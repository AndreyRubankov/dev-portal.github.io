var base =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// identity function for calling harmony imports with the correct context
/******/ 	__webpack_require__.i = function(value) { return value; };
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 63);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {module.exports = global["ko"] = __webpack_require__(4);
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ }),
/* 1 */
/***/ (function(module, exports) {

/*!
 * jQuery JavaScript Library v1.12.4
 * http://jquery.com/
 *
 * Includes Sizzle.js
 * http://sizzlejs.com/
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license
 * http://jquery.org/license
 *
 * Date: 2016-05-20T17:17Z
 */

(function( global, factory ) {

	if ( typeof module === "object" && typeof module.exports === "object" ) {
		// For CommonJS and CommonJS-like environments where a proper `window`
		// is present, execute the factory and get jQuery.
		// For environments that do not have a `window` with a `document`
		// (such as Node.js), expose a factory as module.exports.
		// This accentuates the need for the creation of a real `window`.
		// e.g. var jQuery = require("jquery")(window);
		// See ticket #14549 for more info.
		module.exports = global.document ?
			factory( global, true ) :
			function( w ) {
				if ( !w.document ) {
					throw new Error( "jQuery requires a window with a document" );
				}
				return factory( w );
			};
	} else {
		factory( global );
	}

// Pass this if window is not defined yet
}(typeof window !== "undefined" ? window : this, function( window, noGlobal ) {

// Support: Firefox 18+
// Can't be in strict mode, several libs including ASP.NET trace
// the stack via arguments.caller.callee and Firefox dies if
// you try to trace through "use strict" call chains. (#13335)
//"use strict";
var deletedIds = [];

var document = window.document;

var slice = deletedIds.slice;

var concat = deletedIds.concat;

var push = deletedIds.push;

var indexOf = deletedIds.indexOf;

var class2type = {};

var toString = class2type.toString;

var hasOwn = class2type.hasOwnProperty;

var support = {};



var
	version = "1.12.4",

	// Define a local copy of jQuery
	jQuery = function( selector, context ) {

		// The jQuery object is actually just the init constructor 'enhanced'
		// Need init if jQuery is called (just allow error to be thrown if not included)
		return new jQuery.fn.init( selector, context );
	},

	// Support: Android<4.1, IE<9
	// Make sure we trim BOM and NBSP
	rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,

	// Matches dashed string for camelizing
	rmsPrefix = /^-ms-/,
	rdashAlpha = /-([\da-z])/gi,

	// Used by jQuery.camelCase as callback to replace()
	fcamelCase = function( all, letter ) {
		return letter.toUpperCase();
	};

jQuery.fn = jQuery.prototype = {

	// The current version of jQuery being used
	jquery: version,

	constructor: jQuery,

	// Start with an empty selector
	selector: "",

	// The default length of a jQuery object is 0
	length: 0,

	toArray: function() {
		return slice.call( this );
	},

	// Get the Nth element in the matched element set OR
	// Get the whole matched element set as a clean array
	get: function( num ) {
		return num != null ?

			// Return just the one element from the set
			( num < 0 ? this[ num + this.length ] : this[ num ] ) :

			// Return all the elements in a clean array
			slice.call( this );
	},

	// Take an array of elements and push it onto the stack
	// (returning the new matched element set)
	pushStack: function( elems ) {

		// Build a new jQuery matched element set
		var ret = jQuery.merge( this.constructor(), elems );

		// Add the old object onto the stack (as a reference)
		ret.prevObject = this;
		ret.context = this.context;

		// Return the newly-formed element set
		return ret;
	},

	// Execute a callback for every element in the matched set.
	each: function( callback ) {
		return jQuery.each( this, callback );
	},

	map: function( callback ) {
		return this.pushStack( jQuery.map( this, function( elem, i ) {
			return callback.call( elem, i, elem );
		} ) );
	},

	slice: function() {
		return this.pushStack( slice.apply( this, arguments ) );
	},

	first: function() {
		return this.eq( 0 );
	},

	last: function() {
		return this.eq( -1 );
	},

	eq: function( i ) {
		var len = this.length,
			j = +i + ( i < 0 ? len : 0 );
		return this.pushStack( j >= 0 && j < len ? [ this[ j ] ] : [] );
	},

	end: function() {
		return this.prevObject || this.constructor();
	},

	// For internal use only.
	// Behaves like an Array's method, not like a jQuery method.
	push: push,
	sort: deletedIds.sort,
	splice: deletedIds.splice
};

jQuery.extend = jQuery.fn.extend = function() {
	var src, copyIsArray, copy, name, options, clone,
		target = arguments[ 0 ] || {},
		i = 1,
		length = arguments.length,
		deep = false;

	// Handle a deep copy situation
	if ( typeof target === "boolean" ) {
		deep = target;

		// skip the boolean and the target
		target = arguments[ i ] || {};
		i++;
	}

	// Handle case when target is a string or something (possible in deep copy)
	if ( typeof target !== "object" && !jQuery.isFunction( target ) ) {
		target = {};
	}

	// extend jQuery itself if only one argument is passed
	if ( i === length ) {
		target = this;
		i--;
	}

	for ( ; i < length; i++ ) {

		// Only deal with non-null/undefined values
		if ( ( options = arguments[ i ] ) != null ) {

			// Extend the base object
			for ( name in options ) {
				src = target[ name ];
				copy = options[ name ];

				// Prevent never-ending loop
				if ( target === copy ) {
					continue;
				}

				// Recurse if we're merging plain objects or arrays
				if ( deep && copy && ( jQuery.isPlainObject( copy ) ||
					( copyIsArray = jQuery.isArray( copy ) ) ) ) {

					if ( copyIsArray ) {
						copyIsArray = false;
						clone = src && jQuery.isArray( src ) ? src : [];

					} else {
						clone = src && jQuery.isPlainObject( src ) ? src : {};
					}

					// Never move original objects, clone them
					target[ name ] = jQuery.extend( deep, clone, copy );

				// Don't bring in undefined values
				} else if ( copy !== undefined ) {
					target[ name ] = copy;
				}
			}
		}
	}

	// Return the modified object
	return target;
};

jQuery.extend( {

	// Unique for each copy of jQuery on the page
	expando: "jQuery" + ( version + Math.random() ).replace( /\D/g, "" ),

	// Assume jQuery is ready without the ready module
	isReady: true,

	error: function( msg ) {
		throw new Error( msg );
	},

	noop: function() {},

	// See test/unit/core.js for details concerning isFunction.
	// Since version 1.3, DOM methods and functions like alert
	// aren't supported. They return false on IE (#2968).
	isFunction: function( obj ) {
		return jQuery.type( obj ) === "function";
	},

	isArray: Array.isArray || function( obj ) {
		return jQuery.type( obj ) === "array";
	},

	isWindow: function( obj ) {
		/* jshint eqeqeq: false */
		return obj != null && obj == obj.window;
	},

	isNumeric: function( obj ) {

		// parseFloat NaNs numeric-cast false positives (null|true|false|"")
		// ...but misinterprets leading-number strings, particularly hex literals ("0x...")
		// subtraction forces infinities to NaN
		// adding 1 corrects loss of precision from parseFloat (#15100)
		var realStringObj = obj && obj.toString();
		return !jQuery.isArray( obj ) && ( realStringObj - parseFloat( realStringObj ) + 1 ) >= 0;
	},

	isEmptyObject: function( obj ) {
		var name;
		for ( name in obj ) {
			return false;
		}
		return true;
	},

	isPlainObject: function( obj ) {
		var key;

		// Must be an Object.
		// Because of IE, we also have to check the presence of the constructor property.
		// Make sure that DOM nodes and window objects don't pass through, as well
		if ( !obj || jQuery.type( obj ) !== "object" || obj.nodeType || jQuery.isWindow( obj ) ) {
			return false;
		}

		try {

			// Not own constructor property must be Object
			if ( obj.constructor &&
				!hasOwn.call( obj, "constructor" ) &&
				!hasOwn.call( obj.constructor.prototype, "isPrototypeOf" ) ) {
				return false;
			}
		} catch ( e ) {

			// IE8,9 Will throw exceptions on certain host objects #9897
			return false;
		}

		// Support: IE<9
		// Handle iteration over inherited properties before own properties.
		if ( !support.ownFirst ) {
			for ( key in obj ) {
				return hasOwn.call( obj, key );
			}
		}

		// Own properties are enumerated firstly, so to speed up,
		// if last one is own, then all properties are own.
		for ( key in obj ) {}

		return key === undefined || hasOwn.call( obj, key );
	},

	type: function( obj ) {
		if ( obj == null ) {
			return obj + "";
		}
		return typeof obj === "object" || typeof obj === "function" ?
			class2type[ toString.call( obj ) ] || "object" :
			typeof obj;
	},

	// Workarounds based on findings by Jim Driscoll
	// http://weblogs.java.net/blog/driscoll/archive/2009/09/08/eval-javascript-global-context
	globalEval: function( data ) {
		if ( data && jQuery.trim( data ) ) {

			// We use execScript on Internet Explorer
			// We use an anonymous function so that context is window
			// rather than jQuery in Firefox
			( window.execScript || function( data ) {
				window[ "eval" ].call( window, data ); // jscs:ignore requireDotNotation
			} )( data );
		}
	},

	// Convert dashed to camelCase; used by the css and data modules
	// Microsoft forgot to hump their vendor prefix (#9572)
	camelCase: function( string ) {
		return string.replace( rmsPrefix, "ms-" ).replace( rdashAlpha, fcamelCase );
	},

	nodeName: function( elem, name ) {
		return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();
	},

	each: function( obj, callback ) {
		var length, i = 0;

		if ( isArrayLike( obj ) ) {
			length = obj.length;
			for ( ; i < length; i++ ) {
				if ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {
					break;
				}
			}
		} else {
			for ( i in obj ) {
				if ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {
					break;
				}
			}
		}

		return obj;
	},

	// Support: Android<4.1, IE<9
	trim: function( text ) {
		return text == null ?
			"" :
			( text + "" ).replace( rtrim, "" );
	},

	// results is for internal usage only
	makeArray: function( arr, results ) {
		var ret = results || [];

		if ( arr != null ) {
			if ( isArrayLike( Object( arr ) ) ) {
				jQuery.merge( ret,
					typeof arr === "string" ?
					[ arr ] : arr
				);
			} else {
				push.call( ret, arr );
			}
		}

		return ret;
	},

	inArray: function( elem, arr, i ) {
		var len;

		if ( arr ) {
			if ( indexOf ) {
				return indexOf.call( arr, elem, i );
			}

			len = arr.length;
			i = i ? i < 0 ? Math.max( 0, len + i ) : i : 0;

			for ( ; i < len; i++ ) {

				// Skip accessing in sparse arrays
				if ( i in arr && arr[ i ] === elem ) {
					return i;
				}
			}
		}

		return -1;
	},

	merge: function( first, second ) {
		var len = +second.length,
			j = 0,
			i = first.length;

		while ( j < len ) {
			first[ i++ ] = second[ j++ ];
		}

		// Support: IE<9
		// Workaround casting of .length to NaN on otherwise arraylike objects (e.g., NodeLists)
		if ( len !== len ) {
			while ( second[ j ] !== undefined ) {
				first[ i++ ] = second[ j++ ];
			}
		}

		first.length = i;

		return first;
	},

	grep: function( elems, callback, invert ) {
		var callbackInverse,
			matches = [],
			i = 0,
			length = elems.length,
			callbackExpect = !invert;

		// Go through the array, only saving the items
		// that pass the validator function
		for ( ; i < length; i++ ) {
			callbackInverse = !callback( elems[ i ], i );
			if ( callbackInverse !== callbackExpect ) {
				matches.push( elems[ i ] );
			}
		}

		return matches;
	},

	// arg is for internal usage only
	map: function( elems, callback, arg ) {
		var length, value,
			i = 0,
			ret = [];

		// Go through the array, translating each of the items to their new values
		if ( isArrayLike( elems ) ) {
			length = elems.length;
			for ( ; i < length; i++ ) {
				value = callback( elems[ i ], i, arg );

				if ( value != null ) {
					ret.push( value );
				}
			}

		// Go through every key on the object,
		} else {
			for ( i in elems ) {
				value = callback( elems[ i ], i, arg );

				if ( value != null ) {
					ret.push( value );
				}
			}
		}

		// Flatten any nested arrays
		return concat.apply( [], ret );
	},

	// A global GUID counter for objects
	guid: 1,

	// Bind a function to a context, optionally partially applying any
	// arguments.
	proxy: function( fn, context ) {
		var args, proxy, tmp;

		if ( typeof context === "string" ) {
			tmp = fn[ context ];
			context = fn;
			fn = tmp;
		}

		// Quick check to determine if target is callable, in the spec
		// this throws a TypeError, but we will just return undefined.
		if ( !jQuery.isFunction( fn ) ) {
			return undefined;
		}

		// Simulated bind
		args = slice.call( arguments, 2 );
		proxy = function() {
			return fn.apply( context || this, args.concat( slice.call( arguments ) ) );
		};

		// Set the guid of unique handler to the same of original handler, so it can be removed
		proxy.guid = fn.guid = fn.guid || jQuery.guid++;

		return proxy;
	},

	now: function() {
		return +( new Date() );
	},

	// jQuery.support is not used in Core but other projects attach their
	// properties to it so it needs to exist.
	support: support
} );

// JSHint would error on this code due to the Symbol not being defined in ES5.
// Defining this global in .jshintrc would create a danger of using the global
// unguarded in another place, it seems safer to just disable JSHint for these
// three lines.
/* jshint ignore: start */
if ( typeof Symbol === "function" ) {
	jQuery.fn[ Symbol.iterator ] = deletedIds[ Symbol.iterator ];
}
/* jshint ignore: end */

// Populate the class2type map
jQuery.each( "Boolean Number String Function Array Date RegExp Object Error Symbol".split( " " ),
function( i, name ) {
	class2type[ "[object " + name + "]" ] = name.toLowerCase();
} );

function isArrayLike( obj ) {

	// Support: iOS 8.2 (not reproducible in simulator)
	// `in` check used to prevent JIT error (gh-2145)
	// hasOwn isn't used here due to false negatives
	// regarding Nodelist length in IE
	var length = !!obj && "length" in obj && obj.length,
		type = jQuery.type( obj );

	if ( type === "function" || jQuery.isWindow( obj ) ) {
		return false;
	}

	return type === "array" || length === 0 ||
		typeof length === "number" && length > 0 && ( length - 1 ) in obj;
}
var Sizzle =
/*!
 * Sizzle CSS Selector Engine v2.2.1
 * http://sizzlejs.com/
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license
 * http://jquery.org/license
 *
 * Date: 2015-10-17
 */
(function( window ) {

var i,
	support,
	Expr,
	getText,
	isXML,
	tokenize,
	compile,
	select,
	outermostContext,
	sortInput,
	hasDuplicate,

	// Local document vars
	setDocument,
	document,
	docElem,
	documentIsHTML,
	rbuggyQSA,
	rbuggyMatches,
	matches,
	contains,

	// Instance-specific data
	expando = "sizzle" + 1 * new Date(),
	preferredDoc = window.document,
	dirruns = 0,
	done = 0,
	classCache = createCache(),
	tokenCache = createCache(),
	compilerCache = createCache(),
	sortOrder = function( a, b ) {
		if ( a === b ) {
			hasDuplicate = true;
		}
		return 0;
	},

	// General-purpose constants
	MAX_NEGATIVE = 1 << 31,

	// Instance methods
	hasOwn = ({}).hasOwnProperty,
	arr = [],
	pop = arr.pop,
	push_native = arr.push,
	push = arr.push,
	slice = arr.slice,
	// Use a stripped-down indexOf as it's faster than native
	// http://jsperf.com/thor-indexof-vs-for/5
	indexOf = function( list, elem ) {
		var i = 0,
			len = list.length;
		for ( ; i < len; i++ ) {
			if ( list[i] === elem ) {
				return i;
			}
		}
		return -1;
	},

	booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",

	// Regular expressions

	// http://www.w3.org/TR/css3-selectors/#whitespace
	whitespace = "[\\x20\\t\\r\\n\\f]",

	// http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier
	identifier = "(?:\\\\.|[\\w-]|[^\\x00-\\xa0])+",

	// Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors
	attributes = "\\[" + whitespace + "*(" + identifier + ")(?:" + whitespace +
		// Operator (capture 2)
		"*([*^$|!~]?=)" + whitespace +
		// "Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]"
		"*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + identifier + "))|)" + whitespace +
		"*\\]",

	pseudos = ":(" + identifier + ")(?:\\((" +
		// To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:
		// 1. quoted (capture 3; capture 4 or capture 5)
		"('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|" +
		// 2. simple (capture 6)
		"((?:\\\\.|[^\\\\()[\\]]|" + attributes + ")*)|" +
		// 3. anything else (capture 2)
		".*" +
		")\\)|)",

	// Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter
	rwhitespace = new RegExp( whitespace + "+", "g" ),
	rtrim = new RegExp( "^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$", "g" ),

	rcomma = new RegExp( "^" + whitespace + "*," + whitespace + "*" ),
	rcombinators = new RegExp( "^" + whitespace + "*([>+~]|" + whitespace + ")" + whitespace + "*" ),

	rattributeQuotes = new RegExp( "=" + whitespace + "*([^\\]'\"]*?)" + whitespace + "*\\]", "g" ),

	rpseudo = new RegExp( pseudos ),
	ridentifier = new RegExp( "^" + identifier + "$" ),

	matchExpr = {
		"ID": new RegExp( "^#(" + identifier + ")" ),
		"CLASS": new RegExp( "^\\.(" + identifier + ")" ),
		"TAG": new RegExp( "^(" + identifier + "|[*])" ),
		"ATTR": new RegExp( "^" + attributes ),
		"PSEUDO": new RegExp( "^" + pseudos ),
		"CHILD": new RegExp( "^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + whitespace +
			"*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" + whitespace +
			"*(\\d+)|))" + whitespace + "*\\)|)", "i" ),
		"bool": new RegExp( "^(?:" + booleans + ")$", "i" ),
		// For use in libraries implementing .is()
		// We use this for POS matching in `select`
		"needsContext": new RegExp( "^" + whitespace + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" +
			whitespace + "*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i" )
	},

	rinputs = /^(?:input|select|textarea|button)$/i,
	rheader = /^h\d$/i,

	rnative = /^[^{]+\{\s*\[native \w/,

	// Easily-parseable/retrievable ID or TAG or CLASS selectors
	rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,

	rsibling = /[+~]/,
	rescape = /'|\\/g,

	// CSS escapes http://www.w3.org/TR/CSS21/syndata.html#escaped-characters
	runescape = new RegExp( "\\\\([\\da-f]{1,6}" + whitespace + "?|(" + whitespace + ")|.)", "ig" ),
	funescape = function( _, escaped, escapedWhitespace ) {
		var high = "0x" + escaped - 0x10000;
		// NaN means non-codepoint
		// Support: Firefox<24
		// Workaround erroneous numeric interpretation of +"0x"
		return high !== high || escapedWhitespace ?
			escaped :
			high < 0 ?
				// BMP codepoint
				String.fromCharCode( high + 0x10000 ) :
				// Supplemental Plane codepoint (surrogate pair)
				String.fromCharCode( high >> 10 | 0xD800, high & 0x3FF | 0xDC00 );
	},

	// Used for iframes
	// See setDocument()
	// Removing the function wrapper causes a "Permission Denied"
	// error in IE
	unloadHandler = function() {
		setDocument();
	};

// Optimize for push.apply( _, NodeList )
try {
	push.apply(
		(arr = slice.call( preferredDoc.childNodes )),
		preferredDoc.childNodes
	);
	// Support: Android<4.0
	// Detect silently failing push.apply
	arr[ preferredDoc.childNodes.length ].nodeType;
} catch ( e ) {
	push = { apply: arr.length ?

		// Leverage slice if possible
		function( target, els ) {
			push_native.apply( target, slice.call(els) );
		} :

		// Support: IE<9
		// Otherwise append directly
		function( target, els ) {
			var j = target.length,
				i = 0;
			// Can't trust NodeList.length
			while ( (target[j++] = els[i++]) ) {}
			target.length = j - 1;
		}
	};
}

function Sizzle( selector, context, results, seed ) {
	var m, i, elem, nid, nidselect, match, groups, newSelector,
		newContext = context && context.ownerDocument,

		// nodeType defaults to 9, since context defaults to document
		nodeType = context ? context.nodeType : 9;

	results = results || [];

	// Return early from calls with invalid selector or context
	if ( typeof selector !== "string" || !selector ||
		nodeType !== 1 && nodeType !== 9 && nodeType !== 11 ) {

		return results;
	}

	// Try to shortcut find operations (as opposed to filters) in HTML documents
	if ( !seed ) {

		if ( ( context ? context.ownerDocument || context : preferredDoc ) !== document ) {
			setDocument( context );
		}
		context = context || document;

		if ( documentIsHTML ) {

			// If the selector is sufficiently simple, try using a "get*By*" DOM method
			// (excepting DocumentFragment context, where the methods don't exist)
			if ( nodeType !== 11 && (match = rquickExpr.exec( selector )) ) {

				// ID selector
				if ( (m = match[1]) ) {

					// Document context
					if ( nodeType === 9 ) {
						if ( (elem = context.getElementById( m )) ) {

							// Support: IE, Opera, Webkit
							// TODO: identify versions
							// getElementById can match elements by name instead of ID
							if ( elem.id === m ) {
								results.push( elem );
								return results;
							}
						} else {
							return results;
						}

					// Element context
					} else {

						// Support: IE, Opera, Webkit
						// TODO: identify versions
						// getElementById can match elements by name instead of ID
						if ( newContext && (elem = newContext.getElementById( m )) &&
							contains( context, elem ) &&
							elem.id === m ) {

							results.push( elem );
							return results;
						}
					}

				// Type selector
				} else if ( match[2] ) {
					push.apply( results, context.getElementsByTagName( selector ) );
					return results;

				// Class selector
				} else if ( (m = match[3]) && support.getElementsByClassName &&
					context.getElementsByClassName ) {

					push.apply( results, context.getElementsByClassName( m ) );
					return results;
				}
			}

			// Take advantage of querySelectorAll
			if ( support.qsa &&
				!compilerCache[ selector + " " ] &&
				(!rbuggyQSA || !rbuggyQSA.test( selector )) ) {

				if ( nodeType !== 1 ) {
					newContext = context;
					newSelector = selector;

				// qSA looks outside Element context, which is not what we want
				// Thanks to Andrew Dupont for this workaround technique
				// Support: IE <=8
				// Exclude object elements
				} else if ( context.nodeName.toLowerCase() !== "object" ) {

					// Capture the context ID, setting it first if necessary
					if ( (nid = context.getAttribute( "id" )) ) {
						nid = nid.replace( rescape, "\\$&" );
					} else {
						context.setAttribute( "id", (nid = expando) );
					}

					// Prefix every selector in the list
					groups = tokenize( selector );
					i = groups.length;
					nidselect = ridentifier.test( nid ) ? "#" + nid : "[id='" + nid + "']";
					while ( i-- ) {
						groups[i] = nidselect + " " + toSelector( groups[i] );
					}
					newSelector = groups.join( "," );

					// Expand context for sibling selectors
					newContext = rsibling.test( selector ) && testContext( context.parentNode ) ||
						context;
				}

				if ( newSelector ) {
					try {
						push.apply( results,
							newContext.querySelectorAll( newSelector )
						);
						return results;
					} catch ( qsaError ) {
					} finally {
						if ( nid === expando ) {
							context.removeAttribute( "id" );
						}
					}
				}
			}
		}
	}

	// All others
	return select( selector.replace( rtrim, "$1" ), context, results, seed );
}

/**
 * Create key-value caches of limited size
 * @returns {function(string, object)} Returns the Object data after storing it on itself with
 *	property name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)
 *	deleting the oldest entry
 */
function createCache() {
	var keys = [];

	function cache( key, value ) {
		// Use (key + " ") to avoid collision with native prototype properties (see Issue #157)
		if ( keys.push( key + " " ) > Expr.cacheLength ) {
			// Only keep the most recent entries
			delete cache[ keys.shift() ];
		}
		return (cache[ key + " " ] = value);
	}
	return cache;
}

/**
 * Mark a function for special use by Sizzle
 * @param {Function} fn The function to mark
 */
function markFunction( fn ) {
	fn[ expando ] = true;
	return fn;
}

/**
 * Support testing using an element
 * @param {Function} fn Passed the created div and expects a boolean result
 */
function assert( fn ) {
	var div = document.createElement("div");

	try {
		return !!fn( div );
	} catch (e) {
		return false;
	} finally {
		// Remove from its parent by default
		if ( div.parentNode ) {
			div.parentNode.removeChild( div );
		}
		// release memory in IE
		div = null;
	}
}

/**
 * Adds the same handler for all of the specified attrs
 * @param {String} attrs Pipe-separated list of attributes
 * @param {Function} handler The method that will be applied
 */
function addHandle( attrs, handler ) {
	var arr = attrs.split("|"),
		i = arr.length;

	while ( i-- ) {
		Expr.attrHandle[ arr[i] ] = handler;
	}
}

/**
 * Checks document order of two siblings
 * @param {Element} a
 * @param {Element} b
 * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b
 */
function siblingCheck( a, b ) {
	var cur = b && a,
		diff = cur && a.nodeType === 1 && b.nodeType === 1 &&
			( ~b.sourceIndex || MAX_NEGATIVE ) -
			( ~a.sourceIndex || MAX_NEGATIVE );

	// Use IE sourceIndex if available on both nodes
	if ( diff ) {
		return diff;
	}

	// Check if b follows a
	if ( cur ) {
		while ( (cur = cur.nextSibling) ) {
			if ( cur === b ) {
				return -1;
			}
		}
	}

	return a ? 1 : -1;
}

/**
 * Returns a function to use in pseudos for input types
 * @param {String} type
 */
function createInputPseudo( type ) {
	return function( elem ) {
		var name = elem.nodeName.toLowerCase();
		return name === "input" && elem.type === type;
	};
}

/**
 * Returns a function to use in pseudos for buttons
 * @param {String} type
 */
function createButtonPseudo( type ) {
	return function( elem ) {
		var name = elem.nodeName.toLowerCase();
		return (name === "input" || name === "button") && elem.type === type;
	};
}

/**
 * Returns a function to use in pseudos for positionals
 * @param {Function} fn
 */
function createPositionalPseudo( fn ) {
	return markFunction(function( argument ) {
		argument = +argument;
		return markFunction(function( seed, matches ) {
			var j,
				matchIndexes = fn( [], seed.length, argument ),
				i = matchIndexes.length;

			// Match elements found at the specified indexes
			while ( i-- ) {
				if ( seed[ (j = matchIndexes[i]) ] ) {
					seed[j] = !(matches[j] = seed[j]);
				}
			}
		});
	});
}

/**
 * Checks a node for validity as a Sizzle context
 * @param {Element|Object=} context
 * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value
 */
function testContext( context ) {
	return context && typeof context.getElementsByTagName !== "undefined" && context;
}

// Expose support vars for convenience
support = Sizzle.support = {};

/**
 * Detects XML nodes
 * @param {Element|Object} elem An element or a document
 * @returns {Boolean} True iff elem is a non-HTML XML node
 */
isXML = Sizzle.isXML = function( elem ) {
	// documentElement is verified for cases where it doesn't yet exist
	// (such as loading iframes in IE - #4833)
	var documentElement = elem && (elem.ownerDocument || elem).documentElement;
	return documentElement ? documentElement.nodeName !== "HTML" : false;
};

/**
 * Sets document-related variables once based on the current document
 * @param {Element|Object} [doc] An element or document object to use to set the document
 * @returns {Object} Returns the current document
 */
setDocument = Sizzle.setDocument = function( node ) {
	var hasCompare, parent,
		doc = node ? node.ownerDocument || node : preferredDoc;

	// Return early if doc is invalid or already selected
	if ( doc === document || doc.nodeType !== 9 || !doc.documentElement ) {
		return document;
	}

	// Update global variables
	document = doc;
	docElem = document.documentElement;
	documentIsHTML = !isXML( document );

	// Support: IE 9-11, Edge
	// Accessing iframe documents after unload throws "permission denied" errors (jQuery #13936)
	if ( (parent = document.defaultView) && parent.top !== parent ) {
		// Support: IE 11
		if ( parent.addEventListener ) {
			parent.addEventListener( "unload", unloadHandler, false );

		// Support: IE 9 - 10 only
		} else if ( parent.attachEvent ) {
			parent.attachEvent( "onunload", unloadHandler );
		}
	}

	/* Attributes
	---------------------------------------------------------------------- */

	// Support: IE<8
	// Verify that getAttribute really returns attributes and not properties
	// (excepting IE8 booleans)
	support.attributes = assert(function( div ) {
		div.className = "i";
		return !div.getAttribute("className");
	});

	/* getElement(s)By*
	---------------------------------------------------------------------- */

	// Check if getElementsByTagName("*") returns only elements
	support.getElementsByTagName = assert(function( div ) {
		div.appendChild( document.createComment("") );
		return !div.getElementsByTagName("*").length;
	});

	// Support: IE<9
	support.getElementsByClassName = rnative.test( document.getElementsByClassName );

	// Support: IE<10
	// Check if getElementById returns elements by name
	// The broken getElementById methods don't pick up programatically-set names,
	// so use a roundabout getElementsByName test
	support.getById = assert(function( div ) {
		docElem.appendChild( div ).id = expando;
		return !document.getElementsByName || !document.getElementsByName( expando ).length;
	});

	// ID find and filter
	if ( support.getById ) {
		Expr.find["ID"] = function( id, context ) {
			if ( typeof context.getElementById !== "undefined" && documentIsHTML ) {
				var m = context.getElementById( id );
				return m ? [ m ] : [];
			}
		};
		Expr.filter["ID"] = function( id ) {
			var attrId = id.replace( runescape, funescape );
			return function( elem ) {
				return elem.getAttribute("id") === attrId;
			};
		};
	} else {
		// Support: IE6/7
		// getElementById is not reliable as a find shortcut
		delete Expr.find["ID"];

		Expr.filter["ID"] =  function( id ) {
			var attrId = id.replace( runescape, funescape );
			return function( elem ) {
				var node = typeof elem.getAttributeNode !== "undefined" &&
					elem.getAttributeNode("id");
				return node && node.value === attrId;
			};
		};
	}

	// Tag
	Expr.find["TAG"] = support.getElementsByTagName ?
		function( tag, context ) {
			if ( typeof context.getElementsByTagName !== "undefined" ) {
				return context.getElementsByTagName( tag );

			// DocumentFragment nodes don't have gEBTN
			} else if ( support.qsa ) {
				return context.querySelectorAll( tag );
			}
		} :

		function( tag, context ) {
			var elem,
				tmp = [],
				i = 0,
				// By happy coincidence, a (broken) gEBTN appears on DocumentFragment nodes too
				results = context.getElementsByTagName( tag );

			// Filter out possible comments
			if ( tag === "*" ) {
				while ( (elem = results[i++]) ) {
					if ( elem.nodeType === 1 ) {
						tmp.push( elem );
					}
				}

				return tmp;
			}
			return results;
		};

	// Class
	Expr.find["CLASS"] = support.getElementsByClassName && function( className, context ) {
		if ( typeof context.getElementsByClassName !== "undefined" && documentIsHTML ) {
			return context.getElementsByClassName( className );
		}
	};

	/* QSA/matchesSelector
	---------------------------------------------------------------------- */

	// QSA and matchesSelector support

	// matchesSelector(:active) reports false when true (IE9/Opera 11.5)
	rbuggyMatches = [];

	// qSa(:focus) reports false when true (Chrome 21)
	// We allow this because of a bug in IE8/9 that throws an error
	// whenever `document.activeElement` is accessed on an iframe
	// So, we allow :focus to pass through QSA all the time to avoid the IE error
	// See http://bugs.jquery.com/ticket/13378
	rbuggyQSA = [];

	if ( (support.qsa = rnative.test( document.querySelectorAll )) ) {
		// Build QSA regex
		// Regex strategy adopted from Diego Perini
		assert(function( div ) {
			// Select is set to empty string on purpose
			// This is to test IE's treatment of not explicitly
			// setting a boolean content attribute,
			// since its presence should be enough
			// http://bugs.jquery.com/ticket/12359
			docElem.appendChild( div ).innerHTML = "<a id='" + expando + "'></a>" +
				"<select id='" + expando + "-\r\\' msallowcapture=''>" +
				"<option selected=''></option></select>";

			// Support: IE8, Opera 11-12.16
			// Nothing should be selected when empty strings follow ^= or $= or *=
			// The test attribute must be unknown in Opera but "safe" for WinRT
			// http://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section
			if ( div.querySelectorAll("[msallowcapture^='']").length ) {
				rbuggyQSA.push( "[*^$]=" + whitespace + "*(?:''|\"\")" );
			}

			// Support: IE8
			// Boolean attributes and "value" are not treated correctly
			if ( !div.querySelectorAll("[selected]").length ) {
				rbuggyQSA.push( "\\[" + whitespace + "*(?:value|" + booleans + ")" );
			}

			// Support: Chrome<29, Android<4.4, Safari<7.0+, iOS<7.0+, PhantomJS<1.9.8+
			if ( !div.querySelectorAll( "[id~=" + expando + "-]" ).length ) {
				rbuggyQSA.push("~=");
			}

			// Webkit/Opera - :checked should return selected option elements
			// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
			// IE8 throws error here and will not see later tests
			if ( !div.querySelectorAll(":checked").length ) {
				rbuggyQSA.push(":checked");
			}

			// Support: Safari 8+, iOS 8+
			// https://bugs.webkit.org/show_bug.cgi?id=136851
			// In-page `selector#id sibing-combinator selector` fails
			if ( !div.querySelectorAll( "a#" + expando + "+*" ).length ) {
				rbuggyQSA.push(".#.+[+~]");
			}
		});

		assert(function( div ) {
			// Support: Windows 8 Native Apps
			// The type and name attributes are restricted during .innerHTML assignment
			var input = document.createElement("input");
			input.setAttribute( "type", "hidden" );
			div.appendChild( input ).setAttribute( "name", "D" );

			// Support: IE8
			// Enforce case-sensitivity of name attribute
			if ( div.querySelectorAll("[name=d]").length ) {
				rbuggyQSA.push( "name" + whitespace + "*[*^$|!~]?=" );
			}

			// FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)
			// IE8 throws error here and will not see later tests
			if ( !div.querySelectorAll(":enabled").length ) {
				rbuggyQSA.push( ":enabled", ":disabled" );
			}

			// Opera 10-11 does not throw on post-comma invalid pseudos
			div.querySelectorAll("*,:x");
			rbuggyQSA.push(",.*:");
		});
	}

	if ( (support.matchesSelector = rnative.test( (matches = docElem.matches ||
		docElem.webkitMatchesSelector ||
		docElem.mozMatchesSelector ||
		docElem.oMatchesSelector ||
		docElem.msMatchesSelector) )) ) {

		assert(function( div ) {
			// Check to see if it's possible to do matchesSelector
			// on a disconnected node (IE 9)
			support.disconnectedMatch = matches.call( div, "div" );

			// This should fail with an exception
			// Gecko does not error, returns false instead
			matches.call( div, "[s!='']:x" );
			rbuggyMatches.push( "!=", pseudos );
		});
	}

	rbuggyQSA = rbuggyQSA.length && new RegExp( rbuggyQSA.join("|") );
	rbuggyMatches = rbuggyMatches.length && new RegExp( rbuggyMatches.join("|") );

	/* Contains
	---------------------------------------------------------------------- */
	hasCompare = rnative.test( docElem.compareDocumentPosition );

	// Element contains another
	// Purposefully self-exclusive
	// As in, an element does not contain itself
	contains = hasCompare || rnative.test( docElem.contains ) ?
		function( a, b ) {
			var adown = a.nodeType === 9 ? a.documentElement : a,
				bup = b && b.parentNode;
			return a === bup || !!( bup && bup.nodeType === 1 && (
				adown.contains ?
					adown.contains( bup ) :
					a.compareDocumentPosition && a.compareDocumentPosition( bup ) & 16
			));
		} :
		function( a, b ) {
			if ( b ) {
				while ( (b = b.parentNode) ) {
					if ( b === a ) {
						return true;
					}
				}
			}
			return false;
		};

	/* Sorting
	---------------------------------------------------------------------- */

	// Document order sorting
	sortOrder = hasCompare ?
	function( a, b ) {

		// Flag for duplicate removal
		if ( a === b ) {
			hasDuplicate = true;
			return 0;
		}

		// Sort on method existence if only one input has compareDocumentPosition
		var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
		if ( compare ) {
			return compare;
		}

		// Calculate position if both inputs belong to the same document
		compare = ( a.ownerDocument || a ) === ( b.ownerDocument || b ) ?
			a.compareDocumentPosition( b ) :

			// Otherwise we know they are disconnected
			1;

		// Disconnected nodes
		if ( compare & 1 ||
			(!support.sortDetached && b.compareDocumentPosition( a ) === compare) ) {

			// Choose the first element that is related to our preferred document
			if ( a === document || a.ownerDocument === preferredDoc && contains(preferredDoc, a) ) {
				return -1;
			}
			if ( b === document || b.ownerDocument === preferredDoc && contains(preferredDoc, b) ) {
				return 1;
			}

			// Maintain original order
			return sortInput ?
				( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :
				0;
		}

		return compare & 4 ? -1 : 1;
	} :
	function( a, b ) {
		// Exit early if the nodes are identical
		if ( a === b ) {
			hasDuplicate = true;
			return 0;
		}

		var cur,
			i = 0,
			aup = a.parentNode,
			bup = b.parentNode,
			ap = [ a ],
			bp = [ b ];

		// Parentless nodes are either documents or disconnected
		if ( !aup || !bup ) {
			return a === document ? -1 :
				b === document ? 1 :
				aup ? -1 :
				bup ? 1 :
				sortInput ?
				( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :
				0;

		// If the nodes are siblings, we can do a quick check
		} else if ( aup === bup ) {
			return siblingCheck( a, b );
		}

		// Otherwise we need full lists of their ancestors for comparison
		cur = a;
		while ( (cur = cur.parentNode) ) {
			ap.unshift( cur );
		}
		cur = b;
		while ( (cur = cur.parentNode) ) {
			bp.unshift( cur );
		}

		// Walk down the tree looking for a discrepancy
		while ( ap[i] === bp[i] ) {
			i++;
		}

		return i ?
			// Do a sibling check if the nodes have a common ancestor
			siblingCheck( ap[i], bp[i] ) :

			// Otherwise nodes in our document sort first
			ap[i] === preferredDoc ? -1 :
			bp[i] === preferredDoc ? 1 :
			0;
	};

	return document;
};

Sizzle.matches = function( expr, elements ) {
	return Sizzle( expr, null, null, elements );
};

Sizzle.matchesSelector = function( elem, expr ) {
	// Set document vars if needed
	if ( ( elem.ownerDocument || elem ) !== document ) {
		setDocument( elem );
	}

	// Make sure that attribute selectors are quoted
	expr = expr.replace( rattributeQuotes, "='$1']" );

	if ( support.matchesSelector && documentIsHTML &&
		!compilerCache[ expr + " " ] &&
		( !rbuggyMatches || !rbuggyMatches.test( expr ) ) &&
		( !rbuggyQSA     || !rbuggyQSA.test( expr ) ) ) {

		try {
			var ret = matches.call( elem, expr );

			// IE 9's matchesSelector returns false on disconnected nodes
			if ( ret || support.disconnectedMatch ||
					// As well, disconnected nodes are said to be in a document
					// fragment in IE 9
					elem.document && elem.document.nodeType !== 11 ) {
				return ret;
			}
		} catch (e) {}
	}

	return Sizzle( expr, document, null, [ elem ] ).length > 0;
};

Sizzle.contains = function( context, elem ) {
	// Set document vars if needed
	if ( ( context.ownerDocument || context ) !== document ) {
		setDocument( context );
	}
	return contains( context, elem );
};

Sizzle.attr = function( elem, name ) {
	// Set document vars if needed
	if ( ( elem.ownerDocument || elem ) !== document ) {
		setDocument( elem );
	}

	var fn = Expr.attrHandle[ name.toLowerCase() ],
		// Don't get fooled by Object.prototype properties (jQuery #13807)
		val = fn && hasOwn.call( Expr.attrHandle, name.toLowerCase() ) ?
			fn( elem, name, !documentIsHTML ) :
			undefined;

	return val !== undefined ?
		val :
		support.attributes || !documentIsHTML ?
			elem.getAttribute( name ) :
			(val = elem.getAttributeNode(name)) && val.specified ?
				val.value :
				null;
};

Sizzle.error = function( msg ) {
	throw new Error( "Syntax error, unrecognized expression: " + msg );
};

/**
 * Document sorting and removing duplicates
 * @param {ArrayLike} results
 */
Sizzle.uniqueSort = function( results ) {
	var elem,
		duplicates = [],
		j = 0,
		i = 0;

	// Unless we *know* we can detect duplicates, assume their presence
	hasDuplicate = !support.detectDuplicates;
	sortInput = !support.sortStable && results.slice( 0 );
	results.sort( sortOrder );

	if ( hasDuplicate ) {
		while ( (elem = results[i++]) ) {
			if ( elem === results[ i ] ) {
				j = duplicates.push( i );
			}
		}
		while ( j-- ) {
			results.splice( duplicates[ j ], 1 );
		}
	}

	// Clear input after sorting to release objects
	// See https://github.com/jquery/sizzle/pull/225
	sortInput = null;

	return results;
};

/**
 * Utility function for retrieving the text value of an array of DOM nodes
 * @param {Array|Element} elem
 */
getText = Sizzle.getText = function( elem ) {
	var node,
		ret = "",
		i = 0,
		nodeType = elem.nodeType;

	if ( !nodeType ) {
		// If no nodeType, this is expected to be an array
		while ( (node = elem[i++]) ) {
			// Do not traverse comment nodes
			ret += getText( node );
		}
	} else if ( nodeType === 1 || nodeType === 9 || nodeType === 11 ) {
		// Use textContent for elements
		// innerText usage removed for consistency of new lines (jQuery #11153)
		if ( typeof elem.textContent === "string" ) {
			return elem.textContent;
		} else {
			// Traverse its children
			for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
				ret += getText( elem );
			}
		}
	} else if ( nodeType === 3 || nodeType === 4 ) {
		return elem.nodeValue;
	}
	// Do not include comment or processing instruction nodes

	return ret;
};

Expr = Sizzle.selectors = {

	// Can be adjusted by the user
	cacheLength: 50,

	createPseudo: markFunction,

	match: matchExpr,

	attrHandle: {},

	find: {},

	relative: {
		">": { dir: "parentNode", first: true },
		" ": { dir: "parentNode" },
		"+": { dir: "previousSibling", first: true },
		"~": { dir: "previousSibling" }
	},

	preFilter: {
		"ATTR": function( match ) {
			match[1] = match[1].replace( runescape, funescape );

			// Move the given value to match[3] whether quoted or unquoted
			match[3] = ( match[3] || match[4] || match[5] || "" ).replace( runescape, funescape );

			if ( match[2] === "~=" ) {
				match[3] = " " + match[3] + " ";
			}

			return match.slice( 0, 4 );
		},

		"CHILD": function( match ) {
			/* matches from matchExpr["CHILD"]
				1 type (only|nth|...)
				2 what (child|of-type)
				3 argument (even|odd|\d*|\d*n([+-]\d+)?|...)
				4 xn-component of xn+y argument ([+-]?\d*n|)
				5 sign of xn-component
				6 x of xn-component
				7 sign of y-component
				8 y of y-component
			*/
			match[1] = match[1].toLowerCase();

			if ( match[1].slice( 0, 3 ) === "nth" ) {
				// nth-* requires argument
				if ( !match[3] ) {
					Sizzle.error( match[0] );
				}

				// numeric x and y parameters for Expr.filter.CHILD
				// remember that false/true cast respectively to 0/1
				match[4] = +( match[4] ? match[5] + (match[6] || 1) : 2 * ( match[3] === "even" || match[3] === "odd" ) );
				match[5] = +( ( match[7] + match[8] ) || match[3] === "odd" );

			// other types prohibit arguments
			} else if ( match[3] ) {
				Sizzle.error( match[0] );
			}

			return match;
		},

		"PSEUDO": function( match ) {
			var excess,
				unquoted = !match[6] && match[2];

			if ( matchExpr["CHILD"].test( match[0] ) ) {
				return null;
			}

			// Accept quoted arguments as-is
			if ( match[3] ) {
				match[2] = match[4] || match[5] || "";

			// Strip excess characters from unquoted arguments
			} else if ( unquoted && rpseudo.test( unquoted ) &&
				// Get excess from tokenize (recursively)
				(excess = tokenize( unquoted, true )) &&
				// advance to the next closing parenthesis
				(excess = unquoted.indexOf( ")", unquoted.length - excess ) - unquoted.length) ) {

				// excess is a negative index
				match[0] = match[0].slice( 0, excess );
				match[2] = unquoted.slice( 0, excess );
			}

			// Return only captures needed by the pseudo filter method (type and argument)
			return match.slice( 0, 3 );
		}
	},

	filter: {

		"TAG": function( nodeNameSelector ) {
			var nodeName = nodeNameSelector.replace( runescape, funescape ).toLowerCase();
			return nodeNameSelector === "*" ?
				function() { return true; } :
				function( elem ) {
					return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;
				};
		},

		"CLASS": function( className ) {
			var pattern = classCache[ className + " " ];

			return pattern ||
				(pattern = new RegExp( "(^|" + whitespace + ")" + className + "(" + whitespace + "|$)" )) &&
				classCache( className, function( elem ) {
					return pattern.test( typeof elem.className === "string" && elem.className || typeof elem.getAttribute !== "undefined" && elem.getAttribute("class") || "" );
				});
		},

		"ATTR": function( name, operator, check ) {
			return function( elem ) {
				var result = Sizzle.attr( elem, name );

				if ( result == null ) {
					return operator === "!=";
				}
				if ( !operator ) {
					return true;
				}

				result += "";

				return operator === "=" ? result === check :
					operator === "!=" ? result !== check :
					operator === "^=" ? check && result.indexOf( check ) === 0 :
					operator === "*=" ? check && result.indexOf( check ) > -1 :
					operator === "$=" ? check && result.slice( -check.length ) === check :
					operator === "~=" ? ( " " + result.replace( rwhitespace, " " ) + " " ).indexOf( check ) > -1 :
					operator === "|=" ? result === check || result.slice( 0, check.length + 1 ) === check + "-" :
					false;
			};
		},

		"CHILD": function( type, what, argument, first, last ) {
			var simple = type.slice( 0, 3 ) !== "nth",
				forward = type.slice( -4 ) !== "last",
				ofType = what === "of-type";

			return first === 1 && last === 0 ?

				// Shortcut for :nth-*(n)
				function( elem ) {
					return !!elem.parentNode;
				} :

				function( elem, context, xml ) {
					var cache, uniqueCache, outerCache, node, nodeIndex, start,
						dir = simple !== forward ? "nextSibling" : "previousSibling",
						parent = elem.parentNode,
						name = ofType && elem.nodeName.toLowerCase(),
						useCache = !xml && !ofType,
						diff = false;

					if ( parent ) {

						// :(first|last|only)-(child|of-type)
						if ( simple ) {
							while ( dir ) {
								node = elem;
								while ( (node = node[ dir ]) ) {
									if ( ofType ?
										node.nodeName.toLowerCase() === name :
										node.nodeType === 1 ) {

										return false;
									}
								}
								// Reverse direction for :only-* (if we haven't yet done so)
								start = dir = type === "only" && !start && "nextSibling";
							}
							return true;
						}

						start = [ forward ? parent.firstChild : parent.lastChild ];

						// non-xml :nth-child(...) stores cache data on `parent`
						if ( forward && useCache ) {

							// Seek `elem` from a previously-cached index

							// ...in a gzip-friendly way
							node = parent;
							outerCache = node[ expando ] || (node[ expando ] = {});

							// Support: IE <9 only
							// Defend against cloned attroperties (jQuery gh-1709)
							uniqueCache = outerCache[ node.uniqueID ] ||
								(outerCache[ node.uniqueID ] = {});

							cache = uniqueCache[ type ] || [];
							nodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];
							diff = nodeIndex && cache[ 2 ];
							node = nodeIndex && parent.childNodes[ nodeIndex ];

							while ( (node = ++nodeIndex && node && node[ dir ] ||

								// Fallback to seeking `elem` from the start
								(diff = nodeIndex = 0) || start.pop()) ) {

								// When found, cache indexes on `parent` and break
								if ( node.nodeType === 1 && ++diff && node === elem ) {
									uniqueCache[ type ] = [ dirruns, nodeIndex, diff ];
									break;
								}
							}

						} else {
							// Use previously-cached element index if available
							if ( useCache ) {
								// ...in a gzip-friendly way
								node = elem;
								outerCache = node[ expando ] || (node[ expando ] = {});

								// Support: IE <9 only
								// Defend against cloned attroperties (jQuery gh-1709)
								uniqueCache = outerCache[ node.uniqueID ] ||
									(outerCache[ node.uniqueID ] = {});

								cache = uniqueCache[ type ] || [];
								nodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];
								diff = nodeIndex;
							}

							// xml :nth-child(...)
							// or :nth-last-child(...) or :nth(-last)?-of-type(...)
							if ( diff === false ) {
								// Use the same loop as above to seek `elem` from the start
								while ( (node = ++nodeIndex && node && node[ dir ] ||
									(diff = nodeIndex = 0) || start.pop()) ) {

									if ( ( ofType ?
										node.nodeName.toLowerCase() === name :
										node.nodeType === 1 ) &&
										++diff ) {

										// Cache the index of each encountered element
										if ( useCache ) {
											outerCache = node[ expando ] || (node[ expando ] = {});

											// Support: IE <9 only
											// Defend against cloned attroperties (jQuery gh-1709)
											uniqueCache = outerCache[ node.uniqueID ] ||
												(outerCache[ node.uniqueID ] = {});

											uniqueCache[ type ] = [ dirruns, diff ];
										}

										if ( node === elem ) {
											break;
										}
									}
								}
							}
						}

						// Incorporate the offset, then check against cycle size
						diff -= last;
						return diff === first || ( diff % first === 0 && diff / first >= 0 );
					}
				};
		},

		"PSEUDO": function( pseudo, argument ) {
			// pseudo-class names are case-insensitive
			// http://www.w3.org/TR/selectors/#pseudo-classes
			// Prioritize by case sensitivity in case custom pseudos are added with uppercase letters
			// Remember that setFilters inherits from pseudos
			var args,
				fn = Expr.pseudos[ pseudo ] || Expr.setFilters[ pseudo.toLowerCase() ] ||
					Sizzle.error( "unsupported pseudo: " + pseudo );

			// The user may use createPseudo to indicate that
			// arguments are needed to create the filter function
			// just as Sizzle does
			if ( fn[ expando ] ) {
				return fn( argument );
			}

			// But maintain support for old signatures
			if ( fn.length > 1 ) {
				args = [ pseudo, pseudo, "", argument ];
				return Expr.setFilters.hasOwnProperty( pseudo.toLowerCase() ) ?
					markFunction(function( seed, matches ) {
						var idx,
							matched = fn( seed, argument ),
							i = matched.length;
						while ( i-- ) {
							idx = indexOf( seed, matched[i] );
							seed[ idx ] = !( matches[ idx ] = matched[i] );
						}
					}) :
					function( elem ) {
						return fn( elem, 0, args );
					};
			}

			return fn;
		}
	},

	pseudos: {
		// Potentially complex pseudos
		"not": markFunction(function( selector ) {
			// Trim the selector passed to compile
			// to avoid treating leading and trailing
			// spaces as combinators
			var input = [],
				results = [],
				matcher = compile( selector.replace( rtrim, "$1" ) );

			return matcher[ expando ] ?
				markFunction(function( seed, matches, context, xml ) {
					var elem,
						unmatched = matcher( seed, null, xml, [] ),
						i = seed.length;

					// Match elements unmatched by `matcher`
					while ( i-- ) {
						if ( (elem = unmatched[i]) ) {
							seed[i] = !(matches[i] = elem);
						}
					}
				}) :
				function( elem, context, xml ) {
					input[0] = elem;
					matcher( input, null, xml, results );
					// Don't keep the element (issue #299)
					input[0] = null;
					return !results.pop();
				};
		}),

		"has": markFunction(function( selector ) {
			return function( elem ) {
				return Sizzle( selector, elem ).length > 0;
			};
		}),

		"contains": markFunction(function( text ) {
			text = text.replace( runescape, funescape );
			return function( elem ) {
				return ( elem.textContent || elem.innerText || getText( elem ) ).indexOf( text ) > -1;
			};
		}),

		// "Whether an element is represented by a :lang() selector
		// is based solely on the element's language value
		// being equal to the identifier C,
		// or beginning with the identifier C immediately followed by "-".
		// The matching of C against the element's language value is performed case-insensitively.
		// The identifier C does not have to be a valid language name."
		// http://www.w3.org/TR/selectors/#lang-pseudo
		"lang": markFunction( function( lang ) {
			// lang value must be a valid identifier
			if ( !ridentifier.test(lang || "") ) {
				Sizzle.error( "unsupported lang: " + lang );
			}
			lang = lang.replace( runescape, funescape ).toLowerCase();
			return function( elem ) {
				var elemLang;
				do {
					if ( (elemLang = documentIsHTML ?
						elem.lang :
						elem.getAttribute("xml:lang") || elem.getAttribute("lang")) ) {

						elemLang = elemLang.toLowerCase();
						return elemLang === lang || elemLang.indexOf( lang + "-" ) === 0;
					}
				} while ( (elem = elem.parentNode) && elem.nodeType === 1 );
				return false;
			};
		}),

		// Miscellaneous
		"target": function( elem ) {
			var hash = window.location && window.location.hash;
			return hash && hash.slice( 1 ) === elem.id;
		},

		"root": function( elem ) {
			return elem === docElem;
		},

		"focus": function( elem ) {
			return elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);
		},

		// Boolean properties
		"enabled": function( elem ) {
			return elem.disabled === false;
		},

		"disabled": function( elem ) {
			return elem.disabled === true;
		},

		"checked": function( elem ) {
			// In CSS3, :checked should return both checked and selected elements
			// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
			var nodeName = elem.nodeName.toLowerCase();
			return (nodeName === "input" && !!elem.checked) || (nodeName === "option" && !!elem.selected);
		},

		"selected": function( elem ) {
			// Accessing this property makes selected-by-default
			// options in Safari work properly
			if ( elem.parentNode ) {
				elem.parentNode.selectedIndex;
			}

			return elem.selected === true;
		},

		// Contents
		"empty": function( elem ) {
			// http://www.w3.org/TR/selectors/#empty-pseudo
			// :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),
			//   but not by others (comment: 8; processing instruction: 7; etc.)
			// nodeType < 6 works because attributes (2) do not appear as children
			for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
				if ( elem.nodeType < 6 ) {
					return false;
				}
			}
			return true;
		},

		"parent": function( elem ) {
			return !Expr.pseudos["empty"]( elem );
		},

		// Element/input types
		"header": function( elem ) {
			return rheader.test( elem.nodeName );
		},

		"input": function( elem ) {
			return rinputs.test( elem.nodeName );
		},

		"button": function( elem ) {
			var name = elem.nodeName.toLowerCase();
			return name === "input" && elem.type === "button" || name === "button";
		},

		"text": function( elem ) {
			var attr;
			return elem.nodeName.toLowerCase() === "input" &&
				elem.type === "text" &&

				// Support: IE<8
				// New HTML5 attribute values (e.g., "search") appear with elem.type === "text"
				( (attr = elem.getAttribute("type")) == null || attr.toLowerCase() === "text" );
		},

		// Position-in-collection
		"first": createPositionalPseudo(function() {
			return [ 0 ];
		}),

		"last": createPositionalPseudo(function( matchIndexes, length ) {
			return [ length - 1 ];
		}),

		"eq": createPositionalPseudo(function( matchIndexes, length, argument ) {
			return [ argument < 0 ? argument + length : argument ];
		}),

		"even": createPositionalPseudo(function( matchIndexes, length ) {
			var i = 0;
			for ( ; i < length; i += 2 ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		}),

		"odd": createPositionalPseudo(function( matchIndexes, length ) {
			var i = 1;
			for ( ; i < length; i += 2 ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		}),

		"lt": createPositionalPseudo(function( matchIndexes, length, argument ) {
			var i = argument < 0 ? argument + length : argument;
			for ( ; --i >= 0; ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		}),

		"gt": createPositionalPseudo(function( matchIndexes, length, argument ) {
			var i = argument < 0 ? argument + length : argument;
			for ( ; ++i < length; ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		})
	}
};

Expr.pseudos["nth"] = Expr.pseudos["eq"];

// Add button/input type pseudos
for ( i in { radio: true, checkbox: true, file: true, password: true, image: true } ) {
	Expr.pseudos[ i ] = createInputPseudo( i );
}
for ( i in { submit: true, reset: true } ) {
	Expr.pseudos[ i ] = createButtonPseudo( i );
}

// Easy API for creating new setFilters
function setFilters() {}
setFilters.prototype = Expr.filters = Expr.pseudos;
Expr.setFilters = new setFilters();

tokenize = Sizzle.tokenize = function( selector, parseOnly ) {
	var matched, match, tokens, type,
		soFar, groups, preFilters,
		cached = tokenCache[ selector + " " ];

	if ( cached ) {
		return parseOnly ? 0 : cached.slice( 0 );
	}

	soFar = selector;
	groups = [];
	preFilters = Expr.preFilter;

	while ( soFar ) {

		// Comma and first run
		if ( !matched || (match = rcomma.exec( soFar )) ) {
			if ( match ) {
				// Don't consume trailing commas as valid
				soFar = soFar.slice( match[0].length ) || soFar;
			}
			groups.push( (tokens = []) );
		}

		matched = false;

		// Combinators
		if ( (match = rcombinators.exec( soFar )) ) {
			matched = match.shift();
			tokens.push({
				value: matched,
				// Cast descendant combinators to space
				type: match[0].replace( rtrim, " " )
			});
			soFar = soFar.slice( matched.length );
		}

		// Filters
		for ( type in Expr.filter ) {
			if ( (match = matchExpr[ type ].exec( soFar )) && (!preFilters[ type ] ||
				(match = preFilters[ type ]( match ))) ) {
				matched = match.shift();
				tokens.push({
					value: matched,
					type: type,
					matches: match
				});
				soFar = soFar.slice( matched.length );
			}
		}

		if ( !matched ) {
			break;
		}
	}

	// Return the length of the invalid excess
	// if we're just parsing
	// Otherwise, throw an error or return tokens
	return parseOnly ?
		soFar.length :
		soFar ?
			Sizzle.error( selector ) :
			// Cache the tokens
			tokenCache( selector, groups ).slice( 0 );
};

function toSelector( tokens ) {
	var i = 0,
		len = tokens.length,
		selector = "";
	for ( ; i < len; i++ ) {
		selector += tokens[i].value;
	}
	return selector;
}

function addCombinator( matcher, combinator, base ) {
	var dir = combinator.dir,
		checkNonElements = base && dir === "parentNode",
		doneName = done++;

	return combinator.first ?
		// Check against closest ancestor/preceding element
		function( elem, context, xml ) {
			while ( (elem = elem[ dir ]) ) {
				if ( elem.nodeType === 1 || checkNonElements ) {
					return matcher( elem, context, xml );
				}
			}
		} :

		// Check against all ancestor/preceding elements
		function( elem, context, xml ) {
			var oldCache, uniqueCache, outerCache,
				newCache = [ dirruns, doneName ];

			// We can't set arbitrary data on XML nodes, so they don't benefit from combinator caching
			if ( xml ) {
				while ( (elem = elem[ dir ]) ) {
					if ( elem.nodeType === 1 || checkNonElements ) {
						if ( matcher( elem, context, xml ) ) {
							return true;
						}
					}
				}
			} else {
				while ( (elem = elem[ dir ]) ) {
					if ( elem.nodeType === 1 || checkNonElements ) {
						outerCache = elem[ expando ] || (elem[ expando ] = {});

						// Support: IE <9 only
						// Defend against cloned attroperties (jQuery gh-1709)
						uniqueCache = outerCache[ elem.uniqueID ] || (outerCache[ elem.uniqueID ] = {});

						if ( (oldCache = uniqueCache[ dir ]) &&
							oldCache[ 0 ] === dirruns && oldCache[ 1 ] === doneName ) {

							// Assign to newCache so results back-propagate to previous elements
							return (newCache[ 2 ] = oldCache[ 2 ]);
						} else {
							// Reuse newcache so results back-propagate to previous elements
							uniqueCache[ dir ] = newCache;

							// A match means we're done; a fail means we have to keep checking
							if ( (newCache[ 2 ] = matcher( elem, context, xml )) ) {
								return true;
							}
						}
					}
				}
			}
		};
}

function elementMatcher( matchers ) {
	return matchers.length > 1 ?
		function( elem, context, xml ) {
			var i = matchers.length;
			while ( i-- ) {
				if ( !matchers[i]( elem, context, xml ) ) {
					return false;
				}
			}
			return true;
		} :
		matchers[0];
}

function multipleContexts( selector, contexts, results ) {
	var i = 0,
		len = contexts.length;
	for ( ; i < len; i++ ) {
		Sizzle( selector, contexts[i], results );
	}
	return results;
}

function condense( unmatched, map, filter, context, xml ) {
	var elem,
		newUnmatched = [],
		i = 0,
		len = unmatched.length,
		mapped = map != null;

	for ( ; i < len; i++ ) {
		if ( (elem = unmatched[i]) ) {
			if ( !filter || filter( elem, context, xml ) ) {
				newUnmatched.push( elem );
				if ( mapped ) {
					map.push( i );
				}
			}
		}
	}

	return newUnmatched;
}

function setMatcher( preFilter, selector, matcher, postFilter, postFinder, postSelector ) {
	if ( postFilter && !postFilter[ expando ] ) {
		postFilter = setMatcher( postFilter );
	}
	if ( postFinder && !postFinder[ expando ] ) {
		postFinder = setMatcher( postFinder, postSelector );
	}
	return markFunction(function( seed, results, context, xml ) {
		var temp, i, elem,
			preMap = [],
			postMap = [],
			preexisting = results.length,

			// Get initial elements from seed or context
			elems = seed || multipleContexts( selector || "*", context.nodeType ? [ context ] : context, [] ),

			// Prefilter to get matcher input, preserving a map for seed-results synchronization
			matcherIn = preFilter && ( seed || !selector ) ?
				condense( elems, preMap, preFilter, context, xml ) :
				elems,

			matcherOut = matcher ?
				// If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,
				postFinder || ( seed ? preFilter : preexisting || postFilter ) ?

					// ...intermediate processing is necessary
					[] :

					// ...otherwise use results directly
					results :
				matcherIn;

		// Find primary matches
		if ( matcher ) {
			matcher( matcherIn, matcherOut, context, xml );
		}

		// Apply postFilter
		if ( postFilter ) {
			temp = condense( matcherOut, postMap );
			postFilter( temp, [], context, xml );

			// Un-match failing elements by moving them back to matcherIn
			i = temp.length;
			while ( i-- ) {
				if ( (elem = temp[i]) ) {
					matcherOut[ postMap[i] ] = !(matcherIn[ postMap[i] ] = elem);
				}
			}
		}

		if ( seed ) {
			if ( postFinder || preFilter ) {
				if ( postFinder ) {
					// Get the final matcherOut by condensing this intermediate into postFinder contexts
					temp = [];
					i = matcherOut.length;
					while ( i-- ) {
						if ( (elem = matcherOut[i]) ) {
							// Restore matcherIn since elem is not yet a final match
							temp.push( (matcherIn[i] = elem) );
						}
					}
					postFinder( null, (matcherOut = []), temp, xml );
				}

				// Move matched elements from seed to results to keep them synchronized
				i = matcherOut.length;
				while ( i-- ) {
					if ( (elem = matcherOut[i]) &&
						(temp = postFinder ? indexOf( seed, elem ) : preMap[i]) > -1 ) {

						seed[temp] = !(results[temp] = elem);
					}
				}
			}

		// Add elements to results, through postFinder if defined
		} else {
			matcherOut = condense(
				matcherOut === results ?
					matcherOut.splice( preexisting, matcherOut.length ) :
					matcherOut
			);
			if ( postFinder ) {
				postFinder( null, results, matcherOut, xml );
			} else {
				push.apply( results, matcherOut );
			}
		}
	});
}

function matcherFromTokens( tokens ) {
	var checkContext, matcher, j,
		len = tokens.length,
		leadingRelative = Expr.relative[ tokens[0].type ],
		implicitRelative = leadingRelative || Expr.relative[" "],
		i = leadingRelative ? 1 : 0,

		// The foundational matcher ensures that elements are reachable from top-level context(s)
		matchContext = addCombinator( function( elem ) {
			return elem === checkContext;
		}, implicitRelative, true ),
		matchAnyContext = addCombinator( function( elem ) {
			return indexOf( checkContext, elem ) > -1;
		}, implicitRelative, true ),
		matchers = [ function( elem, context, xml ) {
			var ret = ( !leadingRelative && ( xml || context !== outermostContext ) ) || (
				(checkContext = context).nodeType ?
					matchContext( elem, context, xml ) :
					matchAnyContext( elem, context, xml ) );
			// Avoid hanging onto element (issue #299)
			checkContext = null;
			return ret;
		} ];

	for ( ; i < len; i++ ) {
		if ( (matcher = Expr.relative[ tokens[i].type ]) ) {
			matchers = [ addCombinator(elementMatcher( matchers ), matcher) ];
		} else {
			matcher = Expr.filter[ tokens[i].type ].apply( null, tokens[i].matches );

			// Return special upon seeing a positional matcher
			if ( matcher[ expando ] ) {
				// Find the next relative operator (if any) for proper handling
				j = ++i;
				for ( ; j < len; j++ ) {
					if ( Expr.relative[ tokens[j].type ] ) {
						break;
					}
				}
				return setMatcher(
					i > 1 && elementMatcher( matchers ),
					i > 1 && toSelector(
						// If the preceding token was a descendant combinator, insert an implicit any-element `*`
						tokens.slice( 0, i - 1 ).concat({ value: tokens[ i - 2 ].type === " " ? "*" : "" })
					).replace( rtrim, "$1" ),
					matcher,
					i < j && matcherFromTokens( tokens.slice( i, j ) ),
					j < len && matcherFromTokens( (tokens = tokens.slice( j )) ),
					j < len && toSelector( tokens )
				);
			}
			matchers.push( matcher );
		}
	}

	return elementMatcher( matchers );
}

function matcherFromGroupMatchers( elementMatchers, setMatchers ) {
	var bySet = setMatchers.length > 0,
		byElement = elementMatchers.length > 0,
		superMatcher = function( seed, context, xml, results, outermost ) {
			var elem, j, matcher,
				matchedCount = 0,
				i = "0",
				unmatched = seed && [],
				setMatched = [],
				contextBackup = outermostContext,
				// We must always have either seed elements or outermost context
				elems = seed || byElement && Expr.find["TAG"]( "*", outermost ),
				// Use integer dirruns iff this is the outermost matcher
				dirrunsUnique = (dirruns += contextBackup == null ? 1 : Math.random() || 0.1),
				len = elems.length;

			if ( outermost ) {
				outermostContext = context === document || context || outermost;
			}

			// Add elements passing elementMatchers directly to results
			// Support: IE<9, Safari
			// Tolerate NodeList properties (IE: "length"; Safari: <number>) matching elements by id
			for ( ; i !== len && (elem = elems[i]) != null; i++ ) {
				if ( byElement && elem ) {
					j = 0;
					if ( !context && elem.ownerDocument !== document ) {
						setDocument( elem );
						xml = !documentIsHTML;
					}
					while ( (matcher = elementMatchers[j++]) ) {
						if ( matcher( elem, context || document, xml) ) {
							results.push( elem );
							break;
						}
					}
					if ( outermost ) {
						dirruns = dirrunsUnique;
					}
				}

				// Track unmatched elements for set filters
				if ( bySet ) {
					// They will have gone through all possible matchers
					if ( (elem = !matcher && elem) ) {
						matchedCount--;
					}

					// Lengthen the array for every element, matched or not
					if ( seed ) {
						unmatched.push( elem );
					}
				}
			}

			// `i` is now the count of elements visited above, and adding it to `matchedCount`
			// makes the latter nonnegative.
			matchedCount += i;

			// Apply set filters to unmatched elements
			// NOTE: This can be skipped if there are no unmatched elements (i.e., `matchedCount`
			// equals `i`), unless we didn't visit _any_ elements in the above loop because we have
			// no element matchers and no seed.
			// Incrementing an initially-string "0" `i` allows `i` to remain a string only in that
			// case, which will result in a "00" `matchedCount` that differs from `i` but is also
			// numerically zero.
			if ( bySet && i !== matchedCount ) {
				j = 0;
				while ( (matcher = setMatchers[j++]) ) {
					matcher( unmatched, setMatched, context, xml );
				}

				if ( seed ) {
					// Reintegrate element matches to eliminate the need for sorting
					if ( matchedCount > 0 ) {
						while ( i-- ) {
							if ( !(unmatched[i] || setMatched[i]) ) {
								setMatched[i] = pop.call( results );
							}
						}
					}

					// Discard index placeholder values to get only actual matches
					setMatched = condense( setMatched );
				}

				// Add matches to results
				push.apply( results, setMatched );

				// Seedless set matches succeeding multiple successful matchers stipulate sorting
				if ( outermost && !seed && setMatched.length > 0 &&
					( matchedCount + setMatchers.length ) > 1 ) {

					Sizzle.uniqueSort( results );
				}
			}

			// Override manipulation of globals by nested matchers
			if ( outermost ) {
				dirruns = dirrunsUnique;
				outermostContext = contextBackup;
			}

			return unmatched;
		};

	return bySet ?
		markFunction( superMatcher ) :
		superMatcher;
}

compile = Sizzle.compile = function( selector, match /* Internal Use Only */ ) {
	var i,
		setMatchers = [],
		elementMatchers = [],
		cached = compilerCache[ selector + " " ];

	if ( !cached ) {
		// Generate a function of recursive functions that can be used to check each element
		if ( !match ) {
			match = tokenize( selector );
		}
		i = match.length;
		while ( i-- ) {
			cached = matcherFromTokens( match[i] );
			if ( cached[ expando ] ) {
				setMatchers.push( cached );
			} else {
				elementMatchers.push( cached );
			}
		}

		// Cache the compiled function
		cached = compilerCache( selector, matcherFromGroupMatchers( elementMatchers, setMatchers ) );

		// Save selector and tokenization
		cached.selector = selector;
	}
	return cached;
};

/**
 * A low-level selection function that works with Sizzle's compiled
 *  selector functions
 * @param {String|Function} selector A selector or a pre-compiled
 *  selector function built with Sizzle.compile
 * @param {Element} context
 * @param {Array} [results]
 * @param {Array} [seed] A set of elements to match against
 */
select = Sizzle.select = function( selector, context, results, seed ) {
	var i, tokens, token, type, find,
		compiled = typeof selector === "function" && selector,
		match = !seed && tokenize( (selector = compiled.selector || selector) );

	results = results || [];

	// Try to minimize operations if there is only one selector in the list and no seed
	// (the latter of which guarantees us context)
	if ( match.length === 1 ) {

		// Reduce context if the leading compound selector is an ID
		tokens = match[0] = match[0].slice( 0 );
		if ( tokens.length > 2 && (token = tokens[0]).type === "ID" &&
				support.getById && context.nodeType === 9 && documentIsHTML &&
				Expr.relative[ tokens[1].type ] ) {

			context = ( Expr.find["ID"]( token.matches[0].replace(runescape, funescape), context ) || [] )[0];
			if ( !context ) {
				return results;

			// Precompiled matchers will still verify ancestry, so step up a level
			} else if ( compiled ) {
				context = context.parentNode;
			}

			selector = selector.slice( tokens.shift().value.length );
		}

		// Fetch a seed set for right-to-left matching
		i = matchExpr["needsContext"].test( selector ) ? 0 : tokens.length;
		while ( i-- ) {
			token = tokens[i];

			// Abort if we hit a combinator
			if ( Expr.relative[ (type = token.type) ] ) {
				break;
			}
			if ( (find = Expr.find[ type ]) ) {
				// Search, expanding context for leading sibling combinators
				if ( (seed = find(
					token.matches[0].replace( runescape, funescape ),
					rsibling.test( tokens[0].type ) && testContext( context.parentNode ) || context
				)) ) {

					// If seed is empty or no tokens remain, we can return early
					tokens.splice( i, 1 );
					selector = seed.length && toSelector( tokens );
					if ( !selector ) {
						push.apply( results, seed );
						return results;
					}

					break;
				}
			}
		}
	}

	// Compile and execute a filtering function if one is not provided
	// Provide `match` to avoid retokenization if we modified the selector above
	( compiled || compile( selector, match ) )(
		seed,
		context,
		!documentIsHTML,
		results,
		!context || rsibling.test( selector ) && testContext( context.parentNode ) || context
	);
	return results;
};

// One-time assignments

// Sort stability
support.sortStable = expando.split("").sort( sortOrder ).join("") === expando;

// Support: Chrome 14-35+
// Always assume duplicates if they aren't passed to the comparison function
support.detectDuplicates = !!hasDuplicate;

// Initialize against the default document
setDocument();

// Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)
// Detached nodes confoundingly follow *each other*
support.sortDetached = assert(function( div1 ) {
	// Should return 1, but returns 4 (following)
	return div1.compareDocumentPosition( document.createElement("div") ) & 1;
});

// Support: IE<8
// Prevent attribute/property "interpolation"
// http://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx
if ( !assert(function( div ) {
	div.innerHTML = "<a href='#'></a>";
	return div.firstChild.getAttribute("href") === "#" ;
}) ) {
	addHandle( "type|href|height|width", function( elem, name, isXML ) {
		if ( !isXML ) {
			return elem.getAttribute( name, name.toLowerCase() === "type" ? 1 : 2 );
		}
	});
}

// Support: IE<9
// Use defaultValue in place of getAttribute("value")
if ( !support.attributes || !assert(function( div ) {
	div.innerHTML = "<input/>";
	div.firstChild.setAttribute( "value", "" );
	return div.firstChild.getAttribute( "value" ) === "";
}) ) {
	addHandle( "value", function( elem, name, isXML ) {
		if ( !isXML && elem.nodeName.toLowerCase() === "input" ) {
			return elem.defaultValue;
		}
	});
}

// Support: IE<9
// Use getAttributeNode to fetch booleans when getAttribute lies
if ( !assert(function( div ) {
	return div.getAttribute("disabled") == null;
}) ) {
	addHandle( booleans, function( elem, name, isXML ) {
		var val;
		if ( !isXML ) {
			return elem[ name ] === true ? name.toLowerCase() :
					(val = elem.getAttributeNode( name )) && val.specified ?
					val.value :
				null;
		}
	});
}

return Sizzle;

})( window );



jQuery.find = Sizzle;
jQuery.expr = Sizzle.selectors;
jQuery.expr[ ":" ] = jQuery.expr.pseudos;
jQuery.uniqueSort = jQuery.unique = Sizzle.uniqueSort;
jQuery.text = Sizzle.getText;
jQuery.isXMLDoc = Sizzle.isXML;
jQuery.contains = Sizzle.contains;



var dir = function( elem, dir, until ) {
	var matched = [],
		truncate = until !== undefined;

	while ( ( elem = elem[ dir ] ) && elem.nodeType !== 9 ) {
		if ( elem.nodeType === 1 ) {
			if ( truncate && jQuery( elem ).is( until ) ) {
				break;
			}
			matched.push( elem );
		}
	}
	return matched;
};


var siblings = function( n, elem ) {
	var matched = [];

	for ( ; n; n = n.nextSibling ) {
		if ( n.nodeType === 1 && n !== elem ) {
			matched.push( n );
		}
	}

	return matched;
};


var rneedsContext = jQuery.expr.match.needsContext;

var rsingleTag = ( /^<([\w-]+)\s*\/?>(?:<\/\1>|)$/ );



var risSimple = /^.[^:#\[\.,]*$/;

// Implement the identical functionality for filter and not
function winnow( elements, qualifier, not ) {
	if ( jQuery.isFunction( qualifier ) ) {
		return jQuery.grep( elements, function( elem, i ) {
			/* jshint -W018 */
			return !!qualifier.call( elem, i, elem ) !== not;
		} );

	}

	if ( qualifier.nodeType ) {
		return jQuery.grep( elements, function( elem ) {
			return ( elem === qualifier ) !== not;
		} );

	}

	if ( typeof qualifier === "string" ) {
		if ( risSimple.test( qualifier ) ) {
			return jQuery.filter( qualifier, elements, not );
		}

		qualifier = jQuery.filter( qualifier, elements );
	}

	return jQuery.grep( elements, function( elem ) {
		return ( jQuery.inArray( elem, qualifier ) > -1 ) !== not;
	} );
}

jQuery.filter = function( expr, elems, not ) {
	var elem = elems[ 0 ];

	if ( not ) {
		expr = ":not(" + expr + ")";
	}

	return elems.length === 1 && elem.nodeType === 1 ?
		jQuery.find.matchesSelector( elem, expr ) ? [ elem ] : [] :
		jQuery.find.matches( expr, jQuery.grep( elems, function( elem ) {
			return elem.nodeType === 1;
		} ) );
};

jQuery.fn.extend( {
	find: function( selector ) {
		var i,
			ret = [],
			self = this,
			len = self.length;

		if ( typeof selector !== "string" ) {
			return this.pushStack( jQuery( selector ).filter( function() {
				for ( i = 0; i < len; i++ ) {
					if ( jQuery.contains( self[ i ], this ) ) {
						return true;
					}
				}
			} ) );
		}

		for ( i = 0; i < len; i++ ) {
			jQuery.find( selector, self[ i ], ret );
		}

		// Needed because $( selector, context ) becomes $( context ).find( selector )
		ret = this.pushStack( len > 1 ? jQuery.unique( ret ) : ret );
		ret.selector = this.selector ? this.selector + " " + selector : selector;
		return ret;
	},
	filter: function( selector ) {
		return this.pushStack( winnow( this, selector || [], false ) );
	},
	not: function( selector ) {
		return this.pushStack( winnow( this, selector || [], true ) );
	},
	is: function( selector ) {
		return !!winnow(
			this,

			// If this is a positional/relative selector, check membership in the returned set
			// so $("p:first").is("p:last") won't return true for a doc with two "p".
			typeof selector === "string" && rneedsContext.test( selector ) ?
				jQuery( selector ) :
				selector || [],
			false
		).length;
	}
} );


// Initialize a jQuery object


// A central reference to the root jQuery(document)
var rootjQuery,

	// A simple way to check for HTML strings
	// Prioritize #id over <tag> to avoid XSS via location.hash (#9521)
	// Strict HTML recognition (#11290: must start with <)
	rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]*))$/,

	init = jQuery.fn.init = function( selector, context, root ) {
		var match, elem;

		// HANDLE: $(""), $(null), $(undefined), $(false)
		if ( !selector ) {
			return this;
		}

		// init accepts an alternate rootjQuery
		// so migrate can support jQuery.sub (gh-2101)
		root = root || rootjQuery;

		// Handle HTML strings
		if ( typeof selector === "string" ) {
			if ( selector.charAt( 0 ) === "<" &&
				selector.charAt( selector.length - 1 ) === ">" &&
				selector.length >= 3 ) {

				// Assume that strings that start and end with <> are HTML and skip the regex check
				match = [ null, selector, null ];

			} else {
				match = rquickExpr.exec( selector );
			}

			// Match html or make sure no context is specified for #id
			if ( match && ( match[ 1 ] || !context ) ) {

				// HANDLE: $(html) -> $(array)
				if ( match[ 1 ] ) {
					context = context instanceof jQuery ? context[ 0 ] : context;

					// scripts is true for back-compat
					// Intentionally let the error be thrown if parseHTML is not present
					jQuery.merge( this, jQuery.parseHTML(
						match[ 1 ],
						context && context.nodeType ? context.ownerDocument || context : document,
						true
					) );

					// HANDLE: $(html, props)
					if ( rsingleTag.test( match[ 1 ] ) && jQuery.isPlainObject( context ) ) {
						for ( match in context ) {

							// Properties of context are called as methods if possible
							if ( jQuery.isFunction( this[ match ] ) ) {
								this[ match ]( context[ match ] );

							// ...and otherwise set as attributes
							} else {
								this.attr( match, context[ match ] );
							}
						}
					}

					return this;

				// HANDLE: $(#id)
				} else {
					elem = document.getElementById( match[ 2 ] );

					// Check parentNode to catch when Blackberry 4.6 returns
					// nodes that are no longer in the document #6963
					if ( elem && elem.parentNode ) {

						// Handle the case where IE and Opera return items
						// by name instead of ID
						if ( elem.id !== match[ 2 ] ) {
							return rootjQuery.find( selector );
						}

						// Otherwise, we inject the element directly into the jQuery object
						this.length = 1;
						this[ 0 ] = elem;
					}

					this.context = document;
					this.selector = selector;
					return this;
				}

			// HANDLE: $(expr, $(...))
			} else if ( !context || context.jquery ) {
				return ( context || root ).find( selector );

			// HANDLE: $(expr, context)
			// (which is just equivalent to: $(context).find(expr)
			} else {
				return this.constructor( context ).find( selector );
			}

		// HANDLE: $(DOMElement)
		} else if ( selector.nodeType ) {
			this.context = this[ 0 ] = selector;
			this.length = 1;
			return this;

		// HANDLE: $(function)
		// Shortcut for document ready
		} else if ( jQuery.isFunction( selector ) ) {
			return typeof root.ready !== "undefined" ?
				root.ready( selector ) :

				// Execute immediately if ready is not present
				selector( jQuery );
		}

		if ( selector.selector !== undefined ) {
			this.selector = selector.selector;
			this.context = selector.context;
		}

		return jQuery.makeArray( selector, this );
	};

// Give the init function the jQuery prototype for later instantiation
init.prototype = jQuery.fn;

// Initialize central reference
rootjQuery = jQuery( document );


var rparentsprev = /^(?:parents|prev(?:Until|All))/,

	// methods guaranteed to produce a unique set when starting from a unique set
	guaranteedUnique = {
		children: true,
		contents: true,
		next: true,
		prev: true
	};

jQuery.fn.extend( {
	has: function( target ) {
		var i,
			targets = jQuery( target, this ),
			len = targets.length;

		return this.filter( function() {
			for ( i = 0; i < len; i++ ) {
				if ( jQuery.contains( this, targets[ i ] ) ) {
					return true;
				}
			}
		} );
	},

	closest: function( selectors, context ) {
		var cur,
			i = 0,
			l = this.length,
			matched = [],
			pos = rneedsContext.test( selectors ) || typeof selectors !== "string" ?
				jQuery( selectors, context || this.context ) :
				0;

		for ( ; i < l; i++ ) {
			for ( cur = this[ i ]; cur && cur !== context; cur = cur.parentNode ) {

				// Always skip document fragments
				if ( cur.nodeType < 11 && ( pos ?
					pos.index( cur ) > -1 :

					// Don't pass non-elements to Sizzle
					cur.nodeType === 1 &&
						jQuery.find.matchesSelector( cur, selectors ) ) ) {

					matched.push( cur );
					break;
				}
			}
		}

		return this.pushStack( matched.length > 1 ? jQuery.uniqueSort( matched ) : matched );
	},

	// Determine the position of an element within
	// the matched set of elements
	index: function( elem ) {

		// No argument, return index in parent
		if ( !elem ) {
			return ( this[ 0 ] && this[ 0 ].parentNode ) ? this.first().prevAll().length : -1;
		}

		// index in selector
		if ( typeof elem === "string" ) {
			return jQuery.inArray( this[ 0 ], jQuery( elem ) );
		}

		// Locate the position of the desired element
		return jQuery.inArray(

			// If it receives a jQuery object, the first element is used
			elem.jquery ? elem[ 0 ] : elem, this );
	},

	add: function( selector, context ) {
		return this.pushStack(
			jQuery.uniqueSort(
				jQuery.merge( this.get(), jQuery( selector, context ) )
			)
		);
	},

	addBack: function( selector ) {
		return this.add( selector == null ?
			this.prevObject : this.prevObject.filter( selector )
		);
	}
} );

function sibling( cur, dir ) {
	do {
		cur = cur[ dir ];
	} while ( cur && cur.nodeType !== 1 );

	return cur;
}

jQuery.each( {
	parent: function( elem ) {
		var parent = elem.parentNode;
		return parent && parent.nodeType !== 11 ? parent : null;
	},
	parents: function( elem ) {
		return dir( elem, "parentNode" );
	},
	parentsUntil: function( elem, i, until ) {
		return dir( elem, "parentNode", until );
	},
	next: function( elem ) {
		return sibling( elem, "nextSibling" );
	},
	prev: function( elem ) {
		return sibling( elem, "previousSibling" );
	},
	nextAll: function( elem ) {
		return dir( elem, "nextSibling" );
	},
	prevAll: function( elem ) {
		return dir( elem, "previousSibling" );
	},
	nextUntil: function( elem, i, until ) {
		return dir( elem, "nextSibling", until );
	},
	prevUntil: function( elem, i, until ) {
		return dir( elem, "previousSibling", until );
	},
	siblings: function( elem ) {
		return siblings( ( elem.parentNode || {} ).firstChild, elem );
	},
	children: function( elem ) {
		return siblings( elem.firstChild );
	},
	contents: function( elem ) {
		return jQuery.nodeName( elem, "iframe" ) ?
			elem.contentDocument || elem.contentWindow.document :
			jQuery.merge( [], elem.childNodes );
	}
}, function( name, fn ) {
	jQuery.fn[ name ] = function( until, selector ) {
		var ret = jQuery.map( this, fn, until );

		if ( name.slice( -5 ) !== "Until" ) {
			selector = until;
		}

		if ( selector && typeof selector === "string" ) {
			ret = jQuery.filter( selector, ret );
		}

		if ( this.length > 1 ) {

			// Remove duplicates
			if ( !guaranteedUnique[ name ] ) {
				ret = jQuery.uniqueSort( ret );
			}

			// Reverse order for parents* and prev-derivatives
			if ( rparentsprev.test( name ) ) {
				ret = ret.reverse();
			}
		}

		return this.pushStack( ret );
	};
} );
var rnotwhite = ( /\S+/g );



// Convert String-formatted options into Object-formatted ones
function createOptions( options ) {
	var object = {};
	jQuery.each( options.match( rnotwhite ) || [], function( _, flag ) {
		object[ flag ] = true;
	} );
	return object;
}

/*
 * Create a callback list using the following parameters:
 *
 *	options: an optional list of space-separated options that will change how
 *			the callback list behaves or a more traditional option object
 *
 * By default a callback list will act like an event callback list and can be
 * "fired" multiple times.
 *
 * Possible options:
 *
 *	once:			will ensure the callback list can only be fired once (like a Deferred)
 *
 *	memory:			will keep track of previous values and will call any callback added
 *					after the list has been fired right away with the latest "memorized"
 *					values (like a Deferred)
 *
 *	unique:			will ensure a callback can only be added once (no duplicate in the list)
 *
 *	stopOnFalse:	interrupt callings when a callback returns false
 *
 */
jQuery.Callbacks = function( options ) {

	// Convert options from String-formatted to Object-formatted if needed
	// (we check in cache first)
	options = typeof options === "string" ?
		createOptions( options ) :
		jQuery.extend( {}, options );

	var // Flag to know if list is currently firing
		firing,

		// Last fire value for non-forgettable lists
		memory,

		// Flag to know if list was already fired
		fired,

		// Flag to prevent firing
		locked,

		// Actual callback list
		list = [],

		// Queue of execution data for repeatable lists
		queue = [],

		// Index of currently firing callback (modified by add/remove as needed)
		firingIndex = -1,

		// Fire callbacks
		fire = function() {

			// Enforce single-firing
			locked = options.once;

			// Execute callbacks for all pending executions,
			// respecting firingIndex overrides and runtime changes
			fired = firing = true;
			for ( ; queue.length; firingIndex = -1 ) {
				memory = queue.shift();
				while ( ++firingIndex < list.length ) {

					// Run callback and check for early termination
					if ( list[ firingIndex ].apply( memory[ 0 ], memory[ 1 ] ) === false &&
						options.stopOnFalse ) {

						// Jump to end and forget the data so .add doesn't re-fire
						firingIndex = list.length;
						memory = false;
					}
				}
			}

			// Forget the data if we're done with it
			if ( !options.memory ) {
				memory = false;
			}

			firing = false;

			// Clean up if we're done firing for good
			if ( locked ) {

				// Keep an empty list if we have data for future add calls
				if ( memory ) {
					list = [];

				// Otherwise, this object is spent
				} else {
					list = "";
				}
			}
		},

		// Actual Callbacks object
		self = {

			// Add a callback or a collection of callbacks to the list
			add: function() {
				if ( list ) {

					// If we have memory from a past run, we should fire after adding
					if ( memory && !firing ) {
						firingIndex = list.length - 1;
						queue.push( memory );
					}

					( function add( args ) {
						jQuery.each( args, function( _, arg ) {
							if ( jQuery.isFunction( arg ) ) {
								if ( !options.unique || !self.has( arg ) ) {
									list.push( arg );
								}
							} else if ( arg && arg.length && jQuery.type( arg ) !== "string" ) {

								// Inspect recursively
								add( arg );
							}
						} );
					} )( arguments );

					if ( memory && !firing ) {
						fire();
					}
				}
				return this;
			},

			// Remove a callback from the list
			remove: function() {
				jQuery.each( arguments, function( _, arg ) {
					var index;
					while ( ( index = jQuery.inArray( arg, list, index ) ) > -1 ) {
						list.splice( index, 1 );

						// Handle firing indexes
						if ( index <= firingIndex ) {
							firingIndex--;
						}
					}
				} );
				return this;
			},

			// Check if a given callback is in the list.
			// If no argument is given, return whether or not list has callbacks attached.
			has: function( fn ) {
				return fn ?
					jQuery.inArray( fn, list ) > -1 :
					list.length > 0;
			},

			// Remove all callbacks from the list
			empty: function() {
				if ( list ) {
					list = [];
				}
				return this;
			},

			// Disable .fire and .add
			// Abort any current/pending executions
			// Clear all callbacks and values
			disable: function() {
				locked = queue = [];
				list = memory = "";
				return this;
			},
			disabled: function() {
				return !list;
			},

			// Disable .fire
			// Also disable .add unless we have memory (since it would have no effect)
			// Abort any pending executions
			lock: function() {
				locked = true;
				if ( !memory ) {
					self.disable();
				}
				return this;
			},
			locked: function() {
				return !!locked;
			},

			// Call all callbacks with the given context and arguments
			fireWith: function( context, args ) {
				if ( !locked ) {
					args = args || [];
					args = [ context, args.slice ? args.slice() : args ];
					queue.push( args );
					if ( !firing ) {
						fire();
					}
				}
				return this;
			},

			// Call all the callbacks with the given arguments
			fire: function() {
				self.fireWith( this, arguments );
				return this;
			},

			// To know if the callbacks have already been called at least once
			fired: function() {
				return !!fired;
			}
		};

	return self;
};


jQuery.extend( {

	Deferred: function( func ) {
		var tuples = [

				// action, add listener, listener list, final state
				[ "resolve", "done", jQuery.Callbacks( "once memory" ), "resolved" ],
				[ "reject", "fail", jQuery.Callbacks( "once memory" ), "rejected" ],
				[ "notify", "progress", jQuery.Callbacks( "memory" ) ]
			],
			state = "pending",
			promise = {
				state: function() {
					return state;
				},
				always: function() {
					deferred.done( arguments ).fail( arguments );
					return this;
				},
				then: function( /* fnDone, fnFail, fnProgress */ ) {
					var fns = arguments;
					return jQuery.Deferred( function( newDefer ) {
						jQuery.each( tuples, function( i, tuple ) {
							var fn = jQuery.isFunction( fns[ i ] ) && fns[ i ];

							// deferred[ done | fail | progress ] for forwarding actions to newDefer
							deferred[ tuple[ 1 ] ]( function() {
								var returned = fn && fn.apply( this, arguments );
								if ( returned && jQuery.isFunction( returned.promise ) ) {
									returned.promise()
										.progress( newDefer.notify )
										.done( newDefer.resolve )
										.fail( newDefer.reject );
								} else {
									newDefer[ tuple[ 0 ] + "With" ](
										this === promise ? newDefer.promise() : this,
										fn ? [ returned ] : arguments
									);
								}
							} );
						} );
						fns = null;
					} ).promise();
				},

				// Get a promise for this deferred
				// If obj is provided, the promise aspect is added to the object
				promise: function( obj ) {
					return obj != null ? jQuery.extend( obj, promise ) : promise;
				}
			},
			deferred = {};

		// Keep pipe for back-compat
		promise.pipe = promise.then;

		// Add list-specific methods
		jQuery.each( tuples, function( i, tuple ) {
			var list = tuple[ 2 ],
				stateString = tuple[ 3 ];

			// promise[ done | fail | progress ] = list.add
			promise[ tuple[ 1 ] ] = list.add;

			// Handle state
			if ( stateString ) {
				list.add( function() {

					// state = [ resolved | rejected ]
					state = stateString;

				// [ reject_list | resolve_list ].disable; progress_list.lock
				}, tuples[ i ^ 1 ][ 2 ].disable, tuples[ 2 ][ 2 ].lock );
			}

			// deferred[ resolve | reject | notify ]
			deferred[ tuple[ 0 ] ] = function() {
				deferred[ tuple[ 0 ] + "With" ]( this === deferred ? promise : this, arguments );
				return this;
			};
			deferred[ tuple[ 0 ] + "With" ] = list.fireWith;
		} );

		// Make the deferred a promise
		promise.promise( deferred );

		// Call given func if any
		if ( func ) {
			func.call( deferred, deferred );
		}

		// All done!
		return deferred;
	},

	// Deferred helper
	when: function( subordinate /* , ..., subordinateN */ ) {
		var i = 0,
			resolveValues = slice.call( arguments ),
			length = resolveValues.length,

			// the count of uncompleted subordinates
			remaining = length !== 1 ||
				( subordinate && jQuery.isFunction( subordinate.promise ) ) ? length : 0,

			// the master Deferred.
			// If resolveValues consist of only a single Deferred, just use that.
			deferred = remaining === 1 ? subordinate : jQuery.Deferred(),

			// Update function for both resolve and progress values
			updateFunc = function( i, contexts, values ) {
				return function( value ) {
					contexts[ i ] = this;
					values[ i ] = arguments.length > 1 ? slice.call( arguments ) : value;
					if ( values === progressValues ) {
						deferred.notifyWith( contexts, values );

					} else if ( !( --remaining ) ) {
						deferred.resolveWith( contexts, values );
					}
				};
			},

			progressValues, progressContexts, resolveContexts;

		// add listeners to Deferred subordinates; treat others as resolved
		if ( length > 1 ) {
			progressValues = new Array( length );
			progressContexts = new Array( length );
			resolveContexts = new Array( length );
			for ( ; i < length; i++ ) {
				if ( resolveValues[ i ] && jQuery.isFunction( resolveValues[ i ].promise ) ) {
					resolveValues[ i ].promise()
						.progress( updateFunc( i, progressContexts, progressValues ) )
						.done( updateFunc( i, resolveContexts, resolveValues ) )
						.fail( deferred.reject );
				} else {
					--remaining;
				}
			}
		}

		// if we're not waiting on anything, resolve the master
		if ( !remaining ) {
			deferred.resolveWith( resolveContexts, resolveValues );
		}

		return deferred.promise();
	}
} );


// The deferred used on DOM ready
var readyList;

jQuery.fn.ready = function( fn ) {

	// Add the callback
	jQuery.ready.promise().done( fn );

	return this;
};

jQuery.extend( {

	// Is the DOM ready to be used? Set to true once it occurs.
	isReady: false,

	// A counter to track how many items to wait for before
	// the ready event fires. See #6781
	readyWait: 1,

	// Hold (or release) the ready event
	holdReady: function( hold ) {
		if ( hold ) {
			jQuery.readyWait++;
		} else {
			jQuery.ready( true );
		}
	},

	// Handle when the DOM is ready
	ready: function( wait ) {

		// Abort if there are pending holds or we're already ready
		if ( wait === true ? --jQuery.readyWait : jQuery.isReady ) {
			return;
		}

		// Remember that the DOM is ready
		jQuery.isReady = true;

		// If a normal DOM Ready event fired, decrement, and wait if need be
		if ( wait !== true && --jQuery.readyWait > 0 ) {
			return;
		}

		// If there are functions bound, to execute
		readyList.resolveWith( document, [ jQuery ] );

		// Trigger any bound ready events
		if ( jQuery.fn.triggerHandler ) {
			jQuery( document ).triggerHandler( "ready" );
			jQuery( document ).off( "ready" );
		}
	}
} );

/**
 * Clean-up method for dom ready events
 */
function detach() {
	if ( document.addEventListener ) {
		document.removeEventListener( "DOMContentLoaded", completed );
		window.removeEventListener( "load", completed );

	} else {
		document.detachEvent( "onreadystatechange", completed );
		window.detachEvent( "onload", completed );
	}
}

/**
 * The ready event handler and self cleanup method
 */
function completed() {

	// readyState === "complete" is good enough for us to call the dom ready in oldIE
	if ( document.addEventListener ||
		window.event.type === "load" ||
		document.readyState === "complete" ) {

		detach();
		jQuery.ready();
	}
}

jQuery.ready.promise = function( obj ) {
	if ( !readyList ) {

		readyList = jQuery.Deferred();

		// Catch cases where $(document).ready() is called
		// after the browser event has already occurred.
		// Support: IE6-10
		// Older IE sometimes signals "interactive" too soon
		if ( document.readyState === "complete" ||
			( document.readyState !== "loading" && !document.documentElement.doScroll ) ) {

			// Handle it asynchronously to allow scripts the opportunity to delay ready
			window.setTimeout( jQuery.ready );

		// Standards-based browsers support DOMContentLoaded
		} else if ( document.addEventListener ) {

			// Use the handy event callback
			document.addEventListener( "DOMContentLoaded", completed );

			// A fallback to window.onload, that will always work
			window.addEventListener( "load", completed );

		// If IE event model is used
		} else {

			// Ensure firing before onload, maybe late but safe also for iframes
			document.attachEvent( "onreadystatechange", completed );

			// A fallback to window.onload, that will always work
			window.attachEvent( "onload", completed );

			// If IE and not a frame
			// continually check to see if the document is ready
			var top = false;

			try {
				top = window.frameElement == null && document.documentElement;
			} catch ( e ) {}

			if ( top && top.doScroll ) {
				( function doScrollCheck() {
					if ( !jQuery.isReady ) {

						try {

							// Use the trick by Diego Perini
							// http://javascript.nwbox.com/IEContentLoaded/
							top.doScroll( "left" );
						} catch ( e ) {
							return window.setTimeout( doScrollCheck, 50 );
						}

						// detach all dom ready events
						detach();

						// and execute any waiting functions
						jQuery.ready();
					}
				} )();
			}
		}
	}
	return readyList.promise( obj );
};

// Kick off the DOM ready check even if the user does not
jQuery.ready.promise();




// Support: IE<9
// Iteration over object's inherited properties before its own
var i;
for ( i in jQuery( support ) ) {
	break;
}
support.ownFirst = i === "0";

// Note: most support tests are defined in their respective modules.
// false until the test is run
support.inlineBlockNeedsLayout = false;

// Execute ASAP in case we need to set body.style.zoom
jQuery( function() {

	// Minified: var a,b,c,d
	var val, div, body, container;

	body = document.getElementsByTagName( "body" )[ 0 ];
	if ( !body || !body.style ) {

		// Return for frameset docs that don't have a body
		return;
	}

	// Setup
	div = document.createElement( "div" );
	container = document.createElement( "div" );
	container.style.cssText = "position:absolute;border:0;width:0;height:0;top:0;left:-9999px";
	body.appendChild( container ).appendChild( div );

	if ( typeof div.style.zoom !== "undefined" ) {

		// Support: IE<8
		// Check if natively block-level elements act like inline-block
		// elements when setting their display to 'inline' and giving
		// them layout
		div.style.cssText = "display:inline;margin:0;border:0;padding:1px;width:1px;zoom:1";

		support.inlineBlockNeedsLayout = val = div.offsetWidth === 3;
		if ( val ) {

			// Prevent IE 6 from affecting layout for positioned elements #11048
			// Prevent IE from shrinking the body in IE 7 mode #12869
			// Support: IE<8
			body.style.zoom = 1;
		}
	}

	body.removeChild( container );
} );


( function() {
	var div = document.createElement( "div" );

	// Support: IE<9
	support.deleteExpando = true;
	try {
		delete div.test;
	} catch ( e ) {
		support.deleteExpando = false;
	}

	// Null elements to avoid leaks in IE.
	div = null;
} )();
var acceptData = function( elem ) {
	var noData = jQuery.noData[ ( elem.nodeName + " " ).toLowerCase() ],
		nodeType = +elem.nodeType || 1;

	// Do not set data on non-element DOM nodes because it will not be cleared (#8335).
	return nodeType !== 1 && nodeType !== 9 ?
		false :

		// Nodes accept data unless otherwise specified; rejection can be conditional
		!noData || noData !== true && elem.getAttribute( "classid" ) === noData;
};




var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
	rmultiDash = /([A-Z])/g;

function dataAttr( elem, key, data ) {

	// If nothing was found internally, try to fetch any
	// data from the HTML5 data-* attribute
	if ( data === undefined && elem.nodeType === 1 ) {

		var name = "data-" + key.replace( rmultiDash, "-$1" ).toLowerCase();

		data = elem.getAttribute( name );

		if ( typeof data === "string" ) {
			try {
				data = data === "true" ? true :
					data === "false" ? false :
					data === "null" ? null :

					// Only convert to a number if it doesn't change the string
					+data + "" === data ? +data :
					rbrace.test( data ) ? jQuery.parseJSON( data ) :
					data;
			} catch ( e ) {}

			// Make sure we set the data so it isn't changed later
			jQuery.data( elem, key, data );

		} else {
			data = undefined;
		}
	}

	return data;
}

// checks a cache object for emptiness
function isEmptyDataObject( obj ) {
	var name;
	for ( name in obj ) {

		// if the public data object is empty, the private is still empty
		if ( name === "data" && jQuery.isEmptyObject( obj[ name ] ) ) {
			continue;
		}
		if ( name !== "toJSON" ) {
			return false;
		}
	}

	return true;
}

function internalData( elem, name, data, pvt /* Internal Use Only */ ) {
	if ( !acceptData( elem ) ) {
		return;
	}

	var ret, thisCache,
		internalKey = jQuery.expando,

		// We have to handle DOM nodes and JS objects differently because IE6-7
		// can't GC object references properly across the DOM-JS boundary
		isNode = elem.nodeType,

		// Only DOM nodes need the global jQuery cache; JS object data is
		// attached directly to the object so GC can occur automatically
		cache = isNode ? jQuery.cache : elem,

		// Only defining an ID for JS objects if its cache already exists allows
		// the code to shortcut on the same path as a DOM node with no cache
		id = isNode ? elem[ internalKey ] : elem[ internalKey ] && internalKey;

	// Avoid doing any more work than we need to when trying to get data on an
	// object that has no data at all
	if ( ( !id || !cache[ id ] || ( !pvt && !cache[ id ].data ) ) &&
		data === undefined && typeof name === "string" ) {
		return;
	}

	if ( !id ) {

		// Only DOM nodes need a new unique ID for each element since their data
		// ends up in the global cache
		if ( isNode ) {
			id = elem[ internalKey ] = deletedIds.pop() || jQuery.guid++;
		} else {
			id = internalKey;
		}
	}

	if ( !cache[ id ] ) {

		// Avoid exposing jQuery metadata on plain JS objects when the object
		// is serialized using JSON.stringify
		cache[ id ] = isNode ? {} : { toJSON: jQuery.noop };
	}

	// An object can be passed to jQuery.data instead of a key/value pair; this gets
	// shallow copied over onto the existing cache
	if ( typeof name === "object" || typeof name === "function" ) {
		if ( pvt ) {
			cache[ id ] = jQuery.extend( cache[ id ], name );
		} else {
			cache[ id ].data = jQuery.extend( cache[ id ].data, name );
		}
	}

	thisCache = cache[ id ];

	// jQuery data() is stored in a separate object inside the object's internal data
	// cache in order to avoid key collisions between internal data and user-defined
	// data.
	if ( !pvt ) {
		if ( !thisCache.data ) {
			thisCache.data = {};
		}

		thisCache = thisCache.data;
	}

	if ( data !== undefined ) {
		thisCache[ jQuery.camelCase( name ) ] = data;
	}

	// Check for both converted-to-camel and non-converted data property names
	// If a data property was specified
	if ( typeof name === "string" ) {

		// First Try to find as-is property data
		ret = thisCache[ name ];

		// Test for null|undefined property data
		if ( ret == null ) {

			// Try to find the camelCased property
			ret = thisCache[ jQuery.camelCase( name ) ];
		}
	} else {
		ret = thisCache;
	}

	return ret;
}

function internalRemoveData( elem, name, pvt ) {
	if ( !acceptData( elem ) ) {
		return;
	}

	var thisCache, i,
		isNode = elem.nodeType,

		// See jQuery.data for more information
		cache = isNode ? jQuery.cache : elem,
		id = isNode ? elem[ jQuery.expando ] : jQuery.expando;

	// If there is already no cache entry for this object, there is no
	// purpose in continuing
	if ( !cache[ id ] ) {
		return;
	}

	if ( name ) {

		thisCache = pvt ? cache[ id ] : cache[ id ].data;

		if ( thisCache ) {

			// Support array or space separated string names for data keys
			if ( !jQuery.isArray( name ) ) {

				// try the string as a key before any manipulation
				if ( name in thisCache ) {
					name = [ name ];
				} else {

					// split the camel cased version by spaces unless a key with the spaces exists
					name = jQuery.camelCase( name );
					if ( name in thisCache ) {
						name = [ name ];
					} else {
						name = name.split( " " );
					}
				}
			} else {

				// If "name" is an array of keys...
				// When data is initially created, via ("key", "val") signature,
				// keys will be converted to camelCase.
				// Since there is no way to tell _how_ a key was added, remove
				// both plain key and camelCase key. #12786
				// This will only penalize the array argument path.
				name = name.concat( jQuery.map( name, jQuery.camelCase ) );
			}

			i = name.length;
			while ( i-- ) {
				delete thisCache[ name[ i ] ];
			}

			// If there is no data left in the cache, we want to continue
			// and let the cache object itself get destroyed
			if ( pvt ? !isEmptyDataObject( thisCache ) : !jQuery.isEmptyObject( thisCache ) ) {
				return;
			}
		}
	}

	// See jQuery.data for more information
	if ( !pvt ) {
		delete cache[ id ].data;

		// Don't destroy the parent cache unless the internal data object
		// had been the only thing left in it
		if ( !isEmptyDataObject( cache[ id ] ) ) {
			return;
		}
	}

	// Destroy the cache
	if ( isNode ) {
		jQuery.cleanData( [ elem ], true );

	// Use delete when supported for expandos or `cache` is not a window per isWindow (#10080)
	/* jshint eqeqeq: false */
	} else if ( support.deleteExpando || cache != cache.window ) {
		/* jshint eqeqeq: true */
		delete cache[ id ];

	// When all else fails, undefined
	} else {
		cache[ id ] = undefined;
	}
}

jQuery.extend( {
	cache: {},

	// The following elements (space-suffixed to avoid Object.prototype collisions)
	// throw uncatchable exceptions if you attempt to set expando properties
	noData: {
		"applet ": true,
		"embed ": true,

		// ...but Flash objects (which have this classid) *can* handle expandos
		"object ": "clsid:D27CDB6E-AE6D-11cf-96B8-444553540000"
	},

	hasData: function( elem ) {
		elem = elem.nodeType ? jQuery.cache[ elem[ jQuery.expando ] ] : elem[ jQuery.expando ];
		return !!elem && !isEmptyDataObject( elem );
	},

	data: function( elem, name, data ) {
		return internalData( elem, name, data );
	},

	removeData: function( elem, name ) {
		return internalRemoveData( elem, name );
	},

	// For internal use only.
	_data: function( elem, name, data ) {
		return internalData( elem, name, data, true );
	},

	_removeData: function( elem, name ) {
		return internalRemoveData( elem, name, true );
	}
} );

jQuery.fn.extend( {
	data: function( key, value ) {
		var i, name, data,
			elem = this[ 0 ],
			attrs = elem && elem.attributes;

		// Special expections of .data basically thwart jQuery.access,
		// so implement the relevant behavior ourselves

		// Gets all values
		if ( key === undefined ) {
			if ( this.length ) {
				data = jQuery.data( elem );

				if ( elem.nodeType === 1 && !jQuery._data( elem, "parsedAttrs" ) ) {
					i = attrs.length;
					while ( i-- ) {

						// Support: IE11+
						// The attrs elements can be null (#14894)
						if ( attrs[ i ] ) {
							name = attrs[ i ].name;
							if ( name.indexOf( "data-" ) === 0 ) {
								name = jQuery.camelCase( name.slice( 5 ) );
								dataAttr( elem, name, data[ name ] );
							}
						}
					}
					jQuery._data( elem, "parsedAttrs", true );
				}
			}

			return data;
		}

		// Sets multiple values
		if ( typeof key === "object" ) {
			return this.each( function() {
				jQuery.data( this, key );
			} );
		}

		return arguments.length > 1 ?

			// Sets one value
			this.each( function() {
				jQuery.data( this, key, value );
			} ) :

			// Gets one value
			// Try to fetch any internally stored data first
			elem ? dataAttr( elem, key, jQuery.data( elem, key ) ) : undefined;
	},

	removeData: function( key ) {
		return this.each( function() {
			jQuery.removeData( this, key );
		} );
	}
} );


jQuery.extend( {
	queue: function( elem, type, data ) {
		var queue;

		if ( elem ) {
			type = ( type || "fx" ) + "queue";
			queue = jQuery._data( elem, type );

			// Speed up dequeue by getting out quickly if this is just a lookup
			if ( data ) {
				if ( !queue || jQuery.isArray( data ) ) {
					queue = jQuery._data( elem, type, jQuery.makeArray( data ) );
				} else {
					queue.push( data );
				}
			}
			return queue || [];
		}
	},

	dequeue: function( elem, type ) {
		type = type || "fx";

		var queue = jQuery.queue( elem, type ),
			startLength = queue.length,
			fn = queue.shift(),
			hooks = jQuery._queueHooks( elem, type ),
			next = function() {
				jQuery.dequeue( elem, type );
			};

		// If the fx queue is dequeued, always remove the progress sentinel
		if ( fn === "inprogress" ) {
			fn = queue.shift();
			startLength--;
		}

		if ( fn ) {

			// Add a progress sentinel to prevent the fx queue from being
			// automatically dequeued
			if ( type === "fx" ) {
				queue.unshift( "inprogress" );
			}

			// clear up the last queue stop function
			delete hooks.stop;
			fn.call( elem, next, hooks );
		}

		if ( !startLength && hooks ) {
			hooks.empty.fire();
		}
	},

	// not intended for public consumption - generates a queueHooks object,
	// or returns the current one
	_queueHooks: function( elem, type ) {
		var key = type + "queueHooks";
		return jQuery._data( elem, key ) || jQuery._data( elem, key, {
			empty: jQuery.Callbacks( "once memory" ).add( function() {
				jQuery._removeData( elem, type + "queue" );
				jQuery._removeData( elem, key );
			} )
		} );
	}
} );

jQuery.fn.extend( {
	queue: function( type, data ) {
		var setter = 2;

		if ( typeof type !== "string" ) {
			data = type;
			type = "fx";
			setter--;
		}

		if ( arguments.length < setter ) {
			return jQuery.queue( this[ 0 ], type );
		}

		return data === undefined ?
			this :
			this.each( function() {
				var queue = jQuery.queue( this, type, data );

				// ensure a hooks for this queue
				jQuery._queueHooks( this, type );

				if ( type === "fx" && queue[ 0 ] !== "inprogress" ) {
					jQuery.dequeue( this, type );
				}
			} );
	},
	dequeue: function( type ) {
		return this.each( function() {
			jQuery.dequeue( this, type );
		} );
	},
	clearQueue: function( type ) {
		return this.queue( type || "fx", [] );
	},

	// Get a promise resolved when queues of a certain type
	// are emptied (fx is the type by default)
	promise: function( type, obj ) {
		var tmp,
			count = 1,
			defer = jQuery.Deferred(),
			elements = this,
			i = this.length,
			resolve = function() {
				if ( !( --count ) ) {
					defer.resolveWith( elements, [ elements ] );
				}
			};

		if ( typeof type !== "string" ) {
			obj = type;
			type = undefined;
		}
		type = type || "fx";

		while ( i-- ) {
			tmp = jQuery._data( elements[ i ], type + "queueHooks" );
			if ( tmp && tmp.empty ) {
				count++;
				tmp.empty.add( resolve );
			}
		}
		resolve();
		return defer.promise( obj );
	}
} );


( function() {
	var shrinkWrapBlocksVal;

	support.shrinkWrapBlocks = function() {
		if ( shrinkWrapBlocksVal != null ) {
			return shrinkWrapBlocksVal;
		}

		// Will be changed later if needed.
		shrinkWrapBlocksVal = false;

		// Minified: var b,c,d
		var div, body, container;

		body = document.getElementsByTagName( "body" )[ 0 ];
		if ( !body || !body.style ) {

			// Test fired too early or in an unsupported environment, exit.
			return;
		}

		// Setup
		div = document.createElement( "div" );
		container = document.createElement( "div" );
		container.style.cssText = "position:absolute;border:0;width:0;height:0;top:0;left:-9999px";
		body.appendChild( container ).appendChild( div );

		// Support: IE6
		// Check if elements with layout shrink-wrap their children
		if ( typeof div.style.zoom !== "undefined" ) {

			// Reset CSS: box-sizing; display; margin; border
			div.style.cssText =

				// Support: Firefox<29, Android 2.3
				// Vendor-prefix box-sizing
				"-webkit-box-sizing:content-box;-moz-box-sizing:content-box;" +
				"box-sizing:content-box;display:block;margin:0;border:0;" +
				"padding:1px;width:1px;zoom:1";
			div.appendChild( document.createElement( "div" ) ).style.width = "5px";
			shrinkWrapBlocksVal = div.offsetWidth !== 3;
		}

		body.removeChild( container );

		return shrinkWrapBlocksVal;
	};

} )();
var pnum = ( /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/ ).source;

var rcssNum = new RegExp( "^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i" );


var cssExpand = [ "Top", "Right", "Bottom", "Left" ];

var isHidden = function( elem, el ) {

		// isHidden might be called from jQuery#filter function;
		// in that case, element will be second argument
		elem = el || elem;
		return jQuery.css( elem, "display" ) === "none" ||
			!jQuery.contains( elem.ownerDocument, elem );
	};



function adjustCSS( elem, prop, valueParts, tween ) {
	var adjusted,
		scale = 1,
		maxIterations = 20,
		currentValue = tween ?
			function() { return tween.cur(); } :
			function() { return jQuery.css( elem, prop, "" ); },
		initial = currentValue(),
		unit = valueParts && valueParts[ 3 ] || ( jQuery.cssNumber[ prop ] ? "" : "px" ),

		// Starting value computation is required for potential unit mismatches
		initialInUnit = ( jQuery.cssNumber[ prop ] || unit !== "px" && +initial ) &&
			rcssNum.exec( jQuery.css( elem, prop ) );

	if ( initialInUnit && initialInUnit[ 3 ] !== unit ) {

		// Trust units reported by jQuery.css
		unit = unit || initialInUnit[ 3 ];

		// Make sure we update the tween properties later on
		valueParts = valueParts || [];

		// Iteratively approximate from a nonzero starting point
		initialInUnit = +initial || 1;

		do {

			// If previous iteration zeroed out, double until we get *something*.
			// Use string for doubling so we don't accidentally see scale as unchanged below
			scale = scale || ".5";

			// Adjust and apply
			initialInUnit = initialInUnit / scale;
			jQuery.style( elem, prop, initialInUnit + unit );

		// Update scale, tolerating zero or NaN from tween.cur()
		// Break the loop if scale is unchanged or perfect, or if we've just had enough.
		} while (
			scale !== ( scale = currentValue() / initial ) && scale !== 1 && --maxIterations
		);
	}

	if ( valueParts ) {
		initialInUnit = +initialInUnit || +initial || 0;

		// Apply relative offset (+=/-=) if specified
		adjusted = valueParts[ 1 ] ?
			initialInUnit + ( valueParts[ 1 ] + 1 ) * valueParts[ 2 ] :
			+valueParts[ 2 ];
		if ( tween ) {
			tween.unit = unit;
			tween.start = initialInUnit;
			tween.end = adjusted;
		}
	}
	return adjusted;
}


// Multifunctional method to get and set values of a collection
// The value/s can optionally be executed if it's a function
var access = function( elems, fn, key, value, chainable, emptyGet, raw ) {
	var i = 0,
		length = elems.length,
		bulk = key == null;

	// Sets many values
	if ( jQuery.type( key ) === "object" ) {
		chainable = true;
		for ( i in key ) {
			access( elems, fn, i, key[ i ], true, emptyGet, raw );
		}

	// Sets one value
	} else if ( value !== undefined ) {
		chainable = true;

		if ( !jQuery.isFunction( value ) ) {
			raw = true;
		}

		if ( bulk ) {

			// Bulk operations run against the entire set
			if ( raw ) {
				fn.call( elems, value );
				fn = null;

			// ...except when executing function values
			} else {
				bulk = fn;
				fn = function( elem, key, value ) {
					return bulk.call( jQuery( elem ), value );
				};
			}
		}

		if ( fn ) {
			for ( ; i < length; i++ ) {
				fn(
					elems[ i ],
					key,
					raw ? value : value.call( elems[ i ], i, fn( elems[ i ], key ) )
				);
			}
		}
	}

	return chainable ?
		elems :

		// Gets
		bulk ?
			fn.call( elems ) :
			length ? fn( elems[ 0 ], key ) : emptyGet;
};
var rcheckableType = ( /^(?:checkbox|radio)$/i );

var rtagName = ( /<([\w:-]+)/ );

var rscriptType = ( /^$|\/(?:java|ecma)script/i );

var rleadingWhitespace = ( /^\s+/ );

var nodeNames = "abbr|article|aside|audio|bdi|canvas|data|datalist|" +
		"details|dialog|figcaption|figure|footer|header|hgroup|main|" +
		"mark|meter|nav|output|picture|progress|section|summary|template|time|video";



function createSafeFragment( document ) {
	var list = nodeNames.split( "|" ),
		safeFrag = document.createDocumentFragment();

	if ( safeFrag.createElement ) {
		while ( list.length ) {
			safeFrag.createElement(
				list.pop()
			);
		}
	}
	return safeFrag;
}


( function() {
	var div = document.createElement( "div" ),
		fragment = document.createDocumentFragment(),
		input = document.createElement( "input" );

	// Setup
	div.innerHTML = "  <link/><table></table><a href='/a'>a</a><input type='checkbox'/>";

	// IE strips leading whitespace when .innerHTML is used
	support.leadingWhitespace = div.firstChild.nodeType === 3;

	// Make sure that tbody elements aren't automatically inserted
	// IE will insert them into empty tables
	support.tbody = !div.getElementsByTagName( "tbody" ).length;

	// Make sure that link elements get serialized correctly by innerHTML
	// This requires a wrapper element in IE
	support.htmlSerialize = !!div.getElementsByTagName( "link" ).length;

	// Makes sure cloning an html5 element does not cause problems
	// Where outerHTML is undefined, this still works
	support.html5Clone =
		document.createElement( "nav" ).cloneNode( true ).outerHTML !== "<:nav></:nav>";

	// Check if a disconnected checkbox will retain its checked
	// value of true after appended to the DOM (IE6/7)
	input.type = "checkbox";
	input.checked = true;
	fragment.appendChild( input );
	support.appendChecked = input.checked;

	// Make sure textarea (and checkbox) defaultValue is properly cloned
	// Support: IE6-IE11+
	div.innerHTML = "<textarea>x</textarea>";
	support.noCloneChecked = !!div.cloneNode( true ).lastChild.defaultValue;

	// #11217 - WebKit loses check when the name is after the checked attribute
	fragment.appendChild( div );

	// Support: Windows Web Apps (WWA)
	// `name` and `type` must use .setAttribute for WWA (#14901)
	input = document.createElement( "input" );
	input.setAttribute( "type", "radio" );
	input.setAttribute( "checked", "checked" );
	input.setAttribute( "name", "t" );

	div.appendChild( input );

	// Support: Safari 5.1, iOS 5.1, Android 4.x, Android 2.3
	// old WebKit doesn't clone checked state correctly in fragments
	support.checkClone = div.cloneNode( true ).cloneNode( true ).lastChild.checked;

	// Support: IE<9
	// Cloned elements keep attachEvent handlers, we use addEventListener on IE9+
	support.noCloneEvent = !!div.addEventListener;

	// Support: IE<9
	// Since attributes and properties are the same in IE,
	// cleanData must set properties to undefined rather than use removeAttribute
	div[ jQuery.expando ] = 1;
	support.attributes = !div.getAttribute( jQuery.expando );
} )();


// We have to close these tags to support XHTML (#13200)
var wrapMap = {
	option: [ 1, "<select multiple='multiple'>", "</select>" ],
	legend: [ 1, "<fieldset>", "</fieldset>" ],
	area: [ 1, "<map>", "</map>" ],

	// Support: IE8
	param: [ 1, "<object>", "</object>" ],
	thead: [ 1, "<table>", "</table>" ],
	tr: [ 2, "<table><tbody>", "</tbody></table>" ],
	col: [ 2, "<table><tbody></tbody><colgroup>", "</colgroup></table>" ],
	td: [ 3, "<table><tbody><tr>", "</tr></tbody></table>" ],

	// IE6-8 can't serialize link, script, style, or any html5 (NoScope) tags,
	// unless wrapped in a div with non-breaking characters in front of it.
	_default: support.htmlSerialize ? [ 0, "", "" ] : [ 1, "X<div>", "</div>" ]
};

// Support: IE8-IE9
wrapMap.optgroup = wrapMap.option;

wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
wrapMap.th = wrapMap.td;


function getAll( context, tag ) {
	var elems, elem,
		i = 0,
		found = typeof context.getElementsByTagName !== "undefined" ?
			context.getElementsByTagName( tag || "*" ) :
			typeof context.querySelectorAll !== "undefined" ?
				context.querySelectorAll( tag || "*" ) :
				undefined;

	if ( !found ) {
		for ( found = [], elems = context.childNodes || context;
			( elem = elems[ i ] ) != null;
			i++
		) {
			if ( !tag || jQuery.nodeName( elem, tag ) ) {
				found.push( elem );
			} else {
				jQuery.merge( found, getAll( elem, tag ) );
			}
		}
	}

	return tag === undefined || tag && jQuery.nodeName( context, tag ) ?
		jQuery.merge( [ context ], found ) :
		found;
}


// Mark scripts as having already been evaluated
function setGlobalEval( elems, refElements ) {
	var elem,
		i = 0;
	for ( ; ( elem = elems[ i ] ) != null; i++ ) {
		jQuery._data(
			elem,
			"globalEval",
			!refElements || jQuery._data( refElements[ i ], "globalEval" )
		);
	}
}


var rhtml = /<|&#?\w+;/,
	rtbody = /<tbody/i;

function fixDefaultChecked( elem ) {
	if ( rcheckableType.test( elem.type ) ) {
		elem.defaultChecked = elem.checked;
	}
}

function buildFragment( elems, context, scripts, selection, ignored ) {
	var j, elem, contains,
		tmp, tag, tbody, wrap,
		l = elems.length,

		// Ensure a safe fragment
		safe = createSafeFragment( context ),

		nodes = [],
		i = 0;

	for ( ; i < l; i++ ) {
		elem = elems[ i ];

		if ( elem || elem === 0 ) {

			// Add nodes directly
			if ( jQuery.type( elem ) === "object" ) {
				jQuery.merge( nodes, elem.nodeType ? [ elem ] : elem );

			// Convert non-html into a text node
			} else if ( !rhtml.test( elem ) ) {
				nodes.push( context.createTextNode( elem ) );

			// Convert html into DOM nodes
			} else {
				tmp = tmp || safe.appendChild( context.createElement( "div" ) );

				// Deserialize a standard representation
				tag = ( rtagName.exec( elem ) || [ "", "" ] )[ 1 ].toLowerCase();
				wrap = wrapMap[ tag ] || wrapMap._default;

				tmp.innerHTML = wrap[ 1 ] + jQuery.htmlPrefilter( elem ) + wrap[ 2 ];

				// Descend through wrappers to the right content
				j = wrap[ 0 ];
				while ( j-- ) {
					tmp = tmp.lastChild;
				}

				// Manually add leading whitespace removed by IE
				if ( !support.leadingWhitespace && rleadingWhitespace.test( elem ) ) {
					nodes.push( context.createTextNode( rleadingWhitespace.exec( elem )[ 0 ] ) );
				}

				// Remove IE's autoinserted <tbody> from table fragments
				if ( !support.tbody ) {

					// String was a <table>, *may* have spurious <tbody>
					elem = tag === "table" && !rtbody.test( elem ) ?
						tmp.firstChild :

						// String was a bare <thead> or <tfoot>
						wrap[ 1 ] === "<table>" && !rtbody.test( elem ) ?
							tmp :
							0;

					j = elem && elem.childNodes.length;
					while ( j-- ) {
						if ( jQuery.nodeName( ( tbody = elem.childNodes[ j ] ), "tbody" ) &&
							!tbody.childNodes.length ) {

							elem.removeChild( tbody );
						}
					}
				}

				jQuery.merge( nodes, tmp.childNodes );

				// Fix #12392 for WebKit and IE > 9
				tmp.textContent = "";

				// Fix #12392 for oldIE
				while ( tmp.firstChild ) {
					tmp.removeChild( tmp.firstChild );
				}

				// Remember the top-level container for proper cleanup
				tmp = safe.lastChild;
			}
		}
	}

	// Fix #11356: Clear elements from fragment
	if ( tmp ) {
		safe.removeChild( tmp );
	}

	// Reset defaultChecked for any radios and checkboxes
	// about to be appended to the DOM in IE 6/7 (#8060)
	if ( !support.appendChecked ) {
		jQuery.grep( getAll( nodes, "input" ), fixDefaultChecked );
	}

	i = 0;
	while ( ( elem = nodes[ i++ ] ) ) {

		// Skip elements already in the context collection (trac-4087)
		if ( selection && jQuery.inArray( elem, selection ) > -1 ) {
			if ( ignored ) {
				ignored.push( elem );
			}

			continue;
		}

		contains = jQuery.contains( elem.ownerDocument, elem );

		// Append to fragment
		tmp = getAll( safe.appendChild( elem ), "script" );

		// Preserve script evaluation history
		if ( contains ) {
			setGlobalEval( tmp );
		}

		// Capture executables
		if ( scripts ) {
			j = 0;
			while ( ( elem = tmp[ j++ ] ) ) {
				if ( rscriptType.test( elem.type || "" ) ) {
					scripts.push( elem );
				}
			}
		}
	}

	tmp = null;

	return safe;
}


( function() {
	var i, eventName,
		div = document.createElement( "div" );

	// Support: IE<9 (lack submit/change bubble), Firefox (lack focus(in | out) events)
	for ( i in { submit: true, change: true, focusin: true } ) {
		eventName = "on" + i;

		if ( !( support[ i ] = eventName in window ) ) {

			// Beware of CSP restrictions (https://developer.mozilla.org/en/Security/CSP)
			div.setAttribute( eventName, "t" );
			support[ i ] = div.attributes[ eventName ].expando === false;
		}
	}

	// Null elements to avoid leaks in IE.
	div = null;
} )();


var rformElems = /^(?:input|select|textarea)$/i,
	rkeyEvent = /^key/,
	rmouseEvent = /^(?:mouse|pointer|contextmenu|drag|drop)|click/,
	rfocusMorph = /^(?:focusinfocus|focusoutblur)$/,
	rtypenamespace = /^([^.]*)(?:\.(.+)|)/;

function returnTrue() {
	return true;
}

function returnFalse() {
	return false;
}

// Support: IE9
// See #13393 for more info
function safeActiveElement() {
	try {
		return document.activeElement;
	} catch ( err ) { }
}

function on( elem, types, selector, data, fn, one ) {
	var origFn, type;

	// Types can be a map of types/handlers
	if ( typeof types === "object" ) {

		// ( types-Object, selector, data )
		if ( typeof selector !== "string" ) {

			// ( types-Object, data )
			data = data || selector;
			selector = undefined;
		}
		for ( type in types ) {
			on( elem, type, selector, data, types[ type ], one );
		}
		return elem;
	}

	if ( data == null && fn == null ) {

		// ( types, fn )
		fn = selector;
		data = selector = undefined;
	} else if ( fn == null ) {
		if ( typeof selector === "string" ) {

			// ( types, selector, fn )
			fn = data;
			data = undefined;
		} else {

			// ( types, data, fn )
			fn = data;
			data = selector;
			selector = undefined;
		}
	}
	if ( fn === false ) {
		fn = returnFalse;
	} else if ( !fn ) {
		return elem;
	}

	if ( one === 1 ) {
		origFn = fn;
		fn = function( event ) {

			// Can use an empty set, since event contains the info
			jQuery().off( event );
			return origFn.apply( this, arguments );
		};

		// Use same guid so caller can remove using origFn
		fn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );
	}
	return elem.each( function() {
		jQuery.event.add( this, types, fn, data, selector );
	} );
}

/*
 * Helper functions for managing events -- not part of the public interface.
 * Props to Dean Edwards' addEvent library for many of the ideas.
 */
jQuery.event = {

	global: {},

	add: function( elem, types, handler, data, selector ) {
		var tmp, events, t, handleObjIn,
			special, eventHandle, handleObj,
			handlers, type, namespaces, origType,
			elemData = jQuery._data( elem );

		// Don't attach events to noData or text/comment nodes (but allow plain objects)
		if ( !elemData ) {
			return;
		}

		// Caller can pass in an object of custom data in lieu of the handler
		if ( handler.handler ) {
			handleObjIn = handler;
			handler = handleObjIn.handler;
			selector = handleObjIn.selector;
		}

		// Make sure that the handler has a unique ID, used to find/remove it later
		if ( !handler.guid ) {
			handler.guid = jQuery.guid++;
		}

		// Init the element's event structure and main handler, if this is the first
		if ( !( events = elemData.events ) ) {
			events = elemData.events = {};
		}
		if ( !( eventHandle = elemData.handle ) ) {
			eventHandle = elemData.handle = function( e ) {

				// Discard the second event of a jQuery.event.trigger() and
				// when an event is called after a page has unloaded
				return typeof jQuery !== "undefined" &&
					( !e || jQuery.event.triggered !== e.type ) ?
					jQuery.event.dispatch.apply( eventHandle.elem, arguments ) :
					undefined;
			};

			// Add elem as a property of the handle fn to prevent a memory leak
			// with IE non-native events
			eventHandle.elem = elem;
		}

		// Handle multiple events separated by a space
		types = ( types || "" ).match( rnotwhite ) || [ "" ];
		t = types.length;
		while ( t-- ) {
			tmp = rtypenamespace.exec( types[ t ] ) || [];
			type = origType = tmp[ 1 ];
			namespaces = ( tmp[ 2 ] || "" ).split( "." ).sort();

			// There *must* be a type, no attaching namespace-only handlers
			if ( !type ) {
				continue;
			}

			// If event changes its type, use the special event handlers for the changed type
			special = jQuery.event.special[ type ] || {};

			// If selector defined, determine special event api type, otherwise given type
			type = ( selector ? special.delegateType : special.bindType ) || type;

			// Update special based on newly reset type
			special = jQuery.event.special[ type ] || {};

			// handleObj is passed to all event handlers
			handleObj = jQuery.extend( {
				type: type,
				origType: origType,
				data: data,
				handler: handler,
				guid: handler.guid,
				selector: selector,
				needsContext: selector && jQuery.expr.match.needsContext.test( selector ),
				namespace: namespaces.join( "." )
			}, handleObjIn );

			// Init the event handler queue if we're the first
			if ( !( handlers = events[ type ] ) ) {
				handlers = events[ type ] = [];
				handlers.delegateCount = 0;

				// Only use addEventListener/attachEvent if the special events handler returns false
				if ( !special.setup ||
					special.setup.call( elem, data, namespaces, eventHandle ) === false ) {

					// Bind the global event handler to the element
					if ( elem.addEventListener ) {
						elem.addEventListener( type, eventHandle, false );

					} else if ( elem.attachEvent ) {
						elem.attachEvent( "on" + type, eventHandle );
					}
				}
			}

			if ( special.add ) {
				special.add.call( elem, handleObj );

				if ( !handleObj.handler.guid ) {
					handleObj.handler.guid = handler.guid;
				}
			}

			// Add to the element's handler list, delegates in front
			if ( selector ) {
				handlers.splice( handlers.delegateCount++, 0, handleObj );
			} else {
				handlers.push( handleObj );
			}

			// Keep track of which events have ever been used, for event optimization
			jQuery.event.global[ type ] = true;
		}

		// Nullify elem to prevent memory leaks in IE
		elem = null;
	},

	// Detach an event or set of events from an element
	remove: function( elem, types, handler, selector, mappedTypes ) {
		var j, handleObj, tmp,
			origCount, t, events,
			special, handlers, type,
			namespaces, origType,
			elemData = jQuery.hasData( elem ) && jQuery._data( elem );

		if ( !elemData || !( events = elemData.events ) ) {
			return;
		}

		// Once for each type.namespace in types; type may be omitted
		types = ( types || "" ).match( rnotwhite ) || [ "" ];
		t = types.length;
		while ( t-- ) {
			tmp = rtypenamespace.exec( types[ t ] ) || [];
			type = origType = tmp[ 1 ];
			namespaces = ( tmp[ 2 ] || "" ).split( "." ).sort();

			// Unbind all events (on this namespace, if provided) for the element
			if ( !type ) {
				for ( type in events ) {
					jQuery.event.remove( elem, type + types[ t ], handler, selector, true );
				}
				continue;
			}

			special = jQuery.event.special[ type ] || {};
			type = ( selector ? special.delegateType : special.bindType ) || type;
			handlers = events[ type ] || [];
			tmp = tmp[ 2 ] &&
				new RegExp( "(^|\\.)" + namespaces.join( "\\.(?:.*\\.|)" ) + "(\\.|$)" );

			// Remove matching events
			origCount = j = handlers.length;
			while ( j-- ) {
				handleObj = handlers[ j ];

				if ( ( mappedTypes || origType === handleObj.origType ) &&
					( !handler || handler.guid === handleObj.guid ) &&
					( !tmp || tmp.test( handleObj.namespace ) ) &&
					( !selector || selector === handleObj.selector ||
						selector === "**" && handleObj.selector ) ) {
					handlers.splice( j, 1 );

					if ( handleObj.selector ) {
						handlers.delegateCount--;
					}
					if ( special.remove ) {
						special.remove.call( elem, handleObj );
					}
				}
			}

			// Remove generic event handler if we removed something and no more handlers exist
			// (avoids potential for endless recursion during removal of special event handlers)
			if ( origCount && !handlers.length ) {
				if ( !special.teardown ||
					special.teardown.call( elem, namespaces, elemData.handle ) === false ) {

					jQuery.removeEvent( elem, type, elemData.handle );
				}

				delete events[ type ];
			}
		}

		// Remove the expando if it's no longer used
		if ( jQuery.isEmptyObject( events ) ) {
			delete elemData.handle;

			// removeData also checks for emptiness and clears the expando if empty
			// so use it instead of delete
			jQuery._removeData( elem, "events" );
		}
	},

	trigger: function( event, data, elem, onlyHandlers ) {
		var handle, ontype, cur,
			bubbleType, special, tmp, i,
			eventPath = [ elem || document ],
			type = hasOwn.call( event, "type" ) ? event.type : event,
			namespaces = hasOwn.call( event, "namespace" ) ? event.namespace.split( "." ) : [];

		cur = tmp = elem = elem || document;

		// Don't do events on text and comment nodes
		if ( elem.nodeType === 3 || elem.nodeType === 8 ) {
			return;
		}

		// focus/blur morphs to focusin/out; ensure we're not firing them right now
		if ( rfocusMorph.test( type + jQuery.event.triggered ) ) {
			return;
		}

		if ( type.indexOf( "." ) > -1 ) {

			// Namespaced trigger; create a regexp to match event type in handle()
			namespaces = type.split( "." );
			type = namespaces.shift();
			namespaces.sort();
		}
		ontype = type.indexOf( ":" ) < 0 && "on" + type;

		// Caller can pass in a jQuery.Event object, Object, or just an event type string
		event = event[ jQuery.expando ] ?
			event :
			new jQuery.Event( type, typeof event === "object" && event );

		// Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)
		event.isTrigger = onlyHandlers ? 2 : 3;
		event.namespace = namespaces.join( "." );
		event.rnamespace = event.namespace ?
			new RegExp( "(^|\\.)" + namespaces.join( "\\.(?:.*\\.|)" ) + "(\\.|$)" ) :
			null;

		// Clean up the event in case it is being reused
		event.result = undefined;
		if ( !event.target ) {
			event.target = elem;
		}

		// Clone any incoming data and prepend the event, creating the handler arg list
		data = data == null ?
			[ event ] :
			jQuery.makeArray( data, [ event ] );

		// Allow special events to draw outside the lines
		special = jQuery.event.special[ type ] || {};
		if ( !onlyHandlers && special.trigger && special.trigger.apply( elem, data ) === false ) {
			return;
		}

		// Determine event propagation path in advance, per W3C events spec (#9951)
		// Bubble up to document, then to window; watch for a global ownerDocument var (#9724)
		if ( !onlyHandlers && !special.noBubble && !jQuery.isWindow( elem ) ) {

			bubbleType = special.delegateType || type;
			if ( !rfocusMorph.test( bubbleType + type ) ) {
				cur = cur.parentNode;
			}
			for ( ; cur; cur = cur.parentNode ) {
				eventPath.push( cur );
				tmp = cur;
			}

			// Only add window if we got to document (e.g., not plain obj or detached DOM)
			if ( tmp === ( elem.ownerDocument || document ) ) {
				eventPath.push( tmp.defaultView || tmp.parentWindow || window );
			}
		}

		// Fire handlers on the event path
		i = 0;
		while ( ( cur = eventPath[ i++ ] ) && !event.isPropagationStopped() ) {

			event.type = i > 1 ?
				bubbleType :
				special.bindType || type;

			// jQuery handler
			handle = ( jQuery._data( cur, "events" ) || {} )[ event.type ] &&
				jQuery._data( cur, "handle" );

			if ( handle ) {
				handle.apply( cur, data );
			}

			// Native handler
			handle = ontype && cur[ ontype ];
			if ( handle && handle.apply && acceptData( cur ) ) {
				event.result = handle.apply( cur, data );
				if ( event.result === false ) {
					event.preventDefault();
				}
			}
		}
		event.type = type;

		// If nobody prevented the default action, do it now
		if ( !onlyHandlers && !event.isDefaultPrevented() ) {

			if (
				( !special._default ||
				 special._default.apply( eventPath.pop(), data ) === false
				) && acceptData( elem )
			) {

				// Call a native DOM method on the target with the same name name as the event.
				// Can't use an .isFunction() check here because IE6/7 fails that test.
				// Don't do default actions on window, that's where global variables be (#6170)
				if ( ontype && elem[ type ] && !jQuery.isWindow( elem ) ) {

					// Don't re-trigger an onFOO event when we call its FOO() method
					tmp = elem[ ontype ];

					if ( tmp ) {
						elem[ ontype ] = null;
					}

					// Prevent re-triggering of the same event, since we already bubbled it above
					jQuery.event.triggered = type;
					try {
						elem[ type ]();
					} catch ( e ) {

						// IE<9 dies on focus/blur to hidden element (#1486,#12518)
						// only reproducible on winXP IE8 native, not IE9 in IE8 mode
					}
					jQuery.event.triggered = undefined;

					if ( tmp ) {
						elem[ ontype ] = tmp;
					}
				}
			}
		}

		return event.result;
	},

	dispatch: function( event ) {

		// Make a writable jQuery.Event from the native event object
		event = jQuery.event.fix( event );

		var i, j, ret, matched, handleObj,
			handlerQueue = [],
			args = slice.call( arguments ),
			handlers = ( jQuery._data( this, "events" ) || {} )[ event.type ] || [],
			special = jQuery.event.special[ event.type ] || {};

		// Use the fix-ed jQuery.Event rather than the (read-only) native event
		args[ 0 ] = event;
		event.delegateTarget = this;

		// Call the preDispatch hook for the mapped type, and let it bail if desired
		if ( special.preDispatch && special.preDispatch.call( this, event ) === false ) {
			return;
		}

		// Determine handlers
		handlerQueue = jQuery.event.handlers.call( this, event, handlers );

		// Run delegates first; they may want to stop propagation beneath us
		i = 0;
		while ( ( matched = handlerQueue[ i++ ] ) && !event.isPropagationStopped() ) {
			event.currentTarget = matched.elem;

			j = 0;
			while ( ( handleObj = matched.handlers[ j++ ] ) &&
				!event.isImmediatePropagationStopped() ) {

				// Triggered event must either 1) have no namespace, or 2) have namespace(s)
				// a subset or equal to those in the bound event (both can have no namespace).
				if ( !event.rnamespace || event.rnamespace.test( handleObj.namespace ) ) {

					event.handleObj = handleObj;
					event.data = handleObj.data;

					ret = ( ( jQuery.event.special[ handleObj.origType ] || {} ).handle ||
						handleObj.handler ).apply( matched.elem, args );

					if ( ret !== undefined ) {
						if ( ( event.result = ret ) === false ) {
							event.preventDefault();
							event.stopPropagation();
						}
					}
				}
			}
		}

		// Call the postDispatch hook for the mapped type
		if ( special.postDispatch ) {
			special.postDispatch.call( this, event );
		}

		return event.result;
	},

	handlers: function( event, handlers ) {
		var i, matches, sel, handleObj,
			handlerQueue = [],
			delegateCount = handlers.delegateCount,
			cur = event.target;

		// Support (at least): Chrome, IE9
		// Find delegate handlers
		// Black-hole SVG <use> instance trees (#13180)
		//
		// Support: Firefox<=42+
		// Avoid non-left-click in FF but don't block IE radio events (#3861, gh-2343)
		if ( delegateCount && cur.nodeType &&
			( event.type !== "click" || isNaN( event.button ) || event.button < 1 ) ) {

			/* jshint eqeqeq: false */
			for ( ; cur != this; cur = cur.parentNode || this ) {
				/* jshint eqeqeq: true */

				// Don't check non-elements (#13208)
				// Don't process clicks on disabled elements (#6911, #8165, #11382, #11764)
				if ( cur.nodeType === 1 && ( cur.disabled !== true || event.type !== "click" ) ) {
					matches = [];
					for ( i = 0; i < delegateCount; i++ ) {
						handleObj = handlers[ i ];

						// Don't conflict with Object.prototype properties (#13203)
						sel = handleObj.selector + " ";

						if ( matches[ sel ] === undefined ) {
							matches[ sel ] = handleObj.needsContext ?
								jQuery( sel, this ).index( cur ) > -1 :
								jQuery.find( sel, this, null, [ cur ] ).length;
						}
						if ( matches[ sel ] ) {
							matches.push( handleObj );
						}
					}
					if ( matches.length ) {
						handlerQueue.push( { elem: cur, handlers: matches } );
					}
				}
			}
		}

		// Add the remaining (directly-bound) handlers
		if ( delegateCount < handlers.length ) {
			handlerQueue.push( { elem: this, handlers: handlers.slice( delegateCount ) } );
		}

		return handlerQueue;
	},

	fix: function( event ) {
		if ( event[ jQuery.expando ] ) {
			return event;
		}

		// Create a writable copy of the event object and normalize some properties
		var i, prop, copy,
			type = event.type,
			originalEvent = event,
			fixHook = this.fixHooks[ type ];

		if ( !fixHook ) {
			this.fixHooks[ type ] = fixHook =
				rmouseEvent.test( type ) ? this.mouseHooks :
				rkeyEvent.test( type ) ? this.keyHooks :
				{};
		}
		copy = fixHook.props ? this.props.concat( fixHook.props ) : this.props;

		event = new jQuery.Event( originalEvent );

		i = copy.length;
		while ( i-- ) {
			prop = copy[ i ];
			event[ prop ] = originalEvent[ prop ];
		}

		// Support: IE<9
		// Fix target property (#1925)
		if ( !event.target ) {
			event.target = originalEvent.srcElement || document;
		}

		// Support: Safari 6-8+
		// Target should not be a text node (#504, #13143)
		if ( event.target.nodeType === 3 ) {
			event.target = event.target.parentNode;
		}

		// Support: IE<9
		// For mouse/key events, metaKey==false if it's undefined (#3368, #11328)
		event.metaKey = !!event.metaKey;

		return fixHook.filter ? fixHook.filter( event, originalEvent ) : event;
	},

	// Includes some event props shared by KeyEvent and MouseEvent
	props: ( "altKey bubbles cancelable ctrlKey currentTarget detail eventPhase " +
		"metaKey relatedTarget shiftKey target timeStamp view which" ).split( " " ),

	fixHooks: {},

	keyHooks: {
		props: "char charCode key keyCode".split( " " ),
		filter: function( event, original ) {

			// Add which for key events
			if ( event.which == null ) {
				event.which = original.charCode != null ? original.charCode : original.keyCode;
			}

			return event;
		}
	},

	mouseHooks: {
		props: ( "button buttons clientX clientY fromElement offsetX offsetY " +
			"pageX pageY screenX screenY toElement" ).split( " " ),
		filter: function( event, original ) {
			var body, eventDoc, doc,
				button = original.button,
				fromElement = original.fromElement;

			// Calculate pageX/Y if missing and clientX/Y available
			if ( event.pageX == null && original.clientX != null ) {
				eventDoc = event.target.ownerDocument || document;
				doc = eventDoc.documentElement;
				body = eventDoc.body;

				event.pageX = original.clientX +
					( doc && doc.scrollLeft || body && body.scrollLeft || 0 ) -
					( doc && doc.clientLeft || body && body.clientLeft || 0 );
				event.pageY = original.clientY +
					( doc && doc.scrollTop  || body && body.scrollTop  || 0 ) -
					( doc && doc.clientTop  || body && body.clientTop  || 0 );
			}

			// Add relatedTarget, if necessary
			if ( !event.relatedTarget && fromElement ) {
				event.relatedTarget = fromElement === event.target ?
					original.toElement :
					fromElement;
			}

			// Add which for click: 1 === left; 2 === middle; 3 === right
			// Note: button is not normalized, so don't use it
			if ( !event.which && button !== undefined ) {
				event.which = ( button & 1 ? 1 : ( button & 2 ? 3 : ( button & 4 ? 2 : 0 ) ) );
			}

			return event;
		}
	},

	special: {
		load: {

			// Prevent triggered image.load events from bubbling to window.load
			noBubble: true
		},
		focus: {

			// Fire native event if possible so blur/focus sequence is correct
			trigger: function() {
				if ( this !== safeActiveElement() && this.focus ) {
					try {
						this.focus();
						return false;
					} catch ( e ) {

						// Support: IE<9
						// If we error on focus to hidden element (#1486, #12518),
						// let .trigger() run the handlers
					}
				}
			},
			delegateType: "focusin"
		},
		blur: {
			trigger: function() {
				if ( this === safeActiveElement() && this.blur ) {
					this.blur();
					return false;
				}
			},
			delegateType: "focusout"
		},
		click: {

			// For checkbox, fire native event so checked state will be right
			trigger: function() {
				if ( jQuery.nodeName( this, "input" ) && this.type === "checkbox" && this.click ) {
					this.click();
					return false;
				}
			},

			// For cross-browser consistency, don't fire native .click() on links
			_default: function( event ) {
				return jQuery.nodeName( event.target, "a" );
			}
		},

		beforeunload: {
			postDispatch: function( event ) {

				// Support: Firefox 20+
				// Firefox doesn't alert if the returnValue field is not set.
				if ( event.result !== undefined && event.originalEvent ) {
					event.originalEvent.returnValue = event.result;
				}
			}
		}
	},

	// Piggyback on a donor event to simulate a different one
	simulate: function( type, elem, event ) {
		var e = jQuery.extend(
			new jQuery.Event(),
			event,
			{
				type: type,
				isSimulated: true

				// Previously, `originalEvent: {}` was set here, so stopPropagation call
				// would not be triggered on donor event, since in our own
				// jQuery.event.stopPropagation function we had a check for existence of
				// originalEvent.stopPropagation method, so, consequently it would be a noop.
				//
				// Guard for simulated events was moved to jQuery.event.stopPropagation function
				// since `originalEvent` should point to the original event for the
				// constancy with other events and for more focused logic
			}
		);

		jQuery.event.trigger( e, null, elem );

		if ( e.isDefaultPrevented() ) {
			event.preventDefault();
		}
	}
};

jQuery.removeEvent = document.removeEventListener ?
	function( elem, type, handle ) {

		// This "if" is needed for plain objects
		if ( elem.removeEventListener ) {
			elem.removeEventListener( type, handle );
		}
	} :
	function( elem, type, handle ) {
		var name = "on" + type;

		if ( elem.detachEvent ) {

			// #8545, #7054, preventing memory leaks for custom events in IE6-8
			// detachEvent needed property on element, by name of that event,
			// to properly expose it to GC
			if ( typeof elem[ name ] === "undefined" ) {
				elem[ name ] = null;
			}

			elem.detachEvent( name, handle );
		}
	};

jQuery.Event = function( src, props ) {

	// Allow instantiation without the 'new' keyword
	if ( !( this instanceof jQuery.Event ) ) {
		return new jQuery.Event( src, props );
	}

	// Event object
	if ( src && src.type ) {
		this.originalEvent = src;
		this.type = src.type;

		// Events bubbling up the document may have been marked as prevented
		// by a handler lower down the tree; reflect the correct value.
		this.isDefaultPrevented = src.defaultPrevented ||
				src.defaultPrevented === undefined &&

				// Support: IE < 9, Android < 4.0
				src.returnValue === false ?
			returnTrue :
			returnFalse;

	// Event type
	} else {
		this.type = src;
	}

	// Put explicitly provided properties onto the event object
	if ( props ) {
		jQuery.extend( this, props );
	}

	// Create a timestamp if incoming event doesn't have one
	this.timeStamp = src && src.timeStamp || jQuery.now();

	// Mark it as fixed
	this[ jQuery.expando ] = true;
};

// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
// http://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
jQuery.Event.prototype = {
	constructor: jQuery.Event,
	isDefaultPrevented: returnFalse,
	isPropagationStopped: returnFalse,
	isImmediatePropagationStopped: returnFalse,

	preventDefault: function() {
		var e = this.originalEvent;

		this.isDefaultPrevented = returnTrue;
		if ( !e ) {
			return;
		}

		// If preventDefault exists, run it on the original event
		if ( e.preventDefault ) {
			e.preventDefault();

		// Support: IE
		// Otherwise set the returnValue property of the original event to false
		} else {
			e.returnValue = false;
		}
	},
	stopPropagation: function() {
		var e = this.originalEvent;

		this.isPropagationStopped = returnTrue;

		if ( !e || this.isSimulated ) {
			return;
		}

		// If stopPropagation exists, run it on the original event
		if ( e.stopPropagation ) {
			e.stopPropagation();
		}

		// Support: IE
		// Set the cancelBubble property of the original event to true
		e.cancelBubble = true;
	},
	stopImmediatePropagation: function() {
		var e = this.originalEvent;

		this.isImmediatePropagationStopped = returnTrue;

		if ( e && e.stopImmediatePropagation ) {
			e.stopImmediatePropagation();
		}

		this.stopPropagation();
	}
};

// Create mouseenter/leave events using mouseover/out and event-time checks
// so that event delegation works in jQuery.
// Do the same for pointerenter/pointerleave and pointerover/pointerout
//
// Support: Safari 7 only
// Safari sends mouseenter too often; see:
// https://code.google.com/p/chromium/issues/detail?id=470258
// for the description of the bug (it existed in older Chrome versions as well).
jQuery.each( {
	mouseenter: "mouseover",
	mouseleave: "mouseout",
	pointerenter: "pointerover",
	pointerleave: "pointerout"
}, function( orig, fix ) {
	jQuery.event.special[ orig ] = {
		delegateType: fix,
		bindType: fix,

		handle: function( event ) {
			var ret,
				target = this,
				related = event.relatedTarget,
				handleObj = event.handleObj;

			// For mouseenter/leave call the handler if related is outside the target.
			// NB: No relatedTarget if the mouse left/entered the browser window
			if ( !related || ( related !== target && !jQuery.contains( target, related ) ) ) {
				event.type = handleObj.origType;
				ret = handleObj.handler.apply( this, arguments );
				event.type = fix;
			}
			return ret;
		}
	};
} );

// IE submit delegation
if ( !support.submit ) {

	jQuery.event.special.submit = {
		setup: function() {

			// Only need this for delegated form submit events
			if ( jQuery.nodeName( this, "form" ) ) {
				return false;
			}

			// Lazy-add a submit handler when a descendant form may potentially be submitted
			jQuery.event.add( this, "click._submit keypress._submit", function( e ) {

				// Node name check avoids a VML-related crash in IE (#9807)
				var elem = e.target,
					form = jQuery.nodeName( elem, "input" ) || jQuery.nodeName( elem, "button" ) ?

						// Support: IE <=8
						// We use jQuery.prop instead of elem.form
						// to allow fixing the IE8 delegated submit issue (gh-2332)
						// by 3rd party polyfills/workarounds.
						jQuery.prop( elem, "form" ) :
						undefined;

				if ( form && !jQuery._data( form, "submit" ) ) {
					jQuery.event.add( form, "submit._submit", function( event ) {
						event._submitBubble = true;
					} );
					jQuery._data( form, "submit", true );
				}
			} );

			// return undefined since we don't need an event listener
		},

		postDispatch: function( event ) {

			// If form was submitted by the user, bubble the event up the tree
			if ( event._submitBubble ) {
				delete event._submitBubble;
				if ( this.parentNode && !event.isTrigger ) {
					jQuery.event.simulate( "submit", this.parentNode, event );
				}
			}
		},

		teardown: function() {

			// Only need this for delegated form submit events
			if ( jQuery.nodeName( this, "form" ) ) {
				return false;
			}

			// Remove delegated handlers; cleanData eventually reaps submit handlers attached above
			jQuery.event.remove( this, "._submit" );
		}
	};
}

// IE change delegation and checkbox/radio fix
if ( !support.change ) {

	jQuery.event.special.change = {

		setup: function() {

			if ( rformElems.test( this.nodeName ) ) {

				// IE doesn't fire change on a check/radio until blur; trigger it on click
				// after a propertychange. Eat the blur-change in special.change.handle.
				// This still fires onchange a second time for check/radio after blur.
				if ( this.type === "checkbox" || this.type === "radio" ) {
					jQuery.event.add( this, "propertychange._change", function( event ) {
						if ( event.originalEvent.propertyName === "checked" ) {
							this._justChanged = true;
						}
					} );
					jQuery.event.add( this, "click._change", function( event ) {
						if ( this._justChanged && !event.isTrigger ) {
							this._justChanged = false;
						}

						// Allow triggered, simulated change events (#11500)
						jQuery.event.simulate( "change", this, event );
					} );
				}
				return false;
			}

			// Delegated event; lazy-add a change handler on descendant inputs
			jQuery.event.add( this, "beforeactivate._change", function( e ) {
				var elem = e.target;

				if ( rformElems.test( elem.nodeName ) && !jQuery._data( elem, "change" ) ) {
					jQuery.event.add( elem, "change._change", function( event ) {
						if ( this.parentNode && !event.isSimulated && !event.isTrigger ) {
							jQuery.event.simulate( "change", this.parentNode, event );
						}
					} );
					jQuery._data( elem, "change", true );
				}
			} );
		},

		handle: function( event ) {
			var elem = event.target;

			// Swallow native change events from checkbox/radio, we already triggered them above
			if ( this !== elem || event.isSimulated || event.isTrigger ||
				( elem.type !== "radio" && elem.type !== "checkbox" ) ) {

				return event.handleObj.handler.apply( this, arguments );
			}
		},

		teardown: function() {
			jQuery.event.remove( this, "._change" );

			return !rformElems.test( this.nodeName );
		}
	};
}

// Support: Firefox
// Firefox doesn't have focus(in | out) events
// Related ticket - https://bugzilla.mozilla.org/show_bug.cgi?id=687787
//
// Support: Chrome, Safari
// focus(in | out) events fire after focus & blur events,
// which is spec violation - http://www.w3.org/TR/DOM-Level-3-Events/#events-focusevent-event-order
// Related ticket - https://code.google.com/p/chromium/issues/detail?id=449857
if ( !support.focusin ) {
	jQuery.each( { focus: "focusin", blur: "focusout" }, function( orig, fix ) {

		// Attach a single capturing handler on the document while someone wants focusin/focusout
		var handler = function( event ) {
			jQuery.event.simulate( fix, event.target, jQuery.event.fix( event ) );
		};

		jQuery.event.special[ fix ] = {
			setup: function() {
				var doc = this.ownerDocument || this,
					attaches = jQuery._data( doc, fix );

				if ( !attaches ) {
					doc.addEventListener( orig, handler, true );
				}
				jQuery._data( doc, fix, ( attaches || 0 ) + 1 );
			},
			teardown: function() {
				var doc = this.ownerDocument || this,
					attaches = jQuery._data( doc, fix ) - 1;

				if ( !attaches ) {
					doc.removeEventListener( orig, handler, true );
					jQuery._removeData( doc, fix );
				} else {
					jQuery._data( doc, fix, attaches );
				}
			}
		};
	} );
}

jQuery.fn.extend( {

	on: function( types, selector, data, fn ) {
		return on( this, types, selector, data, fn );
	},
	one: function( types, selector, data, fn ) {
		return on( this, types, selector, data, fn, 1 );
	},
	off: function( types, selector, fn ) {
		var handleObj, type;
		if ( types && types.preventDefault && types.handleObj ) {

			// ( event )  dispatched jQuery.Event
			handleObj = types.handleObj;
			jQuery( types.delegateTarget ).off(
				handleObj.namespace ?
					handleObj.origType + "." + handleObj.namespace :
					handleObj.origType,
				handleObj.selector,
				handleObj.handler
			);
			return this;
		}
		if ( typeof types === "object" ) {

			// ( types-object [, selector] )
			for ( type in types ) {
				this.off( type, selector, types[ type ] );
			}
			return this;
		}
		if ( selector === false || typeof selector === "function" ) {

			// ( types [, fn] )
			fn = selector;
			selector = undefined;
		}
		if ( fn === false ) {
			fn = returnFalse;
		}
		return this.each( function() {
			jQuery.event.remove( this, types, fn, selector );
		} );
	},

	trigger: function( type, data ) {
		return this.each( function() {
			jQuery.event.trigger( type, data, this );
		} );
	},
	triggerHandler: function( type, data ) {
		var elem = this[ 0 ];
		if ( elem ) {
			return jQuery.event.trigger( type, data, elem, true );
		}
	}
} );


var rinlinejQuery = / jQuery\d+="(?:null|\d+)"/g,
	rnoshimcache = new RegExp( "<(?:" + nodeNames + ")[\\s/>]", "i" ),
	rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:-]+)[^>]*)\/>/gi,

	// Support: IE 10-11, Edge 10240+
	// In IE/Edge using regex groups here causes severe slowdowns.
	// See https://connect.microsoft.com/IE/feedback/details/1736512/
	rnoInnerhtml = /<script|<style|<link/i,

	// checked="checked" or checked
	rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,
	rscriptTypeMasked = /^true\/(.*)/,
	rcleanScript = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g,
	safeFragment = createSafeFragment( document ),
	fragmentDiv = safeFragment.appendChild( document.createElement( "div" ) );

// Support: IE<8
// Manipulating tables requires a tbody
function manipulationTarget( elem, content ) {
	return jQuery.nodeName( elem, "table" ) &&
		jQuery.nodeName( content.nodeType !== 11 ? content : content.firstChild, "tr" ) ?

		elem.getElementsByTagName( "tbody" )[ 0 ] ||
			elem.appendChild( elem.ownerDocument.createElement( "tbody" ) ) :
		elem;
}

// Replace/restore the type attribute of script elements for safe DOM manipulation
function disableScript( elem ) {
	elem.type = ( jQuery.find.attr( elem, "type" ) !== null ) + "/" + elem.type;
	return elem;
}
function restoreScript( elem ) {
	var match = rscriptTypeMasked.exec( elem.type );
	if ( match ) {
		elem.type = match[ 1 ];
	} else {
		elem.removeAttribute( "type" );
	}
	return elem;
}

function cloneCopyEvent( src, dest ) {
	if ( dest.nodeType !== 1 || !jQuery.hasData( src ) ) {
		return;
	}

	var type, i, l,
		oldData = jQuery._data( src ),
		curData = jQuery._data( dest, oldData ),
		events = oldData.events;

	if ( events ) {
		delete curData.handle;
		curData.events = {};

		for ( type in events ) {
			for ( i = 0, l = events[ type ].length; i < l; i++ ) {
				jQuery.event.add( dest, type, events[ type ][ i ] );
			}
		}
	}

	// make the cloned public data object a copy from the original
	if ( curData.data ) {
		curData.data = jQuery.extend( {}, curData.data );
	}
}

function fixCloneNodeIssues( src, dest ) {
	var nodeName, e, data;

	// We do not need to do anything for non-Elements
	if ( dest.nodeType !== 1 ) {
		return;
	}

	nodeName = dest.nodeName.toLowerCase();

	// IE6-8 copies events bound via attachEvent when using cloneNode.
	if ( !support.noCloneEvent && dest[ jQuery.expando ] ) {
		data = jQuery._data( dest );

		for ( e in data.events ) {
			jQuery.removeEvent( dest, e, data.handle );
		}

		// Event data gets referenced instead of copied if the expando gets copied too
		dest.removeAttribute( jQuery.expando );
	}

	// IE blanks contents when cloning scripts, and tries to evaluate newly-set text
	if ( nodeName === "script" && dest.text !== src.text ) {
		disableScript( dest ).text = src.text;
		restoreScript( dest );

	// IE6-10 improperly clones children of object elements using classid.
	// IE10 throws NoModificationAllowedError if parent is null, #12132.
	} else if ( nodeName === "object" ) {
		if ( dest.parentNode ) {
			dest.outerHTML = src.outerHTML;
		}

		// This path appears unavoidable for IE9. When cloning an object
		// element in IE9, the outerHTML strategy above is not sufficient.
		// If the src has innerHTML and the destination does not,
		// copy the src.innerHTML into the dest.innerHTML. #10324
		if ( support.html5Clone && ( src.innerHTML && !jQuery.trim( dest.innerHTML ) ) ) {
			dest.innerHTML = src.innerHTML;
		}

	} else if ( nodeName === "input" && rcheckableType.test( src.type ) ) {

		// IE6-8 fails to persist the checked state of a cloned checkbox
		// or radio button. Worse, IE6-7 fail to give the cloned element
		// a checked appearance if the defaultChecked value isn't also set

		dest.defaultChecked = dest.checked = src.checked;

		// IE6-7 get confused and end up setting the value of a cloned
		// checkbox/radio button to an empty string instead of "on"
		if ( dest.value !== src.value ) {
			dest.value = src.value;
		}

	// IE6-8 fails to return the selected option to the default selected
	// state when cloning options
	} else if ( nodeName === "option" ) {
		dest.defaultSelected = dest.selected = src.defaultSelected;

	// IE6-8 fails to set the defaultValue to the correct value when
	// cloning other types of input fields
	} else if ( nodeName === "input" || nodeName === "textarea" ) {
		dest.defaultValue = src.defaultValue;
	}
}

function domManip( collection, args, callback, ignored ) {

	// Flatten any nested arrays
	args = concat.apply( [], args );

	var first, node, hasScripts,
		scripts, doc, fragment,
		i = 0,
		l = collection.length,
		iNoClone = l - 1,
		value = args[ 0 ],
		isFunction = jQuery.isFunction( value );

	// We can't cloneNode fragments that contain checked, in WebKit
	if ( isFunction ||
			( l > 1 && typeof value === "string" &&
				!support.checkClone && rchecked.test( value ) ) ) {
		return collection.each( function( index ) {
			var self = collection.eq( index );
			if ( isFunction ) {
				args[ 0 ] = value.call( this, index, self.html() );
			}
			domManip( self, args, callback, ignored );
		} );
	}

	if ( l ) {
		fragment = buildFragment( args, collection[ 0 ].ownerDocument, false, collection, ignored );
		first = fragment.firstChild;

		if ( fragment.childNodes.length === 1 ) {
			fragment = first;
		}

		// Require either new content or an interest in ignored elements to invoke the callback
		if ( first || ignored ) {
			scripts = jQuery.map( getAll( fragment, "script" ), disableScript );
			hasScripts = scripts.length;

			// Use the original fragment for the last item
			// instead of the first because it can end up
			// being emptied incorrectly in certain situations (#8070).
			for ( ; i < l; i++ ) {
				node = fragment;

				if ( i !== iNoClone ) {
					node = jQuery.clone( node, true, true );

					// Keep references to cloned scripts for later restoration
					if ( hasScripts ) {

						// Support: Android<4.1, PhantomJS<2
						// push.apply(_, arraylike) throws on ancient WebKit
						jQuery.merge( scripts, getAll( node, "script" ) );
					}
				}

				callback.call( collection[ i ], node, i );
			}

			if ( hasScripts ) {
				doc = scripts[ scripts.length - 1 ].ownerDocument;

				// Reenable scripts
				jQuery.map( scripts, restoreScript );

				// Evaluate executable scripts on first document insertion
				for ( i = 0; i < hasScripts; i++ ) {
					node = scripts[ i ];
					if ( rscriptType.test( node.type || "" ) &&
						!jQuery._data( node, "globalEval" ) &&
						jQuery.contains( doc, node ) ) {

						if ( node.src ) {

							// Optional AJAX dependency, but won't run scripts if not present
							if ( jQuery._evalUrl ) {
								jQuery._evalUrl( node.src );
							}
						} else {
							jQuery.globalEval(
								( node.text || node.textContent || node.innerHTML || "" )
									.replace( rcleanScript, "" )
							);
						}
					}
				}
			}

			// Fix #11809: Avoid leaking memory
			fragment = first = null;
		}
	}

	return collection;
}

function remove( elem, selector, keepData ) {
	var node,
		elems = selector ? jQuery.filter( selector, elem ) : elem,
		i = 0;

	for ( ; ( node = elems[ i ] ) != null; i++ ) {

		if ( !keepData && node.nodeType === 1 ) {
			jQuery.cleanData( getAll( node ) );
		}

		if ( node.parentNode ) {
			if ( keepData && jQuery.contains( node.ownerDocument, node ) ) {
				setGlobalEval( getAll( node, "script" ) );
			}
			node.parentNode.removeChild( node );
		}
	}

	return elem;
}

jQuery.extend( {
	htmlPrefilter: function( html ) {
		return html.replace( rxhtmlTag, "<$1></$2>" );
	},

	clone: function( elem, dataAndEvents, deepDataAndEvents ) {
		var destElements, node, clone, i, srcElements,
			inPage = jQuery.contains( elem.ownerDocument, elem );

		if ( support.html5Clone || jQuery.isXMLDoc( elem ) ||
			!rnoshimcache.test( "<" + elem.nodeName + ">" ) ) {

			clone = elem.cloneNode( true );

		// IE<=8 does not properly clone detached, unknown element nodes
		} else {
			fragmentDiv.innerHTML = elem.outerHTML;
			fragmentDiv.removeChild( clone = fragmentDiv.firstChild );
		}

		if ( ( !support.noCloneEvent || !support.noCloneChecked ) &&
				( elem.nodeType === 1 || elem.nodeType === 11 ) && !jQuery.isXMLDoc( elem ) ) {

			// We eschew Sizzle here for performance reasons: http://jsperf.com/getall-vs-sizzle/2
			destElements = getAll( clone );
			srcElements = getAll( elem );

			// Fix all IE cloning issues
			for ( i = 0; ( node = srcElements[ i ] ) != null; ++i ) {

				// Ensure that the destination node is not null; Fixes #9587
				if ( destElements[ i ] ) {
					fixCloneNodeIssues( node, destElements[ i ] );
				}
			}
		}

		// Copy the events from the original to the clone
		if ( dataAndEvents ) {
			if ( deepDataAndEvents ) {
				srcElements = srcElements || getAll( elem );
				destElements = destElements || getAll( clone );

				for ( i = 0; ( node = srcElements[ i ] ) != null; i++ ) {
					cloneCopyEvent( node, destElements[ i ] );
				}
			} else {
				cloneCopyEvent( elem, clone );
			}
		}

		// Preserve script evaluation history
		destElements = getAll( clone, "script" );
		if ( destElements.length > 0 ) {
			setGlobalEval( destElements, !inPage && getAll( elem, "script" ) );
		}

		destElements = srcElements = node = null;

		// Return the cloned set
		return clone;
	},

	cleanData: function( elems, /* internal */ forceAcceptData ) {
		var elem, type, id, data,
			i = 0,
			internalKey = jQuery.expando,
			cache = jQuery.cache,
			attributes = support.attributes,
			special = jQuery.event.special;

		for ( ; ( elem = elems[ i ] ) != null; i++ ) {
			if ( forceAcceptData || acceptData( elem ) ) {

				id = elem[ internalKey ];
				data = id && cache[ id ];

				if ( data ) {
					if ( data.events ) {
						for ( type in data.events ) {
							if ( special[ type ] ) {
								jQuery.event.remove( elem, type );

							// This is a shortcut to avoid jQuery.event.remove's overhead
							} else {
								jQuery.removeEvent( elem, type, data.handle );
							}
						}
					}

					// Remove cache only if it was not already removed by jQuery.event.remove
					if ( cache[ id ] ) {

						delete cache[ id ];

						// Support: IE<9
						// IE does not allow us to delete expando properties from nodes
						// IE creates expando attributes along with the property
						// IE does not have a removeAttribute function on Document nodes
						if ( !attributes && typeof elem.removeAttribute !== "undefined" ) {
							elem.removeAttribute( internalKey );

						// Webkit & Blink performance suffers when deleting properties
						// from DOM nodes, so set to undefined instead
						// https://code.google.com/p/chromium/issues/detail?id=378607
						} else {
							elem[ internalKey ] = undefined;
						}

						deletedIds.push( id );
					}
				}
			}
		}
	}
} );

jQuery.fn.extend( {

	// Keep domManip exposed until 3.0 (gh-2225)
	domManip: domManip,

	detach: function( selector ) {
		return remove( this, selector, true );
	},

	remove: function( selector ) {
		return remove( this, selector );
	},

	text: function( value ) {
		return access( this, function( value ) {
			return value === undefined ?
				jQuery.text( this ) :
				this.empty().append(
					( this[ 0 ] && this[ 0 ].ownerDocument || document ).createTextNode( value )
				);
		}, null, value, arguments.length );
	},

	append: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
				var target = manipulationTarget( this, elem );
				target.appendChild( elem );
			}
		} );
	},

	prepend: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
				var target = manipulationTarget( this, elem );
				target.insertBefore( elem, target.firstChild );
			}
		} );
	},

	before: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.parentNode ) {
				this.parentNode.insertBefore( elem, this );
			}
		} );
	},

	after: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.parentNode ) {
				this.parentNode.insertBefore( elem, this.nextSibling );
			}
		} );
	},

	empty: function() {
		var elem,
			i = 0;

		for ( ; ( elem = this[ i ] ) != null; i++ ) {

			// Remove element nodes and prevent memory leaks
			if ( elem.nodeType === 1 ) {
				jQuery.cleanData( getAll( elem, false ) );
			}

			// Remove any remaining nodes
			while ( elem.firstChild ) {
				elem.removeChild( elem.firstChild );
			}

			// If this is a select, ensure that it displays empty (#12336)
			// Support: IE<9
			if ( elem.options && jQuery.nodeName( elem, "select" ) ) {
				elem.options.length = 0;
			}
		}

		return this;
	},

	clone: function( dataAndEvents, deepDataAndEvents ) {
		dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
		deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;

		return this.map( function() {
			return jQuery.clone( this, dataAndEvents, deepDataAndEvents );
		} );
	},

	html: function( value ) {
		return access( this, function( value ) {
			var elem = this[ 0 ] || {},
				i = 0,
				l = this.length;

			if ( value === undefined ) {
				return elem.nodeType === 1 ?
					elem.innerHTML.replace( rinlinejQuery, "" ) :
					undefined;
			}

			// See if we can take a shortcut and just use innerHTML
			if ( typeof value === "string" && !rnoInnerhtml.test( value ) &&
				( support.htmlSerialize || !rnoshimcache.test( value )  ) &&
				( support.leadingWhitespace || !rleadingWhitespace.test( value ) ) &&
				!wrapMap[ ( rtagName.exec( value ) || [ "", "" ] )[ 1 ].toLowerCase() ] ) {

				value = jQuery.htmlPrefilter( value );

				try {
					for ( ; i < l; i++ ) {

						// Remove element nodes and prevent memory leaks
						elem = this[ i ] || {};
						if ( elem.nodeType === 1 ) {
							jQuery.cleanData( getAll( elem, false ) );
							elem.innerHTML = value;
						}
					}

					elem = 0;

				// If using innerHTML throws an exception, use the fallback method
				} catch ( e ) {}
			}

			if ( elem ) {
				this.empty().append( value );
			}
		}, null, value, arguments.length );
	},

	replaceWith: function() {
		var ignored = [];

		// Make the changes, replacing each non-ignored context element with the new content
		return domManip( this, arguments, function( elem ) {
			var parent = this.parentNode;

			if ( jQuery.inArray( this, ignored ) < 0 ) {
				jQuery.cleanData( getAll( this ) );
				if ( parent ) {
					parent.replaceChild( elem, this );
				}
			}

		// Force callback invocation
		}, ignored );
	}
} );

jQuery.each( {
	appendTo: "append",
	prependTo: "prepend",
	insertBefore: "before",
	insertAfter: "after",
	replaceAll: "replaceWith"
}, function( name, original ) {
	jQuery.fn[ name ] = function( selector ) {
		var elems,
			i = 0,
			ret = [],
			insert = jQuery( selector ),
			last = insert.length - 1;

		for ( ; i <= last; i++ ) {
			elems = i === last ? this : this.clone( true );
			jQuery( insert[ i ] )[ original ]( elems );

			// Modern browsers can apply jQuery collections as arrays, but oldIE needs a .get()
			push.apply( ret, elems.get() );
		}

		return this.pushStack( ret );
	};
} );


var iframe,
	elemdisplay = {

		// Support: Firefox
		// We have to pre-define these values for FF (#10227)
		HTML: "block",
		BODY: "block"
	};

/**
 * Retrieve the actual display of a element
 * @param {String} name nodeName of the element
 * @param {Object} doc Document object
 */

// Called only from within defaultDisplay
function actualDisplay( name, doc ) {
	var elem = jQuery( doc.createElement( name ) ).appendTo( doc.body ),

		display = jQuery.css( elem[ 0 ], "display" );

	// We don't have any data stored on the element,
	// so use "detach" method as fast way to get rid of the element
	elem.detach();

	return display;
}

/**
 * Try to determine the default display value of an element
 * @param {String} nodeName
 */
function defaultDisplay( nodeName ) {
	var doc = document,
		display = elemdisplay[ nodeName ];

	if ( !display ) {
		display = actualDisplay( nodeName, doc );

		// If the simple way fails, read from inside an iframe
		if ( display === "none" || !display ) {

			// Use the already-created iframe if possible
			iframe = ( iframe || jQuery( "<iframe frameborder='0' width='0' height='0'/>" ) )
				.appendTo( doc.documentElement );

			// Always write a new HTML skeleton so Webkit and Firefox don't choke on reuse
			doc = ( iframe[ 0 ].contentWindow || iframe[ 0 ].contentDocument ).document;

			// Support: IE
			doc.write();
			doc.close();

			display = actualDisplay( nodeName, doc );
			iframe.detach();
		}

		// Store the correct default display
		elemdisplay[ nodeName ] = display;
	}

	return display;
}
var rmargin = ( /^margin/ );

var rnumnonpx = new RegExp( "^(" + pnum + ")(?!px)[a-z%]+$", "i" );

var swap = function( elem, options, callback, args ) {
	var ret, name,
		old = {};

	// Remember the old values, and insert the new ones
	for ( name in options ) {
		old[ name ] = elem.style[ name ];
		elem.style[ name ] = options[ name ];
	}

	ret = callback.apply( elem, args || [] );

	// Revert the old values
	for ( name in options ) {
		elem.style[ name ] = old[ name ];
	}

	return ret;
};


var documentElement = document.documentElement;



( function() {
	var pixelPositionVal, pixelMarginRightVal, boxSizingReliableVal,
		reliableHiddenOffsetsVal, reliableMarginRightVal, reliableMarginLeftVal,
		container = document.createElement( "div" ),
		div = document.createElement( "div" );

	// Finish early in limited (non-browser) environments
	if ( !div.style ) {
		return;
	}

	div.style.cssText = "float:left;opacity:.5";

	// Support: IE<9
	// Make sure that element opacity exists (as opposed to filter)
	support.opacity = div.style.opacity === "0.5";

	// Verify style float existence
	// (IE uses styleFloat instead of cssFloat)
	support.cssFloat = !!div.style.cssFloat;

	div.style.backgroundClip = "content-box";
	div.cloneNode( true ).style.backgroundClip = "";
	support.clearCloneStyle = div.style.backgroundClip === "content-box";

	container = document.createElement( "div" );
	container.style.cssText = "border:0;width:8px;height:0;top:0;left:-9999px;" +
		"padding:0;margin-top:1px;position:absolute";
	div.innerHTML = "";
	container.appendChild( div );

	// Support: Firefox<29, Android 2.3
	// Vendor-prefix box-sizing
	support.boxSizing = div.style.boxSizing === "" || div.style.MozBoxSizing === "" ||
		div.style.WebkitBoxSizing === "";

	jQuery.extend( support, {
		reliableHiddenOffsets: function() {
			if ( pixelPositionVal == null ) {
				computeStyleTests();
			}
			return reliableHiddenOffsetsVal;
		},

		boxSizingReliable: function() {

			// We're checking for pixelPositionVal here instead of boxSizingReliableVal
			// since that compresses better and they're computed together anyway.
			if ( pixelPositionVal == null ) {
				computeStyleTests();
			}
			return boxSizingReliableVal;
		},

		pixelMarginRight: function() {

			// Support: Android 4.0-4.3
			if ( pixelPositionVal == null ) {
				computeStyleTests();
			}
			return pixelMarginRightVal;
		},

		pixelPosition: function() {
			if ( pixelPositionVal == null ) {
				computeStyleTests();
			}
			return pixelPositionVal;
		},

		reliableMarginRight: function() {

			// Support: Android 2.3
			if ( pixelPositionVal == null ) {
				computeStyleTests();
			}
			return reliableMarginRightVal;
		},

		reliableMarginLeft: function() {

			// Support: IE <=8 only, Android 4.0 - 4.3 only, Firefox <=3 - 37
			if ( pixelPositionVal == null ) {
				computeStyleTests();
			}
			return reliableMarginLeftVal;
		}
	} );

	function computeStyleTests() {
		var contents, divStyle,
			documentElement = document.documentElement;

		// Setup
		documentElement.appendChild( container );

		div.style.cssText =

			// Support: Android 2.3
			// Vendor-prefix box-sizing
			"-webkit-box-sizing:border-box;box-sizing:border-box;" +
			"position:relative;display:block;" +
			"margin:auto;border:1px;padding:1px;" +
			"top:1%;width:50%";

		// Support: IE<9
		// Assume reasonable values in the absence of getComputedStyle
		pixelPositionVal = boxSizingReliableVal = reliableMarginLeftVal = false;
		pixelMarginRightVal = reliableMarginRightVal = true;

		// Check for getComputedStyle so that this code is not run in IE<9.
		if ( window.getComputedStyle ) {
			divStyle = window.getComputedStyle( div );
			pixelPositionVal = ( divStyle || {} ).top !== "1%";
			reliableMarginLeftVal = ( divStyle || {} ).marginLeft === "2px";
			boxSizingReliableVal = ( divStyle || { width: "4px" } ).width === "4px";

			// Support: Android 4.0 - 4.3 only
			// Some styles come back with percentage values, even though they shouldn't
			div.style.marginRight = "50%";
			pixelMarginRightVal = ( divStyle || { marginRight: "4px" } ).marginRight === "4px";

			// Support: Android 2.3 only
			// Div with explicit width and no margin-right incorrectly
			// gets computed margin-right based on width of container (#3333)
			// WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right
			contents = div.appendChild( document.createElement( "div" ) );

			// Reset CSS: box-sizing; display; margin; border; padding
			contents.style.cssText = div.style.cssText =

				// Support: Android 2.3
				// Vendor-prefix box-sizing
				"-webkit-box-sizing:content-box;-moz-box-sizing:content-box;" +
				"box-sizing:content-box;display:block;margin:0;border:0;padding:0";
			contents.style.marginRight = contents.style.width = "0";
			div.style.width = "1px";

			reliableMarginRightVal =
				!parseFloat( ( window.getComputedStyle( contents ) || {} ).marginRight );

			div.removeChild( contents );
		}

		// Support: IE6-8
		// First check that getClientRects works as expected
		// Check if table cells still have offsetWidth/Height when they are set
		// to display:none and there are still other visible table cells in a
		// table row; if so, offsetWidth/Height are not reliable for use when
		// determining if an element has been hidden directly using
		// display:none (it is still safe to use offsets if a parent element is
		// hidden; don safety goggles and see bug #4512 for more information).
		div.style.display = "none";
		reliableHiddenOffsetsVal = div.getClientRects().length === 0;
		if ( reliableHiddenOffsetsVal ) {
			div.style.display = "";
			div.innerHTML = "<table><tr><td></td><td>t</td></tr></table>";
			div.childNodes[ 0 ].style.borderCollapse = "separate";
			contents = div.getElementsByTagName( "td" );
			contents[ 0 ].style.cssText = "margin:0;border:0;padding:0;display:none";
			reliableHiddenOffsetsVal = contents[ 0 ].offsetHeight === 0;
			if ( reliableHiddenOffsetsVal ) {
				contents[ 0 ].style.display = "";
				contents[ 1 ].style.display = "none";
				reliableHiddenOffsetsVal = contents[ 0 ].offsetHeight === 0;
			}
		}

		// Teardown
		documentElement.removeChild( container );
	}

} )();


var getStyles, curCSS,
	rposition = /^(top|right|bottom|left)$/;

if ( window.getComputedStyle ) {
	getStyles = function( elem ) {

		// Support: IE<=11+, Firefox<=30+ (#15098, #14150)
		// IE throws on elements created in popups
		// FF meanwhile throws on frame elements through "defaultView.getComputedStyle"
		var view = elem.ownerDocument.defaultView;

		if ( !view || !view.opener ) {
			view = window;
		}

		return view.getComputedStyle( elem );
	};

	curCSS = function( elem, name, computed ) {
		var width, minWidth, maxWidth, ret,
			style = elem.style;

		computed = computed || getStyles( elem );

		// getPropertyValue is only needed for .css('filter') in IE9, see #12537
		ret = computed ? computed.getPropertyValue( name ) || computed[ name ] : undefined;

		// Support: Opera 12.1x only
		// Fall back to style even without computed
		// computed is undefined for elems on document fragments
		if ( ( ret === "" || ret === undefined ) && !jQuery.contains( elem.ownerDocument, elem ) ) {
			ret = jQuery.style( elem, name );
		}

		if ( computed ) {

			// A tribute to the "awesome hack by Dean Edwards"
			// Chrome < 17 and Safari 5.0 uses "computed value"
			// instead of "used value" for margin-right
			// Safari 5.1.7 (at least) returns percentage for a larger set of values,
			// but width seems to be reliably pixels
			// this is against the CSSOM draft spec:
			// http://dev.w3.org/csswg/cssom/#resolved-values
			if ( !support.pixelMarginRight() && rnumnonpx.test( ret ) && rmargin.test( name ) ) {

				// Remember the original values
				width = style.width;
				minWidth = style.minWidth;
				maxWidth = style.maxWidth;

				// Put in the new values to get a computed value out
				style.minWidth = style.maxWidth = style.width = ret;
				ret = computed.width;

				// Revert the changed values
				style.width = width;
				style.minWidth = minWidth;
				style.maxWidth = maxWidth;
			}
		}

		// Support: IE
		// IE returns zIndex value as an integer.
		return ret === undefined ?
			ret :
			ret + "";
	};
} else if ( documentElement.currentStyle ) {
	getStyles = function( elem ) {
		return elem.currentStyle;
	};

	curCSS = function( elem, name, computed ) {
		var left, rs, rsLeft, ret,
			style = elem.style;

		computed = computed || getStyles( elem );
		ret = computed ? computed[ name ] : undefined;

		// Avoid setting ret to empty string here
		// so we don't default to auto
		if ( ret == null && style && style[ name ] ) {
			ret = style[ name ];
		}

		// From the awesome hack by Dean Edwards
		// http://erik.eae.net/archives/2007/07/27/18.54.15/#comment-102291

		// If we're not dealing with a regular pixel number
		// but a number that has a weird ending, we need to convert it to pixels
		// but not position css attributes, as those are
		// proportional to the parent element instead
		// and we can't measure the parent instead because it
		// might trigger a "stacking dolls" problem
		if ( rnumnonpx.test( ret ) && !rposition.test( name ) ) {

			// Remember the original values
			left = style.left;
			rs = elem.runtimeStyle;
			rsLeft = rs && rs.left;

			// Put in the new values to get a computed value out
			if ( rsLeft ) {
				rs.left = elem.currentStyle.left;
			}
			style.left = name === "fontSize" ? "1em" : ret;
			ret = style.pixelLeft + "px";

			// Revert the changed values
			style.left = left;
			if ( rsLeft ) {
				rs.left = rsLeft;
			}
		}

		// Support: IE
		// IE returns zIndex value as an integer.
		return ret === undefined ?
			ret :
			ret + "" || "auto";
	};
}




function addGetHookIf( conditionFn, hookFn ) {

	// Define the hook, we'll check on the first run if it's really needed.
	return {
		get: function() {
			if ( conditionFn() ) {

				// Hook not needed (or it's not possible to use it due
				// to missing dependency), remove it.
				delete this.get;
				return;
			}

			// Hook needed; redefine it so that the support test is not executed again.
			return ( this.get = hookFn ).apply( this, arguments );
		}
	};
}


var

		ralpha = /alpha\([^)]*\)/i,
	ropacity = /opacity\s*=\s*([^)]*)/i,

	// swappable if display is none or starts with table except
	// "table", "table-cell", or "table-caption"
	// see here for display values:
	// https://developer.mozilla.org/en-US/docs/CSS/display
	rdisplayswap = /^(none|table(?!-c[ea]).+)/,
	rnumsplit = new RegExp( "^(" + pnum + ")(.*)$", "i" ),

	cssShow = { position: "absolute", visibility: "hidden", display: "block" },
	cssNormalTransform = {
		letterSpacing: "0",
		fontWeight: "400"
	},

	cssPrefixes = [ "Webkit", "O", "Moz", "ms" ],
	emptyStyle = document.createElement( "div" ).style;


// return a css property mapped to a potentially vendor prefixed property
function vendorPropName( name ) {

	// shortcut for names that are not vendor prefixed
	if ( name in emptyStyle ) {
		return name;
	}

	// check for vendor prefixed names
	var capName = name.charAt( 0 ).toUpperCase() + name.slice( 1 ),
		i = cssPrefixes.length;

	while ( i-- ) {
		name = cssPrefixes[ i ] + capName;
		if ( name in emptyStyle ) {
			return name;
		}
	}
}

function showHide( elements, show ) {
	var display, elem, hidden,
		values = [],
		index = 0,
		length = elements.length;

	for ( ; index < length; index++ ) {
		elem = elements[ index ];
		if ( !elem.style ) {
			continue;
		}

		values[ index ] = jQuery._data( elem, "olddisplay" );
		display = elem.style.display;
		if ( show ) {

			// Reset the inline display of this element to learn if it is
			// being hidden by cascaded rules or not
			if ( !values[ index ] && display === "none" ) {
				elem.style.display = "";
			}

			// Set elements which have been overridden with display: none
			// in a stylesheet to whatever the default browser style is
			// for such an element
			if ( elem.style.display === "" && isHidden( elem ) ) {
				values[ index ] =
					jQuery._data( elem, "olddisplay", defaultDisplay( elem.nodeName ) );
			}
		} else {
			hidden = isHidden( elem );

			if ( display && display !== "none" || !hidden ) {
				jQuery._data(
					elem,
					"olddisplay",
					hidden ? display : jQuery.css( elem, "display" )
				);
			}
		}
	}

	// Set the display of most of the elements in a second loop
	// to avoid the constant reflow
	for ( index = 0; index < length; index++ ) {
		elem = elements[ index ];
		if ( !elem.style ) {
			continue;
		}
		if ( !show || elem.style.display === "none" || elem.style.display === "" ) {
			elem.style.display = show ? values[ index ] || "" : "none";
		}
	}

	return elements;
}

function setPositiveNumber( elem, value, subtract ) {
	var matches = rnumsplit.exec( value );
	return matches ?

		// Guard against undefined "subtract", e.g., when used as in cssHooks
		Math.max( 0, matches[ 1 ] - ( subtract || 0 ) ) + ( matches[ 2 ] || "px" ) :
		value;
}

function augmentWidthOrHeight( elem, name, extra, isBorderBox, styles ) {
	var i = extra === ( isBorderBox ? "border" : "content" ) ?

		// If we already have the right measurement, avoid augmentation
		4 :

		// Otherwise initialize for horizontal or vertical properties
		name === "width" ? 1 : 0,

		val = 0;

	for ( ; i < 4; i += 2 ) {

		// both box models exclude margin, so add it if we want it
		if ( extra === "margin" ) {
			val += jQuery.css( elem, extra + cssExpand[ i ], true, styles );
		}

		if ( isBorderBox ) {

			// border-box includes padding, so remove it if we want content
			if ( extra === "content" ) {
				val -= jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );
			}

			// at this point, extra isn't border nor margin, so remove border
			if ( extra !== "margin" ) {
				val -= jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
			}
		} else {

			// at this point, extra isn't content, so add padding
			val += jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );

			// at this point, extra isn't content nor padding, so add border
			if ( extra !== "padding" ) {
				val += jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
			}
		}
	}

	return val;
}

function getWidthOrHeight( elem, name, extra ) {

	// Start with offset property, which is equivalent to the border-box value
	var valueIsBorderBox = true,
		val = name === "width" ? elem.offsetWidth : elem.offsetHeight,
		styles = getStyles( elem ),
		isBorderBox = support.boxSizing &&
			jQuery.css( elem, "boxSizing", false, styles ) === "border-box";

	// some non-html elements return undefined for offsetWidth, so check for null/undefined
	// svg - https://bugzilla.mozilla.org/show_bug.cgi?id=649285
	// MathML - https://bugzilla.mozilla.org/show_bug.cgi?id=491668
	if ( val <= 0 || val == null ) {

		// Fall back to computed then uncomputed css if necessary
		val = curCSS( elem, name, styles );
		if ( val < 0 || val == null ) {
			val = elem.style[ name ];
		}

		// Computed unit is not pixels. Stop here and return.
		if ( rnumnonpx.test( val ) ) {
			return val;
		}

		// we need the check for style in case a browser which returns unreliable values
		// for getComputedStyle silently falls back to the reliable elem.style
		valueIsBorderBox = isBorderBox &&
			( support.boxSizingReliable() || val === elem.style[ name ] );

		// Normalize "", auto, and prepare for extra
		val = parseFloat( val ) || 0;
	}

	// use the active box-sizing model to add/subtract irrelevant styles
	return ( val +
		augmentWidthOrHeight(
			elem,
			name,
			extra || ( isBorderBox ? "border" : "content" ),
			valueIsBorderBox,
			styles
		)
	) + "px";
}

jQuery.extend( {

	// Add in style property hooks for overriding the default
	// behavior of getting and setting a style property
	cssHooks: {
		opacity: {
			get: function( elem, computed ) {
				if ( computed ) {

					// We should always get a number back from opacity
					var ret = curCSS( elem, "opacity" );
					return ret === "" ? "1" : ret;
				}
			}
		}
	},

	// Don't automatically add "px" to these possibly-unitless properties
	cssNumber: {
		"animationIterationCount": true,
		"columnCount": true,
		"fillOpacity": true,
		"flexGrow": true,
		"flexShrink": true,
		"fontWeight": true,
		"lineHeight": true,
		"opacity": true,
		"order": true,
		"orphans": true,
		"widows": true,
		"zIndex": true,
		"zoom": true
	},

	// Add in properties whose names you wish to fix before
	// setting or getting the value
	cssProps: {

		// normalize float css property
		"float": support.cssFloat ? "cssFloat" : "styleFloat"
	},

	// Get and set the style property on a DOM Node
	style: function( elem, name, value, extra ) {

		// Don't set styles on text and comment nodes
		if ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) {
			return;
		}

		// Make sure that we're working with the right name
		var ret, type, hooks,
			origName = jQuery.camelCase( name ),
			style = elem.style;

		name = jQuery.cssProps[ origName ] ||
			( jQuery.cssProps[ origName ] = vendorPropName( origName ) || origName );

		// gets hook for the prefixed version
		// followed by the unprefixed version
		hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

		// Check if we're setting a value
		if ( value !== undefined ) {
			type = typeof value;

			// Convert "+=" or "-=" to relative numbers (#7345)
			if ( type === "string" && ( ret = rcssNum.exec( value ) ) && ret[ 1 ] ) {
				value = adjustCSS( elem, name, ret );

				// Fixes bug #9237
				type = "number";
			}

			// Make sure that null and NaN values aren't set. See: #7116
			if ( value == null || value !== value ) {
				return;
			}

			// If a number was passed in, add the unit (except for certain CSS properties)
			if ( type === "number" ) {
				value += ret && ret[ 3 ] || ( jQuery.cssNumber[ origName ] ? "" : "px" );
			}

			// Fixes #8908, it can be done more correctly by specifing setters in cssHooks,
			// but it would mean to define eight
			// (for every problematic property) identical functions
			if ( !support.clearCloneStyle && value === "" && name.indexOf( "background" ) === 0 ) {
				style[ name ] = "inherit";
			}

			// If a hook was provided, use that value, otherwise just set the specified value
			if ( !hooks || !( "set" in hooks ) ||
				( value = hooks.set( elem, value, extra ) ) !== undefined ) {

				// Support: IE
				// Swallow errors from 'invalid' CSS values (#5509)
				try {
					style[ name ] = value;
				} catch ( e ) {}
			}

		} else {

			// If a hook was provided get the non-computed value from there
			if ( hooks && "get" in hooks &&
				( ret = hooks.get( elem, false, extra ) ) !== undefined ) {

				return ret;
			}

			// Otherwise just get the value from the style object
			return style[ name ];
		}
	},

	css: function( elem, name, extra, styles ) {
		var num, val, hooks,
			origName = jQuery.camelCase( name );

		// Make sure that we're working with the right name
		name = jQuery.cssProps[ origName ] ||
			( jQuery.cssProps[ origName ] = vendorPropName( origName ) || origName );

		// gets hook for the prefixed version
		// followed by the unprefixed version
		hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

		// If a hook was provided get the computed value from there
		if ( hooks && "get" in hooks ) {
			val = hooks.get( elem, true, extra );
		}

		// Otherwise, if a way to get the computed value exists, use that
		if ( val === undefined ) {
			val = curCSS( elem, name, styles );
		}

		//convert "normal" to computed value
		if ( val === "normal" && name in cssNormalTransform ) {
			val = cssNormalTransform[ name ];
		}

		// Return, converting to number if forced or a qualifier was provided and val looks numeric
		if ( extra === "" || extra ) {
			num = parseFloat( val );
			return extra === true || isFinite( num ) ? num || 0 : val;
		}
		return val;
	}
} );

jQuery.each( [ "height", "width" ], function( i, name ) {
	jQuery.cssHooks[ name ] = {
		get: function( elem, computed, extra ) {
			if ( computed ) {

				// certain elements can have dimension info if we invisibly show them
				// however, it must have a current display style that would benefit from this
				return rdisplayswap.test( jQuery.css( elem, "display" ) ) &&
					elem.offsetWidth === 0 ?
						swap( elem, cssShow, function() {
							return getWidthOrHeight( elem, name, extra );
						} ) :
						getWidthOrHeight( elem, name, extra );
			}
		},

		set: function( elem, value, extra ) {
			var styles = extra && getStyles( elem );
			return setPositiveNumber( elem, value, extra ?
				augmentWidthOrHeight(
					elem,
					name,
					extra,
					support.boxSizing &&
						jQuery.css( elem, "boxSizing", false, styles ) === "border-box",
					styles
				) : 0
			);
		}
	};
} );

if ( !support.opacity ) {
	jQuery.cssHooks.opacity = {
		get: function( elem, computed ) {

			// IE uses filters for opacity
			return ropacity.test( ( computed && elem.currentStyle ?
				elem.currentStyle.filter :
				elem.style.filter ) || "" ) ?
					( 0.01 * parseFloat( RegExp.$1 ) ) + "" :
					computed ? "1" : "";
		},

		set: function( elem, value ) {
			var style = elem.style,
				currentStyle = elem.currentStyle,
				opacity = jQuery.isNumeric( value ) ? "alpha(opacity=" + value * 100 + ")" : "",
				filter = currentStyle && currentStyle.filter || style.filter || "";

			// IE has trouble with opacity if it does not have layout
			// Force it by setting the zoom level
			style.zoom = 1;

			// if setting opacity to 1, and no other filters exist -
			// attempt to remove filter attribute #6652
			// if value === "", then remove inline opacity #12685
			if ( ( value >= 1 || value === "" ) &&
					jQuery.trim( filter.replace( ralpha, "" ) ) === "" &&
					style.removeAttribute ) {

				// Setting style.filter to null, "" & " " still leave "filter:" in the cssText
				// if "filter:" is present at all, clearType is disabled, we want to avoid this
				// style.removeAttribute is IE Only, but so apparently is this code path...
				style.removeAttribute( "filter" );

				// if there is no filter style applied in a css rule
				// or unset inline opacity, we are done
				if ( value === "" || currentStyle && !currentStyle.filter ) {
					return;
				}
			}

			// otherwise, set new filter values
			style.filter = ralpha.test( filter ) ?
				filter.replace( ralpha, opacity ) :
				filter + " " + opacity;
		}
	};
}

jQuery.cssHooks.marginRight = addGetHookIf( support.reliableMarginRight,
	function( elem, computed ) {
		if ( computed ) {
			return swap( elem, { "display": "inline-block" },
				curCSS, [ elem, "marginRight" ] );
		}
	}
);

jQuery.cssHooks.marginLeft = addGetHookIf( support.reliableMarginLeft,
	function( elem, computed ) {
		if ( computed ) {
			return (
				parseFloat( curCSS( elem, "marginLeft" ) ) ||

				// Support: IE<=11+
				// Running getBoundingClientRect on a disconnected node in IE throws an error
				// Support: IE8 only
				// getClientRects() errors on disconnected elems
				( jQuery.contains( elem.ownerDocument, elem ) ?
					elem.getBoundingClientRect().left -
						swap( elem, { marginLeft: 0 }, function() {
							return elem.getBoundingClientRect().left;
						} ) :
					0
				)
			) + "px";
		}
	}
);

// These hooks are used by animate to expand properties
jQuery.each( {
	margin: "",
	padding: "",
	border: "Width"
}, function( prefix, suffix ) {
	jQuery.cssHooks[ prefix + suffix ] = {
		expand: function( value ) {
			var i = 0,
				expanded = {},

				// assumes a single number if not a string
				parts = typeof value === "string" ? value.split( " " ) : [ value ];

			for ( ; i < 4; i++ ) {
				expanded[ prefix + cssExpand[ i ] + suffix ] =
					parts[ i ] || parts[ i - 2 ] || parts[ 0 ];
			}

			return expanded;
		}
	};

	if ( !rmargin.test( prefix ) ) {
		jQuery.cssHooks[ prefix + suffix ].set = setPositiveNumber;
	}
} );

jQuery.fn.extend( {
	css: function( name, value ) {
		return access( this, function( elem, name, value ) {
			var styles, len,
				map = {},
				i = 0;

			if ( jQuery.isArray( name ) ) {
				styles = getStyles( elem );
				len = name.length;

				for ( ; i < len; i++ ) {
					map[ name[ i ] ] = jQuery.css( elem, name[ i ], false, styles );
				}

				return map;
			}

			return value !== undefined ?
				jQuery.style( elem, name, value ) :
				jQuery.css( elem, name );
		}, name, value, arguments.length > 1 );
	},
	show: function() {
		return showHide( this, true );
	},
	hide: function() {
		return showHide( this );
	},
	toggle: function( state ) {
		if ( typeof state === "boolean" ) {
			return state ? this.show() : this.hide();
		}

		return this.each( function() {
			if ( isHidden( this ) ) {
				jQuery( this ).show();
			} else {
				jQuery( this ).hide();
			}
		} );
	}
} );


function Tween( elem, options, prop, end, easing ) {
	return new Tween.prototype.init( elem, options, prop, end, easing );
}
jQuery.Tween = Tween;

Tween.prototype = {
	constructor: Tween,
	init: function( elem, options, prop, end, easing, unit ) {
		this.elem = elem;
		this.prop = prop;
		this.easing = easing || jQuery.easing._default;
		this.options = options;
		this.start = this.now = this.cur();
		this.end = end;
		this.unit = unit || ( jQuery.cssNumber[ prop ] ? "" : "px" );
	},
	cur: function() {
		var hooks = Tween.propHooks[ this.prop ];

		return hooks && hooks.get ?
			hooks.get( this ) :
			Tween.propHooks._default.get( this );
	},
	run: function( percent ) {
		var eased,
			hooks = Tween.propHooks[ this.prop ];

		if ( this.options.duration ) {
			this.pos = eased = jQuery.easing[ this.easing ](
				percent, this.options.duration * percent, 0, 1, this.options.duration
			);
		} else {
			this.pos = eased = percent;
		}
		this.now = ( this.end - this.start ) * eased + this.start;

		if ( this.options.step ) {
			this.options.step.call( this.elem, this.now, this );
		}

		if ( hooks && hooks.set ) {
			hooks.set( this );
		} else {
			Tween.propHooks._default.set( this );
		}
		return this;
	}
};

Tween.prototype.init.prototype = Tween.prototype;

Tween.propHooks = {
	_default: {
		get: function( tween ) {
			var result;

			// Use a property on the element directly when it is not a DOM element,
			// or when there is no matching style property that exists.
			if ( tween.elem.nodeType !== 1 ||
				tween.elem[ tween.prop ] != null && tween.elem.style[ tween.prop ] == null ) {
				return tween.elem[ tween.prop ];
			}

			// passing an empty string as a 3rd parameter to .css will automatically
			// attempt a parseFloat and fallback to a string if the parse fails
			// so, simple values such as "10px" are parsed to Float.
			// complex values such as "rotate(1rad)" are returned as is.
			result = jQuery.css( tween.elem, tween.prop, "" );

			// Empty strings, null, undefined and "auto" are converted to 0.
			return !result || result === "auto" ? 0 : result;
		},
		set: function( tween ) {

			// use step hook for back compat - use cssHook if its there - use .style if its
			// available and use plain properties where available
			if ( jQuery.fx.step[ tween.prop ] ) {
				jQuery.fx.step[ tween.prop ]( tween );
			} else if ( tween.elem.nodeType === 1 &&
				( tween.elem.style[ jQuery.cssProps[ tween.prop ] ] != null ||
					jQuery.cssHooks[ tween.prop ] ) ) {
				jQuery.style( tween.elem, tween.prop, tween.now + tween.unit );
			} else {
				tween.elem[ tween.prop ] = tween.now;
			}
		}
	}
};

// Support: IE <=9
// Panic based approach to setting things on disconnected nodes

Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
	set: function( tween ) {
		if ( tween.elem.nodeType && tween.elem.parentNode ) {
			tween.elem[ tween.prop ] = tween.now;
		}
	}
};

jQuery.easing = {
	linear: function( p ) {
		return p;
	},
	swing: function( p ) {
		return 0.5 - Math.cos( p * Math.PI ) / 2;
	},
	_default: "swing"
};

jQuery.fx = Tween.prototype.init;

// Back Compat <1.8 extension point
jQuery.fx.step = {};




var
	fxNow, timerId,
	rfxtypes = /^(?:toggle|show|hide)$/,
	rrun = /queueHooks$/;

// Animations created synchronously will run synchronously
function createFxNow() {
	window.setTimeout( function() {
		fxNow = undefined;
	} );
	return ( fxNow = jQuery.now() );
}

// Generate parameters to create a standard animation
function genFx( type, includeWidth ) {
	var which,
		attrs = { height: type },
		i = 0;

	// if we include width, step value is 1 to do all cssExpand values,
	// if we don't include width, step value is 2 to skip over Left and Right
	includeWidth = includeWidth ? 1 : 0;
	for ( ; i < 4 ; i += 2 - includeWidth ) {
		which = cssExpand[ i ];
		attrs[ "margin" + which ] = attrs[ "padding" + which ] = type;
	}

	if ( includeWidth ) {
		attrs.opacity = attrs.width = type;
	}

	return attrs;
}

function createTween( value, prop, animation ) {
	var tween,
		collection = ( Animation.tweeners[ prop ] || [] ).concat( Animation.tweeners[ "*" ] ),
		index = 0,
		length = collection.length;
	for ( ; index < length; index++ ) {
		if ( ( tween = collection[ index ].call( animation, prop, value ) ) ) {

			// we're done with this property
			return tween;
		}
	}
}

function defaultPrefilter( elem, props, opts ) {
	/* jshint validthis: true */
	var prop, value, toggle, tween, hooks, oldfire, display, checkDisplay,
		anim = this,
		orig = {},
		style = elem.style,
		hidden = elem.nodeType && isHidden( elem ),
		dataShow = jQuery._data( elem, "fxshow" );

	// handle queue: false promises
	if ( !opts.queue ) {
		hooks = jQuery._queueHooks( elem, "fx" );
		if ( hooks.unqueued == null ) {
			hooks.unqueued = 0;
			oldfire = hooks.empty.fire;
			hooks.empty.fire = function() {
				if ( !hooks.unqueued ) {
					oldfire();
				}
			};
		}
		hooks.unqueued++;

		anim.always( function() {

			// doing this makes sure that the complete handler will be called
			// before this completes
			anim.always( function() {
				hooks.unqueued--;
				if ( !jQuery.queue( elem, "fx" ).length ) {
					hooks.empty.fire();
				}
			} );
		} );
	}

	// height/width overflow pass
	if ( elem.nodeType === 1 && ( "height" in props || "width" in props ) ) {

		// Make sure that nothing sneaks out
		// Record all 3 overflow attributes because IE does not
		// change the overflow attribute when overflowX and
		// overflowY are set to the same value
		opts.overflow = [ style.overflow, style.overflowX, style.overflowY ];

		// Set display property to inline-block for height/width
		// animations on inline elements that are having width/height animated
		display = jQuery.css( elem, "display" );

		// Test default display if display is currently "none"
		checkDisplay = display === "none" ?
			jQuery._data( elem, "olddisplay" ) || defaultDisplay( elem.nodeName ) : display;

		if ( checkDisplay === "inline" && jQuery.css( elem, "float" ) === "none" ) {

			// inline-level elements accept inline-block;
			// block-level elements need to be inline with layout
			if ( !support.inlineBlockNeedsLayout || defaultDisplay( elem.nodeName ) === "inline" ) {
				style.display = "inline-block";
			} else {
				style.zoom = 1;
			}
		}
	}

	if ( opts.overflow ) {
		style.overflow = "hidden";
		if ( !support.shrinkWrapBlocks() ) {
			anim.always( function() {
				style.overflow = opts.overflow[ 0 ];
				style.overflowX = opts.overflow[ 1 ];
				style.overflowY = opts.overflow[ 2 ];
			} );
		}
	}

	// show/hide pass
	for ( prop in props ) {
		value = props[ prop ];
		if ( rfxtypes.exec( value ) ) {
			delete props[ prop ];
			toggle = toggle || value === "toggle";
			if ( value === ( hidden ? "hide" : "show" ) ) {

				// If there is dataShow left over from a stopped hide or show
				// and we are going to proceed with show, we should pretend to be hidden
				if ( value === "show" && dataShow && dataShow[ prop ] !== undefined ) {
					hidden = true;
				} else {
					continue;
				}
			}
			orig[ prop ] = dataShow && dataShow[ prop ] || jQuery.style( elem, prop );

		// Any non-fx value stops us from restoring the original display value
		} else {
			display = undefined;
		}
	}

	if ( !jQuery.isEmptyObject( orig ) ) {
		if ( dataShow ) {
			if ( "hidden" in dataShow ) {
				hidden = dataShow.hidden;
			}
		} else {
			dataShow = jQuery._data( elem, "fxshow", {} );
		}

		// store state if its toggle - enables .stop().toggle() to "reverse"
		if ( toggle ) {
			dataShow.hidden = !hidden;
		}
		if ( hidden ) {
			jQuery( elem ).show();
		} else {
			anim.done( function() {
				jQuery( elem ).hide();
			} );
		}
		anim.done( function() {
			var prop;
			jQuery._removeData( elem, "fxshow" );
			for ( prop in orig ) {
				jQuery.style( elem, prop, orig[ prop ] );
			}
		} );
		for ( prop in orig ) {
			tween = createTween( hidden ? dataShow[ prop ] : 0, prop, anim );

			if ( !( prop in dataShow ) ) {
				dataShow[ prop ] = tween.start;
				if ( hidden ) {
					tween.end = tween.start;
					tween.start = prop === "width" || prop === "height" ? 1 : 0;
				}
			}
		}

	// If this is a noop like .hide().hide(), restore an overwritten display value
	} else if ( ( display === "none" ? defaultDisplay( elem.nodeName ) : display ) === "inline" ) {
		style.display = display;
	}
}

function propFilter( props, specialEasing ) {
	var index, name, easing, value, hooks;

	// camelCase, specialEasing and expand cssHook pass
	for ( index in props ) {
		name = jQuery.camelCase( index );
		easing = specialEasing[ name ];
		value = props[ index ];
		if ( jQuery.isArray( value ) ) {
			easing = value[ 1 ];
			value = props[ index ] = value[ 0 ];
		}

		if ( index !== name ) {
			props[ name ] = value;
			delete props[ index ];
		}

		hooks = jQuery.cssHooks[ name ];
		if ( hooks && "expand" in hooks ) {
			value = hooks.expand( value );
			delete props[ name ];

			// not quite $.extend, this wont overwrite keys already present.
			// also - reusing 'index' from above because we have the correct "name"
			for ( index in value ) {
				if ( !( index in props ) ) {
					props[ index ] = value[ index ];
					specialEasing[ index ] = easing;
				}
			}
		} else {
			specialEasing[ name ] = easing;
		}
	}
}

function Animation( elem, properties, options ) {
	var result,
		stopped,
		index = 0,
		length = Animation.prefilters.length,
		deferred = jQuery.Deferred().always( function() {

			// don't match elem in the :animated selector
			delete tick.elem;
		} ),
		tick = function() {
			if ( stopped ) {
				return false;
			}
			var currentTime = fxNow || createFxNow(),
				remaining = Math.max( 0, animation.startTime + animation.duration - currentTime ),

				// Support: Android 2.3
				// Archaic crash bug won't allow us to use `1 - ( 0.5 || 0 )` (#12497)
				temp = remaining / animation.duration || 0,
				percent = 1 - temp,
				index = 0,
				length = animation.tweens.length;

			for ( ; index < length ; index++ ) {
				animation.tweens[ index ].run( percent );
			}

			deferred.notifyWith( elem, [ animation, percent, remaining ] );

			if ( percent < 1 && length ) {
				return remaining;
			} else {
				deferred.resolveWith( elem, [ animation ] );
				return false;
			}
		},
		animation = deferred.promise( {
			elem: elem,
			props: jQuery.extend( {}, properties ),
			opts: jQuery.extend( true, {
				specialEasing: {},
				easing: jQuery.easing._default
			}, options ),
			originalProperties: properties,
			originalOptions: options,
			startTime: fxNow || createFxNow(),
			duration: options.duration,
			tweens: [],
			createTween: function( prop, end ) {
				var tween = jQuery.Tween( elem, animation.opts, prop, end,
						animation.opts.specialEasing[ prop ] || animation.opts.easing );
				animation.tweens.push( tween );
				return tween;
			},
			stop: function( gotoEnd ) {
				var index = 0,

					// if we are going to the end, we want to run all the tweens
					// otherwise we skip this part
					length = gotoEnd ? animation.tweens.length : 0;
				if ( stopped ) {
					return this;
				}
				stopped = true;
				for ( ; index < length ; index++ ) {
					animation.tweens[ index ].run( 1 );
				}

				// resolve when we played the last frame
				// otherwise, reject
				if ( gotoEnd ) {
					deferred.notifyWith( elem, [ animation, 1, 0 ] );
					deferred.resolveWith( elem, [ animation, gotoEnd ] );
				} else {
					deferred.rejectWith( elem, [ animation, gotoEnd ] );
				}
				return this;
			}
		} ),
		props = animation.props;

	propFilter( props, animation.opts.specialEasing );

	for ( ; index < length ; index++ ) {
		result = Animation.prefilters[ index ].call( animation, elem, props, animation.opts );
		if ( result ) {
			if ( jQuery.isFunction( result.stop ) ) {
				jQuery._queueHooks( animation.elem, animation.opts.queue ).stop =
					jQuery.proxy( result.stop, result );
			}
			return result;
		}
	}

	jQuery.map( props, createTween, animation );

	if ( jQuery.isFunction( animation.opts.start ) ) {
		animation.opts.start.call( elem, animation );
	}

	jQuery.fx.timer(
		jQuery.extend( tick, {
			elem: elem,
			anim: animation,
			queue: animation.opts.queue
		} )
	);

	// attach callbacks from options
	return animation.progress( animation.opts.progress )
		.done( animation.opts.done, animation.opts.complete )
		.fail( animation.opts.fail )
		.always( animation.opts.always );
}

jQuery.Animation = jQuery.extend( Animation, {

	tweeners: {
		"*": [ function( prop, value ) {
			var tween = this.createTween( prop, value );
			adjustCSS( tween.elem, prop, rcssNum.exec( value ), tween );
			return tween;
		} ]
	},

	tweener: function( props, callback ) {
		if ( jQuery.isFunction( props ) ) {
			callback = props;
			props = [ "*" ];
		} else {
			props = props.match( rnotwhite );
		}

		var prop,
			index = 0,
			length = props.length;

		for ( ; index < length ; index++ ) {
			prop = props[ index ];
			Animation.tweeners[ prop ] = Animation.tweeners[ prop ] || [];
			Animation.tweeners[ prop ].unshift( callback );
		}
	},

	prefilters: [ defaultPrefilter ],

	prefilter: function( callback, prepend ) {
		if ( prepend ) {
			Animation.prefilters.unshift( callback );
		} else {
			Animation.prefilters.push( callback );
		}
	}
} );

jQuery.speed = function( speed, easing, fn ) {
	var opt = speed && typeof speed === "object" ? jQuery.extend( {}, speed ) : {
		complete: fn || !fn && easing ||
			jQuery.isFunction( speed ) && speed,
		duration: speed,
		easing: fn && easing || easing && !jQuery.isFunction( easing ) && easing
	};

	opt.duration = jQuery.fx.off ? 0 : typeof opt.duration === "number" ? opt.duration :
		opt.duration in jQuery.fx.speeds ?
			jQuery.fx.speeds[ opt.duration ] : jQuery.fx.speeds._default;

	// normalize opt.queue - true/undefined/null -> "fx"
	if ( opt.queue == null || opt.queue === true ) {
		opt.queue = "fx";
	}

	// Queueing
	opt.old = opt.complete;

	opt.complete = function() {
		if ( jQuery.isFunction( opt.old ) ) {
			opt.old.call( this );
		}

		if ( opt.queue ) {
			jQuery.dequeue( this, opt.queue );
		}
	};

	return opt;
};

jQuery.fn.extend( {
	fadeTo: function( speed, to, easing, callback ) {

		// show any hidden elements after setting opacity to 0
		return this.filter( isHidden ).css( "opacity", 0 ).show()

			// animate to the value specified
			.end().animate( { opacity: to }, speed, easing, callback );
	},
	animate: function( prop, speed, easing, callback ) {
		var empty = jQuery.isEmptyObject( prop ),
			optall = jQuery.speed( speed, easing, callback ),
			doAnimation = function() {

				// Operate on a copy of prop so per-property easing won't be lost
				var anim = Animation( this, jQuery.extend( {}, prop ), optall );

				// Empty animations, or finishing resolves immediately
				if ( empty || jQuery._data( this, "finish" ) ) {
					anim.stop( true );
				}
			};
			doAnimation.finish = doAnimation;

		return empty || optall.queue === false ?
			this.each( doAnimation ) :
			this.queue( optall.queue, doAnimation );
	},
	stop: function( type, clearQueue, gotoEnd ) {
		var stopQueue = function( hooks ) {
			var stop = hooks.stop;
			delete hooks.stop;
			stop( gotoEnd );
		};

		if ( typeof type !== "string" ) {
			gotoEnd = clearQueue;
			clearQueue = type;
			type = undefined;
		}
		if ( clearQueue && type !== false ) {
			this.queue( type || "fx", [] );
		}

		return this.each( function() {
			var dequeue = true,
				index = type != null && type + "queueHooks",
				timers = jQuery.timers,
				data = jQuery._data( this );

			if ( index ) {
				if ( data[ index ] && data[ index ].stop ) {
					stopQueue( data[ index ] );
				}
			} else {
				for ( index in data ) {
					if ( data[ index ] && data[ index ].stop && rrun.test( index ) ) {
						stopQueue( data[ index ] );
					}
				}
			}

			for ( index = timers.length; index--; ) {
				if ( timers[ index ].elem === this &&
					( type == null || timers[ index ].queue === type ) ) {

					timers[ index ].anim.stop( gotoEnd );
					dequeue = false;
					timers.splice( index, 1 );
				}
			}

			// start the next in the queue if the last step wasn't forced
			// timers currently will call their complete callbacks, which will dequeue
			// but only if they were gotoEnd
			if ( dequeue || !gotoEnd ) {
				jQuery.dequeue( this, type );
			}
		} );
	},
	finish: function( type ) {
		if ( type !== false ) {
			type = type || "fx";
		}
		return this.each( function() {
			var index,
				data = jQuery._data( this ),
				queue = data[ type + "queue" ],
				hooks = data[ type + "queueHooks" ],
				timers = jQuery.timers,
				length = queue ? queue.length : 0;

			// enable finishing flag on private data
			data.finish = true;

			// empty the queue first
			jQuery.queue( this, type, [] );

			if ( hooks && hooks.stop ) {
				hooks.stop.call( this, true );
			}

			// look for any active animations, and finish them
			for ( index = timers.length; index--; ) {
				if ( timers[ index ].elem === this && timers[ index ].queue === type ) {
					timers[ index ].anim.stop( true );
					timers.splice( index, 1 );
				}
			}

			// look for any animations in the old queue and finish them
			for ( index = 0; index < length; index++ ) {
				if ( queue[ index ] && queue[ index ].finish ) {
					queue[ index ].finish.call( this );
				}
			}

			// turn off finishing flag
			delete data.finish;
		} );
	}
} );

jQuery.each( [ "toggle", "show", "hide" ], function( i, name ) {
	var cssFn = jQuery.fn[ name ];
	jQuery.fn[ name ] = function( speed, easing, callback ) {
		return speed == null || typeof speed === "boolean" ?
			cssFn.apply( this, arguments ) :
			this.animate( genFx( name, true ), speed, easing, callback );
	};
} );

// Generate shortcuts for custom animations
jQuery.each( {
	slideDown: genFx( "show" ),
	slideUp: genFx( "hide" ),
	slideToggle: genFx( "toggle" ),
	fadeIn: { opacity: "show" },
	fadeOut: { opacity: "hide" },
	fadeToggle: { opacity: "toggle" }
}, function( name, props ) {
	jQuery.fn[ name ] = function( speed, easing, callback ) {
		return this.animate( props, speed, easing, callback );
	};
} );

jQuery.timers = [];
jQuery.fx.tick = function() {
	var timer,
		timers = jQuery.timers,
		i = 0;

	fxNow = jQuery.now();

	for ( ; i < timers.length; i++ ) {
		timer = timers[ i ];

		// Checks the timer has not already been removed
		if ( !timer() && timers[ i ] === timer ) {
			timers.splice( i--, 1 );
		}
	}

	if ( !timers.length ) {
		jQuery.fx.stop();
	}
	fxNow = undefined;
};

jQuery.fx.timer = function( timer ) {
	jQuery.timers.push( timer );
	if ( timer() ) {
		jQuery.fx.start();
	} else {
		jQuery.timers.pop();
	}
};

jQuery.fx.interval = 13;

jQuery.fx.start = function() {
	if ( !timerId ) {
		timerId = window.setInterval( jQuery.fx.tick, jQuery.fx.interval );
	}
};

jQuery.fx.stop = function() {
	window.clearInterval( timerId );
	timerId = null;
};

jQuery.fx.speeds = {
	slow: 600,
	fast: 200,

	// Default speed
	_default: 400
};


// Based off of the plugin by Clint Helfers, with permission.
// http://web.archive.org/web/20100324014747/http://blindsignals.com/index.php/2009/07/jquery-delay/
jQuery.fn.delay = function( time, type ) {
	time = jQuery.fx ? jQuery.fx.speeds[ time ] || time : time;
	type = type || "fx";

	return this.queue( type, function( next, hooks ) {
		var timeout = window.setTimeout( next, time );
		hooks.stop = function() {
			window.clearTimeout( timeout );
		};
	} );
};


( function() {
	var a,
		input = document.createElement( "input" ),
		div = document.createElement( "div" ),
		select = document.createElement( "select" ),
		opt = select.appendChild( document.createElement( "option" ) );

	// Setup
	div = document.createElement( "div" );
	div.setAttribute( "className", "t" );
	div.innerHTML = "  <link/><table></table><a href='/a'>a</a><input type='checkbox'/>";
	a = div.getElementsByTagName( "a" )[ 0 ];

	// Support: Windows Web Apps (WWA)
	// `type` must use .setAttribute for WWA (#14901)
	input.setAttribute( "type", "checkbox" );
	div.appendChild( input );

	a = div.getElementsByTagName( "a" )[ 0 ];

	// First batch of tests.
	a.style.cssText = "top:1px";

	// Test setAttribute on camelCase class.
	// If it works, we need attrFixes when doing get/setAttribute (ie6/7)
	support.getSetAttribute = div.className !== "t";

	// Get the style information from getAttribute
	// (IE uses .cssText instead)
	support.style = /top/.test( a.getAttribute( "style" ) );

	// Make sure that URLs aren't manipulated
	// (IE normalizes it by default)
	support.hrefNormalized = a.getAttribute( "href" ) === "/a";

	// Check the default checkbox/radio value ("" on WebKit; "on" elsewhere)
	support.checkOn = !!input.value;

	// Make sure that a selected-by-default option has a working selected property.
	// (WebKit defaults to false instead of true, IE too, if it's in an optgroup)
	support.optSelected = opt.selected;

	// Tests for enctype support on a form (#6743)
	support.enctype = !!document.createElement( "form" ).enctype;

	// Make sure that the options inside disabled selects aren't marked as disabled
	// (WebKit marks them as disabled)
	select.disabled = true;
	support.optDisabled = !opt.disabled;

	// Support: IE8 only
	// Check if we can trust getAttribute("value")
	input = document.createElement( "input" );
	input.setAttribute( "value", "" );
	support.input = input.getAttribute( "value" ) === "";

	// Check if an input maintains its value after becoming a radio
	input.value = "t";
	input.setAttribute( "type", "radio" );
	support.radioValue = input.value === "t";
} )();


var rreturn = /\r/g,
	rspaces = /[\x20\t\r\n\f]+/g;

jQuery.fn.extend( {
	val: function( value ) {
		var hooks, ret, isFunction,
			elem = this[ 0 ];

		if ( !arguments.length ) {
			if ( elem ) {
				hooks = jQuery.valHooks[ elem.type ] ||
					jQuery.valHooks[ elem.nodeName.toLowerCase() ];

				if (
					hooks &&
					"get" in hooks &&
					( ret = hooks.get( elem, "value" ) ) !== undefined
				) {
					return ret;
				}

				ret = elem.value;

				return typeof ret === "string" ?

					// handle most common string cases
					ret.replace( rreturn, "" ) :

					// handle cases where value is null/undef or number
					ret == null ? "" : ret;
			}

			return;
		}

		isFunction = jQuery.isFunction( value );

		return this.each( function( i ) {
			var val;

			if ( this.nodeType !== 1 ) {
				return;
			}

			if ( isFunction ) {
				val = value.call( this, i, jQuery( this ).val() );
			} else {
				val = value;
			}

			// Treat null/undefined as ""; convert numbers to string
			if ( val == null ) {
				val = "";
			} else if ( typeof val === "number" ) {
				val += "";
			} else if ( jQuery.isArray( val ) ) {
				val = jQuery.map( val, function( value ) {
					return value == null ? "" : value + "";
				} );
			}

			hooks = jQuery.valHooks[ this.type ] || jQuery.valHooks[ this.nodeName.toLowerCase() ];

			// If set returns undefined, fall back to normal setting
			if ( !hooks || !( "set" in hooks ) || hooks.set( this, val, "value" ) === undefined ) {
				this.value = val;
			}
		} );
	}
} );

jQuery.extend( {
	valHooks: {
		option: {
			get: function( elem ) {
				var val = jQuery.find.attr( elem, "value" );
				return val != null ?
					val :

					// Support: IE10-11+
					// option.text throws exceptions (#14686, #14858)
					// Strip and collapse whitespace
					// https://html.spec.whatwg.org/#strip-and-collapse-whitespace
					jQuery.trim( jQuery.text( elem ) ).replace( rspaces, " " );
			}
		},
		select: {
			get: function( elem ) {
				var value, option,
					options = elem.options,
					index = elem.selectedIndex,
					one = elem.type === "select-one" || index < 0,
					values = one ? null : [],
					max = one ? index + 1 : options.length,
					i = index < 0 ?
						max :
						one ? index : 0;

				// Loop through all the selected options
				for ( ; i < max; i++ ) {
					option = options[ i ];

					// oldIE doesn't update selected after form reset (#2551)
					if ( ( option.selected || i === index ) &&

							// Don't return options that are disabled or in a disabled optgroup
							( support.optDisabled ?
								!option.disabled :
								option.getAttribute( "disabled" ) === null ) &&
							( !option.parentNode.disabled ||
								!jQuery.nodeName( option.parentNode, "optgroup" ) ) ) {

						// Get the specific value for the option
						value = jQuery( option ).val();

						// We don't need an array for one selects
						if ( one ) {
							return value;
						}

						// Multi-Selects return an array
						values.push( value );
					}
				}

				return values;
			},

			set: function( elem, value ) {
				var optionSet, option,
					options = elem.options,
					values = jQuery.makeArray( value ),
					i = options.length;

				while ( i-- ) {
					option = options[ i ];

					if ( jQuery.inArray( jQuery.valHooks.option.get( option ), values ) > -1 ) {

						// Support: IE6
						// When new option element is added to select box we need to
						// force reflow of newly added node in order to workaround delay
						// of initialization properties
						try {
							option.selected = optionSet = true;

						} catch ( _ ) {

							// Will be executed only in IE6
							option.scrollHeight;
						}

					} else {
						option.selected = false;
					}
				}

				// Force browsers to behave consistently when non-matching value is set
				if ( !optionSet ) {
					elem.selectedIndex = -1;
				}

				return options;
			}
		}
	}
} );

// Radios and checkboxes getter/setter
jQuery.each( [ "radio", "checkbox" ], function() {
	jQuery.valHooks[ this ] = {
		set: function( elem, value ) {
			if ( jQuery.isArray( value ) ) {
				return ( elem.checked = jQuery.inArray( jQuery( elem ).val(), value ) > -1 );
			}
		}
	};
	if ( !support.checkOn ) {
		jQuery.valHooks[ this ].get = function( elem ) {
			return elem.getAttribute( "value" ) === null ? "on" : elem.value;
		};
	}
} );




var nodeHook, boolHook,
	attrHandle = jQuery.expr.attrHandle,
	ruseDefault = /^(?:checked|selected)$/i,
	getSetAttribute = support.getSetAttribute,
	getSetInput = support.input;

jQuery.fn.extend( {
	attr: function( name, value ) {
		return access( this, jQuery.attr, name, value, arguments.length > 1 );
	},

	removeAttr: function( name ) {
		return this.each( function() {
			jQuery.removeAttr( this, name );
		} );
	}
} );

jQuery.extend( {
	attr: function( elem, name, value ) {
		var ret, hooks,
			nType = elem.nodeType;

		// Don't get/set attributes on text, comment and attribute nodes
		if ( nType === 3 || nType === 8 || nType === 2 ) {
			return;
		}

		// Fallback to prop when attributes are not supported
		if ( typeof elem.getAttribute === "undefined" ) {
			return jQuery.prop( elem, name, value );
		}

		// All attributes are lowercase
		// Grab necessary hook if one is defined
		if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {
			name = name.toLowerCase();
			hooks = jQuery.attrHooks[ name ] ||
				( jQuery.expr.match.bool.test( name ) ? boolHook : nodeHook );
		}

		if ( value !== undefined ) {
			if ( value === null ) {
				jQuery.removeAttr( elem, name );
				return;
			}

			if ( hooks && "set" in hooks &&
				( ret = hooks.set( elem, value, name ) ) !== undefined ) {
				return ret;
			}

			elem.setAttribute( name, value + "" );
			return value;
		}

		if ( hooks && "get" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {
			return ret;
		}

		ret = jQuery.find.attr( elem, name );

		// Non-existent attributes return null, we normalize to undefined
		return ret == null ? undefined : ret;
	},

	attrHooks: {
		type: {
			set: function( elem, value ) {
				if ( !support.radioValue && value === "radio" &&
					jQuery.nodeName( elem, "input" ) ) {

					// Setting the type on a radio button after the value resets the value in IE8-9
					// Reset value to default in case type is set after value during creation
					var val = elem.value;
					elem.setAttribute( "type", value );
					if ( val ) {
						elem.value = val;
					}
					return value;
				}
			}
		}
	},

	removeAttr: function( elem, value ) {
		var name, propName,
			i = 0,
			attrNames = value && value.match( rnotwhite );

		if ( attrNames && elem.nodeType === 1 ) {
			while ( ( name = attrNames[ i++ ] ) ) {
				propName = jQuery.propFix[ name ] || name;

				// Boolean attributes get special treatment (#10870)
				if ( jQuery.expr.match.bool.test( name ) ) {

					// Set corresponding property to false
					if ( getSetInput && getSetAttribute || !ruseDefault.test( name ) ) {
						elem[ propName ] = false;

					// Support: IE<9
					// Also clear defaultChecked/defaultSelected (if appropriate)
					} else {
						elem[ jQuery.camelCase( "default-" + name ) ] =
							elem[ propName ] = false;
					}

				// See #9699 for explanation of this approach (setting first, then removal)
				} else {
					jQuery.attr( elem, name, "" );
				}

				elem.removeAttribute( getSetAttribute ? name : propName );
			}
		}
	}
} );

// Hooks for boolean attributes
boolHook = {
	set: function( elem, value, name ) {
		if ( value === false ) {

			// Remove boolean attributes when set to false
			jQuery.removeAttr( elem, name );
		} else if ( getSetInput && getSetAttribute || !ruseDefault.test( name ) ) {

			// IE<8 needs the *property* name
			elem.setAttribute( !getSetAttribute && jQuery.propFix[ name ] || name, name );

		} else {

			// Support: IE<9
			// Use defaultChecked and defaultSelected for oldIE
			elem[ jQuery.camelCase( "default-" + name ) ] = elem[ name ] = true;
		}
		return name;
	}
};

jQuery.each( jQuery.expr.match.bool.source.match( /\w+/g ), function( i, name ) {
	var getter = attrHandle[ name ] || jQuery.find.attr;

	if ( getSetInput && getSetAttribute || !ruseDefault.test( name ) ) {
		attrHandle[ name ] = function( elem, name, isXML ) {
			var ret, handle;
			if ( !isXML ) {

				// Avoid an infinite loop by temporarily removing this function from the getter
				handle = attrHandle[ name ];
				attrHandle[ name ] = ret;
				ret = getter( elem, name, isXML ) != null ?
					name.toLowerCase() :
					null;
				attrHandle[ name ] = handle;
			}
			return ret;
		};
	} else {
		attrHandle[ name ] = function( elem, name, isXML ) {
			if ( !isXML ) {
				return elem[ jQuery.camelCase( "default-" + name ) ] ?
					name.toLowerCase() :
					null;
			}
		};
	}
} );

// fix oldIE attroperties
if ( !getSetInput || !getSetAttribute ) {
	jQuery.attrHooks.value = {
		set: function( elem, value, name ) {
			if ( jQuery.nodeName( elem, "input" ) ) {

				// Does not return so that setAttribute is also used
				elem.defaultValue = value;
			} else {

				// Use nodeHook if defined (#1954); otherwise setAttribute is fine
				return nodeHook && nodeHook.set( elem, value, name );
			}
		}
	};
}

// IE6/7 do not support getting/setting some attributes with get/setAttribute
if ( !getSetAttribute ) {

	// Use this for any attribute in IE6/7
	// This fixes almost every IE6/7 issue
	nodeHook = {
		set: function( elem, value, name ) {

			// Set the existing or create a new attribute node
			var ret = elem.getAttributeNode( name );
			if ( !ret ) {
				elem.setAttributeNode(
					( ret = elem.ownerDocument.createAttribute( name ) )
				);
			}

			ret.value = value += "";

			// Break association with cloned elements by also using setAttribute (#9646)
			if ( name === "value" || value === elem.getAttribute( name ) ) {
				return value;
			}
		}
	};

	// Some attributes are constructed with empty-string values when not defined
	attrHandle.id = attrHandle.name = attrHandle.coords =
		function( elem, name, isXML ) {
			var ret;
			if ( !isXML ) {
				return ( ret = elem.getAttributeNode( name ) ) && ret.value !== "" ?
					ret.value :
					null;
			}
		};

	// Fixing value retrieval on a button requires this module
	jQuery.valHooks.button = {
		get: function( elem, name ) {
			var ret = elem.getAttributeNode( name );
			if ( ret && ret.specified ) {
				return ret.value;
			}
		},
		set: nodeHook.set
	};

	// Set contenteditable to false on removals(#10429)
	// Setting to empty string throws an error as an invalid value
	jQuery.attrHooks.contenteditable = {
		set: function( elem, value, name ) {
			nodeHook.set( elem, value === "" ? false : value, name );
		}
	};

	// Set width and height to auto instead of 0 on empty string( Bug #8150 )
	// This is for removals
	jQuery.each( [ "width", "height" ], function( i, name ) {
		jQuery.attrHooks[ name ] = {
			set: function( elem, value ) {
				if ( value === "" ) {
					elem.setAttribute( name, "auto" );
					return value;
				}
			}
		};
	} );
}

if ( !support.style ) {
	jQuery.attrHooks.style = {
		get: function( elem ) {

			// Return undefined in the case of empty string
			// Note: IE uppercases css property names, but if we were to .toLowerCase()
			// .cssText, that would destroy case sensitivity in URL's, like in "background"
			return elem.style.cssText || undefined;
		},
		set: function( elem, value ) {
			return ( elem.style.cssText = value + "" );
		}
	};
}




var rfocusable = /^(?:input|select|textarea|button|object)$/i,
	rclickable = /^(?:a|area)$/i;

jQuery.fn.extend( {
	prop: function( name, value ) {
		return access( this, jQuery.prop, name, value, arguments.length > 1 );
	},

	removeProp: function( name ) {
		name = jQuery.propFix[ name ] || name;
		return this.each( function() {

			// try/catch handles cases where IE balks (such as removing a property on window)
			try {
				this[ name ] = undefined;
				delete this[ name ];
			} catch ( e ) {}
		} );
	}
} );

jQuery.extend( {
	prop: function( elem, name, value ) {
		var ret, hooks,
			nType = elem.nodeType;

		// Don't get/set properties on text, comment and attribute nodes
		if ( nType === 3 || nType === 8 || nType === 2 ) {
			return;
		}

		if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {

			// Fix name and attach hooks
			name = jQuery.propFix[ name ] || name;
			hooks = jQuery.propHooks[ name ];
		}

		if ( value !== undefined ) {
			if ( hooks && "set" in hooks &&
				( ret = hooks.set( elem, value, name ) ) !== undefined ) {
				return ret;
			}

			return ( elem[ name ] = value );
		}

		if ( hooks && "get" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {
			return ret;
		}

		return elem[ name ];
	},

	propHooks: {
		tabIndex: {
			get: function( elem ) {

				// elem.tabIndex doesn't always return the
				// correct value when it hasn't been explicitly set
				// http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/
				// Use proper attribute retrieval(#12072)
				var tabindex = jQuery.find.attr( elem, "tabindex" );

				return tabindex ?
					parseInt( tabindex, 10 ) :
					rfocusable.test( elem.nodeName ) ||
						rclickable.test( elem.nodeName ) && elem.href ?
							0 :
							-1;
			}
		}
	},

	propFix: {
		"for": "htmlFor",
		"class": "className"
	}
} );

// Some attributes require a special call on IE
// http://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx
if ( !support.hrefNormalized ) {

	// href/src property should get the full normalized URL (#10299/#12915)
	jQuery.each( [ "href", "src" ], function( i, name ) {
		jQuery.propHooks[ name ] = {
			get: function( elem ) {
				return elem.getAttribute( name, 4 );
			}
		};
	} );
}

// Support: Safari, IE9+
// Accessing the selectedIndex property
// forces the browser to respect setting selected
// on the option
// The getter ensures a default option is selected
// when in an optgroup
if ( !support.optSelected ) {
	jQuery.propHooks.selected = {
		get: function( elem ) {
			var parent = elem.parentNode;

			if ( parent ) {
				parent.selectedIndex;

				// Make sure that it also works with optgroups, see #5701
				if ( parent.parentNode ) {
					parent.parentNode.selectedIndex;
				}
			}
			return null;
		},
		set: function( elem ) {
			var parent = elem.parentNode;
			if ( parent ) {
				parent.selectedIndex;

				if ( parent.parentNode ) {
					parent.parentNode.selectedIndex;
				}
			}
		}
	};
}

jQuery.each( [
	"tabIndex",
	"readOnly",
	"maxLength",
	"cellSpacing",
	"cellPadding",
	"rowSpan",
	"colSpan",
	"useMap",
	"frameBorder",
	"contentEditable"
], function() {
	jQuery.propFix[ this.toLowerCase() ] = this;
} );

// IE6/7 call enctype encoding
if ( !support.enctype ) {
	jQuery.propFix.enctype = "encoding";
}




var rclass = /[\t\r\n\f]/g;

function getClass( elem ) {
	return jQuery.attr( elem, "class" ) || "";
}

jQuery.fn.extend( {
	addClass: function( value ) {
		var classes, elem, cur, curValue, clazz, j, finalValue,
			i = 0;

		if ( jQuery.isFunction( value ) ) {
			return this.each( function( j ) {
				jQuery( this ).addClass( value.call( this, j, getClass( this ) ) );
			} );
		}

		if ( typeof value === "string" && value ) {
			classes = value.match( rnotwhite ) || [];

			while ( ( elem = this[ i++ ] ) ) {
				curValue = getClass( elem );
				cur = elem.nodeType === 1 &&
					( " " + curValue + " " ).replace( rclass, " " );

				if ( cur ) {
					j = 0;
					while ( ( clazz = classes[ j++ ] ) ) {
						if ( cur.indexOf( " " + clazz + " " ) < 0 ) {
							cur += clazz + " ";
						}
					}

					// only assign if different to avoid unneeded rendering.
					finalValue = jQuery.trim( cur );
					if ( curValue !== finalValue ) {
						jQuery.attr( elem, "class", finalValue );
					}
				}
			}
		}

		return this;
	},

	removeClass: function( value ) {
		var classes, elem, cur, curValue, clazz, j, finalValue,
			i = 0;

		if ( jQuery.isFunction( value ) ) {
			return this.each( function( j ) {
				jQuery( this ).removeClass( value.call( this, j, getClass( this ) ) );
			} );
		}

		if ( !arguments.length ) {
			return this.attr( "class", "" );
		}

		if ( typeof value === "string" && value ) {
			classes = value.match( rnotwhite ) || [];

			while ( ( elem = this[ i++ ] ) ) {
				curValue = getClass( elem );

				// This expression is here for better compressibility (see addClass)
				cur = elem.nodeType === 1 &&
					( " " + curValue + " " ).replace( rclass, " " );

				if ( cur ) {
					j = 0;
					while ( ( clazz = classes[ j++ ] ) ) {

						// Remove *all* instances
						while ( cur.indexOf( " " + clazz + " " ) > -1 ) {
							cur = cur.replace( " " + clazz + " ", " " );
						}
					}

					// Only assign if different to avoid unneeded rendering.
					finalValue = jQuery.trim( cur );
					if ( curValue !== finalValue ) {
						jQuery.attr( elem, "class", finalValue );
					}
				}
			}
		}

		return this;
	},

	toggleClass: function( value, stateVal ) {
		var type = typeof value;

		if ( typeof stateVal === "boolean" && type === "string" ) {
			return stateVal ? this.addClass( value ) : this.removeClass( value );
		}

		if ( jQuery.isFunction( value ) ) {
			return this.each( function( i ) {
				jQuery( this ).toggleClass(
					value.call( this, i, getClass( this ), stateVal ),
					stateVal
				);
			} );
		}

		return this.each( function() {
			var className, i, self, classNames;

			if ( type === "string" ) {

				// Toggle individual class names
				i = 0;
				self = jQuery( this );
				classNames = value.match( rnotwhite ) || [];

				while ( ( className = classNames[ i++ ] ) ) {

					// Check each className given, space separated list
					if ( self.hasClass( className ) ) {
						self.removeClass( className );
					} else {
						self.addClass( className );
					}
				}

			// Toggle whole class name
			} else if ( value === undefined || type === "boolean" ) {
				className = getClass( this );
				if ( className ) {

					// store className if set
					jQuery._data( this, "__className__", className );
				}

				// If the element has a class name or if we're passed "false",
				// then remove the whole classname (if there was one, the above saved it).
				// Otherwise bring back whatever was previously saved (if anything),
				// falling back to the empty string if nothing was stored.
				jQuery.attr( this, "class",
					className || value === false ?
					"" :
					jQuery._data( this, "__className__" ) || ""
				);
			}
		} );
	},

	hasClass: function( selector ) {
		var className, elem,
			i = 0;

		className = " " + selector + " ";
		while ( ( elem = this[ i++ ] ) ) {
			if ( elem.nodeType === 1 &&
				( " " + getClass( elem ) + " " ).replace( rclass, " " )
					.indexOf( className ) > -1
			) {
				return true;
			}
		}

		return false;
	}
} );




// Return jQuery for attributes-only inclusion


jQuery.each( ( "blur focus focusin focusout load resize scroll unload click dblclick " +
	"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " +
	"change select submit keydown keypress keyup error contextmenu" ).split( " " ),
	function( i, name ) {

	// Handle event binding
	jQuery.fn[ name ] = function( data, fn ) {
		return arguments.length > 0 ?
			this.on( name, null, data, fn ) :
			this.trigger( name );
	};
} );

jQuery.fn.extend( {
	hover: function( fnOver, fnOut ) {
		return this.mouseenter( fnOver ).mouseleave( fnOut || fnOver );
	}
} );


var location = window.location;

var nonce = jQuery.now();

var rquery = ( /\?/ );



var rvalidtokens = /(,)|(\[|{)|(}|])|"(?:[^"\\\r\n]|\\["\\\/bfnrt]|\\u[\da-fA-F]{4})*"\s*:?|true|false|null|-?(?!0\d)\d+(?:\.\d+|)(?:[eE][+-]?\d+|)/g;

jQuery.parseJSON = function( data ) {

	// Attempt to parse using the native JSON parser first
	if ( window.JSON && window.JSON.parse ) {

		// Support: Android 2.3
		// Workaround failure to string-cast null input
		return window.JSON.parse( data + "" );
	}

	var requireNonComma,
		depth = null,
		str = jQuery.trim( data + "" );

	// Guard against invalid (and possibly dangerous) input by ensuring that nothing remains
	// after removing valid tokens
	return str && !jQuery.trim( str.replace( rvalidtokens, function( token, comma, open, close ) {

		// Force termination if we see a misplaced comma
		if ( requireNonComma && comma ) {
			depth = 0;
		}

		// Perform no more replacements after returning to outermost depth
		if ( depth === 0 ) {
			return token;
		}

		// Commas must not follow "[", "{", or ","
		requireNonComma = open || comma;

		// Determine new depth
		// array/object open ("[" or "{"): depth += true - false (increment)
		// array/object close ("]" or "}"): depth += false - true (decrement)
		// other cases ("," or primitive): depth += true - true (numeric cast)
		depth += !close - !open;

		// Remove this token
		return "";
	} ) ) ?
		( Function( "return " + str ) )() :
		jQuery.error( "Invalid JSON: " + data );
};


// Cross-browser xml parsing
jQuery.parseXML = function( data ) {
	var xml, tmp;
	if ( !data || typeof data !== "string" ) {
		return null;
	}
	try {
		if ( window.DOMParser ) { // Standard
			tmp = new window.DOMParser();
			xml = tmp.parseFromString( data, "text/xml" );
		} else { // IE
			xml = new window.ActiveXObject( "Microsoft.XMLDOM" );
			xml.async = "false";
			xml.loadXML( data );
		}
	} catch ( e ) {
		xml = undefined;
	}
	if ( !xml || !xml.documentElement || xml.getElementsByTagName( "parsererror" ).length ) {
		jQuery.error( "Invalid XML: " + data );
	}
	return xml;
};


var
	rhash = /#.*$/,
	rts = /([?&])_=[^&]*/,

	// IE leaves an \r character at EOL
	rheaders = /^(.*?):[ \t]*([^\r\n]*)\r?$/mg,

	// #7653, #8125, #8152: local protocol detection
	rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,
	rnoContent = /^(?:GET|HEAD)$/,
	rprotocol = /^\/\//,
	rurl = /^([\w.+-]+:)(?:\/\/(?:[^\/?#]*@|)([^\/?#:]*)(?::(\d+)|)|)/,

	/* Prefilters
	 * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)
	 * 2) These are called:
	 *    - BEFORE asking for a transport
	 *    - AFTER param serialization (s.data is a string if s.processData is true)
	 * 3) key is the dataType
	 * 4) the catchall symbol "*" can be used
	 * 5) execution will start with transport dataType and THEN continue down to "*" if needed
	 */
	prefilters = {},

	/* Transports bindings
	 * 1) key is the dataType
	 * 2) the catchall symbol "*" can be used
	 * 3) selection will start with transport dataType and THEN go to "*" if needed
	 */
	transports = {},

	// Avoid comment-prolog char sequence (#10098); must appease lint and evade compression
	allTypes = "*/".concat( "*" ),

	// Document location
	ajaxLocation = location.href,

	// Segment location into parts
	ajaxLocParts = rurl.exec( ajaxLocation.toLowerCase() ) || [];

// Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport
function addToPrefiltersOrTransports( structure ) {

	// dataTypeExpression is optional and defaults to "*"
	return function( dataTypeExpression, func ) {

		if ( typeof dataTypeExpression !== "string" ) {
			func = dataTypeExpression;
			dataTypeExpression = "*";
		}

		var dataType,
			i = 0,
			dataTypes = dataTypeExpression.toLowerCase().match( rnotwhite ) || [];

		if ( jQuery.isFunction( func ) ) {

			// For each dataType in the dataTypeExpression
			while ( ( dataType = dataTypes[ i++ ] ) ) {

				// Prepend if requested
				if ( dataType.charAt( 0 ) === "+" ) {
					dataType = dataType.slice( 1 ) || "*";
					( structure[ dataType ] = structure[ dataType ] || [] ).unshift( func );

				// Otherwise append
				} else {
					( structure[ dataType ] = structure[ dataType ] || [] ).push( func );
				}
			}
		}
	};
}

// Base inspection function for prefilters and transports
function inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR ) {

	var inspected = {},
		seekingTransport = ( structure === transports );

	function inspect( dataType ) {
		var selected;
		inspected[ dataType ] = true;
		jQuery.each( structure[ dataType ] || [], function( _, prefilterOrFactory ) {
			var dataTypeOrTransport = prefilterOrFactory( options, originalOptions, jqXHR );
			if ( typeof dataTypeOrTransport === "string" &&
				!seekingTransport && !inspected[ dataTypeOrTransport ] ) {

				options.dataTypes.unshift( dataTypeOrTransport );
				inspect( dataTypeOrTransport );
				return false;
			} else if ( seekingTransport ) {
				return !( selected = dataTypeOrTransport );
			}
		} );
		return selected;
	}

	return inspect( options.dataTypes[ 0 ] ) || !inspected[ "*" ] && inspect( "*" );
}

// A special extend for ajax options
// that takes "flat" options (not to be deep extended)
// Fixes #9887
function ajaxExtend( target, src ) {
	var deep, key,
		flatOptions = jQuery.ajaxSettings.flatOptions || {};

	for ( key in src ) {
		if ( src[ key ] !== undefined ) {
			( flatOptions[ key ] ? target : ( deep || ( deep = {} ) ) )[ key ] = src[ key ];
		}
	}
	if ( deep ) {
		jQuery.extend( true, target, deep );
	}

	return target;
}

/* Handles responses to an ajax request:
 * - finds the right dataType (mediates between content-type and expected dataType)
 * - returns the corresponding response
 */
function ajaxHandleResponses( s, jqXHR, responses ) {
	var firstDataType, ct, finalDataType, type,
		contents = s.contents,
		dataTypes = s.dataTypes;

	// Remove auto dataType and get content-type in the process
	while ( dataTypes[ 0 ] === "*" ) {
		dataTypes.shift();
		if ( ct === undefined ) {
			ct = s.mimeType || jqXHR.getResponseHeader( "Content-Type" );
		}
	}

	// Check if we're dealing with a known content-type
	if ( ct ) {
		for ( type in contents ) {
			if ( contents[ type ] && contents[ type ].test( ct ) ) {
				dataTypes.unshift( type );
				break;
			}
		}
	}

	// Check to see if we have a response for the expected dataType
	if ( dataTypes[ 0 ] in responses ) {
		finalDataType = dataTypes[ 0 ];
	} else {

		// Try convertible dataTypes
		for ( type in responses ) {
			if ( !dataTypes[ 0 ] || s.converters[ type + " " + dataTypes[ 0 ] ] ) {
				finalDataType = type;
				break;
			}
			if ( !firstDataType ) {
				firstDataType = type;
			}
		}

		// Or just use first one
		finalDataType = finalDataType || firstDataType;
	}

	// If we found a dataType
	// We add the dataType to the list if needed
	// and return the corresponding response
	if ( finalDataType ) {
		if ( finalDataType !== dataTypes[ 0 ] ) {
			dataTypes.unshift( finalDataType );
		}
		return responses[ finalDataType ];
	}
}

/* Chain conversions given the request and the original response
 * Also sets the responseXXX fields on the jqXHR instance
 */
function ajaxConvert( s, response, jqXHR, isSuccess ) {
	var conv2, current, conv, tmp, prev,
		converters = {},

		// Work with a copy of dataTypes in case we need to modify it for conversion
		dataTypes = s.dataTypes.slice();

	// Create converters map with lowercased keys
	if ( dataTypes[ 1 ] ) {
		for ( conv in s.converters ) {
			converters[ conv.toLowerCase() ] = s.converters[ conv ];
		}
	}

	current = dataTypes.shift();

	// Convert to each sequential dataType
	while ( current ) {

		if ( s.responseFields[ current ] ) {
			jqXHR[ s.responseFields[ current ] ] = response;
		}

		// Apply the dataFilter if provided
		if ( !prev && isSuccess && s.dataFilter ) {
			response = s.dataFilter( response, s.dataType );
		}

		prev = current;
		current = dataTypes.shift();

		if ( current ) {

			// There's only work to do if current dataType is non-auto
			if ( current === "*" ) {

				current = prev;

			// Convert response if prev dataType is non-auto and differs from current
			} else if ( prev !== "*" && prev !== current ) {

				// Seek a direct converter
				conv = converters[ prev + " " + current ] || converters[ "* " + current ];

				// If none found, seek a pair
				if ( !conv ) {
					for ( conv2 in converters ) {

						// If conv2 outputs current
						tmp = conv2.split( " " );
						if ( tmp[ 1 ] === current ) {

							// If prev can be converted to accepted input
							conv = converters[ prev + " " + tmp[ 0 ] ] ||
								converters[ "* " + tmp[ 0 ] ];
							if ( conv ) {

								// Condense equivalence converters
								if ( conv === true ) {
									conv = converters[ conv2 ];

								// Otherwise, insert the intermediate dataType
								} else if ( converters[ conv2 ] !== true ) {
									current = tmp[ 0 ];
									dataTypes.unshift( tmp[ 1 ] );
								}
								break;
							}
						}
					}
				}

				// Apply converter (if not an equivalence)
				if ( conv !== true ) {

					// Unless errors are allowed to bubble, catch and return them
					if ( conv && s[ "throws" ] ) { // jscs:ignore requireDotNotation
						response = conv( response );
					} else {
						try {
							response = conv( response );
						} catch ( e ) {
							return {
								state: "parsererror",
								error: conv ? e : "No conversion from " + prev + " to " + current
							};
						}
					}
				}
			}
		}
	}

	return { state: "success", data: response };
}

jQuery.extend( {

	// Counter for holding the number of active queries
	active: 0,

	// Last-Modified header cache for next request
	lastModified: {},
	etag: {},

	ajaxSettings: {
		url: ajaxLocation,
		type: "GET",
		isLocal: rlocalProtocol.test( ajaxLocParts[ 1 ] ),
		global: true,
		processData: true,
		async: true,
		contentType: "application/x-www-form-urlencoded; charset=UTF-8",
		/*
		timeout: 0,
		data: null,
		dataType: null,
		username: null,
		password: null,
		cache: null,
		throws: false,
		traditional: false,
		headers: {},
		*/

		accepts: {
			"*": allTypes,
			text: "text/plain",
			html: "text/html",
			xml: "application/xml, text/xml",
			json: "application/json, text/javascript"
		},

		contents: {
			xml: /\bxml\b/,
			html: /\bhtml/,
			json: /\bjson\b/
		},

		responseFields: {
			xml: "responseXML",
			text: "responseText",
			json: "responseJSON"
		},

		// Data converters
		// Keys separate source (or catchall "*") and destination types with a single space
		converters: {

			// Convert anything to text
			"* text": String,

			// Text to html (true = no transformation)
			"text html": true,

			// Evaluate text as a json expression
			"text json": jQuery.parseJSON,

			// Parse text as xml
			"text xml": jQuery.parseXML
		},

		// For options that shouldn't be deep extended:
		// you can add your own custom options here if
		// and when you create one that shouldn't be
		// deep extended (see ajaxExtend)
		flatOptions: {
			url: true,
			context: true
		}
	},

	// Creates a full fledged settings object into target
	// with both ajaxSettings and settings fields.
	// If target is omitted, writes into ajaxSettings.
	ajaxSetup: function( target, settings ) {
		return settings ?

			// Building a settings object
			ajaxExtend( ajaxExtend( target, jQuery.ajaxSettings ), settings ) :

			// Extending ajaxSettings
			ajaxExtend( jQuery.ajaxSettings, target );
	},

	ajaxPrefilter: addToPrefiltersOrTransports( prefilters ),
	ajaxTransport: addToPrefiltersOrTransports( transports ),

	// Main method
	ajax: function( url, options ) {

		// If url is an object, simulate pre-1.5 signature
		if ( typeof url === "object" ) {
			options = url;
			url = undefined;
		}

		// Force options to be an object
		options = options || {};

		var

			// Cross-domain detection vars
			parts,

			// Loop variable
			i,

			// URL without anti-cache param
			cacheURL,

			// Response headers as string
			responseHeadersString,

			// timeout handle
			timeoutTimer,

			// To know if global events are to be dispatched
			fireGlobals,

			transport,

			// Response headers
			responseHeaders,

			// Create the final options object
			s = jQuery.ajaxSetup( {}, options ),

			// Callbacks context
			callbackContext = s.context || s,

			// Context for global events is callbackContext if it is a DOM node or jQuery collection
			globalEventContext = s.context &&
				( callbackContext.nodeType || callbackContext.jquery ) ?
					jQuery( callbackContext ) :
					jQuery.event,

			// Deferreds
			deferred = jQuery.Deferred(),
			completeDeferred = jQuery.Callbacks( "once memory" ),

			// Status-dependent callbacks
			statusCode = s.statusCode || {},

			// Headers (they are sent all at once)
			requestHeaders = {},
			requestHeadersNames = {},

			// The jqXHR state
			state = 0,

			// Default abort message
			strAbort = "canceled",

			// Fake xhr
			jqXHR = {
				readyState: 0,

				// Builds headers hashtable if needed
				getResponseHeader: function( key ) {
					var match;
					if ( state === 2 ) {
						if ( !responseHeaders ) {
							responseHeaders = {};
							while ( ( match = rheaders.exec( responseHeadersString ) ) ) {
								responseHeaders[ match[ 1 ].toLowerCase() ] = match[ 2 ];
							}
						}
						match = responseHeaders[ key.toLowerCase() ];
					}
					return match == null ? null : match;
				},

				// Raw string
				getAllResponseHeaders: function() {
					return state === 2 ? responseHeadersString : null;
				},

				// Caches the header
				setRequestHeader: function( name, value ) {
					var lname = name.toLowerCase();
					if ( !state ) {
						name = requestHeadersNames[ lname ] = requestHeadersNames[ lname ] || name;
						requestHeaders[ name ] = value;
					}
					return this;
				},

				// Overrides response content-type header
				overrideMimeType: function( type ) {
					if ( !state ) {
						s.mimeType = type;
					}
					return this;
				},

				// Status-dependent callbacks
				statusCode: function( map ) {
					var code;
					if ( map ) {
						if ( state < 2 ) {
							for ( code in map ) {

								// Lazy-add the new callback in a way that preserves old ones
								statusCode[ code ] = [ statusCode[ code ], map[ code ] ];
							}
						} else {

							// Execute the appropriate callbacks
							jqXHR.always( map[ jqXHR.status ] );
						}
					}
					return this;
				},

				// Cancel the request
				abort: function( statusText ) {
					var finalText = statusText || strAbort;
					if ( transport ) {
						transport.abort( finalText );
					}
					done( 0, finalText );
					return this;
				}
			};

		// Attach deferreds
		deferred.promise( jqXHR ).complete = completeDeferred.add;
		jqXHR.success = jqXHR.done;
		jqXHR.error = jqXHR.fail;

		// Remove hash character (#7531: and string promotion)
		// Add protocol if not provided (#5866: IE7 issue with protocol-less urls)
		// Handle falsy url in the settings object (#10093: consistency with old signature)
		// We also use the url parameter if available
		s.url = ( ( url || s.url || ajaxLocation ) + "" )
			.replace( rhash, "" )
			.replace( rprotocol, ajaxLocParts[ 1 ] + "//" );

		// Alias method option to type as per ticket #12004
		s.type = options.method || options.type || s.method || s.type;

		// Extract dataTypes list
		s.dataTypes = jQuery.trim( s.dataType || "*" ).toLowerCase().match( rnotwhite ) || [ "" ];

		// A cross-domain request is in order when we have a protocol:host:port mismatch
		if ( s.crossDomain == null ) {
			parts = rurl.exec( s.url.toLowerCase() );
			s.crossDomain = !!( parts &&
				( parts[ 1 ] !== ajaxLocParts[ 1 ] || parts[ 2 ] !== ajaxLocParts[ 2 ] ||
					( parts[ 3 ] || ( parts[ 1 ] === "http:" ? "80" : "443" ) ) !==
						( ajaxLocParts[ 3 ] || ( ajaxLocParts[ 1 ] === "http:" ? "80" : "443" ) ) )
			);
		}

		// Convert data if not already a string
		if ( s.data && s.processData && typeof s.data !== "string" ) {
			s.data = jQuery.param( s.data, s.traditional );
		}

		// Apply prefilters
		inspectPrefiltersOrTransports( prefilters, s, options, jqXHR );

		// If request was aborted inside a prefilter, stop there
		if ( state === 2 ) {
			return jqXHR;
		}

		// We can fire global events as of now if asked to
		// Don't fire events if jQuery.event is undefined in an AMD-usage scenario (#15118)
		fireGlobals = jQuery.event && s.global;

		// Watch for a new set of requests
		if ( fireGlobals && jQuery.active++ === 0 ) {
			jQuery.event.trigger( "ajaxStart" );
		}

		// Uppercase the type
		s.type = s.type.toUpperCase();

		// Determine if request has content
		s.hasContent = !rnoContent.test( s.type );

		// Save the URL in case we're toying with the If-Modified-Since
		// and/or If-None-Match header later on
		cacheURL = s.url;

		// More options handling for requests with no content
		if ( !s.hasContent ) {

			// If data is available, append data to url
			if ( s.data ) {
				cacheURL = ( s.url += ( rquery.test( cacheURL ) ? "&" : "?" ) + s.data );

				// #9682: remove data so that it's not used in an eventual retry
				delete s.data;
			}

			// Add anti-cache in url if needed
			if ( s.cache === false ) {
				s.url = rts.test( cacheURL ) ?

					// If there is already a '_' parameter, set its value
					cacheURL.replace( rts, "$1_=" + nonce++ ) :

					// Otherwise add one to the end
					cacheURL + ( rquery.test( cacheURL ) ? "&" : "?" ) + "_=" + nonce++;
			}
		}

		// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
		if ( s.ifModified ) {
			if ( jQuery.lastModified[ cacheURL ] ) {
				jqXHR.setRequestHeader( "If-Modified-Since", jQuery.lastModified[ cacheURL ] );
			}
			if ( jQuery.etag[ cacheURL ] ) {
				jqXHR.setRequestHeader( "If-None-Match", jQuery.etag[ cacheURL ] );
			}
		}

		// Set the correct header, if data is being sent
		if ( s.data && s.hasContent && s.contentType !== false || options.contentType ) {
			jqXHR.setRequestHeader( "Content-Type", s.contentType );
		}

		// Set the Accepts header for the server, depending on the dataType
		jqXHR.setRequestHeader(
			"Accept",
			s.dataTypes[ 0 ] && s.accepts[ s.dataTypes[ 0 ] ] ?
				s.accepts[ s.dataTypes[ 0 ] ] +
					( s.dataTypes[ 0 ] !== "*" ? ", " + allTypes + "; q=0.01" : "" ) :
				s.accepts[ "*" ]
		);

		// Check for headers option
		for ( i in s.headers ) {
			jqXHR.setRequestHeader( i, s.headers[ i ] );
		}

		// Allow custom headers/mimetypes and early abort
		if ( s.beforeSend &&
			( s.beforeSend.call( callbackContext, jqXHR, s ) === false || state === 2 ) ) {

			// Abort if not done already and return
			return jqXHR.abort();
		}

		// aborting is no longer a cancellation
		strAbort = "abort";

		// Install callbacks on deferreds
		for ( i in { success: 1, error: 1, complete: 1 } ) {
			jqXHR[ i ]( s[ i ] );
		}

		// Get transport
		transport = inspectPrefiltersOrTransports( transports, s, options, jqXHR );

		// If no transport, we auto-abort
		if ( !transport ) {
			done( -1, "No Transport" );
		} else {
			jqXHR.readyState = 1;

			// Send global event
			if ( fireGlobals ) {
				globalEventContext.trigger( "ajaxSend", [ jqXHR, s ] );
			}

			// If request was aborted inside ajaxSend, stop there
			if ( state === 2 ) {
				return jqXHR;
			}

			// Timeout
			if ( s.async && s.timeout > 0 ) {
				timeoutTimer = window.setTimeout( function() {
					jqXHR.abort( "timeout" );
				}, s.timeout );
			}

			try {
				state = 1;
				transport.send( requestHeaders, done );
			} catch ( e ) {

				// Propagate exception as error if not done
				if ( state < 2 ) {
					done( -1, e );

				// Simply rethrow otherwise
				} else {
					throw e;
				}
			}
		}

		// Callback for when everything is done
		function done( status, nativeStatusText, responses, headers ) {
			var isSuccess, success, error, response, modified,
				statusText = nativeStatusText;

			// Called once
			if ( state === 2 ) {
				return;
			}

			// State is "done" now
			state = 2;

			// Clear timeout if it exists
			if ( timeoutTimer ) {
				window.clearTimeout( timeoutTimer );
			}

			// Dereference transport for early garbage collection
			// (no matter how long the jqXHR object will be used)
			transport = undefined;

			// Cache response headers
			responseHeadersString = headers || "";

			// Set readyState
			jqXHR.readyState = status > 0 ? 4 : 0;

			// Determine if successful
			isSuccess = status >= 200 && status < 300 || status === 304;

			// Get response data
			if ( responses ) {
				response = ajaxHandleResponses( s, jqXHR, responses );
			}

			// Convert no matter what (that way responseXXX fields are always set)
			response = ajaxConvert( s, response, jqXHR, isSuccess );

			// If successful, handle type chaining
			if ( isSuccess ) {

				// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
				if ( s.ifModified ) {
					modified = jqXHR.getResponseHeader( "Last-Modified" );
					if ( modified ) {
						jQuery.lastModified[ cacheURL ] = modified;
					}
					modified = jqXHR.getResponseHeader( "etag" );
					if ( modified ) {
						jQuery.etag[ cacheURL ] = modified;
					}
				}

				// if no content
				if ( status === 204 || s.type === "HEAD" ) {
					statusText = "nocontent";

				// if not modified
				} else if ( status === 304 ) {
					statusText = "notmodified";

				// If we have data, let's convert it
				} else {
					statusText = response.state;
					success = response.data;
					error = response.error;
					isSuccess = !error;
				}
			} else {

				// We extract error from statusText
				// then normalize statusText and status for non-aborts
				error = statusText;
				if ( status || !statusText ) {
					statusText = "error";
					if ( status < 0 ) {
						status = 0;
					}
				}
			}

			// Set data for the fake xhr object
			jqXHR.status = status;
			jqXHR.statusText = ( nativeStatusText || statusText ) + "";

			// Success/Error
			if ( isSuccess ) {
				deferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );
			} else {
				deferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );
			}

			// Status-dependent callbacks
			jqXHR.statusCode( statusCode );
			statusCode = undefined;

			if ( fireGlobals ) {
				globalEventContext.trigger( isSuccess ? "ajaxSuccess" : "ajaxError",
					[ jqXHR, s, isSuccess ? success : error ] );
			}

			// Complete
			completeDeferred.fireWith( callbackContext, [ jqXHR, statusText ] );

			if ( fireGlobals ) {
				globalEventContext.trigger( "ajaxComplete", [ jqXHR, s ] );

				// Handle the global AJAX counter
				if ( !( --jQuery.active ) ) {
					jQuery.event.trigger( "ajaxStop" );
				}
			}
		}

		return jqXHR;
	},

	getJSON: function( url, data, callback ) {
		return jQuery.get( url, data, callback, "json" );
	},

	getScript: function( url, callback ) {
		return jQuery.get( url, undefined, callback, "script" );
	}
} );

jQuery.each( [ "get", "post" ], function( i, method ) {
	jQuery[ method ] = function( url, data, callback, type ) {

		// shift arguments if data argument was omitted
		if ( jQuery.isFunction( data ) ) {
			type = type || callback;
			callback = data;
			data = undefined;
		}

		// The url can be an options object (which then must have .url)
		return jQuery.ajax( jQuery.extend( {
			url: url,
			type: method,
			dataType: type,
			data: data,
			success: callback
		}, jQuery.isPlainObject( url ) && url ) );
	};
} );


jQuery._evalUrl = function( url ) {
	return jQuery.ajax( {
		url: url,

		// Make this explicit, since user can override this through ajaxSetup (#11264)
		type: "GET",
		dataType: "script",
		cache: true,
		async: false,
		global: false,
		"throws": true
	} );
};


jQuery.fn.extend( {
	wrapAll: function( html ) {
		if ( jQuery.isFunction( html ) ) {
			return this.each( function( i ) {
				jQuery( this ).wrapAll( html.call( this, i ) );
			} );
		}

		if ( this[ 0 ] ) {

			// The elements to wrap the target around
			var wrap = jQuery( html, this[ 0 ].ownerDocument ).eq( 0 ).clone( true );

			if ( this[ 0 ].parentNode ) {
				wrap.insertBefore( this[ 0 ] );
			}

			wrap.map( function() {
				var elem = this;

				while ( elem.firstChild && elem.firstChild.nodeType === 1 ) {
					elem = elem.firstChild;
				}

				return elem;
			} ).append( this );
		}

		return this;
	},

	wrapInner: function( html ) {
		if ( jQuery.isFunction( html ) ) {
			return this.each( function( i ) {
				jQuery( this ).wrapInner( html.call( this, i ) );
			} );
		}

		return this.each( function() {
			var self = jQuery( this ),
				contents = self.contents();

			if ( contents.length ) {
				contents.wrapAll( html );

			} else {
				self.append( html );
			}
		} );
	},

	wrap: function( html ) {
		var isFunction = jQuery.isFunction( html );

		return this.each( function( i ) {
			jQuery( this ).wrapAll( isFunction ? html.call( this, i ) : html );
		} );
	},

	unwrap: function() {
		return this.parent().each( function() {
			if ( !jQuery.nodeName( this, "body" ) ) {
				jQuery( this ).replaceWith( this.childNodes );
			}
		} ).end();
	}
} );


function getDisplay( elem ) {
	return elem.style && elem.style.display || jQuery.css( elem, "display" );
}

function filterHidden( elem ) {

	// Disconnected elements are considered hidden
	if ( !jQuery.contains( elem.ownerDocument || document, elem ) ) {
		return true;
	}
	while ( elem && elem.nodeType === 1 ) {
		if ( getDisplay( elem ) === "none" || elem.type === "hidden" ) {
			return true;
		}
		elem = elem.parentNode;
	}
	return false;
}

jQuery.expr.filters.hidden = function( elem ) {

	// Support: Opera <= 12.12
	// Opera reports offsetWidths and offsetHeights less than zero on some elements
	return support.reliableHiddenOffsets() ?
		( elem.offsetWidth <= 0 && elem.offsetHeight <= 0 &&
			!elem.getClientRects().length ) :
			filterHidden( elem );
};

jQuery.expr.filters.visible = function( elem ) {
	return !jQuery.expr.filters.hidden( elem );
};




var r20 = /%20/g,
	rbracket = /\[\]$/,
	rCRLF = /\r?\n/g,
	rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,
	rsubmittable = /^(?:input|select|textarea|keygen)/i;

function buildParams( prefix, obj, traditional, add ) {
	var name;

	if ( jQuery.isArray( obj ) ) {

		// Serialize array item.
		jQuery.each( obj, function( i, v ) {
			if ( traditional || rbracket.test( prefix ) ) {

				// Treat each array item as a scalar.
				add( prefix, v );

			} else {

				// Item is non-scalar (array or object), encode its numeric index.
				buildParams(
					prefix + "[" + ( typeof v === "object" && v != null ? i : "" ) + "]",
					v,
					traditional,
					add
				);
			}
		} );

	} else if ( !traditional && jQuery.type( obj ) === "object" ) {

		// Serialize object item.
		for ( name in obj ) {
			buildParams( prefix + "[" + name + "]", obj[ name ], traditional, add );
		}

	} else {

		// Serialize scalar item.
		add( prefix, obj );
	}
}

// Serialize an array of form elements or a set of
// key/values into a query string
jQuery.param = function( a, traditional ) {
	var prefix,
		s = [],
		add = function( key, value ) {

			// If value is a function, invoke it and return its value
			value = jQuery.isFunction( value ) ? value() : ( value == null ? "" : value );
			s[ s.length ] = encodeURIComponent( key ) + "=" + encodeURIComponent( value );
		};

	// Set traditional to true for jQuery <= 1.3.2 behavior.
	if ( traditional === undefined ) {
		traditional = jQuery.ajaxSettings && jQuery.ajaxSettings.traditional;
	}

	// If an array was passed in, assume that it is an array of form elements.
	if ( jQuery.isArray( a ) || ( a.jquery && !jQuery.isPlainObject( a ) ) ) {

		// Serialize the form elements
		jQuery.each( a, function() {
			add( this.name, this.value );
		} );

	} else {

		// If traditional, encode the "old" way (the way 1.3.2 or older
		// did it), otherwise encode params recursively.
		for ( prefix in a ) {
			buildParams( prefix, a[ prefix ], traditional, add );
		}
	}

	// Return the resulting serialization
	return s.join( "&" ).replace( r20, "+" );
};

jQuery.fn.extend( {
	serialize: function() {
		return jQuery.param( this.serializeArray() );
	},
	serializeArray: function() {
		return this.map( function() {

			// Can add propHook for "elements" to filter or add form elements
			var elements = jQuery.prop( this, "elements" );
			return elements ? jQuery.makeArray( elements ) : this;
		} )
		.filter( function() {
			var type = this.type;

			// Use .is(":disabled") so that fieldset[disabled] works
			return this.name && !jQuery( this ).is( ":disabled" ) &&
				rsubmittable.test( this.nodeName ) && !rsubmitterTypes.test( type ) &&
				( this.checked || !rcheckableType.test( type ) );
		} )
		.map( function( i, elem ) {
			var val = jQuery( this ).val();

			return val == null ?
				null :
				jQuery.isArray( val ) ?
					jQuery.map( val, function( val ) {
						return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
					} ) :
					{ name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
		} ).get();
	}
} );


// Create the request object
// (This is still attached to ajaxSettings for backward compatibility)
jQuery.ajaxSettings.xhr = window.ActiveXObject !== undefined ?

	// Support: IE6-IE8
	function() {

		// XHR cannot access local files, always use ActiveX for that case
		if ( this.isLocal ) {
			return createActiveXHR();
		}

		// Support: IE 9-11
		// IE seems to error on cross-domain PATCH requests when ActiveX XHR
		// is used. In IE 9+ always use the native XHR.
		// Note: this condition won't catch Edge as it doesn't define
		// document.documentMode but it also doesn't support ActiveX so it won't
		// reach this code.
		if ( document.documentMode > 8 ) {
			return createStandardXHR();
		}

		// Support: IE<9
		// oldIE XHR does not support non-RFC2616 methods (#13240)
		// See http://msdn.microsoft.com/en-us/library/ie/ms536648(v=vs.85).aspx
		// and http://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html#sec9
		// Although this check for six methods instead of eight
		// since IE also does not support "trace" and "connect"
		return /^(get|post|head|put|delete|options)$/i.test( this.type ) &&
			createStandardXHR() || createActiveXHR();
	} :

	// For all other browsers, use the standard XMLHttpRequest object
	createStandardXHR;

var xhrId = 0,
	xhrCallbacks = {},
	xhrSupported = jQuery.ajaxSettings.xhr();

// Support: IE<10
// Open requests must be manually aborted on unload (#5280)
// See https://support.microsoft.com/kb/2856746 for more info
if ( window.attachEvent ) {
	window.attachEvent( "onunload", function() {
		for ( var key in xhrCallbacks ) {
			xhrCallbacks[ key ]( undefined, true );
		}
	} );
}

// Determine support properties
support.cors = !!xhrSupported && ( "withCredentials" in xhrSupported );
xhrSupported = support.ajax = !!xhrSupported;

// Create transport if the browser can provide an xhr
if ( xhrSupported ) {

	jQuery.ajaxTransport( function( options ) {

		// Cross domain only allowed if supported through XMLHttpRequest
		if ( !options.crossDomain || support.cors ) {

			var callback;

			return {
				send: function( headers, complete ) {
					var i,
						xhr = options.xhr(),
						id = ++xhrId;

					// Open the socket
					xhr.open(
						options.type,
						options.url,
						options.async,
						options.username,
						options.password
					);

					// Apply custom fields if provided
					if ( options.xhrFields ) {
						for ( i in options.xhrFields ) {
							xhr[ i ] = options.xhrFields[ i ];
						}
					}

					// Override mime type if needed
					if ( options.mimeType && xhr.overrideMimeType ) {
						xhr.overrideMimeType( options.mimeType );
					}

					// X-Requested-With header
					// For cross-domain requests, seeing as conditions for a preflight are
					// akin to a jigsaw puzzle, we simply never set it to be sure.
					// (it can always be set on a per-request basis or even using ajaxSetup)
					// For same-domain requests, won't change header if already provided.
					if ( !options.crossDomain && !headers[ "X-Requested-With" ] ) {
						headers[ "X-Requested-With" ] = "XMLHttpRequest";
					}

					// Set headers
					for ( i in headers ) {

						// Support: IE<9
						// IE's ActiveXObject throws a 'Type Mismatch' exception when setting
						// request header to a null-value.
						//
						// To keep consistent with other XHR implementations, cast the value
						// to string and ignore `undefined`.
						if ( headers[ i ] !== undefined ) {
							xhr.setRequestHeader( i, headers[ i ] + "" );
						}
					}

					// Do send the request
					// This may raise an exception which is actually
					// handled in jQuery.ajax (so no try/catch here)
					xhr.send( ( options.hasContent && options.data ) || null );

					// Listener
					callback = function( _, isAbort ) {
						var status, statusText, responses;

						// Was never called and is aborted or complete
						if ( callback && ( isAbort || xhr.readyState === 4 ) ) {

							// Clean up
							delete xhrCallbacks[ id ];
							callback = undefined;
							xhr.onreadystatechange = jQuery.noop;

							// Abort manually if needed
							if ( isAbort ) {
								if ( xhr.readyState !== 4 ) {
									xhr.abort();
								}
							} else {
								responses = {};
								status = xhr.status;

								// Support: IE<10
								// Accessing binary-data responseText throws an exception
								// (#11426)
								if ( typeof xhr.responseText === "string" ) {
									responses.text = xhr.responseText;
								}

								// Firefox throws an exception when accessing
								// statusText for faulty cross-domain requests
								try {
									statusText = xhr.statusText;
								} catch ( e ) {

									// We normalize with Webkit giving an empty statusText
									statusText = "";
								}

								// Filter status for non standard behaviors

								// If the request is local and we have data: assume a success
								// (success with no data won't get notified, that's the best we
								// can do given current implementations)
								if ( !status && options.isLocal && !options.crossDomain ) {
									status = responses.text ? 200 : 404;

								// IE - #1450: sometimes returns 1223 when it should be 204
								} else if ( status === 1223 ) {
									status = 204;
								}
							}
						}

						// Call complete if needed
						if ( responses ) {
							complete( status, statusText, responses, xhr.getAllResponseHeaders() );
						}
					};

					// Do send the request
					// `xhr.send` may raise an exception, but it will be
					// handled in jQuery.ajax (so no try/catch here)
					if ( !options.async ) {

						// If we're in sync mode we fire the callback
						callback();
					} else if ( xhr.readyState === 4 ) {

						// (IE6 & IE7) if it's in cache and has been
						// retrieved directly we need to fire the callback
						window.setTimeout( callback );
					} else {

						// Register the callback, but delay it in case `xhr.send` throws
						// Add to the list of active xhr callbacks
						xhr.onreadystatechange = xhrCallbacks[ id ] = callback;
					}
				},

				abort: function() {
					if ( callback ) {
						callback( undefined, true );
					}
				}
			};
		}
	} );
}

// Functions to create xhrs
function createStandardXHR() {
	try {
		return new window.XMLHttpRequest();
	} catch ( e ) {}
}

function createActiveXHR() {
	try {
		return new window.ActiveXObject( "Microsoft.XMLHTTP" );
	} catch ( e ) {}
}




// Install script dataType
jQuery.ajaxSetup( {
	accepts: {
		script: "text/javascript, application/javascript, " +
			"application/ecmascript, application/x-ecmascript"
	},
	contents: {
		script: /\b(?:java|ecma)script\b/
	},
	converters: {
		"text script": function( text ) {
			jQuery.globalEval( text );
			return text;
		}
	}
} );

// Handle cache's special case and global
jQuery.ajaxPrefilter( "script", function( s ) {
	if ( s.cache === undefined ) {
		s.cache = false;
	}
	if ( s.crossDomain ) {
		s.type = "GET";
		s.global = false;
	}
} );

// Bind script tag hack transport
jQuery.ajaxTransport( "script", function( s ) {

	// This transport only deals with cross domain requests
	if ( s.crossDomain ) {

		var script,
			head = document.head || jQuery( "head" )[ 0 ] || document.documentElement;

		return {

			send: function( _, callback ) {

				script = document.createElement( "script" );

				script.async = true;

				if ( s.scriptCharset ) {
					script.charset = s.scriptCharset;
				}

				script.src = s.url;

				// Attach handlers for all browsers
				script.onload = script.onreadystatechange = function( _, isAbort ) {

					if ( isAbort || !script.readyState || /loaded|complete/.test( script.readyState ) ) {

						// Handle memory leak in IE
						script.onload = script.onreadystatechange = null;

						// Remove the script
						if ( script.parentNode ) {
							script.parentNode.removeChild( script );
						}

						// Dereference the script
						script = null;

						// Callback if not abort
						if ( !isAbort ) {
							callback( 200, "success" );
						}
					}
				};

				// Circumvent IE6 bugs with base elements (#2709 and #4378) by prepending
				// Use native DOM manipulation to avoid our domManip AJAX trickery
				head.insertBefore( script, head.firstChild );
			},

			abort: function() {
				if ( script ) {
					script.onload( undefined, true );
				}
			}
		};
	}
} );




var oldCallbacks = [],
	rjsonp = /(=)\?(?=&|$)|\?\?/;

// Default jsonp settings
jQuery.ajaxSetup( {
	jsonp: "callback",
	jsonpCallback: function() {
		var callback = oldCallbacks.pop() || ( jQuery.expando + "_" + ( nonce++ ) );
		this[ callback ] = true;
		return callback;
	}
} );

// Detect, normalize options and install callbacks for jsonp requests
jQuery.ajaxPrefilter( "json jsonp", function( s, originalSettings, jqXHR ) {

	var callbackName, overwritten, responseContainer,
		jsonProp = s.jsonp !== false && ( rjsonp.test( s.url ) ?
			"url" :
			typeof s.data === "string" &&
				( s.contentType || "" )
					.indexOf( "application/x-www-form-urlencoded" ) === 0 &&
				rjsonp.test( s.data ) && "data"
		);

	// Handle iff the expected data type is "jsonp" or we have a parameter to set
	if ( jsonProp || s.dataTypes[ 0 ] === "jsonp" ) {

		// Get callback name, remembering preexisting value associated with it
		callbackName = s.jsonpCallback = jQuery.isFunction( s.jsonpCallback ) ?
			s.jsonpCallback() :
			s.jsonpCallback;

		// Insert callback into url or form data
		if ( jsonProp ) {
			s[ jsonProp ] = s[ jsonProp ].replace( rjsonp, "$1" + callbackName );
		} else if ( s.jsonp !== false ) {
			s.url += ( rquery.test( s.url ) ? "&" : "?" ) + s.jsonp + "=" + callbackName;
		}

		// Use data converter to retrieve json after script execution
		s.converters[ "script json" ] = function() {
			if ( !responseContainer ) {
				jQuery.error( callbackName + " was not called" );
			}
			return responseContainer[ 0 ];
		};

		// force json dataType
		s.dataTypes[ 0 ] = "json";

		// Install callback
		overwritten = window[ callbackName ];
		window[ callbackName ] = function() {
			responseContainer = arguments;
		};

		// Clean-up function (fires after converters)
		jqXHR.always( function() {

			// If previous value didn't exist - remove it
			if ( overwritten === undefined ) {
				jQuery( window ).removeProp( callbackName );

			// Otherwise restore preexisting value
			} else {
				window[ callbackName ] = overwritten;
			}

			// Save back as free
			if ( s[ callbackName ] ) {

				// make sure that re-using the options doesn't screw things around
				s.jsonpCallback = originalSettings.jsonpCallback;

				// save the callback name for future use
				oldCallbacks.push( callbackName );
			}

			// Call if it was a function and we have a response
			if ( responseContainer && jQuery.isFunction( overwritten ) ) {
				overwritten( responseContainer[ 0 ] );
			}

			responseContainer = overwritten = undefined;
		} );

		// Delegate to script
		return "script";
	}
} );




// data: string of html
// context (optional): If specified, the fragment will be created in this context,
// defaults to document
// keepScripts (optional): If true, will include scripts passed in the html string
jQuery.parseHTML = function( data, context, keepScripts ) {
	if ( !data || typeof data !== "string" ) {
		return null;
	}
	if ( typeof context === "boolean" ) {
		keepScripts = context;
		context = false;
	}
	context = context || document;

	var parsed = rsingleTag.exec( data ),
		scripts = !keepScripts && [];

	// Single tag
	if ( parsed ) {
		return [ context.createElement( parsed[ 1 ] ) ];
	}

	parsed = buildFragment( [ data ], context, scripts );

	if ( scripts && scripts.length ) {
		jQuery( scripts ).remove();
	}

	return jQuery.merge( [], parsed.childNodes );
};


// Keep a copy of the old load method
var _load = jQuery.fn.load;

/**
 * Load a url into a page
 */
jQuery.fn.load = function( url, params, callback ) {
	if ( typeof url !== "string" && _load ) {
		return _load.apply( this, arguments );
	}

	var selector, type, response,
		self = this,
		off = url.indexOf( " " );

	if ( off > -1 ) {
		selector = jQuery.trim( url.slice( off, url.length ) );
		url = url.slice( 0, off );
	}

	// If it's a function
	if ( jQuery.isFunction( params ) ) {

		// We assume that it's the callback
		callback = params;
		params = undefined;

	// Otherwise, build a param string
	} else if ( params && typeof params === "object" ) {
		type = "POST";
	}

	// If we have elements to modify, make the request
	if ( self.length > 0 ) {
		jQuery.ajax( {
			url: url,

			// If "type" variable is undefined, then "GET" method will be used.
			// Make value of this field explicit since
			// user can override it through ajaxSetup method
			type: type || "GET",
			dataType: "html",
			data: params
		} ).done( function( responseText ) {

			// Save response for use in complete callback
			response = arguments;

			self.html( selector ?

				// If a selector was specified, locate the right elements in a dummy div
				// Exclude scripts to avoid IE 'Permission Denied' errors
				jQuery( "<div>" ).append( jQuery.parseHTML( responseText ) ).find( selector ) :

				// Otherwise use the full result
				responseText );

		// If the request succeeds, this function gets "data", "status", "jqXHR"
		// but they are ignored because response was set above.
		// If it fails, this function gets "jqXHR", "status", "error"
		} ).always( callback && function( jqXHR, status ) {
			self.each( function() {
				callback.apply( this, response || [ jqXHR.responseText, status, jqXHR ] );
			} );
		} );
	}

	return this;
};




// Attach a bunch of functions for handling common AJAX events
jQuery.each( [
	"ajaxStart",
	"ajaxStop",
	"ajaxComplete",
	"ajaxError",
	"ajaxSuccess",
	"ajaxSend"
], function( i, type ) {
	jQuery.fn[ type ] = function( fn ) {
		return this.on( type, fn );
	};
} );




jQuery.expr.filters.animated = function( elem ) {
	return jQuery.grep( jQuery.timers, function( fn ) {
		return elem === fn.elem;
	} ).length;
};





/**
 * Gets a window from an element
 */
function getWindow( elem ) {
	return jQuery.isWindow( elem ) ?
		elem :
		elem.nodeType === 9 ?
			elem.defaultView || elem.parentWindow :
			false;
}

jQuery.offset = {
	setOffset: function( elem, options, i ) {
		var curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition,
			position = jQuery.css( elem, "position" ),
			curElem = jQuery( elem ),
			props = {};

		// set position first, in-case top/left are set even on static elem
		if ( position === "static" ) {
			elem.style.position = "relative";
		}

		curOffset = curElem.offset();
		curCSSTop = jQuery.css( elem, "top" );
		curCSSLeft = jQuery.css( elem, "left" );
		calculatePosition = ( position === "absolute" || position === "fixed" ) &&
			jQuery.inArray( "auto", [ curCSSTop, curCSSLeft ] ) > -1;

		// need to be able to calculate position if either top or left
		// is auto and position is either absolute or fixed
		if ( calculatePosition ) {
			curPosition = curElem.position();
			curTop = curPosition.top;
			curLeft = curPosition.left;
		} else {
			curTop = parseFloat( curCSSTop ) || 0;
			curLeft = parseFloat( curCSSLeft ) || 0;
		}

		if ( jQuery.isFunction( options ) ) {

			// Use jQuery.extend here to allow modification of coordinates argument (gh-1848)
			options = options.call( elem, i, jQuery.extend( {}, curOffset ) );
		}

		if ( options.top != null ) {
			props.top = ( options.top - curOffset.top ) + curTop;
		}
		if ( options.left != null ) {
			props.left = ( options.left - curOffset.left ) + curLeft;
		}

		if ( "using" in options ) {
			options.using.call( elem, props );
		} else {
			curElem.css( props );
		}
	}
};

jQuery.fn.extend( {
	offset: function( options ) {
		if ( arguments.length ) {
			return options === undefined ?
				this :
				this.each( function( i ) {
					jQuery.offset.setOffset( this, options, i );
				} );
		}

		var docElem, win,
			box = { top: 0, left: 0 },
			elem = this[ 0 ],
			doc = elem && elem.ownerDocument;

		if ( !doc ) {
			return;
		}

		docElem = doc.documentElement;

		// Make sure it's not a disconnected DOM node
		if ( !jQuery.contains( docElem, elem ) ) {
			return box;
		}

		// If we don't have gBCR, just use 0,0 rather than error
		// BlackBerry 5, iOS 3 (original iPhone)
		if ( typeof elem.getBoundingClientRect !== "undefined" ) {
			box = elem.getBoundingClientRect();
		}
		win = getWindow( doc );
		return {
			top: box.top  + ( win.pageYOffset || docElem.scrollTop )  - ( docElem.clientTop  || 0 ),
			left: box.left + ( win.pageXOffset || docElem.scrollLeft ) - ( docElem.clientLeft || 0 )
		};
	},

	position: function() {
		if ( !this[ 0 ] ) {
			return;
		}

		var offsetParent, offset,
			parentOffset = { top: 0, left: 0 },
			elem = this[ 0 ];

		// Fixed elements are offset from window (parentOffset = {top:0, left: 0},
		// because it is its only offset parent
		if ( jQuery.css( elem, "position" ) === "fixed" ) {

			// we assume that getBoundingClientRect is available when computed position is fixed
			offset = elem.getBoundingClientRect();
		} else {

			// Get *real* offsetParent
			offsetParent = this.offsetParent();

			// Get correct offsets
			offset = this.offset();
			if ( !jQuery.nodeName( offsetParent[ 0 ], "html" ) ) {
				parentOffset = offsetParent.offset();
			}

			// Add offsetParent borders
			parentOffset.top  += jQuery.css( offsetParent[ 0 ], "borderTopWidth", true );
			parentOffset.left += jQuery.css( offsetParent[ 0 ], "borderLeftWidth", true );
		}

		// Subtract parent offsets and element margins
		// note: when an element has margin: auto the offsetLeft and marginLeft
		// are the same in Safari causing offset.left to incorrectly be 0
		return {
			top:  offset.top  - parentOffset.top - jQuery.css( elem, "marginTop", true ),
			left: offset.left - parentOffset.left - jQuery.css( elem, "marginLeft", true )
		};
	},

	offsetParent: function() {
		return this.map( function() {
			var offsetParent = this.offsetParent;

			while ( offsetParent && ( !jQuery.nodeName( offsetParent, "html" ) &&
				jQuery.css( offsetParent, "position" ) === "static" ) ) {
				offsetParent = offsetParent.offsetParent;
			}
			return offsetParent || documentElement;
		} );
	}
} );

// Create scrollLeft and scrollTop methods
jQuery.each( { scrollLeft: "pageXOffset", scrollTop: "pageYOffset" }, function( method, prop ) {
	var top = /Y/.test( prop );

	jQuery.fn[ method ] = function( val ) {
		return access( this, function( elem, method, val ) {
			var win = getWindow( elem );

			if ( val === undefined ) {
				return win ? ( prop in win ) ? win[ prop ] :
					win.document.documentElement[ method ] :
					elem[ method ];
			}

			if ( win ) {
				win.scrollTo(
					!top ? val : jQuery( win ).scrollLeft(),
					top ? val : jQuery( win ).scrollTop()
				);

			} else {
				elem[ method ] = val;
			}
		}, method, val, arguments.length, null );
	};
} );

// Support: Safari<7-8+, Chrome<37-44+
// Add the top/left cssHooks using jQuery.fn.position
// Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084
// getComputedStyle returns percent when specified for top/left/bottom/right
// rather than make the css module depend on the offset module, we just check for it here
jQuery.each( [ "top", "left" ], function( i, prop ) {
	jQuery.cssHooks[ prop ] = addGetHookIf( support.pixelPosition,
		function( elem, computed ) {
			if ( computed ) {
				computed = curCSS( elem, prop );

				// if curCSS returns percentage, fallback to offset
				return rnumnonpx.test( computed ) ?
					jQuery( elem ).position()[ prop ] + "px" :
					computed;
			}
		}
	);
} );


// Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods
jQuery.each( { Height: "height", Width: "width" }, function( name, type ) {
	jQuery.each( { padding: "inner" + name, content: type, "": "outer" + name },
	function( defaultExtra, funcName ) {

		// margin is only for outerHeight, outerWidth
		jQuery.fn[ funcName ] = function( margin, value ) {
			var chainable = arguments.length && ( defaultExtra || typeof margin !== "boolean" ),
				extra = defaultExtra || ( margin === true || value === true ? "margin" : "border" );

			return access( this, function( elem, type, value ) {
				var doc;

				if ( jQuery.isWindow( elem ) ) {

					// As of 5/8/2012 this will yield incorrect results for Mobile Safari, but there
					// isn't a whole lot we can do. See pull request at this URL for discussion:
					// https://github.com/jquery/jquery/pull/764
					return elem.document.documentElement[ "client" + name ];
				}

				// Get document width or height
				if ( elem.nodeType === 9 ) {
					doc = elem.documentElement;

					// Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],
					// whichever is greatest
					// unfortunately, this causes bug #3838 in IE6/8 only,
					// but there is currently no good, small way to fix it.
					return Math.max(
						elem.body[ "scroll" + name ], doc[ "scroll" + name ],
						elem.body[ "offset" + name ], doc[ "offset" + name ],
						doc[ "client" + name ]
					);
				}

				return value === undefined ?

					// Get width or height on the element, requesting but not forcing parseFloat
					jQuery.css( elem, type, extra ) :

					// Set width or height on the element
					jQuery.style( elem, type, value, extra );
			}, type, chainable ? margin : undefined, chainable, null );
		};
	} );
} );


jQuery.fn.extend( {

	bind: function( types, data, fn ) {
		return this.on( types, null, data, fn );
	},
	unbind: function( types, fn ) {
		return this.off( types, null, fn );
	},

	delegate: function( selector, types, data, fn ) {
		return this.on( types, selector, data, fn );
	},
	undelegate: function( selector, types, fn ) {

		// ( namespace ) or ( selector, types [, fn] )
		return arguments.length === 1 ?
			this.off( selector, "**" ) :
			this.off( types, selector || "**", fn );
	}
} );

// The number of elements contained in the matched element set
jQuery.fn.size = function() {
	return this.length;
};

jQuery.fn.andSelf = jQuery.fn.addBack;




// Register as a named AMD module, since jQuery can be concatenated with other
// files that may use define, but not via a proper concatenation script that
// understands anonymous AMD modules. A named AMD is safest and most robust
// way to register. Lowercase jquery is used because AMD module names are
// derived from file names, and jQuery is normally delivered in a lowercase
// file name. Do this after creating the global so that if an AMD module wants
// to call noConflict to hide this version of jQuery, it will work.

// Note that for maximum portability, libraries that are not jQuery should
// declare themselves as anonymous modules, and avoid setting a global if an
// AMD loader is present. jQuery is a special case. For more information, see
// https://github.com/jrburke/requirejs/wiki/Updating-existing-libraries#wiki-anon

if ( typeof define === "function" && define.amd ) {
	define( "jquery", [], function() {
		return jQuery;
	} );
}



var

	// Map over jQuery in case of overwrite
	_jQuery = window.jQuery,

	// Map over the $ in case of overwrite
	_$ = window.$;

jQuery.noConflict = function( deep ) {
	if ( window.$ === jQuery ) {
		window.$ = _$;
	}

	if ( deep && window.jQuery === jQuery ) {
		window.jQuery = _jQuery;
	}

	return jQuery;
};

// Expose jQuery and $ identifiers, even in
// AMD (#7102#comment:10, https://github.com/jquery/jquery/pull/557)
// and CommonJS for browser emulators (#13566)
if ( !noGlobal ) {
	window.jQuery = window.$ = jQuery;
}

return jQuery;
}));


/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.colorsService = exports.jsonHL = exports.config = exports.rest = exports.apiKey = exports.base = undefined;

var _base = __webpack_require__(6);

var _base2 = _interopRequireDefault(_base);

var _apiKey = __webpack_require__(5);

var _apiKey2 = _interopRequireDefault(_apiKey);

var _config = __webpack_require__(46);

var _config2 = _interopRequireDefault(_config);

var _jsonHighlight = __webpack_require__(47);

var _jsonHighlight2 = _interopRequireDefault(_jsonHighlight);

var _colors = __webpack_require__(45);

var _colors2 = _interopRequireDefault(_colors);

var _rest = __webpack_require__(7);

var _rest2 = _interopRequireDefault(_rest);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.base = _base2.default;
exports.apiKey = _apiKey2.default;
exports.rest = _rest2.default;
exports.config = _config2.default;
exports.jsonHL = _jsonHighlight2.default;
exports.colorsService = _colors2.default;

/***/ }),
/* 3 */
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || Function("return this")() || (1,eval)("this");
} catch(e) {
	// This works if the window reference is available
	if(typeof window === "object")
		g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
 * Knockout JavaScript library v3.4.1
 * (c) The Knockout.js team - http://knockoutjs.com/
 * License: MIT (http://www.opensource.org/licenses/mit-license.php)
 */

(function(){
var DEBUG=true;
(function(undefined){
    // (0, eval)('this') is a robust way of getting a reference to the global object
    // For details, see http://stackoverflow.com/questions/14119988/return-this-0-evalthis/14120023#14120023
    var window = this || (0, eval)('this'),
        document = window['document'],
        navigator = window['navigator'],
        jQueryInstance = window["jQuery"],
        JSON = window["JSON"];
(function(factory) {
    // Support three module loading scenarios
    if (true) {
        // [1] AMD anonymous module
        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports, __webpack_require__], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
    } else if (typeof exports === 'object' && typeof module === 'object') {
        // [2] CommonJS/Node.js
        factory(module['exports'] || exports);  // module.exports is for Node.js
    } else {
        // [3] No module loader (plain <script> tag) - put directly in global namespace
        factory(window['ko'] = {});
    }
}(function(koExports, amdRequire){
// Internally, all KO objects are attached to koExports (even the non-exported ones whose names will be minified by the closure compiler).
// In the future, the following "ko" variable may be made distinct from "koExports" so that private objects are not externally reachable.
var ko = typeof koExports !== 'undefined' ? koExports : {};
// Google Closure Compiler helpers (used only to make the minified file smaller)
ko.exportSymbol = function(koPath, object) {
    var tokens = koPath.split(".");

    // In the future, "ko" may become distinct from "koExports" (so that non-exported objects are not reachable)
    // At that point, "target" would be set to: (typeof koExports !== "undefined" ? koExports : ko)
    var target = ko;

    for (var i = 0; i < tokens.length - 1; i++)
        target = target[tokens[i]];
    target[tokens[tokens.length - 1]] = object;
};
ko.exportProperty = function(owner, publicName, object) {
    owner[publicName] = object;
};
ko.version = "3.4.1";

ko.exportSymbol('version', ko.version);
// For any options that may affect various areas of Knockout and aren't directly associated with data binding.
ko.options = {
    'deferUpdates': false,
    'useOnlyNativeEvents': false
};

//ko.exportSymbol('options', ko.options);   // 'options' isn't minified
ko.utils = (function () {
    function objectForEach(obj, action) {
        for (var prop in obj) {
            if (obj.hasOwnProperty(prop)) {
                action(prop, obj[prop]);
            }
        }
    }

    function extend(target, source) {
        if (source) {
            for(var prop in source) {
                if(source.hasOwnProperty(prop)) {
                    target[prop] = source[prop];
                }
            }
        }
        return target;
    }

    function setPrototypeOf(obj, proto) {
        obj.__proto__ = proto;
        return obj;
    }

    var canSetPrototype = ({ __proto__: [] } instanceof Array);
    var canUseSymbols = !DEBUG && typeof Symbol === 'function';

    // Represent the known event types in a compact way, then at runtime transform it into a hash with event name as key (for fast lookup)
    var knownEvents = {}, knownEventTypesByEventName = {};
    var keyEventTypeName = (navigator && /Firefox\/2/i.test(navigator.userAgent)) ? 'KeyboardEvent' : 'UIEvents';
    knownEvents[keyEventTypeName] = ['keyup', 'keydown', 'keypress'];
    knownEvents['MouseEvents'] = ['click', 'dblclick', 'mousedown', 'mouseup', 'mousemove', 'mouseover', 'mouseout', 'mouseenter', 'mouseleave'];
    objectForEach(knownEvents, function(eventType, knownEventsForType) {
        if (knownEventsForType.length) {
            for (var i = 0, j = knownEventsForType.length; i < j; i++)
                knownEventTypesByEventName[knownEventsForType[i]] = eventType;
        }
    });
    var eventsThatMustBeRegisteredUsingAttachEvent = { 'propertychange': true }; // Workaround for an IE9 issue - https://github.com/SteveSanderson/knockout/issues/406

    // Detect IE versions for bug workarounds (uses IE conditionals, not UA string, for robustness)
    // Note that, since IE 10 does not support conditional comments, the following logic only detects IE < 10.
    // Currently this is by design, since IE 10+ behaves correctly when treated as a standard browser.
    // If there is a future need to detect specific versions of IE10+, we will amend this.
    var ieVersion = document && (function() {
        var version = 3, div = document.createElement('div'), iElems = div.getElementsByTagName('i');

        // Keep constructing conditional HTML blocks until we hit one that resolves to an empty fragment
        while (
            div.innerHTML = '<!--[if gt IE ' + (++version) + ']><i></i><![endif]-->',
            iElems[0]
        ) {}
        return version > 4 ? version : undefined;
    }());
    var isIe6 = ieVersion === 6,
        isIe7 = ieVersion === 7;

    function isClickOnCheckableElement(element, eventType) {
        if ((ko.utils.tagNameLower(element) !== "input") || !element.type) return false;
        if (eventType.toLowerCase() != "click") return false;
        var inputType = element.type;
        return (inputType == "checkbox") || (inputType == "radio");
    }

    // For details on the pattern for changing node classes
    // see: https://github.com/knockout/knockout/issues/1597
    var cssClassNameRegex = /\S+/g;

    function toggleDomNodeCssClass(node, classNames, shouldHaveClass) {
        var addOrRemoveFn;
        if (classNames) {
            if (typeof node.classList === 'object') {
                addOrRemoveFn = node.classList[shouldHaveClass ? 'add' : 'remove'];
                ko.utils.arrayForEach(classNames.match(cssClassNameRegex), function(className) {
                    addOrRemoveFn.call(node.classList, className);
                });
            } else if (typeof node.className['baseVal'] === 'string') {
                // SVG tag .classNames is an SVGAnimatedString instance
                toggleObjectClassPropertyString(node.className, 'baseVal', classNames, shouldHaveClass);
            } else {
                // node.className ought to be a string.
                toggleObjectClassPropertyString(node, 'className', classNames, shouldHaveClass);
            }
        }
    }

    function toggleObjectClassPropertyString(obj, prop, classNames, shouldHaveClass) {
        // obj/prop is either a node/'className' or a SVGAnimatedString/'baseVal'.
        var currentClassNames = obj[prop].match(cssClassNameRegex) || [];
        ko.utils.arrayForEach(classNames.match(cssClassNameRegex), function(className) {
            ko.utils.addOrRemoveItem(currentClassNames, className, shouldHaveClass);
        });
        obj[prop] = currentClassNames.join(" ");
    }

    return {
        fieldsIncludedWithJsonPost: ['authenticity_token', /^__RequestVerificationToken(_.*)?$/],

        arrayForEach: function (array, action) {
            for (var i = 0, j = array.length; i < j; i++)
                action(array[i], i);
        },

        arrayIndexOf: function (array, item) {
            if (typeof Array.prototype.indexOf == "function")
                return Array.prototype.indexOf.call(array, item);
            for (var i = 0, j = array.length; i < j; i++)
                if (array[i] === item)
                    return i;
            return -1;
        },

        arrayFirst: function (array, predicate, predicateOwner) {
            for (var i = 0, j = array.length; i < j; i++)
                if (predicate.call(predicateOwner, array[i], i))
                    return array[i];
            return null;
        },

        arrayRemoveItem: function (array, itemToRemove) {
            var index = ko.utils.arrayIndexOf(array, itemToRemove);
            if (index > 0) {
                array.splice(index, 1);
            }
            else if (index === 0) {
                array.shift();
            }
        },

        arrayGetDistinctValues: function (array) {
            array = array || [];
            var result = [];
            for (var i = 0, j = array.length; i < j; i++) {
                if (ko.utils.arrayIndexOf(result, array[i]) < 0)
                    result.push(array[i]);
            }
            return result;
        },

        arrayMap: function (array, mapping) {
            array = array || [];
            var result = [];
            for (var i = 0, j = array.length; i < j; i++)
                result.push(mapping(array[i], i));
            return result;
        },

        arrayFilter: function (array, predicate) {
            array = array || [];
            var result = [];
            for (var i = 0, j = array.length; i < j; i++)
                if (predicate(array[i], i))
                    result.push(array[i]);
            return result;
        },

        arrayPushAll: function (array, valuesToPush) {
            if (valuesToPush instanceof Array)
                array.push.apply(array, valuesToPush);
            else
                for (var i = 0, j = valuesToPush.length; i < j; i++)
                    array.push(valuesToPush[i]);
            return array;
        },

        addOrRemoveItem: function(array, value, included) {
            var existingEntryIndex = ko.utils.arrayIndexOf(ko.utils.peekObservable(array), value);
            if (existingEntryIndex < 0) {
                if (included)
                    array.push(value);
            } else {
                if (!included)
                    array.splice(existingEntryIndex, 1);
            }
        },

        canSetPrototype: canSetPrototype,

        extend: extend,

        setPrototypeOf: setPrototypeOf,

        setPrototypeOfOrExtend: canSetPrototype ? setPrototypeOf : extend,

        objectForEach: objectForEach,

        objectMap: function(source, mapping) {
            if (!source)
                return source;
            var target = {};
            for (var prop in source) {
                if (source.hasOwnProperty(prop)) {
                    target[prop] = mapping(source[prop], prop, source);
                }
            }
            return target;
        },

        emptyDomNode: function (domNode) {
            while (domNode.firstChild) {
                ko.removeNode(domNode.firstChild);
            }
        },

        moveCleanedNodesToContainerElement: function(nodes) {
            // Ensure it's a real array, as we're about to reparent the nodes and
            // we don't want the underlying collection to change while we're doing that.
            var nodesArray = ko.utils.makeArray(nodes);
            var templateDocument = (nodesArray[0] && nodesArray[0].ownerDocument) || document;

            var container = templateDocument.createElement('div');
            for (var i = 0, j = nodesArray.length; i < j; i++) {
                container.appendChild(ko.cleanNode(nodesArray[i]));
            }
            return container;
        },

        cloneNodes: function (nodesArray, shouldCleanNodes) {
            for (var i = 0, j = nodesArray.length, newNodesArray = []; i < j; i++) {
                var clonedNode = nodesArray[i].cloneNode(true);
                newNodesArray.push(shouldCleanNodes ? ko.cleanNode(clonedNode) : clonedNode);
            }
            return newNodesArray;
        },

        setDomNodeChildren: function (domNode, childNodes) {
            ko.utils.emptyDomNode(domNode);
            if (childNodes) {
                for (var i = 0, j = childNodes.length; i < j; i++)
                    domNode.appendChild(childNodes[i]);
            }
        },

        replaceDomNodes: function (nodeToReplaceOrNodeArray, newNodesArray) {
            var nodesToReplaceArray = nodeToReplaceOrNodeArray.nodeType ? [nodeToReplaceOrNodeArray] : nodeToReplaceOrNodeArray;
            if (nodesToReplaceArray.length > 0) {
                var insertionPoint = nodesToReplaceArray[0];
                var parent = insertionPoint.parentNode;
                for (var i = 0, j = newNodesArray.length; i < j; i++)
                    parent.insertBefore(newNodesArray[i], insertionPoint);
                for (var i = 0, j = nodesToReplaceArray.length; i < j; i++) {
                    ko.removeNode(nodesToReplaceArray[i]);
                }
            }
        },

        fixUpContinuousNodeArray: function(continuousNodeArray, parentNode) {
            // Before acting on a set of nodes that were previously outputted by a template function, we have to reconcile
            // them against what is in the DOM right now. It may be that some of the nodes have already been removed, or that
            // new nodes might have been inserted in the middle, for example by a binding. Also, there may previously have been
            // leading comment nodes (created by rewritten string-based templates) that have since been removed during binding.
            // So, this function translates the old "map" output array into its best guess of the set of current DOM nodes.
            //
            // Rules:
            //   [A] Any leading nodes that have been removed should be ignored
            //       These most likely correspond to memoization nodes that were already removed during binding
            //       See https://github.com/knockout/knockout/pull/440
            //   [B] Any trailing nodes that have been remove should be ignored
            //       This prevents the code here from adding unrelated nodes to the array while processing rule [C]
            //       See https://github.com/knockout/knockout/pull/1903
            //   [C] We want to output a continuous series of nodes. So, ignore any nodes that have already been removed,
            //       and include any nodes that have been inserted among the previous collection

            if (continuousNodeArray.length) {
                // The parent node can be a virtual element; so get the real parent node
                parentNode = (parentNode.nodeType === 8 && parentNode.parentNode) || parentNode;

                // Rule [A]
                while (continuousNodeArray.length && continuousNodeArray[0].parentNode !== parentNode)
                    continuousNodeArray.splice(0, 1);

                // Rule [B]
                while (continuousNodeArray.length > 1 && continuousNodeArray[continuousNodeArray.length - 1].parentNode !== parentNode)
                    continuousNodeArray.length--;

                // Rule [C]
                if (continuousNodeArray.length > 1) {
                    var current = continuousNodeArray[0], last = continuousNodeArray[continuousNodeArray.length - 1];
                    // Replace with the actual new continuous node set
                    continuousNodeArray.length = 0;
                    while (current !== last) {
                        continuousNodeArray.push(current);
                        current = current.nextSibling;
                    }
                    continuousNodeArray.push(last);
                }
            }
            return continuousNodeArray;
        },

        setOptionNodeSelectionState: function (optionNode, isSelected) {
            // IE6 sometimes throws "unknown error" if you try to write to .selected directly, whereas Firefox struggles with setAttribute. Pick one based on browser.
            if (ieVersion < 7)
                optionNode.setAttribute("selected", isSelected);
            else
                optionNode.selected = isSelected;
        },

        stringTrim: function (string) {
            return string === null || string === undefined ? '' :
                string.trim ?
                    string.trim() :
                    string.toString().replace(/^[\s\xa0]+|[\s\xa0]+$/g, '');
        },

        stringStartsWith: function (string, startsWith) {
            string = string || "";
            if (startsWith.length > string.length)
                return false;
            return string.substring(0, startsWith.length) === startsWith;
        },

        domNodeIsContainedBy: function (node, containedByNode) {
            if (node === containedByNode)
                return true;
            if (node.nodeType === 11)
                return false; // Fixes issue #1162 - can't use node.contains for document fragments on IE8
            if (containedByNode.contains)
                return containedByNode.contains(node.nodeType === 3 ? node.parentNode : node);
            if (containedByNode.compareDocumentPosition)
                return (containedByNode.compareDocumentPosition(node) & 16) == 16;
            while (node && node != containedByNode) {
                node = node.parentNode;
            }
            return !!node;
        },

        domNodeIsAttachedToDocument: function (node) {
            return ko.utils.domNodeIsContainedBy(node, node.ownerDocument.documentElement);
        },

        anyDomNodeIsAttachedToDocument: function(nodes) {
            return !!ko.utils.arrayFirst(nodes, ko.utils.domNodeIsAttachedToDocument);
        },

        tagNameLower: function(element) {
            // For HTML elements, tagName will always be upper case; for XHTML elements, it'll be lower case.
            // Possible future optimization: If we know it's an element from an XHTML document (not HTML),
            // we don't need to do the .toLowerCase() as it will always be lower case anyway.
            return element && element.tagName && element.tagName.toLowerCase();
        },

        catchFunctionErrors: function (delegate) {
            return ko['onError'] ? function () {
                try {
                    return delegate.apply(this, arguments);
                } catch (e) {
                    ko['onError'] && ko['onError'](e);
                    throw e;
                }
            } : delegate;
        },

        setTimeout: function (handler, timeout) {
            return setTimeout(ko.utils.catchFunctionErrors(handler), timeout);
        },

        deferError: function (error) {
            setTimeout(function () {
                ko['onError'] && ko['onError'](error);
                throw error;
            }, 0);
        },

        registerEventHandler: function (element, eventType, handler) {
            var wrappedHandler = ko.utils.catchFunctionErrors(handler);

            var mustUseAttachEvent = ieVersion && eventsThatMustBeRegisteredUsingAttachEvent[eventType];
            if (!ko.options['useOnlyNativeEvents'] && !mustUseAttachEvent && jQueryInstance) {
                jQueryInstance(element)['bind'](eventType, wrappedHandler);
            } else if (!mustUseAttachEvent && typeof element.addEventListener == "function")
                element.addEventListener(eventType, wrappedHandler, false);
            else if (typeof element.attachEvent != "undefined") {
                var attachEventHandler = function (event) { wrappedHandler.call(element, event); },
                    attachEventName = "on" + eventType;
                element.attachEvent(attachEventName, attachEventHandler);

                // IE does not dispose attachEvent handlers automatically (unlike with addEventListener)
                // so to avoid leaks, we have to remove them manually. See bug #856
                ko.utils.domNodeDisposal.addDisposeCallback(element, function() {
                    element.detachEvent(attachEventName, attachEventHandler);
                });
            } else
                throw new Error("Browser doesn't support addEventListener or attachEvent");
        },

        triggerEvent: function (element, eventType) {
            if (!(element && element.nodeType))
                throw new Error("element must be a DOM node when calling triggerEvent");

            // For click events on checkboxes and radio buttons, jQuery toggles the element checked state *after* the
            // event handler runs instead of *before*. (This was fixed in 1.9 for checkboxes but not for radio buttons.)
            // IE doesn't change the checked state when you trigger the click event using "fireEvent".
            // In both cases, we'll use the click method instead.
            var useClickWorkaround = isClickOnCheckableElement(element, eventType);

            if (!ko.options['useOnlyNativeEvents'] && jQueryInstance && !useClickWorkaround) {
                jQueryInstance(element)['trigger'](eventType);
            } else if (typeof document.createEvent == "function") {
                if (typeof element.dispatchEvent == "function") {
                    var eventCategory = knownEventTypesByEventName[eventType] || "HTMLEvents";
                    var event = document.createEvent(eventCategory);
                    event.initEvent(eventType, true, true, window, 0, 0, 0, 0, 0, false, false, false, false, 0, element);
                    element.dispatchEvent(event);
                }
                else
                    throw new Error("The supplied element doesn't support dispatchEvent");
            } else if (useClickWorkaround && element.click) {
                element.click();
            } else if (typeof element.fireEvent != "undefined") {
                element.fireEvent("on" + eventType);
            } else {
                throw new Error("Browser doesn't support triggering events");
            }
        },

        unwrapObservable: function (value) {
            return ko.isObservable(value) ? value() : value;
        },

        peekObservable: function (value) {
            return ko.isObservable(value) ? value.peek() : value;
        },

        toggleDomNodeCssClass: toggleDomNodeCssClass,

        setTextContent: function(element, textContent) {
            var value = ko.utils.unwrapObservable(textContent);
            if ((value === null) || (value === undefined))
                value = "";

            // We need there to be exactly one child: a text node.
            // If there are no children, more than one, or if it's not a text node,
            // we'll clear everything and create a single text node.
            var innerTextNode = ko.virtualElements.firstChild(element);
            if (!innerTextNode || innerTextNode.nodeType != 3 || ko.virtualElements.nextSibling(innerTextNode)) {
                ko.virtualElements.setDomNodeChildren(element, [element.ownerDocument.createTextNode(value)]);
            } else {
                innerTextNode.data = value;
            }

            ko.utils.forceRefresh(element);
        },

        setElementName: function(element, name) {
            element.name = name;

            // Workaround IE 6/7 issue
            // - https://github.com/SteveSanderson/knockout/issues/197
            // - http://www.matts411.com/post/setting_the_name_attribute_in_ie_dom/
            if (ieVersion <= 7) {
                try {
                    element.mergeAttributes(document.createElement("<input name='" + element.name + "'/>"), false);
                }
                catch(e) {} // For IE9 with doc mode "IE9 Standards" and browser mode "IE9 Compatibility View"
            }
        },

        forceRefresh: function(node) {
            // Workaround for an IE9 rendering bug - https://github.com/SteveSanderson/knockout/issues/209
            if (ieVersion >= 9) {
                // For text nodes and comment nodes (most likely virtual elements), we will have to refresh the container
                var elem = node.nodeType == 1 ? node : node.parentNode;
                if (elem.style)
                    elem.style.zoom = elem.style.zoom;
            }
        },

        ensureSelectElementIsRenderedCorrectly: function(selectElement) {
            // Workaround for IE9 rendering bug - it doesn't reliably display all the text in dynamically-added select boxes unless you force it to re-render by updating the width.
            // (See https://github.com/SteveSanderson/knockout/issues/312, http://stackoverflow.com/questions/5908494/select-only-shows-first-char-of-selected-option)
            // Also fixes IE7 and IE8 bug that causes selects to be zero width if enclosed by 'if' or 'with'. (See issue #839)
            if (ieVersion) {
                var originalWidth = selectElement.style.width;
                selectElement.style.width = 0;
                selectElement.style.width = originalWidth;
            }
        },

        range: function (min, max) {
            min = ko.utils.unwrapObservable(min);
            max = ko.utils.unwrapObservable(max);
            var result = [];
            for (var i = min; i <= max; i++)
                result.push(i);
            return result;
        },

        makeArray: function(arrayLikeObject) {
            var result = [];
            for (var i = 0, j = arrayLikeObject.length; i < j; i++) {
                result.push(arrayLikeObject[i]);
            };
            return result;
        },

        createSymbolOrString: function(identifier) {
            return canUseSymbols ? Symbol(identifier) : identifier;
        },

        isIe6 : isIe6,
        isIe7 : isIe7,
        ieVersion : ieVersion,

        getFormFields: function(form, fieldName) {
            var fields = ko.utils.makeArray(form.getElementsByTagName("input")).concat(ko.utils.makeArray(form.getElementsByTagName("textarea")));
            var isMatchingField = (typeof fieldName == 'string')
                ? function(field) { return field.name === fieldName }
                : function(field) { return fieldName.test(field.name) }; // Treat fieldName as regex or object containing predicate
            var matches = [];
            for (var i = fields.length - 1; i >= 0; i--) {
                if (isMatchingField(fields[i]))
                    matches.push(fields[i]);
            };
            return matches;
        },

        parseJson: function (jsonString) {
            if (typeof jsonString == "string") {
                jsonString = ko.utils.stringTrim(jsonString);
                if (jsonString) {
                    if (JSON && JSON.parse) // Use native parsing where available
                        return JSON.parse(jsonString);
                    return (new Function("return " + jsonString))(); // Fallback on less safe parsing for older browsers
                }
            }
            return null;
        },

        stringifyJson: function (data, replacer, space) {   // replacer and space are optional
            if (!JSON || !JSON.stringify)
                throw new Error("Cannot find JSON.stringify(). Some browsers (e.g., IE < 8) don't support it natively, but you can overcome this by adding a script reference to json2.js, downloadable from http://www.json.org/json2.js");
            return JSON.stringify(ko.utils.unwrapObservable(data), replacer, space);
        },

        postJson: function (urlOrForm, data, options) {
            options = options || {};
            var params = options['params'] || {};
            var includeFields = options['includeFields'] || this.fieldsIncludedWithJsonPost;
            var url = urlOrForm;

            // If we were given a form, use its 'action' URL and pick out any requested field values
            if((typeof urlOrForm == 'object') && (ko.utils.tagNameLower(urlOrForm) === "form")) {
                var originalForm = urlOrForm;
                url = originalForm.action;
                for (var i = includeFields.length - 1; i >= 0; i--) {
                    var fields = ko.utils.getFormFields(originalForm, includeFields[i]);
                    for (var j = fields.length - 1; j >= 0; j--)
                        params[fields[j].name] = fields[j].value;
                }
            }

            data = ko.utils.unwrapObservable(data);
            var form = document.createElement("form");
            form.style.display = "none";
            form.action = url;
            form.method = "post";
            for (var key in data) {
                // Since 'data' this is a model object, we include all properties including those inherited from its prototype
                var input = document.createElement("input");
                input.type = "hidden";
                input.name = key;
                input.value = ko.utils.stringifyJson(ko.utils.unwrapObservable(data[key]));
                form.appendChild(input);
            }
            objectForEach(params, function(key, value) {
                var input = document.createElement("input");
                input.type = "hidden";
                input.name = key;
                input.value = value;
                form.appendChild(input);
            });
            document.body.appendChild(form);
            options['submitter'] ? options['submitter'](form) : form.submit();
            setTimeout(function () { form.parentNode.removeChild(form); }, 0);
        }
    }
}());

ko.exportSymbol('utils', ko.utils);
ko.exportSymbol('utils.arrayForEach', ko.utils.arrayForEach);
ko.exportSymbol('utils.arrayFirst', ko.utils.arrayFirst);
ko.exportSymbol('utils.arrayFilter', ko.utils.arrayFilter);
ko.exportSymbol('utils.arrayGetDistinctValues', ko.utils.arrayGetDistinctValues);
ko.exportSymbol('utils.arrayIndexOf', ko.utils.arrayIndexOf);
ko.exportSymbol('utils.arrayMap', ko.utils.arrayMap);
ko.exportSymbol('utils.arrayPushAll', ko.utils.arrayPushAll);
ko.exportSymbol('utils.arrayRemoveItem', ko.utils.arrayRemoveItem);
ko.exportSymbol('utils.extend', ko.utils.extend);
ko.exportSymbol('utils.fieldsIncludedWithJsonPost', ko.utils.fieldsIncludedWithJsonPost);
ko.exportSymbol('utils.getFormFields', ko.utils.getFormFields);
ko.exportSymbol('utils.peekObservable', ko.utils.peekObservable);
ko.exportSymbol('utils.postJson', ko.utils.postJson);
ko.exportSymbol('utils.parseJson', ko.utils.parseJson);
ko.exportSymbol('utils.registerEventHandler', ko.utils.registerEventHandler);
ko.exportSymbol('utils.stringifyJson', ko.utils.stringifyJson);
ko.exportSymbol('utils.range', ko.utils.range);
ko.exportSymbol('utils.toggleDomNodeCssClass', ko.utils.toggleDomNodeCssClass);
ko.exportSymbol('utils.triggerEvent', ko.utils.triggerEvent);
ko.exportSymbol('utils.unwrapObservable', ko.utils.unwrapObservable);
ko.exportSymbol('utils.objectForEach', ko.utils.objectForEach);
ko.exportSymbol('utils.addOrRemoveItem', ko.utils.addOrRemoveItem);
ko.exportSymbol('utils.setTextContent', ko.utils.setTextContent);
ko.exportSymbol('unwrap', ko.utils.unwrapObservable); // Convenient shorthand, because this is used so commonly

if (!Function.prototype['bind']) {
    // Function.prototype.bind is a standard part of ECMAScript 5th Edition (December 2009, http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-262.pdf)
    // In case the browser doesn't implement it natively, provide a JavaScript implementation. This implementation is based on the one in prototype.js
    Function.prototype['bind'] = function (object) {
        var originalFunction = this;
        if (arguments.length === 1) {
            return function () {
                return originalFunction.apply(object, arguments);
            };
        } else {
            var partialArgs = Array.prototype.slice.call(arguments, 1);
            return function () {
                var args = partialArgs.slice(0);
                args.push.apply(args, arguments);
                return originalFunction.apply(object, args);
            };
        }
    };
}

ko.utils.domData = new (function () {
    var uniqueId = 0;
    var dataStoreKeyExpandoPropertyName = "__ko__" + (new Date).getTime();
    var dataStore = {};

    function getAll(node, createIfNotFound) {
        var dataStoreKey = node[dataStoreKeyExpandoPropertyName];
        var hasExistingDataStore = dataStoreKey && (dataStoreKey !== "null") && dataStore[dataStoreKey];
        if (!hasExistingDataStore) {
            if (!createIfNotFound)
                return undefined;
            dataStoreKey = node[dataStoreKeyExpandoPropertyName] = "ko" + uniqueId++;
            dataStore[dataStoreKey] = {};
        }
        return dataStore[dataStoreKey];
    }

    return {
        get: function (node, key) {
            var allDataForNode = getAll(node, false);
            return allDataForNode === undefined ? undefined : allDataForNode[key];
        },
        set: function (node, key, value) {
            if (value === undefined) {
                // Make sure we don't actually create a new domData key if we are actually deleting a value
                if (getAll(node, false) === undefined)
                    return;
            }
            var allDataForNode = getAll(node, true);
            allDataForNode[key] = value;
        },
        clear: function (node) {
            var dataStoreKey = node[dataStoreKeyExpandoPropertyName];
            if (dataStoreKey) {
                delete dataStore[dataStoreKey];
                node[dataStoreKeyExpandoPropertyName] = null;
                return true; // Exposing "did clean" flag purely so specs can infer whether things have been cleaned up as intended
            }
            return false;
        },

        nextKey: function () {
            return (uniqueId++) + dataStoreKeyExpandoPropertyName;
        }
    };
})();

ko.exportSymbol('utils.domData', ko.utils.domData);
ko.exportSymbol('utils.domData.clear', ko.utils.domData.clear); // Exporting only so specs can clear up after themselves fully

ko.utils.domNodeDisposal = new (function () {
    var domDataKey = ko.utils.domData.nextKey();
    var cleanableNodeTypes = { 1: true, 8: true, 9: true };       // Element, Comment, Document
    var cleanableNodeTypesWithDescendants = { 1: true, 9: true }; // Element, Document

    function getDisposeCallbacksCollection(node, createIfNotFound) {
        var allDisposeCallbacks = ko.utils.domData.get(node, domDataKey);
        if ((allDisposeCallbacks === undefined) && createIfNotFound) {
            allDisposeCallbacks = [];
            ko.utils.domData.set(node, domDataKey, allDisposeCallbacks);
        }
        return allDisposeCallbacks;
    }
    function destroyCallbacksCollection(node) {
        ko.utils.domData.set(node, domDataKey, undefined);
    }

    function cleanSingleNode(node) {
        // Run all the dispose callbacks
        var callbacks = getDisposeCallbacksCollection(node, false);
        if (callbacks) {
            callbacks = callbacks.slice(0); // Clone, as the array may be modified during iteration (typically, callbacks will remove themselves)
            for (var i = 0; i < callbacks.length; i++)
                callbacks[i](node);
        }

        // Erase the DOM data
        ko.utils.domData.clear(node);

        // Perform cleanup needed by external libraries (currently only jQuery, but can be extended)
        ko.utils.domNodeDisposal["cleanExternalData"](node);

        // Clear any immediate-child comment nodes, as these wouldn't have been found by
        // node.getElementsByTagName("*") in cleanNode() (comment nodes aren't elements)
        if (cleanableNodeTypesWithDescendants[node.nodeType])
            cleanImmediateCommentTypeChildren(node);
    }

    function cleanImmediateCommentTypeChildren(nodeWithChildren) {
        var child, nextChild = nodeWithChildren.firstChild;
        while (child = nextChild) {
            nextChild = child.nextSibling;
            if (child.nodeType === 8)
                cleanSingleNode(child);
        }
    }

    return {
        addDisposeCallback : function(node, callback) {
            if (typeof callback != "function")
                throw new Error("Callback must be a function");
            getDisposeCallbacksCollection(node, true).push(callback);
        },

        removeDisposeCallback : function(node, callback) {
            var callbacksCollection = getDisposeCallbacksCollection(node, false);
            if (callbacksCollection) {
                ko.utils.arrayRemoveItem(callbacksCollection, callback);
                if (callbacksCollection.length == 0)
                    destroyCallbacksCollection(node);
            }
        },

        cleanNode : function(node) {
            // First clean this node, where applicable
            if (cleanableNodeTypes[node.nodeType]) {
                cleanSingleNode(node);

                // ... then its descendants, where applicable
                if (cleanableNodeTypesWithDescendants[node.nodeType]) {
                    // Clone the descendants list in case it changes during iteration
                    var descendants = [];
                    ko.utils.arrayPushAll(descendants, node.getElementsByTagName("*"));
                    for (var i = 0, j = descendants.length; i < j; i++)
                        cleanSingleNode(descendants[i]);
                }
            }
            return node;
        },

        removeNode : function(node) {
            ko.cleanNode(node);
            if (node.parentNode)
                node.parentNode.removeChild(node);
        },

        "cleanExternalData" : function (node) {
            // Special support for jQuery here because it's so commonly used.
            // Many jQuery plugins (including jquery.tmpl) store data using jQuery's equivalent of domData
            // so notify it to tear down any resources associated with the node & descendants here.
            if (jQueryInstance && (typeof jQueryInstance['cleanData'] == "function"))
                jQueryInstance['cleanData']([node]);
        }
    };
})();
ko.cleanNode = ko.utils.domNodeDisposal.cleanNode; // Shorthand name for convenience
ko.removeNode = ko.utils.domNodeDisposal.removeNode; // Shorthand name for convenience
ko.exportSymbol('cleanNode', ko.cleanNode);
ko.exportSymbol('removeNode', ko.removeNode);
ko.exportSymbol('utils.domNodeDisposal', ko.utils.domNodeDisposal);
ko.exportSymbol('utils.domNodeDisposal.addDisposeCallback', ko.utils.domNodeDisposal.addDisposeCallback);
ko.exportSymbol('utils.domNodeDisposal.removeDisposeCallback', ko.utils.domNodeDisposal.removeDisposeCallback);
(function () {
    var none = [0, "", ""],
        table = [1, "<table>", "</table>"],
        tbody = [2, "<table><tbody>", "</tbody></table>"],
        tr = [3, "<table><tbody><tr>", "</tr></tbody></table>"],
        select = [1, "<select multiple='multiple'>", "</select>"],
        lookup = {
            'thead': table,
            'tbody': table,
            'tfoot': table,
            'tr': tbody,
            'td': tr,
            'th': tr,
            'option': select,
            'optgroup': select
        },

        // This is needed for old IE if you're *not* using either jQuery or innerShiv. Doesn't affect other cases.
        mayRequireCreateElementHack = ko.utils.ieVersion <= 8;

    function getWrap(tags) {
        var m = tags.match(/^<([a-z]+)[ >]/);
        return (m && lookup[m[1]]) || none;
    }

    function simpleHtmlParse(html, documentContext) {
        documentContext || (documentContext = document);
        var windowContext = documentContext['parentWindow'] || documentContext['defaultView'] || window;

        // Based on jQuery's "clean" function, but only accounting for table-related elements.
        // If you have referenced jQuery, this won't be used anyway - KO will use jQuery's "clean" function directly

        // Note that there's still an issue in IE < 9 whereby it will discard comment nodes that are the first child of
        // a descendant node. For example: "<div><!-- mycomment -->abc</div>" will get parsed as "<div>abc</div>"
        // This won't affect anyone who has referenced jQuery, and there's always the workaround of inserting a dummy node
        // (possibly a text node) in front of the comment. So, KO does not attempt to workaround this IE issue automatically at present.

        // Trim whitespace, otherwise indexOf won't work as expected
        var tags = ko.utils.stringTrim(html).toLowerCase(), div = documentContext.createElement("div"),
            wrap = getWrap(tags),
            depth = wrap[0];

        // Go to html and back, then peel off extra wrappers
        // Note that we always prefix with some dummy text, because otherwise, IE<9 will strip out leading comment nodes in descendants. Total madness.
        var markup = "ignored<div>" + wrap[1] + html + wrap[2] + "</div>";
        if (typeof windowContext['innerShiv'] == "function") {
            // Note that innerShiv is deprecated in favour of html5shiv. We should consider adding
            // support for html5shiv (except if no explicit support is needed, e.g., if html5shiv
            // somehow shims the native APIs so it just works anyway)
            div.appendChild(windowContext['innerShiv'](markup));
        } else {
            if (mayRequireCreateElementHack) {
                // The document.createElement('my-element') trick to enable custom elements in IE6-8
                // only works if we assign innerHTML on an element associated with that document.
                documentContext.appendChild(div);
            }

            div.innerHTML = markup;

            if (mayRequireCreateElementHack) {
                div.parentNode.removeChild(div);
            }
        }

        // Move to the right depth
        while (depth--)
            div = div.lastChild;

        return ko.utils.makeArray(div.lastChild.childNodes);
    }

    function jQueryHtmlParse(html, documentContext) {
        // jQuery's "parseHTML" function was introduced in jQuery 1.8.0 and is a documented public API.
        if (jQueryInstance['parseHTML']) {
            return jQueryInstance['parseHTML'](html, documentContext) || []; // Ensure we always return an array and never null
        } else {
            // For jQuery < 1.8.0, we fall back on the undocumented internal "clean" function.
            var elems = jQueryInstance['clean']([html], documentContext);

            // As of jQuery 1.7.1, jQuery parses the HTML by appending it to some dummy parent nodes held in an in-memory document fragment.
            // Unfortunately, it never clears the dummy parent nodes from the document fragment, so it leaks memory over time.
            // Fix this by finding the top-most dummy parent element, and detaching it from its owner fragment.
            if (elems && elems[0]) {
                // Find the top-most parent element that's a direct child of a document fragment
                var elem = elems[0];
                while (elem.parentNode && elem.parentNode.nodeType !== 11 /* i.e., DocumentFragment */)
                    elem = elem.parentNode;
                // ... then detach it
                if (elem.parentNode)
                    elem.parentNode.removeChild(elem);
            }

            return elems;
        }
    }

    ko.utils.parseHtmlFragment = function(html, documentContext) {
        return jQueryInstance ?
            jQueryHtmlParse(html, documentContext) :   // As below, benefit from jQuery's optimisations where possible
            simpleHtmlParse(html, documentContext);  // ... otherwise, this simple logic will do in most common cases.
    };

    ko.utils.setHtml = function(node, html) {
        ko.utils.emptyDomNode(node);

        // There's no legitimate reason to display a stringified observable without unwrapping it, so we'll unwrap it
        html = ko.utils.unwrapObservable(html);

        if ((html !== null) && (html !== undefined)) {
            if (typeof html != 'string')
                html = html.toString();

            // jQuery contains a lot of sophisticated code to parse arbitrary HTML fragments,
            // for example <tr> elements which are not normally allowed to exist on their own.
            // If you've referenced jQuery we'll use that rather than duplicating its code.
            if (jQueryInstance) {
                jQueryInstance(node)['html'](html);
            } else {
                // ... otherwise, use KO's own parsing logic.
                var parsedNodes = ko.utils.parseHtmlFragment(html, node.ownerDocument);
                for (var i = 0; i < parsedNodes.length; i++)
                    node.appendChild(parsedNodes[i]);
            }
        }
    };
})();

ko.exportSymbol('utils.parseHtmlFragment', ko.utils.parseHtmlFragment);
ko.exportSymbol('utils.setHtml', ko.utils.setHtml);

ko.memoization = (function () {
    var memos = {};

    function randomMax8HexChars() {
        return (((1 + Math.random()) * 0x100000000) | 0).toString(16).substring(1);
    }
    function generateRandomId() {
        return randomMax8HexChars() + randomMax8HexChars();
    }
    function findMemoNodes(rootNode, appendToArray) {
        if (!rootNode)
            return;
        if (rootNode.nodeType == 8) {
            var memoId = ko.memoization.parseMemoText(rootNode.nodeValue);
            if (memoId != null)
                appendToArray.push({ domNode: rootNode, memoId: memoId });
        } else if (rootNode.nodeType == 1) {
            for (var i = 0, childNodes = rootNode.childNodes, j = childNodes.length; i < j; i++)
                findMemoNodes(childNodes[i], appendToArray);
        }
    }

    return {
        memoize: function (callback) {
            if (typeof callback != "function")
                throw new Error("You can only pass a function to ko.memoization.memoize()");
            var memoId = generateRandomId();
            memos[memoId] = callback;
            return "<!--[ko_memo:" + memoId + "]-->";
        },

        unmemoize: function (memoId, callbackParams) {
            var callback = memos[memoId];
            if (callback === undefined)
                throw new Error("Couldn't find any memo with ID " + memoId + ". Perhaps it's already been unmemoized.");
            try {
                callback.apply(null, callbackParams || []);
                return true;
            }
            finally { delete memos[memoId]; }
        },

        unmemoizeDomNodeAndDescendants: function (domNode, extraCallbackParamsArray) {
            var memos = [];
            findMemoNodes(domNode, memos);
            for (var i = 0, j = memos.length; i < j; i++) {
                var node = memos[i].domNode;
                var combinedParams = [node];
                if (extraCallbackParamsArray)
                    ko.utils.arrayPushAll(combinedParams, extraCallbackParamsArray);
                ko.memoization.unmemoize(memos[i].memoId, combinedParams);
                node.nodeValue = ""; // Neuter this node so we don't try to unmemoize it again
                if (node.parentNode)
                    node.parentNode.removeChild(node); // If possible, erase it totally (not always possible - someone else might just hold a reference to it then call unmemoizeDomNodeAndDescendants again)
            }
        },

        parseMemoText: function (memoText) {
            var match = memoText.match(/^\[ko_memo\:(.*?)\]$/);
            return match ? match[1] : null;
        }
    };
})();

ko.exportSymbol('memoization', ko.memoization);
ko.exportSymbol('memoization.memoize', ko.memoization.memoize);
ko.exportSymbol('memoization.unmemoize', ko.memoization.unmemoize);
ko.exportSymbol('memoization.parseMemoText', ko.memoization.parseMemoText);
ko.exportSymbol('memoization.unmemoizeDomNodeAndDescendants', ko.memoization.unmemoizeDomNodeAndDescendants);
ko.tasks = (function () {
    var scheduler,
        taskQueue = [],
        taskQueueLength = 0,
        nextHandle = 1,
        nextIndexToProcess = 0;

    if (window['MutationObserver']) {
        // Chrome 27+, Firefox 14+, IE 11+, Opera 15+, Safari 6.1+
        // From https://github.com/petkaantonov/bluebird * Copyright (c) 2014 Petka Antonov * License: MIT
        scheduler = (function (callback) {
            var div = document.createElement("div");
            new MutationObserver(callback).observe(div, {attributes: true});
            return function () { div.classList.toggle("foo"); };
        })(scheduledProcess);
    } else if (document && "onreadystatechange" in document.createElement("script")) {
        // IE 6-10
        // From https://github.com/YuzuJS/setImmediate * Copyright (c) 2012 Barnesandnoble.com, llc, Donavon West, and Domenic Denicola * License: MIT
        scheduler = function (callback) {
            var script = document.createElement("script");
            script.onreadystatechange = function () {
                script.onreadystatechange = null;
                document.documentElement.removeChild(script);
                script = null;
                callback();
            };
            document.documentElement.appendChild(script);
        };
    } else {
        scheduler = function (callback) {
            setTimeout(callback, 0);
        };
    }

    function processTasks() {
        if (taskQueueLength) {
            // Each mark represents the end of a logical group of tasks and the number of these groups is
            // limited to prevent unchecked recursion.
            var mark = taskQueueLength, countMarks = 0;

            // nextIndexToProcess keeps track of where we are in the queue; processTasks can be called recursively without issue
            for (var task; nextIndexToProcess < taskQueueLength; ) {
                if (task = taskQueue[nextIndexToProcess++]) {
                    if (nextIndexToProcess > mark) {
                        if (++countMarks >= 5000) {
                            nextIndexToProcess = taskQueueLength;   // skip all tasks remaining in the queue since any of them could be causing the recursion
                            ko.utils.deferError(Error("'Too much recursion' after processing " + countMarks + " task groups."));
                            break;
                        }
                        mark = taskQueueLength;
                    }
                    try {
                        task();
                    } catch (ex) {
                        ko.utils.deferError(ex);
                    }
                }
            }
        }
    }

    function scheduledProcess() {
        processTasks();

        // Reset the queue
        nextIndexToProcess = taskQueueLength = taskQueue.length = 0;
    }

    function scheduleTaskProcessing() {
        ko.tasks['scheduler'](scheduledProcess);
    }

    var tasks = {
        'scheduler': scheduler,     // Allow overriding the scheduler

        schedule: function (func) {
            if (!taskQueueLength) {
                scheduleTaskProcessing();
            }

            taskQueue[taskQueueLength++] = func;
            return nextHandle++;
        },

        cancel: function (handle) {
            var index = handle - (nextHandle - taskQueueLength);
            if (index >= nextIndexToProcess && index < taskQueueLength) {
                taskQueue[index] = null;
            }
        },

        // For testing only: reset the queue and return the previous queue length
        'resetForTesting': function () {
            var length = taskQueueLength - nextIndexToProcess;
            nextIndexToProcess = taskQueueLength = taskQueue.length = 0;
            return length;
        },

        runEarly: processTasks
    };

    return tasks;
})();

ko.exportSymbol('tasks', ko.tasks);
ko.exportSymbol('tasks.schedule', ko.tasks.schedule);
//ko.exportSymbol('tasks.cancel', ko.tasks.cancel);  "cancel" isn't minified
ko.exportSymbol('tasks.runEarly', ko.tasks.runEarly);
ko.extenders = {
    'throttle': function(target, timeout) {
        // Throttling means two things:

        // (1) For dependent observables, we throttle *evaluations* so that, no matter how fast its dependencies
        //     notify updates, the target doesn't re-evaluate (and hence doesn't notify) faster than a certain rate
        target['throttleEvaluation'] = timeout;

        // (2) For writable targets (observables, or writable dependent observables), we throttle *writes*
        //     so the target cannot change value synchronously or faster than a certain rate
        var writeTimeoutInstance = null;
        return ko.dependentObservable({
            'read': target,
            'write': function(value) {
                clearTimeout(writeTimeoutInstance);
                writeTimeoutInstance = ko.utils.setTimeout(function() {
                    target(value);
                }, timeout);
            }
        });
    },

    'rateLimit': function(target, options) {
        var timeout, method, limitFunction;

        if (typeof options == 'number') {
            timeout = options;
        } else {
            timeout = options['timeout'];
            method = options['method'];
        }

        // rateLimit supersedes deferred updates
        target._deferUpdates = false;

        limitFunction = method == 'notifyWhenChangesStop' ?  debounce : throttle;
        target.limit(function(callback) {
            return limitFunction(callback, timeout);
        });
    },

    'deferred': function(target, options) {
        if (options !== true) {
            throw new Error('The \'deferred\' extender only accepts the value \'true\', because it is not supported to turn deferral off once enabled.')
        }

        if (!target._deferUpdates) {
            target._deferUpdates = true;
            target.limit(function (callback) {
                var handle;
                return function () {
                    ko.tasks.cancel(handle);
                    handle = ko.tasks.schedule(callback);
                    target['notifySubscribers'](undefined, 'dirty');
                };
            });
        }
    },

    'notify': function(target, notifyWhen) {
        target["equalityComparer"] = notifyWhen == "always" ?
            null :  // null equalityComparer means to always notify
            valuesArePrimitiveAndEqual;
    }
};

var primitiveTypes = { 'undefined':1, 'boolean':1, 'number':1, 'string':1 };
function valuesArePrimitiveAndEqual(a, b) {
    var oldValueIsPrimitive = (a === null) || (typeof(a) in primitiveTypes);
    return oldValueIsPrimitive ? (a === b) : false;
}

function throttle(callback, timeout) {
    var timeoutInstance;
    return function () {
        if (!timeoutInstance) {
            timeoutInstance = ko.utils.setTimeout(function () {
                timeoutInstance = undefined;
                callback();
            }, timeout);
        }
    };
}

function debounce(callback, timeout) {
    var timeoutInstance;
    return function () {
        clearTimeout(timeoutInstance);
        timeoutInstance = ko.utils.setTimeout(callback, timeout);
    };
}

function applyExtenders(requestedExtenders) {
    var target = this;
    if (requestedExtenders) {
        ko.utils.objectForEach(requestedExtenders, function(key, value) {
            var extenderHandler = ko.extenders[key];
            if (typeof extenderHandler == 'function') {
                target = extenderHandler(target, value) || target;
            }
        });
    }
    return target;
}

ko.exportSymbol('extenders', ko.extenders);

ko.subscription = function (target, callback, disposeCallback) {
    this._target = target;
    this.callback = callback;
    this.disposeCallback = disposeCallback;
    this.isDisposed = false;
    ko.exportProperty(this, 'dispose', this.dispose);
};
ko.subscription.prototype.dispose = function () {
    this.isDisposed = true;
    this.disposeCallback();
};

ko.subscribable = function () {
    ko.utils.setPrototypeOfOrExtend(this, ko_subscribable_fn);
    ko_subscribable_fn.init(this);
}

var defaultEvent = "change";

// Moved out of "limit" to avoid the extra closure
function limitNotifySubscribers(value, event) {
    if (!event || event === defaultEvent) {
        this._limitChange(value);
    } else if (event === 'beforeChange') {
        this._limitBeforeChange(value);
    } else {
        this._origNotifySubscribers(value, event);
    }
}

var ko_subscribable_fn = {
    init: function(instance) {
        instance._subscriptions = {};
        instance._versionNumber = 1;
    },

    subscribe: function (callback, callbackTarget, event) {
        var self = this;

        event = event || defaultEvent;
        var boundCallback = callbackTarget ? callback.bind(callbackTarget) : callback;

        var subscription = new ko.subscription(self, boundCallback, function () {
            ko.utils.arrayRemoveItem(self._subscriptions[event], subscription);
            if (self.afterSubscriptionRemove)
                self.afterSubscriptionRemove(event);
        });

        if (self.beforeSubscriptionAdd)
            self.beforeSubscriptionAdd(event);

        if (!self._subscriptions[event])
            self._subscriptions[event] = [];
        self._subscriptions[event].push(subscription);

        return subscription;
    },

    "notifySubscribers": function (valueToNotify, event) {
        event = event || defaultEvent;
        if (event === defaultEvent) {
            this.updateVersion();
        }
        if (this.hasSubscriptionsForEvent(event)) {
            try {
                ko.dependencyDetection.begin(); // Begin suppressing dependency detection (by setting the top frame to undefined)
                for (var a = this._subscriptions[event].slice(0), i = 0, subscription; subscription = a[i]; ++i) {
                    // In case a subscription was disposed during the arrayForEach cycle, check
                    // for isDisposed on each subscription before invoking its callback
                    if (!subscription.isDisposed)
                        subscription.callback(valueToNotify);
                }
            } finally {
                ko.dependencyDetection.end(); // End suppressing dependency detection
            }
        }
    },

    getVersion: function () {
        return this._versionNumber;
    },

    hasChanged: function (versionToCheck) {
        return this.getVersion() !== versionToCheck;
    },

    updateVersion: function () {
        ++this._versionNumber;
    },

    limit: function(limitFunction) {
        var self = this, selfIsObservable = ko.isObservable(self),
            ignoreBeforeChange, previousValue, pendingValue, beforeChange = 'beforeChange';

        if (!self._origNotifySubscribers) {
            self._origNotifySubscribers = self["notifySubscribers"];
            self["notifySubscribers"] = limitNotifySubscribers;
        }

        var finish = limitFunction(function() {
            self._notificationIsPending = false;

            // If an observable provided a reference to itself, access it to get the latest value.
            // This allows computed observables to delay calculating their value until needed.
            if (selfIsObservable && pendingValue === self) {
                pendingValue = self();
            }
            ignoreBeforeChange = false;
            if (self.isDifferent(previousValue, pendingValue)) {
                self._origNotifySubscribers(previousValue = pendingValue);
            }
        });

        self._limitChange = function(value) {
            self._notificationIsPending = ignoreBeforeChange = true;
            pendingValue = value;
            finish();
        };
        self._limitBeforeChange = function(value) {
            if (!ignoreBeforeChange) {
                previousValue = value;
                self._origNotifySubscribers(value, beforeChange);
            }
        };
    },

    hasSubscriptionsForEvent: function(event) {
        return this._subscriptions[event] && this._subscriptions[event].length;
    },

    getSubscriptionsCount: function (event) {
        if (event) {
            return this._subscriptions[event] && this._subscriptions[event].length || 0;
        } else {
            var total = 0;
            ko.utils.objectForEach(this._subscriptions, function(eventName, subscriptions) {
                if (eventName !== 'dirty')
                    total += subscriptions.length;
            });
            return total;
        }
    },

    isDifferent: function(oldValue, newValue) {
        return !this['equalityComparer'] || !this['equalityComparer'](oldValue, newValue);
    },

    extend: applyExtenders
};

ko.exportProperty(ko_subscribable_fn, 'subscribe', ko_subscribable_fn.subscribe);
ko.exportProperty(ko_subscribable_fn, 'extend', ko_subscribable_fn.extend);
ko.exportProperty(ko_subscribable_fn, 'getSubscriptionsCount', ko_subscribable_fn.getSubscriptionsCount);

// For browsers that support proto assignment, we overwrite the prototype of each
// observable instance. Since observables are functions, we need Function.prototype
// to still be in the prototype chain.
if (ko.utils.canSetPrototype) {
    ko.utils.setPrototypeOf(ko_subscribable_fn, Function.prototype);
}

ko.subscribable['fn'] = ko_subscribable_fn;


ko.isSubscribable = function (instance) {
    return instance != null && typeof instance.subscribe == "function" && typeof instance["notifySubscribers"] == "function";
};

ko.exportSymbol('subscribable', ko.subscribable);
ko.exportSymbol('isSubscribable', ko.isSubscribable);

ko.computedContext = ko.dependencyDetection = (function () {
    var outerFrames = [],
        currentFrame,
        lastId = 0;

    // Return a unique ID that can be assigned to an observable for dependency tracking.
    // Theoretically, you could eventually overflow the number storage size, resulting
    // in duplicate IDs. But in JavaScript, the largest exact integral value is 2^53
    // or 9,007,199,254,740,992. If you created 1,000,000 IDs per second, it would
    // take over 285 years to reach that number.
    // Reference http://blog.vjeux.com/2010/javascript/javascript-max_int-number-limits.html
    function getId() {
        return ++lastId;
    }

    function begin(options) {
        outerFrames.push(currentFrame);
        currentFrame = options;
    }

    function end() {
        currentFrame = outerFrames.pop();
    }

    return {
        begin: begin,

        end: end,

        registerDependency: function (subscribable) {
            if (currentFrame) {
                if (!ko.isSubscribable(subscribable))
                    throw new Error("Only subscribable things can act as dependencies");
                currentFrame.callback.call(currentFrame.callbackTarget, subscribable, subscribable._id || (subscribable._id = getId()));
            }
        },

        ignore: function (callback, callbackTarget, callbackArgs) {
            try {
                begin();
                return callback.apply(callbackTarget, callbackArgs || []);
            } finally {
                end();
            }
        },

        getDependenciesCount: function () {
            if (currentFrame)
                return currentFrame.computed.getDependenciesCount();
        },

        isInitial: function() {
            if (currentFrame)
                return currentFrame.isInitial;
        }
    };
})();

ko.exportSymbol('computedContext', ko.computedContext);
ko.exportSymbol('computedContext.getDependenciesCount', ko.computedContext.getDependenciesCount);
ko.exportSymbol('computedContext.isInitial', ko.computedContext.isInitial);

ko.exportSymbol('ignoreDependencies', ko.ignoreDependencies = ko.dependencyDetection.ignore);
var observableLatestValue = ko.utils.createSymbolOrString('_latestValue');

ko.observable = function (initialValue) {
    function observable() {
        if (arguments.length > 0) {
            // Write

            // Ignore writes if the value hasn't changed
            if (observable.isDifferent(observable[observableLatestValue], arguments[0])) {
                observable.valueWillMutate();
                observable[observableLatestValue] = arguments[0];
                observable.valueHasMutated();
            }
            return this; // Permits chained assignments
        }
        else {
            // Read
            ko.dependencyDetection.registerDependency(observable); // The caller only needs to be notified of changes if they did a "read" operation
            return observable[observableLatestValue];
        }
    }

    observable[observableLatestValue] = initialValue;

    // Inherit from 'subscribable'
    if (!ko.utils.canSetPrototype) {
        // 'subscribable' won't be on the prototype chain unless we put it there directly
        ko.utils.extend(observable, ko.subscribable['fn']);
    }
    ko.subscribable['fn'].init(observable);

    // Inherit from 'observable'
    ko.utils.setPrototypeOfOrExtend(observable, observableFn);

    if (ko.options['deferUpdates']) {
        ko.extenders['deferred'](observable, true);
    }

    return observable;
}

// Define prototype for observables
var observableFn = {
    'equalityComparer': valuesArePrimitiveAndEqual,
    peek: function() { return this[observableLatestValue]; },
    valueHasMutated: function () { this['notifySubscribers'](this[observableLatestValue]); },
    valueWillMutate: function () { this['notifySubscribers'](this[observableLatestValue], 'beforeChange'); }
};

// Note that for browsers that don't support proto assignment, the
// inheritance chain is created manually in the ko.observable constructor
if (ko.utils.canSetPrototype) {
    ko.utils.setPrototypeOf(observableFn, ko.subscribable['fn']);
}

var protoProperty = ko.observable.protoProperty = '__ko_proto__';
observableFn[protoProperty] = ko.observable;

ko.hasPrototype = function(instance, prototype) {
    if ((instance === null) || (instance === undefined) || (instance[protoProperty] === undefined)) return false;
    if (instance[protoProperty] === prototype) return true;
    return ko.hasPrototype(instance[protoProperty], prototype); // Walk the prototype chain
};

ko.isObservable = function (instance) {
    return ko.hasPrototype(instance, ko.observable);
}
ko.isWriteableObservable = function (instance) {
    // Observable
    if ((typeof instance == 'function') && instance[protoProperty] === ko.observable)
        return true;
    // Writeable dependent observable
    if ((typeof instance == 'function') && (instance[protoProperty] === ko.dependentObservable) && (instance.hasWriteFunction))
        return true;
    // Anything else
    return false;
}

ko.exportSymbol('observable', ko.observable);
ko.exportSymbol('isObservable', ko.isObservable);
ko.exportSymbol('isWriteableObservable', ko.isWriteableObservable);
ko.exportSymbol('isWritableObservable', ko.isWriteableObservable);
ko.exportSymbol('observable.fn', observableFn);
ko.exportProperty(observableFn, 'peek', observableFn.peek);
ko.exportProperty(observableFn, 'valueHasMutated', observableFn.valueHasMutated);
ko.exportProperty(observableFn, 'valueWillMutate', observableFn.valueWillMutate);
ko.observableArray = function (initialValues) {
    initialValues = initialValues || [];

    if (typeof initialValues != 'object' || !('length' in initialValues))
        throw new Error("The argument passed when initializing an observable array must be an array, or null, or undefined.");

    var result = ko.observable(initialValues);
    ko.utils.setPrototypeOfOrExtend(result, ko.observableArray['fn']);
    return result.extend({'trackArrayChanges':true});
};

ko.observableArray['fn'] = {
    'remove': function (valueOrPredicate) {
        var underlyingArray = this.peek();
        var removedValues = [];
        var predicate = typeof valueOrPredicate == "function" && !ko.isObservable(valueOrPredicate) ? valueOrPredicate : function (value) { return value === valueOrPredicate; };
        for (var i = 0; i < underlyingArray.length; i++) {
            var value = underlyingArray[i];
            if (predicate(value)) {
                if (removedValues.length === 0) {
                    this.valueWillMutate();
                }
                removedValues.push(value);
                underlyingArray.splice(i, 1);
                i--;
            }
        }
        if (removedValues.length) {
            this.valueHasMutated();
        }
        return removedValues;
    },

    'removeAll': function (arrayOfValues) {
        // If you passed zero args, we remove everything
        if (arrayOfValues === undefined) {
            var underlyingArray = this.peek();
            var allValues = underlyingArray.slice(0);
            this.valueWillMutate();
            underlyingArray.splice(0, underlyingArray.length);
            this.valueHasMutated();
            return allValues;
        }
        // If you passed an arg, we interpret it as an array of entries to remove
        if (!arrayOfValues)
            return [];
        return this['remove'](function (value) {
            return ko.utils.arrayIndexOf(arrayOfValues, value) >= 0;
        });
    },

    'destroy': function (valueOrPredicate) {
        var underlyingArray = this.peek();
        var predicate = typeof valueOrPredicate == "function" && !ko.isObservable(valueOrPredicate) ? valueOrPredicate : function (value) { return value === valueOrPredicate; };
        this.valueWillMutate();
        for (var i = underlyingArray.length - 1; i >= 0; i--) {
            var value = underlyingArray[i];
            if (predicate(value))
                underlyingArray[i]["_destroy"] = true;
        }
        this.valueHasMutated();
    },

    'destroyAll': function (arrayOfValues) {
        // If you passed zero args, we destroy everything
        if (arrayOfValues === undefined)
            return this['destroy'](function() { return true });

        // If you passed an arg, we interpret it as an array of entries to destroy
        if (!arrayOfValues)
            return [];
        return this['destroy'](function (value) {
            return ko.utils.arrayIndexOf(arrayOfValues, value) >= 0;
        });
    },

    'indexOf': function (item) {
        var underlyingArray = this();
        return ko.utils.arrayIndexOf(underlyingArray, item);
    },

    'replace': function(oldItem, newItem) {
        var index = this['indexOf'](oldItem);
        if (index >= 0) {
            this.valueWillMutate();
            this.peek()[index] = newItem;
            this.valueHasMutated();
        }
    }
};

// Note that for browsers that don't support proto assignment, the
// inheritance chain is created manually in the ko.observableArray constructor
if (ko.utils.canSetPrototype) {
    ko.utils.setPrototypeOf(ko.observableArray['fn'], ko.observable['fn']);
}

// Populate ko.observableArray.fn with read/write functions from native arrays
// Important: Do not add any additional functions here that may reasonably be used to *read* data from the array
// because we'll eval them without causing subscriptions, so ko.computed output could end up getting stale
ko.utils.arrayForEach(["pop", "push", "reverse", "shift", "sort", "splice", "unshift"], function (methodName) {
    ko.observableArray['fn'][methodName] = function () {
        // Use "peek" to avoid creating a subscription in any computed that we're executing in the context of
        // (for consistency with mutating regular observables)
        var underlyingArray = this.peek();
        this.valueWillMutate();
        this.cacheDiffForKnownOperation(underlyingArray, methodName, arguments);
        var methodCallResult = underlyingArray[methodName].apply(underlyingArray, arguments);
        this.valueHasMutated();
        // The native sort and reverse methods return a reference to the array, but it makes more sense to return the observable array instead.
        return methodCallResult === underlyingArray ? this : methodCallResult;
    };
});

// Populate ko.observableArray.fn with read-only functions from native arrays
ko.utils.arrayForEach(["slice"], function (methodName) {
    ko.observableArray['fn'][methodName] = function () {
        var underlyingArray = this();
        return underlyingArray[methodName].apply(underlyingArray, arguments);
    };
});

ko.exportSymbol('observableArray', ko.observableArray);
var arrayChangeEventName = 'arrayChange';
ko.extenders['trackArrayChanges'] = function(target, options) {
    // Use the provided options--each call to trackArrayChanges overwrites the previously set options
    target.compareArrayOptions = {};
    if (options && typeof options == "object") {
        ko.utils.extend(target.compareArrayOptions, options);
    }
    target.compareArrayOptions['sparse'] = true;

    // Only modify the target observable once
    if (target.cacheDiffForKnownOperation) {
        return;
    }
    var trackingChanges = false,
        cachedDiff = null,
        arrayChangeSubscription,
        pendingNotifications = 0,
        underlyingNotifySubscribersFunction,
        underlyingBeforeSubscriptionAddFunction = target.beforeSubscriptionAdd,
        underlyingAfterSubscriptionRemoveFunction = target.afterSubscriptionRemove;

    // Watch "subscribe" calls, and for array change events, ensure change tracking is enabled
    target.beforeSubscriptionAdd = function (event) {
        if (underlyingBeforeSubscriptionAddFunction)
            underlyingBeforeSubscriptionAddFunction.call(target, event);
        if (event === arrayChangeEventName) {
            trackChanges();
        }
    };
    // Watch "dispose" calls, and for array change events, ensure change tracking is disabled when all are disposed
    target.afterSubscriptionRemove = function (event) {
        if (underlyingAfterSubscriptionRemoveFunction)
            underlyingAfterSubscriptionRemoveFunction.call(target, event);
        if (event === arrayChangeEventName && !target.hasSubscriptionsForEvent(arrayChangeEventName)) {
            if (underlyingNotifySubscribersFunction) {
                target['notifySubscribers'] = underlyingNotifySubscribersFunction;
                underlyingNotifySubscribersFunction = undefined;
            }
            arrayChangeSubscription.dispose();
            trackingChanges = false;
        }
    };

    function trackChanges() {
        // Calling 'trackChanges' multiple times is the same as calling it once
        if (trackingChanges) {
            return;
        }

        trackingChanges = true;

        // Intercept "notifySubscribers" to track how many times it was called.
        underlyingNotifySubscribersFunction = target['notifySubscribers'];
        target['notifySubscribers'] = function(valueToNotify, event) {
            if (!event || event === defaultEvent) {
                ++pendingNotifications;
            }
            return underlyingNotifySubscribersFunction.apply(this, arguments);
        };

        // Each time the array changes value, capture a clone so that on the next
        // change it's possible to produce a diff
        var previousContents = [].concat(target.peek() || []);
        cachedDiff = null;
        arrayChangeSubscription = target.subscribe(function(currentContents) {
            // Make a copy of the current contents and ensure it's an array
            currentContents = [].concat(currentContents || []);

            // Compute the diff and issue notifications, but only if someone is listening
            if (target.hasSubscriptionsForEvent(arrayChangeEventName)) {
                var changes = getChanges(previousContents, currentContents);
            }

            // Eliminate references to the old, removed items, so they can be GCed
            previousContents = currentContents;
            cachedDiff = null;
            pendingNotifications = 0;

            if (changes && changes.length) {
                target['notifySubscribers'](changes, arrayChangeEventName);
            }
        });
    }

    function getChanges(previousContents, currentContents) {
        // We try to re-use cached diffs.
        // The scenarios where pendingNotifications > 1 are when using rate-limiting or the Deferred Updates
        // plugin, which without this check would not be compatible with arrayChange notifications. Normally,
        // notifications are issued immediately so we wouldn't be queueing up more than one.
        if (!cachedDiff || pendingNotifications > 1) {
            cachedDiff = ko.utils.compareArrays(previousContents, currentContents, target.compareArrayOptions);
        }

        return cachedDiff;
    }

    target.cacheDiffForKnownOperation = function(rawArray, operationName, args) {
        // Only run if we're currently tracking changes for this observable array
        // and there aren't any pending deferred notifications.
        if (!trackingChanges || pendingNotifications) {
            return;
        }
        var diff = [],
            arrayLength = rawArray.length,
            argsLength = args.length,
            offset = 0;

        function pushDiff(status, value, index) {
            return diff[diff.length] = { 'status': status, 'value': value, 'index': index };
        }
        switch (operationName) {
            case 'push':
                offset = arrayLength;
            case 'unshift':
                for (var index = 0; index < argsLength; index++) {
                    pushDiff('added', args[index], offset + index);
                }
                break;

            case 'pop':
                offset = arrayLength - 1;
            case 'shift':
                if (arrayLength) {
                    pushDiff('deleted', rawArray[offset], offset);
                }
                break;

            case 'splice':
                // Negative start index means 'from end of array'. After that we clamp to [0...arrayLength].
                // See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/splice
                var startIndex = Math.min(Math.max(0, args[0] < 0 ? arrayLength + args[0] : args[0]), arrayLength),
                    endDeleteIndex = argsLength === 1 ? arrayLength : Math.min(startIndex + (args[1] || 0), arrayLength),
                    endAddIndex = startIndex + argsLength - 2,
                    endIndex = Math.max(endDeleteIndex, endAddIndex),
                    additions = [], deletions = [];
                for (var index = startIndex, argsIndex = 2; index < endIndex; ++index, ++argsIndex) {
                    if (index < endDeleteIndex)
                        deletions.push(pushDiff('deleted', rawArray[index], index));
                    if (index < endAddIndex)
                        additions.push(pushDiff('added', args[argsIndex], index));
                }
                ko.utils.findMovesInArrayComparison(deletions, additions);
                break;

            default:
                return;
        }
        cachedDiff = diff;
    };
};
var computedState = ko.utils.createSymbolOrString('_state');

ko.computed = ko.dependentObservable = function (evaluatorFunctionOrOptions, evaluatorFunctionTarget, options) {
    if (typeof evaluatorFunctionOrOptions === "object") {
        // Single-parameter syntax - everything is on this "options" param
        options = evaluatorFunctionOrOptions;
    } else {
        // Multi-parameter syntax - construct the options according to the params passed
        options = options || {};
        if (evaluatorFunctionOrOptions) {
            options["read"] = evaluatorFunctionOrOptions;
        }
    }
    if (typeof options["read"] != "function")
        throw Error("Pass a function that returns the value of the ko.computed");

    var writeFunction = options["write"];
    var state = {
        latestValue: undefined,
        isStale: true,
        isBeingEvaluated: false,
        suppressDisposalUntilDisposeWhenReturnsFalse: false,
        isDisposed: false,
        pure: false,
        isSleeping: false,
        readFunction: options["read"],
        evaluatorFunctionTarget: evaluatorFunctionTarget || options["owner"],
        disposeWhenNodeIsRemoved: options["disposeWhenNodeIsRemoved"] || options.disposeWhenNodeIsRemoved || null,
        disposeWhen: options["disposeWhen"] || options.disposeWhen,
        domNodeDisposalCallback: null,
        dependencyTracking: {},
        dependenciesCount: 0,
        evaluationTimeoutInstance: null
    };

    function computedObservable() {
        if (arguments.length > 0) {
            if (typeof writeFunction === "function") {
                // Writing a value
                writeFunction.apply(state.evaluatorFunctionTarget, arguments);
            } else {
                throw new Error("Cannot write a value to a ko.computed unless you specify a 'write' option. If you wish to read the current value, don't pass any parameters.");
            }
            return this; // Permits chained assignments
        } else {
            // Reading the value
            ko.dependencyDetection.registerDependency(computedObservable);
            if (state.isStale || (state.isSleeping && computedObservable.haveDependenciesChanged())) {
                computedObservable.evaluateImmediate();
            }
            return state.latestValue;
        }
    }

    computedObservable[computedState] = state;
    computedObservable.hasWriteFunction = typeof writeFunction === "function";

    // Inherit from 'subscribable'
    if (!ko.utils.canSetPrototype) {
        // 'subscribable' won't be on the prototype chain unless we put it there directly
        ko.utils.extend(computedObservable, ko.subscribable['fn']);
    }
    ko.subscribable['fn'].init(computedObservable);

    // Inherit from 'computed'
    ko.utils.setPrototypeOfOrExtend(computedObservable, computedFn);

    if (options['pure']) {
        state.pure = true;
        state.isSleeping = true;     // Starts off sleeping; will awake on the first subscription
        ko.utils.extend(computedObservable, pureComputedOverrides);
    } else if (options['deferEvaluation']) {
        ko.utils.extend(computedObservable, deferEvaluationOverrides);
    }

    if (ko.options['deferUpdates']) {
        ko.extenders['deferred'](computedObservable, true);
    }

    if (DEBUG) {
        // #1731 - Aid debugging by exposing the computed's options
        computedObservable["_options"] = options;
    }

    if (state.disposeWhenNodeIsRemoved) {
        // Since this computed is associated with a DOM node, and we don't want to dispose the computed
        // until the DOM node is *removed* from the document (as opposed to never having been in the document),
        // we'll prevent disposal until "disposeWhen" first returns false.
        state.suppressDisposalUntilDisposeWhenReturnsFalse = true;

        // disposeWhenNodeIsRemoved: true can be used to opt into the "only dispose after first false result"
        // behaviour even if there's no specific node to watch. In that case, clear the option so we don't try
        // to watch for a non-node's disposal. This technique is intended for KO's internal use only and shouldn't
        // be documented or used by application code, as it's likely to change in a future version of KO.
        if (!state.disposeWhenNodeIsRemoved.nodeType) {
            state.disposeWhenNodeIsRemoved = null;
        }
    }

    // Evaluate, unless sleeping or deferEvaluation is true
    if (!state.isSleeping && !options['deferEvaluation']) {
        computedObservable.evaluateImmediate();
    }

    // Attach a DOM node disposal callback so that the computed will be proactively disposed as soon as the node is
    // removed using ko.removeNode. But skip if isActive is false (there will never be any dependencies to dispose).
    if (state.disposeWhenNodeIsRemoved && computedObservable.isActive()) {
        ko.utils.domNodeDisposal.addDisposeCallback(state.disposeWhenNodeIsRemoved, state.domNodeDisposalCallback = function () {
            computedObservable.dispose();
        });
    }

    return computedObservable;
};

// Utility function that disposes a given dependencyTracking entry
function computedDisposeDependencyCallback(id, entryToDispose) {
    if (entryToDispose !== null && entryToDispose.dispose) {
        entryToDispose.dispose();
    }
}

// This function gets called each time a dependency is detected while evaluating a computed.
// It's factored out as a shared function to avoid creating unnecessary function instances during evaluation.
function computedBeginDependencyDetectionCallback(subscribable, id) {
    var computedObservable = this.computedObservable,
        state = computedObservable[computedState];
    if (!state.isDisposed) {
        if (this.disposalCount && this.disposalCandidates[id]) {
            // Don't want to dispose this subscription, as it's still being used
            computedObservable.addDependencyTracking(id, subscribable, this.disposalCandidates[id]);
            this.disposalCandidates[id] = null; // No need to actually delete the property - disposalCandidates is a transient object anyway
            --this.disposalCount;
        } else if (!state.dependencyTracking[id]) {
            // Brand new subscription - add it
            computedObservable.addDependencyTracking(id, subscribable, state.isSleeping ? { _target: subscribable } : computedObservable.subscribeToDependency(subscribable));
        }
    }
}

var computedFn = {
    "equalityComparer": valuesArePrimitiveAndEqual,
    getDependenciesCount: function () {
        return this[computedState].dependenciesCount;
    },
    addDependencyTracking: function (id, target, trackingObj) {
        if (this[computedState].pure && target === this) {
            throw Error("A 'pure' computed must not be called recursively");
        }

        this[computedState].dependencyTracking[id] = trackingObj;
        trackingObj._order = this[computedState].dependenciesCount++;
        trackingObj._version = target.getVersion();
    },
    haveDependenciesChanged: function () {
        var id, dependency, dependencyTracking = this[computedState].dependencyTracking;
        for (id in dependencyTracking) {
            if (dependencyTracking.hasOwnProperty(id)) {
                dependency = dependencyTracking[id];
                if (dependency._target.hasChanged(dependency._version)) {
                    return true;
                }
            }
        }
    },
    markDirty: function () {
        // Process "dirty" events if we can handle delayed notifications
        if (this._evalDelayed && !this[computedState].isBeingEvaluated) {
            this._evalDelayed();
        }
    },
    isActive: function () {
        return this[computedState].isStale || this[computedState].dependenciesCount > 0;
    },
    respondToChange: function () {
        // Ignore "change" events if we've already scheduled a delayed notification
        if (!this._notificationIsPending) {
            this.evaluatePossiblyAsync();
        }
    },
    subscribeToDependency: function (target) {
        if (target._deferUpdates && !this[computedState].disposeWhenNodeIsRemoved) {
            var dirtySub = target.subscribe(this.markDirty, this, 'dirty'),
                changeSub = target.subscribe(this.respondToChange, this);
            return {
                _target: target,
                dispose: function () {
                    dirtySub.dispose();
                    changeSub.dispose();
                }
            };
        } else {
            return target.subscribe(this.evaluatePossiblyAsync, this);
        }
    },
    evaluatePossiblyAsync: function () {
        var computedObservable = this,
            throttleEvaluationTimeout = computedObservable['throttleEvaluation'];
        if (throttleEvaluationTimeout && throttleEvaluationTimeout >= 0) {
            clearTimeout(this[computedState].evaluationTimeoutInstance);
            this[computedState].evaluationTimeoutInstance = ko.utils.setTimeout(function () {
                computedObservable.evaluateImmediate(true /*notifyChange*/);
            }, throttleEvaluationTimeout);
        } else if (computedObservable._evalDelayed) {
            computedObservable._evalDelayed();
        } else {
            computedObservable.evaluateImmediate(true /*notifyChange*/);
        }
    },
    evaluateImmediate: function (notifyChange) {
        var computedObservable = this,
            state = computedObservable[computedState],
            disposeWhen = state.disposeWhen,
            changed = false;

        if (state.isBeingEvaluated) {
            // If the evaluation of a ko.computed causes side effects, it's possible that it will trigger its own re-evaluation.
            // This is not desirable (it's hard for a developer to realise a chain of dependencies might cause this, and they almost
            // certainly didn't intend infinite re-evaluations). So, for predictability, we simply prevent ko.computeds from causing
            // their own re-evaluation. Further discussion at https://github.com/SteveSanderson/knockout/pull/387
            return;
        }

        // Do not evaluate (and possibly capture new dependencies) if disposed
        if (state.isDisposed) {
            return;
        }

        if (state.disposeWhenNodeIsRemoved && !ko.utils.domNodeIsAttachedToDocument(state.disposeWhenNodeIsRemoved) || disposeWhen && disposeWhen()) {
            // See comment above about suppressDisposalUntilDisposeWhenReturnsFalse
            if (!state.suppressDisposalUntilDisposeWhenReturnsFalse) {
                computedObservable.dispose();
                return;
            }
        } else {
            // It just did return false, so we can stop suppressing now
            state.suppressDisposalUntilDisposeWhenReturnsFalse = false;
        }

        state.isBeingEvaluated = true;
        try {
            changed = this.evaluateImmediate_CallReadWithDependencyDetection(notifyChange);
        } finally {
            state.isBeingEvaluated = false;
        }

        if (!state.dependenciesCount) {
            computedObservable.dispose();
        }

        return changed;
    },
    evaluateImmediate_CallReadWithDependencyDetection: function (notifyChange) {
        // This function is really just part of the evaluateImmediate logic. You would never call it from anywhere else.
        // Factoring it out into a separate function means it can be independent of the try/catch block in evaluateImmediate,
        // which contributes to saving about 40% off the CPU overhead of computed evaluation (on V8 at least).

        var computedObservable = this,
            state = computedObservable[computedState],
            changed = false;

        // Initially, we assume that none of the subscriptions are still being used (i.e., all are candidates for disposal).
        // Then, during evaluation, we cross off any that are in fact still being used.
        var isInitial = state.pure ? undefined : !state.dependenciesCount,   // If we're evaluating when there are no previous dependencies, it must be the first time
            dependencyDetectionContext = {
                computedObservable: computedObservable,
                disposalCandidates: state.dependencyTracking,
                disposalCount: state.dependenciesCount
            };

        ko.dependencyDetection.begin({
            callbackTarget: dependencyDetectionContext,
            callback: computedBeginDependencyDetectionCallback,
            computed: computedObservable,
            isInitial: isInitial
        });

        state.dependencyTracking = {};
        state.dependenciesCount = 0;

        var newValue = this.evaluateImmediate_CallReadThenEndDependencyDetection(state, dependencyDetectionContext);

        if (computedObservable.isDifferent(state.latestValue, newValue)) {
            if (!state.isSleeping) {
                computedObservable["notifySubscribers"](state.latestValue, "beforeChange");
            }

            state.latestValue = newValue;
            if (DEBUG) computedObservable._latestValue = newValue;

            if (state.isSleeping) {
                computedObservable.updateVersion();
            } else if (notifyChange) {
                computedObservable["notifySubscribers"](state.latestValue);
            }

            changed = true;
        }

        if (isInitial) {
            computedObservable["notifySubscribers"](state.latestValue, "awake");
        }

        return changed;
    },
    evaluateImmediate_CallReadThenEndDependencyDetection: function (state, dependencyDetectionContext) {
        // This function is really part of the evaluateImmediate_CallReadWithDependencyDetection logic.
        // You'd never call it from anywhere else. Factoring it out means that evaluateImmediate_CallReadWithDependencyDetection
        // can be independent of try/finally blocks, which contributes to saving about 40% off the CPU
        // overhead of computed evaluation (on V8 at least).

        try {
            var readFunction = state.readFunction;
            return state.evaluatorFunctionTarget ? readFunction.call(state.evaluatorFunctionTarget) : readFunction();
        } finally {
            ko.dependencyDetection.end();

            // For each subscription no longer being used, remove it from the active subscriptions list and dispose it
            if (dependencyDetectionContext.disposalCount && !state.isSleeping) {
                ko.utils.objectForEach(dependencyDetectionContext.disposalCandidates, computedDisposeDependencyCallback);
            }

            state.isStale = false;
        }
    },
    peek: function () {
        // Peek won't re-evaluate, except while the computed is sleeping or to get the initial value when "deferEvaluation" is set.
        var state = this[computedState];
        if ((state.isStale && !state.dependenciesCount) || (state.isSleeping && this.haveDependenciesChanged())) {
            this.evaluateImmediate();
        }
        return state.latestValue;
    },
    limit: function (limitFunction) {
        // Override the limit function with one that delays evaluation as well
        ko.subscribable['fn'].limit.call(this, limitFunction);
        this._evalDelayed = function () {
            this._limitBeforeChange(this[computedState].latestValue);

            this[computedState].isStale = true; // Mark as dirty

            // Pass the observable to the "limit" code, which will access it when
            // it's time to do the notification.
            this._limitChange(this);
        }
    },
    dispose: function () {
        var state = this[computedState];
        if (!state.isSleeping && state.dependencyTracking) {
            ko.utils.objectForEach(state.dependencyTracking, function (id, dependency) {
                if (dependency.dispose)
                    dependency.dispose();
            });
        }
        if (state.disposeWhenNodeIsRemoved && state.domNodeDisposalCallback) {
            ko.utils.domNodeDisposal.removeDisposeCallback(state.disposeWhenNodeIsRemoved, state.domNodeDisposalCallback);
        }
        state.dependencyTracking = null;
        state.dependenciesCount = 0;
        state.isDisposed = true;
        state.isStale = false;
        state.isSleeping = false;
        state.disposeWhenNodeIsRemoved = null;
    }
};

var pureComputedOverrides = {
    beforeSubscriptionAdd: function (event) {
        // If asleep, wake up the computed by subscribing to any dependencies.
        var computedObservable = this,
            state = computedObservable[computedState];
        if (!state.isDisposed && state.isSleeping && event == 'change') {
            state.isSleeping = false;
            if (state.isStale || computedObservable.haveDependenciesChanged()) {
                state.dependencyTracking = null;
                state.dependenciesCount = 0;
                state.isStale = true;
                if (computedObservable.evaluateImmediate()) {
                    computedObservable.updateVersion();
                }
            } else {
                // First put the dependencies in order
                var dependeciesOrder = [];
                ko.utils.objectForEach(state.dependencyTracking, function (id, dependency) {
                    dependeciesOrder[dependency._order] = id;
                });
                // Next, subscribe to each one
                ko.utils.arrayForEach(dependeciesOrder, function (id, order) {
                    var dependency = state.dependencyTracking[id],
                        subscription = computedObservable.subscribeToDependency(dependency._target);
                    subscription._order = order;
                    subscription._version = dependency._version;
                    state.dependencyTracking[id] = subscription;
                });
            }
            if (!state.isDisposed) {     // test since evaluating could trigger disposal
                computedObservable["notifySubscribers"](state.latestValue, "awake");
            }
        }
    },
    afterSubscriptionRemove: function (event) {
        var state = this[computedState];
        if (!state.isDisposed && event == 'change' && !this.hasSubscriptionsForEvent('change')) {
            ko.utils.objectForEach(state.dependencyTracking, function (id, dependency) {
                if (dependency.dispose) {
                    state.dependencyTracking[id] = {
                        _target: dependency._target,
                        _order: dependency._order,
                        _version: dependency._version
                    };
                    dependency.dispose();
                }
            });
            state.isSleeping = true;
            this["notifySubscribers"](undefined, "asleep");
        }
    },
    getVersion: function () {
        // Because a pure computed is not automatically updated while it is sleeping, we can't
        // simply return the version number. Instead, we check if any of the dependencies have
        // changed and conditionally re-evaluate the computed observable.
        var state = this[computedState];
        if (state.isSleeping && (state.isStale || this.haveDependenciesChanged())) {
            this.evaluateImmediate();
        }
        return ko.subscribable['fn'].getVersion.call(this);
    }
};

var deferEvaluationOverrides = {
    beforeSubscriptionAdd: function (event) {
        // This will force a computed with deferEvaluation to evaluate when the first subscription is registered.
        if (event == 'change' || event == 'beforeChange') {
            this.peek();
        }
    }
};

// Note that for browsers that don't support proto assignment, the
// inheritance chain is created manually in the ko.computed constructor
if (ko.utils.canSetPrototype) {
    ko.utils.setPrototypeOf(computedFn, ko.subscribable['fn']);
}

// Set the proto chain values for ko.hasPrototype
var protoProp = ko.observable.protoProperty; // == "__ko_proto__"
ko.computed[protoProp] = ko.observable;
computedFn[protoProp] = ko.computed;

ko.isComputed = function (instance) {
    return ko.hasPrototype(instance, ko.computed);
};

ko.isPureComputed = function (instance) {
    return ko.hasPrototype(instance, ko.computed)
        && instance[computedState] && instance[computedState].pure;
};

ko.exportSymbol('computed', ko.computed);
ko.exportSymbol('dependentObservable', ko.computed);    // export ko.dependentObservable for backwards compatibility (1.x)
ko.exportSymbol('isComputed', ko.isComputed);
ko.exportSymbol('isPureComputed', ko.isPureComputed);
ko.exportSymbol('computed.fn', computedFn);
ko.exportProperty(computedFn, 'peek', computedFn.peek);
ko.exportProperty(computedFn, 'dispose', computedFn.dispose);
ko.exportProperty(computedFn, 'isActive', computedFn.isActive);
ko.exportProperty(computedFn, 'getDependenciesCount', computedFn.getDependenciesCount);

ko.pureComputed = function (evaluatorFunctionOrOptions, evaluatorFunctionTarget) {
    if (typeof evaluatorFunctionOrOptions === 'function') {
        return ko.computed(evaluatorFunctionOrOptions, evaluatorFunctionTarget, {'pure':true});
    } else {
        evaluatorFunctionOrOptions = ko.utils.extend({}, evaluatorFunctionOrOptions);   // make a copy of the parameter object
        evaluatorFunctionOrOptions['pure'] = true;
        return ko.computed(evaluatorFunctionOrOptions, evaluatorFunctionTarget);
    }
}
ko.exportSymbol('pureComputed', ko.pureComputed);

(function() {
    var maxNestedObservableDepth = 10; // Escape the (unlikely) pathalogical case where an observable's current value is itself (or similar reference cycle)

    ko.toJS = function(rootObject) {
        if (arguments.length == 0)
            throw new Error("When calling ko.toJS, pass the object you want to convert.");

        // We just unwrap everything at every level in the object graph
        return mapJsObjectGraph(rootObject, function(valueToMap) {
            // Loop because an observable's value might in turn be another observable wrapper
            for (var i = 0; ko.isObservable(valueToMap) && (i < maxNestedObservableDepth); i++)
                valueToMap = valueToMap();
            return valueToMap;
        });
    };

    ko.toJSON = function(rootObject, replacer, space) {     // replacer and space are optional
        var plainJavaScriptObject = ko.toJS(rootObject);
        return ko.utils.stringifyJson(plainJavaScriptObject, replacer, space);
    };

    function mapJsObjectGraph(rootObject, mapInputCallback, visitedObjects) {
        visitedObjects = visitedObjects || new objectLookup();

        rootObject = mapInputCallback(rootObject);
        var canHaveProperties = (typeof rootObject == "object") && (rootObject !== null) && (rootObject !== undefined) && (!(rootObject instanceof RegExp)) && (!(rootObject instanceof Date)) && (!(rootObject instanceof String)) && (!(rootObject instanceof Number)) && (!(rootObject instanceof Boolean));
        if (!canHaveProperties)
            return rootObject;

        var outputProperties = rootObject instanceof Array ? [] : {};
        visitedObjects.save(rootObject, outputProperties);

        visitPropertiesOrArrayEntries(rootObject, function(indexer) {
            var propertyValue = mapInputCallback(rootObject[indexer]);

            switch (typeof propertyValue) {
                case "boolean":
                case "number":
                case "string":
                case "function":
                    outputProperties[indexer] = propertyValue;
                    break;
                case "object":
                case "undefined":
                    var previouslyMappedValue = visitedObjects.get(propertyValue);
                    outputProperties[indexer] = (previouslyMappedValue !== undefined)
                        ? previouslyMappedValue
                        : mapJsObjectGraph(propertyValue, mapInputCallback, visitedObjects);
                    break;
            }
        });

        return outputProperties;
    }

    function visitPropertiesOrArrayEntries(rootObject, visitorCallback) {
        if (rootObject instanceof Array) {
            for (var i = 0; i < rootObject.length; i++)
                visitorCallback(i);

            // For arrays, also respect toJSON property for custom mappings (fixes #278)
            if (typeof rootObject['toJSON'] == 'function')
                visitorCallback('toJSON');
        } else {
            for (var propertyName in rootObject) {
                visitorCallback(propertyName);
            }
        }
    };

    function objectLookup() {
        this.keys = [];
        this.values = [];
    };

    objectLookup.prototype = {
        constructor: objectLookup,
        save: function(key, value) {
            var existingIndex = ko.utils.arrayIndexOf(this.keys, key);
            if (existingIndex >= 0)
                this.values[existingIndex] = value;
            else {
                this.keys.push(key);
                this.values.push(value);
            }
        },
        get: function(key) {
            var existingIndex = ko.utils.arrayIndexOf(this.keys, key);
            return (existingIndex >= 0) ? this.values[existingIndex] : undefined;
        }
    };
})();

ko.exportSymbol('toJS', ko.toJS);
ko.exportSymbol('toJSON', ko.toJSON);
(function () {
    var hasDomDataExpandoProperty = '__ko__hasDomDataOptionValue__';

    // Normally, SELECT elements and their OPTIONs can only take value of type 'string' (because the values
    // are stored on DOM attributes). ko.selectExtensions provides a way for SELECTs/OPTIONs to have values
    // that are arbitrary objects. This is very convenient when implementing things like cascading dropdowns.
    ko.selectExtensions = {
        readValue : function(element) {
            switch (ko.utils.tagNameLower(element)) {
                case 'option':
                    if (element[hasDomDataExpandoProperty] === true)
                        return ko.utils.domData.get(element, ko.bindingHandlers.options.optionValueDomDataKey);
                    return ko.utils.ieVersion <= 7
                        ? (element.getAttributeNode('value') && element.getAttributeNode('value').specified ? element.value : element.text)
                        : element.value;
                case 'select':
                    return element.selectedIndex >= 0 ? ko.selectExtensions.readValue(element.options[element.selectedIndex]) : undefined;
                default:
                    return element.value;
            }
        },

        writeValue: function(element, value, allowUnset) {
            switch (ko.utils.tagNameLower(element)) {
                case 'option':
                    switch(typeof value) {
                        case "string":
                            ko.utils.domData.set(element, ko.bindingHandlers.options.optionValueDomDataKey, undefined);
                            if (hasDomDataExpandoProperty in element) { // IE <= 8 throws errors if you delete non-existent properties from a DOM node
                                delete element[hasDomDataExpandoProperty];
                            }
                            element.value = value;
                            break;
                        default:
                            // Store arbitrary object using DomData
                            ko.utils.domData.set(element, ko.bindingHandlers.options.optionValueDomDataKey, value);
                            element[hasDomDataExpandoProperty] = true;

                            // Special treatment of numbers is just for backward compatibility. KO 1.2.1 wrote numerical values to element.value.
                            element.value = typeof value === "number" ? value : "";
                            break;
                    }
                    break;
                case 'select':
                    if (value === "" || value === null)       // A blank string or null value will select the caption
                        value = undefined;
                    var selection = -1;
                    for (var i = 0, n = element.options.length, optionValue; i < n; ++i) {
                        optionValue = ko.selectExtensions.readValue(element.options[i]);
                        // Include special check to handle selecting a caption with a blank string value
                        if (optionValue == value || (optionValue == "" && value === undefined)) {
                            selection = i;
                            break;
                        }
                    }
                    if (allowUnset || selection >= 0 || (value === undefined && element.size > 1)) {
                        element.selectedIndex = selection;
                    }
                    break;
                default:
                    if ((value === null) || (value === undefined))
                        value = "";
                    element.value = value;
                    break;
            }
        }
    };
})();

ko.exportSymbol('selectExtensions', ko.selectExtensions);
ko.exportSymbol('selectExtensions.readValue', ko.selectExtensions.readValue);
ko.exportSymbol('selectExtensions.writeValue', ko.selectExtensions.writeValue);
ko.expressionRewriting = (function () {
    var javaScriptReservedWords = ["true", "false", "null", "undefined"];

    // Matches something that can be assigned to--either an isolated identifier or something ending with a property accessor
    // This is designed to be simple and avoid false negatives, but could produce false positives (e.g., a+b.c).
    // This also will not properly handle nested brackets (e.g., obj1[obj2['prop']]; see #911).
    var javaScriptAssignmentTarget = /^(?:[$_a-z][$\w]*|(.+)(\.\s*[$_a-z][$\w]*|\[.+\]))$/i;

    function getWriteableValue(expression) {
        if (ko.utils.arrayIndexOf(javaScriptReservedWords, expression) >= 0)
            return false;
        var match = expression.match(javaScriptAssignmentTarget);
        return match === null ? false : match[1] ? ('Object(' + match[1] + ')' + match[2]) : expression;
    }

    // The following regular expressions will be used to split an object-literal string into tokens

        // These two match strings, either with double quotes or single quotes
    var stringDouble = '"(?:[^"\\\\]|\\\\.)*"',
        stringSingle = "'(?:[^'\\\\]|\\\\.)*'",
        // Matches a regular expression (text enclosed by slashes), but will also match sets of divisions
        // as a regular expression (this is handled by the parsing loop below).
        stringRegexp = '/(?:[^/\\\\]|\\\\.)*/\w*',
        // These characters have special meaning to the parser and must not appear in the middle of a
        // token, except as part of a string.
        specials = ',"\'{}()/:[\\]',
        // Match text (at least two characters) that does not contain any of the above special characters,
        // although some of the special characters are allowed to start it (all but the colon and comma).
        // The text can contain spaces, but leading or trailing spaces are skipped.
        everyThingElse = '[^\\s:,/][^' + specials + ']*[^\\s' + specials + ']',
        // Match any non-space character not matched already. This will match colons and commas, since they're
        // not matched by "everyThingElse", but will also match any other single character that wasn't already
        // matched (for example: in "a: 1, b: 2", each of the non-space characters will be matched by oneNotSpace).
        oneNotSpace = '[^\\s]',

        // Create the actual regular expression by or-ing the above strings. The order is important.
        bindingToken = RegExp(stringDouble + '|' + stringSingle + '|' + stringRegexp + '|' + everyThingElse + '|' + oneNotSpace, 'g'),

        // Match end of previous token to determine whether a slash is a division or regex.
        divisionLookBehind = /[\])"'A-Za-z0-9_$]+$/,
        keywordRegexLookBehind = {'in':1,'return':1,'typeof':1};

    function parseObjectLiteral(objectLiteralString) {
        // Trim leading and trailing spaces from the string
        var str = ko.utils.stringTrim(objectLiteralString);

        // Trim braces '{' surrounding the whole object literal
        if (str.charCodeAt(0) === 123) str = str.slice(1, -1);

        // Split into tokens
        var result = [], toks = str.match(bindingToken), key, values = [], depth = 0;

        if (toks) {
            // Append a comma so that we don't need a separate code block to deal with the last item
            toks.push(',');

            for (var i = 0, tok; tok = toks[i]; ++i) {
                var c = tok.charCodeAt(0);
                // A comma signals the end of a key/value pair if depth is zero
                if (c === 44) { // ","
                    if (depth <= 0) {
                        result.push((key && values.length) ? {key: key, value: values.join('')} : {'unknown': key || values.join('')});
                        key = depth = 0;
                        values = [];
                        continue;
                    }
                // Simply skip the colon that separates the name and value
                } else if (c === 58) { // ":"
                    if (!depth && !key && values.length === 1) {
                        key = values.pop();
                        continue;
                    }
                // A set of slashes is initially matched as a regular expression, but could be division
                } else if (c === 47 && i && tok.length > 1) {  // "/"
                    // Look at the end of the previous token to determine if the slash is actually division
                    var match = toks[i-1].match(divisionLookBehind);
                    if (match && !keywordRegexLookBehind[match[0]]) {
                        // The slash is actually a division punctuator; re-parse the remainder of the string (not including the slash)
                        str = str.substr(str.indexOf(tok) + 1);
                        toks = str.match(bindingToken);
                        toks.push(',');
                        i = -1;
                        // Continue with just the slash
                        tok = '/';
                    }
                // Increment depth for parentheses, braces, and brackets so that interior commas are ignored
                } else if (c === 40 || c === 123 || c === 91) { // '(', '{', '['
                    ++depth;
                } else if (c === 41 || c === 125 || c === 93) { // ')', '}', ']'
                    --depth;
                // The key will be the first token; if it's a string, trim the quotes
                } else if (!key && !values.length && (c === 34 || c === 39)) { // '"', "'"
                    tok = tok.slice(1, -1);
                }
                values.push(tok);
            }
        }
        return result;
    }

    // Two-way bindings include a write function that allow the handler to update the value even if it's not an observable.
    var twoWayBindings = {};

    function preProcessBindings(bindingsStringOrKeyValueArray, bindingOptions) {
        bindingOptions = bindingOptions || {};

        function processKeyValue(key, val) {
            var writableVal;
            function callPreprocessHook(obj) {
                return (obj && obj['preprocess']) ? (val = obj['preprocess'](val, key, processKeyValue)) : true;
            }
            if (!bindingParams) {
                if (!callPreprocessHook(ko['getBindingHandler'](key)))
                    return;

                if (twoWayBindings[key] && (writableVal = getWriteableValue(val))) {
                    // For two-way bindings, provide a write method in case the value
                    // isn't a writable observable.
                    propertyAccessorResultStrings.push("'" + key + "':function(_z){" + writableVal + "=_z}");
                }
            }
            // Values are wrapped in a function so that each value can be accessed independently
            if (makeValueAccessors) {
                val = 'function(){return ' + val + ' }';
            }
            resultStrings.push("'" + key + "':" + val);
        }

        var resultStrings = [],
            propertyAccessorResultStrings = [],
            makeValueAccessors = bindingOptions['valueAccessors'],
            bindingParams = bindingOptions['bindingParams'],
            keyValueArray = typeof bindingsStringOrKeyValueArray === "string" ?
                parseObjectLiteral(bindingsStringOrKeyValueArray) : bindingsStringOrKeyValueArray;

        ko.utils.arrayForEach(keyValueArray, function(keyValue) {
            processKeyValue(keyValue.key || keyValue['unknown'], keyValue.value);
        });

        if (propertyAccessorResultStrings.length)
            processKeyValue('_ko_property_writers', "{" + propertyAccessorResultStrings.join(",") + " }");

        return resultStrings.join(",");
    }

    return {
        bindingRewriteValidators: [],

        twoWayBindings: twoWayBindings,

        parseObjectLiteral: parseObjectLiteral,

        preProcessBindings: preProcessBindings,

        keyValueArrayContainsKey: function(keyValueArray, key) {
            for (var i = 0; i < keyValueArray.length; i++)
                if (keyValueArray[i]['key'] == key)
                    return true;
            return false;
        },

        // Internal, private KO utility for updating model properties from within bindings
        // property:            If the property being updated is (or might be) an observable, pass it here
        //                      If it turns out to be a writable observable, it will be written to directly
        // allBindings:         An object with a get method to retrieve bindings in the current execution context.
        //                      This will be searched for a '_ko_property_writers' property in case you're writing to a non-observable
        // key:                 The key identifying the property to be written. Example: for { hasFocus: myValue }, write to 'myValue' by specifying the key 'hasFocus'
        // value:               The value to be written
        // checkIfDifferent:    If true, and if the property being written is a writable observable, the value will only be written if
        //                      it is !== existing value on that writable observable
        writeValueToProperty: function(property, allBindings, key, value, checkIfDifferent) {
            if (!property || !ko.isObservable(property)) {
                var propWriters = allBindings.get('_ko_property_writers');
                if (propWriters && propWriters[key])
                    propWriters[key](value);
            } else if (ko.isWriteableObservable(property) && (!checkIfDifferent || property.peek() !== value)) {
                property(value);
            }
        }
    };
})();

ko.exportSymbol('expressionRewriting', ko.expressionRewriting);
ko.exportSymbol('expressionRewriting.bindingRewriteValidators', ko.expressionRewriting.bindingRewriteValidators);
ko.exportSymbol('expressionRewriting.parseObjectLiteral', ko.expressionRewriting.parseObjectLiteral);
ko.exportSymbol('expressionRewriting.preProcessBindings', ko.expressionRewriting.preProcessBindings);

// Making bindings explicitly declare themselves as "two way" isn't ideal in the long term (it would be better if
// all bindings could use an official 'property writer' API without needing to declare that they might). However,
// since this is not, and has never been, a public API (_ko_property_writers was never documented), it's acceptable
// as an internal implementation detail in the short term.
// For those developers who rely on _ko_property_writers in their custom bindings, we expose _twoWayBindings as an
// undocumented feature that makes it relatively easy to upgrade to KO 3.0. However, this is still not an official
// public API, and we reserve the right to remove it at any time if we create a real public property writers API.
ko.exportSymbol('expressionRewriting._twoWayBindings', ko.expressionRewriting.twoWayBindings);

// For backward compatibility, define the following aliases. (Previously, these function names were misleading because
// they referred to JSON specifically, even though they actually work with arbitrary JavaScript object literal expressions.)
ko.exportSymbol('jsonExpressionRewriting', ko.expressionRewriting);
ko.exportSymbol('jsonExpressionRewriting.insertPropertyAccessorsIntoJson', ko.expressionRewriting.preProcessBindings);
(function() {
    // "Virtual elements" is an abstraction on top of the usual DOM API which understands the notion that comment nodes
    // may be used to represent hierarchy (in addition to the DOM's natural hierarchy).
    // If you call the DOM-manipulating functions on ko.virtualElements, you will be able to read and write the state
    // of that virtual hierarchy
    //
    // The point of all this is to support containerless templates (e.g., <!-- ko foreach:someCollection -->blah<!-- /ko -->)
    // without having to scatter special cases all over the binding and templating code.

    // IE 9 cannot reliably read the "nodeValue" property of a comment node (see https://github.com/SteveSanderson/knockout/issues/186)
    // but it does give them a nonstandard alternative property called "text" that it can read reliably. Other browsers don't have that property.
    // So, use node.text where available, and node.nodeValue elsewhere
    var commentNodesHaveTextProperty = document && document.createComment("test").text === "<!--test-->";

    var startCommentRegex = commentNodesHaveTextProperty ? /^<!--\s*ko(?:\s+([\s\S]+))?\s*-->$/ : /^\s*ko(?:\s+([\s\S]+))?\s*$/;
    var endCommentRegex =   commentNodesHaveTextProperty ? /^<!--\s*\/ko\s*-->$/ : /^\s*\/ko\s*$/;
    var htmlTagsWithOptionallyClosingChildren = { 'ul': true, 'ol': true };

    function isStartComment(node) {
        return (node.nodeType == 8) && startCommentRegex.test(commentNodesHaveTextProperty ? node.text : node.nodeValue);
    }

    function isEndComment(node) {
        return (node.nodeType == 8) && endCommentRegex.test(commentNodesHaveTextProperty ? node.text : node.nodeValue);
    }

    function getVirtualChildren(startComment, allowUnbalanced) {
        var currentNode = startComment;
        var depth = 1;
        var children = [];
        while (currentNode = currentNode.nextSibling) {
            if (isEndComment(currentNode)) {
                depth--;
                if (depth === 0)
                    return children;
            }

            children.push(currentNode);

            if (isStartComment(currentNode))
                depth++;
        }
        if (!allowUnbalanced)
            throw new Error("Cannot find closing comment tag to match: " + startComment.nodeValue);
        return null;
    }

    function getMatchingEndComment(startComment, allowUnbalanced) {
        var allVirtualChildren = getVirtualChildren(startComment, allowUnbalanced);
        if (allVirtualChildren) {
            if (allVirtualChildren.length > 0)
                return allVirtualChildren[allVirtualChildren.length - 1].nextSibling;
            return startComment.nextSibling;
        } else
            return null; // Must have no matching end comment, and allowUnbalanced is true
    }

    function getUnbalancedChildTags(node) {
        // e.g., from <div>OK</div><!-- ko blah --><span>Another</span>, returns: <!-- ko blah --><span>Another</span>
        //       from <div>OK</div><!-- /ko --><!-- /ko -->,             returns: <!-- /ko --><!-- /ko -->
        var childNode = node.firstChild, captureRemaining = null;
        if (childNode) {
            do {
                if (captureRemaining)                   // We already hit an unbalanced node and are now just scooping up all subsequent nodes
                    captureRemaining.push(childNode);
                else if (isStartComment(childNode)) {
                    var matchingEndComment = getMatchingEndComment(childNode, /* allowUnbalanced: */ true);
                    if (matchingEndComment)             // It's a balanced tag, so skip immediately to the end of this virtual set
                        childNode = matchingEndComment;
                    else
                        captureRemaining = [childNode]; // It's unbalanced, so start capturing from this point
                } else if (isEndComment(childNode)) {
                    captureRemaining = [childNode];     // It's unbalanced (if it wasn't, we'd have skipped over it already), so start capturing
                }
            } while (childNode = childNode.nextSibling);
        }
        return captureRemaining;
    }

    ko.virtualElements = {
        allowedBindings: {},

        childNodes: function(node) {
            return isStartComment(node) ? getVirtualChildren(node) : node.childNodes;
        },

        emptyNode: function(node) {
            if (!isStartComment(node))
                ko.utils.emptyDomNode(node);
            else {
                var virtualChildren = ko.virtualElements.childNodes(node);
                for (var i = 0, j = virtualChildren.length; i < j; i++)
                    ko.removeNode(virtualChildren[i]);
            }
        },

        setDomNodeChildren: function(node, childNodes) {
            if (!isStartComment(node))
                ko.utils.setDomNodeChildren(node, childNodes);
            else {
                ko.virtualElements.emptyNode(node);
                var endCommentNode = node.nextSibling; // Must be the next sibling, as we just emptied the children
                for (var i = 0, j = childNodes.length; i < j; i++)
                    endCommentNode.parentNode.insertBefore(childNodes[i], endCommentNode);
            }
        },

        prepend: function(containerNode, nodeToPrepend) {
            if (!isStartComment(containerNode)) {
                if (containerNode.firstChild)
                    containerNode.insertBefore(nodeToPrepend, containerNode.firstChild);
                else
                    containerNode.appendChild(nodeToPrepend);
            } else {
                // Start comments must always have a parent and at least one following sibling (the end comment)
                containerNode.parentNode.insertBefore(nodeToPrepend, containerNode.nextSibling);
            }
        },

        insertAfter: function(containerNode, nodeToInsert, insertAfterNode) {
            if (!insertAfterNode) {
                ko.virtualElements.prepend(containerNode, nodeToInsert);
            } else if (!isStartComment(containerNode)) {
                // Insert after insertion point
                if (insertAfterNode.nextSibling)
                    containerNode.insertBefore(nodeToInsert, insertAfterNode.nextSibling);
                else
                    containerNode.appendChild(nodeToInsert);
            } else {
                // Children of start comments must always have a parent and at least one following sibling (the end comment)
                containerNode.parentNode.insertBefore(nodeToInsert, insertAfterNode.nextSibling);
            }
        },

        firstChild: function(node) {
            if (!isStartComment(node))
                return node.firstChild;
            if (!node.nextSibling || isEndComment(node.nextSibling))
                return null;
            return node.nextSibling;
        },

        nextSibling: function(node) {
            if (isStartComment(node))
                node = getMatchingEndComment(node);
            if (node.nextSibling && isEndComment(node.nextSibling))
                return null;
            return node.nextSibling;
        },

        hasBindingValue: isStartComment,

        virtualNodeBindingValue: function(node) {
            var regexMatch = (commentNodesHaveTextProperty ? node.text : node.nodeValue).match(startCommentRegex);
            return regexMatch ? regexMatch[1] : null;
        },

        normaliseVirtualElementDomStructure: function(elementVerified) {
            // Workaround for https://github.com/SteveSanderson/knockout/issues/155
            // (IE <= 8 or IE 9 quirks mode parses your HTML weirdly, treating closing </li> tags as if they don't exist, thereby moving comment nodes
            // that are direct descendants of <ul> into the preceding <li>)
            if (!htmlTagsWithOptionallyClosingChildren[ko.utils.tagNameLower(elementVerified)])
                return;

            // Scan immediate children to see if they contain unbalanced comment tags. If they do, those comment tags
            // must be intended to appear *after* that child, so move them there.
            var childNode = elementVerified.firstChild;
            if (childNode) {
                do {
                    if (childNode.nodeType === 1) {
                        var unbalancedTags = getUnbalancedChildTags(childNode);
                        if (unbalancedTags) {
                            // Fix up the DOM by moving the unbalanced tags to where they most likely were intended to be placed - *after* the child
                            var nodeToInsertBefore = childNode.nextSibling;
                            for (var i = 0; i < unbalancedTags.length; i++) {
                                if (nodeToInsertBefore)
                                    elementVerified.insertBefore(unbalancedTags[i], nodeToInsertBefore);
                                else
                                    elementVerified.appendChild(unbalancedTags[i]);
                            }
                        }
                    }
                } while (childNode = childNode.nextSibling);
            }
        }
    };
})();
ko.exportSymbol('virtualElements', ko.virtualElements);
ko.exportSymbol('virtualElements.allowedBindings', ko.virtualElements.allowedBindings);
ko.exportSymbol('virtualElements.emptyNode', ko.virtualElements.emptyNode);
//ko.exportSymbol('virtualElements.firstChild', ko.virtualElements.firstChild);     // firstChild is not minified
ko.exportSymbol('virtualElements.insertAfter', ko.virtualElements.insertAfter);
//ko.exportSymbol('virtualElements.nextSibling', ko.virtualElements.nextSibling);   // nextSibling is not minified
ko.exportSymbol('virtualElements.prepend', ko.virtualElements.prepend);
ko.exportSymbol('virtualElements.setDomNodeChildren', ko.virtualElements.setDomNodeChildren);
(function() {
    var defaultBindingAttributeName = "data-bind";

    ko.bindingProvider = function() {
        this.bindingCache = {};
    };

    ko.utils.extend(ko.bindingProvider.prototype, {
        'nodeHasBindings': function(node) {
            switch (node.nodeType) {
                case 1: // Element
                    return node.getAttribute(defaultBindingAttributeName) != null
                        || ko.components['getComponentNameForNode'](node);
                case 8: // Comment node
                    return ko.virtualElements.hasBindingValue(node);
                default: return false;
            }
        },

        'getBindings': function(node, bindingContext) {
            var bindingsString = this['getBindingsString'](node, bindingContext),
                parsedBindings = bindingsString ? this['parseBindingsString'](bindingsString, bindingContext, node) : null;
            return ko.components.addBindingsForCustomElement(parsedBindings, node, bindingContext, /* valueAccessors */ false);
        },

        'getBindingAccessors': function(node, bindingContext) {
            var bindingsString = this['getBindingsString'](node, bindingContext),
                parsedBindings = bindingsString ? this['parseBindingsString'](bindingsString, bindingContext, node, { 'valueAccessors': true }) : null;
            return ko.components.addBindingsForCustomElement(parsedBindings, node, bindingContext, /* valueAccessors */ true);
        },

        // The following function is only used internally by this default provider.
        // It's not part of the interface definition for a general binding provider.
        'getBindingsString': function(node, bindingContext) {
            switch (node.nodeType) {
                case 1: return node.getAttribute(defaultBindingAttributeName);   // Element
                case 8: return ko.virtualElements.virtualNodeBindingValue(node); // Comment node
                default: return null;
            }
        },

        // The following function is only used internally by this default provider.
        // It's not part of the interface definition for a general binding provider.
        'parseBindingsString': function(bindingsString, bindingContext, node, options) {
            try {
                var bindingFunction = createBindingsStringEvaluatorViaCache(bindingsString, this.bindingCache, options);
                return bindingFunction(bindingContext, node);
            } catch (ex) {
                ex.message = "Unable to parse bindings.\nBindings value: " + bindingsString + "\nMessage: " + ex.message;
                throw ex;
            }
        }
    });

    ko.bindingProvider['instance'] = new ko.bindingProvider();

    function createBindingsStringEvaluatorViaCache(bindingsString, cache, options) {
        var cacheKey = bindingsString + (options && options['valueAccessors'] || '');
        return cache[cacheKey]
            || (cache[cacheKey] = createBindingsStringEvaluator(bindingsString, options));
    }

    function createBindingsStringEvaluator(bindingsString, options) {
        // Build the source for a function that evaluates "expression"
        // For each scope variable, add an extra level of "with" nesting
        // Example result: with(sc1) { with(sc0) { return (expression) } }
        var rewrittenBindings = ko.expressionRewriting.preProcessBindings(bindingsString, options),
            functionBody = "with($context){with($data||{}){return{" + rewrittenBindings + "}}}";
        return new Function("$context", "$element", functionBody);
    }
})();

ko.exportSymbol('bindingProvider', ko.bindingProvider);
(function () {
    ko.bindingHandlers = {};

    // The following element types will not be recursed into during binding.
    var bindingDoesNotRecurseIntoElementTypes = {
        // Don't want bindings that operate on text nodes to mutate <script> and <textarea> contents,
        // because it's unexpected and a potential XSS issue.
        // Also bindings should not operate on <template> elements since this breaks in Internet Explorer
        // and because such elements' contents are always intended to be bound in a different context
        // from where they appear in the document.
        'script': true,
        'textarea': true,
        'template': true
    };

    // Use an overridable method for retrieving binding handlers so that a plugins may support dynamically created handlers
    ko['getBindingHandler'] = function(bindingKey) {
        return ko.bindingHandlers[bindingKey];
    };

    // The ko.bindingContext constructor is only called directly to create the root context. For child
    // contexts, use bindingContext.createChildContext or bindingContext.extend.
    ko.bindingContext = function(dataItemOrAccessor, parentContext, dataItemAlias, extendCallback, options) {

        // The binding context object includes static properties for the current, parent, and root view models.
        // If a view model is actually stored in an observable, the corresponding binding context object, and
        // any child contexts, must be updated when the view model is changed.
        function updateContext() {
            // Most of the time, the context will directly get a view model object, but if a function is given,
            // we call the function to retrieve the view model. If the function accesses any observables or returns
            // an observable, the dependency is tracked, and those observables can later cause the binding
            // context to be updated.
            var dataItemOrObservable = isFunc ? dataItemOrAccessor() : dataItemOrAccessor,
                dataItem = ko.utils.unwrapObservable(dataItemOrObservable);

            if (parentContext) {
                // When a "parent" context is given, register a dependency on the parent context. Thus whenever the
                // parent context is updated, this context will also be updated.
                if (parentContext._subscribable)
                    parentContext._subscribable();

                // Copy $root and any custom properties from the parent context
                ko.utils.extend(self, parentContext);

                // Because the above copy overwrites our own properties, we need to reset them.
                self._subscribable = subscribable;
            } else {
                self['$parents'] = [];
                self['$root'] = dataItem;

                // Export 'ko' in the binding context so it will be available in bindings and templates
                // even if 'ko' isn't exported as a global, such as when using an AMD loader.
                // See https://github.com/SteveSanderson/knockout/issues/490
                self['ko'] = ko;
            }
            self['$rawData'] = dataItemOrObservable;
            self['$data'] = dataItem;
            if (dataItemAlias)
                self[dataItemAlias] = dataItem;

            // The extendCallback function is provided when creating a child context or extending a context.
            // It handles the specific actions needed to finish setting up the binding context. Actions in this
            // function could also add dependencies to this binding context.
            if (extendCallback)
                extendCallback(self, parentContext, dataItem);

            return self['$data'];
        }
        function disposeWhen() {
            return nodes && !ko.utils.anyDomNodeIsAttachedToDocument(nodes);
        }

        var self = this,
            isFunc = typeof(dataItemOrAccessor) == "function" && !ko.isObservable(dataItemOrAccessor),
            nodes,
            subscribable;

        if (options && options['exportDependencies']) {
            // The "exportDependencies" option means that the calling code will track any dependencies and re-create
            // the binding context when they change.
            updateContext();
        } else {
            subscribable = ko.dependentObservable(updateContext, null, { disposeWhen: disposeWhen, disposeWhenNodeIsRemoved: true });

            // At this point, the binding context has been initialized, and the "subscribable" computed observable is
            // subscribed to any observables that were accessed in the process. If there is nothing to track, the
            // computed will be inactive, and we can safely throw it away. If it's active, the computed is stored in
            // the context object.
            if (subscribable.isActive()) {
                self._subscribable = subscribable;

                // Always notify because even if the model ($data) hasn't changed, other context properties might have changed
                subscribable['equalityComparer'] = null;

                // We need to be able to dispose of this computed observable when it's no longer needed. This would be
                // easy if we had a single node to watch, but binding contexts can be used by many different nodes, and
                // we cannot assume that those nodes have any relation to each other. So instead we track any node that
                // the context is attached to, and dispose the computed when all of those nodes have been cleaned.

                // Add properties to *subscribable* instead of *self* because any properties added to *self* may be overwritten on updates
                nodes = [];
                subscribable._addNode = function(node) {
                    nodes.push(node);
                    ko.utils.domNodeDisposal.addDisposeCallback(node, function(node) {
                        ko.utils.arrayRemoveItem(nodes, node);
                        if (!nodes.length) {
                            subscribable.dispose();
                            self._subscribable = subscribable = undefined;
                        }
                    });
                };
            }
        }
    }

    // Extend the binding context hierarchy with a new view model object. If the parent context is watching
    // any observables, the new child context will automatically get a dependency on the parent context.
    // But this does not mean that the $data value of the child context will also get updated. If the child
    // view model also depends on the parent view model, you must provide a function that returns the correct
    // view model on each update.
    ko.bindingContext.prototype['createChildContext'] = function (dataItemOrAccessor, dataItemAlias, extendCallback, options) {
        return new ko.bindingContext(dataItemOrAccessor, this, dataItemAlias, function(self, parentContext) {
            // Extend the context hierarchy by setting the appropriate pointers
            self['$parentContext'] = parentContext;
            self['$parent'] = parentContext['$data'];
            self['$parents'] = (parentContext['$parents'] || []).slice(0);
            self['$parents'].unshift(self['$parent']);
            if (extendCallback)
                extendCallback(self);
        }, options);
    };

    // Extend the binding context with new custom properties. This doesn't change the context hierarchy.
    // Similarly to "child" contexts, provide a function here to make sure that the correct values are set
    // when an observable view model is updated.
    ko.bindingContext.prototype['extend'] = function(properties) {
        // If the parent context references an observable view model, "_subscribable" will always be the
        // latest view model object. If not, "_subscribable" isn't set, and we can use the static "$data" value.
        return new ko.bindingContext(this._subscribable || this['$data'], this, null, function(self, parentContext) {
            // This "child" context doesn't directly track a parent observable view model,
            // so we need to manually set the $rawData value to match the parent.
            self['$rawData'] = parentContext['$rawData'];
            ko.utils.extend(self, typeof(properties) == "function" ? properties() : properties);
        });
    };

    ko.bindingContext.prototype.createStaticChildContext = function (dataItemOrAccessor, dataItemAlias) {
        return this['createChildContext'](dataItemOrAccessor, dataItemAlias, null, { "exportDependencies": true });
    };

    // Returns the valueAccesor function for a binding value
    function makeValueAccessor(value) {
        return function() {
            return value;
        };
    }

    // Returns the value of a valueAccessor function
    function evaluateValueAccessor(valueAccessor) {
        return valueAccessor();
    }

    // Given a function that returns bindings, create and return a new object that contains
    // binding value-accessors functions. Each accessor function calls the original function
    // so that it always gets the latest value and all dependencies are captured. This is used
    // by ko.applyBindingsToNode and getBindingsAndMakeAccessors.
    function makeAccessorsFromFunction(callback) {
        return ko.utils.objectMap(ko.dependencyDetection.ignore(callback), function(value, key) {
            return function() {
                return callback()[key];
            };
        });
    }

    // Given a bindings function or object, create and return a new object that contains
    // binding value-accessors functions. This is used by ko.applyBindingsToNode.
    function makeBindingAccessors(bindings, context, node) {
        if (typeof bindings === 'function') {
            return makeAccessorsFromFunction(bindings.bind(null, context, node));
        } else {
            return ko.utils.objectMap(bindings, makeValueAccessor);
        }
    }

    // This function is used if the binding provider doesn't include a getBindingAccessors function.
    // It must be called with 'this' set to the provider instance.
    function getBindingsAndMakeAccessors(node, context) {
        return makeAccessorsFromFunction(this['getBindings'].bind(this, node, context));
    }

    function validateThatBindingIsAllowedForVirtualElements(bindingName) {
        var validator = ko.virtualElements.allowedBindings[bindingName];
        if (!validator)
            throw new Error("The binding '" + bindingName + "' cannot be used with virtual elements")
    }

    function applyBindingsToDescendantsInternal (bindingContext, elementOrVirtualElement, bindingContextsMayDifferFromDomParentElement) {
        var currentChild,
            nextInQueue = ko.virtualElements.firstChild(elementOrVirtualElement),
            provider = ko.bindingProvider['instance'],
            preprocessNode = provider['preprocessNode'];

        // Preprocessing allows a binding provider to mutate a node before bindings are applied to it. For example it's
        // possible to insert new siblings after it, and/or replace the node with a different one. This can be used to
        // implement custom binding syntaxes, such as {{ value }} for string interpolation, or custom element types that
        // trigger insertion of <template> contents at that point in the document.
        if (preprocessNode) {
            while (currentChild = nextInQueue) {
                nextInQueue = ko.virtualElements.nextSibling(currentChild);
                preprocessNode.call(provider, currentChild);
            }
            // Reset nextInQueue for the next loop
            nextInQueue = ko.virtualElements.firstChild(elementOrVirtualElement);
        }

        while (currentChild = nextInQueue) {
            // Keep a record of the next child *before* applying bindings, in case the binding removes the current child from its position
            nextInQueue = ko.virtualElements.nextSibling(currentChild);
            applyBindingsToNodeAndDescendantsInternal(bindingContext, currentChild, bindingContextsMayDifferFromDomParentElement);
        }
    }

    function applyBindingsToNodeAndDescendantsInternal (bindingContext, nodeVerified, bindingContextMayDifferFromDomParentElement) {
        var shouldBindDescendants = true;

        // Perf optimisation: Apply bindings only if...
        // (1) We need to store the binding context on this node (because it may differ from the DOM parent node's binding context)
        //     Note that we can't store binding contexts on non-elements (e.g., text nodes), as IE doesn't allow expando properties for those
        // (2) It might have bindings (e.g., it has a data-bind attribute, or it's a marker for a containerless template)
        var isElement = (nodeVerified.nodeType === 1);
        if (isElement) // Workaround IE <= 8 HTML parsing weirdness
            ko.virtualElements.normaliseVirtualElementDomStructure(nodeVerified);

        var shouldApplyBindings = (isElement && bindingContextMayDifferFromDomParentElement)             // Case (1)
                               || ko.bindingProvider['instance']['nodeHasBindings'](nodeVerified);       // Case (2)
        if (shouldApplyBindings)
            shouldBindDescendants = applyBindingsToNodeInternal(nodeVerified, null, bindingContext, bindingContextMayDifferFromDomParentElement)['shouldBindDescendants'];

        if (shouldBindDescendants && !bindingDoesNotRecurseIntoElementTypes[ko.utils.tagNameLower(nodeVerified)]) {
            // We're recursing automatically into (real or virtual) child nodes without changing binding contexts. So,
            //  * For children of a *real* element, the binding context is certainly the same as on their DOM .parentNode,
            //    hence bindingContextsMayDifferFromDomParentElement is false
            //  * For children of a *virtual* element, we can't be sure. Evaluating .parentNode on those children may
            //    skip over any number of intermediate virtual elements, any of which might define a custom binding context,
            //    hence bindingContextsMayDifferFromDomParentElement is true
            applyBindingsToDescendantsInternal(bindingContext, nodeVerified, /* bindingContextsMayDifferFromDomParentElement: */ !isElement);
        }
    }

    var boundElementDomDataKey = ko.utils.domData.nextKey();


    function topologicalSortBindings(bindings) {
        // Depth-first sort
        var result = [],                // The list of key/handler pairs that we will return
            bindingsConsidered = {},    // A temporary record of which bindings are already in 'result'
            cyclicDependencyStack = []; // Keeps track of a depth-search so that, if there's a cycle, we know which bindings caused it
        ko.utils.objectForEach(bindings, function pushBinding(bindingKey) {
            if (!bindingsConsidered[bindingKey]) {
                var binding = ko['getBindingHandler'](bindingKey);
                if (binding) {
                    // First add dependencies (if any) of the current binding
                    if (binding['after']) {
                        cyclicDependencyStack.push(bindingKey);
                        ko.utils.arrayForEach(binding['after'], function(bindingDependencyKey) {
                            if (bindings[bindingDependencyKey]) {
                                if (ko.utils.arrayIndexOf(cyclicDependencyStack, bindingDependencyKey) !== -1) {
                                    throw Error("Cannot combine the following bindings, because they have a cyclic dependency: " + cyclicDependencyStack.join(", "));
                                } else {
                                    pushBinding(bindingDependencyKey);
                                }
                            }
                        });
                        cyclicDependencyStack.length--;
                    }
                    // Next add the current binding
                    result.push({ key: bindingKey, handler: binding });
                }
                bindingsConsidered[bindingKey] = true;
            }
        });

        return result;
    }

    function applyBindingsToNodeInternal(node, sourceBindings, bindingContext, bindingContextMayDifferFromDomParentElement) {
        // Prevent multiple applyBindings calls for the same node, except when a binding value is specified
        var alreadyBound = ko.utils.domData.get(node, boundElementDomDataKey);
        if (!sourceBindings) {
            if (alreadyBound) {
                throw Error("You cannot apply bindings multiple times to the same element.");
            }
            ko.utils.domData.set(node, boundElementDomDataKey, true);
        }

        // Optimization: Don't store the binding context on this node if it's definitely the same as on node.parentNode, because
        // we can easily recover it just by scanning up the node's ancestors in the DOM
        // (note: here, parent node means "real DOM parent" not "virtual parent", as there's no O(1) way to find the virtual parent)
        if (!alreadyBound && bindingContextMayDifferFromDomParentElement)
            ko.storedBindingContextForNode(node, bindingContext);

        // Use bindings if given, otherwise fall back on asking the bindings provider to give us some bindings
        var bindings;
        if (sourceBindings && typeof sourceBindings !== 'function') {
            bindings = sourceBindings;
        } else {
            var provider = ko.bindingProvider['instance'],
                getBindings = provider['getBindingAccessors'] || getBindingsAndMakeAccessors;

            // Get the binding from the provider within a computed observable so that we can update the bindings whenever
            // the binding context is updated or if the binding provider accesses observables.
            var bindingsUpdater = ko.dependentObservable(
                function() {
                    bindings = sourceBindings ? sourceBindings(bindingContext, node) : getBindings.call(provider, node, bindingContext);
                    // Register a dependency on the binding context to support observable view models.
                    if (bindings && bindingContext._subscribable)
                        bindingContext._subscribable();
                    return bindings;
                },
                null, { disposeWhenNodeIsRemoved: node }
            );

            if (!bindings || !bindingsUpdater.isActive())
                bindingsUpdater = null;
        }

        var bindingHandlerThatControlsDescendantBindings;
        if (bindings) {
            // Return the value accessor for a given binding. When bindings are static (won't be updated because of a binding
            // context update), just return the value accessor from the binding. Otherwise, return a function that always gets
            // the latest binding value and registers a dependency on the binding updater.
            var getValueAccessor = bindingsUpdater
                ? function(bindingKey) {
                    return function() {
                        return evaluateValueAccessor(bindingsUpdater()[bindingKey]);
                    };
                } : function(bindingKey) {
                    return bindings[bindingKey];
                };

            // Use of allBindings as a function is maintained for backwards compatibility, but its use is deprecated
            function allBindings() {
                return ko.utils.objectMap(bindingsUpdater ? bindingsUpdater() : bindings, evaluateValueAccessor);
            }
            // The following is the 3.x allBindings API
            allBindings['get'] = function(key) {
                return bindings[key] && evaluateValueAccessor(getValueAccessor(key));
            };
            allBindings['has'] = function(key) {
                return key in bindings;
            };

            // First put the bindings into the right order
            var orderedBindings = topologicalSortBindings(bindings);

            // Go through the sorted bindings, calling init and update for each
            ko.utils.arrayForEach(orderedBindings, function(bindingKeyAndHandler) {
                // Note that topologicalSortBindings has already filtered out any nonexistent binding handlers,
                // so bindingKeyAndHandler.handler will always be nonnull.
                var handlerInitFn = bindingKeyAndHandler.handler["init"],
                    handlerUpdateFn = bindingKeyAndHandler.handler["update"],
                    bindingKey = bindingKeyAndHandler.key;

                if (node.nodeType === 8) {
                    validateThatBindingIsAllowedForVirtualElements(bindingKey);
                }

                try {
                    // Run init, ignoring any dependencies
                    if (typeof handlerInitFn == "function") {
                        ko.dependencyDetection.ignore(function() {
                            var initResult = handlerInitFn(node, getValueAccessor(bindingKey), allBindings, bindingContext['$data'], bindingContext);

                            // If this binding handler claims to control descendant bindings, make a note of this
                            if (initResult && initResult['controlsDescendantBindings']) {
                                if (bindingHandlerThatControlsDescendantBindings !== undefined)
                                    throw new Error("Multiple bindings (" + bindingHandlerThatControlsDescendantBindings + " and " + bindingKey + ") are trying to control descendant bindings of the same element. You cannot use these bindings together on the same element.");
                                bindingHandlerThatControlsDescendantBindings = bindingKey;
                            }
                        });
                    }

                    // Run update in its own computed wrapper
                    if (typeof handlerUpdateFn == "function") {
                        ko.dependentObservable(
                            function() {
                                handlerUpdateFn(node, getValueAccessor(bindingKey), allBindings, bindingContext['$data'], bindingContext);
                            },
                            null,
                            { disposeWhenNodeIsRemoved: node }
                        );
                    }
                } catch (ex) {
                    ex.message = "Unable to process binding \"" + bindingKey + ": " + bindings[bindingKey] + "\"\nMessage: " + ex.message;
                    throw ex;
                }
            });
        }

        return {
            'shouldBindDescendants': bindingHandlerThatControlsDescendantBindings === undefined
        };
    };

    var storedBindingContextDomDataKey = ko.utils.domData.nextKey();
    ko.storedBindingContextForNode = function (node, bindingContext) {
        if (arguments.length == 2) {
            ko.utils.domData.set(node, storedBindingContextDomDataKey, bindingContext);
            if (bindingContext._subscribable)
                bindingContext._subscribable._addNode(node);
        } else {
            return ko.utils.domData.get(node, storedBindingContextDomDataKey);
        }
    }

    function getBindingContext(viewModelOrBindingContext) {
        return viewModelOrBindingContext && (viewModelOrBindingContext instanceof ko.bindingContext)
            ? viewModelOrBindingContext
            : new ko.bindingContext(viewModelOrBindingContext);
    }

    ko.applyBindingAccessorsToNode = function (node, bindings, viewModelOrBindingContext) {
        if (node.nodeType === 1) // If it's an element, workaround IE <= 8 HTML parsing weirdness
            ko.virtualElements.normaliseVirtualElementDomStructure(node);
        return applyBindingsToNodeInternal(node, bindings, getBindingContext(viewModelOrBindingContext), true);
    };

    ko.applyBindingsToNode = function (node, bindings, viewModelOrBindingContext) {
        var context = getBindingContext(viewModelOrBindingContext);
        return ko.applyBindingAccessorsToNode(node, makeBindingAccessors(bindings, context, node), context);
    };

    ko.applyBindingsToDescendants = function(viewModelOrBindingContext, rootNode) {
        if (rootNode.nodeType === 1 || rootNode.nodeType === 8)
            applyBindingsToDescendantsInternal(getBindingContext(viewModelOrBindingContext), rootNode, true);
    };

    ko.applyBindings = function (viewModelOrBindingContext, rootNode) {
        // If jQuery is loaded after Knockout, we won't initially have access to it. So save it here.
        if (!jQueryInstance && window['jQuery']) {
            jQueryInstance = window['jQuery'];
        }

        if (rootNode && (rootNode.nodeType !== 1) && (rootNode.nodeType !== 8))
            throw new Error("ko.applyBindings: first parameter should be your view model; second parameter should be a DOM node");
        rootNode = rootNode || window.document.body; // Make "rootNode" parameter optional

        applyBindingsToNodeAndDescendantsInternal(getBindingContext(viewModelOrBindingContext), rootNode, true);
    };

    // Retrieving binding context from arbitrary nodes
    ko.contextFor = function(node) {
        // We can only do something meaningful for elements and comment nodes (in particular, not text nodes, as IE can't store domdata for them)
        switch (node.nodeType) {
            case 1:
            case 8:
                var context = ko.storedBindingContextForNode(node);
                if (context) return context;
                if (node.parentNode) return ko.contextFor(node.parentNode);
                break;
        }
        return undefined;
    };
    ko.dataFor = function(node) {
        var context = ko.contextFor(node);
        return context ? context['$data'] : undefined;
    };

    ko.exportSymbol('bindingHandlers', ko.bindingHandlers);
    ko.exportSymbol('applyBindings', ko.applyBindings);
    ko.exportSymbol('applyBindingsToDescendants', ko.applyBindingsToDescendants);
    ko.exportSymbol('applyBindingAccessorsToNode', ko.applyBindingAccessorsToNode);
    ko.exportSymbol('applyBindingsToNode', ko.applyBindingsToNode);
    ko.exportSymbol('contextFor', ko.contextFor);
    ko.exportSymbol('dataFor', ko.dataFor);
})();
(function(undefined) {
    var loadingSubscribablesCache = {}, // Tracks component loads that are currently in flight
        loadedDefinitionsCache = {};    // Tracks component loads that have already completed

    ko.components = {
        get: function(componentName, callback) {
            var cachedDefinition = getObjectOwnProperty(loadedDefinitionsCache, componentName);
            if (cachedDefinition) {
                // It's already loaded and cached. Reuse the same definition object.
                // Note that for API consistency, even cache hits complete asynchronously by default.
                // You can bypass this by putting synchronous:true on your component config.
                if (cachedDefinition.isSynchronousComponent) {
                    ko.dependencyDetection.ignore(function() { // See comment in loaderRegistryBehaviors.js for reasoning
                        callback(cachedDefinition.definition);
                    });
                } else {
                    ko.tasks.schedule(function() { callback(cachedDefinition.definition); });
                }
            } else {
                // Join the loading process that is already underway, or start a new one.
                loadComponentAndNotify(componentName, callback);
            }
        },

        clearCachedDefinition: function(componentName) {
            delete loadedDefinitionsCache[componentName];
        },

        _getFirstResultFromLoaders: getFirstResultFromLoaders
    };

    function getObjectOwnProperty(obj, propName) {
        return obj.hasOwnProperty(propName) ? obj[propName] : undefined;
    }

    function loadComponentAndNotify(componentName, callback) {
        var subscribable = getObjectOwnProperty(loadingSubscribablesCache, componentName),
            completedAsync;
        if (!subscribable) {
            // It's not started loading yet. Start loading, and when it's done, move it to loadedDefinitionsCache.
            subscribable = loadingSubscribablesCache[componentName] = new ko.subscribable();
            subscribable.subscribe(callback);

            beginLoadingComponent(componentName, function(definition, config) {
                var isSynchronousComponent = !!(config && config['synchronous']);
                loadedDefinitionsCache[componentName] = { definition: definition, isSynchronousComponent: isSynchronousComponent };
                delete loadingSubscribablesCache[componentName];

                // For API consistency, all loads complete asynchronously. However we want to avoid
                // adding an extra task schedule if it's unnecessary (i.e., the completion is already
                // async).
                //
                // You can bypass the 'always asynchronous' feature by putting the synchronous:true
                // flag on your component configuration when you register it.
                if (completedAsync || isSynchronousComponent) {
                    // Note that notifySubscribers ignores any dependencies read within the callback.
                    // See comment in loaderRegistryBehaviors.js for reasoning
                    subscribable['notifySubscribers'](definition);
                } else {
                    ko.tasks.schedule(function() {
                        subscribable['notifySubscribers'](definition);
                    });
                }
            });
            completedAsync = true;
        } else {
            subscribable.subscribe(callback);
        }
    }

    function beginLoadingComponent(componentName, callback) {
        getFirstResultFromLoaders('getConfig', [componentName], function(config) {
            if (config) {
                // We have a config, so now load its definition
                getFirstResultFromLoaders('loadComponent', [componentName, config], function(definition) {
                    callback(definition, config);
                });
            } else {
                // The component has no config - it's unknown to all the loaders.
                // Note that this is not an error (e.g., a module loading error) - that would abort the
                // process and this callback would not run. For this callback to run, all loaders must
                // have confirmed they don't know about this component.
                callback(null, null);
            }
        });
    }

    function getFirstResultFromLoaders(methodName, argsExceptCallback, callback, candidateLoaders) {
        // On the first call in the stack, start with the full set of loaders
        if (!candidateLoaders) {
            candidateLoaders = ko.components['loaders'].slice(0); // Use a copy, because we'll be mutating this array
        }

        // Try the next candidate
        var currentCandidateLoader = candidateLoaders.shift();
        if (currentCandidateLoader) {
            var methodInstance = currentCandidateLoader[methodName];
            if (methodInstance) {
                var wasAborted = false,
                    synchronousReturnValue = methodInstance.apply(currentCandidateLoader, argsExceptCallback.concat(function(result) {
                        if (wasAborted) {
                            callback(null);
                        } else if (result !== null) {
                            // This candidate returned a value. Use it.
                            callback(result);
                        } else {
                            // Try the next candidate
                            getFirstResultFromLoaders(methodName, argsExceptCallback, callback, candidateLoaders);
                        }
                    }));

                // Currently, loaders may not return anything synchronously. This leaves open the possibility
                // that we'll extend the API to support synchronous return values in the future. It won't be
                // a breaking change, because currently no loader is allowed to return anything except undefined.
                if (synchronousReturnValue !== undefined) {
                    wasAborted = true;

                    // Method to suppress exceptions will remain undocumented. This is only to keep
                    // KO's specs running tidily, since we can observe the loading got aborted without
                    // having exceptions cluttering up the console too.
                    if (!currentCandidateLoader['suppressLoaderExceptions']) {
                        throw new Error('Component loaders must supply values by invoking the callback, not by returning values synchronously.');
                    }
                }
            } else {
                // This candidate doesn't have the relevant handler. Synchronously move on to the next one.
                getFirstResultFromLoaders(methodName, argsExceptCallback, callback, candidateLoaders);
            }
        } else {
            // No candidates returned a value
            callback(null);
        }
    }

    // Reference the loaders via string name so it's possible for developers
    // to replace the whole array by assigning to ko.components.loaders
    ko.components['loaders'] = [];

    ko.exportSymbol('components', ko.components);
    ko.exportSymbol('components.get', ko.components.get);
    ko.exportSymbol('components.clearCachedDefinition', ko.components.clearCachedDefinition);
})();
(function(undefined) {

    // The default loader is responsible for two things:
    // 1. Maintaining the default in-memory registry of component configuration objects
    //    (i.e., the thing you're writing to when you call ko.components.register(someName, ...))
    // 2. Answering requests for components by fetching configuration objects
    //    from that default in-memory registry and resolving them into standard
    //    component definition objects (of the form { createViewModel: ..., template: ... })
    // Custom loaders may override either of these facilities, i.e.,
    // 1. To supply configuration objects from some other source (e.g., conventions)
    // 2. Or, to resolve configuration objects by loading viewmodels/templates via arbitrary logic.

    var defaultConfigRegistry = {};

    ko.components.register = function(componentName, config) {
        if (!config) {
            throw new Error('Invalid configuration for ' + componentName);
        }

        if (ko.components.isRegistered(componentName)) {
            throw new Error('Component ' + componentName + ' is already registered');
        }

        defaultConfigRegistry[componentName] = config;
    };

    ko.components.isRegistered = function(componentName) {
        return defaultConfigRegistry.hasOwnProperty(componentName);
    };

    ko.components.unregister = function(componentName) {
        delete defaultConfigRegistry[componentName];
        ko.components.clearCachedDefinition(componentName);
    };

    ko.components.defaultLoader = {
        'getConfig': function(componentName, callback) {
            var result = defaultConfigRegistry.hasOwnProperty(componentName)
                ? defaultConfigRegistry[componentName]
                : null;
            callback(result);
        },

        'loadComponent': function(componentName, config, callback) {
            var errorCallback = makeErrorCallback(componentName);
            possiblyGetConfigFromAmd(errorCallback, config, function(loadedConfig) {
                resolveConfig(componentName, errorCallback, loadedConfig, callback);
            });
        },

        'loadTemplate': function(componentName, templateConfig, callback) {
            resolveTemplate(makeErrorCallback(componentName), templateConfig, callback);
        },

        'loadViewModel': function(componentName, viewModelConfig, callback) {
            resolveViewModel(makeErrorCallback(componentName), viewModelConfig, callback);
        }
    };

    var createViewModelKey = 'createViewModel';

    // Takes a config object of the form { template: ..., viewModel: ... }, and asynchronously convert it
    // into the standard component definition format:
    //    { template: <ArrayOfDomNodes>, createViewModel: function(params, componentInfo) { ... } }.
    // Since both template and viewModel may need to be resolved asynchronously, both tasks are performed
    // in parallel, and the results joined when both are ready. We don't depend on any promises infrastructure,
    // so this is implemented manually below.
    function resolveConfig(componentName, errorCallback, config, callback) {
        var result = {},
            makeCallBackWhenZero = 2,
            tryIssueCallback = function() {
                if (--makeCallBackWhenZero === 0) {
                    callback(result);
                }
            },
            templateConfig = config['template'],
            viewModelConfig = config['viewModel'];

        if (templateConfig) {
            possiblyGetConfigFromAmd(errorCallback, templateConfig, function(loadedConfig) {
                ko.components._getFirstResultFromLoaders('loadTemplate', [componentName, loadedConfig], function(resolvedTemplate) {
                    result['template'] = resolvedTemplate;
                    tryIssueCallback();
                });
            });
        } else {
            tryIssueCallback();
        }

        if (viewModelConfig) {
            possiblyGetConfigFromAmd(errorCallback, viewModelConfig, function(loadedConfig) {
                ko.components._getFirstResultFromLoaders('loadViewModel', [componentName, loadedConfig], function(resolvedViewModel) {
                    result[createViewModelKey] = resolvedViewModel;
                    tryIssueCallback();
                });
            });
        } else {
            tryIssueCallback();
        }
    }

    function resolveTemplate(errorCallback, templateConfig, callback) {
        if (typeof templateConfig === 'string') {
            // Markup - parse it
            callback(ko.utils.parseHtmlFragment(templateConfig));
        } else if (templateConfig instanceof Array) {
            // Assume already an array of DOM nodes - pass through unchanged
            callback(templateConfig);
        } else if (isDocumentFragment(templateConfig)) {
            // Document fragment - use its child nodes
            callback(ko.utils.makeArray(templateConfig.childNodes));
        } else if (templateConfig['element']) {
            var element = templateConfig['element'];
            if (isDomElement(element)) {
                // Element instance - copy its child nodes
                callback(cloneNodesFromTemplateSourceElement(element));
            } else if (typeof element === 'string') {
                // Element ID - find it, then copy its child nodes
                var elemInstance = document.getElementById(element);
                if (elemInstance) {
                    callback(cloneNodesFromTemplateSourceElement(elemInstance));
                } else {
                    errorCallback('Cannot find element with ID ' + element);
                }
            } else {
                errorCallback('Unknown element type: ' + element);
            }
        } else {
            errorCallback('Unknown template value: ' + templateConfig);
        }
    }

    function resolveViewModel(errorCallback, viewModelConfig, callback) {
        if (typeof viewModelConfig === 'function') {
            // Constructor - convert to standard factory function format
            // By design, this does *not* supply componentInfo to the constructor, as the intent is that
            // componentInfo contains non-viewmodel data (e.g., the component's element) that should only
            // be used in factory functions, not viewmodel constructors.
            callback(function (params /*, componentInfo */) {
                return new viewModelConfig(params);
            });
        } else if (typeof viewModelConfig[createViewModelKey] === 'function') {
            // Already a factory function - use it as-is
            callback(viewModelConfig[createViewModelKey]);
        } else if ('instance' in viewModelConfig) {
            // Fixed object instance - promote to createViewModel format for API consistency
            var fixedInstance = viewModelConfig['instance'];
            callback(function (params, componentInfo) {
                return fixedInstance;
            });
        } else if ('viewModel' in viewModelConfig) {
            // Resolved AMD module whose value is of the form { viewModel: ... }
            resolveViewModel(errorCallback, viewModelConfig['viewModel'], callback);
        } else {
            errorCallback('Unknown viewModel value: ' + viewModelConfig);
        }
    }

    function cloneNodesFromTemplateSourceElement(elemInstance) {
        switch (ko.utils.tagNameLower(elemInstance)) {
            case 'script':
                return ko.utils.parseHtmlFragment(elemInstance.text);
            case 'textarea':
                return ko.utils.parseHtmlFragment(elemInstance.value);
            case 'template':
                // For browsers with proper <template> element support (i.e., where the .content property
                // gives a document fragment), use that document fragment.
                if (isDocumentFragment(elemInstance.content)) {
                    return ko.utils.cloneNodes(elemInstance.content.childNodes);
                }
        }

        // Regular elements such as <div>, and <template> elements on old browsers that don't really
        // understand <template> and just treat it as a regular container
        return ko.utils.cloneNodes(elemInstance.childNodes);
    }

    function isDomElement(obj) {
        if (window['HTMLElement']) {
            return obj instanceof HTMLElement;
        } else {
            return obj && obj.tagName && obj.nodeType === 1;
        }
    }

    function isDocumentFragment(obj) {
        if (window['DocumentFragment']) {
            return obj instanceof DocumentFragment;
        } else {
            return obj && obj.nodeType === 11;
        }
    }

    function possiblyGetConfigFromAmd(errorCallback, config, callback) {
        if (typeof config['require'] === 'string') {
            // The config is the value of an AMD module
            if (amdRequire || window['require']) {
                (amdRequire || window['require'])([config['require']], callback);
            } else {
                errorCallback('Uses require, but no AMD loader is present');
            }
        } else {
            callback(config);
        }
    }

    function makeErrorCallback(componentName) {
        return function (message) {
            throw new Error('Component \'' + componentName + '\': ' + message);
        };
    }

    ko.exportSymbol('components.register', ko.components.register);
    ko.exportSymbol('components.isRegistered', ko.components.isRegistered);
    ko.exportSymbol('components.unregister', ko.components.unregister);

    // Expose the default loader so that developers can directly ask it for configuration
    // or to resolve configuration
    ko.exportSymbol('components.defaultLoader', ko.components.defaultLoader);

    // By default, the default loader is the only registered component loader
    ko.components['loaders'].push(ko.components.defaultLoader);

    // Privately expose the underlying config registry for use in old-IE shim
    ko.components._allRegisteredComponents = defaultConfigRegistry;
})();
(function (undefined) {
    // Overridable API for determining which component name applies to a given node. By overriding this,
    // you can for example map specific tagNames to components that are not preregistered.
    ko.components['getComponentNameForNode'] = function(node) {
        var tagNameLower = ko.utils.tagNameLower(node);
        if (ko.components.isRegistered(tagNameLower)) {
            // Try to determine that this node can be considered a *custom* element; see https://github.com/knockout/knockout/issues/1603
            if (tagNameLower.indexOf('-') != -1 || ('' + node) == "[object HTMLUnknownElement]" || (ko.utils.ieVersion <= 8 && node.tagName === tagNameLower)) {
                return tagNameLower;
            }
        }
    };

    ko.components.addBindingsForCustomElement = function(allBindings, node, bindingContext, valueAccessors) {
        // Determine if it's really a custom element matching a component
        if (node.nodeType === 1) {
            var componentName = ko.components['getComponentNameForNode'](node);
            if (componentName) {
                // It does represent a component, so add a component binding for it
                allBindings = allBindings || {};

                if (allBindings['component']) {
                    // Avoid silently overwriting some other 'component' binding that may already be on the element
                    throw new Error('Cannot use the "component" binding on a custom element matching a component');
                }

                var componentBindingValue = { 'name': componentName, 'params': getComponentParamsFromCustomElement(node, bindingContext) };

                allBindings['component'] = valueAccessors
                    ? function() { return componentBindingValue; }
                    : componentBindingValue;
            }
        }

        return allBindings;
    }

    var nativeBindingProviderInstance = new ko.bindingProvider();

    function getComponentParamsFromCustomElement(elem, bindingContext) {
        var paramsAttribute = elem.getAttribute('params');

        if (paramsAttribute) {
            var params = nativeBindingProviderInstance['parseBindingsString'](paramsAttribute, bindingContext, elem, { 'valueAccessors': true, 'bindingParams': true }),
                rawParamComputedValues = ko.utils.objectMap(params, function(paramValue, paramName) {
                    return ko.computed(paramValue, null, { disposeWhenNodeIsRemoved: elem });
                }),
                result = ko.utils.objectMap(rawParamComputedValues, function(paramValueComputed, paramName) {
                    var paramValue = paramValueComputed.peek();
                    // Does the evaluation of the parameter value unwrap any observables?
                    if (!paramValueComputed.isActive()) {
                        // No it doesn't, so there's no need for any computed wrapper. Just pass through the supplied value directly.
                        // Example: "someVal: firstName, age: 123" (whether or not firstName is an observable/computed)
                        return paramValue;
                    } else {
                        // Yes it does. Supply a computed property that unwraps both the outer (binding expression)
                        // level of observability, and any inner (resulting model value) level of observability.
                        // This means the component doesn't have to worry about multiple unwrapping. If the value is a
                        // writable observable, the computed will also be writable and pass the value on to the observable.
                        return ko.computed({
                            'read': function() {
                                return ko.utils.unwrapObservable(paramValueComputed());
                            },
                            'write': ko.isWriteableObservable(paramValue) && function(value) {
                                paramValueComputed()(value);
                            },
                            disposeWhenNodeIsRemoved: elem
                        });
                    }
                });

            // Give access to the raw computeds, as long as that wouldn't overwrite any custom param also called '$raw'
            // This is in case the developer wants to react to outer (binding) observability separately from inner
            // (model value) observability, or in case the model value observable has subobservables.
            if (!result.hasOwnProperty('$raw')) {
                result['$raw'] = rawParamComputedValues;
            }

            return result;
        } else {
            // For consistency, absence of a "params" attribute is treated the same as the presence of
            // any empty one. Otherwise component viewmodels need special code to check whether or not
            // 'params' or 'params.$raw' is null/undefined before reading subproperties, which is annoying.
            return { '$raw': {} };
        }
    }

    // --------------------------------------------------------------------------------
    // Compatibility code for older (pre-HTML5) IE browsers

    if (ko.utils.ieVersion < 9) {
        // Whenever you preregister a component, enable it as a custom element in the current document
        ko.components['register'] = (function(originalFunction) {
            return function(componentName) {
                document.createElement(componentName); // Allows IE<9 to parse markup containing the custom element
                return originalFunction.apply(this, arguments);
            }
        })(ko.components['register']);

        // Whenever you create a document fragment, enable all preregistered component names as custom elements
        // This is needed to make innerShiv/jQuery HTML parsing correctly handle the custom elements
        document.createDocumentFragment = (function(originalFunction) {
            return function() {
                var newDocFrag = originalFunction(),
                    allComponents = ko.components._allRegisteredComponents;
                for (var componentName in allComponents) {
                    if (allComponents.hasOwnProperty(componentName)) {
                        newDocFrag.createElement(componentName);
                    }
                }
                return newDocFrag;
            };
        })(document.createDocumentFragment);
    }
})();(function(undefined) {

    var componentLoadingOperationUniqueId = 0;

    ko.bindingHandlers['component'] = {
        'init': function(element, valueAccessor, ignored1, ignored2, bindingContext) {
            var currentViewModel,
                currentLoadingOperationId,
                disposeAssociatedComponentViewModel = function () {
                    var currentViewModelDispose = currentViewModel && currentViewModel['dispose'];
                    if (typeof currentViewModelDispose === 'function') {
                        currentViewModelDispose.call(currentViewModel);
                    }
                    currentViewModel = null;
                    // Any in-flight loading operation is no longer relevant, so make sure we ignore its completion
                    currentLoadingOperationId = null;
                },
                originalChildNodes = ko.utils.makeArray(ko.virtualElements.childNodes(element));

            ko.utils.domNodeDisposal.addDisposeCallback(element, disposeAssociatedComponentViewModel);

            ko.computed(function () {
                var value = ko.utils.unwrapObservable(valueAccessor()),
                    componentName, componentParams;

                if (typeof value === 'string') {
                    componentName = value;
                } else {
                    componentName = ko.utils.unwrapObservable(value['name']);
                    componentParams = ko.utils.unwrapObservable(value['params']);
                }

                if (!componentName) {
                    throw new Error('No component name specified');
                }

                var loadingOperationId = currentLoadingOperationId = ++componentLoadingOperationUniqueId;
                ko.components.get(componentName, function(componentDefinition) {
                    // If this is not the current load operation for this element, ignore it.
                    if (currentLoadingOperationId !== loadingOperationId) {
                        return;
                    }

                    // Clean up previous state
                    disposeAssociatedComponentViewModel();

                    // Instantiate and bind new component. Implicitly this cleans any old DOM nodes.
                    if (!componentDefinition) {
                        throw new Error('Unknown component \'' + componentName + '\'');
                    }
                    cloneTemplateIntoElement(componentName, componentDefinition, element);
                    var componentViewModel = createViewModel(componentDefinition, element, originalChildNodes, componentParams),
                        childBindingContext = bindingContext['createChildContext'](componentViewModel, /* dataItemAlias */ undefined, function(ctx) {
                            ctx['$component'] = componentViewModel;
                            ctx['$componentTemplateNodes'] = originalChildNodes;
                        });
                    currentViewModel = componentViewModel;
                    ko.applyBindingsToDescendants(childBindingContext, element);
                });
            }, null, { disposeWhenNodeIsRemoved: element });

            return { 'controlsDescendantBindings': true };
        }
    };

    ko.virtualElements.allowedBindings['component'] = true;

    function cloneTemplateIntoElement(componentName, componentDefinition, element) {
        var template = componentDefinition['template'];
        if (!template) {
            throw new Error('Component \'' + componentName + '\' has no template');
        }

        var clonedNodesArray = ko.utils.cloneNodes(template);
        ko.virtualElements.setDomNodeChildren(element, clonedNodesArray);
    }

    function createViewModel(componentDefinition, element, originalChildNodes, componentParams) {
        var componentViewModelFactory = componentDefinition['createViewModel'];
        return componentViewModelFactory
            ? componentViewModelFactory.call(componentDefinition, componentParams, { 'element': element, 'templateNodes': originalChildNodes })
            : componentParams; // Template-only component
    }

})();
var attrHtmlToJavascriptMap = { 'class': 'className', 'for': 'htmlFor' };
ko.bindingHandlers['attr'] = {
    'update': function(element, valueAccessor, allBindings) {
        var value = ko.utils.unwrapObservable(valueAccessor()) || {};
        ko.utils.objectForEach(value, function(attrName, attrValue) {
            attrValue = ko.utils.unwrapObservable(attrValue);

            // To cover cases like "attr: { checked:someProp }", we want to remove the attribute entirely
            // when someProp is a "no value"-like value (strictly null, false, or undefined)
            // (because the absence of the "checked" attr is how to mark an element as not checked, etc.)
            var toRemove = (attrValue === false) || (attrValue === null) || (attrValue === undefined);
            if (toRemove)
                element.removeAttribute(attrName);

            // In IE <= 7 and IE8 Quirks Mode, you have to use the Javascript property name instead of the
            // HTML attribute name for certain attributes. IE8 Standards Mode supports the correct behavior,
            // but instead of figuring out the mode, we'll just set the attribute through the Javascript
            // property for IE <= 8.
            if (ko.utils.ieVersion <= 8 && attrName in attrHtmlToJavascriptMap) {
                attrName = attrHtmlToJavascriptMap[attrName];
                if (toRemove)
                    element.removeAttribute(attrName);
                else
                    element[attrName] = attrValue;
            } else if (!toRemove) {
                element.setAttribute(attrName, attrValue.toString());
            }

            // Treat "name" specially - although you can think of it as an attribute, it also needs
            // special handling on older versions of IE (https://github.com/SteveSanderson/knockout/pull/333)
            // Deliberately being case-sensitive here because XHTML would regard "Name" as a different thing
            // entirely, and there's no strong reason to allow for such casing in HTML.
            if (attrName === "name") {
                ko.utils.setElementName(element, toRemove ? "" : attrValue.toString());
            }
        });
    }
};
(function() {

ko.bindingHandlers['checked'] = {
    'after': ['value', 'attr'],
    'init': function (element, valueAccessor, allBindings) {
        var checkedValue = ko.pureComputed(function() {
            // Treat "value" like "checkedValue" when it is included with "checked" binding
            if (allBindings['has']('checkedValue')) {
                return ko.utils.unwrapObservable(allBindings.get('checkedValue'));
            } else if (allBindings['has']('value')) {
                return ko.utils.unwrapObservable(allBindings.get('value'));
            }

            return element.value;
        });

        function updateModel() {
            // This updates the model value from the view value.
            // It runs in response to DOM events (click) and changes in checkedValue.
            var isChecked = element.checked,
                elemValue = useCheckedValue ? checkedValue() : isChecked;

            // When we're first setting up this computed, don't change any model state.
            if (ko.computedContext.isInitial()) {
                return;
            }

            // We can ignore unchecked radio buttons, because some other radio
            // button will be getting checked, and that one can take care of updating state.
            if (isRadio && !isChecked) {
                return;
            }

            var modelValue = ko.dependencyDetection.ignore(valueAccessor);
            if (valueIsArray) {
                var writableValue = rawValueIsNonArrayObservable ? modelValue.peek() : modelValue;
                if (oldElemValue !== elemValue) {
                    // When we're responding to the checkedValue changing, and the element is
                    // currently checked, replace the old elem value with the new elem value
                    // in the model array.
                    if (isChecked) {
                        ko.utils.addOrRemoveItem(writableValue, elemValue, true);
                        ko.utils.addOrRemoveItem(writableValue, oldElemValue, false);
                    }

                    oldElemValue = elemValue;
                } else {
                    // When we're responding to the user having checked/unchecked a checkbox,
                    // add/remove the element value to the model array.
                    ko.utils.addOrRemoveItem(writableValue, elemValue, isChecked);
                }
                if (rawValueIsNonArrayObservable && ko.isWriteableObservable(modelValue)) {
                    modelValue(writableValue);
                }
            } else {
                ko.expressionRewriting.writeValueToProperty(modelValue, allBindings, 'checked', elemValue, true);
            }
        };

        function updateView() {
            // This updates the view value from the model value.
            // It runs in response to changes in the bound (checked) value.
            var modelValue = ko.utils.unwrapObservable(valueAccessor());

            if (valueIsArray) {
                // When a checkbox is bound to an array, being checked represents its value being present in that array
                element.checked = ko.utils.arrayIndexOf(modelValue, checkedValue()) >= 0;
            } else if (isCheckbox) {
                // When a checkbox is bound to any other value (not an array), being checked represents the value being trueish
                element.checked = modelValue;
            } else {
                // For radio buttons, being checked means that the radio button's value corresponds to the model value
                element.checked = (checkedValue() === modelValue);
            }
        };

        var isCheckbox = element.type == "checkbox",
            isRadio = element.type == "radio";

        // Only bind to check boxes and radio buttons
        if (!isCheckbox && !isRadio) {
            return;
        }

        var rawValue = valueAccessor(),
            valueIsArray = isCheckbox && (ko.utils.unwrapObservable(rawValue) instanceof Array),
            rawValueIsNonArrayObservable = !(valueIsArray && rawValue.push && rawValue.splice),
            oldElemValue = valueIsArray ? checkedValue() : undefined,
            useCheckedValue = isRadio || valueIsArray;

        // IE 6 won't allow radio buttons to be selected unless they have a name
        if (isRadio && !element.name)
            ko.bindingHandlers['uniqueName']['init'](element, function() { return true });

        // Set up two computeds to update the binding:

        // The first responds to changes in the checkedValue value and to element clicks
        ko.computed(updateModel, null, { disposeWhenNodeIsRemoved: element });
        ko.utils.registerEventHandler(element, "click", updateModel);

        // The second responds to changes in the model value (the one associated with the checked binding)
        ko.computed(updateView, null, { disposeWhenNodeIsRemoved: element });

        rawValue = undefined;
    }
};
ko.expressionRewriting.twoWayBindings['checked'] = true;

ko.bindingHandlers['checkedValue'] = {
    'update': function (element, valueAccessor) {
        element.value = ko.utils.unwrapObservable(valueAccessor());
    }
};

})();var classesWrittenByBindingKey = '__ko__cssValue';
ko.bindingHandlers['css'] = {
    'update': function (element, valueAccessor) {
        var value = ko.utils.unwrapObservable(valueAccessor());
        if (value !== null && typeof value == "object") {
            ko.utils.objectForEach(value, function(className, shouldHaveClass) {
                shouldHaveClass = ko.utils.unwrapObservable(shouldHaveClass);
                ko.utils.toggleDomNodeCssClass(element, className, shouldHaveClass);
            });
        } else {
            value = ko.utils.stringTrim(String(value || '')); // Make sure we don't try to store or set a non-string value
            ko.utils.toggleDomNodeCssClass(element, element[classesWrittenByBindingKey], false);
            element[classesWrittenByBindingKey] = value;
            ko.utils.toggleDomNodeCssClass(element, value, true);
        }
    }
};
ko.bindingHandlers['enable'] = {
    'update': function (element, valueAccessor) {
        var value = ko.utils.unwrapObservable(valueAccessor());
        if (value && element.disabled)
            element.removeAttribute("disabled");
        else if ((!value) && (!element.disabled))
            element.disabled = true;
    }
};

ko.bindingHandlers['disable'] = {
    'update': function (element, valueAccessor) {
        ko.bindingHandlers['enable']['update'](element, function() { return !ko.utils.unwrapObservable(valueAccessor()) });
    }
};
// For certain common events (currently just 'click'), allow a simplified data-binding syntax
// e.g. click:handler instead of the usual full-length event:{click:handler}
function makeEventHandlerShortcut(eventName) {
    ko.bindingHandlers[eventName] = {
        'init': function(element, valueAccessor, allBindings, viewModel, bindingContext) {
            var newValueAccessor = function () {
                var result = {};
                result[eventName] = valueAccessor();
                return result;
            };
            return ko.bindingHandlers['event']['init'].call(this, element, newValueAccessor, allBindings, viewModel, bindingContext);
        }
    }
}

ko.bindingHandlers['event'] = {
    'init' : function (element, valueAccessor, allBindings, viewModel, bindingContext) {
        var eventsToHandle = valueAccessor() || {};
        ko.utils.objectForEach(eventsToHandle, function(eventName) {
            if (typeof eventName == "string") {
                ko.utils.registerEventHandler(element, eventName, function (event) {
                    var handlerReturnValue;
                    var handlerFunction = valueAccessor()[eventName];
                    if (!handlerFunction)
                        return;

                    try {
                        // Take all the event args, and prefix with the viewmodel
                        var argsForHandler = ko.utils.makeArray(arguments);
                        viewModel = bindingContext['$data'];
                        argsForHandler.unshift(viewModel);
                        handlerReturnValue = handlerFunction.apply(viewModel, argsForHandler);
                    } finally {
                        if (handlerReturnValue !== true) { // Normally we want to prevent default action. Developer can override this be explicitly returning true.
                            if (event.preventDefault)
                                event.preventDefault();
                            else
                                event.returnValue = false;
                        }
                    }

                    var bubble = allBindings.get(eventName + 'Bubble') !== false;
                    if (!bubble) {
                        event.cancelBubble = true;
                        if (event.stopPropagation)
                            event.stopPropagation();
                    }
                });
            }
        });
    }
};
// "foreach: someExpression" is equivalent to "template: { foreach: someExpression }"
// "foreach: { data: someExpression, afterAdd: myfn }" is equivalent to "template: { foreach: someExpression, afterAdd: myfn }"
ko.bindingHandlers['foreach'] = {
    makeTemplateValueAccessor: function(valueAccessor) {
        return function() {
            var modelValue = valueAccessor(),
                unwrappedValue = ko.utils.peekObservable(modelValue);    // Unwrap without setting a dependency here

            // If unwrappedValue is the array, pass in the wrapped value on its own
            // The value will be unwrapped and tracked within the template binding
            // (See https://github.com/SteveSanderson/knockout/issues/523)
            if ((!unwrappedValue) || typeof unwrappedValue.length == "number")
                return { 'foreach': modelValue, 'templateEngine': ko.nativeTemplateEngine.instance };

            // If unwrappedValue.data is the array, preserve all relevant options and unwrap again value so we get updates
            ko.utils.unwrapObservable(modelValue);
            return {
                'foreach': unwrappedValue['data'],
                'as': unwrappedValue['as'],
                'includeDestroyed': unwrappedValue['includeDestroyed'],
                'afterAdd': unwrappedValue['afterAdd'],
                'beforeRemove': unwrappedValue['beforeRemove'],
                'afterRender': unwrappedValue['afterRender'],
                'beforeMove': unwrappedValue['beforeMove'],
                'afterMove': unwrappedValue['afterMove'],
                'templateEngine': ko.nativeTemplateEngine.instance
            };
        };
    },
    'init': function(element, valueAccessor, allBindings, viewModel, bindingContext) {
        return ko.bindingHandlers['template']['init'](element, ko.bindingHandlers['foreach'].makeTemplateValueAccessor(valueAccessor));
    },
    'update': function(element, valueAccessor, allBindings, viewModel, bindingContext) {
        return ko.bindingHandlers['template']['update'](element, ko.bindingHandlers['foreach'].makeTemplateValueAccessor(valueAccessor), allBindings, viewModel, bindingContext);
    }
};
ko.expressionRewriting.bindingRewriteValidators['foreach'] = false; // Can't rewrite control flow bindings
ko.virtualElements.allowedBindings['foreach'] = true;
var hasfocusUpdatingProperty = '__ko_hasfocusUpdating';
var hasfocusLastValue = '__ko_hasfocusLastValue';
ko.bindingHandlers['hasfocus'] = {
    'init': function(element, valueAccessor, allBindings) {
        var handleElementFocusChange = function(isFocused) {
            // Where possible, ignore which event was raised and determine focus state using activeElement,
            // as this avoids phantom focus/blur events raised when changing tabs in modern browsers.
            // However, not all KO-targeted browsers (Firefox 2) support activeElement. For those browsers,
            // prevent a loss of focus when changing tabs/windows by setting a flag that prevents hasfocus
            // from calling 'blur()' on the element when it loses focus.
            // Discussion at https://github.com/SteveSanderson/knockout/pull/352
            element[hasfocusUpdatingProperty] = true;
            var ownerDoc = element.ownerDocument;
            if ("activeElement" in ownerDoc) {
                var active;
                try {
                    active = ownerDoc.activeElement;
                } catch(e) {
                    // IE9 throws if you access activeElement during page load (see issue #703)
                    active = ownerDoc.body;
                }
                isFocused = (active === element);
            }
            var modelValue = valueAccessor();
            ko.expressionRewriting.writeValueToProperty(modelValue, allBindings, 'hasfocus', isFocused, true);

            //cache the latest value, so we can avoid unnecessarily calling focus/blur in the update function
            element[hasfocusLastValue] = isFocused;
            element[hasfocusUpdatingProperty] = false;
        };
        var handleElementFocusIn = handleElementFocusChange.bind(null, true);
        var handleElementFocusOut = handleElementFocusChange.bind(null, false);

        ko.utils.registerEventHandler(element, "focus", handleElementFocusIn);
        ko.utils.registerEventHandler(element, "focusin", handleElementFocusIn); // For IE
        ko.utils.registerEventHandler(element, "blur",  handleElementFocusOut);
        ko.utils.registerEventHandler(element, "focusout",  handleElementFocusOut); // For IE
    },
    'update': function(element, valueAccessor) {
        var value = !!ko.utils.unwrapObservable(valueAccessor());

        if (!element[hasfocusUpdatingProperty] && element[hasfocusLastValue] !== value) {
            value ? element.focus() : element.blur();

            // In IE, the blur method doesn't always cause the element to lose focus (for example, if the window is not in focus).
            // Setting focus to the body element does seem to be reliable in IE, but should only be used if we know that the current
            // element was focused already.
            if (!value && element[hasfocusLastValue]) {
                element.ownerDocument.body.focus();
            }

            // For IE, which doesn't reliably fire "focus" or "blur" events synchronously
            ko.dependencyDetection.ignore(ko.utils.triggerEvent, null, [element, value ? "focusin" : "focusout"]);
        }
    }
};
ko.expressionRewriting.twoWayBindings['hasfocus'] = true;

ko.bindingHandlers['hasFocus'] = ko.bindingHandlers['hasfocus']; // Make "hasFocus" an alias
ko.expressionRewriting.twoWayBindings['hasFocus'] = true;
ko.bindingHandlers['html'] = {
    'init': function() {
        // Prevent binding on the dynamically-injected HTML (as developers are unlikely to expect that, and it has security implications)
        return { 'controlsDescendantBindings': true };
    },
    'update': function (element, valueAccessor) {
        // setHtml will unwrap the value if needed
        ko.utils.setHtml(element, valueAccessor());
    }
};
// Makes a binding like with or if
function makeWithIfBinding(bindingKey, isWith, isNot, makeContextCallback) {
    ko.bindingHandlers[bindingKey] = {
        'init': function(element, valueAccessor, allBindings, viewModel, bindingContext) {
            var didDisplayOnLastUpdate,
                savedNodes;
            ko.computed(function() {
                var rawValue = valueAccessor(),
                    dataValue = ko.utils.unwrapObservable(rawValue),
                    shouldDisplay = !isNot !== !dataValue, // equivalent to isNot ? !dataValue : !!dataValue
                    isFirstRender = !savedNodes,
                    needsRefresh = isFirstRender || isWith || (shouldDisplay !== didDisplayOnLastUpdate);

                if (needsRefresh) {
                    // Save a copy of the inner nodes on the initial update, but only if we have dependencies.
                    if (isFirstRender && ko.computedContext.getDependenciesCount()) {
                        savedNodes = ko.utils.cloneNodes(ko.virtualElements.childNodes(element), true /* shouldCleanNodes */);
                    }

                    if (shouldDisplay) {
                        if (!isFirstRender) {
                            ko.virtualElements.setDomNodeChildren(element, ko.utils.cloneNodes(savedNodes));
                        }
                        ko.applyBindingsToDescendants(makeContextCallback ? makeContextCallback(bindingContext, rawValue) : bindingContext, element);
                    } else {
                        ko.virtualElements.emptyNode(element);
                    }

                    didDisplayOnLastUpdate = shouldDisplay;
                }
            }, null, { disposeWhenNodeIsRemoved: element });
            return { 'controlsDescendantBindings': true };
        }
    };
    ko.expressionRewriting.bindingRewriteValidators[bindingKey] = false; // Can't rewrite control flow bindings
    ko.virtualElements.allowedBindings[bindingKey] = true;
}

// Construct the actual binding handlers
makeWithIfBinding('if');
makeWithIfBinding('ifnot', false /* isWith */, true /* isNot */);
makeWithIfBinding('with', true /* isWith */, false /* isNot */,
    function(bindingContext, dataValue) {
        return bindingContext.createStaticChildContext(dataValue);
    }
);
var captionPlaceholder = {};
ko.bindingHandlers['options'] = {
    'init': function(element) {
        if (ko.utils.tagNameLower(element) !== "select")
            throw new Error("options binding applies only to SELECT elements");

        // Remove all existing <option>s.
        while (element.length > 0) {
            element.remove(0);
        }

        // Ensures that the binding processor doesn't try to bind the options
        return { 'controlsDescendantBindings': true };
    },
    'update': function (element, valueAccessor, allBindings) {
        function selectedOptions() {
            return ko.utils.arrayFilter(element.options, function (node) { return node.selected; });
        }

        var selectWasPreviouslyEmpty = element.length == 0,
            multiple = element.multiple,
            previousScrollTop = (!selectWasPreviouslyEmpty && multiple) ? element.scrollTop : null,
            unwrappedArray = ko.utils.unwrapObservable(valueAccessor()),
            valueAllowUnset = allBindings.get('valueAllowUnset') && allBindings['has']('value'),
            includeDestroyed = allBindings.get('optionsIncludeDestroyed'),
            arrayToDomNodeChildrenOptions = {},
            captionValue,
            filteredArray,
            previousSelectedValues = [];

        if (!valueAllowUnset) {
            if (multiple) {
                previousSelectedValues = ko.utils.arrayMap(selectedOptions(), ko.selectExtensions.readValue);
            } else if (element.selectedIndex >= 0) {
                previousSelectedValues.push(ko.selectExtensions.readValue(element.options[element.selectedIndex]));
            }
        }

        if (unwrappedArray) {
            if (typeof unwrappedArray.length == "undefined") // Coerce single value into array
                unwrappedArray = [unwrappedArray];

            // Filter out any entries marked as destroyed
            filteredArray = ko.utils.arrayFilter(unwrappedArray, function(item) {
                return includeDestroyed || item === undefined || item === null || !ko.utils.unwrapObservable(item['_destroy']);
            });

            // If caption is included, add it to the array
            if (allBindings['has']('optionsCaption')) {
                captionValue = ko.utils.unwrapObservable(allBindings.get('optionsCaption'));
                // If caption value is null or undefined, don't show a caption
                if (captionValue !== null && captionValue !== undefined) {
                    filteredArray.unshift(captionPlaceholder);
                }
            }
        } else {
            // If a falsy value is provided (e.g. null), we'll simply empty the select element
        }

        function applyToObject(object, predicate, defaultValue) {
            var predicateType = typeof predicate;
            if (predicateType == "function")    // Given a function; run it against the data value
                return predicate(object);
            else if (predicateType == "string") // Given a string; treat it as a property name on the data value
                return object[predicate];
            else                                // Given no optionsText arg; use the data value itself
                return defaultValue;
        }

        // The following functions can run at two different times:
        // The first is when the whole array is being updated directly from this binding handler.
        // The second is when an observable value for a specific array entry is updated.
        // oldOptions will be empty in the first case, but will be filled with the previously generated option in the second.
        var itemUpdate = false;
        function optionForArrayItem(arrayEntry, index, oldOptions) {
            if (oldOptions.length) {
                previousSelectedValues = !valueAllowUnset && oldOptions[0].selected ? [ ko.selectExtensions.readValue(oldOptions[0]) ] : [];
                itemUpdate = true;
            }
            var option = element.ownerDocument.createElement("option");
            if (arrayEntry === captionPlaceholder) {
                ko.utils.setTextContent(option, allBindings.get('optionsCaption'));
                ko.selectExtensions.writeValue(option, undefined);
            } else {
                // Apply a value to the option element
                var optionValue = applyToObject(arrayEntry, allBindings.get('optionsValue'), arrayEntry);
                ko.selectExtensions.writeValue(option, ko.utils.unwrapObservable(optionValue));

                // Apply some text to the option element
                var optionText = applyToObject(arrayEntry, allBindings.get('optionsText'), optionValue);
                ko.utils.setTextContent(option, optionText);
            }
            return [option];
        }

        // By using a beforeRemove callback, we delay the removal until after new items are added. This fixes a selection
        // problem in IE<=8 and Firefox. See https://github.com/knockout/knockout/issues/1208
        arrayToDomNodeChildrenOptions['beforeRemove'] =
            function (option) {
                element.removeChild(option);
            };

        function setSelectionCallback(arrayEntry, newOptions) {
            if (itemUpdate && valueAllowUnset) {
                // The model value is authoritative, so make sure its value is the one selected
                // There is no need to use dependencyDetection.ignore since setDomNodeChildrenFromArrayMapping does so already.
                ko.selectExtensions.writeValue(element, ko.utils.unwrapObservable(allBindings.get('value')), true /* allowUnset */);
            } else if (previousSelectedValues.length) {
                // IE6 doesn't like us to assign selection to OPTION nodes before they're added to the document.
                // That's why we first added them without selection. Now it's time to set the selection.
                var isSelected = ko.utils.arrayIndexOf(previousSelectedValues, ko.selectExtensions.readValue(newOptions[0])) >= 0;
                ko.utils.setOptionNodeSelectionState(newOptions[0], isSelected);

                // If this option was changed from being selected during a single-item update, notify the change
                if (itemUpdate && !isSelected) {
                    ko.dependencyDetection.ignore(ko.utils.triggerEvent, null, [element, "change"]);
                }
            }
        }

        var callback = setSelectionCallback;
        if (allBindings['has']('optionsAfterRender') && typeof allBindings.get('optionsAfterRender') == "function") {
            callback = function(arrayEntry, newOptions) {
                setSelectionCallback(arrayEntry, newOptions);
                ko.dependencyDetection.ignore(allBindings.get('optionsAfterRender'), null, [newOptions[0], arrayEntry !== captionPlaceholder ? arrayEntry : undefined]);
            }
        }

        ko.utils.setDomNodeChildrenFromArrayMapping(element, filteredArray, optionForArrayItem, arrayToDomNodeChildrenOptions, callback);

        ko.dependencyDetection.ignore(function () {
            if (valueAllowUnset) {
                // The model value is authoritative, so make sure its value is the one selected
                ko.selectExtensions.writeValue(element, ko.utils.unwrapObservable(allBindings.get('value')), true /* allowUnset */);
            } else {
                // Determine if the selection has changed as a result of updating the options list
                var selectionChanged;
                if (multiple) {
                    // For a multiple-select box, compare the new selection count to the previous one
                    // But if nothing was selected before, the selection can't have changed
                    selectionChanged = previousSelectedValues.length && selectedOptions().length < previousSelectedValues.length;
                } else {
                    // For a single-select box, compare the current value to the previous value
                    // But if nothing was selected before or nothing is selected now, just look for a change in selection
                    selectionChanged = (previousSelectedValues.length && element.selectedIndex >= 0)
                        ? (ko.selectExtensions.readValue(element.options[element.selectedIndex]) !== previousSelectedValues[0])
                        : (previousSelectedValues.length || element.selectedIndex >= 0);
                }

                // Ensure consistency between model value and selected option.
                // If the dropdown was changed so that selection is no longer the same,
                // notify the value or selectedOptions binding.
                if (selectionChanged) {
                    ko.utils.triggerEvent(element, "change");
                }
            }
        });

        // Workaround for IE bug
        ko.utils.ensureSelectElementIsRenderedCorrectly(element);

        if (previousScrollTop && Math.abs(previousScrollTop - element.scrollTop) > 20)
            element.scrollTop = previousScrollTop;
    }
};
ko.bindingHandlers['options'].optionValueDomDataKey = ko.utils.domData.nextKey();
ko.bindingHandlers['selectedOptions'] = {
    'after': ['options', 'foreach'],
    'init': function (element, valueAccessor, allBindings) {
        ko.utils.registerEventHandler(element, "change", function () {
            var value = valueAccessor(), valueToWrite = [];
            ko.utils.arrayForEach(element.getElementsByTagName("option"), function(node) {
                if (node.selected)
                    valueToWrite.push(ko.selectExtensions.readValue(node));
            });
            ko.expressionRewriting.writeValueToProperty(value, allBindings, 'selectedOptions', valueToWrite);
        });
    },
    'update': function (element, valueAccessor) {
        if (ko.utils.tagNameLower(element) != "select")
            throw new Error("values binding applies only to SELECT elements");

        var newValue = ko.utils.unwrapObservable(valueAccessor()),
            previousScrollTop = element.scrollTop;

        if (newValue && typeof newValue.length == "number") {
            ko.utils.arrayForEach(element.getElementsByTagName("option"), function(node) {
                var isSelected = ko.utils.arrayIndexOf(newValue, ko.selectExtensions.readValue(node)) >= 0;
                if (node.selected != isSelected) {      // This check prevents flashing of the select element in IE
                    ko.utils.setOptionNodeSelectionState(node, isSelected);
                }
            });
        }

        element.scrollTop = previousScrollTop;
    }
};
ko.expressionRewriting.twoWayBindings['selectedOptions'] = true;
ko.bindingHandlers['style'] = {
    'update': function (element, valueAccessor) {
        var value = ko.utils.unwrapObservable(valueAccessor() || {});
        ko.utils.objectForEach(value, function(styleName, styleValue) {
            styleValue = ko.utils.unwrapObservable(styleValue);

            if (styleValue === null || styleValue === undefined || styleValue === false) {
                // Empty string removes the value, whereas null/undefined have no effect
                styleValue = "";
            }

            element.style[styleName] = styleValue;
        });
    }
};
ko.bindingHandlers['submit'] = {
    'init': function (element, valueAccessor, allBindings, viewModel, bindingContext) {
        if (typeof valueAccessor() != "function")
            throw new Error("The value for a submit binding must be a function");
        ko.utils.registerEventHandler(element, "submit", function (event) {
            var handlerReturnValue;
            var value = valueAccessor();
            try { handlerReturnValue = value.call(bindingContext['$data'], element); }
            finally {
                if (handlerReturnValue !== true) { // Normally we want to prevent default action. Developer can override this be explicitly returning true.
                    if (event.preventDefault)
                        event.preventDefault();
                    else
                        event.returnValue = false;
                }
            }
        });
    }
};
ko.bindingHandlers['text'] = {
    'init': function() {
        // Prevent binding on the dynamically-injected text node (as developers are unlikely to expect that, and it has security implications).
        // It should also make things faster, as we no longer have to consider whether the text node might be bindable.
        return { 'controlsDescendantBindings': true };
    },
    'update': function (element, valueAccessor) {
        ko.utils.setTextContent(element, valueAccessor());
    }
};
ko.virtualElements.allowedBindings['text'] = true;
(function () {

if (window && window.navigator) {
    var parseVersion = function (matches) {
        if (matches) {
            return parseFloat(matches[1]);
        }
    };

    // Detect various browser versions because some old versions don't fully support the 'input' event
    var operaVersion = window.opera && window.opera.version && parseInt(window.opera.version()),
        userAgent = window.navigator.userAgent,
        safariVersion = parseVersion(userAgent.match(/^(?:(?!chrome).)*version\/([^ ]*) safari/i)),
        firefoxVersion = parseVersion(userAgent.match(/Firefox\/([^ ]*)/));
}

// IE 8 and 9 have bugs that prevent the normal events from firing when the value changes.
// But it does fire the 'selectionchange' event on many of those, presumably because the
// cursor is moving and that counts as the selection changing. The 'selectionchange' event is
// fired at the document level only and doesn't directly indicate which element changed. We
// set up just one event handler for the document and use 'activeElement' to determine which
// element was changed.
if (ko.utils.ieVersion < 10) {
    var selectionChangeRegisteredName = ko.utils.domData.nextKey(),
        selectionChangeHandlerName = ko.utils.domData.nextKey();
    var selectionChangeHandler = function(event) {
        var target = this.activeElement,
            handler = target && ko.utils.domData.get(target, selectionChangeHandlerName);
        if (handler) {
            handler(event);
        }
    };
    var registerForSelectionChangeEvent = function (element, handler) {
        var ownerDoc = element.ownerDocument;
        if (!ko.utils.domData.get(ownerDoc, selectionChangeRegisteredName)) {
            ko.utils.domData.set(ownerDoc, selectionChangeRegisteredName, true);
            ko.utils.registerEventHandler(ownerDoc, 'selectionchange', selectionChangeHandler);
        }
        ko.utils.domData.set(element, selectionChangeHandlerName, handler);
    };
}

ko.bindingHandlers['textInput'] = {
    'init': function (element, valueAccessor, allBindings) {

        var previousElementValue = element.value,
            timeoutHandle,
            elementValueBeforeEvent;

        var updateModel = function (event) {
            clearTimeout(timeoutHandle);
            elementValueBeforeEvent = timeoutHandle = undefined;

            var elementValue = element.value;
            if (previousElementValue !== elementValue) {
                // Provide a way for tests to know exactly which event was processed
                if (DEBUG && event) element['_ko_textInputProcessedEvent'] = event.type;
                previousElementValue = elementValue;
                ko.expressionRewriting.writeValueToProperty(valueAccessor(), allBindings, 'textInput', elementValue);
            }
        };

        var deferUpdateModel = function (event) {
            if (!timeoutHandle) {
                // The elementValueBeforeEvent variable is set *only* during the brief gap between an
                // event firing and the updateModel function running. This allows us to ignore model
                // updates that are from the previous state of the element, usually due to techniques
                // such as rateLimit. Such updates, if not ignored, can cause keystrokes to be lost.
                elementValueBeforeEvent = element.value;
                var handler = DEBUG ? updateModel.bind(element, {type: event.type}) : updateModel;
                timeoutHandle = ko.utils.setTimeout(handler, 4);
            }
        };

        // IE9 will mess up the DOM if you handle events synchronously which results in DOM changes (such as other bindings);
        // so we'll make sure all updates are asynchronous
        var ieUpdateModel = ko.utils.ieVersion == 9 ? deferUpdateModel : updateModel;

        var updateView = function () {
            var modelValue = ko.utils.unwrapObservable(valueAccessor());

            if (modelValue === null || modelValue === undefined) {
                modelValue = '';
            }

            if (elementValueBeforeEvent !== undefined && modelValue === elementValueBeforeEvent) {
                ko.utils.setTimeout(updateView, 4);
                return;
            }

            // Update the element only if the element and model are different. On some browsers, updating the value
            // will move the cursor to the end of the input, which would be bad while the user is typing.
            if (element.value !== modelValue) {
                previousElementValue = modelValue;  // Make sure we ignore events (propertychange) that result from updating the value
                element.value = modelValue;
            }
        };

        var onEvent = function (event, handler) {
            ko.utils.registerEventHandler(element, event, handler);
        };

        if (DEBUG && ko.bindingHandlers['textInput']['_forceUpdateOn']) {
            // Provide a way for tests to specify exactly which events are bound
            ko.utils.arrayForEach(ko.bindingHandlers['textInput']['_forceUpdateOn'], function(eventName) {
                if (eventName.slice(0,5) == 'after') {
                    onEvent(eventName.slice(5), deferUpdateModel);
                } else {
                    onEvent(eventName, updateModel);
                }
            });
        } else {
            if (ko.utils.ieVersion < 10) {
                // Internet Explorer <= 8 doesn't support the 'input' event, but does include 'propertychange' that fires whenever
                // any property of an element changes. Unlike 'input', it also fires if a property is changed from JavaScript code,
                // but that's an acceptable compromise for this binding. IE 9 does support 'input', but since it doesn't fire it
                // when using autocomplete, we'll use 'propertychange' for it also.
                onEvent('propertychange', function(event) {
                    if (event.propertyName === 'value') {
                        ieUpdateModel(event);
                    }
                });

                if (ko.utils.ieVersion == 8) {
                    // IE 8 has a bug where it fails to fire 'propertychange' on the first update following a value change from
                    // JavaScript code. It also doesn't fire if you clear the entire value. To fix this, we bind to the following
                    // events too.
                    onEvent('keyup', updateModel);      // A single keystoke
                    onEvent('keydown', updateModel);    // The first character when a key is held down
                }
                if (ko.utils.ieVersion >= 8) {
                    // Internet Explorer 9 doesn't fire the 'input' event when deleting text, including using
                    // the backspace, delete, or ctrl-x keys, clicking the 'x' to clear the input, dragging text
                    // out of the field, and cutting or deleting text using the context menu. 'selectionchange'
                    // can detect all of those except dragging text out of the field, for which we use 'dragend'.
                    // These are also needed in IE8 because of the bug described above.
                    registerForSelectionChangeEvent(element, ieUpdateModel);  // 'selectionchange' covers cut, paste, drop, delete, etc.
                    onEvent('dragend', deferUpdateModel);
                }
            } else {
                // All other supported browsers support the 'input' event, which fires whenever the content of the element is changed
                // through the user interface.
                onEvent('input', updateModel);

                if (safariVersion < 5 && ko.utils.tagNameLower(element) === "textarea") {
                    // Safari <5 doesn't fire the 'input' event for <textarea> elements (it does fire 'textInput'
                    // but only when typing). So we'll just catch as much as we can with keydown, cut, and paste.
                    onEvent('keydown', deferUpdateModel);
                    onEvent('paste', deferUpdateModel);
                    onEvent('cut', deferUpdateModel);
                } else if (operaVersion < 11) {
                    // Opera 10 doesn't always fire the 'input' event for cut, paste, undo & drop operations.
                    // We can try to catch some of those using 'keydown'.
                    onEvent('keydown', deferUpdateModel);
                } else if (firefoxVersion < 4.0) {
                    // Firefox <= 3.6 doesn't fire the 'input' event when text is filled in through autocomplete
                    onEvent('DOMAutoComplete', updateModel);

                    // Firefox <=3.5 doesn't fire the 'input' event when text is dropped into the input.
                    onEvent('dragdrop', updateModel);       // <3.5
                    onEvent('drop', updateModel);           // 3.5
                }
            }
        }

        // Bind to the change event so that we can catch programmatic updates of the value that fire this event.
        onEvent('change', updateModel);

        ko.computed(updateView, null, { disposeWhenNodeIsRemoved: element });
    }
};
ko.expressionRewriting.twoWayBindings['textInput'] = true;

// textinput is an alias for textInput
ko.bindingHandlers['textinput'] = {
    // preprocess is the only way to set up a full alias
    'preprocess': function (value, name, addBinding) {
        addBinding('textInput', value);
    }
};

})();ko.bindingHandlers['uniqueName'] = {
    'init': function (element, valueAccessor) {
        if (valueAccessor()) {
            var name = "ko_unique_" + (++ko.bindingHandlers['uniqueName'].currentIndex);
            ko.utils.setElementName(element, name);
        }
    }
};
ko.bindingHandlers['uniqueName'].currentIndex = 0;
ko.bindingHandlers['value'] = {
    'after': ['options', 'foreach'],
    'init': function (element, valueAccessor, allBindings) {
        // If the value binding is placed on a radio/checkbox, then just pass through to checkedValue and quit
        if (element.tagName.toLowerCase() == "input" && (element.type == "checkbox" || element.type == "radio")) {
            ko.applyBindingAccessorsToNode(element, { 'checkedValue': valueAccessor });
            return;
        }

        // Always catch "change" event; possibly other events too if asked
        var eventsToCatch = ["change"];
        var requestedEventsToCatch = allBindings.get("valueUpdate");
        var propertyChangedFired = false;
        var elementValueBeforeEvent = null;

        if (requestedEventsToCatch) {
            if (typeof requestedEventsToCatch == "string") // Allow both individual event names, and arrays of event names
                requestedEventsToCatch = [requestedEventsToCatch];
            ko.utils.arrayPushAll(eventsToCatch, requestedEventsToCatch);
            eventsToCatch = ko.utils.arrayGetDistinctValues(eventsToCatch);
        }

        var valueUpdateHandler = function() {
            elementValueBeforeEvent = null;
            propertyChangedFired = false;
            var modelValue = valueAccessor();
            var elementValue = ko.selectExtensions.readValue(element);
            ko.expressionRewriting.writeValueToProperty(modelValue, allBindings, 'value', elementValue);
        }

        // Workaround for https://github.com/SteveSanderson/knockout/issues/122
        // IE doesn't fire "change" events on textboxes if the user selects a value from its autocomplete list
        var ieAutoCompleteHackNeeded = ko.utils.ieVersion && element.tagName.toLowerCase() == "input" && element.type == "text"
                                       && element.autocomplete != "off" && (!element.form || element.form.autocomplete != "off");
        if (ieAutoCompleteHackNeeded && ko.utils.arrayIndexOf(eventsToCatch, "propertychange") == -1) {
            ko.utils.registerEventHandler(element, "propertychange", function () { propertyChangedFired = true });
            ko.utils.registerEventHandler(element, "focus", function () { propertyChangedFired = false });
            ko.utils.registerEventHandler(element, "blur", function() {
                if (propertyChangedFired) {
                    valueUpdateHandler();
                }
            });
        }

        ko.utils.arrayForEach(eventsToCatch, function(eventName) {
            // The syntax "after<eventname>" means "run the handler asynchronously after the event"
            // This is useful, for example, to catch "keydown" events after the browser has updated the control
            // (otherwise, ko.selectExtensions.readValue(this) will receive the control's value *before* the key event)
            var handler = valueUpdateHandler;
            if (ko.utils.stringStartsWith(eventName, "after")) {
                handler = function() {
                    // The elementValueBeforeEvent variable is non-null *only* during the brief gap between
                    // a keyX event firing and the valueUpdateHandler running, which is scheduled to happen
                    // at the earliest asynchronous opportunity. We store this temporary information so that
                    // if, between keyX and valueUpdateHandler, the underlying model value changes separately,
                    // we can overwrite that model value change with the value the user just typed. Otherwise,
                    // techniques like rateLimit can trigger model changes at critical moments that will
                    // override the user's inputs, causing keystrokes to be lost.
                    elementValueBeforeEvent = ko.selectExtensions.readValue(element);
                    ko.utils.setTimeout(valueUpdateHandler, 0);
                };
                eventName = eventName.substring("after".length);
            }
            ko.utils.registerEventHandler(element, eventName, handler);
        });

        var updateFromModel = function () {
            var newValue = ko.utils.unwrapObservable(valueAccessor());
            var elementValue = ko.selectExtensions.readValue(element);

            if (elementValueBeforeEvent !== null && newValue === elementValueBeforeEvent) {
                ko.utils.setTimeout(updateFromModel, 0);
                return;
            }

            var valueHasChanged = (newValue !== elementValue);

            if (valueHasChanged) {
                if (ko.utils.tagNameLower(element) === "select") {
                    var allowUnset = allBindings.get('valueAllowUnset');
                    var applyValueAction = function () {
                        ko.selectExtensions.writeValue(element, newValue, allowUnset);
                    };
                    applyValueAction();

                    if (!allowUnset && newValue !== ko.selectExtensions.readValue(element)) {
                        // If you try to set a model value that can't be represented in an already-populated dropdown, reject that change,
                        // because you're not allowed to have a model value that disagrees with a visible UI selection.
                        ko.dependencyDetection.ignore(ko.utils.triggerEvent, null, [element, "change"]);
                    } else {
                        // Workaround for IE6 bug: It won't reliably apply values to SELECT nodes during the same execution thread
                        // right after you've changed the set of OPTION nodes on it. So for that node type, we'll schedule a second thread
                        // to apply the value as well.
                        ko.utils.setTimeout(applyValueAction, 0);
                    }
                } else {
                    ko.selectExtensions.writeValue(element, newValue);
                }
            }
        };

        ko.computed(updateFromModel, null, { disposeWhenNodeIsRemoved: element });
    },
    'update': function() {} // Keep for backwards compatibility with code that may have wrapped value binding
};
ko.expressionRewriting.twoWayBindings['value'] = true;
ko.bindingHandlers['visible'] = {
    'update': function (element, valueAccessor) {
        var value = ko.utils.unwrapObservable(valueAccessor());
        var isCurrentlyVisible = !(element.style.display == "none");
        if (value && !isCurrentlyVisible)
            element.style.display = "";
        else if ((!value) && isCurrentlyVisible)
            element.style.display = "none";
    }
};
// 'click' is just a shorthand for the usual full-length event:{click:handler}
makeEventHandlerShortcut('click');
// If you want to make a custom template engine,
//
// [1] Inherit from this class (like ko.nativeTemplateEngine does)
// [2] Override 'renderTemplateSource', supplying a function with this signature:
//
//        function (templateSource, bindingContext, options) {
//            // - templateSource.text() is the text of the template you should render
//            // - bindingContext.$data is the data you should pass into the template
//            //   - you might also want to make bindingContext.$parent, bindingContext.$parents,
//            //     and bindingContext.$root available in the template too
//            // - options gives you access to any other properties set on "data-bind: { template: options }"
//            // - templateDocument is the document object of the template
//            //
//            // Return value: an array of DOM nodes
//        }
//
// [3] Override 'createJavaScriptEvaluatorBlock', supplying a function with this signature:
//
//        function (script) {
//            // Return value: Whatever syntax means "Evaluate the JavaScript statement 'script' and output the result"
//            //               For example, the jquery.tmpl template engine converts 'someScript' to '${ someScript }'
//        }
//
//     This is only necessary if you want to allow data-bind attributes to reference arbitrary template variables.
//     If you don't want to allow that, you can set the property 'allowTemplateRewriting' to false (like ko.nativeTemplateEngine does)
//     and then you don't need to override 'createJavaScriptEvaluatorBlock'.

ko.templateEngine = function () { };

ko.templateEngine.prototype['renderTemplateSource'] = function (templateSource, bindingContext, options, templateDocument) {
    throw new Error("Override renderTemplateSource");
};

ko.templateEngine.prototype['createJavaScriptEvaluatorBlock'] = function (script) {
    throw new Error("Override createJavaScriptEvaluatorBlock");
};

ko.templateEngine.prototype['makeTemplateSource'] = function(template, templateDocument) {
    // Named template
    if (typeof template == "string") {
        templateDocument = templateDocument || document;
        var elem = templateDocument.getElementById(template);
        if (!elem)
            throw new Error("Cannot find template with ID " + template);
        return new ko.templateSources.domElement(elem);
    } else if ((template.nodeType == 1) || (template.nodeType == 8)) {
        // Anonymous template
        return new ko.templateSources.anonymousTemplate(template);
    } else
        throw new Error("Unknown template type: " + template);
};

ko.templateEngine.prototype['renderTemplate'] = function (template, bindingContext, options, templateDocument) {
    var templateSource = this['makeTemplateSource'](template, templateDocument);
    return this['renderTemplateSource'](templateSource, bindingContext, options, templateDocument);
};

ko.templateEngine.prototype['isTemplateRewritten'] = function (template, templateDocument) {
    // Skip rewriting if requested
    if (this['allowTemplateRewriting'] === false)
        return true;
    return this['makeTemplateSource'](template, templateDocument)['data']("isRewritten");
};

ko.templateEngine.prototype['rewriteTemplate'] = function (template, rewriterCallback, templateDocument) {
    var templateSource = this['makeTemplateSource'](template, templateDocument);
    var rewritten = rewriterCallback(templateSource['text']());
    templateSource['text'](rewritten);
    templateSource['data']("isRewritten", true);
};

ko.exportSymbol('templateEngine', ko.templateEngine);

ko.templateRewriting = (function () {
    var memoizeDataBindingAttributeSyntaxRegex = /(<([a-z]+\d*)(?:\s+(?!data-bind\s*=\s*)[a-z0-9\-]+(?:=(?:\"[^\"]*\"|\'[^\']*\'|[^>]*))?)*\s+)data-bind\s*=\s*(["'])([\s\S]*?)\3/gi;
    var memoizeVirtualContainerBindingSyntaxRegex = /<!--\s*ko\b\s*([\s\S]*?)\s*-->/g;

    function validateDataBindValuesForRewriting(keyValueArray) {
        var allValidators = ko.expressionRewriting.bindingRewriteValidators;
        for (var i = 0; i < keyValueArray.length; i++) {
            var key = keyValueArray[i]['key'];
            if (allValidators.hasOwnProperty(key)) {
                var validator = allValidators[key];

                if (typeof validator === "function") {
                    var possibleErrorMessage = validator(keyValueArray[i]['value']);
                    if (possibleErrorMessage)
                        throw new Error(possibleErrorMessage);
                } else if (!validator) {
                    throw new Error("This template engine does not support the '" + key + "' binding within its templates");
                }
            }
        }
    }

    function constructMemoizedTagReplacement(dataBindAttributeValue, tagToRetain, nodeName, templateEngine) {
        var dataBindKeyValueArray = ko.expressionRewriting.parseObjectLiteral(dataBindAttributeValue);
        validateDataBindValuesForRewriting(dataBindKeyValueArray);
        var rewrittenDataBindAttributeValue = ko.expressionRewriting.preProcessBindings(dataBindKeyValueArray, {'valueAccessors':true});

        // For no obvious reason, Opera fails to evaluate rewrittenDataBindAttributeValue unless it's wrapped in an additional
        // anonymous function, even though Opera's built-in debugger can evaluate it anyway. No other browser requires this
        // extra indirection.
        var applyBindingsToNextSiblingScript =
            "ko.__tr_ambtns(function($context,$element){return(function(){return{ " + rewrittenDataBindAttributeValue + " } })()},'" + nodeName.toLowerCase() + "')";
        return templateEngine['createJavaScriptEvaluatorBlock'](applyBindingsToNextSiblingScript) + tagToRetain;
    }

    return {
        ensureTemplateIsRewritten: function (template, templateEngine, templateDocument) {
            if (!templateEngine['isTemplateRewritten'](template, templateDocument))
                templateEngine['rewriteTemplate'](template, function (htmlString) {
                    return ko.templateRewriting.memoizeBindingAttributeSyntax(htmlString, templateEngine);
                }, templateDocument);
        },

        memoizeBindingAttributeSyntax: function (htmlString, templateEngine) {
            return htmlString.replace(memoizeDataBindingAttributeSyntaxRegex, function () {
                return constructMemoizedTagReplacement(/* dataBindAttributeValue: */ arguments[4], /* tagToRetain: */ arguments[1], /* nodeName: */ arguments[2], templateEngine);
            }).replace(memoizeVirtualContainerBindingSyntaxRegex, function() {
                return constructMemoizedTagReplacement(/* dataBindAttributeValue: */ arguments[1], /* tagToRetain: */ "<!-- ko -->", /* nodeName: */ "#comment", templateEngine);
            });
        },

        applyMemoizedBindingsToNextSibling: function (bindings, nodeName) {
            return ko.memoization.memoize(function (domNode, bindingContext) {
                var nodeToBind = domNode.nextSibling;
                if (nodeToBind && nodeToBind.nodeName.toLowerCase() === nodeName) {
                    ko.applyBindingAccessorsToNode(nodeToBind, bindings, bindingContext);
                }
            });
        }
    }
})();


// Exported only because it has to be referenced by string lookup from within rewritten template
ko.exportSymbol('__tr_ambtns', ko.templateRewriting.applyMemoizedBindingsToNextSibling);
(function() {
    // A template source represents a read/write way of accessing a template. This is to eliminate the need for template loading/saving
    // logic to be duplicated in every template engine (and means they can all work with anonymous templates, etc.)
    //
    // Two are provided by default:
    //  1. ko.templateSources.domElement       - reads/writes the text content of an arbitrary DOM element
    //  2. ko.templateSources.anonymousElement - uses ko.utils.domData to read/write text *associated* with the DOM element, but
    //                                           without reading/writing the actual element text content, since it will be overwritten
    //                                           with the rendered template output.
    // You can implement your own template source if you want to fetch/store templates somewhere other than in DOM elements.
    // Template sources need to have the following functions:
    //   text() 			- returns the template text from your storage location
    //   text(value)		- writes the supplied template text to your storage location
    //   data(key)			- reads values stored using data(key, value) - see below
    //   data(key, value)	- associates "value" with this template and the key "key". Is used to store information like "isRewritten".
    //
    // Optionally, template sources can also have the following functions:
    //   nodes()            - returns a DOM element containing the nodes of this template, where available
    //   nodes(value)       - writes the given DOM element to your storage location
    // If a DOM element is available for a given template source, template engines are encouraged to use it in preference over text()
    // for improved speed. However, all templateSources must supply text() even if they don't supply nodes().
    //
    // Once you've implemented a templateSource, make your template engine use it by subclassing whatever template engine you were
    // using and overriding "makeTemplateSource" to return an instance of your custom template source.

    ko.templateSources = {};

    // ---- ko.templateSources.domElement -----

    // template types
    var templateScript = 1,
        templateTextArea = 2,
        templateTemplate = 3,
        templateElement = 4;

    ko.templateSources.domElement = function(element) {
        this.domElement = element;

        if (element) {
            var tagNameLower = ko.utils.tagNameLower(element);
            this.templateType =
                tagNameLower === "script" ? templateScript :
                tagNameLower === "textarea" ? templateTextArea :
                    // For browsers with proper <template> element support, where the .content property gives a document fragment
                tagNameLower == "template" && element.content && element.content.nodeType === 11 ? templateTemplate :
                templateElement;
        }
    }

    ko.templateSources.domElement.prototype['text'] = function(/* valueToWrite */) {
        var elemContentsProperty = this.templateType === templateScript ? "text"
                                 : this.templateType === templateTextArea ? "value"
                                 : "innerHTML";

        if (arguments.length == 0) {
            return this.domElement[elemContentsProperty];
        } else {
            var valueToWrite = arguments[0];
            if (elemContentsProperty === "innerHTML")
                ko.utils.setHtml(this.domElement, valueToWrite);
            else
                this.domElement[elemContentsProperty] = valueToWrite;
        }
    };

    var dataDomDataPrefix = ko.utils.domData.nextKey() + "_";
    ko.templateSources.domElement.prototype['data'] = function(key /*, valueToWrite */) {
        if (arguments.length === 1) {
            return ko.utils.domData.get(this.domElement, dataDomDataPrefix + key);
        } else {
            ko.utils.domData.set(this.domElement, dataDomDataPrefix + key, arguments[1]);
        }
    };

    var templatesDomDataKey = ko.utils.domData.nextKey();
    function getTemplateDomData(element) {
        return ko.utils.domData.get(element, templatesDomDataKey) || {};
    }
    function setTemplateDomData(element, data) {
        ko.utils.domData.set(element, templatesDomDataKey, data);
    }

    ko.templateSources.domElement.prototype['nodes'] = function(/* valueToWrite */) {
        var element = this.domElement;
        if (arguments.length == 0) {
            var templateData = getTemplateDomData(element),
                containerData = templateData.containerData;
            return containerData || (
                this.templateType === templateTemplate ? element.content :
                this.templateType === templateElement ? element :
                undefined);
        } else {
            var valueToWrite = arguments[0];
            setTemplateDomData(element, {containerData: valueToWrite});
        }
    };

    // ---- ko.templateSources.anonymousTemplate -----
    // Anonymous templates are normally saved/retrieved as DOM nodes through "nodes".
    // For compatibility, you can also read "text"; it will be serialized from the nodes on demand.
    // Writing to "text" is still supported, but then the template data will not be available as DOM nodes.

    ko.templateSources.anonymousTemplate = function(element) {
        this.domElement = element;
    }
    ko.templateSources.anonymousTemplate.prototype = new ko.templateSources.domElement();
    ko.templateSources.anonymousTemplate.prototype.constructor = ko.templateSources.anonymousTemplate;
    ko.templateSources.anonymousTemplate.prototype['text'] = function(/* valueToWrite */) {
        if (arguments.length == 0) {
            var templateData = getTemplateDomData(this.domElement);
            if (templateData.textData === undefined && templateData.containerData)
                templateData.textData = templateData.containerData.innerHTML;
            return templateData.textData;
        } else {
            var valueToWrite = arguments[0];
            setTemplateDomData(this.domElement, {textData: valueToWrite});
        }
    };

    ko.exportSymbol('templateSources', ko.templateSources);
    ko.exportSymbol('templateSources.domElement', ko.templateSources.domElement);
    ko.exportSymbol('templateSources.anonymousTemplate', ko.templateSources.anonymousTemplate);
})();
(function () {
    var _templateEngine;
    ko.setTemplateEngine = function (templateEngine) {
        if ((templateEngine != undefined) && !(templateEngine instanceof ko.templateEngine))
            throw new Error("templateEngine must inherit from ko.templateEngine");
        _templateEngine = templateEngine;
    }

    function invokeForEachNodeInContinuousRange(firstNode, lastNode, action) {
        var node, nextInQueue = firstNode, firstOutOfRangeNode = ko.virtualElements.nextSibling(lastNode);
        while (nextInQueue && ((node = nextInQueue) !== firstOutOfRangeNode)) {
            nextInQueue = ko.virtualElements.nextSibling(node);
            action(node, nextInQueue);
        }
    }

    function activateBindingsOnContinuousNodeArray(continuousNodeArray, bindingContext) {
        // To be used on any nodes that have been rendered by a template and have been inserted into some parent element
        // Walks through continuousNodeArray (which *must* be continuous, i.e., an uninterrupted sequence of sibling nodes, because
        // the algorithm for walking them relies on this), and for each top-level item in the virtual-element sense,
        // (1) Does a regular "applyBindings" to associate bindingContext with this node and to activate any non-memoized bindings
        // (2) Unmemoizes any memos in the DOM subtree (e.g., to activate bindings that had been memoized during template rewriting)

        if (continuousNodeArray.length) {
            var firstNode = continuousNodeArray[0],
                lastNode = continuousNodeArray[continuousNodeArray.length - 1],
                parentNode = firstNode.parentNode,
                provider = ko.bindingProvider['instance'],
                preprocessNode = provider['preprocessNode'];

            if (preprocessNode) {
                invokeForEachNodeInContinuousRange(firstNode, lastNode, function(node, nextNodeInRange) {
                    var nodePreviousSibling = node.previousSibling;
                    var newNodes = preprocessNode.call(provider, node);
                    if (newNodes) {
                        if (node === firstNode)
                            firstNode = newNodes[0] || nextNodeInRange;
                        if (node === lastNode)
                            lastNode = newNodes[newNodes.length - 1] || nodePreviousSibling;
                    }
                });

                // Because preprocessNode can change the nodes, including the first and last nodes, update continuousNodeArray to match.
                // We need the full set, including inner nodes, because the unmemoize step might remove the first node (and so the real
                // first node needs to be in the array).
                continuousNodeArray.length = 0;
                if (!firstNode) { // preprocessNode might have removed all the nodes, in which case there's nothing left to do
                    return;
                }
                if (firstNode === lastNode) {
                    continuousNodeArray.push(firstNode);
                } else {
                    continuousNodeArray.push(firstNode, lastNode);
                    ko.utils.fixUpContinuousNodeArray(continuousNodeArray, parentNode);
                }
            }

            // Need to applyBindings *before* unmemoziation, because unmemoization might introduce extra nodes (that we don't want to re-bind)
            // whereas a regular applyBindings won't introduce new memoized nodes
            invokeForEachNodeInContinuousRange(firstNode, lastNode, function(node) {
                if (node.nodeType === 1 || node.nodeType === 8)
                    ko.applyBindings(bindingContext, node);
            });
            invokeForEachNodeInContinuousRange(firstNode, lastNode, function(node) {
                if (node.nodeType === 1 || node.nodeType === 8)
                    ko.memoization.unmemoizeDomNodeAndDescendants(node, [bindingContext]);
            });

            // Make sure any changes done by applyBindings or unmemoize are reflected in the array
            ko.utils.fixUpContinuousNodeArray(continuousNodeArray, parentNode);
        }
    }

    function getFirstNodeFromPossibleArray(nodeOrNodeArray) {
        return nodeOrNodeArray.nodeType ? nodeOrNodeArray
                                        : nodeOrNodeArray.length > 0 ? nodeOrNodeArray[0]
                                        : null;
    }

    function executeTemplate(targetNodeOrNodeArray, renderMode, template, bindingContext, options) {
        options = options || {};
        var firstTargetNode = targetNodeOrNodeArray && getFirstNodeFromPossibleArray(targetNodeOrNodeArray);
        var templateDocument = (firstTargetNode || template || {}).ownerDocument;
        var templateEngineToUse = (options['templateEngine'] || _templateEngine);
        ko.templateRewriting.ensureTemplateIsRewritten(template, templateEngineToUse, templateDocument);
        var renderedNodesArray = templateEngineToUse['renderTemplate'](template, bindingContext, options, templateDocument);

        // Loosely check result is an array of DOM nodes
        if ((typeof renderedNodesArray.length != "number") || (renderedNodesArray.length > 0 && typeof renderedNodesArray[0].nodeType != "number"))
            throw new Error("Template engine must return an array of DOM nodes");

        var haveAddedNodesToParent = false;
        switch (renderMode) {
            case "replaceChildren":
                ko.virtualElements.setDomNodeChildren(targetNodeOrNodeArray, renderedNodesArray);
                haveAddedNodesToParent = true;
                break;
            case "replaceNode":
                ko.utils.replaceDomNodes(targetNodeOrNodeArray, renderedNodesArray);
                haveAddedNodesToParent = true;
                break;
            case "ignoreTargetNode": break;
            default:
                throw new Error("Unknown renderMode: " + renderMode);
        }

        if (haveAddedNodesToParent) {
            activateBindingsOnContinuousNodeArray(renderedNodesArray, bindingContext);
            if (options['afterRender'])
                ko.dependencyDetection.ignore(options['afterRender'], null, [renderedNodesArray, bindingContext['$data']]);
        }

        return renderedNodesArray;
    }

    function resolveTemplateName(template, data, context) {
        // The template can be specified as:
        if (ko.isObservable(template)) {
            // 1. An observable, with string value
            return template();
        } else if (typeof template === 'function') {
            // 2. A function of (data, context) returning a string
            return template(data, context);
        } else {
            // 3. A string
            return template;
        }
    }

    ko.renderTemplate = function (template, dataOrBindingContext, options, targetNodeOrNodeArray, renderMode) {
        options = options || {};
        if ((options['templateEngine'] || _templateEngine) == undefined)
            throw new Error("Set a template engine before calling renderTemplate");
        renderMode = renderMode || "replaceChildren";

        if (targetNodeOrNodeArray) {
            var firstTargetNode = getFirstNodeFromPossibleArray(targetNodeOrNodeArray);

            var whenToDispose = function () { return (!firstTargetNode) || !ko.utils.domNodeIsAttachedToDocument(firstTargetNode); }; // Passive disposal (on next evaluation)
            var activelyDisposeWhenNodeIsRemoved = (firstTargetNode && renderMode == "replaceNode") ? firstTargetNode.parentNode : firstTargetNode;

            return ko.dependentObservable( // So the DOM is automatically updated when any dependency changes
                function () {
                    // Ensure we've got a proper binding context to work with
                    var bindingContext = (dataOrBindingContext && (dataOrBindingContext instanceof ko.bindingContext))
                        ? dataOrBindingContext
                        : new ko.bindingContext(dataOrBindingContext, null, null, null, { "exportDependencies": true });

                    var templateName = resolveTemplateName(template, bindingContext['$data'], bindingContext),
                        renderedNodesArray = executeTemplate(targetNodeOrNodeArray, renderMode, templateName, bindingContext, options);

                    if (renderMode == "replaceNode") {
                        targetNodeOrNodeArray = renderedNodesArray;
                        firstTargetNode = getFirstNodeFromPossibleArray(targetNodeOrNodeArray);
                    }
                },
                null,
                { disposeWhen: whenToDispose, disposeWhenNodeIsRemoved: activelyDisposeWhenNodeIsRemoved }
            );
        } else {
            // We don't yet have a DOM node to evaluate, so use a memo and render the template later when there is a DOM node
            return ko.memoization.memoize(function (domNode) {
                ko.renderTemplate(template, dataOrBindingContext, options, domNode, "replaceNode");
            });
        }
    };

    ko.renderTemplateForEach = function (template, arrayOrObservableArray, options, targetNode, parentBindingContext) {
        // Since setDomNodeChildrenFromArrayMapping always calls executeTemplateForArrayItem and then
        // activateBindingsCallback for added items, we can store the binding context in the former to use in the latter.
        var arrayItemContext;

        // This will be called by setDomNodeChildrenFromArrayMapping to get the nodes to add to targetNode
        var executeTemplateForArrayItem = function (arrayValue, index) {
            // Support selecting template as a function of the data being rendered
            arrayItemContext = parentBindingContext['createChildContext'](arrayValue, options['as'], function(context) {
                context['$index'] = index;
            });

            var templateName = resolveTemplateName(template, arrayValue, arrayItemContext);
            return executeTemplate(null, "ignoreTargetNode", templateName, arrayItemContext, options);
        }

        // This will be called whenever setDomNodeChildrenFromArrayMapping has added nodes to targetNode
        var activateBindingsCallback = function(arrayValue, addedNodesArray, index) {
            activateBindingsOnContinuousNodeArray(addedNodesArray, arrayItemContext);
            if (options['afterRender'])
                options['afterRender'](addedNodesArray, arrayValue);

            // release the "cache" variable, so that it can be collected by
            // the GC when its value isn't used from within the bindings anymore.
            arrayItemContext = null;
        };

        return ko.dependentObservable(function () {
            var unwrappedArray = ko.utils.unwrapObservable(arrayOrObservableArray) || [];
            if (typeof unwrappedArray.length == "undefined") // Coerce single value into array
                unwrappedArray = [unwrappedArray];

            // Filter out any entries marked as destroyed
            var filteredArray = ko.utils.arrayFilter(unwrappedArray, function(item) {
                return options['includeDestroyed'] || item === undefined || item === null || !ko.utils.unwrapObservable(item['_destroy']);
            });

            // Call setDomNodeChildrenFromArrayMapping, ignoring any observables unwrapped within (most likely from a callback function).
            // If the array items are observables, though, they will be unwrapped in executeTemplateForArrayItem and managed within setDomNodeChildrenFromArrayMapping.
            ko.dependencyDetection.ignore(ko.utils.setDomNodeChildrenFromArrayMapping, null, [targetNode, filteredArray, executeTemplateForArrayItem, options, activateBindingsCallback]);

        }, null, { disposeWhenNodeIsRemoved: targetNode });
    };

    var templateComputedDomDataKey = ko.utils.domData.nextKey();
    function disposeOldComputedAndStoreNewOne(element, newComputed) {
        var oldComputed = ko.utils.domData.get(element, templateComputedDomDataKey);
        if (oldComputed && (typeof(oldComputed.dispose) == 'function'))
            oldComputed.dispose();
        ko.utils.domData.set(element, templateComputedDomDataKey, (newComputed && newComputed.isActive()) ? newComputed : undefined);
    }

    ko.bindingHandlers['template'] = {
        'init': function(element, valueAccessor) {
            // Support anonymous templates
            var bindingValue = ko.utils.unwrapObservable(valueAccessor());
            if (typeof bindingValue == "string" || bindingValue['name']) {
                // It's a named template - clear the element
                ko.virtualElements.emptyNode(element);
            } else if ('nodes' in bindingValue) {
                // We've been given an array of DOM nodes. Save them as the template source.
                // There is no known use case for the node array being an observable array (if the output
                // varies, put that behavior *into* your template - that's what templates are for), and
                // the implementation would be a mess, so assert that it's not observable.
                var nodes = bindingValue['nodes'] || [];
                if (ko.isObservable(nodes)) {
                    throw new Error('The "nodes" option must be a plain, non-observable array.');
                }
                var container = ko.utils.moveCleanedNodesToContainerElement(nodes); // This also removes the nodes from their current parent
                new ko.templateSources.anonymousTemplate(element)['nodes'](container);
            } else {
                // It's an anonymous template - store the element contents, then clear the element
                var templateNodes = ko.virtualElements.childNodes(element),
                    container = ko.utils.moveCleanedNodesToContainerElement(templateNodes); // This also removes the nodes from their current parent
                new ko.templateSources.anonymousTemplate(element)['nodes'](container);
            }
            return { 'controlsDescendantBindings': true };
        },
        'update': function (element, valueAccessor, allBindings, viewModel, bindingContext) {
            var value = valueAccessor(),
                options = ko.utils.unwrapObservable(value),
                shouldDisplay = true,
                templateComputed = null,
                templateName;

            if (typeof options == "string") {
                templateName = value;
                options = {};
            } else {
                templateName = options['name'];

                // Support "if"/"ifnot" conditions
                if ('if' in options)
                    shouldDisplay = ko.utils.unwrapObservable(options['if']);
                if (shouldDisplay && 'ifnot' in options)
                    shouldDisplay = !ko.utils.unwrapObservable(options['ifnot']);
            }

            if ('foreach' in options) {
                // Render once for each data point (treating data set as empty if shouldDisplay==false)
                var dataArray = (shouldDisplay && options['foreach']) || [];
                templateComputed = ko.renderTemplateForEach(templateName || element, dataArray, options, element, bindingContext);
            } else if (!shouldDisplay) {
                ko.virtualElements.emptyNode(element);
            } else {
                // Render once for this single data point (or use the viewModel if no data was provided)
                var innerBindingContext = ('data' in options) ?
                    bindingContext.createStaticChildContext(options['data'], options['as']) :  // Given an explitit 'data' value, we create a child binding context for it
                    bindingContext;                                                        // Given no explicit 'data' value, we retain the same binding context
                templateComputed = ko.renderTemplate(templateName || element, innerBindingContext, options, element);
            }

            // It only makes sense to have a single template computed per element (otherwise which one should have its output displayed?)
            disposeOldComputedAndStoreNewOne(element, templateComputed);
        }
    };

    // Anonymous templates can't be rewritten. Give a nice error message if you try to do it.
    ko.expressionRewriting.bindingRewriteValidators['template'] = function(bindingValue) {
        var parsedBindingValue = ko.expressionRewriting.parseObjectLiteral(bindingValue);

        if ((parsedBindingValue.length == 1) && parsedBindingValue[0]['unknown'])
            return null; // It looks like a string literal, not an object literal, so treat it as a named template (which is allowed for rewriting)

        if (ko.expressionRewriting.keyValueArrayContainsKey(parsedBindingValue, "name"))
            return null; // Named templates can be rewritten, so return "no error"
        return "This template engine does not support anonymous templates nested within its templates";
    };

    ko.virtualElements.allowedBindings['template'] = true;
})();

ko.exportSymbol('setTemplateEngine', ko.setTemplateEngine);
ko.exportSymbol('renderTemplate', ko.renderTemplate);
// Go through the items that have been added and deleted and try to find matches between them.
ko.utils.findMovesInArrayComparison = function (left, right, limitFailedCompares) {
    if (left.length && right.length) {
        var failedCompares, l, r, leftItem, rightItem;
        for (failedCompares = l = 0; (!limitFailedCompares || failedCompares < limitFailedCompares) && (leftItem = left[l]); ++l) {
            for (r = 0; rightItem = right[r]; ++r) {
                if (leftItem['value'] === rightItem['value']) {
                    leftItem['moved'] = rightItem['index'];
                    rightItem['moved'] = leftItem['index'];
                    right.splice(r, 1);         // This item is marked as moved; so remove it from right list
                    failedCompares = r = 0;     // Reset failed compares count because we're checking for consecutive failures
                    break;
                }
            }
            failedCompares += r;
        }
    }
};

ko.utils.compareArrays = (function () {
    var statusNotInOld = 'added', statusNotInNew = 'deleted';

    // Simple calculation based on Levenshtein distance.
    function compareArrays(oldArray, newArray, options) {
        // For backward compatibility, if the third arg is actually a bool, interpret
        // it as the old parameter 'dontLimitMoves'. Newer code should use { dontLimitMoves: true }.
        options = (typeof options === 'boolean') ? { 'dontLimitMoves': options } : (options || {});
        oldArray = oldArray || [];
        newArray = newArray || [];

        if (oldArray.length < newArray.length)
            return compareSmallArrayToBigArray(oldArray, newArray, statusNotInOld, statusNotInNew, options);
        else
            return compareSmallArrayToBigArray(newArray, oldArray, statusNotInNew, statusNotInOld, options);
    }

    function compareSmallArrayToBigArray(smlArray, bigArray, statusNotInSml, statusNotInBig, options) {
        var myMin = Math.min,
            myMax = Math.max,
            editDistanceMatrix = [],
            smlIndex, smlIndexMax = smlArray.length,
            bigIndex, bigIndexMax = bigArray.length,
            compareRange = (bigIndexMax - smlIndexMax) || 1,
            maxDistance = smlIndexMax + bigIndexMax + 1,
            thisRow, lastRow,
            bigIndexMaxForRow, bigIndexMinForRow;

        for (smlIndex = 0; smlIndex <= smlIndexMax; smlIndex++) {
            lastRow = thisRow;
            editDistanceMatrix.push(thisRow = []);
            bigIndexMaxForRow = myMin(bigIndexMax, smlIndex + compareRange);
            bigIndexMinForRow = myMax(0, smlIndex - 1);
            for (bigIndex = bigIndexMinForRow; bigIndex <= bigIndexMaxForRow; bigIndex++) {
                if (!bigIndex)
                    thisRow[bigIndex] = smlIndex + 1;
                else if (!smlIndex)  // Top row - transform empty array into new array via additions
                    thisRow[bigIndex] = bigIndex + 1;
                else if (smlArray[smlIndex - 1] === bigArray[bigIndex - 1])
                    thisRow[bigIndex] = lastRow[bigIndex - 1];                  // copy value (no edit)
                else {
                    var northDistance = lastRow[bigIndex] || maxDistance;       // not in big (deletion)
                    var westDistance = thisRow[bigIndex - 1] || maxDistance;    // not in small (addition)
                    thisRow[bigIndex] = myMin(northDistance, westDistance) + 1;
                }
            }
        }

        var editScript = [], meMinusOne, notInSml = [], notInBig = [];
        for (smlIndex = smlIndexMax, bigIndex = bigIndexMax; smlIndex || bigIndex;) {
            meMinusOne = editDistanceMatrix[smlIndex][bigIndex] - 1;
            if (bigIndex && meMinusOne === editDistanceMatrix[smlIndex][bigIndex-1]) {
                notInSml.push(editScript[editScript.length] = {     // added
                    'status': statusNotInSml,
                    'value': bigArray[--bigIndex],
                    'index': bigIndex });
            } else if (smlIndex && meMinusOne === editDistanceMatrix[smlIndex - 1][bigIndex]) {
                notInBig.push(editScript[editScript.length] = {     // deleted
                    'status': statusNotInBig,
                    'value': smlArray[--smlIndex],
                    'index': smlIndex });
            } else {
                --bigIndex;
                --smlIndex;
                if (!options['sparse']) {
                    editScript.push({
                        'status': "retained",
                        'value': bigArray[bigIndex] });
                }
            }
        }

        // Set a limit on the number of consecutive non-matching comparisons; having it a multiple of
        // smlIndexMax keeps the time complexity of this algorithm linear.
        ko.utils.findMovesInArrayComparison(notInBig, notInSml, !options['dontLimitMoves'] && smlIndexMax * 10);

        return editScript.reverse();
    }

    return compareArrays;
})();

ko.exportSymbol('utils.compareArrays', ko.utils.compareArrays);
(function () {
    // Objective:
    // * Given an input array, a container DOM node, and a function from array elements to arrays of DOM nodes,
    //   map the array elements to arrays of DOM nodes, concatenate together all these arrays, and use them to populate the container DOM node
    // * Next time we're given the same combination of things (with the array possibly having mutated), update the container DOM node
    //   so that its children is again the concatenation of the mappings of the array elements, but don't re-map any array elements that we
    //   previously mapped - retain those nodes, and just insert/delete other ones

    // "callbackAfterAddingNodes" will be invoked after any "mapping"-generated nodes are inserted into the container node
    // You can use this, for example, to activate bindings on those nodes.

    function mapNodeAndRefreshWhenChanged(containerNode, mapping, valueToMap, callbackAfterAddingNodes, index) {
        // Map this array value inside a dependentObservable so we re-map when any dependency changes
        var mappedNodes = [];
        var dependentObservable = ko.dependentObservable(function() {
            var newMappedNodes = mapping(valueToMap, index, ko.utils.fixUpContinuousNodeArray(mappedNodes, containerNode)) || [];

            // On subsequent evaluations, just replace the previously-inserted DOM nodes
            if (mappedNodes.length > 0) {
                ko.utils.replaceDomNodes(mappedNodes, newMappedNodes);
                if (callbackAfterAddingNodes)
                    ko.dependencyDetection.ignore(callbackAfterAddingNodes, null, [valueToMap, newMappedNodes, index]);
            }

            // Replace the contents of the mappedNodes array, thereby updating the record
            // of which nodes would be deleted if valueToMap was itself later removed
            mappedNodes.length = 0;
            ko.utils.arrayPushAll(mappedNodes, newMappedNodes);
        }, null, { disposeWhenNodeIsRemoved: containerNode, disposeWhen: function() { return !ko.utils.anyDomNodeIsAttachedToDocument(mappedNodes); } });
        return { mappedNodes : mappedNodes, dependentObservable : (dependentObservable.isActive() ? dependentObservable : undefined) };
    }

    var lastMappingResultDomDataKey = ko.utils.domData.nextKey(),
        deletedItemDummyValue = ko.utils.domData.nextKey();

    ko.utils.setDomNodeChildrenFromArrayMapping = function (domNode, array, mapping, options, callbackAfterAddingNodes) {
        // Compare the provided array against the previous one
        array = array || [];
        options = options || {};
        var isFirstExecution = ko.utils.domData.get(domNode, lastMappingResultDomDataKey) === undefined;
        var lastMappingResult = ko.utils.domData.get(domNode, lastMappingResultDomDataKey) || [];
        var lastArray = ko.utils.arrayMap(lastMappingResult, function (x) { return x.arrayEntry; });
        var editScript = ko.utils.compareArrays(lastArray, array, options['dontLimitMoves']);

        // Build the new mapping result
        var newMappingResult = [];
        var lastMappingResultIndex = 0;
        var newMappingResultIndex = 0;

        var nodesToDelete = [];
        var itemsToProcess = [];
        var itemsForBeforeRemoveCallbacks = [];
        var itemsForMoveCallbacks = [];
        var itemsForAfterAddCallbacks = [];
        var mapData;

        function itemMovedOrRetained(editScriptIndex, oldPosition) {
            mapData = lastMappingResult[oldPosition];
            if (newMappingResultIndex !== oldPosition)
                itemsForMoveCallbacks[editScriptIndex] = mapData;
            // Since updating the index might change the nodes, do so before calling fixUpContinuousNodeArray
            mapData.indexObservable(newMappingResultIndex++);
            ko.utils.fixUpContinuousNodeArray(mapData.mappedNodes, domNode);
            newMappingResult.push(mapData);
            itemsToProcess.push(mapData);
        }

        function callCallback(callback, items) {
            if (callback) {
                for (var i = 0, n = items.length; i < n; i++) {
                    if (items[i]) {
                        ko.utils.arrayForEach(items[i].mappedNodes, function(node) {
                            callback(node, i, items[i].arrayEntry);
                        });
                    }
                }
            }
        }

        for (var i = 0, editScriptItem, movedIndex; editScriptItem = editScript[i]; i++) {
            movedIndex = editScriptItem['moved'];
            switch (editScriptItem['status']) {
                case "deleted":
                    if (movedIndex === undefined) {
                        mapData = lastMappingResult[lastMappingResultIndex];

                        // Stop tracking changes to the mapping for these nodes
                        if (mapData.dependentObservable) {
                            mapData.dependentObservable.dispose();
                            mapData.dependentObservable = undefined;
                        }

                        // Queue these nodes for later removal
                        if (ko.utils.fixUpContinuousNodeArray(mapData.mappedNodes, domNode).length) {
                            if (options['beforeRemove']) {
                                newMappingResult.push(mapData);
                                itemsToProcess.push(mapData);
                                if (mapData.arrayEntry === deletedItemDummyValue) {
                                    mapData = null;
                                } else {
                                    itemsForBeforeRemoveCallbacks[i] = mapData;
                                }
                            }
                            if (mapData) {
                                nodesToDelete.push.apply(nodesToDelete, mapData.mappedNodes);
                            }
                        }
                    }
                    lastMappingResultIndex++;
                    break;

                case "retained":
                    itemMovedOrRetained(i, lastMappingResultIndex++);
                    break;

                case "added":
                    if (movedIndex !== undefined) {
                        itemMovedOrRetained(i, movedIndex);
                    } else {
                        mapData = { arrayEntry: editScriptItem['value'], indexObservable: ko.observable(newMappingResultIndex++) };
                        newMappingResult.push(mapData);
                        itemsToProcess.push(mapData);
                        if (!isFirstExecution)
                            itemsForAfterAddCallbacks[i] = mapData;
                    }
                    break;
            }
        }

        // Store a copy of the array items we just considered so we can difference it next time
        ko.utils.domData.set(domNode, lastMappingResultDomDataKey, newMappingResult);

        // Call beforeMove first before any changes have been made to the DOM
        callCallback(options['beforeMove'], itemsForMoveCallbacks);

        // Next remove nodes for deleted items (or just clean if there's a beforeRemove callback)
        ko.utils.arrayForEach(nodesToDelete, options['beforeRemove'] ? ko.cleanNode : ko.removeNode);

        // Next add/reorder the remaining items (will include deleted items if there's a beforeRemove callback)
        for (var i = 0, nextNode = ko.virtualElements.firstChild(domNode), lastNode, node; mapData = itemsToProcess[i]; i++) {
            // Get nodes for newly added items
            if (!mapData.mappedNodes)
                ko.utils.extend(mapData, mapNodeAndRefreshWhenChanged(domNode, mapping, mapData.arrayEntry, callbackAfterAddingNodes, mapData.indexObservable));

            // Put nodes in the right place if they aren't there already
            for (var j = 0; node = mapData.mappedNodes[j]; nextNode = node.nextSibling, lastNode = node, j++) {
                if (node !== nextNode)
                    ko.virtualElements.insertAfter(domNode, node, lastNode);
            }

            // Run the callbacks for newly added nodes (for example, to apply bindings, etc.)
            if (!mapData.initialized && callbackAfterAddingNodes) {
                callbackAfterAddingNodes(mapData.arrayEntry, mapData.mappedNodes, mapData.indexObservable);
                mapData.initialized = true;
            }
        }

        // If there's a beforeRemove callback, call it after reordering.
        // Note that we assume that the beforeRemove callback will usually be used to remove the nodes using
        // some sort of animation, which is why we first reorder the nodes that will be removed. If the
        // callback instead removes the nodes right away, it would be more efficient to skip reordering them.
        // Perhaps we'll make that change in the future if this scenario becomes more common.
        callCallback(options['beforeRemove'], itemsForBeforeRemoveCallbacks);

        // Replace the stored values of deleted items with a dummy value. This provides two benefits: it marks this item
        // as already "removed" so we won't call beforeRemove for it again, and it ensures that the item won't match up
        // with an actual item in the array and appear as "retained" or "moved".
        for (i = 0; i < itemsForBeforeRemoveCallbacks.length; ++i) {
            if (itemsForBeforeRemoveCallbacks[i]) {
                itemsForBeforeRemoveCallbacks[i].arrayEntry = deletedItemDummyValue;
            }
        }

        // Finally call afterMove and afterAdd callbacks
        callCallback(options['afterMove'], itemsForMoveCallbacks);
        callCallback(options['afterAdd'], itemsForAfterAddCallbacks);
    }
})();

ko.exportSymbol('utils.setDomNodeChildrenFromArrayMapping', ko.utils.setDomNodeChildrenFromArrayMapping);
ko.nativeTemplateEngine = function () {
    this['allowTemplateRewriting'] = false;
}

ko.nativeTemplateEngine.prototype = new ko.templateEngine();
ko.nativeTemplateEngine.prototype.constructor = ko.nativeTemplateEngine;
ko.nativeTemplateEngine.prototype['renderTemplateSource'] = function (templateSource, bindingContext, options, templateDocument) {
    var useNodesIfAvailable = !(ko.utils.ieVersion < 9), // IE<9 cloneNode doesn't work properly
        templateNodesFunc = useNodesIfAvailable ? templateSource['nodes'] : null,
        templateNodes = templateNodesFunc ? templateSource['nodes']() : null;

    if (templateNodes) {
        return ko.utils.makeArray(templateNodes.cloneNode(true).childNodes);
    } else {
        var templateText = templateSource['text']();
        return ko.utils.parseHtmlFragment(templateText, templateDocument);
    }
};

ko.nativeTemplateEngine.instance = new ko.nativeTemplateEngine();
ko.setTemplateEngine(ko.nativeTemplateEngine.instance);

ko.exportSymbol('nativeTemplateEngine', ko.nativeTemplateEngine);
(function() {
    ko.jqueryTmplTemplateEngine = function () {
        // Detect which version of jquery-tmpl you're using. Unfortunately jquery-tmpl
        // doesn't expose a version number, so we have to infer it.
        // Note that as of Knockout 1.3, we only support jQuery.tmpl 1.0.0pre and later,
        // which KO internally refers to as version "2", so older versions are no longer detected.
        var jQueryTmplVersion = this.jQueryTmplVersion = (function() {
            if (!jQueryInstance || !(jQueryInstance['tmpl']))
                return 0;
            // Since it exposes no official version number, we use our own numbering system. To be updated as jquery-tmpl evolves.
            try {
                if (jQueryInstance['tmpl']['tag']['tmpl']['open'].toString().indexOf('__') >= 0) {
                    // Since 1.0.0pre, custom tags should append markup to an array called "__"
                    return 2; // Final version of jquery.tmpl
                }
            } catch(ex) { /* Apparently not the version we were looking for */ }

            return 1; // Any older version that we don't support
        })();

        function ensureHasReferencedJQueryTemplates() {
            if (jQueryTmplVersion < 2)
                throw new Error("Your version of jQuery.tmpl is too old. Please upgrade to jQuery.tmpl 1.0.0pre or later.");
        }

        function executeTemplate(compiledTemplate, data, jQueryTemplateOptions) {
            return jQueryInstance['tmpl'](compiledTemplate, data, jQueryTemplateOptions);
        }

        this['renderTemplateSource'] = function(templateSource, bindingContext, options, templateDocument) {
            templateDocument = templateDocument || document;
            options = options || {};
            ensureHasReferencedJQueryTemplates();

            // Ensure we have stored a precompiled version of this template (don't want to reparse on every render)
            var precompiled = templateSource['data']('precompiled');
            if (!precompiled) {
                var templateText = templateSource['text']() || "";
                // Wrap in "with($whatever.koBindingContext) { ... }"
                templateText = "{{ko_with $item.koBindingContext}}" + templateText + "{{/ko_with}}";

                precompiled = jQueryInstance['template'](null, templateText);
                templateSource['data']('precompiled', precompiled);
            }

            var data = [bindingContext['$data']]; // Prewrap the data in an array to stop jquery.tmpl from trying to unwrap any arrays
            var jQueryTemplateOptions = jQueryInstance['extend']({ 'koBindingContext': bindingContext }, options['templateOptions']);

            var resultNodes = executeTemplate(precompiled, data, jQueryTemplateOptions);
            resultNodes['appendTo'](templateDocument.createElement("div")); // Using "appendTo" forces jQuery/jQuery.tmpl to perform necessary cleanup work

            jQueryInstance['fragments'] = {}; // Clear jQuery's fragment cache to avoid a memory leak after a large number of template renders
            return resultNodes;
        };

        this['createJavaScriptEvaluatorBlock'] = function(script) {
            return "{{ko_code ((function() { return " + script + " })()) }}";
        };

        this['addTemplate'] = function(templateName, templateMarkup) {
            document.write("<script type='text/html' id='" + templateName + "'>" + templateMarkup + "<" + "/script>");
        };

        if (jQueryTmplVersion > 0) {
            jQueryInstance['tmpl']['tag']['ko_code'] = {
                open: "__.push($1 || '');"
            };
            jQueryInstance['tmpl']['tag']['ko_with'] = {
                open: "with($1) {",
                close: "} "
            };
        }
    };

    ko.jqueryTmplTemplateEngine.prototype = new ko.templateEngine();
    ko.jqueryTmplTemplateEngine.prototype.constructor = ko.jqueryTmplTemplateEngine;

    // Use this one by default *only if jquery.tmpl is referenced*
    var jqueryTmplTemplateEngineInstance = new ko.jqueryTmplTemplateEngine();
    if (jqueryTmplTemplateEngineInstance.jQueryTmplVersion > 0)
        ko.setTemplateEngine(jqueryTmplTemplateEngineInstance);

    ko.exportSymbol('jqueryTmplTemplateEngine', ko.jqueryTmplTemplateEngine);
})();
}));
}());
})();


/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(ko) {

var apiKey = apiKeyService.getApiKeysCookie() || apiKeyService.getApiExploreKey(); //API Key

module.exports = {
  placeholder: 'Api key',
  name: 'apikey',
  style: 'query',
  value: ko.observable(apiKey),
  type: 'string',
  required: true
};
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function($) {

var _country = __webpack_require__(48);

var _country2 = _interopRequireDefault(_country);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var base = {};
var CONFIG_URL = '../../scripts/api-explorer/apidescription.xml';

var parseData = function parseData(xml) {
	var global = {};
	//get all APIs
	var resourcesEl = $(xml).find("resources").eq(0);

	// resource
	$(xml).find("resource").get().map(function (res) {
		var resource = $(res);
		// method --------------------------------
		var methodElem = resource.find("method").eq(0);

		var method = {
			id: methodElem.attr("id"), // method id
			name: methodElem.attr("apigee:displayName") || methodElem.attr("id"), // method name
			method: methodElem.attr('name'), // GET or POST
			category: methodElem.find('[primary="true"]').text().trim(), // API name
			path: resource.attr('path'), // method URL
			base: resourcesEl.attr('base'), // method base link
			link: methodElem.find('doc').eq(0).attr('apigee:url'), // link to documentation
			description: methodElem.find('doc').eq(0).text().trim(), //method description
			parameters: {}
		};

		// params --------------------------------
		resource.find('param').get().map(function (par) {
			var param = $(par);
			var options = param.find('option');
			var isSelect = !!options.length;

			var parameter = {
				name: param.attr('name'),
				doc: param.find('doc').first().text().trim(),
				style: param.attr('style'),
				required: param.attr('required') === 'true',
				default: param.attr('default') === 'none' && isSelect ? '' : param.attr('default'),
				select: isSelect,
				type: param.attr('type').replace('xsd:', '')
			};

			if (isSelect) {
				parameter.options = options.get().map(function (option) {
					return {
						name: $(option).attr('value'),
						checked: $(option).attr('value') === parameter.default || $(option).attr('value') === 'none',
						link: false
					};
				});
			}

			if (parameter.name === 'countryCode') {
				parameter.select = true;
				parameter.options = _country2.default;
			}

			method.parameters[parameter.name] = parameter;
		});

		if (method.method === 'POST') {
			method.parameters.requestBody = {
				name: 'Post JSON',
				doc: 'Request JSON body',
				style: 'requestBody',
				required: false,
				default: '',
				select: false,
				type: 'string'
			};
		}

		/**
   * Global obj composition
      */
		// set category obj
		global[method.category] = global[method.category] || {};

		// set methods type obj
		global[method.category].ALL = global[method.category].ALL || {};
		global[method.category][method.method] = global[method.category][method.method] || {};

		// set method obj
		global[method.category].ALL[method.id] = global[method.category][method.method][method.id] = method;
	});

	return global;
};

//gets document from WADL configuration file
var readFromWADL = function readFromWADL() {
	$.ajax({
		url: CONFIG_URL,
		async: false,
		dataType: "text",
		success: function success(response) {
			var xml = $.parseXML(response);
			base = parseData(xml);
		},

		error: function error(XMLHttpRequest, textStatus, errorThrown) {
			alert('Data Could Not Be Loaded - ' + textStatus);
		}
	});
};
readFromWADL();
module.exports = base;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(ko, $, global) {

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _base = __webpack_require__(6);

var _base2 = _interopRequireDefault(_base);

var _apiKey = __webpack_require__(5);

var _apiKey2 = _interopRequireDefault(_apiKey);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Rest service
 * Gets data from server
 */
var instance = void 0;

var RestService = function () {
	function RestService() {
		var _this = this;

		_classCallCheck(this, RestService);

		this.callback = function (res, msg) {
			var category = ko.unwrap(_this.selectedCategory);
			var type = ko.unwrap(_this.selectedMethodType);
			var methodId = ko.unwrap(_this.selectedMethod);
			var params = ko.unwrap(_this.selectedParams);

			var resObj = {
				category: category,
				method: type,
				methodId: methodId,
				params: params.map(function (obj) {
					return $.extend(true, {}, {
						name: obj.name,
						value: ko.observable(ko.unwrap(obj.value)),
						options: obj.options
					});
				}),
				req: _this.req,
				index: _this.requests().length
			};

			if (msg == 'error') {
				// notifying error modal
				_this.error = ko.observable(res).publishOn('REQUEST_ERROR');
				// error popover of request
				resObj.error = res;
			} else {
				_this.error && delete _this.error;
				global.lastResponse = resObj.response = res.responseJSON;
			}

			// exporting data using observable
			_this.requests.unshift(resObj);
			_this.requestInProgress(false);
		};

		this.parseUrl = function (url) {
			var location = url ? '?' + url.split('?')[1] : window.location.search;

			if (location) {
				var querys = location.replace(/^\?/g, '').split('&');
				var obj = {
					apiCategory: '',
					methodId: '',
					parameters: []
				};

				var globalQueryObj = window.location.query = {};
				querys.map(function (query) {
					var _decodeURI$split = decodeURI(query).split('='),
					    _decodeURI$split2 = _slicedToArray(_decodeURI$split, 2),
					    key = _decodeURI$split2[0],
					    val = _decodeURI$split2[1];

					if (Object.keys(obj).indexOf(key) !== -1) {
						try {
							obj[key] = globalQueryObj[key] = JSON.parse(val);
						} catch (exception_var) {
							obj[key] = globalQueryObj[key] = val;
						}
					} else {
						try {
							globalQueryObj[key] = JSON.parse(val);
						} catch (exception_var) {
							globalQueryObj[key] = val;
						}

						obj.parameters.push({
							name: key,
							value: globalQueryObj[key]
						});
					}
				});

				var methodData = _this.getMethodData(obj);
				var parameters = methodData.parameters;

				obj.parameters = obj.parameters.map(function (obj) {
					return $.extend(true, {}, parameters[obj.name], obj);
				});
				return obj;
			}
			return {};
		};

		if (!instance) {
			instance = this;
		}
		this.base = _base2.default;
		this.apiKey = _apiKey2.default;
		this.selectedCategory = ko.observable('').subscribeTo('SELECTED_CATEGORY');
		this.selectedMethodType = ko.observable('').subscribeTo('SELECTED_METHOD_TYPE');
		this.selectedMethod = ko.observable('').subscribeTo('SELECTED_METHOD');
		this.selectedParams = ko.observableArray([]).subscribeTo('SELECTED_PARAMS');
		this.requests = ko.observableArray([]).syncWith('REQUESTS_ARR');
		this.anotherResponse = ko.observable().publishOn('ANOTHER_RESPONSE');
		this.requestInProgress = ko.observable(false);
		this.init();
		return instance;
	}

	_createClass(RestService, [{
		key: 'init',
		value: function init() {
			var _this2 = this;

			ko.postbox.subscribe('SELECTED_METHOD', function (newValue) {
				_this2.selectedMethodData = _this2.getMethodData();
			});

			ko.postbox.subscribe('ANOTHER_REQUEST', function (_ref) {
				var method = _ref.method,
				    panelGroup = _ref.panelGroup,
				    color = _ref.color;

				_this2.anotherRequest = true;
				var url = _this2.prepareUrl(method.base, method.path, method.parameters);

				_this2.ajaxService({ url: url, type: method.method, callback: function callback(res, msg) {
						var category = method.category;
						var type = method.method;
						var methodId = method.id;
						var params = method.parameters;

						var resObj = {
							category: category,
							method: type,
							methodId: methodId,
							params: params.map(function (obj) {
								return $.extend(true, {}, {
									name: obj.name,
									value: ko.observable(ko.unwrap(obj.value)),
									options: obj.options
								});
							}),
							req: _this2.req,
							index: _this2.requests().length
						};

						if (msg == 'error') {
							// notifying error modal
							_this2.error = ko.observable(res).publishOn('REQUEST_ERROR');
						} else {
							_this2.error && delete _this2.error;
							resObj.response = res.responseJSON;
						}

						// exporting data using observable
						_this2.anotherResponse({ data: resObj, panelGroup: panelGroup, color: color });
					} });
			});
		}
	}, {
		key: 'sendRequest',
		value: function sendRequest(apikeyActive) {
			this.apikeyActive = apikeyActive || ko.unwrap(this.apiKey.value);
			var type = ko.unwrap(this.selectedMethodType);
			this.req = this.prepareUrl();
			this.ajaxService({ url: this.req, type: type, callback: this.callback });
			this.requestInProgress(true);
		}

		/**
   * Filters and prepares params pairs
   * @returns {boolean}
   */

	}, {
		key: 'prepareUrl',
		value: function prepareUrl(_domain, _path, _selectedParams) {
			var replacement = void 0,
			    url = void 0,
			    params = void 0,
			    selectedParams = ko.unwrap(_selectedParams || this.selectedParams);

			var domain = _domain || this.selectedMethodData.base;
			var path = _path || this.selectedMethodData.path;

			params = selectedParams.filter(function (item) {
				return item.style === 'query';
			});

			// arr of template marks
			replacement = path.match(/([^{]*?)\w(?=\})/gmi);

			// arr of template params
			var templatesArr = selectedParams.filter(function (item) {
				return item.style === 'template';
			});

			// replacement
			replacement.forEach(function (val) {
				var param = templatesArr.find(function (item) {
					return item.name === val;
				});
				path = path.replace('{' + param.name + '}', ko.unwrap(param.value) || param.default);
			});

			// prepares params part of url
			params = params.map(function (item) {
				return [item.name, ko.unwrap(item.value) || item.default].join('=');
			}).join('&');

			url = [domain, '/', path, '?apikey=' + this.apikeyActive + '&', params].join('');

			return encodeURI(url);
		}

		/**
   * Ajax Service
   */

	}, {
		key: 'ajaxService',
		value: function ajaxService(_ref2) {
			var url = _ref2.url,
			    _ref2$type = _ref2.type,
			    type = _ref2$type === undefined ? 'GET' : _ref2$type,
			    _ref2$async = _ref2.async,
			    async = _ref2$async === undefined ? true : _ref2$async,
			    _ref2$dataType = _ref2.dataType,
			    dataType = _ref2$dataType === undefined ? 'json' : _ref2$dataType,
			    callback = _ref2.callback;

			var method = this.base[ko.unwrap(this.selectedCategory)][ko.unwrap(this.selectedMethodType)][ko.unwrap(this.selectedMethod)].method;
			var obj = {
				type: method,
				url: url,
				async: async,
				dataType: dataType,
				complete: callback
			};
			if (method === 'POST') {
				obj.headers = $.extend(true, {}, this.getHeaders());
				var body = ko.unwrap(ko.unwrap(this.selectedParams).find(function (param) {
					return param.style === 'requestBody';
				}).value);
				try {
					obj.data = JSON.parse(body);
				} catch (err) {
					obj.data = { "body": body };
				}
			}
			$.ajax(obj);
		}
	}, {
		key: 'getHeaders',
		value: function getHeaders() {
			var headersObj = {};
			ko.unwrap(this.selectedParams).map(function (param) {
				if (param.style === 'header') {
					headersObj[param.name] = ko.unwrap(param.value);
				}
			});
			return headersObj;
		}
	}, {
		key: 'getMethodData',
		value: function getMethodData() {
			var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

			var category = ko.unwrap(params.apiCategory || this.selectedCategory);
			var methodType = ko.unwrap(params.type || this.selectedMethodType || 'ALL');
			var method = ko.unwrap(params.methodId || this.selectedMethod);
			return this.base[category] && this.base[category][methodType] && this.base[category][methodType][method] || {};
		}
	}]);

	return RestService;
}();

module.exports = new RestService();
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0), __webpack_require__(1), __webpack_require__(3)))

/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(ko, $) {

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; /**
                                                                                                                                                                                                                                                                               * Main file for Api Explrer v2.0
                                                                                                                                                                                                                                                                               * For development please use Webpack to bundle all modules
                                                                                                                                                                                                                                                                               * It can be made using npm scripts cmd - 'webpack'
                                                                                                                                                                                                                                                                               */

// custom bindings


var _modules = __webpack_require__(42);

var modules = _interopRequireWildcard(_modules);

var _customBindings = __webpack_require__(39);

var customBindings = _interopRequireWildcard(_customBindings);

var _components = __webpack_require__(19);

var components = _interopRequireWildcard(_components);

var _services = __webpack_require__(2);

var services = _interopRequireWildcard(_services);

var _rest = __webpack_require__(7);

var restSrv = _interopRequireWildcard(_rest);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Gets deep prop
 * @returns {*[]}
 */
Object.getProp = function (o, s) {
	if (((typeof o === 'undefined' ? 'undefined' : _typeof(o)) !== 'object' || o == null) && !s) {
		return;
	}
	s = s.replace(/\[(\w+)\]/g, '.$1'); // convert indexes to properties
	s = s.replace(/^\./, ''); // strip a leading dot
	var a = s.split('.');
	for (var i = 0, n = a.length; i < n; ++i) {
		var k = a[i];
		if (o && k in o) {
			o = o[k];
		} else {
			return;
		}
	}
	return o;
};

var AppViewModel = function () {
	function AppViewModel(_ref) {
		var _this = this;

		var _ref$base = _ref.base,
		    base = _ref$base === undefined ? {} : _ref$base,
		    apiKey = _ref.apiKey,
		    config = _ref.config,
		    rest = _ref.rest;

		_classCallCheck(this, AppViewModel);

		this.setParams = function (_ref2) {
			var category = _ref2.category,
			    _ref2$method = _ref2.method,
			    method = _ref2$method === undefined ? 'ALL' : _ref2$method,
			    methodId = _ref2.methodId,
			    params = _ref2.params;

			_this.selectedCategory(category);
			_this.selectedMethodType(method);
			_this.selectedMethod(methodId);
			_this.selectedParams.notifySubscribers(params, 'paramsSet');
		};

		this.base = base;
		this.apiKey = apiKey;
		this.apiKeyInputId = '#api-key';
		this.config = config;
		this.restService = rest;
		this.paramsIsHiden = ko.observable(true);

		var parsedUrl = this.parseUrl();
		// observables
		this.selectedCategory = ko.observable(parsedUrl.apiCategory || '').syncWith('SELECTED_CATEGORY');
		this.selectedMethodType = ko.observable('ALL').syncWith('SELECTED_METHOD_TYPE');
		this.selectedMethod = ko.observable(parsedUrl.methodId || '').syncWith('SELECTED_METHOD');
		this.selectedParams = ko.observableArray([]).syncWith('SELECTED_PARAMS');
		this.selectedMethodData = ko.observable(this.getMethodData({}));

		this.initValidation();

		// computed
		this.sendButtonText = ko.pureComputed(function () {
			return ko.unwrap(_this.selectedMethodData).method;
		});
		this.requestInProgress = this.restService.requestInProgress;
		this.sharePath = ko.pureComputed(function () {
			return _this.formDeepLinkingUrl();
		});

		this.selectedMethod.subscribe(function (val) {
			_this.paramsIsHiden(true);
			_this.validationModel($.extend({}, ko.unwrap(_this.apiKeyValidationModel)));
			_this.selectedMethodData(_this.getMethodData({ methodId: val }));
		});
		$(this.apiKeyInputId).val(ko.unwrap(this.apiKey.value)).show();
	}

	/**
  * Validation watchers and logic
  */


	_createClass(AppViewModel, [{
		key: 'initValidation',
		value: function initValidation() {
			var _this2 = this;

			this.apiKeyValidationModel = ko.observable({});
			this.validationModel = ko.observable({});

			this.sendBtnValidationText = ko.observable('');
			this.formIsValid = ko.observable(true);
			ko.computed(function () {
				var validationModel = ko.validatedObservable($.extend({}, ko.unwrap(_this2.validationModel), ko.unwrap(_this2.apiKeyValidationModel)));
				var validationFlag = validationModel.isValid() || !$('.custom-input__field.not-valid').length;
				_this2.sendBtnValidationText(validationFlag ? '' : _this2.validationText);
				_this2.formIsValid(validationFlag);
			});
		}

		/**
   * Send request method
   */

	}, {
		key: 'onClickSendBtn',
		value: function onClickSendBtn() {
			var model = ko.validatedObservable($.extend({}, ko.unwrap(this.validationModel), ko.unwrap(this.apiKeyValidationModel)));
			if (model.isValid()) {
				var activeKey = $(this.apiKeyInputId).val();
				this.restService.sendRequest(activeKey);
			} else {
				this.paramsIsHiden(false); // slide toggle when params are not valid
				this.formIsValid(false);
				this.sendBtnValidationText(this.validationText);
				model.errors.showAllMessages();
			}
		}
	}, {
		key: 'formDeepLinkingUrl',
		value: function formDeepLinkingUrl() {
			var location = window.location;
			var category = ko.unwrap(this.selectedCategory);
			var method = ko.unwrap(this.selectedMethod);
			var params = ko.unwrap(this.selectedParams);

			var querys = ['apiCategory=' + encodeURI(category), 'methodId=' + encodeURI(method)];

			params.map(function (param) {
				var value = ko.unwrap(param.value);
				var defaultValue = ko.unwrap(param.default);
				querys.push(param.name + '=' + (value !== '' ? value : defaultValue)); //todo: remove default from here when set up it in source like value by default
				return param;
			});

			return '' + location.origin + location.pathname.replace(/\/$/gmi, '') + '?' + querys.join('&');
		}

		//rest service

	}, {
		key: 'getMethodData',
		value: function getMethodData(_ref3) {
			var apiCategory = _ref3.apiCategory,
			    type = _ref3.type,
			    methodId = _ref3.methodId;

			var category = ko.unwrap(apiCategory || this.selectedCategory);
			var methodType = ko.unwrap(type || this.selectedMethodType || 'ALL');
			var method = ko.unwrap(methodId || this.selectedMethod);
			return this.base[category] && this.base[category][methodType] && this.base[category][methodType][method] || {};
		}

		//**********

	}, {
		key: 'parseUrl',
		value: function parseUrl() {
			var location = window.location.search;

			if (location) {
				var querys = location.replace(/^\?/g, '').split('&');
				var obj = {
					apiCategory: '',
					methodId: '',
					parameters: []
				};

				var globalQueryObj = window.location.query = {};
				querys.map(function (query) {
					var _decodeURI$split = decodeURI(query).split('='),
					    _decodeURI$split2 = _slicedToArray(_decodeURI$split, 2),
					    key = _decodeURI$split2[0],
					    val = _decodeURI$split2[1];

					if (Object.keys(obj).indexOf(key) !== -1) {
						try {
							obj[key] = globalQueryObj[key] = JSON.parse(val);
						} catch (exception_var) {
							obj[key] = globalQueryObj[key] = val;
						}
					} else {
						try {
							globalQueryObj[key] = JSON.parse(val);
						} catch (exception_var) {
							globalQueryObj[key] = val;
						}

						obj.parameters.push({
							name: key,
							value: globalQueryObj[key]
						});
					}
				});

				var methodData = this.getMethodData(obj);
				var parameters = methodData.parameters;

				obj.parameters.map(function (obj) {
					parameters[obj.name].value = obj.value;
					return obj;
				});
				obj.parameters = parameters;
				return obj;
			}
			return {};
		}
		//**********

	}, {
		key: 'validationText',
		get: function get() {
			return 'Please solve form validation issues';
		}
	}]);

	return AppViewModel;
}();

var app = new AppViewModel(services);
/**
 * Activates knockout.js
 */
ko.applyBindings(app);

/**
 * exports global variable
 */
module.exports = app;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0), __webpack_require__(1)))

/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function () {
	return __webpack_require__(62)("/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// identity function for calling harmony imports with the correct context\n/******/ \t__webpack_require__.i = function(value) { return value; };\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 1);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar prefix = 'tm-code';\n\nvar getExpanderClasses = function getExpanderClasses(expanded) {\n\tif (!expanded) {\n\t\treturn 'expanded collapsed hidden';\n\t}\n\treturn 'expanded';\n};\n\nvar encode = function encode(value) {\n\treturn ['<span>', value, '</span>'].join('');\n};\n\nvar createElement = function createElement(key, value, type, expanderClasses) {\n\tvar klass = 'object',\n\t    open = '{',\n\t    close = '}';\n\n\tif (Array.isArray(value)) {\n\t\tklass = 'array';\n\t\topen = '[';\n\t\tclose = ']';\n\t}\n\n\tif (value === null) {\n\t\treturn ['<li>', '<span class=\"key\">\"', encode(key), '\": </span>', '<span class=\"null\">\"', encode(value), '\"</span>', '</li>'].join('');\n\t}\n\n\tif (type == 'object') {\n\t\treturn ['<li>', '<span class=\"', expanderClasses, '\"></span>', '<span class=\"key\">\"', encode(key), '\": </span> ', '<span class=\"open\">', open, '</span> ', '<ul class=\"', klass, '\">', json2html(value, expanderClasses), '</ul>', '<span class=\"close\">', close, '</span>', '</li>'].join('');\n\t}\n\n\tif (type == 'number' || type == 'boolean') {\n\t\treturn ['<li>', '<span class=\"key\">\"', encode(key), '\": </span>', '<span class=\"', type, '\">', encode(value), '</span>', '</li>'].join('');\n\t}\n\treturn ['<li>', '<span class=\"key\">\"', encode(key), '\": </span>', '<span class=\"', type, '\">\"', encode(value), '\"</span>', '</li>'].join('');\n};\n\nvar json2html = function json2html(json, expanderClasses) {\n\tvar html = '';\n\tfor (var key in json) {\n\t\tif (!json.hasOwnProperty(key)) {\n\t\t\tcontinue;\n\t\t}\n\n\t\thtml = [html, createElement(key, json[key], _typeof(json[key]), expanderClasses)].join('');\n\t}\n\treturn html;\n};\n\nvar getJsonViewer = function getJsonViewer(data, options) {\n\ttry {\n\t\treturn ['<ul class=\"', prefix, '-container\">', json2html([JSON.parse(data)], getExpanderClasses(options.expanded)), '</ul>'].join('');\n\t} catch (e) {\n\t\treturn ['<div class=\"', prefix, '-error\" >', e.toString(), ' </div>'].join('');\n\t}\n};\n\nmodule.exports = function (data, opt) {\n\tvar json = '';\n\tvar options = opt || { expanded: true };\n\tif (typeof data == 'string') {\n\t\tjson = data;\n\t} else if ((typeof data === 'undefined' ? 'undefined' : _typeof(data)) == 'object') {\n\t\tjson = JSON.stringify(data);\n\t}\n\treturn getJsonViewer(json, options);\n};\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/**\r\n * Code format web-worker\r\n * @param event\r\n */\r\n// var highlightJson()\r\nvar highlightJson = __webpack_require__(0);\r\n\r\nonmessage = function(event) {\r\n  var code = event.data;\r\n  // importScripts('json-parse.js');\r\n  var result = highlightJson(code, {expanded: true});\r\n  // var result =JSON.stringify(code);\r\n  postMessage(result);\r\n};\r\n\n\n/***/ })\n/******/ ]);\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAgYTEwNDJkNGQwZjI2NTU4ZDJhYjEiLCJ3ZWJwYWNrOi8vLy4vc2NyaXB0cy9hcGktZXhwbG9yZXIvdjIvc3JjL3NlcnZpY2VzL2pzb24taGlnaGxpZ2h0L2pzb24tcGFyc2UuanMiLCJ3ZWJwYWNrOi8vLy4vc2NyaXB0cy9hcGktZXhwbG9yZXIvdjIvc3JjL3NlcnZpY2VzL2pzb24taGlnaGxpZ2h0L2hpZ2hsaWdodEpzb24ud29ya2VyLmpzIl0sIm5hbWVzIjpbInByZWZpeCIsImdldEV4cGFuZGVyQ2xhc3NlcyIsImV4cGFuZGVkIiwiZW5jb2RlIiwidmFsdWUiLCJqb2luIiwiY3JlYXRlRWxlbWVudCIsImtleSIsInR5cGUiLCJleHBhbmRlckNsYXNzZXMiLCJrbGFzcyIsIm9wZW4iLCJjbG9zZSIsIkFycmF5IiwiaXNBcnJheSIsImpzb24yaHRtbCIsImpzb24iLCJodG1sIiwiaGFzT3duUHJvcGVydHkiLCJnZXRKc29uVmlld2VyIiwiZGF0YSIsIm9wdGlvbnMiLCJKU09OIiwicGFyc2UiLCJlIiwidG9TdHJpbmciLCJtb2R1bGUiLCJleHBvcnRzIiwib3B0Iiwic3RyaW5naWZ5Il0sIm1hcHBpbmdzIjoiO0FBQUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsbURBQTJDLGNBQWM7O0FBRXpEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsbUNBQTJCLDBCQUEwQixFQUFFO0FBQ3ZELHlDQUFpQyxlQUFlO0FBQ2hEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDhEQUFzRCwrREFBK0Q7O0FBRXJIO0FBQ0E7O0FBRUE7QUFDQTs7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LElBQUlFLGdCQUFnQixTQUFoQkEsYUFBZ0IsQ0FBVUMsSUFBVixFQUFnQkMsT0FBaEIsRUFBeUI7QUFDNUMsS0FBSTtBQUNILFNBQU8sQ0FDTixhQURNLEVBQ1NyQixNQURULEVBQ2lCLGNBRGpCLEVBRUxlLFVBQVUsQ0FBQ08sS0FBS0MsS0FBTCxDQUFXSCxJQUFYLENBQUQsQ0FBVixFQUE4Qm5CLG1CQUFtQm9CLFFBQVFuQixRQUEzQixDQUE5QixDQUZLLEVBR04sT0FITSxFQUlMRyxJQUpLLENBSUEsRUFKQSxDQUFQO0FBS0EsRUFORCxDQU1FLE9BQU9tQixDQUFQLEVBQVU7QUFDWCxTQUFPLENBQ04sY0FETSxFQUNVeEIsTUFEVixFQUNrQixXQURsQixFQUMrQndCLEVBQUVDLFFBQUYsRUFEL0IsRUFDNkMsU0FEN0MsRUFFTHBCLElBRkssQ0FFQSxFQUZBLENBQVA7QUFHQTtBQUNELENBWkQ7O0FBY0FxQixPQUFPQyxPQUFQLEdBQWlCLFVBQVNQLElBQVQsRUFBZVEsR0FBZixFQUFvQjtBQUNwQyxLQUFJWixPQUFPLEVBQVg7QUFDQSxLQUFJSyxVQUFVTyxPQUFPLEVBQUMxQixVQUFVLElBQVgsRUFBckI7QUFDQSxLQUFJLE9BQU9rQixJQUFQLElBQWUsUUFBbkIsRUFBNkI7QUFDNUJKLFNBQU9JLElBQVA7QUFDQSxFQUZELE1BRU8sSUFBSSxRQUFPQSxJQUFQLHlDQUFPQSxJQUFQLE1BQWUsUUFBbkIsRUFBNkI7QUFDbkNKLFNBQU9NLEtBQUtPLFNBQUwsQ0FBZVQsSUFBZixDQUFQO0FBQ0E7QUFDRCxRQUFPRCxjQUFjSCxJQUFkLEVBQW9CSyxPQUFwQixDQUFQO0FBQ0EsQ0FURCxDOzs7Ozs7QUN6RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxlQUFlO0FBQ25EO0FBQ0E7QUFDQSIsImZpbGUiOiJoaWdobGlnaHRKc29uLndvcmtlci5qcyIsInNvdXJjZXNDb250ZW50IjpbIiBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbiBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG5cbiBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cbiBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKVxuIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuXG4gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbiBcdFx0XHRpOiBtb2R1bGVJZCxcbiBcdFx0XHRsOiBmYWxzZSxcbiBcdFx0XHRleHBvcnRzOiB7fVxuIFx0XHR9O1xuXG4gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4gXHRcdG1vZHVsZS5sID0gdHJ1ZTtcblxuIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4gXHR9XG5cblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuXG4gXHQvLyBpZGVudGl0eSBmdW5jdGlvbiBmb3IgY2FsbGluZyBoYXJtb255IGltcG9ydHMgd2l0aCB0aGUgY29ycmVjdCBjb250ZXh0XG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmkgPSBmdW5jdGlvbih2YWx1ZSkgeyByZXR1cm4gdmFsdWU7IH07XG5cbiBcdC8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb24gZm9yIGhhcm1vbnkgZXhwb3J0c1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kID0gZnVuY3Rpb24oZXhwb3J0cywgbmFtZSwgZ2V0dGVyKSB7XG4gXHRcdGlmKCFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywgbmFtZSkpIHtcbiBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgbmFtZSwge1xuIFx0XHRcdFx0Y29uZmlndXJhYmxlOiBmYWxzZSxcbiBcdFx0XHRcdGVudW1lcmFibGU6IHRydWUsXG4gXHRcdFx0XHRnZXQ6IGdldHRlclxuIFx0XHRcdH0pO1xuIFx0XHR9XG4gXHR9O1xuXG4gXHQvLyBnZXREZWZhdWx0RXhwb3J0IGZ1bmN0aW9uIGZvciBjb21wYXRpYmlsaXR5IHdpdGggbm9uLWhhcm1vbnkgbW9kdWxlc1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5uID0gZnVuY3Rpb24obW9kdWxlKSB7XG4gXHRcdHZhciBnZXR0ZXIgPSBtb2R1bGUgJiYgbW9kdWxlLl9fZXNNb2R1bGUgP1xuIFx0XHRcdGZ1bmN0aW9uIGdldERlZmF1bHQoKSB7IHJldHVybiBtb2R1bGVbJ2RlZmF1bHQnXTsgfSA6XG4gXHRcdFx0ZnVuY3Rpb24gZ2V0TW9kdWxlRXhwb3J0cygpIHsgcmV0dXJuIG1vZHVsZTsgfTtcbiBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kKGdldHRlciwgJ2EnLCBnZXR0ZXIpO1xuIFx0XHRyZXR1cm4gZ2V0dGVyO1xuIFx0fTtcblxuIFx0Ly8gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSBmdW5jdGlvbihvYmplY3QsIHByb3BlcnR5KSB7IHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSk7IH07XG5cbiBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIlwiO1xuXG4gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbiBcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKF9fd2VicGFja19yZXF1aXJlX18ucyA9IDEpO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHdlYnBhY2svYm9vdHN0cmFwIGExMDQyZDRkMGYyNjU1OGQyYWIxIiwidmFyIHByZWZpeCA9ICd0bS1jb2RlJztcclxuXHJcbnZhciBnZXRFeHBhbmRlckNsYXNzZXMgPSBmdW5jdGlvbiAoZXhwYW5kZWQpIHtcclxuXHRpZiAoIWV4cGFuZGVkKSB7XHJcblx0XHRyZXR1cm4gJ2V4cGFuZGVkIGNvbGxhcHNlZCBoaWRkZW4nO1xyXG5cdH1cclxuXHRyZXR1cm4gJ2V4cGFuZGVkJztcclxufTtcclxuXHJcbnZhciBlbmNvZGUgPSBmdW5jdGlvbiAodmFsdWUpIHtcclxuXHRyZXR1cm4gWyc8c3Bhbj4nLCB2YWx1ZSwgJzwvc3Bhbj4nXS5qb2luKCcnKTtcclxufTtcclxuXHJcbnZhciBjcmVhdGVFbGVtZW50ID0gZnVuY3Rpb24gKGtleSwgdmFsdWUsIHR5cGUsIGV4cGFuZGVyQ2xhc3Nlcykge1xyXG5cdHZhciBrbGFzcyA9ICdvYmplY3QnLFxyXG5cdFx0b3BlbiA9ICd7JyxcclxuXHRcdGNsb3NlID0gJ30nO1xyXG5cclxuXHRpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcclxuXHRcdGtsYXNzID0gJ2FycmF5JztcclxuXHRcdG9wZW4gPSAnWyc7XHJcblx0XHRjbG9zZSA9ICddJztcclxuXHR9XHJcblxyXG5cdGlmICh2YWx1ZSA9PT0gbnVsbCkge1xyXG5cdFx0cmV0dXJuIFtcclxuXHRcdFx0JzxsaT4nLFxyXG5cdFx0XHRcdCc8c3BhbiBjbGFzcz1cImtleVwiPlwiJywgZW5jb2RlKGtleSksICdcIjogPC9zcGFuPicsXHJcblx0XHRcdFx0JzxzcGFuIGNsYXNzPVwibnVsbFwiPlwiJywgZW5jb2RlKHZhbHVlKSwgJ1wiPC9zcGFuPicsXHJcblx0XHRcdCc8L2xpPidcclxuXHRcdF0uam9pbignJyk7XHJcblx0fVxyXG5cclxuXHRpZiAodHlwZSA9PSAnb2JqZWN0Jykge1xyXG5cdFx0cmV0dXJuIFtcclxuXHRcdFx0JzxsaT4nLFxyXG5cdFx0XHRcdCc8c3BhbiBjbGFzcz1cIicsIGV4cGFuZGVyQ2xhc3NlcywgJ1wiPjwvc3Bhbj4nLFxyXG5cdFx0XHRcdCc8c3BhbiBjbGFzcz1cImtleVwiPlwiJywgZW5jb2RlKGtleSksICdcIjogPC9zcGFuPiAnLFxyXG5cdFx0XHRcdCc8c3BhbiBjbGFzcz1cIm9wZW5cIj4nLCBvcGVuLCAnPC9zcGFuPiAnLFxyXG5cdFx0XHRcdCc8dWwgY2xhc3M9XCInLCBrbGFzcywgJ1wiPicsXHJcblx0XHRcdFx0XHRqc29uMmh0bWwodmFsdWUsIGV4cGFuZGVyQ2xhc3NlcyksXHJcblx0XHRcdFx0JzwvdWw+JyxcclxuXHRcdFx0XHQnPHNwYW4gY2xhc3M9XCJjbG9zZVwiPicsIGNsb3NlLCAnPC9zcGFuPicsXHJcblx0XHRcdCc8L2xpPidcclxuXHRcdF0uam9pbignJyk7XHJcblx0fVxyXG5cclxuXHRpZiAodHlwZSA9PSAnbnVtYmVyJyB8fCB0eXBlID09ICdib29sZWFuJykge1xyXG5cdFx0cmV0dXJuIFtcclxuXHRcdFx0JzxsaT4nLFxyXG5cdFx0XHRcdCc8c3BhbiBjbGFzcz1cImtleVwiPlwiJywgZW5jb2RlKGtleSksICdcIjogPC9zcGFuPicsXHJcblx0XHRcdFx0JzxzcGFuIGNsYXNzPVwiJywgdHlwZSwgJ1wiPicsIGVuY29kZSh2YWx1ZSksICc8L3NwYW4+JyxcclxuXHRcdFx0JzwvbGk+J1xyXG5cdFx0XS5qb2luKCcnKTtcclxuXHR9XHJcblx0cmV0dXJuIFtcclxuXHRcdCc8bGk+JyxcclxuXHRcdFx0JzxzcGFuIGNsYXNzPVwia2V5XCI+XCInLCBlbmNvZGUoa2V5KSwgJ1wiOiA8L3NwYW4+JyxcclxuXHRcdFx0JzxzcGFuIGNsYXNzPVwiJywgdHlwZSwgJ1wiPlwiJywgZW5jb2RlKHZhbHVlKSwgJ1wiPC9zcGFuPicsXHJcblx0XHQnPC9saT4nXHJcblx0XS5qb2luKCcnKTtcclxufTtcclxuXHJcbnZhciBqc29uMmh0bWwgPSBmdW5jdGlvbiAoanNvbiwgZXhwYW5kZXJDbGFzc2VzKSB7XHJcblx0dmFyIGh0bWwgPSAnJztcclxuXHRmb3IgKHZhciBrZXkgaW4ganNvbikge1xyXG5cdFx0aWYgKCFqc29uLmhhc093blByb3BlcnR5KGtleSkpIHtcclxuXHRcdFx0Y29udGludWU7XHJcblx0XHR9XHJcblxyXG5cdFx0aHRtbCA9IFtodG1sLCBjcmVhdGVFbGVtZW50KGtleSwganNvbltrZXldLCB0eXBlb2YganNvbltrZXldLCBleHBhbmRlckNsYXNzZXMpXS5qb2luKCcnKTtcclxuXHR9XHJcblx0cmV0dXJuIGh0bWw7XHJcbn07XHJcblxyXG52YXIgZ2V0SnNvblZpZXdlciA9IGZ1bmN0aW9uIChkYXRhLCBvcHRpb25zKSB7XHJcblx0dHJ5IHtcclxuXHRcdHJldHVybiBbXHJcblx0XHRcdCc8dWwgY2xhc3M9XCInLCBwcmVmaXgsICctY29udGFpbmVyXCI+JyxcclxuXHRcdFx0XHRqc29uMmh0bWwoW0pTT04ucGFyc2UoZGF0YSldLCBnZXRFeHBhbmRlckNsYXNzZXMob3B0aW9ucy5leHBhbmRlZCkpLFxyXG5cdFx0XHQnPC91bD4nXHJcblx0XHRdLmpvaW4oJycpO1xyXG5cdH0gY2F0Y2ggKGUpIHtcclxuXHRcdHJldHVybiBbXHJcblx0XHRcdCc8ZGl2IGNsYXNzPVwiJywgcHJlZml4LCAnLWVycm9yXCIgPicsIGUudG9TdHJpbmcoKSwgJyA8L2Rpdj4nXHJcblx0XHRdLmpvaW4oJycpO1xyXG5cdH1cclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oZGF0YSwgb3B0KSB7XHJcblx0dmFyIGpzb24gPSAnJztcclxuXHR2YXIgb3B0aW9ucyA9IG9wdCB8fCB7ZXhwYW5kZWQ6IHRydWV9O1xyXG5cdGlmICh0eXBlb2YgZGF0YSA9PSAnc3RyaW5nJykge1xyXG5cdFx0anNvbiA9IGRhdGE7XHJcblx0fSBlbHNlIGlmICh0eXBlb2YgZGF0YSA9PSAnb2JqZWN0Jykge1xyXG5cdFx0anNvbiA9IEpTT04uc3RyaW5naWZ5KGRhdGEpXHJcblx0fVxyXG5cdHJldHVybiBnZXRKc29uVmlld2VyKGpzb24sIG9wdGlvbnMpO1xyXG59O1xyXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zY3JpcHRzL2FwaS1leHBsb3Jlci92Mi9zcmMvc2VydmljZXMvanNvbi1oaWdobGlnaHQvanNvbi1wYXJzZS5qcyIsIi8qKlxyXG4gKiBDb2RlIGZvcm1hdCB3ZWItd29ya2VyXHJcbiAqIEBwYXJhbSBldmVudFxyXG4gKi9cclxuLy8gdmFyIGhpZ2hsaWdodEpzb24oKVxyXG52YXIgaGlnaGxpZ2h0SnNvbiA9IHJlcXVpcmUoJy4vanNvbi1wYXJzZScpO1xyXG5cclxub25tZXNzYWdlID0gZnVuY3Rpb24oZXZlbnQpIHtcclxuICB2YXIgY29kZSA9IGV2ZW50LmRhdGE7XHJcbiAgLy8gaW1wb3J0U2NyaXB0cygnanNvbi1wYXJzZS5qcycpO1xyXG4gIHZhciByZXN1bHQgPSBoaWdobGlnaHRKc29uKGNvZGUsIHtleHBhbmRlZDogdHJ1ZX0pO1xyXG4gIC8vIHZhciByZXN1bHQgPUpTT04uc3RyaW5naWZ5KGNvZGUpO1xyXG4gIHBvc3RNZXNzYWdlKHJlc3VsdCk7XHJcbn07XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc2NyaXB0cy9hcGktZXhwbG9yZXIvdjIvc3JjL3NlcnZpY2VzL2pzb24taGlnaGxpZ2h0L2hpZ2hsaWdodEpzb24ud29ya2VyLmpzXG4vLyBtb2R1bGUgaWQgPSAxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=", __webpack_require__.p + "highlightJson.worker.js");
};

/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(ko, $) {

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Custom input component
 */

var CustomInput = function () {
	function CustomInput(_ref) {
		var onFocusMethod = _ref.onFocusMethod,
		    _ref$data = _ref.data,
		    data = _ref$data === undefined ? { value: '', isDirty: false, required: false } : _ref$data,
		    _ref$cssClass = _ref.cssClass,
		    cssClass = _ref$cssClass === undefined ? '' : _ref$cssClass,
		    validationModel = _ref.validationModel;

		_classCallCheck(this, CustomInput);

		this.data = data;
		this.focusMethod = onFocusMethod;
		this.placeholder = data.placeholder || data.name;
		this.id = data.name;
		this.isVirgin = ko.observable(true);
		// css classes
		this.cssClass = cssClass;

		// Dirty watcher
		this.fieldWatcher(data);
		// Validation
		this.initValidation(data, validationModel);
	}

	/**
  * Dirty watcher method
  * @param data {object}
  */


	_createClass(CustomInput, [{
		key: 'fieldWatcher',
		value: function fieldWatcher(data) {
			this.isDirty = data.isDirty = ko.pureComputed(function () {
				return !!data.value().toString().trim().length;
			});
		}

		/**
   * Validation init method
   * @param data {object}
   * @param validationModel {object}
   */

	}, {
		key: 'initValidation',
		value: function initValidation(data, validationModel) {
			var obj = { required: data.required };

			// validation by type
			switch (data.type) {
				case 'integer':
					obj.nullableInt = data.value;
					break;
				default:
					break;
			}

			this.value = data.value.extend(obj);
			var model = ko.unwrap(validationModel);
			model[data.name] = this.value;
			validationModel(model);
		}

		/**
   * On field in focus method
   * @param data {object}
   */

	}, {
		key: 'onFocusMethod',
		value: function onFocusMethod(data) {
			this.focusMethod && this.focusMethod(data);
		}

		/**
   * Enter key handler
   * @param model {object}
   * @param event {object}
   */

	}, {
		key: 'onKeyDown',
		value: function onKeyDown(model, event) {
			this.isVirgin(false);
			var btn = $('#api-exp-get-btn');

			if (event.keyCode === 13 && btn.is(':enabled')) {
				btn.trigger('click');
			} else {
				return true;
			}
		}

		/**
   * Is teatarea checker
   * @returns {boolean}
   */

	}, {
		key: 'isTextarea',
		get: function get() {
			return this.data.style === 'requestBody';
		}
	}]);

	return CustomInput;
}();

ko.components.register('custom-input', {
	viewModel: CustomInput,
	template: '\n\t\t<div data-bind="css: {[cssClass]: true, dirty: isDirty, virgin: isVirgin}" class="api-exp-custom-input">\n\t\t\t<div data-bind="validationElement: value" class="custom-input__inner-wrapper">\n\t\t\t\t<!-- ko ifnot: isTextarea -->\n\t\t\t\t<input data-bind="textInput: value, lazyLoader: {name: placeholder, val: value}, dateTimePicker, event: {focus: onFocusMethod(data), keydown: onKeyDown.bind($component)}, attr: {id: id}"\n\t\t\t\t\t\t\t\ttype="text"\n\t\t\t\t\t\t\t\tclass="custom-input__field form-control">\n\t\t\t\t<!-- /ko -->\n\t\t\t\t<!-- ko if: isTextarea -->\n\t\t\t\t<textarea data-bind="textInput: value, lazyLoader: {name: placeholder, val: value}, dateTimePicker, event: {focus: onFocusMethod(data)}, attr: {id: id}" \n\t\t\t\t\t\t\t\t\tcols="30" rows="10"\n\t\t\t\t\t\t\t\t\tclass="custom-textarea custom-input__field form-control"></textarea>\n\t\t\t\t<!-- /ko -->\n\t\t\t\t<span data-bind="text: placeholder, css: {required: data.required}" class="custom-input__placeholder"></span>\n\t\t\t</div>\n\t\t\t<p data-bind="validationMessage: value, css: {textarea: isTextarea}" class="custom-input__validation-message"></p>\n\t\t</div>\n' });

module.exports = CustomInput;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0), __webpack_require__(1)))

/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(ko, $) {

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Custom select component
 */

var CustomSelect = function () {
	function CustomSelect(_ref) {
		var data = _ref.data,
		    selected = _ref.selected,
		    options = _ref.options,
		    focus = _ref.focus,
		    onselect = _ref.onselect,
		    _ref$animationSpeed = _ref.animationSpeed,
		    animationSpeed = _ref$animationSpeed === undefined ? 200 : _ref$animationSpeed,
		    _ref$isReadOnly = _ref.isReadOnly,
		    isReadOnly = _ref$isReadOnly === undefined ? true : _ref$isReadOnly;

		_classCallCheck(this, CustomSelect);

		var rawOptions = ko.unwrap(options);
		var DEFAULT_SELECTED = rawOptions[0].name;
		this.curentSelectData = data;
		this.onFocus = focus;
		this.onselectMethod = onselect;
		this.animationSpeed = animationSpeed;
		this.options = options;
		this.value = ko.unwrap(selected) || DEFAULT_SELECTED;
		this.selectedOption = ko.observable(this.mapForChecked({ rawOptions: rawOptions, name: this.value }));
		this.isExpandeded = ko.observable(false);
		this.isReadOnly = isReadOnly;
		this.setSubscribtions({ selected: selected, DEFAULT_SELECTED: DEFAULT_SELECTED });
		// Dirty watcher
		this.fieldWatcher(data);
	}

	_createClass(CustomSelect, [{
		key: 'fieldWatcher',
		value: function fieldWatcher(data) {
			if (data) {
				this.isDirty = data.isDirty = ko.pureComputed(function () {
					return data.value() !== data.default && data.value() !== 'none';
				});
			}
		}
	}, {
		key: 'setSubscribtions',
		value: function setSubscribtions(_ref2) {
			var _this = this;

			var selected = _ref2.selected,
			    DEFAULT_SELECTED = _ref2.DEFAULT_SELECTED;

			// has preselected option
			if (selected) {
				selected.subscribe(function (value) {
					var selectedOption = _this.mapForChecked({ rawOptions: ko.unwrap(_this.options), name: value || DEFAULT_SELECTED });

					return _this.selectedOption(selectedOption);
				});
			}

			// on select map for checked
			this.selectedOption.subscribe(function (value) {
				_this.mapForChecked({ rawOptions: ko.unwrap(_this.options), name: value.name });
				_this.onselectMethod(value);
			});

			// quantity of options check
			this.isOneOption = ko.pureComputed(function () {
				return ko.unwrap(_this.options).length < 2;
			});
		}

		/**
   * Updates checked option
   * @param rawOptions {array} options
   * @param name {string} name of selected option
   * @returns {object} selected option
   */

	}, {
		key: 'mapForChecked',
		value: function mapForChecked(_ref3) {
			var rawOptions = _ref3.rawOptions,
			    name = _ref3.name;

			var selectedOption = void 0;
			var _iteratorNormalCompletion = true;
			var _didIteratorError = false;
			var _iteratorError = undefined;

			try {
				for (var _iterator = rawOptions[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
					var option = _step.value;

					var optionValue = option.value || option.name;
					option.checked(optionValue === name);
					if (optionValue === name) {
						selectedOption = option;
					}
				}
			} catch (err) {
				_didIteratorError = true;
				_iteratorError = err;
			} finally {
				try {
					if (!_iteratorNormalCompletion && _iterator.return) {
						_iterator.return();
					}
				} finally {
					if (_didIteratorError) {
						throw _iteratorError;
					}
				}
			}

			return selectedOption;
		}
	}, {
		key: 'slideToggle',
		value: function slideToggle(item, event) {
			this.onFocus && this.onFocus(this.curentSelectData);
			this.isExpandeded(!ko.unwrap(this.isExpandeded));
			if (ko.unwrap(this.isOneOption)) {
				return false;
			}
			var el = this.constructor.findElement(event);
			el.wrapper.slideToggle(this.animationSpeed);
			el.layer.toggleClass('hidden');
		}
	}, {
		key: 'onSelect',
		value: function onSelect(item, event) {
			var rawOptions = ko.unwrap(this.options);
			this.mapForChecked({ rawOptions: rawOptions, name: item.name });
			this.selectedOption(item);
			this.slideToggle(item, event);
		}
	}], [{
		key: 'findElement',
		value: function findElement(event) {
			var parent = $(event.currentTarget).parents('.js-custom-select');
			return {
				wrapper: parent.find('.js-custom-select-wrapper'),
				layer: parent.find('.js-custom-select-layer')
			};
		}
	}]);

	return CustomSelect;
}();

module.exports = ko.components.register('custom-select', {
	viewModel: CustomSelect,
	template: '\n\t<div class="api-exp-custom-select js-custom-select">\n\t\t<div class="api-exp-custom-select-wrapper">\n\t\t\t<select class="api-exp-custom-select__field" name="api-exp-method" data-bind="options: options, optionsText: \'name\', value: selectedOption"></select>\n\t\t\t\t<span class="api-exp-custom-select__placeholder">\n\t\t\t\t<input type="text" data-bind="click: slideToggle, value: selectedOption().name, attr: {disabled: isOneOption, readonly: isReadOnly}">\n\t\t\t\t<button class="btn btn-icon shevron up blue api-exp-custom-select__chevron" data-bind="css: {hidden: isOneOption, down: isExpandeded}" type="button"></button>\n\t\t\t</span>\n\t\t\t<ul data-bind="foreach: options, scroll: {x: false, y: true}" class="api-exp-custom-select__list js-custom-select-wrapper">\n\t\t\t\t<li data-bind="css: {\'active\': checked}" class="api-exp-custom-select__item">\n\t\t\t\t\t<button class="api-exp-custom-select__item-label"\n\t\t\t\t\t\t\t\t\tdata-bind="click: $component.onSelect.bind($component),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\ttext: name,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcss: {\'active\': checked},\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tattr: {\'data-value\': name}"></button>\n\t\t\t\t\t<a class="api-exp-custom-select__item-link" target="_blank" data-bind="attr: {href: link}, css: {\'hidden\': !link}">&nbsp;</a>\n\t\t\t\t</li>\n\t\t\t</ul>\n\t\t</div>\n\t\t<div data-bind="click: slideToggle" class="api-exp-custom-select-layer js-custom-select-layer hidden"></div>\n\t</div>\n' });
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0), __webpack_require__(1)))

/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(11);
__webpack_require__(10);

/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(ko) {

var self;

function AboutMethod(params) {
	self = this;
	var method = ko.unwrap(params.selectedMethodData);
	this.documentationLink = ko.observable(method.link);
	this.name = ko.observable(method.name);
	this.description = ko.observable(method.description);

	// on model change
	params.selectedMethodData.subscribe(function (val) {
		this.documentationLink(val.link);
		this.name(val.name);
		this.description(val.description);
	}, this);

	// methods
	this.togglePopUp = ko.observable(false);
}

AboutMethod.prototype.onAboutClick = function (model) {
	return model.togglePopUp(!model.togglePopUp());
};

module.exports = ko.components.register('about-method', {
	viewModel: AboutMethod,
	template: '\n\t\t<section data-bind="css: {active: togglePopUp}" class="api-exp-about">\n\t\t\t<div class="api-exp-about-wrapper">\n\t\t\t\t<button data-bind="click: onAboutClick" class="api-exp-about__button devices-button"></button>\n\t\t\t\t<a data-bind="attr: {href: documentationLink}" href="#" class="api-exp-about__button" target="_blank"></a>\n\t\t\t\t<article class="api-exp-about__content">\n\t\t\t\t\t<h5 data-bind="text: name" class="api-exp-about__title">About API and Method:</h5>\n\t\t\t\t\t<section class="api-exp-about__description">\n\t\t\t\t\t\t<p data-bind="text: description"></p>\n\t\t\t\t\t\t<p>\n\t\t\t\t\t\t\t<a data-bind="attr: {href: documentationLink}" target="_blank" href="#" class="api-exp-about__description-link">Read mode</a>\n\t\t\t\t\t\t</p>\n\t\t\t\t\t</section>\n\t\t\t\t</article>\n\t\t\t\t<div data-bind="click: onAboutClick" class="api-exp-about-layer"></div>\n\t\t\t</div>\n\t\t</section>\n' });
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 14 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(ko) {

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var self;

var CategoryMenu = function CategoryMenu(_ref) {
	var _this = this;

	var data = _ref.data,
	    selectedCategory = _ref.selectedCategory;

	_classCallCheck(this, CategoryMenu);

	this.selectCategory = function (category) {
		var categoryName = category.name;
		_this.selectedCategory(categoryName);
		checkActive(_this.categories, categoryName);
	};

	self = this;
	this.selectedCategory = selectedCategory;
	var initCategory = ko.unwrap(this.selectedCategory);
	this.categories = ko.observableArray(Object.keys(data).map(function (item, index) {
		var checked = initCategory ? item === initCategory : !index;
		// initial load
		checked && _this.selectedCategory(item);
		return {
			checked: ko.observable(checked),
			name: item,
			link: false
		};
	}));

	this.selectedCategory.subscribe(function (categoryName) {
		checkActive(_this.categories, categoryName);
	});
};

module.exports = ko.components.register('category-menu', {
	viewModel: CategoryMenu,
	template: '\n\t\t<aside class="api-exp-side-menu">\n\t\t\t<ul data-bind="foreach: categories" class="api-exp-side-menu__container nav nav-pills nav-stacked visible-lg-block">\n\t\t\t\t<li data-bind="css: {active: checked}" role="presentation" class="api-exp-side-menu__item">\n\t\t\t\t\t<a data-bind="click: $parent.selectCategory, text: name" href="#" class="api-exp-side-menu__link"></a>\n\t\t\t\t</li>\n\t\t\t</ul>\n\t\t\t<!--select-->\n\t\t\t<div class="api-exp-side-menu__select hidden-lg">\n\t\t\t\t<!-- ko template: { nodes: $componentTemplateNodes, data: $component } --><!-- /ko -->\n\t\t\t</div>\n\t\t</aside>\n' });

function checkActive(koArr, activeElem) {
	if (!koArr && !activeElem) {
		return false;
	}

	koArr(koArr().map(function (obj) {
		if (obj.name === activeElem) {
			obj.checked(true);
		} else {
			obj.checked(false);
		}
		return obj;
	}));
}
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(13);
__webpack_require__(14);
__webpack_require__(16);
__webpack_require__(18);
__webpack_require__(17);

/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(ko, $) {

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var self;

var MethodsFilter = function () {
	function MethodsFilter(_ref) {
		var selectedCategory = _ref.selectedCategory,
		    data = _ref.data,
		    selectedMethodType = _ref.selectedMethodType,
		    selectedMethod = _ref.selectedMethod;

		_classCallCheck(this, MethodsFilter);

		_initialiseProps.call(this);

		self = this;
		this.selectedCategory = selectedCategory;
		this.data = data;
		this.selectedMethodType = selectedMethodType;
		this.selectedMethod = selectedMethod;
		this.selectedMethodName = ko.observable('');
		this.methodsViewModel = ko.observableArray([]);
		this.init();
	}

	/**
  * Initialization phase
  */


	_createClass(MethodsFilter, [{
		key: 'filterTransclusion',


		/**
   * Filters transclusion dom nodes
   * @param param {array} $componentTemplateNodes
   * @param index {number} index of element
   * @returns {array} dom nodes array for insertion
   */
		value: function filterTransclusion(param, index) {
			var text = param.find(function (item) {
				return item.nodeName === '#text';
			});
			var el = param.filter(function (item) {
				return item.nodeName !== '#text' && item.nodeName !== '#comment';
			})[index];
			return [text, el, text];
		}

		/**
   * Updates VM for methods select
   * @param methodType
   */

	}, {
		key: 'onSelectMethod',


		/**
   * On select handler for methods select
   * @param item
   */
		value: function onSelectMethod(item) {
			self.selectedMethod(item.id);
		}
	}]);

	return MethodsFilter;
}();

var _initialiseProps = function _initialiseProps() {
	var _this = this;

	this.init = function () {
		_this.updateMethodsModel(ko.unwrap(_this.selectedMethodType));

		//on change
		_this.selectedMethodType.subscribe(function (val) {
			return _this.updateMethodsModel(val);
		});
		_this.selectedMethod.subscribe(function (val) {
			_this.selectedMethodName(_this.data[ko.unwrap(_this.selectedCategory)]['ALL'][val].name);
		});
	};

	this.updateMethodsModel = function (methodType) {
		var obj = _this.data[ko.unwrap(_this.selectedCategory)][methodType] || {},
		    arr = [],
		    selectedMethod = ko.unwrap(_this.selectedMethod),
		    count = 0;

		for (var i in obj) {
			if (!obj.hasOwnProperty(i)) {
				continue;
			}
			var property = obj[i];

			var vmMethod = $.extend({}, {
				id: property.id,
				name: property.name,
				link: property.link,
				checked: ko.observable(selectedMethod ? selectedMethod === property.id : !count)
			});

			if (selectedMethod === property.id) {
				_this.selectedMethodName(property.name);
			}

			arr.push(vmMethod);

			// set global observable
			!selectedMethod && !count && _this.selectedMethod(property.id);

			count++;
		}

		_this.methodsViewModel(arr);
	};
};

module.exports = ko.components.register('methods-filter', {
	viewModel: MethodsFilter,
	template: '\n\t\t<section  class="api-exp-main-filter">\n\t\t\t<section class="api-exp-filter">\n\t\t\t\t<section class="api-exp-methods clearfix">\n\t\t\t\t\t<label class="api-exp-methods__label">Methods</label>\n\t\n\t\t\t\t\t<!--radios-->\n\t\t\t\t\t<!-- ko template: { nodes: filterTransclusion($componentTemplateNodes, 0), data: $component } --><!-- /ko -->\n\t\t\t\t\t\n\t\t\t\t\t<!--select-->\n\t\t\t\t\t<div class="api-exp-methods__select">\n\t\t\t\t\t\t<!-- ko template: { nodes: filterTransclusion($componentTemplateNodes, 1), data: $component }--><!--/ko-->\n\t\t\t\t\t</div>\n\t\t\t\t</section>\n\t\t\t</section>\n\t\t</section>\n' });
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0), __webpack_require__(1)))

/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(ko, $) {

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var ParamsFilter = function () {
	function ParamsFilter(_ref) {
		var _this = this;

		var selectedMethod = _ref.selectedMethod,
		    selectedParams = _ref.selectedParams,
		    selectedMethodData = _ref.selectedMethodData,
		    _ref$animationSpeed = _ref.animationSpeed,
		    animationSpeed = _ref$animationSpeed === undefined ? 200 : _ref$animationSpeed,
		    paramsIsHiden = _ref.paramsIsHiden;

		_classCallCheck(this, ParamsFilter);

		this.updateViewModel = function () {
			var obj = ko.unwrap(_this.selectedMethodData);
			var parameters = ko.unwrap(_this.selectedMethodData).parameters || {},
			    arr = [];

			for (var i in parameters) {
				if (!parameters.hasOwnProperty(i)) {
					continue;
				}
				var param = parameters[i];
				var selectedParam;

				// copies all values from model to view-model
				var vmParam = $.extend(true, {}, param);

				vmParam.value = ko.observable(vmParam.value || vmParam.select && param.options[0].name || '');

				//add observable for selected options
				if (vmParam.select) {
					vmParam.options = selectedParam ? selectedParam.options : ko.observableArray(param.options.map(function (item) {
						return $.extend(true, {}, item, { checked: ko.observable(item.checked) });
					}));
				}

				// add calendar btn for current field
				vmParam.hasCalendar = i.search(/(date|time)/gmi) != -1;

				// add pop-up btn for current field
				vmParam.hasPopUp = i.search(/(attractionId|venueId)/gmi) != -1;

				arr.push(vmParam);
			}

			// prepare output for request
			_this.paramsModel(arr);

			//set focus for first elem
			_this.paramInFocus(_this.paramsModel()[0]);
			_this.prepareUrlPairs(arr, _this.selectedParams);
			return arr;
		};

		this.onFocus = function (item) {
			_this.paramInFocus(item);
		};

		this.onParamsClear = function (vm, e) {
			var arr = ko.unwrap(_this.paramsModel);

			_this.paramsModel(arr.map(function (param) {
				param.value(param.select && param.default || '');

				if (param.select) {
					param.options(ko.unwrap(param.options).map(function (option, index) {
						option.checked(!index);
						return option;
					}));
				}
				return param;
			}));

			// prepare output for request
			_this.paramInFocus(_this.paramsModel()[0]);
			_this.prepareUrlPairs(arr, _this.selectedParams);
		};

		this.animationSpeed = animationSpeed;
		this.selectedMethod = selectedMethod;
		this.selectedParams = selectedParams;
		this.selectedMethodData = selectedMethodData;
		this.isHidden = ko.observable(true);
		this.paramInFocus = ko.observable({});
		this.paramsModel = ko.observableArray([]);
		this.isDirty = ko.computed(this.checkDirty, this);
		this.init({ selectedMethod: selectedMethod, selectedParams: selectedParams });

		// slide toggle when params are not valid
		paramsIsHiden.subscribe(function (newVal) {
			_this.slideToggle.call(null, _this);
		});
	}

	/**
  * Initialization phase
  */


	_createClass(ParamsFilter, [{
		key: 'init',
		value: function init(_ref2) {
			var _this2 = this;

			var selectedMethod = _ref2.selectedMethod,
			    selectedParams = _ref2.selectedParams;

			this.updateViewModel();
			selectedMethod.subscribe(function (val) {
				_this2.updateViewModel(val);
			});

			selectedParams.subscribe(function (selected) {
				var paramsModel = ko.unwrap(_this2.paramsModel);
				selected.map(function (param) {
					var matchedParam = paramsModel.find(function (val) {
						return param.name === val.name;
					});
					matchedParam.value(ko.unwrap(param.value));
				});
				_this2.paramsModel(paramsModel);
			}, this, 'paramsSet');
		}

		/**
   * Initial build of Select Model
   */

	}, {
		key: 'checkDirty',


		/**
   * Dirty params form observable method
   * @returns {boolean}
   */
		value: function checkDirty() {
			this.prepareUrlPairs(ko.unwrap(this.paramsModel), this.selectedParams);
			var dirty = ko.unwrap(this.paramsModel).filter(function (item) {
				return ko.unwrap(item.isDirty) === true;
			});
			return dirty.length > 0;
		}

		/**
   * Slide toggle for params container method
   * @param viewModel
   * @param event
   */

	}, {
		key: 'slideToggle',
		value: function slideToggle(viewModel, event) {
			$('#api-exp2-params-toggle').parents('.js-slide-control').find('.js-slide-wrapper').slideToggle(viewModel.animationSpeed, function () {
				viewModel.isHidden(!viewModel.isHidden());
			});
		}

		/**
   * Maches focused param
   * @param item
   */

	}, {
		key: 'prepareUrlPairs',


		/**
   * Filters params by defined value
   * @param arr
   * @param koObs
   * @returns {boolean}
   */
		value: function prepareUrlPairs(arr, koObs) {
			if (!arr || !koObs) {
				return false;
			}

			return koObs(arr.filter(function (item) {
				return item.value() && item.value() !== 'none' || item.default;
			}));
		}

		/**
   * On select value handler for params select
   * @param param {object} parameter view-model
   * @param option {object} option view-model
   */

	}, {
		key: 'onSelectParamValue',
		value: function onSelectParamValue(param, option) {
			param.value(option.value || option.name);
		}

		/**
   * Params clear button handler
   * @param vm {object} view model
   * @param e {object} event
   */

	}]);

	return ParamsFilter;
}();

ko.components.register('params-filter', {
	viewModel: ParamsFilter,
	template: '\n\t\t<section data-bind="css: {closed: isHidden, dirty: isDirty}" class="api-exp-params js-slide-control">\n\t\t\n\t\t\t<section class="api-exp-params-headline">\n\t\t\t\t<button id="api-exp2-params-toggle" data-bind="click: slideToggle" class="btn btn-icon toggle-btn" type="button">Parameters</button>\n\t\t\t\t<span class="btn btn-icon shevron up grey" data-bind="css: {down: isHidden}"></span>\n\t\t\t\t<div class="api-exp-params-headline-edit">\n\t\t\t\t\t<button class="btn api-exp-params-headline__btn api-exp-params-headline__btn-copy">&nbsp;</button>\n\t\t\t\t\t<button data-bind="click: onParamsClear" class="btn api-exp-params-headline__btn api-exp-params-headline__btn-clear">&nbsp;</button>\n\t\t\t\t</div>\n\t\t\t</section>\n\t\t\t\n\t\t\t<div class="api-exp-params-wrapper clearfix js-slide-wrapper">\n\t\t\t\t<!--about-->\n\t\t\t\t<section class="api-exp-about visible-lg-block">\n\t\t\t\t\t<div class="api-exp-about-wrapper">\n\t\t\t\t\t\t<span class="api-exp-about__button"></span>\n\t\t\t\t\t\t<article class="api-exp-about__content">\n\t\t\t\t\t\t\t<h5 data-bind="text: paramInFocus().name" class="api-exp-about__title">About API and Method:</h5>\n\t\t\t\t\t\t\t<section class="api-exp-about__description">\n\t\t\t\t\t\t\t\t<p data-bind="html: paramInFocus().doc"></p>\n\t\t\t\t\t\t\t</section>\n\t\t\t\t\t\t</article>\n\t\t\t\t\t</div>\n\t\t\t\t</section>\n\t\t\t\t\n\t\t\t\t<!--params filter-->\n\t\t\t\t<section class="api-exp-params-filter">\n\t\t\t\t\t<section data-bind="foreach: paramsModel" class="api-exp-params-filter-fields">\n\t\t\t\t\t\t<!--select-->\n\t\t\t\t\t\t<!-- ko ifnot: style === \'requestBody\' -->\n\t\t\t\t\t\t\t<div class="api-exp-params-filter__field">\n\t\t\t\t\t\t\t\t<!-- ko if: select -->\n\t\t\t\t\t\t\t\t\t<custom-select params="\n\t\t\t\t\t\t\t\t\t\tdata: $data,\n\t\t\t\t\t\t\t\t\t\toptions: options,\n\t\t\t\t\t\t\t\t\t\tonselect: $component.onSelectParamValue.bind($data, $data),\n\t\t\t\t\t\t\t\t\t\tfocus: $component.onFocus,\n\t\t\t\t\t\t\t\t\t\tselected: value">\n\t\t\t\t\t\t\t\t\t</custom-select>\n\t\t\t\t\t\t\t\t<!-- /ko -->\n\t\t\t\t\t\t\t\t<!-- ko ifnot: select -->\n\t\t\t\t\t\t\t\t\t<custom-input params="\n\t\t\t\t\t\t\t\t\t\tonFocusMethod: $component.onFocus,\n\t\t\t\t\t\t\t\t\t\tdata: $data,\n\t\t\t\t\t\t\t\t\t\tcssClass: hasCalendar ? \'calendar\': hasPopUp ? \'popup\': \'\',\n\t\t\t\t\t\t\t\t\t\tvalidationModel: $root.validationModel">\n\t\t\t\t\t\t\t\t\t</custom-input>\n\t\t\t\t\t\t\t\t<!-- /ko -->\n\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t<!-- /ko -->\n\t\t\t\t\t\t<!-- ko if: style === \'requestBody\'-->\n\t\t\t\t\t\t\t<section class="cusotm-textarea-wrapper">\n\t\t\t\t\t\t\t\t<custom-input params="\n\t\t\t\t\t\t\t\t\tonFocusMethod: $component.onFocus,\n\t\t\t\t\t\t\t\t\tdata: $data,\n\t\t\t\t\t\t\t\t\tcssClass: hasCalendar ? \'calendar\': hasPopUp ? \'popup\': \'\',\n\t\t\t\t\t\t\t\t\tvalidationModel: $root.validationModel">\n\t\t\t\t\t\t\t\t</custom-input>\n\t\t\t\t\t\t\t</section>\n\t\t\t\t\t\t<!-- /ko -->\n\t\t\t\t\t</section>\n\t\t\t\t</section><!--params filter-->\n\t\t\t</div>\n\t\t</section><!--parameters-->\n' });

module.exports = ParamsFilter;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0), __webpack_require__(1)))

/***/ }),
/* 18 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(ko) {

var self;

function RadioFilter(params) {
	self = this;
	var selectedCategory = ko.unwrap(params.selectedCategory);
	var data = params.data;
	this.selectedMethodType = params.selectedMethodType;
	this.RADIO_ID = 'api-exp-';

	this.radiosModel = ko.observableArray([]);
	this.updateRadiosModel(data[selectedCategory]);

	params.selectedCategory.subscribe(function (val) {
		this.updateRadiosModel(data[val]);
	}, this);
}

RadioFilter.prototype.updateRadiosModel = function (param) {
	var obj = param || {},
	    arr = [];

	for (var i in obj) {
		if (!obj.hasOwnProperty(i)) {
			continue;
		}
		var item = {
			checked: ko.observable(i === 'ALL'),
			name: i
		};
		arr.push(item);
		// initial notify for all subscribers
		i === 'ALL' && this.selectedMethodType.notifySubscribers(i);
	}

	arr = arr.sort(compareMethods);
	this.radiosModel(arr);
	return arr;
};

/**
 * Onchange handler for Radio buttons
 * @param item
 */
RadioFilter.prototype.onchangeRadios = function (item) {
	var radiosModel = ko.unwrap(self.radiosModel).map(function (obj) {
		if (obj.name === item.name) {
			obj.checked(true);
			self.selectedMethodType(obj.name);
		} else {
			obj.checked(false);
		}
		return obj;
	});
	self.radiosModel(radiosModel);
};

/**
 * Uniq id for radio btn
 * @param name
 * @returns {string}
 */
RadioFilter.prototype.getInputId = function (name) {
	return self.RADIO_ID + name;
};

/**
 * Sort function for methods aray
 * @param f
 * @param s
 * @returns {number}
 */
function compareMethods(f, s) {
	var a = f.name.toUpperCase();
	var b = s.name.toUpperCase();

	if (a === b) {
		return 0;
	}
	if (a === 'ALL' || a === 'GET' && (b === 'POST' || b === 'PUT' || b === 'DELETE') || a === 'POST' && (b === 'PUT' || b === 'DELETE') || a === 'PUT' && b === 'DELETE') {
		return -1;
	}
	return 1;
}

module.exports = ko.components.register('radio-filter', {
	viewModel: RadioFilter,
	template: '\n\t\t<!--radios-->\n\t\t<section data-bind="foreach: radiosModel" class="api-exp-methods__radio-buttons radio-buttons clearfix">\n\t\t\t<div data-bind="css: {active: checked}" class="api-exp-method">\n\t\t\t\t<input data-bind="attr: { id: $component.getInputId(name), checked: checked }, event: {change: $component.onchangeRadios}"\n\t\t\t\t\t\t\t\tclass="api-exp-content-method__radio"\n\t\t\t\t\t\t\t\ttype="radio"\n\t\t\t\t\t\t\t\tname="api-exp-methods">\n\t\t\t\t<label data-bind="text: name, attr: {for: $component.getInputId(name)}" class="radio-inline api-exp-method__label"></label>\n\t\t\t</div>\n\t\t</section>\n' });
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 19 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(12);
__webpack_require__(15);
__webpack_require__(29);
__webpack_require__(21);
__webpack_require__(30);

/***/ }),
/* 20 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(ko, $) {

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var self;

var ArrayPanelBody = function () {
	function ArrayPanelBody(params) {
		_classCallCheck(this, ArrayPanelBody);

		self = this;
		this.data = params.data.value;
		this.config = params.config;
		this._panelName = params.data.key;
		this.cardIndex = this.cardIndex || ko.utils.unwrapObservable(params.index);
		this.panelGroup = params.panelGroup;
		this.getMore = this.panelGroup.getMore;
	}

	_createClass(ArrayPanelBody, [{
		key: 'getStartData',
		value: function getStartData($data) {
			return Object.getProp($data, 'dates.start.localDate') || '';
		}
	}, {
		key: 'getVenueName',
		value: function getVenueName($data) {
			return Object.getProp($data, '_embedded.venues[0].name') || '';
		}
	}, {
		key: 'setActive',
		value: function setActive($index, model, e) {
			$(e.currentTarget).parents('.slick-slide').find('.item.object').removeClass('active');
			$(e.currentTarget).parent('.item').addClass('active');
			this.getMore.call(null, { panel: this, id: $index, data: model });
		}
	}]);

	return ArrayPanelBody;
}();

module.exports = ko.components.register('array-panel-body', {
	viewModel: ArrayPanelBody,
	template: '\n\t\t<section class="panel-body array-panel-body">\n\t\t\t<ul data-bind="foreach: data, css: {\'events\': $component._panelName === \'events\'}" class="list list-group">\n\t\t\t\t<li data-bind="css: {\'object\': typeof $data === \'object\'}" class="list-group-item item">\n\t\t\t\t\n\t\t\t\t\t<!-- ko if: $component._panelName === \'images\' -->\n\t\t\t\t\t\t<img data-bind="attr: {src: url, alt: \'image-\' + ratio}" alt="img" class="img">\n\t\t\t\t\t\t<div class="img-info">\n\t\t\t\t\t\t\t<span class="img-ratio">Ratio: <i data-bind="text: ratio"></i></span>\n\t\t\t\t\t\t\t<span class="img-size">(<i data-bind="text: height"></i> x <i data-bind="text: width"></i>)</span>\n\t\t\t\t\t\t</div>\n\t\t\t\t\t<!-- /ko -->\n\t\t\t\t\t\n\t\t\t\t\t<!-- ko ifnot: $component._panelName === \'images\' -->\n\t\t\t\t\t\t<div class="vertical-align-center">\n\t\t\t\t\t\t\t<div class="name-wrapper">\n\t\t\t\t\t\t\t\t<span data-bind="text: name || \'#\' + $index(), blockEllipsis: {clamp: 2}" class="name"></span>\n\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\n\t\t\t\t\t\t<!-- ko if: $component._panelName === \'events\' -->\n\t\t\t\t\t\t\t<div class="additional-info">\n\t\t\t\t\t\t\t\t<p data-bind="text: $component.getStartData($data)" class="date">event date</p>\n\t\t\t\t\t\t\t\t<!-- ko if: $component.getVenueName($data)-->\n\t\t\t\t\t\t\t\t\t<p data-bind="text: $component.getVenueName($data)" class="venue truncate">event venue</p>\n\t\t\t\t\t\t\t\t<!--/ko-->\n\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t<!-- /ko -->\n\t\t\t\t\t\t\n\t\t\t\t\t<!-- /ko -->\n\t\t\t\t\t\n\t\t\t\t\t<!-- ko if: typeof $data === \'object\' -->\n\t\t\t\t\t\t<button data-bind="click: $component.setActive.bind($component, $index())" type="button" class="btn btn-icon blue-shevron-right pull-right"></button>\n\t\t\t\t\t<!-- /ko -->\n\t\t\t\t\t\n\t\t\t\t</li>\n\t\t\t</ul>\n\t\t</section>\n' });
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0), __webpack_require__(1)))

/***/ }),
/* 21 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(26);
__webpack_require__(25);
__webpack_require__(24);
__webpack_require__(27);
__webpack_require__(23);
__webpack_require__(20);
__webpack_require__(22);

/***/ }),
/* 22 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(ko) {

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var MapPanelBody = function MapPanelBody(_ref) {
	var _this = this;

	var _ref$lat = _ref.lat,
	    lat = _ref$lat === undefined ? null : _ref$lat,
	    _ref$long = _ref.long,
	    long = _ref$long === undefined ? null : _ref$long,
	    address = _ref.address,
	    _ref$showMapPopup = _ref.showMapPopup,
	    showMapPopup = _ref$showMapPopup === undefined ? null : _ref$showMapPopup,
	    _ref$zoom = _ref.zoom,
	    zoom = _ref$zoom === undefined ? 8 : _ref$zoom,
	    _ref$width = _ref.width,
	    width = _ref$width === undefined ? 350 : _ref$width,
	    _ref$height = _ref.height,
	    height = _ref$height === undefined ? 400 : _ref$height,
	    _ref$format = _ref.format,
	    format = _ref$format === undefined ? 'JPEG' : _ref$format;

	_classCallCheck(this, MapPanelBody);

	this.lat = parseFloat(lat);
	this.long = parseFloat(long);
	this.address = address;
	this.size = width + 'x' + height;
	this.zoom = zoom;
	var coordinates = lat + ',' + long;
	this.url = ko.pureComputed(function () {
		return 'https://maps.googleapis.com/maps/api/staticmap\n\t\t\t?center=' + coordinates + '\n\t\t\t&zoom=' + zoom + '\n\t\t\t&size=' + _this.size + '\n\t\t\t&format=' + format + '\n\t\t\t&markers=color:red%7Clabel:V%7C' + coordinates;
	});
	this.showMapPopup = showMapPopup;
};

ko.components.register('map-panel-body', {
	viewModel: MapPanelBody,
	template: '\n\t\t<section class="map-panel-body">\n\t\t\t<a class="location-map-link" data-bind="click: showMapPopup" href="#">\n\t\t\t\t<img data-bind="attr: {\'data-lat\': lat, \'data-long\': long, \'data-address\': address, src: url}, imgOnError">\n\t\t\t</a>\n\t\t</section>\n' });

module.exports = MapPanelBody;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 23 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(ko, $) {

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var ObjectPanelBody = function () {
	function ObjectPanelBody(_ref) {
		var _ref$data = _ref.data,
		    data = _ref$data === undefined ? {} : _ref$data,
		    config = _ref.config,
		    _ref$index = _ref.index,
		    index = _ref$index === undefined ? this.cardIndex : _ref$index,
		    _ref$panelGroup = _ref.panelGroup,
		    panelGroup = _ref$panelGroup === undefined ? {} : _ref$panelGroup,
		    page = _ref.page,
		    collapseId = _ref.collapseId,
		    subjectID = _ref.subjectID;

		_classCallCheck(this, ObjectPanelBody);

		_initialiseProps.call(this);

		this.data = this.data || ko.observable(data.value);
		this.config = config;
		this._panelName = data.key;
		this.cardIndex = ko.unwrap(index);
		this.panelGroup = panelGroup;
		this.getMore = panelGroup.getMore;
		this.page = page;
		this.collapseId = collapseId;
		this._allInside = !!Object.getProp(ko.unwrap(config), '._CONFIG.allInside');
		this.sortByConfig = panelGroup.sortByConfig;
		this.subjectID = subjectID;
		this.sendId(this.data);
	}

	_createClass(ObjectPanelBody, [{
		key: 'sendId',
		value: function sendId(data) {
			var id = ko.unwrap(data).id;
			if (id) {
				this.subjectID(id);
			}
		}
	}, {
		key: 'canBeCopied',
		value: function canBeCopied(data) {
			return !!Object.getProp(this.config, '._CONFIG.copyBtn.' + data.key) && _typeof(data.value) !== 'object';
		}
	}, {
		key: 'setActive',
		value: function setActive(key, value, model, e) {
			$(e.currentTarget).parents('.slick-slide').find('.item.object').removeClass('active');
			$(e.currentTarget).parent('.item').addClass('active');
			this.getMore.call(null, { panel: this, id: key, data: value });
		}
	}]);

	return ObjectPanelBody;
}();

var _initialiseProps = function _initialiseProps() {
	var _this = this;

	this.changePage = function (model, event) {
		if (event.keyCode === 13) {
			var page = _this.page,
			    totalPages = ko.unwrap(_this.data).totalPages,
			    value = +event.currentTarget.value;

			value = Number.isNaN(value) ? 0 : value;
			var pageNumber = ~~value < 0 ? 0 : ~~value;
			page.pageParam(pageNumber < totalPages ? pageNumber : totalPages - 1);
			page.setParams({
				category: page.category,
				method: page.method,
				methodId: page.methodId,
				params: page.params
			});
			$('#api-exp-get-btn').trigger('click');
		} else {
			return true;
		}
	};
};

module.exports = ko.components.register('object-panel-body', {
	viewModel: ObjectPanelBody,
	template: '\n\t\t<section data-bind="css: {\'all-inside\': $component._allInside}" class="panel-body object-panel-body">\n\t\t\t<!-- ko if: $component._panelName === \'object\' && !!Object.getProp(ko.unwrap(data), \'.ratio\')-->\n\t\t\t\t<img data-bind="attr: {src: ko.utils.unwrapObservable(data).url, alt: \'image-\' + ko.utils.unwrapObservable(data).ratio}" alt="img" class="img img-thumbnail">\n\t\t\t<!-- /ko -->\n\t\t\t\n\t\t\t<ul data-bind="foreachprop: {data: data, sortFn: $component.sortByConfig.bind($component)}" class="list object-list">\n\t\t\t\t<li data-bind="css: {\'object\': typeof value === \'object\', \'primitive\': typeof value !== \'object\'}" class="clearfix pading item">\n\t\t\t\t\n\t\t\t\t\t<!-- ko ifnot: typeof value === \'object\' && $component._allInside -->\n\t\t\t\t\t<span data-bind="text: typeof value === \'object\' ? key: key + \':\'" class="key"></span>\n\t\t\t\t\t<!-- /ko -->\n\t\t\t\t\t\n\t\t\t\t\t<!-- ko ifnot: typeof value === \'object\' || $component._panelName === \'page\' && key === \'number\' -->\n\t\t\t\t\t\t<span data-bind="text: value" class="value"></span>\n\t\t\t\t\t<!-- /ko -->\n\t\t\t\t\t\n\t\t\t\t\t<!-- ko if: $component._panelName === \'page\' && key === \'number\'-->\n\t\t\t\t\t\t<div class="form-inline">\n\t\t\t\t\t\t\t<input id="pagination-input" data-bind="event: {keydown: $component.changePage}, attr: {placeholder: value}" type="text" pattern="[0-9]+" class="form-control">\n\t\t\t\t\t\t</div>\n\t\t\t\t\t<!-- /ko -->\n\t\t\t\t\t\n\t\t\t\t\t<!-- ko if: $component.canBeCopied.call($component, $data) -->\n\t\t\t\t\t\t<!-- copy property btn -->\n\t\t\t\t\t\t<button data-bind="copyToClipboard: {text: value.toString()}, attr: {id: \'prop-value-\' + key + $index()}, popover: {type: \'tooltip\', title: \'Copy value\'}" type="button" class="btn btn-icon btn-copy"></button>\n\t\t\t\t\t<!-- /ko -->\n\t\t\t\t\t\n\t\t\t\t\t<!-- ko if: typeof value === \'object\' && $component._allInside -->\n\t\t\t\t\t\t<panel params="$data: $data, $index: $index, panelGroup: $component"></panel>\n\t\t\t\t\t<!-- /ko -->\n\t\t\t\t\t<!-- ko if: typeof value === \'object\' && !$component._allInside -->\n\t\t\t\t\t\t<button data-bind="click: $component.setActive.bind($component, key, value)" type="button" class="btn btn-icon blue-shevron-right pull-right"></button>\n\t\t\t\t\t<!-- /ko -->\n\t\t\t\t</li>\n\t\t\t</ul>\n\t\t</section>\n' });
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0), __webpack_require__(1)))

/***/ }),
/* 24 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function($, ko) {

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Pagination element
 * @param params
 */
var Pagination = function () {
	function Pagination(_ref) {
		var _ref$page = _ref.page,
		    page = _ref$page === undefined ? {} : _ref$page,
		    totalPages = _ref.totalPages,
		    number = _ref.number;

		_classCallCheck(this, Pagination);

		this.page = page;
		this.totalPages = +totalPages;
		this.number = +number;
		this.first = !!this.number;
		this.last = +number < +totalPages - 1;
		this.requestBtn = $('#api-exp-get-btn');
	}

	/**
  * get next page
  */


	_createClass(Pagination, [{
		key: 'getPrevPage',
		value: function getPrevPage() {
			var page = this.page;
			var val = ko.unwrap(page.pageParam);
			page.pageParam(val > 0 ? val - 1 : 0);
			page.setParams({
				category: page.category,
				method: page.method,
				methodId: page.methodId,
				params: page.params
			});
			this.requestBtn.trigger('click');
		}

		/**
   * get prev page
   */

	}, {
		key: 'getNextPage',
		value: function getNextPage() {
			var page = this.page;
			var val = ko.unwrap(this.number);
			page.pageParam(val < this.totalPages - 1 ? val + 1 : val);
			page.setParams({
				category: page.category,
				method: page.method,
				methodId: page.methodId,
				params: page.params
			});
			this.requestBtn.trigger('click');
		}
	}]);

	return Pagination;
}();

module.exports = ko.components.register('pagination', {
	viewModel: Pagination,
	template: '<span class="navigation-wrapper">\n\t\t<button data-bind="click: getPrevPage, enable: first" type="button" class="navigation prev"></button>\n\t\t<button data-bind="click: getNextPage, enable: last" type="button" class="navigation next"></button>\n\t</span>'
});
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1), __webpack_require__(0)))

/***/ }),
/* 25 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function($, ko) {

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Panel = function () {
	function Panel(_ref) {
		var _this = this;

		var _ref$$data = _ref.$data,
		    $data = _ref$$data === undefined ? {} : _ref$$data,
		    _ref$panelGroup = _ref.panelGroup,
		    panelGroup = _ref$panelGroup === undefined ? {} : _ref$panelGroup,
		    $index = _ref.$index;

		_classCallCheck(this, Panel);

		this.showMapPopup = function () {
			var map = void 0,
			    marker = void 0,
			    mapEl = $('#map-popup'),
			    lat = parseFloat(_this.lat, 10),
			    lng = parseFloat(_this.long, 10),
			    address = _this.address,
			    geocoder = new google.maps.Geocoder(),
			    coordinates = lat && lng ? { lat: lat, lng: lng } : new google.maps.LatLng(0, 0);

			// initialize map object
			map = new google.maps.Map(document.getElementById('map'), {
				center: coordinates,
				zoom: 8
			});

			if (address) {
				// if there was address provided
				geocodeAddress(geocoder, map, address, function (result) {
					// geocode address and center the map
					coordinates = result;
				});
			} else {
				// if not (means lat and long were provided)
				marker = new google.maps.Marker({ //Create a marker and set its position.
					position: coordinates,
					map: map
				});
			}
			// when map popup is shown
			mapEl.on("shown.bs.modal", function (e) {
				google.maps.event.trigger(map, "resize");
				// Recenter the map now that it's been redrawn
				map.setCenter(coordinates);
			});
			mapEl.modal(); // show map popup
		};

		this.$data = $data;
		this.key = $data.key;
		this.$index = ko.unwrap($index);
		this.panelGroup = panelGroup;
		this.page = panelGroup.page;
		this.colorClass = panelGroup.colorClass || '';
		this.config = this.constructor.panelConfig({ config: panelGroup.config, key: this.key });
		this.isExpanded = this.constructor.isExpanded(this.config);
		this.collapseId = panelGroup.collapseId + this.$index;
		this.isActive = ko.observable(this.isExpanded);
		this.subjectID = ko.observable('');
		this.lat = $data.value.latitude;
		this.long = $data.value.longitude;
		this.address = $data.value.address;
	}

	_createClass(Panel, [{
		key: 'setActive',
		value: function setActive(model, event) {
			this.isActive(!this.isActive());
		}
	}], [{
		key: 'panelConfig',


		/**
   * Gets config for each panel
   * @param config
   * @param key
   * @returns {*|{}}
   */
		value: function panelConfig(_ref2) {
			var config = _ref2.config,
			    key = _ref2.key;

			var subConfig = config[key] || {};

			subConfig._CONFIG = $.extend(true, {}, config._CONFIG, subConfig._CONFIG);
			return subConfig;
		}

		/**
   * Checks for 'expanded' config for each panel
   * @param config
   * @returns {boolean}
   */

	}, {
		key: 'isExpanded',
		value: function isExpanded(config) {
			return !(Object.getProp(config, '._CONFIG.collapsed') || false);
		}
	}]);

	return Panel;
}();

module.exports = ko.components.register('panel', {
	viewModel: Panel,
	template: '\n\t\t<section data-bind="css: {[colorClass]: true, active: isActive}" class="panel panel-primary">\n\t\t\t<!--panel-heading-->\n\t\t\t<panel-heading params="\n\t\t\t\tshowMapPopup: showMapPopup,\n\t\t\t\tpanelGroup: panelGroup,\n\t\t\t\tconfig: config,\n\t\t\t\tdata: $data,\n\t\t\t\tindex: $index,\n\t\t\t\tpage: page,\n\t\t\t\tsetActive: setActive.bind($component),\n\t\t\t\tcollapseId: collapseId,\n\t\t\t\tcolorClass: colorClass,\n\t\t\t\tisExpanded: isExpanded,\n\t\t\t\tsubjectID:subjectID\n\t\t\t"></panel-heading>\n\t\t\t\n\t\t\t<!--panel-body-->\n\t\t\t<section data-bind="attr: {\'id\': collapseId}, css: {\'in\': isExpanded}" class="panel-collapse collapse">\t\t\t\t\n\t\t\t\t<!--ko if: key === \'location\' -->\n\t\t\t\t\t<map-panel-body params="lat: lat, long: long, address: address, showMapPopup: showMapPopup"></map-panel-body>\n\t\t\t\t<!-- /ko -->\n\t\t\t\t<!-- ko if: (typeof $data.value === \'object\' && !$.isArray($data.value)) -->\n\t\t\t\t\t<object-panel-body params="config: config, data: $data, index: $index, panelGroup: panelGroup, page: page, collapseId: collapseId, subjectID: subjectID"></object-panel-body>\n\t\t\t\t<!-- /ko -->\n\t\t\t\t<!-- ko if: (typeof $data.value === \'object\' && $.isArray($data.value)) -->\n\t\t\t\t\t<array-panel-body params="config: config, data: $data, index: $index, panelGroup: panelGroup"></array-panel-body>\n\t\t\t\t<!-- /ko -->\n\t\t\t</section>\n\t\t</section>\n' });
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1), __webpack_require__(0)))

/***/ }),
/* 26 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(ko, $) {

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var self;

var CardGroup = function () {
	function CardGroup(params) {
		_classCallCheck(this, CardGroup);

		self = this;
		this.config = this.constructor.getConfig(params);
		this.data = this.prepareData({ params: params, config: this.config._CONFIG });
		this.groupIndex = params.groupIndex || 0;
		this.sectionIndex = ko.unwrap(params.sectionIndex);
		this.colorClass = params.colorClass;
		this.getMore = params.getMore;
		this.page = this.constructor.getPagingInfo(params, this.data.page);
		this.collapseId = this.constructor.getCollapseId();
		this._hasEventsPanel = false;
	}

	_createClass(CardGroup, [{
		key: 'sortByConfig',
		value: function sortByConfig(a, b) {
			if (this.config && this.config[a.key] && this.config[b.key] && this.config[a.key]._CONFIG && this.config[b.key]._CONFIG) {
				var i1 = this.config[a.key]._CONFIG.index;
				var i2 = this.config[b.key]._CONFIG.index;
				return i1 - i2;
			}
			return 0;
		}
	}, {
		key: 'checkIfHasEventsList',
		value: function checkIfHasEventsList(key) {
			return self._hasEventsPanel = key === 'events' || self._hasEventsPanel;
		}

		/**
   * Configures and params for each panel group
   */

	}, {
		key: 'prepareData',


		/**
   * Data manipulations
   */
		value: function prepareData(_ref) {
			var _ref$params = _ref.params,
			    params = _ref$params === undefined ? {} : _ref$params,
			    _ref$config = _ref.config,
			    config = _ref$config === undefined ? this.config._CONFIG : _ref$config;

			var data = $.extend(true, {}, params.data) || {};
			this.unwrappObjects(data, config);
			this.removeDeprecated(data, config);
			return this.wrappPrimitives({ data: data, _propTitle: params._propTitle });
		}

		/**
   * Gathers all stand alone props in to one object
   * @param data {object}
   * @param _propTitle {string}
   * @returns {object} revised data
   */

	}, {
		key: 'wrappPrimitives',
		value: function wrappPrimitives(_ref2) {
			var data = _ref2.data,
			    _ref2$_propTitle = _ref2._propTitle,
			    _propTitle = _ref2$_propTitle === undefined ? 'object' : _ref2$_propTitle;

			var newData = {},
			    val = void 0;

			// gathering all primitive props in additional panel
			for (var key in data) {
				if (!data.hasOwnProperty(key)) {
					continue;
				}
				val = data[key];

				if ((typeof val === 'undefined' ? 'undefined' : _typeof(val)) !== 'object') {
					newData[_propTitle] = newData[_propTitle] || {};
					newData[_propTitle][key] = val;
				} else {
					newData[key] = val;
				}
			}

			return newData;
		}

		/**
   * Unwraps objects
   */

	}, {
		key: 'removeDeprecated',
		value: function removeDeprecated(obj) {
			var config = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

			var deprecated = config.deprecated || [];

			deprecated.map(function (item) {
				if (obj[item]) {
					delete obj[item];
				}
				return item;
			});

			return obj;
		}

		/**
   * Removes deprecated objects
   */

	}, {
		key: 'unwrappObjects',
		value: function unwrappObjects(obj) {
			var config = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

			var unwrapp = config.unwrapp || [];

			unwrapp.map(function (item) {
				var val = obj[item];
				if (val) {
					var arr = Object.keys(val);
					for (var i = 0; i < arr.length; i++) {
						var prop = arr[i];
						obj[prop] = val[prop];
					}
					delete obj[item];
				}
				return item;
			});

			return obj;
		}

		/**
   * Prepares data for paging
   */

	}], [{
		key: 'getConfig',
		value: function getConfig(_ref3) {
			var _ref3$deepProp = _ref3.deepProp,
			    deepProp = _ref3$deepProp === undefined ? '' : _ref3$deepProp,
			    config = _ref3.config,
			    filter = _ref3.filter,
			    methodId = _ref3.methodId;

			self.deepProp = deepProp;
			// main config
			if (!self.deepProp && !config) {
				// panelGroup index - 0

				// get full config;
				var rawFilter = ko.unwrap(filter);

				// get current method config
				var methodConfig = rawFilter[methodId] || {};

				// method config inherits global config
				methodConfig._CONFIG = $.extend(true, {}, rawFilter._GLOBAL_CONFIG, methodConfig._CONFIG);

				return methodConfig;
			} else {
				// panelGroup index > 0
				return config || {};
			}
		}
	}, {
		key: 'getPagingInfo',
		value: function getPagingInfo(params, pageObj) {
			var pageParam = void 0,
			    size = void 0;

			if (pageObj && (params.pageParam || params.params)) {
				//temporary solution todo: need to be revised and refactored
				size = params.cardSize || pageObj.size;
				pageParam = params.pageParam || params.params.find(function (item) {
					return item.name === 'page';
				});

				return {
					category: params.category,
					method: params.method,
					methodId: params.methodId,
					params: params.params,
					pageParam: pageParam && pageParam.value,
					setParams: params.setParams,
					size: size
				};
			}
			return null;
		}

		/**
   * Provides id str for panel 'collapse toggle' logic
   * @param str
   * @returns {string}
   */

	}, {
		key: 'getCollapseId',
		value: function getCollapseId() {
			return 'card-panel-body-' + self.sectionIndex + self.groupIndex;
		}
	}]);

	return CardGroup;
}();

module.exports = ko.components.register('panel-group', {
	viewModel: CardGroup,
	template: '\n\t\t<section data-bind="foreachprop: {data: data, sortFn: sortByConfig.bind($component)}" class="panel-group">\n\t\t\t<!--panel-->\n\t\t\t<panel class="panel-item" data-bind="css: {\'has-events-list\': $component.checkIfHasEventsList(key)}"\n\t\t\t\t\t\t\tparams="$data: $data,\n\t\t\t\t\t\t\t\t\t\t\t$index: $index,\n\t\t\t\t\t\t\t\t\t\t\tpanelGroup: $component,\n\t\t\t\t\t\t\t\t\t\t\tsortByConfig: $component.sortByConfig">\n\t\t\t</panel>\n\t\t</section>\n' });
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0), __webpack_require__(1)))

/***/ }),
/* 27 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(ko) {

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _services = __webpack_require__(2);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var PanelHeading = function () {
	function PanelHeading(_ref) {
		var _ref$config = _ref.config,
		    config = _ref$config === undefined ? {} : _ref$config,
		    _ref$data = _ref.data,
		    data = _ref$data === undefined ? {} : _ref$data,
		    _ref$showMapPopup = _ref.showMapPopup,
		    showMapPopup = _ref$showMapPopup === undefined ? null : _ref$showMapPopup,
		    setActive = _ref.setActive,
		    isExpanded = _ref.isExpanded,
		    page = _ref.page,
		    collapseId = _ref.collapseId,
		    colorClass = _ref.colorClass,
		    panelGroup = _ref.panelGroup,
		    subjectID = _ref.subjectID;

		_classCallCheck(this, PanelHeading);

		this.config = config._CONFIG;
		this.setActive = setActive;
		this.isExpanded = isExpanded;
		this._panelName = data.key;
		this.title = this.config && this.config.title || this._panelName;
		this.data = data.value;
		this.collapseId = collapseId;
		this.page = page;
		this.panelGroup = panelGroup;
		this.subjectId = subjectID;
		this.showMapPopup = showMapPopup;
		this.init({ page: page, colorClass: colorClass });
	}

	_createClass(PanelHeading, [{
		key: 'init',
		value: function init(_ref2) {
			var page = _ref2.page,
			    colorClass = _ref2.colorClass;

			if (page) {
				this.cardSize = page.size;
			}
			if (this.config.request) {
				this.anotherRequestColor = _services.colorsService.getRandomColor(colorClass);
			}
		}
	}, {
		key: 'followRequest',
		value: function followRequest(value) {
			var _this = this;

			var url = Object.getProp(value, '.config.request');
			if (url) {
				var method = {};
				url = url.split(new RegExp('https://app.ticketmaster.com/'))[1];
				PanelHeading.getDeepProp(url, base, method);
				method = method.object;

				method.parameters = Object.keys(method.parameters).map(function (key) {
					var param = method.parameters[key];
					if (param.name === 'id') {
						param.value = ko.unwrap(_this.subjectId);
					} else if (param.name === 'format') {
						param.value = 'json';
					}
					return param;
				});

				this.anotherRequest = ko.observable({ url: url, method: method, panelGroup: this.panelGroup, color: this.anotherRequestColor }).publishOn('ANOTHER_REQUEST');
			}
		}
	}, {
		key: 'hasAnotherRequest',
		get: function get() {
			return !!this.config.request;
		}
	}], [{
		key: 'getDeepProp',
		value: function getDeepProp(val, obj, result) {
			if ((typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) !== 'object') return;

			for (var prop in obj) {
				if (obj.hasOwnProperty(prop) && _typeof(obj[prop]) === 'object' && !result.length) {
					if (obj[prop].path === val) {
						result.object = obj[prop];
						break;
					} else {
						PanelHeading.getDeepProp(val, obj[prop], result);
					}
				}
			}
		}
	}]);

	return PanelHeading;
}();

module.exports = ko.components.register('panel-heading', {
	viewModel: PanelHeading,
	template: '\n\t\t<section class="panel-heading">\n\t\t\t<div class="panel-title">\n\t\t\t\t\n\t\t\t\t<a data-bind="click: setActive, attr: {href: \'#\' + collapseId, \'aria-controls\': collapseId, \'aria-expanded\': isExpanded}" class="btn btn-icon btn-title" type="button" data-toggle="collapse" aria-expanded="false">\n\t\t\t\t\t<span class="btn btn-icon shevron white-shevron-up"></span>\n\t\t\t\t\t<p data-bind="text: title" class="title">Panel title</p>\n\t\t\t\t</a>\n\t\t\t\t\n\t\t\t\t<!-- ko if: _panelName === \'events\'-->\n\t\t\t\t\t<span data-bind="text: cardSize" class="counter"></span>\n\t\t\t\t<!-- /ko-->\n\t\t\t\t\n\t\t\t\t<!-- ko if: _panelName === \'page\'-->\n\t\t\t\t\t<pagination params="number: data.number, totalPages: data.totalPages, page: page"></pagination>\n\t\t\t\t<!-- /ko-->\n\t\t\t\t\n\t\t\t\t<!-- ko if: hasAnotherRequest -->\n\t\t\t\t<section class="follow-request">\n\t\t\t\t\t<span data-bind="css: anotherRequestColor" class="color-indicator"></span>\n\t\t\t\t\t<button data-bind="click: followRequest" class="btn btn-request" type="button">another request</button>\n\t\t\t\t</section>\n\t\t\t\t<!-- /ko-->\n\t\t\t\t\n\t\t\t\t<!-- ko if: _panelName === \'location\' -->\n\t\t\t\t<section class="follow-request">\n\t\t\t\t\t<button class="api-map-btn" data-bind="click: showMapPopup"></button>\n\t\t\t\t</section>\n\t\t\t\t<!-- /ko-->\n\t\t\t</div>\n\t\t</section>\n' });
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 28 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(ko, $) {

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var ErrorPopUp = function () {
	function ErrorPopUp() {
		var _this = this;

		_classCallCheck(this, ErrorPopUp);

		this.status = ko.observable('');
		this.statusText = ko.observable('');
		this.details = ko.observable('');

		ko.postbox.subscribe('REQUEST_ERROR', function (errorObj) {
			_this.status(Object.getProp(errorObj, '.responseJSON.errors[0].status') || errorObj.status || 'unknown');
			_this.statusText(Object.getProp(errorObj, '.responseJSON.errors[0].statusText') || errorObj.statusText || '');
			_this.details(Object.getProp(errorObj, '.responseJSON.errors[0].detail') || 'unknown');
			_this.togglePopUp();
		});
	}

	_createClass(ErrorPopUp, [{
		key: 'togglePopUp',
		value: function togglePopUp() {
			$('#error-modal').modal('show');
		}
	}]);

	return ErrorPopUp;
}();

module.exports = ko.components.register('error-pop-up', {
	viewModel: ErrorPopUp,
	template: '\n\t\t<section id="error-modal" class="modal fade" tabindex="-1" role="dialog">\n\t\t\t<div class="modal-dialog" role="document">\n\t\t\t\t<div class="modal-content error-pop-up">\n\t\t\t\t\t<div class="modal-header">\n\t\t\t\t\t\t<h2 class="error-title">Error <span data-bind="text: status"></span>: <span data-bind="text: statusText"></span></h2>\n\t\t\t\t\t</div>\n\t\t\t\t\t<div class="modal-body">\n\t\t\t\t\t\t<p data-bind="text: details" class="error-details"></p>\n\t\t\t\t\t</div>\n\t\t\t\t\t<div class="modal-footer">\n\t\t\t\t\t\t<button type="button" class="btn btn-primary btn-accept" data-dismiss="modal" aria-label="Close">Ok</button>\n\t\t\t\t\t</div>\n\t\t\t\t</div><!-- /.modal-content -->\n\t\t\t</div><!-- /.modal-dialog -->\n\t\t</section><!-- /.modal -->\n' });
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0), __webpack_require__(1)))

/***/ }),
/* 29 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(28);

/***/ }),
/* 30 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(32);
__webpack_require__(31);
__webpack_require__(33);

/***/ }),
/* 31 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(ko, $) {

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _services = __webpack_require__(2);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var RequestComponent = function () {
	function RequestComponent(_ref) {
		var data = _ref.data,
		    index = _ref.index,
		    sharePath = _ref.sharePath,
		    setParams = _ref.setParams;

		_classCallCheck(this, RequestComponent);

		var $index = ko.unwrap(index);
		this.data = data;
		this.response = data.response;
		this.hasResponse = !!data.response;
		this.req = data.req;
		this.jsonHL = _services.jsonHL;
		this.color = data.color;
		this.active = data.active;
		this.isActiveMoreMenu = data.isActiveMoreMenu;
		this.copiedForShare = data.copiedForShare;
		this.paramsAreSeted = data.paramsAreSeted;
		this.copiedUrl = data.copiedUrl;
		this.resHTML = data.resHTML;
		this.sharePath = sharePath;
		this.rootsetParams = setParams;
		this.ids = {
			wrapper: 'heading-' + $index,
			details: {
				id: 'show-details-' + $index,
				target: '#collapse-' + $index,
				controls: 'collapse-' + $index
			}
		};
	}

	_createClass(RequestComponent, [{
		key: 'setParams',
		value: function setParams() {
			var _this = this;

			this.paramsAreSeted(true);
			setTimeout(function () {
				_this.paramsAreSeted(false);
			}, 500);
			this.rootsetParams(this.data);
		}
	}, {
		key: 'getMoreMenu',
		value: function getMoreMenu() {
			this.isActiveMoreMenu(!ko.unwrap(this.isActiveMoreMenu));
		}

		/**
   * Details toggle handler
   * @param model
   * @param event
   */

	}, {
		key: 'getDetails',
		value: function getDetails(model, event) {
			if (!ko.unwrap(this.resHTML).length) {
				this.jsonHL(this.resHTML, this.response);
			}

			var slider = $(event.currentTarget).parents('.panel').find('.slick-slider');

			if (!slider.find('.slick-track').width()) {
				setTimeout(function () {
					slider.slick('setPosition');
				}, 0);
			}
			this.active(!this.active());
		}

		/**
   * Get raw response data
   * @param model {object}
   * @returns {string}
   */

	}, {
		key: 'getRawData',
		value: function getRawData() {
			var model = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

			var content = model.response || ko.unwrap(model.data.error)[3] || {};
			var rawWindow = window.open("data:text/json," + encodeURI(JSON.stringify(content, null, 2)), '_blank');
			rawWindow.focus();
		}
	}, {
		key: 'setParamsPopover',
		get: function get() {
			return {
				type: 'tooltip',
				title: 'Repeat settings of this request'
			};
		}
	}, {
		key: 'sharePathPopover',
		get: function get() {
			return {
				type: 'tooltip',
				title: 'Copy request share link'
			};
		}
	}, {
		key: 'copyUrlPopover',
		get: function get() {
			return {
				type: 'tooltip',
				title: 'Copy request URL'
			};
		}
	}, {
		key: 'getRawDataPopover',
		get: function get() {
			return {
				type: 'tooltip',
				title: 'Show raw response data'
			};
		}
	}]);

	return RequestComponent;
}();

module.exports = ko.components.register('request-component', {
	viewModel: RequestComponent,
	template: '\n\t\t<section class="row-container request" data-bind="attr: {id: ids.wrapper}" role="tab">\n\t\t\t<div class="edit-controls" data-bind="css: {\'visible white\': isActiveMoreMenu}">\n\t\t\t\t<button data-bind="click: setParams, css: {done: paramsAreSeted}, popover: setParamsPopover" class="btn btn-icon btn-preset" type="button"></button>\n\t\t\t\t<button data-bind="copyToClipboard: {text: sharePath}, popover: sharePathPopover" class="btn btn-icon btn-share" type="button"></button>\n\t\t\t\t<button data-bind="copyToClipboard: {text: req}, popover: copyUrlPopover" class="btn btn-icon btn-copy" type="button"></button>\n\t\t\t\t<button data-bind="click: getRawData, popover: getRawDataPopover" class="btn btn-icon btn-raw" type="button"></button>\n\t\t\t</div>\n\t\t\t<button data-bind="click: getMoreMenu, css: {active: isActiveMoreMenu}" class="btn btn-icon btn-more"></button>\n\t\t\t<div class="panel-title">\n\t\t\t\t<!-- ko if: hasResponse -->\n\t\t\t\t\t<button data-bind="click: getDetails, attr: {id: ids.details.id, \'data-target\': ids.details.target, \'aria-controls\': ids.details.controls}" type="button" class="btn btn-icon shevron up blue view-control" data-toggle="collapse" data-parent="#response" aria-expanded="false"></button>\n\t\t\t\t<!-- /ko -->\n\t\t\t\t<!-- ko ifnot: hasResponse -->\n\t\t\t\t\t<button data-bind="popover: {type: \'popover\', trigger: \'click\', data: data.error}" class="btn btn-icon btn-alert view-control"></button>\n\t\t\t\t<!-- /ko -->\n\t\t\t</div>\n\t\t\t<span data-bind="css: color" class="color-indicator view-control"></span>\n\t\t\t<p data-bind="text: req, blockEllipsis: {clamp: 2}" class="item_text"></p>\n\t\t</section>\n' });
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0), __webpack_require__(1)))

/***/ }),
/* 32 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(ko, $) {

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _services = __webpack_require__(2);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var slider = __webpack_require__(43);

var RequestListComponent = function () {
	function RequestListComponent(_ref) {
		var selectedParams = _ref.selectedParams,
		    sharePath = _ref.sharePath,
		    setParams = _ref.setParams;

		_classCallCheck(this, RequestListComponent);

		this.url = selectedParams;
		this.sharePath = sharePath;
		this.requests = ko.observableArray([]).syncWith('REQUESTS_ARR');
		this.setParams = setParams;
		this.colors = _services.colorsService.colors;
		this.viewModel = ko.observableArray([]);
		this.clearBtnIsVisible = ko.computed(this._isVisible, this);
		this.requests.subscribe(this.updateModel, this);
	}

	/**
  * Update Viewmodel of request list
  * @param arr
  */


	_createClass(RequestListComponent, [{
		key: 'updateModel',
		value: function updateModel(arr) {
			var _this = this;

			var newModel = ko.unwrap(this.requests).map(function (obj) {
				var newObj = {
					color: _this.colors[obj.index % _this.colors.length],
					active: ko.observable(false),
					isActiveMoreMenu: ko.observable(false),
					copiedForShare: ko.observable(false),
					paramsAreSeted: ko.observable(false),
					copiedUrl: ko.observable(false),
					resHTML: ko.observable('')
				};

				// error popover
				if (obj.error) {
					var errorObj = obj.error;
					newObj.error = ko.observable([Object.getProp(errorObj, '.responseJSON.errors[0].status') || errorObj.status + '', Object.getProp(errorObj, '.responseJSON.errors[0].statusText') || '', Object.getProp(errorObj, '.responseJSON.errors[0].detail') || 'unknown', Object.getProp(errorObj, '.responseJSON') || {}]);
				}

				return $.extend({}, obj, newObj);
			});
			slider.remove(this.viewModel().length);
			this.viewModel(newModel);
			setTimeout(function () {
				slider.set(_this.viewModel().length);
				$('#show-details-0').trigger('click');
			}, 10);
		}

		/**
   * Visibility flag for Clear btn
   * @returns {boolean}
   * @private
   */

	}, {
		key: '_isVisible',
		value: function _isVisible() {
			return ko.utils.unwrapObservable(this.requests).length > 0;
		}

		/**
   * Clear requeststs list handler
   * @param vm
   * @param event
   */

	}, {
		key: 'onClearRequests',
		value: function onClearRequests(vm, event) {
			this.requests([]);
		}
	}]);

	return RequestListComponent;
}();

module.exports = ko.components.register('request-list', {
	viewModel: RequestListComponent,
	template: '\n\t<section class="clearfix">\n\t\t<!--ko if: clearBtnIsVisible-->\n\t\t\t<!--headline-->\n\t\t\t<section class="row-container api-exp-request-list-headline">\n\t\t\t\t<h4 class="title">Request list</h4>\n\t\t\t\t<div class="headline-edit">\n\t\t\t\t\t<button data-bind="click: onClearRequests, popover: {type: \'tooltip\', title: \'Clear requests history\'}" class="btn btn-icon btn-clear" type="button"></button>\n\t\t\t\t</div>\n\t\t\t</section>\n\n\t\t\t<!--requests-->\n\t\t\t<section>\n\t\t\t\t<ul data-bind="foreach: viewModel" class="panel-group api-exp-request-list" id="response" role="tablist" aria-multiselectable="true">\n\t\t\t\t\t<li data-bind="css: {active: active}" class="panel panel-default api-exp-request-list-item clearfix">\n\t\t\t\t\t\t<request-component params="data: $data, index: $index, sharePath: $root.sharePath, setParams: $root.setParams"></request-component>\n\t\t\t\t\t\t<response-component params="data: $data, index: $index, config: $root.config, setParams: $component.setParams"></response-component>\n\t\t\t\t\t</li>\n\t\t\t\t</ul>\n\t\t\t</section>\n\t\t<!-- /ko -->\n\t</section>\n' });
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0), __webpack_require__(1)))

/***/ }),
/* 33 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(ko, $) {

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var ResponseComponent = function () {
	function ResponseComponent(_ref) {
		var _this = this;

		var data = _ref.data,
		    index = _ref.index,
		    config = _ref.config,
		    setParams = _ref.setParams,
		    getRandomColor = _ref.getRandomColor;

		_classCallCheck(this, ResponseComponent);

		_initialiseProps.call(this);

		this.index = ko.unwrap(index);
		this.data = data;
		this.hasResponse = !!data.response;
		this.resHTML = data.resHTML;
		this.color = data.color;
		this.config = config;
		this.setParams = setParams;
		this.response = data.response;
		this.req = data.req;

		this.breadcrubsArr = [];
		this.breadcrumbs = ko.observable('');

		this.attrs = {
			wrapper: {
				id: 'collapse-' + this.index,
				'aria-labelledby': 'heading-' + this.index
			},
			tabs: {
				json: {
					href: '#json-' + this.index,
					'aria-controls': 'json-' + this.index
				},
				blocks: {
					href: '#slider-' + this.index,
					'aria-controls': 'blocks-' + this.index
				}
			},
			view: {
				json: {
					id: 'json-' + this.index
				},
				blocks: {
					id: 'slider-' + this.index
				}
			}
		};

		ko.postbox.subscribe('ANOTHER_RESPONSE', function (_ref2) {
			var data = _ref2.data,
			    panelGroup = _ref2.panelGroup,
			    color = _ref2.color;

			var response = panelGroup.prepareData({ params: { data: data.response } });
			_this.getMore({
				id: panelGroup.groupIndex,
				data: response,
				pGroup: panelGroup,
				color: color
			});
		});
	}

	/**
  * get details
  */


	_createClass(ResponseComponent, [{
		key: 'buildBreadcrumbs',
		value: function buildBreadcrumbs(_ref3) {
			var index = _ref3.index,
			    parent = _ref3.parent,
			    current = _ref3.current;

			var str = index ? '/' : '';

			if (typeof current === 'number') {
				str += parent + '[' + current + ']';
			} else {
				str += parent + '/' + current;
			}
			this.breadcrubsArr[index] = str;
			this.breadcrubsArr.length = index + 1;

			this.breadcrumbs(this.breadcrubsArr.join(''));
		}
	}]);

	return ResponseComponent;
}();

var _initialiseProps = function _initialiseProps() {
	var _this2 = this;

	this.getMore = function (_ref4) {
		var _ref4$panel = _ref4.panel,
		    panel = _ref4$panel === undefined ? {} : _ref4$panel,
		    id = _ref4.id,
		    data = _ref4.data,
		    pGroup = _ref4.pGroup,
		    color = _ref4.color;

		var panelGroup = pGroup || panel.panelGroup;
		var currentSlider = $('#slider-' + panelGroup.sectionIndex);
		var component = $('<section data-bind="component: {name: \'panel-group\', params: params}"></section>');
		var curslick = currentSlider.slick('getSlick');

		// extending additional data (copy)
		var params = $.extend({}, panelGroup, {
			data: data,
			groupIndex: panelGroup.groupIndex + 1,
			_propTitle: typeof id === 'string' && id || 'object',
			config: panel.config,
			colorClass: color
		});

		// apply component data bindings
		ko.applyBindings({
			params: params
		}, component[0]);

		// build breadcrubs
		_this2.buildBreadcrumbs({ index: panelGroup.groupIndex, parent: panel._panelName, current: id });

		// add slide with selected data
		currentSlider.slick('slickAdd', component);
		// remove outstanding slides
		for (var i = curslick.slideCount - 2; i > panelGroup.groupIndex; i--) {
			currentSlider.slick('slickRemove', i, false);
		}
		// move to next slide
		setTimeout(function () {
			currentSlider.slick('slickNext');
		}, 310);
	};
};

module.exports = ko.components.register('response-component', {
	viewModel: ResponseComponent,
	template: '\n\t\t<!-- ko if: hasResponse -->\n\t\t<section class="response collapse" data-bind="attr: attrs.wrapper" role="tabpanel">\n\t\t\t\t<div class="row-container">\n\t\t\t\t\n\t\t\t\t\t<!-- Nav tabs -->\n\t\t\t\t\t<ul class="nav nav-tabs tabs-controlls" role="tablist">\n\t\t\t\t\t\t<li role="presentation" class="tab">\n\t\t\t\t\t\t\t<a data-bind="attr: attrs.tabs.json" class="tab-btn" href="#json" aria-controls="json" role="tab" data-toggle="tab">Json</a>\n\t\t\t\t\t\t</li>\n\t\t\t\t\t\t<li role="presentation" class="tab active">\n\t\t\t\t\t\t\t<a data-bind="attr: attrs.tabs.blocks" class="tab-btn" href="#blocks" aria-controls="blocks" role="tab" data-toggle="tab">Blocks</a>\n\t\t\t\t\t\t</li>\n\t\t\t\t\t</ul>\n\t\t\t\t\t\n\t\t\t\t\t<ul class="nav nav-tabs info">\n\t\t\t\t\t\t<li class="tab">\n\t\t\t\t\t\t\t<div class="tab-label">\n\t\t\t\t\t\t\t\t<span data-bind="visible: breadcrumbs">Structure:</span>\n\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t</li>\n\t\t\t\t\t\t<li class="tab">\n\t\t\t\t\t\t\t<span data-bind="text: breadcrumbs" class="tab-label breadcrumbs truncate"></span>\n\t\t\t\t\t\t</li>\n\t\t\t\t\t</ul>\n\n\t\t\t\t\t<!-- Tab panes -->\n\t\t\t\t\t<div class="row">\n\t\t\t\t\t\t<div class="tab-content col-xs-12">\n\t\t\t\t\t\t\t<!-- json -->\n\t\t\t\t\t\t\t<div data-bind="scroll: {x: false, y: true}, attr: attrs.view.json" role="tabpanel" class="tab-pane prety-json" id="json">\n\t\t\t\t\t\t\t\t<p data-bind="html: resHTML"></p>\n\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t<!-- blocks -->\n\t\t\t\t\t\t\t<div data-bind="attr: attrs.view.blocks" role="tabpanel" class="tab-pane blocks active" id="blocks">\n\t\t\t\t\t\t\t\t<panel-group params="\n\t\t\t\t\t\t\t\t\tcategory: data.category,\n\t\t\t\t\t\t\t\t\tmethod: data.method,\n\t\t\t\t\t\t\t\t\tmethodId: data.methodId,\n\t\t\t\t\t\t\t\t\tparams: data.params,\n\t\t\t\t\t\t\t\t\tdata: data.response,\n\t\t\t\t\t\t\t\t\tcolorClass: data.color,\n\t\t\t\t\t\t\t\t\tsectionIndex: index,\n\t\t\t\t\t\t\t\t\tfilter: config,\n\t\t\t\t\t\t\t\t\tsetParams: setParams,\n\t\t\t\t\t\t\t\t\tgetMore: getMore\n\t\t\t\t\t\t\t\t\t">\n\t\t\t\t\t\t\t\t</panel-group>\n\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t</div>\n\t\t\t\t\t</div>\n\t\t\t\t</div>\n\t\t</section>\n\t\t<!-- /ko -->\t\n' });
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0), __webpack_require__(1)))

/***/ }),
/* 34 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(ko) {

/**
 * blockEllipsis - Clamps (ie. cuts off) an HTML element's content by adding ellipsis to it if the content inside is too long.
 *
 * example: <tag data-bind="blockEllipsis: {clamp: 2}"></tag>
 * link to source: https://github.com/josephschmitt/Clamp.js
 */
ko.bindingHandlers.blockEllipsis = {
  init: function init(element, valueAccessor, allBindings, viewModel, bindingContext) {
    $clamp(element, valueAccessor());
  }
};
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 35 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(ko) {

ko.bindingHandlers.classificationsMap = {
	init: function init(element, valueAccessor, allBindings, viewModel, bindingContext) {
		var params = valueAccessor();
		var _allBindings = allBindings();
		var _bindingContext = bindingContext;
	}
};
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 36 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function($, Clipboard, ko) {

/**
 * copyToClipboard - A modern approach to copy text to clipboard
 *
 * example: <tag data-bind="copyToClipboard: {text: 'some text to copy'}"></tag>
 *
 * options:
 *	text: 'string' - copy|cut text
 *	-- optional --
 * 	target: <node|element> - target element
 * 	action: <string> - type of action 'copy' or 'cut'(cut only for text input field and textarea field)
 * 	doneClass: <string> - css class for successful action (default is done)
 * 	errorClass: <string> - css class for error action (default is error)
 * 	animationTime: <number> (default is 500)
 *
 * link to source: https://clipboardjs.com
 */
ko.bindingHandlers.copyToClipboard = {
	init: function init(element, valueAccessor, allBindings, viewModel, bindingContext) {
		var $element = $(element);
		var params = valueAccessor();
		var done = params.doneClass || 'done';
		var error = params.errorClass || 'error';
		var animationTime = params.animationTime || 500;

		element.clipboard = new Clipboard(element, {
			action: function action(trigger) {
				return params.action || 'copy';
			},
			target: function target(trigger) {
				return params.target;
			},
			text: function text(trigger) {
				return ko.unwrap(params.text);
			}
		});

		element.clipboard.on('success', function (e) {
			$element.addClass(done);
			setTimeout(function () {
				return $element.removeClass(done);
			}, animationTime);
			e.clearSelection();
		}).on('error', function (e) {
			$element.addClass(error);
			setTimeout(function () {
				return $element.removeClass(error);
			}, animationTime);
			console.error('copyToClipboard custom binding - Action:', e.action);
			console.error('copyToClipboard custom binding - Trigger:', e.trigger);
		});

		ko.utils.domNodeDisposal.addDisposeCallback(element, function () {
			if ($element.clipboard && typeof $element.clipboard.destroy === "function") {
				$element.clipboard && $element.clipboard.destroy();
				delete $element.clipboard;
			}
		});
	}
};
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1), __webpack_require__(57), __webpack_require__(0)))

/***/ }),
/* 37 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(ko) {

module.exports = ko.bindingHandlers.foreachprop = {

	transformObject: function transformObject(params) {
		var properties = [];
		var obj,
		    sortFn = params.sortFn;

		obj = sortFn ? params.data : params;
		obj = ko.utils.unwrapObservable(obj);

		ko.utils.objectForEach(obj, function (key, value) {
			properties.push({
				key: key,
				value: value
			});
		});

		if (sortFn) {
			properties.sort(sortFn);
		}

		return properties;
	},
	init: function init(element, valueAccessor, allBindingsAccessor, viewModel, bindingContext) {
		var properties = ko.pureComputed(function () {
			var obj = ko.utils.unwrapObservable(valueAccessor());
			return ko.bindingHandlers.foreachprop.transformObject(obj);
		});
		ko.applyBindingsToNode(element, {
			foreach: properties
		}, bindingContext);
		return {
			controlsDescendantBindings: true
		};
	}
};
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 38 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function($, ko) {

ko.bindingHandlers.imgOnError = {
	init: function init(element, valueAccessor, allBindings, viewModel, bindingContext) {
		var $element = $(element);
		var params = valueAccessor();

		$element.on('error', function () {
			console.warn('error');
			$element.parents('.map-panel-body').css('display', 'none');
		});
		ko.utils.domNodeDisposal.addDisposeCallback(element, function () {
			if ($element.clipboard && typeof $element.clipboard.destroy === "function") {
				$element.clipboard && $element.clipboard.destroy();
				delete $element.clipboard;
			}
		});
	}
};
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1), __webpack_require__(0)))

/***/ }),
/* 39 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(34);
__webpack_require__(37);
__webpack_require__(41);
__webpack_require__(36);
__webpack_require__(40);
__webpack_require__(35);
__webpack_require__(38);

/***/ }),
/* 40 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function($, ko) {

ko.bindingHandlers.lazyLoader = {
	init: function init(element, valueAccessor) {
		var params = valueAccessor();
		var name = params.name.toLowerCase();
		var datesArr = ['startDateTime', 'endDateTime', 'onsaleStartDateTime', 'onsaleEndDateTime'];
		var dateIndex = datesArr.indexOf(params.name);

		var selector = name === 'venueid' ? 'venues' : name === 'attractionid' ? 'attractions' : '';
		var type = name === 'classificationid' ? 'id' : name === 'classificationname' ? 'name' : '';

		if (dateIndex !== -1) {
			addCalendar();
		} else if (selector || type) {
			selector ? $(element).lazySelector({ selector: selector }) : $(element).classificationSelector({ selector: 'classifications', use: type });

			$(element).on('change', function () {
				params.val($(this).val());
			});
		} else if (params.name.toLowerCase() === 'latlong') {
			addLatlong();
		}

		function addCalendar() {
			var btn = $('<button class="custom-input__button">&nbsp;</button>');
			var label = datesArr[dateIndex];
			var selector = $(element);

			selector.after(btn);
			btn.on("click", function () {
				NewCssCal(label, 'yyyyMMdd', 'dropdown', true, '24');
			});

			selector.on('onchange', function () {
				params.val($(this).val());
			});
		}

		function addLatlong() {
			var $input = $(element),
			    btnLatlong = $('<a href="#" id="js_widget_modal_map__open" class="latlong-picker"></a>'),
			    $widgetModalMap = $('#js_widget_modal_map');

			$input.after(btnLatlong);

			btnLatlong.on('click', function (e) {
				e.preventDefault();
				$widgetModalMap.modal('show');
				google.maps.event.trigger(map_latlong, 'resize');
			});

			$('#js_widget_modal_map').on('shown.bs.modal', function () {
				google.maps.event.trigger(map_latlong, 'resize');
				/*set senter on map_open*/
				/*
    var tmp_currentLatLng = $input.val().split(','); //document.getElementById('latlong').value.split(',');
    var currentLatLng = new google.maps.LatLng(parseInt(tmp_currentLatLng[0].replace(/\s+/g, ''))||49.2336287, parseInt(tmp_currentLatLng[1].replace(/\s+/g, ''))||28.4669495);
    map_latlong.setCenter(currentLatLng);
    */
			});

			$('#js_widget_modal_map__close').on('click', function () {
				$widgetModalMap.modal('hide');
				$input.val($input.val().replace(/\s+/g, ''));
				params.val($input.val()); //instead of 'onchange'
			});
		}
	}
};
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1), __webpack_require__(0)))

/***/ }),
/* 41 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function($, ko) {

var common = {
	container: 'body',
	trigger: 'hover',
	placement: 'bottom'
};

ko.bindingHandlers.popover = {
	update: function update(element, valueAccessor) {
		var $element = $(element);
		var params = valueAccessor();
		var config = $.extend({}, common, params, { data: null });

		if (params.type === 'popover' && params.data) {
			var data = ko.unwrap(params.data);
			config.title = 'Error ' + data[0] + ': ' + data[1];
			config.content = data[2];
			$element.popover(config);
			if (config.trigger === 'click') {
				var timer;
				$element.on('shown.bs.popover', function () {
					timer = setTimeout(function () {
						$element.trigger('click');
					}, 2000);
				});
				$element.on('hide.bs.popover', function () {
					clearInterval(timer);
				});
			}
		} else {
			config.delay = {
				"show": 1500,
				"hide": 100
			};
			config.title = params.title || config.title;
			$element.tooltip(config);
		}
	}
};
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1), __webpack_require__(0)))

/***/ }),
/* 42 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(59);
__webpack_require__(50);
__webpack_require__(49);
__webpack_require__(51);
__webpack_require__(44);
__webpack_require__(55);
__webpack_require__(54);
__webpack_require__(52);
__webpack_require__(60);
__webpack_require__(53);

/***/ }),
/* 43 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function($) {

var config = {
	dots: false,
	infinite: false,
	speed: 300,
	slidesToShow: 3,
	slidesToScroll: 1,
	autoplay: false,
	focusOnSelect: true,
	responsive: [{
		breakpoint: 1200,
		settings: {
			dots: true,
			slidesToShow: 2,
			slidesToScroll: 1
		}
	}, {
		breakpoint: 800,
		settings: {
			dots: true,
			slidesToShow: 1,
			slidesToScroll: 1
		}
	}]
};

function slick(times) {
	"use strict";

	var selector = '#slider-';

	for (var i = 0; i < times; i++) {
		var slider = $(selector + i);
		if (slider.length) {
			slider.slick(config);
		}
	}
}

function unslick(times) {
	"use strict";

	for (var i = 0; i < times; i++) {
		var slider = $('#slider-' + i);
		slider.length && slider.slick('unslick');
	}
}

module.exports = {
	set: slick,
	remove: unslick
};
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ }),
/* 44 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(ko) {

__webpack_require__(61);

ko.validation.rules.pattern.message = 'Invalid.';

ko.validation.init({
	registerExtenders: true,
	messagesOnModified: true,
	decorateInputElement: true,
	errorMessageClass: 'custom-input__validation-message',
	errorElementClass: 'not-valid',
	insertMessages: false,
	parseInputAttributes: true,
	messageTemplate: null,
	grouping: {
		deep: true,
		live: true,
		observable: true
	}
}, true);

ko.validation.rules['nullableInt'] = {
	validator: function validator(val, validate) {
		return val === null || val === "" || val === 0 || validate && /^-?\d*$/.test(val.toString());
	},
	message: 'Must be empty or an integer value'
};

ko.validation.rules['nullableDecimal'] = {
	validator: function validator(val, validate) {
		return val === null || val === "" || validate && /^-?\d*(?:\.\d*)?$/.test(val.toString());
	},
	message: 'Must be empty or a decimal value'
};

ko.validation.registerExtenders();
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 45 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Colors service (singleton)
 */

var num = Symbol('NUM');
var prefix = Symbol('PREFIX');
var instance = null;

var ColorsService = function () {
	function ColorsService() {
		var NUM = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 12;
		var PREFIX = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'color-';

		_classCallCheck(this, ColorsService);

		if (!instance) {
			instance = this;
		}

		this[num] = NUM;
		this[prefix] = PREFIX;
		this.colors = this.getColors();

		return instance;
	}

	/**
  * Gets random color css class
  * @param color {string} existing css class to prevent mach
  * @returns {string} css class name
  */


	_createClass(ColorsService, [{
		key: 'getRandomColor',
		value: function getRandomColor(color) {
			var randomNumber = void 0;
			var PREFIX = this[prefix];
			do {
				randomNumber = this.constructor.getRandomInt(1, this.colors.length);
			} while (PREFIX + randomNumber === color);

			return PREFIX + randomNumber;
		}

		/**
   * Builds array of colors css classes
   * @returns {Array} array of strings
   */

	}, {
		key: 'getColors',
		value: function getColors() {
			var colors = new Array(this[num]);
			for (var i = 0; i < colors.length; i++) {
				colors[i] = this[prefix] + (i + 1);
			}
			return colors;
		}

		/**
   * Returns a random integer between min (inclusive) and max (inclusive)
   * Using Math.round() will give you a non-uniform distribution!
   */

	}], [{
		key: 'getRandomInt',
		value: function getRandomInt(min, max) {
			return Math.floor(Math.random() * (max - min + 1)) + min;
		}
	}]);

	return ColorsService;
}();

module.exports = new ColorsService();

/***/ }),
/* 46 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(ko, $) {

var config = ko.observable();

$.ajax({
	type: 'GET',
	url: ['http://', document.location.hostname, document.location.port && ':' + document.location.port, '/scripts/api-explorer/v2/config.json'].join(''),
	async: true,
	dataType: "json",
	complete: function complete(res, msg) {
		if (msg == 'error') {
			console.error('can\'t load config.json!');
		} else {
			config(res.responseJSON);
		}
	}
});

module.exports = config;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0), __webpack_require__(1)))

/***/ }),
/* 47 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function($) {

var Worker = __webpack_require__(9); // Json-formatter worker

module.exports = function (observable, code) {
	var animTime = 100;
	var worker = new Worker();

	worker.onmessage = function (event) {
		observable(event.data);

		$(document).on('click touch', '.tm-code-container .expanded', function jsonCodeContainerExpanded(e) {
			e.preventDefault();
			e.stopPropagation();
			var $self = $(this);
			$self.parent().find('>ul').slideUp(animTime, function () {
				$self.addClass('collapsed');
			});
		}).on('click touch', '.tm-code-container .expanded.collapsed', function jsonCodeContainerCollapsed(e) {
			e.preventDefault();
			e.stopPropagation();
			var $self = $(this);
			$self.removeClass('collapsed').parent().find('>ul').slideDown(animTime, function () {
				$self.removeClass('collapsed').removeClass('hidden');
			});
		});
	};
	worker.onerror = function (event) {
		console.error(event);
	};

	worker.postMessage(code);
};
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ }),
/* 48 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

var countryCodes = __webpack_require__(58);

exports.default = [{
	name: 'none',
	checked: true,
	link: false
}].concat(_toConsumableArray(countryCodes.CountryCode.map(function (codeAndCountry) {
	return {
		name: codeAndCountry.substr(4, codeAndCountry.length - 5), // or you can use regexp \(([a-zA-Z\s]+)\)
		value: codeAndCountry.substr(0, 2),
		checked: false,
		link: false
	};
})));

/***/ }),
/* 49 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(jQuery) {

/**
 * required to include: classification-selector-modal.html
 *
 * availiable option :
 * {
 *    selector: 'classifications'
 *    use: 'name', 'id'
 * }
 * 
 * $('.js_lazy-selector-attractions').classificationSelector({selector:'classifications', use:'name'});
 * $('.js_lazy-selector-venues').classificationSelector({selector:'classifications', use:'id'});
 */

(function ($) {

  $.fn.classificationSelector = function (options) {
    var defaults = {},
        settings = $.extend({}, $.fn.lazySelector.defaults, options),
        $iconButton = $('<a class="icon" id="get-' + options.selector + '-' + options.use + '" data-toggle="modal" data-target="#js_ls-modal-classification" />');

    var $input = $(this),
        $modal = $('#js_ls-modal-classification'),
        $form = $('#js_lazy-sel_form', $modal),
        $btnGET = $modal.find('#js_classification-modal_btn'),
        cssValidationClass = 'get-eventId_form-validation',
        modalContent = $('.modal-content', $modal),
        $jstree = $('#classification-jstree');
    var keyword = $form.find('#keyword'),
        apikey = apiKeyService.checkApiKeyCookie('tk-api-key') || $('#w-tm-api-key').val() || apiKeyService.getApiExploreKey(),
        selector = options.selector,
        use = options.use,
        eventUrl = 'https://app.ticketmaster.com/discovery/v2/' + selector + '.json';

    function initTree(json) {
      json = setChildren(json['_embedded']['classifications']);

      $jstree.jstree({
        "core": {
          'check_callback': true,
          'data': json
        },
        "plugins": ["search"],
        "search": {
          "show_only_matches": true,
          /**
           * Indicates if all nodes opened to reveal the search result, should be closed when the search is cleared or a new search is performed. Default is `true`.
           * @name $.jstree.defaults.search.close_opened_onclear
           * @plugin search
           */
          "case_sensitive": false
        }
      }).on('select_node.jstree', function (e, data) {
        data.instance.toggle_node(data.node); //set open on one click
        var i,
            j,
            r = [];
        for (i = 0, j = data.selected.length; i < j; i++) {
          r.push({
            text: data.instance.get_node(data.selected[i]).text,
            id: data.instance.get_node(data.selected[i]).id
          });
        }

        $('button', $jstree).off('click', setIdListener).remove();

        $('<button/>').addClass('btn btn-submit btn-small').text('Use').attr('data-classificationId', use === 'name' ? r[0].text : r[0].id).insertAfter($('#' + r[0].id + ' .jstree-clicked', $jstree)).on('click', setIdListener);
      });
    }

    function updateTree(json) {
      var newJson = json['_embedded'] && json['_embedded']['classifications'] ? setChildren(json['_embedded']['classifications']) : null;
      $jstree.jstree(true).settings.core.data = newJson;
      $jstree.jstree(true).refresh();

      if (newJson && newJson.length && newJson[0].children.length === 0) {
        setTimeout(function () {
          $('.jstree-icon').hide();
        }, 100);
      };
    }

    /**
     *
     * @param data {Array} - recived classifications array
     * @returns {Array}
     */
    function setChildren(data) {
      var newArrObj = [];
      data = rename(data);

      //rename parent(genres)
      data.map(function (item) {
        newArrObj.push({
          children: item.segment._embedded && item.segment._embedded.genres ? item.segment._embedded.genres : [],
          text: item.segment.text || '',
          id: item.segment.id
        });
      });
      //rename/copy child(subgenres) field
      newArrObj.map(function (item) {
        item.children.map(function (item) {
          if (item._embedded && item._embedded.subgenres) {
            item['children'] = item._embedded.subgenres;
            delete item._embedded;
          }
        });
      });

      return newArrObj;
    }

    /**
     * Rename fields
     * @param json
     */
    function rename(json) {
      var opt = {
        root: { fieldName: ['segment'], val: 'text', to: 'name' },
        parent: { fieldName: ['genres'], '_embedded': true, val: 'text', to: 'name' },
        child: { fieldName: ['subgenres'], '_embedded': true, val: 'text', to: 'name' }
      };
      var arr = JSON.stringify(json); //convert array to string
      arr = JSON.parse(arr);

      function replaceAtoB(arr, opt) {
        var genresArr = [],
            subgenresArr = [];
        for (var i = 0; i < arr.length; i++) {
          arr[i][opt.root.fieldName][opt.root.val] = arr[i][opt.root.fieldName][opt.root.to];
          delete arr[i][opt.root.fieldName][opt.root.to];

          if (arr[i][opt.root.fieldName]['_embedded'] && opt.parent.fieldName in arr[i][opt.root.fieldName]['_embedded']) {
            genresArr = arr[i][opt.root.fieldName]['_embedded'][opt.parent.fieldName];
          }
          if (0 < genresArr.length) {
            for (var ii = 0; ii < genresArr.length; ii++) {
              genresArr[ii][opt.parent.val] = genresArr[ii][opt.parent.to];
              delete genresArr[ii][opt.parent.to];

              if (genresArr[ii]['_embedded'] && genresArr[ii]['_embedded'][opt.child.fieldName]) {
                subgenresArr = genresArr[ii]['_embedded'][opt.child.fieldName];
              }
              if (0 < subgenresArr.length) {
                for (var j = 0; j < subgenresArr.length; j++) {
                  subgenresArr[j][opt.child.val] = subgenresArr[j][opt.child.to];
                  if (j > 0) delete subgenresArr[j][opt.child.to]; //skip zero item
                }
              }
            }
          }
        }
      }
      replaceAtoB(arr, opt);
      return arr;
    }

    /**
     * set data-selector for "GET" button
     */
    function changeModalTextListener() {
      $btnGET.attr('data-selector', selector);
      submitForm(true);
    }

    /**
     * show/hide loader
     * @param action - string ('on' or 'off')
     */
    var loading = function loading(action) {
      var spinner = $('#spinner-ls', $modal);
      // add the overlay with loading image to the page
      if (action == "on") {
        spinner.show();
      } else if (action == "off") {
        spinner.hide();
      }
    };

    function resetForm() {
      $jstree.jstree("destroy").removeAttr('class').removeAttr('role').removeAttr('aria-activedescendant');
      // Clear highlight
      $form.removeClass(cssValidationClass);
    }

    /**
     * Handler for 'GET' button
     * @param pageNumero - int. used for pagination
     * @param eventUrl - url of request
     * @returns {boolean} - done/fail
     */
    function submitForm(isInit) {
      var url = isInit ? eventUrl + '?apikey=' + apikey : eventUrl + '?apikey=' + apikey + '&keyword=' + keyword.val();

      $.ajax({
        dataType: 'json',
        async: true,
        url: url,
        data: $form.serialize()
      }).done(function (result) {
        if (result) {
          if (result.page.totalElements < 1) {
            loading('off');
            renderResults(null, $jstree); //add message at bottom of list
            return false;
          };

          isInit ? initTree(result) : updateTree(result);
          loading('off');
          $btnGET.attr('disabled', false);
        } else {
          console.log('no result found');
        }
      }).fail(function (e, textStatus, errorThrown) {
        console.log('There was an fail status - ', e.status, errorThrown);
        loading('off');
        renderResults('FAIL', $jstree, e);
        $btnGET.attr('disabled', false);
      });
    }

    function hasScrollBar(element) {
      return element.get(0).scrollHeight > element.parent().innerHeight();
    }

    var renderResults = function renderResults(data, ulElement, errorMsg) {
      function showMessage(element, message, /*optional*/clearList) {
        if (clearList) {
          $('li', element).remove();
          $('.error-box').remove();
        }

        $('<div/>').addClass('error-box text-center ').addClass(data === 'FAIL' ? ' error-fail ' : '').append($('<h3/>').text(message.msg)).append($('<p/>').text(message.explanation)).appendTo(ulElement);
      }

      $btnGET.attr('disabled', false);

      //show fail msg
      if (data === 'FAIL') {
        var msgErr = errorMsg.responseJSON !== null ? errorMsg.responseJSON.errors[0].status : 'unknown',
            statusText = errorMsg.responseJSON !== null ? errorMsg.responseJSON.errors[0].statusText : errorMsg.statusText || '',
            explanation = errorMsg.responseJSON !== null ? errorMsg.responseJSON.errors[0].detail : 'unknown';

        showMessage($jstree, {
          msg: 'Error ' + msgErr + ': ' + statusText,
          explanation: explanation
        }, true);
        return false;
      }

      //show No results found msg
      if (data === null || !data._embedded) {
        showMessage(ulElement, { msg: 'No results found.', explanation: 'Please try to get another keyword.' }, true);
        modalContent.removeClass('narrow');
        return false;
      }
    };

    function setIdListener(e) {
      var selectedID = e.target.getAttribute('data-classificationId');
      $input.val(selectedID).attr('value', selectedID).trigger('change'); //update widget:

      // Close dialog
      $modal.modal('hide');
    }

    // EVENTS
    $btnGET.on('click', function (e) {
      e.preventDefault();
      if ($btnGET.attr('data-selector') !== $iconButton.attr('data-selector')) return false; //stop request

      var form = $form.get(0);
      if (!$btnGET.is(':disabled')) {
        if (form.checkValidity()) {
          $btnGET.attr('disabled', true);
          loading('on'); //show loading-spinner
          submitForm();
          //resetForm(); //clear
        } else {
          // Highlight errors
          if (form.reportValidity) form.reportValidity();
          $form.addClass(cssValidationClass);
        }
      }
    });

    $form.on("keyup", function (e) {
      var input = $(e.target);
      if (e.target.tagName === "INPUT") {
        if (e.keyCode == 13) {
          input.blur();

          modalContent.removeClass('narrow');
          if ($btnGET.attr('data-selector') !== $iconButton.attr('data-selector')) return false;

          if ($form.get(0).checkValidity()) {
            loading('on');
            submitForm();
          }
        }
      }
      return false;
    });

    // Mobile devices. Force 'change' by 'Go' press
    $form.on("submit", function (e) {
      e.preventDefault();
    });

    $modal.on('hidden.bs.modal', function () {
      resetForm();
      keyword.val(''); //clear search input
    });

    return this.each(function (i) {
      init($(this));

      function init(input) {
        input.wrap('<div class="lazy-selector-wrapper"></div>');
        input.after($iconButton);
        $iconButton.attr('data-selector', selector);

        $('#get-' + options.selector + '-' + options.use).on('click', changeModalTextListener);
      }
    });
  };
})(jQuery);
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ }),
/* 50 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(jQuery, $) {

/**
 * required to include: lazy-selector-modal.html
 *
 * availiable option :
 * {
 *    selector: 'attractions' , 'venues', '',
 *    hideMultiSelector: true, false
 * }
 * $('.js_lazy-selector').lazySelector();
 * $('.js_lazy-selector-attractions').lazySelector('{selector: 'attractions'});
 * $('.js_lazy-selector-venues').lazySelector({selector:'venues', hideMultiSelector:true});
 */

(function ($) {
  var config = ['events', 'venues', 'attractions'],
      tagsIds = {},
      initialVal = {};

  config.forEach(function (el) {
    tagsIds[el] = [];
    initialVal[el] = [];
  });

  $.fn.lazySelector = function (options) {
    var defaults = {},
        settings = $.extend({}, $.fn.lazySelector.defaults, options),
        $iconButton = $('<a class="icon" id="get-event-by-Id-' + options.selector + '" data-toggle="modal" data-target="#js_ls-modal" />');

    var stateConf = {
      pageIncrement: 0,
      loadingFlag: false,
      setSingleVal: false
    };

    var $input = $(this),
        $modal = $('#js_ls-modal'),
        $form = $('#js_lazy-sel_form', $modal),
        $ul = $('#js_lazy-sel_list'),
        $liFooter = $('#load-more-box'),
        $hr = $('#js_ls-top-hr'),
        $btnGET = $modal.find('#js_ls-modal_btn'),
        btnCloseMap = $('.button-close-map', $modal),
        cssValidationClass = 'get-eventId_form-validation',
        modalContent = $('.modal-content', $modal),
        $msSelection = $('.ms-selection'),
        $msList = $('.ms-list', $msSelection),
        $msBtnUse = $('#js_ms-use-btn', $msSelection);

    var keyword = $form.find('#keyword'),
        defaultApiKey = apiKeyService.getApiExploreKey(),
        apikey = apiKeyService.checkApiKeyCookie('tk-api-key') || $('#w-tm-api-key').val() || defaultApiKey,
        selector = options.selector || 'events',
        eventUrl = 'https://app.ticketmaster.com/discovery/v2/' + selector + '.json';

    function formatDate(date) {
      var result = '';
      if (!date.day) return result; // Day is required

      var MONTH_NAMES = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'],
          DAY_NAMES = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'],
          dayArray = date.day.split('-'),
          d = parseInt(dayArray[2]),
          M = parseInt(dayArray[1]);

      var E = new Date(date.day).getDay();

      //var E1 = new Date(+date.day.split('-')[0],(+date.day.split('-')[1])-1,+date.day.split('-')[2]).getDay();
      //if(E !== E1) console.log('\t alarm equal - ' , E === E1);

      result = DAY_NAMES[E] + ', ' + MONTH_NAMES[M - 1] + ' ' + d + ', ' + dayArray[0];

      if (!date.time) return result;

      var timeArray = date.time.split(':'),
          H = parseInt(timeArray[0]),
          m = timeArray[1],
          a = "AM";

      if (H > 11) a = "PM";
      if (H === 0) {
        H = 12;
      } else if (H > 12) {
        H = H - 12;
      }

      return result + ' ' + getNormalizedDateValue(H) + ':' + m + ' ' + a;
    }

    function getNormalizedDateValue(val) {
      return (val < 0 || val > 9 ? "" : "0") + val;
    }

    var map = null,
        defaultMapZoom = 10,
        markers = [];
    /**
     * Show or init map listener
     * @param e
     */
    var mapPopUpListener = function mapPopUpListener(e) {
      e.preventDefault();
      var lat = $(e.target).attr('data-latitude') != "undefined" ? parseFloat($(e.target).attr('data-latitude')) : null,
          lng = $(e.target).attr('data-longitude') != "undefined" ? parseFloat($(e.target).attr('data-longitude')) : null,
          address = lat && lng ? null : $(e.target).attr('data-address');

      if (lat && lng) {
        initMap(lat, lng);
        map.setZoom(defaultMapZoom);
        google.maps.event.trigger(map, "resize"); //'second init'
      } else {
        initMap(0, 0); //"first init"
      }
    };

    /**
     * Init map google maps
     * @param lat - float
     * @param lng - float
     * @param address - not used @deprecated
     */
    var initMap = function initMap(lat, lng) {
      var modal = $modal,
          mapCenter = new google.maps.LatLng(lat || 55, lng || 43);

      if (map === null) {
        // initialize map object
        map = new google.maps.Map(document.getElementById('map-canvas'), {
          center: mapCenter,
          zoom: defaultMapZoom,
          mapTypeControl: false,
          scaleControl: false,
          fullscreenControl: false,
          streetViewControl: false,
          rotateControl: false
        });
      } else {
        clearMarkers();

        //set new center
        map.panTo(mapCenter); //smooth center. If the change is less than both the width and height of the map, the transition will be smoothly animated.
        map.setCenter(mapCenter);
      }

      // Adds a marker at the center of the map.
      addMarker(mapCenter);

      // when map popup is shown
      modal.on("shown.bs.modal", function () {
        // Recenter the map now that it's been redrawn
        google.maps.event.trigger(map, "resize");
        map.setCenter(mapCenter);
      });
      modal.modal(); // show map popup
    };

    // Adds a marker to the map and push to the array.
    function addMarker(mapCenter) {
      var marker = new google.maps.Marker({ //Create a marker and set its position.
        map: map,
        position: mapCenter,
        icon: new google.maps.MarkerImage('../../../../assets/controls/pin-ic.svg', null, null, null, new google.maps.Size(34, 52))
      });
      markers.push(marker);
    }

    // Removes the markers from the map, but keeps them in the array.
    function clearMarkers() {
      for (var i = 0; i < markers.length; i++) {
        markers[i].setMap(null);
      }
      markers = [];
    }

    function closeMapListener() {
      modalContent.removeClass('narrow');
      btnCloseMap.hide(); // 'X' -button
    }

    function toggleTags() {
      var indToRemove = [],
          inputValArray = $input.val().split(",");

      $('li', $msList).each(function (i) {
        var listItem = $(this),
            id = listItem.data('selector-' + selector);

        if (listItem.data('selector-' + selector)) {
          listItem.show();
          if (jQuery.inArray(id, inputValArray) === -1) {
            indToRemove.push(id);
            listItem.remove();
          }
        } else {
          listItem.hide();
        }
      });

      //filter by : [indToRemove]
      tagsIds[selector] = tagsIds[selector].filter(function (el) {
        return !indToRemove.includes(el);
      });
    }

    function toggleMsSelectionBox() {
      if ($('li', $msList).length < 1) {
        $msSelection.hide();
        return;
      }

      $('li', $msList).each(function (i) {
        var listItem = $(this);
        if (listItem.data('selector-' + selector)) {
          $msSelection.show();
          return false;
        } else $msSelection.hide();
      });
    }

    /**
     * change <Load_More> button text on open modal
     * set data-selector gor "GET" button
     */
    function changeModalTextListener() {
      if (selector !== 'events') {
        $('.modal-title span', $modal).text(selector);
        $('#js_ls-more_btn', $modal).text('SHOW MORE ' + selector);
      }
      if (selector === 'venues') {
        $('.wrapper-list-group', $modal).addClass('low-height');
        $msSelection.addClass('hidden-xs');
      } else {
        $('.wrapper-list-group', $modal).removeClass('low-height');
        $msSelection.removeClass('hidden-xs');
      }

      if (options.hideMultiSelector) {
        $msSelection.hide();
      } else {
        if ($('li', $msList).length > 0) {
          $msSelection.show(); // console.log('show $msList',$('li',$msList).length);
        }
        toggleTags();
        toggleMsSelectionBox();
      }

      $btnGET.attr('data-selector', selector);
    }

    /**
     * show/hide loader
     * @param action - string ('on' or 'off')
     */
    var loading = function loading(action) {
      var spinner = $('#spinner-ls', $modal);
      // add the overlay with loading image to the page
      if (action == "on") {
        spinner.show();
      } else if (action == "off") {
        spinner.hide();
      }
    };

    function resetForm() {
      stateConf.pageIncrement = 0;
      var listItems = $ul.find('li');
      listItems.remove();
      $hr.hide();
      $liFooter.hide();

      // Clear highlight
      $form.removeClass(cssValidationClass);

      // Clear Listener, prevent memory leak
      $("#js_ls-modal").off("click", "ul li button.js_ms-add-list_btn", addMsButtonListener);
      $('#js_open-map_btn').off("click", mapListener);
    }

    /**
     * Handler for 'GET' button
     * @param pageNumero - int. used for pagination
     * @param eventUrl - url of request
     * @returns {boolean} - done/fail
     */
    function submitForm( /*optional*/pageNumero) {
      pageNumero = parseInt(pageNumero);

      var url = isNaN(pageNumero) ? eventUrl + '?apikey=' + apikey + '&keyword=' + keyword.val() : eventUrl + '?apikey=' + apikey + '&keyword=' + keyword.val() + '&page=' + pageNumero;

      //stop load
      if (isNaN(pageNumero) && pageNumero !== 0 && stateConf.loadingFlag === 'STOP_LOAD') {
        renderResults(null, $ul);
        return false;
      }

      //stop load
      if (stateConf.loadingFlag === 'FINAL_PAGE') return false;

      $.ajax({
        dataType: 'json',
        async: true,
        url: url,
        data: $form.serialize()
      }).done(function (result) {
        if (result) {
          //last page reached
          if (stateConf.pageIncrement === result.page.totalPages && result.page.totalElements > 0) {
            stateConf.loadingFlag = 'STOP_LOAD';
            loading('off');
            renderResults(result, $ul); //add message at bottom of list
            return false;
          }

          renderResults(result, $ul);
          loading('off');
        } else {
          console.log('no result found');
        }
      }).fail(function (e) {
        console.log('There was an fail status - ', e.status);
        loading('off');
        renderResults('FAIL', $ul);
      });
    }

    /**
     * find image that have width more then 120px
     * @param images - array
     * @returns {image with lowest+1 width }
     */
    function getImageForEvent(images) {
      images.sort(function (a, b) {
        if (a.width < b.width) return -1;else if (a.width > b.width) return 1;else return 0;
      });
      var src = images[0].url ? images[1] && images[1].url ? images[1].url : images[0].url : '';
      return src;
    }

    /**
     * render for events-id-selector
     * @param items - array
     */
    function renderListEvents(items) {
      var src;
      items.map(function (item) {
        var li = $('<li/>').addClass('list-group-item row')
        //.insertBefore($liFooter);
        .appendTo($ul);

        var leftCol = $('<div class="clear-padding" />').appendTo(li);
        var spanImg = $('<span class="thumbnail" />').appendTo(leftCol);

        if (item.images) {
          src = "src=" + getImageForEvent(item.images);
        } else {
          src = 'style="background-color: #f7f9fa;width: 120px; border: none;"';
        }

        var img = $('<img ' + src + ' />').addClass('list-group-item-heading').appendTo(spanImg);

        var $wrapCol = $('<div class="event-text-wrapper"/>').appendTo(li);
        if (item.name) {
          var title = $('<h4/>').addClass('list-group-item-heading').text(item.name).appendTo($wrapCol);
        }

        /*add time*/
        var currentEvent = {};
        currentEvent.date = {
          day: item.dates.start.localDate,
          time: item.dates.start.localTime,
          dateTime: item.dates.start.dateTime
        };

        var time = formatDate(currentEvent.date);
        var eventTime = $('<h4 class="event-time gray"/>').text(time).appendTo($wrapCol);
        /*add time end*/

        if (item._embedded) {

          if (item._embedded.venues) {
            var venue = item._embedded.venues[0];
            var addressName = $('<span/>').addClass('address-name').text(venue.name + '. ').appendTo($wrapCol);

            if ('address' in venue && 'line1' in venue.address) {
              var addressline1 = $('<span/>').addClass('address-line1').text(venue.address.line1).appendTo($wrapCol);
              if ('line2' in venue.address) {
                var addressline2 = $('<span/>').addClass('address-line2').text(venue.address.line2).appendTo(addressline1);
              }
            }
          } else {
            console.log('no _embedded found');
          }
        }

        if (item.id) {
          //add button <Set this ID> if 'location' exist
          var buttonSetId = $("<button data-event=" + item.id + "/>").addClass('js_lazy-sel_btn btn btn-submit').text('Use this ID').appendTo(li).wrap('<div class ="wrapper-btns text-right"/>');

          var addToEl = { li: li, buttonSetIdWrapper: buttonSetId.parent() };
          addMsButton(addToEl, item.id);
        }
      });
    }

    /**
     * render for venues-id-selector
     * @param items - array
     */
    function renderListVenues(items) {
      items.map(function (item) {

        var li = $('<li/>').addClass('list-group-item row').appendTo($ul);

        if (item.images) {
          var leftCol = $('<div class="clear-padding" />').appendTo(li);
          var spanImg = $('<span class="thumbnail" />').appendTo(leftCol);
          var img = $('<img src=' + getImageForEvent(item.images) + ' />').addClass('list-group-item-heading').appendTo(spanImg);
        }

        var $wrapCol = $('<div class="event-text-wrapper clear-margin-left"/>').appendTo(li);

        if (item.name) {
          var title = $('<h3/>').addClass('list-group-item-heading').text(item.name).appendTo($wrapCol);
        }

        if (item.dates) {
          // console.log('item.dates' , item.dates);
          /*add time*/
          var currentEvent = {};
          currentEvent.date = {
            day: item.dates.start.localDate,
            time: item.dates.start.localTime,
            dateTime: item.dates.start.dateTime
          };

          var time = formatDate(currentEvent.date);
          var eventTime = $('<h4 class="event-time gray"/>').text(time).appendTo($wrapCol);
          /*add time end*/
        }

        if (item) {
          var venue = item; // item._embedded.venues[0];
          var contryStateName = $('<h4/>').addClass('country-name gray').text(venue.country && venue.country.name ? venue.country.name : '').append(venue.state && venue.state.name ? $('<span class="add-dot">' + venue.state.name + '</>') : '').appendTo($wrapCol);
          var cityName = $('<span/>').addClass('address-name').text(venue.city && venue.city.name ? venue.city.name + '. ' : '').appendTo($wrapCol);

          if ('address' in venue && 'line1' in venue.address) {
            var addressline1 = $('<span/>').addClass('address-line1').text(venue.address.line1 + '.').appendTo($wrapCol);
            if ('line2' in venue.address) {
              var addressline2 = $('<span/>').addClass('address-line2').text(venue.address.line2).appendTo(addressline1);
            }
          }
        } else {
          console.log('no _embedded found');
        }

        if (item.id) {
          var buttonSetId = $("<button data-event=" + item.id + "/>").addClass('js_lazy-sel_btn btn btn-submit').text('Use this ID').appendTo(li).wrap('<div class ="wrapper-btns text-right"/>');
          if (venue.location && venue.location.latitude && venue.location.longitude) {
            //console.log('venue.location - ' , venue.location);
            var buttonMap = $("<button data-latitude=" + venue.location.latitude + " data-longitude=" + venue.location.longitude + "/>").addClass('js_open-map_btn btn btn-transparent').text('Show on map').insertAfter(buttonSetId)
            //.appendTo(buttonSetId)
            .wrap('<div class ="wrapper-location_btn pull-right"/>');
          }
          var addToEl = { li: li, buttonSetIdWrapper: buttonSetId.parent() };
          addMsButton(addToEl, item.id);
        }
      });
    }

    /**
     * render for attractions-id-selector
     * @param items - array
     */
    function renderListAttractions(items) {
      items.map(function (item) {

        var li = $('<li/>').addClass('list-group-item row').appendTo($ul);

        if (item.images) {
          var leftCol = $('<div class="clear-padding" />').appendTo(li);
          var spanImg = $('<span class="thumbnail" />').appendTo(leftCol);
          var img = $('<img src=' + getImageForEvent(item.images) + ' />').addClass('list-group-item-heading').appendTo(spanImg);
        }

        var $wrapCol = $('<div class="event-text-wrapper clear-margin-left"/>').appendTo(li);

        if (item.name) {
          var title = $('<h3/>').addClass('list-group-item-heading').text(item.name).appendTo($wrapCol);
        }

        /*add time*/
        if (item.dates) {
          var currentEvent = {};
          currentEvent.date = {
            day: item.dates.start.localDate,
            time: item.dates.start.localTime,
            dateTime: item.dates.start.dateTime
          };

          var time = formatDate(currentEvent.date);
          var eventTime = $('<h4 class="event-time gray"/>').text(time).appendTo($wrapCol);
        } /*add time end*/

        if (item.classifications) {
          if (item.classifications.length > 1) console.log(item.classifications.length);

          var _genre, _subgenre, _segment;
          if (item.classifications[0]) {
            _segment = item.classifications[0].segment;
            _genre = item.classifications[0].genre;
            _subgenre = item.classifications[0].subGenre;

            var segmentText = $('<h4/>').addClass('country-name gray').text(_segment && _segment.name && _segment.name !== 'Undefined' ? _segment.name : '').appendTo($wrapCol);

            var genre = $('<span/>').addClass('classifications-name').append(_genre && _genre.name && _genre.name !== 'Undefined' ? $('<span >' + _genre.name + '</>') : '').append(_subgenre && _subgenre.name && _subgenre.name !== 'Undefined' ? $('<span class="add-dot">' + _subgenre.name + '</>') : '').appendTo($wrapCol);
          }
        }
        if (item) {
          var venue = item; // item._embedded.venues[0];
          var contryStateName = $('<h4/>').addClass('country-name gray').text(venue.country && venue.country.name ? venue.country.name + '. ' : '').append(venue.state && venue.state.name ? venue.state.name + '. ' : '').appendTo($wrapCol);
          var cityName = $('<span/>').addClass('address-name').text(venue.city && venue.city.name ? venue.city.name + '. ' : '').appendTo($wrapCol);

          if ('address' in venue && 'line1' in venue.address) {
            var addressline1 = $('<span/>').addClass('address-line1').text(venue.address.line1 + '.').appendTo($wrapCol);
            if ('line2' in venue.address) {
              var addressline2 = $('<span/>').addClass('address-line2').text(venue.address.line2).appendTo(addressline1);
            }
          }
        } else {
          console.log('no _embedded found');
        }

        if (item.id) {
          var buttonSetId = $("<button data-event=" + item.id + "/>").addClass('js_lazy-sel_btn btn btn-submit').text('Use this ID').appendTo(li).wrap('<div class ="wrapper-btns text-right"/>');
          if (venue.location && venue.location.latitude && venue.location.longitude) {
            //console.log('venue.location - ' , venue.location);
            var buttonMap = $("<button style='float: right;' data-latitude=" + venue.location.latitude + " data-longitude=" + venue.location.longitude + "/>").addClass('js_open-map_btn btn btn-transparent').text('Show on map').insertAfter(buttonSetId)
            //.appendTo(buttonSetId)
            .wrap('<div class ="wrapper-location_btn"/>');
          }
          var addToEl = { li: li, buttonSetIdWrapper: buttonSetId.parent() };
          addMsButton(addToEl, item.id);
        }
      });
    }

    function hasScrollBar(element, wrapper) {
      return element.get(0).scrollHeight > element.parent().innerHeight();
    }

    var renderResults = function renderResults(data, ulElement) {
      var items;

      function showMessage(element, message, /*optional*/clearList) {
        $btnGET.attr('disabled', false);

        if (clearList) $('li', element).remove();
        element.css({ 'overflow': 'auto' });
        $('<li/>').addClass('list-group-item text-center').text(message).appendTo(ulElement);
      }

      if (stateConf.loadingFlag === "FINAL_PAGE") return false; //exit if has reached last page

      //show fail msg
      if (data === 'FAIL') {
        showMessage($ul, 'Failure, possible key not correct.', true);
        modalContent.removeClass('narrow');
        return false;
      }

      if (stateConf.loadingFlag === 'STOP_LOAD' && data.length !== 0) {
        stateConf.loadingFlag = "FINAL_PAGE";
        showMessage(ulElement, 'No more results.', false);
        $liFooter.hide();
        return false;
      }

      if (data === null || !data._embedded) {
        showMessage(ulElement, 'No results found.', true);
        modalContent.removeClass('narrow');
        return false;
      }

      //start render data
      if (selector === 'events') {
        items = data && data._embedded && data._embedded.events ? data._embedded.events : [''];
        renderListEvents(items);
      } else if (selector === 'venues') {
        items = data && data._embedded && data._embedded.venues ? data._embedded.venues : [''];
        renderListVenues(items);
      } else if (selector === 'attractions') {
        items = data && data._embedded && data._embedded.attractions ? data._embedded.attractions : [''];
        renderListAttractions(items);
      }

      //hide scroll if recive less then 2 items
      if (hasScrollBar($ul)) {
        $ul.removeClass('no-scroll');
      } else {
        $ul.addClass('no-scroll');
      }

      // hide/show horizontal line and button <load more>
      if (data && data.page && data.page.totalElements > 20) {
        $hr.show();
        $liFooter.show();
      } else {
        $hr.hide();
        $liFooter.hide();
      }

      // hide button <load more> if nothing left to load
      if (stateConf.loadingFlag === 'STOP_LOAD' || stateConf.pageIncrement + 1 === data.page.totalPages) {
        $hr.hide();
        $liFooter.hide();
      }
      if (data.page.totalElements > 0 || items.length > 0) {
        $hr.show();
      }

      //<show map> button
      $('.js_open-map_btn').on('click', mapListener);

      $('.js_lazy-sel_btn').on('click', setIdListener);

      $("#js_ls-modal").on("click", "ul li button.js_ms-add-list_btn", addMsButtonListener);

      //set availible <Get> button after load is finished
      $btnGET.attr('disabled', false);
    };

    function mapListener(e) {
      var screenWidth = Math.max(document.documentElement.clientWidth, window.innerWidth || 0);
      var isMobile = false; //initiate as false
      // device detection
      if (/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|ipad|iris|kindle|Android|Silk|lge |maemo|midp|mmp|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows (ce|phone)|xda|xiino/i.test(navigator.userAgent) || /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(navigator.userAgent.substr(0, 4))) isMobile = true;

      if (!isMobile || screenWidth >= 768) {
        mapPopUpListener(e);
        modalContent.addClass('narrow');
        btnCloseMap.show();
      } else if (isMobile) {
        var lat = $(e.target).attr('data-latitude') != "undefined" ? parseFloat($(e.target).attr('data-latitude')) : null,
            lng = $(e.target).attr('data-longitude') != "undefined" ? parseFloat($(e.target).attr('data-longitude')) : null;
        if (lat && lng) {
          location.href = 'geo:' + lng + ',' + lat;
        } else {
          location.href = 'geo:0,0';
        }
      }
    }

    function addMsButton(el, data) {
      if (options.hideMultiSelector) return false;

      //add button <ADD to list>
      var buttonAddIdToList = $("<button data-id=" + data + "/>").addClass('js_ms-add-list_btn pull-right btn btn btn-transparent').text('ADD to list').appendTo(el.li.find(el.buttonSetIdWrapper));
    }

    function setIdListener(e) {
      var selectedID = e.target.getAttribute('data-event');
      $input.val(selectedID).attr('value', selectedID).trigger('change'); //update widget:
      stateConf.setSingleVal = true;

      //clear tags box of current selector (that equal 'selectedID' val)
      config.forEach(function (el) {
        tagsIds[selectedID] = [];
      });
      // Close dialog
      $modal.modal('hide');
    }

    function setIdsListener(e) {
      if ($btnGET.attr('data-selector') !== $iconButton.attr('data-selector')) return false;
      var selectedID = tagsIds[selector];

      // set isable=true to all items in tags-list
      $('li', $msList).each(function () {
        $(this).attr('data-isable', true);
      });

      $input.val(selectedID).attr('value', selectedID).trigger('change'); //update widget:

      // Close dialog
      $modal.modal('hide');
    }

    function clearByArrVal(selectedID, indToRemove) {
      function mapAny(array) {
        array.map(function (item) {
          selectedID.splice(selectedID.indexOf(item), 1);
        });
      }

      if (selectedID.length >= indToRemove.length) {
        mapAny(indToRemove);
      } else {
        mapAny(selectedID);
      }
    }

    function delIdListener(event) {
      event.preventDefault();
      var me = $(this),
          tagID = me.parents('li').data('selector-' + selector),
          selectedID = tagsIds[selector];
      var indToRemove = [];

      me.parents('li').remove();
      indToRemove.push(tagID);
      clearByArrVal(selectedID, indToRemove);

      //update input values
      $input.val(selectedID).attr('value', selectedID).trigger('change'); //update widget:

      toggleMsSelectionBox();
    }

    function addMsButtonListener(event) {
      event.preventDefault();

      function isUnique(list) {
        var result = [],
            unique = false;

        $.each(list, function (i, e) {
          if ($.inArray(e, result) == -1) {
            result.push(e);
            unique = true;
          } else {
            unique = false;
          }
        });
        return unique;
      }

      var me = $(this),
          title = me.parents('li').find('.list-group-item-heading', '.event-text-wrapper').text(),
          uniqueUpcoming,
          currentList = tagsIds[selector];

      currentList.push(me.data('id'));
      uniqueUpcoming = isUnique(currentList); // Get list of upcoming tags

      if (uniqueUpcoming) {
        var item = $('<li/>').addClass('ms-elem-selection').text(title).attr('data-selector-' + selector, me.data('id')).attr('data-isable', false).appendTo($msList);
        $('<span/>').appendTo(item).on('click', item, delIdListener);
      } else {
        currentList.splice(currentList.length - 1, 1);
      }

      me.addClass('checked');
      toggleMsSelectionBox();
    }

    // EVENTS
    $btnGET.on('click', function (e) {
      e.preventDefault();
      if ($btnGET.attr('data-selector') !== $iconButton.attr('data-selector')) return false; //stop request

      modalContent.removeClass('narrow');
      var form = $form.get(0);
      if (!$btnGET.is(':disabled')) {
        if (form.checkValidity()) {
          $btnGET.attr('disabled', true);
          stateConf.pageIncrement = 0;
          stateConf.loadingFlag = 'KEEP_LOAD';
          loading('on'); //show loading-spinner
          resetForm(); //clear
          submitForm(stateConf.pageIncrement, true);
        } else {
          // Highlight errors
          if (form.reportValidity) form.reportValidity();
          $form.addClass(cssValidationClass);
        }
      }
    });

    $msBtnUse.on('click', setIdsListener);

    //Close Map button
    btnCloseMap.on('click', closeMapListener);

    $('#js_ls-more_btn', $liFooter).on('click', function (elm) {
      if ($btnGET.attr('data-selector') !== $iconButton.attr('data-selector')) return false;
      // eventUrl = 'https://app.ticketmaster.com/discovery/v2/' + $iconButton.attr('data-selector') + '.json';

      stateConf.pageIncrement++;
      $btnGET.attr('disabled', true);
      loading('on');
      submitForm(stateConf.pageIncrement);

      //Clear Listener, prevent memory leak
      $("#js_ls-modal").off("click", "ul li button.js_ms-add-list_btn", addMsButtonListener);
    });

    //multiple selector events

    $form.on("keyup", function (e) {
      var input = $(e.target);
      if (e.target.tagName === "INPUT") {
        if (e.keyCode == 13) {
          input.blur();

          modalContent.removeClass('narrow');
          if ($btnGET.attr('data-selector') !== $iconButton.attr('data-selector')) return false;

          if ($form.get(0).checkValidity()) {
            stateConf.pageIncrement = 0;
            stateConf.loadingFlag = 'KEEP_LOAD';
            loading('on');
            resetForm();
            submitForm(stateConf.pageIncrement);
          }
        }
      }
      return false;
    });

    // Mobile devices. Force 'change' by 'Go' press
    $form.on("submit", function (e) {
      e.preventDefault();
    });

    $modal.on('shown.bs.modal', function () {
      //save default value to variable for 'events' selector only
      if (typeof $input.val() !== 'undefined' && $iconButton.attr('data-selector') === 'events') initialVal['events'] = $input.val();
    }).on('hidden.bs.modal', function (e) {
      var indToRemove = [],
          selectorBtn = $btnGET.attr('data-selector'),
          tagsArr = tagsIds[selectorBtn];
      resetForm();
      closeMapListener();

      $('li', $msList).each(function (i) {
        if ($(this).data('isable') === false) {
          indToRemove.push($(this).data('selector-' + selectorBtn));
          $(this).remove();
        }
      });

      clearByArrVal(tagsArr, indToRemove);

      //clear tags if set Single ID
      if (selector === selectorBtn && !stateConf.setSingleVal) {
        stateConf.setSingleVal = false;
      }
      keyword.val(''); //clear search input
    });

    return this.each(function () {
      init($(this));

      function init(input) {
        input.wrap('<div class="lazy-selector-wrapper"></div>');
        input.after($iconButton);
        $iconButton.attr('data-selector', selector);

        $('#get-event-by-Id-' + options.selector + '').on('click', changeModalTextListener);
        tagsIds[selector] = [];
      }
    });
  };
})(jQuery);

/**
 * add lazy selector to widgets
 */
$(document).on('ready', function () {
  $('.js_lazy-selector').lazySelector({ selector: '', hideMultiSelector: true });
  $('.js_lazy-selector-attractions').lazySelector({ selector: 'attractions' });
  $('.js_lazy-selector-venues').lazySelector({ selector: 'venues' });
});

/**
 * add lazy selector to api-explorer v1 (made by V.Menshutin)
 */
$(document).on("finishInit", function (event, flag) {
  $('#venueId').lazySelector({ selector: 'venues' });
  $('#attractionId').lazySelector({ selector: 'attractions' });
});
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1), __webpack_require__(1)))

/***/ }),
/* 51 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(jQuery) {

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

/*!
 * Bootstrap v3.3.6 (http://getbootstrap.com)
 * Copyright 2011-2015 Twitter, Inc.
 * Licensed under the MIT license
 */
if ("undefined" == typeof jQuery) throw new Error("Bootstrap's JavaScript requires jQuery");+function (a) {
  "use strict";
  var b = a.fn.jquery.split(" ")[0].split(".");if (b[0] < 2 && b[1] < 9 || 1 == b[0] && 9 == b[1] && b[2] < 1 || b[0] > 2) throw new Error("Bootstrap's JavaScript requires jQuery version 1.9.1 or higher, but lower than version 3");
}(jQuery), +function (a) {
  "use strict";
  function b() {
    var a = document.createElement("bootstrap"),
        b = { WebkitTransition: "webkitTransitionEnd", MozTransition: "transitionend", OTransition: "oTransitionEnd otransitionend", transition: "transitionend" };for (var c in b) {
      if (void 0 !== a.style[c]) return { end: b[c] };
    }return !1;
  }a.fn.emulateTransitionEnd = function (b) {
    var c = !1,
        d = this;a(this).one("bsTransitionEnd", function () {
      c = !0;
    });var e = function e() {
      c || a(d).trigger(a.support.transition.end);
    };return setTimeout(e, b), this;
  }, a(function () {
    a.support.transition = b(), a.support.transition && (a.event.special.bsTransitionEnd = { bindType: a.support.transition.end, delegateType: a.support.transition.end, handle: function handle(b) {
        return a(b.target).is(this) ? b.handleObj.handler.apply(this, arguments) : void 0;
      } });
  });
}(jQuery), +function (a) {
  "use strict";
  function b(b) {
    return this.each(function () {
      var c = a(this),
          e = c.data("bs.alert");e || c.data("bs.alert", e = new d(this)), "string" == typeof b && e[b].call(c);
    });
  }var c = '[data-dismiss="alert"]',
      d = function d(b) {
    a(b).on("click", c, this.close);
  };d.VERSION = "3.3.6", d.TRANSITION_DURATION = 150, d.prototype.close = function (b) {
    function c() {
      g.detach().trigger("closed.bs.alert").remove();
    }var e = a(this),
        f = e.attr("data-target");f || (f = e.attr("href"), f = f && f.replace(/.*(?=#[^\s]*$)/, ""));var g = a(f);b && b.preventDefault(), g.length || (g = e.closest(".alert")), g.trigger(b = a.Event("close.bs.alert")), b.isDefaultPrevented() || (g.removeClass("in"), a.support.transition && g.hasClass("fade") ? g.one("bsTransitionEnd", c).emulateTransitionEnd(d.TRANSITION_DURATION) : c());
  };var e = a.fn.alert;a.fn.alert = b, a.fn.alert.Constructor = d, a.fn.alert.noConflict = function () {
    return a.fn.alert = e, this;
  }, a(document).on("click.bs.alert.data-api", c, d.prototype.close);
}(jQuery), +function (a) {
  "use strict";
  function b(b) {
    return this.each(function () {
      var d = a(this),
          e = d.data("bs.button"),
          f = "object" == (typeof b === "undefined" ? "undefined" : _typeof(b)) && b;e || d.data("bs.button", e = new c(this, f)), "toggle" == b ? e.toggle() : b && e.setState(b);
    });
  }var c = function c(b, d) {
    this.$element = a(b), this.options = a.extend({}, c.DEFAULTS, d), this.isLoading = !1;
  };c.VERSION = "3.3.6", c.DEFAULTS = { loadingText: "loading..." }, c.prototype.setState = function (b) {
    var c = "disabled",
        d = this.$element,
        e = d.is("input") ? "val" : "html",
        f = d.data();b += "Text", null == f.resetText && d.data("resetText", d[e]()), setTimeout(a.proxy(function () {
      d[e](null == f[b] ? this.options[b] : f[b]), "loadingText" == b ? (this.isLoading = !0, d.addClass(c).attr(c, c)) : this.isLoading && (this.isLoading = !1, d.removeClass(c).removeAttr(c));
    }, this), 0);
  }, c.prototype.toggle = function () {
    var a = !0,
        b = this.$element.closest('[data-toggle="buttons"]');if (b.length) {
      var c = this.$element.find("input");"radio" == c.prop("type") ? (c.prop("checked") && (a = !1), b.find(".active").removeClass("active"), this.$element.addClass("active")) : "checkbox" == c.prop("type") && (c.prop("checked") !== this.$element.hasClass("active") && (a = !1), this.$element.toggleClass("active")), c.prop("checked", this.$element.hasClass("active")), a && c.trigger("change");
    } else this.$element.attr("aria-pressed", !this.$element.hasClass("active")), this.$element.toggleClass("active");
  };var d = a.fn.button;a.fn.button = b, a.fn.button.Constructor = c, a.fn.button.noConflict = function () {
    return a.fn.button = d, this;
  }, a(document).on("click.bs.button.data-api", '[data-toggle^="button"]', function (c) {
    var d = a(c.target);d.hasClass("btn") || (d = d.closest(".btn")), b.call(d, "toggle"), a(c.target).is('input[type="radio"]') || a(c.target).is('input[type="checkbox"]') || c.preventDefault();
  }).on("focus.bs.button.data-api blur.bs.button.data-api", '[data-toggle^="button"]', function (b) {
    a(b.target).closest(".btn").toggleClass("focus", /^focus(in)?$/.test(b.type));
  });
}(jQuery), +function (a) {
  "use strict";
  function b(b) {
    return this.each(function () {
      var d = a(this),
          e = d.data("bs.carousel"),
          f = a.extend({}, c.DEFAULTS, d.data(), "object" == (typeof b === "undefined" ? "undefined" : _typeof(b)) && b),
          g = "string" == typeof b ? b : f.slide;e || d.data("bs.carousel", e = new c(this, f)), "number" == typeof b ? e.to(b) : g ? e[g]() : f.interval && e.pause().cycle();
    });
  }var c = function c(b, _c) {
    this.$element = a(b), this.$indicators = this.$element.find(".carousel-indicators"), this.options = _c, this.paused = null, this.sliding = null, this.interval = null, this.$active = null, this.$items = null, this.options.keyboard && this.$element.on("keydown.bs.carousel", a.proxy(this.keydown, this)), "hover" == this.options.pause && !("ontouchstart" in document.documentElement) && this.$element.on("mouseenter.bs.carousel", a.proxy(this.pause, this)).on("mouseleave.bs.carousel", a.proxy(this.cycle, this));
  };c.VERSION = "3.3.6", c.TRANSITION_DURATION = 600, c.DEFAULTS = { interval: 5e3, pause: "hover", wrap: !0, keyboard: !0 }, c.prototype.keydown = function (a) {
    if (!/input|textarea/i.test(a.target.tagName)) {
      switch (a.which) {case 37:
          this.prev();break;case 39:
          this.next();break;default:
          return;}a.preventDefault();
    }
  }, c.prototype.cycle = function (b) {
    return b || (this.paused = !1), this.interval && clearInterval(this.interval), this.options.interval && !this.paused && (this.interval = setInterval(a.proxy(this.next, this), this.options.interval)), this;
  }, c.prototype.getItemIndex = function (a) {
    return this.$items = a.parent().children(".item"), this.$items.index(a || this.$active);
  }, c.prototype.getItemForDirection = function (a, b) {
    var c = this.getItemIndex(b),
        d = "prev" == a && 0 === c || "next" == a && c == this.$items.length - 1;if (d && !this.options.wrap) return b;var e = "prev" == a ? -1 : 1,
        f = (c + e) % this.$items.length;return this.$items.eq(f);
  }, c.prototype.to = function (a) {
    var b = this,
        c = this.getItemIndex(this.$active = this.$element.find(".item.active"));return a > this.$items.length - 1 || 0 > a ? void 0 : this.sliding ? this.$element.one("slid.bs.carousel", function () {
      b.to(a);
    }) : c == a ? this.pause().cycle() : this.slide(a > c ? "next" : "prev", this.$items.eq(a));
  }, c.prototype.pause = function (b) {
    return b || (this.paused = !0), this.$element.find(".next, .prev").length && a.support.transition && (this.$element.trigger(a.support.transition.end), this.cycle(!0)), this.interval = clearInterval(this.interval), this;
  }, c.prototype.next = function () {
    return this.sliding ? void 0 : this.slide("next");
  }, c.prototype.prev = function () {
    return this.sliding ? void 0 : this.slide("prev");
  }, c.prototype.slide = function (b, d) {
    var e = this.$element.find(".item.active"),
        f = d || this.getItemForDirection(b, e),
        g = this.interval,
        h = "next" == b ? "left" : "right",
        i = this;if (f.hasClass("active")) return this.sliding = !1;var j = f[0],
        k = a.Event("slide.bs.carousel", { relatedTarget: j, direction: h });if (this.$element.trigger(k), !k.isDefaultPrevented()) {
      if (this.sliding = !0, g && this.pause(), this.$indicators.length) {
        this.$indicators.find(".active").removeClass("active");var l = a(this.$indicators.children()[this.getItemIndex(f)]);l && l.addClass("active");
      }var m = a.Event("slid.bs.carousel", { relatedTarget: j, direction: h });return a.support.transition && this.$element.hasClass("slide") ? (f.addClass(b), f[0].offsetWidth, e.addClass(h), f.addClass(h), e.one("bsTransitionEnd", function () {
        f.removeClass([b, h].join(" ")).addClass("active"), e.removeClass(["active", h].join(" ")), i.sliding = !1, setTimeout(function () {
          i.$element.trigger(m);
        }, 0);
      }).emulateTransitionEnd(c.TRANSITION_DURATION)) : (e.removeClass("active"), f.addClass("active"), this.sliding = !1, this.$element.trigger(m)), g && this.cycle(), this;
    }
  };var d = a.fn.carousel;a.fn.carousel = b, a.fn.carousel.Constructor = c, a.fn.carousel.noConflict = function () {
    return a.fn.carousel = d, this;
  };var e = function e(c) {
    var d,
        e = a(this),
        f = a(e.attr("data-target") || (d = e.attr("href")) && d.replace(/.*(?=#[^\s]+$)/, ""));if (f.hasClass("carousel")) {
      var g = a.extend({}, f.data(), e.data()),
          h = e.attr("data-slide-to");h && (g.interval = !1), b.call(f, g), h && f.data("bs.carousel").to(h), c.preventDefault();
    }
  };a(document).on("click.bs.carousel.data-api", "[data-slide]", e).on("click.bs.carousel.data-api", "[data-slide-to]", e), a(window).on("load", function () {
    a('[data-ride="carousel"]').each(function () {
      var c = a(this);b.call(c, c.data());
    });
  });
}(jQuery), +function (a) {
  "use strict";
  function b(b) {
    var c,
        d = b.attr("data-target") || (c = b.attr("href")) && c.replace(/.*(?=#[^\s]+$)/, "");return a(d);
  }function c(b) {
    return this.each(function () {
      var c = a(this),
          e = c.data("bs.collapse"),
          f = a.extend({}, d.DEFAULTS, c.data(), "object" == (typeof b === "undefined" ? "undefined" : _typeof(b)) && b);!e && f.toggle && /show|hide/.test(b) && (f.toggle = !1), e || c.data("bs.collapse", e = new d(this, f)), "string" == typeof b && e[b]();
    });
  }var d = function d(b, c) {
    this.$element = a(b), this.options = a.extend({}, d.DEFAULTS, c), this.$trigger = a('[data-toggle="collapse"][href="#' + b.id + '"],[data-toggle="collapse"][data-target="#' + b.id + '"]'), this.transitioning = null, this.options.parent ? this.$parent = this.getParent() : this.addAriaAndCollapsedClass(this.$element, this.$trigger), this.options.toggle && this.toggle();
  };d.VERSION = "3.3.6", d.TRANSITION_DURATION = 350, d.DEFAULTS = { toggle: !0 }, d.prototype.dimension = function () {
    var a = this.$element.hasClass("width");return a ? "width" : "height";
  }, d.prototype.show = function () {
    if (!this.transitioning && !this.$element.hasClass("in")) {
      var b,
          e = this.$parent && this.$parent.children(".panel").children(".in, .collapsing");if (!(e && e.length && (b = e.data("bs.collapse"), b && b.transitioning))) {
        var f = a.Event("show.bs.collapse");if (this.$element.trigger(f), !f.isDefaultPrevented()) {
          e && e.length && (c.call(e, "hide"), b || e.data("bs.collapse", null));var g = this.dimension();this.$element.removeClass("collapse").addClass("collapsing")[g](0).attr("aria-expanded", !0), this.$trigger.removeClass("collapsed").attr("aria-expanded", !0), this.transitioning = 1;var h = function h() {
            this.$element.removeClass("collapsing").addClass("collapse in")[g](""), this.transitioning = 0, this.$element.trigger("shown.bs.collapse");
          };if (!a.support.transition) return h.call(this);var i = a.camelCase(["scroll", g].join("-"));this.$element.one("bsTransitionEnd", a.proxy(h, this)).emulateTransitionEnd(d.TRANSITION_DURATION)[g](this.$element[0][i]);
        }
      }
    }
  }, d.prototype.hide = function () {
    if (!this.transitioning && this.$element.hasClass("in")) {
      var b = a.Event("hide.bs.collapse");if (this.$element.trigger(b), !b.isDefaultPrevented()) {
        var c = this.dimension();this.$element[c](this.$element[c]())[0].offsetHeight, this.$element.addClass("collapsing").removeClass("collapse in").attr("aria-expanded", !1), this.$trigger.addClass("collapsed").attr("aria-expanded", !1), this.transitioning = 1;var e = function e() {
          this.transitioning = 0, this.$element.removeClass("collapsing").addClass("collapse").trigger("hidden.bs.collapse");
        };return a.support.transition ? void this.$element[c](0).one("bsTransitionEnd", a.proxy(e, this)).emulateTransitionEnd(d.TRANSITION_DURATION) : e.call(this);
      }
    }
  }, d.prototype.toggle = function () {
    this[this.$element.hasClass("in") ? "hide" : "show"]();
  }, d.prototype.getParent = function () {
    return a(this.options.parent).find('[data-toggle="collapse"][data-parent="' + this.options.parent + '"]').each(a.proxy(function (c, d) {
      var e = a(d);this.addAriaAndCollapsedClass(b(e), e);
    }, this)).end();
  }, d.prototype.addAriaAndCollapsedClass = function (a, b) {
    var c = a.hasClass("in");a.attr("aria-expanded", c), b.toggleClass("collapsed", !c).attr("aria-expanded", c);
  };var e = a.fn.collapse;a.fn.collapse = c, a.fn.collapse.Constructor = d, a.fn.collapse.noConflict = function () {
    return a.fn.collapse = e, this;
  }, a(document).on("click.bs.collapse.data-api", '[data-toggle="collapse"]', function (d) {
    var e = a(this);e.attr("data-target") || d.preventDefault();var f = b(e),
        g = f.data("bs.collapse"),
        h = g ? "toggle" : e.data();c.call(f, h);
  });
}(jQuery), +function (a) {
  "use strict";
  function b(b) {
    var c = b.attr("data-target");c || (c = b.attr("href"), c = c && /#[A-Za-z]/.test(c) && c.replace(/.*(?=#[^\s]*$)/, ""));var d = c && a(c);return d && d.length ? d : b.parent();
  }function c(c) {
    c && 3 === c.which || (a(e).remove(), a(f).each(function () {
      var d = a(this),
          e = b(d),
          f = { relatedTarget: this };e.hasClass("open") && (c && "click" == c.type && /input|textarea/i.test(c.target.tagName) && a.contains(e[0], c.target) || (e.trigger(c = a.Event("hide.bs.dropdown", f)), c.isDefaultPrevented() || (d.attr("aria-expanded", "false"), e.removeClass("open").trigger(a.Event("hidden.bs.dropdown", f)))));
    }));
  }function d(b) {
    return this.each(function () {
      var c = a(this),
          d = c.data("bs.dropdown");d || c.data("bs.dropdown", d = new g(this)), "string" == typeof b && d[b].call(c);
    });
  }var e = ".dropdown-backdrop",
      f = '[data-toggle="dropdown"]',
      g = function g(b) {
    a(b).on("click.bs.dropdown", this.toggle);
  };g.VERSION = "3.3.6", g.prototype.toggle = function (d) {
    var e = a(this);if (!e.is(".disabled, :disabled")) {
      var f = b(e),
          g = f.hasClass("open");if (c(), !g) {
        "ontouchstart" in document.documentElement && !f.closest(".navbar-nav").length && a(document.createElement("div")).addClass("dropdown-backdrop").insertAfter(a(this)).on("click", c);var h = { relatedTarget: this };if (f.trigger(d = a.Event("show.bs.dropdown", h)), d.isDefaultPrevented()) return;e.trigger("focus").attr("aria-expanded", "true"), f.toggleClass("open").trigger(a.Event("shown.bs.dropdown", h));
      }return !1;
    }
  }, g.prototype.keydown = function (c) {
    if (/(38|40|27|32)/.test(c.which) && !/input|textarea/i.test(c.target.tagName)) {
      var d = a(this);if (c.preventDefault(), c.stopPropagation(), !d.is(".disabled, :disabled")) {
        var e = b(d),
            g = e.hasClass("open");if (!g && 27 != c.which || g && 27 == c.which) return 27 == c.which && e.find(f).trigger("focus"), d.trigger("click");var h = " li:not(.disabled):visible a",
            i = e.find(".dropdown-menu" + h);if (i.length) {
          var j = i.index(c.target);38 == c.which && j > 0 && j--, 40 == c.which && j < i.length - 1 && j++, ~j || (j = 0), i.eq(j).trigger("focus");
        }
      }
    }
  };var h = a.fn.dropdown;a.fn.dropdown = d, a.fn.dropdown.Constructor = g, a.fn.dropdown.noConflict = function () {
    return a.fn.dropdown = h, this;
  }, a(document).on("click.bs.dropdown.data-api", c).on("click.bs.dropdown.data-api", ".dropdown form", function (a) {
    a.stopPropagation();
  }).on("click.bs.dropdown.data-api", f, g.prototype.toggle).on("keydown.bs.dropdown.data-api", f, g.prototype.keydown).on("keydown.bs.dropdown.data-api", ".dropdown-menu", g.prototype.keydown);
}(jQuery), +function (a) {
  "use strict";
  function b(b, d) {
    return this.each(function () {
      var e = a(this),
          f = e.data("bs.modal"),
          g = a.extend({}, c.DEFAULTS, e.data(), "object" == (typeof b === "undefined" ? "undefined" : _typeof(b)) && b);f || e.data("bs.modal", f = new c(this, g)), "string" == typeof b ? f[b](d) : g.show && f.show(d);
    });
  }var c = function c(b, _c2) {
    this.options = _c2, this.$body = a(document.body), this.$element = a(b), this.$dialog = this.$element.find(".modal-dialog"), this.$backdrop = null, this.isShown = null, this.originalBodyPad = null, this.scrollbarWidth = 0, this.ignoreBackdropClick = !1, this.options.remote && this.$element.find(".modal-content").load(this.options.remote, a.proxy(function () {
      this.$element.trigger("loaded.bs.modal");
    }, this));
  };c.VERSION = "3.3.6", c.TRANSITION_DURATION = 300, c.BACKDROP_TRANSITION_DURATION = 150, c.DEFAULTS = { backdrop: !0, keyboard: !0, show: !0 }, c.prototype.toggle = function (a) {
    return this.isShown ? this.hide() : this.show(a);
  }, c.prototype.show = function (b) {
    var d = this,
        e = a.Event("show.bs.modal", { relatedTarget: b });this.$element.trigger(e), this.isShown || e.isDefaultPrevented() || (this.isShown = !0, this.checkScrollbar(), this.setScrollbar(), this.$body.addClass("modal-open"), this.escape(), this.resize(), this.$element.on("click.dismiss.bs.modal", '[data-dismiss="modal"]', a.proxy(this.hide, this)), this.$dialog.on("mousedown.dismiss.bs.modal", function () {
      d.$element.one("mouseup.dismiss.bs.modal", function (b) {
        a(b.target).is(d.$element) && (d.ignoreBackdropClick = !0);
      });
    }), this.backdrop(function () {
      var e = a.support.transition && d.$element.hasClass("fade");d.$element.parent().length || d.$element.appendTo(d.$body), d.$element.show().scrollTop(0), d.adjustDialog(), e && d.$element[0].offsetWidth, d.$element.addClass("in"), d.enforceFocus();var f = a.Event("shown.bs.modal", { relatedTarget: b });e ? d.$dialog.one("bsTransitionEnd", function () {
        d.$element.trigger("focus").trigger(f);
      }).emulateTransitionEnd(c.TRANSITION_DURATION) : d.$element.trigger("focus").trigger(f);
    }));
  }, c.prototype.hide = function (b) {
    b && b.preventDefault(), b = a.Event("hide.bs.modal"), this.$element.trigger(b), this.isShown && !b.isDefaultPrevented() && (this.isShown = !1, this.escape(), this.resize(), a(document).off("focusin.bs.modal"), this.$element.removeClass("in").off("click.dismiss.bs.modal").off("mouseup.dismiss.bs.modal"), this.$dialog.off("mousedown.dismiss.bs.modal"), a.support.transition && this.$element.hasClass("fade") ? this.$element.one("bsTransitionEnd", a.proxy(this.hideModal, this)).emulateTransitionEnd(c.TRANSITION_DURATION) : this.hideModal());
  }, c.prototype.enforceFocus = function () {
    a(document).off("focusin.bs.modal").on("focusin.bs.modal", a.proxy(function (a) {
      this.$element[0] === a.target || this.$element.has(a.target).length || this.$element.trigger("focus");
    }, this));
  }, c.prototype.escape = function () {
    this.isShown && this.options.keyboard ? this.$element.on("keydown.dismiss.bs.modal", a.proxy(function (a) {
      27 == a.which && this.hide();
    }, this)) : this.isShown || this.$element.off("keydown.dismiss.bs.modal");
  }, c.prototype.resize = function () {
    this.isShown ? a(window).on("resize.bs.modal", a.proxy(this.handleUpdate, this)) : a(window).off("resize.bs.modal");
  }, c.prototype.hideModal = function () {
    var a = this;this.$element.hide(), this.backdrop(function () {
      a.$body.removeClass("modal-open"), a.resetAdjustments(), a.resetScrollbar(), a.$element.trigger("hidden.bs.modal");
    });
  }, c.prototype.removeBackdrop = function () {
    this.$backdrop && this.$backdrop.remove(), this.$backdrop = null;
  }, c.prototype.backdrop = function (b) {
    var d = this,
        e = this.$element.hasClass("fade") ? "fade" : "";if (this.isShown && this.options.backdrop) {
      var f = a.support.transition && e;if (this.$backdrop = a(document.createElement("div")).addClass("modal-backdrop " + e).appendTo(this.$body), this.$element.on("click.dismiss.bs.modal", a.proxy(function (a) {
        return this.ignoreBackdropClick ? void (this.ignoreBackdropClick = !1) : void (a.target === a.currentTarget && ("static" == this.options.backdrop ? this.$element[0].focus() : this.hide()));
      }, this)), f && this.$backdrop[0].offsetWidth, this.$backdrop.addClass("in"), !b) return;f ? this.$backdrop.one("bsTransitionEnd", b).emulateTransitionEnd(c.BACKDROP_TRANSITION_DURATION) : b();
    } else if (!this.isShown && this.$backdrop) {
      this.$backdrop.removeClass("in");var g = function g() {
        d.removeBackdrop(), b && b();
      };a.support.transition && this.$element.hasClass("fade") ? this.$backdrop.one("bsTransitionEnd", g).emulateTransitionEnd(c.BACKDROP_TRANSITION_DURATION) : g();
    } else b && b();
  }, c.prototype.handleUpdate = function () {
    this.adjustDialog();
  }, c.prototype.adjustDialog = function () {
    var a = this.$element[0].scrollHeight > document.documentElement.clientHeight;this.$element.css({ paddingLeft: !this.bodyIsOverflowing && a ? this.scrollbarWidth : "", paddingRight: this.bodyIsOverflowing && !a ? this.scrollbarWidth : "" });
  }, c.prototype.resetAdjustments = function () {
    this.$element.css({ paddingLeft: "", paddingRight: "" });
  }, c.prototype.checkScrollbar = function () {
    var a = window.innerWidth;if (!a) {
      var b = document.documentElement.getBoundingClientRect();a = b.right - Math.abs(b.left);
    }this.bodyIsOverflowing = document.body.clientWidth < a, this.scrollbarWidth = this.measureScrollbar();
  }, c.prototype.setScrollbar = function () {
    var a = parseInt(this.$body.css("padding-right") || 0, 10);this.originalBodyPad = document.body.style.paddingRight || "", this.bodyIsOverflowing && this.$body.css("padding-right", a + this.scrollbarWidth);
  }, c.prototype.resetScrollbar = function () {
    this.$body.css("padding-right", this.originalBodyPad);
  }, c.prototype.measureScrollbar = function () {
    var a = document.createElement("div");a.className = "modal-scrollbar-measure", this.$body.append(a);var b = a.offsetWidth - a.clientWidth;return this.$body[0].removeChild(a), b;
  };var d = a.fn.modal;a.fn.modal = b, a.fn.modal.Constructor = c, a.fn.modal.noConflict = function () {
    return a.fn.modal = d, this;
  }, a(document).on("click.bs.modal.data-api", '[data-toggle="modal"]', function (c) {
    var d = a(this),
        e = d.attr("href"),
        f = a(d.attr("data-target") || e && e.replace(/.*(?=#[^\s]+$)/, "")),
        g = f.data("bs.modal") ? "toggle" : a.extend({ remote: !/#/.test(e) && e }, f.data(), d.data());d.is("a") && c.preventDefault(), f.one("show.bs.modal", function (a) {
      a.isDefaultPrevented() || f.one("hidden.bs.modal", function () {
        d.is(":visible") && d.trigger("focus");
      });
    }), b.call(f, g, this);
  });
}(jQuery), +function (a) {
  "use strict";
  function b(b) {
    return this.each(function () {
      var d = a(this),
          e = d.data("bs.tooltip"),
          f = "object" == (typeof b === "undefined" ? "undefined" : _typeof(b)) && b;(e || !/destroy|hide/.test(b)) && (e || d.data("bs.tooltip", e = new c(this, f)), "string" == typeof b && e[b]());
    });
  }var c = function c(a, b) {
    this.type = null, this.options = null, this.enabled = null, this.timeout = null, this.hoverState = null, this.$element = null, this.inState = null, this.init("tooltip", a, b);
  };c.VERSION = "3.3.6", c.TRANSITION_DURATION = 150, c.DEFAULTS = { animation: !0, placement: "top", selector: !1, template: '<div class="tooltip" role="tooltip"><div class="tooltip-arrow"></div><div class="tooltip-inner"></div></div>', trigger: "hover focus", title: "", delay: 0, html: !1, container: !1, viewport: { selector: "body", padding: 0 } }, c.prototype.init = function (b, c, d) {
    if (this.enabled = !0, this.type = b, this.$element = a(c), this.options = this.getOptions(d), this.$viewport = this.options.viewport && a(a.isFunction(this.options.viewport) ? this.options.viewport.call(this, this.$element) : this.options.viewport.selector || this.options.viewport), this.inState = { click: !1, hover: !1, focus: !1 }, this.$element[0] instanceof document.constructor && !this.options.selector) throw new Error("`selector` option must be specified when initializing " + this.type + " on the window.document object!");for (var e = this.options.trigger.split(" "), f = e.length; f--;) {
      var g = e[f];if ("click" == g) this.$element.on("click." + this.type, this.options.selector, a.proxy(this.toggle, this));else if ("manual" != g) {
        var h = "hover" == g ? "mouseenter" : "focusin",
            i = "hover" == g ? "mouseleave" : "focusout";this.$element.on(h + "." + this.type, this.options.selector, a.proxy(this.enter, this)), this.$element.on(i + "." + this.type, this.options.selector, a.proxy(this.leave, this));
      }
    }this.options.selector ? this._options = a.extend({}, this.options, { trigger: "manual", selector: "" }) : this.fixTitle();
  }, c.prototype.getDefaults = function () {
    return c.DEFAULTS;
  }, c.prototype.getOptions = function (b) {
    return b = a.extend({}, this.getDefaults(), this.$element.data(), b), b.delay && "number" == typeof b.delay && (b.delay = { show: b.delay, hide: b.delay }), b;
  }, c.prototype.getDelegateOptions = function () {
    var b = {},
        c = this.getDefaults();return this._options && a.each(this._options, function (a, d) {
      c[a] != d && (b[a] = d);
    }), b;
  }, c.prototype.enter = function (b) {
    var c = b instanceof this.constructor ? b : a(b.currentTarget).data("bs." + this.type);return c || (c = new this.constructor(b.currentTarget, this.getDelegateOptions()), a(b.currentTarget).data("bs." + this.type, c)), b instanceof a.Event && (c.inState["focusin" == b.type ? "focus" : "hover"] = !0), c.tip().hasClass("in") || "in" == c.hoverState ? void (c.hoverState = "in") : (clearTimeout(c.timeout), c.hoverState = "in", c.options.delay && c.options.delay.show ? void (c.timeout = setTimeout(function () {
      "in" == c.hoverState && c.show();
    }, c.options.delay.show)) : c.show());
  }, c.prototype.isInStateTrue = function () {
    for (var a in this.inState) {
      if (this.inState[a]) return !0;
    }return !1;
  }, c.prototype.leave = function (b) {
    var c = b instanceof this.constructor ? b : a(b.currentTarget).data("bs." + this.type);return c || (c = new this.constructor(b.currentTarget, this.getDelegateOptions()), a(b.currentTarget).data("bs." + this.type, c)), b instanceof a.Event && (c.inState["focusout" == b.type ? "focus" : "hover"] = !1), c.isInStateTrue() ? void 0 : (clearTimeout(c.timeout), c.hoverState = "out", c.options.delay && c.options.delay.hide ? void (c.timeout = setTimeout(function () {
      "out" == c.hoverState && c.hide();
    }, c.options.delay.hide)) : c.hide());
  }, c.prototype.show = function () {
    var b = a.Event("show.bs." + this.type);if (this.hasContent() && this.enabled) {
      this.$element.trigger(b);var d = a.contains(this.$element[0].ownerDocument.documentElement, this.$element[0]);if (b.isDefaultPrevented() || !d) return;var e = this,
          f = this.tip(),
          g = this.getUID(this.type);this.setContent(), f.attr("id", g), this.$element.attr("aria-describedby", g), this.options.animation && f.addClass("fade");var h = "function" == typeof this.options.placement ? this.options.placement.call(this, f[0], this.$element[0]) : this.options.placement,
          i = /\s?auto?\s?/i,
          j = i.test(h);j && (h = h.replace(i, "") || "top"), f.detach().css({ top: 0, left: 0, display: "block" }).addClass(h).data("bs." + this.type, this), this.options.container ? f.appendTo(this.options.container) : f.insertAfter(this.$element), this.$element.trigger("inserted.bs." + this.type);var k = this.getPosition(),
          l = f[0].offsetWidth,
          m = f[0].offsetHeight;if (j) {
        var n = h,
            o = this.getPosition(this.$viewport);h = "bottom" == h && k.bottom + m > o.bottom ? "top" : "top" == h && k.top - m < o.top ? "bottom" : "right" == h && k.right + l > o.width ? "left" : "left" == h && k.left - l < o.left ? "right" : h, f.removeClass(n).addClass(h);
      }var p = this.getCalculatedOffset(h, k, l, m);this.applyPlacement(p, h);var q = function q() {
        var a = e.hoverState;e.$element.trigger("shown.bs." + e.type), e.hoverState = null, "out" == a && e.leave(e);
      };a.support.transition && this.$tip.hasClass("fade") ? f.one("bsTransitionEnd", q).emulateTransitionEnd(c.TRANSITION_DURATION) : q();
    }
  }, c.prototype.applyPlacement = function (b, c) {
    var d = this.tip(),
        e = d[0].offsetWidth,
        f = d[0].offsetHeight,
        g = parseInt(d.css("margin-top"), 10),
        h = parseInt(d.css("margin-left"), 10);isNaN(g) && (g = 0), isNaN(h) && (h = 0), b.top += g, b.left += h, a.offset.setOffset(d[0], a.extend({ using: function using(a) {
        d.css({ top: Math.round(a.top), left: Math.round(a.left) });
      } }, b), 0), d.addClass("in");var i = d[0].offsetWidth,
        j = d[0].offsetHeight;"top" == c && j != f && (b.top = b.top + f - j);var k = this.getViewportAdjustedDelta(c, b, i, j);k.left ? b.left += k.left : b.top += k.top;var l = /top|bottom/.test(c),
        m = l ? 2 * k.left - e + i : 2 * k.top - f + j,
        n = l ? "offsetWidth" : "offsetHeight";d.offset(b), this.replaceArrow(m, d[0][n], l);
  }, c.prototype.replaceArrow = function (a, b, c) {
    this.arrow().css(c ? "left" : "top", 50 * (1 - a / b) + "%").css(c ? "top" : "left", "");
  }, c.prototype.setContent = function () {
    var a = this.tip(),
        b = this.getTitle();a.find(".tooltip-inner")[this.options.html ? "html" : "text"](b), a.removeClass("fade in top bottom left right");
  }, c.prototype.hide = function (b) {
    function d() {
      "in" != e.hoverState && f.detach(), e.$element.removeAttr("aria-describedby").trigger("hidden.bs." + e.type), b && b();
    }var e = this,
        f = a(this.$tip),
        g = a.Event("hide.bs." + this.type);return this.$element.trigger(g), g.isDefaultPrevented() ? void 0 : (f.removeClass("in"), a.support.transition && f.hasClass("fade") ? f.one("bsTransitionEnd", d).emulateTransitionEnd(c.TRANSITION_DURATION) : d(), this.hoverState = null, this);
  }, c.prototype.fixTitle = function () {
    var a = this.$element;(a.attr("title") || "string" != typeof a.attr("data-original-title")) && a.attr("data-original-title", a.attr("title") || "").attr("title", "");
  }, c.prototype.hasContent = function () {
    return this.getTitle();
  }, c.prototype.getPosition = function (b) {
    b = b || this.$element;var c = b[0],
        d = "BODY" == c.tagName,
        e = c.getBoundingClientRect();null == e.width && (e = a.extend({}, e, { width: e.right - e.left, height: e.bottom - e.top }));var f = d ? { top: 0, left: 0 } : b.offset(),
        g = { scroll: d ? document.documentElement.scrollTop || document.body.scrollTop : b.scrollTop() },
        h = d ? { width: a(window).width(), height: a(window).height() } : null;return a.extend({}, e, g, h, f);
  }, c.prototype.getCalculatedOffset = function (a, b, c, d) {
    return "bottom" == a ? { top: b.top + b.height, left: b.left + b.width / 2 - c / 2 } : "top" == a ? { top: b.top - d, left: b.left + b.width / 2 - c / 2 } : "left" == a ? { top: b.top + b.height / 2 - d / 2, left: b.left - c } : { top: b.top + b.height / 2 - d / 2, left: b.left + b.width };
  }, c.prototype.getViewportAdjustedDelta = function (a, b, c, d) {
    var e = { top: 0, left: 0 };if (!this.$viewport) return e;var f = this.options.viewport && this.options.viewport.padding || 0,
        g = this.getPosition(this.$viewport);if (/right|left/.test(a)) {
      var h = b.top - f - g.scroll,
          i = b.top + f - g.scroll + d;h < g.top ? e.top = g.top - h : i > g.top + g.height && (e.top = g.top + g.height - i);
    } else {
      var j = b.left - f,
          k = b.left + f + c;j < g.left ? e.left = g.left - j : k > g.right && (e.left = g.left + g.width - k);
    }return e;
  }, c.prototype.getTitle = function () {
    var a,
        b = this.$element,
        c = this.options;return a = b.attr("data-original-title") || ("function" == typeof c.title ? c.title.call(b[0]) : c.title);
  }, c.prototype.getUID = function (a) {
    do {
      a += ~~(1e6 * Math.random());
    } while (document.getElementById(a));return a;
  }, c.prototype.tip = function () {
    if (!this.$tip && (this.$tip = a(this.options.template), 1 != this.$tip.length)) throw new Error(this.type + " `template` option must consist of exactly 1 top-level element!");return this.$tip;
  }, c.prototype.arrow = function () {
    return this.$arrow = this.$arrow || this.tip().find(".tooltip-arrow");
  }, c.prototype.enable = function () {
    this.enabled = !0;
  }, c.prototype.disable = function () {
    this.enabled = !1;
  }, c.prototype.toggleEnabled = function () {
    this.enabled = !this.enabled;
  }, c.prototype.toggle = function (b) {
    var c = this;b && (c = a(b.currentTarget).data("bs." + this.type), c || (c = new this.constructor(b.currentTarget, this.getDelegateOptions()), a(b.currentTarget).data("bs." + this.type, c))), b ? (c.inState.click = !c.inState.click, c.isInStateTrue() ? c.enter(c) : c.leave(c)) : c.tip().hasClass("in") ? c.leave(c) : c.enter(c);
  }, c.prototype.destroy = function () {
    var a = this;clearTimeout(this.timeout), this.hide(function () {
      a.$element.off("." + a.type).removeData("bs." + a.type), a.$tip && a.$tip.detach(), a.$tip = null, a.$arrow = null, a.$viewport = null;
    });
  };var d = a.fn.tooltip;a.fn.tooltip = b, a.fn.tooltip.Constructor = c, a.fn.tooltip.noConflict = function () {
    return a.fn.tooltip = d, this;
  };
}(jQuery), +function (a) {
  "use strict";
  function b(b) {
    return this.each(function () {
      var d = a(this),
          e = d.data("bs.popover"),
          f = "object" == (typeof b === "undefined" ? "undefined" : _typeof(b)) && b;(e || !/destroy|hide/.test(b)) && (e || d.data("bs.popover", e = new c(this, f)), "string" == typeof b && e[b]());
    });
  }var c = function c(a, b) {
    this.init("popover", a, b);
  };if (!a.fn.tooltip) throw new Error("Popover requires tooltip.js");c.VERSION = "3.3.6", c.DEFAULTS = a.extend({}, a.fn.tooltip.Constructor.DEFAULTS, { placement: "right", trigger: "click", content: "", template: '<div class="popover" role="tooltip"><div class="arrow"></div><h3 class="popover-title"></h3><div class="popover-content"></div></div>' }), c.prototype = a.extend({}, a.fn.tooltip.Constructor.prototype), c.prototype.constructor = c, c.prototype.getDefaults = function () {
    return c.DEFAULTS;
  }, c.prototype.setContent = function () {
    var a = this.tip(),
        b = this.getTitle(),
        c = this.getContent();a.find(".popover-title")[this.options.html ? "html" : "text"](b), a.find(".popover-content").children().detach().end()[this.options.html ? "string" == typeof c ? "html" : "append" : "text"](c), a.removeClass("fade top bottom left right in"), a.find(".popover-title").html() || a.find(".popover-title").hide();
  }, c.prototype.hasContent = function () {
    return this.getTitle() || this.getContent();
  }, c.prototype.getContent = function () {
    var a = this.$element,
        b = this.options;return a.attr("data-content") || ("function" == typeof b.content ? b.content.call(a[0]) : b.content);
  }, c.prototype.arrow = function () {
    return this.$arrow = this.$arrow || this.tip().find(".arrow");
  };var d = a.fn.popover;a.fn.popover = b, a.fn.popover.Constructor = c, a.fn.popover.noConflict = function () {
    return a.fn.popover = d, this;
  };
}(jQuery), +function (a) {
  "use strict";
  function b(c, d) {
    this.$body = a(document.body), this.$scrollElement = a(a(c).is(document.body) ? window : c), this.options = a.extend({}, b.DEFAULTS, d), this.selector = (this.options.target || "") + " .nav li > a", this.offsets = [], this.targets = [], this.activeTarget = null, this.scrollHeight = 0, this.$scrollElement.on("scroll.bs.scrollspy", a.proxy(this.process, this)), this.refresh(), this.process();
  }function c(c) {
    return this.each(function () {
      var d = a(this),
          e = d.data("bs.scrollspy"),
          f = "object" == (typeof c === "undefined" ? "undefined" : _typeof(c)) && c;e || d.data("bs.scrollspy", e = new b(this, f)), "string" == typeof c && e[c]();
    });
  }b.VERSION = "3.3.6", b.DEFAULTS = { offset: 10 }, b.prototype.getScrollHeight = function () {
    return this.$scrollElement[0].scrollHeight || Math.max(this.$body[0].scrollHeight, document.documentElement.scrollHeight);
  }, b.prototype.refresh = function () {
    var b = this,
        c = "offset",
        d = 0;this.offsets = [], this.targets = [], this.scrollHeight = this.getScrollHeight(), a.isWindow(this.$scrollElement[0]) || (c = "position", d = this.$scrollElement.scrollTop()), this.$body.find(this.selector).map(function () {
      var b = a(this),
          e = b.data("target") || b.attr("href"),
          f = /^#./.test(e) && a(e);return f && f.length && f.is(":visible") && [[f[c]().top + d, e]] || null;
    }).sort(function (a, b) {
      return a[0] - b[0];
    }).each(function () {
      b.offsets.push(this[0]), b.targets.push(this[1]);
    });
  }, b.prototype.process = function () {
    var a,
        b = this.$scrollElement.scrollTop() + this.options.offset,
        c = this.getScrollHeight(),
        d = this.options.offset + c - this.$scrollElement.height(),
        e = this.offsets,
        f = this.targets,
        g = this.activeTarget;if (this.scrollHeight != c && this.refresh(), b >= d) return g != (a = f[f.length - 1]) && this.activate(a);if (g && b < e[0]) return this.activeTarget = null, this.clear();for (a = e.length; a--;) {
      g != f[a] && b >= e[a] && (void 0 === e[a + 1] || b < e[a + 1]) && this.activate(f[a]);
    }
  }, b.prototype.activate = function (b) {
    this.activeTarget = b, this.clear();var c = this.selector + '[data-target="' + b + '"],' + this.selector + '[href="' + b + '"]',
        d = a(c).parents("li").addClass("active");
    d.parent(".dropdown-menu").length && (d = d.closest("li.dropdown").addClass("active")), d.trigger("activate.bs.scrollspy");
  }, b.prototype.clear = function () {
    a(this.selector).parentsUntil(this.options.target, ".active").removeClass("active");
  };var d = a.fn.scrollspy;a.fn.scrollspy = c, a.fn.scrollspy.Constructor = b, a.fn.scrollspy.noConflict = function () {
    return a.fn.scrollspy = d, this;
  }, a(window).on("load.bs.scrollspy.data-api", function () {
    a('[data-spy="scroll"]').each(function () {
      var b = a(this);c.call(b, b.data());
    });
  });
}(jQuery), +function (a) {
  "use strict";
  function b(b) {
    return this.each(function () {
      var d = a(this),
          e = d.data("bs.tab");e || d.data("bs.tab", e = new c(this)), "string" == typeof b && e[b]();
    });
  }var c = function c(b) {
    this.element = a(b);
  };c.VERSION = "3.3.6", c.TRANSITION_DURATION = 150, c.prototype.show = function () {
    var b = this.element,
        c = b.closest("ul:not(.dropdown-menu)"),
        d = b.data("target");if (d || (d = b.attr("href"), d = d && d.replace(/.*(?=#[^\s]*$)/, "")), !b.parent("li").hasClass("active")) {
      var e = c.find(".active:last a"),
          f = a.Event("hide.bs.tab", { relatedTarget: b[0] }),
          g = a.Event("show.bs.tab", { relatedTarget: e[0] });if (e.trigger(f), b.trigger(g), !g.isDefaultPrevented() && !f.isDefaultPrevented()) {
        var h = a(d);this.activate(b.closest("li"), c), this.activate(h, h.parent(), function () {
          e.trigger({ type: "hidden.bs.tab", relatedTarget: b[0] }), b.trigger({ type: "shown.bs.tab", relatedTarget: e[0] });
        });
      }
    }
  }, c.prototype.activate = function (b, d, e) {
    function f() {
      g.removeClass("active").find("> .dropdown-menu > .active").removeClass("active").end().find('[data-toggle="tab"]').attr("aria-expanded", !1), b.addClass("active").find('[data-toggle="tab"]').attr("aria-expanded", !0), h ? (b[0].offsetWidth, b.addClass("in")) : b.removeClass("fade"), b.parent(".dropdown-menu").length && b.closest("li.dropdown").addClass("active").end().find('[data-toggle="tab"]').attr("aria-expanded", !0), e && e();
    }var g = d.find("> .active"),
        h = e && a.support.transition && (g.length && g.hasClass("fade") || !!d.find("> .fade").length);g.length && h ? g.one("bsTransitionEnd", f).emulateTransitionEnd(c.TRANSITION_DURATION) : f(), g.removeClass("in");
  };var d = a.fn.tab;a.fn.tab = b, a.fn.tab.Constructor = c, a.fn.tab.noConflict = function () {
    return a.fn.tab = d, this;
  };var e = function e(c) {
    c.preventDefault(), b.call(a(this), "show");
  };a(document).on("click.bs.tab.data-api", '[data-toggle="tab"]', e).on("click.bs.tab.data-api", '[data-toggle="pill"]', e);
}(jQuery), +function (a) {
  "use strict";
  function b(b) {
    return this.each(function () {
      var d = a(this),
          e = d.data("bs.affix"),
          f = "object" == (typeof b === "undefined" ? "undefined" : _typeof(b)) && b;e || d.data("bs.affix", e = new c(this, f)), "string" == typeof b && e[b]();
    });
  }var c = function c(b, d) {
    this.options = a.extend({}, c.DEFAULTS, d), this.$target = a(this.options.target).on("scroll.bs.affix.data-api", a.proxy(this.checkPosition, this)).on("click.bs.affix.data-api", a.proxy(this.checkPositionWithEventLoop, this)), this.$element = a(b), this.affixed = null, this.unpin = null, this.pinnedOffset = null, this.checkPosition();
  };c.VERSION = "3.3.6", c.RESET = "affix affix-top affix-bottom", c.DEFAULTS = { offset: 0, target: window }, c.prototype.getState = function (a, b, c, d) {
    var e = this.$target.scrollTop(),
        f = this.$element.offset(),
        g = this.$target.height();if (null != c && "top" == this.affixed) return c > e ? "top" : !1;if ("bottom" == this.affixed) return null != c ? e + this.unpin <= f.top ? !1 : "bottom" : a - d >= e + g ? !1 : "bottom";var h = null == this.affixed,
        i = h ? e : f.top,
        j = h ? g : b;return null != c && c >= e ? "top" : null != d && i + j >= a - d ? "bottom" : !1;
  }, c.prototype.getPinnedOffset = function () {
    if (this.pinnedOffset) return this.pinnedOffset;this.$element.removeClass(c.RESET).addClass("affix");var a = this.$target.scrollTop(),
        b = this.$element.offset();return this.pinnedOffset = b.top - a;
  }, c.prototype.checkPositionWithEventLoop = function () {
    setTimeout(a.proxy(this.checkPosition, this), 1);
  }, c.prototype.checkPosition = function () {
    if (this.$element.is(":visible")) {
      var b = this.$element.height(),
          d = this.options.offset,
          e = d.top,
          f = d.bottom,
          g = Math.max(a(document).height(), a(document.body).height());"object" != (typeof d === "undefined" ? "undefined" : _typeof(d)) && (f = e = d), "function" == typeof e && (e = d.top(this.$element)), "function" == typeof f && (f = d.bottom(this.$element));var h = this.getState(g, b, e, f);if (this.affixed != h) {
        null != this.unpin && this.$element.css("top", "");var i = "affix" + (h ? "-" + h : ""),
            j = a.Event(i + ".bs.affix");if (this.$element.trigger(j), j.isDefaultPrevented()) return;this.affixed = h, this.unpin = "bottom" == h ? this.getPinnedOffset() : null, this.$element.removeClass(c.RESET).addClass(i).trigger(i.replace("affix", "affixed") + ".bs.affix");
      }"bottom" == h && this.$element.offset({ top: g - b - f });
    }
  };var d = a.fn.affix;a.fn.affix = b, a.fn.affix.Constructor = c, a.fn.affix.noConflict = function () {
    return a.fn.affix = d, this;
  }, a(window).on("load", function () {
    a('[data-spy="affix"]').each(function () {
      var c = a(this),
          d = c.data();d.offset = d.offset || {}, null != d.offsetBottom && (d.offset.bottom = d.offsetBottom), null != d.offsetTop && (d.offset.top = d.offsetTop), b.call(c, d);
    });
  });
}(jQuery);
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ }),
/* 52 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/*!
* Clamp.js 0.5.1
*
* Copyright 2011-2013, Joseph Schmitt http://joe.sh
* Released under the WTFPL license
* http://sam.zoy.org/wtfpl/
*/
(function () {
  window.$clamp = function (c, d) {
    function s(a, b) {
      n.getComputedStyle || (n.getComputedStyle = function (a, b) {
        this.el = a;this.getPropertyValue = function (b) {
          var c = /(\-([a-z]){1})/g;"float" == b && (b = "styleFloat");c.test(b) && (b = b.replace(c, function (a, b, c) {
            return c.toUpperCase();
          }));return a.currentStyle && a.currentStyle[b] ? a.currentStyle[b] : null;
        };return this;
      });return n.getComputedStyle(a, null).getPropertyValue(b);
    }function t(a) {
      a = a || c.clientHeight;var b = u(c);return Math.max(Math.floor(a / b), 0);
    }function x(a) {
      return u(c) * a;
    }function u(a) {
      var b = s(a, "line-height");"normal" == b && (b = 1.2 * parseInt(s(a, "font-size")));return parseInt(b);
    }function l(a) {
      if (a.lastChild.children && 0 < a.lastChild.children.length) return l(Array.prototype.slice.call(a.children).pop());if (a.lastChild && a.lastChild.nodeValue && "" != a.lastChild.nodeValue && a.lastChild.nodeValue != b.truncationChar) return a.lastChild;a.lastChild.parentNode.removeChild(a.lastChild);return l(c);
    }function p(a, d) {
      if (d) {
        var e = a.nodeValue.replace(b.truncationChar, "");f || (h = 0 < k.length ? k.shift() : "", f = e.split(h));1 < f.length ? (q = f.pop(), r(a, f.join(h))) : f = null;m && (a.nodeValue = a.nodeValue.replace(b.truncationChar, ""), c.innerHTML = a.nodeValue + " " + m.innerHTML + b.truncationChar);if (f) {
          if (c.clientHeight <= d) if (0 <= k.length && "" != h) r(a, f.join(h) + h + q), f = null;else return c.innerHTML;
        } else "" == h && (r(a, ""), a = l(c), k = b.splitOnChars.slice(0), h = k[0], q = f = null);if (b.animate) setTimeout(function () {
          p(a, d);
        }, !0 === b.animate ? 10 : b.animate);else return p(a, d);
      }
    }function r(a, c) {
      a.nodeValue = c + b.truncationChar;
    }d = d || {};
    var n = window,
        b = { clamp: d.clamp || 2, useNativeClamp: "undefined" != typeof d.useNativeClamp ? d.useNativeClamp : !0, splitOnChars: d.splitOnChars || [".", "-", "\u2013", "\u2014", " "], animate: d.animate || !1, truncationChar: d.truncationChar || "\u2026", truncationHTML: d.truncationHTML },
        e = c.style,
        y = c.innerHTML,
        z = "undefined" != typeof c.style.webkitLineClamp,
        g = b.clamp,
        v = g.indexOf && (-1 < g.indexOf("px") || -1 < g.indexOf("em")),
        m;b.truncationHTML && (m = document.createElement("span"), m.innerHTML = b.truncationHTML);var k = b.splitOnChars.slice(0),
        h = k[0],
        f,
        q;"auto" == g ? g = t() : v && (g = t(parseInt(g)));var w;z && b.useNativeClamp ? (e.overflow = "hidden", e.textOverflow = "ellipsis", e.webkitBoxOrient = "vertical", e.display = "-webkit-box", e.webkitLineClamp = g, v && (e.height = b.clamp + "px")) : (e = x(g), e <= c.clientHeight && (w = p(l(c), e)));return { original: y, clamped: w };
  };
})();

/***/ }),
/* 53 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


//Javasript name: My Date Time Picker
//Date created: 16-Nov-2003 23:19
//Creator: TengYong Ng
//Website: http://www.rainforestnet.com
//Copyright (c) 2003 TengYong Ng
//FileName: DateTimePicker_css.js
//Version: 2.2.4
// Note: Permission given to use and modify this script in ANY kind of applications if
//       header lines are left unchanged.
//Permission is granted to redistribute and modify this javascript under a FreeBSD License.
//New Css style version added by Yvan Lavoie (Québec, Canada) 29-Jan-2009
//Formatted for JSLint compatibility by Labsmedia.com (30-Dec-2010)


//Global variables

window.winCal = undefined;
window.dtToday = undefined;
window.Cal = undefined;
window.exDateTime = undefined; //Existing Date and Time
window.selDate = undefined; //selected date. version 1.7
window.calSpanID = "calBorder"; // span ID
window.domStyle = null; // span DOM object with style
window.cnLeft = "0"; //left coordinate of calendar span
window.cnTop = "0"; //top coordinate of calendar span
window.xpos = 0; // mouse x position
window.ypos = 0; // mouse y position
window.calHeight = 0; // calendar height
window.CalWidth = "auto"; // calendar width
window.CellWidth = 36; // width of day cell.
window.TimeMode = 24; // TimeMode value. 12 or 24
window.StartYear = parseInt(new Date().getFullYear()); //First Year in drop down year selection
window.EndYear = 5; // The last year of pickable date. if current year is 2011, the last year that still picker will be 2016 (2011+5)
window.CalPosOffsetX = -227; //X position offset relative to calendar icon, can be negative value
window.CalPosOffsetY = -230; //Y position offset relative to calendar icon, can be negative value
window.showMonthInHead = "display:none;";
//Configurable parameters start
window.SpanBorderColor = "#cccccc"; //span border color
window.SpanBgColor = "#FFFFFF"; //span background color
window.MonthYearColor = "#cc0033"; //Font Color of Month and Year in Calendar header.
window.WeekHeadColor = "#b7c9d3"; //var WeekHeadColor="#18861B";//Background Color in Week header.
window.WeekHeadBackground = "#ffffff"; //var WeekHeadColor="#18861B";//Background Color in Week header.
window.SundayColor = ""; //var SundayColor="#C0F64F";//Background color of Sunday.
window.SaturdayColor = ""; //Background color of Saturday.
window.WeekDayColor = ""; //Background color of weekdays.
window.FontColor = "blue"; //color of font in Calendar day cell.
window.TodayColor = 'font-family:"TMSans-Bold",Helvetica,Arial,sans-serif;box-shadow:0 0 2px rgba(0,0,0,1);';
window.SelDateColor = 'font-family:"TMSans-Bold",Helvetica,Arial,sans-serif;color:#fff;background:#179cdb;';
window.YrSelColor = "#cc0033"; //color of font of Year selector.
window.MthSelColor = "#cc0033"; //color of font of Month selector if "MonthSelector" is "arrow".
window.HoverColor = "#E0FF38"; //color when mouse move over.
window.DisableColor = "#999966"; //color of disabled cell.
window.CalBgColor = "#ffffff"; //Background color of Calendar window.
window.topSelectorBg = "#f1f4f6";

window.WeekChar = 2; //number of character for week day. if 2 then Mo,Tu,We. if 3 then Mon,Tue,Wed.
window.DateSeparator = "-"; //Date Separator, you can change it to "-" if you want.
window.ShowLongMonth = true; //Show long month name in Calendar header. example: "January".
window.ShowMonthYear = true; //Show Month and Year in Calendar header.
window.ThemeBg = ""; //Background image of Calendar window.
window.PrecedeZero = true; //Preceding zero [true|false]
window.MondayFirstDay = false; //true:Use Monday as first day; false:Sunday as first day. [true|false]  //added in version 1.7
window.UseImageFiles = false; //Use image files with "arrows" and "close" button
window.imageFilesPath = "images2/";
//Configurable parameters end

//use the Month and Weekday in your preferred language.
window.MonthName = ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"];
window.WeekDayName1 = ["S", "M", "T", "W", "T", "F", "S"];
window.WeekDayName2 = ["Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday"];

//end Configurable parameters

//end Global variable

// Calendar prototype
function Calendar(pDate, pCtrl) {
	//Properties
	this.Date = pDate.getDate(); //selected date
	this.Month = pDate.getMonth(); //selected month number
	this.Year = pDate.getFullYear(); //selected year in 4 digits
	this.Hours = pDate.getHours();

	if (pDate.getMinutes() < 10) {
		this.Minutes = "0" + pDate.getMinutes();
	} else {
		this.Minutes = pDate.getMinutes();
	}

	if (pDate.getSeconds() < 10) {
		this.Seconds = "0" + pDate.getSeconds();
	} else {
		this.Seconds = pDate.getSeconds();
	}

	this.MyWindow = winCal;
	this.Ctrl = pCtrl;
	this.Format = "ddMMyyyy";
	this.Separator = DateSeparator;
	this.ShowTime = false;
	this.Scroller = "DROPDOWN";

	if (pDate.getHours() < 12) {
		this.AMorPM = "AM";
	} else {
		this.AMorPM = "PM";
	}

	this.ShowSeconds = false;
	this.EnableDateMode = "";
}

Calendar.prototype.GetMonthIndex = function (shortMonthName) {
	for (var i = 0; i < 12; i += 1) {
		if (MonthName[i].substring(0, 3).toUpperCase() === shortMonthName.toUpperCase()) {
			return i;
		}
	}
};

Calendar.prototype.IncYear = function () {
	if (Cal.Year <= dtToday.getFullYear() + EndYear) Cal.Year += 1;
};

Calendar.prototype.DecYear = function () {
	if (Cal.Year > StartYear) Cal.Year -= 1;
};

Calendar.prototype.IncMonth = function () {
	if (Cal.Year <= dtToday.getFullYear() + EndYear) {
		Cal.Month += 1;
		if (Cal.Month >= 12) {
			Cal.Month = 0;
			Cal.IncYear();
		}
	}
};

Calendar.prototype.DecMonth = function () {
	if (Cal.Year >= StartYear) {
		Cal.Month -= 1;
		if (Cal.Month < 0) {
			Cal.Month = 11;
			Cal.DecYear();
		}
	}
};

Calendar.prototype.SwitchMth = function (intMth) {
	Cal.Month = parseInt(intMth, 10);
};

Calendar.prototype.SwitchYear = function (intYear) {
	Cal.Year = parseInt(intYear, 10);
};

Calendar.prototype.SetHour = function (intHour) {
	var MaxHour,
	    MinHour,
	    HourExp = new RegExp("^\\d\\d"),
	    SingleDigit = new RegExp("^\\d{1}$");

	if (TimeMode === 24) {
		MaxHour = 23;
		MinHour = 0;
	} else if (TimeMode === 12) {
		MaxHour = 12;
		MinHour = 1;
	} else {
		alert("TimeMode can only be 12 or 24");
	}

	if ((HourExp.test(intHour) || SingleDigit.test(intHour)) && parseInt(intHour, 10) > MaxHour) {
		intHour = MinHour;
	} else if ((HourExp.test(intHour) || SingleDigit.test(intHour)) && parseInt(intHour, 10) < MinHour) {
		intHour = MaxHour;
	}

	intHour = parseInt(intHour, 10);
	if (SingleDigit.test(intHour)) {
		intHour = "0" + intHour;
	}

	if (HourExp.test(intHour) && parseInt(intHour, 10) <= MaxHour && parseInt(intHour, 10) >= MinHour) {
		if (TimeMode === 12 && Cal.AMorPM === "PM") {
			if (parseInt(intHour, 10) === 12) {
				Cal.Hours = 12;
			} else {
				Cal.Hours = parseInt(intHour, 10) + 12;
			}
		} else if (TimeMode === 12 && Cal.AMorPM === "AM") {
			if (intHour === 12) {
				intHour -= 12;
			}

			Cal.Hours = parseInt(intHour, 10);
		} else if (TimeMode === 24) {
			Cal.Hours = parseInt(intHour, 10);
		}
	}
};

Calendar.prototype.SetMinute = function (intMin) {
	var MaxMin = 59,
	    MinMin = 0,
	    SingleDigit = new RegExp("\\d"),
	    SingleDigit2 = new RegExp("^\\d{1}$"),
	    MinExp = new RegExp("^\\d{2}$"),
	    strMin = 0;

	if ((MinExp.test(intMin) || SingleDigit.test(intMin)) && parseInt(intMin, 10) > MaxMin) {
		intMin = MinMin;
	} else if ((MinExp.test(intMin) || SingleDigit.test(intMin)) && parseInt(intMin, 10) < MinMin) {
		intMin = MaxMin;
	}

	strMin = intMin + "";
	if (SingleDigit2.test(intMin)) {
		strMin = "0" + strMin;
	}

	if ((MinExp.test(intMin) || SingleDigit.test(intMin)) && parseInt(intMin, 10) <= 59 && parseInt(intMin, 10) >= 0) {
		Cal.Minutes = strMin;
	}
};

Calendar.prototype.SetSecond = function (intSec) {
	var MaxSec = 59,
	    MinSec = 0,
	    SingleDigit = new RegExp("\\d"),
	    SingleDigit2 = new RegExp("^\\d{1}$"),
	    SecExp = new RegExp("^\\d{2}$"),
	    strSec = 0;

	if ((SecExp.test(intSec) || SingleDigit.test(intSec)) && parseInt(intSec, 10) > MaxSec) {
		intSec = MinSec;
	} else if ((SecExp.test(intSec) || SingleDigit.test(intSec)) && parseInt(intSec, 10) < MinSec) {
		intSec = MaxSec;
	}

	strSec = intSec + "";
	if (SingleDigit2.test(intSec)) {
		strSec = "0" + strSec;
	}

	if ((SecExp.test(intSec) || SingleDigit.test(intSec)) && parseInt(intSec, 10) <= 59 && parseInt(intSec, 10) >= 0) {
		Cal.Seconds = strSec;
	}
};

Calendar.prototype.SetAmPm = function (pvalue) {
	this.AMorPM = pvalue;
	if (pvalue === "PM") {
		this.Hours = parseInt(this.Hours, 10) + 12;
		if (this.Hours === 24) {
			this.Hours = 12;
		}
	} else if (pvalue === "AM") {
		this.Hours -= 12;
	}
};

Calendar.prototype.getShowHour = function () {
	var finalHour;

	if (TimeMode === 12) {
		if (parseInt(this.Hours, 10) === 0) {
			this.AMorPM = "AM";
			finalHour = parseInt(this.Hours, 10) + 12;
		} else if (parseInt(this.Hours, 10) === 12) {
			this.AMorPM = "PM";
			finalHour = 12;
		} else if (this.Hours > 12) {
			this.AMorPM = "PM";
			if (this.Hours - 12 < 10) {
				finalHour = "0" + (parseInt(this.Hours, 10) - 12);
			} else {
				finalHour = parseInt(this.Hours, 10) - 12;
			}
		} else {
			this.AMorPM = "AM";
			if (this.Hours < 10) {
				finalHour = "0" + parseInt(this.Hours, 10);
			} else {
				finalHour = this.Hours;
			}
		}
	} else if (TimeMode === 24) {
		if (this.Hours < 10) {
			finalHour = "0" + parseInt(this.Hours, 10);
		} else {
			finalHour = this.Hours;
		}
	}

	return finalHour;
};

Calendar.prototype.getShowAMorPM = function () {
	return this.AMorPM;
};

Calendar.prototype.GetMonthName = function (IsLong) {
	var Month = MonthName[this.Month];
	if (IsLong) {
		return Month;
	} else {
		return Month.substr(0, 3);
	}
};

Calendar.prototype.GetMonDays = function () {
	//Get number of days in a month

	var DaysInMonth = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
	if (Cal.IsLeapYear()) {
		DaysInMonth[1] = 29;
	}

	return DaysInMonth[this.Month];
};

Calendar.prototype.IsLeapYear = function () {
	if (this.Year % 4 === 0) {
		if (this.Year % 100 === 0 && this.Year % 400 !== 0) {
			return false;
		} else {
			return true;
		}
	} else {
		return false;
	}
};

Calendar.prototype.FormatDate = function (pDate) {
	var MonthDigit = this.Month + 1;
	if (PrecedeZero === true) {
		if (pDate < 10 && String(pDate).length === 1) //length checking added in version 2.2
			{
				pDate = "0" + pDate;
			}
		if (MonthDigit < 10) {
			MonthDigit = "0" + MonthDigit;
		}
	}

	switch (this.Format.toUpperCase()) {
		case "DDMMYYYY":
			return pDate + DateSeparator + MonthDigit + DateSeparator + this.Year;
		case "DDMMMYYYY":
			return pDate + DateSeparator + this.GetMonthName(false) + DateSeparator + this.Year;
		case "MMDDYYYY":
			return MonthDigit + DateSeparator + pDate + DateSeparator + this.Year;
		case "MMMDDYYYY":
			return this.GetMonthName(false) + DateSeparator + pDate + DateSeparator + this.Year;
		case "YYYYMMDD":
			return this.Year + DateSeparator + MonthDigit + DateSeparator + pDate;
		case "YYMMDD":
			return String(this.Year).substring(2, 4) + DateSeparator + MonthDigit + DateSeparator + pDate;
		case "YYMMMDD":
			return String(this.Year).substring(2, 4) + DateSeparator + this.GetMonthName(false) + DateSeparator + pDate;
		case "YYYYMMMDD":
			return this.Year + DateSeparator + this.GetMonthName(false) + DateSeparator + pDate;
		default:
			return pDate + DateSeparator + (this.Month + 1) + DateSeparator + this.Year;
	}
};

// end Calendar prototype

function GenCell(pValue, pHighLight, pColor, pClickable) {
	//Generate table cell with value
	var PValue, PCellStr, PClickable, vTimeStr;

	if (!pValue) {
		PValue = "";
	} else {
		PValue = pValue;
	}

	if (pColor === undefined) pColor = CalBgColor;

	if (pClickable !== undefined) {
		PClickable = pClickable;
	} else {
		PClickable = true;
	}

	if (Cal.ShowTime) {
		vTimeStr = ' ' + Cal.Hours + ':' + Cal.Minutes;
		if (Cal.ShowSeconds) {
			vTimeStr += ':' + Cal.Seconds;
		}
		if (TimeMode === 12) {
			vTimeStr += ' ' + Cal.AMorPM;
		}
	} else {
		vTimeStr = "";
	}

	if (PValue !== "") {
		if (PClickable === true) {
			if (Cal.ShowTime === true) {
				PCellStr = "<td id='c" + PValue + "' class='calTD' style='text-align:center;cursor:pointer;" + pColor + "' onmousedown='selectDate(this," + PValue + ");'>" + PValue + "</td>";
			} else {
				PCellStr = "<td class='calTD' style='text-align:center;cursor:pointer;background-color:" + pColor + "' onmouseover='changeBorder(this, 0);' onmouseout=\"changeBorder(this, 1, '" + pColor + "');\" onClick=\"javascript:callback('" + Cal.Ctrl + "','" + Cal.FormatDate(PValue) + "');\">" + PValue + "</td>";
			}
		} else {
			PCellStr = "<td style='text-align:center;background-color:" + pColor + "' class='calTD'>" + PValue + "</td>";
		}
	} else {
		PCellStr = "<td style='text-align:center;background-color:" + pColor + "' class='calTD'>&nbsp;</td>";
	}

	return PCellStr;
}

function RenderCssCal(bNewCal) {
	if (typeof bNewCal === "undefined" || bNewCal !== true) {
		bNewCal = false;
	}
	var vCalHeader,
	    vCalData,
	    vCalTime = "",
	    vCalClosing = "",
	    winCalData = "",
	    CalDate,
	    i,
	    j,
	    SelectStr,
	    vDayCount = 0,
	    vFirstDay,
	    WeekDayName = [],
	    //Added version 1.7
	strCell,
	    showHour,
	    ShowArrows = false,
	    HourCellWidth = "35px",
	    //cell width with seconds.

	SelectAm,
	    SelectPm,
	    funcCalback,
	    headID,
	    e,
	    cssStr,
	    style,
	    cssText,
	    span;

	calHeight = 0; // reset the window height on refresh

	// Set the default cursor for the calendar

	winCalData = "<span style='cursor:auto;'>";
	vCalHeader = "<table style='background-color:" + CalBgColor + ";width:auto;padding:0;border:none;'><tbody>";

	//Table for Month & Year Selector

	vCalHeader += "<tr><td colspan='7'><table border='0' width='100%' cellpadding='0' cellspacing='0' style='border:none;padding:5px;'><tr>";
	//******************Month and Year selector in dropdown list************************

	if (Cal.Scroller === "DROPDOWN") {
		vCalHeader += "<td align='left' style='padding:10px 5px 10px 10px;margin:0;background:" + topSelectorBg + "'>\n";
		vCalHeader += "<select name='MonthSelector' id='MonthSelectorSelect' style='margin-bottom:5px; display: none;' onChange='javascript:Cal.SwitchMth(this.selectedIndex);RenderCssCal();'>";
		for (i = 0; i < 12; i += 1) {
			if (i === Cal.Month) {
				SelectStr = "Selected";
			} else {
				SelectStr = "";
			}
			vCalHeader += "<option " + SelectStr + " value=" + i + ">" + MonthName[i] + "</option>";
		}
		vCalHeader += '</select>';

		/* ul month for custom select */
		vCalHeader += '<span class="MonthSelectorTitle">' + MonthName[Cal.Month] + '</span>';
		vCalHeader += '<ul name="MonthSelector" class="MonthSelector" onChange="javascript:Cal.SwitchMth(this.selectedIndex);RenderCssCal();">';
		for (i = 0; i < 12; i += 1) {
			if (i === Cal.Month) {
				SelectStr = "Selected";
			} else {
				SelectStr = "";
			}
			vCalHeader += '<li>' + MonthName[i] + '</li>';
		}
		vCalHeader += "</ul>";
		vCalHeader += "</td>";
		//Year selector

		vCalHeader += "<td align='right' style='padding:10px 10px 10px 5px;margin:0;background:" + topSelectorBg + "'>";
		vCalHeader += "<select name='YearSelector' style='display:none; margin-bottom:5px;' size='1' onChange='javascript:Cal.SwitchYear(this.value);RenderCssCal();'>";
		for (i = StartYear; i <= dtToday.getFullYear() + EndYear; i += 1) {
			if (i === Cal.Year) {
				SelectStr = 'selected="selected"';
			} else {
				SelectStr = '';
			}
			vCalHeader += "<option " + SelectStr + " value=" + i + ">" + i + "</option>\n";
		}
		vCalHeader += "</select>";

		/* ul year for custom select */
		vCalHeader += '<span class="MonthSelectorTitle Year">' + Cal.Year + '</span>';
		vCalHeader += '<ul name="YearSelector" class="MonthSelector Year" onChange="javascript:Cal.SwitchMth(this.selectedIndex);RenderCssCal();">';
		for (i = StartYear; i <= dtToday.getFullYear() + EndYear; i += 1) {
			if (i === Cal.Year) {
				SelectStr = 'selected="selected"';
			} else {
				SelectStr = '';
			}
			vCalHeader += '<li>' + i + '</li>';
		}
		vCalHeader += "</ul>";
		vCalHeader += "</td>\n";
		calHeight += 30;
	}

	//******************End Month and Year selector in dropdown list*********************

	//******************Month and Year selector in arrow*********************************

	else if (Cal.Scroller === "ARROW") {
			if (UseImageFiles) {
				vCalHeader += "<td><img onmousedown='javascript:Cal.DecYear();RenderCssCal();' src='" + imageFilesPath + "cal_fastreverse.gif' width='13px' height='9' onmouseover='changeBorder(this, 0)' onmouseout='changeBorder(this, 1)' style='border:1px solid white'></td>\n"; //Year scroller (decrease 1 year)
				vCalHeader += "<td><img onmousedown='javascript:Cal.DecMonth();RenderCssCal();' src='" + imageFilesPath + "cal_reverse.gif' width='13px' height='9' onmouseover='changeBorder(this, 0)' onmouseout='changeBorder(this, 1)' style='border:1px solid white'></td>\n"; //Month scroller (decrease 1 month)
				vCalHeader += "<td width='70%' class='calR' style='color:" + YrSelColor + "'>" + Cal.GetMonthName(ShowLongMonth) + " " + Cal.Year + "</td>"; //Month and Year
				vCalHeader += "<td><img onmousedown='javascript:Cal.IncMonth();RenderCssCal();' src='" + imageFilesPath + "cal_forward.gif' width='13px' height='9' onmouseover='changeBorder(this, 0)' onmouseout='changeBorder(this, 1)' style='border:1px solid white'></td>\n"; //Month scroller (increase 1 month)
				vCalHeader += "<td><img onmousedown='javascript:Cal.IncYear();RenderCssCal();' src='" + imageFilesPath + "cal_fastforward.gif' width='13px' height='9' onmouseover='changeBorder(this, 0)' onmouseout='changeBorder(this, 1)' style='border:1px solid white'></td>\n"; //Year scroller (increase 1 year)
				calHeight += 22;
			} else {
				vCalHeader += "<td><span id='dec_year' title='reverse year' onmousedown='javascript:Cal.DecYear();RenderCssCal();' onmouseover='changeBorder(this, 0)' onmouseout='changeBorder(this, 1)' style='border:1px solid white; color:" + YrSelColor + "'>-</span></td>"; //Year scroller (decrease 1 year)
				vCalHeader += "<td><span id='dec_month' title='reverse month' onmousedown='javascript:Cal.DecMonth();RenderCssCal();' onmouseover='changeBorder(this, 0)' onmouseout='changeBorder(this, 1)' style='border:1px solid white'>&lt;</span></td>\n"; //Month scroller (decrease 1 month)
				vCalHeader += "<td width='70%' class='calR' style='color:" + YrSelColor + "'>" + Cal.GetMonthName(ShowLongMonth) + " " + Cal.Year + "</td>\n"; //Month and Year
				vCalHeader += "<td><span id='inc_month' title='forward month' onmousedown='javascript:Cal.IncMonth();RenderCssCal();' onmouseover='changeBorder(this, 0)' onmouseout='changeBorder(this, 1)' style='border:1px solid white'>&gt;</span></td>\n"; //Month scroller (increase 1 month)
				vCalHeader += "<td><span id='inc_year' title='forward year' onmousedown='javascript:Cal.IncYear();RenderCssCal();'  onmouseover='changeBorder(this, 0)' onmouseout='changeBorder(this, 1)' style='border:1px solid white; color:" + YrSelColor + "'>+</span></td>\n"; //Year scroller (increase 1 year)
				calHeight += 22;
			}
		}

	vCalHeader += "</tr></table></td></tr>";

	//******************End Month and Year selector in arrow******************************

	//Calendar header shows Month and Year
	if (ShowMonthYear && Cal.Scroller === "DROPDOWN") {
		vCalHeader += "<tr><td colspan='7' class='calR' style='color:" + MonthYearColor + "'>" + Cal.GetMonthName(ShowLongMonth) + " " + Cal.Year + "</td></tr>";
		calHeight += 19;
	}

	//Week day header

	vCalHeader += "<tr><td colspan=\"7\"><table style='border-spacing:0;border-collapse:collapse;box-sizing:border-box; margin: 5px 5px 5px 4px;'><tr>";
	if (MondayFirstDay === true) {
		WeekDayName = WeekDayName2;
	} else {
		WeekDayName = WeekDayName1;
	}
	for (i = 0; i < 7; i += 1) {
		vCalHeader += "<td style='background-color:" + WeekHeadBackground + ";width:" + CellWidth + "px;color:" + WeekHeadColor + "' class='calTD'>" + WeekDayName[i].substr(0, WeekChar) + "</td>";
	}

	calHeight += 19;
	vCalHeader += "</tr>";
	//Calendar detail
	CalDate = new Date(Cal.Year, Cal.Month);
	CalDate.setDate(1);

	vFirstDay = CalDate.getDay();

	//Added version 1.7
	if (MondayFirstDay === true) {
		vFirstDay -= 1;
		if (vFirstDay === -1) {
			vFirstDay = 6;
		}
	}

	//Added version 1.7
	vCalData = "<tr>";
	calHeight += 19;
	for (i = 0; i < vFirstDay; i += 1) {
		vCalData = vCalData + GenCell();
		vDayCount = vDayCount + 1;
	}

	//Added version 1.7
	for (j = 1; j <= Cal.GetMonDays(); j += 1) {
		if (vDayCount % 7 === 0 && j > 1) {
			vCalData = vCalData + "<tr>";
		}

		vDayCount = vDayCount + 1;
		//added version 2.1.2
		if (Cal.EnableDateMode === "future" && (j < dtToday.getDate() && Cal.Month === dtToday.getMonth() && Cal.Year === dtToday.getFullYear() || Cal.Month < dtToday.getMonth() && Cal.Year === dtToday.getFullYear() || Cal.Year < dtToday.getFullYear())) {
			strCell = GenCell(j, false, DisableColor, false); //Before today's date is not clickable
		} else if (Cal.EnableDateMode === "past" && (j >= dtToday.getDate() && Cal.Month === dtToday.getMonth() && Cal.Year === dtToday.getFullYear() || Cal.Month > dtToday.getMonth() && Cal.Year === dtToday.getFullYear() || Cal.Year > dtToday.getFullYear())) {
			strCell = GenCell(j, false, DisableColor, false); //After today's date is not clickable
		}
		//if End Year + Current Year = Cal.Year. Disable.
		else if (Cal.Year > dtToday.getFullYear() + EndYear) {
				strCell = GenCell(j, false, DisableColor, false);
			} else if (j === dtToday.getDate() && Cal.Month === dtToday.getMonth() && Cal.Year === dtToday.getFullYear()) {
				strCell = GenCell(j, true, TodayColor); //Highlight today's date
			} else {
				if (j === selDate.getDate() && Cal.Month === selDate.getMonth() && Cal.Year === selDate.getFullYear()) {
					//modified version 1.7
					strCell = GenCell(j, true, SelDateColor);
				} else {
					if (MondayFirstDay === true) {
						if (vDayCount % 7 === 0) {
							strCell = GenCell(j, false, SundayColor);
						} else if ((vDayCount + 1) % 7 === 0) {
							strCell = GenCell(j, false, SaturdayColor);
						} else {
							strCell = GenCell(j, null, WeekDayColor);
						}
					} else {
						if (vDayCount % 7 === 0) {
							strCell = GenCell(j, false, SaturdayColor);
						} else if ((vDayCount + 6) % 7 === 0) {
							strCell = GenCell(j, false, SundayColor);
						} else {
							strCell = GenCell(j, null, WeekDayColor);
						}
					}
				}
			}

		vCalData = vCalData + strCell;

		if (vDayCount % 7 === 0 && j < Cal.GetMonDays()) {
			vCalData = vCalData + "</tr>";
			calHeight += 19;
		}
	}

	// finish the table proper

	if (vDayCount % 7 !== 0) {
		while (vDayCount % 7 !== 0) {
			vCalData = vCalData + GenCell();
			vDayCount = vDayCount + 1;
		}
	}

	vCalData = vCalData + "</table></td></tr>";

	//Time picker
	if (Cal.ShowTime === true) {
		showHour = Cal.getShowHour();

		if (Cal.ShowSeconds === false && TimeMode === 24) {
			ShowArrows = true;
			HourCellWidth = "10px";
		}

		vCalTime = "<tr><td colspan='7' style=\"text-align:center;\"><table border='0' width='100%' cellpadding='0' cellspacing='0'><tbody><tr><td height='5px' width='" + HourCellWidth + "'>&nbsp;</td>";

		if (ShowArrows && UseImageFiles) //this is where the up and down arrow control the hour.
			{
				vCalTime += "<td style='vertical-align:middle;'><table cellspacing='0' cellpadding='0' style='line-height:0pt;width:100%;'><tr><td style='text-align:center;'><img onclick='nextStep(\"Hour\", \"plus\");' onmousedown='startSpin(\"Hour\", \"plus\");' onmouseup='stopSpin();' src='" + imageFilesPath + "cal_plus.gif' width='13px' height='9px' onmouseover='changeBorder(this, 0)' onmouseout='changeBorder(this, 1)' style='border:1px solid white'></td></tr><tr><td style='text-align:center;'><img onclick='nextStep(\"Hour\", \"minus\");' onmousedown='startSpin(\"Hour\", \"minus\");' onmouseup='stopSpin();' src='" + imageFilesPath + "cal_minus.gif' width='13px' height='9px' onmouseover='changeBorder(this, 0)' onmouseout='changeBorder(this, 1)' style='border:1px solid white'></td></tr></table></td>\n";
			}

		vCalTime += "<td style='border-top:1px solid #b7c9d3;'><input type='text' name='hour' maxlength=2 size=1 style='width:auto;padding:5px 10px;margin:10px auto;float:right;' value=" + showHour + " onkeyup=\"javascript:Cal.SetHour(this.value)\">";
		vCalTime += "</td><td style='font-weight:bold;text-align:center;padding:0 3px;border-top:1px solid #b7c9d3;'>:</td><td style='border-top:1px solid #b7c9d3;'>";
		vCalTime += "<input type='text' name='minute' maxlength=2 size=1 style='border-top:1px solid #b7c9d3; width:auto;padding:5px 10px;margin:0 auto;float:left;' value=" + Cal.Minutes + " onkeyup=\"javascript:Cal.SetMinute(this.value)\">";

		if (Cal.ShowSeconds) {
			vCalTime += "</td><td style='font-weight:bold;border-top:1px solid #b7c9d3;'>:</td><td style='border-top:1px solid #b7c9d3;'>";
			vCalTime += "<input type='text' name='second' maxlength=2 size=1 style='width:auto;padding:5px 10px;margin:0 auto;float:left;' value=" + Cal.Seconds + " onkeyup=\"javascript:Cal.SetSecond(parseInt(this.value,10))\">";
		}

		if (TimeMode === 12) {
			SelectAm = Cal.AMorPM === "AM" ? "Selected" : "";
			SelectPm = Cal.AMorPM === "PM" ? "Selected" : "";

			vCalTime += "</td><td>";
			vCalTime += "<select name=\"ampm\" onChange=\"javascript:Cal.SetAmPm(this.options[this.selectedIndex].value);\">\n";
			vCalTime += "<option " + SelectAm + " value=\"AM\">AM</option>";
			vCalTime += "<option " + SelectPm + " value=\"PM\">PM<option>";
			vCalTime += "</select>";
		}

		if (ShowArrows && UseImageFiles) //this is where the up and down arrow to change the "Minute".
			{
				vCalTime += "</td>\n<td style='vertical-align:middle;'><table cellspacing='0' cellpadding='0' style='line-height:0pt;width:100%'><tr><td style='text-align:center;'><img onclick='nextStep(\"Minute\", \"plus\");' onmousedown='startSpin(\"Minute\", \"plus\");' onmouseup='stopSpin();' src='" + imageFilesPath + "cal_plus.gif' width='13px' height='9px' onmouseover='changeBorder(this, 0)' onmouseout='changeBorder(this, 1)' style='border:1px solid white'></td></tr><tr><td style='text-align:center;'><img onmousedown='startSpin(\"Minute\", \"minus\");' onmouseup='stopSpin();' onclick='nextStep(\"Minute\",\"minus\");' src='" + imageFilesPath + "cal_minus.gif' width='13px' height='9px' onmouseover='changeBorder(this, 0)' onmouseout='changeBorder(this, 1)' style='border:1px solid white'></td></tr></table>";
			}

		vCalTime += "</td>\n<td align='right' valign='bottom' width='" + HourCellWidth + "px'></td></tr>";
		vCalTime += "<tr><td height='5px' width='" + HourCellWidth + "'>&nbsp;</td><td colspan='3' style='text-align:center;border-top:1px solid #b7c9d3;'><input onClick='javascript:closewin(\"" + Cal.Ctrl + "\");'  type=\"button\" value=\"OK\">&nbsp;<input onClick='javascript:winclose()' type=\"button\" value=\"Cancel\"></td><td height='5px' width='" + HourCellWidth + "'>&nbsp;</td></tr>";
	} else //if not to show time.
		{
			vCalTime += "\n<tr>\n<td colspan='7' style=\"text-align:right;\">";
			//close button
			if (UseImageFiles) {
				vCalClosing += "<img onmousedown='javascript:closewin(\"" + Cal.Ctrl + "\"); stopSpin();' src='" + imageFilesPath + "cal_close.gif' width='16px' height='14px' onmouseover='changeBorder(this,0)' onmouseout='changeBorder(this, 1)' style='border:1px solid white'></td>";
			} else {
				vCalClosing += "<span id='close_cal' title='close'onmousedown='javascript:closewin(\"" + Cal.Ctrl + "\");stopSpin();' onmouseover='changeBorder(this, 0)'onmouseout='changeBorder(this, 1)' style='border:1px solid white; font-family: Arial;font-size: 10pt;'>x</span></td>";
			}
			vCalClosing += "</tr>";
		}
	vCalClosing += "</tbody></table></td></tr>";
	calHeight += 31;
	vCalClosing += "</tbody></table>\n</span>";

	//end time picker
	funcCalback = "function callback(id, datum) {";
	funcCalback += " var CalId = document.getElementById(id);if (datum=== 'undefined') { var d = new Date(); datum = d.getDate() + '/' +(d.getMonth()+1) + '/' + d.getFullYear(); } window.calDatum=datum;CalId.value=datum;";
	funcCalback += " if(Cal.ShowTime){";
	funcCalback += " CalId.value+='T'+Cal.getShowHour()+':'+Cal.Minutes+':00Z';";
	funcCalback += " if (Cal.ShowSeconds)  CalId.value+=':'+Cal.Seconds;";
	funcCalback += " if (TimeMode === 12)  CalId.value+=''+Cal.getShowAMorPM();";
	funcCalback += "}if(CalId.onchange!=undefined) CalId.onchange();CalId.focus();winCal.style.visibility='hidden'; $(CalId).trigger('change')}";

	// determines if there is enough space to open the cal above the position where it is called
	if (ypos > calHeight) {
		ypos = ypos - calHeight;
	}

	if (!winCal) {
		headID = document.getElementsByTagName("head")[0];

		// add javascript function to the span cal
		e = document.createElement("script");
		e.type = "text/javascript";
		e.language = "javascript";
		e.text = funcCalback;
		headID.appendChild(e);
		// add stylesheet to the span cal

		cssStr = ".calTD {text-align: center; border:0; width:36px; height:36px; border-radius:50%}\n";
		cssStr += "#calBorder {font-size: 14px; border-radius:0px 0px 4px 4px}\n";
		cssStr += ".calR {text-align: center; font-weight: bold;" + showMonthInHead + "}\n";
		cssStr += "#calBorder table, #calBorder table th, #calBorder table td {margin:0; padding:0; border-spacing:0; border-collapse:collapse; border:0; box-sizing:border-box; -webkit-user-select: none; -moz-user-select: none; -ms-user-select: none; user-select: none;}\n";
		cssStr += "#calBorder input, #calBorder select {height:auto;}\n";
		cssStr += "#calBorder select { -webkit-appearance: menulist; -moz-appearance: menulist;}\n";
		cssStr += "#calBorder table tr:nth-child(even) {background: none;}\n";
		cssStr += '#calBorder input[type="button"], #calBorderinput[type="reset"], #calBorder input[type="submit"] {margin-top: 15px; font-family:"TMSans-Bold",Helvetica,Arial,sans-serif; font-size:12px; width:45%; border:2px solid #b7c9d3; border-radius:4px; text-transform:uppercase; color:#b7c9d3; padding:4px; margin-bottom:12px;}\n';
		cssStr += '#calBorder .MonthSelectorTitle {position: relative; font-family: "TMSans-Bold", Arial, serif; font-size: 14px; color: #b7c9d3; display: block; float: left; margin-left: 5px; padding-right:24px; -webkit-transition: color 0.3s ease-in-out; -o-transition: color 0.3s ease-in-out; transition: color 0.3s ease-in-out; -webkit-user-select: none; -moz-user-select: none; -ms-user-select: none; user-select: none;}\n';
		cssStr += '#calBorder .MonthSelectorTitle:hover {color: #189ddc; cursor: pointer;}\n';
		cssStr += '#calBorder .MonthSelectorTitle:hover:before {opacity:1;}\n';
		cssStr += '#calBorder .MonthSelectorTitle:hover:after {opacity:0;}\n';
		cssStr += '#calBorder .MonthSelectorTitle:hover:after {color: #189ddc; cursor: pointer;}\n';
		cssStr += '#calBorder .MonthSelectorTitle.Year {float: right;}\n';
		cssStr += '#calBorder .MonthSelectorTitle:before, #calBorder .MonthSelectorTitle:after {content: ""; position: absolute; right: 0; top: 50%; width: 15px; height: 10px; margin-top: -5px; background-position: center center; background-repeat: no-repeat; -webkit-transition: opacity 0.2s ease-in-out; -o-transition: opacity 0.2s ease-in-out; transition: opacity 0.2s ease-in-out;}\n';
		cssStr += '#calBorder .MonthSelectorTitle:before {opacity:0; background: url("http://developer.ticketmaster.com/assets/widgets/1.0.0/img/small-shevron-hover.svg") center center no-repeat;\n}';
		cssStr += '#calBorder .MonthSelectorTitle:after {background: url("http://developer.ticketmaster.com/assets/widgets/1.0.0/img/small-shevron.svg") center center no-repeat;}\n';
		cssStr += '#calBorder ul.MonthSelector {display: none; background:#b7c9d2; margin-bottom:5px; font-family: "TMSans-Bold", Arial, serif; font-size: 14px; padding: 10px 15px; margin:0; top:35px; left:0; position: absolute;}\n';
		cssStr += '#calBorder ul.MonthSelector.show {display: block;}\n';
		cssStr += '#calBorder ul.MonthSelector.Year {left:auto; right:0; padding: 10px 34px;}\n';
		cssStr += '#calBorder ul.MonthSelector.Year.show {display: block;}\n';
		cssStr += '#calBorder ul.MonthSelector li { font-family: "TMSans-Bold", Arial, serif; font-size: 14px; margin:0; padding:0; line-height:27px; color: #fff; -webkit-user-select: none; -moz-user-select: none; -ms-user-select: none; user-select: none;}\n';
		cssStr += '#calBorder ul.MonthSelector li:hover {color: #189ddc; cursor: pointer;}\n';
		cssStr += '#calOverlay {width: 100%; height: 100%; position: fixed; top: 0; left: 0; display: none;}\n';
		cssStr += '#calOverlay.show {display: block;}\n';

		style = document.createElement("style");
		style.type = "text/css";
		style.rel = "stylesheet";
		if (style.styleSheet) {
			// IE
			style.styleSheet.cssText = cssStr;
		} else {
			// w3c
			cssText = document.createTextNode(cssStr);
			style.appendChild(cssText);
		}

		headID.appendChild(style);
		// create the outer frame that allows the cal. to be moved
		span = document.createElement("span");
		span.id = calSpanID;
		span.style.position = "absolute";
		span.style.left = xpos + CalPosOffsetX + 'px';
		span.style.top = ypos - CalPosOffsetY + 'px';
		span.style.width = CalWidth + 'px';
		span.style.border = "solid 1px " + SpanBorderColor;
		span.style.padding = "0";
		span.style.cursor = "move";
		span.style.backgroundColor = SpanBgColor;
		span.style.zIndex = 1;
		var overlay = document.createElement("div");
		overlay.id = "calOverlay";
		overlay.classList.add("show");
		document.body.appendChild(span);
		document.body.appendChild(overlay);
		winCal = document.getElementById(calSpanID);
	} else {
		winCal.style.visibility = "visible";
		winCal.style.Height = calHeight;

		// set the position for a new calendar only
		if (bNewCal === true) {
			winCal.style.left = xpos + CalPosOffsetX + 'px';
			winCal.style.top = ypos - CalPosOffsetY + 'px';
		}
	}

	winCal.innerHTML = winCalData + vCalHeader + vCalData + vCalTime + vCalClosing;
	return true;
}

function NewCssCal(pCtrl, pFormat, pScroller, pShowTime, pTimeMode, pShowSeconds, pEnableDateMode) {
	// get current date and time

	dtToday = new Date();
	Cal = new Calendar(dtToday);

	if (pShowTime !== undefined) {
		if (pShowTime) {
			Cal.ShowTime = true;
		} else {
			Cal.ShowTime = false;
		}

		if (pTimeMode) {
			pTimeMode = parseInt(pTimeMode, 10);
		}
		if (pTimeMode === 12 || pTimeMode === 24) {
			TimeMode = pTimeMode;
		} else {
			TimeMode = 24;
		}

		if (pShowSeconds !== undefined) {
			if (pShowSeconds) {
				Cal.ShowSeconds = true;
			} else {
				Cal.ShowSeconds = false;
			}
		} else {
			Cal.ShowSeconds = false;
		}
	}

	if (pCtrl !== undefined) {
		Cal.Ctrl = pCtrl;
	}

	if (pFormat !== undefined && pFormat !== "") {
		Cal.Format = pFormat.toUpperCase();
	} else {
		Cal.Format = "MMDDYYYY";
	}

	if (pScroller !== undefined && pScroller !== "") {
		if (pScroller.toUpperCase() === "ARROW") {
			Cal.Scroller = "ARROW";
		} else {
			Cal.Scroller = "DROPDOWN";
		}
	}

	if (pEnableDateMode !== undefined && (pEnableDateMode === "future" || pEnableDateMode === "past")) {
		Cal.EnableDateMode = pEnableDateMode;
	}

	exDateTime = document.getElementById(pCtrl).value; //Existing Date Time value in textbox.

	if (exDateTime) {
		//Parse existing Date String
		var Sp1 = exDateTime.indexOf(DateSeparator, 0),
		    //Index of Date Separator 1
		Sp2 = exDateTime.indexOf(DateSeparator, parseInt(Sp1, 10) + 1),
		    //Index of Date Separator 2
		tSp1,
		    //Index of Time Separator 1
		tSp2,
		    //Index of Time Separator 2
		strMonth,
		    strDate,
		    strYear,
		    intMonth,
		    YearPattern,
		    strHour,
		    strMinute,
		    strSecond,
		    winHeight,
		    offset = parseInt(Cal.Format.toUpperCase().lastIndexOf("M"), 10) - parseInt(Cal.Format.toUpperCase().indexOf("M"), 10) - 1,
		    strAMPM = "";
		//parse month

		if (Cal.Format.toUpperCase() === "DDMMYYYY" || Cal.Format.toUpperCase() === "DDMMMYYYY") {
			if (DateSeparator === "") {
				strMonth = exDateTime.substring(2, 4 + offset);
				strDate = exDateTime.substring(0, 2);
				strYear = exDateTime.substring(4 + offset, 8 + offset);
			} else {
				if (exDateTime.indexOf("D*") !== -1) {
					//DTG
					strMonth = exDateTime.substring(8, 11);
					strDate = exDateTime.substring(0, 2);
					strYear = "20" + exDateTime.substring(11, 13); //Hack, nur für Jahreszahlen ab 2000
				} else {
					strMonth = exDateTime.substring(Sp1 + 1, Sp2);
					strDate = exDateTime.substring(0, Sp1);
					strYear = exDateTime.substring(Sp2 + 1, Sp2 + 5);
				}
			}
		} else if (Cal.Format.toUpperCase() === "MMDDYYYY" || Cal.Format.toUpperCase() === "MMMDDYYYY") {
			if (DateSeparator === "") {
				strMonth = exDateTime.substring(0, 2 + offset);
				strDate = exDateTime.substring(2 + offset, 4 + offset);
				strYear = exDateTime.substring(4 + offset, 8 + offset);
			} else {
				strMonth = exDateTime.substring(0, Sp1);
				strDate = exDateTime.substring(Sp1 + 1, Sp2);
				strYear = exDateTime.substring(Sp2 + 1, Sp2 + 5);
			}
		} else if (Cal.Format.toUpperCase() === "YYYYMMDD" || Cal.Format.toUpperCase() === "YYYYMMMDD") {
			if (DateSeparator === "") {
				strMonth = exDateTime.substring(4, 6 + offset);
				strDate = exDateTime.substring(6 + offset, 8 + offset);
				strYear = exDateTime.substring(0, 4);
			} else {
				strMonth = exDateTime.substring(Sp1 + 1, Sp2);
				strDate = exDateTime.substring(Sp2 + 1, Sp2 + 3);
				strYear = exDateTime.substring(0, Sp1);
			}
		} else if (Cal.Format.toUpperCase() === "YYMMDD" || Cal.Format.toUpperCase() === "YYMMMDD") {
			if (DateSeparator === "") {
				strMonth = exDateTime.substring(2, 4 + offset);
				strDate = exDateTime.substring(4 + offset, 6 + offset);
				strYear = exDateTime.substring(0, 2);
			} else {
				strMonth = exDateTime.substring(Sp1 + 1, Sp2);
				strDate = exDateTime.substring(Sp2 + 1, Sp2 + 3);
				strYear = exDateTime.substring(0, Sp1);
			}
		}

		if (isNaN(strMonth)) {
			intMonth = Cal.GetMonthIndex(strMonth);
		} else {
			intMonth = parseInt(strMonth, 10) - 1;
		}
		if (parseInt(intMonth, 10) >= 0 && parseInt(intMonth, 10) < 12) {
			Cal.Month = intMonth;
		}
		//end parse month

		//parse year
		YearPattern = /^\d{4}$/;
		if (YearPattern.test(strYear)) {
			if (parseInt(strYear, 10) >= StartYear && parseInt(strYear, 10) <= dtToday.getFullYear() + EndYear) Cal.Year = parseInt(strYear, 10);
		}
		//end parse year

		//parse Date
		if (parseInt(strDate, 10) <= Cal.GetMonDays() && parseInt(strDate, 10) >= 1) {
			Cal.Date = strDate;
		}
		//end parse Date

		//parse time

		if (Cal.ShowTime === true) {
			//parse AM or PM
			if (TimeMode === 12) {
				strAMPM = exDateTime.substring(exDateTime.length - 2, exDateTime.length);
				Cal.AMorPM = strAMPM;
			}

			tSp1 = exDateTime.indexOf(":", 0);
			tSp2 = exDateTime.indexOf(":", parseInt(tSp1, 10) + 1);

			if (tSp1 > 0) {
				strHour = exDateTime.substring(tSp1, tSp1 - 2);
				Cal.SetHour(strHour);
				strMinute = exDateTime.substring(tSp1 + 1, tSp1 + 3);
				Cal.SetMinute(strMinute);
				strSecond = exDateTime.substring(tSp2 + 1, tSp2 + 3);
				Cal.SetSecond(strSecond);
			} else if (exDateTime.indexOf("D*") !== -1) {
				//DTG
				strHour = exDateTime.substring(2, 4);
				Cal.SetHour(strHour);
				strMinute = exDateTime.substring(4, 6);
				Cal.SetMinute(strMinute);
			}
		}
	}
	selDate = new Date(Cal.Year, Cal.Month, Cal.Date); //version 1.7
	RenderCssCal(true);
}

function closewin(id) {
	if (Cal.ShowTime === true) {
		var MaxYear = dtToday.getFullYear() + EndYear;
		var beforeToday = Cal.Date < dtToday.getDate() && Cal.Month === dtToday.getMonth() && Cal.Year === dtToday.getFullYear() || Cal.Month < dtToday.getMonth() && Cal.Year === dtToday.getFullYear() || Cal.Year < dtToday.getFullYear();

		if (Cal.Year <= MaxYear && Cal.Year >= StartYear && Cal.Month === selDate.getMonth() && Cal.Year === selDate.getFullYear()) {
			if (Cal.EnableDateMode === "future") {
				if (beforeToday === false) {
					callback(id, Cal.FormatDate(Cal.Date));
				}
			} else callback(id, Cal.FormatDate(Cal.Date));
		}
	}
	var CalId = document.getElementById(id);
	CalId.focus();
	winCal.style.visibility = 'hidden';
	document.getElementById('calOverlay').classList.remove('show');
	var activeIcons = document.querySelectorAll('.dt-ico');
	var aiCountLenght = activeIcons.length;
	for (var aiCount = 0; aiCount < aiCountLenght; ++aiCount) {
		activeIcons[aiCount].classList.remove('active');
	}
}

function winclose() {
	winCal.style.visibility = 'hidden';
	document.getElementById('calOverlay').classList.remove('show');
	var activeIcons = document.querySelectorAll('.dt-ico');
	var aiCountLenght = activeIcons.length;
	for (var aiCount = 0; aiCount < aiCountLenght; ++aiCount) {
		activeIcons[aiCount].classList.remove('active');
	}
}

function changeBorder(element, col, oldBgColor) {
	if (col === 0) {
		element.style.background = HoverColor;
		element.style.borderColor = "black";
		element.style.cursor = "pointer";
	} else {
		if (oldBgColor) {
			element.style.background = oldBgColor;
		} else {
			element.style.background = "white";
		}
		element.style.borderColor = "white";
		element.style.cursor = "auto";
	}
}

function selectDate(element, date) {
	Cal.Date = date;
	selDate = new Date(Cal.Year, Cal.Month, Cal.Date);
	element.style.background = SelDateColor;
	RenderCssCal();
}

function findPos(obj) {
	var curleft = 0,
	    curtop = 0;
	if (obj.offsetParent) {
		do {
			curleft += obj.offsetLeft;
			curtop += obj.offsetTop;
		} while (obj = obj.offsetParent);
		return { x: curleft, y: curtop };
	}
	return undefined;
}

function pickIt(evt) {
	var objectID, dom, de, b;
	// accesses the element that generates the event and retrieves its ID
	if (document.addEventListener) {
		// w3c
		objectID = evt.target.id;
		/*
   if (objectID.indexOf(calSpanID) !== -1)
   {
   dom = document.getElementById(objectID);
   cnLeft = evt.pageX;
   cnTop = evt.pageY;
  		 if (dom.offsetLeft)
   {
   cnLeft = (cnLeft - dom.offsetLeft);
   cnTop = (cnTop - dom.offsetTop);
   }
   }
   */
		// get mouse position on click
		/*
   xpos = (evt.pageX);
   ypos = (evt.pageY);
   */
		if (objectID == '') {
			var posEvTarget = findPos(evt.target);
			if (posEvTarget) {
				xpos = posEvTarget.x;
				ypos = posEvTarget.y;
			}
		}
	} else {
		// IE
		objectID = event.srcElement.id;
		cnLeft = event.offsetX;
		cnTop = event.offsetY;

		// get mouse position on click
		de = document.documentElement;
		b = document.body;

		xpos = event.clientX + (de.scrollLeft || b.scrollLeft) - (de.clientLeft || 0);
		ypos = event.clientY + (de.scrollTop || b.scrollTop) - (de.clientTop || 0);
	}

	// verify if this is a valid element to pick
	if (objectID.indexOf(calSpanID) !== -1) {
		domStyle = document.getElementById(objectID).style;
	}

	if (domStyle) {
		domStyle.zIndex = 100;
		return false;
	} else {
		domStyle = null;
		return;
	}
}

function dragIt(evt) {
	if (domStyle) {
		if (document.addEventListener) {
			//for IE
			domStyle.left = event.clientX - cnLeft + document.body.scrollLeft + 'px';
			domStyle.top = event.clientY - cnTop + document.body.scrollTop + 'px';
		} else {
			//Firefox
			domStyle.left = evt.clientX - cnLeft + document.body.scrollLeft + 'px';
			domStyle.top = evt.clientY - cnTop + document.body.scrollTop + 'px';
		}
	}
}

// performs a single increment or decrement
function nextStep(whatSpinner, direction) {
	if (whatSpinner === "Hour") {
		if (direction === "plus") {
			Cal.SetHour(Cal.Hours + 1);
			RenderCssCal();
		} else if (direction === "minus") {
			Cal.SetHour(Cal.Hours - 1);
			RenderCssCal();
		}
	} else if (whatSpinner === "Minute") {
		if (direction === "plus") {
			Cal.SetMinute(parseInt(Cal.Minutes, 10) + 1);
			RenderCssCal();
		} else if (direction === "minus") {
			Cal.SetMinute(parseInt(Cal.Minutes, 10) - 1);
			RenderCssCal();
		}
	}
}

// starts the time spinner
function startSpin(whatSpinner, direction) {
	document.thisLoop = setInterval(function () {
		nextStep(whatSpinner, direction);
	}, 125); //125 ms
}

//stops the time spinner
function stopSpin() {
	clearInterval(document.thisLoop);
}

function dropIt() {
	stopSpin();

	if (domStyle) {
		domStyle = null;
	}
}

// Default events configuration

document.onmousedown = pickIt;
/*
 document.onmousemove = dragIt;
 document.onmouseup = dropIt;
 */

document.addEventListener('click', function (e) {

	if (e.target.classList[0] == 'dt-ico') {
		if (e.target.classList[1] !== undefined) {
			e.target.classList.remove('active');
			document.getElementById('calBorder').style.visibility = 'hidden';
			document.getElementById('calOverlay').classList.remove('show');
		} else {
			e.target.classList.add('active');
			document.getElementById('calBorder').style.visibility = 'visible';
			document.getElementById('calOverlay').classList.add('show');
		}
	}

	if (e.target.id === 'calOverlay') {
		document.getElementById('calBorder').style.visibility = 'hidden';
		document.getElementById('calOverlay').classList.remove('show');
		var activeIcons = document.querySelectorAll('.dt-ico');
		var aiCountLenght = activeIcons.length;
		for (var aiCount = 0; aiCount < aiCountLenght; ++aiCount) {
			activeIcons[aiCount].classList.remove('active');
		}
	}

	if (document.querySelector('#calBorder .MonthSelector') !== null) {

		var targetClass = e.target.classList[0];
		if (e.target.classList[1] !== undefined) targetClass = e.target.classList[1];
		if (targetClass === undefined) targetClass = e.target.parentNode.classList[0];

		if (targetClass == 'MonthSelectorTitle') {
			if (document.querySelector('#calBorder .MonthSelector').classList.contains("show")) {
				document.querySelector('#calBorder .MonthSelector').classList.remove("show");
			} else {
				document.querySelector('#calBorder .MonthSelector').classList.add("show");
				document.querySelector('#calBorder .MonthSelector.Year').classList.remove("show");
			}
		};

		if (targetClass == 'MonthSelector') {

			var selectClass = e.target.parentNode.classList[1];

			if (e.target.tagName === 'LI' && selectClass === 'show') {
				document.querySelector('#calBorder .MonthSelectorTitle').innerHTML = e.target.innerHTML;
				Cal.SwitchMth([].indexOf.call(e.target.parentNode.children, e ? e.target : e.srcElement));
				RenderCssCal();
			}
			if (e.target.tagName === 'LI' && selectClass === 'Year') {
				document.querySelector('#calBorder .MonthSelectorTitle.Year').innerHTML = e.target.innerHTML;
				Cal.SwitchYear(e.target.innerHTML);
				RenderCssCal();
			}
		};

		if (targetClass == 'Year') {
			if (document.querySelector('#calBorder .MonthSelector.Year').classList.contains("show")) {
				document.querySelector('#calBorder .MonthSelector.Year').classList.remove("show");
			} else {
				document.querySelector('#calBorder .MonthSelector.Year').classList.add("show");
				document.querySelector('#calBorder .MonthSelector').classList.remove("show");
			}
		};
	}
});

try {
	window.NewCssCal = NewCssCal;
	window.Calendar = Calendar;
	window.GenCell = GenCell;
	window.RenderCssCal = RenderCssCal;
	window.NewCssCal = NewCssCal;
	window.closewin = closewin;
	window.winclose = winclose;
	window.changeBorder = changeBorder;
	window.selectDate = selectDate;
	window.findPos = findPos;
	window.pickIt = pickIt;
	window.dragIt = dragIt;
	window.nextStep = nextStep;
	window.startSpin = startSpin;
	window.dropIt = dropIt;
} catch (err) {
	console.log(err);
}

/***/ }),
/* 54 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global, jQuery) {var require;var require;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

(function e(t, n, r) {
  function s(o, u) {
    if (!n[o]) {
      if (!t[o]) {
        var a = typeof require == "function" && require;if (!u && a) return require(o, !0);if (i) return i(o, !0);var f = new Error("Cannot find module '" + o + "'");throw f.code = "MODULE_NOT_FOUND", f;
      }var l = n[o] = { exports: {} };t[o][0].call(l.exports, function (e) {
        var n = t[o][1][e];return s(n ? n : e);
      }, l, l.exports, e, t, n, r);
    }return n[o].exports;
  }var i = typeof require == "function" && require;for (var o = 0; o < r.length; o++) {
    s(r[o]);
  }return s;
})({ 1: [function (require, module, exports) {
    (function (global) {

      var ResizeSensor = require('css-element-queries/src/ResizeSensor');
      var ResizeSensor = require('css-element-queries/src/ResizeSensor');
      var Ps = require('perfect-scrollbar');
      var ko = typeof window !== "undefined" ? window['ko'] : typeof global !== "undefined" ? global['ko'] : null;

      function getOpts(acc) {
        var opts = ko.unwrap(acc());
        if (opts.x === undefined) opts.x = true;
        if (opts.y === undefined) opts.y = true;
        return opts;
      }

      function psOpts(opts) {
        return {
          suppressScrollX: !opts.x,
          suppressScrollY: !opts.y
        };
      }

      var scrollBinding = {
        init: function init(element, valAcc, bindings, vm, ctx) {
          var opts = getOpts(valAcc);
          Ps.initialize(element, psOpts(opts));
          var sensor = new ResizeSensor(element, function () {
            Ps.update(element);
          });
          ko.utils.domNodeDisposal.addDisposeCallback(element, function () {
            sensor.detach();
            Ps.destroy(element);
          });
        },
        update: function update(element, valAcc, bindings, vm, ctx) {
          var opts = getOpts(valAcc);
          if (ctx._firstUpdateComplete) {
            Ps.destroy(element);
            ko.bindingHandlers.scroll.init.apply(this, arguments);
          }
          Object.assign(element.style, {
            overflowX: opts.x ? 'scroll' : 'hidden',
            overflowY: opts.y ? 'scroll' : 'hidden'
          });
          ctx._firstUpdateComplete = true;
        }
      };

      module.exports = ko.bindingHandlers.scroll = scrollBinding;
    }).call(this, typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
  }, { "css-element-queries/src/ResizeSensor": 2, "perfect-scrollbar": 3 }], 2: [function (require, module, exports) {
    /**
     * Copyright Marc J. Schmidt. See the LICENSE file at the top-level
     * directory of this distribution and at
     * https://github.com/marcj/css-element-queries/blob/master/LICENSE.
     */
    ;
    (function () {

      /**
       * Class for dimension change detection.
       *
       * @param {Element|Element[]|Elements|jQuery} element
       * @param {Function} callback
       *
       * @constructor
       */
      var ResizeSensor = function ResizeSensor(element, callback) {
        /**
         *
         * @constructor
         */
        function EventQueue() {
          this.q = [];
          this.add = function (ev) {
            this.q.push(ev);
          };

          var i, j;
          this.call = function () {
            for (i = 0, j = this.q.length; i < j; i++) {
              this.q[i].call();
            }
          };
        }

        /**
         * @param {HTMLElement} element
         * @param {String}      prop
         * @returns {String|Number}
         */
        function getComputedStyle(element, prop) {
          if (element.currentStyle) {
            return element.currentStyle[prop];
          } else if (window.getComputedStyle) {
            return window.getComputedStyle(element, null).getPropertyValue(prop);
          } else {
            return element.style[prop];
          }
        }

        /**
         *
         * @param {HTMLElement} element
         * @param {Function}    resized
         */
        function attachResizeEvent(element, resized) {
          if (!element.resizedAttached) {
            element.resizedAttached = new EventQueue();
            element.resizedAttached.add(resized);
          } else if (element.resizedAttached) {
            element.resizedAttached.add(resized);
            return;
          }

          element.resizeSensor = document.createElement('div');
          element.resizeSensor.className = 'resize-sensor';
          var style = 'position: absolute; left: 0; top: 0; right: 0; bottom: 0; overflow: hidden; z-index: -1; visibility: hidden;';
          var styleChild = 'position: absolute; left: 0; top: 0; transition: 0s;';

          element.resizeSensor.style.cssText = style;
          element.resizeSensor.innerHTML = '<div class="resize-sensor-expand" style="' + style + '">' + '<div style="' + styleChild + '"></div>' + '</div>' + '<div class="resize-sensor-shrink" style="' + style + '">' + '<div style="' + styleChild + ' width: 200%; height: 200%"></div>' + '</div>';
          element.appendChild(element.resizeSensor);

          if (!{ fixed: 1, absolute: 1 }[getComputedStyle(element, 'position')]) {
            element.style.position = 'relative';
          }

          var expand = element.resizeSensor.childNodes[0];
          var expandChild = expand.childNodes[0];
          var shrink = element.resizeSensor.childNodes[1];
          var shrinkChild = shrink.childNodes[0];

          var lastWidth, lastHeight;

          var reset = function reset() {
            expandChild.style.width = expand.offsetWidth + 10 + 'px';
            expandChild.style.height = expand.offsetHeight + 10 + 'px';
            expand.scrollLeft = expand.scrollWidth;
            expand.scrollTop = expand.scrollHeight;
            shrink.scrollLeft = shrink.scrollWidth;
            shrink.scrollTop = shrink.scrollHeight;
            lastWidth = element.offsetWidth;
            lastHeight = element.offsetHeight;
          };

          reset();

          var changed = function changed() {
            if (element.resizedAttached) {
              element.resizedAttached.call();
            }
          };

          var addEvent = function addEvent(el, name, cb) {
            if (el.attachEvent) {
              el.attachEvent('on' + name, cb);
            } else {
              el.addEventListener(name, cb);
            }
          };

          var onScroll = function onScroll() {
            if (element.offsetWidth != lastWidth || element.offsetHeight != lastHeight) {
              changed();
            }
            reset();
          };

          addEvent(expand, 'scroll', onScroll);
          addEvent(shrink, 'scroll', onScroll);
        }

        var elementType = Object.prototype.toString.call(element);
        var isCollectionTyped = '[object Array]' === elementType || '[object NodeList]' === elementType || '[object HTMLCollection]' === elementType || 'undefined' !== typeof jQuery && element instanceof jQuery //jquery
        || 'undefined' !== typeof Elements && element instanceof Elements //mootools
        ;

        if (isCollectionTyped) {
          var i = 0,
              j = element.length;
          for (; i < j; i++) {
            attachResizeEvent(element[i], callback);
          }
        } else {
          attachResizeEvent(element, callback);
        }

        this.detach = function () {
          if (isCollectionTyped) {
            var i = 0,
                j = element.length;
            for (; i < j; i++) {
              ResizeSensor.detach(element[i]);
            }
          } else {
            ResizeSensor.detach(element);
          }
        };
      };

      ResizeSensor.detach = function (element) {
        if (element.resizeSensor) {
          element.removeChild(element.resizeSensor);
          delete element.resizeSensor;
          delete element.resizedAttached;
        }
      };

      // make available to common module loader
      if (typeof module !== 'undefined' && typeof module.exports !== 'undefined') {
        module.exports = ResizeSensor;
      } else {
        window.ResizeSensor = ResizeSensor;
      }
    })();
  }, {}], 3: [function (require, module, exports) {
    'use strict';

    module.exports = require('./src/js/main');
  }, { "./src/js/main": 9 }], 4: [function (require, module, exports) {
    'use strict';

    function oldAdd(element, className) {
      var classes = element.className.split(' ');
      if (classes.indexOf(className) < 0) {
        classes.push(className);
      }
      element.className = classes.join(' ');
    }

    function oldRemove(element, className) {
      var classes = element.className.split(' ');
      var idx = classes.indexOf(className);
      if (idx >= 0) {
        classes.splice(idx, 1);
      }
      element.className = classes.join(' ');
    }

    exports.add = function (element, className) {
      if (element.classList) {
        element.classList.add(className);
      } else {
        oldAdd(element, className);
      }
    };

    exports.remove = function (element, className) {
      if (element.classList) {
        element.classList.remove(className);
      } else {
        oldRemove(element, className);
      }
    };

    exports.list = function (element) {
      if (element.classList) {
        return Array.prototype.slice.apply(element.classList);
      } else {
        return element.className.split(' ');
      }
    };
  }, {}], 5: [function (require, module, exports) {
    'use strict';

    var DOM = {};

    DOM.e = function (tagName, className) {
      var element = document.createElement(tagName);
      element.className = className;
      return element;
    };

    DOM.appendTo = function (child, parent) {
      parent.appendChild(child);
      return child;
    };

    function cssGet(element, styleName) {
      return window.getComputedStyle(element)[styleName];
    }

    function cssSet(element, styleName, styleValue) {
      if (typeof styleValue === 'number') {
        styleValue = styleValue.toString() + 'px';
      }
      element.style[styleName] = styleValue;
      return element;
    }

    function cssMultiSet(element, obj) {
      for (var key in obj) {
        var val = obj[key];
        if (typeof val === 'number') {
          val = val.toString() + 'px';
        }
        element.style[key] = val;
      }
      return element;
    }

    DOM.css = function (element, styleNameOrObject, styleValue) {
      if ((typeof styleNameOrObject === "undefined" ? "undefined" : _typeof(styleNameOrObject)) === 'object') {
        // multiple set with object
        return cssMultiSet(element, styleNameOrObject);
      } else {
        if (typeof styleValue === 'undefined') {
          return cssGet(element, styleNameOrObject);
        } else {
          return cssSet(element, styleNameOrObject, styleValue);
        }
      }
    };

    DOM.matches = function (element, query) {
      if (typeof element.matches !== 'undefined') {
        return element.matches(query);
      } else {
        if (typeof element.matchesSelector !== 'undefined') {
          return element.matchesSelector(query);
        } else if (typeof element.webkitMatchesSelector !== 'undefined') {
          return element.webkitMatchesSelector(query);
        } else if (typeof element.mozMatchesSelector !== 'undefined') {
          return element.mozMatchesSelector(query);
        } else if (typeof element.msMatchesSelector !== 'undefined') {
          return element.msMatchesSelector(query);
        }
      }
    };

    DOM.remove = function (element) {
      if (typeof element.remove !== 'undefined') {
        element.remove();
      } else {
        if (element.parentNode) {
          element.parentNode.removeChild(element);
        }
      }
    };

    DOM.queryChildren = function (element, selector) {
      return Array.prototype.filter.call(element.childNodes, function (child) {
        return DOM.matches(child, selector);
      });
    };

    module.exports = DOM;
  }, {}], 6: [function (require, module, exports) {
    'use strict';

    var EventElement = function EventElement(element) {
      this.element = element;
      this.events = {};
    };

    EventElement.prototype.bind = function (eventName, handler) {
      if (typeof this.events[eventName] === 'undefined') {
        this.events[eventName] = [];
      }
      this.events[eventName].push(handler);
      this.element.addEventListener(eventName, handler, false);
    };

    EventElement.prototype.unbind = function (eventName, handler) {
      var isHandlerProvided = typeof handler !== 'undefined';
      this.events[eventName] = this.events[eventName].filter(function (hdlr) {
        if (isHandlerProvided && hdlr !== handler) {
          return true;
        }
        this.element.removeEventListener(eventName, hdlr, false);
        return false;
      }, this);
    };

    EventElement.prototype.unbindAll = function () {
      for (var name in this.events) {
        this.unbind(name);
      }
    };

    var EventManager = function EventManager() {
      this.eventElements = [];
    };

    EventManager.prototype.eventElement = function (element) {
      var ee = this.eventElements.filter(function (eventElement) {
        return eventElement.element === element;
      })[0];
      if (typeof ee === 'undefined') {
        ee = new EventElement(element);
        this.eventElements.push(ee);
      }
      return ee;
    };

    EventManager.prototype.bind = function (element, eventName, handler) {
      this.eventElement(element).bind(eventName, handler);
    };

    EventManager.prototype.unbind = function (element, eventName, handler) {
      this.eventElement(element).unbind(eventName, handler);
    };

    EventManager.prototype.unbindAll = function () {
      for (var i = 0; i < this.eventElements.length; i++) {
        this.eventElements[i].unbindAll();
      }
    };

    EventManager.prototype.once = function (element, eventName, handler) {
      var ee = this.eventElement(element);
      var onceHandler = function onceHandler(e) {
        ee.unbind(eventName, onceHandler);
        handler(e);
      };
      ee.bind(eventName, onceHandler);
    };

    module.exports = EventManager;
  }, {}], 7: [function (require, module, exports) {
    'use strict';

    module.exports = function () {
      function s4() {
        return Math.floor((1 + Math.random()) * 0x10000).toString(16).substring(1);
      }
      return function () {
        return s4() + s4() + '-' + s4() + '-' + s4() + '-' + s4() + '-' + s4() + s4() + s4();
      };
    }();
  }, {}], 8: [function (require, module, exports) {
    'use strict';

    var cls = require('./class');
    var dom = require('./dom');

    var toInt = exports.toInt = function (x) {
      return parseInt(x, 10) || 0;
    };

    var clone = exports.clone = function (obj) {
      if (obj === null) {
        return null;
      } else if (obj.constructor === Array) {
        return obj.map(clone);
      } else if ((typeof obj === "undefined" ? "undefined" : _typeof(obj)) === 'object') {
        var result = {};
        for (var key in obj) {
          result[key] = clone(obj[key]);
        }
        return result;
      } else {
        return obj;
      }
    };

    exports.extend = function (original, source) {
      var result = clone(original);
      for (var key in source) {
        result[key] = clone(source[key]);
      }
      return result;
    };

    exports.isEditable = function (el) {
      return dom.matches(el, "input,[contenteditable]") || dom.matches(el, "select,[contenteditable]") || dom.matches(el, "textarea,[contenteditable]") || dom.matches(el, "button,[contenteditable]");
    };

    exports.removePsClasses = function (element) {
      var clsList = cls.list(element);
      for (var i = 0; i < clsList.length; i++) {
        var className = clsList[i];
        if (className.indexOf('ps-') === 0) {
          cls.remove(element, className);
        }
      }
    };

    exports.outerWidth = function (element) {
      return toInt(dom.css(element, 'width')) + toInt(dom.css(element, 'paddingLeft')) + toInt(dom.css(element, 'paddingRight')) + toInt(dom.css(element, 'borderLeftWidth')) + toInt(dom.css(element, 'borderRightWidth'));
    };

    exports.startScrolling = function (element, axis) {
      cls.add(element, 'ps-in-scrolling');
      if (typeof axis !== 'undefined') {
        cls.add(element, 'ps-' + axis);
      } else {
        cls.add(element, 'ps-x');
        cls.add(element, 'ps-y');
      }
    };

    exports.stopScrolling = function (element, axis) {
      cls.remove(element, 'ps-in-scrolling');
      if (typeof axis !== 'undefined') {
        cls.remove(element, 'ps-' + axis);
      } else {
        cls.remove(element, 'ps-x');
        cls.remove(element, 'ps-y');
      }
    };

    exports.env = {
      isWebKit: 'WebkitAppearance' in document.documentElement.style,
      supportsTouch: 'ontouchstart' in window || window.DocumentTouch && document instanceof window.DocumentTouch,
      supportsIePointer: window.navigator.msMaxTouchPoints !== null
    };
  }, { "./class": 4, "./dom": 5 }], 9: [function (require, module, exports) {
    'use strict';

    var destroy = require('./plugin/destroy');
    var initialize = require('./plugin/initialize');
    var update = require('./plugin/update');

    module.exports = {
      initialize: initialize,
      update: update,
      destroy: destroy
    };
  }, { "./plugin/destroy": 11, "./plugin/initialize": 19, "./plugin/update": 23 }], 10: [function (require, module, exports) {
    'use strict';

    module.exports = {
      handlers: ['click-rail', 'drag-scrollbar', 'keyboard', 'wheel', 'touch'],
      maxScrollbarLength: null,
      minScrollbarLength: null,
      scrollXMarginOffset: 0,
      scrollYMarginOffset: 0,
      stopPropagationOnClick: true,
      suppressScrollX: false,
      suppressScrollY: false,
      swipePropagation: true,
      useBothWheelAxes: false,
      wheelPropagation: false,
      wheelSpeed: 1,
      theme: 'default'
    };
  }, {}], 11: [function (require, module, exports) {
    'use strict';

    var _ = require('../lib/helper');
    var dom = require('../lib/dom');
    var instances = require('./instances');

    module.exports = function (element) {
      var i = instances.get(element);

      if (!i) {
        return;
      }

      i.event.unbindAll();
      dom.remove(i.scrollbarX);
      dom.remove(i.scrollbarY);
      dom.remove(i.scrollbarXRail);
      dom.remove(i.scrollbarYRail);
      _.removePsClasses(element);

      instances.remove(element);
    };
  }, { "../lib/dom": 5, "../lib/helper": 8, "./instances": 20 }], 12: [function (require, module, exports) {
    'use strict';

    var _ = require('../../lib/helper');
    var instances = require('../instances');
    var updateGeometry = require('../update-geometry');
    var updateScroll = require('../update-scroll');

    function bindClickRailHandler(element, i) {
      function pageOffset(el) {
        return el.getBoundingClientRect();
      }
      var stopPropagation = function stopPropagation(e) {
        e.stopPropagation();
      };

      if (i.settings.stopPropagationOnClick) {
        i.event.bind(i.scrollbarY, 'click', stopPropagation);
      }
      i.event.bind(i.scrollbarYRail, 'click', function (e) {
        var halfOfScrollbarLength = _.toInt(i.scrollbarYHeight / 2);
        var positionTop = i.railYRatio * (e.pageY - window.pageYOffset - pageOffset(i.scrollbarYRail).top - halfOfScrollbarLength);
        var maxPositionTop = i.railYRatio * (i.railYHeight - i.scrollbarYHeight);
        var positionRatio = positionTop / maxPositionTop;

        if (positionRatio < 0) {
          positionRatio = 0;
        } else if (positionRatio > 1) {
          positionRatio = 1;
        }

        updateScroll(element, 'top', (i.contentHeight - i.containerHeight) * positionRatio);
        updateGeometry(element);

        e.stopPropagation();
      });

      if (i.settings.stopPropagationOnClick) {
        i.event.bind(i.scrollbarX, 'click', stopPropagation);
      }
      i.event.bind(i.scrollbarXRail, 'click', function (e) {
        var halfOfScrollbarLength = _.toInt(i.scrollbarXWidth / 2);
        var positionLeft = i.railXRatio * (e.pageX - window.pageXOffset - pageOffset(i.scrollbarXRail).left - halfOfScrollbarLength);
        var maxPositionLeft = i.railXRatio * (i.railXWidth - i.scrollbarXWidth);
        var positionRatio = positionLeft / maxPositionLeft;

        if (positionRatio < 0) {
          positionRatio = 0;
        } else if (positionRatio > 1) {
          positionRatio = 1;
        }

        updateScroll(element, 'left', (i.contentWidth - i.containerWidth) * positionRatio - i.negativeScrollAdjustment);
        updateGeometry(element);

        e.stopPropagation();
      });
    }

    module.exports = function (element) {
      var i = instances.get(element);
      bindClickRailHandler(element, i);
    };
  }, { "../../lib/helper": 8, "../instances": 20, "../update-geometry": 21, "../update-scroll": 22 }], 13: [function (require, module, exports) {
    'use strict';

    var _ = require('../../lib/helper');
    var dom = require('../../lib/dom');
    var instances = require('../instances');
    var updateGeometry = require('../update-geometry');
    var updateScroll = require('../update-scroll');

    function bindMouseScrollXHandler(element, i) {
      var currentLeft = null;
      var currentPageX = null;

      function updateScrollLeft(deltaX) {
        var newLeft = currentLeft + deltaX * i.railXRatio;
        var maxLeft = Math.max(0, i.scrollbarXRail.getBoundingClientRect().left) + i.railXRatio * (i.railXWidth - i.scrollbarXWidth);

        if (newLeft < 0) {
          i.scrollbarXLeft = 0;
        } else if (newLeft > maxLeft) {
          i.scrollbarXLeft = maxLeft;
        } else {
          i.scrollbarXLeft = newLeft;
        }

        var scrollLeft = _.toInt(i.scrollbarXLeft * (i.contentWidth - i.containerWidth) / (i.containerWidth - i.railXRatio * i.scrollbarXWidth)) - i.negativeScrollAdjustment;
        updateScroll(element, 'left', scrollLeft);
      }

      var mouseMoveHandler = function mouseMoveHandler(e) {
        updateScrollLeft(e.pageX - currentPageX);
        updateGeometry(element);
        e.stopPropagation();
        e.preventDefault();
      };

      var mouseUpHandler = function mouseUpHandler() {
        _.stopScrolling(element, 'x');
        i.event.unbind(i.ownerDocument, 'mousemove', mouseMoveHandler);
      };

      i.event.bind(i.scrollbarX, 'mousedown', function (e) {
        currentPageX = e.pageX;
        currentLeft = _.toInt(dom.css(i.scrollbarX, 'left')) * i.railXRatio;
        _.startScrolling(element, 'x');

        i.event.bind(i.ownerDocument, 'mousemove', mouseMoveHandler);
        i.event.once(i.ownerDocument, 'mouseup', mouseUpHandler);

        e.stopPropagation();
        e.preventDefault();
      });
    }

    function bindMouseScrollYHandler(element, i) {
      var currentTop = null;
      var currentPageY = null;

      function updateScrollTop(deltaY) {
        var newTop = currentTop + deltaY * i.railYRatio;
        var maxTop = Math.max(0, i.scrollbarYRail.getBoundingClientRect().top) + i.railYRatio * (i.railYHeight - i.scrollbarYHeight);

        if (newTop < 0) {
          i.scrollbarYTop = 0;
        } else if (newTop > maxTop) {
          i.scrollbarYTop = maxTop;
        } else {
          i.scrollbarYTop = newTop;
        }

        var scrollTop = _.toInt(i.scrollbarYTop * (i.contentHeight - i.containerHeight) / (i.containerHeight - i.railYRatio * i.scrollbarYHeight));
        updateScroll(element, 'top', scrollTop);
      }

      var mouseMoveHandler = function mouseMoveHandler(e) {
        updateScrollTop(e.pageY - currentPageY);
        updateGeometry(element);
        e.stopPropagation();
        e.preventDefault();
      };

      var mouseUpHandler = function mouseUpHandler() {
        _.stopScrolling(element, 'y');
        i.event.unbind(i.ownerDocument, 'mousemove', mouseMoveHandler);
      };

      i.event.bind(i.scrollbarY, 'mousedown', function (e) {
        currentPageY = e.pageY;
        currentTop = _.toInt(dom.css(i.scrollbarY, 'top')) * i.railYRatio;
        _.startScrolling(element, 'y');

        i.event.bind(i.ownerDocument, 'mousemove', mouseMoveHandler);
        i.event.once(i.ownerDocument, 'mouseup', mouseUpHandler);

        e.stopPropagation();
        e.preventDefault();
      });
    }

    module.exports = function (element) {
      var i = instances.get(element);
      bindMouseScrollXHandler(element, i);
      bindMouseScrollYHandler(element, i);
    };
  }, { "../../lib/dom": 5, "../../lib/helper": 8, "../instances": 20, "../update-geometry": 21, "../update-scroll": 22 }], 14: [function (require, module, exports) {
    'use strict';

    var _ = require('../../lib/helper');
    var dom = require('../../lib/dom');
    var instances = require('../instances');
    var updateGeometry = require('../update-geometry');
    var updateScroll = require('../update-scroll');

    function bindKeyboardHandler(element, i) {
      var hovered = false;
      i.event.bind(element, 'mouseenter', function () {
        hovered = true;
      });
      i.event.bind(element, 'mouseleave', function () {
        hovered = false;
      });

      var shouldPrevent = false;
      function shouldPreventDefault(deltaX, deltaY) {
        var scrollTop = element.scrollTop;
        if (deltaX === 0) {
          if (!i.scrollbarYActive) {
            return false;
          }
          if (scrollTop === 0 && deltaY > 0 || scrollTop >= i.contentHeight - i.containerHeight && deltaY < 0) {
            return !i.settings.wheelPropagation;
          }
        }

        var scrollLeft = element.scrollLeft;
        if (deltaY === 0) {
          if (!i.scrollbarXActive) {
            return false;
          }
          if (scrollLeft === 0 && deltaX < 0 || scrollLeft >= i.contentWidth - i.containerWidth && deltaX > 0) {
            return !i.settings.wheelPropagation;
          }
        }
        return true;
      }

      i.event.bind(i.ownerDocument, 'keydown', function (e) {
        if (e.isDefaultPrevented && e.isDefaultPrevented() || e.defaultPrevented) {
          return;
        }

        var focused = dom.matches(i.scrollbarX, ':focus') || dom.matches(i.scrollbarY, ':focus');

        if (!hovered && !focused) {
          return;
        }

        var activeElement = document.activeElement ? document.activeElement : i.ownerDocument.activeElement;
        if (activeElement) {
          if (activeElement.tagName === 'IFRAME') {
            activeElement = activeElement.contentDocument.activeElement;
          } else {
            // go deeper if element is a webcomponent
            while (activeElement.shadowRoot) {
              activeElement = activeElement.shadowRoot.activeElement;
            }
          }
          if (_.isEditable(activeElement)) {
            return;
          }
        }

        var deltaX = 0;
        var deltaY = 0;

        switch (e.which) {
          case 37:
            // left
            deltaX = -30;
            break;
          case 38:
            // up
            deltaY = 30;
            break;
          case 39:
            // right
            deltaX = 30;
            break;
          case 40:
            // down
            deltaY = -30;
            break;
          case 33:
            // page up
            deltaY = 90;
            break;
          case 32:
            // space bar
            if (e.shiftKey) {
              deltaY = 90;
            } else {
              deltaY = -90;
            }
            break;
          case 34:
            // page down
            deltaY = -90;
            break;
          case 35:
            // end
            if (e.ctrlKey) {
              deltaY = -i.contentHeight;
            } else {
              deltaY = -i.containerHeight;
            }
            break;
          case 36:
            // home
            if (e.ctrlKey) {
              deltaY = element.scrollTop;
            } else {
              deltaY = i.containerHeight;
            }
            break;
          default:
            return;
        }

        updateScroll(element, 'top', element.scrollTop - deltaY);
        updateScroll(element, 'left', element.scrollLeft + deltaX);
        updateGeometry(element);

        shouldPrevent = shouldPreventDefault(deltaX, deltaY);
        if (shouldPrevent) {
          e.preventDefault();
        }
      });
    }

    module.exports = function (element) {
      var i = instances.get(element);
      bindKeyboardHandler(element, i);
    };
  }, { "../../lib/dom": 5, "../../lib/helper": 8, "../instances": 20, "../update-geometry": 21, "../update-scroll": 22 }], 15: [function (require, module, exports) {
    'use strict';

    var instances = require('../instances');
    var updateGeometry = require('../update-geometry');
    var updateScroll = require('../update-scroll');

    function bindMouseWheelHandler(element, i) {
      var shouldPrevent = false;

      function shouldPreventDefault(deltaX, deltaY) {
        var scrollTop = element.scrollTop;
        if (deltaX === 0) {
          if (!i.scrollbarYActive) {
            return false;
          }
          if (scrollTop === 0 && deltaY > 0 || scrollTop >= i.contentHeight - i.containerHeight && deltaY < 0) {
            return !i.settings.wheelPropagation;
          }
        }

        var scrollLeft = element.scrollLeft;
        if (deltaY === 0) {
          if (!i.scrollbarXActive) {
            return false;
          }
          if (scrollLeft === 0 && deltaX < 0 || scrollLeft >= i.contentWidth - i.containerWidth && deltaX > 0) {
            return !i.settings.wheelPropagation;
          }
        }
        return true;
      }

      function getDeltaFromEvent(e) {
        var deltaX = e.deltaX;
        var deltaY = -1 * e.deltaY;

        if (typeof deltaX === "undefined" || typeof deltaY === "undefined") {
          // OS X Safari
          deltaX = -1 * e.wheelDeltaX / 6;
          deltaY = e.wheelDeltaY / 6;
        }

        if (e.deltaMode && e.deltaMode === 1) {
          // Firefox in deltaMode 1: Line scrolling
          deltaX *= 10;
          deltaY *= 10;
        }

        if (deltaX !== deltaX && deltaY !== deltaY /* NaN checks */) {
            // IE in some mouse drivers
            deltaX = 0;
            deltaY = e.wheelDelta;
          }

        return [deltaX, deltaY];
      }

      function shouldBeConsumedByChild(deltaX, deltaY) {
        var child = element.querySelector('textarea:hover, select[multiple]:hover, .ps-child:hover');
        if (child) {
          if (child.tagName !== 'TEXTAREA' && !window.getComputedStyle(child).overflow.match(/(scroll|auto)/)) {
            return false;
          }

          var maxScrollTop = child.scrollHeight - child.clientHeight;
          if (maxScrollTop > 0) {
            if (!(child.scrollTop === 0 && deltaY > 0) && !(child.scrollTop === maxScrollTop && deltaY < 0)) {
              return true;
            }
          }
          var maxScrollLeft = child.scrollLeft - child.clientWidth;
          if (maxScrollLeft > 0) {
            if (!(child.scrollLeft === 0 && deltaX < 0) && !(child.scrollLeft === maxScrollLeft && deltaX > 0)) {
              return true;
            }
          }
        }
        return false;
      }

      function mousewheelHandler(e) {
        var delta = getDeltaFromEvent(e);

        var deltaX = delta[0];
        var deltaY = delta[1];

        if (shouldBeConsumedByChild(deltaX, deltaY)) {
          return;
        }

        shouldPrevent = false;
        if (!i.settings.useBothWheelAxes) {
          // deltaX will only be used for horizontal scrolling and deltaY will
          // only be used for vertical scrolling - this is the default
          updateScroll(element, 'top', element.scrollTop - deltaY * i.settings.wheelSpeed);
          updateScroll(element, 'left', element.scrollLeft + deltaX * i.settings.wheelSpeed);
        } else if (i.scrollbarYActive && !i.scrollbarXActive) {
          // only vertical scrollbar is active and useBothWheelAxes option is
          // active, so let's scroll vertical bar using both mouse wheel axes
          if (deltaY) {
            updateScroll(element, 'top', element.scrollTop - deltaY * i.settings.wheelSpeed);
          } else {
            updateScroll(element, 'top', element.scrollTop + deltaX * i.settings.wheelSpeed);
          }
          shouldPrevent = true;
        } else if (i.scrollbarXActive && !i.scrollbarYActive) {
          // useBothWheelAxes and only horizontal bar is active, so use both
          // wheel axes for horizontal bar
          if (deltaX) {
            updateScroll(element, 'left', element.scrollLeft + deltaX * i.settings.wheelSpeed);
          } else {
            updateScroll(element, 'left', element.scrollLeft - deltaY * i.settings.wheelSpeed);
          }
          shouldPrevent = true;
        }

        updateGeometry(element);

        shouldPrevent = shouldPrevent || shouldPreventDefault(deltaX, deltaY);
        if (shouldPrevent) {
          e.stopPropagation();
          e.preventDefault();
        }
      }

      if (typeof window.onwheel !== "undefined") {
        i.event.bind(element, 'wheel', mousewheelHandler);
      } else if (typeof window.onmousewheel !== "undefined") {
        i.event.bind(element, 'mousewheel', mousewheelHandler);
      }
    }

    module.exports = function (element) {
      var i = instances.get(element);
      bindMouseWheelHandler(element, i);
    };
  }, { "../instances": 20, "../update-geometry": 21, "../update-scroll": 22 }], 16: [function (require, module, exports) {
    'use strict';

    var instances = require('../instances');
    var updateGeometry = require('../update-geometry');

    function bindNativeScrollHandler(element, i) {
      i.event.bind(element, 'scroll', function () {
        updateGeometry(element);
      });
    }

    module.exports = function (element) {
      var i = instances.get(element);
      bindNativeScrollHandler(element, i);
    };
  }, { "../instances": 20, "../update-geometry": 21 }], 17: [function (require, module, exports) {
    'use strict';

    var _ = require('../../lib/helper');
    var instances = require('../instances');
    var updateGeometry = require('../update-geometry');
    var updateScroll = require('../update-scroll');

    function bindSelectionHandler(element, i) {
      function getRangeNode() {
        var selection = window.getSelection ? window.getSelection() : document.getSelection ? document.getSelection() : '';
        if (selection.toString().length === 0) {
          return null;
        } else {
          return selection.getRangeAt(0).commonAncestorContainer;
        }
      }

      var scrollingLoop = null;
      var scrollDiff = { top: 0, left: 0 };
      function startScrolling() {
        if (!scrollingLoop) {
          scrollingLoop = setInterval(function () {
            if (!instances.get(element)) {
              clearInterval(scrollingLoop);
              return;
            }

            updateScroll(element, 'top', element.scrollTop + scrollDiff.top);
            updateScroll(element, 'left', element.scrollLeft + scrollDiff.left);
            updateGeometry(element);
          }, 50); // every .1 sec
        }
      }
      function stopScrolling() {
        if (scrollingLoop) {
          clearInterval(scrollingLoop);
          scrollingLoop = null;
        }
        _.stopScrolling(element);
      }

      var isSelected = false;
      i.event.bind(i.ownerDocument, 'selectionchange', function () {
        if (element.contains(getRangeNode())) {
          isSelected = true;
        } else {
          isSelected = false;
          stopScrolling();
        }
      });
      i.event.bind(window, 'mouseup', function () {
        if (isSelected) {
          isSelected = false;
          stopScrolling();
        }
      });

      i.event.bind(window, 'mousemove', function (e) {
        if (isSelected) {
          var mousePosition = { x: e.pageX, y: e.pageY };
          var containerGeometry = {
            left: element.offsetLeft,
            right: element.offsetLeft + element.offsetWidth,
            top: element.offsetTop,
            bottom: element.offsetTop + element.offsetHeight
          };

          if (mousePosition.x < containerGeometry.left + 3) {
            scrollDiff.left = -5;
            _.startScrolling(element, 'x');
          } else if (mousePosition.x > containerGeometry.right - 3) {
            scrollDiff.left = 5;
            _.startScrolling(element, 'x');
          } else {
            scrollDiff.left = 0;
          }

          if (mousePosition.y < containerGeometry.top + 3) {
            if (containerGeometry.top + 3 - mousePosition.y < 5) {
              scrollDiff.top = -5;
            } else {
              scrollDiff.top = -20;
            }
            _.startScrolling(element, 'y');
          } else if (mousePosition.y > containerGeometry.bottom - 3) {
            if (mousePosition.y - containerGeometry.bottom + 3 < 5) {
              scrollDiff.top = 5;
            } else {
              scrollDiff.top = 20;
            }
            _.startScrolling(element, 'y');
          } else {
            scrollDiff.top = 0;
          }

          if (scrollDiff.top === 0 && scrollDiff.left === 0) {
            stopScrolling();
          } else {
            startScrolling();
          }
        }
      });
    }

    module.exports = function (element) {
      var i = instances.get(element);
      bindSelectionHandler(element, i);
    };
  }, { "../../lib/helper": 8, "../instances": 20, "../update-geometry": 21, "../update-scroll": 22 }], 18: [function (require, module, exports) {
    'use strict';

    var _ = require('../../lib/helper');
    var instances = require('../instances');
    var updateGeometry = require('../update-geometry');
    var updateScroll = require('../update-scroll');

    function bindTouchHandler(element, i, supportsTouch, supportsIePointer) {
      function shouldPreventDefault(deltaX, deltaY) {
        var scrollTop = element.scrollTop;
        var scrollLeft = element.scrollLeft;
        var magnitudeX = Math.abs(deltaX);
        var magnitudeY = Math.abs(deltaY);

        if (magnitudeY > magnitudeX) {
          // user is perhaps trying to swipe up/down the page

          if (deltaY < 0 && scrollTop === i.contentHeight - i.containerHeight || deltaY > 0 && scrollTop === 0) {
            return !i.settings.swipePropagation;
          }
        } else if (magnitudeX > magnitudeY) {
          // user is perhaps trying to swipe left/right across the page

          if (deltaX < 0 && scrollLeft === i.contentWidth - i.containerWidth || deltaX > 0 && scrollLeft === 0) {
            return !i.settings.swipePropagation;
          }
        }

        return true;
      }

      function applyTouchMove(differenceX, differenceY) {
        updateScroll(element, 'top', element.scrollTop - differenceY);
        updateScroll(element, 'left', element.scrollLeft - differenceX);

        updateGeometry(element);
      }

      var startOffset = {};
      var startTime = 0;
      var speed = {};
      var easingLoop = null;
      var inGlobalTouch = false;
      var inLocalTouch = false;

      function globalTouchStart() {
        inGlobalTouch = true;
      }
      function globalTouchEnd() {
        inGlobalTouch = false;
      }

      function getTouch(e) {
        if (e.targetTouches) {
          return e.targetTouches[0];
        } else {
          // Maybe IE pointer
          return e;
        }
      }
      function shouldHandle(e) {
        if (e.targetTouches && e.targetTouches.length === 1) {
          return true;
        }
        if (e.pointerType && e.pointerType !== 'mouse' && e.pointerType !== e.MSPOINTER_TYPE_MOUSE) {
          return true;
        }
        return false;
      }
      function touchStart(e) {
        if (shouldHandle(e)) {
          inLocalTouch = true;

          var touch = getTouch(e);

          startOffset.pageX = touch.pageX;
          startOffset.pageY = touch.pageY;

          startTime = new Date().getTime();

          if (easingLoop !== null) {
            clearInterval(easingLoop);
          }

          e.stopPropagation();
        }
      }
      function touchMove(e) {
        if (!inLocalTouch && i.settings.swipePropagation) {
          touchStart(e);
        }
        if (!inGlobalTouch && inLocalTouch && shouldHandle(e)) {
          var touch = getTouch(e);

          var currentOffset = { pageX: touch.pageX, pageY: touch.pageY };

          var differenceX = currentOffset.pageX - startOffset.pageX;
          var differenceY = currentOffset.pageY - startOffset.pageY;

          applyTouchMove(differenceX, differenceY);
          startOffset = currentOffset;

          var currentTime = new Date().getTime();

          var timeGap = currentTime - startTime;
          if (timeGap > 0) {
            speed.x = differenceX / timeGap;
            speed.y = differenceY / timeGap;
            startTime = currentTime;
          }

          if (shouldPreventDefault(differenceX, differenceY)) {
            e.stopPropagation();
            e.preventDefault();
          }
        }
      }
      function touchEnd() {
        if (!inGlobalTouch && inLocalTouch) {
          inLocalTouch = false;

          clearInterval(easingLoop);
          easingLoop = setInterval(function () {
            if (!instances.get(element)) {
              clearInterval(easingLoop);
              return;
            }

            if (Math.abs(speed.x) < 0.01 && Math.abs(speed.y) < 0.01) {
              clearInterval(easingLoop);
              return;
            }

            applyTouchMove(speed.x * 30, speed.y * 30);

            speed.x *= 0.8;
            speed.y *= 0.8;
          }, 10);
        }
      }

      if (supportsTouch) {
        i.event.bind(window, 'touchstart', globalTouchStart);
        i.event.bind(window, 'touchend', globalTouchEnd);
        i.event.bind(element, 'touchstart', touchStart);
        i.event.bind(element, 'touchmove', touchMove);
        i.event.bind(element, 'touchend', touchEnd);
      }

      if (supportsIePointer) {
        if (window.PointerEvent) {
          i.event.bind(window, 'pointerdown', globalTouchStart);
          i.event.bind(window, 'pointerup', globalTouchEnd);
          i.event.bind(element, 'pointerdown', touchStart);
          i.event.bind(element, 'pointermove', touchMove);
          i.event.bind(element, 'pointerup', touchEnd);
        } else if (window.MSPointerEvent) {
          i.event.bind(window, 'MSPointerDown', globalTouchStart);
          i.event.bind(window, 'MSPointerUp', globalTouchEnd);
          i.event.bind(element, 'MSPointerDown', touchStart);
          i.event.bind(element, 'MSPointerMove', touchMove);
          i.event.bind(element, 'MSPointerUp', touchEnd);
        }
      }
    }

    module.exports = function (element) {
      if (!_.env.supportsTouch && !_.env.supportsIePointer) {
        return;
      }

      var i = instances.get(element);
      bindTouchHandler(element, i, _.env.supportsTouch, _.env.supportsIePointer);
    };
  }, { "../../lib/helper": 8, "../instances": 20, "../update-geometry": 21, "../update-scroll": 22 }], 19: [function (require, module, exports) {
    'use strict';

    var _ = require('../lib/helper');
    var cls = require('../lib/class');
    var instances = require('./instances');
    var updateGeometry = require('./update-geometry');

    // Handlers
    var handlers = {
      'click-rail': require('./handler/click-rail'),
      'drag-scrollbar': require('./handler/drag-scrollbar'),
      'keyboard': require('./handler/keyboard'),
      'wheel': require('./handler/mouse-wheel'),
      'touch': require('./handler/touch'),
      'selection': require('./handler/selection')
    };
    var nativeScrollHandler = require('./handler/native-scroll');

    module.exports = function (element, userSettings) {
      userSettings = (typeof userSettings === "undefined" ? "undefined" : _typeof(userSettings)) === 'object' ? userSettings : {};

      cls.add(element, 'ps-container');

      // Create a plugin instance.
      var i = instances.add(element);

      i.settings = _.extend(i.settings, userSettings);
      cls.add(element, 'ps-theme-' + i.settings.theme);

      i.settings.handlers.forEach(function (handlerName) {
        handlers[handlerName](element);
      });

      nativeScrollHandler(element);

      updateGeometry(element);
    };
  }, { "../lib/class": 4, "../lib/helper": 8, "./handler/click-rail": 12, "./handler/drag-scrollbar": 13, "./handler/keyboard": 14, "./handler/mouse-wheel": 15, "./handler/native-scroll": 16, "./handler/selection": 17, "./handler/touch": 18, "./instances": 20, "./update-geometry": 21 }], 20: [function (require, module, exports) {
    'use strict';

    var _ = require('../lib/helper');
    var cls = require('../lib/class');
    var defaultSettings = require('./default-setting');
    var dom = require('../lib/dom');
    var EventManager = require('../lib/event-manager');
    var guid = require('../lib/guid');

    var instances = {};

    function Instance(element) {
      var i = this;

      i.settings = _.clone(defaultSettings);
      i.containerWidth = null;
      i.containerHeight = null;
      i.contentWidth = null;
      i.contentHeight = null;

      i.isRtl = dom.css(element, 'direction') === "rtl";
      i.isNegativeScroll = function () {
        var originalScrollLeft = element.scrollLeft;
        var result = null;
        element.scrollLeft = -1;
        result = element.scrollLeft < 0;
        element.scrollLeft = originalScrollLeft;
        return result;
      }();
      i.negativeScrollAdjustment = i.isNegativeScroll ? element.scrollWidth - element.clientWidth : 0;
      i.event = new EventManager();
      i.ownerDocument = element.ownerDocument || document;

      function focus() {
        cls.add(element, 'ps-focus');
      }

      function blur() {
        cls.remove(element, 'ps-focus');
      }

      i.scrollbarXRail = dom.appendTo(dom.e('div', 'ps-scrollbar-x-rail'), element);
      i.scrollbarX = dom.appendTo(dom.e('div', 'ps-scrollbar-x'), i.scrollbarXRail);
      i.scrollbarX.setAttribute('tabindex', 0);
      i.event.bind(i.scrollbarX, 'focus', focus);
      i.event.bind(i.scrollbarX, 'blur', blur);
      i.scrollbarXActive = null;
      i.scrollbarXWidth = null;
      i.scrollbarXLeft = null;
      i.scrollbarXBottom = _.toInt(dom.css(i.scrollbarXRail, 'bottom'));
      i.isScrollbarXUsingBottom = i.scrollbarXBottom === i.scrollbarXBottom; // !isNaN
      i.scrollbarXTop = i.isScrollbarXUsingBottom ? null : _.toInt(dom.css(i.scrollbarXRail, 'top'));
      i.railBorderXWidth = _.toInt(dom.css(i.scrollbarXRail, 'borderLeftWidth')) + _.toInt(dom.css(i.scrollbarXRail, 'borderRightWidth'));
      // Set rail to display:block to calculate margins
      dom.css(i.scrollbarXRail, 'display', 'block');
      i.railXMarginWidth = _.toInt(dom.css(i.scrollbarXRail, 'marginLeft')) + _.toInt(dom.css(i.scrollbarXRail, 'marginRight'));
      dom.css(i.scrollbarXRail, 'display', '');
      i.railXWidth = null;
      i.railXRatio = null;

      i.scrollbarYRail = dom.appendTo(dom.e('div', 'ps-scrollbar-y-rail'), element);
      i.scrollbarY = dom.appendTo(dom.e('div', 'ps-scrollbar-y'), i.scrollbarYRail);
      i.scrollbarY.setAttribute('tabindex', 0);
      i.event.bind(i.scrollbarY, 'focus', focus);
      i.event.bind(i.scrollbarY, 'blur', blur);
      i.scrollbarYActive = null;
      i.scrollbarYHeight = null;
      i.scrollbarYTop = null;
      i.scrollbarYRight = _.toInt(dom.css(i.scrollbarYRail, 'right'));
      i.isScrollbarYUsingRight = i.scrollbarYRight === i.scrollbarYRight; // !isNaN
      i.scrollbarYLeft = i.isScrollbarYUsingRight ? null : _.toInt(dom.css(i.scrollbarYRail, 'left'));
      i.scrollbarYOuterWidth = i.isRtl ? _.outerWidth(i.scrollbarY) : null;
      i.railBorderYWidth = _.toInt(dom.css(i.scrollbarYRail, 'borderTopWidth')) + _.toInt(dom.css(i.scrollbarYRail, 'borderBottomWidth'));
      dom.css(i.scrollbarYRail, 'display', 'block');
      i.railYMarginHeight = _.toInt(dom.css(i.scrollbarYRail, 'marginTop')) + _.toInt(dom.css(i.scrollbarYRail, 'marginBottom'));
      dom.css(i.scrollbarYRail, 'display', '');
      i.railYHeight = null;
      i.railYRatio = null;
    }

    function getId(element) {
      return element.getAttribute('data-ps-id');
    }

    function setId(element, id) {
      element.setAttribute('data-ps-id', id);
    }

    function removeId(element) {
      element.removeAttribute('data-ps-id');
    }

    exports.add = function (element) {
      var newId = guid();
      setId(element, newId);
      instances[newId] = new Instance(element);
      return instances[newId];
    };

    exports.remove = function (element) {
      delete instances[getId(element)];
      removeId(element);
    };

    exports.get = function (element) {
      return instances[getId(element)];
    };
  }, { "../lib/class": 4, "../lib/dom": 5, "../lib/event-manager": 6, "../lib/guid": 7, "../lib/helper": 8, "./default-setting": 10 }], 21: [function (require, module, exports) {
    'use strict';

    var _ = require('../lib/helper');
    var cls = require('../lib/class');
    var dom = require('../lib/dom');
    var instances = require('./instances');
    var updateScroll = require('./update-scroll');

    function getThumbSize(i, thumbSize) {
      if (i.settings.minScrollbarLength) {
        thumbSize = Math.max(thumbSize, i.settings.minScrollbarLength);
      }
      if (i.settings.maxScrollbarLength) {
        thumbSize = Math.min(thumbSize, i.settings.maxScrollbarLength);
      }
      return thumbSize;
    }

    function updateCss(element, i) {
      var xRailOffset = { width: i.railXWidth };
      if (i.isRtl) {
        xRailOffset.left = i.negativeScrollAdjustment + element.scrollLeft + i.containerWidth - i.contentWidth;
      } else {
        xRailOffset.left = element.scrollLeft;
      }
      if (i.isScrollbarXUsingBottom) {
        xRailOffset.bottom = i.scrollbarXBottom - element.scrollTop;
      } else {
        xRailOffset.top = i.scrollbarXTop + element.scrollTop;
      }
      dom.css(i.scrollbarXRail, xRailOffset);

      var yRailOffset = { top: element.scrollTop, height: i.railYHeight };
      if (i.isScrollbarYUsingRight) {
        if (i.isRtl) {
          yRailOffset.right = i.contentWidth - (i.negativeScrollAdjustment + element.scrollLeft) - i.scrollbarYRight - i.scrollbarYOuterWidth;
        } else {
          yRailOffset.right = i.scrollbarYRight - element.scrollLeft;
        }
      } else {
        if (i.isRtl) {
          yRailOffset.left = i.negativeScrollAdjustment + element.scrollLeft + i.containerWidth * 2 - i.contentWidth - i.scrollbarYLeft - i.scrollbarYOuterWidth;
        } else {
          yRailOffset.left = i.scrollbarYLeft + element.scrollLeft;
        }
      }
      dom.css(i.scrollbarYRail, yRailOffset);

      dom.css(i.scrollbarX, { left: i.scrollbarXLeft, width: i.scrollbarXWidth - i.railBorderXWidth });
      dom.css(i.scrollbarY, { top: i.scrollbarYTop, height: i.scrollbarYHeight - i.railBorderYWidth });
    }

    module.exports = function (element) {
      var i = instances.get(element);

      i.containerWidth = element.clientWidth;
      i.containerHeight = element.clientHeight;
      i.contentWidth = element.scrollWidth;
      i.contentHeight = element.scrollHeight;

      var existingRails;
      if (!element.contains(i.scrollbarXRail)) {
        existingRails = dom.queryChildren(element, '.ps-scrollbar-x-rail');
        if (existingRails.length > 0) {
          existingRails.forEach(function (rail) {
            dom.remove(rail);
          });
        }
        dom.appendTo(i.scrollbarXRail, element);
      }
      if (!element.contains(i.scrollbarYRail)) {
        existingRails = dom.queryChildren(element, '.ps-scrollbar-y-rail');
        if (existingRails.length > 0) {
          existingRails.forEach(function (rail) {
            dom.remove(rail);
          });
        }
        dom.appendTo(i.scrollbarYRail, element);
      }

      if (!i.settings.suppressScrollX && i.containerWidth + i.settings.scrollXMarginOffset < i.contentWidth) {
        i.scrollbarXActive = true;
        i.railXWidth = i.containerWidth - i.railXMarginWidth;
        i.railXRatio = i.containerWidth / i.railXWidth;
        i.scrollbarXWidth = getThumbSize(i, _.toInt(i.railXWidth * i.containerWidth / i.contentWidth));
        i.scrollbarXLeft = _.toInt((i.negativeScrollAdjustment + element.scrollLeft) * (i.railXWidth - i.scrollbarXWidth) / (i.contentWidth - i.containerWidth));
      } else {
        i.scrollbarXActive = false;
      }

      if (!i.settings.suppressScrollY && i.containerHeight + i.settings.scrollYMarginOffset < i.contentHeight) {
        i.scrollbarYActive = true;
        i.railYHeight = i.containerHeight - i.railYMarginHeight;
        i.railYRatio = i.containerHeight / i.railYHeight;
        i.scrollbarYHeight = getThumbSize(i, _.toInt(i.railYHeight * i.containerHeight / i.contentHeight));
        i.scrollbarYTop = _.toInt(element.scrollTop * (i.railYHeight - i.scrollbarYHeight) / (i.contentHeight - i.containerHeight));
      } else {
        i.scrollbarYActive = false;
      }

      if (i.scrollbarXLeft >= i.railXWidth - i.scrollbarXWidth) {
        i.scrollbarXLeft = i.railXWidth - i.scrollbarXWidth;
      }
      if (i.scrollbarYTop >= i.railYHeight - i.scrollbarYHeight) {
        i.scrollbarYTop = i.railYHeight - i.scrollbarYHeight;
      }

      updateCss(element, i);

      if (i.scrollbarXActive) {
        cls.add(element, 'ps-active-x');
      } else {
        cls.remove(element, 'ps-active-x');
        i.scrollbarXWidth = 0;
        i.scrollbarXLeft = 0;
        updateScroll(element, 'left', 0);
      }
      if (i.scrollbarYActive) {
        cls.add(element, 'ps-active-y');
      } else {
        cls.remove(element, 'ps-active-y');
        i.scrollbarYHeight = 0;
        i.scrollbarYTop = 0;
        updateScroll(element, 'top', 0);
      }
    };
  }, { "../lib/class": 4, "../lib/dom": 5, "../lib/helper": 8, "./instances": 20, "./update-scroll": 22 }], 22: [function (require, module, exports) {
    'use strict';

    var instances = require('./instances');

    var upEvent = document.createEvent('Event');
    var downEvent = document.createEvent('Event');
    var leftEvent = document.createEvent('Event');
    var rightEvent = document.createEvent('Event');
    var yEvent = document.createEvent('Event');
    var xEvent = document.createEvent('Event');
    var xStartEvent = document.createEvent('Event');
    var xEndEvent = document.createEvent('Event');
    var yStartEvent = document.createEvent('Event');
    var yEndEvent = document.createEvent('Event');
    var lastTop;
    var lastLeft;

    upEvent.initEvent('ps-scroll-up', true, true);
    downEvent.initEvent('ps-scroll-down', true, true);
    leftEvent.initEvent('ps-scroll-left', true, true);
    rightEvent.initEvent('ps-scroll-right', true, true);
    yEvent.initEvent('ps-scroll-y', true, true);
    xEvent.initEvent('ps-scroll-x', true, true);
    xStartEvent.initEvent('ps-x-reach-start', true, true);
    xEndEvent.initEvent('ps-x-reach-end', true, true);
    yStartEvent.initEvent('ps-y-reach-start', true, true);
    yEndEvent.initEvent('ps-y-reach-end', true, true);

    module.exports = function (element, axis, value) {
      if (typeof element === 'undefined') {
        throw 'You must provide an element to the update-scroll function';
      }

      if (typeof axis === 'undefined') {
        throw 'You must provide an axis to the update-scroll function';
      }

      if (typeof value === 'undefined') {
        throw 'You must provide a value to the update-scroll function';
      }

      if (axis === 'top' && value <= 0) {
        element.scrollTop = value = 0; // don't allow negative scroll
        element.dispatchEvent(yStartEvent);
      }

      if (axis === 'left' && value <= 0) {
        element.scrollLeft = value = 0; // don't allow negative scroll
        element.dispatchEvent(xStartEvent);
      }

      var i = instances.get(element);

      if (axis === 'top' && value >= i.contentHeight - i.containerHeight) {
        // don't allow scroll past container
        value = i.contentHeight - i.containerHeight;
        if (value - element.scrollTop <= 1) {
          // mitigates rounding errors on non-subpixel scroll values
          value = element.scrollTop;
        } else {
          element.scrollTop = value;
        }
        element.dispatchEvent(yEndEvent);
      }

      if (axis === 'left' && value >= i.contentWidth - i.containerWidth) {
        // don't allow scroll past container
        value = i.contentWidth - i.containerWidth;
        if (value - element.scrollLeft <= 1) {
          // mitigates rounding errors on non-subpixel scroll values
          value = element.scrollLeft;
        } else {
          element.scrollLeft = value;
        }
        element.dispatchEvent(xEndEvent);
      }

      if (!lastTop) {
        lastTop = element.scrollTop;
      }

      if (!lastLeft) {
        lastLeft = element.scrollLeft;
      }

      if (axis === 'top' && value < lastTop) {
        element.dispatchEvent(upEvent);
      }

      if (axis === 'top' && value > lastTop) {
        element.dispatchEvent(downEvent);
      }

      if (axis === 'left' && value < lastLeft) {
        element.dispatchEvent(leftEvent);
      }

      if (axis === 'left' && value > lastLeft) {
        element.dispatchEvent(rightEvent);
      }

      if (axis === 'top') {
        element.scrollTop = lastTop = value;
        element.dispatchEvent(yEvent);
      }

      if (axis === 'left') {
        element.scrollLeft = lastLeft = value;
        element.dispatchEvent(xEvent);
      }
    };
  }, { "./instances": 20 }], 23: [function (require, module, exports) {
    'use strict';

    var _ = require('../lib/helper');
    var dom = require('../lib/dom');
    var instances = require('./instances');
    var updateGeometry = require('./update-geometry');
    var updateScroll = require('./update-scroll');

    module.exports = function (element) {
      var i = instances.get(element);

      if (!i) {
        return;
      }

      // Recalcuate negative scrollLeft adjustment
      i.negativeScrollAdjustment = i.isNegativeScroll ? element.scrollWidth - element.clientWidth : 0;

      // Recalculate rail margins
      dom.css(i.scrollbarXRail, 'display', 'block');
      dom.css(i.scrollbarYRail, 'display', 'block');
      i.railXMarginWidth = _.toInt(dom.css(i.scrollbarXRail, 'marginLeft')) + _.toInt(dom.css(i.scrollbarXRail, 'marginRight'));
      i.railYMarginHeight = _.toInt(dom.css(i.scrollbarYRail, 'marginTop')) + _.toInt(dom.css(i.scrollbarYRail, 'marginBottom'));

      // Hide scrollbars not to affect scrollWidth and scrollHeight
      dom.css(i.scrollbarXRail, 'display', 'none');
      dom.css(i.scrollbarYRail, 'display', 'none');

      updateGeometry(element);

      // Update top/left scroll to trigger events
      updateScroll(element, 'top', element.scrollTop);
      updateScroll(element, 'left', element.scrollLeft);

      dom.css(i.scrollbarXRail, 'display', '');
      dom.css(i.scrollbarYRail, 'display', '');
    };
  }, { "../lib/dom": 5, "../lib/helper": 8, "./instances": 20, "./update-geometry": 21, "./update-scroll": 22 }] }, {}, [1]);
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3), __webpack_require__(1)))

/***/ }),
/* 55 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

/*
 _ _      _       _
 ___| (_) ___| | __  (_)___
 / __| | |/ __| |/ /  | / __|
 \__ \ | | (__|   < _ | \__ \
 |___/_|_|\___|_|\_(_)/ |___/
 |__/

 Version: 1.5.9
 Author: Ken Wheeler
 Website: http://kenwheeler.github.io
 Docs: http://kenwheeler.github.io/slick
 Repo: http://github.com/kenwheeler/slick
 Issues: http://github.com/kenwheeler/slick/issues

 */
!function (a) {
  "use strict";
   true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(1)], __WEBPACK_AMD_DEFINE_FACTORY__ = (a),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : "undefined" != typeof exports ? module.exports = a(require("jquery")) : a(jQuery);
}(function (a) {
  "use strict";
  var b = window.Slick || {};b = function () {
    function c(c, d) {
      var f,
          e = this;e.defaults = { accessibility: !0, adaptiveHeight: !1, appendArrows: a(c), appendDots: a(c), arrows: !0, asNavFor: null, prevArrow: '<button type="button" data-role="none" class="slick-prev" aria-label="Previous" tabindex="0" role="button">Previous</button>', nextArrow: '<button type="button" data-role="none" class="slick-next" aria-label="Next" tabindex="0" role="button">Next</button>', autoplay: !1, autoplaySpeed: 3e3, centerMode: !1, centerPadding: "50px", cssEase: "ease", customPaging: function customPaging(a, b) {
          return '<button type="button" data-role="none" role="button" aria-required="false" tabindex="0">' + (b + 1) + "</button>";
        }, dots: !1, dotsClass: "slick-dots", draggable: !0, easing: "linear", edgeFriction: .35, fade: !1, focusOnSelect: !1, infinite: !0, initialSlide: 0, lazyLoad: "ondemand", mobileFirst: !1, pauseOnHover: !0, pauseOnDotsHover: !1, respondTo: "window", responsive: null, rows: 1, rtl: !1, slide: "", slidesPerRow: 1, slidesToShow: 1, slidesToScroll: 1, speed: 500, swipe: !0, swipeToSlide: !1, touchMove: !0, touchThreshold: 5, useCSS: !0, useTransform: !1, variableWidth: !1, vertical: !1, verticalSwiping: !1, waitForAnimate: !0, zIndex: 1e3 }, e.initials = { animating: !1, dragging: !1, autoPlayTimer: null, currentDirection: 0, currentLeft: null, currentSlide: 0, direction: 1, $dots: null, listWidth: null, listHeight: null, loadIndex: 0, $nextArrow: null, $prevArrow: null, slideCount: null, slideWidth: null, $slideTrack: null, $slides: null, sliding: !1, slideOffset: 0, swipeLeft: null, $list: null, touchObject: {}, transformsEnabled: !1, unslicked: !1 }, a.extend(e, e.initials), e.activeBreakpoint = null, e.animType = null, e.animProp = null, e.breakpoints = [], e.breakpointSettings = [], e.cssTransitions = !1, e.hidden = "hidden", e.paused = !1, e.positionProp = null, e.respondTo = null, e.rowCount = 1, e.shouldClick = !0, e.$slider = a(c), e.$slidesCache = null, e.transformType = null, e.transitionType = null, e.visibilityChange = "visibilitychange", e.windowWidth = 0, e.windowTimer = null, f = a(c).data("slick") || {}, e.options = a.extend({}, e.defaults, f, d), e.currentSlide = e.options.initialSlide, e.originalSettings = e.options, "undefined" != typeof document.mozHidden ? (e.hidden = "mozHidden", e.visibilityChange = "mozvisibilitychange") : "undefined" != typeof document.webkitHidden && (e.hidden = "webkitHidden", e.visibilityChange = "webkitvisibilitychange"), e.autoPlay = a.proxy(e.autoPlay, e), e.autoPlayClear = a.proxy(e.autoPlayClear, e), e.changeSlide = a.proxy(e.changeSlide, e), e.clickHandler = a.proxy(e.clickHandler, e), e.selectHandler = a.proxy(e.selectHandler, e), e.setPosition = a.proxy(e.setPosition, e), e.swipeHandler = a.proxy(e.swipeHandler, e), e.dragHandler = a.proxy(e.dragHandler, e), e.keyHandler = a.proxy(e.keyHandler, e), e.autoPlayIterator = a.proxy(e.autoPlayIterator, e), e.instanceUid = b++, e.htmlExpr = /^(?:\s*(<[\w\W]+>)[^>]*)$/, e.registerBreakpoints(), e.init(!0), e.checkResponsive(!0);
    }var b = 0;return c;
  }(), b.prototype.addSlide = b.prototype.slickAdd = function (b, c, d) {
    var e = this;if ("boolean" == typeof c) d = c, c = null;else if (0 > c || c >= e.slideCount) return !1;e.unload(), "number" == typeof c ? 0 === c && 0 === e.$slides.length ? a(b).appendTo(e.$slideTrack) : d ? a(b).insertBefore(e.$slides.eq(c)) : a(b).insertAfter(e.$slides.eq(c)) : d === !0 ? a(b).prependTo(e.$slideTrack) : a(b).appendTo(e.$slideTrack), e.$slides = e.$slideTrack.children(this.options.slide), e.$slideTrack.children(this.options.slide).detach(), e.$slideTrack.append(e.$slides), e.$slides.each(function (b, c) {
      a(c).attr("data-slick-index", b);
    }), e.$slidesCache = e.$slides, e.reinit();
  }, b.prototype.animateHeight = function () {
    var a = this;if (1 === a.options.slidesToShow && a.options.adaptiveHeight === !0 && a.options.vertical === !1) {
      var b = a.$slides.eq(a.currentSlide).outerHeight(!0);a.$list.animate({ height: b }, a.options.speed);
    }
  }, b.prototype.animateSlide = function (b, c) {
    var d = {},
        e = this;e.animateHeight(), e.options.rtl === !0 && e.options.vertical === !1 && (b = -b), e.transformsEnabled === !1 ? e.options.vertical === !1 ? e.$slideTrack.animate({ left: b }, e.options.speed, e.options.easing, c) : e.$slideTrack.animate({ top: b }, e.options.speed, e.options.easing, c) : e.cssTransitions === !1 ? (e.options.rtl === !0 && (e.currentLeft = -e.currentLeft), a({ animStart: e.currentLeft }).animate({ animStart: b }, { duration: e.options.speed, easing: e.options.easing, step: function step(a) {
        a = Math.ceil(a), e.options.vertical === !1 ? (d[e.animType] = "translate(" + a + "px, 0px)", e.$slideTrack.css(d)) : (d[e.animType] = "translate(0px," + a + "px)", e.$slideTrack.css(d));
      }, complete: function complete() {
        c && c.call();
      } })) : (e.applyTransition(), b = Math.ceil(b), e.options.vertical === !1 ? d[e.animType] = "translate3d(" + b + "px, 0px, 0px)" : d[e.animType] = "translate3d(0px," + b + "px, 0px)", e.$slideTrack.css(d), c && setTimeout(function () {
      e.disableTransition(), c.call();
    }, e.options.speed));
  }, b.prototype.asNavFor = function (b) {
    var c = this,
        d = c.options.asNavFor;d && null !== d && (d = a(d).not(c.$slider)), null !== d && "object" == (typeof d === "undefined" ? "undefined" : _typeof(d)) && d.each(function () {
      var c = a(this).slick("getSlick");c.unslicked || c.slideHandler(b, !0);
    });
  }, b.prototype.applyTransition = function (a) {
    var b = this,
        c = {};b.options.fade === !1 ? c[b.transitionType] = b.transformType + " " + b.options.speed + "ms " + b.options.cssEase : c[b.transitionType] = "opacity " + b.options.speed + "ms " + b.options.cssEase, b.options.fade === !1 ? b.$slideTrack.css(c) : b.$slides.eq(a).css(c);
  }, b.prototype.autoPlay = function () {
    var a = this;a.autoPlayTimer && clearInterval(a.autoPlayTimer), a.slideCount > a.options.slidesToShow && a.paused !== !0 && (a.autoPlayTimer = setInterval(a.autoPlayIterator, a.options.autoplaySpeed));
  }, b.prototype.autoPlayClear = function () {
    var a = this;a.autoPlayTimer && clearInterval(a.autoPlayTimer);
  }, b.prototype.autoPlayIterator = function () {
    var a = this;a.options.infinite === !1 ? 1 === a.direction ? (a.currentSlide + 1 === a.slideCount - 1 && (a.direction = 0), a.slideHandler(a.currentSlide + a.options.slidesToScroll)) : (a.currentSlide - 1 === 0 && (a.direction = 1), a.slideHandler(a.currentSlide - a.options.slidesToScroll)) : a.slideHandler(a.currentSlide + a.options.slidesToScroll);
  }, b.prototype.buildArrows = function () {
    var b = this;b.options.arrows === !0 && (b.$prevArrow = a(b.options.prevArrow).addClass("slick-arrow"), b.$nextArrow = a(b.options.nextArrow).addClass("slick-arrow"), b.slideCount > b.options.slidesToShow ? (b.$prevArrow.removeClass("slick-hidden").removeAttr("aria-hidden tabindex"), b.$nextArrow.removeClass("slick-hidden").removeAttr("aria-hidden tabindex"), b.htmlExpr.test(b.options.prevArrow) && b.$prevArrow.prependTo(b.options.appendArrows), b.htmlExpr.test(b.options.nextArrow) && b.$nextArrow.appendTo(b.options.appendArrows), b.options.infinite !== !0 && b.$prevArrow.addClass("slick-disabled").attr("aria-disabled", "true")) : b.$prevArrow.add(b.$nextArrow).addClass("slick-hidden").attr({ "aria-disabled": "true", tabindex: "-1" }));
  }, b.prototype.buildDots = function () {
    var c,
        d,
        b = this;if (b.options.dots === !0 && b.slideCount > b.options.slidesToShow) {
      for (d = '<ul class="' + b.options.dotsClass + '">', c = 0; c <= b.getDotCount(); c += 1) {
        d += "<li>" + b.options.customPaging.call(this, b, c) + "</li>";
      }d += "</ul>", b.$dots = a(d).appendTo(b.options.appendDots), b.$dots.find("li").first().addClass("slick-active").attr("aria-hidden", "false");
    }
  }, b.prototype.buildOut = function () {
    var b = this;b.$slides = b.$slider.children(b.options.slide + ":not(.slick-cloned)").addClass("slick-slide"), b.slideCount = b.$slides.length, b.$slides.each(function (b, c) {
      a(c).attr("data-slick-index", b).data("originalStyling", a(c).attr("style") || "");
    }), b.$slider.addClass("slick-slider"), b.$slideTrack = 0 === b.slideCount ? a('<div class="slick-track"/>').appendTo(b.$slider) : b.$slides.wrapAll('<div class="slick-track"/>').parent(), b.$list = b.$slideTrack.wrap('<div aria-live="polite" class="slick-list"/>').parent(), b.$slideTrack.css("opacity", 0), (b.options.centerMode === !0 || b.options.swipeToSlide === !0) && (b.options.slidesToScroll = 1), a("img[data-lazy]", b.$slider).not("[src]").addClass("slick-loading"), b.setupInfinite(), b.buildArrows(), b.buildDots(), b.updateDots(), b.setSlideClasses("number" == typeof b.currentSlide ? b.currentSlide : 0), b.options.draggable === !0 && b.$list.addClass("draggable");
  }, b.prototype.buildRows = function () {
    var b,
        c,
        d,
        e,
        f,
        g,
        h,
        a = this;if (e = document.createDocumentFragment(), g = a.$slider.children(), a.options.rows > 1) {
      for (h = a.options.slidesPerRow * a.options.rows, f = Math.ceil(g.length / h), b = 0; f > b; b++) {
        var i = document.createElement("div");for (c = 0; c < a.options.rows; c++) {
          var j = document.createElement("div");for (d = 0; d < a.options.slidesPerRow; d++) {
            var k = b * h + (c * a.options.slidesPerRow + d);g.get(k) && j.appendChild(g.get(k));
          }i.appendChild(j);
        }e.appendChild(i);
      }a.$slider.html(e), a.$slider.children().children().children().css({ width: 100 / a.options.slidesPerRow + "%", display: "inline-block" });
    }
  }, b.prototype.checkResponsive = function (b, c) {
    var e,
        f,
        g,
        d = this,
        h = !1,
        i = d.$slider.width(),
        j = window.innerWidth || a(window).width();if ("window" === d.respondTo ? g = j : "slider" === d.respondTo ? g = i : "min" === d.respondTo && (g = Math.min(j, i)), d.options.responsive && d.options.responsive.length && null !== d.options.responsive) {
      f = null;for (e in d.breakpoints) {
        d.breakpoints.hasOwnProperty(e) && (d.originalSettings.mobileFirst === !1 ? g < d.breakpoints[e] && (f = d.breakpoints[e]) : g > d.breakpoints[e] && (f = d.breakpoints[e]));
      }null !== f ? null !== d.activeBreakpoint ? (f !== d.activeBreakpoint || c) && (d.activeBreakpoint = f, "unslick" === d.breakpointSettings[f] ? d.unslick(f) : (d.options = a.extend({}, d.originalSettings, d.breakpointSettings[f]), b === !0 && (d.currentSlide = d.options.initialSlide), d.refresh(b)), h = f) : (d.activeBreakpoint = f, "unslick" === d.breakpointSettings[f] ? d.unslick(f) : (d.options = a.extend({}, d.originalSettings, d.breakpointSettings[f]), b === !0 && (d.currentSlide = d.options.initialSlide), d.refresh(b)), h = f) : null !== d.activeBreakpoint && (d.activeBreakpoint = null, d.options = d.originalSettings, b === !0 && (d.currentSlide = d.options.initialSlide), d.refresh(b), h = f), b || h === !1 || d.$slider.trigger("breakpoint", [d, h]);
    }
  }, b.prototype.changeSlide = function (b, c) {
    var f,
        g,
        h,
        d = this,
        e = a(b.target);switch (e.is("a") && b.preventDefault(), e.is("li") || (e = e.closest("li")), h = d.slideCount % d.options.slidesToScroll !== 0, f = h ? 0 : (d.slideCount - d.currentSlide) % d.options.slidesToScroll, b.data.message) {case "previous":
        g = 0 === f ? d.options.slidesToScroll : d.options.slidesToShow - f, d.slideCount > d.options.slidesToShow && d.slideHandler(d.currentSlide - g, !1, c);break;case "next":
        g = 0 === f ? d.options.slidesToScroll : f, d.slideCount > d.options.slidesToShow && d.slideHandler(d.currentSlide + g, !1, c);break;case "index":
        var i = 0 === b.data.index ? 0 : b.data.index || e.index() * d.options.slidesToScroll;d.slideHandler(d.checkNavigable(i), !1, c), e.children().trigger("focus");break;default:
        return;}
  }, b.prototype.checkNavigable = function (a) {
    var c,
        d,
        b = this;if (c = b.getNavigableIndexes(), d = 0, a > c[c.length - 1]) a = c[c.length - 1];else for (var e in c) {
      if (a < c[e]) {
        a = d;break;
      }d = c[e];
    }return a;
  }, b.prototype.cleanUpEvents = function () {
    var b = this;b.options.dots && null !== b.$dots && (a("li", b.$dots).off("click.slick", b.changeSlide), b.options.pauseOnDotsHover === !0 && b.options.autoplay === !0 && a("li", b.$dots).off("mouseenter.slick", a.proxy(b.setPaused, b, !0)).off("mouseleave.slick", a.proxy(b.setPaused, b, !1))), b.options.arrows === !0 && b.slideCount > b.options.slidesToShow && (b.$prevArrow && b.$prevArrow.off("click.slick", b.changeSlide), b.$nextArrow && b.$nextArrow.off("click.slick", b.changeSlide)), b.$list.off("touchstart.slick mousedown.slick", b.swipeHandler), b.$list.off("touchmove.slick mousemove.slick", b.swipeHandler), b.$list.off("touchend.slick mouseup.slick", b.swipeHandler), b.$list.off("touchcancel.slick mouseleave.slick", b.swipeHandler), b.$list.off("click.slick", b.clickHandler), a(document).off(b.visibilityChange, b.visibility), b.$list.off("mouseenter.slick", a.proxy(b.setPaused, b, !0)), b.$list.off("mouseleave.slick", a.proxy(b.setPaused, b, !1)), b.options.accessibility === !0 && b.$list.off("keydown.slick", b.keyHandler), b.options.focusOnSelect === !0 && a(b.$slideTrack).children().off("click.slick", b.selectHandler), a(window).off("orientationchange.slick.slick-" + b.instanceUid, b.orientationChange), a(window).off("resize.slick.slick-" + b.instanceUid, b.resize), a("[draggable!=true]", b.$slideTrack).off("dragstart", b.preventDefault), a(window).off("load.slick.slick-" + b.instanceUid, b.setPosition), a(document).off("ready.slick.slick-" + b.instanceUid, b.setPosition);
  }, b.prototype.cleanUpRows = function () {
    var b,
        a = this;a.options.rows > 1 && (b = a.$slides.children().children(), b.removeAttr("style"), a.$slider.html(b));
  }, b.prototype.clickHandler = function (a) {
    var b = this;b.shouldClick === !1 && (a.stopImmediatePropagation(), a.stopPropagation(), a.preventDefault());
  }, b.prototype.destroy = function (b) {
    var c = this;c.autoPlayClear(), c.touchObject = {}, c.cleanUpEvents(), a(".slick-cloned", c.$slider).detach(), c.$dots && c.$dots.remove(), c.$prevArrow && c.$prevArrow.length && (c.$prevArrow.removeClass("slick-disabled slick-arrow slick-hidden").removeAttr("aria-hidden aria-disabled tabindex").css("display", ""), c.htmlExpr.test(c.options.prevArrow) && c.$prevArrow.remove()), c.$nextArrow && c.$nextArrow.length && (c.$nextArrow.removeClass("slick-disabled slick-arrow slick-hidden").removeAttr("aria-hidden aria-disabled tabindex").css("display", ""), c.htmlExpr.test(c.options.nextArrow) && c.$nextArrow.remove()), c.$slides && (c.$slides.removeClass("slick-slide slick-active slick-center slick-visible slick-current").removeAttr("aria-hidden").removeAttr("data-slick-index").each(function () {
      a(this).attr("style", a(this).data("originalStyling"));
    }), c.$slideTrack.children(this.options.slide).detach(), c.$slideTrack.detach(), c.$list.detach(), c.$slider.append(c.$slides)), c.cleanUpRows(), c.$slider.removeClass("slick-slider"), c.$slider.removeClass("slick-initialized"), c.unslicked = !0, b || c.$slider.trigger("destroy", [c]);
  }, b.prototype.disableTransition = function (a) {
    var b = this,
        c = {};c[b.transitionType] = "", b.options.fade === !1 ? b.$slideTrack.css(c) : b.$slides.eq(a).css(c);
  }, b.prototype.fadeSlide = function (a, b) {
    var c = this;c.cssTransitions === !1 ? (c.$slides.eq(a).css({ zIndex: c.options.zIndex }), c.$slides.eq(a).animate({ opacity: 1 }, c.options.speed, c.options.easing, b)) : (c.applyTransition(a), c.$slides.eq(a).css({ opacity: 1, zIndex: c.options.zIndex }), b && setTimeout(function () {
      c.disableTransition(a), b.call();
    }, c.options.speed));
  }, b.prototype.fadeSlideOut = function (a) {
    var b = this;b.cssTransitions === !1 ? b.$slides.eq(a).animate({ opacity: 0, zIndex: b.options.zIndex - 2 }, b.options.speed, b.options.easing) : (b.applyTransition(a), b.$slides.eq(a).css({ opacity: 0, zIndex: b.options.zIndex - 2 }));
  }, b.prototype.filterSlides = b.prototype.slickFilter = function (a) {
    var b = this;null !== a && (b.$slidesCache = b.$slides, b.unload(), b.$slideTrack.children(this.options.slide).detach(), b.$slidesCache.filter(a).appendTo(b.$slideTrack), b.reinit());
  }, b.prototype.getCurrent = b.prototype.slickCurrentSlide = function () {
    var a = this;return a.currentSlide;
  }, b.prototype.getDotCount = function () {
    var a = this,
        b = 0,
        c = 0,
        d = 0;if (a.options.infinite === !0) for (; b < a.slideCount;) {
      ++d, b = c + a.options.slidesToScroll, c += a.options.slidesToScroll <= a.options.slidesToShow ? a.options.slidesToScroll : a.options.slidesToShow;
    } else if (a.options.centerMode === !0) d = a.slideCount;else for (; b < a.slideCount;) {
      ++d, b = c + a.options.slidesToScroll, c += a.options.slidesToScroll <= a.options.slidesToShow ? a.options.slidesToScroll : a.options.slidesToShow;
    }return d - 1;
  }, b.prototype.getLeft = function (a) {
    var c,
        d,
        f,
        b = this,
        e = 0;return b.slideOffset = 0, d = b.$slides.first().outerHeight(!0), b.options.infinite === !0 ? (b.slideCount > b.options.slidesToShow && (b.slideOffset = b.slideWidth * b.options.slidesToShow * -1, e = d * b.options.slidesToShow * -1), b.slideCount % b.options.slidesToScroll !== 0 && a + b.options.slidesToScroll > b.slideCount && b.slideCount > b.options.slidesToShow && (a > b.slideCount ? (b.slideOffset = (b.options.slidesToShow - (a - b.slideCount)) * b.slideWidth * -1, e = (b.options.slidesToShow - (a - b.slideCount)) * d * -1) : (b.slideOffset = b.slideCount % b.options.slidesToScroll * b.slideWidth * -1, e = b.slideCount % b.options.slidesToScroll * d * -1))) : a + b.options.slidesToShow > b.slideCount && (b.slideOffset = (a + b.options.slidesToShow - b.slideCount) * b.slideWidth, e = (a + b.options.slidesToShow - b.slideCount) * d), b.slideCount <= b.options.slidesToShow && (b.slideOffset = 0, e = 0), b.options.centerMode === !0 && b.options.infinite === !0 ? b.slideOffset += b.slideWidth * Math.floor(b.options.slidesToShow / 2) - b.slideWidth : b.options.centerMode === !0 && (b.slideOffset = 0, b.slideOffset += b.slideWidth * Math.floor(b.options.slidesToShow / 2)), c = b.options.vertical === !1 ? a * b.slideWidth * -1 + b.slideOffset : a * d * -1 + e, b.options.variableWidth === !0 && (f = b.slideCount <= b.options.slidesToShow || b.options.infinite === !1 ? b.$slideTrack.children(".slick-slide").eq(a) : b.$slideTrack.children(".slick-slide").eq(a + b.options.slidesToShow), c = b.options.rtl === !0 ? f[0] ? -1 * (b.$slideTrack.width() - f[0].offsetLeft - f.width()) : 0 : f[0] ? -1 * f[0].offsetLeft : 0, b.options.centerMode === !0 && (f = b.slideCount <= b.options.slidesToShow || b.options.infinite === !1 ? b.$slideTrack.children(".slick-slide").eq(a) : b.$slideTrack.children(".slick-slide").eq(a + b.options.slidesToShow + 1), c = b.options.rtl === !0 ? f[0] ? -1 * (b.$slideTrack.width() - f[0].offsetLeft - f.width()) : 0 : f[0] ? -1 * f[0].offsetLeft : 0, c += (b.$list.width() - f.outerWidth()) / 2)), c;
  }, b.prototype.getOption = b.prototype.slickGetOption = function (a) {
    var b = this;return b.options[a];
  }, b.prototype.getNavigableIndexes = function () {
    var e,
        a = this,
        b = 0,
        c = 0,
        d = [];for (a.options.infinite === !1 ? e = a.slideCount : (b = -1 * a.options.slidesToScroll, c = -1 * a.options.slidesToScroll, e = 2 * a.slideCount); e > b;) {
      d.push(b), b = c + a.options.slidesToScroll, c += a.options.slidesToScroll <= a.options.slidesToShow ? a.options.slidesToScroll : a.options.slidesToShow;
    }return d;
  }, b.prototype.getSlick = function () {
    return this;
  }, b.prototype.getSlideCount = function () {
    var c,
        d,
        e,
        b = this;return e = b.options.centerMode === !0 ? b.slideWidth * Math.floor(b.options.slidesToShow / 2) : 0, b.options.swipeToSlide === !0 ? (b.$slideTrack.find(".slick-slide").each(function (c, f) {
      return f.offsetLeft - e + a(f).outerWidth() / 2 > -1 * b.swipeLeft ? (d = f, !1) : void 0;
    }), c = Math.abs(a(d).attr("data-slick-index") - b.currentSlide) || 1) : b.options.slidesToScroll;
  }, b.prototype.goTo = b.prototype.slickGoTo = function (a, b) {
    var c = this;c.changeSlide({ data: { message: "index", index: parseInt(a) } }, b);
  }, b.prototype.init = function (b) {
    var c = this;a(c.$slider).hasClass("slick-initialized") || (a(c.$slider).addClass("slick-initialized"), c.buildRows(), c.buildOut(), c.setProps(), c.startLoad(), c.loadSlider(), c.initializeEvents(), c.updateArrows(), c.updateDots()), b && c.$slider.trigger("init", [c]), c.options.accessibility === !0 && c.initADA();
  }, b.prototype.initArrowEvents = function () {
    var a = this;a.options.arrows === !0 && a.slideCount > a.options.slidesToShow && (a.$prevArrow.on("click.slick", { message: "previous" }, a.changeSlide), a.$nextArrow.on("click.slick", { message: "next" }, a.changeSlide));
  }, b.prototype.initDotEvents = function () {
    var b = this;b.options.dots === !0 && b.slideCount > b.options.slidesToShow && a("li", b.$dots).on("click.slick", { message: "index" }, b.changeSlide), b.options.dots === !0 && b.options.pauseOnDotsHover === !0 && b.options.autoplay === !0 && a("li", b.$dots).on("mouseenter.slick", a.proxy(b.setPaused, b, !0)).on("mouseleave.slick", a.proxy(b.setPaused, b, !1));
  }, b.prototype.initializeEvents = function () {
    var b = this;b.initArrowEvents(), b.initDotEvents(), b.$list.on("touchstart.slick mousedown.slick", { action: "start" }, b.swipeHandler), b.$list.on("touchmove.slick mousemove.slick", { action: "move" }, b.swipeHandler), b.$list.on("touchend.slick mouseup.slick", { action: "end" }, b.swipeHandler), b.$list.on("touchcancel.slick mouseleave.slick", { action: "end" }, b.swipeHandler), b.$list.on("click.slick", b.clickHandler), a(document).on(b.visibilityChange, a.proxy(b.visibility, b)), b.$list.on("mouseenter.slick", a.proxy(b.setPaused, b, !0)), b.$list.on("mouseleave.slick", a.proxy(b.setPaused, b, !1)), b.options.accessibility === !0 && b.$list.on("keydown.slick", b.keyHandler), b.options.focusOnSelect === !0 && a(b.$slideTrack).children().on("click.slick", b.selectHandler), a(window).on("orientationchange.slick.slick-" + b.instanceUid, a.proxy(b.orientationChange, b)), a(window).on("resize.slick.slick-" + b.instanceUid, a.proxy(b.resize, b)), a("[draggable!=true]", b.$slideTrack).on("dragstart", b.preventDefault), a(window).on("load.slick.slick-" + b.instanceUid, b.setPosition), a(document).on("ready.slick.slick-" + b.instanceUid, b.setPosition);
  }, b.prototype.initUI = function () {
    var a = this;a.options.arrows === !0 && a.slideCount > a.options.slidesToShow && (a.$prevArrow.show(), a.$nextArrow.show()), a.options.dots === !0 && a.slideCount > a.options.slidesToShow && a.$dots.show(), a.options.autoplay === !0 && a.autoPlay();
  }, b.prototype.keyHandler = function (a) {
    var b = this;a.target.tagName.match("TEXTAREA|INPUT|SELECT") || (37 === a.keyCode && b.options.accessibility === !0 ? b.changeSlide({ data: { message: "previous" } }) : 39 === a.keyCode && b.options.accessibility === !0 && b.changeSlide({ data: { message: "next" } }));
  }, b.prototype.lazyLoad = function () {
    function g(b) {
      a("img[data-lazy]", b).each(function () {
        var b = a(this),
            c = a(this).attr("data-lazy"),
            d = document.createElement("img");d.onload = function () {
          b.animate({ opacity: 0 }, 100, function () {
            b.attr("src", c).animate({ opacity: 1 }, 200, function () {
              b.removeAttr("data-lazy").removeClass("slick-loading");
            });
          });
        }, d.src = c;
      });
    }var c,
        d,
        e,
        f,
        b = this;b.options.centerMode === !0 ? b.options.infinite === !0 ? (e = b.currentSlide + (b.options.slidesToShow / 2 + 1), f = e + b.options.slidesToShow + 2) : (e = Math.max(0, b.currentSlide - (b.options.slidesToShow / 2 + 1)), f = 2 + (b.options.slidesToShow / 2 + 1) + b.currentSlide) : (e = b.options.infinite ? b.options.slidesToShow + b.currentSlide : b.currentSlide, f = e + b.options.slidesToShow, b.options.fade === !0 && (e > 0 && e--, f <= b.slideCount && f++)), c = b.$slider.find(".slick-slide").slice(e, f), g(c), b.slideCount <= b.options.slidesToShow ? (d = b.$slider.find(".slick-slide"), g(d)) : b.currentSlide >= b.slideCount - b.options.slidesToShow ? (d = b.$slider.find(".slick-cloned").slice(0, b.options.slidesToShow), g(d)) : 0 === b.currentSlide && (d = b.$slider.find(".slick-cloned").slice(-1 * b.options.slidesToShow), g(d));
  }, b.prototype.loadSlider = function () {
    var a = this;a.setPosition(), a.$slideTrack.css({ opacity: 1 }), a.$slider.removeClass("slick-loading"), a.initUI(), "progressive" === a.options.lazyLoad && a.progressiveLazyLoad();
  }, b.prototype.next = b.prototype.slickNext = function () {
    var a = this;a.changeSlide({ data: { message: "next" } });
  }, b.prototype.orientationChange = function () {
    var a = this;a.checkResponsive(), a.setPosition();
  }, b.prototype.pause = b.prototype.slickPause = function () {
    var a = this;a.autoPlayClear(), a.paused = !0;
  }, b.prototype.play = b.prototype.slickPlay = function () {
    var a = this;a.paused = !1, a.autoPlay();
  }, b.prototype.postSlide = function (a) {
    var b = this;b.$slider.trigger("afterChange", [b, a]), b.animating = !1, b.setPosition(), b.swipeLeft = null, b.options.autoplay === !0 && b.paused === !1 && b.autoPlay(), b.options.accessibility === !0 && b.initADA();
  }, b.prototype.prev = b.prototype.slickPrev = function () {
    var a = this;a.changeSlide({ data: { message: "previous" } });
  }, b.prototype.preventDefault = function (a) {
    a.preventDefault();
  }, b.prototype.progressiveLazyLoad = function () {
    var c,
        d,
        b = this;c = a("img[data-lazy]", b.$slider).length, c > 0 && (d = a("img[data-lazy]", b.$slider).first(), d.attr("src", null), d.attr("src", d.attr("data-lazy")).removeClass("slick-loading").load(function () {
      d.removeAttr("data-lazy"), b.progressiveLazyLoad(), b.options.adaptiveHeight === !0 && b.setPosition();
    }).error(function () {
      d.removeAttr("data-lazy"), b.progressiveLazyLoad();
    }));
  }, b.prototype.refresh = function (b) {
    var d,
        e,
        c = this;e = c.slideCount - c.options.slidesToShow, c.options.infinite || (c.slideCount <= c.options.slidesToShow ? c.currentSlide = 0 : c.currentSlide > e && (c.currentSlide = e)), d = c.currentSlide, c.destroy(!0), a.extend(c, c.initials, { currentSlide: d }), c.init(), b || c.changeSlide({ data: { message: "index", index: d } }, !1);
  }, b.prototype.registerBreakpoints = function () {
    var c,
        d,
        e,
        b = this,
        f = b.options.responsive || null;if ("array" === a.type(f) && f.length) {
      b.respondTo = b.options.respondTo || "window";for (c in f) {
        if (e = b.breakpoints.length - 1, d = f[c].breakpoint, f.hasOwnProperty(c)) {
          for (; e >= 0;) {
            b.breakpoints[e] && b.breakpoints[e] === d && b.breakpoints.splice(e, 1), e--;
          }b.breakpoints.push(d), b.breakpointSettings[d] = f[c].settings;
        }
      }b.breakpoints.sort(function (a, c) {
        return b.options.mobileFirst ? a - c : c - a;
      });
    }
  }, b.prototype.reinit = function () {
    var b = this;b.$slides = b.$slideTrack.children(b.options.slide).addClass("slick-slide"), b.slideCount = b.$slides.length, b.currentSlide >= b.slideCount && 0 !== b.currentSlide && (b.currentSlide = b.currentSlide - b.options.slidesToScroll), b.slideCount <= b.options.slidesToShow && (b.currentSlide = 0), b.registerBreakpoints(), b.setProps(), b.setupInfinite(), b.buildArrows(), b.updateArrows(), b.initArrowEvents(), b.buildDots(), b.updateDots(), b.initDotEvents(), b.checkResponsive(!1, !0), b.options.focusOnSelect === !0 && a(b.$slideTrack).children().on("click.slick", b.selectHandler), b.setSlideClasses(0), b.setPosition(), b.$slider.trigger("reInit", [b]), b.options.autoplay === !0 && b.focusHandler();
  }, b.prototype.resize = function () {
    var b = this;a(window).width() !== b.windowWidth && (clearTimeout(b.windowDelay), b.windowDelay = window.setTimeout(function () {
      b.windowWidth = a(window).width(), b.checkResponsive(), b.unslicked || b.setPosition();
    }, 50));
  }, b.prototype.removeSlide = b.prototype.slickRemove = function (a, b, c) {
    var d = this;return "boolean" == typeof a ? (b = a, a = b === !0 ? 0 : d.slideCount - 1) : a = b === !0 ? --a : a, d.slideCount < 1 || 0 > a || a > d.slideCount - 1 ? !1 : (d.unload(), c === !0 ? d.$slideTrack.children().remove() : d.$slideTrack.children(this.options.slide).eq(a).remove(), d.$slides = d.$slideTrack.children(this.options.slide), d.$slideTrack.children(this.options.slide).detach(), d.$slideTrack.append(d.$slides), d.$slidesCache = d.$slides, void d.reinit());
  }, b.prototype.setCSS = function (a) {
    var d,
        e,
        b = this,
        c = {};b.options.rtl === !0 && (a = -a), d = "left" == b.positionProp ? Math.ceil(a) + "px" : "0px", e = "top" == b.positionProp ? Math.ceil(a) + "px" : "0px", c[b.positionProp] = a, b.transformsEnabled === !1 ? b.$slideTrack.css(c) : (c = {}, b.cssTransitions === !1 ? (c[b.animType] = "translate(" + d + ", " + e + ")", b.$slideTrack.css(c)) : (c[b.animType] = "translate3d(" + d + ", " + e + ", 0px)", b.$slideTrack.css(c)));
  }, b.prototype.setDimensions = function () {
    var a = this;a.options.vertical === !1 ? a.options.centerMode === !0 && a.$list.css({ padding: "0px " + a.options.centerPadding }) : (a.$list.height(a.$slides.first().outerHeight(!0) * a.options.slidesToShow), a.options.centerMode === !0 && a.$list.css({ padding: a.options.centerPadding + " 0px" })), a.listWidth = a.$list.width(), a.listHeight = a.$list.height(), a.options.vertical === !1 && a.options.variableWidth === !1 ? (a.slideWidth = Math.ceil(a.listWidth / a.options.slidesToShow), a.$slideTrack.width(Math.ceil(a.slideWidth * a.$slideTrack.children(".slick-slide").length))) : a.options.variableWidth === !0 ? a.$slideTrack.width(5e3 * a.slideCount) : (a.slideWidth = Math.ceil(a.listWidth), a.$slideTrack.height(Math.ceil(a.$slides.first().outerHeight(!0) * a.$slideTrack.children(".slick-slide").length)));var b = a.$slides.first().outerWidth(!0) - a.$slides.first().width();a.options.variableWidth === !1 && a.$slideTrack.children(".slick-slide").width(a.slideWidth - b);
  }, b.prototype.setFade = function () {
    var c,
        b = this;b.$slides.each(function (d, e) {
      c = b.slideWidth * d * -1, b.options.rtl === !0 ? a(e).css({ position: "relative", right: c, top: 0, zIndex: b.options.zIndex - 2, opacity: 0 }) : a(e).css({ position: "relative", left: c, top: 0, zIndex: b.options.zIndex - 2, opacity: 0 });
    }), b.$slides.eq(b.currentSlide).css({ zIndex: b.options.zIndex - 1, opacity: 1 });
  }, b.prototype.setHeight = function () {
    var a = this;if (1 === a.options.slidesToShow && a.options.adaptiveHeight === !0 && a.options.vertical === !1) {
      var b = a.$slides.eq(a.currentSlide).outerHeight(!0);a.$list.css("height", b);
    }
  }, b.prototype.setOption = b.prototype.slickSetOption = function (b, c, d) {
    var f,
        g,
        e = this;if ("responsive" === b && "array" === a.type(c)) for (g in c) {
      if ("array" !== a.type(e.options.responsive)) e.options.responsive = [c[g]];else {
        for (f = e.options.responsive.length - 1; f >= 0;) {
          e.options.responsive[f].breakpoint === c[g].breakpoint && e.options.responsive.splice(f, 1), f--;
        }e.options.responsive.push(c[g]);
      }
    } else e.options[b] = c;d === !0 && (e.unload(), e.reinit());
  }, b.prototype.setPosition = function () {
    var a = this;a.setDimensions(), a.setHeight(), a.options.fade === !1 ? a.setCSS(a.getLeft(a.currentSlide)) : a.setFade(), a.$slider.trigger("setPosition", [a]);
  }, b.prototype.setProps = function () {
    var a = this,
        b = document.body.style;a.positionProp = a.options.vertical === !0 ? "top" : "left", "top" === a.positionProp ? a.$slider.addClass("slick-vertical") : a.$slider.removeClass("slick-vertical"), (void 0 !== b.WebkitTransition || void 0 !== b.MozTransition || void 0 !== b.msTransition) && a.options.useCSS === !0 && (a.cssTransitions = !0), a.options.fade && ("number" == typeof a.options.zIndex ? a.options.zIndex < 3 && (a.options.zIndex = 3) : a.options.zIndex = a.defaults.zIndex), void 0 !== b.OTransform && (a.animType = "OTransform", a.transformType = "-o-transform", a.transitionType = "OTransition", void 0 === b.perspectiveProperty && void 0 === b.webkitPerspective && (a.animType = !1)), void 0 !== b.MozTransform && (a.animType = "MozTransform", a.transformType = "-moz-transform", a.transitionType = "MozTransition", void 0 === b.perspectiveProperty && void 0 === b.MozPerspective && (a.animType = !1)), void 0 !== b.webkitTransform && (a.animType = "webkitTransform", a.transformType = "-webkit-transform", a.transitionType = "webkitTransition", void 0 === b.perspectiveProperty && void 0 === b.webkitPerspective && (a.animType = !1)), void 0 !== b.msTransform && (a.animType = "msTransform", a.transformType = "-ms-transform", a.transitionType = "msTransition", void 0 === b.msTransform && (a.animType = !1)), void 0 !== b.transform && a.animType !== !1 && (a.animType = "transform", a.transformType = "transform", a.transitionType = "transition"), a.transformsEnabled = a.options.useTransform && null !== a.animType && a.animType !== !1;
  }, b.prototype.setSlideClasses = function (a) {
    var c,
        d,
        e,
        f,
        b = this;d = b.$slider.find(".slick-slide").removeClass("slick-active slick-center slick-current").attr("aria-hidden", "true"), b.$slides.eq(a).addClass("slick-current"), b.options.centerMode === !0 ? (c = Math.floor(b.options.slidesToShow / 2), b.options.infinite === !0 && (a >= c && a <= b.slideCount - 1 - c ? b.$slides.slice(a - c, a + c + 1).addClass("slick-active").attr("aria-hidden", "false") : (e = b.options.slidesToShow + a, d.slice(e - c + 1, e + c + 2).addClass("slick-active").attr("aria-hidden", "false")), 0 === a ? d.eq(d.length - 1 - b.options.slidesToShow).addClass("slick-center") : a === b.slideCount - 1 && d.eq(b.options.slidesToShow).addClass("slick-center")), b.$slides.eq(a).addClass("slick-center")) : a >= 0 && a <= b.slideCount - b.options.slidesToShow ? b.$slides.slice(a, a + b.options.slidesToShow).addClass("slick-active").attr("aria-hidden", "false") : d.length <= b.options.slidesToShow ? d.addClass("slick-active").attr("aria-hidden", "false") : (f = b.slideCount % b.options.slidesToShow, e = b.options.infinite === !0 ? b.options.slidesToShow + a : a, b.options.slidesToShow == b.options.slidesToScroll && b.slideCount - a < b.options.slidesToShow ? d.slice(e - (b.options.slidesToShow - f), e + f).addClass("slick-active").attr("aria-hidden", "false") : d.slice(e, e + b.options.slidesToShow).addClass("slick-active").attr("aria-hidden", "false")), "ondemand" === b.options.lazyLoad && b.lazyLoad();
  }, b.prototype.setupInfinite = function () {
    var c,
        d,
        e,
        b = this;if (b.options.fade === !0 && (b.options.centerMode = !1), b.options.infinite === !0 && b.options.fade === !1 && (d = null, b.slideCount > b.options.slidesToShow)) {
      for (e = b.options.centerMode === !0 ? b.options.slidesToShow + 1 : b.options.slidesToShow, c = b.slideCount; c > b.slideCount - e; c -= 1) {
        d = c - 1, a(b.$slides[d]).clone(!0).attr("id", "").attr("data-slick-index", d - b.slideCount).prependTo(b.$slideTrack).addClass("slick-cloned");
      }for (c = 0; e > c; c += 1) {
        d = c, a(b.$slides[d]).clone(!0).attr("id", "").attr("data-slick-index", d + b.slideCount).appendTo(b.$slideTrack).addClass("slick-cloned");
      }b.$slideTrack.find(".slick-cloned").find("[id]").each(function () {
        a(this).attr("id", "");
      });
    }
  }, b.prototype.setPaused = function (a) {
    var b = this;b.options.autoplay === !0 && b.options.pauseOnHover === !0 && (b.paused = a, a ? b.autoPlayClear() : b.autoPlay());
  }, b.prototype.selectHandler = function (b) {
    var c = this,
        d = a(b.target).is(".slick-slide") ? a(b.target) : a(b.target).parents(".slick-slide"),
        e = parseInt(d.attr("data-slick-index"));return e || (e = 0), c.slideCount <= c.options.slidesToShow ? (c.setSlideClasses(e), void c.asNavFor(e)) : void c.slideHandler(e);
  }, b.prototype.slideHandler = function (a, b, c) {
    var d,
        e,
        f,
        g,
        h = null,
        i = this;return b = b || !1, i.animating === !0 && i.options.waitForAnimate === !0 || i.options.fade === !0 && i.currentSlide === a || i.slideCount <= i.options.slidesToShow ? void 0 : (b === !1 && i.asNavFor(a), d = a, h = i.getLeft(d), g = i.getLeft(i.currentSlide), i.currentLeft = null === i.swipeLeft ? g : i.swipeLeft, i.options.infinite === !1 && i.options.centerMode === !1 && (0 > a || a > i.getDotCount() * i.options.slidesToScroll) ? void (i.options.fade === !1 && (d = i.currentSlide, c !== !0 ? i.animateSlide(g, function () {
      i.postSlide(d);
    }) : i.postSlide(d))) : i.options.infinite === !1 && i.options.centerMode === !0 && (0 > a || a > i.slideCount - i.options.slidesToScroll) ? void (i.options.fade === !1 && (d = i.currentSlide, c !== !0 ? i.animateSlide(g, function () {
      i.postSlide(d);
    }) : i.postSlide(d))) : (i.options.autoplay === !0 && clearInterval(i.autoPlayTimer), e = 0 > d ? i.slideCount % i.options.slidesToScroll !== 0 ? i.slideCount - i.slideCount % i.options.slidesToScroll : i.slideCount + d : d >= i.slideCount ? i.slideCount % i.options.slidesToScroll !== 0 ? 0 : d - i.slideCount : d, i.animating = !0, i.$slider.trigger("beforeChange", [i, i.currentSlide, e]), f = i.currentSlide, i.currentSlide = e, i.setSlideClasses(i.currentSlide), i.updateDots(), i.updateArrows(), i.options.fade === !0 ? (c !== !0 ? (i.fadeSlideOut(f), i.fadeSlide(e, function () {
      i.postSlide(e);
    })) : i.postSlide(e), void i.animateHeight()) : void (c !== !0 ? i.animateSlide(h, function () {
      i.postSlide(e);
    }) : i.postSlide(e))));
  }, b.prototype.startLoad = function () {
    var a = this;a.options.arrows === !0 && a.slideCount > a.options.slidesToShow && (a.$prevArrow.hide(), a.$nextArrow.hide()), a.options.dots === !0 && a.slideCount > a.options.slidesToShow && a.$dots.hide(), a.$slider.addClass("slick-loading");
  }, b.prototype.swipeDirection = function () {
    var a,
        b,
        c,
        d,
        e = this;return a = e.touchObject.startX - e.touchObject.curX, b = e.touchObject.startY - e.touchObject.curY, c = Math.atan2(b, a), d = Math.round(180 * c / Math.PI), 0 > d && (d = 360 - Math.abs(d)), 45 >= d && d >= 0 ? e.options.rtl === !1 ? "left" : "right" : 360 >= d && d >= 315 ? e.options.rtl === !1 ? "left" : "right" : d >= 135 && 225 >= d ? e.options.rtl === !1 ? "right" : "left" : e.options.verticalSwiping === !0 ? d >= 35 && 135 >= d ? "left" : "right" : "vertical";
  }, b.prototype.swipeEnd = function (a) {
    var c,
        b = this;if (b.dragging = !1, b.shouldClick = b.touchObject.swipeLength > 10 ? !1 : !0, void 0 === b.touchObject.curX) return !1;if (b.touchObject.edgeHit === !0 && b.$slider.trigger("edge", [b, b.swipeDirection()]), b.touchObject.swipeLength >= b.touchObject.minSwipe) switch (b.swipeDirection()) {case "left":
        c = b.options.swipeToSlide ? b.checkNavigable(b.currentSlide + b.getSlideCount()) : b.currentSlide + b.getSlideCount(), b.slideHandler(c), b.currentDirection = 0, b.touchObject = {}, b.$slider.trigger("swipe", [b, "left"]);break;case "right":
        c = b.options.swipeToSlide ? b.checkNavigable(b.currentSlide - b.getSlideCount()) : b.currentSlide - b.getSlideCount(), b.slideHandler(c), b.currentDirection = 1, b.touchObject = {}, b.$slider.trigger("swipe", [b, "right"]);} else b.touchObject.startX !== b.touchObject.curX && (b.slideHandler(b.currentSlide), b.touchObject = {});
  }, b.prototype.swipeHandler = function (a) {
    var b = this;if (!(b.options.swipe === !1 || "ontouchend" in document && b.options.swipe === !1 || b.options.draggable === !1 && -1 !== a.type.indexOf("mouse"))) switch (b.touchObject.fingerCount = a.originalEvent && void 0 !== a.originalEvent.touches ? a.originalEvent.touches.length : 1, b.touchObject.minSwipe = b.listWidth / b.options.touchThreshold, b.options.verticalSwiping === !0 && (b.touchObject.minSwipe = b.listHeight / b.options.touchThreshold), a.data.action) {case "start":
        b.swipeStart(a);break;case "move":
        b.swipeMove(a);break;case "end":
        b.swipeEnd(a);}
  }, b.prototype.swipeMove = function (a) {
    var d,
        e,
        f,
        g,
        h,
        b = this;return h = void 0 !== a.originalEvent ? a.originalEvent.touches : null, !b.dragging || h && 1 !== h.length ? !1 : (d = b.getLeft(b.currentSlide), b.touchObject.curX = void 0 !== h ? h[0].pageX : a.clientX, b.touchObject.curY = void 0 !== h ? h[0].pageY : a.clientY, b.touchObject.swipeLength = Math.round(Math.sqrt(Math.pow(b.touchObject.curX - b.touchObject.startX, 2))), b.options.verticalSwiping === !0 && (b.touchObject.swipeLength = Math.round(Math.sqrt(Math.pow(b.touchObject.curY - b.touchObject.startY, 2)))), e = b.swipeDirection(), "vertical" !== e ? (void 0 !== a.originalEvent && b.touchObject.swipeLength > 4 && a.preventDefault(), g = (b.options.rtl === !1 ? 1 : -1) * (b.touchObject.curX > b.touchObject.startX ? 1 : -1), b.options.verticalSwiping === !0 && (g = b.touchObject.curY > b.touchObject.startY ? 1 : -1), f = b.touchObject.swipeLength, b.touchObject.edgeHit = !1, b.options.infinite === !1 && (0 === b.currentSlide && "right" === e || b.currentSlide >= b.getDotCount() && "left" === e) && (f = b.touchObject.swipeLength * b.options.edgeFriction, b.touchObject.edgeHit = !0), b.options.vertical === !1 ? b.swipeLeft = d + f * g : b.swipeLeft = d + f * (b.$list.height() / b.listWidth) * g, b.options.verticalSwiping === !0 && (b.swipeLeft = d + f * g), b.options.fade === !0 || b.options.touchMove === !1 ? !1 : b.animating === !0 ? (b.swipeLeft = null, !1) : void b.setCSS(b.swipeLeft)) : void 0);
  }, b.prototype.swipeStart = function (a) {
    var c,
        b = this;return 1 !== b.touchObject.fingerCount || b.slideCount <= b.options.slidesToShow ? (b.touchObject = {}, !1) : (void 0 !== a.originalEvent && void 0 !== a.originalEvent.touches && (c = a.originalEvent.touches[0]), b.touchObject.startX = b.touchObject.curX = void 0 !== c ? c.pageX : a.clientX, b.touchObject.startY = b.touchObject.curY = void 0 !== c ? c.pageY : a.clientY, void (b.dragging = !0));
  }, b.prototype.unfilterSlides = b.prototype.slickUnfilter = function () {
    var a = this;null !== a.$slidesCache && (a.unload(), a.$slideTrack.children(this.options.slide).detach(), a.$slidesCache.appendTo(a.$slideTrack), a.reinit());
  }, b.prototype.unload = function () {
    var b = this;a(".slick-cloned", b.$slider).remove(), b.$dots && b.$dots.remove(), b.$prevArrow && b.htmlExpr.test(b.options.prevArrow) && b.$prevArrow.remove(), b.$nextArrow && b.htmlExpr.test(b.options.nextArrow) && b.$nextArrow.remove(), b.$slides.removeClass("slick-slide slick-active slick-visible slick-current").attr("aria-hidden", "true").css("width", "");
  }, b.prototype.unslick = function (a) {
    var b = this;b.$slider.trigger("unslick", [b, a]), b.destroy();
  }, b.prototype.updateArrows = function () {
    var b,
        a = this;b = Math.floor(a.options.slidesToShow / 2), a.options.arrows === !0 && a.slideCount > a.options.slidesToShow && !a.options.infinite && (a.$prevArrow.removeClass("slick-disabled").attr("aria-disabled", "false"), a.$nextArrow.removeClass("slick-disabled").attr("aria-disabled", "false"), 0 === a.currentSlide ? (a.$prevArrow.addClass("slick-disabled").attr("aria-disabled", "true"), a.$nextArrow.removeClass("slick-disabled").attr("aria-disabled", "false")) : a.currentSlide >= a.slideCount - a.options.slidesToShow && a.options.centerMode === !1 ? (a.$nextArrow.addClass("slick-disabled").attr("aria-disabled", "true"), a.$prevArrow.removeClass("slick-disabled").attr("aria-disabled", "false")) : a.currentSlide >= a.slideCount - 1 && a.options.centerMode === !0 && (a.$nextArrow.addClass("slick-disabled").attr("aria-disabled", "true"), a.$prevArrow.removeClass("slick-disabled").attr("aria-disabled", "false")));
  }, b.prototype.updateDots = function () {
    var a = this;null !== a.$dots && (a.$dots.find("li").removeClass("slick-active").attr("aria-hidden", "true"), a.$dots.find("li").eq(Math.floor(a.currentSlide / a.options.slidesToScroll)).addClass("slick-active").attr("aria-hidden", "false"));
  }, b.prototype.visibility = function () {
    var a = this;document[a.hidden] ? (a.paused = !0, a.autoPlayClear()) : a.options.autoplay === !0 && (a.paused = !1, a.autoPlay());
  }, b.prototype.initADA = function () {
    var b = this;b.$slides.add(b.$slideTrack.find(".slick-cloned")).attr({ "aria-hidden": "true", tabindex: "-1" }).find("a, input, button, select").attr({ tabindex: "-1" }), b.$slideTrack.attr("role", "listbox"), b.$slides.not(b.$slideTrack.find(".slick-cloned")).each(function (c) {
      a(this).attr({ role: "option", "aria-describedby": "slick-slide" + b.instanceUid + c });
    }), null !== b.$dots && b.$dots.attr("role", "tablist").find("li").each(function (c) {
      a(this).attr({ role: "presentation", "aria-selected": "false", "aria-controls": "navigation" + b.instanceUid + c, id: "slick-slide" + b.instanceUid + c });
    }).first().attr("aria-selected", "true").end().find("button").attr("role", "button").end().closest("div").attr("role", "toolbar"), b.activateADA();
  }, b.prototype.activateADA = function () {
    var a = this;a.$slideTrack.find(".slick-active").attr({ "aria-hidden": "false" }).find("a, input, button, select").attr({ tabindex: "0" });
  }, b.prototype.focusHandler = function () {
    var b = this;b.$slider.on("focus.slick blur.slick", "*", function (c) {
      c.stopImmediatePropagation();var d = a(this);setTimeout(function () {
        b.isPlay && (d.is(":focus") ? (b.autoPlayClear(), b.paused = !0) : (b.paused = !1, b.autoPlay()));
      }, 0);
    });
  }, a.fn.slick = function () {
    var f,
        g,
        a = this,
        c = arguments[0],
        d = Array.prototype.slice.call(arguments, 1),
        e = a.length;for (f = 0; e > f; f++) {
      if ("object" == (typeof c === "undefined" ? "undefined" : _typeof(c)) || "undefined" == typeof c ? a[f].slick = new b(a[f], c) : g = a[f].slick[c].apply(a[f].slick, d), "undefined" != typeof g) return g;
    }return a;
  };
});

/***/ }),
/* 56 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;var require;var require;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

/*!
 * clipboard.js v1.5.5
 * https://zenorocha.github.io/clipboard.js
 *
 * Licensed MIT © Zeno Rocha
 */
!function (t) {
  if ("object" == ( false ? "undefined" : _typeof(exports)) && "undefined" != typeof module) module.exports = t();else if (true) !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (t),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));else {
    var e;e = "undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof self ? self : this, e.Clipboard = t();
  }
}(function () {
  var t, e, n;return function t(e, n, r) {
    function o(a, c) {
      if (!n[a]) {
        if (!e[a]) {
          var s = "function" == typeof require && require;if (!c && s) return require(a, !0);if (i) return i(a, !0);var u = new Error("Cannot find module '" + a + "'");throw u.code = "MODULE_NOT_FOUND", u;
        }var l = n[a] = { exports: {} };e[a][0].call(l.exports, function (t) {
          var n = e[a][1][t];return o(n ? n : t);
        }, l, l.exports, t, e, n, r);
      }return n[a].exports;
    }for (var i = "function" == typeof require && require, a = 0; a < r.length; a++) {
      o(r[a]);
    }return o;
  }({ 1: [function (t, e, n) {
      var r = t("matches-selector");e.exports = function (t, e, n) {
        for (var o = n ? t : t.parentNode; o && o !== document;) {
          if (r(o, e)) return o;o = o.parentNode;
        }
      };
    }, { "matches-selector": 2 }], 2: [function (t, e, n) {
      function r(t, e) {
        if (i) return i.call(t, e);for (var n = t.parentNode.querySelectorAll(e), r = 0; r < n.length; ++r) {
          if (n[r] == t) return !0;
        }return !1;
      }var o = Element.prototype,
          i = o.matchesSelector || o.webkitMatchesSelector || o.mozMatchesSelector || o.msMatchesSelector || o.oMatchesSelector;e.exports = r;
    }, {}], 3: [function (t, e, n) {
      function r(t, e, n, r) {
        var i = o.apply(this, arguments);return t.addEventListener(n, i), { destroy: function destroy() {
            t.removeEventListener(n, i);
          } };
      }function o(t, e, n, r) {
        return function (n) {
          n.delegateTarget = i(n.target, e, !0), n.delegateTarget && r.call(t, n);
        };
      }var i = t("closest");e.exports = r;
    }, { closest: 1 }], 4: [function (t, e, n) {
      n.node = function (t) {
        return void 0 !== t && t instanceof HTMLElement && 1 === t.nodeType;
      }, n.nodeList = function (t) {
        var e = Object.prototype.toString.call(t);return void 0 !== t && ("[object NodeList]" === e || "[object HTMLCollection]" === e) && "length" in t && (0 === t.length || n.node(t[0]));
      }, n.string = function (t) {
        return "string" == typeof t || t instanceof String;
      }, n.function = function (t) {
        var e = Object.prototype.toString.call(t);return "[object Function]" === e;
      };
    }, {}], 5: [function (t, e, n) {
      function r(t, e, n) {
        if (!t && !e && !n) throw new Error("Missing required arguments");if (!c.string(e)) throw new TypeError("Second argument must be a String");if (!c.function(n)) throw new TypeError("Third argument must be a Function");if (c.node(t)) return o(t, e, n);if (c.nodeList(t)) return i(t, e, n);if (c.string(t)) return a(t, e, n);throw new TypeError("First argument must be a String, HTMLElement, HTMLCollection, or NodeList");
      }function o(t, e, n) {
        return t.addEventListener(e, n), { destroy: function destroy() {
            t.removeEventListener(e, n);
          } };
      }function i(t, e, n) {
        return Array.prototype.forEach.call(t, function (t) {
          t.addEventListener(e, n);
        }), { destroy: function destroy() {
            Array.prototype.forEach.call(t, function (t) {
              t.removeEventListener(e, n);
            });
          } };
      }function a(t, e, n) {
        return s(document.body, t, e, n);
      }var c = t("./is"),
          s = t("delegate");e.exports = r;
    }, { "./is": 4, delegate: 3 }], 6: [function (t, e, n) {
      function r(t) {
        var e;if ("INPUT" === t.nodeName || "TEXTAREA" === t.nodeName) t.focus(), t.setSelectionRange(0, t.value.length), e = t.value;else {
          t.hasAttribute("contenteditable") && t.focus();var n = window.getSelection(),
              r = document.createRange();r.selectNodeContents(t), n.removeAllRanges(), n.addRange(r), e = n.toString();
        }return e;
      }e.exports = r;
    }, {}], 7: [function (t, e, n) {
      function r() {}r.prototype = { on: function on(t, e, n) {
          var r = this.e || (this.e = {});return (r[t] || (r[t] = [])).push({ fn: e, ctx: n }), this;
        }, once: function once(t, e, n) {
          function r() {
            o.off(t, r), e.apply(n, arguments);
          }var o = this;return r._ = e, this.on(t, r, n);
        }, emit: function emit(t) {
          var e = [].slice.call(arguments, 1),
              n = ((this.e || (this.e = {}))[t] || []).slice(),
              r = 0,
              o = n.length;for (r; o > r; r++) {
            n[r].fn.apply(n[r].ctx, e);
          }return this;
        }, off: function off(t, e) {
          var n = this.e || (this.e = {}),
              r = n[t],
              o = [];if (r && e) for (var i = 0, a = r.length; a > i; i++) {
            r[i].fn !== e && r[i].fn._ !== e && o.push(r[i]);
          }return o.length ? n[t] = o : delete n[t], this;
        } }, e.exports = r;
    }, {}], 8: [function (t, e, n) {
      "use strict";
      function r(t) {
        return t && t.__esModule ? t : { "default": t };
      }function o(t, e) {
        if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function");
      }n.__esModule = !0;var i = function () {
        function t(t, e) {
          for (var n = 0; n < e.length; n++) {
            var r = e[n];r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(t, r.key, r);
          }
        }return function (e, n, r) {
          return n && t(e.prototype, n), r && t(e, r), e;
        };
      }(),
          a = t("select"),
          c = r(a),
          s = function () {
        function t(e) {
          o(this, t), this.resolveOptions(e), this.initSelection();
        }return t.prototype.resolveOptions = function t() {
          var e = arguments.length <= 0 || void 0 === arguments[0] ? {} : arguments[0];this.action = e.action, this.emitter = e.emitter, this.target = e.target, this.text = e.text, this.trigger = e.trigger, this.selectedText = "";
        }, t.prototype.initSelection = function t() {
          if (this.text && this.target) throw new Error('Multiple attributes declared, use either "target" or "text"');if (this.text) this.selectFake();else {
            if (!this.target) throw new Error('Missing required attributes, use either "target" or "text"');this.selectTarget();
          }
        }, t.prototype.selectFake = function t() {
          var e = this;this.removeFake(), this.fakeHandler = document.body.addEventListener("click", function () {
            return e.removeFake();
          }), this.fakeElem = document.createElement("textarea"), this.fakeElem.style.position = "absolute", this.fakeElem.style.left = "-9999px", this.fakeElem.style.top = (window.pageYOffset || document.documentElement.scrollTop) + "px", this.fakeElem.setAttribute("readonly", ""), this.fakeElem.value = this.text, document.body.appendChild(this.fakeElem), this.selectedText = c.default(this.fakeElem), this.copyText();
        }, t.prototype.removeFake = function t() {
          this.fakeHandler && (document.body.removeEventListener("click"), this.fakeHandler = null), this.fakeElem && (document.body.removeChild(this.fakeElem), this.fakeElem = null);
        }, t.prototype.selectTarget = function t() {
          this.selectedText = c.default(this.target), this.copyText();
        }, t.prototype.copyText = function t() {
          var e = void 0;try {
            e = document.execCommand(this.action);
          } catch (n) {
            e = !1;
          }this.handleResult(e);
        }, t.prototype.handleResult = function t(e) {
          e ? this.emitter.emit("success", { action: this.action, text: this.selectedText, trigger: this.trigger, clearSelection: this.clearSelection.bind(this) }) : this.emitter.emit("error", { action: this.action, trigger: this.trigger, clearSelection: this.clearSelection.bind(this) });
        }, t.prototype.clearSelection = function t() {
          this.target && this.target.blur(), window.getSelection().removeAllRanges();
        }, t.prototype.destroy = function t() {
          this.removeFake();
        }, i(t, [{ key: "action", set: function t() {
            var e = arguments.length <= 0 || void 0 === arguments[0] ? "copy" : arguments[0];if (this._action = e, "copy" !== this._action && "cut" !== this._action) throw new Error('Invalid "action" value, use either "copy" or "cut"');
          }, get: function t() {
            return this._action;
          } }, { key: "target", set: function t(e) {
            if (void 0 !== e) {
              if (!e || "object" != (typeof e === "undefined" ? "undefined" : _typeof(e)) || 1 !== e.nodeType) throw new Error('Invalid "target" value, use a valid Element');this._target = e;
            }
          }, get: function t() {
            return this._target;
          } }]), t;
      }();n.default = s, e.exports = n.default;
    }, { select: 6 }], 9: [function (t, e, n) {
      "use strict";
      function r(t) {
        return t && t.__esModule ? t : { "default": t };
      }function o(t, e) {
        if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function");
      }function i(t, e) {
        if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function, not " + (typeof e === "undefined" ? "undefined" : _typeof(e)));t.prototype = Object.create(e && e.prototype, { constructor: { value: t, enumerable: !1, writable: !0, configurable: !0 } }), e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e);
      }function a(t, e) {
        var n = "data-clipboard-" + t;if (e.hasAttribute(n)) return e.getAttribute(n);
      }n.__esModule = !0;var c = t("./clipboard-action"),
          s = r(c),
          u = t("tiny-emitter"),
          l = r(u),
          f = t("good-listener"),
          d = r(f),
          h = function (t) {
        function e(n, r) {
          o(this, e), t.call(this), this.resolveOptions(r), this.listenClick(n);
        }return i(e, t), e.prototype.resolveOptions = function t() {
          var e = arguments.length <= 0 || void 0 === arguments[0] ? {} : arguments[0];this.action = "function" == typeof e.action ? e.action : this.defaultAction, this.target = "function" == typeof e.target ? e.target : this.defaultTarget, this.text = "function" == typeof e.text ? e.text : this.defaultText;
        }, e.prototype.listenClick = function t(e) {
          var n = this;this.listener = d.default(e, "click", function (t) {
            return n.onClick(t);
          });
        }, e.prototype.onClick = function t(e) {
          var n = e.delegateTarget || e.currentTarget;this.clipboardAction && (this.clipboardAction = null), this.clipboardAction = new s.default({ action: this.action(n), target: this.target(n), text: this.text(n), trigger: n, emitter: this });
        }, e.prototype.defaultAction = function t(e) {
          return a("action", e);
        }, e.prototype.defaultTarget = function t(e) {
          var n = a("target", e);return n ? document.querySelector(n) : void 0;
        }, e.prototype.defaultText = function t(e) {
          return a("text", e);
        }, e.prototype.destroy = function t() {
          this.listener.destroy(), this.clipboardAction && (this.clipboardAction.destroy(), this.clipboardAction = null);
        }, e;
      }(l.default);n.default = h, e.exports = n.default;
    }, { "./clipboard-action": 8, "good-listener": 5, "tiny-emitter": 7 }] }, {}, [9])(9);
});

/***/ }),
/* 57 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {module.exports = global["Clipboard"] = __webpack_require__(56);
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ }),
/* 58 */
/***/ (function(module, exports) {

module.exports = {
	"CountryCode": [
		"US (United States Of America)",
		"AD (Andorra)",
		"AI (Anguilla)",
		"AR (Argentina)",
		"AU (Australia)",
		"AT (Austria)",
		"AZ (Azerbaijan)",
		"BS (Bahamas)",
		"BH (Bahrain)",
		"BB (Barbados)",
		"BE (Belgium)",
		"BM (Bermuda)",
		"BR (Brazil)",
		"BG (Bulgaria)",
		"CA (Canada)",
		"CL (Chile)",
		"CN (China)",
		"CO (Colombia)",
		"CR (Costa Rica)",
		"HR (Croatia)",
		"CY (Cyprus)",
		"CZ (Czech Republic)",
		"DK (Denmark)",
		"DO (Dominican Republic)",
		"EC (Ecuador)",
		"EE (Estonia)",
		"FO (Faroe Islands)",
		"FI (Finland)",
		"FR (France)",
		"GE (Georgia)",
		"DE (Germany)",
		"GH (Ghana)",
		"GI (Gibraltar)",
		"GB (Great Britain)",
		"GR (Greece)",
		"HK (Hong Kong)",
		"HU (Hungary)",
		"IS (Iceland)",
		"IN (India)",
		"IE (Ireland)",
		"IL (Israel)",
		"IT (Italy)",
		"JM (Jamaica)",
		"JP (Japan)",
		"KR (Korea, Republic of)",
		"LV (Latvia)",
		"LB (Lebanon)",
		"LT (Lithuania)",
		"LU (Luxembourg)",
		"MY (Malaysia)",
		"MT (Malta)",
		"MX (Mexico)",
		"MC (Monaco)",
		"ME (Montenegro)",
		"MA (Morocco)",
		"NL (Netherlands)",
		"AN (Netherlands Antilles)",
		"NZ (New Zealand)",
		"ND (Northern Ireland)",
		"NO (Norway)",
		"PE (Peru)",
		"PL (Poland)",
		"PT (Portugal)",
		"RO (Romania)",
		"RU (Russian Federation)",
		"LC (Saint Lucia)",
		"SA (Saudi Arabia)",
		"RS (Serbia)",
		"SG (Singapore)",
		"SK (Slovakia)",
		"SI (Slovenia)",
		"ZA (South Africa)",
		"ES (Spain)",
		"SE (Sweden)",
		"CH (Switzerland)",
		"TW (Taiwan)",
		"TH (Thailand)",
		"TT (Trinidad and Tobago)",
		"TR (Turkey)",
		"UA (Ukraine)",
		"AE (United Arab Emirates)",
		"UY (Uruguay)",
		"VE (Venezuela)"
	]
};

/***/ }),
/* 59 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*globals jQuery, define, module, exports, require, window, document, postMessage */
(function (factory) {
	"use strict";
	if (true) {
		!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(1)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	}
	else if(typeof module !== 'undefined' && module.exports) {
		module.exports = factory(require('jquery'));
	}
	else {
		factory(jQuery);
	}
}(function ($, undefined) {
	"use strict";
/*!
 * jsTree 3.3.3
 * http://jstree.com/
 *
 * Copyright (c) 2014 Ivan Bozhanov (http://vakata.com)
 *
 * Licensed same as jquery - under the terms of the MIT License
 *   http://www.opensource.org/licenses/mit-license.php
 */
/*!
 * if using jslint please allow for the jQuery global and use following options:
 * jslint: loopfunc: true, browser: true, ass: true, bitwise: true, continue: true, nomen: true, plusplus: true, regexp: true, unparam: true, todo: true, white: true
 */
/*jshint -W083 */

	// prevent another load? maybe there is a better way?
	if($.jstree) {
		return;
	}

	/**
	 * ### jsTree core functionality
	 */

	// internal variables
	var instance_counter = 0,
		ccp_node = false,
		ccp_mode = false,
		ccp_inst = false,
		themes_loaded = [],
		src = $('script:last').attr('src'),
		document = window.document; // local variable is always faster to access then a global

	/**
	 * holds all jstree related functions and variables, including the actual class and methods to create, access and manipulate instances.
	 * @name $.jstree
	 */
	$.jstree = {
		/**
		 * specifies the jstree version in use
		 * @name $.jstree.version
		 */
		version : '3.3.3',
		/**
		 * holds all the default options used when creating new instances
		 * @name $.jstree.defaults
		 */
		defaults : {
			/**
			 * configure which plugins will be active on an instance. Should be an array of strings, where each element is a plugin name. The default is `[]`
			 * @name $.jstree.defaults.plugins
			 */
			plugins : []
		},
		/**
		 * stores all loaded jstree plugins (used internally)
		 * @name $.jstree.plugins
		 */
		plugins : {},
		path : src && src.indexOf('/') !== -1 ? src.replace(/\/[^\/]+$/,'') : '',
		idregex : /[\\:&!^|()\[\]<>@*'+~#";.,=\- \/${}%?`]/g,
		root : '#'
	};
	
	/**
	 * creates a jstree instance
	 * @name $.jstree.create(el [, options])
	 * @param {DOMElement|jQuery|String} el the element to create the instance on, can be jQuery extended or a selector
	 * @param {Object} options options for this instance (extends `$.jstree.defaults`)
	 * @return {jsTree} the new instance
	 */
	$.jstree.create = function (el, options) {
		var tmp = new $.jstree.core(++instance_counter),
			opt = options;
		options = $.extend(true, {}, $.jstree.defaults, options);
		if(opt && opt.plugins) {
			options.plugins = opt.plugins;
		}
		$.each(options.plugins, function (i, k) {
			if(i !== 'core') {
				tmp = tmp.plugin(k, options[k]);
			}
		});
		$(el).data('jstree', tmp);
		tmp.init(el, options);
		return tmp;
	};
	/**
	 * remove all traces of jstree from the DOM and destroy all instances
	 * @name $.jstree.destroy()
	 */
	$.jstree.destroy = function () {
		$('.jstree:jstree').jstree('destroy');
		$(document).off('.jstree');
	};
	/**
	 * the jstree class constructor, used only internally
	 * @private
	 * @name $.jstree.core(id)
	 * @param {Number} id this instance's index
	 */
	$.jstree.core = function (id) {
		this._id = id;
		this._cnt = 0;
		this._wrk = null;
		this._data = {
			core : {
				themes : {
					name : false,
					dots : false,
					icons : false,
					ellipsis : false
				},
				selected : [],
				last_error : {},
				working : false,
				worker_queue : [],
				focused : null
			}
		};
	};
	/**
	 * get a reference to an existing instance
	 *
	 * __Examples__
	 *
	 *	// provided a container with an ID of "tree", and a nested node with an ID of "branch"
	 *	// all of there will return the same instance
	 *	$.jstree.reference('tree');
	 *	$.jstree.reference('#tree');
	 *	$.jstree.reference($('#tree'));
	 *	$.jstree.reference(document.getElementByID('tree'));
	 *	$.jstree.reference('branch');
	 *	$.jstree.reference('#branch');
	 *	$.jstree.reference($('#branch'));
	 *	$.jstree.reference(document.getElementByID('branch'));
	 *
	 * @name $.jstree.reference(needle)
	 * @param {DOMElement|jQuery|String} needle
	 * @return {jsTree|null} the instance or `null` if not found
	 */
	$.jstree.reference = function (needle) {
		var tmp = null,
			obj = null;
		if(needle && needle.id && (!needle.tagName || !needle.nodeType)) { needle = needle.id; }

		if(!obj || !obj.length) {
			try { obj = $(needle); } catch (ignore) { }
		}
		if(!obj || !obj.length) {
			try { obj = $('#' + needle.replace($.jstree.idregex,'\\$&')); } catch (ignore) { }
		}
		if(obj && obj.length && (obj = obj.closest('.jstree')).length && (obj = obj.data('jstree'))) {
			tmp = obj;
		}
		else {
			$('.jstree').each(function () {
				var inst = $(this).data('jstree');
				if(inst && inst._model.data[needle]) {
					tmp = inst;
					return false;
				}
			});
		}
		return tmp;
	};
	/**
	 * Create an instance, get an instance or invoke a command on a instance.
	 *
	 * If there is no instance associated with the current node a new one is created and `arg` is used to extend `$.jstree.defaults` for this new instance. There would be no return value (chaining is not broken).
	 *
	 * If there is an existing instance and `arg` is a string the command specified by `arg` is executed on the instance, with any additional arguments passed to the function. If the function returns a value it will be returned (chaining could break depending on function).
	 *
	 * If there is an existing instance and `arg` is not a string the instance itself is returned (similar to `$.jstree.reference`).
	 *
	 * In any other case - nothing is returned and chaining is not broken.
	 *
	 * __Examples__
	 *
	 *	$('#tree1').jstree(); // creates an instance
	 *	$('#tree2').jstree({ plugins : [] }); // create an instance with some options
	 *	$('#tree1').jstree('open_node', '#branch_1'); // call a method on an existing instance, passing additional arguments
	 *	$('#tree2').jstree(); // get an existing instance (or create an instance)
	 *	$('#tree2').jstree(true); // get an existing instance (will not create new instance)
	 *	$('#branch_1').jstree().select_node('#branch_1'); // get an instance (using a nested element and call a method)
	 *
	 * @name $().jstree([arg])
	 * @param {String|Object} arg
	 * @return {Mixed}
	 */
	$.fn.jstree = function (arg) {
		// check for string argument
		var is_method	= (typeof arg === 'string'),
			args		= Array.prototype.slice.call(arguments, 1),
			result		= null;
		if(arg === true && !this.length) { return false; }
		this.each(function () {
			// get the instance (if there is one) and method (if it exists)
			var instance = $.jstree.reference(this),
				method = is_method && instance ? instance[arg] : null;
			// if calling a method, and method is available - execute on the instance
			result = is_method && method ?
				method.apply(instance, args) :
				null;
			// if there is no instance and no method is being called - create one
			if(!instance && !is_method && (arg === undefined || $.isPlainObject(arg))) {
				$.jstree.create(this, arg);
			}
			// if there is an instance and no method is called - return the instance
			if( (instance && !is_method) || arg === true ) {
				result = instance || false;
			}
			// if there was a method call which returned a result - break and return the value
			if(result !== null && result !== undefined) {
				return false;
			}
		});
		// if there was a method call with a valid return value - return that, otherwise continue the chain
		return result !== null && result !== undefined ?
			result : this;
	};
	/**
	 * used to find elements containing an instance
	 *
	 * __Examples__
	 *
	 *	$('div:jstree').each(function () {
	 *		$(this).jstree('destroy');
	 *	});
	 *
	 * @name $(':jstree')
	 * @return {jQuery}
	 */
	$.expr.pseudos.jstree = $.expr.createPseudo(function(search) {
		return function(a) {
			return $(a).hasClass('jstree') &&
				$(a).data('jstree') !== undefined;
		};
	});

	/**
	 * stores all defaults for the core
	 * @name $.jstree.defaults.core
	 */
	$.jstree.defaults.core = {
		/**
		 * data configuration
		 *
		 * If left as `false` the HTML inside the jstree container element is used to populate the tree (that should be an unordered list with list items).
		 *
		 * You can also pass in a HTML string or a JSON array here.
		 *
		 * It is possible to pass in a standard jQuery-like AJAX config and jstree will automatically determine if the response is JSON or HTML and use that to populate the tree.
		 * In addition to the standard jQuery ajax options here you can suppy functions for `data` and `url`, the functions will be run in the current instance's scope and a param will be passed indicating which node is being loaded, the return value of those functions will be used.
		 *
		 * The last option is to specify a function, that function will receive the node being loaded as argument and a second param which is a function which should be called with the result.
		 *
		 * __Examples__
		 *
		 *	// AJAX
		 *	$('#tree').jstree({
		 *		'core' : {
		 *			'data' : {
		 *				'url' : '/get/children/',
		 *				'data' : function (node) {
		 *					return { 'id' : node.id };
		 *				}
		 *			}
		 *		});
		 *
		 *	// direct data
		 *	$('#tree').jstree({
		 *		'core' : {
		 *			'data' : [
		 *				'Simple root node',
		 *				{
		 *					'id' : 'node_2',
		 *					'text' : 'Root node with options',
		 *					'state' : { 'opened' : true, 'selected' : true },
		 *					'children' : [ { 'text' : 'Child 1' }, 'Child 2']
		 *				}
		 *			]
		 *		}
		 *	});
		 *
		 *	// function
		 *	$('#tree').jstree({
		 *		'core' : {
		 *			'data' : function (obj, callback) {
		 *				callback.call(this, ['Root 1', 'Root 2']);
		 *			}
		 *		});
		 *
		 * @name $.jstree.defaults.core.data
		 */
		data			: false,
		/**
		 * configure the various strings used throughout the tree
		 *
		 * You can use an object where the key is the string you need to replace and the value is your replacement.
		 * Another option is to specify a function which will be called with an argument of the needed string and should return the replacement.
		 * If left as `false` no replacement is made.
		 *
		 * __Examples__
		 *
		 *	$('#tree').jstree({
		 *		'core' : {
		 *			'strings' : {
		 *				'Loading ...' : 'Please wait ...'
		 *			}
		 *		}
		 *	});
		 *
		 * @name $.jstree.defaults.core.strings
		 */
		strings			: false,
		/**
		 * determines what happens when a user tries to modify the structure of the tree
		 * If left as `false` all operations like create, rename, delete, move or copy are prevented.
		 * You can set this to `true` to allow all interactions or use a function to have better control.
		 *
		 * __Examples__
		 *
		 *	$('#tree').jstree({
		 *		'core' : {
		 *			'check_callback' : function (operation, node, node_parent, node_position, more) {
		 *				// operation can be 'create_node', 'rename_node', 'delete_node', 'move_node' or 'copy_node'
		 *				// in case of 'rename_node' node_position is filled with the new node name
		 *				return operation === 'rename_node' ? true : false;
		 *			}
		 *		}
		 *	});
		 *
		 * @name $.jstree.defaults.core.check_callback
		 */
		check_callback	: false,
		/**
		 * a callback called with a single object parameter in the instance's scope when something goes wrong (operation prevented, ajax failed, etc)
		 * @name $.jstree.defaults.core.error
		 */
		error			: $.noop,
		/**
		 * the open / close animation duration in milliseconds - set this to `false` to disable the animation (default is `200`)
		 * @name $.jstree.defaults.core.animation
		 */
		animation		: 200,
		/**
		 * a boolean indicating if multiple nodes can be selected
		 * @name $.jstree.defaults.core.multiple
		 */
		multiple		: true,
		/**
		 * theme configuration object
		 * @name $.jstree.defaults.core.themes
		 */
		themes			: {
			/**
			 * the name of the theme to use (if left as `false` the default theme is used)
			 * @name $.jstree.defaults.core.themes.name
			 */
			name			: false,
			/**
			 * the URL of the theme's CSS file, leave this as `false` if you have manually included the theme CSS (recommended). You can set this to `true` too which will try to autoload the theme.
			 * @name $.jstree.defaults.core.themes.url
			 */
			url				: false,
			/**
			 * the location of all jstree themes - only used if `url` is set to `true`
			 * @name $.jstree.defaults.core.themes.dir
			 */
			dir				: false,
			/**
			 * a boolean indicating if connecting dots are shown
			 * @name $.jstree.defaults.core.themes.dots
			 */
			dots			: true,
			/**
			 * a boolean indicating if node icons are shown
			 * @name $.jstree.defaults.core.themes.icons
			 */
			icons			: true,
			/**
			 * a boolean indicating if node ellipsis should be shown - this only works with a fixed with on the container
			 * @name $.jstree.defaults.core.themes.ellipsis
			 */
			ellipsis		: false,
			/**
			 * a boolean indicating if the tree background is striped
			 * @name $.jstree.defaults.core.themes.stripes
			 */
			stripes			: false,
			/**
			 * a string (or boolean `false`) specifying the theme variant to use (if the theme supports variants)
			 * @name $.jstree.defaults.core.themes.variant
			 */
			variant			: false,
			/**
			 * a boolean specifying if a reponsive version of the theme should kick in on smaller screens (if the theme supports it). Defaults to `false`.
			 * @name $.jstree.defaults.core.themes.responsive
			 */
			responsive		: false
		},
		/**
		 * if left as `true` all parents of all selected nodes will be opened once the tree loads (so that all selected nodes are visible to the user)
		 * @name $.jstree.defaults.core.expand_selected_onload
		 */
		expand_selected_onload : true,
		/**
		 * if left as `true` web workers will be used to parse incoming JSON data where possible, so that the UI will not be blocked by large requests. Workers are however about 30% slower. Defaults to `true`
		 * @name $.jstree.defaults.core.worker
		 */
		worker : true,
		/**
		 * Force node text to plain text (and escape HTML). Defaults to `false`
		 * @name $.jstree.defaults.core.force_text
		 */
		force_text : false,
		/**
		 * Should the node should be toggled if the text is double clicked . Defaults to `true`
		 * @name $.jstree.defaults.core.dblclick_toggle
		 */
		dblclick_toggle : true
	};
	$.jstree.core.prototype = {
		/**
		 * used to decorate an instance with a plugin. Used internally.
		 * @private
		 * @name plugin(deco [, opts])
		 * @param  {String} deco the plugin to decorate with
		 * @param  {Object} opts options for the plugin
		 * @return {jsTree}
		 */
		plugin : function (deco, opts) {
			var Child = $.jstree.plugins[deco];
			if(Child) {
				this._data[deco] = {};
				Child.prototype = this;
				return new Child(opts, this);
			}
			return this;
		},
		/**
		 * initialize the instance. Used internally.
		 * @private
		 * @name init(el, optons)
		 * @param {DOMElement|jQuery|String} el the element we are transforming
		 * @param {Object} options options for this instance
		 * @trigger init.jstree, loading.jstree, loaded.jstree, ready.jstree, changed.jstree
		 */
		init : function (el, options) {
			this._model = {
				data : {},
				changed : [],
				force_full_redraw : false,
				redraw_timeout : false,
				default_state : {
					loaded : true,
					opened : false,
					selected : false,
					disabled : false
				}
			};
			this._model.data[$.jstree.root] = {
				id : $.jstree.root,
				parent : null,
				parents : [],
				children : [],
				children_d : [],
				state : { loaded : false }
			};

			this.element = $(el).addClass('jstree jstree-' + this._id);
			this.settings = options;

			this._data.core.ready = false;
			this._data.core.loaded = false;
			this._data.core.rtl = (this.element.css("direction") === "rtl");
			this.element[this._data.core.rtl ? 'addClass' : 'removeClass']("jstree-rtl");
			this.element.attr('role','tree');
			if(this.settings.core.multiple) {
				this.element.attr('aria-multiselectable', true);
			}
			if(!this.element.attr('tabindex')) {
				this.element.attr('tabindex','0');
			}

			this.bind();
			/**
			 * triggered after all events are bound
			 * @event
			 * @name init.jstree
			 */
			this.trigger("init");

			this._data.core.original_container_html = this.element.find(" > ul > li").clone(true);
			this._data.core.original_container_html
				.find("li").addBack()
				.contents().filter(function() {
					return this.nodeType === 3 && (!this.nodeValue || /^\s+$/.test(this.nodeValue));
				})
				.remove();
			this.element.html("<"+"ul class='jstree-container-ul jstree-children' role='group'><"+"li id='j"+this._id+"_loading' class='jstree-initial-node jstree-loading jstree-leaf jstree-last' role='tree-item'><i class='jstree-icon jstree-ocl'></i><"+"a class='jstree-anchor' href='#'><i class='jstree-icon jstree-themeicon-hidden'></i>" + this.get_string("Loading ...") + "</a></li></ul>");
			this.element.attr('aria-activedescendant','j' + this._id + '_loading');
			this._data.core.li_height = this.get_container_ul().children("li").first().height() || 24;
			this._data.core.node = this._create_prototype_node();
			/**
			 * triggered after the loading text is shown and before loading starts
			 * @event
			 * @name loading.jstree
			 */
			this.trigger("loading");
			this.load_node($.jstree.root);
		},
		/**
		 * destroy an instance
		 * @name destroy()
		 * @param  {Boolean} keep_html if not set to `true` the container will be emptied, otherwise the current DOM elements will be kept intact
		 */
		destroy : function (keep_html) {
			if(this._wrk) {
				try {
					window.URL.revokeObjectURL(this._wrk);
					this._wrk = null;
				}
				catch (ignore) { }
			}
			if(!keep_html) { this.element.empty(); }
			this.teardown();
		},
		/**
		 * Create prototype node
		 */
		_create_prototype_node : function () {
			var _node = document.createElement('LI'), _temp1, _temp2;
			_node.setAttribute('role', 'treeitem');
			_temp1 = document.createElement('I');
			_temp1.className = 'jstree-icon jstree-ocl';
			_temp1.setAttribute('role', 'presentation');
			_node.appendChild(_temp1);
			_temp1 = document.createElement('A');
			_temp1.className = 'jstree-anchor';
			_temp1.setAttribute('href','#');
			_temp1.setAttribute('tabindex','-1');
			_temp2 = document.createElement('I');
			_temp2.className = 'jstree-icon jstree-themeicon';
			_temp2.setAttribute('role', 'presentation');
			_temp1.appendChild(_temp2);
			_node.appendChild(_temp1);
			_temp1 = _temp2 = null;

			return _node;
		},
		/**
		 * part of the destroying of an instance. Used internally.
		 * @private
		 * @name teardown()
		 */
		teardown : function () {
			this.unbind();
			this.element
				.removeClass('jstree')
				.removeData('jstree')
				.find("[class^='jstree']")
					.addBack()
					.attr("class", function () { return this.className.replace(/jstree[^ ]*|$/ig,''); });
			this.element = null;
		},
		/**
		 * bind all events. Used internally.
		 * @private
		 * @name bind()
		 */
		bind : function () {
			var word = '',
				tout = null,
				was_click = 0;
			this.element
				.on("dblclick.jstree", function (e) {
						if(e.target.tagName && e.target.tagName.toLowerCase() === "input") { return true; }
						if(document.selection && document.selection.empty) {
							document.selection.empty();
						}
						else {
							if(window.getSelection) {
								var sel = window.getSelection();
								try {
									sel.removeAllRanges();
									sel.collapse();
								} catch (ignore) { }
							}
						}
					})
				.on("mousedown.jstree", $.proxy(function (e) {
						if(e.target === this.element[0]) {
							e.preventDefault(); // prevent losing focus when clicking scroll arrows (FF, Chrome)
							was_click = +(new Date()); // ie does not allow to prevent losing focus
						}
					}, this))
				.on("mousedown.jstree", ".jstree-ocl", function (e) {
						e.preventDefault(); // prevent any node inside from losing focus when clicking the open/close icon
					})
				.on("click.jstree", ".jstree-ocl", $.proxy(function (e) {
						this.toggle_node(e.target);
					}, this))
				.on("dblclick.jstree", ".jstree-anchor", $.proxy(function (e) {
						if(e.target.tagName && e.target.tagName.toLowerCase() === "input") { return true; }
						if(this.settings.core.dblclick_toggle) {
							this.toggle_node(e.target);
						}
					}, this))
				.on("click.jstree", ".jstree-anchor", $.proxy(function (e) {
						e.preventDefault();
						if(e.currentTarget !== document.activeElement) { $(e.currentTarget).focus(); }
						this.activate_node(e.currentTarget, e);
					}, this))
				.on('keydown.jstree', '.jstree-anchor', $.proxy(function (e) {
						if(e.target.tagName && e.target.tagName.toLowerCase() === "input") { return true; }
						if(e.which !== 32 && e.which !== 13 && (e.shiftKey || e.ctrlKey || e.altKey || e.metaKey)) { return true; }
						var o = null;
						if(this._data.core.rtl) {
							if(e.which === 37) { e.which = 39; }
							else if(e.which === 39) { e.which = 37; }
						}
						switch(e.which) {
							case 32: // aria defines space only with Ctrl
								if(e.ctrlKey) {
									e.type = "click";
									$(e.currentTarget).trigger(e);
								}
								break;
							case 13: // enter
								e.type = "click";
								$(e.currentTarget).trigger(e);
								break;
							case 37: // left
								e.preventDefault();
								if(this.is_open(e.currentTarget)) {
									this.close_node(e.currentTarget);
								}
								else {
									o = this.get_parent(e.currentTarget);
									if(o && o.id !== $.jstree.root) { this.get_node(o, true).children('.jstree-anchor').focus(); }
								}
								break;
							case 38: // up
								e.preventDefault();
								o = this.get_prev_dom(e.currentTarget);
								if(o && o.length) { o.children('.jstree-anchor').focus(); }
								break;
							case 39: // right
								e.preventDefault();
								if(this.is_closed(e.currentTarget)) {
									this.open_node(e.currentTarget, function (o) { this.get_node(o, true).children('.jstree-anchor').focus(); });
								}
								else if (this.is_open(e.currentTarget)) {
									o = this.get_node(e.currentTarget, true).children('.jstree-children')[0];
									if(o) { $(this._firstChild(o)).children('.jstree-anchor').focus(); }
								}
								break;
							case 40: // down
								e.preventDefault();
								o = this.get_next_dom(e.currentTarget);
								if(o && o.length) { o.children('.jstree-anchor').focus(); }
								break;
							case 106: // aria defines * on numpad as open_all - not very common
								this.open_all();
								break;
							case 36: // home
								e.preventDefault();
								o = this._firstChild(this.get_container_ul()[0]);
								if(o) { $(o).children('.jstree-anchor').filter(':visible').focus(); }
								break;
							case 35: // end
								e.preventDefault();
								this.element.find('.jstree-anchor').filter(':visible').last().focus();
								break;
							case 113: // f2 - safe to include - if check_callback is false it will fail
								e.preventDefault();
								this.edit(e.currentTarget);
								break;
							default:
								break;
							/*!
							// delete
							case 46:
								e.preventDefault();
								o = this.get_node(e.currentTarget);
								if(o && o.id && o.id !== $.jstree.root) {
									o = this.is_selected(o) ? this.get_selected() : o;
									this.delete_node(o);
								}
								break;

							*/
						}
					}, this))
				.on("load_node.jstree", $.proxy(function (e, data) {
						if(data.status) {
							if(data.node.id === $.jstree.root && !this._data.core.loaded) {
								this._data.core.loaded = true;
								if(this._firstChild(this.get_container_ul()[0])) {
									this.element.attr('aria-activedescendant',this._firstChild(this.get_container_ul()[0]).id);
								}
								/**
								 * triggered after the root node is loaded for the first time
								 * @event
								 * @name loaded.jstree
								 */
								this.trigger("loaded");
							}
							if(!this._data.core.ready) {
								setTimeout($.proxy(function() {
									if(this.element && !this.get_container_ul().find('.jstree-loading').length) {
										this._data.core.ready = true;
										if(this._data.core.selected.length) {
											if(this.settings.core.expand_selected_onload) {
												var tmp = [], i, j;
												for(i = 0, j = this._data.core.selected.length; i < j; i++) {
													tmp = tmp.concat(this._model.data[this._data.core.selected[i]].parents);
												}
												tmp = $.vakata.array_unique(tmp);
												for(i = 0, j = tmp.length; i < j; i++) {
													this.open_node(tmp[i], false, 0);
												}
											}
											this.trigger('changed', { 'action' : 'ready', 'selected' : this._data.core.selected });
										}
										/**
										 * triggered after all nodes are finished loading
										 * @event
										 * @name ready.jstree
										 */
										this.trigger("ready");
									}
								}, this), 0);
							}
						}
					}, this))
				// quick searching when the tree is focused
				.on('keypress.jstree', $.proxy(function (e) {
						if(e.target.tagName && e.target.tagName.toLowerCase() === "input") { return true; }
						if(tout) { clearTimeout(tout); }
						tout = setTimeout(function () {
							word = '';
						}, 500);

						var chr = String.fromCharCode(e.which).toLowerCase(),
							col = this.element.find('.jstree-anchor').filter(':visible'),
							ind = col.index(document.activeElement) || 0,
							end = false;
						word += chr;

						// match for whole word from current node down (including the current node)
						if(word.length > 1) {
							col.slice(ind).each($.proxy(function (i, v) {
								if($(v).text().toLowerCase().indexOf(word) === 0) {
									$(v).focus();
									end = true;
									return false;
								}
							}, this));
							if(end) { return; }

							// match for whole word from the beginning of the tree
							col.slice(0, ind).each($.proxy(function (i, v) {
								if($(v).text().toLowerCase().indexOf(word) === 0) {
									$(v).focus();
									end = true;
									return false;
								}
							}, this));
							if(end) { return; }
						}
						// list nodes that start with that letter (only if word consists of a single char)
						if(new RegExp('^' + chr.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&') + '+$').test(word)) {
							// search for the next node starting with that letter
							col.slice(ind + 1).each($.proxy(function (i, v) {
								if($(v).text().toLowerCase().charAt(0) === chr) {
									$(v).focus();
									end = true;
									return false;
								}
							}, this));
							if(end) { return; }

							// search from the beginning
							col.slice(0, ind + 1).each($.proxy(function (i, v) {
								if($(v).text().toLowerCase().charAt(0) === chr) {
									$(v).focus();
									end = true;
									return false;
								}
							}, this));
							if(end) { return; }
						}
					}, this))
				// THEME RELATED
				.on("init.jstree", $.proxy(function () {
						var s = this.settings.core.themes;
						this._data.core.themes.dots			= s.dots;
						this._data.core.themes.stripes		= s.stripes;
						this._data.core.themes.icons		= s.icons;
						this._data.core.themes.ellipsis		= s.ellipsis;
						this.set_theme(s.name || "default", s.url);
						this.set_theme_variant(s.variant);
					}, this))
				.on("loading.jstree", $.proxy(function () {
						this[ this._data.core.themes.dots ? "show_dots" : "hide_dots" ]();
						this[ this._data.core.themes.icons ? "show_icons" : "hide_icons" ]();
						this[ this._data.core.themes.stripes ? "show_stripes" : "hide_stripes" ]();
						this[ this._data.core.themes.ellipsis ? "show_ellipsis" : "hide_ellipsis" ]();
					}, this))
				.on('blur.jstree', '.jstree-anchor', $.proxy(function (e) {
						this._data.core.focused = null;
						$(e.currentTarget).filter('.jstree-hovered').mouseleave();
						this.element.attr('tabindex', '0');
					}, this))
				.on('focus.jstree', '.jstree-anchor', $.proxy(function (e) {
						var tmp = this.get_node(e.currentTarget);
						if(tmp && tmp.id) {
							this._data.core.focused = tmp.id;
						}
						this.element.find('.jstree-hovered').not(e.currentTarget).mouseleave();
						$(e.currentTarget).mouseenter();
						this.element.attr('tabindex', '-1');
					}, this))
				.on('focus.jstree', $.proxy(function () {
						if(+(new Date()) - was_click > 500 && !this._data.core.focused) {
							was_click = 0;
							var act = this.get_node(this.element.attr('aria-activedescendant'), true);
							if(act) {
								act.find('> .jstree-anchor').focus();
							}
						}
					}, this))
				.on('mouseenter.jstree', '.jstree-anchor', $.proxy(function (e) {
						this.hover_node(e.currentTarget);
					}, this))
				.on('mouseleave.jstree', '.jstree-anchor', $.proxy(function (e) {
						this.dehover_node(e.currentTarget);
					}, this));
		},
		/**
		 * part of the destroying of an instance. Used internally.
		 * @private
		 * @name unbind()
		 */
		unbind : function () {
			this.element.off('.jstree');
			$(document).off('.jstree-' + this._id);
		},
		/**
		 * trigger an event. Used internally.
		 * @private
		 * @name trigger(ev [, data])
		 * @param  {String} ev the name of the event to trigger
		 * @param  {Object} data additional data to pass with the event
		 */
		trigger : function (ev, data) {
			if(!data) {
				data = {};
			}
			data.instance = this;
			this.element.triggerHandler(ev.replace('.jstree','') + '.jstree', data);
		},
		/**
		 * returns the jQuery extended instance container
		 * @name get_container()
		 * @return {jQuery}
		 */
		get_container : function () {
			return this.element;
		},
		/**
		 * returns the jQuery extended main UL node inside the instance container. Used internally.
		 * @private
		 * @name get_container_ul()
		 * @return {jQuery}
		 */
		get_container_ul : function () {
			return this.element.children(".jstree-children").first();
		},
		/**
		 * gets string replacements (localization). Used internally.
		 * @private
		 * @name get_string(key)
		 * @param  {String} key
		 * @return {String}
		 */
		get_string : function (key) {
			var a = this.settings.core.strings;
			if($.isFunction(a)) { return a.call(this, key); }
			if(a && a[key]) { return a[key]; }
			return key;
		},
		/**
		 * gets the first child of a DOM node. Used internally.
		 * @private
		 * @name _firstChild(dom)
		 * @param  {DOMElement} dom
		 * @return {DOMElement}
		 */
		_firstChild : function (dom) {
			dom = dom ? dom.firstChild : null;
			while(dom !== null && dom.nodeType !== 1) {
				dom = dom.nextSibling;
			}
			return dom;
		},
		/**
		 * gets the next sibling of a DOM node. Used internally.
		 * @private
		 * @name _nextSibling(dom)
		 * @param  {DOMElement} dom
		 * @return {DOMElement}
		 */
		_nextSibling : function (dom) {
			dom = dom ? dom.nextSibling : null;
			while(dom !== null && dom.nodeType !== 1) {
				dom = dom.nextSibling;
			}
			return dom;
		},
		/**
		 * gets the previous sibling of a DOM node. Used internally.
		 * @private
		 * @name _previousSibling(dom)
		 * @param  {DOMElement} dom
		 * @return {DOMElement}
		 */
		_previousSibling : function (dom) {
			dom = dom ? dom.previousSibling : null;
			while(dom !== null && dom.nodeType !== 1) {
				dom = dom.previousSibling;
			}
			return dom;
		},
		/**
		 * get the JSON representation of a node (or the actual jQuery extended DOM node) by using any input (child DOM element, ID string, selector, etc)
		 * @name get_node(obj [, as_dom])
		 * @param  {mixed} obj
		 * @param  {Boolean} as_dom
		 * @return {Object|jQuery}
		 */
		get_node : function (obj, as_dom) {
			if(obj && obj.id) {
				obj = obj.id;
			}
			var dom;
			try {
				if(this._model.data[obj]) {
					obj = this._model.data[obj];
				}
				else if(typeof obj === "string" && this._model.data[obj.replace(/^#/, '')]) {
					obj = this._model.data[obj.replace(/^#/, '')];
				}
				else if(typeof obj === "string" && (dom = $('#' + obj.replace($.jstree.idregex,'\\$&'), this.element)).length && this._model.data[dom.closest('.jstree-node').attr('id')]) {
					obj = this._model.data[dom.closest('.jstree-node').attr('id')];
				}
				else if((dom = $(obj, this.element)).length && this._model.data[dom.closest('.jstree-node').attr('id')]) {
					obj = this._model.data[dom.closest('.jstree-node').attr('id')];
				}
				else if((dom = $(obj, this.element)).length && dom.hasClass('jstree')) {
					obj = this._model.data[$.jstree.root];
				}
				else {
					return false;
				}

				if(as_dom) {
					obj = obj.id === $.jstree.root ? this.element : $('#' + obj.id.replace($.jstree.idregex,'\\$&'), this.element);
				}
				return obj;
			} catch (ex) { return false; }
		},
		/**
		 * get the path to a node, either consisting of node texts, or of node IDs, optionally glued together (otherwise an array)
		 * @name get_path(obj [, glue, ids])
		 * @param  {mixed} obj the node
		 * @param  {String} glue if you want the path as a string - pass the glue here (for example '/'), if a falsy value is supplied here, an array is returned
		 * @param  {Boolean} ids if set to true build the path using ID, otherwise node text is used
		 * @return {mixed}
		 */
		get_path : function (obj, glue, ids) {
			obj = obj.parents ? obj : this.get_node(obj);
			if(!obj || obj.id === $.jstree.root || !obj.parents) {
				return false;
			}
			var i, j, p = [];
			p.push(ids ? obj.id : obj.text);
			for(i = 0, j = obj.parents.length; i < j; i++) {
				p.push(ids ? obj.parents[i] : this.get_text(obj.parents[i]));
			}
			p = p.reverse().slice(1);
			return glue ? p.join(glue) : p;
		},
		/**
		 * get the next visible node that is below the `obj` node. If `strict` is set to `true` only sibling nodes are returned.
		 * @name get_next_dom(obj [, strict])
		 * @param  {mixed} obj
		 * @param  {Boolean} strict
		 * @return {jQuery}
		 */
		get_next_dom : function (obj, strict) {
			var tmp;
			obj = this.get_node(obj, true);
			if(obj[0] === this.element[0]) {
				tmp = this._firstChild(this.get_container_ul()[0]);
				while (tmp && tmp.offsetHeight === 0) {
					tmp = this._nextSibling(tmp);
				}
				return tmp ? $(tmp) : false;
			}
			if(!obj || !obj.length) {
				return false;
			}
			if(strict) {
				tmp = obj[0];
				do {
					tmp = this._nextSibling(tmp);
				} while (tmp && tmp.offsetHeight === 0);
				return tmp ? $(tmp) : false;
			}
			if(obj.hasClass("jstree-open")) {
				tmp = this._firstChild(obj.children('.jstree-children')[0]);
				while (tmp && tmp.offsetHeight === 0) {
					tmp = this._nextSibling(tmp);
				}
				if(tmp !== null) {
					return $(tmp);
				}
			}
			tmp = obj[0];
			do {
				tmp = this._nextSibling(tmp);
			} while (tmp && tmp.offsetHeight === 0);
			if(tmp !== null) {
				return $(tmp);
			}
			return obj.parentsUntil(".jstree",".jstree-node").nextAll(".jstree-node:visible").first();
		},
		/**
		 * get the previous visible node that is above the `obj` node. If `strict` is set to `true` only sibling nodes are returned.
		 * @name get_prev_dom(obj [, strict])
		 * @param  {mixed} obj
		 * @param  {Boolean} strict
		 * @return {jQuery}
		 */
		get_prev_dom : function (obj, strict) {
			var tmp;
			obj = this.get_node(obj, true);
			if(obj[0] === this.element[0]) {
				tmp = this.get_container_ul()[0].lastChild;
				while (tmp && tmp.offsetHeight === 0) {
					tmp = this._previousSibling(tmp);
				}
				return tmp ? $(tmp) : false;
			}
			if(!obj || !obj.length) {
				return false;
			}
			if(strict) {
				tmp = obj[0];
				do {
					tmp = this._previousSibling(tmp);
				} while (tmp && tmp.offsetHeight === 0);
				return tmp ? $(tmp) : false;
			}
			tmp = obj[0];
			do {
				tmp = this._previousSibling(tmp);
			} while (tmp && tmp.offsetHeight === 0);
			if(tmp !== null) {
				obj = $(tmp);
				while(obj.hasClass("jstree-open")) {
					obj = obj.children(".jstree-children").first().children(".jstree-node:visible:last");
				}
				return obj;
			}
			tmp = obj[0].parentNode.parentNode;
			return tmp && tmp.className && tmp.className.indexOf('jstree-node') !== -1 ? $(tmp) : false;
		},
		/**
		 * get the parent ID of a node
		 * @name get_parent(obj)
		 * @param  {mixed} obj
		 * @return {String}
		 */
		get_parent : function (obj) {
			obj = this.get_node(obj);
			if(!obj || obj.id === $.jstree.root) {
				return false;
			}
			return obj.parent;
		},
		/**
		 * get a jQuery collection of all the children of a node (node must be rendered)
		 * @name get_children_dom(obj)
		 * @param  {mixed} obj
		 * @return {jQuery}
		 */
		get_children_dom : function (obj) {
			obj = this.get_node(obj, true);
			if(obj[0] === this.element[0]) {
				return this.get_container_ul().children(".jstree-node");
			}
			if(!obj || !obj.length) {
				return false;
			}
			return obj.children(".jstree-children").children(".jstree-node");
		},
		/**
		 * checks if a node has children
		 * @name is_parent(obj)
		 * @param  {mixed} obj
		 * @return {Boolean}
		 */
		is_parent : function (obj) {
			obj = this.get_node(obj);
			return obj && (obj.state.loaded === false || obj.children.length > 0);
		},
		/**
		 * checks if a node is loaded (its children are available)
		 * @name is_loaded(obj)
		 * @param  {mixed} obj
		 * @return {Boolean}
		 */
		is_loaded : function (obj) {
			obj = this.get_node(obj);
			return obj && obj.state.loaded;
		},
		/**
		 * check if a node is currently loading (fetching children)
		 * @name is_loading(obj)
		 * @param  {mixed} obj
		 * @return {Boolean}
		 */
		is_loading : function (obj) {
			obj = this.get_node(obj);
			return obj && obj.state && obj.state.loading;
		},
		/**
		 * check if a node is opened
		 * @name is_open(obj)
		 * @param  {mixed} obj
		 * @return {Boolean}
		 */
		is_open : function (obj) {
			obj = this.get_node(obj);
			return obj && obj.state.opened;
		},
		/**
		 * check if a node is in a closed state
		 * @name is_closed(obj)
		 * @param  {mixed} obj
		 * @return {Boolean}
		 */
		is_closed : function (obj) {
			obj = this.get_node(obj);
			return obj && this.is_parent(obj) && !obj.state.opened;
		},
		/**
		 * check if a node has no children
		 * @name is_leaf(obj)
		 * @param  {mixed} obj
		 * @return {Boolean}
		 */
		is_leaf : function (obj) {
			return !this.is_parent(obj);
		},
		/**
		 * loads a node (fetches its children using the `core.data` setting). Multiple nodes can be passed to by using an array.
		 * @name load_node(obj [, callback])
		 * @param  {mixed} obj
		 * @param  {function} callback a function to be executed once loading is complete, the function is executed in the instance's scope and receives two arguments - the node and a boolean status
		 * @return {Boolean}
		 * @trigger load_node.jstree
		 */
		load_node : function (obj, callback) {
			var k, l, i, j, c;
			if($.isArray(obj)) {
				this._load_nodes(obj.slice(), callback);
				return true;
			}
			obj = this.get_node(obj);
			if(!obj) {
				if(callback) { callback.call(this, obj, false); }
				return false;
			}
			// if(obj.state.loading) { } // the node is already loading - just wait for it to load and invoke callback? but if called implicitly it should be loaded again?
			if(obj.state.loaded) {
				obj.state.loaded = false;
				for(i = 0, j = obj.parents.length; i < j; i++) {
					this._model.data[obj.parents[i]].children_d = $.vakata.array_filter(this._model.data[obj.parents[i]].children_d, function (v) {
						return $.inArray(v, obj.children_d) === -1;
					});
				}
				for(k = 0, l = obj.children_d.length; k < l; k++) {
					if(this._model.data[obj.children_d[k]].state.selected) {
						c = true;
					}
					delete this._model.data[obj.children_d[k]];
				}
				if (c) {
					this._data.core.selected = $.vakata.array_filter(this._data.core.selected, function (v) {
						return $.inArray(v, obj.children_d) === -1;
					});
				}
				obj.children = [];
				obj.children_d = [];
				if(c) {
					this.trigger('changed', { 'action' : 'load_node', 'node' : obj, 'selected' : this._data.core.selected });
				}
			}
			obj.state.failed = false;
			obj.state.loading = true;
			this.get_node(obj, true).addClass("jstree-loading").attr('aria-busy',true);
			this._load_node(obj, $.proxy(function (status) {
				obj = this._model.data[obj.id];
				obj.state.loading = false;
				obj.state.loaded = status;
				obj.state.failed = !obj.state.loaded;
				var dom = this.get_node(obj, true), i = 0, j = 0, m = this._model.data, has_children = false;
				for(i = 0, j = obj.children.length; i < j; i++) {
					if(m[obj.children[i]] && !m[obj.children[i]].state.hidden) {
						has_children = true;
						break;
					}
				}
				if(obj.state.loaded && dom && dom.length) {
					dom.removeClass('jstree-closed jstree-open jstree-leaf');
					if (!has_children) {
						dom.addClass('jstree-leaf');
					}
					else {
						if (obj.id !== '#') {
							dom.addClass(obj.state.opened ? 'jstree-open' : 'jstree-closed');
						}
					}
				}
				dom.removeClass("jstree-loading").attr('aria-busy',false);
				/**
				 * triggered after a node is loaded
				 * @event
				 * @name load_node.jstree
				 * @param {Object} node the node that was loading
				 * @param {Boolean} status was the node loaded successfully
				 */
				this.trigger('load_node', { "node" : obj, "status" : status });
				if(callback) {
					callback.call(this, obj, status);
				}
			}, this));
			return true;
		},
		/**
		 * load an array of nodes (will also load unavailable nodes as soon as the appear in the structure). Used internally.
		 * @private
		 * @name _load_nodes(nodes [, callback])
		 * @param  {array} nodes
		 * @param  {function} callback a function to be executed once loading is complete, the function is executed in the instance's scope and receives one argument - the array passed to _load_nodes
		 */
		_load_nodes : function (nodes, callback, is_callback, force_reload) {
			var r = true,
				c = function () { this._load_nodes(nodes, callback, true); },
				m = this._model.data, i, j, tmp = [];
			for(i = 0, j = nodes.length; i < j; i++) {
				if(m[nodes[i]] && ( (!m[nodes[i]].state.loaded && !m[nodes[i]].state.failed) || (!is_callback && force_reload) )) {
					if(!this.is_loading(nodes[i])) {
						this.load_node(nodes[i], c);
					}
					r = false;
				}
			}
			if(r) {
				for(i = 0, j = nodes.length; i < j; i++) {
					if(m[nodes[i]] && m[nodes[i]].state.loaded) {
						tmp.push(nodes[i]);
					}
				}
				if(callback && !callback.done) {
					callback.call(this, tmp);
					callback.done = true;
				}
			}
		},
		/**
		 * loads all unloaded nodes
		 * @name load_all([obj, callback])
		 * @param {mixed} obj the node to load recursively, omit to load all nodes in the tree
		 * @param {function} callback a function to be executed once loading all the nodes is complete,
		 * @trigger load_all.jstree
		 */
		load_all : function (obj, callback) {
			if(!obj) { obj = $.jstree.root; }
			obj = this.get_node(obj);
			if(!obj) { return false; }
			var to_load = [],
				m = this._model.data,
				c = m[obj.id].children_d,
				i, j;
			if(obj.state && !obj.state.loaded) {
				to_load.push(obj.id);
			}
			for(i = 0, j = c.length; i < j; i++) {
				if(m[c[i]] && m[c[i]].state && !m[c[i]].state.loaded) {
					to_load.push(c[i]);
				}
			}
			if(to_load.length) {
				this._load_nodes(to_load, function () {
					this.load_all(obj, callback);
				});
			}
			else {
				/**
				 * triggered after a load_all call completes
				 * @event
				 * @name load_all.jstree
				 * @param {Object} node the recursively loaded node
				 */
				if(callback) { callback.call(this, obj); }
				this.trigger('load_all', { "node" : obj });
			}
		},
		/**
		 * handles the actual loading of a node. Used only internally.
		 * @private
		 * @name _load_node(obj [, callback])
		 * @param  {mixed} obj
		 * @param  {function} callback a function to be executed once loading is complete, the function is executed in the instance's scope and receives one argument - a boolean status
		 * @return {Boolean}
		 */
		_load_node : function (obj, callback) {
			var s = this.settings.core.data, t;
			var notTextOrCommentNode = function notTextOrCommentNode () {
				return this.nodeType !== 3 && this.nodeType !== 8;
			};
			// use original HTML
			if(!s) {
				if(obj.id === $.jstree.root) {
					return this._append_html_data(obj, this._data.core.original_container_html.clone(true), function (status) {
						callback.call(this, status);
					});
				}
				else {
					return callback.call(this, false);
				}
				// return callback.call(this, obj.id === $.jstree.root ? this._append_html_data(obj, this._data.core.original_container_html.clone(true)) : false);
			}
			if($.isFunction(s)) {
				return s.call(this, obj, $.proxy(function (d) {
					if(d === false) {
						callback.call(this, false);
					}
					else {
						this[typeof d === 'string' ? '_append_html_data' : '_append_json_data'](obj, typeof d === 'string' ? $($.parseHTML(d)).filter(notTextOrCommentNode) : d, function (status) {
							callback.call(this, status);
						});
					}
					// return d === false ? callback.call(this, false) : callback.call(this, this[typeof d === 'string' ? '_append_html_data' : '_append_json_data'](obj, typeof d === 'string' ? $(d) : d));
				}, this));
			}
			if(typeof s === 'object') {
				if(s.url) {
					s = $.extend(true, {}, s);
					if($.isFunction(s.url)) {
						s.url = s.url.call(this, obj);
					}
					if($.isFunction(s.data)) {
						s.data = s.data.call(this, obj);
					}
					return $.ajax(s)
						.done($.proxy(function (d,t,x) {
								var type = x.getResponseHeader('Content-Type');
								if((type && type.indexOf('json') !== -1) || typeof d === "object") {
									return this._append_json_data(obj, d, function (status) { callback.call(this, status); });
									//return callback.call(this, this._append_json_data(obj, d));
								}
								if((type && type.indexOf('html') !== -1) || typeof d === "string") {
									return this._append_html_data(obj, $($.parseHTML(d)).filter(notTextOrCommentNode), function (status) { callback.call(this, status); });
									// return callback.call(this, this._append_html_data(obj, $(d)));
								}
								this._data.core.last_error = { 'error' : 'ajax', 'plugin' : 'core', 'id' : 'core_04', 'reason' : 'Could not load node', 'data' : JSON.stringify({ 'id' : obj.id, 'xhr' : x }) };
								this.settings.core.error.call(this, this._data.core.last_error);
								return callback.call(this, false);
							}, this))
						.fail($.proxy(function (f) {
								callback.call(this, false);
								this._data.core.last_error = { 'error' : 'ajax', 'plugin' : 'core', 'id' : 'core_04', 'reason' : 'Could not load node', 'data' : JSON.stringify({ 'id' : obj.id, 'xhr' : f }) };
								this.settings.core.error.call(this, this._data.core.last_error);
							}, this));
				}
				t = ($.isArray(s) || $.isPlainObject(s)) ? JSON.parse(JSON.stringify(s)) : s;
				if(obj.id === $.jstree.root) {
					return this._append_json_data(obj, t, function (status) {
						callback.call(this, status);
					});
				}
				else {
					this._data.core.last_error = { 'error' : 'nodata', 'plugin' : 'core', 'id' : 'core_05', 'reason' : 'Could not load node', 'data' : JSON.stringify({ 'id' : obj.id }) };
					this.settings.core.error.call(this, this._data.core.last_error);
					return callback.call(this, false);
				}
				//return callback.call(this, (obj.id === $.jstree.root ? this._append_json_data(obj, t) : false) );
			}
			if(typeof s === 'string') {
				if(obj.id === $.jstree.root) {
					return this._append_html_data(obj, $($.parseHTML(s)).filter(notTextOrCommentNode), function (status) {
						callback.call(this, status);
					});
				}
				else {
					this._data.core.last_error = { 'error' : 'nodata', 'plugin' : 'core', 'id' : 'core_06', 'reason' : 'Could not load node', 'data' : JSON.stringify({ 'id' : obj.id }) };
					this.settings.core.error.call(this, this._data.core.last_error);
					return callback.call(this, false);
				}
				//return callback.call(this, (obj.id === $.jstree.root ? this._append_html_data(obj, $(s)) : false) );
			}
			return callback.call(this, false);
		},
		/**
		 * adds a node to the list of nodes to redraw. Used only internally.
		 * @private
		 * @name _node_changed(obj [, callback])
		 * @param  {mixed} obj
		 */
		_node_changed : function (obj) {
			obj = this.get_node(obj);
			if(obj) {
				this._model.changed.push(obj.id);
			}
		},
		/**
		 * appends HTML content to the tree. Used internally.
		 * @private
		 * @name _append_html_data(obj, data)
		 * @param  {mixed} obj the node to append to
		 * @param  {String} data the HTML string to parse and append
		 * @trigger model.jstree, changed.jstree
		 */
		_append_html_data : function (dom, data, cb) {
			dom = this.get_node(dom);
			dom.children = [];
			dom.children_d = [];
			var dat = data.is('ul') ? data.children() : data,
				par = dom.id,
				chd = [],
				dpc = [],
				m = this._model.data,
				p = m[par],
				s = this._data.core.selected.length,
				tmp, i, j;
			dat.each($.proxy(function (i, v) {
				tmp = this._parse_model_from_html($(v), par, p.parents.concat());
				if(tmp) {
					chd.push(tmp);
					dpc.push(tmp);
					if(m[tmp].children_d.length) {
						dpc = dpc.concat(m[tmp].children_d);
					}
				}
			}, this));
			p.children = chd;
			p.children_d = dpc;
			for(i = 0, j = p.parents.length; i < j; i++) {
				m[p.parents[i]].children_d = m[p.parents[i]].children_d.concat(dpc);
			}
			/**
			 * triggered when new data is inserted to the tree model
			 * @event
			 * @name model.jstree
			 * @param {Array} nodes an array of node IDs
			 * @param {String} parent the parent ID of the nodes
			 */
			this.trigger('model', { "nodes" : dpc, 'parent' : par });
			if(par !== $.jstree.root) {
				this._node_changed(par);
				this.redraw();
			}
			else {
				this.get_container_ul().children('.jstree-initial-node').remove();
				this.redraw(true);
			}
			if(this._data.core.selected.length !== s) {
				this.trigger('changed', { 'action' : 'model', 'selected' : this._data.core.selected });
			}
			cb.call(this, true);
		},
		/**
		 * appends JSON content to the tree. Used internally.
		 * @private
		 * @name _append_json_data(obj, data)
		 * @param  {mixed} obj the node to append to
		 * @param  {String} data the JSON object to parse and append
		 * @param  {Boolean} force_processing internal param - do not set
		 * @trigger model.jstree, changed.jstree
		 */
		_append_json_data : function (dom, data, cb, force_processing) {
			if(this.element === null) { return; }
			dom = this.get_node(dom);
			dom.children = [];
			dom.children_d = [];
			// *%$@!!!
			if(data.d) {
				data = data.d;
				if(typeof data === "string") {
					data = JSON.parse(data);
				}
			}
			if(!$.isArray(data)) { data = [data]; }
			var w = null,
				args = {
					'df'	: this._model.default_state,
					'dat'	: data,
					'par'	: dom.id,
					'm'		: this._model.data,
					't_id'	: this._id,
					't_cnt'	: this._cnt,
					'sel'	: this._data.core.selected
				},
				func = function (data, undefined) {
					if(data.data) { data = data.data; }
					var dat = data.dat,
						par = data.par,
						chd = [],
						dpc = [],
						add = [],
						df = data.df,
						t_id = data.t_id,
						t_cnt = data.t_cnt,
						m = data.m,
						p = m[par],
						sel = data.sel,
						tmp, i, j, rslt,
						parse_flat = function (d, p, ps) {
							if(!ps) { ps = []; }
							else { ps = ps.concat(); }
							if(p) { ps.unshift(p); }
							var tid = d.id.toString(),
								i, j, c, e,
								tmp = {
									id			: tid,
									text		: d.text || '',
									icon		: d.icon !== undefined ? d.icon : true,
									parent		: p,
									parents		: ps,
									children	: d.children || [],
									children_d	: d.children_d || [],
									data		: d.data,
									state		: { },
									li_attr		: { id : false },
									a_attr		: { href : '#' },
									original	: false
								};
							for(i in df) {
								if(df.hasOwnProperty(i)) {
									tmp.state[i] = df[i];
								}
							}
							if(d && d.data && d.data.jstree && d.data.jstree.icon) {
								tmp.icon = d.data.jstree.icon;
							}
							if(tmp.icon === undefined || tmp.icon === null || tmp.icon === "") {
								tmp.icon = true;
							}
							if(d && d.data) {
								tmp.data = d.data;
								if(d.data.jstree) {
									for(i in d.data.jstree) {
										if(d.data.jstree.hasOwnProperty(i)) {
											tmp.state[i] = d.data.jstree[i];
										}
									}
								}
							}
							if(d && typeof d.state === 'object') {
								for (i in d.state) {
									if(d.state.hasOwnProperty(i)) {
										tmp.state[i] = d.state[i];
									}
								}
							}
							if(d && typeof d.li_attr === 'object') {
								for (i in d.li_attr) {
									if(d.li_attr.hasOwnProperty(i)) {
										tmp.li_attr[i] = d.li_attr[i];
									}
								}
							}
							if(!tmp.li_attr.id) {
								tmp.li_attr.id = tid;
							}
							if(d && typeof d.a_attr === 'object') {
								for (i in d.a_attr) {
									if(d.a_attr.hasOwnProperty(i)) {
										tmp.a_attr[i] = d.a_attr[i];
									}
								}
							}
							if(d && d.children && d.children === true) {
								tmp.state.loaded = false;
								tmp.children = [];
								tmp.children_d = [];
							}
							m[tmp.id] = tmp;
							for(i = 0, j = tmp.children.length; i < j; i++) {
								c = parse_flat(m[tmp.children[i]], tmp.id, ps);
								e = m[c];
								tmp.children_d.push(c);
								if(e.children_d.length) {
									tmp.children_d = tmp.children_d.concat(e.children_d);
								}
							}
							delete d.data;
							delete d.children;
							m[tmp.id].original = d;
							if(tmp.state.selected) {
								add.push(tmp.id);
							}
							return tmp.id;
						},
						parse_nest = function (d, p, ps) {
							if(!ps) { ps = []; }
							else { ps = ps.concat(); }
							if(p) { ps.unshift(p); }
							var tid = false, i, j, c, e, tmp;
							do {
								tid = 'j' + t_id + '_' + (++t_cnt);
							} while(m[tid]);

							tmp = {
								id			: false,
								text		: typeof d === 'string' ? d : '',
								icon		: typeof d === 'object' && d.icon !== undefined ? d.icon : true,
								parent		: p,
								parents		: ps,
								children	: [],
								children_d	: [],
								data		: null,
								state		: { },
								li_attr		: { id : false },
								a_attr		: { href : '#' },
								original	: false
							};
							for(i in df) {
								if(df.hasOwnProperty(i)) {
									tmp.state[i] = df[i];
								}
							}
							if(d && d.id) { tmp.id = d.id.toString(); }
							if(d && d.text) { tmp.text = d.text; }
							if(d && d.data && d.data.jstree && d.data.jstree.icon) {
								tmp.icon = d.data.jstree.icon;
							}
							if(tmp.icon === undefined || tmp.icon === null || tmp.icon === "") {
								tmp.icon = true;
							}
							if(d && d.data) {
								tmp.data = d.data;
								if(d.data.jstree) {
									for(i in d.data.jstree) {
										if(d.data.jstree.hasOwnProperty(i)) {
											tmp.state[i] = d.data.jstree[i];
										}
									}
								}
							}
							if(d && typeof d.state === 'object') {
								for (i in d.state) {
									if(d.state.hasOwnProperty(i)) {
										tmp.state[i] = d.state[i];
									}
								}
							}
							if(d && typeof d.li_attr === 'object') {
								for (i in d.li_attr) {
									if(d.li_attr.hasOwnProperty(i)) {
										tmp.li_attr[i] = d.li_attr[i];
									}
								}
							}
							if(tmp.li_attr.id && !tmp.id) {
								tmp.id = tmp.li_attr.id.toString();
							}
							if(!tmp.id) {
								tmp.id = tid;
							}
							if(!tmp.li_attr.id) {
								tmp.li_attr.id = tmp.id;
							}
							if(d && typeof d.a_attr === 'object') {
								for (i in d.a_attr) {
									if(d.a_attr.hasOwnProperty(i)) {
										tmp.a_attr[i] = d.a_attr[i];
									}
								}
							}
							if(d && d.children && d.children.length) {
								for(i = 0, j = d.children.length; i < j; i++) {
									c = parse_nest(d.children[i], tmp.id, ps);
									e = m[c];
									tmp.children.push(c);
									if(e.children_d.length) {
										tmp.children_d = tmp.children_d.concat(e.children_d);
									}
								}
								tmp.children_d = tmp.children_d.concat(tmp.children);
							}
							if(d && d.children && d.children === true) {
								tmp.state.loaded = false;
								tmp.children = [];
								tmp.children_d = [];
							}
							delete d.data;
							delete d.children;
							tmp.original = d;
							m[tmp.id] = tmp;
							if(tmp.state.selected) {
								add.push(tmp.id);
							}
							return tmp.id;
						};

					if(dat.length && dat[0].id !== undefined && dat[0].parent !== undefined) {
						// Flat JSON support (for easy import from DB):
						// 1) convert to object (foreach)
						for(i = 0, j = dat.length; i < j; i++) {
							if(!dat[i].children) {
								dat[i].children = [];
							}
							m[dat[i].id.toString()] = dat[i];
						}
						// 2) populate children (foreach)
						for(i = 0, j = dat.length; i < j; i++) {
							m[dat[i].parent.toString()].children.push(dat[i].id.toString());
							// populate parent.children_d
							p.children_d.push(dat[i].id.toString());
						}
						// 3) normalize && populate parents and children_d with recursion
						for(i = 0, j = p.children.length; i < j; i++) {
							tmp = parse_flat(m[p.children[i]], par, p.parents.concat());
							dpc.push(tmp);
							if(m[tmp].children_d.length) {
								dpc = dpc.concat(m[tmp].children_d);
							}
						}
						for(i = 0, j = p.parents.length; i < j; i++) {
							m[p.parents[i]].children_d = m[p.parents[i]].children_d.concat(dpc);
						}
						// ?) three_state selection - p.state.selected && t - (if three_state foreach(dat => ch) -> foreach(parents) if(parent.selected) child.selected = true;
						rslt = {
							'cnt' : t_cnt,
							'mod' : m,
							'sel' : sel,
							'par' : par,
							'dpc' : dpc,
							'add' : add
						};
					}
					else {
						for(i = 0, j = dat.length; i < j; i++) {
							tmp = parse_nest(dat[i], par, p.parents.concat());
							if(tmp) {
								chd.push(tmp);
								dpc.push(tmp);
								if(m[tmp].children_d.length) {
									dpc = dpc.concat(m[tmp].children_d);
								}
							}
						}
						p.children = chd;
						p.children_d = dpc;
						for(i = 0, j = p.parents.length; i < j; i++) {
							m[p.parents[i]].children_d = m[p.parents[i]].children_d.concat(dpc);
						}
						rslt = {
							'cnt' : t_cnt,
							'mod' : m,
							'sel' : sel,
							'par' : par,
							'dpc' : dpc,
							'add' : add
						};
					}
					if(typeof window === 'undefined' || typeof window.document === 'undefined') {
						postMessage(rslt);
					}
					else {
						return rslt;
					}
				},
				rslt = function (rslt, worker) {
					if(this.element === null) { return; }
					this._cnt = rslt.cnt;
					var i, m = this._model.data;
					for (i in m) {
						if (m.hasOwnProperty(i) && m[i].state && m[i].state.loading && rslt.mod[i]) {
							rslt.mod[i].state.loading = true;
						}
					}
					this._model.data = rslt.mod; // breaks the reference in load_node - careful

					if(worker) {
						var j, a = rslt.add, r = rslt.sel, s = this._data.core.selected.slice();
						m = this._model.data;
						// if selection was changed while calculating in worker
						if(r.length !== s.length || $.vakata.array_unique(r.concat(s)).length !== r.length) {
							// deselect nodes that are no longer selected
							for(i = 0, j = r.length; i < j; i++) {
								if($.inArray(r[i], a) === -1 && $.inArray(r[i], s) === -1) {
									m[r[i]].state.selected = false;
								}
							}
							// select nodes that were selected in the mean time
							for(i = 0, j = s.length; i < j; i++) {
								if($.inArray(s[i], r) === -1) {
									m[s[i]].state.selected = true;
								}
							}
						}
					}
					if(rslt.add.length) {
						this._data.core.selected = this._data.core.selected.concat(rslt.add);
					}

					this.trigger('model', { "nodes" : rslt.dpc, 'parent' : rslt.par });

					if(rslt.par !== $.jstree.root) {
						this._node_changed(rslt.par);
						this.redraw();
					}
					else {
						// this.get_container_ul().children('.jstree-initial-node').remove();
						this.redraw(true);
					}
					if(rslt.add.length) {
						this.trigger('changed', { 'action' : 'model', 'selected' : this._data.core.selected });
					}
					cb.call(this, true);
				};
			if(this.settings.core.worker && window.Blob && window.URL && window.Worker) {
				try {
					if(this._wrk === null) {
						this._wrk = window.URL.createObjectURL(
							new window.Blob(
								['self.onmessage = ' + func.toString()],
								{type:"text/javascript"}
							)
						);
					}
					if(!this._data.core.working || force_processing) {
						this._data.core.working = true;
						w = new window.Worker(this._wrk);
						w.onmessage = $.proxy(function (e) {
							rslt.call(this, e.data, true);
							try { w.terminate(); w = null; } catch(ignore) { }
							if(this._data.core.worker_queue.length) {
								this._append_json_data.apply(this, this._data.core.worker_queue.shift());
							}
							else {
								this._data.core.working = false;
							}
						}, this);
						if(!args.par) {
							if(this._data.core.worker_queue.length) {
								this._append_json_data.apply(this, this._data.core.worker_queue.shift());
							}
							else {
								this._data.core.working = false;
							}
						}
						else {
							w.postMessage(args);
						}
					}
					else {
						this._data.core.worker_queue.push([dom, data, cb, true]);
					}
				}
				catch(e) {
					rslt.call(this, func(args), false);
					if(this._data.core.worker_queue.length) {
						this._append_json_data.apply(this, this._data.core.worker_queue.shift());
					}
					else {
						this._data.core.working = false;
					}
				}
			}
			else {
				rslt.call(this, func(args), false);
			}
		},
		/**
		 * parses a node from a jQuery object and appends them to the in memory tree model. Used internally.
		 * @private
		 * @name _parse_model_from_html(d [, p, ps])
		 * @param  {jQuery} d the jQuery object to parse
		 * @param  {String} p the parent ID
		 * @param  {Array} ps list of all parents
		 * @return {String} the ID of the object added to the model
		 */
		_parse_model_from_html : function (d, p, ps) {
			if(!ps) { ps = []; }
			else { ps = [].concat(ps); }
			if(p) { ps.unshift(p); }
			var c, e, m = this._model.data,
				data = {
					id			: false,
					text		: false,
					icon		: true,
					parent		: p,
					parents		: ps,
					children	: [],
					children_d	: [],
					data		: null,
					state		: { },
					li_attr		: { id : false },
					a_attr		: { href : '#' },
					original	: false
				}, i, tmp, tid;
			for(i in this._model.default_state) {
				if(this._model.default_state.hasOwnProperty(i)) {
					data.state[i] = this._model.default_state[i];
				}
			}
			tmp = $.vakata.attributes(d, true);
			$.each(tmp, function (i, v) {
				v = $.trim(v);
				if(!v.length) { return true; }
				data.li_attr[i] = v;
				if(i === 'id') {
					data.id = v.toString();
				}
			});
			tmp = d.children('a').first();
			if(tmp.length) {
				tmp = $.vakata.attributes(tmp, true);
				$.each(tmp, function (i, v) {
					v = $.trim(v);
					if(v.length) {
						data.a_attr[i] = v;
					}
				});
			}
			tmp = d.children("a").first().length ? d.children("a").first().clone() : d.clone();
			tmp.children("ins, i, ul").remove();
			tmp = tmp.html();
			tmp = $('<div />').html(tmp);
			data.text = this.settings.core.force_text ? tmp.text() : tmp.html();
			tmp = d.data();
			data.data = tmp ? $.extend(true, {}, tmp) : null;
			data.state.opened = d.hasClass('jstree-open');
			data.state.selected = d.children('a').hasClass('jstree-clicked');
			data.state.disabled = d.children('a').hasClass('jstree-disabled');
			if(data.data && data.data.jstree) {
				for(i in data.data.jstree) {
					if(data.data.jstree.hasOwnProperty(i)) {
						data.state[i] = data.data.jstree[i];
					}
				}
			}
			tmp = d.children("a").children(".jstree-themeicon");
			if(tmp.length) {
				data.icon = tmp.hasClass('jstree-themeicon-hidden') ? false : tmp.attr('rel');
			}
			if(data.state.icon !== undefined) {
				data.icon = data.state.icon;
			}
			if(data.icon === undefined || data.icon === null || data.icon === "") {
				data.icon = true;
			}
			tmp = d.children("ul").children("li");
			do {
				tid = 'j' + this._id + '_' + (++this._cnt);
			} while(m[tid]);
			data.id = data.li_attr.id ? data.li_attr.id.toString() : tid;
			if(tmp.length) {
				tmp.each($.proxy(function (i, v) {
					c = this._parse_model_from_html($(v), data.id, ps);
					e = this._model.data[c];
					data.children.push(c);
					if(e.children_d.length) {
						data.children_d = data.children_d.concat(e.children_d);
					}
				}, this));
				data.children_d = data.children_d.concat(data.children);
			}
			else {
				if(d.hasClass('jstree-closed')) {
					data.state.loaded = false;
				}
			}
			if(data.li_attr['class']) {
				data.li_attr['class'] = data.li_attr['class'].replace('jstree-closed','').replace('jstree-open','');
			}
			if(data.a_attr['class']) {
				data.a_attr['class'] = data.a_attr['class'].replace('jstree-clicked','').replace('jstree-disabled','');
			}
			m[data.id] = data;
			if(data.state.selected) {
				this._data.core.selected.push(data.id);
			}
			return data.id;
		},
		/**
		 * parses a node from a JSON object (used when dealing with flat data, which has no nesting of children, but has id and parent properties) and appends it to the in memory tree model. Used internally.
		 * @private
		 * @name _parse_model_from_flat_json(d [, p, ps])
		 * @param  {Object} d the JSON object to parse
		 * @param  {String} p the parent ID
		 * @param  {Array} ps list of all parents
		 * @return {String} the ID of the object added to the model
		 */
		_parse_model_from_flat_json : function (d, p, ps) {
			if(!ps) { ps = []; }
			else { ps = ps.concat(); }
			if(p) { ps.unshift(p); }
			var tid = d.id.toString(),
				m = this._model.data,
				df = this._model.default_state,
				i, j, c, e,
				tmp = {
					id			: tid,
					text		: d.text || '',
					icon		: d.icon !== undefined ? d.icon : true,
					parent		: p,
					parents		: ps,
					children	: d.children || [],
					children_d	: d.children_d || [],
					data		: d.data,
					state		: { },
					li_attr		: { id : false },
					a_attr		: { href : '#' },
					original	: false
				};
			for(i in df) {
				if(df.hasOwnProperty(i)) {
					tmp.state[i] = df[i];
				}
			}
			if(d && d.data && d.data.jstree && d.data.jstree.icon) {
				tmp.icon = d.data.jstree.icon;
			}
			if(tmp.icon === undefined || tmp.icon === null || tmp.icon === "") {
				tmp.icon = true;
			}
			if(d && d.data) {
				tmp.data = d.data;
				if(d.data.jstree) {
					for(i in d.data.jstree) {
						if(d.data.jstree.hasOwnProperty(i)) {
							tmp.state[i] = d.data.jstree[i];
						}
					}
				}
			}
			if(d && typeof d.state === 'object') {
				for (i in d.state) {
					if(d.state.hasOwnProperty(i)) {
						tmp.state[i] = d.state[i];
					}
				}
			}
			if(d && typeof d.li_attr === 'object') {
				for (i in d.li_attr) {
					if(d.li_attr.hasOwnProperty(i)) {
						tmp.li_attr[i] = d.li_attr[i];
					}
				}
			}
			if(!tmp.li_attr.id) {
				tmp.li_attr.id = tid;
			}
			if(d && typeof d.a_attr === 'object') {
				for (i in d.a_attr) {
					if(d.a_attr.hasOwnProperty(i)) {
						tmp.a_attr[i] = d.a_attr[i];
					}
				}
			}
			if(d && d.children && d.children === true) {
				tmp.state.loaded = false;
				tmp.children = [];
				tmp.children_d = [];
			}
			m[tmp.id] = tmp;
			for(i = 0, j = tmp.children.length; i < j; i++) {
				c = this._parse_model_from_flat_json(m[tmp.children[i]], tmp.id, ps);
				e = m[c];
				tmp.children_d.push(c);
				if(e.children_d.length) {
					tmp.children_d = tmp.children_d.concat(e.children_d);
				}
			}
			delete d.data;
			delete d.children;
			m[tmp.id].original = d;
			if(tmp.state.selected) {
				this._data.core.selected.push(tmp.id);
			}
			return tmp.id;
		},
		/**
		 * parses a node from a JSON object and appends it to the in memory tree model. Used internally.
		 * @private
		 * @name _parse_model_from_json(d [, p, ps])
		 * @param  {Object} d the JSON object to parse
		 * @param  {String} p the parent ID
		 * @param  {Array} ps list of all parents
		 * @return {String} the ID of the object added to the model
		 */
		_parse_model_from_json : function (d, p, ps) {
			if(!ps) { ps = []; }
			else { ps = ps.concat(); }
			if(p) { ps.unshift(p); }
			var tid = false, i, j, c, e, m = this._model.data, df = this._model.default_state, tmp;
			do {
				tid = 'j' + this._id + '_' + (++this._cnt);
			} while(m[tid]);

			tmp = {
				id			: false,
				text		: typeof d === 'string' ? d : '',
				icon		: typeof d === 'object' && d.icon !== undefined ? d.icon : true,
				parent		: p,
				parents		: ps,
				children	: [],
				children_d	: [],
				data		: null,
				state		: { },
				li_attr		: { id : false },
				a_attr		: { href : '#' },
				original	: false
			};
			for(i in df) {
				if(df.hasOwnProperty(i)) {
					tmp.state[i] = df[i];
				}
			}
			if(d && d.id) { tmp.id = d.id.toString(); }
			if(d && d.text) { tmp.text = d.text; }
			if(d && d.data && d.data.jstree && d.data.jstree.icon) {
				tmp.icon = d.data.jstree.icon;
			}
			if(tmp.icon === undefined || tmp.icon === null || tmp.icon === "") {
				tmp.icon = true;
			}
			if(d && d.data) {
				tmp.data = d.data;
				if(d.data.jstree) {
					for(i in d.data.jstree) {
						if(d.data.jstree.hasOwnProperty(i)) {
							tmp.state[i] = d.data.jstree[i];
						}
					}
				}
			}
			if(d && typeof d.state === 'object') {
				for (i in d.state) {
					if(d.state.hasOwnProperty(i)) {
						tmp.state[i] = d.state[i];
					}
				}
			}
			if(d && typeof d.li_attr === 'object') {
				for (i in d.li_attr) {
					if(d.li_attr.hasOwnProperty(i)) {
						tmp.li_attr[i] = d.li_attr[i];
					}
				}
			}
			if(tmp.li_attr.id && !tmp.id) {
				tmp.id = tmp.li_attr.id.toString();
			}
			if(!tmp.id) {
				tmp.id = tid;
			}
			if(!tmp.li_attr.id) {
				tmp.li_attr.id = tmp.id;
			}
			if(d && typeof d.a_attr === 'object') {
				for (i in d.a_attr) {
					if(d.a_attr.hasOwnProperty(i)) {
						tmp.a_attr[i] = d.a_attr[i];
					}
				}
			}
			if(d && d.children && d.children.length) {
				for(i = 0, j = d.children.length; i < j; i++) {
					c = this._parse_model_from_json(d.children[i], tmp.id, ps);
					e = m[c];
					tmp.children.push(c);
					if(e.children_d.length) {
						tmp.children_d = tmp.children_d.concat(e.children_d);
					}
				}
				tmp.children_d = tmp.children_d.concat(tmp.children);
			}
			if(d && d.children && d.children === true) {
				tmp.state.loaded = false;
				tmp.children = [];
				tmp.children_d = [];
			}
			delete d.data;
			delete d.children;
			tmp.original = d;
			m[tmp.id] = tmp;
			if(tmp.state.selected) {
				this._data.core.selected.push(tmp.id);
			}
			return tmp.id;
		},
		/**
		 * redraws all nodes that need to be redrawn. Used internally.
		 * @private
		 * @name _redraw()
		 * @trigger redraw.jstree
		 */
		_redraw : function () {
			var nodes = this._model.force_full_redraw ? this._model.data[$.jstree.root].children.concat([]) : this._model.changed.concat([]),
				f = document.createElement('UL'), tmp, i, j, fe = this._data.core.focused;
			for(i = 0, j = nodes.length; i < j; i++) {
				tmp = this.redraw_node(nodes[i], true, this._model.force_full_redraw);
				if(tmp && this._model.force_full_redraw) {
					f.appendChild(tmp);
				}
			}
			if(this._model.force_full_redraw) {
				f.className = this.get_container_ul()[0].className;
				f.setAttribute('role','group');
				this.element.empty().append(f);
				//this.get_container_ul()[0].appendChild(f);
			}
			if(fe !== null) {
				tmp = this.get_node(fe, true);
				if(tmp && tmp.length && tmp.children('.jstree-anchor')[0] !== document.activeElement) {
					tmp.children('.jstree-anchor').focus();
				}
				else {
					this._data.core.focused = null;
				}
			}
			this._model.force_full_redraw = false;
			this._model.changed = [];
			/**
			 * triggered after nodes are redrawn
			 * @event
			 * @name redraw.jstree
			 * @param {array} nodes the redrawn nodes
			 */
			this.trigger('redraw', { "nodes" : nodes });
		},
		/**
		 * redraws all nodes that need to be redrawn or optionally - the whole tree
		 * @name redraw([full])
		 * @param {Boolean} full if set to `true` all nodes are redrawn.
		 */
		redraw : function (full) {
			if(full) {
				this._model.force_full_redraw = true;
			}
			//if(this._model.redraw_timeout) {
			//	clearTimeout(this._model.redraw_timeout);
			//}
			//this._model.redraw_timeout = setTimeout($.proxy(this._redraw, this),0);
			this._redraw();
		},
		/**
		 * redraws a single node's children. Used internally.
		 * @private
		 * @name draw_children(node)
		 * @param {mixed} node the node whose children will be redrawn
		 */
		draw_children : function (node) {
			var obj = this.get_node(node),
				i = false,
				j = false,
				k = false,
				d = document;
			if(!obj) { return false; }
			if(obj.id === $.jstree.root) { return this.redraw(true); }
			node = this.get_node(node, true);
			if(!node || !node.length) { return false; } // TODO: quick toggle

			node.children('.jstree-children').remove();
			node = node[0];
			if(obj.children.length && obj.state.loaded) {
				k = d.createElement('UL');
				k.setAttribute('role', 'group');
				k.className = 'jstree-children';
				for(i = 0, j = obj.children.length; i < j; i++) {
					k.appendChild(this.redraw_node(obj.children[i], true, true));
				}
				node.appendChild(k);
			}
		},
		/**
		 * redraws a single node. Used internally.
		 * @private
		 * @name redraw_node(node, deep, is_callback, force_render)
		 * @param {mixed} node the node to redraw
		 * @param {Boolean} deep should child nodes be redrawn too
		 * @param {Boolean} is_callback is this a recursion call
		 * @param {Boolean} force_render should children of closed parents be drawn anyway
		 */
		redraw_node : function (node, deep, is_callback, force_render) {
			var obj = this.get_node(node),
				par = false,
				ind = false,
				old = false,
				i = false,
				j = false,
				k = false,
				c = '',
				d = document,
				m = this._model.data,
				f = false,
				s = false,
				tmp = null,
				t = 0,
				l = 0,
				has_children = false,
				last_sibling = false;
			if(!obj) { return false; }
			if(obj.id === $.jstree.root) {  return this.redraw(true); }
			deep = deep || obj.children.length === 0;
			node = !document.querySelector ? document.getElementById(obj.id) : this.element[0].querySelector('#' + ("0123456789".indexOf(obj.id[0]) !== -1 ? '\\3' + obj.id[0] + ' ' + obj.id.substr(1).replace($.jstree.idregex,'\\$&') : obj.id.replace($.jstree.idregex,'\\$&')) ); //, this.element);
			if(!node) {
				deep = true;
				//node = d.createElement('LI');
				if(!is_callback) {
					par = obj.parent !== $.jstree.root ? $('#' + obj.parent.replace($.jstree.idregex,'\\$&'), this.element)[0] : null;
					if(par !== null && (!par || !m[obj.parent].state.opened)) {
						return false;
					}
					ind = $.inArray(obj.id, par === null ? m[$.jstree.root].children : m[obj.parent].children);
				}
			}
			else {
				node = $(node);
				if(!is_callback) {
					par = node.parent().parent()[0];
					if(par === this.element[0]) {
						par = null;
					}
					ind = node.index();
				}
				// m[obj.id].data = node.data(); // use only node's data, no need to touch jquery storage
				if(!deep && obj.children.length && !node.children('.jstree-children').length) {
					deep = true;
				}
				if(!deep) {
					old = node.children('.jstree-children')[0];
				}
				f = node.children('.jstree-anchor')[0] === document.activeElement;
				node.remove();
				//node = d.createElement('LI');
				//node = node[0];
			}
			node = this._data.core.node.cloneNode(true);
			// node is DOM, deep is boolean

			c = 'jstree-node ';
			for(i in obj.li_attr) {
				if(obj.li_attr.hasOwnProperty(i)) {
					if(i === 'id') { continue; }
					if(i !== 'class') {
						node.setAttribute(i, obj.li_attr[i]);
					}
					else {
						c += obj.li_attr[i];
					}
				}
			}
			if(!obj.a_attr.id) {
				obj.a_attr.id = obj.id + '_anchor';
			}
			node.setAttribute('aria-selected', !!obj.state.selected);
			node.setAttribute('aria-level', obj.parents.length);
			node.setAttribute('aria-labelledby', obj.a_attr.id);
			if(obj.state.disabled) {
				node.setAttribute('aria-disabled', true);
			}

			for(i = 0, j = obj.children.length; i < j; i++) {
				if(!m[obj.children[i]].state.hidden) {
					has_children = true;
					break;
				}
			}
			if(obj.parent !== null && m[obj.parent] && !obj.state.hidden) {
				i = $.inArray(obj.id, m[obj.parent].children);
				last_sibling = obj.id;
				if(i !== -1) {
					i++;
					for(j = m[obj.parent].children.length; i < j; i++) {
						if(!m[m[obj.parent].children[i]].state.hidden) {
							last_sibling = m[obj.parent].children[i];
						}
						if(last_sibling !== obj.id) {
							break;
						}
					}
				}
			}

			if(obj.state.hidden) {
				c += ' jstree-hidden';
			}
			if(obj.state.loaded && !has_children) {
				c += ' jstree-leaf';
			}
			else {
				c += obj.state.opened && obj.state.loaded ? ' jstree-open' : ' jstree-closed';
				node.setAttribute('aria-expanded', (obj.state.opened && obj.state.loaded) );
			}
			if(last_sibling === obj.id) {
				c += ' jstree-last';
			}
			node.id = obj.id;
			node.className = c;
			c = ( obj.state.selected ? ' jstree-clicked' : '') + ( obj.state.disabled ? ' jstree-disabled' : '');
			for(j in obj.a_attr) {
				if(obj.a_attr.hasOwnProperty(j)) {
					if(j === 'href' && obj.a_attr[j] === '#') { continue; }
					if(j !== 'class') {
						node.childNodes[1].setAttribute(j, obj.a_attr[j]);
					}
					else {
						c += ' ' + obj.a_attr[j];
					}
				}
			}
			if(c.length) {
				node.childNodes[1].className = 'jstree-anchor ' + c;
			}
			if((obj.icon && obj.icon !== true) || obj.icon === false) {
				if(obj.icon === false) {
					node.childNodes[1].childNodes[0].className += ' jstree-themeicon-hidden';
				}
				else if(obj.icon.indexOf('/') === -1 && obj.icon.indexOf('.') === -1) {
					node.childNodes[1].childNodes[0].className += ' ' + obj.icon + ' jstree-themeicon-custom';
				}
				else {
					node.childNodes[1].childNodes[0].style.backgroundImage = 'url("'+obj.icon+'")';
					node.childNodes[1].childNodes[0].style.backgroundPosition = 'center center';
					node.childNodes[1].childNodes[0].style.backgroundSize = 'auto';
					node.childNodes[1].childNodes[0].className += ' jstree-themeicon-custom';
				}
			}

			if(this.settings.core.force_text) {
				node.childNodes[1].appendChild(d.createTextNode(obj.text));
			}
			else {
				node.childNodes[1].innerHTML += obj.text;
			}


			if(deep && obj.children.length && (obj.state.opened || force_render) && obj.state.loaded) {
				k = d.createElement('UL');
				k.setAttribute('role', 'group');
				k.className = 'jstree-children';
				for(i = 0, j = obj.children.length; i < j; i++) {
					k.appendChild(this.redraw_node(obj.children[i], deep, true));
				}
				node.appendChild(k);
			}
			if(old) {
				node.appendChild(old);
			}
			if(!is_callback) {
				// append back using par / ind
				if(!par) {
					par = this.element[0];
				}
				for(i = 0, j = par.childNodes.length; i < j; i++) {
					if(par.childNodes[i] && par.childNodes[i].className && par.childNodes[i].className.indexOf('jstree-children') !== -1) {
						tmp = par.childNodes[i];
						break;
					}
				}
				if(!tmp) {
					tmp = d.createElement('UL');
					tmp.setAttribute('role', 'group');
					tmp.className = 'jstree-children';
					par.appendChild(tmp);
				}
				par = tmp;

				if(ind < par.childNodes.length) {
					par.insertBefore(node, par.childNodes[ind]);
				}
				else {
					par.appendChild(node);
				}
				if(f) {
					t = this.element[0].scrollTop;
					l = this.element[0].scrollLeft;
					node.childNodes[1].focus();
					this.element[0].scrollTop = t;
					this.element[0].scrollLeft = l;
				}
			}
			if(obj.state.opened && !obj.state.loaded) {
				obj.state.opened = false;
				setTimeout($.proxy(function () {
					this.open_node(obj.id, false, 0);
				}, this), 0);
			}
			return node;
		},
		/**
		 * opens a node, revaling its children. If the node is not loaded it will be loaded and opened once ready.
		 * @name open_node(obj [, callback, animation])
		 * @param {mixed} obj the node to open
		 * @param {Function} callback a function to execute once the node is opened
		 * @param {Number} animation the animation duration in milliseconds when opening the node (overrides the `core.animation` setting). Use `false` for no animation.
		 * @trigger open_node.jstree, after_open.jstree, before_open.jstree
		 */
		open_node : function (obj, callback, animation) {
			var t1, t2, d, t;
			if($.isArray(obj)) {
				obj = obj.slice();
				for(t1 = 0, t2 = obj.length; t1 < t2; t1++) {
					this.open_node(obj[t1], callback, animation);
				}
				return true;
			}
			obj = this.get_node(obj);
			if(!obj || obj.id === $.jstree.root) {
				return false;
			}
			animation = animation === undefined ? this.settings.core.animation : animation;
			if(!this.is_closed(obj)) {
				if(callback) {
					callback.call(this, obj, false);
				}
				return false;
			}
			if(!this.is_loaded(obj)) {
				if(this.is_loading(obj)) {
					return setTimeout($.proxy(function () {
						this.open_node(obj, callback, animation);
					}, this), 500);
				}
				this.load_node(obj, function (o, ok) {
					return ok ? this.open_node(o, callback, animation) : (callback ? callback.call(this, o, false) : false);
				});
			}
			else {
				d = this.get_node(obj, true);
				t = this;
				if(d.length) {
					if(animation && d.children(".jstree-children").length) {
						d.children(".jstree-children").stop(true, true);
					}
					if(obj.children.length && !this._firstChild(d.children('.jstree-children')[0])) {
						this.draw_children(obj);
						//d = this.get_node(obj, true);
					}
					if(!animation) {
						this.trigger('before_open', { "node" : obj });
						d[0].className = d[0].className.replace('jstree-closed', 'jstree-open');
						d[0].setAttribute("aria-expanded", true);
					}
					else {
						this.trigger('before_open', { "node" : obj });
						d
							.children(".jstree-children").css("display","none").end()
							.removeClass("jstree-closed").addClass("jstree-open").attr("aria-expanded", true)
							.children(".jstree-children").stop(true, true)
								.slideDown(animation, function () {
									this.style.display = "";
									if (t.element) {
										t.trigger("after_open", { "node" : obj });
									}
								});
					}
				}
				obj.state.opened = true;
				if(callback) {
					callback.call(this, obj, true);
				}
				if(!d.length) {
					/**
					 * triggered when a node is about to be opened (if the node is supposed to be in the DOM, it will be, but it won't be visible yet)
					 * @event
					 * @name before_open.jstree
					 * @param {Object} node the opened node
					 */
					this.trigger('before_open', { "node" : obj });
				}
				/**
				 * triggered when a node is opened (if there is an animation it will not be completed yet)
				 * @event
				 * @name open_node.jstree
				 * @param {Object} node the opened node
				 */
				this.trigger('open_node', { "node" : obj });
				if(!animation || !d.length) {
					/**
					 * triggered when a node is opened and the animation is complete
					 * @event
					 * @name after_open.jstree
					 * @param {Object} node the opened node
					 */
					this.trigger("after_open", { "node" : obj });
				}
				return true;
			}
		},
		/**
		 * opens every parent of a node (node should be loaded)
		 * @name _open_to(obj)
		 * @param {mixed} obj the node to reveal
		 * @private
		 */
		_open_to : function (obj) {
			obj = this.get_node(obj);
			if(!obj || obj.id === $.jstree.root) {
				return false;
			}
			var i, j, p = obj.parents;
			for(i = 0, j = p.length; i < j; i+=1) {
				if(i !== $.jstree.root) {
					this.open_node(p[i], false, 0);
				}
			}
			return $('#' + obj.id.replace($.jstree.idregex,'\\$&'), this.element);
		},
		/**
		 * closes a node, hiding its children
		 * @name close_node(obj [, animation])
		 * @param {mixed} obj the node to close
		 * @param {Number} animation the animation duration in milliseconds when closing the node (overrides the `core.animation` setting). Use `false` for no animation.
		 * @trigger close_node.jstree, after_close.jstree
		 */
		close_node : function (obj, animation) {
			var t1, t2, t, d;
			if($.isArray(obj)) {
				obj = obj.slice();
				for(t1 = 0, t2 = obj.length; t1 < t2; t1++) {
					this.close_node(obj[t1], animation);
				}
				return true;
			}
			obj = this.get_node(obj);
			if(!obj || obj.id === $.jstree.root) {
				return false;
			}
			if(this.is_closed(obj)) {
				return false;
			}
			animation = animation === undefined ? this.settings.core.animation : animation;
			t = this;
			d = this.get_node(obj, true);

			obj.state.opened = false;
			/**
			 * triggered when a node is closed (if there is an animation it will not be complete yet)
			 * @event
			 * @name close_node.jstree
			 * @param {Object} node the closed node
			 */
			this.trigger('close_node',{ "node" : obj });
			if(!d.length) {
				/**
				 * triggered when a node is closed and the animation is complete
				 * @event
				 * @name after_close.jstree
				 * @param {Object} node the closed node
				 */
				this.trigger("after_close", { "node" : obj });
			}
			else {
				if(!animation) {
					d[0].className = d[0].className.replace('jstree-open', 'jstree-closed');
					d.attr("aria-expanded", false).children('.jstree-children').remove();
					this.trigger("after_close", { "node" : obj });
				}
				else {
					d
						.children(".jstree-children").attr("style","display:block !important").end()
						.removeClass("jstree-open").addClass("jstree-closed").attr("aria-expanded", false)
						.children(".jstree-children").stop(true, true).slideUp(animation, function () {
							this.style.display = "";
							d.children('.jstree-children').remove();
							if (t.element) {
								t.trigger("after_close", { "node" : obj });
							}
						});
				}
			}
		},
		/**
		 * toggles a node - closing it if it is open, opening it if it is closed
		 * @name toggle_node(obj)
		 * @param {mixed} obj the node to toggle
		 */
		toggle_node : function (obj) {
			var t1, t2;
			if($.isArray(obj)) {
				obj = obj.slice();
				for(t1 = 0, t2 = obj.length; t1 < t2; t1++) {
					this.toggle_node(obj[t1]);
				}
				return true;
			}
			if(this.is_closed(obj)) {
				return this.open_node(obj);
			}
			if(this.is_open(obj)) {
				return this.close_node(obj);
			}
		},
		/**
		 * opens all nodes within a node (or the tree), revaling their children. If the node is not loaded it will be loaded and opened once ready.
		 * @name open_all([obj, animation, original_obj])
		 * @param {mixed} obj the node to open recursively, omit to open all nodes in the tree
		 * @param {Number} animation the animation duration in milliseconds when opening the nodes, the default is no animation
		 * @param {jQuery} reference to the node that started the process (internal use)
		 * @trigger open_all.jstree
		 */
		open_all : function (obj, animation, original_obj) {
			if(!obj) { obj = $.jstree.root; }
			obj = this.get_node(obj);
			if(!obj) { return false; }
			var dom = obj.id === $.jstree.root ? this.get_container_ul() : this.get_node(obj, true), i, j, _this;
			if(!dom.length) {
				for(i = 0, j = obj.children_d.length; i < j; i++) {
					if(this.is_closed(this._model.data[obj.children_d[i]])) {
						this._model.data[obj.children_d[i]].state.opened = true;
					}
				}
				return this.trigger('open_all', { "node" : obj });
			}
			original_obj = original_obj || dom;
			_this = this;
			dom = this.is_closed(obj) ? dom.find('.jstree-closed').addBack() : dom.find('.jstree-closed');
			dom.each(function () {
				_this.open_node(
					this,
					function(node, status) { if(status && this.is_parent(node)) { this.open_all(node, animation, original_obj); } },
					animation || 0
				);
			});
			if(original_obj.find('.jstree-closed').length === 0) {
				/**
				 * triggered when an `open_all` call completes
				 * @event
				 * @name open_all.jstree
				 * @param {Object} node the opened node
				 */
				this.trigger('open_all', { "node" : this.get_node(original_obj) });
			}
		},
		/**
		 * closes all nodes within a node (or the tree), revaling their children
		 * @name close_all([obj, animation])
		 * @param {mixed} obj the node to close recursively, omit to close all nodes in the tree
		 * @param {Number} animation the animation duration in milliseconds when closing the nodes, the default is no animation
		 * @trigger close_all.jstree
		 */
		close_all : function (obj, animation) {
			if(!obj) { obj = $.jstree.root; }
			obj = this.get_node(obj);
			if(!obj) { return false; }
			var dom = obj.id === $.jstree.root ? this.get_container_ul() : this.get_node(obj, true),
				_this = this, i, j;
			if(dom.length) {
				dom = this.is_open(obj) ? dom.find('.jstree-open').addBack() : dom.find('.jstree-open');
				$(dom.get().reverse()).each(function () { _this.close_node(this, animation || 0); });
			}
			for(i = 0, j = obj.children_d.length; i < j; i++) {
				this._model.data[obj.children_d[i]].state.opened = false;
			}
			/**
			 * triggered when an `close_all` call completes
			 * @event
			 * @name close_all.jstree
			 * @param {Object} node the closed node
			 */
			this.trigger('close_all', { "node" : obj });
		},
		/**
		 * checks if a node is disabled (not selectable)
		 * @name is_disabled(obj)
		 * @param  {mixed} obj
		 * @return {Boolean}
		 */
		is_disabled : function (obj) {
			obj = this.get_node(obj);
			return obj && obj.state && obj.state.disabled;
		},
		/**
		 * enables a node - so that it can be selected
		 * @name enable_node(obj)
		 * @param {mixed} obj the node to enable
		 * @trigger enable_node.jstree
		 */
		enable_node : function (obj) {
			var t1, t2;
			if($.isArray(obj)) {
				obj = obj.slice();
				for(t1 = 0, t2 = obj.length; t1 < t2; t1++) {
					this.enable_node(obj[t1]);
				}
				return true;
			}
			obj = this.get_node(obj);
			if(!obj || obj.id === $.jstree.root) {
				return false;
			}
			obj.state.disabled = false;
			this.get_node(obj,true).children('.jstree-anchor').removeClass('jstree-disabled').attr('aria-disabled', false);
			/**
			 * triggered when an node is enabled
			 * @event
			 * @name enable_node.jstree
			 * @param {Object} node the enabled node
			 */
			this.trigger('enable_node', { 'node' : obj });
		},
		/**
		 * disables a node - so that it can not be selected
		 * @name disable_node(obj)
		 * @param {mixed} obj the node to disable
		 * @trigger disable_node.jstree
		 */
		disable_node : function (obj) {
			var t1, t2;
			if($.isArray(obj)) {
				obj = obj.slice();
				for(t1 = 0, t2 = obj.length; t1 < t2; t1++) {
					this.disable_node(obj[t1]);
				}
				return true;
			}
			obj = this.get_node(obj);
			if(!obj || obj.id === $.jstree.root) {
				return false;
			}
			obj.state.disabled = true;
			this.get_node(obj,true).children('.jstree-anchor').addClass('jstree-disabled').attr('aria-disabled', true);
			/**
			 * triggered when an node is disabled
			 * @event
			 * @name disable_node.jstree
			 * @param {Object} node the disabled node
			 */
			this.trigger('disable_node', { 'node' : obj });
		},
		/**
		 * determines if a node is hidden
		 * @name is_hidden(obj)
		 * @param {mixed} obj the node
		 */
		is_hidden : function (obj) {
			obj = this.get_node(obj);
			return obj.state.hidden === true;
		},
		/**
		 * hides a node - it is still in the structure but will not be visible
		 * @name hide_node(obj)
		 * @param {mixed} obj the node to hide
		 * @param {Boolean} skip_redraw internal parameter controlling if redraw is called
		 * @trigger hide_node.jstree
		 */
		hide_node : function (obj, skip_redraw) {
			var t1, t2;
			if($.isArray(obj)) {
				obj = obj.slice();
				for(t1 = 0, t2 = obj.length; t1 < t2; t1++) {
					this.hide_node(obj[t1], true);
				}
				if (!skip_redraw) {
					this.redraw();
				}
				return true;
			}
			obj = this.get_node(obj);
			if(!obj || obj.id === $.jstree.root) {
				return false;
			}
			if(!obj.state.hidden) {
				obj.state.hidden = true;
				this._node_changed(obj.parent);
				if(!skip_redraw) {
					this.redraw();
				}
				/**
				 * triggered when an node is hidden
				 * @event
				 * @name hide_node.jstree
				 * @param {Object} node the hidden node
				 */
				this.trigger('hide_node', { 'node' : obj });
			}
		},
		/**
		 * shows a node
		 * @name show_node(obj)
		 * @param {mixed} obj the node to show
		 * @param {Boolean} skip_redraw internal parameter controlling if redraw is called
		 * @trigger show_node.jstree
		 */
		show_node : function (obj, skip_redraw) {
			var t1, t2;
			if($.isArray(obj)) {
				obj = obj.slice();
				for(t1 = 0, t2 = obj.length; t1 < t2; t1++) {
					this.show_node(obj[t1], true);
				}
				if (!skip_redraw) {
					this.redraw();
				}
				return true;
			}
			obj = this.get_node(obj);
			if(!obj || obj.id === $.jstree.root) {
				return false;
			}
			if(obj.state.hidden) {
				obj.state.hidden = false;
				this._node_changed(obj.parent);
				if(!skip_redraw) {
					this.redraw();
				}
				/**
				 * triggered when an node is shown
				 * @event
				 * @name show_node.jstree
				 * @param {Object} node the shown node
				 */
				this.trigger('show_node', { 'node' : obj });
			}
		},
		/**
		 * hides all nodes
		 * @name hide_all()
		 * @trigger hide_all.jstree
		 */
		hide_all : function (skip_redraw) {
			var i, m = this._model.data, ids = [];
			for(i in m) {
				if(m.hasOwnProperty(i) && i !== $.jstree.root && !m[i].state.hidden) {
					m[i].state.hidden = true;
					ids.push(i);
				}
			}
			this._model.force_full_redraw = true;
			if(!skip_redraw) {
				this.redraw();
			}
			/**
			 * triggered when all nodes are hidden
			 * @event
			 * @name hide_all.jstree
			 * @param {Array} nodes the IDs of all hidden nodes
			 */
			this.trigger('hide_all', { 'nodes' : ids });
			return ids;
		},
		/**
		 * shows all nodes
		 * @name show_all()
		 * @trigger show_all.jstree
		 */
		show_all : function (skip_redraw) {
			var i, m = this._model.data, ids = [];
			for(i in m) {
				if(m.hasOwnProperty(i) && i !== $.jstree.root && m[i].state.hidden) {
					m[i].state.hidden = false;
					ids.push(i);
				}
			}
			this._model.force_full_redraw = true;
			if(!skip_redraw) {
				this.redraw();
			}
			/**
			 * triggered when all nodes are shown
			 * @event
			 * @name show_all.jstree
			 * @param {Array} nodes the IDs of all shown nodes
			 */
			this.trigger('show_all', { 'nodes' : ids });
			return ids;
		},
		/**
		 * called when a node is selected by the user. Used internally.
		 * @private
		 * @name activate_node(obj, e)
		 * @param {mixed} obj the node
		 * @param {Object} e the related event
		 * @trigger activate_node.jstree, changed.jstree
		 */
		activate_node : function (obj, e) {
			if(this.is_disabled(obj)) {
				return false;
			}
			if(!e || typeof e !== 'object') {
				e = {};
			}

			// ensure last_clicked is still in the DOM, make it fresh (maybe it was moved?) and make sure it is still selected, if not - make last_clicked the last selected node
			this._data.core.last_clicked = this._data.core.last_clicked && this._data.core.last_clicked.id !== undefined ? this.get_node(this._data.core.last_clicked.id) : null;
			if(this._data.core.last_clicked && !this._data.core.last_clicked.state.selected) { this._data.core.last_clicked = null; }
			if(!this._data.core.last_clicked && this._data.core.selected.length) { this._data.core.last_clicked = this.get_node(this._data.core.selected[this._data.core.selected.length - 1]); }

			if(!this.settings.core.multiple || (!e.metaKey && !e.ctrlKey && !e.shiftKey) || (e.shiftKey && (!this._data.core.last_clicked || !this.get_parent(obj) || this.get_parent(obj) !== this._data.core.last_clicked.parent ) )) {
				if(!this.settings.core.multiple && (e.metaKey || e.ctrlKey || e.shiftKey) && this.is_selected(obj)) {
					this.deselect_node(obj, false, e);
				}
				else {
					this.deselect_all(true);
					this.select_node(obj, false, false, e);
					this._data.core.last_clicked = this.get_node(obj);
				}
			}
			else {
				if(e.shiftKey) {
					var o = this.get_node(obj).id,
						l = this._data.core.last_clicked.id,
						p = this.get_node(this._data.core.last_clicked.parent).children,
						c = false,
						i, j;
					for(i = 0, j = p.length; i < j; i += 1) {
						// separate IFs work whem o and l are the same
						if(p[i] === o) {
							c = !c;
						}
						if(p[i] === l) {
							c = !c;
						}
						if(!this.is_disabled(p[i]) && (c || p[i] === o || p[i] === l)) {
							if (!this.is_hidden(p[i])) {
								this.select_node(p[i], true, false, e);
							}
						}
						else {
							this.deselect_node(p[i], true, e);
						}
					}
					this.trigger('changed', { 'action' : 'select_node', 'node' : this.get_node(obj), 'selected' : this._data.core.selected, 'event' : e });
				}
				else {
					if(!this.is_selected(obj)) {
						this.select_node(obj, false, false, e);
					}
					else {
						this.deselect_node(obj, false, e);
					}
				}
			}
			/**
			 * triggered when an node is clicked or intercated with by the user
			 * @event
			 * @name activate_node.jstree
			 * @param {Object} node
			 * @param {Object} event the ooriginal event (if any) which triggered the call (may be an empty object)
			 */
			this.trigger('activate_node', { 'node' : this.get_node(obj), 'event' : e });
		},
		/**
		 * applies the hover state on a node, called when a node is hovered by the user. Used internally.
		 * @private
		 * @name hover_node(obj)
		 * @param {mixed} obj
		 * @trigger hover_node.jstree
		 */
		hover_node : function (obj) {
			obj = this.get_node(obj, true);
			if(!obj || !obj.length || obj.children('.jstree-hovered').length) {
				return false;
			}
			var o = this.element.find('.jstree-hovered'), t = this.element;
			if(o && o.length) { this.dehover_node(o); }

			obj.children('.jstree-anchor').addClass('jstree-hovered');
			/**
			 * triggered when an node is hovered
			 * @event
			 * @name hover_node.jstree
			 * @param {Object} node
			 */
			this.trigger('hover_node', { 'node' : this.get_node(obj) });
			setTimeout(function () { t.attr('aria-activedescendant', obj[0].id); }, 0);
		},
		/**
		 * removes the hover state from a nodecalled when a node is no longer hovered by the user. Used internally.
		 * @private
		 * @name dehover_node(obj)
		 * @param {mixed} obj
		 * @trigger dehover_node.jstree
		 */
		dehover_node : function (obj) {
			obj = this.get_node(obj, true);
			if(!obj || !obj.length || !obj.children('.jstree-hovered').length) {
				return false;
			}
			obj.children('.jstree-anchor').removeClass('jstree-hovered');
			/**
			 * triggered when an node is no longer hovered
			 * @event
			 * @name dehover_node.jstree
			 * @param {Object} node
			 */
			this.trigger('dehover_node', { 'node' : this.get_node(obj) });
		},
		/**
		 * select a node
		 * @name select_node(obj [, supress_event, prevent_open])
		 * @param {mixed} obj an array can be used to select multiple nodes
		 * @param {Boolean} supress_event if set to `true` the `changed.jstree` event won't be triggered
		 * @param {Boolean} prevent_open if set to `true` parents of the selected node won't be opened
		 * @trigger select_node.jstree, changed.jstree
		 */
		select_node : function (obj, supress_event, prevent_open, e) {
			var dom, t1, t2, th;
			if($.isArray(obj)) {
				obj = obj.slice();
				for(t1 = 0, t2 = obj.length; t1 < t2; t1++) {
					this.select_node(obj[t1], supress_event, prevent_open, e);
				}
				return true;
			}
			obj = this.get_node(obj);
			if(!obj || obj.id === $.jstree.root) {
				return false;
			}
			dom = this.get_node(obj, true);
			if(!obj.state.selected) {
				obj.state.selected = true;
				this._data.core.selected.push(obj.id);
				if(!prevent_open) {
					dom = this._open_to(obj);
				}
				if(dom && dom.length) {
					dom.attr('aria-selected', true).children('.jstree-anchor').addClass('jstree-clicked');
				}
				/**
				 * triggered when an node is selected
				 * @event
				 * @name select_node.jstree
				 * @param {Object} node
				 * @param {Array} selected the current selection
				 * @param {Object} event the event (if any) that triggered this select_node
				 */
				this.trigger('select_node', { 'node' : obj, 'selected' : this._data.core.selected, 'event' : e });
				if(!supress_event) {
					/**
					 * triggered when selection changes
					 * @event
					 * @name changed.jstree
					 * @param {Object} node
					 * @param {Object} action the action that caused the selection to change
					 * @param {Array} selected the current selection
					 * @param {Object} event the event (if any) that triggered this changed event
					 */
					this.trigger('changed', { 'action' : 'select_node', 'node' : obj, 'selected' : this._data.core.selected, 'event' : e });
				}
			}
		},
		/**
		 * deselect a node
		 * @name deselect_node(obj [, supress_event])
		 * @param {mixed} obj an array can be used to deselect multiple nodes
		 * @param {Boolean} supress_event if set to `true` the `changed.jstree` event won't be triggered
		 * @trigger deselect_node.jstree, changed.jstree
		 */
		deselect_node : function (obj, supress_event, e) {
			var t1, t2, dom;
			if($.isArray(obj)) {
				obj = obj.slice();
				for(t1 = 0, t2 = obj.length; t1 < t2; t1++) {
					this.deselect_node(obj[t1], supress_event, e);
				}
				return true;
			}
			obj = this.get_node(obj);
			if(!obj || obj.id === $.jstree.root) {
				return false;
			}
			dom = this.get_node(obj, true);
			if(obj.state.selected) {
				obj.state.selected = false;
				this._data.core.selected = $.vakata.array_remove_item(this._data.core.selected, obj.id);
				if(dom.length) {
					dom.attr('aria-selected', false).children('.jstree-anchor').removeClass('jstree-clicked');
				}
				/**
				 * triggered when an node is deselected
				 * @event
				 * @name deselect_node.jstree
				 * @param {Object} node
				 * @param {Array} selected the current selection
				 * @param {Object} event the event (if any) that triggered this deselect_node
				 */
				this.trigger('deselect_node', { 'node' : obj, 'selected' : this._data.core.selected, 'event' : e });
				if(!supress_event) {
					this.trigger('changed', { 'action' : 'deselect_node', 'node' : obj, 'selected' : this._data.core.selected, 'event' : e });
				}
			}
		},
		/**
		 * select all nodes in the tree
		 * @name select_all([supress_event])
		 * @param {Boolean} supress_event if set to `true` the `changed.jstree` event won't be triggered
		 * @trigger select_all.jstree, changed.jstree
		 */
		select_all : function (supress_event) {
			var tmp = this._data.core.selected.concat([]), i, j;
			this._data.core.selected = this._model.data[$.jstree.root].children_d.concat();
			for(i = 0, j = this._data.core.selected.length; i < j; i++) {
				if(this._model.data[this._data.core.selected[i]]) {
					this._model.data[this._data.core.selected[i]].state.selected = true;
				}
			}
			this.redraw(true);
			/**
			 * triggered when all nodes are selected
			 * @event
			 * @name select_all.jstree
			 * @param {Array} selected the current selection
			 */
			this.trigger('select_all', { 'selected' : this._data.core.selected });
			if(!supress_event) {
				this.trigger('changed', { 'action' : 'select_all', 'selected' : this._data.core.selected, 'old_selection' : tmp });
			}
		},
		/**
		 * deselect all selected nodes
		 * @name deselect_all([supress_event])
		 * @param {Boolean} supress_event if set to `true` the `changed.jstree` event won't be triggered
		 * @trigger deselect_all.jstree, changed.jstree
		 */
		deselect_all : function (supress_event) {
			var tmp = this._data.core.selected.concat([]), i, j;
			for(i = 0, j = this._data.core.selected.length; i < j; i++) {
				if(this._model.data[this._data.core.selected[i]]) {
					this._model.data[this._data.core.selected[i]].state.selected = false;
				}
			}
			this._data.core.selected = [];
			this.element.find('.jstree-clicked').removeClass('jstree-clicked').parent().attr('aria-selected', false);
			/**
			 * triggered when all nodes are deselected
			 * @event
			 * @name deselect_all.jstree
			 * @param {Object} node the previous selection
			 * @param {Array} selected the current selection
			 */
			this.trigger('deselect_all', { 'selected' : this._data.core.selected, 'node' : tmp });
			if(!supress_event) {
				this.trigger('changed', { 'action' : 'deselect_all', 'selected' : this._data.core.selected, 'old_selection' : tmp });
			}
		},
		/**
		 * checks if a node is selected
		 * @name is_selected(obj)
		 * @param  {mixed}  obj
		 * @return {Boolean}
		 */
		is_selected : function (obj) {
			obj = this.get_node(obj);
			if(!obj || obj.id === $.jstree.root) {
				return false;
			}
			return obj.state.selected;
		},
		/**
		 * get an array of all selected nodes
		 * @name get_selected([full])
		 * @param  {mixed}  full if set to `true` the returned array will consist of the full node objects, otherwise - only IDs will be returned
		 * @return {Array}
		 */
		get_selected : function (full) {
			return full ? $.map(this._data.core.selected, $.proxy(function (i) { return this.get_node(i); }, this)) : this._data.core.selected.slice();
		},
		/**
		 * get an array of all top level selected nodes (ignoring children of selected nodes)
		 * @name get_top_selected([full])
		 * @param  {mixed}  full if set to `true` the returned array will consist of the full node objects, otherwise - only IDs will be returned
		 * @return {Array}
		 */
		get_top_selected : function (full) {
			var tmp = this.get_selected(true),
				obj = {}, i, j, k, l;
			for(i = 0, j = tmp.length; i < j; i++) {
				obj[tmp[i].id] = tmp[i];
			}
			for(i = 0, j = tmp.length; i < j; i++) {
				for(k = 0, l = tmp[i].children_d.length; k < l; k++) {
					if(obj[tmp[i].children_d[k]]) {
						delete obj[tmp[i].children_d[k]];
					}
				}
			}
			tmp = [];
			for(i in obj) {
				if(obj.hasOwnProperty(i)) {
					tmp.push(i);
				}
			}
			return full ? $.map(tmp, $.proxy(function (i) { return this.get_node(i); }, this)) : tmp;
		},
		/**
		 * get an array of all bottom level selected nodes (ignoring selected parents)
		 * @name get_bottom_selected([full])
		 * @param  {mixed}  full if set to `true` the returned array will consist of the full node objects, otherwise - only IDs will be returned
		 * @return {Array}
		 */
		get_bottom_selected : function (full) {
			var tmp = this.get_selected(true),
				obj = [], i, j;
			for(i = 0, j = tmp.length; i < j; i++) {
				if(!tmp[i].children.length) {
					obj.push(tmp[i].id);
				}
			}
			return full ? $.map(obj, $.proxy(function (i) { return this.get_node(i); }, this)) : obj;
		},
		/**
		 * gets the current state of the tree so that it can be restored later with `set_state(state)`. Used internally.
		 * @name get_state()
		 * @private
		 * @return {Object}
		 */
		get_state : function () {
			var state	= {
				'core' : {
					'open' : [],
					'scroll' : {
						'left' : this.element.scrollLeft(),
						'top' : this.element.scrollTop()
					},
					/*!
					'themes' : {
						'name' : this.get_theme(),
						'icons' : this._data.core.themes.icons,
						'dots' : this._data.core.themes.dots
					},
					*/
					'selected' : []
				}
			}, i;
			for(i in this._model.data) {
				if(this._model.data.hasOwnProperty(i)) {
					if(i !== $.jstree.root) {
						if(this._model.data[i].state.opened) {
							state.core.open.push(i);
						}
						if(this._model.data[i].state.selected) {
							state.core.selected.push(i);
						}
					}
				}
			}
			return state;
		},
		/**
		 * sets the state of the tree. Used internally.
		 * @name set_state(state [, callback])
		 * @private
		 * @param {Object} state the state to restore. Keep in mind this object is passed by reference and jstree will modify it.
		 * @param {Function} callback an optional function to execute once the state is restored.
		 * @trigger set_state.jstree
		 */
		set_state : function (state, callback) {
			if(state) {
				if(state.core) {
					var res, n, t, _this, i;
					if(state.core.open) {
						if(!$.isArray(state.core.open) || !state.core.open.length) {
							delete state.core.open;
							this.set_state(state, callback);
						}
						else {
							this._load_nodes(state.core.open, function (nodes) {
								this.open_node(nodes, false, 0);
								delete state.core.open;
								this.set_state(state, callback);
							});
						}
						return false;
					}
					if(state.core.scroll) {
						if(state.core.scroll && state.core.scroll.left !== undefined) {
							this.element.scrollLeft(state.core.scroll.left);
						}
						if(state.core.scroll && state.core.scroll.top !== undefined) {
							this.element.scrollTop(state.core.scroll.top);
						}
						delete state.core.scroll;
						this.set_state(state, callback);
						return false;
					}
					if(state.core.selected) {
						_this = this;
						this.deselect_all();
						$.each(state.core.selected, function (i, v) {
							_this.select_node(v, false, true);
						});
						delete state.core.selected;
						this.set_state(state, callback);
						return false;
					}
					for(i in state) {
						if(state.hasOwnProperty(i) && i !== "core" && $.inArray(i, this.settings.plugins) === -1) {
							delete state[i];
						}
					}
					if($.isEmptyObject(state.core)) {
						delete state.core;
						this.set_state(state, callback);
						return false;
					}
				}
				if($.isEmptyObject(state)) {
					state = null;
					if(callback) { callback.call(this); }
					/**
					 * triggered when a `set_state` call completes
					 * @event
					 * @name set_state.jstree
					 */
					this.trigger('set_state');
					return false;
				}
				return true;
			}
			return false;
		},
		/**
		 * refreshes the tree - all nodes are reloaded with calls to `load_node`.
		 * @name refresh()
		 * @param {Boolean} skip_loading an option to skip showing the loading indicator
		 * @param {Mixed} forget_state if set to `true` state will not be reapplied, if set to a function (receiving the current state as argument) the result of that function will be used as state
		 * @trigger refresh.jstree
		 */
		refresh : function (skip_loading, forget_state) {
			this._data.core.state = forget_state === true ? {} : this.get_state();
			if(forget_state && $.isFunction(forget_state)) { this._data.core.state = forget_state.call(this, this._data.core.state); }
			this._cnt = 0;
			this._model.data = {};
			this._model.data[$.jstree.root] = {
				id : $.jstree.root,
				parent : null,
				parents : [],
				children : [],
				children_d : [],
				state : { loaded : false }
			};
			this._data.core.selected = [];
			this._data.core.last_clicked = null;
			this._data.core.focused = null;

			var c = this.get_container_ul()[0].className;
			if(!skip_loading) {
				this.element.html("<"+"ul class='"+c+"' role='group'><"+"li class='jstree-initial-node jstree-loading jstree-leaf jstree-last' role='treeitem' id='j"+this._id+"_loading'><i class='jstree-icon jstree-ocl'></i><"+"a class='jstree-anchor' href='#'><i class='jstree-icon jstree-themeicon-hidden'></i>" + this.get_string("Loading ...") + "</a></li></ul>");
				this.element.attr('aria-activedescendant','j'+this._id+'_loading');
			}
			this.load_node($.jstree.root, function (o, s) {
				if(s) {
					this.get_container_ul()[0].className = c;
					if(this._firstChild(this.get_container_ul()[0])) {
						this.element.attr('aria-activedescendant',this._firstChild(this.get_container_ul()[0]).id);
					}
					this.set_state($.extend(true, {}, this._data.core.state), function () {
						/**
						 * triggered when a `refresh` call completes
						 * @event
						 * @name refresh.jstree
						 */
						this.trigger('refresh');
					});
				}
				this._data.core.state = null;
			});
		},
		/**
		 * refreshes a node in the tree (reload its children) all opened nodes inside that node are reloaded with calls to `load_node`.
		 * @name refresh_node(obj)
		 * @param  {mixed} obj the node
		 * @trigger refresh_node.jstree
		 */
		refresh_node : function (obj) {
			obj = this.get_node(obj);
			if(!obj || obj.id === $.jstree.root) { return false; }
			var opened = [], to_load = [], s = this._data.core.selected.concat([]);
			to_load.push(obj.id);
			if(obj.state.opened === true) { opened.push(obj.id); }
			this.get_node(obj, true).find('.jstree-open').each(function() { to_load.push(this.id); opened.push(this.id); });
			this._load_nodes(to_load, $.proxy(function (nodes) {
				this.open_node(opened, false, 0);
				this.select_node(s);
				/**
				 * triggered when a node is refreshed
				 * @event
				 * @name refresh_node.jstree
				 * @param {Object} node - the refreshed node
				 * @param {Array} nodes - an array of the IDs of the nodes that were reloaded
				 */
				this.trigger('refresh_node', { 'node' : obj, 'nodes' : nodes });
			}, this), false, true);
		},
		/**
		 * set (change) the ID of a node
		 * @name set_id(obj, id)
		 * @param  {mixed} obj the node
		 * @param  {String} id the new ID
		 * @return {Boolean}
		 * @trigger set_id.jstree
		 */
		set_id : function (obj, id) {
			obj = this.get_node(obj);
			if(!obj || obj.id === $.jstree.root) { return false; }
			var i, j, m = this._model.data, old = obj.id;
			id = id.toString();
			// update parents (replace current ID with new one in children and children_d)
			m[obj.parent].children[$.inArray(obj.id, m[obj.parent].children)] = id;
			for(i = 0, j = obj.parents.length; i < j; i++) {
				m[obj.parents[i]].children_d[$.inArray(obj.id, m[obj.parents[i]].children_d)] = id;
			}
			// update children (replace current ID with new one in parent and parents)
			for(i = 0, j = obj.children.length; i < j; i++) {
				m[obj.children[i]].parent = id;
			}
			for(i = 0, j = obj.children_d.length; i < j; i++) {
				m[obj.children_d[i]].parents[$.inArray(obj.id, m[obj.children_d[i]].parents)] = id;
			}
			i = $.inArray(obj.id, this._data.core.selected);
			if(i !== -1) { this._data.core.selected[i] = id; }
			// update model and obj itself (obj.id, this._model.data[KEY])
			i = this.get_node(obj.id, true);
			if(i) {
				i.attr('id', id); //.children('.jstree-anchor').attr('id', id + '_anchor').end().attr('aria-labelledby', id + '_anchor');
				if(this.element.attr('aria-activedescendant') === obj.id) {
					this.element.attr('aria-activedescendant', id);
				}
			}
			delete m[obj.id];
			obj.id = id;
			obj.li_attr.id = id;
			m[id] = obj;
			/**
			 * triggered when a node id value is changed
			 * @event
			 * @name set_id.jstree
			 * @param {Object} node
			 * @param {String} old the old id
			 */
			this.trigger('set_id',{ "node" : obj, "new" : obj.id, "old" : old });
			return true;
		},
		/**
		 * get the text value of a node
		 * @name get_text(obj)
		 * @param  {mixed} obj the node
		 * @return {String}
		 */
		get_text : function (obj) {
			obj = this.get_node(obj);
			return (!obj || obj.id === $.jstree.root) ? false : obj.text;
		},
		/**
		 * set the text value of a node. Used internally, please use `rename_node(obj, val)`.
		 * @private
		 * @name set_text(obj, val)
		 * @param  {mixed} obj the node, you can pass an array to set the text on multiple nodes
		 * @param  {String} val the new text value
		 * @return {Boolean}
		 * @trigger set_text.jstree
		 */
		set_text : function (obj, val) {
			var t1, t2;
			if($.isArray(obj)) {
				obj = obj.slice();
				for(t1 = 0, t2 = obj.length; t1 < t2; t1++) {
					this.set_text(obj[t1], val);
				}
				return true;
			}
			obj = this.get_node(obj);
			if(!obj || obj.id === $.jstree.root) { return false; }
			obj.text = val;
			if(this.get_node(obj, true).length) {
				this.redraw_node(obj.id);
			}
			/**
			 * triggered when a node text value is changed
			 * @event
			 * @name set_text.jstree
			 * @param {Object} obj
			 * @param {String} text the new value
			 */
			this.trigger('set_text',{ "obj" : obj, "text" : val });
			return true;
		},
		/**
		 * gets a JSON representation of a node (or the whole tree)
		 * @name get_json([obj, options])
		 * @param  {mixed} obj
		 * @param  {Object} options
		 * @param  {Boolean} options.no_state do not return state information
		 * @param  {Boolean} options.no_id do not return ID
		 * @param  {Boolean} options.no_children do not include children
		 * @param  {Boolean} options.no_data do not include node data
		 * @param  {Boolean} options.no_li_attr do not include LI attributes
		 * @param  {Boolean} options.no_a_attr do not include A attributes
		 * @param  {Boolean} options.flat return flat JSON instead of nested
		 * @return {Object}
		 */
		get_json : function (obj, options, flat) {
			obj = this.get_node(obj || $.jstree.root);
			if(!obj) { return false; }
			if(options && options.flat && !flat) { flat = []; }
			var tmp = {
				'id' : obj.id,
				'text' : obj.text,
				'icon' : this.get_icon(obj),
				'li_attr' : $.extend(true, {}, obj.li_attr),
				'a_attr' : $.extend(true, {}, obj.a_attr),
				'state' : {},
				'data' : options && options.no_data ? false : $.extend(true, {}, obj.data)
				//( this.get_node(obj, true).length ? this.get_node(obj, true).data() : obj.data ),
			}, i, j;
			if(options && options.flat) {
				tmp.parent = obj.parent;
			}
			else {
				tmp.children = [];
			}
			if(!options || !options.no_state) {
				for(i in obj.state) {
					if(obj.state.hasOwnProperty(i)) {
						tmp.state[i] = obj.state[i];
					}
				}
			} else {
				delete tmp.state;
			}
			if(options && options.no_li_attr) {
				delete tmp.li_attr;
			}
			if(options && options.no_a_attr) {
				delete tmp.a_attr;
			}
			if(options && options.no_id) {
				delete tmp.id;
				if(tmp.li_attr && tmp.li_attr.id) {
					delete tmp.li_attr.id;
				}
				if(tmp.a_attr && tmp.a_attr.id) {
					delete tmp.a_attr.id;
				}
			}
			if(options && options.flat && obj.id !== $.jstree.root) {
				flat.push(tmp);
			}
			if(!options || !options.no_children) {
				for(i = 0, j = obj.children.length; i < j; i++) {
					if(options && options.flat) {
						this.get_json(obj.children[i], options, flat);
					}
					else {
						tmp.children.push(this.get_json(obj.children[i], options));
					}
				}
			}
			return options && options.flat ? flat : (obj.id === $.jstree.root ? tmp.children : tmp);
		},
		/**
		 * create a new node (do not confuse with load_node)
		 * @name create_node([par, node, pos, callback, is_loaded])
		 * @param  {mixed}   par       the parent node (to create a root node use either "#" (string) or `null`)
		 * @param  {mixed}   node      the data for the new node (a valid JSON object, or a simple string with the name)
		 * @param  {mixed}   pos       the index at which to insert the node, "first" and "last" are also supported, default is "last"
		 * @param  {Function} callback a function to be called once the node is created
		 * @param  {Boolean} is_loaded internal argument indicating if the parent node was succesfully loaded
		 * @return {String}            the ID of the newly create node
		 * @trigger model.jstree, create_node.jstree
		 */
		create_node : function (par, node, pos, callback, is_loaded) {
			if(par === null) { par = $.jstree.root; }
			par = this.get_node(par);
			if(!par) { return false; }
			pos = pos === undefined ? "last" : pos;
			if(!pos.toString().match(/^(before|after)$/) && !is_loaded && !this.is_loaded(par)) {
				return this.load_node(par, function () { this.create_node(par, node, pos, callback, true); });
			}
			if(!node) { node = { "text" : this.get_string('New node') }; }
			if(typeof node === "string") { node = { "text" : node }; }
			if(node.text === undefined) { node.text = this.get_string('New node'); }
			var tmp, dpc, i, j;

			if(par.id === $.jstree.root) {
				if(pos === "before") { pos = "first"; }
				if(pos === "after") { pos = "last"; }
			}
			switch(pos) {
				case "before":
					tmp = this.get_node(par.parent);
					pos = $.inArray(par.id, tmp.children);
					par = tmp;
					break;
				case "after" :
					tmp = this.get_node(par.parent);
					pos = $.inArray(par.id, tmp.children) + 1;
					par = tmp;
					break;
				case "inside":
				case "first":
					pos = 0;
					break;
				case "last":
					pos = par.children.length;
					break;
				default:
					if(!pos) { pos = 0; }
					break;
			}
			if(pos > par.children.length) { pos = par.children.length; }
			if(!node.id) { node.id = true; }
			if(!this.check("create_node", node, par, pos)) {
				this.settings.core.error.call(this, this._data.core.last_error);
				return false;
			}
			if(node.id === true) { delete node.id; }
			node = this._parse_model_from_json(node, par.id, par.parents.concat());
			if(!node) { return false; }
			tmp = this.get_node(node);
			dpc = [];
			dpc.push(node);
			dpc = dpc.concat(tmp.children_d);
			this.trigger('model', { "nodes" : dpc, "parent" : par.id });

			par.children_d = par.children_d.concat(dpc);
			for(i = 0, j = par.parents.length; i < j; i++) {
				this._model.data[par.parents[i]].children_d = this._model.data[par.parents[i]].children_d.concat(dpc);
			}
			node = tmp;
			tmp = [];
			for(i = 0, j = par.children.length; i < j; i++) {
				tmp[i >= pos ? i+1 : i] = par.children[i];
			}
			tmp[pos] = node.id;
			par.children = tmp;

			this.redraw_node(par, true);
			if(callback) { callback.call(this, this.get_node(node)); }
			/**
			 * triggered when a node is created
			 * @event
			 * @name create_node.jstree
			 * @param {Object} node
			 * @param {String} parent the parent's ID
			 * @param {Number} position the position of the new node among the parent's children
			 */
			this.trigger('create_node', { "node" : this.get_node(node), "parent" : par.id, "position" : pos });
			return node.id;
		},
		/**
		 * set the text value of a node
		 * @name rename_node(obj, val)
		 * @param  {mixed} obj the node, you can pass an array to rename multiple nodes to the same name
		 * @param  {String} val the new text value
		 * @return {Boolean}
		 * @trigger rename_node.jstree
		 */
		rename_node : function (obj, val) {
			var t1, t2, old;
			if($.isArray(obj)) {
				obj = obj.slice();
				for(t1 = 0, t2 = obj.length; t1 < t2; t1++) {
					this.rename_node(obj[t1], val);
				}
				return true;
			}
			obj = this.get_node(obj);
			if(!obj || obj.id === $.jstree.root) { return false; }
			old = obj.text;
			if(!this.check("rename_node", obj, this.get_parent(obj), val)) {
				this.settings.core.error.call(this, this._data.core.last_error);
				return false;
			}
			this.set_text(obj, val); // .apply(this, Array.prototype.slice.call(arguments))
			/**
			 * triggered when a node is renamed
			 * @event
			 * @name rename_node.jstree
			 * @param {Object} node
			 * @param {String} text the new value
			 * @param {String} old the old value
			 */
			this.trigger('rename_node', { "node" : obj, "text" : val, "old" : old });
			return true;
		},
		/**
		 * remove a node
		 * @name delete_node(obj)
		 * @param  {mixed} obj the node, you can pass an array to delete multiple nodes
		 * @return {Boolean}
		 * @trigger delete_node.jstree, changed.jstree
		 */
		delete_node : function (obj) {
			var t1, t2, par, pos, tmp, i, j, k, l, c, top, lft;
			if($.isArray(obj)) {
				obj = obj.slice();
				for(t1 = 0, t2 = obj.length; t1 < t2; t1++) {
					this.delete_node(obj[t1]);
				}
				return true;
			}
			obj = this.get_node(obj);
			if(!obj || obj.id === $.jstree.root) { return false; }
			par = this.get_node(obj.parent);
			pos = $.inArray(obj.id, par.children);
			c = false;
			if(!this.check("delete_node", obj, par, pos)) {
				this.settings.core.error.call(this, this._data.core.last_error);
				return false;
			}
			if(pos !== -1) {
				par.children = $.vakata.array_remove(par.children, pos);
			}
			tmp = obj.children_d.concat([]);
			tmp.push(obj.id);
			for(i = 0, j = obj.parents.length; i < j; i++) {
				this._model.data[obj.parents[i]].children_d = $.vakata.array_filter(this._model.data[obj.parents[i]].children_d, function (v) {
					return $.inArray(v, tmp) === -1;
				});
			}
			for(k = 0, l = tmp.length; k < l; k++) {
				if(this._model.data[tmp[k]].state.selected) {
					c = true;
					break;
				}
			}
			if (c) {
				this._data.core.selected = $.vakata.array_filter(this._data.core.selected, function (v) {
					return $.inArray(v, tmp) === -1;
				});
			}
			/**
			 * triggered when a node is deleted
			 * @event
			 * @name delete_node.jstree
			 * @param {Object} node
			 * @param {String} parent the parent's ID
			 */
			this.trigger('delete_node', { "node" : obj, "parent" : par.id });
			if(c) {
				this.trigger('changed', { 'action' : 'delete_node', 'node' : obj, 'selected' : this._data.core.selected, 'parent' : par.id });
			}
			for(k = 0, l = tmp.length; k < l; k++) {
				delete this._model.data[tmp[k]];
			}
			if($.inArray(this._data.core.focused, tmp) !== -1) {
				this._data.core.focused = null;
				top = this.element[0].scrollTop;
				lft = this.element[0].scrollLeft;
				if(par.id === $.jstree.root) {
					if (this._model.data[$.jstree.root].children[0]) {
						this.get_node(this._model.data[$.jstree.root].children[0], true).children('.jstree-anchor').focus();
					}
				}
				else {
					this.get_node(par, true).children('.jstree-anchor').focus();
				}
				this.element[0].scrollTop  = top;
				this.element[0].scrollLeft = lft;
			}
			this.redraw_node(par, true);
			return true;
		},
		/**
		 * check if an operation is premitted on the tree. Used internally.
		 * @private
		 * @name check(chk, obj, par, pos)
		 * @param  {String} chk the operation to check, can be "create_node", "rename_node", "delete_node", "copy_node" or "move_node"
		 * @param  {mixed} obj the node
		 * @param  {mixed} par the parent
		 * @param  {mixed} pos the position to insert at, or if "rename_node" - the new name
		 * @param  {mixed} more some various additional information, for example if a "move_node" operations is triggered by DND this will be the hovered node
		 * @return {Boolean}
		 */
		check : function (chk, obj, par, pos, more) {
			obj = obj && obj.id ? obj : this.get_node(obj);
			par = par && par.id ? par : this.get_node(par);
			var tmp = chk.match(/^move_node|copy_node|create_node$/i) ? par : obj,
				chc = this.settings.core.check_callback;
			if(chk === "move_node" || chk === "copy_node") {
				if((!more || !more.is_multi) && (obj.id === par.id || (chk === "move_node" && $.inArray(obj.id, par.children) === pos) || $.inArray(par.id, obj.children_d) !== -1)) {
					this._data.core.last_error = { 'error' : 'check', 'plugin' : 'core', 'id' : 'core_01', 'reason' : 'Moving parent inside child', 'data' : JSON.stringify({ 'chk' : chk, 'pos' : pos, 'obj' : obj && obj.id ? obj.id : false, 'par' : par && par.id ? par.id : false }) };
					return false;
				}
			}
			if(tmp && tmp.data) { tmp = tmp.data; }
			if(tmp && tmp.functions && (tmp.functions[chk] === false || tmp.functions[chk] === true)) {
				if(tmp.functions[chk] === false) {
					this._data.core.last_error = { 'error' : 'check', 'plugin' : 'core', 'id' : 'core_02', 'reason' : 'Node data prevents function: ' + chk, 'data' : JSON.stringify({ 'chk' : chk, 'pos' : pos, 'obj' : obj && obj.id ? obj.id : false, 'par' : par && par.id ? par.id : false }) };
				}
				return tmp.functions[chk];
			}
			if(chc === false || ($.isFunction(chc) && chc.call(this, chk, obj, par, pos, more) === false) || (chc && chc[chk] === false)) {
				this._data.core.last_error = { 'error' : 'check', 'plugin' : 'core', 'id' : 'core_03', 'reason' : 'User config for core.check_callback prevents function: ' + chk, 'data' : JSON.stringify({ 'chk' : chk, 'pos' : pos, 'obj' : obj && obj.id ? obj.id : false, 'par' : par && par.id ? par.id : false }) };
				return false;
			}
			return true;
		},
		/**
		 * get the last error
		 * @name last_error()
		 * @return {Object}
		 */
		last_error : function () {
			return this._data.core.last_error;
		},
		/**
		 * move a node to a new parent
		 * @name move_node(obj, par [, pos, callback, is_loaded])
		 * @param  {mixed} obj the node to move, pass an array to move multiple nodes
		 * @param  {mixed} par the new parent
		 * @param  {mixed} pos the position to insert at (besides integer values, "first" and "last" are supported, as well as "before" and "after"), defaults to integer `0`
		 * @param  {function} callback a function to call once the move is completed, receives 3 arguments - the node, the new parent and the position
		 * @param  {Boolean} is_loaded internal parameter indicating if the parent node has been loaded
		 * @param  {Boolean} skip_redraw internal parameter indicating if the tree should be redrawn
		 * @param  {Boolean} instance internal parameter indicating if the node comes from another instance
		 * @trigger move_node.jstree
		 */
		move_node : function (obj, par, pos, callback, is_loaded, skip_redraw, origin) {
			var t1, t2, old_par, old_pos, new_par, old_ins, is_multi, dpc, tmp, i, j, k, l, p;

			par = this.get_node(par);
			pos = pos === undefined ? 0 : pos;
			if(!par) { return false; }
			if(!pos.toString().match(/^(before|after)$/) && !is_loaded && !this.is_loaded(par)) {
				return this.load_node(par, function () { this.move_node(obj, par, pos, callback, true, false, origin); });
			}

			if($.isArray(obj)) {
				if(obj.length === 1) {
					obj = obj[0];
				}
				else {
					//obj = obj.slice();
					for(t1 = 0, t2 = obj.length; t1 < t2; t1++) {
						if((tmp = this.move_node(obj[t1], par, pos, callback, is_loaded, false, origin))) {
							par = tmp;
							pos = "after";
						}
					}
					this.redraw();
					return true;
				}
			}
			obj = obj && obj.id ? obj : this.get_node(obj);

			if(!obj || obj.id === $.jstree.root) { return false; }

			old_par = (obj.parent || $.jstree.root).toString();
			new_par = (!pos.toString().match(/^(before|after)$/) || par.id === $.jstree.root) ? par : this.get_node(par.parent);
			old_ins = origin ? origin : (this._model.data[obj.id] ? this : $.jstree.reference(obj.id));
			is_multi = !old_ins || !old_ins._id || (this._id !== old_ins._id);
			old_pos = old_ins && old_ins._id && old_par && old_ins._model.data[old_par] && old_ins._model.data[old_par].children ? $.inArray(obj.id, old_ins._model.data[old_par].children) : -1;
			if(old_ins && old_ins._id) {
				obj = old_ins._model.data[obj.id];
			}

			if(is_multi) {
				if((tmp = this.copy_node(obj, par, pos, callback, is_loaded, false, origin))) {
					if(old_ins) { old_ins.delete_node(obj); }
					return tmp;
				}
				return false;
			}
			//var m = this._model.data;
			if(par.id === $.jstree.root) {
				if(pos === "before") { pos = "first"; }
				if(pos === "after") { pos = "last"; }
			}
			switch(pos) {
				case "before":
					pos = $.inArray(par.id, new_par.children);
					break;
				case "after" :
					pos = $.inArray(par.id, new_par.children) + 1;
					break;
				case "inside":
				case "first":
					pos = 0;
					break;
				case "last":
					pos = new_par.children.length;
					break;
				default:
					if(!pos) { pos = 0; }
					break;
			}
			if(pos > new_par.children.length) { pos = new_par.children.length; }
			if(!this.check("move_node", obj, new_par, pos, { 'core' : true, 'origin' : origin, 'is_multi' : (old_ins && old_ins._id && old_ins._id !== this._id), 'is_foreign' : (!old_ins || !old_ins._id) })) {
				this.settings.core.error.call(this, this._data.core.last_error);
				return false;
			}
			if(obj.parent === new_par.id) {
				dpc = new_par.children.concat();
				tmp = $.inArray(obj.id, dpc);
				if(tmp !== -1) {
					dpc = $.vakata.array_remove(dpc, tmp);
					if(pos > tmp) { pos--; }
				}
				tmp = [];
				for(i = 0, j = dpc.length; i < j; i++) {
					tmp[i >= pos ? i+1 : i] = dpc[i];
				}
				tmp[pos] = obj.id;
				new_par.children = tmp;
				this._node_changed(new_par.id);
				this.redraw(new_par.id === $.jstree.root);
			}
			else {
				// clean old parent and up
				tmp = obj.children_d.concat();
				tmp.push(obj.id);
				for(i = 0, j = obj.parents.length; i < j; i++) {
					dpc = [];
					p = old_ins._model.data[obj.parents[i]].children_d;
					for(k = 0, l = p.length; k < l; k++) {
						if($.inArray(p[k], tmp) === -1) {
							dpc.push(p[k]);
						}
					}
					old_ins._model.data[obj.parents[i]].children_d = dpc;
				}
				old_ins._model.data[old_par].children = $.vakata.array_remove_item(old_ins._model.data[old_par].children, obj.id);

				// insert into new parent and up
				for(i = 0, j = new_par.parents.length; i < j; i++) {
					this._model.data[new_par.parents[i]].children_d = this._model.data[new_par.parents[i]].children_d.concat(tmp);
				}
				dpc = [];
				for(i = 0, j = new_par.children.length; i < j; i++) {
					dpc[i >= pos ? i+1 : i] = new_par.children[i];
				}
				dpc[pos] = obj.id;
				new_par.children = dpc;
				new_par.children_d.push(obj.id);
				new_par.children_d = new_par.children_d.concat(obj.children_d);

				// update object
				obj.parent = new_par.id;
				tmp = new_par.parents.concat();
				tmp.unshift(new_par.id);
				p = obj.parents.length;
				obj.parents = tmp;

				// update object children
				tmp = tmp.concat();
				for(i = 0, j = obj.children_d.length; i < j; i++) {
					this._model.data[obj.children_d[i]].parents = this._model.data[obj.children_d[i]].parents.slice(0,p*-1);
					Array.prototype.push.apply(this._model.data[obj.children_d[i]].parents, tmp);
				}

				if(old_par === $.jstree.root || new_par.id === $.jstree.root) {
					this._model.force_full_redraw = true;
				}
				if(!this._model.force_full_redraw) {
					this._node_changed(old_par);
					this._node_changed(new_par.id);
				}
				if(!skip_redraw) {
					this.redraw();
				}
			}
			if(callback) { callback.call(this, obj, new_par, pos); }
			/**
			 * triggered when a node is moved
			 * @event
			 * @name move_node.jstree
			 * @param {Object} node
			 * @param {String} parent the parent's ID
			 * @param {Number} position the position of the node among the parent's children
			 * @param {String} old_parent the old parent of the node
			 * @param {Number} old_position the old position of the node
			 * @param {Boolean} is_multi do the node and new parent belong to different instances
			 * @param {jsTree} old_instance the instance the node came from
			 * @param {jsTree} new_instance the instance of the new parent
			 */
			this.trigger('move_node', { "node" : obj, "parent" : new_par.id, "position" : pos, "old_parent" : old_par, "old_position" : old_pos, 'is_multi' : (old_ins && old_ins._id && old_ins._id !== this._id), 'is_foreign' : (!old_ins || !old_ins._id), 'old_instance' : old_ins, 'new_instance' : this });
			return obj.id;
		},
		/**
		 * copy a node to a new parent
		 * @name copy_node(obj, par [, pos, callback, is_loaded])
		 * @param  {mixed} obj the node to copy, pass an array to copy multiple nodes
		 * @param  {mixed} par the new parent
		 * @param  {mixed} pos the position to insert at (besides integer values, "first" and "last" are supported, as well as "before" and "after"), defaults to integer `0`
		 * @param  {function} callback a function to call once the move is completed, receives 3 arguments - the node, the new parent and the position
		 * @param  {Boolean} is_loaded internal parameter indicating if the parent node has been loaded
		 * @param  {Boolean} skip_redraw internal parameter indicating if the tree should be redrawn
		 * @param  {Boolean} instance internal parameter indicating if the node comes from another instance
		 * @trigger model.jstree copy_node.jstree
		 */
		copy_node : function (obj, par, pos, callback, is_loaded, skip_redraw, origin) {
			var t1, t2, dpc, tmp, i, j, node, old_par, new_par, old_ins, is_multi;

			par = this.get_node(par);
			pos = pos === undefined ? 0 : pos;
			if(!par) { return false; }
			if(!pos.toString().match(/^(before|after)$/) && !is_loaded && !this.is_loaded(par)) {
				return this.load_node(par, function () { this.copy_node(obj, par, pos, callback, true, false, origin); });
			}

			if($.isArray(obj)) {
				if(obj.length === 1) {
					obj = obj[0];
				}
				else {
					//obj = obj.slice();
					for(t1 = 0, t2 = obj.length; t1 < t2; t1++) {
						if((tmp = this.copy_node(obj[t1], par, pos, callback, is_loaded, true, origin))) {
							par = tmp;
							pos = "after";
						}
					}
					this.redraw();
					return true;
				}
			}
			obj = obj && obj.id ? obj : this.get_node(obj);
			if(!obj || obj.id === $.jstree.root) { return false; }

			old_par = (obj.parent || $.jstree.root).toString();
			new_par = (!pos.toString().match(/^(before|after)$/) || par.id === $.jstree.root) ? par : this.get_node(par.parent);
			old_ins = origin ? origin : (this._model.data[obj.id] ? this : $.jstree.reference(obj.id));
			is_multi = !old_ins || !old_ins._id || (this._id !== old_ins._id);

			if(old_ins && old_ins._id) {
				obj = old_ins._model.data[obj.id];
			}

			if(par.id === $.jstree.root) {
				if(pos === "before") { pos = "first"; }
				if(pos === "after") { pos = "last"; }
			}
			switch(pos) {
				case "before":
					pos = $.inArray(par.id, new_par.children);
					break;
				case "after" :
					pos = $.inArray(par.id, new_par.children) + 1;
					break;
				case "inside":
				case "first":
					pos = 0;
					break;
				case "last":
					pos = new_par.children.length;
					break;
				default:
					if(!pos) { pos = 0; }
					break;
			}
			if(pos > new_par.children.length) { pos = new_par.children.length; }
			if(!this.check("copy_node", obj, new_par, pos, { 'core' : true, 'origin' : origin, 'is_multi' : (old_ins && old_ins._id && old_ins._id !== this._id), 'is_foreign' : (!old_ins || !old_ins._id) })) {
				this.settings.core.error.call(this, this._data.core.last_error);
				return false;
			}
			node = old_ins ? old_ins.get_json(obj, { no_id : true, no_data : true, no_state : true }) : obj;
			if(!node) { return false; }
			if(node.id === true) { delete node.id; }
			node = this._parse_model_from_json(node, new_par.id, new_par.parents.concat());
			if(!node) { return false; }
			tmp = this.get_node(node);
			if(obj && obj.state && obj.state.loaded === false) { tmp.state.loaded = false; }
			dpc = [];
			dpc.push(node);
			dpc = dpc.concat(tmp.children_d);
			this.trigger('model', { "nodes" : dpc, "parent" : new_par.id });

			// insert into new parent and up
			for(i = 0, j = new_par.parents.length; i < j; i++) {
				this._model.data[new_par.parents[i]].children_d = this._model.data[new_par.parents[i]].children_d.concat(dpc);
			}
			dpc = [];
			for(i = 0, j = new_par.children.length; i < j; i++) {
				dpc[i >= pos ? i+1 : i] = new_par.children[i];
			}
			dpc[pos] = tmp.id;
			new_par.children = dpc;
			new_par.children_d.push(tmp.id);
			new_par.children_d = new_par.children_d.concat(tmp.children_d);

			if(new_par.id === $.jstree.root) {
				this._model.force_full_redraw = true;
			}
			if(!this._model.force_full_redraw) {
				this._node_changed(new_par.id);
			}
			if(!skip_redraw) {
				this.redraw(new_par.id === $.jstree.root);
			}
			if(callback) { callback.call(this, tmp, new_par, pos); }
			/**
			 * triggered when a node is copied
			 * @event
			 * @name copy_node.jstree
			 * @param {Object} node the copied node
			 * @param {Object} original the original node
			 * @param {String} parent the parent's ID
			 * @param {Number} position the position of the node among the parent's children
			 * @param {String} old_parent the old parent of the node
			 * @param {Number} old_position the position of the original node
			 * @param {Boolean} is_multi do the node and new parent belong to different instances
			 * @param {jsTree} old_instance the instance the node came from
			 * @param {jsTree} new_instance the instance of the new parent
			 */
			this.trigger('copy_node', { "node" : tmp, "original" : obj, "parent" : new_par.id, "position" : pos, "old_parent" : old_par, "old_position" : old_ins && old_ins._id && old_par && old_ins._model.data[old_par] && old_ins._model.data[old_par].children ? $.inArray(obj.id, old_ins._model.data[old_par].children) : -1,'is_multi' : (old_ins && old_ins._id && old_ins._id !== this._id), 'is_foreign' : (!old_ins || !old_ins._id), 'old_instance' : old_ins, 'new_instance' : this });
			return tmp.id;
		},
		/**
		 * cut a node (a later call to `paste(obj)` would move the node)
		 * @name cut(obj)
		 * @param  {mixed} obj multiple objects can be passed using an array
		 * @trigger cut.jstree
		 */
		cut : function (obj) {
			if(!obj) { obj = this._data.core.selected.concat(); }
			if(!$.isArray(obj)) { obj = [obj]; }
			if(!obj.length) { return false; }
			var tmp = [], o, t1, t2;
			for(t1 = 0, t2 = obj.length; t1 < t2; t1++) {
				o = this.get_node(obj[t1]);
				if(o && o.id && o.id !== $.jstree.root) { tmp.push(o); }
			}
			if(!tmp.length) { return false; }
			ccp_node = tmp;
			ccp_inst = this;
			ccp_mode = 'move_node';
			/**
			 * triggered when nodes are added to the buffer for moving
			 * @event
			 * @name cut.jstree
			 * @param {Array} node
			 */
			this.trigger('cut', { "node" : obj });
		},
		/**
		 * copy a node (a later call to `paste(obj)` would copy the node)
		 * @name copy(obj)
		 * @param  {mixed} obj multiple objects can be passed using an array
		 * @trigger copy.jstree
		 */
		copy : function (obj) {
			if(!obj) { obj = this._data.core.selected.concat(); }
			if(!$.isArray(obj)) { obj = [obj]; }
			if(!obj.length) { return false; }
			var tmp = [], o, t1, t2;
			for(t1 = 0, t2 = obj.length; t1 < t2; t1++) {
				o = this.get_node(obj[t1]);
				if(o && o.id && o.id !== $.jstree.root) { tmp.push(o); }
			}
			if(!tmp.length) { return false; }
			ccp_node = tmp;
			ccp_inst = this;
			ccp_mode = 'copy_node';
			/**
			 * triggered when nodes are added to the buffer for copying
			 * @event
			 * @name copy.jstree
			 * @param {Array} node
			 */
			this.trigger('copy', { "node" : obj });
		},
		/**
		 * get the current buffer (any nodes that are waiting for a paste operation)
		 * @name get_buffer()
		 * @return {Object} an object consisting of `mode` ("copy_node" or "move_node"), `node` (an array of objects) and `inst` (the instance)
		 */
		get_buffer : function () {
			return { 'mode' : ccp_mode, 'node' : ccp_node, 'inst' : ccp_inst };
		},
		/**
		 * check if there is something in the buffer to paste
		 * @name can_paste()
		 * @return {Boolean}
		 */
		can_paste : function () {
			return ccp_mode !== false && ccp_node !== false; // && ccp_inst._model.data[ccp_node];
		},
		/**
		 * copy or move the previously cut or copied nodes to a new parent
		 * @name paste(obj [, pos])
		 * @param  {mixed} obj the new parent
		 * @param  {mixed} pos the position to insert at (besides integer, "first" and "last" are supported), defaults to integer `0`
		 * @trigger paste.jstree
		 */
		paste : function (obj, pos) {
			obj = this.get_node(obj);
			if(!obj || !ccp_mode || !ccp_mode.match(/^(copy_node|move_node)$/) || !ccp_node) { return false; }
			if(this[ccp_mode](ccp_node, obj, pos, false, false, false, ccp_inst)) {
				/**
				 * triggered when paste is invoked
				 * @event
				 * @name paste.jstree
				 * @param {String} parent the ID of the receiving node
				 * @param {Array} node the nodes in the buffer
				 * @param {String} mode the performed operation - "copy_node" or "move_node"
				 */
				this.trigger('paste', { "parent" : obj.id, "node" : ccp_node, "mode" : ccp_mode });
			}
			ccp_node = false;
			ccp_mode = false;
			ccp_inst = false;
		},
		/**
		 * clear the buffer of previously copied or cut nodes
		 * @name clear_buffer()
		 * @trigger clear_buffer.jstree
		 */
		clear_buffer : function () {
			ccp_node = false;
			ccp_mode = false;
			ccp_inst = false;
			/**
			 * triggered when the copy / cut buffer is cleared
			 * @event
			 * @name clear_buffer.jstree
			 */
			this.trigger('clear_buffer');
		},
		/**
		 * put a node in edit mode (input field to rename the node)
		 * @name edit(obj [, default_text, callback])
		 * @param  {mixed} obj
		 * @param  {String} default_text the text to populate the input with (if omitted or set to a non-string value the node's text value is used)
		 * @param  {Function} callback a function to be called once the text box is blurred, it is called in the instance's scope and receives the node, a status parameter (true if the rename is successful, false otherwise) and a boolean indicating if the user cancelled the edit. You can access the node's title using .text
		 */
		edit : function (obj, default_text, callback) {
			var rtl, w, a, s, t, h1, h2, fn, tmp, cancel = false;
			obj = this.get_node(obj);
			if(!obj) { return false; }
			if(this.settings.core.check_callback === false) {
				this._data.core.last_error = { 'error' : 'check', 'plugin' : 'core', 'id' : 'core_07', 'reason' : 'Could not edit node because of check_callback' };
				this.settings.core.error.call(this, this._data.core.last_error);
				return false;
			}
			tmp = obj;
			default_text = typeof default_text === 'string' ? default_text : obj.text;
			this.set_text(obj, "");
			obj = this._open_to(obj);
			tmp.text = default_text;

			rtl = this._data.core.rtl;
			w  = this.element.width();
			this._data.core.focused = tmp.id;
			a  = obj.children('.jstree-anchor').focus();
			s  = $('<span>');
			/*!
			oi = obj.children("i:visible"),
			ai = a.children("i:visible"),
			w1 = oi.width() * oi.length,
			w2 = ai.width() * ai.length,
			*/
			t  = default_text;
			h1 = $("<"+"div />", { css : { "position" : "absolute", "top" : "-200px", "left" : (rtl ? "0px" : "-1000px"), "visibility" : "hidden" } }).appendTo("body");
			h2 = $("<"+"input />", {
						"value" : t,
						"class" : "jstree-rename-input",
						// "size" : t.length,
						"css" : {
							"padding" : "0",
							"border" : "1px solid silver",
							"box-sizing" : "border-box",
							"display" : "inline-block",
							"height" : (this._data.core.li_height) + "px",
							"lineHeight" : (this._data.core.li_height) + "px",
							"width" : "150px" // will be set a bit further down
						},
						"blur" : $.proxy(function (e) {
							e.stopImmediatePropagation();
							e.preventDefault();
							var i = s.children(".jstree-rename-input"),
								v = i.val(),
								f = this.settings.core.force_text,
								nv;
							if(v === "") { v = t; }
							h1.remove();
							s.replaceWith(a);
							s.remove();
							t = f ? t : $('<div></div>').append($.parseHTML(t)).html();
							this.set_text(obj, t);
							nv = !!this.rename_node(obj, f ? $('<div></div>').text(v).text() : $('<div></div>').append($.parseHTML(v)).html());
							if(!nv) {
								this.set_text(obj, t); // move this up? and fix #483
							}
							this._data.core.focused = tmp.id;
							setTimeout($.proxy(function () {
								var node = this.get_node(tmp.id, true);
								if(node.length) {
									this._data.core.focused = tmp.id;
									node.children('.jstree-anchor').focus();
								}
							}, this), 0);
							if(callback) {
								callback.call(this, tmp, nv, cancel);
							}
							h2 = null;
						}, this),
						"keydown" : function (e) {
							var key = e.which;
							if(key === 27) {
								cancel = true;
								this.value = t;
							}
							if(key === 27 || key === 13 || key === 37 || key === 38 || key === 39 || key === 40 || key === 32) {
								e.stopImmediatePropagation();
							}
							if(key === 27 || key === 13) {
								e.preventDefault();
								this.blur();
							}
						},
						"click" : function (e) { e.stopImmediatePropagation(); },
						"mousedown" : function (e) { e.stopImmediatePropagation(); },
						"keyup" : function (e) {
							h2.width(Math.min(h1.text("pW" + this.value).width(),w));
						},
						"keypress" : function(e) {
							if(e.which === 13) { return false; }
						}
					});
				fn = {
						fontFamily		: a.css('fontFamily')		|| '',
						fontSize		: a.css('fontSize')			|| '',
						fontWeight		: a.css('fontWeight')		|| '',
						fontStyle		: a.css('fontStyle')		|| '',
						fontStretch		: a.css('fontStretch')		|| '',
						fontVariant		: a.css('fontVariant')		|| '',
						letterSpacing	: a.css('letterSpacing')	|| '',
						wordSpacing		: a.css('wordSpacing')		|| ''
				};
			s.attr('class', a.attr('class')).append(a.contents().clone()).append(h2);
			a.replaceWith(s);
			h1.css(fn);
			h2.css(fn).width(Math.min(h1.text("pW" + h2[0].value).width(),w))[0].select();
			$(document).one('mousedown.jstree touchstart.jstree dnd_start.vakata', function (e) {
				if (h2 && e.target !== h2) {
					$(h2).blur();
				}
			});
		},


		/**
		 * changes the theme
		 * @name set_theme(theme_name [, theme_url])
		 * @param {String} theme_name the name of the new theme to apply
		 * @param {mixed} theme_url  the location of the CSS file for this theme. Omit or set to `false` if you manually included the file. Set to `true` to autoload from the `core.themes.dir` directory.
		 * @trigger set_theme.jstree
		 */
		set_theme : function (theme_name, theme_url) {
			if(!theme_name) { return false; }
			if(theme_url === true) {
				var dir = this.settings.core.themes.dir;
				if(!dir) { dir = $.jstree.path + '/themes'; }
				theme_url = dir + '/' + theme_name + '/style.css';
			}
			if(theme_url && $.inArray(theme_url, themes_loaded) === -1) {
				$('head').append('<'+'link rel="stylesheet" href="' + theme_url + '" type="text/css" />');
				themes_loaded.push(theme_url);
			}
			if(this._data.core.themes.name) {
				this.element.removeClass('jstree-' + this._data.core.themes.name);
			}
			this._data.core.themes.name = theme_name;
			this.element.addClass('jstree-' + theme_name);
			this.element[this.settings.core.themes.responsive ? 'addClass' : 'removeClass' ]('jstree-' + theme_name + '-responsive');
			/**
			 * triggered when a theme is set
			 * @event
			 * @name set_theme.jstree
			 * @param {String} theme the new theme
			 */
			this.trigger('set_theme', { 'theme' : theme_name });
		},
		/**
		 * gets the name of the currently applied theme name
		 * @name get_theme()
		 * @return {String}
		 */
		get_theme : function () { return this._data.core.themes.name; },
		/**
		 * changes the theme variant (if the theme has variants)
		 * @name set_theme_variant(variant_name)
		 * @param {String|Boolean} variant_name the variant to apply (if `false` is used the current variant is removed)
		 */
		set_theme_variant : function (variant_name) {
			if(this._data.core.themes.variant) {
				this.element.removeClass('jstree-' + this._data.core.themes.name + '-' + this._data.core.themes.variant);
			}
			this._data.core.themes.variant = variant_name;
			if(variant_name) {
				this.element.addClass('jstree-' + this._data.core.themes.name + '-' + this._data.core.themes.variant);
			}
		},
		/**
		 * gets the name of the currently applied theme variant
		 * @name get_theme()
		 * @return {String}
		 */
		get_theme_variant : function () { return this._data.core.themes.variant; },
		/**
		 * shows a striped background on the container (if the theme supports it)
		 * @name show_stripes()
		 */
		show_stripes : function () {
			this._data.core.themes.stripes = true;
			this.get_container_ul().addClass("jstree-striped");
			/**
			 * triggered when stripes are shown
			 * @event
			 * @name show_stripes.jstree
			 */
			this.trigger('show_stripes');
		},
		/**
		 * hides the striped background on the container
		 * @name hide_stripes()
		 */
		hide_stripes : function () {
			this._data.core.themes.stripes = false;
			this.get_container_ul().removeClass("jstree-striped");
			/**
			 * triggered when stripes are hidden
			 * @event
			 * @name hide_stripes.jstree
			 */
			this.trigger('hide_stripes');
		},
		/**
		 * toggles the striped background on the container
		 * @name toggle_stripes()
		 */
		toggle_stripes : function () { if(this._data.core.themes.stripes) { this.hide_stripes(); } else { this.show_stripes(); } },
		/**
		 * shows the connecting dots (if the theme supports it)
		 * @name show_dots()
		 */
		show_dots : function () {
			this._data.core.themes.dots = true;
			this.get_container_ul().removeClass("jstree-no-dots");
			/**
			 * triggered when dots are shown
			 * @event
			 * @name show_dots.jstree
			 */
			this.trigger('show_dots');
		},
		/**
		 * hides the connecting dots
		 * @name hide_dots()
		 */
		hide_dots : function () {
			this._data.core.themes.dots = false;
			this.get_container_ul().addClass("jstree-no-dots");
			/**
			 * triggered when dots are hidden
			 * @event
			 * @name hide_dots.jstree
			 */
			this.trigger('hide_dots');
		},
		/**
		 * toggles the connecting dots
		 * @name toggle_dots()
		 */
		toggle_dots : function () { if(this._data.core.themes.dots) { this.hide_dots(); } else { this.show_dots(); } },
		/**
		 * show the node icons
		 * @name show_icons()
		 */
		show_icons : function () {
			this._data.core.themes.icons = true;
			this.get_container_ul().removeClass("jstree-no-icons");
			/**
			 * triggered when icons are shown
			 * @event
			 * @name show_icons.jstree
			 */
			this.trigger('show_icons');
		},
		/**
		 * hide the node icons
		 * @name hide_icons()
		 */
		hide_icons : function () {
			this._data.core.themes.icons = false;
			this.get_container_ul().addClass("jstree-no-icons");
			/**
			 * triggered when icons are hidden
			 * @event
			 * @name hide_icons.jstree
			 */
			this.trigger('hide_icons');
		},
		/**
		 * toggle the node icons
		 * @name toggle_icons()
		 */
		toggle_icons : function () { if(this._data.core.themes.icons) { this.hide_icons(); } else { this.show_icons(); } },
		/**
		 * show the node ellipsis
		 * @name show_icons()
		 */
		show_ellipsis : function () {
			this._data.core.themes.ellipsis = true;
			this.get_container_ul().addClass("jstree-ellipsis");
			/**
			 * triggered when ellisis is shown
			 * @event
			 * @name show_ellipsis.jstree
			 */
			this.trigger('show_ellipsis');
		},
		/**
		 * hide the node ellipsis
		 * @name hide_ellipsis()
		 */
		hide_ellipsis : function () {
			this._data.core.themes.ellipsis = false;
			this.get_container_ul().removeClass("jstree-ellipsis");
			/**
			 * triggered when ellisis is hidden
			 * @event
			 * @name hide_ellipsis.jstree
			 */
			this.trigger('hide_ellipsis');
		},
		/**
		 * toggle the node ellipsis
		 * @name toggle_icons()
		 */
		toggle_ellipsis : function () { if(this._data.core.themes.ellipsis) { this.hide_ellipsis(); } else { this.show_ellipsis(); } },
		/**
		 * set the node icon for a node
		 * @name set_icon(obj, icon)
		 * @param {mixed} obj
		 * @param {String} icon the new icon - can be a path to an icon or a className, if using an image that is in the current directory use a `./` prefix, otherwise it will be detected as a class
		 */
		set_icon : function (obj, icon) {
			var t1, t2, dom, old;
			if($.isArray(obj)) {
				obj = obj.slice();
				for(t1 = 0, t2 = obj.length; t1 < t2; t1++) {
					this.set_icon(obj[t1], icon);
				}
				return true;
			}
			obj = this.get_node(obj);
			if(!obj || obj.id === $.jstree.root) { return false; }
			old = obj.icon;
			obj.icon = icon === true || icon === null || icon === undefined || icon === '' ? true : icon;
			dom = this.get_node(obj, true).children(".jstree-anchor").children(".jstree-themeicon");
			if(icon === false) {
				this.hide_icon(obj);
			}
			else if(icon === true || icon === null || icon === undefined || icon === '') {
				dom.removeClass('jstree-themeicon-custom ' + old).css("background","").removeAttr("rel");
				if(old === false) { this.show_icon(obj); }
			}
			else if(icon.indexOf("/") === -1 && icon.indexOf(".") === -1) {
				dom.removeClass(old).css("background","");
				dom.addClass(icon + ' jstree-themeicon-custom').attr("rel",icon);
				if(old === false) { this.show_icon(obj); }
			}
			else {
				dom.removeClass(old).css("background","");
				dom.addClass('jstree-themeicon-custom').css("background", "url('" + icon + "') center center no-repeat").attr("rel",icon);
				if(old === false) { this.show_icon(obj); }
			}
			return true;
		},
		/**
		 * get the node icon for a node
		 * @name get_icon(obj)
		 * @param {mixed} obj
		 * @return {String}
		 */
		get_icon : function (obj) {
			obj = this.get_node(obj);
			return (!obj || obj.id === $.jstree.root) ? false : obj.icon;
		},
		/**
		 * hide the icon on an individual node
		 * @name hide_icon(obj)
		 * @param {mixed} obj
		 */
		hide_icon : function (obj) {
			var t1, t2;
			if($.isArray(obj)) {
				obj = obj.slice();
				for(t1 = 0, t2 = obj.length; t1 < t2; t1++) {
					this.hide_icon(obj[t1]);
				}
				return true;
			}
			obj = this.get_node(obj);
			if(!obj || obj === $.jstree.root) { return false; }
			obj.icon = false;
			this.get_node(obj, true).children(".jstree-anchor").children(".jstree-themeicon").addClass('jstree-themeicon-hidden');
			return true;
		},
		/**
		 * show the icon on an individual node
		 * @name show_icon(obj)
		 * @param {mixed} obj
		 */
		show_icon : function (obj) {
			var t1, t2, dom;
			if($.isArray(obj)) {
				obj = obj.slice();
				for(t1 = 0, t2 = obj.length; t1 < t2; t1++) {
					this.show_icon(obj[t1]);
				}
				return true;
			}
			obj = this.get_node(obj);
			if(!obj || obj === $.jstree.root) { return false; }
			dom = this.get_node(obj, true);
			obj.icon = dom.length ? dom.children(".jstree-anchor").children(".jstree-themeicon").attr('rel') : true;
			if(!obj.icon) { obj.icon = true; }
			dom.children(".jstree-anchor").children(".jstree-themeicon").removeClass('jstree-themeicon-hidden');
			return true;
		}
	};

	// helpers
	$.vakata = {};
	// collect attributes
	$.vakata.attributes = function(node, with_values) {
		node = $(node)[0];
		var attr = with_values ? {} : [];
		if(node && node.attributes) {
			$.each(node.attributes, function (i, v) {
				if($.inArray(v.name.toLowerCase(),['style','contenteditable','hasfocus','tabindex']) !== -1) { return; }
				if(v.value !== null && $.trim(v.value) !== '') {
					if(with_values) { attr[v.name] = v.value; }
					else { attr.push(v.name); }
				}
			});
		}
		return attr;
	};
	$.vakata.array_unique = function(array) {
		var a = [], i, j, l, o = {};
		for(i = 0, l = array.length; i < l; i++) {
			if(o[array[i]] === undefined) {
				a.push(array[i]);
				o[array[i]] = true;
			}
		}
		return a;
	};
	// remove item from array
	$.vakata.array_remove = function(array, from) {
		array.splice(from, 1);
		return array;
		//var rest = array.slice((to || from) + 1 || array.length);
		//array.length = from < 0 ? array.length + from : from;
		//array.push.apply(array, rest);
		//return array;
	};
	// remove item from array
	$.vakata.array_remove_item = function(array, item) {
		var tmp = $.inArray(item, array);
		return tmp !== -1 ? $.vakata.array_remove(array, tmp) : array;
	};
	$.vakata.array_filter = function(c,a,b,d,e) {
		if (c.filter) {
			return c.filter(a, b);
		}
		d=[];
		for (e in c) {
			if (~~e+''===e+'' && e>=0 && a.call(b,c[e],+e,c)) {
				d.push(c[e]);
			}
		}
		return d;
	};


/**
 * ### Changed plugin
 *
 * This plugin adds more information to the `changed.jstree` event. The new data is contained in the `changed` event data property, and contains a lists of `selected` and `deselected` nodes.
 */

	$.jstree.plugins.changed = function (options, parent) {
		var last = [];
		this.trigger = function (ev, data) {
			var i, j;
			if(!data) {
				data = {};
			}
			if(ev.replace('.jstree','') === 'changed') {
				data.changed = { selected : [], deselected : [] };
				var tmp = {};
				for(i = 0, j = last.length; i < j; i++) {
					tmp[last[i]] = 1;
				}
				for(i = 0, j = data.selected.length; i < j; i++) {
					if(!tmp[data.selected[i]]) {
						data.changed.selected.push(data.selected[i]);
					}
					else {
						tmp[data.selected[i]] = 2;
					}
				}
				for(i = 0, j = last.length; i < j; i++) {
					if(tmp[last[i]] === 1) {
						data.changed.deselected.push(last[i]);
					}
				}
				last = data.selected.slice();
			}
			/**
			 * triggered when selection changes (the "changed" plugin enhances the original event with more data)
			 * @event
			 * @name changed.jstree
			 * @param {Object} node
			 * @param {Object} action the action that caused the selection to change
			 * @param {Array} selected the current selection
			 * @param {Object} changed an object containing two properties `selected` and `deselected` - both arrays of node IDs, which were selected or deselected since the last changed event
			 * @param {Object} event the event (if any) that triggered this changed event
			 * @plugin changed
			 */
			parent.trigger.call(this, ev, data);
		};
		this.refresh = function (skip_loading, forget_state) {
			last = [];
			return parent.refresh.apply(this, arguments);
		};
	};

/**
 * ### Checkbox plugin
 *
 * This plugin renders checkbox icons in front of each node, making multiple selection much easier.
 * It also supports tri-state behavior, meaning that if a node has a few of its children checked it will be rendered as undetermined, and state will be propagated up.
 */

	var _i = document.createElement('I');
	_i.className = 'jstree-icon jstree-checkbox';
	_i.setAttribute('role', 'presentation');
	/**
	 * stores all defaults for the checkbox plugin
	 * @name $.jstree.defaults.checkbox
	 * @plugin checkbox
	 */
	$.jstree.defaults.checkbox = {
		/**
		 * a boolean indicating if checkboxes should be visible (can be changed at a later time using `show_checkboxes()` and `hide_checkboxes`). Defaults to `true`.
		 * @name $.jstree.defaults.checkbox.visible
		 * @plugin checkbox
		 */
		visible				: true,
		/**
		 * a boolean indicating if checkboxes should cascade down and have an undetermined state. Defaults to `true`.
		 * @name $.jstree.defaults.checkbox.three_state
		 * @plugin checkbox
		 */
		three_state			: true,
		/**
		 * a boolean indicating if clicking anywhere on the node should act as clicking on the checkbox. Defaults to `true`.
		 * @name $.jstree.defaults.checkbox.whole_node
		 * @plugin checkbox
		 */
		whole_node			: true,
		/**
		 * a boolean indicating if the selected style of a node should be kept, or removed. Defaults to `true`.
		 * @name $.jstree.defaults.checkbox.keep_selected_style
		 * @plugin checkbox
		 */
		keep_selected_style	: true,
		/**
		 * This setting controls how cascading and undetermined nodes are applied.
		 * If 'up' is in the string - cascading up is enabled, if 'down' is in the string - cascading down is enabled, if 'undetermined' is in the string - undetermined nodes will be used.
		 * If `three_state` is set to `true` this setting is automatically set to 'up+down+undetermined'. Defaults to ''.
		 * @name $.jstree.defaults.checkbox.cascade
		 * @plugin checkbox
		 */
		cascade				: '',
		/**
		 * This setting controls if checkbox are bound to the general tree selection or to an internal array maintained by the checkbox plugin. Defaults to `true`, only set to `false` if you know exactly what you are doing.
		 * @name $.jstree.defaults.checkbox.tie_selection
		 * @plugin checkbox
		 */
		tie_selection		: true
	};
	$.jstree.plugins.checkbox = function (options, parent) {
		this.bind = function () {
			parent.bind.call(this);
			this._data.checkbox.uto = false;
			this._data.checkbox.selected = [];
			if(this.settings.checkbox.three_state) {
				this.settings.checkbox.cascade = 'up+down+undetermined';
			}
			this.element
				.on("init.jstree", $.proxy(function () {
						this._data.checkbox.visible = this.settings.checkbox.visible;
						if(!this.settings.checkbox.keep_selected_style) {
							this.element.addClass('jstree-checkbox-no-clicked');
						}
						if(this.settings.checkbox.tie_selection) {
							this.element.addClass('jstree-checkbox-selection');
						}
					}, this))
				.on("loading.jstree", $.proxy(function () {
						this[ this._data.checkbox.visible ? 'show_checkboxes' : 'hide_checkboxes' ]();
					}, this));
			if(this.settings.checkbox.cascade.indexOf('undetermined') !== -1) {
				this.element
					.on('changed.jstree uncheck_node.jstree check_node.jstree uncheck_all.jstree check_all.jstree move_node.jstree copy_node.jstree redraw.jstree open_node.jstree', $.proxy(function () {
							// only if undetermined is in setting
							if(this._data.checkbox.uto) { clearTimeout(this._data.checkbox.uto); }
							this._data.checkbox.uto = setTimeout($.proxy(this._undetermined, this), 50);
						}, this));
			}
			if(!this.settings.checkbox.tie_selection) {
				this.element
					.on('model.jstree', $.proxy(function (e, data) {
						var m = this._model.data,
							p = m[data.parent],
							dpc = data.nodes,
							i, j;
						for(i = 0, j = dpc.length; i < j; i++) {
							m[dpc[i]].state.checked = m[dpc[i]].state.checked || (m[dpc[i]].original && m[dpc[i]].original.state && m[dpc[i]].original.state.checked);
							if(m[dpc[i]].state.checked) {
								this._data.checkbox.selected.push(dpc[i]);
							}
						}
					}, this));
			}
			if(this.settings.checkbox.cascade.indexOf('up') !== -1 || this.settings.checkbox.cascade.indexOf('down') !== -1) {
				this.element
					.on('model.jstree', $.proxy(function (e, data) {
							var m = this._model.data,
								p = m[data.parent],
								dpc = data.nodes,
								chd = [],
								c, i, j, k, l, tmp, s = this.settings.checkbox.cascade, t = this.settings.checkbox.tie_selection;

							if(s.indexOf('down') !== -1) {
								// apply down
								if(p.state[ t ? 'selected' : 'checked' ]) {
									for(i = 0, j = dpc.length; i < j; i++) {
										m[dpc[i]].state[ t ? 'selected' : 'checked' ] = true;
									}
									this._data[ t ? 'core' : 'checkbox' ].selected = this._data[ t ? 'core' : 'checkbox' ].selected.concat(dpc);
								}
								else {
									for(i = 0, j = dpc.length; i < j; i++) {
										if(m[dpc[i]].state[ t ? 'selected' : 'checked' ]) {
											for(k = 0, l = m[dpc[i]].children_d.length; k < l; k++) {
												m[m[dpc[i]].children_d[k]].state[ t ? 'selected' : 'checked' ] = true;
											}
											this._data[ t ? 'core' : 'checkbox' ].selected = this._data[ t ? 'core' : 'checkbox' ].selected.concat(m[dpc[i]].children_d);
										}
									}
								}
							}

							if(s.indexOf('up') !== -1) {
								// apply up
								for(i = 0, j = p.children_d.length; i < j; i++) {
									if(!m[p.children_d[i]].children.length) {
										chd.push(m[p.children_d[i]].parent);
									}
								}
								chd = $.vakata.array_unique(chd);
								for(k = 0, l = chd.length; k < l; k++) {
									p = m[chd[k]];
									while(p && p.id !== $.jstree.root) {
										c = 0;
										for(i = 0, j = p.children.length; i < j; i++) {
											c += m[p.children[i]].state[ t ? 'selected' : 'checked' ];
										}
										if(c === j) {
											p.state[ t ? 'selected' : 'checked' ] = true;
											this._data[ t ? 'core' : 'checkbox' ].selected.push(p.id);
											tmp = this.get_node(p, true);
											if(tmp && tmp.length) {
												tmp.attr('aria-selected', true).children('.jstree-anchor').addClass( t ? 'jstree-clicked' : 'jstree-checked');
											}
										}
										else {
											break;
										}
										p = this.get_node(p.parent);
									}
								}
							}

							this._data[ t ? 'core' : 'checkbox' ].selected = $.vakata.array_unique(this._data[ t ? 'core' : 'checkbox' ].selected);
						}, this))
					.on(this.settings.checkbox.tie_selection ? 'select_node.jstree' : 'check_node.jstree', $.proxy(function (e, data) {
							var obj = data.node,
								m = this._model.data,
								par = this.get_node(obj.parent),
								dom = this.get_node(obj, true),
								i, j, c, tmp, s = this.settings.checkbox.cascade, t = this.settings.checkbox.tie_selection,
								sel = {}, cur = this._data[ t ? 'core' : 'checkbox' ].selected;

							for (i = 0, j = cur.length; i < j; i++) {
								sel[cur[i]] = true;
							}
							// apply down
							if(s.indexOf('down') !== -1) {
								//this._data[ t ? 'core' : 'checkbox' ].selected = $.vakata.array_unique(this._data[ t ? 'core' : 'checkbox' ].selected.concat(obj.children_d));
								for(i = 0, j = obj.children_d.length; i < j; i++) {
									sel[obj.children_d[i]] = true;
									tmp = m[obj.children_d[i]];
									tmp.state[ t ? 'selected' : 'checked' ] = true;
									if(tmp && tmp.original && tmp.original.state && tmp.original.state.undetermined) {
										tmp.original.state.undetermined = false;
									}
								}
							}

							// apply up
							if(s.indexOf('up') !== -1) {
								while(par && par.id !== $.jstree.root) {
									c = 0;
									for(i = 0, j = par.children.length; i < j; i++) {
										c += m[par.children[i]].state[ t ? 'selected' : 'checked' ];
									}
									if(c === j) {
										par.state[ t ? 'selected' : 'checked' ] = true;
										sel[par.id] = true;
										//this._data[ t ? 'core' : 'checkbox' ].selected.push(par.id);
										tmp = this.get_node(par, true);
										if(tmp && tmp.length) {
											tmp.attr('aria-selected', true).children('.jstree-anchor').addClass(t ? 'jstree-clicked' : 'jstree-checked');
										}
									}
									else {
										break;
									}
									par = this.get_node(par.parent);
								}
							}

							cur = [];
							for (i in sel) {
								if (sel.hasOwnProperty(i)) {
									cur.push(i);
								}
							}
							this._data[ t ? 'core' : 'checkbox' ].selected = cur;

							// apply down (process .children separately?)
							if(s.indexOf('down') !== -1 && dom.length) {
								dom.find('.jstree-anchor').addClass(t ? 'jstree-clicked' : 'jstree-checked').parent().attr('aria-selected', true);
							}
						}, this))
					.on(this.settings.checkbox.tie_selection ? 'deselect_all.jstree' : 'uncheck_all.jstree', $.proxy(function (e, data) {
							var obj = this.get_node($.jstree.root),
								m = this._model.data,
								i, j, tmp;
							for(i = 0, j = obj.children_d.length; i < j; i++) {
								tmp = m[obj.children_d[i]];
								if(tmp && tmp.original && tmp.original.state && tmp.original.state.undetermined) {
									tmp.original.state.undetermined = false;
								}
							}
						}, this))
					.on(this.settings.checkbox.tie_selection ? 'deselect_node.jstree' : 'uncheck_node.jstree', $.proxy(function (e, data) {
							var obj = data.node,
								dom = this.get_node(obj, true),
								i, j, tmp, s = this.settings.checkbox.cascade, t = this.settings.checkbox.tie_selection,
								cur = this._data[ t ? 'core' : 'checkbox' ].selected, sel = {};
							if(obj && obj.original && obj.original.state && obj.original.state.undetermined) {
								obj.original.state.undetermined = false;
							}

							// apply down
							if(s.indexOf('down') !== -1) {
								for(i = 0, j = obj.children_d.length; i < j; i++) {
									tmp = this._model.data[obj.children_d[i]];
									tmp.state[ t ? 'selected' : 'checked' ] = false;
									if(tmp && tmp.original && tmp.original.state && tmp.original.state.undetermined) {
										tmp.original.state.undetermined = false;
									}
								}
							}

							// apply up
							if(s.indexOf('up') !== -1) {
								for(i = 0, j = obj.parents.length; i < j; i++) {
									tmp = this._model.data[obj.parents[i]];
									tmp.state[ t ? 'selected' : 'checked' ] = false;
									if(tmp && tmp.original && tmp.original.state && tmp.original.state.undetermined) {
										tmp.original.state.undetermined = false;
									}
									tmp = this.get_node(obj.parents[i], true);
									if(tmp && tmp.length) {
										tmp.attr('aria-selected', false).children('.jstree-anchor').removeClass(t ? 'jstree-clicked' : 'jstree-checked');
									}
								}
							}
							sel = {};
							for(i = 0, j = cur.length; i < j; i++) {
								// apply down + apply up
								if(
									(s.indexOf('down') === -1 || $.inArray(cur[i], obj.children_d) === -1) &&
									(s.indexOf('up') === -1 || $.inArray(cur[i], obj.parents) === -1)
								) {
									sel[cur[i]] = true;
								}
							}
							cur = [];
							for (i in sel) {
								if (sel.hasOwnProperty(i)) {
									cur.push(i);
								}
							}
							this._data[ t ? 'core' : 'checkbox' ].selected = cur;
							
							// apply down (process .children separately?)
							if(s.indexOf('down') !== -1 && dom.length) {
								dom.find('.jstree-anchor').removeClass(t ? 'jstree-clicked' : 'jstree-checked').parent().attr('aria-selected', false);
							}
						}, this));
			}
			if(this.settings.checkbox.cascade.indexOf('up') !== -1) {
				this.element
					.on('delete_node.jstree', $.proxy(function (e, data) {
							// apply up (whole handler)
							var p = this.get_node(data.parent),
								m = this._model.data,
								i, j, c, tmp, t = this.settings.checkbox.tie_selection;
							while(p && p.id !== $.jstree.root && !p.state[ t ? 'selected' : 'checked' ]) {
								c = 0;
								for(i = 0, j = p.children.length; i < j; i++) {
									c += m[p.children[i]].state[ t ? 'selected' : 'checked' ];
								}
								if(j > 0 && c === j) {
									p.state[ t ? 'selected' : 'checked' ] = true;
									this._data[ t ? 'core' : 'checkbox' ].selected.push(p.id);
									tmp = this.get_node(p, true);
									if(tmp && tmp.length) {
										tmp.attr('aria-selected', true).children('.jstree-anchor').addClass(t ? 'jstree-clicked' : 'jstree-checked');
									}
								}
								else {
									break;
								}
								p = this.get_node(p.parent);
							}
						}, this))
					.on('move_node.jstree', $.proxy(function (e, data) {
							// apply up (whole handler)
							var is_multi = data.is_multi,
								old_par = data.old_parent,
								new_par = this.get_node(data.parent),
								m = this._model.data,
								p, c, i, j, tmp, t = this.settings.checkbox.tie_selection;
							if(!is_multi) {
								p = this.get_node(old_par);
								while(p && p.id !== $.jstree.root && !p.state[ t ? 'selected' : 'checked' ]) {
									c = 0;
									for(i = 0, j = p.children.length; i < j; i++) {
										c += m[p.children[i]].state[ t ? 'selected' : 'checked' ];
									}
									if(j > 0 && c === j) {
										p.state[ t ? 'selected' : 'checked' ] = true;
										this._data[ t ? 'core' : 'checkbox' ].selected.push(p.id);
										tmp = this.get_node(p, true);
										if(tmp && tmp.length) {
											tmp.attr('aria-selected', true).children('.jstree-anchor').addClass(t ? 'jstree-clicked' : 'jstree-checked');
										}
									}
									else {
										break;
									}
									p = this.get_node(p.parent);
								}
							}
							p = new_par;
							while(p && p.id !== $.jstree.root) {
								c = 0;
								for(i = 0, j = p.children.length; i < j; i++) {
									c += m[p.children[i]].state[ t ? 'selected' : 'checked' ];
								}
								if(c === j) {
									if(!p.state[ t ? 'selected' : 'checked' ]) {
										p.state[ t ? 'selected' : 'checked' ] = true;
										this._data[ t ? 'core' : 'checkbox' ].selected.push(p.id);
										tmp = this.get_node(p, true);
										if(tmp && tmp.length) {
											tmp.attr('aria-selected', true).children('.jstree-anchor').addClass(t ? 'jstree-clicked' : 'jstree-checked');
										}
									}
								}
								else {
									if(p.state[ t ? 'selected' : 'checked' ]) {
										p.state[ t ? 'selected' : 'checked' ] = false;
										this._data[ t ? 'core' : 'checkbox' ].selected = $.vakata.array_remove_item(this._data[ t ? 'core' : 'checkbox' ].selected, p.id);
										tmp = this.get_node(p, true);
										if(tmp && tmp.length) {
											tmp.attr('aria-selected', false).children('.jstree-anchor').removeClass(t ? 'jstree-clicked' : 'jstree-checked');
										}
									}
									else {
										break;
									}
								}
								p = this.get_node(p.parent);
							}
						}, this));
			}
		};
		/**
		 * set the undetermined state where and if necessary. Used internally.
		 * @private
		 * @name _undetermined()
		 * @plugin checkbox
		 */
		this._undetermined = function () {
			if(this.element === null) { return; }
			var i, j, k, l, o = {}, m = this._model.data, t = this.settings.checkbox.tie_selection, s = this._data[ t ? 'core' : 'checkbox' ].selected, p = [], tt = this;
			for(i = 0, j = s.length; i < j; i++) {
				if(m[s[i]] && m[s[i]].parents) {
					for(k = 0, l = m[s[i]].parents.length; k < l; k++) {
						if(o[m[s[i]].parents[k]] !== undefined) {
							break;
						}
						if(m[s[i]].parents[k] !== $.jstree.root) {
							o[m[s[i]].parents[k]] = true;
							p.push(m[s[i]].parents[k]);
						}
					}
				}
			}
			// attempt for server side undetermined state
			this.element.find('.jstree-closed').not(':has(.jstree-children)')
				.each(function () {
					var tmp = tt.get_node(this), tmp2;
					if(!tmp.state.loaded) {
						if(tmp.original && tmp.original.state && tmp.original.state.undetermined && tmp.original.state.undetermined === true) {
							if(o[tmp.id] === undefined && tmp.id !== $.jstree.root) {
								o[tmp.id] = true;
								p.push(tmp.id);
							}
							for(k = 0, l = tmp.parents.length; k < l; k++) {
								if(o[tmp.parents[k]] === undefined && tmp.parents[k] !== $.jstree.root) {
									o[tmp.parents[k]] = true;
									p.push(tmp.parents[k]);
								}
							}
						}
					}
					else {
						for(i = 0, j = tmp.children_d.length; i < j; i++) {
							tmp2 = m[tmp.children_d[i]];
							if(!tmp2.state.loaded && tmp2.original && tmp2.original.state && tmp2.original.state.undetermined && tmp2.original.state.undetermined === true) {
								if(o[tmp2.id] === undefined && tmp2.id !== $.jstree.root) {
									o[tmp2.id] = true;
									p.push(tmp2.id);
								}
								for(k = 0, l = tmp2.parents.length; k < l; k++) {
									if(o[tmp2.parents[k]] === undefined && tmp2.parents[k] !== $.jstree.root) {
										o[tmp2.parents[k]] = true;
										p.push(tmp2.parents[k]);
									}
								}
							}
						}
					}
				});

			this.element.find('.jstree-undetermined').removeClass('jstree-undetermined');
			for(i = 0, j = p.length; i < j; i++) {
				if(!m[p[i]].state[ t ? 'selected' : 'checked' ]) {
					s = this.get_node(p[i], true);
					if(s && s.length) {
						s.children('.jstree-anchor').children('.jstree-checkbox').addClass('jstree-undetermined');
					}
				}
			}
		};
		this.redraw_node = function(obj, deep, is_callback, force_render) {
			obj = parent.redraw_node.apply(this, arguments);
			if(obj) {
				var i, j, tmp = null, icon = null;
				for(i = 0, j = obj.childNodes.length; i < j; i++) {
					if(obj.childNodes[i] && obj.childNodes[i].className && obj.childNodes[i].className.indexOf("jstree-anchor") !== -1) {
						tmp = obj.childNodes[i];
						break;
					}
				}
				if(tmp) {
					if(!this.settings.checkbox.tie_selection && this._model.data[obj.id].state.checked) { tmp.className += ' jstree-checked'; }
					icon = _i.cloneNode(false);
					if(this._model.data[obj.id].state.checkbox_disabled) { icon.className += ' jstree-checkbox-disabled'; }
					tmp.insertBefore(icon, tmp.childNodes[0]);
				}
			}
			if(!is_callback && this.settings.checkbox.cascade.indexOf('undetermined') !== -1) {
				if(this._data.checkbox.uto) { clearTimeout(this._data.checkbox.uto); }
				this._data.checkbox.uto = setTimeout($.proxy(this._undetermined, this), 50);
			}
			return obj;
		};
		/**
		 * show the node checkbox icons
		 * @name show_checkboxes()
		 * @plugin checkbox
		 */
		this.show_checkboxes = function () { this._data.core.themes.checkboxes = true; this.get_container_ul().removeClass("jstree-no-checkboxes"); };
		/**
		 * hide the node checkbox icons
		 * @name hide_checkboxes()
		 * @plugin checkbox
		 */
		this.hide_checkboxes = function () { this._data.core.themes.checkboxes = false; this.get_container_ul().addClass("jstree-no-checkboxes"); };
		/**
		 * toggle the node icons
		 * @name toggle_checkboxes()
		 * @plugin checkbox
		 */
		this.toggle_checkboxes = function () { if(this._data.core.themes.checkboxes) { this.hide_checkboxes(); } else { this.show_checkboxes(); } };
		/**
		 * checks if a node is in an undetermined state
		 * @name is_undetermined(obj)
		 * @param  {mixed} obj
		 * @return {Boolean}
		 */
		this.is_undetermined = function (obj) {
			obj = this.get_node(obj);
			var s = this.settings.checkbox.cascade, i, j, t = this.settings.checkbox.tie_selection, d = this._data[ t ? 'core' : 'checkbox' ].selected, m = this._model.data;
			if(!obj || obj.state[ t ? 'selected' : 'checked' ] === true || s.indexOf('undetermined') === -1 || (s.indexOf('down') === -1 && s.indexOf('up') === -1)) {
				return false;
			}
			if(!obj.state.loaded && obj.original.state.undetermined === true) {
				return true;
			}
			for(i = 0, j = obj.children_d.length; i < j; i++) {
				if($.inArray(obj.children_d[i], d) !== -1 || (!m[obj.children_d[i]].state.loaded && m[obj.children_d[i]].original.state.undetermined)) {
					return true;
				}
			}
			return false;
		};
		/**
		 * disable a node's checkbox
		 * @name disable_checkbox(obj)
		 * @param {mixed} obj an array can be used too
		 * @trigger disable_checkbox.jstree
		 * @plugin checkbox
		 */
		this.disable_checkbox = function (obj) {
			var t1, t2, dom;
			if($.isArray(obj)) {
				obj = obj.slice();
				for(t1 = 0, t2 = obj.length; t1 < t2; t1++) {
					this.disable_checkbox(obj[t1]);
				}
				return true;
			}
			obj = this.get_node(obj);
			if(!obj || obj.id === $.jstree.root) {
				return false;
			}
			dom = this.get_node(obj, true);
			if(!obj.state.checkbox_disabled) {
				obj.state.checkbox_disabled = true;
				if(dom && dom.length) {
					dom.children('.jstree-anchor').children('.jstree-checkbox').addClass('jstree-checkbox-disabled');
				}
				/**
				 * triggered when an node's checkbox is disabled
				 * @event
				 * @name disable_checkbox.jstree
				 * @param {Object} node
				 * @plugin checkbox
				 */
				this.trigger('disable_checkbox', { 'node' : obj });
			}
		};
		/**
		 * enable a node's checkbox
		 * @name disable_checkbox(obj)
		 * @param {mixed} obj an array can be used too
		 * @trigger enable_checkbox.jstree
		 * @plugin checkbox
		 */
		this.enable_checkbox = function (obj) {
			var t1, t2, dom;
			if($.isArray(obj)) {
				obj = obj.slice();
				for(t1 = 0, t2 = obj.length; t1 < t2; t1++) {
					this.enable_checkbox(obj[t1]);
				}
				return true;
			}
			obj = this.get_node(obj);
			if(!obj || obj.id === $.jstree.root) {
				return false;
			}
			dom = this.get_node(obj, true);
			if(obj.state.checkbox_disabled) {
				obj.state.checkbox_disabled = false;
				if(dom && dom.length) {
					dom.children('.jstree-anchor').children('.jstree-checkbox').removeClass('jstree-checkbox-disabled');
				}
				/**
				 * triggered when an node's checkbox is enabled
				 * @event
				 * @name enable_checkbox.jstree
				 * @param {Object} node
				 * @plugin checkbox
				 */
				this.trigger('enable_checkbox', { 'node' : obj });
			}
		};

		this.activate_node = function (obj, e) {
			if($(e.target).hasClass('jstree-checkbox-disabled')) {
				return false;
			}
			if(this.settings.checkbox.tie_selection && (this.settings.checkbox.whole_node || $(e.target).hasClass('jstree-checkbox'))) {
				e.ctrlKey = true;
			}
			if(this.settings.checkbox.tie_selection || (!this.settings.checkbox.whole_node && !$(e.target).hasClass('jstree-checkbox'))) {
				return parent.activate_node.call(this, obj, e);
			}
			if(this.is_disabled(obj)) {
				return false;
			}
			if(this.is_checked(obj)) {
				this.uncheck_node(obj, e);
			}
			else {
				this.check_node(obj, e);
			}
			this.trigger('activate_node', { 'node' : this.get_node(obj) });
		};

		/**
		 * check a node (only if tie_selection in checkbox settings is false, otherwise select_node will be called internally)
		 * @name check_node(obj)
		 * @param {mixed} obj an array can be used to check multiple nodes
		 * @trigger check_node.jstree
		 * @plugin checkbox
		 */
		this.check_node = function (obj, e) {
			if(this.settings.checkbox.tie_selection) { return this.select_node(obj, false, true, e); }
			var dom, t1, t2, th;
			if($.isArray(obj)) {
				obj = obj.slice();
				for(t1 = 0, t2 = obj.length; t1 < t2; t1++) {
					this.check_node(obj[t1], e);
				}
				return true;
			}
			obj = this.get_node(obj);
			if(!obj || obj.id === $.jstree.root) {
				return false;
			}
			dom = this.get_node(obj, true);
			if(!obj.state.checked) {
				obj.state.checked = true;
				this._data.checkbox.selected.push(obj.id);
				if(dom && dom.length) {
					dom.children('.jstree-anchor').addClass('jstree-checked');
				}
				/**
				 * triggered when an node is checked (only if tie_selection in checkbox settings is false)
				 * @event
				 * @name check_node.jstree
				 * @param {Object} node
				 * @param {Array} selected the current selection
				 * @param {Object} event the event (if any) that triggered this check_node
				 * @plugin checkbox
				 */
				this.trigger('check_node', { 'node' : obj, 'selected' : this._data.checkbox.selected, 'event' : e });
			}
		};
		/**
		 * uncheck a node (only if tie_selection in checkbox settings is false, otherwise deselect_node will be called internally)
		 * @name uncheck_node(obj)
		 * @param {mixed} obj an array can be used to uncheck multiple nodes
		 * @trigger uncheck_node.jstree
		 * @plugin checkbox
		 */
		this.uncheck_node = function (obj, e) {
			if(this.settings.checkbox.tie_selection) { return this.deselect_node(obj, false, e); }
			var t1, t2, dom;
			if($.isArray(obj)) {
				obj = obj.slice();
				for(t1 = 0, t2 = obj.length; t1 < t2; t1++) {
					this.uncheck_node(obj[t1], e);
				}
				return true;
			}
			obj = this.get_node(obj);
			if(!obj || obj.id === $.jstree.root) {
				return false;
			}
			dom = this.get_node(obj, true);
			if(obj.state.checked) {
				obj.state.checked = false;
				this._data.checkbox.selected = $.vakata.array_remove_item(this._data.checkbox.selected, obj.id);
				if(dom.length) {
					dom.children('.jstree-anchor').removeClass('jstree-checked');
				}
				/**
				 * triggered when an node is unchecked (only if tie_selection in checkbox settings is false)
				 * @event
				 * @name uncheck_node.jstree
				 * @param {Object} node
				 * @param {Array} selected the current selection
				 * @param {Object} event the event (if any) that triggered this uncheck_node
				 * @plugin checkbox
				 */
				this.trigger('uncheck_node', { 'node' : obj, 'selected' : this._data.checkbox.selected, 'event' : e });
			}
		};
		/**
		 * checks all nodes in the tree (only if tie_selection in checkbox settings is false, otherwise select_all will be called internally)
		 * @name check_all()
		 * @trigger check_all.jstree, changed.jstree
		 * @plugin checkbox
		 */
		this.check_all = function () {
			if(this.settings.checkbox.tie_selection) { return this.select_all(); }
			var tmp = this._data.checkbox.selected.concat([]), i, j;
			this._data.checkbox.selected = this._model.data[$.jstree.root].children_d.concat();
			for(i = 0, j = this._data.checkbox.selected.length; i < j; i++) {
				if(this._model.data[this._data.checkbox.selected[i]]) {
					this._model.data[this._data.checkbox.selected[i]].state.checked = true;
				}
			}
			this.redraw(true);
			/**
			 * triggered when all nodes are checked (only if tie_selection in checkbox settings is false)
			 * @event
			 * @name check_all.jstree
			 * @param {Array} selected the current selection
			 * @plugin checkbox
			 */
			this.trigger('check_all', { 'selected' : this._data.checkbox.selected });
		};
		/**
		 * uncheck all checked nodes (only if tie_selection in checkbox settings is false, otherwise deselect_all will be called internally)
		 * @name uncheck_all()
		 * @trigger uncheck_all.jstree
		 * @plugin checkbox
		 */
		this.uncheck_all = function () {
			if(this.settings.checkbox.tie_selection) { return this.deselect_all(); }
			var tmp = this._data.checkbox.selected.concat([]), i, j;
			for(i = 0, j = this._data.checkbox.selected.length; i < j; i++) {
				if(this._model.data[this._data.checkbox.selected[i]]) {
					this._model.data[this._data.checkbox.selected[i]].state.checked = false;
				}
			}
			this._data.checkbox.selected = [];
			this.element.find('.jstree-checked').removeClass('jstree-checked');
			/**
			 * triggered when all nodes are unchecked (only if tie_selection in checkbox settings is false)
			 * @event
			 * @name uncheck_all.jstree
			 * @param {Object} node the previous selection
			 * @param {Array} selected the current selection
			 * @plugin checkbox
			 */
			this.trigger('uncheck_all', { 'selected' : this._data.checkbox.selected, 'node' : tmp });
		};
		/**
		 * checks if a node is checked (if tie_selection is on in the settings this function will return the same as is_selected)
		 * @name is_checked(obj)
		 * @param  {mixed}  obj
		 * @return {Boolean}
		 * @plugin checkbox
		 */
		this.is_checked = function (obj) {
			if(this.settings.checkbox.tie_selection) { return this.is_selected(obj); }
			obj = this.get_node(obj);
			if(!obj || obj.id === $.jstree.root) { return false; }
			return obj.state.checked;
		};
		/**
		 * get an array of all checked nodes (if tie_selection is on in the settings this function will return the same as get_selected)
		 * @name get_checked([full])
		 * @param  {mixed}  full if set to `true` the returned array will consist of the full node objects, otherwise - only IDs will be returned
		 * @return {Array}
		 * @plugin checkbox
		 */
		this.get_checked = function (full) {
			if(this.settings.checkbox.tie_selection) { return this.get_selected(full); }
			return full ? $.map(this._data.checkbox.selected, $.proxy(function (i) { return this.get_node(i); }, this)) : this._data.checkbox.selected;
		};
		/**
		 * get an array of all top level checked nodes (ignoring children of checked nodes) (if tie_selection is on in the settings this function will return the same as get_top_selected)
		 * @name get_top_checked([full])
		 * @param  {mixed}  full if set to `true` the returned array will consist of the full node objects, otherwise - only IDs will be returned
		 * @return {Array}
		 * @plugin checkbox
		 */
		this.get_top_checked = function (full) {
			if(this.settings.checkbox.tie_selection) { return this.get_top_selected(full); }
			var tmp = this.get_checked(true),
				obj = {}, i, j, k, l;
			for(i = 0, j = tmp.length; i < j; i++) {
				obj[tmp[i].id] = tmp[i];
			}
			for(i = 0, j = tmp.length; i < j; i++) {
				for(k = 0, l = tmp[i].children_d.length; k < l; k++) {
					if(obj[tmp[i].children_d[k]]) {
						delete obj[tmp[i].children_d[k]];
					}
				}
			}
			tmp = [];
			for(i in obj) {
				if(obj.hasOwnProperty(i)) {
					tmp.push(i);
				}
			}
			return full ? $.map(tmp, $.proxy(function (i) { return this.get_node(i); }, this)) : tmp;
		};
		/**
		 * get an array of all bottom level checked nodes (ignoring selected parents) (if tie_selection is on in the settings this function will return the same as get_bottom_selected)
		 * @name get_bottom_checked([full])
		 * @param  {mixed}  full if set to `true` the returned array will consist of the full node objects, otherwise - only IDs will be returned
		 * @return {Array}
		 * @plugin checkbox
		 */
		this.get_bottom_checked = function (full) {
			if(this.settings.checkbox.tie_selection) { return this.get_bottom_selected(full); }
			var tmp = this.get_checked(true),
				obj = [], i, j;
			for(i = 0, j = tmp.length; i < j; i++) {
				if(!tmp[i].children.length) {
					obj.push(tmp[i].id);
				}
			}
			return full ? $.map(obj, $.proxy(function (i) { return this.get_node(i); }, this)) : obj;
		};
		this.load_node = function (obj, callback) {
			var k, l, i, j, c, tmp;
			if(!$.isArray(obj) && !this.settings.checkbox.tie_selection) {
				tmp = this.get_node(obj);
				if(tmp && tmp.state.loaded) {
					for(k = 0, l = tmp.children_d.length; k < l; k++) {
						if(this._model.data[tmp.children_d[k]].state.checked) {
							c = true;
							this._data.checkbox.selected = $.vakata.array_remove_item(this._data.checkbox.selected, tmp.children_d[k]);
						}
					}
				}
			}
			return parent.load_node.apply(this, arguments);
		};
		this.get_state = function () {
			var state = parent.get_state.apply(this, arguments);
			if(this.settings.checkbox.tie_selection) { return state; }
			state.checkbox = this._data.checkbox.selected.slice();
			return state;
		};
		this.set_state = function (state, callback) {
			var res = parent.set_state.apply(this, arguments);
			if(res && state.checkbox) {
				if(!this.settings.checkbox.tie_selection) {
					this.uncheck_all();
					var _this = this;
					$.each(state.checkbox, function (i, v) {
						_this.check_node(v);
					});
				}
				delete state.checkbox;
				this.set_state(state, callback);
				return false;
			}
			return res;
		};
		this.refresh = function (skip_loading, forget_state) {
			if(!this.settings.checkbox.tie_selection) {
				this._data.checkbox.selected = [];
			}
			return parent.refresh.apply(this, arguments);
		};
	};

	// include the checkbox plugin by default
	// $.jstree.defaults.plugins.push("checkbox");

/**
 * ### Conditionalselect plugin
 *
 * This plugin allows defining a callback to allow or deny node selection by user input (activate node method).
 */

	/**
	 * a callback (function) which is invoked in the instance's scope and receives two arguments - the node and the event that triggered the `activate_node` call. Returning false prevents working with the node, returning true allows invoking activate_node. Defaults to returning `true`.
	 * @name $.jstree.defaults.checkbox.visible
	 * @plugin checkbox
	 */
	$.jstree.defaults.conditionalselect = function () { return true; };
	$.jstree.plugins.conditionalselect = function (options, parent) {
		// own function
		this.activate_node = function (obj, e) {
			if(this.settings.conditionalselect.call(this, this.get_node(obj), e)) {
				parent.activate_node.call(this, obj, e);
			}
		};
	};


/**
 * ### Contextmenu plugin
 *
 * Shows a context menu when a node is right-clicked.
 */

	/**
	 * stores all defaults for the contextmenu plugin
	 * @name $.jstree.defaults.contextmenu
	 * @plugin contextmenu
	 */
	$.jstree.defaults.contextmenu = {
		/**
		 * a boolean indicating if the node should be selected when the context menu is invoked on it. Defaults to `true`.
		 * @name $.jstree.defaults.contextmenu.select_node
		 * @plugin contextmenu
		 */
		select_node : true,
		/**
		 * a boolean indicating if the menu should be shown aligned with the node. Defaults to `true`, otherwise the mouse coordinates are used.
		 * @name $.jstree.defaults.contextmenu.show_at_node
		 * @plugin contextmenu
		 */
		show_at_node : true,
		/**
		 * an object of actions, or a function that accepts a node and a callback function and calls the callback function with an object of actions available for that node (you can also return the items too).
		 *
		 * Each action consists of a key (a unique name) and a value which is an object with the following properties (only label and action are required). Once a menu item is activated the `action` function will be invoked with an object containing the following keys: item - the contextmenu item definition as seen below, reference - the DOM node that was used (the tree node), element - the contextmenu DOM element, position - an object with x/y properties indicating the position of the menu.
		 *
		 * * `separator_before` - a boolean indicating if there should be a separator before this item
		 * * `separator_after` - a boolean indicating if there should be a separator after this item
		 * * `_disabled` - a boolean indicating if this action should be disabled
		 * * `label` - a string - the name of the action (could be a function returning a string)
		 * * `title` - a string - an optional tooltip for the item
		 * * `action` - a function to be executed if this item is chosen, the function will receive 
		 * * `icon` - a string, can be a path to an icon or a className, if using an image that is in the current directory use a `./` prefix, otherwise it will be detected as a class
		 * * `shortcut` - keyCode which will trigger the action if the menu is open (for example `113` for rename, which equals F2)
		 * * `shortcut_label` - shortcut label (like for example `F2` for rename)
		 * * `submenu` - an object with the same structure as $.jstree.defaults.contextmenu.items which can be used to create a submenu - each key will be rendered as a separate option in a submenu that will appear once the current item is hovered
		 *
		 * @name $.jstree.defaults.contextmenu.items
		 * @plugin contextmenu
		 */
		items : function (o, cb) { // Could be an object directly
			return {
				"create" : {
					"separator_before"	: false,
					"separator_after"	: true,
					"_disabled"			: false, //(this.check("create_node", data.reference, {}, "last")),
					"label"				: "Create",
					"action"			: function (data) {
						var inst = $.jstree.reference(data.reference),
							obj = inst.get_node(data.reference);
						inst.create_node(obj, {}, "last", function (new_node) {
							setTimeout(function () { inst.edit(new_node); },0);
						});
					}
				},
				"rename" : {
					"separator_before"	: false,
					"separator_after"	: false,
					"_disabled"			: false, //(this.check("rename_node", data.reference, this.get_parent(data.reference), "")),
					"label"				: "Rename",
					/*!
					"shortcut"			: 113,
					"shortcut_label"	: 'F2',
					"icon"				: "glyphicon glyphicon-leaf",
					*/
					"action"			: function (data) {
						var inst = $.jstree.reference(data.reference),
							obj = inst.get_node(data.reference);
						inst.edit(obj);
					}
				},
				"remove" : {
					"separator_before"	: false,
					"icon"				: false,
					"separator_after"	: false,
					"_disabled"			: false, //(this.check("delete_node", data.reference, this.get_parent(data.reference), "")),
					"label"				: "Delete",
					"action"			: function (data) {
						var inst = $.jstree.reference(data.reference),
							obj = inst.get_node(data.reference);
						if(inst.is_selected(obj)) {
							inst.delete_node(inst.get_selected());
						}
						else {
							inst.delete_node(obj);
						}
					}
				},
				"ccp" : {
					"separator_before"	: true,
					"icon"				: false,
					"separator_after"	: false,
					"label"				: "Edit",
					"action"			: false,
					"submenu" : {
						"cut" : {
							"separator_before"	: false,
							"separator_after"	: false,
							"label"				: "Cut",
							"action"			: function (data) {
								var inst = $.jstree.reference(data.reference),
									obj = inst.get_node(data.reference);
								if(inst.is_selected(obj)) {
									inst.cut(inst.get_top_selected());
								}
								else {
									inst.cut(obj);
								}
							}
						},
						"copy" : {
							"separator_before"	: false,
							"icon"				: false,
							"separator_after"	: false,
							"label"				: "Copy",
							"action"			: function (data) {
								var inst = $.jstree.reference(data.reference),
									obj = inst.get_node(data.reference);
								if(inst.is_selected(obj)) {
									inst.copy(inst.get_top_selected());
								}
								else {
									inst.copy(obj);
								}
							}
						},
						"paste" : {
							"separator_before"	: false,
							"icon"				: false,
							"_disabled"			: function (data) {
								return !$.jstree.reference(data.reference).can_paste();
							},
							"separator_after"	: false,
							"label"				: "Paste",
							"action"			: function (data) {
								var inst = $.jstree.reference(data.reference),
									obj = inst.get_node(data.reference);
								inst.paste(obj);
							}
						}
					}
				}
			};
		}
	};

	$.jstree.plugins.contextmenu = function (options, parent) {
		this.bind = function () {
			parent.bind.call(this);

			var last_ts = 0, cto = null, ex, ey;
			this.element
				.on("contextmenu.jstree", ".jstree-anchor", $.proxy(function (e, data) {
						if (e.target.tagName.toLowerCase() === 'input') {
							return;
						}
						e.preventDefault();
						last_ts = e.ctrlKey ? +new Date() : 0;
						if(data || cto) {
							last_ts = (+new Date()) + 10000;
						}
						if(cto) {
							clearTimeout(cto);
						}
						if(!this.is_loading(e.currentTarget)) {
							this.show_contextmenu(e.currentTarget, e.pageX, e.pageY, e);
						}
					}, this))
				.on("click.jstree", ".jstree-anchor", $.proxy(function (e) {
						if(this._data.contextmenu.visible && (!last_ts || (+new Date()) - last_ts > 250)) { // work around safari & macOS ctrl+click
							$.vakata.context.hide();
						}
						last_ts = 0;
					}, this))
				.on("touchstart.jstree", ".jstree-anchor", function (e) {
						if(!e.originalEvent || !e.originalEvent.changedTouches || !e.originalEvent.changedTouches[0]) {
							return;
						}
						ex = e.originalEvent.changedTouches[0].clientX;
						ey = e.originalEvent.changedTouches[0].clientY;
						cto = setTimeout(function () {
							$(e.currentTarget).trigger('contextmenu', true);
						}, 750);
					})
				.on('touchmove.vakata.jstree', function (e) {
						if(cto && e.originalEvent && e.originalEvent.changedTouches && e.originalEvent.changedTouches[0] && (Math.abs(ex - e.originalEvent.changedTouches[0].clientX) > 50 || Math.abs(ey - e.originalEvent.changedTouches[0].clientY) > 50)) {
							clearTimeout(cto);
						}
					})
				.on('touchend.vakata.jstree', function (e) {
						if(cto) {
							clearTimeout(cto);
						}
					});

			/*!
			if(!('oncontextmenu' in document.body) && ('ontouchstart' in document.body)) {
				var el = null, tm = null;
				this.element
					.on("touchstart", ".jstree-anchor", function (e) {
						el = e.currentTarget;
						tm = +new Date();
						$(document).one("touchend", function (e) {
							e.target = document.elementFromPoint(e.originalEvent.targetTouches[0].pageX - window.pageXOffset, e.originalEvent.targetTouches[0].pageY - window.pageYOffset);
							e.currentTarget = e.target;
							tm = ((+(new Date())) - tm);
							if(e.target === el && tm > 600 && tm < 1000) {
								e.preventDefault();
								$(el).trigger('contextmenu', e);
							}
							el = null;
							tm = null;
						});
					});
			}
			*/
			$(document).on("context_hide.vakata.jstree", $.proxy(function (e, data) {
				this._data.contextmenu.visible = false;
				$(data.reference).removeClass('jstree-context');
			}, this));
		};
		this.teardown = function () {
			if(this._data.contextmenu.visible) {
				$.vakata.context.hide();
			}
			parent.teardown.call(this);
		};

		/**
		 * prepare and show the context menu for a node
		 * @name show_contextmenu(obj [, x, y])
		 * @param {mixed} obj the node
		 * @param {Number} x the x-coordinate relative to the document to show the menu at
		 * @param {Number} y the y-coordinate relative to the document to show the menu at
		 * @param {Object} e the event if available that triggered the contextmenu
		 * @plugin contextmenu
		 * @trigger show_contextmenu.jstree
		 */
		this.show_contextmenu = function (obj, x, y, e) {
			obj = this.get_node(obj);
			if(!obj || obj.id === $.jstree.root) { return false; }
			var s = this.settings.contextmenu,
				d = this.get_node(obj, true),
				a = d.children(".jstree-anchor"),
				o = false,
				i = false;
			if(s.show_at_node || x === undefined || y === undefined) {
				o = a.offset();
				x = o.left;
				y = o.top + this._data.core.li_height;
			}
			if(this.settings.contextmenu.select_node && !this.is_selected(obj)) {
				this.activate_node(obj, e);
			}

			i = s.items;
			if($.isFunction(i)) {
				i = i.call(this, obj, $.proxy(function (i) {
					this._show_contextmenu(obj, x, y, i);
				}, this));
			}
			if($.isPlainObject(i)) {
				this._show_contextmenu(obj, x, y, i);
			}
		};
		/**
		 * show the prepared context menu for a node
		 * @name _show_contextmenu(obj, x, y, i)
		 * @param {mixed} obj the node
		 * @param {Number} x the x-coordinate relative to the document to show the menu at
		 * @param {Number} y the y-coordinate relative to the document to show the menu at
		 * @param {Number} i the object of items to show
		 * @plugin contextmenu
		 * @trigger show_contextmenu.jstree
		 * @private
		 */
		this._show_contextmenu = function (obj, x, y, i) {
			var d = this.get_node(obj, true),
				a = d.children(".jstree-anchor");
			$(document).one("context_show.vakata.jstree", $.proxy(function (e, data) {
				var cls = 'jstree-contextmenu jstree-' + this.get_theme() + '-contextmenu';
				$(data.element).addClass(cls);
				a.addClass('jstree-context');
			}, this));
			this._data.contextmenu.visible = true;
			$.vakata.context.show(a, { 'x' : x, 'y' : y }, i);
			/**
			 * triggered when the contextmenu is shown for a node
			 * @event
			 * @name show_contextmenu.jstree
			 * @param {Object} node the node
			 * @param {Number} x the x-coordinate of the menu relative to the document
			 * @param {Number} y the y-coordinate of the menu relative to the document
			 * @plugin contextmenu
			 */
			this.trigger('show_contextmenu', { "node" : obj, "x" : x, "y" : y });
		};
	};

	// contextmenu helper
	(function ($) {
		var right_to_left = false,
			vakata_context = {
				element		: false,
				reference	: false,
				position_x	: 0,
				position_y	: 0,
				items		: [],
				html		: "",
				is_visible	: false
			};

		$.vakata.context = {
			settings : {
				hide_onmouseleave	: 0,
				icons				: true
			},
			_trigger : function (event_name) {
				$(document).triggerHandler("context_" + event_name + ".vakata", {
					"reference"	: vakata_context.reference,
					"element"	: vakata_context.element,
					"position"	: {
						"x" : vakata_context.position_x,
						"y" : vakata_context.position_y
					}
				});
			},
			_execute : function (i) {
				i = vakata_context.items[i];
				return i && (!i._disabled || ($.isFunction(i._disabled) && !i._disabled({ "item" : i, "reference" : vakata_context.reference, "element" : vakata_context.element }))) && i.action ? i.action.call(null, {
							"item"		: i,
							"reference"	: vakata_context.reference,
							"element"	: vakata_context.element,
							"position"	: {
								"x" : vakata_context.position_x,
								"y" : vakata_context.position_y
							}
						}) : false;
			},
			_parse : function (o, is_callback) {
				if(!o) { return false; }
				if(!is_callback) {
					vakata_context.html		= "";
					vakata_context.items	= [];
				}
				var str = "",
					sep = false,
					tmp;

				if(is_callback) { str += "<"+"ul>"; }
				$.each(o, function (i, val) {
					if(!val) { return true; }
					vakata_context.items.push(val);
					if(!sep && val.separator_before) {
						str += "<"+"li class='vakata-context-separator'><"+"a href='#' " + ($.vakata.context.settings.icons ? '' : 'style="margin-left:0px;"') + ">&#160;<"+"/a><"+"/li>";
					}
					sep = false;
					str += "<"+"li class='" + (val._class || "") + (val._disabled === true || ($.isFunction(val._disabled) && val._disabled({ "item" : val, "reference" : vakata_context.reference, "element" : vakata_context.element })) ? " vakata-contextmenu-disabled " : "") + "' "+(val.shortcut?" data-shortcut='"+val.shortcut+"' ":'')+">";
					str += "<"+"a href='#' rel='" + (vakata_context.items.length - 1) + "' " + (val.title ? "title='" + val.title + "'" : "") + ">";
					if($.vakata.context.settings.icons) {
						str += "<"+"i ";
						if(val.icon) {
							if(val.icon.indexOf("/") !== -1 || val.icon.indexOf(".") !== -1) { str += " style='background:url(\"" + val.icon + "\") center center no-repeat' "; }
							else { str += " class='" + val.icon + "' "; }
						}
						str += "><"+"/i><"+"span class='vakata-contextmenu-sep'>&#160;<"+"/span>";
					}
					str += ($.isFunction(val.label) ? val.label({ "item" : i, "reference" : vakata_context.reference, "element" : vakata_context.element }) : val.label) + (val.shortcut?' <span class="vakata-contextmenu-shortcut vakata-contextmenu-shortcut-'+val.shortcut+'">'+ (val.shortcut_label || '') +'</span>':'') + "<"+"/a>";
					if(val.submenu) {
						tmp = $.vakata.context._parse(val.submenu, true);
						if(tmp) { str += tmp; }
					}
					str += "<"+"/li>";
					if(val.separator_after) {
						str += "<"+"li class='vakata-context-separator'><"+"a href='#' " + ($.vakata.context.settings.icons ? '' : 'style="margin-left:0px;"') + ">&#160;<"+"/a><"+"/li>";
						sep = true;
					}
				});
				str  = str.replace(/<li class\='vakata-context-separator'\><\/li\>$/,"");
				if(is_callback) { str += "</ul>"; }
				/**
				 * triggered on the document when the contextmenu is parsed (HTML is built)
				 * @event
				 * @plugin contextmenu
				 * @name context_parse.vakata
				 * @param {jQuery} reference the element that was right clicked
				 * @param {jQuery} element the DOM element of the menu itself
				 * @param {Object} position the x & y coordinates of the menu
				 */
				if(!is_callback) { vakata_context.html = str; $.vakata.context._trigger("parse"); }
				return str.length > 10 ? str : false;
			},
			_show_submenu : function (o) {
				o = $(o);
				if(!o.length || !o.children("ul").length) { return; }
				var e = o.children("ul"),
					xl = o.offset().left,
					x = xl + o.outerWidth(),
					y = o.offset().top,
					w = e.width(),
					h = e.height(),
					dw = $(window).width() + $(window).scrollLeft(),
					dh = $(window).height() + $(window).scrollTop();
				// може да се спести е една проверка - дали няма някой от класовете вече нагоре
				if(right_to_left) {
					o[x - (w + 10 + o.outerWidth()) < 0 ? "addClass" : "removeClass"]("vakata-context-left");
				}
				else {
					o[x + w > dw  && xl > dw - x ? "addClass" : "removeClass"]("vakata-context-right");
				}
				if(y + h + 10 > dh) {
					e.css("bottom","-1px");
				}

				//if does not fit - stick it to the side
				if (o.hasClass('vakata-context-right')) {
					if (xl < w) {
						e.css("margin-right", xl - w);
					}
				} else {
					if (dw - x < w) {
						e.css("margin-left", dw - x - w);
					}
				}

				e.show();
			},
			show : function (reference, position, data) {
				var o, e, x, y, w, h, dw, dh, cond = true;
				if(vakata_context.element && vakata_context.element.length) {
					vakata_context.element.width('');
				}
				switch(cond) {
					case (!position && !reference):
						return false;
					case (!!position && !!reference):
						vakata_context.reference	= reference;
						vakata_context.position_x	= position.x;
						vakata_context.position_y	= position.y;
						break;
					case (!position && !!reference):
						vakata_context.reference	= reference;
						o = reference.offset();
						vakata_context.position_x	= o.left + reference.outerHeight();
						vakata_context.position_y	= o.top;
						break;
					case (!!position && !reference):
						vakata_context.position_x	= position.x;
						vakata_context.position_y	= position.y;
						break;
				}
				if(!!reference && !data && $(reference).data('vakata_contextmenu')) {
					data = $(reference).data('vakata_contextmenu');
				}
				if($.vakata.context._parse(data)) {
					vakata_context.element.html(vakata_context.html);
				}
				if(vakata_context.items.length) {
					vakata_context.element.appendTo("body");
					e = vakata_context.element;
					x = vakata_context.position_x;
					y = vakata_context.position_y;
					w = e.width();
					h = e.height();
					dw = $(window).width() + $(window).scrollLeft();
					dh = $(window).height() + $(window).scrollTop();
					if(right_to_left) {
						x -= (e.outerWidth() - $(reference).outerWidth());
						if(x < $(window).scrollLeft() + 20) {
							x = $(window).scrollLeft() + 20;
						}
					}
					if(x + w + 20 > dw) {
						x = dw - (w + 20);
					}
					if(y + h + 20 > dh) {
						y = dh - (h + 20);
					}

					vakata_context.element
						.css({ "left" : x, "top" : y })
						.show()
						.find('a').first().focus().parent().addClass("vakata-context-hover");
					vakata_context.is_visible = true;
					/**
					 * triggered on the document when the contextmenu is shown
					 * @event
					 * @plugin contextmenu
					 * @name context_show.vakata
					 * @param {jQuery} reference the element that was right clicked
					 * @param {jQuery} element the DOM element of the menu itself
					 * @param {Object} position the x & y coordinates of the menu
					 */
					$.vakata.context._trigger("show");
				}
			},
			hide : function () {
				if(vakata_context.is_visible) {
					vakata_context.element.hide().find("ul").hide().end().find(':focus').blur().end().detach();
					vakata_context.is_visible = false;
					/**
					 * triggered on the document when the contextmenu is hidden
					 * @event
					 * @plugin contextmenu
					 * @name context_hide.vakata
					 * @param {jQuery} reference the element that was right clicked
					 * @param {jQuery} element the DOM element of the menu itself
					 * @param {Object} position the x & y coordinates of the menu
					 */
					$.vakata.context._trigger("hide");
				}
			}
		};
		$(function () {
			right_to_left = $("body").css("direction") === "rtl";
			var to = false;

			vakata_context.element = $("<ul class='vakata-context'></ul>");
			vakata_context.element
				.on("mouseenter", "li", function (e) {
					e.stopImmediatePropagation();

					if($.contains(this, e.relatedTarget)) {
						// премахнато заради delegate mouseleave по-долу
						// $(this).find(".vakata-context-hover").removeClass("vakata-context-hover");
						return;
					}

					if(to) { clearTimeout(to); }
					vakata_context.element.find(".vakata-context-hover").removeClass("vakata-context-hover").end();

					$(this)
						.siblings().find("ul").hide().end().end()
						.parentsUntil(".vakata-context", "li").addBack().addClass("vakata-context-hover");
					$.vakata.context._show_submenu(this);
				})
				// тестово - дали не натоварва?
				.on("mouseleave", "li", function (e) {
					if($.contains(this, e.relatedTarget)) { return; }
					$(this).find(".vakata-context-hover").addBack().removeClass("vakata-context-hover");
				})
				.on("mouseleave", function (e) {
					$(this).find(".vakata-context-hover").removeClass("vakata-context-hover");
					if($.vakata.context.settings.hide_onmouseleave) {
						to = setTimeout(
							(function (t) {
								return function () { $.vakata.context.hide(); };
							}(this)), $.vakata.context.settings.hide_onmouseleave);
					}
				})
				.on("click", "a", function (e) {
					e.preventDefault();
				//})
				//.on("mouseup", "a", function (e) {
					if(!$(this).blur().parent().hasClass("vakata-context-disabled") && $.vakata.context._execute($(this).attr("rel")) !== false) {
						$.vakata.context.hide();
					}
				})
				.on('keydown', 'a', function (e) {
						var o = null;
						switch(e.which) {
							case 13:
							case 32:
								e.type = "click";
								e.preventDefault();
								$(e.currentTarget).trigger(e);
								break;
							case 37:
								if(vakata_context.is_visible) {
									vakata_context.element.find(".vakata-context-hover").last().closest("li").first().find("ul").hide().find(".vakata-context-hover").removeClass("vakata-context-hover").end().end().children('a').focus();
									e.stopImmediatePropagation();
									e.preventDefault();
								}
								break;
							case 38:
								if(vakata_context.is_visible) {
									o = vakata_context.element.find("ul:visible").addBack().last().children(".vakata-context-hover").removeClass("vakata-context-hover").prevAll("li:not(.vakata-context-separator)").first();
									if(!o.length) { o = vakata_context.element.find("ul:visible").addBack().last().children("li:not(.vakata-context-separator)").last(); }
									o.addClass("vakata-context-hover").children('a').focus();
									e.stopImmediatePropagation();
									e.preventDefault();
								}
								break;
							case 39:
								if(vakata_context.is_visible) {
									vakata_context.element.find(".vakata-context-hover").last().children("ul").show().children("li:not(.vakata-context-separator)").removeClass("vakata-context-hover").first().addClass("vakata-context-hover").children('a').focus();
									e.stopImmediatePropagation();
									e.preventDefault();
								}
								break;
							case 40:
								if(vakata_context.is_visible) {
									o = vakata_context.element.find("ul:visible").addBack().last().children(".vakata-context-hover").removeClass("vakata-context-hover").nextAll("li:not(.vakata-context-separator)").first();
									if(!o.length) { o = vakata_context.element.find("ul:visible").addBack().last().children("li:not(.vakata-context-separator)").first(); }
									o.addClass("vakata-context-hover").children('a').focus();
									e.stopImmediatePropagation();
									e.preventDefault();
								}
								break;
							case 27:
								$.vakata.context.hide();
								e.preventDefault();
								break;
							default:
								//console.log(e.which);
								break;
						}
					})
				.on('keydown', function (e) {
					e.preventDefault();
					var a = vakata_context.element.find('.vakata-contextmenu-shortcut-' + e.which).parent();
					if(a.parent().not('.vakata-context-disabled')) {
						a.click();
					}
				});

			$(document)
				.on("mousedown.vakata.jstree", function (e) {
					if(vakata_context.is_visible && !$.contains(vakata_context.element[0], e.target)) {
						$.vakata.context.hide();
					}
				})
				.on("context_show.vakata.jstree", function (e, data) {
					vakata_context.element.find("li:has(ul)").children("a").addClass("vakata-context-parent");
					if(right_to_left) {
						vakata_context.element.addClass("vakata-context-rtl").css("direction", "rtl");
					}
					// also apply a RTL class?
					vakata_context.element.find("ul").hide().end();
				});
		});
	}($));
	// $.jstree.defaults.plugins.push("contextmenu");


/**
 * ### Drag'n'drop plugin
 *
 * Enables dragging and dropping of nodes in the tree, resulting in a move or copy operations.
 */

	/**
	 * stores all defaults for the drag'n'drop plugin
	 * @name $.jstree.defaults.dnd
	 * @plugin dnd
	 */
	$.jstree.defaults.dnd = {
		/**
		 * a boolean indicating if a copy should be possible while dragging (by pressint the meta key or Ctrl). Defaults to `true`.
		 * @name $.jstree.defaults.dnd.copy
		 * @plugin dnd
		 */
		copy : true,
		/**
		 * a number indicating how long a node should remain hovered while dragging to be opened. Defaults to `500`.
		 * @name $.jstree.defaults.dnd.open_timeout
		 * @plugin dnd
		 */
		open_timeout : 500,
		/**
		 * a function invoked each time a node is about to be dragged, invoked in the tree's scope and receives the nodes about to be dragged as an argument (array) and the event that started the drag - return `false` to prevent dragging
		 * @name $.jstree.defaults.dnd.is_draggable
		 * @plugin dnd
		 */
		is_draggable : true,
		/**
		 * a boolean indicating if checks should constantly be made while the user is dragging the node (as opposed to checking only on drop), default is `true`
		 * @name $.jstree.defaults.dnd.check_while_dragging
		 * @plugin dnd
		 */
		check_while_dragging : true,
		/**
		 * a boolean indicating if nodes from this tree should only be copied with dnd (as opposed to moved), default is `false`
		 * @name $.jstree.defaults.dnd.always_copy
		 * @plugin dnd
		 */
		always_copy : false,
		/**
		 * when dropping a node "inside", this setting indicates the position the node should go to - it can be an integer or a string: "first" (same as 0) or "last", default is `0`
		 * @name $.jstree.defaults.dnd.inside_pos
		 * @plugin dnd
		 */
		inside_pos : 0,
		/**
		 * when starting the drag on a node that is selected this setting controls if all selected nodes are dragged or only the single node, default is `true`, which means all selected nodes are dragged when the drag is started on a selected node
		 * @name $.jstree.defaults.dnd.drag_selection
		 * @plugin dnd
		 */
		drag_selection : true,
		/**
		 * controls whether dnd works on touch devices. If left as boolean true dnd will work the same as in desktop browsers, which in some cases may impair scrolling. If set to boolean false dnd will not work on touch devices. There is a special third option - string "selected" which means only selected nodes can be dragged on touch devices.
		 * @name $.jstree.defaults.dnd.touch
		 * @plugin dnd
		 */
		touch : true,
		/**
		 * controls whether items can be dropped anywhere on the node, not just on the anchor, by default only the node anchor is a valid drop target. Works best with the wholerow plugin. If enabled on mobile depending on the interface it might be hard for the user to cancel the drop, since the whole tree container will be a valid drop target.
		 * @name $.jstree.defaults.dnd.large_drop_target
		 * @plugin dnd
		 */
		large_drop_target : false,
		/**
		 * controls whether a drag can be initiated from any part of the node and not just the text/icon part, works best with the wholerow plugin. Keep in mind it can cause problems with tree scrolling on mobile depending on the interface - in that case set the touch option to "selected".
		 * @name $.jstree.defaults.dnd.large_drag_target
		 * @plugin dnd
		 */
		large_drag_target : false,
		/**
		 * controls whether use HTML5 dnd api instead of classical. That will allow better integration of dnd events with other HTML5 controls.
		 * @reference http://caniuse.com/#feat=dragndrop
		 * @name $.jstree.defaults.dnd.use_html5
		 * @plugin dnd
		 */
		use_html5: false
	};
	var drg, elm;
	// TODO: now check works by checking for each node individually, how about max_children, unique, etc?
	$.jstree.plugins.dnd = function (options, parent) {
		this.init = function (el, options) {
			parent.init.call(this, el, options);
			this.settings.dnd.use_html5 = this.settings.dnd.use_html5 && ('draggable' in document.createElement('span'));
		};
		this.bind = function () {
			parent.bind.call(this);

			this.element
				.on(this.settings.dnd.use_html5 ? 'dragstart.jstree' : 'mousedown.jstree touchstart.jstree', this.settings.dnd.large_drag_target ? '.jstree-node' : '.jstree-anchor', $.proxy(function (e) {
						if(this.settings.dnd.large_drag_target && $(e.target).closest('.jstree-node')[0] !== e.currentTarget) {
							return true;
						}
						if(e.type === "touchstart" && (!this.settings.dnd.touch || (this.settings.dnd.touch === 'selected' && !$(e.currentTarget).closest('.jstree-node').children('.jstree-anchor').hasClass('jstree-clicked')))) {
							return true;
						}
						var obj = this.get_node(e.target),
							mlt = this.is_selected(obj) && this.settings.dnd.drag_selection ? this.get_top_selected().length : 1,
							txt = (mlt > 1 ? mlt + ' ' + this.get_string('nodes') : this.get_text(e.currentTarget));
						if(this.settings.core.force_text) {
							txt = $.vakata.html.escape(txt);
						}
						if(obj && obj.id && obj.id !== $.jstree.root && (e.which === 1 || e.type === "touchstart" || e.type === "dragstart") &&
							(this.settings.dnd.is_draggable === true || ($.isFunction(this.settings.dnd.is_draggable) && this.settings.dnd.is_draggable.call(this, (mlt > 1 ? this.get_top_selected(true) : [obj]), e)))
						) {
							drg = { 'jstree' : true, 'origin' : this, 'obj' : this.get_node(obj,true), 'nodes' : mlt > 1 ? this.get_top_selected() : [obj.id] };
							elm = e.currentTarget;
							if (this.settings.dnd.use_html5) {
								$.vakata.dnd._trigger('start', e, { 'helper': $(), 'element': elm, 'data': drg });
							} else {
								this.element.trigger('mousedown.jstree');
								return $.vakata.dnd.start(e, drg, '<div id="jstree-dnd" class="jstree-' + this.get_theme() + ' jstree-' + this.get_theme() + '-' + this.get_theme_variant() + ' ' + ( this.settings.core.themes.responsive ? ' jstree-dnd-responsive' : '' ) + '"><i class="jstree-icon jstree-er"></i>' + txt + '<ins class="jstree-copy" style="display:none;">+</ins></div>');
							}
						}
					}, this));
			if (this.settings.dnd.use_html5) {
				this.element
					.on('dragover.jstree', function (e) {
							e.preventDefault();
							$.vakata.dnd._trigger('move', e, { 'helper': $(), 'element': elm, 'data': drg });
							return false;
						})
					//.on('dragenter.jstree', this.settings.dnd.large_drop_target ? '.jstree-node' : '.jstree-anchor', $.proxy(function (e) {
					//		e.preventDefault();
					//		$.vakata.dnd._trigger('move', e, { 'helper': $(), 'element': elm, 'data': drg });
					//		return false;
					//	}, this))
					.on('drop.jstree', $.proxy(function (e) {
							e.preventDefault();
							$.vakata.dnd._trigger('stop', e, { 'helper': $(), 'element': elm, 'data': drg });
							return false;
						}, this));
			}
		};
		this.redraw_node = function(obj, deep, callback, force_render) {
			obj = parent.redraw_node.apply(this, arguments);
			if (obj && this.settings.dnd.use_html5) {
				if (this.settings.dnd.large_drag_target) {
					obj.setAttribute('draggable', true);
				} else {
					var i, j, tmp = null;
					for(i = 0, j = obj.childNodes.length; i < j; i++) {
						if(obj.childNodes[i] && obj.childNodes[i].className && obj.childNodes[i].className.indexOf("jstree-anchor") !== -1) {
							tmp = obj.childNodes[i];
							break;
						}
					}
					if(tmp) {
						tmp.setAttribute('draggable', true);
					}
				}
			}
			return obj;
		};
	};

	$(function() {
		// bind only once for all instances
		var lastmv = false,
			laster = false,
			lastev = false,
			opento = false,
			marker = $('<div id="jstree-marker">&#160;</div>').hide(); //.appendTo('body');

		$(document)
			.on('dnd_start.vakata.jstree', function (e, data) {
				lastmv = false;
				lastev = false;
				if(!data || !data.data || !data.data.jstree) { return; }
				marker.appendTo('body'); //.show();
			})
			.on('dnd_move.vakata.jstree', function (e, data) {
				if(opento) {
					if (!data.event || data.event.type !== 'dragover' || data.event.target !== lastev.target) {
						clearTimeout(opento);
					}
				}
				if(!data || !data.data || !data.data.jstree) { return; }

				// if we are hovering the marker image do nothing (can happen on "inside" drags)
				if(data.event.target.id && data.event.target.id === 'jstree-marker') {
					return;
				}
				lastev = data.event;

				var ins = $.jstree.reference(data.event.target),
					ref = false,
					off = false,
					rel = false,
					tmp, l, t, h, p, i, o, ok, t1, t2, op, ps, pr, ip, tm, is_copy, pn;
				// if we are over an instance
				if(ins && ins._data && ins._data.dnd) {
					marker.attr('class', 'jstree-' + ins.get_theme() + ( ins.settings.core.themes.responsive ? ' jstree-dnd-responsive' : '' ));
					is_copy = data.data.origin && (data.data.origin.settings.dnd.always_copy || (data.data.origin.settings.dnd.copy && (data.event.metaKey || data.event.ctrlKey)));
					data.helper
						.children().attr('class', 'jstree-' + ins.get_theme() + ' jstree-' + ins.get_theme() + '-' + ins.get_theme_variant() + ' ' + ( ins.settings.core.themes.responsive ? ' jstree-dnd-responsive' : '' ))
						.find('.jstree-copy').first()[ is_copy ? 'show' : 'hide' ]();

					// if are hovering the container itself add a new root node
					//console.log(data.event);
					if( (data.event.target === ins.element[0] || data.event.target === ins.get_container_ul()[0]) && ins.get_container_ul().children().length === 0) {
						ok = true;
						for(t1 = 0, t2 = data.data.nodes.length; t1 < t2; t1++) {
							ok = ok && ins.check( (data.data.origin && (data.data.origin.settings.dnd.always_copy || (data.data.origin.settings.dnd.copy && (data.event.metaKey || data.event.ctrlKey)) ) ? "copy_node" : "move_node"), (data.data.origin && data.data.origin !== ins ? data.data.origin.get_node(data.data.nodes[t1]) : data.data.nodes[t1]), $.jstree.root, 'last', { 'dnd' : true, 'ref' : ins.get_node($.jstree.root), 'pos' : 'i', 'origin' : data.data.origin, 'is_multi' : (data.data.origin && data.data.origin !== ins), 'is_foreign' : (!data.data.origin) });
							if(!ok) { break; }
						}
						if(ok) {
							lastmv = { 'ins' : ins, 'par' : $.jstree.root, 'pos' : 'last' };
							marker.hide();
							data.helper.find('.jstree-icon').first().removeClass('jstree-er').addClass('jstree-ok');
							if (data.event.originalEvent && data.event.originalEvent.dataTransfer) {
								data.event.originalEvent.dataTransfer.dropEffect = is_copy ? 'copy' : 'move';
							}
							return;
						}
					}
					else {
						// if we are hovering a tree node
						ref = ins.settings.dnd.large_drop_target ? $(data.event.target).closest('.jstree-node').children('.jstree-anchor') : $(data.event.target).closest('.jstree-anchor');
						if(ref && ref.length && ref.parent().is('.jstree-closed, .jstree-open, .jstree-leaf')) {
							off = ref.offset();
							rel = (data.event.pageY !== undefined ? data.event.pageY : data.event.originalEvent.pageY) - off.top;
							h = ref.outerHeight();
							if(rel < h / 3) {
								o = ['b', 'i', 'a'];
							}
							else if(rel > h - h / 3) {
								o = ['a', 'i', 'b'];
							}
							else {
								o = rel > h / 2 ? ['i', 'a', 'b'] : ['i', 'b', 'a'];
							}
							$.each(o, function (j, v) {
								switch(v) {
									case 'b':
										l = off.left - 6;
										t = off.top;
										p = ins.get_parent(ref);
										i = ref.parent().index();
										break;
									case 'i':
										ip = ins.settings.dnd.inside_pos;
										tm = ins.get_node(ref.parent());
										l = off.left - 2;
										t = off.top + h / 2 + 1;
										p = tm.id;
										i = ip === 'first' ? 0 : (ip === 'last' ? tm.children.length : Math.min(ip, tm.children.length));
										break;
									case 'a':
										l = off.left - 6;
										t = off.top + h;
										p = ins.get_parent(ref);
										i = ref.parent().index() + 1;
										break;
								}
								ok = true;
								for(t1 = 0, t2 = data.data.nodes.length; t1 < t2; t1++) {
									op = data.data.origin && (data.data.origin.settings.dnd.always_copy || (data.data.origin.settings.dnd.copy && (data.event.metaKey || data.event.ctrlKey))) ? "copy_node" : "move_node";
									ps = i;
									if(op === "move_node" && v === 'a' && (data.data.origin && data.data.origin === ins) && p === ins.get_parent(data.data.nodes[t1])) {
										pr = ins.get_node(p);
										if(ps > $.inArray(data.data.nodes[t1], pr.children)) {
											ps -= 1;
										}
									}
									ok = ok && ( (ins && ins.settings && ins.settings.dnd && ins.settings.dnd.check_while_dragging === false) || ins.check(op, (data.data.origin && data.data.origin !== ins ? data.data.origin.get_node(data.data.nodes[t1]) : data.data.nodes[t1]), p, ps, { 'dnd' : true, 'ref' : ins.get_node(ref.parent()), 'pos' : v, 'origin' : data.data.origin, 'is_multi' : (data.data.origin && data.data.origin !== ins), 'is_foreign' : (!data.data.origin) }) );
									if(!ok) {
										if(ins && ins.last_error) { laster = ins.last_error(); }
										break;
									}
								}
								if(v === 'i' && ref.parent().is('.jstree-closed') && ins.settings.dnd.open_timeout) {
									opento = setTimeout((function (x, z) { return function () { x.open_node(z); }; }(ins, ref)), ins.settings.dnd.open_timeout);
								}
								if(ok) {
									pn = ins.get_node(p, true);
									if (!pn.hasClass('.jstree-dnd-parent')) {
										$('.jstree-dnd-parent').removeClass('jstree-dnd-parent');
										pn.addClass('jstree-dnd-parent');
									}
									lastmv = { 'ins' : ins, 'par' : p, 'pos' : v === 'i' && ip === 'last' && i === 0 && !ins.is_loaded(tm) ? 'last' : i };
									marker.css({ 'left' : l + 'px', 'top' : t + 'px' }).show();
									data.helper.find('.jstree-icon').first().removeClass('jstree-er').addClass('jstree-ok');
									if (data.event.originalEvent && data.event.originalEvent.dataTransfer) {
										data.event.originalEvent.dataTransfer.dropEffect = is_copy ? 'copy' : 'move';
									}
									laster = {};
									o = true;
									return false;
								}
							});
							if(o === true) { return; }
						}
					}
				}
				$('.jstree-dnd-parent').removeClass('jstree-dnd-parent');
				lastmv = false;
				data.helper.find('.jstree-icon').removeClass('jstree-ok').addClass('jstree-er');
				if (data.event.originalEvent && data.event.originalEvent.dataTransfer) {
					data.event.originalEvent.dataTransfer.dropEffect = 'none';
				}
				marker.hide();
			})
			.on('dnd_scroll.vakata.jstree', function (e, data) {
				if(!data || !data.data || !data.data.jstree) { return; }
				marker.hide();
				lastmv = false;
				lastev = false;
				data.helper.find('.jstree-icon').first().removeClass('jstree-ok').addClass('jstree-er');
			})
			.on('dnd_stop.vakata.jstree', function (e, data) {
				$('.jstree-dnd-parent').removeClass('jstree-dnd-parent');
				if(opento) { clearTimeout(opento); }
				if(!data || !data.data || !data.data.jstree) { return; }
				marker.hide().detach();
				var i, j, nodes = [];
				if(lastmv) {
					for(i = 0, j = data.data.nodes.length; i < j; i++) {
						nodes[i] = data.data.origin ? data.data.origin.get_node(data.data.nodes[i]) : data.data.nodes[i];
					}
					lastmv.ins[ data.data.origin && (data.data.origin.settings.dnd.always_copy || (data.data.origin.settings.dnd.copy && (data.event.metaKey || data.event.ctrlKey))) ? 'copy_node' : 'move_node' ](nodes, lastmv.par, lastmv.pos, false, false, false, data.data.origin);
				}
				else {
					i = $(data.event.target).closest('.jstree');
					if(i.length && laster && laster.error && laster.error === 'check') {
						i = i.jstree(true);
						if(i) {
							i.settings.core.error.call(this, laster);
						}
					}
				}
				lastev = false;
				lastmv = false;
			})
			.on('keyup.jstree keydown.jstree', function (e, data) {
				data = $.vakata.dnd._get();
				if(data && data.data && data.data.jstree) {
					if (e.type === "keyup" && e.which === 27) {
						if (opento) { clearTimeout(opento); }
						lastmv = false;
						laster = false;
						lastev = false;
						opento = false;
						marker.hide().detach();
						$.vakata.dnd._clean();
					} else {
						data.helper.find('.jstree-copy').first()[ data.data.origin && (data.data.origin.settings.dnd.always_copy || (data.data.origin.settings.dnd.copy && (e.metaKey || e.ctrlKey))) ? 'show' : 'hide' ]();
						if(lastev) {
							lastev.metaKey = e.metaKey;
							lastev.ctrlKey = e.ctrlKey;
							$.vakata.dnd._trigger('move', lastev);
						}
					}
				}
			});
	});

	// helpers
	(function ($) {
		$.vakata.html = {
			div : $('<div />'),
			escape : function (str) {
				return $.vakata.html.div.text(str).html();
			},
			strip : function (str) {
				return $.vakata.html.div.empty().append($.parseHTML(str)).text();
			}
		};
		// private variable
		var vakata_dnd = {
			element	: false,
			target	: false,
			is_down	: false,
			is_drag	: false,
			helper	: false,
			helper_w: 0,
			data	: false,
			init_x	: 0,
			init_y	: 0,
			scroll_l: 0,
			scroll_t: 0,
			scroll_e: false,
			scroll_i: false,
			is_touch: false
		};
		$.vakata.dnd = {
			settings : {
				scroll_speed		: 10,
				scroll_proximity	: 20,
				helper_left			: 5,
				helper_top			: 10,
				threshold			: 5,
				threshold_touch		: 50
			},
			_trigger : function (event_name, e, data) {
				if (data === undefined) {
					data = $.vakata.dnd._get();
				}
				data.event = e;
				$(document).triggerHandler("dnd_" + event_name + ".vakata", data);
			},
			_get : function () {
				return {
					"data"		: vakata_dnd.data,
					"element"	: vakata_dnd.element,
					"helper"	: vakata_dnd.helper
				};
			},
			_clean : function () {
				if(vakata_dnd.helper) { vakata_dnd.helper.remove(); }
				if(vakata_dnd.scroll_i) { clearInterval(vakata_dnd.scroll_i); vakata_dnd.scroll_i = false; }
				vakata_dnd = {
					element	: false,
					target	: false,
					is_down	: false,
					is_drag	: false,
					helper	: false,
					helper_w: 0,
					data	: false,
					init_x	: 0,
					init_y	: 0,
					scroll_l: 0,
					scroll_t: 0,
					scroll_e: false,
					scroll_i: false,
					is_touch: false
				};
				$(document).off("mousemove.vakata.jstree touchmove.vakata.jstree", $.vakata.dnd.drag);
				$(document).off("mouseup.vakata.jstree touchend.vakata.jstree", $.vakata.dnd.stop);
			},
			_scroll : function (init_only) {
				if(!vakata_dnd.scroll_e || (!vakata_dnd.scroll_l && !vakata_dnd.scroll_t)) {
					if(vakata_dnd.scroll_i) { clearInterval(vakata_dnd.scroll_i); vakata_dnd.scroll_i = false; }
					return false;
				}
				if(!vakata_dnd.scroll_i) {
					vakata_dnd.scroll_i = setInterval($.vakata.dnd._scroll, 100);
					return false;
				}
				if(init_only === true) { return false; }

				var i = vakata_dnd.scroll_e.scrollTop(),
					j = vakata_dnd.scroll_e.scrollLeft();
				vakata_dnd.scroll_e.scrollTop(i + vakata_dnd.scroll_t * $.vakata.dnd.settings.scroll_speed);
				vakata_dnd.scroll_e.scrollLeft(j + vakata_dnd.scroll_l * $.vakata.dnd.settings.scroll_speed);
				if(i !== vakata_dnd.scroll_e.scrollTop() || j !== vakata_dnd.scroll_e.scrollLeft()) {
					/**
					 * triggered on the document when a drag causes an element to scroll
					 * @event
					 * @plugin dnd
					 * @name dnd_scroll.vakata
					 * @param {Mixed} data any data supplied with the call to $.vakata.dnd.start
					 * @param {DOM} element the DOM element being dragged
					 * @param {jQuery} helper the helper shown next to the mouse
					 * @param {jQuery} event the element that is scrolling
					 */
					$.vakata.dnd._trigger("scroll", vakata_dnd.scroll_e);
				}
			},
			start : function (e, data, html) {
				if(e.type === "touchstart" && e.originalEvent && e.originalEvent.changedTouches && e.originalEvent.changedTouches[0]) {
					e.pageX = e.originalEvent.changedTouches[0].pageX;
					e.pageY = e.originalEvent.changedTouches[0].pageY;
					e.target = document.elementFromPoint(e.originalEvent.changedTouches[0].pageX - window.pageXOffset, e.originalEvent.changedTouches[0].pageY - window.pageYOffset);
				}
				if(vakata_dnd.is_drag) { $.vakata.dnd.stop({}); }
				try {
					e.currentTarget.unselectable = "on";
					e.currentTarget.onselectstart = function() { return false; };
					if(e.currentTarget.style) {
						e.currentTarget.style.touchAction = "none";
						e.currentTarget.style.msTouchAction = "none";
						e.currentTarget.style.MozUserSelect = "none";
					}
				} catch(ignore) { }
				vakata_dnd.init_x	= e.pageX;
				vakata_dnd.init_y	= e.pageY;
				vakata_dnd.data		= data;
				vakata_dnd.is_down	= true;
				vakata_dnd.element	= e.currentTarget;
				vakata_dnd.target	= e.target;
				vakata_dnd.is_touch	= e.type === "touchstart";
				if(html !== false) {
					vakata_dnd.helper = $("<div id='vakata-dnd'></div>").html(html).css({
						"display"		: "block",
						"margin"		: "0",
						"padding"		: "0",
						"position"		: "absolute",
						"top"			: "-2000px",
						"lineHeight"	: "16px",
						"zIndex"		: "10000"
					});
				}
				$(document).on("mousemove.vakata.jstree touchmove.vakata.jstree", $.vakata.dnd.drag);
				$(document).on("mouseup.vakata.jstree touchend.vakata.jstree", $.vakata.dnd.stop);
				return false;
			},
			drag : function (e) {
				if(e.type === "touchmove" && e.originalEvent && e.originalEvent.changedTouches && e.originalEvent.changedTouches[0]) {
					e.pageX = e.originalEvent.changedTouches[0].pageX;
					e.pageY = e.originalEvent.changedTouches[0].pageY;
					e.target = document.elementFromPoint(e.originalEvent.changedTouches[0].pageX - window.pageXOffset, e.originalEvent.changedTouches[0].pageY - window.pageYOffset);
				}
				if(!vakata_dnd.is_down) { return; }
				if(!vakata_dnd.is_drag) {
					if(
						Math.abs(e.pageX - vakata_dnd.init_x) > (vakata_dnd.is_touch ? $.vakata.dnd.settings.threshold_touch : $.vakata.dnd.settings.threshold) ||
						Math.abs(e.pageY - vakata_dnd.init_y) > (vakata_dnd.is_touch ? $.vakata.dnd.settings.threshold_touch : $.vakata.dnd.settings.threshold)
					) {
						if(vakata_dnd.helper) {
							vakata_dnd.helper.appendTo("body");
							vakata_dnd.helper_w = vakata_dnd.helper.outerWidth();
						}
						vakata_dnd.is_drag = true;
						$(vakata_dnd.target).one('click.vakata', false);
						/**
						 * triggered on the document when a drag starts
						 * @event
						 * @plugin dnd
						 * @name dnd_start.vakata
						 * @param {Mixed} data any data supplied with the call to $.vakata.dnd.start
						 * @param {DOM} element the DOM element being dragged
						 * @param {jQuery} helper the helper shown next to the mouse
						 * @param {Object} event the event that caused the start (probably mousemove)
						 */
						$.vakata.dnd._trigger("start", e);
					}
					else { return; }
				}

				var d  = false, w  = false,
					dh = false, wh = false,
					dw = false, ww = false,
					dt = false, dl = false,
					ht = false, hl = false;

				vakata_dnd.scroll_t = 0;
				vakata_dnd.scroll_l = 0;
				vakata_dnd.scroll_e = false;
				$($(e.target).parentsUntil("body").addBack().get().reverse())
					.filter(function () {
						return	(/^auto|scroll$/).test($(this).css("overflow")) &&
								(this.scrollHeight > this.offsetHeight || this.scrollWidth > this.offsetWidth);
					})
					.each(function () {
						var t = $(this), o = t.offset();
						if(this.scrollHeight > this.offsetHeight) {
							if(o.top + t.height() - e.pageY < $.vakata.dnd.settings.scroll_proximity)	{ vakata_dnd.scroll_t = 1; }
							if(e.pageY - o.top < $.vakata.dnd.settings.scroll_proximity)				{ vakata_dnd.scroll_t = -1; }
						}
						if(this.scrollWidth > this.offsetWidth) {
							if(o.left + t.width() - e.pageX < $.vakata.dnd.settings.scroll_proximity)	{ vakata_dnd.scroll_l = 1; }
							if(e.pageX - o.left < $.vakata.dnd.settings.scroll_proximity)				{ vakata_dnd.scroll_l = -1; }
						}
						if(vakata_dnd.scroll_t || vakata_dnd.scroll_l) {
							vakata_dnd.scroll_e = $(this);
							return false;
						}
					});

				if(!vakata_dnd.scroll_e) {
					d  = $(document); w = $(window);
					dh = d.height(); wh = w.height();
					dw = d.width(); ww = w.width();
					dt = d.scrollTop(); dl = d.scrollLeft();
					if(dh > wh && e.pageY - dt < $.vakata.dnd.settings.scroll_proximity)		{ vakata_dnd.scroll_t = -1;  }
					if(dh > wh && wh - (e.pageY - dt) < $.vakata.dnd.settings.scroll_proximity)	{ vakata_dnd.scroll_t = 1; }
					if(dw > ww && e.pageX - dl < $.vakata.dnd.settings.scroll_proximity)		{ vakata_dnd.scroll_l = -1; }
					if(dw > ww && ww - (e.pageX - dl) < $.vakata.dnd.settings.scroll_proximity)	{ vakata_dnd.scroll_l = 1; }
					if(vakata_dnd.scroll_t || vakata_dnd.scroll_l) {
						vakata_dnd.scroll_e = d;
					}
				}
				if(vakata_dnd.scroll_e) { $.vakata.dnd._scroll(true); }

				if(vakata_dnd.helper) {
					ht = parseInt(e.pageY + $.vakata.dnd.settings.helper_top, 10);
					hl = parseInt(e.pageX + $.vakata.dnd.settings.helper_left, 10);
					if(dh && ht + 25 > dh) { ht = dh - 50; }
					if(dw && hl + vakata_dnd.helper_w > dw) { hl = dw - (vakata_dnd.helper_w + 2); }
					vakata_dnd.helper.css({
						left	: hl + "px",
						top		: ht + "px"
					});
				}
				/**
				 * triggered on the document when a drag is in progress
				 * @event
				 * @plugin dnd
				 * @name dnd_move.vakata
				 * @param {Mixed} data any data supplied with the call to $.vakata.dnd.start
				 * @param {DOM} element the DOM element being dragged
				 * @param {jQuery} helper the helper shown next to the mouse
				 * @param {Object} event the event that caused this to trigger (most likely mousemove)
				 */
				$.vakata.dnd._trigger("move", e);
				return false;
			},
			stop : function (e) {
				if(e.type === "touchend" && e.originalEvent && e.originalEvent.changedTouches && e.originalEvent.changedTouches[0]) {
					e.pageX = e.originalEvent.changedTouches[0].pageX;
					e.pageY = e.originalEvent.changedTouches[0].pageY;
					e.target = document.elementFromPoint(e.originalEvent.changedTouches[0].pageX - window.pageXOffset, e.originalEvent.changedTouches[0].pageY - window.pageYOffset);
				}
				if(vakata_dnd.is_drag) {
					/**
					 * triggered on the document when a drag stops (the dragged element is dropped)
					 * @event
					 * @plugin dnd
					 * @name dnd_stop.vakata
					 * @param {Mixed} data any data supplied with the call to $.vakata.dnd.start
					 * @param {DOM} element the DOM element being dragged
					 * @param {jQuery} helper the helper shown next to the mouse
					 * @param {Object} event the event that caused the stop
					 */
					if (e.target !== vakata_dnd.target) {
						$(vakata_dnd.target).off('click.vakata');
					}
					$.vakata.dnd._trigger("stop", e);
				}
				else {
					if(e.type === "touchend" && e.target === vakata_dnd.target) {
						var to = setTimeout(function () { $(e.target).click(); }, 100);
						$(e.target).one('click', function() { if(to) { clearTimeout(to); } });
					}
				}
				$.vakata.dnd._clean();
				return false;
			}
		};
	}($));

	// include the dnd plugin by default
	// $.jstree.defaults.plugins.push("dnd");


/**
 * ### Massload plugin
 *
 * Adds massload functionality to jsTree, so that multiple nodes can be loaded in a single request (only useful with lazy loading).
 */

	/**
	 * massload configuration
	 *
	 * It is possible to set this to a standard jQuery-like AJAX config.
	 * In addition to the standard jQuery ajax options here you can supply functions for `data` and `url`, the functions will be run in the current instance's scope and a param will be passed indicating which node IDs need to be loaded, the return value of those functions will be used.
	 *
	 * You can also set this to a function, that function will receive the node IDs being loaded as argument and a second param which is a function (callback) which should be called with the result.
	 *
	 * Both the AJAX and the function approach rely on the same return value - an object where the keys are the node IDs, and the value is the children of that node as an array.
	 *
	 *	{
	 *		"id1" : [{ "text" : "Child of ID1", "id" : "c1" }, { "text" : "Another child of ID1", "id" : "c2" }],
	 *		"id2" : [{ "text" : "Child of ID2", "id" : "c3" }]
	 *	}
	 * 
	 * @name $.jstree.defaults.massload
	 * @plugin massload
	 */
	$.jstree.defaults.massload = null;
	$.jstree.plugins.massload = function (options, parent) {
		this.init = function (el, options) {
			this._data.massload = {};
			parent.init.call(this, el, options);
		};
		this._load_nodes = function (nodes, callback, is_callback, force_reload) {
			var s = this.settings.massload,
				nodesString = JSON.stringify(nodes),
				toLoad = [],
				m = this._model.data,
				i, j, dom;
			if (!is_callback) {
				for(i = 0, j = nodes.length; i < j; i++) {
					if(!m[nodes[i]] || ( (!m[nodes[i]].state.loaded && !m[nodes[i]].state.failed) || force_reload) ) {
						toLoad.push(nodes[i]);
						dom = this.get_node(nodes[i], true);
						if (dom && dom.length) {
							dom.addClass("jstree-loading").attr('aria-busy',true);
						}
					}
				}
				this._data.massload = {};
				if (toLoad.length) {
					if($.isFunction(s)) {
						return s.call(this, toLoad, $.proxy(function (data) {
							var i, j;
							if(data) {
								for(i in data) {
									if(data.hasOwnProperty(i)) {
										this._data.massload[i] = data[i];
									}
								}
							}
							for(i = 0, j = nodes.length; i < j; i++) {
								dom = this.get_node(nodes[i], true);
								if (dom && dom.length) {
									dom.removeClass("jstree-loading").attr('aria-busy',false);
								}
							}
							parent._load_nodes.call(this, nodes, callback, is_callback, force_reload);
						}, this));
					}
					if(typeof s === 'object' && s && s.url) {
						s = $.extend(true, {}, s);
						if($.isFunction(s.url)) {
							s.url = s.url.call(this, toLoad);
						}
						if($.isFunction(s.data)) {
							s.data = s.data.call(this, toLoad);
						}
						return $.ajax(s)
							.done($.proxy(function (data,t,x) {
									var i, j;
									if(data) {
										for(i in data) {
											if(data.hasOwnProperty(i)) {
												this._data.massload[i] = data[i];
											}
										}
									}
									for(i = 0, j = nodes.length; i < j; i++) {
										dom = this.get_node(nodes[i], true);
										if (dom && dom.length) {
											dom.removeClass("jstree-loading").attr('aria-busy',false);
										}
									}
									parent._load_nodes.call(this, nodes, callback, is_callback, force_reload);
								}, this))
							.fail($.proxy(function (f) {
									parent._load_nodes.call(this, nodes, callback, is_callback, force_reload);
								}, this));
					}
				}
			}
			return parent._load_nodes.call(this, nodes, callback, is_callback, force_reload);
		};
		this._load_node = function (obj, callback) {
			var data = this._data.massload[obj.id],
				rslt = null, dom;
			if(data) {
				rslt = this[typeof data === 'string' ? '_append_html_data' : '_append_json_data'](
					obj,
					typeof data === 'string' ? $($.parseHTML(data)).filter(function () { return this.nodeType !== 3; }) : data,
					function (status) { callback.call(this, status); }
				);
				dom = this.get_node(obj.id, true);
				if (dom && dom.length) {
					dom.removeClass("jstree-loading").attr('aria-busy',false);
				}
				delete this._data.massload[obj.id];
				return rslt;
			}
			return parent._load_node.call(this, obj, callback);
		};
	};

/**
 * ### Search plugin
 *
 * Adds search functionality to jsTree.
 */

	/**
	 * stores all defaults for the search plugin
	 * @name $.jstree.defaults.search
	 * @plugin search
	 */
	$.jstree.defaults.search = {
		/**
		 * a jQuery-like AJAX config, which jstree uses if a server should be queried for results.
		 *
		 * A `str` (which is the search string) parameter will be added with the request, an optional `inside` parameter will be added if the search is limited to a node id. The expected result is a JSON array with nodes that need to be opened so that matching nodes will be revealed.
		 * Leave this setting as `false` to not query the server. You can also set this to a function, which will be invoked in the instance's scope and receive 3 parameters - the search string, the callback to call with the array of nodes to load, and the optional node ID to limit the search to
		 * @name $.jstree.defaults.search.ajax
		 * @plugin search
		 */
		ajax : false,
		/**
		 * Indicates if the search should be fuzzy or not (should `chnd3` match `child node 3`). Default is `false`.
		 * @name $.jstree.defaults.search.fuzzy
		 * @plugin search
		 */
		fuzzy : false,
		/**
		 * Indicates if the search should be case sensitive. Default is `false`.
		 * @name $.jstree.defaults.search.case_sensitive
		 * @plugin search
		 */
		case_sensitive : false,
		/**
		 * Indicates if the tree should be filtered (by default) to show only matching nodes (keep in mind this can be a heavy on large trees in old browsers).
		 * This setting can be changed at runtime when calling the search method. Default is `false`.
		 * @name $.jstree.defaults.search.show_only_matches
		 * @plugin search
		 */
		show_only_matches : false,
		/**
		 * Indicates if the children of matched element are shown (when show_only_matches is true)
		 * This setting can be changed at runtime when calling the search method. Default is `false`.
		 * @name $.jstree.defaults.search.show_only_matches_children
		 * @plugin search
		 */
		show_only_matches_children : false,
		/**
		 * Indicates if all nodes opened to reveal the search result, should be closed when the search is cleared or a new search is performed. Default is `true`.
		 * @name $.jstree.defaults.search.close_opened_onclear
		 * @plugin search
		 */
		close_opened_onclear : true,
		/**
		 * Indicates if only leaf nodes should be included in search results. Default is `false`.
		 * @name $.jstree.defaults.search.search_leaves_only
		 * @plugin search
		 */
		search_leaves_only : false,
		/**
		 * If set to a function it wil be called in the instance's scope with two arguments - search string and node (where node will be every node in the structure, so use with caution).
		 * If the function returns a truthy value the node will be considered a match (it might not be displayed if search_only_leaves is set to true and the node is not a leaf). Default is `false`.
		 * @name $.jstree.defaults.search.search_callback
		 * @plugin search
		 */
		search_callback : false
	};

	$.jstree.plugins.search = function (options, parent) {
		this.bind = function () {
			parent.bind.call(this);

			this._data.search.str = "";
			this._data.search.dom = $();
			this._data.search.res = [];
			this._data.search.opn = [];
			this._data.search.som = false;
			this._data.search.smc = false;
			this._data.search.hdn = [];

			this.element
				.on("search.jstree", $.proxy(function (e, data) {
						if(this._data.search.som && data.res.length) {
							var m = this._model.data, i, j, p = [], k, l;
							for(i = 0, j = data.res.length; i < j; i++) {
								if(m[data.res[i]] && !m[data.res[i]].state.hidden) {
									p.push(data.res[i]);
									p = p.concat(m[data.res[i]].parents);
									if(this._data.search.smc) {
										for (k = 0, l = m[data.res[i]].children_d.length; k < l; k++) {
											if (m[m[data.res[i]].children_d[k]] && !m[m[data.res[i]].children_d[k]].state.hidden) {
												p.push(m[data.res[i]].children_d[k]);
											}
										}
									}
								}
							}
							p = $.vakata.array_remove_item($.vakata.array_unique(p), $.jstree.root);
							this._data.search.hdn = this.hide_all(true);
							this.show_node(p, true);
							this.redraw(true);
						}
					}, this))
				.on("clear_search.jstree", $.proxy(function (e, data) {
						if(this._data.search.som && data.res.length) {
							this.show_node(this._data.search.hdn, true);
							this.redraw(true);
						}
					}, this));
		};
		/**
		 * used to search the tree nodes for a given string
		 * @name search(str [, skip_async])
		 * @param {String} str the search string
		 * @param {Boolean} skip_async if set to true server will not be queried even if configured
		 * @param {Boolean} show_only_matches if set to true only matching nodes will be shown (keep in mind this can be very slow on large trees or old browsers)
		 * @param {mixed} inside an optional node to whose children to limit the search
		 * @param {Boolean} append if set to true the results of this search are appended to the previous search
		 * @plugin search
		 * @trigger search.jstree
		 */
		this.search = function (str, skip_async, show_only_matches, inside, append, show_only_matches_children) {
			if(str === false || $.trim(str.toString()) === "") {
				return this.clear_search();
			}
			inside = this.get_node(inside);
			inside = inside && inside.id ? inside.id : null;
			str = str.toString();
			var s = this.settings.search,
				a = s.ajax ? s.ajax : false,
				m = this._model.data,
				f = null,
				r = [],
				p = [], i, j;
			if(this._data.search.res.length && !append) {
				this.clear_search();
			}
			if(show_only_matches === undefined) {
				show_only_matches = s.show_only_matches;
			}
			if(show_only_matches_children === undefined) {
				show_only_matches_children = s.show_only_matches_children;
			}
			if(!skip_async && a !== false) {
				if($.isFunction(a)) {
					return a.call(this, str, $.proxy(function (d) {
							if(d && d.d) { d = d.d; }
							this._load_nodes(!$.isArray(d) ? [] : $.vakata.array_unique(d), function () {
								this.search(str, true, show_only_matches, inside, append, show_only_matches_children);
							});
						}, this), inside);
				}
				else {
					a = $.extend({}, a);
					if(!a.data) { a.data = {}; }
					a.data.str = str;
					if(inside) {
						a.data.inside = inside;
					}
					if (this._data.search.lastRequest) {
						this._data.search.lastRequest.abort();
					}
					this._data.search.lastRequest = $.ajax(a)
						.fail($.proxy(function () {
							this._data.core.last_error = { 'error' : 'ajax', 'plugin' : 'search', 'id' : 'search_01', 'reason' : 'Could not load search parents', 'data' : JSON.stringify(a) };
							this.settings.core.error.call(this, this._data.core.last_error);
						}, this))
						.done($.proxy(function (d) {
							if(d && d.d) { d = d.d; }
							this._load_nodes(!$.isArray(d) ? [] : $.vakata.array_unique(d), function () {
								this.search(str, true, show_only_matches, inside, append, show_only_matches_children);
							});
						}, this));
					return this._data.search.lastRequest;
				}
			}
			if(!append) {
				this._data.search.str = str;
				this._data.search.dom = $();
				this._data.search.res = [];
				this._data.search.opn = [];
				this._data.search.som = show_only_matches;
				this._data.search.smc = show_only_matches_children;
			}

			f = new $.vakata.search(str, true, { caseSensitive : s.case_sensitive, fuzzy : s.fuzzy });
			$.each(m[inside ? inside : $.jstree.root].children_d, function (ii, i) {
				var v = m[i];
				if(v.text && !v.state.hidden && (!s.search_leaves_only || (v.state.loaded && v.children.length === 0)) && ( (s.search_callback && s.search_callback.call(this, str, v)) || (!s.search_callback && f.search(v.text).isMatch) ) ) {
					r.push(i);
					p = p.concat(v.parents);
				}
			});
			if(r.length) {
				p = $.vakata.array_unique(p);
				for(i = 0, j = p.length; i < j; i++) {
					if(p[i] !== $.jstree.root && m[p[i]] && this.open_node(p[i], null, 0) === true) {
						this._data.search.opn.push(p[i]);
					}
				}
				if(!append) {
					this._data.search.dom = $(this.element[0].querySelectorAll('#' + $.map(r, function (v) { return "0123456789".indexOf(v[0]) !== -1 ? '\\3' + v[0] + ' ' + v.substr(1).replace($.jstree.idregex,'\\$&') : v.replace($.jstree.idregex,'\\$&'); }).join(', #')));
					this._data.search.res = r;
				}
				else {
					this._data.search.dom = this._data.search.dom.add($(this.element[0].querySelectorAll('#' + $.map(r, function (v) { return "0123456789".indexOf(v[0]) !== -1 ? '\\3' + v[0] + ' ' + v.substr(1).replace($.jstree.idregex,'\\$&') : v.replace($.jstree.idregex,'\\$&'); }).join(', #'))));
					this._data.search.res = $.vakata.array_unique(this._data.search.res.concat(r));
				}
				this._data.search.dom.children(".jstree-anchor").addClass('jstree-search');
			}
			/**
			 * triggered after search is complete
			 * @event
			 * @name search.jstree
			 * @param {jQuery} nodes a jQuery collection of matching nodes
			 * @param {String} str the search string
			 * @param {Array} res a collection of objects represeing the matching nodes
			 * @plugin search
			 */
			this.trigger('search', { nodes : this._data.search.dom, str : str, res : this._data.search.res, show_only_matches : show_only_matches });
		};
		/**
		 * used to clear the last search (removes classes and shows all nodes if filtering is on)
		 * @name clear_search()
		 * @plugin search
		 * @trigger clear_search.jstree
		 */
		this.clear_search = function () {
			if(this.settings.search.close_opened_onclear) {
				this.close_node(this._data.search.opn, 0);
			}
			/**
			 * triggered after search is complete
			 * @event
			 * @name clear_search.jstree
			 * @param {jQuery} nodes a jQuery collection of matching nodes (the result from the last search)
			 * @param {String} str the search string (the last search string)
			 * @param {Array} res a collection of objects represeing the matching nodes (the result from the last search)
			 * @plugin search
			 */
			this.trigger('clear_search', { 'nodes' : this._data.search.dom, str : this._data.search.str, res : this._data.search.res });
			if(this._data.search.res.length) {
				this._data.search.dom = $(this.element[0].querySelectorAll('#' + $.map(this._data.search.res, function (v) {
					return "0123456789".indexOf(v[0]) !== -1 ? '\\3' + v[0] + ' ' + v.substr(1).replace($.jstree.idregex,'\\$&') : v.replace($.jstree.idregex,'\\$&');
				}).join(', #')));
				this._data.search.dom.children(".jstree-anchor").removeClass("jstree-search");
			}
			this._data.search.str = "";
			this._data.search.res = [];
			this._data.search.opn = [];
			this._data.search.dom = $();
		};

		this.redraw_node = function(obj, deep, callback, force_render) {
			obj = parent.redraw_node.apply(this, arguments);
			if(obj) {
				if($.inArray(obj.id, this._data.search.res) !== -1) {
					var i, j, tmp = null;
					for(i = 0, j = obj.childNodes.length; i < j; i++) {
						if(obj.childNodes[i] && obj.childNodes[i].className && obj.childNodes[i].className.indexOf("jstree-anchor") !== -1) {
							tmp = obj.childNodes[i];
							break;
						}
					}
					if(tmp) {
						tmp.className += ' jstree-search';
					}
				}
			}
			return obj;
		};
	};

	// helpers
	(function ($) {
		// from http://kiro.me/projects/fuse.html
		$.vakata.search = function(pattern, txt, options) {
			options = options || {};
			options = $.extend({}, $.vakata.search.defaults, options);
			if(options.fuzzy !== false) {
				options.fuzzy = true;
			}
			pattern = options.caseSensitive ? pattern : pattern.toLowerCase();
			var MATCH_LOCATION	= options.location,
				MATCH_DISTANCE	= options.distance,
				MATCH_THRESHOLD	= options.threshold,
				patternLen = pattern.length,
				matchmask, pattern_alphabet, match_bitapScore, search;
			if(patternLen > 32) {
				options.fuzzy = false;
			}
			if(options.fuzzy) {
				matchmask = 1 << (patternLen - 1);
				pattern_alphabet = (function () {
					var mask = {},
						i = 0;
					for (i = 0; i < patternLen; i++) {
						mask[pattern.charAt(i)] = 0;
					}
					for (i = 0; i < patternLen; i++) {
						mask[pattern.charAt(i)] |= 1 << (patternLen - i - 1);
					}
					return mask;
				}());
				match_bitapScore = function (e, x) {
					var accuracy = e / patternLen,
						proximity = Math.abs(MATCH_LOCATION - x);
					if(!MATCH_DISTANCE) {
						return proximity ? 1.0 : accuracy;
					}
					return accuracy + (proximity / MATCH_DISTANCE);
				};
			}
			search = function (text) {
				text = options.caseSensitive ? text : text.toLowerCase();
				if(pattern === text || text.indexOf(pattern) !== -1) {
					return {
						isMatch: true,
						score: 0
					};
				}
				if(!options.fuzzy) {
					return {
						isMatch: false,
						score: 1
					};
				}
				var i, j,
					textLen = text.length,
					scoreThreshold = MATCH_THRESHOLD,
					bestLoc = text.indexOf(pattern, MATCH_LOCATION),
					binMin, binMid,
					binMax = patternLen + textLen,
					lastRd, start, finish, rd, charMatch,
					score = 1,
					locations = [];
				if (bestLoc !== -1) {
					scoreThreshold = Math.min(match_bitapScore(0, bestLoc), scoreThreshold);
					bestLoc = text.lastIndexOf(pattern, MATCH_LOCATION + patternLen);
					if (bestLoc !== -1) {
						scoreThreshold = Math.min(match_bitapScore(0, bestLoc), scoreThreshold);
					}
				}
				bestLoc = -1;
				for (i = 0; i < patternLen; i++) {
					binMin = 0;
					binMid = binMax;
					while (binMin < binMid) {
						if (match_bitapScore(i, MATCH_LOCATION + binMid) <= scoreThreshold) {
							binMin = binMid;
						} else {
							binMax = binMid;
						}
						binMid = Math.floor((binMax - binMin) / 2 + binMin);
					}
					binMax = binMid;
					start = Math.max(1, MATCH_LOCATION - binMid + 1);
					finish = Math.min(MATCH_LOCATION + binMid, textLen) + patternLen;
					rd = new Array(finish + 2);
					rd[finish + 1] = (1 << i) - 1;
					for (j = finish; j >= start; j--) {
						charMatch = pattern_alphabet[text.charAt(j - 1)];
						if (i === 0) {
							rd[j] = ((rd[j + 1] << 1) | 1) & charMatch;
						} else {
							rd[j] = ((rd[j + 1] << 1) | 1) & charMatch | (((lastRd[j + 1] | lastRd[j]) << 1) | 1) | lastRd[j + 1];
						}
						if (rd[j] & matchmask) {
							score = match_bitapScore(i, j - 1);
							if (score <= scoreThreshold) {
								scoreThreshold = score;
								bestLoc = j - 1;
								locations.push(bestLoc);
								if (bestLoc > MATCH_LOCATION) {
									start = Math.max(1, 2 * MATCH_LOCATION - bestLoc);
								} else {
									break;
								}
							}
						}
					}
					if (match_bitapScore(i + 1, MATCH_LOCATION) > scoreThreshold) {
						break;
					}
					lastRd = rd;
				}
				return {
					isMatch: bestLoc >= 0,
					score: score
				};
			};
			return txt === true ? { 'search' : search } : search(txt);
		};
		$.vakata.search.defaults = {
			location : 0,
			distance : 100,
			threshold : 0.6,
			fuzzy : false,
			caseSensitive : false
		};
	}($));

	// include the search plugin by default
	// $.jstree.defaults.plugins.push("search");


/**
 * ### Sort plugin
 *
 * Automatically sorts all siblings in the tree according to a sorting function.
 */

	/**
	 * the settings function used to sort the nodes.
	 * It is executed in the tree's context, accepts two nodes as arguments and should return `1` or `-1`.
	 * @name $.jstree.defaults.sort
	 * @plugin sort
	 */
	$.jstree.defaults.sort = function (a, b) {
		//return this.get_type(a) === this.get_type(b) ? (this.get_text(a) > this.get_text(b) ? 1 : -1) : this.get_type(a) >= this.get_type(b);
		return this.get_text(a) > this.get_text(b) ? 1 : -1;
	};
	$.jstree.plugins.sort = function (options, parent) {
		this.bind = function () {
			parent.bind.call(this);
			this.element
				.on("model.jstree", $.proxy(function (e, data) {
						this.sort(data.parent, true);
					}, this))
				.on("rename_node.jstree create_node.jstree", $.proxy(function (e, data) {
						this.sort(data.parent || data.node.parent, false);
						this.redraw_node(data.parent || data.node.parent, true);
					}, this))
				.on("move_node.jstree copy_node.jstree", $.proxy(function (e, data) {
						this.sort(data.parent, false);
						this.redraw_node(data.parent, true);
					}, this));
		};
		/**
		 * used to sort a node's children
		 * @private
		 * @name sort(obj [, deep])
		 * @param  {mixed} obj the node
		 * @param {Boolean} deep if set to `true` nodes are sorted recursively.
		 * @plugin sort
		 * @trigger search.jstree
		 */
		this.sort = function (obj, deep) {
			var i, j;
			obj = this.get_node(obj);
			if(obj && obj.children && obj.children.length) {
				obj.children.sort($.proxy(this.settings.sort, this));
				if(deep) {
					for(i = 0, j = obj.children_d.length; i < j; i++) {
						this.sort(obj.children_d[i], false);
					}
				}
			}
		};
	};

	// include the sort plugin by default
	// $.jstree.defaults.plugins.push("sort");

/**
 * ### State plugin
 *
 * Saves the state of the tree (selected nodes, opened nodes) on the user's computer using available options (localStorage, cookies, etc)
 */

	var to = false;
	/**
	 * stores all defaults for the state plugin
	 * @name $.jstree.defaults.state
	 * @plugin state
	 */
	$.jstree.defaults.state = {
		/**
		 * A string for the key to use when saving the current tree (change if using multiple trees in your project). Defaults to `jstree`.
		 * @name $.jstree.defaults.state.key
		 * @plugin state
		 */
		key		: 'jstree',
		/**
		 * A space separated list of events that trigger a state save. Defaults to `changed.jstree open_node.jstree close_node.jstree`.
		 * @name $.jstree.defaults.state.events
		 * @plugin state
		 */
		events	: 'changed.jstree open_node.jstree close_node.jstree check_node.jstree uncheck_node.jstree',
		/**
		 * Time in milliseconds after which the state will expire. Defaults to 'false' meaning - no expire.
		 * @name $.jstree.defaults.state.ttl
		 * @plugin state
		 */
		ttl		: false,
		/**
		 * A function that will be executed prior to restoring state with one argument - the state object. Can be used to clear unwanted parts of the state.
		 * @name $.jstree.defaults.state.filter
		 * @plugin state
		 */
		filter	: false
	};
	$.jstree.plugins.state = function (options, parent) {
		this.bind = function () {
			parent.bind.call(this);
			var bind = $.proxy(function () {
				this.element.on(this.settings.state.events, $.proxy(function () {
					if(to) { clearTimeout(to); }
					to = setTimeout($.proxy(function () { this.save_state(); }, this), 100);
				}, this));
				/**
				 * triggered when the state plugin is finished restoring the state (and immediately after ready if there is no state to restore).
				 * @event
				 * @name state_ready.jstree
				 * @plugin state
				 */
				this.trigger('state_ready');
			}, this);
			this.element
				.on("ready.jstree", $.proxy(function (e, data) {
						this.element.one("restore_state.jstree", bind);
						if(!this.restore_state()) { bind(); }
					}, this));
		};
		/**
		 * save the state
		 * @name save_state()
		 * @plugin state
		 */
		this.save_state = function () {
			var st = { 'state' : this.get_state(), 'ttl' : this.settings.state.ttl, 'sec' : +(new Date()) };
			$.vakata.storage.set(this.settings.state.key, JSON.stringify(st));
		};
		/**
		 * restore the state from the user's computer
		 * @name restore_state()
		 * @plugin state
		 */
		this.restore_state = function () {
			var k = $.vakata.storage.get(this.settings.state.key);
			if(!!k) { try { k = JSON.parse(k); } catch(ex) { return false; } }
			if(!!k && k.ttl && k.sec && +(new Date()) - k.sec > k.ttl) { return false; }
			if(!!k && k.state) { k = k.state; }
			if(!!k && $.isFunction(this.settings.state.filter)) { k = this.settings.state.filter.call(this, k); }
			if(!!k) {
				this.element.one("set_state.jstree", function (e, data) { data.instance.trigger('restore_state', { 'state' : $.extend(true, {}, k) }); });
				this.set_state(k);
				return true;
			}
			return false;
		};
		/**
		 * clear the state on the user's computer
		 * @name clear_state()
		 * @plugin state
		 */
		this.clear_state = function () {
			return $.vakata.storage.del(this.settings.state.key);
		};
	};

	(function ($, undefined) {
		$.vakata.storage = {
			// simply specifying the functions in FF throws an error
			set : function (key, val) { return window.localStorage.setItem(key, val); },
			get : function (key) { return window.localStorage.getItem(key); },
			del : function (key) { return window.localStorage.removeItem(key); }
		};
	}($));

	// include the state plugin by default
	// $.jstree.defaults.plugins.push("state");

/**
 * ### Types plugin
 *
 * Makes it possible to add predefined types for groups of nodes, which make it possible to easily control nesting rules and icon for each group.
 */

	/**
	 * An object storing all types as key value pairs, where the key is the type name and the value is an object that could contain following keys (all optional).
	 *
	 * * `max_children` the maximum number of immediate children this node type can have. Do not specify or set to `-1` for unlimited.
	 * * `max_depth` the maximum number of nesting this node type can have. A value of `1` would mean that the node can have children, but no grandchildren. Do not specify or set to `-1` for unlimited.
	 * * `valid_children` an array of node type strings, that nodes of this type can have as children. Do not specify or set to `-1` for no limits.
	 * * `icon` a string - can be a path to an icon or a className, if using an image that is in the current directory use a `./` prefix, otherwise it will be detected as a class. Omit to use the default icon from your theme.
	 * * `li_attr` an object of values which will be used to add HTML attributes on the resulting LI DOM node (merged with the node's own data)
	 * * `a_attr` an object of values which will be used to add HTML attributes on the resulting A DOM node (merged with the node's own data)
	 *
	 * There are two predefined types:
	 *
	 * * `#` represents the root of the tree, for example `max_children` would control the maximum number of root nodes.
	 * * `default` represents the default node - any settings here will be applied to all nodes that do not have a type specified.
	 *
	 * @name $.jstree.defaults.types
	 * @plugin types
	 */
	$.jstree.defaults.types = {
		'default' : {}
	};
	$.jstree.defaults.types[$.jstree.root] = {};

	$.jstree.plugins.types = function (options, parent) {
		this.init = function (el, options) {
			var i, j;
			if(options && options.types && options.types['default']) {
				for(i in options.types) {
					if(i !== "default" && i !== $.jstree.root && options.types.hasOwnProperty(i)) {
						for(j in options.types['default']) {
							if(options.types['default'].hasOwnProperty(j) && options.types[i][j] === undefined) {
								options.types[i][j] = options.types['default'][j];
							}
						}
					}
				}
			}
			parent.init.call(this, el, options);
			this._model.data[$.jstree.root].type = $.jstree.root;
		};
		this.refresh = function (skip_loading, forget_state) {
			parent.refresh.call(this, skip_loading, forget_state);
			this._model.data[$.jstree.root].type = $.jstree.root;
		};
		this.bind = function () {
			this.element
				.on('model.jstree', $.proxy(function (e, data) {
						var m = this._model.data,
							dpc = data.nodes,
							t = this.settings.types,
							i, j, c = 'default', k;
						for(i = 0, j = dpc.length; i < j; i++) {
							c = 'default';
							if(m[dpc[i]].original && m[dpc[i]].original.type && t[m[dpc[i]].original.type]) {
								c = m[dpc[i]].original.type;
							}
							if(m[dpc[i]].data && m[dpc[i]].data.jstree && m[dpc[i]].data.jstree.type && t[m[dpc[i]].data.jstree.type]) {
								c = m[dpc[i]].data.jstree.type;
							}
							m[dpc[i]].type = c;
							if(m[dpc[i]].icon === true && t[c].icon !== undefined) {
								m[dpc[i]].icon = t[c].icon;
							}
							if(t[c].li_attr !== undefined && typeof t[c].li_attr === 'object') {
								for (k in t[c].li_attr) {
									if (t[c].li_attr.hasOwnProperty(k)) {
										if (k === 'id') {
											continue;
										}
										else if (m[dpc[i]].li_attr[k] === undefined) {
											m[dpc[i]].li_attr[k] = t[c].li_attr[k];
										}
										else if (k === 'class') {
											m[dpc[i]].li_attr['class'] = t[c].li_attr['class'] + ' ' + m[dpc[i]].li_attr['class'];
										}
									}
								}
							}
							if(t[c].a_attr !== undefined && typeof t[c].a_attr === 'object') {
								for (k in t[c].a_attr) {
									if (t[c].a_attr.hasOwnProperty(k)) {
										if (k === 'id') {
											continue;
										}
										else if (m[dpc[i]].a_attr[k] === undefined) {
											m[dpc[i]].a_attr[k] = t[c].a_attr[k];
										}
										else if (k === 'href' && m[dpc[i]].a_attr[k] === '#') {
											m[dpc[i]].a_attr['href'] = t[c].a_attr['href'];
										}
										else if (k === 'class') {
											m[dpc[i]].a_attr['class'] = t[c].a_attr['class'] + ' ' + m[dpc[i]].a_attr['class'];
										}
									}
								}
							}
						}
						m[$.jstree.root].type = $.jstree.root;
					}, this));
			parent.bind.call(this);
		};
		this.get_json = function (obj, options, flat) {
			var i, j,
				m = this._model.data,
				opt = options ? $.extend(true, {}, options, {no_id:false}) : {},
				tmp = parent.get_json.call(this, obj, opt, flat);
			if(tmp === false) { return false; }
			if($.isArray(tmp)) {
				for(i = 0, j = tmp.length; i < j; i++) {
					tmp[i].type = tmp[i].id && m[tmp[i].id] && m[tmp[i].id].type ? m[tmp[i].id].type : "default";
					if(options && options.no_id) {
						delete tmp[i].id;
						if(tmp[i].li_attr && tmp[i].li_attr.id) {
							delete tmp[i].li_attr.id;
						}
						if(tmp[i].a_attr && tmp[i].a_attr.id) {
							delete tmp[i].a_attr.id;
						}
					}
				}
			}
			else {
				tmp.type = tmp.id && m[tmp.id] && m[tmp.id].type ? m[tmp.id].type : "default";
				if(options && options.no_id) {
					tmp = this._delete_ids(tmp);
				}
			}
			return tmp;
		};
		this._delete_ids = function (tmp) {
			if($.isArray(tmp)) {
				for(var i = 0, j = tmp.length; i < j; i++) {
					tmp[i] = this._delete_ids(tmp[i]);
				}
				return tmp;
			}
			delete tmp.id;
			if(tmp.li_attr && tmp.li_attr.id) {
				delete tmp.li_attr.id;
			}
			if(tmp.a_attr && tmp.a_attr.id) {
				delete tmp.a_attr.id;
			}
			if(tmp.children && $.isArray(tmp.children)) {
				tmp.children = this._delete_ids(tmp.children);
			}
			return tmp;
		};
		this.check = function (chk, obj, par, pos, more) {
			if(parent.check.call(this, chk, obj, par, pos, more) === false) { return false; }
			obj = obj && obj.id ? obj : this.get_node(obj);
			par = par && par.id ? par : this.get_node(par);
			var m = obj && obj.id ? (more && more.origin ? more.origin : $.jstree.reference(obj.id)) : null, tmp, d, i, j;
			m = m && m._model && m._model.data ? m._model.data : null;
			switch(chk) {
				case "create_node":
				case "move_node":
				case "copy_node":
					if(chk !== 'move_node' || $.inArray(obj.id, par.children) === -1) {
						tmp = this.get_rules(par);
						if(tmp.max_children !== undefined && tmp.max_children !== -1 && tmp.max_children === par.children.length) {
							this._data.core.last_error = { 'error' : 'check', 'plugin' : 'types', 'id' : 'types_01', 'reason' : 'max_children prevents function: ' + chk, 'data' : JSON.stringify({ 'chk' : chk, 'pos' : pos, 'obj' : obj && obj.id ? obj.id : false, 'par' : par && par.id ? par.id : false }) };
							return false;
						}
						if(tmp.valid_children !== undefined && tmp.valid_children !== -1 && $.inArray((obj.type || 'default'), tmp.valid_children) === -1) {
							this._data.core.last_error = { 'error' : 'check', 'plugin' : 'types', 'id' : 'types_02', 'reason' : 'valid_children prevents function: ' + chk, 'data' : JSON.stringify({ 'chk' : chk, 'pos' : pos, 'obj' : obj && obj.id ? obj.id : false, 'par' : par && par.id ? par.id : false }) };
							return false;
						}
						if(m && obj.children_d && obj.parents) {
							d = 0;
							for(i = 0, j = obj.children_d.length; i < j; i++) {
								d = Math.max(d, m[obj.children_d[i]].parents.length);
							}
							d = d - obj.parents.length + 1;
						}
						if(d <= 0 || d === undefined) { d = 1; }
						do {
							if(tmp.max_depth !== undefined && tmp.max_depth !== -1 && tmp.max_depth < d) {
								this._data.core.last_error = { 'error' : 'check', 'plugin' : 'types', 'id' : 'types_03', 'reason' : 'max_depth prevents function: ' + chk, 'data' : JSON.stringify({ 'chk' : chk, 'pos' : pos, 'obj' : obj && obj.id ? obj.id : false, 'par' : par && par.id ? par.id : false }) };
								return false;
							}
							par = this.get_node(par.parent);
							tmp = this.get_rules(par);
							d++;
						} while(par);
					}
					break;
			}
			return true;
		};
		/**
		 * used to retrieve the type settings object for a node
		 * @name get_rules(obj)
		 * @param {mixed} obj the node to find the rules for
		 * @return {Object}
		 * @plugin types
		 */
		this.get_rules = function (obj) {
			obj = this.get_node(obj);
			if(!obj) { return false; }
			var tmp = this.get_type(obj, true);
			if(tmp.max_depth === undefined) { tmp.max_depth = -1; }
			if(tmp.max_children === undefined) { tmp.max_children = -1; }
			if(tmp.valid_children === undefined) { tmp.valid_children = -1; }
			return tmp;
		};
		/**
		 * used to retrieve the type string or settings object for a node
		 * @name get_type(obj [, rules])
		 * @param {mixed} obj the node to find the rules for
		 * @param {Boolean} rules if set to `true` instead of a string the settings object will be returned
		 * @return {String|Object}
		 * @plugin types
		 */
		this.get_type = function (obj, rules) {
			obj = this.get_node(obj);
			return (!obj) ? false : ( rules ? $.extend({ 'type' : obj.type }, this.settings.types[obj.type]) : obj.type);
		};
		/**
		 * used to change a node's type
		 * @name set_type(obj, type)
		 * @param {mixed} obj the node to change
		 * @param {String} type the new type
		 * @plugin types
		 */
		this.set_type = function (obj, type) {
			var m = this._model.data, t, t1, t2, old_type, old_icon, k, d, a;
			if($.isArray(obj)) {
				obj = obj.slice();
				for(t1 = 0, t2 = obj.length; t1 < t2; t1++) {
					this.set_type(obj[t1], type);
				}
				return true;
			}
			t = this.settings.types;
			obj = this.get_node(obj);
			if(!t[type] || !obj) { return false; }
			d = this.get_node(obj, true);
			if (d && d.length) {
				a = d.children('.jstree-anchor');
			}
			old_type = obj.type;
			old_icon = this.get_icon(obj);
			obj.type = type;
			if(old_icon === true || !t[old_type] || (t[old_type].icon !== undefined && old_icon === t[old_type].icon)) {
				this.set_icon(obj, t[type].icon !== undefined ? t[type].icon : true);
			}

			// remove old type props
			if(t[old_type] && t[old_type].li_attr !== undefined && typeof t[old_type].li_attr === 'object') {
				for (k in t[old_type].li_attr) {
					if (t[old_type].li_attr.hasOwnProperty(k)) {
						if (k === 'id') {
							continue;
						}
						else if (k === 'class') {
							m[obj.id].li_attr['class'] = (m[obj.id].li_attr['class'] || '').replace(t[old_type].li_attr[k], '');
							if (d) { d.removeClass(t[old_type].li_attr[k]); }
						}
						else if (m[obj.id].li_attr[k] === t[old_type].li_attr[k]) {
							m[obj.id].li_attr[k] = null;
							if (d) { d.removeAttr(k); }
						}
					}
				}
			}
			if(t[old_type] && t[old_type].a_attr !== undefined && typeof t[old_type].a_attr === 'object') {
				for (k in t[old_type].a_attr) {
					if (t[old_type].a_attr.hasOwnProperty(k)) {
						if (k === 'id') {
							continue;
						}
						else if (k === 'class') {
							m[obj.id].a_attr['class'] = (m[obj.id].a_attr['class'] || '').replace(t[old_type].a_attr[k], '');
							if (a) { a.removeClass(t[old_type].a_attr[k]); }
						}
						else if (m[obj.id].a_attr[k] === t[old_type].a_attr[k]) {
							if (k === 'href') {
								m[obj.id].a_attr[k] = '#';
								if (a) { a.attr('href', '#'); }
							}
							else {
								delete m[obj.id].a_attr[k];
								if (a) { a.removeAttr(k); }
							}
						}
					}
				}
			}

			// add new props
			if(t[type].li_attr !== undefined && typeof t[type].li_attr === 'object') {
				for (k in t[type].li_attr) {
					if (t[type].li_attr.hasOwnProperty(k)) {
						if (k === 'id') {
							continue;
						}
						else if (m[obj.id].li_attr[k] === undefined) {
							m[obj.id].li_attr[k] = t[type].li_attr[k];
							if (d) {
								if (k === 'class') {
									d.addClass(t[type].li_attr[k]);
								}
								else {
									d.attr(k, t[type].li_attr[k]);
								}
							}
						}
						else if (k === 'class') {
							m[obj.id].li_attr['class'] = t[type].li_attr[k] + ' ' + m[obj.id].li_attr['class'];
							if (d) { d.addClass(t[type].li_attr[k]); }
						}
					}
				}
			}
			if(t[type].a_attr !== undefined && typeof t[type].a_attr === 'object') {
				for (k in t[type].a_attr) {
					if (t[type].a_attr.hasOwnProperty(k)) {
						if (k === 'id') {
							continue;
						}
						else if (m[obj.id].a_attr[k] === undefined) {
							m[obj.id].a_attr[k] = t[type].a_attr[k];
							if (a) {
								if (k === 'class') {
									a.addClass(t[type].a_attr[k]);
								}
								else {
									a.attr(k, t[type].a_attr[k]);
								}
							}
						}
						else if (k === 'href' && m[obj.id].a_attr[k] === '#') {
							m[obj.id].a_attr['href'] = t[type].a_attr['href'];
							if (a) { a.attr('href', t[type].a_attr['href']); }
						}
						else if (k === 'class') {
							m[obj.id].a_attr['class'] = t[type].a_attr['class'] + ' ' + m[obj.id].a_attr['class'];
							if (a) { a.addClass(t[type].a_attr[k]); }
						}
					}
				}
			}

			return true;
		};
	};
	// include the types plugin by default
	// $.jstree.defaults.plugins.push("types");


/**
 * ### Unique plugin
 *
 * Enforces that no nodes with the same name can coexist as siblings.
 */

	/**
	 * stores all defaults for the unique plugin
	 * @name $.jstree.defaults.unique
	 * @plugin unique
	 */
	$.jstree.defaults.unique = {
		/**
		 * Indicates if the comparison should be case sensitive. Default is `false`.
		 * @name $.jstree.defaults.unique.case_sensitive
		 * @plugin unique
		 */
		case_sensitive : false,
		/**
		 * A callback executed in the instance's scope when a new node is created and the name is already taken, the two arguments are the conflicting name and the counter. The default will produce results like `New node (2)`.
		 * @name $.jstree.defaults.unique.duplicate
		 * @plugin unique
		 */
		duplicate : function (name, counter) {
			return name + ' (' + counter + ')';
		}
	};

	$.jstree.plugins.unique = function (options, parent) {
		this.check = function (chk, obj, par, pos, more) {
			if(parent.check.call(this, chk, obj, par, pos, more) === false) { return false; }
			obj = obj && obj.id ? obj : this.get_node(obj);
			par = par && par.id ? par : this.get_node(par);
			if(!par || !par.children) { return true; }
			var n = chk === "rename_node" ? pos : obj.text,
				c = [],
				s = this.settings.unique.case_sensitive,
				m = this._model.data, i, j;
			for(i = 0, j = par.children.length; i < j; i++) {
				c.push(s ? m[par.children[i]].text : m[par.children[i]].text.toLowerCase());
			}
			if(!s) { n = n.toLowerCase(); }
			switch(chk) {
				case "delete_node":
					return true;
				case "rename_node":
					i = ($.inArray(n, c) === -1 || (obj.text && obj.text[ s ? 'toString' : 'toLowerCase']() === n));
					if(!i) {
						this._data.core.last_error = { 'error' : 'check', 'plugin' : 'unique', 'id' : 'unique_01', 'reason' : 'Child with name ' + n + ' already exists. Preventing: ' + chk, 'data' : JSON.stringify({ 'chk' : chk, 'pos' : pos, 'obj' : obj && obj.id ? obj.id : false, 'par' : par && par.id ? par.id : false }) };
					}
					return i;
				case "create_node":
					i = ($.inArray(n, c) === -1);
					if(!i) {
						this._data.core.last_error = { 'error' : 'check', 'plugin' : 'unique', 'id' : 'unique_04', 'reason' : 'Child with name ' + n + ' already exists. Preventing: ' + chk, 'data' : JSON.stringify({ 'chk' : chk, 'pos' : pos, 'obj' : obj && obj.id ? obj.id : false, 'par' : par && par.id ? par.id : false }) };
					}
					return i;
				case "copy_node":
					i = ($.inArray(n, c) === -1);
					if(!i) {
						this._data.core.last_error = { 'error' : 'check', 'plugin' : 'unique', 'id' : 'unique_02', 'reason' : 'Child with name ' + n + ' already exists. Preventing: ' + chk, 'data' : JSON.stringify({ 'chk' : chk, 'pos' : pos, 'obj' : obj && obj.id ? obj.id : false, 'par' : par && par.id ? par.id : false }) };
					}
					return i;
				case "move_node":
					i = ( (obj.parent === par.id && (!more || !more.is_multi)) || $.inArray(n, c) === -1);
					if(!i) {
						this._data.core.last_error = { 'error' : 'check', 'plugin' : 'unique', 'id' : 'unique_03', 'reason' : 'Child with name ' + n + ' already exists. Preventing: ' + chk, 'data' : JSON.stringify({ 'chk' : chk, 'pos' : pos, 'obj' : obj && obj.id ? obj.id : false, 'par' : par && par.id ? par.id : false }) };
					}
					return i;
			}
			return true;
		};
		this.create_node = function (par, node, pos, callback, is_loaded) {
			if(!node || node.text === undefined) {
				if(par === null) {
					par = $.jstree.root;
				}
				par = this.get_node(par);
				if(!par) {
					return parent.create_node.call(this, par, node, pos, callback, is_loaded);
				}
				pos = pos === undefined ? "last" : pos;
				if(!pos.toString().match(/^(before|after)$/) && !is_loaded && !this.is_loaded(par)) {
					return parent.create_node.call(this, par, node, pos, callback, is_loaded);
				}
				if(!node) { node = {}; }
				var tmp, n, dpc, i, j, m = this._model.data, s = this.settings.unique.case_sensitive, cb = this.settings.unique.duplicate;
				n = tmp = this.get_string('New node');
				dpc = [];
				for(i = 0, j = par.children.length; i < j; i++) {
					dpc.push(s ? m[par.children[i]].text : m[par.children[i]].text.toLowerCase());
				}
				i = 1;
				while($.inArray(s ? n : n.toLowerCase(), dpc) !== -1) {
					n = cb.call(this, tmp, (++i)).toString();
				}
				node.text = n;
			}
			return parent.create_node.call(this, par, node, pos, callback, is_loaded);
		};
	};

	// include the unique plugin by default
	// $.jstree.defaults.plugins.push("unique");


/**
 * ### Wholerow plugin
 *
 * Makes each node appear block level. Making selection easier. May cause slow down for large trees in old browsers.
 */

	var div = document.createElement('DIV');
	div.setAttribute('unselectable','on');
	div.setAttribute('role','presentation');
	div.className = 'jstree-wholerow';
	div.innerHTML = '&#160;';
	$.jstree.plugins.wholerow = function (options, parent) {
		this.bind = function () {
			parent.bind.call(this);

			this.element
				.on('ready.jstree set_state.jstree', $.proxy(function () {
						this.hide_dots();
					}, this))
				.on("init.jstree loading.jstree ready.jstree", $.proxy(function () {
						//div.style.height = this._data.core.li_height + 'px';
						this.get_container_ul().addClass('jstree-wholerow-ul');
					}, this))
				.on("deselect_all.jstree", $.proxy(function (e, data) {
						this.element.find('.jstree-wholerow-clicked').removeClass('jstree-wholerow-clicked');
					}, this))
				.on("changed.jstree", $.proxy(function (e, data) {
						this.element.find('.jstree-wholerow-clicked').removeClass('jstree-wholerow-clicked');
						var tmp = false, i, j;
						for(i = 0, j = data.selected.length; i < j; i++) {
							tmp = this.get_node(data.selected[i], true);
							if(tmp && tmp.length) {
								tmp.children('.jstree-wholerow').addClass('jstree-wholerow-clicked');
							}
						}
					}, this))
				.on("open_node.jstree", $.proxy(function (e, data) {
						this.get_node(data.node, true).find('.jstree-clicked').parent().children('.jstree-wholerow').addClass('jstree-wholerow-clicked');
					}, this))
				.on("hover_node.jstree dehover_node.jstree", $.proxy(function (e, data) {
						if(e.type === "hover_node" && this.is_disabled(data.node)) { return; }
						this.get_node(data.node, true).children('.jstree-wholerow')[e.type === "hover_node"?"addClass":"removeClass"]('jstree-wholerow-hovered');
					}, this))
				.on("contextmenu.jstree", ".jstree-wholerow", $.proxy(function (e) {
						if (this._data.contextmenu) {
							e.preventDefault();
							var tmp = $.Event('contextmenu', { metaKey : e.metaKey, ctrlKey : e.ctrlKey, altKey : e.altKey, shiftKey : e.shiftKey, pageX : e.pageX, pageY : e.pageY });
							$(e.currentTarget).closest(".jstree-node").children(".jstree-anchor").first().trigger(tmp);
						}
					}, this))
				/*!
				.on("mousedown.jstree touchstart.jstree", ".jstree-wholerow", function (e) {
						if(e.target === e.currentTarget) {
							var a = $(e.currentTarget).closest(".jstree-node").children(".jstree-anchor");
							e.target = a[0];
							a.trigger(e);
						}
					})
				*/
				.on("click.jstree", ".jstree-wholerow", function (e) {
						e.stopImmediatePropagation();
						var tmp = $.Event('click', { metaKey : e.metaKey, ctrlKey : e.ctrlKey, altKey : e.altKey, shiftKey : e.shiftKey });
						$(e.currentTarget).closest(".jstree-node").children(".jstree-anchor").first().trigger(tmp).focus();
					})
				.on("dblclick.jstree", ".jstree-wholerow", function (e) {
						e.stopImmediatePropagation();
						var tmp = $.Event('dblclick', { metaKey : e.metaKey, ctrlKey : e.ctrlKey, altKey : e.altKey, shiftKey : e.shiftKey });
						$(e.currentTarget).closest(".jstree-node").children(".jstree-anchor").first().trigger(tmp).focus();
					})
				.on("click.jstree", ".jstree-leaf > .jstree-ocl", $.proxy(function (e) {
						e.stopImmediatePropagation();
						var tmp = $.Event('click', { metaKey : e.metaKey, ctrlKey : e.ctrlKey, altKey : e.altKey, shiftKey : e.shiftKey });
						$(e.currentTarget).closest(".jstree-node").children(".jstree-anchor").first().trigger(tmp).focus();
					}, this))
				.on("mouseover.jstree", ".jstree-wholerow, .jstree-icon", $.proxy(function (e) {
						e.stopImmediatePropagation();
						if(!this.is_disabled(e.currentTarget)) {
							this.hover_node(e.currentTarget);
						}
						return false;
					}, this))
				.on("mouseleave.jstree", ".jstree-node", $.proxy(function (e) {
						this.dehover_node(e.currentTarget);
					}, this));
		};
		this.teardown = function () {
			if(this.settings.wholerow) {
				this.element.find(".jstree-wholerow").remove();
			}
			parent.teardown.call(this);
		};
		this.redraw_node = function(obj, deep, callback, force_render) {
			obj = parent.redraw_node.apply(this, arguments);
			if(obj) {
				var tmp = div.cloneNode(true);
				//tmp.style.height = this._data.core.li_height + 'px';
				if($.inArray(obj.id, this._data.core.selected) !== -1) { tmp.className += ' jstree-wholerow-clicked'; }
				if(this._data.core.focused && this._data.core.focused === obj.id) { tmp.className += ' jstree-wholerow-hovered'; }
				obj.insertBefore(tmp, obj.childNodes[0]);
			}
			return obj;
		};
	};
	// include the wholerow plugin by default
	// $.jstree.defaults.plugins.push("wholerow");
	if(document.registerElement && Object && Object.create) {
		var proto = Object.create(HTMLElement.prototype);
		proto.createdCallback = function () {
			var c = { core : {}, plugins : [] }, i;
			for(i in $.jstree.plugins) {
				if($.jstree.plugins.hasOwnProperty(i) && this.attributes[i]) {
					c.plugins.push(i);
					if(this.getAttribute(i) && JSON.parse(this.getAttribute(i))) {
						c[i] = JSON.parse(this.getAttribute(i));
					}
				}
			}
			for(i in $.jstree.defaults.core) {
				if($.jstree.defaults.core.hasOwnProperty(i) && this.attributes[i]) {
					c.core[i] = JSON.parse(this.getAttribute(i)) || this.getAttribute(i);
				}
			}
			$(this).jstree(c);
		};
		// proto.attributeChangedCallback = function (name, previous, value) { };
		try {
			document.registerElement("vakata-jstree", { prototype: proto });
		} catch(ignore) { }
	}

}));

/***/ }),
/* 60 */
/***/ (function(module, exports, __webpack_require__) {

// knockout-postbox 0.5.2 | (c) 2015 Ryan Niemeyer |  http://www.opensource.org/licenses/mit-license
;(function(factory) {
    //CommonJS
    if (true) {
        factory(__webpack_require__(4), exports);
    //AMD
    } else if (typeof define === "function" && define.amd) {
        define(["knockout", "exports"], factory);
    //normal script tag
    } else {
        factory(ko, ko.postbox = {});
    }
}(function(ko, exports, undefined) {
    var disposeTopicSubscription, existingSubscribe,
		subscriptions = {},
		subId = 1;

	exports.subscriptions = subscriptions;

    //create a global postbox that supports subscribing/publishing
    ko.subscribable.call(exports);

    //keep a cache of the latest value and subscribers
    exports.topicCache = {};

    //allow customization of the function used to serialize values for the topic cache
    exports.serializer = ko.toJSON;

    //wrap notifySubscribers passing topic first and caching latest value
    exports.publish = function(topic, value) {
        if (topic) {
            //keep the value and a serialized version for comparison
            exports.topicCache[topic] = {
                value: value,
                serialized: exports.serializer(value)
            };
            exports.notifySubscribers(value, topic);
        }
    };

    //provide a subscribe API for the postbox that takes in the topic as first arg
    existingSubscribe = exports.subscribe;
    exports.subscribe = function(topic, action, target, initializeWithLatestValue) {
        var subscription, current, existingDispose;

        if (topic) {
            if (typeof target === "boolean") {
                initializeWithLatestValue = target;
                target = undefined;
            }

            subscription = existingSubscribe.call(exports, action, target, topic);
			subscription.subId = ++subId;
			subscriptions[ subId ] = subscription;

            if (initializeWithLatestValue) {
                current = exports.topicCache[topic];

                if (current !== undefined) {
                    action.call(target, current.value);
                }
            }

			existingDispose = subscription.dispose;
			subscription.dispose = function() {
				delete subscriptions[subscription.subId];
				existingDispose.call(subscription);
			};

            return subscription;
        }
    };

	//clean up all subscriptions and references
	exports.reset = function() {
		var subscription;

		for (var id in subscriptions) {
			if (subscriptions.hasOwnProperty(id)) {
				subscription = subscriptions[id];

				if (subscription && typeof subscription.dispose === "function") {
					subscription.dispose();
				}
			}
		}

		exports.topicCache = {};
	};

    //by default publish when the previous cached value does not equal the new value
    exports.defaultComparer = function(newValue, cacheItem) {
        return cacheItem && exports.serializer(newValue) === cacheItem.serialized;
    };

    //augment observables/computeds with the ability to automatically publish updates on a topic
    ko.subscribable.fn.publishOn = function(topic, skipInitialOrEqualityComparer, equalityComparer) {
        var skipInitialPublish, subscription, existingDispose;

        if (topic) {
            //allow passing the equalityComparer as the second argument
            if (typeof skipInitialOrEqualityComparer === "function") {
                equalityComparer = skipInitialOrEqualityComparer;
            } else {
                skipInitialPublish = skipInitialOrEqualityComparer;
            }

            equalityComparer = equalityComparer || exports.defaultComparer;

            //remove any existing subs
            disposeTopicSubscription.call(this, topic, "publishOn");

            //keep a reference to the subscription, so we can stop publishing
            subscription = this.subscribe(function(newValue) {
				if (!equalityComparer.call(this, newValue, exports.topicCache[topic])) {
					exports.publish(topic, newValue);
				}
			}, this);

			//track the subscription in case of a reset
			subscription.id = ++subId;
			subscriptions[subId] = subscription;

			//ensure that we cleanup pointers to subscription on dispose
			existingDispose = subscription.dispose;
			subscription.dispose = function() {
				delete this.postboxSubs[topic].publishOn;
				delete subscriptions[subscription.id];

				existingDispose.call(subscription);
			}.bind(this);

			this.postboxSubs[topic].publishOn = subscription;

            //do an initial publish
            if (!skipInitialPublish) {
                exports.publish(topic, this());
            }
        }

        return this;
    };

    //handle disposing a subscription used to publish or subscribe to a topic
    disposeTopicSubscription = function(topic, type) {
        var subs = this.postboxSubs = this.postboxSubs || {};
        subs[topic] = subs[topic] || {};

        if (subs[topic][type]) {
            subs[topic][type].dispose();
        }
    };

    //discontinue automatically publishing on a topic
    ko.subscribable.fn.stopPublishingOn = function(topic) {
        disposeTopicSubscription.call(this, topic, "publishOn");

        return this;
    };

    //augment observables/computeds to automatically be updated by notifications on a topic
    ko.subscribable.fn.subscribeTo = function(topic, initializeWithLatestValueOrTransform, transform) {
        var initializeWithLatestValue, current, callback, subscription, existingDispose,
            self = this;

        //allow passing the filter as the second argument
        if (typeof initializeWithLatestValueOrTransform === "function") {
            transform = initializeWithLatestValueOrTransform;
        } else {
            initializeWithLatestValue = initializeWithLatestValueOrTransform;
        }

        if (topic && ko.isWriteableObservable(this)) {
            //remove any existing subs
            disposeTopicSubscription.call(this, topic, "subscribeTo");

            //if specified, apply a filter function in the subscription
            callback = function(newValue) {
                self(transform ? transform.call(self, newValue) : newValue);
            };

			////keep a reference to the subscription, so we can unsubscribe, if necessary
			subscription = exports.subscribe(topic, callback);
			this.postboxSubs[topic].subscribeTo = subscription;

			//ensure that we cleanup pointers to subscription on dispose
			existingDispose = subscription.dispose;
			subscription.dispose = function() {
				delete this.postboxSubs[topic].subscribeTo;
				existingDispose.call(subscription);
			}.bind(this);

            if (initializeWithLatestValue) {
                current = exports.topicCache[topic];

                if (current !== undefined) {
                    callback(current.value);
                }
            }
        }

        return this;
    };

    //discontinue receiving updates on a topic
    ko.subscribable.fn.unsubscribeFrom = function(topic) {
        disposeTopicSubscription.call(this, topic, "subscribeTo");

        return this;
    };

    // both subscribe and publish on the same topic
    //   -allows the ability to sync an observable/writeable computed/observableArray between view models
    //   -subscribeTo should really not use a filter function, as it would likely cause infinite recursion
    ko.subscribable.fn.syncWith = function(topic, initializeWithLatestValue, skipInitialOrEqualityComparer, equalityComparer) {
        this.subscribeTo(topic, initializeWithLatestValue).publishOn(topic, skipInitialOrEqualityComparer, equalityComparer);

        return this;
    };

    ko.postbox = exports;
}));


/***/ }),
/* 61 */
/***/ (function(module, exports, __webpack_require__) {

/*=============================================================================
	Author:			Eric M. Barnard - @ericmbarnard								
	License:		MIT (http://opensource.org/licenses/mit-license.php)		
																				
	Description:	Validation Library for KnockoutJS							
	Version:		2.0.3											
===============================================================================
*/
/*globals require: false, exports: false, define: false, ko: false */

(function (factory) {
	// Module systems magic dance.

	if (true) {
		// CommonJS or Node: hard-coded dependency on "knockout"
		factory(__webpack_require__(4), exports);
	} else if (typeof define === "function" && define["amd"]) {
		// AMD anonymous module with hard-coded dependency on "knockout"
		define(["knockout", "exports"], factory);
	} else {
		// <script> tag: use the global `ko` object, attaching a `mapping` property
		factory(ko, ko.validation = {});
	}
}(function ( ko, exports ) {

	if (typeof (ko) === 'undefined') {
		throw new Error('Knockout is required, please ensure it is loaded before loading this validation plug-in');
	}

	// create our namespace object
	ko.validation = exports;

	var kv = ko.validation,
		koUtils = ko.utils,
		unwrap = koUtils.unwrapObservable,
		forEach = koUtils.arrayForEach,
		extend = koUtils.extend;
;/*global ko: false*/

var defaults = {
	registerExtenders: true,
	messagesOnModified: true,
	errorsAsTitle: true,            // enables/disables showing of errors as title attribute of the target element.
	errorsAsTitleOnModified: false, // shows the error when hovering the input field (decorateElement must be true)
	messageTemplate: null,
	insertMessages: true,           // automatically inserts validation messages as <span></span>
	parseInputAttributes: false,    // parses the HTML5 validation attribute from a form element and adds that to the object
	writeInputAttributes: false,    // adds HTML5 input validation attributes to form elements that ko observable's are bound to
	decorateInputElement: false,         // false to keep backward compatibility
	decorateElementOnModified: true,// true to keep backward compatibility
	errorClass: null,               // single class for error message and element
	errorElementClass: 'validationElement',  // class to decorate error element
	errorMessageClass: 'validationMessage',  // class to decorate error message
	allowHtmlMessages: false,		// allows HTML in validation messages
	grouping: {
		deep: false,        //by default grouping is shallow
		observable: true,   //and using observables
		live: false		    //react to changes to observableArrays if observable === true
	},
	validate: {
		// throttle: 10
	}
};

// make a copy  so we can use 'reset' later
var configuration = extend({}, defaults);

configuration.html5Attributes = ['required', 'pattern', 'min', 'max', 'step'];
configuration.html5InputTypes = ['email', 'number', 'date'];

configuration.reset = function () {
	extend(configuration, defaults);
};

kv.configuration = configuration;
;kv.utils = (function () {
	var seedId = new Date().getTime();

	var domData = {}; //hash of data objects that we reference from dom elements
	var domDataKey = '__ko_validation__';

	return {
		isArray: function (o) {
			return o.isArray || Object.prototype.toString.call(o) === '[object Array]';
		},
		isObject: function (o) {
			return o !== null && typeof o === 'object';
		},
		isNumber: function(o) {
			return !isNaN(o);	
		},
		isObservableArray: function(instance) {
			return !!instance &&
					typeof instance["remove"] === "function" &&
					typeof instance["removeAll"] === "function" &&
					typeof instance["destroy"] === "function" &&
					typeof instance["destroyAll"] === "function" &&
					typeof instance["indexOf"] === "function" &&
					typeof instance["replace"] === "function";
		},
		values: function (o) {
			var r = [];
			for (var i in o) {
				if (o.hasOwnProperty(i)) {
					r.push(o[i]);
				}
			}
			return r;
		},
		getValue: function (o) {
			return (typeof o === 'function' ? o() : o);
		},
		hasAttribute: function (node, attr) {
			return node.getAttribute(attr) !== null;
		},
		getAttribute: function (element, attr) {
			return element.getAttribute(attr);
		},
		setAttribute: function (element, attr, value) {
			return element.setAttribute(attr, value);
		},
		isValidatable: function (o) {
			return !!(o && o.rules && o.isValid && o.isModified);
		},
		insertAfter: function (node, newNode) {
			node.parentNode.insertBefore(newNode, node.nextSibling);
		},
		newId: function () {
			return seedId += 1;
		},
		getConfigOptions: function (element) {
			var options = kv.utils.contextFor(element);

			return options || kv.configuration;
		},
		setDomData: function (node, data) {
			var key = node[domDataKey];

			if (!key) {
				node[domDataKey] = key = kv.utils.newId();
			}

			domData[key] = data;
		},
		getDomData: function (node) {
			var key = node[domDataKey];

			if (!key) {
				return undefined;
			}

			return domData[key];
		},
		contextFor: function (node) {
			switch (node.nodeType) {
				case 1:
				case 8:
					var context = kv.utils.getDomData(node);
					if (context) { return context; }
					if (node.parentNode) { return kv.utils.contextFor(node.parentNode); }
					break;
			}
			return undefined;
		},
		isEmptyVal: function (val) {
			if (val === undefined) {
				return true;
			}
			if (val === null) {
				return true;
			}
			if (val === "") {
				return true;
			}
		},
		getOriginalElementTitle: function (element) {
			var savedOriginalTitle = kv.utils.getAttribute(element, 'data-orig-title'),
				currentTitle = element.title,
				hasSavedOriginalTitle = kv.utils.hasAttribute(element, 'data-orig-title');

			return hasSavedOriginalTitle ?
				savedOriginalTitle : currentTitle;
		},
		async: function (expr) {
			if (window.setImmediate) { window.setImmediate(expr); }
			else { window.setTimeout(expr, 0); }
		},
		forEach: function (object, callback) {
			if (kv.utils.isArray(object)) {
				return forEach(object, callback);
			}
			for (var prop in object) {
				if (object.hasOwnProperty(prop)) {
					callback(object[prop], prop);
				}
			}
		}
	};
}());;var api = (function () {

	var isInitialized = 0,
		configuration = kv.configuration,
		utils = kv.utils;

	function cleanUpSubscriptions(context) {
		forEach(context.subscriptions, function (subscription) {
			subscription.dispose();
		});
		context.subscriptions = [];
	}

	function dispose(context) {
		if (context.options.deep) {
			forEach(context.flagged, function (obj) {
				delete obj.__kv_traversed;
			});
			context.flagged.length = 0;
		}

		if (!context.options.live) {
			cleanUpSubscriptions(context);
		}
	}

	function runTraversal(obj, context) {
		context.validatables = [];
		cleanUpSubscriptions(context);
		traverseGraph(obj, context);
		dispose(context);
	}

	function traverseGraph(obj, context, level) {
		var objValues = [],
			val = obj.peek ? obj.peek() : obj;

		if (obj.__kv_traversed === true) {
			return;
		}

		if (context.options.deep) {
			obj.__kv_traversed = true;
			context.flagged.push(obj);
		}

		//default level value depends on deep option.
		level = (level !== undefined ? level : context.options.deep ? 1 : -1);

		// if object is observable then add it to the list
		if (ko.isObservable(obj)) {
			// ensure it's validatable but don't extend validatedObservable because it
			// would overwrite isValid property.
			if (!obj.errors && !utils.isValidatable(obj)) {
				obj.extend({ validatable: true });
			}
			context.validatables.push(obj);

			if (context.options.live && utils.isObservableArray(obj)) {
				context.subscriptions.push(obj.subscribe(function () {
					context.graphMonitor.valueHasMutated();
				}));
			}
		}

		//get list of values either from array or object but ignore non-objects
		// and destroyed objects
		if (val && !val._destroy) {
			if (utils.isArray(val)) {
				objValues = val;
			}
			else if (utils.isObject(val)) {
				objValues = utils.values(val);
			}
		}

		//process recursively if it is deep grouping
		if (level !== 0) {
			utils.forEach(objValues, function (observable) {
				//but not falsy things and not HTML Elements
				if (observable && !observable.nodeType && (!ko.isComputed(observable) || observable.rules)) {
					traverseGraph(observable, context, level + 1);
				}
			});
		}
	}

	function collectErrors(array) {
		var errors = [];
		forEach(array, function (observable) {
			// Do not collect validatedObservable errors
			if (utils.isValidatable(observable) && !observable.isValid()) {
				// Use peek because we don't want a dependency for 'error' property because it
				// changes before 'isValid' does. (Issue #99)
				errors.push(observable.error.peek());
			}
		});
		return errors;
	}

	return {
		//Call this on startup
		//any config can be overridden with the passed in options
		init: function (options, force) {
			//done run this multiple times if we don't really want to
			if (isInitialized > 0 && !force) {
				return;
			}

			//because we will be accessing options properties it has to be an object at least
			options = options || {};
			//if specific error classes are not provided then apply generic errorClass
			//it has to be done on option so that options.errorClass can override default
			//errorElementClass and errorMessage class but not those provided in options
			options.errorElementClass = options.errorElementClass || options.errorClass || configuration.errorElementClass;
			options.errorMessageClass = options.errorMessageClass || options.errorClass || configuration.errorMessageClass;

			extend(configuration, options);

			if (configuration.registerExtenders) {
				kv.registerExtenders();
			}

			isInitialized = 1;
		},

		// resets the config back to its original state
		reset: kv.configuration.reset,

		// recursively walks a viewModel and creates an object that
		// provides validation information for the entire viewModel
		// obj -> the viewModel to walk
		// options -> {
		//	  deep: false, // if true, will walk past the first level of viewModel properties
		//	  observable: false // if true, returns a computed observable indicating if the viewModel is valid
		// }
		group: function group(obj, options) { // array of observables or viewModel
			options = extend(extend({}, configuration.grouping), options);

			var context = {
				options: options,
				graphMonitor: ko.observable(),
				flagged: [],
				subscriptions: [],
				validatables: []
			};

			var result = null;

			//if using observables then traverse structure once and add observables
			if (options.observable) {
				result = ko.computed(function () {
					context.graphMonitor(); //register dependency
					runTraversal(obj, context);
					return collectErrors(context.validatables);
				});
			}
			else { //if not using observables then every call to error() should traverse the structure
				result = function () {
					runTraversal(obj, context);
					return collectErrors(context.validatables);
				};
			}

			result.showAllMessages = function (show) { // thanks @heliosPortal
				if (show === undefined) {//default to true
					show = true;
				}

				result.forEach(function (observable) {
					if (utils.isValidatable(observable)) {
						observable.isModified(show);
					}
				});
			};

			result.isAnyMessageShown = function () {
				var invalidAndModifiedPresent;

				invalidAndModifiedPresent = !!result.find(function (observable) {
					return utils.isValidatable(observable) && !observable.isValid() && observable.isModified();
				});
				return invalidAndModifiedPresent;
			};

			result.filter = function(predicate) {
				predicate = predicate || function () { return true; };
				// ensure we have latest changes
				result();

				return koUtils.arrayFilter(context.validatables, predicate);
			};

			result.find = function(predicate) {
				predicate = predicate || function () { return true; };
				// ensure we have latest changes
				result();

				return koUtils.arrayFirst(context.validatables, predicate);
			};

			result.forEach = function(callback) {
				callback = callback || function () { };
				// ensure we have latest changes
				result();

				forEach(context.validatables, callback);
			};

			result.map = function(mapping) {
				mapping = mapping || function (item) { return item; };
				// ensure we have latest changes
				result();

				return koUtils.arrayMap(context.validatables, mapping);
			};

			/**
			 * @private You should not rely on this method being here.
			 * It's a private method and it may change in the future.
			 *
			 * @description Updates the validated object and collects errors from it.
			 */
			result._updateState = function(newValue) {
				if (!utils.isObject(newValue)) {
					throw new Error('An object is required.');
				}
				obj = newValue;
				if (options.observable) {
					context.graphMonitor.valueHasMutated();
				}
				else {
					runTraversal(newValue, context);
					return collectErrors(context.validatables);
				}
			};
			return result;
		},

		formatMessage: function (message, params, observable) {
			if (utils.isObject(params) && params.typeAttr) {
				params = params.value;
			}
			if (typeof message === 'function') {
				return message(params, observable);
			}
			var replacements = unwrap(params);
            if (replacements == null) {
                replacements = [];
            }
			if (!utils.isArray(replacements)) {
				replacements = [replacements];
			}
			return message.replace(/{(\d+)}/gi, function(match, index) {
				if (typeof replacements[index] !== 'undefined') {
					return replacements[index];
				}
				return match;
			});
		},

		// addRule:
		// This takes in a ko.observable and a Rule Context - which is just a rule name and params to supply to the validator
		// ie: kv.addRule(myObservable, {
		//		  rule: 'required',
		//		  params: true
		//	  });
		//
		addRule: function (observable, rule) {
			observable.extend({ validatable: true });

			var hasRule = !!koUtils.arrayFirst(observable.rules(), function(item) {
				return item.rule && item.rule === rule.rule;
			});

			if (!hasRule) {
				//push a Rule Context to the observables local array of Rule Contexts
				observable.rules.push(rule);
			}
			return observable;
		},

		// addAnonymousRule:
		// Anonymous Rules essentially have all the properties of a Rule, but are only specific for a certain property
		// and developers typically are wanting to add them on the fly or not register a rule with the 'kv.rules' object
		//
		// Example:
		// var test = ko.observable('something').extend{(
		//	  validation: {
		//		  validator: function(val, someOtherVal){
		//			  return true;
		//		  },
		//		  message: "Something must be really wrong!',
		//		  params: true
		//	  }
		//  )};
		addAnonymousRule: function (observable, ruleObj) {
			if (ruleObj['message'] === undefined) {
				ruleObj['message'] = 'Error';
			}

			//make sure onlyIf is honoured
			if (ruleObj.onlyIf) {
				ruleObj.condition = ruleObj.onlyIf;
			}

			//add the anonymous rule to the observable
			kv.addRule(observable, ruleObj);
		},

		addExtender: function (ruleName) {
			ko.extenders[ruleName] = function (observable, params) {
				//params can come in a few flavors
				// 1. Just the params to be passed to the validator
				// 2. An object containing the Message to be used and the Params to pass to the validator
				// 3. A condition when the validation rule to be applied
				//
				// Example:
				// var test = ko.observable(3).extend({
				//	  max: {
				//		  message: 'This special field has a Max of {0}',
				//		  params: 2,
				//		  onlyIf: function() {
				//					  return specialField.IsVisible();
				//				  }
				//	  }
				//  )};
				//
				if (params && (params.message || params.onlyIf)) { //if it has a message or condition object, then its an object literal to use
					return kv.addRule(observable, {
						rule: ruleName,
						message: params.message,
						params: utils.isEmptyVal(params.params) ? true : params.params,
						condition: params.onlyIf
					});
				} else {
					return kv.addRule(observable, {
						rule: ruleName,
						params: params
					});
				}
			};
		},

		// loops through all kv.rules and adds them as extenders to
		// ko.extenders
		registerExtenders: function () { // root extenders optional, use 'validation' extender if would cause conflicts
			if (configuration.registerExtenders) {
				for (var ruleName in kv.rules) {
					if (kv.rules.hasOwnProperty(ruleName)) {
						if (!ko.extenders[ruleName]) {
							kv.addExtender(ruleName);
						}
					}
				}
			}
		},

		//creates a span next to the @element with the specified error class
		insertValidationMessage: function (element) {
			var span = document.createElement('SPAN');
			span.className = utils.getConfigOptions(element).errorMessageClass;
			utils.insertAfter(element, span);
			return span;
		},

		// if html-5 validation attributes have been specified, this parses
		// the attributes on @element
		parseInputValidationAttributes: function (element, valueAccessor) {
			forEach(kv.configuration.html5Attributes, function (attr) {
				if (utils.hasAttribute(element, attr)) {

					var params = element.getAttribute(attr) || true;

					if (attr === 'min' || attr === 'max')
					{
						// If we're validating based on the min and max attributes, we'll
						// need to know what the 'type' attribute is set to
						var typeAttr = element.getAttribute('type');
						if (typeof typeAttr === "undefined" || !typeAttr)
						{
							// From http://www.w3.org/TR/html-markup/input:
							//   An input element with no type attribute specified represents the
							//   same thing as an input element with its type attribute set to "text".
							typeAttr = "text";
						}
						params = {typeAttr: typeAttr, value: params};
					}

					kv.addRule(valueAccessor(), {
						rule: attr,
						params: params
					});
				}
			});

			var currentType = element.getAttribute('type');
			forEach(kv.configuration.html5InputTypes, function (type) {
				if (type === currentType) {
					kv.addRule(valueAccessor(), {
						rule: (type === 'date') ? 'dateISO' : type,
						params: true
					});
				}
			});
		},

		// writes html5 validation attributes on the element passed in
		writeInputValidationAttributes: function (element, valueAccessor) {
			var observable = valueAccessor();

			if (!observable || !observable.rules) {
				return;
			}

			var contexts = observable.rules(); // observable array

			// loop through the attributes and add the information needed
			forEach(kv.configuration.html5Attributes, function (attr) {
				var ctx = koUtils.arrayFirst(contexts, function (ctx) {
					return ctx.rule && ctx.rule.toLowerCase() === attr.toLowerCase();
				});

				if (!ctx) {
					return;
				}

				// we have a rule matching a validation attribute at this point
				// so lets add it to the element along with the params
				ko.computed({
					read: function() {
						var params = ko.unwrap(ctx.params);

						// we have to do some special things for the pattern validation
						if (ctx.rule === "pattern" && params instanceof RegExp) {
							// we need the pure string representation of the RegExpr without the //gi stuff
							params = params.source;
						}

						element.setAttribute(attr, params);
					},
					disposeWhenNodeIsRemoved: element
				});
			});

			contexts = null;
		},

		//take an existing binding handler and make it cause automatic validations
		makeBindingHandlerValidatable: function (handlerName) {
			var init = ko.bindingHandlers[handlerName].init;

			ko.bindingHandlers[handlerName].init = function (element, valueAccessor, allBindingsAccessor, viewModel, bindingContext) {

				init(element, valueAccessor, allBindingsAccessor, viewModel, bindingContext);

				return ko.bindingHandlers['validationCore'].init(element, valueAccessor, allBindingsAccessor, viewModel, bindingContext);
			};
		},

		// visit an objects properties and apply validation rules from a definition
		setRules: function (target, definition) {
			var setRules = function (target, definition) {
				if (!target || !definition) { return; }

				for (var prop in definition) {
					if (!definition.hasOwnProperty(prop)) { continue; }
					var ruleDefinitions = definition[prop];

					//check the target property exists and has a value
					if (!target[prop]) { continue; }
					var targetValue = target[prop],
						unwrappedTargetValue = unwrap(targetValue),
						rules = {},
						nonRules = {};

					for (var rule in ruleDefinitions) {
						if (!ruleDefinitions.hasOwnProperty(rule)) { continue; }
						if (kv.rules[rule]) {
							rules[rule] = ruleDefinitions[rule];
						} else {
							nonRules[rule] = ruleDefinitions[rule];
						}
					}

					//apply rules
					if (ko.isObservable(targetValue)) {
						targetValue.extend(rules);
					}

					//then apply child rules
					//if it's an array, apply rules to all children
					if (unwrappedTargetValue && utils.isArray(unwrappedTargetValue)) {
						for (var i = 0; i < unwrappedTargetValue.length; i++) {
							setRules(unwrappedTargetValue[i], nonRules);
						}
						//otherwise, just apply to this property
					} else {
						setRules(unwrappedTargetValue, nonRules);
					}
				}
			};
			setRules(target, definition);
		}
	};

}());

// expose api publicly
extend(ko.validation, api);
;//Validation Rules:
// You can view and override messages or rules via:
// kv.rules[ruleName]
//
// To implement a custom Rule, simply use this template:
// kv.rules['<custom rule name>'] = {
//      validator: function (val, param) {
//          <custom logic>
//          return <true or false>;
//      },
//      message: '<custom validation message>' //optionally you can also use a '{0}' to denote a placeholder that will be replaced with your 'param'
// };
//
// Example:
// kv.rules['mustEqual'] = {
//      validator: function( val, mustEqualVal ){
//          return val === mustEqualVal;
//      },
//      message: 'This field must equal {0}'
// };
//
kv.rules = {};
kv.rules['required'] = {
	validator: function (val, required) {
		var testVal;

		if (val === undefined || val === null) {
			return !required;
		}

		testVal = val;
		if (typeof (val) === 'string') {
			if (String.prototype.trim) {
				testVal = val.trim();
			}
			else {
				testVal = val.replace(/^\s+|\s+$/g, '');
			}
		}

		if (!required) {// if they passed: { required: false }, then don't require this
			return true;
		}

		return ((testVal + '').length > 0);
	},
	message: 'This field is required.'
};

function minMaxValidatorFactory(validatorName) {
    var isMaxValidation = validatorName === "max";

    return function (val, options) {
        if (kv.utils.isEmptyVal(val)) {
            return true;
        }

        var comparisonValue, type;
        if (options.typeAttr === undefined) {
            // This validator is being called from javascript rather than
            // being bound from markup
            type = "text";
            comparisonValue = options;
        } else {
            type = options.typeAttr;
            comparisonValue = options.value;
        }

        // From http://www.w3.org/TR/2012/WD-html5-20121025/common-input-element-attributes.html#attr-input-min,
        // if the value is parseable to a number, then the minimum should be numeric
        if (!isNaN(comparisonValue) && !(comparisonValue instanceof Date)) {
            type = "number";
        }

        var regex, valMatches, comparisonValueMatches;
        switch (type.toLowerCase()) {
            case "week":
                regex = /^(\d{4})-W(\d{2})$/;
                valMatches = val.match(regex);
                if (valMatches === null) {
                    throw new Error("Invalid value for " + validatorName + " attribute for week input.  Should look like " +
                        "'2000-W33' http://www.w3.org/TR/html-markup/input.week.html#input.week.attrs.min");
                }
                comparisonValueMatches = comparisonValue.match(regex);
                // If no regex matches were found, validation fails
                if (!comparisonValueMatches) {
                    return false;
                }

                if (isMaxValidation) {
                    return (valMatches[1] < comparisonValueMatches[1]) || // older year
                        // same year, older week
                        ((valMatches[1] === comparisonValueMatches[1]) && (valMatches[2] <= comparisonValueMatches[2]));
                } else {
                    return (valMatches[1] > comparisonValueMatches[1]) || // newer year
                        // same year, newer week
                        ((valMatches[1] === comparisonValueMatches[1]) && (valMatches[2] >= comparisonValueMatches[2]));
                }
                break;

            case "month":
                regex = /^(\d{4})-(\d{2})$/;
                valMatches = val.match(regex);
                if (valMatches === null) {
                    throw new Error("Invalid value for " + validatorName + " attribute for month input.  Should look like " +
                        "'2000-03' http://www.w3.org/TR/html-markup/input.month.html#input.month.attrs.min");
                }
                comparisonValueMatches = comparisonValue.match(regex);
                // If no regex matches were found, validation fails
                if (!comparisonValueMatches) {
                    return false;
                }

                if (isMaxValidation) {
                    return ((valMatches[1] < comparisonValueMatches[1]) || // older year
                        // same year, older month
                        ((valMatches[1] === comparisonValueMatches[1]) && (valMatches[2] <= comparisonValueMatches[2])));
                } else {
                    return (valMatches[1] > comparisonValueMatches[1]) || // newer year
                        // same year, newer month
                        ((valMatches[1] === comparisonValueMatches[1]) && (valMatches[2] >= comparisonValueMatches[2]));
                }
                break;

            case "number":
            case "range":
                if (isMaxValidation) {
                    return (!isNaN(val) && parseFloat(val) <= parseFloat(comparisonValue));
                } else {
                    return (!isNaN(val) && parseFloat(val) >= parseFloat(comparisonValue));
                }
                break;

            default:
                if (isMaxValidation) {
                    return val <= comparisonValue;
                } else {
                    return val >= comparisonValue;
                }
        }
    };
}

kv.rules['min'] = {
	validator: minMaxValidatorFactory("min"),
	message: 'Please enter a value greater than or equal to {0}.'
};

kv.rules['max'] = {
	validator: minMaxValidatorFactory("max"),
	message: 'Please enter a value less than or equal to {0}.'
};

kv.rules['minLength'] = {
	validator: function (val, minLength) {
		if(kv.utils.isEmptyVal(val)) { return true; }
		var normalizedVal = kv.utils.isNumber(val) ? ('' + val) : val;
		return normalizedVal.length >= minLength;
	},
	message: 'Please enter at least {0} characters.'
};

kv.rules['maxLength'] = {
	validator: function (val, maxLength) {
		if(kv.utils.isEmptyVal(val)) { return true; }
		var normalizedVal = kv.utils.isNumber(val) ? ('' + val) : val;
		return normalizedVal.length <= maxLength;
	},
	message: 'Please enter no more than {0} characters.'
};

kv.rules['pattern'] = {
	validator: function (val, regex) {
		return kv.utils.isEmptyVal(val) || val.toString().match(regex) !== null;
	},
	message: 'Please check this value.'
};

kv.rules['step'] = {
	validator: function (val, step) {

		// in order to handle steps of .1 & .01 etc.. Modulus won't work
		// if the value is a decimal, so we have to correct for that
		if (kv.utils.isEmptyVal(val) || step === 'any') { return true; }
		var dif = (val * 100) % (step * 100);
		return Math.abs(dif) < 0.00001 || Math.abs(1 - dif) < 0.00001;
	},
	message: 'The value must increment by {0}.'
};

kv.rules['email'] = {
	validator: function (val, validate) {
		if (!validate) { return true; }

		//I think an empty email address is also a valid entry
		//if one want's to enforce entry it should be done with 'required: true'
		return kv.utils.isEmptyVal(val) || (
			// jquery validate regex - thanks Scott Gonzalez
			validate && /^((([a-z]|\d|[!#\$%&'\*\+\-\/=\?\^_`{\|}~]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])+(\.([a-z]|\d|[!#\$%&'\*\+\-\/=\?\^_`{\|}~]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])+)*)|((\x22)((((\x20|\x09)*(\x0d\x0a))?(\x20|\x09)+)?(([\x01-\x08\x0b\x0c\x0e-\x1f\x7f]|\x21|[\x23-\x5b]|[\x5d-\x7e]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(\\([\x01-\x09\x0b\x0c\x0d-\x7f]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]))))*(((\x20|\x09)*(\x0d\x0a))?(\x20|\x09)+)?(\x22)))@((([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.)+(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))$/i.test(val)
		);
	},
	message: 'Please enter a proper email address.'
};

kv.rules['date'] = {
	validator: function (value, validate) {
		if (!validate) { return true; }
		return kv.utils.isEmptyVal(value) || (validate && !/Invalid|NaN/.test(new Date(value)));
	},
	message: 'Please enter a proper date.'
};

kv.rules['dateISO'] = {
	validator: function (value, validate) {
		if (!validate) { return true; }
		return kv.utils.isEmptyVal(value) || (validate && /^\d{4}[-/](?:0?[1-9]|1[012])[-/](?:0?[1-9]|[12][0-9]|3[01])$/.test(value));
	},
	message: 'Please enter a proper date.'
};

kv.rules['number'] = {
	validator: function (value, validate) {
		if (!validate) { return true; }
		return kv.utils.isEmptyVal(value) || (validate && /^-?(?:\d+|\d{1,3}(?:,\d{3})+)?(?:\.\d+)?$/.test(value));
	},
	message: 'Please enter a number.'
};

kv.rules['digit'] = {
	validator: function (value, validate) {
		if (!validate) { return true; }
		return kv.utils.isEmptyVal(value) || (validate && /^\d+$/.test(value));
	},
	message: 'Please enter a digit.'
};

kv.rules['phoneUS'] = {
	validator: function (phoneNumber, validate) {
		if (!validate) { return true; }
		if (kv.utils.isEmptyVal(phoneNumber)) { return true; } // makes it optional, use 'required' rule if it should be required
		if (typeof (phoneNumber) !== 'string') { return false; }
		phoneNumber = phoneNumber.replace(/\s+/g, "");
		return validate && phoneNumber.length > 9 && phoneNumber.match(/^(1-?)?(\([2-9]\d{2}\)|[2-9]\d{2})-?[2-9]\d{2}-?\d{4}$/);
	},
	message: 'Please specify a valid phone number.'
};

kv.rules['equal'] = {
	validator: function (val, params) {
		var otherValue = params;
		return val === kv.utils.getValue(otherValue);
	},
	message: 'Values must equal.'
};

kv.rules['notEqual'] = {
	validator: function (val, params) {
		var otherValue = params;
		return val !== kv.utils.getValue(otherValue);
	},
	message: 'Please choose another value.'
};

//unique in collection
// options are:
//    collection: array or function returning (observable) array
//              in which the value has to be unique
//    valueAccessor: function that returns value from an object stored in collection
//              if it is null the value is compared directly
//    external: set to true when object you are validating is automatically updating collection
kv.rules['unique'] = {
	validator: function (val, options) {
		var c = kv.utils.getValue(options.collection),
			external = kv.utils.getValue(options.externalValue),
			counter = 0;

		if (!val || !c) { return true; }

		koUtils.arrayFilter(c, function (item) {
			if (val === (options.valueAccessor ? options.valueAccessor(item) : item)) { counter++; }
		});
		// if value is external even 1 same value in collection means the value is not unique
		return counter < (!!external ? 1 : 2);
	},
	message: 'Please make sure the value is unique.'
};


//now register all of these!
(function () {
	kv.registerExtenders();
}());
;// The core binding handler
// this allows us to setup any value binding that internally always
// performs the same functionality
ko.bindingHandlers['validationCore'] = (function () {

	return {
		init: function (element, valueAccessor, allBindingsAccessor, viewModel, bindingContext) {
			var config = kv.utils.getConfigOptions(element);
			var observable = valueAccessor();

			// parse html5 input validation attributes, optional feature
			if (config.parseInputAttributes) {
				kv.utils.async(function () { kv.parseInputValidationAttributes(element, valueAccessor); });
			}

			// if requested insert message element and apply bindings
			if (config.insertMessages && kv.utils.isValidatable(observable)) {

				// insert the <span></span>
				var validationMessageElement = kv.insertValidationMessage(element);

				// if we're told to use a template, make sure that gets rendered
				if (config.messageTemplate) {
					ko.renderTemplate(config.messageTemplate, { field: observable }, null, validationMessageElement, 'replaceNode');
				} else {
					ko.applyBindingsToNode(validationMessageElement, { validationMessage: observable });
				}
			}

			// write the html5 attributes if indicated by the config
			if (config.writeInputAttributes && kv.utils.isValidatable(observable)) {

				kv.writeInputValidationAttributes(element, valueAccessor);
			}

			// if requested, add binding to decorate element
			if (config.decorateInputElement && kv.utils.isValidatable(observable)) {
				ko.applyBindingsToNode(element, { validationElement: observable });
			}
		}
	};

}());

// override for KO's default 'value', 'checked', 'textInput' and selectedOptions bindings
kv.makeBindingHandlerValidatable("value");
kv.makeBindingHandlerValidatable("checked");
if (ko.bindingHandlers.textInput) {
	kv.makeBindingHandlerValidatable("textInput");
}
kv.makeBindingHandlerValidatable("selectedOptions");


ko.bindingHandlers['validationMessage'] = { // individual error message, if modified or post binding
	update: function (element, valueAccessor) {
		var obsv = valueAccessor(),
			config = kv.utils.getConfigOptions(element),
			val = unwrap(obsv),
			msg = null,
			isModified = false,
			isValid = false;

		if (obsv === null || typeof obsv === 'undefined') {
			throw new Error('Cannot bind validationMessage to undefined value. data-bind expression: ' +
				element.getAttribute('data-bind'));
		}

		isModified = obsv.isModified && obsv.isModified();
		isValid = obsv.isValid && obsv.isValid();

		var error = null;
		if (!config.messagesOnModified || isModified) {
			error = isValid ? null : obsv.error;
		}

		var isVisible = !config.messagesOnModified || isModified ? !isValid : false;
		var isCurrentlyVisible = element.style.display !== "none";

		if (config.allowHtmlMessages) {
			koUtils.setHtml(element, error);
		} else {
			ko.bindingHandlers.text.update(element, function () { return error; });
		}

		if (isCurrentlyVisible && !isVisible) {
			element.style.display = 'none';
		} else if (!isCurrentlyVisible && isVisible) {
			element.style.display = '';
		}
	}
};

ko.bindingHandlers['validationElement'] = {
	update: function (element, valueAccessor, allBindingsAccessor) {
		var obsv = valueAccessor(),
			config = kv.utils.getConfigOptions(element),
			val = unwrap(obsv),
			msg = null,
			isModified = false,
			isValid = false;

		if (obsv === null || typeof obsv === 'undefined') {
			throw new Error('Cannot bind validationElement to undefined value. data-bind expression: ' +
				element.getAttribute('data-bind'));
		}

		isModified = obsv.isModified && obsv.isModified();
		isValid = obsv.isValid && obsv.isValid();

		// create an evaluator function that will return something like:
		// css: { validationElement: true }
		var cssSettingsAccessor = function () {
			var css = {};

			var shouldShow = ((!config.decorateElementOnModified || isModified) ? !isValid : false);

			// css: { validationElement: false }
			css[config.errorElementClass] = shouldShow;

			return css;
		};

		//add or remove class on the element;
		ko.bindingHandlers.css.update(element, cssSettingsAccessor, allBindingsAccessor);
		if (!config.errorsAsTitle) { return; }

		ko.bindingHandlers.attr.update(element, function () {
			var
				hasModification = !config.errorsAsTitleOnModified || isModified,
				title = kv.utils.getOriginalElementTitle(element);

			if (hasModification && !isValid) {
				return { title: obsv.error, 'data-orig-title': title };
			} else if (!hasModification || isValid) {
				return { title: title, 'data-orig-title': null };
			}
		});
	}
};

// ValidationOptions:
// This binding handler allows you to override the initial config by setting any of the options for a specific element or context of elements
//
// Example:
// <div data-bind="validationOptions: { insertMessages: true, messageTemplate: 'customTemplate', errorMessageClass: 'mySpecialClass'}">
//      <input type="text" data-bind="value: someValue"/>
//      <input type="text" data-bind="value: someValue2"/>
// </div>
ko.bindingHandlers['validationOptions'] = (function () {
	return {
		init: function (element, valueAccessor, allBindingsAccessor, viewModel, bindingContext) {
			var options = unwrap(valueAccessor());
			if (options) {
				var newConfig = extend({}, kv.configuration);
				extend(newConfig, options);

				//store the validation options on the node so we can retrieve it later
				kv.utils.setDomData(element, newConfig);
			}
		}
	};
}());
;// Validation Extender:
// This is for creating custom validation logic on the fly
// Example:
// var test = ko.observable('something').extend{(
//      validation: {
//          validator: function(val, someOtherVal){
//              return true;
//          },
//          message: "Something must be really wrong!',
//          params: true
//      }
//  )};
ko.extenders['validation'] = function (observable, rules) { // allow single rule or array
	forEach(kv.utils.isArray(rules) ? rules : [rules], function (rule) {
		// the 'rule' being passed in here has no name to identify a core Rule,
		// so we add it as an anonymous rule
		// If the developer is wanting to use a core Rule, but use a different message see the 'addExtender' logic for examples
		kv.addAnonymousRule(observable, rule);
	});
	return observable;
};

//This is the extender that makes a Knockout Observable also 'Validatable'
//examples include:
// 1. var test = ko.observable('something').extend({validatable: true});
// this will ensure that the Observable object is setup properly to respond to rules
//
// 2. test.extend({validatable: false});
// this will remove the validation properties from the Observable object should you need to do that.
ko.extenders['validatable'] = function (observable, options) {
	if (!kv.utils.isObject(options)) {
		options = { enable: options };
	}

	if (!('enable' in options)) {
		options.enable = true;
	}

	if (options.enable && !kv.utils.isValidatable(observable)) {
		var config = kv.configuration.validate || {};
		var validationOptions = {
			throttleEvaluation : options.throttle || config.throttle
		};

		observable.error = ko.observable(null); // holds the error message, we only need one since we stop processing validators when one is invalid

		// observable.rules:
		// ObservableArray of Rule Contexts, where a Rule Context is simply the name of a rule and the params to supply to it
		//
		// Rule Context = { rule: '<rule name>', params: '<passed in params>', message: '<Override of default Message>' }
		observable.rules = ko.observableArray(); //holds the rule Contexts to use as part of validation

		//in case async validation is occurring
		observable.isValidating = ko.observable(false);

		//the true holder of whether the observable is valid or not
		observable.__valid__ = ko.observable(true);

		observable.isModified = ko.observable(false);

		// a semi-protected observable
		observable.isValid = ko.computed(observable.__valid__);

		//manually set error state
		observable.setError = function (error) {
			var previousError = observable.error.peek();
			var previousIsValid = observable.__valid__.peek();

			observable.error(error);
			observable.__valid__(false);

			if (previousError !== error && !previousIsValid) {
				// if the observable was not valid before then isValid will not mutate,
				// hence causing any grouping to not display the latest error.
				observable.isValid.notifySubscribers();
			}
		};

		//manually clear error state
		observable.clearError = function () {
			observable.error(null);
			observable.__valid__(true);
			return observable;
		};

		//subscribe to changes in the observable
		var h_change = observable.subscribe(function () {
			observable.isModified(true);
		});

		// we use a computed here to ensure that anytime a dependency changes, the
		// validation logic evaluates
		var h_obsValidationTrigger = ko.computed(extend({
			read: function () {
				var obs = observable(),
					ruleContexts = observable.rules();

				kv.validateObservable(observable);

				return true;
			}
		}, validationOptions));

		extend(h_obsValidationTrigger, validationOptions);

		observable._disposeValidation = function () {
			//first dispose of the subscriptions
			observable.isValid.dispose();
			observable.rules.removeAll();
			h_change.dispose();
			h_obsValidationTrigger.dispose();

			delete observable['rules'];
			delete observable['error'];
			delete observable['isValid'];
			delete observable['isValidating'];
			delete observable['__valid__'];
			delete observable['isModified'];
            delete observable['setError'];
            delete observable['clearError'];
            delete observable['_disposeValidation'];
		};
	} else if (options.enable === false && observable._disposeValidation) {
		observable._disposeValidation();
	}
	return observable;
};

function validateSync(observable, rule, ctx) {
	//Execute the validator and see if its valid
	if (!rule.validator(observable(), (ctx.params === undefined ? true : unwrap(ctx.params)))) { // default param is true, eg. required = true

		//not valid, so format the error message and stick it in the 'error' variable
		observable.setError(kv.formatMessage(
					ctx.message || rule.message,
					unwrap(ctx.params),
					observable));
		return false;
	} else {
		return true;
	}
}

function validateAsync(observable, rule, ctx) {
	observable.isValidating(true);

	var callBack = function (valObj) {
		var isValid = false,
			msg = '';

		if (!observable.__valid__()) {

			// since we're returning early, make sure we turn this off
			observable.isValidating(false);

			return; //if its already NOT valid, don't add to that
		}

		//we were handed back a complex object
		if (valObj['message']) {
			isValid = valObj.isValid;
			msg = valObj.message;
		} else {
			isValid = valObj;
		}

		if (!isValid) {
			//not valid, so format the error message and stick it in the 'error' variable
			observable.error(kv.formatMessage(
				msg || ctx.message || rule.message,
				unwrap(ctx.params),
				observable));
			observable.__valid__(isValid);
		}

		// tell it that we're done
		observable.isValidating(false);
	};

	kv.utils.async(function() {
	    //fire the validator and hand it the callback
        rule.validator(observable(), ctx.params === undefined ? true : unwrap(ctx.params), callBack);
	});
}

kv.validateObservable = function (observable) {
	var i = 0,
		rule, // the rule validator to execute
		ctx, // the current Rule Context for the loop
		ruleContexts = observable.rules(), //cache for iterator
		len = ruleContexts.length; //cache for iterator

	for (; i < len; i++) {

		//get the Rule Context info to give to the core Rule
		ctx = ruleContexts[i];

		// checks an 'onlyIf' condition
		if (ctx.condition && !ctx.condition()) {
			continue;
		}

		//get the core Rule to use for validation
		rule = ctx.rule ? kv.rules[ctx.rule] : ctx;

		if (rule['async'] || ctx['async']) {
			//run async validation
			validateAsync(observable, rule, ctx);

		} else {
			//run normal sync validation
			if (!validateSync(observable, rule, ctx)) {
				return false; //break out of the loop
			}
		}
	}
	//finally if we got this far, make the observable valid again!
	observable.clearError();
	return true;
};
;
var _locales = {};
var _currentLocale;

kv.defineLocale = function(name, values) {
	if (name && values) {
		_locales[name.toLowerCase()] = values;
		return values;
	}
	return null;
};

kv.locale = function(name) {
	if (name) {
		name = name.toLowerCase();

		if (_locales.hasOwnProperty(name)) {
			kv.localize(_locales[name]);
			_currentLocale = name;
		}
		else {
			throw new Error('Localization ' + name + ' has not been loaded.');
		}
	}
	return _currentLocale;
};

//quick function to override rule messages
kv.localize = function (msgTranslations) {
	var rules = kv.rules;

	//loop the properties in the object and assign the msg to the rule
	for (var ruleName in msgTranslations) {
		if (rules.hasOwnProperty(ruleName)) {
			rules[ruleName].message = msgTranslations[ruleName];
		}
	}
};

// Populate default locale (this will make en-US.js somewhat redundant)
(function() {
	var localeData = {};
	var rules = kv.rules;

	for (var ruleName in rules) {
		if (rules.hasOwnProperty(ruleName)) {
			localeData[ruleName] = rules[ruleName].message;
		}
	}
	kv.defineLocale('en-us', localeData);
})();

// No need to invoke locale because the messages are already defined along with the rules for en-US
_currentLocale = 'en-us';
;/**
 * Possible invocations:
 * 		applyBindingsWithValidation(viewModel)
 * 		applyBindingsWithValidation(viewModel, options)
 * 		applyBindingsWithValidation(viewModel, rootNode)
 *		applyBindingsWithValidation(viewModel, rootNode, options)
 */
ko.applyBindingsWithValidation = function (viewModel, rootNode, options) {
	var node = document.body,
		config;

	if (rootNode && rootNode.nodeType) {
		node = rootNode;
		config = options;
	}
	else {
		config = rootNode;
	}

	kv.init();

	if (config) {
		config = extend(extend({}, kv.configuration), config);
		kv.utils.setDomData(node, config);
	}

	ko.applyBindings(viewModel, node);
};

//override the original applyBindings so that we can ensure all new rules and what not are correctly registered
var origApplyBindings = ko.applyBindings;
ko.applyBindings = function (viewModel, rootNode) {

	kv.init();

	origApplyBindings(viewModel, rootNode);
};

ko.validatedObservable = function (initialValue, options) {
	if (!options && !kv.utils.isObject(initialValue)) {
		return ko.observable(initialValue).extend({ validatable: true });
	}

	var obsv = ko.observable(initialValue);
	obsv.errors = kv.group(kv.utils.isObject(initialValue) ? initialValue : {}, options);
	obsv.isValid = ko.observable(obsv.errors().length === 0);

	if (ko.isObservable(obsv.errors)) {
		obsv.errors.subscribe(function(errors) {
			obsv.isValid(errors.length === 0);
		});
	}
	else {
		ko.computed(obsv.errors).subscribe(function (errors) {
			obsv.isValid(errors.length === 0);
		});
	}

	obsv.subscribe(function(newValue) {
		if (!kv.utils.isObject(newValue)) {
			/*
			 * The validation group works on objects.
			 * Since the new value is a primitive (scalar, null or undefined) we need
			 * to create an empty object to pass along.
			 */
			newValue = {};
		}
		// Force the group to refresh
		obsv.errors._updateState(newValue);
		obsv.isValid(obsv.errors().length === 0);
	});

	return obsv;
};
;}));

/***/ }),
/* 62 */
/***/ (function(module, exports) {

// http://stackoverflow.com/questions/10343913/how-to-create-a-web-worker-from-a-string

var URL = window.URL || window.webkitURL;
module.exports = function(content, url) {
	try {
		try {
			var blob;
			try { // BlobBuilder = Deprecated, but widely implemented
				var BlobBuilder = window.BlobBuilder || window.WebKitBlobBuilder || window.MozBlobBuilder || window.MSBlobBuilder;
				blob = new BlobBuilder();
				blob.append(content);
				blob = blob.getBlob();
			} catch(e) { // The proposed API
				blob = new Blob([content]);
			}
			return new Worker(URL.createObjectURL(blob));
		} catch(e) {
			return new Worker('data:application/javascript,' + encodeURIComponent(content));
		}
	} catch(e) {
		return new Worker(url);
	}
}

/***/ }),
/* 63 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(8);


/***/ })
/******/ ]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAgNGJjNGZhMGIyMGE2ZmY0MTM4MzIiLCJ3ZWJwYWNrOi8vLy4vfi9rbm9ja291dC9idWlsZC9vdXRwdXQva25vY2tvdXQtbGF0ZXN0LmRlYnVnLmpzPzYwODMiLCJ3ZWJwYWNrOi8vLy4vfi9qcXVlcnkvZGlzdC9qcXVlcnkuanMiLCJ3ZWJwYWNrOi8vLy4vc2NyaXB0cy9hcGktZXhwbG9yZXIvdjIvc3JjL3NlcnZpY2VzL2luZGV4LmpzIiwid2VicGFjazovLy8od2VicGFjaykvYnVpbGRpbi9nbG9iYWwuanMiLCJ3ZWJwYWNrOi8vLy4vfi9rbm9ja291dC9idWlsZC9vdXRwdXQva25vY2tvdXQtbGF0ZXN0LmRlYnVnLmpzIiwid2VicGFjazovLy8uL3NjcmlwdHMvYXBpLWV4cGxvcmVyL3YyL3NyYy9zZXJ2aWNlcy9hcGlLZXkuc2VydmljZS5qcyIsIndlYnBhY2s6Ly8vLi9zY3JpcHRzL2FwaS1leHBsb3Jlci92Mi9zcmMvc2VydmljZXMvYmFzZS5zZXJ2aWNlLmpzIiwid2VicGFjazovLy8uL3NjcmlwdHMvYXBpLWV4cGxvcmVyL3YyL3NyYy9zZXJ2aWNlcy9yZXN0LnNlcnZpY2UuanMiLCJ3ZWJwYWNrOi8vLy4vc2NyaXB0cy9hcGktZXhwbG9yZXIvdjIvc3JjL21haW4uZXM2LmpzIiwid2VicGFjazovLy8uL3NjcmlwdHMvYXBpLWV4cGxvcmVyL3YyL3NyYy9zZXJ2aWNlcy9qc29uLWhpZ2hsaWdodC9oaWdobGlnaHRKc29uLndvcmtlci5qcyIsIndlYnBhY2s6Ly8vLi9zY3JpcHRzL2FwaS1leHBsb3Jlci92Mi9zcmMvY29tcG9uZW50cy9jb21tb24vY3VzdG9tSW5wdXQuY29tcG9uZW50LmpzIiwid2VicGFjazovLy8uL3NjcmlwdHMvYXBpLWV4cGxvcmVyL3YyL3NyYy9jb21wb25lbnRzL2NvbW1vbi9jdXN0b21TZWxlY3QuY29tcG9uZW50LmpzIiwid2VicGFjazovLy8uL3NjcmlwdHMvYXBpLWV4cGxvcmVyL3YyL3NyYy9jb21wb25lbnRzL2NvbW1vbi9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9zY3JpcHRzL2FwaS1leHBsb3Jlci92Mi9zcmMvY29tcG9uZW50cy9maWx0ZXIvYWJvdXRNZXRob2QuY29tcG9uZW50LmpzIiwid2VicGFjazovLy8uL3NjcmlwdHMvYXBpLWV4cGxvcmVyL3YyL3NyYy9jb21wb25lbnRzL2ZpbHRlci9jYXRlZ29yeU1lbnUuY29tcG9uZW50LmpzIiwid2VicGFjazovLy8uL3NjcmlwdHMvYXBpLWV4cGxvcmVyL3YyL3NyYy9jb21wb25lbnRzL2ZpbHRlci9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9zY3JpcHRzL2FwaS1leHBsb3Jlci92Mi9zcmMvY29tcG9uZW50cy9maWx0ZXIvbWV0aG9kc0ZpbHRlci5jb21wb25lbnQuanMiLCJ3ZWJwYWNrOi8vLy4vc2NyaXB0cy9hcGktZXhwbG9yZXIvdjIvc3JjL2NvbXBvbmVudHMvZmlsdGVyL3BhcmFtc0ZpbHRlci5jb21wb25lbnQuanMiLCJ3ZWJwYWNrOi8vLy4vc2NyaXB0cy9hcGktZXhwbG9yZXIvdjIvc3JjL2NvbXBvbmVudHMvZmlsdGVyL3JhZGlvRmlsdGVyLmNvbXBvbmVudC5qcyIsIndlYnBhY2s6Ly8vLi9zY3JpcHRzL2FwaS1leHBsb3Jlci92Mi9zcmMvY29tcG9uZW50cy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9zY3JpcHRzL2FwaS1leHBsb3Jlci92Mi9zcmMvY29tcG9uZW50cy9wYW5lbHMvYXJyYXlQYW5lbEJvZHkuY29tcG9uZW50LmpzIiwid2VicGFjazovLy8uL3NjcmlwdHMvYXBpLWV4cGxvcmVyL3YyL3NyYy9jb21wb25lbnRzL3BhbmVscy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9zY3JpcHRzL2FwaS1leHBsb3Jlci92Mi9zcmMvY29tcG9uZW50cy9wYW5lbHMvbWFwUGFuZWxCb2R5LmNvbXBvbmVudC5qcyIsIndlYnBhY2s6Ly8vLi9zY3JpcHRzL2FwaS1leHBsb3Jlci92Mi9zcmMvY29tcG9uZW50cy9wYW5lbHMvb2JqZWN0UGFuZWxCb2R5LmNvbXBvbmVudC5qcyIsIndlYnBhY2s6Ly8vLi9zY3JpcHRzL2FwaS1leHBsb3Jlci92Mi9zcmMvY29tcG9uZW50cy9wYW5lbHMvcGFnaW5hdGlvbi5jb21wb25lbnQuanMiLCJ3ZWJwYWNrOi8vLy4vc2NyaXB0cy9hcGktZXhwbG9yZXIvdjIvc3JjL2NvbXBvbmVudHMvcGFuZWxzL3BhbmVsLmNvbXBvbmVudC5qcyIsIndlYnBhY2s6Ly8vLi9zY3JpcHRzL2FwaS1leHBsb3Jlci92Mi9zcmMvY29tcG9uZW50cy9wYW5lbHMvcGFuZWxHcm91cC5jb21wb25lbnQuanMiLCJ3ZWJwYWNrOi8vLy4vc2NyaXB0cy9hcGktZXhwbG9yZXIvdjIvc3JjL2NvbXBvbmVudHMvcGFuZWxzL3BhbmVsSGVhZGluZy5jb21wb25lbnQuanMiLCJ3ZWJwYWNrOi8vLy4vc2NyaXB0cy9hcGktZXhwbG9yZXIvdjIvc3JjL2NvbXBvbmVudHMvcG9wdXBzL2Vycm9yLmNvbXBvbmVudC5qcyIsIndlYnBhY2s6Ly8vLi9zY3JpcHRzL2FwaS1leHBsb3Jlci92Mi9zcmMvY29tcG9uZW50cy9wb3B1cHMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vc2NyaXB0cy9hcGktZXhwbG9yZXIvdjIvc3JjL2NvbXBvbmVudHMvcmVxdWVzdC9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9zY3JpcHRzL2FwaS1leHBsb3Jlci92Mi9zcmMvY29tcG9uZW50cy9yZXF1ZXN0L3JlcXVlc3QuY29tcG9uZW50LmpzIiwid2VicGFjazovLy8uL3NjcmlwdHMvYXBpLWV4cGxvcmVyL3YyL3NyYy9jb21wb25lbnRzL3JlcXVlc3QvcmVxdWVzdExpc3QuY29tcG9uZW50LmpzIiwid2VicGFjazovLy8uL3NjcmlwdHMvYXBpLWV4cGxvcmVyL3YyL3NyYy9jb21wb25lbnRzL3JlcXVlc3QvcmVzcG9uc2UuY29tcG9uZW50LmpzIiwid2VicGFjazovLy8uL3NjcmlwdHMvYXBpLWV4cGxvcmVyL3YyL3NyYy9jdXN0b21CaW5kaW5ncy9ibG9ja0VsbGlwc2lzLmJpbmRpbmcuanMiLCJ3ZWJwYWNrOi8vLy4vc2NyaXB0cy9hcGktZXhwbG9yZXIvdjIvc3JjL2N1c3RvbUJpbmRpbmdzL2NsYXNzaWZpY2F0aW9uc01hcC5iaW5kaW5nLmpzIiwid2VicGFjazovLy8uL3NjcmlwdHMvYXBpLWV4cGxvcmVyL3YyL3NyYy9jdXN0b21CaW5kaW5ncy9jb3B5Q2xpcGJvYXJkLmJpbmRpbmcuanMiLCJ3ZWJwYWNrOi8vLy4vc2NyaXB0cy9hcGktZXhwbG9yZXIvdjIvc3JjL2N1c3RvbUJpbmRpbmdzL2ZvcmVhY2hQcm9wLmJpbmRpbmcuanMiLCJ3ZWJwYWNrOi8vLy4vc2NyaXB0cy9hcGktZXhwbG9yZXIvdjIvc3JjL2N1c3RvbUJpbmRpbmdzL2ltZ09uRXJyb3IuYmluZGluZy5qcyIsIndlYnBhY2s6Ly8vLi9zY3JpcHRzL2FwaS1leHBsb3Jlci92Mi9zcmMvY3VzdG9tQmluZGluZ3MvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vc2NyaXB0cy9hcGktZXhwbG9yZXIvdjIvc3JjL2N1c3RvbUJpbmRpbmdzL2xhenlMb2FkZXIuYmluZGluZy5qcyIsIndlYnBhY2s6Ly8vLi9zY3JpcHRzL2FwaS1leHBsb3Jlci92Mi9zcmMvY3VzdG9tQmluZGluZ3MvcG9wb3Zlci5iaW5kaW5nLmpzIiwid2VicGFjazovLy8uL3NjcmlwdHMvYXBpLWV4cGxvcmVyL3YyL3NyYy9tb2R1bGVzL2luZGV4LmpzIiwid2VicGFjazovLy8uL3NjcmlwdHMvYXBpLWV4cGxvcmVyL3YyL3NyYy9tb2R1bGVzL3NsaWRlci5qcyIsIndlYnBhY2s6Ly8vLi9zY3JpcHRzL2FwaS1leHBsb3Jlci92Mi9zcmMvbW9kdWxlcy92YWxpZGF0aW9uLmpzIiwid2VicGFjazovLy8uL3NjcmlwdHMvYXBpLWV4cGxvcmVyL3YyL3NyYy9zZXJ2aWNlcy9jb2xvcnMuc2VydmljZS5qcyIsIndlYnBhY2s6Ly8vLi9zY3JpcHRzL2FwaS1leHBsb3Jlci92Mi9zcmMvc2VydmljZXMvY29uZmlnLnNlcnZpY2UuanMiLCJ3ZWJwYWNrOi8vLy4vc2NyaXB0cy9hcGktZXhwbG9yZXIvdjIvc3JjL3NlcnZpY2VzL2pzb24taGlnaGxpZ2h0L2luZGV4LmpzIiwid2VicGFjazovLy8uL3NjcmlwdHMvYXBpLWV4cGxvcmVyL3YyL3NyYy9zZXJ2aWNlcy9vcHRpb25zL2NvdW50cnkub3B0aW9ucy5qcyIsIndlYnBhY2s6Ly8vLi9zY3JpcHRzL2NvbXBvbmVudHMvY2xhc3NpZmljYXRpb24tc2VsZWN0b3IuanMiLCJ3ZWJwYWNrOi8vLy4vc2NyaXB0cy9jb21wb25lbnRzL2xhenktc2VsZWN0b3IuanMiLCJ3ZWJwYWNrOi8vLy4vc2NyaXB0cy92ZW5kb3JzL2Jvb3RzdHJhcC5taW4uanMiLCJ3ZWJwYWNrOi8vLy4vc2NyaXB0cy92ZW5kb3JzL2NsYW1wLm1pbi5qcyIsIndlYnBhY2s6Ly8vLi9zY3JpcHRzL3ZlbmRvcnMvZGF0ZXRpbWVwaWNrZXIuanMiLCJ3ZWJwYWNrOi8vLy4vc2NyaXB0cy92ZW5kb3JzL2tub2Nrb3V0LXNjcm9sbGJhci5qcyIsIndlYnBhY2s6Ly8vLi9zY3JpcHRzL3ZlbmRvcnMvc2xpY2subWluLmpzIiwid2VicGFjazovLy8uL3NjcmlwdHMvdmVuZG9ycy9jbGlwYm9hcmQuanMiLCJ3ZWJwYWNrOi8vLy4vc2NyaXB0cy92ZW5kb3JzL2NsaXBib2FyZC5qcz9lZDY3Iiwid2VicGFjazovLy8uL19kYXRhL29yZ3MvZGlzY292ZXJ5LWFwaS92Mi9jb3VudHJ5Q29kZS5qc29uIiwid2VicGFjazovLy8uL34vanN0cmVlL2Rpc3QvanN0cmVlLmpzIiwid2VicGFjazovLy8uL34va25vY2tvdXQtcG9zdGJveC9idWlsZC9rbm9ja291dC1wb3N0Ym94LmpzIiwid2VicGFjazovLy8uL34va25vY2tvdXQudmFsaWRhdGlvbi9kaXN0L2tub2Nrb3V0LnZhbGlkYXRpb24uanMiLCJ3ZWJwYWNrOi8vLy4vfi93b3JrZXItbG9hZGVyL2NyZWF0ZUlubGluZVdvcmtlci5qcyJdLCJuYW1lcyI6WyJiYXNlIiwiYXBpS2V5IiwicmVzdCIsImNvbmZpZyIsImpzb25ITCIsImNvbG9yc1NlcnZpY2UiLCJhcGlLZXlTZXJ2aWNlIiwiZ2V0QXBpS2V5c0Nvb2tpZSIsImdldEFwaUV4cGxvcmVLZXkiLCJtb2R1bGUiLCJleHBvcnRzIiwicGxhY2Vob2xkZXIiLCJuYW1lIiwic3R5bGUiLCJ2YWx1ZSIsImtvIiwib2JzZXJ2YWJsZSIsInR5cGUiLCJyZXF1aXJlZCIsIkNPTkZJR19VUkwiLCJwYXJzZURhdGEiLCJ4bWwiLCJnbG9iYWwiLCJyZXNvdXJjZXNFbCIsIiQiLCJmaW5kIiwiZXEiLCJnZXQiLCJtYXAiLCJyZXMiLCJyZXNvdXJjZSIsIm1ldGhvZEVsZW0iLCJtZXRob2QiLCJpZCIsImF0dHIiLCJjYXRlZ29yeSIsInRleHQiLCJ0cmltIiwicGF0aCIsImxpbmsiLCJkZXNjcmlwdGlvbiIsInBhcmFtZXRlcnMiLCJwYXIiLCJwYXJhbSIsIm9wdGlvbnMiLCJpc1NlbGVjdCIsImxlbmd0aCIsInBhcmFtZXRlciIsImRvYyIsImZpcnN0IiwiZGVmYXVsdCIsInNlbGVjdCIsInJlcGxhY2UiLCJvcHRpb24iLCJjaGVja2VkIiwicmVxdWVzdEJvZHkiLCJBTEwiLCJyZWFkRnJvbVdBREwiLCJhamF4IiwidXJsIiwiYXN5bmMiLCJkYXRhVHlwZSIsInN1Y2Nlc3MiLCJyZXNwb25zZSIsInBhcnNlWE1MIiwiZXJyb3IiLCJYTUxIdHRwUmVxdWVzdCIsInRleHRTdGF0dXMiLCJlcnJvclRocm93biIsImFsZXJ0IiwiaW5zdGFuY2UiLCJSZXN0U2VydmljZSIsImNhbGxiYWNrIiwibXNnIiwidW53cmFwIiwic2VsZWN0ZWRDYXRlZ29yeSIsInNlbGVjdGVkTWV0aG9kVHlwZSIsIm1ldGhvZElkIiwic2VsZWN0ZWRNZXRob2QiLCJwYXJhbXMiLCJzZWxlY3RlZFBhcmFtcyIsInJlc09iaiIsImV4dGVuZCIsIm9iaiIsInJlcSIsImluZGV4IiwicmVxdWVzdHMiLCJwdWJsaXNoT24iLCJsYXN0UmVzcG9uc2UiLCJyZXNwb25zZUpTT04iLCJ1bnNoaWZ0IiwicmVxdWVzdEluUHJvZ3Jlc3MiLCJwYXJzZVVybCIsImxvY2F0aW9uIiwic3BsaXQiLCJ3aW5kb3ciLCJzZWFyY2giLCJxdWVyeXMiLCJhcGlDYXRlZ29yeSIsImdsb2JhbFF1ZXJ5T2JqIiwicXVlcnkiLCJkZWNvZGVVUkkiLCJrZXkiLCJ2YWwiLCJPYmplY3QiLCJrZXlzIiwiaW5kZXhPZiIsIkpTT04iLCJwYXJzZSIsImV4Y2VwdGlvbl92YXIiLCJwdXNoIiwibWV0aG9kRGF0YSIsImdldE1ldGhvZERhdGEiLCJzdWJzY3JpYmVUbyIsIm9ic2VydmFibGVBcnJheSIsInN5bmNXaXRoIiwiYW5vdGhlclJlc3BvbnNlIiwiaW5pdCIsInBvc3Rib3giLCJzdWJzY3JpYmUiLCJzZWxlY3RlZE1ldGhvZERhdGEiLCJwYW5lbEdyb3VwIiwiY29sb3IiLCJhbm90aGVyUmVxdWVzdCIsInByZXBhcmVVcmwiLCJhamF4U2VydmljZSIsImRhdGEiLCJhcGlrZXlBY3RpdmUiLCJfZG9tYWluIiwiX3BhdGgiLCJfc2VsZWN0ZWRQYXJhbXMiLCJyZXBsYWNlbWVudCIsImRvbWFpbiIsImZpbHRlciIsIml0ZW0iLCJtYXRjaCIsInRlbXBsYXRlc0FyciIsImZvckVhY2giLCJqb2luIiwiZW5jb2RlVVJJIiwiY29tcGxldGUiLCJoZWFkZXJzIiwiZ2V0SGVhZGVycyIsImJvZHkiLCJlcnIiLCJoZWFkZXJzT2JqIiwibWV0aG9kVHlwZSIsIm1vZHVsZXMiLCJjdXN0b21CaW5kaW5ncyIsImNvbXBvbmVudHMiLCJzZXJ2aWNlcyIsInJlc3RTcnYiLCJnZXRQcm9wIiwibyIsInMiLCJhIiwiaSIsIm4iLCJrIiwiQXBwVmlld01vZGVsIiwic2V0UGFyYW1zIiwibm90aWZ5U3Vic2NyaWJlcnMiLCJhcGlLZXlJbnB1dElkIiwicmVzdFNlcnZpY2UiLCJwYXJhbXNJc0hpZGVuIiwicGFyc2VkVXJsIiwiaW5pdFZhbGlkYXRpb24iLCJzZW5kQnV0dG9uVGV4dCIsInB1cmVDb21wdXRlZCIsInNoYXJlUGF0aCIsImZvcm1EZWVwTGlua2luZ1VybCIsInZhbGlkYXRpb25Nb2RlbCIsImFwaUtleVZhbGlkYXRpb25Nb2RlbCIsInNob3ciLCJzZW5kQnRuVmFsaWRhdGlvblRleHQiLCJmb3JtSXNWYWxpZCIsImNvbXB1dGVkIiwidmFsaWRhdGVkT2JzZXJ2YWJsZSIsInZhbGlkYXRpb25GbGFnIiwiaXNWYWxpZCIsInZhbGlkYXRpb25UZXh0IiwibW9kZWwiLCJhY3RpdmVLZXkiLCJzZW5kUmVxdWVzdCIsImVycm9ycyIsInNob3dBbGxNZXNzYWdlcyIsImRlZmF1bHRWYWx1ZSIsIm9yaWdpbiIsInBhdGhuYW1lIiwiYXBwIiwiYXBwbHlCaW5kaW5ncyIsInJlcXVpcmUiLCJfX3dlYnBhY2tfcHVibGljX3BhdGhfXyIsIkN1c3RvbUlucHV0Iiwib25Gb2N1c01ldGhvZCIsImlzRGlydHkiLCJjc3NDbGFzcyIsImZvY3VzTWV0aG9kIiwiaXNWaXJnaW4iLCJmaWVsZFdhdGNoZXIiLCJ0b1N0cmluZyIsIm51bGxhYmxlSW50IiwiZXZlbnQiLCJidG4iLCJrZXlDb2RlIiwiaXMiLCJ0cmlnZ2VyIiwicmVnaXN0ZXIiLCJ2aWV3TW9kZWwiLCJ0ZW1wbGF0ZSIsIkN1c3RvbVNlbGVjdCIsInNlbGVjdGVkIiwiZm9jdXMiLCJvbnNlbGVjdCIsImFuaW1hdGlvblNwZWVkIiwiaXNSZWFkT25seSIsInJhd09wdGlvbnMiLCJERUZBVUxUX1NFTEVDVEVEIiwiY3VyZW50U2VsZWN0RGF0YSIsIm9uRm9jdXMiLCJvbnNlbGVjdE1ldGhvZCIsInNlbGVjdGVkT3B0aW9uIiwibWFwRm9yQ2hlY2tlZCIsImlzRXhwYW5kZWRlZCIsInNldFN1YnNjcmlidGlvbnMiLCJpc09uZU9wdGlvbiIsIm9wdGlvblZhbHVlIiwiZWwiLCJjb25zdHJ1Y3RvciIsImZpbmRFbGVtZW50Iiwid3JhcHBlciIsInNsaWRlVG9nZ2xlIiwibGF5ZXIiLCJ0b2dnbGVDbGFzcyIsInBhcmVudCIsImN1cnJlbnRUYXJnZXQiLCJwYXJlbnRzIiwic2VsZiIsIkFib3V0TWV0aG9kIiwiZG9jdW1lbnRhdGlvbkxpbmsiLCJ0b2dnbGVQb3BVcCIsInByb3RvdHlwZSIsIm9uQWJvdXRDbGljayIsIkNhdGVnb3J5TWVudSIsInNlbGVjdENhdGVnb3J5IiwiY2F0ZWdvcnlOYW1lIiwiY2hlY2tBY3RpdmUiLCJjYXRlZ29yaWVzIiwiaW5pdENhdGVnb3J5Iiwia29BcnIiLCJhY3RpdmVFbGVtIiwiTWV0aG9kc0ZpbHRlciIsInNlbGVjdGVkTWV0aG9kTmFtZSIsIm1ldGhvZHNWaWV3TW9kZWwiLCJub2RlTmFtZSIsInVwZGF0ZU1ldGhvZHNNb2RlbCIsImFyciIsImNvdW50IiwiaGFzT3duUHJvcGVydHkiLCJwcm9wZXJ0eSIsInZtTWV0aG9kIiwiUGFyYW1zRmlsdGVyIiwidXBkYXRlVmlld01vZGVsIiwic2VsZWN0ZWRQYXJhbSIsInZtUGFyYW0iLCJoYXNDYWxlbmRhciIsImhhc1BvcFVwIiwicGFyYW1zTW9kZWwiLCJwYXJhbUluRm9jdXMiLCJwcmVwYXJlVXJsUGFpcnMiLCJvblBhcmFtc0NsZWFyIiwidm0iLCJlIiwiaXNIaWRkZW4iLCJjaGVja0RpcnR5IiwiY2FsbCIsIm1hdGNoZWRQYXJhbSIsImRpcnR5Iiwia29PYnMiLCJSYWRpb0ZpbHRlciIsIlJBRElPX0lEIiwicmFkaW9zTW9kZWwiLCJ1cGRhdGVSYWRpb3NNb2RlbCIsInNvcnQiLCJjb21wYXJlTWV0aG9kcyIsIm9uY2hhbmdlUmFkaW9zIiwiZ2V0SW5wdXRJZCIsImYiLCJ0b1VwcGVyQ2FzZSIsImIiLCJBcnJheVBhbmVsQm9keSIsIl9wYW5lbE5hbWUiLCJjYXJkSW5kZXgiLCJ1dGlscyIsInVud3JhcE9ic2VydmFibGUiLCJnZXRNb3JlIiwiJGRhdGEiLCIkaW5kZXgiLCJyZW1vdmVDbGFzcyIsImFkZENsYXNzIiwicGFuZWwiLCJNYXBQYW5lbEJvZHkiLCJsYXQiLCJsb25nIiwiYWRkcmVzcyIsInNob3dNYXBQb3B1cCIsInpvb20iLCJ3aWR0aCIsImhlaWdodCIsImZvcm1hdCIsInBhcnNlRmxvYXQiLCJzaXplIiwiY29vcmRpbmF0ZXMiLCJPYmplY3RQYW5lbEJvZHkiLCJwYWdlIiwiY29sbGFwc2VJZCIsInN1YmplY3RJRCIsIl9hbGxJbnNpZGUiLCJzb3J0QnlDb25maWciLCJzZW5kSWQiLCJjaGFuZ2VQYWdlIiwidG90YWxQYWdlcyIsIk51bWJlciIsImlzTmFOIiwicGFnZU51bWJlciIsInBhZ2VQYXJhbSIsIlBhZ2luYXRpb24iLCJudW1iZXIiLCJsYXN0IiwicmVxdWVzdEJ0biIsIlBhbmVsIiwibWFya2VyIiwibWFwRWwiLCJsbmciLCJnZW9jb2RlciIsImdvb2dsZSIsIm1hcHMiLCJHZW9jb2RlciIsIkxhdExuZyIsIk1hcCIsImRvY3VtZW50IiwiZ2V0RWxlbWVudEJ5SWQiLCJjZW50ZXIiLCJnZW9jb2RlQWRkcmVzcyIsInJlc3VsdCIsIk1hcmtlciIsInBvc2l0aW9uIiwib24iLCJzZXRDZW50ZXIiLCJtb2RhbCIsImNvbG9yQ2xhc3MiLCJwYW5lbENvbmZpZyIsImlzRXhwYW5kZWQiLCJpc0FjdGl2ZSIsImxhdGl0dWRlIiwibG9uZ2l0dWRlIiwic3ViQ29uZmlnIiwiX0NPTkZJRyIsIkNhcmRHcm91cCIsImdldENvbmZpZyIsInByZXBhcmVEYXRhIiwiZ3JvdXBJbmRleCIsInNlY3Rpb25JbmRleCIsImdldFBhZ2luZ0luZm8iLCJnZXRDb2xsYXBzZUlkIiwiX2hhc0V2ZW50c1BhbmVsIiwiaTEiLCJpMiIsInVud3JhcHBPYmplY3RzIiwicmVtb3ZlRGVwcmVjYXRlZCIsIndyYXBwUHJpbWl0aXZlcyIsIl9wcm9wVGl0bGUiLCJuZXdEYXRhIiwiZGVwcmVjYXRlZCIsInVud3JhcHAiLCJwcm9wIiwiZGVlcFByb3AiLCJyYXdGaWx0ZXIiLCJtZXRob2RDb25maWciLCJfR0xPQkFMX0NPTkZJRyIsInBhZ2VPYmoiLCJjYXJkU2l6ZSIsIlBhbmVsSGVhZGluZyIsInNldEFjdGl2ZSIsInRpdGxlIiwic3ViamVjdElkIiwicmVxdWVzdCIsImFub3RoZXJSZXF1ZXN0Q29sb3IiLCJnZXRSYW5kb21Db2xvciIsIlJlZ0V4cCIsImdldERlZXBQcm9wIiwib2JqZWN0IiwiRXJyb3JQb3BVcCIsInN0YXR1cyIsInN0YXR1c1RleHQiLCJkZXRhaWxzIiwiZXJyb3JPYmoiLCJSZXF1ZXN0Q29tcG9uZW50IiwiaGFzUmVzcG9uc2UiLCJhY3RpdmUiLCJpc0FjdGl2ZU1vcmVNZW51IiwiY29waWVkRm9yU2hhcmUiLCJwYXJhbXNBcmVTZXRlZCIsImNvcGllZFVybCIsInJlc0hUTUwiLCJyb290c2V0UGFyYW1zIiwiaWRzIiwidGFyZ2V0IiwiY29udHJvbHMiLCJzZXRUaW1lb3V0Iiwic2xpZGVyIiwic2xpY2siLCJjb250ZW50IiwicmF3V2luZG93Iiwib3BlbiIsInN0cmluZ2lmeSIsIlJlcXVlc3RMaXN0Q29tcG9uZW50IiwiY29sb3JzIiwiY2xlYXJCdG5Jc1Zpc2libGUiLCJfaXNWaXNpYmxlIiwidXBkYXRlTW9kZWwiLCJuZXdNb2RlbCIsIm5ld09iaiIsInJlbW92ZSIsInNldCIsIlJlc3BvbnNlQ29tcG9uZW50IiwiYnJlYWRjcnVic0FyciIsImJyZWFkY3J1bWJzIiwiYXR0cnMiLCJ0YWJzIiwianNvbiIsImhyZWYiLCJibG9ja3MiLCJ2aWV3IiwicEdyb3VwIiwiY3VycmVudCIsInN0ciIsImN1cnJlbnRTbGlkZXIiLCJjb21wb25lbnQiLCJjdXJzbGljayIsImJ1aWxkQnJlYWRjcnVtYnMiLCJzbGlkZUNvdW50IiwiYmluZGluZ0hhbmRsZXJzIiwiYmxvY2tFbGxpcHNpcyIsImVsZW1lbnQiLCJ2YWx1ZUFjY2Vzc29yIiwiYWxsQmluZGluZ3MiLCJiaW5kaW5nQ29udGV4dCIsIiRjbGFtcCIsImNsYXNzaWZpY2F0aW9uc01hcCIsIl9hbGxCaW5kaW5ncyIsIl9iaW5kaW5nQ29udGV4dCIsImNvcHlUb0NsaXBib2FyZCIsIiRlbGVtZW50IiwiZG9uZSIsImRvbmVDbGFzcyIsImVycm9yQ2xhc3MiLCJhbmltYXRpb25UaW1lIiwiY2xpcGJvYXJkIiwiQ2xpcGJvYXJkIiwiYWN0aW9uIiwiY2xlYXJTZWxlY3Rpb24iLCJjb25zb2xlIiwiZG9tTm9kZURpc3Bvc2FsIiwiYWRkRGlzcG9zZUNhbGxiYWNrIiwiZGVzdHJveSIsImZvcmVhY2hwcm9wIiwidHJhbnNmb3JtT2JqZWN0IiwicHJvcGVydGllcyIsInNvcnRGbiIsIm9iamVjdEZvckVhY2giLCJhbGxCaW5kaW5nc0FjY2Vzc29yIiwiYXBwbHlCaW5kaW5nc1RvTm9kZSIsImZvcmVhY2giLCJjb250cm9sc0Rlc2NlbmRhbnRCaW5kaW5ncyIsImltZ09uRXJyb3IiLCJ3YXJuIiwiY3NzIiwibGF6eUxvYWRlciIsInRvTG93ZXJDYXNlIiwiZGF0ZXNBcnIiLCJkYXRlSW5kZXgiLCJzZWxlY3RvciIsImFkZENhbGVuZGFyIiwibGF6eVNlbGVjdG9yIiwiY2xhc3NpZmljYXRpb25TZWxlY3RvciIsInVzZSIsImFkZExhdGxvbmciLCJsYWJlbCIsImFmdGVyIiwiTmV3Q3NzQ2FsIiwiJGlucHV0IiwiYnRuTGF0bG9uZyIsIiR3aWRnZXRNb2RhbE1hcCIsInByZXZlbnREZWZhdWx0IiwibWFwX2xhdGxvbmciLCJjb21tb24iLCJjb250YWluZXIiLCJwbGFjZW1lbnQiLCJwb3BvdmVyIiwidXBkYXRlIiwidGltZXIiLCJjbGVhckludGVydmFsIiwiZGVsYXkiLCJ0b29sdGlwIiwiZG90cyIsImluZmluaXRlIiwic3BlZWQiLCJzbGlkZXNUb1Nob3ciLCJzbGlkZXNUb1Njcm9sbCIsImF1dG9wbGF5IiwiZm9jdXNPblNlbGVjdCIsInJlc3BvbnNpdmUiLCJicmVha3BvaW50Iiwic2V0dGluZ3MiLCJ0aW1lcyIsInVuc2xpY2siLCJ2YWxpZGF0aW9uIiwicnVsZXMiLCJwYXR0ZXJuIiwibWVzc2FnZSIsInJlZ2lzdGVyRXh0ZW5kZXJzIiwibWVzc2FnZXNPbk1vZGlmaWVkIiwiZGVjb3JhdGVJbnB1dEVsZW1lbnQiLCJlcnJvck1lc3NhZ2VDbGFzcyIsImVycm9yRWxlbWVudENsYXNzIiwiaW5zZXJ0TWVzc2FnZXMiLCJwYXJzZUlucHV0QXR0cmlidXRlcyIsIm1lc3NhZ2VUZW1wbGF0ZSIsImdyb3VwaW5nIiwiZGVlcCIsImxpdmUiLCJ2YWxpZGF0b3IiLCJ2YWxpZGF0ZSIsInRlc3QiLCJudW0iLCJTeW1ib2wiLCJwcmVmaXgiLCJDb2xvcnNTZXJ2aWNlIiwiTlVNIiwiUFJFRklYIiwiZ2V0Q29sb3JzIiwicmFuZG9tTnVtYmVyIiwiZ2V0UmFuZG9tSW50IiwiQXJyYXkiLCJtaW4iLCJtYXgiLCJNYXRoIiwiZmxvb3IiLCJyYW5kb20iLCJob3N0bmFtZSIsInBvcnQiLCJXb3JrZXIiLCJjb2RlIiwiYW5pbVRpbWUiLCJ3b3JrZXIiLCJvbm1lc3NhZ2UiLCJqc29uQ29kZUNvbnRhaW5lckV4cGFuZGVkIiwic3RvcFByb3BhZ2F0aW9uIiwiJHNlbGYiLCJzbGlkZVVwIiwianNvbkNvZGVDb250YWluZXJDb2xsYXBzZWQiLCJzbGlkZURvd24iLCJvbmVycm9yIiwicG9zdE1lc3NhZ2UiLCJjb3VudHJ5Q29kZXMiLCJDb3VudHJ5Q29kZSIsImNvZGVBbmRDb3VudHJ5Iiwic3Vic3RyIiwiZm4iLCJkZWZhdWx0cyIsIiRpY29uQnV0dG9uIiwiJG1vZGFsIiwiJGZvcm0iLCIkYnRuR0VUIiwiY3NzVmFsaWRhdGlvbkNsYXNzIiwibW9kYWxDb250ZW50IiwiJGpzdHJlZSIsImtleXdvcmQiLCJhcGlrZXkiLCJjaGVja0FwaUtleUNvb2tpZSIsImV2ZW50VXJsIiwiaW5pdFRyZWUiLCJzZXRDaGlsZHJlbiIsImpzdHJlZSIsInRvZ2dsZV9ub2RlIiwibm9kZSIsImoiLCJyIiwiZ2V0X25vZGUiLCJvZmYiLCJzZXRJZExpc3RlbmVyIiwiaW5zZXJ0QWZ0ZXIiLCJ1cGRhdGVUcmVlIiwibmV3SnNvbiIsImNvcmUiLCJyZWZyZXNoIiwiY2hpbGRyZW4iLCJoaWRlIiwibmV3QXJyT2JqIiwicmVuYW1lIiwic2VnbWVudCIsIl9lbWJlZGRlZCIsImdlbnJlcyIsInN1YmdlbnJlcyIsIm9wdCIsInJvb3QiLCJmaWVsZE5hbWUiLCJ0byIsImNoaWxkIiwicmVwbGFjZUF0b0IiLCJnZW5yZXNBcnIiLCJzdWJnZW5yZXNBcnIiLCJpaSIsImNoYW5nZU1vZGFsVGV4dExpc3RlbmVyIiwic3VibWl0Rm9ybSIsImxvYWRpbmciLCJzcGlubmVyIiwicmVzZXRGb3JtIiwicmVtb3ZlQXR0ciIsImlzSW5pdCIsInNlcmlhbGl6ZSIsInRvdGFsRWxlbWVudHMiLCJyZW5kZXJSZXN1bHRzIiwibG9nIiwiZmFpbCIsImhhc1Njcm9sbEJhciIsInNjcm9sbEhlaWdodCIsImlubmVySGVpZ2h0IiwidWxFbGVtZW50IiwiZXJyb3JNc2ciLCJzaG93TWVzc2FnZSIsImNsZWFyTGlzdCIsImFwcGVuZCIsImV4cGxhbmF0aW9uIiwiYXBwZW5kVG8iLCJtc2dFcnIiLCJkZXRhaWwiLCJzZWxlY3RlZElEIiwiZ2V0QXR0cmlidXRlIiwiZm9ybSIsImNoZWNrVmFsaWRpdHkiLCJyZXBvcnRWYWxpZGl0eSIsImlucHV0IiwidGFnTmFtZSIsImJsdXIiLCJlYWNoIiwid3JhcCIsImpRdWVyeSIsInRhZ3NJZHMiLCJpbml0aWFsVmFsIiwic3RhdGVDb25mIiwicGFnZUluY3JlbWVudCIsImxvYWRpbmdGbGFnIiwic2V0U2luZ2xlVmFsIiwiJHVsIiwiJGxpRm9vdGVyIiwiJGhyIiwiYnRuQ2xvc2VNYXAiLCIkbXNTZWxlY3Rpb24iLCIkbXNMaXN0IiwiJG1zQnRuVXNlIiwiZGVmYXVsdEFwaUtleSIsImZvcm1hdERhdGUiLCJkYXRlIiwiZGF5IiwiTU9OVEhfTkFNRVMiLCJEQVlfTkFNRVMiLCJkYXlBcnJheSIsImQiLCJwYXJzZUludCIsIk0iLCJFIiwiRGF0ZSIsImdldERheSIsInRpbWUiLCJ0aW1lQXJyYXkiLCJIIiwibSIsImdldE5vcm1hbGl6ZWREYXRlVmFsdWUiLCJkZWZhdWx0TWFwWm9vbSIsIm1hcmtlcnMiLCJtYXBQb3BVcExpc3RlbmVyIiwiaW5pdE1hcCIsInNldFpvb20iLCJtYXBDZW50ZXIiLCJtYXBUeXBlQ29udHJvbCIsInNjYWxlQ29udHJvbCIsImZ1bGxzY3JlZW5Db250cm9sIiwic3RyZWV0Vmlld0NvbnRyb2wiLCJyb3RhdGVDb250cm9sIiwiY2xlYXJNYXJrZXJzIiwicGFuVG8iLCJhZGRNYXJrZXIiLCJpY29uIiwiTWFya2VySW1hZ2UiLCJTaXplIiwic2V0TWFwIiwiY2xvc2VNYXBMaXN0ZW5lciIsInRvZ2dsZVRhZ3MiLCJpbmRUb1JlbW92ZSIsImlucHV0VmFsQXJyYXkiLCJsaXN0SXRlbSIsImluQXJyYXkiLCJpbmNsdWRlcyIsInRvZ2dsZU1zU2VsZWN0aW9uQm94IiwiaGlkZU11bHRpU2VsZWN0b3IiLCJsaXN0SXRlbXMiLCJhZGRNc0J1dHRvbkxpc3RlbmVyIiwibWFwTGlzdGVuZXIiLCJwYWdlTnVtZXJvIiwiZ2V0SW1hZ2VGb3JFdmVudCIsImltYWdlcyIsInNyYyIsInJlbmRlckxpc3RFdmVudHMiLCJpdGVtcyIsImxpIiwibGVmdENvbCIsInNwYW5JbWciLCJpbWciLCIkd3JhcENvbCIsImN1cnJlbnRFdmVudCIsImRhdGVzIiwic3RhcnQiLCJsb2NhbERhdGUiLCJsb2NhbFRpbWUiLCJkYXRlVGltZSIsImV2ZW50VGltZSIsInZlbnVlcyIsInZlbnVlIiwiYWRkcmVzc05hbWUiLCJhZGRyZXNzbGluZTEiLCJsaW5lMSIsImFkZHJlc3NsaW5lMiIsImxpbmUyIiwiYnV0dG9uU2V0SWQiLCJhZGRUb0VsIiwiYnV0dG9uU2V0SWRXcmFwcGVyIiwiYWRkTXNCdXR0b24iLCJyZW5kZXJMaXN0VmVudWVzIiwiY29udHJ5U3RhdGVOYW1lIiwiY291bnRyeSIsInN0YXRlIiwiY2l0eU5hbWUiLCJjaXR5IiwiYnV0dG9uTWFwIiwicmVuZGVyTGlzdEF0dHJhY3Rpb25zIiwiY2xhc3NpZmljYXRpb25zIiwiX2dlbnJlIiwiX3N1YmdlbnJlIiwiX3NlZ21lbnQiLCJnZW5yZSIsInN1YkdlbnJlIiwic2VnbWVudFRleHQiLCJldmVudHMiLCJhdHRyYWN0aW9ucyIsInNjcmVlbldpZHRoIiwiZG9jdW1lbnRFbGVtZW50IiwiY2xpZW50V2lkdGgiLCJpbm5lcldpZHRoIiwiaXNNb2JpbGUiLCJuYXZpZ2F0b3IiLCJ1c2VyQWdlbnQiLCJidXR0b25BZGRJZFRvTGlzdCIsInNldElkc0xpc3RlbmVyIiwiY2xlYXJCeUFyclZhbCIsIm1hcEFueSIsImFycmF5Iiwic3BsaWNlIiwiZGVsSWRMaXN0ZW5lciIsIm1lIiwidGFnSUQiLCJpc1VuaXF1ZSIsImxpc3QiLCJ1bmlxdWUiLCJ1bmlxdWVVcGNvbWluZyIsImN1cnJlbnRMaXN0IiwiZWxtIiwic2VsZWN0b3JCdG4iLCJ0YWdzQXJyIiwiZmxhZyIsIkVycm9yIiwianF1ZXJ5IiwiY3JlYXRlRWxlbWVudCIsIldlYmtpdFRyYW5zaXRpb24iLCJNb3pUcmFuc2l0aW9uIiwiT1RyYW5zaXRpb24iLCJ0cmFuc2l0aW9uIiwiYyIsImVuZCIsImVtdWxhdGVUcmFuc2l0aW9uRW5kIiwib25lIiwic3VwcG9ydCIsInNwZWNpYWwiLCJic1RyYW5zaXRpb25FbmQiLCJiaW5kVHlwZSIsImRlbGVnYXRlVHlwZSIsImhhbmRsZSIsImhhbmRsZU9iaiIsImhhbmRsZXIiLCJhcHBseSIsImFyZ3VtZW50cyIsImNsb3NlIiwiVkVSU0lPTiIsIlRSQU5TSVRJT05fRFVSQVRJT04iLCJnIiwiZGV0YWNoIiwiY2xvc2VzdCIsIkV2ZW50IiwiaXNEZWZhdWx0UHJldmVudGVkIiwiaGFzQ2xhc3MiLCJDb25zdHJ1Y3RvciIsIm5vQ29uZmxpY3QiLCJ0b2dnbGUiLCJzZXRTdGF0ZSIsIkRFRkFVTFRTIiwiaXNMb2FkaW5nIiwibG9hZGluZ1RleHQiLCJyZXNldFRleHQiLCJwcm94eSIsImJ1dHRvbiIsInNsaWRlIiwiaW50ZXJ2YWwiLCJwYXVzZSIsImN5Y2xlIiwiJGluZGljYXRvcnMiLCJwYXVzZWQiLCJzbGlkaW5nIiwiJGFjdGl2ZSIsIiRpdGVtcyIsImtleWJvYXJkIiwia2V5ZG93biIsIndoaWNoIiwicHJldiIsIm5leHQiLCJzZXRJbnRlcnZhbCIsImdldEl0ZW1JbmRleCIsImdldEl0ZW1Gb3JEaXJlY3Rpb24iLCJoIiwicmVsYXRlZFRhcmdldCIsImRpcmVjdGlvbiIsImwiLCJvZmZzZXRXaWR0aCIsImNhcm91c2VsIiwiJHRyaWdnZXIiLCJ0cmFuc2l0aW9uaW5nIiwiJHBhcmVudCIsImdldFBhcmVudCIsImFkZEFyaWFBbmRDb2xsYXBzZWRDbGFzcyIsImRpbWVuc2lvbiIsImNhbWVsQ2FzZSIsIm9mZnNldEhlaWdodCIsImNvbGxhcHNlIiwiY29udGFpbnMiLCJkcm9wZG93biIsIiRib2R5IiwiJGRpYWxvZyIsIiRiYWNrZHJvcCIsImlzU2hvd24iLCJvcmlnaW5hbEJvZHlQYWQiLCJzY3JvbGxiYXJXaWR0aCIsImlnbm9yZUJhY2tkcm9wQ2xpY2siLCJyZW1vdGUiLCJsb2FkIiwiQkFDS0RST1BfVFJBTlNJVElPTl9EVVJBVElPTiIsImJhY2tkcm9wIiwiY2hlY2tTY3JvbGxiYXIiLCJzZXRTY3JvbGxiYXIiLCJlc2NhcGUiLCJyZXNpemUiLCJzY3JvbGxUb3AiLCJhZGp1c3REaWFsb2ciLCJlbmZvcmNlRm9jdXMiLCJoaWRlTW9kYWwiLCJoYXMiLCJoYW5kbGVVcGRhdGUiLCJyZXNldEFkanVzdG1lbnRzIiwicmVzZXRTY3JvbGxiYXIiLCJyZW1vdmVCYWNrZHJvcCIsImNsaWVudEhlaWdodCIsInBhZGRpbmdMZWZ0IiwiYm9keUlzT3ZlcmZsb3dpbmciLCJwYWRkaW5nUmlnaHQiLCJnZXRCb3VuZGluZ0NsaWVudFJlY3QiLCJyaWdodCIsImFicyIsImxlZnQiLCJtZWFzdXJlU2Nyb2xsYmFyIiwiY2xhc3NOYW1lIiwicmVtb3ZlQ2hpbGQiLCJlbmFibGVkIiwidGltZW91dCIsImhvdmVyU3RhdGUiLCJpblN0YXRlIiwiYW5pbWF0aW9uIiwiaHRtbCIsInZpZXdwb3J0IiwicGFkZGluZyIsImdldE9wdGlvbnMiLCIkdmlld3BvcnQiLCJpc0Z1bmN0aW9uIiwiY2xpY2siLCJob3ZlciIsImVudGVyIiwibGVhdmUiLCJfb3B0aW9ucyIsImZpeFRpdGxlIiwiZ2V0RGVmYXVsdHMiLCJnZXREZWxlZ2F0ZU9wdGlvbnMiLCJ0aXAiLCJjbGVhclRpbWVvdXQiLCJpc0luU3RhdGVUcnVlIiwiaGFzQ29udGVudCIsIm93bmVyRG9jdW1lbnQiLCJnZXRVSUQiLCJzZXRDb250ZW50IiwidG9wIiwiZGlzcGxheSIsImdldFBvc2l0aW9uIiwiYm90dG9tIiwicCIsImdldENhbGN1bGF0ZWRPZmZzZXQiLCJhcHBseVBsYWNlbWVudCIsInEiLCIkdGlwIiwib2Zmc2V0Iiwic2V0T2Zmc2V0IiwidXNpbmciLCJyb3VuZCIsImdldFZpZXdwb3J0QWRqdXN0ZWREZWx0YSIsInJlcGxhY2VBcnJvdyIsImFycm93IiwiZ2V0VGl0bGUiLCJzY3JvbGwiLCIkYXJyb3ciLCJlbmFibGUiLCJkaXNhYmxlIiwidG9nZ2xlRW5hYmxlZCIsInJlbW92ZURhdGEiLCJnZXRDb250ZW50IiwiJHNjcm9sbEVsZW1lbnQiLCJvZmZzZXRzIiwidGFyZ2V0cyIsImFjdGl2ZVRhcmdldCIsInByb2Nlc3MiLCJnZXRTY3JvbGxIZWlnaHQiLCJpc1dpbmRvdyIsImFjdGl2YXRlIiwiY2xlYXIiLCJwYXJlbnRzVW50aWwiLCJzY3JvbGxzcHkiLCJ0YWIiLCIkdGFyZ2V0IiwiY2hlY2tQb3NpdGlvbiIsImNoZWNrUG9zaXRpb25XaXRoRXZlbnRMb29wIiwiYWZmaXhlZCIsInVucGluIiwicGlubmVkT2Zmc2V0IiwiUkVTRVQiLCJnZXRTdGF0ZSIsImdldFBpbm5lZE9mZnNldCIsImFmZml4Iiwib2Zmc2V0Qm90dG9tIiwib2Zmc2V0VG9wIiwiZ2V0Q29tcHV0ZWRTdHlsZSIsImdldFByb3BlcnR5VmFsdWUiLCJjdXJyZW50U3R5bGUiLCJ0IiwidSIsIngiLCJsYXN0Q2hpbGQiLCJzbGljZSIsInBvcCIsIm5vZGVWYWx1ZSIsInRydW5jYXRpb25DaGFyIiwicGFyZW50Tm9kZSIsInNoaWZ0IiwiaW5uZXJIVE1MIiwic3BsaXRPbkNoYXJzIiwiYW5pbWF0ZSIsImNsYW1wIiwidXNlTmF0aXZlQ2xhbXAiLCJ0cnVuY2F0aW9uSFRNTCIsInkiLCJ6Iiwid2Via2l0TGluZUNsYW1wIiwidiIsInciLCJvdmVyZmxvdyIsInRleHRPdmVyZmxvdyIsIndlYmtpdEJveE9yaWVudCIsIm9yaWdpbmFsIiwiY2xhbXBlZCIsIndpbkNhbCIsInVuZGVmaW5lZCIsImR0VG9kYXkiLCJDYWwiLCJleERhdGVUaW1lIiwic2VsRGF0ZSIsImNhbFNwYW5JRCIsImRvbVN0eWxlIiwiY25MZWZ0IiwiY25Ub3AiLCJ4cG9zIiwieXBvcyIsImNhbEhlaWdodCIsIkNhbFdpZHRoIiwiQ2VsbFdpZHRoIiwiVGltZU1vZGUiLCJTdGFydFllYXIiLCJnZXRGdWxsWWVhciIsIkVuZFllYXIiLCJDYWxQb3NPZmZzZXRYIiwiQ2FsUG9zT2Zmc2V0WSIsInNob3dNb250aEluSGVhZCIsIlNwYW5Cb3JkZXJDb2xvciIsIlNwYW5CZ0NvbG9yIiwiTW9udGhZZWFyQ29sb3IiLCJXZWVrSGVhZENvbG9yIiwiV2Vla0hlYWRCYWNrZ3JvdW5kIiwiU3VuZGF5Q29sb3IiLCJTYXR1cmRheUNvbG9yIiwiV2Vla0RheUNvbG9yIiwiRm9udENvbG9yIiwiVG9kYXlDb2xvciIsIlNlbERhdGVDb2xvciIsIllyU2VsQ29sb3IiLCJNdGhTZWxDb2xvciIsIkhvdmVyQ29sb3IiLCJEaXNhYmxlQ29sb3IiLCJDYWxCZ0NvbG9yIiwidG9wU2VsZWN0b3JCZyIsIldlZWtDaGFyIiwiRGF0ZVNlcGFyYXRvciIsIlNob3dMb25nTW9udGgiLCJTaG93TW9udGhZZWFyIiwiVGhlbWVCZyIsIlByZWNlZGVaZXJvIiwiTW9uZGF5Rmlyc3REYXkiLCJVc2VJbWFnZUZpbGVzIiwiaW1hZ2VGaWxlc1BhdGgiLCJNb250aE5hbWUiLCJXZWVrRGF5TmFtZTEiLCJXZWVrRGF5TmFtZTIiLCJDYWxlbmRhciIsInBEYXRlIiwicEN0cmwiLCJnZXREYXRlIiwiTW9udGgiLCJnZXRNb250aCIsIlllYXIiLCJIb3VycyIsImdldEhvdXJzIiwiZ2V0TWludXRlcyIsIk1pbnV0ZXMiLCJnZXRTZWNvbmRzIiwiU2Vjb25kcyIsIk15V2luZG93IiwiQ3RybCIsIkZvcm1hdCIsIlNlcGFyYXRvciIsIlNob3dUaW1lIiwiU2Nyb2xsZXIiLCJBTW9yUE0iLCJTaG93U2Vjb25kcyIsIkVuYWJsZURhdGVNb2RlIiwiR2V0TW9udGhJbmRleCIsInNob3J0TW9udGhOYW1lIiwic3Vic3RyaW5nIiwiSW5jWWVhciIsIkRlY1llYXIiLCJJbmNNb250aCIsIkRlY01vbnRoIiwiU3dpdGNoTXRoIiwiaW50TXRoIiwiU3dpdGNoWWVhciIsImludFllYXIiLCJTZXRIb3VyIiwiaW50SG91ciIsIk1heEhvdXIiLCJNaW5Ib3VyIiwiSG91ckV4cCIsIlNpbmdsZURpZ2l0IiwiU2V0TWludXRlIiwiaW50TWluIiwiTWF4TWluIiwiTWluTWluIiwiU2luZ2xlRGlnaXQyIiwiTWluRXhwIiwic3RyTWluIiwiU2V0U2Vjb25kIiwiaW50U2VjIiwiTWF4U2VjIiwiTWluU2VjIiwiU2VjRXhwIiwic3RyU2VjIiwiU2V0QW1QbSIsInB2YWx1ZSIsImdldFNob3dIb3VyIiwiZmluYWxIb3VyIiwiZ2V0U2hvd0FNb3JQTSIsIkdldE1vbnRoTmFtZSIsIklzTG9uZyIsIkdldE1vbkRheXMiLCJEYXlzSW5Nb250aCIsIklzTGVhcFllYXIiLCJGb3JtYXREYXRlIiwiTW9udGhEaWdpdCIsIlN0cmluZyIsIkdlbkNlbGwiLCJwVmFsdWUiLCJwSGlnaExpZ2h0IiwicENvbG9yIiwicENsaWNrYWJsZSIsIlBWYWx1ZSIsIlBDZWxsU3RyIiwiUENsaWNrYWJsZSIsInZUaW1lU3RyIiwiUmVuZGVyQ3NzQ2FsIiwiYk5ld0NhbCIsInZDYWxIZWFkZXIiLCJ2Q2FsRGF0YSIsInZDYWxUaW1lIiwidkNhbENsb3NpbmciLCJ3aW5DYWxEYXRhIiwiQ2FsRGF0ZSIsIlNlbGVjdFN0ciIsInZEYXlDb3VudCIsInZGaXJzdERheSIsIldlZWtEYXlOYW1lIiwic3RyQ2VsbCIsInNob3dIb3VyIiwiU2hvd0Fycm93cyIsIkhvdXJDZWxsV2lkdGgiLCJTZWxlY3RBbSIsIlNlbGVjdFBtIiwiZnVuY0NhbGJhY2siLCJoZWFkSUQiLCJjc3NTdHIiLCJjc3NUZXh0Iiwic3BhbiIsInNldERhdGUiLCJnZXRFbGVtZW50c0J5VGFnTmFtZSIsImxhbmd1YWdlIiwiYXBwZW5kQ2hpbGQiLCJyZWwiLCJzdHlsZVNoZWV0IiwiY3JlYXRlVGV4dE5vZGUiLCJib3JkZXIiLCJjdXJzb3IiLCJiYWNrZ3JvdW5kQ29sb3IiLCJ6SW5kZXgiLCJvdmVybGF5IiwiY2xhc3NMaXN0IiwiYWRkIiwidmlzaWJpbGl0eSIsIkhlaWdodCIsInBGb3JtYXQiLCJwU2Nyb2xsZXIiLCJwU2hvd1RpbWUiLCJwVGltZU1vZGUiLCJwU2hvd1NlY29uZHMiLCJwRW5hYmxlRGF0ZU1vZGUiLCJTcDEiLCJTcDIiLCJ0U3AxIiwidFNwMiIsInN0ck1vbnRoIiwic3RyRGF0ZSIsInN0clllYXIiLCJpbnRNb250aCIsIlllYXJQYXR0ZXJuIiwic3RySG91ciIsInN0ck1pbnV0ZSIsInN0clNlY29uZCIsIndpbkhlaWdodCIsImxhc3RJbmRleE9mIiwic3RyQU1QTSIsImNsb3Nld2luIiwiTWF4WWVhciIsImJlZm9yZVRvZGF5IiwiQ2FsSWQiLCJhY3RpdmVJY29ucyIsInF1ZXJ5U2VsZWN0b3JBbGwiLCJhaUNvdW50TGVuZ2h0IiwiYWlDb3VudCIsIndpbmNsb3NlIiwiY2hhbmdlQm9yZGVyIiwiY29sIiwib2xkQmdDb2xvciIsImJhY2tncm91bmQiLCJib3JkZXJDb2xvciIsInNlbGVjdERhdGUiLCJmaW5kUG9zIiwiY3VybGVmdCIsImN1cnRvcCIsIm9mZnNldFBhcmVudCIsIm9mZnNldExlZnQiLCJwaWNrSXQiLCJldnQiLCJvYmplY3RJRCIsImRvbSIsImRlIiwiYWRkRXZlbnRMaXN0ZW5lciIsInBvc0V2VGFyZ2V0Iiwic3JjRWxlbWVudCIsIm9mZnNldFgiLCJvZmZzZXRZIiwiY2xpZW50WCIsInNjcm9sbExlZnQiLCJjbGllbnRMZWZ0IiwiY2xpZW50WSIsImNsaWVudFRvcCIsImRyYWdJdCIsIm5leHRTdGVwIiwid2hhdFNwaW5uZXIiLCJzdGFydFNwaW4iLCJ0aGlzTG9vcCIsInN0b3BTcGluIiwiZHJvcEl0Iiwib25tb3VzZWRvd24iLCJxdWVyeVNlbGVjdG9yIiwidGFyZ2V0Q2xhc3MiLCJzZWxlY3RDbGFzcyIsIlJlc2l6ZVNlbnNvciIsIlBzIiwiZ2V0T3B0cyIsImFjYyIsIm9wdHMiLCJwc09wdHMiLCJzdXBwcmVzc1Njcm9sbFgiLCJzdXBwcmVzc1Njcm9sbFkiLCJzY3JvbGxCaW5kaW5nIiwidmFsQWNjIiwiYmluZGluZ3MiLCJjdHgiLCJpbml0aWFsaXplIiwic2Vuc29yIiwiX2ZpcnN0VXBkYXRlQ29tcGxldGUiLCJhc3NpZ24iLCJvdmVyZmxvd1giLCJvdmVyZmxvd1kiLCJFdmVudFF1ZXVlIiwiZXYiLCJhdHRhY2hSZXNpemVFdmVudCIsInJlc2l6ZWQiLCJyZXNpemVkQXR0YWNoZWQiLCJyZXNpemVTZW5zb3IiLCJzdHlsZUNoaWxkIiwiZml4ZWQiLCJhYnNvbHV0ZSIsImV4cGFuZCIsImNoaWxkTm9kZXMiLCJleHBhbmRDaGlsZCIsInNocmluayIsInNocmlua0NoaWxkIiwibGFzdFdpZHRoIiwibGFzdEhlaWdodCIsInJlc2V0Iiwic2Nyb2xsV2lkdGgiLCJjaGFuZ2VkIiwiYWRkRXZlbnQiLCJjYiIsImF0dGFjaEV2ZW50Iiwib25TY3JvbGwiLCJlbGVtZW50VHlwZSIsImlzQ29sbGVjdGlvblR5cGVkIiwiRWxlbWVudHMiLCJvbGRBZGQiLCJjbGFzc2VzIiwib2xkUmVtb3ZlIiwiaWR4IiwiRE9NIiwiY3NzR2V0Iiwic3R5bGVOYW1lIiwiY3NzU2V0Iiwic3R5bGVWYWx1ZSIsImNzc011bHRpU2V0Iiwic3R5bGVOYW1lT3JPYmplY3QiLCJtYXRjaGVzIiwibWF0Y2hlc1NlbGVjdG9yIiwid2Via2l0TWF0Y2hlc1NlbGVjdG9yIiwibW96TWF0Y2hlc1NlbGVjdG9yIiwibXNNYXRjaGVzU2VsZWN0b3IiLCJxdWVyeUNoaWxkcmVuIiwiRXZlbnRFbGVtZW50IiwiYmluZCIsImV2ZW50TmFtZSIsInVuYmluZCIsImlzSGFuZGxlclByb3ZpZGVkIiwiaGRsciIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJ1bmJpbmRBbGwiLCJFdmVudE1hbmFnZXIiLCJldmVudEVsZW1lbnRzIiwiZXZlbnRFbGVtZW50IiwiZWUiLCJvbmNlIiwib25jZUhhbmRsZXIiLCJzNCIsImNscyIsInRvSW50IiwiY2xvbmUiLCJzb3VyY2UiLCJpc0VkaXRhYmxlIiwicmVtb3ZlUHNDbGFzc2VzIiwiY2xzTGlzdCIsIm91dGVyV2lkdGgiLCJzdGFydFNjcm9sbGluZyIsImF4aXMiLCJzdG9wU2Nyb2xsaW5nIiwiZW52IiwiaXNXZWJLaXQiLCJzdXBwb3J0c1RvdWNoIiwiRG9jdW1lbnRUb3VjaCIsInN1cHBvcnRzSWVQb2ludGVyIiwibXNNYXhUb3VjaFBvaW50cyIsImhhbmRsZXJzIiwibWF4U2Nyb2xsYmFyTGVuZ3RoIiwibWluU2Nyb2xsYmFyTGVuZ3RoIiwic2Nyb2xsWE1hcmdpbk9mZnNldCIsInNjcm9sbFlNYXJnaW5PZmZzZXQiLCJzdG9wUHJvcGFnYXRpb25PbkNsaWNrIiwic3dpcGVQcm9wYWdhdGlvbiIsInVzZUJvdGhXaGVlbEF4ZXMiLCJ3aGVlbFByb3BhZ2F0aW9uIiwid2hlZWxTcGVlZCIsInRoZW1lIiwiXyIsImluc3RhbmNlcyIsInNjcm9sbGJhclgiLCJzY3JvbGxiYXJZIiwic2Nyb2xsYmFyWFJhaWwiLCJzY3JvbGxiYXJZUmFpbCIsInVwZGF0ZUdlb21ldHJ5IiwidXBkYXRlU2Nyb2xsIiwiYmluZENsaWNrUmFpbEhhbmRsZXIiLCJwYWdlT2Zmc2V0IiwiaGFsZk9mU2Nyb2xsYmFyTGVuZ3RoIiwic2Nyb2xsYmFyWUhlaWdodCIsInBvc2l0aW9uVG9wIiwicmFpbFlSYXRpbyIsInBhZ2VZIiwicGFnZVlPZmZzZXQiLCJtYXhQb3NpdGlvblRvcCIsInJhaWxZSGVpZ2h0IiwicG9zaXRpb25SYXRpbyIsImNvbnRlbnRIZWlnaHQiLCJjb250YWluZXJIZWlnaHQiLCJzY3JvbGxiYXJYV2lkdGgiLCJwb3NpdGlvbkxlZnQiLCJyYWlsWFJhdGlvIiwicGFnZVgiLCJwYWdlWE9mZnNldCIsIm1heFBvc2l0aW9uTGVmdCIsInJhaWxYV2lkdGgiLCJjb250ZW50V2lkdGgiLCJjb250YWluZXJXaWR0aCIsIm5lZ2F0aXZlU2Nyb2xsQWRqdXN0bWVudCIsImJpbmRNb3VzZVNjcm9sbFhIYW5kbGVyIiwiY3VycmVudExlZnQiLCJjdXJyZW50UGFnZVgiLCJ1cGRhdGVTY3JvbGxMZWZ0IiwiZGVsdGFYIiwibmV3TGVmdCIsIm1heExlZnQiLCJzY3JvbGxiYXJYTGVmdCIsIm1vdXNlTW92ZUhhbmRsZXIiLCJtb3VzZVVwSGFuZGxlciIsImJpbmRNb3VzZVNjcm9sbFlIYW5kbGVyIiwiY3VycmVudFRvcCIsImN1cnJlbnRQYWdlWSIsInVwZGF0ZVNjcm9sbFRvcCIsImRlbHRhWSIsIm5ld1RvcCIsIm1heFRvcCIsInNjcm9sbGJhcllUb3AiLCJiaW5kS2V5Ym9hcmRIYW5kbGVyIiwiaG92ZXJlZCIsInNob3VsZFByZXZlbnQiLCJzaG91bGRQcmV2ZW50RGVmYXVsdCIsInNjcm9sbGJhcllBY3RpdmUiLCJzY3JvbGxiYXJYQWN0aXZlIiwiZGVmYXVsdFByZXZlbnRlZCIsImZvY3VzZWQiLCJhY3RpdmVFbGVtZW50IiwiY29udGVudERvY3VtZW50Iiwic2hhZG93Um9vdCIsInNoaWZ0S2V5IiwiY3RybEtleSIsImJpbmRNb3VzZVdoZWVsSGFuZGxlciIsImdldERlbHRhRnJvbUV2ZW50Iiwid2hlZWxEZWx0YVgiLCJ3aGVlbERlbHRhWSIsImRlbHRhTW9kZSIsIndoZWVsRGVsdGEiLCJzaG91bGRCZUNvbnN1bWVkQnlDaGlsZCIsIm1heFNjcm9sbFRvcCIsIm1heFNjcm9sbExlZnQiLCJtb3VzZXdoZWVsSGFuZGxlciIsImRlbHRhIiwib253aGVlbCIsIm9ubW91c2V3aGVlbCIsImJpbmROYXRpdmVTY3JvbGxIYW5kbGVyIiwiYmluZFNlbGVjdGlvbkhhbmRsZXIiLCJnZXRSYW5nZU5vZGUiLCJzZWxlY3Rpb24iLCJnZXRTZWxlY3Rpb24iLCJnZXRSYW5nZUF0IiwiY29tbW9uQW5jZXN0b3JDb250YWluZXIiLCJzY3JvbGxpbmdMb29wIiwic2Nyb2xsRGlmZiIsImlzU2VsZWN0ZWQiLCJtb3VzZVBvc2l0aW9uIiwiY29udGFpbmVyR2VvbWV0cnkiLCJiaW5kVG91Y2hIYW5kbGVyIiwibWFnbml0dWRlWCIsIm1hZ25pdHVkZVkiLCJhcHBseVRvdWNoTW92ZSIsImRpZmZlcmVuY2VYIiwiZGlmZmVyZW5jZVkiLCJzdGFydE9mZnNldCIsInN0YXJ0VGltZSIsImVhc2luZ0xvb3AiLCJpbkdsb2JhbFRvdWNoIiwiaW5Mb2NhbFRvdWNoIiwiZ2xvYmFsVG91Y2hTdGFydCIsImdsb2JhbFRvdWNoRW5kIiwiZ2V0VG91Y2giLCJ0YXJnZXRUb3VjaGVzIiwic2hvdWxkSGFuZGxlIiwicG9pbnRlclR5cGUiLCJNU1BPSU5URVJfVFlQRV9NT1VTRSIsInRvdWNoU3RhcnQiLCJ0b3VjaCIsImdldFRpbWUiLCJ0b3VjaE1vdmUiLCJjdXJyZW50T2Zmc2V0IiwiY3VycmVudFRpbWUiLCJ0aW1lR2FwIiwidG91Y2hFbmQiLCJQb2ludGVyRXZlbnQiLCJNU1BvaW50ZXJFdmVudCIsIm5hdGl2ZVNjcm9sbEhhbmRsZXIiLCJ1c2VyU2V0dGluZ3MiLCJoYW5kbGVyTmFtZSIsImRlZmF1bHRTZXR0aW5ncyIsImd1aWQiLCJJbnN0YW5jZSIsImlzUnRsIiwiaXNOZWdhdGl2ZVNjcm9sbCIsIm9yaWdpbmFsU2Nyb2xsTGVmdCIsInNldEF0dHJpYnV0ZSIsInNjcm9sbGJhclhCb3R0b20iLCJpc1Njcm9sbGJhclhVc2luZ0JvdHRvbSIsInNjcm9sbGJhclhUb3AiLCJyYWlsQm9yZGVyWFdpZHRoIiwicmFpbFhNYXJnaW5XaWR0aCIsInNjcm9sbGJhcllSaWdodCIsImlzU2Nyb2xsYmFyWVVzaW5nUmlnaHQiLCJzY3JvbGxiYXJZTGVmdCIsInNjcm9sbGJhcllPdXRlcldpZHRoIiwicmFpbEJvcmRlcllXaWR0aCIsInJhaWxZTWFyZ2luSGVpZ2h0IiwiZ2V0SWQiLCJzZXRJZCIsInJlbW92ZUlkIiwicmVtb3ZlQXR0cmlidXRlIiwibmV3SWQiLCJnZXRUaHVtYlNpemUiLCJ0aHVtYlNpemUiLCJ1cGRhdGVDc3MiLCJ4UmFpbE9mZnNldCIsInlSYWlsT2Zmc2V0IiwiZXhpc3RpbmdSYWlscyIsInJhaWwiLCJ1cEV2ZW50IiwiY3JlYXRlRXZlbnQiLCJkb3duRXZlbnQiLCJsZWZ0RXZlbnQiLCJyaWdodEV2ZW50IiwieUV2ZW50IiwieEV2ZW50IiwieFN0YXJ0RXZlbnQiLCJ4RW5kRXZlbnQiLCJ5U3RhcnRFdmVudCIsInlFbmRFdmVudCIsImxhc3RUb3AiLCJsYXN0TGVmdCIsImluaXRFdmVudCIsImRpc3BhdGNoRXZlbnQiLCJTbGljayIsImFjY2Vzc2liaWxpdHkiLCJhZGFwdGl2ZUhlaWdodCIsImFwcGVuZEFycm93cyIsImFwcGVuZERvdHMiLCJhcnJvd3MiLCJhc05hdkZvciIsInByZXZBcnJvdyIsIm5leHRBcnJvdyIsImF1dG9wbGF5U3BlZWQiLCJjZW50ZXJNb2RlIiwiY2VudGVyUGFkZGluZyIsImNzc0Vhc2UiLCJjdXN0b21QYWdpbmciLCJkb3RzQ2xhc3MiLCJkcmFnZ2FibGUiLCJlYXNpbmciLCJlZGdlRnJpY3Rpb24iLCJmYWRlIiwiaW5pdGlhbFNsaWRlIiwibGF6eUxvYWQiLCJtb2JpbGVGaXJzdCIsInBhdXNlT25Ib3ZlciIsInBhdXNlT25Eb3RzSG92ZXIiLCJyZXNwb25kVG8iLCJyb3dzIiwicnRsIiwic2xpZGVzUGVyUm93Iiwic3dpcGUiLCJzd2lwZVRvU2xpZGUiLCJ0b3VjaFRocmVzaG9sZCIsInVzZUNTUyIsInVzZVRyYW5zZm9ybSIsInZhcmlhYmxlV2lkdGgiLCJ2ZXJ0aWNhbCIsInZlcnRpY2FsU3dpcGluZyIsIndhaXRGb3JBbmltYXRlIiwiaW5pdGlhbHMiLCJhbmltYXRpbmciLCJkcmFnZ2luZyIsImF1dG9QbGF5VGltZXIiLCJjdXJyZW50RGlyZWN0aW9uIiwiY3VycmVudFNsaWRlIiwiJGRvdHMiLCJsaXN0V2lkdGgiLCJsaXN0SGVpZ2h0IiwibG9hZEluZGV4IiwiJG5leHRBcnJvdyIsIiRwcmV2QXJyb3ciLCJzbGlkZVdpZHRoIiwiJHNsaWRlVHJhY2siLCIkc2xpZGVzIiwic2xpZGVPZmZzZXQiLCJzd2lwZUxlZnQiLCIkbGlzdCIsInRvdWNoT2JqZWN0IiwidHJhbnNmb3Jtc0VuYWJsZWQiLCJ1bnNsaWNrZWQiLCJhY3RpdmVCcmVha3BvaW50IiwiYW5pbVR5cGUiLCJhbmltUHJvcCIsImJyZWFrcG9pbnRzIiwiYnJlYWtwb2ludFNldHRpbmdzIiwiY3NzVHJhbnNpdGlvbnMiLCJoaWRkZW4iLCJwb3NpdGlvblByb3AiLCJyb3dDb3VudCIsInNob3VsZENsaWNrIiwiJHNsaWRlciIsIiRzbGlkZXNDYWNoZSIsInRyYW5zZm9ybVR5cGUiLCJ0cmFuc2l0aW9uVHlwZSIsInZpc2liaWxpdHlDaGFuZ2UiLCJ3aW5kb3dXaWR0aCIsIndpbmRvd1RpbWVyIiwib3JpZ2luYWxTZXR0aW5ncyIsIm1vekhpZGRlbiIsIndlYmtpdEhpZGRlbiIsImF1dG9QbGF5IiwiYXV0b1BsYXlDbGVhciIsImNoYW5nZVNsaWRlIiwiY2xpY2tIYW5kbGVyIiwic2VsZWN0SGFuZGxlciIsInNldFBvc2l0aW9uIiwic3dpcGVIYW5kbGVyIiwiZHJhZ0hhbmRsZXIiLCJrZXlIYW5kbGVyIiwiYXV0b1BsYXlJdGVyYXRvciIsImluc3RhbmNlVWlkIiwiaHRtbEV4cHIiLCJyZWdpc3RlckJyZWFrcG9pbnRzIiwiY2hlY2tSZXNwb25zaXZlIiwiYWRkU2xpZGUiLCJzbGlja0FkZCIsInVubG9hZCIsImluc2VydEJlZm9yZSIsInByZXBlbmRUbyIsInJlaW5pdCIsImFuaW1hdGVIZWlnaHQiLCJvdXRlckhlaWdodCIsImFuaW1hdGVTbGlkZSIsImFuaW1TdGFydCIsImR1cmF0aW9uIiwic3RlcCIsImNlaWwiLCJhcHBseVRyYW5zaXRpb24iLCJkaXNhYmxlVHJhbnNpdGlvbiIsIm5vdCIsInNsaWRlSGFuZGxlciIsImJ1aWxkQXJyb3dzIiwidGFiaW5kZXgiLCJidWlsZERvdHMiLCJnZXREb3RDb3VudCIsImJ1aWxkT3V0Iiwid3JhcEFsbCIsInNldHVwSW5maW5pdGUiLCJ1cGRhdGVEb3RzIiwic2V0U2xpZGVDbGFzc2VzIiwiYnVpbGRSb3dzIiwiY3JlYXRlRG9jdW1lbnRGcmFnbWVudCIsImNoZWNrTmF2aWdhYmxlIiwiZ2V0TmF2aWdhYmxlSW5kZXhlcyIsImNsZWFuVXBFdmVudHMiLCJzZXRQYXVzZWQiLCJvcmllbnRhdGlvbkNoYW5nZSIsImNsZWFuVXBSb3dzIiwic3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uIiwiZmFkZVNsaWRlIiwib3BhY2l0eSIsImZhZGVTbGlkZU91dCIsImZpbHRlclNsaWRlcyIsInNsaWNrRmlsdGVyIiwiZ2V0Q3VycmVudCIsInNsaWNrQ3VycmVudFNsaWRlIiwiZ2V0TGVmdCIsImdldE9wdGlvbiIsInNsaWNrR2V0T3B0aW9uIiwiZ2V0U2xpY2siLCJnZXRTbGlkZUNvdW50IiwiZ29UbyIsInNsaWNrR29UbyIsInNldFByb3BzIiwic3RhcnRMb2FkIiwibG9hZFNsaWRlciIsImluaXRpYWxpemVFdmVudHMiLCJ1cGRhdGVBcnJvd3MiLCJpbml0QURBIiwiaW5pdEFycm93RXZlbnRzIiwiaW5pdERvdEV2ZW50cyIsImluaXRVSSIsIm9ubG9hZCIsInByb2dyZXNzaXZlTGF6eUxvYWQiLCJzbGlja05leHQiLCJzbGlja1BhdXNlIiwicGxheSIsInNsaWNrUGxheSIsInBvc3RTbGlkZSIsInNsaWNrUHJldiIsImZvY3VzSGFuZGxlciIsIndpbmRvd0RlbGF5IiwicmVtb3ZlU2xpZGUiLCJzbGlja1JlbW92ZSIsInNldENTUyIsInNldERpbWVuc2lvbnMiLCJzZXRGYWRlIiwic2V0SGVpZ2h0Iiwic2V0T3B0aW9uIiwic2xpY2tTZXRPcHRpb24iLCJtc1RyYW5zaXRpb24iLCJPVHJhbnNmb3JtIiwicGVyc3BlY3RpdmVQcm9wZXJ0eSIsIndlYmtpdFBlcnNwZWN0aXZlIiwiTW96VHJhbnNmb3JtIiwiTW96UGVyc3BlY3RpdmUiLCJ3ZWJraXRUcmFuc2Zvcm0iLCJtc1RyYW5zZm9ybSIsInRyYW5zZm9ybSIsInN3aXBlRGlyZWN0aW9uIiwic3RhcnRYIiwiY3VyWCIsInN0YXJ0WSIsImN1clkiLCJhdGFuMiIsIlBJIiwic3dpcGVFbmQiLCJzd2lwZUxlbmd0aCIsImVkZ2VIaXQiLCJtaW5Td2lwZSIsImZpbmdlckNvdW50Iiwib3JpZ2luYWxFdmVudCIsInRvdWNoZXMiLCJzd2lwZVN0YXJ0Iiwic3dpcGVNb3ZlIiwic3FydCIsInBvdyIsInVuZmlsdGVyU2xpZGVzIiwic2xpY2tVbmZpbHRlciIsInJvbGUiLCJhY3RpdmF0ZUFEQSIsImlzUGxheSIsIkVsZW1lbnQiLCJvTWF0Y2hlc1NlbGVjdG9yIiwiZGVsZWdhdGVUYXJnZXQiLCJIVE1MRWxlbWVudCIsIm5vZGVUeXBlIiwibm9kZUxpc3QiLCJzdHJpbmciLCJmdW5jdGlvbiIsIlR5cGVFcnJvciIsImRlbGVnYXRlIiwic2V0U2VsZWN0aW9uUmFuZ2UiLCJoYXNBdHRyaWJ1dGUiLCJjcmVhdGVSYW5nZSIsInNlbGVjdE5vZGVDb250ZW50cyIsInJlbW92ZUFsbFJhbmdlcyIsImFkZFJhbmdlIiwiZW1pdCIsIl9fZXNNb2R1bGUiLCJlbnVtZXJhYmxlIiwiY29uZmlndXJhYmxlIiwid3JpdGFibGUiLCJkZWZpbmVQcm9wZXJ0eSIsInJlc29sdmVPcHRpb25zIiwiaW5pdFNlbGVjdGlvbiIsImVtaXR0ZXIiLCJzZWxlY3RlZFRleHQiLCJzZWxlY3RGYWtlIiwic2VsZWN0VGFyZ2V0IiwicmVtb3ZlRmFrZSIsImZha2VIYW5kbGVyIiwiZmFrZUVsZW0iLCJjb3B5VGV4dCIsImV4ZWNDb21tYW5kIiwiaGFuZGxlUmVzdWx0IiwiX2FjdGlvbiIsIl90YXJnZXQiLCJjcmVhdGUiLCJzZXRQcm90b3R5cGVPZiIsIl9fcHJvdG9fXyIsImxpc3RlbkNsaWNrIiwiZGVmYXVsdEFjdGlvbiIsImRlZmF1bHRUYXJnZXQiLCJkZWZhdWx0VGV4dCIsImxpc3RlbmVyIiwib25DbGljayIsImNsaXBib2FyZEFjdGlvbiJdLCJtYXBwaW5ncyI6Ijs7QUFBQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxtREFBMkMsY0FBYzs7QUFFekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBMkIsMEJBQTBCLEVBQUU7QUFDdkQseUNBQWlDLGVBQWU7QUFDaEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0EsOERBQXNELCtEQUErRDs7QUFFckg7QUFDQTs7QUFFQTtBQUNBOzs7Ozs7O0FDaEVBLHFHOzs7Ozs7O0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOzs7O0FBSUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsUUFBUSxZQUFZOztBQUVwQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7O0FBRUYsb0JBQW9COztBQUVwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQztBQUMxQyxJQUFJO0FBQ0o7QUFDQSxFQUFFOztBQUVGLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVUsWUFBWTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsVUFBVSxTQUFTOztBQUVuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTLFlBQVk7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLFlBQVk7QUFDdEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxTQUFTO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7O0FBRUEsZ0JBQWdCLElBQUk7O0FBRXBCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLHdDQUF3QyxJQUFJO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQSxNQUFNOztBQUVOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFD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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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O0FBRTdEO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQzs7QUFFMUM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnRUFBZ0U7O0FBRWhFO0FBQ0E7QUFDQTtBQUNBLDZDQUE2Qzs7QUFFN0M7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSCxRQUFRLFNBQVM7QUFDakI7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsU0FBUztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLGlEQUFpRDtBQUN4RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlEQUFpRDtBQUNqRCxVQUFVLHdDQUF3QztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGdCQUFnQjtBQUMzQjtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLE1BQU07QUFDakIsV0FBVyxNQUFNO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7O0FBRUE7O0FBRUEsQ0FBQzs7OztBQUlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBLFFBQVEsR0FBRztBQUNYO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBOztBQUVBOzs7O0FBSUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7QUFDRjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdCQUFnQixTQUFTO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBLGNBQWMsU0FBUztBQUN2QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7OztBQUdEOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsU0FBUyxPQUFPO0FBQ2hCLHlCQUF5Qix3QkFBd0I7O0FBRWpEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0EsMENBQTBDO0FBQzFDLEVBQUU7QUFDRjtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7QUFDRDs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1COztBQUVuQjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLGNBQWM7QUFDeEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFROztBQUVSO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxNQUFNOztBQUVOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUixPQUFPO0FBQ1A7QUFDQSxNQUFNO0FBQ04sS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSw4Q0FBOEM7QUFDOUMsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7O0FBRUEsNENBQTRDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxZQUFZO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7OztBQUdEO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsOENBQThDLFNBQVMsUUFBUSxTQUFTLE1BQU07QUFDOUU7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsU0FBUyxTQUFTLFlBQVksVUFBVTs7QUFFOUU7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOzs7QUFHRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGtEQUFrRDtBQUNsRDtBQUNBOzs7OztBQUtBLG9CQUFvQixTQUFTO0FBQzdCOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsaURBQWlEO0FBQ2pEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLDJCQUEyQixJQUFJO0FBQy9COztBQUVBLHVFQUF1RTtBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7O0FBRUE7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBOztBQUVBO0FBQ0EsVUFBVTs7QUFFVjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQzs7O0FBR0Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osR0FBRztBQUNIO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxFQUFFO0FBQ0Y7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7OztBQUdEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxTQUFTLFFBQVEsU0FBUyxNQUFNO0FBQy9FOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSw0QkFBNEIsU0FBUyxRQUFRO0FBQzdDOztBQUVBO0FBQ0E7QUFDQSxvQ0FBb0MsNEJBQTRCO0FBQ2hFLDRCQUE0QixjQUFjLFNBQVMsU0FBUztBQUM1RCxpQkFBaUIsVUFBVTtBQUMzQjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxDQUFDO0FBQ0Q7O0FBRUE7OztBQUdBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG9CQUFvQixFQUFFO0FBQ3JDLGVBQWUscUNBQXFDLEVBQUU7QUFDdEQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsVUFBVSxZQUFZO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7OztBQUdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLCtCQUErQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0Esc0JBQXNCO0FBQ3RCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBLFFBQVEsT0FBTztBQUNmOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWEsNENBQTRDO0FBQ3pEOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7OztBQUdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSxnQkFBZ0I7QUFDbEI7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFdBQVc7O0FBRVg7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsMkNBQTJDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxzQ0FBc0MsY0FBYztBQUNwRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQSxHQUFHOztBQUVIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSwwREFBMEQ7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUEsc0JBQXNCO0FBQ3RCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsSUFBSTtBQUNKLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLHFDQUFxQzs7QUFFcEQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7OztBQUdEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMENBQTBDLE9BQU87QUFDakQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTtBQUNGOztBQUVBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLE9BQU87QUFDakI7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxnQkFBZ0IsZ0JBQWdCO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxRQUFRLCtCQUErQjs7QUFFdkM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLHFDQUFxQzs7QUFFcEQsb0RBQW9EO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxnQkFBZ0IscUNBQXFDO0FBQ3JEO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsU0FBUywrQkFBK0I7QUFDeEM7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBLFNBQVMsOEJBQThCOztBQUV2QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUU7O0FBRUY7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLFlBQVksT0FBTzs7QUFFbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFNBQVMsV0FBVztBQUNwQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQzs7O0FBR0Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlDQUFpQzs7QUFFakM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxxQ0FBcUMsVUFBVSxTQUFTLE1BQU0sYUFBYTtBQUMzRSxhQUFhLGVBQWU7QUFDNUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0Esa0NBQWtDLHNCQUFzQjtBQUN4RCxzQkFBc0IsY0FBYztBQUNwQyxnQkFBZ0IsV0FBVyxZQUFZO0FBQ3ZDLFdBQVc7O0FBRVg7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDLDJDQUEyQztBQUMzQyx5Q0FBeUMsZUFBZTs7QUFFeEQ7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLHFCQUFxQjs7QUFFN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw0QkFBNEIsU0FBUyxRQUFRLFFBQVE7QUFDckQ7O0FBRUE7QUFDQTtBQUNBLG9DQUFvQyw0QkFBNEI7QUFDaEUsNEJBQTRCLGNBQWMsU0FBUyxTQUFTO0FBQzVEO0FBQ0E7O0FBRUE7QUFDQSw0REFBNEQ7O0FBRTVEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxTQUFTLFVBQVU7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLENBQUM7OztBQUdEO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFlBQVksK0RBQStEO0FBQzNFO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxRQUFRLGdCQUFnQjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlCQUFpQixnQkFBZ0I7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxRQUFRLE9BQU87O0FBRWY7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLDRCQUE0QjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixnQkFBZ0I7QUFDbkM7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCOztBQUVqQjtBQUNBOztBQUVBLFVBQVUsT0FBTztBQUNqQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7O0FBRUE7QUFDQTtBQUNBOztBQUVBLFdBQVcsU0FBUztBQUNwQjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUU7QUFDRjtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxDQUFDOzs7QUFHRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsZUFBZTtBQUMxQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLFFBQVE7QUFDaEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLGdCQUFnQjtBQUN4Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSixHQUFHO0FBQ0g7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtB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QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7O0FBR0Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVcsU0FBUztBQUNwQjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE9BQU87O0FBRVA7QUFDQTtBQUNBOztBQUVBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7OztBQUtEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJOztBQUVKLHVDQUF1QztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFLQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLEdBQUc7QUFDSDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxF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Q0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNEO0FBQ3REO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsY0FBYyxvQ0FBb0M7QUFDbEQ7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQzs7O0FBR0Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLEdBQUc7QUFDSCxFQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSCxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxDQUFDOzs7QUFHRDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSCxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSCxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZCxNQUFNO0FBQ04sTUFBTTtBQUNOLEdBQUc7QUFDSDtBQUNBLENBQUM7OztBQUdEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCO0FBQ2xCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNOztBQUVOO0FBQ0E7QUFDQTtBQUNBLE1BQU07O0FBRU47QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7Ozs7O0FBS0Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7OztBQUtEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsSUFBSTtBQUNKLEdBQUc7QUFDSDs7QUFFQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7Ozs7O0FBS0Q7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGOzs7Ozs7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EscURBQXFEO0FBQ3JEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0EsVUFBVSxrQkFBa0I7QUFDNUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbUJBQW1CLGtCQUFrQjtBQUNyQzs7QUFFQSw0REFBNEQsZUFBZTtBQUMzRTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxDQUFDOztBQUVEO0FBQ0EsY0FBYyxzREFBc0Q7QUFDcEU7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7QUFHRDtBQUNBLGNBQWMsbUNBQW1DO0FBQ2pELGVBQWUsNkRBQTZEO0FBQzVFOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsRUFBRTtBQUNGLENBQUM7OztBQUdEOztBQUVBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7Ozs7QUFJQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7Ozs7Ozs7Ozs7Ozs7O0FDL3ZWRDs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7OztRQUdDQSxJO1FBQ0FDLE07UUFDQUMsSTtRQUNBQyxNO1FBQ0FDLE07UUFDQUMsYTs7Ozs7O0FDYkQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDRDQUE0Qzs7QUFFNUM7Ozs7Ozs7QUNwQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQSxLQUFLO0FBQ0w7QUFDQSw4Q0FBOEM7QUFDOUMsS0FBSztBQUNMO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsbUJBQW1CLHVCQUF1QjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNEJBQTRCLGdCQUFnQjtBQUM1Qzs7QUFFQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBELE9BQU87QUFDakU7QUFDQTtBQUNBLEtBQUs7QUFDTCxzREFBc0QsMEJBQTBCOztBQUVoRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsNkNBQTZDLE9BQU87QUFDcEQ7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxPQUFPO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQSw2Q0FBNkMsT0FBTztBQUNwRDtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxPQUFPO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsT0FBTztBQUNwRDtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsT0FBTztBQUNwRDtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdELE9BQU87QUFDL0Q7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtEQUFrRCxPQUFPO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQSxzRUFBc0UsT0FBTztBQUM3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0Esc0RBQXNELE9BQU87QUFDN0Q7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RCxPQUFPO0FBQ2hFO0FBQ0EsK0RBQStELE9BQU87QUFDdEU7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDREQUE0RDtBQUM1RDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0Esb0VBQW9FO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7O0FBRVQ7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUzs7QUFFVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsMkRBQTJELHFDQUFxQyxFQUFFO0FBQ2xHO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxhQUFhO0FBQ2I7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQSxTQUFTOztBQUVUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsVUFBVTtBQUN2QztBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0EsdURBQXVELE9BQU87QUFDOUQ7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DLG1DQUFtQyxxQ0FBcUM7QUFDeEU7QUFDQSwyQ0FBMkMsUUFBUTtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0VBQW9FO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQseURBQXlEO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCxRQUFRO0FBQzlEO0FBQ0EsbURBQW1ELFFBQVE7QUFDM0Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxvQ0FBb0MsbUNBQW1DLEVBQUU7QUFDekU7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFEOztBQUVyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBLCtEQUErRDs7QUFFL0Q7QUFDQTtBQUNBLDhCQUE4Qiw2QkFBNkI7QUFDM0QsNkNBQTZDLG9CQUFvQjs7QUFFakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQztBQUMzQywyQkFBMkIsc0JBQXNCO0FBQ2pEO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRCxPQUFPO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxrREFBa0Q7QUFDbEQsb0RBQW9EO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDRFQUE0RTtBQUM1RSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRDtBQUNuRDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLCtCQUErQix3QkFBd0I7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0Msb0NBQW9DO0FBQ3hFLFNBQVM7QUFDVCxvRkFBb0YsT0FBTztBQUMzRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsc0JBQXNCO0FBQzNDLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLE9BQU87QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBLHNEQUFzRDtBQUN0RDtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlELGlCQUFpQjtBQUMxRSxnQ0FBZ0MsNkJBQTZCO0FBQzdELFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMkVBQTJFO0FBQzNFLDBCQUEwQixzQ0FBc0M7QUFDaEU7QUFDQTtBQUNBO0FBQ0EsaUVBQWlFO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0EsbURBQW1EO0FBQ25EO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxTQUFTO0FBQ1QsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0M7QUFDL0Msc0ZBQXNGLHFCQUFxQjtBQUMzRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLDZDQUE2QztBQUM3QztBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBLGtFQUFrRTtBQUNsRTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLG9DQUFvQyxFQUFFO0FBQzVELGtDQUFrQyx3REFBd0QsRUFBRTtBQUM1RixrQ0FBa0Msd0VBQXdFO0FBQzFHOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwrREFBK0Q7QUFDL0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMEJBQTBCLHlCQUF5QjtBQUNuRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJJQUEySSxtQ0FBbUM7QUFDOUssdUJBQXVCLDRCQUE0QjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsMklBQTJJLG1DQUFtQztBQUM5SztBQUNBLGdEQUFnRCxRQUFRO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxjQUFjOztBQUU3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsb0JBQW9CO0FBQ3ZEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTJELGtCQUFrQjtBQUM3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnQ0FBZ0MsNEJBQTRCO0FBQzVEO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQztBQUMvQztBQUNBLFNBQVM7QUFDVDtBQUNBLDJGQUEyRix3QkFBd0I7QUFDbkg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwrQ0FBK0M7O0FBRS9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsT0FBTztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxjQUFjLE1BQU07QUFDcEIsY0FBYyxRQUFRO0FBQ3RCLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxjQUFjLE1BQU07QUFDcEIsY0FBYyxRQUFRO0FBQ3RCLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsY0FBYyxNQUFNO0FBQ3BCLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxjQUFjLE1BQU07QUFDcEIsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLGNBQWMsTUFBTTtBQUNwQixjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsY0FBYyxNQUFNO0FBQ3BCLGNBQWM7QUFDZDtBQUNBO0FB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyRUFBMkU7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUIsK0JBQStCLHFCQUFxQixFQUFFO0FBQ3RELE9BQU87QUFDUDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IscUhBQXFIO0FBQzdJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixzSEFBc0g7QUFDOUk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSCxFQUFFO0FBQ0Y7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Es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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7Ozs7OztBQzdORDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDZCQUE2Qjs7QUFFN0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDO0FBQ0Q7O0FBRUEsa0JBQWtCO0FBQ2xCOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0Esb0I7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBLEdB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDZGQUE2Rjs7QUFFN0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLFVBQVU7QUFDVjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCOztBQUU1QixPQUFPLFNBQVM7O0FBRWhCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNkNBQTZDLG9CQUFvQjtBQUNqRTs7QUFFQTtBQUNBLDJFQUEyRTtBQUMzRTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRSxHOzs7Ozs7QUN0K0NGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLFdBQVc7QUFDZjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0EsQyIsImZpbGUiOiJzY3JpcHQuanMiLCJzb3VyY2VzQ29udGVudCI6WyIgXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4gXHR2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xuXG4gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXG4gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuIFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSlcbiBcdFx0XHRyZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcblxuIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuIFx0XHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XG4gXHRcdFx0aTogbW9kdWxlSWQsXG4gXHRcdFx0bDogZmFsc2UsXG4gXHRcdFx0ZXhwb3J0czoge31cbiBcdFx0fTtcblxuIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbiBcdFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cbiBcdFx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuIFx0XHRtb2R1bGUubCA9IHRydWU7XG5cbiBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbiBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuIFx0fVxuXG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcblxuIFx0Ly8gaWRlbnRpdHkgZnVuY3Rpb24gZm9yIGNhbGxpbmcgaGFybW9ueSBpbXBvcnRzIHdpdGggdGhlIGNvcnJlY3QgY29udGV4dFxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5pID0gZnVuY3Rpb24odmFsdWUpIHsgcmV0dXJuIHZhbHVlOyB9O1xuXG4gXHQvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9uIGZvciBoYXJtb255IGV4cG9ydHNcbiBcdF9fd2VicGFja19yZXF1aXJlX18uZCA9IGZ1bmN0aW9uKGV4cG9ydHMsIG5hbWUsIGdldHRlcikge1xuIFx0XHRpZighX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIG5hbWUpKSB7XG4gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIG5hbWUsIHtcbiBcdFx0XHRcdGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gXHRcdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuIFx0XHRcdFx0Z2V0OiBnZXR0ZXJcbiBcdFx0XHR9KTtcbiBcdFx0fVxuIFx0fTtcblxuIFx0Ly8gZ2V0RGVmYXVsdEV4cG9ydCBmdW5jdGlvbiBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIG5vbi1oYXJtb255IG1vZHVsZXNcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubiA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuIFx0XHR2YXIgZ2V0dGVyID0gbW9kdWxlICYmIG1vZHVsZS5fX2VzTW9kdWxlID9cbiBcdFx0XHRmdW5jdGlvbiBnZXREZWZhdWx0KCkgeyByZXR1cm4gbW9kdWxlWydkZWZhdWx0J107IH0gOlxuIFx0XHRcdGZ1bmN0aW9uIGdldE1vZHVsZUV4cG9ydHMoKSB7IHJldHVybiBtb2R1bGU7IH07XG4gXHRcdF9fd2VicGFja19yZXF1aXJlX18uZChnZXR0ZXIsICdhJywgZ2V0dGVyKTtcbiBcdFx0cmV0dXJuIGdldHRlcjtcbiBcdH07XG5cbiBcdC8vIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbFxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5vID0gZnVuY3Rpb24ob2JqZWN0LCBwcm9wZXJ0eSkgeyByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpOyB9O1xuXG4gXHQvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCJcIjtcblxuIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4gXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXyhfX3dlYnBhY2tfcmVxdWlyZV9fLnMgPSA2Myk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gd2VicGFjay9ib290c3RyYXAgNGJjNGZhMGIyMGE2ZmY0MTM4MzIiLCJtb2R1bGUuZXhwb3J0cyA9IGdsb2JhbFtcImtvXCJdID0gcmVxdWlyZShcIi0hLlxcXFxrbm9ja291dC1sYXRlc3QuZGVidWcuanNcIik7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2V4cG9zZS1sb2FkZXI/a28hLi9+L2tub2Nrb3V0L2J1aWxkL291dHB1dC9rbm9ja291dC1sYXRlc3QuZGVidWcuanNcbi8vIG1vZHVsZSBpZCA9IDBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyohXG4gKiBqUXVlcnkgSmF2YVNjcmlwdCBMaWJyYXJ5IHYxLjEyLjRcbiAqIGh0dHA6Ly9qcXVlcnkuY29tL1xuICpcbiAqIEluY2x1ZGVzIFNpenpsZS5qc1xuICogaHR0cDovL3NpenpsZWpzLmNvbS9cbiAqXG4gKiBDb3B5cmlnaHQgalF1ZXJ5IEZvdW5kYXRpb24gYW5kIG90aGVyIGNvbnRyaWJ1dG9yc1xuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXG4gKiBodHRwOi8vanF1ZXJ5Lm9yZy9saWNlbnNlXG4gKlxuICogRGF0ZTogMjAxNi0wNS0yMFQxNzoxN1pcbiAqL1xuXG4oZnVuY3Rpb24oIGdsb2JhbCwgZmFjdG9yeSApIHtcblxuXHRpZiAoIHR5cGVvZiBtb2R1bGUgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIG1vZHVsZS5leHBvcnRzID09PSBcIm9iamVjdFwiICkge1xuXHRcdC8vIEZvciBDb21tb25KUyBhbmQgQ29tbW9uSlMtbGlrZSBlbnZpcm9ubWVudHMgd2hlcmUgYSBwcm9wZXIgYHdpbmRvd2Bcblx0XHQvLyBpcyBwcmVzZW50LCBleGVjdXRlIHRoZSBmYWN0b3J5IGFuZCBnZXQgalF1ZXJ5LlxuXHRcdC8vIEZvciBlbnZpcm9ubWVudHMgdGhhdCBkbyBub3QgaGF2ZSBhIGB3aW5kb3dgIHdpdGggYSBgZG9jdW1lbnRgXG5cdFx0Ly8gKHN1Y2ggYXMgTm9kZS5qcyksIGV4cG9zZSBhIGZhY3RvcnkgYXMgbW9kdWxlLmV4cG9ydHMuXG5cdFx0Ly8gVGhpcyBhY2NlbnR1YXRlcyB0aGUgbmVlZCBmb3IgdGhlIGNyZWF0aW9uIG9mIGEgcmVhbCBgd2luZG93YC5cblx0XHQvLyBlLmcuIHZhciBqUXVlcnkgPSByZXF1aXJlKFwianF1ZXJ5XCIpKHdpbmRvdyk7XG5cdFx0Ly8gU2VlIHRpY2tldCAjMTQ1NDkgZm9yIG1vcmUgaW5mby5cblx0XHRtb2R1bGUuZXhwb3J0cyA9IGdsb2JhbC5kb2N1bWVudCA/XG5cdFx0XHRmYWN0b3J5KCBnbG9iYWwsIHRydWUgKSA6XG5cdFx0XHRmdW5jdGlvbiggdyApIHtcblx0XHRcdFx0aWYgKCAhdy5kb2N1bWVudCApIHtcblx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoIFwialF1ZXJ5IHJlcXVpcmVzIGEgd2luZG93IHdpdGggYSBkb2N1bWVudFwiICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIGZhY3RvcnkoIHcgKTtcblx0XHRcdH07XG5cdH0gZWxzZSB7XG5cdFx0ZmFjdG9yeSggZ2xvYmFsICk7XG5cdH1cblxuLy8gUGFzcyB0aGlzIGlmIHdpbmRvdyBpcyBub3QgZGVmaW5lZCB5ZXRcbn0odHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHRoaXMsIGZ1bmN0aW9uKCB3aW5kb3csIG5vR2xvYmFsICkge1xuXG4vLyBTdXBwb3J0OiBGaXJlZm94IDE4K1xuLy8gQ2FuJ3QgYmUgaW4gc3RyaWN0IG1vZGUsIHNldmVyYWwgbGlicyBpbmNsdWRpbmcgQVNQLk5FVCB0cmFjZVxuLy8gdGhlIHN0YWNrIHZpYSBhcmd1bWVudHMuY2FsbGVyLmNhbGxlZSBhbmQgRmlyZWZveCBkaWVzIGlmXG4vLyB5b3UgdHJ5IHRvIHRyYWNlIHRocm91Z2ggXCJ1c2Ugc3RyaWN0XCIgY2FsbCBjaGFpbnMuICgjMTMzMzUpXG4vL1widXNlIHN0cmljdFwiO1xudmFyIGRlbGV0ZWRJZHMgPSBbXTtcblxudmFyIGRvY3VtZW50ID0gd2luZG93LmRvY3VtZW50O1xuXG52YXIgc2xpY2UgPSBkZWxldGVkSWRzLnNsaWNlO1xuXG52YXIgY29uY2F0ID0gZGVsZXRlZElkcy5jb25jYXQ7XG5cbnZhciBwdXNoID0gZGVsZXRlZElkcy5wdXNoO1xuXG52YXIgaW5kZXhPZiA9IGRlbGV0ZWRJZHMuaW5kZXhPZjtcblxudmFyIGNsYXNzMnR5cGUgPSB7fTtcblxudmFyIHRvU3RyaW5nID0gY2xhc3MydHlwZS50b1N0cmluZztcblxudmFyIGhhc093biA9IGNsYXNzMnR5cGUuaGFzT3duUHJvcGVydHk7XG5cbnZhciBzdXBwb3J0ID0ge307XG5cblxuXG52YXJcblx0dmVyc2lvbiA9IFwiMS4xMi40XCIsXG5cblx0Ly8gRGVmaW5lIGEgbG9jYWwgY29weSBvZiBqUXVlcnlcblx0alF1ZXJ5ID0gZnVuY3Rpb24oIHNlbGVjdG9yLCBjb250ZXh0ICkge1xuXG5cdFx0Ly8gVGhlIGpRdWVyeSBvYmplY3QgaXMgYWN0dWFsbHkganVzdCB0aGUgaW5pdCBjb25zdHJ1Y3RvciAnZW5oYW5jZWQnXG5cdFx0Ly8gTmVlZCBpbml0IGlmIGpRdWVyeSBpcyBjYWxsZWQgKGp1c3QgYWxsb3cgZXJyb3IgdG8gYmUgdGhyb3duIGlmIG5vdCBpbmNsdWRlZClcblx0XHRyZXR1cm4gbmV3IGpRdWVyeS5mbi5pbml0KCBzZWxlY3RvciwgY29udGV4dCApO1xuXHR9LFxuXG5cdC8vIFN1cHBvcnQ6IEFuZHJvaWQ8NC4xLCBJRTw5XG5cdC8vIE1ha2Ugc3VyZSB3ZSB0cmltIEJPTSBhbmQgTkJTUFxuXHRydHJpbSA9IC9eW1xcc1xcdUZFRkZcXHhBMF0rfFtcXHNcXHVGRUZGXFx4QTBdKyQvZyxcblxuXHQvLyBNYXRjaGVzIGRhc2hlZCBzdHJpbmcgZm9yIGNhbWVsaXppbmdcblx0cm1zUHJlZml4ID0gL14tbXMtLyxcblx0cmRhc2hBbHBoYSA9IC8tKFtcXGRhLXpdKS9naSxcblxuXHQvLyBVc2VkIGJ5IGpRdWVyeS5jYW1lbENhc2UgYXMgY2FsbGJhY2sgdG8gcmVwbGFjZSgpXG5cdGZjYW1lbENhc2UgPSBmdW5jdGlvbiggYWxsLCBsZXR0ZXIgKSB7XG5cdFx0cmV0dXJuIGxldHRlci50b1VwcGVyQ2FzZSgpO1xuXHR9O1xuXG5qUXVlcnkuZm4gPSBqUXVlcnkucHJvdG90eXBlID0ge1xuXG5cdC8vIFRoZSBjdXJyZW50IHZlcnNpb24gb2YgalF1ZXJ5IGJlaW5nIHVzZWRcblx0anF1ZXJ5OiB2ZXJzaW9uLFxuXG5cdGNvbnN0cnVjdG9yOiBqUXVlcnksXG5cblx0Ly8gU3RhcnQgd2l0aCBhbiBlbXB0eSBzZWxlY3RvclxuXHRzZWxlY3RvcjogXCJcIixcblxuXHQvLyBUaGUgZGVmYXVsdCBsZW5ndGggb2YgYSBqUXVlcnkgb2JqZWN0IGlzIDBcblx0bGVuZ3RoOiAwLFxuXG5cdHRvQXJyYXk6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBzbGljZS5jYWxsKCB0aGlzICk7XG5cdH0sXG5cblx0Ly8gR2V0IHRoZSBOdGggZWxlbWVudCBpbiB0aGUgbWF0Y2hlZCBlbGVtZW50IHNldCBPUlxuXHQvLyBHZXQgdGhlIHdob2xlIG1hdGNoZWQgZWxlbWVudCBzZXQgYXMgYSBjbGVhbiBhcnJheVxuXHRnZXQ6IGZ1bmN0aW9uKCBudW0gKSB7XG5cdFx0cmV0dXJuIG51bSAhPSBudWxsID9cblxuXHRcdFx0Ly8gUmV0dXJuIGp1c3QgdGhlIG9uZSBlbGVtZW50IGZyb20gdGhlIHNldFxuXHRcdFx0KCBudW0gPCAwID8gdGhpc1sgbnVtICsgdGhpcy5sZW5ndGggXSA6IHRoaXNbIG51bSBdICkgOlxuXG5cdFx0XHQvLyBSZXR1cm4gYWxsIHRoZSBlbGVtZW50cyBpbiBhIGNsZWFuIGFycmF5XG5cdFx0XHRzbGljZS5jYWxsKCB0aGlzICk7XG5cdH0sXG5cblx0Ly8gVGFrZSBhbiBhcnJheSBvZiBlbGVtZW50cyBhbmQgcHVzaCBpdCBvbnRvIHRoZSBzdGFja1xuXHQvLyAocmV0dXJuaW5nIHRoZSBuZXcgbWF0Y2hlZCBlbGVtZW50IHNldClcblx0cHVzaFN0YWNrOiBmdW5jdGlvbiggZWxlbXMgKSB7XG5cblx0XHQvLyBCdWlsZCBhIG5ldyBqUXVlcnkgbWF0Y2hlZCBlbGVtZW50IHNldFxuXHRcdHZhciByZXQgPSBqUXVlcnkubWVyZ2UoIHRoaXMuY29uc3RydWN0b3IoKSwgZWxlbXMgKTtcblxuXHRcdC8vIEFkZCB0aGUgb2xkIG9iamVjdCBvbnRvIHRoZSBzdGFjayAoYXMgYSByZWZlcmVuY2UpXG5cdFx0cmV0LnByZXZPYmplY3QgPSB0aGlzO1xuXHRcdHJldC5jb250ZXh0ID0gdGhpcy5jb250ZXh0O1xuXG5cdFx0Ly8gUmV0dXJuIHRoZSBuZXdseS1mb3JtZWQgZWxlbWVudCBzZXRcblx0XHRyZXR1cm4gcmV0O1xuXHR9LFxuXG5cdC8vIEV4ZWN1dGUgYSBjYWxsYmFjayBmb3IgZXZlcnkgZWxlbWVudCBpbiB0aGUgbWF0Y2hlZCBzZXQuXG5cdGVhY2g6IGZ1bmN0aW9uKCBjYWxsYmFjayApIHtcblx0XHRyZXR1cm4galF1ZXJ5LmVhY2goIHRoaXMsIGNhbGxiYWNrICk7XG5cdH0sXG5cblx0bWFwOiBmdW5jdGlvbiggY2FsbGJhY2sgKSB7XG5cdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCBqUXVlcnkubWFwKCB0aGlzLCBmdW5jdGlvbiggZWxlbSwgaSApIHtcblx0XHRcdHJldHVybiBjYWxsYmFjay5jYWxsKCBlbGVtLCBpLCBlbGVtICk7XG5cdFx0fSApICk7XG5cdH0sXG5cblx0c2xpY2U6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayggc2xpY2UuYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApICk7XG5cdH0sXG5cblx0Zmlyc3Q6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLmVxKCAwICk7XG5cdH0sXG5cblx0bGFzdDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuZXEoIC0xICk7XG5cdH0sXG5cblx0ZXE6IGZ1bmN0aW9uKCBpICkge1xuXHRcdHZhciBsZW4gPSB0aGlzLmxlbmd0aCxcblx0XHRcdGogPSAraSArICggaSA8IDAgPyBsZW4gOiAwICk7XG5cdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCBqID49IDAgJiYgaiA8IGxlbiA/IFsgdGhpc1sgaiBdIF0gOiBbXSApO1xuXHR9LFxuXG5cdGVuZDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMucHJldk9iamVjdCB8fCB0aGlzLmNvbnN0cnVjdG9yKCk7XG5cdH0sXG5cblx0Ly8gRm9yIGludGVybmFsIHVzZSBvbmx5LlxuXHQvLyBCZWhhdmVzIGxpa2UgYW4gQXJyYXkncyBtZXRob2QsIG5vdCBsaWtlIGEgalF1ZXJ5IG1ldGhvZC5cblx0cHVzaDogcHVzaCxcblx0c29ydDogZGVsZXRlZElkcy5zb3J0LFxuXHRzcGxpY2U6IGRlbGV0ZWRJZHMuc3BsaWNlXG59O1xuXG5qUXVlcnkuZXh0ZW5kID0galF1ZXJ5LmZuLmV4dGVuZCA9IGZ1bmN0aW9uKCkge1xuXHR2YXIgc3JjLCBjb3B5SXNBcnJheSwgY29weSwgbmFtZSwgb3B0aW9ucywgY2xvbmUsXG5cdFx0dGFyZ2V0ID0gYXJndW1lbnRzWyAwIF0gfHwge30sXG5cdFx0aSA9IDEsXG5cdFx0bGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aCxcblx0XHRkZWVwID0gZmFsc2U7XG5cblx0Ly8gSGFuZGxlIGEgZGVlcCBjb3B5IHNpdHVhdGlvblxuXHRpZiAoIHR5cGVvZiB0YXJnZXQgPT09IFwiYm9vbGVhblwiICkge1xuXHRcdGRlZXAgPSB0YXJnZXQ7XG5cblx0XHQvLyBza2lwIHRoZSBib29sZWFuIGFuZCB0aGUgdGFyZ2V0XG5cdFx0dGFyZ2V0ID0gYXJndW1lbnRzWyBpIF0gfHwge307XG5cdFx0aSsrO1xuXHR9XG5cblx0Ly8gSGFuZGxlIGNhc2Ugd2hlbiB0YXJnZXQgaXMgYSBzdHJpbmcgb3Igc29tZXRoaW5nIChwb3NzaWJsZSBpbiBkZWVwIGNvcHkpXG5cdGlmICggdHlwZW9mIHRhcmdldCAhPT0gXCJvYmplY3RcIiAmJiAhalF1ZXJ5LmlzRnVuY3Rpb24oIHRhcmdldCApICkge1xuXHRcdHRhcmdldCA9IHt9O1xuXHR9XG5cblx0Ly8gZXh0ZW5kIGpRdWVyeSBpdHNlbGYgaWYgb25seSBvbmUgYXJndW1lbnQgaXMgcGFzc2VkXG5cdGlmICggaSA9PT0gbGVuZ3RoICkge1xuXHRcdHRhcmdldCA9IHRoaXM7XG5cdFx0aS0tO1xuXHR9XG5cblx0Zm9yICggOyBpIDwgbGVuZ3RoOyBpKysgKSB7XG5cblx0XHQvLyBPbmx5IGRlYWwgd2l0aCBub24tbnVsbC91bmRlZmluZWQgdmFsdWVzXG5cdFx0aWYgKCAoIG9wdGlvbnMgPSBhcmd1bWVudHNbIGkgXSApICE9IG51bGwgKSB7XG5cblx0XHRcdC8vIEV4dGVuZCB0aGUgYmFzZSBvYmplY3Rcblx0XHRcdGZvciAoIG5hbWUgaW4gb3B0aW9ucyApIHtcblx0XHRcdFx0c3JjID0gdGFyZ2V0WyBuYW1lIF07XG5cdFx0XHRcdGNvcHkgPSBvcHRpb25zWyBuYW1lIF07XG5cblx0XHRcdFx0Ly8gUHJldmVudCBuZXZlci1lbmRpbmcgbG9vcFxuXHRcdFx0XHRpZiAoIHRhcmdldCA9PT0gY29weSApIHtcblx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFJlY3Vyc2UgaWYgd2UncmUgbWVyZ2luZyBwbGFpbiBvYmplY3RzIG9yIGFycmF5c1xuXHRcdFx0XHRpZiAoIGRlZXAgJiYgY29weSAmJiAoIGpRdWVyeS5pc1BsYWluT2JqZWN0KCBjb3B5ICkgfHxcblx0XHRcdFx0XHQoIGNvcHlJc0FycmF5ID0galF1ZXJ5LmlzQXJyYXkoIGNvcHkgKSApICkgKSB7XG5cblx0XHRcdFx0XHRpZiAoIGNvcHlJc0FycmF5ICkge1xuXHRcdFx0XHRcdFx0Y29weUlzQXJyYXkgPSBmYWxzZTtcblx0XHRcdFx0XHRcdGNsb25lID0gc3JjICYmIGpRdWVyeS5pc0FycmF5KCBzcmMgKSA/IHNyYyA6IFtdO1xuXG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdGNsb25lID0gc3JjICYmIGpRdWVyeS5pc1BsYWluT2JqZWN0KCBzcmMgKSA/IHNyYyA6IHt9O1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIE5ldmVyIG1vdmUgb3JpZ2luYWwgb2JqZWN0cywgY2xvbmUgdGhlbVxuXHRcdFx0XHRcdHRhcmdldFsgbmFtZSBdID0galF1ZXJ5LmV4dGVuZCggZGVlcCwgY2xvbmUsIGNvcHkgKTtcblxuXHRcdFx0XHQvLyBEb24ndCBicmluZyBpbiB1bmRlZmluZWQgdmFsdWVzXG5cdFx0XHRcdH0gZWxzZSBpZiAoIGNvcHkgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHR0YXJnZXRbIG5hbWUgXSA9IGNvcHk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvLyBSZXR1cm4gdGhlIG1vZGlmaWVkIG9iamVjdFxuXHRyZXR1cm4gdGFyZ2V0O1xufTtcblxualF1ZXJ5LmV4dGVuZCgge1xuXG5cdC8vIFVuaXF1ZSBmb3IgZWFjaCBjb3B5IG9mIGpRdWVyeSBvbiB0aGUgcGFnZVxuXHRleHBhbmRvOiBcImpRdWVyeVwiICsgKCB2ZXJzaW9uICsgTWF0aC5yYW5kb20oKSApLnJlcGxhY2UoIC9cXEQvZywgXCJcIiApLFxuXG5cdC8vIEFzc3VtZSBqUXVlcnkgaXMgcmVhZHkgd2l0aG91dCB0aGUgcmVhZHkgbW9kdWxlXG5cdGlzUmVhZHk6IHRydWUsXG5cblx0ZXJyb3I6IGZ1bmN0aW9uKCBtc2cgKSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKCBtc2cgKTtcblx0fSxcblxuXHRub29wOiBmdW5jdGlvbigpIHt9LFxuXG5cdC8vIFNlZSB0ZXN0L3VuaXQvY29yZS5qcyBmb3IgZGV0YWlscyBjb25jZXJuaW5nIGlzRnVuY3Rpb24uXG5cdC8vIFNpbmNlIHZlcnNpb24gMS4zLCBET00gbWV0aG9kcyBhbmQgZnVuY3Rpb25zIGxpa2UgYWxlcnRcblx0Ly8gYXJlbid0IHN1cHBvcnRlZC4gVGhleSByZXR1cm4gZmFsc2Ugb24gSUUgKCMyOTY4KS5cblx0aXNGdW5jdGlvbjogZnVuY3Rpb24oIG9iaiApIHtcblx0XHRyZXR1cm4galF1ZXJ5LnR5cGUoIG9iaiApID09PSBcImZ1bmN0aW9uXCI7XG5cdH0sXG5cblx0aXNBcnJheTogQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiggb2JqICkge1xuXHRcdHJldHVybiBqUXVlcnkudHlwZSggb2JqICkgPT09IFwiYXJyYXlcIjtcblx0fSxcblxuXHRpc1dpbmRvdzogZnVuY3Rpb24oIG9iaiApIHtcblx0XHQvKiBqc2hpbnQgZXFlcWVxOiBmYWxzZSAqL1xuXHRcdHJldHVybiBvYmogIT0gbnVsbCAmJiBvYmogPT0gb2JqLndpbmRvdztcblx0fSxcblxuXHRpc051bWVyaWM6IGZ1bmN0aW9uKCBvYmogKSB7XG5cblx0XHQvLyBwYXJzZUZsb2F0IE5hTnMgbnVtZXJpYy1jYXN0IGZhbHNlIHBvc2l0aXZlcyAobnVsbHx0cnVlfGZhbHNlfFwiXCIpXG5cdFx0Ly8gLi4uYnV0IG1pc2ludGVycHJldHMgbGVhZGluZy1udW1iZXIgc3RyaW5ncywgcGFydGljdWxhcmx5IGhleCBsaXRlcmFscyAoXCIweC4uLlwiKVxuXHRcdC8vIHN1YnRyYWN0aW9uIGZvcmNlcyBpbmZpbml0aWVzIHRvIE5hTlxuXHRcdC8vIGFkZGluZyAxIGNvcnJlY3RzIGxvc3Mgb2YgcHJlY2lzaW9uIGZyb20gcGFyc2VGbG9hdCAoIzE1MTAwKVxuXHRcdHZhciByZWFsU3RyaW5nT2JqID0gb2JqICYmIG9iai50b1N0cmluZygpO1xuXHRcdHJldHVybiAhalF1ZXJ5LmlzQXJyYXkoIG9iaiApICYmICggcmVhbFN0cmluZ09iaiAtIHBhcnNlRmxvYXQoIHJlYWxTdHJpbmdPYmogKSArIDEgKSA+PSAwO1xuXHR9LFxuXG5cdGlzRW1wdHlPYmplY3Q6IGZ1bmN0aW9uKCBvYmogKSB7XG5cdFx0dmFyIG5hbWU7XG5cdFx0Zm9yICggbmFtZSBpbiBvYmogKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXHRcdHJldHVybiB0cnVlO1xuXHR9LFxuXG5cdGlzUGxhaW5PYmplY3Q6IGZ1bmN0aW9uKCBvYmogKSB7XG5cdFx0dmFyIGtleTtcblxuXHRcdC8vIE11c3QgYmUgYW4gT2JqZWN0LlxuXHRcdC8vIEJlY2F1c2Ugb2YgSUUsIHdlIGFsc28gaGF2ZSB0byBjaGVjayB0aGUgcHJlc2VuY2Ugb2YgdGhlIGNvbnN0cnVjdG9yIHByb3BlcnR5LlxuXHRcdC8vIE1ha2Ugc3VyZSB0aGF0IERPTSBub2RlcyBhbmQgd2luZG93IG9iamVjdHMgZG9uJ3QgcGFzcyB0aHJvdWdoLCBhcyB3ZWxsXG5cdFx0aWYgKCAhb2JqIHx8IGpRdWVyeS50eXBlKCBvYmogKSAhPT0gXCJvYmplY3RcIiB8fCBvYmoubm9kZVR5cGUgfHwgalF1ZXJ5LmlzV2luZG93KCBvYmogKSApIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHR0cnkge1xuXG5cdFx0XHQvLyBOb3Qgb3duIGNvbnN0cnVjdG9yIHByb3BlcnR5IG11c3QgYmUgT2JqZWN0XG5cdFx0XHRpZiAoIG9iai5jb25zdHJ1Y3RvciAmJlxuXHRcdFx0XHQhaGFzT3duLmNhbGwoIG9iaiwgXCJjb25zdHJ1Y3RvclwiICkgJiZcblx0XHRcdFx0IWhhc093bi5jYWxsKCBvYmouY29uc3RydWN0b3IucHJvdG90eXBlLCBcImlzUHJvdG90eXBlT2ZcIiApICkge1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cdFx0fSBjYXRjaCAoIGUgKSB7XG5cblx0XHRcdC8vIElFOCw5IFdpbGwgdGhyb3cgZXhjZXB0aW9ucyBvbiBjZXJ0YWluIGhvc3Qgb2JqZWN0cyAjOTg5N1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdC8vIFN1cHBvcnQ6IElFPDlcblx0XHQvLyBIYW5kbGUgaXRlcmF0aW9uIG92ZXIgaW5oZXJpdGVkIHByb3BlcnRpZXMgYmVmb3JlIG93biBwcm9wZXJ0aWVzLlxuXHRcdGlmICggIXN1cHBvcnQub3duRmlyc3QgKSB7XG5cdFx0XHRmb3IgKCBrZXkgaW4gb2JqICkge1xuXHRcdFx0XHRyZXR1cm4gaGFzT3duLmNhbGwoIG9iaiwga2V5ICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gT3duIHByb3BlcnRpZXMgYXJlIGVudW1lcmF0ZWQgZmlyc3RseSwgc28gdG8gc3BlZWQgdXAsXG5cdFx0Ly8gaWYgbGFzdCBvbmUgaXMgb3duLCB0aGVuIGFsbCBwcm9wZXJ0aWVzIGFyZSBvd24uXG5cdFx0Zm9yICgga2V5IGluIG9iaiApIHt9XG5cblx0XHRyZXR1cm4ga2V5ID09PSB1bmRlZmluZWQgfHwgaGFzT3duLmNhbGwoIG9iaiwga2V5ICk7XG5cdH0sXG5cblx0dHlwZTogZnVuY3Rpb24oIG9iaiApIHtcblx0XHRpZiAoIG9iaiA9PSBudWxsICkge1xuXHRcdFx0cmV0dXJuIG9iaiArIFwiXCI7XG5cdFx0fVxuXHRcdHJldHVybiB0eXBlb2Ygb2JqID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBvYmogPT09IFwiZnVuY3Rpb25cIiA/XG5cdFx0XHRjbGFzczJ0eXBlWyB0b1N0cmluZy5jYWxsKCBvYmogKSBdIHx8IFwib2JqZWN0XCIgOlxuXHRcdFx0dHlwZW9mIG9iajtcblx0fSxcblxuXHQvLyBXb3JrYXJvdW5kcyBiYXNlZCBvbiBmaW5kaW5ncyBieSBKaW0gRHJpc2NvbGxcblx0Ly8gaHR0cDovL3dlYmxvZ3MuamF2YS5uZXQvYmxvZy9kcmlzY29sbC9hcmNoaXZlLzIwMDkvMDkvMDgvZXZhbC1qYXZhc2NyaXB0LWdsb2JhbC1jb250ZXh0XG5cdGdsb2JhbEV2YWw6IGZ1bmN0aW9uKCBkYXRhICkge1xuXHRcdGlmICggZGF0YSAmJiBqUXVlcnkudHJpbSggZGF0YSApICkge1xuXG5cdFx0XHQvLyBXZSB1c2UgZXhlY1NjcmlwdCBvbiBJbnRlcm5ldCBFeHBsb3JlclxuXHRcdFx0Ly8gV2UgdXNlIGFuIGFub255bW91cyBmdW5jdGlvbiBzbyB0aGF0IGNvbnRleHQgaXMgd2luZG93XG5cdFx0XHQvLyByYXRoZXIgdGhhbiBqUXVlcnkgaW4gRmlyZWZveFxuXHRcdFx0KCB3aW5kb3cuZXhlY1NjcmlwdCB8fCBmdW5jdGlvbiggZGF0YSApIHtcblx0XHRcdFx0d2luZG93WyBcImV2YWxcIiBdLmNhbGwoIHdpbmRvdywgZGF0YSApOyAvLyBqc2NzOmlnbm9yZSByZXF1aXJlRG90Tm90YXRpb25cblx0XHRcdH0gKSggZGF0YSApO1xuXHRcdH1cblx0fSxcblxuXHQvLyBDb252ZXJ0IGRhc2hlZCB0byBjYW1lbENhc2U7IHVzZWQgYnkgdGhlIGNzcyBhbmQgZGF0YSBtb2R1bGVzXG5cdC8vIE1pY3Jvc29mdCBmb3Jnb3QgdG8gaHVtcCB0aGVpciB2ZW5kb3IgcHJlZml4ICgjOTU3Milcblx0Y2FtZWxDYXNlOiBmdW5jdGlvbiggc3RyaW5nICkge1xuXHRcdHJldHVybiBzdHJpbmcucmVwbGFjZSggcm1zUHJlZml4LCBcIm1zLVwiICkucmVwbGFjZSggcmRhc2hBbHBoYSwgZmNhbWVsQ2FzZSApO1xuXHR9LFxuXG5cdG5vZGVOYW1lOiBmdW5jdGlvbiggZWxlbSwgbmFtZSApIHtcblx0XHRyZXR1cm4gZWxlbS5ub2RlTmFtZSAmJiBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09IG5hbWUudG9Mb3dlckNhc2UoKTtcblx0fSxcblxuXHRlYWNoOiBmdW5jdGlvbiggb2JqLCBjYWxsYmFjayApIHtcblx0XHR2YXIgbGVuZ3RoLCBpID0gMDtcblxuXHRcdGlmICggaXNBcnJheUxpa2UoIG9iaiApICkge1xuXHRcdFx0bGVuZ3RoID0gb2JqLmxlbmd0aDtcblx0XHRcdGZvciAoIDsgaSA8IGxlbmd0aDsgaSsrICkge1xuXHRcdFx0XHRpZiAoIGNhbGxiYWNrLmNhbGwoIG9ialsgaSBdLCBpLCBvYmpbIGkgXSApID09PSBmYWxzZSApIHtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRmb3IgKCBpIGluIG9iaiApIHtcblx0XHRcdFx0aWYgKCBjYWxsYmFjay5jYWxsKCBvYmpbIGkgXSwgaSwgb2JqWyBpIF0gKSA9PT0gZmFsc2UgKSB7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gb2JqO1xuXHR9LFxuXG5cdC8vIFN1cHBvcnQ6IEFuZHJvaWQ8NC4xLCBJRTw5XG5cdHRyaW06IGZ1bmN0aW9uKCB0ZXh0ICkge1xuXHRcdHJldHVybiB0ZXh0ID09IG51bGwgP1xuXHRcdFx0XCJcIiA6XG5cdFx0XHQoIHRleHQgKyBcIlwiICkucmVwbGFjZSggcnRyaW0sIFwiXCIgKTtcblx0fSxcblxuXHQvLyByZXN1bHRzIGlzIGZvciBpbnRlcm5hbCB1c2FnZSBvbmx5XG5cdG1ha2VBcnJheTogZnVuY3Rpb24oIGFyciwgcmVzdWx0cyApIHtcblx0XHR2YXIgcmV0ID0gcmVzdWx0cyB8fCBbXTtcblxuXHRcdGlmICggYXJyICE9IG51bGwgKSB7XG5cdFx0XHRpZiAoIGlzQXJyYXlMaWtlKCBPYmplY3QoIGFyciApICkgKSB7XG5cdFx0XHRcdGpRdWVyeS5tZXJnZSggcmV0LFxuXHRcdFx0XHRcdHR5cGVvZiBhcnIgPT09IFwic3RyaW5nXCIgP1xuXHRcdFx0XHRcdFsgYXJyIF0gOiBhcnJcblx0XHRcdFx0KTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHB1c2guY2FsbCggcmV0LCBhcnIgKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gcmV0O1xuXHR9LFxuXG5cdGluQXJyYXk6IGZ1bmN0aW9uKCBlbGVtLCBhcnIsIGkgKSB7XG5cdFx0dmFyIGxlbjtcblxuXHRcdGlmICggYXJyICkge1xuXHRcdFx0aWYgKCBpbmRleE9mICkge1xuXHRcdFx0XHRyZXR1cm4gaW5kZXhPZi5jYWxsKCBhcnIsIGVsZW0sIGkgKTtcblx0XHRcdH1cblxuXHRcdFx0bGVuID0gYXJyLmxlbmd0aDtcblx0XHRcdGkgPSBpID8gaSA8IDAgPyBNYXRoLm1heCggMCwgbGVuICsgaSApIDogaSA6IDA7XG5cblx0XHRcdGZvciAoIDsgaSA8IGxlbjsgaSsrICkge1xuXG5cdFx0XHRcdC8vIFNraXAgYWNjZXNzaW5nIGluIHNwYXJzZSBhcnJheXNcblx0XHRcdFx0aWYgKCBpIGluIGFyciAmJiBhcnJbIGkgXSA9PT0gZWxlbSApIHtcblx0XHRcdFx0XHRyZXR1cm4gaTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiAtMTtcblx0fSxcblxuXHRtZXJnZTogZnVuY3Rpb24oIGZpcnN0LCBzZWNvbmQgKSB7XG5cdFx0dmFyIGxlbiA9ICtzZWNvbmQubGVuZ3RoLFxuXHRcdFx0aiA9IDAsXG5cdFx0XHRpID0gZmlyc3QubGVuZ3RoO1xuXG5cdFx0d2hpbGUgKCBqIDwgbGVuICkge1xuXHRcdFx0Zmlyc3RbIGkrKyBdID0gc2Vjb25kWyBqKysgXTtcblx0XHR9XG5cblx0XHQvLyBTdXBwb3J0OiBJRTw5XG5cdFx0Ly8gV29ya2Fyb3VuZCBjYXN0aW5nIG9mIC5sZW5ndGggdG8gTmFOIG9uIG90aGVyd2lzZSBhcnJheWxpa2Ugb2JqZWN0cyAoZS5nLiwgTm9kZUxpc3RzKVxuXHRcdGlmICggbGVuICE9PSBsZW4gKSB7XG5cdFx0XHR3aGlsZSAoIHNlY29uZFsgaiBdICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdGZpcnN0WyBpKysgXSA9IHNlY29uZFsgaisrIF07XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Zmlyc3QubGVuZ3RoID0gaTtcblxuXHRcdHJldHVybiBmaXJzdDtcblx0fSxcblxuXHRncmVwOiBmdW5jdGlvbiggZWxlbXMsIGNhbGxiYWNrLCBpbnZlcnQgKSB7XG5cdFx0dmFyIGNhbGxiYWNrSW52ZXJzZSxcblx0XHRcdG1hdGNoZXMgPSBbXSxcblx0XHRcdGkgPSAwLFxuXHRcdFx0bGVuZ3RoID0gZWxlbXMubGVuZ3RoLFxuXHRcdFx0Y2FsbGJhY2tFeHBlY3QgPSAhaW52ZXJ0O1xuXG5cdFx0Ly8gR28gdGhyb3VnaCB0aGUgYXJyYXksIG9ubHkgc2F2aW5nIHRoZSBpdGVtc1xuXHRcdC8vIHRoYXQgcGFzcyB0aGUgdmFsaWRhdG9yIGZ1bmN0aW9uXG5cdFx0Zm9yICggOyBpIDwgbGVuZ3RoOyBpKysgKSB7XG5cdFx0XHRjYWxsYmFja0ludmVyc2UgPSAhY2FsbGJhY2soIGVsZW1zWyBpIF0sIGkgKTtcblx0XHRcdGlmICggY2FsbGJhY2tJbnZlcnNlICE9PSBjYWxsYmFja0V4cGVjdCApIHtcblx0XHRcdFx0bWF0Y2hlcy5wdXNoKCBlbGVtc1sgaSBdICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIG1hdGNoZXM7XG5cdH0sXG5cblx0Ly8gYXJnIGlzIGZvciBpbnRlcm5hbCB1c2FnZSBvbmx5XG5cdG1hcDogZnVuY3Rpb24oIGVsZW1zLCBjYWxsYmFjaywgYXJnICkge1xuXHRcdHZhciBsZW5ndGgsIHZhbHVlLFxuXHRcdFx0aSA9IDAsXG5cdFx0XHRyZXQgPSBbXTtcblxuXHRcdC8vIEdvIHRocm91Z2ggdGhlIGFycmF5LCB0cmFuc2xhdGluZyBlYWNoIG9mIHRoZSBpdGVtcyB0byB0aGVpciBuZXcgdmFsdWVzXG5cdFx0aWYgKCBpc0FycmF5TGlrZSggZWxlbXMgKSApIHtcblx0XHRcdGxlbmd0aCA9IGVsZW1zLmxlbmd0aDtcblx0XHRcdGZvciAoIDsgaSA8IGxlbmd0aDsgaSsrICkge1xuXHRcdFx0XHR2YWx1ZSA9IGNhbGxiYWNrKCBlbGVtc1sgaSBdLCBpLCBhcmcgKTtcblxuXHRcdFx0XHRpZiAoIHZhbHVlICE9IG51bGwgKSB7XG5cdFx0XHRcdFx0cmV0LnB1c2goIHZhbHVlICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdC8vIEdvIHRocm91Z2ggZXZlcnkga2V5IG9uIHRoZSBvYmplY3QsXG5cdFx0fSBlbHNlIHtcblx0XHRcdGZvciAoIGkgaW4gZWxlbXMgKSB7XG5cdFx0XHRcdHZhbHVlID0gY2FsbGJhY2soIGVsZW1zWyBpIF0sIGksIGFyZyApO1xuXG5cdFx0XHRcdGlmICggdmFsdWUgIT0gbnVsbCApIHtcblx0XHRcdFx0XHRyZXQucHVzaCggdmFsdWUgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIEZsYXR0ZW4gYW55IG5lc3RlZCBhcnJheXNcblx0XHRyZXR1cm4gY29uY2F0LmFwcGx5KCBbXSwgcmV0ICk7XG5cdH0sXG5cblx0Ly8gQSBnbG9iYWwgR1VJRCBjb3VudGVyIGZvciBvYmplY3RzXG5cdGd1aWQ6IDEsXG5cblx0Ly8gQmluZCBhIGZ1bmN0aW9uIHRvIGEgY29udGV4dCwgb3B0aW9uYWxseSBwYXJ0aWFsbHkgYXBwbHlpbmcgYW55XG5cdC8vIGFyZ3VtZW50cy5cblx0cHJveHk6IGZ1bmN0aW9uKCBmbiwgY29udGV4dCApIHtcblx0XHR2YXIgYXJncywgcHJveHksIHRtcDtcblxuXHRcdGlmICggdHlwZW9mIGNvbnRleHQgPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHR0bXAgPSBmblsgY29udGV4dCBdO1xuXHRcdFx0Y29udGV4dCA9IGZuO1xuXHRcdFx0Zm4gPSB0bXA7XG5cdFx0fVxuXG5cdFx0Ly8gUXVpY2sgY2hlY2sgdG8gZGV0ZXJtaW5lIGlmIHRhcmdldCBpcyBjYWxsYWJsZSwgaW4gdGhlIHNwZWNcblx0XHQvLyB0aGlzIHRocm93cyBhIFR5cGVFcnJvciwgYnV0IHdlIHdpbGwganVzdCByZXR1cm4gdW5kZWZpbmVkLlxuXHRcdGlmICggIWpRdWVyeS5pc0Z1bmN0aW9uKCBmbiApICkge1xuXHRcdFx0cmV0dXJuIHVuZGVmaW5lZDtcblx0XHR9XG5cblx0XHQvLyBTaW11bGF0ZWQgYmluZFxuXHRcdGFyZ3MgPSBzbGljZS5jYWxsKCBhcmd1bWVudHMsIDIgKTtcblx0XHRwcm94eSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIGZuLmFwcGx5KCBjb250ZXh0IHx8IHRoaXMsIGFyZ3MuY29uY2F0KCBzbGljZS5jYWxsKCBhcmd1bWVudHMgKSApICk7XG5cdFx0fTtcblxuXHRcdC8vIFNldCB0aGUgZ3VpZCBvZiB1bmlxdWUgaGFuZGxlciB0byB0aGUgc2FtZSBvZiBvcmlnaW5hbCBoYW5kbGVyLCBzbyBpdCBjYW4gYmUgcmVtb3ZlZFxuXHRcdHByb3h5Lmd1aWQgPSBmbi5ndWlkID0gZm4uZ3VpZCB8fCBqUXVlcnkuZ3VpZCsrO1xuXG5cdFx0cmV0dXJuIHByb3h5O1xuXHR9LFxuXG5cdG5vdzogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuICsoIG5ldyBEYXRlKCkgKTtcblx0fSxcblxuXHQvLyBqUXVlcnkuc3VwcG9ydCBpcyBub3QgdXNlZCBpbiBDb3JlIGJ1dCBvdGhlciBwcm9qZWN0cyBhdHRhY2ggdGhlaXJcblx0Ly8gcHJvcGVydGllcyB0byBpdCBzbyBpdCBuZWVkcyB0byBleGlzdC5cblx0c3VwcG9ydDogc3VwcG9ydFxufSApO1xuXG4vLyBKU0hpbnQgd291bGQgZXJyb3Igb24gdGhpcyBjb2RlIGR1ZSB0byB0aGUgU3ltYm9sIG5vdCBiZWluZyBkZWZpbmVkIGluIEVTNS5cbi8vIERlZmluaW5nIHRoaXMgZ2xvYmFsIGluIC5qc2hpbnRyYyB3b3VsZCBjcmVhdGUgYSBkYW5nZXIgb2YgdXNpbmcgdGhlIGdsb2JhbFxuLy8gdW5ndWFyZGVkIGluIGFub3RoZXIgcGxhY2UsIGl0IHNlZW1zIHNhZmVyIHRvIGp1c3QgZGlzYWJsZSBKU0hpbnQgZm9yIHRoZXNlXG4vLyB0aHJlZSBsaW5lcy5cbi8qIGpzaGludCBpZ25vcmU6IHN0YXJ0ICovXG5pZiAoIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiApIHtcblx0alF1ZXJ5LmZuWyBTeW1ib2wuaXRlcmF0b3IgXSA9IGRlbGV0ZWRJZHNbIFN5bWJvbC5pdGVyYXRvciBdO1xufVxuLyoganNoaW50IGlnbm9yZTogZW5kICovXG5cbi8vIFBvcHVsYXRlIHRoZSBjbGFzczJ0eXBlIG1hcFxualF1ZXJ5LmVhY2goIFwiQm9vbGVhbiBOdW1iZXIgU3RyaW5nIEZ1bmN0aW9uIEFycmF5IERhdGUgUmVnRXhwIE9iamVjdCBFcnJvciBTeW1ib2xcIi5zcGxpdCggXCIgXCIgKSxcbmZ1bmN0aW9uKCBpLCBuYW1lICkge1xuXHRjbGFzczJ0eXBlWyBcIltvYmplY3QgXCIgKyBuYW1lICsgXCJdXCIgXSA9IG5hbWUudG9Mb3dlckNhc2UoKTtcbn0gKTtcblxuZnVuY3Rpb24gaXNBcnJheUxpa2UoIG9iaiApIHtcblxuXHQvLyBTdXBwb3J0OiBpT1MgOC4yIChub3QgcmVwcm9kdWNpYmxlIGluIHNpbXVsYXRvcilcblx0Ly8gYGluYCBjaGVjayB1c2VkIHRvIHByZXZlbnQgSklUIGVycm9yIChnaC0yMTQ1KVxuXHQvLyBoYXNPd24gaXNuJ3QgdXNlZCBoZXJlIGR1ZSB0byBmYWxzZSBuZWdhdGl2ZXNcblx0Ly8gcmVnYXJkaW5nIE5vZGVsaXN0IGxlbmd0aCBpbiBJRVxuXHR2YXIgbGVuZ3RoID0gISFvYmogJiYgXCJsZW5ndGhcIiBpbiBvYmogJiYgb2JqLmxlbmd0aCxcblx0XHR0eXBlID0galF1ZXJ5LnR5cGUoIG9iaiApO1xuXG5cdGlmICggdHlwZSA9PT0gXCJmdW5jdGlvblwiIHx8IGpRdWVyeS5pc1dpbmRvdyggb2JqICkgKSB7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG5cblx0cmV0dXJuIHR5cGUgPT09IFwiYXJyYXlcIiB8fCBsZW5ndGggPT09IDAgfHxcblx0XHR0eXBlb2YgbGVuZ3RoID09PSBcIm51bWJlclwiICYmIGxlbmd0aCA+IDAgJiYgKCBsZW5ndGggLSAxICkgaW4gb2JqO1xufVxudmFyIFNpenpsZSA9XG4vKiFcbiAqIFNpenpsZSBDU1MgU2VsZWN0b3IgRW5naW5lIHYyLjIuMVxuICogaHR0cDovL3NpenpsZWpzLmNvbS9cbiAqXG4gKiBDb3B5cmlnaHQgalF1ZXJ5IEZvdW5kYXRpb24gYW5kIG90aGVyIGNvbnRyaWJ1dG9yc1xuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXG4gKiBodHRwOi8vanF1ZXJ5Lm9yZy9saWNlbnNlXG4gKlxuICogRGF0ZTogMjAxNS0xMC0xN1xuICovXG4oZnVuY3Rpb24oIHdpbmRvdyApIHtcblxudmFyIGksXG5cdHN1cHBvcnQsXG5cdEV4cHIsXG5cdGdldFRleHQsXG5cdGlzWE1MLFxuXHR0b2tlbml6ZSxcblx0Y29tcGlsZSxcblx0c2VsZWN0LFxuXHRvdXRlcm1vc3RDb250ZXh0LFxuXHRzb3J0SW5wdXQsXG5cdGhhc0R1cGxpY2F0ZSxcblxuXHQvLyBMb2NhbCBkb2N1bWVudCB2YXJzXG5cdHNldERvY3VtZW50LFxuXHRkb2N1bWVudCxcblx0ZG9jRWxlbSxcblx0ZG9jdW1lbnRJc0hUTUwsXG5cdHJidWdneVFTQSxcblx0cmJ1Z2d5TWF0Y2hlcyxcblx0bWF0Y2hlcyxcblx0Y29udGFpbnMsXG5cblx0Ly8gSW5zdGFuY2Utc3BlY2lmaWMgZGF0YVxuXHRleHBhbmRvID0gXCJzaXp6bGVcIiArIDEgKiBuZXcgRGF0ZSgpLFxuXHRwcmVmZXJyZWREb2MgPSB3aW5kb3cuZG9jdW1lbnQsXG5cdGRpcnJ1bnMgPSAwLFxuXHRkb25lID0gMCxcblx0Y2xhc3NDYWNoZSA9IGNyZWF0ZUNhY2hlKCksXG5cdHRva2VuQ2FjaGUgPSBjcmVhdGVDYWNoZSgpLFxuXHRjb21waWxlckNhY2hlID0gY3JlYXRlQ2FjaGUoKSxcblx0c29ydE9yZGVyID0gZnVuY3Rpb24oIGEsIGIgKSB7XG5cdFx0aWYgKCBhID09PSBiICkge1xuXHRcdFx0aGFzRHVwbGljYXRlID0gdHJ1ZTtcblx0XHR9XG5cdFx0cmV0dXJuIDA7XG5cdH0sXG5cblx0Ly8gR2VuZXJhbC1wdXJwb3NlIGNvbnN0YW50c1xuXHRNQVhfTkVHQVRJVkUgPSAxIDw8IDMxLFxuXG5cdC8vIEluc3RhbmNlIG1ldGhvZHNcblx0aGFzT3duID0gKHt9KS5oYXNPd25Qcm9wZXJ0eSxcblx0YXJyID0gW10sXG5cdHBvcCA9IGFyci5wb3AsXG5cdHB1c2hfbmF0aXZlID0gYXJyLnB1c2gsXG5cdHB1c2ggPSBhcnIucHVzaCxcblx0c2xpY2UgPSBhcnIuc2xpY2UsXG5cdC8vIFVzZSBhIHN0cmlwcGVkLWRvd24gaW5kZXhPZiBhcyBpdCdzIGZhc3RlciB0aGFuIG5hdGl2ZVxuXHQvLyBodHRwOi8vanNwZXJmLmNvbS90aG9yLWluZGV4b2YtdnMtZm9yLzVcblx0aW5kZXhPZiA9IGZ1bmN0aW9uKCBsaXN0LCBlbGVtICkge1xuXHRcdHZhciBpID0gMCxcblx0XHRcdGxlbiA9IGxpc3QubGVuZ3RoO1xuXHRcdGZvciAoIDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdFx0aWYgKCBsaXN0W2ldID09PSBlbGVtICkge1xuXHRcdFx0XHRyZXR1cm4gaTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIC0xO1xuXHR9LFxuXG5cdGJvb2xlYW5zID0gXCJjaGVja2VkfHNlbGVjdGVkfGFzeW5jfGF1dG9mb2N1c3xhdXRvcGxheXxjb250cm9sc3xkZWZlcnxkaXNhYmxlZHxoaWRkZW58aXNtYXB8bG9vcHxtdWx0aXBsZXxvcGVufHJlYWRvbmx5fHJlcXVpcmVkfHNjb3BlZFwiLFxuXG5cdC8vIFJlZ3VsYXIgZXhwcmVzc2lvbnNcblxuXHQvLyBodHRwOi8vd3d3LnczLm9yZy9UUi9jc3MzLXNlbGVjdG9ycy8jd2hpdGVzcGFjZVxuXHR3aGl0ZXNwYWNlID0gXCJbXFxcXHgyMFxcXFx0XFxcXHJcXFxcblxcXFxmXVwiLFxuXG5cdC8vIGh0dHA6Ly93d3cudzMub3JnL1RSL0NTUzIxL3N5bmRhdGEuaHRtbCN2YWx1ZS1kZWYtaWRlbnRpZmllclxuXHRpZGVudGlmaWVyID0gXCIoPzpcXFxcXFxcXC58W1xcXFx3LV18W15cXFxceDAwLVxcXFx4YTBdKStcIixcblxuXHQvLyBBdHRyaWJ1dGUgc2VsZWN0b3JzOiBodHRwOi8vd3d3LnczLm9yZy9UUi9zZWxlY3RvcnMvI2F0dHJpYnV0ZS1zZWxlY3RvcnNcblx0YXR0cmlidXRlcyA9IFwiXFxcXFtcIiArIHdoaXRlc3BhY2UgKyBcIiooXCIgKyBpZGVudGlmaWVyICsgXCIpKD86XCIgKyB3aGl0ZXNwYWNlICtcblx0XHQvLyBPcGVyYXRvciAoY2FwdHVyZSAyKVxuXHRcdFwiKihbKl4kfCF+XT89KVwiICsgd2hpdGVzcGFjZSArXG5cdFx0Ly8gXCJBdHRyaWJ1dGUgdmFsdWVzIG11c3QgYmUgQ1NTIGlkZW50aWZpZXJzIFtjYXB0dXJlIDVdIG9yIHN0cmluZ3MgW2NhcHR1cmUgMyBvciBjYXB0dXJlIDRdXCJcblx0XHRcIiooPzonKCg/OlxcXFxcXFxcLnxbXlxcXFxcXFxcJ10pKiknfFxcXCIoKD86XFxcXFxcXFwufFteXFxcXFxcXFxcXFwiXSkqKVxcXCJ8KFwiICsgaWRlbnRpZmllciArIFwiKSl8KVwiICsgd2hpdGVzcGFjZSArXG5cdFx0XCIqXFxcXF1cIixcblxuXHRwc2V1ZG9zID0gXCI6KFwiICsgaWRlbnRpZmllciArIFwiKSg/OlxcXFwoKFwiICtcblx0XHQvLyBUbyByZWR1Y2UgdGhlIG51bWJlciBvZiBzZWxlY3RvcnMgbmVlZGluZyB0b2tlbml6ZSBpbiB0aGUgcHJlRmlsdGVyLCBwcmVmZXIgYXJndW1lbnRzOlxuXHRcdC8vIDEuIHF1b3RlZCAoY2FwdHVyZSAzOyBjYXB0dXJlIDQgb3IgY2FwdHVyZSA1KVxuXHRcdFwiKCcoKD86XFxcXFxcXFwufFteXFxcXFxcXFwnXSkqKSd8XFxcIigoPzpcXFxcXFxcXC58W15cXFxcXFxcXFxcXCJdKSopXFxcIil8XCIgK1xuXHRcdC8vIDIuIHNpbXBsZSAoY2FwdHVyZSA2KVxuXHRcdFwiKCg/OlxcXFxcXFxcLnxbXlxcXFxcXFxcKClbXFxcXF1dfFwiICsgYXR0cmlidXRlcyArIFwiKSopfFwiICtcblx0XHQvLyAzLiBhbnl0aGluZyBlbHNlIChjYXB0dXJlIDIpXG5cdFx0XCIuKlwiICtcblx0XHRcIilcXFxcKXwpXCIsXG5cblx0Ly8gTGVhZGluZyBhbmQgbm9uLWVzY2FwZWQgdHJhaWxpbmcgd2hpdGVzcGFjZSwgY2FwdHVyaW5nIHNvbWUgbm9uLXdoaXRlc3BhY2UgY2hhcmFjdGVycyBwcmVjZWRpbmcgdGhlIGxhdHRlclxuXHRyd2hpdGVzcGFjZSA9IG5ldyBSZWdFeHAoIHdoaXRlc3BhY2UgKyBcIitcIiwgXCJnXCIgKSxcblx0cnRyaW0gPSBuZXcgUmVnRXhwKCBcIl5cIiArIHdoaXRlc3BhY2UgKyBcIit8KCg/Ol58W15cXFxcXFxcXF0pKD86XFxcXFxcXFwuKSopXCIgKyB3aGl0ZXNwYWNlICsgXCIrJFwiLCBcImdcIiApLFxuXG5cdHJjb21tYSA9IG5ldyBSZWdFeHAoIFwiXlwiICsgd2hpdGVzcGFjZSArIFwiKixcIiArIHdoaXRlc3BhY2UgKyBcIipcIiApLFxuXHRyY29tYmluYXRvcnMgPSBuZXcgUmVnRXhwKCBcIl5cIiArIHdoaXRlc3BhY2UgKyBcIiooWz4rfl18XCIgKyB3aGl0ZXNwYWNlICsgXCIpXCIgKyB3aGl0ZXNwYWNlICsgXCIqXCIgKSxcblxuXHRyYXR0cmlidXRlUXVvdGVzID0gbmV3IFJlZ0V4cCggXCI9XCIgKyB3aGl0ZXNwYWNlICsgXCIqKFteXFxcXF0nXFxcIl0qPylcIiArIHdoaXRlc3BhY2UgKyBcIipcXFxcXVwiLCBcImdcIiApLFxuXG5cdHJwc2V1ZG8gPSBuZXcgUmVnRXhwKCBwc2V1ZG9zICksXG5cdHJpZGVudGlmaWVyID0gbmV3IFJlZ0V4cCggXCJeXCIgKyBpZGVudGlmaWVyICsgXCIkXCIgKSxcblxuXHRtYXRjaEV4cHIgPSB7XG5cdFx0XCJJRFwiOiBuZXcgUmVnRXhwKCBcIl4jKFwiICsgaWRlbnRpZmllciArIFwiKVwiICksXG5cdFx0XCJDTEFTU1wiOiBuZXcgUmVnRXhwKCBcIl5cXFxcLihcIiArIGlkZW50aWZpZXIgKyBcIilcIiApLFxuXHRcdFwiVEFHXCI6IG5ldyBSZWdFeHAoIFwiXihcIiArIGlkZW50aWZpZXIgKyBcInxbKl0pXCIgKSxcblx0XHRcIkFUVFJcIjogbmV3IFJlZ0V4cCggXCJeXCIgKyBhdHRyaWJ1dGVzICksXG5cdFx0XCJQU0VVRE9cIjogbmV3IFJlZ0V4cCggXCJeXCIgKyBwc2V1ZG9zICksXG5cdFx0XCJDSElMRFwiOiBuZXcgUmVnRXhwKCBcIl46KG9ubHl8Zmlyc3R8bGFzdHxudGh8bnRoLWxhc3QpLShjaGlsZHxvZi10eXBlKSg/OlxcXFwoXCIgKyB3aGl0ZXNwYWNlICtcblx0XHRcdFwiKihldmVufG9kZHwoKFsrLV18KShcXFxcZCopbnwpXCIgKyB3aGl0ZXNwYWNlICsgXCIqKD86KFsrLV18KVwiICsgd2hpdGVzcGFjZSArXG5cdFx0XHRcIiooXFxcXGQrKXwpKVwiICsgd2hpdGVzcGFjZSArIFwiKlxcXFwpfClcIiwgXCJpXCIgKSxcblx0XHRcImJvb2xcIjogbmV3IFJlZ0V4cCggXCJeKD86XCIgKyBib29sZWFucyArIFwiKSRcIiwgXCJpXCIgKSxcblx0XHQvLyBGb3IgdXNlIGluIGxpYnJhcmllcyBpbXBsZW1lbnRpbmcgLmlzKClcblx0XHQvLyBXZSB1c2UgdGhpcyBmb3IgUE9TIG1hdGNoaW5nIGluIGBzZWxlY3RgXG5cdFx0XCJuZWVkc0NvbnRleHRcIjogbmV3IFJlZ0V4cCggXCJeXCIgKyB3aGl0ZXNwYWNlICsgXCIqWz4rfl18OihldmVufG9kZHxlcXxndHxsdHxudGh8Zmlyc3R8bGFzdCkoPzpcXFxcKFwiICtcblx0XHRcdHdoaXRlc3BhY2UgKyBcIiooKD86LVxcXFxkKT9cXFxcZCopXCIgKyB3aGl0ZXNwYWNlICsgXCIqXFxcXCl8KSg/PVteLV18JClcIiwgXCJpXCIgKVxuXHR9LFxuXG5cdHJpbnB1dHMgPSAvXig/OmlucHV0fHNlbGVjdHx0ZXh0YXJlYXxidXR0b24pJC9pLFxuXHRyaGVhZGVyID0gL15oXFxkJC9pLFxuXG5cdHJuYXRpdmUgPSAvXltee10rXFx7XFxzKlxcW25hdGl2ZSBcXHcvLFxuXG5cdC8vIEVhc2lseS1wYXJzZWFibGUvcmV0cmlldmFibGUgSUQgb3IgVEFHIG9yIENMQVNTIHNlbGVjdG9yc1xuXHRycXVpY2tFeHByID0gL14oPzojKFtcXHctXSspfChcXHcrKXxcXC4oW1xcdy1dKykpJC8sXG5cblx0cnNpYmxpbmcgPSAvWyt+XS8sXG5cdHJlc2NhcGUgPSAvJ3xcXFxcL2csXG5cblx0Ly8gQ1NTIGVzY2FwZXMgaHR0cDovL3d3dy53My5vcmcvVFIvQ1NTMjEvc3luZGF0YS5odG1sI2VzY2FwZWQtY2hhcmFjdGVyc1xuXHRydW5lc2NhcGUgPSBuZXcgUmVnRXhwKCBcIlxcXFxcXFxcKFtcXFxcZGEtZl17MSw2fVwiICsgd2hpdGVzcGFjZSArIFwiP3woXCIgKyB3aGl0ZXNwYWNlICsgXCIpfC4pXCIsIFwiaWdcIiApLFxuXHRmdW5lc2NhcGUgPSBmdW5jdGlvbiggXywgZXNjYXBlZCwgZXNjYXBlZFdoaXRlc3BhY2UgKSB7XG5cdFx0dmFyIGhpZ2ggPSBcIjB4XCIgKyBlc2NhcGVkIC0gMHgxMDAwMDtcblx0XHQvLyBOYU4gbWVhbnMgbm9uLWNvZGVwb2ludFxuXHRcdC8vIFN1cHBvcnQ6IEZpcmVmb3g8MjRcblx0XHQvLyBXb3JrYXJvdW5kIGVycm9uZW91cyBudW1lcmljIGludGVycHJldGF0aW9uIG9mICtcIjB4XCJcblx0XHRyZXR1cm4gaGlnaCAhPT0gaGlnaCB8fCBlc2NhcGVkV2hpdGVzcGFjZSA/XG5cdFx0XHRlc2NhcGVkIDpcblx0XHRcdGhpZ2ggPCAwID9cblx0XHRcdFx0Ly8gQk1QIGNvZGVwb2ludFxuXHRcdFx0XHRTdHJpbmcuZnJvbUNoYXJDb2RlKCBoaWdoICsgMHgxMDAwMCApIDpcblx0XHRcdFx0Ly8gU3VwcGxlbWVudGFsIFBsYW5lIGNvZGVwb2ludCAoc3Vycm9nYXRlIHBhaXIpXG5cdFx0XHRcdFN0cmluZy5mcm9tQ2hhckNvZGUoIGhpZ2ggPj4gMTAgfCAweEQ4MDAsIGhpZ2ggJiAweDNGRiB8IDB4REMwMCApO1xuXHR9LFxuXG5cdC8vIFVzZWQgZm9yIGlmcmFtZXNcblx0Ly8gU2VlIHNldERvY3VtZW50KClcblx0Ly8gUmVtb3ZpbmcgdGhlIGZ1bmN0aW9uIHdyYXBwZXIgY2F1c2VzIGEgXCJQZXJtaXNzaW9uIERlbmllZFwiXG5cdC8vIGVycm9yIGluIElFXG5cdHVubG9hZEhhbmRsZXIgPSBmdW5jdGlvbigpIHtcblx0XHRzZXREb2N1bWVudCgpO1xuXHR9O1xuXG4vLyBPcHRpbWl6ZSBmb3IgcHVzaC5hcHBseSggXywgTm9kZUxpc3QgKVxudHJ5IHtcblx0cHVzaC5hcHBseShcblx0XHQoYXJyID0gc2xpY2UuY2FsbCggcHJlZmVycmVkRG9jLmNoaWxkTm9kZXMgKSksXG5cdFx0cHJlZmVycmVkRG9jLmNoaWxkTm9kZXNcblx0KTtcblx0Ly8gU3VwcG9ydDogQW5kcm9pZDw0LjBcblx0Ly8gRGV0ZWN0IHNpbGVudGx5IGZhaWxpbmcgcHVzaC5hcHBseVxuXHRhcnJbIHByZWZlcnJlZERvYy5jaGlsZE5vZGVzLmxlbmd0aCBdLm5vZGVUeXBlO1xufSBjYXRjaCAoIGUgKSB7XG5cdHB1c2ggPSB7IGFwcGx5OiBhcnIubGVuZ3RoID9cblxuXHRcdC8vIExldmVyYWdlIHNsaWNlIGlmIHBvc3NpYmxlXG5cdFx0ZnVuY3Rpb24oIHRhcmdldCwgZWxzICkge1xuXHRcdFx0cHVzaF9uYXRpdmUuYXBwbHkoIHRhcmdldCwgc2xpY2UuY2FsbChlbHMpICk7XG5cdFx0fSA6XG5cblx0XHQvLyBTdXBwb3J0OiBJRTw5XG5cdFx0Ly8gT3RoZXJ3aXNlIGFwcGVuZCBkaXJlY3RseVxuXHRcdGZ1bmN0aW9uKCB0YXJnZXQsIGVscyApIHtcblx0XHRcdHZhciBqID0gdGFyZ2V0Lmxlbmd0aCxcblx0XHRcdFx0aSA9IDA7XG5cdFx0XHQvLyBDYW4ndCB0cnVzdCBOb2RlTGlzdC5sZW5ndGhcblx0XHRcdHdoaWxlICggKHRhcmdldFtqKytdID0gZWxzW2krK10pICkge31cblx0XHRcdHRhcmdldC5sZW5ndGggPSBqIC0gMTtcblx0XHR9XG5cdH07XG59XG5cbmZ1bmN0aW9uIFNpenpsZSggc2VsZWN0b3IsIGNvbnRleHQsIHJlc3VsdHMsIHNlZWQgKSB7XG5cdHZhciBtLCBpLCBlbGVtLCBuaWQsIG5pZHNlbGVjdCwgbWF0Y2gsIGdyb3VwcywgbmV3U2VsZWN0b3IsXG5cdFx0bmV3Q29udGV4dCA9IGNvbnRleHQgJiYgY29udGV4dC5vd25lckRvY3VtZW50LFxuXG5cdFx0Ly8gbm9kZVR5cGUgZGVmYXVsdHMgdG8gOSwgc2luY2UgY29udGV4dCBkZWZhdWx0cyB0byBkb2N1bWVudFxuXHRcdG5vZGVUeXBlID0gY29udGV4dCA/IGNvbnRleHQubm9kZVR5cGUgOiA5O1xuXG5cdHJlc3VsdHMgPSByZXN1bHRzIHx8IFtdO1xuXG5cdC8vIFJldHVybiBlYXJseSBmcm9tIGNhbGxzIHdpdGggaW52YWxpZCBzZWxlY3RvciBvciBjb250ZXh0XG5cdGlmICggdHlwZW9mIHNlbGVjdG9yICE9PSBcInN0cmluZ1wiIHx8ICFzZWxlY3RvciB8fFxuXHRcdG5vZGVUeXBlICE9PSAxICYmIG5vZGVUeXBlICE9PSA5ICYmIG5vZGVUeXBlICE9PSAxMSApIHtcblxuXHRcdHJldHVybiByZXN1bHRzO1xuXHR9XG5cblx0Ly8gVHJ5IHRvIHNob3J0Y3V0IGZpbmQgb3BlcmF0aW9ucyAoYXMgb3Bwb3NlZCB0byBmaWx0ZXJzKSBpbiBIVE1MIGRvY3VtZW50c1xuXHRpZiAoICFzZWVkICkge1xuXG5cdFx0aWYgKCAoIGNvbnRleHQgPyBjb250ZXh0Lm93bmVyRG9jdW1lbnQgfHwgY29udGV4dCA6IHByZWZlcnJlZERvYyApICE9PSBkb2N1bWVudCApIHtcblx0XHRcdHNldERvY3VtZW50KCBjb250ZXh0ICk7XG5cdFx0fVxuXHRcdGNvbnRleHQgPSBjb250ZXh0IHx8IGRvY3VtZW50O1xuXG5cdFx0aWYgKCBkb2N1bWVudElzSFRNTCApIHtcblxuXHRcdFx0Ly8gSWYgdGhlIHNlbGVjdG9yIGlzIHN1ZmZpY2llbnRseSBzaW1wbGUsIHRyeSB1c2luZyBhIFwiZ2V0KkJ5KlwiIERPTSBtZXRob2Rcblx0XHRcdC8vIChleGNlcHRpbmcgRG9jdW1lbnRGcmFnbWVudCBjb250ZXh0LCB3aGVyZSB0aGUgbWV0aG9kcyBkb24ndCBleGlzdClcblx0XHRcdGlmICggbm9kZVR5cGUgIT09IDExICYmIChtYXRjaCA9IHJxdWlja0V4cHIuZXhlYyggc2VsZWN0b3IgKSkgKSB7XG5cblx0XHRcdFx0Ly8gSUQgc2VsZWN0b3Jcblx0XHRcdFx0aWYgKCAobSA9IG1hdGNoWzFdKSApIHtcblxuXHRcdFx0XHRcdC8vIERvY3VtZW50IGNvbnRleHRcblx0XHRcdFx0XHRpZiAoIG5vZGVUeXBlID09PSA5ICkge1xuXHRcdFx0XHRcdFx0aWYgKCAoZWxlbSA9IGNvbnRleHQuZ2V0RWxlbWVudEJ5SWQoIG0gKSkgKSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUsIE9wZXJhLCBXZWJraXRcblx0XHRcdFx0XHRcdFx0Ly8gVE9ETzogaWRlbnRpZnkgdmVyc2lvbnNcblx0XHRcdFx0XHRcdFx0Ly8gZ2V0RWxlbWVudEJ5SWQgY2FuIG1hdGNoIGVsZW1lbnRzIGJ5IG5hbWUgaW5zdGVhZCBvZiBJRFxuXHRcdFx0XHRcdFx0XHRpZiAoIGVsZW0uaWQgPT09IG0gKSB7XG5cdFx0XHRcdFx0XHRcdFx0cmVzdWx0cy5wdXNoKCBlbGVtICk7XG5cdFx0XHRcdFx0XHRcdFx0cmV0dXJuIHJlc3VsdHM7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiByZXN1bHRzO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gRWxlbWVudCBjb250ZXh0XG5cdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUsIE9wZXJhLCBXZWJraXRcblx0XHRcdFx0XHRcdC8vIFRPRE86IGlkZW50aWZ5IHZlcnNpb25zXG5cdFx0XHRcdFx0XHQvLyBnZXRFbGVtZW50QnlJZCBjYW4gbWF0Y2ggZWxlbWVudHMgYnkgbmFtZSBpbnN0ZWFkIG9mIElEXG5cdFx0XHRcdFx0XHRpZiAoIG5ld0NvbnRleHQgJiYgKGVsZW0gPSBuZXdDb250ZXh0LmdldEVsZW1lbnRCeUlkKCBtICkpICYmXG5cdFx0XHRcdFx0XHRcdGNvbnRhaW5zKCBjb250ZXh0LCBlbGVtICkgJiZcblx0XHRcdFx0XHRcdFx0ZWxlbS5pZCA9PT0gbSApIHtcblxuXHRcdFx0XHRcdFx0XHRyZXN1bHRzLnB1c2goIGVsZW0gKTtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIHJlc3VsdHM7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFR5cGUgc2VsZWN0b3Jcblx0XHRcdFx0fSBlbHNlIGlmICggbWF0Y2hbMl0gKSB7XG5cdFx0XHRcdFx0cHVzaC5hcHBseSggcmVzdWx0cywgY29udGV4dC5nZXRFbGVtZW50c0J5VGFnTmFtZSggc2VsZWN0b3IgKSApO1xuXHRcdFx0XHRcdHJldHVybiByZXN1bHRzO1xuXG5cdFx0XHRcdC8vIENsYXNzIHNlbGVjdG9yXG5cdFx0XHRcdH0gZWxzZSBpZiAoIChtID0gbWF0Y2hbM10pICYmIHN1cHBvcnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSAmJlxuXHRcdFx0XHRcdGNvbnRleHQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSApIHtcblxuXHRcdFx0XHRcdHB1c2guYXBwbHkoIHJlc3VsdHMsIGNvbnRleHQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSggbSApICk7XG5cdFx0XHRcdFx0cmV0dXJuIHJlc3VsdHM7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gVGFrZSBhZHZhbnRhZ2Ugb2YgcXVlcnlTZWxlY3RvckFsbFxuXHRcdFx0aWYgKCBzdXBwb3J0LnFzYSAmJlxuXHRcdFx0XHQhY29tcGlsZXJDYWNoZVsgc2VsZWN0b3IgKyBcIiBcIiBdICYmXG5cdFx0XHRcdCghcmJ1Z2d5UVNBIHx8ICFyYnVnZ3lRU0EudGVzdCggc2VsZWN0b3IgKSkgKSB7XG5cblx0XHRcdFx0aWYgKCBub2RlVHlwZSAhPT0gMSApIHtcblx0XHRcdFx0XHRuZXdDb250ZXh0ID0gY29udGV4dDtcblx0XHRcdFx0XHRuZXdTZWxlY3RvciA9IHNlbGVjdG9yO1xuXG5cdFx0XHRcdC8vIHFTQSBsb29rcyBvdXRzaWRlIEVsZW1lbnQgY29udGV4dCwgd2hpY2ggaXMgbm90IHdoYXQgd2Ugd2FudFxuXHRcdFx0XHQvLyBUaGFua3MgdG8gQW5kcmV3IER1cG9udCBmb3IgdGhpcyB3b3JrYXJvdW5kIHRlY2huaXF1ZVxuXHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA8PThcblx0XHRcdFx0Ly8gRXhjbHVkZSBvYmplY3QgZWxlbWVudHNcblx0XHRcdFx0fSBlbHNlIGlmICggY29udGV4dC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpICE9PSBcIm9iamVjdFwiICkge1xuXG5cdFx0XHRcdFx0Ly8gQ2FwdHVyZSB0aGUgY29udGV4dCBJRCwgc2V0dGluZyBpdCBmaXJzdCBpZiBuZWNlc3Nhcnlcblx0XHRcdFx0XHRpZiAoIChuaWQgPSBjb250ZXh0LmdldEF0dHJpYnV0ZSggXCJpZFwiICkpICkge1xuXHRcdFx0XHRcdFx0bmlkID0gbmlkLnJlcGxhY2UoIHJlc2NhcGUsIFwiXFxcXCQmXCIgKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0Y29udGV4dC5zZXRBdHRyaWJ1dGUoIFwiaWRcIiwgKG5pZCA9IGV4cGFuZG8pICk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gUHJlZml4IGV2ZXJ5IHNlbGVjdG9yIGluIHRoZSBsaXN0XG5cdFx0XHRcdFx0Z3JvdXBzID0gdG9rZW5pemUoIHNlbGVjdG9yICk7XG5cdFx0XHRcdFx0aSA9IGdyb3Vwcy5sZW5ndGg7XG5cdFx0XHRcdFx0bmlkc2VsZWN0ID0gcmlkZW50aWZpZXIudGVzdCggbmlkICkgPyBcIiNcIiArIG5pZCA6IFwiW2lkPSdcIiArIG5pZCArIFwiJ11cIjtcblx0XHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHRcdGdyb3Vwc1tpXSA9IG5pZHNlbGVjdCArIFwiIFwiICsgdG9TZWxlY3RvciggZ3JvdXBzW2ldICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdG5ld1NlbGVjdG9yID0gZ3JvdXBzLmpvaW4oIFwiLFwiICk7XG5cblx0XHRcdFx0XHQvLyBFeHBhbmQgY29udGV4dCBmb3Igc2libGluZyBzZWxlY3RvcnNcblx0XHRcdFx0XHRuZXdDb250ZXh0ID0gcnNpYmxpbmcudGVzdCggc2VsZWN0b3IgKSAmJiB0ZXN0Q29udGV4dCggY29udGV4dC5wYXJlbnROb2RlICkgfHxcblx0XHRcdFx0XHRcdGNvbnRleHQ7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoIG5ld1NlbGVjdG9yICkge1xuXHRcdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0XHRwdXNoLmFwcGx5KCByZXN1bHRzLFxuXHRcdFx0XHRcdFx0XHRuZXdDb250ZXh0LnF1ZXJ5U2VsZWN0b3JBbGwoIG5ld1NlbGVjdG9yIClcblx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0XHRyZXR1cm4gcmVzdWx0cztcblx0XHRcdFx0XHR9IGNhdGNoICggcXNhRXJyb3IgKSB7XG5cdFx0XHRcdFx0fSBmaW5hbGx5IHtcblx0XHRcdFx0XHRcdGlmICggbmlkID09PSBleHBhbmRvICkge1xuXHRcdFx0XHRcdFx0XHRjb250ZXh0LnJlbW92ZUF0dHJpYnV0ZSggXCJpZFwiICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0Ly8gQWxsIG90aGVyc1xuXHRyZXR1cm4gc2VsZWN0KCBzZWxlY3Rvci5yZXBsYWNlKCBydHJpbSwgXCIkMVwiICksIGNvbnRleHQsIHJlc3VsdHMsIHNlZWQgKTtcbn1cblxuLyoqXG4gKiBDcmVhdGUga2V5LXZhbHVlIGNhY2hlcyBvZiBsaW1pdGVkIHNpemVcbiAqIEByZXR1cm5zIHtmdW5jdGlvbihzdHJpbmcsIG9iamVjdCl9IFJldHVybnMgdGhlIE9iamVjdCBkYXRhIGFmdGVyIHN0b3JpbmcgaXQgb24gaXRzZWxmIHdpdGhcbiAqXHRwcm9wZXJ0eSBuYW1lIHRoZSAoc3BhY2Utc3VmZml4ZWQpIHN0cmluZyBhbmQgKGlmIHRoZSBjYWNoZSBpcyBsYXJnZXIgdGhhbiBFeHByLmNhY2hlTGVuZ3RoKVxuICpcdGRlbGV0aW5nIHRoZSBvbGRlc3QgZW50cnlcbiAqL1xuZnVuY3Rpb24gY3JlYXRlQ2FjaGUoKSB7XG5cdHZhciBrZXlzID0gW107XG5cblx0ZnVuY3Rpb24gY2FjaGUoIGtleSwgdmFsdWUgKSB7XG5cdFx0Ly8gVXNlIChrZXkgKyBcIiBcIikgdG8gYXZvaWQgY29sbGlzaW9uIHdpdGggbmF0aXZlIHByb3RvdHlwZSBwcm9wZXJ0aWVzIChzZWUgSXNzdWUgIzE1Nylcblx0XHRpZiAoIGtleXMucHVzaCgga2V5ICsgXCIgXCIgKSA+IEV4cHIuY2FjaGVMZW5ndGggKSB7XG5cdFx0XHQvLyBPbmx5IGtlZXAgdGhlIG1vc3QgcmVjZW50IGVudHJpZXNcblx0XHRcdGRlbGV0ZSBjYWNoZVsga2V5cy5zaGlmdCgpIF07XG5cdFx0fVxuXHRcdHJldHVybiAoY2FjaGVbIGtleSArIFwiIFwiIF0gPSB2YWx1ZSk7XG5cdH1cblx0cmV0dXJuIGNhY2hlO1xufVxuXG4vKipcbiAqIE1hcmsgYSBmdW5jdGlvbiBmb3Igc3BlY2lhbCB1c2UgYnkgU2l6emxlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgZnVuY3Rpb24gdG8gbWFya1xuICovXG5mdW5jdGlvbiBtYXJrRnVuY3Rpb24oIGZuICkge1xuXHRmblsgZXhwYW5kbyBdID0gdHJ1ZTtcblx0cmV0dXJuIGZuO1xufVxuXG4vKipcbiAqIFN1cHBvcnQgdGVzdGluZyB1c2luZyBhbiBlbGVtZW50XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBQYXNzZWQgdGhlIGNyZWF0ZWQgZGl2IGFuZCBleHBlY3RzIGEgYm9vbGVhbiByZXN1bHRcbiAqL1xuZnVuY3Rpb24gYXNzZXJ0KCBmbiApIHtcblx0dmFyIGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG5cblx0dHJ5IHtcblx0XHRyZXR1cm4gISFmbiggZGl2ICk7XG5cdH0gY2F0Y2ggKGUpIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH0gZmluYWxseSB7XG5cdFx0Ly8gUmVtb3ZlIGZyb20gaXRzIHBhcmVudCBieSBkZWZhdWx0XG5cdFx0aWYgKCBkaXYucGFyZW50Tm9kZSApIHtcblx0XHRcdGRpdi5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKCBkaXYgKTtcblx0XHR9XG5cdFx0Ly8gcmVsZWFzZSBtZW1vcnkgaW4gSUVcblx0XHRkaXYgPSBudWxsO1xuXHR9XG59XG5cbi8qKlxuICogQWRkcyB0aGUgc2FtZSBoYW5kbGVyIGZvciBhbGwgb2YgdGhlIHNwZWNpZmllZCBhdHRyc1xuICogQHBhcmFtIHtTdHJpbmd9IGF0dHJzIFBpcGUtc2VwYXJhdGVkIGxpc3Qgb2YgYXR0cmlidXRlc1xuICogQHBhcmFtIHtGdW5jdGlvbn0gaGFuZGxlciBUaGUgbWV0aG9kIHRoYXQgd2lsbCBiZSBhcHBsaWVkXG4gKi9cbmZ1bmN0aW9uIGFkZEhhbmRsZSggYXR0cnMsIGhhbmRsZXIgKSB7XG5cdHZhciBhcnIgPSBhdHRycy5zcGxpdChcInxcIiksXG5cdFx0aSA9IGFyci5sZW5ndGg7XG5cblx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0RXhwci5hdHRySGFuZGxlWyBhcnJbaV0gXSA9IGhhbmRsZXI7XG5cdH1cbn1cblxuLyoqXG4gKiBDaGVja3MgZG9jdW1lbnQgb3JkZXIgb2YgdHdvIHNpYmxpbmdzXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGFcbiAqIEBwYXJhbSB7RWxlbWVudH0gYlxuICogQHJldHVybnMge051bWJlcn0gUmV0dXJucyBsZXNzIHRoYW4gMCBpZiBhIHByZWNlZGVzIGIsIGdyZWF0ZXIgdGhhbiAwIGlmIGEgZm9sbG93cyBiXG4gKi9cbmZ1bmN0aW9uIHNpYmxpbmdDaGVjayggYSwgYiApIHtcblx0dmFyIGN1ciA9IGIgJiYgYSxcblx0XHRkaWZmID0gY3VyICYmIGEubm9kZVR5cGUgPT09IDEgJiYgYi5ub2RlVHlwZSA9PT0gMSAmJlxuXHRcdFx0KCB+Yi5zb3VyY2VJbmRleCB8fCBNQVhfTkVHQVRJVkUgKSAtXG5cdFx0XHQoIH5hLnNvdXJjZUluZGV4IHx8IE1BWF9ORUdBVElWRSApO1xuXG5cdC8vIFVzZSBJRSBzb3VyY2VJbmRleCBpZiBhdmFpbGFibGUgb24gYm90aCBub2Rlc1xuXHRpZiAoIGRpZmYgKSB7XG5cdFx0cmV0dXJuIGRpZmY7XG5cdH1cblxuXHQvLyBDaGVjayBpZiBiIGZvbGxvd3MgYVxuXHRpZiAoIGN1ciApIHtcblx0XHR3aGlsZSAoIChjdXIgPSBjdXIubmV4dFNpYmxpbmcpICkge1xuXHRcdFx0aWYgKCBjdXIgPT09IGIgKSB7XG5cdFx0XHRcdHJldHVybiAtMTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gYSA/IDEgOiAtMTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgZnVuY3Rpb24gdG8gdXNlIGluIHBzZXVkb3MgZm9yIGlucHV0IHR5cGVzXG4gKiBAcGFyYW0ge1N0cmluZ30gdHlwZVxuICovXG5mdW5jdGlvbiBjcmVhdGVJbnB1dFBzZXVkbyggdHlwZSApIHtcblx0cmV0dXJuIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHZhciBuYW1lID0gZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuXHRcdHJldHVybiBuYW1lID09PSBcImlucHV0XCIgJiYgZWxlbS50eXBlID09PSB0eXBlO1xuXHR9O1xufVxuXG4vKipcbiAqIFJldHVybnMgYSBmdW5jdGlvbiB0byB1c2UgaW4gcHNldWRvcyBmb3IgYnV0dG9uc1xuICogQHBhcmFtIHtTdHJpbmd9IHR5cGVcbiAqL1xuZnVuY3Rpb24gY3JlYXRlQnV0dG9uUHNldWRvKCB0eXBlICkge1xuXHRyZXR1cm4gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0dmFyIG5hbWUgPSBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG5cdFx0cmV0dXJuIChuYW1lID09PSBcImlucHV0XCIgfHwgbmFtZSA9PT0gXCJidXR0b25cIikgJiYgZWxlbS50eXBlID09PSB0eXBlO1xuXHR9O1xufVxuXG4vKipcbiAqIFJldHVybnMgYSBmdW5jdGlvbiB0byB1c2UgaW4gcHNldWRvcyBmb3IgcG9zaXRpb25hbHNcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVBvc2l0aW9uYWxQc2V1ZG8oIGZuICkge1xuXHRyZXR1cm4gbWFya0Z1bmN0aW9uKGZ1bmN0aW9uKCBhcmd1bWVudCApIHtcblx0XHRhcmd1bWVudCA9ICthcmd1bWVudDtcblx0XHRyZXR1cm4gbWFya0Z1bmN0aW9uKGZ1bmN0aW9uKCBzZWVkLCBtYXRjaGVzICkge1xuXHRcdFx0dmFyIGosXG5cdFx0XHRcdG1hdGNoSW5kZXhlcyA9IGZuKCBbXSwgc2VlZC5sZW5ndGgsIGFyZ3VtZW50ICksXG5cdFx0XHRcdGkgPSBtYXRjaEluZGV4ZXMubGVuZ3RoO1xuXG5cdFx0XHQvLyBNYXRjaCBlbGVtZW50cyBmb3VuZCBhdCB0aGUgc3BlY2lmaWVkIGluZGV4ZXNcblx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRpZiAoIHNlZWRbIChqID0gbWF0Y2hJbmRleGVzW2ldKSBdICkge1xuXHRcdFx0XHRcdHNlZWRbal0gPSAhKG1hdGNoZXNbal0gPSBzZWVkW2pdKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0pO1xuXHR9KTtcbn1cblxuLyoqXG4gKiBDaGVja3MgYSBub2RlIGZvciB2YWxpZGl0eSBhcyBhIFNpenpsZSBjb250ZXh0XG4gKiBAcGFyYW0ge0VsZW1lbnR8T2JqZWN0PX0gY29udGV4dFxuICogQHJldHVybnMge0VsZW1lbnR8T2JqZWN0fEJvb2xlYW59IFRoZSBpbnB1dCBub2RlIGlmIGFjY2VwdGFibGUsIG90aGVyd2lzZSBhIGZhbHN5IHZhbHVlXG4gKi9cbmZ1bmN0aW9uIHRlc3RDb250ZXh0KCBjb250ZXh0ICkge1xuXHRyZXR1cm4gY29udGV4dCAmJiB0eXBlb2YgY29udGV4dC5nZXRFbGVtZW50c0J5VGFnTmFtZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBjb250ZXh0O1xufVxuXG4vLyBFeHBvc2Ugc3VwcG9ydCB2YXJzIGZvciBjb252ZW5pZW5jZVxuc3VwcG9ydCA9IFNpenpsZS5zdXBwb3J0ID0ge307XG5cbi8qKlxuICogRGV0ZWN0cyBYTUwgbm9kZXNcbiAqIEBwYXJhbSB7RWxlbWVudHxPYmplY3R9IGVsZW0gQW4gZWxlbWVudCBvciBhIGRvY3VtZW50XG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gVHJ1ZSBpZmYgZWxlbSBpcyBhIG5vbi1IVE1MIFhNTCBub2RlXG4gKi9cbmlzWE1MID0gU2l6emxlLmlzWE1MID0gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdC8vIGRvY3VtZW50RWxlbWVudCBpcyB2ZXJpZmllZCBmb3IgY2FzZXMgd2hlcmUgaXQgZG9lc24ndCB5ZXQgZXhpc3Rcblx0Ly8gKHN1Y2ggYXMgbG9hZGluZyBpZnJhbWVzIGluIElFIC0gIzQ4MzMpXG5cdHZhciBkb2N1bWVudEVsZW1lbnQgPSBlbGVtICYmIChlbGVtLm93bmVyRG9jdW1lbnQgfHwgZWxlbSkuZG9jdW1lbnRFbGVtZW50O1xuXHRyZXR1cm4gZG9jdW1lbnRFbGVtZW50ID8gZG9jdW1lbnRFbGVtZW50Lm5vZGVOYW1lICE9PSBcIkhUTUxcIiA6IGZhbHNlO1xufTtcblxuLyoqXG4gKiBTZXRzIGRvY3VtZW50LXJlbGF0ZWQgdmFyaWFibGVzIG9uY2UgYmFzZWQgb24gdGhlIGN1cnJlbnQgZG9jdW1lbnRcbiAqIEBwYXJhbSB7RWxlbWVudHxPYmplY3R9IFtkb2NdIEFuIGVsZW1lbnQgb3IgZG9jdW1lbnQgb2JqZWN0IHRvIHVzZSB0byBzZXQgdGhlIGRvY3VtZW50XG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjdXJyZW50IGRvY3VtZW50XG4gKi9cbnNldERvY3VtZW50ID0gU2l6emxlLnNldERvY3VtZW50ID0gZnVuY3Rpb24oIG5vZGUgKSB7XG5cdHZhciBoYXNDb21wYXJlLCBwYXJlbnQsXG5cdFx0ZG9jID0gbm9kZSA/IG5vZGUub3duZXJEb2N1bWVudCB8fCBub2RlIDogcHJlZmVycmVkRG9jO1xuXG5cdC8vIFJldHVybiBlYXJseSBpZiBkb2MgaXMgaW52YWxpZCBvciBhbHJlYWR5IHNlbGVjdGVkXG5cdGlmICggZG9jID09PSBkb2N1bWVudCB8fCBkb2Mubm9kZVR5cGUgIT09IDkgfHwgIWRvYy5kb2N1bWVudEVsZW1lbnQgKSB7XG5cdFx0cmV0dXJuIGRvY3VtZW50O1xuXHR9XG5cblx0Ly8gVXBkYXRlIGdsb2JhbCB2YXJpYWJsZXNcblx0ZG9jdW1lbnQgPSBkb2M7XG5cdGRvY0VsZW0gPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG5cdGRvY3VtZW50SXNIVE1MID0gIWlzWE1MKCBkb2N1bWVudCApO1xuXG5cdC8vIFN1cHBvcnQ6IElFIDktMTEsIEVkZ2Vcblx0Ly8gQWNjZXNzaW5nIGlmcmFtZSBkb2N1bWVudHMgYWZ0ZXIgdW5sb2FkIHRocm93cyBcInBlcm1pc3Npb24gZGVuaWVkXCIgZXJyb3JzIChqUXVlcnkgIzEzOTM2KVxuXHRpZiAoIChwYXJlbnQgPSBkb2N1bWVudC5kZWZhdWx0VmlldykgJiYgcGFyZW50LnRvcCAhPT0gcGFyZW50ICkge1xuXHRcdC8vIFN1cHBvcnQ6IElFIDExXG5cdFx0aWYgKCBwYXJlbnQuYWRkRXZlbnRMaXN0ZW5lciApIHtcblx0XHRcdHBhcmVudC5hZGRFdmVudExpc3RlbmVyKCBcInVubG9hZFwiLCB1bmxvYWRIYW5kbGVyLCBmYWxzZSApO1xuXG5cdFx0Ly8gU3VwcG9ydDogSUUgOSAtIDEwIG9ubHlcblx0XHR9IGVsc2UgaWYgKCBwYXJlbnQuYXR0YWNoRXZlbnQgKSB7XG5cdFx0XHRwYXJlbnQuYXR0YWNoRXZlbnQoIFwib251bmxvYWRcIiwgdW5sb2FkSGFuZGxlciApO1xuXHRcdH1cblx0fVxuXG5cdC8qIEF0dHJpYnV0ZXNcblx0LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuXG5cdC8vIFN1cHBvcnQ6IElFPDhcblx0Ly8gVmVyaWZ5IHRoYXQgZ2V0QXR0cmlidXRlIHJlYWxseSByZXR1cm5zIGF0dHJpYnV0ZXMgYW5kIG5vdCBwcm9wZXJ0aWVzXG5cdC8vIChleGNlcHRpbmcgSUU4IGJvb2xlYW5zKVxuXHRzdXBwb3J0LmF0dHJpYnV0ZXMgPSBhc3NlcnQoZnVuY3Rpb24oIGRpdiApIHtcblx0XHRkaXYuY2xhc3NOYW1lID0gXCJpXCI7XG5cdFx0cmV0dXJuICFkaXYuZ2V0QXR0cmlidXRlKFwiY2xhc3NOYW1lXCIpO1xuXHR9KTtcblxuXHQvKiBnZXRFbGVtZW50KHMpQnkqXG5cdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cblxuXHQvLyBDaGVjayBpZiBnZXRFbGVtZW50c0J5VGFnTmFtZShcIipcIikgcmV0dXJucyBvbmx5IGVsZW1lbnRzXG5cdHN1cHBvcnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUgPSBhc3NlcnQoZnVuY3Rpb24oIGRpdiApIHtcblx0XHRkaXYuYXBwZW5kQ2hpbGQoIGRvY3VtZW50LmNyZWF0ZUNvbW1lbnQoXCJcIikgKTtcblx0XHRyZXR1cm4gIWRpdi5nZXRFbGVtZW50c0J5VGFnTmFtZShcIipcIikubGVuZ3RoO1xuXHR9KTtcblxuXHQvLyBTdXBwb3J0OiBJRTw5XG5cdHN1cHBvcnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSA9IHJuYXRpdmUudGVzdCggZG9jdW1lbnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSApO1xuXG5cdC8vIFN1cHBvcnQ6IElFPDEwXG5cdC8vIENoZWNrIGlmIGdldEVsZW1lbnRCeUlkIHJldHVybnMgZWxlbWVudHMgYnkgbmFtZVxuXHQvLyBUaGUgYnJva2VuIGdldEVsZW1lbnRCeUlkIG1ldGhvZHMgZG9uJ3QgcGljayB1cCBwcm9ncmFtYXRpY2FsbHktc2V0IG5hbWVzLFxuXHQvLyBzbyB1c2UgYSByb3VuZGFib3V0IGdldEVsZW1lbnRzQnlOYW1lIHRlc3Rcblx0c3VwcG9ydC5nZXRCeUlkID0gYXNzZXJ0KGZ1bmN0aW9uKCBkaXYgKSB7XG5cdFx0ZG9jRWxlbS5hcHBlbmRDaGlsZCggZGl2ICkuaWQgPSBleHBhbmRvO1xuXHRcdHJldHVybiAhZG9jdW1lbnQuZ2V0RWxlbWVudHNCeU5hbWUgfHwgIWRvY3VtZW50LmdldEVsZW1lbnRzQnlOYW1lKCBleHBhbmRvICkubGVuZ3RoO1xuXHR9KTtcblxuXHQvLyBJRCBmaW5kIGFuZCBmaWx0ZXJcblx0aWYgKCBzdXBwb3J0LmdldEJ5SWQgKSB7XG5cdFx0RXhwci5maW5kW1wiSURcIl0gPSBmdW5jdGlvbiggaWQsIGNvbnRleHQgKSB7XG5cdFx0XHRpZiAoIHR5cGVvZiBjb250ZXh0LmdldEVsZW1lbnRCeUlkICE9PSBcInVuZGVmaW5lZFwiICYmIGRvY3VtZW50SXNIVE1MICkge1xuXHRcdFx0XHR2YXIgbSA9IGNvbnRleHQuZ2V0RWxlbWVudEJ5SWQoIGlkICk7XG5cdFx0XHRcdHJldHVybiBtID8gWyBtIF0gOiBbXTtcblx0XHRcdH1cblx0XHR9O1xuXHRcdEV4cHIuZmlsdGVyW1wiSURcIl0gPSBmdW5jdGlvbiggaWQgKSB7XG5cdFx0XHR2YXIgYXR0cklkID0gaWQucmVwbGFjZSggcnVuZXNjYXBlLCBmdW5lc2NhcGUgKTtcblx0XHRcdHJldHVybiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0cmV0dXJuIGVsZW0uZ2V0QXR0cmlidXRlKFwiaWRcIikgPT09IGF0dHJJZDtcblx0XHRcdH07XG5cdFx0fTtcblx0fSBlbHNlIHtcblx0XHQvLyBTdXBwb3J0OiBJRTYvN1xuXHRcdC8vIGdldEVsZW1lbnRCeUlkIGlzIG5vdCByZWxpYWJsZSBhcyBhIGZpbmQgc2hvcnRjdXRcblx0XHRkZWxldGUgRXhwci5maW5kW1wiSURcIl07XG5cblx0XHRFeHByLmZpbHRlcltcIklEXCJdID0gIGZ1bmN0aW9uKCBpZCApIHtcblx0XHRcdHZhciBhdHRySWQgPSBpZC5yZXBsYWNlKCBydW5lc2NhcGUsIGZ1bmVzY2FwZSApO1xuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHR2YXIgbm9kZSA9IHR5cGVvZiBlbGVtLmdldEF0dHJpYnV0ZU5vZGUgIT09IFwidW5kZWZpbmVkXCIgJiZcblx0XHRcdFx0XHRlbGVtLmdldEF0dHJpYnV0ZU5vZGUoXCJpZFwiKTtcblx0XHRcdFx0cmV0dXJuIG5vZGUgJiYgbm9kZS52YWx1ZSA9PT0gYXR0cklkO1xuXHRcdFx0fTtcblx0XHR9O1xuXHR9XG5cblx0Ly8gVGFnXG5cdEV4cHIuZmluZFtcIlRBR1wiXSA9IHN1cHBvcnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUgP1xuXHRcdGZ1bmN0aW9uKCB0YWcsIGNvbnRleHQgKSB7XG5cdFx0XHRpZiAoIHR5cGVvZiBjb250ZXh0LmdldEVsZW1lbnRzQnlUYWdOYW1lICE9PSBcInVuZGVmaW5lZFwiICkge1xuXHRcdFx0XHRyZXR1cm4gY29udGV4dC5nZXRFbGVtZW50c0J5VGFnTmFtZSggdGFnICk7XG5cblx0XHRcdC8vIERvY3VtZW50RnJhZ21lbnQgbm9kZXMgZG9uJ3QgaGF2ZSBnRUJUTlxuXHRcdFx0fSBlbHNlIGlmICggc3VwcG9ydC5xc2EgKSB7XG5cdFx0XHRcdHJldHVybiBjb250ZXh0LnF1ZXJ5U2VsZWN0b3JBbGwoIHRhZyApO1xuXHRcdFx0fVxuXHRcdH0gOlxuXG5cdFx0ZnVuY3Rpb24oIHRhZywgY29udGV4dCApIHtcblx0XHRcdHZhciBlbGVtLFxuXHRcdFx0XHR0bXAgPSBbXSxcblx0XHRcdFx0aSA9IDAsXG5cdFx0XHRcdC8vIEJ5IGhhcHB5IGNvaW5jaWRlbmNlLCBhIChicm9rZW4pIGdFQlROIGFwcGVhcnMgb24gRG9jdW1lbnRGcmFnbWVudCBub2RlcyB0b29cblx0XHRcdFx0cmVzdWx0cyA9IGNvbnRleHQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoIHRhZyApO1xuXG5cdFx0XHQvLyBGaWx0ZXIgb3V0IHBvc3NpYmxlIGNvbW1lbnRzXG5cdFx0XHRpZiAoIHRhZyA9PT0gXCIqXCIgKSB7XG5cdFx0XHRcdHdoaWxlICggKGVsZW0gPSByZXN1bHRzW2krK10pICkge1xuXHRcdFx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSApIHtcblx0XHRcdFx0XHRcdHRtcC5wdXNoKCBlbGVtICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIHRtcDtcblx0XHRcdH1cblx0XHRcdHJldHVybiByZXN1bHRzO1xuXHRcdH07XG5cblx0Ly8gQ2xhc3Ncblx0RXhwci5maW5kW1wiQ0xBU1NcIl0gPSBzdXBwb3J0LmdldEVsZW1lbnRzQnlDbGFzc05hbWUgJiYgZnVuY3Rpb24oIGNsYXNzTmFtZSwgY29udGV4dCApIHtcblx0XHRpZiAoIHR5cGVvZiBjb250ZXh0LmdldEVsZW1lbnRzQnlDbGFzc05hbWUgIT09IFwidW5kZWZpbmVkXCIgJiYgZG9jdW1lbnRJc0hUTUwgKSB7XG5cdFx0XHRyZXR1cm4gY29udGV4dC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKCBjbGFzc05hbWUgKTtcblx0XHR9XG5cdH07XG5cblx0LyogUVNBL21hdGNoZXNTZWxlY3RvclxuXHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5cblx0Ly8gUVNBIGFuZCBtYXRjaGVzU2VsZWN0b3Igc3VwcG9ydFxuXG5cdC8vIG1hdGNoZXNTZWxlY3Rvcig6YWN0aXZlKSByZXBvcnRzIGZhbHNlIHdoZW4gdHJ1ZSAoSUU5L09wZXJhIDExLjUpXG5cdHJidWdneU1hdGNoZXMgPSBbXTtcblxuXHQvLyBxU2EoOmZvY3VzKSByZXBvcnRzIGZhbHNlIHdoZW4gdHJ1ZSAoQ2hyb21lIDIxKVxuXHQvLyBXZSBhbGxvdyB0aGlzIGJlY2F1c2Ugb2YgYSBidWcgaW4gSUU4LzkgdGhhdCB0aHJvd3MgYW4gZXJyb3Jcblx0Ly8gd2hlbmV2ZXIgYGRvY3VtZW50LmFjdGl2ZUVsZW1lbnRgIGlzIGFjY2Vzc2VkIG9uIGFuIGlmcmFtZVxuXHQvLyBTbywgd2UgYWxsb3cgOmZvY3VzIHRvIHBhc3MgdGhyb3VnaCBRU0EgYWxsIHRoZSB0aW1lIHRvIGF2b2lkIHRoZSBJRSBlcnJvclxuXHQvLyBTZWUgaHR0cDovL2J1Z3MuanF1ZXJ5LmNvbS90aWNrZXQvMTMzNzhcblx0cmJ1Z2d5UVNBID0gW107XG5cblx0aWYgKCAoc3VwcG9ydC5xc2EgPSBybmF0aXZlLnRlc3QoIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwgKSkgKSB7XG5cdFx0Ly8gQnVpbGQgUVNBIHJlZ2V4XG5cdFx0Ly8gUmVnZXggc3RyYXRlZ3kgYWRvcHRlZCBmcm9tIERpZWdvIFBlcmluaVxuXHRcdGFzc2VydChmdW5jdGlvbiggZGl2ICkge1xuXHRcdFx0Ly8gU2VsZWN0IGlzIHNldCB0byBlbXB0eSBzdHJpbmcgb24gcHVycG9zZVxuXHRcdFx0Ly8gVGhpcyBpcyB0byB0ZXN0IElFJ3MgdHJlYXRtZW50IG9mIG5vdCBleHBsaWNpdGx5XG5cdFx0XHQvLyBzZXR0aW5nIGEgYm9vbGVhbiBjb250ZW50IGF0dHJpYnV0ZSxcblx0XHRcdC8vIHNpbmNlIGl0cyBwcmVzZW5jZSBzaG91bGQgYmUgZW5vdWdoXG5cdFx0XHQvLyBodHRwOi8vYnVncy5qcXVlcnkuY29tL3RpY2tldC8xMjM1OVxuXHRcdFx0ZG9jRWxlbS5hcHBlbmRDaGlsZCggZGl2ICkuaW5uZXJIVE1MID0gXCI8YSBpZD0nXCIgKyBleHBhbmRvICsgXCInPjwvYT5cIiArXG5cdFx0XHRcdFwiPHNlbGVjdCBpZD0nXCIgKyBleHBhbmRvICsgXCItXFxyXFxcXCcgbXNhbGxvd2NhcHR1cmU9Jyc+XCIgK1xuXHRcdFx0XHRcIjxvcHRpb24gc2VsZWN0ZWQ9Jyc+PC9vcHRpb24+PC9zZWxlY3Q+XCI7XG5cblx0XHRcdC8vIFN1cHBvcnQ6IElFOCwgT3BlcmEgMTEtMTIuMTZcblx0XHRcdC8vIE5vdGhpbmcgc2hvdWxkIGJlIHNlbGVjdGVkIHdoZW4gZW1wdHkgc3RyaW5ncyBmb2xsb3cgXj0gb3IgJD0gb3IgKj1cblx0XHRcdC8vIFRoZSB0ZXN0IGF0dHJpYnV0ZSBtdXN0IGJlIHVua25vd24gaW4gT3BlcmEgYnV0IFwic2FmZVwiIGZvciBXaW5SVFxuXHRcdFx0Ly8gaHR0cDovL21zZG4ubWljcm9zb2Z0LmNvbS9lbi11cy9saWJyYXJ5L2llL2hoNDY1Mzg4LmFzcHgjYXR0cmlidXRlX3NlY3Rpb25cblx0XHRcdGlmICggZGl2LnF1ZXJ5U2VsZWN0b3JBbGwoXCJbbXNhbGxvd2NhcHR1cmVePScnXVwiKS5sZW5ndGggKSB7XG5cdFx0XHRcdHJidWdneVFTQS5wdXNoKCBcIlsqXiRdPVwiICsgd2hpdGVzcGFjZSArIFwiKig/OicnfFxcXCJcXFwiKVwiICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFN1cHBvcnQ6IElFOFxuXHRcdFx0Ly8gQm9vbGVhbiBhdHRyaWJ1dGVzIGFuZCBcInZhbHVlXCIgYXJlIG5vdCB0cmVhdGVkIGNvcnJlY3RseVxuXHRcdFx0aWYgKCAhZGl2LnF1ZXJ5U2VsZWN0b3JBbGwoXCJbc2VsZWN0ZWRdXCIpLmxlbmd0aCApIHtcblx0XHRcdFx0cmJ1Z2d5UVNBLnB1c2goIFwiXFxcXFtcIiArIHdoaXRlc3BhY2UgKyBcIiooPzp2YWx1ZXxcIiArIGJvb2xlYW5zICsgXCIpXCIgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU3VwcG9ydDogQ2hyb21lPDI5LCBBbmRyb2lkPDQuNCwgU2FmYXJpPDcuMCssIGlPUzw3LjArLCBQaGFudG9tSlM8MS45LjgrXG5cdFx0XHRpZiAoICFkaXYucXVlcnlTZWxlY3RvckFsbCggXCJbaWR+PVwiICsgZXhwYW5kbyArIFwiLV1cIiApLmxlbmd0aCApIHtcblx0XHRcdFx0cmJ1Z2d5UVNBLnB1c2goXCJ+PVwiKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gV2Via2l0L09wZXJhIC0gOmNoZWNrZWQgc2hvdWxkIHJldHVybiBzZWxlY3RlZCBvcHRpb24gZWxlbWVudHNcblx0XHRcdC8vIGh0dHA6Ly93d3cudzMub3JnL1RSLzIwMTEvUkVDLWNzczMtc2VsZWN0b3JzLTIwMTEwOTI5LyNjaGVja2VkXG5cdFx0XHQvLyBJRTggdGhyb3dzIGVycm9yIGhlcmUgYW5kIHdpbGwgbm90IHNlZSBsYXRlciB0ZXN0c1xuXHRcdFx0aWYgKCAhZGl2LnF1ZXJ5U2VsZWN0b3JBbGwoXCI6Y2hlY2tlZFwiKS5sZW5ndGggKSB7XG5cdFx0XHRcdHJidWdneVFTQS5wdXNoKFwiOmNoZWNrZWRcIik7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFN1cHBvcnQ6IFNhZmFyaSA4KywgaU9TIDgrXG5cdFx0XHQvLyBodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTM2ODUxXG5cdFx0XHQvLyBJbi1wYWdlIGBzZWxlY3RvciNpZCBzaWJpbmctY29tYmluYXRvciBzZWxlY3RvcmAgZmFpbHNcblx0XHRcdGlmICggIWRpdi5xdWVyeVNlbGVjdG9yQWxsKCBcImEjXCIgKyBleHBhbmRvICsgXCIrKlwiICkubGVuZ3RoICkge1xuXHRcdFx0XHRyYnVnZ3lRU0EucHVzaChcIi4jLitbK35dXCIpO1xuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0YXNzZXJ0KGZ1bmN0aW9uKCBkaXYgKSB7XG5cdFx0XHQvLyBTdXBwb3J0OiBXaW5kb3dzIDggTmF0aXZlIEFwcHNcblx0XHRcdC8vIFRoZSB0eXBlIGFuZCBuYW1lIGF0dHJpYnV0ZXMgYXJlIHJlc3RyaWN0ZWQgZHVyaW5nIC5pbm5lckhUTUwgYXNzaWdubWVudFxuXHRcdFx0dmFyIGlucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImlucHV0XCIpO1xuXHRcdFx0aW5wdXQuc2V0QXR0cmlidXRlKCBcInR5cGVcIiwgXCJoaWRkZW5cIiApO1xuXHRcdFx0ZGl2LmFwcGVuZENoaWxkKCBpbnB1dCApLnNldEF0dHJpYnV0ZSggXCJuYW1lXCIsIFwiRFwiICk7XG5cblx0XHRcdC8vIFN1cHBvcnQ6IElFOFxuXHRcdFx0Ly8gRW5mb3JjZSBjYXNlLXNlbnNpdGl2aXR5IG9mIG5hbWUgYXR0cmlidXRlXG5cdFx0XHRpZiAoIGRpdi5xdWVyeVNlbGVjdG9yQWxsKFwiW25hbWU9ZF1cIikubGVuZ3RoICkge1xuXHRcdFx0XHRyYnVnZ3lRU0EucHVzaCggXCJuYW1lXCIgKyB3aGl0ZXNwYWNlICsgXCIqWypeJHwhfl0/PVwiICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEZGIDMuNSAtIDplbmFibGVkLzpkaXNhYmxlZCBhbmQgaGlkZGVuIGVsZW1lbnRzIChoaWRkZW4gZWxlbWVudHMgYXJlIHN0aWxsIGVuYWJsZWQpXG5cdFx0XHQvLyBJRTggdGhyb3dzIGVycm9yIGhlcmUgYW5kIHdpbGwgbm90IHNlZSBsYXRlciB0ZXN0c1xuXHRcdFx0aWYgKCAhZGl2LnF1ZXJ5U2VsZWN0b3JBbGwoXCI6ZW5hYmxlZFwiKS5sZW5ndGggKSB7XG5cdFx0XHRcdHJidWdneVFTQS5wdXNoKCBcIjplbmFibGVkXCIsIFwiOmRpc2FibGVkXCIgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gT3BlcmEgMTAtMTEgZG9lcyBub3QgdGhyb3cgb24gcG9zdC1jb21tYSBpbnZhbGlkIHBzZXVkb3Ncblx0XHRcdGRpdi5xdWVyeVNlbGVjdG9yQWxsKFwiKiw6eFwiKTtcblx0XHRcdHJidWdneVFTQS5wdXNoKFwiLC4qOlwiKTtcblx0XHR9KTtcblx0fVxuXG5cdGlmICggKHN1cHBvcnQubWF0Y2hlc1NlbGVjdG9yID0gcm5hdGl2ZS50ZXN0KCAobWF0Y2hlcyA9IGRvY0VsZW0ubWF0Y2hlcyB8fFxuXHRcdGRvY0VsZW0ud2Via2l0TWF0Y2hlc1NlbGVjdG9yIHx8XG5cdFx0ZG9jRWxlbS5tb3pNYXRjaGVzU2VsZWN0b3IgfHxcblx0XHRkb2NFbGVtLm9NYXRjaGVzU2VsZWN0b3IgfHxcblx0XHRkb2NFbGVtLm1zTWF0Y2hlc1NlbGVjdG9yKSApKSApIHtcblxuXHRcdGFzc2VydChmdW5jdGlvbiggZGl2ICkge1xuXHRcdFx0Ly8gQ2hlY2sgdG8gc2VlIGlmIGl0J3MgcG9zc2libGUgdG8gZG8gbWF0Y2hlc1NlbGVjdG9yXG5cdFx0XHQvLyBvbiBhIGRpc2Nvbm5lY3RlZCBub2RlIChJRSA5KVxuXHRcdFx0c3VwcG9ydC5kaXNjb25uZWN0ZWRNYXRjaCA9IG1hdGNoZXMuY2FsbCggZGl2LCBcImRpdlwiICk7XG5cblx0XHRcdC8vIFRoaXMgc2hvdWxkIGZhaWwgd2l0aCBhbiBleGNlcHRpb25cblx0XHRcdC8vIEdlY2tvIGRvZXMgbm90IGVycm9yLCByZXR1cm5zIGZhbHNlIGluc3RlYWRcblx0XHRcdG1hdGNoZXMuY2FsbCggZGl2LCBcIltzIT0nJ106eFwiICk7XG5cdFx0XHRyYnVnZ3lNYXRjaGVzLnB1c2goIFwiIT1cIiwgcHNldWRvcyApO1xuXHRcdH0pO1xuXHR9XG5cblx0cmJ1Z2d5UVNBID0gcmJ1Z2d5UVNBLmxlbmd0aCAmJiBuZXcgUmVnRXhwKCByYnVnZ3lRU0Euam9pbihcInxcIikgKTtcblx0cmJ1Z2d5TWF0Y2hlcyA9IHJidWdneU1hdGNoZXMubGVuZ3RoICYmIG5ldyBSZWdFeHAoIHJidWdneU1hdGNoZXMuam9pbihcInxcIikgKTtcblxuXHQvKiBDb250YWluc1xuXHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5cdGhhc0NvbXBhcmUgPSBybmF0aXZlLnRlc3QoIGRvY0VsZW0uY29tcGFyZURvY3VtZW50UG9zaXRpb24gKTtcblxuXHQvLyBFbGVtZW50IGNvbnRhaW5zIGFub3RoZXJcblx0Ly8gUHVycG9zZWZ1bGx5IHNlbGYtZXhjbHVzaXZlXG5cdC8vIEFzIGluLCBhbiBlbGVtZW50IGRvZXMgbm90IGNvbnRhaW4gaXRzZWxmXG5cdGNvbnRhaW5zID0gaGFzQ29tcGFyZSB8fCBybmF0aXZlLnRlc3QoIGRvY0VsZW0uY29udGFpbnMgKSA/XG5cdFx0ZnVuY3Rpb24oIGEsIGIgKSB7XG5cdFx0XHR2YXIgYWRvd24gPSBhLm5vZGVUeXBlID09PSA5ID8gYS5kb2N1bWVudEVsZW1lbnQgOiBhLFxuXHRcdFx0XHRidXAgPSBiICYmIGIucGFyZW50Tm9kZTtcblx0XHRcdHJldHVybiBhID09PSBidXAgfHwgISEoIGJ1cCAmJiBidXAubm9kZVR5cGUgPT09IDEgJiYgKFxuXHRcdFx0XHRhZG93bi5jb250YWlucyA/XG5cdFx0XHRcdFx0YWRvd24uY29udGFpbnMoIGJ1cCApIDpcblx0XHRcdFx0XHRhLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uICYmIGEuY29tcGFyZURvY3VtZW50UG9zaXRpb24oIGJ1cCApICYgMTZcblx0XHRcdCkpO1xuXHRcdH0gOlxuXHRcdGZ1bmN0aW9uKCBhLCBiICkge1xuXHRcdFx0aWYgKCBiICkge1xuXHRcdFx0XHR3aGlsZSAoIChiID0gYi5wYXJlbnROb2RlKSApIHtcblx0XHRcdFx0XHRpZiAoIGIgPT09IGEgKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9O1xuXG5cdC8qIFNvcnRpbmdcblx0LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuXG5cdC8vIERvY3VtZW50IG9yZGVyIHNvcnRpbmdcblx0c29ydE9yZGVyID0gaGFzQ29tcGFyZSA/XG5cdGZ1bmN0aW9uKCBhLCBiICkge1xuXG5cdFx0Ly8gRmxhZyBmb3IgZHVwbGljYXRlIHJlbW92YWxcblx0XHRpZiAoIGEgPT09IGIgKSB7XG5cdFx0XHRoYXNEdXBsaWNhdGUgPSB0cnVlO1xuXHRcdFx0cmV0dXJuIDA7XG5cdFx0fVxuXG5cdFx0Ly8gU29ydCBvbiBtZXRob2QgZXhpc3RlbmNlIGlmIG9ubHkgb25lIGlucHV0IGhhcyBjb21wYXJlRG9jdW1lbnRQb3NpdGlvblxuXHRcdHZhciBjb21wYXJlID0gIWEuY29tcGFyZURvY3VtZW50UG9zaXRpb24gLSAhYi5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbjtcblx0XHRpZiAoIGNvbXBhcmUgKSB7XG5cdFx0XHRyZXR1cm4gY29tcGFyZTtcblx0XHR9XG5cblx0XHQvLyBDYWxjdWxhdGUgcG9zaXRpb24gaWYgYm90aCBpbnB1dHMgYmVsb25nIHRvIHRoZSBzYW1lIGRvY3VtZW50XG5cdFx0Y29tcGFyZSA9ICggYS5vd25lckRvY3VtZW50IHx8IGEgKSA9PT0gKCBiLm93bmVyRG9jdW1lbnQgfHwgYiApID9cblx0XHRcdGEuY29tcGFyZURvY3VtZW50UG9zaXRpb24oIGIgKSA6XG5cblx0XHRcdC8vIE90aGVyd2lzZSB3ZSBrbm93IHRoZXkgYXJlIGRpc2Nvbm5lY3RlZFxuXHRcdFx0MTtcblxuXHRcdC8vIERpc2Nvbm5lY3RlZCBub2Rlc1xuXHRcdGlmICggY29tcGFyZSAmIDEgfHxcblx0XHRcdCghc3VwcG9ydC5zb3J0RGV0YWNoZWQgJiYgYi5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbiggYSApID09PSBjb21wYXJlKSApIHtcblxuXHRcdFx0Ly8gQ2hvb3NlIHRoZSBmaXJzdCBlbGVtZW50IHRoYXQgaXMgcmVsYXRlZCB0byBvdXIgcHJlZmVycmVkIGRvY3VtZW50XG5cdFx0XHRpZiAoIGEgPT09IGRvY3VtZW50IHx8IGEub3duZXJEb2N1bWVudCA9PT0gcHJlZmVycmVkRG9jICYmIGNvbnRhaW5zKHByZWZlcnJlZERvYywgYSkgKSB7XG5cdFx0XHRcdHJldHVybiAtMTtcblx0XHRcdH1cblx0XHRcdGlmICggYiA9PT0gZG9jdW1lbnQgfHwgYi5vd25lckRvY3VtZW50ID09PSBwcmVmZXJyZWREb2MgJiYgY29udGFpbnMocHJlZmVycmVkRG9jLCBiKSApIHtcblx0XHRcdFx0cmV0dXJuIDE7XG5cdFx0XHR9XG5cblx0XHRcdC8vIE1haW50YWluIG9yaWdpbmFsIG9yZGVyXG5cdFx0XHRyZXR1cm4gc29ydElucHV0ID9cblx0XHRcdFx0KCBpbmRleE9mKCBzb3J0SW5wdXQsIGEgKSAtIGluZGV4T2YoIHNvcnRJbnB1dCwgYiApICkgOlxuXHRcdFx0XHQwO1xuXHRcdH1cblxuXHRcdHJldHVybiBjb21wYXJlICYgNCA/IC0xIDogMTtcblx0fSA6XG5cdGZ1bmN0aW9uKCBhLCBiICkge1xuXHRcdC8vIEV4aXQgZWFybHkgaWYgdGhlIG5vZGVzIGFyZSBpZGVudGljYWxcblx0XHRpZiAoIGEgPT09IGIgKSB7XG5cdFx0XHRoYXNEdXBsaWNhdGUgPSB0cnVlO1xuXHRcdFx0cmV0dXJuIDA7XG5cdFx0fVxuXG5cdFx0dmFyIGN1cixcblx0XHRcdGkgPSAwLFxuXHRcdFx0YXVwID0gYS5wYXJlbnROb2RlLFxuXHRcdFx0YnVwID0gYi5wYXJlbnROb2RlLFxuXHRcdFx0YXAgPSBbIGEgXSxcblx0XHRcdGJwID0gWyBiIF07XG5cblx0XHQvLyBQYXJlbnRsZXNzIG5vZGVzIGFyZSBlaXRoZXIgZG9jdW1lbnRzIG9yIGRpc2Nvbm5lY3RlZFxuXHRcdGlmICggIWF1cCB8fCAhYnVwICkge1xuXHRcdFx0cmV0dXJuIGEgPT09IGRvY3VtZW50ID8gLTEgOlxuXHRcdFx0XHRiID09PSBkb2N1bWVudCA/IDEgOlxuXHRcdFx0XHRhdXAgPyAtMSA6XG5cdFx0XHRcdGJ1cCA/IDEgOlxuXHRcdFx0XHRzb3J0SW5wdXQgP1xuXHRcdFx0XHQoIGluZGV4T2YoIHNvcnRJbnB1dCwgYSApIC0gaW5kZXhPZiggc29ydElucHV0LCBiICkgKSA6XG5cdFx0XHRcdDA7XG5cblx0XHQvLyBJZiB0aGUgbm9kZXMgYXJlIHNpYmxpbmdzLCB3ZSBjYW4gZG8gYSBxdWljayBjaGVja1xuXHRcdH0gZWxzZSBpZiAoIGF1cCA9PT0gYnVwICkge1xuXHRcdFx0cmV0dXJuIHNpYmxpbmdDaGVjayggYSwgYiApO1xuXHRcdH1cblxuXHRcdC8vIE90aGVyd2lzZSB3ZSBuZWVkIGZ1bGwgbGlzdHMgb2YgdGhlaXIgYW5jZXN0b3JzIGZvciBjb21wYXJpc29uXG5cdFx0Y3VyID0gYTtcblx0XHR3aGlsZSAoIChjdXIgPSBjdXIucGFyZW50Tm9kZSkgKSB7XG5cdFx0XHRhcC51bnNoaWZ0KCBjdXIgKTtcblx0XHR9XG5cdFx0Y3VyID0gYjtcblx0XHR3aGlsZSAoIChjdXIgPSBjdXIucGFyZW50Tm9kZSkgKSB7XG5cdFx0XHRicC51bnNoaWZ0KCBjdXIgKTtcblx0XHR9XG5cblx0XHQvLyBXYWxrIGRvd24gdGhlIHRyZWUgbG9va2luZyBmb3IgYSBkaXNjcmVwYW5jeVxuXHRcdHdoaWxlICggYXBbaV0gPT09IGJwW2ldICkge1xuXHRcdFx0aSsrO1xuXHRcdH1cblxuXHRcdHJldHVybiBpID9cblx0XHRcdC8vIERvIGEgc2libGluZyBjaGVjayBpZiB0aGUgbm9kZXMgaGF2ZSBhIGNvbW1vbiBhbmNlc3RvclxuXHRcdFx0c2libGluZ0NoZWNrKCBhcFtpXSwgYnBbaV0gKSA6XG5cblx0XHRcdC8vIE90aGVyd2lzZSBub2RlcyBpbiBvdXIgZG9jdW1lbnQgc29ydCBmaXJzdFxuXHRcdFx0YXBbaV0gPT09IHByZWZlcnJlZERvYyA/IC0xIDpcblx0XHRcdGJwW2ldID09PSBwcmVmZXJyZWREb2MgPyAxIDpcblx0XHRcdDA7XG5cdH07XG5cblx0cmV0dXJuIGRvY3VtZW50O1xufTtcblxuU2l6emxlLm1hdGNoZXMgPSBmdW5jdGlvbiggZXhwciwgZWxlbWVudHMgKSB7XG5cdHJldHVybiBTaXp6bGUoIGV4cHIsIG51bGwsIG51bGwsIGVsZW1lbnRzICk7XG59O1xuXG5TaXp6bGUubWF0Y2hlc1NlbGVjdG9yID0gZnVuY3Rpb24oIGVsZW0sIGV4cHIgKSB7XG5cdC8vIFNldCBkb2N1bWVudCB2YXJzIGlmIG5lZWRlZFxuXHRpZiAoICggZWxlbS5vd25lckRvY3VtZW50IHx8IGVsZW0gKSAhPT0gZG9jdW1lbnQgKSB7XG5cdFx0c2V0RG9jdW1lbnQoIGVsZW0gKTtcblx0fVxuXG5cdC8vIE1ha2Ugc3VyZSB0aGF0IGF0dHJpYnV0ZSBzZWxlY3RvcnMgYXJlIHF1b3RlZFxuXHRleHByID0gZXhwci5yZXBsYWNlKCByYXR0cmlidXRlUXVvdGVzLCBcIj0nJDEnXVwiICk7XG5cblx0aWYgKCBzdXBwb3J0Lm1hdGNoZXNTZWxlY3RvciAmJiBkb2N1bWVudElzSFRNTCAmJlxuXHRcdCFjb21waWxlckNhY2hlWyBleHByICsgXCIgXCIgXSAmJlxuXHRcdCggIXJidWdneU1hdGNoZXMgfHwgIXJidWdneU1hdGNoZXMudGVzdCggZXhwciApICkgJiZcblx0XHQoICFyYnVnZ3lRU0EgICAgIHx8ICFyYnVnZ3lRU0EudGVzdCggZXhwciApICkgKSB7XG5cblx0XHR0cnkge1xuXHRcdFx0dmFyIHJldCA9IG1hdGNoZXMuY2FsbCggZWxlbSwgZXhwciApO1xuXG5cdFx0XHQvLyBJRSA5J3MgbWF0Y2hlc1NlbGVjdG9yIHJldHVybnMgZmFsc2Ugb24gZGlzY29ubmVjdGVkIG5vZGVzXG5cdFx0XHRpZiAoIHJldCB8fCBzdXBwb3J0LmRpc2Nvbm5lY3RlZE1hdGNoIHx8XG5cdFx0XHRcdFx0Ly8gQXMgd2VsbCwgZGlzY29ubmVjdGVkIG5vZGVzIGFyZSBzYWlkIHRvIGJlIGluIGEgZG9jdW1lbnRcblx0XHRcdFx0XHQvLyBmcmFnbWVudCBpbiBJRSA5XG5cdFx0XHRcdFx0ZWxlbS5kb2N1bWVudCAmJiBlbGVtLmRvY3VtZW50Lm5vZGVUeXBlICE9PSAxMSApIHtcblx0XHRcdFx0cmV0dXJuIHJldDtcblx0XHRcdH1cblx0XHR9IGNhdGNoIChlKSB7fVxuXHR9XG5cblx0cmV0dXJuIFNpenpsZSggZXhwciwgZG9jdW1lbnQsIG51bGwsIFsgZWxlbSBdICkubGVuZ3RoID4gMDtcbn07XG5cblNpenpsZS5jb250YWlucyA9IGZ1bmN0aW9uKCBjb250ZXh0LCBlbGVtICkge1xuXHQvLyBTZXQgZG9jdW1lbnQgdmFycyBpZiBuZWVkZWRcblx0aWYgKCAoIGNvbnRleHQub3duZXJEb2N1bWVudCB8fCBjb250ZXh0ICkgIT09IGRvY3VtZW50ICkge1xuXHRcdHNldERvY3VtZW50KCBjb250ZXh0ICk7XG5cdH1cblx0cmV0dXJuIGNvbnRhaW5zKCBjb250ZXh0LCBlbGVtICk7XG59O1xuXG5TaXp6bGUuYXR0ciA9IGZ1bmN0aW9uKCBlbGVtLCBuYW1lICkge1xuXHQvLyBTZXQgZG9jdW1lbnQgdmFycyBpZiBuZWVkZWRcblx0aWYgKCAoIGVsZW0ub3duZXJEb2N1bWVudCB8fCBlbGVtICkgIT09IGRvY3VtZW50ICkge1xuXHRcdHNldERvY3VtZW50KCBlbGVtICk7XG5cdH1cblxuXHR2YXIgZm4gPSBFeHByLmF0dHJIYW5kbGVbIG5hbWUudG9Mb3dlckNhc2UoKSBdLFxuXHRcdC8vIERvbid0IGdldCBmb29sZWQgYnkgT2JqZWN0LnByb3RvdHlwZSBwcm9wZXJ0aWVzIChqUXVlcnkgIzEzODA3KVxuXHRcdHZhbCA9IGZuICYmIGhhc093bi5jYWxsKCBFeHByLmF0dHJIYW5kbGUsIG5hbWUudG9Mb3dlckNhc2UoKSApID9cblx0XHRcdGZuKCBlbGVtLCBuYW1lLCAhZG9jdW1lbnRJc0hUTUwgKSA6XG5cdFx0XHR1bmRlZmluZWQ7XG5cblx0cmV0dXJuIHZhbCAhPT0gdW5kZWZpbmVkID9cblx0XHR2YWwgOlxuXHRcdHN1cHBvcnQuYXR0cmlidXRlcyB8fCAhZG9jdW1lbnRJc0hUTUwgP1xuXHRcdFx0ZWxlbS5nZXRBdHRyaWJ1dGUoIG5hbWUgKSA6XG5cdFx0XHQodmFsID0gZWxlbS5nZXRBdHRyaWJ1dGVOb2RlKG5hbWUpKSAmJiB2YWwuc3BlY2lmaWVkID9cblx0XHRcdFx0dmFsLnZhbHVlIDpcblx0XHRcdFx0bnVsbDtcbn07XG5cblNpenpsZS5lcnJvciA9IGZ1bmN0aW9uKCBtc2cgKSB7XG5cdHRocm93IG5ldyBFcnJvciggXCJTeW50YXggZXJyb3IsIHVucmVjb2duaXplZCBleHByZXNzaW9uOiBcIiArIG1zZyApO1xufTtcblxuLyoqXG4gKiBEb2N1bWVudCBzb3J0aW5nIGFuZCByZW1vdmluZyBkdXBsaWNhdGVzXG4gKiBAcGFyYW0ge0FycmF5TGlrZX0gcmVzdWx0c1xuICovXG5TaXp6bGUudW5pcXVlU29ydCA9IGZ1bmN0aW9uKCByZXN1bHRzICkge1xuXHR2YXIgZWxlbSxcblx0XHRkdXBsaWNhdGVzID0gW10sXG5cdFx0aiA9IDAsXG5cdFx0aSA9IDA7XG5cblx0Ly8gVW5sZXNzIHdlICprbm93KiB3ZSBjYW4gZGV0ZWN0IGR1cGxpY2F0ZXMsIGFzc3VtZSB0aGVpciBwcmVzZW5jZVxuXHRoYXNEdXBsaWNhdGUgPSAhc3VwcG9ydC5kZXRlY3REdXBsaWNhdGVzO1xuXHRzb3J0SW5wdXQgPSAhc3VwcG9ydC5zb3J0U3RhYmxlICYmIHJlc3VsdHMuc2xpY2UoIDAgKTtcblx0cmVzdWx0cy5zb3J0KCBzb3J0T3JkZXIgKTtcblxuXHRpZiAoIGhhc0R1cGxpY2F0ZSApIHtcblx0XHR3aGlsZSAoIChlbGVtID0gcmVzdWx0c1tpKytdKSApIHtcblx0XHRcdGlmICggZWxlbSA9PT0gcmVzdWx0c1sgaSBdICkge1xuXHRcdFx0XHRqID0gZHVwbGljYXRlcy5wdXNoKCBpICk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHdoaWxlICggai0tICkge1xuXHRcdFx0cmVzdWx0cy5zcGxpY2UoIGR1cGxpY2F0ZXNbIGogXSwgMSApO1xuXHRcdH1cblx0fVxuXG5cdC8vIENsZWFyIGlucHV0IGFmdGVyIHNvcnRpbmcgdG8gcmVsZWFzZSBvYmplY3RzXG5cdC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vanF1ZXJ5L3NpenpsZS9wdWxsLzIyNVxuXHRzb3J0SW5wdXQgPSBudWxsO1xuXG5cdHJldHVybiByZXN1bHRzO1xufTtcblxuLyoqXG4gKiBVdGlsaXR5IGZ1bmN0aW9uIGZvciByZXRyaWV2aW5nIHRoZSB0ZXh0IHZhbHVlIG9mIGFuIGFycmF5IG9mIERPTSBub2Rlc1xuICogQHBhcmFtIHtBcnJheXxFbGVtZW50fSBlbGVtXG4gKi9cbmdldFRleHQgPSBTaXp6bGUuZ2V0VGV4dCA9IGZ1bmN0aW9uKCBlbGVtICkge1xuXHR2YXIgbm9kZSxcblx0XHRyZXQgPSBcIlwiLFxuXHRcdGkgPSAwLFxuXHRcdG5vZGVUeXBlID0gZWxlbS5ub2RlVHlwZTtcblxuXHRpZiAoICFub2RlVHlwZSApIHtcblx0XHQvLyBJZiBubyBub2RlVHlwZSwgdGhpcyBpcyBleHBlY3RlZCB0byBiZSBhbiBhcnJheVxuXHRcdHdoaWxlICggKG5vZGUgPSBlbGVtW2krK10pICkge1xuXHRcdFx0Ly8gRG8gbm90IHRyYXZlcnNlIGNvbW1lbnQgbm9kZXNcblx0XHRcdHJldCArPSBnZXRUZXh0KCBub2RlICk7XG5cdFx0fVxuXHR9IGVsc2UgaWYgKCBub2RlVHlwZSA9PT0gMSB8fCBub2RlVHlwZSA9PT0gOSB8fCBub2RlVHlwZSA9PT0gMTEgKSB7XG5cdFx0Ly8gVXNlIHRleHRDb250ZW50IGZvciBlbGVtZW50c1xuXHRcdC8vIGlubmVyVGV4dCB1c2FnZSByZW1vdmVkIGZvciBjb25zaXN0ZW5jeSBvZiBuZXcgbGluZXMgKGpRdWVyeSAjMTExNTMpXG5cdFx0aWYgKCB0eXBlb2YgZWxlbS50ZXh0Q29udGVudCA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdHJldHVybiBlbGVtLnRleHRDb250ZW50O1xuXHRcdH0gZWxzZSB7XG5cdFx0XHQvLyBUcmF2ZXJzZSBpdHMgY2hpbGRyZW5cblx0XHRcdGZvciAoIGVsZW0gPSBlbGVtLmZpcnN0Q2hpbGQ7IGVsZW07IGVsZW0gPSBlbGVtLm5leHRTaWJsaW5nICkge1xuXHRcdFx0XHRyZXQgKz0gZ2V0VGV4dCggZWxlbSApO1xuXHRcdFx0fVxuXHRcdH1cblx0fSBlbHNlIGlmICggbm9kZVR5cGUgPT09IDMgfHwgbm9kZVR5cGUgPT09IDQgKSB7XG5cdFx0cmV0dXJuIGVsZW0ubm9kZVZhbHVlO1xuXHR9XG5cdC8vIERvIG5vdCBpbmNsdWRlIGNvbW1lbnQgb3IgcHJvY2Vzc2luZyBpbnN0cnVjdGlvbiBub2Rlc1xuXG5cdHJldHVybiByZXQ7XG59O1xuXG5FeHByID0gU2l6emxlLnNlbGVjdG9ycyA9IHtcblxuXHQvLyBDYW4gYmUgYWRqdXN0ZWQgYnkgdGhlIHVzZXJcblx0Y2FjaGVMZW5ndGg6IDUwLFxuXG5cdGNyZWF0ZVBzZXVkbzogbWFya0Z1bmN0aW9uLFxuXG5cdG1hdGNoOiBtYXRjaEV4cHIsXG5cblx0YXR0ckhhbmRsZToge30sXG5cblx0ZmluZDoge30sXG5cblx0cmVsYXRpdmU6IHtcblx0XHRcIj5cIjogeyBkaXI6IFwicGFyZW50Tm9kZVwiLCBmaXJzdDogdHJ1ZSB9LFxuXHRcdFwiIFwiOiB7IGRpcjogXCJwYXJlbnROb2RlXCIgfSxcblx0XHRcIitcIjogeyBkaXI6IFwicHJldmlvdXNTaWJsaW5nXCIsIGZpcnN0OiB0cnVlIH0sXG5cdFx0XCJ+XCI6IHsgZGlyOiBcInByZXZpb3VzU2libGluZ1wiIH1cblx0fSxcblxuXHRwcmVGaWx0ZXI6IHtcblx0XHRcIkFUVFJcIjogZnVuY3Rpb24oIG1hdGNoICkge1xuXHRcdFx0bWF0Y2hbMV0gPSBtYXRjaFsxXS5yZXBsYWNlKCBydW5lc2NhcGUsIGZ1bmVzY2FwZSApO1xuXG5cdFx0XHQvLyBNb3ZlIHRoZSBnaXZlbiB2YWx1ZSB0byBtYXRjaFszXSB3aGV0aGVyIHF1b3RlZCBvciB1bnF1b3RlZFxuXHRcdFx0bWF0Y2hbM10gPSAoIG1hdGNoWzNdIHx8IG1hdGNoWzRdIHx8IG1hdGNoWzVdIHx8IFwiXCIgKS5yZXBsYWNlKCBydW5lc2NhcGUsIGZ1bmVzY2FwZSApO1xuXG5cdFx0XHRpZiAoIG1hdGNoWzJdID09PSBcIn49XCIgKSB7XG5cdFx0XHRcdG1hdGNoWzNdID0gXCIgXCIgKyBtYXRjaFszXSArIFwiIFwiO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gbWF0Y2guc2xpY2UoIDAsIDQgKTtcblx0XHR9LFxuXG5cdFx0XCJDSElMRFwiOiBmdW5jdGlvbiggbWF0Y2ggKSB7XG5cdFx0XHQvKiBtYXRjaGVzIGZyb20gbWF0Y2hFeHByW1wiQ0hJTERcIl1cblx0XHRcdFx0MSB0eXBlIChvbmx5fG50aHwuLi4pXG5cdFx0XHRcdDIgd2hhdCAoY2hpbGR8b2YtdHlwZSlcblx0XHRcdFx0MyBhcmd1bWVudCAoZXZlbnxvZGR8XFxkKnxcXGQqbihbKy1dXFxkKyk/fC4uLilcblx0XHRcdFx0NCB4bi1jb21wb25lbnQgb2YgeG4reSBhcmd1bWVudCAoWystXT9cXGQqbnwpXG5cdFx0XHRcdDUgc2lnbiBvZiB4bi1jb21wb25lbnRcblx0XHRcdFx0NiB4IG9mIHhuLWNvbXBvbmVudFxuXHRcdFx0XHQ3IHNpZ24gb2YgeS1jb21wb25lbnRcblx0XHRcdFx0OCB5IG9mIHktY29tcG9uZW50XG5cdFx0XHQqL1xuXHRcdFx0bWF0Y2hbMV0gPSBtYXRjaFsxXS50b0xvd2VyQ2FzZSgpO1xuXG5cdFx0XHRpZiAoIG1hdGNoWzFdLnNsaWNlKCAwLCAzICkgPT09IFwibnRoXCIgKSB7XG5cdFx0XHRcdC8vIG50aC0qIHJlcXVpcmVzIGFyZ3VtZW50XG5cdFx0XHRcdGlmICggIW1hdGNoWzNdICkge1xuXHRcdFx0XHRcdFNpenpsZS5lcnJvciggbWF0Y2hbMF0gKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIG51bWVyaWMgeCBhbmQgeSBwYXJhbWV0ZXJzIGZvciBFeHByLmZpbHRlci5DSElMRFxuXHRcdFx0XHQvLyByZW1lbWJlciB0aGF0IGZhbHNlL3RydWUgY2FzdCByZXNwZWN0aXZlbHkgdG8gMC8xXG5cdFx0XHRcdG1hdGNoWzRdID0gKyggbWF0Y2hbNF0gPyBtYXRjaFs1XSArIChtYXRjaFs2XSB8fCAxKSA6IDIgKiAoIG1hdGNoWzNdID09PSBcImV2ZW5cIiB8fCBtYXRjaFszXSA9PT0gXCJvZGRcIiApICk7XG5cdFx0XHRcdG1hdGNoWzVdID0gKyggKCBtYXRjaFs3XSArIG1hdGNoWzhdICkgfHwgbWF0Y2hbM10gPT09IFwib2RkXCIgKTtcblxuXHRcdFx0Ly8gb3RoZXIgdHlwZXMgcHJvaGliaXQgYXJndW1lbnRzXG5cdFx0XHR9IGVsc2UgaWYgKCBtYXRjaFszXSApIHtcblx0XHRcdFx0U2l6emxlLmVycm9yKCBtYXRjaFswXSApO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gbWF0Y2g7XG5cdFx0fSxcblxuXHRcdFwiUFNFVURPXCI6IGZ1bmN0aW9uKCBtYXRjaCApIHtcblx0XHRcdHZhciBleGNlc3MsXG5cdFx0XHRcdHVucXVvdGVkID0gIW1hdGNoWzZdICYmIG1hdGNoWzJdO1xuXG5cdFx0XHRpZiAoIG1hdGNoRXhwcltcIkNISUxEXCJdLnRlc3QoIG1hdGNoWzBdICkgKSB7XG5cdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBBY2NlcHQgcXVvdGVkIGFyZ3VtZW50cyBhcy1pc1xuXHRcdFx0aWYgKCBtYXRjaFszXSApIHtcblx0XHRcdFx0bWF0Y2hbMl0gPSBtYXRjaFs0XSB8fCBtYXRjaFs1XSB8fCBcIlwiO1xuXG5cdFx0XHQvLyBTdHJpcCBleGNlc3MgY2hhcmFjdGVycyBmcm9tIHVucXVvdGVkIGFyZ3VtZW50c1xuXHRcdFx0fSBlbHNlIGlmICggdW5xdW90ZWQgJiYgcnBzZXVkby50ZXN0KCB1bnF1b3RlZCApICYmXG5cdFx0XHRcdC8vIEdldCBleGNlc3MgZnJvbSB0b2tlbml6ZSAocmVjdXJzaXZlbHkpXG5cdFx0XHRcdChleGNlc3MgPSB0b2tlbml6ZSggdW5xdW90ZWQsIHRydWUgKSkgJiZcblx0XHRcdFx0Ly8gYWR2YW5jZSB0byB0aGUgbmV4dCBjbG9zaW5nIHBhcmVudGhlc2lzXG5cdFx0XHRcdChleGNlc3MgPSB1bnF1b3RlZC5pbmRleE9mKCBcIilcIiwgdW5xdW90ZWQubGVuZ3RoIC0gZXhjZXNzICkgLSB1bnF1b3RlZC5sZW5ndGgpICkge1xuXG5cdFx0XHRcdC8vIGV4Y2VzcyBpcyBhIG5lZ2F0aXZlIGluZGV4XG5cdFx0XHRcdG1hdGNoWzBdID0gbWF0Y2hbMF0uc2xpY2UoIDAsIGV4Y2VzcyApO1xuXHRcdFx0XHRtYXRjaFsyXSA9IHVucXVvdGVkLnNsaWNlKCAwLCBleGNlc3MgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gUmV0dXJuIG9ubHkgY2FwdHVyZXMgbmVlZGVkIGJ5IHRoZSBwc2V1ZG8gZmlsdGVyIG1ldGhvZCAodHlwZSBhbmQgYXJndW1lbnQpXG5cdFx0XHRyZXR1cm4gbWF0Y2guc2xpY2UoIDAsIDMgKTtcblx0XHR9XG5cdH0sXG5cblx0ZmlsdGVyOiB7XG5cblx0XHRcIlRBR1wiOiBmdW5jdGlvbiggbm9kZU5hbWVTZWxlY3RvciApIHtcblx0XHRcdHZhciBub2RlTmFtZSA9IG5vZGVOYW1lU2VsZWN0b3IucmVwbGFjZSggcnVuZXNjYXBlLCBmdW5lc2NhcGUgKS50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0cmV0dXJuIG5vZGVOYW1lU2VsZWN0b3IgPT09IFwiKlwiID9cblx0XHRcdFx0ZnVuY3Rpb24oKSB7IHJldHVybiB0cnVlOyB9IDpcblx0XHRcdFx0ZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGVsZW0ubm9kZU5hbWUgJiYgZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSBub2RlTmFtZTtcblx0XHRcdFx0fTtcblx0XHR9LFxuXG5cdFx0XCJDTEFTU1wiOiBmdW5jdGlvbiggY2xhc3NOYW1lICkge1xuXHRcdFx0dmFyIHBhdHRlcm4gPSBjbGFzc0NhY2hlWyBjbGFzc05hbWUgKyBcIiBcIiBdO1xuXG5cdFx0XHRyZXR1cm4gcGF0dGVybiB8fFxuXHRcdFx0XHQocGF0dGVybiA9IG5ldyBSZWdFeHAoIFwiKF58XCIgKyB3aGl0ZXNwYWNlICsgXCIpXCIgKyBjbGFzc05hbWUgKyBcIihcIiArIHdoaXRlc3BhY2UgKyBcInwkKVwiICkpICYmXG5cdFx0XHRcdGNsYXNzQ2FjaGUoIGNsYXNzTmFtZSwgZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHBhdHRlcm4udGVzdCggdHlwZW9mIGVsZW0uY2xhc3NOYW1lID09PSBcInN0cmluZ1wiICYmIGVsZW0uY2xhc3NOYW1lIHx8IHR5cGVvZiBlbGVtLmdldEF0dHJpYnV0ZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBlbGVtLmdldEF0dHJpYnV0ZShcImNsYXNzXCIpIHx8IFwiXCIgKTtcblx0XHRcdFx0fSk7XG5cdFx0fSxcblxuXHRcdFwiQVRUUlwiOiBmdW5jdGlvbiggbmFtZSwgb3BlcmF0b3IsIGNoZWNrICkge1xuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHR2YXIgcmVzdWx0ID0gU2l6emxlLmF0dHIoIGVsZW0sIG5hbWUgKTtcblxuXHRcdFx0XHRpZiAoIHJlc3VsdCA9PSBudWxsICkge1xuXHRcdFx0XHRcdHJldHVybiBvcGVyYXRvciA9PT0gXCIhPVwiO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICggIW9wZXJhdG9yICkge1xuXHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmVzdWx0ICs9IFwiXCI7XG5cblx0XHRcdFx0cmV0dXJuIG9wZXJhdG9yID09PSBcIj1cIiA/IHJlc3VsdCA9PT0gY2hlY2sgOlxuXHRcdFx0XHRcdG9wZXJhdG9yID09PSBcIiE9XCIgPyByZXN1bHQgIT09IGNoZWNrIDpcblx0XHRcdFx0XHRvcGVyYXRvciA9PT0gXCJePVwiID8gY2hlY2sgJiYgcmVzdWx0LmluZGV4T2YoIGNoZWNrICkgPT09IDAgOlxuXHRcdFx0XHRcdG9wZXJhdG9yID09PSBcIio9XCIgPyBjaGVjayAmJiByZXN1bHQuaW5kZXhPZiggY2hlY2sgKSA+IC0xIDpcblx0XHRcdFx0XHRvcGVyYXRvciA9PT0gXCIkPVwiID8gY2hlY2sgJiYgcmVzdWx0LnNsaWNlKCAtY2hlY2subGVuZ3RoICkgPT09IGNoZWNrIDpcblx0XHRcdFx0XHRvcGVyYXRvciA9PT0gXCJ+PVwiID8gKCBcIiBcIiArIHJlc3VsdC5yZXBsYWNlKCByd2hpdGVzcGFjZSwgXCIgXCIgKSArIFwiIFwiICkuaW5kZXhPZiggY2hlY2sgKSA+IC0xIDpcblx0XHRcdFx0XHRvcGVyYXRvciA9PT0gXCJ8PVwiID8gcmVzdWx0ID09PSBjaGVjayB8fCByZXN1bHQuc2xpY2UoIDAsIGNoZWNrLmxlbmd0aCArIDEgKSA9PT0gY2hlY2sgKyBcIi1cIiA6XG5cdFx0XHRcdFx0ZmFsc2U7XG5cdFx0XHR9O1xuXHRcdH0sXG5cblx0XHRcIkNISUxEXCI6IGZ1bmN0aW9uKCB0eXBlLCB3aGF0LCBhcmd1bWVudCwgZmlyc3QsIGxhc3QgKSB7XG5cdFx0XHR2YXIgc2ltcGxlID0gdHlwZS5zbGljZSggMCwgMyApICE9PSBcIm50aFwiLFxuXHRcdFx0XHRmb3J3YXJkID0gdHlwZS5zbGljZSggLTQgKSAhPT0gXCJsYXN0XCIsXG5cdFx0XHRcdG9mVHlwZSA9IHdoYXQgPT09IFwib2YtdHlwZVwiO1xuXG5cdFx0XHRyZXR1cm4gZmlyc3QgPT09IDEgJiYgbGFzdCA9PT0gMCA/XG5cblx0XHRcdFx0Ly8gU2hvcnRjdXQgZm9yIDpudGgtKihuKVxuXHRcdFx0XHRmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0XHRyZXR1cm4gISFlbGVtLnBhcmVudE5vZGU7XG5cdFx0XHRcdH0gOlxuXG5cdFx0XHRcdGZ1bmN0aW9uKCBlbGVtLCBjb250ZXh0LCB4bWwgKSB7XG5cdFx0XHRcdFx0dmFyIGNhY2hlLCB1bmlxdWVDYWNoZSwgb3V0ZXJDYWNoZSwgbm9kZSwgbm9kZUluZGV4LCBzdGFydCxcblx0XHRcdFx0XHRcdGRpciA9IHNpbXBsZSAhPT0gZm9yd2FyZCA/IFwibmV4dFNpYmxpbmdcIiA6IFwicHJldmlvdXNTaWJsaW5nXCIsXG5cdFx0XHRcdFx0XHRwYXJlbnQgPSBlbGVtLnBhcmVudE5vZGUsXG5cdFx0XHRcdFx0XHRuYW1lID0gb2ZUeXBlICYmIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSxcblx0XHRcdFx0XHRcdHVzZUNhY2hlID0gIXhtbCAmJiAhb2ZUeXBlLFxuXHRcdFx0XHRcdFx0ZGlmZiA9IGZhbHNlO1xuXG5cdFx0XHRcdFx0aWYgKCBwYXJlbnQgKSB7XG5cblx0XHRcdFx0XHRcdC8vIDooZmlyc3R8bGFzdHxvbmx5KS0oY2hpbGR8b2YtdHlwZSlcblx0XHRcdFx0XHRcdGlmICggc2ltcGxlICkge1xuXHRcdFx0XHRcdFx0XHR3aGlsZSAoIGRpciApIHtcblx0XHRcdFx0XHRcdFx0XHRub2RlID0gZWxlbTtcblx0XHRcdFx0XHRcdFx0XHR3aGlsZSAoIChub2RlID0gbm9kZVsgZGlyIF0pICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0aWYgKCBvZlR5cGUgP1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRub2RlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09IG5hbWUgOlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRub2RlLm5vZGVUeXBlID09PSAxICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0Ly8gUmV2ZXJzZSBkaXJlY3Rpb24gZm9yIDpvbmx5LSogKGlmIHdlIGhhdmVuJ3QgeWV0IGRvbmUgc28pXG5cdFx0XHRcdFx0XHRcdFx0c3RhcnQgPSBkaXIgPSB0eXBlID09PSBcIm9ubHlcIiAmJiAhc3RhcnQgJiYgXCJuZXh0U2libGluZ1wiO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRzdGFydCA9IFsgZm9yd2FyZCA/IHBhcmVudC5maXJzdENoaWxkIDogcGFyZW50Lmxhc3RDaGlsZCBdO1xuXG5cdFx0XHRcdFx0XHQvLyBub24teG1sIDpudGgtY2hpbGQoLi4uKSBzdG9yZXMgY2FjaGUgZGF0YSBvbiBgcGFyZW50YFxuXHRcdFx0XHRcdFx0aWYgKCBmb3J3YXJkICYmIHVzZUNhY2hlICkge1xuXG5cdFx0XHRcdFx0XHRcdC8vIFNlZWsgYGVsZW1gIGZyb20gYSBwcmV2aW91c2x5LWNhY2hlZCBpbmRleFxuXG5cdFx0XHRcdFx0XHRcdC8vIC4uLmluIGEgZ3ppcC1mcmllbmRseSB3YXlcblx0XHRcdFx0XHRcdFx0bm9kZSA9IHBhcmVudDtcblx0XHRcdFx0XHRcdFx0b3V0ZXJDYWNoZSA9IG5vZGVbIGV4cGFuZG8gXSB8fCAobm9kZVsgZXhwYW5kbyBdID0ge30pO1xuXG5cdFx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDw5IG9ubHlcblx0XHRcdFx0XHRcdFx0Ly8gRGVmZW5kIGFnYWluc3QgY2xvbmVkIGF0dHJvcGVydGllcyAoalF1ZXJ5IGdoLTE3MDkpXG5cdFx0XHRcdFx0XHRcdHVuaXF1ZUNhY2hlID0gb3V0ZXJDYWNoZVsgbm9kZS51bmlxdWVJRCBdIHx8XG5cdFx0XHRcdFx0XHRcdFx0KG91dGVyQ2FjaGVbIG5vZGUudW5pcXVlSUQgXSA9IHt9KTtcblxuXHRcdFx0XHRcdFx0XHRjYWNoZSA9IHVuaXF1ZUNhY2hlWyB0eXBlIF0gfHwgW107XG5cdFx0XHRcdFx0XHRcdG5vZGVJbmRleCA9IGNhY2hlWyAwIF0gPT09IGRpcnJ1bnMgJiYgY2FjaGVbIDEgXTtcblx0XHRcdFx0XHRcdFx0ZGlmZiA9IG5vZGVJbmRleCAmJiBjYWNoZVsgMiBdO1xuXHRcdFx0XHRcdFx0XHRub2RlID0gbm9kZUluZGV4ICYmIHBhcmVudC5jaGlsZE5vZGVzWyBub2RlSW5kZXggXTtcblxuXHRcdFx0XHRcdFx0XHR3aGlsZSAoIChub2RlID0gKytub2RlSW5kZXggJiYgbm9kZSAmJiBub2RlWyBkaXIgXSB8fFxuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gRmFsbGJhY2sgdG8gc2Vla2luZyBgZWxlbWAgZnJvbSB0aGUgc3RhcnRcblx0XHRcdFx0XHRcdFx0XHQoZGlmZiA9IG5vZGVJbmRleCA9IDApIHx8IHN0YXJ0LnBvcCgpKSApIHtcblxuXHRcdFx0XHRcdFx0XHRcdC8vIFdoZW4gZm91bmQsIGNhY2hlIGluZGV4ZXMgb24gYHBhcmVudGAgYW5kIGJyZWFrXG5cdFx0XHRcdFx0XHRcdFx0aWYgKCBub2RlLm5vZGVUeXBlID09PSAxICYmICsrZGlmZiAmJiBub2RlID09PSBlbGVtICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0dW5pcXVlQ2FjaGVbIHR5cGUgXSA9IFsgZGlycnVucywgbm9kZUluZGV4LCBkaWZmIF07XG5cdFx0XHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0Ly8gVXNlIHByZXZpb3VzbHktY2FjaGVkIGVsZW1lbnQgaW5kZXggaWYgYXZhaWxhYmxlXG5cdFx0XHRcdFx0XHRcdGlmICggdXNlQ2FjaGUgKSB7XG5cdFx0XHRcdFx0XHRcdFx0Ly8gLi4uaW4gYSBnemlwLWZyaWVuZGx5IHdheVxuXHRcdFx0XHRcdFx0XHRcdG5vZGUgPSBlbGVtO1xuXHRcdFx0XHRcdFx0XHRcdG91dGVyQ2FjaGUgPSBub2RlWyBleHBhbmRvIF0gfHwgKG5vZGVbIGV4cGFuZG8gXSA9IHt9KTtcblxuXHRcdFx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDw5IG9ubHlcblx0XHRcdFx0XHRcdFx0XHQvLyBEZWZlbmQgYWdhaW5zdCBjbG9uZWQgYXR0cm9wZXJ0aWVzIChqUXVlcnkgZ2gtMTcwOSlcblx0XHRcdFx0XHRcdFx0XHR1bmlxdWVDYWNoZSA9IG91dGVyQ2FjaGVbIG5vZGUudW5pcXVlSUQgXSB8fFxuXHRcdFx0XHRcdFx0XHRcdFx0KG91dGVyQ2FjaGVbIG5vZGUudW5pcXVlSUQgXSA9IHt9KTtcblxuXHRcdFx0XHRcdFx0XHRcdGNhY2hlID0gdW5pcXVlQ2FjaGVbIHR5cGUgXSB8fCBbXTtcblx0XHRcdFx0XHRcdFx0XHRub2RlSW5kZXggPSBjYWNoZVsgMCBdID09PSBkaXJydW5zICYmIGNhY2hlWyAxIF07XG5cdFx0XHRcdFx0XHRcdFx0ZGlmZiA9IG5vZGVJbmRleDtcblx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdC8vIHhtbCA6bnRoLWNoaWxkKC4uLilcblx0XHRcdFx0XHRcdFx0Ly8gb3IgOm50aC1sYXN0LWNoaWxkKC4uLikgb3IgOm50aCgtbGFzdCk/LW9mLXR5cGUoLi4uKVxuXHRcdFx0XHRcdFx0XHRpZiAoIGRpZmYgPT09IGZhbHNlICkge1xuXHRcdFx0XHRcdFx0XHRcdC8vIFVzZSB0aGUgc2FtZSBsb29wIGFzIGFib3ZlIHRvIHNlZWsgYGVsZW1gIGZyb20gdGhlIHN0YXJ0XG5cdFx0XHRcdFx0XHRcdFx0d2hpbGUgKCAobm9kZSA9ICsrbm9kZUluZGV4ICYmIG5vZGUgJiYgbm9kZVsgZGlyIF0gfHxcblx0XHRcdFx0XHRcdFx0XHRcdChkaWZmID0gbm9kZUluZGV4ID0gMCkgfHwgc3RhcnQucG9wKCkpICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRpZiAoICggb2ZUeXBlID9cblx0XHRcdFx0XHRcdFx0XHRcdFx0bm9kZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSBuYW1lIDpcblx0XHRcdFx0XHRcdFx0XHRcdFx0bm9kZS5ub2RlVHlwZSA9PT0gMSApICYmXG5cdFx0XHRcdFx0XHRcdFx0XHRcdCsrZGlmZiApIHtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBDYWNoZSB0aGUgaW5kZXggb2YgZWFjaCBlbmNvdW50ZXJlZCBlbGVtZW50XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlmICggdXNlQ2FjaGUgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0b3V0ZXJDYWNoZSA9IG5vZGVbIGV4cGFuZG8gXSB8fCAobm9kZVsgZXhwYW5kbyBdID0ge30pO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgPDkgb25seVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdC8vIERlZmVuZCBhZ2FpbnN0IGNsb25lZCBhdHRyb3BlcnRpZXMgKGpRdWVyeSBnaC0xNzA5KVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHVuaXF1ZUNhY2hlID0gb3V0ZXJDYWNoZVsgbm9kZS51bmlxdWVJRCBdIHx8XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHQob3V0ZXJDYWNoZVsgbm9kZS51bmlxdWVJRCBdID0ge30pO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0dW5pcXVlQ2FjaGVbIHR5cGUgXSA9IFsgZGlycnVucywgZGlmZiBdO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0aWYgKCBub2RlID09PSBlbGVtICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdC8vIEluY29ycG9yYXRlIHRoZSBvZmZzZXQsIHRoZW4gY2hlY2sgYWdhaW5zdCBjeWNsZSBzaXplXG5cdFx0XHRcdFx0XHRkaWZmIC09IGxhc3Q7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZGlmZiA9PT0gZmlyc3QgfHwgKCBkaWZmICUgZmlyc3QgPT09IDAgJiYgZGlmZiAvIGZpcnN0ID49IDAgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH07XG5cdFx0fSxcblxuXHRcdFwiUFNFVURPXCI6IGZ1bmN0aW9uKCBwc2V1ZG8sIGFyZ3VtZW50ICkge1xuXHRcdFx0Ly8gcHNldWRvLWNsYXNzIG5hbWVzIGFyZSBjYXNlLWluc2Vuc2l0aXZlXG5cdFx0XHQvLyBodHRwOi8vd3d3LnczLm9yZy9UUi9zZWxlY3RvcnMvI3BzZXVkby1jbGFzc2VzXG5cdFx0XHQvLyBQcmlvcml0aXplIGJ5IGNhc2Ugc2Vuc2l0aXZpdHkgaW4gY2FzZSBjdXN0b20gcHNldWRvcyBhcmUgYWRkZWQgd2l0aCB1cHBlcmNhc2UgbGV0dGVyc1xuXHRcdFx0Ly8gUmVtZW1iZXIgdGhhdCBzZXRGaWx0ZXJzIGluaGVyaXRzIGZyb20gcHNldWRvc1xuXHRcdFx0dmFyIGFyZ3MsXG5cdFx0XHRcdGZuID0gRXhwci5wc2V1ZG9zWyBwc2V1ZG8gXSB8fCBFeHByLnNldEZpbHRlcnNbIHBzZXVkby50b0xvd2VyQ2FzZSgpIF0gfHxcblx0XHRcdFx0XHRTaXp6bGUuZXJyb3IoIFwidW5zdXBwb3J0ZWQgcHNldWRvOiBcIiArIHBzZXVkbyApO1xuXG5cdFx0XHQvLyBUaGUgdXNlciBtYXkgdXNlIGNyZWF0ZVBzZXVkbyB0byBpbmRpY2F0ZSB0aGF0XG5cdFx0XHQvLyBhcmd1bWVudHMgYXJlIG5lZWRlZCB0byBjcmVhdGUgdGhlIGZpbHRlciBmdW5jdGlvblxuXHRcdFx0Ly8ganVzdCBhcyBTaXp6bGUgZG9lc1xuXHRcdFx0aWYgKCBmblsgZXhwYW5kbyBdICkge1xuXHRcdFx0XHRyZXR1cm4gZm4oIGFyZ3VtZW50ICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEJ1dCBtYWludGFpbiBzdXBwb3J0IGZvciBvbGQgc2lnbmF0dXJlc1xuXHRcdFx0aWYgKCBmbi5sZW5ndGggPiAxICkge1xuXHRcdFx0XHRhcmdzID0gWyBwc2V1ZG8sIHBzZXVkbywgXCJcIiwgYXJndW1lbnQgXTtcblx0XHRcdFx0cmV0dXJuIEV4cHIuc2V0RmlsdGVycy5oYXNPd25Qcm9wZXJ0eSggcHNldWRvLnRvTG93ZXJDYXNlKCkgKSA/XG5cdFx0XHRcdFx0bWFya0Z1bmN0aW9uKGZ1bmN0aW9uKCBzZWVkLCBtYXRjaGVzICkge1xuXHRcdFx0XHRcdFx0dmFyIGlkeCxcblx0XHRcdFx0XHRcdFx0bWF0Y2hlZCA9IGZuKCBzZWVkLCBhcmd1bWVudCApLFxuXHRcdFx0XHRcdFx0XHRpID0gbWF0Y2hlZC5sZW5ndGg7XG5cdFx0XHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHRcdFx0aWR4ID0gaW5kZXhPZiggc2VlZCwgbWF0Y2hlZFtpXSApO1xuXHRcdFx0XHRcdFx0XHRzZWVkWyBpZHggXSA9ICEoIG1hdGNoZXNbIGlkeCBdID0gbWF0Y2hlZFtpXSApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0pIDpcblx0XHRcdFx0XHRmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0XHRcdHJldHVybiBmbiggZWxlbSwgMCwgYXJncyApO1xuXHRcdFx0XHRcdH07XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBmbjtcblx0XHR9XG5cdH0sXG5cblx0cHNldWRvczoge1xuXHRcdC8vIFBvdGVudGlhbGx5IGNvbXBsZXggcHNldWRvc1xuXHRcdFwibm90XCI6IG1hcmtGdW5jdGlvbihmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0XHQvLyBUcmltIHRoZSBzZWxlY3RvciBwYXNzZWQgdG8gY29tcGlsZVxuXHRcdFx0Ly8gdG8gYXZvaWQgdHJlYXRpbmcgbGVhZGluZyBhbmQgdHJhaWxpbmdcblx0XHRcdC8vIHNwYWNlcyBhcyBjb21iaW5hdG9yc1xuXHRcdFx0dmFyIGlucHV0ID0gW10sXG5cdFx0XHRcdHJlc3VsdHMgPSBbXSxcblx0XHRcdFx0bWF0Y2hlciA9IGNvbXBpbGUoIHNlbGVjdG9yLnJlcGxhY2UoIHJ0cmltLCBcIiQxXCIgKSApO1xuXG5cdFx0XHRyZXR1cm4gbWF0Y2hlclsgZXhwYW5kbyBdID9cblx0XHRcdFx0bWFya0Z1bmN0aW9uKGZ1bmN0aW9uKCBzZWVkLCBtYXRjaGVzLCBjb250ZXh0LCB4bWwgKSB7XG5cdFx0XHRcdFx0dmFyIGVsZW0sXG5cdFx0XHRcdFx0XHR1bm1hdGNoZWQgPSBtYXRjaGVyKCBzZWVkLCBudWxsLCB4bWwsIFtdICksXG5cdFx0XHRcdFx0XHRpID0gc2VlZC5sZW5ndGg7XG5cblx0XHRcdFx0XHQvLyBNYXRjaCBlbGVtZW50cyB1bm1hdGNoZWQgYnkgYG1hdGNoZXJgXG5cdFx0XHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdFx0XHRpZiAoIChlbGVtID0gdW5tYXRjaGVkW2ldKSApIHtcblx0XHRcdFx0XHRcdFx0c2VlZFtpXSA9ICEobWF0Y2hlc1tpXSA9IGVsZW0pO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSkgOlxuXHRcdFx0XHRmdW5jdGlvbiggZWxlbSwgY29udGV4dCwgeG1sICkge1xuXHRcdFx0XHRcdGlucHV0WzBdID0gZWxlbTtcblx0XHRcdFx0XHRtYXRjaGVyKCBpbnB1dCwgbnVsbCwgeG1sLCByZXN1bHRzICk7XG5cdFx0XHRcdFx0Ly8gRG9uJ3Qga2VlcCB0aGUgZWxlbWVudCAoaXNzdWUgIzI5OSlcblx0XHRcdFx0XHRpbnB1dFswXSA9IG51bGw7XG5cdFx0XHRcdFx0cmV0dXJuICFyZXN1bHRzLnBvcCgpO1xuXHRcdFx0XHR9O1xuXHRcdH0pLFxuXG5cdFx0XCJoYXNcIjogbWFya0Z1bmN0aW9uKGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHRcdHJldHVybiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0cmV0dXJuIFNpenpsZSggc2VsZWN0b3IsIGVsZW0gKS5sZW5ndGggPiAwO1xuXHRcdFx0fTtcblx0XHR9KSxcblxuXHRcdFwiY29udGFpbnNcIjogbWFya0Z1bmN0aW9uKGZ1bmN0aW9uKCB0ZXh0ICkge1xuXHRcdFx0dGV4dCA9IHRleHQucmVwbGFjZSggcnVuZXNjYXBlLCBmdW5lc2NhcGUgKTtcblx0XHRcdHJldHVybiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0cmV0dXJuICggZWxlbS50ZXh0Q29udGVudCB8fCBlbGVtLmlubmVyVGV4dCB8fCBnZXRUZXh0KCBlbGVtICkgKS5pbmRleE9mKCB0ZXh0ICkgPiAtMTtcblx0XHRcdH07XG5cdFx0fSksXG5cblx0XHQvLyBcIldoZXRoZXIgYW4gZWxlbWVudCBpcyByZXByZXNlbnRlZCBieSBhIDpsYW5nKCkgc2VsZWN0b3Jcblx0XHQvLyBpcyBiYXNlZCBzb2xlbHkgb24gdGhlIGVsZW1lbnQncyBsYW5ndWFnZSB2YWx1ZVxuXHRcdC8vIGJlaW5nIGVxdWFsIHRvIHRoZSBpZGVudGlmaWVyIEMsXG5cdFx0Ly8gb3IgYmVnaW5uaW5nIHdpdGggdGhlIGlkZW50aWZpZXIgQyBpbW1lZGlhdGVseSBmb2xsb3dlZCBieSBcIi1cIi5cblx0XHQvLyBUaGUgbWF0Y2hpbmcgb2YgQyBhZ2FpbnN0IHRoZSBlbGVtZW50J3MgbGFuZ3VhZ2UgdmFsdWUgaXMgcGVyZm9ybWVkIGNhc2UtaW5zZW5zaXRpdmVseS5cblx0XHQvLyBUaGUgaWRlbnRpZmllciBDIGRvZXMgbm90IGhhdmUgdG8gYmUgYSB2YWxpZCBsYW5ndWFnZSBuYW1lLlwiXG5cdFx0Ly8gaHR0cDovL3d3dy53My5vcmcvVFIvc2VsZWN0b3JzLyNsYW5nLXBzZXVkb1xuXHRcdFwibGFuZ1wiOiBtYXJrRnVuY3Rpb24oIGZ1bmN0aW9uKCBsYW5nICkge1xuXHRcdFx0Ly8gbGFuZyB2YWx1ZSBtdXN0IGJlIGEgdmFsaWQgaWRlbnRpZmllclxuXHRcdFx0aWYgKCAhcmlkZW50aWZpZXIudGVzdChsYW5nIHx8IFwiXCIpICkge1xuXHRcdFx0XHRTaXp6bGUuZXJyb3IoIFwidW5zdXBwb3J0ZWQgbGFuZzogXCIgKyBsYW5nICk7XG5cdFx0XHR9XG5cdFx0XHRsYW5nID0gbGFuZy5yZXBsYWNlKCBydW5lc2NhcGUsIGZ1bmVzY2FwZSApLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdHZhciBlbGVtTGFuZztcblx0XHRcdFx0ZG8ge1xuXHRcdFx0XHRcdGlmICggKGVsZW1MYW5nID0gZG9jdW1lbnRJc0hUTUwgP1xuXHRcdFx0XHRcdFx0ZWxlbS5sYW5nIDpcblx0XHRcdFx0XHRcdGVsZW0uZ2V0QXR0cmlidXRlKFwieG1sOmxhbmdcIikgfHwgZWxlbS5nZXRBdHRyaWJ1dGUoXCJsYW5nXCIpKSApIHtcblxuXHRcdFx0XHRcdFx0ZWxlbUxhbmcgPSBlbGVtTGFuZy50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0XHRcdFx0cmV0dXJuIGVsZW1MYW5nID09PSBsYW5nIHx8IGVsZW1MYW5nLmluZGV4T2YoIGxhbmcgKyBcIi1cIiApID09PSAwO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSB3aGlsZSAoIChlbGVtID0gZWxlbS5wYXJlbnROb2RlKSAmJiBlbGVtLm5vZGVUeXBlID09PSAxICk7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH07XG5cdFx0fSksXG5cblx0XHQvLyBNaXNjZWxsYW5lb3VzXG5cdFx0XCJ0YXJnZXRcIjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHR2YXIgaGFzaCA9IHdpbmRvdy5sb2NhdGlvbiAmJiB3aW5kb3cubG9jYXRpb24uaGFzaDtcblx0XHRcdHJldHVybiBoYXNoICYmIGhhc2guc2xpY2UoIDEgKSA9PT0gZWxlbS5pZDtcblx0XHR9LFxuXG5cdFx0XCJyb290XCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuIGVsZW0gPT09IGRvY0VsZW07XG5cdFx0fSxcblxuXHRcdFwiZm9jdXNcIjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gZWxlbSA9PT0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudCAmJiAoIWRvY3VtZW50Lmhhc0ZvY3VzIHx8IGRvY3VtZW50Lmhhc0ZvY3VzKCkpICYmICEhKGVsZW0udHlwZSB8fCBlbGVtLmhyZWYgfHwgfmVsZW0udGFiSW5kZXgpO1xuXHRcdH0sXG5cblx0XHQvLyBCb29sZWFuIHByb3BlcnRpZXNcblx0XHRcImVuYWJsZWRcIjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gZWxlbS5kaXNhYmxlZCA9PT0gZmFsc2U7XG5cdFx0fSxcblxuXHRcdFwiZGlzYWJsZWRcIjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gZWxlbS5kaXNhYmxlZCA9PT0gdHJ1ZTtcblx0XHR9LFxuXG5cdFx0XCJjaGVja2VkXCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0Ly8gSW4gQ1NTMywgOmNoZWNrZWQgc2hvdWxkIHJldHVybiBib3RoIGNoZWNrZWQgYW5kIHNlbGVjdGVkIGVsZW1lbnRzXG5cdFx0XHQvLyBodHRwOi8vd3d3LnczLm9yZy9UUi8yMDExL1JFQy1jc3MzLXNlbGVjdG9ycy0yMDExMDkyOS8jY2hlY2tlZFxuXHRcdFx0dmFyIG5vZGVOYW1lID0gZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0cmV0dXJuIChub2RlTmFtZSA9PT0gXCJpbnB1dFwiICYmICEhZWxlbS5jaGVja2VkKSB8fCAobm9kZU5hbWUgPT09IFwib3B0aW9uXCIgJiYgISFlbGVtLnNlbGVjdGVkKTtcblx0XHR9LFxuXG5cdFx0XCJzZWxlY3RlZFwiOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdC8vIEFjY2Vzc2luZyB0aGlzIHByb3BlcnR5IG1ha2VzIHNlbGVjdGVkLWJ5LWRlZmF1bHRcblx0XHRcdC8vIG9wdGlvbnMgaW4gU2FmYXJpIHdvcmsgcHJvcGVybHlcblx0XHRcdGlmICggZWxlbS5wYXJlbnROb2RlICkge1xuXHRcdFx0XHRlbGVtLnBhcmVudE5vZGUuc2VsZWN0ZWRJbmRleDtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGVsZW0uc2VsZWN0ZWQgPT09IHRydWU7XG5cdFx0fSxcblxuXHRcdC8vIENvbnRlbnRzXG5cdFx0XCJlbXB0eVwiOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdC8vIGh0dHA6Ly93d3cudzMub3JnL1RSL3NlbGVjdG9ycy8jZW1wdHktcHNldWRvXG5cdFx0XHQvLyA6ZW1wdHkgaXMgbmVnYXRlZCBieSBlbGVtZW50ICgxKSBvciBjb250ZW50IG5vZGVzICh0ZXh0OiAzOyBjZGF0YTogNDsgZW50aXR5IHJlZjogNSksXG5cdFx0XHQvLyAgIGJ1dCBub3QgYnkgb3RoZXJzIChjb21tZW50OiA4OyBwcm9jZXNzaW5nIGluc3RydWN0aW9uOiA3OyBldGMuKVxuXHRcdFx0Ly8gbm9kZVR5cGUgPCA2IHdvcmtzIGJlY2F1c2UgYXR0cmlidXRlcyAoMikgZG8gbm90IGFwcGVhciBhcyBjaGlsZHJlblxuXHRcdFx0Zm9yICggZWxlbSA9IGVsZW0uZmlyc3RDaGlsZDsgZWxlbTsgZWxlbSA9IGVsZW0ubmV4dFNpYmxpbmcgKSB7XG5cdFx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA8IDYgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9LFxuXG5cdFx0XCJwYXJlbnRcIjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gIUV4cHIucHNldWRvc1tcImVtcHR5XCJdKCBlbGVtICk7XG5cdFx0fSxcblxuXHRcdC8vIEVsZW1lbnQvaW5wdXQgdHlwZXNcblx0XHRcImhlYWRlclwiOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiByaGVhZGVyLnRlc3QoIGVsZW0ubm9kZU5hbWUgKTtcblx0XHR9LFxuXG5cdFx0XCJpbnB1dFwiOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiByaW5wdXRzLnRlc3QoIGVsZW0ubm9kZU5hbWUgKTtcblx0XHR9LFxuXG5cdFx0XCJidXR0b25cIjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHR2YXIgbmFtZSA9IGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcblx0XHRcdHJldHVybiBuYW1lID09PSBcImlucHV0XCIgJiYgZWxlbS50eXBlID09PSBcImJ1dHRvblwiIHx8IG5hbWUgPT09IFwiYnV0dG9uXCI7XG5cdFx0fSxcblxuXHRcdFwidGV4dFwiOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHZhciBhdHRyO1xuXHRcdFx0cmV0dXJuIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gXCJpbnB1dFwiICYmXG5cdFx0XHRcdGVsZW0udHlwZSA9PT0gXCJ0ZXh0XCIgJiZcblxuXHRcdFx0XHQvLyBTdXBwb3J0OiBJRTw4XG5cdFx0XHRcdC8vIE5ldyBIVE1MNSBhdHRyaWJ1dGUgdmFsdWVzIChlLmcuLCBcInNlYXJjaFwiKSBhcHBlYXIgd2l0aCBlbGVtLnR5cGUgPT09IFwidGV4dFwiXG5cdFx0XHRcdCggKGF0dHIgPSBlbGVtLmdldEF0dHJpYnV0ZShcInR5cGVcIikpID09IG51bGwgfHwgYXR0ci50b0xvd2VyQ2FzZSgpID09PSBcInRleHRcIiApO1xuXHRcdH0sXG5cblx0XHQvLyBQb3NpdGlvbi1pbi1jb2xsZWN0aW9uXG5cdFx0XCJmaXJzdFwiOiBjcmVhdGVQb3NpdGlvbmFsUHNldWRvKGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIFsgMCBdO1xuXHRcdH0pLFxuXG5cdFx0XCJsYXN0XCI6IGNyZWF0ZVBvc2l0aW9uYWxQc2V1ZG8oZnVuY3Rpb24oIG1hdGNoSW5kZXhlcywgbGVuZ3RoICkge1xuXHRcdFx0cmV0dXJuIFsgbGVuZ3RoIC0gMSBdO1xuXHRcdH0pLFxuXG5cdFx0XCJlcVwiOiBjcmVhdGVQb3NpdGlvbmFsUHNldWRvKGZ1bmN0aW9uKCBtYXRjaEluZGV4ZXMsIGxlbmd0aCwgYXJndW1lbnQgKSB7XG5cdFx0XHRyZXR1cm4gWyBhcmd1bWVudCA8IDAgPyBhcmd1bWVudCArIGxlbmd0aCA6IGFyZ3VtZW50IF07XG5cdFx0fSksXG5cblx0XHRcImV2ZW5cIjogY3JlYXRlUG9zaXRpb25hbFBzZXVkbyhmdW5jdGlvbiggbWF0Y2hJbmRleGVzLCBsZW5ndGggKSB7XG5cdFx0XHR2YXIgaSA9IDA7XG5cdFx0XHRmb3IgKCA7IGkgPCBsZW5ndGg7IGkgKz0gMiApIHtcblx0XHRcdFx0bWF0Y2hJbmRleGVzLnB1c2goIGkgKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBtYXRjaEluZGV4ZXM7XG5cdFx0fSksXG5cblx0XHRcIm9kZFwiOiBjcmVhdGVQb3NpdGlvbmFsUHNldWRvKGZ1bmN0aW9uKCBtYXRjaEluZGV4ZXMsIGxlbmd0aCApIHtcblx0XHRcdHZhciBpID0gMTtcblx0XHRcdGZvciAoIDsgaSA8IGxlbmd0aDsgaSArPSAyICkge1xuXHRcdFx0XHRtYXRjaEluZGV4ZXMucHVzaCggaSApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG1hdGNoSW5kZXhlcztcblx0XHR9KSxcblxuXHRcdFwibHRcIjogY3JlYXRlUG9zaXRpb25hbFBzZXVkbyhmdW5jdGlvbiggbWF0Y2hJbmRleGVzLCBsZW5ndGgsIGFyZ3VtZW50ICkge1xuXHRcdFx0dmFyIGkgPSBhcmd1bWVudCA8IDAgPyBhcmd1bWVudCArIGxlbmd0aCA6IGFyZ3VtZW50O1xuXHRcdFx0Zm9yICggOyAtLWkgPj0gMDsgKSB7XG5cdFx0XHRcdG1hdGNoSW5kZXhlcy5wdXNoKCBpICk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gbWF0Y2hJbmRleGVzO1xuXHRcdH0pLFxuXG5cdFx0XCJndFwiOiBjcmVhdGVQb3NpdGlvbmFsUHNldWRvKGZ1bmN0aW9uKCBtYXRjaEluZGV4ZXMsIGxlbmd0aCwgYXJndW1lbnQgKSB7XG5cdFx0XHR2YXIgaSA9IGFyZ3VtZW50IDwgMCA/IGFyZ3VtZW50ICsgbGVuZ3RoIDogYXJndW1lbnQ7XG5cdFx0XHRmb3IgKCA7ICsraSA8IGxlbmd0aDsgKSB7XG5cdFx0XHRcdG1hdGNoSW5kZXhlcy5wdXNoKCBpICk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gbWF0Y2hJbmRleGVzO1xuXHRcdH0pXG5cdH1cbn07XG5cbkV4cHIucHNldWRvc1tcIm50aFwiXSA9IEV4cHIucHNldWRvc1tcImVxXCJdO1xuXG4vLyBBZGQgYnV0dG9uL2lucHV0IHR5cGUgcHNldWRvc1xuZm9yICggaSBpbiB7IHJhZGlvOiB0cnVlLCBjaGVja2JveDogdHJ1ZSwgZmlsZTogdHJ1ZSwgcGFzc3dvcmQ6IHRydWUsIGltYWdlOiB0cnVlIH0gKSB7XG5cdEV4cHIucHNldWRvc1sgaSBdID0gY3JlYXRlSW5wdXRQc2V1ZG8oIGkgKTtcbn1cbmZvciAoIGkgaW4geyBzdWJtaXQ6IHRydWUsIHJlc2V0OiB0cnVlIH0gKSB7XG5cdEV4cHIucHNldWRvc1sgaSBdID0gY3JlYXRlQnV0dG9uUHNldWRvKCBpICk7XG59XG5cbi8vIEVhc3kgQVBJIGZvciBjcmVhdGluZyBuZXcgc2V0RmlsdGVyc1xuZnVuY3Rpb24gc2V0RmlsdGVycygpIHt9XG5zZXRGaWx0ZXJzLnByb3RvdHlwZSA9IEV4cHIuZmlsdGVycyA9IEV4cHIucHNldWRvcztcbkV4cHIuc2V0RmlsdGVycyA9IG5ldyBzZXRGaWx0ZXJzKCk7XG5cbnRva2VuaXplID0gU2l6emxlLnRva2VuaXplID0gZnVuY3Rpb24oIHNlbGVjdG9yLCBwYXJzZU9ubHkgKSB7XG5cdHZhciBtYXRjaGVkLCBtYXRjaCwgdG9rZW5zLCB0eXBlLFxuXHRcdHNvRmFyLCBncm91cHMsIHByZUZpbHRlcnMsXG5cdFx0Y2FjaGVkID0gdG9rZW5DYWNoZVsgc2VsZWN0b3IgKyBcIiBcIiBdO1xuXG5cdGlmICggY2FjaGVkICkge1xuXHRcdHJldHVybiBwYXJzZU9ubHkgPyAwIDogY2FjaGVkLnNsaWNlKCAwICk7XG5cdH1cblxuXHRzb0ZhciA9IHNlbGVjdG9yO1xuXHRncm91cHMgPSBbXTtcblx0cHJlRmlsdGVycyA9IEV4cHIucHJlRmlsdGVyO1xuXG5cdHdoaWxlICggc29GYXIgKSB7XG5cblx0XHQvLyBDb21tYSBhbmQgZmlyc3QgcnVuXG5cdFx0aWYgKCAhbWF0Y2hlZCB8fCAobWF0Y2ggPSByY29tbWEuZXhlYyggc29GYXIgKSkgKSB7XG5cdFx0XHRpZiAoIG1hdGNoICkge1xuXHRcdFx0XHQvLyBEb24ndCBjb25zdW1lIHRyYWlsaW5nIGNvbW1hcyBhcyB2YWxpZFxuXHRcdFx0XHRzb0ZhciA9IHNvRmFyLnNsaWNlKCBtYXRjaFswXS5sZW5ndGggKSB8fCBzb0Zhcjtcblx0XHRcdH1cblx0XHRcdGdyb3Vwcy5wdXNoKCAodG9rZW5zID0gW10pICk7XG5cdFx0fVxuXG5cdFx0bWF0Y2hlZCA9IGZhbHNlO1xuXG5cdFx0Ly8gQ29tYmluYXRvcnNcblx0XHRpZiAoIChtYXRjaCA9IHJjb21iaW5hdG9ycy5leGVjKCBzb0ZhciApKSApIHtcblx0XHRcdG1hdGNoZWQgPSBtYXRjaC5zaGlmdCgpO1xuXHRcdFx0dG9rZW5zLnB1c2goe1xuXHRcdFx0XHR2YWx1ZTogbWF0Y2hlZCxcblx0XHRcdFx0Ly8gQ2FzdCBkZXNjZW5kYW50IGNvbWJpbmF0b3JzIHRvIHNwYWNlXG5cdFx0XHRcdHR5cGU6IG1hdGNoWzBdLnJlcGxhY2UoIHJ0cmltLCBcIiBcIiApXG5cdFx0XHR9KTtcblx0XHRcdHNvRmFyID0gc29GYXIuc2xpY2UoIG1hdGNoZWQubGVuZ3RoICk7XG5cdFx0fVxuXG5cdFx0Ly8gRmlsdGVyc1xuXHRcdGZvciAoIHR5cGUgaW4gRXhwci5maWx0ZXIgKSB7XG5cdFx0XHRpZiAoIChtYXRjaCA9IG1hdGNoRXhwclsgdHlwZSBdLmV4ZWMoIHNvRmFyICkpICYmICghcHJlRmlsdGVyc1sgdHlwZSBdIHx8XG5cdFx0XHRcdChtYXRjaCA9IHByZUZpbHRlcnNbIHR5cGUgXSggbWF0Y2ggKSkpICkge1xuXHRcdFx0XHRtYXRjaGVkID0gbWF0Y2guc2hpZnQoKTtcblx0XHRcdFx0dG9rZW5zLnB1c2goe1xuXHRcdFx0XHRcdHZhbHVlOiBtYXRjaGVkLFxuXHRcdFx0XHRcdHR5cGU6IHR5cGUsXG5cdFx0XHRcdFx0bWF0Y2hlczogbWF0Y2hcblx0XHRcdFx0fSk7XG5cdFx0XHRcdHNvRmFyID0gc29GYXIuc2xpY2UoIG1hdGNoZWQubGVuZ3RoICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKCAhbWF0Y2hlZCApIHtcblx0XHRcdGJyZWFrO1xuXHRcdH1cblx0fVxuXG5cdC8vIFJldHVybiB0aGUgbGVuZ3RoIG9mIHRoZSBpbnZhbGlkIGV4Y2Vzc1xuXHQvLyBpZiB3ZSdyZSBqdXN0IHBhcnNpbmdcblx0Ly8gT3RoZXJ3aXNlLCB0aHJvdyBhbiBlcnJvciBvciByZXR1cm4gdG9rZW5zXG5cdHJldHVybiBwYXJzZU9ubHkgP1xuXHRcdHNvRmFyLmxlbmd0aCA6XG5cdFx0c29GYXIgP1xuXHRcdFx0U2l6emxlLmVycm9yKCBzZWxlY3RvciApIDpcblx0XHRcdC8vIENhY2hlIHRoZSB0b2tlbnNcblx0XHRcdHRva2VuQ2FjaGUoIHNlbGVjdG9yLCBncm91cHMgKS5zbGljZSggMCApO1xufTtcblxuZnVuY3Rpb24gdG9TZWxlY3RvciggdG9rZW5zICkge1xuXHR2YXIgaSA9IDAsXG5cdFx0bGVuID0gdG9rZW5zLmxlbmd0aCxcblx0XHRzZWxlY3RvciA9IFwiXCI7XG5cdGZvciAoIDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdHNlbGVjdG9yICs9IHRva2Vuc1tpXS52YWx1ZTtcblx0fVxuXHRyZXR1cm4gc2VsZWN0b3I7XG59XG5cbmZ1bmN0aW9uIGFkZENvbWJpbmF0b3IoIG1hdGNoZXIsIGNvbWJpbmF0b3IsIGJhc2UgKSB7XG5cdHZhciBkaXIgPSBjb21iaW5hdG9yLmRpcixcblx0XHRjaGVja05vbkVsZW1lbnRzID0gYmFzZSAmJiBkaXIgPT09IFwicGFyZW50Tm9kZVwiLFxuXHRcdGRvbmVOYW1lID0gZG9uZSsrO1xuXG5cdHJldHVybiBjb21iaW5hdG9yLmZpcnN0ID9cblx0XHQvLyBDaGVjayBhZ2FpbnN0IGNsb3Nlc3QgYW5jZXN0b3IvcHJlY2VkaW5nIGVsZW1lbnRcblx0XHRmdW5jdGlvbiggZWxlbSwgY29udGV4dCwgeG1sICkge1xuXHRcdFx0d2hpbGUgKCAoZWxlbSA9IGVsZW1bIGRpciBdKSApIHtcblx0XHRcdFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSAxIHx8IGNoZWNrTm9uRWxlbWVudHMgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIG1hdGNoZXIoIGVsZW0sIGNvbnRleHQsIHhtbCApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSA6XG5cblx0XHQvLyBDaGVjayBhZ2FpbnN0IGFsbCBhbmNlc3Rvci9wcmVjZWRpbmcgZWxlbWVudHNcblx0XHRmdW5jdGlvbiggZWxlbSwgY29udGV4dCwgeG1sICkge1xuXHRcdFx0dmFyIG9sZENhY2hlLCB1bmlxdWVDYWNoZSwgb3V0ZXJDYWNoZSxcblx0XHRcdFx0bmV3Q2FjaGUgPSBbIGRpcnJ1bnMsIGRvbmVOYW1lIF07XG5cblx0XHRcdC8vIFdlIGNhbid0IHNldCBhcmJpdHJhcnkgZGF0YSBvbiBYTUwgbm9kZXMsIHNvIHRoZXkgZG9uJ3QgYmVuZWZpdCBmcm9tIGNvbWJpbmF0b3IgY2FjaGluZ1xuXHRcdFx0aWYgKCB4bWwgKSB7XG5cdFx0XHRcdHdoaWxlICggKGVsZW0gPSBlbGVtWyBkaXIgXSkgKSB7XG5cdFx0XHRcdFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSAxIHx8IGNoZWNrTm9uRWxlbWVudHMgKSB7XG5cdFx0XHRcdFx0XHRpZiAoIG1hdGNoZXIoIGVsZW0sIGNvbnRleHQsIHhtbCApICkge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHdoaWxlICggKGVsZW0gPSBlbGVtWyBkaXIgXSkgKSB7XG5cdFx0XHRcdFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSAxIHx8IGNoZWNrTm9uRWxlbWVudHMgKSB7XG5cdFx0XHRcdFx0XHRvdXRlckNhY2hlID0gZWxlbVsgZXhwYW5kbyBdIHx8IChlbGVtWyBleHBhbmRvIF0gPSB7fSk7XG5cblx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDw5IG9ubHlcblx0XHRcdFx0XHRcdC8vIERlZmVuZCBhZ2FpbnN0IGNsb25lZCBhdHRyb3BlcnRpZXMgKGpRdWVyeSBnaC0xNzA5KVxuXHRcdFx0XHRcdFx0dW5pcXVlQ2FjaGUgPSBvdXRlckNhY2hlWyBlbGVtLnVuaXF1ZUlEIF0gfHwgKG91dGVyQ2FjaGVbIGVsZW0udW5pcXVlSUQgXSA9IHt9KTtcblxuXHRcdFx0XHRcdFx0aWYgKCAob2xkQ2FjaGUgPSB1bmlxdWVDYWNoZVsgZGlyIF0pICYmXG5cdFx0XHRcdFx0XHRcdG9sZENhY2hlWyAwIF0gPT09IGRpcnJ1bnMgJiYgb2xkQ2FjaGVbIDEgXSA9PT0gZG9uZU5hbWUgKSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gQXNzaWduIHRvIG5ld0NhY2hlIHNvIHJlc3VsdHMgYmFjay1wcm9wYWdhdGUgdG8gcHJldmlvdXMgZWxlbWVudHNcblx0XHRcdFx0XHRcdFx0cmV0dXJuIChuZXdDYWNoZVsgMiBdID0gb2xkQ2FjaGVbIDIgXSk7XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHQvLyBSZXVzZSBuZXdjYWNoZSBzbyByZXN1bHRzIGJhY2stcHJvcGFnYXRlIHRvIHByZXZpb3VzIGVsZW1lbnRzXG5cdFx0XHRcdFx0XHRcdHVuaXF1ZUNhY2hlWyBkaXIgXSA9IG5ld0NhY2hlO1xuXG5cdFx0XHRcdFx0XHRcdC8vIEEgbWF0Y2ggbWVhbnMgd2UncmUgZG9uZTsgYSBmYWlsIG1lYW5zIHdlIGhhdmUgdG8ga2VlcCBjaGVja2luZ1xuXHRcdFx0XHRcdFx0XHRpZiAoIChuZXdDYWNoZVsgMiBdID0gbWF0Y2hlciggZWxlbSwgY29udGV4dCwgeG1sICkpICkge1xuXHRcdFx0XHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fTtcbn1cblxuZnVuY3Rpb24gZWxlbWVudE1hdGNoZXIoIG1hdGNoZXJzICkge1xuXHRyZXR1cm4gbWF0Y2hlcnMubGVuZ3RoID4gMSA/XG5cdFx0ZnVuY3Rpb24oIGVsZW0sIGNvbnRleHQsIHhtbCApIHtcblx0XHRcdHZhciBpID0gbWF0Y2hlcnMubGVuZ3RoO1xuXHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdGlmICggIW1hdGNoZXJzW2ldKCBlbGVtLCBjb250ZXh0LCB4bWwgKSApIHtcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH0gOlxuXHRcdG1hdGNoZXJzWzBdO1xufVxuXG5mdW5jdGlvbiBtdWx0aXBsZUNvbnRleHRzKCBzZWxlY3RvciwgY29udGV4dHMsIHJlc3VsdHMgKSB7XG5cdHZhciBpID0gMCxcblx0XHRsZW4gPSBjb250ZXh0cy5sZW5ndGg7XG5cdGZvciAoIDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdFNpenpsZSggc2VsZWN0b3IsIGNvbnRleHRzW2ldLCByZXN1bHRzICk7XG5cdH1cblx0cmV0dXJuIHJlc3VsdHM7XG59XG5cbmZ1bmN0aW9uIGNvbmRlbnNlKCB1bm1hdGNoZWQsIG1hcCwgZmlsdGVyLCBjb250ZXh0LCB4bWwgKSB7XG5cdHZhciBlbGVtLFxuXHRcdG5ld1VubWF0Y2hlZCA9IFtdLFxuXHRcdGkgPSAwLFxuXHRcdGxlbiA9IHVubWF0Y2hlZC5sZW5ndGgsXG5cdFx0bWFwcGVkID0gbWFwICE9IG51bGw7XG5cblx0Zm9yICggOyBpIDwgbGVuOyBpKysgKSB7XG5cdFx0aWYgKCAoZWxlbSA9IHVubWF0Y2hlZFtpXSkgKSB7XG5cdFx0XHRpZiAoICFmaWx0ZXIgfHwgZmlsdGVyKCBlbGVtLCBjb250ZXh0LCB4bWwgKSApIHtcblx0XHRcdFx0bmV3VW5tYXRjaGVkLnB1c2goIGVsZW0gKTtcblx0XHRcdFx0aWYgKCBtYXBwZWQgKSB7XG5cdFx0XHRcdFx0bWFwLnB1c2goIGkgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiBuZXdVbm1hdGNoZWQ7XG59XG5cbmZ1bmN0aW9uIHNldE1hdGNoZXIoIHByZUZpbHRlciwgc2VsZWN0b3IsIG1hdGNoZXIsIHBvc3RGaWx0ZXIsIHBvc3RGaW5kZXIsIHBvc3RTZWxlY3RvciApIHtcblx0aWYgKCBwb3N0RmlsdGVyICYmICFwb3N0RmlsdGVyWyBleHBhbmRvIF0gKSB7XG5cdFx0cG9zdEZpbHRlciA9IHNldE1hdGNoZXIoIHBvc3RGaWx0ZXIgKTtcblx0fVxuXHRpZiAoIHBvc3RGaW5kZXIgJiYgIXBvc3RGaW5kZXJbIGV4cGFuZG8gXSApIHtcblx0XHRwb3N0RmluZGVyID0gc2V0TWF0Y2hlciggcG9zdEZpbmRlciwgcG9zdFNlbGVjdG9yICk7XG5cdH1cblx0cmV0dXJuIG1hcmtGdW5jdGlvbihmdW5jdGlvbiggc2VlZCwgcmVzdWx0cywgY29udGV4dCwgeG1sICkge1xuXHRcdHZhciB0ZW1wLCBpLCBlbGVtLFxuXHRcdFx0cHJlTWFwID0gW10sXG5cdFx0XHRwb3N0TWFwID0gW10sXG5cdFx0XHRwcmVleGlzdGluZyA9IHJlc3VsdHMubGVuZ3RoLFxuXG5cdFx0XHQvLyBHZXQgaW5pdGlhbCBlbGVtZW50cyBmcm9tIHNlZWQgb3IgY29udGV4dFxuXHRcdFx0ZWxlbXMgPSBzZWVkIHx8IG11bHRpcGxlQ29udGV4dHMoIHNlbGVjdG9yIHx8IFwiKlwiLCBjb250ZXh0Lm5vZGVUeXBlID8gWyBjb250ZXh0IF0gOiBjb250ZXh0LCBbXSApLFxuXG5cdFx0XHQvLyBQcmVmaWx0ZXIgdG8gZ2V0IG1hdGNoZXIgaW5wdXQsIHByZXNlcnZpbmcgYSBtYXAgZm9yIHNlZWQtcmVzdWx0cyBzeW5jaHJvbml6YXRpb25cblx0XHRcdG1hdGNoZXJJbiA9IHByZUZpbHRlciAmJiAoIHNlZWQgfHwgIXNlbGVjdG9yICkgP1xuXHRcdFx0XHRjb25kZW5zZSggZWxlbXMsIHByZU1hcCwgcHJlRmlsdGVyLCBjb250ZXh0LCB4bWwgKSA6XG5cdFx0XHRcdGVsZW1zLFxuXG5cdFx0XHRtYXRjaGVyT3V0ID0gbWF0Y2hlciA/XG5cdFx0XHRcdC8vIElmIHdlIGhhdmUgYSBwb3N0RmluZGVyLCBvciBmaWx0ZXJlZCBzZWVkLCBvciBub24tc2VlZCBwb3N0RmlsdGVyIG9yIHByZWV4aXN0aW5nIHJlc3VsdHMsXG5cdFx0XHRcdHBvc3RGaW5kZXIgfHwgKCBzZWVkID8gcHJlRmlsdGVyIDogcHJlZXhpc3RpbmcgfHwgcG9zdEZpbHRlciApID9cblxuXHRcdFx0XHRcdC8vIC4uLmludGVybWVkaWF0ZSBwcm9jZXNzaW5nIGlzIG5lY2Vzc2FyeVxuXHRcdFx0XHRcdFtdIDpcblxuXHRcdFx0XHRcdC8vIC4uLm90aGVyd2lzZSB1c2UgcmVzdWx0cyBkaXJlY3RseVxuXHRcdFx0XHRcdHJlc3VsdHMgOlxuXHRcdFx0XHRtYXRjaGVySW47XG5cblx0XHQvLyBGaW5kIHByaW1hcnkgbWF0Y2hlc1xuXHRcdGlmICggbWF0Y2hlciApIHtcblx0XHRcdG1hdGNoZXIoIG1hdGNoZXJJbiwgbWF0Y2hlck91dCwgY29udGV4dCwgeG1sICk7XG5cdFx0fVxuXG5cdFx0Ly8gQXBwbHkgcG9zdEZpbHRlclxuXHRcdGlmICggcG9zdEZpbHRlciApIHtcblx0XHRcdHRlbXAgPSBjb25kZW5zZSggbWF0Y2hlck91dCwgcG9zdE1hcCApO1xuXHRcdFx0cG9zdEZpbHRlciggdGVtcCwgW10sIGNvbnRleHQsIHhtbCApO1xuXG5cdFx0XHQvLyBVbi1tYXRjaCBmYWlsaW5nIGVsZW1lbnRzIGJ5IG1vdmluZyB0aGVtIGJhY2sgdG8gbWF0Y2hlckluXG5cdFx0XHRpID0gdGVtcC5sZW5ndGg7XG5cdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0aWYgKCAoZWxlbSA9IHRlbXBbaV0pICkge1xuXHRcdFx0XHRcdG1hdGNoZXJPdXRbIHBvc3RNYXBbaV0gXSA9ICEobWF0Y2hlckluWyBwb3N0TWFwW2ldIF0gPSBlbGVtKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmICggc2VlZCApIHtcblx0XHRcdGlmICggcG9zdEZpbmRlciB8fCBwcmVGaWx0ZXIgKSB7XG5cdFx0XHRcdGlmICggcG9zdEZpbmRlciApIHtcblx0XHRcdFx0XHQvLyBHZXQgdGhlIGZpbmFsIG1hdGNoZXJPdXQgYnkgY29uZGVuc2luZyB0aGlzIGludGVybWVkaWF0ZSBpbnRvIHBvc3RGaW5kZXIgY29udGV4dHNcblx0XHRcdFx0XHR0ZW1wID0gW107XG5cdFx0XHRcdFx0aSA9IG1hdGNoZXJPdXQubGVuZ3RoO1xuXHRcdFx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRcdFx0aWYgKCAoZWxlbSA9IG1hdGNoZXJPdXRbaV0pICkge1xuXHRcdFx0XHRcdFx0XHQvLyBSZXN0b3JlIG1hdGNoZXJJbiBzaW5jZSBlbGVtIGlzIG5vdCB5ZXQgYSBmaW5hbCBtYXRjaFxuXHRcdFx0XHRcdFx0XHR0ZW1wLnB1c2goIChtYXRjaGVySW5baV0gPSBlbGVtKSApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRwb3N0RmluZGVyKCBudWxsLCAobWF0Y2hlck91dCA9IFtdKSwgdGVtcCwgeG1sICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBNb3ZlIG1hdGNoZWQgZWxlbWVudHMgZnJvbSBzZWVkIHRvIHJlc3VsdHMgdG8ga2VlcCB0aGVtIHN5bmNocm9uaXplZFxuXHRcdFx0XHRpID0gbWF0Y2hlck91dC5sZW5ndGg7XG5cdFx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRcdGlmICggKGVsZW0gPSBtYXRjaGVyT3V0W2ldKSAmJlxuXHRcdFx0XHRcdFx0KHRlbXAgPSBwb3N0RmluZGVyID8gaW5kZXhPZiggc2VlZCwgZWxlbSApIDogcHJlTWFwW2ldKSA+IC0xICkge1xuXG5cdFx0XHRcdFx0XHRzZWVkW3RlbXBdID0gIShyZXN1bHRzW3RlbXBdID0gZWxlbSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHQvLyBBZGQgZWxlbWVudHMgdG8gcmVzdWx0cywgdGhyb3VnaCBwb3N0RmluZGVyIGlmIGRlZmluZWRcblx0XHR9IGVsc2Uge1xuXHRcdFx0bWF0Y2hlck91dCA9IGNvbmRlbnNlKFxuXHRcdFx0XHRtYXRjaGVyT3V0ID09PSByZXN1bHRzID9cblx0XHRcdFx0XHRtYXRjaGVyT3V0LnNwbGljZSggcHJlZXhpc3RpbmcsIG1hdGNoZXJPdXQubGVuZ3RoICkgOlxuXHRcdFx0XHRcdG1hdGNoZXJPdXRcblx0XHRcdCk7XG5cdFx0XHRpZiAoIHBvc3RGaW5kZXIgKSB7XG5cdFx0XHRcdHBvc3RGaW5kZXIoIG51bGwsIHJlc3VsdHMsIG1hdGNoZXJPdXQsIHhtbCApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cHVzaC5hcHBseSggcmVzdWx0cywgbWF0Y2hlck91dCApO1xuXHRcdFx0fVxuXHRcdH1cblx0fSk7XG59XG5cbmZ1bmN0aW9uIG1hdGNoZXJGcm9tVG9rZW5zKCB0b2tlbnMgKSB7XG5cdHZhciBjaGVja0NvbnRleHQsIG1hdGNoZXIsIGosXG5cdFx0bGVuID0gdG9rZW5zLmxlbmd0aCxcblx0XHRsZWFkaW5nUmVsYXRpdmUgPSBFeHByLnJlbGF0aXZlWyB0b2tlbnNbMF0udHlwZSBdLFxuXHRcdGltcGxpY2l0UmVsYXRpdmUgPSBsZWFkaW5nUmVsYXRpdmUgfHwgRXhwci5yZWxhdGl2ZVtcIiBcIl0sXG5cdFx0aSA9IGxlYWRpbmdSZWxhdGl2ZSA/IDEgOiAwLFxuXG5cdFx0Ly8gVGhlIGZvdW5kYXRpb25hbCBtYXRjaGVyIGVuc3VyZXMgdGhhdCBlbGVtZW50cyBhcmUgcmVhY2hhYmxlIGZyb20gdG9wLWxldmVsIGNvbnRleHQocylcblx0XHRtYXRjaENvbnRleHQgPSBhZGRDb21iaW5hdG9yKCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiBlbGVtID09PSBjaGVja0NvbnRleHQ7XG5cdFx0fSwgaW1wbGljaXRSZWxhdGl2ZSwgdHJ1ZSApLFxuXHRcdG1hdGNoQW55Q29udGV4dCA9IGFkZENvbWJpbmF0b3IoIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuIGluZGV4T2YoIGNoZWNrQ29udGV4dCwgZWxlbSApID4gLTE7XG5cdFx0fSwgaW1wbGljaXRSZWxhdGl2ZSwgdHJ1ZSApLFxuXHRcdG1hdGNoZXJzID0gWyBmdW5jdGlvbiggZWxlbSwgY29udGV4dCwgeG1sICkge1xuXHRcdFx0dmFyIHJldCA9ICggIWxlYWRpbmdSZWxhdGl2ZSAmJiAoIHhtbCB8fCBjb250ZXh0ICE9PSBvdXRlcm1vc3RDb250ZXh0ICkgKSB8fCAoXG5cdFx0XHRcdChjaGVja0NvbnRleHQgPSBjb250ZXh0KS5ub2RlVHlwZSA/XG5cdFx0XHRcdFx0bWF0Y2hDb250ZXh0KCBlbGVtLCBjb250ZXh0LCB4bWwgKSA6XG5cdFx0XHRcdFx0bWF0Y2hBbnlDb250ZXh0KCBlbGVtLCBjb250ZXh0LCB4bWwgKSApO1xuXHRcdFx0Ly8gQXZvaWQgaGFuZ2luZyBvbnRvIGVsZW1lbnQgKGlzc3VlICMyOTkpXG5cdFx0XHRjaGVja0NvbnRleHQgPSBudWxsO1xuXHRcdFx0cmV0dXJuIHJldDtcblx0XHR9IF07XG5cblx0Zm9yICggOyBpIDwgbGVuOyBpKysgKSB7XG5cdFx0aWYgKCAobWF0Y2hlciA9IEV4cHIucmVsYXRpdmVbIHRva2Vuc1tpXS50eXBlIF0pICkge1xuXHRcdFx0bWF0Y2hlcnMgPSBbIGFkZENvbWJpbmF0b3IoZWxlbWVudE1hdGNoZXIoIG1hdGNoZXJzICksIG1hdGNoZXIpIF07XG5cdFx0fSBlbHNlIHtcblx0XHRcdG1hdGNoZXIgPSBFeHByLmZpbHRlclsgdG9rZW5zW2ldLnR5cGUgXS5hcHBseSggbnVsbCwgdG9rZW5zW2ldLm1hdGNoZXMgKTtcblxuXHRcdFx0Ly8gUmV0dXJuIHNwZWNpYWwgdXBvbiBzZWVpbmcgYSBwb3NpdGlvbmFsIG1hdGNoZXJcblx0XHRcdGlmICggbWF0Y2hlclsgZXhwYW5kbyBdICkge1xuXHRcdFx0XHQvLyBGaW5kIHRoZSBuZXh0IHJlbGF0aXZlIG9wZXJhdG9yIChpZiBhbnkpIGZvciBwcm9wZXIgaGFuZGxpbmdcblx0XHRcdFx0aiA9ICsraTtcblx0XHRcdFx0Zm9yICggOyBqIDwgbGVuOyBqKysgKSB7XG5cdFx0XHRcdFx0aWYgKCBFeHByLnJlbGF0aXZlWyB0b2tlbnNbal0udHlwZSBdICkge1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBzZXRNYXRjaGVyKFxuXHRcdFx0XHRcdGkgPiAxICYmIGVsZW1lbnRNYXRjaGVyKCBtYXRjaGVycyApLFxuXHRcdFx0XHRcdGkgPiAxICYmIHRvU2VsZWN0b3IoXG5cdFx0XHRcdFx0XHQvLyBJZiB0aGUgcHJlY2VkaW5nIHRva2VuIHdhcyBhIGRlc2NlbmRhbnQgY29tYmluYXRvciwgaW5zZXJ0IGFuIGltcGxpY2l0IGFueS1lbGVtZW50IGAqYFxuXHRcdFx0XHRcdFx0dG9rZW5zLnNsaWNlKCAwLCBpIC0gMSApLmNvbmNhdCh7IHZhbHVlOiB0b2tlbnNbIGkgLSAyIF0udHlwZSA9PT0gXCIgXCIgPyBcIipcIiA6IFwiXCIgfSlcblx0XHRcdFx0XHQpLnJlcGxhY2UoIHJ0cmltLCBcIiQxXCIgKSxcblx0XHRcdFx0XHRtYXRjaGVyLFxuXHRcdFx0XHRcdGkgPCBqICYmIG1hdGNoZXJGcm9tVG9rZW5zKCB0b2tlbnMuc2xpY2UoIGksIGogKSApLFxuXHRcdFx0XHRcdGogPCBsZW4gJiYgbWF0Y2hlckZyb21Ub2tlbnMoICh0b2tlbnMgPSB0b2tlbnMuc2xpY2UoIGogKSkgKSxcblx0XHRcdFx0XHRqIDwgbGVuICYmIHRvU2VsZWN0b3IoIHRva2VucyApXG5cdFx0XHRcdCk7XG5cdFx0XHR9XG5cdFx0XHRtYXRjaGVycy5wdXNoKCBtYXRjaGVyICk7XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIGVsZW1lbnRNYXRjaGVyKCBtYXRjaGVycyApO1xufVxuXG5mdW5jdGlvbiBtYXRjaGVyRnJvbUdyb3VwTWF0Y2hlcnMoIGVsZW1lbnRNYXRjaGVycywgc2V0TWF0Y2hlcnMgKSB7XG5cdHZhciBieVNldCA9IHNldE1hdGNoZXJzLmxlbmd0aCA+IDAsXG5cdFx0YnlFbGVtZW50ID0gZWxlbWVudE1hdGNoZXJzLmxlbmd0aCA+IDAsXG5cdFx0c3VwZXJNYXRjaGVyID0gZnVuY3Rpb24oIHNlZWQsIGNvbnRleHQsIHhtbCwgcmVzdWx0cywgb3V0ZXJtb3N0ICkge1xuXHRcdFx0dmFyIGVsZW0sIGosIG1hdGNoZXIsXG5cdFx0XHRcdG1hdGNoZWRDb3VudCA9IDAsXG5cdFx0XHRcdGkgPSBcIjBcIixcblx0XHRcdFx0dW5tYXRjaGVkID0gc2VlZCAmJiBbXSxcblx0XHRcdFx0c2V0TWF0Y2hlZCA9IFtdLFxuXHRcdFx0XHRjb250ZXh0QmFja3VwID0gb3V0ZXJtb3N0Q29udGV4dCxcblx0XHRcdFx0Ly8gV2UgbXVzdCBhbHdheXMgaGF2ZSBlaXRoZXIgc2VlZCBlbGVtZW50cyBvciBvdXRlcm1vc3QgY29udGV4dFxuXHRcdFx0XHRlbGVtcyA9IHNlZWQgfHwgYnlFbGVtZW50ICYmIEV4cHIuZmluZFtcIlRBR1wiXSggXCIqXCIsIG91dGVybW9zdCApLFxuXHRcdFx0XHQvLyBVc2UgaW50ZWdlciBkaXJydW5zIGlmZiB0aGlzIGlzIHRoZSBvdXRlcm1vc3QgbWF0Y2hlclxuXHRcdFx0XHRkaXJydW5zVW5pcXVlID0gKGRpcnJ1bnMgKz0gY29udGV4dEJhY2t1cCA9PSBudWxsID8gMSA6IE1hdGgucmFuZG9tKCkgfHwgMC4xKSxcblx0XHRcdFx0bGVuID0gZWxlbXMubGVuZ3RoO1xuXG5cdFx0XHRpZiAoIG91dGVybW9zdCApIHtcblx0XHRcdFx0b3V0ZXJtb3N0Q29udGV4dCA9IGNvbnRleHQgPT09IGRvY3VtZW50IHx8IGNvbnRleHQgfHwgb3V0ZXJtb3N0O1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBBZGQgZWxlbWVudHMgcGFzc2luZyBlbGVtZW50TWF0Y2hlcnMgZGlyZWN0bHkgdG8gcmVzdWx0c1xuXHRcdFx0Ly8gU3VwcG9ydDogSUU8OSwgU2FmYXJpXG5cdFx0XHQvLyBUb2xlcmF0ZSBOb2RlTGlzdCBwcm9wZXJ0aWVzIChJRTogXCJsZW5ndGhcIjsgU2FmYXJpOiA8bnVtYmVyPikgbWF0Y2hpbmcgZWxlbWVudHMgYnkgaWRcblx0XHRcdGZvciAoIDsgaSAhPT0gbGVuICYmIChlbGVtID0gZWxlbXNbaV0pICE9IG51bGw7IGkrKyApIHtcblx0XHRcdFx0aWYgKCBieUVsZW1lbnQgJiYgZWxlbSApIHtcblx0XHRcdFx0XHRqID0gMDtcblx0XHRcdFx0XHRpZiAoICFjb250ZXh0ICYmIGVsZW0ub3duZXJEb2N1bWVudCAhPT0gZG9jdW1lbnQgKSB7XG5cdFx0XHRcdFx0XHRzZXREb2N1bWVudCggZWxlbSApO1xuXHRcdFx0XHRcdFx0eG1sID0gIWRvY3VtZW50SXNIVE1MO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHR3aGlsZSAoIChtYXRjaGVyID0gZWxlbWVudE1hdGNoZXJzW2orK10pICkge1xuXHRcdFx0XHRcdFx0aWYgKCBtYXRjaGVyKCBlbGVtLCBjb250ZXh0IHx8IGRvY3VtZW50LCB4bWwpICkge1xuXHRcdFx0XHRcdFx0XHRyZXN1bHRzLnB1c2goIGVsZW0gKTtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmICggb3V0ZXJtb3N0ICkge1xuXHRcdFx0XHRcdFx0ZGlycnVucyA9IGRpcnJ1bnNVbmlxdWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gVHJhY2sgdW5tYXRjaGVkIGVsZW1lbnRzIGZvciBzZXQgZmlsdGVyc1xuXHRcdFx0XHRpZiAoIGJ5U2V0ICkge1xuXHRcdFx0XHRcdC8vIFRoZXkgd2lsbCBoYXZlIGdvbmUgdGhyb3VnaCBhbGwgcG9zc2libGUgbWF0Y2hlcnNcblx0XHRcdFx0XHRpZiAoIChlbGVtID0gIW1hdGNoZXIgJiYgZWxlbSkgKSB7XG5cdFx0XHRcdFx0XHRtYXRjaGVkQ291bnQtLTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBMZW5ndGhlbiB0aGUgYXJyYXkgZm9yIGV2ZXJ5IGVsZW1lbnQsIG1hdGNoZWQgb3Igbm90XG5cdFx0XHRcdFx0aWYgKCBzZWVkICkge1xuXHRcdFx0XHRcdFx0dW5tYXRjaGVkLnB1c2goIGVsZW0gKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gYGlgIGlzIG5vdyB0aGUgY291bnQgb2YgZWxlbWVudHMgdmlzaXRlZCBhYm92ZSwgYW5kIGFkZGluZyBpdCB0byBgbWF0Y2hlZENvdW50YFxuXHRcdFx0Ly8gbWFrZXMgdGhlIGxhdHRlciBub25uZWdhdGl2ZS5cblx0XHRcdG1hdGNoZWRDb3VudCArPSBpO1xuXG5cdFx0XHQvLyBBcHBseSBzZXQgZmlsdGVycyB0byB1bm1hdGNoZWQgZWxlbWVudHNcblx0XHRcdC8vIE5PVEU6IFRoaXMgY2FuIGJlIHNraXBwZWQgaWYgdGhlcmUgYXJlIG5vIHVubWF0Y2hlZCBlbGVtZW50cyAoaS5lLiwgYG1hdGNoZWRDb3VudGBcblx0XHRcdC8vIGVxdWFscyBgaWApLCB1bmxlc3Mgd2UgZGlkbid0IHZpc2l0IF9hbnlfIGVsZW1lbnRzIGluIHRoZSBhYm92ZSBsb29wIGJlY2F1c2Ugd2UgaGF2ZVxuXHRcdFx0Ly8gbm8gZWxlbWVudCBtYXRjaGVycyBhbmQgbm8gc2VlZC5cblx0XHRcdC8vIEluY3JlbWVudGluZyBhbiBpbml0aWFsbHktc3RyaW5nIFwiMFwiIGBpYCBhbGxvd3MgYGlgIHRvIHJlbWFpbiBhIHN0cmluZyBvbmx5IGluIHRoYXRcblx0XHRcdC8vIGNhc2UsIHdoaWNoIHdpbGwgcmVzdWx0IGluIGEgXCIwMFwiIGBtYXRjaGVkQ291bnRgIHRoYXQgZGlmZmVycyBmcm9tIGBpYCBidXQgaXMgYWxzb1xuXHRcdFx0Ly8gbnVtZXJpY2FsbHkgemVyby5cblx0XHRcdGlmICggYnlTZXQgJiYgaSAhPT0gbWF0Y2hlZENvdW50ICkge1xuXHRcdFx0XHRqID0gMDtcblx0XHRcdFx0d2hpbGUgKCAobWF0Y2hlciA9IHNldE1hdGNoZXJzW2orK10pICkge1xuXHRcdFx0XHRcdG1hdGNoZXIoIHVubWF0Y2hlZCwgc2V0TWF0Y2hlZCwgY29udGV4dCwgeG1sICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoIHNlZWQgKSB7XG5cdFx0XHRcdFx0Ly8gUmVpbnRlZ3JhdGUgZWxlbWVudCBtYXRjaGVzIHRvIGVsaW1pbmF0ZSB0aGUgbmVlZCBmb3Igc29ydGluZ1xuXHRcdFx0XHRcdGlmICggbWF0Y2hlZENvdW50ID4gMCApIHtcblx0XHRcdFx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRcdFx0XHRpZiAoICEodW5tYXRjaGVkW2ldIHx8IHNldE1hdGNoZWRbaV0pICkge1xuXHRcdFx0XHRcdFx0XHRcdHNldE1hdGNoZWRbaV0gPSBwb3AuY2FsbCggcmVzdWx0cyApO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gRGlzY2FyZCBpbmRleCBwbGFjZWhvbGRlciB2YWx1ZXMgdG8gZ2V0IG9ubHkgYWN0dWFsIG1hdGNoZXNcblx0XHRcdFx0XHRzZXRNYXRjaGVkID0gY29uZGVuc2UoIHNldE1hdGNoZWQgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIEFkZCBtYXRjaGVzIHRvIHJlc3VsdHNcblx0XHRcdFx0cHVzaC5hcHBseSggcmVzdWx0cywgc2V0TWF0Y2hlZCApO1xuXG5cdFx0XHRcdC8vIFNlZWRsZXNzIHNldCBtYXRjaGVzIHN1Y2NlZWRpbmcgbXVsdGlwbGUgc3VjY2Vzc2Z1bCBtYXRjaGVycyBzdGlwdWxhdGUgc29ydGluZ1xuXHRcdFx0XHRpZiAoIG91dGVybW9zdCAmJiAhc2VlZCAmJiBzZXRNYXRjaGVkLmxlbmd0aCA+IDAgJiZcblx0XHRcdFx0XHQoIG1hdGNoZWRDb3VudCArIHNldE1hdGNoZXJzLmxlbmd0aCApID4gMSApIHtcblxuXHRcdFx0XHRcdFNpenpsZS51bmlxdWVTb3J0KCByZXN1bHRzICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gT3ZlcnJpZGUgbWFuaXB1bGF0aW9uIG9mIGdsb2JhbHMgYnkgbmVzdGVkIG1hdGNoZXJzXG5cdFx0XHRpZiAoIG91dGVybW9zdCApIHtcblx0XHRcdFx0ZGlycnVucyA9IGRpcnJ1bnNVbmlxdWU7XG5cdFx0XHRcdG91dGVybW9zdENvbnRleHQgPSBjb250ZXh0QmFja3VwO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdW5tYXRjaGVkO1xuXHRcdH07XG5cblx0cmV0dXJuIGJ5U2V0ID9cblx0XHRtYXJrRnVuY3Rpb24oIHN1cGVyTWF0Y2hlciApIDpcblx0XHRzdXBlck1hdGNoZXI7XG59XG5cbmNvbXBpbGUgPSBTaXp6bGUuY29tcGlsZSA9IGZ1bmN0aW9uKCBzZWxlY3RvciwgbWF0Y2ggLyogSW50ZXJuYWwgVXNlIE9ubHkgKi8gKSB7XG5cdHZhciBpLFxuXHRcdHNldE1hdGNoZXJzID0gW10sXG5cdFx0ZWxlbWVudE1hdGNoZXJzID0gW10sXG5cdFx0Y2FjaGVkID0gY29tcGlsZXJDYWNoZVsgc2VsZWN0b3IgKyBcIiBcIiBdO1xuXG5cdGlmICggIWNhY2hlZCApIHtcblx0XHQvLyBHZW5lcmF0ZSBhIGZ1bmN0aW9uIG9mIHJlY3Vyc2l2ZSBmdW5jdGlvbnMgdGhhdCBjYW4gYmUgdXNlZCB0byBjaGVjayBlYWNoIGVsZW1lbnRcblx0XHRpZiAoICFtYXRjaCApIHtcblx0XHRcdG1hdGNoID0gdG9rZW5pemUoIHNlbGVjdG9yICk7XG5cdFx0fVxuXHRcdGkgPSBtYXRjaC5sZW5ndGg7XG5cdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRjYWNoZWQgPSBtYXRjaGVyRnJvbVRva2VucyggbWF0Y2hbaV0gKTtcblx0XHRcdGlmICggY2FjaGVkWyBleHBhbmRvIF0gKSB7XG5cdFx0XHRcdHNldE1hdGNoZXJzLnB1c2goIGNhY2hlZCApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZWxlbWVudE1hdGNoZXJzLnB1c2goIGNhY2hlZCApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIENhY2hlIHRoZSBjb21waWxlZCBmdW5jdGlvblxuXHRcdGNhY2hlZCA9IGNvbXBpbGVyQ2FjaGUoIHNlbGVjdG9yLCBtYXRjaGVyRnJvbUdyb3VwTWF0Y2hlcnMoIGVsZW1lbnRNYXRjaGVycywgc2V0TWF0Y2hlcnMgKSApO1xuXG5cdFx0Ly8gU2F2ZSBzZWxlY3RvciBhbmQgdG9rZW5pemF0aW9uXG5cdFx0Y2FjaGVkLnNlbGVjdG9yID0gc2VsZWN0b3I7XG5cdH1cblx0cmV0dXJuIGNhY2hlZDtcbn07XG5cbi8qKlxuICogQSBsb3ctbGV2ZWwgc2VsZWN0aW9uIGZ1bmN0aW9uIHRoYXQgd29ya3Mgd2l0aCBTaXp6bGUncyBjb21waWxlZFxuICogIHNlbGVjdG9yIGZ1bmN0aW9uc1xuICogQHBhcmFtIHtTdHJpbmd8RnVuY3Rpb259IHNlbGVjdG9yIEEgc2VsZWN0b3Igb3IgYSBwcmUtY29tcGlsZWRcbiAqICBzZWxlY3RvciBmdW5jdGlvbiBidWlsdCB3aXRoIFNpenpsZS5jb21waWxlXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGNvbnRleHRcbiAqIEBwYXJhbSB7QXJyYXl9IFtyZXN1bHRzXVxuICogQHBhcmFtIHtBcnJheX0gW3NlZWRdIEEgc2V0IG9mIGVsZW1lbnRzIHRvIG1hdGNoIGFnYWluc3RcbiAqL1xuc2VsZWN0ID0gU2l6emxlLnNlbGVjdCA9IGZ1bmN0aW9uKCBzZWxlY3RvciwgY29udGV4dCwgcmVzdWx0cywgc2VlZCApIHtcblx0dmFyIGksIHRva2VucywgdG9rZW4sIHR5cGUsIGZpbmQsXG5cdFx0Y29tcGlsZWQgPSB0eXBlb2Ygc2VsZWN0b3IgPT09IFwiZnVuY3Rpb25cIiAmJiBzZWxlY3Rvcixcblx0XHRtYXRjaCA9ICFzZWVkICYmIHRva2VuaXplKCAoc2VsZWN0b3IgPSBjb21waWxlZC5zZWxlY3RvciB8fCBzZWxlY3RvcikgKTtcblxuXHRyZXN1bHRzID0gcmVzdWx0cyB8fCBbXTtcblxuXHQvLyBUcnkgdG8gbWluaW1pemUgb3BlcmF0aW9ucyBpZiB0aGVyZSBpcyBvbmx5IG9uZSBzZWxlY3RvciBpbiB0aGUgbGlzdCBhbmQgbm8gc2VlZFxuXHQvLyAodGhlIGxhdHRlciBvZiB3aGljaCBndWFyYW50ZWVzIHVzIGNvbnRleHQpXG5cdGlmICggbWF0Y2gubGVuZ3RoID09PSAxICkge1xuXG5cdFx0Ly8gUmVkdWNlIGNvbnRleHQgaWYgdGhlIGxlYWRpbmcgY29tcG91bmQgc2VsZWN0b3IgaXMgYW4gSURcblx0XHR0b2tlbnMgPSBtYXRjaFswXSA9IG1hdGNoWzBdLnNsaWNlKCAwICk7XG5cdFx0aWYgKCB0b2tlbnMubGVuZ3RoID4gMiAmJiAodG9rZW4gPSB0b2tlbnNbMF0pLnR5cGUgPT09IFwiSURcIiAmJlxuXHRcdFx0XHRzdXBwb3J0LmdldEJ5SWQgJiYgY29udGV4dC5ub2RlVHlwZSA9PT0gOSAmJiBkb2N1bWVudElzSFRNTCAmJlxuXHRcdFx0XHRFeHByLnJlbGF0aXZlWyB0b2tlbnNbMV0udHlwZSBdICkge1xuXG5cdFx0XHRjb250ZXh0ID0gKCBFeHByLmZpbmRbXCJJRFwiXSggdG9rZW4ubWF0Y2hlc1swXS5yZXBsYWNlKHJ1bmVzY2FwZSwgZnVuZXNjYXBlKSwgY29udGV4dCApIHx8IFtdIClbMF07XG5cdFx0XHRpZiAoICFjb250ZXh0ICkge1xuXHRcdFx0XHRyZXR1cm4gcmVzdWx0cztcblxuXHRcdFx0Ly8gUHJlY29tcGlsZWQgbWF0Y2hlcnMgd2lsbCBzdGlsbCB2ZXJpZnkgYW5jZXN0cnksIHNvIHN0ZXAgdXAgYSBsZXZlbFxuXHRcdFx0fSBlbHNlIGlmICggY29tcGlsZWQgKSB7XG5cdFx0XHRcdGNvbnRleHQgPSBjb250ZXh0LnBhcmVudE5vZGU7XG5cdFx0XHR9XG5cblx0XHRcdHNlbGVjdG9yID0gc2VsZWN0b3Iuc2xpY2UoIHRva2Vucy5zaGlmdCgpLnZhbHVlLmxlbmd0aCApO1xuXHRcdH1cblxuXHRcdC8vIEZldGNoIGEgc2VlZCBzZXQgZm9yIHJpZ2h0LXRvLWxlZnQgbWF0Y2hpbmdcblx0XHRpID0gbWF0Y2hFeHByW1wibmVlZHNDb250ZXh0XCJdLnRlc3QoIHNlbGVjdG9yICkgPyAwIDogdG9rZW5zLmxlbmd0aDtcblx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdHRva2VuID0gdG9rZW5zW2ldO1xuXG5cdFx0XHQvLyBBYm9ydCBpZiB3ZSBoaXQgYSBjb21iaW5hdG9yXG5cdFx0XHRpZiAoIEV4cHIucmVsYXRpdmVbICh0eXBlID0gdG9rZW4udHlwZSkgXSApIHtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIChmaW5kID0gRXhwci5maW5kWyB0eXBlIF0pICkge1xuXHRcdFx0XHQvLyBTZWFyY2gsIGV4cGFuZGluZyBjb250ZXh0IGZvciBsZWFkaW5nIHNpYmxpbmcgY29tYmluYXRvcnNcblx0XHRcdFx0aWYgKCAoc2VlZCA9IGZpbmQoXG5cdFx0XHRcdFx0dG9rZW4ubWF0Y2hlc1swXS5yZXBsYWNlKCBydW5lc2NhcGUsIGZ1bmVzY2FwZSApLFxuXHRcdFx0XHRcdHJzaWJsaW5nLnRlc3QoIHRva2Vuc1swXS50eXBlICkgJiYgdGVzdENvbnRleHQoIGNvbnRleHQucGFyZW50Tm9kZSApIHx8IGNvbnRleHRcblx0XHRcdFx0KSkgKSB7XG5cblx0XHRcdFx0XHQvLyBJZiBzZWVkIGlzIGVtcHR5IG9yIG5vIHRva2VucyByZW1haW4sIHdlIGNhbiByZXR1cm4gZWFybHlcblx0XHRcdFx0XHR0b2tlbnMuc3BsaWNlKCBpLCAxICk7XG5cdFx0XHRcdFx0c2VsZWN0b3IgPSBzZWVkLmxlbmd0aCAmJiB0b1NlbGVjdG9yKCB0b2tlbnMgKTtcblx0XHRcdFx0XHRpZiAoICFzZWxlY3RvciApIHtcblx0XHRcdFx0XHRcdHB1c2guYXBwbHkoIHJlc3VsdHMsIHNlZWQgKTtcblx0XHRcdFx0XHRcdHJldHVybiByZXN1bHRzO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0Ly8gQ29tcGlsZSBhbmQgZXhlY3V0ZSBhIGZpbHRlcmluZyBmdW5jdGlvbiBpZiBvbmUgaXMgbm90IHByb3ZpZGVkXG5cdC8vIFByb3ZpZGUgYG1hdGNoYCB0byBhdm9pZCByZXRva2VuaXphdGlvbiBpZiB3ZSBtb2RpZmllZCB0aGUgc2VsZWN0b3IgYWJvdmVcblx0KCBjb21waWxlZCB8fCBjb21waWxlKCBzZWxlY3RvciwgbWF0Y2ggKSApKFxuXHRcdHNlZWQsXG5cdFx0Y29udGV4dCxcblx0XHQhZG9jdW1lbnRJc0hUTUwsXG5cdFx0cmVzdWx0cyxcblx0XHQhY29udGV4dCB8fCByc2libGluZy50ZXN0KCBzZWxlY3RvciApICYmIHRlc3RDb250ZXh0KCBjb250ZXh0LnBhcmVudE5vZGUgKSB8fCBjb250ZXh0XG5cdCk7XG5cdHJldHVybiByZXN1bHRzO1xufTtcblxuLy8gT25lLXRpbWUgYXNzaWdubWVudHNcblxuLy8gU29ydCBzdGFiaWxpdHlcbnN1cHBvcnQuc29ydFN0YWJsZSA9IGV4cGFuZG8uc3BsaXQoXCJcIikuc29ydCggc29ydE9yZGVyICkuam9pbihcIlwiKSA9PT0gZXhwYW5kbztcblxuLy8gU3VwcG9ydDogQ2hyb21lIDE0LTM1K1xuLy8gQWx3YXlzIGFzc3VtZSBkdXBsaWNhdGVzIGlmIHRoZXkgYXJlbid0IHBhc3NlZCB0byB0aGUgY29tcGFyaXNvbiBmdW5jdGlvblxuc3VwcG9ydC5kZXRlY3REdXBsaWNhdGVzID0gISFoYXNEdXBsaWNhdGU7XG5cbi8vIEluaXRpYWxpemUgYWdhaW5zdCB0aGUgZGVmYXVsdCBkb2N1bWVudFxuc2V0RG9jdW1lbnQoKTtcblxuLy8gU3VwcG9ydDogV2Via2l0PDUzNy4zMiAtIFNhZmFyaSA2LjAuMy9DaHJvbWUgMjUgKGZpeGVkIGluIENocm9tZSAyNylcbi8vIERldGFjaGVkIG5vZGVzIGNvbmZvdW5kaW5nbHkgZm9sbG93ICplYWNoIG90aGVyKlxuc3VwcG9ydC5zb3J0RGV0YWNoZWQgPSBhc3NlcnQoZnVuY3Rpb24oIGRpdjEgKSB7XG5cdC8vIFNob3VsZCByZXR1cm4gMSwgYnV0IHJldHVybnMgNCAoZm9sbG93aW5nKVxuXHRyZXR1cm4gZGl2MS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbiggZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKSApICYgMTtcbn0pO1xuXG4vLyBTdXBwb3J0OiBJRTw4XG4vLyBQcmV2ZW50IGF0dHJpYnV0ZS9wcm9wZXJ0eSBcImludGVycG9sYXRpb25cIlxuLy8gaHR0cDovL21zZG4ubWljcm9zb2Z0LmNvbS9lbi11cy9saWJyYXJ5L21zNTM2NDI5JTI4VlMuODUlMjkuYXNweFxuaWYgKCAhYXNzZXJ0KGZ1bmN0aW9uKCBkaXYgKSB7XG5cdGRpdi5pbm5lckhUTUwgPSBcIjxhIGhyZWY9JyMnPjwvYT5cIjtcblx0cmV0dXJuIGRpdi5maXJzdENoaWxkLmdldEF0dHJpYnV0ZShcImhyZWZcIikgPT09IFwiI1wiIDtcbn0pICkge1xuXHRhZGRIYW5kbGUoIFwidHlwZXxocmVmfGhlaWdodHx3aWR0aFwiLCBmdW5jdGlvbiggZWxlbSwgbmFtZSwgaXNYTUwgKSB7XG5cdFx0aWYgKCAhaXNYTUwgKSB7XG5cdFx0XHRyZXR1cm4gZWxlbS5nZXRBdHRyaWJ1dGUoIG5hbWUsIG5hbWUudG9Mb3dlckNhc2UoKSA9PT0gXCJ0eXBlXCIgPyAxIDogMiApO1xuXHRcdH1cblx0fSk7XG59XG5cbi8vIFN1cHBvcnQ6IElFPDlcbi8vIFVzZSBkZWZhdWx0VmFsdWUgaW4gcGxhY2Ugb2YgZ2V0QXR0cmlidXRlKFwidmFsdWVcIilcbmlmICggIXN1cHBvcnQuYXR0cmlidXRlcyB8fCAhYXNzZXJ0KGZ1bmN0aW9uKCBkaXYgKSB7XG5cdGRpdi5pbm5lckhUTUwgPSBcIjxpbnB1dC8+XCI7XG5cdGRpdi5maXJzdENoaWxkLnNldEF0dHJpYnV0ZSggXCJ2YWx1ZVwiLCBcIlwiICk7XG5cdHJldHVybiBkaXYuZmlyc3RDaGlsZC5nZXRBdHRyaWJ1dGUoIFwidmFsdWVcIiApID09PSBcIlwiO1xufSkgKSB7XG5cdGFkZEhhbmRsZSggXCJ2YWx1ZVwiLCBmdW5jdGlvbiggZWxlbSwgbmFtZSwgaXNYTUwgKSB7XG5cdFx0aWYgKCAhaXNYTUwgJiYgZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSBcImlucHV0XCIgKSB7XG5cdFx0XHRyZXR1cm4gZWxlbS5kZWZhdWx0VmFsdWU7XG5cdFx0fVxuXHR9KTtcbn1cblxuLy8gU3VwcG9ydDogSUU8OVxuLy8gVXNlIGdldEF0dHJpYnV0ZU5vZGUgdG8gZmV0Y2ggYm9vbGVhbnMgd2hlbiBnZXRBdHRyaWJ1dGUgbGllc1xuaWYgKCAhYXNzZXJ0KGZ1bmN0aW9uKCBkaXYgKSB7XG5cdHJldHVybiBkaXYuZ2V0QXR0cmlidXRlKFwiZGlzYWJsZWRcIikgPT0gbnVsbDtcbn0pICkge1xuXHRhZGRIYW5kbGUoIGJvb2xlYW5zLCBmdW5jdGlvbiggZWxlbSwgbmFtZSwgaXNYTUwgKSB7XG5cdFx0dmFyIHZhbDtcblx0XHRpZiAoICFpc1hNTCApIHtcblx0XHRcdHJldHVybiBlbGVtWyBuYW1lIF0gPT09IHRydWUgPyBuYW1lLnRvTG93ZXJDYXNlKCkgOlxuXHRcdFx0XHRcdCh2YWwgPSBlbGVtLmdldEF0dHJpYnV0ZU5vZGUoIG5hbWUgKSkgJiYgdmFsLnNwZWNpZmllZCA/XG5cdFx0XHRcdFx0dmFsLnZhbHVlIDpcblx0XHRcdFx0bnVsbDtcblx0XHR9XG5cdH0pO1xufVxuXG5yZXR1cm4gU2l6emxlO1xuXG59KSggd2luZG93ICk7XG5cblxuXG5qUXVlcnkuZmluZCA9IFNpenpsZTtcbmpRdWVyeS5leHByID0gU2l6emxlLnNlbGVjdG9ycztcbmpRdWVyeS5leHByWyBcIjpcIiBdID0galF1ZXJ5LmV4cHIucHNldWRvcztcbmpRdWVyeS51bmlxdWVTb3J0ID0galF1ZXJ5LnVuaXF1ZSA9IFNpenpsZS51bmlxdWVTb3J0O1xualF1ZXJ5LnRleHQgPSBTaXp6bGUuZ2V0VGV4dDtcbmpRdWVyeS5pc1hNTERvYyA9IFNpenpsZS5pc1hNTDtcbmpRdWVyeS5jb250YWlucyA9IFNpenpsZS5jb250YWlucztcblxuXG5cbnZhciBkaXIgPSBmdW5jdGlvbiggZWxlbSwgZGlyLCB1bnRpbCApIHtcblx0dmFyIG1hdGNoZWQgPSBbXSxcblx0XHR0cnVuY2F0ZSA9IHVudGlsICE9PSB1bmRlZmluZWQ7XG5cblx0d2hpbGUgKCAoIGVsZW0gPSBlbGVtWyBkaXIgXSApICYmIGVsZW0ubm9kZVR5cGUgIT09IDkgKSB7XG5cdFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSAxICkge1xuXHRcdFx0aWYgKCB0cnVuY2F0ZSAmJiBqUXVlcnkoIGVsZW0gKS5pcyggdW50aWwgKSApIHtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0XHRtYXRjaGVkLnB1c2goIGVsZW0gKTtcblx0XHR9XG5cdH1cblx0cmV0dXJuIG1hdGNoZWQ7XG59O1xuXG5cbnZhciBzaWJsaW5ncyA9IGZ1bmN0aW9uKCBuLCBlbGVtICkge1xuXHR2YXIgbWF0Y2hlZCA9IFtdO1xuXG5cdGZvciAoIDsgbjsgbiA9IG4ubmV4dFNpYmxpbmcgKSB7XG5cdFx0aWYgKCBuLm5vZGVUeXBlID09PSAxICYmIG4gIT09IGVsZW0gKSB7XG5cdFx0XHRtYXRjaGVkLnB1c2goIG4gKTtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gbWF0Y2hlZDtcbn07XG5cblxudmFyIHJuZWVkc0NvbnRleHQgPSBqUXVlcnkuZXhwci5tYXRjaC5uZWVkc0NvbnRleHQ7XG5cbnZhciByc2luZ2xlVGFnID0gKCAvXjwoW1xcdy1dKylcXHMqXFwvPz4oPzo8XFwvXFwxPnwpJC8gKTtcblxuXG5cbnZhciByaXNTaW1wbGUgPSAvXi5bXjojXFxbXFwuLF0qJC87XG5cbi8vIEltcGxlbWVudCB0aGUgaWRlbnRpY2FsIGZ1bmN0aW9uYWxpdHkgZm9yIGZpbHRlciBhbmQgbm90XG5mdW5jdGlvbiB3aW5ub3coIGVsZW1lbnRzLCBxdWFsaWZpZXIsIG5vdCApIHtcblx0aWYgKCBqUXVlcnkuaXNGdW5jdGlvbiggcXVhbGlmaWVyICkgKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS5ncmVwKCBlbGVtZW50cywgZnVuY3Rpb24oIGVsZW0sIGkgKSB7XG5cdFx0XHQvKiBqc2hpbnQgLVcwMTggKi9cblx0XHRcdHJldHVybiAhIXF1YWxpZmllci5jYWxsKCBlbGVtLCBpLCBlbGVtICkgIT09IG5vdDtcblx0XHR9ICk7XG5cblx0fVxuXG5cdGlmICggcXVhbGlmaWVyLm5vZGVUeXBlICkge1xuXHRcdHJldHVybiBqUXVlcnkuZ3JlcCggZWxlbWVudHMsIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuICggZWxlbSA9PT0gcXVhbGlmaWVyICkgIT09IG5vdDtcblx0XHR9ICk7XG5cblx0fVxuXG5cdGlmICggdHlwZW9mIHF1YWxpZmllciA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRpZiAoIHJpc1NpbXBsZS50ZXN0KCBxdWFsaWZpZXIgKSApIHtcblx0XHRcdHJldHVybiBqUXVlcnkuZmlsdGVyKCBxdWFsaWZpZXIsIGVsZW1lbnRzLCBub3QgKTtcblx0XHR9XG5cblx0XHRxdWFsaWZpZXIgPSBqUXVlcnkuZmlsdGVyKCBxdWFsaWZpZXIsIGVsZW1lbnRzICk7XG5cdH1cblxuXHRyZXR1cm4galF1ZXJ5LmdyZXAoIGVsZW1lbnRzLCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRyZXR1cm4gKCBqUXVlcnkuaW5BcnJheSggZWxlbSwgcXVhbGlmaWVyICkgPiAtMSApICE9PSBub3Q7XG5cdH0gKTtcbn1cblxualF1ZXJ5LmZpbHRlciA9IGZ1bmN0aW9uKCBleHByLCBlbGVtcywgbm90ICkge1xuXHR2YXIgZWxlbSA9IGVsZW1zWyAwIF07XG5cblx0aWYgKCBub3QgKSB7XG5cdFx0ZXhwciA9IFwiOm5vdChcIiArIGV4cHIgKyBcIilcIjtcblx0fVxuXG5cdHJldHVybiBlbGVtcy5sZW5ndGggPT09IDEgJiYgZWxlbS5ub2RlVHlwZSA9PT0gMSA/XG5cdFx0alF1ZXJ5LmZpbmQubWF0Y2hlc1NlbGVjdG9yKCBlbGVtLCBleHByICkgPyBbIGVsZW0gXSA6IFtdIDpcblx0XHRqUXVlcnkuZmluZC5tYXRjaGVzKCBleHByLCBqUXVlcnkuZ3JlcCggZWxlbXMsIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuIGVsZW0ubm9kZVR5cGUgPT09IDE7XG5cdFx0fSApICk7XG59O1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdGZpbmQ6IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHR2YXIgaSxcblx0XHRcdHJldCA9IFtdLFxuXHRcdFx0c2VsZiA9IHRoaXMsXG5cdFx0XHRsZW4gPSBzZWxmLmxlbmd0aDtcblxuXHRcdGlmICggdHlwZW9mIHNlbGVjdG9yICE9PSBcInN0cmluZ1wiICkge1xuXHRcdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCBqUXVlcnkoIHNlbGVjdG9yICkuZmlsdGVyKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0Zm9yICggaSA9IDA7IGkgPCBsZW47IGkrKyApIHtcblx0XHRcdFx0XHRpZiAoIGpRdWVyeS5jb250YWlucyggc2VsZlsgaSBdLCB0aGlzICkgKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0gKSApO1xuXHRcdH1cblxuXHRcdGZvciAoIGkgPSAwOyBpIDwgbGVuOyBpKysgKSB7XG5cdFx0XHRqUXVlcnkuZmluZCggc2VsZWN0b3IsIHNlbGZbIGkgXSwgcmV0ICk7XG5cdFx0fVxuXG5cdFx0Ly8gTmVlZGVkIGJlY2F1c2UgJCggc2VsZWN0b3IsIGNvbnRleHQgKSBiZWNvbWVzICQoIGNvbnRleHQgKS5maW5kKCBzZWxlY3RvciApXG5cdFx0cmV0ID0gdGhpcy5wdXNoU3RhY2soIGxlbiA+IDEgPyBqUXVlcnkudW5pcXVlKCByZXQgKSA6IHJldCApO1xuXHRcdHJldC5zZWxlY3RvciA9IHRoaXMuc2VsZWN0b3IgPyB0aGlzLnNlbGVjdG9yICsgXCIgXCIgKyBzZWxlY3RvciA6IHNlbGVjdG9yO1xuXHRcdHJldHVybiByZXQ7XG5cdH0sXG5cdGZpbHRlcjogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayggd2lubm93KCB0aGlzLCBzZWxlY3RvciB8fCBbXSwgZmFsc2UgKSApO1xuXHR9LFxuXHRub3Q6IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soIHdpbm5vdyggdGhpcywgc2VsZWN0b3IgfHwgW10sIHRydWUgKSApO1xuXHR9LFxuXHRpczogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdHJldHVybiAhIXdpbm5vdyhcblx0XHRcdHRoaXMsXG5cblx0XHRcdC8vIElmIHRoaXMgaXMgYSBwb3NpdGlvbmFsL3JlbGF0aXZlIHNlbGVjdG9yLCBjaGVjayBtZW1iZXJzaGlwIGluIHRoZSByZXR1cm5lZCBzZXRcblx0XHRcdC8vIHNvICQoXCJwOmZpcnN0XCIpLmlzKFwicDpsYXN0XCIpIHdvbid0IHJldHVybiB0cnVlIGZvciBhIGRvYyB3aXRoIHR3byBcInBcIi5cblx0XHRcdHR5cGVvZiBzZWxlY3RvciA9PT0gXCJzdHJpbmdcIiAmJiBybmVlZHNDb250ZXh0LnRlc3QoIHNlbGVjdG9yICkgP1xuXHRcdFx0XHRqUXVlcnkoIHNlbGVjdG9yICkgOlxuXHRcdFx0XHRzZWxlY3RvciB8fCBbXSxcblx0XHRcdGZhbHNlXG5cdFx0KS5sZW5ndGg7XG5cdH1cbn0gKTtcblxuXG4vLyBJbml0aWFsaXplIGEgalF1ZXJ5IG9iamVjdFxuXG5cbi8vIEEgY2VudHJhbCByZWZlcmVuY2UgdG8gdGhlIHJvb3QgalF1ZXJ5KGRvY3VtZW50KVxudmFyIHJvb3RqUXVlcnksXG5cblx0Ly8gQSBzaW1wbGUgd2F5IHRvIGNoZWNrIGZvciBIVE1MIHN0cmluZ3Ncblx0Ly8gUHJpb3JpdGl6ZSAjaWQgb3ZlciA8dGFnPiB0byBhdm9pZCBYU1MgdmlhIGxvY2F0aW9uLmhhc2ggKCM5NTIxKVxuXHQvLyBTdHJpY3QgSFRNTCByZWNvZ25pdGlvbiAoIzExMjkwOiBtdXN0IHN0YXJ0IHdpdGggPClcblx0cnF1aWNrRXhwciA9IC9eKD86XFxzKig8W1xcd1xcV10rPilbXj5dKnwjKFtcXHctXSopKSQvLFxuXG5cdGluaXQgPSBqUXVlcnkuZm4uaW5pdCA9IGZ1bmN0aW9uKCBzZWxlY3RvciwgY29udGV4dCwgcm9vdCApIHtcblx0XHR2YXIgbWF0Y2gsIGVsZW07XG5cblx0XHQvLyBIQU5ETEU6ICQoXCJcIiksICQobnVsbCksICQodW5kZWZpbmVkKSwgJChmYWxzZSlcblx0XHRpZiAoICFzZWxlY3RvciApIHtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdC8vIGluaXQgYWNjZXB0cyBhbiBhbHRlcm5hdGUgcm9vdGpRdWVyeVxuXHRcdC8vIHNvIG1pZ3JhdGUgY2FuIHN1cHBvcnQgalF1ZXJ5LnN1YiAoZ2gtMjEwMSlcblx0XHRyb290ID0gcm9vdCB8fCByb290alF1ZXJ5O1xuXG5cdFx0Ly8gSGFuZGxlIEhUTUwgc3RyaW5nc1xuXHRcdGlmICggdHlwZW9mIHNlbGVjdG9yID09PSBcInN0cmluZ1wiICkge1xuXHRcdFx0aWYgKCBzZWxlY3Rvci5jaGFyQXQoIDAgKSA9PT0gXCI8XCIgJiZcblx0XHRcdFx0c2VsZWN0b3IuY2hhckF0KCBzZWxlY3Rvci5sZW5ndGggLSAxICkgPT09IFwiPlwiICYmXG5cdFx0XHRcdHNlbGVjdG9yLmxlbmd0aCA+PSAzICkge1xuXG5cdFx0XHRcdC8vIEFzc3VtZSB0aGF0IHN0cmluZ3MgdGhhdCBzdGFydCBhbmQgZW5kIHdpdGggPD4gYXJlIEhUTUwgYW5kIHNraXAgdGhlIHJlZ2V4IGNoZWNrXG5cdFx0XHRcdG1hdGNoID0gWyBudWxsLCBzZWxlY3RvciwgbnVsbCBdO1xuXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRtYXRjaCA9IHJxdWlja0V4cHIuZXhlYyggc2VsZWN0b3IgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gTWF0Y2ggaHRtbCBvciBtYWtlIHN1cmUgbm8gY29udGV4dCBpcyBzcGVjaWZpZWQgZm9yICNpZFxuXHRcdFx0aWYgKCBtYXRjaCAmJiAoIG1hdGNoWyAxIF0gfHwgIWNvbnRleHQgKSApIHtcblxuXHRcdFx0XHQvLyBIQU5ETEU6ICQoaHRtbCkgLT4gJChhcnJheSlcblx0XHRcdFx0aWYgKCBtYXRjaFsgMSBdICkge1xuXHRcdFx0XHRcdGNvbnRleHQgPSBjb250ZXh0IGluc3RhbmNlb2YgalF1ZXJ5ID8gY29udGV4dFsgMCBdIDogY29udGV4dDtcblxuXHRcdFx0XHRcdC8vIHNjcmlwdHMgaXMgdHJ1ZSBmb3IgYmFjay1jb21wYXRcblx0XHRcdFx0XHQvLyBJbnRlbnRpb25hbGx5IGxldCB0aGUgZXJyb3IgYmUgdGhyb3duIGlmIHBhcnNlSFRNTCBpcyBub3QgcHJlc2VudFxuXHRcdFx0XHRcdGpRdWVyeS5tZXJnZSggdGhpcywgalF1ZXJ5LnBhcnNlSFRNTChcblx0XHRcdFx0XHRcdG1hdGNoWyAxIF0sXG5cdFx0XHRcdFx0XHRjb250ZXh0ICYmIGNvbnRleHQubm9kZVR5cGUgPyBjb250ZXh0Lm93bmVyRG9jdW1lbnQgfHwgY29udGV4dCA6IGRvY3VtZW50LFxuXHRcdFx0XHRcdFx0dHJ1ZVxuXHRcdFx0XHRcdCkgKTtcblxuXHRcdFx0XHRcdC8vIEhBTkRMRTogJChodG1sLCBwcm9wcylcblx0XHRcdFx0XHRpZiAoIHJzaW5nbGVUYWcudGVzdCggbWF0Y2hbIDEgXSApICYmIGpRdWVyeS5pc1BsYWluT2JqZWN0KCBjb250ZXh0ICkgKSB7XG5cdFx0XHRcdFx0XHRmb3IgKCBtYXRjaCBpbiBjb250ZXh0ICkge1xuXG5cdFx0XHRcdFx0XHRcdC8vIFByb3BlcnRpZXMgb2YgY29udGV4dCBhcmUgY2FsbGVkIGFzIG1ldGhvZHMgaWYgcG9zc2libGVcblx0XHRcdFx0XHRcdFx0aWYgKCBqUXVlcnkuaXNGdW5jdGlvbiggdGhpc1sgbWF0Y2ggXSApICkge1xuXHRcdFx0XHRcdFx0XHRcdHRoaXNbIG1hdGNoIF0oIGNvbnRleHRbIG1hdGNoIF0gKTtcblxuXHRcdFx0XHRcdFx0XHQvLyAuLi5hbmQgb3RoZXJ3aXNlIHNldCBhcyBhdHRyaWJ1dGVzXG5cdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0dGhpcy5hdHRyKCBtYXRjaCwgY29udGV4dFsgbWF0Y2ggXSApO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHRcdFx0Ly8gSEFORExFOiAkKCNpZClcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRlbGVtID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoIG1hdGNoWyAyIF0gKTtcblxuXHRcdFx0XHRcdC8vIENoZWNrIHBhcmVudE5vZGUgdG8gY2F0Y2ggd2hlbiBCbGFja2JlcnJ5IDQuNiByZXR1cm5zXG5cdFx0XHRcdFx0Ly8gbm9kZXMgdGhhdCBhcmUgbm8gbG9uZ2VyIGluIHRoZSBkb2N1bWVudCAjNjk2M1xuXHRcdFx0XHRcdGlmICggZWxlbSAmJiBlbGVtLnBhcmVudE5vZGUgKSB7XG5cblx0XHRcdFx0XHRcdC8vIEhhbmRsZSB0aGUgY2FzZSB3aGVyZSBJRSBhbmQgT3BlcmEgcmV0dXJuIGl0ZW1zXG5cdFx0XHRcdFx0XHQvLyBieSBuYW1lIGluc3RlYWQgb2YgSURcblx0XHRcdFx0XHRcdGlmICggZWxlbS5pZCAhPT0gbWF0Y2hbIDIgXSApIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIHJvb3RqUXVlcnkuZmluZCggc2VsZWN0b3IgKTtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0Ly8gT3RoZXJ3aXNlLCB3ZSBpbmplY3QgdGhlIGVsZW1lbnQgZGlyZWN0bHkgaW50byB0aGUgalF1ZXJ5IG9iamVjdFxuXHRcdFx0XHRcdFx0dGhpcy5sZW5ndGggPSAxO1xuXHRcdFx0XHRcdFx0dGhpc1sgMCBdID0gZWxlbTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR0aGlzLmNvbnRleHQgPSBkb2N1bWVudDtcblx0XHRcdFx0XHR0aGlzLnNlbGVjdG9yID0gc2VsZWN0b3I7XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHRcdH1cblxuXHRcdFx0Ly8gSEFORExFOiAkKGV4cHIsICQoLi4uKSlcblx0XHRcdH0gZWxzZSBpZiAoICFjb250ZXh0IHx8IGNvbnRleHQuanF1ZXJ5ICkge1xuXHRcdFx0XHRyZXR1cm4gKCBjb250ZXh0IHx8IHJvb3QgKS5maW5kKCBzZWxlY3RvciApO1xuXG5cdFx0XHQvLyBIQU5ETEU6ICQoZXhwciwgY29udGV4dClcblx0XHRcdC8vICh3aGljaCBpcyBqdXN0IGVxdWl2YWxlbnQgdG86ICQoY29udGV4dCkuZmluZChleHByKVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuY29uc3RydWN0b3IoIGNvbnRleHQgKS5maW5kKCBzZWxlY3RvciApO1xuXHRcdFx0fVxuXG5cdFx0Ly8gSEFORExFOiAkKERPTUVsZW1lbnQpXG5cdFx0fSBlbHNlIGlmICggc2VsZWN0b3Iubm9kZVR5cGUgKSB7XG5cdFx0XHR0aGlzLmNvbnRleHQgPSB0aGlzWyAwIF0gPSBzZWxlY3Rvcjtcblx0XHRcdHRoaXMubGVuZ3RoID0gMTtcblx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0Ly8gSEFORExFOiAkKGZ1bmN0aW9uKVxuXHRcdC8vIFNob3J0Y3V0IGZvciBkb2N1bWVudCByZWFkeVxuXHRcdH0gZWxzZSBpZiAoIGpRdWVyeS5pc0Z1bmN0aW9uKCBzZWxlY3RvciApICkge1xuXHRcdFx0cmV0dXJuIHR5cGVvZiByb290LnJlYWR5ICE9PSBcInVuZGVmaW5lZFwiID9cblx0XHRcdFx0cm9vdC5yZWFkeSggc2VsZWN0b3IgKSA6XG5cblx0XHRcdFx0Ly8gRXhlY3V0ZSBpbW1lZGlhdGVseSBpZiByZWFkeSBpcyBub3QgcHJlc2VudFxuXHRcdFx0XHRzZWxlY3RvciggalF1ZXJ5ICk7XG5cdFx0fVxuXG5cdFx0aWYgKCBzZWxlY3Rvci5zZWxlY3RvciAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0dGhpcy5zZWxlY3RvciA9IHNlbGVjdG9yLnNlbGVjdG9yO1xuXHRcdFx0dGhpcy5jb250ZXh0ID0gc2VsZWN0b3IuY29udGV4dDtcblx0XHR9XG5cblx0XHRyZXR1cm4galF1ZXJ5Lm1ha2VBcnJheSggc2VsZWN0b3IsIHRoaXMgKTtcblx0fTtcblxuLy8gR2l2ZSB0aGUgaW5pdCBmdW5jdGlvbiB0aGUgalF1ZXJ5IHByb3RvdHlwZSBmb3IgbGF0ZXIgaW5zdGFudGlhdGlvblxuaW5pdC5wcm90b3R5cGUgPSBqUXVlcnkuZm47XG5cbi8vIEluaXRpYWxpemUgY2VudHJhbCByZWZlcmVuY2VcbnJvb3RqUXVlcnkgPSBqUXVlcnkoIGRvY3VtZW50ICk7XG5cblxudmFyIHJwYXJlbnRzcHJldiA9IC9eKD86cGFyZW50c3xwcmV2KD86VW50aWx8QWxsKSkvLFxuXG5cdC8vIG1ldGhvZHMgZ3VhcmFudGVlZCB0byBwcm9kdWNlIGEgdW5pcXVlIHNldCB3aGVuIHN0YXJ0aW5nIGZyb20gYSB1bmlxdWUgc2V0XG5cdGd1YXJhbnRlZWRVbmlxdWUgPSB7XG5cdFx0Y2hpbGRyZW46IHRydWUsXG5cdFx0Y29udGVudHM6IHRydWUsXG5cdFx0bmV4dDogdHJ1ZSxcblx0XHRwcmV2OiB0cnVlXG5cdH07XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0aGFzOiBmdW5jdGlvbiggdGFyZ2V0ICkge1xuXHRcdHZhciBpLFxuXHRcdFx0dGFyZ2V0cyA9IGpRdWVyeSggdGFyZ2V0LCB0aGlzICksXG5cdFx0XHRsZW4gPSB0YXJnZXRzLmxlbmd0aDtcblxuXHRcdHJldHVybiB0aGlzLmZpbHRlciggZnVuY3Rpb24oKSB7XG5cdFx0XHRmb3IgKCBpID0gMDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdFx0XHRpZiAoIGpRdWVyeS5jb250YWlucyggdGhpcywgdGFyZ2V0c1sgaSBdICkgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9ICk7XG5cdH0sXG5cblx0Y2xvc2VzdDogZnVuY3Rpb24oIHNlbGVjdG9ycywgY29udGV4dCApIHtcblx0XHR2YXIgY3VyLFxuXHRcdFx0aSA9IDAsXG5cdFx0XHRsID0gdGhpcy5sZW5ndGgsXG5cdFx0XHRtYXRjaGVkID0gW10sXG5cdFx0XHRwb3MgPSBybmVlZHNDb250ZXh0LnRlc3QoIHNlbGVjdG9ycyApIHx8IHR5cGVvZiBzZWxlY3RvcnMgIT09IFwic3RyaW5nXCIgP1xuXHRcdFx0XHRqUXVlcnkoIHNlbGVjdG9ycywgY29udGV4dCB8fCB0aGlzLmNvbnRleHQgKSA6XG5cdFx0XHRcdDA7XG5cblx0XHRmb3IgKCA7IGkgPCBsOyBpKysgKSB7XG5cdFx0XHRmb3IgKCBjdXIgPSB0aGlzWyBpIF07IGN1ciAmJiBjdXIgIT09IGNvbnRleHQ7IGN1ciA9IGN1ci5wYXJlbnROb2RlICkge1xuXG5cdFx0XHRcdC8vIEFsd2F5cyBza2lwIGRvY3VtZW50IGZyYWdtZW50c1xuXHRcdFx0XHRpZiAoIGN1ci5ub2RlVHlwZSA8IDExICYmICggcG9zID9cblx0XHRcdFx0XHRwb3MuaW5kZXgoIGN1ciApID4gLTEgOlxuXG5cdFx0XHRcdFx0Ly8gRG9uJ3QgcGFzcyBub24tZWxlbWVudHMgdG8gU2l6emxlXG5cdFx0XHRcdFx0Y3VyLm5vZGVUeXBlID09PSAxICYmXG5cdFx0XHRcdFx0XHRqUXVlcnkuZmluZC5tYXRjaGVzU2VsZWN0b3IoIGN1ciwgc2VsZWN0b3JzICkgKSApIHtcblxuXHRcdFx0XHRcdG1hdGNoZWQucHVzaCggY3VyICk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soIG1hdGNoZWQubGVuZ3RoID4gMSA/IGpRdWVyeS51bmlxdWVTb3J0KCBtYXRjaGVkICkgOiBtYXRjaGVkICk7XG5cdH0sXG5cblx0Ly8gRGV0ZXJtaW5lIHRoZSBwb3NpdGlvbiBvZiBhbiBlbGVtZW50IHdpdGhpblxuXHQvLyB0aGUgbWF0Y2hlZCBzZXQgb2YgZWxlbWVudHNcblx0aW5kZXg6IGZ1bmN0aW9uKCBlbGVtICkge1xuXG5cdFx0Ly8gTm8gYXJndW1lbnQsIHJldHVybiBpbmRleCBpbiBwYXJlbnRcblx0XHRpZiAoICFlbGVtICkge1xuXHRcdFx0cmV0dXJuICggdGhpc1sgMCBdICYmIHRoaXNbIDAgXS5wYXJlbnROb2RlICkgPyB0aGlzLmZpcnN0KCkucHJldkFsbCgpLmxlbmd0aCA6IC0xO1xuXHRcdH1cblxuXHRcdC8vIGluZGV4IGluIHNlbGVjdG9yXG5cdFx0aWYgKCB0eXBlb2YgZWxlbSA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdHJldHVybiBqUXVlcnkuaW5BcnJheSggdGhpc1sgMCBdLCBqUXVlcnkoIGVsZW0gKSApO1xuXHRcdH1cblxuXHRcdC8vIExvY2F0ZSB0aGUgcG9zaXRpb24gb2YgdGhlIGRlc2lyZWQgZWxlbWVudFxuXHRcdHJldHVybiBqUXVlcnkuaW5BcnJheShcblxuXHRcdFx0Ly8gSWYgaXQgcmVjZWl2ZXMgYSBqUXVlcnkgb2JqZWN0LCB0aGUgZmlyc3QgZWxlbWVudCBpcyB1c2VkXG5cdFx0XHRlbGVtLmpxdWVyeSA/IGVsZW1bIDAgXSA6IGVsZW0sIHRoaXMgKTtcblx0fSxcblxuXHRhZGQ6IGZ1bmN0aW9uKCBzZWxlY3RvciwgY29udGV4dCApIHtcblx0XHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soXG5cdFx0XHRqUXVlcnkudW5pcXVlU29ydChcblx0XHRcdFx0alF1ZXJ5Lm1lcmdlKCB0aGlzLmdldCgpLCBqUXVlcnkoIHNlbGVjdG9yLCBjb250ZXh0ICkgKVxuXHRcdFx0KVxuXHRcdCk7XG5cdH0sXG5cblx0YWRkQmFjazogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdHJldHVybiB0aGlzLmFkZCggc2VsZWN0b3IgPT0gbnVsbCA/XG5cdFx0XHR0aGlzLnByZXZPYmplY3QgOiB0aGlzLnByZXZPYmplY3QuZmlsdGVyKCBzZWxlY3RvciApXG5cdFx0KTtcblx0fVxufSApO1xuXG5mdW5jdGlvbiBzaWJsaW5nKCBjdXIsIGRpciApIHtcblx0ZG8ge1xuXHRcdGN1ciA9IGN1clsgZGlyIF07XG5cdH0gd2hpbGUgKCBjdXIgJiYgY3VyLm5vZGVUeXBlICE9PSAxICk7XG5cblx0cmV0dXJuIGN1cjtcbn1cblxualF1ZXJ5LmVhY2goIHtcblx0cGFyZW50OiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHR2YXIgcGFyZW50ID0gZWxlbS5wYXJlbnROb2RlO1xuXHRcdHJldHVybiBwYXJlbnQgJiYgcGFyZW50Lm5vZGVUeXBlICE9PSAxMSA/IHBhcmVudCA6IG51bGw7XG5cdH0sXG5cdHBhcmVudHM6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHJldHVybiBkaXIoIGVsZW0sIFwicGFyZW50Tm9kZVwiICk7XG5cdH0sXG5cdHBhcmVudHNVbnRpbDogZnVuY3Rpb24oIGVsZW0sIGksIHVudGlsICkge1xuXHRcdHJldHVybiBkaXIoIGVsZW0sIFwicGFyZW50Tm9kZVwiLCB1bnRpbCApO1xuXHR9LFxuXHRuZXh0OiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRyZXR1cm4gc2libGluZyggZWxlbSwgXCJuZXh0U2libGluZ1wiICk7XG5cdH0sXG5cdHByZXY6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHJldHVybiBzaWJsaW5nKCBlbGVtLCBcInByZXZpb3VzU2libGluZ1wiICk7XG5cdH0sXG5cdG5leHRBbGw6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHJldHVybiBkaXIoIGVsZW0sIFwibmV4dFNpYmxpbmdcIiApO1xuXHR9LFxuXHRwcmV2QWxsOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRyZXR1cm4gZGlyKCBlbGVtLCBcInByZXZpb3VzU2libGluZ1wiICk7XG5cdH0sXG5cdG5leHRVbnRpbDogZnVuY3Rpb24oIGVsZW0sIGksIHVudGlsICkge1xuXHRcdHJldHVybiBkaXIoIGVsZW0sIFwibmV4dFNpYmxpbmdcIiwgdW50aWwgKTtcblx0fSxcblx0cHJldlVudGlsOiBmdW5jdGlvbiggZWxlbSwgaSwgdW50aWwgKSB7XG5cdFx0cmV0dXJuIGRpciggZWxlbSwgXCJwcmV2aW91c1NpYmxpbmdcIiwgdW50aWwgKTtcblx0fSxcblx0c2libGluZ3M6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHJldHVybiBzaWJsaW5ncyggKCBlbGVtLnBhcmVudE5vZGUgfHwge30gKS5maXJzdENoaWxkLCBlbGVtICk7XG5cdH0sXG5cdGNoaWxkcmVuOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRyZXR1cm4gc2libGluZ3MoIGVsZW0uZmlyc3RDaGlsZCApO1xuXHR9LFxuXHRjb250ZW50czogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS5ub2RlTmFtZSggZWxlbSwgXCJpZnJhbWVcIiApID9cblx0XHRcdGVsZW0uY29udGVudERvY3VtZW50IHx8IGVsZW0uY29udGVudFdpbmRvdy5kb2N1bWVudCA6XG5cdFx0XHRqUXVlcnkubWVyZ2UoIFtdLCBlbGVtLmNoaWxkTm9kZXMgKTtcblx0fVxufSwgZnVuY3Rpb24oIG5hbWUsIGZuICkge1xuXHRqUXVlcnkuZm5bIG5hbWUgXSA9IGZ1bmN0aW9uKCB1bnRpbCwgc2VsZWN0b3IgKSB7XG5cdFx0dmFyIHJldCA9IGpRdWVyeS5tYXAoIHRoaXMsIGZuLCB1bnRpbCApO1xuXG5cdFx0aWYgKCBuYW1lLnNsaWNlKCAtNSApICE9PSBcIlVudGlsXCIgKSB7XG5cdFx0XHRzZWxlY3RvciA9IHVudGlsO1xuXHRcdH1cblxuXHRcdGlmICggc2VsZWN0b3IgJiYgdHlwZW9mIHNlbGVjdG9yID09PSBcInN0cmluZ1wiICkge1xuXHRcdFx0cmV0ID0galF1ZXJ5LmZpbHRlciggc2VsZWN0b3IsIHJldCApO1xuXHRcdH1cblxuXHRcdGlmICggdGhpcy5sZW5ndGggPiAxICkge1xuXG5cdFx0XHQvLyBSZW1vdmUgZHVwbGljYXRlc1xuXHRcdFx0aWYgKCAhZ3VhcmFudGVlZFVuaXF1ZVsgbmFtZSBdICkge1xuXHRcdFx0XHRyZXQgPSBqUXVlcnkudW5pcXVlU29ydCggcmV0ICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFJldmVyc2Ugb3JkZXIgZm9yIHBhcmVudHMqIGFuZCBwcmV2LWRlcml2YXRpdmVzXG5cdFx0XHRpZiAoIHJwYXJlbnRzcHJldi50ZXN0KCBuYW1lICkgKSB7XG5cdFx0XHRcdHJldCA9IHJldC5yZXZlcnNlKCk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCByZXQgKTtcblx0fTtcbn0gKTtcbnZhciBybm90d2hpdGUgPSAoIC9cXFMrL2cgKTtcblxuXG5cbi8vIENvbnZlcnQgU3RyaW5nLWZvcm1hdHRlZCBvcHRpb25zIGludG8gT2JqZWN0LWZvcm1hdHRlZCBvbmVzXG5mdW5jdGlvbiBjcmVhdGVPcHRpb25zKCBvcHRpb25zICkge1xuXHR2YXIgb2JqZWN0ID0ge307XG5cdGpRdWVyeS5lYWNoKCBvcHRpb25zLm1hdGNoKCBybm90d2hpdGUgKSB8fCBbXSwgZnVuY3Rpb24oIF8sIGZsYWcgKSB7XG5cdFx0b2JqZWN0WyBmbGFnIF0gPSB0cnVlO1xuXHR9ICk7XG5cdHJldHVybiBvYmplY3Q7XG59XG5cbi8qXG4gKiBDcmVhdGUgYSBjYWxsYmFjayBsaXN0IHVzaW5nIHRoZSBmb2xsb3dpbmcgcGFyYW1ldGVyczpcbiAqXG4gKlx0b3B0aW9uczogYW4gb3B0aW9uYWwgbGlzdCBvZiBzcGFjZS1zZXBhcmF0ZWQgb3B0aW9ucyB0aGF0IHdpbGwgY2hhbmdlIGhvd1xuICpcdFx0XHR0aGUgY2FsbGJhY2sgbGlzdCBiZWhhdmVzIG9yIGEgbW9yZSB0cmFkaXRpb25hbCBvcHRpb24gb2JqZWN0XG4gKlxuICogQnkgZGVmYXVsdCBhIGNhbGxiYWNrIGxpc3Qgd2lsbCBhY3QgbGlrZSBhbiBldmVudCBjYWxsYmFjayBsaXN0IGFuZCBjYW4gYmVcbiAqIFwiZmlyZWRcIiBtdWx0aXBsZSB0aW1lcy5cbiAqXG4gKiBQb3NzaWJsZSBvcHRpb25zOlxuICpcbiAqXHRvbmNlOlx0XHRcdHdpbGwgZW5zdXJlIHRoZSBjYWxsYmFjayBsaXN0IGNhbiBvbmx5IGJlIGZpcmVkIG9uY2UgKGxpa2UgYSBEZWZlcnJlZClcbiAqXG4gKlx0bWVtb3J5Olx0XHRcdHdpbGwga2VlcCB0cmFjayBvZiBwcmV2aW91cyB2YWx1ZXMgYW5kIHdpbGwgY2FsbCBhbnkgY2FsbGJhY2sgYWRkZWRcbiAqXHRcdFx0XHRcdGFmdGVyIHRoZSBsaXN0IGhhcyBiZWVuIGZpcmVkIHJpZ2h0IGF3YXkgd2l0aCB0aGUgbGF0ZXN0IFwibWVtb3JpemVkXCJcbiAqXHRcdFx0XHRcdHZhbHVlcyAobGlrZSBhIERlZmVycmVkKVxuICpcbiAqXHR1bmlxdWU6XHRcdFx0d2lsbCBlbnN1cmUgYSBjYWxsYmFjayBjYW4gb25seSBiZSBhZGRlZCBvbmNlIChubyBkdXBsaWNhdGUgaW4gdGhlIGxpc3QpXG4gKlxuICpcdHN0b3BPbkZhbHNlOlx0aW50ZXJydXB0IGNhbGxpbmdzIHdoZW4gYSBjYWxsYmFjayByZXR1cm5zIGZhbHNlXG4gKlxuICovXG5qUXVlcnkuQ2FsbGJhY2tzID0gZnVuY3Rpb24oIG9wdGlvbnMgKSB7XG5cblx0Ly8gQ29udmVydCBvcHRpb25zIGZyb20gU3RyaW5nLWZvcm1hdHRlZCB0byBPYmplY3QtZm9ybWF0dGVkIGlmIG5lZWRlZFxuXHQvLyAod2UgY2hlY2sgaW4gY2FjaGUgZmlyc3QpXG5cdG9wdGlvbnMgPSB0eXBlb2Ygb3B0aW9ucyA9PT0gXCJzdHJpbmdcIiA/XG5cdFx0Y3JlYXRlT3B0aW9ucyggb3B0aW9ucyApIDpcblx0XHRqUXVlcnkuZXh0ZW5kKCB7fSwgb3B0aW9ucyApO1xuXG5cdHZhciAvLyBGbGFnIHRvIGtub3cgaWYgbGlzdCBpcyBjdXJyZW50bHkgZmlyaW5nXG5cdFx0ZmlyaW5nLFxuXG5cdFx0Ly8gTGFzdCBmaXJlIHZhbHVlIGZvciBub24tZm9yZ2V0dGFibGUgbGlzdHNcblx0XHRtZW1vcnksXG5cblx0XHQvLyBGbGFnIHRvIGtub3cgaWYgbGlzdCB3YXMgYWxyZWFkeSBmaXJlZFxuXHRcdGZpcmVkLFxuXG5cdFx0Ly8gRmxhZyB0byBwcmV2ZW50IGZpcmluZ1xuXHRcdGxvY2tlZCxcblxuXHRcdC8vIEFjdHVhbCBjYWxsYmFjayBsaXN0XG5cdFx0bGlzdCA9IFtdLFxuXG5cdFx0Ly8gUXVldWUgb2YgZXhlY3V0aW9uIGRhdGEgZm9yIHJlcGVhdGFibGUgbGlzdHNcblx0XHRxdWV1ZSA9IFtdLFxuXG5cdFx0Ly8gSW5kZXggb2YgY3VycmVudGx5IGZpcmluZyBjYWxsYmFjayAobW9kaWZpZWQgYnkgYWRkL3JlbW92ZSBhcyBuZWVkZWQpXG5cdFx0ZmlyaW5nSW5kZXggPSAtMSxcblxuXHRcdC8vIEZpcmUgY2FsbGJhY2tzXG5cdFx0ZmlyZSA9IGZ1bmN0aW9uKCkge1xuXG5cdFx0XHQvLyBFbmZvcmNlIHNpbmdsZS1maXJpbmdcblx0XHRcdGxvY2tlZCA9IG9wdGlvbnMub25jZTtcblxuXHRcdFx0Ly8gRXhlY3V0ZSBjYWxsYmFja3MgZm9yIGFsbCBwZW5kaW5nIGV4ZWN1dGlvbnMsXG5cdFx0XHQvLyByZXNwZWN0aW5nIGZpcmluZ0luZGV4IG92ZXJyaWRlcyBhbmQgcnVudGltZSBjaGFuZ2VzXG5cdFx0XHRmaXJlZCA9IGZpcmluZyA9IHRydWU7XG5cdFx0XHRmb3IgKCA7IHF1ZXVlLmxlbmd0aDsgZmlyaW5nSW5kZXggPSAtMSApIHtcblx0XHRcdFx0bWVtb3J5ID0gcXVldWUuc2hpZnQoKTtcblx0XHRcdFx0d2hpbGUgKCArK2ZpcmluZ0luZGV4IDwgbGlzdC5sZW5ndGggKSB7XG5cblx0XHRcdFx0XHQvLyBSdW4gY2FsbGJhY2sgYW5kIGNoZWNrIGZvciBlYXJseSB0ZXJtaW5hdGlvblxuXHRcdFx0XHRcdGlmICggbGlzdFsgZmlyaW5nSW5kZXggXS5hcHBseSggbWVtb3J5WyAwIF0sIG1lbW9yeVsgMSBdICkgPT09IGZhbHNlICYmXG5cdFx0XHRcdFx0XHRvcHRpb25zLnN0b3BPbkZhbHNlICkge1xuXG5cdFx0XHRcdFx0XHQvLyBKdW1wIHRvIGVuZCBhbmQgZm9yZ2V0IHRoZSBkYXRhIHNvIC5hZGQgZG9lc24ndCByZS1maXJlXG5cdFx0XHRcdFx0XHRmaXJpbmdJbmRleCA9IGxpc3QubGVuZ3RoO1xuXHRcdFx0XHRcdFx0bWVtb3J5ID0gZmFsc2U7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIEZvcmdldCB0aGUgZGF0YSBpZiB3ZSdyZSBkb25lIHdpdGggaXRcblx0XHRcdGlmICggIW9wdGlvbnMubWVtb3J5ICkge1xuXHRcdFx0XHRtZW1vcnkgPSBmYWxzZTtcblx0XHRcdH1cblxuXHRcdFx0ZmlyaW5nID0gZmFsc2U7XG5cblx0XHRcdC8vIENsZWFuIHVwIGlmIHdlJ3JlIGRvbmUgZmlyaW5nIGZvciBnb29kXG5cdFx0XHRpZiAoIGxvY2tlZCApIHtcblxuXHRcdFx0XHQvLyBLZWVwIGFuIGVtcHR5IGxpc3QgaWYgd2UgaGF2ZSBkYXRhIGZvciBmdXR1cmUgYWRkIGNhbGxzXG5cdFx0XHRcdGlmICggbWVtb3J5ICkge1xuXHRcdFx0XHRcdGxpc3QgPSBbXTtcblxuXHRcdFx0XHQvLyBPdGhlcndpc2UsIHRoaXMgb2JqZWN0IGlzIHNwZW50XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0bGlzdCA9IFwiXCI7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0Ly8gQWN0dWFsIENhbGxiYWNrcyBvYmplY3Rcblx0XHRzZWxmID0ge1xuXG5cdFx0XHQvLyBBZGQgYSBjYWxsYmFjayBvciBhIGNvbGxlY3Rpb24gb2YgY2FsbGJhY2tzIHRvIHRoZSBsaXN0XG5cdFx0XHRhZGQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoIGxpc3QgKSB7XG5cblx0XHRcdFx0XHQvLyBJZiB3ZSBoYXZlIG1lbW9yeSBmcm9tIGEgcGFzdCBydW4sIHdlIHNob3VsZCBmaXJlIGFmdGVyIGFkZGluZ1xuXHRcdFx0XHRcdGlmICggbWVtb3J5ICYmICFmaXJpbmcgKSB7XG5cdFx0XHRcdFx0XHRmaXJpbmdJbmRleCA9IGxpc3QubGVuZ3RoIC0gMTtcblx0XHRcdFx0XHRcdHF1ZXVlLnB1c2goIG1lbW9yeSApO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdCggZnVuY3Rpb24gYWRkKCBhcmdzICkge1xuXHRcdFx0XHRcdFx0alF1ZXJ5LmVhY2goIGFyZ3MsIGZ1bmN0aW9uKCBfLCBhcmcgKSB7XG5cdFx0XHRcdFx0XHRcdGlmICggalF1ZXJ5LmlzRnVuY3Rpb24oIGFyZyApICkge1xuXHRcdFx0XHRcdFx0XHRcdGlmICggIW9wdGlvbnMudW5pcXVlIHx8ICFzZWxmLmhhcyggYXJnICkgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRsaXN0LnB1c2goIGFyZyApO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fSBlbHNlIGlmICggYXJnICYmIGFyZy5sZW5ndGggJiYgalF1ZXJ5LnR5cGUoIGFyZyApICE9PSBcInN0cmluZ1wiICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gSW5zcGVjdCByZWN1cnNpdmVseVxuXHRcdFx0XHRcdFx0XHRcdGFkZCggYXJnICk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH0gKTtcblx0XHRcdFx0XHR9ICkoIGFyZ3VtZW50cyApO1xuXG5cdFx0XHRcdFx0aWYgKCBtZW1vcnkgJiYgIWZpcmluZyApIHtcblx0XHRcdFx0XHRcdGZpcmUoKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBSZW1vdmUgYSBjYWxsYmFjayBmcm9tIHRoZSBsaXN0XG5cdFx0XHRyZW1vdmU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRqUXVlcnkuZWFjaCggYXJndW1lbnRzLCBmdW5jdGlvbiggXywgYXJnICkge1xuXHRcdFx0XHRcdHZhciBpbmRleDtcblx0XHRcdFx0XHR3aGlsZSAoICggaW5kZXggPSBqUXVlcnkuaW5BcnJheSggYXJnLCBsaXN0LCBpbmRleCApICkgPiAtMSApIHtcblx0XHRcdFx0XHRcdGxpc3Quc3BsaWNlKCBpbmRleCwgMSApO1xuXG5cdFx0XHRcdFx0XHQvLyBIYW5kbGUgZmlyaW5nIGluZGV4ZXNcblx0XHRcdFx0XHRcdGlmICggaW5kZXggPD0gZmlyaW5nSW5kZXggKSB7XG5cdFx0XHRcdFx0XHRcdGZpcmluZ0luZGV4LS07XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9ICk7XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fSxcblxuXHRcdFx0Ly8gQ2hlY2sgaWYgYSBnaXZlbiBjYWxsYmFjayBpcyBpbiB0aGUgbGlzdC5cblx0XHRcdC8vIElmIG5vIGFyZ3VtZW50IGlzIGdpdmVuLCByZXR1cm4gd2hldGhlciBvciBub3QgbGlzdCBoYXMgY2FsbGJhY2tzIGF0dGFjaGVkLlxuXHRcdFx0aGFzOiBmdW5jdGlvbiggZm4gKSB7XG5cdFx0XHRcdHJldHVybiBmbiA/XG5cdFx0XHRcdFx0alF1ZXJ5LmluQXJyYXkoIGZuLCBsaXN0ICkgPiAtMSA6XG5cdFx0XHRcdFx0bGlzdC5sZW5ndGggPiAwO1xuXHRcdFx0fSxcblxuXHRcdFx0Ly8gUmVtb3ZlIGFsbCBjYWxsYmFja3MgZnJvbSB0aGUgbGlzdFxuXHRcdFx0ZW1wdHk6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoIGxpc3QgKSB7XG5cdFx0XHRcdFx0bGlzdCA9IFtdO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fSxcblxuXHRcdFx0Ly8gRGlzYWJsZSAuZmlyZSBhbmQgLmFkZFxuXHRcdFx0Ly8gQWJvcnQgYW55IGN1cnJlbnQvcGVuZGluZyBleGVjdXRpb25zXG5cdFx0XHQvLyBDbGVhciBhbGwgY2FsbGJhY2tzIGFuZCB2YWx1ZXNcblx0XHRcdGRpc2FibGU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRsb2NrZWQgPSBxdWV1ZSA9IFtdO1xuXHRcdFx0XHRsaXN0ID0gbWVtb3J5ID0gXCJcIjtcblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9LFxuXHRcdFx0ZGlzYWJsZWQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gIWxpc3Q7XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBEaXNhYmxlIC5maXJlXG5cdFx0XHQvLyBBbHNvIGRpc2FibGUgLmFkZCB1bmxlc3Mgd2UgaGF2ZSBtZW1vcnkgKHNpbmNlIGl0IHdvdWxkIGhhdmUgbm8gZWZmZWN0KVxuXHRcdFx0Ly8gQWJvcnQgYW55IHBlbmRpbmcgZXhlY3V0aW9uc1xuXHRcdFx0bG9jazogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGxvY2tlZCA9IHRydWU7XG5cdFx0XHRcdGlmICggIW1lbW9yeSApIHtcblx0XHRcdFx0XHRzZWxmLmRpc2FibGUoKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH0sXG5cdFx0XHRsb2NrZWQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gISFsb2NrZWQ7XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBDYWxsIGFsbCBjYWxsYmFja3Mgd2l0aCB0aGUgZ2l2ZW4gY29udGV4dCBhbmQgYXJndW1lbnRzXG5cdFx0XHRmaXJlV2l0aDogZnVuY3Rpb24oIGNvbnRleHQsIGFyZ3MgKSB7XG5cdFx0XHRcdGlmICggIWxvY2tlZCApIHtcblx0XHRcdFx0XHRhcmdzID0gYXJncyB8fCBbXTtcblx0XHRcdFx0XHRhcmdzID0gWyBjb250ZXh0LCBhcmdzLnNsaWNlID8gYXJncy5zbGljZSgpIDogYXJncyBdO1xuXHRcdFx0XHRcdHF1ZXVlLnB1c2goIGFyZ3MgKTtcblx0XHRcdFx0XHRpZiAoICFmaXJpbmcgKSB7XG5cdFx0XHRcdFx0XHRmaXJlKCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fSxcblxuXHRcdFx0Ly8gQ2FsbCBhbGwgdGhlIGNhbGxiYWNrcyB3aXRoIHRoZSBnaXZlbiBhcmd1bWVudHNcblx0XHRcdGZpcmU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRzZWxmLmZpcmVXaXRoKCB0aGlzLCBhcmd1bWVudHMgKTtcblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBUbyBrbm93IGlmIHRoZSBjYWxsYmFja3MgaGF2ZSBhbHJlYWR5IGJlZW4gY2FsbGVkIGF0IGxlYXN0IG9uY2Vcblx0XHRcdGZpcmVkOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuICEhZmlyZWQ7XG5cdFx0XHR9XG5cdFx0fTtcblxuXHRyZXR1cm4gc2VsZjtcbn07XG5cblxualF1ZXJ5LmV4dGVuZCgge1xuXG5cdERlZmVycmVkOiBmdW5jdGlvbiggZnVuYyApIHtcblx0XHR2YXIgdHVwbGVzID0gW1xuXG5cdFx0XHRcdC8vIGFjdGlvbiwgYWRkIGxpc3RlbmVyLCBsaXN0ZW5lciBsaXN0LCBmaW5hbCBzdGF0ZVxuXHRcdFx0XHRbIFwicmVzb2x2ZVwiLCBcImRvbmVcIiwgalF1ZXJ5LkNhbGxiYWNrcyggXCJvbmNlIG1lbW9yeVwiICksIFwicmVzb2x2ZWRcIiBdLFxuXHRcdFx0XHRbIFwicmVqZWN0XCIsIFwiZmFpbFwiLCBqUXVlcnkuQ2FsbGJhY2tzKCBcIm9uY2UgbWVtb3J5XCIgKSwgXCJyZWplY3RlZFwiIF0sXG5cdFx0XHRcdFsgXCJub3RpZnlcIiwgXCJwcm9ncmVzc1wiLCBqUXVlcnkuQ2FsbGJhY2tzKCBcIm1lbW9yeVwiICkgXVxuXHRcdFx0XSxcblx0XHRcdHN0YXRlID0gXCJwZW5kaW5nXCIsXG5cdFx0XHRwcm9taXNlID0ge1xuXHRcdFx0XHRzdGF0ZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHN0YXRlO1xuXHRcdFx0XHR9LFxuXHRcdFx0XHRhbHdheXM6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdGRlZmVycmVkLmRvbmUoIGFyZ3VtZW50cyApLmZhaWwoIGFyZ3VtZW50cyApO1xuXHRcdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0XHR9LFxuXHRcdFx0XHR0aGVuOiBmdW5jdGlvbiggLyogZm5Eb25lLCBmbkZhaWwsIGZuUHJvZ3Jlc3MgKi8gKSB7XG5cdFx0XHRcdFx0dmFyIGZucyA9IGFyZ3VtZW50cztcblx0XHRcdFx0XHRyZXR1cm4galF1ZXJ5LkRlZmVycmVkKCBmdW5jdGlvbiggbmV3RGVmZXIgKSB7XG5cdFx0XHRcdFx0XHRqUXVlcnkuZWFjaCggdHVwbGVzLCBmdW5jdGlvbiggaSwgdHVwbGUgKSB7XG5cdFx0XHRcdFx0XHRcdHZhciBmbiA9IGpRdWVyeS5pc0Z1bmN0aW9uKCBmbnNbIGkgXSApICYmIGZuc1sgaSBdO1xuXG5cdFx0XHRcdFx0XHRcdC8vIGRlZmVycmVkWyBkb25lIHwgZmFpbCB8IHByb2dyZXNzIF0gZm9yIGZvcndhcmRpbmcgYWN0aW9ucyB0byBuZXdEZWZlclxuXHRcdFx0XHRcdFx0XHRkZWZlcnJlZFsgdHVwbGVbIDEgXSBdKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdFx0XHR2YXIgcmV0dXJuZWQgPSBmbiAmJiBmbi5hcHBseSggdGhpcywgYXJndW1lbnRzICk7XG5cdFx0XHRcdFx0XHRcdFx0aWYgKCByZXR1cm5lZCAmJiBqUXVlcnkuaXNGdW5jdGlvbiggcmV0dXJuZWQucHJvbWlzZSApICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0cmV0dXJuZWQucHJvbWlzZSgpXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC5wcm9ncmVzcyggbmV3RGVmZXIubm90aWZ5IClcblx0XHRcdFx0XHRcdFx0XHRcdFx0LmRvbmUoIG5ld0RlZmVyLnJlc29sdmUgKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHQuZmFpbCggbmV3RGVmZXIucmVqZWN0ICk7XG5cdFx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRcdG5ld0RlZmVyWyB0dXBsZVsgMCBdICsgXCJXaXRoXCIgXShcblx0XHRcdFx0XHRcdFx0XHRcdFx0dGhpcyA9PT0gcHJvbWlzZSA/IG5ld0RlZmVyLnByb21pc2UoKSA6IHRoaXMsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGZuID8gWyByZXR1cm5lZCBdIDogYXJndW1lbnRzXG5cdFx0XHRcdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fSApO1xuXHRcdFx0XHRcdFx0fSApO1xuXHRcdFx0XHRcdFx0Zm5zID0gbnVsbDtcblx0XHRcdFx0XHR9ICkucHJvbWlzZSgpO1xuXHRcdFx0XHR9LFxuXG5cdFx0XHRcdC8vIEdldCBhIHByb21pc2UgZm9yIHRoaXMgZGVmZXJyZWRcblx0XHRcdFx0Ly8gSWYgb2JqIGlzIHByb3ZpZGVkLCB0aGUgcHJvbWlzZSBhc3BlY3QgaXMgYWRkZWQgdG8gdGhlIG9iamVjdFxuXHRcdFx0XHRwcm9taXNlOiBmdW5jdGlvbiggb2JqICkge1xuXHRcdFx0XHRcdHJldHVybiBvYmogIT0gbnVsbCA/IGpRdWVyeS5leHRlbmQoIG9iaiwgcHJvbWlzZSApIDogcHJvbWlzZTtcblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdGRlZmVycmVkID0ge307XG5cblx0XHQvLyBLZWVwIHBpcGUgZm9yIGJhY2stY29tcGF0XG5cdFx0cHJvbWlzZS5waXBlID0gcHJvbWlzZS50aGVuO1xuXG5cdFx0Ly8gQWRkIGxpc3Qtc3BlY2lmaWMgbWV0aG9kc1xuXHRcdGpRdWVyeS5lYWNoKCB0dXBsZXMsIGZ1bmN0aW9uKCBpLCB0dXBsZSApIHtcblx0XHRcdHZhciBsaXN0ID0gdHVwbGVbIDIgXSxcblx0XHRcdFx0c3RhdGVTdHJpbmcgPSB0dXBsZVsgMyBdO1xuXG5cdFx0XHQvLyBwcm9taXNlWyBkb25lIHwgZmFpbCB8IHByb2dyZXNzIF0gPSBsaXN0LmFkZFxuXHRcdFx0cHJvbWlzZVsgdHVwbGVbIDEgXSBdID0gbGlzdC5hZGQ7XG5cblx0XHRcdC8vIEhhbmRsZSBzdGF0ZVxuXHRcdFx0aWYgKCBzdGF0ZVN0cmluZyApIHtcblx0XHRcdFx0bGlzdC5hZGQoIGZ1bmN0aW9uKCkge1xuXG5cdFx0XHRcdFx0Ly8gc3RhdGUgPSBbIHJlc29sdmVkIHwgcmVqZWN0ZWQgXVxuXHRcdFx0XHRcdHN0YXRlID0gc3RhdGVTdHJpbmc7XG5cblx0XHRcdFx0Ly8gWyByZWplY3RfbGlzdCB8IHJlc29sdmVfbGlzdCBdLmRpc2FibGU7IHByb2dyZXNzX2xpc3QubG9ja1xuXHRcdFx0XHR9LCB0dXBsZXNbIGkgXiAxIF1bIDIgXS5kaXNhYmxlLCB0dXBsZXNbIDIgXVsgMiBdLmxvY2sgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gZGVmZXJyZWRbIHJlc29sdmUgfCByZWplY3QgfCBub3RpZnkgXVxuXHRcdFx0ZGVmZXJyZWRbIHR1cGxlWyAwIF0gXSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRkZWZlcnJlZFsgdHVwbGVbIDAgXSArIFwiV2l0aFwiIF0oIHRoaXMgPT09IGRlZmVycmVkID8gcHJvbWlzZSA6IHRoaXMsIGFyZ3VtZW50cyApO1xuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH07XG5cdFx0XHRkZWZlcnJlZFsgdHVwbGVbIDAgXSArIFwiV2l0aFwiIF0gPSBsaXN0LmZpcmVXaXRoO1xuXHRcdH0gKTtcblxuXHRcdC8vIE1ha2UgdGhlIGRlZmVycmVkIGEgcHJvbWlzZVxuXHRcdHByb21pc2UucHJvbWlzZSggZGVmZXJyZWQgKTtcblxuXHRcdC8vIENhbGwgZ2l2ZW4gZnVuYyBpZiBhbnlcblx0XHRpZiAoIGZ1bmMgKSB7XG5cdFx0XHRmdW5jLmNhbGwoIGRlZmVycmVkLCBkZWZlcnJlZCApO1xuXHRcdH1cblxuXHRcdC8vIEFsbCBkb25lIVxuXHRcdHJldHVybiBkZWZlcnJlZDtcblx0fSxcblxuXHQvLyBEZWZlcnJlZCBoZWxwZXJcblx0d2hlbjogZnVuY3Rpb24oIHN1Ym9yZGluYXRlIC8qICwgLi4uLCBzdWJvcmRpbmF0ZU4gKi8gKSB7XG5cdFx0dmFyIGkgPSAwLFxuXHRcdFx0cmVzb2x2ZVZhbHVlcyA9IHNsaWNlLmNhbGwoIGFyZ3VtZW50cyApLFxuXHRcdFx0bGVuZ3RoID0gcmVzb2x2ZVZhbHVlcy5sZW5ndGgsXG5cblx0XHRcdC8vIHRoZSBjb3VudCBvZiB1bmNvbXBsZXRlZCBzdWJvcmRpbmF0ZXNcblx0XHRcdHJlbWFpbmluZyA9IGxlbmd0aCAhPT0gMSB8fFxuXHRcdFx0XHQoIHN1Ym9yZGluYXRlICYmIGpRdWVyeS5pc0Z1bmN0aW9uKCBzdWJvcmRpbmF0ZS5wcm9taXNlICkgKSA/IGxlbmd0aCA6IDAsXG5cblx0XHRcdC8vIHRoZSBtYXN0ZXIgRGVmZXJyZWQuXG5cdFx0XHQvLyBJZiByZXNvbHZlVmFsdWVzIGNvbnNpc3Qgb2Ygb25seSBhIHNpbmdsZSBEZWZlcnJlZCwganVzdCB1c2UgdGhhdC5cblx0XHRcdGRlZmVycmVkID0gcmVtYWluaW5nID09PSAxID8gc3Vib3JkaW5hdGUgOiBqUXVlcnkuRGVmZXJyZWQoKSxcblxuXHRcdFx0Ly8gVXBkYXRlIGZ1bmN0aW9uIGZvciBib3RoIHJlc29sdmUgYW5kIHByb2dyZXNzIHZhbHVlc1xuXHRcdFx0dXBkYXRlRnVuYyA9IGZ1bmN0aW9uKCBpLCBjb250ZXh0cywgdmFsdWVzICkge1xuXHRcdFx0XHRyZXR1cm4gZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdFx0XHRcdGNvbnRleHRzWyBpIF0gPSB0aGlzO1xuXHRcdFx0XHRcdHZhbHVlc1sgaSBdID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBzbGljZS5jYWxsKCBhcmd1bWVudHMgKSA6IHZhbHVlO1xuXHRcdFx0XHRcdGlmICggdmFsdWVzID09PSBwcm9ncmVzc1ZhbHVlcyApIHtcblx0XHRcdFx0XHRcdGRlZmVycmVkLm5vdGlmeVdpdGgoIGNvbnRleHRzLCB2YWx1ZXMgKTtcblxuXHRcdFx0XHRcdH0gZWxzZSBpZiAoICEoIC0tcmVtYWluaW5nICkgKSB7XG5cdFx0XHRcdFx0XHRkZWZlcnJlZC5yZXNvbHZlV2l0aCggY29udGV4dHMsIHZhbHVlcyApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fTtcblx0XHRcdH0sXG5cblx0XHRcdHByb2dyZXNzVmFsdWVzLCBwcm9ncmVzc0NvbnRleHRzLCByZXNvbHZlQ29udGV4dHM7XG5cblx0XHQvLyBhZGQgbGlzdGVuZXJzIHRvIERlZmVycmVkIHN1Ym9yZGluYXRlczsgdHJlYXQgb3RoZXJzIGFzIHJlc29sdmVkXG5cdFx0aWYgKCBsZW5ndGggPiAxICkge1xuXHRcdFx0cHJvZ3Jlc3NWYWx1ZXMgPSBuZXcgQXJyYXkoIGxlbmd0aCApO1xuXHRcdFx0cHJvZ3Jlc3NDb250ZXh0cyA9IG5ldyBBcnJheSggbGVuZ3RoICk7XG5cdFx0XHRyZXNvbHZlQ29udGV4dHMgPSBuZXcgQXJyYXkoIGxlbmd0aCApO1xuXHRcdFx0Zm9yICggOyBpIDwgbGVuZ3RoOyBpKysgKSB7XG5cdFx0XHRcdGlmICggcmVzb2x2ZVZhbHVlc1sgaSBdICYmIGpRdWVyeS5pc0Z1bmN0aW9uKCByZXNvbHZlVmFsdWVzWyBpIF0ucHJvbWlzZSApICkge1xuXHRcdFx0XHRcdHJlc29sdmVWYWx1ZXNbIGkgXS5wcm9taXNlKClcblx0XHRcdFx0XHRcdC5wcm9ncmVzcyggdXBkYXRlRnVuYyggaSwgcHJvZ3Jlc3NDb250ZXh0cywgcHJvZ3Jlc3NWYWx1ZXMgKSApXG5cdFx0XHRcdFx0XHQuZG9uZSggdXBkYXRlRnVuYyggaSwgcmVzb2x2ZUNvbnRleHRzLCByZXNvbHZlVmFsdWVzICkgKVxuXHRcdFx0XHRcdFx0LmZhaWwoIGRlZmVycmVkLnJlamVjdCApO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdC0tcmVtYWluaW5nO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gaWYgd2UncmUgbm90IHdhaXRpbmcgb24gYW55dGhpbmcsIHJlc29sdmUgdGhlIG1hc3RlclxuXHRcdGlmICggIXJlbWFpbmluZyApIHtcblx0XHRcdGRlZmVycmVkLnJlc29sdmVXaXRoKCByZXNvbHZlQ29udGV4dHMsIHJlc29sdmVWYWx1ZXMgKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gZGVmZXJyZWQucHJvbWlzZSgpO1xuXHR9XG59ICk7XG5cblxuLy8gVGhlIGRlZmVycmVkIHVzZWQgb24gRE9NIHJlYWR5XG52YXIgcmVhZHlMaXN0O1xuXG5qUXVlcnkuZm4ucmVhZHkgPSBmdW5jdGlvbiggZm4gKSB7XG5cblx0Ly8gQWRkIHRoZSBjYWxsYmFja1xuXHRqUXVlcnkucmVhZHkucHJvbWlzZSgpLmRvbmUoIGZuICk7XG5cblx0cmV0dXJuIHRoaXM7XG59O1xuXG5qUXVlcnkuZXh0ZW5kKCB7XG5cblx0Ly8gSXMgdGhlIERPTSByZWFkeSB0byBiZSB1c2VkPyBTZXQgdG8gdHJ1ZSBvbmNlIGl0IG9jY3Vycy5cblx0aXNSZWFkeTogZmFsc2UsXG5cblx0Ly8gQSBjb3VudGVyIHRvIHRyYWNrIGhvdyBtYW55IGl0ZW1zIHRvIHdhaXQgZm9yIGJlZm9yZVxuXHQvLyB0aGUgcmVhZHkgZXZlbnQgZmlyZXMuIFNlZSAjNjc4MVxuXHRyZWFkeVdhaXQ6IDEsXG5cblx0Ly8gSG9sZCAob3IgcmVsZWFzZSkgdGhlIHJlYWR5IGV2ZW50XG5cdGhvbGRSZWFkeTogZnVuY3Rpb24oIGhvbGQgKSB7XG5cdFx0aWYgKCBob2xkICkge1xuXHRcdFx0alF1ZXJ5LnJlYWR5V2FpdCsrO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRqUXVlcnkucmVhZHkoIHRydWUgKTtcblx0XHR9XG5cdH0sXG5cblx0Ly8gSGFuZGxlIHdoZW4gdGhlIERPTSBpcyByZWFkeVxuXHRyZWFkeTogZnVuY3Rpb24oIHdhaXQgKSB7XG5cblx0XHQvLyBBYm9ydCBpZiB0aGVyZSBhcmUgcGVuZGluZyBob2xkcyBvciB3ZSdyZSBhbHJlYWR5IHJlYWR5XG5cdFx0aWYgKCB3YWl0ID09PSB0cnVlID8gLS1qUXVlcnkucmVhZHlXYWl0IDogalF1ZXJ5LmlzUmVhZHkgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gUmVtZW1iZXIgdGhhdCB0aGUgRE9NIGlzIHJlYWR5XG5cdFx0alF1ZXJ5LmlzUmVhZHkgPSB0cnVlO1xuXG5cdFx0Ly8gSWYgYSBub3JtYWwgRE9NIFJlYWR5IGV2ZW50IGZpcmVkLCBkZWNyZW1lbnQsIGFuZCB3YWl0IGlmIG5lZWQgYmVcblx0XHRpZiAoIHdhaXQgIT09IHRydWUgJiYgLS1qUXVlcnkucmVhZHlXYWl0ID4gMCApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBJZiB0aGVyZSBhcmUgZnVuY3Rpb25zIGJvdW5kLCB0byBleGVjdXRlXG5cdFx0cmVhZHlMaXN0LnJlc29sdmVXaXRoKCBkb2N1bWVudCwgWyBqUXVlcnkgXSApO1xuXG5cdFx0Ly8gVHJpZ2dlciBhbnkgYm91bmQgcmVhZHkgZXZlbnRzXG5cdFx0aWYgKCBqUXVlcnkuZm4udHJpZ2dlckhhbmRsZXIgKSB7XG5cdFx0XHRqUXVlcnkoIGRvY3VtZW50ICkudHJpZ2dlckhhbmRsZXIoIFwicmVhZHlcIiApO1xuXHRcdFx0alF1ZXJ5KCBkb2N1bWVudCApLm9mZiggXCJyZWFkeVwiICk7XG5cdFx0fVxuXHR9XG59ICk7XG5cbi8qKlxuICogQ2xlYW4tdXAgbWV0aG9kIGZvciBkb20gcmVhZHkgZXZlbnRzXG4gKi9cbmZ1bmN0aW9uIGRldGFjaCgpIHtcblx0aWYgKCBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyICkge1xuXHRcdGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoIFwiRE9NQ29udGVudExvYWRlZFwiLCBjb21wbGV0ZWQgKTtcblx0XHR3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lciggXCJsb2FkXCIsIGNvbXBsZXRlZCApO1xuXG5cdH0gZWxzZSB7XG5cdFx0ZG9jdW1lbnQuZGV0YWNoRXZlbnQoIFwib25yZWFkeXN0YXRlY2hhbmdlXCIsIGNvbXBsZXRlZCApO1xuXHRcdHdpbmRvdy5kZXRhY2hFdmVudCggXCJvbmxvYWRcIiwgY29tcGxldGVkICk7XG5cdH1cbn1cblxuLyoqXG4gKiBUaGUgcmVhZHkgZXZlbnQgaGFuZGxlciBhbmQgc2VsZiBjbGVhbnVwIG1ldGhvZFxuICovXG5mdW5jdGlvbiBjb21wbGV0ZWQoKSB7XG5cblx0Ly8gcmVhZHlTdGF0ZSA9PT0gXCJjb21wbGV0ZVwiIGlzIGdvb2QgZW5vdWdoIGZvciB1cyB0byBjYWxsIHRoZSBkb20gcmVhZHkgaW4gb2xkSUVcblx0aWYgKCBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyIHx8XG5cdFx0d2luZG93LmV2ZW50LnR5cGUgPT09IFwibG9hZFwiIHx8XG5cdFx0ZG9jdW1lbnQucmVhZHlTdGF0ZSA9PT0gXCJjb21wbGV0ZVwiICkge1xuXG5cdFx0ZGV0YWNoKCk7XG5cdFx0alF1ZXJ5LnJlYWR5KCk7XG5cdH1cbn1cblxualF1ZXJ5LnJlYWR5LnByb21pc2UgPSBmdW5jdGlvbiggb2JqICkge1xuXHRpZiAoICFyZWFkeUxpc3QgKSB7XG5cblx0XHRyZWFkeUxpc3QgPSBqUXVlcnkuRGVmZXJyZWQoKTtcblxuXHRcdC8vIENhdGNoIGNhc2VzIHdoZXJlICQoZG9jdW1lbnQpLnJlYWR5KCkgaXMgY2FsbGVkXG5cdFx0Ly8gYWZ0ZXIgdGhlIGJyb3dzZXIgZXZlbnQgaGFzIGFscmVhZHkgb2NjdXJyZWQuXG5cdFx0Ly8gU3VwcG9ydDogSUU2LTEwXG5cdFx0Ly8gT2xkZXIgSUUgc29tZXRpbWVzIHNpZ25hbHMgXCJpbnRlcmFjdGl2ZVwiIHRvbyBzb29uXG5cdFx0aWYgKCBkb2N1bWVudC5yZWFkeVN0YXRlID09PSBcImNvbXBsZXRlXCIgfHxcblx0XHRcdCggZG9jdW1lbnQucmVhZHlTdGF0ZSAhPT0gXCJsb2FkaW5nXCIgJiYgIWRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5kb1Njcm9sbCApICkge1xuXG5cdFx0XHQvLyBIYW5kbGUgaXQgYXN5bmNocm9ub3VzbHkgdG8gYWxsb3cgc2NyaXB0cyB0aGUgb3Bwb3J0dW5pdHkgdG8gZGVsYXkgcmVhZHlcblx0XHRcdHdpbmRvdy5zZXRUaW1lb3V0KCBqUXVlcnkucmVhZHkgKTtcblxuXHRcdC8vIFN0YW5kYXJkcy1iYXNlZCBicm93c2VycyBzdXBwb3J0IERPTUNvbnRlbnRMb2FkZWRcblx0XHR9IGVsc2UgaWYgKCBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyICkge1xuXG5cdFx0XHQvLyBVc2UgdGhlIGhhbmR5IGV2ZW50IGNhbGxiYWNrXG5cdFx0XHRkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCBcIkRPTUNvbnRlbnRMb2FkZWRcIiwgY29tcGxldGVkICk7XG5cblx0XHRcdC8vIEEgZmFsbGJhY2sgdG8gd2luZG93Lm9ubG9hZCwgdGhhdCB3aWxsIGFsd2F5cyB3b3JrXG5cdFx0XHR3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lciggXCJsb2FkXCIsIGNvbXBsZXRlZCApO1xuXG5cdFx0Ly8gSWYgSUUgZXZlbnQgbW9kZWwgaXMgdXNlZFxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdC8vIEVuc3VyZSBmaXJpbmcgYmVmb3JlIG9ubG9hZCwgbWF5YmUgbGF0ZSBidXQgc2FmZSBhbHNvIGZvciBpZnJhbWVzXG5cdFx0XHRkb2N1bWVudC5hdHRhY2hFdmVudCggXCJvbnJlYWR5c3RhdGVjaGFuZ2VcIiwgY29tcGxldGVkICk7XG5cblx0XHRcdC8vIEEgZmFsbGJhY2sgdG8gd2luZG93Lm9ubG9hZCwgdGhhdCB3aWxsIGFsd2F5cyB3b3JrXG5cdFx0XHR3aW5kb3cuYXR0YWNoRXZlbnQoIFwib25sb2FkXCIsIGNvbXBsZXRlZCApO1xuXG5cdFx0XHQvLyBJZiBJRSBhbmQgbm90IGEgZnJhbWVcblx0XHRcdC8vIGNvbnRpbnVhbGx5IGNoZWNrIHRvIHNlZSBpZiB0aGUgZG9jdW1lbnQgaXMgcmVhZHlcblx0XHRcdHZhciB0b3AgPSBmYWxzZTtcblxuXHRcdFx0dHJ5IHtcblx0XHRcdFx0dG9wID0gd2luZG93LmZyYW1lRWxlbWVudCA9PSBudWxsICYmIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcblx0XHRcdH0gY2F0Y2ggKCBlICkge31cblxuXHRcdFx0aWYgKCB0b3AgJiYgdG9wLmRvU2Nyb2xsICkge1xuXHRcdFx0XHQoIGZ1bmN0aW9uIGRvU2Nyb2xsQ2hlY2soKSB7XG5cdFx0XHRcdFx0aWYgKCAhalF1ZXJ5LmlzUmVhZHkgKSB7XG5cblx0XHRcdFx0XHRcdHRyeSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gVXNlIHRoZSB0cmljayBieSBEaWVnbyBQZXJpbmlcblx0XHRcdFx0XHRcdFx0Ly8gaHR0cDovL2phdmFzY3JpcHQubndib3guY29tL0lFQ29udGVudExvYWRlZC9cblx0XHRcdFx0XHRcdFx0dG9wLmRvU2Nyb2xsKCBcImxlZnRcIiApO1xuXHRcdFx0XHRcdFx0fSBjYXRjaCAoIGUgKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiB3aW5kb3cuc2V0VGltZW91dCggZG9TY3JvbGxDaGVjaywgNTAgKTtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0Ly8gZGV0YWNoIGFsbCBkb20gcmVhZHkgZXZlbnRzXG5cdFx0XHRcdFx0XHRkZXRhY2goKTtcblxuXHRcdFx0XHRcdFx0Ly8gYW5kIGV4ZWN1dGUgYW55IHdhaXRpbmcgZnVuY3Rpb25zXG5cdFx0XHRcdFx0XHRqUXVlcnkucmVhZHkoKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gKSgpO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXHRyZXR1cm4gcmVhZHlMaXN0LnByb21pc2UoIG9iaiApO1xufTtcblxuLy8gS2ljayBvZmYgdGhlIERPTSByZWFkeSBjaGVjayBldmVuIGlmIHRoZSB1c2VyIGRvZXMgbm90XG5qUXVlcnkucmVhZHkucHJvbWlzZSgpO1xuXG5cblxuXG4vLyBTdXBwb3J0OiBJRTw5XG4vLyBJdGVyYXRpb24gb3ZlciBvYmplY3QncyBpbmhlcml0ZWQgcHJvcGVydGllcyBiZWZvcmUgaXRzIG93blxudmFyIGk7XG5mb3IgKCBpIGluIGpRdWVyeSggc3VwcG9ydCApICkge1xuXHRicmVhaztcbn1cbnN1cHBvcnQub3duRmlyc3QgPSBpID09PSBcIjBcIjtcblxuLy8gTm90ZTogbW9zdCBzdXBwb3J0IHRlc3RzIGFyZSBkZWZpbmVkIGluIHRoZWlyIHJlc3BlY3RpdmUgbW9kdWxlcy5cbi8vIGZhbHNlIHVudGlsIHRoZSB0ZXN0IGlzIHJ1blxuc3VwcG9ydC5pbmxpbmVCbG9ja05lZWRzTGF5b3V0ID0gZmFsc2U7XG5cbi8vIEV4ZWN1dGUgQVNBUCBpbiBjYXNlIHdlIG5lZWQgdG8gc2V0IGJvZHkuc3R5bGUuem9vbVxualF1ZXJ5KCBmdW5jdGlvbigpIHtcblxuXHQvLyBNaW5pZmllZDogdmFyIGEsYixjLGRcblx0dmFyIHZhbCwgZGl2LCBib2R5LCBjb250YWluZXI7XG5cblx0Ym9keSA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCBcImJvZHlcIiApWyAwIF07XG5cdGlmICggIWJvZHkgfHwgIWJvZHkuc3R5bGUgKSB7XG5cblx0XHQvLyBSZXR1cm4gZm9yIGZyYW1lc2V0IGRvY3MgdGhhdCBkb24ndCBoYXZlIGEgYm9keVxuXHRcdHJldHVybjtcblx0fVxuXG5cdC8vIFNldHVwXG5cdGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiZGl2XCIgKTtcblx0Y29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJkaXZcIiApO1xuXHRjb250YWluZXIuc3R5bGUuY3NzVGV4dCA9IFwicG9zaXRpb246YWJzb2x1dGU7Ym9yZGVyOjA7d2lkdGg6MDtoZWlnaHQ6MDt0b3A6MDtsZWZ0Oi05OTk5cHhcIjtcblx0Ym9keS5hcHBlbmRDaGlsZCggY29udGFpbmVyICkuYXBwZW5kQ2hpbGQoIGRpdiApO1xuXG5cdGlmICggdHlwZW9mIGRpdi5zdHlsZS56b29tICE9PSBcInVuZGVmaW5lZFwiICkge1xuXG5cdFx0Ly8gU3VwcG9ydDogSUU8OFxuXHRcdC8vIENoZWNrIGlmIG5hdGl2ZWx5IGJsb2NrLWxldmVsIGVsZW1lbnRzIGFjdCBsaWtlIGlubGluZS1ibG9ja1xuXHRcdC8vIGVsZW1lbnRzIHdoZW4gc2V0dGluZyB0aGVpciBkaXNwbGF5IHRvICdpbmxpbmUnIGFuZCBnaXZpbmdcblx0XHQvLyB0aGVtIGxheW91dFxuXHRcdGRpdi5zdHlsZS5jc3NUZXh0ID0gXCJkaXNwbGF5OmlubGluZTttYXJnaW46MDtib3JkZXI6MDtwYWRkaW5nOjFweDt3aWR0aDoxcHg7em9vbToxXCI7XG5cblx0XHRzdXBwb3J0LmlubGluZUJsb2NrTmVlZHNMYXlvdXQgPSB2YWwgPSBkaXYub2Zmc2V0V2lkdGggPT09IDM7XG5cdFx0aWYgKCB2YWwgKSB7XG5cblx0XHRcdC8vIFByZXZlbnQgSUUgNiBmcm9tIGFmZmVjdGluZyBsYXlvdXQgZm9yIHBvc2l0aW9uZWQgZWxlbWVudHMgIzExMDQ4XG5cdFx0XHQvLyBQcmV2ZW50IElFIGZyb20gc2hyaW5raW5nIHRoZSBib2R5IGluIElFIDcgbW9kZSAjMTI4Njlcblx0XHRcdC8vIFN1cHBvcnQ6IElFPDhcblx0XHRcdGJvZHkuc3R5bGUuem9vbSA9IDE7XG5cdFx0fVxuXHR9XG5cblx0Ym9keS5yZW1vdmVDaGlsZCggY29udGFpbmVyICk7XG59ICk7XG5cblxuKCBmdW5jdGlvbigpIHtcblx0dmFyIGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiZGl2XCIgKTtcblxuXHQvLyBTdXBwb3J0OiBJRTw5XG5cdHN1cHBvcnQuZGVsZXRlRXhwYW5kbyA9IHRydWU7XG5cdHRyeSB7XG5cdFx0ZGVsZXRlIGRpdi50ZXN0O1xuXHR9IGNhdGNoICggZSApIHtcblx0XHRzdXBwb3J0LmRlbGV0ZUV4cGFuZG8gPSBmYWxzZTtcblx0fVxuXG5cdC8vIE51bGwgZWxlbWVudHMgdG8gYXZvaWQgbGVha3MgaW4gSUUuXG5cdGRpdiA9IG51bGw7XG59ICkoKTtcbnZhciBhY2NlcHREYXRhID0gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdHZhciBub0RhdGEgPSBqUXVlcnkubm9EYXRhWyAoIGVsZW0ubm9kZU5hbWUgKyBcIiBcIiApLnRvTG93ZXJDYXNlKCkgXSxcblx0XHRub2RlVHlwZSA9ICtlbGVtLm5vZGVUeXBlIHx8IDE7XG5cblx0Ly8gRG8gbm90IHNldCBkYXRhIG9uIG5vbi1lbGVtZW50IERPTSBub2RlcyBiZWNhdXNlIGl0IHdpbGwgbm90IGJlIGNsZWFyZWQgKCM4MzM1KS5cblx0cmV0dXJuIG5vZGVUeXBlICE9PSAxICYmIG5vZGVUeXBlICE9PSA5ID9cblx0XHRmYWxzZSA6XG5cblx0XHQvLyBOb2RlcyBhY2NlcHQgZGF0YSB1bmxlc3Mgb3RoZXJ3aXNlIHNwZWNpZmllZDsgcmVqZWN0aW9uIGNhbiBiZSBjb25kaXRpb25hbFxuXHRcdCFub0RhdGEgfHwgbm9EYXRhICE9PSB0cnVlICYmIGVsZW0uZ2V0QXR0cmlidXRlKCBcImNsYXNzaWRcIiApID09PSBub0RhdGE7XG59O1xuXG5cblxuXG52YXIgcmJyYWNlID0gL14oPzpcXHtbXFx3XFxXXSpcXH18XFxbW1xcd1xcV10qXFxdKSQvLFxuXHRybXVsdGlEYXNoID0gLyhbQS1aXSkvZztcblxuZnVuY3Rpb24gZGF0YUF0dHIoIGVsZW0sIGtleSwgZGF0YSApIHtcblxuXHQvLyBJZiBub3RoaW5nIHdhcyBmb3VuZCBpbnRlcm5hbGx5LCB0cnkgdG8gZmV0Y2ggYW55XG5cdC8vIGRhdGEgZnJvbSB0aGUgSFRNTDUgZGF0YS0qIGF0dHJpYnV0ZVxuXHRpZiAoIGRhdGEgPT09IHVuZGVmaW5lZCAmJiBlbGVtLm5vZGVUeXBlID09PSAxICkge1xuXG5cdFx0dmFyIG5hbWUgPSBcImRhdGEtXCIgKyBrZXkucmVwbGFjZSggcm11bHRpRGFzaCwgXCItJDFcIiApLnRvTG93ZXJDYXNlKCk7XG5cblx0XHRkYXRhID0gZWxlbS5nZXRBdHRyaWJ1dGUoIG5hbWUgKTtcblxuXHRcdGlmICggdHlwZW9mIGRhdGEgPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHR0cnkge1xuXHRcdFx0XHRkYXRhID0gZGF0YSA9PT0gXCJ0cnVlXCIgPyB0cnVlIDpcblx0XHRcdFx0XHRkYXRhID09PSBcImZhbHNlXCIgPyBmYWxzZSA6XG5cdFx0XHRcdFx0ZGF0YSA9PT0gXCJudWxsXCIgPyBudWxsIDpcblxuXHRcdFx0XHRcdC8vIE9ubHkgY29udmVydCB0byBhIG51bWJlciBpZiBpdCBkb2Vzbid0IGNoYW5nZSB0aGUgc3RyaW5nXG5cdFx0XHRcdFx0K2RhdGEgKyBcIlwiID09PSBkYXRhID8gK2RhdGEgOlxuXHRcdFx0XHRcdHJicmFjZS50ZXN0KCBkYXRhICkgPyBqUXVlcnkucGFyc2VKU09OKCBkYXRhICkgOlxuXHRcdFx0XHRcdGRhdGE7XG5cdFx0XHR9IGNhdGNoICggZSApIHt9XG5cblx0XHRcdC8vIE1ha2Ugc3VyZSB3ZSBzZXQgdGhlIGRhdGEgc28gaXQgaXNuJ3QgY2hhbmdlZCBsYXRlclxuXHRcdFx0alF1ZXJ5LmRhdGEoIGVsZW0sIGtleSwgZGF0YSApO1xuXG5cdFx0fSBlbHNlIHtcblx0XHRcdGRhdGEgPSB1bmRlZmluZWQ7XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIGRhdGE7XG59XG5cbi8vIGNoZWNrcyBhIGNhY2hlIG9iamVjdCBmb3IgZW1wdGluZXNzXG5mdW5jdGlvbiBpc0VtcHR5RGF0YU9iamVjdCggb2JqICkge1xuXHR2YXIgbmFtZTtcblx0Zm9yICggbmFtZSBpbiBvYmogKSB7XG5cblx0XHQvLyBpZiB0aGUgcHVibGljIGRhdGEgb2JqZWN0IGlzIGVtcHR5LCB0aGUgcHJpdmF0ZSBpcyBzdGlsbCBlbXB0eVxuXHRcdGlmICggbmFtZSA9PT0gXCJkYXRhXCIgJiYgalF1ZXJ5LmlzRW1wdHlPYmplY3QoIG9ialsgbmFtZSBdICkgKSB7XG5cdFx0XHRjb250aW51ZTtcblx0XHR9XG5cdFx0aWYgKCBuYW1lICE9PSBcInRvSlNPTlwiICkge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBpbnRlcm5hbERhdGEoIGVsZW0sIG5hbWUsIGRhdGEsIHB2dCAvKiBJbnRlcm5hbCBVc2UgT25seSAqLyApIHtcblx0aWYgKCAhYWNjZXB0RGF0YSggZWxlbSApICkge1xuXHRcdHJldHVybjtcblx0fVxuXG5cdHZhciByZXQsIHRoaXNDYWNoZSxcblx0XHRpbnRlcm5hbEtleSA9IGpRdWVyeS5leHBhbmRvLFxuXG5cdFx0Ly8gV2UgaGF2ZSB0byBoYW5kbGUgRE9NIG5vZGVzIGFuZCBKUyBvYmplY3RzIGRpZmZlcmVudGx5IGJlY2F1c2UgSUU2LTdcblx0XHQvLyBjYW4ndCBHQyBvYmplY3QgcmVmZXJlbmNlcyBwcm9wZXJseSBhY3Jvc3MgdGhlIERPTS1KUyBib3VuZGFyeVxuXHRcdGlzTm9kZSA9IGVsZW0ubm9kZVR5cGUsXG5cblx0XHQvLyBPbmx5IERPTSBub2RlcyBuZWVkIHRoZSBnbG9iYWwgalF1ZXJ5IGNhY2hlOyBKUyBvYmplY3QgZGF0YSBpc1xuXHRcdC8vIGF0dGFjaGVkIGRpcmVjdGx5IHRvIHRoZSBvYmplY3Qgc28gR0MgY2FuIG9jY3VyIGF1dG9tYXRpY2FsbHlcblx0XHRjYWNoZSA9IGlzTm9kZSA/IGpRdWVyeS5jYWNoZSA6IGVsZW0sXG5cblx0XHQvLyBPbmx5IGRlZmluaW5nIGFuIElEIGZvciBKUyBvYmplY3RzIGlmIGl0cyBjYWNoZSBhbHJlYWR5IGV4aXN0cyBhbGxvd3Ncblx0XHQvLyB0aGUgY29kZSB0byBzaG9ydGN1dCBvbiB0aGUgc2FtZSBwYXRoIGFzIGEgRE9NIG5vZGUgd2l0aCBubyBjYWNoZVxuXHRcdGlkID0gaXNOb2RlID8gZWxlbVsgaW50ZXJuYWxLZXkgXSA6IGVsZW1bIGludGVybmFsS2V5IF0gJiYgaW50ZXJuYWxLZXk7XG5cblx0Ly8gQXZvaWQgZG9pbmcgYW55IG1vcmUgd29yayB0aGFuIHdlIG5lZWQgdG8gd2hlbiB0cnlpbmcgdG8gZ2V0IGRhdGEgb24gYW5cblx0Ly8gb2JqZWN0IHRoYXQgaGFzIG5vIGRhdGEgYXQgYWxsXG5cdGlmICggKCAhaWQgfHwgIWNhY2hlWyBpZCBdIHx8ICggIXB2dCAmJiAhY2FjaGVbIGlkIF0uZGF0YSApICkgJiZcblx0XHRkYXRhID09PSB1bmRlZmluZWQgJiYgdHlwZW9mIG5hbWUgPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0aWYgKCAhaWQgKSB7XG5cblx0XHQvLyBPbmx5IERPTSBub2RlcyBuZWVkIGEgbmV3IHVuaXF1ZSBJRCBmb3IgZWFjaCBlbGVtZW50IHNpbmNlIHRoZWlyIGRhdGFcblx0XHQvLyBlbmRzIHVwIGluIHRoZSBnbG9iYWwgY2FjaGVcblx0XHRpZiAoIGlzTm9kZSApIHtcblx0XHRcdGlkID0gZWxlbVsgaW50ZXJuYWxLZXkgXSA9IGRlbGV0ZWRJZHMucG9wKCkgfHwgalF1ZXJ5Lmd1aWQrKztcblx0XHR9IGVsc2Uge1xuXHRcdFx0aWQgPSBpbnRlcm5hbEtleTtcblx0XHR9XG5cdH1cblxuXHRpZiAoICFjYWNoZVsgaWQgXSApIHtcblxuXHRcdC8vIEF2b2lkIGV4cG9zaW5nIGpRdWVyeSBtZXRhZGF0YSBvbiBwbGFpbiBKUyBvYmplY3RzIHdoZW4gdGhlIG9iamVjdFxuXHRcdC8vIGlzIHNlcmlhbGl6ZWQgdXNpbmcgSlNPTi5zdHJpbmdpZnlcblx0XHRjYWNoZVsgaWQgXSA9IGlzTm9kZSA/IHt9IDogeyB0b0pTT046IGpRdWVyeS5ub29wIH07XG5cdH1cblxuXHQvLyBBbiBvYmplY3QgY2FuIGJlIHBhc3NlZCB0byBqUXVlcnkuZGF0YSBpbnN0ZWFkIG9mIGEga2V5L3ZhbHVlIHBhaXI7IHRoaXMgZ2V0c1xuXHQvLyBzaGFsbG93IGNvcGllZCBvdmVyIG9udG8gdGhlIGV4aXN0aW5nIGNhY2hlXG5cdGlmICggdHlwZW9mIG5hbWUgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIG5hbWUgPT09IFwiZnVuY3Rpb25cIiApIHtcblx0XHRpZiAoIHB2dCApIHtcblx0XHRcdGNhY2hlWyBpZCBdID0galF1ZXJ5LmV4dGVuZCggY2FjaGVbIGlkIF0sIG5hbWUgKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Y2FjaGVbIGlkIF0uZGF0YSA9IGpRdWVyeS5leHRlbmQoIGNhY2hlWyBpZCBdLmRhdGEsIG5hbWUgKTtcblx0XHR9XG5cdH1cblxuXHR0aGlzQ2FjaGUgPSBjYWNoZVsgaWQgXTtcblxuXHQvLyBqUXVlcnkgZGF0YSgpIGlzIHN0b3JlZCBpbiBhIHNlcGFyYXRlIG9iamVjdCBpbnNpZGUgdGhlIG9iamVjdCdzIGludGVybmFsIGRhdGFcblx0Ly8gY2FjaGUgaW4gb3JkZXIgdG8gYXZvaWQga2V5IGNvbGxpc2lvbnMgYmV0d2VlbiBpbnRlcm5hbCBkYXRhIGFuZCB1c2VyLWRlZmluZWRcblx0Ly8gZGF0YS5cblx0aWYgKCAhcHZ0ICkge1xuXHRcdGlmICggIXRoaXNDYWNoZS5kYXRhICkge1xuXHRcdFx0dGhpc0NhY2hlLmRhdGEgPSB7fTtcblx0XHR9XG5cblx0XHR0aGlzQ2FjaGUgPSB0aGlzQ2FjaGUuZGF0YTtcblx0fVxuXG5cdGlmICggZGF0YSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdHRoaXNDYWNoZVsgalF1ZXJ5LmNhbWVsQ2FzZSggbmFtZSApIF0gPSBkYXRhO1xuXHR9XG5cblx0Ly8gQ2hlY2sgZm9yIGJvdGggY29udmVydGVkLXRvLWNhbWVsIGFuZCBub24tY29udmVydGVkIGRhdGEgcHJvcGVydHkgbmFtZXNcblx0Ly8gSWYgYSBkYXRhIHByb3BlcnR5IHdhcyBzcGVjaWZpZWRcblx0aWYgKCB0eXBlb2YgbmFtZSA9PT0gXCJzdHJpbmdcIiApIHtcblxuXHRcdC8vIEZpcnN0IFRyeSB0byBmaW5kIGFzLWlzIHByb3BlcnR5IGRhdGFcblx0XHRyZXQgPSB0aGlzQ2FjaGVbIG5hbWUgXTtcblxuXHRcdC8vIFRlc3QgZm9yIG51bGx8dW5kZWZpbmVkIHByb3BlcnR5IGRhdGFcblx0XHRpZiAoIHJldCA9PSBudWxsICkge1xuXG5cdFx0XHQvLyBUcnkgdG8gZmluZCB0aGUgY2FtZWxDYXNlZCBwcm9wZXJ0eVxuXHRcdFx0cmV0ID0gdGhpc0NhY2hlWyBqUXVlcnkuY2FtZWxDYXNlKCBuYW1lICkgXTtcblx0XHR9XG5cdH0gZWxzZSB7XG5cdFx0cmV0ID0gdGhpc0NhY2hlO1xuXHR9XG5cblx0cmV0dXJuIHJldDtcbn1cblxuZnVuY3Rpb24gaW50ZXJuYWxSZW1vdmVEYXRhKCBlbGVtLCBuYW1lLCBwdnQgKSB7XG5cdGlmICggIWFjY2VwdERhdGEoIGVsZW0gKSApIHtcblx0XHRyZXR1cm47XG5cdH1cblxuXHR2YXIgdGhpc0NhY2hlLCBpLFxuXHRcdGlzTm9kZSA9IGVsZW0ubm9kZVR5cGUsXG5cblx0XHQvLyBTZWUgalF1ZXJ5LmRhdGEgZm9yIG1vcmUgaW5mb3JtYXRpb25cblx0XHRjYWNoZSA9IGlzTm9kZSA/IGpRdWVyeS5jYWNoZSA6IGVsZW0sXG5cdFx0aWQgPSBpc05vZGUgPyBlbGVtWyBqUXVlcnkuZXhwYW5kbyBdIDogalF1ZXJ5LmV4cGFuZG87XG5cblx0Ly8gSWYgdGhlcmUgaXMgYWxyZWFkeSBubyBjYWNoZSBlbnRyeSBmb3IgdGhpcyBvYmplY3QsIHRoZXJlIGlzIG5vXG5cdC8vIHB1cnBvc2UgaW4gY29udGludWluZ1xuXHRpZiAoICFjYWNoZVsgaWQgXSApIHtcblx0XHRyZXR1cm47XG5cdH1cblxuXHRpZiAoIG5hbWUgKSB7XG5cblx0XHR0aGlzQ2FjaGUgPSBwdnQgPyBjYWNoZVsgaWQgXSA6IGNhY2hlWyBpZCBdLmRhdGE7XG5cblx0XHRpZiAoIHRoaXNDYWNoZSApIHtcblxuXHRcdFx0Ly8gU3VwcG9ydCBhcnJheSBvciBzcGFjZSBzZXBhcmF0ZWQgc3RyaW5nIG5hbWVzIGZvciBkYXRhIGtleXNcblx0XHRcdGlmICggIWpRdWVyeS5pc0FycmF5KCBuYW1lICkgKSB7XG5cblx0XHRcdFx0Ly8gdHJ5IHRoZSBzdHJpbmcgYXMgYSBrZXkgYmVmb3JlIGFueSBtYW5pcHVsYXRpb25cblx0XHRcdFx0aWYgKCBuYW1lIGluIHRoaXNDYWNoZSApIHtcblx0XHRcdFx0XHRuYW1lID0gWyBuYW1lIF07XG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHQvLyBzcGxpdCB0aGUgY2FtZWwgY2FzZWQgdmVyc2lvbiBieSBzcGFjZXMgdW5sZXNzIGEga2V5IHdpdGggdGhlIHNwYWNlcyBleGlzdHNcblx0XHRcdFx0XHRuYW1lID0galF1ZXJ5LmNhbWVsQ2FzZSggbmFtZSApO1xuXHRcdFx0XHRcdGlmICggbmFtZSBpbiB0aGlzQ2FjaGUgKSB7XG5cdFx0XHRcdFx0XHRuYW1lID0gWyBuYW1lIF07XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdG5hbWUgPSBuYW1lLnNwbGl0KCBcIiBcIiApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHQvLyBJZiBcIm5hbWVcIiBpcyBhbiBhcnJheSBvZiBrZXlzLi4uXG5cdFx0XHRcdC8vIFdoZW4gZGF0YSBpcyBpbml0aWFsbHkgY3JlYXRlZCwgdmlhIChcImtleVwiLCBcInZhbFwiKSBzaWduYXR1cmUsXG5cdFx0XHRcdC8vIGtleXMgd2lsbCBiZSBjb252ZXJ0ZWQgdG8gY2FtZWxDYXNlLlxuXHRcdFx0XHQvLyBTaW5jZSB0aGVyZSBpcyBubyB3YXkgdG8gdGVsbCBfaG93XyBhIGtleSB3YXMgYWRkZWQsIHJlbW92ZVxuXHRcdFx0XHQvLyBib3RoIHBsYWluIGtleSBhbmQgY2FtZWxDYXNlIGtleS4gIzEyNzg2XG5cdFx0XHRcdC8vIFRoaXMgd2lsbCBvbmx5IHBlbmFsaXplIHRoZSBhcnJheSBhcmd1bWVudCBwYXRoLlxuXHRcdFx0XHRuYW1lID0gbmFtZS5jb25jYXQoIGpRdWVyeS5tYXAoIG5hbWUsIGpRdWVyeS5jYW1lbENhc2UgKSApO1xuXHRcdFx0fVxuXG5cdFx0XHRpID0gbmFtZS5sZW5ndGg7XG5cdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0ZGVsZXRlIHRoaXNDYWNoZVsgbmFtZVsgaSBdIF07XG5cdFx0XHR9XG5cblx0XHRcdC8vIElmIHRoZXJlIGlzIG5vIGRhdGEgbGVmdCBpbiB0aGUgY2FjaGUsIHdlIHdhbnQgdG8gY29udGludWVcblx0XHRcdC8vIGFuZCBsZXQgdGhlIGNhY2hlIG9iamVjdCBpdHNlbGYgZ2V0IGRlc3Ryb3llZFxuXHRcdFx0aWYgKCBwdnQgPyAhaXNFbXB0eURhdGFPYmplY3QoIHRoaXNDYWNoZSApIDogIWpRdWVyeS5pc0VtcHR5T2JqZWN0KCB0aGlzQ2FjaGUgKSApIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8vIFNlZSBqUXVlcnkuZGF0YSBmb3IgbW9yZSBpbmZvcm1hdGlvblxuXHRpZiAoICFwdnQgKSB7XG5cdFx0ZGVsZXRlIGNhY2hlWyBpZCBdLmRhdGE7XG5cblx0XHQvLyBEb24ndCBkZXN0cm95IHRoZSBwYXJlbnQgY2FjaGUgdW5sZXNzIHRoZSBpbnRlcm5hbCBkYXRhIG9iamVjdFxuXHRcdC8vIGhhZCBiZWVuIHRoZSBvbmx5IHRoaW5nIGxlZnQgaW4gaXRcblx0XHRpZiAoICFpc0VtcHR5RGF0YU9iamVjdCggY2FjaGVbIGlkIF0gKSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdH1cblxuXHQvLyBEZXN0cm95IHRoZSBjYWNoZVxuXHRpZiAoIGlzTm9kZSApIHtcblx0XHRqUXVlcnkuY2xlYW5EYXRhKCBbIGVsZW0gXSwgdHJ1ZSApO1xuXG5cdC8vIFVzZSBkZWxldGUgd2hlbiBzdXBwb3J0ZWQgZm9yIGV4cGFuZG9zIG9yIGBjYWNoZWAgaXMgbm90IGEgd2luZG93IHBlciBpc1dpbmRvdyAoIzEwMDgwKVxuXHQvKiBqc2hpbnQgZXFlcWVxOiBmYWxzZSAqL1xuXHR9IGVsc2UgaWYgKCBzdXBwb3J0LmRlbGV0ZUV4cGFuZG8gfHwgY2FjaGUgIT0gY2FjaGUud2luZG93ICkge1xuXHRcdC8qIGpzaGludCBlcWVxZXE6IHRydWUgKi9cblx0XHRkZWxldGUgY2FjaGVbIGlkIF07XG5cblx0Ly8gV2hlbiBhbGwgZWxzZSBmYWlscywgdW5kZWZpbmVkXG5cdH0gZWxzZSB7XG5cdFx0Y2FjaGVbIGlkIF0gPSB1bmRlZmluZWQ7XG5cdH1cbn1cblxualF1ZXJ5LmV4dGVuZCgge1xuXHRjYWNoZToge30sXG5cblx0Ly8gVGhlIGZvbGxvd2luZyBlbGVtZW50cyAoc3BhY2Utc3VmZml4ZWQgdG8gYXZvaWQgT2JqZWN0LnByb3RvdHlwZSBjb2xsaXNpb25zKVxuXHQvLyB0aHJvdyB1bmNhdGNoYWJsZSBleGNlcHRpb25zIGlmIHlvdSBhdHRlbXB0IHRvIHNldCBleHBhbmRvIHByb3BlcnRpZXNcblx0bm9EYXRhOiB7XG5cdFx0XCJhcHBsZXQgXCI6IHRydWUsXG5cdFx0XCJlbWJlZCBcIjogdHJ1ZSxcblxuXHRcdC8vIC4uLmJ1dCBGbGFzaCBvYmplY3RzICh3aGljaCBoYXZlIHRoaXMgY2xhc3NpZCkgKmNhbiogaGFuZGxlIGV4cGFuZG9zXG5cdFx0XCJvYmplY3QgXCI6IFwiY2xzaWQ6RDI3Q0RCNkUtQUU2RC0xMWNmLTk2QjgtNDQ0NTUzNTQwMDAwXCJcblx0fSxcblxuXHRoYXNEYXRhOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRlbGVtID0gZWxlbS5ub2RlVHlwZSA/IGpRdWVyeS5jYWNoZVsgZWxlbVsgalF1ZXJ5LmV4cGFuZG8gXSBdIDogZWxlbVsgalF1ZXJ5LmV4cGFuZG8gXTtcblx0XHRyZXR1cm4gISFlbGVtICYmICFpc0VtcHR5RGF0YU9iamVjdCggZWxlbSApO1xuXHR9LFxuXG5cdGRhdGE6IGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCBkYXRhICkge1xuXHRcdHJldHVybiBpbnRlcm5hbERhdGEoIGVsZW0sIG5hbWUsIGRhdGEgKTtcblx0fSxcblxuXHRyZW1vdmVEYXRhOiBmdW5jdGlvbiggZWxlbSwgbmFtZSApIHtcblx0XHRyZXR1cm4gaW50ZXJuYWxSZW1vdmVEYXRhKCBlbGVtLCBuYW1lICk7XG5cdH0sXG5cblx0Ly8gRm9yIGludGVybmFsIHVzZSBvbmx5LlxuXHRfZGF0YTogZnVuY3Rpb24oIGVsZW0sIG5hbWUsIGRhdGEgKSB7XG5cdFx0cmV0dXJuIGludGVybmFsRGF0YSggZWxlbSwgbmFtZSwgZGF0YSwgdHJ1ZSApO1xuXHR9LFxuXG5cdF9yZW1vdmVEYXRhOiBmdW5jdGlvbiggZWxlbSwgbmFtZSApIHtcblx0XHRyZXR1cm4gaW50ZXJuYWxSZW1vdmVEYXRhKCBlbGVtLCBuYW1lLCB0cnVlICk7XG5cdH1cbn0gKTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRkYXRhOiBmdW5jdGlvbigga2V5LCB2YWx1ZSApIHtcblx0XHR2YXIgaSwgbmFtZSwgZGF0YSxcblx0XHRcdGVsZW0gPSB0aGlzWyAwIF0sXG5cdFx0XHRhdHRycyA9IGVsZW0gJiYgZWxlbS5hdHRyaWJ1dGVzO1xuXG5cdFx0Ly8gU3BlY2lhbCBleHBlY3Rpb25zIG9mIC5kYXRhIGJhc2ljYWxseSB0aHdhcnQgalF1ZXJ5LmFjY2Vzcyxcblx0XHQvLyBzbyBpbXBsZW1lbnQgdGhlIHJlbGV2YW50IGJlaGF2aW9yIG91cnNlbHZlc1xuXG5cdFx0Ly8gR2V0cyBhbGwgdmFsdWVzXG5cdFx0aWYgKCBrZXkgPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdGlmICggdGhpcy5sZW5ndGggKSB7XG5cdFx0XHRcdGRhdGEgPSBqUXVlcnkuZGF0YSggZWxlbSApO1xuXG5cdFx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSAmJiAhalF1ZXJ5Ll9kYXRhKCBlbGVtLCBcInBhcnNlZEF0dHJzXCIgKSApIHtcblx0XHRcdFx0XHRpID0gYXR0cnMubGVuZ3RoO1xuXHRcdFx0XHRcdHdoaWxlICggaS0tICkge1xuXG5cdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRTExK1xuXHRcdFx0XHRcdFx0Ly8gVGhlIGF0dHJzIGVsZW1lbnRzIGNhbiBiZSBudWxsICgjMTQ4OTQpXG5cdFx0XHRcdFx0XHRpZiAoIGF0dHJzWyBpIF0gKSB7XG5cdFx0XHRcdFx0XHRcdG5hbWUgPSBhdHRyc1sgaSBdLm5hbWU7XG5cdFx0XHRcdFx0XHRcdGlmICggbmFtZS5pbmRleE9mKCBcImRhdGEtXCIgKSA9PT0gMCApIHtcblx0XHRcdFx0XHRcdFx0XHRuYW1lID0galF1ZXJ5LmNhbWVsQ2FzZSggbmFtZS5zbGljZSggNSApICk7XG5cdFx0XHRcdFx0XHRcdFx0ZGF0YUF0dHIoIGVsZW0sIG5hbWUsIGRhdGFbIG5hbWUgXSApO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGpRdWVyeS5fZGF0YSggZWxlbSwgXCJwYXJzZWRBdHRyc1wiLCB0cnVlICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGRhdGE7XG5cdFx0fVxuXG5cdFx0Ly8gU2V0cyBtdWx0aXBsZSB2YWx1ZXNcblx0XHRpZiAoIHR5cGVvZiBrZXkgPT09IFwib2JqZWN0XCIgKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0alF1ZXJ5LmRhdGEoIHRoaXMsIGtleSApO1xuXHRcdFx0fSApO1xuXHRcdH1cblxuXHRcdHJldHVybiBhcmd1bWVudHMubGVuZ3RoID4gMSA/XG5cblx0XHRcdC8vIFNldHMgb25lIHZhbHVlXG5cdFx0XHR0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRqUXVlcnkuZGF0YSggdGhpcywga2V5LCB2YWx1ZSApO1xuXHRcdFx0fSApIDpcblxuXHRcdFx0Ly8gR2V0cyBvbmUgdmFsdWVcblx0XHRcdC8vIFRyeSB0byBmZXRjaCBhbnkgaW50ZXJuYWxseSBzdG9yZWQgZGF0YSBmaXJzdFxuXHRcdFx0ZWxlbSA/IGRhdGFBdHRyKCBlbGVtLCBrZXksIGpRdWVyeS5kYXRhKCBlbGVtLCBrZXkgKSApIDogdW5kZWZpbmVkO1xuXHR9LFxuXG5cdHJlbW92ZURhdGE6IGZ1bmN0aW9uKCBrZXkgKSB7XG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRqUXVlcnkucmVtb3ZlRGF0YSggdGhpcywga2V5ICk7XG5cdFx0fSApO1xuXHR9XG59ICk7XG5cblxualF1ZXJ5LmV4dGVuZCgge1xuXHRxdWV1ZTogZnVuY3Rpb24oIGVsZW0sIHR5cGUsIGRhdGEgKSB7XG5cdFx0dmFyIHF1ZXVlO1xuXG5cdFx0aWYgKCBlbGVtICkge1xuXHRcdFx0dHlwZSA9ICggdHlwZSB8fCBcImZ4XCIgKSArIFwicXVldWVcIjtcblx0XHRcdHF1ZXVlID0galF1ZXJ5Ll9kYXRhKCBlbGVtLCB0eXBlICk7XG5cblx0XHRcdC8vIFNwZWVkIHVwIGRlcXVldWUgYnkgZ2V0dGluZyBvdXQgcXVpY2tseSBpZiB0aGlzIGlzIGp1c3QgYSBsb29rdXBcblx0XHRcdGlmICggZGF0YSApIHtcblx0XHRcdFx0aWYgKCAhcXVldWUgfHwgalF1ZXJ5LmlzQXJyYXkoIGRhdGEgKSApIHtcblx0XHRcdFx0XHRxdWV1ZSA9IGpRdWVyeS5fZGF0YSggZWxlbSwgdHlwZSwgalF1ZXJ5Lm1ha2VBcnJheSggZGF0YSApICk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0cXVldWUucHVzaCggZGF0YSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcXVldWUgfHwgW107XG5cdFx0fVxuXHR9LFxuXG5cdGRlcXVldWU6IGZ1bmN0aW9uKCBlbGVtLCB0eXBlICkge1xuXHRcdHR5cGUgPSB0eXBlIHx8IFwiZnhcIjtcblxuXHRcdHZhciBxdWV1ZSA9IGpRdWVyeS5xdWV1ZSggZWxlbSwgdHlwZSApLFxuXHRcdFx0c3RhcnRMZW5ndGggPSBxdWV1ZS5sZW5ndGgsXG5cdFx0XHRmbiA9IHF1ZXVlLnNoaWZ0KCksXG5cdFx0XHRob29rcyA9IGpRdWVyeS5fcXVldWVIb29rcyggZWxlbSwgdHlwZSApLFxuXHRcdFx0bmV4dCA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRqUXVlcnkuZGVxdWV1ZSggZWxlbSwgdHlwZSApO1xuXHRcdFx0fTtcblxuXHRcdC8vIElmIHRoZSBmeCBxdWV1ZSBpcyBkZXF1ZXVlZCwgYWx3YXlzIHJlbW92ZSB0aGUgcHJvZ3Jlc3Mgc2VudGluZWxcblx0XHRpZiAoIGZuID09PSBcImlucHJvZ3Jlc3NcIiApIHtcblx0XHRcdGZuID0gcXVldWUuc2hpZnQoKTtcblx0XHRcdHN0YXJ0TGVuZ3RoLS07XG5cdFx0fVxuXG5cdFx0aWYgKCBmbiApIHtcblxuXHRcdFx0Ly8gQWRkIGEgcHJvZ3Jlc3Mgc2VudGluZWwgdG8gcHJldmVudCB0aGUgZnggcXVldWUgZnJvbSBiZWluZ1xuXHRcdFx0Ly8gYXV0b21hdGljYWxseSBkZXF1ZXVlZFxuXHRcdFx0aWYgKCB0eXBlID09PSBcImZ4XCIgKSB7XG5cdFx0XHRcdHF1ZXVlLnVuc2hpZnQoIFwiaW5wcm9ncmVzc1wiICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIGNsZWFyIHVwIHRoZSBsYXN0IHF1ZXVlIHN0b3AgZnVuY3Rpb25cblx0XHRcdGRlbGV0ZSBob29rcy5zdG9wO1xuXHRcdFx0Zm4uY2FsbCggZWxlbSwgbmV4dCwgaG9va3MgKTtcblx0XHR9XG5cblx0XHRpZiAoICFzdGFydExlbmd0aCAmJiBob29rcyApIHtcblx0XHRcdGhvb2tzLmVtcHR5LmZpcmUoKTtcblx0XHR9XG5cdH0sXG5cblx0Ly8gbm90IGludGVuZGVkIGZvciBwdWJsaWMgY29uc3VtcHRpb24gLSBnZW5lcmF0ZXMgYSBxdWV1ZUhvb2tzIG9iamVjdCxcblx0Ly8gb3IgcmV0dXJucyB0aGUgY3VycmVudCBvbmVcblx0X3F1ZXVlSG9va3M6IGZ1bmN0aW9uKCBlbGVtLCB0eXBlICkge1xuXHRcdHZhciBrZXkgPSB0eXBlICsgXCJxdWV1ZUhvb2tzXCI7XG5cdFx0cmV0dXJuIGpRdWVyeS5fZGF0YSggZWxlbSwga2V5ICkgfHwgalF1ZXJ5Ll9kYXRhKCBlbGVtLCBrZXksIHtcblx0XHRcdGVtcHR5OiBqUXVlcnkuQ2FsbGJhY2tzKCBcIm9uY2UgbWVtb3J5XCIgKS5hZGQoIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRqUXVlcnkuX3JlbW92ZURhdGEoIGVsZW0sIHR5cGUgKyBcInF1ZXVlXCIgKTtcblx0XHRcdFx0alF1ZXJ5Ll9yZW1vdmVEYXRhKCBlbGVtLCBrZXkgKTtcblx0XHRcdH0gKVxuXHRcdH0gKTtcblx0fVxufSApO1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdHF1ZXVlOiBmdW5jdGlvbiggdHlwZSwgZGF0YSApIHtcblx0XHR2YXIgc2V0dGVyID0gMjtcblxuXHRcdGlmICggdHlwZW9mIHR5cGUgIT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRkYXRhID0gdHlwZTtcblx0XHRcdHR5cGUgPSBcImZ4XCI7XG5cdFx0XHRzZXR0ZXItLTtcblx0XHR9XG5cblx0XHRpZiAoIGFyZ3VtZW50cy5sZW5ndGggPCBzZXR0ZXIgKSB7XG5cdFx0XHRyZXR1cm4galF1ZXJ5LnF1ZXVlKCB0aGlzWyAwIF0sIHR5cGUgKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gZGF0YSA9PT0gdW5kZWZpbmVkID9cblx0XHRcdHRoaXMgOlxuXHRcdFx0dGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIHF1ZXVlID0galF1ZXJ5LnF1ZXVlKCB0aGlzLCB0eXBlLCBkYXRhICk7XG5cblx0XHRcdFx0Ly8gZW5zdXJlIGEgaG9va3MgZm9yIHRoaXMgcXVldWVcblx0XHRcdFx0alF1ZXJ5Ll9xdWV1ZUhvb2tzKCB0aGlzLCB0eXBlICk7XG5cblx0XHRcdFx0aWYgKCB0eXBlID09PSBcImZ4XCIgJiYgcXVldWVbIDAgXSAhPT0gXCJpbnByb2dyZXNzXCIgKSB7XG5cdFx0XHRcdFx0alF1ZXJ5LmRlcXVldWUoIHRoaXMsIHR5cGUgKTtcblx0XHRcdFx0fVxuXHRcdFx0fSApO1xuXHR9LFxuXHRkZXF1ZXVlOiBmdW5jdGlvbiggdHlwZSApIHtcblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdGpRdWVyeS5kZXF1ZXVlKCB0aGlzLCB0eXBlICk7XG5cdFx0fSApO1xuXHR9LFxuXHRjbGVhclF1ZXVlOiBmdW5jdGlvbiggdHlwZSApIHtcblx0XHRyZXR1cm4gdGhpcy5xdWV1ZSggdHlwZSB8fCBcImZ4XCIsIFtdICk7XG5cdH0sXG5cblx0Ly8gR2V0IGEgcHJvbWlzZSByZXNvbHZlZCB3aGVuIHF1ZXVlcyBvZiBhIGNlcnRhaW4gdHlwZVxuXHQvLyBhcmUgZW1wdGllZCAoZnggaXMgdGhlIHR5cGUgYnkgZGVmYXVsdClcblx0cHJvbWlzZTogZnVuY3Rpb24oIHR5cGUsIG9iaiApIHtcblx0XHR2YXIgdG1wLFxuXHRcdFx0Y291bnQgPSAxLFxuXHRcdFx0ZGVmZXIgPSBqUXVlcnkuRGVmZXJyZWQoKSxcblx0XHRcdGVsZW1lbnRzID0gdGhpcyxcblx0XHRcdGkgPSB0aGlzLmxlbmd0aCxcblx0XHRcdHJlc29sdmUgPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKCAhKCAtLWNvdW50ICkgKSB7XG5cdFx0XHRcdFx0ZGVmZXIucmVzb2x2ZVdpdGgoIGVsZW1lbnRzLCBbIGVsZW1lbnRzIF0gKTtcblx0XHRcdFx0fVxuXHRcdFx0fTtcblxuXHRcdGlmICggdHlwZW9mIHR5cGUgIT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRvYmogPSB0eXBlO1xuXHRcdFx0dHlwZSA9IHVuZGVmaW5lZDtcblx0XHR9XG5cdFx0dHlwZSA9IHR5cGUgfHwgXCJmeFwiO1xuXG5cdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHR0bXAgPSBqUXVlcnkuX2RhdGEoIGVsZW1lbnRzWyBpIF0sIHR5cGUgKyBcInF1ZXVlSG9va3NcIiApO1xuXHRcdFx0aWYgKCB0bXAgJiYgdG1wLmVtcHR5ICkge1xuXHRcdFx0XHRjb3VudCsrO1xuXHRcdFx0XHR0bXAuZW1wdHkuYWRkKCByZXNvbHZlICk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJlc29sdmUoKTtcblx0XHRyZXR1cm4gZGVmZXIucHJvbWlzZSggb2JqICk7XG5cdH1cbn0gKTtcblxuXG4oIGZ1bmN0aW9uKCkge1xuXHR2YXIgc2hyaW5rV3JhcEJsb2Nrc1ZhbDtcblxuXHRzdXBwb3J0LnNocmlua1dyYXBCbG9ja3MgPSBmdW5jdGlvbigpIHtcblx0XHRpZiAoIHNocmlua1dyYXBCbG9ja3NWYWwgIT0gbnVsbCApIHtcblx0XHRcdHJldHVybiBzaHJpbmtXcmFwQmxvY2tzVmFsO1xuXHRcdH1cblxuXHRcdC8vIFdpbGwgYmUgY2hhbmdlZCBsYXRlciBpZiBuZWVkZWQuXG5cdFx0c2hyaW5rV3JhcEJsb2Nrc1ZhbCA9IGZhbHNlO1xuXG5cdFx0Ly8gTWluaWZpZWQ6IHZhciBiLGMsZFxuXHRcdHZhciBkaXYsIGJvZHksIGNvbnRhaW5lcjtcblxuXHRcdGJvZHkgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSggXCJib2R5XCIgKVsgMCBdO1xuXHRcdGlmICggIWJvZHkgfHwgIWJvZHkuc3R5bGUgKSB7XG5cblx0XHRcdC8vIFRlc3QgZmlyZWQgdG9vIGVhcmx5IG9yIGluIGFuIHVuc3VwcG9ydGVkIGVudmlyb25tZW50LCBleGl0LlxuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIFNldHVwXG5cdFx0ZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJkaXZcIiApO1xuXHRcdGNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiZGl2XCIgKTtcblx0XHRjb250YWluZXIuc3R5bGUuY3NzVGV4dCA9IFwicG9zaXRpb246YWJzb2x1dGU7Ym9yZGVyOjA7d2lkdGg6MDtoZWlnaHQ6MDt0b3A6MDtsZWZ0Oi05OTk5cHhcIjtcblx0XHRib2R5LmFwcGVuZENoaWxkKCBjb250YWluZXIgKS5hcHBlbmRDaGlsZCggZGl2ICk7XG5cblx0XHQvLyBTdXBwb3J0OiBJRTZcblx0XHQvLyBDaGVjayBpZiBlbGVtZW50cyB3aXRoIGxheW91dCBzaHJpbmstd3JhcCB0aGVpciBjaGlsZHJlblxuXHRcdGlmICggdHlwZW9mIGRpdi5zdHlsZS56b29tICE9PSBcInVuZGVmaW5lZFwiICkge1xuXG5cdFx0XHQvLyBSZXNldCBDU1M6IGJveC1zaXppbmc7IGRpc3BsYXk7IG1hcmdpbjsgYm9yZGVyXG5cdFx0XHRkaXYuc3R5bGUuY3NzVGV4dCA9XG5cblx0XHRcdFx0Ly8gU3VwcG9ydDogRmlyZWZveDwyOSwgQW5kcm9pZCAyLjNcblx0XHRcdFx0Ly8gVmVuZG9yLXByZWZpeCBib3gtc2l6aW5nXG5cdFx0XHRcdFwiLXdlYmtpdC1ib3gtc2l6aW5nOmNvbnRlbnQtYm94Oy1tb3otYm94LXNpemluZzpjb250ZW50LWJveDtcIiArXG5cdFx0XHRcdFwiYm94LXNpemluZzpjb250ZW50LWJveDtkaXNwbGF5OmJsb2NrO21hcmdpbjowO2JvcmRlcjowO1wiICtcblx0XHRcdFx0XCJwYWRkaW5nOjFweDt3aWR0aDoxcHg7em9vbToxXCI7XG5cdFx0XHRkaXYuYXBwZW5kQ2hpbGQoIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiZGl2XCIgKSApLnN0eWxlLndpZHRoID0gXCI1cHhcIjtcblx0XHRcdHNocmlua1dyYXBCbG9ja3NWYWwgPSBkaXYub2Zmc2V0V2lkdGggIT09IDM7XG5cdFx0fVxuXG5cdFx0Ym9keS5yZW1vdmVDaGlsZCggY29udGFpbmVyICk7XG5cblx0XHRyZXR1cm4gc2hyaW5rV3JhcEJsb2Nrc1ZhbDtcblx0fTtcblxufSApKCk7XG52YXIgcG51bSA9ICggL1srLV0/KD86XFxkKlxcLnwpXFxkKyg/OltlRV1bKy1dP1xcZCt8KS8gKS5zb3VyY2U7XG5cbnZhciByY3NzTnVtID0gbmV3IFJlZ0V4cCggXCJeKD86KFsrLV0pPXwpKFwiICsgcG51bSArIFwiKShbYS16JV0qKSRcIiwgXCJpXCIgKTtcblxuXG52YXIgY3NzRXhwYW5kID0gWyBcIlRvcFwiLCBcIlJpZ2h0XCIsIFwiQm90dG9tXCIsIFwiTGVmdFwiIF07XG5cbnZhciBpc0hpZGRlbiA9IGZ1bmN0aW9uKCBlbGVtLCBlbCApIHtcblxuXHRcdC8vIGlzSGlkZGVuIG1pZ2h0IGJlIGNhbGxlZCBmcm9tIGpRdWVyeSNmaWx0ZXIgZnVuY3Rpb247XG5cdFx0Ly8gaW4gdGhhdCBjYXNlLCBlbGVtZW50IHdpbGwgYmUgc2Vjb25kIGFyZ3VtZW50XG5cdFx0ZWxlbSA9IGVsIHx8IGVsZW07XG5cdFx0cmV0dXJuIGpRdWVyeS5jc3MoIGVsZW0sIFwiZGlzcGxheVwiICkgPT09IFwibm9uZVwiIHx8XG5cdFx0XHQhalF1ZXJ5LmNvbnRhaW5zKCBlbGVtLm93bmVyRG9jdW1lbnQsIGVsZW0gKTtcblx0fTtcblxuXG5cbmZ1bmN0aW9uIGFkanVzdENTUyggZWxlbSwgcHJvcCwgdmFsdWVQYXJ0cywgdHdlZW4gKSB7XG5cdHZhciBhZGp1c3RlZCxcblx0XHRzY2FsZSA9IDEsXG5cdFx0bWF4SXRlcmF0aW9ucyA9IDIwLFxuXHRcdGN1cnJlbnRWYWx1ZSA9IHR3ZWVuID9cblx0XHRcdGZ1bmN0aW9uKCkgeyByZXR1cm4gdHdlZW4uY3VyKCk7IH0gOlxuXHRcdFx0ZnVuY3Rpb24oKSB7IHJldHVybiBqUXVlcnkuY3NzKCBlbGVtLCBwcm9wLCBcIlwiICk7IH0sXG5cdFx0aW5pdGlhbCA9IGN1cnJlbnRWYWx1ZSgpLFxuXHRcdHVuaXQgPSB2YWx1ZVBhcnRzICYmIHZhbHVlUGFydHNbIDMgXSB8fCAoIGpRdWVyeS5jc3NOdW1iZXJbIHByb3AgXSA/IFwiXCIgOiBcInB4XCIgKSxcblxuXHRcdC8vIFN0YXJ0aW5nIHZhbHVlIGNvbXB1dGF0aW9uIGlzIHJlcXVpcmVkIGZvciBwb3RlbnRpYWwgdW5pdCBtaXNtYXRjaGVzXG5cdFx0aW5pdGlhbEluVW5pdCA9ICggalF1ZXJ5LmNzc051bWJlclsgcHJvcCBdIHx8IHVuaXQgIT09IFwicHhcIiAmJiAraW5pdGlhbCApICYmXG5cdFx0XHRyY3NzTnVtLmV4ZWMoIGpRdWVyeS5jc3MoIGVsZW0sIHByb3AgKSApO1xuXG5cdGlmICggaW5pdGlhbEluVW5pdCAmJiBpbml0aWFsSW5Vbml0WyAzIF0gIT09IHVuaXQgKSB7XG5cblx0XHQvLyBUcnVzdCB1bml0cyByZXBvcnRlZCBieSBqUXVlcnkuY3NzXG5cdFx0dW5pdCA9IHVuaXQgfHwgaW5pdGlhbEluVW5pdFsgMyBdO1xuXG5cdFx0Ly8gTWFrZSBzdXJlIHdlIHVwZGF0ZSB0aGUgdHdlZW4gcHJvcGVydGllcyBsYXRlciBvblxuXHRcdHZhbHVlUGFydHMgPSB2YWx1ZVBhcnRzIHx8IFtdO1xuXG5cdFx0Ly8gSXRlcmF0aXZlbHkgYXBwcm94aW1hdGUgZnJvbSBhIG5vbnplcm8gc3RhcnRpbmcgcG9pbnRcblx0XHRpbml0aWFsSW5Vbml0ID0gK2luaXRpYWwgfHwgMTtcblxuXHRcdGRvIHtcblxuXHRcdFx0Ly8gSWYgcHJldmlvdXMgaXRlcmF0aW9uIHplcm9lZCBvdXQsIGRvdWJsZSB1bnRpbCB3ZSBnZXQgKnNvbWV0aGluZyouXG5cdFx0XHQvLyBVc2Ugc3RyaW5nIGZvciBkb3VibGluZyBzbyB3ZSBkb24ndCBhY2NpZGVudGFsbHkgc2VlIHNjYWxlIGFzIHVuY2hhbmdlZCBiZWxvd1xuXHRcdFx0c2NhbGUgPSBzY2FsZSB8fCBcIi41XCI7XG5cblx0XHRcdC8vIEFkanVzdCBhbmQgYXBwbHlcblx0XHRcdGluaXRpYWxJblVuaXQgPSBpbml0aWFsSW5Vbml0IC8gc2NhbGU7XG5cdFx0XHRqUXVlcnkuc3R5bGUoIGVsZW0sIHByb3AsIGluaXRpYWxJblVuaXQgKyB1bml0ICk7XG5cblx0XHQvLyBVcGRhdGUgc2NhbGUsIHRvbGVyYXRpbmcgemVybyBvciBOYU4gZnJvbSB0d2Vlbi5jdXIoKVxuXHRcdC8vIEJyZWFrIHRoZSBsb29wIGlmIHNjYWxlIGlzIHVuY2hhbmdlZCBvciBwZXJmZWN0LCBvciBpZiB3ZSd2ZSBqdXN0IGhhZCBlbm91Z2guXG5cdFx0fSB3aGlsZSAoXG5cdFx0XHRzY2FsZSAhPT0gKCBzY2FsZSA9IGN1cnJlbnRWYWx1ZSgpIC8gaW5pdGlhbCApICYmIHNjYWxlICE9PSAxICYmIC0tbWF4SXRlcmF0aW9uc1xuXHRcdCk7XG5cdH1cblxuXHRpZiAoIHZhbHVlUGFydHMgKSB7XG5cdFx0aW5pdGlhbEluVW5pdCA9ICtpbml0aWFsSW5Vbml0IHx8ICtpbml0aWFsIHx8IDA7XG5cblx0XHQvLyBBcHBseSByZWxhdGl2ZSBvZmZzZXQgKCs9Ly09KSBpZiBzcGVjaWZpZWRcblx0XHRhZGp1c3RlZCA9IHZhbHVlUGFydHNbIDEgXSA/XG5cdFx0XHRpbml0aWFsSW5Vbml0ICsgKCB2YWx1ZVBhcnRzWyAxIF0gKyAxICkgKiB2YWx1ZVBhcnRzWyAyIF0gOlxuXHRcdFx0K3ZhbHVlUGFydHNbIDIgXTtcblx0XHRpZiAoIHR3ZWVuICkge1xuXHRcdFx0dHdlZW4udW5pdCA9IHVuaXQ7XG5cdFx0XHR0d2Vlbi5zdGFydCA9IGluaXRpYWxJblVuaXQ7XG5cdFx0XHR0d2Vlbi5lbmQgPSBhZGp1c3RlZDtcblx0XHR9XG5cdH1cblx0cmV0dXJuIGFkanVzdGVkO1xufVxuXG5cbi8vIE11bHRpZnVuY3Rpb25hbCBtZXRob2QgdG8gZ2V0IGFuZCBzZXQgdmFsdWVzIG9mIGEgY29sbGVjdGlvblxuLy8gVGhlIHZhbHVlL3MgY2FuIG9wdGlvbmFsbHkgYmUgZXhlY3V0ZWQgaWYgaXQncyBhIGZ1bmN0aW9uXG52YXIgYWNjZXNzID0gZnVuY3Rpb24oIGVsZW1zLCBmbiwga2V5LCB2YWx1ZSwgY2hhaW5hYmxlLCBlbXB0eUdldCwgcmF3ICkge1xuXHR2YXIgaSA9IDAsXG5cdFx0bGVuZ3RoID0gZWxlbXMubGVuZ3RoLFxuXHRcdGJ1bGsgPSBrZXkgPT0gbnVsbDtcblxuXHQvLyBTZXRzIG1hbnkgdmFsdWVzXG5cdGlmICggalF1ZXJ5LnR5cGUoIGtleSApID09PSBcIm9iamVjdFwiICkge1xuXHRcdGNoYWluYWJsZSA9IHRydWU7XG5cdFx0Zm9yICggaSBpbiBrZXkgKSB7XG5cdFx0XHRhY2Nlc3MoIGVsZW1zLCBmbiwgaSwga2V5WyBpIF0sIHRydWUsIGVtcHR5R2V0LCByYXcgKTtcblx0XHR9XG5cblx0Ly8gU2V0cyBvbmUgdmFsdWVcblx0fSBlbHNlIGlmICggdmFsdWUgIT09IHVuZGVmaW5lZCApIHtcblx0XHRjaGFpbmFibGUgPSB0cnVlO1xuXG5cdFx0aWYgKCAhalF1ZXJ5LmlzRnVuY3Rpb24oIHZhbHVlICkgKSB7XG5cdFx0XHRyYXcgPSB0cnVlO1xuXHRcdH1cblxuXHRcdGlmICggYnVsayApIHtcblxuXHRcdFx0Ly8gQnVsayBvcGVyYXRpb25zIHJ1biBhZ2FpbnN0IHRoZSBlbnRpcmUgc2V0XG5cdFx0XHRpZiAoIHJhdyApIHtcblx0XHRcdFx0Zm4uY2FsbCggZWxlbXMsIHZhbHVlICk7XG5cdFx0XHRcdGZuID0gbnVsbDtcblxuXHRcdFx0Ly8gLi4uZXhjZXB0IHdoZW4gZXhlY3V0aW5nIGZ1bmN0aW9uIHZhbHVlc1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0YnVsayA9IGZuO1xuXHRcdFx0XHRmbiA9IGZ1bmN0aW9uKCBlbGVtLCBrZXksIHZhbHVlICkge1xuXHRcdFx0XHRcdHJldHVybiBidWxrLmNhbGwoIGpRdWVyeSggZWxlbSApLCB2YWx1ZSApO1xuXHRcdFx0XHR9O1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmICggZm4gKSB7XG5cdFx0XHRmb3IgKCA7IGkgPCBsZW5ndGg7IGkrKyApIHtcblx0XHRcdFx0Zm4oXG5cdFx0XHRcdFx0ZWxlbXNbIGkgXSxcblx0XHRcdFx0XHRrZXksXG5cdFx0XHRcdFx0cmF3ID8gdmFsdWUgOiB2YWx1ZS5jYWxsKCBlbGVtc1sgaSBdLCBpLCBmbiggZWxlbXNbIGkgXSwga2V5ICkgKVxuXHRcdFx0XHQpO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiBjaGFpbmFibGUgP1xuXHRcdGVsZW1zIDpcblxuXHRcdC8vIEdldHNcblx0XHRidWxrID9cblx0XHRcdGZuLmNhbGwoIGVsZW1zICkgOlxuXHRcdFx0bGVuZ3RoID8gZm4oIGVsZW1zWyAwIF0sIGtleSApIDogZW1wdHlHZXQ7XG59O1xudmFyIHJjaGVja2FibGVUeXBlID0gKCAvXig/OmNoZWNrYm94fHJhZGlvKSQvaSApO1xuXG52YXIgcnRhZ05hbWUgPSAoIC88KFtcXHc6LV0rKS8gKTtcblxudmFyIHJzY3JpcHRUeXBlID0gKCAvXiR8XFwvKD86amF2YXxlY21hKXNjcmlwdC9pICk7XG5cbnZhciBybGVhZGluZ1doaXRlc3BhY2UgPSAoIC9eXFxzKy8gKTtcblxudmFyIG5vZGVOYW1lcyA9IFwiYWJicnxhcnRpY2xlfGFzaWRlfGF1ZGlvfGJkaXxjYW52YXN8ZGF0YXxkYXRhbGlzdHxcIiArXG5cdFx0XCJkZXRhaWxzfGRpYWxvZ3xmaWdjYXB0aW9ufGZpZ3VyZXxmb290ZXJ8aGVhZGVyfGhncm91cHxtYWlufFwiICtcblx0XHRcIm1hcmt8bWV0ZXJ8bmF2fG91dHB1dHxwaWN0dXJlfHByb2dyZXNzfHNlY3Rpb258c3VtbWFyeXx0ZW1wbGF0ZXx0aW1lfHZpZGVvXCI7XG5cblxuXG5mdW5jdGlvbiBjcmVhdGVTYWZlRnJhZ21lbnQoIGRvY3VtZW50ICkge1xuXHR2YXIgbGlzdCA9IG5vZGVOYW1lcy5zcGxpdCggXCJ8XCIgKSxcblx0XHRzYWZlRnJhZyA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcblxuXHRpZiAoIHNhZmVGcmFnLmNyZWF0ZUVsZW1lbnQgKSB7XG5cdFx0d2hpbGUgKCBsaXN0Lmxlbmd0aCApIHtcblx0XHRcdHNhZmVGcmFnLmNyZWF0ZUVsZW1lbnQoXG5cdFx0XHRcdGxpc3QucG9wKClcblx0XHRcdCk7XG5cdFx0fVxuXHR9XG5cdHJldHVybiBzYWZlRnJhZztcbn1cblxuXG4oIGZ1bmN0aW9uKCkge1xuXHR2YXIgZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJkaXZcIiApLFxuXHRcdGZyYWdtZW50ID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpLFxuXHRcdGlucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJpbnB1dFwiICk7XG5cblx0Ly8gU2V0dXBcblx0ZGl2LmlubmVySFRNTCA9IFwiICA8bGluay8+PHRhYmxlPjwvdGFibGU+PGEgaHJlZj0nL2EnPmE8L2E+PGlucHV0IHR5cGU9J2NoZWNrYm94Jy8+XCI7XG5cblx0Ly8gSUUgc3RyaXBzIGxlYWRpbmcgd2hpdGVzcGFjZSB3aGVuIC5pbm5lckhUTUwgaXMgdXNlZFxuXHRzdXBwb3J0LmxlYWRpbmdXaGl0ZXNwYWNlID0gZGl2LmZpcnN0Q2hpbGQubm9kZVR5cGUgPT09IDM7XG5cblx0Ly8gTWFrZSBzdXJlIHRoYXQgdGJvZHkgZWxlbWVudHMgYXJlbid0IGF1dG9tYXRpY2FsbHkgaW5zZXJ0ZWRcblx0Ly8gSUUgd2lsbCBpbnNlcnQgdGhlbSBpbnRvIGVtcHR5IHRhYmxlc1xuXHRzdXBwb3J0LnRib2R5ID0gIWRpdi5nZXRFbGVtZW50c0J5VGFnTmFtZSggXCJ0Ym9keVwiICkubGVuZ3RoO1xuXG5cdC8vIE1ha2Ugc3VyZSB0aGF0IGxpbmsgZWxlbWVudHMgZ2V0IHNlcmlhbGl6ZWQgY29ycmVjdGx5IGJ5IGlubmVySFRNTFxuXHQvLyBUaGlzIHJlcXVpcmVzIGEgd3JhcHBlciBlbGVtZW50IGluIElFXG5cdHN1cHBvcnQuaHRtbFNlcmlhbGl6ZSA9ICEhZGl2LmdldEVsZW1lbnRzQnlUYWdOYW1lKCBcImxpbmtcIiApLmxlbmd0aDtcblxuXHQvLyBNYWtlcyBzdXJlIGNsb25pbmcgYW4gaHRtbDUgZWxlbWVudCBkb2VzIG5vdCBjYXVzZSBwcm9ibGVtc1xuXHQvLyBXaGVyZSBvdXRlckhUTUwgaXMgdW5kZWZpbmVkLCB0aGlzIHN0aWxsIHdvcmtzXG5cdHN1cHBvcnQuaHRtbDVDbG9uZSA9XG5cdFx0ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJuYXZcIiApLmNsb25lTm9kZSggdHJ1ZSApLm91dGVySFRNTCAhPT0gXCI8Om5hdj48LzpuYXY+XCI7XG5cblx0Ly8gQ2hlY2sgaWYgYSBkaXNjb25uZWN0ZWQgY2hlY2tib3ggd2lsbCByZXRhaW4gaXRzIGNoZWNrZWRcblx0Ly8gdmFsdWUgb2YgdHJ1ZSBhZnRlciBhcHBlbmRlZCB0byB0aGUgRE9NIChJRTYvNylcblx0aW5wdXQudHlwZSA9IFwiY2hlY2tib3hcIjtcblx0aW5wdXQuY2hlY2tlZCA9IHRydWU7XG5cdGZyYWdtZW50LmFwcGVuZENoaWxkKCBpbnB1dCApO1xuXHRzdXBwb3J0LmFwcGVuZENoZWNrZWQgPSBpbnB1dC5jaGVja2VkO1xuXG5cdC8vIE1ha2Ugc3VyZSB0ZXh0YXJlYSAoYW5kIGNoZWNrYm94KSBkZWZhdWx0VmFsdWUgaXMgcHJvcGVybHkgY2xvbmVkXG5cdC8vIFN1cHBvcnQ6IElFNi1JRTExK1xuXHRkaXYuaW5uZXJIVE1MID0gXCI8dGV4dGFyZWE+eDwvdGV4dGFyZWE+XCI7XG5cdHN1cHBvcnQubm9DbG9uZUNoZWNrZWQgPSAhIWRpdi5jbG9uZU5vZGUoIHRydWUgKS5sYXN0Q2hpbGQuZGVmYXVsdFZhbHVlO1xuXG5cdC8vICMxMTIxNyAtIFdlYktpdCBsb3NlcyBjaGVjayB3aGVuIHRoZSBuYW1lIGlzIGFmdGVyIHRoZSBjaGVja2VkIGF0dHJpYnV0ZVxuXHRmcmFnbWVudC5hcHBlbmRDaGlsZCggZGl2ICk7XG5cblx0Ly8gU3VwcG9ydDogV2luZG93cyBXZWIgQXBwcyAoV1dBKVxuXHQvLyBgbmFtZWAgYW5kIGB0eXBlYCBtdXN0IHVzZSAuc2V0QXR0cmlidXRlIGZvciBXV0EgKCMxNDkwMSlcblx0aW5wdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImlucHV0XCIgKTtcblx0aW5wdXQuc2V0QXR0cmlidXRlKCBcInR5cGVcIiwgXCJyYWRpb1wiICk7XG5cdGlucHV0LnNldEF0dHJpYnV0ZSggXCJjaGVja2VkXCIsIFwiY2hlY2tlZFwiICk7XG5cdGlucHV0LnNldEF0dHJpYnV0ZSggXCJuYW1lXCIsIFwidFwiICk7XG5cblx0ZGl2LmFwcGVuZENoaWxkKCBpbnB1dCApO1xuXG5cdC8vIFN1cHBvcnQ6IFNhZmFyaSA1LjEsIGlPUyA1LjEsIEFuZHJvaWQgNC54LCBBbmRyb2lkIDIuM1xuXHQvLyBvbGQgV2ViS2l0IGRvZXNuJ3QgY2xvbmUgY2hlY2tlZCBzdGF0ZSBjb3JyZWN0bHkgaW4gZnJhZ21lbnRzXG5cdHN1cHBvcnQuY2hlY2tDbG9uZSA9IGRpdi5jbG9uZU5vZGUoIHRydWUgKS5jbG9uZU5vZGUoIHRydWUgKS5sYXN0Q2hpbGQuY2hlY2tlZDtcblxuXHQvLyBTdXBwb3J0OiBJRTw5XG5cdC8vIENsb25lZCBlbGVtZW50cyBrZWVwIGF0dGFjaEV2ZW50IGhhbmRsZXJzLCB3ZSB1c2UgYWRkRXZlbnRMaXN0ZW5lciBvbiBJRTkrXG5cdHN1cHBvcnQubm9DbG9uZUV2ZW50ID0gISFkaXYuYWRkRXZlbnRMaXN0ZW5lcjtcblxuXHQvLyBTdXBwb3J0OiBJRTw5XG5cdC8vIFNpbmNlIGF0dHJpYnV0ZXMgYW5kIHByb3BlcnRpZXMgYXJlIHRoZSBzYW1lIGluIElFLFxuXHQvLyBjbGVhbkRhdGEgbXVzdCBzZXQgcHJvcGVydGllcyB0byB1bmRlZmluZWQgcmF0aGVyIHRoYW4gdXNlIHJlbW92ZUF0dHJpYnV0ZVxuXHRkaXZbIGpRdWVyeS5leHBhbmRvIF0gPSAxO1xuXHRzdXBwb3J0LmF0dHJpYnV0ZXMgPSAhZGl2LmdldEF0dHJpYnV0ZSggalF1ZXJ5LmV4cGFuZG8gKTtcbn0gKSgpO1xuXG5cbi8vIFdlIGhhdmUgdG8gY2xvc2UgdGhlc2UgdGFncyB0byBzdXBwb3J0IFhIVE1MICgjMTMyMDApXG52YXIgd3JhcE1hcCA9IHtcblx0b3B0aW9uOiBbIDEsIFwiPHNlbGVjdCBtdWx0aXBsZT0nbXVsdGlwbGUnPlwiLCBcIjwvc2VsZWN0PlwiIF0sXG5cdGxlZ2VuZDogWyAxLCBcIjxmaWVsZHNldD5cIiwgXCI8L2ZpZWxkc2V0PlwiIF0sXG5cdGFyZWE6IFsgMSwgXCI8bWFwPlwiLCBcIjwvbWFwPlwiIF0sXG5cblx0Ly8gU3VwcG9ydDogSUU4XG5cdHBhcmFtOiBbIDEsIFwiPG9iamVjdD5cIiwgXCI8L29iamVjdD5cIiBdLFxuXHR0aGVhZDogWyAxLCBcIjx0YWJsZT5cIiwgXCI8L3RhYmxlPlwiIF0sXG5cdHRyOiBbIDIsIFwiPHRhYmxlPjx0Ym9keT5cIiwgXCI8L3Rib2R5PjwvdGFibGU+XCIgXSxcblx0Y29sOiBbIDIsIFwiPHRhYmxlPjx0Ym9keT48L3Rib2R5Pjxjb2xncm91cD5cIiwgXCI8L2NvbGdyb3VwPjwvdGFibGU+XCIgXSxcblx0dGQ6IFsgMywgXCI8dGFibGU+PHRib2R5Pjx0cj5cIiwgXCI8L3RyPjwvdGJvZHk+PC90YWJsZT5cIiBdLFxuXG5cdC8vIElFNi04IGNhbid0IHNlcmlhbGl6ZSBsaW5rLCBzY3JpcHQsIHN0eWxlLCBvciBhbnkgaHRtbDUgKE5vU2NvcGUpIHRhZ3MsXG5cdC8vIHVubGVzcyB3cmFwcGVkIGluIGEgZGl2IHdpdGggbm9uLWJyZWFraW5nIGNoYXJhY3RlcnMgaW4gZnJvbnQgb2YgaXQuXG5cdF9kZWZhdWx0OiBzdXBwb3J0Lmh0bWxTZXJpYWxpemUgPyBbIDAsIFwiXCIsIFwiXCIgXSA6IFsgMSwgXCJYPGRpdj5cIiwgXCI8L2Rpdj5cIiBdXG59O1xuXG4vLyBTdXBwb3J0OiBJRTgtSUU5XG53cmFwTWFwLm9wdGdyb3VwID0gd3JhcE1hcC5vcHRpb247XG5cbndyYXBNYXAudGJvZHkgPSB3cmFwTWFwLnRmb290ID0gd3JhcE1hcC5jb2xncm91cCA9IHdyYXBNYXAuY2FwdGlvbiA9IHdyYXBNYXAudGhlYWQ7XG53cmFwTWFwLnRoID0gd3JhcE1hcC50ZDtcblxuXG5mdW5jdGlvbiBnZXRBbGwoIGNvbnRleHQsIHRhZyApIHtcblx0dmFyIGVsZW1zLCBlbGVtLFxuXHRcdGkgPSAwLFxuXHRcdGZvdW5kID0gdHlwZW9mIGNvbnRleHQuZ2V0RWxlbWVudHNCeVRhZ05hbWUgIT09IFwidW5kZWZpbmVkXCIgP1xuXHRcdFx0Y29udGV4dC5nZXRFbGVtZW50c0J5VGFnTmFtZSggdGFnIHx8IFwiKlwiICkgOlxuXHRcdFx0dHlwZW9mIGNvbnRleHQucXVlcnlTZWxlY3RvckFsbCAhPT0gXCJ1bmRlZmluZWRcIiA/XG5cdFx0XHRcdGNvbnRleHQucXVlcnlTZWxlY3RvckFsbCggdGFnIHx8IFwiKlwiICkgOlxuXHRcdFx0XHR1bmRlZmluZWQ7XG5cblx0aWYgKCAhZm91bmQgKSB7XG5cdFx0Zm9yICggZm91bmQgPSBbXSwgZWxlbXMgPSBjb250ZXh0LmNoaWxkTm9kZXMgfHwgY29udGV4dDtcblx0XHRcdCggZWxlbSA9IGVsZW1zWyBpIF0gKSAhPSBudWxsO1xuXHRcdFx0aSsrXG5cdFx0KSB7XG5cdFx0XHRpZiAoICF0YWcgfHwgalF1ZXJ5Lm5vZGVOYW1lKCBlbGVtLCB0YWcgKSApIHtcblx0XHRcdFx0Zm91bmQucHVzaCggZWxlbSApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0alF1ZXJ5Lm1lcmdlKCBmb3VuZCwgZ2V0QWxsKCBlbGVtLCB0YWcgKSApO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiB0YWcgPT09IHVuZGVmaW5lZCB8fCB0YWcgJiYgalF1ZXJ5Lm5vZGVOYW1lKCBjb250ZXh0LCB0YWcgKSA/XG5cdFx0alF1ZXJ5Lm1lcmdlKCBbIGNvbnRleHQgXSwgZm91bmQgKSA6XG5cdFx0Zm91bmQ7XG59XG5cblxuLy8gTWFyayBzY3JpcHRzIGFzIGhhdmluZyBhbHJlYWR5IGJlZW4gZXZhbHVhdGVkXG5mdW5jdGlvbiBzZXRHbG9iYWxFdmFsKCBlbGVtcywgcmVmRWxlbWVudHMgKSB7XG5cdHZhciBlbGVtLFxuXHRcdGkgPSAwO1xuXHRmb3IgKCA7ICggZWxlbSA9IGVsZW1zWyBpIF0gKSAhPSBudWxsOyBpKysgKSB7XG5cdFx0alF1ZXJ5Ll9kYXRhKFxuXHRcdFx0ZWxlbSxcblx0XHRcdFwiZ2xvYmFsRXZhbFwiLFxuXHRcdFx0IXJlZkVsZW1lbnRzIHx8IGpRdWVyeS5fZGF0YSggcmVmRWxlbWVudHNbIGkgXSwgXCJnbG9iYWxFdmFsXCIgKVxuXHRcdCk7XG5cdH1cbn1cblxuXG52YXIgcmh0bWwgPSAvPHwmIz9cXHcrOy8sXG5cdHJ0Ym9keSA9IC88dGJvZHkvaTtcblxuZnVuY3Rpb24gZml4RGVmYXVsdENoZWNrZWQoIGVsZW0gKSB7XG5cdGlmICggcmNoZWNrYWJsZVR5cGUudGVzdCggZWxlbS50eXBlICkgKSB7XG5cdFx0ZWxlbS5kZWZhdWx0Q2hlY2tlZCA9IGVsZW0uY2hlY2tlZDtcblx0fVxufVxuXG5mdW5jdGlvbiBidWlsZEZyYWdtZW50KCBlbGVtcywgY29udGV4dCwgc2NyaXB0cywgc2VsZWN0aW9uLCBpZ25vcmVkICkge1xuXHR2YXIgaiwgZWxlbSwgY29udGFpbnMsXG5cdFx0dG1wLCB0YWcsIHRib2R5LCB3cmFwLFxuXHRcdGwgPSBlbGVtcy5sZW5ndGgsXG5cblx0XHQvLyBFbnN1cmUgYSBzYWZlIGZyYWdtZW50XG5cdFx0c2FmZSA9IGNyZWF0ZVNhZmVGcmFnbWVudCggY29udGV4dCApLFxuXG5cdFx0bm9kZXMgPSBbXSxcblx0XHRpID0gMDtcblxuXHRmb3IgKCA7IGkgPCBsOyBpKysgKSB7XG5cdFx0ZWxlbSA9IGVsZW1zWyBpIF07XG5cblx0XHRpZiAoIGVsZW0gfHwgZWxlbSA9PT0gMCApIHtcblxuXHRcdFx0Ly8gQWRkIG5vZGVzIGRpcmVjdGx5XG5cdFx0XHRpZiAoIGpRdWVyeS50eXBlKCBlbGVtICkgPT09IFwib2JqZWN0XCIgKSB7XG5cdFx0XHRcdGpRdWVyeS5tZXJnZSggbm9kZXMsIGVsZW0ubm9kZVR5cGUgPyBbIGVsZW0gXSA6IGVsZW0gKTtcblxuXHRcdFx0Ly8gQ29udmVydCBub24taHRtbCBpbnRvIGEgdGV4dCBub2RlXG5cdFx0XHR9IGVsc2UgaWYgKCAhcmh0bWwudGVzdCggZWxlbSApICkge1xuXHRcdFx0XHRub2Rlcy5wdXNoKCBjb250ZXh0LmNyZWF0ZVRleHROb2RlKCBlbGVtICkgKTtcblxuXHRcdFx0Ly8gQ29udmVydCBodG1sIGludG8gRE9NIG5vZGVzXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0bXAgPSB0bXAgfHwgc2FmZS5hcHBlbmRDaGlsZCggY29udGV4dC5jcmVhdGVFbGVtZW50KCBcImRpdlwiICkgKTtcblxuXHRcdFx0XHQvLyBEZXNlcmlhbGl6ZSBhIHN0YW5kYXJkIHJlcHJlc2VudGF0aW9uXG5cdFx0XHRcdHRhZyA9ICggcnRhZ05hbWUuZXhlYyggZWxlbSApIHx8IFsgXCJcIiwgXCJcIiBdIClbIDEgXS50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0XHR3cmFwID0gd3JhcE1hcFsgdGFnIF0gfHwgd3JhcE1hcC5fZGVmYXVsdDtcblxuXHRcdFx0XHR0bXAuaW5uZXJIVE1MID0gd3JhcFsgMSBdICsgalF1ZXJ5Lmh0bWxQcmVmaWx0ZXIoIGVsZW0gKSArIHdyYXBbIDIgXTtcblxuXHRcdFx0XHQvLyBEZXNjZW5kIHRocm91Z2ggd3JhcHBlcnMgdG8gdGhlIHJpZ2h0IGNvbnRlbnRcblx0XHRcdFx0aiA9IHdyYXBbIDAgXTtcblx0XHRcdFx0d2hpbGUgKCBqLS0gKSB7XG5cdFx0XHRcdFx0dG1wID0gdG1wLmxhc3RDaGlsZDtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIE1hbnVhbGx5IGFkZCBsZWFkaW5nIHdoaXRlc3BhY2UgcmVtb3ZlZCBieSBJRVxuXHRcdFx0XHRpZiAoICFzdXBwb3J0LmxlYWRpbmdXaGl0ZXNwYWNlICYmIHJsZWFkaW5nV2hpdGVzcGFjZS50ZXN0KCBlbGVtICkgKSB7XG5cdFx0XHRcdFx0bm9kZXMucHVzaCggY29udGV4dC5jcmVhdGVUZXh0Tm9kZSggcmxlYWRpbmdXaGl0ZXNwYWNlLmV4ZWMoIGVsZW0gKVsgMCBdICkgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFJlbW92ZSBJRSdzIGF1dG9pbnNlcnRlZCA8dGJvZHk+IGZyb20gdGFibGUgZnJhZ21lbnRzXG5cdFx0XHRcdGlmICggIXN1cHBvcnQudGJvZHkgKSB7XG5cblx0XHRcdFx0XHQvLyBTdHJpbmcgd2FzIGEgPHRhYmxlPiwgKm1heSogaGF2ZSBzcHVyaW91cyA8dGJvZHk+XG5cdFx0XHRcdFx0ZWxlbSA9IHRhZyA9PT0gXCJ0YWJsZVwiICYmICFydGJvZHkudGVzdCggZWxlbSApID9cblx0XHRcdFx0XHRcdHRtcC5maXJzdENoaWxkIDpcblxuXHRcdFx0XHRcdFx0Ly8gU3RyaW5nIHdhcyBhIGJhcmUgPHRoZWFkPiBvciA8dGZvb3Q+XG5cdFx0XHRcdFx0XHR3cmFwWyAxIF0gPT09IFwiPHRhYmxlPlwiICYmICFydGJvZHkudGVzdCggZWxlbSApID9cblx0XHRcdFx0XHRcdFx0dG1wIDpcblx0XHRcdFx0XHRcdFx0MDtcblxuXHRcdFx0XHRcdGogPSBlbGVtICYmIGVsZW0uY2hpbGROb2Rlcy5sZW5ndGg7XG5cdFx0XHRcdFx0d2hpbGUgKCBqLS0gKSB7XG5cdFx0XHRcdFx0XHRpZiAoIGpRdWVyeS5ub2RlTmFtZSggKCB0Ym9keSA9IGVsZW0uY2hpbGROb2Rlc1sgaiBdICksIFwidGJvZHlcIiApICYmXG5cdFx0XHRcdFx0XHRcdCF0Ym9keS5jaGlsZE5vZGVzLmxlbmd0aCApIHtcblxuXHRcdFx0XHRcdFx0XHRlbGVtLnJlbW92ZUNoaWxkKCB0Ym9keSApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGpRdWVyeS5tZXJnZSggbm9kZXMsIHRtcC5jaGlsZE5vZGVzICk7XG5cblx0XHRcdFx0Ly8gRml4ICMxMjM5MiBmb3IgV2ViS2l0IGFuZCBJRSA+IDlcblx0XHRcdFx0dG1wLnRleHRDb250ZW50ID0gXCJcIjtcblxuXHRcdFx0XHQvLyBGaXggIzEyMzkyIGZvciBvbGRJRVxuXHRcdFx0XHR3aGlsZSAoIHRtcC5maXJzdENoaWxkICkge1xuXHRcdFx0XHRcdHRtcC5yZW1vdmVDaGlsZCggdG1wLmZpcnN0Q2hpbGQgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFJlbWVtYmVyIHRoZSB0b3AtbGV2ZWwgY29udGFpbmVyIGZvciBwcm9wZXIgY2xlYW51cFxuXHRcdFx0XHR0bXAgPSBzYWZlLmxhc3RDaGlsZDtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvLyBGaXggIzExMzU2OiBDbGVhciBlbGVtZW50cyBmcm9tIGZyYWdtZW50XG5cdGlmICggdG1wICkge1xuXHRcdHNhZmUucmVtb3ZlQ2hpbGQoIHRtcCApO1xuXHR9XG5cblx0Ly8gUmVzZXQgZGVmYXVsdENoZWNrZWQgZm9yIGFueSByYWRpb3MgYW5kIGNoZWNrYm94ZXNcblx0Ly8gYWJvdXQgdG8gYmUgYXBwZW5kZWQgdG8gdGhlIERPTSBpbiBJRSA2LzcgKCM4MDYwKVxuXHRpZiAoICFzdXBwb3J0LmFwcGVuZENoZWNrZWQgKSB7XG5cdFx0alF1ZXJ5LmdyZXAoIGdldEFsbCggbm9kZXMsIFwiaW5wdXRcIiApLCBmaXhEZWZhdWx0Q2hlY2tlZCApO1xuXHR9XG5cblx0aSA9IDA7XG5cdHdoaWxlICggKCBlbGVtID0gbm9kZXNbIGkrKyBdICkgKSB7XG5cblx0XHQvLyBTa2lwIGVsZW1lbnRzIGFscmVhZHkgaW4gdGhlIGNvbnRleHQgY29sbGVjdGlvbiAodHJhYy00MDg3KVxuXHRcdGlmICggc2VsZWN0aW9uICYmIGpRdWVyeS5pbkFycmF5KCBlbGVtLCBzZWxlY3Rpb24gKSA+IC0xICkge1xuXHRcdFx0aWYgKCBpZ25vcmVkICkge1xuXHRcdFx0XHRpZ25vcmVkLnB1c2goIGVsZW0gKTtcblx0XHRcdH1cblxuXHRcdFx0Y29udGludWU7XG5cdFx0fVxuXG5cdFx0Y29udGFpbnMgPSBqUXVlcnkuY29udGFpbnMoIGVsZW0ub3duZXJEb2N1bWVudCwgZWxlbSApO1xuXG5cdFx0Ly8gQXBwZW5kIHRvIGZyYWdtZW50XG5cdFx0dG1wID0gZ2V0QWxsKCBzYWZlLmFwcGVuZENoaWxkKCBlbGVtICksIFwic2NyaXB0XCIgKTtcblxuXHRcdC8vIFByZXNlcnZlIHNjcmlwdCBldmFsdWF0aW9uIGhpc3Rvcnlcblx0XHRpZiAoIGNvbnRhaW5zICkge1xuXHRcdFx0c2V0R2xvYmFsRXZhbCggdG1wICk7XG5cdFx0fVxuXG5cdFx0Ly8gQ2FwdHVyZSBleGVjdXRhYmxlc1xuXHRcdGlmICggc2NyaXB0cyApIHtcblx0XHRcdGogPSAwO1xuXHRcdFx0d2hpbGUgKCAoIGVsZW0gPSB0bXBbIGorKyBdICkgKSB7XG5cdFx0XHRcdGlmICggcnNjcmlwdFR5cGUudGVzdCggZWxlbS50eXBlIHx8IFwiXCIgKSApIHtcblx0XHRcdFx0XHRzY3JpcHRzLnB1c2goIGVsZW0gKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHRtcCA9IG51bGw7XG5cblx0cmV0dXJuIHNhZmU7XG59XG5cblxuKCBmdW5jdGlvbigpIHtcblx0dmFyIGksIGV2ZW50TmFtZSxcblx0XHRkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImRpdlwiICk7XG5cblx0Ly8gU3VwcG9ydDogSUU8OSAobGFjayBzdWJtaXQvY2hhbmdlIGJ1YmJsZSksIEZpcmVmb3ggKGxhY2sgZm9jdXMoaW4gfCBvdXQpIGV2ZW50cylcblx0Zm9yICggaSBpbiB7IHN1Ym1pdDogdHJ1ZSwgY2hhbmdlOiB0cnVlLCBmb2N1c2luOiB0cnVlIH0gKSB7XG5cdFx0ZXZlbnROYW1lID0gXCJvblwiICsgaTtcblxuXHRcdGlmICggISggc3VwcG9ydFsgaSBdID0gZXZlbnROYW1lIGluIHdpbmRvdyApICkge1xuXG5cdFx0XHQvLyBCZXdhcmUgb2YgQ1NQIHJlc3RyaWN0aW9ucyAoaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vU2VjdXJpdHkvQ1NQKVxuXHRcdFx0ZGl2LnNldEF0dHJpYnV0ZSggZXZlbnROYW1lLCBcInRcIiApO1xuXHRcdFx0c3VwcG9ydFsgaSBdID0gZGl2LmF0dHJpYnV0ZXNbIGV2ZW50TmFtZSBdLmV4cGFuZG8gPT09IGZhbHNlO1xuXHRcdH1cblx0fVxuXG5cdC8vIE51bGwgZWxlbWVudHMgdG8gYXZvaWQgbGVha3MgaW4gSUUuXG5cdGRpdiA9IG51bGw7XG59ICkoKTtcblxuXG52YXIgcmZvcm1FbGVtcyA9IC9eKD86aW5wdXR8c2VsZWN0fHRleHRhcmVhKSQvaSxcblx0cmtleUV2ZW50ID0gL15rZXkvLFxuXHRybW91c2VFdmVudCA9IC9eKD86bW91c2V8cG9pbnRlcnxjb250ZXh0bWVudXxkcmFnfGRyb3ApfGNsaWNrLyxcblx0cmZvY3VzTW9ycGggPSAvXig/OmZvY3VzaW5mb2N1c3xmb2N1c291dGJsdXIpJC8sXG5cdHJ0eXBlbmFtZXNwYWNlID0gL14oW14uXSopKD86XFwuKC4rKXwpLztcblxuZnVuY3Rpb24gcmV0dXJuVHJ1ZSgpIHtcblx0cmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIHJldHVybkZhbHNlKCkge1xuXHRyZXR1cm4gZmFsc2U7XG59XG5cbi8vIFN1cHBvcnQ6IElFOVxuLy8gU2VlICMxMzM5MyBmb3IgbW9yZSBpbmZvXG5mdW5jdGlvbiBzYWZlQWN0aXZlRWxlbWVudCgpIHtcblx0dHJ5IHtcblx0XHRyZXR1cm4gZG9jdW1lbnQuYWN0aXZlRWxlbWVudDtcblx0fSBjYXRjaCAoIGVyciApIHsgfVxufVxuXG5mdW5jdGlvbiBvbiggZWxlbSwgdHlwZXMsIHNlbGVjdG9yLCBkYXRhLCBmbiwgb25lICkge1xuXHR2YXIgb3JpZ0ZuLCB0eXBlO1xuXG5cdC8vIFR5cGVzIGNhbiBiZSBhIG1hcCBvZiB0eXBlcy9oYW5kbGVyc1xuXHRpZiAoIHR5cGVvZiB0eXBlcyA9PT0gXCJvYmplY3RcIiApIHtcblxuXHRcdC8vICggdHlwZXMtT2JqZWN0LCBzZWxlY3RvciwgZGF0YSApXG5cdFx0aWYgKCB0eXBlb2Ygc2VsZWN0b3IgIT09IFwic3RyaW5nXCIgKSB7XG5cblx0XHRcdC8vICggdHlwZXMtT2JqZWN0LCBkYXRhIClcblx0XHRcdGRhdGEgPSBkYXRhIHx8IHNlbGVjdG9yO1xuXHRcdFx0c2VsZWN0b3IgPSB1bmRlZmluZWQ7XG5cdFx0fVxuXHRcdGZvciAoIHR5cGUgaW4gdHlwZXMgKSB7XG5cdFx0XHRvbiggZWxlbSwgdHlwZSwgc2VsZWN0b3IsIGRhdGEsIHR5cGVzWyB0eXBlIF0sIG9uZSApO1xuXHRcdH1cblx0XHRyZXR1cm4gZWxlbTtcblx0fVxuXG5cdGlmICggZGF0YSA9PSBudWxsICYmIGZuID09IG51bGwgKSB7XG5cblx0XHQvLyAoIHR5cGVzLCBmbiApXG5cdFx0Zm4gPSBzZWxlY3Rvcjtcblx0XHRkYXRhID0gc2VsZWN0b3IgPSB1bmRlZmluZWQ7XG5cdH0gZWxzZSBpZiAoIGZuID09IG51bGwgKSB7XG5cdFx0aWYgKCB0eXBlb2Ygc2VsZWN0b3IgPT09IFwic3RyaW5nXCIgKSB7XG5cblx0XHRcdC8vICggdHlwZXMsIHNlbGVjdG9yLCBmbiApXG5cdFx0XHRmbiA9IGRhdGE7XG5cdFx0XHRkYXRhID0gdW5kZWZpbmVkO1xuXHRcdH0gZWxzZSB7XG5cblx0XHRcdC8vICggdHlwZXMsIGRhdGEsIGZuIClcblx0XHRcdGZuID0gZGF0YTtcblx0XHRcdGRhdGEgPSBzZWxlY3Rvcjtcblx0XHRcdHNlbGVjdG9yID0gdW5kZWZpbmVkO1xuXHRcdH1cblx0fVxuXHRpZiAoIGZuID09PSBmYWxzZSApIHtcblx0XHRmbiA9IHJldHVybkZhbHNlO1xuXHR9IGVsc2UgaWYgKCAhZm4gKSB7XG5cdFx0cmV0dXJuIGVsZW07XG5cdH1cblxuXHRpZiAoIG9uZSA9PT0gMSApIHtcblx0XHRvcmlnRm4gPSBmbjtcblx0XHRmbiA9IGZ1bmN0aW9uKCBldmVudCApIHtcblxuXHRcdFx0Ly8gQ2FuIHVzZSBhbiBlbXB0eSBzZXQsIHNpbmNlIGV2ZW50IGNvbnRhaW5zIHRoZSBpbmZvXG5cdFx0XHRqUXVlcnkoKS5vZmYoIGV2ZW50ICk7XG5cdFx0XHRyZXR1cm4gb3JpZ0ZuLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKTtcblx0XHR9O1xuXG5cdFx0Ly8gVXNlIHNhbWUgZ3VpZCBzbyBjYWxsZXIgY2FuIHJlbW92ZSB1c2luZyBvcmlnRm5cblx0XHRmbi5ndWlkID0gb3JpZ0ZuLmd1aWQgfHwgKCBvcmlnRm4uZ3VpZCA9IGpRdWVyeS5ndWlkKysgKTtcblx0fVxuXHRyZXR1cm4gZWxlbS5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRqUXVlcnkuZXZlbnQuYWRkKCB0aGlzLCB0eXBlcywgZm4sIGRhdGEsIHNlbGVjdG9yICk7XG5cdH0gKTtcbn1cblxuLypcbiAqIEhlbHBlciBmdW5jdGlvbnMgZm9yIG1hbmFnaW5nIGV2ZW50cyAtLSBub3QgcGFydCBvZiB0aGUgcHVibGljIGludGVyZmFjZS5cbiAqIFByb3BzIHRvIERlYW4gRWR3YXJkcycgYWRkRXZlbnQgbGlicmFyeSBmb3IgbWFueSBvZiB0aGUgaWRlYXMuXG4gKi9cbmpRdWVyeS5ldmVudCA9IHtcblxuXHRnbG9iYWw6IHt9LFxuXG5cdGFkZDogZnVuY3Rpb24oIGVsZW0sIHR5cGVzLCBoYW5kbGVyLCBkYXRhLCBzZWxlY3RvciApIHtcblx0XHR2YXIgdG1wLCBldmVudHMsIHQsIGhhbmRsZU9iakluLFxuXHRcdFx0c3BlY2lhbCwgZXZlbnRIYW5kbGUsIGhhbmRsZU9iaixcblx0XHRcdGhhbmRsZXJzLCB0eXBlLCBuYW1lc3BhY2VzLCBvcmlnVHlwZSxcblx0XHRcdGVsZW1EYXRhID0galF1ZXJ5Ll9kYXRhKCBlbGVtICk7XG5cblx0XHQvLyBEb24ndCBhdHRhY2ggZXZlbnRzIHRvIG5vRGF0YSBvciB0ZXh0L2NvbW1lbnQgbm9kZXMgKGJ1dCBhbGxvdyBwbGFpbiBvYmplY3RzKVxuXHRcdGlmICggIWVsZW1EYXRhICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIENhbGxlciBjYW4gcGFzcyBpbiBhbiBvYmplY3Qgb2YgY3VzdG9tIGRhdGEgaW4gbGlldSBvZiB0aGUgaGFuZGxlclxuXHRcdGlmICggaGFuZGxlci5oYW5kbGVyICkge1xuXHRcdFx0aGFuZGxlT2JqSW4gPSBoYW5kbGVyO1xuXHRcdFx0aGFuZGxlciA9IGhhbmRsZU9iakluLmhhbmRsZXI7XG5cdFx0XHRzZWxlY3RvciA9IGhhbmRsZU9iakluLnNlbGVjdG9yO1xuXHRcdH1cblxuXHRcdC8vIE1ha2Ugc3VyZSB0aGF0IHRoZSBoYW5kbGVyIGhhcyBhIHVuaXF1ZSBJRCwgdXNlZCB0byBmaW5kL3JlbW92ZSBpdCBsYXRlclxuXHRcdGlmICggIWhhbmRsZXIuZ3VpZCApIHtcblx0XHRcdGhhbmRsZXIuZ3VpZCA9IGpRdWVyeS5ndWlkKys7XG5cdFx0fVxuXG5cdFx0Ly8gSW5pdCB0aGUgZWxlbWVudCdzIGV2ZW50IHN0cnVjdHVyZSBhbmQgbWFpbiBoYW5kbGVyLCBpZiB0aGlzIGlzIHRoZSBmaXJzdFxuXHRcdGlmICggISggZXZlbnRzID0gZWxlbURhdGEuZXZlbnRzICkgKSB7XG5cdFx0XHRldmVudHMgPSBlbGVtRGF0YS5ldmVudHMgPSB7fTtcblx0XHR9XG5cdFx0aWYgKCAhKCBldmVudEhhbmRsZSA9IGVsZW1EYXRhLmhhbmRsZSApICkge1xuXHRcdFx0ZXZlbnRIYW5kbGUgPSBlbGVtRGF0YS5oYW5kbGUgPSBmdW5jdGlvbiggZSApIHtcblxuXHRcdFx0XHQvLyBEaXNjYXJkIHRoZSBzZWNvbmQgZXZlbnQgb2YgYSBqUXVlcnkuZXZlbnQudHJpZ2dlcigpIGFuZFxuXHRcdFx0XHQvLyB3aGVuIGFuIGV2ZW50IGlzIGNhbGxlZCBhZnRlciBhIHBhZ2UgaGFzIHVubG9hZGVkXG5cdFx0XHRcdHJldHVybiB0eXBlb2YgalF1ZXJ5ICE9PSBcInVuZGVmaW5lZFwiICYmXG5cdFx0XHRcdFx0KCAhZSB8fCBqUXVlcnkuZXZlbnQudHJpZ2dlcmVkICE9PSBlLnR5cGUgKSA/XG5cdFx0XHRcdFx0alF1ZXJ5LmV2ZW50LmRpc3BhdGNoLmFwcGx5KCBldmVudEhhbmRsZS5lbGVtLCBhcmd1bWVudHMgKSA6XG5cdFx0XHRcdFx0dW5kZWZpbmVkO1xuXHRcdFx0fTtcblxuXHRcdFx0Ly8gQWRkIGVsZW0gYXMgYSBwcm9wZXJ0eSBvZiB0aGUgaGFuZGxlIGZuIHRvIHByZXZlbnQgYSBtZW1vcnkgbGVha1xuXHRcdFx0Ly8gd2l0aCBJRSBub24tbmF0aXZlIGV2ZW50c1xuXHRcdFx0ZXZlbnRIYW5kbGUuZWxlbSA9IGVsZW07XG5cdFx0fVxuXG5cdFx0Ly8gSGFuZGxlIG11bHRpcGxlIGV2ZW50cyBzZXBhcmF0ZWQgYnkgYSBzcGFjZVxuXHRcdHR5cGVzID0gKCB0eXBlcyB8fCBcIlwiICkubWF0Y2goIHJub3R3aGl0ZSApIHx8IFsgXCJcIiBdO1xuXHRcdHQgPSB0eXBlcy5sZW5ndGg7XG5cdFx0d2hpbGUgKCB0LS0gKSB7XG5cdFx0XHR0bXAgPSBydHlwZW5hbWVzcGFjZS5leGVjKCB0eXBlc1sgdCBdICkgfHwgW107XG5cdFx0XHR0eXBlID0gb3JpZ1R5cGUgPSB0bXBbIDEgXTtcblx0XHRcdG5hbWVzcGFjZXMgPSAoIHRtcFsgMiBdIHx8IFwiXCIgKS5zcGxpdCggXCIuXCIgKS5zb3J0KCk7XG5cblx0XHRcdC8vIFRoZXJlICptdXN0KiBiZSBhIHR5cGUsIG5vIGF0dGFjaGluZyBuYW1lc3BhY2Utb25seSBoYW5kbGVyc1xuXHRcdFx0aWYgKCAhdHlwZSApIHtcblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR9XG5cblx0XHRcdC8vIElmIGV2ZW50IGNoYW5nZXMgaXRzIHR5cGUsIHVzZSB0aGUgc3BlY2lhbCBldmVudCBoYW5kbGVycyBmb3IgdGhlIGNoYW5nZWQgdHlwZVxuXHRcdFx0c3BlY2lhbCA9IGpRdWVyeS5ldmVudC5zcGVjaWFsWyB0eXBlIF0gfHwge307XG5cblx0XHRcdC8vIElmIHNlbGVjdG9yIGRlZmluZWQsIGRldGVybWluZSBzcGVjaWFsIGV2ZW50IGFwaSB0eXBlLCBvdGhlcndpc2UgZ2l2ZW4gdHlwZVxuXHRcdFx0dHlwZSA9ICggc2VsZWN0b3IgPyBzcGVjaWFsLmRlbGVnYXRlVHlwZSA6IHNwZWNpYWwuYmluZFR5cGUgKSB8fCB0eXBlO1xuXG5cdFx0XHQvLyBVcGRhdGUgc3BlY2lhbCBiYXNlZCBvbiBuZXdseSByZXNldCB0eXBlXG5cdFx0XHRzcGVjaWFsID0galF1ZXJ5LmV2ZW50LnNwZWNpYWxbIHR5cGUgXSB8fCB7fTtcblxuXHRcdFx0Ly8gaGFuZGxlT2JqIGlzIHBhc3NlZCB0byBhbGwgZXZlbnQgaGFuZGxlcnNcblx0XHRcdGhhbmRsZU9iaiA9IGpRdWVyeS5leHRlbmQoIHtcblx0XHRcdFx0dHlwZTogdHlwZSxcblx0XHRcdFx0b3JpZ1R5cGU6IG9yaWdUeXBlLFxuXHRcdFx0XHRkYXRhOiBkYXRhLFxuXHRcdFx0XHRoYW5kbGVyOiBoYW5kbGVyLFxuXHRcdFx0XHRndWlkOiBoYW5kbGVyLmd1aWQsXG5cdFx0XHRcdHNlbGVjdG9yOiBzZWxlY3Rvcixcblx0XHRcdFx0bmVlZHNDb250ZXh0OiBzZWxlY3RvciAmJiBqUXVlcnkuZXhwci5tYXRjaC5uZWVkc0NvbnRleHQudGVzdCggc2VsZWN0b3IgKSxcblx0XHRcdFx0bmFtZXNwYWNlOiBuYW1lc3BhY2VzLmpvaW4oIFwiLlwiIClcblx0XHRcdH0sIGhhbmRsZU9iakluICk7XG5cblx0XHRcdC8vIEluaXQgdGhlIGV2ZW50IGhhbmRsZXIgcXVldWUgaWYgd2UncmUgdGhlIGZpcnN0XG5cdFx0XHRpZiAoICEoIGhhbmRsZXJzID0gZXZlbnRzWyB0eXBlIF0gKSApIHtcblx0XHRcdFx0aGFuZGxlcnMgPSBldmVudHNbIHR5cGUgXSA9IFtdO1xuXHRcdFx0XHRoYW5kbGVycy5kZWxlZ2F0ZUNvdW50ID0gMDtcblxuXHRcdFx0XHQvLyBPbmx5IHVzZSBhZGRFdmVudExpc3RlbmVyL2F0dGFjaEV2ZW50IGlmIHRoZSBzcGVjaWFsIGV2ZW50cyBoYW5kbGVyIHJldHVybnMgZmFsc2Vcblx0XHRcdFx0aWYgKCAhc3BlY2lhbC5zZXR1cCB8fFxuXHRcdFx0XHRcdHNwZWNpYWwuc2V0dXAuY2FsbCggZWxlbSwgZGF0YSwgbmFtZXNwYWNlcywgZXZlbnRIYW5kbGUgKSA9PT0gZmFsc2UgKSB7XG5cblx0XHRcdFx0XHQvLyBCaW5kIHRoZSBnbG9iYWwgZXZlbnQgaGFuZGxlciB0byB0aGUgZWxlbWVudFxuXHRcdFx0XHRcdGlmICggZWxlbS5hZGRFdmVudExpc3RlbmVyICkge1xuXHRcdFx0XHRcdFx0ZWxlbS5hZGRFdmVudExpc3RlbmVyKCB0eXBlLCBldmVudEhhbmRsZSwgZmFsc2UgKTtcblxuXHRcdFx0XHRcdH0gZWxzZSBpZiAoIGVsZW0uYXR0YWNoRXZlbnQgKSB7XG5cdFx0XHRcdFx0XHRlbGVtLmF0dGFjaEV2ZW50KCBcIm9uXCIgKyB0eXBlLCBldmVudEhhbmRsZSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIHNwZWNpYWwuYWRkICkge1xuXHRcdFx0XHRzcGVjaWFsLmFkZC5jYWxsKCBlbGVtLCBoYW5kbGVPYmogKTtcblxuXHRcdFx0XHRpZiAoICFoYW5kbGVPYmouaGFuZGxlci5ndWlkICkge1xuXHRcdFx0XHRcdGhhbmRsZU9iai5oYW5kbGVyLmd1aWQgPSBoYW5kbGVyLmd1aWQ7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gQWRkIHRvIHRoZSBlbGVtZW50J3MgaGFuZGxlciBsaXN0LCBkZWxlZ2F0ZXMgaW4gZnJvbnRcblx0XHRcdGlmICggc2VsZWN0b3IgKSB7XG5cdFx0XHRcdGhhbmRsZXJzLnNwbGljZSggaGFuZGxlcnMuZGVsZWdhdGVDb3VudCsrLCAwLCBoYW5kbGVPYmogKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGhhbmRsZXJzLnB1c2goIGhhbmRsZU9iaiApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBLZWVwIHRyYWNrIG9mIHdoaWNoIGV2ZW50cyBoYXZlIGV2ZXIgYmVlbiB1c2VkLCBmb3IgZXZlbnQgb3B0aW1pemF0aW9uXG5cdFx0XHRqUXVlcnkuZXZlbnQuZ2xvYmFsWyB0eXBlIF0gPSB0cnVlO1xuXHRcdH1cblxuXHRcdC8vIE51bGxpZnkgZWxlbSB0byBwcmV2ZW50IG1lbW9yeSBsZWFrcyBpbiBJRVxuXHRcdGVsZW0gPSBudWxsO1xuXHR9LFxuXG5cdC8vIERldGFjaCBhbiBldmVudCBvciBzZXQgb2YgZXZlbnRzIGZyb20gYW4gZWxlbWVudFxuXHRyZW1vdmU6IGZ1bmN0aW9uKCBlbGVtLCB0eXBlcywgaGFuZGxlciwgc2VsZWN0b3IsIG1hcHBlZFR5cGVzICkge1xuXHRcdHZhciBqLCBoYW5kbGVPYmosIHRtcCxcblx0XHRcdG9yaWdDb3VudCwgdCwgZXZlbnRzLFxuXHRcdFx0c3BlY2lhbCwgaGFuZGxlcnMsIHR5cGUsXG5cdFx0XHRuYW1lc3BhY2VzLCBvcmlnVHlwZSxcblx0XHRcdGVsZW1EYXRhID0galF1ZXJ5Lmhhc0RhdGEoIGVsZW0gKSAmJiBqUXVlcnkuX2RhdGEoIGVsZW0gKTtcblxuXHRcdGlmICggIWVsZW1EYXRhIHx8ICEoIGV2ZW50cyA9IGVsZW1EYXRhLmV2ZW50cyApICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIE9uY2UgZm9yIGVhY2ggdHlwZS5uYW1lc3BhY2UgaW4gdHlwZXM7IHR5cGUgbWF5IGJlIG9taXR0ZWRcblx0XHR0eXBlcyA9ICggdHlwZXMgfHwgXCJcIiApLm1hdGNoKCBybm90d2hpdGUgKSB8fCBbIFwiXCIgXTtcblx0XHR0ID0gdHlwZXMubGVuZ3RoO1xuXHRcdHdoaWxlICggdC0tICkge1xuXHRcdFx0dG1wID0gcnR5cGVuYW1lc3BhY2UuZXhlYyggdHlwZXNbIHQgXSApIHx8IFtdO1xuXHRcdFx0dHlwZSA9IG9yaWdUeXBlID0gdG1wWyAxIF07XG5cdFx0XHRuYW1lc3BhY2VzID0gKCB0bXBbIDIgXSB8fCBcIlwiICkuc3BsaXQoIFwiLlwiICkuc29ydCgpO1xuXG5cdFx0XHQvLyBVbmJpbmQgYWxsIGV2ZW50cyAob24gdGhpcyBuYW1lc3BhY2UsIGlmIHByb3ZpZGVkKSBmb3IgdGhlIGVsZW1lbnRcblx0XHRcdGlmICggIXR5cGUgKSB7XG5cdFx0XHRcdGZvciAoIHR5cGUgaW4gZXZlbnRzICkge1xuXHRcdFx0XHRcdGpRdWVyeS5ldmVudC5yZW1vdmUoIGVsZW0sIHR5cGUgKyB0eXBlc1sgdCBdLCBoYW5kbGVyLCBzZWxlY3RvciwgdHJ1ZSApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fVxuXG5cdFx0XHRzcGVjaWFsID0galF1ZXJ5LmV2ZW50LnNwZWNpYWxbIHR5cGUgXSB8fCB7fTtcblx0XHRcdHR5cGUgPSAoIHNlbGVjdG9yID8gc3BlY2lhbC5kZWxlZ2F0ZVR5cGUgOiBzcGVjaWFsLmJpbmRUeXBlICkgfHwgdHlwZTtcblx0XHRcdGhhbmRsZXJzID0gZXZlbnRzWyB0eXBlIF0gfHwgW107XG5cdFx0XHR0bXAgPSB0bXBbIDIgXSAmJlxuXHRcdFx0XHRuZXcgUmVnRXhwKCBcIihefFxcXFwuKVwiICsgbmFtZXNwYWNlcy5qb2luKCBcIlxcXFwuKD86LipcXFxcLnwpXCIgKSArIFwiKFxcXFwufCQpXCIgKTtcblxuXHRcdFx0Ly8gUmVtb3ZlIG1hdGNoaW5nIGV2ZW50c1xuXHRcdFx0b3JpZ0NvdW50ID0gaiA9IGhhbmRsZXJzLmxlbmd0aDtcblx0XHRcdHdoaWxlICggai0tICkge1xuXHRcdFx0XHRoYW5kbGVPYmogPSBoYW5kbGVyc1sgaiBdO1xuXG5cdFx0XHRcdGlmICggKCBtYXBwZWRUeXBlcyB8fCBvcmlnVHlwZSA9PT0gaGFuZGxlT2JqLm9yaWdUeXBlICkgJiZcblx0XHRcdFx0XHQoICFoYW5kbGVyIHx8IGhhbmRsZXIuZ3VpZCA9PT0gaGFuZGxlT2JqLmd1aWQgKSAmJlxuXHRcdFx0XHRcdCggIXRtcCB8fCB0bXAudGVzdCggaGFuZGxlT2JqLm5hbWVzcGFjZSApICkgJiZcblx0XHRcdFx0XHQoICFzZWxlY3RvciB8fCBzZWxlY3RvciA9PT0gaGFuZGxlT2JqLnNlbGVjdG9yIHx8XG5cdFx0XHRcdFx0XHRzZWxlY3RvciA9PT0gXCIqKlwiICYmIGhhbmRsZU9iai5zZWxlY3RvciApICkge1xuXHRcdFx0XHRcdGhhbmRsZXJzLnNwbGljZSggaiwgMSApO1xuXG5cdFx0XHRcdFx0aWYgKCBoYW5kbGVPYmouc2VsZWN0b3IgKSB7XG5cdFx0XHRcdFx0XHRoYW5kbGVycy5kZWxlZ2F0ZUNvdW50LS07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmICggc3BlY2lhbC5yZW1vdmUgKSB7XG5cdFx0XHRcdFx0XHRzcGVjaWFsLnJlbW92ZS5jYWxsKCBlbGVtLCBoYW5kbGVPYmogKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gUmVtb3ZlIGdlbmVyaWMgZXZlbnQgaGFuZGxlciBpZiB3ZSByZW1vdmVkIHNvbWV0aGluZyBhbmQgbm8gbW9yZSBoYW5kbGVycyBleGlzdFxuXHRcdFx0Ly8gKGF2b2lkcyBwb3RlbnRpYWwgZm9yIGVuZGxlc3MgcmVjdXJzaW9uIGR1cmluZyByZW1vdmFsIG9mIHNwZWNpYWwgZXZlbnQgaGFuZGxlcnMpXG5cdFx0XHRpZiAoIG9yaWdDb3VudCAmJiAhaGFuZGxlcnMubGVuZ3RoICkge1xuXHRcdFx0XHRpZiAoICFzcGVjaWFsLnRlYXJkb3duIHx8XG5cdFx0XHRcdFx0c3BlY2lhbC50ZWFyZG93bi5jYWxsKCBlbGVtLCBuYW1lc3BhY2VzLCBlbGVtRGF0YS5oYW5kbGUgKSA9PT0gZmFsc2UgKSB7XG5cblx0XHRcdFx0XHRqUXVlcnkucmVtb3ZlRXZlbnQoIGVsZW0sIHR5cGUsIGVsZW1EYXRhLmhhbmRsZSApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0ZGVsZXRlIGV2ZW50c1sgdHlwZSBdO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIFJlbW92ZSB0aGUgZXhwYW5kbyBpZiBpdCdzIG5vIGxvbmdlciB1c2VkXG5cdFx0aWYgKCBqUXVlcnkuaXNFbXB0eU9iamVjdCggZXZlbnRzICkgKSB7XG5cdFx0XHRkZWxldGUgZWxlbURhdGEuaGFuZGxlO1xuXG5cdFx0XHQvLyByZW1vdmVEYXRhIGFsc28gY2hlY2tzIGZvciBlbXB0aW5lc3MgYW5kIGNsZWFycyB0aGUgZXhwYW5kbyBpZiBlbXB0eVxuXHRcdFx0Ly8gc28gdXNlIGl0IGluc3RlYWQgb2YgZGVsZXRlXG5cdFx0XHRqUXVlcnkuX3JlbW92ZURhdGEoIGVsZW0sIFwiZXZlbnRzXCIgKTtcblx0XHR9XG5cdH0sXG5cblx0dHJpZ2dlcjogZnVuY3Rpb24oIGV2ZW50LCBkYXRhLCBlbGVtLCBvbmx5SGFuZGxlcnMgKSB7XG5cdFx0dmFyIGhhbmRsZSwgb250eXBlLCBjdXIsXG5cdFx0XHRidWJibGVUeXBlLCBzcGVjaWFsLCB0bXAsIGksXG5cdFx0XHRldmVudFBhdGggPSBbIGVsZW0gfHwgZG9jdW1lbnQgXSxcblx0XHRcdHR5cGUgPSBoYXNPd24uY2FsbCggZXZlbnQsIFwidHlwZVwiICkgPyBldmVudC50eXBlIDogZXZlbnQsXG5cdFx0XHRuYW1lc3BhY2VzID0gaGFzT3duLmNhbGwoIGV2ZW50LCBcIm5hbWVzcGFjZVwiICkgPyBldmVudC5uYW1lc3BhY2Uuc3BsaXQoIFwiLlwiICkgOiBbXTtcblxuXHRcdGN1ciA9IHRtcCA9IGVsZW0gPSBlbGVtIHx8IGRvY3VtZW50O1xuXG5cdFx0Ly8gRG9uJ3QgZG8gZXZlbnRzIG9uIHRleHQgYW5kIGNvbW1lbnQgbm9kZXNcblx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDMgfHwgZWxlbS5ub2RlVHlwZSA9PT0gOCApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBmb2N1cy9ibHVyIG1vcnBocyB0byBmb2N1c2luL291dDsgZW5zdXJlIHdlJ3JlIG5vdCBmaXJpbmcgdGhlbSByaWdodCBub3dcblx0XHRpZiAoIHJmb2N1c01vcnBoLnRlc3QoIHR5cGUgKyBqUXVlcnkuZXZlbnQudHJpZ2dlcmVkICkgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0aWYgKCB0eXBlLmluZGV4T2YoIFwiLlwiICkgPiAtMSApIHtcblxuXHRcdFx0Ly8gTmFtZXNwYWNlZCB0cmlnZ2VyOyBjcmVhdGUgYSByZWdleHAgdG8gbWF0Y2ggZXZlbnQgdHlwZSBpbiBoYW5kbGUoKVxuXHRcdFx0bmFtZXNwYWNlcyA9IHR5cGUuc3BsaXQoIFwiLlwiICk7XG5cdFx0XHR0eXBlID0gbmFtZXNwYWNlcy5zaGlmdCgpO1xuXHRcdFx0bmFtZXNwYWNlcy5zb3J0KCk7XG5cdFx0fVxuXHRcdG9udHlwZSA9IHR5cGUuaW5kZXhPZiggXCI6XCIgKSA8IDAgJiYgXCJvblwiICsgdHlwZTtcblxuXHRcdC8vIENhbGxlciBjYW4gcGFzcyBpbiBhIGpRdWVyeS5FdmVudCBvYmplY3QsIE9iamVjdCwgb3IganVzdCBhbiBldmVudCB0eXBlIHN0cmluZ1xuXHRcdGV2ZW50ID0gZXZlbnRbIGpRdWVyeS5leHBhbmRvIF0gP1xuXHRcdFx0ZXZlbnQgOlxuXHRcdFx0bmV3IGpRdWVyeS5FdmVudCggdHlwZSwgdHlwZW9mIGV2ZW50ID09PSBcIm9iamVjdFwiICYmIGV2ZW50ICk7XG5cblx0XHQvLyBUcmlnZ2VyIGJpdG1hc2s6ICYgMSBmb3IgbmF0aXZlIGhhbmRsZXJzOyAmIDIgZm9yIGpRdWVyeSAoYWx3YXlzIHRydWUpXG5cdFx0ZXZlbnQuaXNUcmlnZ2VyID0gb25seUhhbmRsZXJzID8gMiA6IDM7XG5cdFx0ZXZlbnQubmFtZXNwYWNlID0gbmFtZXNwYWNlcy5qb2luKCBcIi5cIiApO1xuXHRcdGV2ZW50LnJuYW1lc3BhY2UgPSBldmVudC5uYW1lc3BhY2UgP1xuXHRcdFx0bmV3IFJlZ0V4cCggXCIoXnxcXFxcLilcIiArIG5hbWVzcGFjZXMuam9pbiggXCJcXFxcLig/Oi4qXFxcXC58KVwiICkgKyBcIihcXFxcLnwkKVwiICkgOlxuXHRcdFx0bnVsbDtcblxuXHRcdC8vIENsZWFuIHVwIHRoZSBldmVudCBpbiBjYXNlIGl0IGlzIGJlaW5nIHJldXNlZFxuXHRcdGV2ZW50LnJlc3VsdCA9IHVuZGVmaW5lZDtcblx0XHRpZiAoICFldmVudC50YXJnZXQgKSB7XG5cdFx0XHRldmVudC50YXJnZXQgPSBlbGVtO1xuXHRcdH1cblxuXHRcdC8vIENsb25lIGFueSBpbmNvbWluZyBkYXRhIGFuZCBwcmVwZW5kIHRoZSBldmVudCwgY3JlYXRpbmcgdGhlIGhhbmRsZXIgYXJnIGxpc3Rcblx0XHRkYXRhID0gZGF0YSA9PSBudWxsID9cblx0XHRcdFsgZXZlbnQgXSA6XG5cdFx0XHRqUXVlcnkubWFrZUFycmF5KCBkYXRhLCBbIGV2ZW50IF0gKTtcblxuXHRcdC8vIEFsbG93IHNwZWNpYWwgZXZlbnRzIHRvIGRyYXcgb3V0c2lkZSB0aGUgbGluZXNcblx0XHRzcGVjaWFsID0galF1ZXJ5LmV2ZW50LnNwZWNpYWxbIHR5cGUgXSB8fCB7fTtcblx0XHRpZiAoICFvbmx5SGFuZGxlcnMgJiYgc3BlY2lhbC50cmlnZ2VyICYmIHNwZWNpYWwudHJpZ2dlci5hcHBseSggZWxlbSwgZGF0YSApID09PSBmYWxzZSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBEZXRlcm1pbmUgZXZlbnQgcHJvcGFnYXRpb24gcGF0aCBpbiBhZHZhbmNlLCBwZXIgVzNDIGV2ZW50cyBzcGVjICgjOTk1MSlcblx0XHQvLyBCdWJibGUgdXAgdG8gZG9jdW1lbnQsIHRoZW4gdG8gd2luZG93OyB3YXRjaCBmb3IgYSBnbG9iYWwgb3duZXJEb2N1bWVudCB2YXIgKCM5NzI0KVxuXHRcdGlmICggIW9ubHlIYW5kbGVycyAmJiAhc3BlY2lhbC5ub0J1YmJsZSAmJiAhalF1ZXJ5LmlzV2luZG93KCBlbGVtICkgKSB7XG5cblx0XHRcdGJ1YmJsZVR5cGUgPSBzcGVjaWFsLmRlbGVnYXRlVHlwZSB8fCB0eXBlO1xuXHRcdFx0aWYgKCAhcmZvY3VzTW9ycGgudGVzdCggYnViYmxlVHlwZSArIHR5cGUgKSApIHtcblx0XHRcdFx0Y3VyID0gY3VyLnBhcmVudE5vZGU7XG5cdFx0XHR9XG5cdFx0XHRmb3IgKCA7IGN1cjsgY3VyID0gY3VyLnBhcmVudE5vZGUgKSB7XG5cdFx0XHRcdGV2ZW50UGF0aC5wdXNoKCBjdXIgKTtcblx0XHRcdFx0dG1wID0gY3VyO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBPbmx5IGFkZCB3aW5kb3cgaWYgd2UgZ290IHRvIGRvY3VtZW50IChlLmcuLCBub3QgcGxhaW4gb2JqIG9yIGRldGFjaGVkIERPTSlcblx0XHRcdGlmICggdG1wID09PSAoIGVsZW0ub3duZXJEb2N1bWVudCB8fCBkb2N1bWVudCApICkge1xuXHRcdFx0XHRldmVudFBhdGgucHVzaCggdG1wLmRlZmF1bHRWaWV3IHx8IHRtcC5wYXJlbnRXaW5kb3cgfHwgd2luZG93ICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gRmlyZSBoYW5kbGVycyBvbiB0aGUgZXZlbnQgcGF0aFxuXHRcdGkgPSAwO1xuXHRcdHdoaWxlICggKCBjdXIgPSBldmVudFBhdGhbIGkrKyBdICkgJiYgIWV2ZW50LmlzUHJvcGFnYXRpb25TdG9wcGVkKCkgKSB7XG5cblx0XHRcdGV2ZW50LnR5cGUgPSBpID4gMSA/XG5cdFx0XHRcdGJ1YmJsZVR5cGUgOlxuXHRcdFx0XHRzcGVjaWFsLmJpbmRUeXBlIHx8IHR5cGU7XG5cblx0XHRcdC8vIGpRdWVyeSBoYW5kbGVyXG5cdFx0XHRoYW5kbGUgPSAoIGpRdWVyeS5fZGF0YSggY3VyLCBcImV2ZW50c1wiICkgfHwge30gKVsgZXZlbnQudHlwZSBdICYmXG5cdFx0XHRcdGpRdWVyeS5fZGF0YSggY3VyLCBcImhhbmRsZVwiICk7XG5cblx0XHRcdGlmICggaGFuZGxlICkge1xuXHRcdFx0XHRoYW5kbGUuYXBwbHkoIGN1ciwgZGF0YSApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBOYXRpdmUgaGFuZGxlclxuXHRcdFx0aGFuZGxlID0gb250eXBlICYmIGN1clsgb250eXBlIF07XG5cdFx0XHRpZiAoIGhhbmRsZSAmJiBoYW5kbGUuYXBwbHkgJiYgYWNjZXB0RGF0YSggY3VyICkgKSB7XG5cdFx0XHRcdGV2ZW50LnJlc3VsdCA9IGhhbmRsZS5hcHBseSggY3VyLCBkYXRhICk7XG5cdFx0XHRcdGlmICggZXZlbnQucmVzdWx0ID09PSBmYWxzZSApIHtcblx0XHRcdFx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGV2ZW50LnR5cGUgPSB0eXBlO1xuXG5cdFx0Ly8gSWYgbm9ib2R5IHByZXZlbnRlZCB0aGUgZGVmYXVsdCBhY3Rpb24sIGRvIGl0IG5vd1xuXHRcdGlmICggIW9ubHlIYW5kbGVycyAmJiAhZXZlbnQuaXNEZWZhdWx0UHJldmVudGVkKCkgKSB7XG5cblx0XHRcdGlmIChcblx0XHRcdFx0KCAhc3BlY2lhbC5fZGVmYXVsdCB8fFxuXHRcdFx0XHQgc3BlY2lhbC5fZGVmYXVsdC5hcHBseSggZXZlbnRQYXRoLnBvcCgpLCBkYXRhICkgPT09IGZhbHNlXG5cdFx0XHRcdCkgJiYgYWNjZXB0RGF0YSggZWxlbSApXG5cdFx0XHQpIHtcblxuXHRcdFx0XHQvLyBDYWxsIGEgbmF0aXZlIERPTSBtZXRob2Qgb24gdGhlIHRhcmdldCB3aXRoIHRoZSBzYW1lIG5hbWUgbmFtZSBhcyB0aGUgZXZlbnQuXG5cdFx0XHRcdC8vIENhbid0IHVzZSBhbiAuaXNGdW5jdGlvbigpIGNoZWNrIGhlcmUgYmVjYXVzZSBJRTYvNyBmYWlscyB0aGF0IHRlc3QuXG5cdFx0XHRcdC8vIERvbid0IGRvIGRlZmF1bHQgYWN0aW9ucyBvbiB3aW5kb3csIHRoYXQncyB3aGVyZSBnbG9iYWwgdmFyaWFibGVzIGJlICgjNjE3MClcblx0XHRcdFx0aWYgKCBvbnR5cGUgJiYgZWxlbVsgdHlwZSBdICYmICFqUXVlcnkuaXNXaW5kb3coIGVsZW0gKSApIHtcblxuXHRcdFx0XHRcdC8vIERvbid0IHJlLXRyaWdnZXIgYW4gb25GT08gZXZlbnQgd2hlbiB3ZSBjYWxsIGl0cyBGT08oKSBtZXRob2Rcblx0XHRcdFx0XHR0bXAgPSBlbGVtWyBvbnR5cGUgXTtcblxuXHRcdFx0XHRcdGlmICggdG1wICkge1xuXHRcdFx0XHRcdFx0ZWxlbVsgb250eXBlIF0gPSBudWxsO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIFByZXZlbnQgcmUtdHJpZ2dlcmluZyBvZiB0aGUgc2FtZSBldmVudCwgc2luY2Ugd2UgYWxyZWFkeSBidWJibGVkIGl0IGFib3ZlXG5cdFx0XHRcdFx0alF1ZXJ5LmV2ZW50LnRyaWdnZXJlZCA9IHR5cGU7XG5cdFx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRcdGVsZW1bIHR5cGUgXSgpO1xuXHRcdFx0XHRcdH0gY2F0Y2ggKCBlICkge1xuXG5cdFx0XHRcdFx0XHQvLyBJRTw5IGRpZXMgb24gZm9jdXMvYmx1ciB0byBoaWRkZW4gZWxlbWVudCAoIzE0ODYsIzEyNTE4KVxuXHRcdFx0XHRcdFx0Ly8gb25seSByZXByb2R1Y2libGUgb24gd2luWFAgSUU4IG5hdGl2ZSwgbm90IElFOSBpbiBJRTggbW9kZVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRqUXVlcnkuZXZlbnQudHJpZ2dlcmVkID0gdW5kZWZpbmVkO1xuXG5cdFx0XHRcdFx0aWYgKCB0bXAgKSB7XG5cdFx0XHRcdFx0XHRlbGVtWyBvbnR5cGUgXSA9IHRtcDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gZXZlbnQucmVzdWx0O1xuXHR9LFxuXG5cdGRpc3BhdGNoOiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cblx0XHQvLyBNYWtlIGEgd3JpdGFibGUgalF1ZXJ5LkV2ZW50IGZyb20gdGhlIG5hdGl2ZSBldmVudCBvYmplY3Rcblx0XHRldmVudCA9IGpRdWVyeS5ldmVudC5maXgoIGV2ZW50ICk7XG5cblx0XHR2YXIgaSwgaiwgcmV0LCBtYXRjaGVkLCBoYW5kbGVPYmosXG5cdFx0XHRoYW5kbGVyUXVldWUgPSBbXSxcblx0XHRcdGFyZ3MgPSBzbGljZS5jYWxsKCBhcmd1bWVudHMgKSxcblx0XHRcdGhhbmRsZXJzID0gKCBqUXVlcnkuX2RhdGEoIHRoaXMsIFwiZXZlbnRzXCIgKSB8fCB7fSApWyBldmVudC50eXBlIF0gfHwgW10sXG5cdFx0XHRzcGVjaWFsID0galF1ZXJ5LmV2ZW50LnNwZWNpYWxbIGV2ZW50LnR5cGUgXSB8fCB7fTtcblxuXHRcdC8vIFVzZSB0aGUgZml4LWVkIGpRdWVyeS5FdmVudCByYXRoZXIgdGhhbiB0aGUgKHJlYWQtb25seSkgbmF0aXZlIGV2ZW50XG5cdFx0YXJnc1sgMCBdID0gZXZlbnQ7XG5cdFx0ZXZlbnQuZGVsZWdhdGVUYXJnZXQgPSB0aGlzO1xuXG5cdFx0Ly8gQ2FsbCB0aGUgcHJlRGlzcGF0Y2ggaG9vayBmb3IgdGhlIG1hcHBlZCB0eXBlLCBhbmQgbGV0IGl0IGJhaWwgaWYgZGVzaXJlZFxuXHRcdGlmICggc3BlY2lhbC5wcmVEaXNwYXRjaCAmJiBzcGVjaWFsLnByZURpc3BhdGNoLmNhbGwoIHRoaXMsIGV2ZW50ICkgPT09IGZhbHNlICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIERldGVybWluZSBoYW5kbGVyc1xuXHRcdGhhbmRsZXJRdWV1ZSA9IGpRdWVyeS5ldmVudC5oYW5kbGVycy5jYWxsKCB0aGlzLCBldmVudCwgaGFuZGxlcnMgKTtcblxuXHRcdC8vIFJ1biBkZWxlZ2F0ZXMgZmlyc3Q7IHRoZXkgbWF5IHdhbnQgdG8gc3RvcCBwcm9wYWdhdGlvbiBiZW5lYXRoIHVzXG5cdFx0aSA9IDA7XG5cdFx0d2hpbGUgKCAoIG1hdGNoZWQgPSBoYW5kbGVyUXVldWVbIGkrKyBdICkgJiYgIWV2ZW50LmlzUHJvcGFnYXRpb25TdG9wcGVkKCkgKSB7XG5cdFx0XHRldmVudC5jdXJyZW50VGFyZ2V0ID0gbWF0Y2hlZC5lbGVtO1xuXG5cdFx0XHRqID0gMDtcblx0XHRcdHdoaWxlICggKCBoYW5kbGVPYmogPSBtYXRjaGVkLmhhbmRsZXJzWyBqKysgXSApICYmXG5cdFx0XHRcdCFldmVudC5pc0ltbWVkaWF0ZVByb3BhZ2F0aW9uU3RvcHBlZCgpICkge1xuXG5cdFx0XHRcdC8vIFRyaWdnZXJlZCBldmVudCBtdXN0IGVpdGhlciAxKSBoYXZlIG5vIG5hbWVzcGFjZSwgb3IgMikgaGF2ZSBuYW1lc3BhY2Uocylcblx0XHRcdFx0Ly8gYSBzdWJzZXQgb3IgZXF1YWwgdG8gdGhvc2UgaW4gdGhlIGJvdW5kIGV2ZW50IChib3RoIGNhbiBoYXZlIG5vIG5hbWVzcGFjZSkuXG5cdFx0XHRcdGlmICggIWV2ZW50LnJuYW1lc3BhY2UgfHwgZXZlbnQucm5hbWVzcGFjZS50ZXN0KCBoYW5kbGVPYmoubmFtZXNwYWNlICkgKSB7XG5cblx0XHRcdFx0XHRldmVudC5oYW5kbGVPYmogPSBoYW5kbGVPYmo7XG5cdFx0XHRcdFx0ZXZlbnQuZGF0YSA9IGhhbmRsZU9iai5kYXRhO1xuXG5cdFx0XHRcdFx0cmV0ID0gKCAoIGpRdWVyeS5ldmVudC5zcGVjaWFsWyBoYW5kbGVPYmoub3JpZ1R5cGUgXSB8fCB7fSApLmhhbmRsZSB8fFxuXHRcdFx0XHRcdFx0aGFuZGxlT2JqLmhhbmRsZXIgKS5hcHBseSggbWF0Y2hlZC5lbGVtLCBhcmdzICk7XG5cblx0XHRcdFx0XHRpZiAoIHJldCAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdFx0aWYgKCAoIGV2ZW50LnJlc3VsdCA9IHJldCApID09PSBmYWxzZSApIHtcblx0XHRcdFx0XHRcdFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcblx0XHRcdFx0XHRcdFx0ZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gQ2FsbCB0aGUgcG9zdERpc3BhdGNoIGhvb2sgZm9yIHRoZSBtYXBwZWQgdHlwZVxuXHRcdGlmICggc3BlY2lhbC5wb3N0RGlzcGF0Y2ggKSB7XG5cdFx0XHRzcGVjaWFsLnBvc3REaXNwYXRjaC5jYWxsKCB0aGlzLCBldmVudCApO1xuXHRcdH1cblxuXHRcdHJldHVybiBldmVudC5yZXN1bHQ7XG5cdH0sXG5cblx0aGFuZGxlcnM6IGZ1bmN0aW9uKCBldmVudCwgaGFuZGxlcnMgKSB7XG5cdFx0dmFyIGksIG1hdGNoZXMsIHNlbCwgaGFuZGxlT2JqLFxuXHRcdFx0aGFuZGxlclF1ZXVlID0gW10sXG5cdFx0XHRkZWxlZ2F0ZUNvdW50ID0gaGFuZGxlcnMuZGVsZWdhdGVDb3VudCxcblx0XHRcdGN1ciA9IGV2ZW50LnRhcmdldDtcblxuXHRcdC8vIFN1cHBvcnQgKGF0IGxlYXN0KTogQ2hyb21lLCBJRTlcblx0XHQvLyBGaW5kIGRlbGVnYXRlIGhhbmRsZXJzXG5cdFx0Ly8gQmxhY2staG9sZSBTVkcgPHVzZT4gaW5zdGFuY2UgdHJlZXMgKCMxMzE4MClcblx0XHQvL1xuXHRcdC8vIFN1cHBvcnQ6IEZpcmVmb3g8PTQyK1xuXHRcdC8vIEF2b2lkIG5vbi1sZWZ0LWNsaWNrIGluIEZGIGJ1dCBkb24ndCBibG9jayBJRSByYWRpbyBldmVudHMgKCMzODYxLCBnaC0yMzQzKVxuXHRcdGlmICggZGVsZWdhdGVDb3VudCAmJiBjdXIubm9kZVR5cGUgJiZcblx0XHRcdCggZXZlbnQudHlwZSAhPT0gXCJjbGlja1wiIHx8IGlzTmFOKCBldmVudC5idXR0b24gKSB8fCBldmVudC5idXR0b24gPCAxICkgKSB7XG5cblx0XHRcdC8qIGpzaGludCBlcWVxZXE6IGZhbHNlICovXG5cdFx0XHRmb3IgKCA7IGN1ciAhPSB0aGlzOyBjdXIgPSBjdXIucGFyZW50Tm9kZSB8fCB0aGlzICkge1xuXHRcdFx0XHQvKiBqc2hpbnQgZXFlcWVxOiB0cnVlICovXG5cblx0XHRcdFx0Ly8gRG9uJ3QgY2hlY2sgbm9uLWVsZW1lbnRzICgjMTMyMDgpXG5cdFx0XHRcdC8vIERvbid0IHByb2Nlc3MgY2xpY2tzIG9uIGRpc2FibGVkIGVsZW1lbnRzICgjNjkxMSwgIzgxNjUsICMxMTM4MiwgIzExNzY0KVxuXHRcdFx0XHRpZiAoIGN1ci5ub2RlVHlwZSA9PT0gMSAmJiAoIGN1ci5kaXNhYmxlZCAhPT0gdHJ1ZSB8fCBldmVudC50eXBlICE9PSBcImNsaWNrXCIgKSApIHtcblx0XHRcdFx0XHRtYXRjaGVzID0gW107XG5cdFx0XHRcdFx0Zm9yICggaSA9IDA7IGkgPCBkZWxlZ2F0ZUNvdW50OyBpKysgKSB7XG5cdFx0XHRcdFx0XHRoYW5kbGVPYmogPSBoYW5kbGVyc1sgaSBdO1xuXG5cdFx0XHRcdFx0XHQvLyBEb24ndCBjb25mbGljdCB3aXRoIE9iamVjdC5wcm90b3R5cGUgcHJvcGVydGllcyAoIzEzMjAzKVxuXHRcdFx0XHRcdFx0c2VsID0gaGFuZGxlT2JqLnNlbGVjdG9yICsgXCIgXCI7XG5cblx0XHRcdFx0XHRcdGlmICggbWF0Y2hlc1sgc2VsIF0gPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHRcdFx0bWF0Y2hlc1sgc2VsIF0gPSBoYW5kbGVPYmoubmVlZHNDb250ZXh0ID9cblx0XHRcdFx0XHRcdFx0XHRqUXVlcnkoIHNlbCwgdGhpcyApLmluZGV4KCBjdXIgKSA+IC0xIDpcblx0XHRcdFx0XHRcdFx0XHRqUXVlcnkuZmluZCggc2VsLCB0aGlzLCBudWxsLCBbIGN1ciBdICkubGVuZ3RoO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0aWYgKCBtYXRjaGVzWyBzZWwgXSApIHtcblx0XHRcdFx0XHRcdFx0bWF0Y2hlcy5wdXNoKCBoYW5kbGVPYmogKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKCBtYXRjaGVzLmxlbmd0aCApIHtcblx0XHRcdFx0XHRcdGhhbmRsZXJRdWV1ZS5wdXNoKCB7IGVsZW06IGN1ciwgaGFuZGxlcnM6IG1hdGNoZXMgfSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIEFkZCB0aGUgcmVtYWluaW5nIChkaXJlY3RseS1ib3VuZCkgaGFuZGxlcnNcblx0XHRpZiAoIGRlbGVnYXRlQ291bnQgPCBoYW5kbGVycy5sZW5ndGggKSB7XG5cdFx0XHRoYW5kbGVyUXVldWUucHVzaCggeyBlbGVtOiB0aGlzLCBoYW5kbGVyczogaGFuZGxlcnMuc2xpY2UoIGRlbGVnYXRlQ291bnQgKSB9ICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGhhbmRsZXJRdWV1ZTtcblx0fSxcblxuXHRmaXg6IGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHRpZiAoIGV2ZW50WyBqUXVlcnkuZXhwYW5kbyBdICkge1xuXHRcdFx0cmV0dXJuIGV2ZW50O1xuXHRcdH1cblxuXHRcdC8vIENyZWF0ZSBhIHdyaXRhYmxlIGNvcHkgb2YgdGhlIGV2ZW50IG9iamVjdCBhbmQgbm9ybWFsaXplIHNvbWUgcHJvcGVydGllc1xuXHRcdHZhciBpLCBwcm9wLCBjb3B5LFxuXHRcdFx0dHlwZSA9IGV2ZW50LnR5cGUsXG5cdFx0XHRvcmlnaW5hbEV2ZW50ID0gZXZlbnQsXG5cdFx0XHRmaXhIb29rID0gdGhpcy5maXhIb29rc1sgdHlwZSBdO1xuXG5cdFx0aWYgKCAhZml4SG9vayApIHtcblx0XHRcdHRoaXMuZml4SG9va3NbIHR5cGUgXSA9IGZpeEhvb2sgPVxuXHRcdFx0XHRybW91c2VFdmVudC50ZXN0KCB0eXBlICkgPyB0aGlzLm1vdXNlSG9va3MgOlxuXHRcdFx0XHRya2V5RXZlbnQudGVzdCggdHlwZSApID8gdGhpcy5rZXlIb29rcyA6XG5cdFx0XHRcdHt9O1xuXHRcdH1cblx0XHRjb3B5ID0gZml4SG9vay5wcm9wcyA/IHRoaXMucHJvcHMuY29uY2F0KCBmaXhIb29rLnByb3BzICkgOiB0aGlzLnByb3BzO1xuXG5cdFx0ZXZlbnQgPSBuZXcgalF1ZXJ5LkV2ZW50KCBvcmlnaW5hbEV2ZW50ICk7XG5cblx0XHRpID0gY29weS5sZW5ndGg7XG5cdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRwcm9wID0gY29weVsgaSBdO1xuXHRcdFx0ZXZlbnRbIHByb3AgXSA9IG9yaWdpbmFsRXZlbnRbIHByb3AgXTtcblx0XHR9XG5cblx0XHQvLyBTdXBwb3J0OiBJRTw5XG5cdFx0Ly8gRml4IHRhcmdldCBwcm9wZXJ0eSAoIzE5MjUpXG5cdFx0aWYgKCAhZXZlbnQudGFyZ2V0ICkge1xuXHRcdFx0ZXZlbnQudGFyZ2V0ID0gb3JpZ2luYWxFdmVudC5zcmNFbGVtZW50IHx8IGRvY3VtZW50O1xuXHRcdH1cblxuXHRcdC8vIFN1cHBvcnQ6IFNhZmFyaSA2LTgrXG5cdFx0Ly8gVGFyZ2V0IHNob3VsZCBub3QgYmUgYSB0ZXh0IG5vZGUgKCM1MDQsICMxMzE0Mylcblx0XHRpZiAoIGV2ZW50LnRhcmdldC5ub2RlVHlwZSA9PT0gMyApIHtcblx0XHRcdGV2ZW50LnRhcmdldCA9IGV2ZW50LnRhcmdldC5wYXJlbnROb2RlO1xuXHRcdH1cblxuXHRcdC8vIFN1cHBvcnQ6IElFPDlcblx0XHQvLyBGb3IgbW91c2Uva2V5IGV2ZW50cywgbWV0YUtleT09ZmFsc2UgaWYgaXQncyB1bmRlZmluZWQgKCMzMzY4LCAjMTEzMjgpXG5cdFx0ZXZlbnQubWV0YUtleSA9ICEhZXZlbnQubWV0YUtleTtcblxuXHRcdHJldHVybiBmaXhIb29rLmZpbHRlciA/IGZpeEhvb2suZmlsdGVyKCBldmVudCwgb3JpZ2luYWxFdmVudCApIDogZXZlbnQ7XG5cdH0sXG5cblx0Ly8gSW5jbHVkZXMgc29tZSBldmVudCBwcm9wcyBzaGFyZWQgYnkgS2V5RXZlbnQgYW5kIE1vdXNlRXZlbnRcblx0cHJvcHM6ICggXCJhbHRLZXkgYnViYmxlcyBjYW5jZWxhYmxlIGN0cmxLZXkgY3VycmVudFRhcmdldCBkZXRhaWwgZXZlbnRQaGFzZSBcIiArXG5cdFx0XCJtZXRhS2V5IHJlbGF0ZWRUYXJnZXQgc2hpZnRLZXkgdGFyZ2V0IHRpbWVTdGFtcCB2aWV3IHdoaWNoXCIgKS5zcGxpdCggXCIgXCIgKSxcblxuXHRmaXhIb29rczoge30sXG5cblx0a2V5SG9va3M6IHtcblx0XHRwcm9wczogXCJjaGFyIGNoYXJDb2RlIGtleSBrZXlDb2RlXCIuc3BsaXQoIFwiIFwiICksXG5cdFx0ZmlsdGVyOiBmdW5jdGlvbiggZXZlbnQsIG9yaWdpbmFsICkge1xuXG5cdFx0XHQvLyBBZGQgd2hpY2ggZm9yIGtleSBldmVudHNcblx0XHRcdGlmICggZXZlbnQud2hpY2ggPT0gbnVsbCApIHtcblx0XHRcdFx0ZXZlbnQud2hpY2ggPSBvcmlnaW5hbC5jaGFyQ29kZSAhPSBudWxsID8gb3JpZ2luYWwuY2hhckNvZGUgOiBvcmlnaW5hbC5rZXlDb2RlO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZXZlbnQ7XG5cdFx0fVxuXHR9LFxuXG5cdG1vdXNlSG9va3M6IHtcblx0XHRwcm9wczogKCBcImJ1dHRvbiBidXR0b25zIGNsaWVudFggY2xpZW50WSBmcm9tRWxlbWVudCBvZmZzZXRYIG9mZnNldFkgXCIgK1xuXHRcdFx0XCJwYWdlWCBwYWdlWSBzY3JlZW5YIHNjcmVlblkgdG9FbGVtZW50XCIgKS5zcGxpdCggXCIgXCIgKSxcblx0XHRmaWx0ZXI6IGZ1bmN0aW9uKCBldmVudCwgb3JpZ2luYWwgKSB7XG5cdFx0XHR2YXIgYm9keSwgZXZlbnREb2MsIGRvYyxcblx0XHRcdFx0YnV0dG9uID0gb3JpZ2luYWwuYnV0dG9uLFxuXHRcdFx0XHRmcm9tRWxlbWVudCA9IG9yaWdpbmFsLmZyb21FbGVtZW50O1xuXG5cdFx0XHQvLyBDYWxjdWxhdGUgcGFnZVgvWSBpZiBtaXNzaW5nIGFuZCBjbGllbnRYL1kgYXZhaWxhYmxlXG5cdFx0XHRpZiAoIGV2ZW50LnBhZ2VYID09IG51bGwgJiYgb3JpZ2luYWwuY2xpZW50WCAhPSBudWxsICkge1xuXHRcdFx0XHRldmVudERvYyA9IGV2ZW50LnRhcmdldC5vd25lckRvY3VtZW50IHx8IGRvY3VtZW50O1xuXHRcdFx0XHRkb2MgPSBldmVudERvYy5kb2N1bWVudEVsZW1lbnQ7XG5cdFx0XHRcdGJvZHkgPSBldmVudERvYy5ib2R5O1xuXG5cdFx0XHRcdGV2ZW50LnBhZ2VYID0gb3JpZ2luYWwuY2xpZW50WCArXG5cdFx0XHRcdFx0KCBkb2MgJiYgZG9jLnNjcm9sbExlZnQgfHwgYm9keSAmJiBib2R5LnNjcm9sbExlZnQgfHwgMCApIC1cblx0XHRcdFx0XHQoIGRvYyAmJiBkb2MuY2xpZW50TGVmdCB8fCBib2R5ICYmIGJvZHkuY2xpZW50TGVmdCB8fCAwICk7XG5cdFx0XHRcdGV2ZW50LnBhZ2VZID0gb3JpZ2luYWwuY2xpZW50WSArXG5cdFx0XHRcdFx0KCBkb2MgJiYgZG9jLnNjcm9sbFRvcCAgfHwgYm9keSAmJiBib2R5LnNjcm9sbFRvcCAgfHwgMCApIC1cblx0XHRcdFx0XHQoIGRvYyAmJiBkb2MuY2xpZW50VG9wICB8fCBib2R5ICYmIGJvZHkuY2xpZW50VG9wICB8fCAwICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEFkZCByZWxhdGVkVGFyZ2V0LCBpZiBuZWNlc3Nhcnlcblx0XHRcdGlmICggIWV2ZW50LnJlbGF0ZWRUYXJnZXQgJiYgZnJvbUVsZW1lbnQgKSB7XG5cdFx0XHRcdGV2ZW50LnJlbGF0ZWRUYXJnZXQgPSBmcm9tRWxlbWVudCA9PT0gZXZlbnQudGFyZ2V0ID9cblx0XHRcdFx0XHRvcmlnaW5hbC50b0VsZW1lbnQgOlxuXHRcdFx0XHRcdGZyb21FbGVtZW50O1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBBZGQgd2hpY2ggZm9yIGNsaWNrOiAxID09PSBsZWZ0OyAyID09PSBtaWRkbGU7IDMgPT09IHJpZ2h0XG5cdFx0XHQvLyBOb3RlOiBidXR0b24gaXMgbm90IG5vcm1hbGl6ZWQsIHNvIGRvbid0IHVzZSBpdFxuXHRcdFx0aWYgKCAhZXZlbnQud2hpY2ggJiYgYnV0dG9uICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdGV2ZW50LndoaWNoID0gKCBidXR0b24gJiAxID8gMSA6ICggYnV0dG9uICYgMiA/IDMgOiAoIGJ1dHRvbiAmIDQgPyAyIDogMCApICkgKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGV2ZW50O1xuXHRcdH1cblx0fSxcblxuXHRzcGVjaWFsOiB7XG5cdFx0bG9hZDoge1xuXG5cdFx0XHQvLyBQcmV2ZW50IHRyaWdnZXJlZCBpbWFnZS5sb2FkIGV2ZW50cyBmcm9tIGJ1YmJsaW5nIHRvIHdpbmRvdy5sb2FkXG5cdFx0XHRub0J1YmJsZTogdHJ1ZVxuXHRcdH0sXG5cdFx0Zm9jdXM6IHtcblxuXHRcdFx0Ly8gRmlyZSBuYXRpdmUgZXZlbnQgaWYgcG9zc2libGUgc28gYmx1ci9mb2N1cyBzZXF1ZW5jZSBpcyBjb3JyZWN0XG5cdFx0XHR0cmlnZ2VyOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKCB0aGlzICE9PSBzYWZlQWN0aXZlRWxlbWVudCgpICYmIHRoaXMuZm9jdXMgKSB7XG5cdFx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRcdHRoaXMuZm9jdXMoKTtcblx0XHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0XHR9IGNhdGNoICggZSApIHtcblxuXHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUU8OVxuXHRcdFx0XHRcdFx0Ly8gSWYgd2UgZXJyb3Igb24gZm9jdXMgdG8gaGlkZGVuIGVsZW1lbnQgKCMxNDg2LCAjMTI1MTgpLFxuXHRcdFx0XHRcdFx0Ly8gbGV0IC50cmlnZ2VyKCkgcnVuIHRoZSBoYW5kbGVyc1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdGRlbGVnYXRlVHlwZTogXCJmb2N1c2luXCJcblx0XHR9LFxuXHRcdGJsdXI6IHtcblx0XHRcdHRyaWdnZXI6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoIHRoaXMgPT09IHNhZmVBY3RpdmVFbGVtZW50KCkgJiYgdGhpcy5ibHVyICkge1xuXHRcdFx0XHRcdHRoaXMuYmx1cigpO1xuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdGRlbGVnYXRlVHlwZTogXCJmb2N1c291dFwiXG5cdFx0fSxcblx0XHRjbGljazoge1xuXG5cdFx0XHQvLyBGb3IgY2hlY2tib3gsIGZpcmUgbmF0aXZlIGV2ZW50IHNvIGNoZWNrZWQgc3RhdGUgd2lsbCBiZSByaWdodFxuXHRcdFx0dHJpZ2dlcjogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggalF1ZXJ5Lm5vZGVOYW1lKCB0aGlzLCBcImlucHV0XCIgKSAmJiB0aGlzLnR5cGUgPT09IFwiY2hlY2tib3hcIiAmJiB0aGlzLmNsaWNrICkge1xuXHRcdFx0XHRcdHRoaXMuY2xpY2soKTtcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cblx0XHRcdC8vIEZvciBjcm9zcy1icm93c2VyIGNvbnNpc3RlbmN5LCBkb24ndCBmaXJlIG5hdGl2ZSAuY2xpY2soKSBvbiBsaW5rc1xuXHRcdFx0X2RlZmF1bHQ6IGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHRcdFx0cmV0dXJuIGpRdWVyeS5ub2RlTmFtZSggZXZlbnQudGFyZ2V0LCBcImFcIiApO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHRiZWZvcmV1bmxvYWQ6IHtcblx0XHRcdHBvc3REaXNwYXRjaDogZnVuY3Rpb24oIGV2ZW50ICkge1xuXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IEZpcmVmb3ggMjArXG5cdFx0XHRcdC8vIEZpcmVmb3ggZG9lc24ndCBhbGVydCBpZiB0aGUgcmV0dXJuVmFsdWUgZmllbGQgaXMgbm90IHNldC5cblx0XHRcdFx0aWYgKCBldmVudC5yZXN1bHQgIT09IHVuZGVmaW5lZCAmJiBldmVudC5vcmlnaW5hbEV2ZW50ICkge1xuXHRcdFx0XHRcdGV2ZW50Lm9yaWdpbmFsRXZlbnQucmV0dXJuVmFsdWUgPSBldmVudC5yZXN1bHQ7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0Ly8gUGlnZ3liYWNrIG9uIGEgZG9ub3IgZXZlbnQgdG8gc2ltdWxhdGUgYSBkaWZmZXJlbnQgb25lXG5cdHNpbXVsYXRlOiBmdW5jdGlvbiggdHlwZSwgZWxlbSwgZXZlbnQgKSB7XG5cdFx0dmFyIGUgPSBqUXVlcnkuZXh0ZW5kKFxuXHRcdFx0bmV3IGpRdWVyeS5FdmVudCgpLFxuXHRcdFx0ZXZlbnQsXG5cdFx0XHR7XG5cdFx0XHRcdHR5cGU6IHR5cGUsXG5cdFx0XHRcdGlzU2ltdWxhdGVkOiB0cnVlXG5cblx0XHRcdFx0Ly8gUHJldmlvdXNseSwgYG9yaWdpbmFsRXZlbnQ6IHt9YCB3YXMgc2V0IGhlcmUsIHNvIHN0b3BQcm9wYWdhdGlvbiBjYWxsXG5cdFx0XHRcdC8vIHdvdWxkIG5vdCBiZSB0cmlnZ2VyZWQgb24gZG9ub3IgZXZlbnQsIHNpbmNlIGluIG91ciBvd25cblx0XHRcdFx0Ly8galF1ZXJ5LmV2ZW50LnN0b3BQcm9wYWdhdGlvbiBmdW5jdGlvbiB3ZSBoYWQgYSBjaGVjayBmb3IgZXhpc3RlbmNlIG9mXG5cdFx0XHRcdC8vIG9yaWdpbmFsRXZlbnQuc3RvcFByb3BhZ2F0aW9uIG1ldGhvZCwgc28sIGNvbnNlcXVlbnRseSBpdCB3b3VsZCBiZSBhIG5vb3AuXG5cdFx0XHRcdC8vXG5cdFx0XHRcdC8vIEd1YXJkIGZvciBzaW11bGF0ZWQgZXZlbnRzIHdhcyBtb3ZlZCB0byBqUXVlcnkuZXZlbnQuc3RvcFByb3BhZ2F0aW9uIGZ1bmN0aW9uXG5cdFx0XHRcdC8vIHNpbmNlIGBvcmlnaW5hbEV2ZW50YCBzaG91bGQgcG9pbnQgdG8gdGhlIG9yaWdpbmFsIGV2ZW50IGZvciB0aGVcblx0XHRcdFx0Ly8gY29uc3RhbmN5IHdpdGggb3RoZXIgZXZlbnRzIGFuZCBmb3IgbW9yZSBmb2N1c2VkIGxvZ2ljXG5cdFx0XHR9XG5cdFx0KTtcblxuXHRcdGpRdWVyeS5ldmVudC50cmlnZ2VyKCBlLCBudWxsLCBlbGVtICk7XG5cblx0XHRpZiAoIGUuaXNEZWZhdWx0UHJldmVudGVkKCkgKSB7XG5cdFx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdH1cblx0fVxufTtcblxualF1ZXJ5LnJlbW92ZUV2ZW50ID0gZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lciA/XG5cdGZ1bmN0aW9uKCBlbGVtLCB0eXBlLCBoYW5kbGUgKSB7XG5cblx0XHQvLyBUaGlzIFwiaWZcIiBpcyBuZWVkZWQgZm9yIHBsYWluIG9iamVjdHNcblx0XHRpZiAoIGVsZW0ucmVtb3ZlRXZlbnRMaXN0ZW5lciApIHtcblx0XHRcdGVsZW0ucmVtb3ZlRXZlbnRMaXN0ZW5lciggdHlwZSwgaGFuZGxlICk7XG5cdFx0fVxuXHR9IDpcblx0ZnVuY3Rpb24oIGVsZW0sIHR5cGUsIGhhbmRsZSApIHtcblx0XHR2YXIgbmFtZSA9IFwib25cIiArIHR5cGU7XG5cblx0XHRpZiAoIGVsZW0uZGV0YWNoRXZlbnQgKSB7XG5cblx0XHRcdC8vICM4NTQ1LCAjNzA1NCwgcHJldmVudGluZyBtZW1vcnkgbGVha3MgZm9yIGN1c3RvbSBldmVudHMgaW4gSUU2LThcblx0XHRcdC8vIGRldGFjaEV2ZW50IG5lZWRlZCBwcm9wZXJ0eSBvbiBlbGVtZW50LCBieSBuYW1lIG9mIHRoYXQgZXZlbnQsXG5cdFx0XHQvLyB0byBwcm9wZXJseSBleHBvc2UgaXQgdG8gR0Ncblx0XHRcdGlmICggdHlwZW9mIGVsZW1bIG5hbWUgXSA9PT0gXCJ1bmRlZmluZWRcIiApIHtcblx0XHRcdFx0ZWxlbVsgbmFtZSBdID0gbnVsbDtcblx0XHRcdH1cblxuXHRcdFx0ZWxlbS5kZXRhY2hFdmVudCggbmFtZSwgaGFuZGxlICk7XG5cdFx0fVxuXHR9O1xuXG5qUXVlcnkuRXZlbnQgPSBmdW5jdGlvbiggc3JjLCBwcm9wcyApIHtcblxuXHQvLyBBbGxvdyBpbnN0YW50aWF0aW9uIHdpdGhvdXQgdGhlICduZXcnIGtleXdvcmRcblx0aWYgKCAhKCB0aGlzIGluc3RhbmNlb2YgalF1ZXJ5LkV2ZW50ICkgKSB7XG5cdFx0cmV0dXJuIG5ldyBqUXVlcnkuRXZlbnQoIHNyYywgcHJvcHMgKTtcblx0fVxuXG5cdC8vIEV2ZW50IG9iamVjdFxuXHRpZiAoIHNyYyAmJiBzcmMudHlwZSApIHtcblx0XHR0aGlzLm9yaWdpbmFsRXZlbnQgPSBzcmM7XG5cdFx0dGhpcy50eXBlID0gc3JjLnR5cGU7XG5cblx0XHQvLyBFdmVudHMgYnViYmxpbmcgdXAgdGhlIGRvY3VtZW50IG1heSBoYXZlIGJlZW4gbWFya2VkIGFzIHByZXZlbnRlZFxuXHRcdC8vIGJ5IGEgaGFuZGxlciBsb3dlciBkb3duIHRoZSB0cmVlOyByZWZsZWN0IHRoZSBjb3JyZWN0IHZhbHVlLlxuXHRcdHRoaXMuaXNEZWZhdWx0UHJldmVudGVkID0gc3JjLmRlZmF1bHRQcmV2ZW50ZWQgfHxcblx0XHRcdFx0c3JjLmRlZmF1bHRQcmV2ZW50ZWQgPT09IHVuZGVmaW5lZCAmJlxuXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDwgOSwgQW5kcm9pZCA8IDQuMFxuXHRcdFx0XHRzcmMucmV0dXJuVmFsdWUgPT09IGZhbHNlID9cblx0XHRcdHJldHVyblRydWUgOlxuXHRcdFx0cmV0dXJuRmFsc2U7XG5cblx0Ly8gRXZlbnQgdHlwZVxuXHR9IGVsc2Uge1xuXHRcdHRoaXMudHlwZSA9IHNyYztcblx0fVxuXG5cdC8vIFB1dCBleHBsaWNpdGx5IHByb3ZpZGVkIHByb3BlcnRpZXMgb250byB0aGUgZXZlbnQgb2JqZWN0XG5cdGlmICggcHJvcHMgKSB7XG5cdFx0alF1ZXJ5LmV4dGVuZCggdGhpcywgcHJvcHMgKTtcblx0fVxuXG5cdC8vIENyZWF0ZSBhIHRpbWVzdGFtcCBpZiBpbmNvbWluZyBldmVudCBkb2Vzbid0IGhhdmUgb25lXG5cdHRoaXMudGltZVN0YW1wID0gc3JjICYmIHNyYy50aW1lU3RhbXAgfHwgalF1ZXJ5Lm5vdygpO1xuXG5cdC8vIE1hcmsgaXQgYXMgZml4ZWRcblx0dGhpc1sgalF1ZXJ5LmV4cGFuZG8gXSA9IHRydWU7XG59O1xuXG4vLyBqUXVlcnkuRXZlbnQgaXMgYmFzZWQgb24gRE9NMyBFdmVudHMgYXMgc3BlY2lmaWVkIGJ5IHRoZSBFQ01BU2NyaXB0IExhbmd1YWdlIEJpbmRpbmdcbi8vIGh0dHA6Ly93d3cudzMub3JnL1RSLzIwMDMvV0QtRE9NLUxldmVsLTMtRXZlbnRzLTIwMDMwMzMxL2VjbWEtc2NyaXB0LWJpbmRpbmcuaHRtbFxualF1ZXJ5LkV2ZW50LnByb3RvdHlwZSA9IHtcblx0Y29uc3RydWN0b3I6IGpRdWVyeS5FdmVudCxcblx0aXNEZWZhdWx0UHJldmVudGVkOiByZXR1cm5GYWxzZSxcblx0aXNQcm9wYWdhdGlvblN0b3BwZWQ6IHJldHVybkZhbHNlLFxuXHRpc0ltbWVkaWF0ZVByb3BhZ2F0aW9uU3RvcHBlZDogcmV0dXJuRmFsc2UsXG5cblx0cHJldmVudERlZmF1bHQ6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBlID0gdGhpcy5vcmlnaW5hbEV2ZW50O1xuXG5cdFx0dGhpcy5pc0RlZmF1bHRQcmV2ZW50ZWQgPSByZXR1cm5UcnVlO1xuXHRcdGlmICggIWUgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gSWYgcHJldmVudERlZmF1bHQgZXhpc3RzLCBydW4gaXQgb24gdGhlIG9yaWdpbmFsIGV2ZW50XG5cdFx0aWYgKCBlLnByZXZlbnREZWZhdWx0ICkge1xuXHRcdFx0ZS5wcmV2ZW50RGVmYXVsdCgpO1xuXG5cdFx0Ly8gU3VwcG9ydDogSUVcblx0XHQvLyBPdGhlcndpc2Ugc2V0IHRoZSByZXR1cm5WYWx1ZSBwcm9wZXJ0eSBvZiB0aGUgb3JpZ2luYWwgZXZlbnQgdG8gZmFsc2Vcblx0XHR9IGVsc2Uge1xuXHRcdFx0ZS5yZXR1cm5WYWx1ZSA9IGZhbHNlO1xuXHRcdH1cblx0fSxcblx0c3RvcFByb3BhZ2F0aW9uOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgZSA9IHRoaXMub3JpZ2luYWxFdmVudDtcblxuXHRcdHRoaXMuaXNQcm9wYWdhdGlvblN0b3BwZWQgPSByZXR1cm5UcnVlO1xuXG5cdFx0aWYgKCAhZSB8fCB0aGlzLmlzU2ltdWxhdGVkICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIElmIHN0b3BQcm9wYWdhdGlvbiBleGlzdHMsIHJ1biBpdCBvbiB0aGUgb3JpZ2luYWwgZXZlbnRcblx0XHRpZiAoIGUuc3RvcFByb3BhZ2F0aW9uICkge1xuXHRcdFx0ZS5zdG9wUHJvcGFnYXRpb24oKTtcblx0XHR9XG5cblx0XHQvLyBTdXBwb3J0OiBJRVxuXHRcdC8vIFNldCB0aGUgY2FuY2VsQnViYmxlIHByb3BlcnR5IG9mIHRoZSBvcmlnaW5hbCBldmVudCB0byB0cnVlXG5cdFx0ZS5jYW5jZWxCdWJibGUgPSB0cnVlO1xuXHR9LFxuXHRzdG9wSW1tZWRpYXRlUHJvcGFnYXRpb246IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBlID0gdGhpcy5vcmlnaW5hbEV2ZW50O1xuXG5cdFx0dGhpcy5pc0ltbWVkaWF0ZVByb3BhZ2F0aW9uU3RvcHBlZCA9IHJldHVyblRydWU7XG5cblx0XHRpZiAoIGUgJiYgZS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24gKSB7XG5cdFx0XHRlLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xuXHRcdH1cblxuXHRcdHRoaXMuc3RvcFByb3BhZ2F0aW9uKCk7XG5cdH1cbn07XG5cbi8vIENyZWF0ZSBtb3VzZWVudGVyL2xlYXZlIGV2ZW50cyB1c2luZyBtb3VzZW92ZXIvb3V0IGFuZCBldmVudC10aW1lIGNoZWNrc1xuLy8gc28gdGhhdCBldmVudCBkZWxlZ2F0aW9uIHdvcmtzIGluIGpRdWVyeS5cbi8vIERvIHRoZSBzYW1lIGZvciBwb2ludGVyZW50ZXIvcG9pbnRlcmxlYXZlIGFuZCBwb2ludGVyb3Zlci9wb2ludGVyb3V0XG4vL1xuLy8gU3VwcG9ydDogU2FmYXJpIDcgb25seVxuLy8gU2FmYXJpIHNlbmRzIG1vdXNlZW50ZXIgdG9vIG9mdGVuOyBzZWU6XG4vLyBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9NDcwMjU4XG4vLyBmb3IgdGhlIGRlc2NyaXB0aW9uIG9mIHRoZSBidWcgKGl0IGV4aXN0ZWQgaW4gb2xkZXIgQ2hyb21lIHZlcnNpb25zIGFzIHdlbGwpLlxualF1ZXJ5LmVhY2goIHtcblx0bW91c2VlbnRlcjogXCJtb3VzZW92ZXJcIixcblx0bW91c2VsZWF2ZTogXCJtb3VzZW91dFwiLFxuXHRwb2ludGVyZW50ZXI6IFwicG9pbnRlcm92ZXJcIixcblx0cG9pbnRlcmxlYXZlOiBcInBvaW50ZXJvdXRcIlxufSwgZnVuY3Rpb24oIG9yaWcsIGZpeCApIHtcblx0alF1ZXJ5LmV2ZW50LnNwZWNpYWxbIG9yaWcgXSA9IHtcblx0XHRkZWxlZ2F0ZVR5cGU6IGZpeCxcblx0XHRiaW5kVHlwZTogZml4LFxuXG5cdFx0aGFuZGxlOiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0XHR2YXIgcmV0LFxuXHRcdFx0XHR0YXJnZXQgPSB0aGlzLFxuXHRcdFx0XHRyZWxhdGVkID0gZXZlbnQucmVsYXRlZFRhcmdldCxcblx0XHRcdFx0aGFuZGxlT2JqID0gZXZlbnQuaGFuZGxlT2JqO1xuXG5cdFx0XHQvLyBGb3IgbW91c2VlbnRlci9sZWF2ZSBjYWxsIHRoZSBoYW5kbGVyIGlmIHJlbGF0ZWQgaXMgb3V0c2lkZSB0aGUgdGFyZ2V0LlxuXHRcdFx0Ly8gTkI6IE5vIHJlbGF0ZWRUYXJnZXQgaWYgdGhlIG1vdXNlIGxlZnQvZW50ZXJlZCB0aGUgYnJvd3NlciB3aW5kb3dcblx0XHRcdGlmICggIXJlbGF0ZWQgfHwgKCByZWxhdGVkICE9PSB0YXJnZXQgJiYgIWpRdWVyeS5jb250YWlucyggdGFyZ2V0LCByZWxhdGVkICkgKSApIHtcblx0XHRcdFx0ZXZlbnQudHlwZSA9IGhhbmRsZU9iai5vcmlnVHlwZTtcblx0XHRcdFx0cmV0ID0gaGFuZGxlT2JqLmhhbmRsZXIuYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApO1xuXHRcdFx0XHRldmVudC50eXBlID0gZml4O1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHJldDtcblx0XHR9XG5cdH07XG59ICk7XG5cbi8vIElFIHN1Ym1pdCBkZWxlZ2F0aW9uXG5pZiAoICFzdXBwb3J0LnN1Ym1pdCApIHtcblxuXHRqUXVlcnkuZXZlbnQuc3BlY2lhbC5zdWJtaXQgPSB7XG5cdFx0c2V0dXA6IGZ1bmN0aW9uKCkge1xuXG5cdFx0XHQvLyBPbmx5IG5lZWQgdGhpcyBmb3IgZGVsZWdhdGVkIGZvcm0gc3VibWl0IGV2ZW50c1xuXHRcdFx0aWYgKCBqUXVlcnkubm9kZU5hbWUoIHRoaXMsIFwiZm9ybVwiICkgKSB7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gTGF6eS1hZGQgYSBzdWJtaXQgaGFuZGxlciB3aGVuIGEgZGVzY2VuZGFudCBmb3JtIG1heSBwb3RlbnRpYWxseSBiZSBzdWJtaXR0ZWRcblx0XHRcdGpRdWVyeS5ldmVudC5hZGQoIHRoaXMsIFwiY2xpY2suX3N1Ym1pdCBrZXlwcmVzcy5fc3VibWl0XCIsIGZ1bmN0aW9uKCBlICkge1xuXG5cdFx0XHRcdC8vIE5vZGUgbmFtZSBjaGVjayBhdm9pZHMgYSBWTUwtcmVsYXRlZCBjcmFzaCBpbiBJRSAoIzk4MDcpXG5cdFx0XHRcdHZhciBlbGVtID0gZS50YXJnZXQsXG5cdFx0XHRcdFx0Zm9ybSA9IGpRdWVyeS5ub2RlTmFtZSggZWxlbSwgXCJpbnB1dFwiICkgfHwgalF1ZXJ5Lm5vZGVOYW1lKCBlbGVtLCBcImJ1dHRvblwiICkgP1xuXG5cdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA8PThcblx0XHRcdFx0XHRcdC8vIFdlIHVzZSBqUXVlcnkucHJvcCBpbnN0ZWFkIG9mIGVsZW0uZm9ybVxuXHRcdFx0XHRcdFx0Ly8gdG8gYWxsb3cgZml4aW5nIHRoZSBJRTggZGVsZWdhdGVkIHN1Ym1pdCBpc3N1ZSAoZ2gtMjMzMilcblx0XHRcdFx0XHRcdC8vIGJ5IDNyZCBwYXJ0eSBwb2x5ZmlsbHMvd29ya2Fyb3VuZHMuXG5cdFx0XHRcdFx0XHRqUXVlcnkucHJvcCggZWxlbSwgXCJmb3JtXCIgKSA6XG5cdFx0XHRcdFx0XHR1bmRlZmluZWQ7XG5cblx0XHRcdFx0aWYgKCBmb3JtICYmICFqUXVlcnkuX2RhdGEoIGZvcm0sIFwic3VibWl0XCIgKSApIHtcblx0XHRcdFx0XHRqUXVlcnkuZXZlbnQuYWRkKCBmb3JtLCBcInN1Ym1pdC5fc3VibWl0XCIsIGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHRcdFx0XHRcdGV2ZW50Ll9zdWJtaXRCdWJibGUgPSB0cnVlO1xuXHRcdFx0XHRcdH0gKTtcblx0XHRcdFx0XHRqUXVlcnkuX2RhdGEoIGZvcm0sIFwic3VibWl0XCIsIHRydWUgKTtcblx0XHRcdFx0fVxuXHRcdFx0fSApO1xuXG5cdFx0XHQvLyByZXR1cm4gdW5kZWZpbmVkIHNpbmNlIHdlIGRvbid0IG5lZWQgYW4gZXZlbnQgbGlzdGVuZXJcblx0XHR9LFxuXG5cdFx0cG9zdERpc3BhdGNoOiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cblx0XHRcdC8vIElmIGZvcm0gd2FzIHN1Ym1pdHRlZCBieSB0aGUgdXNlciwgYnViYmxlIHRoZSBldmVudCB1cCB0aGUgdHJlZVxuXHRcdFx0aWYgKCBldmVudC5fc3VibWl0QnViYmxlICkge1xuXHRcdFx0XHRkZWxldGUgZXZlbnQuX3N1Ym1pdEJ1YmJsZTtcblx0XHRcdFx0aWYgKCB0aGlzLnBhcmVudE5vZGUgJiYgIWV2ZW50LmlzVHJpZ2dlciApIHtcblx0XHRcdFx0XHRqUXVlcnkuZXZlbnQuc2ltdWxhdGUoIFwic3VibWl0XCIsIHRoaXMucGFyZW50Tm9kZSwgZXZlbnQgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHR0ZWFyZG93bjogZnVuY3Rpb24oKSB7XG5cblx0XHRcdC8vIE9ubHkgbmVlZCB0aGlzIGZvciBkZWxlZ2F0ZWQgZm9ybSBzdWJtaXQgZXZlbnRzXG5cdFx0XHRpZiAoIGpRdWVyeS5ub2RlTmFtZSggdGhpcywgXCJmb3JtXCIgKSApIHtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBSZW1vdmUgZGVsZWdhdGVkIGhhbmRsZXJzOyBjbGVhbkRhdGEgZXZlbnR1YWxseSByZWFwcyBzdWJtaXQgaGFuZGxlcnMgYXR0YWNoZWQgYWJvdmVcblx0XHRcdGpRdWVyeS5ldmVudC5yZW1vdmUoIHRoaXMsIFwiLl9zdWJtaXRcIiApO1xuXHRcdH1cblx0fTtcbn1cblxuLy8gSUUgY2hhbmdlIGRlbGVnYXRpb24gYW5kIGNoZWNrYm94L3JhZGlvIGZpeFxuaWYgKCAhc3VwcG9ydC5jaGFuZ2UgKSB7XG5cblx0alF1ZXJ5LmV2ZW50LnNwZWNpYWwuY2hhbmdlID0ge1xuXG5cdFx0c2V0dXA6IGZ1bmN0aW9uKCkge1xuXG5cdFx0XHRpZiAoIHJmb3JtRWxlbXMudGVzdCggdGhpcy5ub2RlTmFtZSApICkge1xuXG5cdFx0XHRcdC8vIElFIGRvZXNuJ3QgZmlyZSBjaGFuZ2Ugb24gYSBjaGVjay9yYWRpbyB1bnRpbCBibHVyOyB0cmlnZ2VyIGl0IG9uIGNsaWNrXG5cdFx0XHRcdC8vIGFmdGVyIGEgcHJvcGVydHljaGFuZ2UuIEVhdCB0aGUgYmx1ci1jaGFuZ2UgaW4gc3BlY2lhbC5jaGFuZ2UuaGFuZGxlLlxuXHRcdFx0XHQvLyBUaGlzIHN0aWxsIGZpcmVzIG9uY2hhbmdlIGEgc2Vjb25kIHRpbWUgZm9yIGNoZWNrL3JhZGlvIGFmdGVyIGJsdXIuXG5cdFx0XHRcdGlmICggdGhpcy50eXBlID09PSBcImNoZWNrYm94XCIgfHwgdGhpcy50eXBlID09PSBcInJhZGlvXCIgKSB7XG5cdFx0XHRcdFx0alF1ZXJ5LmV2ZW50LmFkZCggdGhpcywgXCJwcm9wZXJ0eWNoYW5nZS5fY2hhbmdlXCIsIGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHRcdFx0XHRcdGlmICggZXZlbnQub3JpZ2luYWxFdmVudC5wcm9wZXJ0eU5hbWUgPT09IFwiY2hlY2tlZFwiICkge1xuXHRcdFx0XHRcdFx0XHR0aGlzLl9qdXN0Q2hhbmdlZCA9IHRydWU7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSApO1xuXHRcdFx0XHRcdGpRdWVyeS5ldmVudC5hZGQoIHRoaXMsIFwiY2xpY2suX2NoYW5nZVwiLCBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0XHRcdFx0XHRpZiAoIHRoaXMuX2p1c3RDaGFuZ2VkICYmICFldmVudC5pc1RyaWdnZXIgKSB7XG5cdFx0XHRcdFx0XHRcdHRoaXMuX2p1c3RDaGFuZ2VkID0gZmFsc2U7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdC8vIEFsbG93IHRyaWdnZXJlZCwgc2ltdWxhdGVkIGNoYW5nZSBldmVudHMgKCMxMTUwMClcblx0XHRcdFx0XHRcdGpRdWVyeS5ldmVudC5zaW11bGF0ZSggXCJjaGFuZ2VcIiwgdGhpcywgZXZlbnQgKTtcblx0XHRcdFx0XHR9ICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBEZWxlZ2F0ZWQgZXZlbnQ7IGxhenktYWRkIGEgY2hhbmdlIGhhbmRsZXIgb24gZGVzY2VuZGFudCBpbnB1dHNcblx0XHRcdGpRdWVyeS5ldmVudC5hZGQoIHRoaXMsIFwiYmVmb3JlYWN0aXZhdGUuX2NoYW5nZVwiLCBmdW5jdGlvbiggZSApIHtcblx0XHRcdFx0dmFyIGVsZW0gPSBlLnRhcmdldDtcblxuXHRcdFx0XHRpZiAoIHJmb3JtRWxlbXMudGVzdCggZWxlbS5ub2RlTmFtZSApICYmICFqUXVlcnkuX2RhdGEoIGVsZW0sIFwiY2hhbmdlXCIgKSApIHtcblx0XHRcdFx0XHRqUXVlcnkuZXZlbnQuYWRkKCBlbGVtLCBcImNoYW5nZS5fY2hhbmdlXCIsIGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHRcdFx0XHRcdGlmICggdGhpcy5wYXJlbnROb2RlICYmICFldmVudC5pc1NpbXVsYXRlZCAmJiAhZXZlbnQuaXNUcmlnZ2VyICkge1xuXHRcdFx0XHRcdFx0XHRqUXVlcnkuZXZlbnQuc2ltdWxhdGUoIFwiY2hhbmdlXCIsIHRoaXMucGFyZW50Tm9kZSwgZXZlbnQgKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9ICk7XG5cdFx0XHRcdFx0alF1ZXJ5Ll9kYXRhKCBlbGVtLCBcImNoYW5nZVwiLCB0cnVlICk7XG5cdFx0XHRcdH1cblx0XHRcdH0gKTtcblx0XHR9LFxuXG5cdFx0aGFuZGxlOiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0XHR2YXIgZWxlbSA9IGV2ZW50LnRhcmdldDtcblxuXHRcdFx0Ly8gU3dhbGxvdyBuYXRpdmUgY2hhbmdlIGV2ZW50cyBmcm9tIGNoZWNrYm94L3JhZGlvLCB3ZSBhbHJlYWR5IHRyaWdnZXJlZCB0aGVtIGFib3ZlXG5cdFx0XHRpZiAoIHRoaXMgIT09IGVsZW0gfHwgZXZlbnQuaXNTaW11bGF0ZWQgfHwgZXZlbnQuaXNUcmlnZ2VyIHx8XG5cdFx0XHRcdCggZWxlbS50eXBlICE9PSBcInJhZGlvXCIgJiYgZWxlbS50eXBlICE9PSBcImNoZWNrYm94XCIgKSApIHtcblxuXHRcdFx0XHRyZXR1cm4gZXZlbnQuaGFuZGxlT2JqLmhhbmRsZXIuYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHR0ZWFyZG93bjogZnVuY3Rpb24oKSB7XG5cdFx0XHRqUXVlcnkuZXZlbnQucmVtb3ZlKCB0aGlzLCBcIi5fY2hhbmdlXCIgKTtcblxuXHRcdFx0cmV0dXJuICFyZm9ybUVsZW1zLnRlc3QoIHRoaXMubm9kZU5hbWUgKTtcblx0XHR9XG5cdH07XG59XG5cbi8vIFN1cHBvcnQ6IEZpcmVmb3hcbi8vIEZpcmVmb3ggZG9lc24ndCBoYXZlIGZvY3VzKGluIHwgb3V0KSBldmVudHNcbi8vIFJlbGF0ZWQgdGlja2V0IC0gaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9Njg3Nzg3XG4vL1xuLy8gU3VwcG9ydDogQ2hyb21lLCBTYWZhcmlcbi8vIGZvY3VzKGluIHwgb3V0KSBldmVudHMgZmlyZSBhZnRlciBmb2N1cyAmIGJsdXIgZXZlbnRzLFxuLy8gd2hpY2ggaXMgc3BlYyB2aW9sYXRpb24gLSBodHRwOi8vd3d3LnczLm9yZy9UUi9ET00tTGV2ZWwtMy1FdmVudHMvI2V2ZW50cy1mb2N1c2V2ZW50LWV2ZW50LW9yZGVyXG4vLyBSZWxhdGVkIHRpY2tldCAtIGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD00NDk4NTdcbmlmICggIXN1cHBvcnQuZm9jdXNpbiApIHtcblx0alF1ZXJ5LmVhY2goIHsgZm9jdXM6IFwiZm9jdXNpblwiLCBibHVyOiBcImZvY3Vzb3V0XCIgfSwgZnVuY3Rpb24oIG9yaWcsIGZpeCApIHtcblxuXHRcdC8vIEF0dGFjaCBhIHNpbmdsZSBjYXB0dXJpbmcgaGFuZGxlciBvbiB0aGUgZG9jdW1lbnQgd2hpbGUgc29tZW9uZSB3YW50cyBmb2N1c2luL2ZvY3Vzb3V0XG5cdFx0dmFyIGhhbmRsZXIgPSBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0XHRqUXVlcnkuZXZlbnQuc2ltdWxhdGUoIGZpeCwgZXZlbnQudGFyZ2V0LCBqUXVlcnkuZXZlbnQuZml4KCBldmVudCApICk7XG5cdFx0fTtcblxuXHRcdGpRdWVyeS5ldmVudC5zcGVjaWFsWyBmaXggXSA9IHtcblx0XHRcdHNldHVwOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIGRvYyA9IHRoaXMub3duZXJEb2N1bWVudCB8fCB0aGlzLFxuXHRcdFx0XHRcdGF0dGFjaGVzID0galF1ZXJ5Ll9kYXRhKCBkb2MsIGZpeCApO1xuXG5cdFx0XHRcdGlmICggIWF0dGFjaGVzICkge1xuXHRcdFx0XHRcdGRvYy5hZGRFdmVudExpc3RlbmVyKCBvcmlnLCBoYW5kbGVyLCB0cnVlICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0alF1ZXJ5Ll9kYXRhKCBkb2MsIGZpeCwgKCBhdHRhY2hlcyB8fCAwICkgKyAxICk7XG5cdFx0XHR9LFxuXHRcdFx0dGVhcmRvd246IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgZG9jID0gdGhpcy5vd25lckRvY3VtZW50IHx8IHRoaXMsXG5cdFx0XHRcdFx0YXR0YWNoZXMgPSBqUXVlcnkuX2RhdGEoIGRvYywgZml4ICkgLSAxO1xuXG5cdFx0XHRcdGlmICggIWF0dGFjaGVzICkge1xuXHRcdFx0XHRcdGRvYy5yZW1vdmVFdmVudExpc3RlbmVyKCBvcmlnLCBoYW5kbGVyLCB0cnVlICk7XG5cdFx0XHRcdFx0alF1ZXJ5Ll9yZW1vdmVEYXRhKCBkb2MsIGZpeCApO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGpRdWVyeS5fZGF0YSggZG9jLCBmaXgsIGF0dGFjaGVzICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9O1xuXHR9ICk7XG59XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblxuXHRvbjogZnVuY3Rpb24oIHR5cGVzLCBzZWxlY3RvciwgZGF0YSwgZm4gKSB7XG5cdFx0cmV0dXJuIG9uKCB0aGlzLCB0eXBlcywgc2VsZWN0b3IsIGRhdGEsIGZuICk7XG5cdH0sXG5cdG9uZTogZnVuY3Rpb24oIHR5cGVzLCBzZWxlY3RvciwgZGF0YSwgZm4gKSB7XG5cdFx0cmV0dXJuIG9uKCB0aGlzLCB0eXBlcywgc2VsZWN0b3IsIGRhdGEsIGZuLCAxICk7XG5cdH0sXG5cdG9mZjogZnVuY3Rpb24oIHR5cGVzLCBzZWxlY3RvciwgZm4gKSB7XG5cdFx0dmFyIGhhbmRsZU9iaiwgdHlwZTtcblx0XHRpZiAoIHR5cGVzICYmIHR5cGVzLnByZXZlbnREZWZhdWx0ICYmIHR5cGVzLmhhbmRsZU9iaiApIHtcblxuXHRcdFx0Ly8gKCBldmVudCApICBkaXNwYXRjaGVkIGpRdWVyeS5FdmVudFxuXHRcdFx0aGFuZGxlT2JqID0gdHlwZXMuaGFuZGxlT2JqO1xuXHRcdFx0alF1ZXJ5KCB0eXBlcy5kZWxlZ2F0ZVRhcmdldCApLm9mZihcblx0XHRcdFx0aGFuZGxlT2JqLm5hbWVzcGFjZSA/XG5cdFx0XHRcdFx0aGFuZGxlT2JqLm9yaWdUeXBlICsgXCIuXCIgKyBoYW5kbGVPYmoubmFtZXNwYWNlIDpcblx0XHRcdFx0XHRoYW5kbGVPYmoub3JpZ1R5cGUsXG5cdFx0XHRcdGhhbmRsZU9iai5zZWxlY3Rvcixcblx0XHRcdFx0aGFuZGxlT2JqLmhhbmRsZXJcblx0XHRcdCk7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cdFx0aWYgKCB0eXBlb2YgdHlwZXMgPT09IFwib2JqZWN0XCIgKSB7XG5cblx0XHRcdC8vICggdHlwZXMtb2JqZWN0IFssIHNlbGVjdG9yXSApXG5cdFx0XHRmb3IgKCB0eXBlIGluIHR5cGVzICkge1xuXHRcdFx0XHR0aGlzLm9mZiggdHlwZSwgc2VsZWN0b3IsIHR5cGVzWyB0eXBlIF0gKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblx0XHRpZiAoIHNlbGVjdG9yID09PSBmYWxzZSB8fCB0eXBlb2Ygc2VsZWN0b3IgPT09IFwiZnVuY3Rpb25cIiApIHtcblxuXHRcdFx0Ly8gKCB0eXBlcyBbLCBmbl0gKVxuXHRcdFx0Zm4gPSBzZWxlY3Rvcjtcblx0XHRcdHNlbGVjdG9yID0gdW5kZWZpbmVkO1xuXHRcdH1cblx0XHRpZiAoIGZuID09PSBmYWxzZSApIHtcblx0XHRcdGZuID0gcmV0dXJuRmFsc2U7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0alF1ZXJ5LmV2ZW50LnJlbW92ZSggdGhpcywgdHlwZXMsIGZuLCBzZWxlY3RvciApO1xuXHRcdH0gKTtcblx0fSxcblxuXHR0cmlnZ2VyOiBmdW5jdGlvbiggdHlwZSwgZGF0YSApIHtcblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdGpRdWVyeS5ldmVudC50cmlnZ2VyKCB0eXBlLCBkYXRhLCB0aGlzICk7XG5cdFx0fSApO1xuXHR9LFxuXHR0cmlnZ2VySGFuZGxlcjogZnVuY3Rpb24oIHR5cGUsIGRhdGEgKSB7XG5cdFx0dmFyIGVsZW0gPSB0aGlzWyAwIF07XG5cdFx0aWYgKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuIGpRdWVyeS5ldmVudC50cmlnZ2VyKCB0eXBlLCBkYXRhLCBlbGVtLCB0cnVlICk7XG5cdFx0fVxuXHR9XG59ICk7XG5cblxudmFyIHJpbmxpbmVqUXVlcnkgPSAvIGpRdWVyeVxcZCs9XCIoPzpudWxsfFxcZCspXCIvZyxcblx0cm5vc2hpbWNhY2hlID0gbmV3IFJlZ0V4cCggXCI8KD86XCIgKyBub2RlTmFtZXMgKyBcIilbXFxcXHMvPl1cIiwgXCJpXCIgKSxcblx0cnhodG1sVGFnID0gLzwoPyFhcmVhfGJyfGNvbHxlbWJlZHxocnxpbWd8aW5wdXR8bGlua3xtZXRhfHBhcmFtKSgoW1xcdzotXSspW14+XSopXFwvPi9naSxcblxuXHQvLyBTdXBwb3J0OiBJRSAxMC0xMSwgRWRnZSAxMDI0MCtcblx0Ly8gSW4gSUUvRWRnZSB1c2luZyByZWdleCBncm91cHMgaGVyZSBjYXVzZXMgc2V2ZXJlIHNsb3dkb3ducy5cblx0Ly8gU2VlIGh0dHBzOi8vY29ubmVjdC5taWNyb3NvZnQuY29tL0lFL2ZlZWRiYWNrL2RldGFpbHMvMTczNjUxMi9cblx0cm5vSW5uZXJodG1sID0gLzxzY3JpcHR8PHN0eWxlfDxsaW5rL2ksXG5cblx0Ly8gY2hlY2tlZD1cImNoZWNrZWRcIiBvciBjaGVja2VkXG5cdHJjaGVja2VkID0gL2NoZWNrZWRcXHMqKD86W149XXw9XFxzKi5jaGVja2VkLikvaSxcblx0cnNjcmlwdFR5cGVNYXNrZWQgPSAvXnRydWVcXC8oLiopLyxcblx0cmNsZWFuU2NyaXB0ID0gL15cXHMqPCEoPzpcXFtDREFUQVxcW3wtLSl8KD86XFxdXFxdfC0tKT5cXHMqJC9nLFxuXHRzYWZlRnJhZ21lbnQgPSBjcmVhdGVTYWZlRnJhZ21lbnQoIGRvY3VtZW50ICksXG5cdGZyYWdtZW50RGl2ID0gc2FmZUZyYWdtZW50LmFwcGVuZENoaWxkKCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImRpdlwiICkgKTtcblxuLy8gU3VwcG9ydDogSUU8OFxuLy8gTWFuaXB1bGF0aW5nIHRhYmxlcyByZXF1aXJlcyBhIHRib2R5XG5mdW5jdGlvbiBtYW5pcHVsYXRpb25UYXJnZXQoIGVsZW0sIGNvbnRlbnQgKSB7XG5cdHJldHVybiBqUXVlcnkubm9kZU5hbWUoIGVsZW0sIFwidGFibGVcIiApICYmXG5cdFx0alF1ZXJ5Lm5vZGVOYW1lKCBjb250ZW50Lm5vZGVUeXBlICE9PSAxMSA/IGNvbnRlbnQgOiBjb250ZW50LmZpcnN0Q2hpbGQsIFwidHJcIiApID9cblxuXHRcdGVsZW0uZ2V0RWxlbWVudHNCeVRhZ05hbWUoIFwidGJvZHlcIiApWyAwIF0gfHxcblx0XHRcdGVsZW0uYXBwZW5kQ2hpbGQoIGVsZW0ub3duZXJEb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcInRib2R5XCIgKSApIDpcblx0XHRlbGVtO1xufVxuXG4vLyBSZXBsYWNlL3Jlc3RvcmUgdGhlIHR5cGUgYXR0cmlidXRlIG9mIHNjcmlwdCBlbGVtZW50cyBmb3Igc2FmZSBET00gbWFuaXB1bGF0aW9uXG5mdW5jdGlvbiBkaXNhYmxlU2NyaXB0KCBlbGVtICkge1xuXHRlbGVtLnR5cGUgPSAoIGpRdWVyeS5maW5kLmF0dHIoIGVsZW0sIFwidHlwZVwiICkgIT09IG51bGwgKSArIFwiL1wiICsgZWxlbS50eXBlO1xuXHRyZXR1cm4gZWxlbTtcbn1cbmZ1bmN0aW9uIHJlc3RvcmVTY3JpcHQoIGVsZW0gKSB7XG5cdHZhciBtYXRjaCA9IHJzY3JpcHRUeXBlTWFza2VkLmV4ZWMoIGVsZW0udHlwZSApO1xuXHRpZiAoIG1hdGNoICkge1xuXHRcdGVsZW0udHlwZSA9IG1hdGNoWyAxIF07XG5cdH0gZWxzZSB7XG5cdFx0ZWxlbS5yZW1vdmVBdHRyaWJ1dGUoIFwidHlwZVwiICk7XG5cdH1cblx0cmV0dXJuIGVsZW07XG59XG5cbmZ1bmN0aW9uIGNsb25lQ29weUV2ZW50KCBzcmMsIGRlc3QgKSB7XG5cdGlmICggZGVzdC5ub2RlVHlwZSAhPT0gMSB8fCAhalF1ZXJ5Lmhhc0RhdGEoIHNyYyApICkge1xuXHRcdHJldHVybjtcblx0fVxuXG5cdHZhciB0eXBlLCBpLCBsLFxuXHRcdG9sZERhdGEgPSBqUXVlcnkuX2RhdGEoIHNyYyApLFxuXHRcdGN1ckRhdGEgPSBqUXVlcnkuX2RhdGEoIGRlc3QsIG9sZERhdGEgKSxcblx0XHRldmVudHMgPSBvbGREYXRhLmV2ZW50cztcblxuXHRpZiAoIGV2ZW50cyApIHtcblx0XHRkZWxldGUgY3VyRGF0YS5oYW5kbGU7XG5cdFx0Y3VyRGF0YS5ldmVudHMgPSB7fTtcblxuXHRcdGZvciAoIHR5cGUgaW4gZXZlbnRzICkge1xuXHRcdFx0Zm9yICggaSA9IDAsIGwgPSBldmVudHNbIHR5cGUgXS5sZW5ndGg7IGkgPCBsOyBpKysgKSB7XG5cdFx0XHRcdGpRdWVyeS5ldmVudC5hZGQoIGRlc3QsIHR5cGUsIGV2ZW50c1sgdHlwZSBdWyBpIF0gKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvLyBtYWtlIHRoZSBjbG9uZWQgcHVibGljIGRhdGEgb2JqZWN0IGEgY29weSBmcm9tIHRoZSBvcmlnaW5hbFxuXHRpZiAoIGN1ckRhdGEuZGF0YSApIHtcblx0XHRjdXJEYXRhLmRhdGEgPSBqUXVlcnkuZXh0ZW5kKCB7fSwgY3VyRGF0YS5kYXRhICk7XG5cdH1cbn1cblxuZnVuY3Rpb24gZml4Q2xvbmVOb2RlSXNzdWVzKCBzcmMsIGRlc3QgKSB7XG5cdHZhciBub2RlTmFtZSwgZSwgZGF0YTtcblxuXHQvLyBXZSBkbyBub3QgbmVlZCB0byBkbyBhbnl0aGluZyBmb3Igbm9uLUVsZW1lbnRzXG5cdGlmICggZGVzdC5ub2RlVHlwZSAhPT0gMSApIHtcblx0XHRyZXR1cm47XG5cdH1cblxuXHRub2RlTmFtZSA9IGRlc3Qubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcblxuXHQvLyBJRTYtOCBjb3BpZXMgZXZlbnRzIGJvdW5kIHZpYSBhdHRhY2hFdmVudCB3aGVuIHVzaW5nIGNsb25lTm9kZS5cblx0aWYgKCAhc3VwcG9ydC5ub0Nsb25lRXZlbnQgJiYgZGVzdFsgalF1ZXJ5LmV4cGFuZG8gXSApIHtcblx0XHRkYXRhID0galF1ZXJ5Ll9kYXRhKCBkZXN0ICk7XG5cblx0XHRmb3IgKCBlIGluIGRhdGEuZXZlbnRzICkge1xuXHRcdFx0alF1ZXJ5LnJlbW92ZUV2ZW50KCBkZXN0LCBlLCBkYXRhLmhhbmRsZSApO1xuXHRcdH1cblxuXHRcdC8vIEV2ZW50IGRhdGEgZ2V0cyByZWZlcmVuY2VkIGluc3RlYWQgb2YgY29waWVkIGlmIHRoZSBleHBhbmRvIGdldHMgY29waWVkIHRvb1xuXHRcdGRlc3QucmVtb3ZlQXR0cmlidXRlKCBqUXVlcnkuZXhwYW5kbyApO1xuXHR9XG5cblx0Ly8gSUUgYmxhbmtzIGNvbnRlbnRzIHdoZW4gY2xvbmluZyBzY3JpcHRzLCBhbmQgdHJpZXMgdG8gZXZhbHVhdGUgbmV3bHktc2V0IHRleHRcblx0aWYgKCBub2RlTmFtZSA9PT0gXCJzY3JpcHRcIiAmJiBkZXN0LnRleHQgIT09IHNyYy50ZXh0ICkge1xuXHRcdGRpc2FibGVTY3JpcHQoIGRlc3QgKS50ZXh0ID0gc3JjLnRleHQ7XG5cdFx0cmVzdG9yZVNjcmlwdCggZGVzdCApO1xuXG5cdC8vIElFNi0xMCBpbXByb3Blcmx5IGNsb25lcyBjaGlsZHJlbiBvZiBvYmplY3QgZWxlbWVudHMgdXNpbmcgY2xhc3NpZC5cblx0Ly8gSUUxMCB0aHJvd3MgTm9Nb2RpZmljYXRpb25BbGxvd2VkRXJyb3IgaWYgcGFyZW50IGlzIG51bGwsICMxMjEzMi5cblx0fSBlbHNlIGlmICggbm9kZU5hbWUgPT09IFwib2JqZWN0XCIgKSB7XG5cdFx0aWYgKCBkZXN0LnBhcmVudE5vZGUgKSB7XG5cdFx0XHRkZXN0Lm91dGVySFRNTCA9IHNyYy5vdXRlckhUTUw7XG5cdFx0fVxuXG5cdFx0Ly8gVGhpcyBwYXRoIGFwcGVhcnMgdW5hdm9pZGFibGUgZm9yIElFOS4gV2hlbiBjbG9uaW5nIGFuIG9iamVjdFxuXHRcdC8vIGVsZW1lbnQgaW4gSUU5LCB0aGUgb3V0ZXJIVE1MIHN0cmF0ZWd5IGFib3ZlIGlzIG5vdCBzdWZmaWNpZW50LlxuXHRcdC8vIElmIHRoZSBzcmMgaGFzIGlubmVySFRNTCBhbmQgdGhlIGRlc3RpbmF0aW9uIGRvZXMgbm90LFxuXHRcdC8vIGNvcHkgdGhlIHNyYy5pbm5lckhUTUwgaW50byB0aGUgZGVzdC5pbm5lckhUTUwuICMxMDMyNFxuXHRcdGlmICggc3VwcG9ydC5odG1sNUNsb25lICYmICggc3JjLmlubmVySFRNTCAmJiAhalF1ZXJ5LnRyaW0oIGRlc3QuaW5uZXJIVE1MICkgKSApIHtcblx0XHRcdGRlc3QuaW5uZXJIVE1MID0gc3JjLmlubmVySFRNTDtcblx0XHR9XG5cblx0fSBlbHNlIGlmICggbm9kZU5hbWUgPT09IFwiaW5wdXRcIiAmJiByY2hlY2thYmxlVHlwZS50ZXN0KCBzcmMudHlwZSApICkge1xuXG5cdFx0Ly8gSUU2LTggZmFpbHMgdG8gcGVyc2lzdCB0aGUgY2hlY2tlZCBzdGF0ZSBvZiBhIGNsb25lZCBjaGVja2JveFxuXHRcdC8vIG9yIHJhZGlvIGJ1dHRvbi4gV29yc2UsIElFNi03IGZhaWwgdG8gZ2l2ZSB0aGUgY2xvbmVkIGVsZW1lbnRcblx0XHQvLyBhIGNoZWNrZWQgYXBwZWFyYW5jZSBpZiB0aGUgZGVmYXVsdENoZWNrZWQgdmFsdWUgaXNuJ3QgYWxzbyBzZXRcblxuXHRcdGRlc3QuZGVmYXVsdENoZWNrZWQgPSBkZXN0LmNoZWNrZWQgPSBzcmMuY2hlY2tlZDtcblxuXHRcdC8vIElFNi03IGdldCBjb25mdXNlZCBhbmQgZW5kIHVwIHNldHRpbmcgdGhlIHZhbHVlIG9mIGEgY2xvbmVkXG5cdFx0Ly8gY2hlY2tib3gvcmFkaW8gYnV0dG9uIHRvIGFuIGVtcHR5IHN0cmluZyBpbnN0ZWFkIG9mIFwib25cIlxuXHRcdGlmICggZGVzdC52YWx1ZSAhPT0gc3JjLnZhbHVlICkge1xuXHRcdFx0ZGVzdC52YWx1ZSA9IHNyYy52YWx1ZTtcblx0XHR9XG5cblx0Ly8gSUU2LTggZmFpbHMgdG8gcmV0dXJuIHRoZSBzZWxlY3RlZCBvcHRpb24gdG8gdGhlIGRlZmF1bHQgc2VsZWN0ZWRcblx0Ly8gc3RhdGUgd2hlbiBjbG9uaW5nIG9wdGlvbnNcblx0fSBlbHNlIGlmICggbm9kZU5hbWUgPT09IFwib3B0aW9uXCIgKSB7XG5cdFx0ZGVzdC5kZWZhdWx0U2VsZWN0ZWQgPSBkZXN0LnNlbGVjdGVkID0gc3JjLmRlZmF1bHRTZWxlY3RlZDtcblxuXHQvLyBJRTYtOCBmYWlscyB0byBzZXQgdGhlIGRlZmF1bHRWYWx1ZSB0byB0aGUgY29ycmVjdCB2YWx1ZSB3aGVuXG5cdC8vIGNsb25pbmcgb3RoZXIgdHlwZXMgb2YgaW5wdXQgZmllbGRzXG5cdH0gZWxzZSBpZiAoIG5vZGVOYW1lID09PSBcImlucHV0XCIgfHwgbm9kZU5hbWUgPT09IFwidGV4dGFyZWFcIiApIHtcblx0XHRkZXN0LmRlZmF1bHRWYWx1ZSA9IHNyYy5kZWZhdWx0VmFsdWU7XG5cdH1cbn1cblxuZnVuY3Rpb24gZG9tTWFuaXAoIGNvbGxlY3Rpb24sIGFyZ3MsIGNhbGxiYWNrLCBpZ25vcmVkICkge1xuXG5cdC8vIEZsYXR0ZW4gYW55IG5lc3RlZCBhcnJheXNcblx0YXJncyA9IGNvbmNhdC5hcHBseSggW10sIGFyZ3MgKTtcblxuXHR2YXIgZmlyc3QsIG5vZGUsIGhhc1NjcmlwdHMsXG5cdFx0c2NyaXB0cywgZG9jLCBmcmFnbWVudCxcblx0XHRpID0gMCxcblx0XHRsID0gY29sbGVjdGlvbi5sZW5ndGgsXG5cdFx0aU5vQ2xvbmUgPSBsIC0gMSxcblx0XHR2YWx1ZSA9IGFyZ3NbIDAgXSxcblx0XHRpc0Z1bmN0aW9uID0galF1ZXJ5LmlzRnVuY3Rpb24oIHZhbHVlICk7XG5cblx0Ly8gV2UgY2FuJ3QgY2xvbmVOb2RlIGZyYWdtZW50cyB0aGF0IGNvbnRhaW4gY2hlY2tlZCwgaW4gV2ViS2l0XG5cdGlmICggaXNGdW5jdGlvbiB8fFxuXHRcdFx0KCBsID4gMSAmJiB0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgJiZcblx0XHRcdFx0IXN1cHBvcnQuY2hlY2tDbG9uZSAmJiByY2hlY2tlZC50ZXN0KCB2YWx1ZSApICkgKSB7XG5cdFx0cmV0dXJuIGNvbGxlY3Rpb24uZWFjaCggZnVuY3Rpb24oIGluZGV4ICkge1xuXHRcdFx0dmFyIHNlbGYgPSBjb2xsZWN0aW9uLmVxKCBpbmRleCApO1xuXHRcdFx0aWYgKCBpc0Z1bmN0aW9uICkge1xuXHRcdFx0XHRhcmdzWyAwIF0gPSB2YWx1ZS5jYWxsKCB0aGlzLCBpbmRleCwgc2VsZi5odG1sKCkgKTtcblx0XHRcdH1cblx0XHRcdGRvbU1hbmlwKCBzZWxmLCBhcmdzLCBjYWxsYmFjaywgaWdub3JlZCApO1xuXHRcdH0gKTtcblx0fVxuXG5cdGlmICggbCApIHtcblx0XHRmcmFnbWVudCA9IGJ1aWxkRnJhZ21lbnQoIGFyZ3MsIGNvbGxlY3Rpb25bIDAgXS5vd25lckRvY3VtZW50LCBmYWxzZSwgY29sbGVjdGlvbiwgaWdub3JlZCApO1xuXHRcdGZpcnN0ID0gZnJhZ21lbnQuZmlyc3RDaGlsZDtcblxuXHRcdGlmICggZnJhZ21lbnQuY2hpbGROb2Rlcy5sZW5ndGggPT09IDEgKSB7XG5cdFx0XHRmcmFnbWVudCA9IGZpcnN0O1xuXHRcdH1cblxuXHRcdC8vIFJlcXVpcmUgZWl0aGVyIG5ldyBjb250ZW50IG9yIGFuIGludGVyZXN0IGluIGlnbm9yZWQgZWxlbWVudHMgdG8gaW52b2tlIHRoZSBjYWxsYmFja1xuXHRcdGlmICggZmlyc3QgfHwgaWdub3JlZCApIHtcblx0XHRcdHNjcmlwdHMgPSBqUXVlcnkubWFwKCBnZXRBbGwoIGZyYWdtZW50LCBcInNjcmlwdFwiICksIGRpc2FibGVTY3JpcHQgKTtcblx0XHRcdGhhc1NjcmlwdHMgPSBzY3JpcHRzLmxlbmd0aDtcblxuXHRcdFx0Ly8gVXNlIHRoZSBvcmlnaW5hbCBmcmFnbWVudCBmb3IgdGhlIGxhc3QgaXRlbVxuXHRcdFx0Ly8gaW5zdGVhZCBvZiB0aGUgZmlyc3QgYmVjYXVzZSBpdCBjYW4gZW5kIHVwXG5cdFx0XHQvLyBiZWluZyBlbXB0aWVkIGluY29ycmVjdGx5IGluIGNlcnRhaW4gc2l0dWF0aW9ucyAoIzgwNzApLlxuXHRcdFx0Zm9yICggOyBpIDwgbDsgaSsrICkge1xuXHRcdFx0XHRub2RlID0gZnJhZ21lbnQ7XG5cblx0XHRcdFx0aWYgKCBpICE9PSBpTm9DbG9uZSApIHtcblx0XHRcdFx0XHRub2RlID0galF1ZXJ5LmNsb25lKCBub2RlLCB0cnVlLCB0cnVlICk7XG5cblx0XHRcdFx0XHQvLyBLZWVwIHJlZmVyZW5jZXMgdG8gY2xvbmVkIHNjcmlwdHMgZm9yIGxhdGVyIHJlc3RvcmF0aW9uXG5cdFx0XHRcdFx0aWYgKCBoYXNTY3JpcHRzICkge1xuXG5cdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBBbmRyb2lkPDQuMSwgUGhhbnRvbUpTPDJcblx0XHRcdFx0XHRcdC8vIHB1c2guYXBwbHkoXywgYXJyYXlsaWtlKSB0aHJvd3Mgb24gYW5jaWVudCBXZWJLaXRcblx0XHRcdFx0XHRcdGpRdWVyeS5tZXJnZSggc2NyaXB0cywgZ2V0QWxsKCBub2RlLCBcInNjcmlwdFwiICkgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRjYWxsYmFjay5jYWxsKCBjb2xsZWN0aW9uWyBpIF0sIG5vZGUsIGkgKTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCBoYXNTY3JpcHRzICkge1xuXHRcdFx0XHRkb2MgPSBzY3JpcHRzWyBzY3JpcHRzLmxlbmd0aCAtIDEgXS5vd25lckRvY3VtZW50O1xuXG5cdFx0XHRcdC8vIFJlZW5hYmxlIHNjcmlwdHNcblx0XHRcdFx0alF1ZXJ5Lm1hcCggc2NyaXB0cywgcmVzdG9yZVNjcmlwdCApO1xuXG5cdFx0XHRcdC8vIEV2YWx1YXRlIGV4ZWN1dGFibGUgc2NyaXB0cyBvbiBmaXJzdCBkb2N1bWVudCBpbnNlcnRpb25cblx0XHRcdFx0Zm9yICggaSA9IDA7IGkgPCBoYXNTY3JpcHRzOyBpKysgKSB7XG5cdFx0XHRcdFx0bm9kZSA9IHNjcmlwdHNbIGkgXTtcblx0XHRcdFx0XHRpZiAoIHJzY3JpcHRUeXBlLnRlc3QoIG5vZGUudHlwZSB8fCBcIlwiICkgJiZcblx0XHRcdFx0XHRcdCFqUXVlcnkuX2RhdGEoIG5vZGUsIFwiZ2xvYmFsRXZhbFwiICkgJiZcblx0XHRcdFx0XHRcdGpRdWVyeS5jb250YWlucyggZG9jLCBub2RlICkgKSB7XG5cblx0XHRcdFx0XHRcdGlmICggbm9kZS5zcmMgKSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gT3B0aW9uYWwgQUpBWCBkZXBlbmRlbmN5LCBidXQgd29uJ3QgcnVuIHNjcmlwdHMgaWYgbm90IHByZXNlbnRcblx0XHRcdFx0XHRcdFx0aWYgKCBqUXVlcnkuX2V2YWxVcmwgKSB7XG5cdFx0XHRcdFx0XHRcdFx0alF1ZXJ5Ll9ldmFsVXJsKCBub2RlLnNyYyApO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRqUXVlcnkuZ2xvYmFsRXZhbChcblx0XHRcdFx0XHRcdFx0XHQoIG5vZGUudGV4dCB8fCBub2RlLnRleHRDb250ZW50IHx8IG5vZGUuaW5uZXJIVE1MIHx8IFwiXCIgKVxuXHRcdFx0XHRcdFx0XHRcdFx0LnJlcGxhY2UoIHJjbGVhblNjcmlwdCwgXCJcIiApXG5cdFx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIEZpeCAjMTE4MDk6IEF2b2lkIGxlYWtpbmcgbWVtb3J5XG5cdFx0XHRmcmFnbWVudCA9IGZpcnN0ID0gbnVsbDtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gY29sbGVjdGlvbjtcbn1cblxuZnVuY3Rpb24gcmVtb3ZlKCBlbGVtLCBzZWxlY3Rvciwga2VlcERhdGEgKSB7XG5cdHZhciBub2RlLFxuXHRcdGVsZW1zID0gc2VsZWN0b3IgPyBqUXVlcnkuZmlsdGVyKCBzZWxlY3RvciwgZWxlbSApIDogZWxlbSxcblx0XHRpID0gMDtcblxuXHRmb3IgKCA7ICggbm9kZSA9IGVsZW1zWyBpIF0gKSAhPSBudWxsOyBpKysgKSB7XG5cblx0XHRpZiAoICFrZWVwRGF0YSAmJiBub2RlLm5vZGVUeXBlID09PSAxICkge1xuXHRcdFx0alF1ZXJ5LmNsZWFuRGF0YSggZ2V0QWxsKCBub2RlICkgKTtcblx0XHR9XG5cblx0XHRpZiAoIG5vZGUucGFyZW50Tm9kZSApIHtcblx0XHRcdGlmICgga2VlcERhdGEgJiYgalF1ZXJ5LmNvbnRhaW5zKCBub2RlLm93bmVyRG9jdW1lbnQsIG5vZGUgKSApIHtcblx0XHRcdFx0c2V0R2xvYmFsRXZhbCggZ2V0QWxsKCBub2RlLCBcInNjcmlwdFwiICkgKTtcblx0XHRcdH1cblx0XHRcdG5vZGUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCggbm9kZSApO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiBlbGVtO1xufVxuXG5qUXVlcnkuZXh0ZW5kKCB7XG5cdGh0bWxQcmVmaWx0ZXI6IGZ1bmN0aW9uKCBodG1sICkge1xuXHRcdHJldHVybiBodG1sLnJlcGxhY2UoIHJ4aHRtbFRhZywgXCI8JDE+PC8kMj5cIiApO1xuXHR9LFxuXG5cdGNsb25lOiBmdW5jdGlvbiggZWxlbSwgZGF0YUFuZEV2ZW50cywgZGVlcERhdGFBbmRFdmVudHMgKSB7XG5cdFx0dmFyIGRlc3RFbGVtZW50cywgbm9kZSwgY2xvbmUsIGksIHNyY0VsZW1lbnRzLFxuXHRcdFx0aW5QYWdlID0galF1ZXJ5LmNvbnRhaW5zKCBlbGVtLm93bmVyRG9jdW1lbnQsIGVsZW0gKTtcblxuXHRcdGlmICggc3VwcG9ydC5odG1sNUNsb25lIHx8IGpRdWVyeS5pc1hNTERvYyggZWxlbSApIHx8XG5cdFx0XHQhcm5vc2hpbWNhY2hlLnRlc3QoIFwiPFwiICsgZWxlbS5ub2RlTmFtZSArIFwiPlwiICkgKSB7XG5cblx0XHRcdGNsb25lID0gZWxlbS5jbG9uZU5vZGUoIHRydWUgKTtcblxuXHRcdC8vIElFPD04IGRvZXMgbm90IHByb3Blcmx5IGNsb25lIGRldGFjaGVkLCB1bmtub3duIGVsZW1lbnQgbm9kZXNcblx0XHR9IGVsc2Uge1xuXHRcdFx0ZnJhZ21lbnREaXYuaW5uZXJIVE1MID0gZWxlbS5vdXRlckhUTUw7XG5cdFx0XHRmcmFnbWVudERpdi5yZW1vdmVDaGlsZCggY2xvbmUgPSBmcmFnbWVudERpdi5maXJzdENoaWxkICk7XG5cdFx0fVxuXG5cdFx0aWYgKCAoICFzdXBwb3J0Lm5vQ2xvbmVFdmVudCB8fCAhc3VwcG9ydC5ub0Nsb25lQ2hlY2tlZCApICYmXG5cdFx0XHRcdCggZWxlbS5ub2RlVHlwZSA9PT0gMSB8fCBlbGVtLm5vZGVUeXBlID09PSAxMSApICYmICFqUXVlcnkuaXNYTUxEb2MoIGVsZW0gKSApIHtcblxuXHRcdFx0Ly8gV2UgZXNjaGV3IFNpenpsZSBoZXJlIGZvciBwZXJmb3JtYW5jZSByZWFzb25zOiBodHRwOi8vanNwZXJmLmNvbS9nZXRhbGwtdnMtc2l6emxlLzJcblx0XHRcdGRlc3RFbGVtZW50cyA9IGdldEFsbCggY2xvbmUgKTtcblx0XHRcdHNyY0VsZW1lbnRzID0gZ2V0QWxsKCBlbGVtICk7XG5cblx0XHRcdC8vIEZpeCBhbGwgSUUgY2xvbmluZyBpc3N1ZXNcblx0XHRcdGZvciAoIGkgPSAwOyAoIG5vZGUgPSBzcmNFbGVtZW50c1sgaSBdICkgIT0gbnVsbDsgKytpICkge1xuXG5cdFx0XHRcdC8vIEVuc3VyZSB0aGF0IHRoZSBkZXN0aW5hdGlvbiBub2RlIGlzIG5vdCBudWxsOyBGaXhlcyAjOTU4N1xuXHRcdFx0XHRpZiAoIGRlc3RFbGVtZW50c1sgaSBdICkge1xuXHRcdFx0XHRcdGZpeENsb25lTm9kZUlzc3Vlcyggbm9kZSwgZGVzdEVsZW1lbnRzWyBpIF0gKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIENvcHkgdGhlIGV2ZW50cyBmcm9tIHRoZSBvcmlnaW5hbCB0byB0aGUgY2xvbmVcblx0XHRpZiAoIGRhdGFBbmRFdmVudHMgKSB7XG5cdFx0XHRpZiAoIGRlZXBEYXRhQW5kRXZlbnRzICkge1xuXHRcdFx0XHRzcmNFbGVtZW50cyA9IHNyY0VsZW1lbnRzIHx8IGdldEFsbCggZWxlbSApO1xuXHRcdFx0XHRkZXN0RWxlbWVudHMgPSBkZXN0RWxlbWVudHMgfHwgZ2V0QWxsKCBjbG9uZSApO1xuXG5cdFx0XHRcdGZvciAoIGkgPSAwOyAoIG5vZGUgPSBzcmNFbGVtZW50c1sgaSBdICkgIT0gbnVsbDsgaSsrICkge1xuXHRcdFx0XHRcdGNsb25lQ29weUV2ZW50KCBub2RlLCBkZXN0RWxlbWVudHNbIGkgXSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRjbG9uZUNvcHlFdmVudCggZWxlbSwgY2xvbmUgKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBQcmVzZXJ2ZSBzY3JpcHQgZXZhbHVhdGlvbiBoaXN0b3J5XG5cdFx0ZGVzdEVsZW1lbnRzID0gZ2V0QWxsKCBjbG9uZSwgXCJzY3JpcHRcIiApO1xuXHRcdGlmICggZGVzdEVsZW1lbnRzLmxlbmd0aCA+IDAgKSB7XG5cdFx0XHRzZXRHbG9iYWxFdmFsKCBkZXN0RWxlbWVudHMsICFpblBhZ2UgJiYgZ2V0QWxsKCBlbGVtLCBcInNjcmlwdFwiICkgKTtcblx0XHR9XG5cblx0XHRkZXN0RWxlbWVudHMgPSBzcmNFbGVtZW50cyA9IG5vZGUgPSBudWxsO1xuXG5cdFx0Ly8gUmV0dXJuIHRoZSBjbG9uZWQgc2V0XG5cdFx0cmV0dXJuIGNsb25lO1xuXHR9LFxuXG5cdGNsZWFuRGF0YTogZnVuY3Rpb24oIGVsZW1zLCAvKiBpbnRlcm5hbCAqLyBmb3JjZUFjY2VwdERhdGEgKSB7XG5cdFx0dmFyIGVsZW0sIHR5cGUsIGlkLCBkYXRhLFxuXHRcdFx0aSA9IDAsXG5cdFx0XHRpbnRlcm5hbEtleSA9IGpRdWVyeS5leHBhbmRvLFxuXHRcdFx0Y2FjaGUgPSBqUXVlcnkuY2FjaGUsXG5cdFx0XHRhdHRyaWJ1dGVzID0gc3VwcG9ydC5hdHRyaWJ1dGVzLFxuXHRcdFx0c3BlY2lhbCA9IGpRdWVyeS5ldmVudC5zcGVjaWFsO1xuXG5cdFx0Zm9yICggOyAoIGVsZW0gPSBlbGVtc1sgaSBdICkgIT0gbnVsbDsgaSsrICkge1xuXHRcdFx0aWYgKCBmb3JjZUFjY2VwdERhdGEgfHwgYWNjZXB0RGF0YSggZWxlbSApICkge1xuXG5cdFx0XHRcdGlkID0gZWxlbVsgaW50ZXJuYWxLZXkgXTtcblx0XHRcdFx0ZGF0YSA9IGlkICYmIGNhY2hlWyBpZCBdO1xuXG5cdFx0XHRcdGlmICggZGF0YSApIHtcblx0XHRcdFx0XHRpZiAoIGRhdGEuZXZlbnRzICkge1xuXHRcdFx0XHRcdFx0Zm9yICggdHlwZSBpbiBkYXRhLmV2ZW50cyApIHtcblx0XHRcdFx0XHRcdFx0aWYgKCBzcGVjaWFsWyB0eXBlIF0gKSB7XG5cdFx0XHRcdFx0XHRcdFx0alF1ZXJ5LmV2ZW50LnJlbW92ZSggZWxlbSwgdHlwZSApO1xuXG5cdFx0XHRcdFx0XHRcdC8vIFRoaXMgaXMgYSBzaG9ydGN1dCB0byBhdm9pZCBqUXVlcnkuZXZlbnQucmVtb3ZlJ3Mgb3ZlcmhlYWRcblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRqUXVlcnkucmVtb3ZlRXZlbnQoIGVsZW0sIHR5cGUsIGRhdGEuaGFuZGxlICk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBSZW1vdmUgY2FjaGUgb25seSBpZiBpdCB3YXMgbm90IGFscmVhZHkgcmVtb3ZlZCBieSBqUXVlcnkuZXZlbnQucmVtb3ZlXG5cdFx0XHRcdFx0aWYgKCBjYWNoZVsgaWQgXSApIHtcblxuXHRcdFx0XHRcdFx0ZGVsZXRlIGNhY2hlWyBpZCBdO1xuXG5cdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRTw5XG5cdFx0XHRcdFx0XHQvLyBJRSBkb2VzIG5vdCBhbGxvdyB1cyB0byBkZWxldGUgZXhwYW5kbyBwcm9wZXJ0aWVzIGZyb20gbm9kZXNcblx0XHRcdFx0XHRcdC8vIElFIGNyZWF0ZXMgZXhwYW5kbyBhdHRyaWJ1dGVzIGFsb25nIHdpdGggdGhlIHByb3BlcnR5XG5cdFx0XHRcdFx0XHQvLyBJRSBkb2VzIG5vdCBoYXZlIGEgcmVtb3ZlQXR0cmlidXRlIGZ1bmN0aW9uIG9uIERvY3VtZW50IG5vZGVzXG5cdFx0XHRcdFx0XHRpZiAoICFhdHRyaWJ1dGVzICYmIHR5cGVvZiBlbGVtLnJlbW92ZUF0dHJpYnV0ZSAhPT0gXCJ1bmRlZmluZWRcIiApIHtcblx0XHRcdFx0XHRcdFx0ZWxlbS5yZW1vdmVBdHRyaWJ1dGUoIGludGVybmFsS2V5ICk7XG5cblx0XHRcdFx0XHRcdC8vIFdlYmtpdCAmIEJsaW5rIHBlcmZvcm1hbmNlIHN1ZmZlcnMgd2hlbiBkZWxldGluZyBwcm9wZXJ0aWVzXG5cdFx0XHRcdFx0XHQvLyBmcm9tIERPTSBub2Rlcywgc28gc2V0IHRvIHVuZGVmaW5lZCBpbnN0ZWFkXG5cdFx0XHRcdFx0XHQvLyBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9Mzc4NjA3XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRlbGVtWyBpbnRlcm5hbEtleSBdID0gdW5kZWZpbmVkO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRkZWxldGVkSWRzLnB1c2goIGlkICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG59ICk7XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblxuXHQvLyBLZWVwIGRvbU1hbmlwIGV4cG9zZWQgdW50aWwgMy4wIChnaC0yMjI1KVxuXHRkb21NYW5pcDogZG9tTWFuaXAsXG5cblx0ZGV0YWNoOiBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0cmV0dXJuIHJlbW92ZSggdGhpcywgc2VsZWN0b3IsIHRydWUgKTtcblx0fSxcblxuXHRyZW1vdmU6IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHRyZXR1cm4gcmVtb3ZlKCB0aGlzLCBzZWxlY3RvciApO1xuXHR9LFxuXG5cdHRleHQ6IGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHRyZXR1cm4gYWNjZXNzKCB0aGlzLCBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0XHRyZXR1cm4gdmFsdWUgPT09IHVuZGVmaW5lZCA/XG5cdFx0XHRcdGpRdWVyeS50ZXh0KCB0aGlzICkgOlxuXHRcdFx0XHR0aGlzLmVtcHR5KCkuYXBwZW5kKFxuXHRcdFx0XHRcdCggdGhpc1sgMCBdICYmIHRoaXNbIDAgXS5vd25lckRvY3VtZW50IHx8IGRvY3VtZW50ICkuY3JlYXRlVGV4dE5vZGUoIHZhbHVlIClcblx0XHRcdFx0KTtcblx0XHR9LCBudWxsLCB2YWx1ZSwgYXJndW1lbnRzLmxlbmd0aCApO1xuXHR9LFxuXG5cdGFwcGVuZDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIGRvbU1hbmlwKCB0aGlzLCBhcmd1bWVudHMsIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0aWYgKCB0aGlzLm5vZGVUeXBlID09PSAxIHx8IHRoaXMubm9kZVR5cGUgPT09IDExIHx8IHRoaXMubm9kZVR5cGUgPT09IDkgKSB7XG5cdFx0XHRcdHZhciB0YXJnZXQgPSBtYW5pcHVsYXRpb25UYXJnZXQoIHRoaXMsIGVsZW0gKTtcblx0XHRcdFx0dGFyZ2V0LmFwcGVuZENoaWxkKCBlbGVtICk7XG5cdFx0XHR9XG5cdFx0fSApO1xuXHR9LFxuXG5cdHByZXBlbmQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBkb21NYW5pcCggdGhpcywgYXJndW1lbnRzLCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdGlmICggdGhpcy5ub2RlVHlwZSA9PT0gMSB8fCB0aGlzLm5vZGVUeXBlID09PSAxMSB8fCB0aGlzLm5vZGVUeXBlID09PSA5ICkge1xuXHRcdFx0XHR2YXIgdGFyZ2V0ID0gbWFuaXB1bGF0aW9uVGFyZ2V0KCB0aGlzLCBlbGVtICk7XG5cdFx0XHRcdHRhcmdldC5pbnNlcnRCZWZvcmUoIGVsZW0sIHRhcmdldC5maXJzdENoaWxkICk7XG5cdFx0XHR9XG5cdFx0fSApO1xuXHR9LFxuXG5cdGJlZm9yZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIGRvbU1hbmlwKCB0aGlzLCBhcmd1bWVudHMsIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0aWYgKCB0aGlzLnBhcmVudE5vZGUgKSB7XG5cdFx0XHRcdHRoaXMucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoIGVsZW0sIHRoaXMgKTtcblx0XHRcdH1cblx0XHR9ICk7XG5cdH0sXG5cblx0YWZ0ZXI6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBkb21NYW5pcCggdGhpcywgYXJndW1lbnRzLCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdGlmICggdGhpcy5wYXJlbnROb2RlICkge1xuXHRcdFx0XHR0aGlzLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKCBlbGVtLCB0aGlzLm5leHRTaWJsaW5nICk7XG5cdFx0XHR9XG5cdFx0fSApO1xuXHR9LFxuXG5cdGVtcHR5OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgZWxlbSxcblx0XHRcdGkgPSAwO1xuXG5cdFx0Zm9yICggOyAoIGVsZW0gPSB0aGlzWyBpIF0gKSAhPSBudWxsOyBpKysgKSB7XG5cblx0XHRcdC8vIFJlbW92ZSBlbGVtZW50IG5vZGVzIGFuZCBwcmV2ZW50IG1lbW9yeSBsZWFrc1xuXHRcdFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSAxICkge1xuXHRcdFx0XHRqUXVlcnkuY2xlYW5EYXRhKCBnZXRBbGwoIGVsZW0sIGZhbHNlICkgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gUmVtb3ZlIGFueSByZW1haW5pbmcgbm9kZXNcblx0XHRcdHdoaWxlICggZWxlbS5maXJzdENoaWxkICkge1xuXHRcdFx0XHRlbGVtLnJlbW92ZUNoaWxkKCBlbGVtLmZpcnN0Q2hpbGQgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gSWYgdGhpcyBpcyBhIHNlbGVjdCwgZW5zdXJlIHRoYXQgaXQgZGlzcGxheXMgZW1wdHkgKCMxMjMzNilcblx0XHRcdC8vIFN1cHBvcnQ6IElFPDlcblx0XHRcdGlmICggZWxlbS5vcHRpb25zICYmIGpRdWVyeS5ub2RlTmFtZSggZWxlbSwgXCJzZWxlY3RcIiApICkge1xuXHRcdFx0XHRlbGVtLm9wdGlvbnMubGVuZ3RoID0gMDtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRjbG9uZTogZnVuY3Rpb24oIGRhdGFBbmRFdmVudHMsIGRlZXBEYXRhQW5kRXZlbnRzICkge1xuXHRcdGRhdGFBbmRFdmVudHMgPSBkYXRhQW5kRXZlbnRzID09IG51bGwgPyBmYWxzZSA6IGRhdGFBbmRFdmVudHM7XG5cdFx0ZGVlcERhdGFBbmRFdmVudHMgPSBkZWVwRGF0YUFuZEV2ZW50cyA9PSBudWxsID8gZGF0YUFuZEV2ZW50cyA6IGRlZXBEYXRhQW5kRXZlbnRzO1xuXG5cdFx0cmV0dXJuIHRoaXMubWFwKCBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiBqUXVlcnkuY2xvbmUoIHRoaXMsIGRhdGFBbmRFdmVudHMsIGRlZXBEYXRhQW5kRXZlbnRzICk7XG5cdFx0fSApO1xuXHR9LFxuXG5cdGh0bWw6IGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHRyZXR1cm4gYWNjZXNzKCB0aGlzLCBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0XHR2YXIgZWxlbSA9IHRoaXNbIDAgXSB8fCB7fSxcblx0XHRcdFx0aSA9IDAsXG5cdFx0XHRcdGwgPSB0aGlzLmxlbmd0aDtcblxuXHRcdFx0aWYgKCB2YWx1ZSA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRyZXR1cm4gZWxlbS5ub2RlVHlwZSA9PT0gMSA/XG5cdFx0XHRcdFx0ZWxlbS5pbm5lckhUTUwucmVwbGFjZSggcmlubGluZWpRdWVyeSwgXCJcIiApIDpcblx0XHRcdFx0XHR1bmRlZmluZWQ7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFNlZSBpZiB3ZSBjYW4gdGFrZSBhIHNob3J0Y3V0IGFuZCBqdXN0IHVzZSBpbm5lckhUTUxcblx0XHRcdGlmICggdHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiICYmICFybm9Jbm5lcmh0bWwudGVzdCggdmFsdWUgKSAmJlxuXHRcdFx0XHQoIHN1cHBvcnQuaHRtbFNlcmlhbGl6ZSB8fCAhcm5vc2hpbWNhY2hlLnRlc3QoIHZhbHVlICkgICkgJiZcblx0XHRcdFx0KCBzdXBwb3J0LmxlYWRpbmdXaGl0ZXNwYWNlIHx8ICFybGVhZGluZ1doaXRlc3BhY2UudGVzdCggdmFsdWUgKSApICYmXG5cdFx0XHRcdCF3cmFwTWFwWyAoIHJ0YWdOYW1lLmV4ZWMoIHZhbHVlICkgfHwgWyBcIlwiLCBcIlwiIF0gKVsgMSBdLnRvTG93ZXJDYXNlKCkgXSApIHtcblxuXHRcdFx0XHR2YWx1ZSA9IGpRdWVyeS5odG1sUHJlZmlsdGVyKCB2YWx1ZSApO1xuXG5cdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0Zm9yICggOyBpIDwgbDsgaSsrICkge1xuXG5cdFx0XHRcdFx0XHQvLyBSZW1vdmUgZWxlbWVudCBub2RlcyBhbmQgcHJldmVudCBtZW1vcnkgbGVha3Ncblx0XHRcdFx0XHRcdGVsZW0gPSB0aGlzWyBpIF0gfHwge307XG5cdFx0XHRcdFx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgKSB7XG5cdFx0XHRcdFx0XHRcdGpRdWVyeS5jbGVhbkRhdGEoIGdldEFsbCggZWxlbSwgZmFsc2UgKSApO1xuXHRcdFx0XHRcdFx0XHRlbGVtLmlubmVySFRNTCA9IHZhbHVlO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGVsZW0gPSAwO1xuXG5cdFx0XHRcdC8vIElmIHVzaW5nIGlubmVySFRNTCB0aHJvd3MgYW4gZXhjZXB0aW9uLCB1c2UgdGhlIGZhbGxiYWNrIG1ldGhvZFxuXHRcdFx0XHR9IGNhdGNoICggZSApIHt9XG5cdFx0XHR9XG5cblx0XHRcdGlmICggZWxlbSApIHtcblx0XHRcdFx0dGhpcy5lbXB0eSgpLmFwcGVuZCggdmFsdWUgKTtcblx0XHRcdH1cblx0XHR9LCBudWxsLCB2YWx1ZSwgYXJndW1lbnRzLmxlbmd0aCApO1xuXHR9LFxuXG5cdHJlcGxhY2VXaXRoOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgaWdub3JlZCA9IFtdO1xuXG5cdFx0Ly8gTWFrZSB0aGUgY2hhbmdlcywgcmVwbGFjaW5nIGVhY2ggbm9uLWlnbm9yZWQgY29udGV4dCBlbGVtZW50IHdpdGggdGhlIG5ldyBjb250ZW50XG5cdFx0cmV0dXJuIGRvbU1hbmlwKCB0aGlzLCBhcmd1bWVudHMsIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0dmFyIHBhcmVudCA9IHRoaXMucGFyZW50Tm9kZTtcblxuXHRcdFx0aWYgKCBqUXVlcnkuaW5BcnJheSggdGhpcywgaWdub3JlZCApIDwgMCApIHtcblx0XHRcdFx0alF1ZXJ5LmNsZWFuRGF0YSggZ2V0QWxsKCB0aGlzICkgKTtcblx0XHRcdFx0aWYgKCBwYXJlbnQgKSB7XG5cdFx0XHRcdFx0cGFyZW50LnJlcGxhY2VDaGlsZCggZWxlbSwgdGhpcyApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHQvLyBGb3JjZSBjYWxsYmFjayBpbnZvY2F0aW9uXG5cdFx0fSwgaWdub3JlZCApO1xuXHR9XG59ICk7XG5cbmpRdWVyeS5lYWNoKCB7XG5cdGFwcGVuZFRvOiBcImFwcGVuZFwiLFxuXHRwcmVwZW5kVG86IFwicHJlcGVuZFwiLFxuXHRpbnNlcnRCZWZvcmU6IFwiYmVmb3JlXCIsXG5cdGluc2VydEFmdGVyOiBcImFmdGVyXCIsXG5cdHJlcGxhY2VBbGw6IFwicmVwbGFjZVdpdGhcIlxufSwgZnVuY3Rpb24oIG5hbWUsIG9yaWdpbmFsICkge1xuXHRqUXVlcnkuZm5bIG5hbWUgXSA9IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHR2YXIgZWxlbXMsXG5cdFx0XHRpID0gMCxcblx0XHRcdHJldCA9IFtdLFxuXHRcdFx0aW5zZXJ0ID0galF1ZXJ5KCBzZWxlY3RvciApLFxuXHRcdFx0bGFzdCA9IGluc2VydC5sZW5ndGggLSAxO1xuXG5cdFx0Zm9yICggOyBpIDw9IGxhc3Q7IGkrKyApIHtcblx0XHRcdGVsZW1zID0gaSA9PT0gbGFzdCA/IHRoaXMgOiB0aGlzLmNsb25lKCB0cnVlICk7XG5cdFx0XHRqUXVlcnkoIGluc2VydFsgaSBdIClbIG9yaWdpbmFsIF0oIGVsZW1zICk7XG5cblx0XHRcdC8vIE1vZGVybiBicm93c2VycyBjYW4gYXBwbHkgalF1ZXJ5IGNvbGxlY3Rpb25zIGFzIGFycmF5cywgYnV0IG9sZElFIG5lZWRzIGEgLmdldCgpXG5cdFx0XHRwdXNoLmFwcGx5KCByZXQsIGVsZW1zLmdldCgpICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCByZXQgKTtcblx0fTtcbn0gKTtcblxuXG52YXIgaWZyYW1lLFxuXHRlbGVtZGlzcGxheSA9IHtcblxuXHRcdC8vIFN1cHBvcnQ6IEZpcmVmb3hcblx0XHQvLyBXZSBoYXZlIHRvIHByZS1kZWZpbmUgdGhlc2UgdmFsdWVzIGZvciBGRiAoIzEwMjI3KVxuXHRcdEhUTUw6IFwiYmxvY2tcIixcblx0XHRCT0RZOiBcImJsb2NrXCJcblx0fTtcblxuLyoqXG4gKiBSZXRyaWV2ZSB0aGUgYWN0dWFsIGRpc3BsYXkgb2YgYSBlbGVtZW50XG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBub2RlTmFtZSBvZiB0aGUgZWxlbWVudFxuICogQHBhcmFtIHtPYmplY3R9IGRvYyBEb2N1bWVudCBvYmplY3RcbiAqL1xuXG4vLyBDYWxsZWQgb25seSBmcm9tIHdpdGhpbiBkZWZhdWx0RGlzcGxheVxuZnVuY3Rpb24gYWN0dWFsRGlzcGxheSggbmFtZSwgZG9jICkge1xuXHR2YXIgZWxlbSA9IGpRdWVyeSggZG9jLmNyZWF0ZUVsZW1lbnQoIG5hbWUgKSApLmFwcGVuZFRvKCBkb2MuYm9keSApLFxuXG5cdFx0ZGlzcGxheSA9IGpRdWVyeS5jc3MoIGVsZW1bIDAgXSwgXCJkaXNwbGF5XCIgKTtcblxuXHQvLyBXZSBkb24ndCBoYXZlIGFueSBkYXRhIHN0b3JlZCBvbiB0aGUgZWxlbWVudCxcblx0Ly8gc28gdXNlIFwiZGV0YWNoXCIgbWV0aG9kIGFzIGZhc3Qgd2F5IHRvIGdldCByaWQgb2YgdGhlIGVsZW1lbnRcblx0ZWxlbS5kZXRhY2goKTtcblxuXHRyZXR1cm4gZGlzcGxheTtcbn1cblxuLyoqXG4gKiBUcnkgdG8gZGV0ZXJtaW5lIHRoZSBkZWZhdWx0IGRpc3BsYXkgdmFsdWUgb2YgYW4gZWxlbWVudFxuICogQHBhcmFtIHtTdHJpbmd9IG5vZGVOYW1lXG4gKi9cbmZ1bmN0aW9uIGRlZmF1bHREaXNwbGF5KCBub2RlTmFtZSApIHtcblx0dmFyIGRvYyA9IGRvY3VtZW50LFxuXHRcdGRpc3BsYXkgPSBlbGVtZGlzcGxheVsgbm9kZU5hbWUgXTtcblxuXHRpZiAoICFkaXNwbGF5ICkge1xuXHRcdGRpc3BsYXkgPSBhY3R1YWxEaXNwbGF5KCBub2RlTmFtZSwgZG9jICk7XG5cblx0XHQvLyBJZiB0aGUgc2ltcGxlIHdheSBmYWlscywgcmVhZCBmcm9tIGluc2lkZSBhbiBpZnJhbWVcblx0XHRpZiAoIGRpc3BsYXkgPT09IFwibm9uZVwiIHx8ICFkaXNwbGF5ICkge1xuXG5cdFx0XHQvLyBVc2UgdGhlIGFscmVhZHktY3JlYXRlZCBpZnJhbWUgaWYgcG9zc2libGVcblx0XHRcdGlmcmFtZSA9ICggaWZyYW1lIHx8IGpRdWVyeSggXCI8aWZyYW1lIGZyYW1lYm9yZGVyPScwJyB3aWR0aD0nMCcgaGVpZ2h0PScwJy8+XCIgKSApXG5cdFx0XHRcdC5hcHBlbmRUbyggZG9jLmRvY3VtZW50RWxlbWVudCApO1xuXG5cdFx0XHQvLyBBbHdheXMgd3JpdGUgYSBuZXcgSFRNTCBza2VsZXRvbiBzbyBXZWJraXQgYW5kIEZpcmVmb3ggZG9uJ3QgY2hva2Ugb24gcmV1c2Vcblx0XHRcdGRvYyA9ICggaWZyYW1lWyAwIF0uY29udGVudFdpbmRvdyB8fCBpZnJhbWVbIDAgXS5jb250ZW50RG9jdW1lbnQgKS5kb2N1bWVudDtcblxuXHRcdFx0Ly8gU3VwcG9ydDogSUVcblx0XHRcdGRvYy53cml0ZSgpO1xuXHRcdFx0ZG9jLmNsb3NlKCk7XG5cblx0XHRcdGRpc3BsYXkgPSBhY3R1YWxEaXNwbGF5KCBub2RlTmFtZSwgZG9jICk7XG5cdFx0XHRpZnJhbWUuZGV0YWNoKCk7XG5cdFx0fVxuXG5cdFx0Ly8gU3RvcmUgdGhlIGNvcnJlY3QgZGVmYXVsdCBkaXNwbGF5XG5cdFx0ZWxlbWRpc3BsYXlbIG5vZGVOYW1lIF0gPSBkaXNwbGF5O1xuXHR9XG5cblx0cmV0dXJuIGRpc3BsYXk7XG59XG52YXIgcm1hcmdpbiA9ICggL15tYXJnaW4vICk7XG5cbnZhciBybnVtbm9ucHggPSBuZXcgUmVnRXhwKCBcIl4oXCIgKyBwbnVtICsgXCIpKD8hcHgpW2EteiVdKyRcIiwgXCJpXCIgKTtcblxudmFyIHN3YXAgPSBmdW5jdGlvbiggZWxlbSwgb3B0aW9ucywgY2FsbGJhY2ssIGFyZ3MgKSB7XG5cdHZhciByZXQsIG5hbWUsXG5cdFx0b2xkID0ge307XG5cblx0Ly8gUmVtZW1iZXIgdGhlIG9sZCB2YWx1ZXMsIGFuZCBpbnNlcnQgdGhlIG5ldyBvbmVzXG5cdGZvciAoIG5hbWUgaW4gb3B0aW9ucyApIHtcblx0XHRvbGRbIG5hbWUgXSA9IGVsZW0uc3R5bGVbIG5hbWUgXTtcblx0XHRlbGVtLnN0eWxlWyBuYW1lIF0gPSBvcHRpb25zWyBuYW1lIF07XG5cdH1cblxuXHRyZXQgPSBjYWxsYmFjay5hcHBseSggZWxlbSwgYXJncyB8fCBbXSApO1xuXG5cdC8vIFJldmVydCB0aGUgb2xkIHZhbHVlc1xuXHRmb3IgKCBuYW1lIGluIG9wdGlvbnMgKSB7XG5cdFx0ZWxlbS5zdHlsZVsgbmFtZSBdID0gb2xkWyBuYW1lIF07XG5cdH1cblxuXHRyZXR1cm4gcmV0O1xufTtcblxuXG52YXIgZG9jdW1lbnRFbGVtZW50ID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuXG5cblxuKCBmdW5jdGlvbigpIHtcblx0dmFyIHBpeGVsUG9zaXRpb25WYWwsIHBpeGVsTWFyZ2luUmlnaHRWYWwsIGJveFNpemluZ1JlbGlhYmxlVmFsLFxuXHRcdHJlbGlhYmxlSGlkZGVuT2Zmc2V0c1ZhbCwgcmVsaWFibGVNYXJnaW5SaWdodFZhbCwgcmVsaWFibGVNYXJnaW5MZWZ0VmFsLFxuXHRcdGNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiZGl2XCIgKSxcblx0XHRkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImRpdlwiICk7XG5cblx0Ly8gRmluaXNoIGVhcmx5IGluIGxpbWl0ZWQgKG5vbi1icm93c2VyKSBlbnZpcm9ubWVudHNcblx0aWYgKCAhZGl2LnN0eWxlICkge1xuXHRcdHJldHVybjtcblx0fVxuXG5cdGRpdi5zdHlsZS5jc3NUZXh0ID0gXCJmbG9hdDpsZWZ0O29wYWNpdHk6LjVcIjtcblxuXHQvLyBTdXBwb3J0OiBJRTw5XG5cdC8vIE1ha2Ugc3VyZSB0aGF0IGVsZW1lbnQgb3BhY2l0eSBleGlzdHMgKGFzIG9wcG9zZWQgdG8gZmlsdGVyKVxuXHRzdXBwb3J0Lm9wYWNpdHkgPSBkaXYuc3R5bGUub3BhY2l0eSA9PT0gXCIwLjVcIjtcblxuXHQvLyBWZXJpZnkgc3R5bGUgZmxvYXQgZXhpc3RlbmNlXG5cdC8vIChJRSB1c2VzIHN0eWxlRmxvYXQgaW5zdGVhZCBvZiBjc3NGbG9hdClcblx0c3VwcG9ydC5jc3NGbG9hdCA9ICEhZGl2LnN0eWxlLmNzc0Zsb2F0O1xuXG5cdGRpdi5zdHlsZS5iYWNrZ3JvdW5kQ2xpcCA9IFwiY29udGVudC1ib3hcIjtcblx0ZGl2LmNsb25lTm9kZSggdHJ1ZSApLnN0eWxlLmJhY2tncm91bmRDbGlwID0gXCJcIjtcblx0c3VwcG9ydC5jbGVhckNsb25lU3R5bGUgPSBkaXYuc3R5bGUuYmFja2dyb3VuZENsaXAgPT09IFwiY29udGVudC1ib3hcIjtcblxuXHRjb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImRpdlwiICk7XG5cdGNvbnRhaW5lci5zdHlsZS5jc3NUZXh0ID0gXCJib3JkZXI6MDt3aWR0aDo4cHg7aGVpZ2h0OjA7dG9wOjA7bGVmdDotOTk5OXB4O1wiICtcblx0XHRcInBhZGRpbmc6MDttYXJnaW4tdG9wOjFweDtwb3NpdGlvbjphYnNvbHV0ZVwiO1xuXHRkaXYuaW5uZXJIVE1MID0gXCJcIjtcblx0Y29udGFpbmVyLmFwcGVuZENoaWxkKCBkaXYgKTtcblxuXHQvLyBTdXBwb3J0OiBGaXJlZm94PDI5LCBBbmRyb2lkIDIuM1xuXHQvLyBWZW5kb3ItcHJlZml4IGJveC1zaXppbmdcblx0c3VwcG9ydC5ib3hTaXppbmcgPSBkaXYuc3R5bGUuYm94U2l6aW5nID09PSBcIlwiIHx8IGRpdi5zdHlsZS5Nb3pCb3hTaXppbmcgPT09IFwiXCIgfHxcblx0XHRkaXYuc3R5bGUuV2Via2l0Qm94U2l6aW5nID09PSBcIlwiO1xuXG5cdGpRdWVyeS5leHRlbmQoIHN1cHBvcnQsIHtcblx0XHRyZWxpYWJsZUhpZGRlbk9mZnNldHM6IGZ1bmN0aW9uKCkge1xuXHRcdFx0aWYgKCBwaXhlbFBvc2l0aW9uVmFsID09IG51bGwgKSB7XG5cdFx0XHRcdGNvbXB1dGVTdHlsZVRlc3RzKCk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcmVsaWFibGVIaWRkZW5PZmZzZXRzVmFsO1xuXHRcdH0sXG5cblx0XHRib3hTaXppbmdSZWxpYWJsZTogZnVuY3Rpb24oKSB7XG5cblx0XHRcdC8vIFdlJ3JlIGNoZWNraW5nIGZvciBwaXhlbFBvc2l0aW9uVmFsIGhlcmUgaW5zdGVhZCBvZiBib3hTaXppbmdSZWxpYWJsZVZhbFxuXHRcdFx0Ly8gc2luY2UgdGhhdCBjb21wcmVzc2VzIGJldHRlciBhbmQgdGhleSdyZSBjb21wdXRlZCB0b2dldGhlciBhbnl3YXkuXG5cdFx0XHRpZiAoIHBpeGVsUG9zaXRpb25WYWwgPT0gbnVsbCApIHtcblx0XHRcdFx0Y29tcHV0ZVN0eWxlVGVzdHMoKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBib3hTaXppbmdSZWxpYWJsZVZhbDtcblx0XHR9LFxuXG5cdFx0cGl4ZWxNYXJnaW5SaWdodDogZnVuY3Rpb24oKSB7XG5cblx0XHRcdC8vIFN1cHBvcnQ6IEFuZHJvaWQgNC4wLTQuM1xuXHRcdFx0aWYgKCBwaXhlbFBvc2l0aW9uVmFsID09IG51bGwgKSB7XG5cdFx0XHRcdGNvbXB1dGVTdHlsZVRlc3RzKCk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcGl4ZWxNYXJnaW5SaWdodFZhbDtcblx0XHR9LFxuXG5cdFx0cGl4ZWxQb3NpdGlvbjogZnVuY3Rpb24oKSB7XG5cdFx0XHRpZiAoIHBpeGVsUG9zaXRpb25WYWwgPT0gbnVsbCApIHtcblx0XHRcdFx0Y29tcHV0ZVN0eWxlVGVzdHMoKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBwaXhlbFBvc2l0aW9uVmFsO1xuXHRcdH0sXG5cblx0XHRyZWxpYWJsZU1hcmdpblJpZ2h0OiBmdW5jdGlvbigpIHtcblxuXHRcdFx0Ly8gU3VwcG9ydDogQW5kcm9pZCAyLjNcblx0XHRcdGlmICggcGl4ZWxQb3NpdGlvblZhbCA9PSBudWxsICkge1xuXHRcdFx0XHRjb21wdXRlU3R5bGVUZXN0cygpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHJlbGlhYmxlTWFyZ2luUmlnaHRWYWw7XG5cdFx0fSxcblxuXHRcdHJlbGlhYmxlTWFyZ2luTGVmdDogZnVuY3Rpb24oKSB7XG5cblx0XHRcdC8vIFN1cHBvcnQ6IElFIDw9OCBvbmx5LCBBbmRyb2lkIDQuMCAtIDQuMyBvbmx5LCBGaXJlZm94IDw9MyAtIDM3XG5cdFx0XHRpZiAoIHBpeGVsUG9zaXRpb25WYWwgPT0gbnVsbCApIHtcblx0XHRcdFx0Y29tcHV0ZVN0eWxlVGVzdHMoKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiByZWxpYWJsZU1hcmdpbkxlZnRWYWw7XG5cdFx0fVxuXHR9ICk7XG5cblx0ZnVuY3Rpb24gY29tcHV0ZVN0eWxlVGVzdHMoKSB7XG5cdFx0dmFyIGNvbnRlbnRzLCBkaXZTdHlsZSxcblx0XHRcdGRvY3VtZW50RWxlbWVudCA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcblxuXHRcdC8vIFNldHVwXG5cdFx0ZG9jdW1lbnRFbGVtZW50LmFwcGVuZENoaWxkKCBjb250YWluZXIgKTtcblxuXHRcdGRpdi5zdHlsZS5jc3NUZXh0ID1cblxuXHRcdFx0Ly8gU3VwcG9ydDogQW5kcm9pZCAyLjNcblx0XHRcdC8vIFZlbmRvci1wcmVmaXggYm94LXNpemluZ1xuXHRcdFx0XCItd2Via2l0LWJveC1zaXppbmc6Ym9yZGVyLWJveDtib3gtc2l6aW5nOmJvcmRlci1ib3g7XCIgK1xuXHRcdFx0XCJwb3NpdGlvbjpyZWxhdGl2ZTtkaXNwbGF5OmJsb2NrO1wiICtcblx0XHRcdFwibWFyZ2luOmF1dG87Ym9yZGVyOjFweDtwYWRkaW5nOjFweDtcIiArXG5cdFx0XHRcInRvcDoxJTt3aWR0aDo1MCVcIjtcblxuXHRcdC8vIFN1cHBvcnQ6IElFPDlcblx0XHQvLyBBc3N1bWUgcmVhc29uYWJsZSB2YWx1ZXMgaW4gdGhlIGFic2VuY2Ugb2YgZ2V0Q29tcHV0ZWRTdHlsZVxuXHRcdHBpeGVsUG9zaXRpb25WYWwgPSBib3hTaXppbmdSZWxpYWJsZVZhbCA9IHJlbGlhYmxlTWFyZ2luTGVmdFZhbCA9IGZhbHNlO1xuXHRcdHBpeGVsTWFyZ2luUmlnaHRWYWwgPSByZWxpYWJsZU1hcmdpblJpZ2h0VmFsID0gdHJ1ZTtcblxuXHRcdC8vIENoZWNrIGZvciBnZXRDb21wdXRlZFN0eWxlIHNvIHRoYXQgdGhpcyBjb2RlIGlzIG5vdCBydW4gaW4gSUU8OS5cblx0XHRpZiAoIHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlICkge1xuXHRcdFx0ZGl2U3R5bGUgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSggZGl2ICk7XG5cdFx0XHRwaXhlbFBvc2l0aW9uVmFsID0gKCBkaXZTdHlsZSB8fCB7fSApLnRvcCAhPT0gXCIxJVwiO1xuXHRcdFx0cmVsaWFibGVNYXJnaW5MZWZ0VmFsID0gKCBkaXZTdHlsZSB8fCB7fSApLm1hcmdpbkxlZnQgPT09IFwiMnB4XCI7XG5cdFx0XHRib3hTaXppbmdSZWxpYWJsZVZhbCA9ICggZGl2U3R5bGUgfHwgeyB3aWR0aDogXCI0cHhcIiB9ICkud2lkdGggPT09IFwiNHB4XCI7XG5cblx0XHRcdC8vIFN1cHBvcnQ6IEFuZHJvaWQgNC4wIC0gNC4zIG9ubHlcblx0XHRcdC8vIFNvbWUgc3R5bGVzIGNvbWUgYmFjayB3aXRoIHBlcmNlbnRhZ2UgdmFsdWVzLCBldmVuIHRob3VnaCB0aGV5IHNob3VsZG4ndFxuXHRcdFx0ZGl2LnN0eWxlLm1hcmdpblJpZ2h0ID0gXCI1MCVcIjtcblx0XHRcdHBpeGVsTWFyZ2luUmlnaHRWYWwgPSAoIGRpdlN0eWxlIHx8IHsgbWFyZ2luUmlnaHQ6IFwiNHB4XCIgfSApLm1hcmdpblJpZ2h0ID09PSBcIjRweFwiO1xuXG5cdFx0XHQvLyBTdXBwb3J0OiBBbmRyb2lkIDIuMyBvbmx5XG5cdFx0XHQvLyBEaXYgd2l0aCBleHBsaWNpdCB3aWR0aCBhbmQgbm8gbWFyZ2luLXJpZ2h0IGluY29ycmVjdGx5XG5cdFx0XHQvLyBnZXRzIGNvbXB1dGVkIG1hcmdpbi1yaWdodCBiYXNlZCBvbiB3aWR0aCBvZiBjb250YWluZXIgKCMzMzMzKVxuXHRcdFx0Ly8gV2ViS2l0IEJ1ZyAxMzM0MyAtIGdldENvbXB1dGVkU3R5bGUgcmV0dXJucyB3cm9uZyB2YWx1ZSBmb3IgbWFyZ2luLXJpZ2h0XG5cdFx0XHRjb250ZW50cyA9IGRpdi5hcHBlbmRDaGlsZCggZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJkaXZcIiApICk7XG5cblx0XHRcdC8vIFJlc2V0IENTUzogYm94LXNpemluZzsgZGlzcGxheTsgbWFyZ2luOyBib3JkZXI7IHBhZGRpbmdcblx0XHRcdGNvbnRlbnRzLnN0eWxlLmNzc1RleHQgPSBkaXYuc3R5bGUuY3NzVGV4dCA9XG5cblx0XHRcdFx0Ly8gU3VwcG9ydDogQW5kcm9pZCAyLjNcblx0XHRcdFx0Ly8gVmVuZG9yLXByZWZpeCBib3gtc2l6aW5nXG5cdFx0XHRcdFwiLXdlYmtpdC1ib3gtc2l6aW5nOmNvbnRlbnQtYm94Oy1tb3otYm94LXNpemluZzpjb250ZW50LWJveDtcIiArXG5cdFx0XHRcdFwiYm94LXNpemluZzpjb250ZW50LWJveDtkaXNwbGF5OmJsb2NrO21hcmdpbjowO2JvcmRlcjowO3BhZGRpbmc6MFwiO1xuXHRcdFx0Y29udGVudHMuc3R5bGUubWFyZ2luUmlnaHQgPSBjb250ZW50cy5zdHlsZS53aWR0aCA9IFwiMFwiO1xuXHRcdFx0ZGl2LnN0eWxlLndpZHRoID0gXCIxcHhcIjtcblxuXHRcdFx0cmVsaWFibGVNYXJnaW5SaWdodFZhbCA9XG5cdFx0XHRcdCFwYXJzZUZsb2F0KCAoIHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKCBjb250ZW50cyApIHx8IHt9ICkubWFyZ2luUmlnaHQgKTtcblxuXHRcdFx0ZGl2LnJlbW92ZUNoaWxkKCBjb250ZW50cyApO1xuXHRcdH1cblxuXHRcdC8vIFN1cHBvcnQ6IElFNi04XG5cdFx0Ly8gRmlyc3QgY2hlY2sgdGhhdCBnZXRDbGllbnRSZWN0cyB3b3JrcyBhcyBleHBlY3RlZFxuXHRcdC8vIENoZWNrIGlmIHRhYmxlIGNlbGxzIHN0aWxsIGhhdmUgb2Zmc2V0V2lkdGgvSGVpZ2h0IHdoZW4gdGhleSBhcmUgc2V0XG5cdFx0Ly8gdG8gZGlzcGxheTpub25lIGFuZCB0aGVyZSBhcmUgc3RpbGwgb3RoZXIgdmlzaWJsZSB0YWJsZSBjZWxscyBpbiBhXG5cdFx0Ly8gdGFibGUgcm93OyBpZiBzbywgb2Zmc2V0V2lkdGgvSGVpZ2h0IGFyZSBub3QgcmVsaWFibGUgZm9yIHVzZSB3aGVuXG5cdFx0Ly8gZGV0ZXJtaW5pbmcgaWYgYW4gZWxlbWVudCBoYXMgYmVlbiBoaWRkZW4gZGlyZWN0bHkgdXNpbmdcblx0XHQvLyBkaXNwbGF5Om5vbmUgKGl0IGlzIHN0aWxsIHNhZmUgdG8gdXNlIG9mZnNldHMgaWYgYSBwYXJlbnQgZWxlbWVudCBpc1xuXHRcdC8vIGhpZGRlbjsgZG9uIHNhZmV0eSBnb2dnbGVzIGFuZCBzZWUgYnVnICM0NTEyIGZvciBtb3JlIGluZm9ybWF0aW9uKS5cblx0XHRkaXYuc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiO1xuXHRcdHJlbGlhYmxlSGlkZGVuT2Zmc2V0c1ZhbCA9IGRpdi5nZXRDbGllbnRSZWN0cygpLmxlbmd0aCA9PT0gMDtcblx0XHRpZiAoIHJlbGlhYmxlSGlkZGVuT2Zmc2V0c1ZhbCApIHtcblx0XHRcdGRpdi5zdHlsZS5kaXNwbGF5ID0gXCJcIjtcblx0XHRcdGRpdi5pbm5lckhUTUwgPSBcIjx0YWJsZT48dHI+PHRkPjwvdGQ+PHRkPnQ8L3RkPjwvdHI+PC90YWJsZT5cIjtcblx0XHRcdGRpdi5jaGlsZE5vZGVzWyAwIF0uc3R5bGUuYm9yZGVyQ29sbGFwc2UgPSBcInNlcGFyYXRlXCI7XG5cdFx0XHRjb250ZW50cyA9IGRpdi5nZXRFbGVtZW50c0J5VGFnTmFtZSggXCJ0ZFwiICk7XG5cdFx0XHRjb250ZW50c1sgMCBdLnN0eWxlLmNzc1RleHQgPSBcIm1hcmdpbjowO2JvcmRlcjowO3BhZGRpbmc6MDtkaXNwbGF5Om5vbmVcIjtcblx0XHRcdHJlbGlhYmxlSGlkZGVuT2Zmc2V0c1ZhbCA9IGNvbnRlbnRzWyAwIF0ub2Zmc2V0SGVpZ2h0ID09PSAwO1xuXHRcdFx0aWYgKCByZWxpYWJsZUhpZGRlbk9mZnNldHNWYWwgKSB7XG5cdFx0XHRcdGNvbnRlbnRzWyAwIF0uc3R5bGUuZGlzcGxheSA9IFwiXCI7XG5cdFx0XHRcdGNvbnRlbnRzWyAxIF0uc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiO1xuXHRcdFx0XHRyZWxpYWJsZUhpZGRlbk9mZnNldHNWYWwgPSBjb250ZW50c1sgMCBdLm9mZnNldEhlaWdodCA9PT0gMDtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBUZWFyZG93blxuXHRcdGRvY3VtZW50RWxlbWVudC5yZW1vdmVDaGlsZCggY29udGFpbmVyICk7XG5cdH1cblxufSApKCk7XG5cblxudmFyIGdldFN0eWxlcywgY3VyQ1NTLFxuXHRycG9zaXRpb24gPSAvXih0b3B8cmlnaHR8Ym90dG9tfGxlZnQpJC87XG5cbmlmICggd2luZG93LmdldENvbXB1dGVkU3R5bGUgKSB7XG5cdGdldFN0eWxlcyA9IGZ1bmN0aW9uKCBlbGVtICkge1xuXG5cdFx0Ly8gU3VwcG9ydDogSUU8PTExKywgRmlyZWZveDw9MzArICgjMTUwOTgsICMxNDE1MClcblx0XHQvLyBJRSB0aHJvd3Mgb24gZWxlbWVudHMgY3JlYXRlZCBpbiBwb3B1cHNcblx0XHQvLyBGRiBtZWFud2hpbGUgdGhyb3dzIG9uIGZyYW1lIGVsZW1lbnRzIHRocm91Z2ggXCJkZWZhdWx0Vmlldy5nZXRDb21wdXRlZFN0eWxlXCJcblx0XHR2YXIgdmlldyA9IGVsZW0ub3duZXJEb2N1bWVudC5kZWZhdWx0VmlldztcblxuXHRcdGlmICggIXZpZXcgfHwgIXZpZXcub3BlbmVyICkge1xuXHRcdFx0dmlldyA9IHdpbmRvdztcblx0XHR9XG5cblx0XHRyZXR1cm4gdmlldy5nZXRDb21wdXRlZFN0eWxlKCBlbGVtICk7XG5cdH07XG5cblx0Y3VyQ1NTID0gZnVuY3Rpb24oIGVsZW0sIG5hbWUsIGNvbXB1dGVkICkge1xuXHRcdHZhciB3aWR0aCwgbWluV2lkdGgsIG1heFdpZHRoLCByZXQsXG5cdFx0XHRzdHlsZSA9IGVsZW0uc3R5bGU7XG5cblx0XHRjb21wdXRlZCA9IGNvbXB1dGVkIHx8IGdldFN0eWxlcyggZWxlbSApO1xuXG5cdFx0Ly8gZ2V0UHJvcGVydHlWYWx1ZSBpcyBvbmx5IG5lZWRlZCBmb3IgLmNzcygnZmlsdGVyJykgaW4gSUU5LCBzZWUgIzEyNTM3XG5cdFx0cmV0ID0gY29tcHV0ZWQgPyBjb21wdXRlZC5nZXRQcm9wZXJ0eVZhbHVlKCBuYW1lICkgfHwgY29tcHV0ZWRbIG5hbWUgXSA6IHVuZGVmaW5lZDtcblxuXHRcdC8vIFN1cHBvcnQ6IE9wZXJhIDEyLjF4IG9ubHlcblx0XHQvLyBGYWxsIGJhY2sgdG8gc3R5bGUgZXZlbiB3aXRob3V0IGNvbXB1dGVkXG5cdFx0Ly8gY29tcHV0ZWQgaXMgdW5kZWZpbmVkIGZvciBlbGVtcyBvbiBkb2N1bWVudCBmcmFnbWVudHNcblx0XHRpZiAoICggcmV0ID09PSBcIlwiIHx8IHJldCA9PT0gdW5kZWZpbmVkICkgJiYgIWpRdWVyeS5jb250YWlucyggZWxlbS5vd25lckRvY3VtZW50LCBlbGVtICkgKSB7XG5cdFx0XHRyZXQgPSBqUXVlcnkuc3R5bGUoIGVsZW0sIG5hbWUgKTtcblx0XHR9XG5cblx0XHRpZiAoIGNvbXB1dGVkICkge1xuXG5cdFx0XHQvLyBBIHRyaWJ1dGUgdG8gdGhlIFwiYXdlc29tZSBoYWNrIGJ5IERlYW4gRWR3YXJkc1wiXG5cdFx0XHQvLyBDaHJvbWUgPCAxNyBhbmQgU2FmYXJpIDUuMCB1c2VzIFwiY29tcHV0ZWQgdmFsdWVcIlxuXHRcdFx0Ly8gaW5zdGVhZCBvZiBcInVzZWQgdmFsdWVcIiBmb3IgbWFyZ2luLXJpZ2h0XG5cdFx0XHQvLyBTYWZhcmkgNS4xLjcgKGF0IGxlYXN0KSByZXR1cm5zIHBlcmNlbnRhZ2UgZm9yIGEgbGFyZ2VyIHNldCBvZiB2YWx1ZXMsXG5cdFx0XHQvLyBidXQgd2lkdGggc2VlbXMgdG8gYmUgcmVsaWFibHkgcGl4ZWxzXG5cdFx0XHQvLyB0aGlzIGlzIGFnYWluc3QgdGhlIENTU09NIGRyYWZ0IHNwZWM6XG5cdFx0XHQvLyBodHRwOi8vZGV2LnczLm9yZy9jc3N3Zy9jc3NvbS8jcmVzb2x2ZWQtdmFsdWVzXG5cdFx0XHRpZiAoICFzdXBwb3J0LnBpeGVsTWFyZ2luUmlnaHQoKSAmJiBybnVtbm9ucHgudGVzdCggcmV0ICkgJiYgcm1hcmdpbi50ZXN0KCBuYW1lICkgKSB7XG5cblx0XHRcdFx0Ly8gUmVtZW1iZXIgdGhlIG9yaWdpbmFsIHZhbHVlc1xuXHRcdFx0XHR3aWR0aCA9IHN0eWxlLndpZHRoO1xuXHRcdFx0XHRtaW5XaWR0aCA9IHN0eWxlLm1pbldpZHRoO1xuXHRcdFx0XHRtYXhXaWR0aCA9IHN0eWxlLm1heFdpZHRoO1xuXG5cdFx0XHRcdC8vIFB1dCBpbiB0aGUgbmV3IHZhbHVlcyB0byBnZXQgYSBjb21wdXRlZCB2YWx1ZSBvdXRcblx0XHRcdFx0c3R5bGUubWluV2lkdGggPSBzdHlsZS5tYXhXaWR0aCA9IHN0eWxlLndpZHRoID0gcmV0O1xuXHRcdFx0XHRyZXQgPSBjb21wdXRlZC53aWR0aDtcblxuXHRcdFx0XHQvLyBSZXZlcnQgdGhlIGNoYW5nZWQgdmFsdWVzXG5cdFx0XHRcdHN0eWxlLndpZHRoID0gd2lkdGg7XG5cdFx0XHRcdHN0eWxlLm1pbldpZHRoID0gbWluV2lkdGg7XG5cdFx0XHRcdHN0eWxlLm1heFdpZHRoID0gbWF4V2lkdGg7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gU3VwcG9ydDogSUVcblx0XHQvLyBJRSByZXR1cm5zIHpJbmRleCB2YWx1ZSBhcyBhbiBpbnRlZ2VyLlxuXHRcdHJldHVybiByZXQgPT09IHVuZGVmaW5lZCA/XG5cdFx0XHRyZXQgOlxuXHRcdFx0cmV0ICsgXCJcIjtcblx0fTtcbn0gZWxzZSBpZiAoIGRvY3VtZW50RWxlbWVudC5jdXJyZW50U3R5bGUgKSB7XG5cdGdldFN0eWxlcyA9IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHJldHVybiBlbGVtLmN1cnJlbnRTdHlsZTtcblx0fTtcblxuXHRjdXJDU1MgPSBmdW5jdGlvbiggZWxlbSwgbmFtZSwgY29tcHV0ZWQgKSB7XG5cdFx0dmFyIGxlZnQsIHJzLCByc0xlZnQsIHJldCxcblx0XHRcdHN0eWxlID0gZWxlbS5zdHlsZTtcblxuXHRcdGNvbXB1dGVkID0gY29tcHV0ZWQgfHwgZ2V0U3R5bGVzKCBlbGVtICk7XG5cdFx0cmV0ID0gY29tcHV0ZWQgPyBjb21wdXRlZFsgbmFtZSBdIDogdW5kZWZpbmVkO1xuXG5cdFx0Ly8gQXZvaWQgc2V0dGluZyByZXQgdG8gZW1wdHkgc3RyaW5nIGhlcmVcblx0XHQvLyBzbyB3ZSBkb24ndCBkZWZhdWx0IHRvIGF1dG9cblx0XHRpZiAoIHJldCA9PSBudWxsICYmIHN0eWxlICYmIHN0eWxlWyBuYW1lIF0gKSB7XG5cdFx0XHRyZXQgPSBzdHlsZVsgbmFtZSBdO1xuXHRcdH1cblxuXHRcdC8vIEZyb20gdGhlIGF3ZXNvbWUgaGFjayBieSBEZWFuIEVkd2FyZHNcblx0XHQvLyBodHRwOi8vZXJpay5lYWUubmV0L2FyY2hpdmVzLzIwMDcvMDcvMjcvMTguNTQuMTUvI2NvbW1lbnQtMTAyMjkxXG5cblx0XHQvLyBJZiB3ZSdyZSBub3QgZGVhbGluZyB3aXRoIGEgcmVndWxhciBwaXhlbCBudW1iZXJcblx0XHQvLyBidXQgYSBudW1iZXIgdGhhdCBoYXMgYSB3ZWlyZCBlbmRpbmcsIHdlIG5lZWQgdG8gY29udmVydCBpdCB0byBwaXhlbHNcblx0XHQvLyBidXQgbm90IHBvc2l0aW9uIGNzcyBhdHRyaWJ1dGVzLCBhcyB0aG9zZSBhcmVcblx0XHQvLyBwcm9wb3J0aW9uYWwgdG8gdGhlIHBhcmVudCBlbGVtZW50IGluc3RlYWRcblx0XHQvLyBhbmQgd2UgY2FuJ3QgbWVhc3VyZSB0aGUgcGFyZW50IGluc3RlYWQgYmVjYXVzZSBpdFxuXHRcdC8vIG1pZ2h0IHRyaWdnZXIgYSBcInN0YWNraW5nIGRvbGxzXCIgcHJvYmxlbVxuXHRcdGlmICggcm51bW5vbnB4LnRlc3QoIHJldCApICYmICFycG9zaXRpb24udGVzdCggbmFtZSApICkge1xuXG5cdFx0XHQvLyBSZW1lbWJlciB0aGUgb3JpZ2luYWwgdmFsdWVzXG5cdFx0XHRsZWZ0ID0gc3R5bGUubGVmdDtcblx0XHRcdHJzID0gZWxlbS5ydW50aW1lU3R5bGU7XG5cdFx0XHRyc0xlZnQgPSBycyAmJiBycy5sZWZ0O1xuXG5cdFx0XHQvLyBQdXQgaW4gdGhlIG5ldyB2YWx1ZXMgdG8gZ2V0IGEgY29tcHV0ZWQgdmFsdWUgb3V0XG5cdFx0XHRpZiAoIHJzTGVmdCApIHtcblx0XHRcdFx0cnMubGVmdCA9IGVsZW0uY3VycmVudFN0eWxlLmxlZnQ7XG5cdFx0XHR9XG5cdFx0XHRzdHlsZS5sZWZ0ID0gbmFtZSA9PT0gXCJmb250U2l6ZVwiID8gXCIxZW1cIiA6IHJldDtcblx0XHRcdHJldCA9IHN0eWxlLnBpeGVsTGVmdCArIFwicHhcIjtcblxuXHRcdFx0Ly8gUmV2ZXJ0IHRoZSBjaGFuZ2VkIHZhbHVlc1xuXHRcdFx0c3R5bGUubGVmdCA9IGxlZnQ7XG5cdFx0XHRpZiAoIHJzTGVmdCApIHtcblx0XHRcdFx0cnMubGVmdCA9IHJzTGVmdDtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBTdXBwb3J0OiBJRVxuXHRcdC8vIElFIHJldHVybnMgekluZGV4IHZhbHVlIGFzIGFuIGludGVnZXIuXG5cdFx0cmV0dXJuIHJldCA9PT0gdW5kZWZpbmVkID9cblx0XHRcdHJldCA6XG5cdFx0XHRyZXQgKyBcIlwiIHx8IFwiYXV0b1wiO1xuXHR9O1xufVxuXG5cblxuXG5mdW5jdGlvbiBhZGRHZXRIb29rSWYoIGNvbmRpdGlvbkZuLCBob29rRm4gKSB7XG5cblx0Ly8gRGVmaW5lIHRoZSBob29rLCB3ZSdsbCBjaGVjayBvbiB0aGUgZmlyc3QgcnVuIGlmIGl0J3MgcmVhbGx5IG5lZWRlZC5cblx0cmV0dXJuIHtcblx0XHRnZXQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0aWYgKCBjb25kaXRpb25GbigpICkge1xuXG5cdFx0XHRcdC8vIEhvb2sgbm90IG5lZWRlZCAob3IgaXQncyBub3QgcG9zc2libGUgdG8gdXNlIGl0IGR1ZVxuXHRcdFx0XHQvLyB0byBtaXNzaW5nIGRlcGVuZGVuY3kpLCByZW1vdmUgaXQuXG5cdFx0XHRcdGRlbGV0ZSB0aGlzLmdldDtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBIb29rIG5lZWRlZDsgcmVkZWZpbmUgaXQgc28gdGhhdCB0aGUgc3VwcG9ydCB0ZXN0IGlzIG5vdCBleGVjdXRlZCBhZ2Fpbi5cblx0XHRcdHJldHVybiAoIHRoaXMuZ2V0ID0gaG9va0ZuICkuYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApO1xuXHRcdH1cblx0fTtcbn1cblxuXG52YXJcblxuXHRcdHJhbHBoYSA9IC9hbHBoYVxcKFteKV0qXFwpL2ksXG5cdHJvcGFjaXR5ID0gL29wYWNpdHlcXHMqPVxccyooW14pXSopL2ksXG5cblx0Ly8gc3dhcHBhYmxlIGlmIGRpc3BsYXkgaXMgbm9uZSBvciBzdGFydHMgd2l0aCB0YWJsZSBleGNlcHRcblx0Ly8gXCJ0YWJsZVwiLCBcInRhYmxlLWNlbGxcIiwgb3IgXCJ0YWJsZS1jYXB0aW9uXCJcblx0Ly8gc2VlIGhlcmUgZm9yIGRpc3BsYXkgdmFsdWVzOlxuXHQvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL0NTUy9kaXNwbGF5XG5cdHJkaXNwbGF5c3dhcCA9IC9eKG5vbmV8dGFibGUoPyEtY1tlYV0pLispLyxcblx0cm51bXNwbGl0ID0gbmV3IFJlZ0V4cCggXCJeKFwiICsgcG51bSArIFwiKSguKikkXCIsIFwiaVwiICksXG5cblx0Y3NzU2hvdyA9IHsgcG9zaXRpb246IFwiYWJzb2x1dGVcIiwgdmlzaWJpbGl0eTogXCJoaWRkZW5cIiwgZGlzcGxheTogXCJibG9ja1wiIH0sXG5cdGNzc05vcm1hbFRyYW5zZm9ybSA9IHtcblx0XHRsZXR0ZXJTcGFjaW5nOiBcIjBcIixcblx0XHRmb250V2VpZ2h0OiBcIjQwMFwiXG5cdH0sXG5cblx0Y3NzUHJlZml4ZXMgPSBbIFwiV2Via2l0XCIsIFwiT1wiLCBcIk1velwiLCBcIm1zXCIgXSxcblx0ZW1wdHlTdHlsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiZGl2XCIgKS5zdHlsZTtcblxuXG4vLyByZXR1cm4gYSBjc3MgcHJvcGVydHkgbWFwcGVkIHRvIGEgcG90ZW50aWFsbHkgdmVuZG9yIHByZWZpeGVkIHByb3BlcnR5XG5mdW5jdGlvbiB2ZW5kb3JQcm9wTmFtZSggbmFtZSApIHtcblxuXHQvLyBzaG9ydGN1dCBmb3IgbmFtZXMgdGhhdCBhcmUgbm90IHZlbmRvciBwcmVmaXhlZFxuXHRpZiAoIG5hbWUgaW4gZW1wdHlTdHlsZSApIHtcblx0XHRyZXR1cm4gbmFtZTtcblx0fVxuXG5cdC8vIGNoZWNrIGZvciB2ZW5kb3IgcHJlZml4ZWQgbmFtZXNcblx0dmFyIGNhcE5hbWUgPSBuYW1lLmNoYXJBdCggMCApLnRvVXBwZXJDYXNlKCkgKyBuYW1lLnNsaWNlKCAxICksXG5cdFx0aSA9IGNzc1ByZWZpeGVzLmxlbmd0aDtcblxuXHR3aGlsZSAoIGktLSApIHtcblx0XHRuYW1lID0gY3NzUHJlZml4ZXNbIGkgXSArIGNhcE5hbWU7XG5cdFx0aWYgKCBuYW1lIGluIGVtcHR5U3R5bGUgKSB7XG5cdFx0XHRyZXR1cm4gbmFtZTtcblx0XHR9XG5cdH1cbn1cblxuZnVuY3Rpb24gc2hvd0hpZGUoIGVsZW1lbnRzLCBzaG93ICkge1xuXHR2YXIgZGlzcGxheSwgZWxlbSwgaGlkZGVuLFxuXHRcdHZhbHVlcyA9IFtdLFxuXHRcdGluZGV4ID0gMCxcblx0XHRsZW5ndGggPSBlbGVtZW50cy5sZW5ndGg7XG5cblx0Zm9yICggOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKyApIHtcblx0XHRlbGVtID0gZWxlbWVudHNbIGluZGV4IF07XG5cdFx0aWYgKCAhZWxlbS5zdHlsZSApIHtcblx0XHRcdGNvbnRpbnVlO1xuXHRcdH1cblxuXHRcdHZhbHVlc1sgaW5kZXggXSA9IGpRdWVyeS5fZGF0YSggZWxlbSwgXCJvbGRkaXNwbGF5XCIgKTtcblx0XHRkaXNwbGF5ID0gZWxlbS5zdHlsZS5kaXNwbGF5O1xuXHRcdGlmICggc2hvdyApIHtcblxuXHRcdFx0Ly8gUmVzZXQgdGhlIGlubGluZSBkaXNwbGF5IG9mIHRoaXMgZWxlbWVudCB0byBsZWFybiBpZiBpdCBpc1xuXHRcdFx0Ly8gYmVpbmcgaGlkZGVuIGJ5IGNhc2NhZGVkIHJ1bGVzIG9yIG5vdFxuXHRcdFx0aWYgKCAhdmFsdWVzWyBpbmRleCBdICYmIGRpc3BsYXkgPT09IFwibm9uZVwiICkge1xuXHRcdFx0XHRlbGVtLnN0eWxlLmRpc3BsYXkgPSBcIlwiO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTZXQgZWxlbWVudHMgd2hpY2ggaGF2ZSBiZWVuIG92ZXJyaWRkZW4gd2l0aCBkaXNwbGF5OiBub25lXG5cdFx0XHQvLyBpbiBhIHN0eWxlc2hlZXQgdG8gd2hhdGV2ZXIgdGhlIGRlZmF1bHQgYnJvd3NlciBzdHlsZSBpc1xuXHRcdFx0Ly8gZm9yIHN1Y2ggYW4gZWxlbWVudFxuXHRcdFx0aWYgKCBlbGVtLnN0eWxlLmRpc3BsYXkgPT09IFwiXCIgJiYgaXNIaWRkZW4oIGVsZW0gKSApIHtcblx0XHRcdFx0dmFsdWVzWyBpbmRleCBdID1cblx0XHRcdFx0XHRqUXVlcnkuX2RhdGEoIGVsZW0sIFwib2xkZGlzcGxheVwiLCBkZWZhdWx0RGlzcGxheSggZWxlbS5ub2RlTmFtZSApICk7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdGhpZGRlbiA9IGlzSGlkZGVuKCBlbGVtICk7XG5cblx0XHRcdGlmICggZGlzcGxheSAmJiBkaXNwbGF5ICE9PSBcIm5vbmVcIiB8fCAhaGlkZGVuICkge1xuXHRcdFx0XHRqUXVlcnkuX2RhdGEoXG5cdFx0XHRcdFx0ZWxlbSxcblx0XHRcdFx0XHRcIm9sZGRpc3BsYXlcIixcblx0XHRcdFx0XHRoaWRkZW4gPyBkaXNwbGF5IDogalF1ZXJ5LmNzcyggZWxlbSwgXCJkaXNwbGF5XCIgKVxuXHRcdFx0XHQpO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8vIFNldCB0aGUgZGlzcGxheSBvZiBtb3N0IG9mIHRoZSBlbGVtZW50cyBpbiBhIHNlY29uZCBsb29wXG5cdC8vIHRvIGF2b2lkIHRoZSBjb25zdGFudCByZWZsb3dcblx0Zm9yICggaW5kZXggPSAwOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKyApIHtcblx0XHRlbGVtID0gZWxlbWVudHNbIGluZGV4IF07XG5cdFx0aWYgKCAhZWxlbS5zdHlsZSApIHtcblx0XHRcdGNvbnRpbnVlO1xuXHRcdH1cblx0XHRpZiAoICFzaG93IHx8IGVsZW0uc3R5bGUuZGlzcGxheSA9PT0gXCJub25lXCIgfHwgZWxlbS5zdHlsZS5kaXNwbGF5ID09PSBcIlwiICkge1xuXHRcdFx0ZWxlbS5zdHlsZS5kaXNwbGF5ID0gc2hvdyA/IHZhbHVlc1sgaW5kZXggXSB8fCBcIlwiIDogXCJub25lXCI7XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIGVsZW1lbnRzO1xufVxuXG5mdW5jdGlvbiBzZXRQb3NpdGl2ZU51bWJlciggZWxlbSwgdmFsdWUsIHN1YnRyYWN0ICkge1xuXHR2YXIgbWF0Y2hlcyA9IHJudW1zcGxpdC5leGVjKCB2YWx1ZSApO1xuXHRyZXR1cm4gbWF0Y2hlcyA/XG5cblx0XHQvLyBHdWFyZCBhZ2FpbnN0IHVuZGVmaW5lZCBcInN1YnRyYWN0XCIsIGUuZy4sIHdoZW4gdXNlZCBhcyBpbiBjc3NIb29rc1xuXHRcdE1hdGgubWF4KCAwLCBtYXRjaGVzWyAxIF0gLSAoIHN1YnRyYWN0IHx8IDAgKSApICsgKCBtYXRjaGVzWyAyIF0gfHwgXCJweFwiICkgOlxuXHRcdHZhbHVlO1xufVxuXG5mdW5jdGlvbiBhdWdtZW50V2lkdGhPckhlaWdodCggZWxlbSwgbmFtZSwgZXh0cmEsIGlzQm9yZGVyQm94LCBzdHlsZXMgKSB7XG5cdHZhciBpID0gZXh0cmEgPT09ICggaXNCb3JkZXJCb3ggPyBcImJvcmRlclwiIDogXCJjb250ZW50XCIgKSA/XG5cblx0XHQvLyBJZiB3ZSBhbHJlYWR5IGhhdmUgdGhlIHJpZ2h0IG1lYXN1cmVtZW50LCBhdm9pZCBhdWdtZW50YXRpb25cblx0XHQ0IDpcblxuXHRcdC8vIE90aGVyd2lzZSBpbml0aWFsaXplIGZvciBob3Jpem9udGFsIG9yIHZlcnRpY2FsIHByb3BlcnRpZXNcblx0XHRuYW1lID09PSBcIndpZHRoXCIgPyAxIDogMCxcblxuXHRcdHZhbCA9IDA7XG5cblx0Zm9yICggOyBpIDwgNDsgaSArPSAyICkge1xuXG5cdFx0Ly8gYm90aCBib3ggbW9kZWxzIGV4Y2x1ZGUgbWFyZ2luLCBzbyBhZGQgaXQgaWYgd2Ugd2FudCBpdFxuXHRcdGlmICggZXh0cmEgPT09IFwibWFyZ2luXCIgKSB7XG5cdFx0XHR2YWwgKz0galF1ZXJ5LmNzcyggZWxlbSwgZXh0cmEgKyBjc3NFeHBhbmRbIGkgXSwgdHJ1ZSwgc3R5bGVzICk7XG5cdFx0fVxuXG5cdFx0aWYgKCBpc0JvcmRlckJveCApIHtcblxuXHRcdFx0Ly8gYm9yZGVyLWJveCBpbmNsdWRlcyBwYWRkaW5nLCBzbyByZW1vdmUgaXQgaWYgd2Ugd2FudCBjb250ZW50XG5cdFx0XHRpZiAoIGV4dHJhID09PSBcImNvbnRlbnRcIiApIHtcblx0XHRcdFx0dmFsIC09IGpRdWVyeS5jc3MoIGVsZW0sIFwicGFkZGluZ1wiICsgY3NzRXhwYW5kWyBpIF0sIHRydWUsIHN0eWxlcyApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBhdCB0aGlzIHBvaW50LCBleHRyYSBpc24ndCBib3JkZXIgbm9yIG1hcmdpbiwgc28gcmVtb3ZlIGJvcmRlclxuXHRcdFx0aWYgKCBleHRyYSAhPT0gXCJtYXJnaW5cIiApIHtcblx0XHRcdFx0dmFsIC09IGpRdWVyeS5jc3MoIGVsZW0sIFwiYm9yZGVyXCIgKyBjc3NFeHBhbmRbIGkgXSArIFwiV2lkdGhcIiwgdHJ1ZSwgc3R5bGVzICk7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0Ly8gYXQgdGhpcyBwb2ludCwgZXh0cmEgaXNuJ3QgY29udGVudCwgc28gYWRkIHBhZGRpbmdcblx0XHRcdHZhbCArPSBqUXVlcnkuY3NzKCBlbGVtLCBcInBhZGRpbmdcIiArIGNzc0V4cGFuZFsgaSBdLCB0cnVlLCBzdHlsZXMgKTtcblxuXHRcdFx0Ly8gYXQgdGhpcyBwb2ludCwgZXh0cmEgaXNuJ3QgY29udGVudCBub3IgcGFkZGluZywgc28gYWRkIGJvcmRlclxuXHRcdFx0aWYgKCBleHRyYSAhPT0gXCJwYWRkaW5nXCIgKSB7XG5cdFx0XHRcdHZhbCArPSBqUXVlcnkuY3NzKCBlbGVtLCBcImJvcmRlclwiICsgY3NzRXhwYW5kWyBpIF0gKyBcIldpZHRoXCIsIHRydWUsIHN0eWxlcyApO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiB2YWw7XG59XG5cbmZ1bmN0aW9uIGdldFdpZHRoT3JIZWlnaHQoIGVsZW0sIG5hbWUsIGV4dHJhICkge1xuXG5cdC8vIFN0YXJ0IHdpdGggb2Zmc2V0IHByb3BlcnR5LCB3aGljaCBpcyBlcXVpdmFsZW50IHRvIHRoZSBib3JkZXItYm94IHZhbHVlXG5cdHZhciB2YWx1ZUlzQm9yZGVyQm94ID0gdHJ1ZSxcblx0XHR2YWwgPSBuYW1lID09PSBcIndpZHRoXCIgPyBlbGVtLm9mZnNldFdpZHRoIDogZWxlbS5vZmZzZXRIZWlnaHQsXG5cdFx0c3R5bGVzID0gZ2V0U3R5bGVzKCBlbGVtICksXG5cdFx0aXNCb3JkZXJCb3ggPSBzdXBwb3J0LmJveFNpemluZyAmJlxuXHRcdFx0alF1ZXJ5LmNzcyggZWxlbSwgXCJib3hTaXppbmdcIiwgZmFsc2UsIHN0eWxlcyApID09PSBcImJvcmRlci1ib3hcIjtcblxuXHQvLyBzb21lIG5vbi1odG1sIGVsZW1lbnRzIHJldHVybiB1bmRlZmluZWQgZm9yIG9mZnNldFdpZHRoLCBzbyBjaGVjayBmb3IgbnVsbC91bmRlZmluZWRcblx0Ly8gc3ZnIC0gaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9NjQ5Mjg1XG5cdC8vIE1hdGhNTCAtIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTQ5MTY2OFxuXHRpZiAoIHZhbCA8PSAwIHx8IHZhbCA9PSBudWxsICkge1xuXG5cdFx0Ly8gRmFsbCBiYWNrIHRvIGNvbXB1dGVkIHRoZW4gdW5jb21wdXRlZCBjc3MgaWYgbmVjZXNzYXJ5XG5cdFx0dmFsID0gY3VyQ1NTKCBlbGVtLCBuYW1lLCBzdHlsZXMgKTtcblx0XHRpZiAoIHZhbCA8IDAgfHwgdmFsID09IG51bGwgKSB7XG5cdFx0XHR2YWwgPSBlbGVtLnN0eWxlWyBuYW1lIF07XG5cdFx0fVxuXG5cdFx0Ly8gQ29tcHV0ZWQgdW5pdCBpcyBub3QgcGl4ZWxzLiBTdG9wIGhlcmUgYW5kIHJldHVybi5cblx0XHRpZiAoIHJudW1ub25weC50ZXN0KCB2YWwgKSApIHtcblx0XHRcdHJldHVybiB2YWw7XG5cdFx0fVxuXG5cdFx0Ly8gd2UgbmVlZCB0aGUgY2hlY2sgZm9yIHN0eWxlIGluIGNhc2UgYSBicm93c2VyIHdoaWNoIHJldHVybnMgdW5yZWxpYWJsZSB2YWx1ZXNcblx0XHQvLyBmb3IgZ2V0Q29tcHV0ZWRTdHlsZSBzaWxlbnRseSBmYWxscyBiYWNrIHRvIHRoZSByZWxpYWJsZSBlbGVtLnN0eWxlXG5cdFx0dmFsdWVJc0JvcmRlckJveCA9IGlzQm9yZGVyQm94ICYmXG5cdFx0XHQoIHN1cHBvcnQuYm94U2l6aW5nUmVsaWFibGUoKSB8fCB2YWwgPT09IGVsZW0uc3R5bGVbIG5hbWUgXSApO1xuXG5cdFx0Ly8gTm9ybWFsaXplIFwiXCIsIGF1dG8sIGFuZCBwcmVwYXJlIGZvciBleHRyYVxuXHRcdHZhbCA9IHBhcnNlRmxvYXQoIHZhbCApIHx8IDA7XG5cdH1cblxuXHQvLyB1c2UgdGhlIGFjdGl2ZSBib3gtc2l6aW5nIG1vZGVsIHRvIGFkZC9zdWJ0cmFjdCBpcnJlbGV2YW50IHN0eWxlc1xuXHRyZXR1cm4gKCB2YWwgK1xuXHRcdGF1Z21lbnRXaWR0aE9ySGVpZ2h0KFxuXHRcdFx0ZWxlbSxcblx0XHRcdG5hbWUsXG5cdFx0XHRleHRyYSB8fCAoIGlzQm9yZGVyQm94ID8gXCJib3JkZXJcIiA6IFwiY29udGVudFwiICksXG5cdFx0XHR2YWx1ZUlzQm9yZGVyQm94LFxuXHRcdFx0c3R5bGVzXG5cdFx0KVxuXHQpICsgXCJweFwiO1xufVxuXG5qUXVlcnkuZXh0ZW5kKCB7XG5cblx0Ly8gQWRkIGluIHN0eWxlIHByb3BlcnR5IGhvb2tzIGZvciBvdmVycmlkaW5nIHRoZSBkZWZhdWx0XG5cdC8vIGJlaGF2aW9yIG9mIGdldHRpbmcgYW5kIHNldHRpbmcgYSBzdHlsZSBwcm9wZXJ0eVxuXHRjc3NIb29rczoge1xuXHRcdG9wYWNpdHk6IHtcblx0XHRcdGdldDogZnVuY3Rpb24oIGVsZW0sIGNvbXB1dGVkICkge1xuXHRcdFx0XHRpZiAoIGNvbXB1dGVkICkge1xuXG5cdFx0XHRcdFx0Ly8gV2Ugc2hvdWxkIGFsd2F5cyBnZXQgYSBudW1iZXIgYmFjayBmcm9tIG9wYWNpdHlcblx0XHRcdFx0XHR2YXIgcmV0ID0gY3VyQ1NTKCBlbGVtLCBcIm9wYWNpdHlcIiApO1xuXHRcdFx0XHRcdHJldHVybiByZXQgPT09IFwiXCIgPyBcIjFcIiA6IHJldDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHQvLyBEb24ndCBhdXRvbWF0aWNhbGx5IGFkZCBcInB4XCIgdG8gdGhlc2UgcG9zc2libHktdW5pdGxlc3MgcHJvcGVydGllc1xuXHRjc3NOdW1iZXI6IHtcblx0XHRcImFuaW1hdGlvbkl0ZXJhdGlvbkNvdW50XCI6IHRydWUsXG5cdFx0XCJjb2x1bW5Db3VudFwiOiB0cnVlLFxuXHRcdFwiZmlsbE9wYWNpdHlcIjogdHJ1ZSxcblx0XHRcImZsZXhHcm93XCI6IHRydWUsXG5cdFx0XCJmbGV4U2hyaW5rXCI6IHRydWUsXG5cdFx0XCJmb250V2VpZ2h0XCI6IHRydWUsXG5cdFx0XCJsaW5lSGVpZ2h0XCI6IHRydWUsXG5cdFx0XCJvcGFjaXR5XCI6IHRydWUsXG5cdFx0XCJvcmRlclwiOiB0cnVlLFxuXHRcdFwib3JwaGFuc1wiOiB0cnVlLFxuXHRcdFwid2lkb3dzXCI6IHRydWUsXG5cdFx0XCJ6SW5kZXhcIjogdHJ1ZSxcblx0XHRcInpvb21cIjogdHJ1ZVxuXHR9LFxuXG5cdC8vIEFkZCBpbiBwcm9wZXJ0aWVzIHdob3NlIG5hbWVzIHlvdSB3aXNoIHRvIGZpeCBiZWZvcmVcblx0Ly8gc2V0dGluZyBvciBnZXR0aW5nIHRoZSB2YWx1ZVxuXHRjc3NQcm9wczoge1xuXG5cdFx0Ly8gbm9ybWFsaXplIGZsb2F0IGNzcyBwcm9wZXJ0eVxuXHRcdFwiZmxvYXRcIjogc3VwcG9ydC5jc3NGbG9hdCA/IFwiY3NzRmxvYXRcIiA6IFwic3R5bGVGbG9hdFwiXG5cdH0sXG5cblx0Ly8gR2V0IGFuZCBzZXQgdGhlIHN0eWxlIHByb3BlcnR5IG9uIGEgRE9NIE5vZGVcblx0c3R5bGU6IGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCB2YWx1ZSwgZXh0cmEgKSB7XG5cblx0XHQvLyBEb24ndCBzZXQgc3R5bGVzIG9uIHRleHQgYW5kIGNvbW1lbnQgbm9kZXNcblx0XHRpZiAoICFlbGVtIHx8IGVsZW0ubm9kZVR5cGUgPT09IDMgfHwgZWxlbS5ub2RlVHlwZSA9PT0gOCB8fCAhZWxlbS5zdHlsZSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBNYWtlIHN1cmUgdGhhdCB3ZSdyZSB3b3JraW5nIHdpdGggdGhlIHJpZ2h0IG5hbWVcblx0XHR2YXIgcmV0LCB0eXBlLCBob29rcyxcblx0XHRcdG9yaWdOYW1lID0galF1ZXJ5LmNhbWVsQ2FzZSggbmFtZSApLFxuXHRcdFx0c3R5bGUgPSBlbGVtLnN0eWxlO1xuXG5cdFx0bmFtZSA9IGpRdWVyeS5jc3NQcm9wc1sgb3JpZ05hbWUgXSB8fFxuXHRcdFx0KCBqUXVlcnkuY3NzUHJvcHNbIG9yaWdOYW1lIF0gPSB2ZW5kb3JQcm9wTmFtZSggb3JpZ05hbWUgKSB8fCBvcmlnTmFtZSApO1xuXG5cdFx0Ly8gZ2V0cyBob29rIGZvciB0aGUgcHJlZml4ZWQgdmVyc2lvblxuXHRcdC8vIGZvbGxvd2VkIGJ5IHRoZSB1bnByZWZpeGVkIHZlcnNpb25cblx0XHRob29rcyA9IGpRdWVyeS5jc3NIb29rc1sgbmFtZSBdIHx8IGpRdWVyeS5jc3NIb29rc1sgb3JpZ05hbWUgXTtcblxuXHRcdC8vIENoZWNrIGlmIHdlJ3JlIHNldHRpbmcgYSB2YWx1ZVxuXHRcdGlmICggdmFsdWUgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdHR5cGUgPSB0eXBlb2YgdmFsdWU7XG5cblx0XHRcdC8vIENvbnZlcnQgXCIrPVwiIG9yIFwiLT1cIiB0byByZWxhdGl2ZSBudW1iZXJzICgjNzM0NSlcblx0XHRcdGlmICggdHlwZSA9PT0gXCJzdHJpbmdcIiAmJiAoIHJldCA9IHJjc3NOdW0uZXhlYyggdmFsdWUgKSApICYmIHJldFsgMSBdICkge1xuXHRcdFx0XHR2YWx1ZSA9IGFkanVzdENTUyggZWxlbSwgbmFtZSwgcmV0ICk7XG5cblx0XHRcdFx0Ly8gRml4ZXMgYnVnICM5MjM3XG5cdFx0XHRcdHR5cGUgPSBcIm51bWJlclwiO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBNYWtlIHN1cmUgdGhhdCBudWxsIGFuZCBOYU4gdmFsdWVzIGFyZW4ndCBzZXQuIFNlZTogIzcxMTZcblx0XHRcdGlmICggdmFsdWUgPT0gbnVsbCB8fCB2YWx1ZSAhPT0gdmFsdWUgKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gSWYgYSBudW1iZXIgd2FzIHBhc3NlZCBpbiwgYWRkIHRoZSB1bml0IChleGNlcHQgZm9yIGNlcnRhaW4gQ1NTIHByb3BlcnRpZXMpXG5cdFx0XHRpZiAoIHR5cGUgPT09IFwibnVtYmVyXCIgKSB7XG5cdFx0XHRcdHZhbHVlICs9IHJldCAmJiByZXRbIDMgXSB8fCAoIGpRdWVyeS5jc3NOdW1iZXJbIG9yaWdOYW1lIF0gPyBcIlwiIDogXCJweFwiICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEZpeGVzICM4OTA4LCBpdCBjYW4gYmUgZG9uZSBtb3JlIGNvcnJlY3RseSBieSBzcGVjaWZpbmcgc2V0dGVycyBpbiBjc3NIb29rcyxcblx0XHRcdC8vIGJ1dCBpdCB3b3VsZCBtZWFuIHRvIGRlZmluZSBlaWdodFxuXHRcdFx0Ly8gKGZvciBldmVyeSBwcm9ibGVtYXRpYyBwcm9wZXJ0eSkgaWRlbnRpY2FsIGZ1bmN0aW9uc1xuXHRcdFx0aWYgKCAhc3VwcG9ydC5jbGVhckNsb25lU3R5bGUgJiYgdmFsdWUgPT09IFwiXCIgJiYgbmFtZS5pbmRleE9mKCBcImJhY2tncm91bmRcIiApID09PSAwICkge1xuXHRcdFx0XHRzdHlsZVsgbmFtZSBdID0gXCJpbmhlcml0XCI7XG5cdFx0XHR9XG5cblx0XHRcdC8vIElmIGEgaG9vayB3YXMgcHJvdmlkZWQsIHVzZSB0aGF0IHZhbHVlLCBvdGhlcndpc2UganVzdCBzZXQgdGhlIHNwZWNpZmllZCB2YWx1ZVxuXHRcdFx0aWYgKCAhaG9va3MgfHwgISggXCJzZXRcIiBpbiBob29rcyApIHx8XG5cdFx0XHRcdCggdmFsdWUgPSBob29rcy5zZXQoIGVsZW0sIHZhbHVlLCBleHRyYSApICkgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHQvLyBTdXBwb3J0OiBJRVxuXHRcdFx0XHQvLyBTd2FsbG93IGVycm9ycyBmcm9tICdpbnZhbGlkJyBDU1MgdmFsdWVzICgjNTUwOSlcblx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRzdHlsZVsgbmFtZSBdID0gdmFsdWU7XG5cdFx0XHRcdH0gY2F0Y2ggKCBlICkge31cblx0XHRcdH1cblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdC8vIElmIGEgaG9vayB3YXMgcHJvdmlkZWQgZ2V0IHRoZSBub24tY29tcHV0ZWQgdmFsdWUgZnJvbSB0aGVyZVxuXHRcdFx0aWYgKCBob29rcyAmJiBcImdldFwiIGluIGhvb2tzICYmXG5cdFx0XHRcdCggcmV0ID0gaG9va3MuZ2V0KCBlbGVtLCBmYWxzZSwgZXh0cmEgKSApICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0cmV0dXJuIHJldDtcblx0XHRcdH1cblxuXHRcdFx0Ly8gT3RoZXJ3aXNlIGp1c3QgZ2V0IHRoZSB2YWx1ZSBmcm9tIHRoZSBzdHlsZSBvYmplY3Rcblx0XHRcdHJldHVybiBzdHlsZVsgbmFtZSBdO1xuXHRcdH1cblx0fSxcblxuXHRjc3M6IGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCBleHRyYSwgc3R5bGVzICkge1xuXHRcdHZhciBudW0sIHZhbCwgaG9va3MsXG5cdFx0XHRvcmlnTmFtZSA9IGpRdWVyeS5jYW1lbENhc2UoIG5hbWUgKTtcblxuXHRcdC8vIE1ha2Ugc3VyZSB0aGF0IHdlJ3JlIHdvcmtpbmcgd2l0aCB0aGUgcmlnaHQgbmFtZVxuXHRcdG5hbWUgPSBqUXVlcnkuY3NzUHJvcHNbIG9yaWdOYW1lIF0gfHxcblx0XHRcdCggalF1ZXJ5LmNzc1Byb3BzWyBvcmlnTmFtZSBdID0gdmVuZG9yUHJvcE5hbWUoIG9yaWdOYW1lICkgfHwgb3JpZ05hbWUgKTtcblxuXHRcdC8vIGdldHMgaG9vayBmb3IgdGhlIHByZWZpeGVkIHZlcnNpb25cblx0XHQvLyBmb2xsb3dlZCBieSB0aGUgdW5wcmVmaXhlZCB2ZXJzaW9uXG5cdFx0aG9va3MgPSBqUXVlcnkuY3NzSG9va3NbIG5hbWUgXSB8fCBqUXVlcnkuY3NzSG9va3NbIG9yaWdOYW1lIF07XG5cblx0XHQvLyBJZiBhIGhvb2sgd2FzIHByb3ZpZGVkIGdldCB0aGUgY29tcHV0ZWQgdmFsdWUgZnJvbSB0aGVyZVxuXHRcdGlmICggaG9va3MgJiYgXCJnZXRcIiBpbiBob29rcyApIHtcblx0XHRcdHZhbCA9IGhvb2tzLmdldCggZWxlbSwgdHJ1ZSwgZXh0cmEgKTtcblx0XHR9XG5cblx0XHQvLyBPdGhlcndpc2UsIGlmIGEgd2F5IHRvIGdldCB0aGUgY29tcHV0ZWQgdmFsdWUgZXhpc3RzLCB1c2UgdGhhdFxuXHRcdGlmICggdmFsID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHR2YWwgPSBjdXJDU1MoIGVsZW0sIG5hbWUsIHN0eWxlcyApO1xuXHRcdH1cblxuXHRcdC8vY29udmVydCBcIm5vcm1hbFwiIHRvIGNvbXB1dGVkIHZhbHVlXG5cdFx0aWYgKCB2YWwgPT09IFwibm9ybWFsXCIgJiYgbmFtZSBpbiBjc3NOb3JtYWxUcmFuc2Zvcm0gKSB7XG5cdFx0XHR2YWwgPSBjc3NOb3JtYWxUcmFuc2Zvcm1bIG5hbWUgXTtcblx0XHR9XG5cblx0XHQvLyBSZXR1cm4sIGNvbnZlcnRpbmcgdG8gbnVtYmVyIGlmIGZvcmNlZCBvciBhIHF1YWxpZmllciB3YXMgcHJvdmlkZWQgYW5kIHZhbCBsb29rcyBudW1lcmljXG5cdFx0aWYgKCBleHRyYSA9PT0gXCJcIiB8fCBleHRyYSApIHtcblx0XHRcdG51bSA9IHBhcnNlRmxvYXQoIHZhbCApO1xuXHRcdFx0cmV0dXJuIGV4dHJhID09PSB0cnVlIHx8IGlzRmluaXRlKCBudW0gKSA/IG51bSB8fCAwIDogdmFsO1xuXHRcdH1cblx0XHRyZXR1cm4gdmFsO1xuXHR9XG59ICk7XG5cbmpRdWVyeS5lYWNoKCBbIFwiaGVpZ2h0XCIsIFwid2lkdGhcIiBdLCBmdW5jdGlvbiggaSwgbmFtZSApIHtcblx0alF1ZXJ5LmNzc0hvb2tzWyBuYW1lIF0gPSB7XG5cdFx0Z2V0OiBmdW5jdGlvbiggZWxlbSwgY29tcHV0ZWQsIGV4dHJhICkge1xuXHRcdFx0aWYgKCBjb21wdXRlZCApIHtcblxuXHRcdFx0XHQvLyBjZXJ0YWluIGVsZW1lbnRzIGNhbiBoYXZlIGRpbWVuc2lvbiBpbmZvIGlmIHdlIGludmlzaWJseSBzaG93IHRoZW1cblx0XHRcdFx0Ly8gaG93ZXZlciwgaXQgbXVzdCBoYXZlIGEgY3VycmVudCBkaXNwbGF5IHN0eWxlIHRoYXQgd291bGQgYmVuZWZpdCBmcm9tIHRoaXNcblx0XHRcdFx0cmV0dXJuIHJkaXNwbGF5c3dhcC50ZXN0KCBqUXVlcnkuY3NzKCBlbGVtLCBcImRpc3BsYXlcIiApICkgJiZcblx0XHRcdFx0XHRlbGVtLm9mZnNldFdpZHRoID09PSAwID9cblx0XHRcdFx0XHRcdHN3YXAoIGVsZW0sIGNzc1Nob3csIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gZ2V0V2lkdGhPckhlaWdodCggZWxlbSwgbmFtZSwgZXh0cmEgKTtcblx0XHRcdFx0XHRcdH0gKSA6XG5cdFx0XHRcdFx0XHRnZXRXaWR0aE9ySGVpZ2h0KCBlbGVtLCBuYW1lLCBleHRyYSApO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHRzZXQ6IGZ1bmN0aW9uKCBlbGVtLCB2YWx1ZSwgZXh0cmEgKSB7XG5cdFx0XHR2YXIgc3R5bGVzID0gZXh0cmEgJiYgZ2V0U3R5bGVzKCBlbGVtICk7XG5cdFx0XHRyZXR1cm4gc2V0UG9zaXRpdmVOdW1iZXIoIGVsZW0sIHZhbHVlLCBleHRyYSA/XG5cdFx0XHRcdGF1Z21lbnRXaWR0aE9ySGVpZ2h0KFxuXHRcdFx0XHRcdGVsZW0sXG5cdFx0XHRcdFx0bmFtZSxcblx0XHRcdFx0XHRleHRyYSxcblx0XHRcdFx0XHRzdXBwb3J0LmJveFNpemluZyAmJlxuXHRcdFx0XHRcdFx0alF1ZXJ5LmNzcyggZWxlbSwgXCJib3hTaXppbmdcIiwgZmFsc2UsIHN0eWxlcyApID09PSBcImJvcmRlci1ib3hcIixcblx0XHRcdFx0XHRzdHlsZXNcblx0XHRcdFx0KSA6IDBcblx0XHRcdCk7XG5cdFx0fVxuXHR9O1xufSApO1xuXG5pZiAoICFzdXBwb3J0Lm9wYWNpdHkgKSB7XG5cdGpRdWVyeS5jc3NIb29rcy5vcGFjaXR5ID0ge1xuXHRcdGdldDogZnVuY3Rpb24oIGVsZW0sIGNvbXB1dGVkICkge1xuXG5cdFx0XHQvLyBJRSB1c2VzIGZpbHRlcnMgZm9yIG9wYWNpdHlcblx0XHRcdHJldHVybiByb3BhY2l0eS50ZXN0KCAoIGNvbXB1dGVkICYmIGVsZW0uY3VycmVudFN0eWxlID9cblx0XHRcdFx0ZWxlbS5jdXJyZW50U3R5bGUuZmlsdGVyIDpcblx0XHRcdFx0ZWxlbS5zdHlsZS5maWx0ZXIgKSB8fCBcIlwiICkgP1xuXHRcdFx0XHRcdCggMC4wMSAqIHBhcnNlRmxvYXQoIFJlZ0V4cC4kMSApICkgKyBcIlwiIDpcblx0XHRcdFx0XHRjb21wdXRlZCA/IFwiMVwiIDogXCJcIjtcblx0XHR9LFxuXG5cdFx0c2V0OiBmdW5jdGlvbiggZWxlbSwgdmFsdWUgKSB7XG5cdFx0XHR2YXIgc3R5bGUgPSBlbGVtLnN0eWxlLFxuXHRcdFx0XHRjdXJyZW50U3R5bGUgPSBlbGVtLmN1cnJlbnRTdHlsZSxcblx0XHRcdFx0b3BhY2l0eSA9IGpRdWVyeS5pc051bWVyaWMoIHZhbHVlICkgPyBcImFscGhhKG9wYWNpdHk9XCIgKyB2YWx1ZSAqIDEwMCArIFwiKVwiIDogXCJcIixcblx0XHRcdFx0ZmlsdGVyID0gY3VycmVudFN0eWxlICYmIGN1cnJlbnRTdHlsZS5maWx0ZXIgfHwgc3R5bGUuZmlsdGVyIHx8IFwiXCI7XG5cblx0XHRcdC8vIElFIGhhcyB0cm91YmxlIHdpdGggb3BhY2l0eSBpZiBpdCBkb2VzIG5vdCBoYXZlIGxheW91dFxuXHRcdFx0Ly8gRm9yY2UgaXQgYnkgc2V0dGluZyB0aGUgem9vbSBsZXZlbFxuXHRcdFx0c3R5bGUuem9vbSA9IDE7XG5cblx0XHRcdC8vIGlmIHNldHRpbmcgb3BhY2l0eSB0byAxLCBhbmQgbm8gb3RoZXIgZmlsdGVycyBleGlzdCAtXG5cdFx0XHQvLyBhdHRlbXB0IHRvIHJlbW92ZSBmaWx0ZXIgYXR0cmlidXRlICM2NjUyXG5cdFx0XHQvLyBpZiB2YWx1ZSA9PT0gXCJcIiwgdGhlbiByZW1vdmUgaW5saW5lIG9wYWNpdHkgIzEyNjg1XG5cdFx0XHRpZiAoICggdmFsdWUgPj0gMSB8fCB2YWx1ZSA9PT0gXCJcIiApICYmXG5cdFx0XHRcdFx0alF1ZXJ5LnRyaW0oIGZpbHRlci5yZXBsYWNlKCByYWxwaGEsIFwiXCIgKSApID09PSBcIlwiICYmXG5cdFx0XHRcdFx0c3R5bGUucmVtb3ZlQXR0cmlidXRlICkge1xuXG5cdFx0XHRcdC8vIFNldHRpbmcgc3R5bGUuZmlsdGVyIHRvIG51bGwsIFwiXCIgJiBcIiBcIiBzdGlsbCBsZWF2ZSBcImZpbHRlcjpcIiBpbiB0aGUgY3NzVGV4dFxuXHRcdFx0XHQvLyBpZiBcImZpbHRlcjpcIiBpcyBwcmVzZW50IGF0IGFsbCwgY2xlYXJUeXBlIGlzIGRpc2FibGVkLCB3ZSB3YW50IHRvIGF2b2lkIHRoaXNcblx0XHRcdFx0Ly8gc3R5bGUucmVtb3ZlQXR0cmlidXRlIGlzIElFIE9ubHksIGJ1dCBzbyBhcHBhcmVudGx5IGlzIHRoaXMgY29kZSBwYXRoLi4uXG5cdFx0XHRcdHN0eWxlLnJlbW92ZUF0dHJpYnV0ZSggXCJmaWx0ZXJcIiApO1xuXG5cdFx0XHRcdC8vIGlmIHRoZXJlIGlzIG5vIGZpbHRlciBzdHlsZSBhcHBsaWVkIGluIGEgY3NzIHJ1bGVcblx0XHRcdFx0Ly8gb3IgdW5zZXQgaW5saW5lIG9wYWNpdHksIHdlIGFyZSBkb25lXG5cdFx0XHRcdGlmICggdmFsdWUgPT09IFwiXCIgfHwgY3VycmVudFN0eWxlICYmICFjdXJyZW50U3R5bGUuZmlsdGVyICkge1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBvdGhlcndpc2UsIHNldCBuZXcgZmlsdGVyIHZhbHVlc1xuXHRcdFx0c3R5bGUuZmlsdGVyID0gcmFscGhhLnRlc3QoIGZpbHRlciApID9cblx0XHRcdFx0ZmlsdGVyLnJlcGxhY2UoIHJhbHBoYSwgb3BhY2l0eSApIDpcblx0XHRcdFx0ZmlsdGVyICsgXCIgXCIgKyBvcGFjaXR5O1xuXHRcdH1cblx0fTtcbn1cblxualF1ZXJ5LmNzc0hvb2tzLm1hcmdpblJpZ2h0ID0gYWRkR2V0SG9va0lmKCBzdXBwb3J0LnJlbGlhYmxlTWFyZ2luUmlnaHQsXG5cdGZ1bmN0aW9uKCBlbGVtLCBjb21wdXRlZCApIHtcblx0XHRpZiAoIGNvbXB1dGVkICkge1xuXHRcdFx0cmV0dXJuIHN3YXAoIGVsZW0sIHsgXCJkaXNwbGF5XCI6IFwiaW5saW5lLWJsb2NrXCIgfSxcblx0XHRcdFx0Y3VyQ1NTLCBbIGVsZW0sIFwibWFyZ2luUmlnaHRcIiBdICk7XG5cdFx0fVxuXHR9XG4pO1xuXG5qUXVlcnkuY3NzSG9va3MubWFyZ2luTGVmdCA9IGFkZEdldEhvb2tJZiggc3VwcG9ydC5yZWxpYWJsZU1hcmdpbkxlZnQsXG5cdGZ1bmN0aW9uKCBlbGVtLCBjb21wdXRlZCApIHtcblx0XHRpZiAoIGNvbXB1dGVkICkge1xuXHRcdFx0cmV0dXJuIChcblx0XHRcdFx0cGFyc2VGbG9hdCggY3VyQ1NTKCBlbGVtLCBcIm1hcmdpbkxlZnRcIiApICkgfHxcblxuXHRcdFx0XHQvLyBTdXBwb3J0OiBJRTw9MTErXG5cdFx0XHRcdC8vIFJ1bm5pbmcgZ2V0Qm91bmRpbmdDbGllbnRSZWN0IG9uIGEgZGlzY29ubmVjdGVkIG5vZGUgaW4gSUUgdGhyb3dzIGFuIGVycm9yXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IElFOCBvbmx5XG5cdFx0XHRcdC8vIGdldENsaWVudFJlY3RzKCkgZXJyb3JzIG9uIGRpc2Nvbm5lY3RlZCBlbGVtc1xuXHRcdFx0XHQoIGpRdWVyeS5jb250YWlucyggZWxlbS5vd25lckRvY3VtZW50LCBlbGVtICkgP1xuXHRcdFx0XHRcdGVsZW0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkubGVmdCAtXG5cdFx0XHRcdFx0XHRzd2FwKCBlbGVtLCB7IG1hcmdpbkxlZnQ6IDAgfSwgZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiBlbGVtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmxlZnQ7XG5cdFx0XHRcdFx0XHR9ICkgOlxuXHRcdFx0XHRcdDBcblx0XHRcdFx0KVxuXHRcdFx0KSArIFwicHhcIjtcblx0XHR9XG5cdH1cbik7XG5cbi8vIFRoZXNlIGhvb2tzIGFyZSB1c2VkIGJ5IGFuaW1hdGUgdG8gZXhwYW5kIHByb3BlcnRpZXNcbmpRdWVyeS5lYWNoKCB7XG5cdG1hcmdpbjogXCJcIixcblx0cGFkZGluZzogXCJcIixcblx0Ym9yZGVyOiBcIldpZHRoXCJcbn0sIGZ1bmN0aW9uKCBwcmVmaXgsIHN1ZmZpeCApIHtcblx0alF1ZXJ5LmNzc0hvb2tzWyBwcmVmaXggKyBzdWZmaXggXSA9IHtcblx0XHRleHBhbmQ6IGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHRcdHZhciBpID0gMCxcblx0XHRcdFx0ZXhwYW5kZWQgPSB7fSxcblxuXHRcdFx0XHQvLyBhc3N1bWVzIGEgc2luZ2xlIG51bWJlciBpZiBub3QgYSBzdHJpbmdcblx0XHRcdFx0cGFydHMgPSB0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgPyB2YWx1ZS5zcGxpdCggXCIgXCIgKSA6IFsgdmFsdWUgXTtcblxuXHRcdFx0Zm9yICggOyBpIDwgNDsgaSsrICkge1xuXHRcdFx0XHRleHBhbmRlZFsgcHJlZml4ICsgY3NzRXhwYW5kWyBpIF0gKyBzdWZmaXggXSA9XG5cdFx0XHRcdFx0cGFydHNbIGkgXSB8fCBwYXJ0c1sgaSAtIDIgXSB8fCBwYXJ0c1sgMCBdO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZXhwYW5kZWQ7XG5cdFx0fVxuXHR9O1xuXG5cdGlmICggIXJtYXJnaW4udGVzdCggcHJlZml4ICkgKSB7XG5cdFx0alF1ZXJ5LmNzc0hvb2tzWyBwcmVmaXggKyBzdWZmaXggXS5zZXQgPSBzZXRQb3NpdGl2ZU51bWJlcjtcblx0fVxufSApO1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdGNzczogZnVuY3Rpb24oIG5hbWUsIHZhbHVlICkge1xuXHRcdHJldHVybiBhY2Nlc3MoIHRoaXMsIGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCB2YWx1ZSApIHtcblx0XHRcdHZhciBzdHlsZXMsIGxlbixcblx0XHRcdFx0bWFwID0ge30sXG5cdFx0XHRcdGkgPSAwO1xuXG5cdFx0XHRpZiAoIGpRdWVyeS5pc0FycmF5KCBuYW1lICkgKSB7XG5cdFx0XHRcdHN0eWxlcyA9IGdldFN0eWxlcyggZWxlbSApO1xuXHRcdFx0XHRsZW4gPSBuYW1lLmxlbmd0aDtcblxuXHRcdFx0XHRmb3IgKCA7IGkgPCBsZW47IGkrKyApIHtcblx0XHRcdFx0XHRtYXBbIG5hbWVbIGkgXSBdID0galF1ZXJ5LmNzcyggZWxlbSwgbmFtZVsgaSBdLCBmYWxzZSwgc3R5bGVzICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gbWFwO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdmFsdWUgIT09IHVuZGVmaW5lZCA/XG5cdFx0XHRcdGpRdWVyeS5zdHlsZSggZWxlbSwgbmFtZSwgdmFsdWUgKSA6XG5cdFx0XHRcdGpRdWVyeS5jc3MoIGVsZW0sIG5hbWUgKTtcblx0XHR9LCBuYW1lLCB2YWx1ZSwgYXJndW1lbnRzLmxlbmd0aCA+IDEgKTtcblx0fSxcblx0c2hvdzogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHNob3dIaWRlKCB0aGlzLCB0cnVlICk7XG5cdH0sXG5cdGhpZGU6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBzaG93SGlkZSggdGhpcyApO1xuXHR9LFxuXHR0b2dnbGU6IGZ1bmN0aW9uKCBzdGF0ZSApIHtcblx0XHRpZiAoIHR5cGVvZiBzdGF0ZSA9PT0gXCJib29sZWFuXCIgKSB7XG5cdFx0XHRyZXR1cm4gc3RhdGUgPyB0aGlzLnNob3coKSA6IHRoaXMuaGlkZSgpO1xuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0aWYgKCBpc0hpZGRlbiggdGhpcyApICkge1xuXHRcdFx0XHRqUXVlcnkoIHRoaXMgKS5zaG93KCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRqUXVlcnkoIHRoaXMgKS5oaWRlKCk7XG5cdFx0XHR9XG5cdFx0fSApO1xuXHR9XG59ICk7XG5cblxuZnVuY3Rpb24gVHdlZW4oIGVsZW0sIG9wdGlvbnMsIHByb3AsIGVuZCwgZWFzaW5nICkge1xuXHRyZXR1cm4gbmV3IFR3ZWVuLnByb3RvdHlwZS5pbml0KCBlbGVtLCBvcHRpb25zLCBwcm9wLCBlbmQsIGVhc2luZyApO1xufVxualF1ZXJ5LlR3ZWVuID0gVHdlZW47XG5cblR3ZWVuLnByb3RvdHlwZSA9IHtcblx0Y29uc3RydWN0b3I6IFR3ZWVuLFxuXHRpbml0OiBmdW5jdGlvbiggZWxlbSwgb3B0aW9ucywgcHJvcCwgZW5kLCBlYXNpbmcsIHVuaXQgKSB7XG5cdFx0dGhpcy5lbGVtID0gZWxlbTtcblx0XHR0aGlzLnByb3AgPSBwcm9wO1xuXHRcdHRoaXMuZWFzaW5nID0gZWFzaW5nIHx8IGpRdWVyeS5lYXNpbmcuX2RlZmF1bHQ7XG5cdFx0dGhpcy5vcHRpb25zID0gb3B0aW9ucztcblx0XHR0aGlzLnN0YXJ0ID0gdGhpcy5ub3cgPSB0aGlzLmN1cigpO1xuXHRcdHRoaXMuZW5kID0gZW5kO1xuXHRcdHRoaXMudW5pdCA9IHVuaXQgfHwgKCBqUXVlcnkuY3NzTnVtYmVyWyBwcm9wIF0gPyBcIlwiIDogXCJweFwiICk7XG5cdH0sXG5cdGN1cjogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGhvb2tzID0gVHdlZW4ucHJvcEhvb2tzWyB0aGlzLnByb3AgXTtcblxuXHRcdHJldHVybiBob29rcyAmJiBob29rcy5nZXQgP1xuXHRcdFx0aG9va3MuZ2V0KCB0aGlzICkgOlxuXHRcdFx0VHdlZW4ucHJvcEhvb2tzLl9kZWZhdWx0LmdldCggdGhpcyApO1xuXHR9LFxuXHRydW46IGZ1bmN0aW9uKCBwZXJjZW50ICkge1xuXHRcdHZhciBlYXNlZCxcblx0XHRcdGhvb2tzID0gVHdlZW4ucHJvcEhvb2tzWyB0aGlzLnByb3AgXTtcblxuXHRcdGlmICggdGhpcy5vcHRpb25zLmR1cmF0aW9uICkge1xuXHRcdFx0dGhpcy5wb3MgPSBlYXNlZCA9IGpRdWVyeS5lYXNpbmdbIHRoaXMuZWFzaW5nIF0oXG5cdFx0XHRcdHBlcmNlbnQsIHRoaXMub3B0aW9ucy5kdXJhdGlvbiAqIHBlcmNlbnQsIDAsIDEsIHRoaXMub3B0aW9ucy5kdXJhdGlvblxuXHRcdFx0KTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5wb3MgPSBlYXNlZCA9IHBlcmNlbnQ7XG5cdFx0fVxuXHRcdHRoaXMubm93ID0gKCB0aGlzLmVuZCAtIHRoaXMuc3RhcnQgKSAqIGVhc2VkICsgdGhpcy5zdGFydDtcblxuXHRcdGlmICggdGhpcy5vcHRpb25zLnN0ZXAgKSB7XG5cdFx0XHR0aGlzLm9wdGlvbnMuc3RlcC5jYWxsKCB0aGlzLmVsZW0sIHRoaXMubm93LCB0aGlzICk7XG5cdFx0fVxuXG5cdFx0aWYgKCBob29rcyAmJiBob29rcy5zZXQgKSB7XG5cdFx0XHRob29rcy5zZXQoIHRoaXMgKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0VHdlZW4ucHJvcEhvb2tzLl9kZWZhdWx0LnNldCggdGhpcyApO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcztcblx0fVxufTtcblxuVHdlZW4ucHJvdG90eXBlLmluaXQucHJvdG90eXBlID0gVHdlZW4ucHJvdG90eXBlO1xuXG5Ud2Vlbi5wcm9wSG9va3MgPSB7XG5cdF9kZWZhdWx0OiB7XG5cdFx0Z2V0OiBmdW5jdGlvbiggdHdlZW4gKSB7XG5cdFx0XHR2YXIgcmVzdWx0O1xuXG5cdFx0XHQvLyBVc2UgYSBwcm9wZXJ0eSBvbiB0aGUgZWxlbWVudCBkaXJlY3RseSB3aGVuIGl0IGlzIG5vdCBhIERPTSBlbGVtZW50LFxuXHRcdFx0Ly8gb3Igd2hlbiB0aGVyZSBpcyBubyBtYXRjaGluZyBzdHlsZSBwcm9wZXJ0eSB0aGF0IGV4aXN0cy5cblx0XHRcdGlmICggdHdlZW4uZWxlbS5ub2RlVHlwZSAhPT0gMSB8fFxuXHRcdFx0XHR0d2Vlbi5lbGVtWyB0d2Vlbi5wcm9wIF0gIT0gbnVsbCAmJiB0d2Vlbi5lbGVtLnN0eWxlWyB0d2Vlbi5wcm9wIF0gPT0gbnVsbCApIHtcblx0XHRcdFx0cmV0dXJuIHR3ZWVuLmVsZW1bIHR3ZWVuLnByb3AgXTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gcGFzc2luZyBhbiBlbXB0eSBzdHJpbmcgYXMgYSAzcmQgcGFyYW1ldGVyIHRvIC5jc3Mgd2lsbCBhdXRvbWF0aWNhbGx5XG5cdFx0XHQvLyBhdHRlbXB0IGEgcGFyc2VGbG9hdCBhbmQgZmFsbGJhY2sgdG8gYSBzdHJpbmcgaWYgdGhlIHBhcnNlIGZhaWxzXG5cdFx0XHQvLyBzbywgc2ltcGxlIHZhbHVlcyBzdWNoIGFzIFwiMTBweFwiIGFyZSBwYXJzZWQgdG8gRmxvYXQuXG5cdFx0XHQvLyBjb21wbGV4IHZhbHVlcyBzdWNoIGFzIFwicm90YXRlKDFyYWQpXCIgYXJlIHJldHVybmVkIGFzIGlzLlxuXHRcdFx0cmVzdWx0ID0galF1ZXJ5LmNzcyggdHdlZW4uZWxlbSwgdHdlZW4ucHJvcCwgXCJcIiApO1xuXG5cdFx0XHQvLyBFbXB0eSBzdHJpbmdzLCBudWxsLCB1bmRlZmluZWQgYW5kIFwiYXV0b1wiIGFyZSBjb252ZXJ0ZWQgdG8gMC5cblx0XHRcdHJldHVybiAhcmVzdWx0IHx8IHJlc3VsdCA9PT0gXCJhdXRvXCIgPyAwIDogcmVzdWx0O1xuXHRcdH0sXG5cdFx0c2V0OiBmdW5jdGlvbiggdHdlZW4gKSB7XG5cblx0XHRcdC8vIHVzZSBzdGVwIGhvb2sgZm9yIGJhY2sgY29tcGF0IC0gdXNlIGNzc0hvb2sgaWYgaXRzIHRoZXJlIC0gdXNlIC5zdHlsZSBpZiBpdHNcblx0XHRcdC8vIGF2YWlsYWJsZSBhbmQgdXNlIHBsYWluIHByb3BlcnRpZXMgd2hlcmUgYXZhaWxhYmxlXG5cdFx0XHRpZiAoIGpRdWVyeS5meC5zdGVwWyB0d2Vlbi5wcm9wIF0gKSB7XG5cdFx0XHRcdGpRdWVyeS5meC5zdGVwWyB0d2Vlbi5wcm9wIF0oIHR3ZWVuICk7XG5cdFx0XHR9IGVsc2UgaWYgKCB0d2Vlbi5lbGVtLm5vZGVUeXBlID09PSAxICYmXG5cdFx0XHRcdCggdHdlZW4uZWxlbS5zdHlsZVsgalF1ZXJ5LmNzc1Byb3BzWyB0d2Vlbi5wcm9wIF0gXSAhPSBudWxsIHx8XG5cdFx0XHRcdFx0alF1ZXJ5LmNzc0hvb2tzWyB0d2Vlbi5wcm9wIF0gKSApIHtcblx0XHRcdFx0alF1ZXJ5LnN0eWxlKCB0d2Vlbi5lbGVtLCB0d2Vlbi5wcm9wLCB0d2Vlbi5ub3cgKyB0d2Vlbi51bml0ICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0d2Vlbi5lbGVtWyB0d2Vlbi5wcm9wIF0gPSB0d2Vlbi5ub3c7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG59O1xuXG4vLyBTdXBwb3J0OiBJRSA8PTlcbi8vIFBhbmljIGJhc2VkIGFwcHJvYWNoIHRvIHNldHRpbmcgdGhpbmdzIG9uIGRpc2Nvbm5lY3RlZCBub2Rlc1xuXG5Ud2Vlbi5wcm9wSG9va3Muc2Nyb2xsVG9wID0gVHdlZW4ucHJvcEhvb2tzLnNjcm9sbExlZnQgPSB7XG5cdHNldDogZnVuY3Rpb24oIHR3ZWVuICkge1xuXHRcdGlmICggdHdlZW4uZWxlbS5ub2RlVHlwZSAmJiB0d2Vlbi5lbGVtLnBhcmVudE5vZGUgKSB7XG5cdFx0XHR0d2Vlbi5lbGVtWyB0d2Vlbi5wcm9wIF0gPSB0d2Vlbi5ub3c7XG5cdFx0fVxuXHR9XG59O1xuXG5qUXVlcnkuZWFzaW5nID0ge1xuXHRsaW5lYXI6IGZ1bmN0aW9uKCBwICkge1xuXHRcdHJldHVybiBwO1xuXHR9LFxuXHRzd2luZzogZnVuY3Rpb24oIHAgKSB7XG5cdFx0cmV0dXJuIDAuNSAtIE1hdGguY29zKCBwICogTWF0aC5QSSApIC8gMjtcblx0fSxcblx0X2RlZmF1bHQ6IFwic3dpbmdcIlxufTtcblxualF1ZXJ5LmZ4ID0gVHdlZW4ucHJvdG90eXBlLmluaXQ7XG5cbi8vIEJhY2sgQ29tcGF0IDwxLjggZXh0ZW5zaW9uIHBvaW50XG5qUXVlcnkuZnguc3RlcCA9IHt9O1xuXG5cblxuXG52YXJcblx0ZnhOb3csIHRpbWVySWQsXG5cdHJmeHR5cGVzID0gL14oPzp0b2dnbGV8c2hvd3xoaWRlKSQvLFxuXHRycnVuID0gL3F1ZXVlSG9va3MkLztcblxuLy8gQW5pbWF0aW9ucyBjcmVhdGVkIHN5bmNocm9ub3VzbHkgd2lsbCBydW4gc3luY2hyb25vdXNseVxuZnVuY3Rpb24gY3JlYXRlRnhOb3coKSB7XG5cdHdpbmRvdy5zZXRUaW1lb3V0KCBmdW5jdGlvbigpIHtcblx0XHRmeE5vdyA9IHVuZGVmaW5lZDtcblx0fSApO1xuXHRyZXR1cm4gKCBmeE5vdyA9IGpRdWVyeS5ub3coKSApO1xufVxuXG4vLyBHZW5lcmF0ZSBwYXJhbWV0ZXJzIHRvIGNyZWF0ZSBhIHN0YW5kYXJkIGFuaW1hdGlvblxuZnVuY3Rpb24gZ2VuRngoIHR5cGUsIGluY2x1ZGVXaWR0aCApIHtcblx0dmFyIHdoaWNoLFxuXHRcdGF0dHJzID0geyBoZWlnaHQ6IHR5cGUgfSxcblx0XHRpID0gMDtcblxuXHQvLyBpZiB3ZSBpbmNsdWRlIHdpZHRoLCBzdGVwIHZhbHVlIGlzIDEgdG8gZG8gYWxsIGNzc0V4cGFuZCB2YWx1ZXMsXG5cdC8vIGlmIHdlIGRvbid0IGluY2x1ZGUgd2lkdGgsIHN0ZXAgdmFsdWUgaXMgMiB0byBza2lwIG92ZXIgTGVmdCBhbmQgUmlnaHRcblx0aW5jbHVkZVdpZHRoID0gaW5jbHVkZVdpZHRoID8gMSA6IDA7XG5cdGZvciAoIDsgaSA8IDQgOyBpICs9IDIgLSBpbmNsdWRlV2lkdGggKSB7XG5cdFx0d2hpY2ggPSBjc3NFeHBhbmRbIGkgXTtcblx0XHRhdHRyc1sgXCJtYXJnaW5cIiArIHdoaWNoIF0gPSBhdHRyc1sgXCJwYWRkaW5nXCIgKyB3aGljaCBdID0gdHlwZTtcblx0fVxuXG5cdGlmICggaW5jbHVkZVdpZHRoICkge1xuXHRcdGF0dHJzLm9wYWNpdHkgPSBhdHRycy53aWR0aCA9IHR5cGU7XG5cdH1cblxuXHRyZXR1cm4gYXR0cnM7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVR3ZWVuKCB2YWx1ZSwgcHJvcCwgYW5pbWF0aW9uICkge1xuXHR2YXIgdHdlZW4sXG5cdFx0Y29sbGVjdGlvbiA9ICggQW5pbWF0aW9uLnR3ZWVuZXJzWyBwcm9wIF0gfHwgW10gKS5jb25jYXQoIEFuaW1hdGlvbi50d2VlbmVyc1sgXCIqXCIgXSApLFxuXHRcdGluZGV4ID0gMCxcblx0XHRsZW5ndGggPSBjb2xsZWN0aW9uLmxlbmd0aDtcblx0Zm9yICggOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKyApIHtcblx0XHRpZiAoICggdHdlZW4gPSBjb2xsZWN0aW9uWyBpbmRleCBdLmNhbGwoIGFuaW1hdGlvbiwgcHJvcCwgdmFsdWUgKSApICkge1xuXG5cdFx0XHQvLyB3ZSdyZSBkb25lIHdpdGggdGhpcyBwcm9wZXJ0eVxuXHRcdFx0cmV0dXJuIHR3ZWVuO1xuXHRcdH1cblx0fVxufVxuXG5mdW5jdGlvbiBkZWZhdWx0UHJlZmlsdGVyKCBlbGVtLCBwcm9wcywgb3B0cyApIHtcblx0LyoganNoaW50IHZhbGlkdGhpczogdHJ1ZSAqL1xuXHR2YXIgcHJvcCwgdmFsdWUsIHRvZ2dsZSwgdHdlZW4sIGhvb2tzLCBvbGRmaXJlLCBkaXNwbGF5LCBjaGVja0Rpc3BsYXksXG5cdFx0YW5pbSA9IHRoaXMsXG5cdFx0b3JpZyA9IHt9LFxuXHRcdHN0eWxlID0gZWxlbS5zdHlsZSxcblx0XHRoaWRkZW4gPSBlbGVtLm5vZGVUeXBlICYmIGlzSGlkZGVuKCBlbGVtICksXG5cdFx0ZGF0YVNob3cgPSBqUXVlcnkuX2RhdGEoIGVsZW0sIFwiZnhzaG93XCIgKTtcblxuXHQvLyBoYW5kbGUgcXVldWU6IGZhbHNlIHByb21pc2VzXG5cdGlmICggIW9wdHMucXVldWUgKSB7XG5cdFx0aG9va3MgPSBqUXVlcnkuX3F1ZXVlSG9va3MoIGVsZW0sIFwiZnhcIiApO1xuXHRcdGlmICggaG9va3MudW5xdWV1ZWQgPT0gbnVsbCApIHtcblx0XHRcdGhvb2tzLnVucXVldWVkID0gMDtcblx0XHRcdG9sZGZpcmUgPSBob29rcy5lbXB0eS5maXJlO1xuXHRcdFx0aG9va3MuZW1wdHkuZmlyZSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoICFob29rcy51bnF1ZXVlZCApIHtcblx0XHRcdFx0XHRvbGRmaXJlKCk7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cdFx0fVxuXHRcdGhvb2tzLnVucXVldWVkKys7XG5cblx0XHRhbmltLmFsd2F5cyggZnVuY3Rpb24oKSB7XG5cblx0XHRcdC8vIGRvaW5nIHRoaXMgbWFrZXMgc3VyZSB0aGF0IHRoZSBjb21wbGV0ZSBoYW5kbGVyIHdpbGwgYmUgY2FsbGVkXG5cdFx0XHQvLyBiZWZvcmUgdGhpcyBjb21wbGV0ZXNcblx0XHRcdGFuaW0uYWx3YXlzKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0aG9va3MudW5xdWV1ZWQtLTtcblx0XHRcdFx0aWYgKCAhalF1ZXJ5LnF1ZXVlKCBlbGVtLCBcImZ4XCIgKS5sZW5ndGggKSB7XG5cdFx0XHRcdFx0aG9va3MuZW1wdHkuZmlyZSgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9ICk7XG5cdFx0fSApO1xuXHR9XG5cblx0Ly8gaGVpZ2h0L3dpZHRoIG92ZXJmbG93IHBhc3Ncblx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSAxICYmICggXCJoZWlnaHRcIiBpbiBwcm9wcyB8fCBcIndpZHRoXCIgaW4gcHJvcHMgKSApIHtcblxuXHRcdC8vIE1ha2Ugc3VyZSB0aGF0IG5vdGhpbmcgc25lYWtzIG91dFxuXHRcdC8vIFJlY29yZCBhbGwgMyBvdmVyZmxvdyBhdHRyaWJ1dGVzIGJlY2F1c2UgSUUgZG9lcyBub3Rcblx0XHQvLyBjaGFuZ2UgdGhlIG92ZXJmbG93IGF0dHJpYnV0ZSB3aGVuIG92ZXJmbG93WCBhbmRcblx0XHQvLyBvdmVyZmxvd1kgYXJlIHNldCB0byB0aGUgc2FtZSB2YWx1ZVxuXHRcdG9wdHMub3ZlcmZsb3cgPSBbIHN0eWxlLm92ZXJmbG93LCBzdHlsZS5vdmVyZmxvd1gsIHN0eWxlLm92ZXJmbG93WSBdO1xuXG5cdFx0Ly8gU2V0IGRpc3BsYXkgcHJvcGVydHkgdG8gaW5saW5lLWJsb2NrIGZvciBoZWlnaHQvd2lkdGhcblx0XHQvLyBhbmltYXRpb25zIG9uIGlubGluZSBlbGVtZW50cyB0aGF0IGFyZSBoYXZpbmcgd2lkdGgvaGVpZ2h0IGFuaW1hdGVkXG5cdFx0ZGlzcGxheSA9IGpRdWVyeS5jc3MoIGVsZW0sIFwiZGlzcGxheVwiICk7XG5cblx0XHQvLyBUZXN0IGRlZmF1bHQgZGlzcGxheSBpZiBkaXNwbGF5IGlzIGN1cnJlbnRseSBcIm5vbmVcIlxuXHRcdGNoZWNrRGlzcGxheSA9IGRpc3BsYXkgPT09IFwibm9uZVwiID9cblx0XHRcdGpRdWVyeS5fZGF0YSggZWxlbSwgXCJvbGRkaXNwbGF5XCIgKSB8fCBkZWZhdWx0RGlzcGxheSggZWxlbS5ub2RlTmFtZSApIDogZGlzcGxheTtcblxuXHRcdGlmICggY2hlY2tEaXNwbGF5ID09PSBcImlubGluZVwiICYmIGpRdWVyeS5jc3MoIGVsZW0sIFwiZmxvYXRcIiApID09PSBcIm5vbmVcIiApIHtcblxuXHRcdFx0Ly8gaW5saW5lLWxldmVsIGVsZW1lbnRzIGFjY2VwdCBpbmxpbmUtYmxvY2s7XG5cdFx0XHQvLyBibG9jay1sZXZlbCBlbGVtZW50cyBuZWVkIHRvIGJlIGlubGluZSB3aXRoIGxheW91dFxuXHRcdFx0aWYgKCAhc3VwcG9ydC5pbmxpbmVCbG9ja05lZWRzTGF5b3V0IHx8IGRlZmF1bHREaXNwbGF5KCBlbGVtLm5vZGVOYW1lICkgPT09IFwiaW5saW5lXCIgKSB7XG5cdFx0XHRcdHN0eWxlLmRpc3BsYXkgPSBcImlubGluZS1ibG9ja1wiO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0c3R5bGUuem9vbSA9IDE7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0aWYgKCBvcHRzLm92ZXJmbG93ICkge1xuXHRcdHN0eWxlLm92ZXJmbG93ID0gXCJoaWRkZW5cIjtcblx0XHRpZiAoICFzdXBwb3J0LnNocmlua1dyYXBCbG9ja3MoKSApIHtcblx0XHRcdGFuaW0uYWx3YXlzKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0c3R5bGUub3ZlcmZsb3cgPSBvcHRzLm92ZXJmbG93WyAwIF07XG5cdFx0XHRcdHN0eWxlLm92ZXJmbG93WCA9IG9wdHMub3ZlcmZsb3dbIDEgXTtcblx0XHRcdFx0c3R5bGUub3ZlcmZsb3dZID0gb3B0cy5vdmVyZmxvd1sgMiBdO1xuXHRcdFx0fSApO1xuXHRcdH1cblx0fVxuXG5cdC8vIHNob3cvaGlkZSBwYXNzXG5cdGZvciAoIHByb3AgaW4gcHJvcHMgKSB7XG5cdFx0dmFsdWUgPSBwcm9wc1sgcHJvcCBdO1xuXHRcdGlmICggcmZ4dHlwZXMuZXhlYyggdmFsdWUgKSApIHtcblx0XHRcdGRlbGV0ZSBwcm9wc1sgcHJvcCBdO1xuXHRcdFx0dG9nZ2xlID0gdG9nZ2xlIHx8IHZhbHVlID09PSBcInRvZ2dsZVwiO1xuXHRcdFx0aWYgKCB2YWx1ZSA9PT0gKCBoaWRkZW4gPyBcImhpZGVcIiA6IFwic2hvd1wiICkgKSB7XG5cblx0XHRcdFx0Ly8gSWYgdGhlcmUgaXMgZGF0YVNob3cgbGVmdCBvdmVyIGZyb20gYSBzdG9wcGVkIGhpZGUgb3Igc2hvd1xuXHRcdFx0XHQvLyBhbmQgd2UgYXJlIGdvaW5nIHRvIHByb2NlZWQgd2l0aCBzaG93LCB3ZSBzaG91bGQgcHJldGVuZCB0byBiZSBoaWRkZW5cblx0XHRcdFx0aWYgKCB2YWx1ZSA9PT0gXCJzaG93XCIgJiYgZGF0YVNob3cgJiYgZGF0YVNob3dbIHByb3AgXSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdGhpZGRlbiA9IHRydWU7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdG9yaWdbIHByb3AgXSA9IGRhdGFTaG93ICYmIGRhdGFTaG93WyBwcm9wIF0gfHwgalF1ZXJ5LnN0eWxlKCBlbGVtLCBwcm9wICk7XG5cblx0XHQvLyBBbnkgbm9uLWZ4IHZhbHVlIHN0b3BzIHVzIGZyb20gcmVzdG9yaW5nIHRoZSBvcmlnaW5hbCBkaXNwbGF5IHZhbHVlXG5cdFx0fSBlbHNlIHtcblx0XHRcdGRpc3BsYXkgPSB1bmRlZmluZWQ7XG5cdFx0fVxuXHR9XG5cblx0aWYgKCAhalF1ZXJ5LmlzRW1wdHlPYmplY3QoIG9yaWcgKSApIHtcblx0XHRpZiAoIGRhdGFTaG93ICkge1xuXHRcdFx0aWYgKCBcImhpZGRlblwiIGluIGRhdGFTaG93ICkge1xuXHRcdFx0XHRoaWRkZW4gPSBkYXRhU2hvdy5oaWRkZW47XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdGRhdGFTaG93ID0galF1ZXJ5Ll9kYXRhKCBlbGVtLCBcImZ4c2hvd1wiLCB7fSApO1xuXHRcdH1cblxuXHRcdC8vIHN0b3JlIHN0YXRlIGlmIGl0cyB0b2dnbGUgLSBlbmFibGVzIC5zdG9wKCkudG9nZ2xlKCkgdG8gXCJyZXZlcnNlXCJcblx0XHRpZiAoIHRvZ2dsZSApIHtcblx0XHRcdGRhdGFTaG93LmhpZGRlbiA9ICFoaWRkZW47XG5cdFx0fVxuXHRcdGlmICggaGlkZGVuICkge1xuXHRcdFx0alF1ZXJ5KCBlbGVtICkuc2hvdygpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRhbmltLmRvbmUoIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRqUXVlcnkoIGVsZW0gKS5oaWRlKCk7XG5cdFx0XHR9ICk7XG5cdFx0fVxuXHRcdGFuaW0uZG9uZSggZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgcHJvcDtcblx0XHRcdGpRdWVyeS5fcmVtb3ZlRGF0YSggZWxlbSwgXCJmeHNob3dcIiApO1xuXHRcdFx0Zm9yICggcHJvcCBpbiBvcmlnICkge1xuXHRcdFx0XHRqUXVlcnkuc3R5bGUoIGVsZW0sIHByb3AsIG9yaWdbIHByb3AgXSApO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0XHRmb3IgKCBwcm9wIGluIG9yaWcgKSB7XG5cdFx0XHR0d2VlbiA9IGNyZWF0ZVR3ZWVuKCBoaWRkZW4gPyBkYXRhU2hvd1sgcHJvcCBdIDogMCwgcHJvcCwgYW5pbSApO1xuXG5cdFx0XHRpZiAoICEoIHByb3AgaW4gZGF0YVNob3cgKSApIHtcblx0XHRcdFx0ZGF0YVNob3dbIHByb3AgXSA9IHR3ZWVuLnN0YXJ0O1xuXHRcdFx0XHRpZiAoIGhpZGRlbiApIHtcblx0XHRcdFx0XHR0d2Vlbi5lbmQgPSB0d2Vlbi5zdGFydDtcblx0XHRcdFx0XHR0d2Vlbi5zdGFydCA9IHByb3AgPT09IFwid2lkdGhcIiB8fCBwcm9wID09PSBcImhlaWdodFwiID8gMSA6IDA7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0Ly8gSWYgdGhpcyBpcyBhIG5vb3AgbGlrZSAuaGlkZSgpLmhpZGUoKSwgcmVzdG9yZSBhbiBvdmVyd3JpdHRlbiBkaXNwbGF5IHZhbHVlXG5cdH0gZWxzZSBpZiAoICggZGlzcGxheSA9PT0gXCJub25lXCIgPyBkZWZhdWx0RGlzcGxheSggZWxlbS5ub2RlTmFtZSApIDogZGlzcGxheSApID09PSBcImlubGluZVwiICkge1xuXHRcdHN0eWxlLmRpc3BsYXkgPSBkaXNwbGF5O1xuXHR9XG59XG5cbmZ1bmN0aW9uIHByb3BGaWx0ZXIoIHByb3BzLCBzcGVjaWFsRWFzaW5nICkge1xuXHR2YXIgaW5kZXgsIG5hbWUsIGVhc2luZywgdmFsdWUsIGhvb2tzO1xuXG5cdC8vIGNhbWVsQ2FzZSwgc3BlY2lhbEVhc2luZyBhbmQgZXhwYW5kIGNzc0hvb2sgcGFzc1xuXHRmb3IgKCBpbmRleCBpbiBwcm9wcyApIHtcblx0XHRuYW1lID0galF1ZXJ5LmNhbWVsQ2FzZSggaW5kZXggKTtcblx0XHRlYXNpbmcgPSBzcGVjaWFsRWFzaW5nWyBuYW1lIF07XG5cdFx0dmFsdWUgPSBwcm9wc1sgaW5kZXggXTtcblx0XHRpZiAoIGpRdWVyeS5pc0FycmF5KCB2YWx1ZSApICkge1xuXHRcdFx0ZWFzaW5nID0gdmFsdWVbIDEgXTtcblx0XHRcdHZhbHVlID0gcHJvcHNbIGluZGV4IF0gPSB2YWx1ZVsgMCBdO1xuXHRcdH1cblxuXHRcdGlmICggaW5kZXggIT09IG5hbWUgKSB7XG5cdFx0XHRwcm9wc1sgbmFtZSBdID0gdmFsdWU7XG5cdFx0XHRkZWxldGUgcHJvcHNbIGluZGV4IF07XG5cdFx0fVxuXG5cdFx0aG9va3MgPSBqUXVlcnkuY3NzSG9va3NbIG5hbWUgXTtcblx0XHRpZiAoIGhvb2tzICYmIFwiZXhwYW5kXCIgaW4gaG9va3MgKSB7XG5cdFx0XHR2YWx1ZSA9IGhvb2tzLmV4cGFuZCggdmFsdWUgKTtcblx0XHRcdGRlbGV0ZSBwcm9wc1sgbmFtZSBdO1xuXG5cdFx0XHQvLyBub3QgcXVpdGUgJC5leHRlbmQsIHRoaXMgd29udCBvdmVyd3JpdGUga2V5cyBhbHJlYWR5IHByZXNlbnQuXG5cdFx0XHQvLyBhbHNvIC0gcmV1c2luZyAnaW5kZXgnIGZyb20gYWJvdmUgYmVjYXVzZSB3ZSBoYXZlIHRoZSBjb3JyZWN0IFwibmFtZVwiXG5cdFx0XHRmb3IgKCBpbmRleCBpbiB2YWx1ZSApIHtcblx0XHRcdFx0aWYgKCAhKCBpbmRleCBpbiBwcm9wcyApICkge1xuXHRcdFx0XHRcdHByb3BzWyBpbmRleCBdID0gdmFsdWVbIGluZGV4IF07XG5cdFx0XHRcdFx0c3BlY2lhbEVhc2luZ1sgaW5kZXggXSA9IGVhc2luZztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRzcGVjaWFsRWFzaW5nWyBuYW1lIF0gPSBlYXNpbmc7XG5cdFx0fVxuXHR9XG59XG5cbmZ1bmN0aW9uIEFuaW1hdGlvbiggZWxlbSwgcHJvcGVydGllcywgb3B0aW9ucyApIHtcblx0dmFyIHJlc3VsdCxcblx0XHRzdG9wcGVkLFxuXHRcdGluZGV4ID0gMCxcblx0XHRsZW5ndGggPSBBbmltYXRpb24ucHJlZmlsdGVycy5sZW5ndGgsXG5cdFx0ZGVmZXJyZWQgPSBqUXVlcnkuRGVmZXJyZWQoKS5hbHdheXMoIGZ1bmN0aW9uKCkge1xuXG5cdFx0XHQvLyBkb24ndCBtYXRjaCBlbGVtIGluIHRoZSA6YW5pbWF0ZWQgc2VsZWN0b3Jcblx0XHRcdGRlbGV0ZSB0aWNrLmVsZW07XG5cdFx0fSApLFxuXHRcdHRpY2sgPSBmdW5jdGlvbigpIHtcblx0XHRcdGlmICggc3RvcHBlZCApIHtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXHRcdFx0dmFyIGN1cnJlbnRUaW1lID0gZnhOb3cgfHwgY3JlYXRlRnhOb3coKSxcblx0XHRcdFx0cmVtYWluaW5nID0gTWF0aC5tYXgoIDAsIGFuaW1hdGlvbi5zdGFydFRpbWUgKyBhbmltYXRpb24uZHVyYXRpb24gLSBjdXJyZW50VGltZSApLFxuXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IEFuZHJvaWQgMi4zXG5cdFx0XHRcdC8vIEFyY2hhaWMgY3Jhc2ggYnVnIHdvbid0IGFsbG93IHVzIHRvIHVzZSBgMSAtICggMC41IHx8IDAgKWAgKCMxMjQ5Nylcblx0XHRcdFx0dGVtcCA9IHJlbWFpbmluZyAvIGFuaW1hdGlvbi5kdXJhdGlvbiB8fCAwLFxuXHRcdFx0XHRwZXJjZW50ID0gMSAtIHRlbXAsXG5cdFx0XHRcdGluZGV4ID0gMCxcblx0XHRcdFx0bGVuZ3RoID0gYW5pbWF0aW9uLnR3ZWVucy5sZW5ndGg7XG5cblx0XHRcdGZvciAoIDsgaW5kZXggPCBsZW5ndGggOyBpbmRleCsrICkge1xuXHRcdFx0XHRhbmltYXRpb24udHdlZW5zWyBpbmRleCBdLnJ1biggcGVyY2VudCApO1xuXHRcdFx0fVxuXG5cdFx0XHRkZWZlcnJlZC5ub3RpZnlXaXRoKCBlbGVtLCBbIGFuaW1hdGlvbiwgcGVyY2VudCwgcmVtYWluaW5nIF0gKTtcblxuXHRcdFx0aWYgKCBwZXJjZW50IDwgMSAmJiBsZW5ndGggKSB7XG5cdFx0XHRcdHJldHVybiByZW1haW5pbmc7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRkZWZlcnJlZC5yZXNvbHZlV2l0aCggZWxlbSwgWyBhbmltYXRpb24gXSApO1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRhbmltYXRpb24gPSBkZWZlcnJlZC5wcm9taXNlKCB7XG5cdFx0XHRlbGVtOiBlbGVtLFxuXHRcdFx0cHJvcHM6IGpRdWVyeS5leHRlbmQoIHt9LCBwcm9wZXJ0aWVzICksXG5cdFx0XHRvcHRzOiBqUXVlcnkuZXh0ZW5kKCB0cnVlLCB7XG5cdFx0XHRcdHNwZWNpYWxFYXNpbmc6IHt9LFxuXHRcdFx0XHRlYXNpbmc6IGpRdWVyeS5lYXNpbmcuX2RlZmF1bHRcblx0XHRcdH0sIG9wdGlvbnMgKSxcblx0XHRcdG9yaWdpbmFsUHJvcGVydGllczogcHJvcGVydGllcyxcblx0XHRcdG9yaWdpbmFsT3B0aW9uczogb3B0aW9ucyxcblx0XHRcdHN0YXJ0VGltZTogZnhOb3cgfHwgY3JlYXRlRnhOb3coKSxcblx0XHRcdGR1cmF0aW9uOiBvcHRpb25zLmR1cmF0aW9uLFxuXHRcdFx0dHdlZW5zOiBbXSxcblx0XHRcdGNyZWF0ZVR3ZWVuOiBmdW5jdGlvbiggcHJvcCwgZW5kICkge1xuXHRcdFx0XHR2YXIgdHdlZW4gPSBqUXVlcnkuVHdlZW4oIGVsZW0sIGFuaW1hdGlvbi5vcHRzLCBwcm9wLCBlbmQsXG5cdFx0XHRcdFx0XHRhbmltYXRpb24ub3B0cy5zcGVjaWFsRWFzaW5nWyBwcm9wIF0gfHwgYW5pbWF0aW9uLm9wdHMuZWFzaW5nICk7XG5cdFx0XHRcdGFuaW1hdGlvbi50d2VlbnMucHVzaCggdHdlZW4gKTtcblx0XHRcdFx0cmV0dXJuIHR3ZWVuO1xuXHRcdFx0fSxcblx0XHRcdHN0b3A6IGZ1bmN0aW9uKCBnb3RvRW5kICkge1xuXHRcdFx0XHR2YXIgaW5kZXggPSAwLFxuXG5cdFx0XHRcdFx0Ly8gaWYgd2UgYXJlIGdvaW5nIHRvIHRoZSBlbmQsIHdlIHdhbnQgdG8gcnVuIGFsbCB0aGUgdHdlZW5zXG5cdFx0XHRcdFx0Ly8gb3RoZXJ3aXNlIHdlIHNraXAgdGhpcyBwYXJ0XG5cdFx0XHRcdFx0bGVuZ3RoID0gZ290b0VuZCA/IGFuaW1hdGlvbi50d2VlbnMubGVuZ3RoIDogMDtcblx0XHRcdFx0aWYgKCBzdG9wcGVkICkge1xuXHRcdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHN0b3BwZWQgPSB0cnVlO1xuXHRcdFx0XHRmb3IgKCA7IGluZGV4IDwgbGVuZ3RoIDsgaW5kZXgrKyApIHtcblx0XHRcdFx0XHRhbmltYXRpb24udHdlZW5zWyBpbmRleCBdLnJ1biggMSApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gcmVzb2x2ZSB3aGVuIHdlIHBsYXllZCB0aGUgbGFzdCBmcmFtZVxuXHRcdFx0XHQvLyBvdGhlcndpc2UsIHJlamVjdFxuXHRcdFx0XHRpZiAoIGdvdG9FbmQgKSB7XG5cdFx0XHRcdFx0ZGVmZXJyZWQubm90aWZ5V2l0aCggZWxlbSwgWyBhbmltYXRpb24sIDEsIDAgXSApO1xuXHRcdFx0XHRcdGRlZmVycmVkLnJlc29sdmVXaXRoKCBlbGVtLCBbIGFuaW1hdGlvbiwgZ290b0VuZCBdICk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0ZGVmZXJyZWQucmVqZWN0V2l0aCggZWxlbSwgWyBhbmltYXRpb24sIGdvdG9FbmQgXSApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fVxuXHRcdH0gKSxcblx0XHRwcm9wcyA9IGFuaW1hdGlvbi5wcm9wcztcblxuXHRwcm9wRmlsdGVyKCBwcm9wcywgYW5pbWF0aW9uLm9wdHMuc3BlY2lhbEVhc2luZyApO1xuXG5cdGZvciAoIDsgaW5kZXggPCBsZW5ndGggOyBpbmRleCsrICkge1xuXHRcdHJlc3VsdCA9IEFuaW1hdGlvbi5wcmVmaWx0ZXJzWyBpbmRleCBdLmNhbGwoIGFuaW1hdGlvbiwgZWxlbSwgcHJvcHMsIGFuaW1hdGlvbi5vcHRzICk7XG5cdFx0aWYgKCByZXN1bHQgKSB7XG5cdFx0XHRpZiAoIGpRdWVyeS5pc0Z1bmN0aW9uKCByZXN1bHQuc3RvcCApICkge1xuXHRcdFx0XHRqUXVlcnkuX3F1ZXVlSG9va3MoIGFuaW1hdGlvbi5lbGVtLCBhbmltYXRpb24ub3B0cy5xdWV1ZSApLnN0b3AgPVxuXHRcdFx0XHRcdGpRdWVyeS5wcm94eSggcmVzdWx0LnN0b3AsIHJlc3VsdCApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHJlc3VsdDtcblx0XHR9XG5cdH1cblxuXHRqUXVlcnkubWFwKCBwcm9wcywgY3JlYXRlVHdlZW4sIGFuaW1hdGlvbiApO1xuXG5cdGlmICggalF1ZXJ5LmlzRnVuY3Rpb24oIGFuaW1hdGlvbi5vcHRzLnN0YXJ0ICkgKSB7XG5cdFx0YW5pbWF0aW9uLm9wdHMuc3RhcnQuY2FsbCggZWxlbSwgYW5pbWF0aW9uICk7XG5cdH1cblxuXHRqUXVlcnkuZngudGltZXIoXG5cdFx0alF1ZXJ5LmV4dGVuZCggdGljaywge1xuXHRcdFx0ZWxlbTogZWxlbSxcblx0XHRcdGFuaW06IGFuaW1hdGlvbixcblx0XHRcdHF1ZXVlOiBhbmltYXRpb24ub3B0cy5xdWV1ZVxuXHRcdH0gKVxuXHQpO1xuXG5cdC8vIGF0dGFjaCBjYWxsYmFja3MgZnJvbSBvcHRpb25zXG5cdHJldHVybiBhbmltYXRpb24ucHJvZ3Jlc3MoIGFuaW1hdGlvbi5vcHRzLnByb2dyZXNzIClcblx0XHQuZG9uZSggYW5pbWF0aW9uLm9wdHMuZG9uZSwgYW5pbWF0aW9uLm9wdHMuY29tcGxldGUgKVxuXHRcdC5mYWlsKCBhbmltYXRpb24ub3B0cy5mYWlsIClcblx0XHQuYWx3YXlzKCBhbmltYXRpb24ub3B0cy5hbHdheXMgKTtcbn1cblxualF1ZXJ5LkFuaW1hdGlvbiA9IGpRdWVyeS5leHRlbmQoIEFuaW1hdGlvbiwge1xuXG5cdHR3ZWVuZXJzOiB7XG5cdFx0XCIqXCI6IFsgZnVuY3Rpb24oIHByb3AsIHZhbHVlICkge1xuXHRcdFx0dmFyIHR3ZWVuID0gdGhpcy5jcmVhdGVUd2VlbiggcHJvcCwgdmFsdWUgKTtcblx0XHRcdGFkanVzdENTUyggdHdlZW4uZWxlbSwgcHJvcCwgcmNzc051bS5leGVjKCB2YWx1ZSApLCB0d2VlbiApO1xuXHRcdFx0cmV0dXJuIHR3ZWVuO1xuXHRcdH0gXVxuXHR9LFxuXG5cdHR3ZWVuZXI6IGZ1bmN0aW9uKCBwcm9wcywgY2FsbGJhY2sgKSB7XG5cdFx0aWYgKCBqUXVlcnkuaXNGdW5jdGlvbiggcHJvcHMgKSApIHtcblx0XHRcdGNhbGxiYWNrID0gcHJvcHM7XG5cdFx0XHRwcm9wcyA9IFsgXCIqXCIgXTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cHJvcHMgPSBwcm9wcy5tYXRjaCggcm5vdHdoaXRlICk7XG5cdFx0fVxuXG5cdFx0dmFyIHByb3AsXG5cdFx0XHRpbmRleCA9IDAsXG5cdFx0XHRsZW5ndGggPSBwcm9wcy5sZW5ndGg7XG5cblx0XHRmb3IgKCA7IGluZGV4IDwgbGVuZ3RoIDsgaW5kZXgrKyApIHtcblx0XHRcdHByb3AgPSBwcm9wc1sgaW5kZXggXTtcblx0XHRcdEFuaW1hdGlvbi50d2VlbmVyc1sgcHJvcCBdID0gQW5pbWF0aW9uLnR3ZWVuZXJzWyBwcm9wIF0gfHwgW107XG5cdFx0XHRBbmltYXRpb24udHdlZW5lcnNbIHByb3AgXS51bnNoaWZ0KCBjYWxsYmFjayApO1xuXHRcdH1cblx0fSxcblxuXHRwcmVmaWx0ZXJzOiBbIGRlZmF1bHRQcmVmaWx0ZXIgXSxcblxuXHRwcmVmaWx0ZXI6IGZ1bmN0aW9uKCBjYWxsYmFjaywgcHJlcGVuZCApIHtcblx0XHRpZiAoIHByZXBlbmQgKSB7XG5cdFx0XHRBbmltYXRpb24ucHJlZmlsdGVycy51bnNoaWZ0KCBjYWxsYmFjayApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRBbmltYXRpb24ucHJlZmlsdGVycy5wdXNoKCBjYWxsYmFjayApO1xuXHRcdH1cblx0fVxufSApO1xuXG5qUXVlcnkuc3BlZWQgPSBmdW5jdGlvbiggc3BlZWQsIGVhc2luZywgZm4gKSB7XG5cdHZhciBvcHQgPSBzcGVlZCAmJiB0eXBlb2Ygc3BlZWQgPT09IFwib2JqZWN0XCIgPyBqUXVlcnkuZXh0ZW5kKCB7fSwgc3BlZWQgKSA6IHtcblx0XHRjb21wbGV0ZTogZm4gfHwgIWZuICYmIGVhc2luZyB8fFxuXHRcdFx0alF1ZXJ5LmlzRnVuY3Rpb24oIHNwZWVkICkgJiYgc3BlZWQsXG5cdFx0ZHVyYXRpb246IHNwZWVkLFxuXHRcdGVhc2luZzogZm4gJiYgZWFzaW5nIHx8IGVhc2luZyAmJiAhalF1ZXJ5LmlzRnVuY3Rpb24oIGVhc2luZyApICYmIGVhc2luZ1xuXHR9O1xuXG5cdG9wdC5kdXJhdGlvbiA9IGpRdWVyeS5meC5vZmYgPyAwIDogdHlwZW9mIG9wdC5kdXJhdGlvbiA9PT0gXCJudW1iZXJcIiA/IG9wdC5kdXJhdGlvbiA6XG5cdFx0b3B0LmR1cmF0aW9uIGluIGpRdWVyeS5meC5zcGVlZHMgP1xuXHRcdFx0alF1ZXJ5LmZ4LnNwZWVkc1sgb3B0LmR1cmF0aW9uIF0gOiBqUXVlcnkuZnguc3BlZWRzLl9kZWZhdWx0O1xuXG5cdC8vIG5vcm1hbGl6ZSBvcHQucXVldWUgLSB0cnVlL3VuZGVmaW5lZC9udWxsIC0+IFwiZnhcIlxuXHRpZiAoIG9wdC5xdWV1ZSA9PSBudWxsIHx8IG9wdC5xdWV1ZSA9PT0gdHJ1ZSApIHtcblx0XHRvcHQucXVldWUgPSBcImZ4XCI7XG5cdH1cblxuXHQvLyBRdWV1ZWluZ1xuXHRvcHQub2xkID0gb3B0LmNvbXBsZXRlO1xuXG5cdG9wdC5jb21wbGV0ZSA9IGZ1bmN0aW9uKCkge1xuXHRcdGlmICggalF1ZXJ5LmlzRnVuY3Rpb24oIG9wdC5vbGQgKSApIHtcblx0XHRcdG9wdC5vbGQuY2FsbCggdGhpcyApO1xuXHRcdH1cblxuXHRcdGlmICggb3B0LnF1ZXVlICkge1xuXHRcdFx0alF1ZXJ5LmRlcXVldWUoIHRoaXMsIG9wdC5xdWV1ZSApO1xuXHRcdH1cblx0fTtcblxuXHRyZXR1cm4gb3B0O1xufTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRmYWRlVG86IGZ1bmN0aW9uKCBzcGVlZCwgdG8sIGVhc2luZywgY2FsbGJhY2sgKSB7XG5cblx0XHQvLyBzaG93IGFueSBoaWRkZW4gZWxlbWVudHMgYWZ0ZXIgc2V0dGluZyBvcGFjaXR5IHRvIDBcblx0XHRyZXR1cm4gdGhpcy5maWx0ZXIoIGlzSGlkZGVuICkuY3NzKCBcIm9wYWNpdHlcIiwgMCApLnNob3coKVxuXG5cdFx0XHQvLyBhbmltYXRlIHRvIHRoZSB2YWx1ZSBzcGVjaWZpZWRcblx0XHRcdC5lbmQoKS5hbmltYXRlKCB7IG9wYWNpdHk6IHRvIH0sIHNwZWVkLCBlYXNpbmcsIGNhbGxiYWNrICk7XG5cdH0sXG5cdGFuaW1hdGU6IGZ1bmN0aW9uKCBwcm9wLCBzcGVlZCwgZWFzaW5nLCBjYWxsYmFjayApIHtcblx0XHR2YXIgZW1wdHkgPSBqUXVlcnkuaXNFbXB0eU9iamVjdCggcHJvcCApLFxuXHRcdFx0b3B0YWxsID0galF1ZXJ5LnNwZWVkKCBzcGVlZCwgZWFzaW5nLCBjYWxsYmFjayApLFxuXHRcdFx0ZG9BbmltYXRpb24gPSBmdW5jdGlvbigpIHtcblxuXHRcdFx0XHQvLyBPcGVyYXRlIG9uIGEgY29weSBvZiBwcm9wIHNvIHBlci1wcm9wZXJ0eSBlYXNpbmcgd29uJ3QgYmUgbG9zdFxuXHRcdFx0XHR2YXIgYW5pbSA9IEFuaW1hdGlvbiggdGhpcywgalF1ZXJ5LmV4dGVuZCgge30sIHByb3AgKSwgb3B0YWxsICk7XG5cblx0XHRcdFx0Ly8gRW1wdHkgYW5pbWF0aW9ucywgb3IgZmluaXNoaW5nIHJlc29sdmVzIGltbWVkaWF0ZWx5XG5cdFx0XHRcdGlmICggZW1wdHkgfHwgalF1ZXJ5Ll9kYXRhKCB0aGlzLCBcImZpbmlzaFwiICkgKSB7XG5cdFx0XHRcdFx0YW5pbS5zdG9wKCB0cnVlICk7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cdFx0XHRkb0FuaW1hdGlvbi5maW5pc2ggPSBkb0FuaW1hdGlvbjtcblxuXHRcdHJldHVybiBlbXB0eSB8fCBvcHRhbGwucXVldWUgPT09IGZhbHNlID9cblx0XHRcdHRoaXMuZWFjaCggZG9BbmltYXRpb24gKSA6XG5cdFx0XHR0aGlzLnF1ZXVlKCBvcHRhbGwucXVldWUsIGRvQW5pbWF0aW9uICk7XG5cdH0sXG5cdHN0b3A6IGZ1bmN0aW9uKCB0eXBlLCBjbGVhclF1ZXVlLCBnb3RvRW5kICkge1xuXHRcdHZhciBzdG9wUXVldWUgPSBmdW5jdGlvbiggaG9va3MgKSB7XG5cdFx0XHR2YXIgc3RvcCA9IGhvb2tzLnN0b3A7XG5cdFx0XHRkZWxldGUgaG9va3Muc3RvcDtcblx0XHRcdHN0b3AoIGdvdG9FbmQgKTtcblx0XHR9O1xuXG5cdFx0aWYgKCB0eXBlb2YgdHlwZSAhPT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdGdvdG9FbmQgPSBjbGVhclF1ZXVlO1xuXHRcdFx0Y2xlYXJRdWV1ZSA9IHR5cGU7XG5cdFx0XHR0eXBlID0gdW5kZWZpbmVkO1xuXHRcdH1cblx0XHRpZiAoIGNsZWFyUXVldWUgJiYgdHlwZSAhPT0gZmFsc2UgKSB7XG5cdFx0XHR0aGlzLnF1ZXVlKCB0eXBlIHx8IFwiZnhcIiwgW10gKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBkZXF1ZXVlID0gdHJ1ZSxcblx0XHRcdFx0aW5kZXggPSB0eXBlICE9IG51bGwgJiYgdHlwZSArIFwicXVldWVIb29rc1wiLFxuXHRcdFx0XHR0aW1lcnMgPSBqUXVlcnkudGltZXJzLFxuXHRcdFx0XHRkYXRhID0galF1ZXJ5Ll9kYXRhKCB0aGlzICk7XG5cblx0XHRcdGlmICggaW5kZXggKSB7XG5cdFx0XHRcdGlmICggZGF0YVsgaW5kZXggXSAmJiBkYXRhWyBpbmRleCBdLnN0b3AgKSB7XG5cdFx0XHRcdFx0c3RvcFF1ZXVlKCBkYXRhWyBpbmRleCBdICk7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGZvciAoIGluZGV4IGluIGRhdGEgKSB7XG5cdFx0XHRcdFx0aWYgKCBkYXRhWyBpbmRleCBdICYmIGRhdGFbIGluZGV4IF0uc3RvcCAmJiBycnVuLnRlc3QoIGluZGV4ICkgKSB7XG5cdFx0XHRcdFx0XHRzdG9wUXVldWUoIGRhdGFbIGluZGV4IF0gKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Zm9yICggaW5kZXggPSB0aW1lcnMubGVuZ3RoOyBpbmRleC0tOyApIHtcblx0XHRcdFx0aWYgKCB0aW1lcnNbIGluZGV4IF0uZWxlbSA9PT0gdGhpcyAmJlxuXHRcdFx0XHRcdCggdHlwZSA9PSBudWxsIHx8IHRpbWVyc1sgaW5kZXggXS5xdWV1ZSA9PT0gdHlwZSApICkge1xuXG5cdFx0XHRcdFx0dGltZXJzWyBpbmRleCBdLmFuaW0uc3RvcCggZ290b0VuZCApO1xuXHRcdFx0XHRcdGRlcXVldWUgPSBmYWxzZTtcblx0XHRcdFx0XHR0aW1lcnMuc3BsaWNlKCBpbmRleCwgMSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIHN0YXJ0IHRoZSBuZXh0IGluIHRoZSBxdWV1ZSBpZiB0aGUgbGFzdCBzdGVwIHdhc24ndCBmb3JjZWRcblx0XHRcdC8vIHRpbWVycyBjdXJyZW50bHkgd2lsbCBjYWxsIHRoZWlyIGNvbXBsZXRlIGNhbGxiYWNrcywgd2hpY2ggd2lsbCBkZXF1ZXVlXG5cdFx0XHQvLyBidXQgb25seSBpZiB0aGV5IHdlcmUgZ290b0VuZFxuXHRcdFx0aWYgKCBkZXF1ZXVlIHx8ICFnb3RvRW5kICkge1xuXHRcdFx0XHRqUXVlcnkuZGVxdWV1ZSggdGhpcywgdHlwZSApO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0fSxcblx0ZmluaXNoOiBmdW5jdGlvbiggdHlwZSApIHtcblx0XHRpZiAoIHR5cGUgIT09IGZhbHNlICkge1xuXHRcdFx0dHlwZSA9IHR5cGUgfHwgXCJmeFwiO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBpbmRleCxcblx0XHRcdFx0ZGF0YSA9IGpRdWVyeS5fZGF0YSggdGhpcyApLFxuXHRcdFx0XHRxdWV1ZSA9IGRhdGFbIHR5cGUgKyBcInF1ZXVlXCIgXSxcblx0XHRcdFx0aG9va3MgPSBkYXRhWyB0eXBlICsgXCJxdWV1ZUhvb2tzXCIgXSxcblx0XHRcdFx0dGltZXJzID0galF1ZXJ5LnRpbWVycyxcblx0XHRcdFx0bGVuZ3RoID0gcXVldWUgPyBxdWV1ZS5sZW5ndGggOiAwO1xuXG5cdFx0XHQvLyBlbmFibGUgZmluaXNoaW5nIGZsYWcgb24gcHJpdmF0ZSBkYXRhXG5cdFx0XHRkYXRhLmZpbmlzaCA9IHRydWU7XG5cblx0XHRcdC8vIGVtcHR5IHRoZSBxdWV1ZSBmaXJzdFxuXHRcdFx0alF1ZXJ5LnF1ZXVlKCB0aGlzLCB0eXBlLCBbXSApO1xuXG5cdFx0XHRpZiAoIGhvb2tzICYmIGhvb2tzLnN0b3AgKSB7XG5cdFx0XHRcdGhvb2tzLnN0b3AuY2FsbCggdGhpcywgdHJ1ZSApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBsb29rIGZvciBhbnkgYWN0aXZlIGFuaW1hdGlvbnMsIGFuZCBmaW5pc2ggdGhlbVxuXHRcdFx0Zm9yICggaW5kZXggPSB0aW1lcnMubGVuZ3RoOyBpbmRleC0tOyApIHtcblx0XHRcdFx0aWYgKCB0aW1lcnNbIGluZGV4IF0uZWxlbSA9PT0gdGhpcyAmJiB0aW1lcnNbIGluZGV4IF0ucXVldWUgPT09IHR5cGUgKSB7XG5cdFx0XHRcdFx0dGltZXJzWyBpbmRleCBdLmFuaW0uc3RvcCggdHJ1ZSApO1xuXHRcdFx0XHRcdHRpbWVycy5zcGxpY2UoIGluZGV4LCAxICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gbG9vayBmb3IgYW55IGFuaW1hdGlvbnMgaW4gdGhlIG9sZCBxdWV1ZSBhbmQgZmluaXNoIHRoZW1cblx0XHRcdGZvciAoIGluZGV4ID0gMDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KysgKSB7XG5cdFx0XHRcdGlmICggcXVldWVbIGluZGV4IF0gJiYgcXVldWVbIGluZGV4IF0uZmluaXNoICkge1xuXHRcdFx0XHRcdHF1ZXVlWyBpbmRleCBdLmZpbmlzaC5jYWxsKCB0aGlzICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gdHVybiBvZmYgZmluaXNoaW5nIGZsYWdcblx0XHRcdGRlbGV0ZSBkYXRhLmZpbmlzaDtcblx0XHR9ICk7XG5cdH1cbn0gKTtcblxualF1ZXJ5LmVhY2goIFsgXCJ0b2dnbGVcIiwgXCJzaG93XCIsIFwiaGlkZVwiIF0sIGZ1bmN0aW9uKCBpLCBuYW1lICkge1xuXHR2YXIgY3NzRm4gPSBqUXVlcnkuZm5bIG5hbWUgXTtcblx0alF1ZXJ5LmZuWyBuYW1lIF0gPSBmdW5jdGlvbiggc3BlZWQsIGVhc2luZywgY2FsbGJhY2sgKSB7XG5cdFx0cmV0dXJuIHNwZWVkID09IG51bGwgfHwgdHlwZW9mIHNwZWVkID09PSBcImJvb2xlYW5cIiA/XG5cdFx0XHRjc3NGbi5hcHBseSggdGhpcywgYXJndW1lbnRzICkgOlxuXHRcdFx0dGhpcy5hbmltYXRlKCBnZW5GeCggbmFtZSwgdHJ1ZSApLCBzcGVlZCwgZWFzaW5nLCBjYWxsYmFjayApO1xuXHR9O1xufSApO1xuXG4vLyBHZW5lcmF0ZSBzaG9ydGN1dHMgZm9yIGN1c3RvbSBhbmltYXRpb25zXG5qUXVlcnkuZWFjaCgge1xuXHRzbGlkZURvd246IGdlbkZ4KCBcInNob3dcIiApLFxuXHRzbGlkZVVwOiBnZW5GeCggXCJoaWRlXCIgKSxcblx0c2xpZGVUb2dnbGU6IGdlbkZ4KCBcInRvZ2dsZVwiICksXG5cdGZhZGVJbjogeyBvcGFjaXR5OiBcInNob3dcIiB9LFxuXHRmYWRlT3V0OiB7IG9wYWNpdHk6IFwiaGlkZVwiIH0sXG5cdGZhZGVUb2dnbGU6IHsgb3BhY2l0eTogXCJ0b2dnbGVcIiB9XG59LCBmdW5jdGlvbiggbmFtZSwgcHJvcHMgKSB7XG5cdGpRdWVyeS5mblsgbmFtZSBdID0gZnVuY3Rpb24oIHNwZWVkLCBlYXNpbmcsIGNhbGxiYWNrICkge1xuXHRcdHJldHVybiB0aGlzLmFuaW1hdGUoIHByb3BzLCBzcGVlZCwgZWFzaW5nLCBjYWxsYmFjayApO1xuXHR9O1xufSApO1xuXG5qUXVlcnkudGltZXJzID0gW107XG5qUXVlcnkuZngudGljayA9IGZ1bmN0aW9uKCkge1xuXHR2YXIgdGltZXIsXG5cdFx0dGltZXJzID0galF1ZXJ5LnRpbWVycyxcblx0XHRpID0gMDtcblxuXHRmeE5vdyA9IGpRdWVyeS5ub3coKTtcblxuXHRmb3IgKCA7IGkgPCB0aW1lcnMubGVuZ3RoOyBpKysgKSB7XG5cdFx0dGltZXIgPSB0aW1lcnNbIGkgXTtcblxuXHRcdC8vIENoZWNrcyB0aGUgdGltZXIgaGFzIG5vdCBhbHJlYWR5IGJlZW4gcmVtb3ZlZFxuXHRcdGlmICggIXRpbWVyKCkgJiYgdGltZXJzWyBpIF0gPT09IHRpbWVyICkge1xuXHRcdFx0dGltZXJzLnNwbGljZSggaS0tLCAxICk7XG5cdFx0fVxuXHR9XG5cblx0aWYgKCAhdGltZXJzLmxlbmd0aCApIHtcblx0XHRqUXVlcnkuZnguc3RvcCgpO1xuXHR9XG5cdGZ4Tm93ID0gdW5kZWZpbmVkO1xufTtcblxualF1ZXJ5LmZ4LnRpbWVyID0gZnVuY3Rpb24oIHRpbWVyICkge1xuXHRqUXVlcnkudGltZXJzLnB1c2goIHRpbWVyICk7XG5cdGlmICggdGltZXIoKSApIHtcblx0XHRqUXVlcnkuZnguc3RhcnQoKTtcblx0fSBlbHNlIHtcblx0XHRqUXVlcnkudGltZXJzLnBvcCgpO1xuXHR9XG59O1xuXG5qUXVlcnkuZnguaW50ZXJ2YWwgPSAxMztcblxualF1ZXJ5LmZ4LnN0YXJ0ID0gZnVuY3Rpb24oKSB7XG5cdGlmICggIXRpbWVySWQgKSB7XG5cdFx0dGltZXJJZCA9IHdpbmRvdy5zZXRJbnRlcnZhbCggalF1ZXJ5LmZ4LnRpY2ssIGpRdWVyeS5meC5pbnRlcnZhbCApO1xuXHR9XG59O1xuXG5qUXVlcnkuZnguc3RvcCA9IGZ1bmN0aW9uKCkge1xuXHR3aW5kb3cuY2xlYXJJbnRlcnZhbCggdGltZXJJZCApO1xuXHR0aW1lcklkID0gbnVsbDtcbn07XG5cbmpRdWVyeS5meC5zcGVlZHMgPSB7XG5cdHNsb3c6IDYwMCxcblx0ZmFzdDogMjAwLFxuXG5cdC8vIERlZmF1bHQgc3BlZWRcblx0X2RlZmF1bHQ6IDQwMFxufTtcblxuXG4vLyBCYXNlZCBvZmYgb2YgdGhlIHBsdWdpbiBieSBDbGludCBIZWxmZXJzLCB3aXRoIHBlcm1pc3Npb24uXG4vLyBodHRwOi8vd2ViLmFyY2hpdmUub3JnL3dlYi8yMDEwMDMyNDAxNDc0Ny9odHRwOi8vYmxpbmRzaWduYWxzLmNvbS9pbmRleC5waHAvMjAwOS8wNy9qcXVlcnktZGVsYXkvXG5qUXVlcnkuZm4uZGVsYXkgPSBmdW5jdGlvbiggdGltZSwgdHlwZSApIHtcblx0dGltZSA9IGpRdWVyeS5meCA/IGpRdWVyeS5meC5zcGVlZHNbIHRpbWUgXSB8fCB0aW1lIDogdGltZTtcblx0dHlwZSA9IHR5cGUgfHwgXCJmeFwiO1xuXG5cdHJldHVybiB0aGlzLnF1ZXVlKCB0eXBlLCBmdW5jdGlvbiggbmV4dCwgaG9va3MgKSB7XG5cdFx0dmFyIHRpbWVvdXQgPSB3aW5kb3cuc2V0VGltZW91dCggbmV4dCwgdGltZSApO1xuXHRcdGhvb2tzLnN0b3AgPSBmdW5jdGlvbigpIHtcblx0XHRcdHdpbmRvdy5jbGVhclRpbWVvdXQoIHRpbWVvdXQgKTtcblx0XHR9O1xuXHR9ICk7XG59O1xuXG5cbiggZnVuY3Rpb24oKSB7XG5cdHZhciBhLFxuXHRcdGlucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJpbnB1dFwiICksXG5cdFx0ZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJkaXZcIiApLFxuXHRcdHNlbGVjdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwic2VsZWN0XCIgKSxcblx0XHRvcHQgPSBzZWxlY3QuYXBwZW5kQ2hpbGQoIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwib3B0aW9uXCIgKSApO1xuXG5cdC8vIFNldHVwXG5cdGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiZGl2XCIgKTtcblx0ZGl2LnNldEF0dHJpYnV0ZSggXCJjbGFzc05hbWVcIiwgXCJ0XCIgKTtcblx0ZGl2LmlubmVySFRNTCA9IFwiICA8bGluay8+PHRhYmxlPjwvdGFibGU+PGEgaHJlZj0nL2EnPmE8L2E+PGlucHV0IHR5cGU9J2NoZWNrYm94Jy8+XCI7XG5cdGEgPSBkaXYuZ2V0RWxlbWVudHNCeVRhZ05hbWUoIFwiYVwiIClbIDAgXTtcblxuXHQvLyBTdXBwb3J0OiBXaW5kb3dzIFdlYiBBcHBzIChXV0EpXG5cdC8vIGB0eXBlYCBtdXN0IHVzZSAuc2V0QXR0cmlidXRlIGZvciBXV0EgKCMxNDkwMSlcblx0aW5wdXQuc2V0QXR0cmlidXRlKCBcInR5cGVcIiwgXCJjaGVja2JveFwiICk7XG5cdGRpdi5hcHBlbmRDaGlsZCggaW5wdXQgKTtcblxuXHRhID0gZGl2LmdldEVsZW1lbnRzQnlUYWdOYW1lKCBcImFcIiApWyAwIF07XG5cblx0Ly8gRmlyc3QgYmF0Y2ggb2YgdGVzdHMuXG5cdGEuc3R5bGUuY3NzVGV4dCA9IFwidG9wOjFweFwiO1xuXG5cdC8vIFRlc3Qgc2V0QXR0cmlidXRlIG9uIGNhbWVsQ2FzZSBjbGFzcy5cblx0Ly8gSWYgaXQgd29ya3MsIHdlIG5lZWQgYXR0ckZpeGVzIHdoZW4gZG9pbmcgZ2V0L3NldEF0dHJpYnV0ZSAoaWU2LzcpXG5cdHN1cHBvcnQuZ2V0U2V0QXR0cmlidXRlID0gZGl2LmNsYXNzTmFtZSAhPT0gXCJ0XCI7XG5cblx0Ly8gR2V0IHRoZSBzdHlsZSBpbmZvcm1hdGlvbiBmcm9tIGdldEF0dHJpYnV0ZVxuXHQvLyAoSUUgdXNlcyAuY3NzVGV4dCBpbnN0ZWFkKVxuXHRzdXBwb3J0LnN0eWxlID0gL3RvcC8udGVzdCggYS5nZXRBdHRyaWJ1dGUoIFwic3R5bGVcIiApICk7XG5cblx0Ly8gTWFrZSBzdXJlIHRoYXQgVVJMcyBhcmVuJ3QgbWFuaXB1bGF0ZWRcblx0Ly8gKElFIG5vcm1hbGl6ZXMgaXQgYnkgZGVmYXVsdClcblx0c3VwcG9ydC5ocmVmTm9ybWFsaXplZCA9IGEuZ2V0QXR0cmlidXRlKCBcImhyZWZcIiApID09PSBcIi9hXCI7XG5cblx0Ly8gQ2hlY2sgdGhlIGRlZmF1bHQgY2hlY2tib3gvcmFkaW8gdmFsdWUgKFwiXCIgb24gV2ViS2l0OyBcIm9uXCIgZWxzZXdoZXJlKVxuXHRzdXBwb3J0LmNoZWNrT24gPSAhIWlucHV0LnZhbHVlO1xuXG5cdC8vIE1ha2Ugc3VyZSB0aGF0IGEgc2VsZWN0ZWQtYnktZGVmYXVsdCBvcHRpb24gaGFzIGEgd29ya2luZyBzZWxlY3RlZCBwcm9wZXJ0eS5cblx0Ly8gKFdlYktpdCBkZWZhdWx0cyB0byBmYWxzZSBpbnN0ZWFkIG9mIHRydWUsIElFIHRvbywgaWYgaXQncyBpbiBhbiBvcHRncm91cClcblx0c3VwcG9ydC5vcHRTZWxlY3RlZCA9IG9wdC5zZWxlY3RlZDtcblxuXHQvLyBUZXN0cyBmb3IgZW5jdHlwZSBzdXBwb3J0IG9uIGEgZm9ybSAoIzY3NDMpXG5cdHN1cHBvcnQuZW5jdHlwZSA9ICEhZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJmb3JtXCIgKS5lbmN0eXBlO1xuXG5cdC8vIE1ha2Ugc3VyZSB0aGF0IHRoZSBvcHRpb25zIGluc2lkZSBkaXNhYmxlZCBzZWxlY3RzIGFyZW4ndCBtYXJrZWQgYXMgZGlzYWJsZWRcblx0Ly8gKFdlYktpdCBtYXJrcyB0aGVtIGFzIGRpc2FibGVkKVxuXHRzZWxlY3QuZGlzYWJsZWQgPSB0cnVlO1xuXHRzdXBwb3J0Lm9wdERpc2FibGVkID0gIW9wdC5kaXNhYmxlZDtcblxuXHQvLyBTdXBwb3J0OiBJRTggb25seVxuXHQvLyBDaGVjayBpZiB3ZSBjYW4gdHJ1c3QgZ2V0QXR0cmlidXRlKFwidmFsdWVcIilcblx0aW5wdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImlucHV0XCIgKTtcblx0aW5wdXQuc2V0QXR0cmlidXRlKCBcInZhbHVlXCIsIFwiXCIgKTtcblx0c3VwcG9ydC5pbnB1dCA9IGlucHV0LmdldEF0dHJpYnV0ZSggXCJ2YWx1ZVwiICkgPT09IFwiXCI7XG5cblx0Ly8gQ2hlY2sgaWYgYW4gaW5wdXQgbWFpbnRhaW5zIGl0cyB2YWx1ZSBhZnRlciBiZWNvbWluZyBhIHJhZGlvXG5cdGlucHV0LnZhbHVlID0gXCJ0XCI7XG5cdGlucHV0LnNldEF0dHJpYnV0ZSggXCJ0eXBlXCIsIFwicmFkaW9cIiApO1xuXHRzdXBwb3J0LnJhZGlvVmFsdWUgPSBpbnB1dC52YWx1ZSA9PT0gXCJ0XCI7XG59ICkoKTtcblxuXG52YXIgcnJldHVybiA9IC9cXHIvZyxcblx0cnNwYWNlcyA9IC9bXFx4MjBcXHRcXHJcXG5cXGZdKy9nO1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdHZhbDogZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdHZhciBob29rcywgcmV0LCBpc0Z1bmN0aW9uLFxuXHRcdFx0ZWxlbSA9IHRoaXNbIDAgXTtcblxuXHRcdGlmICggIWFyZ3VtZW50cy5sZW5ndGggKSB7XG5cdFx0XHRpZiAoIGVsZW0gKSB7XG5cdFx0XHRcdGhvb2tzID0galF1ZXJ5LnZhbEhvb2tzWyBlbGVtLnR5cGUgXSB8fFxuXHRcdFx0XHRcdGpRdWVyeS52YWxIb29rc1sgZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpIF07XG5cblx0XHRcdFx0aWYgKFxuXHRcdFx0XHRcdGhvb2tzICYmXG5cdFx0XHRcdFx0XCJnZXRcIiBpbiBob29rcyAmJlxuXHRcdFx0XHRcdCggcmV0ID0gaG9va3MuZ2V0KCBlbGVtLCBcInZhbHVlXCIgKSApICE9PSB1bmRlZmluZWRcblx0XHRcdFx0KSB7XG5cdFx0XHRcdFx0cmV0dXJuIHJldDtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldCA9IGVsZW0udmFsdWU7XG5cblx0XHRcdFx0cmV0dXJuIHR5cGVvZiByZXQgPT09IFwic3RyaW5nXCIgP1xuXG5cdFx0XHRcdFx0Ly8gaGFuZGxlIG1vc3QgY29tbW9uIHN0cmluZyBjYXNlc1xuXHRcdFx0XHRcdHJldC5yZXBsYWNlKCBycmV0dXJuLCBcIlwiICkgOlxuXG5cdFx0XHRcdFx0Ly8gaGFuZGxlIGNhc2VzIHdoZXJlIHZhbHVlIGlzIG51bGwvdW5kZWYgb3IgbnVtYmVyXG5cdFx0XHRcdFx0cmV0ID09IG51bGwgPyBcIlwiIDogcmV0O1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0aXNGdW5jdGlvbiA9IGpRdWVyeS5pc0Z1bmN0aW9uKCB2YWx1ZSApO1xuXG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oIGkgKSB7XG5cdFx0XHR2YXIgdmFsO1xuXG5cdFx0XHRpZiAoIHRoaXMubm9kZVR5cGUgIT09IDEgKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCBpc0Z1bmN0aW9uICkge1xuXHRcdFx0XHR2YWwgPSB2YWx1ZS5jYWxsKCB0aGlzLCBpLCBqUXVlcnkoIHRoaXMgKS52YWwoKSApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dmFsID0gdmFsdWU7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFRyZWF0IG51bGwvdW5kZWZpbmVkIGFzIFwiXCI7IGNvbnZlcnQgbnVtYmVycyB0byBzdHJpbmdcblx0XHRcdGlmICggdmFsID09IG51bGwgKSB7XG5cdFx0XHRcdHZhbCA9IFwiXCI7XG5cdFx0XHR9IGVsc2UgaWYgKCB0eXBlb2YgdmFsID09PSBcIm51bWJlclwiICkge1xuXHRcdFx0XHR2YWwgKz0gXCJcIjtcblx0XHRcdH0gZWxzZSBpZiAoIGpRdWVyeS5pc0FycmF5KCB2YWwgKSApIHtcblx0XHRcdFx0dmFsID0galF1ZXJ5Lm1hcCggdmFsLCBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHZhbHVlID09IG51bGwgPyBcIlwiIDogdmFsdWUgKyBcIlwiO1xuXHRcdFx0XHR9ICk7XG5cdFx0XHR9XG5cblx0XHRcdGhvb2tzID0galF1ZXJ5LnZhbEhvb2tzWyB0aGlzLnR5cGUgXSB8fCBqUXVlcnkudmFsSG9va3NbIHRoaXMubm9kZU5hbWUudG9Mb3dlckNhc2UoKSBdO1xuXG5cdFx0XHQvLyBJZiBzZXQgcmV0dXJucyB1bmRlZmluZWQsIGZhbGwgYmFjayB0byBub3JtYWwgc2V0dGluZ1xuXHRcdFx0aWYgKCAhaG9va3MgfHwgISggXCJzZXRcIiBpbiBob29rcyApIHx8IGhvb2tzLnNldCggdGhpcywgdmFsLCBcInZhbHVlXCIgKSA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHR0aGlzLnZhbHVlID0gdmFsO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0fVxufSApO1xuXG5qUXVlcnkuZXh0ZW5kKCB7XG5cdHZhbEhvb2tzOiB7XG5cdFx0b3B0aW9uOiB7XG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHR2YXIgdmFsID0galF1ZXJ5LmZpbmQuYXR0ciggZWxlbSwgXCJ2YWx1ZVwiICk7XG5cdFx0XHRcdHJldHVybiB2YWwgIT0gbnVsbCA/XG5cdFx0XHRcdFx0dmFsIDpcblxuXHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFMTAtMTErXG5cdFx0XHRcdFx0Ly8gb3B0aW9uLnRleHQgdGhyb3dzIGV4Y2VwdGlvbnMgKCMxNDY4NiwgIzE0ODU4KVxuXHRcdFx0XHRcdC8vIFN0cmlwIGFuZCBjb2xsYXBzZSB3aGl0ZXNwYWNlXG5cdFx0XHRcdFx0Ly8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy8jc3RyaXAtYW5kLWNvbGxhcHNlLXdoaXRlc3BhY2Vcblx0XHRcdFx0XHRqUXVlcnkudHJpbSggalF1ZXJ5LnRleHQoIGVsZW0gKSApLnJlcGxhY2UoIHJzcGFjZXMsIFwiIFwiICk7XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRzZWxlY3Q6IHtcblx0XHRcdGdldDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdHZhciB2YWx1ZSwgb3B0aW9uLFxuXHRcdFx0XHRcdG9wdGlvbnMgPSBlbGVtLm9wdGlvbnMsXG5cdFx0XHRcdFx0aW5kZXggPSBlbGVtLnNlbGVjdGVkSW5kZXgsXG5cdFx0XHRcdFx0b25lID0gZWxlbS50eXBlID09PSBcInNlbGVjdC1vbmVcIiB8fCBpbmRleCA8IDAsXG5cdFx0XHRcdFx0dmFsdWVzID0gb25lID8gbnVsbCA6IFtdLFxuXHRcdFx0XHRcdG1heCA9IG9uZSA/IGluZGV4ICsgMSA6IG9wdGlvbnMubGVuZ3RoLFxuXHRcdFx0XHRcdGkgPSBpbmRleCA8IDAgP1xuXHRcdFx0XHRcdFx0bWF4IDpcblx0XHRcdFx0XHRcdG9uZSA/IGluZGV4IDogMDtcblxuXHRcdFx0XHQvLyBMb29wIHRocm91Z2ggYWxsIHRoZSBzZWxlY3RlZCBvcHRpb25zXG5cdFx0XHRcdGZvciAoIDsgaSA8IG1heDsgaSsrICkge1xuXHRcdFx0XHRcdG9wdGlvbiA9IG9wdGlvbnNbIGkgXTtcblxuXHRcdFx0XHRcdC8vIG9sZElFIGRvZXNuJ3QgdXBkYXRlIHNlbGVjdGVkIGFmdGVyIGZvcm0gcmVzZXQgKCMyNTUxKVxuXHRcdFx0XHRcdGlmICggKCBvcHRpb24uc2VsZWN0ZWQgfHwgaSA9PT0gaW5kZXggKSAmJlxuXG5cdFx0XHRcdFx0XHRcdC8vIERvbid0IHJldHVybiBvcHRpb25zIHRoYXQgYXJlIGRpc2FibGVkIG9yIGluIGEgZGlzYWJsZWQgb3B0Z3JvdXBcblx0XHRcdFx0XHRcdFx0KCBzdXBwb3J0Lm9wdERpc2FibGVkID9cblx0XHRcdFx0XHRcdFx0XHQhb3B0aW9uLmRpc2FibGVkIDpcblx0XHRcdFx0XHRcdFx0XHRvcHRpb24uZ2V0QXR0cmlidXRlKCBcImRpc2FibGVkXCIgKSA9PT0gbnVsbCApICYmXG5cdFx0XHRcdFx0XHRcdCggIW9wdGlvbi5wYXJlbnROb2RlLmRpc2FibGVkIHx8XG5cdFx0XHRcdFx0XHRcdFx0IWpRdWVyeS5ub2RlTmFtZSggb3B0aW9uLnBhcmVudE5vZGUsIFwib3B0Z3JvdXBcIiApICkgKSB7XG5cblx0XHRcdFx0XHRcdC8vIEdldCB0aGUgc3BlY2lmaWMgdmFsdWUgZm9yIHRoZSBvcHRpb25cblx0XHRcdFx0XHRcdHZhbHVlID0galF1ZXJ5KCBvcHRpb24gKS52YWwoKTtcblxuXHRcdFx0XHRcdFx0Ly8gV2UgZG9uJ3QgbmVlZCBhbiBhcnJheSBmb3Igb25lIHNlbGVjdHNcblx0XHRcdFx0XHRcdGlmICggb25lICkge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gdmFsdWU7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdC8vIE11bHRpLVNlbGVjdHMgcmV0dXJuIGFuIGFycmF5XG5cdFx0XHRcdFx0XHR2YWx1ZXMucHVzaCggdmFsdWUgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gdmFsdWVzO1xuXHRcdFx0fSxcblxuXHRcdFx0c2V0OiBmdW5jdGlvbiggZWxlbSwgdmFsdWUgKSB7XG5cdFx0XHRcdHZhciBvcHRpb25TZXQsIG9wdGlvbixcblx0XHRcdFx0XHRvcHRpb25zID0gZWxlbS5vcHRpb25zLFxuXHRcdFx0XHRcdHZhbHVlcyA9IGpRdWVyeS5tYWtlQXJyYXkoIHZhbHVlICksXG5cdFx0XHRcdFx0aSA9IG9wdGlvbnMubGVuZ3RoO1xuXG5cdFx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRcdG9wdGlvbiA9IG9wdGlvbnNbIGkgXTtcblxuXHRcdFx0XHRcdGlmICggalF1ZXJ5LmluQXJyYXkoIGpRdWVyeS52YWxIb29rcy5vcHRpb24uZ2V0KCBvcHRpb24gKSwgdmFsdWVzICkgPiAtMSApIHtcblxuXHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUU2XG5cdFx0XHRcdFx0XHQvLyBXaGVuIG5ldyBvcHRpb24gZWxlbWVudCBpcyBhZGRlZCB0byBzZWxlY3QgYm94IHdlIG5lZWQgdG9cblx0XHRcdFx0XHRcdC8vIGZvcmNlIHJlZmxvdyBvZiBuZXdseSBhZGRlZCBub2RlIGluIG9yZGVyIHRvIHdvcmthcm91bmQgZGVsYXlcblx0XHRcdFx0XHRcdC8vIG9mIGluaXRpYWxpemF0aW9uIHByb3BlcnRpZXNcblx0XHRcdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0XHRcdG9wdGlvbi5zZWxlY3RlZCA9IG9wdGlvblNldCA9IHRydWU7XG5cblx0XHRcdFx0XHRcdH0gY2F0Y2ggKCBfICkge1xuXG5cdFx0XHRcdFx0XHRcdC8vIFdpbGwgYmUgZXhlY3V0ZWQgb25seSBpbiBJRTZcblx0XHRcdFx0XHRcdFx0b3B0aW9uLnNjcm9sbEhlaWdodDtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRvcHRpb24uc2VsZWN0ZWQgPSBmYWxzZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBGb3JjZSBicm93c2VycyB0byBiZWhhdmUgY29uc2lzdGVudGx5IHdoZW4gbm9uLW1hdGNoaW5nIHZhbHVlIGlzIHNldFxuXHRcdFx0XHRpZiAoICFvcHRpb25TZXQgKSB7XG5cdFx0XHRcdFx0ZWxlbS5zZWxlY3RlZEluZGV4ID0gLTE7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gb3B0aW9ucztcblx0XHRcdH1cblx0XHR9XG5cdH1cbn0gKTtcblxuLy8gUmFkaW9zIGFuZCBjaGVja2JveGVzIGdldHRlci9zZXR0ZXJcbmpRdWVyeS5lYWNoKCBbIFwicmFkaW9cIiwgXCJjaGVja2JveFwiIF0sIGZ1bmN0aW9uKCkge1xuXHRqUXVlcnkudmFsSG9va3NbIHRoaXMgXSA9IHtcblx0XHRzZXQ6IGZ1bmN0aW9uKCBlbGVtLCB2YWx1ZSApIHtcblx0XHRcdGlmICggalF1ZXJ5LmlzQXJyYXkoIHZhbHVlICkgKSB7XG5cdFx0XHRcdHJldHVybiAoIGVsZW0uY2hlY2tlZCA9IGpRdWVyeS5pbkFycmF5KCBqUXVlcnkoIGVsZW0gKS52YWwoKSwgdmFsdWUgKSA+IC0xICk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xuXHRpZiAoICFzdXBwb3J0LmNoZWNrT24gKSB7XG5cdFx0alF1ZXJ5LnZhbEhvb2tzWyB0aGlzIF0uZ2V0ID0gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gZWxlbS5nZXRBdHRyaWJ1dGUoIFwidmFsdWVcIiApID09PSBudWxsID8gXCJvblwiIDogZWxlbS52YWx1ZTtcblx0XHR9O1xuXHR9XG59ICk7XG5cblxuXG5cbnZhciBub2RlSG9vaywgYm9vbEhvb2ssXG5cdGF0dHJIYW5kbGUgPSBqUXVlcnkuZXhwci5hdHRySGFuZGxlLFxuXHRydXNlRGVmYXVsdCA9IC9eKD86Y2hlY2tlZHxzZWxlY3RlZCkkL2ksXG5cdGdldFNldEF0dHJpYnV0ZSA9IHN1cHBvcnQuZ2V0U2V0QXR0cmlidXRlLFxuXHRnZXRTZXRJbnB1dCA9IHN1cHBvcnQuaW5wdXQ7XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0YXR0cjogZnVuY3Rpb24oIG5hbWUsIHZhbHVlICkge1xuXHRcdHJldHVybiBhY2Nlc3MoIHRoaXMsIGpRdWVyeS5hdHRyLCBuYW1lLCB2YWx1ZSwgYXJndW1lbnRzLmxlbmd0aCA+IDEgKTtcblx0fSxcblxuXHRyZW1vdmVBdHRyOiBmdW5jdGlvbiggbmFtZSApIHtcblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdGpRdWVyeS5yZW1vdmVBdHRyKCB0aGlzLCBuYW1lICk7XG5cdFx0fSApO1xuXHR9XG59ICk7XG5cbmpRdWVyeS5leHRlbmQoIHtcblx0YXR0cjogZnVuY3Rpb24oIGVsZW0sIG5hbWUsIHZhbHVlICkge1xuXHRcdHZhciByZXQsIGhvb2tzLFxuXHRcdFx0blR5cGUgPSBlbGVtLm5vZGVUeXBlO1xuXG5cdFx0Ly8gRG9uJ3QgZ2V0L3NldCBhdHRyaWJ1dGVzIG9uIHRleHQsIGNvbW1lbnQgYW5kIGF0dHJpYnV0ZSBub2Rlc1xuXHRcdGlmICggblR5cGUgPT09IDMgfHwgblR5cGUgPT09IDggfHwgblR5cGUgPT09IDIgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gRmFsbGJhY2sgdG8gcHJvcCB3aGVuIGF0dHJpYnV0ZXMgYXJlIG5vdCBzdXBwb3J0ZWRcblx0XHRpZiAoIHR5cGVvZiBlbGVtLmdldEF0dHJpYnV0ZSA9PT0gXCJ1bmRlZmluZWRcIiApIHtcblx0XHRcdHJldHVybiBqUXVlcnkucHJvcCggZWxlbSwgbmFtZSwgdmFsdWUgKTtcblx0XHR9XG5cblx0XHQvLyBBbGwgYXR0cmlidXRlcyBhcmUgbG93ZXJjYXNlXG5cdFx0Ly8gR3JhYiBuZWNlc3NhcnkgaG9vayBpZiBvbmUgaXMgZGVmaW5lZFxuXHRcdGlmICggblR5cGUgIT09IDEgfHwgIWpRdWVyeS5pc1hNTERvYyggZWxlbSApICkge1xuXHRcdFx0bmFtZSA9IG5hbWUudG9Mb3dlckNhc2UoKTtcblx0XHRcdGhvb2tzID0galF1ZXJ5LmF0dHJIb29rc1sgbmFtZSBdIHx8XG5cdFx0XHRcdCggalF1ZXJ5LmV4cHIubWF0Y2guYm9vbC50ZXN0KCBuYW1lICkgPyBib29sSG9vayA6IG5vZGVIb29rICk7XG5cdFx0fVxuXG5cdFx0aWYgKCB2YWx1ZSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0aWYgKCB2YWx1ZSA9PT0gbnVsbCApIHtcblx0XHRcdFx0alF1ZXJ5LnJlbW92ZUF0dHIoIGVsZW0sIG5hbWUgKTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIGhvb2tzICYmIFwic2V0XCIgaW4gaG9va3MgJiZcblx0XHRcdFx0KCByZXQgPSBob29rcy5zZXQoIGVsZW0sIHZhbHVlLCBuYW1lICkgKSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRyZXR1cm4gcmV0O1xuXHRcdFx0fVxuXG5cdFx0XHRlbGVtLnNldEF0dHJpYnV0ZSggbmFtZSwgdmFsdWUgKyBcIlwiICk7XG5cdFx0XHRyZXR1cm4gdmFsdWU7XG5cdFx0fVxuXG5cdFx0aWYgKCBob29rcyAmJiBcImdldFwiIGluIGhvb2tzICYmICggcmV0ID0gaG9va3MuZ2V0KCBlbGVtLCBuYW1lICkgKSAhPT0gbnVsbCApIHtcblx0XHRcdHJldHVybiByZXQ7XG5cdFx0fVxuXG5cdFx0cmV0ID0galF1ZXJ5LmZpbmQuYXR0ciggZWxlbSwgbmFtZSApO1xuXG5cdFx0Ly8gTm9uLWV4aXN0ZW50IGF0dHJpYnV0ZXMgcmV0dXJuIG51bGwsIHdlIG5vcm1hbGl6ZSB0byB1bmRlZmluZWRcblx0XHRyZXR1cm4gcmV0ID09IG51bGwgPyB1bmRlZmluZWQgOiByZXQ7XG5cdH0sXG5cblx0YXR0ckhvb2tzOiB7XG5cdFx0dHlwZToge1xuXHRcdFx0c2V0OiBmdW5jdGlvbiggZWxlbSwgdmFsdWUgKSB7XG5cdFx0XHRcdGlmICggIXN1cHBvcnQucmFkaW9WYWx1ZSAmJiB2YWx1ZSA9PT0gXCJyYWRpb1wiICYmXG5cdFx0XHRcdFx0alF1ZXJ5Lm5vZGVOYW1lKCBlbGVtLCBcImlucHV0XCIgKSApIHtcblxuXHRcdFx0XHRcdC8vIFNldHRpbmcgdGhlIHR5cGUgb24gYSByYWRpbyBidXR0b24gYWZ0ZXIgdGhlIHZhbHVlIHJlc2V0cyB0aGUgdmFsdWUgaW4gSUU4LTlcblx0XHRcdFx0XHQvLyBSZXNldCB2YWx1ZSB0byBkZWZhdWx0IGluIGNhc2UgdHlwZSBpcyBzZXQgYWZ0ZXIgdmFsdWUgZHVyaW5nIGNyZWF0aW9uXG5cdFx0XHRcdFx0dmFyIHZhbCA9IGVsZW0udmFsdWU7XG5cdFx0XHRcdFx0ZWxlbS5zZXRBdHRyaWJ1dGUoIFwidHlwZVwiLCB2YWx1ZSApO1xuXHRcdFx0XHRcdGlmICggdmFsICkge1xuXHRcdFx0XHRcdFx0ZWxlbS52YWx1ZSA9IHZhbDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIHZhbHVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdHJlbW92ZUF0dHI6IGZ1bmN0aW9uKCBlbGVtLCB2YWx1ZSApIHtcblx0XHR2YXIgbmFtZSwgcHJvcE5hbWUsXG5cdFx0XHRpID0gMCxcblx0XHRcdGF0dHJOYW1lcyA9IHZhbHVlICYmIHZhbHVlLm1hdGNoKCBybm90d2hpdGUgKTtcblxuXHRcdGlmICggYXR0ck5hbWVzICYmIGVsZW0ubm9kZVR5cGUgPT09IDEgKSB7XG5cdFx0XHR3aGlsZSAoICggbmFtZSA9IGF0dHJOYW1lc1sgaSsrIF0gKSApIHtcblx0XHRcdFx0cHJvcE5hbWUgPSBqUXVlcnkucHJvcEZpeFsgbmFtZSBdIHx8IG5hbWU7XG5cblx0XHRcdFx0Ly8gQm9vbGVhbiBhdHRyaWJ1dGVzIGdldCBzcGVjaWFsIHRyZWF0bWVudCAoIzEwODcwKVxuXHRcdFx0XHRpZiAoIGpRdWVyeS5leHByLm1hdGNoLmJvb2wudGVzdCggbmFtZSApICkge1xuXG5cdFx0XHRcdFx0Ly8gU2V0IGNvcnJlc3BvbmRpbmcgcHJvcGVydHkgdG8gZmFsc2Vcblx0XHRcdFx0XHRpZiAoIGdldFNldElucHV0ICYmIGdldFNldEF0dHJpYnV0ZSB8fCAhcnVzZURlZmF1bHQudGVzdCggbmFtZSApICkge1xuXHRcdFx0XHRcdFx0ZWxlbVsgcHJvcE5hbWUgXSA9IGZhbHNlO1xuXG5cdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUU8OVxuXHRcdFx0XHRcdC8vIEFsc28gY2xlYXIgZGVmYXVsdENoZWNrZWQvZGVmYXVsdFNlbGVjdGVkIChpZiBhcHByb3ByaWF0ZSlcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0ZWxlbVsgalF1ZXJ5LmNhbWVsQ2FzZSggXCJkZWZhdWx0LVwiICsgbmFtZSApIF0gPVxuXHRcdFx0XHRcdFx0XHRlbGVtWyBwcm9wTmFtZSBdID0gZmFsc2U7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFNlZSAjOTY5OSBmb3IgZXhwbGFuYXRpb24gb2YgdGhpcyBhcHByb2FjaCAoc2V0dGluZyBmaXJzdCwgdGhlbiByZW1vdmFsKVxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGpRdWVyeS5hdHRyKCBlbGVtLCBuYW1lLCBcIlwiICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRlbGVtLnJlbW92ZUF0dHJpYnV0ZSggZ2V0U2V0QXR0cmlidXRlID8gbmFtZSA6IHByb3BOYW1lICk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG59ICk7XG5cbi8vIEhvb2tzIGZvciBib29sZWFuIGF0dHJpYnV0ZXNcbmJvb2xIb29rID0ge1xuXHRzZXQ6IGZ1bmN0aW9uKCBlbGVtLCB2YWx1ZSwgbmFtZSApIHtcblx0XHRpZiAoIHZhbHVlID09PSBmYWxzZSApIHtcblxuXHRcdFx0Ly8gUmVtb3ZlIGJvb2xlYW4gYXR0cmlidXRlcyB3aGVuIHNldCB0byBmYWxzZVxuXHRcdFx0alF1ZXJ5LnJlbW92ZUF0dHIoIGVsZW0sIG5hbWUgKTtcblx0XHR9IGVsc2UgaWYgKCBnZXRTZXRJbnB1dCAmJiBnZXRTZXRBdHRyaWJ1dGUgfHwgIXJ1c2VEZWZhdWx0LnRlc3QoIG5hbWUgKSApIHtcblxuXHRcdFx0Ly8gSUU8OCBuZWVkcyB0aGUgKnByb3BlcnR5KiBuYW1lXG5cdFx0XHRlbGVtLnNldEF0dHJpYnV0ZSggIWdldFNldEF0dHJpYnV0ZSAmJiBqUXVlcnkucHJvcEZpeFsgbmFtZSBdIHx8IG5hbWUsIG5hbWUgKTtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdC8vIFN1cHBvcnQ6IElFPDlcblx0XHRcdC8vIFVzZSBkZWZhdWx0Q2hlY2tlZCBhbmQgZGVmYXVsdFNlbGVjdGVkIGZvciBvbGRJRVxuXHRcdFx0ZWxlbVsgalF1ZXJ5LmNhbWVsQ2FzZSggXCJkZWZhdWx0LVwiICsgbmFtZSApIF0gPSBlbGVtWyBuYW1lIF0gPSB0cnVlO1xuXHRcdH1cblx0XHRyZXR1cm4gbmFtZTtcblx0fVxufTtcblxualF1ZXJ5LmVhY2goIGpRdWVyeS5leHByLm1hdGNoLmJvb2wuc291cmNlLm1hdGNoKCAvXFx3Ky9nICksIGZ1bmN0aW9uKCBpLCBuYW1lICkge1xuXHR2YXIgZ2V0dGVyID0gYXR0ckhhbmRsZVsgbmFtZSBdIHx8IGpRdWVyeS5maW5kLmF0dHI7XG5cblx0aWYgKCBnZXRTZXRJbnB1dCAmJiBnZXRTZXRBdHRyaWJ1dGUgfHwgIXJ1c2VEZWZhdWx0LnRlc3QoIG5hbWUgKSApIHtcblx0XHRhdHRySGFuZGxlWyBuYW1lIF0gPSBmdW5jdGlvbiggZWxlbSwgbmFtZSwgaXNYTUwgKSB7XG5cdFx0XHR2YXIgcmV0LCBoYW5kbGU7XG5cdFx0XHRpZiAoICFpc1hNTCApIHtcblxuXHRcdFx0XHQvLyBBdm9pZCBhbiBpbmZpbml0ZSBsb29wIGJ5IHRlbXBvcmFyaWx5IHJlbW92aW5nIHRoaXMgZnVuY3Rpb24gZnJvbSB0aGUgZ2V0dGVyXG5cdFx0XHRcdGhhbmRsZSA9IGF0dHJIYW5kbGVbIG5hbWUgXTtcblx0XHRcdFx0YXR0ckhhbmRsZVsgbmFtZSBdID0gcmV0O1xuXHRcdFx0XHRyZXQgPSBnZXR0ZXIoIGVsZW0sIG5hbWUsIGlzWE1MICkgIT0gbnVsbCA/XG5cdFx0XHRcdFx0bmFtZS50b0xvd2VyQ2FzZSgpIDpcblx0XHRcdFx0XHRudWxsO1xuXHRcdFx0XHRhdHRySGFuZGxlWyBuYW1lIF0gPSBoYW5kbGU7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcmV0O1xuXHRcdH07XG5cdH0gZWxzZSB7XG5cdFx0YXR0ckhhbmRsZVsgbmFtZSBdID0gZnVuY3Rpb24oIGVsZW0sIG5hbWUsIGlzWE1MICkge1xuXHRcdFx0aWYgKCAhaXNYTUwgKSB7XG5cdFx0XHRcdHJldHVybiBlbGVtWyBqUXVlcnkuY2FtZWxDYXNlKCBcImRlZmF1bHQtXCIgKyBuYW1lICkgXSA/XG5cdFx0XHRcdFx0bmFtZS50b0xvd2VyQ2FzZSgpIDpcblx0XHRcdFx0XHRudWxsO1xuXHRcdFx0fVxuXHRcdH07XG5cdH1cbn0gKTtcblxuLy8gZml4IG9sZElFIGF0dHJvcGVydGllc1xuaWYgKCAhZ2V0U2V0SW5wdXQgfHwgIWdldFNldEF0dHJpYnV0ZSApIHtcblx0alF1ZXJ5LmF0dHJIb29rcy52YWx1ZSA9IHtcblx0XHRzZXQ6IGZ1bmN0aW9uKCBlbGVtLCB2YWx1ZSwgbmFtZSApIHtcblx0XHRcdGlmICggalF1ZXJ5Lm5vZGVOYW1lKCBlbGVtLCBcImlucHV0XCIgKSApIHtcblxuXHRcdFx0XHQvLyBEb2VzIG5vdCByZXR1cm4gc28gdGhhdCBzZXRBdHRyaWJ1dGUgaXMgYWxzbyB1c2VkXG5cdFx0XHRcdGVsZW0uZGVmYXVsdFZhbHVlID0gdmFsdWU7XG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdC8vIFVzZSBub2RlSG9vayBpZiBkZWZpbmVkICgjMTk1NCk7IG90aGVyd2lzZSBzZXRBdHRyaWJ1dGUgaXMgZmluZVxuXHRcdFx0XHRyZXR1cm4gbm9kZUhvb2sgJiYgbm9kZUhvb2suc2V0KCBlbGVtLCB2YWx1ZSwgbmFtZSApO1xuXHRcdFx0fVxuXHRcdH1cblx0fTtcbn1cblxuLy8gSUU2LzcgZG8gbm90IHN1cHBvcnQgZ2V0dGluZy9zZXR0aW5nIHNvbWUgYXR0cmlidXRlcyB3aXRoIGdldC9zZXRBdHRyaWJ1dGVcbmlmICggIWdldFNldEF0dHJpYnV0ZSApIHtcblxuXHQvLyBVc2UgdGhpcyBmb3IgYW55IGF0dHJpYnV0ZSBpbiBJRTYvN1xuXHQvLyBUaGlzIGZpeGVzIGFsbW9zdCBldmVyeSBJRTYvNyBpc3N1ZVxuXHRub2RlSG9vayA9IHtcblx0XHRzZXQ6IGZ1bmN0aW9uKCBlbGVtLCB2YWx1ZSwgbmFtZSApIHtcblxuXHRcdFx0Ly8gU2V0IHRoZSBleGlzdGluZyBvciBjcmVhdGUgYSBuZXcgYXR0cmlidXRlIG5vZGVcblx0XHRcdHZhciByZXQgPSBlbGVtLmdldEF0dHJpYnV0ZU5vZGUoIG5hbWUgKTtcblx0XHRcdGlmICggIXJldCApIHtcblx0XHRcdFx0ZWxlbS5zZXRBdHRyaWJ1dGVOb2RlKFxuXHRcdFx0XHRcdCggcmV0ID0gZWxlbS5vd25lckRvY3VtZW50LmNyZWF0ZUF0dHJpYnV0ZSggbmFtZSApIClcblx0XHRcdFx0KTtcblx0XHRcdH1cblxuXHRcdFx0cmV0LnZhbHVlID0gdmFsdWUgKz0gXCJcIjtcblxuXHRcdFx0Ly8gQnJlYWsgYXNzb2NpYXRpb24gd2l0aCBjbG9uZWQgZWxlbWVudHMgYnkgYWxzbyB1c2luZyBzZXRBdHRyaWJ1dGUgKCM5NjQ2KVxuXHRcdFx0aWYgKCBuYW1lID09PSBcInZhbHVlXCIgfHwgdmFsdWUgPT09IGVsZW0uZ2V0QXR0cmlidXRlKCBuYW1lICkgKSB7XG5cdFx0XHRcdHJldHVybiB2YWx1ZTtcblx0XHRcdH1cblx0XHR9XG5cdH07XG5cblx0Ly8gU29tZSBhdHRyaWJ1dGVzIGFyZSBjb25zdHJ1Y3RlZCB3aXRoIGVtcHR5LXN0cmluZyB2YWx1ZXMgd2hlbiBub3QgZGVmaW5lZFxuXHRhdHRySGFuZGxlLmlkID0gYXR0ckhhbmRsZS5uYW1lID0gYXR0ckhhbmRsZS5jb29yZHMgPVxuXHRcdGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCBpc1hNTCApIHtcblx0XHRcdHZhciByZXQ7XG5cdFx0XHRpZiAoICFpc1hNTCApIHtcblx0XHRcdFx0cmV0dXJuICggcmV0ID0gZWxlbS5nZXRBdHRyaWJ1dGVOb2RlKCBuYW1lICkgKSAmJiByZXQudmFsdWUgIT09IFwiXCIgP1xuXHRcdFx0XHRcdHJldC52YWx1ZSA6XG5cdFx0XHRcdFx0bnVsbDtcblx0XHRcdH1cblx0XHR9O1xuXG5cdC8vIEZpeGluZyB2YWx1ZSByZXRyaWV2YWwgb24gYSBidXR0b24gcmVxdWlyZXMgdGhpcyBtb2R1bGVcblx0alF1ZXJ5LnZhbEhvb2tzLmJ1dHRvbiA9IHtcblx0XHRnZXQ6IGZ1bmN0aW9uKCBlbGVtLCBuYW1lICkge1xuXHRcdFx0dmFyIHJldCA9IGVsZW0uZ2V0QXR0cmlidXRlTm9kZSggbmFtZSApO1xuXHRcdFx0aWYgKCByZXQgJiYgcmV0LnNwZWNpZmllZCApIHtcblx0XHRcdFx0cmV0dXJuIHJldC52YWx1ZTtcblx0XHRcdH1cblx0XHR9LFxuXHRcdHNldDogbm9kZUhvb2suc2V0XG5cdH07XG5cblx0Ly8gU2V0IGNvbnRlbnRlZGl0YWJsZSB0byBmYWxzZSBvbiByZW1vdmFscygjMTA0MjkpXG5cdC8vIFNldHRpbmcgdG8gZW1wdHkgc3RyaW5nIHRocm93cyBhbiBlcnJvciBhcyBhbiBpbnZhbGlkIHZhbHVlXG5cdGpRdWVyeS5hdHRySG9va3MuY29udGVudGVkaXRhYmxlID0ge1xuXHRcdHNldDogZnVuY3Rpb24oIGVsZW0sIHZhbHVlLCBuYW1lICkge1xuXHRcdFx0bm9kZUhvb2suc2V0KCBlbGVtLCB2YWx1ZSA9PT0gXCJcIiA/IGZhbHNlIDogdmFsdWUsIG5hbWUgKTtcblx0XHR9XG5cdH07XG5cblx0Ly8gU2V0IHdpZHRoIGFuZCBoZWlnaHQgdG8gYXV0byBpbnN0ZWFkIG9mIDAgb24gZW1wdHkgc3RyaW5nKCBCdWcgIzgxNTAgKVxuXHQvLyBUaGlzIGlzIGZvciByZW1vdmFsc1xuXHRqUXVlcnkuZWFjaCggWyBcIndpZHRoXCIsIFwiaGVpZ2h0XCIgXSwgZnVuY3Rpb24oIGksIG5hbWUgKSB7XG5cdFx0alF1ZXJ5LmF0dHJIb29rc1sgbmFtZSBdID0ge1xuXHRcdFx0c2V0OiBmdW5jdGlvbiggZWxlbSwgdmFsdWUgKSB7XG5cdFx0XHRcdGlmICggdmFsdWUgPT09IFwiXCIgKSB7XG5cdFx0XHRcdFx0ZWxlbS5zZXRBdHRyaWJ1dGUoIG5hbWUsIFwiYXV0b1wiICk7XG5cdFx0XHRcdFx0cmV0dXJuIHZhbHVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fTtcblx0fSApO1xufVxuXG5pZiAoICFzdXBwb3J0LnN0eWxlICkge1xuXHRqUXVlcnkuYXR0ckhvb2tzLnN0eWxlID0ge1xuXHRcdGdldDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cblx0XHRcdC8vIFJldHVybiB1bmRlZmluZWQgaW4gdGhlIGNhc2Ugb2YgZW1wdHkgc3RyaW5nXG5cdFx0XHQvLyBOb3RlOiBJRSB1cHBlcmNhc2VzIGNzcyBwcm9wZXJ0eSBuYW1lcywgYnV0IGlmIHdlIHdlcmUgdG8gLnRvTG93ZXJDYXNlKClcblx0XHRcdC8vIC5jc3NUZXh0LCB0aGF0IHdvdWxkIGRlc3Ryb3kgY2FzZSBzZW5zaXRpdml0eSBpbiBVUkwncywgbGlrZSBpbiBcImJhY2tncm91bmRcIlxuXHRcdFx0cmV0dXJuIGVsZW0uc3R5bGUuY3NzVGV4dCB8fCB1bmRlZmluZWQ7XG5cdFx0fSxcblx0XHRzZXQ6IGZ1bmN0aW9uKCBlbGVtLCB2YWx1ZSApIHtcblx0XHRcdHJldHVybiAoIGVsZW0uc3R5bGUuY3NzVGV4dCA9IHZhbHVlICsgXCJcIiApO1xuXHRcdH1cblx0fTtcbn1cblxuXG5cblxudmFyIHJmb2N1c2FibGUgPSAvXig/OmlucHV0fHNlbGVjdHx0ZXh0YXJlYXxidXR0b258b2JqZWN0KSQvaSxcblx0cmNsaWNrYWJsZSA9IC9eKD86YXxhcmVhKSQvaTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRwcm9wOiBmdW5jdGlvbiggbmFtZSwgdmFsdWUgKSB7XG5cdFx0cmV0dXJuIGFjY2VzcyggdGhpcywgalF1ZXJ5LnByb3AsIG5hbWUsIHZhbHVlLCBhcmd1bWVudHMubGVuZ3RoID4gMSApO1xuXHR9LFxuXG5cdHJlbW92ZVByb3A6IGZ1bmN0aW9uKCBuYW1lICkge1xuXHRcdG5hbWUgPSBqUXVlcnkucHJvcEZpeFsgbmFtZSBdIHx8IG5hbWU7XG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cblx0XHRcdC8vIHRyeS9jYXRjaCBoYW5kbGVzIGNhc2VzIHdoZXJlIElFIGJhbGtzIChzdWNoIGFzIHJlbW92aW5nIGEgcHJvcGVydHkgb24gd2luZG93KVxuXHRcdFx0dHJ5IHtcblx0XHRcdFx0dGhpc1sgbmFtZSBdID0gdW5kZWZpbmVkO1xuXHRcdFx0XHRkZWxldGUgdGhpc1sgbmFtZSBdO1xuXHRcdFx0fSBjYXRjaCAoIGUgKSB7fVxuXHRcdH0gKTtcblx0fVxufSApO1xuXG5qUXVlcnkuZXh0ZW5kKCB7XG5cdHByb3A6IGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCB2YWx1ZSApIHtcblx0XHR2YXIgcmV0LCBob29rcyxcblx0XHRcdG5UeXBlID0gZWxlbS5ub2RlVHlwZTtcblxuXHRcdC8vIERvbid0IGdldC9zZXQgcHJvcGVydGllcyBvbiB0ZXh0LCBjb21tZW50IGFuZCBhdHRyaWJ1dGUgbm9kZXNcblx0XHRpZiAoIG5UeXBlID09PSAzIHx8IG5UeXBlID09PSA4IHx8IG5UeXBlID09PSAyICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGlmICggblR5cGUgIT09IDEgfHwgIWpRdWVyeS5pc1hNTERvYyggZWxlbSApICkge1xuXG5cdFx0XHQvLyBGaXggbmFtZSBhbmQgYXR0YWNoIGhvb2tzXG5cdFx0XHRuYW1lID0galF1ZXJ5LnByb3BGaXhbIG5hbWUgXSB8fCBuYW1lO1xuXHRcdFx0aG9va3MgPSBqUXVlcnkucHJvcEhvb2tzWyBuYW1lIF07XG5cdFx0fVxuXG5cdFx0aWYgKCB2YWx1ZSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0aWYgKCBob29rcyAmJiBcInNldFwiIGluIGhvb2tzICYmXG5cdFx0XHRcdCggcmV0ID0gaG9va3Muc2V0KCBlbGVtLCB2YWx1ZSwgbmFtZSApICkgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0cmV0dXJuIHJldDtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuICggZWxlbVsgbmFtZSBdID0gdmFsdWUgKTtcblx0XHR9XG5cblx0XHRpZiAoIGhvb2tzICYmIFwiZ2V0XCIgaW4gaG9va3MgJiYgKCByZXQgPSBob29rcy5nZXQoIGVsZW0sIG5hbWUgKSApICE9PSBudWxsICkge1xuXHRcdFx0cmV0dXJuIHJldDtcblx0XHR9XG5cblx0XHRyZXR1cm4gZWxlbVsgbmFtZSBdO1xuXHR9LFxuXG5cdHByb3BIb29rczoge1xuXHRcdHRhYkluZGV4OiB7XG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCBlbGVtICkge1xuXG5cdFx0XHRcdC8vIGVsZW0udGFiSW5kZXggZG9lc24ndCBhbHdheXMgcmV0dXJuIHRoZVxuXHRcdFx0XHQvLyBjb3JyZWN0IHZhbHVlIHdoZW4gaXQgaGFzbid0IGJlZW4gZXhwbGljaXRseSBzZXRcblx0XHRcdFx0Ly8gaHR0cDovL2ZsdWlkcHJvamVjdC5vcmcvYmxvZy8yMDA4LzAxLzA5L2dldHRpbmctc2V0dGluZy1hbmQtcmVtb3ZpbmctdGFiaW5kZXgtdmFsdWVzLXdpdGgtamF2YXNjcmlwdC9cblx0XHRcdFx0Ly8gVXNlIHByb3BlciBhdHRyaWJ1dGUgcmV0cmlldmFsKCMxMjA3Milcblx0XHRcdFx0dmFyIHRhYmluZGV4ID0galF1ZXJ5LmZpbmQuYXR0ciggZWxlbSwgXCJ0YWJpbmRleFwiICk7XG5cblx0XHRcdFx0cmV0dXJuIHRhYmluZGV4ID9cblx0XHRcdFx0XHRwYXJzZUludCggdGFiaW5kZXgsIDEwICkgOlxuXHRcdFx0XHRcdHJmb2N1c2FibGUudGVzdCggZWxlbS5ub2RlTmFtZSApIHx8XG5cdFx0XHRcdFx0XHRyY2xpY2thYmxlLnRlc3QoIGVsZW0ubm9kZU5hbWUgKSAmJiBlbGVtLmhyZWYgP1xuXHRcdFx0XHRcdFx0XHQwIDpcblx0XHRcdFx0XHRcdFx0LTE7XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdHByb3BGaXg6IHtcblx0XHRcImZvclwiOiBcImh0bWxGb3JcIixcblx0XHRcImNsYXNzXCI6IFwiY2xhc3NOYW1lXCJcblx0fVxufSApO1xuXG4vLyBTb21lIGF0dHJpYnV0ZXMgcmVxdWlyZSBhIHNwZWNpYWwgY2FsbCBvbiBJRVxuLy8gaHR0cDovL21zZG4ubWljcm9zb2Z0LmNvbS9lbi11cy9saWJyYXJ5L21zNTM2NDI5JTI4VlMuODUlMjkuYXNweFxuaWYgKCAhc3VwcG9ydC5ocmVmTm9ybWFsaXplZCApIHtcblxuXHQvLyBocmVmL3NyYyBwcm9wZXJ0eSBzaG91bGQgZ2V0IHRoZSBmdWxsIG5vcm1hbGl6ZWQgVVJMICgjMTAyOTkvIzEyOTE1KVxuXHRqUXVlcnkuZWFjaCggWyBcImhyZWZcIiwgXCJzcmNcIiBdLCBmdW5jdGlvbiggaSwgbmFtZSApIHtcblx0XHRqUXVlcnkucHJvcEhvb2tzWyBuYW1lIF0gPSB7XG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHRyZXR1cm4gZWxlbS5nZXRBdHRyaWJ1dGUoIG5hbWUsIDQgKTtcblx0XHRcdH1cblx0XHR9O1xuXHR9ICk7XG59XG5cbi8vIFN1cHBvcnQ6IFNhZmFyaSwgSUU5K1xuLy8gQWNjZXNzaW5nIHRoZSBzZWxlY3RlZEluZGV4IHByb3BlcnR5XG4vLyBmb3JjZXMgdGhlIGJyb3dzZXIgdG8gcmVzcGVjdCBzZXR0aW5nIHNlbGVjdGVkXG4vLyBvbiB0aGUgb3B0aW9uXG4vLyBUaGUgZ2V0dGVyIGVuc3VyZXMgYSBkZWZhdWx0IG9wdGlvbiBpcyBzZWxlY3RlZFxuLy8gd2hlbiBpbiBhbiBvcHRncm91cFxuaWYgKCAhc3VwcG9ydC5vcHRTZWxlY3RlZCApIHtcblx0alF1ZXJ5LnByb3BIb29rcy5zZWxlY3RlZCA9IHtcblx0XHRnZXQ6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0dmFyIHBhcmVudCA9IGVsZW0ucGFyZW50Tm9kZTtcblxuXHRcdFx0aWYgKCBwYXJlbnQgKSB7XG5cdFx0XHRcdHBhcmVudC5zZWxlY3RlZEluZGV4O1xuXG5cdFx0XHRcdC8vIE1ha2Ugc3VyZSB0aGF0IGl0IGFsc28gd29ya3Mgd2l0aCBvcHRncm91cHMsIHNlZSAjNTcwMVxuXHRcdFx0XHRpZiAoIHBhcmVudC5wYXJlbnROb2RlICkge1xuXHRcdFx0XHRcdHBhcmVudC5wYXJlbnROb2RlLnNlbGVjdGVkSW5kZXg7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiBudWxsO1xuXHRcdH0sXG5cdFx0c2V0OiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHZhciBwYXJlbnQgPSBlbGVtLnBhcmVudE5vZGU7XG5cdFx0XHRpZiAoIHBhcmVudCApIHtcblx0XHRcdFx0cGFyZW50LnNlbGVjdGVkSW5kZXg7XG5cblx0XHRcdFx0aWYgKCBwYXJlbnQucGFyZW50Tm9kZSApIHtcblx0XHRcdFx0XHRwYXJlbnQucGFyZW50Tm9kZS5zZWxlY3RlZEluZGV4O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xufVxuXG5qUXVlcnkuZWFjaCggW1xuXHRcInRhYkluZGV4XCIsXG5cdFwicmVhZE9ubHlcIixcblx0XCJtYXhMZW5ndGhcIixcblx0XCJjZWxsU3BhY2luZ1wiLFxuXHRcImNlbGxQYWRkaW5nXCIsXG5cdFwicm93U3BhblwiLFxuXHRcImNvbFNwYW5cIixcblx0XCJ1c2VNYXBcIixcblx0XCJmcmFtZUJvcmRlclwiLFxuXHRcImNvbnRlbnRFZGl0YWJsZVwiXG5dLCBmdW5jdGlvbigpIHtcblx0alF1ZXJ5LnByb3BGaXhbIHRoaXMudG9Mb3dlckNhc2UoKSBdID0gdGhpcztcbn0gKTtcblxuLy8gSUU2LzcgY2FsbCBlbmN0eXBlIGVuY29kaW5nXG5pZiAoICFzdXBwb3J0LmVuY3R5cGUgKSB7XG5cdGpRdWVyeS5wcm9wRml4LmVuY3R5cGUgPSBcImVuY29kaW5nXCI7XG59XG5cblxuXG5cbnZhciByY2xhc3MgPSAvW1xcdFxcclxcblxcZl0vZztcblxuZnVuY3Rpb24gZ2V0Q2xhc3MoIGVsZW0gKSB7XG5cdHJldHVybiBqUXVlcnkuYXR0ciggZWxlbSwgXCJjbGFzc1wiICkgfHwgXCJcIjtcbn1cblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRhZGRDbGFzczogZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdHZhciBjbGFzc2VzLCBlbGVtLCBjdXIsIGN1clZhbHVlLCBjbGF6eiwgaiwgZmluYWxWYWx1ZSxcblx0XHRcdGkgPSAwO1xuXG5cdFx0aWYgKCBqUXVlcnkuaXNGdW5jdGlvbiggdmFsdWUgKSApIHtcblx0XHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCBqICkge1xuXHRcdFx0XHRqUXVlcnkoIHRoaXMgKS5hZGRDbGFzcyggdmFsdWUuY2FsbCggdGhpcywgaiwgZ2V0Q2xhc3MoIHRoaXMgKSApICk7XG5cdFx0XHR9ICk7XG5cdFx0fVxuXG5cdFx0aWYgKCB0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgJiYgdmFsdWUgKSB7XG5cdFx0XHRjbGFzc2VzID0gdmFsdWUubWF0Y2goIHJub3R3aGl0ZSApIHx8IFtdO1xuXG5cdFx0XHR3aGlsZSAoICggZWxlbSA9IHRoaXNbIGkrKyBdICkgKSB7XG5cdFx0XHRcdGN1clZhbHVlID0gZ2V0Q2xhc3MoIGVsZW0gKTtcblx0XHRcdFx0Y3VyID0gZWxlbS5ub2RlVHlwZSA9PT0gMSAmJlxuXHRcdFx0XHRcdCggXCIgXCIgKyBjdXJWYWx1ZSArIFwiIFwiICkucmVwbGFjZSggcmNsYXNzLCBcIiBcIiApO1xuXG5cdFx0XHRcdGlmICggY3VyICkge1xuXHRcdFx0XHRcdGogPSAwO1xuXHRcdFx0XHRcdHdoaWxlICggKCBjbGF6eiA9IGNsYXNzZXNbIGorKyBdICkgKSB7XG5cdFx0XHRcdFx0XHRpZiAoIGN1ci5pbmRleE9mKCBcIiBcIiArIGNsYXp6ICsgXCIgXCIgKSA8IDAgKSB7XG5cdFx0XHRcdFx0XHRcdGN1ciArPSBjbGF6eiArIFwiIFwiO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIG9ubHkgYXNzaWduIGlmIGRpZmZlcmVudCB0byBhdm9pZCB1bm5lZWRlZCByZW5kZXJpbmcuXG5cdFx0XHRcdFx0ZmluYWxWYWx1ZSA9IGpRdWVyeS50cmltKCBjdXIgKTtcblx0XHRcdFx0XHRpZiAoIGN1clZhbHVlICE9PSBmaW5hbFZhbHVlICkge1xuXHRcdFx0XHRcdFx0alF1ZXJ5LmF0dHIoIGVsZW0sIFwiY2xhc3NcIiwgZmluYWxWYWx1ZSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdHJlbW92ZUNsYXNzOiBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0dmFyIGNsYXNzZXMsIGVsZW0sIGN1ciwgY3VyVmFsdWUsIGNsYXp6LCBqLCBmaW5hbFZhbHVlLFxuXHRcdFx0aSA9IDA7XG5cblx0XHRpZiAoIGpRdWVyeS5pc0Z1bmN0aW9uKCB2YWx1ZSApICkge1xuXHRcdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oIGogKSB7XG5cdFx0XHRcdGpRdWVyeSggdGhpcyApLnJlbW92ZUNsYXNzKCB2YWx1ZS5jYWxsKCB0aGlzLCBqLCBnZXRDbGFzcyggdGhpcyApICkgKTtcblx0XHRcdH0gKTtcblx0XHR9XG5cblx0XHRpZiAoICFhcmd1bWVudHMubGVuZ3RoICkge1xuXHRcdFx0cmV0dXJuIHRoaXMuYXR0ciggXCJjbGFzc1wiLCBcIlwiICk7XG5cdFx0fVxuXG5cdFx0aWYgKCB0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgJiYgdmFsdWUgKSB7XG5cdFx0XHRjbGFzc2VzID0gdmFsdWUubWF0Y2goIHJub3R3aGl0ZSApIHx8IFtdO1xuXG5cdFx0XHR3aGlsZSAoICggZWxlbSA9IHRoaXNbIGkrKyBdICkgKSB7XG5cdFx0XHRcdGN1clZhbHVlID0gZ2V0Q2xhc3MoIGVsZW0gKTtcblxuXHRcdFx0XHQvLyBUaGlzIGV4cHJlc3Npb24gaXMgaGVyZSBmb3IgYmV0dGVyIGNvbXByZXNzaWJpbGl0eSAoc2VlIGFkZENsYXNzKVxuXHRcdFx0XHRjdXIgPSBlbGVtLm5vZGVUeXBlID09PSAxICYmXG5cdFx0XHRcdFx0KCBcIiBcIiArIGN1clZhbHVlICsgXCIgXCIgKS5yZXBsYWNlKCByY2xhc3MsIFwiIFwiICk7XG5cblx0XHRcdFx0aWYgKCBjdXIgKSB7XG5cdFx0XHRcdFx0aiA9IDA7XG5cdFx0XHRcdFx0d2hpbGUgKCAoIGNsYXp6ID0gY2xhc3Nlc1sgaisrIF0gKSApIHtcblxuXHRcdFx0XHRcdFx0Ly8gUmVtb3ZlICphbGwqIGluc3RhbmNlc1xuXHRcdFx0XHRcdFx0d2hpbGUgKCBjdXIuaW5kZXhPZiggXCIgXCIgKyBjbGF6eiArIFwiIFwiICkgPiAtMSApIHtcblx0XHRcdFx0XHRcdFx0Y3VyID0gY3VyLnJlcGxhY2UoIFwiIFwiICsgY2xhenogKyBcIiBcIiwgXCIgXCIgKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBPbmx5IGFzc2lnbiBpZiBkaWZmZXJlbnQgdG8gYXZvaWQgdW5uZWVkZWQgcmVuZGVyaW5nLlxuXHRcdFx0XHRcdGZpbmFsVmFsdWUgPSBqUXVlcnkudHJpbSggY3VyICk7XG5cdFx0XHRcdFx0aWYgKCBjdXJWYWx1ZSAhPT0gZmluYWxWYWx1ZSApIHtcblx0XHRcdFx0XHRcdGpRdWVyeS5hdHRyKCBlbGVtLCBcImNsYXNzXCIsIGZpbmFsVmFsdWUgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHR0b2dnbGVDbGFzczogZnVuY3Rpb24oIHZhbHVlLCBzdGF0ZVZhbCApIHtcblx0XHR2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcblxuXHRcdGlmICggdHlwZW9mIHN0YXRlVmFsID09PSBcImJvb2xlYW5cIiAmJiB0eXBlID09PSBcInN0cmluZ1wiICkge1xuXHRcdFx0cmV0dXJuIHN0YXRlVmFsID8gdGhpcy5hZGRDbGFzcyggdmFsdWUgKSA6IHRoaXMucmVtb3ZlQ2xhc3MoIHZhbHVlICk7XG5cdFx0fVxuXG5cdFx0aWYgKCBqUXVlcnkuaXNGdW5jdGlvbiggdmFsdWUgKSApIHtcblx0XHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCBpICkge1xuXHRcdFx0XHRqUXVlcnkoIHRoaXMgKS50b2dnbGVDbGFzcyhcblx0XHRcdFx0XHR2YWx1ZS5jYWxsKCB0aGlzLCBpLCBnZXRDbGFzcyggdGhpcyApLCBzdGF0ZVZhbCApLFxuXHRcdFx0XHRcdHN0YXRlVmFsXG5cdFx0XHRcdCk7XG5cdFx0XHR9ICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgY2xhc3NOYW1lLCBpLCBzZWxmLCBjbGFzc05hbWVzO1xuXG5cdFx0XHRpZiAoIHR5cGUgPT09IFwic3RyaW5nXCIgKSB7XG5cblx0XHRcdFx0Ly8gVG9nZ2xlIGluZGl2aWR1YWwgY2xhc3MgbmFtZXNcblx0XHRcdFx0aSA9IDA7XG5cdFx0XHRcdHNlbGYgPSBqUXVlcnkoIHRoaXMgKTtcblx0XHRcdFx0Y2xhc3NOYW1lcyA9IHZhbHVlLm1hdGNoKCBybm90d2hpdGUgKSB8fCBbXTtcblxuXHRcdFx0XHR3aGlsZSAoICggY2xhc3NOYW1lID0gY2xhc3NOYW1lc1sgaSsrIF0gKSApIHtcblxuXHRcdFx0XHRcdC8vIENoZWNrIGVhY2ggY2xhc3NOYW1lIGdpdmVuLCBzcGFjZSBzZXBhcmF0ZWQgbGlzdFxuXHRcdFx0XHRcdGlmICggc2VsZi5oYXNDbGFzcyggY2xhc3NOYW1lICkgKSB7XG5cdFx0XHRcdFx0XHRzZWxmLnJlbW92ZUNsYXNzKCBjbGFzc05hbWUgKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0c2VsZi5hZGRDbGFzcyggY2xhc3NOYW1lICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdC8vIFRvZ2dsZSB3aG9sZSBjbGFzcyBuYW1lXG5cdFx0XHR9IGVsc2UgaWYgKCB2YWx1ZSA9PT0gdW5kZWZpbmVkIHx8IHR5cGUgPT09IFwiYm9vbGVhblwiICkge1xuXHRcdFx0XHRjbGFzc05hbWUgPSBnZXRDbGFzcyggdGhpcyApO1xuXHRcdFx0XHRpZiAoIGNsYXNzTmFtZSApIHtcblxuXHRcdFx0XHRcdC8vIHN0b3JlIGNsYXNzTmFtZSBpZiBzZXRcblx0XHRcdFx0XHRqUXVlcnkuX2RhdGEoIHRoaXMsIFwiX19jbGFzc05hbWVfX1wiLCBjbGFzc05hbWUgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIElmIHRoZSBlbGVtZW50IGhhcyBhIGNsYXNzIG5hbWUgb3IgaWYgd2UncmUgcGFzc2VkIFwiZmFsc2VcIixcblx0XHRcdFx0Ly8gdGhlbiByZW1vdmUgdGhlIHdob2xlIGNsYXNzbmFtZSAoaWYgdGhlcmUgd2FzIG9uZSwgdGhlIGFib3ZlIHNhdmVkIGl0KS5cblx0XHRcdFx0Ly8gT3RoZXJ3aXNlIGJyaW5nIGJhY2sgd2hhdGV2ZXIgd2FzIHByZXZpb3VzbHkgc2F2ZWQgKGlmIGFueXRoaW5nKSxcblx0XHRcdFx0Ly8gZmFsbGluZyBiYWNrIHRvIHRoZSBlbXB0eSBzdHJpbmcgaWYgbm90aGluZyB3YXMgc3RvcmVkLlxuXHRcdFx0XHRqUXVlcnkuYXR0ciggdGhpcywgXCJjbGFzc1wiLFxuXHRcdFx0XHRcdGNsYXNzTmFtZSB8fCB2YWx1ZSA9PT0gZmFsc2UgP1xuXHRcdFx0XHRcdFwiXCIgOlxuXHRcdFx0XHRcdGpRdWVyeS5fZGF0YSggdGhpcywgXCJfX2NsYXNzTmFtZV9fXCIgKSB8fCBcIlwiXG5cdFx0XHRcdCk7XG5cdFx0XHR9XG5cdFx0fSApO1xuXHR9LFxuXG5cdGhhc0NsYXNzOiBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0dmFyIGNsYXNzTmFtZSwgZWxlbSxcblx0XHRcdGkgPSAwO1xuXG5cdFx0Y2xhc3NOYW1lID0gXCIgXCIgKyBzZWxlY3RvciArIFwiIFwiO1xuXHRcdHdoaWxlICggKCBlbGVtID0gdGhpc1sgaSsrIF0gKSApIHtcblx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSAmJlxuXHRcdFx0XHQoIFwiIFwiICsgZ2V0Q2xhc3MoIGVsZW0gKSArIFwiIFwiICkucmVwbGFjZSggcmNsYXNzLCBcIiBcIiApXG5cdFx0XHRcdFx0LmluZGV4T2YoIGNsYXNzTmFtZSApID4gLTFcblx0XHRcdCkge1xuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cbn0gKTtcblxuXG5cblxuLy8gUmV0dXJuIGpRdWVyeSBmb3IgYXR0cmlidXRlcy1vbmx5IGluY2x1c2lvblxuXG5cbmpRdWVyeS5lYWNoKCAoIFwiYmx1ciBmb2N1cyBmb2N1c2luIGZvY3Vzb3V0IGxvYWQgcmVzaXplIHNjcm9sbCB1bmxvYWQgY2xpY2sgZGJsY2xpY2sgXCIgK1xuXHRcIm1vdXNlZG93biBtb3VzZXVwIG1vdXNlbW92ZSBtb3VzZW92ZXIgbW91c2VvdXQgbW91c2VlbnRlciBtb3VzZWxlYXZlIFwiICtcblx0XCJjaGFuZ2Ugc2VsZWN0IHN1Ym1pdCBrZXlkb3duIGtleXByZXNzIGtleXVwIGVycm9yIGNvbnRleHRtZW51XCIgKS5zcGxpdCggXCIgXCIgKSxcblx0ZnVuY3Rpb24oIGksIG5hbWUgKSB7XG5cblx0Ly8gSGFuZGxlIGV2ZW50IGJpbmRpbmdcblx0alF1ZXJ5LmZuWyBuYW1lIF0gPSBmdW5jdGlvbiggZGF0YSwgZm4gKSB7XG5cdFx0cmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPiAwID9cblx0XHRcdHRoaXMub24oIG5hbWUsIG51bGwsIGRhdGEsIGZuICkgOlxuXHRcdFx0dGhpcy50cmlnZ2VyKCBuYW1lICk7XG5cdH07XG59ICk7XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0aG92ZXI6IGZ1bmN0aW9uKCBmbk92ZXIsIGZuT3V0ICkge1xuXHRcdHJldHVybiB0aGlzLm1vdXNlZW50ZXIoIGZuT3ZlciApLm1vdXNlbGVhdmUoIGZuT3V0IHx8IGZuT3ZlciApO1xuXHR9XG59ICk7XG5cblxudmFyIGxvY2F0aW9uID0gd2luZG93LmxvY2F0aW9uO1xuXG52YXIgbm9uY2UgPSBqUXVlcnkubm93KCk7XG5cbnZhciBycXVlcnkgPSAoIC9cXD8vICk7XG5cblxuXG52YXIgcnZhbGlkdG9rZW5zID0gLygsKXwoXFxbfHspfCh9fF0pfFwiKD86W15cIlxcXFxcXHJcXG5dfFxcXFxbXCJcXFxcXFwvYmZucnRdfFxcXFx1W1xcZGEtZkEtRl17NH0pKlwiXFxzKjo/fHRydWV8ZmFsc2V8bnVsbHwtPyg/ITBcXGQpXFxkKyg/OlxcLlxcZCt8KSg/OltlRV1bKy1dP1xcZCt8KS9nO1xuXG5qUXVlcnkucGFyc2VKU09OID0gZnVuY3Rpb24oIGRhdGEgKSB7XG5cblx0Ly8gQXR0ZW1wdCB0byBwYXJzZSB1c2luZyB0aGUgbmF0aXZlIEpTT04gcGFyc2VyIGZpcnN0XG5cdGlmICggd2luZG93LkpTT04gJiYgd2luZG93LkpTT04ucGFyc2UgKSB7XG5cblx0XHQvLyBTdXBwb3J0OiBBbmRyb2lkIDIuM1xuXHRcdC8vIFdvcmthcm91bmQgZmFpbHVyZSB0byBzdHJpbmctY2FzdCBudWxsIGlucHV0XG5cdFx0cmV0dXJuIHdpbmRvdy5KU09OLnBhcnNlKCBkYXRhICsgXCJcIiApO1xuXHR9XG5cblx0dmFyIHJlcXVpcmVOb25Db21tYSxcblx0XHRkZXB0aCA9IG51bGwsXG5cdFx0c3RyID0galF1ZXJ5LnRyaW0oIGRhdGEgKyBcIlwiICk7XG5cblx0Ly8gR3VhcmQgYWdhaW5zdCBpbnZhbGlkIChhbmQgcG9zc2libHkgZGFuZ2Vyb3VzKSBpbnB1dCBieSBlbnN1cmluZyB0aGF0IG5vdGhpbmcgcmVtYWluc1xuXHQvLyBhZnRlciByZW1vdmluZyB2YWxpZCB0b2tlbnNcblx0cmV0dXJuIHN0ciAmJiAhalF1ZXJ5LnRyaW0oIHN0ci5yZXBsYWNlKCBydmFsaWR0b2tlbnMsIGZ1bmN0aW9uKCB0b2tlbiwgY29tbWEsIG9wZW4sIGNsb3NlICkge1xuXG5cdFx0Ly8gRm9yY2UgdGVybWluYXRpb24gaWYgd2Ugc2VlIGEgbWlzcGxhY2VkIGNvbW1hXG5cdFx0aWYgKCByZXF1aXJlTm9uQ29tbWEgJiYgY29tbWEgKSB7XG5cdFx0XHRkZXB0aCA9IDA7XG5cdFx0fVxuXG5cdFx0Ly8gUGVyZm9ybSBubyBtb3JlIHJlcGxhY2VtZW50cyBhZnRlciByZXR1cm5pbmcgdG8gb3V0ZXJtb3N0IGRlcHRoXG5cdFx0aWYgKCBkZXB0aCA9PT0gMCApIHtcblx0XHRcdHJldHVybiB0b2tlbjtcblx0XHR9XG5cblx0XHQvLyBDb21tYXMgbXVzdCBub3QgZm9sbG93IFwiW1wiLCBcIntcIiwgb3IgXCIsXCJcblx0XHRyZXF1aXJlTm9uQ29tbWEgPSBvcGVuIHx8IGNvbW1hO1xuXG5cdFx0Ly8gRGV0ZXJtaW5lIG5ldyBkZXB0aFxuXHRcdC8vIGFycmF5L29iamVjdCBvcGVuIChcIltcIiBvciBcIntcIik6IGRlcHRoICs9IHRydWUgLSBmYWxzZSAoaW5jcmVtZW50KVxuXHRcdC8vIGFycmF5L29iamVjdCBjbG9zZSAoXCJdXCIgb3IgXCJ9XCIpOiBkZXB0aCArPSBmYWxzZSAtIHRydWUgKGRlY3JlbWVudClcblx0XHQvLyBvdGhlciBjYXNlcyAoXCIsXCIgb3IgcHJpbWl0aXZlKTogZGVwdGggKz0gdHJ1ZSAtIHRydWUgKG51bWVyaWMgY2FzdClcblx0XHRkZXB0aCArPSAhY2xvc2UgLSAhb3BlbjtcblxuXHRcdC8vIFJlbW92ZSB0aGlzIHRva2VuXG5cdFx0cmV0dXJuIFwiXCI7XG5cdH0gKSApID9cblx0XHQoIEZ1bmN0aW9uKCBcInJldHVybiBcIiArIHN0ciApICkoKSA6XG5cdFx0alF1ZXJ5LmVycm9yKCBcIkludmFsaWQgSlNPTjogXCIgKyBkYXRhICk7XG59O1xuXG5cbi8vIENyb3NzLWJyb3dzZXIgeG1sIHBhcnNpbmdcbmpRdWVyeS5wYXJzZVhNTCA9IGZ1bmN0aW9uKCBkYXRhICkge1xuXHR2YXIgeG1sLCB0bXA7XG5cdGlmICggIWRhdGEgfHwgdHlwZW9mIGRhdGEgIT09IFwic3RyaW5nXCIgKSB7XG5cdFx0cmV0dXJuIG51bGw7XG5cdH1cblx0dHJ5IHtcblx0XHRpZiAoIHdpbmRvdy5ET01QYXJzZXIgKSB7IC8vIFN0YW5kYXJkXG5cdFx0XHR0bXAgPSBuZXcgd2luZG93LkRPTVBhcnNlcigpO1xuXHRcdFx0eG1sID0gdG1wLnBhcnNlRnJvbVN0cmluZyggZGF0YSwgXCJ0ZXh0L3htbFwiICk7XG5cdFx0fSBlbHNlIHsgLy8gSUVcblx0XHRcdHhtbCA9IG5ldyB3aW5kb3cuQWN0aXZlWE9iamVjdCggXCJNaWNyb3NvZnQuWE1MRE9NXCIgKTtcblx0XHRcdHhtbC5hc3luYyA9IFwiZmFsc2VcIjtcblx0XHRcdHhtbC5sb2FkWE1MKCBkYXRhICk7XG5cdFx0fVxuXHR9IGNhdGNoICggZSApIHtcblx0XHR4bWwgPSB1bmRlZmluZWQ7XG5cdH1cblx0aWYgKCAheG1sIHx8ICF4bWwuZG9jdW1lbnRFbGVtZW50IHx8IHhtbC5nZXRFbGVtZW50c0J5VGFnTmFtZSggXCJwYXJzZXJlcnJvclwiICkubGVuZ3RoICkge1xuXHRcdGpRdWVyeS5lcnJvciggXCJJbnZhbGlkIFhNTDogXCIgKyBkYXRhICk7XG5cdH1cblx0cmV0dXJuIHhtbDtcbn07XG5cblxudmFyXG5cdHJoYXNoID0gLyMuKiQvLFxuXHRydHMgPSAvKFs/Jl0pXz1bXiZdKi8sXG5cblx0Ly8gSUUgbGVhdmVzIGFuIFxcciBjaGFyYWN0ZXIgYXQgRU9MXG5cdHJoZWFkZXJzID0gL14oLio/KTpbIFxcdF0qKFteXFxyXFxuXSopXFxyPyQvbWcsXG5cblx0Ly8gIzc2NTMsICM4MTI1LCAjODE1MjogbG9jYWwgcHJvdG9jb2wgZGV0ZWN0aW9uXG5cdHJsb2NhbFByb3RvY29sID0gL14oPzphYm91dHxhcHB8YXBwLXN0b3JhZ2V8ListZXh0ZW5zaW9ufGZpbGV8cmVzfHdpZGdldCk6JC8sXG5cdHJub0NvbnRlbnQgPSAvXig/OkdFVHxIRUFEKSQvLFxuXHRycHJvdG9jb2wgPSAvXlxcL1xcLy8sXG5cdHJ1cmwgPSAvXihbXFx3ListXSs6KSg/OlxcL1xcLyg/OlteXFwvPyNdKkB8KShbXlxcLz8jOl0qKSg/OjooXFxkKyl8KXwpLyxcblxuXHQvKiBQcmVmaWx0ZXJzXG5cdCAqIDEpIFRoZXkgYXJlIHVzZWZ1bCB0byBpbnRyb2R1Y2UgY3VzdG9tIGRhdGFUeXBlcyAoc2VlIGFqYXgvanNvbnAuanMgZm9yIGFuIGV4YW1wbGUpXG5cdCAqIDIpIFRoZXNlIGFyZSBjYWxsZWQ6XG5cdCAqICAgIC0gQkVGT1JFIGFza2luZyBmb3IgYSB0cmFuc3BvcnRcblx0ICogICAgLSBBRlRFUiBwYXJhbSBzZXJpYWxpemF0aW9uIChzLmRhdGEgaXMgYSBzdHJpbmcgaWYgcy5wcm9jZXNzRGF0YSBpcyB0cnVlKVxuXHQgKiAzKSBrZXkgaXMgdGhlIGRhdGFUeXBlXG5cdCAqIDQpIHRoZSBjYXRjaGFsbCBzeW1ib2wgXCIqXCIgY2FuIGJlIHVzZWRcblx0ICogNSkgZXhlY3V0aW9uIHdpbGwgc3RhcnQgd2l0aCB0cmFuc3BvcnQgZGF0YVR5cGUgYW5kIFRIRU4gY29udGludWUgZG93biB0byBcIipcIiBpZiBuZWVkZWRcblx0ICovXG5cdHByZWZpbHRlcnMgPSB7fSxcblxuXHQvKiBUcmFuc3BvcnRzIGJpbmRpbmdzXG5cdCAqIDEpIGtleSBpcyB0aGUgZGF0YVR5cGVcblx0ICogMikgdGhlIGNhdGNoYWxsIHN5bWJvbCBcIipcIiBjYW4gYmUgdXNlZFxuXHQgKiAzKSBzZWxlY3Rpb24gd2lsbCBzdGFydCB3aXRoIHRyYW5zcG9ydCBkYXRhVHlwZSBhbmQgVEhFTiBnbyB0byBcIipcIiBpZiBuZWVkZWRcblx0ICovXG5cdHRyYW5zcG9ydHMgPSB7fSxcblxuXHQvLyBBdm9pZCBjb21tZW50LXByb2xvZyBjaGFyIHNlcXVlbmNlICgjMTAwOTgpOyBtdXN0IGFwcGVhc2UgbGludCBhbmQgZXZhZGUgY29tcHJlc3Npb25cblx0YWxsVHlwZXMgPSBcIiovXCIuY29uY2F0KCBcIipcIiApLFxuXG5cdC8vIERvY3VtZW50IGxvY2F0aW9uXG5cdGFqYXhMb2NhdGlvbiA9IGxvY2F0aW9uLmhyZWYsXG5cblx0Ly8gU2VnbWVudCBsb2NhdGlvbiBpbnRvIHBhcnRzXG5cdGFqYXhMb2NQYXJ0cyA9IHJ1cmwuZXhlYyggYWpheExvY2F0aW9uLnRvTG93ZXJDYXNlKCkgKSB8fCBbXTtcblxuLy8gQmFzZSBcImNvbnN0cnVjdG9yXCIgZm9yIGpRdWVyeS5hamF4UHJlZmlsdGVyIGFuZCBqUXVlcnkuYWpheFRyYW5zcG9ydFxuZnVuY3Rpb24gYWRkVG9QcmVmaWx0ZXJzT3JUcmFuc3BvcnRzKCBzdHJ1Y3R1cmUgKSB7XG5cblx0Ly8gZGF0YVR5cGVFeHByZXNzaW9uIGlzIG9wdGlvbmFsIGFuZCBkZWZhdWx0cyB0byBcIipcIlxuXHRyZXR1cm4gZnVuY3Rpb24oIGRhdGFUeXBlRXhwcmVzc2lvbiwgZnVuYyApIHtcblxuXHRcdGlmICggdHlwZW9mIGRhdGFUeXBlRXhwcmVzc2lvbiAhPT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdGZ1bmMgPSBkYXRhVHlwZUV4cHJlc3Npb247XG5cdFx0XHRkYXRhVHlwZUV4cHJlc3Npb24gPSBcIipcIjtcblx0XHR9XG5cblx0XHR2YXIgZGF0YVR5cGUsXG5cdFx0XHRpID0gMCxcblx0XHRcdGRhdGFUeXBlcyA9IGRhdGFUeXBlRXhwcmVzc2lvbi50b0xvd2VyQ2FzZSgpLm1hdGNoKCBybm90d2hpdGUgKSB8fCBbXTtcblxuXHRcdGlmICggalF1ZXJ5LmlzRnVuY3Rpb24oIGZ1bmMgKSApIHtcblxuXHRcdFx0Ly8gRm9yIGVhY2ggZGF0YVR5cGUgaW4gdGhlIGRhdGFUeXBlRXhwcmVzc2lvblxuXHRcdFx0d2hpbGUgKCAoIGRhdGFUeXBlID0gZGF0YVR5cGVzWyBpKysgXSApICkge1xuXG5cdFx0XHRcdC8vIFByZXBlbmQgaWYgcmVxdWVzdGVkXG5cdFx0XHRcdGlmICggZGF0YVR5cGUuY2hhckF0KCAwICkgPT09IFwiK1wiICkge1xuXHRcdFx0XHRcdGRhdGFUeXBlID0gZGF0YVR5cGUuc2xpY2UoIDEgKSB8fCBcIipcIjtcblx0XHRcdFx0XHQoIHN0cnVjdHVyZVsgZGF0YVR5cGUgXSA9IHN0cnVjdHVyZVsgZGF0YVR5cGUgXSB8fCBbXSApLnVuc2hpZnQoIGZ1bmMgKTtcblxuXHRcdFx0XHQvLyBPdGhlcndpc2UgYXBwZW5kXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0KCBzdHJ1Y3R1cmVbIGRhdGFUeXBlIF0gPSBzdHJ1Y3R1cmVbIGRhdGFUeXBlIF0gfHwgW10gKS5wdXNoKCBmdW5jICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH07XG59XG5cbi8vIEJhc2UgaW5zcGVjdGlvbiBmdW5jdGlvbiBmb3IgcHJlZmlsdGVycyBhbmQgdHJhbnNwb3J0c1xuZnVuY3Rpb24gaW5zcGVjdFByZWZpbHRlcnNPclRyYW5zcG9ydHMoIHN0cnVjdHVyZSwgb3B0aW9ucywgb3JpZ2luYWxPcHRpb25zLCBqcVhIUiApIHtcblxuXHR2YXIgaW5zcGVjdGVkID0ge30sXG5cdFx0c2Vla2luZ1RyYW5zcG9ydCA9ICggc3RydWN0dXJlID09PSB0cmFuc3BvcnRzICk7XG5cblx0ZnVuY3Rpb24gaW5zcGVjdCggZGF0YVR5cGUgKSB7XG5cdFx0dmFyIHNlbGVjdGVkO1xuXHRcdGluc3BlY3RlZFsgZGF0YVR5cGUgXSA9IHRydWU7XG5cdFx0alF1ZXJ5LmVhY2goIHN0cnVjdHVyZVsgZGF0YVR5cGUgXSB8fCBbXSwgZnVuY3Rpb24oIF8sIHByZWZpbHRlck9yRmFjdG9yeSApIHtcblx0XHRcdHZhciBkYXRhVHlwZU9yVHJhbnNwb3J0ID0gcHJlZmlsdGVyT3JGYWN0b3J5KCBvcHRpb25zLCBvcmlnaW5hbE9wdGlvbnMsIGpxWEhSICk7XG5cdFx0XHRpZiAoIHR5cGVvZiBkYXRhVHlwZU9yVHJhbnNwb3J0ID09PSBcInN0cmluZ1wiICYmXG5cdFx0XHRcdCFzZWVraW5nVHJhbnNwb3J0ICYmICFpbnNwZWN0ZWRbIGRhdGFUeXBlT3JUcmFuc3BvcnQgXSApIHtcblxuXHRcdFx0XHRvcHRpb25zLmRhdGFUeXBlcy51bnNoaWZ0KCBkYXRhVHlwZU9yVHJhbnNwb3J0ICk7XG5cdFx0XHRcdGluc3BlY3QoIGRhdGFUeXBlT3JUcmFuc3BvcnQgKTtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fSBlbHNlIGlmICggc2Vla2luZ1RyYW5zcG9ydCApIHtcblx0XHRcdFx0cmV0dXJuICEoIHNlbGVjdGVkID0gZGF0YVR5cGVPclRyYW5zcG9ydCApO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0XHRyZXR1cm4gc2VsZWN0ZWQ7XG5cdH1cblxuXHRyZXR1cm4gaW5zcGVjdCggb3B0aW9ucy5kYXRhVHlwZXNbIDAgXSApIHx8ICFpbnNwZWN0ZWRbIFwiKlwiIF0gJiYgaW5zcGVjdCggXCIqXCIgKTtcbn1cblxuLy8gQSBzcGVjaWFsIGV4dGVuZCBmb3IgYWpheCBvcHRpb25zXG4vLyB0aGF0IHRha2VzIFwiZmxhdFwiIG9wdGlvbnMgKG5vdCB0byBiZSBkZWVwIGV4dGVuZGVkKVxuLy8gRml4ZXMgIzk4ODdcbmZ1bmN0aW9uIGFqYXhFeHRlbmQoIHRhcmdldCwgc3JjICkge1xuXHR2YXIgZGVlcCwga2V5LFxuXHRcdGZsYXRPcHRpb25zID0galF1ZXJ5LmFqYXhTZXR0aW5ncy5mbGF0T3B0aW9ucyB8fCB7fTtcblxuXHRmb3IgKCBrZXkgaW4gc3JjICkge1xuXHRcdGlmICggc3JjWyBrZXkgXSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0KCBmbGF0T3B0aW9uc1sga2V5IF0gPyB0YXJnZXQgOiAoIGRlZXAgfHwgKCBkZWVwID0ge30gKSApIClbIGtleSBdID0gc3JjWyBrZXkgXTtcblx0XHR9XG5cdH1cblx0aWYgKCBkZWVwICkge1xuXHRcdGpRdWVyeS5leHRlbmQoIHRydWUsIHRhcmdldCwgZGVlcCApO1xuXHR9XG5cblx0cmV0dXJuIHRhcmdldDtcbn1cblxuLyogSGFuZGxlcyByZXNwb25zZXMgdG8gYW4gYWpheCByZXF1ZXN0OlxuICogLSBmaW5kcyB0aGUgcmlnaHQgZGF0YVR5cGUgKG1lZGlhdGVzIGJldHdlZW4gY29udGVudC10eXBlIGFuZCBleHBlY3RlZCBkYXRhVHlwZSlcbiAqIC0gcmV0dXJucyB0aGUgY29ycmVzcG9uZGluZyByZXNwb25zZVxuICovXG5mdW5jdGlvbiBhamF4SGFuZGxlUmVzcG9uc2VzKCBzLCBqcVhIUiwgcmVzcG9uc2VzICkge1xuXHR2YXIgZmlyc3REYXRhVHlwZSwgY3QsIGZpbmFsRGF0YVR5cGUsIHR5cGUsXG5cdFx0Y29udGVudHMgPSBzLmNvbnRlbnRzLFxuXHRcdGRhdGFUeXBlcyA9IHMuZGF0YVR5cGVzO1xuXG5cdC8vIFJlbW92ZSBhdXRvIGRhdGFUeXBlIGFuZCBnZXQgY29udGVudC10eXBlIGluIHRoZSBwcm9jZXNzXG5cdHdoaWxlICggZGF0YVR5cGVzWyAwIF0gPT09IFwiKlwiICkge1xuXHRcdGRhdGFUeXBlcy5zaGlmdCgpO1xuXHRcdGlmICggY3QgPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdGN0ID0gcy5taW1lVHlwZSB8fCBqcVhIUi5nZXRSZXNwb25zZUhlYWRlciggXCJDb250ZW50LVR5cGVcIiApO1xuXHRcdH1cblx0fVxuXG5cdC8vIENoZWNrIGlmIHdlJ3JlIGRlYWxpbmcgd2l0aCBhIGtub3duIGNvbnRlbnQtdHlwZVxuXHRpZiAoIGN0ICkge1xuXHRcdGZvciAoIHR5cGUgaW4gY29udGVudHMgKSB7XG5cdFx0XHRpZiAoIGNvbnRlbnRzWyB0eXBlIF0gJiYgY29udGVudHNbIHR5cGUgXS50ZXN0KCBjdCApICkge1xuXHRcdFx0XHRkYXRhVHlwZXMudW5zaGlmdCggdHlwZSApO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvLyBDaGVjayB0byBzZWUgaWYgd2UgaGF2ZSBhIHJlc3BvbnNlIGZvciB0aGUgZXhwZWN0ZWQgZGF0YVR5cGVcblx0aWYgKCBkYXRhVHlwZXNbIDAgXSBpbiByZXNwb25zZXMgKSB7XG5cdFx0ZmluYWxEYXRhVHlwZSA9IGRhdGFUeXBlc1sgMCBdO1xuXHR9IGVsc2Uge1xuXG5cdFx0Ly8gVHJ5IGNvbnZlcnRpYmxlIGRhdGFUeXBlc1xuXHRcdGZvciAoIHR5cGUgaW4gcmVzcG9uc2VzICkge1xuXHRcdFx0aWYgKCAhZGF0YVR5cGVzWyAwIF0gfHwgcy5jb252ZXJ0ZXJzWyB0eXBlICsgXCIgXCIgKyBkYXRhVHlwZXNbIDAgXSBdICkge1xuXHRcdFx0XHRmaW5hbERhdGFUeXBlID0gdHlwZTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0XHRpZiAoICFmaXJzdERhdGFUeXBlICkge1xuXHRcdFx0XHRmaXJzdERhdGFUeXBlID0gdHlwZTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBPciBqdXN0IHVzZSBmaXJzdCBvbmVcblx0XHRmaW5hbERhdGFUeXBlID0gZmluYWxEYXRhVHlwZSB8fCBmaXJzdERhdGFUeXBlO1xuXHR9XG5cblx0Ly8gSWYgd2UgZm91bmQgYSBkYXRhVHlwZVxuXHQvLyBXZSBhZGQgdGhlIGRhdGFUeXBlIHRvIHRoZSBsaXN0IGlmIG5lZWRlZFxuXHQvLyBhbmQgcmV0dXJuIHRoZSBjb3JyZXNwb25kaW5nIHJlc3BvbnNlXG5cdGlmICggZmluYWxEYXRhVHlwZSApIHtcblx0XHRpZiAoIGZpbmFsRGF0YVR5cGUgIT09IGRhdGFUeXBlc1sgMCBdICkge1xuXHRcdFx0ZGF0YVR5cGVzLnVuc2hpZnQoIGZpbmFsRGF0YVR5cGUgKTtcblx0XHR9XG5cdFx0cmV0dXJuIHJlc3BvbnNlc1sgZmluYWxEYXRhVHlwZSBdO1xuXHR9XG59XG5cbi8qIENoYWluIGNvbnZlcnNpb25zIGdpdmVuIHRoZSByZXF1ZXN0IGFuZCB0aGUgb3JpZ2luYWwgcmVzcG9uc2VcbiAqIEFsc28gc2V0cyB0aGUgcmVzcG9uc2VYWFggZmllbGRzIG9uIHRoZSBqcVhIUiBpbnN0YW5jZVxuICovXG5mdW5jdGlvbiBhamF4Q29udmVydCggcywgcmVzcG9uc2UsIGpxWEhSLCBpc1N1Y2Nlc3MgKSB7XG5cdHZhciBjb252MiwgY3VycmVudCwgY29udiwgdG1wLCBwcmV2LFxuXHRcdGNvbnZlcnRlcnMgPSB7fSxcblxuXHRcdC8vIFdvcmsgd2l0aCBhIGNvcHkgb2YgZGF0YVR5cGVzIGluIGNhc2Ugd2UgbmVlZCB0byBtb2RpZnkgaXQgZm9yIGNvbnZlcnNpb25cblx0XHRkYXRhVHlwZXMgPSBzLmRhdGFUeXBlcy5zbGljZSgpO1xuXG5cdC8vIENyZWF0ZSBjb252ZXJ0ZXJzIG1hcCB3aXRoIGxvd2VyY2FzZWQga2V5c1xuXHRpZiAoIGRhdGFUeXBlc1sgMSBdICkge1xuXHRcdGZvciAoIGNvbnYgaW4gcy5jb252ZXJ0ZXJzICkge1xuXHRcdFx0Y29udmVydGVyc1sgY29udi50b0xvd2VyQ2FzZSgpIF0gPSBzLmNvbnZlcnRlcnNbIGNvbnYgXTtcblx0XHR9XG5cdH1cblxuXHRjdXJyZW50ID0gZGF0YVR5cGVzLnNoaWZ0KCk7XG5cblx0Ly8gQ29udmVydCB0byBlYWNoIHNlcXVlbnRpYWwgZGF0YVR5cGVcblx0d2hpbGUgKCBjdXJyZW50ICkge1xuXG5cdFx0aWYgKCBzLnJlc3BvbnNlRmllbGRzWyBjdXJyZW50IF0gKSB7XG5cdFx0XHRqcVhIUlsgcy5yZXNwb25zZUZpZWxkc1sgY3VycmVudCBdIF0gPSByZXNwb25zZTtcblx0XHR9XG5cblx0XHQvLyBBcHBseSB0aGUgZGF0YUZpbHRlciBpZiBwcm92aWRlZFxuXHRcdGlmICggIXByZXYgJiYgaXNTdWNjZXNzICYmIHMuZGF0YUZpbHRlciApIHtcblx0XHRcdHJlc3BvbnNlID0gcy5kYXRhRmlsdGVyKCByZXNwb25zZSwgcy5kYXRhVHlwZSApO1xuXHRcdH1cblxuXHRcdHByZXYgPSBjdXJyZW50O1xuXHRcdGN1cnJlbnQgPSBkYXRhVHlwZXMuc2hpZnQoKTtcblxuXHRcdGlmICggY3VycmVudCApIHtcblxuXHRcdFx0Ly8gVGhlcmUncyBvbmx5IHdvcmsgdG8gZG8gaWYgY3VycmVudCBkYXRhVHlwZSBpcyBub24tYXV0b1xuXHRcdFx0aWYgKCBjdXJyZW50ID09PSBcIipcIiApIHtcblxuXHRcdFx0XHRjdXJyZW50ID0gcHJldjtcblxuXHRcdFx0Ly8gQ29udmVydCByZXNwb25zZSBpZiBwcmV2IGRhdGFUeXBlIGlzIG5vbi1hdXRvIGFuZCBkaWZmZXJzIGZyb20gY3VycmVudFxuXHRcdFx0fSBlbHNlIGlmICggcHJldiAhPT0gXCIqXCIgJiYgcHJldiAhPT0gY3VycmVudCApIHtcblxuXHRcdFx0XHQvLyBTZWVrIGEgZGlyZWN0IGNvbnZlcnRlclxuXHRcdFx0XHRjb252ID0gY29udmVydGVyc1sgcHJldiArIFwiIFwiICsgY3VycmVudCBdIHx8IGNvbnZlcnRlcnNbIFwiKiBcIiArIGN1cnJlbnQgXTtcblxuXHRcdFx0XHQvLyBJZiBub25lIGZvdW5kLCBzZWVrIGEgcGFpclxuXHRcdFx0XHRpZiAoICFjb252ICkge1xuXHRcdFx0XHRcdGZvciAoIGNvbnYyIGluIGNvbnZlcnRlcnMgKSB7XG5cblx0XHRcdFx0XHRcdC8vIElmIGNvbnYyIG91dHB1dHMgY3VycmVudFxuXHRcdFx0XHRcdFx0dG1wID0gY29udjIuc3BsaXQoIFwiIFwiICk7XG5cdFx0XHRcdFx0XHRpZiAoIHRtcFsgMSBdID09PSBjdXJyZW50ICkge1xuXG5cdFx0XHRcdFx0XHRcdC8vIElmIHByZXYgY2FuIGJlIGNvbnZlcnRlZCB0byBhY2NlcHRlZCBpbnB1dFxuXHRcdFx0XHRcdFx0XHRjb252ID0gY29udmVydGVyc1sgcHJldiArIFwiIFwiICsgdG1wWyAwIF0gXSB8fFxuXHRcdFx0XHRcdFx0XHRcdGNvbnZlcnRlcnNbIFwiKiBcIiArIHRtcFsgMCBdIF07XG5cdFx0XHRcdFx0XHRcdGlmICggY29udiApIHtcblxuXHRcdFx0XHRcdFx0XHRcdC8vIENvbmRlbnNlIGVxdWl2YWxlbmNlIGNvbnZlcnRlcnNcblx0XHRcdFx0XHRcdFx0XHRpZiAoIGNvbnYgPT09IHRydWUgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRjb252ID0gY29udmVydGVyc1sgY29udjIgXTtcblxuXHRcdFx0XHRcdFx0XHRcdC8vIE90aGVyd2lzZSwgaW5zZXJ0IHRoZSBpbnRlcm1lZGlhdGUgZGF0YVR5cGVcblx0XHRcdFx0XHRcdFx0XHR9IGVsc2UgaWYgKCBjb252ZXJ0ZXJzWyBjb252MiBdICE9PSB0cnVlICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0Y3VycmVudCA9IHRtcFsgMCBdO1xuXHRcdFx0XHRcdFx0XHRcdFx0ZGF0YVR5cGVzLnVuc2hpZnQoIHRtcFsgMSBdICk7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gQXBwbHkgY29udmVydGVyIChpZiBub3QgYW4gZXF1aXZhbGVuY2UpXG5cdFx0XHRcdGlmICggY29udiAhPT0gdHJ1ZSApIHtcblxuXHRcdFx0XHRcdC8vIFVubGVzcyBlcnJvcnMgYXJlIGFsbG93ZWQgdG8gYnViYmxlLCBjYXRjaCBhbmQgcmV0dXJuIHRoZW1cblx0XHRcdFx0XHRpZiAoIGNvbnYgJiYgc1sgXCJ0aHJvd3NcIiBdICkgeyAvLyBqc2NzOmlnbm9yZSByZXF1aXJlRG90Tm90YXRpb25cblx0XHRcdFx0XHRcdHJlc3BvbnNlID0gY29udiggcmVzcG9uc2UgKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRcdFx0cmVzcG9uc2UgPSBjb252KCByZXNwb25zZSApO1xuXHRcdFx0XHRcdFx0fSBjYXRjaCAoIGUgKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiB7XG5cdFx0XHRcdFx0XHRcdFx0c3RhdGU6IFwicGFyc2VyZXJyb3JcIixcblx0XHRcdFx0XHRcdFx0XHRlcnJvcjogY29udiA/IGUgOiBcIk5vIGNvbnZlcnNpb24gZnJvbSBcIiArIHByZXYgKyBcIiB0byBcIiArIGN1cnJlbnRcblx0XHRcdFx0XHRcdFx0fTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4geyBzdGF0ZTogXCJzdWNjZXNzXCIsIGRhdGE6IHJlc3BvbnNlIH07XG59XG5cbmpRdWVyeS5leHRlbmQoIHtcblxuXHQvLyBDb3VudGVyIGZvciBob2xkaW5nIHRoZSBudW1iZXIgb2YgYWN0aXZlIHF1ZXJpZXNcblx0YWN0aXZlOiAwLFxuXG5cdC8vIExhc3QtTW9kaWZpZWQgaGVhZGVyIGNhY2hlIGZvciBuZXh0IHJlcXVlc3Rcblx0bGFzdE1vZGlmaWVkOiB7fSxcblx0ZXRhZzoge30sXG5cblx0YWpheFNldHRpbmdzOiB7XG5cdFx0dXJsOiBhamF4TG9jYXRpb24sXG5cdFx0dHlwZTogXCJHRVRcIixcblx0XHRpc0xvY2FsOiBybG9jYWxQcm90b2NvbC50ZXN0KCBhamF4TG9jUGFydHNbIDEgXSApLFxuXHRcdGdsb2JhbDogdHJ1ZSxcblx0XHRwcm9jZXNzRGF0YTogdHJ1ZSxcblx0XHRhc3luYzogdHJ1ZSxcblx0XHRjb250ZW50VHlwZTogXCJhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQ7IGNoYXJzZXQ9VVRGLThcIixcblx0XHQvKlxuXHRcdHRpbWVvdXQ6IDAsXG5cdFx0ZGF0YTogbnVsbCxcblx0XHRkYXRhVHlwZTogbnVsbCxcblx0XHR1c2VybmFtZTogbnVsbCxcblx0XHRwYXNzd29yZDogbnVsbCxcblx0XHRjYWNoZTogbnVsbCxcblx0XHR0aHJvd3M6IGZhbHNlLFxuXHRcdHRyYWRpdGlvbmFsOiBmYWxzZSxcblx0XHRoZWFkZXJzOiB7fSxcblx0XHQqL1xuXG5cdFx0YWNjZXB0czoge1xuXHRcdFx0XCIqXCI6IGFsbFR5cGVzLFxuXHRcdFx0dGV4dDogXCJ0ZXh0L3BsYWluXCIsXG5cdFx0XHRodG1sOiBcInRleHQvaHRtbFwiLFxuXHRcdFx0eG1sOiBcImFwcGxpY2F0aW9uL3htbCwgdGV4dC94bWxcIixcblx0XHRcdGpzb246IFwiYXBwbGljYXRpb24vanNvbiwgdGV4dC9qYXZhc2NyaXB0XCJcblx0XHR9LFxuXG5cdFx0Y29udGVudHM6IHtcblx0XHRcdHhtbDogL1xcYnhtbFxcYi8sXG5cdFx0XHRodG1sOiAvXFxiaHRtbC8sXG5cdFx0XHRqc29uOiAvXFxianNvblxcYi9cblx0XHR9LFxuXG5cdFx0cmVzcG9uc2VGaWVsZHM6IHtcblx0XHRcdHhtbDogXCJyZXNwb25zZVhNTFwiLFxuXHRcdFx0dGV4dDogXCJyZXNwb25zZVRleHRcIixcblx0XHRcdGpzb246IFwicmVzcG9uc2VKU09OXCJcblx0XHR9LFxuXG5cdFx0Ly8gRGF0YSBjb252ZXJ0ZXJzXG5cdFx0Ly8gS2V5cyBzZXBhcmF0ZSBzb3VyY2UgKG9yIGNhdGNoYWxsIFwiKlwiKSBhbmQgZGVzdGluYXRpb24gdHlwZXMgd2l0aCBhIHNpbmdsZSBzcGFjZVxuXHRcdGNvbnZlcnRlcnM6IHtcblxuXHRcdFx0Ly8gQ29udmVydCBhbnl0aGluZyB0byB0ZXh0XG5cdFx0XHRcIiogdGV4dFwiOiBTdHJpbmcsXG5cblx0XHRcdC8vIFRleHQgdG8gaHRtbCAodHJ1ZSA9IG5vIHRyYW5zZm9ybWF0aW9uKVxuXHRcdFx0XCJ0ZXh0IGh0bWxcIjogdHJ1ZSxcblxuXHRcdFx0Ly8gRXZhbHVhdGUgdGV4dCBhcyBhIGpzb24gZXhwcmVzc2lvblxuXHRcdFx0XCJ0ZXh0IGpzb25cIjogalF1ZXJ5LnBhcnNlSlNPTixcblxuXHRcdFx0Ly8gUGFyc2UgdGV4dCBhcyB4bWxcblx0XHRcdFwidGV4dCB4bWxcIjogalF1ZXJ5LnBhcnNlWE1MXG5cdFx0fSxcblxuXHRcdC8vIEZvciBvcHRpb25zIHRoYXQgc2hvdWxkbid0IGJlIGRlZXAgZXh0ZW5kZWQ6XG5cdFx0Ly8geW91IGNhbiBhZGQgeW91ciBvd24gY3VzdG9tIG9wdGlvbnMgaGVyZSBpZlxuXHRcdC8vIGFuZCB3aGVuIHlvdSBjcmVhdGUgb25lIHRoYXQgc2hvdWxkbid0IGJlXG5cdFx0Ly8gZGVlcCBleHRlbmRlZCAoc2VlIGFqYXhFeHRlbmQpXG5cdFx0ZmxhdE9wdGlvbnM6IHtcblx0XHRcdHVybDogdHJ1ZSxcblx0XHRcdGNvbnRleHQ6IHRydWVcblx0XHR9XG5cdH0sXG5cblx0Ly8gQ3JlYXRlcyBhIGZ1bGwgZmxlZGdlZCBzZXR0aW5ncyBvYmplY3QgaW50byB0YXJnZXRcblx0Ly8gd2l0aCBib3RoIGFqYXhTZXR0aW5ncyBhbmQgc2V0dGluZ3MgZmllbGRzLlxuXHQvLyBJZiB0YXJnZXQgaXMgb21pdHRlZCwgd3JpdGVzIGludG8gYWpheFNldHRpbmdzLlxuXHRhamF4U2V0dXA6IGZ1bmN0aW9uKCB0YXJnZXQsIHNldHRpbmdzICkge1xuXHRcdHJldHVybiBzZXR0aW5ncyA/XG5cblx0XHRcdC8vIEJ1aWxkaW5nIGEgc2V0dGluZ3Mgb2JqZWN0XG5cdFx0XHRhamF4RXh0ZW5kKCBhamF4RXh0ZW5kKCB0YXJnZXQsIGpRdWVyeS5hamF4U2V0dGluZ3MgKSwgc2V0dGluZ3MgKSA6XG5cblx0XHRcdC8vIEV4dGVuZGluZyBhamF4U2V0dGluZ3Ncblx0XHRcdGFqYXhFeHRlbmQoIGpRdWVyeS5hamF4U2V0dGluZ3MsIHRhcmdldCApO1xuXHR9LFxuXG5cdGFqYXhQcmVmaWx0ZXI6IGFkZFRvUHJlZmlsdGVyc09yVHJhbnNwb3J0cyggcHJlZmlsdGVycyApLFxuXHRhamF4VHJhbnNwb3J0OiBhZGRUb1ByZWZpbHRlcnNPclRyYW5zcG9ydHMoIHRyYW5zcG9ydHMgKSxcblxuXHQvLyBNYWluIG1ldGhvZFxuXHRhamF4OiBmdW5jdGlvbiggdXJsLCBvcHRpb25zICkge1xuXG5cdFx0Ly8gSWYgdXJsIGlzIGFuIG9iamVjdCwgc2ltdWxhdGUgcHJlLTEuNSBzaWduYXR1cmVcblx0XHRpZiAoIHR5cGVvZiB1cmwgPT09IFwib2JqZWN0XCIgKSB7XG5cdFx0XHRvcHRpb25zID0gdXJsO1xuXHRcdFx0dXJsID0gdW5kZWZpbmVkO1xuXHRcdH1cblxuXHRcdC8vIEZvcmNlIG9wdGlvbnMgdG8gYmUgYW4gb2JqZWN0XG5cdFx0b3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cblx0XHR2YXJcblxuXHRcdFx0Ly8gQ3Jvc3MtZG9tYWluIGRldGVjdGlvbiB2YXJzXG5cdFx0XHRwYXJ0cyxcblxuXHRcdFx0Ly8gTG9vcCB2YXJpYWJsZVxuXHRcdFx0aSxcblxuXHRcdFx0Ly8gVVJMIHdpdGhvdXQgYW50aS1jYWNoZSBwYXJhbVxuXHRcdFx0Y2FjaGVVUkwsXG5cblx0XHRcdC8vIFJlc3BvbnNlIGhlYWRlcnMgYXMgc3RyaW5nXG5cdFx0XHRyZXNwb25zZUhlYWRlcnNTdHJpbmcsXG5cblx0XHRcdC8vIHRpbWVvdXQgaGFuZGxlXG5cdFx0XHR0aW1lb3V0VGltZXIsXG5cblx0XHRcdC8vIFRvIGtub3cgaWYgZ2xvYmFsIGV2ZW50cyBhcmUgdG8gYmUgZGlzcGF0Y2hlZFxuXHRcdFx0ZmlyZUdsb2JhbHMsXG5cblx0XHRcdHRyYW5zcG9ydCxcblxuXHRcdFx0Ly8gUmVzcG9uc2UgaGVhZGVyc1xuXHRcdFx0cmVzcG9uc2VIZWFkZXJzLFxuXG5cdFx0XHQvLyBDcmVhdGUgdGhlIGZpbmFsIG9wdGlvbnMgb2JqZWN0XG5cdFx0XHRzID0galF1ZXJ5LmFqYXhTZXR1cCgge30sIG9wdGlvbnMgKSxcblxuXHRcdFx0Ly8gQ2FsbGJhY2tzIGNvbnRleHRcblx0XHRcdGNhbGxiYWNrQ29udGV4dCA9IHMuY29udGV4dCB8fCBzLFxuXG5cdFx0XHQvLyBDb250ZXh0IGZvciBnbG9iYWwgZXZlbnRzIGlzIGNhbGxiYWNrQ29udGV4dCBpZiBpdCBpcyBhIERPTSBub2RlIG9yIGpRdWVyeSBjb2xsZWN0aW9uXG5cdFx0XHRnbG9iYWxFdmVudENvbnRleHQgPSBzLmNvbnRleHQgJiZcblx0XHRcdFx0KCBjYWxsYmFja0NvbnRleHQubm9kZVR5cGUgfHwgY2FsbGJhY2tDb250ZXh0LmpxdWVyeSApID9cblx0XHRcdFx0XHRqUXVlcnkoIGNhbGxiYWNrQ29udGV4dCApIDpcblx0XHRcdFx0XHRqUXVlcnkuZXZlbnQsXG5cblx0XHRcdC8vIERlZmVycmVkc1xuXHRcdFx0ZGVmZXJyZWQgPSBqUXVlcnkuRGVmZXJyZWQoKSxcblx0XHRcdGNvbXBsZXRlRGVmZXJyZWQgPSBqUXVlcnkuQ2FsbGJhY2tzKCBcIm9uY2UgbWVtb3J5XCIgKSxcblxuXHRcdFx0Ly8gU3RhdHVzLWRlcGVuZGVudCBjYWxsYmFja3Ncblx0XHRcdHN0YXR1c0NvZGUgPSBzLnN0YXR1c0NvZGUgfHwge30sXG5cblx0XHRcdC8vIEhlYWRlcnMgKHRoZXkgYXJlIHNlbnQgYWxsIGF0IG9uY2UpXG5cdFx0XHRyZXF1ZXN0SGVhZGVycyA9IHt9LFxuXHRcdFx0cmVxdWVzdEhlYWRlcnNOYW1lcyA9IHt9LFxuXG5cdFx0XHQvLyBUaGUganFYSFIgc3RhdGVcblx0XHRcdHN0YXRlID0gMCxcblxuXHRcdFx0Ly8gRGVmYXVsdCBhYm9ydCBtZXNzYWdlXG5cdFx0XHRzdHJBYm9ydCA9IFwiY2FuY2VsZWRcIixcblxuXHRcdFx0Ly8gRmFrZSB4aHJcblx0XHRcdGpxWEhSID0ge1xuXHRcdFx0XHRyZWFkeVN0YXRlOiAwLFxuXG5cdFx0XHRcdC8vIEJ1aWxkcyBoZWFkZXJzIGhhc2h0YWJsZSBpZiBuZWVkZWRcblx0XHRcdFx0Z2V0UmVzcG9uc2VIZWFkZXI6IGZ1bmN0aW9uKCBrZXkgKSB7XG5cdFx0XHRcdFx0dmFyIG1hdGNoO1xuXHRcdFx0XHRcdGlmICggc3RhdGUgPT09IDIgKSB7XG5cdFx0XHRcdFx0XHRpZiAoICFyZXNwb25zZUhlYWRlcnMgKSB7XG5cdFx0XHRcdFx0XHRcdHJlc3BvbnNlSGVhZGVycyA9IHt9O1xuXHRcdFx0XHRcdFx0XHR3aGlsZSAoICggbWF0Y2ggPSByaGVhZGVycy5leGVjKCByZXNwb25zZUhlYWRlcnNTdHJpbmcgKSApICkge1xuXHRcdFx0XHRcdFx0XHRcdHJlc3BvbnNlSGVhZGVyc1sgbWF0Y2hbIDEgXS50b0xvd2VyQ2FzZSgpIF0gPSBtYXRjaFsgMiBdO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRtYXRjaCA9IHJlc3BvbnNlSGVhZGVyc1sga2V5LnRvTG93ZXJDYXNlKCkgXTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIG1hdGNoID09IG51bGwgPyBudWxsIDogbWF0Y2g7XG5cdFx0XHRcdH0sXG5cblx0XHRcdFx0Ly8gUmF3IHN0cmluZ1xuXHRcdFx0XHRnZXRBbGxSZXNwb25zZUhlYWRlcnM6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdHJldHVybiBzdGF0ZSA9PT0gMiA/IHJlc3BvbnNlSGVhZGVyc1N0cmluZyA6IG51bGw7XG5cdFx0XHRcdH0sXG5cblx0XHRcdFx0Ly8gQ2FjaGVzIHRoZSBoZWFkZXJcblx0XHRcdFx0c2V0UmVxdWVzdEhlYWRlcjogZnVuY3Rpb24oIG5hbWUsIHZhbHVlICkge1xuXHRcdFx0XHRcdHZhciBsbmFtZSA9IG5hbWUudG9Mb3dlckNhc2UoKTtcblx0XHRcdFx0XHRpZiAoICFzdGF0ZSApIHtcblx0XHRcdFx0XHRcdG5hbWUgPSByZXF1ZXN0SGVhZGVyc05hbWVzWyBsbmFtZSBdID0gcmVxdWVzdEhlYWRlcnNOYW1lc1sgbG5hbWUgXSB8fCBuYW1lO1xuXHRcdFx0XHRcdFx0cmVxdWVzdEhlYWRlcnNbIG5hbWUgXSA9IHZhbHVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdFx0fSxcblxuXHRcdFx0XHQvLyBPdmVycmlkZXMgcmVzcG9uc2UgY29udGVudC10eXBlIGhlYWRlclxuXHRcdFx0XHRvdmVycmlkZU1pbWVUeXBlOiBmdW5jdGlvbiggdHlwZSApIHtcblx0XHRcdFx0XHRpZiAoICFzdGF0ZSApIHtcblx0XHRcdFx0XHRcdHMubWltZVR5cGUgPSB0eXBlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdFx0fSxcblxuXHRcdFx0XHQvLyBTdGF0dXMtZGVwZW5kZW50IGNhbGxiYWNrc1xuXHRcdFx0XHRzdGF0dXNDb2RlOiBmdW5jdGlvbiggbWFwICkge1xuXHRcdFx0XHRcdHZhciBjb2RlO1xuXHRcdFx0XHRcdGlmICggbWFwICkge1xuXHRcdFx0XHRcdFx0aWYgKCBzdGF0ZSA8IDIgKSB7XG5cdFx0XHRcdFx0XHRcdGZvciAoIGNvZGUgaW4gbWFwICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gTGF6eS1hZGQgdGhlIG5ldyBjYWxsYmFjayBpbiBhIHdheSB0aGF0IHByZXNlcnZlcyBvbGQgb25lc1xuXHRcdFx0XHRcdFx0XHRcdHN0YXR1c0NvZGVbIGNvZGUgXSA9IFsgc3RhdHVzQ29kZVsgY29kZSBdLCBtYXBbIGNvZGUgXSBdO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRcdC8vIEV4ZWN1dGUgdGhlIGFwcHJvcHJpYXRlIGNhbGxiYWNrc1xuXHRcdFx0XHRcdFx0XHRqcVhIUi5hbHdheXMoIG1hcFsganFYSFIuc3RhdHVzIF0gKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHRcdH0sXG5cblx0XHRcdFx0Ly8gQ2FuY2VsIHRoZSByZXF1ZXN0XG5cdFx0XHRcdGFib3J0OiBmdW5jdGlvbiggc3RhdHVzVGV4dCApIHtcblx0XHRcdFx0XHR2YXIgZmluYWxUZXh0ID0gc3RhdHVzVGV4dCB8fCBzdHJBYm9ydDtcblx0XHRcdFx0XHRpZiAoIHRyYW5zcG9ydCApIHtcblx0XHRcdFx0XHRcdHRyYW5zcG9ydC5hYm9ydCggZmluYWxUZXh0ICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGRvbmUoIDAsIGZpbmFsVGV4dCApO1xuXHRcdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXG5cdFx0Ly8gQXR0YWNoIGRlZmVycmVkc1xuXHRcdGRlZmVycmVkLnByb21pc2UoIGpxWEhSICkuY29tcGxldGUgPSBjb21wbGV0ZURlZmVycmVkLmFkZDtcblx0XHRqcVhIUi5zdWNjZXNzID0ganFYSFIuZG9uZTtcblx0XHRqcVhIUi5lcnJvciA9IGpxWEhSLmZhaWw7XG5cblx0XHQvLyBSZW1vdmUgaGFzaCBjaGFyYWN0ZXIgKCM3NTMxOiBhbmQgc3RyaW5nIHByb21vdGlvbilcblx0XHQvLyBBZGQgcHJvdG9jb2wgaWYgbm90IHByb3ZpZGVkICgjNTg2NjogSUU3IGlzc3VlIHdpdGggcHJvdG9jb2wtbGVzcyB1cmxzKVxuXHRcdC8vIEhhbmRsZSBmYWxzeSB1cmwgaW4gdGhlIHNldHRpbmdzIG9iamVjdCAoIzEwMDkzOiBjb25zaXN0ZW5jeSB3aXRoIG9sZCBzaWduYXR1cmUpXG5cdFx0Ly8gV2UgYWxzbyB1c2UgdGhlIHVybCBwYXJhbWV0ZXIgaWYgYXZhaWxhYmxlXG5cdFx0cy51cmwgPSAoICggdXJsIHx8IHMudXJsIHx8IGFqYXhMb2NhdGlvbiApICsgXCJcIiApXG5cdFx0XHQucmVwbGFjZSggcmhhc2gsIFwiXCIgKVxuXHRcdFx0LnJlcGxhY2UoIHJwcm90b2NvbCwgYWpheExvY1BhcnRzWyAxIF0gKyBcIi8vXCIgKTtcblxuXHRcdC8vIEFsaWFzIG1ldGhvZCBvcHRpb24gdG8gdHlwZSBhcyBwZXIgdGlja2V0ICMxMjAwNFxuXHRcdHMudHlwZSA9IG9wdGlvbnMubWV0aG9kIHx8IG9wdGlvbnMudHlwZSB8fCBzLm1ldGhvZCB8fCBzLnR5cGU7XG5cblx0XHQvLyBFeHRyYWN0IGRhdGFUeXBlcyBsaXN0XG5cdFx0cy5kYXRhVHlwZXMgPSBqUXVlcnkudHJpbSggcy5kYXRhVHlwZSB8fCBcIipcIiApLnRvTG93ZXJDYXNlKCkubWF0Y2goIHJub3R3aGl0ZSApIHx8IFsgXCJcIiBdO1xuXG5cdFx0Ly8gQSBjcm9zcy1kb21haW4gcmVxdWVzdCBpcyBpbiBvcmRlciB3aGVuIHdlIGhhdmUgYSBwcm90b2NvbDpob3N0OnBvcnQgbWlzbWF0Y2hcblx0XHRpZiAoIHMuY3Jvc3NEb21haW4gPT0gbnVsbCApIHtcblx0XHRcdHBhcnRzID0gcnVybC5leGVjKCBzLnVybC50b0xvd2VyQ2FzZSgpICk7XG5cdFx0XHRzLmNyb3NzRG9tYWluID0gISEoIHBhcnRzICYmXG5cdFx0XHRcdCggcGFydHNbIDEgXSAhPT0gYWpheExvY1BhcnRzWyAxIF0gfHwgcGFydHNbIDIgXSAhPT0gYWpheExvY1BhcnRzWyAyIF0gfHxcblx0XHRcdFx0XHQoIHBhcnRzWyAzIF0gfHwgKCBwYXJ0c1sgMSBdID09PSBcImh0dHA6XCIgPyBcIjgwXCIgOiBcIjQ0M1wiICkgKSAhPT1cblx0XHRcdFx0XHRcdCggYWpheExvY1BhcnRzWyAzIF0gfHwgKCBhamF4TG9jUGFydHNbIDEgXSA9PT0gXCJodHRwOlwiID8gXCI4MFwiIDogXCI0NDNcIiApICkgKVxuXHRcdFx0KTtcblx0XHR9XG5cblx0XHQvLyBDb252ZXJ0IGRhdGEgaWYgbm90IGFscmVhZHkgYSBzdHJpbmdcblx0XHRpZiAoIHMuZGF0YSAmJiBzLnByb2Nlc3NEYXRhICYmIHR5cGVvZiBzLmRhdGEgIT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRzLmRhdGEgPSBqUXVlcnkucGFyYW0oIHMuZGF0YSwgcy50cmFkaXRpb25hbCApO1xuXHRcdH1cblxuXHRcdC8vIEFwcGx5IHByZWZpbHRlcnNcblx0XHRpbnNwZWN0UHJlZmlsdGVyc09yVHJhbnNwb3J0cyggcHJlZmlsdGVycywgcywgb3B0aW9ucywganFYSFIgKTtcblxuXHRcdC8vIElmIHJlcXVlc3Qgd2FzIGFib3J0ZWQgaW5zaWRlIGEgcHJlZmlsdGVyLCBzdG9wIHRoZXJlXG5cdFx0aWYgKCBzdGF0ZSA9PT0gMiApIHtcblx0XHRcdHJldHVybiBqcVhIUjtcblx0XHR9XG5cblx0XHQvLyBXZSBjYW4gZmlyZSBnbG9iYWwgZXZlbnRzIGFzIG9mIG5vdyBpZiBhc2tlZCB0b1xuXHRcdC8vIERvbid0IGZpcmUgZXZlbnRzIGlmIGpRdWVyeS5ldmVudCBpcyB1bmRlZmluZWQgaW4gYW4gQU1ELXVzYWdlIHNjZW5hcmlvICgjMTUxMTgpXG5cdFx0ZmlyZUdsb2JhbHMgPSBqUXVlcnkuZXZlbnQgJiYgcy5nbG9iYWw7XG5cblx0XHQvLyBXYXRjaCBmb3IgYSBuZXcgc2V0IG9mIHJlcXVlc3RzXG5cdFx0aWYgKCBmaXJlR2xvYmFscyAmJiBqUXVlcnkuYWN0aXZlKysgPT09IDAgKSB7XG5cdFx0XHRqUXVlcnkuZXZlbnQudHJpZ2dlciggXCJhamF4U3RhcnRcIiApO1xuXHRcdH1cblxuXHRcdC8vIFVwcGVyY2FzZSB0aGUgdHlwZVxuXHRcdHMudHlwZSA9IHMudHlwZS50b1VwcGVyQ2FzZSgpO1xuXG5cdFx0Ly8gRGV0ZXJtaW5lIGlmIHJlcXVlc3QgaGFzIGNvbnRlbnRcblx0XHRzLmhhc0NvbnRlbnQgPSAhcm5vQ29udGVudC50ZXN0KCBzLnR5cGUgKTtcblxuXHRcdC8vIFNhdmUgdGhlIFVSTCBpbiBjYXNlIHdlJ3JlIHRveWluZyB3aXRoIHRoZSBJZi1Nb2RpZmllZC1TaW5jZVxuXHRcdC8vIGFuZC9vciBJZi1Ob25lLU1hdGNoIGhlYWRlciBsYXRlciBvblxuXHRcdGNhY2hlVVJMID0gcy51cmw7XG5cblx0XHQvLyBNb3JlIG9wdGlvbnMgaGFuZGxpbmcgZm9yIHJlcXVlc3RzIHdpdGggbm8gY29udGVudFxuXHRcdGlmICggIXMuaGFzQ29udGVudCApIHtcblxuXHRcdFx0Ly8gSWYgZGF0YSBpcyBhdmFpbGFibGUsIGFwcGVuZCBkYXRhIHRvIHVybFxuXHRcdFx0aWYgKCBzLmRhdGEgKSB7XG5cdFx0XHRcdGNhY2hlVVJMID0gKCBzLnVybCArPSAoIHJxdWVyeS50ZXN0KCBjYWNoZVVSTCApID8gXCImXCIgOiBcIj9cIiApICsgcy5kYXRhICk7XG5cblx0XHRcdFx0Ly8gIzk2ODI6IHJlbW92ZSBkYXRhIHNvIHRoYXQgaXQncyBub3QgdXNlZCBpbiBhbiBldmVudHVhbCByZXRyeVxuXHRcdFx0XHRkZWxldGUgcy5kYXRhO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBBZGQgYW50aS1jYWNoZSBpbiB1cmwgaWYgbmVlZGVkXG5cdFx0XHRpZiAoIHMuY2FjaGUgPT09IGZhbHNlICkge1xuXHRcdFx0XHRzLnVybCA9IHJ0cy50ZXN0KCBjYWNoZVVSTCApID9cblxuXHRcdFx0XHRcdC8vIElmIHRoZXJlIGlzIGFscmVhZHkgYSAnXycgcGFyYW1ldGVyLCBzZXQgaXRzIHZhbHVlXG5cdFx0XHRcdFx0Y2FjaGVVUkwucmVwbGFjZSggcnRzLCBcIiQxXz1cIiArIG5vbmNlKysgKSA6XG5cblx0XHRcdFx0XHQvLyBPdGhlcndpc2UgYWRkIG9uZSB0byB0aGUgZW5kXG5cdFx0XHRcdFx0Y2FjaGVVUkwgKyAoIHJxdWVyeS50ZXN0KCBjYWNoZVVSTCApID8gXCImXCIgOiBcIj9cIiApICsgXCJfPVwiICsgbm9uY2UrKztcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBTZXQgdGhlIElmLU1vZGlmaWVkLVNpbmNlIGFuZC9vciBJZi1Ob25lLU1hdGNoIGhlYWRlciwgaWYgaW4gaWZNb2RpZmllZCBtb2RlLlxuXHRcdGlmICggcy5pZk1vZGlmaWVkICkge1xuXHRcdFx0aWYgKCBqUXVlcnkubGFzdE1vZGlmaWVkWyBjYWNoZVVSTCBdICkge1xuXHRcdFx0XHRqcVhIUi5zZXRSZXF1ZXN0SGVhZGVyKCBcIklmLU1vZGlmaWVkLVNpbmNlXCIsIGpRdWVyeS5sYXN0TW9kaWZpZWRbIGNhY2hlVVJMIF0gKTtcblx0XHRcdH1cblx0XHRcdGlmICggalF1ZXJ5LmV0YWdbIGNhY2hlVVJMIF0gKSB7XG5cdFx0XHRcdGpxWEhSLnNldFJlcXVlc3RIZWFkZXIoIFwiSWYtTm9uZS1NYXRjaFwiLCBqUXVlcnkuZXRhZ1sgY2FjaGVVUkwgXSApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIFNldCB0aGUgY29ycmVjdCBoZWFkZXIsIGlmIGRhdGEgaXMgYmVpbmcgc2VudFxuXHRcdGlmICggcy5kYXRhICYmIHMuaGFzQ29udGVudCAmJiBzLmNvbnRlbnRUeXBlICE9PSBmYWxzZSB8fCBvcHRpb25zLmNvbnRlbnRUeXBlICkge1xuXHRcdFx0anFYSFIuc2V0UmVxdWVzdEhlYWRlciggXCJDb250ZW50LVR5cGVcIiwgcy5jb250ZW50VHlwZSApO1xuXHRcdH1cblxuXHRcdC8vIFNldCB0aGUgQWNjZXB0cyBoZWFkZXIgZm9yIHRoZSBzZXJ2ZXIsIGRlcGVuZGluZyBvbiB0aGUgZGF0YVR5cGVcblx0XHRqcVhIUi5zZXRSZXF1ZXN0SGVhZGVyKFxuXHRcdFx0XCJBY2NlcHRcIixcblx0XHRcdHMuZGF0YVR5cGVzWyAwIF0gJiYgcy5hY2NlcHRzWyBzLmRhdGFUeXBlc1sgMCBdIF0gP1xuXHRcdFx0XHRzLmFjY2VwdHNbIHMuZGF0YVR5cGVzWyAwIF0gXSArXG5cdFx0XHRcdFx0KCBzLmRhdGFUeXBlc1sgMCBdICE9PSBcIipcIiA/IFwiLCBcIiArIGFsbFR5cGVzICsgXCI7IHE9MC4wMVwiIDogXCJcIiApIDpcblx0XHRcdFx0cy5hY2NlcHRzWyBcIipcIiBdXG5cdFx0KTtcblxuXHRcdC8vIENoZWNrIGZvciBoZWFkZXJzIG9wdGlvblxuXHRcdGZvciAoIGkgaW4gcy5oZWFkZXJzICkge1xuXHRcdFx0anFYSFIuc2V0UmVxdWVzdEhlYWRlciggaSwgcy5oZWFkZXJzWyBpIF0gKTtcblx0XHR9XG5cblx0XHQvLyBBbGxvdyBjdXN0b20gaGVhZGVycy9taW1ldHlwZXMgYW5kIGVhcmx5IGFib3J0XG5cdFx0aWYgKCBzLmJlZm9yZVNlbmQgJiZcblx0XHRcdCggcy5iZWZvcmVTZW5kLmNhbGwoIGNhbGxiYWNrQ29udGV4dCwganFYSFIsIHMgKSA9PT0gZmFsc2UgfHwgc3RhdGUgPT09IDIgKSApIHtcblxuXHRcdFx0Ly8gQWJvcnQgaWYgbm90IGRvbmUgYWxyZWFkeSBhbmQgcmV0dXJuXG5cdFx0XHRyZXR1cm4ganFYSFIuYWJvcnQoKTtcblx0XHR9XG5cblx0XHQvLyBhYm9ydGluZyBpcyBubyBsb25nZXIgYSBjYW5jZWxsYXRpb25cblx0XHRzdHJBYm9ydCA9IFwiYWJvcnRcIjtcblxuXHRcdC8vIEluc3RhbGwgY2FsbGJhY2tzIG9uIGRlZmVycmVkc1xuXHRcdGZvciAoIGkgaW4geyBzdWNjZXNzOiAxLCBlcnJvcjogMSwgY29tcGxldGU6IDEgfSApIHtcblx0XHRcdGpxWEhSWyBpIF0oIHNbIGkgXSApO1xuXHRcdH1cblxuXHRcdC8vIEdldCB0cmFuc3BvcnRcblx0XHR0cmFuc3BvcnQgPSBpbnNwZWN0UHJlZmlsdGVyc09yVHJhbnNwb3J0cyggdHJhbnNwb3J0cywgcywgb3B0aW9ucywganFYSFIgKTtcblxuXHRcdC8vIElmIG5vIHRyYW5zcG9ydCwgd2UgYXV0by1hYm9ydFxuXHRcdGlmICggIXRyYW5zcG9ydCApIHtcblx0XHRcdGRvbmUoIC0xLCBcIk5vIFRyYW5zcG9ydFwiICk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGpxWEhSLnJlYWR5U3RhdGUgPSAxO1xuXG5cdFx0XHQvLyBTZW5kIGdsb2JhbCBldmVudFxuXHRcdFx0aWYgKCBmaXJlR2xvYmFscyApIHtcblx0XHRcdFx0Z2xvYmFsRXZlbnRDb250ZXh0LnRyaWdnZXIoIFwiYWpheFNlbmRcIiwgWyBqcVhIUiwgcyBdICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIElmIHJlcXVlc3Qgd2FzIGFib3J0ZWQgaW5zaWRlIGFqYXhTZW5kLCBzdG9wIHRoZXJlXG5cdFx0XHRpZiAoIHN0YXRlID09PSAyICkge1xuXHRcdFx0XHRyZXR1cm4ganFYSFI7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFRpbWVvdXRcblx0XHRcdGlmICggcy5hc3luYyAmJiBzLnRpbWVvdXQgPiAwICkge1xuXHRcdFx0XHR0aW1lb3V0VGltZXIgPSB3aW5kb3cuc2V0VGltZW91dCggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0anFYSFIuYWJvcnQoIFwidGltZW91dFwiICk7XG5cdFx0XHRcdH0sIHMudGltZW91dCApO1xuXHRcdFx0fVxuXG5cdFx0XHR0cnkge1xuXHRcdFx0XHRzdGF0ZSA9IDE7XG5cdFx0XHRcdHRyYW5zcG9ydC5zZW5kKCByZXF1ZXN0SGVhZGVycywgZG9uZSApO1xuXHRcdFx0fSBjYXRjaCAoIGUgKSB7XG5cblx0XHRcdFx0Ly8gUHJvcGFnYXRlIGV4Y2VwdGlvbiBhcyBlcnJvciBpZiBub3QgZG9uZVxuXHRcdFx0XHRpZiAoIHN0YXRlIDwgMiApIHtcblx0XHRcdFx0XHRkb25lKCAtMSwgZSApO1xuXG5cdFx0XHRcdC8vIFNpbXBseSByZXRocm93IG90aGVyd2lzZVxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHRocm93IGU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBDYWxsYmFjayBmb3Igd2hlbiBldmVyeXRoaW5nIGlzIGRvbmVcblx0XHRmdW5jdGlvbiBkb25lKCBzdGF0dXMsIG5hdGl2ZVN0YXR1c1RleHQsIHJlc3BvbnNlcywgaGVhZGVycyApIHtcblx0XHRcdHZhciBpc1N1Y2Nlc3MsIHN1Y2Nlc3MsIGVycm9yLCByZXNwb25zZSwgbW9kaWZpZWQsXG5cdFx0XHRcdHN0YXR1c1RleHQgPSBuYXRpdmVTdGF0dXNUZXh0O1xuXG5cdFx0XHQvLyBDYWxsZWQgb25jZVxuXHRcdFx0aWYgKCBzdGF0ZSA9PT0gMiApIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTdGF0ZSBpcyBcImRvbmVcIiBub3dcblx0XHRcdHN0YXRlID0gMjtcblxuXHRcdFx0Ly8gQ2xlYXIgdGltZW91dCBpZiBpdCBleGlzdHNcblx0XHRcdGlmICggdGltZW91dFRpbWVyICkge1xuXHRcdFx0XHR3aW5kb3cuY2xlYXJUaW1lb3V0KCB0aW1lb3V0VGltZXIgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gRGVyZWZlcmVuY2UgdHJhbnNwb3J0IGZvciBlYXJseSBnYXJiYWdlIGNvbGxlY3Rpb25cblx0XHRcdC8vIChubyBtYXR0ZXIgaG93IGxvbmcgdGhlIGpxWEhSIG9iamVjdCB3aWxsIGJlIHVzZWQpXG5cdFx0XHR0cmFuc3BvcnQgPSB1bmRlZmluZWQ7XG5cblx0XHRcdC8vIENhY2hlIHJlc3BvbnNlIGhlYWRlcnNcblx0XHRcdHJlc3BvbnNlSGVhZGVyc1N0cmluZyA9IGhlYWRlcnMgfHwgXCJcIjtcblxuXHRcdFx0Ly8gU2V0IHJlYWR5U3RhdGVcblx0XHRcdGpxWEhSLnJlYWR5U3RhdGUgPSBzdGF0dXMgPiAwID8gNCA6IDA7XG5cblx0XHRcdC8vIERldGVybWluZSBpZiBzdWNjZXNzZnVsXG5cdFx0XHRpc1N1Y2Nlc3MgPSBzdGF0dXMgPj0gMjAwICYmIHN0YXR1cyA8IDMwMCB8fCBzdGF0dXMgPT09IDMwNDtcblxuXHRcdFx0Ly8gR2V0IHJlc3BvbnNlIGRhdGFcblx0XHRcdGlmICggcmVzcG9uc2VzICkge1xuXHRcdFx0XHRyZXNwb25zZSA9IGFqYXhIYW5kbGVSZXNwb25zZXMoIHMsIGpxWEhSLCByZXNwb25zZXMgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQ29udmVydCBubyBtYXR0ZXIgd2hhdCAodGhhdCB3YXkgcmVzcG9uc2VYWFggZmllbGRzIGFyZSBhbHdheXMgc2V0KVxuXHRcdFx0cmVzcG9uc2UgPSBhamF4Q29udmVydCggcywgcmVzcG9uc2UsIGpxWEhSLCBpc1N1Y2Nlc3MgKTtcblxuXHRcdFx0Ly8gSWYgc3VjY2Vzc2Z1bCwgaGFuZGxlIHR5cGUgY2hhaW5pbmdcblx0XHRcdGlmICggaXNTdWNjZXNzICkge1xuXG5cdFx0XHRcdC8vIFNldCB0aGUgSWYtTW9kaWZpZWQtU2luY2UgYW5kL29yIElmLU5vbmUtTWF0Y2ggaGVhZGVyLCBpZiBpbiBpZk1vZGlmaWVkIG1vZGUuXG5cdFx0XHRcdGlmICggcy5pZk1vZGlmaWVkICkge1xuXHRcdFx0XHRcdG1vZGlmaWVkID0ganFYSFIuZ2V0UmVzcG9uc2VIZWFkZXIoIFwiTGFzdC1Nb2RpZmllZFwiICk7XG5cdFx0XHRcdFx0aWYgKCBtb2RpZmllZCApIHtcblx0XHRcdFx0XHRcdGpRdWVyeS5sYXN0TW9kaWZpZWRbIGNhY2hlVVJMIF0gPSBtb2RpZmllZDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0bW9kaWZpZWQgPSBqcVhIUi5nZXRSZXNwb25zZUhlYWRlciggXCJldGFnXCIgKTtcblx0XHRcdFx0XHRpZiAoIG1vZGlmaWVkICkge1xuXHRcdFx0XHRcdFx0alF1ZXJ5LmV0YWdbIGNhY2hlVVJMIF0gPSBtb2RpZmllZDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBpZiBubyBjb250ZW50XG5cdFx0XHRcdGlmICggc3RhdHVzID09PSAyMDQgfHwgcy50eXBlID09PSBcIkhFQURcIiApIHtcblx0XHRcdFx0XHRzdGF0dXNUZXh0ID0gXCJub2NvbnRlbnRcIjtcblxuXHRcdFx0XHQvLyBpZiBub3QgbW9kaWZpZWRcblx0XHRcdFx0fSBlbHNlIGlmICggc3RhdHVzID09PSAzMDQgKSB7XG5cdFx0XHRcdFx0c3RhdHVzVGV4dCA9IFwibm90bW9kaWZpZWRcIjtcblxuXHRcdFx0XHQvLyBJZiB3ZSBoYXZlIGRhdGEsIGxldCdzIGNvbnZlcnQgaXRcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRzdGF0dXNUZXh0ID0gcmVzcG9uc2Uuc3RhdGU7XG5cdFx0XHRcdFx0c3VjY2VzcyA9IHJlc3BvbnNlLmRhdGE7XG5cdFx0XHRcdFx0ZXJyb3IgPSByZXNwb25zZS5lcnJvcjtcblx0XHRcdFx0XHRpc1N1Y2Nlc3MgPSAhZXJyb3I7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0Ly8gV2UgZXh0cmFjdCBlcnJvciBmcm9tIHN0YXR1c1RleHRcblx0XHRcdFx0Ly8gdGhlbiBub3JtYWxpemUgc3RhdHVzVGV4dCBhbmQgc3RhdHVzIGZvciBub24tYWJvcnRzXG5cdFx0XHRcdGVycm9yID0gc3RhdHVzVGV4dDtcblx0XHRcdFx0aWYgKCBzdGF0dXMgfHwgIXN0YXR1c1RleHQgKSB7XG5cdFx0XHRcdFx0c3RhdHVzVGV4dCA9IFwiZXJyb3JcIjtcblx0XHRcdFx0XHRpZiAoIHN0YXR1cyA8IDAgKSB7XG5cdFx0XHRcdFx0XHRzdGF0dXMgPSAwO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBTZXQgZGF0YSBmb3IgdGhlIGZha2UgeGhyIG9iamVjdFxuXHRcdFx0anFYSFIuc3RhdHVzID0gc3RhdHVzO1xuXHRcdFx0anFYSFIuc3RhdHVzVGV4dCA9ICggbmF0aXZlU3RhdHVzVGV4dCB8fCBzdGF0dXNUZXh0ICkgKyBcIlwiO1xuXG5cdFx0XHQvLyBTdWNjZXNzL0Vycm9yXG5cdFx0XHRpZiAoIGlzU3VjY2VzcyApIHtcblx0XHRcdFx0ZGVmZXJyZWQucmVzb2x2ZVdpdGgoIGNhbGxiYWNrQ29udGV4dCwgWyBzdWNjZXNzLCBzdGF0dXNUZXh0LCBqcVhIUiBdICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRkZWZlcnJlZC5yZWplY3RXaXRoKCBjYWxsYmFja0NvbnRleHQsIFsganFYSFIsIHN0YXR1c1RleHQsIGVycm9yIF0gKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU3RhdHVzLWRlcGVuZGVudCBjYWxsYmFja3Ncblx0XHRcdGpxWEhSLnN0YXR1c0NvZGUoIHN0YXR1c0NvZGUgKTtcblx0XHRcdHN0YXR1c0NvZGUgPSB1bmRlZmluZWQ7XG5cblx0XHRcdGlmICggZmlyZUdsb2JhbHMgKSB7XG5cdFx0XHRcdGdsb2JhbEV2ZW50Q29udGV4dC50cmlnZ2VyKCBpc1N1Y2Nlc3MgPyBcImFqYXhTdWNjZXNzXCIgOiBcImFqYXhFcnJvclwiLFxuXHRcdFx0XHRcdFsganFYSFIsIHMsIGlzU3VjY2VzcyA/IHN1Y2Nlc3MgOiBlcnJvciBdICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIENvbXBsZXRlXG5cdFx0XHRjb21wbGV0ZURlZmVycmVkLmZpcmVXaXRoKCBjYWxsYmFja0NvbnRleHQsIFsganFYSFIsIHN0YXR1c1RleHQgXSApO1xuXG5cdFx0XHRpZiAoIGZpcmVHbG9iYWxzICkge1xuXHRcdFx0XHRnbG9iYWxFdmVudENvbnRleHQudHJpZ2dlciggXCJhamF4Q29tcGxldGVcIiwgWyBqcVhIUiwgcyBdICk7XG5cblx0XHRcdFx0Ly8gSGFuZGxlIHRoZSBnbG9iYWwgQUpBWCBjb3VudGVyXG5cdFx0XHRcdGlmICggISggLS1qUXVlcnkuYWN0aXZlICkgKSB7XG5cdFx0XHRcdFx0alF1ZXJ5LmV2ZW50LnRyaWdnZXIoIFwiYWpheFN0b3BcIiApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGpxWEhSO1xuXHR9LFxuXG5cdGdldEpTT046IGZ1bmN0aW9uKCB1cmwsIGRhdGEsIGNhbGxiYWNrICkge1xuXHRcdHJldHVybiBqUXVlcnkuZ2V0KCB1cmwsIGRhdGEsIGNhbGxiYWNrLCBcImpzb25cIiApO1xuXHR9LFxuXG5cdGdldFNjcmlwdDogZnVuY3Rpb24oIHVybCwgY2FsbGJhY2sgKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS5nZXQoIHVybCwgdW5kZWZpbmVkLCBjYWxsYmFjaywgXCJzY3JpcHRcIiApO1xuXHR9XG59ICk7XG5cbmpRdWVyeS5lYWNoKCBbIFwiZ2V0XCIsIFwicG9zdFwiIF0sIGZ1bmN0aW9uKCBpLCBtZXRob2QgKSB7XG5cdGpRdWVyeVsgbWV0aG9kIF0gPSBmdW5jdGlvbiggdXJsLCBkYXRhLCBjYWxsYmFjaywgdHlwZSApIHtcblxuXHRcdC8vIHNoaWZ0IGFyZ3VtZW50cyBpZiBkYXRhIGFyZ3VtZW50IHdhcyBvbWl0dGVkXG5cdFx0aWYgKCBqUXVlcnkuaXNGdW5jdGlvbiggZGF0YSApICkge1xuXHRcdFx0dHlwZSA9IHR5cGUgfHwgY2FsbGJhY2s7XG5cdFx0XHRjYWxsYmFjayA9IGRhdGE7XG5cdFx0XHRkYXRhID0gdW5kZWZpbmVkO1xuXHRcdH1cblxuXHRcdC8vIFRoZSB1cmwgY2FuIGJlIGFuIG9wdGlvbnMgb2JqZWN0ICh3aGljaCB0aGVuIG11c3QgaGF2ZSAudXJsKVxuXHRcdHJldHVybiBqUXVlcnkuYWpheCggalF1ZXJ5LmV4dGVuZCgge1xuXHRcdFx0dXJsOiB1cmwsXG5cdFx0XHR0eXBlOiBtZXRob2QsXG5cdFx0XHRkYXRhVHlwZTogdHlwZSxcblx0XHRcdGRhdGE6IGRhdGEsXG5cdFx0XHRzdWNjZXNzOiBjYWxsYmFja1xuXHRcdH0sIGpRdWVyeS5pc1BsYWluT2JqZWN0KCB1cmwgKSAmJiB1cmwgKSApO1xuXHR9O1xufSApO1xuXG5cbmpRdWVyeS5fZXZhbFVybCA9IGZ1bmN0aW9uKCB1cmwgKSB7XG5cdHJldHVybiBqUXVlcnkuYWpheCgge1xuXHRcdHVybDogdXJsLFxuXG5cdFx0Ly8gTWFrZSB0aGlzIGV4cGxpY2l0LCBzaW5jZSB1c2VyIGNhbiBvdmVycmlkZSB0aGlzIHRocm91Z2ggYWpheFNldHVwICgjMTEyNjQpXG5cdFx0dHlwZTogXCJHRVRcIixcblx0XHRkYXRhVHlwZTogXCJzY3JpcHRcIixcblx0XHRjYWNoZTogdHJ1ZSxcblx0XHRhc3luYzogZmFsc2UsXG5cdFx0Z2xvYmFsOiBmYWxzZSxcblx0XHRcInRocm93c1wiOiB0cnVlXG5cdH0gKTtcbn07XG5cblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHR3cmFwQWxsOiBmdW5jdGlvbiggaHRtbCApIHtcblx0XHRpZiAoIGpRdWVyeS5pc0Z1bmN0aW9uKCBodG1sICkgKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbiggaSApIHtcblx0XHRcdFx0alF1ZXJ5KCB0aGlzICkud3JhcEFsbCggaHRtbC5jYWxsKCB0aGlzLCBpICkgKTtcblx0XHRcdH0gKTtcblx0XHR9XG5cblx0XHRpZiAoIHRoaXNbIDAgXSApIHtcblxuXHRcdFx0Ly8gVGhlIGVsZW1lbnRzIHRvIHdyYXAgdGhlIHRhcmdldCBhcm91bmRcblx0XHRcdHZhciB3cmFwID0galF1ZXJ5KCBodG1sLCB0aGlzWyAwIF0ub3duZXJEb2N1bWVudCApLmVxKCAwICkuY2xvbmUoIHRydWUgKTtcblxuXHRcdFx0aWYgKCB0aGlzWyAwIF0ucGFyZW50Tm9kZSApIHtcblx0XHRcdFx0d3JhcC5pbnNlcnRCZWZvcmUoIHRoaXNbIDAgXSApO1xuXHRcdFx0fVxuXG5cdFx0XHR3cmFwLm1hcCggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciBlbGVtID0gdGhpcztcblxuXHRcdFx0XHR3aGlsZSAoIGVsZW0uZmlyc3RDaGlsZCAmJiBlbGVtLmZpcnN0Q2hpbGQubm9kZVR5cGUgPT09IDEgKSB7XG5cdFx0XHRcdFx0ZWxlbSA9IGVsZW0uZmlyc3RDaGlsZDtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiBlbGVtO1xuXHRcdFx0fSApLmFwcGVuZCggdGhpcyApO1xuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdHdyYXBJbm5lcjogZnVuY3Rpb24oIGh0bWwgKSB7XG5cdFx0aWYgKCBqUXVlcnkuaXNGdW5jdGlvbiggaHRtbCApICkge1xuXHRcdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oIGkgKSB7XG5cdFx0XHRcdGpRdWVyeSggdGhpcyApLndyYXBJbm5lciggaHRtbC5jYWxsKCB0aGlzLCBpICkgKTtcblx0XHRcdH0gKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBzZWxmID0galF1ZXJ5KCB0aGlzICksXG5cdFx0XHRcdGNvbnRlbnRzID0gc2VsZi5jb250ZW50cygpO1xuXG5cdFx0XHRpZiAoIGNvbnRlbnRzLmxlbmd0aCApIHtcblx0XHRcdFx0Y29udGVudHMud3JhcEFsbCggaHRtbCApO1xuXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRzZWxmLmFwcGVuZCggaHRtbCApO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0fSxcblxuXHR3cmFwOiBmdW5jdGlvbiggaHRtbCApIHtcblx0XHR2YXIgaXNGdW5jdGlvbiA9IGpRdWVyeS5pc0Z1bmN0aW9uKCBodG1sICk7XG5cblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbiggaSApIHtcblx0XHRcdGpRdWVyeSggdGhpcyApLndyYXBBbGwoIGlzRnVuY3Rpb24gPyBodG1sLmNhbGwoIHRoaXMsIGkgKSA6IGh0bWwgKTtcblx0XHR9ICk7XG5cdH0sXG5cblx0dW53cmFwOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5wYXJlbnQoKS5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdGlmICggIWpRdWVyeS5ub2RlTmFtZSggdGhpcywgXCJib2R5XCIgKSApIHtcblx0XHRcdFx0alF1ZXJ5KCB0aGlzICkucmVwbGFjZVdpdGgoIHRoaXMuY2hpbGROb2RlcyApO1xuXHRcdFx0fVxuXHRcdH0gKS5lbmQoKTtcblx0fVxufSApO1xuXG5cbmZ1bmN0aW9uIGdldERpc3BsYXkoIGVsZW0gKSB7XG5cdHJldHVybiBlbGVtLnN0eWxlICYmIGVsZW0uc3R5bGUuZGlzcGxheSB8fCBqUXVlcnkuY3NzKCBlbGVtLCBcImRpc3BsYXlcIiApO1xufVxuXG5mdW5jdGlvbiBmaWx0ZXJIaWRkZW4oIGVsZW0gKSB7XG5cblx0Ly8gRGlzY29ubmVjdGVkIGVsZW1lbnRzIGFyZSBjb25zaWRlcmVkIGhpZGRlblxuXHRpZiAoICFqUXVlcnkuY29udGFpbnMoIGVsZW0ub3duZXJEb2N1bWVudCB8fCBkb2N1bWVudCwgZWxlbSApICkge1xuXHRcdHJldHVybiB0cnVlO1xuXHR9XG5cdHdoaWxlICggZWxlbSAmJiBlbGVtLm5vZGVUeXBlID09PSAxICkge1xuXHRcdGlmICggZ2V0RGlzcGxheSggZWxlbSApID09PSBcIm5vbmVcIiB8fCBlbGVtLnR5cGUgPT09IFwiaGlkZGVuXCIgKSB7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cdFx0ZWxlbSA9IGVsZW0ucGFyZW50Tm9kZTtcblx0fVxuXHRyZXR1cm4gZmFsc2U7XG59XG5cbmpRdWVyeS5leHByLmZpbHRlcnMuaGlkZGVuID0gZnVuY3Rpb24oIGVsZW0gKSB7XG5cblx0Ly8gU3VwcG9ydDogT3BlcmEgPD0gMTIuMTJcblx0Ly8gT3BlcmEgcmVwb3J0cyBvZmZzZXRXaWR0aHMgYW5kIG9mZnNldEhlaWdodHMgbGVzcyB0aGFuIHplcm8gb24gc29tZSBlbGVtZW50c1xuXHRyZXR1cm4gc3VwcG9ydC5yZWxpYWJsZUhpZGRlbk9mZnNldHMoKSA/XG5cdFx0KCBlbGVtLm9mZnNldFdpZHRoIDw9IDAgJiYgZWxlbS5vZmZzZXRIZWlnaHQgPD0gMCAmJlxuXHRcdFx0IWVsZW0uZ2V0Q2xpZW50UmVjdHMoKS5sZW5ndGggKSA6XG5cdFx0XHRmaWx0ZXJIaWRkZW4oIGVsZW0gKTtcbn07XG5cbmpRdWVyeS5leHByLmZpbHRlcnMudmlzaWJsZSA9IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRyZXR1cm4gIWpRdWVyeS5leHByLmZpbHRlcnMuaGlkZGVuKCBlbGVtICk7XG59O1xuXG5cblxuXG52YXIgcjIwID0gLyUyMC9nLFxuXHRyYnJhY2tldCA9IC9cXFtcXF0kLyxcblx0ckNSTEYgPSAvXFxyP1xcbi9nLFxuXHRyc3VibWl0dGVyVHlwZXMgPSAvXig/OnN1Ym1pdHxidXR0b258aW1hZ2V8cmVzZXR8ZmlsZSkkL2ksXG5cdHJzdWJtaXR0YWJsZSA9IC9eKD86aW5wdXR8c2VsZWN0fHRleHRhcmVhfGtleWdlbikvaTtcblxuZnVuY3Rpb24gYnVpbGRQYXJhbXMoIHByZWZpeCwgb2JqLCB0cmFkaXRpb25hbCwgYWRkICkge1xuXHR2YXIgbmFtZTtcblxuXHRpZiAoIGpRdWVyeS5pc0FycmF5KCBvYmogKSApIHtcblxuXHRcdC8vIFNlcmlhbGl6ZSBhcnJheSBpdGVtLlxuXHRcdGpRdWVyeS5lYWNoKCBvYmosIGZ1bmN0aW9uKCBpLCB2ICkge1xuXHRcdFx0aWYgKCB0cmFkaXRpb25hbCB8fCByYnJhY2tldC50ZXN0KCBwcmVmaXggKSApIHtcblxuXHRcdFx0XHQvLyBUcmVhdCBlYWNoIGFycmF5IGl0ZW0gYXMgYSBzY2FsYXIuXG5cdFx0XHRcdGFkZCggcHJlZml4LCB2ICk7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0Ly8gSXRlbSBpcyBub24tc2NhbGFyIChhcnJheSBvciBvYmplY3QpLCBlbmNvZGUgaXRzIG51bWVyaWMgaW5kZXguXG5cdFx0XHRcdGJ1aWxkUGFyYW1zKFxuXHRcdFx0XHRcdHByZWZpeCArIFwiW1wiICsgKCB0eXBlb2YgdiA9PT0gXCJvYmplY3RcIiAmJiB2ICE9IG51bGwgPyBpIDogXCJcIiApICsgXCJdXCIsXG5cdFx0XHRcdFx0dixcblx0XHRcdFx0XHR0cmFkaXRpb25hbCxcblx0XHRcdFx0XHRhZGRcblx0XHRcdFx0KTtcblx0XHRcdH1cblx0XHR9ICk7XG5cblx0fSBlbHNlIGlmICggIXRyYWRpdGlvbmFsICYmIGpRdWVyeS50eXBlKCBvYmogKSA9PT0gXCJvYmplY3RcIiApIHtcblxuXHRcdC8vIFNlcmlhbGl6ZSBvYmplY3QgaXRlbS5cblx0XHRmb3IgKCBuYW1lIGluIG9iaiApIHtcblx0XHRcdGJ1aWxkUGFyYW1zKCBwcmVmaXggKyBcIltcIiArIG5hbWUgKyBcIl1cIiwgb2JqWyBuYW1lIF0sIHRyYWRpdGlvbmFsLCBhZGQgKTtcblx0XHR9XG5cblx0fSBlbHNlIHtcblxuXHRcdC8vIFNlcmlhbGl6ZSBzY2FsYXIgaXRlbS5cblx0XHRhZGQoIHByZWZpeCwgb2JqICk7XG5cdH1cbn1cblxuLy8gU2VyaWFsaXplIGFuIGFycmF5IG9mIGZvcm0gZWxlbWVudHMgb3IgYSBzZXQgb2Zcbi8vIGtleS92YWx1ZXMgaW50byBhIHF1ZXJ5IHN0cmluZ1xualF1ZXJ5LnBhcmFtID0gZnVuY3Rpb24oIGEsIHRyYWRpdGlvbmFsICkge1xuXHR2YXIgcHJlZml4LFxuXHRcdHMgPSBbXSxcblx0XHRhZGQgPSBmdW5jdGlvbigga2V5LCB2YWx1ZSApIHtcblxuXHRcdFx0Ly8gSWYgdmFsdWUgaXMgYSBmdW5jdGlvbiwgaW52b2tlIGl0IGFuZCByZXR1cm4gaXRzIHZhbHVlXG5cdFx0XHR2YWx1ZSA9IGpRdWVyeS5pc0Z1bmN0aW9uKCB2YWx1ZSApID8gdmFsdWUoKSA6ICggdmFsdWUgPT0gbnVsbCA/IFwiXCIgOiB2YWx1ZSApO1xuXHRcdFx0c1sgcy5sZW5ndGggXSA9IGVuY29kZVVSSUNvbXBvbmVudCgga2V5ICkgKyBcIj1cIiArIGVuY29kZVVSSUNvbXBvbmVudCggdmFsdWUgKTtcblx0XHR9O1xuXG5cdC8vIFNldCB0cmFkaXRpb25hbCB0byB0cnVlIGZvciBqUXVlcnkgPD0gMS4zLjIgYmVoYXZpb3IuXG5cdGlmICggdHJhZGl0aW9uYWwgPT09IHVuZGVmaW5lZCApIHtcblx0XHR0cmFkaXRpb25hbCA9IGpRdWVyeS5hamF4U2V0dGluZ3MgJiYgalF1ZXJ5LmFqYXhTZXR0aW5ncy50cmFkaXRpb25hbDtcblx0fVxuXG5cdC8vIElmIGFuIGFycmF5IHdhcyBwYXNzZWQgaW4sIGFzc3VtZSB0aGF0IGl0IGlzIGFuIGFycmF5IG9mIGZvcm0gZWxlbWVudHMuXG5cdGlmICggalF1ZXJ5LmlzQXJyYXkoIGEgKSB8fCAoIGEuanF1ZXJ5ICYmICFqUXVlcnkuaXNQbGFpbk9iamVjdCggYSApICkgKSB7XG5cblx0XHQvLyBTZXJpYWxpemUgdGhlIGZvcm0gZWxlbWVudHNcblx0XHRqUXVlcnkuZWFjaCggYSwgZnVuY3Rpb24oKSB7XG5cdFx0XHRhZGQoIHRoaXMubmFtZSwgdGhpcy52YWx1ZSApO1xuXHRcdH0gKTtcblxuXHR9IGVsc2Uge1xuXG5cdFx0Ly8gSWYgdHJhZGl0aW9uYWwsIGVuY29kZSB0aGUgXCJvbGRcIiB3YXkgKHRoZSB3YXkgMS4zLjIgb3Igb2xkZXJcblx0XHQvLyBkaWQgaXQpLCBvdGhlcndpc2UgZW5jb2RlIHBhcmFtcyByZWN1cnNpdmVseS5cblx0XHRmb3IgKCBwcmVmaXggaW4gYSApIHtcblx0XHRcdGJ1aWxkUGFyYW1zKCBwcmVmaXgsIGFbIHByZWZpeCBdLCB0cmFkaXRpb25hbCwgYWRkICk7XG5cdFx0fVxuXHR9XG5cblx0Ly8gUmV0dXJuIHRoZSByZXN1bHRpbmcgc2VyaWFsaXphdGlvblxuXHRyZXR1cm4gcy5qb2luKCBcIiZcIiApLnJlcGxhY2UoIHIyMCwgXCIrXCIgKTtcbn07XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0c2VyaWFsaXplOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4galF1ZXJ5LnBhcmFtKCB0aGlzLnNlcmlhbGl6ZUFycmF5KCkgKTtcblx0fSxcblx0c2VyaWFsaXplQXJyYXk6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLm1hcCggZnVuY3Rpb24oKSB7XG5cblx0XHRcdC8vIENhbiBhZGQgcHJvcEhvb2sgZm9yIFwiZWxlbWVudHNcIiB0byBmaWx0ZXIgb3IgYWRkIGZvcm0gZWxlbWVudHNcblx0XHRcdHZhciBlbGVtZW50cyA9IGpRdWVyeS5wcm9wKCB0aGlzLCBcImVsZW1lbnRzXCIgKTtcblx0XHRcdHJldHVybiBlbGVtZW50cyA/IGpRdWVyeS5tYWtlQXJyYXkoIGVsZW1lbnRzICkgOiB0aGlzO1xuXHRcdH0gKVxuXHRcdC5maWx0ZXIoIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIHR5cGUgPSB0aGlzLnR5cGU7XG5cblx0XHRcdC8vIFVzZSAuaXMoXCI6ZGlzYWJsZWRcIikgc28gdGhhdCBmaWVsZHNldFtkaXNhYmxlZF0gd29ya3Ncblx0XHRcdHJldHVybiB0aGlzLm5hbWUgJiYgIWpRdWVyeSggdGhpcyApLmlzKCBcIjpkaXNhYmxlZFwiICkgJiZcblx0XHRcdFx0cnN1Ym1pdHRhYmxlLnRlc3QoIHRoaXMubm9kZU5hbWUgKSAmJiAhcnN1Ym1pdHRlclR5cGVzLnRlc3QoIHR5cGUgKSAmJlxuXHRcdFx0XHQoIHRoaXMuY2hlY2tlZCB8fCAhcmNoZWNrYWJsZVR5cGUudGVzdCggdHlwZSApICk7XG5cdFx0fSApXG5cdFx0Lm1hcCggZnVuY3Rpb24oIGksIGVsZW0gKSB7XG5cdFx0XHR2YXIgdmFsID0galF1ZXJ5KCB0aGlzICkudmFsKCk7XG5cblx0XHRcdHJldHVybiB2YWwgPT0gbnVsbCA/XG5cdFx0XHRcdG51bGwgOlxuXHRcdFx0XHRqUXVlcnkuaXNBcnJheSggdmFsICkgP1xuXHRcdFx0XHRcdGpRdWVyeS5tYXAoIHZhbCwgZnVuY3Rpb24oIHZhbCApIHtcblx0XHRcdFx0XHRcdHJldHVybiB7IG5hbWU6IGVsZW0ubmFtZSwgdmFsdWU6IHZhbC5yZXBsYWNlKCByQ1JMRiwgXCJcXHJcXG5cIiApIH07XG5cdFx0XHRcdFx0fSApIDpcblx0XHRcdFx0XHR7IG5hbWU6IGVsZW0ubmFtZSwgdmFsdWU6IHZhbC5yZXBsYWNlKCByQ1JMRiwgXCJcXHJcXG5cIiApIH07XG5cdFx0fSApLmdldCgpO1xuXHR9XG59ICk7XG5cblxuLy8gQ3JlYXRlIHRoZSByZXF1ZXN0IG9iamVjdFxuLy8gKFRoaXMgaXMgc3RpbGwgYXR0YWNoZWQgdG8gYWpheFNldHRpbmdzIGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5KVxualF1ZXJ5LmFqYXhTZXR0aW5ncy54aHIgPSB3aW5kb3cuQWN0aXZlWE9iamVjdCAhPT0gdW5kZWZpbmVkID9cblxuXHQvLyBTdXBwb3J0OiBJRTYtSUU4XG5cdGZ1bmN0aW9uKCkge1xuXG5cdFx0Ly8gWEhSIGNhbm5vdCBhY2Nlc3MgbG9jYWwgZmlsZXMsIGFsd2F5cyB1c2UgQWN0aXZlWCBmb3IgdGhhdCBjYXNlXG5cdFx0aWYgKCB0aGlzLmlzTG9jYWwgKSB7XG5cdFx0XHRyZXR1cm4gY3JlYXRlQWN0aXZlWEhSKCk7XG5cdFx0fVxuXG5cdFx0Ly8gU3VwcG9ydDogSUUgOS0xMVxuXHRcdC8vIElFIHNlZW1zIHRvIGVycm9yIG9uIGNyb3NzLWRvbWFpbiBQQVRDSCByZXF1ZXN0cyB3aGVuIEFjdGl2ZVggWEhSXG5cdFx0Ly8gaXMgdXNlZC4gSW4gSUUgOSsgYWx3YXlzIHVzZSB0aGUgbmF0aXZlIFhIUi5cblx0XHQvLyBOb3RlOiB0aGlzIGNvbmRpdGlvbiB3b24ndCBjYXRjaCBFZGdlIGFzIGl0IGRvZXNuJ3QgZGVmaW5lXG5cdFx0Ly8gZG9jdW1lbnQuZG9jdW1lbnRNb2RlIGJ1dCBpdCBhbHNvIGRvZXNuJ3Qgc3VwcG9ydCBBY3RpdmVYIHNvIGl0IHdvbid0XG5cdFx0Ly8gcmVhY2ggdGhpcyBjb2RlLlxuXHRcdGlmICggZG9jdW1lbnQuZG9jdW1lbnRNb2RlID4gOCApIHtcblx0XHRcdHJldHVybiBjcmVhdGVTdGFuZGFyZFhIUigpO1xuXHRcdH1cblxuXHRcdC8vIFN1cHBvcnQ6IElFPDlcblx0XHQvLyBvbGRJRSBYSFIgZG9lcyBub3Qgc3VwcG9ydCBub24tUkZDMjYxNiBtZXRob2RzICgjMTMyNDApXG5cdFx0Ly8gU2VlIGh0dHA6Ly9tc2RuLm1pY3Jvc29mdC5jb20vZW4tdXMvbGlicmFyeS9pZS9tczUzNjY0OCh2PXZzLjg1KS5hc3B4XG5cdFx0Ly8gYW5kIGh0dHA6Ly93d3cudzMub3JnL1Byb3RvY29scy9yZmMyNjE2L3JmYzI2MTYtc2VjOS5odG1sI3NlYzlcblx0XHQvLyBBbHRob3VnaCB0aGlzIGNoZWNrIGZvciBzaXggbWV0aG9kcyBpbnN0ZWFkIG9mIGVpZ2h0XG5cdFx0Ly8gc2luY2UgSUUgYWxzbyBkb2VzIG5vdCBzdXBwb3J0IFwidHJhY2VcIiBhbmQgXCJjb25uZWN0XCJcblx0XHRyZXR1cm4gL14oZ2V0fHBvc3R8aGVhZHxwdXR8ZGVsZXRlfG9wdGlvbnMpJC9pLnRlc3QoIHRoaXMudHlwZSApICYmXG5cdFx0XHRjcmVhdGVTdGFuZGFyZFhIUigpIHx8IGNyZWF0ZUFjdGl2ZVhIUigpO1xuXHR9IDpcblxuXHQvLyBGb3IgYWxsIG90aGVyIGJyb3dzZXJzLCB1c2UgdGhlIHN0YW5kYXJkIFhNTEh0dHBSZXF1ZXN0IG9iamVjdFxuXHRjcmVhdGVTdGFuZGFyZFhIUjtcblxudmFyIHhocklkID0gMCxcblx0eGhyQ2FsbGJhY2tzID0ge30sXG5cdHhoclN1cHBvcnRlZCA9IGpRdWVyeS5hamF4U2V0dGluZ3MueGhyKCk7XG5cbi8vIFN1cHBvcnQ6IElFPDEwXG4vLyBPcGVuIHJlcXVlc3RzIG11c3QgYmUgbWFudWFsbHkgYWJvcnRlZCBvbiB1bmxvYWQgKCM1MjgwKVxuLy8gU2VlIGh0dHBzOi8vc3VwcG9ydC5taWNyb3NvZnQuY29tL2tiLzI4NTY3NDYgZm9yIG1vcmUgaW5mb1xuaWYgKCB3aW5kb3cuYXR0YWNoRXZlbnQgKSB7XG5cdHdpbmRvdy5hdHRhY2hFdmVudCggXCJvbnVubG9hZFwiLCBmdW5jdGlvbigpIHtcblx0XHRmb3IgKCB2YXIga2V5IGluIHhockNhbGxiYWNrcyApIHtcblx0XHRcdHhockNhbGxiYWNrc1sga2V5IF0oIHVuZGVmaW5lZCwgdHJ1ZSApO1xuXHRcdH1cblx0fSApO1xufVxuXG4vLyBEZXRlcm1pbmUgc3VwcG9ydCBwcm9wZXJ0aWVzXG5zdXBwb3J0LmNvcnMgPSAhIXhoclN1cHBvcnRlZCAmJiAoIFwid2l0aENyZWRlbnRpYWxzXCIgaW4geGhyU3VwcG9ydGVkICk7XG54aHJTdXBwb3J0ZWQgPSBzdXBwb3J0LmFqYXggPSAhIXhoclN1cHBvcnRlZDtcblxuLy8gQ3JlYXRlIHRyYW5zcG9ydCBpZiB0aGUgYnJvd3NlciBjYW4gcHJvdmlkZSBhbiB4aHJcbmlmICggeGhyU3VwcG9ydGVkICkge1xuXG5cdGpRdWVyeS5hamF4VHJhbnNwb3J0KCBmdW5jdGlvbiggb3B0aW9ucyApIHtcblxuXHRcdC8vIENyb3NzIGRvbWFpbiBvbmx5IGFsbG93ZWQgaWYgc3VwcG9ydGVkIHRocm91Z2ggWE1MSHR0cFJlcXVlc3Rcblx0XHRpZiAoICFvcHRpb25zLmNyb3NzRG9tYWluIHx8IHN1cHBvcnQuY29ycyApIHtcblxuXHRcdFx0dmFyIGNhbGxiYWNrO1xuXG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRzZW5kOiBmdW5jdGlvbiggaGVhZGVycywgY29tcGxldGUgKSB7XG5cdFx0XHRcdFx0dmFyIGksXG5cdFx0XHRcdFx0XHR4aHIgPSBvcHRpb25zLnhocigpLFxuXHRcdFx0XHRcdFx0aWQgPSArK3hocklkO1xuXG5cdFx0XHRcdFx0Ly8gT3BlbiB0aGUgc29ja2V0XG5cdFx0XHRcdFx0eGhyLm9wZW4oXG5cdFx0XHRcdFx0XHRvcHRpb25zLnR5cGUsXG5cdFx0XHRcdFx0XHRvcHRpb25zLnVybCxcblx0XHRcdFx0XHRcdG9wdGlvbnMuYXN5bmMsXG5cdFx0XHRcdFx0XHRvcHRpb25zLnVzZXJuYW1lLFxuXHRcdFx0XHRcdFx0b3B0aW9ucy5wYXNzd29yZFxuXHRcdFx0XHRcdCk7XG5cblx0XHRcdFx0XHQvLyBBcHBseSBjdXN0b20gZmllbGRzIGlmIHByb3ZpZGVkXG5cdFx0XHRcdFx0aWYgKCBvcHRpb25zLnhockZpZWxkcyApIHtcblx0XHRcdFx0XHRcdGZvciAoIGkgaW4gb3B0aW9ucy54aHJGaWVsZHMgKSB7XG5cdFx0XHRcdFx0XHRcdHhoclsgaSBdID0gb3B0aW9ucy54aHJGaWVsZHNbIGkgXTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBPdmVycmlkZSBtaW1lIHR5cGUgaWYgbmVlZGVkXG5cdFx0XHRcdFx0aWYgKCBvcHRpb25zLm1pbWVUeXBlICYmIHhoci5vdmVycmlkZU1pbWVUeXBlICkge1xuXHRcdFx0XHRcdFx0eGhyLm92ZXJyaWRlTWltZVR5cGUoIG9wdGlvbnMubWltZVR5cGUgKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBYLVJlcXVlc3RlZC1XaXRoIGhlYWRlclxuXHRcdFx0XHRcdC8vIEZvciBjcm9zcy1kb21haW4gcmVxdWVzdHMsIHNlZWluZyBhcyBjb25kaXRpb25zIGZvciBhIHByZWZsaWdodCBhcmVcblx0XHRcdFx0XHQvLyBha2luIHRvIGEgamlnc2F3IHB1enpsZSwgd2Ugc2ltcGx5IG5ldmVyIHNldCBpdCB0byBiZSBzdXJlLlxuXHRcdFx0XHRcdC8vIChpdCBjYW4gYWx3YXlzIGJlIHNldCBvbiBhIHBlci1yZXF1ZXN0IGJhc2lzIG9yIGV2ZW4gdXNpbmcgYWpheFNldHVwKVxuXHRcdFx0XHRcdC8vIEZvciBzYW1lLWRvbWFpbiByZXF1ZXN0cywgd29uJ3QgY2hhbmdlIGhlYWRlciBpZiBhbHJlYWR5IHByb3ZpZGVkLlxuXHRcdFx0XHRcdGlmICggIW9wdGlvbnMuY3Jvc3NEb21haW4gJiYgIWhlYWRlcnNbIFwiWC1SZXF1ZXN0ZWQtV2l0aFwiIF0gKSB7XG5cdFx0XHRcdFx0XHRoZWFkZXJzWyBcIlgtUmVxdWVzdGVkLVdpdGhcIiBdID0gXCJYTUxIdHRwUmVxdWVzdFwiO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIFNldCBoZWFkZXJzXG5cdFx0XHRcdFx0Zm9yICggaSBpbiBoZWFkZXJzICkge1xuXG5cdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRTw5XG5cdFx0XHRcdFx0XHQvLyBJRSdzIEFjdGl2ZVhPYmplY3QgdGhyb3dzIGEgJ1R5cGUgTWlzbWF0Y2gnIGV4Y2VwdGlvbiB3aGVuIHNldHRpbmdcblx0XHRcdFx0XHRcdC8vIHJlcXVlc3QgaGVhZGVyIHRvIGEgbnVsbC12YWx1ZS5cblx0XHRcdFx0XHRcdC8vXG5cdFx0XHRcdFx0XHQvLyBUbyBrZWVwIGNvbnNpc3RlbnQgd2l0aCBvdGhlciBYSFIgaW1wbGVtZW50YXRpb25zLCBjYXN0IHRoZSB2YWx1ZVxuXHRcdFx0XHRcdFx0Ly8gdG8gc3RyaW5nIGFuZCBpZ25vcmUgYHVuZGVmaW5lZGAuXG5cdFx0XHRcdFx0XHRpZiAoIGhlYWRlcnNbIGkgXSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdFx0XHR4aHIuc2V0UmVxdWVzdEhlYWRlciggaSwgaGVhZGVyc1sgaSBdICsgXCJcIiApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIERvIHNlbmQgdGhlIHJlcXVlc3Rcblx0XHRcdFx0XHQvLyBUaGlzIG1heSByYWlzZSBhbiBleGNlcHRpb24gd2hpY2ggaXMgYWN0dWFsbHlcblx0XHRcdFx0XHQvLyBoYW5kbGVkIGluIGpRdWVyeS5hamF4IChzbyBubyB0cnkvY2F0Y2ggaGVyZSlcblx0XHRcdFx0XHR4aHIuc2VuZCggKCBvcHRpb25zLmhhc0NvbnRlbnQgJiYgb3B0aW9ucy5kYXRhICkgfHwgbnVsbCApO1xuXG5cdFx0XHRcdFx0Ly8gTGlzdGVuZXJcblx0XHRcdFx0XHRjYWxsYmFjayA9IGZ1bmN0aW9uKCBfLCBpc0Fib3J0ICkge1xuXHRcdFx0XHRcdFx0dmFyIHN0YXR1cywgc3RhdHVzVGV4dCwgcmVzcG9uc2VzO1xuXG5cdFx0XHRcdFx0XHQvLyBXYXMgbmV2ZXIgY2FsbGVkIGFuZCBpcyBhYm9ydGVkIG9yIGNvbXBsZXRlXG5cdFx0XHRcdFx0XHRpZiAoIGNhbGxiYWNrICYmICggaXNBYm9ydCB8fCB4aHIucmVhZHlTdGF0ZSA9PT0gNCApICkge1xuXG5cdFx0XHRcdFx0XHRcdC8vIENsZWFuIHVwXG5cdFx0XHRcdFx0XHRcdGRlbGV0ZSB4aHJDYWxsYmFja3NbIGlkIF07XG5cdFx0XHRcdFx0XHRcdGNhbGxiYWNrID0gdW5kZWZpbmVkO1xuXHRcdFx0XHRcdFx0XHR4aHIub25yZWFkeXN0YXRlY2hhbmdlID0galF1ZXJ5Lm5vb3A7XG5cblx0XHRcdFx0XHRcdFx0Ly8gQWJvcnQgbWFudWFsbHkgaWYgbmVlZGVkXG5cdFx0XHRcdFx0XHRcdGlmICggaXNBYm9ydCApIHtcblx0XHRcdFx0XHRcdFx0XHRpZiAoIHhoci5yZWFkeVN0YXRlICE9PSA0ICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0eGhyLmFib3J0KCk7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdHJlc3BvbnNlcyA9IHt9O1xuXHRcdFx0XHRcdFx0XHRcdHN0YXR1cyA9IHhoci5zdGF0dXM7XG5cblx0XHRcdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRTwxMFxuXHRcdFx0XHRcdFx0XHRcdC8vIEFjY2Vzc2luZyBiaW5hcnktZGF0YSByZXNwb25zZVRleHQgdGhyb3dzIGFuIGV4Y2VwdGlvblxuXHRcdFx0XHRcdFx0XHRcdC8vICgjMTE0MjYpXG5cdFx0XHRcdFx0XHRcdFx0aWYgKCB0eXBlb2YgeGhyLnJlc3BvbnNlVGV4dCA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdFx0XHRcdFx0XHRcdHJlc3BvbnNlcy50ZXh0ID0geGhyLnJlc3BvbnNlVGV4dDtcblx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHQvLyBGaXJlZm94IHRocm93cyBhbiBleGNlcHRpb24gd2hlbiBhY2Nlc3Npbmdcblx0XHRcdFx0XHRcdFx0XHQvLyBzdGF0dXNUZXh0IGZvciBmYXVsdHkgY3Jvc3MtZG9tYWluIHJlcXVlc3RzXG5cdFx0XHRcdFx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRcdFx0XHRcdHN0YXR1c1RleHQgPSB4aHIuc3RhdHVzVGV4dDtcblx0XHRcdFx0XHRcdFx0XHR9IGNhdGNoICggZSApIHtcblxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gV2Ugbm9ybWFsaXplIHdpdGggV2Via2l0IGdpdmluZyBhbiBlbXB0eSBzdGF0dXNUZXh0XG5cdFx0XHRcdFx0XHRcdFx0XHRzdGF0dXNUZXh0ID0gXCJcIjtcblx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHQvLyBGaWx0ZXIgc3RhdHVzIGZvciBub24gc3RhbmRhcmQgYmVoYXZpb3JzXG5cblx0XHRcdFx0XHRcdFx0XHQvLyBJZiB0aGUgcmVxdWVzdCBpcyBsb2NhbCBhbmQgd2UgaGF2ZSBkYXRhOiBhc3N1bWUgYSBzdWNjZXNzXG5cdFx0XHRcdFx0XHRcdFx0Ly8gKHN1Y2Nlc3Mgd2l0aCBubyBkYXRhIHdvbid0IGdldCBub3RpZmllZCwgdGhhdCdzIHRoZSBiZXN0IHdlXG5cdFx0XHRcdFx0XHRcdFx0Ly8gY2FuIGRvIGdpdmVuIGN1cnJlbnQgaW1wbGVtZW50YXRpb25zKVxuXHRcdFx0XHRcdFx0XHRcdGlmICggIXN0YXR1cyAmJiBvcHRpb25zLmlzTG9jYWwgJiYgIW9wdGlvbnMuY3Jvc3NEb21haW4gKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRzdGF0dXMgPSByZXNwb25zZXMudGV4dCA/IDIwMCA6IDQwNDtcblxuXHRcdFx0XHRcdFx0XHRcdC8vIElFIC0gIzE0NTA6IHNvbWV0aW1lcyByZXR1cm5zIDEyMjMgd2hlbiBpdCBzaG91bGQgYmUgMjA0XG5cdFx0XHRcdFx0XHRcdFx0fSBlbHNlIGlmICggc3RhdHVzID09PSAxMjIzICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0c3RhdHVzID0gMjA0O1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHQvLyBDYWxsIGNvbXBsZXRlIGlmIG5lZWRlZFxuXHRcdFx0XHRcdFx0aWYgKCByZXNwb25zZXMgKSB7XG5cdFx0XHRcdFx0XHRcdGNvbXBsZXRlKCBzdGF0dXMsIHN0YXR1c1RleHQsIHJlc3BvbnNlcywgeGhyLmdldEFsbFJlc3BvbnNlSGVhZGVycygpICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fTtcblxuXHRcdFx0XHRcdC8vIERvIHNlbmQgdGhlIHJlcXVlc3Rcblx0XHRcdFx0XHQvLyBgeGhyLnNlbmRgIG1heSByYWlzZSBhbiBleGNlcHRpb24sIGJ1dCBpdCB3aWxsIGJlXG5cdFx0XHRcdFx0Ly8gaGFuZGxlZCBpbiBqUXVlcnkuYWpheCAoc28gbm8gdHJ5L2NhdGNoIGhlcmUpXG5cdFx0XHRcdFx0aWYgKCAhb3B0aW9ucy5hc3luYyApIHtcblxuXHRcdFx0XHRcdFx0Ly8gSWYgd2UncmUgaW4gc3luYyBtb2RlIHdlIGZpcmUgdGhlIGNhbGxiYWNrXG5cdFx0XHRcdFx0XHRjYWxsYmFjaygpO1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAoIHhoci5yZWFkeVN0YXRlID09PSA0ICkge1xuXG5cdFx0XHRcdFx0XHQvLyAoSUU2ICYgSUU3KSBpZiBpdCdzIGluIGNhY2hlIGFuZCBoYXMgYmVlblxuXHRcdFx0XHRcdFx0Ly8gcmV0cmlldmVkIGRpcmVjdGx5IHdlIG5lZWQgdG8gZmlyZSB0aGUgY2FsbGJhY2tcblx0XHRcdFx0XHRcdHdpbmRvdy5zZXRUaW1lb3V0KCBjYWxsYmFjayApO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdC8vIFJlZ2lzdGVyIHRoZSBjYWxsYmFjaywgYnV0IGRlbGF5IGl0IGluIGNhc2UgYHhoci5zZW5kYCB0aHJvd3Ncblx0XHRcdFx0XHRcdC8vIEFkZCB0byB0aGUgbGlzdCBvZiBhY3RpdmUgeGhyIGNhbGxiYWNrc1xuXHRcdFx0XHRcdFx0eGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IHhockNhbGxiYWNrc1sgaWQgXSA9IGNhbGxiYWNrO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSxcblxuXHRcdFx0XHRhYm9ydDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0aWYgKCBjYWxsYmFjayApIHtcblx0XHRcdFx0XHRcdGNhbGxiYWNrKCB1bmRlZmluZWQsIHRydWUgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cdFx0fVxuXHR9ICk7XG59XG5cbi8vIEZ1bmN0aW9ucyB0byBjcmVhdGUgeGhyc1xuZnVuY3Rpb24gY3JlYXRlU3RhbmRhcmRYSFIoKSB7XG5cdHRyeSB7XG5cdFx0cmV0dXJuIG5ldyB3aW5kb3cuWE1MSHR0cFJlcXVlc3QoKTtcblx0fSBjYXRjaCAoIGUgKSB7fVxufVxuXG5mdW5jdGlvbiBjcmVhdGVBY3RpdmVYSFIoKSB7XG5cdHRyeSB7XG5cdFx0cmV0dXJuIG5ldyB3aW5kb3cuQWN0aXZlWE9iamVjdCggXCJNaWNyb3NvZnQuWE1MSFRUUFwiICk7XG5cdH0gY2F0Y2ggKCBlICkge31cbn1cblxuXG5cblxuLy8gSW5zdGFsbCBzY3JpcHQgZGF0YVR5cGVcbmpRdWVyeS5hamF4U2V0dXAoIHtcblx0YWNjZXB0czoge1xuXHRcdHNjcmlwdDogXCJ0ZXh0L2phdmFzY3JpcHQsIGFwcGxpY2F0aW9uL2phdmFzY3JpcHQsIFwiICtcblx0XHRcdFwiYXBwbGljYXRpb24vZWNtYXNjcmlwdCwgYXBwbGljYXRpb24veC1lY21hc2NyaXB0XCJcblx0fSxcblx0Y29udGVudHM6IHtcblx0XHRzY3JpcHQ6IC9cXGIoPzpqYXZhfGVjbWEpc2NyaXB0XFxiL1xuXHR9LFxuXHRjb252ZXJ0ZXJzOiB7XG5cdFx0XCJ0ZXh0IHNjcmlwdFwiOiBmdW5jdGlvbiggdGV4dCApIHtcblx0XHRcdGpRdWVyeS5nbG9iYWxFdmFsKCB0ZXh0ICk7XG5cdFx0XHRyZXR1cm4gdGV4dDtcblx0XHR9XG5cdH1cbn0gKTtcblxuLy8gSGFuZGxlIGNhY2hlJ3Mgc3BlY2lhbCBjYXNlIGFuZCBnbG9iYWxcbmpRdWVyeS5hamF4UHJlZmlsdGVyKCBcInNjcmlwdFwiLCBmdW5jdGlvbiggcyApIHtcblx0aWYgKCBzLmNhY2hlID09PSB1bmRlZmluZWQgKSB7XG5cdFx0cy5jYWNoZSA9IGZhbHNlO1xuXHR9XG5cdGlmICggcy5jcm9zc0RvbWFpbiApIHtcblx0XHRzLnR5cGUgPSBcIkdFVFwiO1xuXHRcdHMuZ2xvYmFsID0gZmFsc2U7XG5cdH1cbn0gKTtcblxuLy8gQmluZCBzY3JpcHQgdGFnIGhhY2sgdHJhbnNwb3J0XG5qUXVlcnkuYWpheFRyYW5zcG9ydCggXCJzY3JpcHRcIiwgZnVuY3Rpb24oIHMgKSB7XG5cblx0Ly8gVGhpcyB0cmFuc3BvcnQgb25seSBkZWFscyB3aXRoIGNyb3NzIGRvbWFpbiByZXF1ZXN0c1xuXHRpZiAoIHMuY3Jvc3NEb21haW4gKSB7XG5cblx0XHR2YXIgc2NyaXB0LFxuXHRcdFx0aGVhZCA9IGRvY3VtZW50LmhlYWQgfHwgalF1ZXJ5KCBcImhlYWRcIiApWyAwIF0gfHwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuXG5cdFx0cmV0dXJuIHtcblxuXHRcdFx0c2VuZDogZnVuY3Rpb24oIF8sIGNhbGxiYWNrICkge1xuXG5cdFx0XHRcdHNjcmlwdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwic2NyaXB0XCIgKTtcblxuXHRcdFx0XHRzY3JpcHQuYXN5bmMgPSB0cnVlO1xuXG5cdFx0XHRcdGlmICggcy5zY3JpcHRDaGFyc2V0ICkge1xuXHRcdFx0XHRcdHNjcmlwdC5jaGFyc2V0ID0gcy5zY3JpcHRDaGFyc2V0O1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0c2NyaXB0LnNyYyA9IHMudXJsO1xuXG5cdFx0XHRcdC8vIEF0dGFjaCBoYW5kbGVycyBmb3IgYWxsIGJyb3dzZXJzXG5cdFx0XHRcdHNjcmlwdC5vbmxvYWQgPSBzY3JpcHQub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24oIF8sIGlzQWJvcnQgKSB7XG5cblx0XHRcdFx0XHRpZiAoIGlzQWJvcnQgfHwgIXNjcmlwdC5yZWFkeVN0YXRlIHx8IC9sb2FkZWR8Y29tcGxldGUvLnRlc3QoIHNjcmlwdC5yZWFkeVN0YXRlICkgKSB7XG5cblx0XHRcdFx0XHRcdC8vIEhhbmRsZSBtZW1vcnkgbGVhayBpbiBJRVxuXHRcdFx0XHRcdFx0c2NyaXB0Lm9ubG9hZCA9IHNjcmlwdC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBudWxsO1xuXG5cdFx0XHRcdFx0XHQvLyBSZW1vdmUgdGhlIHNjcmlwdFxuXHRcdFx0XHRcdFx0aWYgKCBzY3JpcHQucGFyZW50Tm9kZSApIHtcblx0XHRcdFx0XHRcdFx0c2NyaXB0LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoIHNjcmlwdCApO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHQvLyBEZXJlZmVyZW5jZSB0aGUgc2NyaXB0XG5cdFx0XHRcdFx0XHRzY3JpcHQgPSBudWxsO1xuXG5cdFx0XHRcdFx0XHQvLyBDYWxsYmFjayBpZiBub3QgYWJvcnRcblx0XHRcdFx0XHRcdGlmICggIWlzQWJvcnQgKSB7XG5cdFx0XHRcdFx0XHRcdGNhbGxiYWNrKCAyMDAsIFwic3VjY2Vzc1wiICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9O1xuXG5cdFx0XHRcdC8vIENpcmN1bXZlbnQgSUU2IGJ1Z3Mgd2l0aCBiYXNlIGVsZW1lbnRzICgjMjcwOSBhbmQgIzQzNzgpIGJ5IHByZXBlbmRpbmdcblx0XHRcdFx0Ly8gVXNlIG5hdGl2ZSBET00gbWFuaXB1bGF0aW9uIHRvIGF2b2lkIG91ciBkb21NYW5pcCBBSkFYIHRyaWNrZXJ5XG5cdFx0XHRcdGhlYWQuaW5zZXJ0QmVmb3JlKCBzY3JpcHQsIGhlYWQuZmlyc3RDaGlsZCApO1xuXHRcdFx0fSxcblxuXHRcdFx0YWJvcnQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoIHNjcmlwdCApIHtcblx0XHRcdFx0XHRzY3JpcHQub25sb2FkKCB1bmRlZmluZWQsIHRydWUgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH07XG5cdH1cbn0gKTtcblxuXG5cblxudmFyIG9sZENhbGxiYWNrcyA9IFtdLFxuXHRyanNvbnAgPSAvKD0pXFw/KD89JnwkKXxcXD9cXD8vO1xuXG4vLyBEZWZhdWx0IGpzb25wIHNldHRpbmdzXG5qUXVlcnkuYWpheFNldHVwKCB7XG5cdGpzb25wOiBcImNhbGxiYWNrXCIsXG5cdGpzb25wQ2FsbGJhY2s6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBjYWxsYmFjayA9IG9sZENhbGxiYWNrcy5wb3AoKSB8fCAoIGpRdWVyeS5leHBhbmRvICsgXCJfXCIgKyAoIG5vbmNlKysgKSApO1xuXHRcdHRoaXNbIGNhbGxiYWNrIF0gPSB0cnVlO1xuXHRcdHJldHVybiBjYWxsYmFjaztcblx0fVxufSApO1xuXG4vLyBEZXRlY3QsIG5vcm1hbGl6ZSBvcHRpb25zIGFuZCBpbnN0YWxsIGNhbGxiYWNrcyBmb3IganNvbnAgcmVxdWVzdHNcbmpRdWVyeS5hamF4UHJlZmlsdGVyKCBcImpzb24ganNvbnBcIiwgZnVuY3Rpb24oIHMsIG9yaWdpbmFsU2V0dGluZ3MsIGpxWEhSICkge1xuXG5cdHZhciBjYWxsYmFja05hbWUsIG92ZXJ3cml0dGVuLCByZXNwb25zZUNvbnRhaW5lcixcblx0XHRqc29uUHJvcCA9IHMuanNvbnAgIT09IGZhbHNlICYmICggcmpzb25wLnRlc3QoIHMudXJsICkgP1xuXHRcdFx0XCJ1cmxcIiA6XG5cdFx0XHR0eXBlb2Ygcy5kYXRhID09PSBcInN0cmluZ1wiICYmXG5cdFx0XHRcdCggcy5jb250ZW50VHlwZSB8fCBcIlwiIClcblx0XHRcdFx0XHQuaW5kZXhPZiggXCJhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWRcIiApID09PSAwICYmXG5cdFx0XHRcdHJqc29ucC50ZXN0KCBzLmRhdGEgKSAmJiBcImRhdGFcIlxuXHRcdCk7XG5cblx0Ly8gSGFuZGxlIGlmZiB0aGUgZXhwZWN0ZWQgZGF0YSB0eXBlIGlzIFwianNvbnBcIiBvciB3ZSBoYXZlIGEgcGFyYW1ldGVyIHRvIHNldFxuXHRpZiAoIGpzb25Qcm9wIHx8IHMuZGF0YVR5cGVzWyAwIF0gPT09IFwianNvbnBcIiApIHtcblxuXHRcdC8vIEdldCBjYWxsYmFjayBuYW1lLCByZW1lbWJlcmluZyBwcmVleGlzdGluZyB2YWx1ZSBhc3NvY2lhdGVkIHdpdGggaXRcblx0XHRjYWxsYmFja05hbWUgPSBzLmpzb25wQ2FsbGJhY2sgPSBqUXVlcnkuaXNGdW5jdGlvbiggcy5qc29ucENhbGxiYWNrICkgP1xuXHRcdFx0cy5qc29ucENhbGxiYWNrKCkgOlxuXHRcdFx0cy5qc29ucENhbGxiYWNrO1xuXG5cdFx0Ly8gSW5zZXJ0IGNhbGxiYWNrIGludG8gdXJsIG9yIGZvcm0gZGF0YVxuXHRcdGlmICgganNvblByb3AgKSB7XG5cdFx0XHRzWyBqc29uUHJvcCBdID0gc1sganNvblByb3AgXS5yZXBsYWNlKCByanNvbnAsIFwiJDFcIiArIGNhbGxiYWNrTmFtZSApO1xuXHRcdH0gZWxzZSBpZiAoIHMuanNvbnAgIT09IGZhbHNlICkge1xuXHRcdFx0cy51cmwgKz0gKCBycXVlcnkudGVzdCggcy51cmwgKSA/IFwiJlwiIDogXCI/XCIgKSArIHMuanNvbnAgKyBcIj1cIiArIGNhbGxiYWNrTmFtZTtcblx0XHR9XG5cblx0XHQvLyBVc2UgZGF0YSBjb252ZXJ0ZXIgdG8gcmV0cmlldmUganNvbiBhZnRlciBzY3JpcHQgZXhlY3V0aW9uXG5cdFx0cy5jb252ZXJ0ZXJzWyBcInNjcmlwdCBqc29uXCIgXSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0aWYgKCAhcmVzcG9uc2VDb250YWluZXIgKSB7XG5cdFx0XHRcdGpRdWVyeS5lcnJvciggY2FsbGJhY2tOYW1lICsgXCIgd2FzIG5vdCBjYWxsZWRcIiApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHJlc3BvbnNlQ29udGFpbmVyWyAwIF07XG5cdFx0fTtcblxuXHRcdC8vIGZvcmNlIGpzb24gZGF0YVR5cGVcblx0XHRzLmRhdGFUeXBlc1sgMCBdID0gXCJqc29uXCI7XG5cblx0XHQvLyBJbnN0YWxsIGNhbGxiYWNrXG5cdFx0b3ZlcndyaXR0ZW4gPSB3aW5kb3dbIGNhbGxiYWNrTmFtZSBdO1xuXHRcdHdpbmRvd1sgY2FsbGJhY2tOYW1lIF0gPSBmdW5jdGlvbigpIHtcblx0XHRcdHJlc3BvbnNlQ29udGFpbmVyID0gYXJndW1lbnRzO1xuXHRcdH07XG5cblx0XHQvLyBDbGVhbi11cCBmdW5jdGlvbiAoZmlyZXMgYWZ0ZXIgY29udmVydGVycylcblx0XHRqcVhIUi5hbHdheXMoIGZ1bmN0aW9uKCkge1xuXG5cdFx0XHQvLyBJZiBwcmV2aW91cyB2YWx1ZSBkaWRuJ3QgZXhpc3QgLSByZW1vdmUgaXRcblx0XHRcdGlmICggb3ZlcndyaXR0ZW4gPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0alF1ZXJ5KCB3aW5kb3cgKS5yZW1vdmVQcm9wKCBjYWxsYmFja05hbWUgKTtcblxuXHRcdFx0Ly8gT3RoZXJ3aXNlIHJlc3RvcmUgcHJlZXhpc3RpbmcgdmFsdWVcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHdpbmRvd1sgY2FsbGJhY2tOYW1lIF0gPSBvdmVyd3JpdHRlbjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU2F2ZSBiYWNrIGFzIGZyZWVcblx0XHRcdGlmICggc1sgY2FsbGJhY2tOYW1lIF0gKSB7XG5cblx0XHRcdFx0Ly8gbWFrZSBzdXJlIHRoYXQgcmUtdXNpbmcgdGhlIG9wdGlvbnMgZG9lc24ndCBzY3JldyB0aGluZ3MgYXJvdW5kXG5cdFx0XHRcdHMuanNvbnBDYWxsYmFjayA9IG9yaWdpbmFsU2V0dGluZ3MuanNvbnBDYWxsYmFjaztcblxuXHRcdFx0XHQvLyBzYXZlIHRoZSBjYWxsYmFjayBuYW1lIGZvciBmdXR1cmUgdXNlXG5cdFx0XHRcdG9sZENhbGxiYWNrcy5wdXNoKCBjYWxsYmFja05hbWUgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQ2FsbCBpZiBpdCB3YXMgYSBmdW5jdGlvbiBhbmQgd2UgaGF2ZSBhIHJlc3BvbnNlXG5cdFx0XHRpZiAoIHJlc3BvbnNlQ29udGFpbmVyICYmIGpRdWVyeS5pc0Z1bmN0aW9uKCBvdmVyd3JpdHRlbiApICkge1xuXHRcdFx0XHRvdmVyd3JpdHRlbiggcmVzcG9uc2VDb250YWluZXJbIDAgXSApO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXNwb25zZUNvbnRhaW5lciA9IG92ZXJ3cml0dGVuID0gdW5kZWZpbmVkO1xuXHRcdH0gKTtcblxuXHRcdC8vIERlbGVnYXRlIHRvIHNjcmlwdFxuXHRcdHJldHVybiBcInNjcmlwdFwiO1xuXHR9XG59ICk7XG5cblxuXG5cbi8vIGRhdGE6IHN0cmluZyBvZiBodG1sXG4vLyBjb250ZXh0IChvcHRpb25hbCk6IElmIHNwZWNpZmllZCwgdGhlIGZyYWdtZW50IHdpbGwgYmUgY3JlYXRlZCBpbiB0aGlzIGNvbnRleHQsXG4vLyBkZWZhdWx0cyB0byBkb2N1bWVudFxuLy8ga2VlcFNjcmlwdHMgKG9wdGlvbmFsKTogSWYgdHJ1ZSwgd2lsbCBpbmNsdWRlIHNjcmlwdHMgcGFzc2VkIGluIHRoZSBodG1sIHN0cmluZ1xualF1ZXJ5LnBhcnNlSFRNTCA9IGZ1bmN0aW9uKCBkYXRhLCBjb250ZXh0LCBrZWVwU2NyaXB0cyApIHtcblx0aWYgKCAhZGF0YSB8fCB0eXBlb2YgZGF0YSAhPT0gXCJzdHJpbmdcIiApIHtcblx0XHRyZXR1cm4gbnVsbDtcblx0fVxuXHRpZiAoIHR5cGVvZiBjb250ZXh0ID09PSBcImJvb2xlYW5cIiApIHtcblx0XHRrZWVwU2NyaXB0cyA9IGNvbnRleHQ7XG5cdFx0Y29udGV4dCA9IGZhbHNlO1xuXHR9XG5cdGNvbnRleHQgPSBjb250ZXh0IHx8IGRvY3VtZW50O1xuXG5cdHZhciBwYXJzZWQgPSByc2luZ2xlVGFnLmV4ZWMoIGRhdGEgKSxcblx0XHRzY3JpcHRzID0gIWtlZXBTY3JpcHRzICYmIFtdO1xuXG5cdC8vIFNpbmdsZSB0YWdcblx0aWYgKCBwYXJzZWQgKSB7XG5cdFx0cmV0dXJuIFsgY29udGV4dC5jcmVhdGVFbGVtZW50KCBwYXJzZWRbIDEgXSApIF07XG5cdH1cblxuXHRwYXJzZWQgPSBidWlsZEZyYWdtZW50KCBbIGRhdGEgXSwgY29udGV4dCwgc2NyaXB0cyApO1xuXG5cdGlmICggc2NyaXB0cyAmJiBzY3JpcHRzLmxlbmd0aCApIHtcblx0XHRqUXVlcnkoIHNjcmlwdHMgKS5yZW1vdmUoKTtcblx0fVxuXG5cdHJldHVybiBqUXVlcnkubWVyZ2UoIFtdLCBwYXJzZWQuY2hpbGROb2RlcyApO1xufTtcblxuXG4vLyBLZWVwIGEgY29weSBvZiB0aGUgb2xkIGxvYWQgbWV0aG9kXG52YXIgX2xvYWQgPSBqUXVlcnkuZm4ubG9hZDtcblxuLyoqXG4gKiBMb2FkIGEgdXJsIGludG8gYSBwYWdlXG4gKi9cbmpRdWVyeS5mbi5sb2FkID0gZnVuY3Rpb24oIHVybCwgcGFyYW1zLCBjYWxsYmFjayApIHtcblx0aWYgKCB0eXBlb2YgdXJsICE9PSBcInN0cmluZ1wiICYmIF9sb2FkICkge1xuXHRcdHJldHVybiBfbG9hZC5hcHBseSggdGhpcywgYXJndW1lbnRzICk7XG5cdH1cblxuXHR2YXIgc2VsZWN0b3IsIHR5cGUsIHJlc3BvbnNlLFxuXHRcdHNlbGYgPSB0aGlzLFxuXHRcdG9mZiA9IHVybC5pbmRleE9mKCBcIiBcIiApO1xuXG5cdGlmICggb2ZmID4gLTEgKSB7XG5cdFx0c2VsZWN0b3IgPSBqUXVlcnkudHJpbSggdXJsLnNsaWNlKCBvZmYsIHVybC5sZW5ndGggKSApO1xuXHRcdHVybCA9IHVybC5zbGljZSggMCwgb2ZmICk7XG5cdH1cblxuXHQvLyBJZiBpdCdzIGEgZnVuY3Rpb25cblx0aWYgKCBqUXVlcnkuaXNGdW5jdGlvbiggcGFyYW1zICkgKSB7XG5cblx0XHQvLyBXZSBhc3N1bWUgdGhhdCBpdCdzIHRoZSBjYWxsYmFja1xuXHRcdGNhbGxiYWNrID0gcGFyYW1zO1xuXHRcdHBhcmFtcyA9IHVuZGVmaW5lZDtcblxuXHQvLyBPdGhlcndpc2UsIGJ1aWxkIGEgcGFyYW0gc3RyaW5nXG5cdH0gZWxzZSBpZiAoIHBhcmFtcyAmJiB0eXBlb2YgcGFyYW1zID09PSBcIm9iamVjdFwiICkge1xuXHRcdHR5cGUgPSBcIlBPU1RcIjtcblx0fVxuXG5cdC8vIElmIHdlIGhhdmUgZWxlbWVudHMgdG8gbW9kaWZ5LCBtYWtlIHRoZSByZXF1ZXN0XG5cdGlmICggc2VsZi5sZW5ndGggPiAwICkge1xuXHRcdGpRdWVyeS5hamF4KCB7XG5cdFx0XHR1cmw6IHVybCxcblxuXHRcdFx0Ly8gSWYgXCJ0eXBlXCIgdmFyaWFibGUgaXMgdW5kZWZpbmVkLCB0aGVuIFwiR0VUXCIgbWV0aG9kIHdpbGwgYmUgdXNlZC5cblx0XHRcdC8vIE1ha2UgdmFsdWUgb2YgdGhpcyBmaWVsZCBleHBsaWNpdCBzaW5jZVxuXHRcdFx0Ly8gdXNlciBjYW4gb3ZlcnJpZGUgaXQgdGhyb3VnaCBhamF4U2V0dXAgbWV0aG9kXG5cdFx0XHR0eXBlOiB0eXBlIHx8IFwiR0VUXCIsXG5cdFx0XHRkYXRhVHlwZTogXCJodG1sXCIsXG5cdFx0XHRkYXRhOiBwYXJhbXNcblx0XHR9ICkuZG9uZSggZnVuY3Rpb24oIHJlc3BvbnNlVGV4dCApIHtcblxuXHRcdFx0Ly8gU2F2ZSByZXNwb25zZSBmb3IgdXNlIGluIGNvbXBsZXRlIGNhbGxiYWNrXG5cdFx0XHRyZXNwb25zZSA9IGFyZ3VtZW50cztcblxuXHRcdFx0c2VsZi5odG1sKCBzZWxlY3RvciA/XG5cblx0XHRcdFx0Ly8gSWYgYSBzZWxlY3RvciB3YXMgc3BlY2lmaWVkLCBsb2NhdGUgdGhlIHJpZ2h0IGVsZW1lbnRzIGluIGEgZHVtbXkgZGl2XG5cdFx0XHRcdC8vIEV4Y2x1ZGUgc2NyaXB0cyB0byBhdm9pZCBJRSAnUGVybWlzc2lvbiBEZW5pZWQnIGVycm9yc1xuXHRcdFx0XHRqUXVlcnkoIFwiPGRpdj5cIiApLmFwcGVuZCggalF1ZXJ5LnBhcnNlSFRNTCggcmVzcG9uc2VUZXh0ICkgKS5maW5kKCBzZWxlY3RvciApIDpcblxuXHRcdFx0XHQvLyBPdGhlcndpc2UgdXNlIHRoZSBmdWxsIHJlc3VsdFxuXHRcdFx0XHRyZXNwb25zZVRleHQgKTtcblxuXHRcdC8vIElmIHRoZSByZXF1ZXN0IHN1Y2NlZWRzLCB0aGlzIGZ1bmN0aW9uIGdldHMgXCJkYXRhXCIsIFwic3RhdHVzXCIsIFwianFYSFJcIlxuXHRcdC8vIGJ1dCB0aGV5IGFyZSBpZ25vcmVkIGJlY2F1c2UgcmVzcG9uc2Ugd2FzIHNldCBhYm92ZS5cblx0XHQvLyBJZiBpdCBmYWlscywgdGhpcyBmdW5jdGlvbiBnZXRzIFwianFYSFJcIiwgXCJzdGF0dXNcIiwgXCJlcnJvclwiXG5cdFx0fSApLmFsd2F5cyggY2FsbGJhY2sgJiYgZnVuY3Rpb24oIGpxWEhSLCBzdGF0dXMgKSB7XG5cdFx0XHRzZWxmLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRjYWxsYmFjay5hcHBseSggdGhpcywgcmVzcG9uc2UgfHwgWyBqcVhIUi5yZXNwb25zZVRleHQsIHN0YXR1cywganFYSFIgXSApO1xuXHRcdFx0fSApO1xuXHRcdH0gKTtcblx0fVxuXG5cdHJldHVybiB0aGlzO1xufTtcblxuXG5cblxuLy8gQXR0YWNoIGEgYnVuY2ggb2YgZnVuY3Rpb25zIGZvciBoYW5kbGluZyBjb21tb24gQUpBWCBldmVudHNcbmpRdWVyeS5lYWNoKCBbXG5cdFwiYWpheFN0YXJ0XCIsXG5cdFwiYWpheFN0b3BcIixcblx0XCJhamF4Q29tcGxldGVcIixcblx0XCJhamF4RXJyb3JcIixcblx0XCJhamF4U3VjY2Vzc1wiLFxuXHRcImFqYXhTZW5kXCJcbl0sIGZ1bmN0aW9uKCBpLCB0eXBlICkge1xuXHRqUXVlcnkuZm5bIHR5cGUgXSA9IGZ1bmN0aW9uKCBmbiApIHtcblx0XHRyZXR1cm4gdGhpcy5vbiggdHlwZSwgZm4gKTtcblx0fTtcbn0gKTtcblxuXG5cblxualF1ZXJ5LmV4cHIuZmlsdGVycy5hbmltYXRlZCA9IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRyZXR1cm4galF1ZXJ5LmdyZXAoIGpRdWVyeS50aW1lcnMsIGZ1bmN0aW9uKCBmbiApIHtcblx0XHRyZXR1cm4gZWxlbSA9PT0gZm4uZWxlbTtcblx0fSApLmxlbmd0aDtcbn07XG5cblxuXG5cblxuLyoqXG4gKiBHZXRzIGEgd2luZG93IGZyb20gYW4gZWxlbWVudFxuICovXG5mdW5jdGlvbiBnZXRXaW5kb3coIGVsZW0gKSB7XG5cdHJldHVybiBqUXVlcnkuaXNXaW5kb3coIGVsZW0gKSA/XG5cdFx0ZWxlbSA6XG5cdFx0ZWxlbS5ub2RlVHlwZSA9PT0gOSA/XG5cdFx0XHRlbGVtLmRlZmF1bHRWaWV3IHx8IGVsZW0ucGFyZW50V2luZG93IDpcblx0XHRcdGZhbHNlO1xufVxuXG5qUXVlcnkub2Zmc2V0ID0ge1xuXHRzZXRPZmZzZXQ6IGZ1bmN0aW9uKCBlbGVtLCBvcHRpb25zLCBpICkge1xuXHRcdHZhciBjdXJQb3NpdGlvbiwgY3VyTGVmdCwgY3VyQ1NTVG9wLCBjdXJUb3AsIGN1ck9mZnNldCwgY3VyQ1NTTGVmdCwgY2FsY3VsYXRlUG9zaXRpb24sXG5cdFx0XHRwb3NpdGlvbiA9IGpRdWVyeS5jc3MoIGVsZW0sIFwicG9zaXRpb25cIiApLFxuXHRcdFx0Y3VyRWxlbSA9IGpRdWVyeSggZWxlbSApLFxuXHRcdFx0cHJvcHMgPSB7fTtcblxuXHRcdC8vIHNldCBwb3NpdGlvbiBmaXJzdCwgaW4tY2FzZSB0b3AvbGVmdCBhcmUgc2V0IGV2ZW4gb24gc3RhdGljIGVsZW1cblx0XHRpZiAoIHBvc2l0aW9uID09PSBcInN0YXRpY1wiICkge1xuXHRcdFx0ZWxlbS5zdHlsZS5wb3NpdGlvbiA9IFwicmVsYXRpdmVcIjtcblx0XHR9XG5cblx0XHRjdXJPZmZzZXQgPSBjdXJFbGVtLm9mZnNldCgpO1xuXHRcdGN1ckNTU1RvcCA9IGpRdWVyeS5jc3MoIGVsZW0sIFwidG9wXCIgKTtcblx0XHRjdXJDU1NMZWZ0ID0galF1ZXJ5LmNzcyggZWxlbSwgXCJsZWZ0XCIgKTtcblx0XHRjYWxjdWxhdGVQb3NpdGlvbiA9ICggcG9zaXRpb24gPT09IFwiYWJzb2x1dGVcIiB8fCBwb3NpdGlvbiA9PT0gXCJmaXhlZFwiICkgJiZcblx0XHRcdGpRdWVyeS5pbkFycmF5KCBcImF1dG9cIiwgWyBjdXJDU1NUb3AsIGN1ckNTU0xlZnQgXSApID4gLTE7XG5cblx0XHQvLyBuZWVkIHRvIGJlIGFibGUgdG8gY2FsY3VsYXRlIHBvc2l0aW9uIGlmIGVpdGhlciB0b3Agb3IgbGVmdFxuXHRcdC8vIGlzIGF1dG8gYW5kIHBvc2l0aW9uIGlzIGVpdGhlciBhYnNvbHV0ZSBvciBmaXhlZFxuXHRcdGlmICggY2FsY3VsYXRlUG9zaXRpb24gKSB7XG5cdFx0XHRjdXJQb3NpdGlvbiA9IGN1ckVsZW0ucG9zaXRpb24oKTtcblx0XHRcdGN1clRvcCA9IGN1clBvc2l0aW9uLnRvcDtcblx0XHRcdGN1ckxlZnQgPSBjdXJQb3NpdGlvbi5sZWZ0O1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRjdXJUb3AgPSBwYXJzZUZsb2F0KCBjdXJDU1NUb3AgKSB8fCAwO1xuXHRcdFx0Y3VyTGVmdCA9IHBhcnNlRmxvYXQoIGN1ckNTU0xlZnQgKSB8fCAwO1xuXHRcdH1cblxuXHRcdGlmICggalF1ZXJ5LmlzRnVuY3Rpb24oIG9wdGlvbnMgKSApIHtcblxuXHRcdFx0Ly8gVXNlIGpRdWVyeS5leHRlbmQgaGVyZSB0byBhbGxvdyBtb2RpZmljYXRpb24gb2YgY29vcmRpbmF0ZXMgYXJndW1lbnQgKGdoLTE4NDgpXG5cdFx0XHRvcHRpb25zID0gb3B0aW9ucy5jYWxsKCBlbGVtLCBpLCBqUXVlcnkuZXh0ZW5kKCB7fSwgY3VyT2Zmc2V0ICkgKTtcblx0XHR9XG5cblx0XHRpZiAoIG9wdGlvbnMudG9wICE9IG51bGwgKSB7XG5cdFx0XHRwcm9wcy50b3AgPSAoIG9wdGlvbnMudG9wIC0gY3VyT2Zmc2V0LnRvcCApICsgY3VyVG9wO1xuXHRcdH1cblx0XHRpZiAoIG9wdGlvbnMubGVmdCAhPSBudWxsICkge1xuXHRcdFx0cHJvcHMubGVmdCA9ICggb3B0aW9ucy5sZWZ0IC0gY3VyT2Zmc2V0LmxlZnQgKSArIGN1ckxlZnQ7XG5cdFx0fVxuXG5cdFx0aWYgKCBcInVzaW5nXCIgaW4gb3B0aW9ucyApIHtcblx0XHRcdG9wdGlvbnMudXNpbmcuY2FsbCggZWxlbSwgcHJvcHMgKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Y3VyRWxlbS5jc3MoIHByb3BzICk7XG5cdFx0fVxuXHR9XG59O1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdG9mZnNldDogZnVuY3Rpb24oIG9wdGlvbnMgKSB7XG5cdFx0aWYgKCBhcmd1bWVudHMubGVuZ3RoICkge1xuXHRcdFx0cmV0dXJuIG9wdGlvbnMgPT09IHVuZGVmaW5lZCA/XG5cdFx0XHRcdHRoaXMgOlxuXHRcdFx0XHR0aGlzLmVhY2goIGZ1bmN0aW9uKCBpICkge1xuXHRcdFx0XHRcdGpRdWVyeS5vZmZzZXQuc2V0T2Zmc2V0KCB0aGlzLCBvcHRpb25zLCBpICk7XG5cdFx0XHRcdH0gKTtcblx0XHR9XG5cblx0XHR2YXIgZG9jRWxlbSwgd2luLFxuXHRcdFx0Ym94ID0geyB0b3A6IDAsIGxlZnQ6IDAgfSxcblx0XHRcdGVsZW0gPSB0aGlzWyAwIF0sXG5cdFx0XHRkb2MgPSBlbGVtICYmIGVsZW0ub3duZXJEb2N1bWVudDtcblxuXHRcdGlmICggIWRvYyApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRkb2NFbGVtID0gZG9jLmRvY3VtZW50RWxlbWVudDtcblxuXHRcdC8vIE1ha2Ugc3VyZSBpdCdzIG5vdCBhIGRpc2Nvbm5lY3RlZCBET00gbm9kZVxuXHRcdGlmICggIWpRdWVyeS5jb250YWlucyggZG9jRWxlbSwgZWxlbSApICkge1xuXHRcdFx0cmV0dXJuIGJveDtcblx0XHR9XG5cblx0XHQvLyBJZiB3ZSBkb24ndCBoYXZlIGdCQ1IsIGp1c3QgdXNlIDAsMCByYXRoZXIgdGhhbiBlcnJvclxuXHRcdC8vIEJsYWNrQmVycnkgNSwgaU9TIDMgKG9yaWdpbmFsIGlQaG9uZSlcblx0XHRpZiAoIHR5cGVvZiBlbGVtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCAhPT0gXCJ1bmRlZmluZWRcIiApIHtcblx0XHRcdGJveCA9IGVsZW0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cdFx0fVxuXHRcdHdpbiA9IGdldFdpbmRvdyggZG9jICk7XG5cdFx0cmV0dXJuIHtcblx0XHRcdHRvcDogYm94LnRvcCAgKyAoIHdpbi5wYWdlWU9mZnNldCB8fCBkb2NFbGVtLnNjcm9sbFRvcCApICAtICggZG9jRWxlbS5jbGllbnRUb3AgIHx8IDAgKSxcblx0XHRcdGxlZnQ6IGJveC5sZWZ0ICsgKCB3aW4ucGFnZVhPZmZzZXQgfHwgZG9jRWxlbS5zY3JvbGxMZWZ0ICkgLSAoIGRvY0VsZW0uY2xpZW50TGVmdCB8fCAwIClcblx0XHR9O1xuXHR9LFxuXG5cdHBvc2l0aW9uOiBmdW5jdGlvbigpIHtcblx0XHRpZiAoICF0aGlzWyAwIF0gKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dmFyIG9mZnNldFBhcmVudCwgb2Zmc2V0LFxuXHRcdFx0cGFyZW50T2Zmc2V0ID0geyB0b3A6IDAsIGxlZnQ6IDAgfSxcblx0XHRcdGVsZW0gPSB0aGlzWyAwIF07XG5cblx0XHQvLyBGaXhlZCBlbGVtZW50cyBhcmUgb2Zmc2V0IGZyb20gd2luZG93IChwYXJlbnRPZmZzZXQgPSB7dG9wOjAsIGxlZnQ6IDB9LFxuXHRcdC8vIGJlY2F1c2UgaXQgaXMgaXRzIG9ubHkgb2Zmc2V0IHBhcmVudFxuXHRcdGlmICggalF1ZXJ5LmNzcyggZWxlbSwgXCJwb3NpdGlvblwiICkgPT09IFwiZml4ZWRcIiApIHtcblxuXHRcdFx0Ly8gd2UgYXNzdW1lIHRoYXQgZ2V0Qm91bmRpbmdDbGllbnRSZWN0IGlzIGF2YWlsYWJsZSB3aGVuIGNvbXB1dGVkIHBvc2l0aW9uIGlzIGZpeGVkXG5cdFx0XHRvZmZzZXQgPSBlbGVtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXHRcdH0gZWxzZSB7XG5cblx0XHRcdC8vIEdldCAqcmVhbCogb2Zmc2V0UGFyZW50XG5cdFx0XHRvZmZzZXRQYXJlbnQgPSB0aGlzLm9mZnNldFBhcmVudCgpO1xuXG5cdFx0XHQvLyBHZXQgY29ycmVjdCBvZmZzZXRzXG5cdFx0XHRvZmZzZXQgPSB0aGlzLm9mZnNldCgpO1xuXHRcdFx0aWYgKCAhalF1ZXJ5Lm5vZGVOYW1lKCBvZmZzZXRQYXJlbnRbIDAgXSwgXCJodG1sXCIgKSApIHtcblx0XHRcdFx0cGFyZW50T2Zmc2V0ID0gb2Zmc2V0UGFyZW50Lm9mZnNldCgpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBBZGQgb2Zmc2V0UGFyZW50IGJvcmRlcnNcblx0XHRcdHBhcmVudE9mZnNldC50b3AgICs9IGpRdWVyeS5jc3MoIG9mZnNldFBhcmVudFsgMCBdLCBcImJvcmRlclRvcFdpZHRoXCIsIHRydWUgKTtcblx0XHRcdHBhcmVudE9mZnNldC5sZWZ0ICs9IGpRdWVyeS5jc3MoIG9mZnNldFBhcmVudFsgMCBdLCBcImJvcmRlckxlZnRXaWR0aFwiLCB0cnVlICk7XG5cdFx0fVxuXG5cdFx0Ly8gU3VidHJhY3QgcGFyZW50IG9mZnNldHMgYW5kIGVsZW1lbnQgbWFyZ2luc1xuXHRcdC8vIG5vdGU6IHdoZW4gYW4gZWxlbWVudCBoYXMgbWFyZ2luOiBhdXRvIHRoZSBvZmZzZXRMZWZ0IGFuZCBtYXJnaW5MZWZ0XG5cdFx0Ly8gYXJlIHRoZSBzYW1lIGluIFNhZmFyaSBjYXVzaW5nIG9mZnNldC5sZWZ0IHRvIGluY29ycmVjdGx5IGJlIDBcblx0XHRyZXR1cm4ge1xuXHRcdFx0dG9wOiAgb2Zmc2V0LnRvcCAgLSBwYXJlbnRPZmZzZXQudG9wIC0galF1ZXJ5LmNzcyggZWxlbSwgXCJtYXJnaW5Ub3BcIiwgdHJ1ZSApLFxuXHRcdFx0bGVmdDogb2Zmc2V0LmxlZnQgLSBwYXJlbnRPZmZzZXQubGVmdCAtIGpRdWVyeS5jc3MoIGVsZW0sIFwibWFyZ2luTGVmdFwiLCB0cnVlIClcblx0XHR9O1xuXHR9LFxuXG5cdG9mZnNldFBhcmVudDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMubWFwKCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBvZmZzZXRQYXJlbnQgPSB0aGlzLm9mZnNldFBhcmVudDtcblxuXHRcdFx0d2hpbGUgKCBvZmZzZXRQYXJlbnQgJiYgKCAhalF1ZXJ5Lm5vZGVOYW1lKCBvZmZzZXRQYXJlbnQsIFwiaHRtbFwiICkgJiZcblx0XHRcdFx0alF1ZXJ5LmNzcyggb2Zmc2V0UGFyZW50LCBcInBvc2l0aW9uXCIgKSA9PT0gXCJzdGF0aWNcIiApICkge1xuXHRcdFx0XHRvZmZzZXRQYXJlbnQgPSBvZmZzZXRQYXJlbnQub2Zmc2V0UGFyZW50O1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG9mZnNldFBhcmVudCB8fCBkb2N1bWVudEVsZW1lbnQ7XG5cdFx0fSApO1xuXHR9XG59ICk7XG5cbi8vIENyZWF0ZSBzY3JvbGxMZWZ0IGFuZCBzY3JvbGxUb3AgbWV0aG9kc1xualF1ZXJ5LmVhY2goIHsgc2Nyb2xsTGVmdDogXCJwYWdlWE9mZnNldFwiLCBzY3JvbGxUb3A6IFwicGFnZVlPZmZzZXRcIiB9LCBmdW5jdGlvbiggbWV0aG9kLCBwcm9wICkge1xuXHR2YXIgdG9wID0gL1kvLnRlc3QoIHByb3AgKTtcblxuXHRqUXVlcnkuZm5bIG1ldGhvZCBdID0gZnVuY3Rpb24oIHZhbCApIHtcblx0XHRyZXR1cm4gYWNjZXNzKCB0aGlzLCBmdW5jdGlvbiggZWxlbSwgbWV0aG9kLCB2YWwgKSB7XG5cdFx0XHR2YXIgd2luID0gZ2V0V2luZG93KCBlbGVtICk7XG5cblx0XHRcdGlmICggdmFsID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdHJldHVybiB3aW4gPyAoIHByb3AgaW4gd2luICkgPyB3aW5bIHByb3AgXSA6XG5cdFx0XHRcdFx0d2luLmRvY3VtZW50LmRvY3VtZW50RWxlbWVudFsgbWV0aG9kIF0gOlxuXHRcdFx0XHRcdGVsZW1bIG1ldGhvZCBdO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIHdpbiApIHtcblx0XHRcdFx0d2luLnNjcm9sbFRvKFxuXHRcdFx0XHRcdCF0b3AgPyB2YWwgOiBqUXVlcnkoIHdpbiApLnNjcm9sbExlZnQoKSxcblx0XHRcdFx0XHR0b3AgPyB2YWwgOiBqUXVlcnkoIHdpbiApLnNjcm9sbFRvcCgpXG5cdFx0XHRcdCk7XG5cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGVsZW1bIG1ldGhvZCBdID0gdmFsO1xuXHRcdFx0fVxuXHRcdH0sIG1ldGhvZCwgdmFsLCBhcmd1bWVudHMubGVuZ3RoLCBudWxsICk7XG5cdH07XG59ICk7XG5cbi8vIFN1cHBvcnQ6IFNhZmFyaTw3LTgrLCBDaHJvbWU8MzctNDQrXG4vLyBBZGQgdGhlIHRvcC9sZWZ0IGNzc0hvb2tzIHVzaW5nIGpRdWVyeS5mbi5wb3NpdGlvblxuLy8gV2Via2l0IGJ1ZzogaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTI5MDg0XG4vLyBnZXRDb21wdXRlZFN0eWxlIHJldHVybnMgcGVyY2VudCB3aGVuIHNwZWNpZmllZCBmb3IgdG9wL2xlZnQvYm90dG9tL3JpZ2h0XG4vLyByYXRoZXIgdGhhbiBtYWtlIHRoZSBjc3MgbW9kdWxlIGRlcGVuZCBvbiB0aGUgb2Zmc2V0IG1vZHVsZSwgd2UganVzdCBjaGVjayBmb3IgaXQgaGVyZVxualF1ZXJ5LmVhY2goIFsgXCJ0b3BcIiwgXCJsZWZ0XCIgXSwgZnVuY3Rpb24oIGksIHByb3AgKSB7XG5cdGpRdWVyeS5jc3NIb29rc1sgcHJvcCBdID0gYWRkR2V0SG9va0lmKCBzdXBwb3J0LnBpeGVsUG9zaXRpb24sXG5cdFx0ZnVuY3Rpb24oIGVsZW0sIGNvbXB1dGVkICkge1xuXHRcdFx0aWYgKCBjb21wdXRlZCApIHtcblx0XHRcdFx0Y29tcHV0ZWQgPSBjdXJDU1MoIGVsZW0sIHByb3AgKTtcblxuXHRcdFx0XHQvLyBpZiBjdXJDU1MgcmV0dXJucyBwZXJjZW50YWdlLCBmYWxsYmFjayB0byBvZmZzZXRcblx0XHRcdFx0cmV0dXJuIHJudW1ub25weC50ZXN0KCBjb21wdXRlZCApID9cblx0XHRcdFx0XHRqUXVlcnkoIGVsZW0gKS5wb3NpdGlvbigpWyBwcm9wIF0gKyBcInB4XCIgOlxuXHRcdFx0XHRcdGNvbXB1dGVkO1xuXHRcdFx0fVxuXHRcdH1cblx0KTtcbn0gKTtcblxuXG4vLyBDcmVhdGUgaW5uZXJIZWlnaHQsIGlubmVyV2lkdGgsIGhlaWdodCwgd2lkdGgsIG91dGVySGVpZ2h0IGFuZCBvdXRlcldpZHRoIG1ldGhvZHNcbmpRdWVyeS5lYWNoKCB7IEhlaWdodDogXCJoZWlnaHRcIiwgV2lkdGg6IFwid2lkdGhcIiB9LCBmdW5jdGlvbiggbmFtZSwgdHlwZSApIHtcblx0alF1ZXJ5LmVhY2goIHsgcGFkZGluZzogXCJpbm5lclwiICsgbmFtZSwgY29udGVudDogdHlwZSwgXCJcIjogXCJvdXRlclwiICsgbmFtZSB9LFxuXHRmdW5jdGlvbiggZGVmYXVsdEV4dHJhLCBmdW5jTmFtZSApIHtcblxuXHRcdC8vIG1hcmdpbiBpcyBvbmx5IGZvciBvdXRlckhlaWdodCwgb3V0ZXJXaWR0aFxuXHRcdGpRdWVyeS5mblsgZnVuY05hbWUgXSA9IGZ1bmN0aW9uKCBtYXJnaW4sIHZhbHVlICkge1xuXHRcdFx0dmFyIGNoYWluYWJsZSA9IGFyZ3VtZW50cy5sZW5ndGggJiYgKCBkZWZhdWx0RXh0cmEgfHwgdHlwZW9mIG1hcmdpbiAhPT0gXCJib29sZWFuXCIgKSxcblx0XHRcdFx0ZXh0cmEgPSBkZWZhdWx0RXh0cmEgfHwgKCBtYXJnaW4gPT09IHRydWUgfHwgdmFsdWUgPT09IHRydWUgPyBcIm1hcmdpblwiIDogXCJib3JkZXJcIiApO1xuXG5cdFx0XHRyZXR1cm4gYWNjZXNzKCB0aGlzLCBmdW5jdGlvbiggZWxlbSwgdHlwZSwgdmFsdWUgKSB7XG5cdFx0XHRcdHZhciBkb2M7XG5cblx0XHRcdFx0aWYgKCBqUXVlcnkuaXNXaW5kb3coIGVsZW0gKSApIHtcblxuXHRcdFx0XHRcdC8vIEFzIG9mIDUvOC8yMDEyIHRoaXMgd2lsbCB5aWVsZCBpbmNvcnJlY3QgcmVzdWx0cyBmb3IgTW9iaWxlIFNhZmFyaSwgYnV0IHRoZXJlXG5cdFx0XHRcdFx0Ly8gaXNuJ3QgYSB3aG9sZSBsb3Qgd2UgY2FuIGRvLiBTZWUgcHVsbCByZXF1ZXN0IGF0IHRoaXMgVVJMIGZvciBkaXNjdXNzaW9uOlxuXHRcdFx0XHRcdC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9qcXVlcnkvanF1ZXJ5L3B1bGwvNzY0XG5cdFx0XHRcdFx0cmV0dXJuIGVsZW0uZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50WyBcImNsaWVudFwiICsgbmFtZSBdO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gR2V0IGRvY3VtZW50IHdpZHRoIG9yIGhlaWdodFxuXHRcdFx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDkgKSB7XG5cdFx0XHRcdFx0ZG9jID0gZWxlbS5kb2N1bWVudEVsZW1lbnQ7XG5cblx0XHRcdFx0XHQvLyBFaXRoZXIgc2Nyb2xsW1dpZHRoL0hlaWdodF0gb3Igb2Zmc2V0W1dpZHRoL0hlaWdodF0gb3IgY2xpZW50W1dpZHRoL0hlaWdodF0sXG5cdFx0XHRcdFx0Ly8gd2hpY2hldmVyIGlzIGdyZWF0ZXN0XG5cdFx0XHRcdFx0Ly8gdW5mb3J0dW5hdGVseSwgdGhpcyBjYXVzZXMgYnVnICMzODM4IGluIElFNi84IG9ubHksXG5cdFx0XHRcdFx0Ly8gYnV0IHRoZXJlIGlzIGN1cnJlbnRseSBubyBnb29kLCBzbWFsbCB3YXkgdG8gZml4IGl0LlxuXHRcdFx0XHRcdHJldHVybiBNYXRoLm1heChcblx0XHRcdFx0XHRcdGVsZW0uYm9keVsgXCJzY3JvbGxcIiArIG5hbWUgXSwgZG9jWyBcInNjcm9sbFwiICsgbmFtZSBdLFxuXHRcdFx0XHRcdFx0ZWxlbS5ib2R5WyBcIm9mZnNldFwiICsgbmFtZSBdLCBkb2NbIFwib2Zmc2V0XCIgKyBuYW1lIF0sXG5cdFx0XHRcdFx0XHRkb2NbIFwiY2xpZW50XCIgKyBuYW1lIF1cblx0XHRcdFx0XHQpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIHZhbHVlID09PSB1bmRlZmluZWQgP1xuXG5cdFx0XHRcdFx0Ly8gR2V0IHdpZHRoIG9yIGhlaWdodCBvbiB0aGUgZWxlbWVudCwgcmVxdWVzdGluZyBidXQgbm90IGZvcmNpbmcgcGFyc2VGbG9hdFxuXHRcdFx0XHRcdGpRdWVyeS5jc3MoIGVsZW0sIHR5cGUsIGV4dHJhICkgOlxuXG5cdFx0XHRcdFx0Ly8gU2V0IHdpZHRoIG9yIGhlaWdodCBvbiB0aGUgZWxlbWVudFxuXHRcdFx0XHRcdGpRdWVyeS5zdHlsZSggZWxlbSwgdHlwZSwgdmFsdWUsIGV4dHJhICk7XG5cdFx0XHR9LCB0eXBlLCBjaGFpbmFibGUgPyBtYXJnaW4gOiB1bmRlZmluZWQsIGNoYWluYWJsZSwgbnVsbCApO1xuXHRcdH07XG5cdH0gKTtcbn0gKTtcblxuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cblx0YmluZDogZnVuY3Rpb24oIHR5cGVzLCBkYXRhLCBmbiApIHtcblx0XHRyZXR1cm4gdGhpcy5vbiggdHlwZXMsIG51bGwsIGRhdGEsIGZuICk7XG5cdH0sXG5cdHVuYmluZDogZnVuY3Rpb24oIHR5cGVzLCBmbiApIHtcblx0XHRyZXR1cm4gdGhpcy5vZmYoIHR5cGVzLCBudWxsLCBmbiApO1xuXHR9LFxuXG5cdGRlbGVnYXRlOiBmdW5jdGlvbiggc2VsZWN0b3IsIHR5cGVzLCBkYXRhLCBmbiApIHtcblx0XHRyZXR1cm4gdGhpcy5vbiggdHlwZXMsIHNlbGVjdG9yLCBkYXRhLCBmbiApO1xuXHR9LFxuXHR1bmRlbGVnYXRlOiBmdW5jdGlvbiggc2VsZWN0b3IsIHR5cGVzLCBmbiApIHtcblxuXHRcdC8vICggbmFtZXNwYWNlICkgb3IgKCBzZWxlY3RvciwgdHlwZXMgWywgZm5dIClcblx0XHRyZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA9PT0gMSA/XG5cdFx0XHR0aGlzLm9mZiggc2VsZWN0b3IsIFwiKipcIiApIDpcblx0XHRcdHRoaXMub2ZmKCB0eXBlcywgc2VsZWN0b3IgfHwgXCIqKlwiLCBmbiApO1xuXHR9XG59ICk7XG5cbi8vIFRoZSBudW1iZXIgb2YgZWxlbWVudHMgY29udGFpbmVkIGluIHRoZSBtYXRjaGVkIGVsZW1lbnQgc2V0XG5qUXVlcnkuZm4uc2l6ZSA9IGZ1bmN0aW9uKCkge1xuXHRyZXR1cm4gdGhpcy5sZW5ndGg7XG59O1xuXG5qUXVlcnkuZm4uYW5kU2VsZiA9IGpRdWVyeS5mbi5hZGRCYWNrO1xuXG5cblxuXG4vLyBSZWdpc3RlciBhcyBhIG5hbWVkIEFNRCBtb2R1bGUsIHNpbmNlIGpRdWVyeSBjYW4gYmUgY29uY2F0ZW5hdGVkIHdpdGggb3RoZXJcbi8vIGZpbGVzIHRoYXQgbWF5IHVzZSBkZWZpbmUsIGJ1dCBub3QgdmlhIGEgcHJvcGVyIGNvbmNhdGVuYXRpb24gc2NyaXB0IHRoYXRcbi8vIHVuZGVyc3RhbmRzIGFub255bW91cyBBTUQgbW9kdWxlcy4gQSBuYW1lZCBBTUQgaXMgc2FmZXN0IGFuZCBtb3N0IHJvYnVzdFxuLy8gd2F5IHRvIHJlZ2lzdGVyLiBMb3dlcmNhc2UganF1ZXJ5IGlzIHVzZWQgYmVjYXVzZSBBTUQgbW9kdWxlIG5hbWVzIGFyZVxuLy8gZGVyaXZlZCBmcm9tIGZpbGUgbmFtZXMsIGFuZCBqUXVlcnkgaXMgbm9ybWFsbHkgZGVsaXZlcmVkIGluIGEgbG93ZXJjYXNlXG4vLyBmaWxlIG5hbWUuIERvIHRoaXMgYWZ0ZXIgY3JlYXRpbmcgdGhlIGdsb2JhbCBzbyB0aGF0IGlmIGFuIEFNRCBtb2R1bGUgd2FudHNcbi8vIHRvIGNhbGwgbm9Db25mbGljdCB0byBoaWRlIHRoaXMgdmVyc2lvbiBvZiBqUXVlcnksIGl0IHdpbGwgd29yay5cblxuLy8gTm90ZSB0aGF0IGZvciBtYXhpbXVtIHBvcnRhYmlsaXR5LCBsaWJyYXJpZXMgdGhhdCBhcmUgbm90IGpRdWVyeSBzaG91bGRcbi8vIGRlY2xhcmUgdGhlbXNlbHZlcyBhcyBhbm9ueW1vdXMgbW9kdWxlcywgYW5kIGF2b2lkIHNldHRpbmcgYSBnbG9iYWwgaWYgYW5cbi8vIEFNRCBsb2FkZXIgaXMgcHJlc2VudC4galF1ZXJ5IGlzIGEgc3BlY2lhbCBjYXNlLiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgc2VlXG4vLyBodHRwczovL2dpdGh1Yi5jb20vanJidXJrZS9yZXF1aXJlanMvd2lraS9VcGRhdGluZy1leGlzdGluZy1saWJyYXJpZXMjd2lraS1hbm9uXG5cbmlmICggdHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQgKSB7XG5cdGRlZmluZSggXCJqcXVlcnlcIiwgW10sIGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBqUXVlcnk7XG5cdH0gKTtcbn1cblxuXG5cbnZhclxuXG5cdC8vIE1hcCBvdmVyIGpRdWVyeSBpbiBjYXNlIG9mIG92ZXJ3cml0ZVxuXHRfalF1ZXJ5ID0gd2luZG93LmpRdWVyeSxcblxuXHQvLyBNYXAgb3ZlciB0aGUgJCBpbiBjYXNlIG9mIG92ZXJ3cml0ZVxuXHRfJCA9IHdpbmRvdy4kO1xuXG5qUXVlcnkubm9Db25mbGljdCA9IGZ1bmN0aW9uKCBkZWVwICkge1xuXHRpZiAoIHdpbmRvdy4kID09PSBqUXVlcnkgKSB7XG5cdFx0d2luZG93LiQgPSBfJDtcblx0fVxuXG5cdGlmICggZGVlcCAmJiB3aW5kb3cualF1ZXJ5ID09PSBqUXVlcnkgKSB7XG5cdFx0d2luZG93LmpRdWVyeSA9IF9qUXVlcnk7XG5cdH1cblxuXHRyZXR1cm4galF1ZXJ5O1xufTtcblxuLy8gRXhwb3NlIGpRdWVyeSBhbmQgJCBpZGVudGlmaWVycywgZXZlbiBpblxuLy8gQU1EICgjNzEwMiNjb21tZW50OjEwLCBodHRwczovL2dpdGh1Yi5jb20vanF1ZXJ5L2pxdWVyeS9wdWxsLzU1Nylcbi8vIGFuZCBDb21tb25KUyBmb3IgYnJvd3NlciBlbXVsYXRvcnMgKCMxMzU2NilcbmlmICggIW5vR2xvYmFsICkge1xuXHR3aW5kb3cualF1ZXJ5ID0gd2luZG93LiQgPSBqUXVlcnk7XG59XG5cbnJldHVybiBqUXVlcnk7XG59KSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vanF1ZXJ5L2Rpc3QvanF1ZXJ5LmpzXG4vLyBtb2R1bGUgaWQgPSAxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImltcG9ydCBiYXNlIGZyb20gJy4vYmFzZS5zZXJ2aWNlJztcclxuaW1wb3J0IGFwaUtleSBmcm9tICcuL2FwaUtleS5zZXJ2aWNlJztcclxuaW1wb3J0IGNvbmZpZyBmcm9tICcuL2NvbmZpZy5zZXJ2aWNlJztcclxuaW1wb3J0IGpzb25ITCBmcm9tICcuL2pzb24taGlnaGxpZ2h0JztcclxuaW1wb3J0IGNvbG9yc1NlcnZpY2UgZnJvbSAnLi9jb2xvcnMuc2VydmljZSc7XHJcbmltcG9ydCByZXN0IGZyb20gJy4vcmVzdC5zZXJ2aWNlJztcclxuXHJcbmV4cG9ydCB7XHJcblx0YmFzZSxcclxuXHRhcGlLZXksXHJcblx0cmVzdCxcclxuXHRjb25maWcsXHJcblx0anNvbkhMLFxyXG5cdGNvbG9yc1NlcnZpY2VcclxufTtcclxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc2NyaXB0cy9hcGktZXhwbG9yZXIvdjIvc3JjL3NlcnZpY2VzL2luZGV4LmpzIiwidmFyIGc7XHJcblxyXG4vLyBUaGlzIHdvcmtzIGluIG5vbi1zdHJpY3QgbW9kZVxyXG5nID0gKGZ1bmN0aW9uKCkge1xyXG5cdHJldHVybiB0aGlzO1xyXG59KSgpO1xyXG5cclxudHJ5IHtcclxuXHQvLyBUaGlzIHdvcmtzIGlmIGV2YWwgaXMgYWxsb3dlZCAoc2VlIENTUClcclxuXHRnID0gZyB8fCBGdW5jdGlvbihcInJldHVybiB0aGlzXCIpKCkgfHwgKDEsZXZhbCkoXCJ0aGlzXCIpO1xyXG59IGNhdGNoKGUpIHtcclxuXHQvLyBUaGlzIHdvcmtzIGlmIHRoZSB3aW5kb3cgcmVmZXJlbmNlIGlzIGF2YWlsYWJsZVxyXG5cdGlmKHR5cGVvZiB3aW5kb3cgPT09IFwib2JqZWN0XCIpXHJcblx0XHRnID0gd2luZG93O1xyXG59XHJcblxyXG4vLyBnIGNhbiBzdGlsbCBiZSB1bmRlZmluZWQsIGJ1dCBub3RoaW5nIHRvIGRvIGFib3V0IGl0Li4uXHJcbi8vIFdlIHJldHVybiB1bmRlZmluZWQsIGluc3RlYWQgb2Ygbm90aGluZyBoZXJlLCBzbyBpdCdzXHJcbi8vIGVhc2llciB0byBoYW5kbGUgdGhpcyBjYXNlLiBpZighZ2xvYmFsKSB7IC4uLn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gZztcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gKHdlYnBhY2spL2J1aWxkaW4vZ2xvYmFsLmpzXG4vLyBtb2R1bGUgaWQgPSAzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qIVxuICogS25vY2tvdXQgSmF2YVNjcmlwdCBsaWJyYXJ5IHYzLjQuMVxuICogKGMpIFRoZSBLbm9ja291dC5qcyB0ZWFtIC0gaHR0cDovL2tub2Nrb3V0anMuY29tL1xuICogTGljZW5zZTogTUlUIChodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocClcbiAqL1xuXG4oZnVuY3Rpb24oKXtcbnZhciBERUJVRz10cnVlO1xuKGZ1bmN0aW9uKHVuZGVmaW5lZCl7XG4gICAgLy8gKDAsIGV2YWwpKCd0aGlzJykgaXMgYSByb2J1c3Qgd2F5IG9mIGdldHRpbmcgYSByZWZlcmVuY2UgdG8gdGhlIGdsb2JhbCBvYmplY3RcbiAgICAvLyBGb3IgZGV0YWlscywgc2VlIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMTQxMTk5ODgvcmV0dXJuLXRoaXMtMC1ldmFsdGhpcy8xNDEyMDAyMyMxNDEyMDAyM1xuICAgIHZhciB3aW5kb3cgPSB0aGlzIHx8ICgwLCBldmFsKSgndGhpcycpLFxuICAgICAgICBkb2N1bWVudCA9IHdpbmRvd1snZG9jdW1lbnQnXSxcbiAgICAgICAgbmF2aWdhdG9yID0gd2luZG93WyduYXZpZ2F0b3InXSxcbiAgICAgICAgalF1ZXJ5SW5zdGFuY2UgPSB3aW5kb3dbXCJqUXVlcnlcIl0sXG4gICAgICAgIEpTT04gPSB3aW5kb3dbXCJKU09OXCJdO1xuKGZ1bmN0aW9uKGZhY3RvcnkpIHtcbiAgICAvLyBTdXBwb3J0IHRocmVlIG1vZHVsZSBsb2FkaW5nIHNjZW5hcmlvc1xuICAgIGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZVsnYW1kJ10pIHtcbiAgICAgICAgLy8gWzFdIEFNRCBhbm9ueW1vdXMgbW9kdWxlXG4gICAgICAgIGRlZmluZShbJ2V4cG9ydHMnLCAncmVxdWlyZSddLCBmYWN0b3J5KTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0Jykge1xuICAgICAgICAvLyBbMl0gQ29tbW9uSlMvTm9kZS5qc1xuICAgICAgICBmYWN0b3J5KG1vZHVsZVsnZXhwb3J0cyddIHx8IGV4cG9ydHMpOyAgLy8gbW9kdWxlLmV4cG9ydHMgaXMgZm9yIE5vZGUuanNcbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBbM10gTm8gbW9kdWxlIGxvYWRlciAocGxhaW4gPHNjcmlwdD4gdGFnKSAtIHB1dCBkaXJlY3RseSBpbiBnbG9iYWwgbmFtZXNwYWNlXG4gICAgICAgIGZhY3Rvcnkod2luZG93WydrbyddID0ge30pO1xuICAgIH1cbn0oZnVuY3Rpb24oa29FeHBvcnRzLCBhbWRSZXF1aXJlKXtcbi8vIEludGVybmFsbHksIGFsbCBLTyBvYmplY3RzIGFyZSBhdHRhY2hlZCB0byBrb0V4cG9ydHMgKGV2ZW4gdGhlIG5vbi1leHBvcnRlZCBvbmVzIHdob3NlIG5hbWVzIHdpbGwgYmUgbWluaWZpZWQgYnkgdGhlIGNsb3N1cmUgY29tcGlsZXIpLlxuLy8gSW4gdGhlIGZ1dHVyZSwgdGhlIGZvbGxvd2luZyBcImtvXCIgdmFyaWFibGUgbWF5IGJlIG1hZGUgZGlzdGluY3QgZnJvbSBcImtvRXhwb3J0c1wiIHNvIHRoYXQgcHJpdmF0ZSBvYmplY3RzIGFyZSBub3QgZXh0ZXJuYWxseSByZWFjaGFibGUuXG52YXIga28gPSB0eXBlb2Yga29FeHBvcnRzICE9PSAndW5kZWZpbmVkJyA/IGtvRXhwb3J0cyA6IHt9O1xuLy8gR29vZ2xlIENsb3N1cmUgQ29tcGlsZXIgaGVscGVycyAodXNlZCBvbmx5IHRvIG1ha2UgdGhlIG1pbmlmaWVkIGZpbGUgc21hbGxlcilcbmtvLmV4cG9ydFN5bWJvbCA9IGZ1bmN0aW9uKGtvUGF0aCwgb2JqZWN0KSB7XG4gICAgdmFyIHRva2VucyA9IGtvUGF0aC5zcGxpdChcIi5cIik7XG5cbiAgICAvLyBJbiB0aGUgZnV0dXJlLCBcImtvXCIgbWF5IGJlY29tZSBkaXN0aW5jdCBmcm9tIFwia29FeHBvcnRzXCIgKHNvIHRoYXQgbm9uLWV4cG9ydGVkIG9iamVjdHMgYXJlIG5vdCByZWFjaGFibGUpXG4gICAgLy8gQXQgdGhhdCBwb2ludCwgXCJ0YXJnZXRcIiB3b3VsZCBiZSBzZXQgdG86ICh0eXBlb2Yga29FeHBvcnRzICE9PSBcInVuZGVmaW5lZFwiID8ga29FeHBvcnRzIDoga28pXG4gICAgdmFyIHRhcmdldCA9IGtvO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0b2tlbnMubGVuZ3RoIC0gMTsgaSsrKVxuICAgICAgICB0YXJnZXQgPSB0YXJnZXRbdG9rZW5zW2ldXTtcbiAgICB0YXJnZXRbdG9rZW5zW3Rva2Vucy5sZW5ndGggLSAxXV0gPSBvYmplY3Q7XG59O1xua28uZXhwb3J0UHJvcGVydHkgPSBmdW5jdGlvbihvd25lciwgcHVibGljTmFtZSwgb2JqZWN0KSB7XG4gICAgb3duZXJbcHVibGljTmFtZV0gPSBvYmplY3Q7XG59O1xua28udmVyc2lvbiA9IFwiMy40LjFcIjtcblxua28uZXhwb3J0U3ltYm9sKCd2ZXJzaW9uJywga28udmVyc2lvbik7XG4vLyBGb3IgYW55IG9wdGlvbnMgdGhhdCBtYXkgYWZmZWN0IHZhcmlvdXMgYXJlYXMgb2YgS25vY2tvdXQgYW5kIGFyZW4ndCBkaXJlY3RseSBhc3NvY2lhdGVkIHdpdGggZGF0YSBiaW5kaW5nLlxua28ub3B0aW9ucyA9IHtcbiAgICAnZGVmZXJVcGRhdGVzJzogZmFsc2UsXG4gICAgJ3VzZU9ubHlOYXRpdmVFdmVudHMnOiBmYWxzZVxufTtcblxuLy9rby5leHBvcnRTeW1ib2woJ29wdGlvbnMnLCBrby5vcHRpb25zKTsgICAvLyAnb3B0aW9ucycgaXNuJ3QgbWluaWZpZWRcbmtvLnV0aWxzID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBvYmplY3RGb3JFYWNoKG9iaiwgYWN0aW9uKSB7XG4gICAgICAgIGZvciAodmFyIHByb3AgaW4gb2JqKSB7XG4gICAgICAgICAgICBpZiAob2JqLmhhc093blByb3BlcnR5KHByb3ApKSB7XG4gICAgICAgICAgICAgICAgYWN0aW9uKHByb3AsIG9ialtwcm9wXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBleHRlbmQodGFyZ2V0LCBzb3VyY2UpIHtcbiAgICAgICAgaWYgKHNvdXJjZSkge1xuICAgICAgICAgICAgZm9yKHZhciBwcm9wIGluIHNvdXJjZSkge1xuICAgICAgICAgICAgICAgIGlmKHNvdXJjZS5oYXNPd25Qcm9wZXJ0eShwcm9wKSkge1xuICAgICAgICAgICAgICAgICAgICB0YXJnZXRbcHJvcF0gPSBzb3VyY2VbcHJvcF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2V0UHJvdG90eXBlT2Yob2JqLCBwcm90bykge1xuICAgICAgICBvYmouX19wcm90b19fID0gcHJvdG87XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuXG4gICAgdmFyIGNhblNldFByb3RvdHlwZSA9ICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5KTtcbiAgICB2YXIgY2FuVXNlU3ltYm9scyA9ICFERUJVRyAmJiB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nO1xuXG4gICAgLy8gUmVwcmVzZW50IHRoZSBrbm93biBldmVudCB0eXBlcyBpbiBhIGNvbXBhY3Qgd2F5LCB0aGVuIGF0IHJ1bnRpbWUgdHJhbnNmb3JtIGl0IGludG8gYSBoYXNoIHdpdGggZXZlbnQgbmFtZSBhcyBrZXkgKGZvciBmYXN0IGxvb2t1cClcbiAgICB2YXIga25vd25FdmVudHMgPSB7fSwga25vd25FdmVudFR5cGVzQnlFdmVudE5hbWUgPSB7fTtcbiAgICB2YXIga2V5RXZlbnRUeXBlTmFtZSA9IChuYXZpZ2F0b3IgJiYgL0ZpcmVmb3hcXC8yL2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KSkgPyAnS2V5Ym9hcmRFdmVudCcgOiAnVUlFdmVudHMnO1xuICAgIGtub3duRXZlbnRzW2tleUV2ZW50VHlwZU5hbWVdID0gWydrZXl1cCcsICdrZXlkb3duJywgJ2tleXByZXNzJ107XG4gICAga25vd25FdmVudHNbJ01vdXNlRXZlbnRzJ10gPSBbJ2NsaWNrJywgJ2RibGNsaWNrJywgJ21vdXNlZG93bicsICdtb3VzZXVwJywgJ21vdXNlbW92ZScsICdtb3VzZW92ZXInLCAnbW91c2VvdXQnLCAnbW91c2VlbnRlcicsICdtb3VzZWxlYXZlJ107XG4gICAgb2JqZWN0Rm9yRWFjaChrbm93bkV2ZW50cywgZnVuY3Rpb24oZXZlbnRUeXBlLCBrbm93bkV2ZW50c0ZvclR5cGUpIHtcbiAgICAgICAgaWYgKGtub3duRXZlbnRzRm9yVHlwZS5sZW5ndGgpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBqID0ga25vd25FdmVudHNGb3JUeXBlLmxlbmd0aDsgaSA8IGo7IGkrKylcbiAgICAgICAgICAgICAgICBrbm93bkV2ZW50VHlwZXNCeUV2ZW50TmFtZVtrbm93bkV2ZW50c0ZvclR5cGVbaV1dID0gZXZlbnRUeXBlO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgdmFyIGV2ZW50c1RoYXRNdXN0QmVSZWdpc3RlcmVkVXNpbmdBdHRhY2hFdmVudCA9IHsgJ3Byb3BlcnR5Y2hhbmdlJzogdHJ1ZSB9OyAvLyBXb3JrYXJvdW5kIGZvciBhbiBJRTkgaXNzdWUgLSBodHRwczovL2dpdGh1Yi5jb20vU3RldmVTYW5kZXJzb24va25vY2tvdXQvaXNzdWVzLzQwNlxuXG4gICAgLy8gRGV0ZWN0IElFIHZlcnNpb25zIGZvciBidWcgd29ya2Fyb3VuZHMgKHVzZXMgSUUgY29uZGl0aW9uYWxzLCBub3QgVUEgc3RyaW5nLCBmb3Igcm9idXN0bmVzcylcbiAgICAvLyBOb3RlIHRoYXQsIHNpbmNlIElFIDEwIGRvZXMgbm90IHN1cHBvcnQgY29uZGl0aW9uYWwgY29tbWVudHMsIHRoZSBmb2xsb3dpbmcgbG9naWMgb25seSBkZXRlY3RzIElFIDwgMTAuXG4gICAgLy8gQ3VycmVudGx5IHRoaXMgaXMgYnkgZGVzaWduLCBzaW5jZSBJRSAxMCsgYmVoYXZlcyBjb3JyZWN0bHkgd2hlbiB0cmVhdGVkIGFzIGEgc3RhbmRhcmQgYnJvd3Nlci5cbiAgICAvLyBJZiB0aGVyZSBpcyBhIGZ1dHVyZSBuZWVkIHRvIGRldGVjdCBzcGVjaWZpYyB2ZXJzaW9ucyBvZiBJRTEwKywgd2Ugd2lsbCBhbWVuZCB0aGlzLlxuICAgIHZhciBpZVZlcnNpb24gPSBkb2N1bWVudCAmJiAoZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciB2ZXJzaW9uID0gMywgZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JyksIGlFbGVtcyA9IGRpdi5nZXRFbGVtZW50c0J5VGFnTmFtZSgnaScpO1xuXG4gICAgICAgIC8vIEtlZXAgY29uc3RydWN0aW5nIGNvbmRpdGlvbmFsIEhUTUwgYmxvY2tzIHVudGlsIHdlIGhpdCBvbmUgdGhhdCByZXNvbHZlcyB0byBhbiBlbXB0eSBmcmFnbWVudFxuICAgICAgICB3aGlsZSAoXG4gICAgICAgICAgICBkaXYuaW5uZXJIVE1MID0gJzwhLS1baWYgZ3QgSUUgJyArICgrK3ZlcnNpb24pICsgJ10+PGk+PC9pPjwhW2VuZGlmXS0tPicsXG4gICAgICAgICAgICBpRWxlbXNbMF1cbiAgICAgICAgKSB7fVxuICAgICAgICByZXR1cm4gdmVyc2lvbiA+IDQgPyB2ZXJzaW9uIDogdW5kZWZpbmVkO1xuICAgIH0oKSk7XG4gICAgdmFyIGlzSWU2ID0gaWVWZXJzaW9uID09PSA2LFxuICAgICAgICBpc0llNyA9IGllVmVyc2lvbiA9PT0gNztcblxuICAgIGZ1bmN0aW9uIGlzQ2xpY2tPbkNoZWNrYWJsZUVsZW1lbnQoZWxlbWVudCwgZXZlbnRUeXBlKSB7XG4gICAgICAgIGlmICgoa28udXRpbHMudGFnTmFtZUxvd2VyKGVsZW1lbnQpICE9PSBcImlucHV0XCIpIHx8ICFlbGVtZW50LnR5cGUpIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKGV2ZW50VHlwZS50b0xvd2VyQ2FzZSgpICE9IFwiY2xpY2tcIikgcmV0dXJuIGZhbHNlO1xuICAgICAgICB2YXIgaW5wdXRUeXBlID0gZWxlbWVudC50eXBlO1xuICAgICAgICByZXR1cm4gKGlucHV0VHlwZSA9PSBcImNoZWNrYm94XCIpIHx8IChpbnB1dFR5cGUgPT0gXCJyYWRpb1wiKTtcbiAgICB9XG5cbiAgICAvLyBGb3IgZGV0YWlscyBvbiB0aGUgcGF0dGVybiBmb3IgY2hhbmdpbmcgbm9kZSBjbGFzc2VzXG4gICAgLy8gc2VlOiBodHRwczovL2dpdGh1Yi5jb20va25vY2tvdXQva25vY2tvdXQvaXNzdWVzLzE1OTdcbiAgICB2YXIgY3NzQ2xhc3NOYW1lUmVnZXggPSAvXFxTKy9nO1xuXG4gICAgZnVuY3Rpb24gdG9nZ2xlRG9tTm9kZUNzc0NsYXNzKG5vZGUsIGNsYXNzTmFtZXMsIHNob3VsZEhhdmVDbGFzcykge1xuICAgICAgICB2YXIgYWRkT3JSZW1vdmVGbjtcbiAgICAgICAgaWYgKGNsYXNzTmFtZXMpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygbm9kZS5jbGFzc0xpc3QgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgYWRkT3JSZW1vdmVGbiA9IG5vZGUuY2xhc3NMaXN0W3Nob3VsZEhhdmVDbGFzcyA/ICdhZGQnIDogJ3JlbW92ZSddO1xuICAgICAgICAgICAgICAgIGtvLnV0aWxzLmFycmF5Rm9yRWFjaChjbGFzc05hbWVzLm1hdGNoKGNzc0NsYXNzTmFtZVJlZ2V4KSwgZnVuY3Rpb24oY2xhc3NOYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIGFkZE9yUmVtb3ZlRm4uY2FsbChub2RlLmNsYXNzTGlzdCwgY2xhc3NOYW1lKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIG5vZGUuY2xhc3NOYW1lWydiYXNlVmFsJ10gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgLy8gU1ZHIHRhZyAuY2xhc3NOYW1lcyBpcyBhbiBTVkdBbmltYXRlZFN0cmluZyBpbnN0YW5jZVxuICAgICAgICAgICAgICAgIHRvZ2dsZU9iamVjdENsYXNzUHJvcGVydHlTdHJpbmcobm9kZS5jbGFzc05hbWUsICdiYXNlVmFsJywgY2xhc3NOYW1lcywgc2hvdWxkSGF2ZUNsYXNzKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gbm9kZS5jbGFzc05hbWUgb3VnaHQgdG8gYmUgYSBzdHJpbmcuXG4gICAgICAgICAgICAgICAgdG9nZ2xlT2JqZWN0Q2xhc3NQcm9wZXJ0eVN0cmluZyhub2RlLCAnY2xhc3NOYW1lJywgY2xhc3NOYW1lcywgc2hvdWxkSGF2ZUNsYXNzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRvZ2dsZU9iamVjdENsYXNzUHJvcGVydHlTdHJpbmcob2JqLCBwcm9wLCBjbGFzc05hbWVzLCBzaG91bGRIYXZlQ2xhc3MpIHtcbiAgICAgICAgLy8gb2JqL3Byb3AgaXMgZWl0aGVyIGEgbm9kZS8nY2xhc3NOYW1lJyBvciBhIFNWR0FuaW1hdGVkU3RyaW5nLydiYXNlVmFsJy5cbiAgICAgICAgdmFyIGN1cnJlbnRDbGFzc05hbWVzID0gb2JqW3Byb3BdLm1hdGNoKGNzc0NsYXNzTmFtZVJlZ2V4KSB8fCBbXTtcbiAgICAgICAga28udXRpbHMuYXJyYXlGb3JFYWNoKGNsYXNzTmFtZXMubWF0Y2goY3NzQ2xhc3NOYW1lUmVnZXgpLCBmdW5jdGlvbihjbGFzc05hbWUpIHtcbiAgICAgICAgICAgIGtvLnV0aWxzLmFkZE9yUmVtb3ZlSXRlbShjdXJyZW50Q2xhc3NOYW1lcywgY2xhc3NOYW1lLCBzaG91bGRIYXZlQ2xhc3MpO1xuICAgICAgICB9KTtcbiAgICAgICAgb2JqW3Byb3BdID0gY3VycmVudENsYXNzTmFtZXMuam9pbihcIiBcIik7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgZmllbGRzSW5jbHVkZWRXaXRoSnNvblBvc3Q6IFsnYXV0aGVudGljaXR5X3Rva2VuJywgL15fX1JlcXVlc3RWZXJpZmljYXRpb25Ub2tlbihfLiopPyQvXSxcblxuICAgICAgICBhcnJheUZvckVhY2g6IGZ1bmN0aW9uIChhcnJheSwgYWN0aW9uKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgaiA9IGFycmF5Lmxlbmd0aDsgaSA8IGo7IGkrKylcbiAgICAgICAgICAgICAgICBhY3Rpb24oYXJyYXlbaV0sIGkpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGFycmF5SW5kZXhPZjogZnVuY3Rpb24gKGFycmF5LCBpdGVtKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIEFycmF5LnByb3RvdHlwZS5pbmRleE9mID09IFwiZnVuY3Rpb25cIilcbiAgICAgICAgICAgICAgICByZXR1cm4gQXJyYXkucHJvdG90eXBlLmluZGV4T2YuY2FsbChhcnJheSwgaXRlbSk7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgaiA9IGFycmF5Lmxlbmd0aDsgaSA8IGo7IGkrKylcbiAgICAgICAgICAgICAgICBpZiAoYXJyYXlbaV0gPT09IGl0ZW0pXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9LFxuXG4gICAgICAgIGFycmF5Rmlyc3Q6IGZ1bmN0aW9uIChhcnJheSwgcHJlZGljYXRlLCBwcmVkaWNhdGVPd25lcikge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGogPSBhcnJheS5sZW5ndGg7IGkgPCBqOyBpKyspXG4gICAgICAgICAgICAgICAgaWYgKHByZWRpY2F0ZS5jYWxsKHByZWRpY2F0ZU93bmVyLCBhcnJheVtpXSwgaSkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhcnJheVtpXTtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9LFxuXG4gICAgICAgIGFycmF5UmVtb3ZlSXRlbTogZnVuY3Rpb24gKGFycmF5LCBpdGVtVG9SZW1vdmUpIHtcbiAgICAgICAgICAgIHZhciBpbmRleCA9IGtvLnV0aWxzLmFycmF5SW5kZXhPZihhcnJheSwgaXRlbVRvUmVtb3ZlKTtcbiAgICAgICAgICAgIGlmIChpbmRleCA+IDApIHtcbiAgICAgICAgICAgICAgICBhcnJheS5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaW5kZXggPT09IDApIHtcbiAgICAgICAgICAgICAgICBhcnJheS5zaGlmdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIGFycmF5R2V0RGlzdGluY3RWYWx1ZXM6IGZ1bmN0aW9uIChhcnJheSkge1xuICAgICAgICAgICAgYXJyYXkgPSBhcnJheSB8fCBbXTtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBqID0gYXJyYXkubGVuZ3RoOyBpIDwgajsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGtvLnV0aWxzLmFycmF5SW5kZXhPZihyZXN1bHQsIGFycmF5W2ldKSA8IDApXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGFycmF5W2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH0sXG5cbiAgICAgICAgYXJyYXlNYXA6IGZ1bmN0aW9uIChhcnJheSwgbWFwcGluZykge1xuICAgICAgICAgICAgYXJyYXkgPSBhcnJheSB8fCBbXTtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBqID0gYXJyYXkubGVuZ3RoOyBpIDwgajsgaSsrKVxuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKG1hcHBpbmcoYXJyYXlbaV0sIGkpKTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH0sXG5cbiAgICAgICAgYXJyYXlGaWx0ZXI6IGZ1bmN0aW9uIChhcnJheSwgcHJlZGljYXRlKSB7XG4gICAgICAgICAgICBhcnJheSA9IGFycmF5IHx8IFtdO1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGogPSBhcnJheS5sZW5ndGg7IGkgPCBqOyBpKyspXG4gICAgICAgICAgICAgICAgaWYgKHByZWRpY2F0ZShhcnJheVtpXSwgaSkpXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGFycmF5W2ldKTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH0sXG5cbiAgICAgICAgYXJyYXlQdXNoQWxsOiBmdW5jdGlvbiAoYXJyYXksIHZhbHVlc1RvUHVzaCkge1xuICAgICAgICAgICAgaWYgKHZhbHVlc1RvUHVzaCBpbnN0YW5jZW9mIEFycmF5KVxuICAgICAgICAgICAgICAgIGFycmF5LnB1c2guYXBwbHkoYXJyYXksIHZhbHVlc1RvUHVzaCk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGogPSB2YWx1ZXNUb1B1c2gubGVuZ3RoOyBpIDwgajsgaSsrKVxuICAgICAgICAgICAgICAgICAgICBhcnJheS5wdXNoKHZhbHVlc1RvUHVzaFtpXSk7XG4gICAgICAgICAgICByZXR1cm4gYXJyYXk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgYWRkT3JSZW1vdmVJdGVtOiBmdW5jdGlvbihhcnJheSwgdmFsdWUsIGluY2x1ZGVkKSB7XG4gICAgICAgICAgICB2YXIgZXhpc3RpbmdFbnRyeUluZGV4ID0ga28udXRpbHMuYXJyYXlJbmRleE9mKGtvLnV0aWxzLnBlZWtPYnNlcnZhYmxlKGFycmF5KSwgdmFsdWUpO1xuICAgICAgICAgICAgaWYgKGV4aXN0aW5nRW50cnlJbmRleCA8IDApIHtcbiAgICAgICAgICAgICAgICBpZiAoaW5jbHVkZWQpXG4gICAgICAgICAgICAgICAgICAgIGFycmF5LnB1c2godmFsdWUpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoIWluY2x1ZGVkKVxuICAgICAgICAgICAgICAgICAgICBhcnJheS5zcGxpY2UoZXhpc3RpbmdFbnRyeUluZGV4LCAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBjYW5TZXRQcm90b3R5cGU6IGNhblNldFByb3RvdHlwZSxcblxuICAgICAgICBleHRlbmQ6IGV4dGVuZCxcblxuICAgICAgICBzZXRQcm90b3R5cGVPZjogc2V0UHJvdG90eXBlT2YsXG5cbiAgICAgICAgc2V0UHJvdG90eXBlT2ZPckV4dGVuZDogY2FuU2V0UHJvdG90eXBlID8gc2V0UHJvdG90eXBlT2YgOiBleHRlbmQsXG5cbiAgICAgICAgb2JqZWN0Rm9yRWFjaDogb2JqZWN0Rm9yRWFjaCxcblxuICAgICAgICBvYmplY3RNYXA6IGZ1bmN0aW9uKHNvdXJjZSwgbWFwcGluZykge1xuICAgICAgICAgICAgaWYgKCFzb3VyY2UpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHNvdXJjZTtcbiAgICAgICAgICAgIHZhciB0YXJnZXQgPSB7fTtcbiAgICAgICAgICAgIGZvciAodmFyIHByb3AgaW4gc291cmNlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNvdXJjZS5oYXNPd25Qcm9wZXJ0eShwcm9wKSkge1xuICAgICAgICAgICAgICAgICAgICB0YXJnZXRbcHJvcF0gPSBtYXBwaW5nKHNvdXJjZVtwcm9wXSwgcHJvcCwgc291cmNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGFyZ2V0O1xuICAgICAgICB9LFxuXG4gICAgICAgIGVtcHR5RG9tTm9kZTogZnVuY3Rpb24gKGRvbU5vZGUpIHtcbiAgICAgICAgICAgIHdoaWxlIChkb21Ob2RlLmZpcnN0Q2hpbGQpIHtcbiAgICAgICAgICAgICAgICBrby5yZW1vdmVOb2RlKGRvbU5vZGUuZmlyc3RDaGlsZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgbW92ZUNsZWFuZWROb2Rlc1RvQ29udGFpbmVyRWxlbWVudDogZnVuY3Rpb24obm9kZXMpIHtcbiAgICAgICAgICAgIC8vIEVuc3VyZSBpdCdzIGEgcmVhbCBhcnJheSwgYXMgd2UncmUgYWJvdXQgdG8gcmVwYXJlbnQgdGhlIG5vZGVzIGFuZFxuICAgICAgICAgICAgLy8gd2UgZG9uJ3Qgd2FudCB0aGUgdW5kZXJseWluZyBjb2xsZWN0aW9uIHRvIGNoYW5nZSB3aGlsZSB3ZSdyZSBkb2luZyB0aGF0LlxuICAgICAgICAgICAgdmFyIG5vZGVzQXJyYXkgPSBrby51dGlscy5tYWtlQXJyYXkobm9kZXMpO1xuICAgICAgICAgICAgdmFyIHRlbXBsYXRlRG9jdW1lbnQgPSAobm9kZXNBcnJheVswXSAmJiBub2Rlc0FycmF5WzBdLm93bmVyRG9jdW1lbnQpIHx8IGRvY3VtZW50O1xuXG4gICAgICAgICAgICB2YXIgY29udGFpbmVyID0gdGVtcGxhdGVEb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBqID0gbm9kZXNBcnJheS5sZW5ndGg7IGkgPCBqOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQoa28uY2xlYW5Ob2RlKG5vZGVzQXJyYXlbaV0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBjb250YWluZXI7XG4gICAgICAgIH0sXG5cbiAgICAgICAgY2xvbmVOb2RlczogZnVuY3Rpb24gKG5vZGVzQXJyYXksIHNob3VsZENsZWFuTm9kZXMpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBqID0gbm9kZXNBcnJheS5sZW5ndGgsIG5ld05vZGVzQXJyYXkgPSBbXTsgaSA8IGo7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBjbG9uZWROb2RlID0gbm9kZXNBcnJheVtpXS5jbG9uZU5vZGUodHJ1ZSk7XG4gICAgICAgICAgICAgICAgbmV3Tm9kZXNBcnJheS5wdXNoKHNob3VsZENsZWFuTm9kZXMgPyBrby5jbGVhbk5vZGUoY2xvbmVkTm9kZSkgOiBjbG9uZWROb2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuZXdOb2Rlc0FycmF5O1xuICAgICAgICB9LFxuXG4gICAgICAgIHNldERvbU5vZGVDaGlsZHJlbjogZnVuY3Rpb24gKGRvbU5vZGUsIGNoaWxkTm9kZXMpIHtcbiAgICAgICAgICAgIGtvLnV0aWxzLmVtcHR5RG9tTm9kZShkb21Ob2RlKTtcbiAgICAgICAgICAgIGlmIChjaGlsZE5vZGVzKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGogPSBjaGlsZE5vZGVzLmxlbmd0aDsgaSA8IGo7IGkrKylcbiAgICAgICAgICAgICAgICAgICAgZG9tTm9kZS5hcHBlbmRDaGlsZChjaGlsZE5vZGVzW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICByZXBsYWNlRG9tTm9kZXM6IGZ1bmN0aW9uIChub2RlVG9SZXBsYWNlT3JOb2RlQXJyYXksIG5ld05vZGVzQXJyYXkpIHtcbiAgICAgICAgICAgIHZhciBub2Rlc1RvUmVwbGFjZUFycmF5ID0gbm9kZVRvUmVwbGFjZU9yTm9kZUFycmF5Lm5vZGVUeXBlID8gW25vZGVUb1JlcGxhY2VPck5vZGVBcnJheV0gOiBub2RlVG9SZXBsYWNlT3JOb2RlQXJyYXk7XG4gICAgICAgICAgICBpZiAobm9kZXNUb1JlcGxhY2VBcnJheS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgdmFyIGluc2VydGlvblBvaW50ID0gbm9kZXNUb1JlcGxhY2VBcnJheVswXTtcbiAgICAgICAgICAgICAgICB2YXIgcGFyZW50ID0gaW5zZXJ0aW9uUG9pbnQucGFyZW50Tm9kZTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgaiA9IG5ld05vZGVzQXJyYXkubGVuZ3RoOyBpIDwgajsgaSsrKVxuICAgICAgICAgICAgICAgICAgICBwYXJlbnQuaW5zZXJ0QmVmb3JlKG5ld05vZGVzQXJyYXlbaV0sIGluc2VydGlvblBvaW50KTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgaiA9IG5vZGVzVG9SZXBsYWNlQXJyYXkubGVuZ3RoOyBpIDwgajsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGtvLnJlbW92ZU5vZGUobm9kZXNUb1JlcGxhY2VBcnJheVtpXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIGZpeFVwQ29udGludW91c05vZGVBcnJheTogZnVuY3Rpb24oY29udGludW91c05vZGVBcnJheSwgcGFyZW50Tm9kZSkge1xuICAgICAgICAgICAgLy8gQmVmb3JlIGFjdGluZyBvbiBhIHNldCBvZiBub2RlcyB0aGF0IHdlcmUgcHJldmlvdXNseSBvdXRwdXR0ZWQgYnkgYSB0ZW1wbGF0ZSBmdW5jdGlvbiwgd2UgaGF2ZSB0byByZWNvbmNpbGVcbiAgICAgICAgICAgIC8vIHRoZW0gYWdhaW5zdCB3aGF0IGlzIGluIHRoZSBET00gcmlnaHQgbm93LiBJdCBtYXkgYmUgdGhhdCBzb21lIG9mIHRoZSBub2RlcyBoYXZlIGFscmVhZHkgYmVlbiByZW1vdmVkLCBvciB0aGF0XG4gICAgICAgICAgICAvLyBuZXcgbm9kZXMgbWlnaHQgaGF2ZSBiZWVuIGluc2VydGVkIGluIHRoZSBtaWRkbGUsIGZvciBleGFtcGxlIGJ5IGEgYmluZGluZy4gQWxzbywgdGhlcmUgbWF5IHByZXZpb3VzbHkgaGF2ZSBiZWVuXG4gICAgICAgICAgICAvLyBsZWFkaW5nIGNvbW1lbnQgbm9kZXMgKGNyZWF0ZWQgYnkgcmV3cml0dGVuIHN0cmluZy1iYXNlZCB0ZW1wbGF0ZXMpIHRoYXQgaGF2ZSBzaW5jZSBiZWVuIHJlbW92ZWQgZHVyaW5nIGJpbmRpbmcuXG4gICAgICAgICAgICAvLyBTbywgdGhpcyBmdW5jdGlvbiB0cmFuc2xhdGVzIHRoZSBvbGQgXCJtYXBcIiBvdXRwdXQgYXJyYXkgaW50byBpdHMgYmVzdCBndWVzcyBvZiB0aGUgc2V0IG9mIGN1cnJlbnQgRE9NIG5vZGVzLlxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vIFJ1bGVzOlxuICAgICAgICAgICAgLy8gICBbQV0gQW55IGxlYWRpbmcgbm9kZXMgdGhhdCBoYXZlIGJlZW4gcmVtb3ZlZCBzaG91bGQgYmUgaWdub3JlZFxuICAgICAgICAgICAgLy8gICAgICAgVGhlc2UgbW9zdCBsaWtlbHkgY29ycmVzcG9uZCB0byBtZW1vaXphdGlvbiBub2RlcyB0aGF0IHdlcmUgYWxyZWFkeSByZW1vdmVkIGR1cmluZyBiaW5kaW5nXG4gICAgICAgICAgICAvLyAgICAgICBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2tub2Nrb3V0L2tub2Nrb3V0L3B1bGwvNDQwXG4gICAgICAgICAgICAvLyAgIFtCXSBBbnkgdHJhaWxpbmcgbm9kZXMgdGhhdCBoYXZlIGJlZW4gcmVtb3ZlIHNob3VsZCBiZSBpZ25vcmVkXG4gICAgICAgICAgICAvLyAgICAgICBUaGlzIHByZXZlbnRzIHRoZSBjb2RlIGhlcmUgZnJvbSBhZGRpbmcgdW5yZWxhdGVkIG5vZGVzIHRvIHRoZSBhcnJheSB3aGlsZSBwcm9jZXNzaW5nIHJ1bGUgW0NdXG4gICAgICAgICAgICAvLyAgICAgICBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2tub2Nrb3V0L2tub2Nrb3V0L3B1bGwvMTkwM1xuICAgICAgICAgICAgLy8gICBbQ10gV2Ugd2FudCB0byBvdXRwdXQgYSBjb250aW51b3VzIHNlcmllcyBvZiBub2Rlcy4gU28sIGlnbm9yZSBhbnkgbm9kZXMgdGhhdCBoYXZlIGFscmVhZHkgYmVlbiByZW1vdmVkLFxuICAgICAgICAgICAgLy8gICAgICAgYW5kIGluY2x1ZGUgYW55IG5vZGVzIHRoYXQgaGF2ZSBiZWVuIGluc2VydGVkIGFtb25nIHRoZSBwcmV2aW91cyBjb2xsZWN0aW9uXG5cbiAgICAgICAgICAgIGlmIChjb250aW51b3VzTm9kZUFycmF5Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIC8vIFRoZSBwYXJlbnQgbm9kZSBjYW4gYmUgYSB2aXJ0dWFsIGVsZW1lbnQ7IHNvIGdldCB0aGUgcmVhbCBwYXJlbnQgbm9kZVxuICAgICAgICAgICAgICAgIHBhcmVudE5vZGUgPSAocGFyZW50Tm9kZS5ub2RlVHlwZSA9PT0gOCAmJiBwYXJlbnROb2RlLnBhcmVudE5vZGUpIHx8IHBhcmVudE5vZGU7XG5cbiAgICAgICAgICAgICAgICAvLyBSdWxlIFtBXVxuICAgICAgICAgICAgICAgIHdoaWxlIChjb250aW51b3VzTm9kZUFycmF5Lmxlbmd0aCAmJiBjb250aW51b3VzTm9kZUFycmF5WzBdLnBhcmVudE5vZGUgIT09IHBhcmVudE5vZGUpXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVvdXNOb2RlQXJyYXkuc3BsaWNlKDAsIDEpO1xuXG4gICAgICAgICAgICAgICAgLy8gUnVsZSBbQl1cbiAgICAgICAgICAgICAgICB3aGlsZSAoY29udGludW91c05vZGVBcnJheS5sZW5ndGggPiAxICYmIGNvbnRpbnVvdXNOb2RlQXJyYXlbY29udGludW91c05vZGVBcnJheS5sZW5ndGggLSAxXS5wYXJlbnROb2RlICE9PSBwYXJlbnROb2RlKVxuICAgICAgICAgICAgICAgICAgICBjb250aW51b3VzTm9kZUFycmF5Lmxlbmd0aC0tO1xuXG4gICAgICAgICAgICAgICAgLy8gUnVsZSBbQ11cbiAgICAgICAgICAgICAgICBpZiAoY29udGludW91c05vZGVBcnJheS5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjdXJyZW50ID0gY29udGludW91c05vZGVBcnJheVswXSwgbGFzdCA9IGNvbnRpbnVvdXNOb2RlQXJyYXlbY29udGludW91c05vZGVBcnJheS5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgICAgICAgICAgLy8gUmVwbGFjZSB3aXRoIHRoZSBhY3R1YWwgbmV3IGNvbnRpbnVvdXMgbm9kZSBzZXRcbiAgICAgICAgICAgICAgICAgICAgY29udGludW91c05vZGVBcnJheS5sZW5ndGggPSAwO1xuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoY3VycmVudCAhPT0gbGFzdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludW91c05vZGVBcnJheS5wdXNoKGN1cnJlbnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudCA9IGN1cnJlbnQubmV4dFNpYmxpbmc7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29udGludW91c05vZGVBcnJheS5wdXNoKGxhc3QpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBjb250aW51b3VzTm9kZUFycmF5O1xuICAgICAgICB9LFxuXG4gICAgICAgIHNldE9wdGlvbk5vZGVTZWxlY3Rpb25TdGF0ZTogZnVuY3Rpb24gKG9wdGlvbk5vZGUsIGlzU2VsZWN0ZWQpIHtcbiAgICAgICAgICAgIC8vIElFNiBzb21ldGltZXMgdGhyb3dzIFwidW5rbm93biBlcnJvclwiIGlmIHlvdSB0cnkgdG8gd3JpdGUgdG8gLnNlbGVjdGVkIGRpcmVjdGx5LCB3aGVyZWFzIEZpcmVmb3ggc3RydWdnbGVzIHdpdGggc2V0QXR0cmlidXRlLiBQaWNrIG9uZSBiYXNlZCBvbiBicm93c2VyLlxuICAgICAgICAgICAgaWYgKGllVmVyc2lvbiA8IDcpXG4gICAgICAgICAgICAgICAgb3B0aW9uTm9kZS5zZXRBdHRyaWJ1dGUoXCJzZWxlY3RlZFwiLCBpc1NlbGVjdGVkKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBvcHRpb25Ob2RlLnNlbGVjdGVkID0gaXNTZWxlY3RlZDtcbiAgICAgICAgfSxcblxuICAgICAgICBzdHJpbmdUcmltOiBmdW5jdGlvbiAoc3RyaW5nKSB7XG4gICAgICAgICAgICByZXR1cm4gc3RyaW5nID09PSBudWxsIHx8IHN0cmluZyA9PT0gdW5kZWZpbmVkID8gJycgOlxuICAgICAgICAgICAgICAgIHN0cmluZy50cmltID9cbiAgICAgICAgICAgICAgICAgICAgc3RyaW5nLnRyaW0oKSA6XG4gICAgICAgICAgICAgICAgICAgIHN0cmluZy50b1N0cmluZygpLnJlcGxhY2UoL15bXFxzXFx4YTBdK3xbXFxzXFx4YTBdKyQvZywgJycpO1xuICAgICAgICB9LFxuXG4gICAgICAgIHN0cmluZ1N0YXJ0c1dpdGg6IGZ1bmN0aW9uIChzdHJpbmcsIHN0YXJ0c1dpdGgpIHtcbiAgICAgICAgICAgIHN0cmluZyA9IHN0cmluZyB8fCBcIlwiO1xuICAgICAgICAgICAgaWYgKHN0YXJ0c1dpdGgubGVuZ3RoID4gc3RyaW5nLmxlbmd0aClcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICByZXR1cm4gc3RyaW5nLnN1YnN0cmluZygwLCBzdGFydHNXaXRoLmxlbmd0aCkgPT09IHN0YXJ0c1dpdGg7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZG9tTm9kZUlzQ29udGFpbmVkQnk6IGZ1bmN0aW9uIChub2RlLCBjb250YWluZWRCeU5vZGUpIHtcbiAgICAgICAgICAgIGlmIChub2RlID09PSBjb250YWluZWRCeU5vZGUpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICBpZiAobm9kZS5ub2RlVHlwZSA9PT0gMTEpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlOyAvLyBGaXhlcyBpc3N1ZSAjMTE2MiAtIGNhbid0IHVzZSBub2RlLmNvbnRhaW5zIGZvciBkb2N1bWVudCBmcmFnbWVudHMgb24gSUU4XG4gICAgICAgICAgICBpZiAoY29udGFpbmVkQnlOb2RlLmNvbnRhaW5zKVxuICAgICAgICAgICAgICAgIHJldHVybiBjb250YWluZWRCeU5vZGUuY29udGFpbnMobm9kZS5ub2RlVHlwZSA9PT0gMyA/IG5vZGUucGFyZW50Tm9kZSA6IG5vZGUpO1xuICAgICAgICAgICAgaWYgKGNvbnRhaW5lZEJ5Tm9kZS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbilcbiAgICAgICAgICAgICAgICByZXR1cm4gKGNvbnRhaW5lZEJ5Tm9kZS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbihub2RlKSAmIDE2KSA9PSAxNjtcbiAgICAgICAgICAgIHdoaWxlIChub2RlICYmIG5vZGUgIT0gY29udGFpbmVkQnlOb2RlKSB7XG4gICAgICAgICAgICAgICAgbm9kZSA9IG5vZGUucGFyZW50Tm9kZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAhIW5vZGU7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZG9tTm9kZUlzQXR0YWNoZWRUb0RvY3VtZW50OiBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgICAgcmV0dXJuIGtvLnV0aWxzLmRvbU5vZGVJc0NvbnRhaW5lZEJ5KG5vZGUsIG5vZGUub3duZXJEb2N1bWVudC5kb2N1bWVudEVsZW1lbnQpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGFueURvbU5vZGVJc0F0dGFjaGVkVG9Eb2N1bWVudDogZnVuY3Rpb24obm9kZXMpIHtcbiAgICAgICAgICAgIHJldHVybiAhIWtvLnV0aWxzLmFycmF5Rmlyc3Qobm9kZXMsIGtvLnV0aWxzLmRvbU5vZGVJc0F0dGFjaGVkVG9Eb2N1bWVudCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgdGFnTmFtZUxvd2VyOiBmdW5jdGlvbihlbGVtZW50KSB7XG4gICAgICAgICAgICAvLyBGb3IgSFRNTCBlbGVtZW50cywgdGFnTmFtZSB3aWxsIGFsd2F5cyBiZSB1cHBlciBjYXNlOyBmb3IgWEhUTUwgZWxlbWVudHMsIGl0J2xsIGJlIGxvd2VyIGNhc2UuXG4gICAgICAgICAgICAvLyBQb3NzaWJsZSBmdXR1cmUgb3B0aW1pemF0aW9uOiBJZiB3ZSBrbm93IGl0J3MgYW4gZWxlbWVudCBmcm9tIGFuIFhIVE1MIGRvY3VtZW50IChub3QgSFRNTCksXG4gICAgICAgICAgICAvLyB3ZSBkb24ndCBuZWVkIHRvIGRvIHRoZSAudG9Mb3dlckNhc2UoKSBhcyBpdCB3aWxsIGFsd2F5cyBiZSBsb3dlciBjYXNlIGFueXdheS5cbiAgICAgICAgICAgIHJldHVybiBlbGVtZW50ICYmIGVsZW1lbnQudGFnTmFtZSAmJiBlbGVtZW50LnRhZ05hbWUudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgfSxcblxuICAgICAgICBjYXRjaEZ1bmN0aW9uRXJyb3JzOiBmdW5jdGlvbiAoZGVsZWdhdGUpIHtcbiAgICAgICAgICAgIHJldHVybiBrb1snb25FcnJvciddID8gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkZWxlZ2F0ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAga29bJ29uRXJyb3InXSAmJiBrb1snb25FcnJvciddKGUpO1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gOiBkZWxlZ2F0ZTtcbiAgICAgICAgfSxcblxuICAgICAgICBzZXRUaW1lb3V0OiBmdW5jdGlvbiAoaGFuZGxlciwgdGltZW91dCkge1xuICAgICAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoa28udXRpbHMuY2F0Y2hGdW5jdGlvbkVycm9ycyhoYW5kbGVyKSwgdGltZW91dCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZGVmZXJFcnJvcjogZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBrb1snb25FcnJvciddICYmIGtvWydvbkVycm9yJ10oZXJyb3IpO1xuICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgfSwgMCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgcmVnaXN0ZXJFdmVudEhhbmRsZXI6IGZ1bmN0aW9uIChlbGVtZW50LCBldmVudFR5cGUsIGhhbmRsZXIpIHtcbiAgICAgICAgICAgIHZhciB3cmFwcGVkSGFuZGxlciA9IGtvLnV0aWxzLmNhdGNoRnVuY3Rpb25FcnJvcnMoaGFuZGxlcik7XG5cbiAgICAgICAgICAgIHZhciBtdXN0VXNlQXR0YWNoRXZlbnQgPSBpZVZlcnNpb24gJiYgZXZlbnRzVGhhdE11c3RCZVJlZ2lzdGVyZWRVc2luZ0F0dGFjaEV2ZW50W2V2ZW50VHlwZV07XG4gICAgICAgICAgICBpZiAoIWtvLm9wdGlvbnNbJ3VzZU9ubHlOYXRpdmVFdmVudHMnXSAmJiAhbXVzdFVzZUF0dGFjaEV2ZW50ICYmIGpRdWVyeUluc3RhbmNlKSB7XG4gICAgICAgICAgICAgICAgalF1ZXJ5SW5zdGFuY2UoZWxlbWVudClbJ2JpbmQnXShldmVudFR5cGUsIHdyYXBwZWRIYW5kbGVyKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIW11c3RVc2VBdHRhY2hFdmVudCAmJiB0eXBlb2YgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyID09IFwiZnVuY3Rpb25cIilcbiAgICAgICAgICAgICAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoZXZlbnRUeXBlLCB3cmFwcGVkSGFuZGxlciwgZmFsc2UpO1xuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIGVsZW1lbnQuYXR0YWNoRXZlbnQgIT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgICAgIHZhciBhdHRhY2hFdmVudEhhbmRsZXIgPSBmdW5jdGlvbiAoZXZlbnQpIHsgd3JhcHBlZEhhbmRsZXIuY2FsbChlbGVtZW50LCBldmVudCk7IH0sXG4gICAgICAgICAgICAgICAgICAgIGF0dGFjaEV2ZW50TmFtZSA9IFwib25cIiArIGV2ZW50VHlwZTtcbiAgICAgICAgICAgICAgICBlbGVtZW50LmF0dGFjaEV2ZW50KGF0dGFjaEV2ZW50TmFtZSwgYXR0YWNoRXZlbnRIYW5kbGVyKTtcblxuICAgICAgICAgICAgICAgIC8vIElFIGRvZXMgbm90IGRpc3Bvc2UgYXR0YWNoRXZlbnQgaGFuZGxlcnMgYXV0b21hdGljYWxseSAodW5saWtlIHdpdGggYWRkRXZlbnRMaXN0ZW5lcilcbiAgICAgICAgICAgICAgICAvLyBzbyB0byBhdm9pZCBsZWFrcywgd2UgaGF2ZSB0byByZW1vdmUgdGhlbSBtYW51YWxseS4gU2VlIGJ1ZyAjODU2XG4gICAgICAgICAgICAgICAga28udXRpbHMuZG9tTm9kZURpc3Bvc2FsLmFkZERpc3Bvc2VDYWxsYmFjayhlbGVtZW50LCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5kZXRhY2hFdmVudChhdHRhY2hFdmVudE5hbWUsIGF0dGFjaEV2ZW50SGFuZGxlcik7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2VcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJCcm93c2VyIGRvZXNuJ3Qgc3VwcG9ydCBhZGRFdmVudExpc3RlbmVyIG9yIGF0dGFjaEV2ZW50XCIpO1xuICAgICAgICB9LFxuXG4gICAgICAgIHRyaWdnZXJFdmVudDogZnVuY3Rpb24gKGVsZW1lbnQsIGV2ZW50VHlwZSkge1xuICAgICAgICAgICAgaWYgKCEoZWxlbWVudCAmJiBlbGVtZW50Lm5vZGVUeXBlKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJlbGVtZW50IG11c3QgYmUgYSBET00gbm9kZSB3aGVuIGNhbGxpbmcgdHJpZ2dlckV2ZW50XCIpO1xuXG4gICAgICAgICAgICAvLyBGb3IgY2xpY2sgZXZlbnRzIG9uIGNoZWNrYm94ZXMgYW5kIHJhZGlvIGJ1dHRvbnMsIGpRdWVyeSB0b2dnbGVzIHRoZSBlbGVtZW50IGNoZWNrZWQgc3RhdGUgKmFmdGVyKiB0aGVcbiAgICAgICAgICAgIC8vIGV2ZW50IGhhbmRsZXIgcnVucyBpbnN0ZWFkIG9mICpiZWZvcmUqLiAoVGhpcyB3YXMgZml4ZWQgaW4gMS45IGZvciBjaGVja2JveGVzIGJ1dCBub3QgZm9yIHJhZGlvIGJ1dHRvbnMuKVxuICAgICAgICAgICAgLy8gSUUgZG9lc24ndCBjaGFuZ2UgdGhlIGNoZWNrZWQgc3RhdGUgd2hlbiB5b3UgdHJpZ2dlciB0aGUgY2xpY2sgZXZlbnQgdXNpbmcgXCJmaXJlRXZlbnRcIi5cbiAgICAgICAgICAgIC8vIEluIGJvdGggY2FzZXMsIHdlJ2xsIHVzZSB0aGUgY2xpY2sgbWV0aG9kIGluc3RlYWQuXG4gICAgICAgICAgICB2YXIgdXNlQ2xpY2tXb3JrYXJvdW5kID0gaXNDbGlja09uQ2hlY2thYmxlRWxlbWVudChlbGVtZW50LCBldmVudFR5cGUpO1xuXG4gICAgICAgICAgICBpZiAoIWtvLm9wdGlvbnNbJ3VzZU9ubHlOYXRpdmVFdmVudHMnXSAmJiBqUXVlcnlJbnN0YW5jZSAmJiAhdXNlQ2xpY2tXb3JrYXJvdW5kKSB7XG4gICAgICAgICAgICAgICAgalF1ZXJ5SW5zdGFuY2UoZWxlbWVudClbJ3RyaWdnZXInXShldmVudFR5cGUpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgZG9jdW1lbnQuY3JlYXRlRXZlbnQgPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBlbGVtZW50LmRpc3BhdGNoRXZlbnQgPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBldmVudENhdGVnb3J5ID0ga25vd25FdmVudFR5cGVzQnlFdmVudE5hbWVbZXZlbnRUeXBlXSB8fCBcIkhUTUxFdmVudHNcIjtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGV2ZW50ID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoZXZlbnRDYXRlZ29yeSk7XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50LmluaXRFdmVudChldmVudFR5cGUsIHRydWUsIHRydWUsIHdpbmRvdywgMCwgMCwgMCwgMCwgMCwgZmFsc2UsIGZhbHNlLCBmYWxzZSwgZmFsc2UsIDAsIGVsZW1lbnQpO1xuICAgICAgICAgICAgICAgICAgICBlbGVtZW50LmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoZSBzdXBwbGllZCBlbGVtZW50IGRvZXNuJ3Qgc3VwcG9ydCBkaXNwYXRjaEV2ZW50XCIpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh1c2VDbGlja1dvcmthcm91bmQgJiYgZWxlbWVudC5jbGljaykge1xuICAgICAgICAgICAgICAgIGVsZW1lbnQuY2xpY2soKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGVsZW1lbnQuZmlyZUV2ZW50ICE9IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgICAgICBlbGVtZW50LmZpcmVFdmVudChcIm9uXCIgKyBldmVudFR5cGUpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJCcm93c2VyIGRvZXNuJ3Qgc3VwcG9ydCB0cmlnZ2VyaW5nIGV2ZW50c1wiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICB1bndyYXBPYnNlcnZhYmxlOiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiBrby5pc09ic2VydmFibGUodmFsdWUpID8gdmFsdWUoKSA6IHZhbHVlO1xuICAgICAgICB9LFxuXG4gICAgICAgIHBlZWtPYnNlcnZhYmxlOiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiBrby5pc09ic2VydmFibGUodmFsdWUpID8gdmFsdWUucGVlaygpIDogdmFsdWU7XG4gICAgICAgIH0sXG5cbiAgICAgICAgdG9nZ2xlRG9tTm9kZUNzc0NsYXNzOiB0b2dnbGVEb21Ob2RlQ3NzQ2xhc3MsXG5cbiAgICAgICAgc2V0VGV4dENvbnRlbnQ6IGZ1bmN0aW9uKGVsZW1lbnQsIHRleHRDb250ZW50KSB7XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBrby51dGlscy51bndyYXBPYnNlcnZhYmxlKHRleHRDb250ZW50KTtcbiAgICAgICAgICAgIGlmICgodmFsdWUgPT09IG51bGwpIHx8ICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSlcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IFwiXCI7XG5cbiAgICAgICAgICAgIC8vIFdlIG5lZWQgdGhlcmUgdG8gYmUgZXhhY3RseSBvbmUgY2hpbGQ6IGEgdGV4dCBub2RlLlxuICAgICAgICAgICAgLy8gSWYgdGhlcmUgYXJlIG5vIGNoaWxkcmVuLCBtb3JlIHRoYW4gb25lLCBvciBpZiBpdCdzIG5vdCBhIHRleHQgbm9kZSxcbiAgICAgICAgICAgIC8vIHdlJ2xsIGNsZWFyIGV2ZXJ5dGhpbmcgYW5kIGNyZWF0ZSBhIHNpbmdsZSB0ZXh0IG5vZGUuXG4gICAgICAgICAgICB2YXIgaW5uZXJUZXh0Tm9kZSA9IGtvLnZpcnR1YWxFbGVtZW50cy5maXJzdENoaWxkKGVsZW1lbnQpO1xuICAgICAgICAgICAgaWYgKCFpbm5lclRleHROb2RlIHx8IGlubmVyVGV4dE5vZGUubm9kZVR5cGUgIT0gMyB8fCBrby52aXJ0dWFsRWxlbWVudHMubmV4dFNpYmxpbmcoaW5uZXJUZXh0Tm9kZSkpIHtcbiAgICAgICAgICAgICAgICBrby52aXJ0dWFsRWxlbWVudHMuc2V0RG9tTm9kZUNoaWxkcmVuKGVsZW1lbnQsIFtlbGVtZW50Lm93bmVyRG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUodmFsdWUpXSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlubmVyVGV4dE5vZGUuZGF0YSA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBrby51dGlscy5mb3JjZVJlZnJlc2goZWxlbWVudCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgc2V0RWxlbWVudE5hbWU6IGZ1bmN0aW9uKGVsZW1lbnQsIG5hbWUpIHtcbiAgICAgICAgICAgIGVsZW1lbnQubmFtZSA9IG5hbWU7XG5cbiAgICAgICAgICAgIC8vIFdvcmthcm91bmQgSUUgNi83IGlzc3VlXG4gICAgICAgICAgICAvLyAtIGh0dHBzOi8vZ2l0aHViLmNvbS9TdGV2ZVNhbmRlcnNvbi9rbm9ja291dC9pc3N1ZXMvMTk3XG4gICAgICAgICAgICAvLyAtIGh0dHA6Ly93d3cubWF0dHM0MTEuY29tL3Bvc3Qvc2V0dGluZ190aGVfbmFtZV9hdHRyaWJ1dGVfaW5faWVfZG9tL1xuICAgICAgICAgICAgaWYgKGllVmVyc2lvbiA8PSA3KSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5tZXJnZUF0dHJpYnV0ZXMoZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcIjxpbnB1dCBuYW1lPSdcIiArIGVsZW1lbnQubmFtZSArIFwiJy8+XCIpLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoKGUpIHt9IC8vIEZvciBJRTkgd2l0aCBkb2MgbW9kZSBcIklFOSBTdGFuZGFyZHNcIiBhbmQgYnJvd3NlciBtb2RlIFwiSUU5IENvbXBhdGliaWxpdHkgVmlld1wiXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgZm9yY2VSZWZyZXNoOiBmdW5jdGlvbihub2RlKSB7XG4gICAgICAgICAgICAvLyBXb3JrYXJvdW5kIGZvciBhbiBJRTkgcmVuZGVyaW5nIGJ1ZyAtIGh0dHBzOi8vZ2l0aHViLmNvbS9TdGV2ZVNhbmRlcnNvbi9rbm9ja291dC9pc3N1ZXMvMjA5XG4gICAgICAgICAgICBpZiAoaWVWZXJzaW9uID49IDkpIHtcbiAgICAgICAgICAgICAgICAvLyBGb3IgdGV4dCBub2RlcyBhbmQgY29tbWVudCBub2RlcyAobW9zdCBsaWtlbHkgdmlydHVhbCBlbGVtZW50cyksIHdlIHdpbGwgaGF2ZSB0byByZWZyZXNoIHRoZSBjb250YWluZXJcbiAgICAgICAgICAgICAgICB2YXIgZWxlbSA9IG5vZGUubm9kZVR5cGUgPT0gMSA/IG5vZGUgOiBub2RlLnBhcmVudE5vZGU7XG4gICAgICAgICAgICAgICAgaWYgKGVsZW0uc3R5bGUpXG4gICAgICAgICAgICAgICAgICAgIGVsZW0uc3R5bGUuem9vbSA9IGVsZW0uc3R5bGUuem9vbTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBlbnN1cmVTZWxlY3RFbGVtZW50SXNSZW5kZXJlZENvcnJlY3RseTogZnVuY3Rpb24oc2VsZWN0RWxlbWVudCkge1xuICAgICAgICAgICAgLy8gV29ya2Fyb3VuZCBmb3IgSUU5IHJlbmRlcmluZyBidWcgLSBpdCBkb2Vzbid0IHJlbGlhYmx5IGRpc3BsYXkgYWxsIHRoZSB0ZXh0IGluIGR5bmFtaWNhbGx5LWFkZGVkIHNlbGVjdCBib3hlcyB1bmxlc3MgeW91IGZvcmNlIGl0IHRvIHJlLXJlbmRlciBieSB1cGRhdGluZyB0aGUgd2lkdGguXG4gICAgICAgICAgICAvLyAoU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9TdGV2ZVNhbmRlcnNvbi9rbm9ja291dC9pc3N1ZXMvMzEyLCBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzU5MDg0OTQvc2VsZWN0LW9ubHktc2hvd3MtZmlyc3QtY2hhci1vZi1zZWxlY3RlZC1vcHRpb24pXG4gICAgICAgICAgICAvLyBBbHNvIGZpeGVzIElFNyBhbmQgSUU4IGJ1ZyB0aGF0IGNhdXNlcyBzZWxlY3RzIHRvIGJlIHplcm8gd2lkdGggaWYgZW5jbG9zZWQgYnkgJ2lmJyBvciAnd2l0aCcuIChTZWUgaXNzdWUgIzgzOSlcbiAgICAgICAgICAgIGlmIChpZVZlcnNpb24pIHtcbiAgICAgICAgICAgICAgICB2YXIgb3JpZ2luYWxXaWR0aCA9IHNlbGVjdEVsZW1lbnQuc3R5bGUud2lkdGg7XG4gICAgICAgICAgICAgICAgc2VsZWN0RWxlbWVudC5zdHlsZS53aWR0aCA9IDA7XG4gICAgICAgICAgICAgICAgc2VsZWN0RWxlbWVudC5zdHlsZS53aWR0aCA9IG9yaWdpbmFsV2lkdGg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgcmFuZ2U6IGZ1bmN0aW9uIChtaW4sIG1heCkge1xuICAgICAgICAgICAgbWluID0ga28udXRpbHMudW53cmFwT2JzZXJ2YWJsZShtaW4pO1xuICAgICAgICAgICAgbWF4ID0ga28udXRpbHMudW53cmFwT2JzZXJ2YWJsZShtYXgpO1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IG1pbjsgaSA8PSBtYXg7IGkrKylcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChpKTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH0sXG5cbiAgICAgICAgbWFrZUFycmF5OiBmdW5jdGlvbihhcnJheUxpa2VPYmplY3QpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBqID0gYXJyYXlMaWtlT2JqZWN0Lmxlbmd0aDsgaSA8IGo7IGkrKykge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGFycmF5TGlrZU9iamVjdFtpXSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfSxcblxuICAgICAgICBjcmVhdGVTeW1ib2xPclN0cmluZzogZnVuY3Rpb24oaWRlbnRpZmllcikge1xuICAgICAgICAgICAgcmV0dXJuIGNhblVzZVN5bWJvbHMgPyBTeW1ib2woaWRlbnRpZmllcikgOiBpZGVudGlmaWVyO1xuICAgICAgICB9LFxuXG4gICAgICAgIGlzSWU2IDogaXNJZTYsXG4gICAgICAgIGlzSWU3IDogaXNJZTcsXG4gICAgICAgIGllVmVyc2lvbiA6IGllVmVyc2lvbixcblxuICAgICAgICBnZXRGb3JtRmllbGRzOiBmdW5jdGlvbihmb3JtLCBmaWVsZE5hbWUpIHtcbiAgICAgICAgICAgIHZhciBmaWVsZHMgPSBrby51dGlscy5tYWtlQXJyYXkoZm9ybS5nZXRFbGVtZW50c0J5VGFnTmFtZShcImlucHV0XCIpKS5jb25jYXQoa28udXRpbHMubWFrZUFycmF5KGZvcm0uZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJ0ZXh0YXJlYVwiKSkpO1xuICAgICAgICAgICAgdmFyIGlzTWF0Y2hpbmdGaWVsZCA9ICh0eXBlb2YgZmllbGROYW1lID09ICdzdHJpbmcnKVxuICAgICAgICAgICAgICAgID8gZnVuY3Rpb24oZmllbGQpIHsgcmV0dXJuIGZpZWxkLm5hbWUgPT09IGZpZWxkTmFtZSB9XG4gICAgICAgICAgICAgICAgOiBmdW5jdGlvbihmaWVsZCkgeyByZXR1cm4gZmllbGROYW1lLnRlc3QoZmllbGQubmFtZSkgfTsgLy8gVHJlYXQgZmllbGROYW1lIGFzIHJlZ2V4IG9yIG9iamVjdCBjb250YWluaW5nIHByZWRpY2F0ZVxuICAgICAgICAgICAgdmFyIG1hdGNoZXMgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSBmaWVsZHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNNYXRjaGluZ0ZpZWxkKGZpZWxkc1tpXSkpXG4gICAgICAgICAgICAgICAgICAgIG1hdGNoZXMucHVzaChmaWVsZHNbaV0pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiBtYXRjaGVzO1xuICAgICAgICB9LFxuXG4gICAgICAgIHBhcnNlSnNvbjogZnVuY3Rpb24gKGpzb25TdHJpbmcpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YganNvblN0cmluZyA9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAganNvblN0cmluZyA9IGtvLnV0aWxzLnN0cmluZ1RyaW0oanNvblN0cmluZyk7XG4gICAgICAgICAgICAgICAgaWYgKGpzb25TdHJpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKEpTT04gJiYgSlNPTi5wYXJzZSkgLy8gVXNlIG5hdGl2ZSBwYXJzaW5nIHdoZXJlIGF2YWlsYWJsZVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEpTT04ucGFyc2UoanNvblN0cmluZyk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAobmV3IEZ1bmN0aW9uKFwicmV0dXJuIFwiICsganNvblN0cmluZykpKCk7IC8vIEZhbGxiYWNrIG9uIGxlc3Mgc2FmZSBwYXJzaW5nIGZvciBvbGRlciBicm93c2Vyc1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9LFxuXG4gICAgICAgIHN0cmluZ2lmeUpzb246IGZ1bmN0aW9uIChkYXRhLCByZXBsYWNlciwgc3BhY2UpIHsgICAvLyByZXBsYWNlciBhbmQgc3BhY2UgYXJlIG9wdGlvbmFsXG4gICAgICAgICAgICBpZiAoIUpTT04gfHwgIUpTT04uc3RyaW5naWZ5KVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIEpTT04uc3RyaW5naWZ5KCkuIFNvbWUgYnJvd3NlcnMgKGUuZy4sIElFIDwgOCkgZG9uJ3Qgc3VwcG9ydCBpdCBuYXRpdmVseSwgYnV0IHlvdSBjYW4gb3ZlcmNvbWUgdGhpcyBieSBhZGRpbmcgYSBzY3JpcHQgcmVmZXJlbmNlIHRvIGpzb24yLmpzLCBkb3dubG9hZGFibGUgZnJvbSBodHRwOi8vd3d3Lmpzb24ub3JnL2pzb24yLmpzXCIpO1xuICAgICAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGtvLnV0aWxzLnVud3JhcE9ic2VydmFibGUoZGF0YSksIHJlcGxhY2VyLCBzcGFjZSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgcG9zdEpzb246IGZ1bmN0aW9uICh1cmxPckZvcm0sIGRhdGEsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgICAgICAgICAgdmFyIHBhcmFtcyA9IG9wdGlvbnNbJ3BhcmFtcyddIHx8IHt9O1xuICAgICAgICAgICAgdmFyIGluY2x1ZGVGaWVsZHMgPSBvcHRpb25zWydpbmNsdWRlRmllbGRzJ10gfHwgdGhpcy5maWVsZHNJbmNsdWRlZFdpdGhKc29uUG9zdDtcbiAgICAgICAgICAgIHZhciB1cmwgPSB1cmxPckZvcm07XG5cbiAgICAgICAgICAgIC8vIElmIHdlIHdlcmUgZ2l2ZW4gYSBmb3JtLCB1c2UgaXRzICdhY3Rpb24nIFVSTCBhbmQgcGljayBvdXQgYW55IHJlcXVlc3RlZCBmaWVsZCB2YWx1ZXNcbiAgICAgICAgICAgIGlmKCh0eXBlb2YgdXJsT3JGb3JtID09ICdvYmplY3QnKSAmJiAoa28udXRpbHMudGFnTmFtZUxvd2VyKHVybE9yRm9ybSkgPT09IFwiZm9ybVwiKSkge1xuICAgICAgICAgICAgICAgIHZhciBvcmlnaW5hbEZvcm0gPSB1cmxPckZvcm07XG4gICAgICAgICAgICAgICAgdXJsID0gb3JpZ2luYWxGb3JtLmFjdGlvbjtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gaW5jbHVkZUZpZWxkcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZmllbGRzID0ga28udXRpbHMuZ2V0Rm9ybUZpZWxkcyhvcmlnaW5hbEZvcm0sIGluY2x1ZGVGaWVsZHNbaV0pO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gZmllbGRzLmxlbmd0aCAtIDE7IGogPj0gMDsgai0tKVxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1zW2ZpZWxkc1tqXS5uYW1lXSA9IGZpZWxkc1tqXS52YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGRhdGEgPSBrby51dGlscy51bndyYXBPYnNlcnZhYmxlKGRhdGEpO1xuICAgICAgICAgICAgdmFyIGZvcm0gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZm9ybVwiKTtcbiAgICAgICAgICAgIGZvcm0uc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiO1xuICAgICAgICAgICAgZm9ybS5hY3Rpb24gPSB1cmw7XG4gICAgICAgICAgICBmb3JtLm1ldGhvZCA9IFwicG9zdFwiO1xuICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIGRhdGEpIHtcbiAgICAgICAgICAgICAgICAvLyBTaW5jZSAnZGF0YScgdGhpcyBpcyBhIG1vZGVsIG9iamVjdCwgd2UgaW5jbHVkZSBhbGwgcHJvcGVydGllcyBpbmNsdWRpbmcgdGhvc2UgaW5oZXJpdGVkIGZyb20gaXRzIHByb3RvdHlwZVxuICAgICAgICAgICAgICAgIHZhciBpbnB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpbnB1dFwiKTtcbiAgICAgICAgICAgICAgICBpbnB1dC50eXBlID0gXCJoaWRkZW5cIjtcbiAgICAgICAgICAgICAgICBpbnB1dC5uYW1lID0ga2V5O1xuICAgICAgICAgICAgICAgIGlucHV0LnZhbHVlID0ga28udXRpbHMuc3RyaW5naWZ5SnNvbihrby51dGlscy51bndyYXBPYnNlcnZhYmxlKGRhdGFba2V5XSkpO1xuICAgICAgICAgICAgICAgIGZvcm0uYXBwZW5kQ2hpbGQoaW5wdXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb2JqZWN0Rm9yRWFjaChwYXJhbXMsIGZ1bmN0aW9uKGtleSwgdmFsdWUpIHtcbiAgICAgICAgICAgICAgICB2YXIgaW5wdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaW5wdXRcIik7XG4gICAgICAgICAgICAgICAgaW5wdXQudHlwZSA9IFwiaGlkZGVuXCI7XG4gICAgICAgICAgICAgICAgaW5wdXQubmFtZSA9IGtleTtcbiAgICAgICAgICAgICAgICBpbnB1dC52YWx1ZSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIGZvcm0uYXBwZW5kQ2hpbGQoaW5wdXQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGZvcm0pO1xuICAgICAgICAgICAgb3B0aW9uc1snc3VibWl0dGVyJ10gPyBvcHRpb25zWydzdWJtaXR0ZXInXShmb3JtKSA6IGZvcm0uc3VibWl0KCk7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHsgZm9ybS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGZvcm0pOyB9LCAwKTtcbiAgICAgICAgfVxuICAgIH1cbn0oKSk7XG5cbmtvLmV4cG9ydFN5bWJvbCgndXRpbHMnLCBrby51dGlscyk7XG5rby5leHBvcnRTeW1ib2woJ3V0aWxzLmFycmF5Rm9yRWFjaCcsIGtvLnV0aWxzLmFycmF5Rm9yRWFjaCk7XG5rby5leHBvcnRTeW1ib2woJ3V0aWxzLmFycmF5Rmlyc3QnLCBrby51dGlscy5hcnJheUZpcnN0KTtcbmtvLmV4cG9ydFN5bWJvbCgndXRpbHMuYXJyYXlGaWx0ZXInLCBrby51dGlscy5hcnJheUZpbHRlcik7XG5rby5leHBvcnRTeW1ib2woJ3V0aWxzLmFycmF5R2V0RGlzdGluY3RWYWx1ZXMnLCBrby51dGlscy5hcnJheUdldERpc3RpbmN0VmFsdWVzKTtcbmtvLmV4cG9ydFN5bWJvbCgndXRpbHMuYXJyYXlJbmRleE9mJywga28udXRpbHMuYXJyYXlJbmRleE9mKTtcbmtvLmV4cG9ydFN5bWJvbCgndXRpbHMuYXJyYXlNYXAnLCBrby51dGlscy5hcnJheU1hcCk7XG5rby5leHBvcnRTeW1ib2woJ3V0aWxzLmFycmF5UHVzaEFsbCcsIGtvLnV0aWxzLmFycmF5UHVzaEFsbCk7XG5rby5leHBvcnRTeW1ib2woJ3V0aWxzLmFycmF5UmVtb3ZlSXRlbScsIGtvLnV0aWxzLmFycmF5UmVtb3ZlSXRlbSk7XG5rby5leHBvcnRTeW1ib2woJ3V0aWxzLmV4dGVuZCcsIGtvLnV0aWxzLmV4dGVuZCk7XG5rby5leHBvcnRTeW1ib2woJ3V0aWxzLmZpZWxkc0luY2x1ZGVkV2l0aEpzb25Qb3N0Jywga28udXRpbHMuZmllbGRzSW5jbHVkZWRXaXRoSnNvblBvc3QpO1xua28uZXhwb3J0U3ltYm9sKCd1dGlscy5nZXRGb3JtRmllbGRzJywga28udXRpbHMuZ2V0Rm9ybUZpZWxkcyk7XG5rby5leHBvcnRTeW1ib2woJ3V0aWxzLnBlZWtPYnNlcnZhYmxlJywga28udXRpbHMucGVla09ic2VydmFibGUpO1xua28uZXhwb3J0U3ltYm9sKCd1dGlscy5wb3N0SnNvbicsIGtvLnV0aWxzLnBvc3RKc29uKTtcbmtvLmV4cG9ydFN5bWJvbCgndXRpbHMucGFyc2VKc29uJywga28udXRpbHMucGFyc2VKc29uKTtcbmtvLmV4cG9ydFN5bWJvbCgndXRpbHMucmVnaXN0ZXJFdmVudEhhbmRsZXInLCBrby51dGlscy5yZWdpc3RlckV2ZW50SGFuZGxlcik7XG5rby5leHBvcnRTeW1ib2woJ3V0aWxzLnN0cmluZ2lmeUpzb24nLCBrby51dGlscy5zdHJpbmdpZnlKc29uKTtcbmtvLmV4cG9ydFN5bWJvbCgndXRpbHMucmFuZ2UnLCBrby51dGlscy5yYW5nZSk7XG5rby5leHBvcnRTeW1ib2woJ3V0aWxzLnRvZ2dsZURvbU5vZGVDc3NDbGFzcycsIGtvLnV0aWxzLnRvZ2dsZURvbU5vZGVDc3NDbGFzcyk7XG5rby5leHBvcnRTeW1ib2woJ3V0aWxzLnRyaWdnZXJFdmVudCcsIGtvLnV0aWxzLnRyaWdnZXJFdmVudCk7XG5rby5leHBvcnRTeW1ib2woJ3V0aWxzLnVud3JhcE9ic2VydmFibGUnLCBrby51dGlscy51bndyYXBPYnNlcnZhYmxlKTtcbmtvLmV4cG9ydFN5bWJvbCgndXRpbHMub2JqZWN0Rm9yRWFjaCcsIGtvLnV0aWxzLm9iamVjdEZvckVhY2gpO1xua28uZXhwb3J0U3ltYm9sKCd1dGlscy5hZGRPclJlbW92ZUl0ZW0nLCBrby51dGlscy5hZGRPclJlbW92ZUl0ZW0pO1xua28uZXhwb3J0U3ltYm9sKCd1dGlscy5zZXRUZXh0Q29udGVudCcsIGtvLnV0aWxzLnNldFRleHRDb250ZW50KTtcbmtvLmV4cG9ydFN5bWJvbCgndW53cmFwJywga28udXRpbHMudW53cmFwT2JzZXJ2YWJsZSk7IC8vIENvbnZlbmllbnQgc2hvcnRoYW5kLCBiZWNhdXNlIHRoaXMgaXMgdXNlZCBzbyBjb21tb25seVxuXG5pZiAoIUZ1bmN0aW9uLnByb3RvdHlwZVsnYmluZCddKSB7XG4gICAgLy8gRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQgaXMgYSBzdGFuZGFyZCBwYXJ0IG9mIEVDTUFTY3JpcHQgNXRoIEVkaXRpb24gKERlY2VtYmVyIDIwMDksIGh0dHA6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9wdWJsaWNhdGlvbnMvZmlsZXMvRUNNQS1TVC9FQ01BLTI2Mi5wZGYpXG4gICAgLy8gSW4gY2FzZSB0aGUgYnJvd3NlciBkb2Vzbid0IGltcGxlbWVudCBpdCBuYXRpdmVseSwgcHJvdmlkZSBhIEphdmFTY3JpcHQgaW1wbGVtZW50YXRpb24uIFRoaXMgaW1wbGVtZW50YXRpb24gaXMgYmFzZWQgb24gdGhlIG9uZSBpbiBwcm90b3R5cGUuanNcbiAgICBGdW5jdGlvbi5wcm90b3R5cGVbJ2JpbmQnXSA9IGZ1bmN0aW9uIChvYmplY3QpIHtcbiAgICAgICAgdmFyIG9yaWdpbmFsRnVuY3Rpb24gPSB0aGlzO1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gb3JpZ2luYWxGdW5jdGlvbi5hcHBseShvYmplY3QsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIHBhcnRpYWxBcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGFyZ3MgPSBwYXJ0aWFsQXJncy5zbGljZSgwKTtcbiAgICAgICAgICAgICAgICBhcmdzLnB1c2guYXBwbHkoYXJncywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gb3JpZ2luYWxGdW5jdGlvbi5hcHBseShvYmplY3QsIGFyZ3MpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH07XG59XG5cbmtvLnV0aWxzLmRvbURhdGEgPSBuZXcgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgdW5pcXVlSWQgPSAwO1xuICAgIHZhciBkYXRhU3RvcmVLZXlFeHBhbmRvUHJvcGVydHlOYW1lID0gXCJfX2tvX19cIiArIChuZXcgRGF0ZSkuZ2V0VGltZSgpO1xuICAgIHZhciBkYXRhU3RvcmUgPSB7fTtcblxuICAgIGZ1bmN0aW9uIGdldEFsbChub2RlLCBjcmVhdGVJZk5vdEZvdW5kKSB7XG4gICAgICAgIHZhciBkYXRhU3RvcmVLZXkgPSBub2RlW2RhdGFTdG9yZUtleUV4cGFuZG9Qcm9wZXJ0eU5hbWVdO1xuICAgICAgICB2YXIgaGFzRXhpc3RpbmdEYXRhU3RvcmUgPSBkYXRhU3RvcmVLZXkgJiYgKGRhdGFTdG9yZUtleSAhPT0gXCJudWxsXCIpICYmIGRhdGFTdG9yZVtkYXRhU3RvcmVLZXldO1xuICAgICAgICBpZiAoIWhhc0V4aXN0aW5nRGF0YVN0b3JlKSB7XG4gICAgICAgICAgICBpZiAoIWNyZWF0ZUlmTm90Rm91bmQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGRhdGFTdG9yZUtleSA9IG5vZGVbZGF0YVN0b3JlS2V5RXhwYW5kb1Byb3BlcnR5TmFtZV0gPSBcImtvXCIgKyB1bmlxdWVJZCsrO1xuICAgICAgICAgICAgZGF0YVN0b3JlW2RhdGFTdG9yZUtleV0gPSB7fTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGF0YVN0b3JlW2RhdGFTdG9yZUtleV07XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAobm9kZSwga2V5KSB7XG4gICAgICAgICAgICB2YXIgYWxsRGF0YUZvck5vZGUgPSBnZXRBbGwobm9kZSwgZmFsc2UpO1xuICAgICAgICAgICAgcmV0dXJuIGFsbERhdGFGb3JOb2RlID09PSB1bmRlZmluZWQgPyB1bmRlZmluZWQgOiBhbGxEYXRhRm9yTm9kZVtrZXldO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uIChub2RlLCBrZXksIHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSB3ZSBkb24ndCBhY3R1YWxseSBjcmVhdGUgYSBuZXcgZG9tRGF0YSBrZXkgaWYgd2UgYXJlIGFjdHVhbGx5IGRlbGV0aW5nIGEgdmFsdWVcbiAgICAgICAgICAgICAgICBpZiAoZ2V0QWxsKG5vZGUsIGZhbHNlKSA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgYWxsRGF0YUZvck5vZGUgPSBnZXRBbGwobm9kZSwgdHJ1ZSk7XG4gICAgICAgICAgICBhbGxEYXRhRm9yTm9kZVtrZXldID0gdmFsdWU7XG4gICAgICAgIH0sXG4gICAgICAgIGNsZWFyOiBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgICAgdmFyIGRhdGFTdG9yZUtleSA9IG5vZGVbZGF0YVN0b3JlS2V5RXhwYW5kb1Byb3BlcnR5TmFtZV07XG4gICAgICAgICAgICBpZiAoZGF0YVN0b3JlS2V5KSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIGRhdGFTdG9yZVtkYXRhU3RvcmVLZXldO1xuICAgICAgICAgICAgICAgIG5vZGVbZGF0YVN0b3JlS2V5RXhwYW5kb1Byb3BlcnR5TmFtZV0gPSBudWxsO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlOyAvLyBFeHBvc2luZyBcImRpZCBjbGVhblwiIGZsYWcgcHVyZWx5IHNvIHNwZWNzIGNhbiBpbmZlciB3aGV0aGVyIHRoaW5ncyBoYXZlIGJlZW4gY2xlYW5lZCB1cCBhcyBpbnRlbmRlZFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9LFxuXG4gICAgICAgIG5leHRLZXk6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiAodW5pcXVlSWQrKykgKyBkYXRhU3RvcmVLZXlFeHBhbmRvUHJvcGVydHlOYW1lO1xuICAgICAgICB9XG4gICAgfTtcbn0pKCk7XG5cbmtvLmV4cG9ydFN5bWJvbCgndXRpbHMuZG9tRGF0YScsIGtvLnV0aWxzLmRvbURhdGEpO1xua28uZXhwb3J0U3ltYm9sKCd1dGlscy5kb21EYXRhLmNsZWFyJywga28udXRpbHMuZG9tRGF0YS5jbGVhcik7IC8vIEV4cG9ydGluZyBvbmx5IHNvIHNwZWNzIGNhbiBjbGVhciB1cCBhZnRlciB0aGVtc2VsdmVzIGZ1bGx5XG5cbmtvLnV0aWxzLmRvbU5vZGVEaXNwb3NhbCA9IG5ldyAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBkb21EYXRhS2V5ID0ga28udXRpbHMuZG9tRGF0YS5uZXh0S2V5KCk7XG4gICAgdmFyIGNsZWFuYWJsZU5vZGVUeXBlcyA9IHsgMTogdHJ1ZSwgODogdHJ1ZSwgOTogdHJ1ZSB9OyAgICAgICAvLyBFbGVtZW50LCBDb21tZW50LCBEb2N1bWVudFxuICAgIHZhciBjbGVhbmFibGVOb2RlVHlwZXNXaXRoRGVzY2VuZGFudHMgPSB7IDE6IHRydWUsIDk6IHRydWUgfTsgLy8gRWxlbWVudCwgRG9jdW1lbnRcblxuICAgIGZ1bmN0aW9uIGdldERpc3Bvc2VDYWxsYmFja3NDb2xsZWN0aW9uKG5vZGUsIGNyZWF0ZUlmTm90Rm91bmQpIHtcbiAgICAgICAgdmFyIGFsbERpc3Bvc2VDYWxsYmFja3MgPSBrby51dGlscy5kb21EYXRhLmdldChub2RlLCBkb21EYXRhS2V5KTtcbiAgICAgICAgaWYgKChhbGxEaXNwb3NlQ2FsbGJhY2tzID09PSB1bmRlZmluZWQpICYmIGNyZWF0ZUlmTm90Rm91bmQpIHtcbiAgICAgICAgICAgIGFsbERpc3Bvc2VDYWxsYmFja3MgPSBbXTtcbiAgICAgICAgICAgIGtvLnV0aWxzLmRvbURhdGEuc2V0KG5vZGUsIGRvbURhdGFLZXksIGFsbERpc3Bvc2VDYWxsYmFja3MpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhbGxEaXNwb3NlQ2FsbGJhY2tzO1xuICAgIH1cbiAgICBmdW5jdGlvbiBkZXN0cm95Q2FsbGJhY2tzQ29sbGVjdGlvbihub2RlKSB7XG4gICAgICAgIGtvLnV0aWxzLmRvbURhdGEuc2V0KG5vZGUsIGRvbURhdGFLZXksIHVuZGVmaW5lZCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2xlYW5TaW5nbGVOb2RlKG5vZGUpIHtcbiAgICAgICAgLy8gUnVuIGFsbCB0aGUgZGlzcG9zZSBjYWxsYmFja3NcbiAgICAgICAgdmFyIGNhbGxiYWNrcyA9IGdldERpc3Bvc2VDYWxsYmFja3NDb2xsZWN0aW9uKG5vZGUsIGZhbHNlKTtcbiAgICAgICAgaWYgKGNhbGxiYWNrcykge1xuICAgICAgICAgICAgY2FsbGJhY2tzID0gY2FsbGJhY2tzLnNsaWNlKDApOyAvLyBDbG9uZSwgYXMgdGhlIGFycmF5IG1heSBiZSBtb2RpZmllZCBkdXJpbmcgaXRlcmF0aW9uICh0eXBpY2FsbHksIGNhbGxiYWNrcyB3aWxsIHJlbW92ZSB0aGVtc2VsdmVzKVxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjYWxsYmFja3MubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICAgICAgY2FsbGJhY2tzW2ldKG5vZGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRXJhc2UgdGhlIERPTSBkYXRhXG4gICAgICAgIGtvLnV0aWxzLmRvbURhdGEuY2xlYXIobm9kZSk7XG5cbiAgICAgICAgLy8gUGVyZm9ybSBjbGVhbnVwIG5lZWRlZCBieSBleHRlcm5hbCBsaWJyYXJpZXMgKGN1cnJlbnRseSBvbmx5IGpRdWVyeSwgYnV0IGNhbiBiZSBleHRlbmRlZClcbiAgICAgICAga28udXRpbHMuZG9tTm9kZURpc3Bvc2FsW1wiY2xlYW5FeHRlcm5hbERhdGFcIl0obm9kZSk7XG5cbiAgICAgICAgLy8gQ2xlYXIgYW55IGltbWVkaWF0ZS1jaGlsZCBjb21tZW50IG5vZGVzLCBhcyB0aGVzZSB3b3VsZG4ndCBoYXZlIGJlZW4gZm91bmQgYnlcbiAgICAgICAgLy8gbm9kZS5nZXRFbGVtZW50c0J5VGFnTmFtZShcIipcIikgaW4gY2xlYW5Ob2RlKCkgKGNvbW1lbnQgbm9kZXMgYXJlbid0IGVsZW1lbnRzKVxuICAgICAgICBpZiAoY2xlYW5hYmxlTm9kZVR5cGVzV2l0aERlc2NlbmRhbnRzW25vZGUubm9kZVR5cGVdKVxuICAgICAgICAgICAgY2xlYW5JbW1lZGlhdGVDb21tZW50VHlwZUNoaWxkcmVuKG5vZGUpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNsZWFuSW1tZWRpYXRlQ29tbWVudFR5cGVDaGlsZHJlbihub2RlV2l0aENoaWxkcmVuKSB7XG4gICAgICAgIHZhciBjaGlsZCwgbmV4dENoaWxkID0gbm9kZVdpdGhDaGlsZHJlbi5maXJzdENoaWxkO1xuICAgICAgICB3aGlsZSAoY2hpbGQgPSBuZXh0Q2hpbGQpIHtcbiAgICAgICAgICAgIG5leHRDaGlsZCA9IGNoaWxkLm5leHRTaWJsaW5nO1xuICAgICAgICAgICAgaWYgKGNoaWxkLm5vZGVUeXBlID09PSA4KVxuICAgICAgICAgICAgICAgIGNsZWFuU2luZ2xlTm9kZShjaGlsZCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgICBhZGREaXNwb3NlQ2FsbGJhY2sgOiBmdW5jdGlvbihub2RlLCBjYWxsYmFjaykge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayAhPSBcImZ1bmN0aW9uXCIpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2FsbGJhY2sgbXVzdCBiZSBhIGZ1bmN0aW9uXCIpO1xuICAgICAgICAgICAgZ2V0RGlzcG9zZUNhbGxiYWNrc0NvbGxlY3Rpb24obm9kZSwgdHJ1ZSkucHVzaChjYWxsYmFjayk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgcmVtb3ZlRGlzcG9zZUNhbGxiYWNrIDogZnVuY3Rpb24obm9kZSwgY2FsbGJhY2spIHtcbiAgICAgICAgICAgIHZhciBjYWxsYmFja3NDb2xsZWN0aW9uID0gZ2V0RGlzcG9zZUNhbGxiYWNrc0NvbGxlY3Rpb24obm9kZSwgZmFsc2UpO1xuICAgICAgICAgICAgaWYgKGNhbGxiYWNrc0NvbGxlY3Rpb24pIHtcbiAgICAgICAgICAgICAgICBrby51dGlscy5hcnJheVJlbW92ZUl0ZW0oY2FsbGJhY2tzQ29sbGVjdGlvbiwgY2FsbGJhY2spO1xuICAgICAgICAgICAgICAgIGlmIChjYWxsYmFja3NDb2xsZWN0aW9uLmxlbmd0aCA9PSAwKVxuICAgICAgICAgICAgICAgICAgICBkZXN0cm95Q2FsbGJhY2tzQ29sbGVjdGlvbihub2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBjbGVhbk5vZGUgOiBmdW5jdGlvbihub2RlKSB7XG4gICAgICAgICAgICAvLyBGaXJzdCBjbGVhbiB0aGlzIG5vZGUsIHdoZXJlIGFwcGxpY2FibGVcbiAgICAgICAgICAgIGlmIChjbGVhbmFibGVOb2RlVHlwZXNbbm9kZS5ub2RlVHlwZV0pIHtcbiAgICAgICAgICAgICAgICBjbGVhblNpbmdsZU5vZGUobm9kZSk7XG5cbiAgICAgICAgICAgICAgICAvLyAuLi4gdGhlbiBpdHMgZGVzY2VuZGFudHMsIHdoZXJlIGFwcGxpY2FibGVcbiAgICAgICAgICAgICAgICBpZiAoY2xlYW5hYmxlTm9kZVR5cGVzV2l0aERlc2NlbmRhbnRzW25vZGUubm9kZVR5cGVdKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIENsb25lIHRoZSBkZXNjZW5kYW50cyBsaXN0IGluIGNhc2UgaXQgY2hhbmdlcyBkdXJpbmcgaXRlcmF0aW9uXG4gICAgICAgICAgICAgICAgICAgIHZhciBkZXNjZW5kYW50cyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICBrby51dGlscy5hcnJheVB1c2hBbGwoZGVzY2VuZGFudHMsIG5vZGUuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCIqXCIpKTtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGogPSBkZXNjZW5kYW50cy5sZW5ndGg7IGkgPCBqOyBpKyspXG4gICAgICAgICAgICAgICAgICAgICAgICBjbGVhblNpbmdsZU5vZGUoZGVzY2VuZGFudHNbaV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBub2RlO1xuICAgICAgICB9LFxuXG4gICAgICAgIHJlbW92ZU5vZGUgOiBmdW5jdGlvbihub2RlKSB7XG4gICAgICAgICAgICBrby5jbGVhbk5vZGUobm9kZSk7XG4gICAgICAgICAgICBpZiAobm9kZS5wYXJlbnROb2RlKVxuICAgICAgICAgICAgICAgIG5vZGUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChub2RlKTtcbiAgICAgICAgfSxcblxuICAgICAgICBcImNsZWFuRXh0ZXJuYWxEYXRhXCIgOiBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgICAgLy8gU3BlY2lhbCBzdXBwb3J0IGZvciBqUXVlcnkgaGVyZSBiZWNhdXNlIGl0J3Mgc28gY29tbW9ubHkgdXNlZC5cbiAgICAgICAgICAgIC8vIE1hbnkgalF1ZXJ5IHBsdWdpbnMgKGluY2x1ZGluZyBqcXVlcnkudG1wbCkgc3RvcmUgZGF0YSB1c2luZyBqUXVlcnkncyBlcXVpdmFsZW50IG9mIGRvbURhdGFcbiAgICAgICAgICAgIC8vIHNvIG5vdGlmeSBpdCB0byB0ZWFyIGRvd24gYW55IHJlc291cmNlcyBhc3NvY2lhdGVkIHdpdGggdGhlIG5vZGUgJiBkZXNjZW5kYW50cyBoZXJlLlxuICAgICAgICAgICAgaWYgKGpRdWVyeUluc3RhbmNlICYmICh0eXBlb2YgalF1ZXJ5SW5zdGFuY2VbJ2NsZWFuRGF0YSddID09IFwiZnVuY3Rpb25cIikpXG4gICAgICAgICAgICAgICAgalF1ZXJ5SW5zdGFuY2VbJ2NsZWFuRGF0YSddKFtub2RlXSk7XG4gICAgICAgIH1cbiAgICB9O1xufSkoKTtcbmtvLmNsZWFuTm9kZSA9IGtvLnV0aWxzLmRvbU5vZGVEaXNwb3NhbC5jbGVhbk5vZGU7IC8vIFNob3J0aGFuZCBuYW1lIGZvciBjb252ZW5pZW5jZVxua28ucmVtb3ZlTm9kZSA9IGtvLnV0aWxzLmRvbU5vZGVEaXNwb3NhbC5yZW1vdmVOb2RlOyAvLyBTaG9ydGhhbmQgbmFtZSBmb3IgY29udmVuaWVuY2VcbmtvLmV4cG9ydFN5bWJvbCgnY2xlYW5Ob2RlJywga28uY2xlYW5Ob2RlKTtcbmtvLmV4cG9ydFN5bWJvbCgncmVtb3ZlTm9kZScsIGtvLnJlbW92ZU5vZGUpO1xua28uZXhwb3J0U3ltYm9sKCd1dGlscy5kb21Ob2RlRGlzcG9zYWwnLCBrby51dGlscy5kb21Ob2RlRGlzcG9zYWwpO1xua28uZXhwb3J0U3ltYm9sKCd1dGlscy5kb21Ob2RlRGlzcG9zYWwuYWRkRGlzcG9zZUNhbGxiYWNrJywga28udXRpbHMuZG9tTm9kZURpc3Bvc2FsLmFkZERpc3Bvc2VDYWxsYmFjayk7XG5rby5leHBvcnRTeW1ib2woJ3V0aWxzLmRvbU5vZGVEaXNwb3NhbC5yZW1vdmVEaXNwb3NlQ2FsbGJhY2snLCBrby51dGlscy5kb21Ob2RlRGlzcG9zYWwucmVtb3ZlRGlzcG9zZUNhbGxiYWNrKTtcbihmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG5vbmUgPSBbMCwgXCJcIiwgXCJcIl0sXG4gICAgICAgIHRhYmxlID0gWzEsIFwiPHRhYmxlPlwiLCBcIjwvdGFibGU+XCJdLFxuICAgICAgICB0Ym9keSA9IFsyLCBcIjx0YWJsZT48dGJvZHk+XCIsIFwiPC90Ym9keT48L3RhYmxlPlwiXSxcbiAgICAgICAgdHIgPSBbMywgXCI8dGFibGU+PHRib2R5Pjx0cj5cIiwgXCI8L3RyPjwvdGJvZHk+PC90YWJsZT5cIl0sXG4gICAgICAgIHNlbGVjdCA9IFsxLCBcIjxzZWxlY3QgbXVsdGlwbGU9J211bHRpcGxlJz5cIiwgXCI8L3NlbGVjdD5cIl0sXG4gICAgICAgIGxvb2t1cCA9IHtcbiAgICAgICAgICAgICd0aGVhZCc6IHRhYmxlLFxuICAgICAgICAgICAgJ3Rib2R5JzogdGFibGUsXG4gICAgICAgICAgICAndGZvb3QnOiB0YWJsZSxcbiAgICAgICAgICAgICd0cic6IHRib2R5LFxuICAgICAgICAgICAgJ3RkJzogdHIsXG4gICAgICAgICAgICAndGgnOiB0cixcbiAgICAgICAgICAgICdvcHRpb24nOiBzZWxlY3QsXG4gICAgICAgICAgICAnb3B0Z3JvdXAnOiBzZWxlY3RcbiAgICAgICAgfSxcblxuICAgICAgICAvLyBUaGlzIGlzIG5lZWRlZCBmb3Igb2xkIElFIGlmIHlvdSdyZSAqbm90KiB1c2luZyBlaXRoZXIgalF1ZXJ5IG9yIGlubmVyU2hpdi4gRG9lc24ndCBhZmZlY3Qgb3RoZXIgY2FzZXMuXG4gICAgICAgIG1heVJlcXVpcmVDcmVhdGVFbGVtZW50SGFjayA9IGtvLnV0aWxzLmllVmVyc2lvbiA8PSA4O1xuXG4gICAgZnVuY3Rpb24gZ2V0V3JhcCh0YWdzKSB7XG4gICAgICAgIHZhciBtID0gdGFncy5tYXRjaCgvXjwoW2Etel0rKVsgPl0vKTtcbiAgICAgICAgcmV0dXJuIChtICYmIGxvb2t1cFttWzFdXSkgfHwgbm9uZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzaW1wbGVIdG1sUGFyc2UoaHRtbCwgZG9jdW1lbnRDb250ZXh0KSB7XG4gICAgICAgIGRvY3VtZW50Q29udGV4dCB8fCAoZG9jdW1lbnRDb250ZXh0ID0gZG9jdW1lbnQpO1xuICAgICAgICB2YXIgd2luZG93Q29udGV4dCA9IGRvY3VtZW50Q29udGV4dFsncGFyZW50V2luZG93J10gfHwgZG9jdW1lbnRDb250ZXh0WydkZWZhdWx0VmlldyddIHx8IHdpbmRvdztcblxuICAgICAgICAvLyBCYXNlZCBvbiBqUXVlcnkncyBcImNsZWFuXCIgZnVuY3Rpb24sIGJ1dCBvbmx5IGFjY291bnRpbmcgZm9yIHRhYmxlLXJlbGF0ZWQgZWxlbWVudHMuXG4gICAgICAgIC8vIElmIHlvdSBoYXZlIHJlZmVyZW5jZWQgalF1ZXJ5LCB0aGlzIHdvbid0IGJlIHVzZWQgYW55d2F5IC0gS08gd2lsbCB1c2UgalF1ZXJ5J3MgXCJjbGVhblwiIGZ1bmN0aW9uIGRpcmVjdGx5XG5cbiAgICAgICAgLy8gTm90ZSB0aGF0IHRoZXJlJ3Mgc3RpbGwgYW4gaXNzdWUgaW4gSUUgPCA5IHdoZXJlYnkgaXQgd2lsbCBkaXNjYXJkIGNvbW1lbnQgbm9kZXMgdGhhdCBhcmUgdGhlIGZpcnN0IGNoaWxkIG9mXG4gICAgICAgIC8vIGEgZGVzY2VuZGFudCBub2RlLiBGb3IgZXhhbXBsZTogXCI8ZGl2PjwhLS0gbXljb21tZW50IC0tPmFiYzwvZGl2PlwiIHdpbGwgZ2V0IHBhcnNlZCBhcyBcIjxkaXY+YWJjPC9kaXY+XCJcbiAgICAgICAgLy8gVGhpcyB3b24ndCBhZmZlY3QgYW55b25lIHdobyBoYXMgcmVmZXJlbmNlZCBqUXVlcnksIGFuZCB0aGVyZSdzIGFsd2F5cyB0aGUgd29ya2Fyb3VuZCBvZiBpbnNlcnRpbmcgYSBkdW1teSBub2RlXG4gICAgICAgIC8vIChwb3NzaWJseSBhIHRleHQgbm9kZSkgaW4gZnJvbnQgb2YgdGhlIGNvbW1lbnQuIFNvLCBLTyBkb2VzIG5vdCBhdHRlbXB0IHRvIHdvcmthcm91bmQgdGhpcyBJRSBpc3N1ZSBhdXRvbWF0aWNhbGx5IGF0IHByZXNlbnQuXG5cbiAgICAgICAgLy8gVHJpbSB3aGl0ZXNwYWNlLCBvdGhlcndpc2UgaW5kZXhPZiB3b24ndCB3b3JrIGFzIGV4cGVjdGVkXG4gICAgICAgIHZhciB0YWdzID0ga28udXRpbHMuc3RyaW5nVHJpbShodG1sKS50b0xvd2VyQ2FzZSgpLCBkaXYgPSBkb2N1bWVudENvbnRleHQuY3JlYXRlRWxlbWVudChcImRpdlwiKSxcbiAgICAgICAgICAgIHdyYXAgPSBnZXRXcmFwKHRhZ3MpLFxuICAgICAgICAgICAgZGVwdGggPSB3cmFwWzBdO1xuXG4gICAgICAgIC8vIEdvIHRvIGh0bWwgYW5kIGJhY2ssIHRoZW4gcGVlbCBvZmYgZXh0cmEgd3JhcHBlcnNcbiAgICAgICAgLy8gTm90ZSB0aGF0IHdlIGFsd2F5cyBwcmVmaXggd2l0aCBzb21lIGR1bW15IHRleHQsIGJlY2F1c2Ugb3RoZXJ3aXNlLCBJRTw5IHdpbGwgc3RyaXAgb3V0IGxlYWRpbmcgY29tbWVudCBub2RlcyBpbiBkZXNjZW5kYW50cy4gVG90YWwgbWFkbmVzcy5cbiAgICAgICAgdmFyIG1hcmt1cCA9IFwiaWdub3JlZDxkaXY+XCIgKyB3cmFwWzFdICsgaHRtbCArIHdyYXBbMl0gKyBcIjwvZGl2PlwiO1xuICAgICAgICBpZiAodHlwZW9mIHdpbmRvd0NvbnRleHRbJ2lubmVyU2hpdiddID09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgLy8gTm90ZSB0aGF0IGlubmVyU2hpdiBpcyBkZXByZWNhdGVkIGluIGZhdm91ciBvZiBodG1sNXNoaXYuIFdlIHNob3VsZCBjb25zaWRlciBhZGRpbmdcbiAgICAgICAgICAgIC8vIHN1cHBvcnQgZm9yIGh0bWw1c2hpdiAoZXhjZXB0IGlmIG5vIGV4cGxpY2l0IHN1cHBvcnQgaXMgbmVlZGVkLCBlLmcuLCBpZiBodG1sNXNoaXZcbiAgICAgICAgICAgIC8vIHNvbWVob3cgc2hpbXMgdGhlIG5hdGl2ZSBBUElzIHNvIGl0IGp1c3Qgd29ya3MgYW55d2F5KVxuICAgICAgICAgICAgZGl2LmFwcGVuZENoaWxkKHdpbmRvd0NvbnRleHRbJ2lubmVyU2hpdiddKG1hcmt1cCkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKG1heVJlcXVpcmVDcmVhdGVFbGVtZW50SGFjaykge1xuICAgICAgICAgICAgICAgIC8vIFRoZSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdteS1lbGVtZW50JykgdHJpY2sgdG8gZW5hYmxlIGN1c3RvbSBlbGVtZW50cyBpbiBJRTYtOFxuICAgICAgICAgICAgICAgIC8vIG9ubHkgd29ya3MgaWYgd2UgYXNzaWduIGlubmVySFRNTCBvbiBhbiBlbGVtZW50IGFzc29jaWF0ZWQgd2l0aCB0aGF0IGRvY3VtZW50LlxuICAgICAgICAgICAgICAgIGRvY3VtZW50Q29udGV4dC5hcHBlbmRDaGlsZChkaXYpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBkaXYuaW5uZXJIVE1MID0gbWFya3VwO1xuXG4gICAgICAgICAgICBpZiAobWF5UmVxdWlyZUNyZWF0ZUVsZW1lbnRIYWNrKSB7XG4gICAgICAgICAgICAgICAgZGl2LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZGl2KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIE1vdmUgdG8gdGhlIHJpZ2h0IGRlcHRoXG4gICAgICAgIHdoaWxlIChkZXB0aC0tKVxuICAgICAgICAgICAgZGl2ID0gZGl2Lmxhc3RDaGlsZDtcblxuICAgICAgICByZXR1cm4ga28udXRpbHMubWFrZUFycmF5KGRpdi5sYXN0Q2hpbGQuY2hpbGROb2Rlcyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24galF1ZXJ5SHRtbFBhcnNlKGh0bWwsIGRvY3VtZW50Q29udGV4dCkge1xuICAgICAgICAvLyBqUXVlcnkncyBcInBhcnNlSFRNTFwiIGZ1bmN0aW9uIHdhcyBpbnRyb2R1Y2VkIGluIGpRdWVyeSAxLjguMCBhbmQgaXMgYSBkb2N1bWVudGVkIHB1YmxpYyBBUEkuXG4gICAgICAgIGlmIChqUXVlcnlJbnN0YW5jZVsncGFyc2VIVE1MJ10pIHtcbiAgICAgICAgICAgIHJldHVybiBqUXVlcnlJbnN0YW5jZVsncGFyc2VIVE1MJ10oaHRtbCwgZG9jdW1lbnRDb250ZXh0KSB8fCBbXTsgLy8gRW5zdXJlIHdlIGFsd2F5cyByZXR1cm4gYW4gYXJyYXkgYW5kIG5ldmVyIG51bGxcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIEZvciBqUXVlcnkgPCAxLjguMCwgd2UgZmFsbCBiYWNrIG9uIHRoZSB1bmRvY3VtZW50ZWQgaW50ZXJuYWwgXCJjbGVhblwiIGZ1bmN0aW9uLlxuICAgICAgICAgICAgdmFyIGVsZW1zID0galF1ZXJ5SW5zdGFuY2VbJ2NsZWFuJ10oW2h0bWxdLCBkb2N1bWVudENvbnRleHQpO1xuXG4gICAgICAgICAgICAvLyBBcyBvZiBqUXVlcnkgMS43LjEsIGpRdWVyeSBwYXJzZXMgdGhlIEhUTUwgYnkgYXBwZW5kaW5nIGl0IHRvIHNvbWUgZHVtbXkgcGFyZW50IG5vZGVzIGhlbGQgaW4gYW4gaW4tbWVtb3J5IGRvY3VtZW50IGZyYWdtZW50LlxuICAgICAgICAgICAgLy8gVW5mb3J0dW5hdGVseSwgaXQgbmV2ZXIgY2xlYXJzIHRoZSBkdW1teSBwYXJlbnQgbm9kZXMgZnJvbSB0aGUgZG9jdW1lbnQgZnJhZ21lbnQsIHNvIGl0IGxlYWtzIG1lbW9yeSBvdmVyIHRpbWUuXG4gICAgICAgICAgICAvLyBGaXggdGhpcyBieSBmaW5kaW5nIHRoZSB0b3AtbW9zdCBkdW1teSBwYXJlbnQgZWxlbWVudCwgYW5kIGRldGFjaGluZyBpdCBmcm9tIGl0cyBvd25lciBmcmFnbWVudC5cbiAgICAgICAgICAgIGlmIChlbGVtcyAmJiBlbGVtc1swXSkge1xuICAgICAgICAgICAgICAgIC8vIEZpbmQgdGhlIHRvcC1tb3N0IHBhcmVudCBlbGVtZW50IHRoYXQncyBhIGRpcmVjdCBjaGlsZCBvZiBhIGRvY3VtZW50IGZyYWdtZW50XG4gICAgICAgICAgICAgICAgdmFyIGVsZW0gPSBlbGVtc1swXTtcbiAgICAgICAgICAgICAgICB3aGlsZSAoZWxlbS5wYXJlbnROb2RlICYmIGVsZW0ucGFyZW50Tm9kZS5ub2RlVHlwZSAhPT0gMTEgLyogaS5lLiwgRG9jdW1lbnRGcmFnbWVudCAqLylcbiAgICAgICAgICAgICAgICAgICAgZWxlbSA9IGVsZW0ucGFyZW50Tm9kZTtcbiAgICAgICAgICAgICAgICAvLyAuLi4gdGhlbiBkZXRhY2ggaXRcbiAgICAgICAgICAgICAgICBpZiAoZWxlbS5wYXJlbnROb2RlKVxuICAgICAgICAgICAgICAgICAgICBlbGVtLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZWxlbSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBlbGVtcztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGtvLnV0aWxzLnBhcnNlSHRtbEZyYWdtZW50ID0gZnVuY3Rpb24oaHRtbCwgZG9jdW1lbnRDb250ZXh0KSB7XG4gICAgICAgIHJldHVybiBqUXVlcnlJbnN0YW5jZSA/XG4gICAgICAgICAgICBqUXVlcnlIdG1sUGFyc2UoaHRtbCwgZG9jdW1lbnRDb250ZXh0KSA6ICAgLy8gQXMgYmVsb3csIGJlbmVmaXQgZnJvbSBqUXVlcnkncyBvcHRpbWlzYXRpb25zIHdoZXJlIHBvc3NpYmxlXG4gICAgICAgICAgICBzaW1wbGVIdG1sUGFyc2UoaHRtbCwgZG9jdW1lbnRDb250ZXh0KTsgIC8vIC4uLiBvdGhlcndpc2UsIHRoaXMgc2ltcGxlIGxvZ2ljIHdpbGwgZG8gaW4gbW9zdCBjb21tb24gY2FzZXMuXG4gICAgfTtcblxuICAgIGtvLnV0aWxzLnNldEh0bWwgPSBmdW5jdGlvbihub2RlLCBodG1sKSB7XG4gICAgICAgIGtvLnV0aWxzLmVtcHR5RG9tTm9kZShub2RlKTtcblxuICAgICAgICAvLyBUaGVyZSdzIG5vIGxlZ2l0aW1hdGUgcmVhc29uIHRvIGRpc3BsYXkgYSBzdHJpbmdpZmllZCBvYnNlcnZhYmxlIHdpdGhvdXQgdW53cmFwcGluZyBpdCwgc28gd2UnbGwgdW53cmFwIGl0XG4gICAgICAgIGh0bWwgPSBrby51dGlscy51bndyYXBPYnNlcnZhYmxlKGh0bWwpO1xuXG4gICAgICAgIGlmICgoaHRtbCAhPT0gbnVsbCkgJiYgKGh0bWwgIT09IHVuZGVmaW5lZCkpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgaHRtbCAhPSAnc3RyaW5nJylcbiAgICAgICAgICAgICAgICBodG1sID0gaHRtbC50b1N0cmluZygpO1xuXG4gICAgICAgICAgICAvLyBqUXVlcnkgY29udGFpbnMgYSBsb3Qgb2Ygc29waGlzdGljYXRlZCBjb2RlIHRvIHBhcnNlIGFyYml0cmFyeSBIVE1MIGZyYWdtZW50cyxcbiAgICAgICAgICAgIC8vIGZvciBleGFtcGxlIDx0cj4gZWxlbWVudHMgd2hpY2ggYXJlIG5vdCBub3JtYWxseSBhbGxvd2VkIHRvIGV4aXN0IG9uIHRoZWlyIG93bi5cbiAgICAgICAgICAgIC8vIElmIHlvdSd2ZSByZWZlcmVuY2VkIGpRdWVyeSB3ZSdsbCB1c2UgdGhhdCByYXRoZXIgdGhhbiBkdXBsaWNhdGluZyBpdHMgY29kZS5cbiAgICAgICAgICAgIGlmIChqUXVlcnlJbnN0YW5jZSkge1xuICAgICAgICAgICAgICAgIGpRdWVyeUluc3RhbmNlKG5vZGUpWydodG1sJ10oaHRtbCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIC4uLiBvdGhlcndpc2UsIHVzZSBLTydzIG93biBwYXJzaW5nIGxvZ2ljLlxuICAgICAgICAgICAgICAgIHZhciBwYXJzZWROb2RlcyA9IGtvLnV0aWxzLnBhcnNlSHRtbEZyYWdtZW50KGh0bWwsIG5vZGUub3duZXJEb2N1bWVudCk7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXJzZWROb2Rlcy5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5hcHBlbmRDaGlsZChwYXJzZWROb2Rlc1tpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xufSkoKTtcblxua28uZXhwb3J0U3ltYm9sKCd1dGlscy5wYXJzZUh0bWxGcmFnbWVudCcsIGtvLnV0aWxzLnBhcnNlSHRtbEZyYWdtZW50KTtcbmtvLmV4cG9ydFN5bWJvbCgndXRpbHMuc2V0SHRtbCcsIGtvLnV0aWxzLnNldEh0bWwpO1xuXG5rby5tZW1vaXphdGlvbiA9IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG1lbW9zID0ge307XG5cbiAgICBmdW5jdGlvbiByYW5kb21NYXg4SGV4Q2hhcnMoKSB7XG4gICAgICAgIHJldHVybiAoKCgxICsgTWF0aC5yYW5kb20oKSkgKiAweDEwMDAwMDAwMCkgfCAwKS50b1N0cmluZygxNikuc3Vic3RyaW5nKDEpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBnZW5lcmF0ZVJhbmRvbUlkKCkge1xuICAgICAgICByZXR1cm4gcmFuZG9tTWF4OEhleENoYXJzKCkgKyByYW5kb21NYXg4SGV4Q2hhcnMoKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZmluZE1lbW9Ob2Rlcyhyb290Tm9kZSwgYXBwZW5kVG9BcnJheSkge1xuICAgICAgICBpZiAoIXJvb3ROb2RlKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBpZiAocm9vdE5vZGUubm9kZVR5cGUgPT0gOCkge1xuICAgICAgICAgICAgdmFyIG1lbW9JZCA9IGtvLm1lbW9pemF0aW9uLnBhcnNlTWVtb1RleHQocm9vdE5vZGUubm9kZVZhbHVlKTtcbiAgICAgICAgICAgIGlmIChtZW1vSWQgIT0gbnVsbClcbiAgICAgICAgICAgICAgICBhcHBlbmRUb0FycmF5LnB1c2goeyBkb21Ob2RlOiByb290Tm9kZSwgbWVtb0lkOiBtZW1vSWQgfSk7XG4gICAgICAgIH0gZWxzZSBpZiAocm9vdE5vZGUubm9kZVR5cGUgPT0gMSkge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGNoaWxkTm9kZXMgPSByb290Tm9kZS5jaGlsZE5vZGVzLCBqID0gY2hpbGROb2Rlcy5sZW5ndGg7IGkgPCBqOyBpKyspXG4gICAgICAgICAgICAgICAgZmluZE1lbW9Ob2RlcyhjaGlsZE5vZGVzW2ldLCBhcHBlbmRUb0FycmF5KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICAgIG1lbW9pemU6IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayAhPSBcImZ1bmN0aW9uXCIpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiWW91IGNhbiBvbmx5IHBhc3MgYSBmdW5jdGlvbiB0byBrby5tZW1vaXphdGlvbi5tZW1vaXplKClcIik7XG4gICAgICAgICAgICB2YXIgbWVtb0lkID0gZ2VuZXJhdGVSYW5kb21JZCgpO1xuICAgICAgICAgICAgbWVtb3NbbWVtb0lkXSA9IGNhbGxiYWNrO1xuICAgICAgICAgICAgcmV0dXJuIFwiPCEtLVtrb19tZW1vOlwiICsgbWVtb0lkICsgXCJdLS0+XCI7XG4gICAgICAgIH0sXG5cbiAgICAgICAgdW5tZW1vaXplOiBmdW5jdGlvbiAobWVtb0lkLCBjYWxsYmFja1BhcmFtcykge1xuICAgICAgICAgICAgdmFyIGNhbGxiYWNrID0gbWVtb3NbbWVtb0lkXTtcbiAgICAgICAgICAgIGlmIChjYWxsYmFjayA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvdWxkbid0IGZpbmQgYW55IG1lbW8gd2l0aCBJRCBcIiArIG1lbW9JZCArIFwiLiBQZXJoYXBzIGl0J3MgYWxyZWFkeSBiZWVuIHVubWVtb2l6ZWQuXCIpO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjay5hcHBseShudWxsLCBjYWxsYmFja1BhcmFtcyB8fCBbXSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmaW5hbGx5IHsgZGVsZXRlIG1lbW9zW21lbW9JZF07IH1cbiAgICAgICAgfSxcblxuICAgICAgICB1bm1lbW9pemVEb21Ob2RlQW5kRGVzY2VuZGFudHM6IGZ1bmN0aW9uIChkb21Ob2RlLCBleHRyYUNhbGxiYWNrUGFyYW1zQXJyYXkpIHtcbiAgICAgICAgICAgIHZhciBtZW1vcyA9IFtdO1xuICAgICAgICAgICAgZmluZE1lbW9Ob2Rlcyhkb21Ob2RlLCBtZW1vcyk7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgaiA9IG1lbW9zLmxlbmd0aDsgaSA8IGo7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBub2RlID0gbWVtb3NbaV0uZG9tTm9kZTtcbiAgICAgICAgICAgICAgICB2YXIgY29tYmluZWRQYXJhbXMgPSBbbm9kZV07XG4gICAgICAgICAgICAgICAgaWYgKGV4dHJhQ2FsbGJhY2tQYXJhbXNBcnJheSlcbiAgICAgICAgICAgICAgICAgICAga28udXRpbHMuYXJyYXlQdXNoQWxsKGNvbWJpbmVkUGFyYW1zLCBleHRyYUNhbGxiYWNrUGFyYW1zQXJyYXkpO1xuICAgICAgICAgICAgICAgIGtvLm1lbW9pemF0aW9uLnVubWVtb2l6ZShtZW1vc1tpXS5tZW1vSWQsIGNvbWJpbmVkUGFyYW1zKTtcbiAgICAgICAgICAgICAgICBub2RlLm5vZGVWYWx1ZSA9IFwiXCI7IC8vIE5ldXRlciB0aGlzIG5vZGUgc28gd2UgZG9uJ3QgdHJ5IHRvIHVubWVtb2l6ZSBpdCBhZ2FpblxuICAgICAgICAgICAgICAgIGlmIChub2RlLnBhcmVudE5vZGUpXG4gICAgICAgICAgICAgICAgICAgIG5vZGUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChub2RlKTsgLy8gSWYgcG9zc2libGUsIGVyYXNlIGl0IHRvdGFsbHkgKG5vdCBhbHdheXMgcG9zc2libGUgLSBzb21lb25lIGVsc2UgbWlnaHQganVzdCBob2xkIGEgcmVmZXJlbmNlIHRvIGl0IHRoZW4gY2FsbCB1bm1lbW9pemVEb21Ob2RlQW5kRGVzY2VuZGFudHMgYWdhaW4pXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgcGFyc2VNZW1vVGV4dDogZnVuY3Rpb24gKG1lbW9UZXh0KSB7XG4gICAgICAgICAgICB2YXIgbWF0Y2ggPSBtZW1vVGV4dC5tYXRjaCgvXlxcW2tvX21lbW9cXDooLio/KVxcXSQvKTtcbiAgICAgICAgICAgIHJldHVybiBtYXRjaCA/IG1hdGNoWzFdIDogbnVsbDtcbiAgICAgICAgfVxuICAgIH07XG59KSgpO1xuXG5rby5leHBvcnRTeW1ib2woJ21lbW9pemF0aW9uJywga28ubWVtb2l6YXRpb24pO1xua28uZXhwb3J0U3ltYm9sKCdtZW1vaXphdGlvbi5tZW1vaXplJywga28ubWVtb2l6YXRpb24ubWVtb2l6ZSk7XG5rby5leHBvcnRTeW1ib2woJ21lbW9pemF0aW9uLnVubWVtb2l6ZScsIGtvLm1lbW9pemF0aW9uLnVubWVtb2l6ZSk7XG5rby5leHBvcnRTeW1ib2woJ21lbW9pemF0aW9uLnBhcnNlTWVtb1RleHQnLCBrby5tZW1vaXphdGlvbi5wYXJzZU1lbW9UZXh0KTtcbmtvLmV4cG9ydFN5bWJvbCgnbWVtb2l6YXRpb24udW5tZW1vaXplRG9tTm9kZUFuZERlc2NlbmRhbnRzJywga28ubWVtb2l6YXRpb24udW5tZW1vaXplRG9tTm9kZUFuZERlc2NlbmRhbnRzKTtcbmtvLnRhc2tzID0gKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgc2NoZWR1bGVyLFxuICAgICAgICB0YXNrUXVldWUgPSBbXSxcbiAgICAgICAgdGFza1F1ZXVlTGVuZ3RoID0gMCxcbiAgICAgICAgbmV4dEhhbmRsZSA9IDEsXG4gICAgICAgIG5leHRJbmRleFRvUHJvY2VzcyA9IDA7XG5cbiAgICBpZiAod2luZG93WydNdXRhdGlvbk9ic2VydmVyJ10pIHtcbiAgICAgICAgLy8gQ2hyb21lIDI3KywgRmlyZWZveCAxNCssIElFIDExKywgT3BlcmEgMTUrLCBTYWZhcmkgNi4xK1xuICAgICAgICAvLyBGcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9wZXRrYWFudG9ub3YvYmx1ZWJpcmQgKiBDb3B5cmlnaHQgKGMpIDIwMTQgUGV0a2EgQW50b25vdiAqIExpY2Vuc2U6IE1JVFxuICAgICAgICBzY2hlZHVsZXIgPSAoZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICB2YXIgZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgICAgIG5ldyBNdXRhdGlvbk9ic2VydmVyKGNhbGxiYWNrKS5vYnNlcnZlKGRpdiwge2F0dHJpYnV0ZXM6IHRydWV9KTtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7IGRpdi5jbGFzc0xpc3QudG9nZ2xlKFwiZm9vXCIpOyB9O1xuICAgICAgICB9KShzY2hlZHVsZWRQcm9jZXNzKTtcbiAgICB9IGVsc2UgaWYgKGRvY3VtZW50ICYmIFwib25yZWFkeXN0YXRlY2hhbmdlXCIgaW4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNjcmlwdFwiKSkge1xuICAgICAgICAvLyBJRSA2LTEwXG4gICAgICAgIC8vIEZyb20gaHR0cHM6Ly9naXRodWIuY29tL1l1enVKUy9zZXRJbW1lZGlhdGUgKiBDb3B5cmlnaHQgKGMpIDIwMTIgQmFybmVzYW5kbm9ibGUuY29tLCBsbGMsIERvbmF2b24gV2VzdCwgYW5kIERvbWVuaWMgRGVuaWNvbGEgKiBMaWNlbnNlOiBNSVRcbiAgICAgICAgc2NoZWR1bGVyID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICB2YXIgc2NyaXB0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNjcmlwdFwiKTtcbiAgICAgICAgICAgIHNjcmlwdC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgc2NyaXB0Lm9ucmVhZHlzdGF0ZWNoYW5nZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnJlbW92ZUNoaWxkKHNjcmlwdCk7XG4gICAgICAgICAgICAgICAgc2NyaXB0ID0gbnVsbDtcbiAgICAgICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5hcHBlbmRDaGlsZChzY3JpcHQpO1xuICAgICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHNjaGVkdWxlciA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgICAgICAgICAgc2V0VGltZW91dChjYWxsYmFjaywgMCk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcHJvY2Vzc1Rhc2tzKCkge1xuICAgICAgICBpZiAodGFza1F1ZXVlTGVuZ3RoKSB7XG4gICAgICAgICAgICAvLyBFYWNoIG1hcmsgcmVwcmVzZW50cyB0aGUgZW5kIG9mIGEgbG9naWNhbCBncm91cCBvZiB0YXNrcyBhbmQgdGhlIG51bWJlciBvZiB0aGVzZSBncm91cHMgaXNcbiAgICAgICAgICAgIC8vIGxpbWl0ZWQgdG8gcHJldmVudCB1bmNoZWNrZWQgcmVjdXJzaW9uLlxuICAgICAgICAgICAgdmFyIG1hcmsgPSB0YXNrUXVldWVMZW5ndGgsIGNvdW50TWFya3MgPSAwO1xuXG4gICAgICAgICAgICAvLyBuZXh0SW5kZXhUb1Byb2Nlc3Mga2VlcHMgdHJhY2sgb2Ygd2hlcmUgd2UgYXJlIGluIHRoZSBxdWV1ZTsgcHJvY2Vzc1Rhc2tzIGNhbiBiZSBjYWxsZWQgcmVjdXJzaXZlbHkgd2l0aG91dCBpc3N1ZVxuICAgICAgICAgICAgZm9yICh2YXIgdGFzazsgbmV4dEluZGV4VG9Qcm9jZXNzIDwgdGFza1F1ZXVlTGVuZ3RoOyApIHtcbiAgICAgICAgICAgICAgICBpZiAodGFzayA9IHRhc2tRdWV1ZVtuZXh0SW5kZXhUb1Byb2Nlc3MrK10pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5leHRJbmRleFRvUHJvY2VzcyA+IG1hcmspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgrK2NvdW50TWFya3MgPj0gNTAwMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5leHRJbmRleFRvUHJvY2VzcyA9IHRhc2tRdWV1ZUxlbmd0aDsgICAvLyBza2lwIGFsbCB0YXNrcyByZW1haW5pbmcgaW4gdGhlIHF1ZXVlIHNpbmNlIGFueSBvZiB0aGVtIGNvdWxkIGJlIGNhdXNpbmcgdGhlIHJlY3Vyc2lvblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtvLnV0aWxzLmRlZmVyRXJyb3IoRXJyb3IoXCInVG9vIG11Y2ggcmVjdXJzaW9uJyBhZnRlciBwcm9jZXNzaW5nIFwiICsgY291bnRNYXJrcyArIFwiIHRhc2sgZ3JvdXBzLlwiKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXJrID0gdGFza1F1ZXVlTGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0YXNrKCk7XG4gICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBrby51dGlscy5kZWZlckVycm9yKGV4KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNjaGVkdWxlZFByb2Nlc3MoKSB7XG4gICAgICAgIHByb2Nlc3NUYXNrcygpO1xuXG4gICAgICAgIC8vIFJlc2V0IHRoZSBxdWV1ZVxuICAgICAgICBuZXh0SW5kZXhUb1Byb2Nlc3MgPSB0YXNrUXVldWVMZW5ndGggPSB0YXNrUXVldWUubGVuZ3RoID0gMDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzY2hlZHVsZVRhc2tQcm9jZXNzaW5nKCkge1xuICAgICAgICBrby50YXNrc1snc2NoZWR1bGVyJ10oc2NoZWR1bGVkUHJvY2Vzcyk7XG4gICAgfVxuXG4gICAgdmFyIHRhc2tzID0ge1xuICAgICAgICAnc2NoZWR1bGVyJzogc2NoZWR1bGVyLCAgICAgLy8gQWxsb3cgb3ZlcnJpZGluZyB0aGUgc2NoZWR1bGVyXG5cbiAgICAgICAgc2NoZWR1bGU6IGZ1bmN0aW9uIChmdW5jKSB7XG4gICAgICAgICAgICBpZiAoIXRhc2tRdWV1ZUxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHNjaGVkdWxlVGFza1Byb2Nlc3NpbmcoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGFza1F1ZXVlW3Rhc2tRdWV1ZUxlbmd0aCsrXSA9IGZ1bmM7XG4gICAgICAgICAgICByZXR1cm4gbmV4dEhhbmRsZSsrO1xuICAgICAgICB9LFxuXG4gICAgICAgIGNhbmNlbDogZnVuY3Rpb24gKGhhbmRsZSkge1xuICAgICAgICAgICAgdmFyIGluZGV4ID0gaGFuZGxlIC0gKG5leHRIYW5kbGUgLSB0YXNrUXVldWVMZW5ndGgpO1xuICAgICAgICAgICAgaWYgKGluZGV4ID49IG5leHRJbmRleFRvUHJvY2VzcyAmJiBpbmRleCA8IHRhc2tRdWV1ZUxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHRhc2tRdWV1ZVtpbmRleF0gPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8vIEZvciB0ZXN0aW5nIG9ubHk6IHJlc2V0IHRoZSBxdWV1ZSBhbmQgcmV0dXJuIHRoZSBwcmV2aW91cyBxdWV1ZSBsZW5ndGhcbiAgICAgICAgJ3Jlc2V0Rm9yVGVzdGluZyc6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBsZW5ndGggPSB0YXNrUXVldWVMZW5ndGggLSBuZXh0SW5kZXhUb1Byb2Nlc3M7XG4gICAgICAgICAgICBuZXh0SW5kZXhUb1Byb2Nlc3MgPSB0YXNrUXVldWVMZW5ndGggPSB0YXNrUXVldWUubGVuZ3RoID0gMDtcbiAgICAgICAgICAgIHJldHVybiBsZW5ndGg7XG4gICAgICAgIH0sXG5cbiAgICAgICAgcnVuRWFybHk6IHByb2Nlc3NUYXNrc1xuICAgIH07XG5cbiAgICByZXR1cm4gdGFza3M7XG59KSgpO1xuXG5rby5leHBvcnRTeW1ib2woJ3Rhc2tzJywga28udGFza3MpO1xua28uZXhwb3J0U3ltYm9sKCd0YXNrcy5zY2hlZHVsZScsIGtvLnRhc2tzLnNjaGVkdWxlKTtcbi8va28uZXhwb3J0U3ltYm9sKCd0YXNrcy5jYW5jZWwnLCBrby50YXNrcy5jYW5jZWwpOyAgXCJjYW5jZWxcIiBpc24ndCBtaW5pZmllZFxua28uZXhwb3J0U3ltYm9sKCd0YXNrcy5ydW5FYXJseScsIGtvLnRhc2tzLnJ1bkVhcmx5KTtcbmtvLmV4dGVuZGVycyA9IHtcbiAgICAndGhyb3R0bGUnOiBmdW5jdGlvbih0YXJnZXQsIHRpbWVvdXQpIHtcbiAgICAgICAgLy8gVGhyb3R0bGluZyBtZWFucyB0d28gdGhpbmdzOlxuXG4gICAgICAgIC8vICgxKSBGb3IgZGVwZW5kZW50IG9ic2VydmFibGVzLCB3ZSB0aHJvdHRsZSAqZXZhbHVhdGlvbnMqIHNvIHRoYXQsIG5vIG1hdHRlciBob3cgZmFzdCBpdHMgZGVwZW5kZW5jaWVzXG4gICAgICAgIC8vICAgICBub3RpZnkgdXBkYXRlcywgdGhlIHRhcmdldCBkb2Vzbid0IHJlLWV2YWx1YXRlIChhbmQgaGVuY2UgZG9lc24ndCBub3RpZnkpIGZhc3RlciB0aGFuIGEgY2VydGFpbiByYXRlXG4gICAgICAgIHRhcmdldFsndGhyb3R0bGVFdmFsdWF0aW9uJ10gPSB0aW1lb3V0O1xuXG4gICAgICAgIC8vICgyKSBGb3Igd3JpdGFibGUgdGFyZ2V0cyAob2JzZXJ2YWJsZXMsIG9yIHdyaXRhYmxlIGRlcGVuZGVudCBvYnNlcnZhYmxlcyksIHdlIHRocm90dGxlICp3cml0ZXMqXG4gICAgICAgIC8vICAgICBzbyB0aGUgdGFyZ2V0IGNhbm5vdCBjaGFuZ2UgdmFsdWUgc3luY2hyb25vdXNseSBvciBmYXN0ZXIgdGhhbiBhIGNlcnRhaW4gcmF0ZVxuICAgICAgICB2YXIgd3JpdGVUaW1lb3V0SW5zdGFuY2UgPSBudWxsO1xuICAgICAgICByZXR1cm4ga28uZGVwZW5kZW50T2JzZXJ2YWJsZSh7XG4gICAgICAgICAgICAncmVhZCc6IHRhcmdldCxcbiAgICAgICAgICAgICd3cml0ZSc6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHdyaXRlVGltZW91dEluc3RhbmNlKTtcbiAgICAgICAgICAgICAgICB3cml0ZVRpbWVvdXRJbnN0YW5jZSA9IGtvLnV0aWxzLnNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHRhcmdldCh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfSwgdGltZW91dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAncmF0ZUxpbWl0JzogZnVuY3Rpb24odGFyZ2V0LCBvcHRpb25zKSB7XG4gICAgICAgIHZhciB0aW1lb3V0LCBtZXRob2QsIGxpbWl0RnVuY3Rpb247XG5cbiAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zID09ICdudW1iZXInKSB7XG4gICAgICAgICAgICB0aW1lb3V0ID0gb3B0aW9ucztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRpbWVvdXQgPSBvcHRpb25zWyd0aW1lb3V0J107XG4gICAgICAgICAgICBtZXRob2QgPSBvcHRpb25zWydtZXRob2QnXTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHJhdGVMaW1pdCBzdXBlcnNlZGVzIGRlZmVycmVkIHVwZGF0ZXNcbiAgICAgICAgdGFyZ2V0Ll9kZWZlclVwZGF0ZXMgPSBmYWxzZTtcblxuICAgICAgICBsaW1pdEZ1bmN0aW9uID0gbWV0aG9kID09ICdub3RpZnlXaGVuQ2hhbmdlc1N0b3AnID8gIGRlYm91bmNlIDogdGhyb3R0bGU7XG4gICAgICAgIHRhcmdldC5saW1pdChmdW5jdGlvbihjYWxsYmFjaykge1xuICAgICAgICAgICAgcmV0dXJuIGxpbWl0RnVuY3Rpb24oY2FsbGJhY2ssIHRpbWVvdXQpO1xuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgJ2RlZmVycmVkJzogZnVuY3Rpb24odGFyZ2V0LCBvcHRpb25zKSB7XG4gICAgICAgIGlmIChvcHRpb25zICE9PSB0cnVlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBcXCdkZWZlcnJlZFxcJyBleHRlbmRlciBvbmx5IGFjY2VwdHMgdGhlIHZhbHVlIFxcJ3RydWVcXCcsIGJlY2F1c2UgaXQgaXMgbm90IHN1cHBvcnRlZCB0byB0dXJuIGRlZmVycmFsIG9mZiBvbmNlIGVuYWJsZWQuJylcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdGFyZ2V0Ll9kZWZlclVwZGF0ZXMpIHtcbiAgICAgICAgICAgIHRhcmdldC5fZGVmZXJVcGRhdGVzID0gdHJ1ZTtcbiAgICAgICAgICAgIHRhcmdldC5saW1pdChmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICB2YXIgaGFuZGxlO1xuICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIGtvLnRhc2tzLmNhbmNlbChoYW5kbGUpO1xuICAgICAgICAgICAgICAgICAgICBoYW5kbGUgPSBrby50YXNrcy5zY2hlZHVsZShjYWxsYmFjayk7XG4gICAgICAgICAgICAgICAgICAgIHRhcmdldFsnbm90aWZ5U3Vic2NyaWJlcnMnXSh1bmRlZmluZWQsICdkaXJ0eScpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAnbm90aWZ5JzogZnVuY3Rpb24odGFyZ2V0LCBub3RpZnlXaGVuKSB7XG4gICAgICAgIHRhcmdldFtcImVxdWFsaXR5Q29tcGFyZXJcIl0gPSBub3RpZnlXaGVuID09IFwiYWx3YXlzXCIgP1xuICAgICAgICAgICAgbnVsbCA6ICAvLyBudWxsIGVxdWFsaXR5Q29tcGFyZXIgbWVhbnMgdG8gYWx3YXlzIG5vdGlmeVxuICAgICAgICAgICAgdmFsdWVzQXJlUHJpbWl0aXZlQW5kRXF1YWw7XG4gICAgfVxufTtcblxudmFyIHByaW1pdGl2ZVR5cGVzID0geyAndW5kZWZpbmVkJzoxLCAnYm9vbGVhbic6MSwgJ251bWJlcic6MSwgJ3N0cmluZyc6MSB9O1xuZnVuY3Rpb24gdmFsdWVzQXJlUHJpbWl0aXZlQW5kRXF1YWwoYSwgYikge1xuICAgIHZhciBvbGRWYWx1ZUlzUHJpbWl0aXZlID0gKGEgPT09IG51bGwpIHx8ICh0eXBlb2YoYSkgaW4gcHJpbWl0aXZlVHlwZXMpO1xuICAgIHJldHVybiBvbGRWYWx1ZUlzUHJpbWl0aXZlID8gKGEgPT09IGIpIDogZmFsc2U7XG59XG5cbmZ1bmN0aW9uIHRocm90dGxlKGNhbGxiYWNrLCB0aW1lb3V0KSB7XG4gICAgdmFyIHRpbWVvdXRJbnN0YW5jZTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIXRpbWVvdXRJbnN0YW5jZSkge1xuICAgICAgICAgICAgdGltZW91dEluc3RhbmNlID0ga28udXRpbHMuc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdGltZW91dEluc3RhbmNlID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgICB9LCB0aW1lb3V0KTtcbiAgICAgICAgfVxuICAgIH07XG59XG5cbmZ1bmN0aW9uIGRlYm91bmNlKGNhbGxiYWNrLCB0aW1lb3V0KSB7XG4gICAgdmFyIHRpbWVvdXRJbnN0YW5jZTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dEluc3RhbmNlKTtcbiAgICAgICAgdGltZW91dEluc3RhbmNlID0ga28udXRpbHMuc2V0VGltZW91dChjYWxsYmFjaywgdGltZW91dCk7XG4gICAgfTtcbn1cblxuZnVuY3Rpb24gYXBwbHlFeHRlbmRlcnMocmVxdWVzdGVkRXh0ZW5kZXJzKSB7XG4gICAgdmFyIHRhcmdldCA9IHRoaXM7XG4gICAgaWYgKHJlcXVlc3RlZEV4dGVuZGVycykge1xuICAgICAgICBrby51dGlscy5vYmplY3RGb3JFYWNoKHJlcXVlc3RlZEV4dGVuZGVycywgZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1xuICAgICAgICAgICAgdmFyIGV4dGVuZGVySGFuZGxlciA9IGtvLmV4dGVuZGVyc1trZXldO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBleHRlbmRlckhhbmRsZXIgPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIHRhcmdldCA9IGV4dGVuZGVySGFuZGxlcih0YXJnZXQsIHZhbHVlKSB8fCB0YXJnZXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gdGFyZ2V0O1xufVxuXG5rby5leHBvcnRTeW1ib2woJ2V4dGVuZGVycycsIGtvLmV4dGVuZGVycyk7XG5cbmtvLnN1YnNjcmlwdGlvbiA9IGZ1bmN0aW9uICh0YXJnZXQsIGNhbGxiYWNrLCBkaXNwb3NlQ2FsbGJhY2spIHtcbiAgICB0aGlzLl90YXJnZXQgPSB0YXJnZXQ7XG4gICAgdGhpcy5jYWxsYmFjayA9IGNhbGxiYWNrO1xuICAgIHRoaXMuZGlzcG9zZUNhbGxiYWNrID0gZGlzcG9zZUNhbGxiYWNrO1xuICAgIHRoaXMuaXNEaXNwb3NlZCA9IGZhbHNlO1xuICAgIGtvLmV4cG9ydFByb3BlcnR5KHRoaXMsICdkaXNwb3NlJywgdGhpcy5kaXNwb3NlKTtcbn07XG5rby5zdWJzY3JpcHRpb24ucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5pc0Rpc3Bvc2VkID0gdHJ1ZTtcbiAgICB0aGlzLmRpc3Bvc2VDYWxsYmFjaygpO1xufTtcblxua28uc3Vic2NyaWJhYmxlID0gZnVuY3Rpb24gKCkge1xuICAgIGtvLnV0aWxzLnNldFByb3RvdHlwZU9mT3JFeHRlbmQodGhpcywga29fc3Vic2NyaWJhYmxlX2ZuKTtcbiAgICBrb19zdWJzY3JpYmFibGVfZm4uaW5pdCh0aGlzKTtcbn1cblxudmFyIGRlZmF1bHRFdmVudCA9IFwiY2hhbmdlXCI7XG5cbi8vIE1vdmVkIG91dCBvZiBcImxpbWl0XCIgdG8gYXZvaWQgdGhlIGV4dHJhIGNsb3N1cmVcbmZ1bmN0aW9uIGxpbWl0Tm90aWZ5U3Vic2NyaWJlcnModmFsdWUsIGV2ZW50KSB7XG4gICAgaWYgKCFldmVudCB8fCBldmVudCA9PT0gZGVmYXVsdEV2ZW50KSB7XG4gICAgICAgIHRoaXMuX2xpbWl0Q2hhbmdlKHZhbHVlKTtcbiAgICB9IGVsc2UgaWYgKGV2ZW50ID09PSAnYmVmb3JlQ2hhbmdlJykge1xuICAgICAgICB0aGlzLl9saW1pdEJlZm9yZUNoYW5nZSh2YWx1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fb3JpZ05vdGlmeVN1YnNjcmliZXJzKHZhbHVlLCBldmVudCk7XG4gICAgfVxufVxuXG52YXIga29fc3Vic2NyaWJhYmxlX2ZuID0ge1xuICAgIGluaXQ6IGZ1bmN0aW9uKGluc3RhbmNlKSB7XG4gICAgICAgIGluc3RhbmNlLl9zdWJzY3JpcHRpb25zID0ge307XG4gICAgICAgIGluc3RhbmNlLl92ZXJzaW9uTnVtYmVyID0gMTtcbiAgICB9LFxuXG4gICAgc3Vic2NyaWJlOiBmdW5jdGlvbiAoY2FsbGJhY2ssIGNhbGxiYWNrVGFyZ2V0LCBldmVudCkge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAgICAgZXZlbnQgPSBldmVudCB8fCBkZWZhdWx0RXZlbnQ7XG4gICAgICAgIHZhciBib3VuZENhbGxiYWNrID0gY2FsbGJhY2tUYXJnZXQgPyBjYWxsYmFjay5iaW5kKGNhbGxiYWNrVGFyZ2V0KSA6IGNhbGxiYWNrO1xuXG4gICAgICAgIHZhciBzdWJzY3JpcHRpb24gPSBuZXcga28uc3Vic2NyaXB0aW9uKHNlbGYsIGJvdW5kQ2FsbGJhY2ssIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGtvLnV0aWxzLmFycmF5UmVtb3ZlSXRlbShzZWxmLl9zdWJzY3JpcHRpb25zW2V2ZW50XSwgc3Vic2NyaXB0aW9uKTtcbiAgICAgICAgICAgIGlmIChzZWxmLmFmdGVyU3Vic2NyaXB0aW9uUmVtb3ZlKVxuICAgICAgICAgICAgICAgIHNlbGYuYWZ0ZXJTdWJzY3JpcHRpb25SZW1vdmUoZXZlbnQpO1xuICAgICAgICB9KTtcblxuICAgICAgICBpZiAoc2VsZi5iZWZvcmVTdWJzY3JpcHRpb25BZGQpXG4gICAgICAgICAgICBzZWxmLmJlZm9yZVN1YnNjcmlwdGlvbkFkZChldmVudCk7XG5cbiAgICAgICAgaWYgKCFzZWxmLl9zdWJzY3JpcHRpb25zW2V2ZW50XSlcbiAgICAgICAgICAgIHNlbGYuX3N1YnNjcmlwdGlvbnNbZXZlbnRdID0gW107XG4gICAgICAgIHNlbGYuX3N1YnNjcmlwdGlvbnNbZXZlbnRdLnB1c2goc3Vic2NyaXB0aW9uKTtcblxuICAgICAgICByZXR1cm4gc3Vic2NyaXB0aW9uO1xuICAgIH0sXG5cbiAgICBcIm5vdGlmeVN1YnNjcmliZXJzXCI6IGZ1bmN0aW9uICh2YWx1ZVRvTm90aWZ5LCBldmVudCkge1xuICAgICAgICBldmVudCA9IGV2ZW50IHx8IGRlZmF1bHRFdmVudDtcbiAgICAgICAgaWYgKGV2ZW50ID09PSBkZWZhdWx0RXZlbnQpIHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlVmVyc2lvbigpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmhhc1N1YnNjcmlwdGlvbnNGb3JFdmVudChldmVudCkpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAga28uZGVwZW5kZW5jeURldGVjdGlvbi5iZWdpbigpOyAvLyBCZWdpbiBzdXBwcmVzc2luZyBkZXBlbmRlbmN5IGRldGVjdGlvbiAoYnkgc2V0dGluZyB0aGUgdG9wIGZyYW1lIHRvIHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBhID0gdGhpcy5fc3Vic2NyaXB0aW9uc1tldmVudF0uc2xpY2UoMCksIGkgPSAwLCBzdWJzY3JpcHRpb247IHN1YnNjcmlwdGlvbiA9IGFbaV07ICsraSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBJbiBjYXNlIGEgc3Vic2NyaXB0aW9uIHdhcyBkaXNwb3NlZCBkdXJpbmcgdGhlIGFycmF5Rm9yRWFjaCBjeWNsZSwgY2hlY2tcbiAgICAgICAgICAgICAgICAgICAgLy8gZm9yIGlzRGlzcG9zZWQgb24gZWFjaCBzdWJzY3JpcHRpb24gYmVmb3JlIGludm9raW5nIGl0cyBjYWxsYmFja1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXN1YnNjcmlwdGlvbi5pc0Rpc3Bvc2VkKVxuICAgICAgICAgICAgICAgICAgICAgICAgc3Vic2NyaXB0aW9uLmNhbGxiYWNrKHZhbHVlVG9Ob3RpZnkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgICAga28uZGVwZW5kZW5jeURldGVjdGlvbi5lbmQoKTsgLy8gRW5kIHN1cHByZXNzaW5nIGRlcGVuZGVuY3kgZGV0ZWN0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgZ2V0VmVyc2lvbjogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdmVyc2lvbk51bWJlcjtcbiAgICB9LFxuXG4gICAgaGFzQ2hhbmdlZDogZnVuY3Rpb24gKHZlcnNpb25Ub0NoZWNrKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldFZlcnNpb24oKSAhPT0gdmVyc2lvblRvQ2hlY2s7XG4gICAgfSxcblxuICAgIHVwZGF0ZVZlcnNpb246IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgKyt0aGlzLl92ZXJzaW9uTnVtYmVyO1xuICAgIH0sXG5cbiAgICBsaW1pdDogZnVuY3Rpb24obGltaXRGdW5jdGlvbikge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXMsIHNlbGZJc09ic2VydmFibGUgPSBrby5pc09ic2VydmFibGUoc2VsZiksXG4gICAgICAgICAgICBpZ25vcmVCZWZvcmVDaGFuZ2UsIHByZXZpb3VzVmFsdWUsIHBlbmRpbmdWYWx1ZSwgYmVmb3JlQ2hhbmdlID0gJ2JlZm9yZUNoYW5nZSc7XG5cbiAgICAgICAgaWYgKCFzZWxmLl9vcmlnTm90aWZ5U3Vic2NyaWJlcnMpIHtcbiAgICAgICAgICAgIHNlbGYuX29yaWdOb3RpZnlTdWJzY3JpYmVycyA9IHNlbGZbXCJub3RpZnlTdWJzY3JpYmVyc1wiXTtcbiAgICAgICAgICAgIHNlbGZbXCJub3RpZnlTdWJzY3JpYmVyc1wiXSA9IGxpbWl0Tm90aWZ5U3Vic2NyaWJlcnM7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZmluaXNoID0gbGltaXRGdW5jdGlvbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHNlbGYuX25vdGlmaWNhdGlvbklzUGVuZGluZyA9IGZhbHNlO1xuXG4gICAgICAgICAgICAvLyBJZiBhbiBvYnNlcnZhYmxlIHByb3ZpZGVkIGEgcmVmZXJlbmNlIHRvIGl0c2VsZiwgYWNjZXNzIGl0IHRvIGdldCB0aGUgbGF0ZXN0IHZhbHVlLlxuICAgICAgICAgICAgLy8gVGhpcyBhbGxvd3MgY29tcHV0ZWQgb2JzZXJ2YWJsZXMgdG8gZGVsYXkgY2FsY3VsYXRpbmcgdGhlaXIgdmFsdWUgdW50aWwgbmVlZGVkLlxuICAgICAgICAgICAgaWYgKHNlbGZJc09ic2VydmFibGUgJiYgcGVuZGluZ1ZhbHVlID09PSBzZWxmKSB7XG4gICAgICAgICAgICAgICAgcGVuZGluZ1ZhbHVlID0gc2VsZigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWdub3JlQmVmb3JlQ2hhbmdlID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAoc2VsZi5pc0RpZmZlcmVudChwcmV2aW91c1ZhbHVlLCBwZW5kaW5nVmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5fb3JpZ05vdGlmeVN1YnNjcmliZXJzKHByZXZpb3VzVmFsdWUgPSBwZW5kaW5nVmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBzZWxmLl9saW1pdENoYW5nZSA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICBzZWxmLl9ub3RpZmljYXRpb25Jc1BlbmRpbmcgPSBpZ25vcmVCZWZvcmVDaGFuZ2UgPSB0cnVlO1xuICAgICAgICAgICAgcGVuZGluZ1ZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgICBmaW5pc2goKTtcbiAgICAgICAgfTtcbiAgICAgICAgc2VsZi5fbGltaXRCZWZvcmVDaGFuZ2UgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKCFpZ25vcmVCZWZvcmVDaGFuZ2UpIHtcbiAgICAgICAgICAgICAgICBwcmV2aW91c1ZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgc2VsZi5fb3JpZ05vdGlmeVN1YnNjcmliZXJzKHZhbHVlLCBiZWZvcmVDaGFuZ2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH0sXG5cbiAgICBoYXNTdWJzY3JpcHRpb25zRm9yRXZlbnQ6IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zdWJzY3JpcHRpb25zW2V2ZW50XSAmJiB0aGlzLl9zdWJzY3JpcHRpb25zW2V2ZW50XS5sZW5ndGg7XG4gICAgfSxcblxuICAgIGdldFN1YnNjcmlwdGlvbnNDb3VudDogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIGlmIChldmVudCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3N1YnNjcmlwdGlvbnNbZXZlbnRdICYmIHRoaXMuX3N1YnNjcmlwdGlvbnNbZXZlbnRdLmxlbmd0aCB8fCAwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIHRvdGFsID0gMDtcbiAgICAgICAgICAgIGtvLnV0aWxzLm9iamVjdEZvckVhY2godGhpcy5fc3Vic2NyaXB0aW9ucywgZnVuY3Rpb24oZXZlbnROYW1lLCBzdWJzY3JpcHRpb25zKSB7XG4gICAgICAgICAgICAgICAgaWYgKGV2ZW50TmFtZSAhPT0gJ2RpcnR5JylcbiAgICAgICAgICAgICAgICAgICAgdG90YWwgKz0gc3Vic2NyaXB0aW9ucy5sZW5ndGg7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiB0b3RhbDtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBpc0RpZmZlcmVudDogZnVuY3Rpb24ob2xkVmFsdWUsIG5ld1ZhbHVlKSB7XG4gICAgICAgIHJldHVybiAhdGhpc1snZXF1YWxpdHlDb21wYXJlciddIHx8ICF0aGlzWydlcXVhbGl0eUNvbXBhcmVyJ10ob2xkVmFsdWUsIG5ld1ZhbHVlKTtcbiAgICB9LFxuXG4gICAgZXh0ZW5kOiBhcHBseUV4dGVuZGVyc1xufTtcblxua28uZXhwb3J0UHJvcGVydHkoa29fc3Vic2NyaWJhYmxlX2ZuLCAnc3Vic2NyaWJlJywga29fc3Vic2NyaWJhYmxlX2ZuLnN1YnNjcmliZSk7XG5rby5leHBvcnRQcm9wZXJ0eShrb19zdWJzY3JpYmFibGVfZm4sICdleHRlbmQnLCBrb19zdWJzY3JpYmFibGVfZm4uZXh0ZW5kKTtcbmtvLmV4cG9ydFByb3BlcnR5KGtvX3N1YnNjcmliYWJsZV9mbiwgJ2dldFN1YnNjcmlwdGlvbnNDb3VudCcsIGtvX3N1YnNjcmliYWJsZV9mbi5nZXRTdWJzY3JpcHRpb25zQ291bnQpO1xuXG4vLyBGb3IgYnJvd3NlcnMgdGhhdCBzdXBwb3J0IHByb3RvIGFzc2lnbm1lbnQsIHdlIG92ZXJ3cml0ZSB0aGUgcHJvdG90eXBlIG9mIGVhY2hcbi8vIG9ic2VydmFibGUgaW5zdGFuY2UuIFNpbmNlIG9ic2VydmFibGVzIGFyZSBmdW5jdGlvbnMsIHdlIG5lZWQgRnVuY3Rpb24ucHJvdG90eXBlXG4vLyB0byBzdGlsbCBiZSBpbiB0aGUgcHJvdG90eXBlIGNoYWluLlxuaWYgKGtvLnV0aWxzLmNhblNldFByb3RvdHlwZSkge1xuICAgIGtvLnV0aWxzLnNldFByb3RvdHlwZU9mKGtvX3N1YnNjcmliYWJsZV9mbiwgRnVuY3Rpb24ucHJvdG90eXBlKTtcbn1cblxua28uc3Vic2NyaWJhYmxlWydmbiddID0ga29fc3Vic2NyaWJhYmxlX2ZuO1xuXG5cbmtvLmlzU3Vic2NyaWJhYmxlID0gZnVuY3Rpb24gKGluc3RhbmNlKSB7XG4gICAgcmV0dXJuIGluc3RhbmNlICE9IG51bGwgJiYgdHlwZW9mIGluc3RhbmNlLnN1YnNjcmliZSA9PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIGluc3RhbmNlW1wibm90aWZ5U3Vic2NyaWJlcnNcIl0gPT0gXCJmdW5jdGlvblwiO1xufTtcblxua28uZXhwb3J0U3ltYm9sKCdzdWJzY3JpYmFibGUnLCBrby5zdWJzY3JpYmFibGUpO1xua28uZXhwb3J0U3ltYm9sKCdpc1N1YnNjcmliYWJsZScsIGtvLmlzU3Vic2NyaWJhYmxlKTtcblxua28uY29tcHV0ZWRDb250ZXh0ID0ga28uZGVwZW5kZW5jeURldGVjdGlvbiA9IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG91dGVyRnJhbWVzID0gW10sXG4gICAgICAgIGN1cnJlbnRGcmFtZSxcbiAgICAgICAgbGFzdElkID0gMDtcblxuICAgIC8vIFJldHVybiBhIHVuaXF1ZSBJRCB0aGF0IGNhbiBiZSBhc3NpZ25lZCB0byBhbiBvYnNlcnZhYmxlIGZvciBkZXBlbmRlbmN5IHRyYWNraW5nLlxuICAgIC8vIFRoZW9yZXRpY2FsbHksIHlvdSBjb3VsZCBldmVudHVhbGx5IG92ZXJmbG93IHRoZSBudW1iZXIgc3RvcmFnZSBzaXplLCByZXN1bHRpbmdcbiAgICAvLyBpbiBkdXBsaWNhdGUgSURzLiBCdXQgaW4gSmF2YVNjcmlwdCwgdGhlIGxhcmdlc3QgZXhhY3QgaW50ZWdyYWwgdmFsdWUgaXMgMl41M1xuICAgIC8vIG9yIDksMDA3LDE5OSwyNTQsNzQwLDk5Mi4gSWYgeW91IGNyZWF0ZWQgMSwwMDAsMDAwIElEcyBwZXIgc2Vjb25kLCBpdCB3b3VsZFxuICAgIC8vIHRha2Ugb3ZlciAyODUgeWVhcnMgdG8gcmVhY2ggdGhhdCBudW1iZXIuXG4gICAgLy8gUmVmZXJlbmNlIGh0dHA6Ly9ibG9nLnZqZXV4LmNvbS8yMDEwL2phdmFzY3JpcHQvamF2YXNjcmlwdC1tYXhfaW50LW51bWJlci1saW1pdHMuaHRtbFxuICAgIGZ1bmN0aW9uIGdldElkKCkge1xuICAgICAgICByZXR1cm4gKytsYXN0SWQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYmVnaW4ob3B0aW9ucykge1xuICAgICAgICBvdXRlckZyYW1lcy5wdXNoKGN1cnJlbnRGcmFtZSk7XG4gICAgICAgIGN1cnJlbnRGcmFtZSA9IG9wdGlvbnM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZW5kKCkge1xuICAgICAgICBjdXJyZW50RnJhbWUgPSBvdXRlckZyYW1lcy5wb3AoKTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgICBiZWdpbjogYmVnaW4sXG5cbiAgICAgICAgZW5kOiBlbmQsXG5cbiAgICAgICAgcmVnaXN0ZXJEZXBlbmRlbmN5OiBmdW5jdGlvbiAoc3Vic2NyaWJhYmxlKSB7XG4gICAgICAgICAgICBpZiAoY3VycmVudEZyYW1lKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFrby5pc1N1YnNjcmliYWJsZShzdWJzY3JpYmFibGUpKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJPbmx5IHN1YnNjcmliYWJsZSB0aGluZ3MgY2FuIGFjdCBhcyBkZXBlbmRlbmNpZXNcIik7XG4gICAgICAgICAgICAgICAgY3VycmVudEZyYW1lLmNhbGxiYWNrLmNhbGwoY3VycmVudEZyYW1lLmNhbGxiYWNrVGFyZ2V0LCBzdWJzY3JpYmFibGUsIHN1YnNjcmliYWJsZS5faWQgfHwgKHN1YnNjcmliYWJsZS5faWQgPSBnZXRJZCgpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgaWdub3JlOiBmdW5jdGlvbiAoY2FsbGJhY2ssIGNhbGxiYWNrVGFyZ2V0LCBjYWxsYmFja0FyZ3MpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgYmVnaW4oKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2suYXBwbHkoY2FsbGJhY2tUYXJnZXQsIGNhbGxiYWNrQXJncyB8fCBbXSk7XG4gICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICAgIGVuZCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIGdldERlcGVuZGVuY2llc0NvdW50OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoY3VycmVudEZyYW1lKVxuICAgICAgICAgICAgICAgIHJldHVybiBjdXJyZW50RnJhbWUuY29tcHV0ZWQuZ2V0RGVwZW5kZW5jaWVzQ291bnQoKTtcbiAgICAgICAgfSxcblxuICAgICAgICBpc0luaXRpYWw6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRGcmFtZSlcbiAgICAgICAgICAgICAgICByZXR1cm4gY3VycmVudEZyYW1lLmlzSW5pdGlhbDtcbiAgICAgICAgfVxuICAgIH07XG59KSgpO1xuXG5rby5leHBvcnRTeW1ib2woJ2NvbXB1dGVkQ29udGV4dCcsIGtvLmNvbXB1dGVkQ29udGV4dCk7XG5rby5leHBvcnRTeW1ib2woJ2NvbXB1dGVkQ29udGV4dC5nZXREZXBlbmRlbmNpZXNDb3VudCcsIGtvLmNvbXB1dGVkQ29udGV4dC5nZXREZXBlbmRlbmNpZXNDb3VudCk7XG5rby5leHBvcnRTeW1ib2woJ2NvbXB1dGVkQ29udGV4dC5pc0luaXRpYWwnLCBrby5jb21wdXRlZENvbnRleHQuaXNJbml0aWFsKTtcblxua28uZXhwb3J0U3ltYm9sKCdpZ25vcmVEZXBlbmRlbmNpZXMnLCBrby5pZ25vcmVEZXBlbmRlbmNpZXMgPSBrby5kZXBlbmRlbmN5RGV0ZWN0aW9uLmlnbm9yZSk7XG52YXIgb2JzZXJ2YWJsZUxhdGVzdFZhbHVlID0ga28udXRpbHMuY3JlYXRlU3ltYm9sT3JTdHJpbmcoJ19sYXRlc3RWYWx1ZScpO1xuXG5rby5vYnNlcnZhYmxlID0gZnVuY3Rpb24gKGluaXRpYWxWYWx1ZSkge1xuICAgIGZ1bmN0aW9uIG9ic2VydmFibGUoKSB7XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgLy8gV3JpdGVcblxuICAgICAgICAgICAgLy8gSWdub3JlIHdyaXRlcyBpZiB0aGUgdmFsdWUgaGFzbid0IGNoYW5nZWRcbiAgICAgICAgICAgIGlmIChvYnNlcnZhYmxlLmlzRGlmZmVyZW50KG9ic2VydmFibGVbb2JzZXJ2YWJsZUxhdGVzdFZhbHVlXSwgYXJndW1lbnRzWzBdKSkge1xuICAgICAgICAgICAgICAgIG9ic2VydmFibGUudmFsdWVXaWxsTXV0YXRlKCk7XG4gICAgICAgICAgICAgICAgb2JzZXJ2YWJsZVtvYnNlcnZhYmxlTGF0ZXN0VmFsdWVdID0gYXJndW1lbnRzWzBdO1xuICAgICAgICAgICAgICAgIG9ic2VydmFibGUudmFsdWVIYXNNdXRhdGVkKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpczsgLy8gUGVybWl0cyBjaGFpbmVkIGFzc2lnbm1lbnRzXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBSZWFkXG4gICAgICAgICAgICBrby5kZXBlbmRlbmN5RGV0ZWN0aW9uLnJlZ2lzdGVyRGVwZW5kZW5jeShvYnNlcnZhYmxlKTsgLy8gVGhlIGNhbGxlciBvbmx5IG5lZWRzIHRvIGJlIG5vdGlmaWVkIG9mIGNoYW5nZXMgaWYgdGhleSBkaWQgYSBcInJlYWRcIiBvcGVyYXRpb25cbiAgICAgICAgICAgIHJldHVybiBvYnNlcnZhYmxlW29ic2VydmFibGVMYXRlc3RWYWx1ZV07XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBvYnNlcnZhYmxlW29ic2VydmFibGVMYXRlc3RWYWx1ZV0gPSBpbml0aWFsVmFsdWU7XG5cbiAgICAvLyBJbmhlcml0IGZyb20gJ3N1YnNjcmliYWJsZSdcbiAgICBpZiAoIWtvLnV0aWxzLmNhblNldFByb3RvdHlwZSkge1xuICAgICAgICAvLyAnc3Vic2NyaWJhYmxlJyB3b24ndCBiZSBvbiB0aGUgcHJvdG90eXBlIGNoYWluIHVubGVzcyB3ZSBwdXQgaXQgdGhlcmUgZGlyZWN0bHlcbiAgICAgICAga28udXRpbHMuZXh0ZW5kKG9ic2VydmFibGUsIGtvLnN1YnNjcmliYWJsZVsnZm4nXSk7XG4gICAgfVxuICAgIGtvLnN1YnNjcmliYWJsZVsnZm4nXS5pbml0KG9ic2VydmFibGUpO1xuXG4gICAgLy8gSW5oZXJpdCBmcm9tICdvYnNlcnZhYmxlJ1xuICAgIGtvLnV0aWxzLnNldFByb3RvdHlwZU9mT3JFeHRlbmQob2JzZXJ2YWJsZSwgb2JzZXJ2YWJsZUZuKTtcblxuICAgIGlmIChrby5vcHRpb25zWydkZWZlclVwZGF0ZXMnXSkge1xuICAgICAgICBrby5leHRlbmRlcnNbJ2RlZmVycmVkJ10ob2JzZXJ2YWJsZSwgdHJ1ZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG9ic2VydmFibGU7XG59XG5cbi8vIERlZmluZSBwcm90b3R5cGUgZm9yIG9ic2VydmFibGVzXG52YXIgb2JzZXJ2YWJsZUZuID0ge1xuICAgICdlcXVhbGl0eUNvbXBhcmVyJzogdmFsdWVzQXJlUHJpbWl0aXZlQW5kRXF1YWwsXG4gICAgcGVlazogZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzW29ic2VydmFibGVMYXRlc3RWYWx1ZV07IH0sXG4gICAgdmFsdWVIYXNNdXRhdGVkOiBmdW5jdGlvbiAoKSB7IHRoaXNbJ25vdGlmeVN1YnNjcmliZXJzJ10odGhpc1tvYnNlcnZhYmxlTGF0ZXN0VmFsdWVdKTsgfSxcbiAgICB2YWx1ZVdpbGxNdXRhdGU6IGZ1bmN0aW9uICgpIHsgdGhpc1snbm90aWZ5U3Vic2NyaWJlcnMnXSh0aGlzW29ic2VydmFibGVMYXRlc3RWYWx1ZV0sICdiZWZvcmVDaGFuZ2UnKTsgfVxufTtcblxuLy8gTm90ZSB0aGF0IGZvciBicm93c2VycyB0aGF0IGRvbid0IHN1cHBvcnQgcHJvdG8gYXNzaWdubWVudCwgdGhlXG4vLyBpbmhlcml0YW5jZSBjaGFpbiBpcyBjcmVhdGVkIG1hbnVhbGx5IGluIHRoZSBrby5vYnNlcnZhYmxlIGNvbnN0cnVjdG9yXG5pZiAoa28udXRpbHMuY2FuU2V0UHJvdG90eXBlKSB7XG4gICAga28udXRpbHMuc2V0UHJvdG90eXBlT2Yob2JzZXJ2YWJsZUZuLCBrby5zdWJzY3JpYmFibGVbJ2ZuJ10pO1xufVxuXG52YXIgcHJvdG9Qcm9wZXJ0eSA9IGtvLm9ic2VydmFibGUucHJvdG9Qcm9wZXJ0eSA9ICdfX2tvX3Byb3RvX18nO1xub2JzZXJ2YWJsZUZuW3Byb3RvUHJvcGVydHldID0ga28ub2JzZXJ2YWJsZTtcblxua28uaGFzUHJvdG90eXBlID0gZnVuY3Rpb24oaW5zdGFuY2UsIHByb3RvdHlwZSkge1xuICAgIGlmICgoaW5zdGFuY2UgPT09IG51bGwpIHx8IChpbnN0YW5jZSA9PT0gdW5kZWZpbmVkKSB8fCAoaW5zdGFuY2VbcHJvdG9Qcm9wZXJ0eV0gPT09IHVuZGVmaW5lZCkpIHJldHVybiBmYWxzZTtcbiAgICBpZiAoaW5zdGFuY2VbcHJvdG9Qcm9wZXJ0eV0gPT09IHByb3RvdHlwZSkgcmV0dXJuIHRydWU7XG4gICAgcmV0dXJuIGtvLmhhc1Byb3RvdHlwZShpbnN0YW5jZVtwcm90b1Byb3BlcnR5XSwgcHJvdG90eXBlKTsgLy8gV2FsayB0aGUgcHJvdG90eXBlIGNoYWluXG59O1xuXG5rby5pc09ic2VydmFibGUgPSBmdW5jdGlvbiAoaW5zdGFuY2UpIHtcbiAgICByZXR1cm4ga28uaGFzUHJvdG90eXBlKGluc3RhbmNlLCBrby5vYnNlcnZhYmxlKTtcbn1cbmtvLmlzV3JpdGVhYmxlT2JzZXJ2YWJsZSA9IGZ1bmN0aW9uIChpbnN0YW5jZSkge1xuICAgIC8vIE9ic2VydmFibGVcbiAgICBpZiAoKHR5cGVvZiBpbnN0YW5jZSA9PSAnZnVuY3Rpb24nKSAmJiBpbnN0YW5jZVtwcm90b1Byb3BlcnR5XSA9PT0ga28ub2JzZXJ2YWJsZSlcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgLy8gV3JpdGVhYmxlIGRlcGVuZGVudCBvYnNlcnZhYmxlXG4gICAgaWYgKCh0eXBlb2YgaW5zdGFuY2UgPT0gJ2Z1bmN0aW9uJykgJiYgKGluc3RhbmNlW3Byb3RvUHJvcGVydHldID09PSBrby5kZXBlbmRlbnRPYnNlcnZhYmxlKSAmJiAoaW5zdGFuY2UuaGFzV3JpdGVGdW5jdGlvbikpXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIC8vIEFueXRoaW5nIGVsc2VcbiAgICByZXR1cm4gZmFsc2U7XG59XG5cbmtvLmV4cG9ydFN5bWJvbCgnb2JzZXJ2YWJsZScsIGtvLm9ic2VydmFibGUpO1xua28uZXhwb3J0U3ltYm9sKCdpc09ic2VydmFibGUnLCBrby5pc09ic2VydmFibGUpO1xua28uZXhwb3J0U3ltYm9sKCdpc1dyaXRlYWJsZU9ic2VydmFibGUnLCBrby5pc1dyaXRlYWJsZU9ic2VydmFibGUpO1xua28uZXhwb3J0U3ltYm9sKCdpc1dyaXRhYmxlT2JzZXJ2YWJsZScsIGtvLmlzV3JpdGVhYmxlT2JzZXJ2YWJsZSk7XG5rby5leHBvcnRTeW1ib2woJ29ic2VydmFibGUuZm4nLCBvYnNlcnZhYmxlRm4pO1xua28uZXhwb3J0UHJvcGVydHkob2JzZXJ2YWJsZUZuLCAncGVlaycsIG9ic2VydmFibGVGbi5wZWVrKTtcbmtvLmV4cG9ydFByb3BlcnR5KG9ic2VydmFibGVGbiwgJ3ZhbHVlSGFzTXV0YXRlZCcsIG9ic2VydmFibGVGbi52YWx1ZUhhc011dGF0ZWQpO1xua28uZXhwb3J0UHJvcGVydHkob2JzZXJ2YWJsZUZuLCAndmFsdWVXaWxsTXV0YXRlJywgb2JzZXJ2YWJsZUZuLnZhbHVlV2lsbE11dGF0ZSk7XG5rby5vYnNlcnZhYmxlQXJyYXkgPSBmdW5jdGlvbiAoaW5pdGlhbFZhbHVlcykge1xuICAgIGluaXRpYWxWYWx1ZXMgPSBpbml0aWFsVmFsdWVzIHx8IFtdO1xuXG4gICAgaWYgKHR5cGVvZiBpbml0aWFsVmFsdWVzICE9ICdvYmplY3QnIHx8ICEoJ2xlbmd0aCcgaW4gaW5pdGlhbFZhbHVlcykpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoZSBhcmd1bWVudCBwYXNzZWQgd2hlbiBpbml0aWFsaXppbmcgYW4gb2JzZXJ2YWJsZSBhcnJheSBtdXN0IGJlIGFuIGFycmF5LCBvciBudWxsLCBvciB1bmRlZmluZWQuXCIpO1xuXG4gICAgdmFyIHJlc3VsdCA9IGtvLm9ic2VydmFibGUoaW5pdGlhbFZhbHVlcyk7XG4gICAga28udXRpbHMuc2V0UHJvdG90eXBlT2ZPckV4dGVuZChyZXN1bHQsIGtvLm9ic2VydmFibGVBcnJheVsnZm4nXSk7XG4gICAgcmV0dXJuIHJlc3VsdC5leHRlbmQoeyd0cmFja0FycmF5Q2hhbmdlcyc6dHJ1ZX0pO1xufTtcblxua28ub2JzZXJ2YWJsZUFycmF5WydmbiddID0ge1xuICAgICdyZW1vdmUnOiBmdW5jdGlvbiAodmFsdWVPclByZWRpY2F0ZSkge1xuICAgICAgICB2YXIgdW5kZXJseWluZ0FycmF5ID0gdGhpcy5wZWVrKCk7XG4gICAgICAgIHZhciByZW1vdmVkVmFsdWVzID0gW107XG4gICAgICAgIHZhciBwcmVkaWNhdGUgPSB0eXBlb2YgdmFsdWVPclByZWRpY2F0ZSA9PSBcImZ1bmN0aW9uXCIgJiYgIWtvLmlzT2JzZXJ2YWJsZSh2YWx1ZU9yUHJlZGljYXRlKSA/IHZhbHVlT3JQcmVkaWNhdGUgOiBmdW5jdGlvbiAodmFsdWUpIHsgcmV0dXJuIHZhbHVlID09PSB2YWx1ZU9yUHJlZGljYXRlOyB9O1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHVuZGVybHlpbmdBcnJheS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gdW5kZXJseWluZ0FycmF5W2ldO1xuICAgICAgICAgICAgaWYgKHByZWRpY2F0ZSh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICBpZiAocmVtb3ZlZFZhbHVlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy52YWx1ZVdpbGxNdXRhdGUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVtb3ZlZFZhbHVlcy5wdXNoKHZhbHVlKTtcbiAgICAgICAgICAgICAgICB1bmRlcmx5aW5nQXJyYXkuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgICAgIGktLTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAocmVtb3ZlZFZhbHVlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMudmFsdWVIYXNNdXRhdGVkKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlbW92ZWRWYWx1ZXM7XG4gICAgfSxcblxuICAgICdyZW1vdmVBbGwnOiBmdW5jdGlvbiAoYXJyYXlPZlZhbHVlcykge1xuICAgICAgICAvLyBJZiB5b3UgcGFzc2VkIHplcm8gYXJncywgd2UgcmVtb3ZlIGV2ZXJ5dGhpbmdcbiAgICAgICAgaWYgKGFycmF5T2ZWYWx1ZXMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdmFyIHVuZGVybHlpbmdBcnJheSA9IHRoaXMucGVlaygpO1xuICAgICAgICAgICAgdmFyIGFsbFZhbHVlcyA9IHVuZGVybHlpbmdBcnJheS5zbGljZSgwKTtcbiAgICAgICAgICAgIHRoaXMudmFsdWVXaWxsTXV0YXRlKCk7XG4gICAgICAgICAgICB1bmRlcmx5aW5nQXJyYXkuc3BsaWNlKDAsIHVuZGVybHlpbmdBcnJheS5sZW5ndGgpO1xuICAgICAgICAgICAgdGhpcy52YWx1ZUhhc011dGF0ZWQoKTtcbiAgICAgICAgICAgIHJldHVybiBhbGxWYWx1ZXM7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgeW91IHBhc3NlZCBhbiBhcmcsIHdlIGludGVycHJldCBpdCBhcyBhbiBhcnJheSBvZiBlbnRyaWVzIHRvIHJlbW92ZVxuICAgICAgICBpZiAoIWFycmF5T2ZWYWx1ZXMpXG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIHJldHVybiB0aGlzWydyZW1vdmUnXShmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiBrby51dGlscy5hcnJheUluZGV4T2YoYXJyYXlPZlZhbHVlcywgdmFsdWUpID49IDA7XG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAnZGVzdHJveSc6IGZ1bmN0aW9uICh2YWx1ZU9yUHJlZGljYXRlKSB7XG4gICAgICAgIHZhciB1bmRlcmx5aW5nQXJyYXkgPSB0aGlzLnBlZWsoKTtcbiAgICAgICAgdmFyIHByZWRpY2F0ZSA9IHR5cGVvZiB2YWx1ZU9yUHJlZGljYXRlID09IFwiZnVuY3Rpb25cIiAmJiAha28uaXNPYnNlcnZhYmxlKHZhbHVlT3JQcmVkaWNhdGUpID8gdmFsdWVPclByZWRpY2F0ZSA6IGZ1bmN0aW9uICh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgPT09IHZhbHVlT3JQcmVkaWNhdGU7IH07XG4gICAgICAgIHRoaXMudmFsdWVXaWxsTXV0YXRlKCk7XG4gICAgICAgIGZvciAodmFyIGkgPSB1bmRlcmx5aW5nQXJyYXkubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IHVuZGVybHlpbmdBcnJheVtpXTtcbiAgICAgICAgICAgIGlmIChwcmVkaWNhdGUodmFsdWUpKVxuICAgICAgICAgICAgICAgIHVuZGVybHlpbmdBcnJheVtpXVtcIl9kZXN0cm95XCJdID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnZhbHVlSGFzTXV0YXRlZCgpO1xuICAgIH0sXG5cbiAgICAnZGVzdHJveUFsbCc6IGZ1bmN0aW9uIChhcnJheU9mVmFsdWVzKSB7XG4gICAgICAgIC8vIElmIHlvdSBwYXNzZWQgemVybyBhcmdzLCB3ZSBkZXN0cm95IGV2ZXJ5dGhpbmdcbiAgICAgICAgaWYgKGFycmF5T2ZWYWx1ZXMgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHJldHVybiB0aGlzWydkZXN0cm95J10oZnVuY3Rpb24oKSB7IHJldHVybiB0cnVlIH0pO1xuXG4gICAgICAgIC8vIElmIHlvdSBwYXNzZWQgYW4gYXJnLCB3ZSBpbnRlcnByZXQgaXQgYXMgYW4gYXJyYXkgb2YgZW50cmllcyB0byBkZXN0cm95XG4gICAgICAgIGlmICghYXJyYXlPZlZhbHVlcylcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgcmV0dXJuIHRoaXNbJ2Rlc3Ryb3knXShmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiBrby51dGlscy5hcnJheUluZGV4T2YoYXJyYXlPZlZhbHVlcywgdmFsdWUpID49IDA7XG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAnaW5kZXhPZic6IGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgIHZhciB1bmRlcmx5aW5nQXJyYXkgPSB0aGlzKCk7XG4gICAgICAgIHJldHVybiBrby51dGlscy5hcnJheUluZGV4T2YodW5kZXJseWluZ0FycmF5LCBpdGVtKTtcbiAgICB9LFxuXG4gICAgJ3JlcGxhY2UnOiBmdW5jdGlvbihvbGRJdGVtLCBuZXdJdGVtKSB7XG4gICAgICAgIHZhciBpbmRleCA9IHRoaXNbJ2luZGV4T2YnXShvbGRJdGVtKTtcbiAgICAgICAgaWYgKGluZGV4ID49IDApIHtcbiAgICAgICAgICAgIHRoaXMudmFsdWVXaWxsTXV0YXRlKCk7XG4gICAgICAgICAgICB0aGlzLnBlZWsoKVtpbmRleF0gPSBuZXdJdGVtO1xuICAgICAgICAgICAgdGhpcy52YWx1ZUhhc011dGF0ZWQoKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbi8vIE5vdGUgdGhhdCBmb3IgYnJvd3NlcnMgdGhhdCBkb24ndCBzdXBwb3J0IHByb3RvIGFzc2lnbm1lbnQsIHRoZVxuLy8gaW5oZXJpdGFuY2UgY2hhaW4gaXMgY3JlYXRlZCBtYW51YWxseSBpbiB0aGUga28ub2JzZXJ2YWJsZUFycmF5IGNvbnN0cnVjdG9yXG5pZiAoa28udXRpbHMuY2FuU2V0UHJvdG90eXBlKSB7XG4gICAga28udXRpbHMuc2V0UHJvdG90eXBlT2Yoa28ub2JzZXJ2YWJsZUFycmF5WydmbiddLCBrby5vYnNlcnZhYmxlWydmbiddKTtcbn1cblxuLy8gUG9wdWxhdGUga28ub2JzZXJ2YWJsZUFycmF5LmZuIHdpdGggcmVhZC93cml0ZSBmdW5jdGlvbnMgZnJvbSBuYXRpdmUgYXJyYXlzXG4vLyBJbXBvcnRhbnQ6IERvIG5vdCBhZGQgYW55IGFkZGl0aW9uYWwgZnVuY3Rpb25zIGhlcmUgdGhhdCBtYXkgcmVhc29uYWJseSBiZSB1c2VkIHRvICpyZWFkKiBkYXRhIGZyb20gdGhlIGFycmF5XG4vLyBiZWNhdXNlIHdlJ2xsIGV2YWwgdGhlbSB3aXRob3V0IGNhdXNpbmcgc3Vic2NyaXB0aW9ucywgc28ga28uY29tcHV0ZWQgb3V0cHV0IGNvdWxkIGVuZCB1cCBnZXR0aW5nIHN0YWxlXG5rby51dGlscy5hcnJheUZvckVhY2goW1wicG9wXCIsIFwicHVzaFwiLCBcInJldmVyc2VcIiwgXCJzaGlmdFwiLCBcInNvcnRcIiwgXCJzcGxpY2VcIiwgXCJ1bnNoaWZ0XCJdLCBmdW5jdGlvbiAobWV0aG9kTmFtZSkge1xuICAgIGtvLm9ic2VydmFibGVBcnJheVsnZm4nXVttZXRob2ROYW1lXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gVXNlIFwicGVla1wiIHRvIGF2b2lkIGNyZWF0aW5nIGEgc3Vic2NyaXB0aW9uIGluIGFueSBjb21wdXRlZCB0aGF0IHdlJ3JlIGV4ZWN1dGluZyBpbiB0aGUgY29udGV4dCBvZlxuICAgICAgICAvLyAoZm9yIGNvbnNpc3RlbmN5IHdpdGggbXV0YXRpbmcgcmVndWxhciBvYnNlcnZhYmxlcylcbiAgICAgICAgdmFyIHVuZGVybHlpbmdBcnJheSA9IHRoaXMucGVlaygpO1xuICAgICAgICB0aGlzLnZhbHVlV2lsbE11dGF0ZSgpO1xuICAgICAgICB0aGlzLmNhY2hlRGlmZkZvcktub3duT3BlcmF0aW9uKHVuZGVybHlpbmdBcnJheSwgbWV0aG9kTmFtZSwgYXJndW1lbnRzKTtcbiAgICAgICAgdmFyIG1ldGhvZENhbGxSZXN1bHQgPSB1bmRlcmx5aW5nQXJyYXlbbWV0aG9kTmFtZV0uYXBwbHkodW5kZXJseWluZ0FycmF5LCBhcmd1bWVudHMpO1xuICAgICAgICB0aGlzLnZhbHVlSGFzTXV0YXRlZCgpO1xuICAgICAgICAvLyBUaGUgbmF0aXZlIHNvcnQgYW5kIHJldmVyc2UgbWV0aG9kcyByZXR1cm4gYSByZWZlcmVuY2UgdG8gdGhlIGFycmF5LCBidXQgaXQgbWFrZXMgbW9yZSBzZW5zZSB0byByZXR1cm4gdGhlIG9ic2VydmFibGUgYXJyYXkgaW5zdGVhZC5cbiAgICAgICAgcmV0dXJuIG1ldGhvZENhbGxSZXN1bHQgPT09IHVuZGVybHlpbmdBcnJheSA/IHRoaXMgOiBtZXRob2RDYWxsUmVzdWx0O1xuICAgIH07XG59KTtcblxuLy8gUG9wdWxhdGUga28ub2JzZXJ2YWJsZUFycmF5LmZuIHdpdGggcmVhZC1vbmx5IGZ1bmN0aW9ucyBmcm9tIG5hdGl2ZSBhcnJheXNcbmtvLnV0aWxzLmFycmF5Rm9yRWFjaChbXCJzbGljZVwiXSwgZnVuY3Rpb24gKG1ldGhvZE5hbWUpIHtcbiAgICBrby5vYnNlcnZhYmxlQXJyYXlbJ2ZuJ11bbWV0aG9kTmFtZV0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB1bmRlcmx5aW5nQXJyYXkgPSB0aGlzKCk7XG4gICAgICAgIHJldHVybiB1bmRlcmx5aW5nQXJyYXlbbWV0aG9kTmFtZV0uYXBwbHkodW5kZXJseWluZ0FycmF5LCBhcmd1bWVudHMpO1xuICAgIH07XG59KTtcblxua28uZXhwb3J0U3ltYm9sKCdvYnNlcnZhYmxlQXJyYXknLCBrby5vYnNlcnZhYmxlQXJyYXkpO1xudmFyIGFycmF5Q2hhbmdlRXZlbnROYW1lID0gJ2FycmF5Q2hhbmdlJztcbmtvLmV4dGVuZGVyc1sndHJhY2tBcnJheUNoYW5nZXMnXSA9IGZ1bmN0aW9uKHRhcmdldCwgb3B0aW9ucykge1xuICAgIC8vIFVzZSB0aGUgcHJvdmlkZWQgb3B0aW9ucy0tZWFjaCBjYWxsIHRvIHRyYWNrQXJyYXlDaGFuZ2VzIG92ZXJ3cml0ZXMgdGhlIHByZXZpb3VzbHkgc2V0IG9wdGlvbnNcbiAgICB0YXJnZXQuY29tcGFyZUFycmF5T3B0aW9ucyA9IHt9O1xuICAgIGlmIChvcHRpb25zICYmIHR5cGVvZiBvcHRpb25zID09IFwib2JqZWN0XCIpIHtcbiAgICAgICAga28udXRpbHMuZXh0ZW5kKHRhcmdldC5jb21wYXJlQXJyYXlPcHRpb25zLCBvcHRpb25zKTtcbiAgICB9XG4gICAgdGFyZ2V0LmNvbXBhcmVBcnJheU9wdGlvbnNbJ3NwYXJzZSddID0gdHJ1ZTtcblxuICAgIC8vIE9ubHkgbW9kaWZ5IHRoZSB0YXJnZXQgb2JzZXJ2YWJsZSBvbmNlXG4gICAgaWYgKHRhcmdldC5jYWNoZURpZmZGb3JLbm93bk9wZXJhdGlvbikge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciB0cmFja2luZ0NoYW5nZXMgPSBmYWxzZSxcbiAgICAgICAgY2FjaGVkRGlmZiA9IG51bGwsXG4gICAgICAgIGFycmF5Q2hhbmdlU3Vic2NyaXB0aW9uLFxuICAgICAgICBwZW5kaW5nTm90aWZpY2F0aW9ucyA9IDAsXG4gICAgICAgIHVuZGVybHlpbmdOb3RpZnlTdWJzY3JpYmVyc0Z1bmN0aW9uLFxuICAgICAgICB1bmRlcmx5aW5nQmVmb3JlU3Vic2NyaXB0aW9uQWRkRnVuY3Rpb24gPSB0YXJnZXQuYmVmb3JlU3Vic2NyaXB0aW9uQWRkLFxuICAgICAgICB1bmRlcmx5aW5nQWZ0ZXJTdWJzY3JpcHRpb25SZW1vdmVGdW5jdGlvbiA9IHRhcmdldC5hZnRlclN1YnNjcmlwdGlvblJlbW92ZTtcblxuICAgIC8vIFdhdGNoIFwic3Vic2NyaWJlXCIgY2FsbHMsIGFuZCBmb3IgYXJyYXkgY2hhbmdlIGV2ZW50cywgZW5zdXJlIGNoYW5nZSB0cmFja2luZyBpcyBlbmFibGVkXG4gICAgdGFyZ2V0LmJlZm9yZVN1YnNjcmlwdGlvbkFkZCA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICBpZiAodW5kZXJseWluZ0JlZm9yZVN1YnNjcmlwdGlvbkFkZEZ1bmN0aW9uKVxuICAgICAgICAgICAgdW5kZXJseWluZ0JlZm9yZVN1YnNjcmlwdGlvbkFkZEZ1bmN0aW9uLmNhbGwodGFyZ2V0LCBldmVudCk7XG4gICAgICAgIGlmIChldmVudCA9PT0gYXJyYXlDaGFuZ2VFdmVudE5hbWUpIHtcbiAgICAgICAgICAgIHRyYWNrQ2hhbmdlcygpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvLyBXYXRjaCBcImRpc3Bvc2VcIiBjYWxscywgYW5kIGZvciBhcnJheSBjaGFuZ2UgZXZlbnRzLCBlbnN1cmUgY2hhbmdlIHRyYWNraW5nIGlzIGRpc2FibGVkIHdoZW4gYWxsIGFyZSBkaXNwb3NlZFxuICAgIHRhcmdldC5hZnRlclN1YnNjcmlwdGlvblJlbW92ZSA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICBpZiAodW5kZXJseWluZ0FmdGVyU3Vic2NyaXB0aW9uUmVtb3ZlRnVuY3Rpb24pXG4gICAgICAgICAgICB1bmRlcmx5aW5nQWZ0ZXJTdWJzY3JpcHRpb25SZW1vdmVGdW5jdGlvbi5jYWxsKHRhcmdldCwgZXZlbnQpO1xuICAgICAgICBpZiAoZXZlbnQgPT09IGFycmF5Q2hhbmdlRXZlbnROYW1lICYmICF0YXJnZXQuaGFzU3Vic2NyaXB0aW9uc0ZvckV2ZW50KGFycmF5Q2hhbmdlRXZlbnROYW1lKSkge1xuICAgICAgICAgICAgaWYgKHVuZGVybHlpbmdOb3RpZnlTdWJzY3JpYmVyc0Z1bmN0aW9uKSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0Wydub3RpZnlTdWJzY3JpYmVycyddID0gdW5kZXJseWluZ05vdGlmeVN1YnNjcmliZXJzRnVuY3Rpb247XG4gICAgICAgICAgICAgICAgdW5kZXJseWluZ05vdGlmeVN1YnNjcmliZXJzRnVuY3Rpb24gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhcnJheUNoYW5nZVN1YnNjcmlwdGlvbi5kaXNwb3NlKCk7XG4gICAgICAgICAgICB0cmFja2luZ0NoYW5nZXMgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBmdW5jdGlvbiB0cmFja0NoYW5nZXMoKSB7XG4gICAgICAgIC8vIENhbGxpbmcgJ3RyYWNrQ2hhbmdlcycgbXVsdGlwbGUgdGltZXMgaXMgdGhlIHNhbWUgYXMgY2FsbGluZyBpdCBvbmNlXG4gICAgICAgIGlmICh0cmFja2luZ0NoYW5nZXMpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRyYWNraW5nQ2hhbmdlcyA9IHRydWU7XG5cbiAgICAgICAgLy8gSW50ZXJjZXB0IFwibm90aWZ5U3Vic2NyaWJlcnNcIiB0byB0cmFjayBob3cgbWFueSB0aW1lcyBpdCB3YXMgY2FsbGVkLlxuICAgICAgICB1bmRlcmx5aW5nTm90aWZ5U3Vic2NyaWJlcnNGdW5jdGlvbiA9IHRhcmdldFsnbm90aWZ5U3Vic2NyaWJlcnMnXTtcbiAgICAgICAgdGFyZ2V0Wydub3RpZnlTdWJzY3JpYmVycyddID0gZnVuY3Rpb24odmFsdWVUb05vdGlmeSwgZXZlbnQpIHtcbiAgICAgICAgICAgIGlmICghZXZlbnQgfHwgZXZlbnQgPT09IGRlZmF1bHRFdmVudCkge1xuICAgICAgICAgICAgICAgICsrcGVuZGluZ05vdGlmaWNhdGlvbnM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdW5kZXJseWluZ05vdGlmeVN1YnNjcmliZXJzRnVuY3Rpb24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBFYWNoIHRpbWUgdGhlIGFycmF5IGNoYW5nZXMgdmFsdWUsIGNhcHR1cmUgYSBjbG9uZSBzbyB0aGF0IG9uIHRoZSBuZXh0XG4gICAgICAgIC8vIGNoYW5nZSBpdCdzIHBvc3NpYmxlIHRvIHByb2R1Y2UgYSBkaWZmXG4gICAgICAgIHZhciBwcmV2aW91c0NvbnRlbnRzID0gW10uY29uY2F0KHRhcmdldC5wZWVrKCkgfHwgW10pO1xuICAgICAgICBjYWNoZWREaWZmID0gbnVsbDtcbiAgICAgICAgYXJyYXlDaGFuZ2VTdWJzY3JpcHRpb24gPSB0YXJnZXQuc3Vic2NyaWJlKGZ1bmN0aW9uKGN1cnJlbnRDb250ZW50cykge1xuICAgICAgICAgICAgLy8gTWFrZSBhIGNvcHkgb2YgdGhlIGN1cnJlbnQgY29udGVudHMgYW5kIGVuc3VyZSBpdCdzIGFuIGFycmF5XG4gICAgICAgICAgICBjdXJyZW50Q29udGVudHMgPSBbXS5jb25jYXQoY3VycmVudENvbnRlbnRzIHx8IFtdKTtcblxuICAgICAgICAgICAgLy8gQ29tcHV0ZSB0aGUgZGlmZiBhbmQgaXNzdWUgbm90aWZpY2F0aW9ucywgYnV0IG9ubHkgaWYgc29tZW9uZSBpcyBsaXN0ZW5pbmdcbiAgICAgICAgICAgIGlmICh0YXJnZXQuaGFzU3Vic2NyaXB0aW9uc0ZvckV2ZW50KGFycmF5Q2hhbmdlRXZlbnROYW1lKSkge1xuICAgICAgICAgICAgICAgIHZhciBjaGFuZ2VzID0gZ2V0Q2hhbmdlcyhwcmV2aW91c0NvbnRlbnRzLCBjdXJyZW50Q29udGVudHMpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBFbGltaW5hdGUgcmVmZXJlbmNlcyB0byB0aGUgb2xkLCByZW1vdmVkIGl0ZW1zLCBzbyB0aGV5IGNhbiBiZSBHQ2VkXG4gICAgICAgICAgICBwcmV2aW91c0NvbnRlbnRzID0gY3VycmVudENvbnRlbnRzO1xuICAgICAgICAgICAgY2FjaGVkRGlmZiA9IG51bGw7XG4gICAgICAgICAgICBwZW5kaW5nTm90aWZpY2F0aW9ucyA9IDA7XG5cbiAgICAgICAgICAgIGlmIChjaGFuZ2VzICYmIGNoYW5nZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0Wydub3RpZnlTdWJzY3JpYmVycyddKGNoYW5nZXMsIGFycmF5Q2hhbmdlRXZlbnROYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0Q2hhbmdlcyhwcmV2aW91c0NvbnRlbnRzLCBjdXJyZW50Q29udGVudHMpIHtcbiAgICAgICAgLy8gV2UgdHJ5IHRvIHJlLXVzZSBjYWNoZWQgZGlmZnMuXG4gICAgICAgIC8vIFRoZSBzY2VuYXJpb3Mgd2hlcmUgcGVuZGluZ05vdGlmaWNhdGlvbnMgPiAxIGFyZSB3aGVuIHVzaW5nIHJhdGUtbGltaXRpbmcgb3IgdGhlIERlZmVycmVkIFVwZGF0ZXNcbiAgICAgICAgLy8gcGx1Z2luLCB3aGljaCB3aXRob3V0IHRoaXMgY2hlY2sgd291bGQgbm90IGJlIGNvbXBhdGlibGUgd2l0aCBhcnJheUNoYW5nZSBub3RpZmljYXRpb25zLiBOb3JtYWxseSxcbiAgICAgICAgLy8gbm90aWZpY2F0aW9ucyBhcmUgaXNzdWVkIGltbWVkaWF0ZWx5IHNvIHdlIHdvdWxkbid0IGJlIHF1ZXVlaW5nIHVwIG1vcmUgdGhhbiBvbmUuXG4gICAgICAgIGlmICghY2FjaGVkRGlmZiB8fCBwZW5kaW5nTm90aWZpY2F0aW9ucyA+IDEpIHtcbiAgICAgICAgICAgIGNhY2hlZERpZmYgPSBrby51dGlscy5jb21wYXJlQXJyYXlzKHByZXZpb3VzQ29udGVudHMsIGN1cnJlbnRDb250ZW50cywgdGFyZ2V0LmNvbXBhcmVBcnJheU9wdGlvbnMpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNhY2hlZERpZmY7XG4gICAgfVxuXG4gICAgdGFyZ2V0LmNhY2hlRGlmZkZvcktub3duT3BlcmF0aW9uID0gZnVuY3Rpb24ocmF3QXJyYXksIG9wZXJhdGlvbk5hbWUsIGFyZ3MpIHtcbiAgICAgICAgLy8gT25seSBydW4gaWYgd2UncmUgY3VycmVudGx5IHRyYWNraW5nIGNoYW5nZXMgZm9yIHRoaXMgb2JzZXJ2YWJsZSBhcnJheVxuICAgICAgICAvLyBhbmQgdGhlcmUgYXJlbid0IGFueSBwZW5kaW5nIGRlZmVycmVkIG5vdGlmaWNhdGlvbnMuXG4gICAgICAgIGlmICghdHJhY2tpbmdDaGFuZ2VzIHx8IHBlbmRpbmdOb3RpZmljYXRpb25zKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGRpZmYgPSBbXSxcbiAgICAgICAgICAgIGFycmF5TGVuZ3RoID0gcmF3QXJyYXkubGVuZ3RoLFxuICAgICAgICAgICAgYXJnc0xlbmd0aCA9IGFyZ3MubGVuZ3RoLFxuICAgICAgICAgICAgb2Zmc2V0ID0gMDtcblxuICAgICAgICBmdW5jdGlvbiBwdXNoRGlmZihzdGF0dXMsIHZhbHVlLCBpbmRleCkge1xuICAgICAgICAgICAgcmV0dXJuIGRpZmZbZGlmZi5sZW5ndGhdID0geyAnc3RhdHVzJzogc3RhdHVzLCAndmFsdWUnOiB2YWx1ZSwgJ2luZGV4JzogaW5kZXggfTtcbiAgICAgICAgfVxuICAgICAgICBzd2l0Y2ggKG9wZXJhdGlvbk5hbWUpIHtcbiAgICAgICAgICAgIGNhc2UgJ3B1c2gnOlxuICAgICAgICAgICAgICAgIG9mZnNldCA9IGFycmF5TGVuZ3RoO1xuICAgICAgICAgICAgY2FzZSAndW5zaGlmdCc6XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IGFyZ3NMZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgICAgICAgICAgICAgcHVzaERpZmYoJ2FkZGVkJywgYXJnc1tpbmRleF0sIG9mZnNldCArIGluZGV4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgJ3BvcCc6XG4gICAgICAgICAgICAgICAgb2Zmc2V0ID0gYXJyYXlMZW5ndGggLSAxO1xuICAgICAgICAgICAgY2FzZSAnc2hpZnQnOlxuICAgICAgICAgICAgICAgIGlmIChhcnJheUxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBwdXNoRGlmZignZGVsZXRlZCcsIHJhd0FycmF5W29mZnNldF0sIG9mZnNldCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlICdzcGxpY2UnOlxuICAgICAgICAgICAgICAgIC8vIE5lZ2F0aXZlIHN0YXJ0IGluZGV4IG1lYW5zICdmcm9tIGVuZCBvZiBhcnJheScuIEFmdGVyIHRoYXQgd2UgY2xhbXAgdG8gWzAuLi5hcnJheUxlbmd0aF0uXG4gICAgICAgICAgICAgICAgLy8gU2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0FycmF5L3NwbGljZVxuICAgICAgICAgICAgICAgIHZhciBzdGFydEluZGV4ID0gTWF0aC5taW4oTWF0aC5tYXgoMCwgYXJnc1swXSA8IDAgPyBhcnJheUxlbmd0aCArIGFyZ3NbMF0gOiBhcmdzWzBdKSwgYXJyYXlMZW5ndGgpLFxuICAgICAgICAgICAgICAgICAgICBlbmREZWxldGVJbmRleCA9IGFyZ3NMZW5ndGggPT09IDEgPyBhcnJheUxlbmd0aCA6IE1hdGgubWluKHN0YXJ0SW5kZXggKyAoYXJnc1sxXSB8fCAwKSwgYXJyYXlMZW5ndGgpLFxuICAgICAgICAgICAgICAgICAgICBlbmRBZGRJbmRleCA9IHN0YXJ0SW5kZXggKyBhcmdzTGVuZ3RoIC0gMixcbiAgICAgICAgICAgICAgICAgICAgZW5kSW5kZXggPSBNYXRoLm1heChlbmREZWxldGVJbmRleCwgZW5kQWRkSW5kZXgpLFxuICAgICAgICAgICAgICAgICAgICBhZGRpdGlvbnMgPSBbXSwgZGVsZXRpb25zID0gW107XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaW5kZXggPSBzdGFydEluZGV4LCBhcmdzSW5kZXggPSAyOyBpbmRleCA8IGVuZEluZGV4OyArK2luZGV4LCArK2FyZ3NJbmRleCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaW5kZXggPCBlbmREZWxldGVJbmRleClcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0aW9ucy5wdXNoKHB1c2hEaWZmKCdkZWxldGVkJywgcmF3QXJyYXlbaW5kZXhdLCBpbmRleCkpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaW5kZXggPCBlbmRBZGRJbmRleClcbiAgICAgICAgICAgICAgICAgICAgICAgIGFkZGl0aW9ucy5wdXNoKHB1c2hEaWZmKCdhZGRlZCcsIGFyZ3NbYXJnc0luZGV4XSwgaW5kZXgpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAga28udXRpbHMuZmluZE1vdmVzSW5BcnJheUNvbXBhcmlzb24oZGVsZXRpb25zLCBhZGRpdGlvbnMpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjYWNoZWREaWZmID0gZGlmZjtcbiAgICB9O1xufTtcbnZhciBjb21wdXRlZFN0YXRlID0ga28udXRpbHMuY3JlYXRlU3ltYm9sT3JTdHJpbmcoJ19zdGF0ZScpO1xuXG5rby5jb21wdXRlZCA9IGtvLmRlcGVuZGVudE9ic2VydmFibGUgPSBmdW5jdGlvbiAoZXZhbHVhdG9yRnVuY3Rpb25Pck9wdGlvbnMsIGV2YWx1YXRvckZ1bmN0aW9uVGFyZ2V0LCBvcHRpb25zKSB7XG4gICAgaWYgKHR5cGVvZiBldmFsdWF0b3JGdW5jdGlvbk9yT3B0aW9ucyA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAvLyBTaW5nbGUtcGFyYW1ldGVyIHN5bnRheCAtIGV2ZXJ5dGhpbmcgaXMgb24gdGhpcyBcIm9wdGlvbnNcIiBwYXJhbVxuICAgICAgICBvcHRpb25zID0gZXZhbHVhdG9yRnVuY3Rpb25Pck9wdGlvbnM7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gTXVsdGktcGFyYW1ldGVyIHN5bnRheCAtIGNvbnN0cnVjdCB0aGUgb3B0aW9ucyBhY2NvcmRpbmcgdG8gdGhlIHBhcmFtcyBwYXNzZWRcbiAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgICAgIGlmIChldmFsdWF0b3JGdW5jdGlvbk9yT3B0aW9ucykge1xuICAgICAgICAgICAgb3B0aW9uc1tcInJlYWRcIl0gPSBldmFsdWF0b3JGdW5jdGlvbk9yT3B0aW9ucztcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAodHlwZW9mIG9wdGlvbnNbXCJyZWFkXCJdICE9IFwiZnVuY3Rpb25cIilcbiAgICAgICAgdGhyb3cgRXJyb3IoXCJQYXNzIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRoZSB2YWx1ZSBvZiB0aGUga28uY29tcHV0ZWRcIik7XG5cbiAgICB2YXIgd3JpdGVGdW5jdGlvbiA9IG9wdGlvbnNbXCJ3cml0ZVwiXTtcbiAgICB2YXIgc3RhdGUgPSB7XG4gICAgICAgIGxhdGVzdFZhbHVlOiB1bmRlZmluZWQsXG4gICAgICAgIGlzU3RhbGU6IHRydWUsXG4gICAgICAgIGlzQmVpbmdFdmFsdWF0ZWQ6IGZhbHNlLFxuICAgICAgICBzdXBwcmVzc0Rpc3Bvc2FsVW50aWxEaXNwb3NlV2hlblJldHVybnNGYWxzZTogZmFsc2UsXG4gICAgICAgIGlzRGlzcG9zZWQ6IGZhbHNlLFxuICAgICAgICBwdXJlOiBmYWxzZSxcbiAgICAgICAgaXNTbGVlcGluZzogZmFsc2UsXG4gICAgICAgIHJlYWRGdW5jdGlvbjogb3B0aW9uc1tcInJlYWRcIl0sXG4gICAgICAgIGV2YWx1YXRvckZ1bmN0aW9uVGFyZ2V0OiBldmFsdWF0b3JGdW5jdGlvblRhcmdldCB8fCBvcHRpb25zW1wib3duZXJcIl0sXG4gICAgICAgIGRpc3Bvc2VXaGVuTm9kZUlzUmVtb3ZlZDogb3B0aW9uc1tcImRpc3Bvc2VXaGVuTm9kZUlzUmVtb3ZlZFwiXSB8fCBvcHRpb25zLmRpc3Bvc2VXaGVuTm9kZUlzUmVtb3ZlZCB8fCBudWxsLFxuICAgICAgICBkaXNwb3NlV2hlbjogb3B0aW9uc1tcImRpc3Bvc2VXaGVuXCJdIHx8IG9wdGlvbnMuZGlzcG9zZVdoZW4sXG4gICAgICAgIGRvbU5vZGVEaXNwb3NhbENhbGxiYWNrOiBudWxsLFxuICAgICAgICBkZXBlbmRlbmN5VHJhY2tpbmc6IHt9LFxuICAgICAgICBkZXBlbmRlbmNpZXNDb3VudDogMCxcbiAgICAgICAgZXZhbHVhdGlvblRpbWVvdXRJbnN0YW5jZTogbnVsbFxuICAgIH07XG5cbiAgICBmdW5jdGlvbiBjb21wdXRlZE9ic2VydmFibGUoKSB7XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB3cml0ZUZ1bmN0aW9uID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICAvLyBXcml0aW5nIGEgdmFsdWVcbiAgICAgICAgICAgICAgICB3cml0ZUZ1bmN0aW9uLmFwcGx5KHN0YXRlLmV2YWx1YXRvckZ1bmN0aW9uVGFyZ2V0LCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3Qgd3JpdGUgYSB2YWx1ZSB0byBhIGtvLmNvbXB1dGVkIHVubGVzcyB5b3Ugc3BlY2lmeSBhICd3cml0ZScgb3B0aW9uLiBJZiB5b3Ugd2lzaCB0byByZWFkIHRoZSBjdXJyZW50IHZhbHVlLCBkb24ndCBwYXNzIGFueSBwYXJhbWV0ZXJzLlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzOyAvLyBQZXJtaXRzIGNoYWluZWQgYXNzaWdubWVudHNcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIFJlYWRpbmcgdGhlIHZhbHVlXG4gICAgICAgICAgICBrby5kZXBlbmRlbmN5RGV0ZWN0aW9uLnJlZ2lzdGVyRGVwZW5kZW5jeShjb21wdXRlZE9ic2VydmFibGUpO1xuICAgICAgICAgICAgaWYgKHN0YXRlLmlzU3RhbGUgfHwgKHN0YXRlLmlzU2xlZXBpbmcgJiYgY29tcHV0ZWRPYnNlcnZhYmxlLmhhdmVEZXBlbmRlbmNpZXNDaGFuZ2VkKCkpKSB7XG4gICAgICAgICAgICAgICAgY29tcHV0ZWRPYnNlcnZhYmxlLmV2YWx1YXRlSW1tZWRpYXRlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gc3RhdGUubGF0ZXN0VmFsdWU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBjb21wdXRlZE9ic2VydmFibGVbY29tcHV0ZWRTdGF0ZV0gPSBzdGF0ZTtcbiAgICBjb21wdXRlZE9ic2VydmFibGUuaGFzV3JpdGVGdW5jdGlvbiA9IHR5cGVvZiB3cml0ZUZ1bmN0aW9uID09PSBcImZ1bmN0aW9uXCI7XG5cbiAgICAvLyBJbmhlcml0IGZyb20gJ3N1YnNjcmliYWJsZSdcbiAgICBpZiAoIWtvLnV0aWxzLmNhblNldFByb3RvdHlwZSkge1xuICAgICAgICAvLyAnc3Vic2NyaWJhYmxlJyB3b24ndCBiZSBvbiB0aGUgcHJvdG90eXBlIGNoYWluIHVubGVzcyB3ZSBwdXQgaXQgdGhlcmUgZGlyZWN0bHlcbiAgICAgICAga28udXRpbHMuZXh0ZW5kKGNvbXB1dGVkT2JzZXJ2YWJsZSwga28uc3Vic2NyaWJhYmxlWydmbiddKTtcbiAgICB9XG4gICAga28uc3Vic2NyaWJhYmxlWydmbiddLmluaXQoY29tcHV0ZWRPYnNlcnZhYmxlKTtcblxuICAgIC8vIEluaGVyaXQgZnJvbSAnY29tcHV0ZWQnXG4gICAga28udXRpbHMuc2V0UHJvdG90eXBlT2ZPckV4dGVuZChjb21wdXRlZE9ic2VydmFibGUsIGNvbXB1dGVkRm4pO1xuXG4gICAgaWYgKG9wdGlvbnNbJ3B1cmUnXSkge1xuICAgICAgICBzdGF0ZS5wdXJlID0gdHJ1ZTtcbiAgICAgICAgc3RhdGUuaXNTbGVlcGluZyA9IHRydWU7ICAgICAvLyBTdGFydHMgb2ZmIHNsZWVwaW5nOyB3aWxsIGF3YWtlIG9uIHRoZSBmaXJzdCBzdWJzY3JpcHRpb25cbiAgICAgICAga28udXRpbHMuZXh0ZW5kKGNvbXB1dGVkT2JzZXJ2YWJsZSwgcHVyZUNvbXB1dGVkT3ZlcnJpZGVzKTtcbiAgICB9IGVsc2UgaWYgKG9wdGlvbnNbJ2RlZmVyRXZhbHVhdGlvbiddKSB7XG4gICAgICAgIGtvLnV0aWxzLmV4dGVuZChjb21wdXRlZE9ic2VydmFibGUsIGRlZmVyRXZhbHVhdGlvbk92ZXJyaWRlcyk7XG4gICAgfVxuXG4gICAgaWYgKGtvLm9wdGlvbnNbJ2RlZmVyVXBkYXRlcyddKSB7XG4gICAgICAgIGtvLmV4dGVuZGVyc1snZGVmZXJyZWQnXShjb21wdXRlZE9ic2VydmFibGUsIHRydWUpO1xuICAgIH1cblxuICAgIGlmIChERUJVRykge1xuICAgICAgICAvLyAjMTczMSAtIEFpZCBkZWJ1Z2dpbmcgYnkgZXhwb3NpbmcgdGhlIGNvbXB1dGVkJ3Mgb3B0aW9uc1xuICAgICAgICBjb21wdXRlZE9ic2VydmFibGVbXCJfb3B0aW9uc1wiXSA9IG9wdGlvbnM7XG4gICAgfVxuXG4gICAgaWYgKHN0YXRlLmRpc3Bvc2VXaGVuTm9kZUlzUmVtb3ZlZCkge1xuICAgICAgICAvLyBTaW5jZSB0aGlzIGNvbXB1dGVkIGlzIGFzc29jaWF0ZWQgd2l0aCBhIERPTSBub2RlLCBhbmQgd2UgZG9uJ3Qgd2FudCB0byBkaXNwb3NlIHRoZSBjb21wdXRlZFxuICAgICAgICAvLyB1bnRpbCB0aGUgRE9NIG5vZGUgaXMgKnJlbW92ZWQqIGZyb20gdGhlIGRvY3VtZW50IChhcyBvcHBvc2VkIHRvIG5ldmVyIGhhdmluZyBiZWVuIGluIHRoZSBkb2N1bWVudCksXG4gICAgICAgIC8vIHdlJ2xsIHByZXZlbnQgZGlzcG9zYWwgdW50aWwgXCJkaXNwb3NlV2hlblwiIGZpcnN0IHJldHVybnMgZmFsc2UuXG4gICAgICAgIHN0YXRlLnN1cHByZXNzRGlzcG9zYWxVbnRpbERpc3Bvc2VXaGVuUmV0dXJuc0ZhbHNlID0gdHJ1ZTtcblxuICAgICAgICAvLyBkaXNwb3NlV2hlbk5vZGVJc1JlbW92ZWQ6IHRydWUgY2FuIGJlIHVzZWQgdG8gb3B0IGludG8gdGhlIFwib25seSBkaXNwb3NlIGFmdGVyIGZpcnN0IGZhbHNlIHJlc3VsdFwiXG4gICAgICAgIC8vIGJlaGF2aW91ciBldmVuIGlmIHRoZXJlJ3Mgbm8gc3BlY2lmaWMgbm9kZSB0byB3YXRjaC4gSW4gdGhhdCBjYXNlLCBjbGVhciB0aGUgb3B0aW9uIHNvIHdlIGRvbid0IHRyeVxuICAgICAgICAvLyB0byB3YXRjaCBmb3IgYSBub24tbm9kZSdzIGRpc3Bvc2FsLiBUaGlzIHRlY2huaXF1ZSBpcyBpbnRlbmRlZCBmb3IgS08ncyBpbnRlcm5hbCB1c2Ugb25seSBhbmQgc2hvdWxkbid0XG4gICAgICAgIC8vIGJlIGRvY3VtZW50ZWQgb3IgdXNlZCBieSBhcHBsaWNhdGlvbiBjb2RlLCBhcyBpdCdzIGxpa2VseSB0byBjaGFuZ2UgaW4gYSBmdXR1cmUgdmVyc2lvbiBvZiBLTy5cbiAgICAgICAgaWYgKCFzdGF0ZS5kaXNwb3NlV2hlbk5vZGVJc1JlbW92ZWQubm9kZVR5cGUpIHtcbiAgICAgICAgICAgIHN0YXRlLmRpc3Bvc2VXaGVuTm9kZUlzUmVtb3ZlZCA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBFdmFsdWF0ZSwgdW5sZXNzIHNsZWVwaW5nIG9yIGRlZmVyRXZhbHVhdGlvbiBpcyB0cnVlXG4gICAgaWYgKCFzdGF0ZS5pc1NsZWVwaW5nICYmICFvcHRpb25zWydkZWZlckV2YWx1YXRpb24nXSkge1xuICAgICAgICBjb21wdXRlZE9ic2VydmFibGUuZXZhbHVhdGVJbW1lZGlhdGUoKTtcbiAgICB9XG5cbiAgICAvLyBBdHRhY2ggYSBET00gbm9kZSBkaXNwb3NhbCBjYWxsYmFjayBzbyB0aGF0IHRoZSBjb21wdXRlZCB3aWxsIGJlIHByb2FjdGl2ZWx5IGRpc3Bvc2VkIGFzIHNvb24gYXMgdGhlIG5vZGUgaXNcbiAgICAvLyByZW1vdmVkIHVzaW5nIGtvLnJlbW92ZU5vZGUuIEJ1dCBza2lwIGlmIGlzQWN0aXZlIGlzIGZhbHNlICh0aGVyZSB3aWxsIG5ldmVyIGJlIGFueSBkZXBlbmRlbmNpZXMgdG8gZGlzcG9zZSkuXG4gICAgaWYgKHN0YXRlLmRpc3Bvc2VXaGVuTm9kZUlzUmVtb3ZlZCAmJiBjb21wdXRlZE9ic2VydmFibGUuaXNBY3RpdmUoKSkge1xuICAgICAgICBrby51dGlscy5kb21Ob2RlRGlzcG9zYWwuYWRkRGlzcG9zZUNhbGxiYWNrKHN0YXRlLmRpc3Bvc2VXaGVuTm9kZUlzUmVtb3ZlZCwgc3RhdGUuZG9tTm9kZURpc3Bvc2FsQ2FsbGJhY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBjb21wdXRlZE9ic2VydmFibGUuZGlzcG9zZSgpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gY29tcHV0ZWRPYnNlcnZhYmxlO1xufTtcblxuLy8gVXRpbGl0eSBmdW5jdGlvbiB0aGF0IGRpc3Bvc2VzIGEgZ2l2ZW4gZGVwZW5kZW5jeVRyYWNraW5nIGVudHJ5XG5mdW5jdGlvbiBjb21wdXRlZERpc3Bvc2VEZXBlbmRlbmN5Q2FsbGJhY2soaWQsIGVudHJ5VG9EaXNwb3NlKSB7XG4gICAgaWYgKGVudHJ5VG9EaXNwb3NlICE9PSBudWxsICYmIGVudHJ5VG9EaXNwb3NlLmRpc3Bvc2UpIHtcbiAgICAgICAgZW50cnlUb0Rpc3Bvc2UuZGlzcG9zZSgpO1xuICAgIH1cbn1cblxuLy8gVGhpcyBmdW5jdGlvbiBnZXRzIGNhbGxlZCBlYWNoIHRpbWUgYSBkZXBlbmRlbmN5IGlzIGRldGVjdGVkIHdoaWxlIGV2YWx1YXRpbmcgYSBjb21wdXRlZC5cbi8vIEl0J3MgZmFjdG9yZWQgb3V0IGFzIGEgc2hhcmVkIGZ1bmN0aW9uIHRvIGF2b2lkIGNyZWF0aW5nIHVubmVjZXNzYXJ5IGZ1bmN0aW9uIGluc3RhbmNlcyBkdXJpbmcgZXZhbHVhdGlvbi5cbmZ1bmN0aW9uIGNvbXB1dGVkQmVnaW5EZXBlbmRlbmN5RGV0ZWN0aW9uQ2FsbGJhY2soc3Vic2NyaWJhYmxlLCBpZCkge1xuICAgIHZhciBjb21wdXRlZE9ic2VydmFibGUgPSB0aGlzLmNvbXB1dGVkT2JzZXJ2YWJsZSxcbiAgICAgICAgc3RhdGUgPSBjb21wdXRlZE9ic2VydmFibGVbY29tcHV0ZWRTdGF0ZV07XG4gICAgaWYgKCFzdGF0ZS5pc0Rpc3Bvc2VkKSB7XG4gICAgICAgIGlmICh0aGlzLmRpc3Bvc2FsQ291bnQgJiYgdGhpcy5kaXNwb3NhbENhbmRpZGF0ZXNbaWRdKSB7XG4gICAgICAgICAgICAvLyBEb24ndCB3YW50IHRvIGRpc3Bvc2UgdGhpcyBzdWJzY3JpcHRpb24sIGFzIGl0J3Mgc3RpbGwgYmVpbmcgdXNlZFxuICAgICAgICAgICAgY29tcHV0ZWRPYnNlcnZhYmxlLmFkZERlcGVuZGVuY3lUcmFja2luZyhpZCwgc3Vic2NyaWJhYmxlLCB0aGlzLmRpc3Bvc2FsQ2FuZGlkYXRlc1tpZF0pO1xuICAgICAgICAgICAgdGhpcy5kaXNwb3NhbENhbmRpZGF0ZXNbaWRdID0gbnVsbDsgLy8gTm8gbmVlZCB0byBhY3R1YWxseSBkZWxldGUgdGhlIHByb3BlcnR5IC0gZGlzcG9zYWxDYW5kaWRhdGVzIGlzIGEgdHJhbnNpZW50IG9iamVjdCBhbnl3YXlcbiAgICAgICAgICAgIC0tdGhpcy5kaXNwb3NhbENvdW50O1xuICAgICAgICB9IGVsc2UgaWYgKCFzdGF0ZS5kZXBlbmRlbmN5VHJhY2tpbmdbaWRdKSB7XG4gICAgICAgICAgICAvLyBCcmFuZCBuZXcgc3Vic2NyaXB0aW9uIC0gYWRkIGl0XG4gICAgICAgICAgICBjb21wdXRlZE9ic2VydmFibGUuYWRkRGVwZW5kZW5jeVRyYWNraW5nKGlkLCBzdWJzY3JpYmFibGUsIHN0YXRlLmlzU2xlZXBpbmcgPyB7IF90YXJnZXQ6IHN1YnNjcmliYWJsZSB9IDogY29tcHV0ZWRPYnNlcnZhYmxlLnN1YnNjcmliZVRvRGVwZW5kZW5jeShzdWJzY3JpYmFibGUpKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxudmFyIGNvbXB1dGVkRm4gPSB7XG4gICAgXCJlcXVhbGl0eUNvbXBhcmVyXCI6IHZhbHVlc0FyZVByaW1pdGl2ZUFuZEVxdWFsLFxuICAgIGdldERlcGVuZGVuY2llc0NvdW50OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzW2NvbXB1dGVkU3RhdGVdLmRlcGVuZGVuY2llc0NvdW50O1xuICAgIH0sXG4gICAgYWRkRGVwZW5kZW5jeVRyYWNraW5nOiBmdW5jdGlvbiAoaWQsIHRhcmdldCwgdHJhY2tpbmdPYmopIHtcbiAgICAgICAgaWYgKHRoaXNbY29tcHV0ZWRTdGF0ZV0ucHVyZSAmJiB0YXJnZXQgPT09IHRoaXMpIHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKFwiQSAncHVyZScgY29tcHV0ZWQgbXVzdCBub3QgYmUgY2FsbGVkIHJlY3Vyc2l2ZWx5XCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpc1tjb21wdXRlZFN0YXRlXS5kZXBlbmRlbmN5VHJhY2tpbmdbaWRdID0gdHJhY2tpbmdPYmo7XG4gICAgICAgIHRyYWNraW5nT2JqLl9vcmRlciA9IHRoaXNbY29tcHV0ZWRTdGF0ZV0uZGVwZW5kZW5jaWVzQ291bnQrKztcbiAgICAgICAgdHJhY2tpbmdPYmouX3ZlcnNpb24gPSB0YXJnZXQuZ2V0VmVyc2lvbigpO1xuICAgIH0sXG4gICAgaGF2ZURlcGVuZGVuY2llc0NoYW5nZWQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGlkLCBkZXBlbmRlbmN5LCBkZXBlbmRlbmN5VHJhY2tpbmcgPSB0aGlzW2NvbXB1dGVkU3RhdGVdLmRlcGVuZGVuY3lUcmFja2luZztcbiAgICAgICAgZm9yIChpZCBpbiBkZXBlbmRlbmN5VHJhY2tpbmcpIHtcbiAgICAgICAgICAgIGlmIChkZXBlbmRlbmN5VHJhY2tpbmcuaGFzT3duUHJvcGVydHkoaWQpKSB7XG4gICAgICAgICAgICAgICAgZGVwZW5kZW5jeSA9IGRlcGVuZGVuY3lUcmFja2luZ1tpZF07XG4gICAgICAgICAgICAgICAgaWYgKGRlcGVuZGVuY3kuX3RhcmdldC5oYXNDaGFuZ2VkKGRlcGVuZGVuY3kuX3ZlcnNpb24pKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG4gICAgbWFya0RpcnR5OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIFByb2Nlc3MgXCJkaXJ0eVwiIGV2ZW50cyBpZiB3ZSBjYW4gaGFuZGxlIGRlbGF5ZWQgbm90aWZpY2F0aW9uc1xuICAgICAgICBpZiAodGhpcy5fZXZhbERlbGF5ZWQgJiYgIXRoaXNbY29tcHV0ZWRTdGF0ZV0uaXNCZWluZ0V2YWx1YXRlZCkge1xuICAgICAgICAgICAgdGhpcy5fZXZhbERlbGF5ZWQoKTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgaXNBY3RpdmU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXNbY29tcHV0ZWRTdGF0ZV0uaXNTdGFsZSB8fCB0aGlzW2NvbXB1dGVkU3RhdGVdLmRlcGVuZGVuY2llc0NvdW50ID4gMDtcbiAgICB9LFxuICAgIHJlc3BvbmRUb0NoYW5nZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBJZ25vcmUgXCJjaGFuZ2VcIiBldmVudHMgaWYgd2UndmUgYWxyZWFkeSBzY2hlZHVsZWQgYSBkZWxheWVkIG5vdGlmaWNhdGlvblxuICAgICAgICBpZiAoIXRoaXMuX25vdGlmaWNhdGlvbklzUGVuZGluZykge1xuICAgICAgICAgICAgdGhpcy5ldmFsdWF0ZVBvc3NpYmx5QXN5bmMoKTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgc3Vic2NyaWJlVG9EZXBlbmRlbmN5OiBmdW5jdGlvbiAodGFyZ2V0KSB7XG4gICAgICAgIGlmICh0YXJnZXQuX2RlZmVyVXBkYXRlcyAmJiAhdGhpc1tjb21wdXRlZFN0YXRlXS5kaXNwb3NlV2hlbk5vZGVJc1JlbW92ZWQpIHtcbiAgICAgICAgICAgIHZhciBkaXJ0eVN1YiA9IHRhcmdldC5zdWJzY3JpYmUodGhpcy5tYXJrRGlydHksIHRoaXMsICdkaXJ0eScpLFxuICAgICAgICAgICAgICAgIGNoYW5nZVN1YiA9IHRhcmdldC5zdWJzY3JpYmUodGhpcy5yZXNwb25kVG9DaGFuZ2UsIHRoaXMpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBfdGFyZ2V0OiB0YXJnZXQsXG4gICAgICAgICAgICAgICAgZGlzcG9zZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBkaXJ0eVN1Yi5kaXNwb3NlKCk7XG4gICAgICAgICAgICAgICAgICAgIGNoYW5nZVN1Yi5kaXNwb3NlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0YXJnZXQuc3Vic2NyaWJlKHRoaXMuZXZhbHVhdGVQb3NzaWJseUFzeW5jLCB0aGlzKTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgZXZhbHVhdGVQb3NzaWJseUFzeW5jOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBjb21wdXRlZE9ic2VydmFibGUgPSB0aGlzLFxuICAgICAgICAgICAgdGhyb3R0bGVFdmFsdWF0aW9uVGltZW91dCA9IGNvbXB1dGVkT2JzZXJ2YWJsZVsndGhyb3R0bGVFdmFsdWF0aW9uJ107XG4gICAgICAgIGlmICh0aHJvdHRsZUV2YWx1YXRpb25UaW1lb3V0ICYmIHRocm90dGxlRXZhbHVhdGlvblRpbWVvdXQgPj0gMCkge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXNbY29tcHV0ZWRTdGF0ZV0uZXZhbHVhdGlvblRpbWVvdXRJbnN0YW5jZSk7XG4gICAgICAgICAgICB0aGlzW2NvbXB1dGVkU3RhdGVdLmV2YWx1YXRpb25UaW1lb3V0SW5zdGFuY2UgPSBrby51dGlscy5zZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBjb21wdXRlZE9ic2VydmFibGUuZXZhbHVhdGVJbW1lZGlhdGUodHJ1ZSAvKm5vdGlmeUNoYW5nZSovKTtcbiAgICAgICAgICAgIH0sIHRocm90dGxlRXZhbHVhdGlvblRpbWVvdXQpO1xuICAgICAgICB9IGVsc2UgaWYgKGNvbXB1dGVkT2JzZXJ2YWJsZS5fZXZhbERlbGF5ZWQpIHtcbiAgICAgICAgICAgIGNvbXB1dGVkT2JzZXJ2YWJsZS5fZXZhbERlbGF5ZWQoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbXB1dGVkT2JzZXJ2YWJsZS5ldmFsdWF0ZUltbWVkaWF0ZSh0cnVlIC8qbm90aWZ5Q2hhbmdlKi8pO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBldmFsdWF0ZUltbWVkaWF0ZTogZnVuY3Rpb24gKG5vdGlmeUNoYW5nZSkge1xuICAgICAgICB2YXIgY29tcHV0ZWRPYnNlcnZhYmxlID0gdGhpcyxcbiAgICAgICAgICAgIHN0YXRlID0gY29tcHV0ZWRPYnNlcnZhYmxlW2NvbXB1dGVkU3RhdGVdLFxuICAgICAgICAgICAgZGlzcG9zZVdoZW4gPSBzdGF0ZS5kaXNwb3NlV2hlbixcbiAgICAgICAgICAgIGNoYW5nZWQgPSBmYWxzZTtcblxuICAgICAgICBpZiAoc3RhdGUuaXNCZWluZ0V2YWx1YXRlZCkge1xuICAgICAgICAgICAgLy8gSWYgdGhlIGV2YWx1YXRpb24gb2YgYSBrby5jb21wdXRlZCBjYXVzZXMgc2lkZSBlZmZlY3RzLCBpdCdzIHBvc3NpYmxlIHRoYXQgaXQgd2lsbCB0cmlnZ2VyIGl0cyBvd24gcmUtZXZhbHVhdGlvbi5cbiAgICAgICAgICAgIC8vIFRoaXMgaXMgbm90IGRlc2lyYWJsZSAoaXQncyBoYXJkIGZvciBhIGRldmVsb3BlciB0byByZWFsaXNlIGEgY2hhaW4gb2YgZGVwZW5kZW5jaWVzIG1pZ2h0IGNhdXNlIHRoaXMsIGFuZCB0aGV5IGFsbW9zdFxuICAgICAgICAgICAgLy8gY2VydGFpbmx5IGRpZG4ndCBpbnRlbmQgaW5maW5pdGUgcmUtZXZhbHVhdGlvbnMpLiBTbywgZm9yIHByZWRpY3RhYmlsaXR5LCB3ZSBzaW1wbHkgcHJldmVudCBrby5jb21wdXRlZHMgZnJvbSBjYXVzaW5nXG4gICAgICAgICAgICAvLyB0aGVpciBvd24gcmUtZXZhbHVhdGlvbi4gRnVydGhlciBkaXNjdXNzaW9uIGF0IGh0dHBzOi8vZ2l0aHViLmNvbS9TdGV2ZVNhbmRlcnNvbi9rbm9ja291dC9wdWxsLzM4N1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRG8gbm90IGV2YWx1YXRlIChhbmQgcG9zc2libHkgY2FwdHVyZSBuZXcgZGVwZW5kZW5jaWVzKSBpZiBkaXNwb3NlZFxuICAgICAgICBpZiAoc3RhdGUuaXNEaXNwb3NlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHN0YXRlLmRpc3Bvc2VXaGVuTm9kZUlzUmVtb3ZlZCAmJiAha28udXRpbHMuZG9tTm9kZUlzQXR0YWNoZWRUb0RvY3VtZW50KHN0YXRlLmRpc3Bvc2VXaGVuTm9kZUlzUmVtb3ZlZCkgfHwgZGlzcG9zZVdoZW4gJiYgZGlzcG9zZVdoZW4oKSkge1xuICAgICAgICAgICAgLy8gU2VlIGNvbW1lbnQgYWJvdmUgYWJvdXQgc3VwcHJlc3NEaXNwb3NhbFVudGlsRGlzcG9zZVdoZW5SZXR1cm5zRmFsc2VcbiAgICAgICAgICAgIGlmICghc3RhdGUuc3VwcHJlc3NEaXNwb3NhbFVudGlsRGlzcG9zZVdoZW5SZXR1cm5zRmFsc2UpIHtcbiAgICAgICAgICAgICAgICBjb21wdXRlZE9ic2VydmFibGUuZGlzcG9zZSgpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIEl0IGp1c3QgZGlkIHJldHVybiBmYWxzZSwgc28gd2UgY2FuIHN0b3Agc3VwcHJlc3Npbmcgbm93XG4gICAgICAgICAgICBzdGF0ZS5zdXBwcmVzc0Rpc3Bvc2FsVW50aWxEaXNwb3NlV2hlblJldHVybnNGYWxzZSA9IGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgc3RhdGUuaXNCZWluZ0V2YWx1YXRlZCA9IHRydWU7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjaGFuZ2VkID0gdGhpcy5ldmFsdWF0ZUltbWVkaWF0ZV9DYWxsUmVhZFdpdGhEZXBlbmRlbmN5RGV0ZWN0aW9uKG5vdGlmeUNoYW5nZSk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICBzdGF0ZS5pc0JlaW5nRXZhbHVhdGVkID0gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXN0YXRlLmRlcGVuZGVuY2llc0NvdW50KSB7XG4gICAgICAgICAgICBjb21wdXRlZE9ic2VydmFibGUuZGlzcG9zZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNoYW5nZWQ7XG4gICAgfSxcbiAgICBldmFsdWF0ZUltbWVkaWF0ZV9DYWxsUmVhZFdpdGhEZXBlbmRlbmN5RGV0ZWN0aW9uOiBmdW5jdGlvbiAobm90aWZ5Q2hhbmdlKSB7XG4gICAgICAgIC8vIFRoaXMgZnVuY3Rpb24gaXMgcmVhbGx5IGp1c3QgcGFydCBvZiB0aGUgZXZhbHVhdGVJbW1lZGlhdGUgbG9naWMuIFlvdSB3b3VsZCBuZXZlciBjYWxsIGl0IGZyb20gYW55d2hlcmUgZWxzZS5cbiAgICAgICAgLy8gRmFjdG9yaW5nIGl0IG91dCBpbnRvIGEgc2VwYXJhdGUgZnVuY3Rpb24gbWVhbnMgaXQgY2FuIGJlIGluZGVwZW5kZW50IG9mIHRoZSB0cnkvY2F0Y2ggYmxvY2sgaW4gZXZhbHVhdGVJbW1lZGlhdGUsXG4gICAgICAgIC8vIHdoaWNoIGNvbnRyaWJ1dGVzIHRvIHNhdmluZyBhYm91dCA0MCUgb2ZmIHRoZSBDUFUgb3ZlcmhlYWQgb2YgY29tcHV0ZWQgZXZhbHVhdGlvbiAob24gVjggYXQgbGVhc3QpLlxuXG4gICAgICAgIHZhciBjb21wdXRlZE9ic2VydmFibGUgPSB0aGlzLFxuICAgICAgICAgICAgc3RhdGUgPSBjb21wdXRlZE9ic2VydmFibGVbY29tcHV0ZWRTdGF0ZV0sXG4gICAgICAgICAgICBjaGFuZ2VkID0gZmFsc2U7XG5cbiAgICAgICAgLy8gSW5pdGlhbGx5LCB3ZSBhc3N1bWUgdGhhdCBub25lIG9mIHRoZSBzdWJzY3JpcHRpb25zIGFyZSBzdGlsbCBiZWluZyB1c2VkIChpLmUuLCBhbGwgYXJlIGNhbmRpZGF0ZXMgZm9yIGRpc3Bvc2FsKS5cbiAgICAgICAgLy8gVGhlbiwgZHVyaW5nIGV2YWx1YXRpb24sIHdlIGNyb3NzIG9mZiBhbnkgdGhhdCBhcmUgaW4gZmFjdCBzdGlsbCBiZWluZyB1c2VkLlxuICAgICAgICB2YXIgaXNJbml0aWFsID0gc3RhdGUucHVyZSA/IHVuZGVmaW5lZCA6ICFzdGF0ZS5kZXBlbmRlbmNpZXNDb3VudCwgICAvLyBJZiB3ZSdyZSBldmFsdWF0aW5nIHdoZW4gdGhlcmUgYXJlIG5vIHByZXZpb3VzIGRlcGVuZGVuY2llcywgaXQgbXVzdCBiZSB0aGUgZmlyc3QgdGltZVxuICAgICAgICAgICAgZGVwZW5kZW5jeURldGVjdGlvbkNvbnRleHQgPSB7XG4gICAgICAgICAgICAgICAgY29tcHV0ZWRPYnNlcnZhYmxlOiBjb21wdXRlZE9ic2VydmFibGUsXG4gICAgICAgICAgICAgICAgZGlzcG9zYWxDYW5kaWRhdGVzOiBzdGF0ZS5kZXBlbmRlbmN5VHJhY2tpbmcsXG4gICAgICAgICAgICAgICAgZGlzcG9zYWxDb3VudDogc3RhdGUuZGVwZW5kZW5jaWVzQ291bnRcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAga28uZGVwZW5kZW5jeURldGVjdGlvbi5iZWdpbih7XG4gICAgICAgICAgICBjYWxsYmFja1RhcmdldDogZGVwZW5kZW5jeURldGVjdGlvbkNvbnRleHQsXG4gICAgICAgICAgICBjYWxsYmFjazogY29tcHV0ZWRCZWdpbkRlcGVuZGVuY3lEZXRlY3Rpb25DYWxsYmFjayxcbiAgICAgICAgICAgIGNvbXB1dGVkOiBjb21wdXRlZE9ic2VydmFibGUsXG4gICAgICAgICAgICBpc0luaXRpYWw6IGlzSW5pdGlhbFxuICAgICAgICB9KTtcblxuICAgICAgICBzdGF0ZS5kZXBlbmRlbmN5VHJhY2tpbmcgPSB7fTtcbiAgICAgICAgc3RhdGUuZGVwZW5kZW5jaWVzQ291bnQgPSAwO1xuXG4gICAgICAgIHZhciBuZXdWYWx1ZSA9IHRoaXMuZXZhbHVhdGVJbW1lZGlhdGVfQ2FsbFJlYWRUaGVuRW5kRGVwZW5kZW5jeURldGVjdGlvbihzdGF0ZSwgZGVwZW5kZW5jeURldGVjdGlvbkNvbnRleHQpO1xuXG4gICAgICAgIGlmIChjb21wdXRlZE9ic2VydmFibGUuaXNEaWZmZXJlbnQoc3RhdGUubGF0ZXN0VmFsdWUsIG5ld1ZhbHVlKSkge1xuICAgICAgICAgICAgaWYgKCFzdGF0ZS5pc1NsZWVwaW5nKSB7XG4gICAgICAgICAgICAgICAgY29tcHV0ZWRPYnNlcnZhYmxlW1wibm90aWZ5U3Vic2NyaWJlcnNcIl0oc3RhdGUubGF0ZXN0VmFsdWUsIFwiYmVmb3JlQ2hhbmdlXCIpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzdGF0ZS5sYXRlc3RWYWx1ZSA9IG5ld1ZhbHVlO1xuICAgICAgICAgICAgaWYgKERFQlVHKSBjb21wdXRlZE9ic2VydmFibGUuX2xhdGVzdFZhbHVlID0gbmV3VmFsdWU7XG5cbiAgICAgICAgICAgIGlmIChzdGF0ZS5pc1NsZWVwaW5nKSB7XG4gICAgICAgICAgICAgICAgY29tcHV0ZWRPYnNlcnZhYmxlLnVwZGF0ZVZlcnNpb24oKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobm90aWZ5Q2hhbmdlKSB7XG4gICAgICAgICAgICAgICAgY29tcHV0ZWRPYnNlcnZhYmxlW1wibm90aWZ5U3Vic2NyaWJlcnNcIl0oc3RhdGUubGF0ZXN0VmFsdWUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc0luaXRpYWwpIHtcbiAgICAgICAgICAgIGNvbXB1dGVkT2JzZXJ2YWJsZVtcIm5vdGlmeVN1YnNjcmliZXJzXCJdKHN0YXRlLmxhdGVzdFZhbHVlLCBcImF3YWtlXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNoYW5nZWQ7XG4gICAgfSxcbiAgICBldmFsdWF0ZUltbWVkaWF0ZV9DYWxsUmVhZFRoZW5FbmREZXBlbmRlbmN5RGV0ZWN0aW9uOiBmdW5jdGlvbiAoc3RhdGUsIGRlcGVuZGVuY3lEZXRlY3Rpb25Db250ZXh0KSB7XG4gICAgICAgIC8vIFRoaXMgZnVuY3Rpb24gaXMgcmVhbGx5IHBhcnQgb2YgdGhlIGV2YWx1YXRlSW1tZWRpYXRlX0NhbGxSZWFkV2l0aERlcGVuZGVuY3lEZXRlY3Rpb24gbG9naWMuXG4gICAgICAgIC8vIFlvdSdkIG5ldmVyIGNhbGwgaXQgZnJvbSBhbnl3aGVyZSBlbHNlLiBGYWN0b3JpbmcgaXQgb3V0IG1lYW5zIHRoYXQgZXZhbHVhdGVJbW1lZGlhdGVfQ2FsbFJlYWRXaXRoRGVwZW5kZW5jeURldGVjdGlvblxuICAgICAgICAvLyBjYW4gYmUgaW5kZXBlbmRlbnQgb2YgdHJ5L2ZpbmFsbHkgYmxvY2tzLCB3aGljaCBjb250cmlidXRlcyB0byBzYXZpbmcgYWJvdXQgNDAlIG9mZiB0aGUgQ1BVXG4gICAgICAgIC8vIG92ZXJoZWFkIG9mIGNvbXB1dGVkIGV2YWx1YXRpb24gKG9uIFY4IGF0IGxlYXN0KS5cblxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdmFyIHJlYWRGdW5jdGlvbiA9IHN0YXRlLnJlYWRGdW5jdGlvbjtcbiAgICAgICAgICAgIHJldHVybiBzdGF0ZS5ldmFsdWF0b3JGdW5jdGlvblRhcmdldCA/IHJlYWRGdW5jdGlvbi5jYWxsKHN0YXRlLmV2YWx1YXRvckZ1bmN0aW9uVGFyZ2V0KSA6IHJlYWRGdW5jdGlvbigpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAga28uZGVwZW5kZW5jeURldGVjdGlvbi5lbmQoKTtcblxuICAgICAgICAgICAgLy8gRm9yIGVhY2ggc3Vic2NyaXB0aW9uIG5vIGxvbmdlciBiZWluZyB1c2VkLCByZW1vdmUgaXQgZnJvbSB0aGUgYWN0aXZlIHN1YnNjcmlwdGlvbnMgbGlzdCBhbmQgZGlzcG9zZSBpdFxuICAgICAgICAgICAgaWYgKGRlcGVuZGVuY3lEZXRlY3Rpb25Db250ZXh0LmRpc3Bvc2FsQ291bnQgJiYgIXN0YXRlLmlzU2xlZXBpbmcpIHtcbiAgICAgICAgICAgICAgICBrby51dGlscy5vYmplY3RGb3JFYWNoKGRlcGVuZGVuY3lEZXRlY3Rpb25Db250ZXh0LmRpc3Bvc2FsQ2FuZGlkYXRlcywgY29tcHV0ZWREaXNwb3NlRGVwZW5kZW5jeUNhbGxiYWNrKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgc3RhdGUuaXNTdGFsZSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBwZWVrOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIFBlZWsgd29uJ3QgcmUtZXZhbHVhdGUsIGV4Y2VwdCB3aGlsZSB0aGUgY29tcHV0ZWQgaXMgc2xlZXBpbmcgb3IgdG8gZ2V0IHRoZSBpbml0aWFsIHZhbHVlIHdoZW4gXCJkZWZlckV2YWx1YXRpb25cIiBpcyBzZXQuXG4gICAgICAgIHZhciBzdGF0ZSA9IHRoaXNbY29tcHV0ZWRTdGF0ZV07XG4gICAgICAgIGlmICgoc3RhdGUuaXNTdGFsZSAmJiAhc3RhdGUuZGVwZW5kZW5jaWVzQ291bnQpIHx8IChzdGF0ZS5pc1NsZWVwaW5nICYmIHRoaXMuaGF2ZURlcGVuZGVuY2llc0NoYW5nZWQoKSkpIHtcbiAgICAgICAgICAgIHRoaXMuZXZhbHVhdGVJbW1lZGlhdGUoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3RhdGUubGF0ZXN0VmFsdWU7XG4gICAgfSxcbiAgICBsaW1pdDogZnVuY3Rpb24gKGxpbWl0RnVuY3Rpb24pIHtcbiAgICAgICAgLy8gT3ZlcnJpZGUgdGhlIGxpbWl0IGZ1bmN0aW9uIHdpdGggb25lIHRoYXQgZGVsYXlzIGV2YWx1YXRpb24gYXMgd2VsbFxuICAgICAgICBrby5zdWJzY3JpYmFibGVbJ2ZuJ10ubGltaXQuY2FsbCh0aGlzLCBsaW1pdEZ1bmN0aW9uKTtcbiAgICAgICAgdGhpcy5fZXZhbERlbGF5ZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLl9saW1pdEJlZm9yZUNoYW5nZSh0aGlzW2NvbXB1dGVkU3RhdGVdLmxhdGVzdFZhbHVlKTtcblxuICAgICAgICAgICAgdGhpc1tjb21wdXRlZFN0YXRlXS5pc1N0YWxlID0gdHJ1ZTsgLy8gTWFyayBhcyBkaXJ0eVxuXG4gICAgICAgICAgICAvLyBQYXNzIHRoZSBvYnNlcnZhYmxlIHRvIHRoZSBcImxpbWl0XCIgY29kZSwgd2hpY2ggd2lsbCBhY2Nlc3MgaXQgd2hlblxuICAgICAgICAgICAgLy8gaXQncyB0aW1lIHRvIGRvIHRoZSBub3RpZmljYXRpb24uXG4gICAgICAgICAgICB0aGlzLl9saW1pdENoYW5nZSh0aGlzKTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgZGlzcG9zZTogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgc3RhdGUgPSB0aGlzW2NvbXB1dGVkU3RhdGVdO1xuICAgICAgICBpZiAoIXN0YXRlLmlzU2xlZXBpbmcgJiYgc3RhdGUuZGVwZW5kZW5jeVRyYWNraW5nKSB7XG4gICAgICAgICAgICBrby51dGlscy5vYmplY3RGb3JFYWNoKHN0YXRlLmRlcGVuZGVuY3lUcmFja2luZywgZnVuY3Rpb24gKGlkLCBkZXBlbmRlbmN5KSB7XG4gICAgICAgICAgICAgICAgaWYgKGRlcGVuZGVuY3kuZGlzcG9zZSlcbiAgICAgICAgICAgICAgICAgICAgZGVwZW5kZW5jeS5kaXNwb3NlKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhdGUuZGlzcG9zZVdoZW5Ob2RlSXNSZW1vdmVkICYmIHN0YXRlLmRvbU5vZGVEaXNwb3NhbENhbGxiYWNrKSB7XG4gICAgICAgICAgICBrby51dGlscy5kb21Ob2RlRGlzcG9zYWwucmVtb3ZlRGlzcG9zZUNhbGxiYWNrKHN0YXRlLmRpc3Bvc2VXaGVuTm9kZUlzUmVtb3ZlZCwgc3RhdGUuZG9tTm9kZURpc3Bvc2FsQ2FsbGJhY2spO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRlLmRlcGVuZGVuY3lUcmFja2luZyA9IG51bGw7XG4gICAgICAgIHN0YXRlLmRlcGVuZGVuY2llc0NvdW50ID0gMDtcbiAgICAgICAgc3RhdGUuaXNEaXNwb3NlZCA9IHRydWU7XG4gICAgICAgIHN0YXRlLmlzU3RhbGUgPSBmYWxzZTtcbiAgICAgICAgc3RhdGUuaXNTbGVlcGluZyA9IGZhbHNlO1xuICAgICAgICBzdGF0ZS5kaXNwb3NlV2hlbk5vZGVJc1JlbW92ZWQgPSBudWxsO1xuICAgIH1cbn07XG5cbnZhciBwdXJlQ29tcHV0ZWRPdmVycmlkZXMgPSB7XG4gICAgYmVmb3JlU3Vic2NyaXB0aW9uQWRkOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgLy8gSWYgYXNsZWVwLCB3YWtlIHVwIHRoZSBjb21wdXRlZCBieSBzdWJzY3JpYmluZyB0byBhbnkgZGVwZW5kZW5jaWVzLlxuICAgICAgICB2YXIgY29tcHV0ZWRPYnNlcnZhYmxlID0gdGhpcyxcbiAgICAgICAgICAgIHN0YXRlID0gY29tcHV0ZWRPYnNlcnZhYmxlW2NvbXB1dGVkU3RhdGVdO1xuICAgICAgICBpZiAoIXN0YXRlLmlzRGlzcG9zZWQgJiYgc3RhdGUuaXNTbGVlcGluZyAmJiBldmVudCA9PSAnY2hhbmdlJykge1xuICAgICAgICAgICAgc3RhdGUuaXNTbGVlcGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKHN0YXRlLmlzU3RhbGUgfHwgY29tcHV0ZWRPYnNlcnZhYmxlLmhhdmVEZXBlbmRlbmNpZXNDaGFuZ2VkKCkpIHtcbiAgICAgICAgICAgICAgICBzdGF0ZS5kZXBlbmRlbmN5VHJhY2tpbmcgPSBudWxsO1xuICAgICAgICAgICAgICAgIHN0YXRlLmRlcGVuZGVuY2llc0NvdW50ID0gMDtcbiAgICAgICAgICAgICAgICBzdGF0ZS5pc1N0YWxlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBpZiAoY29tcHV0ZWRPYnNlcnZhYmxlLmV2YWx1YXRlSW1tZWRpYXRlKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29tcHV0ZWRPYnNlcnZhYmxlLnVwZGF0ZVZlcnNpb24oKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIEZpcnN0IHB1dCB0aGUgZGVwZW5kZW5jaWVzIGluIG9yZGVyXG4gICAgICAgICAgICAgICAgdmFyIGRlcGVuZGVjaWVzT3JkZXIgPSBbXTtcbiAgICAgICAgICAgICAgICBrby51dGlscy5vYmplY3RGb3JFYWNoKHN0YXRlLmRlcGVuZGVuY3lUcmFja2luZywgZnVuY3Rpb24gKGlkLCBkZXBlbmRlbmN5KSB7XG4gICAgICAgICAgICAgICAgICAgIGRlcGVuZGVjaWVzT3JkZXJbZGVwZW5kZW5jeS5fb3JkZXJdID0gaWQ7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgLy8gTmV4dCwgc3Vic2NyaWJlIHRvIGVhY2ggb25lXG4gICAgICAgICAgICAgICAga28udXRpbHMuYXJyYXlGb3JFYWNoKGRlcGVuZGVjaWVzT3JkZXIsIGZ1bmN0aW9uIChpZCwgb3JkZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRlcGVuZGVuY3kgPSBzdGF0ZS5kZXBlbmRlbmN5VHJhY2tpbmdbaWRdLFxuICAgICAgICAgICAgICAgICAgICAgICAgc3Vic2NyaXB0aW9uID0gY29tcHV0ZWRPYnNlcnZhYmxlLnN1YnNjcmliZVRvRGVwZW5kZW5jeShkZXBlbmRlbmN5Ll90YXJnZXQpO1xuICAgICAgICAgICAgICAgICAgICBzdWJzY3JpcHRpb24uX29yZGVyID0gb3JkZXI7XG4gICAgICAgICAgICAgICAgICAgIHN1YnNjcmlwdGlvbi5fdmVyc2lvbiA9IGRlcGVuZGVuY3kuX3ZlcnNpb247XG4gICAgICAgICAgICAgICAgICAgIHN0YXRlLmRlcGVuZGVuY3lUcmFja2luZ1tpZF0gPSBzdWJzY3JpcHRpb247XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXN0YXRlLmlzRGlzcG9zZWQpIHsgICAgIC8vIHRlc3Qgc2luY2UgZXZhbHVhdGluZyBjb3VsZCB0cmlnZ2VyIGRpc3Bvc2FsXG4gICAgICAgICAgICAgICAgY29tcHV0ZWRPYnNlcnZhYmxlW1wibm90aWZ5U3Vic2NyaWJlcnNcIl0oc3RhdGUubGF0ZXN0VmFsdWUsIFwiYXdha2VcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuICAgIGFmdGVyU3Vic2NyaXB0aW9uUmVtb3ZlOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgdmFyIHN0YXRlID0gdGhpc1tjb21wdXRlZFN0YXRlXTtcbiAgICAgICAgaWYgKCFzdGF0ZS5pc0Rpc3Bvc2VkICYmIGV2ZW50ID09ICdjaGFuZ2UnICYmICF0aGlzLmhhc1N1YnNjcmlwdGlvbnNGb3JFdmVudCgnY2hhbmdlJykpIHtcbiAgICAgICAgICAgIGtvLnV0aWxzLm9iamVjdEZvckVhY2goc3RhdGUuZGVwZW5kZW5jeVRyYWNraW5nLCBmdW5jdGlvbiAoaWQsIGRlcGVuZGVuY3kpIHtcbiAgICAgICAgICAgICAgICBpZiAoZGVwZW5kZW5jeS5kaXNwb3NlKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXRlLmRlcGVuZGVuY3lUcmFja2luZ1tpZF0gPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGFyZ2V0OiBkZXBlbmRlbmN5Ll90YXJnZXQsXG4gICAgICAgICAgICAgICAgICAgICAgICBfb3JkZXI6IGRlcGVuZGVuY3kuX29yZGVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgX3ZlcnNpb246IGRlcGVuZGVuY3kuX3ZlcnNpb25cbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgZGVwZW5kZW5jeS5kaXNwb3NlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBzdGF0ZS5pc1NsZWVwaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXNbXCJub3RpZnlTdWJzY3JpYmVyc1wiXSh1bmRlZmluZWQsIFwiYXNsZWVwXCIpO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBnZXRWZXJzaW9uOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIEJlY2F1c2UgYSBwdXJlIGNvbXB1dGVkIGlzIG5vdCBhdXRvbWF0aWNhbGx5IHVwZGF0ZWQgd2hpbGUgaXQgaXMgc2xlZXBpbmcsIHdlIGNhbid0XG4gICAgICAgIC8vIHNpbXBseSByZXR1cm4gdGhlIHZlcnNpb24gbnVtYmVyLiBJbnN0ZWFkLCB3ZSBjaGVjayBpZiBhbnkgb2YgdGhlIGRlcGVuZGVuY2llcyBoYXZlXG4gICAgICAgIC8vIGNoYW5nZWQgYW5kIGNvbmRpdGlvbmFsbHkgcmUtZXZhbHVhdGUgdGhlIGNvbXB1dGVkIG9ic2VydmFibGUuXG4gICAgICAgIHZhciBzdGF0ZSA9IHRoaXNbY29tcHV0ZWRTdGF0ZV07XG4gICAgICAgIGlmIChzdGF0ZS5pc1NsZWVwaW5nICYmIChzdGF0ZS5pc1N0YWxlIHx8IHRoaXMuaGF2ZURlcGVuZGVuY2llc0NoYW5nZWQoKSkpIHtcbiAgICAgICAgICAgIHRoaXMuZXZhbHVhdGVJbW1lZGlhdGUoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ga28uc3Vic2NyaWJhYmxlWydmbiddLmdldFZlcnNpb24uY2FsbCh0aGlzKTtcbiAgICB9XG59O1xuXG52YXIgZGVmZXJFdmFsdWF0aW9uT3ZlcnJpZGVzID0ge1xuICAgIGJlZm9yZVN1YnNjcmlwdGlvbkFkZDogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIC8vIFRoaXMgd2lsbCBmb3JjZSBhIGNvbXB1dGVkIHdpdGggZGVmZXJFdmFsdWF0aW9uIHRvIGV2YWx1YXRlIHdoZW4gdGhlIGZpcnN0IHN1YnNjcmlwdGlvbiBpcyByZWdpc3RlcmVkLlxuICAgICAgICBpZiAoZXZlbnQgPT0gJ2NoYW5nZScgfHwgZXZlbnQgPT0gJ2JlZm9yZUNoYW5nZScpIHtcbiAgICAgICAgICAgIHRoaXMucGVlaygpO1xuICAgICAgICB9XG4gICAgfVxufTtcblxuLy8gTm90ZSB0aGF0IGZvciBicm93c2VycyB0aGF0IGRvbid0IHN1cHBvcnQgcHJvdG8gYXNzaWdubWVudCwgdGhlXG4vLyBpbmhlcml0YW5jZSBjaGFpbiBpcyBjcmVhdGVkIG1hbnVhbGx5IGluIHRoZSBrby5jb21wdXRlZCBjb25zdHJ1Y3RvclxuaWYgKGtvLnV0aWxzLmNhblNldFByb3RvdHlwZSkge1xuICAgIGtvLnV0aWxzLnNldFByb3RvdHlwZU9mKGNvbXB1dGVkRm4sIGtvLnN1YnNjcmliYWJsZVsnZm4nXSk7XG59XG5cbi8vIFNldCB0aGUgcHJvdG8gY2hhaW4gdmFsdWVzIGZvciBrby5oYXNQcm90b3R5cGVcbnZhciBwcm90b1Byb3AgPSBrby5vYnNlcnZhYmxlLnByb3RvUHJvcGVydHk7IC8vID09IFwiX19rb19wcm90b19fXCJcbmtvLmNvbXB1dGVkW3Byb3RvUHJvcF0gPSBrby5vYnNlcnZhYmxlO1xuY29tcHV0ZWRGbltwcm90b1Byb3BdID0ga28uY29tcHV0ZWQ7XG5cbmtvLmlzQ29tcHV0ZWQgPSBmdW5jdGlvbiAoaW5zdGFuY2UpIHtcbiAgICByZXR1cm4ga28uaGFzUHJvdG90eXBlKGluc3RhbmNlLCBrby5jb21wdXRlZCk7XG59O1xuXG5rby5pc1B1cmVDb21wdXRlZCA9IGZ1bmN0aW9uIChpbnN0YW5jZSkge1xuICAgIHJldHVybiBrby5oYXNQcm90b3R5cGUoaW5zdGFuY2UsIGtvLmNvbXB1dGVkKVxuICAgICAgICAmJiBpbnN0YW5jZVtjb21wdXRlZFN0YXRlXSAmJiBpbnN0YW5jZVtjb21wdXRlZFN0YXRlXS5wdXJlO1xufTtcblxua28uZXhwb3J0U3ltYm9sKCdjb21wdXRlZCcsIGtvLmNvbXB1dGVkKTtcbmtvLmV4cG9ydFN5bWJvbCgnZGVwZW5kZW50T2JzZXJ2YWJsZScsIGtvLmNvbXB1dGVkKTsgICAgLy8gZXhwb3J0IGtvLmRlcGVuZGVudE9ic2VydmFibGUgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5ICgxLngpXG5rby5leHBvcnRTeW1ib2woJ2lzQ29tcHV0ZWQnLCBrby5pc0NvbXB1dGVkKTtcbmtvLmV4cG9ydFN5bWJvbCgnaXNQdXJlQ29tcHV0ZWQnLCBrby5pc1B1cmVDb21wdXRlZCk7XG5rby5leHBvcnRTeW1ib2woJ2NvbXB1dGVkLmZuJywgY29tcHV0ZWRGbik7XG5rby5leHBvcnRQcm9wZXJ0eShjb21wdXRlZEZuLCAncGVlaycsIGNvbXB1dGVkRm4ucGVlayk7XG5rby5leHBvcnRQcm9wZXJ0eShjb21wdXRlZEZuLCAnZGlzcG9zZScsIGNvbXB1dGVkRm4uZGlzcG9zZSk7XG5rby5leHBvcnRQcm9wZXJ0eShjb21wdXRlZEZuLCAnaXNBY3RpdmUnLCBjb21wdXRlZEZuLmlzQWN0aXZlKTtcbmtvLmV4cG9ydFByb3BlcnR5KGNvbXB1dGVkRm4sICdnZXREZXBlbmRlbmNpZXNDb3VudCcsIGNvbXB1dGVkRm4uZ2V0RGVwZW5kZW5jaWVzQ291bnQpO1xuXG5rby5wdXJlQ29tcHV0ZWQgPSBmdW5jdGlvbiAoZXZhbHVhdG9yRnVuY3Rpb25Pck9wdGlvbnMsIGV2YWx1YXRvckZ1bmN0aW9uVGFyZ2V0KSB7XG4gICAgaWYgKHR5cGVvZiBldmFsdWF0b3JGdW5jdGlvbk9yT3B0aW9ucyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4ga28uY29tcHV0ZWQoZXZhbHVhdG9yRnVuY3Rpb25Pck9wdGlvbnMsIGV2YWx1YXRvckZ1bmN0aW9uVGFyZ2V0LCB7J3B1cmUnOnRydWV9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBldmFsdWF0b3JGdW5jdGlvbk9yT3B0aW9ucyA9IGtvLnV0aWxzLmV4dGVuZCh7fSwgZXZhbHVhdG9yRnVuY3Rpb25Pck9wdGlvbnMpOyAgIC8vIG1ha2UgYSBjb3B5IG9mIHRoZSBwYXJhbWV0ZXIgb2JqZWN0XG4gICAgICAgIGV2YWx1YXRvckZ1bmN0aW9uT3JPcHRpb25zWydwdXJlJ10gPSB0cnVlO1xuICAgICAgICByZXR1cm4ga28uY29tcHV0ZWQoZXZhbHVhdG9yRnVuY3Rpb25Pck9wdGlvbnMsIGV2YWx1YXRvckZ1bmN0aW9uVGFyZ2V0KTtcbiAgICB9XG59XG5rby5leHBvcnRTeW1ib2woJ3B1cmVDb21wdXRlZCcsIGtvLnB1cmVDb21wdXRlZCk7XG5cbihmdW5jdGlvbigpIHtcbiAgICB2YXIgbWF4TmVzdGVkT2JzZXJ2YWJsZURlcHRoID0gMTA7IC8vIEVzY2FwZSB0aGUgKHVubGlrZWx5KSBwYXRoYWxvZ2ljYWwgY2FzZSB3aGVyZSBhbiBvYnNlcnZhYmxlJ3MgY3VycmVudCB2YWx1ZSBpcyBpdHNlbGYgKG9yIHNpbWlsYXIgcmVmZXJlbmNlIGN5Y2xlKVxuXG4gICAga28udG9KUyA9IGZ1bmN0aW9uKHJvb3RPYmplY3QpIHtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT0gMClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIldoZW4gY2FsbGluZyBrby50b0pTLCBwYXNzIHRoZSBvYmplY3QgeW91IHdhbnQgdG8gY29udmVydC5cIik7XG5cbiAgICAgICAgLy8gV2UganVzdCB1bndyYXAgZXZlcnl0aGluZyBhdCBldmVyeSBsZXZlbCBpbiB0aGUgb2JqZWN0IGdyYXBoXG4gICAgICAgIHJldHVybiBtYXBKc09iamVjdEdyYXBoKHJvb3RPYmplY3QsIGZ1bmN0aW9uKHZhbHVlVG9NYXApIHtcbiAgICAgICAgICAgIC8vIExvb3AgYmVjYXVzZSBhbiBvYnNlcnZhYmxlJ3MgdmFsdWUgbWlnaHQgaW4gdHVybiBiZSBhbm90aGVyIG9ic2VydmFibGUgd3JhcHBlclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGtvLmlzT2JzZXJ2YWJsZSh2YWx1ZVRvTWFwKSAmJiAoaSA8IG1heE5lc3RlZE9ic2VydmFibGVEZXB0aCk7IGkrKylcbiAgICAgICAgICAgICAgICB2YWx1ZVRvTWFwID0gdmFsdWVUb01hcCgpO1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlVG9NYXA7XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICBrby50b0pTT04gPSBmdW5jdGlvbihyb290T2JqZWN0LCByZXBsYWNlciwgc3BhY2UpIHsgICAgIC8vIHJlcGxhY2VyIGFuZCBzcGFjZSBhcmUgb3B0aW9uYWxcbiAgICAgICAgdmFyIHBsYWluSmF2YVNjcmlwdE9iamVjdCA9IGtvLnRvSlMocm9vdE9iamVjdCk7XG4gICAgICAgIHJldHVybiBrby51dGlscy5zdHJpbmdpZnlKc29uKHBsYWluSmF2YVNjcmlwdE9iamVjdCwgcmVwbGFjZXIsIHNwYWNlKTtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gbWFwSnNPYmplY3RHcmFwaChyb290T2JqZWN0LCBtYXBJbnB1dENhbGxiYWNrLCB2aXNpdGVkT2JqZWN0cykge1xuICAgICAgICB2aXNpdGVkT2JqZWN0cyA9IHZpc2l0ZWRPYmplY3RzIHx8IG5ldyBvYmplY3RMb29rdXAoKTtcblxuICAgICAgICByb290T2JqZWN0ID0gbWFwSW5wdXRDYWxsYmFjayhyb290T2JqZWN0KTtcbiAgICAgICAgdmFyIGNhbkhhdmVQcm9wZXJ0aWVzID0gKHR5cGVvZiByb290T2JqZWN0ID09IFwib2JqZWN0XCIpICYmIChyb290T2JqZWN0ICE9PSBudWxsKSAmJiAocm9vdE9iamVjdCAhPT0gdW5kZWZpbmVkKSAmJiAoIShyb290T2JqZWN0IGluc3RhbmNlb2YgUmVnRXhwKSkgJiYgKCEocm9vdE9iamVjdCBpbnN0YW5jZW9mIERhdGUpKSAmJiAoIShyb290T2JqZWN0IGluc3RhbmNlb2YgU3RyaW5nKSkgJiYgKCEocm9vdE9iamVjdCBpbnN0YW5jZW9mIE51bWJlcikpICYmICghKHJvb3RPYmplY3QgaW5zdGFuY2VvZiBCb29sZWFuKSk7XG4gICAgICAgIGlmICghY2FuSGF2ZVByb3BlcnRpZXMpXG4gICAgICAgICAgICByZXR1cm4gcm9vdE9iamVjdDtcblxuICAgICAgICB2YXIgb3V0cHV0UHJvcGVydGllcyA9IHJvb3RPYmplY3QgaW5zdGFuY2VvZiBBcnJheSA/IFtdIDoge307XG4gICAgICAgIHZpc2l0ZWRPYmplY3RzLnNhdmUocm9vdE9iamVjdCwgb3V0cHV0UHJvcGVydGllcyk7XG5cbiAgICAgICAgdmlzaXRQcm9wZXJ0aWVzT3JBcnJheUVudHJpZXMocm9vdE9iamVjdCwgZnVuY3Rpb24oaW5kZXhlcikge1xuICAgICAgICAgICAgdmFyIHByb3BlcnR5VmFsdWUgPSBtYXBJbnB1dENhbGxiYWNrKHJvb3RPYmplY3RbaW5kZXhlcl0pO1xuXG4gICAgICAgICAgICBzd2l0Y2ggKHR5cGVvZiBwcm9wZXJ0eVZhbHVlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBcImJvb2xlYW5cIjpcbiAgICAgICAgICAgICAgICBjYXNlIFwibnVtYmVyXCI6XG4gICAgICAgICAgICAgICAgY2FzZSBcInN0cmluZ1wiOlxuICAgICAgICAgICAgICAgIGNhc2UgXCJmdW5jdGlvblwiOlxuICAgICAgICAgICAgICAgICAgICBvdXRwdXRQcm9wZXJ0aWVzW2luZGV4ZXJdID0gcHJvcGVydHlWYWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcIm9iamVjdFwiOlxuICAgICAgICAgICAgICAgIGNhc2UgXCJ1bmRlZmluZWRcIjpcbiAgICAgICAgICAgICAgICAgICAgdmFyIHByZXZpb3VzbHlNYXBwZWRWYWx1ZSA9IHZpc2l0ZWRPYmplY3RzLmdldChwcm9wZXJ0eVZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0UHJvcGVydGllc1tpbmRleGVyXSA9IChwcmV2aW91c2x5TWFwcGVkVmFsdWUgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICAgICAgICAgID8gcHJldmlvdXNseU1hcHBlZFZhbHVlXG4gICAgICAgICAgICAgICAgICAgICAgICA6IG1hcEpzT2JqZWN0R3JhcGgocHJvcGVydHlWYWx1ZSwgbWFwSW5wdXRDYWxsYmFjaywgdmlzaXRlZE9iamVjdHMpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIG91dHB1dFByb3BlcnRpZXM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdmlzaXRQcm9wZXJ0aWVzT3JBcnJheUVudHJpZXMocm9vdE9iamVjdCwgdmlzaXRvckNhbGxiYWNrKSB7XG4gICAgICAgIGlmIChyb290T2JqZWN0IGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcm9vdE9iamVjdC5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgICAgICB2aXNpdG9yQ2FsbGJhY2soaSk7XG5cbiAgICAgICAgICAgIC8vIEZvciBhcnJheXMsIGFsc28gcmVzcGVjdCB0b0pTT04gcHJvcGVydHkgZm9yIGN1c3RvbSBtYXBwaW5ncyAoZml4ZXMgIzI3OClcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygcm9vdE9iamVjdFsndG9KU09OJ10gPT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgICAgICAgICB2aXNpdG9yQ2FsbGJhY2soJ3RvSlNPTicpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZm9yICh2YXIgcHJvcGVydHlOYW1lIGluIHJvb3RPYmplY3QpIHtcbiAgICAgICAgICAgICAgICB2aXNpdG9yQ2FsbGJhY2socHJvcGVydHlOYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBmdW5jdGlvbiBvYmplY3RMb29rdXAoKSB7XG4gICAgICAgIHRoaXMua2V5cyA9IFtdO1xuICAgICAgICB0aGlzLnZhbHVlcyA9IFtdO1xuICAgIH07XG5cbiAgICBvYmplY3RMb29rdXAucHJvdG90eXBlID0ge1xuICAgICAgICBjb25zdHJ1Y3Rvcjogb2JqZWN0TG9va3VwLFxuICAgICAgICBzYXZlOiBmdW5jdGlvbihrZXksIHZhbHVlKSB7XG4gICAgICAgICAgICB2YXIgZXhpc3RpbmdJbmRleCA9IGtvLnV0aWxzLmFycmF5SW5kZXhPZih0aGlzLmtleXMsIGtleSk7XG4gICAgICAgICAgICBpZiAoZXhpc3RpbmdJbmRleCA+PSAwKVxuICAgICAgICAgICAgICAgIHRoaXMudmFsdWVzW2V4aXN0aW5nSW5kZXhdID0gdmFsdWU7XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmtleXMucHVzaChrZXkpO1xuICAgICAgICAgICAgICAgIHRoaXMudmFsdWVzLnB1c2godmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBnZXQ6IGZ1bmN0aW9uKGtleSkge1xuICAgICAgICAgICAgdmFyIGV4aXN0aW5nSW5kZXggPSBrby51dGlscy5hcnJheUluZGV4T2YodGhpcy5rZXlzLCBrZXkpO1xuICAgICAgICAgICAgcmV0dXJuIChleGlzdGluZ0luZGV4ID49IDApID8gdGhpcy52YWx1ZXNbZXhpc3RpbmdJbmRleF0gOiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICB9O1xufSkoKTtcblxua28uZXhwb3J0U3ltYm9sKCd0b0pTJywga28udG9KUyk7XG5rby5leHBvcnRTeW1ib2woJ3RvSlNPTicsIGtvLnRvSlNPTik7XG4oZnVuY3Rpb24gKCkge1xuICAgIHZhciBoYXNEb21EYXRhRXhwYW5kb1Byb3BlcnR5ID0gJ19fa29fX2hhc0RvbURhdGFPcHRpb25WYWx1ZV9fJztcblxuICAgIC8vIE5vcm1hbGx5LCBTRUxFQ1QgZWxlbWVudHMgYW5kIHRoZWlyIE9QVElPTnMgY2FuIG9ubHkgdGFrZSB2YWx1ZSBvZiB0eXBlICdzdHJpbmcnIChiZWNhdXNlIHRoZSB2YWx1ZXNcbiAgICAvLyBhcmUgc3RvcmVkIG9uIERPTSBhdHRyaWJ1dGVzKS4ga28uc2VsZWN0RXh0ZW5zaW9ucyBwcm92aWRlcyBhIHdheSBmb3IgU0VMRUNUcy9PUFRJT05zIHRvIGhhdmUgdmFsdWVzXG4gICAgLy8gdGhhdCBhcmUgYXJiaXRyYXJ5IG9iamVjdHMuIFRoaXMgaXMgdmVyeSBjb252ZW5pZW50IHdoZW4gaW1wbGVtZW50aW5nIHRoaW5ncyBsaWtlIGNhc2NhZGluZyBkcm9wZG93bnMuXG4gICAga28uc2VsZWN0RXh0ZW5zaW9ucyA9IHtcbiAgICAgICAgcmVhZFZhbHVlIDogZnVuY3Rpb24oZWxlbWVudCkge1xuICAgICAgICAgICAgc3dpdGNoIChrby51dGlscy50YWdOYW1lTG93ZXIoZWxlbWVudCkpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdvcHRpb24nOlxuICAgICAgICAgICAgICAgICAgICBpZiAoZWxlbWVudFtoYXNEb21EYXRhRXhwYW5kb1Byb3BlcnR5XSA9PT0gdHJ1ZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBrby51dGlscy5kb21EYXRhLmdldChlbGVtZW50LCBrby5iaW5kaW5nSGFuZGxlcnMub3B0aW9ucy5vcHRpb25WYWx1ZURvbURhdGFLZXkpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4ga28udXRpbHMuaWVWZXJzaW9uIDw9IDdcbiAgICAgICAgICAgICAgICAgICAgICAgID8gKGVsZW1lbnQuZ2V0QXR0cmlidXRlTm9kZSgndmFsdWUnKSAmJiBlbGVtZW50LmdldEF0dHJpYnV0ZU5vZGUoJ3ZhbHVlJykuc3BlY2lmaWVkID8gZWxlbWVudC52YWx1ZSA6IGVsZW1lbnQudGV4dClcbiAgICAgICAgICAgICAgICAgICAgICAgIDogZWxlbWVudC52YWx1ZTtcbiAgICAgICAgICAgICAgICBjYXNlICdzZWxlY3QnOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZWxlbWVudC5zZWxlY3RlZEluZGV4ID49IDAgPyBrby5zZWxlY3RFeHRlbnNpb25zLnJlYWRWYWx1ZShlbGVtZW50Lm9wdGlvbnNbZWxlbWVudC5zZWxlY3RlZEluZGV4XSkgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVsZW1lbnQudmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgd3JpdGVWYWx1ZTogZnVuY3Rpb24oZWxlbWVudCwgdmFsdWUsIGFsbG93VW5zZXQpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoa28udXRpbHMudGFnTmFtZUxvd2VyKGVsZW1lbnQpKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnb3B0aW9uJzpcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoKHR5cGVvZiB2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcInN0cmluZ1wiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtvLnV0aWxzLmRvbURhdGEuc2V0KGVsZW1lbnQsIGtvLmJpbmRpbmdIYW5kbGVycy5vcHRpb25zLm9wdGlvblZhbHVlRG9tRGF0YUtleSwgdW5kZWZpbmVkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaGFzRG9tRGF0YUV4cGFuZG9Qcm9wZXJ0eSBpbiBlbGVtZW50KSB7IC8vIElFIDw9IDggdGhyb3dzIGVycm9ycyBpZiB5b3UgZGVsZXRlIG5vbi1leGlzdGVudCBwcm9wZXJ0aWVzIGZyb20gYSBET00gbm9kZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgZWxlbWVudFtoYXNEb21EYXRhRXhwYW5kb1Byb3BlcnR5XTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudC52YWx1ZSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTdG9yZSBhcmJpdHJhcnkgb2JqZWN0IHVzaW5nIERvbURhdGFcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBrby51dGlscy5kb21EYXRhLnNldChlbGVtZW50LCBrby5iaW5kaW5nSGFuZGxlcnMub3B0aW9ucy5vcHRpb25WYWx1ZURvbURhdGFLZXksIHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50W2hhc0RvbURhdGFFeHBhbmRvUHJvcGVydHldID0gdHJ1ZTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNwZWNpYWwgdHJlYXRtZW50IG9mIG51bWJlcnMgaXMganVzdCBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eS4gS08gMS4yLjEgd3JvdGUgbnVtZXJpY2FsIHZhbHVlcyB0byBlbGVtZW50LnZhbHVlLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnQudmFsdWUgPSB0eXBlb2YgdmFsdWUgPT09IFwibnVtYmVyXCIgPyB2YWx1ZSA6IFwiXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnc2VsZWN0JzpcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlID09PSBcIlwiIHx8IHZhbHVlID09PSBudWxsKSAgICAgICAvLyBBIGJsYW5rIHN0cmluZyBvciBudWxsIHZhbHVlIHdpbGwgc2VsZWN0IHRoZSBjYXB0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNlbGVjdGlvbiA9IC0xO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbiA9IGVsZW1lbnQub3B0aW9ucy5sZW5ndGgsIG9wdGlvblZhbHVlOyBpIDwgbjsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25WYWx1ZSA9IGtvLnNlbGVjdEV4dGVuc2lvbnMucmVhZFZhbHVlKGVsZW1lbnQub3B0aW9uc1tpXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJbmNsdWRlIHNwZWNpYWwgY2hlY2sgdG8gaGFuZGxlIHNlbGVjdGluZyBhIGNhcHRpb24gd2l0aCBhIGJsYW5rIHN0cmluZyB2YWx1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvblZhbHVlID09IHZhbHVlIHx8IChvcHRpb25WYWx1ZSA9PSBcIlwiICYmIHZhbHVlID09PSB1bmRlZmluZWQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0aW9uID0gaTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoYWxsb3dVbnNldCB8fCBzZWxlY3Rpb24gPj0gMCB8fCAodmFsdWUgPT09IHVuZGVmaW5lZCAmJiBlbGVtZW50LnNpemUgPiAxKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5zZWxlY3RlZEluZGV4ID0gc2VsZWN0aW9uO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGlmICgodmFsdWUgPT09IG51bGwpIHx8ICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gXCJcIjtcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudC52YWx1ZSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG59KSgpO1xuXG5rby5leHBvcnRTeW1ib2woJ3NlbGVjdEV4dGVuc2lvbnMnLCBrby5zZWxlY3RFeHRlbnNpb25zKTtcbmtvLmV4cG9ydFN5bWJvbCgnc2VsZWN0RXh0ZW5zaW9ucy5yZWFkVmFsdWUnLCBrby5zZWxlY3RFeHRlbnNpb25zLnJlYWRWYWx1ZSk7XG5rby5leHBvcnRTeW1ib2woJ3NlbGVjdEV4dGVuc2lvbnMud3JpdGVWYWx1ZScsIGtvLnNlbGVjdEV4dGVuc2lvbnMud3JpdGVWYWx1ZSk7XG5rby5leHByZXNzaW9uUmV3cml0aW5nID0gKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgamF2YVNjcmlwdFJlc2VydmVkV29yZHMgPSBbXCJ0cnVlXCIsIFwiZmFsc2VcIiwgXCJudWxsXCIsIFwidW5kZWZpbmVkXCJdO1xuXG4gICAgLy8gTWF0Y2hlcyBzb21ldGhpbmcgdGhhdCBjYW4gYmUgYXNzaWduZWQgdG8tLWVpdGhlciBhbiBpc29sYXRlZCBpZGVudGlmaWVyIG9yIHNvbWV0aGluZyBlbmRpbmcgd2l0aCBhIHByb3BlcnR5IGFjY2Vzc29yXG4gICAgLy8gVGhpcyBpcyBkZXNpZ25lZCB0byBiZSBzaW1wbGUgYW5kIGF2b2lkIGZhbHNlIG5lZ2F0aXZlcywgYnV0IGNvdWxkIHByb2R1Y2UgZmFsc2UgcG9zaXRpdmVzIChlLmcuLCBhK2IuYykuXG4gICAgLy8gVGhpcyBhbHNvIHdpbGwgbm90IHByb3Blcmx5IGhhbmRsZSBuZXN0ZWQgYnJhY2tldHMgKGUuZy4sIG9iajFbb2JqMlsncHJvcCddXTsgc2VlICM5MTEpLlxuICAgIHZhciBqYXZhU2NyaXB0QXNzaWdubWVudFRhcmdldCA9IC9eKD86WyRfYS16XVskXFx3XSp8KC4rKShcXC5cXHMqWyRfYS16XVskXFx3XSp8XFxbLitcXF0pKSQvaTtcblxuICAgIGZ1bmN0aW9uIGdldFdyaXRlYWJsZVZhbHVlKGV4cHJlc3Npb24pIHtcbiAgICAgICAgaWYgKGtvLnV0aWxzLmFycmF5SW5kZXhPZihqYXZhU2NyaXB0UmVzZXJ2ZWRXb3JkcywgZXhwcmVzc2lvbikgPj0gMClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgdmFyIG1hdGNoID0gZXhwcmVzc2lvbi5tYXRjaChqYXZhU2NyaXB0QXNzaWdubWVudFRhcmdldCk7XG4gICAgICAgIHJldHVybiBtYXRjaCA9PT0gbnVsbCA/IGZhbHNlIDogbWF0Y2hbMV0gPyAoJ09iamVjdCgnICsgbWF0Y2hbMV0gKyAnKScgKyBtYXRjaFsyXSkgOiBleHByZXNzaW9uO1xuICAgIH1cblxuICAgIC8vIFRoZSBmb2xsb3dpbmcgcmVndWxhciBleHByZXNzaW9ucyB3aWxsIGJlIHVzZWQgdG8gc3BsaXQgYW4gb2JqZWN0LWxpdGVyYWwgc3RyaW5nIGludG8gdG9rZW5zXG5cbiAgICAgICAgLy8gVGhlc2UgdHdvIG1hdGNoIHN0cmluZ3MsIGVpdGhlciB3aXRoIGRvdWJsZSBxdW90ZXMgb3Igc2luZ2xlIHF1b3Rlc1xuICAgIHZhciBzdHJpbmdEb3VibGUgPSAnXCIoPzpbXlwiXFxcXFxcXFxdfFxcXFxcXFxcLikqXCInLFxuICAgICAgICBzdHJpbmdTaW5nbGUgPSBcIicoPzpbXidcXFxcXFxcXF18XFxcXFxcXFwuKSonXCIsXG4gICAgICAgIC8vIE1hdGNoZXMgYSByZWd1bGFyIGV4cHJlc3Npb24gKHRleHQgZW5jbG9zZWQgYnkgc2xhc2hlcyksIGJ1dCB3aWxsIGFsc28gbWF0Y2ggc2V0cyBvZiBkaXZpc2lvbnNcbiAgICAgICAgLy8gYXMgYSByZWd1bGFyIGV4cHJlc3Npb24gKHRoaXMgaXMgaGFuZGxlZCBieSB0aGUgcGFyc2luZyBsb29wIGJlbG93KS5cbiAgICAgICAgc3RyaW5nUmVnZXhwID0gJy8oPzpbXi9cXFxcXFxcXF18XFxcXFxcXFwuKSovXFx3KicsXG4gICAgICAgIC8vIFRoZXNlIGNoYXJhY3RlcnMgaGF2ZSBzcGVjaWFsIG1lYW5pbmcgdG8gdGhlIHBhcnNlciBhbmQgbXVzdCBub3QgYXBwZWFyIGluIHRoZSBtaWRkbGUgb2YgYVxuICAgICAgICAvLyB0b2tlbiwgZXhjZXB0IGFzIHBhcnQgb2YgYSBzdHJpbmcuXG4gICAgICAgIHNwZWNpYWxzID0gJyxcIlxcJ3t9KCkvOltcXFxcXScsXG4gICAgICAgIC8vIE1hdGNoIHRleHQgKGF0IGxlYXN0IHR3byBjaGFyYWN0ZXJzKSB0aGF0IGRvZXMgbm90IGNvbnRhaW4gYW55IG9mIHRoZSBhYm92ZSBzcGVjaWFsIGNoYXJhY3RlcnMsXG4gICAgICAgIC8vIGFsdGhvdWdoIHNvbWUgb2YgdGhlIHNwZWNpYWwgY2hhcmFjdGVycyBhcmUgYWxsb3dlZCB0byBzdGFydCBpdCAoYWxsIGJ1dCB0aGUgY29sb24gYW5kIGNvbW1hKS5cbiAgICAgICAgLy8gVGhlIHRleHQgY2FuIGNvbnRhaW4gc3BhY2VzLCBidXQgbGVhZGluZyBvciB0cmFpbGluZyBzcGFjZXMgYXJlIHNraXBwZWQuXG4gICAgICAgIGV2ZXJ5VGhpbmdFbHNlID0gJ1teXFxcXHM6LC9dW14nICsgc3BlY2lhbHMgKyAnXSpbXlxcXFxzJyArIHNwZWNpYWxzICsgJ10nLFxuICAgICAgICAvLyBNYXRjaCBhbnkgbm9uLXNwYWNlIGNoYXJhY3RlciBub3QgbWF0Y2hlZCBhbHJlYWR5LiBUaGlzIHdpbGwgbWF0Y2ggY29sb25zIGFuZCBjb21tYXMsIHNpbmNlIHRoZXkncmVcbiAgICAgICAgLy8gbm90IG1hdGNoZWQgYnkgXCJldmVyeVRoaW5nRWxzZVwiLCBidXQgd2lsbCBhbHNvIG1hdGNoIGFueSBvdGhlciBzaW5nbGUgY2hhcmFjdGVyIHRoYXQgd2Fzbid0IGFscmVhZHlcbiAgICAgICAgLy8gbWF0Y2hlZCAoZm9yIGV4YW1wbGU6IGluIFwiYTogMSwgYjogMlwiLCBlYWNoIG9mIHRoZSBub24tc3BhY2UgY2hhcmFjdGVycyB3aWxsIGJlIG1hdGNoZWQgYnkgb25lTm90U3BhY2UpLlxuICAgICAgICBvbmVOb3RTcGFjZSA9ICdbXlxcXFxzXScsXG5cbiAgICAgICAgLy8gQ3JlYXRlIHRoZSBhY3R1YWwgcmVndWxhciBleHByZXNzaW9uIGJ5IG9yLWluZyB0aGUgYWJvdmUgc3RyaW5ncy4gVGhlIG9yZGVyIGlzIGltcG9ydGFudC5cbiAgICAgICAgYmluZGluZ1Rva2VuID0gUmVnRXhwKHN0cmluZ0RvdWJsZSArICd8JyArIHN0cmluZ1NpbmdsZSArICd8JyArIHN0cmluZ1JlZ2V4cCArICd8JyArIGV2ZXJ5VGhpbmdFbHNlICsgJ3wnICsgb25lTm90U3BhY2UsICdnJyksXG5cbiAgICAgICAgLy8gTWF0Y2ggZW5kIG9mIHByZXZpb3VzIHRva2VuIHRvIGRldGVybWluZSB3aGV0aGVyIGEgc2xhc2ggaXMgYSBkaXZpc2lvbiBvciByZWdleC5cbiAgICAgICAgZGl2aXNpb25Mb29rQmVoaW5kID0gL1tcXF0pXCInQS1aYS16MC05XyRdKyQvLFxuICAgICAgICBrZXl3b3JkUmVnZXhMb29rQmVoaW5kID0geydpbic6MSwncmV0dXJuJzoxLCd0eXBlb2YnOjF9O1xuXG4gICAgZnVuY3Rpb24gcGFyc2VPYmplY3RMaXRlcmFsKG9iamVjdExpdGVyYWxTdHJpbmcpIHtcbiAgICAgICAgLy8gVHJpbSBsZWFkaW5nIGFuZCB0cmFpbGluZyBzcGFjZXMgZnJvbSB0aGUgc3RyaW5nXG4gICAgICAgIHZhciBzdHIgPSBrby51dGlscy5zdHJpbmdUcmltKG9iamVjdExpdGVyYWxTdHJpbmcpO1xuXG4gICAgICAgIC8vIFRyaW0gYnJhY2VzICd7JyBzdXJyb3VuZGluZyB0aGUgd2hvbGUgb2JqZWN0IGxpdGVyYWxcbiAgICAgICAgaWYgKHN0ci5jaGFyQ29kZUF0KDApID09PSAxMjMpIHN0ciA9IHN0ci5zbGljZSgxLCAtMSk7XG5cbiAgICAgICAgLy8gU3BsaXQgaW50byB0b2tlbnNcbiAgICAgICAgdmFyIHJlc3VsdCA9IFtdLCB0b2tzID0gc3RyLm1hdGNoKGJpbmRpbmdUb2tlbiksIGtleSwgdmFsdWVzID0gW10sIGRlcHRoID0gMDtcblxuICAgICAgICBpZiAodG9rcykge1xuICAgICAgICAgICAgLy8gQXBwZW5kIGEgY29tbWEgc28gdGhhdCB3ZSBkb24ndCBuZWVkIGEgc2VwYXJhdGUgY29kZSBibG9jayB0byBkZWFsIHdpdGggdGhlIGxhc3QgaXRlbVxuICAgICAgICAgICAgdG9rcy5wdXNoKCcsJyk7XG5cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCB0b2s7IHRvayA9IHRva3NbaV07ICsraSkge1xuICAgICAgICAgICAgICAgIHZhciBjID0gdG9rLmNoYXJDb2RlQXQoMCk7XG4gICAgICAgICAgICAgICAgLy8gQSBjb21tYSBzaWduYWxzIHRoZSBlbmQgb2YgYSBrZXkvdmFsdWUgcGFpciBpZiBkZXB0aCBpcyB6ZXJvXG4gICAgICAgICAgICAgICAgaWYgKGMgPT09IDQ0KSB7IC8vIFwiLFwiXG4gICAgICAgICAgICAgICAgICAgIGlmIChkZXB0aCA8PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaCgoa2V5ICYmIHZhbHVlcy5sZW5ndGgpID8ge2tleToga2V5LCB2YWx1ZTogdmFsdWVzLmpvaW4oJycpfSA6IHsndW5rbm93bic6IGtleSB8fCB2YWx1ZXMuam9pbignJyl9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleSA9IGRlcHRoID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlcyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBTaW1wbHkgc2tpcCB0aGUgY29sb24gdGhhdCBzZXBhcmF0ZXMgdGhlIG5hbWUgYW5kIHZhbHVlXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjID09PSA1OCkgeyAvLyBcIjpcIlxuICAgICAgICAgICAgICAgICAgICBpZiAoIWRlcHRoICYmICFrZXkgJiYgdmFsdWVzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAga2V5ID0gdmFsdWVzLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBBIHNldCBvZiBzbGFzaGVzIGlzIGluaXRpYWxseSBtYXRjaGVkIGFzIGEgcmVndWxhciBleHByZXNzaW9uLCBidXQgY291bGQgYmUgZGl2aXNpb25cbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGMgPT09IDQ3ICYmIGkgJiYgdG9rLmxlbmd0aCA+IDEpIHsgIC8vIFwiL1wiXG4gICAgICAgICAgICAgICAgICAgIC8vIExvb2sgYXQgdGhlIGVuZCBvZiB0aGUgcHJldmlvdXMgdG9rZW4gdG8gZGV0ZXJtaW5lIGlmIHRoZSBzbGFzaCBpcyBhY3R1YWxseSBkaXZpc2lvblxuICAgICAgICAgICAgICAgICAgICB2YXIgbWF0Y2ggPSB0b2tzW2ktMV0ubWF0Y2goZGl2aXNpb25Mb29rQmVoaW5kKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1hdGNoICYmICFrZXl3b3JkUmVnZXhMb29rQmVoaW5kW21hdGNoWzBdXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhlIHNsYXNoIGlzIGFjdHVhbGx5IGEgZGl2aXNpb24gcHVuY3R1YXRvcjsgcmUtcGFyc2UgdGhlIHJlbWFpbmRlciBvZiB0aGUgc3RyaW5nIChub3QgaW5jbHVkaW5nIHRoZSBzbGFzaClcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0ciA9IHN0ci5zdWJzdHIoc3RyLmluZGV4T2YodG9rKSArIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdG9rcyA9IHN0ci5tYXRjaChiaW5kaW5nVG9rZW4pO1xuICAgICAgICAgICAgICAgICAgICAgICAgdG9rcy5wdXNoKCcsJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpID0gLTE7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBDb250aW51ZSB3aXRoIGp1c3QgdGhlIHNsYXNoXG4gICAgICAgICAgICAgICAgICAgICAgICB0b2sgPSAnLyc7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBJbmNyZW1lbnQgZGVwdGggZm9yIHBhcmVudGhlc2VzLCBicmFjZXMsIGFuZCBicmFja2V0cyBzbyB0aGF0IGludGVyaW9yIGNvbW1hcyBhcmUgaWdub3JlZFxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoYyA9PT0gNDAgfHwgYyA9PT0gMTIzIHx8IGMgPT09IDkxKSB7IC8vICcoJywgJ3snLCAnWydcbiAgICAgICAgICAgICAgICAgICAgKytkZXB0aDtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGMgPT09IDQxIHx8IGMgPT09IDEyNSB8fCBjID09PSA5MykgeyAvLyAnKScsICd9JywgJ10nXG4gICAgICAgICAgICAgICAgICAgIC0tZGVwdGg7XG4gICAgICAgICAgICAgICAgLy8gVGhlIGtleSB3aWxsIGJlIHRoZSBmaXJzdCB0b2tlbjsgaWYgaXQncyBhIHN0cmluZywgdHJpbSB0aGUgcXVvdGVzXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICgha2V5ICYmICF2YWx1ZXMubGVuZ3RoICYmIChjID09PSAzNCB8fCBjID09PSAzOSkpIHsgLy8gJ1wiJywgXCInXCJcbiAgICAgICAgICAgICAgICAgICAgdG9rID0gdG9rLnNsaWNlKDEsIC0xKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFsdWVzLnB1c2godG9rKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8vIFR3by13YXkgYmluZGluZ3MgaW5jbHVkZSBhIHdyaXRlIGZ1bmN0aW9uIHRoYXQgYWxsb3cgdGhlIGhhbmRsZXIgdG8gdXBkYXRlIHRoZSB2YWx1ZSBldmVuIGlmIGl0J3Mgbm90IGFuIG9ic2VydmFibGUuXG4gICAgdmFyIHR3b1dheUJpbmRpbmdzID0ge307XG5cbiAgICBmdW5jdGlvbiBwcmVQcm9jZXNzQmluZGluZ3MoYmluZGluZ3NTdHJpbmdPcktleVZhbHVlQXJyYXksIGJpbmRpbmdPcHRpb25zKSB7XG4gICAgICAgIGJpbmRpbmdPcHRpb25zID0gYmluZGluZ09wdGlvbnMgfHwge307XG5cbiAgICAgICAgZnVuY3Rpb24gcHJvY2Vzc0tleVZhbHVlKGtleSwgdmFsKSB7XG4gICAgICAgICAgICB2YXIgd3JpdGFibGVWYWw7XG4gICAgICAgICAgICBmdW5jdGlvbiBjYWxsUHJlcHJvY2Vzc0hvb2sob2JqKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIChvYmogJiYgb2JqWydwcmVwcm9jZXNzJ10pID8gKHZhbCA9IG9ialsncHJlcHJvY2VzcyddKHZhbCwga2V5LCBwcm9jZXNzS2V5VmFsdWUpKSA6IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWJpbmRpbmdQYXJhbXMpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWNhbGxQcmVwcm9jZXNzSG9vayhrb1snZ2V0QmluZGluZ0hhbmRsZXInXShrZXkpKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuXG4gICAgICAgICAgICAgICAgaWYgKHR3b1dheUJpbmRpbmdzW2tleV0gJiYgKHdyaXRhYmxlVmFsID0gZ2V0V3JpdGVhYmxlVmFsdWUodmFsKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gRm9yIHR3by13YXkgYmluZGluZ3MsIHByb3ZpZGUgYSB3cml0ZSBtZXRob2QgaW4gY2FzZSB0aGUgdmFsdWVcbiAgICAgICAgICAgICAgICAgICAgLy8gaXNuJ3QgYSB3cml0YWJsZSBvYnNlcnZhYmxlLlxuICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0eUFjY2Vzc29yUmVzdWx0U3RyaW5ncy5wdXNoKFwiJ1wiICsga2V5ICsgXCInOmZ1bmN0aW9uKF96KXtcIiArIHdyaXRhYmxlVmFsICsgXCI9X3p9XCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFZhbHVlcyBhcmUgd3JhcHBlZCBpbiBhIGZ1bmN0aW9uIHNvIHRoYXQgZWFjaCB2YWx1ZSBjYW4gYmUgYWNjZXNzZWQgaW5kZXBlbmRlbnRseVxuICAgICAgICAgICAgaWYgKG1ha2VWYWx1ZUFjY2Vzc29ycykge1xuICAgICAgICAgICAgICAgIHZhbCA9ICdmdW5jdGlvbigpe3JldHVybiAnICsgdmFsICsgJyB9JztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdFN0cmluZ3MucHVzaChcIidcIiArIGtleSArIFwiJzpcIiArIHZhbCk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcmVzdWx0U3RyaW5ncyA9IFtdLFxuICAgICAgICAgICAgcHJvcGVydHlBY2Nlc3NvclJlc3VsdFN0cmluZ3MgPSBbXSxcbiAgICAgICAgICAgIG1ha2VWYWx1ZUFjY2Vzc29ycyA9IGJpbmRpbmdPcHRpb25zWyd2YWx1ZUFjY2Vzc29ycyddLFxuICAgICAgICAgICAgYmluZGluZ1BhcmFtcyA9IGJpbmRpbmdPcHRpb25zWydiaW5kaW5nUGFyYW1zJ10sXG4gICAgICAgICAgICBrZXlWYWx1ZUFycmF5ID0gdHlwZW9mIGJpbmRpbmdzU3RyaW5nT3JLZXlWYWx1ZUFycmF5ID09PSBcInN0cmluZ1wiID9cbiAgICAgICAgICAgICAgICBwYXJzZU9iamVjdExpdGVyYWwoYmluZGluZ3NTdHJpbmdPcktleVZhbHVlQXJyYXkpIDogYmluZGluZ3NTdHJpbmdPcktleVZhbHVlQXJyYXk7XG5cbiAgICAgICAga28udXRpbHMuYXJyYXlGb3JFYWNoKGtleVZhbHVlQXJyYXksIGZ1bmN0aW9uKGtleVZhbHVlKSB7XG4gICAgICAgICAgICBwcm9jZXNzS2V5VmFsdWUoa2V5VmFsdWUua2V5IHx8IGtleVZhbHVlWyd1bmtub3duJ10sIGtleVZhbHVlLnZhbHVlKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKHByb3BlcnR5QWNjZXNzb3JSZXN1bHRTdHJpbmdzLmxlbmd0aClcbiAgICAgICAgICAgIHByb2Nlc3NLZXlWYWx1ZSgnX2tvX3Byb3BlcnR5X3dyaXRlcnMnLCBcIntcIiArIHByb3BlcnR5QWNjZXNzb3JSZXN1bHRTdHJpbmdzLmpvaW4oXCIsXCIpICsgXCIgfVwiKTtcblxuICAgICAgICByZXR1cm4gcmVzdWx0U3RyaW5ncy5qb2luKFwiLFwiKTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgICBiaW5kaW5nUmV3cml0ZVZhbGlkYXRvcnM6IFtdLFxuXG4gICAgICAgIHR3b1dheUJpbmRpbmdzOiB0d29XYXlCaW5kaW5ncyxcblxuICAgICAgICBwYXJzZU9iamVjdExpdGVyYWw6IHBhcnNlT2JqZWN0TGl0ZXJhbCxcblxuICAgICAgICBwcmVQcm9jZXNzQmluZGluZ3M6IHByZVByb2Nlc3NCaW5kaW5ncyxcblxuICAgICAgICBrZXlWYWx1ZUFycmF5Q29udGFpbnNLZXk6IGZ1bmN0aW9uKGtleVZhbHVlQXJyYXksIGtleSkge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlWYWx1ZUFycmF5Lmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgICAgIGlmIChrZXlWYWx1ZUFycmF5W2ldWydrZXknXSA9PSBrZXkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8vIEludGVybmFsLCBwcml2YXRlIEtPIHV0aWxpdHkgZm9yIHVwZGF0aW5nIG1vZGVsIHByb3BlcnRpZXMgZnJvbSB3aXRoaW4gYmluZGluZ3NcbiAgICAgICAgLy8gcHJvcGVydHk6ICAgICAgICAgICAgSWYgdGhlIHByb3BlcnR5IGJlaW5nIHVwZGF0ZWQgaXMgKG9yIG1pZ2h0IGJlKSBhbiBvYnNlcnZhYmxlLCBwYXNzIGl0IGhlcmVcbiAgICAgICAgLy8gICAgICAgICAgICAgICAgICAgICAgSWYgaXQgdHVybnMgb3V0IHRvIGJlIGEgd3JpdGFibGUgb2JzZXJ2YWJsZSwgaXQgd2lsbCBiZSB3cml0dGVuIHRvIGRpcmVjdGx5XG4gICAgICAgIC8vIGFsbEJpbmRpbmdzOiAgICAgICAgIEFuIG9iamVjdCB3aXRoIGEgZ2V0IG1ldGhvZCB0byByZXRyaWV2ZSBiaW5kaW5ncyBpbiB0aGUgY3VycmVudCBleGVjdXRpb24gY29udGV4dC5cbiAgICAgICAgLy8gICAgICAgICAgICAgICAgICAgICAgVGhpcyB3aWxsIGJlIHNlYXJjaGVkIGZvciBhICdfa29fcHJvcGVydHlfd3JpdGVycycgcHJvcGVydHkgaW4gY2FzZSB5b3UncmUgd3JpdGluZyB0byBhIG5vbi1vYnNlcnZhYmxlXG4gICAgICAgIC8vIGtleTogICAgICAgICAgICAgICAgIFRoZSBrZXkgaWRlbnRpZnlpbmcgdGhlIHByb3BlcnR5IHRvIGJlIHdyaXR0ZW4uIEV4YW1wbGU6IGZvciB7IGhhc0ZvY3VzOiBteVZhbHVlIH0sIHdyaXRlIHRvICdteVZhbHVlJyBieSBzcGVjaWZ5aW5nIHRoZSBrZXkgJ2hhc0ZvY3VzJ1xuICAgICAgICAvLyB2YWx1ZTogICAgICAgICAgICAgICBUaGUgdmFsdWUgdG8gYmUgd3JpdHRlblxuICAgICAgICAvLyBjaGVja0lmRGlmZmVyZW50OiAgICBJZiB0cnVlLCBhbmQgaWYgdGhlIHByb3BlcnR5IGJlaW5nIHdyaXR0ZW4gaXMgYSB3cml0YWJsZSBvYnNlcnZhYmxlLCB0aGUgdmFsdWUgd2lsbCBvbmx5IGJlIHdyaXR0ZW4gaWZcbiAgICAgICAgLy8gICAgICAgICAgICAgICAgICAgICAgaXQgaXMgIT09IGV4aXN0aW5nIHZhbHVlIG9uIHRoYXQgd3JpdGFibGUgb2JzZXJ2YWJsZVxuICAgICAgICB3cml0ZVZhbHVlVG9Qcm9wZXJ0eTogZnVuY3Rpb24ocHJvcGVydHksIGFsbEJpbmRpbmdzLCBrZXksIHZhbHVlLCBjaGVja0lmRGlmZmVyZW50KSB7XG4gICAgICAgICAgICBpZiAoIXByb3BlcnR5IHx8ICFrby5pc09ic2VydmFibGUocHJvcGVydHkpKSB7XG4gICAgICAgICAgICAgICAgdmFyIHByb3BXcml0ZXJzID0gYWxsQmluZGluZ3MuZ2V0KCdfa29fcHJvcGVydHlfd3JpdGVycycpO1xuICAgICAgICAgICAgICAgIGlmIChwcm9wV3JpdGVycyAmJiBwcm9wV3JpdGVyc1trZXldKVxuICAgICAgICAgICAgICAgICAgICBwcm9wV3JpdGVyc1trZXldKHZhbHVlKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoa28uaXNXcml0ZWFibGVPYnNlcnZhYmxlKHByb3BlcnR5KSAmJiAoIWNoZWNrSWZEaWZmZXJlbnQgfHwgcHJvcGVydHkucGVlaygpICE9PSB2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICBwcm9wZXJ0eSh2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xufSkoKTtcblxua28uZXhwb3J0U3ltYm9sKCdleHByZXNzaW9uUmV3cml0aW5nJywga28uZXhwcmVzc2lvblJld3JpdGluZyk7XG5rby5leHBvcnRTeW1ib2woJ2V4cHJlc3Npb25SZXdyaXRpbmcuYmluZGluZ1Jld3JpdGVWYWxpZGF0b3JzJywga28uZXhwcmVzc2lvblJld3JpdGluZy5iaW5kaW5nUmV3cml0ZVZhbGlkYXRvcnMpO1xua28uZXhwb3J0U3ltYm9sKCdleHByZXNzaW9uUmV3cml0aW5nLnBhcnNlT2JqZWN0TGl0ZXJhbCcsIGtvLmV4cHJlc3Npb25SZXdyaXRpbmcucGFyc2VPYmplY3RMaXRlcmFsKTtcbmtvLmV4cG9ydFN5bWJvbCgnZXhwcmVzc2lvblJld3JpdGluZy5wcmVQcm9jZXNzQmluZGluZ3MnLCBrby5leHByZXNzaW9uUmV3cml0aW5nLnByZVByb2Nlc3NCaW5kaW5ncyk7XG5cbi8vIE1ha2luZyBiaW5kaW5ncyBleHBsaWNpdGx5IGRlY2xhcmUgdGhlbXNlbHZlcyBhcyBcInR3byB3YXlcIiBpc24ndCBpZGVhbCBpbiB0aGUgbG9uZyB0ZXJtIChpdCB3b3VsZCBiZSBiZXR0ZXIgaWZcbi8vIGFsbCBiaW5kaW5ncyBjb3VsZCB1c2UgYW4gb2ZmaWNpYWwgJ3Byb3BlcnR5IHdyaXRlcicgQVBJIHdpdGhvdXQgbmVlZGluZyB0byBkZWNsYXJlIHRoYXQgdGhleSBtaWdodCkuIEhvd2V2ZXIsXG4vLyBzaW5jZSB0aGlzIGlzIG5vdCwgYW5kIGhhcyBuZXZlciBiZWVuLCBhIHB1YmxpYyBBUEkgKF9rb19wcm9wZXJ0eV93cml0ZXJzIHdhcyBuZXZlciBkb2N1bWVudGVkKSwgaXQncyBhY2NlcHRhYmxlXG4vLyBhcyBhbiBpbnRlcm5hbCBpbXBsZW1lbnRhdGlvbiBkZXRhaWwgaW4gdGhlIHNob3J0IHRlcm0uXG4vLyBGb3IgdGhvc2UgZGV2ZWxvcGVycyB3aG8gcmVseSBvbiBfa29fcHJvcGVydHlfd3JpdGVycyBpbiB0aGVpciBjdXN0b20gYmluZGluZ3MsIHdlIGV4cG9zZSBfdHdvV2F5QmluZGluZ3MgYXMgYW5cbi8vIHVuZG9jdW1lbnRlZCBmZWF0dXJlIHRoYXQgbWFrZXMgaXQgcmVsYXRpdmVseSBlYXN5IHRvIHVwZ3JhZGUgdG8gS08gMy4wLiBIb3dldmVyLCB0aGlzIGlzIHN0aWxsIG5vdCBhbiBvZmZpY2lhbFxuLy8gcHVibGljIEFQSSwgYW5kIHdlIHJlc2VydmUgdGhlIHJpZ2h0IHRvIHJlbW92ZSBpdCBhdCBhbnkgdGltZSBpZiB3ZSBjcmVhdGUgYSByZWFsIHB1YmxpYyBwcm9wZXJ0eSB3cml0ZXJzIEFQSS5cbmtvLmV4cG9ydFN5bWJvbCgnZXhwcmVzc2lvblJld3JpdGluZy5fdHdvV2F5QmluZGluZ3MnLCBrby5leHByZXNzaW9uUmV3cml0aW5nLnR3b1dheUJpbmRpbmdzKTtcblxuLy8gRm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHksIGRlZmluZSB0aGUgZm9sbG93aW5nIGFsaWFzZXMuIChQcmV2aW91c2x5LCB0aGVzZSBmdW5jdGlvbiBuYW1lcyB3ZXJlIG1pc2xlYWRpbmcgYmVjYXVzZVxuLy8gdGhleSByZWZlcnJlZCB0byBKU09OIHNwZWNpZmljYWxseSwgZXZlbiB0aG91Z2ggdGhleSBhY3R1YWxseSB3b3JrIHdpdGggYXJiaXRyYXJ5IEphdmFTY3JpcHQgb2JqZWN0IGxpdGVyYWwgZXhwcmVzc2lvbnMuKVxua28uZXhwb3J0U3ltYm9sKCdqc29uRXhwcmVzc2lvblJld3JpdGluZycsIGtvLmV4cHJlc3Npb25SZXdyaXRpbmcpO1xua28uZXhwb3J0U3ltYm9sKCdqc29uRXhwcmVzc2lvblJld3JpdGluZy5pbnNlcnRQcm9wZXJ0eUFjY2Vzc29yc0ludG9Kc29uJywga28uZXhwcmVzc2lvblJld3JpdGluZy5wcmVQcm9jZXNzQmluZGluZ3MpO1xuKGZ1bmN0aW9uKCkge1xuICAgIC8vIFwiVmlydHVhbCBlbGVtZW50c1wiIGlzIGFuIGFic3RyYWN0aW9uIG9uIHRvcCBvZiB0aGUgdXN1YWwgRE9NIEFQSSB3aGljaCB1bmRlcnN0YW5kcyB0aGUgbm90aW9uIHRoYXQgY29tbWVudCBub2Rlc1xuICAgIC8vIG1heSBiZSB1c2VkIHRvIHJlcHJlc2VudCBoaWVyYXJjaHkgKGluIGFkZGl0aW9uIHRvIHRoZSBET00ncyBuYXR1cmFsIGhpZXJhcmNoeSkuXG4gICAgLy8gSWYgeW91IGNhbGwgdGhlIERPTS1tYW5pcHVsYXRpbmcgZnVuY3Rpb25zIG9uIGtvLnZpcnR1YWxFbGVtZW50cywgeW91IHdpbGwgYmUgYWJsZSB0byByZWFkIGFuZCB3cml0ZSB0aGUgc3RhdGVcbiAgICAvLyBvZiB0aGF0IHZpcnR1YWwgaGllcmFyY2h5XG4gICAgLy9cbiAgICAvLyBUaGUgcG9pbnQgb2YgYWxsIHRoaXMgaXMgdG8gc3VwcG9ydCBjb250YWluZXJsZXNzIHRlbXBsYXRlcyAoZS5nLiwgPCEtLSBrbyBmb3JlYWNoOnNvbWVDb2xsZWN0aW9uIC0tPmJsYWg8IS0tIC9rbyAtLT4pXG4gICAgLy8gd2l0aG91dCBoYXZpbmcgdG8gc2NhdHRlciBzcGVjaWFsIGNhc2VzIGFsbCBvdmVyIHRoZSBiaW5kaW5nIGFuZCB0ZW1wbGF0aW5nIGNvZGUuXG5cbiAgICAvLyBJRSA5IGNhbm5vdCByZWxpYWJseSByZWFkIHRoZSBcIm5vZGVWYWx1ZVwiIHByb3BlcnR5IG9mIGEgY29tbWVudCBub2RlIChzZWUgaHR0cHM6Ly9naXRodWIuY29tL1N0ZXZlU2FuZGVyc29uL2tub2Nrb3V0L2lzc3Vlcy8xODYpXG4gICAgLy8gYnV0IGl0IGRvZXMgZ2l2ZSB0aGVtIGEgbm9uc3RhbmRhcmQgYWx0ZXJuYXRpdmUgcHJvcGVydHkgY2FsbGVkIFwidGV4dFwiIHRoYXQgaXQgY2FuIHJlYWQgcmVsaWFibHkuIE90aGVyIGJyb3dzZXJzIGRvbid0IGhhdmUgdGhhdCBwcm9wZXJ0eS5cbiAgICAvLyBTbywgdXNlIG5vZGUudGV4dCB3aGVyZSBhdmFpbGFibGUsIGFuZCBub2RlLm5vZGVWYWx1ZSBlbHNld2hlcmVcbiAgICB2YXIgY29tbWVudE5vZGVzSGF2ZVRleHRQcm9wZXJ0eSA9IGRvY3VtZW50ICYmIGRvY3VtZW50LmNyZWF0ZUNvbW1lbnQoXCJ0ZXN0XCIpLnRleHQgPT09IFwiPCEtLXRlc3QtLT5cIjtcblxuICAgIHZhciBzdGFydENvbW1lbnRSZWdleCA9IGNvbW1lbnROb2Rlc0hhdmVUZXh0UHJvcGVydHkgPyAvXjwhLS1cXHMqa28oPzpcXHMrKFtcXHNcXFNdKykpP1xccyotLT4kLyA6IC9eXFxzKmtvKD86XFxzKyhbXFxzXFxTXSspKT9cXHMqJC87XG4gICAgdmFyIGVuZENvbW1lbnRSZWdleCA9ICAgY29tbWVudE5vZGVzSGF2ZVRleHRQcm9wZXJ0eSA/IC9ePCEtLVxccypcXC9rb1xccyotLT4kLyA6IC9eXFxzKlxcL2tvXFxzKiQvO1xuICAgIHZhciBodG1sVGFnc1dpdGhPcHRpb25hbGx5Q2xvc2luZ0NoaWxkcmVuID0geyAndWwnOiB0cnVlLCAnb2wnOiB0cnVlIH07XG5cbiAgICBmdW5jdGlvbiBpc1N0YXJ0Q29tbWVudChub2RlKSB7XG4gICAgICAgIHJldHVybiAobm9kZS5ub2RlVHlwZSA9PSA4KSAmJiBzdGFydENvbW1lbnRSZWdleC50ZXN0KGNvbW1lbnROb2Rlc0hhdmVUZXh0UHJvcGVydHkgPyBub2RlLnRleHQgOiBub2RlLm5vZGVWYWx1ZSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNFbmRDb21tZW50KG5vZGUpIHtcbiAgICAgICAgcmV0dXJuIChub2RlLm5vZGVUeXBlID09IDgpICYmIGVuZENvbW1lbnRSZWdleC50ZXN0KGNvbW1lbnROb2Rlc0hhdmVUZXh0UHJvcGVydHkgPyBub2RlLnRleHQgOiBub2RlLm5vZGVWYWx1ZSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0VmlydHVhbENoaWxkcmVuKHN0YXJ0Q29tbWVudCwgYWxsb3dVbmJhbGFuY2VkKSB7XG4gICAgICAgIHZhciBjdXJyZW50Tm9kZSA9IHN0YXJ0Q29tbWVudDtcbiAgICAgICAgdmFyIGRlcHRoID0gMTtcbiAgICAgICAgdmFyIGNoaWxkcmVuID0gW107XG4gICAgICAgIHdoaWxlIChjdXJyZW50Tm9kZSA9IGN1cnJlbnROb2RlLm5leHRTaWJsaW5nKSB7XG4gICAgICAgICAgICBpZiAoaXNFbmRDb21tZW50KGN1cnJlbnROb2RlKSkge1xuICAgICAgICAgICAgICAgIGRlcHRoLS07XG4gICAgICAgICAgICAgICAgaWYgKGRlcHRoID09PSAwKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2hpbGRyZW47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNoaWxkcmVuLnB1c2goY3VycmVudE5vZGUpO1xuXG4gICAgICAgICAgICBpZiAoaXNTdGFydENvbW1lbnQoY3VycmVudE5vZGUpKVxuICAgICAgICAgICAgICAgIGRlcHRoKys7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFhbGxvd1VuYmFsYW5jZWQpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBjbG9zaW5nIGNvbW1lbnQgdGFnIHRvIG1hdGNoOiBcIiArIHN0YXJ0Q29tbWVudC5ub2RlVmFsdWUpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRNYXRjaGluZ0VuZENvbW1lbnQoc3RhcnRDb21tZW50LCBhbGxvd1VuYmFsYW5jZWQpIHtcbiAgICAgICAgdmFyIGFsbFZpcnR1YWxDaGlsZHJlbiA9IGdldFZpcnR1YWxDaGlsZHJlbihzdGFydENvbW1lbnQsIGFsbG93VW5iYWxhbmNlZCk7XG4gICAgICAgIGlmIChhbGxWaXJ0dWFsQ2hpbGRyZW4pIHtcbiAgICAgICAgICAgIGlmIChhbGxWaXJ0dWFsQ2hpbGRyZW4ubGVuZ3RoID4gMClcbiAgICAgICAgICAgICAgICByZXR1cm4gYWxsVmlydHVhbENoaWxkcmVuW2FsbFZpcnR1YWxDaGlsZHJlbi5sZW5ndGggLSAxXS5uZXh0U2libGluZztcbiAgICAgICAgICAgIHJldHVybiBzdGFydENvbW1lbnQubmV4dFNpYmxpbmc7XG4gICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7IC8vIE11c3QgaGF2ZSBubyBtYXRjaGluZyBlbmQgY29tbWVudCwgYW5kIGFsbG93VW5iYWxhbmNlZCBpcyB0cnVlXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0VW5iYWxhbmNlZENoaWxkVGFncyhub2RlKSB7XG4gICAgICAgIC8vIGUuZy4sIGZyb20gPGRpdj5PSzwvZGl2PjwhLS0ga28gYmxhaCAtLT48c3Bhbj5Bbm90aGVyPC9zcGFuPiwgcmV0dXJuczogPCEtLSBrbyBibGFoIC0tPjxzcGFuPkFub3RoZXI8L3NwYW4+XG4gICAgICAgIC8vICAgICAgIGZyb20gPGRpdj5PSzwvZGl2PjwhLS0gL2tvIC0tPjwhLS0gL2tvIC0tPiwgICAgICAgICAgICAgcmV0dXJuczogPCEtLSAva28gLS0+PCEtLSAva28gLS0+XG4gICAgICAgIHZhciBjaGlsZE5vZGUgPSBub2RlLmZpcnN0Q2hpbGQsIGNhcHR1cmVSZW1haW5pbmcgPSBudWxsO1xuICAgICAgICBpZiAoY2hpbGROb2RlKSB7XG4gICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgaWYgKGNhcHR1cmVSZW1haW5pbmcpICAgICAgICAgICAgICAgICAgIC8vIFdlIGFscmVhZHkgaGl0IGFuIHVuYmFsYW5jZWQgbm9kZSBhbmQgYXJlIG5vdyBqdXN0IHNjb29waW5nIHVwIGFsbCBzdWJzZXF1ZW50IG5vZGVzXG4gICAgICAgICAgICAgICAgICAgIGNhcHR1cmVSZW1haW5pbmcucHVzaChjaGlsZE5vZGUpO1xuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGlzU3RhcnRDb21tZW50KGNoaWxkTm9kZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG1hdGNoaW5nRW5kQ29tbWVudCA9IGdldE1hdGNoaW5nRW5kQ29tbWVudChjaGlsZE5vZGUsIC8qIGFsbG93VW5iYWxhbmNlZDogKi8gdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtYXRjaGluZ0VuZENvbW1lbnQpICAgICAgICAgICAgIC8vIEl0J3MgYSBiYWxhbmNlZCB0YWcsIHNvIHNraXAgaW1tZWRpYXRlbHkgdG8gdGhlIGVuZCBvZiB0aGlzIHZpcnR1YWwgc2V0XG4gICAgICAgICAgICAgICAgICAgICAgICBjaGlsZE5vZGUgPSBtYXRjaGluZ0VuZENvbW1lbnQ7XG4gICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhcHR1cmVSZW1haW5pbmcgPSBbY2hpbGROb2RlXTsgLy8gSXQncyB1bmJhbGFuY2VkLCBzbyBzdGFydCBjYXB0dXJpbmcgZnJvbSB0aGlzIHBvaW50XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChpc0VuZENvbW1lbnQoY2hpbGROb2RlKSkge1xuICAgICAgICAgICAgICAgICAgICBjYXB0dXJlUmVtYWluaW5nID0gW2NoaWxkTm9kZV07ICAgICAvLyBJdCdzIHVuYmFsYW5jZWQgKGlmIGl0IHdhc24ndCwgd2UnZCBoYXZlIHNraXBwZWQgb3ZlciBpdCBhbHJlYWR5KSwgc28gc3RhcnQgY2FwdHVyaW5nXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSB3aGlsZSAoY2hpbGROb2RlID0gY2hpbGROb2RlLm5leHRTaWJsaW5nKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2FwdHVyZVJlbWFpbmluZztcbiAgICB9XG5cbiAgICBrby52aXJ0dWFsRWxlbWVudHMgPSB7XG4gICAgICAgIGFsbG93ZWRCaW5kaW5nczoge30sXG5cbiAgICAgICAgY2hpbGROb2RlczogZnVuY3Rpb24obm9kZSkge1xuICAgICAgICAgICAgcmV0dXJuIGlzU3RhcnRDb21tZW50KG5vZGUpID8gZ2V0VmlydHVhbENoaWxkcmVuKG5vZGUpIDogbm9kZS5jaGlsZE5vZGVzO1xuICAgICAgICB9LFxuXG4gICAgICAgIGVtcHR5Tm9kZTogZnVuY3Rpb24obm9kZSkge1xuICAgICAgICAgICAgaWYgKCFpc1N0YXJ0Q29tbWVudChub2RlKSlcbiAgICAgICAgICAgICAgICBrby51dGlscy5lbXB0eURvbU5vZGUobm9kZSk7XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgdmlydHVhbENoaWxkcmVuID0ga28udmlydHVhbEVsZW1lbnRzLmNoaWxkTm9kZXMobm9kZSk7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGogPSB2aXJ0dWFsQ2hpbGRyZW4ubGVuZ3RoOyBpIDwgajsgaSsrKVxuICAgICAgICAgICAgICAgICAgICBrby5yZW1vdmVOb2RlKHZpcnR1YWxDaGlsZHJlbltpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgc2V0RG9tTm9kZUNoaWxkcmVuOiBmdW5jdGlvbihub2RlLCBjaGlsZE5vZGVzKSB7XG4gICAgICAgICAgICBpZiAoIWlzU3RhcnRDb21tZW50KG5vZGUpKVxuICAgICAgICAgICAgICAgIGtvLnV0aWxzLnNldERvbU5vZGVDaGlsZHJlbihub2RlLCBjaGlsZE5vZGVzKTtcbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGtvLnZpcnR1YWxFbGVtZW50cy5lbXB0eU5vZGUobm9kZSk7XG4gICAgICAgICAgICAgICAgdmFyIGVuZENvbW1lbnROb2RlID0gbm9kZS5uZXh0U2libGluZzsgLy8gTXVzdCBiZSB0aGUgbmV4dCBzaWJsaW5nLCBhcyB3ZSBqdXN0IGVtcHRpZWQgdGhlIGNoaWxkcmVuXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGogPSBjaGlsZE5vZGVzLmxlbmd0aDsgaSA8IGo7IGkrKylcbiAgICAgICAgICAgICAgICAgICAgZW5kQ29tbWVudE5vZGUucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoY2hpbGROb2Rlc1tpXSwgZW5kQ29tbWVudE5vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIHByZXBlbmQ6IGZ1bmN0aW9uKGNvbnRhaW5lck5vZGUsIG5vZGVUb1ByZXBlbmQpIHtcbiAgICAgICAgICAgIGlmICghaXNTdGFydENvbW1lbnQoY29udGFpbmVyTm9kZSkpIHtcbiAgICAgICAgICAgICAgICBpZiAoY29udGFpbmVyTm9kZS5maXJzdENoaWxkKVxuICAgICAgICAgICAgICAgICAgICBjb250YWluZXJOb2RlLmluc2VydEJlZm9yZShub2RlVG9QcmVwZW5kLCBjb250YWluZXJOb2RlLmZpcnN0Q2hpbGQpO1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgY29udGFpbmVyTm9kZS5hcHBlbmRDaGlsZChub2RlVG9QcmVwZW5kKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gU3RhcnQgY29tbWVudHMgbXVzdCBhbHdheXMgaGF2ZSBhIHBhcmVudCBhbmQgYXQgbGVhc3Qgb25lIGZvbGxvd2luZyBzaWJsaW5nICh0aGUgZW5kIGNvbW1lbnQpXG4gICAgICAgICAgICAgICAgY29udGFpbmVyTm9kZS5wYXJlbnROb2RlLmluc2VydEJlZm9yZShub2RlVG9QcmVwZW5kLCBjb250YWluZXJOb2RlLm5leHRTaWJsaW5nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBpbnNlcnRBZnRlcjogZnVuY3Rpb24oY29udGFpbmVyTm9kZSwgbm9kZVRvSW5zZXJ0LCBpbnNlcnRBZnRlck5vZGUpIHtcbiAgICAgICAgICAgIGlmICghaW5zZXJ0QWZ0ZXJOb2RlKSB7XG4gICAgICAgICAgICAgICAga28udmlydHVhbEVsZW1lbnRzLnByZXBlbmQoY29udGFpbmVyTm9kZSwgbm9kZVRvSW5zZXJ0KTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIWlzU3RhcnRDb21tZW50KGNvbnRhaW5lck5vZGUpKSB7XG4gICAgICAgICAgICAgICAgLy8gSW5zZXJ0IGFmdGVyIGluc2VydGlvbiBwb2ludFxuICAgICAgICAgICAgICAgIGlmIChpbnNlcnRBZnRlck5vZGUubmV4dFNpYmxpbmcpXG4gICAgICAgICAgICAgICAgICAgIGNvbnRhaW5lck5vZGUuaW5zZXJ0QmVmb3JlKG5vZGVUb0luc2VydCwgaW5zZXJ0QWZ0ZXJOb2RlLm5leHRTaWJsaW5nKTtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIGNvbnRhaW5lck5vZGUuYXBwZW5kQ2hpbGQobm9kZVRvSW5zZXJ0KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gQ2hpbGRyZW4gb2Ygc3RhcnQgY29tbWVudHMgbXVzdCBhbHdheXMgaGF2ZSBhIHBhcmVudCBhbmQgYXQgbGVhc3Qgb25lIGZvbGxvd2luZyBzaWJsaW5nICh0aGUgZW5kIGNvbW1lbnQpXG4gICAgICAgICAgICAgICAgY29udGFpbmVyTm9kZS5wYXJlbnROb2RlLmluc2VydEJlZm9yZShub2RlVG9JbnNlcnQsIGluc2VydEFmdGVyTm9kZS5uZXh0U2libGluZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgZmlyc3RDaGlsZDogZnVuY3Rpb24obm9kZSkge1xuICAgICAgICAgICAgaWYgKCFpc1N0YXJ0Q29tbWVudChub2RlKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gbm9kZS5maXJzdENoaWxkO1xuICAgICAgICAgICAgaWYgKCFub2RlLm5leHRTaWJsaW5nIHx8IGlzRW5kQ29tbWVudChub2RlLm5leHRTaWJsaW5nKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIHJldHVybiBub2RlLm5leHRTaWJsaW5nO1xuICAgICAgICB9LFxuXG4gICAgICAgIG5leHRTaWJsaW5nOiBmdW5jdGlvbihub2RlKSB7XG4gICAgICAgICAgICBpZiAoaXNTdGFydENvbW1lbnQobm9kZSkpXG4gICAgICAgICAgICAgICAgbm9kZSA9IGdldE1hdGNoaW5nRW5kQ29tbWVudChub2RlKTtcbiAgICAgICAgICAgIGlmIChub2RlLm5leHRTaWJsaW5nICYmIGlzRW5kQ29tbWVudChub2RlLm5leHRTaWJsaW5nKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIHJldHVybiBub2RlLm5leHRTaWJsaW5nO1xuICAgICAgICB9LFxuXG4gICAgICAgIGhhc0JpbmRpbmdWYWx1ZTogaXNTdGFydENvbW1lbnQsXG5cbiAgICAgICAgdmlydHVhbE5vZGVCaW5kaW5nVmFsdWU6IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgICAgICAgIHZhciByZWdleE1hdGNoID0gKGNvbW1lbnROb2Rlc0hhdmVUZXh0UHJvcGVydHkgPyBub2RlLnRleHQgOiBub2RlLm5vZGVWYWx1ZSkubWF0Y2goc3RhcnRDb21tZW50UmVnZXgpO1xuICAgICAgICAgICAgcmV0dXJuIHJlZ2V4TWF0Y2ggPyByZWdleE1hdGNoWzFdIDogbnVsbDtcbiAgICAgICAgfSxcblxuICAgICAgICBub3JtYWxpc2VWaXJ0dWFsRWxlbWVudERvbVN0cnVjdHVyZTogZnVuY3Rpb24oZWxlbWVudFZlcmlmaWVkKSB7XG4gICAgICAgICAgICAvLyBXb3JrYXJvdW5kIGZvciBodHRwczovL2dpdGh1Yi5jb20vU3RldmVTYW5kZXJzb24va25vY2tvdXQvaXNzdWVzLzE1NVxuICAgICAgICAgICAgLy8gKElFIDw9IDggb3IgSUUgOSBxdWlya3MgbW9kZSBwYXJzZXMgeW91ciBIVE1MIHdlaXJkbHksIHRyZWF0aW5nIGNsb3NpbmcgPC9saT4gdGFncyBhcyBpZiB0aGV5IGRvbid0IGV4aXN0LCB0aGVyZWJ5IG1vdmluZyBjb21tZW50IG5vZGVzXG4gICAgICAgICAgICAvLyB0aGF0IGFyZSBkaXJlY3QgZGVzY2VuZGFudHMgb2YgPHVsPiBpbnRvIHRoZSBwcmVjZWRpbmcgPGxpPilcbiAgICAgICAgICAgIGlmICghaHRtbFRhZ3NXaXRoT3B0aW9uYWxseUNsb3NpbmdDaGlsZHJlbltrby51dGlscy50YWdOYW1lTG93ZXIoZWxlbWVudFZlcmlmaWVkKV0pXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuXG4gICAgICAgICAgICAvLyBTY2FuIGltbWVkaWF0ZSBjaGlsZHJlbiB0byBzZWUgaWYgdGhleSBjb250YWluIHVuYmFsYW5jZWQgY29tbWVudCB0YWdzLiBJZiB0aGV5IGRvLCB0aG9zZSBjb21tZW50IHRhZ3NcbiAgICAgICAgICAgIC8vIG11c3QgYmUgaW50ZW5kZWQgdG8gYXBwZWFyICphZnRlciogdGhhdCBjaGlsZCwgc28gbW92ZSB0aGVtIHRoZXJlLlxuICAgICAgICAgICAgdmFyIGNoaWxkTm9kZSA9IGVsZW1lbnRWZXJpZmllZC5maXJzdENoaWxkO1xuICAgICAgICAgICAgaWYgKGNoaWxkTm9kZSkge1xuICAgICAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNoaWxkTm9kZS5ub2RlVHlwZSA9PT0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHVuYmFsYW5jZWRUYWdzID0gZ2V0VW5iYWxhbmNlZENoaWxkVGFncyhjaGlsZE5vZGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHVuYmFsYW5jZWRUYWdzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRml4IHVwIHRoZSBET00gYnkgbW92aW5nIHRoZSB1bmJhbGFuY2VkIHRhZ3MgdG8gd2hlcmUgdGhleSBtb3N0IGxpa2VseSB3ZXJlIGludGVuZGVkIHRvIGJlIHBsYWNlZCAtICphZnRlciogdGhlIGNoaWxkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5vZGVUb0luc2VydEJlZm9yZSA9IGNoaWxkTm9kZS5uZXh0U2libGluZztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHVuYmFsYW5jZWRUYWdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChub2RlVG9JbnNlcnRCZWZvcmUpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50VmVyaWZpZWQuaW5zZXJ0QmVmb3JlKHVuYmFsYW5jZWRUYWdzW2ldLCBub2RlVG9JbnNlcnRCZWZvcmUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50VmVyaWZpZWQuYXBwZW5kQ2hpbGQodW5iYWxhbmNlZFRhZ3NbaV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gd2hpbGUgKGNoaWxkTm9kZSA9IGNoaWxkTm9kZS5uZXh0U2libGluZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xufSkoKTtcbmtvLmV4cG9ydFN5bWJvbCgndmlydHVhbEVsZW1lbnRzJywga28udmlydHVhbEVsZW1lbnRzKTtcbmtvLmV4cG9ydFN5bWJvbCgndmlydHVhbEVsZW1lbnRzLmFsbG93ZWRCaW5kaW5ncycsIGtvLnZpcnR1YWxFbGVtZW50cy5hbGxvd2VkQmluZGluZ3MpO1xua28uZXhwb3J0U3ltYm9sKCd2aXJ0dWFsRWxlbWVudHMuZW1wdHlOb2RlJywga28udmlydHVhbEVsZW1lbnRzLmVtcHR5Tm9kZSk7XG4vL2tvLmV4cG9ydFN5bWJvbCgndmlydHVhbEVsZW1lbnRzLmZpcnN0Q2hpbGQnLCBrby52aXJ0dWFsRWxlbWVudHMuZmlyc3RDaGlsZCk7ICAgICAvLyBmaXJzdENoaWxkIGlzIG5vdCBtaW5pZmllZFxua28uZXhwb3J0U3ltYm9sKCd2aXJ0dWFsRWxlbWVudHMuaW5zZXJ0QWZ0ZXInLCBrby52aXJ0dWFsRWxlbWVudHMuaW5zZXJ0QWZ0ZXIpO1xuLy9rby5leHBvcnRTeW1ib2woJ3ZpcnR1YWxFbGVtZW50cy5uZXh0U2libGluZycsIGtvLnZpcnR1YWxFbGVtZW50cy5uZXh0U2libGluZyk7ICAgLy8gbmV4dFNpYmxpbmcgaXMgbm90IG1pbmlmaWVkXG5rby5leHBvcnRTeW1ib2woJ3ZpcnR1YWxFbGVtZW50cy5wcmVwZW5kJywga28udmlydHVhbEVsZW1lbnRzLnByZXBlbmQpO1xua28uZXhwb3J0U3ltYm9sKCd2aXJ0dWFsRWxlbWVudHMuc2V0RG9tTm9kZUNoaWxkcmVuJywga28udmlydHVhbEVsZW1lbnRzLnNldERvbU5vZGVDaGlsZHJlbik7XG4oZnVuY3Rpb24oKSB7XG4gICAgdmFyIGRlZmF1bHRCaW5kaW5nQXR0cmlidXRlTmFtZSA9IFwiZGF0YS1iaW5kXCI7XG5cbiAgICBrby5iaW5kaW5nUHJvdmlkZXIgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5iaW5kaW5nQ2FjaGUgPSB7fTtcbiAgICB9O1xuXG4gICAga28udXRpbHMuZXh0ZW5kKGtvLmJpbmRpbmdQcm92aWRlci5wcm90b3R5cGUsIHtcbiAgICAgICAgJ25vZGVIYXNCaW5kaW5ncyc6IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgICAgICAgIHN3aXRjaCAobm9kZS5ub2RlVHlwZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgMTogLy8gRWxlbWVudFxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbm9kZS5nZXRBdHRyaWJ1dGUoZGVmYXVsdEJpbmRpbmdBdHRyaWJ1dGVOYW1lKSAhPSBudWxsXG4gICAgICAgICAgICAgICAgICAgICAgICB8fCBrby5jb21wb25lbnRzWydnZXRDb21wb25lbnROYW1lRm9yTm9kZSddKG5vZGUpO1xuICAgICAgICAgICAgICAgIGNhc2UgODogLy8gQ29tbWVudCBub2RlXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBrby52aXJ0dWFsRWxlbWVudHMuaGFzQmluZGluZ1ZhbHVlKG5vZGUpO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6IHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAnZ2V0QmluZGluZ3MnOiBmdW5jdGlvbihub2RlLCBiaW5kaW5nQ29udGV4dCkge1xuICAgICAgICAgICAgdmFyIGJpbmRpbmdzU3RyaW5nID0gdGhpc1snZ2V0QmluZGluZ3NTdHJpbmcnXShub2RlLCBiaW5kaW5nQ29udGV4dCksXG4gICAgICAgICAgICAgICAgcGFyc2VkQmluZGluZ3MgPSBiaW5kaW5nc1N0cmluZyA/IHRoaXNbJ3BhcnNlQmluZGluZ3NTdHJpbmcnXShiaW5kaW5nc1N0cmluZywgYmluZGluZ0NvbnRleHQsIG5vZGUpIDogbnVsbDtcbiAgICAgICAgICAgIHJldHVybiBrby5jb21wb25lbnRzLmFkZEJpbmRpbmdzRm9yQ3VzdG9tRWxlbWVudChwYXJzZWRCaW5kaW5ncywgbm9kZSwgYmluZGluZ0NvbnRleHQsIC8qIHZhbHVlQWNjZXNzb3JzICovIGZhbHNlKTtcbiAgICAgICAgfSxcblxuICAgICAgICAnZ2V0QmluZGluZ0FjY2Vzc29ycyc6IGZ1bmN0aW9uKG5vZGUsIGJpbmRpbmdDb250ZXh0KSB7XG4gICAgICAgICAgICB2YXIgYmluZGluZ3NTdHJpbmcgPSB0aGlzWydnZXRCaW5kaW5nc1N0cmluZyddKG5vZGUsIGJpbmRpbmdDb250ZXh0KSxcbiAgICAgICAgICAgICAgICBwYXJzZWRCaW5kaW5ncyA9IGJpbmRpbmdzU3RyaW5nID8gdGhpc1sncGFyc2VCaW5kaW5nc1N0cmluZyddKGJpbmRpbmdzU3RyaW5nLCBiaW5kaW5nQ29udGV4dCwgbm9kZSwgeyAndmFsdWVBY2Nlc3NvcnMnOiB0cnVlIH0pIDogbnVsbDtcbiAgICAgICAgICAgIHJldHVybiBrby5jb21wb25lbnRzLmFkZEJpbmRpbmdzRm9yQ3VzdG9tRWxlbWVudChwYXJzZWRCaW5kaW5ncywgbm9kZSwgYmluZGluZ0NvbnRleHQsIC8qIHZhbHVlQWNjZXNzb3JzICovIHRydWUpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8vIFRoZSBmb2xsb3dpbmcgZnVuY3Rpb24gaXMgb25seSB1c2VkIGludGVybmFsbHkgYnkgdGhpcyBkZWZhdWx0IHByb3ZpZGVyLlxuICAgICAgICAvLyBJdCdzIG5vdCBwYXJ0IG9mIHRoZSBpbnRlcmZhY2UgZGVmaW5pdGlvbiBmb3IgYSBnZW5lcmFsIGJpbmRpbmcgcHJvdmlkZXIuXG4gICAgICAgICdnZXRCaW5kaW5nc1N0cmluZyc6IGZ1bmN0aW9uKG5vZGUsIGJpbmRpbmdDb250ZXh0KSB7XG4gICAgICAgICAgICBzd2l0Y2ggKG5vZGUubm9kZVR5cGUpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDE6IHJldHVybiBub2RlLmdldEF0dHJpYnV0ZShkZWZhdWx0QmluZGluZ0F0dHJpYnV0ZU5hbWUpOyAgIC8vIEVsZW1lbnRcbiAgICAgICAgICAgICAgICBjYXNlIDg6IHJldHVybiBrby52aXJ0dWFsRWxlbWVudHMudmlydHVhbE5vZGVCaW5kaW5nVmFsdWUobm9kZSk7IC8vIENvbW1lbnQgbm9kZVxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6IHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8vIFRoZSBmb2xsb3dpbmcgZnVuY3Rpb24gaXMgb25seSB1c2VkIGludGVybmFsbHkgYnkgdGhpcyBkZWZhdWx0IHByb3ZpZGVyLlxuICAgICAgICAvLyBJdCdzIG5vdCBwYXJ0IG9mIHRoZSBpbnRlcmZhY2UgZGVmaW5pdGlvbiBmb3IgYSBnZW5lcmFsIGJpbmRpbmcgcHJvdmlkZXIuXG4gICAgICAgICdwYXJzZUJpbmRpbmdzU3RyaW5nJzogZnVuY3Rpb24oYmluZGluZ3NTdHJpbmcsIGJpbmRpbmdDb250ZXh0LCBub2RlLCBvcHRpb25zKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHZhciBiaW5kaW5nRnVuY3Rpb24gPSBjcmVhdGVCaW5kaW5nc1N0cmluZ0V2YWx1YXRvclZpYUNhY2hlKGJpbmRpbmdzU3RyaW5nLCB0aGlzLmJpbmRpbmdDYWNoZSwgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGJpbmRpbmdGdW5jdGlvbihiaW5kaW5nQ29udGV4dCwgbm9kZSk7XG4gICAgICAgICAgICB9IGNhdGNoIChleCkge1xuICAgICAgICAgICAgICAgIGV4Lm1lc3NhZ2UgPSBcIlVuYWJsZSB0byBwYXJzZSBiaW5kaW5ncy5cXG5CaW5kaW5ncyB2YWx1ZTogXCIgKyBiaW5kaW5nc1N0cmluZyArIFwiXFxuTWVzc2FnZTogXCIgKyBleC5tZXNzYWdlO1xuICAgICAgICAgICAgICAgIHRocm93IGV4O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICBrby5iaW5kaW5nUHJvdmlkZXJbJ2luc3RhbmNlJ10gPSBuZXcga28uYmluZGluZ1Byb3ZpZGVyKCk7XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVCaW5kaW5nc1N0cmluZ0V2YWx1YXRvclZpYUNhY2hlKGJpbmRpbmdzU3RyaW5nLCBjYWNoZSwgb3B0aW9ucykge1xuICAgICAgICB2YXIgY2FjaGVLZXkgPSBiaW5kaW5nc1N0cmluZyArIChvcHRpb25zICYmIG9wdGlvbnNbJ3ZhbHVlQWNjZXNzb3JzJ10gfHwgJycpO1xuICAgICAgICByZXR1cm4gY2FjaGVbY2FjaGVLZXldXG4gICAgICAgICAgICB8fCAoY2FjaGVbY2FjaGVLZXldID0gY3JlYXRlQmluZGluZ3NTdHJpbmdFdmFsdWF0b3IoYmluZGluZ3NTdHJpbmcsIG9wdGlvbnMpKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVCaW5kaW5nc1N0cmluZ0V2YWx1YXRvcihiaW5kaW5nc1N0cmluZywgb3B0aW9ucykge1xuICAgICAgICAvLyBCdWlsZCB0aGUgc291cmNlIGZvciBhIGZ1bmN0aW9uIHRoYXQgZXZhbHVhdGVzIFwiZXhwcmVzc2lvblwiXG4gICAgICAgIC8vIEZvciBlYWNoIHNjb3BlIHZhcmlhYmxlLCBhZGQgYW4gZXh0cmEgbGV2ZWwgb2YgXCJ3aXRoXCIgbmVzdGluZ1xuICAgICAgICAvLyBFeGFtcGxlIHJlc3VsdDogd2l0aChzYzEpIHsgd2l0aChzYzApIHsgcmV0dXJuIChleHByZXNzaW9uKSB9IH1cbiAgICAgICAgdmFyIHJld3JpdHRlbkJpbmRpbmdzID0ga28uZXhwcmVzc2lvblJld3JpdGluZy5wcmVQcm9jZXNzQmluZGluZ3MoYmluZGluZ3NTdHJpbmcsIG9wdGlvbnMpLFxuICAgICAgICAgICAgZnVuY3Rpb25Cb2R5ID0gXCJ3aXRoKCRjb250ZXh0KXt3aXRoKCRkYXRhfHx7fSl7cmV0dXJue1wiICsgcmV3cml0dGVuQmluZGluZ3MgKyBcIn19fVwiO1xuICAgICAgICByZXR1cm4gbmV3IEZ1bmN0aW9uKFwiJGNvbnRleHRcIiwgXCIkZWxlbWVudFwiLCBmdW5jdGlvbkJvZHkpO1xuICAgIH1cbn0pKCk7XG5cbmtvLmV4cG9ydFN5bWJvbCgnYmluZGluZ1Byb3ZpZGVyJywga28uYmluZGluZ1Byb3ZpZGVyKTtcbihmdW5jdGlvbiAoKSB7XG4gICAga28uYmluZGluZ0hhbmRsZXJzID0ge307XG5cbiAgICAvLyBUaGUgZm9sbG93aW5nIGVsZW1lbnQgdHlwZXMgd2lsbCBub3QgYmUgcmVjdXJzZWQgaW50byBkdXJpbmcgYmluZGluZy5cbiAgICB2YXIgYmluZGluZ0RvZXNOb3RSZWN1cnNlSW50b0VsZW1lbnRUeXBlcyA9IHtcbiAgICAgICAgLy8gRG9uJ3Qgd2FudCBiaW5kaW5ncyB0aGF0IG9wZXJhdGUgb24gdGV4dCBub2RlcyB0byBtdXRhdGUgPHNjcmlwdD4gYW5kIDx0ZXh0YXJlYT4gY29udGVudHMsXG4gICAgICAgIC8vIGJlY2F1c2UgaXQncyB1bmV4cGVjdGVkIGFuZCBhIHBvdGVudGlhbCBYU1MgaXNzdWUuXG4gICAgICAgIC8vIEFsc28gYmluZGluZ3Mgc2hvdWxkIG5vdCBvcGVyYXRlIG9uIDx0ZW1wbGF0ZT4gZWxlbWVudHMgc2luY2UgdGhpcyBicmVha3MgaW4gSW50ZXJuZXQgRXhwbG9yZXJcbiAgICAgICAgLy8gYW5kIGJlY2F1c2Ugc3VjaCBlbGVtZW50cycgY29udGVudHMgYXJlIGFsd2F5cyBpbnRlbmRlZCB0byBiZSBib3VuZCBpbiBhIGRpZmZlcmVudCBjb250ZXh0XG4gICAgICAgIC8vIGZyb20gd2hlcmUgdGhleSBhcHBlYXIgaW4gdGhlIGRvY3VtZW50LlxuICAgICAgICAnc2NyaXB0JzogdHJ1ZSxcbiAgICAgICAgJ3RleHRhcmVhJzogdHJ1ZSxcbiAgICAgICAgJ3RlbXBsYXRlJzogdHJ1ZVxuICAgIH07XG5cbiAgICAvLyBVc2UgYW4gb3ZlcnJpZGFibGUgbWV0aG9kIGZvciByZXRyaWV2aW5nIGJpbmRpbmcgaGFuZGxlcnMgc28gdGhhdCBhIHBsdWdpbnMgbWF5IHN1cHBvcnQgZHluYW1pY2FsbHkgY3JlYXRlZCBoYW5kbGVyc1xuICAgIGtvWydnZXRCaW5kaW5nSGFuZGxlciddID0gZnVuY3Rpb24oYmluZGluZ0tleSkge1xuICAgICAgICByZXR1cm4ga28uYmluZGluZ0hhbmRsZXJzW2JpbmRpbmdLZXldO1xuICAgIH07XG5cbiAgICAvLyBUaGUga28uYmluZGluZ0NvbnRleHQgY29uc3RydWN0b3IgaXMgb25seSBjYWxsZWQgZGlyZWN0bHkgdG8gY3JlYXRlIHRoZSByb290IGNvbnRleHQuIEZvciBjaGlsZFxuICAgIC8vIGNvbnRleHRzLCB1c2UgYmluZGluZ0NvbnRleHQuY3JlYXRlQ2hpbGRDb250ZXh0IG9yIGJpbmRpbmdDb250ZXh0LmV4dGVuZC5cbiAgICBrby5iaW5kaW5nQ29udGV4dCA9IGZ1bmN0aW9uKGRhdGFJdGVtT3JBY2Nlc3NvciwgcGFyZW50Q29udGV4dCwgZGF0YUl0ZW1BbGlhcywgZXh0ZW5kQ2FsbGJhY2ssIG9wdGlvbnMpIHtcblxuICAgICAgICAvLyBUaGUgYmluZGluZyBjb250ZXh0IG9iamVjdCBpbmNsdWRlcyBzdGF0aWMgcHJvcGVydGllcyBmb3IgdGhlIGN1cnJlbnQsIHBhcmVudCwgYW5kIHJvb3QgdmlldyBtb2RlbHMuXG4gICAgICAgIC8vIElmIGEgdmlldyBtb2RlbCBpcyBhY3R1YWxseSBzdG9yZWQgaW4gYW4gb2JzZXJ2YWJsZSwgdGhlIGNvcnJlc3BvbmRpbmcgYmluZGluZyBjb250ZXh0IG9iamVjdCwgYW5kXG4gICAgICAgIC8vIGFueSBjaGlsZCBjb250ZXh0cywgbXVzdCBiZSB1cGRhdGVkIHdoZW4gdGhlIHZpZXcgbW9kZWwgaXMgY2hhbmdlZC5cbiAgICAgICAgZnVuY3Rpb24gdXBkYXRlQ29udGV4dCgpIHtcbiAgICAgICAgICAgIC8vIE1vc3Qgb2YgdGhlIHRpbWUsIHRoZSBjb250ZXh0IHdpbGwgZGlyZWN0bHkgZ2V0IGEgdmlldyBtb2RlbCBvYmplY3QsIGJ1dCBpZiBhIGZ1bmN0aW9uIGlzIGdpdmVuLFxuICAgICAgICAgICAgLy8gd2UgY2FsbCB0aGUgZnVuY3Rpb24gdG8gcmV0cmlldmUgdGhlIHZpZXcgbW9kZWwuIElmIHRoZSBmdW5jdGlvbiBhY2Nlc3NlcyBhbnkgb2JzZXJ2YWJsZXMgb3IgcmV0dXJuc1xuICAgICAgICAgICAgLy8gYW4gb2JzZXJ2YWJsZSwgdGhlIGRlcGVuZGVuY3kgaXMgdHJhY2tlZCwgYW5kIHRob3NlIG9ic2VydmFibGVzIGNhbiBsYXRlciBjYXVzZSB0aGUgYmluZGluZ1xuICAgICAgICAgICAgLy8gY29udGV4dCB0byBiZSB1cGRhdGVkLlxuICAgICAgICAgICAgdmFyIGRhdGFJdGVtT3JPYnNlcnZhYmxlID0gaXNGdW5jID8gZGF0YUl0ZW1PckFjY2Vzc29yKCkgOiBkYXRhSXRlbU9yQWNjZXNzb3IsXG4gICAgICAgICAgICAgICAgZGF0YUl0ZW0gPSBrby51dGlscy51bndyYXBPYnNlcnZhYmxlKGRhdGFJdGVtT3JPYnNlcnZhYmxlKTtcblxuICAgICAgICAgICAgaWYgKHBhcmVudENvbnRleHQpIHtcbiAgICAgICAgICAgICAgICAvLyBXaGVuIGEgXCJwYXJlbnRcIiBjb250ZXh0IGlzIGdpdmVuLCByZWdpc3RlciBhIGRlcGVuZGVuY3kgb24gdGhlIHBhcmVudCBjb250ZXh0LiBUaHVzIHdoZW5ldmVyIHRoZVxuICAgICAgICAgICAgICAgIC8vIHBhcmVudCBjb250ZXh0IGlzIHVwZGF0ZWQsIHRoaXMgY29udGV4dCB3aWxsIGFsc28gYmUgdXBkYXRlZC5cbiAgICAgICAgICAgICAgICBpZiAocGFyZW50Q29udGV4dC5fc3Vic2NyaWJhYmxlKVxuICAgICAgICAgICAgICAgICAgICBwYXJlbnRDb250ZXh0Ll9zdWJzY3JpYmFibGUoKTtcblxuICAgICAgICAgICAgICAgIC8vIENvcHkgJHJvb3QgYW5kIGFueSBjdXN0b20gcHJvcGVydGllcyBmcm9tIHRoZSBwYXJlbnQgY29udGV4dFxuICAgICAgICAgICAgICAgIGtvLnV0aWxzLmV4dGVuZChzZWxmLCBwYXJlbnRDb250ZXh0KTtcblxuICAgICAgICAgICAgICAgIC8vIEJlY2F1c2UgdGhlIGFib3ZlIGNvcHkgb3ZlcndyaXRlcyBvdXIgb3duIHByb3BlcnRpZXMsIHdlIG5lZWQgdG8gcmVzZXQgdGhlbS5cbiAgICAgICAgICAgICAgICBzZWxmLl9zdWJzY3JpYmFibGUgPSBzdWJzY3JpYmFibGU7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHNlbGZbJyRwYXJlbnRzJ10gPSBbXTtcbiAgICAgICAgICAgICAgICBzZWxmWyckcm9vdCddID0gZGF0YUl0ZW07XG5cbiAgICAgICAgICAgICAgICAvLyBFeHBvcnQgJ2tvJyBpbiB0aGUgYmluZGluZyBjb250ZXh0IHNvIGl0IHdpbGwgYmUgYXZhaWxhYmxlIGluIGJpbmRpbmdzIGFuZCB0ZW1wbGF0ZXNcbiAgICAgICAgICAgICAgICAvLyBldmVuIGlmICdrbycgaXNuJ3QgZXhwb3J0ZWQgYXMgYSBnbG9iYWwsIHN1Y2ggYXMgd2hlbiB1c2luZyBhbiBBTUQgbG9hZGVyLlxuICAgICAgICAgICAgICAgIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vU3RldmVTYW5kZXJzb24va25vY2tvdXQvaXNzdWVzLzQ5MFxuICAgICAgICAgICAgICAgIHNlbGZbJ2tvJ10gPSBrbztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNlbGZbJyRyYXdEYXRhJ10gPSBkYXRhSXRlbU9yT2JzZXJ2YWJsZTtcbiAgICAgICAgICAgIHNlbGZbJyRkYXRhJ10gPSBkYXRhSXRlbTtcbiAgICAgICAgICAgIGlmIChkYXRhSXRlbUFsaWFzKVxuICAgICAgICAgICAgICAgIHNlbGZbZGF0YUl0ZW1BbGlhc10gPSBkYXRhSXRlbTtcblxuICAgICAgICAgICAgLy8gVGhlIGV4dGVuZENhbGxiYWNrIGZ1bmN0aW9uIGlzIHByb3ZpZGVkIHdoZW4gY3JlYXRpbmcgYSBjaGlsZCBjb250ZXh0IG9yIGV4dGVuZGluZyBhIGNvbnRleHQuXG4gICAgICAgICAgICAvLyBJdCBoYW5kbGVzIHRoZSBzcGVjaWZpYyBhY3Rpb25zIG5lZWRlZCB0byBmaW5pc2ggc2V0dGluZyB1cCB0aGUgYmluZGluZyBjb250ZXh0LiBBY3Rpb25zIGluIHRoaXNcbiAgICAgICAgICAgIC8vIGZ1bmN0aW9uIGNvdWxkIGFsc28gYWRkIGRlcGVuZGVuY2llcyB0byB0aGlzIGJpbmRpbmcgY29udGV4dC5cbiAgICAgICAgICAgIGlmIChleHRlbmRDYWxsYmFjaylcbiAgICAgICAgICAgICAgICBleHRlbmRDYWxsYmFjayhzZWxmLCBwYXJlbnRDb250ZXh0LCBkYXRhSXRlbSk7XG5cbiAgICAgICAgICAgIHJldHVybiBzZWxmWyckZGF0YSddO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGRpc3Bvc2VXaGVuKCkge1xuICAgICAgICAgICAgcmV0dXJuIG5vZGVzICYmICFrby51dGlscy5hbnlEb21Ob2RlSXNBdHRhY2hlZFRvRG9jdW1lbnQobm9kZXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzLFxuICAgICAgICAgICAgaXNGdW5jID0gdHlwZW9mKGRhdGFJdGVtT3JBY2Nlc3NvcikgPT0gXCJmdW5jdGlvblwiICYmICFrby5pc09ic2VydmFibGUoZGF0YUl0ZW1PckFjY2Vzc29yKSxcbiAgICAgICAgICAgIG5vZGVzLFxuICAgICAgICAgICAgc3Vic2NyaWJhYmxlO1xuXG4gICAgICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnNbJ2V4cG9ydERlcGVuZGVuY2llcyddKSB7XG4gICAgICAgICAgICAvLyBUaGUgXCJleHBvcnREZXBlbmRlbmNpZXNcIiBvcHRpb24gbWVhbnMgdGhhdCB0aGUgY2FsbGluZyBjb2RlIHdpbGwgdHJhY2sgYW55IGRlcGVuZGVuY2llcyBhbmQgcmUtY3JlYXRlXG4gICAgICAgICAgICAvLyB0aGUgYmluZGluZyBjb250ZXh0IHdoZW4gdGhleSBjaGFuZ2UuXG4gICAgICAgICAgICB1cGRhdGVDb250ZXh0KCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzdWJzY3JpYmFibGUgPSBrby5kZXBlbmRlbnRPYnNlcnZhYmxlKHVwZGF0ZUNvbnRleHQsIG51bGwsIHsgZGlzcG9zZVdoZW46IGRpc3Bvc2VXaGVuLCBkaXNwb3NlV2hlbk5vZGVJc1JlbW92ZWQ6IHRydWUgfSk7XG5cbiAgICAgICAgICAgIC8vIEF0IHRoaXMgcG9pbnQsIHRoZSBiaW5kaW5nIGNvbnRleHQgaGFzIGJlZW4gaW5pdGlhbGl6ZWQsIGFuZCB0aGUgXCJzdWJzY3JpYmFibGVcIiBjb21wdXRlZCBvYnNlcnZhYmxlIGlzXG4gICAgICAgICAgICAvLyBzdWJzY3JpYmVkIHRvIGFueSBvYnNlcnZhYmxlcyB0aGF0IHdlcmUgYWNjZXNzZWQgaW4gdGhlIHByb2Nlc3MuIElmIHRoZXJlIGlzIG5vdGhpbmcgdG8gdHJhY2ssIHRoZVxuICAgICAgICAgICAgLy8gY29tcHV0ZWQgd2lsbCBiZSBpbmFjdGl2ZSwgYW5kIHdlIGNhbiBzYWZlbHkgdGhyb3cgaXQgYXdheS4gSWYgaXQncyBhY3RpdmUsIHRoZSBjb21wdXRlZCBpcyBzdG9yZWQgaW5cbiAgICAgICAgICAgIC8vIHRoZSBjb250ZXh0IG9iamVjdC5cbiAgICAgICAgICAgIGlmIChzdWJzY3JpYmFibGUuaXNBY3RpdmUoKSkge1xuICAgICAgICAgICAgICAgIHNlbGYuX3N1YnNjcmliYWJsZSA9IHN1YnNjcmliYWJsZTtcblxuICAgICAgICAgICAgICAgIC8vIEFsd2F5cyBub3RpZnkgYmVjYXVzZSBldmVuIGlmIHRoZSBtb2RlbCAoJGRhdGEpIGhhc24ndCBjaGFuZ2VkLCBvdGhlciBjb250ZXh0IHByb3BlcnRpZXMgbWlnaHQgaGF2ZSBjaGFuZ2VkXG4gICAgICAgICAgICAgICAgc3Vic2NyaWJhYmxlWydlcXVhbGl0eUNvbXBhcmVyJ10gPSBudWxsO1xuXG4gICAgICAgICAgICAgICAgLy8gV2UgbmVlZCB0byBiZSBhYmxlIHRvIGRpc3Bvc2Ugb2YgdGhpcyBjb21wdXRlZCBvYnNlcnZhYmxlIHdoZW4gaXQncyBubyBsb25nZXIgbmVlZGVkLiBUaGlzIHdvdWxkIGJlXG4gICAgICAgICAgICAgICAgLy8gZWFzeSBpZiB3ZSBoYWQgYSBzaW5nbGUgbm9kZSB0byB3YXRjaCwgYnV0IGJpbmRpbmcgY29udGV4dHMgY2FuIGJlIHVzZWQgYnkgbWFueSBkaWZmZXJlbnQgbm9kZXMsIGFuZFxuICAgICAgICAgICAgICAgIC8vIHdlIGNhbm5vdCBhc3N1bWUgdGhhdCB0aG9zZSBub2RlcyBoYXZlIGFueSByZWxhdGlvbiB0byBlYWNoIG90aGVyLiBTbyBpbnN0ZWFkIHdlIHRyYWNrIGFueSBub2RlIHRoYXRcbiAgICAgICAgICAgICAgICAvLyB0aGUgY29udGV4dCBpcyBhdHRhY2hlZCB0bywgYW5kIGRpc3Bvc2UgdGhlIGNvbXB1dGVkIHdoZW4gYWxsIG9mIHRob3NlIG5vZGVzIGhhdmUgYmVlbiBjbGVhbmVkLlxuXG4gICAgICAgICAgICAgICAgLy8gQWRkIHByb3BlcnRpZXMgdG8gKnN1YnNjcmliYWJsZSogaW5zdGVhZCBvZiAqc2VsZiogYmVjYXVzZSBhbnkgcHJvcGVydGllcyBhZGRlZCB0byAqc2VsZiogbWF5IGJlIG92ZXJ3cml0dGVuIG9uIHVwZGF0ZXNcbiAgICAgICAgICAgICAgICBub2RlcyA9IFtdO1xuICAgICAgICAgICAgICAgIHN1YnNjcmliYWJsZS5fYWRkTm9kZSA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZXMucHVzaChub2RlKTtcbiAgICAgICAgICAgICAgICAgICAga28udXRpbHMuZG9tTm9kZURpc3Bvc2FsLmFkZERpc3Bvc2VDYWxsYmFjayhub2RlLCBmdW5jdGlvbihub2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBrby51dGlscy5hcnJheVJlbW92ZUl0ZW0obm9kZXMsIG5vZGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFub2Rlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdWJzY3JpYmFibGUuZGlzcG9zZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuX3N1YnNjcmliYWJsZSA9IHN1YnNjcmliYWJsZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIEV4dGVuZCB0aGUgYmluZGluZyBjb250ZXh0IGhpZXJhcmNoeSB3aXRoIGEgbmV3IHZpZXcgbW9kZWwgb2JqZWN0LiBJZiB0aGUgcGFyZW50IGNvbnRleHQgaXMgd2F0Y2hpbmdcbiAgICAvLyBhbnkgb2JzZXJ2YWJsZXMsIHRoZSBuZXcgY2hpbGQgY29udGV4dCB3aWxsIGF1dG9tYXRpY2FsbHkgZ2V0IGEgZGVwZW5kZW5jeSBvbiB0aGUgcGFyZW50IGNvbnRleHQuXG4gICAgLy8gQnV0IHRoaXMgZG9lcyBub3QgbWVhbiB0aGF0IHRoZSAkZGF0YSB2YWx1ZSBvZiB0aGUgY2hpbGQgY29udGV4dCB3aWxsIGFsc28gZ2V0IHVwZGF0ZWQuIElmIHRoZSBjaGlsZFxuICAgIC8vIHZpZXcgbW9kZWwgYWxzbyBkZXBlbmRzIG9uIHRoZSBwYXJlbnQgdmlldyBtb2RlbCwgeW91IG11c3QgcHJvdmlkZSBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0aGUgY29ycmVjdFxuICAgIC8vIHZpZXcgbW9kZWwgb24gZWFjaCB1cGRhdGUuXG4gICAga28uYmluZGluZ0NvbnRleHQucHJvdG90eXBlWydjcmVhdGVDaGlsZENvbnRleHQnXSA9IGZ1bmN0aW9uIChkYXRhSXRlbU9yQWNjZXNzb3IsIGRhdGFJdGVtQWxpYXMsIGV4dGVuZENhbGxiYWNrLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBuZXcga28uYmluZGluZ0NvbnRleHQoZGF0YUl0ZW1PckFjY2Vzc29yLCB0aGlzLCBkYXRhSXRlbUFsaWFzLCBmdW5jdGlvbihzZWxmLCBwYXJlbnRDb250ZXh0KSB7XG4gICAgICAgICAgICAvLyBFeHRlbmQgdGhlIGNvbnRleHQgaGllcmFyY2h5IGJ5IHNldHRpbmcgdGhlIGFwcHJvcHJpYXRlIHBvaW50ZXJzXG4gICAgICAgICAgICBzZWxmWyckcGFyZW50Q29udGV4dCddID0gcGFyZW50Q29udGV4dDtcbiAgICAgICAgICAgIHNlbGZbJyRwYXJlbnQnXSA9IHBhcmVudENvbnRleHRbJyRkYXRhJ107XG4gICAgICAgICAgICBzZWxmWyckcGFyZW50cyddID0gKHBhcmVudENvbnRleHRbJyRwYXJlbnRzJ10gfHwgW10pLnNsaWNlKDApO1xuICAgICAgICAgICAgc2VsZlsnJHBhcmVudHMnXS51bnNoaWZ0KHNlbGZbJyRwYXJlbnQnXSk7XG4gICAgICAgICAgICBpZiAoZXh0ZW5kQ2FsbGJhY2spXG4gICAgICAgICAgICAgICAgZXh0ZW5kQ2FsbGJhY2soc2VsZik7XG4gICAgICAgIH0sIG9wdGlvbnMpO1xuICAgIH07XG5cbiAgICAvLyBFeHRlbmQgdGhlIGJpbmRpbmcgY29udGV4dCB3aXRoIG5ldyBjdXN0b20gcHJvcGVydGllcy4gVGhpcyBkb2Vzbid0IGNoYW5nZSB0aGUgY29udGV4dCBoaWVyYXJjaHkuXG4gICAgLy8gU2ltaWxhcmx5IHRvIFwiY2hpbGRcIiBjb250ZXh0cywgcHJvdmlkZSBhIGZ1bmN0aW9uIGhlcmUgdG8gbWFrZSBzdXJlIHRoYXQgdGhlIGNvcnJlY3QgdmFsdWVzIGFyZSBzZXRcbiAgICAvLyB3aGVuIGFuIG9ic2VydmFibGUgdmlldyBtb2RlbCBpcyB1cGRhdGVkLlxuICAgIGtvLmJpbmRpbmdDb250ZXh0LnByb3RvdHlwZVsnZXh0ZW5kJ10gPSBmdW5jdGlvbihwcm9wZXJ0aWVzKSB7XG4gICAgICAgIC8vIElmIHRoZSBwYXJlbnQgY29udGV4dCByZWZlcmVuY2VzIGFuIG9ic2VydmFibGUgdmlldyBtb2RlbCwgXCJfc3Vic2NyaWJhYmxlXCIgd2lsbCBhbHdheXMgYmUgdGhlXG4gICAgICAgIC8vIGxhdGVzdCB2aWV3IG1vZGVsIG9iamVjdC4gSWYgbm90LCBcIl9zdWJzY3JpYmFibGVcIiBpc24ndCBzZXQsIGFuZCB3ZSBjYW4gdXNlIHRoZSBzdGF0aWMgXCIkZGF0YVwiIHZhbHVlLlxuICAgICAgICByZXR1cm4gbmV3IGtvLmJpbmRpbmdDb250ZXh0KHRoaXMuX3N1YnNjcmliYWJsZSB8fCB0aGlzWyckZGF0YSddLCB0aGlzLCBudWxsLCBmdW5jdGlvbihzZWxmLCBwYXJlbnRDb250ZXh0KSB7XG4gICAgICAgICAgICAvLyBUaGlzIFwiY2hpbGRcIiBjb250ZXh0IGRvZXNuJ3QgZGlyZWN0bHkgdHJhY2sgYSBwYXJlbnQgb2JzZXJ2YWJsZSB2aWV3IG1vZGVsLFxuICAgICAgICAgICAgLy8gc28gd2UgbmVlZCB0byBtYW51YWxseSBzZXQgdGhlICRyYXdEYXRhIHZhbHVlIHRvIG1hdGNoIHRoZSBwYXJlbnQuXG4gICAgICAgICAgICBzZWxmWyckcmF3RGF0YSddID0gcGFyZW50Q29udGV4dFsnJHJhd0RhdGEnXTtcbiAgICAgICAgICAgIGtvLnV0aWxzLmV4dGVuZChzZWxmLCB0eXBlb2YocHJvcGVydGllcykgPT0gXCJmdW5jdGlvblwiID8gcHJvcGVydGllcygpIDogcHJvcGVydGllcyk7XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICBrby5iaW5kaW5nQ29udGV4dC5wcm90b3R5cGUuY3JlYXRlU3RhdGljQ2hpbGRDb250ZXh0ID0gZnVuY3Rpb24gKGRhdGFJdGVtT3JBY2Nlc3NvciwgZGF0YUl0ZW1BbGlhcykge1xuICAgICAgICByZXR1cm4gdGhpc1snY3JlYXRlQ2hpbGRDb250ZXh0J10oZGF0YUl0ZW1PckFjY2Vzc29yLCBkYXRhSXRlbUFsaWFzLCBudWxsLCB7IFwiZXhwb3J0RGVwZW5kZW5jaWVzXCI6IHRydWUgfSk7XG4gICAgfTtcblxuICAgIC8vIFJldHVybnMgdGhlIHZhbHVlQWNjZXNvciBmdW5jdGlvbiBmb3IgYSBiaW5kaW5nIHZhbHVlXG4gICAgZnVuY3Rpb24gbWFrZVZhbHVlQWNjZXNzb3IodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8vIFJldHVybnMgdGhlIHZhbHVlIG9mIGEgdmFsdWVBY2Nlc3NvciBmdW5jdGlvblxuICAgIGZ1bmN0aW9uIGV2YWx1YXRlVmFsdWVBY2Nlc3Nvcih2YWx1ZUFjY2Vzc29yKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZUFjY2Vzc29yKCk7XG4gICAgfVxuXG4gICAgLy8gR2l2ZW4gYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgYmluZGluZ3MsIGNyZWF0ZSBhbmQgcmV0dXJuIGEgbmV3IG9iamVjdCB0aGF0IGNvbnRhaW5zXG4gICAgLy8gYmluZGluZyB2YWx1ZS1hY2Nlc3NvcnMgZnVuY3Rpb25zLiBFYWNoIGFjY2Vzc29yIGZ1bmN0aW9uIGNhbGxzIHRoZSBvcmlnaW5hbCBmdW5jdGlvblxuICAgIC8vIHNvIHRoYXQgaXQgYWx3YXlzIGdldHMgdGhlIGxhdGVzdCB2YWx1ZSBhbmQgYWxsIGRlcGVuZGVuY2llcyBhcmUgY2FwdHVyZWQuIFRoaXMgaXMgdXNlZFxuICAgIC8vIGJ5IGtvLmFwcGx5QmluZGluZ3NUb05vZGUgYW5kIGdldEJpbmRpbmdzQW5kTWFrZUFjY2Vzc29ycy5cbiAgICBmdW5jdGlvbiBtYWtlQWNjZXNzb3JzRnJvbUZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gICAgICAgIHJldHVybiBrby51dGlscy5vYmplY3RNYXAoa28uZGVwZW5kZW5jeURldGVjdGlvbi5pZ25vcmUoY2FsbGJhY2spLCBmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKClba2V5XTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIEdpdmVuIGEgYmluZGluZ3MgZnVuY3Rpb24gb3Igb2JqZWN0LCBjcmVhdGUgYW5kIHJldHVybiBhIG5ldyBvYmplY3QgdGhhdCBjb250YWluc1xuICAgIC8vIGJpbmRpbmcgdmFsdWUtYWNjZXNzb3JzIGZ1bmN0aW9ucy4gVGhpcyBpcyB1c2VkIGJ5IGtvLmFwcGx5QmluZGluZ3NUb05vZGUuXG4gICAgZnVuY3Rpb24gbWFrZUJpbmRpbmdBY2Nlc3NvcnMoYmluZGluZ3MsIGNvbnRleHQsIG5vZGUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBiaW5kaW5ncyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgcmV0dXJuIG1ha2VBY2Nlc3NvcnNGcm9tRnVuY3Rpb24oYmluZGluZ3MuYmluZChudWxsLCBjb250ZXh0LCBub2RlKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4ga28udXRpbHMub2JqZWN0TWFwKGJpbmRpbmdzLCBtYWtlVmFsdWVBY2Nlc3Nvcik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBUaGlzIGZ1bmN0aW9uIGlzIHVzZWQgaWYgdGhlIGJpbmRpbmcgcHJvdmlkZXIgZG9lc24ndCBpbmNsdWRlIGEgZ2V0QmluZGluZ0FjY2Vzc29ycyBmdW5jdGlvbi5cbiAgICAvLyBJdCBtdXN0IGJlIGNhbGxlZCB3aXRoICd0aGlzJyBzZXQgdG8gdGhlIHByb3ZpZGVyIGluc3RhbmNlLlxuICAgIGZ1bmN0aW9uIGdldEJpbmRpbmdzQW5kTWFrZUFjY2Vzc29ycyhub2RlLCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiBtYWtlQWNjZXNzb3JzRnJvbUZ1bmN0aW9uKHRoaXNbJ2dldEJpbmRpbmdzJ10uYmluZCh0aGlzLCBub2RlLCBjb250ZXh0KSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdmFsaWRhdGVUaGF0QmluZGluZ0lzQWxsb3dlZEZvclZpcnR1YWxFbGVtZW50cyhiaW5kaW5nTmFtZSkge1xuICAgICAgICB2YXIgdmFsaWRhdG9yID0ga28udmlydHVhbEVsZW1lbnRzLmFsbG93ZWRCaW5kaW5nc1tiaW5kaW5nTmFtZV07XG4gICAgICAgIGlmICghdmFsaWRhdG9yKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlIGJpbmRpbmcgJ1wiICsgYmluZGluZ05hbWUgKyBcIicgY2Fubm90IGJlIHVzZWQgd2l0aCB2aXJ0dWFsIGVsZW1lbnRzXCIpXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYXBwbHlCaW5kaW5nc1RvRGVzY2VuZGFudHNJbnRlcm5hbCAoYmluZGluZ0NvbnRleHQsIGVsZW1lbnRPclZpcnR1YWxFbGVtZW50LCBiaW5kaW5nQ29udGV4dHNNYXlEaWZmZXJGcm9tRG9tUGFyZW50RWxlbWVudCkge1xuICAgICAgICB2YXIgY3VycmVudENoaWxkLFxuICAgICAgICAgICAgbmV4dEluUXVldWUgPSBrby52aXJ0dWFsRWxlbWVudHMuZmlyc3RDaGlsZChlbGVtZW50T3JWaXJ0dWFsRWxlbWVudCksXG4gICAgICAgICAgICBwcm92aWRlciA9IGtvLmJpbmRpbmdQcm92aWRlclsnaW5zdGFuY2UnXSxcbiAgICAgICAgICAgIHByZXByb2Nlc3NOb2RlID0gcHJvdmlkZXJbJ3ByZXByb2Nlc3NOb2RlJ107XG5cbiAgICAgICAgLy8gUHJlcHJvY2Vzc2luZyBhbGxvd3MgYSBiaW5kaW5nIHByb3ZpZGVyIHRvIG11dGF0ZSBhIG5vZGUgYmVmb3JlIGJpbmRpbmdzIGFyZSBhcHBsaWVkIHRvIGl0LiBGb3IgZXhhbXBsZSBpdCdzXG4gICAgICAgIC8vIHBvc3NpYmxlIHRvIGluc2VydCBuZXcgc2libGluZ3MgYWZ0ZXIgaXQsIGFuZC9vciByZXBsYWNlIHRoZSBub2RlIHdpdGggYSBkaWZmZXJlbnQgb25lLiBUaGlzIGNhbiBiZSB1c2VkIHRvXG4gICAgICAgIC8vIGltcGxlbWVudCBjdXN0b20gYmluZGluZyBzeW50YXhlcywgc3VjaCBhcyB7eyB2YWx1ZSB9fSBmb3Igc3RyaW5nIGludGVycG9sYXRpb24sIG9yIGN1c3RvbSBlbGVtZW50IHR5cGVzIHRoYXRcbiAgICAgICAgLy8gdHJpZ2dlciBpbnNlcnRpb24gb2YgPHRlbXBsYXRlPiBjb250ZW50cyBhdCB0aGF0IHBvaW50IGluIHRoZSBkb2N1bWVudC5cbiAgICAgICAgaWYgKHByZXByb2Nlc3NOb2RlKSB7XG4gICAgICAgICAgICB3aGlsZSAoY3VycmVudENoaWxkID0gbmV4dEluUXVldWUpIHtcbiAgICAgICAgICAgICAgICBuZXh0SW5RdWV1ZSA9IGtvLnZpcnR1YWxFbGVtZW50cy5uZXh0U2libGluZyhjdXJyZW50Q2hpbGQpO1xuICAgICAgICAgICAgICAgIHByZXByb2Nlc3NOb2RlLmNhbGwocHJvdmlkZXIsIGN1cnJlbnRDaGlsZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBSZXNldCBuZXh0SW5RdWV1ZSBmb3IgdGhlIG5leHQgbG9vcFxuICAgICAgICAgICAgbmV4dEluUXVldWUgPSBrby52aXJ0dWFsRWxlbWVudHMuZmlyc3RDaGlsZChlbGVtZW50T3JWaXJ0dWFsRWxlbWVudCk7XG4gICAgICAgIH1cblxuICAgICAgICB3aGlsZSAoY3VycmVudENoaWxkID0gbmV4dEluUXVldWUpIHtcbiAgICAgICAgICAgIC8vIEtlZXAgYSByZWNvcmQgb2YgdGhlIG5leHQgY2hpbGQgKmJlZm9yZSogYXBwbHlpbmcgYmluZGluZ3MsIGluIGNhc2UgdGhlIGJpbmRpbmcgcmVtb3ZlcyB0aGUgY3VycmVudCBjaGlsZCBmcm9tIGl0cyBwb3NpdGlvblxuICAgICAgICAgICAgbmV4dEluUXVldWUgPSBrby52aXJ0dWFsRWxlbWVudHMubmV4dFNpYmxpbmcoY3VycmVudENoaWxkKTtcbiAgICAgICAgICAgIGFwcGx5QmluZGluZ3NUb05vZGVBbmREZXNjZW5kYW50c0ludGVybmFsKGJpbmRpbmdDb250ZXh0LCBjdXJyZW50Q2hpbGQsIGJpbmRpbmdDb250ZXh0c01heURpZmZlckZyb21Eb21QYXJlbnRFbGVtZW50KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFwcGx5QmluZGluZ3NUb05vZGVBbmREZXNjZW5kYW50c0ludGVybmFsIChiaW5kaW5nQ29udGV4dCwgbm9kZVZlcmlmaWVkLCBiaW5kaW5nQ29udGV4dE1heURpZmZlckZyb21Eb21QYXJlbnRFbGVtZW50KSB7XG4gICAgICAgIHZhciBzaG91bGRCaW5kRGVzY2VuZGFudHMgPSB0cnVlO1xuXG4gICAgICAgIC8vIFBlcmYgb3B0aW1pc2F0aW9uOiBBcHBseSBiaW5kaW5ncyBvbmx5IGlmLi4uXG4gICAgICAgIC8vICgxKSBXZSBuZWVkIHRvIHN0b3JlIHRoZSBiaW5kaW5nIGNvbnRleHQgb24gdGhpcyBub2RlIChiZWNhdXNlIGl0IG1heSBkaWZmZXIgZnJvbSB0aGUgRE9NIHBhcmVudCBub2RlJ3MgYmluZGluZyBjb250ZXh0KVxuICAgICAgICAvLyAgICAgTm90ZSB0aGF0IHdlIGNhbid0IHN0b3JlIGJpbmRpbmcgY29udGV4dHMgb24gbm9uLWVsZW1lbnRzIChlLmcuLCB0ZXh0IG5vZGVzKSwgYXMgSUUgZG9lc24ndCBhbGxvdyBleHBhbmRvIHByb3BlcnRpZXMgZm9yIHRob3NlXG4gICAgICAgIC8vICgyKSBJdCBtaWdodCBoYXZlIGJpbmRpbmdzIChlLmcuLCBpdCBoYXMgYSBkYXRhLWJpbmQgYXR0cmlidXRlLCBvciBpdCdzIGEgbWFya2VyIGZvciBhIGNvbnRhaW5lcmxlc3MgdGVtcGxhdGUpXG4gICAgICAgIHZhciBpc0VsZW1lbnQgPSAobm9kZVZlcmlmaWVkLm5vZGVUeXBlID09PSAxKTtcbiAgICAgICAgaWYgKGlzRWxlbWVudCkgLy8gV29ya2Fyb3VuZCBJRSA8PSA4IEhUTUwgcGFyc2luZyB3ZWlyZG5lc3NcbiAgICAgICAgICAgIGtvLnZpcnR1YWxFbGVtZW50cy5ub3JtYWxpc2VWaXJ0dWFsRWxlbWVudERvbVN0cnVjdHVyZShub2RlVmVyaWZpZWQpO1xuXG4gICAgICAgIHZhciBzaG91bGRBcHBseUJpbmRpbmdzID0gKGlzRWxlbWVudCAmJiBiaW5kaW5nQ29udGV4dE1heURpZmZlckZyb21Eb21QYXJlbnRFbGVtZW50KSAgICAgICAgICAgICAvLyBDYXNlICgxKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHx8IGtvLmJpbmRpbmdQcm92aWRlclsnaW5zdGFuY2UnXVsnbm9kZUhhc0JpbmRpbmdzJ10obm9kZVZlcmlmaWVkKTsgICAgICAgLy8gQ2FzZSAoMilcbiAgICAgICAgaWYgKHNob3VsZEFwcGx5QmluZGluZ3MpXG4gICAgICAgICAgICBzaG91bGRCaW5kRGVzY2VuZGFudHMgPSBhcHBseUJpbmRpbmdzVG9Ob2RlSW50ZXJuYWwobm9kZVZlcmlmaWVkLCBudWxsLCBiaW5kaW5nQ29udGV4dCwgYmluZGluZ0NvbnRleHRNYXlEaWZmZXJGcm9tRG9tUGFyZW50RWxlbWVudClbJ3Nob3VsZEJpbmREZXNjZW5kYW50cyddO1xuXG4gICAgICAgIGlmIChzaG91bGRCaW5kRGVzY2VuZGFudHMgJiYgIWJpbmRpbmdEb2VzTm90UmVjdXJzZUludG9FbGVtZW50VHlwZXNba28udXRpbHMudGFnTmFtZUxvd2VyKG5vZGVWZXJpZmllZCldKSB7XG4gICAgICAgICAgICAvLyBXZSdyZSByZWN1cnNpbmcgYXV0b21hdGljYWxseSBpbnRvIChyZWFsIG9yIHZpcnR1YWwpIGNoaWxkIG5vZGVzIHdpdGhvdXQgY2hhbmdpbmcgYmluZGluZyBjb250ZXh0cy4gU28sXG4gICAgICAgICAgICAvLyAgKiBGb3IgY2hpbGRyZW4gb2YgYSAqcmVhbCogZWxlbWVudCwgdGhlIGJpbmRpbmcgY29udGV4dCBpcyBjZXJ0YWlubHkgdGhlIHNhbWUgYXMgb24gdGhlaXIgRE9NIC5wYXJlbnROb2RlLFxuICAgICAgICAgICAgLy8gICAgaGVuY2UgYmluZGluZ0NvbnRleHRzTWF5RGlmZmVyRnJvbURvbVBhcmVudEVsZW1lbnQgaXMgZmFsc2VcbiAgICAgICAgICAgIC8vICAqIEZvciBjaGlsZHJlbiBvZiBhICp2aXJ0dWFsKiBlbGVtZW50LCB3ZSBjYW4ndCBiZSBzdXJlLiBFdmFsdWF0aW5nIC5wYXJlbnROb2RlIG9uIHRob3NlIGNoaWxkcmVuIG1heVxuICAgICAgICAgICAgLy8gICAgc2tpcCBvdmVyIGFueSBudW1iZXIgb2YgaW50ZXJtZWRpYXRlIHZpcnR1YWwgZWxlbWVudHMsIGFueSBvZiB3aGljaCBtaWdodCBkZWZpbmUgYSBjdXN0b20gYmluZGluZyBjb250ZXh0LFxuICAgICAgICAgICAgLy8gICAgaGVuY2UgYmluZGluZ0NvbnRleHRzTWF5RGlmZmVyRnJvbURvbVBhcmVudEVsZW1lbnQgaXMgdHJ1ZVxuICAgICAgICAgICAgYXBwbHlCaW5kaW5nc1RvRGVzY2VuZGFudHNJbnRlcm5hbChiaW5kaW5nQ29udGV4dCwgbm9kZVZlcmlmaWVkLCAvKiBiaW5kaW5nQ29udGV4dHNNYXlEaWZmZXJGcm9tRG9tUGFyZW50RWxlbWVudDogKi8gIWlzRWxlbWVudCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgYm91bmRFbGVtZW50RG9tRGF0YUtleSA9IGtvLnV0aWxzLmRvbURhdGEubmV4dEtleSgpO1xuXG5cbiAgICBmdW5jdGlvbiB0b3BvbG9naWNhbFNvcnRCaW5kaW5ncyhiaW5kaW5ncykge1xuICAgICAgICAvLyBEZXB0aC1maXJzdCBzb3J0XG4gICAgICAgIHZhciByZXN1bHQgPSBbXSwgICAgICAgICAgICAgICAgLy8gVGhlIGxpc3Qgb2Yga2V5L2hhbmRsZXIgcGFpcnMgdGhhdCB3ZSB3aWxsIHJldHVyblxuICAgICAgICAgICAgYmluZGluZ3NDb25zaWRlcmVkID0ge30sICAgIC8vIEEgdGVtcG9yYXJ5IHJlY29yZCBvZiB3aGljaCBiaW5kaW5ncyBhcmUgYWxyZWFkeSBpbiAncmVzdWx0J1xuICAgICAgICAgICAgY3ljbGljRGVwZW5kZW5jeVN0YWNrID0gW107IC8vIEtlZXBzIHRyYWNrIG9mIGEgZGVwdGgtc2VhcmNoIHNvIHRoYXQsIGlmIHRoZXJlJ3MgYSBjeWNsZSwgd2Uga25vdyB3aGljaCBiaW5kaW5ncyBjYXVzZWQgaXRcbiAgICAgICAga28udXRpbHMub2JqZWN0Rm9yRWFjaChiaW5kaW5ncywgZnVuY3Rpb24gcHVzaEJpbmRpbmcoYmluZGluZ0tleSkge1xuICAgICAgICAgICAgaWYgKCFiaW5kaW5nc0NvbnNpZGVyZWRbYmluZGluZ0tleV0pIHtcbiAgICAgICAgICAgICAgICB2YXIgYmluZGluZyA9IGtvWydnZXRCaW5kaW5nSGFuZGxlciddKGJpbmRpbmdLZXkpO1xuICAgICAgICAgICAgICAgIGlmIChiaW5kaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEZpcnN0IGFkZCBkZXBlbmRlbmNpZXMgKGlmIGFueSkgb2YgdGhlIGN1cnJlbnQgYmluZGluZ1xuICAgICAgICAgICAgICAgICAgICBpZiAoYmluZGluZ1snYWZ0ZXInXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY3ljbGljRGVwZW5kZW5jeVN0YWNrLnB1c2goYmluZGluZ0tleSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBrby51dGlscy5hcnJheUZvckVhY2goYmluZGluZ1snYWZ0ZXInXSwgZnVuY3Rpb24oYmluZGluZ0RlcGVuZGVuY3lLZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYmluZGluZ3NbYmluZGluZ0RlcGVuZGVuY3lLZXldKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChrby51dGlscy5hcnJheUluZGV4T2YoY3ljbGljRGVwZW5kZW5jeVN0YWNrLCBiaW5kaW5nRGVwZW5kZW5jeUtleSkgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcIkNhbm5vdCBjb21iaW5lIHRoZSBmb2xsb3dpbmcgYmluZGluZ3MsIGJlY2F1c2UgdGhleSBoYXZlIGEgY3ljbGljIGRlcGVuZGVuY3k6IFwiICsgY3ljbGljRGVwZW5kZW5jeVN0YWNrLmpvaW4oXCIsIFwiKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwdXNoQmluZGluZyhiaW5kaW5nRGVwZW5kZW5jeUtleSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN5Y2xpY0RlcGVuZGVuY3lTdGFjay5sZW5ndGgtLTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBOZXh0IGFkZCB0aGUgY3VycmVudCBiaW5kaW5nXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHsga2V5OiBiaW5kaW5nS2V5LCBoYW5kbGVyOiBiaW5kaW5nIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBiaW5kaW5nc0NvbnNpZGVyZWRbYmluZGluZ0tleV0gPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFwcGx5QmluZGluZ3NUb05vZGVJbnRlcm5hbChub2RlLCBzb3VyY2VCaW5kaW5ncywgYmluZGluZ0NvbnRleHQsIGJpbmRpbmdDb250ZXh0TWF5RGlmZmVyRnJvbURvbVBhcmVudEVsZW1lbnQpIHtcbiAgICAgICAgLy8gUHJldmVudCBtdWx0aXBsZSBhcHBseUJpbmRpbmdzIGNhbGxzIGZvciB0aGUgc2FtZSBub2RlLCBleGNlcHQgd2hlbiBhIGJpbmRpbmcgdmFsdWUgaXMgc3BlY2lmaWVkXG4gICAgICAgIHZhciBhbHJlYWR5Qm91bmQgPSBrby51dGlscy5kb21EYXRhLmdldChub2RlLCBib3VuZEVsZW1lbnREb21EYXRhS2V5KTtcbiAgICAgICAgaWYgKCFzb3VyY2VCaW5kaW5ncykge1xuICAgICAgICAgICAgaWYgKGFscmVhZHlCb3VuZCkge1xuICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiWW91IGNhbm5vdCBhcHBseSBiaW5kaW5ncyBtdWx0aXBsZSB0aW1lcyB0byB0aGUgc2FtZSBlbGVtZW50LlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGtvLnV0aWxzLmRvbURhdGEuc2V0KG5vZGUsIGJvdW5kRWxlbWVudERvbURhdGFLZXksIHRydWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gT3B0aW1pemF0aW9uOiBEb24ndCBzdG9yZSB0aGUgYmluZGluZyBjb250ZXh0IG9uIHRoaXMgbm9kZSBpZiBpdCdzIGRlZmluaXRlbHkgdGhlIHNhbWUgYXMgb24gbm9kZS5wYXJlbnROb2RlLCBiZWNhdXNlXG4gICAgICAgIC8vIHdlIGNhbiBlYXNpbHkgcmVjb3ZlciBpdCBqdXN0IGJ5IHNjYW5uaW5nIHVwIHRoZSBub2RlJ3MgYW5jZXN0b3JzIGluIHRoZSBET01cbiAgICAgICAgLy8gKG5vdGU6IGhlcmUsIHBhcmVudCBub2RlIG1lYW5zIFwicmVhbCBET00gcGFyZW50XCIgbm90IFwidmlydHVhbCBwYXJlbnRcIiwgYXMgdGhlcmUncyBubyBPKDEpIHdheSB0byBmaW5kIHRoZSB2aXJ0dWFsIHBhcmVudClcbiAgICAgICAgaWYgKCFhbHJlYWR5Qm91bmQgJiYgYmluZGluZ0NvbnRleHRNYXlEaWZmZXJGcm9tRG9tUGFyZW50RWxlbWVudClcbiAgICAgICAgICAgIGtvLnN0b3JlZEJpbmRpbmdDb250ZXh0Rm9yTm9kZShub2RlLCBiaW5kaW5nQ29udGV4dCk7XG5cbiAgICAgICAgLy8gVXNlIGJpbmRpbmdzIGlmIGdpdmVuLCBvdGhlcndpc2UgZmFsbCBiYWNrIG9uIGFza2luZyB0aGUgYmluZGluZ3MgcHJvdmlkZXIgdG8gZ2l2ZSB1cyBzb21lIGJpbmRpbmdzXG4gICAgICAgIHZhciBiaW5kaW5ncztcbiAgICAgICAgaWYgKHNvdXJjZUJpbmRpbmdzICYmIHR5cGVvZiBzb3VyY2VCaW5kaW5ncyAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgYmluZGluZ3MgPSBzb3VyY2VCaW5kaW5ncztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBwcm92aWRlciA9IGtvLmJpbmRpbmdQcm92aWRlclsnaW5zdGFuY2UnXSxcbiAgICAgICAgICAgICAgICBnZXRCaW5kaW5ncyA9IHByb3ZpZGVyWydnZXRCaW5kaW5nQWNjZXNzb3JzJ10gfHwgZ2V0QmluZGluZ3NBbmRNYWtlQWNjZXNzb3JzO1xuXG4gICAgICAgICAgICAvLyBHZXQgdGhlIGJpbmRpbmcgZnJvbSB0aGUgcHJvdmlkZXIgd2l0aGluIGEgY29tcHV0ZWQgb2JzZXJ2YWJsZSBzbyB0aGF0IHdlIGNhbiB1cGRhdGUgdGhlIGJpbmRpbmdzIHdoZW5ldmVyXG4gICAgICAgICAgICAvLyB0aGUgYmluZGluZyBjb250ZXh0IGlzIHVwZGF0ZWQgb3IgaWYgdGhlIGJpbmRpbmcgcHJvdmlkZXIgYWNjZXNzZXMgb2JzZXJ2YWJsZXMuXG4gICAgICAgICAgICB2YXIgYmluZGluZ3NVcGRhdGVyID0ga28uZGVwZW5kZW50T2JzZXJ2YWJsZShcbiAgICAgICAgICAgICAgICBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgYmluZGluZ3MgPSBzb3VyY2VCaW5kaW5ncyA/IHNvdXJjZUJpbmRpbmdzKGJpbmRpbmdDb250ZXh0LCBub2RlKSA6IGdldEJpbmRpbmdzLmNhbGwocHJvdmlkZXIsIG5vZGUsIGJpbmRpbmdDb250ZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgLy8gUmVnaXN0ZXIgYSBkZXBlbmRlbmN5IG9uIHRoZSBiaW5kaW5nIGNvbnRleHQgdG8gc3VwcG9ydCBvYnNlcnZhYmxlIHZpZXcgbW9kZWxzLlxuICAgICAgICAgICAgICAgICAgICBpZiAoYmluZGluZ3MgJiYgYmluZGluZ0NvbnRleHQuX3N1YnNjcmliYWJsZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGJpbmRpbmdDb250ZXh0Ll9zdWJzY3JpYmFibGUoKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGJpbmRpbmdzO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgbnVsbCwgeyBkaXNwb3NlV2hlbk5vZGVJc1JlbW92ZWQ6IG5vZGUgfVxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgaWYgKCFiaW5kaW5ncyB8fCAhYmluZGluZ3NVcGRhdGVyLmlzQWN0aXZlKCkpXG4gICAgICAgICAgICAgICAgYmluZGluZ3NVcGRhdGVyID0gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBiaW5kaW5nSGFuZGxlclRoYXRDb250cm9sc0Rlc2NlbmRhbnRCaW5kaW5ncztcbiAgICAgICAgaWYgKGJpbmRpbmdzKSB7XG4gICAgICAgICAgICAvLyBSZXR1cm4gdGhlIHZhbHVlIGFjY2Vzc29yIGZvciBhIGdpdmVuIGJpbmRpbmcuIFdoZW4gYmluZGluZ3MgYXJlIHN0YXRpYyAod29uJ3QgYmUgdXBkYXRlZCBiZWNhdXNlIG9mIGEgYmluZGluZ1xuICAgICAgICAgICAgLy8gY29udGV4dCB1cGRhdGUpLCBqdXN0IHJldHVybiB0aGUgdmFsdWUgYWNjZXNzb3IgZnJvbSB0aGUgYmluZGluZy4gT3RoZXJ3aXNlLCByZXR1cm4gYSBmdW5jdGlvbiB0aGF0IGFsd2F5cyBnZXRzXG4gICAgICAgICAgICAvLyB0aGUgbGF0ZXN0IGJpbmRpbmcgdmFsdWUgYW5kIHJlZ2lzdGVycyBhIGRlcGVuZGVuY3kgb24gdGhlIGJpbmRpbmcgdXBkYXRlci5cbiAgICAgICAgICAgIHZhciBnZXRWYWx1ZUFjY2Vzc29yID0gYmluZGluZ3NVcGRhdGVyXG4gICAgICAgICAgICAgICAgPyBmdW5jdGlvbihiaW5kaW5nS2V5KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBldmFsdWF0ZVZhbHVlQWNjZXNzb3IoYmluZGluZ3NVcGRhdGVyKClbYmluZGluZ0tleV0pO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH0gOiBmdW5jdGlvbihiaW5kaW5nS2V5KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBiaW5kaW5nc1tiaW5kaW5nS2V5XTtcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAvLyBVc2Ugb2YgYWxsQmluZGluZ3MgYXMgYSBmdW5jdGlvbiBpcyBtYWludGFpbmVkIGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eSwgYnV0IGl0cyB1c2UgaXMgZGVwcmVjYXRlZFxuICAgICAgICAgICAgZnVuY3Rpb24gYWxsQmluZGluZ3MoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGtvLnV0aWxzLm9iamVjdE1hcChiaW5kaW5nc1VwZGF0ZXIgPyBiaW5kaW5nc1VwZGF0ZXIoKSA6IGJpbmRpbmdzLCBldmFsdWF0ZVZhbHVlQWNjZXNzb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gVGhlIGZvbGxvd2luZyBpcyB0aGUgMy54IGFsbEJpbmRpbmdzIEFQSVxuICAgICAgICAgICAgYWxsQmluZGluZ3NbJ2dldCddID0gZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGJpbmRpbmdzW2tleV0gJiYgZXZhbHVhdGVWYWx1ZUFjY2Vzc29yKGdldFZhbHVlQWNjZXNzb3Ioa2V5KSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgYWxsQmluZGluZ3NbJ2hhcyddID0gZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGtleSBpbiBiaW5kaW5ncztcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIC8vIEZpcnN0IHB1dCB0aGUgYmluZGluZ3MgaW50byB0aGUgcmlnaHQgb3JkZXJcbiAgICAgICAgICAgIHZhciBvcmRlcmVkQmluZGluZ3MgPSB0b3BvbG9naWNhbFNvcnRCaW5kaW5ncyhiaW5kaW5ncyk7XG5cbiAgICAgICAgICAgIC8vIEdvIHRocm91Z2ggdGhlIHNvcnRlZCBiaW5kaW5ncywgY2FsbGluZyBpbml0IGFuZCB1cGRhdGUgZm9yIGVhY2hcbiAgICAgICAgICAgIGtvLnV0aWxzLmFycmF5Rm9yRWFjaChvcmRlcmVkQmluZGluZ3MsIGZ1bmN0aW9uKGJpbmRpbmdLZXlBbmRIYW5kbGVyKSB7XG4gICAgICAgICAgICAgICAgLy8gTm90ZSB0aGF0IHRvcG9sb2dpY2FsU29ydEJpbmRpbmdzIGhhcyBhbHJlYWR5IGZpbHRlcmVkIG91dCBhbnkgbm9uZXhpc3RlbnQgYmluZGluZyBoYW5kbGVycyxcbiAgICAgICAgICAgICAgICAvLyBzbyBiaW5kaW5nS2V5QW5kSGFuZGxlci5oYW5kbGVyIHdpbGwgYWx3YXlzIGJlIG5vbm51bGwuXG4gICAgICAgICAgICAgICAgdmFyIGhhbmRsZXJJbml0Rm4gPSBiaW5kaW5nS2V5QW5kSGFuZGxlci5oYW5kbGVyW1wiaW5pdFwiXSxcbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlclVwZGF0ZUZuID0gYmluZGluZ0tleUFuZEhhbmRsZXIuaGFuZGxlcltcInVwZGF0ZVwiXSxcbiAgICAgICAgICAgICAgICAgICAgYmluZGluZ0tleSA9IGJpbmRpbmdLZXlBbmRIYW5kbGVyLmtleTtcblxuICAgICAgICAgICAgICAgIGlmIChub2RlLm5vZGVUeXBlID09PSA4KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbGlkYXRlVGhhdEJpbmRpbmdJc0FsbG93ZWRGb3JWaXJ0dWFsRWxlbWVudHMoYmluZGluZ0tleSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgLy8gUnVuIGluaXQsIGlnbm9yaW5nIGFueSBkZXBlbmRlbmNpZXNcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBoYW5kbGVySW5pdEZuID09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgICAgICAgICAga28uZGVwZW5kZW5jeURldGVjdGlvbi5pZ25vcmUoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGluaXRSZXN1bHQgPSBoYW5kbGVySW5pdEZuKG5vZGUsIGdldFZhbHVlQWNjZXNzb3IoYmluZGluZ0tleSksIGFsbEJpbmRpbmdzLCBiaW5kaW5nQ29udGV4dFsnJGRhdGEnXSwgYmluZGluZ0NvbnRleHQpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhpcyBiaW5kaW5nIGhhbmRsZXIgY2xhaW1zIHRvIGNvbnRyb2wgZGVzY2VuZGFudCBiaW5kaW5ncywgbWFrZSBhIG5vdGUgb2YgdGhpc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbml0UmVzdWx0ICYmIGluaXRSZXN1bHRbJ2NvbnRyb2xzRGVzY2VuZGFudEJpbmRpbmdzJ10pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGJpbmRpbmdIYW5kbGVyVGhhdENvbnRyb2xzRGVzY2VuZGFudEJpbmRpbmdzICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNdWx0aXBsZSBiaW5kaW5ncyAoXCIgKyBiaW5kaW5nSGFuZGxlclRoYXRDb250cm9sc0Rlc2NlbmRhbnRCaW5kaW5ncyArIFwiIGFuZCBcIiArIGJpbmRpbmdLZXkgKyBcIikgYXJlIHRyeWluZyB0byBjb250cm9sIGRlc2NlbmRhbnQgYmluZGluZ3Mgb2YgdGhlIHNhbWUgZWxlbWVudC4gWW91IGNhbm5vdCB1c2UgdGhlc2UgYmluZGluZ3MgdG9nZXRoZXIgb24gdGhlIHNhbWUgZWxlbWVudC5cIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJpbmRpbmdIYW5kbGVyVGhhdENvbnRyb2xzRGVzY2VuZGFudEJpbmRpbmdzID0gYmluZGluZ0tleTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIFJ1biB1cGRhdGUgaW4gaXRzIG93biBjb21wdXRlZCB3cmFwcGVyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgaGFuZGxlclVwZGF0ZUZuID09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgICAgICAgICAga28uZGVwZW5kZW50T2JzZXJ2YWJsZShcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGFuZGxlclVwZGF0ZUZuKG5vZGUsIGdldFZhbHVlQWNjZXNzb3IoYmluZGluZ0tleSksIGFsbEJpbmRpbmdzLCBiaW5kaW5nQ29udGV4dFsnJGRhdGEnXSwgYmluZGluZ0NvbnRleHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7IGRpc3Bvc2VXaGVuTm9kZUlzUmVtb3ZlZDogbm9kZSB9XG4gICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgZXgubWVzc2FnZSA9IFwiVW5hYmxlIHRvIHByb2Nlc3MgYmluZGluZyBcXFwiXCIgKyBiaW5kaW5nS2V5ICsgXCI6IFwiICsgYmluZGluZ3NbYmluZGluZ0tleV0gKyBcIlxcXCJcXG5NZXNzYWdlOiBcIiArIGV4Lm1lc3NhZ2U7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGV4O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICdzaG91bGRCaW5kRGVzY2VuZGFudHMnOiBiaW5kaW5nSGFuZGxlclRoYXRDb250cm9sc0Rlc2NlbmRhbnRCaW5kaW5ncyA9PT0gdW5kZWZpbmVkXG4gICAgICAgIH07XG4gICAgfTtcblxuICAgIHZhciBzdG9yZWRCaW5kaW5nQ29udGV4dERvbURhdGFLZXkgPSBrby51dGlscy5kb21EYXRhLm5leHRLZXkoKTtcbiAgICBrby5zdG9yZWRCaW5kaW5nQ29udGV4dEZvck5vZGUgPSBmdW5jdGlvbiAobm9kZSwgYmluZGluZ0NvbnRleHQpIHtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT0gMikge1xuICAgICAgICAgICAga28udXRpbHMuZG9tRGF0YS5zZXQobm9kZSwgc3RvcmVkQmluZGluZ0NvbnRleHREb21EYXRhS2V5LCBiaW5kaW5nQ29udGV4dCk7XG4gICAgICAgICAgICBpZiAoYmluZGluZ0NvbnRleHQuX3N1YnNjcmliYWJsZSlcbiAgICAgICAgICAgICAgICBiaW5kaW5nQ29udGV4dC5fc3Vic2NyaWJhYmxlLl9hZGROb2RlKG5vZGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGtvLnV0aWxzLmRvbURhdGEuZ2V0KG5vZGUsIHN0b3JlZEJpbmRpbmdDb250ZXh0RG9tRGF0YUtleSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRCaW5kaW5nQ29udGV4dCh2aWV3TW9kZWxPckJpbmRpbmdDb250ZXh0KSB7XG4gICAgICAgIHJldHVybiB2aWV3TW9kZWxPckJpbmRpbmdDb250ZXh0ICYmICh2aWV3TW9kZWxPckJpbmRpbmdDb250ZXh0IGluc3RhbmNlb2Yga28uYmluZGluZ0NvbnRleHQpXG4gICAgICAgICAgICA/IHZpZXdNb2RlbE9yQmluZGluZ0NvbnRleHRcbiAgICAgICAgICAgIDogbmV3IGtvLmJpbmRpbmdDb250ZXh0KHZpZXdNb2RlbE9yQmluZGluZ0NvbnRleHQpO1xuICAgIH1cblxuICAgIGtvLmFwcGx5QmluZGluZ0FjY2Vzc29yc1RvTm9kZSA9IGZ1bmN0aW9uIChub2RlLCBiaW5kaW5ncywgdmlld01vZGVsT3JCaW5kaW5nQ29udGV4dCkge1xuICAgICAgICBpZiAobm9kZS5ub2RlVHlwZSA9PT0gMSkgLy8gSWYgaXQncyBhbiBlbGVtZW50LCB3b3JrYXJvdW5kIElFIDw9IDggSFRNTCBwYXJzaW5nIHdlaXJkbmVzc1xuICAgICAgICAgICAga28udmlydHVhbEVsZW1lbnRzLm5vcm1hbGlzZVZpcnR1YWxFbGVtZW50RG9tU3RydWN0dXJlKG5vZGUpO1xuICAgICAgICByZXR1cm4gYXBwbHlCaW5kaW5nc1RvTm9kZUludGVybmFsKG5vZGUsIGJpbmRpbmdzLCBnZXRCaW5kaW5nQ29udGV4dCh2aWV3TW9kZWxPckJpbmRpbmdDb250ZXh0KSwgdHJ1ZSk7XG4gICAgfTtcblxuICAgIGtvLmFwcGx5QmluZGluZ3NUb05vZGUgPSBmdW5jdGlvbiAobm9kZSwgYmluZGluZ3MsIHZpZXdNb2RlbE9yQmluZGluZ0NvbnRleHQpIHtcbiAgICAgICAgdmFyIGNvbnRleHQgPSBnZXRCaW5kaW5nQ29udGV4dCh2aWV3TW9kZWxPckJpbmRpbmdDb250ZXh0KTtcbiAgICAgICAgcmV0dXJuIGtvLmFwcGx5QmluZGluZ0FjY2Vzc29yc1RvTm9kZShub2RlLCBtYWtlQmluZGluZ0FjY2Vzc29ycyhiaW5kaW5ncywgY29udGV4dCwgbm9kZSksIGNvbnRleHQpO1xuICAgIH07XG5cbiAgICBrby5hcHBseUJpbmRpbmdzVG9EZXNjZW5kYW50cyA9IGZ1bmN0aW9uKHZpZXdNb2RlbE9yQmluZGluZ0NvbnRleHQsIHJvb3ROb2RlKSB7XG4gICAgICAgIGlmIChyb290Tm9kZS5ub2RlVHlwZSA9PT0gMSB8fCByb290Tm9kZS5ub2RlVHlwZSA9PT0gOClcbiAgICAgICAgICAgIGFwcGx5QmluZGluZ3NUb0Rlc2NlbmRhbnRzSW50ZXJuYWwoZ2V0QmluZGluZ0NvbnRleHQodmlld01vZGVsT3JCaW5kaW5nQ29udGV4dCksIHJvb3ROb2RlLCB0cnVlKTtcbiAgICB9O1xuXG4gICAga28uYXBwbHlCaW5kaW5ncyA9IGZ1bmN0aW9uICh2aWV3TW9kZWxPckJpbmRpbmdDb250ZXh0LCByb290Tm9kZSkge1xuICAgICAgICAvLyBJZiBqUXVlcnkgaXMgbG9hZGVkIGFmdGVyIEtub2Nrb3V0LCB3ZSB3b24ndCBpbml0aWFsbHkgaGF2ZSBhY2Nlc3MgdG8gaXQuIFNvIHNhdmUgaXQgaGVyZS5cbiAgICAgICAgaWYgKCFqUXVlcnlJbnN0YW5jZSAmJiB3aW5kb3dbJ2pRdWVyeSddKSB7XG4gICAgICAgICAgICBqUXVlcnlJbnN0YW5jZSA9IHdpbmRvd1snalF1ZXJ5J107XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocm9vdE5vZGUgJiYgKHJvb3ROb2RlLm5vZGVUeXBlICE9PSAxKSAmJiAocm9vdE5vZGUubm9kZVR5cGUgIT09IDgpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwia28uYXBwbHlCaW5kaW5nczogZmlyc3QgcGFyYW1ldGVyIHNob3VsZCBiZSB5b3VyIHZpZXcgbW9kZWw7IHNlY29uZCBwYXJhbWV0ZXIgc2hvdWxkIGJlIGEgRE9NIG5vZGVcIik7XG4gICAgICAgIHJvb3ROb2RlID0gcm9vdE5vZGUgfHwgd2luZG93LmRvY3VtZW50LmJvZHk7IC8vIE1ha2UgXCJyb290Tm9kZVwiIHBhcmFtZXRlciBvcHRpb25hbFxuXG4gICAgICAgIGFwcGx5QmluZGluZ3NUb05vZGVBbmREZXNjZW5kYW50c0ludGVybmFsKGdldEJpbmRpbmdDb250ZXh0KHZpZXdNb2RlbE9yQmluZGluZ0NvbnRleHQpLCByb290Tm9kZSwgdHJ1ZSk7XG4gICAgfTtcblxuICAgIC8vIFJldHJpZXZpbmcgYmluZGluZyBjb250ZXh0IGZyb20gYXJiaXRyYXJ5IG5vZGVzXG4gICAga28uY29udGV4dEZvciA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgICAgLy8gV2UgY2FuIG9ubHkgZG8gc29tZXRoaW5nIG1lYW5pbmdmdWwgZm9yIGVsZW1lbnRzIGFuZCBjb21tZW50IG5vZGVzIChpbiBwYXJ0aWN1bGFyLCBub3QgdGV4dCBub2RlcywgYXMgSUUgY2FuJ3Qgc3RvcmUgZG9tZGF0YSBmb3IgdGhlbSlcbiAgICAgICAgc3dpdGNoIChub2RlLm5vZGVUeXBlKSB7XG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICAgICAgdmFyIGNvbnRleHQgPSBrby5zdG9yZWRCaW5kaW5nQ29udGV4dEZvck5vZGUobm9kZSk7XG4gICAgICAgICAgICAgICAgaWYgKGNvbnRleHQpIHJldHVybiBjb250ZXh0O1xuICAgICAgICAgICAgICAgIGlmIChub2RlLnBhcmVudE5vZGUpIHJldHVybiBrby5jb250ZXh0Rm9yKG5vZGUucGFyZW50Tm9kZSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9O1xuICAgIGtvLmRhdGFGb3IgPSBmdW5jdGlvbihub2RlKSB7XG4gICAgICAgIHZhciBjb250ZXh0ID0ga28uY29udGV4dEZvcihub2RlKTtcbiAgICAgICAgcmV0dXJuIGNvbnRleHQgPyBjb250ZXh0WyckZGF0YSddIDogdW5kZWZpbmVkO1xuICAgIH07XG5cbiAgICBrby5leHBvcnRTeW1ib2woJ2JpbmRpbmdIYW5kbGVycycsIGtvLmJpbmRpbmdIYW5kbGVycyk7XG4gICAga28uZXhwb3J0U3ltYm9sKCdhcHBseUJpbmRpbmdzJywga28uYXBwbHlCaW5kaW5ncyk7XG4gICAga28uZXhwb3J0U3ltYm9sKCdhcHBseUJpbmRpbmdzVG9EZXNjZW5kYW50cycsIGtvLmFwcGx5QmluZGluZ3NUb0Rlc2NlbmRhbnRzKTtcbiAgICBrby5leHBvcnRTeW1ib2woJ2FwcGx5QmluZGluZ0FjY2Vzc29yc1RvTm9kZScsIGtvLmFwcGx5QmluZGluZ0FjY2Vzc29yc1RvTm9kZSk7XG4gICAga28uZXhwb3J0U3ltYm9sKCdhcHBseUJpbmRpbmdzVG9Ob2RlJywga28uYXBwbHlCaW5kaW5nc1RvTm9kZSk7XG4gICAga28uZXhwb3J0U3ltYm9sKCdjb250ZXh0Rm9yJywga28uY29udGV4dEZvcik7XG4gICAga28uZXhwb3J0U3ltYm9sKCdkYXRhRm9yJywga28uZGF0YUZvcik7XG59KSgpO1xuKGZ1bmN0aW9uKHVuZGVmaW5lZCkge1xuICAgIHZhciBsb2FkaW5nU3Vic2NyaWJhYmxlc0NhY2hlID0ge30sIC8vIFRyYWNrcyBjb21wb25lbnQgbG9hZHMgdGhhdCBhcmUgY3VycmVudGx5IGluIGZsaWdodFxuICAgICAgICBsb2FkZWREZWZpbml0aW9uc0NhY2hlID0ge307ICAgIC8vIFRyYWNrcyBjb21wb25lbnQgbG9hZHMgdGhhdCBoYXZlIGFscmVhZHkgY29tcGxldGVkXG5cbiAgICBrby5jb21wb25lbnRzID0ge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uKGNvbXBvbmVudE5hbWUsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICB2YXIgY2FjaGVkRGVmaW5pdGlvbiA9IGdldE9iamVjdE93blByb3BlcnR5KGxvYWRlZERlZmluaXRpb25zQ2FjaGUsIGNvbXBvbmVudE5hbWUpO1xuICAgICAgICAgICAgaWYgKGNhY2hlZERlZmluaXRpb24pIHtcbiAgICAgICAgICAgICAgICAvLyBJdCdzIGFscmVhZHkgbG9hZGVkIGFuZCBjYWNoZWQuIFJldXNlIHRoZSBzYW1lIGRlZmluaXRpb24gb2JqZWN0LlxuICAgICAgICAgICAgICAgIC8vIE5vdGUgdGhhdCBmb3IgQVBJIGNvbnNpc3RlbmN5LCBldmVuIGNhY2hlIGhpdHMgY29tcGxldGUgYXN5bmNocm9ub3VzbHkgYnkgZGVmYXVsdC5cbiAgICAgICAgICAgICAgICAvLyBZb3UgY2FuIGJ5cGFzcyB0aGlzIGJ5IHB1dHRpbmcgc3luY2hyb25vdXM6dHJ1ZSBvbiB5b3VyIGNvbXBvbmVudCBjb25maWcuXG4gICAgICAgICAgICAgICAgaWYgKGNhY2hlZERlZmluaXRpb24uaXNTeW5jaHJvbm91c0NvbXBvbmVudCkge1xuICAgICAgICAgICAgICAgICAgICBrby5kZXBlbmRlbmN5RGV0ZWN0aW9uLmlnbm9yZShmdW5jdGlvbigpIHsgLy8gU2VlIGNvbW1lbnQgaW4gbG9hZGVyUmVnaXN0cnlCZWhhdmlvcnMuanMgZm9yIHJlYXNvbmluZ1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soY2FjaGVkRGVmaW5pdGlvbi5kZWZpbml0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAga28udGFza3Muc2NoZWR1bGUoZnVuY3Rpb24oKSB7IGNhbGxiYWNrKGNhY2hlZERlZmluaXRpb24uZGVmaW5pdGlvbik7IH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gSm9pbiB0aGUgbG9hZGluZyBwcm9jZXNzIHRoYXQgaXMgYWxyZWFkeSB1bmRlcndheSwgb3Igc3RhcnQgYSBuZXcgb25lLlxuICAgICAgICAgICAgICAgIGxvYWRDb21wb25lbnRBbmROb3RpZnkoY29tcG9uZW50TmFtZSwgY2FsbGJhY2spO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIGNsZWFyQ2FjaGVkRGVmaW5pdGlvbjogZnVuY3Rpb24oY29tcG9uZW50TmFtZSkge1xuICAgICAgICAgICAgZGVsZXRlIGxvYWRlZERlZmluaXRpb25zQ2FjaGVbY29tcG9uZW50TmFtZV07XG4gICAgICAgIH0sXG5cbiAgICAgICAgX2dldEZpcnN0UmVzdWx0RnJvbUxvYWRlcnM6IGdldEZpcnN0UmVzdWx0RnJvbUxvYWRlcnNcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gZ2V0T2JqZWN0T3duUHJvcGVydHkob2JqLCBwcm9wTmFtZSkge1xuICAgICAgICByZXR1cm4gb2JqLmhhc093blByb3BlcnR5KHByb3BOYW1lKSA/IG9ialtwcm9wTmFtZV0gOiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbG9hZENvbXBvbmVudEFuZE5vdGlmeShjb21wb25lbnROYW1lLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgc3Vic2NyaWJhYmxlID0gZ2V0T2JqZWN0T3duUHJvcGVydHkobG9hZGluZ1N1YnNjcmliYWJsZXNDYWNoZSwgY29tcG9uZW50TmFtZSksXG4gICAgICAgICAgICBjb21wbGV0ZWRBc3luYztcbiAgICAgICAgaWYgKCFzdWJzY3JpYmFibGUpIHtcbiAgICAgICAgICAgIC8vIEl0J3Mgbm90IHN0YXJ0ZWQgbG9hZGluZyB5ZXQuIFN0YXJ0IGxvYWRpbmcsIGFuZCB3aGVuIGl0J3MgZG9uZSwgbW92ZSBpdCB0byBsb2FkZWREZWZpbml0aW9uc0NhY2hlLlxuICAgICAgICAgICAgc3Vic2NyaWJhYmxlID0gbG9hZGluZ1N1YnNjcmliYWJsZXNDYWNoZVtjb21wb25lbnROYW1lXSA9IG5ldyBrby5zdWJzY3JpYmFibGUoKTtcbiAgICAgICAgICAgIHN1YnNjcmliYWJsZS5zdWJzY3JpYmUoY2FsbGJhY2spO1xuXG4gICAgICAgICAgICBiZWdpbkxvYWRpbmdDb21wb25lbnQoY29tcG9uZW50TmFtZSwgZnVuY3Rpb24oZGVmaW5pdGlvbiwgY29uZmlnKSB7XG4gICAgICAgICAgICAgICAgdmFyIGlzU3luY2hyb25vdXNDb21wb25lbnQgPSAhIShjb25maWcgJiYgY29uZmlnWydzeW5jaHJvbm91cyddKTtcbiAgICAgICAgICAgICAgICBsb2FkZWREZWZpbml0aW9uc0NhY2hlW2NvbXBvbmVudE5hbWVdID0geyBkZWZpbml0aW9uOiBkZWZpbml0aW9uLCBpc1N5bmNocm9ub3VzQ29tcG9uZW50OiBpc1N5bmNocm9ub3VzQ29tcG9uZW50IH07XG4gICAgICAgICAgICAgICAgZGVsZXRlIGxvYWRpbmdTdWJzY3JpYmFibGVzQ2FjaGVbY29tcG9uZW50TmFtZV07XG5cbiAgICAgICAgICAgICAgICAvLyBGb3IgQVBJIGNvbnNpc3RlbmN5LCBhbGwgbG9hZHMgY29tcGxldGUgYXN5bmNocm9ub3VzbHkuIEhvd2V2ZXIgd2Ugd2FudCB0byBhdm9pZFxuICAgICAgICAgICAgICAgIC8vIGFkZGluZyBhbiBleHRyYSB0YXNrIHNjaGVkdWxlIGlmIGl0J3MgdW5uZWNlc3NhcnkgKGkuZS4sIHRoZSBjb21wbGV0aW9uIGlzIGFscmVhZHlcbiAgICAgICAgICAgICAgICAvLyBhc3luYykuXG4gICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAvLyBZb3UgY2FuIGJ5cGFzcyB0aGUgJ2Fsd2F5cyBhc3luY2hyb25vdXMnIGZlYXR1cmUgYnkgcHV0dGluZyB0aGUgc3luY2hyb25vdXM6dHJ1ZVxuICAgICAgICAgICAgICAgIC8vIGZsYWcgb24geW91ciBjb21wb25lbnQgY29uZmlndXJhdGlvbiB3aGVuIHlvdSByZWdpc3RlciBpdC5cbiAgICAgICAgICAgICAgICBpZiAoY29tcGxldGVkQXN5bmMgfHwgaXNTeW5jaHJvbm91c0NvbXBvbmVudCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBOb3RlIHRoYXQgbm90aWZ5U3Vic2NyaWJlcnMgaWdub3JlcyBhbnkgZGVwZW5kZW5jaWVzIHJlYWQgd2l0aGluIHRoZSBjYWxsYmFjay5cbiAgICAgICAgICAgICAgICAgICAgLy8gU2VlIGNvbW1lbnQgaW4gbG9hZGVyUmVnaXN0cnlCZWhhdmlvcnMuanMgZm9yIHJlYXNvbmluZ1xuICAgICAgICAgICAgICAgICAgICBzdWJzY3JpYmFibGVbJ25vdGlmeVN1YnNjcmliZXJzJ10oZGVmaW5pdGlvbik7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAga28udGFza3Muc2NoZWR1bGUoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdWJzY3JpYmFibGVbJ25vdGlmeVN1YnNjcmliZXJzJ10oZGVmaW5pdGlvbik7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29tcGxldGVkQXN5bmMgPSB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc3Vic2NyaWJhYmxlLnN1YnNjcmliZShjYWxsYmFjayk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBiZWdpbkxvYWRpbmdDb21wb25lbnQoY29tcG9uZW50TmFtZSwgY2FsbGJhY2spIHtcbiAgICAgICAgZ2V0Rmlyc3RSZXN1bHRGcm9tTG9hZGVycygnZ2V0Q29uZmlnJywgW2NvbXBvbmVudE5hbWVdLCBmdW5jdGlvbihjb25maWcpIHtcbiAgICAgICAgICAgIGlmIChjb25maWcpIHtcbiAgICAgICAgICAgICAgICAvLyBXZSBoYXZlIGEgY29uZmlnLCBzbyBub3cgbG9hZCBpdHMgZGVmaW5pdGlvblxuICAgICAgICAgICAgICAgIGdldEZpcnN0UmVzdWx0RnJvbUxvYWRlcnMoJ2xvYWRDb21wb25lbnQnLCBbY29tcG9uZW50TmFtZSwgY29uZmlnXSwgZnVuY3Rpb24oZGVmaW5pdGlvbikge1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhkZWZpbml0aW9uLCBjb25maWcpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBUaGUgY29tcG9uZW50IGhhcyBubyBjb25maWcgLSBpdCdzIHVua25vd24gdG8gYWxsIHRoZSBsb2FkZXJzLlxuICAgICAgICAgICAgICAgIC8vIE5vdGUgdGhhdCB0aGlzIGlzIG5vdCBhbiBlcnJvciAoZS5nLiwgYSBtb2R1bGUgbG9hZGluZyBlcnJvcikgLSB0aGF0IHdvdWxkIGFib3J0IHRoZVxuICAgICAgICAgICAgICAgIC8vIHByb2Nlc3MgYW5kIHRoaXMgY2FsbGJhY2sgd291bGQgbm90IHJ1bi4gRm9yIHRoaXMgY2FsbGJhY2sgdG8gcnVuLCBhbGwgbG9hZGVycyBtdXN0XG4gICAgICAgICAgICAgICAgLy8gaGF2ZSBjb25maXJtZWQgdGhleSBkb24ndCBrbm93IGFib3V0IHRoaXMgY29tcG9uZW50LlxuICAgICAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIG51bGwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRGaXJzdFJlc3VsdEZyb21Mb2FkZXJzKG1ldGhvZE5hbWUsIGFyZ3NFeGNlcHRDYWxsYmFjaywgY2FsbGJhY2ssIGNhbmRpZGF0ZUxvYWRlcnMpIHtcbiAgICAgICAgLy8gT24gdGhlIGZpcnN0IGNhbGwgaW4gdGhlIHN0YWNrLCBzdGFydCB3aXRoIHRoZSBmdWxsIHNldCBvZiBsb2FkZXJzXG4gICAgICAgIGlmICghY2FuZGlkYXRlTG9hZGVycykge1xuICAgICAgICAgICAgY2FuZGlkYXRlTG9hZGVycyA9IGtvLmNvbXBvbmVudHNbJ2xvYWRlcnMnXS5zbGljZSgwKTsgLy8gVXNlIGEgY29weSwgYmVjYXVzZSB3ZSdsbCBiZSBtdXRhdGluZyB0aGlzIGFycmF5XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUcnkgdGhlIG5leHQgY2FuZGlkYXRlXG4gICAgICAgIHZhciBjdXJyZW50Q2FuZGlkYXRlTG9hZGVyID0gY2FuZGlkYXRlTG9hZGVycy5zaGlmdCgpO1xuICAgICAgICBpZiAoY3VycmVudENhbmRpZGF0ZUxvYWRlcikge1xuICAgICAgICAgICAgdmFyIG1ldGhvZEluc3RhbmNlID0gY3VycmVudENhbmRpZGF0ZUxvYWRlclttZXRob2ROYW1lXTtcbiAgICAgICAgICAgIGlmIChtZXRob2RJbnN0YW5jZSkge1xuICAgICAgICAgICAgICAgIHZhciB3YXNBYm9ydGVkID0gZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIHN5bmNocm9ub3VzUmV0dXJuVmFsdWUgPSBtZXRob2RJbnN0YW5jZS5hcHBseShjdXJyZW50Q2FuZGlkYXRlTG9hZGVyLCBhcmdzRXhjZXB0Q2FsbGJhY2suY29uY2F0KGZ1bmN0aW9uKHJlc3VsdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHdhc0Fib3J0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhudWxsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAocmVzdWx0ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhpcyBjYW5kaWRhdGUgcmV0dXJuZWQgYSB2YWx1ZS4gVXNlIGl0LlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRyeSB0aGUgbmV4dCBjYW5kaWRhdGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZXRGaXJzdFJlc3VsdEZyb21Mb2FkZXJzKG1ldGhvZE5hbWUsIGFyZ3NFeGNlcHRDYWxsYmFjaywgY2FsbGJhY2ssIGNhbmRpZGF0ZUxvYWRlcnMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KSk7XG5cbiAgICAgICAgICAgICAgICAvLyBDdXJyZW50bHksIGxvYWRlcnMgbWF5IG5vdCByZXR1cm4gYW55dGhpbmcgc3luY2hyb25vdXNseS4gVGhpcyBsZWF2ZXMgb3BlbiB0aGUgcG9zc2liaWxpdHlcbiAgICAgICAgICAgICAgICAvLyB0aGF0IHdlJ2xsIGV4dGVuZCB0aGUgQVBJIHRvIHN1cHBvcnQgc3luY2hyb25vdXMgcmV0dXJuIHZhbHVlcyBpbiB0aGUgZnV0dXJlLiBJdCB3b24ndCBiZVxuICAgICAgICAgICAgICAgIC8vIGEgYnJlYWtpbmcgY2hhbmdlLCBiZWNhdXNlIGN1cnJlbnRseSBubyBsb2FkZXIgaXMgYWxsb3dlZCB0byByZXR1cm4gYW55dGhpbmcgZXhjZXB0IHVuZGVmaW5lZC5cbiAgICAgICAgICAgICAgICBpZiAoc3luY2hyb25vdXNSZXR1cm5WYWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHdhc0Fib3J0ZWQgPSB0cnVlO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIE1ldGhvZCB0byBzdXBwcmVzcyBleGNlcHRpb25zIHdpbGwgcmVtYWluIHVuZG9jdW1lbnRlZC4gVGhpcyBpcyBvbmx5IHRvIGtlZXBcbiAgICAgICAgICAgICAgICAgICAgLy8gS08ncyBzcGVjcyBydW5uaW5nIHRpZGlseSwgc2luY2Ugd2UgY2FuIG9ic2VydmUgdGhlIGxvYWRpbmcgZ290IGFib3J0ZWQgd2l0aG91dFxuICAgICAgICAgICAgICAgICAgICAvLyBoYXZpbmcgZXhjZXB0aW9ucyBjbHV0dGVyaW5nIHVwIHRoZSBjb25zb2xlIHRvby5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFjdXJyZW50Q2FuZGlkYXRlTG9hZGVyWydzdXBwcmVzc0xvYWRlckV4Y2VwdGlvbnMnXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDb21wb25lbnQgbG9hZGVycyBtdXN0IHN1cHBseSB2YWx1ZXMgYnkgaW52b2tpbmcgdGhlIGNhbGxiYWNrLCBub3QgYnkgcmV0dXJuaW5nIHZhbHVlcyBzeW5jaHJvbm91c2x5LicpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBUaGlzIGNhbmRpZGF0ZSBkb2Vzbid0IGhhdmUgdGhlIHJlbGV2YW50IGhhbmRsZXIuIFN5bmNocm9ub3VzbHkgbW92ZSBvbiB0byB0aGUgbmV4dCBvbmUuXG4gICAgICAgICAgICAgICAgZ2V0Rmlyc3RSZXN1bHRGcm9tTG9hZGVycyhtZXRob2ROYW1lLCBhcmdzRXhjZXB0Q2FsbGJhY2ssIGNhbGxiYWNrLCBjYW5kaWRhdGVMb2FkZXJzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIE5vIGNhbmRpZGF0ZXMgcmV0dXJuZWQgYSB2YWx1ZVxuICAgICAgICAgICAgY2FsbGJhY2sobnVsbCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBSZWZlcmVuY2UgdGhlIGxvYWRlcnMgdmlhIHN0cmluZyBuYW1lIHNvIGl0J3MgcG9zc2libGUgZm9yIGRldmVsb3BlcnNcbiAgICAvLyB0byByZXBsYWNlIHRoZSB3aG9sZSBhcnJheSBieSBhc3NpZ25pbmcgdG8ga28uY29tcG9uZW50cy5sb2FkZXJzXG4gICAga28uY29tcG9uZW50c1snbG9hZGVycyddID0gW107XG5cbiAgICBrby5leHBvcnRTeW1ib2woJ2NvbXBvbmVudHMnLCBrby5jb21wb25lbnRzKTtcbiAgICBrby5leHBvcnRTeW1ib2woJ2NvbXBvbmVudHMuZ2V0Jywga28uY29tcG9uZW50cy5nZXQpO1xuICAgIGtvLmV4cG9ydFN5bWJvbCgnY29tcG9uZW50cy5jbGVhckNhY2hlZERlZmluaXRpb24nLCBrby5jb21wb25lbnRzLmNsZWFyQ2FjaGVkRGVmaW5pdGlvbik7XG59KSgpO1xuKGZ1bmN0aW9uKHVuZGVmaW5lZCkge1xuXG4gICAgLy8gVGhlIGRlZmF1bHQgbG9hZGVyIGlzIHJlc3BvbnNpYmxlIGZvciB0d28gdGhpbmdzOlxuICAgIC8vIDEuIE1haW50YWluaW5nIHRoZSBkZWZhdWx0IGluLW1lbW9yeSByZWdpc3RyeSBvZiBjb21wb25lbnQgY29uZmlndXJhdGlvbiBvYmplY3RzXG4gICAgLy8gICAgKGkuZS4sIHRoZSB0aGluZyB5b3UncmUgd3JpdGluZyB0byB3aGVuIHlvdSBjYWxsIGtvLmNvbXBvbmVudHMucmVnaXN0ZXIoc29tZU5hbWUsIC4uLikpXG4gICAgLy8gMi4gQW5zd2VyaW5nIHJlcXVlc3RzIGZvciBjb21wb25lbnRzIGJ5IGZldGNoaW5nIGNvbmZpZ3VyYXRpb24gb2JqZWN0c1xuICAgIC8vICAgIGZyb20gdGhhdCBkZWZhdWx0IGluLW1lbW9yeSByZWdpc3RyeSBhbmQgcmVzb2x2aW5nIHRoZW0gaW50byBzdGFuZGFyZFxuICAgIC8vICAgIGNvbXBvbmVudCBkZWZpbml0aW9uIG9iamVjdHMgKG9mIHRoZSBmb3JtIHsgY3JlYXRlVmlld01vZGVsOiAuLi4sIHRlbXBsYXRlOiAuLi4gfSlcbiAgICAvLyBDdXN0b20gbG9hZGVycyBtYXkgb3ZlcnJpZGUgZWl0aGVyIG9mIHRoZXNlIGZhY2lsaXRpZXMsIGkuZS4sXG4gICAgLy8gMS4gVG8gc3VwcGx5IGNvbmZpZ3VyYXRpb24gb2JqZWN0cyBmcm9tIHNvbWUgb3RoZXIgc291cmNlIChlLmcuLCBjb252ZW50aW9ucylcbiAgICAvLyAyLiBPciwgdG8gcmVzb2x2ZSBjb25maWd1cmF0aW9uIG9iamVjdHMgYnkgbG9hZGluZyB2aWV3bW9kZWxzL3RlbXBsYXRlcyB2aWEgYXJiaXRyYXJ5IGxvZ2ljLlxuXG4gICAgdmFyIGRlZmF1bHRDb25maWdSZWdpc3RyeSA9IHt9O1xuXG4gICAga28uY29tcG9uZW50cy5yZWdpc3RlciA9IGZ1bmN0aW9uKGNvbXBvbmVudE5hbWUsIGNvbmZpZykge1xuICAgICAgICBpZiAoIWNvbmZpZykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGNvbmZpZ3VyYXRpb24gZm9yICcgKyBjb21wb25lbnROYW1lKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChrby5jb21wb25lbnRzLmlzUmVnaXN0ZXJlZChjb21wb25lbnROYW1lKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDb21wb25lbnQgJyArIGNvbXBvbmVudE5hbWUgKyAnIGlzIGFscmVhZHkgcmVnaXN0ZXJlZCcpO1xuICAgICAgICB9XG5cbiAgICAgICAgZGVmYXVsdENvbmZpZ1JlZ2lzdHJ5W2NvbXBvbmVudE5hbWVdID0gY29uZmlnO1xuICAgIH07XG5cbiAgICBrby5jb21wb25lbnRzLmlzUmVnaXN0ZXJlZCA9IGZ1bmN0aW9uKGNvbXBvbmVudE5hbWUpIHtcbiAgICAgICAgcmV0dXJuIGRlZmF1bHRDb25maWdSZWdpc3RyeS5oYXNPd25Qcm9wZXJ0eShjb21wb25lbnROYW1lKTtcbiAgICB9O1xuXG4gICAga28uY29tcG9uZW50cy51bnJlZ2lzdGVyID0gZnVuY3Rpb24oY29tcG9uZW50TmFtZSkge1xuICAgICAgICBkZWxldGUgZGVmYXVsdENvbmZpZ1JlZ2lzdHJ5W2NvbXBvbmVudE5hbWVdO1xuICAgICAgICBrby5jb21wb25lbnRzLmNsZWFyQ2FjaGVkRGVmaW5pdGlvbihjb21wb25lbnROYW1lKTtcbiAgICB9O1xuXG4gICAga28uY29tcG9uZW50cy5kZWZhdWx0TG9hZGVyID0ge1xuICAgICAgICAnZ2V0Q29uZmlnJzogZnVuY3Rpb24oY29tcG9uZW50TmFtZSwgY2FsbGJhY2spIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBkZWZhdWx0Q29uZmlnUmVnaXN0cnkuaGFzT3duUHJvcGVydHkoY29tcG9uZW50TmFtZSlcbiAgICAgICAgICAgICAgICA/IGRlZmF1bHRDb25maWdSZWdpc3RyeVtjb21wb25lbnROYW1lXVxuICAgICAgICAgICAgICAgIDogbnVsbDtcbiAgICAgICAgICAgIGNhbGxiYWNrKHJlc3VsdCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgJ2xvYWRDb21wb25lbnQnOiBmdW5jdGlvbihjb21wb25lbnROYW1lLCBjb25maWcsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICB2YXIgZXJyb3JDYWxsYmFjayA9IG1ha2VFcnJvckNhbGxiYWNrKGNvbXBvbmVudE5hbWUpO1xuICAgICAgICAgICAgcG9zc2libHlHZXRDb25maWdGcm9tQW1kKGVycm9yQ2FsbGJhY2ssIGNvbmZpZywgZnVuY3Rpb24obG9hZGVkQ29uZmlnKSB7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZUNvbmZpZyhjb21wb25lbnROYW1lLCBlcnJvckNhbGxiYWNrLCBsb2FkZWRDb25maWcsIGNhbGxiYWNrKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuXG4gICAgICAgICdsb2FkVGVtcGxhdGUnOiBmdW5jdGlvbihjb21wb25lbnROYW1lLCB0ZW1wbGF0ZUNvbmZpZywgY2FsbGJhY2spIHtcbiAgICAgICAgICAgIHJlc29sdmVUZW1wbGF0ZShtYWtlRXJyb3JDYWxsYmFjayhjb21wb25lbnROYW1lKSwgdGVtcGxhdGVDb25maWcsIGNhbGxiYWNrKTtcbiAgICAgICAgfSxcblxuICAgICAgICAnbG9hZFZpZXdNb2RlbCc6IGZ1bmN0aW9uKGNvbXBvbmVudE5hbWUsIHZpZXdNb2RlbENvbmZpZywgY2FsbGJhY2spIHtcbiAgICAgICAgICAgIHJlc29sdmVWaWV3TW9kZWwobWFrZUVycm9yQ2FsbGJhY2soY29tcG9uZW50TmFtZSksIHZpZXdNb2RlbENvbmZpZywgY2FsbGJhY2spO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHZhciBjcmVhdGVWaWV3TW9kZWxLZXkgPSAnY3JlYXRlVmlld01vZGVsJztcblxuICAgIC8vIFRha2VzIGEgY29uZmlnIG9iamVjdCBvZiB0aGUgZm9ybSB7IHRlbXBsYXRlOiAuLi4sIHZpZXdNb2RlbDogLi4uIH0sIGFuZCBhc3luY2hyb25vdXNseSBjb252ZXJ0IGl0XG4gICAgLy8gaW50byB0aGUgc3RhbmRhcmQgY29tcG9uZW50IGRlZmluaXRpb24gZm9ybWF0OlxuICAgIC8vICAgIHsgdGVtcGxhdGU6IDxBcnJheU9mRG9tTm9kZXM+LCBjcmVhdGVWaWV3TW9kZWw6IGZ1bmN0aW9uKHBhcmFtcywgY29tcG9uZW50SW5mbykgeyAuLi4gfSB9LlxuICAgIC8vIFNpbmNlIGJvdGggdGVtcGxhdGUgYW5kIHZpZXdNb2RlbCBtYXkgbmVlZCB0byBiZSByZXNvbHZlZCBhc3luY2hyb25vdXNseSwgYm90aCB0YXNrcyBhcmUgcGVyZm9ybWVkXG4gICAgLy8gaW4gcGFyYWxsZWwsIGFuZCB0aGUgcmVzdWx0cyBqb2luZWQgd2hlbiBib3RoIGFyZSByZWFkeS4gV2UgZG9uJ3QgZGVwZW5kIG9uIGFueSBwcm9taXNlcyBpbmZyYXN0cnVjdHVyZSxcbiAgICAvLyBzbyB0aGlzIGlzIGltcGxlbWVudGVkIG1hbnVhbGx5IGJlbG93LlxuICAgIGZ1bmN0aW9uIHJlc29sdmVDb25maWcoY29tcG9uZW50TmFtZSwgZXJyb3JDYWxsYmFjaywgY29uZmlnLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgcmVzdWx0ID0ge30sXG4gICAgICAgICAgICBtYWtlQ2FsbEJhY2tXaGVuWmVybyA9IDIsXG4gICAgICAgICAgICB0cnlJc3N1ZUNhbGxiYWNrID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgaWYgKC0tbWFrZUNhbGxCYWNrV2hlblplcm8gPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2socmVzdWx0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdGVtcGxhdGVDb25maWcgPSBjb25maWdbJ3RlbXBsYXRlJ10sXG4gICAgICAgICAgICB2aWV3TW9kZWxDb25maWcgPSBjb25maWdbJ3ZpZXdNb2RlbCddO1xuXG4gICAgICAgIGlmICh0ZW1wbGF0ZUNvbmZpZykge1xuICAgICAgICAgICAgcG9zc2libHlHZXRDb25maWdGcm9tQW1kKGVycm9yQ2FsbGJhY2ssIHRlbXBsYXRlQ29uZmlnLCBmdW5jdGlvbihsb2FkZWRDb25maWcpIHtcbiAgICAgICAgICAgICAgICBrby5jb21wb25lbnRzLl9nZXRGaXJzdFJlc3VsdEZyb21Mb2FkZXJzKCdsb2FkVGVtcGxhdGUnLCBbY29tcG9uZW50TmFtZSwgbG9hZGVkQ29uZmlnXSwgZnVuY3Rpb24ocmVzb2x2ZWRUZW1wbGF0ZSkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHRbJ3RlbXBsYXRlJ10gPSByZXNvbHZlZFRlbXBsYXRlO1xuICAgICAgICAgICAgICAgICAgICB0cnlJc3N1ZUNhbGxiYWNrKCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRyeUlzc3VlQ2FsbGJhY2soKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh2aWV3TW9kZWxDb25maWcpIHtcbiAgICAgICAgICAgIHBvc3NpYmx5R2V0Q29uZmlnRnJvbUFtZChlcnJvckNhbGxiYWNrLCB2aWV3TW9kZWxDb25maWcsIGZ1bmN0aW9uKGxvYWRlZENvbmZpZykge1xuICAgICAgICAgICAgICAgIGtvLmNvbXBvbmVudHMuX2dldEZpcnN0UmVzdWx0RnJvbUxvYWRlcnMoJ2xvYWRWaWV3TW9kZWwnLCBbY29tcG9uZW50TmFtZSwgbG9hZGVkQ29uZmlnXSwgZnVuY3Rpb24ocmVzb2x2ZWRWaWV3TW9kZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0W2NyZWF0ZVZpZXdNb2RlbEtleV0gPSByZXNvbHZlZFZpZXdNb2RlbDtcbiAgICAgICAgICAgICAgICAgICAgdHJ5SXNzdWVDYWxsYmFjaygpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0cnlJc3N1ZUNhbGxiYWNrKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZXNvbHZlVGVtcGxhdGUoZXJyb3JDYWxsYmFjaywgdGVtcGxhdGVDb25maWcsIGNhbGxiYWNrKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdGVtcGxhdGVDb25maWcgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAvLyBNYXJrdXAgLSBwYXJzZSBpdFxuICAgICAgICAgICAgY2FsbGJhY2soa28udXRpbHMucGFyc2VIdG1sRnJhZ21lbnQodGVtcGxhdGVDb25maWcpKTtcbiAgICAgICAgfSBlbHNlIGlmICh0ZW1wbGF0ZUNvbmZpZyBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgICAgICAvLyBBc3N1bWUgYWxyZWFkeSBhbiBhcnJheSBvZiBET00gbm9kZXMgLSBwYXNzIHRocm91Z2ggdW5jaGFuZ2VkXG4gICAgICAgICAgICBjYWxsYmFjayh0ZW1wbGF0ZUNvbmZpZyk7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNEb2N1bWVudEZyYWdtZW50KHRlbXBsYXRlQ29uZmlnKSkge1xuICAgICAgICAgICAgLy8gRG9jdW1lbnQgZnJhZ21lbnQgLSB1c2UgaXRzIGNoaWxkIG5vZGVzXG4gICAgICAgICAgICBjYWxsYmFjayhrby51dGlscy5tYWtlQXJyYXkodGVtcGxhdGVDb25maWcuY2hpbGROb2RlcykpO1xuICAgICAgICB9IGVsc2UgaWYgKHRlbXBsYXRlQ29uZmlnWydlbGVtZW50J10pIHtcbiAgICAgICAgICAgIHZhciBlbGVtZW50ID0gdGVtcGxhdGVDb25maWdbJ2VsZW1lbnQnXTtcbiAgICAgICAgICAgIGlmIChpc0RvbUVsZW1lbnQoZWxlbWVudCkpIHtcbiAgICAgICAgICAgICAgICAvLyBFbGVtZW50IGluc3RhbmNlIC0gY29weSBpdHMgY2hpbGQgbm9kZXNcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhjbG9uZU5vZGVzRnJvbVRlbXBsYXRlU291cmNlRWxlbWVudChlbGVtZW50KSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBlbGVtZW50ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIC8vIEVsZW1lbnQgSUQgLSBmaW5kIGl0LCB0aGVuIGNvcHkgaXRzIGNoaWxkIG5vZGVzXG4gICAgICAgICAgICAgICAgdmFyIGVsZW1JbnN0YW5jZSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGVsZW1lbnQpO1xuICAgICAgICAgICAgICAgIGlmIChlbGVtSW5zdGFuY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soY2xvbmVOb2Rlc0Zyb21UZW1wbGF0ZVNvdXJjZUVsZW1lbnQoZWxlbUluc3RhbmNlKSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3JDYWxsYmFjaygnQ2Fubm90IGZpbmQgZWxlbWVudCB3aXRoIElEICcgKyBlbGVtZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGVycm9yQ2FsbGJhY2soJ1Vua25vd24gZWxlbWVudCB0eXBlOiAnICsgZWxlbWVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBlcnJvckNhbGxiYWNrKCdVbmtub3duIHRlbXBsYXRlIHZhbHVlOiAnICsgdGVtcGxhdGVDb25maWcpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVzb2x2ZVZpZXdNb2RlbChlcnJvckNhbGxiYWNrLCB2aWV3TW9kZWxDb25maWcsIGNhbGxiYWNrKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygdmlld01vZGVsQ29uZmlnID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAvLyBDb25zdHJ1Y3RvciAtIGNvbnZlcnQgdG8gc3RhbmRhcmQgZmFjdG9yeSBmdW5jdGlvbiBmb3JtYXRcbiAgICAgICAgICAgIC8vIEJ5IGRlc2lnbiwgdGhpcyBkb2VzICpub3QqIHN1cHBseSBjb21wb25lbnRJbmZvIHRvIHRoZSBjb25zdHJ1Y3RvciwgYXMgdGhlIGludGVudCBpcyB0aGF0XG4gICAgICAgICAgICAvLyBjb21wb25lbnRJbmZvIGNvbnRhaW5zIG5vbi12aWV3bW9kZWwgZGF0YSAoZS5nLiwgdGhlIGNvbXBvbmVudCdzIGVsZW1lbnQpIHRoYXQgc2hvdWxkIG9ubHlcbiAgICAgICAgICAgIC8vIGJlIHVzZWQgaW4gZmFjdG9yeSBmdW5jdGlvbnMsIG5vdCB2aWV3bW9kZWwgY29uc3RydWN0b3JzLlxuICAgICAgICAgICAgY2FsbGJhY2soZnVuY3Rpb24gKHBhcmFtcyAvKiwgY29tcG9uZW50SW5mbyAqLykge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgdmlld01vZGVsQ29uZmlnKHBhcmFtcyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2Ygdmlld01vZGVsQ29uZmlnW2NyZWF0ZVZpZXdNb2RlbEtleV0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIC8vIEFscmVhZHkgYSBmYWN0b3J5IGZ1bmN0aW9uIC0gdXNlIGl0IGFzLWlzXG4gICAgICAgICAgICBjYWxsYmFjayh2aWV3TW9kZWxDb25maWdbY3JlYXRlVmlld01vZGVsS2V5XSk7XG4gICAgICAgIH0gZWxzZSBpZiAoJ2luc3RhbmNlJyBpbiB2aWV3TW9kZWxDb25maWcpIHtcbiAgICAgICAgICAgIC8vIEZpeGVkIG9iamVjdCBpbnN0YW5jZSAtIHByb21vdGUgdG8gY3JlYXRlVmlld01vZGVsIGZvcm1hdCBmb3IgQVBJIGNvbnNpc3RlbmN5XG4gICAgICAgICAgICB2YXIgZml4ZWRJbnN0YW5jZSA9IHZpZXdNb2RlbENvbmZpZ1snaW5zdGFuY2UnXTtcbiAgICAgICAgICAgIGNhbGxiYWNrKGZ1bmN0aW9uIChwYXJhbXMsIGNvbXBvbmVudEluZm8pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZml4ZWRJbnN0YW5jZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2UgaWYgKCd2aWV3TW9kZWwnIGluIHZpZXdNb2RlbENvbmZpZykge1xuICAgICAgICAgICAgLy8gUmVzb2x2ZWQgQU1EIG1vZHVsZSB3aG9zZSB2YWx1ZSBpcyBvZiB0aGUgZm9ybSB7IHZpZXdNb2RlbDogLi4uIH1cbiAgICAgICAgICAgIHJlc29sdmVWaWV3TW9kZWwoZXJyb3JDYWxsYmFjaywgdmlld01vZGVsQ29uZmlnWyd2aWV3TW9kZWwnXSwgY2FsbGJhY2spO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZXJyb3JDYWxsYmFjaygnVW5rbm93biB2aWV3TW9kZWwgdmFsdWU6ICcgKyB2aWV3TW9kZWxDb25maWcpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2xvbmVOb2Rlc0Zyb21UZW1wbGF0ZVNvdXJjZUVsZW1lbnQoZWxlbUluc3RhbmNlKSB7XG4gICAgICAgIHN3aXRjaCAoa28udXRpbHMudGFnTmFtZUxvd2VyKGVsZW1JbnN0YW5jZSkpIHtcbiAgICAgICAgICAgIGNhc2UgJ3NjcmlwdCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGtvLnV0aWxzLnBhcnNlSHRtbEZyYWdtZW50KGVsZW1JbnN0YW5jZS50ZXh0KTtcbiAgICAgICAgICAgIGNhc2UgJ3RleHRhcmVhJzpcbiAgICAgICAgICAgICAgICByZXR1cm4ga28udXRpbHMucGFyc2VIdG1sRnJhZ21lbnQoZWxlbUluc3RhbmNlLnZhbHVlKTtcbiAgICAgICAgICAgIGNhc2UgJ3RlbXBsYXRlJzpcbiAgICAgICAgICAgICAgICAvLyBGb3IgYnJvd3NlcnMgd2l0aCBwcm9wZXIgPHRlbXBsYXRlPiBlbGVtZW50IHN1cHBvcnQgKGkuZS4sIHdoZXJlIHRoZSAuY29udGVudCBwcm9wZXJ0eVxuICAgICAgICAgICAgICAgIC8vIGdpdmVzIGEgZG9jdW1lbnQgZnJhZ21lbnQpLCB1c2UgdGhhdCBkb2N1bWVudCBmcmFnbWVudC5cbiAgICAgICAgICAgICAgICBpZiAoaXNEb2N1bWVudEZyYWdtZW50KGVsZW1JbnN0YW5jZS5jb250ZW50KSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4ga28udXRpbHMuY2xvbmVOb2RlcyhlbGVtSW5zdGFuY2UuY29udGVudC5jaGlsZE5vZGVzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBSZWd1bGFyIGVsZW1lbnRzIHN1Y2ggYXMgPGRpdj4sIGFuZCA8dGVtcGxhdGU+IGVsZW1lbnRzIG9uIG9sZCBicm93c2VycyB0aGF0IGRvbid0IHJlYWxseVxuICAgICAgICAvLyB1bmRlcnN0YW5kIDx0ZW1wbGF0ZT4gYW5kIGp1c3QgdHJlYXQgaXQgYXMgYSByZWd1bGFyIGNvbnRhaW5lclxuICAgICAgICByZXR1cm4ga28udXRpbHMuY2xvbmVOb2RlcyhlbGVtSW5zdGFuY2UuY2hpbGROb2Rlcyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNEb21FbGVtZW50KG9iaikge1xuICAgICAgICBpZiAod2luZG93WydIVE1MRWxlbWVudCddKSB7XG4gICAgICAgICAgICByZXR1cm4gb2JqIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gb2JqICYmIG9iai50YWdOYW1lICYmIG9iai5ub2RlVHlwZSA9PT0gMTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzRG9jdW1lbnRGcmFnbWVudChvYmopIHtcbiAgICAgICAgaWYgKHdpbmRvd1snRG9jdW1lbnRGcmFnbWVudCddKSB7XG4gICAgICAgICAgICByZXR1cm4gb2JqIGluc3RhbmNlb2YgRG9jdW1lbnRGcmFnbWVudDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBvYmogJiYgb2JqLm5vZGVUeXBlID09PSAxMTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBvc3NpYmx5R2V0Q29uZmlnRnJvbUFtZChlcnJvckNhbGxiYWNrLCBjb25maWcsIGNhbGxiYWNrKSB7XG4gICAgICAgIGlmICh0eXBlb2YgY29uZmlnWydyZXF1aXJlJ10gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAvLyBUaGUgY29uZmlnIGlzIHRoZSB2YWx1ZSBvZiBhbiBBTUQgbW9kdWxlXG4gICAgICAgICAgICBpZiAoYW1kUmVxdWlyZSB8fCB3aW5kb3dbJ3JlcXVpcmUnXSkge1xuICAgICAgICAgICAgICAgIChhbWRSZXF1aXJlIHx8IHdpbmRvd1sncmVxdWlyZSddKShbY29uZmlnWydyZXF1aXJlJ11dLCBjYWxsYmFjayk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGVycm9yQ2FsbGJhY2soJ1VzZXMgcmVxdWlyZSwgYnV0IG5vIEFNRCBsb2FkZXIgaXMgcHJlc2VudCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FsbGJhY2soY29uZmlnKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1ha2VFcnJvckNhbGxiYWNrKGNvbXBvbmVudE5hbWUpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChtZXNzYWdlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvbXBvbmVudCBcXCcnICsgY29tcG9uZW50TmFtZSArICdcXCc6ICcgKyBtZXNzYWdlKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBrby5leHBvcnRTeW1ib2woJ2NvbXBvbmVudHMucmVnaXN0ZXInLCBrby5jb21wb25lbnRzLnJlZ2lzdGVyKTtcbiAgICBrby5leHBvcnRTeW1ib2woJ2NvbXBvbmVudHMuaXNSZWdpc3RlcmVkJywga28uY29tcG9uZW50cy5pc1JlZ2lzdGVyZWQpO1xuICAgIGtvLmV4cG9ydFN5bWJvbCgnY29tcG9uZW50cy51bnJlZ2lzdGVyJywga28uY29tcG9uZW50cy51bnJlZ2lzdGVyKTtcblxuICAgIC8vIEV4cG9zZSB0aGUgZGVmYXVsdCBsb2FkZXIgc28gdGhhdCBkZXZlbG9wZXJzIGNhbiBkaXJlY3RseSBhc2sgaXQgZm9yIGNvbmZpZ3VyYXRpb25cbiAgICAvLyBvciB0byByZXNvbHZlIGNvbmZpZ3VyYXRpb25cbiAgICBrby5leHBvcnRTeW1ib2woJ2NvbXBvbmVudHMuZGVmYXVsdExvYWRlcicsIGtvLmNvbXBvbmVudHMuZGVmYXVsdExvYWRlcik7XG5cbiAgICAvLyBCeSBkZWZhdWx0LCB0aGUgZGVmYXVsdCBsb2FkZXIgaXMgdGhlIG9ubHkgcmVnaXN0ZXJlZCBjb21wb25lbnQgbG9hZGVyXG4gICAga28uY29tcG9uZW50c1snbG9hZGVycyddLnB1c2goa28uY29tcG9uZW50cy5kZWZhdWx0TG9hZGVyKTtcblxuICAgIC8vIFByaXZhdGVseSBleHBvc2UgdGhlIHVuZGVybHlpbmcgY29uZmlnIHJlZ2lzdHJ5IGZvciB1c2UgaW4gb2xkLUlFIHNoaW1cbiAgICBrby5jb21wb25lbnRzLl9hbGxSZWdpc3RlcmVkQ29tcG9uZW50cyA9IGRlZmF1bHRDb25maWdSZWdpc3RyeTtcbn0pKCk7XG4oZnVuY3Rpb24gKHVuZGVmaW5lZCkge1xuICAgIC8vIE92ZXJyaWRhYmxlIEFQSSBmb3IgZGV0ZXJtaW5pbmcgd2hpY2ggY29tcG9uZW50IG5hbWUgYXBwbGllcyB0byBhIGdpdmVuIG5vZGUuIEJ5IG92ZXJyaWRpbmcgdGhpcyxcbiAgICAvLyB5b3UgY2FuIGZvciBleGFtcGxlIG1hcCBzcGVjaWZpYyB0YWdOYW1lcyB0byBjb21wb25lbnRzIHRoYXQgYXJlIG5vdCBwcmVyZWdpc3RlcmVkLlxuICAgIGtvLmNvbXBvbmVudHNbJ2dldENvbXBvbmVudE5hbWVGb3JOb2RlJ10gPSBmdW5jdGlvbihub2RlKSB7XG4gICAgICAgIHZhciB0YWdOYW1lTG93ZXIgPSBrby51dGlscy50YWdOYW1lTG93ZXIobm9kZSk7XG4gICAgICAgIGlmIChrby5jb21wb25lbnRzLmlzUmVnaXN0ZXJlZCh0YWdOYW1lTG93ZXIpKSB7XG4gICAgICAgICAgICAvLyBUcnkgdG8gZGV0ZXJtaW5lIHRoYXQgdGhpcyBub2RlIGNhbiBiZSBjb25zaWRlcmVkIGEgKmN1c3RvbSogZWxlbWVudDsgc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9rbm9ja291dC9rbm9ja291dC9pc3N1ZXMvMTYwM1xuICAgICAgICAgICAgaWYgKHRhZ05hbWVMb3dlci5pbmRleE9mKCctJykgIT0gLTEgfHwgKCcnICsgbm9kZSkgPT0gXCJbb2JqZWN0IEhUTUxVbmtub3duRWxlbWVudF1cIiB8fCAoa28udXRpbHMuaWVWZXJzaW9uIDw9IDggJiYgbm9kZS50YWdOYW1lID09PSB0YWdOYW1lTG93ZXIpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRhZ05hbWVMb3dlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBrby5jb21wb25lbnRzLmFkZEJpbmRpbmdzRm9yQ3VzdG9tRWxlbWVudCA9IGZ1bmN0aW9uKGFsbEJpbmRpbmdzLCBub2RlLCBiaW5kaW5nQ29udGV4dCwgdmFsdWVBY2Nlc3NvcnMpIHtcbiAgICAgICAgLy8gRGV0ZXJtaW5lIGlmIGl0J3MgcmVhbGx5IGEgY3VzdG9tIGVsZW1lbnQgbWF0Y2hpbmcgYSBjb21wb25lbnRcbiAgICAgICAgaWYgKG5vZGUubm9kZVR5cGUgPT09IDEpIHtcbiAgICAgICAgICAgIHZhciBjb21wb25lbnROYW1lID0ga28uY29tcG9uZW50c1snZ2V0Q29tcG9uZW50TmFtZUZvck5vZGUnXShub2RlKTtcbiAgICAgICAgICAgIGlmIChjb21wb25lbnROYW1lKSB7XG4gICAgICAgICAgICAgICAgLy8gSXQgZG9lcyByZXByZXNlbnQgYSBjb21wb25lbnQsIHNvIGFkZCBhIGNvbXBvbmVudCBiaW5kaW5nIGZvciBpdFxuICAgICAgICAgICAgICAgIGFsbEJpbmRpbmdzID0gYWxsQmluZGluZ3MgfHwge307XG5cbiAgICAgICAgICAgICAgICBpZiAoYWxsQmluZGluZ3NbJ2NvbXBvbmVudCddKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEF2b2lkIHNpbGVudGx5IG92ZXJ3cml0aW5nIHNvbWUgb3RoZXIgJ2NvbXBvbmVudCcgYmluZGluZyB0aGF0IG1heSBhbHJlYWR5IGJlIG9uIHRoZSBlbGVtZW50XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IHVzZSB0aGUgXCJjb21wb25lbnRcIiBiaW5kaW5nIG9uIGEgY3VzdG9tIGVsZW1lbnQgbWF0Y2hpbmcgYSBjb21wb25lbnQnKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgY29tcG9uZW50QmluZGluZ1ZhbHVlID0geyAnbmFtZSc6IGNvbXBvbmVudE5hbWUsICdwYXJhbXMnOiBnZXRDb21wb25lbnRQYXJhbXNGcm9tQ3VzdG9tRWxlbWVudChub2RlLCBiaW5kaW5nQ29udGV4dCkgfTtcblxuICAgICAgICAgICAgICAgIGFsbEJpbmRpbmdzWydjb21wb25lbnQnXSA9IHZhbHVlQWNjZXNzb3JzXG4gICAgICAgICAgICAgICAgICAgID8gZnVuY3Rpb24oKSB7IHJldHVybiBjb21wb25lbnRCaW5kaW5nVmFsdWU7IH1cbiAgICAgICAgICAgICAgICAgICAgOiBjb21wb25lbnRCaW5kaW5nVmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYWxsQmluZGluZ3M7XG4gICAgfVxuXG4gICAgdmFyIG5hdGl2ZUJpbmRpbmdQcm92aWRlckluc3RhbmNlID0gbmV3IGtvLmJpbmRpbmdQcm92aWRlcigpO1xuXG4gICAgZnVuY3Rpb24gZ2V0Q29tcG9uZW50UGFyYW1zRnJvbUN1c3RvbUVsZW1lbnQoZWxlbSwgYmluZGluZ0NvbnRleHQpIHtcbiAgICAgICAgdmFyIHBhcmFtc0F0dHJpYnV0ZSA9IGVsZW0uZ2V0QXR0cmlidXRlKCdwYXJhbXMnKTtcblxuICAgICAgICBpZiAocGFyYW1zQXR0cmlidXRlKSB7XG4gICAgICAgICAgICB2YXIgcGFyYW1zID0gbmF0aXZlQmluZGluZ1Byb3ZpZGVySW5zdGFuY2VbJ3BhcnNlQmluZGluZ3NTdHJpbmcnXShwYXJhbXNBdHRyaWJ1dGUsIGJpbmRpbmdDb250ZXh0LCBlbGVtLCB7ICd2YWx1ZUFjY2Vzc29ycyc6IHRydWUsICdiaW5kaW5nUGFyYW1zJzogdHJ1ZSB9KSxcbiAgICAgICAgICAgICAgICByYXdQYXJhbUNvbXB1dGVkVmFsdWVzID0ga28udXRpbHMub2JqZWN0TWFwKHBhcmFtcywgZnVuY3Rpb24ocGFyYW1WYWx1ZSwgcGFyYW1OYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBrby5jb21wdXRlZChwYXJhbVZhbHVlLCBudWxsLCB7IGRpc3Bvc2VXaGVuTm9kZUlzUmVtb3ZlZDogZWxlbSB9KTtcbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBrby51dGlscy5vYmplY3RNYXAocmF3UGFyYW1Db21wdXRlZFZhbHVlcywgZnVuY3Rpb24ocGFyYW1WYWx1ZUNvbXB1dGVkLCBwYXJhbU5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBhcmFtVmFsdWUgPSBwYXJhbVZhbHVlQ29tcHV0ZWQucGVlaygpO1xuICAgICAgICAgICAgICAgICAgICAvLyBEb2VzIHRoZSBldmFsdWF0aW9uIG9mIHRoZSBwYXJhbWV0ZXIgdmFsdWUgdW53cmFwIGFueSBvYnNlcnZhYmxlcz9cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFwYXJhbVZhbHVlQ29tcHV0ZWQuaXNBY3RpdmUoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gTm8gaXQgZG9lc24ndCwgc28gdGhlcmUncyBubyBuZWVkIGZvciBhbnkgY29tcHV0ZWQgd3JhcHBlci4gSnVzdCBwYXNzIHRocm91Z2ggdGhlIHN1cHBsaWVkIHZhbHVlIGRpcmVjdGx5LlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRXhhbXBsZTogXCJzb21lVmFsOiBmaXJzdE5hbWUsIGFnZTogMTIzXCIgKHdoZXRoZXIgb3Igbm90IGZpcnN0TmFtZSBpcyBhbiBvYnNlcnZhYmxlL2NvbXB1dGVkKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBhcmFtVmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBZZXMgaXQgZG9lcy4gU3VwcGx5IGEgY29tcHV0ZWQgcHJvcGVydHkgdGhhdCB1bndyYXBzIGJvdGggdGhlIG91dGVyIChiaW5kaW5nIGV4cHJlc3Npb24pXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBsZXZlbCBvZiBvYnNlcnZhYmlsaXR5LCBhbmQgYW55IGlubmVyIChyZXN1bHRpbmcgbW9kZWwgdmFsdWUpIGxldmVsIG9mIG9ic2VydmFiaWxpdHkuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGlzIG1lYW5zIHRoZSBjb21wb25lbnQgZG9lc24ndCBoYXZlIHRvIHdvcnJ5IGFib3V0IG11bHRpcGxlIHVud3JhcHBpbmcuIElmIHRoZSB2YWx1ZSBpcyBhXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB3cml0YWJsZSBvYnNlcnZhYmxlLCB0aGUgY29tcHV0ZWQgd2lsbCBhbHNvIGJlIHdyaXRhYmxlIGFuZCBwYXNzIHRoZSB2YWx1ZSBvbiB0byB0aGUgb2JzZXJ2YWJsZS5cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBrby5jb21wdXRlZCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3JlYWQnOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGtvLnV0aWxzLnVud3JhcE9ic2VydmFibGUocGFyYW1WYWx1ZUNvbXB1dGVkKCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3dyaXRlJzoga28uaXNXcml0ZWFibGVPYnNlcnZhYmxlKHBhcmFtVmFsdWUpICYmIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtVmFsdWVDb21wdXRlZCgpKHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpc3Bvc2VXaGVuTm9kZUlzUmVtb3ZlZDogZWxlbVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgLy8gR2l2ZSBhY2Nlc3MgdG8gdGhlIHJhdyBjb21wdXRlZHMsIGFzIGxvbmcgYXMgdGhhdCB3b3VsZG4ndCBvdmVyd3JpdGUgYW55IGN1c3RvbSBwYXJhbSBhbHNvIGNhbGxlZCAnJHJhdydcbiAgICAgICAgICAgIC8vIFRoaXMgaXMgaW4gY2FzZSB0aGUgZGV2ZWxvcGVyIHdhbnRzIHRvIHJlYWN0IHRvIG91dGVyIChiaW5kaW5nKSBvYnNlcnZhYmlsaXR5IHNlcGFyYXRlbHkgZnJvbSBpbm5lclxuICAgICAgICAgICAgLy8gKG1vZGVsIHZhbHVlKSBvYnNlcnZhYmlsaXR5LCBvciBpbiBjYXNlIHRoZSBtb2RlbCB2YWx1ZSBvYnNlcnZhYmxlIGhhcyBzdWJvYnNlcnZhYmxlcy5cbiAgICAgICAgICAgIGlmICghcmVzdWx0Lmhhc093blByb3BlcnR5KCckcmF3JykpIHtcbiAgICAgICAgICAgICAgICByZXN1bHRbJyRyYXcnXSA9IHJhd1BhcmFtQ29tcHV0ZWRWYWx1ZXM7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBGb3IgY29uc2lzdGVuY3ksIGFic2VuY2Ugb2YgYSBcInBhcmFtc1wiIGF0dHJpYnV0ZSBpcyB0cmVhdGVkIHRoZSBzYW1lIGFzIHRoZSBwcmVzZW5jZSBvZlxuICAgICAgICAgICAgLy8gYW55IGVtcHR5IG9uZS4gT3RoZXJ3aXNlIGNvbXBvbmVudCB2aWV3bW9kZWxzIG5lZWQgc3BlY2lhbCBjb2RlIHRvIGNoZWNrIHdoZXRoZXIgb3Igbm90XG4gICAgICAgICAgICAvLyAncGFyYW1zJyBvciAncGFyYW1zLiRyYXcnIGlzIG51bGwvdW5kZWZpbmVkIGJlZm9yZSByZWFkaW5nIHN1YnByb3BlcnRpZXMsIHdoaWNoIGlzIGFubm95aW5nLlxuICAgICAgICAgICAgcmV0dXJuIHsgJyRyYXcnOiB7fSB9O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvLyBDb21wYXRpYmlsaXR5IGNvZGUgZm9yIG9sZGVyIChwcmUtSFRNTDUpIElFIGJyb3dzZXJzXG5cbiAgICBpZiAoa28udXRpbHMuaWVWZXJzaW9uIDwgOSkge1xuICAgICAgICAvLyBXaGVuZXZlciB5b3UgcHJlcmVnaXN0ZXIgYSBjb21wb25lbnQsIGVuYWJsZSBpdCBhcyBhIGN1c3RvbSBlbGVtZW50IGluIHRoZSBjdXJyZW50IGRvY3VtZW50XG4gICAgICAgIGtvLmNvbXBvbmVudHNbJ3JlZ2lzdGVyJ10gPSAoZnVuY3Rpb24ob3JpZ2luYWxGdW5jdGlvbikge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKGNvbXBvbmVudE5hbWUpIHtcbiAgICAgICAgICAgICAgICBkb2N1bWVudC5jcmVhdGVFbGVtZW50KGNvbXBvbmVudE5hbWUpOyAvLyBBbGxvd3MgSUU8OSB0byBwYXJzZSBtYXJrdXAgY29udGFpbmluZyB0aGUgY3VzdG9tIGVsZW1lbnRcbiAgICAgICAgICAgICAgICByZXR1cm4gb3JpZ2luYWxGdW5jdGlvbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KShrby5jb21wb25lbnRzWydyZWdpc3RlciddKTtcblxuICAgICAgICAvLyBXaGVuZXZlciB5b3UgY3JlYXRlIGEgZG9jdW1lbnQgZnJhZ21lbnQsIGVuYWJsZSBhbGwgcHJlcmVnaXN0ZXJlZCBjb21wb25lbnQgbmFtZXMgYXMgY3VzdG9tIGVsZW1lbnRzXG4gICAgICAgIC8vIFRoaXMgaXMgbmVlZGVkIHRvIG1ha2UgaW5uZXJTaGl2L2pRdWVyeSBIVE1MIHBhcnNpbmcgY29ycmVjdGx5IGhhbmRsZSB0aGUgY3VzdG9tIGVsZW1lbnRzXG4gICAgICAgIGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQgPSAoZnVuY3Rpb24ob3JpZ2luYWxGdW5jdGlvbikge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHZhciBuZXdEb2NGcmFnID0gb3JpZ2luYWxGdW5jdGlvbigpLFxuICAgICAgICAgICAgICAgICAgICBhbGxDb21wb25lbnRzID0ga28uY29tcG9uZW50cy5fYWxsUmVnaXN0ZXJlZENvbXBvbmVudHM7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgY29tcG9uZW50TmFtZSBpbiBhbGxDb21wb25lbnRzKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChhbGxDb21wb25lbnRzLmhhc093blByb3BlcnR5KGNvbXBvbmVudE5hbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdEb2NGcmFnLmNyZWF0ZUVsZW1lbnQoY29tcG9uZW50TmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ld0RvY0ZyYWc7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9KShkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KTtcbiAgICB9XG59KSgpOyhmdW5jdGlvbih1bmRlZmluZWQpIHtcblxuICAgIHZhciBjb21wb25lbnRMb2FkaW5nT3BlcmF0aW9uVW5pcXVlSWQgPSAwO1xuXG4gICAga28uYmluZGluZ0hhbmRsZXJzWydjb21wb25lbnQnXSA9IHtcbiAgICAgICAgJ2luaXQnOiBmdW5jdGlvbihlbGVtZW50LCB2YWx1ZUFjY2Vzc29yLCBpZ25vcmVkMSwgaWdub3JlZDIsIGJpbmRpbmdDb250ZXh0KSB7XG4gICAgICAgICAgICB2YXIgY3VycmVudFZpZXdNb2RlbCxcbiAgICAgICAgICAgICAgICBjdXJyZW50TG9hZGluZ09wZXJhdGlvbklkLFxuICAgICAgICAgICAgICAgIGRpc3Bvc2VBc3NvY2lhdGVkQ29tcG9uZW50Vmlld01vZGVsID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgY3VycmVudFZpZXdNb2RlbERpc3Bvc2UgPSBjdXJyZW50Vmlld01vZGVsICYmIGN1cnJlbnRWaWV3TW9kZWxbJ2Rpc3Bvc2UnXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBjdXJyZW50Vmlld01vZGVsRGlzcG9zZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFZpZXdNb2RlbERpc3Bvc2UuY2FsbChjdXJyZW50Vmlld01vZGVsKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50Vmlld01vZGVsID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgLy8gQW55IGluLWZsaWdodCBsb2FkaW5nIG9wZXJhdGlvbiBpcyBubyBsb25nZXIgcmVsZXZhbnQsIHNvIG1ha2Ugc3VyZSB3ZSBpZ25vcmUgaXRzIGNvbXBsZXRpb25cbiAgICAgICAgICAgICAgICAgICAgY3VycmVudExvYWRpbmdPcGVyYXRpb25JZCA9IG51bGw7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBvcmlnaW5hbENoaWxkTm9kZXMgPSBrby51dGlscy5tYWtlQXJyYXkoa28udmlydHVhbEVsZW1lbnRzLmNoaWxkTm9kZXMoZWxlbWVudCkpO1xuXG4gICAgICAgICAgICBrby51dGlscy5kb21Ob2RlRGlzcG9zYWwuYWRkRGlzcG9zZUNhbGxiYWNrKGVsZW1lbnQsIGRpc3Bvc2VBc3NvY2lhdGVkQ29tcG9uZW50Vmlld01vZGVsKTtcblxuICAgICAgICAgICAga28uY29tcHV0ZWQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IGtvLnV0aWxzLnVud3JhcE9ic2VydmFibGUodmFsdWVBY2Nlc3NvcigpKSxcbiAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50TmFtZSwgY29tcG9uZW50UGFyYW1zO1xuXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50TmFtZSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudE5hbWUgPSBrby51dGlscy51bndyYXBPYnNlcnZhYmxlKHZhbHVlWyduYW1lJ10pO1xuICAgICAgICAgICAgICAgICAgICBjb21wb25lbnRQYXJhbXMgPSBrby51dGlscy51bndyYXBPYnNlcnZhYmxlKHZhbHVlWydwYXJhbXMnXSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKCFjb21wb25lbnROYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTm8gY29tcG9uZW50IG5hbWUgc3BlY2lmaWVkJyk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIGxvYWRpbmdPcGVyYXRpb25JZCA9IGN1cnJlbnRMb2FkaW5nT3BlcmF0aW9uSWQgPSArK2NvbXBvbmVudExvYWRpbmdPcGVyYXRpb25VbmlxdWVJZDtcbiAgICAgICAgICAgICAgICBrby5jb21wb25lbnRzLmdldChjb21wb25lbnROYW1lLCBmdW5jdGlvbihjb21wb25lbnREZWZpbml0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHRoaXMgaXMgbm90IHRoZSBjdXJyZW50IGxvYWQgb3BlcmF0aW9uIGZvciB0aGlzIGVsZW1lbnQsIGlnbm9yZSBpdC5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRMb2FkaW5nT3BlcmF0aW9uSWQgIT09IGxvYWRpbmdPcGVyYXRpb25JZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gQ2xlYW4gdXAgcHJldmlvdXMgc3RhdGVcbiAgICAgICAgICAgICAgICAgICAgZGlzcG9zZUFzc29jaWF0ZWRDb21wb25lbnRWaWV3TW9kZWwoKTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBJbnN0YW50aWF0ZSBhbmQgYmluZCBuZXcgY29tcG9uZW50LiBJbXBsaWNpdGx5IHRoaXMgY2xlYW5zIGFueSBvbGQgRE9NIG5vZGVzLlxuICAgICAgICAgICAgICAgICAgICBpZiAoIWNvbXBvbmVudERlZmluaXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBjb21wb25lbnQgXFwnJyArIGNvbXBvbmVudE5hbWUgKyAnXFwnJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2xvbmVUZW1wbGF0ZUludG9FbGVtZW50KGNvbXBvbmVudE5hbWUsIGNvbXBvbmVudERlZmluaXRpb24sIGVsZW1lbnQpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgY29tcG9uZW50Vmlld01vZGVsID0gY3JlYXRlVmlld01vZGVsKGNvbXBvbmVudERlZmluaXRpb24sIGVsZW1lbnQsIG9yaWdpbmFsQ2hpbGROb2RlcywgY29tcG9uZW50UGFyYW1zKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkQmluZGluZ0NvbnRleHQgPSBiaW5kaW5nQ29udGV4dFsnY3JlYXRlQ2hpbGRDb250ZXh0J10oY29tcG9uZW50Vmlld01vZGVsLCAvKiBkYXRhSXRlbUFsaWFzICovIHVuZGVmaW5lZCwgZnVuY3Rpb24oY3R4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3R4WyckY29tcG9uZW50J10gPSBjb21wb25lbnRWaWV3TW9kZWw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3R4WyckY29tcG9uZW50VGVtcGxhdGVOb2RlcyddID0gb3JpZ2luYWxDaGlsZE5vZGVzO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRWaWV3TW9kZWwgPSBjb21wb25lbnRWaWV3TW9kZWw7XG4gICAgICAgICAgICAgICAgICAgIGtvLmFwcGx5QmluZGluZ3NUb0Rlc2NlbmRhbnRzKGNoaWxkQmluZGluZ0NvbnRleHQsIGVsZW1lbnQpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSwgbnVsbCwgeyBkaXNwb3NlV2hlbk5vZGVJc1JlbW92ZWQ6IGVsZW1lbnQgfSk7XG5cbiAgICAgICAgICAgIHJldHVybiB7ICdjb250cm9sc0Rlc2NlbmRhbnRCaW5kaW5ncyc6IHRydWUgfTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBrby52aXJ0dWFsRWxlbWVudHMuYWxsb3dlZEJpbmRpbmdzWydjb21wb25lbnQnXSA9IHRydWU7XG5cbiAgICBmdW5jdGlvbiBjbG9uZVRlbXBsYXRlSW50b0VsZW1lbnQoY29tcG9uZW50TmFtZSwgY29tcG9uZW50RGVmaW5pdGlvbiwgZWxlbWVudCkge1xuICAgICAgICB2YXIgdGVtcGxhdGUgPSBjb21wb25lbnREZWZpbml0aW9uWyd0ZW1wbGF0ZSddO1xuICAgICAgICBpZiAoIXRlbXBsYXRlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvbXBvbmVudCBcXCcnICsgY29tcG9uZW50TmFtZSArICdcXCcgaGFzIG5vIHRlbXBsYXRlJyk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgY2xvbmVkTm9kZXNBcnJheSA9IGtvLnV0aWxzLmNsb25lTm9kZXModGVtcGxhdGUpO1xuICAgICAgICBrby52aXJ0dWFsRWxlbWVudHMuc2V0RG9tTm9kZUNoaWxkcmVuKGVsZW1lbnQsIGNsb25lZE5vZGVzQXJyYXkpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNyZWF0ZVZpZXdNb2RlbChjb21wb25lbnREZWZpbml0aW9uLCBlbGVtZW50LCBvcmlnaW5hbENoaWxkTm9kZXMsIGNvbXBvbmVudFBhcmFtcykge1xuICAgICAgICB2YXIgY29tcG9uZW50Vmlld01vZGVsRmFjdG9yeSA9IGNvbXBvbmVudERlZmluaXRpb25bJ2NyZWF0ZVZpZXdNb2RlbCddO1xuICAgICAgICByZXR1cm4gY29tcG9uZW50Vmlld01vZGVsRmFjdG9yeVxuICAgICAgICAgICAgPyBjb21wb25lbnRWaWV3TW9kZWxGYWN0b3J5LmNhbGwoY29tcG9uZW50RGVmaW5pdGlvbiwgY29tcG9uZW50UGFyYW1zLCB7ICdlbGVtZW50JzogZWxlbWVudCwgJ3RlbXBsYXRlTm9kZXMnOiBvcmlnaW5hbENoaWxkTm9kZXMgfSlcbiAgICAgICAgICAgIDogY29tcG9uZW50UGFyYW1zOyAvLyBUZW1wbGF0ZS1vbmx5IGNvbXBvbmVudFxuICAgIH1cblxufSkoKTtcbnZhciBhdHRySHRtbFRvSmF2YXNjcmlwdE1hcCA9IHsgJ2NsYXNzJzogJ2NsYXNzTmFtZScsICdmb3InOiAnaHRtbEZvcicgfTtcbmtvLmJpbmRpbmdIYW5kbGVyc1snYXR0ciddID0ge1xuICAgICd1cGRhdGUnOiBmdW5jdGlvbihlbGVtZW50LCB2YWx1ZUFjY2Vzc29yLCBhbGxCaW5kaW5ncykge1xuICAgICAgICB2YXIgdmFsdWUgPSBrby51dGlscy51bndyYXBPYnNlcnZhYmxlKHZhbHVlQWNjZXNzb3IoKSkgfHwge307XG4gICAgICAgIGtvLnV0aWxzLm9iamVjdEZvckVhY2godmFsdWUsIGZ1bmN0aW9uKGF0dHJOYW1lLCBhdHRyVmFsdWUpIHtcbiAgICAgICAgICAgIGF0dHJWYWx1ZSA9IGtvLnV0aWxzLnVud3JhcE9ic2VydmFibGUoYXR0clZhbHVlKTtcblxuICAgICAgICAgICAgLy8gVG8gY292ZXIgY2FzZXMgbGlrZSBcImF0dHI6IHsgY2hlY2tlZDpzb21lUHJvcCB9XCIsIHdlIHdhbnQgdG8gcmVtb3ZlIHRoZSBhdHRyaWJ1dGUgZW50aXJlbHlcbiAgICAgICAgICAgIC8vIHdoZW4gc29tZVByb3AgaXMgYSBcIm5vIHZhbHVlXCItbGlrZSB2YWx1ZSAoc3RyaWN0bHkgbnVsbCwgZmFsc2UsIG9yIHVuZGVmaW5lZClcbiAgICAgICAgICAgIC8vIChiZWNhdXNlIHRoZSBhYnNlbmNlIG9mIHRoZSBcImNoZWNrZWRcIiBhdHRyIGlzIGhvdyB0byBtYXJrIGFuIGVsZW1lbnQgYXMgbm90IGNoZWNrZWQsIGV0Yy4pXG4gICAgICAgICAgICB2YXIgdG9SZW1vdmUgPSAoYXR0clZhbHVlID09PSBmYWxzZSkgfHwgKGF0dHJWYWx1ZSA9PT0gbnVsbCkgfHwgKGF0dHJWYWx1ZSA9PT0gdW5kZWZpbmVkKTtcbiAgICAgICAgICAgIGlmICh0b1JlbW92ZSlcbiAgICAgICAgICAgICAgICBlbGVtZW50LnJlbW92ZUF0dHJpYnV0ZShhdHRyTmFtZSk7XG5cbiAgICAgICAgICAgIC8vIEluIElFIDw9IDcgYW5kIElFOCBRdWlya3MgTW9kZSwgeW91IGhhdmUgdG8gdXNlIHRoZSBKYXZhc2NyaXB0IHByb3BlcnR5IG5hbWUgaW5zdGVhZCBvZiB0aGVcbiAgICAgICAgICAgIC8vIEhUTUwgYXR0cmlidXRlIG5hbWUgZm9yIGNlcnRhaW4gYXR0cmlidXRlcy4gSUU4IFN0YW5kYXJkcyBNb2RlIHN1cHBvcnRzIHRoZSBjb3JyZWN0IGJlaGF2aW9yLFxuICAgICAgICAgICAgLy8gYnV0IGluc3RlYWQgb2YgZmlndXJpbmcgb3V0IHRoZSBtb2RlLCB3ZSdsbCBqdXN0IHNldCB0aGUgYXR0cmlidXRlIHRocm91Z2ggdGhlIEphdmFzY3JpcHRcbiAgICAgICAgICAgIC8vIHByb3BlcnR5IGZvciBJRSA8PSA4LlxuICAgICAgICAgICAgaWYgKGtvLnV0aWxzLmllVmVyc2lvbiA8PSA4ICYmIGF0dHJOYW1lIGluIGF0dHJIdG1sVG9KYXZhc2NyaXB0TWFwKSB7XG4gICAgICAgICAgICAgICAgYXR0ck5hbWUgPSBhdHRySHRtbFRvSmF2YXNjcmlwdE1hcFthdHRyTmFtZV07XG4gICAgICAgICAgICAgICAgaWYgKHRvUmVtb3ZlKVxuICAgICAgICAgICAgICAgICAgICBlbGVtZW50LnJlbW92ZUF0dHJpYnV0ZShhdHRyTmFtZSk7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICBlbGVtZW50W2F0dHJOYW1lXSA9IGF0dHJWYWx1ZTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIXRvUmVtb3ZlKSB7XG4gICAgICAgICAgICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoYXR0ck5hbWUsIGF0dHJWYWx1ZS50b1N0cmluZygpKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gVHJlYXQgXCJuYW1lXCIgc3BlY2lhbGx5IC0gYWx0aG91Z2ggeW91IGNhbiB0aGluayBvZiBpdCBhcyBhbiBhdHRyaWJ1dGUsIGl0IGFsc28gbmVlZHNcbiAgICAgICAgICAgIC8vIHNwZWNpYWwgaGFuZGxpbmcgb24gb2xkZXIgdmVyc2lvbnMgb2YgSUUgKGh0dHBzOi8vZ2l0aHViLmNvbS9TdGV2ZVNhbmRlcnNvbi9rbm9ja291dC9wdWxsLzMzMylcbiAgICAgICAgICAgIC8vIERlbGliZXJhdGVseSBiZWluZyBjYXNlLXNlbnNpdGl2ZSBoZXJlIGJlY2F1c2UgWEhUTUwgd291bGQgcmVnYXJkIFwiTmFtZVwiIGFzIGEgZGlmZmVyZW50IHRoaW5nXG4gICAgICAgICAgICAvLyBlbnRpcmVseSwgYW5kIHRoZXJlJ3Mgbm8gc3Ryb25nIHJlYXNvbiB0byBhbGxvdyBmb3Igc3VjaCBjYXNpbmcgaW4gSFRNTC5cbiAgICAgICAgICAgIGlmIChhdHRyTmFtZSA9PT0gXCJuYW1lXCIpIHtcbiAgICAgICAgICAgICAgICBrby51dGlscy5zZXRFbGVtZW50TmFtZShlbGVtZW50LCB0b1JlbW92ZSA/IFwiXCIgOiBhdHRyVmFsdWUudG9TdHJpbmcoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbn07XG4oZnVuY3Rpb24oKSB7XG5cbmtvLmJpbmRpbmdIYW5kbGVyc1snY2hlY2tlZCddID0ge1xuICAgICdhZnRlcic6IFsndmFsdWUnLCAnYXR0ciddLFxuICAgICdpbml0JzogZnVuY3Rpb24gKGVsZW1lbnQsIHZhbHVlQWNjZXNzb3IsIGFsbEJpbmRpbmdzKSB7XG4gICAgICAgIHZhciBjaGVja2VkVmFsdWUgPSBrby5wdXJlQ29tcHV0ZWQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAvLyBUcmVhdCBcInZhbHVlXCIgbGlrZSBcImNoZWNrZWRWYWx1ZVwiIHdoZW4gaXQgaXMgaW5jbHVkZWQgd2l0aCBcImNoZWNrZWRcIiBiaW5kaW5nXG4gICAgICAgICAgICBpZiAoYWxsQmluZGluZ3NbJ2hhcyddKCdjaGVja2VkVmFsdWUnKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBrby51dGlscy51bndyYXBPYnNlcnZhYmxlKGFsbEJpbmRpbmdzLmdldCgnY2hlY2tlZFZhbHVlJykpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChhbGxCaW5kaW5nc1snaGFzJ10oJ3ZhbHVlJykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ga28udXRpbHMudW53cmFwT2JzZXJ2YWJsZShhbGxCaW5kaW5ncy5nZXQoJ3ZhbHVlJykpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gZWxlbWVudC52YWx1ZTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgZnVuY3Rpb24gdXBkYXRlTW9kZWwoKSB7XG4gICAgICAgICAgICAvLyBUaGlzIHVwZGF0ZXMgdGhlIG1vZGVsIHZhbHVlIGZyb20gdGhlIHZpZXcgdmFsdWUuXG4gICAgICAgICAgICAvLyBJdCBydW5zIGluIHJlc3BvbnNlIHRvIERPTSBldmVudHMgKGNsaWNrKSBhbmQgY2hhbmdlcyBpbiBjaGVja2VkVmFsdWUuXG4gICAgICAgICAgICB2YXIgaXNDaGVja2VkID0gZWxlbWVudC5jaGVja2VkLFxuICAgICAgICAgICAgICAgIGVsZW1WYWx1ZSA9IHVzZUNoZWNrZWRWYWx1ZSA/IGNoZWNrZWRWYWx1ZSgpIDogaXNDaGVja2VkO1xuXG4gICAgICAgICAgICAvLyBXaGVuIHdlJ3JlIGZpcnN0IHNldHRpbmcgdXAgdGhpcyBjb21wdXRlZCwgZG9uJ3QgY2hhbmdlIGFueSBtb2RlbCBzdGF0ZS5cbiAgICAgICAgICAgIGlmIChrby5jb21wdXRlZENvbnRleHQuaXNJbml0aWFsKCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFdlIGNhbiBpZ25vcmUgdW5jaGVja2VkIHJhZGlvIGJ1dHRvbnMsIGJlY2F1c2Ugc29tZSBvdGhlciByYWRpb1xuICAgICAgICAgICAgLy8gYnV0dG9uIHdpbGwgYmUgZ2V0dGluZyBjaGVja2VkLCBhbmQgdGhhdCBvbmUgY2FuIHRha2UgY2FyZSBvZiB1cGRhdGluZyBzdGF0ZS5cbiAgICAgICAgICAgIGlmIChpc1JhZGlvICYmICFpc0NoZWNrZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBtb2RlbFZhbHVlID0ga28uZGVwZW5kZW5jeURldGVjdGlvbi5pZ25vcmUodmFsdWVBY2Nlc3Nvcik7XG4gICAgICAgICAgICBpZiAodmFsdWVJc0FycmF5KSB7XG4gICAgICAgICAgICAgICAgdmFyIHdyaXRhYmxlVmFsdWUgPSByYXdWYWx1ZUlzTm9uQXJyYXlPYnNlcnZhYmxlID8gbW9kZWxWYWx1ZS5wZWVrKCkgOiBtb2RlbFZhbHVlO1xuICAgICAgICAgICAgICAgIGlmIChvbGRFbGVtVmFsdWUgIT09IGVsZW1WYWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBXaGVuIHdlJ3JlIHJlc3BvbmRpbmcgdG8gdGhlIGNoZWNrZWRWYWx1ZSBjaGFuZ2luZywgYW5kIHRoZSBlbGVtZW50IGlzXG4gICAgICAgICAgICAgICAgICAgIC8vIGN1cnJlbnRseSBjaGVja2VkLCByZXBsYWNlIHRoZSBvbGQgZWxlbSB2YWx1ZSB3aXRoIHRoZSBuZXcgZWxlbSB2YWx1ZVxuICAgICAgICAgICAgICAgICAgICAvLyBpbiB0aGUgbW9kZWwgYXJyYXkuXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0NoZWNrZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGtvLnV0aWxzLmFkZE9yUmVtb3ZlSXRlbSh3cml0YWJsZVZhbHVlLCBlbGVtVmFsdWUsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAga28udXRpbHMuYWRkT3JSZW1vdmVJdGVtKHdyaXRhYmxlVmFsdWUsIG9sZEVsZW1WYWx1ZSwgZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgb2xkRWxlbVZhbHVlID0gZWxlbVZhbHVlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFdoZW4gd2UncmUgcmVzcG9uZGluZyB0byB0aGUgdXNlciBoYXZpbmcgY2hlY2tlZC91bmNoZWNrZWQgYSBjaGVja2JveCxcbiAgICAgICAgICAgICAgICAgICAgLy8gYWRkL3JlbW92ZSB0aGUgZWxlbWVudCB2YWx1ZSB0byB0aGUgbW9kZWwgYXJyYXkuXG4gICAgICAgICAgICAgICAgICAgIGtvLnV0aWxzLmFkZE9yUmVtb3ZlSXRlbSh3cml0YWJsZVZhbHVlLCBlbGVtVmFsdWUsIGlzQ2hlY2tlZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChyYXdWYWx1ZUlzTm9uQXJyYXlPYnNlcnZhYmxlICYmIGtvLmlzV3JpdGVhYmxlT2JzZXJ2YWJsZShtb2RlbFZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICBtb2RlbFZhbHVlKHdyaXRhYmxlVmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAga28uZXhwcmVzc2lvblJld3JpdGluZy53cml0ZVZhbHVlVG9Qcm9wZXJ0eShtb2RlbFZhbHVlLCBhbGxCaW5kaW5ncywgJ2NoZWNrZWQnLCBlbGVtVmFsdWUsIHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIGZ1bmN0aW9uIHVwZGF0ZVZpZXcoKSB7XG4gICAgICAgICAgICAvLyBUaGlzIHVwZGF0ZXMgdGhlIHZpZXcgdmFsdWUgZnJvbSB0aGUgbW9kZWwgdmFsdWUuXG4gICAgICAgICAgICAvLyBJdCBydW5zIGluIHJlc3BvbnNlIHRvIGNoYW5nZXMgaW4gdGhlIGJvdW5kIChjaGVja2VkKSB2YWx1ZS5cbiAgICAgICAgICAgIHZhciBtb2RlbFZhbHVlID0ga28udXRpbHMudW53cmFwT2JzZXJ2YWJsZSh2YWx1ZUFjY2Vzc29yKCkpO1xuXG4gICAgICAgICAgICBpZiAodmFsdWVJc0FycmF5KSB7XG4gICAgICAgICAgICAgICAgLy8gV2hlbiBhIGNoZWNrYm94IGlzIGJvdW5kIHRvIGFuIGFycmF5LCBiZWluZyBjaGVja2VkIHJlcHJlc2VudHMgaXRzIHZhbHVlIGJlaW5nIHByZXNlbnQgaW4gdGhhdCBhcnJheVxuICAgICAgICAgICAgICAgIGVsZW1lbnQuY2hlY2tlZCA9IGtvLnV0aWxzLmFycmF5SW5kZXhPZihtb2RlbFZhbHVlLCBjaGVja2VkVmFsdWUoKSkgPj0gMDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaXNDaGVja2JveCkge1xuICAgICAgICAgICAgICAgIC8vIFdoZW4gYSBjaGVja2JveCBpcyBib3VuZCB0byBhbnkgb3RoZXIgdmFsdWUgKG5vdCBhbiBhcnJheSksIGJlaW5nIGNoZWNrZWQgcmVwcmVzZW50cyB0aGUgdmFsdWUgYmVpbmcgdHJ1ZWlzaFxuICAgICAgICAgICAgICAgIGVsZW1lbnQuY2hlY2tlZCA9IG1vZGVsVmFsdWU7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIEZvciByYWRpbyBidXR0b25zLCBiZWluZyBjaGVja2VkIG1lYW5zIHRoYXQgdGhlIHJhZGlvIGJ1dHRvbidzIHZhbHVlIGNvcnJlc3BvbmRzIHRvIHRoZSBtb2RlbCB2YWx1ZVxuICAgICAgICAgICAgICAgIGVsZW1lbnQuY2hlY2tlZCA9IChjaGVja2VkVmFsdWUoKSA9PT0gbW9kZWxWYWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIGlzQ2hlY2tib3ggPSBlbGVtZW50LnR5cGUgPT0gXCJjaGVja2JveFwiLFxuICAgICAgICAgICAgaXNSYWRpbyA9IGVsZW1lbnQudHlwZSA9PSBcInJhZGlvXCI7XG5cbiAgICAgICAgLy8gT25seSBiaW5kIHRvIGNoZWNrIGJveGVzIGFuZCByYWRpbyBidXR0b25zXG4gICAgICAgIGlmICghaXNDaGVja2JveCAmJiAhaXNSYWRpbykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHJhd1ZhbHVlID0gdmFsdWVBY2Nlc3NvcigpLFxuICAgICAgICAgICAgdmFsdWVJc0FycmF5ID0gaXNDaGVja2JveCAmJiAoa28udXRpbHMudW53cmFwT2JzZXJ2YWJsZShyYXdWYWx1ZSkgaW5zdGFuY2VvZiBBcnJheSksXG4gICAgICAgICAgICByYXdWYWx1ZUlzTm9uQXJyYXlPYnNlcnZhYmxlID0gISh2YWx1ZUlzQXJyYXkgJiYgcmF3VmFsdWUucHVzaCAmJiByYXdWYWx1ZS5zcGxpY2UpLFxuICAgICAgICAgICAgb2xkRWxlbVZhbHVlID0gdmFsdWVJc0FycmF5ID8gY2hlY2tlZFZhbHVlKCkgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICB1c2VDaGVja2VkVmFsdWUgPSBpc1JhZGlvIHx8IHZhbHVlSXNBcnJheTtcblxuICAgICAgICAvLyBJRSA2IHdvbid0IGFsbG93IHJhZGlvIGJ1dHRvbnMgdG8gYmUgc2VsZWN0ZWQgdW5sZXNzIHRoZXkgaGF2ZSBhIG5hbWVcbiAgICAgICAgaWYgKGlzUmFkaW8gJiYgIWVsZW1lbnQubmFtZSlcbiAgICAgICAgICAgIGtvLmJpbmRpbmdIYW5kbGVyc1sndW5pcXVlTmFtZSddWydpbml0J10oZWxlbWVudCwgZnVuY3Rpb24oKSB7IHJldHVybiB0cnVlIH0pO1xuXG4gICAgICAgIC8vIFNldCB1cCB0d28gY29tcHV0ZWRzIHRvIHVwZGF0ZSB0aGUgYmluZGluZzpcblxuICAgICAgICAvLyBUaGUgZmlyc3QgcmVzcG9uZHMgdG8gY2hhbmdlcyBpbiB0aGUgY2hlY2tlZFZhbHVlIHZhbHVlIGFuZCB0byBlbGVtZW50IGNsaWNrc1xuICAgICAgICBrby5jb21wdXRlZCh1cGRhdGVNb2RlbCwgbnVsbCwgeyBkaXNwb3NlV2hlbk5vZGVJc1JlbW92ZWQ6IGVsZW1lbnQgfSk7XG4gICAgICAgIGtvLnV0aWxzLnJlZ2lzdGVyRXZlbnRIYW5kbGVyKGVsZW1lbnQsIFwiY2xpY2tcIiwgdXBkYXRlTW9kZWwpO1xuXG4gICAgICAgIC8vIFRoZSBzZWNvbmQgcmVzcG9uZHMgdG8gY2hhbmdlcyBpbiB0aGUgbW9kZWwgdmFsdWUgKHRoZSBvbmUgYXNzb2NpYXRlZCB3aXRoIHRoZSBjaGVja2VkIGJpbmRpbmcpXG4gICAgICAgIGtvLmNvbXB1dGVkKHVwZGF0ZVZpZXcsIG51bGwsIHsgZGlzcG9zZVdoZW5Ob2RlSXNSZW1vdmVkOiBlbGVtZW50IH0pO1xuXG4gICAgICAgIHJhd1ZhbHVlID0gdW5kZWZpbmVkO1xuICAgIH1cbn07XG5rby5leHByZXNzaW9uUmV3cml0aW5nLnR3b1dheUJpbmRpbmdzWydjaGVja2VkJ10gPSB0cnVlO1xuXG5rby5iaW5kaW5nSGFuZGxlcnNbJ2NoZWNrZWRWYWx1ZSddID0ge1xuICAgICd1cGRhdGUnOiBmdW5jdGlvbiAoZWxlbWVudCwgdmFsdWVBY2Nlc3Nvcikge1xuICAgICAgICBlbGVtZW50LnZhbHVlID0ga28udXRpbHMudW53cmFwT2JzZXJ2YWJsZSh2YWx1ZUFjY2Vzc29yKCkpO1xuICAgIH1cbn07XG5cbn0pKCk7dmFyIGNsYXNzZXNXcml0dGVuQnlCaW5kaW5nS2V5ID0gJ19fa29fX2Nzc1ZhbHVlJztcbmtvLmJpbmRpbmdIYW5kbGVyc1snY3NzJ10gPSB7XG4gICAgJ3VwZGF0ZSc6IGZ1bmN0aW9uIChlbGVtZW50LCB2YWx1ZUFjY2Vzc29yKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IGtvLnV0aWxzLnVud3JhcE9ic2VydmFibGUodmFsdWVBY2Nlc3NvcigpKTtcbiAgICAgICAgaWYgKHZhbHVlICE9PSBudWxsICYmIHR5cGVvZiB2YWx1ZSA9PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICBrby51dGlscy5vYmplY3RGb3JFYWNoKHZhbHVlLCBmdW5jdGlvbihjbGFzc05hbWUsIHNob3VsZEhhdmVDbGFzcykge1xuICAgICAgICAgICAgICAgIHNob3VsZEhhdmVDbGFzcyA9IGtvLnV0aWxzLnVud3JhcE9ic2VydmFibGUoc2hvdWxkSGF2ZUNsYXNzKTtcbiAgICAgICAgICAgICAgICBrby51dGlscy50b2dnbGVEb21Ob2RlQ3NzQ2xhc3MoZWxlbWVudCwgY2xhc3NOYW1lLCBzaG91bGRIYXZlQ2xhc3MpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YWx1ZSA9IGtvLnV0aWxzLnN0cmluZ1RyaW0oU3RyaW5nKHZhbHVlIHx8ICcnKSk7IC8vIE1ha2Ugc3VyZSB3ZSBkb24ndCB0cnkgdG8gc3RvcmUgb3Igc2V0IGEgbm9uLXN0cmluZyB2YWx1ZVxuICAgICAgICAgICAga28udXRpbHMudG9nZ2xlRG9tTm9kZUNzc0NsYXNzKGVsZW1lbnQsIGVsZW1lbnRbY2xhc3Nlc1dyaXR0ZW5CeUJpbmRpbmdLZXldLCBmYWxzZSk7XG4gICAgICAgICAgICBlbGVtZW50W2NsYXNzZXNXcml0dGVuQnlCaW5kaW5nS2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAga28udXRpbHMudG9nZ2xlRG9tTm9kZUNzc0NsYXNzKGVsZW1lbnQsIHZhbHVlLCB0cnVlKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5rby5iaW5kaW5nSGFuZGxlcnNbJ2VuYWJsZSddID0ge1xuICAgICd1cGRhdGUnOiBmdW5jdGlvbiAoZWxlbWVudCwgdmFsdWVBY2Nlc3Nvcikge1xuICAgICAgICB2YXIgdmFsdWUgPSBrby51dGlscy51bndyYXBPYnNlcnZhYmxlKHZhbHVlQWNjZXNzb3IoKSk7XG4gICAgICAgIGlmICh2YWx1ZSAmJiBlbGVtZW50LmRpc2FibGVkKVxuICAgICAgICAgICAgZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoXCJkaXNhYmxlZFwiKTtcbiAgICAgICAgZWxzZSBpZiAoKCF2YWx1ZSkgJiYgKCFlbGVtZW50LmRpc2FibGVkKSlcbiAgICAgICAgICAgIGVsZW1lbnQuZGlzYWJsZWQgPSB0cnVlO1xuICAgIH1cbn07XG5cbmtvLmJpbmRpbmdIYW5kbGVyc1snZGlzYWJsZSddID0ge1xuICAgICd1cGRhdGUnOiBmdW5jdGlvbiAoZWxlbWVudCwgdmFsdWVBY2Nlc3Nvcikge1xuICAgICAgICBrby5iaW5kaW5nSGFuZGxlcnNbJ2VuYWJsZSddWyd1cGRhdGUnXShlbGVtZW50LCBmdW5jdGlvbigpIHsgcmV0dXJuICFrby51dGlscy51bndyYXBPYnNlcnZhYmxlKHZhbHVlQWNjZXNzb3IoKSkgfSk7XG4gICAgfVxufTtcbi8vIEZvciBjZXJ0YWluIGNvbW1vbiBldmVudHMgKGN1cnJlbnRseSBqdXN0ICdjbGljaycpLCBhbGxvdyBhIHNpbXBsaWZpZWQgZGF0YS1iaW5kaW5nIHN5bnRheFxuLy8gZS5nLiBjbGljazpoYW5kbGVyIGluc3RlYWQgb2YgdGhlIHVzdWFsIGZ1bGwtbGVuZ3RoIGV2ZW50OntjbGljazpoYW5kbGVyfVxuZnVuY3Rpb24gbWFrZUV2ZW50SGFuZGxlclNob3J0Y3V0KGV2ZW50TmFtZSkge1xuICAgIGtvLmJpbmRpbmdIYW5kbGVyc1tldmVudE5hbWVdID0ge1xuICAgICAgICAnaW5pdCc6IGZ1bmN0aW9uKGVsZW1lbnQsIHZhbHVlQWNjZXNzb3IsIGFsbEJpbmRpbmdzLCB2aWV3TW9kZWwsIGJpbmRpbmdDb250ZXh0KSB7XG4gICAgICAgICAgICB2YXIgbmV3VmFsdWVBY2Nlc3NvciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgICAgICAgICAgICAgcmVzdWx0W2V2ZW50TmFtZV0gPSB2YWx1ZUFjY2Vzc29yKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4ga28uYmluZGluZ0hhbmRsZXJzWydldmVudCddWydpbml0J10uY2FsbCh0aGlzLCBlbGVtZW50LCBuZXdWYWx1ZUFjY2Vzc29yLCBhbGxCaW5kaW5ncywgdmlld01vZGVsLCBiaW5kaW5nQ29udGV4dCk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmtvLmJpbmRpbmdIYW5kbGVyc1snZXZlbnQnXSA9IHtcbiAgICAnaW5pdCcgOiBmdW5jdGlvbiAoZWxlbWVudCwgdmFsdWVBY2Nlc3NvciwgYWxsQmluZGluZ3MsIHZpZXdNb2RlbCwgYmluZGluZ0NvbnRleHQpIHtcbiAgICAgICAgdmFyIGV2ZW50c1RvSGFuZGxlID0gdmFsdWVBY2Nlc3NvcigpIHx8IHt9O1xuICAgICAgICBrby51dGlscy5vYmplY3RGb3JFYWNoKGV2ZW50c1RvSGFuZGxlLCBmdW5jdGlvbihldmVudE5hbWUpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZXZlbnROYW1lID09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICBrby51dGlscy5yZWdpc3RlckV2ZW50SGFuZGxlcihlbGVtZW50LCBldmVudE5hbWUsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgaGFuZGxlclJldHVyblZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB2YXIgaGFuZGxlckZ1bmN0aW9uID0gdmFsdWVBY2Nlc3NvcigpW2V2ZW50TmFtZV07XG4gICAgICAgICAgICAgICAgICAgIGlmICghaGFuZGxlckZ1bmN0aW9uKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuXG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUYWtlIGFsbCB0aGUgZXZlbnQgYXJncywgYW5kIHByZWZpeCB3aXRoIHRoZSB2aWV3bW9kZWxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhcmdzRm9ySGFuZGxlciA9IGtvLnV0aWxzLm1ha2VBcnJheShhcmd1bWVudHMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmlld01vZGVsID0gYmluZGluZ0NvbnRleHRbJyRkYXRhJ107XG4gICAgICAgICAgICAgICAgICAgICAgICBhcmdzRm9ySGFuZGxlci51bnNoaWZ0KHZpZXdNb2RlbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBoYW5kbGVyUmV0dXJuVmFsdWUgPSBoYW5kbGVyRnVuY3Rpb24uYXBwbHkodmlld01vZGVsLCBhcmdzRm9ySGFuZGxlcik7XG4gICAgICAgICAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaGFuZGxlclJldHVyblZhbHVlICE9PSB0cnVlKSB7IC8vIE5vcm1hbGx5IHdlIHdhbnQgdG8gcHJldmVudCBkZWZhdWx0IGFjdGlvbi4gRGV2ZWxvcGVyIGNhbiBvdmVycmlkZSB0aGlzIGJlIGV4cGxpY2l0bHkgcmV0dXJuaW5nIHRydWUuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGV2ZW50LnByZXZlbnREZWZhdWx0KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnQucmV0dXJuVmFsdWUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHZhciBidWJibGUgPSBhbGxCaW5kaW5ncy5nZXQoZXZlbnROYW1lICsgJ0J1YmJsZScpICE9PSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFidWJibGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50LmNhbmNlbEJ1YmJsZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXZlbnQuc3RvcFByb3BhZ2F0aW9uKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbn07XG4vLyBcImZvcmVhY2g6IHNvbWVFeHByZXNzaW9uXCIgaXMgZXF1aXZhbGVudCB0byBcInRlbXBsYXRlOiB7IGZvcmVhY2g6IHNvbWVFeHByZXNzaW9uIH1cIlxuLy8gXCJmb3JlYWNoOiB7IGRhdGE6IHNvbWVFeHByZXNzaW9uLCBhZnRlckFkZDogbXlmbiB9XCIgaXMgZXF1aXZhbGVudCB0byBcInRlbXBsYXRlOiB7IGZvcmVhY2g6IHNvbWVFeHByZXNzaW9uLCBhZnRlckFkZDogbXlmbiB9XCJcbmtvLmJpbmRpbmdIYW5kbGVyc1snZm9yZWFjaCddID0ge1xuICAgIG1ha2VUZW1wbGF0ZVZhbHVlQWNjZXNzb3I6IGZ1bmN0aW9uKHZhbHVlQWNjZXNzb3IpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIG1vZGVsVmFsdWUgPSB2YWx1ZUFjY2Vzc29yKCksXG4gICAgICAgICAgICAgICAgdW53cmFwcGVkVmFsdWUgPSBrby51dGlscy5wZWVrT2JzZXJ2YWJsZShtb2RlbFZhbHVlKTsgICAgLy8gVW53cmFwIHdpdGhvdXQgc2V0dGluZyBhIGRlcGVuZGVuY3kgaGVyZVxuXG4gICAgICAgICAgICAvLyBJZiB1bndyYXBwZWRWYWx1ZSBpcyB0aGUgYXJyYXksIHBhc3MgaW4gdGhlIHdyYXBwZWQgdmFsdWUgb24gaXRzIG93blxuICAgICAgICAgICAgLy8gVGhlIHZhbHVlIHdpbGwgYmUgdW53cmFwcGVkIGFuZCB0cmFja2VkIHdpdGhpbiB0aGUgdGVtcGxhdGUgYmluZGluZ1xuICAgICAgICAgICAgLy8gKFNlZSBodHRwczovL2dpdGh1Yi5jb20vU3RldmVTYW5kZXJzb24va25vY2tvdXQvaXNzdWVzLzUyMylcbiAgICAgICAgICAgIGlmICgoIXVud3JhcHBlZFZhbHVlKSB8fCB0eXBlb2YgdW53cmFwcGVkVmFsdWUubGVuZ3RoID09IFwibnVtYmVyXCIpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgJ2ZvcmVhY2gnOiBtb2RlbFZhbHVlLCAndGVtcGxhdGVFbmdpbmUnOiBrby5uYXRpdmVUZW1wbGF0ZUVuZ2luZS5pbnN0YW5jZSB9O1xuXG4gICAgICAgICAgICAvLyBJZiB1bndyYXBwZWRWYWx1ZS5kYXRhIGlzIHRoZSBhcnJheSwgcHJlc2VydmUgYWxsIHJlbGV2YW50IG9wdGlvbnMgYW5kIHVud3JhcCBhZ2FpbiB2YWx1ZSBzbyB3ZSBnZXQgdXBkYXRlc1xuICAgICAgICAgICAga28udXRpbHMudW53cmFwT2JzZXJ2YWJsZShtb2RlbFZhbHVlKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgJ2ZvcmVhY2gnOiB1bndyYXBwZWRWYWx1ZVsnZGF0YSddLFxuICAgICAgICAgICAgICAgICdhcyc6IHVud3JhcHBlZFZhbHVlWydhcyddLFxuICAgICAgICAgICAgICAgICdpbmNsdWRlRGVzdHJveWVkJzogdW53cmFwcGVkVmFsdWVbJ2luY2x1ZGVEZXN0cm95ZWQnXSxcbiAgICAgICAgICAgICAgICAnYWZ0ZXJBZGQnOiB1bndyYXBwZWRWYWx1ZVsnYWZ0ZXJBZGQnXSxcbiAgICAgICAgICAgICAgICAnYmVmb3JlUmVtb3ZlJzogdW53cmFwcGVkVmFsdWVbJ2JlZm9yZVJlbW92ZSddLFxuICAgICAgICAgICAgICAgICdhZnRlclJlbmRlcic6IHVud3JhcHBlZFZhbHVlWydhZnRlclJlbmRlciddLFxuICAgICAgICAgICAgICAgICdiZWZvcmVNb3ZlJzogdW53cmFwcGVkVmFsdWVbJ2JlZm9yZU1vdmUnXSxcbiAgICAgICAgICAgICAgICAnYWZ0ZXJNb3ZlJzogdW53cmFwcGVkVmFsdWVbJ2FmdGVyTW92ZSddLFxuICAgICAgICAgICAgICAgICd0ZW1wbGF0ZUVuZ2luZSc6IGtvLm5hdGl2ZVRlbXBsYXRlRW5naW5lLmluc3RhbmNlXG4gICAgICAgICAgICB9O1xuICAgICAgICB9O1xuICAgIH0sXG4gICAgJ2luaXQnOiBmdW5jdGlvbihlbGVtZW50LCB2YWx1ZUFjY2Vzc29yLCBhbGxCaW5kaW5ncywgdmlld01vZGVsLCBiaW5kaW5nQ29udGV4dCkge1xuICAgICAgICByZXR1cm4ga28uYmluZGluZ0hhbmRsZXJzWyd0ZW1wbGF0ZSddWydpbml0J10oZWxlbWVudCwga28uYmluZGluZ0hhbmRsZXJzWydmb3JlYWNoJ10ubWFrZVRlbXBsYXRlVmFsdWVBY2Nlc3Nvcih2YWx1ZUFjY2Vzc29yKSk7XG4gICAgfSxcbiAgICAndXBkYXRlJzogZnVuY3Rpb24oZWxlbWVudCwgdmFsdWVBY2Nlc3NvciwgYWxsQmluZGluZ3MsIHZpZXdNb2RlbCwgYmluZGluZ0NvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIGtvLmJpbmRpbmdIYW5kbGVyc1sndGVtcGxhdGUnXVsndXBkYXRlJ10oZWxlbWVudCwga28uYmluZGluZ0hhbmRsZXJzWydmb3JlYWNoJ10ubWFrZVRlbXBsYXRlVmFsdWVBY2Nlc3Nvcih2YWx1ZUFjY2Vzc29yKSwgYWxsQmluZGluZ3MsIHZpZXdNb2RlbCwgYmluZGluZ0NvbnRleHQpO1xuICAgIH1cbn07XG5rby5leHByZXNzaW9uUmV3cml0aW5nLmJpbmRpbmdSZXdyaXRlVmFsaWRhdG9yc1snZm9yZWFjaCddID0gZmFsc2U7IC8vIENhbid0IHJld3JpdGUgY29udHJvbCBmbG93IGJpbmRpbmdzXG5rby52aXJ0dWFsRWxlbWVudHMuYWxsb3dlZEJpbmRpbmdzWydmb3JlYWNoJ10gPSB0cnVlO1xudmFyIGhhc2ZvY3VzVXBkYXRpbmdQcm9wZXJ0eSA9ICdfX2tvX2hhc2ZvY3VzVXBkYXRpbmcnO1xudmFyIGhhc2ZvY3VzTGFzdFZhbHVlID0gJ19fa29faGFzZm9jdXNMYXN0VmFsdWUnO1xua28uYmluZGluZ0hhbmRsZXJzWydoYXNmb2N1cyddID0ge1xuICAgICdpbml0JzogZnVuY3Rpb24oZWxlbWVudCwgdmFsdWVBY2Nlc3NvciwgYWxsQmluZGluZ3MpIHtcbiAgICAgICAgdmFyIGhhbmRsZUVsZW1lbnRGb2N1c0NoYW5nZSA9IGZ1bmN0aW9uKGlzRm9jdXNlZCkge1xuICAgICAgICAgICAgLy8gV2hlcmUgcG9zc2libGUsIGlnbm9yZSB3aGljaCBldmVudCB3YXMgcmFpc2VkIGFuZCBkZXRlcm1pbmUgZm9jdXMgc3RhdGUgdXNpbmcgYWN0aXZlRWxlbWVudCxcbiAgICAgICAgICAgIC8vIGFzIHRoaXMgYXZvaWRzIHBoYW50b20gZm9jdXMvYmx1ciBldmVudHMgcmFpc2VkIHdoZW4gY2hhbmdpbmcgdGFicyBpbiBtb2Rlcm4gYnJvd3NlcnMuXG4gICAgICAgICAgICAvLyBIb3dldmVyLCBub3QgYWxsIEtPLXRhcmdldGVkIGJyb3dzZXJzIChGaXJlZm94IDIpIHN1cHBvcnQgYWN0aXZlRWxlbWVudC4gRm9yIHRob3NlIGJyb3dzZXJzLFxuICAgICAgICAgICAgLy8gcHJldmVudCBhIGxvc3Mgb2YgZm9jdXMgd2hlbiBjaGFuZ2luZyB0YWJzL3dpbmRvd3MgYnkgc2V0dGluZyBhIGZsYWcgdGhhdCBwcmV2ZW50cyBoYXNmb2N1c1xuICAgICAgICAgICAgLy8gZnJvbSBjYWxsaW5nICdibHVyKCknIG9uIHRoZSBlbGVtZW50IHdoZW4gaXQgbG9zZXMgZm9jdXMuXG4gICAgICAgICAgICAvLyBEaXNjdXNzaW9uIGF0IGh0dHBzOi8vZ2l0aHViLmNvbS9TdGV2ZVNhbmRlcnNvbi9rbm9ja291dC9wdWxsLzM1MlxuICAgICAgICAgICAgZWxlbWVudFtoYXNmb2N1c1VwZGF0aW5nUHJvcGVydHldID0gdHJ1ZTtcbiAgICAgICAgICAgIHZhciBvd25lckRvYyA9IGVsZW1lbnQub3duZXJEb2N1bWVudDtcbiAgICAgICAgICAgIGlmIChcImFjdGl2ZUVsZW1lbnRcIiBpbiBvd25lckRvYykge1xuICAgICAgICAgICAgICAgIHZhciBhY3RpdmU7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgYWN0aXZlID0gb3duZXJEb2MuYWN0aXZlRWxlbWVudDtcbiAgICAgICAgICAgICAgICB9IGNhdGNoKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSUU5IHRocm93cyBpZiB5b3UgYWNjZXNzIGFjdGl2ZUVsZW1lbnQgZHVyaW5nIHBhZ2UgbG9hZCAoc2VlIGlzc3VlICM3MDMpXG4gICAgICAgICAgICAgICAgICAgIGFjdGl2ZSA9IG93bmVyRG9jLmJvZHk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlzRm9jdXNlZCA9IChhY3RpdmUgPT09IGVsZW1lbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIG1vZGVsVmFsdWUgPSB2YWx1ZUFjY2Vzc29yKCk7XG4gICAgICAgICAgICBrby5leHByZXNzaW9uUmV3cml0aW5nLndyaXRlVmFsdWVUb1Byb3BlcnR5KG1vZGVsVmFsdWUsIGFsbEJpbmRpbmdzLCAnaGFzZm9jdXMnLCBpc0ZvY3VzZWQsIHRydWUpO1xuXG4gICAgICAgICAgICAvL2NhY2hlIHRoZSBsYXRlc3QgdmFsdWUsIHNvIHdlIGNhbiBhdm9pZCB1bm5lY2Vzc2FyaWx5IGNhbGxpbmcgZm9jdXMvYmx1ciBpbiB0aGUgdXBkYXRlIGZ1bmN0aW9uXG4gICAgICAgICAgICBlbGVtZW50W2hhc2ZvY3VzTGFzdFZhbHVlXSA9IGlzRm9jdXNlZDtcbiAgICAgICAgICAgIGVsZW1lbnRbaGFzZm9jdXNVcGRhdGluZ1Byb3BlcnR5XSA9IGZhbHNlO1xuICAgICAgICB9O1xuICAgICAgICB2YXIgaGFuZGxlRWxlbWVudEZvY3VzSW4gPSBoYW5kbGVFbGVtZW50Rm9jdXNDaGFuZ2UuYmluZChudWxsLCB0cnVlKTtcbiAgICAgICAgdmFyIGhhbmRsZUVsZW1lbnRGb2N1c091dCA9IGhhbmRsZUVsZW1lbnRGb2N1c0NoYW5nZS5iaW5kKG51bGwsIGZhbHNlKTtcblxuICAgICAgICBrby51dGlscy5yZWdpc3RlckV2ZW50SGFuZGxlcihlbGVtZW50LCBcImZvY3VzXCIsIGhhbmRsZUVsZW1lbnRGb2N1c0luKTtcbiAgICAgICAga28udXRpbHMucmVnaXN0ZXJFdmVudEhhbmRsZXIoZWxlbWVudCwgXCJmb2N1c2luXCIsIGhhbmRsZUVsZW1lbnRGb2N1c0luKTsgLy8gRm9yIElFXG4gICAgICAgIGtvLnV0aWxzLnJlZ2lzdGVyRXZlbnRIYW5kbGVyKGVsZW1lbnQsIFwiYmx1clwiLCAgaGFuZGxlRWxlbWVudEZvY3VzT3V0KTtcbiAgICAgICAga28udXRpbHMucmVnaXN0ZXJFdmVudEhhbmRsZXIoZWxlbWVudCwgXCJmb2N1c291dFwiLCAgaGFuZGxlRWxlbWVudEZvY3VzT3V0KTsgLy8gRm9yIElFXG4gICAgfSxcbiAgICAndXBkYXRlJzogZnVuY3Rpb24oZWxlbWVudCwgdmFsdWVBY2Nlc3Nvcikge1xuICAgICAgICB2YXIgdmFsdWUgPSAhIWtvLnV0aWxzLnVud3JhcE9ic2VydmFibGUodmFsdWVBY2Nlc3NvcigpKTtcblxuICAgICAgICBpZiAoIWVsZW1lbnRbaGFzZm9jdXNVcGRhdGluZ1Byb3BlcnR5XSAmJiBlbGVtZW50W2hhc2ZvY3VzTGFzdFZhbHVlXSAhPT0gdmFsdWUpIHtcbiAgICAgICAgICAgIHZhbHVlID8gZWxlbWVudC5mb2N1cygpIDogZWxlbWVudC5ibHVyKCk7XG5cbiAgICAgICAgICAgIC8vIEluIElFLCB0aGUgYmx1ciBtZXRob2QgZG9lc24ndCBhbHdheXMgY2F1c2UgdGhlIGVsZW1lbnQgdG8gbG9zZSBmb2N1cyAoZm9yIGV4YW1wbGUsIGlmIHRoZSB3aW5kb3cgaXMgbm90IGluIGZvY3VzKS5cbiAgICAgICAgICAgIC8vIFNldHRpbmcgZm9jdXMgdG8gdGhlIGJvZHkgZWxlbWVudCBkb2VzIHNlZW0gdG8gYmUgcmVsaWFibGUgaW4gSUUsIGJ1dCBzaG91bGQgb25seSBiZSB1c2VkIGlmIHdlIGtub3cgdGhhdCB0aGUgY3VycmVudFxuICAgICAgICAgICAgLy8gZWxlbWVudCB3YXMgZm9jdXNlZCBhbHJlYWR5LlxuICAgICAgICAgICAgaWYgKCF2YWx1ZSAmJiBlbGVtZW50W2hhc2ZvY3VzTGFzdFZhbHVlXSkge1xuICAgICAgICAgICAgICAgIGVsZW1lbnQub3duZXJEb2N1bWVudC5ib2R5LmZvY3VzKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEZvciBJRSwgd2hpY2ggZG9lc24ndCByZWxpYWJseSBmaXJlIFwiZm9jdXNcIiBvciBcImJsdXJcIiBldmVudHMgc3luY2hyb25vdXNseVxuICAgICAgICAgICAga28uZGVwZW5kZW5jeURldGVjdGlvbi5pZ25vcmUoa28udXRpbHMudHJpZ2dlckV2ZW50LCBudWxsLCBbZWxlbWVudCwgdmFsdWUgPyBcImZvY3VzaW5cIiA6IFwiZm9jdXNvdXRcIl0pO1xuICAgICAgICB9XG4gICAgfVxufTtcbmtvLmV4cHJlc3Npb25SZXdyaXRpbmcudHdvV2F5QmluZGluZ3NbJ2hhc2ZvY3VzJ10gPSB0cnVlO1xuXG5rby5iaW5kaW5nSGFuZGxlcnNbJ2hhc0ZvY3VzJ10gPSBrby5iaW5kaW5nSGFuZGxlcnNbJ2hhc2ZvY3VzJ107IC8vIE1ha2UgXCJoYXNGb2N1c1wiIGFuIGFsaWFzXG5rby5leHByZXNzaW9uUmV3cml0aW5nLnR3b1dheUJpbmRpbmdzWydoYXNGb2N1cyddID0gdHJ1ZTtcbmtvLmJpbmRpbmdIYW5kbGVyc1snaHRtbCddID0ge1xuICAgICdpbml0JzogZnVuY3Rpb24oKSB7XG4gICAgICAgIC8vIFByZXZlbnQgYmluZGluZyBvbiB0aGUgZHluYW1pY2FsbHktaW5qZWN0ZWQgSFRNTCAoYXMgZGV2ZWxvcGVycyBhcmUgdW5saWtlbHkgdG8gZXhwZWN0IHRoYXQsIGFuZCBpdCBoYXMgc2VjdXJpdHkgaW1wbGljYXRpb25zKVxuICAgICAgICByZXR1cm4geyAnY29udHJvbHNEZXNjZW5kYW50QmluZGluZ3MnOiB0cnVlIH07XG4gICAgfSxcbiAgICAndXBkYXRlJzogZnVuY3Rpb24gKGVsZW1lbnQsIHZhbHVlQWNjZXNzb3IpIHtcbiAgICAgICAgLy8gc2V0SHRtbCB3aWxsIHVud3JhcCB0aGUgdmFsdWUgaWYgbmVlZGVkXG4gICAgICAgIGtvLnV0aWxzLnNldEh0bWwoZWxlbWVudCwgdmFsdWVBY2Nlc3NvcigpKTtcbiAgICB9XG59O1xuLy8gTWFrZXMgYSBiaW5kaW5nIGxpa2Ugd2l0aCBvciBpZlxuZnVuY3Rpb24gbWFrZVdpdGhJZkJpbmRpbmcoYmluZGluZ0tleSwgaXNXaXRoLCBpc05vdCwgbWFrZUNvbnRleHRDYWxsYmFjaykge1xuICAgIGtvLmJpbmRpbmdIYW5kbGVyc1tiaW5kaW5nS2V5XSA9IHtcbiAgICAgICAgJ2luaXQnOiBmdW5jdGlvbihlbGVtZW50LCB2YWx1ZUFjY2Vzc29yLCBhbGxCaW5kaW5ncywgdmlld01vZGVsLCBiaW5kaW5nQ29udGV4dCkge1xuICAgICAgICAgICAgdmFyIGRpZERpc3BsYXlPbkxhc3RVcGRhdGUsXG4gICAgICAgICAgICAgICAgc2F2ZWROb2RlcztcbiAgICAgICAgICAgIGtvLmNvbXB1dGVkKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHZhciByYXdWYWx1ZSA9IHZhbHVlQWNjZXNzb3IoKSxcbiAgICAgICAgICAgICAgICAgICAgZGF0YVZhbHVlID0ga28udXRpbHMudW53cmFwT2JzZXJ2YWJsZShyYXdWYWx1ZSksXG4gICAgICAgICAgICAgICAgICAgIHNob3VsZERpc3BsYXkgPSAhaXNOb3QgIT09ICFkYXRhVmFsdWUsIC8vIGVxdWl2YWxlbnQgdG8gaXNOb3QgPyAhZGF0YVZhbHVlIDogISFkYXRhVmFsdWVcbiAgICAgICAgICAgICAgICAgICAgaXNGaXJzdFJlbmRlciA9ICFzYXZlZE5vZGVzLFxuICAgICAgICAgICAgICAgICAgICBuZWVkc1JlZnJlc2ggPSBpc0ZpcnN0UmVuZGVyIHx8IGlzV2l0aCB8fCAoc2hvdWxkRGlzcGxheSAhPT0gZGlkRGlzcGxheU9uTGFzdFVwZGF0ZSk7XG5cbiAgICAgICAgICAgICAgICBpZiAobmVlZHNSZWZyZXNoKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFNhdmUgYSBjb3B5IG9mIHRoZSBpbm5lciBub2RlcyBvbiB0aGUgaW5pdGlhbCB1cGRhdGUsIGJ1dCBvbmx5IGlmIHdlIGhhdmUgZGVwZW5kZW5jaWVzLlxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNGaXJzdFJlbmRlciAmJiBrby5jb21wdXRlZENvbnRleHQuZ2V0RGVwZW5kZW5jaWVzQ291bnQoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2F2ZWROb2RlcyA9IGtvLnV0aWxzLmNsb25lTm9kZXMoa28udmlydHVhbEVsZW1lbnRzLmNoaWxkTm9kZXMoZWxlbWVudCksIHRydWUgLyogc2hvdWxkQ2xlYW5Ob2RlcyAqLyk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAoc2hvdWxkRGlzcGxheSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFpc0ZpcnN0UmVuZGVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAga28udmlydHVhbEVsZW1lbnRzLnNldERvbU5vZGVDaGlsZHJlbihlbGVtZW50LCBrby51dGlscy5jbG9uZU5vZGVzKHNhdmVkTm9kZXMpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGtvLmFwcGx5QmluZGluZ3NUb0Rlc2NlbmRhbnRzKG1ha2VDb250ZXh0Q2FsbGJhY2sgPyBtYWtlQ29udGV4dENhbGxiYWNrKGJpbmRpbmdDb250ZXh0LCByYXdWYWx1ZSkgOiBiaW5kaW5nQ29udGV4dCwgZWxlbWVudCk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBrby52aXJ0dWFsRWxlbWVudHMuZW1wdHlOb2RlKGVsZW1lbnQpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgZGlkRGlzcGxheU9uTGFzdFVwZGF0ZSA9IHNob3VsZERpc3BsYXk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgbnVsbCwgeyBkaXNwb3NlV2hlbk5vZGVJc1JlbW92ZWQ6IGVsZW1lbnQgfSk7XG4gICAgICAgICAgICByZXR1cm4geyAnY29udHJvbHNEZXNjZW5kYW50QmluZGluZ3MnOiB0cnVlIH07XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGtvLmV4cHJlc3Npb25SZXdyaXRpbmcuYmluZGluZ1Jld3JpdGVWYWxpZGF0b3JzW2JpbmRpbmdLZXldID0gZmFsc2U7IC8vIENhbid0IHJld3JpdGUgY29udHJvbCBmbG93IGJpbmRpbmdzXG4gICAga28udmlydHVhbEVsZW1lbnRzLmFsbG93ZWRCaW5kaW5nc1tiaW5kaW5nS2V5XSA9IHRydWU7XG59XG5cbi8vIENvbnN0cnVjdCB0aGUgYWN0dWFsIGJpbmRpbmcgaGFuZGxlcnNcbm1ha2VXaXRoSWZCaW5kaW5nKCdpZicpO1xubWFrZVdpdGhJZkJpbmRpbmcoJ2lmbm90JywgZmFsc2UgLyogaXNXaXRoICovLCB0cnVlIC8qIGlzTm90ICovKTtcbm1ha2VXaXRoSWZCaW5kaW5nKCd3aXRoJywgdHJ1ZSAvKiBpc1dpdGggKi8sIGZhbHNlIC8qIGlzTm90ICovLFxuICAgIGZ1bmN0aW9uKGJpbmRpbmdDb250ZXh0LCBkYXRhVmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGJpbmRpbmdDb250ZXh0LmNyZWF0ZVN0YXRpY0NoaWxkQ29udGV4dChkYXRhVmFsdWUpO1xuICAgIH1cbik7XG52YXIgY2FwdGlvblBsYWNlaG9sZGVyID0ge307XG5rby5iaW5kaW5nSGFuZGxlcnNbJ29wdGlvbnMnXSA9IHtcbiAgICAnaW5pdCc6IGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgICAgICAgaWYgKGtvLnV0aWxzLnRhZ05hbWVMb3dlcihlbGVtZW50KSAhPT0gXCJzZWxlY3RcIilcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIm9wdGlvbnMgYmluZGluZyBhcHBsaWVzIG9ubHkgdG8gU0VMRUNUIGVsZW1lbnRzXCIpO1xuXG4gICAgICAgIC8vIFJlbW92ZSBhbGwgZXhpc3RpbmcgPG9wdGlvbj5zLlxuICAgICAgICB3aGlsZSAoZWxlbWVudC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBlbGVtZW50LnJlbW92ZSgwKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEVuc3VyZXMgdGhhdCB0aGUgYmluZGluZyBwcm9jZXNzb3IgZG9lc24ndCB0cnkgdG8gYmluZCB0aGUgb3B0aW9uc1xuICAgICAgICByZXR1cm4geyAnY29udHJvbHNEZXNjZW5kYW50QmluZGluZ3MnOiB0cnVlIH07XG4gICAgfSxcbiAgICAndXBkYXRlJzogZnVuY3Rpb24gKGVsZW1lbnQsIHZhbHVlQWNjZXNzb3IsIGFsbEJpbmRpbmdzKSB7XG4gICAgICAgIGZ1bmN0aW9uIHNlbGVjdGVkT3B0aW9ucygpIHtcbiAgICAgICAgICAgIHJldHVybiBrby51dGlscy5hcnJheUZpbHRlcihlbGVtZW50Lm9wdGlvbnMsIGZ1bmN0aW9uIChub2RlKSB7IHJldHVybiBub2RlLnNlbGVjdGVkOyB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBzZWxlY3RXYXNQcmV2aW91c2x5RW1wdHkgPSBlbGVtZW50Lmxlbmd0aCA9PSAwLFxuICAgICAgICAgICAgbXVsdGlwbGUgPSBlbGVtZW50Lm11bHRpcGxlLFxuICAgICAgICAgICAgcHJldmlvdXNTY3JvbGxUb3AgPSAoIXNlbGVjdFdhc1ByZXZpb3VzbHlFbXB0eSAmJiBtdWx0aXBsZSkgPyBlbGVtZW50LnNjcm9sbFRvcCA6IG51bGwsXG4gICAgICAgICAgICB1bndyYXBwZWRBcnJheSA9IGtvLnV0aWxzLnVud3JhcE9ic2VydmFibGUodmFsdWVBY2Nlc3NvcigpKSxcbiAgICAgICAgICAgIHZhbHVlQWxsb3dVbnNldCA9IGFsbEJpbmRpbmdzLmdldCgndmFsdWVBbGxvd1Vuc2V0JykgJiYgYWxsQmluZGluZ3NbJ2hhcyddKCd2YWx1ZScpLFxuICAgICAgICAgICAgaW5jbHVkZURlc3Ryb3llZCA9IGFsbEJpbmRpbmdzLmdldCgnb3B0aW9uc0luY2x1ZGVEZXN0cm95ZWQnKSxcbiAgICAgICAgICAgIGFycmF5VG9Eb21Ob2RlQ2hpbGRyZW5PcHRpb25zID0ge30sXG4gICAgICAgICAgICBjYXB0aW9uVmFsdWUsXG4gICAgICAgICAgICBmaWx0ZXJlZEFycmF5LFxuICAgICAgICAgICAgcHJldmlvdXNTZWxlY3RlZFZhbHVlcyA9IFtdO1xuXG4gICAgICAgIGlmICghdmFsdWVBbGxvd1Vuc2V0KSB7XG4gICAgICAgICAgICBpZiAobXVsdGlwbGUpIHtcbiAgICAgICAgICAgICAgICBwcmV2aW91c1NlbGVjdGVkVmFsdWVzID0ga28udXRpbHMuYXJyYXlNYXAoc2VsZWN0ZWRPcHRpb25zKCksIGtvLnNlbGVjdEV4dGVuc2lvbnMucmVhZFZhbHVlKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZWxlbWVudC5zZWxlY3RlZEluZGV4ID49IDApIHtcbiAgICAgICAgICAgICAgICBwcmV2aW91c1NlbGVjdGVkVmFsdWVzLnB1c2goa28uc2VsZWN0RXh0ZW5zaW9ucy5yZWFkVmFsdWUoZWxlbWVudC5vcHRpb25zW2VsZW1lbnQuc2VsZWN0ZWRJbmRleF0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh1bndyYXBwZWRBcnJheSkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB1bndyYXBwZWRBcnJheS5sZW5ndGggPT0gXCJ1bmRlZmluZWRcIikgLy8gQ29lcmNlIHNpbmdsZSB2YWx1ZSBpbnRvIGFycmF5XG4gICAgICAgICAgICAgICAgdW53cmFwcGVkQXJyYXkgPSBbdW53cmFwcGVkQXJyYXldO1xuXG4gICAgICAgICAgICAvLyBGaWx0ZXIgb3V0IGFueSBlbnRyaWVzIG1hcmtlZCBhcyBkZXN0cm95ZWRcbiAgICAgICAgICAgIGZpbHRlcmVkQXJyYXkgPSBrby51dGlscy5hcnJheUZpbHRlcih1bndyYXBwZWRBcnJheSwgZnVuY3Rpb24oaXRlbSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpbmNsdWRlRGVzdHJveWVkIHx8IGl0ZW0gPT09IHVuZGVmaW5lZCB8fCBpdGVtID09PSBudWxsIHx8ICFrby51dGlscy51bndyYXBPYnNlcnZhYmxlKGl0ZW1bJ19kZXN0cm95J10pO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIC8vIElmIGNhcHRpb24gaXMgaW5jbHVkZWQsIGFkZCBpdCB0byB0aGUgYXJyYXlcbiAgICAgICAgICAgIGlmIChhbGxCaW5kaW5nc1snaGFzJ10oJ29wdGlvbnNDYXB0aW9uJykpIHtcbiAgICAgICAgICAgICAgICBjYXB0aW9uVmFsdWUgPSBrby51dGlscy51bndyYXBPYnNlcnZhYmxlKGFsbEJpbmRpbmdzLmdldCgnb3B0aW9uc0NhcHRpb24nKSk7XG4gICAgICAgICAgICAgICAgLy8gSWYgY2FwdGlvbiB2YWx1ZSBpcyBudWxsIG9yIHVuZGVmaW5lZCwgZG9uJ3Qgc2hvdyBhIGNhcHRpb25cbiAgICAgICAgICAgICAgICBpZiAoY2FwdGlvblZhbHVlICE9PSBudWxsICYmIGNhcHRpb25WYWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGZpbHRlcmVkQXJyYXkudW5zaGlmdChjYXB0aW9uUGxhY2Vob2xkZXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIElmIGEgZmFsc3kgdmFsdWUgaXMgcHJvdmlkZWQgKGUuZy4gbnVsbCksIHdlJ2xsIHNpbXBseSBlbXB0eSB0aGUgc2VsZWN0IGVsZW1lbnRcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGFwcGx5VG9PYmplY3Qob2JqZWN0LCBwcmVkaWNhdGUsIGRlZmF1bHRWYWx1ZSkge1xuICAgICAgICAgICAgdmFyIHByZWRpY2F0ZVR5cGUgPSB0eXBlb2YgcHJlZGljYXRlO1xuICAgICAgICAgICAgaWYgKHByZWRpY2F0ZVR5cGUgPT0gXCJmdW5jdGlvblwiKSAgICAvLyBHaXZlbiBhIGZ1bmN0aW9uOyBydW4gaXQgYWdhaW5zdCB0aGUgZGF0YSB2YWx1ZVxuICAgICAgICAgICAgICAgIHJldHVybiBwcmVkaWNhdGUob2JqZWN0KTtcbiAgICAgICAgICAgIGVsc2UgaWYgKHByZWRpY2F0ZVR5cGUgPT0gXCJzdHJpbmdcIikgLy8gR2l2ZW4gYSBzdHJpbmc7IHRyZWF0IGl0IGFzIGEgcHJvcGVydHkgbmFtZSBvbiB0aGUgZGF0YSB2YWx1ZVxuICAgICAgICAgICAgICAgIHJldHVybiBvYmplY3RbcHJlZGljYXRlXTtcbiAgICAgICAgICAgIGVsc2UgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEdpdmVuIG5vIG9wdGlvbnNUZXh0IGFyZzsgdXNlIHRoZSBkYXRhIHZhbHVlIGl0c2VsZlxuICAgICAgICAgICAgICAgIHJldHVybiBkZWZhdWx0VmFsdWU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUaGUgZm9sbG93aW5nIGZ1bmN0aW9ucyBjYW4gcnVuIGF0IHR3byBkaWZmZXJlbnQgdGltZXM6XG4gICAgICAgIC8vIFRoZSBmaXJzdCBpcyB3aGVuIHRoZSB3aG9sZSBhcnJheSBpcyBiZWluZyB1cGRhdGVkIGRpcmVjdGx5IGZyb20gdGhpcyBiaW5kaW5nIGhhbmRsZXIuXG4gICAgICAgIC8vIFRoZSBzZWNvbmQgaXMgd2hlbiBhbiBvYnNlcnZhYmxlIHZhbHVlIGZvciBhIHNwZWNpZmljIGFycmF5IGVudHJ5IGlzIHVwZGF0ZWQuXG4gICAgICAgIC8vIG9sZE9wdGlvbnMgd2lsbCBiZSBlbXB0eSBpbiB0aGUgZmlyc3QgY2FzZSwgYnV0IHdpbGwgYmUgZmlsbGVkIHdpdGggdGhlIHByZXZpb3VzbHkgZ2VuZXJhdGVkIG9wdGlvbiBpbiB0aGUgc2Vjb25kLlxuICAgICAgICB2YXIgaXRlbVVwZGF0ZSA9IGZhbHNlO1xuICAgICAgICBmdW5jdGlvbiBvcHRpb25Gb3JBcnJheUl0ZW0oYXJyYXlFbnRyeSwgaW5kZXgsIG9sZE9wdGlvbnMpIHtcbiAgICAgICAgICAgIGlmIChvbGRPcHRpb25zLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHByZXZpb3VzU2VsZWN0ZWRWYWx1ZXMgPSAhdmFsdWVBbGxvd1Vuc2V0ICYmIG9sZE9wdGlvbnNbMF0uc2VsZWN0ZWQgPyBbIGtvLnNlbGVjdEV4dGVuc2lvbnMucmVhZFZhbHVlKG9sZE9wdGlvbnNbMF0pIF0gOiBbXTtcbiAgICAgICAgICAgICAgICBpdGVtVXBkYXRlID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBvcHRpb24gPSBlbGVtZW50Lm93bmVyRG9jdW1lbnQuY3JlYXRlRWxlbWVudChcIm9wdGlvblwiKTtcbiAgICAgICAgICAgIGlmIChhcnJheUVudHJ5ID09PSBjYXB0aW9uUGxhY2Vob2xkZXIpIHtcbiAgICAgICAgICAgICAgICBrby51dGlscy5zZXRUZXh0Q29udGVudChvcHRpb24sIGFsbEJpbmRpbmdzLmdldCgnb3B0aW9uc0NhcHRpb24nKSk7XG4gICAgICAgICAgICAgICAga28uc2VsZWN0RXh0ZW5zaW9ucy53cml0ZVZhbHVlKG9wdGlvbiwgdW5kZWZpbmVkKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gQXBwbHkgYSB2YWx1ZSB0byB0aGUgb3B0aW9uIGVsZW1lbnRcbiAgICAgICAgICAgICAgICB2YXIgb3B0aW9uVmFsdWUgPSBhcHBseVRvT2JqZWN0KGFycmF5RW50cnksIGFsbEJpbmRpbmdzLmdldCgnb3B0aW9uc1ZhbHVlJyksIGFycmF5RW50cnkpO1xuICAgICAgICAgICAgICAgIGtvLnNlbGVjdEV4dGVuc2lvbnMud3JpdGVWYWx1ZShvcHRpb24sIGtvLnV0aWxzLnVud3JhcE9ic2VydmFibGUob3B0aW9uVmFsdWUpKTtcblxuICAgICAgICAgICAgICAgIC8vIEFwcGx5IHNvbWUgdGV4dCB0byB0aGUgb3B0aW9uIGVsZW1lbnRcbiAgICAgICAgICAgICAgICB2YXIgb3B0aW9uVGV4dCA9IGFwcGx5VG9PYmplY3QoYXJyYXlFbnRyeSwgYWxsQmluZGluZ3MuZ2V0KCdvcHRpb25zVGV4dCcpLCBvcHRpb25WYWx1ZSk7XG4gICAgICAgICAgICAgICAga28udXRpbHMuc2V0VGV4dENvbnRlbnQob3B0aW9uLCBvcHRpb25UZXh0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBbb3B0aW9uXTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEJ5IHVzaW5nIGEgYmVmb3JlUmVtb3ZlIGNhbGxiYWNrLCB3ZSBkZWxheSB0aGUgcmVtb3ZhbCB1bnRpbCBhZnRlciBuZXcgaXRlbXMgYXJlIGFkZGVkLiBUaGlzIGZpeGVzIGEgc2VsZWN0aW9uXG4gICAgICAgIC8vIHByb2JsZW0gaW4gSUU8PTggYW5kIEZpcmVmb3guIFNlZSBodHRwczovL2dpdGh1Yi5jb20va25vY2tvdXQva25vY2tvdXQvaXNzdWVzLzEyMDhcbiAgICAgICAgYXJyYXlUb0RvbU5vZGVDaGlsZHJlbk9wdGlvbnNbJ2JlZm9yZVJlbW92ZSddID1cbiAgICAgICAgICAgIGZ1bmN0aW9uIChvcHRpb24pIHtcbiAgICAgICAgICAgICAgICBlbGVtZW50LnJlbW92ZUNoaWxkKG9wdGlvbik7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgIGZ1bmN0aW9uIHNldFNlbGVjdGlvbkNhbGxiYWNrKGFycmF5RW50cnksIG5ld09wdGlvbnMpIHtcbiAgICAgICAgICAgIGlmIChpdGVtVXBkYXRlICYmIHZhbHVlQWxsb3dVbnNldCkge1xuICAgICAgICAgICAgICAgIC8vIFRoZSBtb2RlbCB2YWx1ZSBpcyBhdXRob3JpdGF0aXZlLCBzbyBtYWtlIHN1cmUgaXRzIHZhbHVlIGlzIHRoZSBvbmUgc2VsZWN0ZWRcbiAgICAgICAgICAgICAgICAvLyBUaGVyZSBpcyBubyBuZWVkIHRvIHVzZSBkZXBlbmRlbmN5RGV0ZWN0aW9uLmlnbm9yZSBzaW5jZSBzZXREb21Ob2RlQ2hpbGRyZW5Gcm9tQXJyYXlNYXBwaW5nIGRvZXMgc28gYWxyZWFkeS5cbiAgICAgICAgICAgICAgICBrby5zZWxlY3RFeHRlbnNpb25zLndyaXRlVmFsdWUoZWxlbWVudCwga28udXRpbHMudW53cmFwT2JzZXJ2YWJsZShhbGxCaW5kaW5ncy5nZXQoJ3ZhbHVlJykpLCB0cnVlIC8qIGFsbG93VW5zZXQgKi8pO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChwcmV2aW91c1NlbGVjdGVkVmFsdWVzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIC8vIElFNiBkb2Vzbid0IGxpa2UgdXMgdG8gYXNzaWduIHNlbGVjdGlvbiB0byBPUFRJT04gbm9kZXMgYmVmb3JlIHRoZXkncmUgYWRkZWQgdG8gdGhlIGRvY3VtZW50LlxuICAgICAgICAgICAgICAgIC8vIFRoYXQncyB3aHkgd2UgZmlyc3QgYWRkZWQgdGhlbSB3aXRob3V0IHNlbGVjdGlvbi4gTm93IGl0J3MgdGltZSB0byBzZXQgdGhlIHNlbGVjdGlvbi5cbiAgICAgICAgICAgICAgICB2YXIgaXNTZWxlY3RlZCA9IGtvLnV0aWxzLmFycmF5SW5kZXhPZihwcmV2aW91c1NlbGVjdGVkVmFsdWVzLCBrby5zZWxlY3RFeHRlbnNpb25zLnJlYWRWYWx1ZShuZXdPcHRpb25zWzBdKSkgPj0gMDtcbiAgICAgICAgICAgICAgICBrby51dGlscy5zZXRPcHRpb25Ob2RlU2VsZWN0aW9uU3RhdGUobmV3T3B0aW9uc1swXSwgaXNTZWxlY3RlZCk7XG5cbiAgICAgICAgICAgICAgICAvLyBJZiB0aGlzIG9wdGlvbiB3YXMgY2hhbmdlZCBmcm9tIGJlaW5nIHNlbGVjdGVkIGR1cmluZyBhIHNpbmdsZS1pdGVtIHVwZGF0ZSwgbm90aWZ5IHRoZSBjaGFuZ2VcbiAgICAgICAgICAgICAgICBpZiAoaXRlbVVwZGF0ZSAmJiAhaXNTZWxlY3RlZCkge1xuICAgICAgICAgICAgICAgICAgICBrby5kZXBlbmRlbmN5RGV0ZWN0aW9uLmlnbm9yZShrby51dGlscy50cmlnZ2VyRXZlbnQsIG51bGwsIFtlbGVtZW50LCBcImNoYW5nZVwiXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGNhbGxiYWNrID0gc2V0U2VsZWN0aW9uQ2FsbGJhY2s7XG4gICAgICAgIGlmIChhbGxCaW5kaW5nc1snaGFzJ10oJ29wdGlvbnNBZnRlclJlbmRlcicpICYmIHR5cGVvZiBhbGxCaW5kaW5ncy5nZXQoJ29wdGlvbnNBZnRlclJlbmRlcicpID09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgY2FsbGJhY2sgPSBmdW5jdGlvbihhcnJheUVudHJ5LCBuZXdPcHRpb25zKSB7XG4gICAgICAgICAgICAgICAgc2V0U2VsZWN0aW9uQ2FsbGJhY2soYXJyYXlFbnRyeSwgbmV3T3B0aW9ucyk7XG4gICAgICAgICAgICAgICAga28uZGVwZW5kZW5jeURldGVjdGlvbi5pZ25vcmUoYWxsQmluZGluZ3MuZ2V0KCdvcHRpb25zQWZ0ZXJSZW5kZXInKSwgbnVsbCwgW25ld09wdGlvbnNbMF0sIGFycmF5RW50cnkgIT09IGNhcHRpb25QbGFjZWhvbGRlciA/IGFycmF5RW50cnkgOiB1bmRlZmluZWRdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGtvLnV0aWxzLnNldERvbU5vZGVDaGlsZHJlbkZyb21BcnJheU1hcHBpbmcoZWxlbWVudCwgZmlsdGVyZWRBcnJheSwgb3B0aW9uRm9yQXJyYXlJdGVtLCBhcnJheVRvRG9tTm9kZUNoaWxkcmVuT3B0aW9ucywgY2FsbGJhY2spO1xuXG4gICAgICAgIGtvLmRlcGVuZGVuY3lEZXRlY3Rpb24uaWdub3JlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZUFsbG93VW5zZXQpIHtcbiAgICAgICAgICAgICAgICAvLyBUaGUgbW9kZWwgdmFsdWUgaXMgYXV0aG9yaXRhdGl2ZSwgc28gbWFrZSBzdXJlIGl0cyB2YWx1ZSBpcyB0aGUgb25lIHNlbGVjdGVkXG4gICAgICAgICAgICAgICAga28uc2VsZWN0RXh0ZW5zaW9ucy53cml0ZVZhbHVlKGVsZW1lbnQsIGtvLnV0aWxzLnVud3JhcE9ic2VydmFibGUoYWxsQmluZGluZ3MuZ2V0KCd2YWx1ZScpKSwgdHJ1ZSAvKiBhbGxvd1Vuc2V0ICovKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gRGV0ZXJtaW5lIGlmIHRoZSBzZWxlY3Rpb24gaGFzIGNoYW5nZWQgYXMgYSByZXN1bHQgb2YgdXBkYXRpbmcgdGhlIG9wdGlvbnMgbGlzdFxuICAgICAgICAgICAgICAgIHZhciBzZWxlY3Rpb25DaGFuZ2VkO1xuICAgICAgICAgICAgICAgIGlmIChtdWx0aXBsZSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBGb3IgYSBtdWx0aXBsZS1zZWxlY3QgYm94LCBjb21wYXJlIHRoZSBuZXcgc2VsZWN0aW9uIGNvdW50IHRvIHRoZSBwcmV2aW91cyBvbmVcbiAgICAgICAgICAgICAgICAgICAgLy8gQnV0IGlmIG5vdGhpbmcgd2FzIHNlbGVjdGVkIGJlZm9yZSwgdGhlIHNlbGVjdGlvbiBjYW4ndCBoYXZlIGNoYW5nZWRcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0aW9uQ2hhbmdlZCA9IHByZXZpb3VzU2VsZWN0ZWRWYWx1ZXMubGVuZ3RoICYmIHNlbGVjdGVkT3B0aW9ucygpLmxlbmd0aCA8IHByZXZpb3VzU2VsZWN0ZWRWYWx1ZXMubGVuZ3RoO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEZvciBhIHNpbmdsZS1zZWxlY3QgYm94LCBjb21wYXJlIHRoZSBjdXJyZW50IHZhbHVlIHRvIHRoZSBwcmV2aW91cyB2YWx1ZVxuICAgICAgICAgICAgICAgICAgICAvLyBCdXQgaWYgbm90aGluZyB3YXMgc2VsZWN0ZWQgYmVmb3JlIG9yIG5vdGhpbmcgaXMgc2VsZWN0ZWQgbm93LCBqdXN0IGxvb2sgZm9yIGEgY2hhbmdlIGluIHNlbGVjdGlvblxuICAgICAgICAgICAgICAgICAgICBzZWxlY3Rpb25DaGFuZ2VkID0gKHByZXZpb3VzU2VsZWN0ZWRWYWx1ZXMubGVuZ3RoICYmIGVsZW1lbnQuc2VsZWN0ZWRJbmRleCA+PSAwKVxuICAgICAgICAgICAgICAgICAgICAgICAgPyAoa28uc2VsZWN0RXh0ZW5zaW9ucy5yZWFkVmFsdWUoZWxlbWVudC5vcHRpb25zW2VsZW1lbnQuc2VsZWN0ZWRJbmRleF0pICE9PSBwcmV2aW91c1NlbGVjdGVkVmFsdWVzWzBdKVxuICAgICAgICAgICAgICAgICAgICAgICAgOiAocHJldmlvdXNTZWxlY3RlZFZhbHVlcy5sZW5ndGggfHwgZWxlbWVudC5zZWxlY3RlZEluZGV4ID49IDApO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIEVuc3VyZSBjb25zaXN0ZW5jeSBiZXR3ZWVuIG1vZGVsIHZhbHVlIGFuZCBzZWxlY3RlZCBvcHRpb24uXG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlIGRyb3Bkb3duIHdhcyBjaGFuZ2VkIHNvIHRoYXQgc2VsZWN0aW9uIGlzIG5vIGxvbmdlciB0aGUgc2FtZSxcbiAgICAgICAgICAgICAgICAvLyBub3RpZnkgdGhlIHZhbHVlIG9yIHNlbGVjdGVkT3B0aW9ucyBiaW5kaW5nLlxuICAgICAgICAgICAgICAgIGlmIChzZWxlY3Rpb25DaGFuZ2VkKSB7XG4gICAgICAgICAgICAgICAgICAgIGtvLnV0aWxzLnRyaWdnZXJFdmVudChlbGVtZW50LCBcImNoYW5nZVwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIFdvcmthcm91bmQgZm9yIElFIGJ1Z1xuICAgICAgICBrby51dGlscy5lbnN1cmVTZWxlY3RFbGVtZW50SXNSZW5kZXJlZENvcnJlY3RseShlbGVtZW50KTtcblxuICAgICAgICBpZiAocHJldmlvdXNTY3JvbGxUb3AgJiYgTWF0aC5hYnMocHJldmlvdXNTY3JvbGxUb3AgLSBlbGVtZW50LnNjcm9sbFRvcCkgPiAyMClcbiAgICAgICAgICAgIGVsZW1lbnQuc2Nyb2xsVG9wID0gcHJldmlvdXNTY3JvbGxUb3A7XG4gICAgfVxufTtcbmtvLmJpbmRpbmdIYW5kbGVyc1snb3B0aW9ucyddLm9wdGlvblZhbHVlRG9tRGF0YUtleSA9IGtvLnV0aWxzLmRvbURhdGEubmV4dEtleSgpO1xua28uYmluZGluZ0hhbmRsZXJzWydzZWxlY3RlZE9wdGlvbnMnXSA9IHtcbiAgICAnYWZ0ZXInOiBbJ29wdGlvbnMnLCAnZm9yZWFjaCddLFxuICAgICdpbml0JzogZnVuY3Rpb24gKGVsZW1lbnQsIHZhbHVlQWNjZXNzb3IsIGFsbEJpbmRpbmdzKSB7XG4gICAgICAgIGtvLnV0aWxzLnJlZ2lzdGVyRXZlbnRIYW5kbGVyKGVsZW1lbnQsIFwiY2hhbmdlXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IHZhbHVlQWNjZXNzb3IoKSwgdmFsdWVUb1dyaXRlID0gW107XG4gICAgICAgICAgICBrby51dGlscy5hcnJheUZvckVhY2goZWxlbWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZShcIm9wdGlvblwiKSwgZnVuY3Rpb24obm9kZSkge1xuICAgICAgICAgICAgICAgIGlmIChub2RlLnNlbGVjdGVkKVxuICAgICAgICAgICAgICAgICAgICB2YWx1ZVRvV3JpdGUucHVzaChrby5zZWxlY3RFeHRlbnNpb25zLnJlYWRWYWx1ZShub2RlKSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGtvLmV4cHJlc3Npb25SZXdyaXRpbmcud3JpdGVWYWx1ZVRvUHJvcGVydHkodmFsdWUsIGFsbEJpbmRpbmdzLCAnc2VsZWN0ZWRPcHRpb25zJywgdmFsdWVUb1dyaXRlKTtcbiAgICAgICAgfSk7XG4gICAgfSxcbiAgICAndXBkYXRlJzogZnVuY3Rpb24gKGVsZW1lbnQsIHZhbHVlQWNjZXNzb3IpIHtcbiAgICAgICAgaWYgKGtvLnV0aWxzLnRhZ05hbWVMb3dlcihlbGVtZW50KSAhPSBcInNlbGVjdFwiKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwidmFsdWVzIGJpbmRpbmcgYXBwbGllcyBvbmx5IHRvIFNFTEVDVCBlbGVtZW50c1wiKTtcblxuICAgICAgICB2YXIgbmV3VmFsdWUgPSBrby51dGlscy51bndyYXBPYnNlcnZhYmxlKHZhbHVlQWNjZXNzb3IoKSksXG4gICAgICAgICAgICBwcmV2aW91c1Njcm9sbFRvcCA9IGVsZW1lbnQuc2Nyb2xsVG9wO1xuXG4gICAgICAgIGlmIChuZXdWYWx1ZSAmJiB0eXBlb2YgbmV3VmFsdWUubGVuZ3RoID09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgIGtvLnV0aWxzLmFycmF5Rm9yRWFjaChlbGVtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKFwib3B0aW9uXCIpLCBmdW5jdGlvbihub2RlKSB7XG4gICAgICAgICAgICAgICAgdmFyIGlzU2VsZWN0ZWQgPSBrby51dGlscy5hcnJheUluZGV4T2YobmV3VmFsdWUsIGtvLnNlbGVjdEV4dGVuc2lvbnMucmVhZFZhbHVlKG5vZGUpKSA+PSAwO1xuICAgICAgICAgICAgICAgIGlmIChub2RlLnNlbGVjdGVkICE9IGlzU2VsZWN0ZWQpIHsgICAgICAvLyBUaGlzIGNoZWNrIHByZXZlbnRzIGZsYXNoaW5nIG9mIHRoZSBzZWxlY3QgZWxlbWVudCBpbiBJRVxuICAgICAgICAgICAgICAgICAgICBrby51dGlscy5zZXRPcHRpb25Ob2RlU2VsZWN0aW9uU3RhdGUobm9kZSwgaXNTZWxlY3RlZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBlbGVtZW50LnNjcm9sbFRvcCA9IHByZXZpb3VzU2Nyb2xsVG9wO1xuICAgIH1cbn07XG5rby5leHByZXNzaW9uUmV3cml0aW5nLnR3b1dheUJpbmRpbmdzWydzZWxlY3RlZE9wdGlvbnMnXSA9IHRydWU7XG5rby5iaW5kaW5nSGFuZGxlcnNbJ3N0eWxlJ10gPSB7XG4gICAgJ3VwZGF0ZSc6IGZ1bmN0aW9uIChlbGVtZW50LCB2YWx1ZUFjY2Vzc29yKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IGtvLnV0aWxzLnVud3JhcE9ic2VydmFibGUodmFsdWVBY2Nlc3NvcigpIHx8IHt9KTtcbiAgICAgICAga28udXRpbHMub2JqZWN0Rm9yRWFjaCh2YWx1ZSwgZnVuY3Rpb24oc3R5bGVOYW1lLCBzdHlsZVZhbHVlKSB7XG4gICAgICAgICAgICBzdHlsZVZhbHVlID0ga28udXRpbHMudW53cmFwT2JzZXJ2YWJsZShzdHlsZVZhbHVlKTtcblxuICAgICAgICAgICAgaWYgKHN0eWxlVmFsdWUgPT09IG51bGwgfHwgc3R5bGVWYWx1ZSA9PT0gdW5kZWZpbmVkIHx8IHN0eWxlVmFsdWUgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgLy8gRW1wdHkgc3RyaW5nIHJlbW92ZXMgdGhlIHZhbHVlLCB3aGVyZWFzIG51bGwvdW5kZWZpbmVkIGhhdmUgbm8gZWZmZWN0XG4gICAgICAgICAgICAgICAgc3R5bGVWYWx1ZSA9IFwiXCI7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGVsZW1lbnQuc3R5bGVbc3R5bGVOYW1lXSA9IHN0eWxlVmFsdWU7XG4gICAgICAgIH0pO1xuICAgIH1cbn07XG5rby5iaW5kaW5nSGFuZGxlcnNbJ3N1Ym1pdCddID0ge1xuICAgICdpbml0JzogZnVuY3Rpb24gKGVsZW1lbnQsIHZhbHVlQWNjZXNzb3IsIGFsbEJpbmRpbmdzLCB2aWV3TW9kZWwsIGJpbmRpbmdDb250ZXh0KSB7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWVBY2Nlc3NvcigpICE9IFwiZnVuY3Rpb25cIilcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoZSB2YWx1ZSBmb3IgYSBzdWJtaXQgYmluZGluZyBtdXN0IGJlIGEgZnVuY3Rpb25cIik7XG4gICAgICAgIGtvLnV0aWxzLnJlZ2lzdGVyRXZlbnRIYW5kbGVyKGVsZW1lbnQsIFwic3VibWl0XCIsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgdmFyIGhhbmRsZXJSZXR1cm5WYWx1ZTtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IHZhbHVlQWNjZXNzb3IoKTtcbiAgICAgICAgICAgIHRyeSB7IGhhbmRsZXJSZXR1cm5WYWx1ZSA9IHZhbHVlLmNhbGwoYmluZGluZ0NvbnRleHRbJyRkYXRhJ10sIGVsZW1lbnQpOyB9XG4gICAgICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICBpZiAoaGFuZGxlclJldHVyblZhbHVlICE9PSB0cnVlKSB7IC8vIE5vcm1hbGx5IHdlIHdhbnQgdG8gcHJldmVudCBkZWZhdWx0IGFjdGlvbi4gRGV2ZWxvcGVyIGNhbiBvdmVycmlkZSB0aGlzIGJlIGV4cGxpY2l0bHkgcmV0dXJuaW5nIHRydWUuXG4gICAgICAgICAgICAgICAgICAgIGlmIChldmVudC5wcmV2ZW50RGVmYXVsdClcbiAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50LnJldHVyblZhbHVlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG59O1xua28uYmluZGluZ0hhbmRsZXJzWyd0ZXh0J10gPSB7XG4gICAgJ2luaXQnOiBmdW5jdGlvbigpIHtcbiAgICAgICAgLy8gUHJldmVudCBiaW5kaW5nIG9uIHRoZSBkeW5hbWljYWxseS1pbmplY3RlZCB0ZXh0IG5vZGUgKGFzIGRldmVsb3BlcnMgYXJlIHVubGlrZWx5IHRvIGV4cGVjdCB0aGF0LCBhbmQgaXQgaGFzIHNlY3VyaXR5IGltcGxpY2F0aW9ucykuXG4gICAgICAgIC8vIEl0IHNob3VsZCBhbHNvIG1ha2UgdGhpbmdzIGZhc3RlciwgYXMgd2Ugbm8gbG9uZ2VyIGhhdmUgdG8gY29uc2lkZXIgd2hldGhlciB0aGUgdGV4dCBub2RlIG1pZ2h0IGJlIGJpbmRhYmxlLlxuICAgICAgICByZXR1cm4geyAnY29udHJvbHNEZXNjZW5kYW50QmluZGluZ3MnOiB0cnVlIH07XG4gICAgfSxcbiAgICAndXBkYXRlJzogZnVuY3Rpb24gKGVsZW1lbnQsIHZhbHVlQWNjZXNzb3IpIHtcbiAgICAgICAga28udXRpbHMuc2V0VGV4dENvbnRlbnQoZWxlbWVudCwgdmFsdWVBY2Nlc3NvcigpKTtcbiAgICB9XG59O1xua28udmlydHVhbEVsZW1lbnRzLmFsbG93ZWRCaW5kaW5nc1sndGV4dCddID0gdHJ1ZTtcbihmdW5jdGlvbiAoKSB7XG5cbmlmICh3aW5kb3cgJiYgd2luZG93Lm5hdmlnYXRvcikge1xuICAgIHZhciBwYXJzZVZlcnNpb24gPSBmdW5jdGlvbiAobWF0Y2hlcykge1xuICAgICAgICBpZiAobWF0Y2hlcykge1xuICAgICAgICAgICAgcmV0dXJuIHBhcnNlRmxvYXQobWF0Y2hlc1sxXSk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLy8gRGV0ZWN0IHZhcmlvdXMgYnJvd3NlciB2ZXJzaW9ucyBiZWNhdXNlIHNvbWUgb2xkIHZlcnNpb25zIGRvbid0IGZ1bGx5IHN1cHBvcnQgdGhlICdpbnB1dCcgZXZlbnRcbiAgICB2YXIgb3BlcmFWZXJzaW9uID0gd2luZG93Lm9wZXJhICYmIHdpbmRvdy5vcGVyYS52ZXJzaW9uICYmIHBhcnNlSW50KHdpbmRvdy5vcGVyYS52ZXJzaW9uKCkpLFxuICAgICAgICB1c2VyQWdlbnQgPSB3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudCxcbiAgICAgICAgc2FmYXJpVmVyc2lvbiA9IHBhcnNlVmVyc2lvbih1c2VyQWdlbnQubWF0Y2goL14oPzooPyFjaHJvbWUpLikqdmVyc2lvblxcLyhbXiBdKikgc2FmYXJpL2kpKSxcbiAgICAgICAgZmlyZWZveFZlcnNpb24gPSBwYXJzZVZlcnNpb24odXNlckFnZW50Lm1hdGNoKC9GaXJlZm94XFwvKFteIF0qKS8pKTtcbn1cblxuLy8gSUUgOCBhbmQgOSBoYXZlIGJ1Z3MgdGhhdCBwcmV2ZW50IHRoZSBub3JtYWwgZXZlbnRzIGZyb20gZmlyaW5nIHdoZW4gdGhlIHZhbHVlIGNoYW5nZXMuXG4vLyBCdXQgaXQgZG9lcyBmaXJlIHRoZSAnc2VsZWN0aW9uY2hhbmdlJyBldmVudCBvbiBtYW55IG9mIHRob3NlLCBwcmVzdW1hYmx5IGJlY2F1c2UgdGhlXG4vLyBjdXJzb3IgaXMgbW92aW5nIGFuZCB0aGF0IGNvdW50cyBhcyB0aGUgc2VsZWN0aW9uIGNoYW5naW5nLiBUaGUgJ3NlbGVjdGlvbmNoYW5nZScgZXZlbnQgaXNcbi8vIGZpcmVkIGF0IHRoZSBkb2N1bWVudCBsZXZlbCBvbmx5IGFuZCBkb2Vzbid0IGRpcmVjdGx5IGluZGljYXRlIHdoaWNoIGVsZW1lbnQgY2hhbmdlZC4gV2Vcbi8vIHNldCB1cCBqdXN0IG9uZSBldmVudCBoYW5kbGVyIGZvciB0aGUgZG9jdW1lbnQgYW5kIHVzZSAnYWN0aXZlRWxlbWVudCcgdG8gZGV0ZXJtaW5lIHdoaWNoXG4vLyBlbGVtZW50IHdhcyBjaGFuZ2VkLlxuaWYgKGtvLnV0aWxzLmllVmVyc2lvbiA8IDEwKSB7XG4gICAgdmFyIHNlbGVjdGlvbkNoYW5nZVJlZ2lzdGVyZWROYW1lID0ga28udXRpbHMuZG9tRGF0YS5uZXh0S2V5KCksXG4gICAgICAgIHNlbGVjdGlvbkNoYW5nZUhhbmRsZXJOYW1lID0ga28udXRpbHMuZG9tRGF0YS5uZXh0S2V5KCk7XG4gICAgdmFyIHNlbGVjdGlvbkNoYW5nZUhhbmRsZXIgPSBmdW5jdGlvbihldmVudCkge1xuICAgICAgICB2YXIgdGFyZ2V0ID0gdGhpcy5hY3RpdmVFbGVtZW50LFxuICAgICAgICAgICAgaGFuZGxlciA9IHRhcmdldCAmJiBrby51dGlscy5kb21EYXRhLmdldCh0YXJnZXQsIHNlbGVjdGlvbkNoYW5nZUhhbmRsZXJOYW1lKTtcbiAgICAgICAgaWYgKGhhbmRsZXIpIHtcbiAgICAgICAgICAgIGhhbmRsZXIoZXZlbnQpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICB2YXIgcmVnaXN0ZXJGb3JTZWxlY3Rpb25DaGFuZ2VFdmVudCA9IGZ1bmN0aW9uIChlbGVtZW50LCBoYW5kbGVyKSB7XG4gICAgICAgIHZhciBvd25lckRvYyA9IGVsZW1lbnQub3duZXJEb2N1bWVudDtcbiAgICAgICAgaWYgKCFrby51dGlscy5kb21EYXRhLmdldChvd25lckRvYywgc2VsZWN0aW9uQ2hhbmdlUmVnaXN0ZXJlZE5hbWUpKSB7XG4gICAgICAgICAgICBrby51dGlscy5kb21EYXRhLnNldChvd25lckRvYywgc2VsZWN0aW9uQ2hhbmdlUmVnaXN0ZXJlZE5hbWUsIHRydWUpO1xuICAgICAgICAgICAga28udXRpbHMucmVnaXN0ZXJFdmVudEhhbmRsZXIob3duZXJEb2MsICdzZWxlY3Rpb25jaGFuZ2UnLCBzZWxlY3Rpb25DaGFuZ2VIYW5kbGVyKTtcbiAgICAgICAgfVxuICAgICAgICBrby51dGlscy5kb21EYXRhLnNldChlbGVtZW50LCBzZWxlY3Rpb25DaGFuZ2VIYW5kbGVyTmFtZSwgaGFuZGxlcik7XG4gICAgfTtcbn1cblxua28uYmluZGluZ0hhbmRsZXJzWyd0ZXh0SW5wdXQnXSA9IHtcbiAgICAnaW5pdCc6IGZ1bmN0aW9uIChlbGVtZW50LCB2YWx1ZUFjY2Vzc29yLCBhbGxCaW5kaW5ncykge1xuXG4gICAgICAgIHZhciBwcmV2aW91c0VsZW1lbnRWYWx1ZSA9IGVsZW1lbnQudmFsdWUsXG4gICAgICAgICAgICB0aW1lb3V0SGFuZGxlLFxuICAgICAgICAgICAgZWxlbWVudFZhbHVlQmVmb3JlRXZlbnQ7XG5cbiAgICAgICAgdmFyIHVwZGF0ZU1vZGVsID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dEhhbmRsZSk7XG4gICAgICAgICAgICBlbGVtZW50VmFsdWVCZWZvcmVFdmVudCA9IHRpbWVvdXRIYW5kbGUgPSB1bmRlZmluZWQ7XG5cbiAgICAgICAgICAgIHZhciBlbGVtZW50VmFsdWUgPSBlbGVtZW50LnZhbHVlO1xuICAgICAgICAgICAgaWYgKHByZXZpb3VzRWxlbWVudFZhbHVlICE9PSBlbGVtZW50VmFsdWUpIHtcbiAgICAgICAgICAgICAgICAvLyBQcm92aWRlIGEgd2F5IGZvciB0ZXN0cyB0byBrbm93IGV4YWN0bHkgd2hpY2ggZXZlbnQgd2FzIHByb2Nlc3NlZFxuICAgICAgICAgICAgICAgIGlmIChERUJVRyAmJiBldmVudCkgZWxlbWVudFsnX2tvX3RleHRJbnB1dFByb2Nlc3NlZEV2ZW50J10gPSBldmVudC50eXBlO1xuICAgICAgICAgICAgICAgIHByZXZpb3VzRWxlbWVudFZhbHVlID0gZWxlbWVudFZhbHVlO1xuICAgICAgICAgICAgICAgIGtvLmV4cHJlc3Npb25SZXdyaXRpbmcud3JpdGVWYWx1ZVRvUHJvcGVydHkodmFsdWVBY2Nlc3NvcigpLCBhbGxCaW5kaW5ncywgJ3RleHRJbnB1dCcsIGVsZW1lbnRWYWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIGRlZmVyVXBkYXRlTW9kZWwgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgIGlmICghdGltZW91dEhhbmRsZSkge1xuICAgICAgICAgICAgICAgIC8vIFRoZSBlbGVtZW50VmFsdWVCZWZvcmVFdmVudCB2YXJpYWJsZSBpcyBzZXQgKm9ubHkqIGR1cmluZyB0aGUgYnJpZWYgZ2FwIGJldHdlZW4gYW5cbiAgICAgICAgICAgICAgICAvLyBldmVudCBmaXJpbmcgYW5kIHRoZSB1cGRhdGVNb2RlbCBmdW5jdGlvbiBydW5uaW5nLiBUaGlzIGFsbG93cyB1cyB0byBpZ25vcmUgbW9kZWxcbiAgICAgICAgICAgICAgICAvLyB1cGRhdGVzIHRoYXQgYXJlIGZyb20gdGhlIHByZXZpb3VzIHN0YXRlIG9mIHRoZSBlbGVtZW50LCB1c3VhbGx5IGR1ZSB0byB0ZWNobmlxdWVzXG4gICAgICAgICAgICAgICAgLy8gc3VjaCBhcyByYXRlTGltaXQuIFN1Y2ggdXBkYXRlcywgaWYgbm90IGlnbm9yZWQsIGNhbiBjYXVzZSBrZXlzdHJva2VzIHRvIGJlIGxvc3QuXG4gICAgICAgICAgICAgICAgZWxlbWVudFZhbHVlQmVmb3JlRXZlbnQgPSBlbGVtZW50LnZhbHVlO1xuICAgICAgICAgICAgICAgIHZhciBoYW5kbGVyID0gREVCVUcgPyB1cGRhdGVNb2RlbC5iaW5kKGVsZW1lbnQsIHt0eXBlOiBldmVudC50eXBlfSkgOiB1cGRhdGVNb2RlbDtcbiAgICAgICAgICAgICAgICB0aW1lb3V0SGFuZGxlID0ga28udXRpbHMuc2V0VGltZW91dChoYW5kbGVyLCA0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICAvLyBJRTkgd2lsbCBtZXNzIHVwIHRoZSBET00gaWYgeW91IGhhbmRsZSBldmVudHMgc3luY2hyb25vdXNseSB3aGljaCByZXN1bHRzIGluIERPTSBjaGFuZ2VzIChzdWNoIGFzIG90aGVyIGJpbmRpbmdzKTtcbiAgICAgICAgLy8gc28gd2UnbGwgbWFrZSBzdXJlIGFsbCB1cGRhdGVzIGFyZSBhc3luY2hyb25vdXNcbiAgICAgICAgdmFyIGllVXBkYXRlTW9kZWwgPSBrby51dGlscy5pZVZlcnNpb24gPT0gOSA/IGRlZmVyVXBkYXRlTW9kZWwgOiB1cGRhdGVNb2RlbDtcblxuICAgICAgICB2YXIgdXBkYXRlVmlldyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBtb2RlbFZhbHVlID0ga28udXRpbHMudW53cmFwT2JzZXJ2YWJsZSh2YWx1ZUFjY2Vzc29yKCkpO1xuXG4gICAgICAgICAgICBpZiAobW9kZWxWYWx1ZSA9PT0gbnVsbCB8fCBtb2RlbFZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBtb2RlbFZhbHVlID0gJyc7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChlbGVtZW50VmFsdWVCZWZvcmVFdmVudCAhPT0gdW5kZWZpbmVkICYmIG1vZGVsVmFsdWUgPT09IGVsZW1lbnRWYWx1ZUJlZm9yZUV2ZW50KSB7XG4gICAgICAgICAgICAgICAga28udXRpbHMuc2V0VGltZW91dCh1cGRhdGVWaWV3LCA0KTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFVwZGF0ZSB0aGUgZWxlbWVudCBvbmx5IGlmIHRoZSBlbGVtZW50IGFuZCBtb2RlbCBhcmUgZGlmZmVyZW50LiBPbiBzb21lIGJyb3dzZXJzLCB1cGRhdGluZyB0aGUgdmFsdWVcbiAgICAgICAgICAgIC8vIHdpbGwgbW92ZSB0aGUgY3Vyc29yIHRvIHRoZSBlbmQgb2YgdGhlIGlucHV0LCB3aGljaCB3b3VsZCBiZSBiYWQgd2hpbGUgdGhlIHVzZXIgaXMgdHlwaW5nLlxuICAgICAgICAgICAgaWYgKGVsZW1lbnQudmFsdWUgIT09IG1vZGVsVmFsdWUpIHtcbiAgICAgICAgICAgICAgICBwcmV2aW91c0VsZW1lbnRWYWx1ZSA9IG1vZGVsVmFsdWU7ICAvLyBNYWtlIHN1cmUgd2UgaWdub3JlIGV2ZW50cyAocHJvcGVydHljaGFuZ2UpIHRoYXQgcmVzdWx0IGZyb20gdXBkYXRpbmcgdGhlIHZhbHVlXG4gICAgICAgICAgICAgICAgZWxlbWVudC52YWx1ZSA9IG1vZGVsVmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIG9uRXZlbnQgPSBmdW5jdGlvbiAoZXZlbnQsIGhhbmRsZXIpIHtcbiAgICAgICAgICAgIGtvLnV0aWxzLnJlZ2lzdGVyRXZlbnRIYW5kbGVyKGVsZW1lbnQsIGV2ZW50LCBoYW5kbGVyKTtcbiAgICAgICAgfTtcblxuICAgICAgICBpZiAoREVCVUcgJiYga28uYmluZGluZ0hhbmRsZXJzWyd0ZXh0SW5wdXQnXVsnX2ZvcmNlVXBkYXRlT24nXSkge1xuICAgICAgICAgICAgLy8gUHJvdmlkZSBhIHdheSBmb3IgdGVzdHMgdG8gc3BlY2lmeSBleGFjdGx5IHdoaWNoIGV2ZW50cyBhcmUgYm91bmRcbiAgICAgICAgICAgIGtvLnV0aWxzLmFycmF5Rm9yRWFjaChrby5iaW5kaW5nSGFuZGxlcnNbJ3RleHRJbnB1dCddWydfZm9yY2VVcGRhdGVPbiddLCBmdW5jdGlvbihldmVudE5hbWUpIHtcbiAgICAgICAgICAgICAgICBpZiAoZXZlbnROYW1lLnNsaWNlKDAsNSkgPT0gJ2FmdGVyJykge1xuICAgICAgICAgICAgICAgICAgICBvbkV2ZW50KGV2ZW50TmFtZS5zbGljZSg1KSwgZGVmZXJVcGRhdGVNb2RlbCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgb25FdmVudChldmVudE5hbWUsIHVwZGF0ZU1vZGVsKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChrby51dGlscy5pZVZlcnNpb24gPCAxMCkge1xuICAgICAgICAgICAgICAgIC8vIEludGVybmV0IEV4cGxvcmVyIDw9IDggZG9lc24ndCBzdXBwb3J0IHRoZSAnaW5wdXQnIGV2ZW50LCBidXQgZG9lcyBpbmNsdWRlICdwcm9wZXJ0eWNoYW5nZScgdGhhdCBmaXJlcyB3aGVuZXZlclxuICAgICAgICAgICAgICAgIC8vIGFueSBwcm9wZXJ0eSBvZiBhbiBlbGVtZW50IGNoYW5nZXMuIFVubGlrZSAnaW5wdXQnLCBpdCBhbHNvIGZpcmVzIGlmIGEgcHJvcGVydHkgaXMgY2hhbmdlZCBmcm9tIEphdmFTY3JpcHQgY29kZSxcbiAgICAgICAgICAgICAgICAvLyBidXQgdGhhdCdzIGFuIGFjY2VwdGFibGUgY29tcHJvbWlzZSBmb3IgdGhpcyBiaW5kaW5nLiBJRSA5IGRvZXMgc3VwcG9ydCAnaW5wdXQnLCBidXQgc2luY2UgaXQgZG9lc24ndCBmaXJlIGl0XG4gICAgICAgICAgICAgICAgLy8gd2hlbiB1c2luZyBhdXRvY29tcGxldGUsIHdlJ2xsIHVzZSAncHJvcGVydHljaGFuZ2UnIGZvciBpdCBhbHNvLlxuICAgICAgICAgICAgICAgIG9uRXZlbnQoJ3Byb3BlcnR5Y2hhbmdlJywgZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGV2ZW50LnByb3BlcnR5TmFtZSA9PT0gJ3ZhbHVlJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWVVcGRhdGVNb2RlbChldmVudCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIGlmIChrby51dGlscy5pZVZlcnNpb24gPT0gOCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBJRSA4IGhhcyBhIGJ1ZyB3aGVyZSBpdCBmYWlscyB0byBmaXJlICdwcm9wZXJ0eWNoYW5nZScgb24gdGhlIGZpcnN0IHVwZGF0ZSBmb2xsb3dpbmcgYSB2YWx1ZSBjaGFuZ2UgZnJvbVxuICAgICAgICAgICAgICAgICAgICAvLyBKYXZhU2NyaXB0IGNvZGUuIEl0IGFsc28gZG9lc24ndCBmaXJlIGlmIHlvdSBjbGVhciB0aGUgZW50aXJlIHZhbHVlLiBUbyBmaXggdGhpcywgd2UgYmluZCB0byB0aGUgZm9sbG93aW5nXG4gICAgICAgICAgICAgICAgICAgIC8vIGV2ZW50cyB0b28uXG4gICAgICAgICAgICAgICAgICAgIG9uRXZlbnQoJ2tleXVwJywgdXBkYXRlTW9kZWwpOyAgICAgIC8vIEEgc2luZ2xlIGtleXN0b2tlXG4gICAgICAgICAgICAgICAgICAgIG9uRXZlbnQoJ2tleWRvd24nLCB1cGRhdGVNb2RlbCk7ICAgIC8vIFRoZSBmaXJzdCBjaGFyYWN0ZXIgd2hlbiBhIGtleSBpcyBoZWxkIGRvd25cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGtvLnV0aWxzLmllVmVyc2lvbiA+PSA4KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEludGVybmV0IEV4cGxvcmVyIDkgZG9lc24ndCBmaXJlIHRoZSAnaW5wdXQnIGV2ZW50IHdoZW4gZGVsZXRpbmcgdGV4dCwgaW5jbHVkaW5nIHVzaW5nXG4gICAgICAgICAgICAgICAgICAgIC8vIHRoZSBiYWNrc3BhY2UsIGRlbGV0ZSwgb3IgY3RybC14IGtleXMsIGNsaWNraW5nIHRoZSAneCcgdG8gY2xlYXIgdGhlIGlucHV0LCBkcmFnZ2luZyB0ZXh0XG4gICAgICAgICAgICAgICAgICAgIC8vIG91dCBvZiB0aGUgZmllbGQsIGFuZCBjdXR0aW5nIG9yIGRlbGV0aW5nIHRleHQgdXNpbmcgdGhlIGNvbnRleHQgbWVudS4gJ3NlbGVjdGlvbmNoYW5nZSdcbiAgICAgICAgICAgICAgICAgICAgLy8gY2FuIGRldGVjdCBhbGwgb2YgdGhvc2UgZXhjZXB0IGRyYWdnaW5nIHRleHQgb3V0IG9mIHRoZSBmaWVsZCwgZm9yIHdoaWNoIHdlIHVzZSAnZHJhZ2VuZCcuXG4gICAgICAgICAgICAgICAgICAgIC8vIFRoZXNlIGFyZSBhbHNvIG5lZWRlZCBpbiBJRTggYmVjYXVzZSBvZiB0aGUgYnVnIGRlc2NyaWJlZCBhYm92ZS5cbiAgICAgICAgICAgICAgICAgICAgcmVnaXN0ZXJGb3JTZWxlY3Rpb25DaGFuZ2VFdmVudChlbGVtZW50LCBpZVVwZGF0ZU1vZGVsKTsgIC8vICdzZWxlY3Rpb25jaGFuZ2UnIGNvdmVycyBjdXQsIHBhc3RlLCBkcm9wLCBkZWxldGUsIGV0Yy5cbiAgICAgICAgICAgICAgICAgICAgb25FdmVudCgnZHJhZ2VuZCcsIGRlZmVyVXBkYXRlTW9kZWwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gQWxsIG90aGVyIHN1cHBvcnRlZCBicm93c2VycyBzdXBwb3J0IHRoZSAnaW5wdXQnIGV2ZW50LCB3aGljaCBmaXJlcyB3aGVuZXZlciB0aGUgY29udGVudCBvZiB0aGUgZWxlbWVudCBpcyBjaGFuZ2VkXG4gICAgICAgICAgICAgICAgLy8gdGhyb3VnaCB0aGUgdXNlciBpbnRlcmZhY2UuXG4gICAgICAgICAgICAgICAgb25FdmVudCgnaW5wdXQnLCB1cGRhdGVNb2RlbCk7XG5cbiAgICAgICAgICAgICAgICBpZiAoc2FmYXJpVmVyc2lvbiA8IDUgJiYga28udXRpbHMudGFnTmFtZUxvd2VyKGVsZW1lbnQpID09PSBcInRleHRhcmVhXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gU2FmYXJpIDw1IGRvZXNuJ3QgZmlyZSB0aGUgJ2lucHV0JyBldmVudCBmb3IgPHRleHRhcmVhPiBlbGVtZW50cyAoaXQgZG9lcyBmaXJlICd0ZXh0SW5wdXQnXG4gICAgICAgICAgICAgICAgICAgIC8vIGJ1dCBvbmx5IHdoZW4gdHlwaW5nKS4gU28gd2UnbGwganVzdCBjYXRjaCBhcyBtdWNoIGFzIHdlIGNhbiB3aXRoIGtleWRvd24sIGN1dCwgYW5kIHBhc3RlLlxuICAgICAgICAgICAgICAgICAgICBvbkV2ZW50KCdrZXlkb3duJywgZGVmZXJVcGRhdGVNb2RlbCk7XG4gICAgICAgICAgICAgICAgICAgIG9uRXZlbnQoJ3Bhc3RlJywgZGVmZXJVcGRhdGVNb2RlbCk7XG4gICAgICAgICAgICAgICAgICAgIG9uRXZlbnQoJ2N1dCcsIGRlZmVyVXBkYXRlTW9kZWwpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAob3BlcmFWZXJzaW9uIDwgMTEpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gT3BlcmEgMTAgZG9lc24ndCBhbHdheXMgZmlyZSB0aGUgJ2lucHV0JyBldmVudCBmb3IgY3V0LCBwYXN0ZSwgdW5kbyAmIGRyb3Agb3BlcmF0aW9ucy5cbiAgICAgICAgICAgICAgICAgICAgLy8gV2UgY2FuIHRyeSB0byBjYXRjaCBzb21lIG9mIHRob3NlIHVzaW5nICdrZXlkb3duJy5cbiAgICAgICAgICAgICAgICAgICAgb25FdmVudCgna2V5ZG93bicsIGRlZmVyVXBkYXRlTW9kZWwpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZmlyZWZveFZlcnNpb24gPCA0LjApIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gRmlyZWZveCA8PSAzLjYgZG9lc24ndCBmaXJlIHRoZSAnaW5wdXQnIGV2ZW50IHdoZW4gdGV4dCBpcyBmaWxsZWQgaW4gdGhyb3VnaCBhdXRvY29tcGxldGVcbiAgICAgICAgICAgICAgICAgICAgb25FdmVudCgnRE9NQXV0b0NvbXBsZXRlJywgdXBkYXRlTW9kZWwpO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIEZpcmVmb3ggPD0zLjUgZG9lc24ndCBmaXJlIHRoZSAnaW5wdXQnIGV2ZW50IHdoZW4gdGV4dCBpcyBkcm9wcGVkIGludG8gdGhlIGlucHV0LlxuICAgICAgICAgICAgICAgICAgICBvbkV2ZW50KCdkcmFnZHJvcCcsIHVwZGF0ZU1vZGVsKTsgICAgICAgLy8gPDMuNVxuICAgICAgICAgICAgICAgICAgICBvbkV2ZW50KCdkcm9wJywgdXBkYXRlTW9kZWwpOyAgICAgICAgICAgLy8gMy41XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gQmluZCB0byB0aGUgY2hhbmdlIGV2ZW50IHNvIHRoYXQgd2UgY2FuIGNhdGNoIHByb2dyYW1tYXRpYyB1cGRhdGVzIG9mIHRoZSB2YWx1ZSB0aGF0IGZpcmUgdGhpcyBldmVudC5cbiAgICAgICAgb25FdmVudCgnY2hhbmdlJywgdXBkYXRlTW9kZWwpO1xuXG4gICAgICAgIGtvLmNvbXB1dGVkKHVwZGF0ZVZpZXcsIG51bGwsIHsgZGlzcG9zZVdoZW5Ob2RlSXNSZW1vdmVkOiBlbGVtZW50IH0pO1xuICAgIH1cbn07XG5rby5leHByZXNzaW9uUmV3cml0aW5nLnR3b1dheUJpbmRpbmdzWyd0ZXh0SW5wdXQnXSA9IHRydWU7XG5cbi8vIHRleHRpbnB1dCBpcyBhbiBhbGlhcyBmb3IgdGV4dElucHV0XG5rby5iaW5kaW5nSGFuZGxlcnNbJ3RleHRpbnB1dCddID0ge1xuICAgIC8vIHByZXByb2Nlc3MgaXMgdGhlIG9ubHkgd2F5IHRvIHNldCB1cCBhIGZ1bGwgYWxpYXNcbiAgICAncHJlcHJvY2Vzcyc6IGZ1bmN0aW9uICh2YWx1ZSwgbmFtZSwgYWRkQmluZGluZykge1xuICAgICAgICBhZGRCaW5kaW5nKCd0ZXh0SW5wdXQnLCB2YWx1ZSk7XG4gICAgfVxufTtcblxufSkoKTtrby5iaW5kaW5nSGFuZGxlcnNbJ3VuaXF1ZU5hbWUnXSA9IHtcbiAgICAnaW5pdCc6IGZ1bmN0aW9uIChlbGVtZW50LCB2YWx1ZUFjY2Vzc29yKSB7XG4gICAgICAgIGlmICh2YWx1ZUFjY2Vzc29yKCkpIHtcbiAgICAgICAgICAgIHZhciBuYW1lID0gXCJrb191bmlxdWVfXCIgKyAoKytrby5iaW5kaW5nSGFuZGxlcnNbJ3VuaXF1ZU5hbWUnXS5jdXJyZW50SW5kZXgpO1xuICAgICAgICAgICAga28udXRpbHMuc2V0RWxlbWVudE5hbWUoZWxlbWVudCwgbmFtZSk7XG4gICAgICAgIH1cbiAgICB9XG59O1xua28uYmluZGluZ0hhbmRsZXJzWyd1bmlxdWVOYW1lJ10uY3VycmVudEluZGV4ID0gMDtcbmtvLmJpbmRpbmdIYW5kbGVyc1sndmFsdWUnXSA9IHtcbiAgICAnYWZ0ZXInOiBbJ29wdGlvbnMnLCAnZm9yZWFjaCddLFxuICAgICdpbml0JzogZnVuY3Rpb24gKGVsZW1lbnQsIHZhbHVlQWNjZXNzb3IsIGFsbEJpbmRpbmdzKSB7XG4gICAgICAgIC8vIElmIHRoZSB2YWx1ZSBiaW5kaW5nIGlzIHBsYWNlZCBvbiBhIHJhZGlvL2NoZWNrYm94LCB0aGVuIGp1c3QgcGFzcyB0aHJvdWdoIHRvIGNoZWNrZWRWYWx1ZSBhbmQgcXVpdFxuICAgICAgICBpZiAoZWxlbWVudC50YWdOYW1lLnRvTG93ZXJDYXNlKCkgPT0gXCJpbnB1dFwiICYmIChlbGVtZW50LnR5cGUgPT0gXCJjaGVja2JveFwiIHx8IGVsZW1lbnQudHlwZSA9PSBcInJhZGlvXCIpKSB7XG4gICAgICAgICAgICBrby5hcHBseUJpbmRpbmdBY2Nlc3NvcnNUb05vZGUoZWxlbWVudCwgeyAnY2hlY2tlZFZhbHVlJzogdmFsdWVBY2Nlc3NvciB9KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEFsd2F5cyBjYXRjaCBcImNoYW5nZVwiIGV2ZW50OyBwb3NzaWJseSBvdGhlciBldmVudHMgdG9vIGlmIGFza2VkXG4gICAgICAgIHZhciBldmVudHNUb0NhdGNoID0gW1wiY2hhbmdlXCJdO1xuICAgICAgICB2YXIgcmVxdWVzdGVkRXZlbnRzVG9DYXRjaCA9IGFsbEJpbmRpbmdzLmdldChcInZhbHVlVXBkYXRlXCIpO1xuICAgICAgICB2YXIgcHJvcGVydHlDaGFuZ2VkRmlyZWQgPSBmYWxzZTtcbiAgICAgICAgdmFyIGVsZW1lbnRWYWx1ZUJlZm9yZUV2ZW50ID0gbnVsbDtcblxuICAgICAgICBpZiAocmVxdWVzdGVkRXZlbnRzVG9DYXRjaCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiByZXF1ZXN0ZWRFdmVudHNUb0NhdGNoID09IFwic3RyaW5nXCIpIC8vIEFsbG93IGJvdGggaW5kaXZpZHVhbCBldmVudCBuYW1lcywgYW5kIGFycmF5cyBvZiBldmVudCBuYW1lc1xuICAgICAgICAgICAgICAgIHJlcXVlc3RlZEV2ZW50c1RvQ2F0Y2ggPSBbcmVxdWVzdGVkRXZlbnRzVG9DYXRjaF07XG4gICAgICAgICAgICBrby51dGlscy5hcnJheVB1c2hBbGwoZXZlbnRzVG9DYXRjaCwgcmVxdWVzdGVkRXZlbnRzVG9DYXRjaCk7XG4gICAgICAgICAgICBldmVudHNUb0NhdGNoID0ga28udXRpbHMuYXJyYXlHZXREaXN0aW5jdFZhbHVlcyhldmVudHNUb0NhdGNoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB2YWx1ZVVwZGF0ZUhhbmRsZXIgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGVsZW1lbnRWYWx1ZUJlZm9yZUV2ZW50ID0gbnVsbDtcbiAgICAgICAgICAgIHByb3BlcnR5Q2hhbmdlZEZpcmVkID0gZmFsc2U7XG4gICAgICAgICAgICB2YXIgbW9kZWxWYWx1ZSA9IHZhbHVlQWNjZXNzb3IoKTtcbiAgICAgICAgICAgIHZhciBlbGVtZW50VmFsdWUgPSBrby5zZWxlY3RFeHRlbnNpb25zLnJlYWRWYWx1ZShlbGVtZW50KTtcbiAgICAgICAgICAgIGtvLmV4cHJlc3Npb25SZXdyaXRpbmcud3JpdGVWYWx1ZVRvUHJvcGVydHkobW9kZWxWYWx1ZSwgYWxsQmluZGluZ3MsICd2YWx1ZScsIGVsZW1lbnRWYWx1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBXb3JrYXJvdW5kIGZvciBodHRwczovL2dpdGh1Yi5jb20vU3RldmVTYW5kZXJzb24va25vY2tvdXQvaXNzdWVzLzEyMlxuICAgICAgICAvLyBJRSBkb2Vzbid0IGZpcmUgXCJjaGFuZ2VcIiBldmVudHMgb24gdGV4dGJveGVzIGlmIHRoZSB1c2VyIHNlbGVjdHMgYSB2YWx1ZSBmcm9tIGl0cyBhdXRvY29tcGxldGUgbGlzdFxuICAgICAgICB2YXIgaWVBdXRvQ29tcGxldGVIYWNrTmVlZGVkID0ga28udXRpbHMuaWVWZXJzaW9uICYmIGVsZW1lbnQudGFnTmFtZS50b0xvd2VyQ2FzZSgpID09IFwiaW5wdXRcIiAmJiBlbGVtZW50LnR5cGUgPT0gXCJ0ZXh0XCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICYmIGVsZW1lbnQuYXV0b2NvbXBsZXRlICE9IFwib2ZmXCIgJiYgKCFlbGVtZW50LmZvcm0gfHwgZWxlbWVudC5mb3JtLmF1dG9jb21wbGV0ZSAhPSBcIm9mZlwiKTtcbiAgICAgICAgaWYgKGllQXV0b0NvbXBsZXRlSGFja05lZWRlZCAmJiBrby51dGlscy5hcnJheUluZGV4T2YoZXZlbnRzVG9DYXRjaCwgXCJwcm9wZXJ0eWNoYW5nZVwiKSA9PSAtMSkge1xuICAgICAgICAgICAga28udXRpbHMucmVnaXN0ZXJFdmVudEhhbmRsZXIoZWxlbWVudCwgXCJwcm9wZXJ0eWNoYW5nZVwiLCBmdW5jdGlvbiAoKSB7IHByb3BlcnR5Q2hhbmdlZEZpcmVkID0gdHJ1ZSB9KTtcbiAgICAgICAgICAgIGtvLnV0aWxzLnJlZ2lzdGVyRXZlbnRIYW5kbGVyKGVsZW1lbnQsIFwiZm9jdXNcIiwgZnVuY3Rpb24gKCkgeyBwcm9wZXJ0eUNoYW5nZWRGaXJlZCA9IGZhbHNlIH0pO1xuICAgICAgICAgICAga28udXRpbHMucmVnaXN0ZXJFdmVudEhhbmRsZXIoZWxlbWVudCwgXCJibHVyXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGlmIChwcm9wZXJ0eUNoYW5nZWRGaXJlZCkge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZVVwZGF0ZUhhbmRsZXIoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGtvLnV0aWxzLmFycmF5Rm9yRWFjaChldmVudHNUb0NhdGNoLCBmdW5jdGlvbihldmVudE5hbWUpIHtcbiAgICAgICAgICAgIC8vIFRoZSBzeW50YXggXCJhZnRlcjxldmVudG5hbWU+XCIgbWVhbnMgXCJydW4gdGhlIGhhbmRsZXIgYXN5bmNocm9ub3VzbHkgYWZ0ZXIgdGhlIGV2ZW50XCJcbiAgICAgICAgICAgIC8vIFRoaXMgaXMgdXNlZnVsLCBmb3IgZXhhbXBsZSwgdG8gY2F0Y2ggXCJrZXlkb3duXCIgZXZlbnRzIGFmdGVyIHRoZSBicm93c2VyIGhhcyB1cGRhdGVkIHRoZSBjb250cm9sXG4gICAgICAgICAgICAvLyAob3RoZXJ3aXNlLCBrby5zZWxlY3RFeHRlbnNpb25zLnJlYWRWYWx1ZSh0aGlzKSB3aWxsIHJlY2VpdmUgdGhlIGNvbnRyb2wncyB2YWx1ZSAqYmVmb3JlKiB0aGUga2V5IGV2ZW50KVxuICAgICAgICAgICAgdmFyIGhhbmRsZXIgPSB2YWx1ZVVwZGF0ZUhhbmRsZXI7XG4gICAgICAgICAgICBpZiAoa28udXRpbHMuc3RyaW5nU3RhcnRzV2l0aChldmVudE5hbWUsIFwiYWZ0ZXJcIikpIHtcbiAgICAgICAgICAgICAgICBoYW5kbGVyID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRoZSBlbGVtZW50VmFsdWVCZWZvcmVFdmVudCB2YXJpYWJsZSBpcyBub24tbnVsbCAqb25seSogZHVyaW5nIHRoZSBicmllZiBnYXAgYmV0d2VlblxuICAgICAgICAgICAgICAgICAgICAvLyBhIGtleVggZXZlbnQgZmlyaW5nIGFuZCB0aGUgdmFsdWVVcGRhdGVIYW5kbGVyIHJ1bm5pbmcsIHdoaWNoIGlzIHNjaGVkdWxlZCB0byBoYXBwZW5cbiAgICAgICAgICAgICAgICAgICAgLy8gYXQgdGhlIGVhcmxpZXN0IGFzeW5jaHJvbm91cyBvcHBvcnR1bml0eS4gV2Ugc3RvcmUgdGhpcyB0ZW1wb3JhcnkgaW5mb3JtYXRpb24gc28gdGhhdFxuICAgICAgICAgICAgICAgICAgICAvLyBpZiwgYmV0d2VlbiBrZXlYIGFuZCB2YWx1ZVVwZGF0ZUhhbmRsZXIsIHRoZSB1bmRlcmx5aW5nIG1vZGVsIHZhbHVlIGNoYW5nZXMgc2VwYXJhdGVseSxcbiAgICAgICAgICAgICAgICAgICAgLy8gd2UgY2FuIG92ZXJ3cml0ZSB0aGF0IG1vZGVsIHZhbHVlIGNoYW5nZSB3aXRoIHRoZSB2YWx1ZSB0aGUgdXNlciBqdXN0IHR5cGVkLiBPdGhlcndpc2UsXG4gICAgICAgICAgICAgICAgICAgIC8vIHRlY2huaXF1ZXMgbGlrZSByYXRlTGltaXQgY2FuIHRyaWdnZXIgbW9kZWwgY2hhbmdlcyBhdCBjcml0aWNhbCBtb21lbnRzIHRoYXQgd2lsbFxuICAgICAgICAgICAgICAgICAgICAvLyBvdmVycmlkZSB0aGUgdXNlcidzIGlucHV0cywgY2F1c2luZyBrZXlzdHJva2VzIHRvIGJlIGxvc3QuXG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnRWYWx1ZUJlZm9yZUV2ZW50ID0ga28uc2VsZWN0RXh0ZW5zaW9ucy5yZWFkVmFsdWUoZWxlbWVudCk7XG4gICAgICAgICAgICAgICAgICAgIGtvLnV0aWxzLnNldFRpbWVvdXQodmFsdWVVcGRhdGVIYW5kbGVyLCAwKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGV2ZW50TmFtZSA9IGV2ZW50TmFtZS5zdWJzdHJpbmcoXCJhZnRlclwiLmxlbmd0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBrby51dGlscy5yZWdpc3RlckV2ZW50SGFuZGxlcihlbGVtZW50LCBldmVudE5hbWUsIGhhbmRsZXIpO1xuICAgICAgICB9KTtcblxuICAgICAgICB2YXIgdXBkYXRlRnJvbU1vZGVsID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIG5ld1ZhbHVlID0ga28udXRpbHMudW53cmFwT2JzZXJ2YWJsZSh2YWx1ZUFjY2Vzc29yKCkpO1xuICAgICAgICAgICAgdmFyIGVsZW1lbnRWYWx1ZSA9IGtvLnNlbGVjdEV4dGVuc2lvbnMucmVhZFZhbHVlKGVsZW1lbnQpO1xuXG4gICAgICAgICAgICBpZiAoZWxlbWVudFZhbHVlQmVmb3JlRXZlbnQgIT09IG51bGwgJiYgbmV3VmFsdWUgPT09IGVsZW1lbnRWYWx1ZUJlZm9yZUV2ZW50KSB7XG4gICAgICAgICAgICAgICAga28udXRpbHMuc2V0VGltZW91dCh1cGRhdGVGcm9tTW9kZWwsIDApO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHZhbHVlSGFzQ2hhbmdlZCA9IChuZXdWYWx1ZSAhPT0gZWxlbWVudFZhbHVlKTtcblxuICAgICAgICAgICAgaWYgKHZhbHVlSGFzQ2hhbmdlZCkge1xuICAgICAgICAgICAgICAgIGlmIChrby51dGlscy50YWdOYW1lTG93ZXIoZWxlbWVudCkgPT09IFwic2VsZWN0XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGFsbG93VW5zZXQgPSBhbGxCaW5kaW5ncy5nZXQoJ3ZhbHVlQWxsb3dVbnNldCcpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgYXBwbHlWYWx1ZUFjdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGtvLnNlbGVjdEV4dGVuc2lvbnMud3JpdGVWYWx1ZShlbGVtZW50LCBuZXdWYWx1ZSwgYWxsb3dVbnNldCk7XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIGFwcGx5VmFsdWVBY3Rpb24oKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoIWFsbG93VW5zZXQgJiYgbmV3VmFsdWUgIT09IGtvLnNlbGVjdEV4dGVuc2lvbnMucmVhZFZhbHVlKGVsZW1lbnQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiB5b3UgdHJ5IHRvIHNldCBhIG1vZGVsIHZhbHVlIHRoYXQgY2FuJ3QgYmUgcmVwcmVzZW50ZWQgaW4gYW4gYWxyZWFkeS1wb3B1bGF0ZWQgZHJvcGRvd24sIHJlamVjdCB0aGF0IGNoYW5nZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGJlY2F1c2UgeW91J3JlIG5vdCBhbGxvd2VkIHRvIGhhdmUgYSBtb2RlbCB2YWx1ZSB0aGF0IGRpc2FncmVlcyB3aXRoIGEgdmlzaWJsZSBVSSBzZWxlY3Rpb24uXG4gICAgICAgICAgICAgICAgICAgICAgICBrby5kZXBlbmRlbmN5RGV0ZWN0aW9uLmlnbm9yZShrby51dGlscy50cmlnZ2VyRXZlbnQsIG51bGwsIFtlbGVtZW50LCBcImNoYW5nZVwiXSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBXb3JrYXJvdW5kIGZvciBJRTYgYnVnOiBJdCB3b24ndCByZWxpYWJseSBhcHBseSB2YWx1ZXMgdG8gU0VMRUNUIG5vZGVzIGR1cmluZyB0aGUgc2FtZSBleGVjdXRpb24gdGhyZWFkXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyByaWdodCBhZnRlciB5b3UndmUgY2hhbmdlZCB0aGUgc2V0IG9mIE9QVElPTiBub2RlcyBvbiBpdC4gU28gZm9yIHRoYXQgbm9kZSB0eXBlLCB3ZSdsbCBzY2hlZHVsZSBhIHNlY29uZCB0aHJlYWRcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRvIGFwcGx5IHRoZSB2YWx1ZSBhcyB3ZWxsLlxuICAgICAgICAgICAgICAgICAgICAgICAga28udXRpbHMuc2V0VGltZW91dChhcHBseVZhbHVlQWN0aW9uLCAwKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGtvLnNlbGVjdEV4dGVuc2lvbnMud3JpdGVWYWx1ZShlbGVtZW50LCBuZXdWYWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIGtvLmNvbXB1dGVkKHVwZGF0ZUZyb21Nb2RlbCwgbnVsbCwgeyBkaXNwb3NlV2hlbk5vZGVJc1JlbW92ZWQ6IGVsZW1lbnQgfSk7XG4gICAgfSxcbiAgICAndXBkYXRlJzogZnVuY3Rpb24oKSB7fSAvLyBLZWVwIGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eSB3aXRoIGNvZGUgdGhhdCBtYXkgaGF2ZSB3cmFwcGVkIHZhbHVlIGJpbmRpbmdcbn07XG5rby5leHByZXNzaW9uUmV3cml0aW5nLnR3b1dheUJpbmRpbmdzWyd2YWx1ZSddID0gdHJ1ZTtcbmtvLmJpbmRpbmdIYW5kbGVyc1sndmlzaWJsZSddID0ge1xuICAgICd1cGRhdGUnOiBmdW5jdGlvbiAoZWxlbWVudCwgdmFsdWVBY2Nlc3Nvcikge1xuICAgICAgICB2YXIgdmFsdWUgPSBrby51dGlscy51bndyYXBPYnNlcnZhYmxlKHZhbHVlQWNjZXNzb3IoKSk7XG4gICAgICAgIHZhciBpc0N1cnJlbnRseVZpc2libGUgPSAhKGVsZW1lbnQuc3R5bGUuZGlzcGxheSA9PSBcIm5vbmVcIik7XG4gICAgICAgIGlmICh2YWx1ZSAmJiAhaXNDdXJyZW50bHlWaXNpYmxlKVxuICAgICAgICAgICAgZWxlbWVudC5zdHlsZS5kaXNwbGF5ID0gXCJcIjtcbiAgICAgICAgZWxzZSBpZiAoKCF2YWx1ZSkgJiYgaXNDdXJyZW50bHlWaXNpYmxlKVxuICAgICAgICAgICAgZWxlbWVudC5zdHlsZS5kaXNwbGF5ID0gXCJub25lXCI7XG4gICAgfVxufTtcbi8vICdjbGljaycgaXMganVzdCBhIHNob3J0aGFuZCBmb3IgdGhlIHVzdWFsIGZ1bGwtbGVuZ3RoIGV2ZW50OntjbGljazpoYW5kbGVyfVxubWFrZUV2ZW50SGFuZGxlclNob3J0Y3V0KCdjbGljaycpO1xuLy8gSWYgeW91IHdhbnQgdG8gbWFrZSBhIGN1c3RvbSB0ZW1wbGF0ZSBlbmdpbmUsXG4vL1xuLy8gWzFdIEluaGVyaXQgZnJvbSB0aGlzIGNsYXNzIChsaWtlIGtvLm5hdGl2ZVRlbXBsYXRlRW5naW5lIGRvZXMpXG4vLyBbMl0gT3ZlcnJpZGUgJ3JlbmRlclRlbXBsYXRlU291cmNlJywgc3VwcGx5aW5nIGEgZnVuY3Rpb24gd2l0aCB0aGlzIHNpZ25hdHVyZTpcbi8vXG4vLyAgICAgICAgZnVuY3Rpb24gKHRlbXBsYXRlU291cmNlLCBiaW5kaW5nQ29udGV4dCwgb3B0aW9ucykge1xuLy8gICAgICAgICAgICAvLyAtIHRlbXBsYXRlU291cmNlLnRleHQoKSBpcyB0aGUgdGV4dCBvZiB0aGUgdGVtcGxhdGUgeW91IHNob3VsZCByZW5kZXJcbi8vICAgICAgICAgICAgLy8gLSBiaW5kaW5nQ29udGV4dC4kZGF0YSBpcyB0aGUgZGF0YSB5b3Ugc2hvdWxkIHBhc3MgaW50byB0aGUgdGVtcGxhdGVcbi8vICAgICAgICAgICAgLy8gICAtIHlvdSBtaWdodCBhbHNvIHdhbnQgdG8gbWFrZSBiaW5kaW5nQ29udGV4dC4kcGFyZW50LCBiaW5kaW5nQ29udGV4dC4kcGFyZW50cyxcbi8vICAgICAgICAgICAgLy8gICAgIGFuZCBiaW5kaW5nQ29udGV4dC4kcm9vdCBhdmFpbGFibGUgaW4gdGhlIHRlbXBsYXRlIHRvb1xuLy8gICAgICAgICAgICAvLyAtIG9wdGlvbnMgZ2l2ZXMgeW91IGFjY2VzcyB0byBhbnkgb3RoZXIgcHJvcGVydGllcyBzZXQgb24gXCJkYXRhLWJpbmQ6IHsgdGVtcGxhdGU6IG9wdGlvbnMgfVwiXG4vLyAgICAgICAgICAgIC8vIC0gdGVtcGxhdGVEb2N1bWVudCBpcyB0aGUgZG9jdW1lbnQgb2JqZWN0IG9mIHRoZSB0ZW1wbGF0ZVxuLy8gICAgICAgICAgICAvL1xuLy8gICAgICAgICAgICAvLyBSZXR1cm4gdmFsdWU6IGFuIGFycmF5IG9mIERPTSBub2Rlc1xuLy8gICAgICAgIH1cbi8vXG4vLyBbM10gT3ZlcnJpZGUgJ2NyZWF0ZUphdmFTY3JpcHRFdmFsdWF0b3JCbG9jaycsIHN1cHBseWluZyBhIGZ1bmN0aW9uIHdpdGggdGhpcyBzaWduYXR1cmU6XG4vL1xuLy8gICAgICAgIGZ1bmN0aW9uIChzY3JpcHQpIHtcbi8vICAgICAgICAgICAgLy8gUmV0dXJuIHZhbHVlOiBXaGF0ZXZlciBzeW50YXggbWVhbnMgXCJFdmFsdWF0ZSB0aGUgSmF2YVNjcmlwdCBzdGF0ZW1lbnQgJ3NjcmlwdCcgYW5kIG91dHB1dCB0aGUgcmVzdWx0XCJcbi8vICAgICAgICAgICAgLy8gICAgICAgICAgICAgICBGb3IgZXhhbXBsZSwgdGhlIGpxdWVyeS50bXBsIHRlbXBsYXRlIGVuZ2luZSBjb252ZXJ0cyAnc29tZVNjcmlwdCcgdG8gJyR7IHNvbWVTY3JpcHQgfSdcbi8vICAgICAgICB9XG4vL1xuLy8gICAgIFRoaXMgaXMgb25seSBuZWNlc3NhcnkgaWYgeW91IHdhbnQgdG8gYWxsb3cgZGF0YS1iaW5kIGF0dHJpYnV0ZXMgdG8gcmVmZXJlbmNlIGFyYml0cmFyeSB0ZW1wbGF0ZSB2YXJpYWJsZXMuXG4vLyAgICAgSWYgeW91IGRvbid0IHdhbnQgdG8gYWxsb3cgdGhhdCwgeW91IGNhbiBzZXQgdGhlIHByb3BlcnR5ICdhbGxvd1RlbXBsYXRlUmV3cml0aW5nJyB0byBmYWxzZSAobGlrZSBrby5uYXRpdmVUZW1wbGF0ZUVuZ2luZSBkb2VzKVxuLy8gICAgIGFuZCB0aGVuIHlvdSBkb24ndCBuZWVkIHRvIG92ZXJyaWRlICdjcmVhdGVKYXZhU2NyaXB0RXZhbHVhdG9yQmxvY2snLlxuXG5rby50ZW1wbGF0ZUVuZ2luZSA9IGZ1bmN0aW9uICgpIHsgfTtcblxua28udGVtcGxhdGVFbmdpbmUucHJvdG90eXBlWydyZW5kZXJUZW1wbGF0ZVNvdXJjZSddID0gZnVuY3Rpb24gKHRlbXBsYXRlU291cmNlLCBiaW5kaW5nQ29udGV4dCwgb3B0aW9ucywgdGVtcGxhdGVEb2N1bWVudCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIk92ZXJyaWRlIHJlbmRlclRlbXBsYXRlU291cmNlXCIpO1xufTtcblxua28udGVtcGxhdGVFbmdpbmUucHJvdG90eXBlWydjcmVhdGVKYXZhU2NyaXB0RXZhbHVhdG9yQmxvY2snXSA9IGZ1bmN0aW9uIChzY3JpcHQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJPdmVycmlkZSBjcmVhdGVKYXZhU2NyaXB0RXZhbHVhdG9yQmxvY2tcIik7XG59O1xuXG5rby50ZW1wbGF0ZUVuZ2luZS5wcm90b3R5cGVbJ21ha2VUZW1wbGF0ZVNvdXJjZSddID0gZnVuY3Rpb24odGVtcGxhdGUsIHRlbXBsYXRlRG9jdW1lbnQpIHtcbiAgICAvLyBOYW1lZCB0ZW1wbGF0ZVxuICAgIGlmICh0eXBlb2YgdGVtcGxhdGUgPT0gXCJzdHJpbmdcIikge1xuICAgICAgICB0ZW1wbGF0ZURvY3VtZW50ID0gdGVtcGxhdGVEb2N1bWVudCB8fCBkb2N1bWVudDtcbiAgICAgICAgdmFyIGVsZW0gPSB0ZW1wbGF0ZURvY3VtZW50LmdldEVsZW1lbnRCeUlkKHRlbXBsYXRlKTtcbiAgICAgICAgaWYgKCFlbGVtKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgdGVtcGxhdGUgd2l0aCBJRCBcIiArIHRlbXBsYXRlKTtcbiAgICAgICAgcmV0dXJuIG5ldyBrby50ZW1wbGF0ZVNvdXJjZXMuZG9tRWxlbWVudChlbGVtKTtcbiAgICB9IGVsc2UgaWYgKCh0ZW1wbGF0ZS5ub2RlVHlwZSA9PSAxKSB8fCAodGVtcGxhdGUubm9kZVR5cGUgPT0gOCkpIHtcbiAgICAgICAgLy8gQW5vbnltb3VzIHRlbXBsYXRlXG4gICAgICAgIHJldHVybiBuZXcga28udGVtcGxhdGVTb3VyY2VzLmFub255bW91c1RlbXBsYXRlKHRlbXBsYXRlKTtcbiAgICB9IGVsc2VcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biB0ZW1wbGF0ZSB0eXBlOiBcIiArIHRlbXBsYXRlKTtcbn07XG5cbmtvLnRlbXBsYXRlRW5naW5lLnByb3RvdHlwZVsncmVuZGVyVGVtcGxhdGUnXSA9IGZ1bmN0aW9uICh0ZW1wbGF0ZSwgYmluZGluZ0NvbnRleHQsIG9wdGlvbnMsIHRlbXBsYXRlRG9jdW1lbnQpIHtcbiAgICB2YXIgdGVtcGxhdGVTb3VyY2UgPSB0aGlzWydtYWtlVGVtcGxhdGVTb3VyY2UnXSh0ZW1wbGF0ZSwgdGVtcGxhdGVEb2N1bWVudCk7XG4gICAgcmV0dXJuIHRoaXNbJ3JlbmRlclRlbXBsYXRlU291cmNlJ10odGVtcGxhdGVTb3VyY2UsIGJpbmRpbmdDb250ZXh0LCBvcHRpb25zLCB0ZW1wbGF0ZURvY3VtZW50KTtcbn07XG5cbmtvLnRlbXBsYXRlRW5naW5lLnByb3RvdHlwZVsnaXNUZW1wbGF0ZVJld3JpdHRlbiddID0gZnVuY3Rpb24gKHRlbXBsYXRlLCB0ZW1wbGF0ZURvY3VtZW50KSB7XG4gICAgLy8gU2tpcCByZXdyaXRpbmcgaWYgcmVxdWVzdGVkXG4gICAgaWYgKHRoaXNbJ2FsbG93VGVtcGxhdGVSZXdyaXRpbmcnXSA9PT0gZmFsc2UpXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIHJldHVybiB0aGlzWydtYWtlVGVtcGxhdGVTb3VyY2UnXSh0ZW1wbGF0ZSwgdGVtcGxhdGVEb2N1bWVudClbJ2RhdGEnXShcImlzUmV3cml0dGVuXCIpO1xufTtcblxua28udGVtcGxhdGVFbmdpbmUucHJvdG90eXBlWydyZXdyaXRlVGVtcGxhdGUnXSA9IGZ1bmN0aW9uICh0ZW1wbGF0ZSwgcmV3cml0ZXJDYWxsYmFjaywgdGVtcGxhdGVEb2N1bWVudCkge1xuICAgIHZhciB0ZW1wbGF0ZVNvdXJjZSA9IHRoaXNbJ21ha2VUZW1wbGF0ZVNvdXJjZSddKHRlbXBsYXRlLCB0ZW1wbGF0ZURvY3VtZW50KTtcbiAgICB2YXIgcmV3cml0dGVuID0gcmV3cml0ZXJDYWxsYmFjayh0ZW1wbGF0ZVNvdXJjZVsndGV4dCddKCkpO1xuICAgIHRlbXBsYXRlU291cmNlWyd0ZXh0J10ocmV3cml0dGVuKTtcbiAgICB0ZW1wbGF0ZVNvdXJjZVsnZGF0YSddKFwiaXNSZXdyaXR0ZW5cIiwgdHJ1ZSk7XG59O1xuXG5rby5leHBvcnRTeW1ib2woJ3RlbXBsYXRlRW5naW5lJywga28udGVtcGxhdGVFbmdpbmUpO1xuXG5rby50ZW1wbGF0ZVJld3JpdGluZyA9IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG1lbW9pemVEYXRhQmluZGluZ0F0dHJpYnV0ZVN5bnRheFJlZ2V4ID0gLyg8KFthLXpdK1xcZCopKD86XFxzKyg/IWRhdGEtYmluZFxccyo9XFxzKilbYS16MC05XFwtXSsoPzo9KD86XFxcIlteXFxcIl0qXFxcInxcXCdbXlxcJ10qXFwnfFtePl0qKSk/KSpcXHMrKWRhdGEtYmluZFxccyo9XFxzKihbXCInXSkoW1xcc1xcU10qPylcXDMvZ2k7XG4gICAgdmFyIG1lbW9pemVWaXJ0dWFsQ29udGFpbmVyQmluZGluZ1N5bnRheFJlZ2V4ID0gLzwhLS1cXHMqa29cXGJcXHMqKFtcXHNcXFNdKj8pXFxzKi0tPi9nO1xuXG4gICAgZnVuY3Rpb24gdmFsaWRhdGVEYXRhQmluZFZhbHVlc0ZvclJld3JpdGluZyhrZXlWYWx1ZUFycmF5KSB7XG4gICAgICAgIHZhciBhbGxWYWxpZGF0b3JzID0ga28uZXhwcmVzc2lvblJld3JpdGluZy5iaW5kaW5nUmV3cml0ZVZhbGlkYXRvcnM7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5VmFsdWVBcnJheS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGtleSA9IGtleVZhbHVlQXJyYXlbaV1bJ2tleSddO1xuICAgICAgICAgICAgaWYgKGFsbFZhbGlkYXRvcnMuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgICAgICAgIHZhciB2YWxpZGF0b3IgPSBhbGxWYWxpZGF0b3JzW2tleV07XG5cbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHZhbGlkYXRvciA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBwb3NzaWJsZUVycm9yTWVzc2FnZSA9IHZhbGlkYXRvcihrZXlWYWx1ZUFycmF5W2ldWyd2YWx1ZSddKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBvc3NpYmxlRXJyb3JNZXNzYWdlKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKHBvc3NpYmxlRXJyb3JNZXNzYWdlKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCF2YWxpZGF0b3IpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhpcyB0ZW1wbGF0ZSBlbmdpbmUgZG9lcyBub3Qgc3VwcG9ydCB0aGUgJ1wiICsga2V5ICsgXCInIGJpbmRpbmcgd2l0aGluIGl0cyB0ZW1wbGF0ZXNcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY29uc3RydWN0TWVtb2l6ZWRUYWdSZXBsYWNlbWVudChkYXRhQmluZEF0dHJpYnV0ZVZhbHVlLCB0YWdUb1JldGFpbiwgbm9kZU5hbWUsIHRlbXBsYXRlRW5naW5lKSB7XG4gICAgICAgIHZhciBkYXRhQmluZEtleVZhbHVlQXJyYXkgPSBrby5leHByZXNzaW9uUmV3cml0aW5nLnBhcnNlT2JqZWN0TGl0ZXJhbChkYXRhQmluZEF0dHJpYnV0ZVZhbHVlKTtcbiAgICAgICAgdmFsaWRhdGVEYXRhQmluZFZhbHVlc0ZvclJld3JpdGluZyhkYXRhQmluZEtleVZhbHVlQXJyYXkpO1xuICAgICAgICB2YXIgcmV3cml0dGVuRGF0YUJpbmRBdHRyaWJ1dGVWYWx1ZSA9IGtvLmV4cHJlc3Npb25SZXdyaXRpbmcucHJlUHJvY2Vzc0JpbmRpbmdzKGRhdGFCaW5kS2V5VmFsdWVBcnJheSwgeyd2YWx1ZUFjY2Vzc29ycyc6dHJ1ZX0pO1xuXG4gICAgICAgIC8vIEZvciBubyBvYnZpb3VzIHJlYXNvbiwgT3BlcmEgZmFpbHMgdG8gZXZhbHVhdGUgcmV3cml0dGVuRGF0YUJpbmRBdHRyaWJ1dGVWYWx1ZSB1bmxlc3MgaXQncyB3cmFwcGVkIGluIGFuIGFkZGl0aW9uYWxcbiAgICAgICAgLy8gYW5vbnltb3VzIGZ1bmN0aW9uLCBldmVuIHRob3VnaCBPcGVyYSdzIGJ1aWx0LWluIGRlYnVnZ2VyIGNhbiBldmFsdWF0ZSBpdCBhbnl3YXkuIE5vIG90aGVyIGJyb3dzZXIgcmVxdWlyZXMgdGhpc1xuICAgICAgICAvLyBleHRyYSBpbmRpcmVjdGlvbi5cbiAgICAgICAgdmFyIGFwcGx5QmluZGluZ3NUb05leHRTaWJsaW5nU2NyaXB0ID1cbiAgICAgICAgICAgIFwia28uX190cl9hbWJ0bnMoZnVuY3Rpb24oJGNvbnRleHQsJGVsZW1lbnQpe3JldHVybihmdW5jdGlvbigpe3JldHVybnsgXCIgKyByZXdyaXR0ZW5EYXRhQmluZEF0dHJpYnV0ZVZhbHVlICsgXCIgfSB9KSgpfSwnXCIgKyBub2RlTmFtZS50b0xvd2VyQ2FzZSgpICsgXCInKVwiO1xuICAgICAgICByZXR1cm4gdGVtcGxhdGVFbmdpbmVbJ2NyZWF0ZUphdmFTY3JpcHRFdmFsdWF0b3JCbG9jayddKGFwcGx5QmluZGluZ3NUb05leHRTaWJsaW5nU2NyaXB0KSArIHRhZ1RvUmV0YWluO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICAgIGVuc3VyZVRlbXBsYXRlSXNSZXdyaXR0ZW46IGZ1bmN0aW9uICh0ZW1wbGF0ZSwgdGVtcGxhdGVFbmdpbmUsIHRlbXBsYXRlRG9jdW1lbnQpIHtcbiAgICAgICAgICAgIGlmICghdGVtcGxhdGVFbmdpbmVbJ2lzVGVtcGxhdGVSZXdyaXR0ZW4nXSh0ZW1wbGF0ZSwgdGVtcGxhdGVEb2N1bWVudCkpXG4gICAgICAgICAgICAgICAgdGVtcGxhdGVFbmdpbmVbJ3Jld3JpdGVUZW1wbGF0ZSddKHRlbXBsYXRlLCBmdW5jdGlvbiAoaHRtbFN0cmluZykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4ga28udGVtcGxhdGVSZXdyaXRpbmcubWVtb2l6ZUJpbmRpbmdBdHRyaWJ1dGVTeW50YXgoaHRtbFN0cmluZywgdGVtcGxhdGVFbmdpbmUpO1xuICAgICAgICAgICAgICAgIH0sIHRlbXBsYXRlRG9jdW1lbnQpO1xuICAgICAgICB9LFxuXG4gICAgICAgIG1lbW9pemVCaW5kaW5nQXR0cmlidXRlU3ludGF4OiBmdW5jdGlvbiAoaHRtbFN0cmluZywgdGVtcGxhdGVFbmdpbmUpIHtcbiAgICAgICAgICAgIHJldHVybiBodG1sU3RyaW5nLnJlcGxhY2UobWVtb2l6ZURhdGFCaW5kaW5nQXR0cmlidXRlU3ludGF4UmVnZXgsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29uc3RydWN0TWVtb2l6ZWRUYWdSZXBsYWNlbWVudCgvKiBkYXRhQmluZEF0dHJpYnV0ZVZhbHVlOiAqLyBhcmd1bWVudHNbNF0sIC8qIHRhZ1RvUmV0YWluOiAqLyBhcmd1bWVudHNbMV0sIC8qIG5vZGVOYW1lOiAqLyBhcmd1bWVudHNbMl0sIHRlbXBsYXRlRW5naW5lKTtcbiAgICAgICAgICAgIH0pLnJlcGxhY2UobWVtb2l6ZVZpcnR1YWxDb250YWluZXJCaW5kaW5nU3ludGF4UmVnZXgsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjb25zdHJ1Y3RNZW1vaXplZFRhZ1JlcGxhY2VtZW50KC8qIGRhdGFCaW5kQXR0cmlidXRlVmFsdWU6ICovIGFyZ3VtZW50c1sxXSwgLyogdGFnVG9SZXRhaW46ICovIFwiPCEtLSBrbyAtLT5cIiwgLyogbm9kZU5hbWU6ICovIFwiI2NvbW1lbnRcIiwgdGVtcGxhdGVFbmdpbmUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgYXBwbHlNZW1vaXplZEJpbmRpbmdzVG9OZXh0U2libGluZzogZnVuY3Rpb24gKGJpbmRpbmdzLCBub2RlTmFtZSkge1xuICAgICAgICAgICAgcmV0dXJuIGtvLm1lbW9pemF0aW9uLm1lbW9pemUoZnVuY3Rpb24gKGRvbU5vZGUsIGJpbmRpbmdDb250ZXh0KSB7XG4gICAgICAgICAgICAgICAgdmFyIG5vZGVUb0JpbmQgPSBkb21Ob2RlLm5leHRTaWJsaW5nO1xuICAgICAgICAgICAgICAgIGlmIChub2RlVG9CaW5kICYmIG5vZGVUb0JpbmQubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gbm9kZU5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAga28uYXBwbHlCaW5kaW5nQWNjZXNzb3JzVG9Ob2RlKG5vZGVUb0JpbmQsIGJpbmRpbmdzLCBiaW5kaW5nQ29udGV4dCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG59KSgpO1xuXG5cbi8vIEV4cG9ydGVkIG9ubHkgYmVjYXVzZSBpdCBoYXMgdG8gYmUgcmVmZXJlbmNlZCBieSBzdHJpbmcgbG9va3VwIGZyb20gd2l0aGluIHJld3JpdHRlbiB0ZW1wbGF0ZVxua28uZXhwb3J0U3ltYm9sKCdfX3RyX2FtYnRucycsIGtvLnRlbXBsYXRlUmV3cml0aW5nLmFwcGx5TWVtb2l6ZWRCaW5kaW5nc1RvTmV4dFNpYmxpbmcpO1xuKGZ1bmN0aW9uKCkge1xuICAgIC8vIEEgdGVtcGxhdGUgc291cmNlIHJlcHJlc2VudHMgYSByZWFkL3dyaXRlIHdheSBvZiBhY2Nlc3NpbmcgYSB0ZW1wbGF0ZS4gVGhpcyBpcyB0byBlbGltaW5hdGUgdGhlIG5lZWQgZm9yIHRlbXBsYXRlIGxvYWRpbmcvc2F2aW5nXG4gICAgLy8gbG9naWMgdG8gYmUgZHVwbGljYXRlZCBpbiBldmVyeSB0ZW1wbGF0ZSBlbmdpbmUgKGFuZCBtZWFucyB0aGV5IGNhbiBhbGwgd29yayB3aXRoIGFub255bW91cyB0ZW1wbGF0ZXMsIGV0Yy4pXG4gICAgLy9cbiAgICAvLyBUd28gYXJlIHByb3ZpZGVkIGJ5IGRlZmF1bHQ6XG4gICAgLy8gIDEuIGtvLnRlbXBsYXRlU291cmNlcy5kb21FbGVtZW50ICAgICAgIC0gcmVhZHMvd3JpdGVzIHRoZSB0ZXh0IGNvbnRlbnQgb2YgYW4gYXJiaXRyYXJ5IERPTSBlbGVtZW50XG4gICAgLy8gIDIuIGtvLnRlbXBsYXRlU291cmNlcy5hbm9ueW1vdXNFbGVtZW50IC0gdXNlcyBrby51dGlscy5kb21EYXRhIHRvIHJlYWQvd3JpdGUgdGV4dCAqYXNzb2NpYXRlZCogd2l0aCB0aGUgRE9NIGVsZW1lbnQsIGJ1dFxuICAgIC8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpdGhvdXQgcmVhZGluZy93cml0aW5nIHRoZSBhY3R1YWwgZWxlbWVudCB0ZXh0IGNvbnRlbnQsIHNpbmNlIGl0IHdpbGwgYmUgb3ZlcndyaXR0ZW5cbiAgICAvLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aXRoIHRoZSByZW5kZXJlZCB0ZW1wbGF0ZSBvdXRwdXQuXG4gICAgLy8gWW91IGNhbiBpbXBsZW1lbnQgeW91ciBvd24gdGVtcGxhdGUgc291cmNlIGlmIHlvdSB3YW50IHRvIGZldGNoL3N0b3JlIHRlbXBsYXRlcyBzb21ld2hlcmUgb3RoZXIgdGhhbiBpbiBET00gZWxlbWVudHMuXG4gICAgLy8gVGVtcGxhdGUgc291cmNlcyBuZWVkIHRvIGhhdmUgdGhlIGZvbGxvd2luZyBmdW5jdGlvbnM6XG4gICAgLy8gICB0ZXh0KCkgXHRcdFx0LSByZXR1cm5zIHRoZSB0ZW1wbGF0ZSB0ZXh0IGZyb20geW91ciBzdG9yYWdlIGxvY2F0aW9uXG4gICAgLy8gICB0ZXh0KHZhbHVlKVx0XHQtIHdyaXRlcyB0aGUgc3VwcGxpZWQgdGVtcGxhdGUgdGV4dCB0byB5b3VyIHN0b3JhZ2UgbG9jYXRpb25cbiAgICAvLyAgIGRhdGEoa2V5KVx0XHRcdC0gcmVhZHMgdmFsdWVzIHN0b3JlZCB1c2luZyBkYXRhKGtleSwgdmFsdWUpIC0gc2VlIGJlbG93XG4gICAgLy8gICBkYXRhKGtleSwgdmFsdWUpXHQtIGFzc29jaWF0ZXMgXCJ2YWx1ZVwiIHdpdGggdGhpcyB0ZW1wbGF0ZSBhbmQgdGhlIGtleSBcImtleVwiLiBJcyB1c2VkIHRvIHN0b3JlIGluZm9ybWF0aW9uIGxpa2UgXCJpc1Jld3JpdHRlblwiLlxuICAgIC8vXG4gICAgLy8gT3B0aW9uYWxseSwgdGVtcGxhdGUgc291cmNlcyBjYW4gYWxzbyBoYXZlIHRoZSBmb2xsb3dpbmcgZnVuY3Rpb25zOlxuICAgIC8vICAgbm9kZXMoKSAgICAgICAgICAgIC0gcmV0dXJucyBhIERPTSBlbGVtZW50IGNvbnRhaW5pbmcgdGhlIG5vZGVzIG9mIHRoaXMgdGVtcGxhdGUsIHdoZXJlIGF2YWlsYWJsZVxuICAgIC8vICAgbm9kZXModmFsdWUpICAgICAgIC0gd3JpdGVzIHRoZSBnaXZlbiBET00gZWxlbWVudCB0byB5b3VyIHN0b3JhZ2UgbG9jYXRpb25cbiAgICAvLyBJZiBhIERPTSBlbGVtZW50IGlzIGF2YWlsYWJsZSBmb3IgYSBnaXZlbiB0ZW1wbGF0ZSBzb3VyY2UsIHRlbXBsYXRlIGVuZ2luZXMgYXJlIGVuY291cmFnZWQgdG8gdXNlIGl0IGluIHByZWZlcmVuY2Ugb3ZlciB0ZXh0KClcbiAgICAvLyBmb3IgaW1wcm92ZWQgc3BlZWQuIEhvd2V2ZXIsIGFsbCB0ZW1wbGF0ZVNvdXJjZXMgbXVzdCBzdXBwbHkgdGV4dCgpIGV2ZW4gaWYgdGhleSBkb24ndCBzdXBwbHkgbm9kZXMoKS5cbiAgICAvL1xuICAgIC8vIE9uY2UgeW91J3ZlIGltcGxlbWVudGVkIGEgdGVtcGxhdGVTb3VyY2UsIG1ha2UgeW91ciB0ZW1wbGF0ZSBlbmdpbmUgdXNlIGl0IGJ5IHN1YmNsYXNzaW5nIHdoYXRldmVyIHRlbXBsYXRlIGVuZ2luZSB5b3Ugd2VyZVxuICAgIC8vIHVzaW5nIGFuZCBvdmVycmlkaW5nIFwibWFrZVRlbXBsYXRlU291cmNlXCIgdG8gcmV0dXJuIGFuIGluc3RhbmNlIG9mIHlvdXIgY3VzdG9tIHRlbXBsYXRlIHNvdXJjZS5cblxuICAgIGtvLnRlbXBsYXRlU291cmNlcyA9IHt9O1xuXG4gICAgLy8gLS0tLSBrby50ZW1wbGF0ZVNvdXJjZXMuZG9tRWxlbWVudCAtLS0tLVxuXG4gICAgLy8gdGVtcGxhdGUgdHlwZXNcbiAgICB2YXIgdGVtcGxhdGVTY3JpcHQgPSAxLFxuICAgICAgICB0ZW1wbGF0ZVRleHRBcmVhID0gMixcbiAgICAgICAgdGVtcGxhdGVUZW1wbGF0ZSA9IDMsXG4gICAgICAgIHRlbXBsYXRlRWxlbWVudCA9IDQ7XG5cbiAgICBrby50ZW1wbGF0ZVNvdXJjZXMuZG9tRWxlbWVudCA9IGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgICAgICAgdGhpcy5kb21FbGVtZW50ID0gZWxlbWVudDtcblxuICAgICAgICBpZiAoZWxlbWVudCkge1xuICAgICAgICAgICAgdmFyIHRhZ05hbWVMb3dlciA9IGtvLnV0aWxzLnRhZ05hbWVMb3dlcihlbGVtZW50KTtcbiAgICAgICAgICAgIHRoaXMudGVtcGxhdGVUeXBlID1cbiAgICAgICAgICAgICAgICB0YWdOYW1lTG93ZXIgPT09IFwic2NyaXB0XCIgPyB0ZW1wbGF0ZVNjcmlwdCA6XG4gICAgICAgICAgICAgICAgdGFnTmFtZUxvd2VyID09PSBcInRleHRhcmVhXCIgPyB0ZW1wbGF0ZVRleHRBcmVhIDpcbiAgICAgICAgICAgICAgICAgICAgLy8gRm9yIGJyb3dzZXJzIHdpdGggcHJvcGVyIDx0ZW1wbGF0ZT4gZWxlbWVudCBzdXBwb3J0LCB3aGVyZSB0aGUgLmNvbnRlbnQgcHJvcGVydHkgZ2l2ZXMgYSBkb2N1bWVudCBmcmFnbWVudFxuICAgICAgICAgICAgICAgIHRhZ05hbWVMb3dlciA9PSBcInRlbXBsYXRlXCIgJiYgZWxlbWVudC5jb250ZW50ICYmIGVsZW1lbnQuY29udGVudC5ub2RlVHlwZSA9PT0gMTEgPyB0ZW1wbGF0ZVRlbXBsYXRlIDpcbiAgICAgICAgICAgICAgICB0ZW1wbGF0ZUVsZW1lbnQ7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBrby50ZW1wbGF0ZVNvdXJjZXMuZG9tRWxlbWVudC5wcm90b3R5cGVbJ3RleHQnXSA9IGZ1bmN0aW9uKC8qIHZhbHVlVG9Xcml0ZSAqLykge1xuICAgICAgICB2YXIgZWxlbUNvbnRlbnRzUHJvcGVydHkgPSB0aGlzLnRlbXBsYXRlVHlwZSA9PT0gdGVtcGxhdGVTY3JpcHQgPyBcInRleHRcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiB0aGlzLnRlbXBsYXRlVHlwZSA9PT0gdGVtcGxhdGVUZXh0QXJlYSA/IFwidmFsdWVcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBcImlubmVySFRNTFwiO1xuXG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09IDApIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRvbUVsZW1lbnRbZWxlbUNvbnRlbnRzUHJvcGVydHldO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIHZhbHVlVG9Xcml0ZSA9IGFyZ3VtZW50c1swXTtcbiAgICAgICAgICAgIGlmIChlbGVtQ29udGVudHNQcm9wZXJ0eSA9PT0gXCJpbm5lckhUTUxcIilcbiAgICAgICAgICAgICAgICBrby51dGlscy5zZXRIdG1sKHRoaXMuZG9tRWxlbWVudCwgdmFsdWVUb1dyaXRlKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICB0aGlzLmRvbUVsZW1lbnRbZWxlbUNvbnRlbnRzUHJvcGVydHldID0gdmFsdWVUb1dyaXRlO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHZhciBkYXRhRG9tRGF0YVByZWZpeCA9IGtvLnV0aWxzLmRvbURhdGEubmV4dEtleSgpICsgXCJfXCI7XG4gICAga28udGVtcGxhdGVTb3VyY2VzLmRvbUVsZW1lbnQucHJvdG90eXBlWydkYXRhJ10gPSBmdW5jdGlvbihrZXkgLyosIHZhbHVlVG9Xcml0ZSAqLykge1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgcmV0dXJuIGtvLnV0aWxzLmRvbURhdGEuZ2V0KHRoaXMuZG9tRWxlbWVudCwgZGF0YURvbURhdGFQcmVmaXggKyBrZXkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAga28udXRpbHMuZG9tRGF0YS5zZXQodGhpcy5kb21FbGVtZW50LCBkYXRhRG9tRGF0YVByZWZpeCArIGtleSwgYXJndW1lbnRzWzFdKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgdGVtcGxhdGVzRG9tRGF0YUtleSA9IGtvLnV0aWxzLmRvbURhdGEubmV4dEtleSgpO1xuICAgIGZ1bmN0aW9uIGdldFRlbXBsYXRlRG9tRGF0YShlbGVtZW50KSB7XG4gICAgICAgIHJldHVybiBrby51dGlscy5kb21EYXRhLmdldChlbGVtZW50LCB0ZW1wbGF0ZXNEb21EYXRhS2V5KSB8fCB7fTtcbiAgICB9XG4gICAgZnVuY3Rpb24gc2V0VGVtcGxhdGVEb21EYXRhKGVsZW1lbnQsIGRhdGEpIHtcbiAgICAgICAga28udXRpbHMuZG9tRGF0YS5zZXQoZWxlbWVudCwgdGVtcGxhdGVzRG9tRGF0YUtleSwgZGF0YSk7XG4gICAgfVxuXG4gICAga28udGVtcGxhdGVTb3VyY2VzLmRvbUVsZW1lbnQucHJvdG90eXBlWydub2RlcyddID0gZnVuY3Rpb24oLyogdmFsdWVUb1dyaXRlICovKSB7XG4gICAgICAgIHZhciBlbGVtZW50ID0gdGhpcy5kb21FbGVtZW50O1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgICAgICB2YXIgdGVtcGxhdGVEYXRhID0gZ2V0VGVtcGxhdGVEb21EYXRhKGVsZW1lbnQpLFxuICAgICAgICAgICAgICAgIGNvbnRhaW5lckRhdGEgPSB0ZW1wbGF0ZURhdGEuY29udGFpbmVyRGF0YTtcbiAgICAgICAgICAgIHJldHVybiBjb250YWluZXJEYXRhIHx8IChcbiAgICAgICAgICAgICAgICB0aGlzLnRlbXBsYXRlVHlwZSA9PT0gdGVtcGxhdGVUZW1wbGF0ZSA/IGVsZW1lbnQuY29udGVudCA6XG4gICAgICAgICAgICAgICAgdGhpcy50ZW1wbGF0ZVR5cGUgPT09IHRlbXBsYXRlRWxlbWVudCA/IGVsZW1lbnQgOlxuICAgICAgICAgICAgICAgIHVuZGVmaW5lZCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgdmFsdWVUb1dyaXRlID0gYXJndW1lbnRzWzBdO1xuICAgICAgICAgICAgc2V0VGVtcGxhdGVEb21EYXRhKGVsZW1lbnQsIHtjb250YWluZXJEYXRhOiB2YWx1ZVRvV3JpdGV9KTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvLyAtLS0tIGtvLnRlbXBsYXRlU291cmNlcy5hbm9ueW1vdXNUZW1wbGF0ZSAtLS0tLVxuICAgIC8vIEFub255bW91cyB0ZW1wbGF0ZXMgYXJlIG5vcm1hbGx5IHNhdmVkL3JldHJpZXZlZCBhcyBET00gbm9kZXMgdGhyb3VnaCBcIm5vZGVzXCIuXG4gICAgLy8gRm9yIGNvbXBhdGliaWxpdHksIHlvdSBjYW4gYWxzbyByZWFkIFwidGV4dFwiOyBpdCB3aWxsIGJlIHNlcmlhbGl6ZWQgZnJvbSB0aGUgbm9kZXMgb24gZGVtYW5kLlxuICAgIC8vIFdyaXRpbmcgdG8gXCJ0ZXh0XCIgaXMgc3RpbGwgc3VwcG9ydGVkLCBidXQgdGhlbiB0aGUgdGVtcGxhdGUgZGF0YSB3aWxsIG5vdCBiZSBhdmFpbGFibGUgYXMgRE9NIG5vZGVzLlxuXG4gICAga28udGVtcGxhdGVTb3VyY2VzLmFub255bW91c1RlbXBsYXRlID0gZnVuY3Rpb24oZWxlbWVudCkge1xuICAgICAgICB0aGlzLmRvbUVsZW1lbnQgPSBlbGVtZW50O1xuICAgIH1cbiAgICBrby50ZW1wbGF0ZVNvdXJjZXMuYW5vbnltb3VzVGVtcGxhdGUucHJvdG90eXBlID0gbmV3IGtvLnRlbXBsYXRlU291cmNlcy5kb21FbGVtZW50KCk7XG4gICAga28udGVtcGxhdGVTb3VyY2VzLmFub255bW91c1RlbXBsYXRlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IGtvLnRlbXBsYXRlU291cmNlcy5hbm9ueW1vdXNUZW1wbGF0ZTtcbiAgICBrby50ZW1wbGF0ZVNvdXJjZXMuYW5vbnltb3VzVGVtcGxhdGUucHJvdG90eXBlWyd0ZXh0J10gPSBmdW5jdGlvbigvKiB2YWx1ZVRvV3JpdGUgKi8pIHtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT0gMCkge1xuICAgICAgICAgICAgdmFyIHRlbXBsYXRlRGF0YSA9IGdldFRlbXBsYXRlRG9tRGF0YSh0aGlzLmRvbUVsZW1lbnQpO1xuICAgICAgICAgICAgaWYgKHRlbXBsYXRlRGF0YS50ZXh0RGF0YSA9PT0gdW5kZWZpbmVkICYmIHRlbXBsYXRlRGF0YS5jb250YWluZXJEYXRhKVxuICAgICAgICAgICAgICAgIHRlbXBsYXRlRGF0YS50ZXh0RGF0YSA9IHRlbXBsYXRlRGF0YS5jb250YWluZXJEYXRhLmlubmVySFRNTDtcbiAgICAgICAgICAgIHJldHVybiB0ZW1wbGF0ZURhdGEudGV4dERhdGE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgdmFsdWVUb1dyaXRlID0gYXJndW1lbnRzWzBdO1xuICAgICAgICAgICAgc2V0VGVtcGxhdGVEb21EYXRhKHRoaXMuZG9tRWxlbWVudCwge3RleHREYXRhOiB2YWx1ZVRvV3JpdGV9KTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBrby5leHBvcnRTeW1ib2woJ3RlbXBsYXRlU291cmNlcycsIGtvLnRlbXBsYXRlU291cmNlcyk7XG4gICAga28uZXhwb3J0U3ltYm9sKCd0ZW1wbGF0ZVNvdXJjZXMuZG9tRWxlbWVudCcsIGtvLnRlbXBsYXRlU291cmNlcy5kb21FbGVtZW50KTtcbiAgICBrby5leHBvcnRTeW1ib2woJ3RlbXBsYXRlU291cmNlcy5hbm9ueW1vdXNUZW1wbGF0ZScsIGtvLnRlbXBsYXRlU291cmNlcy5hbm9ueW1vdXNUZW1wbGF0ZSk7XG59KSgpO1xuKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgX3RlbXBsYXRlRW5naW5lO1xuICAgIGtvLnNldFRlbXBsYXRlRW5naW5lID0gZnVuY3Rpb24gKHRlbXBsYXRlRW5naW5lKSB7XG4gICAgICAgIGlmICgodGVtcGxhdGVFbmdpbmUgIT0gdW5kZWZpbmVkKSAmJiAhKHRlbXBsYXRlRW5naW5lIGluc3RhbmNlb2Yga28udGVtcGxhdGVFbmdpbmUpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwidGVtcGxhdGVFbmdpbmUgbXVzdCBpbmhlcml0IGZyb20ga28udGVtcGxhdGVFbmdpbmVcIik7XG4gICAgICAgIF90ZW1wbGF0ZUVuZ2luZSA9IHRlbXBsYXRlRW5naW5lO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGludm9rZUZvckVhY2hOb2RlSW5Db250aW51b3VzUmFuZ2UoZmlyc3ROb2RlLCBsYXN0Tm9kZSwgYWN0aW9uKSB7XG4gICAgICAgIHZhciBub2RlLCBuZXh0SW5RdWV1ZSA9IGZpcnN0Tm9kZSwgZmlyc3RPdXRPZlJhbmdlTm9kZSA9IGtvLnZpcnR1YWxFbGVtZW50cy5uZXh0U2libGluZyhsYXN0Tm9kZSk7XG4gICAgICAgIHdoaWxlIChuZXh0SW5RdWV1ZSAmJiAoKG5vZGUgPSBuZXh0SW5RdWV1ZSkgIT09IGZpcnN0T3V0T2ZSYW5nZU5vZGUpKSB7XG4gICAgICAgICAgICBuZXh0SW5RdWV1ZSA9IGtvLnZpcnR1YWxFbGVtZW50cy5uZXh0U2libGluZyhub2RlKTtcbiAgICAgICAgICAgIGFjdGlvbihub2RlLCBuZXh0SW5RdWV1ZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhY3RpdmF0ZUJpbmRpbmdzT25Db250aW51b3VzTm9kZUFycmF5KGNvbnRpbnVvdXNOb2RlQXJyYXksIGJpbmRpbmdDb250ZXh0KSB7XG4gICAgICAgIC8vIFRvIGJlIHVzZWQgb24gYW55IG5vZGVzIHRoYXQgaGF2ZSBiZWVuIHJlbmRlcmVkIGJ5IGEgdGVtcGxhdGUgYW5kIGhhdmUgYmVlbiBpbnNlcnRlZCBpbnRvIHNvbWUgcGFyZW50IGVsZW1lbnRcbiAgICAgICAgLy8gV2Fsa3MgdGhyb3VnaCBjb250aW51b3VzTm9kZUFycmF5ICh3aGljaCAqbXVzdCogYmUgY29udGludW91cywgaS5lLiwgYW4gdW5pbnRlcnJ1cHRlZCBzZXF1ZW5jZSBvZiBzaWJsaW5nIG5vZGVzLCBiZWNhdXNlXG4gICAgICAgIC8vIHRoZSBhbGdvcml0aG0gZm9yIHdhbGtpbmcgdGhlbSByZWxpZXMgb24gdGhpcyksIGFuZCBmb3IgZWFjaCB0b3AtbGV2ZWwgaXRlbSBpbiB0aGUgdmlydHVhbC1lbGVtZW50IHNlbnNlLFxuICAgICAgICAvLyAoMSkgRG9lcyBhIHJlZ3VsYXIgXCJhcHBseUJpbmRpbmdzXCIgdG8gYXNzb2NpYXRlIGJpbmRpbmdDb250ZXh0IHdpdGggdGhpcyBub2RlIGFuZCB0byBhY3RpdmF0ZSBhbnkgbm9uLW1lbW9pemVkIGJpbmRpbmdzXG4gICAgICAgIC8vICgyKSBVbm1lbW9pemVzIGFueSBtZW1vcyBpbiB0aGUgRE9NIHN1YnRyZWUgKGUuZy4sIHRvIGFjdGl2YXRlIGJpbmRpbmdzIHRoYXQgaGFkIGJlZW4gbWVtb2l6ZWQgZHVyaW5nIHRlbXBsYXRlIHJld3JpdGluZylcblxuICAgICAgICBpZiAoY29udGludW91c05vZGVBcnJheS5sZW5ndGgpIHtcbiAgICAgICAgICAgIHZhciBmaXJzdE5vZGUgPSBjb250aW51b3VzTm9kZUFycmF5WzBdLFxuICAgICAgICAgICAgICAgIGxhc3ROb2RlID0gY29udGludW91c05vZGVBcnJheVtjb250aW51b3VzTm9kZUFycmF5Lmxlbmd0aCAtIDFdLFxuICAgICAgICAgICAgICAgIHBhcmVudE5vZGUgPSBmaXJzdE5vZGUucGFyZW50Tm9kZSxcbiAgICAgICAgICAgICAgICBwcm92aWRlciA9IGtvLmJpbmRpbmdQcm92aWRlclsnaW5zdGFuY2UnXSxcbiAgICAgICAgICAgICAgICBwcmVwcm9jZXNzTm9kZSA9IHByb3ZpZGVyWydwcmVwcm9jZXNzTm9kZSddO1xuXG4gICAgICAgICAgICBpZiAocHJlcHJvY2Vzc05vZGUpIHtcbiAgICAgICAgICAgICAgICBpbnZva2VGb3JFYWNoTm9kZUluQ29udGludW91c1JhbmdlKGZpcnN0Tm9kZSwgbGFzdE5vZGUsIGZ1bmN0aW9uKG5vZGUsIG5leHROb2RlSW5SYW5nZSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbm9kZVByZXZpb3VzU2libGluZyA9IG5vZGUucHJldmlvdXNTaWJsaW5nO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbmV3Tm9kZXMgPSBwcmVwcm9jZXNzTm9kZS5jYWxsKHByb3ZpZGVyLCBub2RlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5ld05vZGVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobm9kZSA9PT0gZmlyc3ROb2RlKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpcnN0Tm9kZSA9IG5ld05vZGVzWzBdIHx8IG5leHROb2RlSW5SYW5nZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChub2RlID09PSBsYXN0Tm9kZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYXN0Tm9kZSA9IG5ld05vZGVzW25ld05vZGVzLmxlbmd0aCAtIDFdIHx8IG5vZGVQcmV2aW91c1NpYmxpbmc7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIC8vIEJlY2F1c2UgcHJlcHJvY2Vzc05vZGUgY2FuIGNoYW5nZSB0aGUgbm9kZXMsIGluY2x1ZGluZyB0aGUgZmlyc3QgYW5kIGxhc3Qgbm9kZXMsIHVwZGF0ZSBjb250aW51b3VzTm9kZUFycmF5IHRvIG1hdGNoLlxuICAgICAgICAgICAgICAgIC8vIFdlIG5lZWQgdGhlIGZ1bGwgc2V0LCBpbmNsdWRpbmcgaW5uZXIgbm9kZXMsIGJlY2F1c2UgdGhlIHVubWVtb2l6ZSBzdGVwIG1pZ2h0IHJlbW92ZSB0aGUgZmlyc3Qgbm9kZSAoYW5kIHNvIHRoZSByZWFsXG4gICAgICAgICAgICAgICAgLy8gZmlyc3Qgbm9kZSBuZWVkcyB0byBiZSBpbiB0aGUgYXJyYXkpLlxuICAgICAgICAgICAgICAgIGNvbnRpbnVvdXNOb2RlQXJyYXkubGVuZ3RoID0gMDtcbiAgICAgICAgICAgICAgICBpZiAoIWZpcnN0Tm9kZSkgeyAvLyBwcmVwcm9jZXNzTm9kZSBtaWdodCBoYXZlIHJlbW92ZWQgYWxsIHRoZSBub2RlcywgaW4gd2hpY2ggY2FzZSB0aGVyZSdzIG5vdGhpbmcgbGVmdCB0byBkb1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChmaXJzdE5vZGUgPT09IGxhc3ROb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVvdXNOb2RlQXJyYXkucHVzaChmaXJzdE5vZGUpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVvdXNOb2RlQXJyYXkucHVzaChmaXJzdE5vZGUsIGxhc3ROb2RlKTtcbiAgICAgICAgICAgICAgICAgICAga28udXRpbHMuZml4VXBDb250aW51b3VzTm9kZUFycmF5KGNvbnRpbnVvdXNOb2RlQXJyYXksIHBhcmVudE5vZGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gTmVlZCB0byBhcHBseUJpbmRpbmdzICpiZWZvcmUqIHVubWVtb3ppYXRpb24sIGJlY2F1c2UgdW5tZW1vaXphdGlvbiBtaWdodCBpbnRyb2R1Y2UgZXh0cmEgbm9kZXMgKHRoYXQgd2UgZG9uJ3Qgd2FudCB0byByZS1iaW5kKVxuICAgICAgICAgICAgLy8gd2hlcmVhcyBhIHJlZ3VsYXIgYXBwbHlCaW5kaW5ncyB3b24ndCBpbnRyb2R1Y2UgbmV3IG1lbW9pemVkIG5vZGVzXG4gICAgICAgICAgICBpbnZva2VGb3JFYWNoTm9kZUluQ29udGludW91c1JhbmdlKGZpcnN0Tm9kZSwgbGFzdE5vZGUsIGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgICAgICAgICAgICBpZiAobm9kZS5ub2RlVHlwZSA9PT0gMSB8fCBub2RlLm5vZGVUeXBlID09PSA4KVxuICAgICAgICAgICAgICAgICAgICBrby5hcHBseUJpbmRpbmdzKGJpbmRpbmdDb250ZXh0LCBub2RlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaW52b2tlRm9yRWFjaE5vZGVJbkNvbnRpbnVvdXNSYW5nZShmaXJzdE5vZGUsIGxhc3ROb2RlLCBmdW5jdGlvbihub2RlKSB7XG4gICAgICAgICAgICAgICAgaWYgKG5vZGUubm9kZVR5cGUgPT09IDEgfHwgbm9kZS5ub2RlVHlwZSA9PT0gOClcbiAgICAgICAgICAgICAgICAgICAga28ubWVtb2l6YXRpb24udW5tZW1vaXplRG9tTm9kZUFuZERlc2NlbmRhbnRzKG5vZGUsIFtiaW5kaW5nQ29udGV4dF0pO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSBhbnkgY2hhbmdlcyBkb25lIGJ5IGFwcGx5QmluZGluZ3Mgb3IgdW5tZW1vaXplIGFyZSByZWZsZWN0ZWQgaW4gdGhlIGFycmF5XG4gICAgICAgICAgICBrby51dGlscy5maXhVcENvbnRpbnVvdXNOb2RlQXJyYXkoY29udGludW91c05vZGVBcnJheSwgcGFyZW50Tm9kZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRGaXJzdE5vZGVGcm9tUG9zc2libGVBcnJheShub2RlT3JOb2RlQXJyYXkpIHtcbiAgICAgICAgcmV0dXJuIG5vZGVPck5vZGVBcnJheS5ub2RlVHlwZSA/IG5vZGVPck5vZGVBcnJheVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogbm9kZU9yTm9kZUFycmF5Lmxlbmd0aCA+IDAgPyBub2RlT3JOb2RlQXJyYXlbMF1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IG51bGw7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZXhlY3V0ZVRlbXBsYXRlKHRhcmdldE5vZGVPck5vZGVBcnJheSwgcmVuZGVyTW9kZSwgdGVtcGxhdGUsIGJpbmRpbmdDb250ZXh0LCBvcHRpb25zKSB7XG4gICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgICAgICB2YXIgZmlyc3RUYXJnZXROb2RlID0gdGFyZ2V0Tm9kZU9yTm9kZUFycmF5ICYmIGdldEZpcnN0Tm9kZUZyb21Qb3NzaWJsZUFycmF5KHRhcmdldE5vZGVPck5vZGVBcnJheSk7XG4gICAgICAgIHZhciB0ZW1wbGF0ZURvY3VtZW50ID0gKGZpcnN0VGFyZ2V0Tm9kZSB8fCB0ZW1wbGF0ZSB8fCB7fSkub3duZXJEb2N1bWVudDtcbiAgICAgICAgdmFyIHRlbXBsYXRlRW5naW5lVG9Vc2UgPSAob3B0aW9uc1sndGVtcGxhdGVFbmdpbmUnXSB8fCBfdGVtcGxhdGVFbmdpbmUpO1xuICAgICAgICBrby50ZW1wbGF0ZVJld3JpdGluZy5lbnN1cmVUZW1wbGF0ZUlzUmV3cml0dGVuKHRlbXBsYXRlLCB0ZW1wbGF0ZUVuZ2luZVRvVXNlLCB0ZW1wbGF0ZURvY3VtZW50KTtcbiAgICAgICAgdmFyIHJlbmRlcmVkTm9kZXNBcnJheSA9IHRlbXBsYXRlRW5naW5lVG9Vc2VbJ3JlbmRlclRlbXBsYXRlJ10odGVtcGxhdGUsIGJpbmRpbmdDb250ZXh0LCBvcHRpb25zLCB0ZW1wbGF0ZURvY3VtZW50KTtcblxuICAgICAgICAvLyBMb29zZWx5IGNoZWNrIHJlc3VsdCBpcyBhbiBhcnJheSBvZiBET00gbm9kZXNcbiAgICAgICAgaWYgKCh0eXBlb2YgcmVuZGVyZWROb2Rlc0FycmF5Lmxlbmd0aCAhPSBcIm51bWJlclwiKSB8fCAocmVuZGVyZWROb2Rlc0FycmF5Lmxlbmd0aCA+IDAgJiYgdHlwZW9mIHJlbmRlcmVkTm9kZXNBcnJheVswXS5ub2RlVHlwZSAhPSBcIm51bWJlclwiKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRlbXBsYXRlIGVuZ2luZSBtdXN0IHJldHVybiBhbiBhcnJheSBvZiBET00gbm9kZXNcIik7XG5cbiAgICAgICAgdmFyIGhhdmVBZGRlZE5vZGVzVG9QYXJlbnQgPSBmYWxzZTtcbiAgICAgICAgc3dpdGNoIChyZW5kZXJNb2RlKSB7XG4gICAgICAgICAgICBjYXNlIFwicmVwbGFjZUNoaWxkcmVuXCI6XG4gICAgICAgICAgICAgICAga28udmlydHVhbEVsZW1lbnRzLnNldERvbU5vZGVDaGlsZHJlbih0YXJnZXROb2RlT3JOb2RlQXJyYXksIHJlbmRlcmVkTm9kZXNBcnJheSk7XG4gICAgICAgICAgICAgICAgaGF2ZUFkZGVkTm9kZXNUb1BhcmVudCA9IHRydWU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwicmVwbGFjZU5vZGVcIjpcbiAgICAgICAgICAgICAgICBrby51dGlscy5yZXBsYWNlRG9tTm9kZXModGFyZ2V0Tm9kZU9yTm9kZUFycmF5LCByZW5kZXJlZE5vZGVzQXJyYXkpO1xuICAgICAgICAgICAgICAgIGhhdmVBZGRlZE5vZGVzVG9QYXJlbnQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcImlnbm9yZVRhcmdldE5vZGVcIjogYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gcmVuZGVyTW9kZTogXCIgKyByZW5kZXJNb2RlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChoYXZlQWRkZWROb2Rlc1RvUGFyZW50KSB7XG4gICAgICAgICAgICBhY3RpdmF0ZUJpbmRpbmdzT25Db250aW51b3VzTm9kZUFycmF5KHJlbmRlcmVkTm9kZXNBcnJheSwgYmluZGluZ0NvbnRleHQpO1xuICAgICAgICAgICAgaWYgKG9wdGlvbnNbJ2FmdGVyUmVuZGVyJ10pXG4gICAgICAgICAgICAgICAga28uZGVwZW5kZW5jeURldGVjdGlvbi5pZ25vcmUob3B0aW9uc1snYWZ0ZXJSZW5kZXInXSwgbnVsbCwgW3JlbmRlcmVkTm9kZXNBcnJheSwgYmluZGluZ0NvbnRleHRbJyRkYXRhJ11dKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZW5kZXJlZE5vZGVzQXJyYXk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVzb2x2ZVRlbXBsYXRlTmFtZSh0ZW1wbGF0ZSwgZGF0YSwgY29udGV4dCkge1xuICAgICAgICAvLyBUaGUgdGVtcGxhdGUgY2FuIGJlIHNwZWNpZmllZCBhczpcbiAgICAgICAgaWYgKGtvLmlzT2JzZXJ2YWJsZSh0ZW1wbGF0ZSkpIHtcbiAgICAgICAgICAgIC8vIDEuIEFuIG9ic2VydmFibGUsIHdpdGggc3RyaW5nIHZhbHVlXG4gICAgICAgICAgICByZXR1cm4gdGVtcGxhdGUoKTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdGVtcGxhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIC8vIDIuIEEgZnVuY3Rpb24gb2YgKGRhdGEsIGNvbnRleHQpIHJldHVybmluZyBhIHN0cmluZ1xuICAgICAgICAgICAgcmV0dXJuIHRlbXBsYXRlKGRhdGEsIGNvbnRleHQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gMy4gQSBzdHJpbmdcbiAgICAgICAgICAgIHJldHVybiB0ZW1wbGF0ZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGtvLnJlbmRlclRlbXBsYXRlID0gZnVuY3Rpb24gKHRlbXBsYXRlLCBkYXRhT3JCaW5kaW5nQ29udGV4dCwgb3B0aW9ucywgdGFyZ2V0Tm9kZU9yTm9kZUFycmF5LCByZW5kZXJNb2RlKSB7XG4gICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgICAgICBpZiAoKG9wdGlvbnNbJ3RlbXBsYXRlRW5naW5lJ10gfHwgX3RlbXBsYXRlRW5naW5lKSA9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTZXQgYSB0ZW1wbGF0ZSBlbmdpbmUgYmVmb3JlIGNhbGxpbmcgcmVuZGVyVGVtcGxhdGVcIik7XG4gICAgICAgIHJlbmRlck1vZGUgPSByZW5kZXJNb2RlIHx8IFwicmVwbGFjZUNoaWxkcmVuXCI7XG5cbiAgICAgICAgaWYgKHRhcmdldE5vZGVPck5vZGVBcnJheSkge1xuICAgICAgICAgICAgdmFyIGZpcnN0VGFyZ2V0Tm9kZSA9IGdldEZpcnN0Tm9kZUZyb21Qb3NzaWJsZUFycmF5KHRhcmdldE5vZGVPck5vZGVBcnJheSk7XG5cbiAgICAgICAgICAgIHZhciB3aGVuVG9EaXNwb3NlID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gKCFmaXJzdFRhcmdldE5vZGUpIHx8ICFrby51dGlscy5kb21Ob2RlSXNBdHRhY2hlZFRvRG9jdW1lbnQoZmlyc3RUYXJnZXROb2RlKTsgfTsgLy8gUGFzc2l2ZSBkaXNwb3NhbCAob24gbmV4dCBldmFsdWF0aW9uKVxuICAgICAgICAgICAgdmFyIGFjdGl2ZWx5RGlzcG9zZVdoZW5Ob2RlSXNSZW1vdmVkID0gKGZpcnN0VGFyZ2V0Tm9kZSAmJiByZW5kZXJNb2RlID09IFwicmVwbGFjZU5vZGVcIikgPyBmaXJzdFRhcmdldE5vZGUucGFyZW50Tm9kZSA6IGZpcnN0VGFyZ2V0Tm9kZTtcblxuICAgICAgICAgICAgcmV0dXJuIGtvLmRlcGVuZGVudE9ic2VydmFibGUoIC8vIFNvIHRoZSBET00gaXMgYXV0b21hdGljYWxseSB1cGRhdGVkIHdoZW4gYW55IGRlcGVuZGVuY3kgY2hhbmdlc1xuICAgICAgICAgICAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gRW5zdXJlIHdlJ3ZlIGdvdCBhIHByb3BlciBiaW5kaW5nIGNvbnRleHQgdG8gd29yayB3aXRoXG4gICAgICAgICAgICAgICAgICAgIHZhciBiaW5kaW5nQ29udGV4dCA9IChkYXRhT3JCaW5kaW5nQ29udGV4dCAmJiAoZGF0YU9yQmluZGluZ0NvbnRleHQgaW5zdGFuY2VvZiBrby5iaW5kaW5nQ29udGV4dCkpXG4gICAgICAgICAgICAgICAgICAgICAgICA/IGRhdGFPckJpbmRpbmdDb250ZXh0XG4gICAgICAgICAgICAgICAgICAgICAgICA6IG5ldyBrby5iaW5kaW5nQ29udGV4dChkYXRhT3JCaW5kaW5nQ29udGV4dCwgbnVsbCwgbnVsbCwgbnVsbCwgeyBcImV4cG9ydERlcGVuZGVuY2llc1wiOiB0cnVlIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgIHZhciB0ZW1wbGF0ZU5hbWUgPSByZXNvbHZlVGVtcGxhdGVOYW1lKHRlbXBsYXRlLCBiaW5kaW5nQ29udGV4dFsnJGRhdGEnXSwgYmluZGluZ0NvbnRleHQpLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVuZGVyZWROb2Rlc0FycmF5ID0gZXhlY3V0ZVRlbXBsYXRlKHRhcmdldE5vZGVPck5vZGVBcnJheSwgcmVuZGVyTW9kZSwgdGVtcGxhdGVOYW1lLCBiaW5kaW5nQ29udGV4dCwgb3B0aW9ucyk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlbmRlck1vZGUgPT0gXCJyZXBsYWNlTm9kZVwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXROb2RlT3JOb2RlQXJyYXkgPSByZW5kZXJlZE5vZGVzQXJyYXk7XG4gICAgICAgICAgICAgICAgICAgICAgICBmaXJzdFRhcmdldE5vZGUgPSBnZXRGaXJzdE5vZGVGcm9tUG9zc2libGVBcnJheSh0YXJnZXROb2RlT3JOb2RlQXJyYXkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgICAgIHsgZGlzcG9zZVdoZW46IHdoZW5Ub0Rpc3Bvc2UsIGRpc3Bvc2VXaGVuTm9kZUlzUmVtb3ZlZDogYWN0aXZlbHlEaXNwb3NlV2hlbk5vZGVJc1JlbW92ZWQgfVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIFdlIGRvbid0IHlldCBoYXZlIGEgRE9NIG5vZGUgdG8gZXZhbHVhdGUsIHNvIHVzZSBhIG1lbW8gYW5kIHJlbmRlciB0aGUgdGVtcGxhdGUgbGF0ZXIgd2hlbiB0aGVyZSBpcyBhIERPTSBub2RlXG4gICAgICAgICAgICByZXR1cm4ga28ubWVtb2l6YXRpb24ubWVtb2l6ZShmdW5jdGlvbiAoZG9tTm9kZSkge1xuICAgICAgICAgICAgICAgIGtvLnJlbmRlclRlbXBsYXRlKHRlbXBsYXRlLCBkYXRhT3JCaW5kaW5nQ29udGV4dCwgb3B0aW9ucywgZG9tTm9kZSwgXCJyZXBsYWNlTm9kZVwiKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIGtvLnJlbmRlclRlbXBsYXRlRm9yRWFjaCA9IGZ1bmN0aW9uICh0ZW1wbGF0ZSwgYXJyYXlPck9ic2VydmFibGVBcnJheSwgb3B0aW9ucywgdGFyZ2V0Tm9kZSwgcGFyZW50QmluZGluZ0NvbnRleHQpIHtcbiAgICAgICAgLy8gU2luY2Ugc2V0RG9tTm9kZUNoaWxkcmVuRnJvbUFycmF5TWFwcGluZyBhbHdheXMgY2FsbHMgZXhlY3V0ZVRlbXBsYXRlRm9yQXJyYXlJdGVtIGFuZCB0aGVuXG4gICAgICAgIC8vIGFjdGl2YXRlQmluZGluZ3NDYWxsYmFjayBmb3IgYWRkZWQgaXRlbXMsIHdlIGNhbiBzdG9yZSB0aGUgYmluZGluZyBjb250ZXh0IGluIHRoZSBmb3JtZXIgdG8gdXNlIGluIHRoZSBsYXR0ZXIuXG4gICAgICAgIHZhciBhcnJheUl0ZW1Db250ZXh0O1xuXG4gICAgICAgIC8vIFRoaXMgd2lsbCBiZSBjYWxsZWQgYnkgc2V0RG9tTm9kZUNoaWxkcmVuRnJvbUFycmF5TWFwcGluZyB0byBnZXQgdGhlIG5vZGVzIHRvIGFkZCB0byB0YXJnZXROb2RlXG4gICAgICAgIHZhciBleGVjdXRlVGVtcGxhdGVGb3JBcnJheUl0ZW0gPSBmdW5jdGlvbiAoYXJyYXlWYWx1ZSwgaW5kZXgpIHtcbiAgICAgICAgICAgIC8vIFN1cHBvcnQgc2VsZWN0aW5nIHRlbXBsYXRlIGFzIGEgZnVuY3Rpb24gb2YgdGhlIGRhdGEgYmVpbmcgcmVuZGVyZWRcbiAgICAgICAgICAgIGFycmF5SXRlbUNvbnRleHQgPSBwYXJlbnRCaW5kaW5nQ29udGV4dFsnY3JlYXRlQ2hpbGRDb250ZXh0J10oYXJyYXlWYWx1ZSwgb3B0aW9uc1snYXMnXSwgZnVuY3Rpb24oY29udGV4dCkge1xuICAgICAgICAgICAgICAgIGNvbnRleHRbJyRpbmRleCddID0gaW5kZXg7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgdmFyIHRlbXBsYXRlTmFtZSA9IHJlc29sdmVUZW1wbGF0ZU5hbWUodGVtcGxhdGUsIGFycmF5VmFsdWUsIGFycmF5SXRlbUNvbnRleHQpO1xuICAgICAgICAgICAgcmV0dXJuIGV4ZWN1dGVUZW1wbGF0ZShudWxsLCBcImlnbm9yZVRhcmdldE5vZGVcIiwgdGVtcGxhdGVOYW1lLCBhcnJheUl0ZW1Db250ZXh0LCBvcHRpb25zKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRoaXMgd2lsbCBiZSBjYWxsZWQgd2hlbmV2ZXIgc2V0RG9tTm9kZUNoaWxkcmVuRnJvbUFycmF5TWFwcGluZyBoYXMgYWRkZWQgbm9kZXMgdG8gdGFyZ2V0Tm9kZVxuICAgICAgICB2YXIgYWN0aXZhdGVCaW5kaW5nc0NhbGxiYWNrID0gZnVuY3Rpb24oYXJyYXlWYWx1ZSwgYWRkZWROb2Rlc0FycmF5LCBpbmRleCkge1xuICAgICAgICAgICAgYWN0aXZhdGVCaW5kaW5nc09uQ29udGludW91c05vZGVBcnJheShhZGRlZE5vZGVzQXJyYXksIGFycmF5SXRlbUNvbnRleHQpO1xuICAgICAgICAgICAgaWYgKG9wdGlvbnNbJ2FmdGVyUmVuZGVyJ10pXG4gICAgICAgICAgICAgICAgb3B0aW9uc1snYWZ0ZXJSZW5kZXInXShhZGRlZE5vZGVzQXJyYXksIGFycmF5VmFsdWUpO1xuXG4gICAgICAgICAgICAvLyByZWxlYXNlIHRoZSBcImNhY2hlXCIgdmFyaWFibGUsIHNvIHRoYXQgaXQgY2FuIGJlIGNvbGxlY3RlZCBieVxuICAgICAgICAgICAgLy8gdGhlIEdDIHdoZW4gaXRzIHZhbHVlIGlzbid0IHVzZWQgZnJvbSB3aXRoaW4gdGhlIGJpbmRpbmdzIGFueW1vcmUuXG4gICAgICAgICAgICBhcnJheUl0ZW1Db250ZXh0ID0gbnVsbDtcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4ga28uZGVwZW5kZW50T2JzZXJ2YWJsZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgdW53cmFwcGVkQXJyYXkgPSBrby51dGlscy51bndyYXBPYnNlcnZhYmxlKGFycmF5T3JPYnNlcnZhYmxlQXJyYXkpIHx8IFtdO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB1bndyYXBwZWRBcnJheS5sZW5ndGggPT0gXCJ1bmRlZmluZWRcIikgLy8gQ29lcmNlIHNpbmdsZSB2YWx1ZSBpbnRvIGFycmF5XG4gICAgICAgICAgICAgICAgdW53cmFwcGVkQXJyYXkgPSBbdW53cmFwcGVkQXJyYXldO1xuXG4gICAgICAgICAgICAvLyBGaWx0ZXIgb3V0IGFueSBlbnRyaWVzIG1hcmtlZCBhcyBkZXN0cm95ZWRcbiAgICAgICAgICAgIHZhciBmaWx0ZXJlZEFycmF5ID0ga28udXRpbHMuYXJyYXlGaWx0ZXIodW53cmFwcGVkQXJyYXksIGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gb3B0aW9uc1snaW5jbHVkZURlc3Ryb3llZCddIHx8IGl0ZW0gPT09IHVuZGVmaW5lZCB8fCBpdGVtID09PSBudWxsIHx8ICFrby51dGlscy51bndyYXBPYnNlcnZhYmxlKGl0ZW1bJ19kZXN0cm95J10pO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIC8vIENhbGwgc2V0RG9tTm9kZUNoaWxkcmVuRnJvbUFycmF5TWFwcGluZywgaWdub3JpbmcgYW55IG9ic2VydmFibGVzIHVud3JhcHBlZCB3aXRoaW4gKG1vc3QgbGlrZWx5IGZyb20gYSBjYWxsYmFjayBmdW5jdGlvbikuXG4gICAgICAgICAgICAvLyBJZiB0aGUgYXJyYXkgaXRlbXMgYXJlIG9ic2VydmFibGVzLCB0aG91Z2gsIHRoZXkgd2lsbCBiZSB1bndyYXBwZWQgaW4gZXhlY3V0ZVRlbXBsYXRlRm9yQXJyYXlJdGVtIGFuZCBtYW5hZ2VkIHdpdGhpbiBzZXREb21Ob2RlQ2hpbGRyZW5Gcm9tQXJyYXlNYXBwaW5nLlxuICAgICAgICAgICAga28uZGVwZW5kZW5jeURldGVjdGlvbi5pZ25vcmUoa28udXRpbHMuc2V0RG9tTm9kZUNoaWxkcmVuRnJvbUFycmF5TWFwcGluZywgbnVsbCwgW3RhcmdldE5vZGUsIGZpbHRlcmVkQXJyYXksIGV4ZWN1dGVUZW1wbGF0ZUZvckFycmF5SXRlbSwgb3B0aW9ucywgYWN0aXZhdGVCaW5kaW5nc0NhbGxiYWNrXSk7XG5cbiAgICAgICAgfSwgbnVsbCwgeyBkaXNwb3NlV2hlbk5vZGVJc1JlbW92ZWQ6IHRhcmdldE5vZGUgfSk7XG4gICAgfTtcblxuICAgIHZhciB0ZW1wbGF0ZUNvbXB1dGVkRG9tRGF0YUtleSA9IGtvLnV0aWxzLmRvbURhdGEubmV4dEtleSgpO1xuICAgIGZ1bmN0aW9uIGRpc3Bvc2VPbGRDb21wdXRlZEFuZFN0b3JlTmV3T25lKGVsZW1lbnQsIG5ld0NvbXB1dGVkKSB7XG4gICAgICAgIHZhciBvbGRDb21wdXRlZCA9IGtvLnV0aWxzLmRvbURhdGEuZ2V0KGVsZW1lbnQsIHRlbXBsYXRlQ29tcHV0ZWREb21EYXRhS2V5KTtcbiAgICAgICAgaWYgKG9sZENvbXB1dGVkICYmICh0eXBlb2Yob2xkQ29tcHV0ZWQuZGlzcG9zZSkgPT0gJ2Z1bmN0aW9uJykpXG4gICAgICAgICAgICBvbGRDb21wdXRlZC5kaXNwb3NlKCk7XG4gICAgICAgIGtvLnV0aWxzLmRvbURhdGEuc2V0KGVsZW1lbnQsIHRlbXBsYXRlQ29tcHV0ZWREb21EYXRhS2V5LCAobmV3Q29tcHV0ZWQgJiYgbmV3Q29tcHV0ZWQuaXNBY3RpdmUoKSkgPyBuZXdDb21wdXRlZCA6IHVuZGVmaW5lZCk7XG4gICAgfVxuXG4gICAga28uYmluZGluZ0hhbmRsZXJzWyd0ZW1wbGF0ZSddID0ge1xuICAgICAgICAnaW5pdCc6IGZ1bmN0aW9uKGVsZW1lbnQsIHZhbHVlQWNjZXNzb3IpIHtcbiAgICAgICAgICAgIC8vIFN1cHBvcnQgYW5vbnltb3VzIHRlbXBsYXRlc1xuICAgICAgICAgICAgdmFyIGJpbmRpbmdWYWx1ZSA9IGtvLnV0aWxzLnVud3JhcE9ic2VydmFibGUodmFsdWVBY2Nlc3NvcigpKTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgYmluZGluZ1ZhbHVlID09IFwic3RyaW5nXCIgfHwgYmluZGluZ1ZhbHVlWyduYW1lJ10pIHtcbiAgICAgICAgICAgICAgICAvLyBJdCdzIGEgbmFtZWQgdGVtcGxhdGUgLSBjbGVhciB0aGUgZWxlbWVudFxuICAgICAgICAgICAgICAgIGtvLnZpcnR1YWxFbGVtZW50cy5lbXB0eU5vZGUoZWxlbWVudCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCdub2RlcycgaW4gYmluZGluZ1ZhbHVlKSB7XG4gICAgICAgICAgICAgICAgLy8gV2UndmUgYmVlbiBnaXZlbiBhbiBhcnJheSBvZiBET00gbm9kZXMuIFNhdmUgdGhlbSBhcyB0aGUgdGVtcGxhdGUgc291cmNlLlxuICAgICAgICAgICAgICAgIC8vIFRoZXJlIGlzIG5vIGtub3duIHVzZSBjYXNlIGZvciB0aGUgbm9kZSBhcnJheSBiZWluZyBhbiBvYnNlcnZhYmxlIGFycmF5IChpZiB0aGUgb3V0cHV0XG4gICAgICAgICAgICAgICAgLy8gdmFyaWVzLCBwdXQgdGhhdCBiZWhhdmlvciAqaW50byogeW91ciB0ZW1wbGF0ZSAtIHRoYXQncyB3aGF0IHRlbXBsYXRlcyBhcmUgZm9yKSwgYW5kXG4gICAgICAgICAgICAgICAgLy8gdGhlIGltcGxlbWVudGF0aW9uIHdvdWxkIGJlIGEgbWVzcywgc28gYXNzZXJ0IHRoYXQgaXQncyBub3Qgb2JzZXJ2YWJsZS5cbiAgICAgICAgICAgICAgICB2YXIgbm9kZXMgPSBiaW5kaW5nVmFsdWVbJ25vZGVzJ10gfHwgW107XG4gICAgICAgICAgICAgICAgaWYgKGtvLmlzT2JzZXJ2YWJsZShub2RlcykpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgXCJub2Rlc1wiIG9wdGlvbiBtdXN0IGJlIGEgcGxhaW4sIG5vbi1vYnNlcnZhYmxlIGFycmF5LicpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgY29udGFpbmVyID0ga28udXRpbHMubW92ZUNsZWFuZWROb2Rlc1RvQ29udGFpbmVyRWxlbWVudChub2Rlcyk7IC8vIFRoaXMgYWxzbyByZW1vdmVzIHRoZSBub2RlcyBmcm9tIHRoZWlyIGN1cnJlbnQgcGFyZW50XG4gICAgICAgICAgICAgICAgbmV3IGtvLnRlbXBsYXRlU291cmNlcy5hbm9ueW1vdXNUZW1wbGF0ZShlbGVtZW50KVsnbm9kZXMnXShjb250YWluZXIpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBJdCdzIGFuIGFub255bW91cyB0ZW1wbGF0ZSAtIHN0b3JlIHRoZSBlbGVtZW50IGNvbnRlbnRzLCB0aGVuIGNsZWFyIHRoZSBlbGVtZW50XG4gICAgICAgICAgICAgICAgdmFyIHRlbXBsYXRlTm9kZXMgPSBrby52aXJ0dWFsRWxlbWVudHMuY2hpbGROb2RlcyhlbGVtZW50KSxcbiAgICAgICAgICAgICAgICAgICAgY29udGFpbmVyID0ga28udXRpbHMubW92ZUNsZWFuZWROb2Rlc1RvQ29udGFpbmVyRWxlbWVudCh0ZW1wbGF0ZU5vZGVzKTsgLy8gVGhpcyBhbHNvIHJlbW92ZXMgdGhlIG5vZGVzIGZyb20gdGhlaXIgY3VycmVudCBwYXJlbnRcbiAgICAgICAgICAgICAgICBuZXcga28udGVtcGxhdGVTb3VyY2VzLmFub255bW91c1RlbXBsYXRlKGVsZW1lbnQpWydub2RlcyddKGNvbnRhaW5lcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4geyAnY29udHJvbHNEZXNjZW5kYW50QmluZGluZ3MnOiB0cnVlIH07XG4gICAgICAgIH0sXG4gICAgICAgICd1cGRhdGUnOiBmdW5jdGlvbiAoZWxlbWVudCwgdmFsdWVBY2Nlc3NvciwgYWxsQmluZGluZ3MsIHZpZXdNb2RlbCwgYmluZGluZ0NvbnRleHQpIHtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IHZhbHVlQWNjZXNzb3IoKSxcbiAgICAgICAgICAgICAgICBvcHRpb25zID0ga28udXRpbHMudW53cmFwT2JzZXJ2YWJsZSh2YWx1ZSksXG4gICAgICAgICAgICAgICAgc2hvdWxkRGlzcGxheSA9IHRydWUsXG4gICAgICAgICAgICAgICAgdGVtcGxhdGVDb21wdXRlZCA9IG51bGwsXG4gICAgICAgICAgICAgICAgdGVtcGxhdGVOYW1lO1xuXG4gICAgICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgIHRlbXBsYXRlTmFtZSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGVtcGxhdGVOYW1lID0gb3B0aW9uc1snbmFtZSddO1xuXG4gICAgICAgICAgICAgICAgLy8gU3VwcG9ydCBcImlmXCIvXCJpZm5vdFwiIGNvbmRpdGlvbnNcbiAgICAgICAgICAgICAgICBpZiAoJ2lmJyBpbiBvcHRpb25zKVxuICAgICAgICAgICAgICAgICAgICBzaG91bGREaXNwbGF5ID0ga28udXRpbHMudW53cmFwT2JzZXJ2YWJsZShvcHRpb25zWydpZiddKTtcbiAgICAgICAgICAgICAgICBpZiAoc2hvdWxkRGlzcGxheSAmJiAnaWZub3QnIGluIG9wdGlvbnMpXG4gICAgICAgICAgICAgICAgICAgIHNob3VsZERpc3BsYXkgPSAha28udXRpbHMudW53cmFwT2JzZXJ2YWJsZShvcHRpb25zWydpZm5vdCddKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCdmb3JlYWNoJyBpbiBvcHRpb25zKSB7XG4gICAgICAgICAgICAgICAgLy8gUmVuZGVyIG9uY2UgZm9yIGVhY2ggZGF0YSBwb2ludCAodHJlYXRpbmcgZGF0YSBzZXQgYXMgZW1wdHkgaWYgc2hvdWxkRGlzcGxheT09ZmFsc2UpXG4gICAgICAgICAgICAgICAgdmFyIGRhdGFBcnJheSA9IChzaG91bGREaXNwbGF5ICYmIG9wdGlvbnNbJ2ZvcmVhY2gnXSkgfHwgW107XG4gICAgICAgICAgICAgICAgdGVtcGxhdGVDb21wdXRlZCA9IGtvLnJlbmRlclRlbXBsYXRlRm9yRWFjaCh0ZW1wbGF0ZU5hbWUgfHwgZWxlbWVudCwgZGF0YUFycmF5LCBvcHRpb25zLCBlbGVtZW50LCBiaW5kaW5nQ29udGV4dCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCFzaG91bGREaXNwbGF5KSB7XG4gICAgICAgICAgICAgICAga28udmlydHVhbEVsZW1lbnRzLmVtcHR5Tm9kZShlbGVtZW50KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gUmVuZGVyIG9uY2UgZm9yIHRoaXMgc2luZ2xlIGRhdGEgcG9pbnQgKG9yIHVzZSB0aGUgdmlld01vZGVsIGlmIG5vIGRhdGEgd2FzIHByb3ZpZGVkKVxuICAgICAgICAgICAgICAgIHZhciBpbm5lckJpbmRpbmdDb250ZXh0ID0gKCdkYXRhJyBpbiBvcHRpb25zKSA/XG4gICAgICAgICAgICAgICAgICAgIGJpbmRpbmdDb250ZXh0LmNyZWF0ZVN0YXRpY0NoaWxkQ29udGV4dChvcHRpb25zWydkYXRhJ10sIG9wdGlvbnNbJ2FzJ10pIDogIC8vIEdpdmVuIGFuIGV4cGxpdGl0ICdkYXRhJyB2YWx1ZSwgd2UgY3JlYXRlIGEgY2hpbGQgYmluZGluZyBjb250ZXh0IGZvciBpdFxuICAgICAgICAgICAgICAgICAgICBiaW5kaW5nQ29udGV4dDsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEdpdmVuIG5vIGV4cGxpY2l0ICdkYXRhJyB2YWx1ZSwgd2UgcmV0YWluIHRoZSBzYW1lIGJpbmRpbmcgY29udGV4dFxuICAgICAgICAgICAgICAgIHRlbXBsYXRlQ29tcHV0ZWQgPSBrby5yZW5kZXJUZW1wbGF0ZSh0ZW1wbGF0ZU5hbWUgfHwgZWxlbWVudCwgaW5uZXJCaW5kaW5nQ29udGV4dCwgb3B0aW9ucywgZWxlbWVudCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEl0IG9ubHkgbWFrZXMgc2Vuc2UgdG8gaGF2ZSBhIHNpbmdsZSB0ZW1wbGF0ZSBjb21wdXRlZCBwZXIgZWxlbWVudCAob3RoZXJ3aXNlIHdoaWNoIG9uZSBzaG91bGQgaGF2ZSBpdHMgb3V0cHV0IGRpc3BsYXllZD8pXG4gICAgICAgICAgICBkaXNwb3NlT2xkQ29tcHV0ZWRBbmRTdG9yZU5ld09uZShlbGVtZW50LCB0ZW1wbGF0ZUNvbXB1dGVkKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvLyBBbm9ueW1vdXMgdGVtcGxhdGVzIGNhbid0IGJlIHJld3JpdHRlbi4gR2l2ZSBhIG5pY2UgZXJyb3IgbWVzc2FnZSBpZiB5b3UgdHJ5IHRvIGRvIGl0LlxuICAgIGtvLmV4cHJlc3Npb25SZXdyaXRpbmcuYmluZGluZ1Jld3JpdGVWYWxpZGF0b3JzWyd0ZW1wbGF0ZSddID0gZnVuY3Rpb24oYmluZGluZ1ZhbHVlKSB7XG4gICAgICAgIHZhciBwYXJzZWRCaW5kaW5nVmFsdWUgPSBrby5leHByZXNzaW9uUmV3cml0aW5nLnBhcnNlT2JqZWN0TGl0ZXJhbChiaW5kaW5nVmFsdWUpO1xuXG4gICAgICAgIGlmICgocGFyc2VkQmluZGluZ1ZhbHVlLmxlbmd0aCA9PSAxKSAmJiBwYXJzZWRCaW5kaW5nVmFsdWVbMF1bJ3Vua25vd24nXSlcbiAgICAgICAgICAgIHJldHVybiBudWxsOyAvLyBJdCBsb29rcyBsaWtlIGEgc3RyaW5nIGxpdGVyYWwsIG5vdCBhbiBvYmplY3QgbGl0ZXJhbCwgc28gdHJlYXQgaXQgYXMgYSBuYW1lZCB0ZW1wbGF0ZSAod2hpY2ggaXMgYWxsb3dlZCBmb3IgcmV3cml0aW5nKVxuXG4gICAgICAgIGlmIChrby5leHByZXNzaW9uUmV3cml0aW5nLmtleVZhbHVlQXJyYXlDb250YWluc0tleShwYXJzZWRCaW5kaW5nVmFsdWUsIFwibmFtZVwiKSlcbiAgICAgICAgICAgIHJldHVybiBudWxsOyAvLyBOYW1lZCB0ZW1wbGF0ZXMgY2FuIGJlIHJld3JpdHRlbiwgc28gcmV0dXJuIFwibm8gZXJyb3JcIlxuICAgICAgICByZXR1cm4gXCJUaGlzIHRlbXBsYXRlIGVuZ2luZSBkb2VzIG5vdCBzdXBwb3J0IGFub255bW91cyB0ZW1wbGF0ZXMgbmVzdGVkIHdpdGhpbiBpdHMgdGVtcGxhdGVzXCI7XG4gICAgfTtcblxuICAgIGtvLnZpcnR1YWxFbGVtZW50cy5hbGxvd2VkQmluZGluZ3NbJ3RlbXBsYXRlJ10gPSB0cnVlO1xufSkoKTtcblxua28uZXhwb3J0U3ltYm9sKCdzZXRUZW1wbGF0ZUVuZ2luZScsIGtvLnNldFRlbXBsYXRlRW5naW5lKTtcbmtvLmV4cG9ydFN5bWJvbCgncmVuZGVyVGVtcGxhdGUnLCBrby5yZW5kZXJUZW1wbGF0ZSk7XG4vLyBHbyB0aHJvdWdoIHRoZSBpdGVtcyB0aGF0IGhhdmUgYmVlbiBhZGRlZCBhbmQgZGVsZXRlZCBhbmQgdHJ5IHRvIGZpbmQgbWF0Y2hlcyBiZXR3ZWVuIHRoZW0uXG5rby51dGlscy5maW5kTW92ZXNJbkFycmF5Q29tcGFyaXNvbiA9IGZ1bmN0aW9uIChsZWZ0LCByaWdodCwgbGltaXRGYWlsZWRDb21wYXJlcykge1xuICAgIGlmIChsZWZ0Lmxlbmd0aCAmJiByaWdodC5sZW5ndGgpIHtcbiAgICAgICAgdmFyIGZhaWxlZENvbXBhcmVzLCBsLCByLCBsZWZ0SXRlbSwgcmlnaHRJdGVtO1xuICAgICAgICBmb3IgKGZhaWxlZENvbXBhcmVzID0gbCA9IDA7ICghbGltaXRGYWlsZWRDb21wYXJlcyB8fCBmYWlsZWRDb21wYXJlcyA8IGxpbWl0RmFpbGVkQ29tcGFyZXMpICYmIChsZWZ0SXRlbSA9IGxlZnRbbF0pOyArK2wpIHtcbiAgICAgICAgICAgIGZvciAociA9IDA7IHJpZ2h0SXRlbSA9IHJpZ2h0W3JdOyArK3IpIHtcbiAgICAgICAgICAgICAgICBpZiAobGVmdEl0ZW1bJ3ZhbHVlJ10gPT09IHJpZ2h0SXRlbVsndmFsdWUnXSkge1xuICAgICAgICAgICAgICAgICAgICBsZWZ0SXRlbVsnbW92ZWQnXSA9IHJpZ2h0SXRlbVsnaW5kZXgnXTtcbiAgICAgICAgICAgICAgICAgICAgcmlnaHRJdGVtWydtb3ZlZCddID0gbGVmdEl0ZW1bJ2luZGV4J107XG4gICAgICAgICAgICAgICAgICAgIHJpZ2h0LnNwbGljZShyLCAxKTsgICAgICAgICAvLyBUaGlzIGl0ZW0gaXMgbWFya2VkIGFzIG1vdmVkOyBzbyByZW1vdmUgaXQgZnJvbSByaWdodCBsaXN0XG4gICAgICAgICAgICAgICAgICAgIGZhaWxlZENvbXBhcmVzID0gciA9IDA7ICAgICAvLyBSZXNldCBmYWlsZWQgY29tcGFyZXMgY291bnQgYmVjYXVzZSB3ZSdyZSBjaGVja2luZyBmb3IgY29uc2VjdXRpdmUgZmFpbHVyZXNcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmFpbGVkQ29tcGFyZXMgKz0gcjtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbmtvLnV0aWxzLmNvbXBhcmVBcnJheXMgPSAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBzdGF0dXNOb3RJbk9sZCA9ICdhZGRlZCcsIHN0YXR1c05vdEluTmV3ID0gJ2RlbGV0ZWQnO1xuXG4gICAgLy8gU2ltcGxlIGNhbGN1bGF0aW9uIGJhc2VkIG9uIExldmVuc2h0ZWluIGRpc3RhbmNlLlxuICAgIGZ1bmN0aW9uIGNvbXBhcmVBcnJheXMob2xkQXJyYXksIG5ld0FycmF5LCBvcHRpb25zKSB7XG4gICAgICAgIC8vIEZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LCBpZiB0aGUgdGhpcmQgYXJnIGlzIGFjdHVhbGx5IGEgYm9vbCwgaW50ZXJwcmV0XG4gICAgICAgIC8vIGl0IGFzIHRoZSBvbGQgcGFyYW1ldGVyICdkb250TGltaXRNb3ZlcycuIE5ld2VyIGNvZGUgc2hvdWxkIHVzZSB7IGRvbnRMaW1pdE1vdmVzOiB0cnVlIH0uXG4gICAgICAgIG9wdGlvbnMgPSAodHlwZW9mIG9wdGlvbnMgPT09ICdib29sZWFuJykgPyB7ICdkb250TGltaXRNb3Zlcyc6IG9wdGlvbnMgfSA6IChvcHRpb25zIHx8IHt9KTtcbiAgICAgICAgb2xkQXJyYXkgPSBvbGRBcnJheSB8fCBbXTtcbiAgICAgICAgbmV3QXJyYXkgPSBuZXdBcnJheSB8fCBbXTtcblxuICAgICAgICBpZiAob2xkQXJyYXkubGVuZ3RoIDwgbmV3QXJyYXkubGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuIGNvbXBhcmVTbWFsbEFycmF5VG9CaWdBcnJheShvbGRBcnJheSwgbmV3QXJyYXksIHN0YXR1c05vdEluT2xkLCBzdGF0dXNOb3RJbk5ldywgb3B0aW9ucyk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHJldHVybiBjb21wYXJlU21hbGxBcnJheVRvQmlnQXJyYXkobmV3QXJyYXksIG9sZEFycmF5LCBzdGF0dXNOb3RJbk5ldywgc3RhdHVzTm90SW5PbGQsIG9wdGlvbnMpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNvbXBhcmVTbWFsbEFycmF5VG9CaWdBcnJheShzbWxBcnJheSwgYmlnQXJyYXksIHN0YXR1c05vdEluU21sLCBzdGF0dXNOb3RJbkJpZywgb3B0aW9ucykge1xuICAgICAgICB2YXIgbXlNaW4gPSBNYXRoLm1pbixcbiAgICAgICAgICAgIG15TWF4ID0gTWF0aC5tYXgsXG4gICAgICAgICAgICBlZGl0RGlzdGFuY2VNYXRyaXggPSBbXSxcbiAgICAgICAgICAgIHNtbEluZGV4LCBzbWxJbmRleE1heCA9IHNtbEFycmF5Lmxlbmd0aCxcbiAgICAgICAgICAgIGJpZ0luZGV4LCBiaWdJbmRleE1heCA9IGJpZ0FycmF5Lmxlbmd0aCxcbiAgICAgICAgICAgIGNvbXBhcmVSYW5nZSA9IChiaWdJbmRleE1heCAtIHNtbEluZGV4TWF4KSB8fCAxLFxuICAgICAgICAgICAgbWF4RGlzdGFuY2UgPSBzbWxJbmRleE1heCArIGJpZ0luZGV4TWF4ICsgMSxcbiAgICAgICAgICAgIHRoaXNSb3csIGxhc3RSb3csXG4gICAgICAgICAgICBiaWdJbmRleE1heEZvclJvdywgYmlnSW5kZXhNaW5Gb3JSb3c7XG5cbiAgICAgICAgZm9yIChzbWxJbmRleCA9IDA7IHNtbEluZGV4IDw9IHNtbEluZGV4TWF4OyBzbWxJbmRleCsrKSB7XG4gICAgICAgICAgICBsYXN0Um93ID0gdGhpc1JvdztcbiAgICAgICAgICAgIGVkaXREaXN0YW5jZU1hdHJpeC5wdXNoKHRoaXNSb3cgPSBbXSk7XG4gICAgICAgICAgICBiaWdJbmRleE1heEZvclJvdyA9IG15TWluKGJpZ0luZGV4TWF4LCBzbWxJbmRleCArIGNvbXBhcmVSYW5nZSk7XG4gICAgICAgICAgICBiaWdJbmRleE1pbkZvclJvdyA9IG15TWF4KDAsIHNtbEluZGV4IC0gMSk7XG4gICAgICAgICAgICBmb3IgKGJpZ0luZGV4ID0gYmlnSW5kZXhNaW5Gb3JSb3c7IGJpZ0luZGV4IDw9IGJpZ0luZGV4TWF4Rm9yUm93OyBiaWdJbmRleCsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFiaWdJbmRleClcbiAgICAgICAgICAgICAgICAgICAgdGhpc1Jvd1tiaWdJbmRleF0gPSBzbWxJbmRleCArIDE7XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoIXNtbEluZGV4KSAgLy8gVG9wIHJvdyAtIHRyYW5zZm9ybSBlbXB0eSBhcnJheSBpbnRvIG5ldyBhcnJheSB2aWEgYWRkaXRpb25zXG4gICAgICAgICAgICAgICAgICAgIHRoaXNSb3dbYmlnSW5kZXhdID0gYmlnSW5kZXggKyAxO1xuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHNtbEFycmF5W3NtbEluZGV4IC0gMV0gPT09IGJpZ0FycmF5W2JpZ0luZGV4IC0gMV0pXG4gICAgICAgICAgICAgICAgICAgIHRoaXNSb3dbYmlnSW5kZXhdID0gbGFzdFJvd1tiaWdJbmRleCAtIDFdOyAgICAgICAgICAgICAgICAgIC8vIGNvcHkgdmFsdWUgKG5vIGVkaXQpXG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBub3J0aERpc3RhbmNlID0gbGFzdFJvd1tiaWdJbmRleF0gfHwgbWF4RGlzdGFuY2U7ICAgICAgIC8vIG5vdCBpbiBiaWcgKGRlbGV0aW9uKVxuICAgICAgICAgICAgICAgICAgICB2YXIgd2VzdERpc3RhbmNlID0gdGhpc1Jvd1tiaWdJbmRleCAtIDFdIHx8IG1heERpc3RhbmNlOyAgICAvLyBub3QgaW4gc21hbGwgKGFkZGl0aW9uKVxuICAgICAgICAgICAgICAgICAgICB0aGlzUm93W2JpZ0luZGV4XSA9IG15TWluKG5vcnRoRGlzdGFuY2UsIHdlc3REaXN0YW5jZSkgKyAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBlZGl0U2NyaXB0ID0gW10sIG1lTWludXNPbmUsIG5vdEluU21sID0gW10sIG5vdEluQmlnID0gW107XG4gICAgICAgIGZvciAoc21sSW5kZXggPSBzbWxJbmRleE1heCwgYmlnSW5kZXggPSBiaWdJbmRleE1heDsgc21sSW5kZXggfHwgYmlnSW5kZXg7KSB7XG4gICAgICAgICAgICBtZU1pbnVzT25lID0gZWRpdERpc3RhbmNlTWF0cml4W3NtbEluZGV4XVtiaWdJbmRleF0gLSAxO1xuICAgICAgICAgICAgaWYgKGJpZ0luZGV4ICYmIG1lTWludXNPbmUgPT09IGVkaXREaXN0YW5jZU1hdHJpeFtzbWxJbmRleF1bYmlnSW5kZXgtMV0pIHtcbiAgICAgICAgICAgICAgICBub3RJblNtbC5wdXNoKGVkaXRTY3JpcHRbZWRpdFNjcmlwdC5sZW5ndGhdID0geyAgICAgLy8gYWRkZWRcbiAgICAgICAgICAgICAgICAgICAgJ3N0YXR1cyc6IHN0YXR1c05vdEluU21sLFxuICAgICAgICAgICAgICAgICAgICAndmFsdWUnOiBiaWdBcnJheVstLWJpZ0luZGV4XSxcbiAgICAgICAgICAgICAgICAgICAgJ2luZGV4JzogYmlnSW5kZXggfSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHNtbEluZGV4ICYmIG1lTWludXNPbmUgPT09IGVkaXREaXN0YW5jZU1hdHJpeFtzbWxJbmRleCAtIDFdW2JpZ0luZGV4XSkge1xuICAgICAgICAgICAgICAgIG5vdEluQmlnLnB1c2goZWRpdFNjcmlwdFtlZGl0U2NyaXB0Lmxlbmd0aF0gPSB7ICAgICAvLyBkZWxldGVkXG4gICAgICAgICAgICAgICAgICAgICdzdGF0dXMnOiBzdGF0dXNOb3RJbkJpZyxcbiAgICAgICAgICAgICAgICAgICAgJ3ZhbHVlJzogc21sQXJyYXlbLS1zbWxJbmRleF0sXG4gICAgICAgICAgICAgICAgICAgICdpbmRleCc6IHNtbEluZGV4IH0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAtLWJpZ0luZGV4O1xuICAgICAgICAgICAgICAgIC0tc21sSW5kZXg7XG4gICAgICAgICAgICAgICAgaWYgKCFvcHRpb25zWydzcGFyc2UnXSkge1xuICAgICAgICAgICAgICAgICAgICBlZGl0U2NyaXB0LnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgJ3N0YXR1cyc6IFwicmV0YWluZWRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICd2YWx1ZSc6IGJpZ0FycmF5W2JpZ0luZGV4XSB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBTZXQgYSBsaW1pdCBvbiB0aGUgbnVtYmVyIG9mIGNvbnNlY3V0aXZlIG5vbi1tYXRjaGluZyBjb21wYXJpc29uczsgaGF2aW5nIGl0IGEgbXVsdGlwbGUgb2ZcbiAgICAgICAgLy8gc21sSW5kZXhNYXgga2VlcHMgdGhlIHRpbWUgY29tcGxleGl0eSBvZiB0aGlzIGFsZ29yaXRobSBsaW5lYXIuXG4gICAgICAgIGtvLnV0aWxzLmZpbmRNb3Zlc0luQXJyYXlDb21wYXJpc29uKG5vdEluQmlnLCBub3RJblNtbCwgIW9wdGlvbnNbJ2RvbnRMaW1pdE1vdmVzJ10gJiYgc21sSW5kZXhNYXggKiAxMCk7XG5cbiAgICAgICAgcmV0dXJuIGVkaXRTY3JpcHQucmV2ZXJzZSgpO1xuICAgIH1cblxuICAgIHJldHVybiBjb21wYXJlQXJyYXlzO1xufSkoKTtcblxua28uZXhwb3J0U3ltYm9sKCd1dGlscy5jb21wYXJlQXJyYXlzJywga28udXRpbHMuY29tcGFyZUFycmF5cyk7XG4oZnVuY3Rpb24gKCkge1xuICAgIC8vIE9iamVjdGl2ZTpcbiAgICAvLyAqIEdpdmVuIGFuIGlucHV0IGFycmF5LCBhIGNvbnRhaW5lciBET00gbm9kZSwgYW5kIGEgZnVuY3Rpb24gZnJvbSBhcnJheSBlbGVtZW50cyB0byBhcnJheXMgb2YgRE9NIG5vZGVzLFxuICAgIC8vICAgbWFwIHRoZSBhcnJheSBlbGVtZW50cyB0byBhcnJheXMgb2YgRE9NIG5vZGVzLCBjb25jYXRlbmF0ZSB0b2dldGhlciBhbGwgdGhlc2UgYXJyYXlzLCBhbmQgdXNlIHRoZW0gdG8gcG9wdWxhdGUgdGhlIGNvbnRhaW5lciBET00gbm9kZVxuICAgIC8vICogTmV4dCB0aW1lIHdlJ3JlIGdpdmVuIHRoZSBzYW1lIGNvbWJpbmF0aW9uIG9mIHRoaW5ncyAod2l0aCB0aGUgYXJyYXkgcG9zc2libHkgaGF2aW5nIG11dGF0ZWQpLCB1cGRhdGUgdGhlIGNvbnRhaW5lciBET00gbm9kZVxuICAgIC8vICAgc28gdGhhdCBpdHMgY2hpbGRyZW4gaXMgYWdhaW4gdGhlIGNvbmNhdGVuYXRpb24gb2YgdGhlIG1hcHBpbmdzIG9mIHRoZSBhcnJheSBlbGVtZW50cywgYnV0IGRvbid0IHJlLW1hcCBhbnkgYXJyYXkgZWxlbWVudHMgdGhhdCB3ZVxuICAgIC8vICAgcHJldmlvdXNseSBtYXBwZWQgLSByZXRhaW4gdGhvc2Ugbm9kZXMsIGFuZCBqdXN0IGluc2VydC9kZWxldGUgb3RoZXIgb25lc1xuXG4gICAgLy8gXCJjYWxsYmFja0FmdGVyQWRkaW5nTm9kZXNcIiB3aWxsIGJlIGludm9rZWQgYWZ0ZXIgYW55IFwibWFwcGluZ1wiLWdlbmVyYXRlZCBub2RlcyBhcmUgaW5zZXJ0ZWQgaW50byB0aGUgY29udGFpbmVyIG5vZGVcbiAgICAvLyBZb3UgY2FuIHVzZSB0aGlzLCBmb3IgZXhhbXBsZSwgdG8gYWN0aXZhdGUgYmluZGluZ3Mgb24gdGhvc2Ugbm9kZXMuXG5cbiAgICBmdW5jdGlvbiBtYXBOb2RlQW5kUmVmcmVzaFdoZW5DaGFuZ2VkKGNvbnRhaW5lck5vZGUsIG1hcHBpbmcsIHZhbHVlVG9NYXAsIGNhbGxiYWNrQWZ0ZXJBZGRpbmdOb2RlcywgaW5kZXgpIHtcbiAgICAgICAgLy8gTWFwIHRoaXMgYXJyYXkgdmFsdWUgaW5zaWRlIGEgZGVwZW5kZW50T2JzZXJ2YWJsZSBzbyB3ZSByZS1tYXAgd2hlbiBhbnkgZGVwZW5kZW5jeSBjaGFuZ2VzXG4gICAgICAgIHZhciBtYXBwZWROb2RlcyA9IFtdO1xuICAgICAgICB2YXIgZGVwZW5kZW50T2JzZXJ2YWJsZSA9IGtvLmRlcGVuZGVudE9ic2VydmFibGUoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgbmV3TWFwcGVkTm9kZXMgPSBtYXBwaW5nKHZhbHVlVG9NYXAsIGluZGV4LCBrby51dGlscy5maXhVcENvbnRpbnVvdXNOb2RlQXJyYXkobWFwcGVkTm9kZXMsIGNvbnRhaW5lck5vZGUpKSB8fCBbXTtcblxuICAgICAgICAgICAgLy8gT24gc3Vic2VxdWVudCBldmFsdWF0aW9ucywganVzdCByZXBsYWNlIHRoZSBwcmV2aW91c2x5LWluc2VydGVkIERPTSBub2Rlc1xuICAgICAgICAgICAgaWYgKG1hcHBlZE5vZGVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBrby51dGlscy5yZXBsYWNlRG9tTm9kZXMobWFwcGVkTm9kZXMsIG5ld01hcHBlZE5vZGVzKTtcbiAgICAgICAgICAgICAgICBpZiAoY2FsbGJhY2tBZnRlckFkZGluZ05vZGVzKVxuICAgICAgICAgICAgICAgICAgICBrby5kZXBlbmRlbmN5RGV0ZWN0aW9uLmlnbm9yZShjYWxsYmFja0FmdGVyQWRkaW5nTm9kZXMsIG51bGwsIFt2YWx1ZVRvTWFwLCBuZXdNYXBwZWROb2RlcywgaW5kZXhdKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gUmVwbGFjZSB0aGUgY29udGVudHMgb2YgdGhlIG1hcHBlZE5vZGVzIGFycmF5LCB0aGVyZWJ5IHVwZGF0aW5nIHRoZSByZWNvcmRcbiAgICAgICAgICAgIC8vIG9mIHdoaWNoIG5vZGVzIHdvdWxkIGJlIGRlbGV0ZWQgaWYgdmFsdWVUb01hcCB3YXMgaXRzZWxmIGxhdGVyIHJlbW92ZWRcbiAgICAgICAgICAgIG1hcHBlZE5vZGVzLmxlbmd0aCA9IDA7XG4gICAgICAgICAgICBrby51dGlscy5hcnJheVB1c2hBbGwobWFwcGVkTm9kZXMsIG5ld01hcHBlZE5vZGVzKTtcbiAgICAgICAgfSwgbnVsbCwgeyBkaXNwb3NlV2hlbk5vZGVJc1JlbW92ZWQ6IGNvbnRhaW5lck5vZGUsIGRpc3Bvc2VXaGVuOiBmdW5jdGlvbigpIHsgcmV0dXJuICFrby51dGlscy5hbnlEb21Ob2RlSXNBdHRhY2hlZFRvRG9jdW1lbnQobWFwcGVkTm9kZXMpOyB9IH0pO1xuICAgICAgICByZXR1cm4geyBtYXBwZWROb2RlcyA6IG1hcHBlZE5vZGVzLCBkZXBlbmRlbnRPYnNlcnZhYmxlIDogKGRlcGVuZGVudE9ic2VydmFibGUuaXNBY3RpdmUoKSA/IGRlcGVuZGVudE9ic2VydmFibGUgOiB1bmRlZmluZWQpIH07XG4gICAgfVxuXG4gICAgdmFyIGxhc3RNYXBwaW5nUmVzdWx0RG9tRGF0YUtleSA9IGtvLnV0aWxzLmRvbURhdGEubmV4dEtleSgpLFxuICAgICAgICBkZWxldGVkSXRlbUR1bW15VmFsdWUgPSBrby51dGlscy5kb21EYXRhLm5leHRLZXkoKTtcblxuICAgIGtvLnV0aWxzLnNldERvbU5vZGVDaGlsZHJlbkZyb21BcnJheU1hcHBpbmcgPSBmdW5jdGlvbiAoZG9tTm9kZSwgYXJyYXksIG1hcHBpbmcsIG9wdGlvbnMsIGNhbGxiYWNrQWZ0ZXJBZGRpbmdOb2Rlcykge1xuICAgICAgICAvLyBDb21wYXJlIHRoZSBwcm92aWRlZCBhcnJheSBhZ2FpbnN0IHRoZSBwcmV2aW91cyBvbmVcbiAgICAgICAgYXJyYXkgPSBhcnJheSB8fCBbXTtcbiAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgICAgIHZhciBpc0ZpcnN0RXhlY3V0aW9uID0ga28udXRpbHMuZG9tRGF0YS5nZXQoZG9tTm9kZSwgbGFzdE1hcHBpbmdSZXN1bHREb21EYXRhS2V5KSA9PT0gdW5kZWZpbmVkO1xuICAgICAgICB2YXIgbGFzdE1hcHBpbmdSZXN1bHQgPSBrby51dGlscy5kb21EYXRhLmdldChkb21Ob2RlLCBsYXN0TWFwcGluZ1Jlc3VsdERvbURhdGFLZXkpIHx8IFtdO1xuICAgICAgICB2YXIgbGFzdEFycmF5ID0ga28udXRpbHMuYXJyYXlNYXAobGFzdE1hcHBpbmdSZXN1bHQsIGZ1bmN0aW9uICh4KSB7IHJldHVybiB4LmFycmF5RW50cnk7IH0pO1xuICAgICAgICB2YXIgZWRpdFNjcmlwdCA9IGtvLnV0aWxzLmNvbXBhcmVBcnJheXMobGFzdEFycmF5LCBhcnJheSwgb3B0aW9uc1snZG9udExpbWl0TW92ZXMnXSk7XG5cbiAgICAgICAgLy8gQnVpbGQgdGhlIG5ldyBtYXBwaW5nIHJlc3VsdFxuICAgICAgICB2YXIgbmV3TWFwcGluZ1Jlc3VsdCA9IFtdO1xuICAgICAgICB2YXIgbGFzdE1hcHBpbmdSZXN1bHRJbmRleCA9IDA7XG4gICAgICAgIHZhciBuZXdNYXBwaW5nUmVzdWx0SW5kZXggPSAwO1xuXG4gICAgICAgIHZhciBub2Rlc1RvRGVsZXRlID0gW107XG4gICAgICAgIHZhciBpdGVtc1RvUHJvY2VzcyA9IFtdO1xuICAgICAgICB2YXIgaXRlbXNGb3JCZWZvcmVSZW1vdmVDYWxsYmFja3MgPSBbXTtcbiAgICAgICAgdmFyIGl0ZW1zRm9yTW92ZUNhbGxiYWNrcyA9IFtdO1xuICAgICAgICB2YXIgaXRlbXNGb3JBZnRlckFkZENhbGxiYWNrcyA9IFtdO1xuICAgICAgICB2YXIgbWFwRGF0YTtcblxuICAgICAgICBmdW5jdGlvbiBpdGVtTW92ZWRPclJldGFpbmVkKGVkaXRTY3JpcHRJbmRleCwgb2xkUG9zaXRpb24pIHtcbiAgICAgICAgICAgIG1hcERhdGEgPSBsYXN0TWFwcGluZ1Jlc3VsdFtvbGRQb3NpdGlvbl07XG4gICAgICAgICAgICBpZiAobmV3TWFwcGluZ1Jlc3VsdEluZGV4ICE9PSBvbGRQb3NpdGlvbilcbiAgICAgICAgICAgICAgICBpdGVtc0Zvck1vdmVDYWxsYmFja3NbZWRpdFNjcmlwdEluZGV4XSA9IG1hcERhdGE7XG4gICAgICAgICAgICAvLyBTaW5jZSB1cGRhdGluZyB0aGUgaW5kZXggbWlnaHQgY2hhbmdlIHRoZSBub2RlcywgZG8gc28gYmVmb3JlIGNhbGxpbmcgZml4VXBDb250aW51b3VzTm9kZUFycmF5XG4gICAgICAgICAgICBtYXBEYXRhLmluZGV4T2JzZXJ2YWJsZShuZXdNYXBwaW5nUmVzdWx0SW5kZXgrKyk7XG4gICAgICAgICAgICBrby51dGlscy5maXhVcENvbnRpbnVvdXNOb2RlQXJyYXkobWFwRGF0YS5tYXBwZWROb2RlcywgZG9tTm9kZSk7XG4gICAgICAgICAgICBuZXdNYXBwaW5nUmVzdWx0LnB1c2gobWFwRGF0YSk7XG4gICAgICAgICAgICBpdGVtc1RvUHJvY2Vzcy5wdXNoKG1hcERhdGEpO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gY2FsbENhbGxiYWNrKGNhbGxiYWNrLCBpdGVtcykge1xuICAgICAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIG4gPSBpdGVtcy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGl0ZW1zW2ldKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBrby51dGlscy5hcnJheUZvckVhY2goaXRlbXNbaV0ubWFwcGVkTm9kZXMsIGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhub2RlLCBpLCBpdGVtc1tpXS5hcnJheUVudHJ5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGVkaXRTY3JpcHRJdGVtLCBtb3ZlZEluZGV4OyBlZGl0U2NyaXB0SXRlbSA9IGVkaXRTY3JpcHRbaV07IGkrKykge1xuICAgICAgICAgICAgbW92ZWRJbmRleCA9IGVkaXRTY3JpcHRJdGVtWydtb3ZlZCddO1xuICAgICAgICAgICAgc3dpdGNoIChlZGl0U2NyaXB0SXRlbVsnc3RhdHVzJ10pIHtcbiAgICAgICAgICAgICAgICBjYXNlIFwiZGVsZXRlZFwiOlxuICAgICAgICAgICAgICAgICAgICBpZiAobW92ZWRJbmRleCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXBEYXRhID0gbGFzdE1hcHBpbmdSZXN1bHRbbGFzdE1hcHBpbmdSZXN1bHRJbmRleF07XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFN0b3AgdHJhY2tpbmcgY2hhbmdlcyB0byB0aGUgbWFwcGluZyBmb3IgdGhlc2Ugbm9kZXNcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtYXBEYXRhLmRlcGVuZGVudE9ic2VydmFibGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXBEYXRhLmRlcGVuZGVudE9ic2VydmFibGUuZGlzcG9zZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hcERhdGEuZGVwZW5kZW50T2JzZXJ2YWJsZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gUXVldWUgdGhlc2Ugbm9kZXMgZm9yIGxhdGVyIHJlbW92YWxcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChrby51dGlscy5maXhVcENvbnRpbnVvdXNOb2RlQXJyYXkobWFwRGF0YS5tYXBwZWROb2RlcywgZG9tTm9kZSkubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbnNbJ2JlZm9yZVJlbW92ZSddKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld01hcHBpbmdSZXN1bHQucHVzaChtYXBEYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXRlbXNUb1Byb2Nlc3MucHVzaChtYXBEYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1hcERhdGEuYXJyYXlFbnRyeSA9PT0gZGVsZXRlZEl0ZW1EdW1teVZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXBEYXRhID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW1zRm9yQmVmb3JlUmVtb3ZlQ2FsbGJhY2tzW2ldID0gbWFwRGF0YTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobWFwRGF0YSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2Rlc1RvRGVsZXRlLnB1c2guYXBwbHkobm9kZXNUb0RlbGV0ZSwgbWFwRGF0YS5tYXBwZWROb2Rlcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGxhc3RNYXBwaW5nUmVzdWx0SW5kZXgrKztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICBjYXNlIFwicmV0YWluZWRcIjpcbiAgICAgICAgICAgICAgICAgICAgaXRlbU1vdmVkT3JSZXRhaW5lZChpLCBsYXN0TWFwcGluZ1Jlc3VsdEluZGV4KyspO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgIGNhc2UgXCJhZGRlZFwiOlxuICAgICAgICAgICAgICAgICAgICBpZiAobW92ZWRJbmRleCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpdGVtTW92ZWRPclJldGFpbmVkKGksIG1vdmVkSW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWFwRGF0YSA9IHsgYXJyYXlFbnRyeTogZWRpdFNjcmlwdEl0ZW1bJ3ZhbHVlJ10sIGluZGV4T2JzZXJ2YWJsZToga28ub2JzZXJ2YWJsZShuZXdNYXBwaW5nUmVzdWx0SW5kZXgrKykgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld01hcHBpbmdSZXN1bHQucHVzaChtYXBEYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW1zVG9Qcm9jZXNzLnB1c2gobWFwRGF0YSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWlzRmlyc3RFeGVjdXRpb24pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaXRlbXNGb3JBZnRlckFkZENhbGxiYWNrc1tpXSA9IG1hcERhdGE7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBTdG9yZSBhIGNvcHkgb2YgdGhlIGFycmF5IGl0ZW1zIHdlIGp1c3QgY29uc2lkZXJlZCBzbyB3ZSBjYW4gZGlmZmVyZW5jZSBpdCBuZXh0IHRpbWVcbiAgICAgICAga28udXRpbHMuZG9tRGF0YS5zZXQoZG9tTm9kZSwgbGFzdE1hcHBpbmdSZXN1bHREb21EYXRhS2V5LCBuZXdNYXBwaW5nUmVzdWx0KTtcblxuICAgICAgICAvLyBDYWxsIGJlZm9yZU1vdmUgZmlyc3QgYmVmb3JlIGFueSBjaGFuZ2VzIGhhdmUgYmVlbiBtYWRlIHRvIHRoZSBET01cbiAgICAgICAgY2FsbENhbGxiYWNrKG9wdGlvbnNbJ2JlZm9yZU1vdmUnXSwgaXRlbXNGb3JNb3ZlQ2FsbGJhY2tzKTtcblxuICAgICAgICAvLyBOZXh0IHJlbW92ZSBub2RlcyBmb3IgZGVsZXRlZCBpdGVtcyAob3IganVzdCBjbGVhbiBpZiB0aGVyZSdzIGEgYmVmb3JlUmVtb3ZlIGNhbGxiYWNrKVxuICAgICAgICBrby51dGlscy5hcnJheUZvckVhY2gobm9kZXNUb0RlbGV0ZSwgb3B0aW9uc1snYmVmb3JlUmVtb3ZlJ10gPyBrby5jbGVhbk5vZGUgOiBrby5yZW1vdmVOb2RlKTtcblxuICAgICAgICAvLyBOZXh0IGFkZC9yZW9yZGVyIHRoZSByZW1haW5pbmcgaXRlbXMgKHdpbGwgaW5jbHVkZSBkZWxldGVkIGl0ZW1zIGlmIHRoZXJlJ3MgYSBiZWZvcmVSZW1vdmUgY2FsbGJhY2spXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBuZXh0Tm9kZSA9IGtvLnZpcnR1YWxFbGVtZW50cy5maXJzdENoaWxkKGRvbU5vZGUpLCBsYXN0Tm9kZSwgbm9kZTsgbWFwRGF0YSA9IGl0ZW1zVG9Qcm9jZXNzW2ldOyBpKyspIHtcbiAgICAgICAgICAgIC8vIEdldCBub2RlcyBmb3IgbmV3bHkgYWRkZWQgaXRlbXNcbiAgICAgICAgICAgIGlmICghbWFwRGF0YS5tYXBwZWROb2RlcylcbiAgICAgICAgICAgICAgICBrby51dGlscy5leHRlbmQobWFwRGF0YSwgbWFwTm9kZUFuZFJlZnJlc2hXaGVuQ2hhbmdlZChkb21Ob2RlLCBtYXBwaW5nLCBtYXBEYXRhLmFycmF5RW50cnksIGNhbGxiYWNrQWZ0ZXJBZGRpbmdOb2RlcywgbWFwRGF0YS5pbmRleE9ic2VydmFibGUpKTtcblxuICAgICAgICAgICAgLy8gUHV0IG5vZGVzIGluIHRoZSByaWdodCBwbGFjZSBpZiB0aGV5IGFyZW4ndCB0aGVyZSBhbHJlYWR5XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgbm9kZSA9IG1hcERhdGEubWFwcGVkTm9kZXNbal07IG5leHROb2RlID0gbm9kZS5uZXh0U2libGluZywgbGFzdE5vZGUgPSBub2RlLCBqKyspIHtcbiAgICAgICAgICAgICAgICBpZiAobm9kZSAhPT0gbmV4dE5vZGUpXG4gICAgICAgICAgICAgICAgICAgIGtvLnZpcnR1YWxFbGVtZW50cy5pbnNlcnRBZnRlcihkb21Ob2RlLCBub2RlLCBsYXN0Tm9kZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFJ1biB0aGUgY2FsbGJhY2tzIGZvciBuZXdseSBhZGRlZCBub2RlcyAoZm9yIGV4YW1wbGUsIHRvIGFwcGx5IGJpbmRpbmdzLCBldGMuKVxuICAgICAgICAgICAgaWYgKCFtYXBEYXRhLmluaXRpYWxpemVkICYmIGNhbGxiYWNrQWZ0ZXJBZGRpbmdOb2Rlcykge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrQWZ0ZXJBZGRpbmdOb2RlcyhtYXBEYXRhLmFycmF5RW50cnksIG1hcERhdGEubWFwcGVkTm9kZXMsIG1hcERhdGEuaW5kZXhPYnNlcnZhYmxlKTtcbiAgICAgICAgICAgICAgICBtYXBEYXRhLmluaXRpYWxpemVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIElmIHRoZXJlJ3MgYSBiZWZvcmVSZW1vdmUgY2FsbGJhY2ssIGNhbGwgaXQgYWZ0ZXIgcmVvcmRlcmluZy5cbiAgICAgICAgLy8gTm90ZSB0aGF0IHdlIGFzc3VtZSB0aGF0IHRoZSBiZWZvcmVSZW1vdmUgY2FsbGJhY2sgd2lsbCB1c3VhbGx5IGJlIHVzZWQgdG8gcmVtb3ZlIHRoZSBub2RlcyB1c2luZ1xuICAgICAgICAvLyBzb21lIHNvcnQgb2YgYW5pbWF0aW9uLCB3aGljaCBpcyB3aHkgd2UgZmlyc3QgcmVvcmRlciB0aGUgbm9kZXMgdGhhdCB3aWxsIGJlIHJlbW92ZWQuIElmIHRoZVxuICAgICAgICAvLyBjYWxsYmFjayBpbnN0ZWFkIHJlbW92ZXMgdGhlIG5vZGVzIHJpZ2h0IGF3YXksIGl0IHdvdWxkIGJlIG1vcmUgZWZmaWNpZW50IHRvIHNraXAgcmVvcmRlcmluZyB0aGVtLlxuICAgICAgICAvLyBQZXJoYXBzIHdlJ2xsIG1ha2UgdGhhdCBjaGFuZ2UgaW4gdGhlIGZ1dHVyZSBpZiB0aGlzIHNjZW5hcmlvIGJlY29tZXMgbW9yZSBjb21tb24uXG4gICAgICAgIGNhbGxDYWxsYmFjayhvcHRpb25zWydiZWZvcmVSZW1vdmUnXSwgaXRlbXNGb3JCZWZvcmVSZW1vdmVDYWxsYmFja3MpO1xuXG4gICAgICAgIC8vIFJlcGxhY2UgdGhlIHN0b3JlZCB2YWx1ZXMgb2YgZGVsZXRlZCBpdGVtcyB3aXRoIGEgZHVtbXkgdmFsdWUuIFRoaXMgcHJvdmlkZXMgdHdvIGJlbmVmaXRzOiBpdCBtYXJrcyB0aGlzIGl0ZW1cbiAgICAgICAgLy8gYXMgYWxyZWFkeSBcInJlbW92ZWRcIiBzbyB3ZSB3b24ndCBjYWxsIGJlZm9yZVJlbW92ZSBmb3IgaXQgYWdhaW4sIGFuZCBpdCBlbnN1cmVzIHRoYXQgdGhlIGl0ZW0gd29uJ3QgbWF0Y2ggdXBcbiAgICAgICAgLy8gd2l0aCBhbiBhY3R1YWwgaXRlbSBpbiB0aGUgYXJyYXkgYW5kIGFwcGVhciBhcyBcInJldGFpbmVkXCIgb3IgXCJtb3ZlZFwiLlxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgaXRlbXNGb3JCZWZvcmVSZW1vdmVDYWxsYmFja3MubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIGlmIChpdGVtc0ZvckJlZm9yZVJlbW92ZUNhbGxiYWNrc1tpXSkge1xuICAgICAgICAgICAgICAgIGl0ZW1zRm9yQmVmb3JlUmVtb3ZlQ2FsbGJhY2tzW2ldLmFycmF5RW50cnkgPSBkZWxldGVkSXRlbUR1bW15VmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBGaW5hbGx5IGNhbGwgYWZ0ZXJNb3ZlIGFuZCBhZnRlckFkZCBjYWxsYmFja3NcbiAgICAgICAgY2FsbENhbGxiYWNrKG9wdGlvbnNbJ2FmdGVyTW92ZSddLCBpdGVtc0Zvck1vdmVDYWxsYmFja3MpO1xuICAgICAgICBjYWxsQ2FsbGJhY2sob3B0aW9uc1snYWZ0ZXJBZGQnXSwgaXRlbXNGb3JBZnRlckFkZENhbGxiYWNrcyk7XG4gICAgfVxufSkoKTtcblxua28uZXhwb3J0U3ltYm9sKCd1dGlscy5zZXREb21Ob2RlQ2hpbGRyZW5Gcm9tQXJyYXlNYXBwaW5nJywga28udXRpbHMuc2V0RG9tTm9kZUNoaWxkcmVuRnJvbUFycmF5TWFwcGluZyk7XG5rby5uYXRpdmVUZW1wbGF0ZUVuZ2luZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzWydhbGxvd1RlbXBsYXRlUmV3cml0aW5nJ10gPSBmYWxzZTtcbn1cblxua28ubmF0aXZlVGVtcGxhdGVFbmdpbmUucHJvdG90eXBlID0gbmV3IGtvLnRlbXBsYXRlRW5naW5lKCk7XG5rby5uYXRpdmVUZW1wbGF0ZUVuZ2luZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBrby5uYXRpdmVUZW1wbGF0ZUVuZ2luZTtcbmtvLm5hdGl2ZVRlbXBsYXRlRW5naW5lLnByb3RvdHlwZVsncmVuZGVyVGVtcGxhdGVTb3VyY2UnXSA9IGZ1bmN0aW9uICh0ZW1wbGF0ZVNvdXJjZSwgYmluZGluZ0NvbnRleHQsIG9wdGlvbnMsIHRlbXBsYXRlRG9jdW1lbnQpIHtcbiAgICB2YXIgdXNlTm9kZXNJZkF2YWlsYWJsZSA9ICEoa28udXRpbHMuaWVWZXJzaW9uIDwgOSksIC8vIElFPDkgY2xvbmVOb2RlIGRvZXNuJ3Qgd29yayBwcm9wZXJseVxuICAgICAgICB0ZW1wbGF0ZU5vZGVzRnVuYyA9IHVzZU5vZGVzSWZBdmFpbGFibGUgPyB0ZW1wbGF0ZVNvdXJjZVsnbm9kZXMnXSA6IG51bGwsXG4gICAgICAgIHRlbXBsYXRlTm9kZXMgPSB0ZW1wbGF0ZU5vZGVzRnVuYyA/IHRlbXBsYXRlU291cmNlWydub2RlcyddKCkgOiBudWxsO1xuXG4gICAgaWYgKHRlbXBsYXRlTm9kZXMpIHtcbiAgICAgICAgcmV0dXJuIGtvLnV0aWxzLm1ha2VBcnJheSh0ZW1wbGF0ZU5vZGVzLmNsb25lTm9kZSh0cnVlKS5jaGlsZE5vZGVzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgdGVtcGxhdGVUZXh0ID0gdGVtcGxhdGVTb3VyY2VbJ3RleHQnXSgpO1xuICAgICAgICByZXR1cm4ga28udXRpbHMucGFyc2VIdG1sRnJhZ21lbnQodGVtcGxhdGVUZXh0LCB0ZW1wbGF0ZURvY3VtZW50KTtcbiAgICB9XG59O1xuXG5rby5uYXRpdmVUZW1wbGF0ZUVuZ2luZS5pbnN0YW5jZSA9IG5ldyBrby5uYXRpdmVUZW1wbGF0ZUVuZ2luZSgpO1xua28uc2V0VGVtcGxhdGVFbmdpbmUoa28ubmF0aXZlVGVtcGxhdGVFbmdpbmUuaW5zdGFuY2UpO1xuXG5rby5leHBvcnRTeW1ib2woJ25hdGl2ZVRlbXBsYXRlRW5naW5lJywga28ubmF0aXZlVGVtcGxhdGVFbmdpbmUpO1xuKGZ1bmN0aW9uKCkge1xuICAgIGtvLmpxdWVyeVRtcGxUZW1wbGF0ZUVuZ2luZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gRGV0ZWN0IHdoaWNoIHZlcnNpb24gb2YganF1ZXJ5LXRtcGwgeW91J3JlIHVzaW5nLiBVbmZvcnR1bmF0ZWx5IGpxdWVyeS10bXBsXG4gICAgICAgIC8vIGRvZXNuJ3QgZXhwb3NlIGEgdmVyc2lvbiBudW1iZXIsIHNvIHdlIGhhdmUgdG8gaW5mZXIgaXQuXG4gICAgICAgIC8vIE5vdGUgdGhhdCBhcyBvZiBLbm9ja291dCAxLjMsIHdlIG9ubHkgc3VwcG9ydCBqUXVlcnkudG1wbCAxLjAuMHByZSBhbmQgbGF0ZXIsXG4gICAgICAgIC8vIHdoaWNoIEtPIGludGVybmFsbHkgcmVmZXJzIHRvIGFzIHZlcnNpb24gXCIyXCIsIHNvIG9sZGVyIHZlcnNpb25zIGFyZSBubyBsb25nZXIgZGV0ZWN0ZWQuXG4gICAgICAgIHZhciBqUXVlcnlUbXBsVmVyc2lvbiA9IHRoaXMualF1ZXJ5VG1wbFZlcnNpb24gPSAoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpZiAoIWpRdWVyeUluc3RhbmNlIHx8ICEoalF1ZXJ5SW5zdGFuY2VbJ3RtcGwnXSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICAvLyBTaW5jZSBpdCBleHBvc2VzIG5vIG9mZmljaWFsIHZlcnNpb24gbnVtYmVyLCB3ZSB1c2Ugb3VyIG93biBudW1iZXJpbmcgc3lzdGVtLiBUbyBiZSB1cGRhdGVkIGFzIGpxdWVyeS10bXBsIGV2b2x2ZXMuXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGlmIChqUXVlcnlJbnN0YW5jZVsndG1wbCddWyd0YWcnXVsndG1wbCddWydvcGVuJ10udG9TdHJpbmcoKS5pbmRleE9mKCdfXycpID49IDApIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gU2luY2UgMS4wLjBwcmUsIGN1c3RvbSB0YWdzIHNob3VsZCBhcHBlbmQgbWFya3VwIHRvIGFuIGFycmF5IGNhbGxlZCBcIl9fXCJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDI7IC8vIEZpbmFsIHZlcnNpb24gb2YganF1ZXJ5LnRtcGxcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGNhdGNoKGV4KSB7IC8qIEFwcGFyZW50bHkgbm90IHRoZSB2ZXJzaW9uIHdlIHdlcmUgbG9va2luZyBmb3IgKi8gfVxuXG4gICAgICAgICAgICByZXR1cm4gMTsgLy8gQW55IG9sZGVyIHZlcnNpb24gdGhhdCB3ZSBkb24ndCBzdXBwb3J0XG4gICAgICAgIH0pKCk7XG5cbiAgICAgICAgZnVuY3Rpb24gZW5zdXJlSGFzUmVmZXJlbmNlZEpRdWVyeVRlbXBsYXRlcygpIHtcbiAgICAgICAgICAgIGlmIChqUXVlcnlUbXBsVmVyc2lvbiA8IDIpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiWW91ciB2ZXJzaW9uIG9mIGpRdWVyeS50bXBsIGlzIHRvbyBvbGQuIFBsZWFzZSB1cGdyYWRlIHRvIGpRdWVyeS50bXBsIDEuMC4wcHJlIG9yIGxhdGVyLlwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGV4ZWN1dGVUZW1wbGF0ZShjb21waWxlZFRlbXBsYXRlLCBkYXRhLCBqUXVlcnlUZW1wbGF0ZU9wdGlvbnMpIHtcbiAgICAgICAgICAgIHJldHVybiBqUXVlcnlJbnN0YW5jZVsndG1wbCddKGNvbXBpbGVkVGVtcGxhdGUsIGRhdGEsIGpRdWVyeVRlbXBsYXRlT3B0aW9ucyk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzWydyZW5kZXJUZW1wbGF0ZVNvdXJjZSddID0gZnVuY3Rpb24odGVtcGxhdGVTb3VyY2UsIGJpbmRpbmdDb250ZXh0LCBvcHRpb25zLCB0ZW1wbGF0ZURvY3VtZW50KSB7XG4gICAgICAgICAgICB0ZW1wbGF0ZURvY3VtZW50ID0gdGVtcGxhdGVEb2N1bWVudCB8fCBkb2N1bWVudDtcbiAgICAgICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgICAgICAgICAgZW5zdXJlSGFzUmVmZXJlbmNlZEpRdWVyeVRlbXBsYXRlcygpO1xuXG4gICAgICAgICAgICAvLyBFbnN1cmUgd2UgaGF2ZSBzdG9yZWQgYSBwcmVjb21waWxlZCB2ZXJzaW9uIG9mIHRoaXMgdGVtcGxhdGUgKGRvbid0IHdhbnQgdG8gcmVwYXJzZSBvbiBldmVyeSByZW5kZXIpXG4gICAgICAgICAgICB2YXIgcHJlY29tcGlsZWQgPSB0ZW1wbGF0ZVNvdXJjZVsnZGF0YSddKCdwcmVjb21waWxlZCcpO1xuICAgICAgICAgICAgaWYgKCFwcmVjb21waWxlZCkge1xuICAgICAgICAgICAgICAgIHZhciB0ZW1wbGF0ZVRleHQgPSB0ZW1wbGF0ZVNvdXJjZVsndGV4dCddKCkgfHwgXCJcIjtcbiAgICAgICAgICAgICAgICAvLyBXcmFwIGluIFwid2l0aCgkd2hhdGV2ZXIua29CaW5kaW5nQ29udGV4dCkgeyAuLi4gfVwiXG4gICAgICAgICAgICAgICAgdGVtcGxhdGVUZXh0ID0gXCJ7e2tvX3dpdGggJGl0ZW0ua29CaW5kaW5nQ29udGV4dH19XCIgKyB0ZW1wbGF0ZVRleHQgKyBcInt7L2tvX3dpdGh9fVwiO1xuXG4gICAgICAgICAgICAgICAgcHJlY29tcGlsZWQgPSBqUXVlcnlJbnN0YW5jZVsndGVtcGxhdGUnXShudWxsLCB0ZW1wbGF0ZVRleHQpO1xuICAgICAgICAgICAgICAgIHRlbXBsYXRlU291cmNlWydkYXRhJ10oJ3ByZWNvbXBpbGVkJywgcHJlY29tcGlsZWQpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgZGF0YSA9IFtiaW5kaW5nQ29udGV4dFsnJGRhdGEnXV07IC8vIFByZXdyYXAgdGhlIGRhdGEgaW4gYW4gYXJyYXkgdG8gc3RvcCBqcXVlcnkudG1wbCBmcm9tIHRyeWluZyB0byB1bndyYXAgYW55IGFycmF5c1xuICAgICAgICAgICAgdmFyIGpRdWVyeVRlbXBsYXRlT3B0aW9ucyA9IGpRdWVyeUluc3RhbmNlWydleHRlbmQnXSh7ICdrb0JpbmRpbmdDb250ZXh0JzogYmluZGluZ0NvbnRleHQgfSwgb3B0aW9uc1sndGVtcGxhdGVPcHRpb25zJ10pO1xuXG4gICAgICAgICAgICB2YXIgcmVzdWx0Tm9kZXMgPSBleGVjdXRlVGVtcGxhdGUocHJlY29tcGlsZWQsIGRhdGEsIGpRdWVyeVRlbXBsYXRlT3B0aW9ucyk7XG4gICAgICAgICAgICByZXN1bHROb2Rlc1snYXBwZW5kVG8nXSh0ZW1wbGF0ZURvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIikpOyAvLyBVc2luZyBcImFwcGVuZFRvXCIgZm9yY2VzIGpRdWVyeS9qUXVlcnkudG1wbCB0byBwZXJmb3JtIG5lY2Vzc2FyeSBjbGVhbnVwIHdvcmtcblxuICAgICAgICAgICAgalF1ZXJ5SW5zdGFuY2VbJ2ZyYWdtZW50cyddID0ge307IC8vIENsZWFyIGpRdWVyeSdzIGZyYWdtZW50IGNhY2hlIHRvIGF2b2lkIGEgbWVtb3J5IGxlYWsgYWZ0ZXIgYSBsYXJnZSBudW1iZXIgb2YgdGVtcGxhdGUgcmVuZGVyc1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdE5vZGVzO1xuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXNbJ2NyZWF0ZUphdmFTY3JpcHRFdmFsdWF0b3JCbG9jayddID0gZnVuY3Rpb24oc2NyaXB0KSB7XG4gICAgICAgICAgICByZXR1cm4gXCJ7e2tvX2NvZGUgKChmdW5jdGlvbigpIHsgcmV0dXJuIFwiICsgc2NyaXB0ICsgXCIgfSkoKSkgfX1cIjtcbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzWydhZGRUZW1wbGF0ZSddID0gZnVuY3Rpb24odGVtcGxhdGVOYW1lLCB0ZW1wbGF0ZU1hcmt1cCkge1xuICAgICAgICAgICAgZG9jdW1lbnQud3JpdGUoXCI8c2NyaXB0IHR5cGU9J3RleHQvaHRtbCcgaWQ9J1wiICsgdGVtcGxhdGVOYW1lICsgXCInPlwiICsgdGVtcGxhdGVNYXJrdXAgKyBcIjxcIiArIFwiL3NjcmlwdD5cIik7XG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKGpRdWVyeVRtcGxWZXJzaW9uID4gMCkge1xuICAgICAgICAgICAgalF1ZXJ5SW5zdGFuY2VbJ3RtcGwnXVsndGFnJ11bJ2tvX2NvZGUnXSA9IHtcbiAgICAgICAgICAgICAgICBvcGVuOiBcIl9fLnB1c2goJDEgfHwgJycpO1wiXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgalF1ZXJ5SW5zdGFuY2VbJ3RtcGwnXVsndGFnJ11bJ2tvX3dpdGgnXSA9IHtcbiAgICAgICAgICAgICAgICBvcGVuOiBcIndpdGgoJDEpIHtcIixcbiAgICAgICAgICAgICAgICBjbG9zZTogXCJ9IFwiXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIGtvLmpxdWVyeVRtcGxUZW1wbGF0ZUVuZ2luZS5wcm90b3R5cGUgPSBuZXcga28udGVtcGxhdGVFbmdpbmUoKTtcbiAgICBrby5qcXVlcnlUbXBsVGVtcGxhdGVFbmdpbmUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0ga28uanF1ZXJ5VG1wbFRlbXBsYXRlRW5naW5lO1xuXG4gICAgLy8gVXNlIHRoaXMgb25lIGJ5IGRlZmF1bHQgKm9ubHkgaWYganF1ZXJ5LnRtcGwgaXMgcmVmZXJlbmNlZCpcbiAgICB2YXIganF1ZXJ5VG1wbFRlbXBsYXRlRW5naW5lSW5zdGFuY2UgPSBuZXcga28uanF1ZXJ5VG1wbFRlbXBsYXRlRW5naW5lKCk7XG4gICAgaWYgKGpxdWVyeVRtcGxUZW1wbGF0ZUVuZ2luZUluc3RhbmNlLmpRdWVyeVRtcGxWZXJzaW9uID4gMClcbiAgICAgICAga28uc2V0VGVtcGxhdGVFbmdpbmUoanF1ZXJ5VG1wbFRlbXBsYXRlRW5naW5lSW5zdGFuY2UpO1xuXG4gICAga28uZXhwb3J0U3ltYm9sKCdqcXVlcnlUbXBsVGVtcGxhdGVFbmdpbmUnLCBrby5qcXVlcnlUbXBsVGVtcGxhdGVFbmdpbmUpO1xufSkoKTtcbn0pKTtcbn0oKSk7XG59KSgpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2tub2Nrb3V0L2J1aWxkL291dHB1dC9rbm9ja291dC1sYXRlc3QuZGVidWcuanNcbi8vIG1vZHVsZSBpZCA9IDRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGFwaUtleSA9IGFwaUtleVNlcnZpY2UuZ2V0QXBpS2V5c0Nvb2tpZSgpIHx8IGFwaUtleVNlcnZpY2UuZ2V0QXBpRXhwbG9yZUtleSgpOyAvL0FQSSBLZXlcclxuXHJcbm1vZHVsZS5leHBvcnRzID0ge1xyXG5cdHBsYWNlaG9sZGVyOiAnQXBpIGtleScsXHJcbiAgbmFtZTogJ2FwaWtleScsXHJcbiAgc3R5bGU6ICdxdWVyeScsXHJcbiAgdmFsdWU6IGtvLm9ic2VydmFibGUoYXBpS2V5KSxcclxuXHR0eXBlOiAnc3RyaW5nJyxcclxuXHRyZXF1aXJlZDogdHJ1ZVxyXG59O1xyXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zY3JpcHRzL2FwaS1leHBsb3Jlci92Mi9zcmMvc2VydmljZXMvYXBpS2V5LnNlcnZpY2UuanMiLCJpbXBvcnQgY291bnRyeU9wdGlvbnMgZnJvbSAnLi9vcHRpb25zL2NvdW50cnkub3B0aW9ucydcclxuXHJcbnZhciBiYXNlID0ge307XHJcbnZhciBDT05GSUdfVVJMID0gJy4uLy4uL3NjcmlwdHMvYXBpLWV4cGxvcmVyL2FwaWRlc2NyaXB0aW9uLnhtbCc7XHJcblxyXG52YXIgcGFyc2VEYXRhID0gZnVuY3Rpb24gKHhtbCkge1xyXG5cdHZhciBnbG9iYWwgPSB7fTtcclxuXHQvL2dldCBhbGwgQVBJc1xyXG5cdHZhciByZXNvdXJjZXNFbCA9ICQoeG1sKS5maW5kKFwicmVzb3VyY2VzXCIpLmVxKDApO1xyXG5cclxuXHQvLyByZXNvdXJjZVxyXG5cdCQoeG1sKVxyXG5cdFx0LmZpbmQoXCJyZXNvdXJjZVwiKVxyXG5cdFx0LmdldCgpXHJcblx0XHQubWFwKGZ1bmN0aW9uIChyZXMpIHtcclxuXHRcdFx0dmFyIHJlc291cmNlID0gJChyZXMpO1xyXG5cdFx0XHQvLyBtZXRob2QgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuXHRcdFx0dmFyIG1ldGhvZEVsZW0gPSByZXNvdXJjZS5maW5kKFwibWV0aG9kXCIpLmVxKDApO1xyXG5cclxuXHRcdFx0dmFyIG1ldGhvZCA9IHtcclxuXHRcdFx0XHRpZCA6IG1ldGhvZEVsZW0uYXR0cihcImlkXCIpLCAvLyBtZXRob2QgaWRcclxuXHRcdFx0XHRuYW1lIDogbWV0aG9kRWxlbS5hdHRyKFwiYXBpZ2VlOmRpc3BsYXlOYW1lXCIpIHx8IG1ldGhvZEVsZW0uYXR0cihcImlkXCIpLCAvLyBtZXRob2QgbmFtZVxyXG5cdFx0XHRcdG1ldGhvZCA6IG1ldGhvZEVsZW0uYXR0cignbmFtZScpLCAvLyBHRVQgb3IgUE9TVFxyXG5cdFx0XHRcdGNhdGVnb3J5IDogbWV0aG9kRWxlbS5maW5kKCdbcHJpbWFyeT1cInRydWVcIl0nKS50ZXh0KCkudHJpbSgpLCAvLyBBUEkgbmFtZVxyXG5cdFx0XHRcdHBhdGg6IHJlc291cmNlLmF0dHIoJ3BhdGgnKSwgLy8gbWV0aG9kIFVSTFxyXG5cdFx0XHRcdGJhc2UgOiByZXNvdXJjZXNFbC5hdHRyKCdiYXNlJyksIC8vIG1ldGhvZCBiYXNlIGxpbmtcclxuXHRcdFx0XHRsaW5rIDogbWV0aG9kRWxlbS5maW5kKCdkb2MnKS5lcSgwKS5hdHRyKCdhcGlnZWU6dXJsJyksIC8vIGxpbmsgdG8gZG9jdW1lbnRhdGlvblxyXG5cdFx0XHRcdGRlc2NyaXB0aW9uIDogbWV0aG9kRWxlbS5maW5kKCdkb2MnKS5lcSgwKS50ZXh0KCkudHJpbSgpLCAvL21ldGhvZCBkZXNjcmlwdGlvblxyXG5cdFx0XHRcdHBhcmFtZXRlcnM6IHt9XHJcblx0XHRcdH07XHJcblxyXG5cdFx0XHQvLyBwYXJhbXMgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuXHRcdFx0cmVzb3VyY2VcclxuXHRcdFx0XHQuZmluZCgncGFyYW0nKVxyXG5cdFx0XHRcdC5nZXQoKVxyXG5cdFx0XHRcdC5tYXAoZnVuY3Rpb24gKHBhcikge1xyXG5cdFx0XHRcdFx0dmFyIHBhcmFtID0gJChwYXIpO1xyXG5cdFx0XHRcdFx0dmFyIG9wdGlvbnMgPSBwYXJhbS5maW5kKCdvcHRpb24nKTtcclxuXHRcdFx0XHRcdHZhciBpc1NlbGVjdCA9ICEhb3B0aW9ucy5sZW5ndGg7XHJcblxyXG5cdFx0XHRcdFx0dmFyIHBhcmFtZXRlciA9IHtcclxuXHRcdFx0XHRcdFx0bmFtZTogcGFyYW0uYXR0cignbmFtZScpLFxyXG5cdFx0XHRcdFx0XHRkb2M6IHBhcmFtLmZpbmQoJ2RvYycpLmZpcnN0KCkudGV4dCgpLnRyaW0oKSxcclxuXHRcdFx0XHRcdFx0c3R5bGU6IHBhcmFtLmF0dHIoJ3N0eWxlJyksXHJcblx0XHRcdFx0XHRcdHJlcXVpcmVkOiBwYXJhbS5hdHRyKCdyZXF1aXJlZCcpID09PSAndHJ1ZScsXHJcblx0XHRcdFx0XHRcdGRlZmF1bHQ6IHBhcmFtLmF0dHIoJ2RlZmF1bHQnKSA9PT0gJ25vbmUnICYmIGlzU2VsZWN0ID8gJycgOiBwYXJhbS5hdHRyKCdkZWZhdWx0JyksXHJcblx0XHRcdFx0XHRcdHNlbGVjdDogaXNTZWxlY3QsXHJcblx0XHRcdFx0XHRcdHR5cGU6IHBhcmFtLmF0dHIoJ3R5cGUnKS5yZXBsYWNlKCd4c2Q6JywgJycpXHJcblx0XHRcdFx0XHR9O1xyXG5cclxuXHRcdFx0XHRcdGlmIChpc1NlbGVjdCkge1xyXG5cdFx0XHRcdFx0XHRwYXJhbWV0ZXIub3B0aW9ucyA9IG9wdGlvbnMuZ2V0KCkubWFwKGZ1bmN0aW9uIChvcHRpb24pIHtcclxuXHRcdFx0XHRcdFx0XHRyZXR1cm4ge1xyXG5cdFx0XHRcdFx0XHRcdFx0bmFtZTogJChvcHRpb24pLmF0dHIoJ3ZhbHVlJyksXHJcblx0XHRcdFx0XHRcdFx0XHRjaGVja2VkOiAkKG9wdGlvbikuYXR0cigndmFsdWUnKSA9PT0gcGFyYW1ldGVyLmRlZmF1bHQgfHwgJChvcHRpb24pLmF0dHIoJ3ZhbHVlJykgPT09ICdub25lJyxcclxuXHRcdFx0XHRcdFx0XHRcdGxpbms6IGZhbHNlXHJcblx0XHRcdFx0XHRcdFx0fTtcclxuXHRcdFx0XHRcdFx0fSk7XHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0aWYocGFyYW1ldGVyLm5hbWUgPT09ICdjb3VudHJ5Q29kZScpe1xyXG5cdFx0XHRcdFx0XHRwYXJhbWV0ZXIuc2VsZWN0ID0gdHJ1ZTtcclxuXHRcdFx0XHRcdFx0cGFyYW1ldGVyLm9wdGlvbnMgPSBjb3VudHJ5T3B0aW9ucztcclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRtZXRob2QucGFyYW1ldGVyc1twYXJhbWV0ZXIubmFtZV0gPSBwYXJhbWV0ZXI7XHJcblx0XHRcdFx0fSk7XHJcblxyXG5cdFx0XHRpZiAobWV0aG9kLm1ldGhvZCA9PT0gJ1BPU1QnKSB7XHJcblx0XHRcdFx0bWV0aG9kLnBhcmFtZXRlcnMucmVxdWVzdEJvZHkgPSB7XHJcblx0XHRcdFx0XHRuYW1lOiAnUG9zdCBKU09OJyxcclxuXHRcdFx0XHRcdGRvYzogJ1JlcXVlc3QgSlNPTiBib2R5JyxcclxuXHRcdFx0XHRcdHN0eWxlOiAncmVxdWVzdEJvZHknLFxyXG5cdFx0XHRcdFx0cmVxdWlyZWQ6IGZhbHNlLFxyXG5cdFx0XHRcdFx0ZGVmYXVsdDogJycsXHJcblx0XHRcdFx0XHRzZWxlY3Q6IGZhbHNlLFxyXG5cdFx0XHRcdFx0dHlwZTogJ3N0cmluZydcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdC8qKlxyXG5cdFx0XHQgKiBHbG9iYWwgb2JqIGNvbXBvc2l0aW9uXHJcbiAgICAgICAqL1xyXG5cdFx0XHQvLyBzZXQgY2F0ZWdvcnkgb2JqXHJcblx0XHRcdGdsb2JhbFttZXRob2QuY2F0ZWdvcnldID0gZ2xvYmFsW21ldGhvZC5jYXRlZ29yeV0gfHwge307XHJcblxyXG5cdFx0XHQvLyBzZXQgbWV0aG9kcyB0eXBlIG9ialxyXG5cdFx0XHRnbG9iYWxbbWV0aG9kLmNhdGVnb3J5XS5BTEwgPSBnbG9iYWxbbWV0aG9kLmNhdGVnb3J5XS5BTEwgfHwge307XHJcblx0XHRcdGdsb2JhbFttZXRob2QuY2F0ZWdvcnldW21ldGhvZC5tZXRob2RdID0gZ2xvYmFsW21ldGhvZC5jYXRlZ29yeV1bbWV0aG9kLm1ldGhvZF0gfHwge307XHJcblxyXG5cdFx0XHQvLyBzZXQgbWV0aG9kIG9ialxyXG5cdFx0XHRnbG9iYWxbbWV0aG9kLmNhdGVnb3J5XS5BTExbbWV0aG9kLmlkXSA9IGdsb2JhbFttZXRob2QuY2F0ZWdvcnldW21ldGhvZC5tZXRob2RdW21ldGhvZC5pZF0gPSBtZXRob2Q7XHJcblxyXG5cdFx0fSk7XHJcblxyXG5cdHJldHVybiBnbG9iYWw7XHJcbn07XHJcblxyXG4vL2dldHMgZG9jdW1lbnQgZnJvbSBXQURMIGNvbmZpZ3VyYXRpb24gZmlsZVxyXG52YXIgcmVhZEZyb21XQURMID0gZnVuY3Rpb24gKCkge1xyXG4gICQuYWpheCh7XHJcbiAgICB1cmw6IENPTkZJR19VUkwsXHJcbiAgICBhc3luYyA6IGZhbHNlLFxyXG4gICAgZGF0YVR5cGU6IFwidGV4dFwiLFxyXG4gICAgc3VjY2VzcyA6IGZ1bmN0aW9uKHJlc3BvbnNlKXtcclxuICAgICAgdmFyIHhtbCA9ICQucGFyc2VYTUwocmVzcG9uc2UpO1xyXG5cdFx0XHRiYXNlID0gcGFyc2VEYXRhKHhtbCk7XHJcbiAgICB9LFxyXG5cclxuICAgIGVycm9yOiBmdW5jdGlvbihYTUxIdHRwUmVxdWVzdCwgdGV4dFN0YXR1cywgZXJyb3JUaHJvd24pe1xyXG4gICAgICBhbGVydCgnRGF0YSBDb3VsZCBOb3QgQmUgTG9hZGVkIC0gJysgdGV4dFN0YXR1cyk7XHJcbiAgICB9XHJcbiAgfSk7XHJcbn07XHJcbnJlYWRGcm9tV0FETCgpO1xyXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2U7XHJcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NjcmlwdHMvYXBpLWV4cGxvcmVyL3YyL3NyYy9zZXJ2aWNlcy9iYXNlLnNlcnZpY2UuanMiLCJpbXBvcnQgYmFzZSBmcm9tICcuL2Jhc2Uuc2VydmljZSc7XHJcbmltcG9ydCBhcGlrZXkgZnJvbSAnLi9hcGlLZXkuc2VydmljZSc7XHJcblxyXG4vKipcclxuICogUmVzdCBzZXJ2aWNlXHJcbiAqIEdldHMgZGF0YSBmcm9tIHNlcnZlclxyXG4gKi9cclxubGV0IGluc3RhbmNlO1xyXG5cclxuY2xhc3MgUmVzdFNlcnZpY2Uge1xyXG5cdGNvbnN0cnVjdG9yKCkge1xyXG5cdFx0aWYgKCFpbnN0YW5jZSkge1xyXG5cdFx0XHRpbnN0YW5jZSA9IHRoaXM7XHJcblx0XHR9XHJcblx0XHR0aGlzLmJhc2UgPSBiYXNlO1xyXG5cdFx0dGhpcy5hcGlLZXkgPSBhcGlrZXk7XHJcblx0XHR0aGlzLnNlbGVjdGVkQ2F0ZWdvcnkgPSBrby5vYnNlcnZhYmxlKCcnKS5zdWJzY3JpYmVUbygnU0VMRUNURURfQ0FURUdPUlknKTtcclxuXHRcdHRoaXMuc2VsZWN0ZWRNZXRob2RUeXBlID0ga28ub2JzZXJ2YWJsZSgnJykuc3Vic2NyaWJlVG8oJ1NFTEVDVEVEX01FVEhPRF9UWVBFJyk7XHJcblx0XHR0aGlzLnNlbGVjdGVkTWV0aG9kID0ga28ub2JzZXJ2YWJsZSgnJykuc3Vic2NyaWJlVG8oJ1NFTEVDVEVEX01FVEhPRCcpO1xyXG5cdFx0dGhpcy5zZWxlY3RlZFBhcmFtcyA9IGtvLm9ic2VydmFibGVBcnJheShbXSkuc3Vic2NyaWJlVG8oJ1NFTEVDVEVEX1BBUkFNUycpO1xyXG5cdFx0dGhpcy5yZXF1ZXN0cyA9IGtvLm9ic2VydmFibGVBcnJheShbXSkuc3luY1dpdGgoJ1JFUVVFU1RTX0FSUicpO1xyXG5cdFx0dGhpcy5hbm90aGVyUmVzcG9uc2UgPSBrby5vYnNlcnZhYmxlKCkucHVibGlzaE9uKCdBTk9USEVSX1JFU1BPTlNFJyk7XHJcblx0XHR0aGlzLnJlcXVlc3RJblByb2dyZXNzID0ga28ub2JzZXJ2YWJsZShmYWxzZSk7XHJcblx0XHR0aGlzLmluaXQoKTtcclxuXHRcdHJldHVybiBpbnN0YW5jZTtcclxuXHR9XHJcblxyXG5cdGluaXQoKSB7XHJcblx0XHRrby5wb3N0Ym94LnN1YnNjcmliZSgnU0VMRUNURURfTUVUSE9EJywgbmV3VmFsdWUgPT4ge1xyXG5cdFx0XHR0aGlzLnNlbGVjdGVkTWV0aG9kRGF0YSA9IHRoaXMuZ2V0TWV0aG9kRGF0YSgpXHJcblx0XHR9KTtcclxuXHJcblx0XHRrby5wb3N0Ym94LnN1YnNjcmliZSgnQU5PVEhFUl9SRVFVRVNUJywgKHttZXRob2QsIHBhbmVsR3JvdXAsIGNvbG9yfSkgPT4ge1xyXG5cdFx0XHR0aGlzLmFub3RoZXJSZXF1ZXN0ID0gdHJ1ZTtcclxuXHRcdFx0bGV0IHVybCA9IHRoaXMucHJlcGFyZVVybChtZXRob2QuYmFzZSwgbWV0aG9kLnBhdGgsIG1ldGhvZC5wYXJhbWV0ZXJzKTtcclxuXHJcblx0XHRcdHRoaXMuYWpheFNlcnZpY2Uoe3VybCwgdHlwZTogbWV0aG9kLm1ldGhvZCwgY2FsbGJhY2s6IChyZXMsIG1zZykgPT4ge1xyXG5cdFx0XHRcdGxldCBjYXRlZ29yeSA9IG1ldGhvZC5jYXRlZ29yeTtcclxuXHRcdFx0XHRsZXQgdHlwZSA9IG1ldGhvZC5tZXRob2Q7XHJcblx0XHRcdFx0bGV0IG1ldGhvZElkID0gbWV0aG9kLmlkO1xyXG5cdFx0XHRcdGxldCBwYXJhbXMgPSBtZXRob2QucGFyYW1ldGVycztcclxuXHJcblx0XHRcdFx0bGV0IHJlc09iaiA9IHtcclxuXHRcdFx0XHRcdGNhdGVnb3J5LFxyXG5cdFx0XHRcdFx0bWV0aG9kOiB0eXBlLFxyXG5cdFx0XHRcdFx0bWV0aG9kSWQsXHJcblx0XHRcdFx0XHRwYXJhbXM6IHBhcmFtcy5tYXAob2JqID0+ICQuZXh0ZW5kKHRydWUsIHt9LCB7XHJcblx0XHRcdFx0XHRcdG5hbWU6IG9iai5uYW1lLFxyXG5cdFx0XHRcdFx0XHR2YWx1ZToga28ub2JzZXJ2YWJsZShrby51bndyYXAob2JqLnZhbHVlKSksXHJcblx0XHRcdFx0XHRcdG9wdGlvbnM6IG9iai5vcHRpb25zXHJcblx0XHRcdFx0XHR9KSksXHJcblx0XHRcdFx0XHRyZXE6IHRoaXMucmVxLFxyXG5cdFx0XHRcdFx0aW5kZXg6IHRoaXMucmVxdWVzdHMoKS5sZW5ndGhcclxuXHRcdFx0XHR9O1xyXG5cclxuXHRcdFx0XHRpZiAobXNnID09ICdlcnJvcicpIHtcclxuXHRcdFx0XHRcdC8vIG5vdGlmeWluZyBlcnJvciBtb2RhbFxyXG5cdFx0XHRcdFx0dGhpcy5lcnJvciA9IGtvLm9ic2VydmFibGUocmVzKS5wdWJsaXNoT24oJ1JFUVVFU1RfRVJST1InKTtcclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0dGhpcy5lcnJvciAmJiBkZWxldGUgdGhpcy5lcnJvcjtcclxuXHRcdFx0XHRcdHJlc09iai5yZXNwb25zZSA9IHJlcy5yZXNwb25zZUpTT047XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHQvLyBleHBvcnRpbmcgZGF0YSB1c2luZyBvYnNlcnZhYmxlXHJcblx0XHRcdFx0dGhpcy5hbm90aGVyUmVzcG9uc2Uoe2RhdGE6IHJlc09iaiwgcGFuZWxHcm91cCwgY29sb3J9KVxyXG5cdFx0XHR9fSk7XHJcblx0XHR9KTtcclxuXHR9XHJcblxyXG5cdHNlbmRSZXF1ZXN0KGFwaWtleUFjdGl2ZSkge1xyXG5cdFx0dGhpcy5hcGlrZXlBY3RpdmUgPSBhcGlrZXlBY3RpdmUgfHwga28udW53cmFwKHRoaXMuYXBpS2V5LnZhbHVlKTtcclxuXHRcdGxldCB0eXBlID0ga28udW53cmFwKHRoaXMuc2VsZWN0ZWRNZXRob2RUeXBlKTtcclxuXHRcdHRoaXMucmVxID0gdGhpcy5wcmVwYXJlVXJsKCk7XHJcblx0XHR0aGlzLmFqYXhTZXJ2aWNlKHt1cmw6IHRoaXMucmVxLCB0eXBlLCBjYWxsYmFjazogdGhpcy5jYWxsYmFja30pO1xyXG5cdFx0dGhpcy5yZXF1ZXN0SW5Qcm9ncmVzcyh0cnVlKTtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIEZpbHRlcnMgYW5kIHByZXBhcmVzIHBhcmFtcyBwYWlyc1xyXG5cdCAqIEByZXR1cm5zIHtib29sZWFufVxyXG5cdCAqL1xyXG5cdHByZXBhcmVVcmwoX2RvbWFpbiwgX3BhdGgsIF9zZWxlY3RlZFBhcmFtcykge1xyXG5cdFx0bGV0IHJlcGxhY2VtZW50LFxyXG5cdFx0XHR1cmwsXHJcblx0XHRcdHBhcmFtcyxcclxuXHRcdFx0c2VsZWN0ZWRQYXJhbXMgPSBrby51bndyYXAoX3NlbGVjdGVkUGFyYW1zIHx8IHRoaXMuc2VsZWN0ZWRQYXJhbXMpO1xyXG5cclxuXHRcdGxldCBkb21haW4gPSBfZG9tYWluIHx8IHRoaXMuc2VsZWN0ZWRNZXRob2REYXRhLmJhc2U7XHJcblx0XHRsZXQgcGF0aCA9IF9wYXRoIHx8IHRoaXMuc2VsZWN0ZWRNZXRob2REYXRhLnBhdGg7XHJcblxyXG5cdFx0cGFyYW1zID0gc2VsZWN0ZWRQYXJhbXMuZmlsdGVyKGl0ZW0gPT4gaXRlbS5zdHlsZSA9PT0gJ3F1ZXJ5Jyk7XHJcblxyXG5cdFx0Ly8gYXJyIG9mIHRlbXBsYXRlIG1hcmtzXHJcblx0XHRyZXBsYWNlbWVudCA9IHBhdGgubWF0Y2goLyhbXntdKj8pXFx3KD89XFx9KS9nbWkpO1xyXG5cclxuXHRcdC8vIGFyciBvZiB0ZW1wbGF0ZSBwYXJhbXNcclxuXHRcdHZhciB0ZW1wbGF0ZXNBcnIgPSBzZWxlY3RlZFBhcmFtcy5maWx0ZXIoaXRlbSA9PiBpdGVtLnN0eWxlID09PSAndGVtcGxhdGUnKTtcclxuXHJcblx0XHQvLyByZXBsYWNlbWVudFxyXG5cdFx0cmVwbGFjZW1lbnQuZm9yRWFjaCh2YWwgPT4ge1xyXG5cdFx0XHR2YXIgcGFyYW0gPSB0ZW1wbGF0ZXNBcnIuZmluZChpdGVtID0+IGl0ZW0ubmFtZSA9PT0gdmFsKTtcclxuXHRcdFx0cGF0aCA9IHBhdGgucmVwbGFjZSgneycrIHBhcmFtLm5hbWUgKyAnfScsIGtvLnVud3JhcChwYXJhbS52YWx1ZSkgfHwgcGFyYW0uZGVmYXVsdCk7XHJcblx0XHR9KTtcclxuXHJcblx0XHQvLyBwcmVwYXJlcyBwYXJhbXMgcGFydCBvZiB1cmxcclxuXHRcdHBhcmFtcyA9IHBhcmFtcy5tYXAoaXRlbSA9PiBbaXRlbS5uYW1lLCBrby51bndyYXAoaXRlbS52YWx1ZSkgfHwgaXRlbS5kZWZhdWx0XS5qb2luKCc9JykpLmpvaW4oJyYnKTtcclxuXHJcblx0XHR1cmwgPSBbZG9tYWluLCAnLycsIHBhdGgsICBgP2FwaWtleT0ke3RoaXMuYXBpa2V5QWN0aXZlfSZgLCBwYXJhbXNdLmpvaW4oJycpO1xyXG5cclxuXHRcdHJldHVybiBlbmNvZGVVUkkodXJsKTtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIEFqYXggU2VydmljZVxyXG5cdCAqL1xyXG5cdGFqYXhTZXJ2aWNlKHt1cmwsIHR5cGUgPSAnR0VUJywgYXN5bmMgPSB0cnVlLCBkYXRhVHlwZSA9ICdqc29uJywgY2FsbGJhY2t9KSB7XHJcblx0XHRsZXQgbWV0aG9kID0gdGhpcy5iYXNlW2tvLnVud3JhcCh0aGlzLnNlbGVjdGVkQ2F0ZWdvcnkpXVtrby51bndyYXAodGhpcy5zZWxlY3RlZE1ldGhvZFR5cGUpXVtrby51bndyYXAodGhpcy5zZWxlY3RlZE1ldGhvZCldLm1ldGhvZDtcclxuXHRcdGxldCBvYmogPSB7XHJcblx0XHRcdHR5cGU6IG1ldGhvZCxcclxuXHRcdFx0dXJsLFxyXG5cdFx0XHRhc3luYyxcclxuXHRcdFx0ZGF0YVR5cGUsXHJcblx0XHRcdGNvbXBsZXRlOiBjYWxsYmFja1xyXG5cdFx0fTtcclxuXHRcdGlmIChtZXRob2QgPT09ICdQT1NUJykge1xyXG5cdFx0XHRvYmouaGVhZGVycyA9ICQuZXh0ZW5kKHRydWUsIHt9LCB0aGlzLmdldEhlYWRlcnMoKSk7XHJcblx0XHRcdGxldCBib2R5ID0ga28udW53cmFwKGtvLnVud3JhcCh0aGlzLnNlbGVjdGVkUGFyYW1zKS5maW5kKHBhcmFtID0+IHBhcmFtLnN0eWxlID09PSAncmVxdWVzdEJvZHknKS52YWx1ZSk7XHJcblx0XHRcdHRyeSB7XHJcblx0XHRcdFx0b2JqLmRhdGEgPSBKU09OLnBhcnNlKGJvZHkpO1xyXG5cdFx0XHR9IGNhdGNoIChlcnIpIHtcclxuXHRcdFx0XHRvYmouZGF0YSA9IHtcImJvZHlcIjogYm9keX07XHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblx0XHQkLmFqYXgob2JqKTtcclxuXHR9XHJcblxyXG5cdGdldEhlYWRlcnMoKSB7XHJcblx0XHRsZXQgaGVhZGVyc09iaiA9IHt9O1xyXG5cdFx0a28udW53cmFwKHRoaXMuc2VsZWN0ZWRQYXJhbXMpLm1hcChwYXJhbSA9PiB7XHJcblx0XHRcdGlmIChwYXJhbS5zdHlsZSA9PT0gJ2hlYWRlcicpIHtcclxuXHRcdFx0XHRoZWFkZXJzT2JqW3BhcmFtLm5hbWVdID0ga28udW53cmFwKHBhcmFtLnZhbHVlKTtcclxuXHRcdFx0fVxyXG5cdFx0fSk7XHJcblx0XHRyZXR1cm4gaGVhZGVyc09iajtcclxuXHR9XHJcblxyXG5cdGdldE1ldGhvZERhdGEocGFyYW1zID0ge30pIHtcclxuXHRcdGxldCBjYXRlZ29yeSA9IGtvLnVud3JhcChwYXJhbXMuYXBpQ2F0ZWdvcnkgfHwgdGhpcy5zZWxlY3RlZENhdGVnb3J5KTtcclxuXHRcdGxldCBtZXRob2RUeXBlID0ga28udW53cmFwKHBhcmFtcy50eXBlIHx8IHRoaXMuc2VsZWN0ZWRNZXRob2RUeXBlIHx8ICdBTEwnKTtcclxuXHRcdGxldCBtZXRob2QgPSBrby51bndyYXAocGFyYW1zLm1ldGhvZElkIHx8IHRoaXMuc2VsZWN0ZWRNZXRob2QpO1xyXG5cdFx0cmV0dXJuIHRoaXMuYmFzZVtjYXRlZ29yeV0gJiYgdGhpcy5iYXNlW2NhdGVnb3J5XVttZXRob2RUeXBlXSAmJiB0aGlzLmJhc2VbY2F0ZWdvcnldW21ldGhvZFR5cGVdW21ldGhvZF0gfHwge307XHJcblx0fVxyXG5cclxuXHRjYWxsYmFjayA9IChyZXMsIG1zZykgPT4ge1xyXG5cdFx0bGV0IGNhdGVnb3J5ID0ga28udW53cmFwKHRoaXMuc2VsZWN0ZWRDYXRlZ29yeSk7XHJcblx0XHRsZXQgdHlwZSA9IGtvLnVud3JhcCh0aGlzLnNlbGVjdGVkTWV0aG9kVHlwZSk7XHJcblx0XHRsZXQgbWV0aG9kSWQgPSBrby51bndyYXAodGhpcy5zZWxlY3RlZE1ldGhvZCk7XHJcblx0XHRsZXQgcGFyYW1zID0ga28udW53cmFwKHRoaXMuc2VsZWN0ZWRQYXJhbXMpO1xyXG5cclxuXHRcdHZhciByZXNPYmogPSB7XHJcblx0XHRcdGNhdGVnb3J5LFxyXG5cdFx0XHRtZXRob2Q6IHR5cGUsXHJcblx0XHRcdG1ldGhvZElkLFxyXG5cdFx0XHRwYXJhbXM6IHBhcmFtcy5tYXAob2JqID0+ICQuZXh0ZW5kKHRydWUsIHt9LCB7XHJcblx0XHRcdFx0bmFtZTogb2JqLm5hbWUsXHJcblx0XHRcdFx0dmFsdWU6IGtvLm9ic2VydmFibGUoa28udW53cmFwKG9iai52YWx1ZSkpLFxyXG5cdFx0XHRcdG9wdGlvbnM6IG9iai5vcHRpb25zXHJcblx0XHRcdH0pKSxcclxuXHRcdFx0cmVxOiB0aGlzLnJlcSxcclxuXHRcdFx0aW5kZXg6IHRoaXMucmVxdWVzdHMoKS5sZW5ndGhcclxuXHRcdH07XHJcblxyXG5cdFx0aWYgKG1zZyA9PSAnZXJyb3InKSB7XHJcblx0XHRcdC8vIG5vdGlmeWluZyBlcnJvciBtb2RhbFxyXG5cdFx0XHR0aGlzLmVycm9yID0ga28ub2JzZXJ2YWJsZShyZXMpLnB1Ymxpc2hPbignUkVRVUVTVF9FUlJPUicpO1xyXG5cdFx0XHQvLyBlcnJvciBwb3BvdmVyIG9mIHJlcXVlc3RcclxuXHRcdFx0cmVzT2JqLmVycm9yID0gcmVzO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0dGhpcy5lcnJvciAmJiBkZWxldGUgdGhpcy5lcnJvcjtcclxuXHRcdFx0Z2xvYmFsLmxhc3RSZXNwb25zZSA9IHJlc09iai5yZXNwb25zZSA9IHJlcy5yZXNwb25zZUpTT047XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gZXhwb3J0aW5nIGRhdGEgdXNpbmcgb2JzZXJ2YWJsZVxyXG5cdFx0dGhpcy5yZXF1ZXN0cy51bnNoaWZ0KHJlc09iaik7XHJcblx0XHR0aGlzLnJlcXVlc3RJblByb2dyZXNzKGZhbHNlKTtcclxuXHR9O1xyXG5cclxuXHRwYXJzZVVybCA9ICh1cmwpID0+IHtcclxuXHRcdGxldCBsb2NhdGlvbiA9IHVybCA/ICc/JyArIHVybC5zcGxpdCgnPycpWzFdOiB3aW5kb3cubG9jYXRpb24uc2VhcmNoO1xyXG5cclxuXHRcdGlmIChsb2NhdGlvbikge1xyXG5cdFx0XHR2YXIgcXVlcnlzID0gbG9jYXRpb24ucmVwbGFjZSgvXlxcPy9nLCAnJykuc3BsaXQoJyYnKTtcclxuXHRcdFx0dmFyIG9iaiA9IHtcclxuXHRcdFx0XHRhcGlDYXRlZ29yeTogJycsXHJcblx0XHRcdFx0bWV0aG9kSWQ6ICcnLFxyXG5cdFx0XHRcdHBhcmFtZXRlcnM6IFtdXHJcblx0XHRcdH07XHJcblxyXG5cdFx0XHRsZXQgZ2xvYmFsUXVlcnlPYmogPSB3aW5kb3cubG9jYXRpb24ucXVlcnkgPSB7fTtcclxuXHRcdFx0cXVlcnlzLm1hcChxdWVyeSA9PiB7XHJcblx0XHRcdFx0bGV0IFtrZXksIHZhbF0gPSBkZWNvZGVVUkkocXVlcnkpLnNwbGl0KCc9Jyk7XHJcblxyXG5cdFx0XHRcdGlmIChPYmplY3Qua2V5cyhvYmopLmluZGV4T2Yoa2V5KSAhPT0gLTEpIHtcclxuXHRcdFx0XHRcdHRyeSB7XHJcblx0XHRcdFx0XHRcdG9ialtrZXldID0gZ2xvYmFsUXVlcnlPYmpba2V5XSA9IEpTT04ucGFyc2UodmFsKTtcclxuXHRcdFx0XHRcdH0gY2F0Y2ggKGV4Y2VwdGlvbl92YXIpIHtcclxuXHRcdFx0XHRcdFx0b2JqW2tleV0gPSBnbG9iYWxRdWVyeU9ialtrZXldID0gdmFsO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHR0cnkge1xyXG5cdFx0XHRcdFx0XHRnbG9iYWxRdWVyeU9ialtrZXldID0gSlNPTi5wYXJzZSh2YWwpO1xyXG5cdFx0XHRcdFx0fSBjYXRjaCAoZXhjZXB0aW9uX3Zhcikge1xyXG5cdFx0XHRcdFx0XHRnbG9iYWxRdWVyeU9ialtrZXldID0gdmFsO1xyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdG9iai5wYXJhbWV0ZXJzLnB1c2goe1xyXG5cdFx0XHRcdFx0XHRuYW1lOiBrZXksXHJcblx0XHRcdFx0XHRcdHZhbHVlOiBnbG9iYWxRdWVyeU9ialtrZXldXHJcblx0XHRcdFx0XHR9KVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0fSk7XHJcblxyXG5cdFx0XHRsZXQgbWV0aG9kRGF0YSA9IHRoaXMuZ2V0TWV0aG9kRGF0YShvYmopO1xyXG5cdFx0XHRsZXQgcGFyYW1ldGVycyA9IG1ldGhvZERhdGEucGFyYW1ldGVycztcclxuXHJcblx0XHRcdG9iai5wYXJhbWV0ZXJzID0gb2JqLnBhcmFtZXRlcnMubWFwKG9iaiA9PiB7XHJcblx0XHRcdFx0cmV0dXJuICQuZXh0ZW5kKHRydWUsIHt9LCBwYXJhbWV0ZXJzW29iai5uYW1lXSwgb2JqKTtcclxuXHRcdFx0fSk7XHJcblx0XHRcdHJldHVybiBvYmo7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4ge307XHJcblx0fTtcclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBuZXcgUmVzdFNlcnZpY2UoKTtcclxuXHJcblxyXG5cclxuXHJcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NjcmlwdHMvYXBpLWV4cGxvcmVyL3YyL3NyYy9zZXJ2aWNlcy9yZXN0LnNlcnZpY2UuanMiLCIvKipcclxuICogTWFpbiBmaWxlIGZvciBBcGkgRXhwbHJlciB2Mi4wXHJcbiAqIEZvciBkZXZlbG9wbWVudCBwbGVhc2UgdXNlIFdlYnBhY2sgdG8gYnVuZGxlIGFsbCBtb2R1bGVzXHJcbiAqIEl0IGNhbiBiZSBtYWRlIHVzaW5nIG5wbSBzY3JpcHRzIGNtZCAtICd3ZWJwYWNrJ1xyXG4gKi9cclxuXHJcbi8vIGN1c3RvbSBiaW5kaW5nc1xyXG5pbXBvcnQgKiBhcyBtb2R1bGVzIGZyb20gJy4vbW9kdWxlcyc7XHJcbmltcG9ydCAqIGFzIGN1c3RvbUJpbmRpbmdzIGZyb20gJy4vY3VzdG9tQmluZGluZ3MnO1xyXG5pbXBvcnQgKiBhcyBjb21wb25lbnRzIGZyb20gJy4vY29tcG9uZW50cyc7XHJcbmltcG9ydCAqIGFzIHNlcnZpY2VzIGZyb20gJy4vc2VydmljZXMnO1xyXG5pbXBvcnQgKiBhcyByZXN0U3J2IGZyb20gJy4vc2VydmljZXMvcmVzdC5zZXJ2aWNlJztcclxuXHJcbi8qKlxyXG4gKiBHZXRzIGRlZXAgcHJvcFxyXG4gKiBAcmV0dXJucyB7KltdfVxyXG4gKi9cclxuT2JqZWN0LmdldFByb3AgPSBmdW5jdGlvbihvLCBzKSB7XHJcblx0aWYgKCh0eXBlb2YgbyAhPT0gJ29iamVjdCcgfHwgbyA9PSBudWxsKSAmJiAhcykge3JldHVybjt9XHJcblx0cyA9IHMucmVwbGFjZSgvXFxbKFxcdyspXFxdL2csICcuJDEnKTsgLy8gY29udmVydCBpbmRleGVzIHRvIHByb3BlcnRpZXNcclxuXHRzID0gcy5yZXBsYWNlKC9eXFwuLywgJycpOyAgICAgICAgICAgLy8gc3RyaXAgYSBsZWFkaW5nIGRvdFxyXG5cdHZhciBhID0gcy5zcGxpdCgnLicpO1xyXG5cdGZvciAodmFyIGkgPSAwLCBuID0gYS5sZW5ndGg7IGkgPCBuOyArK2kpIHtcclxuXHRcdHZhciBrID0gYVtpXTtcclxuXHRcdGlmIChvICYmIGsgaW4gbykge1xyXG5cdFx0XHRvID0gb1trXTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHJldHVybjtcclxuXHRcdH1cclxuXHR9XHJcblx0cmV0dXJuIG87XHJcbn07XHJcblxyXG5jbGFzcyBBcHBWaWV3TW9kZWwge1xyXG5cdGNvbnN0cnVjdG9yKHtiYXNlID0ge30sIGFwaUtleSwgY29uZmlnLCByZXN0fSkge1xyXG5cdFx0dGhpcy5iYXNlID0gYmFzZTtcclxuXHRcdHRoaXMuYXBpS2V5ID0gYXBpS2V5O1xyXG5cdFx0dGhpcy5hcGlLZXlJbnB1dElkID0gJyNhcGkta2V5JztcclxuXHRcdHRoaXMuY29uZmlnID0gY29uZmlnO1xyXG5cdFx0dGhpcy5yZXN0U2VydmljZSA9IHJlc3Q7XHJcblx0XHR0aGlzLnBhcmFtc0lzSGlkZW4gPSBrby5vYnNlcnZhYmxlKHRydWUpO1xyXG5cclxuXHRcdGxldCBwYXJzZWRVcmwgPSB0aGlzLnBhcnNlVXJsKCk7XHJcblx0XHQvLyBvYnNlcnZhYmxlc1xyXG5cdFx0dGhpcy5zZWxlY3RlZENhdGVnb3J5ID0ga28ub2JzZXJ2YWJsZShwYXJzZWRVcmwuYXBpQ2F0ZWdvcnkgfHwgJycpLnN5bmNXaXRoKCdTRUxFQ1RFRF9DQVRFR09SWScpO1xyXG5cdFx0dGhpcy5zZWxlY3RlZE1ldGhvZFR5cGUgPSBrby5vYnNlcnZhYmxlKCdBTEwnKS5zeW5jV2l0aCgnU0VMRUNURURfTUVUSE9EX1RZUEUnKTtcclxuXHRcdHRoaXMuc2VsZWN0ZWRNZXRob2QgPSBrby5vYnNlcnZhYmxlKHBhcnNlZFVybC5tZXRob2RJZCB8fCAnJykuc3luY1dpdGgoJ1NFTEVDVEVEX01FVEhPRCcpO1xyXG5cdFx0dGhpcy5zZWxlY3RlZFBhcmFtcyA9IGtvLm9ic2VydmFibGVBcnJheShbXSkuc3luY1dpdGgoJ1NFTEVDVEVEX1BBUkFNUycpO1xyXG5cdFx0dGhpcy5zZWxlY3RlZE1ldGhvZERhdGEgPSBrby5vYnNlcnZhYmxlKHRoaXMuZ2V0TWV0aG9kRGF0YSh7fSkpO1xyXG5cclxuXHRcdHRoaXMuaW5pdFZhbGlkYXRpb24oKTtcclxuXHJcblx0XHQvLyBjb21wdXRlZFxyXG5cdFx0dGhpcy5zZW5kQnV0dG9uVGV4dCA9IGtvLnB1cmVDb21wdXRlZCgoKSA9PiBrby51bndyYXAodGhpcy5zZWxlY3RlZE1ldGhvZERhdGEpLm1ldGhvZCk7XHJcblx0XHR0aGlzLnJlcXVlc3RJblByb2dyZXNzID0gdGhpcy5yZXN0U2VydmljZS5yZXF1ZXN0SW5Qcm9ncmVzcztcclxuXHRcdHRoaXMuc2hhcmVQYXRoID0ga28ucHVyZUNvbXB1dGVkKCgpID0+IHRoaXMuZm9ybURlZXBMaW5raW5nVXJsKCkpO1xyXG5cclxuXHRcdHRoaXMuc2VsZWN0ZWRNZXRob2Quc3Vic2NyaWJlKHZhbCA9PiB7XHJcblx0XHRcdHRoaXMucGFyYW1zSXNIaWRlbih0cnVlKTtcclxuXHRcdFx0dGhpcy52YWxpZGF0aW9uTW9kZWwoJC5leHRlbmQoe30sIGtvLnVud3JhcCh0aGlzLmFwaUtleVZhbGlkYXRpb25Nb2RlbCkpKTtcclxuXHRcdFx0dGhpcy5zZWxlY3RlZE1ldGhvZERhdGEodGhpcy5nZXRNZXRob2REYXRhKHttZXRob2RJZDogdmFsfSkpO1xyXG5cdFx0fSk7XHJcblx0XHQkKHRoaXMuYXBpS2V5SW5wdXRJZCkudmFsKCBrby51bndyYXAodGhpcy5hcGlLZXkudmFsdWUpKS5zaG93KCk7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBWYWxpZGF0aW9uIHdhdGNoZXJzIGFuZCBsb2dpY1xyXG5cdCAqL1xyXG5cdGluaXRWYWxpZGF0aW9uKCkge1xyXG5cdFx0dGhpcy5hcGlLZXlWYWxpZGF0aW9uTW9kZWwgPSBrby5vYnNlcnZhYmxlKHt9KTtcclxuXHRcdHRoaXMudmFsaWRhdGlvbk1vZGVsID0ga28ub2JzZXJ2YWJsZSh7fSk7XHJcblxyXG5cdFx0dGhpcy5zZW5kQnRuVmFsaWRhdGlvblRleHQgPSBrby5vYnNlcnZhYmxlKCcnKTtcclxuXHRcdHRoaXMuZm9ybUlzVmFsaWQgPSBrby5vYnNlcnZhYmxlKHRydWUpO1xyXG5cdFx0a28uY29tcHV0ZWQoKCkgPT4ge1xyXG5cdFx0XHRsZXQgdmFsaWRhdGlvbk1vZGVsID0ga28udmFsaWRhdGVkT2JzZXJ2YWJsZSgkLmV4dGVuZCh7fSwga28udW53cmFwKHRoaXMudmFsaWRhdGlvbk1vZGVsKSwga28udW53cmFwKHRoaXMuYXBpS2V5VmFsaWRhdGlvbk1vZGVsKSkpO1xyXG5cdFx0XHRsZXQgdmFsaWRhdGlvbkZsYWcgPSB2YWxpZGF0aW9uTW9kZWwuaXNWYWxpZCgpIHx8ICEkKCcuY3VzdG9tLWlucHV0X19maWVsZC5ub3QtdmFsaWQnKS5sZW5ndGg7XHJcblx0XHRcdHRoaXMuc2VuZEJ0blZhbGlkYXRpb25UZXh0KHZhbGlkYXRpb25GbGFnID8gJyc6IHRoaXMudmFsaWRhdGlvblRleHQpO1xyXG5cdFx0XHR0aGlzLmZvcm1Jc1ZhbGlkKHZhbGlkYXRpb25GbGFnKTtcclxuXHRcdH0pO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogU2VuZCByZXF1ZXN0IG1ldGhvZFxyXG5cdCAqL1xyXG5cdG9uQ2xpY2tTZW5kQnRuKCkge1xyXG5cdFx0bGV0IG1vZGVsID0ga28udmFsaWRhdGVkT2JzZXJ2YWJsZSgkLmV4dGVuZCh7fSwga28udW53cmFwKHRoaXMudmFsaWRhdGlvbk1vZGVsKSwga28udW53cmFwKHRoaXMuYXBpS2V5VmFsaWRhdGlvbk1vZGVsKSkpO1xyXG5cdFx0aWYgKG1vZGVsLmlzVmFsaWQoKSkge1xyXG5cdFx0XHRsZXQgYWN0aXZlS2V5ID0gICQodGhpcy5hcGlLZXlJbnB1dElkKS52YWwoKTtcclxuXHRcdFx0dGhpcy5yZXN0U2VydmljZS5zZW5kUmVxdWVzdChhY3RpdmVLZXkpO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0dGhpcy5wYXJhbXNJc0hpZGVuKGZhbHNlKTsgLy8gc2xpZGUgdG9nZ2xlIHdoZW4gcGFyYW1zIGFyZSBub3QgdmFsaWRcclxuXHRcdFx0dGhpcy5mb3JtSXNWYWxpZChmYWxzZSk7XHJcblx0XHRcdHRoaXMuc2VuZEJ0blZhbGlkYXRpb25UZXh0KHRoaXMudmFsaWRhdGlvblRleHQpO1xyXG5cdFx0XHRtb2RlbC5lcnJvcnMuc2hvd0FsbE1lc3NhZ2VzKCk7XHJcblx0XHR9XHJcblx0fVxyXG5cdFxyXG5cdGZvcm1EZWVwTGlua2luZ1VybCgpIHtcclxuXHRcdGxldCBsb2NhdGlvbiA9IHdpbmRvdy5sb2NhdGlvbjtcclxuXHRcdGxldCBjYXRlZ29yeSA9IGtvLnVud3JhcCh0aGlzLnNlbGVjdGVkQ2F0ZWdvcnkpO1xyXG5cdFx0bGV0IG1ldGhvZCA9IGtvLnVud3JhcCh0aGlzLnNlbGVjdGVkTWV0aG9kKTtcclxuXHRcdGxldCBwYXJhbXMgPSBrby51bndyYXAodGhpcy5zZWxlY3RlZFBhcmFtcyk7XHJcblxyXG5cdFx0bGV0IHF1ZXJ5cyA9IFtcclxuXHRcdFx0YGFwaUNhdGVnb3J5PSR7ZW5jb2RlVVJJKGNhdGVnb3J5KX1gLFxyXG5cdFx0XHRgbWV0aG9kSWQ9JHtlbmNvZGVVUkkobWV0aG9kKX1gXHJcblx0XHRdO1xyXG5cclxuXHRcdHBhcmFtcy5tYXAocGFyYW0gPT4ge1xyXG5cdFx0XHRsZXQgdmFsdWUgPSBrby51bndyYXAocGFyYW0udmFsdWUpO1xyXG5cdFx0XHRsZXQgZGVmYXVsdFZhbHVlID0ga28udW53cmFwKHBhcmFtLmRlZmF1bHQpO1xyXG5cdFx0XHRxdWVyeXMucHVzaChgJHtwYXJhbS5uYW1lfT0ke3ZhbHVlICE9PSAnJyA/IHZhbHVlIDogZGVmYXVsdFZhbHVlfWApOyAvL3RvZG86IHJlbW92ZSBkZWZhdWx0IGZyb20gaGVyZSB3aGVuIHNldCB1cCBpdCBpbiBzb3VyY2UgbGlrZSB2YWx1ZSBieSBkZWZhdWx0XHJcblx0XHRcdHJldHVybiBwYXJhbTtcclxuXHRcdH0pO1xyXG5cclxuXHRcdHJldHVybiBgJHtsb2NhdGlvbi5vcmlnaW59JHtsb2NhdGlvbi5wYXRobmFtZS5yZXBsYWNlKC9cXC8kL2dtaSwgJycpfT8ke3F1ZXJ5cy5qb2luKCcmJyl9YFxyXG5cdH1cclxuXHJcblx0Ly9yZXN0IHNlcnZpY2VcclxuXHRnZXRNZXRob2REYXRhKHthcGlDYXRlZ29yeSwgdHlwZSwgbWV0aG9kSWR9KSB7XHJcblx0XHRsZXQgY2F0ZWdvcnkgPSBrby51bndyYXAoYXBpQ2F0ZWdvcnkgfHwgdGhpcy5zZWxlY3RlZENhdGVnb3J5KTtcclxuXHRcdGxldCBtZXRob2RUeXBlID0ga28udW53cmFwKHR5cGUgfHwgdGhpcy5zZWxlY3RlZE1ldGhvZFR5cGUgfHwgJ0FMTCcpO1xyXG5cdFx0bGV0IG1ldGhvZCA9IGtvLnVud3JhcChtZXRob2RJZCB8fCB0aGlzLnNlbGVjdGVkTWV0aG9kKTtcclxuXHRcdHJldHVybiB0aGlzLmJhc2VbY2F0ZWdvcnldICYmIHRoaXMuYmFzZVtjYXRlZ29yeV1bbWV0aG9kVHlwZV0gJiYgdGhpcy5iYXNlW2NhdGVnb3J5XVttZXRob2RUeXBlXVttZXRob2RdIHx8IHt9O1xyXG5cdH1cclxuXHJcblx0Ly8qKioqKioqKioqXHJcblx0cGFyc2VVcmwoKSB7XHJcblx0XHRsZXQgbG9jYXRpb24gPSB3aW5kb3cubG9jYXRpb24uc2VhcmNoO1xyXG5cclxuXHRcdGlmIChsb2NhdGlvbikge1xyXG5cdFx0XHR2YXIgcXVlcnlzID0gbG9jYXRpb24ucmVwbGFjZSgvXlxcPy9nLCAnJykuc3BsaXQoJyYnKTtcclxuXHRcdFx0dmFyIG9iaiA9IHtcclxuXHRcdFx0XHRhcGlDYXRlZ29yeTogJycsXHJcblx0XHRcdFx0bWV0aG9kSWQ6ICcnLFxyXG5cdFx0XHRcdHBhcmFtZXRlcnM6IFtdXHJcblx0XHRcdH07XHJcblxyXG5cdFx0XHRsZXQgZ2xvYmFsUXVlcnlPYmogPSB3aW5kb3cubG9jYXRpb24ucXVlcnkgPSB7fTtcclxuXHRcdFx0cXVlcnlzLm1hcChxdWVyeSA9PiB7XHJcblx0XHRcdFx0bGV0IFtrZXksIHZhbF0gPSBkZWNvZGVVUkkocXVlcnkpLnNwbGl0KCc9Jyk7XHJcblxyXG5cdFx0XHRcdGlmIChPYmplY3Qua2V5cyhvYmopLmluZGV4T2Yoa2V5KSAhPT0gLTEpIHtcclxuXHRcdFx0XHRcdHRyeSB7XHJcblx0XHRcdFx0XHRcdG9ialtrZXldID0gZ2xvYmFsUXVlcnlPYmpba2V5XSA9IEpTT04ucGFyc2UodmFsKTtcclxuXHRcdFx0XHRcdH0gY2F0Y2ggKGV4Y2VwdGlvbl92YXIpIHtcclxuXHRcdFx0XHRcdFx0b2JqW2tleV0gPSBnbG9iYWxRdWVyeU9ialtrZXldID0gdmFsO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHR0cnkge1xyXG5cdFx0XHRcdFx0XHRnbG9iYWxRdWVyeU9ialtrZXldID0gSlNPTi5wYXJzZSh2YWwpO1xyXG5cdFx0XHRcdFx0fSBjYXRjaCAoZXhjZXB0aW9uX3Zhcikge1xyXG5cdFx0XHRcdFx0XHRnbG9iYWxRdWVyeU9ialtrZXldID0gdmFsO1xyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdG9iai5wYXJhbWV0ZXJzLnB1c2goe1xyXG5cdFx0XHRcdFx0XHRuYW1lOiBrZXksXHJcblx0XHRcdFx0XHRcdHZhbHVlOiBnbG9iYWxRdWVyeU9ialtrZXldXHJcblx0XHRcdFx0XHR9KVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0fSk7XHJcblxyXG5cdFx0XHRsZXQgbWV0aG9kRGF0YSA9IHRoaXMuZ2V0TWV0aG9kRGF0YShvYmopO1xyXG5cdFx0XHRsZXQgcGFyYW1ldGVycyA9IG1ldGhvZERhdGEucGFyYW1ldGVycztcclxuXHJcblx0XHRcdG9iai5wYXJhbWV0ZXJzLm1hcChvYmogPT4ge1xyXG5cdFx0XHRcdHBhcmFtZXRlcnNbb2JqLm5hbWVdLnZhbHVlID0gb2JqLnZhbHVlO1xyXG5cdFx0XHRcdHJldHVybiBvYmo7XHJcblx0XHRcdH0pO1xyXG5cdFx0XHRvYmoucGFyYW1ldGVycyA9IHBhcmFtZXRlcnM7XHJcblx0XHRcdHJldHVybiBvYmo7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4ge307XHJcblx0fTtcclxuXHQvLyoqKioqKioqKipcclxuXHRzZXRQYXJhbXMgPSAoe2NhdGVnb3J5LCBtZXRob2QgPSAnQUxMJywgbWV0aG9kSWQsIHBhcmFtc30pID0+IHtcclxuXHRcdHRoaXMuc2VsZWN0ZWRDYXRlZ29yeShjYXRlZ29yeSk7XHJcblx0XHR0aGlzLnNlbGVjdGVkTWV0aG9kVHlwZShtZXRob2QpO1xyXG5cdFx0dGhpcy5zZWxlY3RlZE1ldGhvZChtZXRob2RJZCk7XHJcblx0XHR0aGlzLnNlbGVjdGVkUGFyYW1zLm5vdGlmeVN1YnNjcmliZXJzKHBhcmFtcywgJ3BhcmFtc1NldCcpO1xyXG5cdH1cclxuXHJcblx0Z2V0IHZhbGlkYXRpb25UZXh0KCkge1xyXG5cdFx0cmV0dXJuICdQbGVhc2Ugc29sdmUgZm9ybSB2YWxpZGF0aW9uIGlzc3Vlcyc7XHJcblx0fVxyXG59XHJcblxyXG5sZXQgYXBwID0gbmV3IEFwcFZpZXdNb2RlbChzZXJ2aWNlcyk7XHJcbi8qKlxyXG4gKiBBY3RpdmF0ZXMga25vY2tvdXQuanNcclxuICovXHJcbmtvLmFwcGx5QmluZGluZ3MoYXBwKTtcclxuXHJcbi8qKlxyXG4gKiBleHBvcnRzIGdsb2JhbCB2YXJpYWJsZVxyXG4gKi9cclxubW9kdWxlLmV4cG9ydHMgPSBhcHA7XHJcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NjcmlwdHMvYXBpLWV4cGxvcmVyL3YyL3NyYy9tYWluLmVzNi5qcyIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oKSB7XG5cdHJldHVybiByZXF1aXJlKFwiISFEOlxcXFx0aWNrZXRtYXN0ZXJcXFxcdGlja2V0bWFzdGVyLWFwaS1zdGFnaW5nLmdpdGh1Yi5pb1xcXFxub2RlX21vZHVsZXNcXFxcd29ya2VyLWxvYWRlclxcXFxjcmVhdGVJbmxpbmVXb3JrZXIuanNcIikoXCIvKioqKioqLyAoZnVuY3Rpb24obW9kdWxlcykgeyAvLyB3ZWJwYWNrQm9vdHN0cmFwXFxuLyoqKioqKi8gXFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxcbi8qKioqKiovIFxcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XFxuLyoqKioqKi9cXG4vKioqKioqLyBcXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxcbi8qKioqKiovIFxcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcXG4vKioqKioqL1xcbi8qKioqKiovIFxcdFxcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxcbi8qKioqKiovIFxcdFxcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKVxcbi8qKioqKiovIFxcdFxcdFxcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xcbi8qKioqKiovXFxuLyoqKioqKi8gXFx0XFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcXG4vKioqKioqLyBcXHRcXHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XFxuLyoqKioqKi8gXFx0XFx0XFx0aTogbW9kdWxlSWQsXFxuLyoqKioqKi8gXFx0XFx0XFx0bDogZmFsc2UsXFxuLyoqKioqKi8gXFx0XFx0XFx0ZXhwb3J0czoge31cXG4vKioqKioqLyBcXHRcXHR9O1xcbi8qKioqKiovXFxuLyoqKioqKi8gXFx0XFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXFxuLyoqKioqKi8gXFx0XFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XFxuLyoqKioqKi9cXG4vKioqKioqLyBcXHRcXHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXFxuLyoqKioqKi8gXFx0XFx0bW9kdWxlLmwgPSB0cnVlO1xcbi8qKioqKiovXFxuLyoqKioqKi8gXFx0XFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcXG4vKioqKioqLyBcXHRcXHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XFxuLyoqKioqKi8gXFx0fVxcbi8qKioqKiovXFxuLyoqKioqKi9cXG4vKioqKioqLyBcXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxcbi8qKioqKiovIFxcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XFxuLyoqKioqKi9cXG4vKioqKioqLyBcXHQvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxcbi8qKioqKiovIFxcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XFxuLyoqKioqKi9cXG4vKioqKioqLyBcXHQvLyBpZGVudGl0eSBmdW5jdGlvbiBmb3IgY2FsbGluZyBoYXJtb255IGltcG9ydHMgd2l0aCB0aGUgY29ycmVjdCBjb250ZXh0XFxuLyoqKioqKi8gXFx0X193ZWJwYWNrX3JlcXVpcmVfXy5pID0gZnVuY3Rpb24odmFsdWUpIHsgcmV0dXJuIHZhbHVlOyB9O1xcbi8qKioqKiovXFxuLyoqKioqKi8gXFx0Ly8gZGVmaW5lIGdldHRlciBmdW5jdGlvbiBmb3IgaGFybW9ueSBleHBvcnRzXFxuLyoqKioqKi8gXFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kID0gZnVuY3Rpb24oZXhwb3J0cywgbmFtZSwgZ2V0dGVyKSB7XFxuLyoqKioqKi8gXFx0XFx0aWYoIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBuYW1lKSkge1xcbi8qKioqKiovIFxcdFxcdFxcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBuYW1lLCB7XFxuLyoqKioqKi8gXFx0XFx0XFx0XFx0Y29uZmlndXJhYmxlOiBmYWxzZSxcXG4vKioqKioqLyBcXHRcXHRcXHRcXHRlbnVtZXJhYmxlOiB0cnVlLFxcbi8qKioqKiovIFxcdFxcdFxcdFxcdGdldDogZ2V0dGVyXFxuLyoqKioqKi8gXFx0XFx0XFx0fSk7XFxuLyoqKioqKi8gXFx0XFx0fVxcbi8qKioqKiovIFxcdH07XFxuLyoqKioqKi9cXG4vKioqKioqLyBcXHQvLyBnZXREZWZhdWx0RXhwb3J0IGZ1bmN0aW9uIGZvciBjb21wYXRpYmlsaXR5IHdpdGggbm9uLWhhcm1vbnkgbW9kdWxlc1xcbi8qKioqKiovIFxcdF9fd2VicGFja19yZXF1aXJlX18ubiA9IGZ1bmN0aW9uKG1vZHVsZSkge1xcbi8qKioqKiovIFxcdFxcdHZhciBnZXR0ZXIgPSBtb2R1bGUgJiYgbW9kdWxlLl9fZXNNb2R1bGUgP1xcbi8qKioqKiovIFxcdFxcdFxcdGZ1bmN0aW9uIGdldERlZmF1bHQoKSB7IHJldHVybiBtb2R1bGVbJ2RlZmF1bHQnXTsgfSA6XFxuLyoqKioqKi8gXFx0XFx0XFx0ZnVuY3Rpb24gZ2V0TW9kdWxlRXhwb3J0cygpIHsgcmV0dXJuIG1vZHVsZTsgfTtcXG4vKioqKioqLyBcXHRcXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQoZ2V0dGVyLCAnYScsIGdldHRlcik7XFxuLyoqKioqKi8gXFx0XFx0cmV0dXJuIGdldHRlcjtcXG4vKioqKioqLyBcXHR9O1xcbi8qKioqKiovXFxuLyoqKioqKi8gXFx0Ly8gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsXFxuLyoqKioqKi8gXFx0X193ZWJwYWNrX3JlcXVpcmVfXy5vID0gZnVuY3Rpb24ob2JqZWN0LCBwcm9wZXJ0eSkgeyByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpOyB9O1xcbi8qKioqKiovXFxuLyoqKioqKi8gXFx0Ly8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cXG4vKioqKioqLyBcXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcXFwiXFxcIjtcXG4vKioqKioqL1xcbi8qKioqKiovIFxcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xcbi8qKioqKiovIFxcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKF9fd2VicGFja19yZXF1aXJlX18ucyA9IDEpO1xcbi8qKioqKiovIH0pXFxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cXG4vKioqKioqLyAoW1xcbi8qIDAgKi9cXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XFxuXFxuXFxcInVzZSBzdHJpY3RcXFwiO1xcblxcblxcbnZhciBfdHlwZW9mID0gdHlwZW9mIFN5bWJvbCA9PT0gXFxcImZ1bmN0aW9uXFxcIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcXFwic3ltYm9sXFxcIiA/IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH0gOiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXFxcImZ1bmN0aW9uXFxcIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcXFwic3ltYm9sXFxcIiA6IHR5cGVvZiBvYmo7IH07XFxuXFxudmFyIHByZWZpeCA9ICd0bS1jb2RlJztcXG5cXG52YXIgZ2V0RXhwYW5kZXJDbGFzc2VzID0gZnVuY3Rpb24gZ2V0RXhwYW5kZXJDbGFzc2VzKGV4cGFuZGVkKSB7XFxuXFx0aWYgKCFleHBhbmRlZCkge1xcblxcdFxcdHJldHVybiAnZXhwYW5kZWQgY29sbGFwc2VkIGhpZGRlbic7XFxuXFx0fVxcblxcdHJldHVybiAnZXhwYW5kZWQnO1xcbn07XFxuXFxudmFyIGVuY29kZSA9IGZ1bmN0aW9uIGVuY29kZSh2YWx1ZSkge1xcblxcdHJldHVybiBbJzxzcGFuPicsIHZhbHVlLCAnPC9zcGFuPiddLmpvaW4oJycpO1xcbn07XFxuXFxudmFyIGNyZWF0ZUVsZW1lbnQgPSBmdW5jdGlvbiBjcmVhdGVFbGVtZW50KGtleSwgdmFsdWUsIHR5cGUsIGV4cGFuZGVyQ2xhc3Nlcykge1xcblxcdHZhciBrbGFzcyA9ICdvYmplY3QnLFxcblxcdCAgICBvcGVuID0gJ3snLFxcblxcdCAgICBjbG9zZSA9ICd9JztcXG5cXG5cXHRpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcXG5cXHRcXHRrbGFzcyA9ICdhcnJheSc7XFxuXFx0XFx0b3BlbiA9ICdbJztcXG5cXHRcXHRjbG9zZSA9ICddJztcXG5cXHR9XFxuXFxuXFx0aWYgKHZhbHVlID09PSBudWxsKSB7XFxuXFx0XFx0cmV0dXJuIFsnPGxpPicsICc8c3BhbiBjbGFzcz1cXFwia2V5XFxcIj5cXFwiJywgZW5jb2RlKGtleSksICdcXFwiOiA8L3NwYW4+JywgJzxzcGFuIGNsYXNzPVxcXCJudWxsXFxcIj5cXFwiJywgZW5jb2RlKHZhbHVlKSwgJ1xcXCI8L3NwYW4+JywgJzwvbGk+J10uam9pbignJyk7XFxuXFx0fVxcblxcblxcdGlmICh0eXBlID09ICdvYmplY3QnKSB7XFxuXFx0XFx0cmV0dXJuIFsnPGxpPicsICc8c3BhbiBjbGFzcz1cXFwiJywgZXhwYW5kZXJDbGFzc2VzLCAnXFxcIj48L3NwYW4+JywgJzxzcGFuIGNsYXNzPVxcXCJrZXlcXFwiPlxcXCInLCBlbmNvZGUoa2V5KSwgJ1xcXCI6IDwvc3Bhbj4gJywgJzxzcGFuIGNsYXNzPVxcXCJvcGVuXFxcIj4nLCBvcGVuLCAnPC9zcGFuPiAnLCAnPHVsIGNsYXNzPVxcXCInLCBrbGFzcywgJ1xcXCI+JywganNvbjJodG1sKHZhbHVlLCBleHBhbmRlckNsYXNzZXMpLCAnPC91bD4nLCAnPHNwYW4gY2xhc3M9XFxcImNsb3NlXFxcIj4nLCBjbG9zZSwgJzwvc3Bhbj4nLCAnPC9saT4nXS5qb2luKCcnKTtcXG5cXHR9XFxuXFxuXFx0aWYgKHR5cGUgPT0gJ251bWJlcicgfHwgdHlwZSA9PSAnYm9vbGVhbicpIHtcXG5cXHRcXHRyZXR1cm4gWyc8bGk+JywgJzxzcGFuIGNsYXNzPVxcXCJrZXlcXFwiPlxcXCInLCBlbmNvZGUoa2V5KSwgJ1xcXCI6IDwvc3Bhbj4nLCAnPHNwYW4gY2xhc3M9XFxcIicsIHR5cGUsICdcXFwiPicsIGVuY29kZSh2YWx1ZSksICc8L3NwYW4+JywgJzwvbGk+J10uam9pbignJyk7XFxuXFx0fVxcblxcdHJldHVybiBbJzxsaT4nLCAnPHNwYW4gY2xhc3M9XFxcImtleVxcXCI+XFxcIicsIGVuY29kZShrZXkpLCAnXFxcIjogPC9zcGFuPicsICc8c3BhbiBjbGFzcz1cXFwiJywgdHlwZSwgJ1xcXCI+XFxcIicsIGVuY29kZSh2YWx1ZSksICdcXFwiPC9zcGFuPicsICc8L2xpPiddLmpvaW4oJycpO1xcbn07XFxuXFxudmFyIGpzb24yaHRtbCA9IGZ1bmN0aW9uIGpzb24yaHRtbChqc29uLCBleHBhbmRlckNsYXNzZXMpIHtcXG5cXHR2YXIgaHRtbCA9ICcnO1xcblxcdGZvciAodmFyIGtleSBpbiBqc29uKSB7XFxuXFx0XFx0aWYgKCFqc29uLmhhc093blByb3BlcnR5KGtleSkpIHtcXG5cXHRcXHRcXHRjb250aW51ZTtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0aHRtbCA9IFtodG1sLCBjcmVhdGVFbGVtZW50KGtleSwganNvbltrZXldLCBfdHlwZW9mKGpzb25ba2V5XSksIGV4cGFuZGVyQ2xhc3NlcyldLmpvaW4oJycpO1xcblxcdH1cXG5cXHRyZXR1cm4gaHRtbDtcXG59O1xcblxcbnZhciBnZXRKc29uVmlld2VyID0gZnVuY3Rpb24gZ2V0SnNvblZpZXdlcihkYXRhLCBvcHRpb25zKSB7XFxuXFx0dHJ5IHtcXG5cXHRcXHRyZXR1cm4gWyc8dWwgY2xhc3M9XFxcIicsIHByZWZpeCwgJy1jb250YWluZXJcXFwiPicsIGpzb24yaHRtbChbSlNPTi5wYXJzZShkYXRhKV0sIGdldEV4cGFuZGVyQ2xhc3NlcyhvcHRpb25zLmV4cGFuZGVkKSksICc8L3VsPiddLmpvaW4oJycpO1xcblxcdH0gY2F0Y2ggKGUpIHtcXG5cXHRcXHRyZXR1cm4gWyc8ZGl2IGNsYXNzPVxcXCInLCBwcmVmaXgsICctZXJyb3JcXFwiID4nLCBlLnRvU3RyaW5nKCksICcgPC9kaXY+J10uam9pbignJyk7XFxuXFx0fVxcbn07XFxuXFxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZGF0YSwgb3B0KSB7XFxuXFx0dmFyIGpzb24gPSAnJztcXG5cXHR2YXIgb3B0aW9ucyA9IG9wdCB8fCB7IGV4cGFuZGVkOiB0cnVlIH07XFxuXFx0aWYgKHR5cGVvZiBkYXRhID09ICdzdHJpbmcnKSB7XFxuXFx0XFx0anNvbiA9IGRhdGE7XFxuXFx0fSBlbHNlIGlmICgodHlwZW9mIGRhdGEgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKGRhdGEpKSA9PSAnb2JqZWN0Jykge1xcblxcdFxcdGpzb24gPSBKU09OLnN0cmluZ2lmeShkYXRhKTtcXG5cXHR9XFxuXFx0cmV0dXJuIGdldEpzb25WaWV3ZXIoanNvbiwgb3B0aW9ucyk7XFxufTtcXG5cXG4vKioqLyB9KSxcXG4vKiAxICovXFxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xcblxcbi8qKlxcclxcbiAqIENvZGUgZm9ybWF0IHdlYi13b3JrZXJcXHJcXG4gKiBAcGFyYW0gZXZlbnRcXHJcXG4gKi9cXHJcXG4vLyB2YXIgaGlnaGxpZ2h0SnNvbigpXFxyXFxudmFyIGhpZ2hsaWdodEpzb24gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xcclxcblxcclxcbm9ubWVzc2FnZSA9IGZ1bmN0aW9uKGV2ZW50KSB7XFxyXFxuICB2YXIgY29kZSA9IGV2ZW50LmRhdGE7XFxyXFxuICAvLyBpbXBvcnRTY3JpcHRzKCdqc29uLXBhcnNlLmpzJyk7XFxyXFxuICB2YXIgcmVzdWx0ID0gaGlnaGxpZ2h0SnNvbihjb2RlLCB7ZXhwYW5kZWQ6IHRydWV9KTtcXHJcXG4gIC8vIHZhciByZXN1bHQgPUpTT04uc3RyaW5naWZ5KGNvZGUpO1xcclxcbiAgcG9zdE1lc3NhZ2UocmVzdWx0KTtcXHJcXG59O1xcclxcblxcblxcbi8qKiovIH0pXFxuLyoqKioqKi8gXSk7XFxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2NoYXJzZXQ9dXRmLTg7YmFzZTY0LGV5SjJaWEp6YVc5dUlqb3pMQ0p6YjNWeVkyVnpJanBiSW5kbFluQmhZMnM2THk4dmQyVmljR0ZqYXk5aWIyOTBjM1J5WVhBZ1lURXdOREprTkdRd1pqSTJOVFU0WkRKaFlqRWlMQ0ozWldKd1lXTnJPaTh2THk0dmMyTnlhWEIwY3k5aGNHa3RaWGh3Ykc5eVpYSXZkakl2YzNKakwzTmxjblpwWTJWekwycHpiMjR0YUdsbmFHeHBaMmgwTDJwemIyNHRjR0Z5YzJVdWFuTWlMQ0ozWldKd1lXTnJPaTh2THk0dmMyTnlhWEIwY3k5aGNHa3RaWGh3Ykc5eVpYSXZkakl2YzNKakwzTmxjblpwWTJWekwycHpiMjR0YUdsbmFHeHBaMmgwTDJocFoyaHNhV2RvZEVwemIyNHVkMjl5YTJWeUxtcHpJbDBzSW01aGJXVnpJanBiSW5CeVpXWnBlQ0lzSW1kbGRFVjRjR0Z1WkdWeVEyeGhjM05sY3lJc0ltVjRjR0Z1WkdWa0lpd2laVzVqYjJSbElpd2lkbUZzZFdVaUxDSnFiMmx1SWl3aVkzSmxZWFJsUld4bGJXVnVkQ0lzSW10bGVTSXNJblI1Y0dVaUxDSmxlSEJoYm1SbGNrTnNZWE56WlhNaUxDSnJiR0Z6Y3lJc0ltOXdaVzRpTENKamJHOXpaU0lzSWtGeWNtRjVJaXdpYVhOQmNuSmhlU0lzSW1wemIyNHlhSFJ0YkNJc0ltcHpiMjRpTENKb2RHMXNJaXdpYUdGelQzZHVVSEp2Y0dWeWRIa2lMQ0puWlhSS2MyOXVWbWxsZDJWeUlpd2laR0YwWVNJc0ltOXdkR2x2Ym5NaUxDSktVMDlPSWl3aWNHRnljMlVpTENKbElpd2lkRzlUZEhKcGJtY2lMQ0p0YjJSMWJHVWlMQ0psZUhCdmNuUnpJaXdpYjNCMElpd2ljM1J5YVc1bmFXWjVJbDBzSW0xaGNIQnBibWR6SWpvaU8wRkJRVUU3UVVGRFFUczdRVUZGUVR0QlFVTkJPenRCUVVWQk8wRkJRMEU3UVVGRFFUczdRVUZGUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3TzBGQlJVRTdRVUZEUVRzN1FVRkZRVHRCUVVOQk96dEJRVVZCTzBGQlEwRTdRVUZEUVRzN08wRkJSMEU3UVVGRFFUczdRVUZGUVR0QlFVTkJPenRCUVVWQk8wRkJRMEVzYlVSQlFUSkRMR05CUVdNN08wRkJSWHBFTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEVzWVVGQlN6dEJRVU5NTzBGQlEwRTdPMEZCUlVFN1FVRkRRVHRCUVVOQk8wRkJRMEVzYlVOQlFUSkNMREJDUVVFd1FpeEZRVUZGTzBGQlEzWkVMSGxEUVVGcFF5eGxRVUZsTzBGQlEyaEVPMEZCUTBFN1FVRkRRVHM3UVVGRlFUdEJRVU5CTERoRVFVRnpSQ3dyUkVGQkswUTdPMEZCUlhKSU8wRkJRMEU3TzBGQlJVRTdRVUZEUVRzN096czdPenM3T3pzN08wRkRhRVZCTEVsQlFVbEJMRk5CUVZNc1UwRkJZanM3UVVGRlFTeEpRVUZKUXl4eFFrRkJjVUlzVTBGQmNrSkJMR3RDUVVGeFFpeERRVUZWUXl4UlFVRldMRVZCUVc5Q08wRkJRelZETEV0QlFVa3NRMEZCUTBFc1VVRkJUQ3hGUVVGbE8wRkJRMlFzVTBGQlR5d3lRa0ZCVUR0QlFVTkJPMEZCUTBRc1VVRkJUeXhWUVVGUU8wRkJRMEVzUTBGTVJEczdRVUZQUVN4SlFVRkpReXhUUVVGVExGTkJRVlJCTEUxQlFWTXNRMEZCVlVNc1MwRkJWaXhGUVVGcFFqdEJRVU0zUWl4UlFVRlBMRU5CUVVNc1VVRkJSQ3hGUVVGWFFTeExRVUZZTEVWQlFXdENMRk5CUVd4Q0xFVkJRVFpDUXl4SlFVRTNRaXhEUVVGclF5eEZRVUZzUXl4RFFVRlFPMEZCUTBFc1EwRkdSRHM3UVVGSlFTeEpRVUZKUXl4blFrRkJaMElzVTBGQmFFSkJMR0ZCUVdkQ0xFTkJRVlZETEVkQlFWWXNSVUZCWlVnc1MwRkJaaXhGUVVGelFra3NTVUZCZEVJc1JVRkJORUpETEdWQlFUVkNMRVZCUVRaRE8wRkJRMmhGTEV0QlFVbERMRkZCUVZFc1VVRkJXanRCUVVGQkxFdEJRME5ETEU5QlFVOHNSMEZFVWp0QlFVRkJMRXRCUlVORExGRkJRVkVzUjBGR1ZEczdRVUZKUVN4TFFVRkpReXhOUVVGTlF5eFBRVUZPTEVOQlFXTldMRXRCUVdRc1EwRkJTaXhGUVVFd1FqdEJRVU42UWswc1ZVRkJVU3hQUVVGU08wRkJRMEZETEZOQlFVOHNSMEZCVUR0QlFVTkJReXhWUVVGUkxFZEJRVkk3UVVGRFFUczdRVUZGUkN4TFFVRkpVaXhWUVVGVkxFbEJRV1FzUlVGQmIwSTdRVUZEYmtJc1UwRkJUeXhEUVVOT0xFMUJSRTBzUlVGRlRDeHhRa0ZHU3l4RlFVVnJRa1FzVDBGQlQwa3NSMEZCVUN4RFFVWnNRaXhGUVVVclFpeFpRVVl2UWl4RlFVZE1MSE5DUVVoTExFVkJSMjFDU2l4UFFVRlBReXhMUVVGUUxFTkJTRzVDTEVWQlIydERMRlZCU0d4RExFVkJTVTRzVDBGS1RTeEZRVXRNUXl4SlFVeExMRU5CUzBFc1JVRk1RU3hEUVVGUU8wRkJUVUU3TzBGQlJVUXNTMEZCU1Vjc1VVRkJVU3hSUVVGYUxFVkJRWE5DTzBGQlEzSkNMRk5CUVU4c1EwRkRUaXhOUVVSTkxFVkJSVXdzWlVGR1N5eEZRVVZaUXl4bFFVWmFMRVZCUlRaQ0xGZEJSamRDTEVWQlIwd3NjVUpCU0Vzc1JVRkhhMEpPTEU5QlFVOUpMRWRCUVZBc1EwRkliRUlzUlVGSEswSXNZVUZJTDBJc1JVRkpUQ3h4UWtGS1N5eEZRVWxyUWtrc1NVRktiRUlzUlVGSmQwSXNWVUZLZUVJc1JVRkxUQ3hoUVV4TExFVkJTMVZFTEV0QlRGWXNSVUZMYVVJc1NVRk1ha0lzUlVGTlNrc3NWVUZCVlZnc1MwRkJWaXhGUVVGcFFrc3NaVUZCYWtJc1EwRk9TU3hGUVU5TUxFOUJVRXNzUlVGUlRDeHpRa0ZTU3l4RlFWRnRRa2NzUzBGU2JrSXNSVUZSTUVJc1UwRlNNVUlzUlVGVFRpeFBRVlJOTEVWQlZVeFFMRWxCVmtzc1EwRlZRU3hGUVZaQkxFTkJRVkE3UVVGWFFUczdRVUZGUkN4TFFVRkpSeXhSUVVGUkxGRkJRVklzU1VGQmIwSkJMRkZCUVZFc1UwRkJhRU1zUlVGQk1rTTdRVUZETVVNc1UwRkJUeXhEUVVOT0xFMUJSRTBzUlVGRlRDeHhRa0ZHU3l4RlFVVnJRa3dzVDBGQlQwa3NSMEZCVUN4RFFVWnNRaXhGUVVVclFpeFpRVVl2UWl4RlFVZE1MR1ZCU0Vzc1JVRkhXVU1zU1VGSVdpeEZRVWRyUWl4SlFVaHNRaXhGUVVkM1Frd3NUMEZCVDBNc1MwRkJVQ3hEUVVoNFFpeEZRVWQxUXl4VFFVaDJReXhGUVVsT0xFOUJTazBzUlVGTFRFTXNTVUZNU3l4RFFVdEJMRVZCVEVFc1EwRkJVRHRCUVUxQk8wRkJRMFFzVVVGQlR5eERRVU5PTEUxQlJFMHNSVUZGVEN4eFFrRkdTeXhGUVVWclFrWXNUMEZCVDBrc1IwRkJVQ3hEUVVac1FpeEZRVVVyUWl4WlFVWXZRaXhGUVVkTUxHVkJTRXNzUlVGSFdVTXNTVUZJV2l4RlFVZHJRaXhMUVVoc1FpeEZRVWQ1UWt3c1QwRkJUME1zUzBGQlVDeERRVWg2UWl4RlFVZDNReXhWUVVoNFF5eEZRVWxPTEU5QlNrMHNSVUZMVEVNc1NVRk1TeXhEUVV0QkxFVkJURUVzUTBGQlVEdEJRVTFCTEVOQmFFUkVPenRCUVd0RVFTeEpRVUZKVlN4WlFVRlpMRk5CUVZwQkxGTkJRVmtzUTBGQlZVTXNTVUZCVml4RlFVRm5RbEFzWlVGQmFFSXNSVUZCYVVNN1FVRkRhRVFzUzBGQlNWRXNUMEZCVHl4RlFVRllPMEZCUTBFc1RVRkJTeXhKUVVGSlZpeEhRVUZVTEVsQlFXZENVeXhKUVVGb1FpeEZRVUZ6UWp0QlFVTnlRaXhOUVVGSkxFTkJRVU5CTEV0QlFVdEZMR05CUVV3c1EwRkJiMEpZTEVkQlFYQkNMRU5CUVV3c1JVRkJLMEk3UVVGRE9VSTdRVUZEUVRzN1FVRkZSRlVzVTBGQlR5eERRVUZEUVN4SlFVRkVMRVZCUVU5WUxHTkJRV05ETEVkQlFXUXNSVUZCYlVKVExFdEJRVXRVTEVkQlFVd3NRMEZCYmtJc1ZVRkJjVU5UTEV0QlFVdFVMRWRCUVV3c1EwRkJja01zUjBGQlowUkZMR1ZCUVdoRUxFTkJRVkFzUlVGQmVVVktMRWxCUVhwRkxFTkJRVGhGTEVWQlFUbEZMRU5CUVZBN1FVRkRRVHRCUVVORUxGRkJRVTlaTEVsQlFWQTdRVUZEUVN4RFFWWkVPenRCUVZsQkxFbEJRVWxGTEdkQ1FVRm5RaXhUUVVGb1FrRXNZVUZCWjBJc1EwRkJWVU1zU1VGQlZpeEZRVUZuUWtNc1QwRkJhRUlzUlVGQmVVSTdRVUZETlVNc1MwRkJTVHRCUVVOSUxGTkJRVThzUTBGRFRpeGhRVVJOTEVWQlExTnlRaXhOUVVSVUxFVkJRMmxDTEdOQlJHcENMRVZCUlV4bExGVkJRVlVzUTBGQlEwOHNTMEZCUzBNc1MwRkJUQ3hEUVVGWFNDeEpRVUZZTEVOQlFVUXNRMEZCVml4RlFVRTRRbTVDTEcxQ1FVRnRRbTlDTEZGQlFWRnVRaXhSUVVFelFpeERRVUU1UWl4RFFVWkxMRVZCUjA0c1QwRklUU3hGUVVsTVJ5eEpRVXBMTEVOQlNVRXNSVUZLUVN4RFFVRlFPMEZCUzBFc1JVRk9SQ3hEUVUxRkxFOUJRVTl0UWl4RFFVRlFMRVZCUVZVN1FVRkRXQ3hUUVVGUExFTkJRMDRzWTBGRVRTeEZRVU5WZUVJc1RVRkVWaXhGUVVOclFpeFhRVVJzUWl4RlFVTXJRbmRDTEVWQlFVVkRMRkZCUVVZc1JVRkVMMElzUlVGRE5rTXNVMEZFTjBNc1JVRkZUSEJDTEVsQlJrc3NRMEZGUVN4RlFVWkJMRU5CUVZBN1FVRkhRVHRCUVVORUxFTkJXa1E3TzBGQlkwRnhRaXhQUVVGUFF5eFBRVUZRTEVkQlFXbENMRlZCUVZOUUxFbEJRVlFzUlVGQlpWRXNSMEZCWml4RlFVRnZRanRCUVVOd1F5eExRVUZKV2l4UFFVRlBMRVZCUVZnN1FVRkRRU3hMUVVGSlN5eFZRVUZWVHl4UFFVRlBMRVZCUVVNeFFpeFZRVUZWTEVsQlFWZ3NSVUZCY2tJN1FVRkRRU3hMUVVGSkxFOUJRVTlyUWl4SlFVRlFMRWxCUVdVc1VVRkJia0lzUlVGQk5rSTdRVUZETlVKS0xGTkJRVTlKTEVsQlFWQTdRVUZEUVN4RlFVWkVMRTFCUlU4c1NVRkJTU3hSUVVGUFFTeEpRVUZRTEhsRFFVRlBRU3hKUVVGUUxFMUJRV1VzVVVGQmJrSXNSVUZCTmtJN1FVRkRia05LTEZOQlFVOU5MRXRCUVV0UExGTkJRVXdzUTBGQlpWUXNTVUZCWml4RFFVRlFPMEZCUTBFN1FVRkRSQ3hSUVVGUFJDeGpRVUZqU0N4SlFVRmtMRVZCUVc5Q1N5eFBRVUZ3UWl4RFFVRlFPMEZCUTBFc1EwRlVSQ3hET3pzN096czdRVU42UmtFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CT3p0QlFVVkJPMEZCUTBFN1FVRkRRVHRCUVVOQkxHOURRVUZ2UXl4bFFVRmxPMEZCUTI1RU8wRkJRMEU3UVVGRFFTSXNJbVpwYkdVaU9pSm9hV2RvYkdsbmFIUktjMjl1TG5kdmNtdGxjaTVxY3lJc0luTnZkWEpqWlhORGIyNTBaVzUwSWpwYklpQmNkQzh2SUZSb1pTQnRiMlIxYkdVZ1kyRmphR1ZjYmlCY2RIWmhjaUJwYm5OMFlXeHNaV1JOYjJSMWJHVnpJRDBnZTMwN1hHNWNiaUJjZEM4dklGUm9aU0J5WlhGMWFYSmxJR1oxYm1OMGFXOXVYRzRnWEhSbWRXNWpkR2x2YmlCZlgzZGxZbkJoWTJ0ZmNtVnhkV2x5WlY5ZktHMXZaSFZzWlVsa0tTQjdYRzVjYmlCY2RGeDBMeThnUTJobFkyc2dhV1lnYlc5a2RXeGxJR2x6SUdsdUlHTmhZMmhsWEc0Z1hIUmNkR2xtS0dsdWMzUmhiR3hsWkUxdlpIVnNaWE5iYlc5a2RXeGxTV1JkS1Z4dUlGeDBYSFJjZEhKbGRIVnliaUJwYm5OMFlXeHNaV1JOYjJSMWJHVnpXMjF2WkhWc1pVbGtYUzVsZUhCdmNuUnpPMXh1WEc0Z1hIUmNkQzh2SUVOeVpXRjBaU0JoSUc1bGR5QnRiMlIxYkdVZ0tHRnVaQ0J3ZFhRZ2FYUWdhVzUwYnlCMGFHVWdZMkZqYUdVcFhHNGdYSFJjZEhaaGNpQnRiMlIxYkdVZ1BTQnBibk4wWVd4c1pXUk5iMlIxYkdWelcyMXZaSFZzWlVsa1hTQTlJSHRjYmlCY2RGeDBYSFJwT2lCdGIyUjFiR1ZKWkN4Y2JpQmNkRngwWEhSc09pQm1ZV3h6WlN4Y2JpQmNkRngwWEhSbGVIQnZjblJ6T2lCN2ZWeHVJRngwWEhSOU8xeHVYRzRnWEhSY2RDOHZJRVY0WldOMWRHVWdkR2hsSUcxdlpIVnNaU0JtZFc1amRHbHZibHh1SUZ4MFhIUnRiMlIxYkdWelcyMXZaSFZzWlVsa1hTNWpZV3hzS0cxdlpIVnNaUzVsZUhCdmNuUnpMQ0J0YjJSMWJHVXNJRzF2WkhWc1pTNWxlSEJ2Y25SekxDQmZYM2RsWW5CaFkydGZjbVZ4ZFdseVpWOWZLVHRjYmx4dUlGeDBYSFF2THlCR2JHRm5JSFJvWlNCdGIyUjFiR1VnWVhNZ2JHOWhaR1ZrWEc0Z1hIUmNkRzF2WkhWc1pTNXNJRDBnZEhKMVpUdGNibHh1SUZ4MFhIUXZMeUJTWlhSMWNtNGdkR2hsSUdWNGNHOXlkSE1nYjJZZ2RHaGxJRzF2WkhWc1pWeHVJRngwWEhSeVpYUjFjbTRnYlc5a2RXeGxMbVY0Y0c5eWRITTdYRzRnWEhSOVhHNWNibHh1SUZ4MEx5OGdaWGh3YjNObElIUm9aU0J0YjJSMWJHVnpJRzlpYW1WamRDQW9YMTkzWldKd1lXTnJYMjF2WkhWc1pYTmZYeWxjYmlCY2RGOWZkMlZpY0dGamExOXlaWEYxYVhKbFgxOHViU0E5SUcxdlpIVnNaWE03WEc1Y2JpQmNkQzh2SUdWNGNHOXpaU0IwYUdVZ2JXOWtkV3hsSUdOaFkyaGxYRzRnWEhSZlgzZGxZbkJoWTJ0ZmNtVnhkV2x5WlY5ZkxtTWdQU0JwYm5OMFlXeHNaV1JOYjJSMWJHVnpPMXh1WEc0Z1hIUXZMeUJwWkdWdWRHbDBlU0JtZFc1amRHbHZiaUJtYjNJZ1kyRnNiR2x1WnlCb1lYSnRiMjU1SUdsdGNHOXlkSE1nZDJsMGFDQjBhR1VnWTI5eWNtVmpkQ0JqYjI1MFpYaDBYRzRnWEhSZlgzZGxZbkJoWTJ0ZmNtVnhkV2x5WlY5Zkxta2dQU0JtZFc1amRHbHZiaWgyWVd4MVpTa2dleUJ5WlhSMWNtNGdkbUZzZFdVN0lIMDdYRzVjYmlCY2RDOHZJR1JsWm1sdVpTQm5aWFIwWlhJZ1puVnVZM1JwYjI0Z1ptOXlJR2hoY20xdmJua2daWGh3YjNKMGMxeHVJRngwWDE5M1pXSndZV05yWDNKbGNYVnBjbVZmWHk1a0lEMGdablZ1WTNScGIyNG9aWGh3YjNKMGN5d2dibUZ0WlN3Z1oyVjBkR1Z5S1NCN1hHNGdYSFJjZEdsbUtDRmZYM2RsWW5CaFkydGZjbVZ4ZFdseVpWOWZMbThvWlhod2IzSjBjeXdnYm1GdFpTa3BJSHRjYmlCY2RGeDBYSFJQWW1wbFkzUXVaR1ZtYVc1bFVISnZjR1Z5ZEhrb1pYaHdiM0owY3l3Z2JtRnRaU3dnZTF4dUlGeDBYSFJjZEZ4MFkyOXVabWxuZFhKaFlteGxPaUJtWVd4elpTeGNiaUJjZEZ4MFhIUmNkR1Z1ZFcxbGNtRmliR1U2SUhSeWRXVXNYRzRnWEhSY2RGeDBYSFJuWlhRNklHZGxkSFJsY2x4dUlGeDBYSFJjZEgwcE8xeHVJRngwWEhSOVhHNGdYSFI5TzF4dVhHNGdYSFF2THlCblpYUkVaV1poZFd4MFJYaHdiM0owSUdaMWJtTjBhVzl1SUdadmNpQmpiMjF3WVhScFltbHNhWFI1SUhkcGRHZ2dibTl1TFdoaGNtMXZibmtnYlc5a2RXeGxjMXh1SUZ4MFgxOTNaV0p3WVdOclgzSmxjWFZwY21WZlh5NXVJRDBnWm5WdVkzUnBiMjRvYlc5a2RXeGxLU0I3WEc0Z1hIUmNkSFpoY2lCblpYUjBaWElnUFNCdGIyUjFiR1VnSmlZZ2JXOWtkV3hsTGw5ZlpYTk5iMlIxYkdVZ1AxeHVJRngwWEhSY2RHWjFibU4wYVc5dUlHZGxkRVJsWm1GMWJIUW9LU0I3SUhKbGRIVnliaUJ0YjJSMWJHVmJKMlJsWm1GMWJIUW5YVHNnZlNBNlhHNGdYSFJjZEZ4MFpuVnVZM1JwYjI0Z1oyVjBUVzlrZFd4bFJYaHdiM0owY3lncElIc2djbVYwZFhKdUlHMXZaSFZzWlRzZ2ZUdGNiaUJjZEZ4MFgxOTNaV0p3WVdOclgzSmxjWFZwY21WZlh5NWtLR2RsZEhSbGNpd2dKMkVuTENCblpYUjBaWElwTzF4dUlGeDBYSFJ5WlhSMWNtNGdaMlYwZEdWeU8xeHVJRngwZlR0Y2JseHVJRngwTHk4Z1QySnFaV04wTG5CeWIzUnZkSGx3WlM1b1lYTlBkMjVRY205d1pYSjBlUzVqWVd4c1hHNGdYSFJmWDNkbFluQmhZMnRmY21WeGRXbHlaVjlmTG04Z1BTQm1kVzVqZEdsdmJpaHZZbXBsWTNRc0lIQnliM0JsY25SNUtTQjdJSEpsZEhWeWJpQlBZbXBsWTNRdWNISnZkRzkwZVhCbExtaGhjMDkzYmxCeWIzQmxjblI1TG1OaGJHd29iMkpxWldOMExDQndjbTl3WlhKMGVTazdJSDA3WEc1Y2JpQmNkQzh2SUY5ZmQyVmljR0ZqYTE5d2RXSnNhV05mY0dGMGFGOWZYRzRnWEhSZlgzZGxZbkJoWTJ0ZmNtVnhkV2x5WlY5ZkxuQWdQU0JjSWx3aU8xeHVYRzRnWEhRdkx5Qk1iMkZrSUdWdWRISjVJRzF2WkhWc1pTQmhibVFnY21WMGRYSnVJR1Y0Y0c5eWRITmNiaUJjZEhKbGRIVnliaUJmWDNkbFluQmhZMnRmY21WeGRXbHlaVjlmS0Y5ZmQyVmljR0ZqYTE5eVpYRjFhWEpsWDE4dWN5QTlJREVwTzF4dVhHNWNibHh1THk4Z1YwVkNVRUZEU3lCR1QwOVVSVklnTHk5Y2JpOHZJSGRsWW5CaFkyc3ZZbTl2ZEhOMGNtRndJR0V4TURReVpEUmtNR1l5TmpVMU9HUXlZV0l4SWl3aWRtRnlJSEJ5WldacGVDQTlJQ2QwYlMxamIyUmxKenRjY2x4dVhISmNiblpoY2lCblpYUkZlSEJoYm1SbGNrTnNZWE56WlhNZ1BTQm1kVzVqZEdsdmJpQW9aWGh3WVc1a1pXUXBJSHRjY2x4dVhIUnBaaUFvSVdWNGNHRnVaR1ZrS1NCN1hISmNibHgwWEhSeVpYUjFjbTRnSjJWNGNHRnVaR1ZrSUdOdmJHeGhjSE5sWkNCb2FXUmtaVzRuTzF4eVhHNWNkSDFjY2x4dVhIUnlaWFIxY200Z0oyVjRjR0Z1WkdWa0p6dGNjbHh1ZlR0Y2NseHVYSEpjYm5aaGNpQmxibU52WkdVZ1BTQm1kVzVqZEdsdmJpQW9kbUZzZFdVcElIdGNjbHh1WEhSeVpYUjFjbTRnV3ljOGMzQmhiajRuTENCMllXeDFaU3dnSnp3dmMzQmhiajRuWFM1cWIybHVLQ2NuS1R0Y2NseHVmVHRjY2x4dVhISmNiblpoY2lCamNtVmhkR1ZGYkdWdFpXNTBJRDBnWm5WdVkzUnBiMjRnS0d0bGVTd2dkbUZzZFdVc0lIUjVjR1VzSUdWNGNHRnVaR1Z5UTJ4aGMzTmxjeWtnZTF4eVhHNWNkSFpoY2lCcmJHRnpjeUE5SUNkdlltcGxZM1FuTEZ4eVhHNWNkRngwYjNCbGJpQTlJQ2Q3Snl4Y2NseHVYSFJjZEdOc2IzTmxJRDBnSjMwbk8xeHlYRzVjY2x4dVhIUnBaaUFvUVhKeVlYa3VhWE5CY25KaGVTaDJZV3gxWlNrcElIdGNjbHh1WEhSY2RHdHNZWE56SUQwZ0oyRnljbUY1Snp0Y2NseHVYSFJjZEc5d1pXNGdQU0FuV3ljN1hISmNibHgwWEhSamJHOXpaU0E5SUNkZEp6dGNjbHh1WEhSOVhISmNibHh5WEc1Y2RHbG1JQ2gyWVd4MVpTQTlQVDBnYm5Wc2JDa2dlMXh5WEc1Y2RGeDBjbVYwZFhKdUlGdGNjbHh1WEhSY2RGeDBKenhzYVQ0bkxGeHlYRzVjZEZ4MFhIUmNkQ2M4YzNCaGJpQmpiR0Z6Y3oxY0ltdGxlVndpUGx3aUp5d2daVzVqYjJSbEtHdGxlU2tzSUNkY0lqb2dQQzl6Y0dGdVBpY3NYSEpjYmx4MFhIUmNkRngwSnp4emNHRnVJR05zWVhOelBWd2liblZzYkZ3aVBsd2lKeXdnWlc1amIyUmxLSFpoYkhWbEtTd2dKMXdpUEM5emNHRnVQaWNzWEhKY2JseDBYSFJjZENjOEwyeHBQaWRjY2x4dVhIUmNkRjB1YW05cGJpZ25KeWs3WEhKY2JseDBmVnh5WEc1Y2NseHVYSFJwWmlBb2RIbHdaU0E5UFNBbmIySnFaV04wSnlrZ2UxeHlYRzVjZEZ4MGNtVjBkWEp1SUZ0Y2NseHVYSFJjZEZ4MEp6eHNhVDRuTEZ4eVhHNWNkRngwWEhSY2RDYzhjM0JoYmlCamJHRnpjejFjSWljc0lHVjRjR0Z1WkdWeVEyeGhjM05sY3l3Z0oxd2lQand2YzNCaGJqNG5MRnh5WEc1Y2RGeDBYSFJjZENjOGMzQmhiaUJqYkdGemN6MWNJbXRsZVZ3aVBsd2lKeXdnWlc1amIyUmxLR3RsZVNrc0lDZGNJam9nUEM5emNHRnVQaUFuTEZ4eVhHNWNkRngwWEhSY2RDYzhjM0JoYmlCamJHRnpjejFjSW05d1pXNWNJajRuTENCdmNHVnVMQ0FuUEM5emNHRnVQaUFuTEZ4eVhHNWNkRngwWEhSY2RDYzhkV3dnWTJ4aGMzTTlYQ0luTENCcmJHRnpjeXdnSjF3aVBpY3NYSEpjYmx4MFhIUmNkRngwWEhScWMyOXVNbWgwYld3b2RtRnNkV1VzSUdWNGNHRnVaR1Z5UTJ4aGMzTmxjeWtzWEhKY2JseDBYSFJjZEZ4MEp6d3ZkV3crSnl4Y2NseHVYSFJjZEZ4MFhIUW5QSE53WVc0Z1kyeGhjM005WENKamJHOXpaVndpUGljc0lHTnNiM05sTENBblBDOXpjR0Z1UGljc1hISmNibHgwWEhSY2RDYzhMMnhwUGlkY2NseHVYSFJjZEYwdWFtOXBiaWduSnlrN1hISmNibHgwZlZ4eVhHNWNjbHh1WEhScFppQW9kSGx3WlNBOVBTQW5iblZ0WW1WeUp5QjhmQ0IwZVhCbElEMDlJQ2RpYjI5c1pXRnVKeWtnZTF4eVhHNWNkRngwY21WMGRYSnVJRnRjY2x4dVhIUmNkRngwSnp4c2FUNG5MRnh5WEc1Y2RGeDBYSFJjZENjOGMzQmhiaUJqYkdGemN6MWNJbXRsZVZ3aVBsd2lKeXdnWlc1amIyUmxLR3RsZVNrc0lDZGNJam9nUEM5emNHRnVQaWNzWEhKY2JseDBYSFJjZEZ4MEp6eHpjR0Z1SUdOc1lYTnpQVndpSnl3Z2RIbHdaU3dnSjF3aVBpY3NJR1Z1WTI5a1pTaDJZV3gxWlNrc0lDYzhMM053WVc0K0p5eGNjbHh1WEhSY2RGeDBKend2YkdrK0oxeHlYRzVjZEZ4MFhTNXFiMmx1S0NjbktUdGNjbHh1WEhSOVhISmNibHgwY21WMGRYSnVJRnRjY2x4dVhIUmNkQ2M4YkdrK0p5eGNjbHh1WEhSY2RGeDBKenh6Y0dGdUlHTnNZWE56UFZ3aWEyVjVYQ0krWENJbkxDQmxibU52WkdVb2EyVjVLU3dnSjF3aU9pQThMM053WVc0K0p5eGNjbHh1WEhSY2RGeDBKenh6Y0dGdUlHTnNZWE56UFZ3aUp5d2dkSGx3WlN3Z0oxd2lQbHdpSnl3Z1pXNWpiMlJsS0haaGJIVmxLU3dnSjF3aVBDOXpjR0Z1UGljc1hISmNibHgwWEhRblBDOXNhVDRuWEhKY2JseDBYUzVxYjJsdUtDY25LVHRjY2x4dWZUdGNjbHh1WEhKY2JuWmhjaUJxYzI5dU1taDBiV3dnUFNCbWRXNWpkR2x2YmlBb2FuTnZiaXdnWlhod1lXNWtaWEpEYkdGemMyVnpLU0I3WEhKY2JseDBkbUZ5SUdoMGJXd2dQU0FuSnp0Y2NseHVYSFJtYjNJZ0tIWmhjaUJyWlhrZ2FXNGdhbk52YmlrZ2UxeHlYRzVjZEZ4MGFXWWdLQ0ZxYzI5dUxtaGhjMDkzYmxCeWIzQmxjblI1S0d0bGVTa3BJSHRjY2x4dVhIUmNkRngwWTI5dWRHbHVkV1U3WEhKY2JseDBYSFI5WEhKY2JseHlYRzVjZEZ4MGFIUnRiQ0E5SUZ0b2RHMXNMQ0JqY21WaGRHVkZiR1Z0Wlc1MEtHdGxlU3dnYW5OdmJsdHJaWGxkTENCMGVYQmxiMllnYW5OdmJsdHJaWGxkTENCbGVIQmhibVJsY2tOc1lYTnpaWE1wWFM1cWIybHVLQ2NuS1R0Y2NseHVYSFI5WEhKY2JseDBjbVYwZFhKdUlHaDBiV3c3WEhKY2JuMDdYSEpjYmx4eVhHNTJZWElnWjJWMFNuTnZibFpwWlhkbGNpQTlJR1oxYm1OMGFXOXVJQ2hrWVhSaExDQnZjSFJwYjI1ektTQjdYSEpjYmx4MGRISjVJSHRjY2x4dVhIUmNkSEpsZEhWeWJpQmJYSEpjYmx4MFhIUmNkQ2M4ZFd3Z1kyeGhjM005WENJbkxDQndjbVZtYVhnc0lDY3RZMjl1ZEdGcGJtVnlYQ0krSnl4Y2NseHVYSFJjZEZ4MFhIUnFjMjl1TW1oMGJXd29XMHBUVDA0dWNHRnljMlVvWkdGMFlTbGRMQ0JuWlhSRmVIQmhibVJsY2tOc1lYTnpaWE1vYjNCMGFXOXVjeTVsZUhCaGJtUmxaQ2twTEZ4eVhHNWNkRngwWEhRblBDOTFiRDRuWEhKY2JseDBYSFJkTG1wdmFXNG9KeWNwTzF4eVhHNWNkSDBnWTJGMFkyZ2dLR1VwSUh0Y2NseHVYSFJjZEhKbGRIVnliaUJiWEhKY2JseDBYSFJjZENjOFpHbDJJR05zWVhOelBWd2lKeXdnY0hKbFptbDRMQ0FuTFdWeWNtOXlYQ0lnUGljc0lHVXVkRzlUZEhKcGJtY29LU3dnSnlBOEwyUnBkajRuWEhKY2JseDBYSFJkTG1wdmFXNG9KeWNwTzF4eVhHNWNkSDFjY2x4dWZUdGNjbHh1WEhKY2JtMXZaSFZzWlM1bGVIQnZjblJ6SUQwZ1puVnVZM1JwYjI0b1pHRjBZU3dnYjNCMEtTQjdYSEpjYmx4MGRtRnlJR3B6YjI0Z1BTQW5KenRjY2x4dVhIUjJZWElnYjNCMGFXOXVjeUE5SUc5d2RDQjhmQ0I3Wlhod1lXNWtaV1E2SUhSeWRXVjlPMXh5WEc1Y2RHbG1JQ2gwZVhCbGIyWWdaR0YwWVNBOVBTQW5jM1J5YVc1bkp5a2dlMXh5WEc1Y2RGeDBhbk52YmlBOUlHUmhkR0U3WEhKY2JseDBmU0JsYkhObElHbG1JQ2gwZVhCbGIyWWdaR0YwWVNBOVBTQW5iMkpxWldOMEp5a2dlMXh5WEc1Y2RGeDBhbk52YmlBOUlFcFRUMDR1YzNSeWFXNW5hV1o1S0dSaGRHRXBYSEpjYmx4MGZWeHlYRzVjZEhKbGRIVnliaUJuWlhSS2MyOXVWbWxsZDJWeUtHcHpiMjRzSUc5d2RHbHZibk1wTzF4eVhHNTlPMXh5WEc1Y2JseHVYRzR2THlCWFJVSlFRVU5MSUVaUFQxUkZVaUF2TDF4dUx5OGdMaTl6WTNKcGNIUnpMMkZ3YVMxbGVIQnNiM0psY2k5Mk1pOXpjbU12YzJWeWRtbGpaWE12YW5OdmJpMW9hV2RvYkdsbmFIUXZhbk52Ymkxd1lYSnpaUzVxY3lJc0lpOHFLbHh5WEc0Z0tpQkRiMlJsSUdadmNtMWhkQ0IzWldJdGQyOXlhMlZ5WEhKY2JpQXFJRUJ3WVhKaGJTQmxkbVZ1ZEZ4eVhHNGdLaTljY2x4dUx5OGdkbUZ5SUdocFoyaHNhV2RvZEVwemIyNG9LVnh5WEc1MllYSWdhR2xuYUd4cFoyaDBTbk52YmlBOUlISmxjWFZwY21Vb0p5NHZhbk52Ymkxd1lYSnpaU2NwTzF4eVhHNWNjbHh1YjI1dFpYTnpZV2RsSUQwZ1puVnVZM1JwYjI0b1pYWmxiblFwSUh0Y2NseHVJQ0IyWVhJZ1kyOWtaU0E5SUdWMlpXNTBMbVJoZEdFN1hISmNiaUFnTHk4Z2FXMXdiM0owVTJOeWFYQjBjeWduYW5OdmJpMXdZWEp6WlM1cWN5Y3BPMXh5WEc0Z0lIWmhjaUJ5WlhOMWJIUWdQU0JvYVdkb2JHbG5hSFJLYzI5dUtHTnZaR1VzSUh0bGVIQmhibVJsWkRvZ2RISjFaWDBwTzF4eVhHNGdJQzh2SUhaaGNpQnlaWE4xYkhRZ1BVcFRUMDR1YzNSeWFXNW5hV1o1S0dOdlpHVXBPMXh5WEc0Z0lIQnZjM1JOWlhOellXZGxLSEpsYzNWc2RDazdYSEpjYm4wN1hISmNibHh1WEc1Y2JpOHZMeTh2THk4dkx5OHZMeTh2THk4dkwxeHVMeThnVjBWQ1VFRkRTeUJHVDA5VVJWSmNiaTh2SUM0dmMyTnlhWEIwY3k5aGNHa3RaWGh3Ykc5eVpYSXZkakl2YzNKakwzTmxjblpwWTJWekwycHpiMjR0YUdsbmFHeHBaMmgwTDJocFoyaHNhV2RvZEVwemIyNHVkMjl5YTJWeUxtcHpYRzR2THlCdGIyUjFiR1VnYVdRZ1BTQXhYRzR2THlCdGIyUjFiR1VnWTJoMWJtdHpJRDBnTUNKZExDSnpiM1Z5WTJWU2IyOTBJam9pSW4wPVwiLCBfX3dlYnBhY2tfcHVibGljX3BhdGhfXyArIFwiaGlnaGxpZ2h0SnNvbi53b3JrZXIuanNcIik7XG59O1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NjcmlwdHMvYXBpLWV4cGxvcmVyL3YyL3NyYy9zZXJ2aWNlcy9qc29uLWhpZ2hsaWdodC9oaWdobGlnaHRKc29uLndvcmtlci5qcyIsIi8qKlxyXG4gKiBDdXN0b20gaW5wdXQgY29tcG9uZW50XHJcbiAqL1xyXG5cclxuY2xhc3MgQ3VzdG9tSW5wdXQge1xyXG5cdGNvbnN0cnVjdG9yKHtvbkZvY3VzTWV0aG9kLCBkYXRhID0ge3ZhbHVlOiAnJywgaXNEaXJ0eTogZmFsc2UsIHJlcXVpcmVkOiBmYWxzZX0sICBjc3NDbGFzcyA9ICcnLCB2YWxpZGF0aW9uTW9kZWx9KSB7XHJcblx0XHR0aGlzLmRhdGEgPSBkYXRhO1xyXG5cdFx0dGhpcy5mb2N1c01ldGhvZCA9IG9uRm9jdXNNZXRob2Q7XHJcblx0XHR0aGlzLnBsYWNlaG9sZGVyID0gZGF0YS5wbGFjZWhvbGRlciB8fCBkYXRhLm5hbWU7XHJcblx0XHR0aGlzLmlkID0gZGF0YS5uYW1lO1xyXG5cdFx0dGhpcy5pc1ZpcmdpbiA9IGtvLm9ic2VydmFibGUodHJ1ZSk7XHJcblx0XHQvLyBjc3MgY2xhc3Nlc1xyXG5cdFx0dGhpcy5jc3NDbGFzcyA9IGNzc0NsYXNzO1xyXG5cclxuXHRcdC8vIERpcnR5IHdhdGNoZXJcclxuXHRcdHRoaXMuZmllbGRXYXRjaGVyKGRhdGEpO1xyXG5cdFx0Ly8gVmFsaWRhdGlvblxyXG5cdFx0dGhpcy5pbml0VmFsaWRhdGlvbihkYXRhLCB2YWxpZGF0aW9uTW9kZWwpO1xyXG5cdH1cclxuXHRcclxuXHQvKipcclxuXHQgKiBEaXJ0eSB3YXRjaGVyIG1ldGhvZFxyXG5cdCAqIEBwYXJhbSBkYXRhIHtvYmplY3R9XHJcblx0ICovXHJcblx0ZmllbGRXYXRjaGVyKGRhdGEpIHtcclxuXHRcdHRoaXMuaXNEaXJ0eSA9IGRhdGEuaXNEaXJ0eSA9IGtvLnB1cmVDb21wdXRlZCgoKSA9PiB7XHJcblx0XHRcdHJldHVybiAhIShkYXRhLnZhbHVlKCkudG9TdHJpbmcoKSkudHJpbSgpLmxlbmd0aDtcclxuXHRcdH0pO1xyXG5cdH1cclxuXHRcclxuXHQvKipcclxuXHQgKiBWYWxpZGF0aW9uIGluaXQgbWV0aG9kXHJcblx0ICogQHBhcmFtIGRhdGEge29iamVjdH1cclxuXHQgKiBAcGFyYW0gdmFsaWRhdGlvbk1vZGVsIHtvYmplY3R9XHJcblx0ICovXHJcblx0aW5pdFZhbGlkYXRpb24oZGF0YSwgdmFsaWRhdGlvbk1vZGVsKSB7XHJcblx0XHRsZXQgb2JqID0ge3JlcXVpcmVkOiBkYXRhLnJlcXVpcmVkfTtcclxuXHJcblx0XHQvLyB2YWxpZGF0aW9uIGJ5IHR5cGVcclxuXHRcdHN3aXRjaCAoZGF0YS50eXBlKSB7XHJcblx0XHRcdGNhc2UgJ2ludGVnZXInOlxyXG5cdFx0XHRcdG9iai5udWxsYWJsZUludCA9IGRhdGEudmFsdWU7XHJcblx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdGRlZmF1bHQ6XHJcblx0XHRcdFx0YnJlYWs7XHJcblx0XHR9XHJcblx0XHRcclxuXHRcdHRoaXMudmFsdWUgPSBkYXRhLnZhbHVlLmV4dGVuZChvYmopO1xyXG5cdFx0bGV0IG1vZGVsID0ga28udW53cmFwKHZhbGlkYXRpb25Nb2RlbCk7XHJcblx0XHRtb2RlbFtkYXRhLm5hbWVdID0gdGhpcy52YWx1ZTtcclxuXHRcdHZhbGlkYXRpb25Nb2RlbChtb2RlbCk7XHJcblx0fVxyXG5cdFxyXG5cdC8qKlxyXG5cdCAqIE9uIGZpZWxkIGluIGZvY3VzIG1ldGhvZFxyXG5cdCAqIEBwYXJhbSBkYXRhIHtvYmplY3R9XHJcblx0ICovXHJcblx0b25Gb2N1c01ldGhvZChkYXRhKSB7XHJcblx0XHR0aGlzLmZvY3VzTWV0aG9kICYmIHRoaXMuZm9jdXNNZXRob2QoZGF0YSlcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIEVudGVyIGtleSBoYW5kbGVyXHJcblx0ICogQHBhcmFtIG1vZGVsIHtvYmplY3R9XHJcblx0ICogQHBhcmFtIGV2ZW50IHtvYmplY3R9XHJcblx0ICovXHJcblx0b25LZXlEb3duKG1vZGVsLCBldmVudCkge1xyXG5cdFx0dGhpcy5pc1ZpcmdpbihmYWxzZSk7XHJcblx0XHRsZXQgYnRuID0gJCgnI2FwaS1leHAtZ2V0LWJ0bicpO1xyXG5cdFx0XHJcblx0XHRpZiAoZXZlbnQua2V5Q29kZSA9PT0gMTMgJiYgYnRuLmlzKCc6ZW5hYmxlZCcpKSB7XHJcblx0XHRcdGJ0bi50cmlnZ2VyKCdjbGljaycpO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0cmV0dXJuIHRydWU7XHJcblx0XHR9XHJcblx0fVxyXG5cdFxyXG5cdC8qKlxyXG5cdCAqIElzIHRlYXRhcmVhIGNoZWNrZXJcclxuXHQgKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuXHQgKi9cclxuXHRnZXQgaXNUZXh0YXJlYSgpIHtcclxuXHRcdHJldHVybiB0aGlzLmRhdGEuc3R5bGUgPT09ICdyZXF1ZXN0Qm9keSc7XHJcblx0fVxyXG59XHJcblxyXG5rby5jb21wb25lbnRzLnJlZ2lzdGVyKCdjdXN0b20taW5wdXQnLCB7XHJcblx0dmlld01vZGVsOiBDdXN0b21JbnB1dCxcclxuXHR0ZW1wbGF0ZTogYFxyXG5cdFx0PGRpdiBkYXRhLWJpbmQ9XCJjc3M6IHtbY3NzQ2xhc3NdOiB0cnVlLCBkaXJ0eTogaXNEaXJ0eSwgdmlyZ2luOiBpc1Zpcmdpbn1cIiBjbGFzcz1cImFwaS1leHAtY3VzdG9tLWlucHV0XCI+XHJcblx0XHRcdDxkaXYgZGF0YS1iaW5kPVwidmFsaWRhdGlvbkVsZW1lbnQ6IHZhbHVlXCIgY2xhc3M9XCJjdXN0b20taW5wdXRfX2lubmVyLXdyYXBwZXJcIj5cclxuXHRcdFx0XHQ8IS0tIGtvIGlmbm90OiBpc1RleHRhcmVhIC0tPlxyXG5cdFx0XHRcdDxpbnB1dCBkYXRhLWJpbmQ9XCJ0ZXh0SW5wdXQ6IHZhbHVlLCBsYXp5TG9hZGVyOiB7bmFtZTogcGxhY2Vob2xkZXIsIHZhbDogdmFsdWV9LCBkYXRlVGltZVBpY2tlciwgZXZlbnQ6IHtmb2N1czogb25Gb2N1c01ldGhvZChkYXRhKSwga2V5ZG93bjogb25LZXlEb3duLmJpbmQoJGNvbXBvbmVudCl9LCBhdHRyOiB7aWQ6IGlkfVwiXHJcblx0XHRcdFx0XHRcdFx0XHR0eXBlPVwidGV4dFwiXHJcblx0XHRcdFx0XHRcdFx0XHRjbGFzcz1cImN1c3RvbS1pbnB1dF9fZmllbGQgZm9ybS1jb250cm9sXCI+XHJcblx0XHRcdFx0PCEtLSAva28gLS0+XHJcblx0XHRcdFx0PCEtLSBrbyBpZjogaXNUZXh0YXJlYSAtLT5cclxuXHRcdFx0XHQ8dGV4dGFyZWEgZGF0YS1iaW5kPVwidGV4dElucHV0OiB2YWx1ZSwgbGF6eUxvYWRlcjoge25hbWU6IHBsYWNlaG9sZGVyLCB2YWw6IHZhbHVlfSwgZGF0ZVRpbWVQaWNrZXIsIGV2ZW50OiB7Zm9jdXM6IG9uRm9jdXNNZXRob2QoZGF0YSl9LCBhdHRyOiB7aWQ6IGlkfVwiIFxyXG5cdFx0XHRcdFx0XHRcdFx0XHRjb2xzPVwiMzBcIiByb3dzPVwiMTBcIlxyXG5cdFx0XHRcdFx0XHRcdFx0XHRjbGFzcz1cImN1c3RvbS10ZXh0YXJlYSBjdXN0b20taW5wdXRfX2ZpZWxkIGZvcm0tY29udHJvbFwiPjwvdGV4dGFyZWE+XHJcblx0XHRcdFx0PCEtLSAva28gLS0+XHJcblx0XHRcdFx0PHNwYW4gZGF0YS1iaW5kPVwidGV4dDogcGxhY2Vob2xkZXIsIGNzczoge3JlcXVpcmVkOiBkYXRhLnJlcXVpcmVkfVwiIGNsYXNzPVwiY3VzdG9tLWlucHV0X19wbGFjZWhvbGRlclwiPjwvc3Bhbj5cclxuXHRcdFx0PC9kaXY+XHJcblx0XHRcdDxwIGRhdGEtYmluZD1cInZhbGlkYXRpb25NZXNzYWdlOiB2YWx1ZSwgY3NzOiB7dGV4dGFyZWE6IGlzVGV4dGFyZWF9XCIgY2xhc3M9XCJjdXN0b20taW5wdXRfX3ZhbGlkYXRpb24tbWVzc2FnZVwiPjwvcD5cclxuXHRcdDwvZGl2PlxyXG5gfSk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEN1c3RvbUlucHV0O1xyXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zY3JpcHRzL2FwaS1leHBsb3Jlci92Mi9zcmMvY29tcG9uZW50cy9jb21tb24vY3VzdG9tSW5wdXQuY29tcG9uZW50LmpzIiwiLyoqXHJcbiAqIEN1c3RvbSBzZWxlY3QgY29tcG9uZW50XHJcbiAqL1xyXG5cclxuY2xhc3MgQ3VzdG9tU2VsZWN0IHtcclxuXHRjb25zdHJ1Y3Rvcih7ZGF0YSwgc2VsZWN0ZWQsIG9wdGlvbnMsIGZvY3VzLCBvbnNlbGVjdCwgYW5pbWF0aW9uU3BlZWQgPSAyMDAsIGlzUmVhZE9ubHkgPSB0cnVlfSkge1xyXG5cdFx0Y29uc3QgcmF3T3B0aW9ucyA9IGtvLnVud3JhcChvcHRpb25zKTtcclxuXHRcdGNvbnN0IERFRkFVTFRfU0VMRUNURUQgPSByYXdPcHRpb25zWzBdLm5hbWU7XHJcblx0XHR0aGlzLmN1cmVudFNlbGVjdERhdGEgPSBkYXRhO1xyXG5cdFx0dGhpcy5vbkZvY3VzID0gZm9jdXM7XHJcblx0XHR0aGlzLm9uc2VsZWN0TWV0aG9kID0gb25zZWxlY3Q7XHJcblx0XHR0aGlzLmFuaW1hdGlvblNwZWVkID0gYW5pbWF0aW9uU3BlZWQ7XHJcblx0XHR0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xyXG5cdFx0dGhpcy52YWx1ZSA9IGtvLnVud3JhcChzZWxlY3RlZCkgfHwgREVGQVVMVF9TRUxFQ1RFRDtcclxuXHRcdHRoaXMuc2VsZWN0ZWRPcHRpb24gPSBrby5vYnNlcnZhYmxlKHRoaXMubWFwRm9yQ2hlY2tlZCh7cmF3T3B0aW9ucywgbmFtZTogdGhpcy52YWx1ZX0pKTtcclxuXHRcdHRoaXMuaXNFeHBhbmRlZGVkID0ga28ub2JzZXJ2YWJsZShmYWxzZSk7XHJcblx0XHR0aGlzLmlzUmVhZE9ubHkgPSBpc1JlYWRPbmx5O1xyXG5cdFx0dGhpcy5zZXRTdWJzY3JpYnRpb25zKHtzZWxlY3RlZCwgREVGQVVMVF9TRUxFQ1RFRH0pO1xyXG5cdFx0Ly8gRGlydHkgd2F0Y2hlclxyXG5cdFx0dGhpcy5maWVsZFdhdGNoZXIoZGF0YSk7XHJcblx0fVxyXG5cclxuXHRmaWVsZFdhdGNoZXIoZGF0YSkge1xyXG5cdFx0aWYgKGRhdGEpIHtcclxuXHRcdFx0dGhpcy5pc0RpcnR5ID0gZGF0YS5pc0RpcnR5ID0ga28ucHVyZUNvbXB1dGVkKCgpID0+IHtcclxuXHRcdFx0XHRyZXR1cm4gZGF0YS52YWx1ZSgpICE9PSBkYXRhLmRlZmF1bHQgJiYgZGF0YS52YWx1ZSgpICE9PSAnbm9uZSc7XHJcblx0XHRcdH0pO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0c2V0U3Vic2NyaWJ0aW9ucyh7c2VsZWN0ZWQsIERFRkFVTFRfU0VMRUNURUR9KSB7XHJcblx0XHQvLyBoYXMgcHJlc2VsZWN0ZWQgb3B0aW9uXHJcblx0XHRpZiAoc2VsZWN0ZWQpIHtcclxuXHRcdFx0c2VsZWN0ZWQuc3Vic2NyaWJlKHZhbHVlID0+IHtcclxuXHRcdFx0XHRsZXQgc2VsZWN0ZWRPcHRpb24gPSB0aGlzLm1hcEZvckNoZWNrZWQoe3Jhd09wdGlvbnM6IGtvLnVud3JhcCh0aGlzLm9wdGlvbnMpLCBuYW1lOiB2YWx1ZSB8fCBERUZBVUxUX1NFTEVDVEVEfSk7XHJcblxyXG5cdFx0XHRcdHJldHVybiB0aGlzLnNlbGVjdGVkT3B0aW9uKHNlbGVjdGVkT3B0aW9uKTtcclxuXHRcdFx0fSk7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gb24gc2VsZWN0IG1hcCBmb3IgY2hlY2tlZFxyXG5cdFx0dGhpcy5zZWxlY3RlZE9wdGlvbi5zdWJzY3JpYmUodmFsdWUgPT4ge1xyXG5cdFx0XHR0aGlzLm1hcEZvckNoZWNrZWQoe3Jhd09wdGlvbnM6IGtvLnVud3JhcCh0aGlzLm9wdGlvbnMpLCBuYW1lOiB2YWx1ZS5uYW1lfSk7XHJcblx0XHRcdHRoaXMub25zZWxlY3RNZXRob2QodmFsdWUpO1xyXG5cdFx0fSk7XHJcblxyXG5cdFx0Ly8gcXVhbnRpdHkgb2Ygb3B0aW9ucyBjaGVja1xyXG5cdFx0dGhpcy5pc09uZU9wdGlvbiA9IGtvLnB1cmVDb21wdXRlZCgoKSA9PiBrby51bndyYXAodGhpcy5vcHRpb25zKS5sZW5ndGggPCAyKTtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFVwZGF0ZXMgY2hlY2tlZCBvcHRpb25cclxuXHQgKiBAcGFyYW0gcmF3T3B0aW9ucyB7YXJyYXl9IG9wdGlvbnNcclxuXHQgKiBAcGFyYW0gbmFtZSB7c3RyaW5nfSBuYW1lIG9mIHNlbGVjdGVkIG9wdGlvblxyXG5cdCAqIEByZXR1cm5zIHtvYmplY3R9IHNlbGVjdGVkIG9wdGlvblxyXG5cdCAqL1xyXG5cdG1hcEZvckNoZWNrZWQoe3Jhd09wdGlvbnMsIG5hbWV9KSB7XHJcblx0XHRsZXQgc2VsZWN0ZWRPcHRpb247XHJcblx0XHRmb3IgKGNvbnN0IG9wdGlvbiBvZiByYXdPcHRpb25zKSB7XHJcblx0XHRcdGxldCBvcHRpb25WYWx1ZSA9IG9wdGlvbi52YWx1ZSB8fCBvcHRpb24ubmFtZTtcclxuXHRcdFx0b3B0aW9uLmNoZWNrZWQob3B0aW9uVmFsdWUgPT09IG5hbWUpO1xyXG5cdFx0XHRpZiAob3B0aW9uVmFsdWUgPT09IG5hbWUpIHtcclxuXHRcdFx0XHRzZWxlY3RlZE9wdGlvbiA9IG9wdGlvblxyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gc2VsZWN0ZWRPcHRpb247XHJcblx0fVxyXG5cclxuXHRzbGlkZVRvZ2dsZShpdGVtLCBldmVudCkge1xyXG5cdFx0dGhpcy5vbkZvY3VzICYmIHRoaXMub25Gb2N1cyh0aGlzLmN1cmVudFNlbGVjdERhdGEpO1xyXG5cdFx0dGhpcy5pc0V4cGFuZGVkZWQoIWtvLnVud3JhcCh0aGlzLmlzRXhwYW5kZWRlZCkpO1xyXG5cdFx0aWYgKGtvLnVud3JhcCh0aGlzLmlzT25lT3B0aW9uKSkge1xyXG5cdFx0XHRyZXR1cm4gZmFsc2VcclxuXHRcdH1cclxuXHRcdGxldCBlbCA9IHRoaXMuY29uc3RydWN0b3IuZmluZEVsZW1lbnQoZXZlbnQpO1xyXG5cdFx0ZWwud3JhcHBlci5zbGlkZVRvZ2dsZSh0aGlzLmFuaW1hdGlvblNwZWVkKTtcclxuXHRcdGVsLmxheWVyLnRvZ2dsZUNsYXNzKCdoaWRkZW4nKTtcclxuXHR9XHJcblxyXG5cdG9uU2VsZWN0KGl0ZW0sIGV2ZW50KSB7XHJcblx0XHRjb25zdCByYXdPcHRpb25zID0ga28udW53cmFwKHRoaXMub3B0aW9ucyk7XHJcblx0XHR0aGlzLm1hcEZvckNoZWNrZWQoe3Jhd09wdGlvbnMsIG5hbWU6IGl0ZW0ubmFtZX0pO1xyXG5cdFx0dGhpcy5zZWxlY3RlZE9wdGlvbihpdGVtKTtcclxuXHRcdHRoaXMuc2xpZGVUb2dnbGUoaXRlbSwgZXZlbnQpO1xyXG5cdH1cclxuXHJcblx0c3RhdGljIGZpbmRFbGVtZW50KGV2ZW50KSB7XHJcblx0XHRsZXQgcGFyZW50ID0gJChldmVudC5jdXJyZW50VGFyZ2V0KS5wYXJlbnRzKCcuanMtY3VzdG9tLXNlbGVjdCcpO1xyXG5cdFx0cmV0dXJuIHtcclxuXHRcdFx0d3JhcHBlcjogcGFyZW50LmZpbmQoJy5qcy1jdXN0b20tc2VsZWN0LXdyYXBwZXInKSxcclxuXHRcdFx0bGF5ZXI6IHBhcmVudC5maW5kKCcuanMtY3VzdG9tLXNlbGVjdC1sYXllcicpXHJcblx0XHR9XHJcblx0fVxyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGtvLmNvbXBvbmVudHMucmVnaXN0ZXIoJ2N1c3RvbS1zZWxlY3QnLCB7XHJcbiAgdmlld01vZGVsOiBDdXN0b21TZWxlY3QsXHJcbiAgdGVtcGxhdGU6IGBcclxuXHQ8ZGl2IGNsYXNzPVwiYXBpLWV4cC1jdXN0b20tc2VsZWN0IGpzLWN1c3RvbS1zZWxlY3RcIj5cclxuXHRcdDxkaXYgY2xhc3M9XCJhcGktZXhwLWN1c3RvbS1zZWxlY3Qtd3JhcHBlclwiPlxyXG5cdFx0XHQ8c2VsZWN0IGNsYXNzPVwiYXBpLWV4cC1jdXN0b20tc2VsZWN0X19maWVsZFwiIG5hbWU9XCJhcGktZXhwLW1ldGhvZFwiIGRhdGEtYmluZD1cIm9wdGlvbnM6IG9wdGlvbnMsIG9wdGlvbnNUZXh0OiAnbmFtZScsIHZhbHVlOiBzZWxlY3RlZE9wdGlvblwiPjwvc2VsZWN0PlxyXG5cdFx0XHRcdDxzcGFuIGNsYXNzPVwiYXBpLWV4cC1jdXN0b20tc2VsZWN0X19wbGFjZWhvbGRlclwiPlxyXG5cdFx0XHRcdDxpbnB1dCB0eXBlPVwidGV4dFwiIGRhdGEtYmluZD1cImNsaWNrOiBzbGlkZVRvZ2dsZSwgdmFsdWU6IHNlbGVjdGVkT3B0aW9uKCkubmFtZSwgYXR0cjoge2Rpc2FibGVkOiBpc09uZU9wdGlvbiwgcmVhZG9ubHk6IGlzUmVhZE9ubHl9XCI+XHJcblx0XHRcdFx0PGJ1dHRvbiBjbGFzcz1cImJ0biBidG4taWNvbiBzaGV2cm9uIHVwIGJsdWUgYXBpLWV4cC1jdXN0b20tc2VsZWN0X19jaGV2cm9uXCIgZGF0YS1iaW5kPVwiY3NzOiB7aGlkZGVuOiBpc09uZU9wdGlvbiwgZG93bjogaXNFeHBhbmRlZGVkfVwiIHR5cGU9XCJidXR0b25cIj48L2J1dHRvbj5cclxuXHRcdFx0PC9zcGFuPlxyXG5cdFx0XHQ8dWwgZGF0YS1iaW5kPVwiZm9yZWFjaDogb3B0aW9ucywgc2Nyb2xsOiB7eDogZmFsc2UsIHk6IHRydWV9XCIgY2xhc3M9XCJhcGktZXhwLWN1c3RvbS1zZWxlY3RfX2xpc3QganMtY3VzdG9tLXNlbGVjdC13cmFwcGVyXCI+XHJcblx0XHRcdFx0PGxpIGRhdGEtYmluZD1cImNzczogeydhY3RpdmUnOiBjaGVja2VkfVwiIGNsYXNzPVwiYXBpLWV4cC1jdXN0b20tc2VsZWN0X19pdGVtXCI+XHJcblx0XHRcdFx0XHQ8YnV0dG9uIGNsYXNzPVwiYXBpLWV4cC1jdXN0b20tc2VsZWN0X19pdGVtLWxhYmVsXCJcclxuXHRcdFx0XHRcdFx0XHRcdFx0ZGF0YS1iaW5kPVwiY2xpY2s6ICRjb21wb25lbnQub25TZWxlY3QuYmluZCgkY29tcG9uZW50KSxcclxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0dGV4dDogbmFtZSxcclxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0Y3NzOiB7J2FjdGl2ZSc6IGNoZWNrZWR9LFxyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRhdHRyOiB7J2RhdGEtdmFsdWUnOiBuYW1lfVwiPjwvYnV0dG9uPlxyXG5cdFx0XHRcdFx0PGEgY2xhc3M9XCJhcGktZXhwLWN1c3RvbS1zZWxlY3RfX2l0ZW0tbGlua1wiIHRhcmdldD1cIl9ibGFua1wiIGRhdGEtYmluZD1cImF0dHI6IHtocmVmOiBsaW5rfSwgY3NzOiB7J2hpZGRlbic6ICFsaW5rfVwiPiZuYnNwOzwvYT5cclxuXHRcdFx0XHQ8L2xpPlxyXG5cdFx0XHQ8L3VsPlxyXG5cdFx0PC9kaXY+XHJcblx0XHQ8ZGl2IGRhdGEtYmluZD1cImNsaWNrOiBzbGlkZVRvZ2dsZVwiIGNsYXNzPVwiYXBpLWV4cC1jdXN0b20tc2VsZWN0LWxheWVyIGpzLWN1c3RvbS1zZWxlY3QtbGF5ZXIgaGlkZGVuXCI+PC9kaXY+XHJcblx0PC9kaXY+XHJcbmB9KTtcclxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc2NyaXB0cy9hcGktZXhwbG9yZXIvdjIvc3JjL2NvbXBvbmVudHMvY29tbW9uL2N1c3RvbVNlbGVjdC5jb21wb25lbnQuanMiLCJyZXF1aXJlKCcuL2N1c3RvbVNlbGVjdC5jb21wb25lbnQnKTtcclxucmVxdWlyZSgnLi9jdXN0b21JbnB1dC5jb21wb25lbnQnKTtcclxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc2NyaXB0cy9hcGktZXhwbG9yZXIvdjIvc3JjL2NvbXBvbmVudHMvY29tbW9uL2luZGV4LmpzIiwidmFyIHNlbGY7XHJcblxyXG5mdW5jdGlvbiBBYm91dE1ldGhvZChwYXJhbXMpIHtcclxuXHRzZWxmID0gdGhpcztcclxuXHR2YXIgbWV0aG9kID0ga28udW53cmFwKHBhcmFtcy5zZWxlY3RlZE1ldGhvZERhdGEpO1xyXG5cdHRoaXMuZG9jdW1lbnRhdGlvbkxpbmsgPSBrby5vYnNlcnZhYmxlKG1ldGhvZC5saW5rKTtcclxuXHR0aGlzLm5hbWUgPSBrby5vYnNlcnZhYmxlKG1ldGhvZC5uYW1lKTtcclxuXHR0aGlzLmRlc2NyaXB0aW9uID0ga28ub2JzZXJ2YWJsZShtZXRob2QuZGVzY3JpcHRpb24pO1xyXG5cclxuXHQvLyBvbiBtb2RlbCBjaGFuZ2VcclxuXHRwYXJhbXMuc2VsZWN0ZWRNZXRob2REYXRhLnN1YnNjcmliZShmdW5jdGlvbiAodmFsKSB7XHJcblx0XHR0aGlzLmRvY3VtZW50YXRpb25MaW5rKHZhbC5saW5rKTtcclxuXHRcdHRoaXMubmFtZSh2YWwubmFtZSk7XHJcblx0XHR0aGlzLmRlc2NyaXB0aW9uKHZhbC5kZXNjcmlwdGlvbik7XHJcblx0fSwgdGhpcyk7XHJcblxyXG5cdC8vIG1ldGhvZHNcclxuXHR0aGlzLnRvZ2dsZVBvcFVwICA9IGtvLm9ic2VydmFibGUoZmFsc2UpO1xyXG59XHJcblxyXG5BYm91dE1ldGhvZC5wcm90b3R5cGUub25BYm91dENsaWNrID0gZnVuY3Rpb24gKG1vZGVsKSB7XHJcblx0cmV0dXJuIG1vZGVsLnRvZ2dsZVBvcFVwKCFtb2RlbC50b2dnbGVQb3BVcCgpKTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0ga28uY29tcG9uZW50cy5yZWdpc3RlcignYWJvdXQtbWV0aG9kJywge1xyXG5cdHZpZXdNb2RlbDogQWJvdXRNZXRob2QsXHJcblx0dGVtcGxhdGU6YFxyXG5cdFx0PHNlY3Rpb24gZGF0YS1iaW5kPVwiY3NzOiB7YWN0aXZlOiB0b2dnbGVQb3BVcH1cIiBjbGFzcz1cImFwaS1leHAtYWJvdXRcIj5cclxuXHRcdFx0PGRpdiBjbGFzcz1cImFwaS1leHAtYWJvdXQtd3JhcHBlclwiPlxyXG5cdFx0XHRcdDxidXR0b24gZGF0YS1iaW5kPVwiY2xpY2s6IG9uQWJvdXRDbGlja1wiIGNsYXNzPVwiYXBpLWV4cC1hYm91dF9fYnV0dG9uIGRldmljZXMtYnV0dG9uXCI+PC9idXR0b24+XHJcblx0XHRcdFx0PGEgZGF0YS1iaW5kPVwiYXR0cjoge2hyZWY6IGRvY3VtZW50YXRpb25MaW5rfVwiIGhyZWY9XCIjXCIgY2xhc3M9XCJhcGktZXhwLWFib3V0X19idXR0b25cIiB0YXJnZXQ9XCJfYmxhbmtcIj48L2E+XHJcblx0XHRcdFx0PGFydGljbGUgY2xhc3M9XCJhcGktZXhwLWFib3V0X19jb250ZW50XCI+XHJcblx0XHRcdFx0XHQ8aDUgZGF0YS1iaW5kPVwidGV4dDogbmFtZVwiIGNsYXNzPVwiYXBpLWV4cC1hYm91dF9fdGl0bGVcIj5BYm91dCBBUEkgYW5kIE1ldGhvZDo8L2g1PlxyXG5cdFx0XHRcdFx0PHNlY3Rpb24gY2xhc3M9XCJhcGktZXhwLWFib3V0X19kZXNjcmlwdGlvblwiPlxyXG5cdFx0XHRcdFx0XHQ8cCBkYXRhLWJpbmQ9XCJ0ZXh0OiBkZXNjcmlwdGlvblwiPjwvcD5cclxuXHRcdFx0XHRcdFx0PHA+XHJcblx0XHRcdFx0XHRcdFx0PGEgZGF0YS1iaW5kPVwiYXR0cjoge2hyZWY6IGRvY3VtZW50YXRpb25MaW5rfVwiIHRhcmdldD1cIl9ibGFua1wiIGhyZWY9XCIjXCIgY2xhc3M9XCJhcGktZXhwLWFib3V0X19kZXNjcmlwdGlvbi1saW5rXCI+UmVhZCBtb2RlPC9hPlxyXG5cdFx0XHRcdFx0XHQ8L3A+XHJcblx0XHRcdFx0XHQ8L3NlY3Rpb24+XHJcblx0XHRcdFx0PC9hcnRpY2xlPlxyXG5cdFx0XHRcdDxkaXYgZGF0YS1iaW5kPVwiY2xpY2s6IG9uQWJvdXRDbGlja1wiIGNsYXNzPVwiYXBpLWV4cC1hYm91dC1sYXllclwiPjwvZGl2PlxyXG5cdFx0XHQ8L2Rpdj5cclxuXHRcdDwvc2VjdGlvbj5cclxuYH0pO1xyXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zY3JpcHRzL2FwaS1leHBsb3Jlci92Mi9zcmMvY29tcG9uZW50cy9maWx0ZXIvYWJvdXRNZXRob2QuY29tcG9uZW50LmpzIiwidmFyIHNlbGY7XHJcblxyXG5jbGFzcyBDYXRlZ29yeU1lbnUge1xyXG5cdGNvbnN0cnVjdG9yKHtkYXRhLCBzZWxlY3RlZENhdGVnb3J5fSkge1xyXG5cdFx0c2VsZiA9IHRoaXM7XHJcblx0XHR0aGlzLnNlbGVjdGVkQ2F0ZWdvcnkgPSBzZWxlY3RlZENhdGVnb3J5O1xyXG5cdFx0dmFyIGluaXRDYXRlZ29yeSA9IGtvLnVud3JhcCh0aGlzLnNlbGVjdGVkQ2F0ZWdvcnkpO1xyXG5cdFx0dGhpcy5jYXRlZ29yaWVzID0ga28ub2JzZXJ2YWJsZUFycmF5KE9iamVjdC5rZXlzKGRhdGEpLm1hcCgoaXRlbSwgaW5kZXgpID0+IHtcclxuXHRcdFx0dmFyIGNoZWNrZWQgPSBpbml0Q2F0ZWdvcnkgPyBpdGVtID09PSBpbml0Q2F0ZWdvcnk6ICFpbmRleDtcclxuXHRcdFx0Ly8gaW5pdGlhbCBsb2FkXHJcblx0XHRcdGNoZWNrZWQgJiYgdGhpcy5zZWxlY3RlZENhdGVnb3J5KGl0ZW0pO1xyXG5cdFx0XHRyZXR1cm4ge1xyXG5cdFx0XHRcdGNoZWNrZWQ6IGtvLm9ic2VydmFibGUoY2hlY2tlZCksXHJcblx0XHRcdFx0bmFtZTogaXRlbSxcclxuXHRcdFx0XHRsaW5rOiBmYWxzZVxyXG5cdFx0XHR9XHJcblx0XHR9KSk7XHJcblxyXG5cdFx0dGhpcy5zZWxlY3RlZENhdGVnb3J5LnN1YnNjcmliZShjYXRlZ29yeU5hbWUgPT4ge1xyXG5cdFx0XHRjaGVja0FjdGl2ZSh0aGlzLmNhdGVnb3JpZXMsIGNhdGVnb3J5TmFtZSk7XHJcblx0XHR9KVxyXG5cdH1cclxuXHJcblx0c2VsZWN0Q2F0ZWdvcnkgPSAoY2F0ZWdvcnkpID0+IHtcclxuXHRcdHZhciBjYXRlZ29yeU5hbWUgPSBjYXRlZ29yeS5uYW1lO1xyXG5cdFx0dGhpcy5zZWxlY3RlZENhdGVnb3J5KGNhdGVnb3J5TmFtZSk7XHJcblx0XHRjaGVja0FjdGl2ZSh0aGlzLmNhdGVnb3JpZXMsIGNhdGVnb3J5TmFtZSk7XHJcblx0fVxyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGtvLmNvbXBvbmVudHMucmVnaXN0ZXIoJ2NhdGVnb3J5LW1lbnUnLCB7XHJcblx0dmlld01vZGVsOiBDYXRlZ29yeU1lbnUsXHJcblx0dGVtcGxhdGU6YFxyXG5cdFx0PGFzaWRlIGNsYXNzPVwiYXBpLWV4cC1zaWRlLW1lbnVcIj5cclxuXHRcdFx0PHVsIGRhdGEtYmluZD1cImZvcmVhY2g6IGNhdGVnb3JpZXNcIiBjbGFzcz1cImFwaS1leHAtc2lkZS1tZW51X19jb250YWluZXIgbmF2IG5hdi1waWxscyBuYXYtc3RhY2tlZCB2aXNpYmxlLWxnLWJsb2NrXCI+XHJcblx0XHRcdFx0PGxpIGRhdGEtYmluZD1cImNzczoge2FjdGl2ZTogY2hlY2tlZH1cIiByb2xlPVwicHJlc2VudGF0aW9uXCIgY2xhc3M9XCJhcGktZXhwLXNpZGUtbWVudV9faXRlbVwiPlxyXG5cdFx0XHRcdFx0PGEgZGF0YS1iaW5kPVwiY2xpY2s6ICRwYXJlbnQuc2VsZWN0Q2F0ZWdvcnksIHRleHQ6IG5hbWVcIiBocmVmPVwiI1wiIGNsYXNzPVwiYXBpLWV4cC1zaWRlLW1lbnVfX2xpbmtcIj48L2E+XHJcblx0XHRcdFx0PC9saT5cclxuXHRcdFx0PC91bD5cclxuXHRcdFx0PCEtLXNlbGVjdC0tPlxyXG5cdFx0XHQ8ZGl2IGNsYXNzPVwiYXBpLWV4cC1zaWRlLW1lbnVfX3NlbGVjdCBoaWRkZW4tbGdcIj5cclxuXHRcdFx0XHQ8IS0tIGtvIHRlbXBsYXRlOiB7IG5vZGVzOiAkY29tcG9uZW50VGVtcGxhdGVOb2RlcywgZGF0YTogJGNvbXBvbmVudCB9IC0tPjwhLS0gL2tvIC0tPlxyXG5cdFx0XHQ8L2Rpdj5cclxuXHRcdDwvYXNpZGU+XHJcbmB9KTtcclxuXHJcbmZ1bmN0aW9uIGNoZWNrQWN0aXZlKGtvQXJyLCBhY3RpdmVFbGVtKSB7XHJcblx0aWYgKCFrb0FyciAmJiAhYWN0aXZlRWxlbSkge3JldHVybiBmYWxzZTt9XHJcblxyXG5cdGtvQXJyKGtvQXJyKCkubWFwKGZ1bmN0aW9uIChvYmopIHtcclxuXHRcdGlmIChvYmoubmFtZSA9PT0gYWN0aXZlRWxlbSkge1xyXG5cdFx0XHRvYmouY2hlY2tlZCh0cnVlKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdG9iai5jaGVja2VkKGZhbHNlKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiBvYmo7XHJcblx0fSkpO1xyXG59XHJcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NjcmlwdHMvYXBpLWV4cGxvcmVyL3YyL3NyYy9jb21wb25lbnRzL2ZpbHRlci9jYXRlZ29yeU1lbnUuY29tcG9uZW50LmpzIiwicmVxdWlyZSgnLi9hYm91dE1ldGhvZC5jb21wb25lbnQnKTtcclxucmVxdWlyZSgnLi9jYXRlZ29yeU1lbnUuY29tcG9uZW50Jyk7XHJcbnJlcXVpcmUoJy4vbWV0aG9kc0ZpbHRlci5jb21wb25lbnQnKTtcclxucmVxdWlyZSgnLi9yYWRpb0ZpbHRlci5jb21wb25lbnQnKTtcclxucmVxdWlyZSgnLi9wYXJhbXNGaWx0ZXIuY29tcG9uZW50Jyk7XHJcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NjcmlwdHMvYXBpLWV4cGxvcmVyL3YyL3NyYy9jb21wb25lbnRzL2ZpbHRlci9pbmRleC5qcyIsInZhciBzZWxmO1xyXG5cclxuY2xhc3MgTWV0aG9kc0ZpbHRlciB7XHJcblx0Y29uc3RydWN0b3Ioe3NlbGVjdGVkQ2F0ZWdvcnksIGRhdGEsIHNlbGVjdGVkTWV0aG9kVHlwZSwgc2VsZWN0ZWRNZXRob2R9KSB7XHJcblx0XHRzZWxmID0gdGhpcztcclxuXHRcdHRoaXMuc2VsZWN0ZWRDYXRlZ29yeSA9IHNlbGVjdGVkQ2F0ZWdvcnk7XHJcblx0XHR0aGlzLmRhdGEgPSBkYXRhO1xyXG5cdFx0dGhpcy5zZWxlY3RlZE1ldGhvZFR5cGUgPSBzZWxlY3RlZE1ldGhvZFR5cGU7XHJcblx0XHR0aGlzLnNlbGVjdGVkTWV0aG9kID0gc2VsZWN0ZWRNZXRob2Q7XHJcblx0XHR0aGlzLnNlbGVjdGVkTWV0aG9kTmFtZSA9IGtvLm9ic2VydmFibGUoJycpO1xyXG5cdFx0dGhpcy5tZXRob2RzVmlld01vZGVsID0ga28ub2JzZXJ2YWJsZUFycmF5KFtdKTtcclxuXHRcdHRoaXMuaW5pdCgpXHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBJbml0aWFsaXphdGlvbiBwaGFzZVxyXG5cdCAqL1xyXG5cdGluaXQgPSAoKSA9PiB7XHJcblx0XHR0aGlzLnVwZGF0ZU1ldGhvZHNNb2RlbChrby51bndyYXAodGhpcy5zZWxlY3RlZE1ldGhvZFR5cGUpKTtcclxuXHJcblx0XHQvL29uIGNoYW5nZVxyXG5cdFx0dGhpcy5zZWxlY3RlZE1ldGhvZFR5cGUuc3Vic2NyaWJlKHZhbCA9PiB0aGlzLnVwZGF0ZU1ldGhvZHNNb2RlbCh2YWwpKTtcclxuXHRcdHRoaXMuc2VsZWN0ZWRNZXRob2Quc3Vic2NyaWJlKHZhbCA9PiB7XHJcblx0XHRcdHRoaXMuc2VsZWN0ZWRNZXRob2ROYW1lKHRoaXMuZGF0YVtrby51bndyYXAodGhpcy5zZWxlY3RlZENhdGVnb3J5KV1bJ0FMTCddW3ZhbF0ubmFtZSlcclxuXHRcdH0pXHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBGaWx0ZXJzIHRyYW5zY2x1c2lvbiBkb20gbm9kZXNcclxuXHQgKiBAcGFyYW0gcGFyYW0ge2FycmF5fSAkY29tcG9uZW50VGVtcGxhdGVOb2Rlc1xyXG5cdCAqIEBwYXJhbSBpbmRleCB7bnVtYmVyfSBpbmRleCBvZiBlbGVtZW50XHJcblx0ICogQHJldHVybnMge2FycmF5fSBkb20gbm9kZXMgYXJyYXkgZm9yIGluc2VydGlvblxyXG5cdCAqL1xyXG5cdGZpbHRlclRyYW5zY2x1c2lvbihwYXJhbSwgaW5kZXgpIHtcclxuXHRcdHZhciB0ZXh0ID0gcGFyYW0uZmluZChmdW5jdGlvbiAoaXRlbSkge1xyXG5cdFx0XHRyZXR1cm4gaXRlbS5ub2RlTmFtZSA9PT0gJyN0ZXh0JztcclxuXHRcdH0pO1xyXG5cdFx0dmFyIGVsID0gcGFyYW0uZmlsdGVyKGZ1bmN0aW9uIChpdGVtKSB7XHJcblx0XHRcdHJldHVybiBpdGVtLm5vZGVOYW1lICE9PSAnI3RleHQnICYmIGl0ZW0ubm9kZU5hbWUgIT09ICcjY29tbWVudCc7XHJcblx0XHR9KVtpbmRleF07XHJcblx0XHRyZXR1cm4gW3RleHQsIGVsLCB0ZXh0XTtcclxuXHR9O1xyXG5cclxuXHQvKipcclxuXHQgKiBVcGRhdGVzIFZNIGZvciBtZXRob2RzIHNlbGVjdFxyXG5cdCAqIEBwYXJhbSBtZXRob2RUeXBlXHJcblx0ICovXHJcblx0dXBkYXRlTWV0aG9kc01vZGVsID0gKG1ldGhvZFR5cGUpID0+IHtcclxuXHRcdHZhciBvYmogPSB0aGlzLmRhdGFba28udW53cmFwKHRoaXMuc2VsZWN0ZWRDYXRlZ29yeSldW21ldGhvZFR5cGVdfHwge30sXHJcblx0XHRcdGFyciA9IFtdLFxyXG5cdFx0XHRzZWxlY3RlZE1ldGhvZCA9IGtvLnVud3JhcCh0aGlzLnNlbGVjdGVkTWV0aG9kKSxcclxuXHRcdFx0Y291bnQgPSAwO1xyXG5cclxuXHRcdGZvciAodmFyIGkgaW4gb2JqKSB7XHJcblx0XHRcdGlmICghb2JqLmhhc093blByb3BlcnR5KGkpKSB7IGNvbnRpbnVlOyB9XHJcblx0XHRcdHZhciBwcm9wZXJ0eSA9IG9ialtpXTtcclxuXHJcblx0XHRcdHZhciB2bU1ldGhvZCA9ICQuZXh0ZW5kKHt9LCB7XHJcblx0XHRcdFx0aWQ6IHByb3BlcnR5LmlkLFxyXG5cdFx0XHRcdG5hbWU6IHByb3BlcnR5Lm5hbWUsXHJcblx0XHRcdFx0bGluazogcHJvcGVydHkubGluayxcclxuXHRcdFx0XHRjaGVja2VkOiBrby5vYnNlcnZhYmxlKCBzZWxlY3RlZE1ldGhvZCA/IHNlbGVjdGVkTWV0aG9kID09PSBwcm9wZXJ0eS5pZCA6ICFjb3VudCApXHJcblx0XHRcdH0pO1xyXG5cclxuXHRcdFx0aWYgKHNlbGVjdGVkTWV0aG9kID09PSBwcm9wZXJ0eS5pZCkge1xyXG5cdFx0XHRcdHRoaXMuc2VsZWN0ZWRNZXRob2ROYW1lKHByb3BlcnR5Lm5hbWUpO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRhcnIucHVzaCh2bU1ldGhvZCk7XHJcblxyXG5cdFx0XHQvLyBzZXQgZ2xvYmFsIG9ic2VydmFibGVcclxuXHRcdFx0IXNlbGVjdGVkTWV0aG9kICYmICFjb3VudCAmJiB0aGlzLnNlbGVjdGVkTWV0aG9kKHByb3BlcnR5LmlkKTtcclxuXHJcblx0XHRcdGNvdW50Kys7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5tZXRob2RzVmlld01vZGVsKGFycik7XHJcblx0fTtcclxuXHJcblx0LyoqXHJcblx0ICogT24gc2VsZWN0IGhhbmRsZXIgZm9yIG1ldGhvZHMgc2VsZWN0XHJcblx0ICogQHBhcmFtIGl0ZW1cclxuXHQgKi9cclxuXHRvblNlbGVjdE1ldGhvZChpdGVtKSB7XHJcblx0XHRzZWxmLnNlbGVjdGVkTWV0aG9kKGl0ZW0uaWQpO1xyXG5cdH07XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0ga28uY29tcG9uZW50cy5yZWdpc3RlcignbWV0aG9kcy1maWx0ZXInLCB7XHJcblx0dmlld01vZGVsOiBNZXRob2RzRmlsdGVyLFxyXG5cdHRlbXBsYXRlOmBcclxuXHRcdDxzZWN0aW9uICBjbGFzcz1cImFwaS1leHAtbWFpbi1maWx0ZXJcIj5cclxuXHRcdFx0PHNlY3Rpb24gY2xhc3M9XCJhcGktZXhwLWZpbHRlclwiPlxyXG5cdFx0XHRcdDxzZWN0aW9uIGNsYXNzPVwiYXBpLWV4cC1tZXRob2RzIGNsZWFyZml4XCI+XHJcblx0XHRcdFx0XHQ8bGFiZWwgY2xhc3M9XCJhcGktZXhwLW1ldGhvZHNfX2xhYmVsXCI+TWV0aG9kczwvbGFiZWw+XHJcblx0XHJcblx0XHRcdFx0XHQ8IS0tcmFkaW9zLS0+XHJcblx0XHRcdFx0XHQ8IS0tIGtvIHRlbXBsYXRlOiB7IG5vZGVzOiBmaWx0ZXJUcmFuc2NsdXNpb24oJGNvbXBvbmVudFRlbXBsYXRlTm9kZXMsIDApLCBkYXRhOiAkY29tcG9uZW50IH0gLS0+PCEtLSAva28gLS0+XHJcblx0XHRcdFx0XHRcclxuXHRcdFx0XHRcdDwhLS1zZWxlY3QtLT5cclxuXHRcdFx0XHRcdDxkaXYgY2xhc3M9XCJhcGktZXhwLW1ldGhvZHNfX3NlbGVjdFwiPlxyXG5cdFx0XHRcdFx0XHQ8IS0tIGtvIHRlbXBsYXRlOiB7IG5vZGVzOiBmaWx0ZXJUcmFuc2NsdXNpb24oJGNvbXBvbmVudFRlbXBsYXRlTm9kZXMsIDEpLCBkYXRhOiAkY29tcG9uZW50IH0tLT48IS0tL2tvLS0+XHJcblx0XHRcdFx0XHQ8L2Rpdj5cclxuXHRcdFx0XHQ8L3NlY3Rpb24+XHJcblx0XHRcdDwvc2VjdGlvbj5cclxuXHRcdDwvc2VjdGlvbj5cclxuYH0pO1xyXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zY3JpcHRzL2FwaS1leHBsb3Jlci92Mi9zcmMvY29tcG9uZW50cy9maWx0ZXIvbWV0aG9kc0ZpbHRlci5jb21wb25lbnQuanMiLCJjbGFzcyBQYXJhbXNGaWx0ZXIge1xyXG5cdGNvbnN0cnVjdG9yKHtzZWxlY3RlZE1ldGhvZCwgc2VsZWN0ZWRQYXJhbXMsIHNlbGVjdGVkTWV0aG9kRGF0YSwgYW5pbWF0aW9uU3BlZWQgPSAyMDAsIHBhcmFtc0lzSGlkZW59KSB7XHJcblx0XHR0aGlzLmFuaW1hdGlvblNwZWVkID0gYW5pbWF0aW9uU3BlZWQ7XHJcblx0XHR0aGlzLnNlbGVjdGVkTWV0aG9kID0gc2VsZWN0ZWRNZXRob2Q7XHJcblx0XHR0aGlzLnNlbGVjdGVkUGFyYW1zID0gc2VsZWN0ZWRQYXJhbXM7XHJcblx0XHR0aGlzLnNlbGVjdGVkTWV0aG9kRGF0YSA9IHNlbGVjdGVkTWV0aG9kRGF0YTtcclxuXHRcdHRoaXMuaXNIaWRkZW4gPSBrby5vYnNlcnZhYmxlKHRydWUpO1xyXG5cdFx0dGhpcy5wYXJhbUluRm9jdXMgPSBrby5vYnNlcnZhYmxlKHt9KTtcclxuXHRcdHRoaXMucGFyYW1zTW9kZWwgPSBrby5vYnNlcnZhYmxlQXJyYXkoW10pO1xyXG5cdFx0dGhpcy5pc0RpcnR5ID0ga28uY29tcHV0ZWQodGhpcy5jaGVja0RpcnR5LCB0aGlzKTtcclxuXHRcdHRoaXMuaW5pdCh7c2VsZWN0ZWRNZXRob2QsIHNlbGVjdGVkUGFyYW1zfSk7XHJcblx0XHRcclxuXHRcdC8vIHNsaWRlIHRvZ2dsZSB3aGVuIHBhcmFtcyBhcmUgbm90IHZhbGlkXHJcblx0XHRwYXJhbXNJc0hpZGVuLnN1YnNjcmliZSggbmV3VmFsID0+IHtcclxuXHRcdFx0dGhpcy5zbGlkZVRvZ2dsZS5jYWxsKG51bGwsIHRoaXMpXHJcblx0XHR9KVxyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogSW5pdGlhbGl6YXRpb24gcGhhc2VcclxuXHQgKi9cclxuXHRpbml0KHtzZWxlY3RlZE1ldGhvZCwgc2VsZWN0ZWRQYXJhbXN9KSB7XHJcblx0XHR0aGlzLnVwZGF0ZVZpZXdNb2RlbCgpO1xyXG5cdFx0c2VsZWN0ZWRNZXRob2Quc3Vic2NyaWJlKHZhbCA9PiB7XHJcblx0XHRcdHRoaXMudXBkYXRlVmlld01vZGVsKHZhbClcclxuXHRcdH0pO1xyXG5cclxuXHRcdHNlbGVjdGVkUGFyYW1zLnN1YnNjcmliZShzZWxlY3RlZCA9PiB7XHJcblx0XHRcdGxldCBwYXJhbXNNb2RlbCA9IGtvLnVud3JhcCh0aGlzLnBhcmFtc01vZGVsKTtcclxuXHRcdFx0c2VsZWN0ZWQubWFwKHBhcmFtID0+IHtcclxuXHRcdFx0XHRsZXQgbWF0Y2hlZFBhcmFtID0gcGFyYW1zTW9kZWwuZmluZCh2YWwgPT4gcGFyYW0ubmFtZSA9PT0gdmFsLm5hbWUpO1xyXG5cdFx0XHRcdG1hdGNoZWRQYXJhbS52YWx1ZShrby51bndyYXAocGFyYW0udmFsdWUpKTtcclxuXHRcdFx0fSk7XHJcblx0XHRcdHRoaXMucGFyYW1zTW9kZWwocGFyYW1zTW9kZWwpO1xyXG5cdFx0fSwgdGhpcywgJ3BhcmFtc1NldCcpO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogSW5pdGlhbCBidWlsZCBvZiBTZWxlY3QgTW9kZWxcclxuXHQgKi9cclxuXHR1cGRhdGVWaWV3TW9kZWwgPSAoKSA9PiB7XHJcblx0XHRsZXQgb2JqID0ga28udW53cmFwKHRoaXMuc2VsZWN0ZWRNZXRob2REYXRhKTtcclxuXHRcdGxldCBwYXJhbWV0ZXJzID0ga28udW53cmFwKHRoaXMuc2VsZWN0ZWRNZXRob2REYXRhKS5wYXJhbWV0ZXJzIHx8IHt9LFxyXG5cdFx0XHRhcnIgPSBbXTtcclxuXHJcblx0XHRmb3IgKHZhciBpIGluIHBhcmFtZXRlcnMpIHtcclxuXHRcdFx0aWYgKCFwYXJhbWV0ZXJzLmhhc093blByb3BlcnR5KGkpKSB7Y29udGludWU7fVxyXG5cdFx0XHRsZXQgcGFyYW0gPSBwYXJhbWV0ZXJzW2ldO1xyXG5cdFx0XHR2YXIgc2VsZWN0ZWRQYXJhbTtcclxuXHJcblx0XHRcdC8vIGNvcGllcyBhbGwgdmFsdWVzIGZyb20gbW9kZWwgdG8gdmlldy1tb2RlbFxyXG5cdFx0XHRsZXQgdm1QYXJhbSA9ICQuZXh0ZW5kKHRydWUsIHt9LCBwYXJhbSk7XHJcblxyXG5cdFx0XHR2bVBhcmFtLnZhbHVlID0ga28ub2JzZXJ2YWJsZSh2bVBhcmFtLnZhbHVlIHx8IHZtUGFyYW0uc2VsZWN0ICYmIHBhcmFtLm9wdGlvbnNbMF0ubmFtZSB8fCAnJyk7XHJcblxyXG5cdFx0XHQvL2FkZCBvYnNlcnZhYmxlIGZvciBzZWxlY3RlZCBvcHRpb25zXHJcblx0XHRcdGlmICh2bVBhcmFtLnNlbGVjdCkge1xyXG5cdFx0XHRcdHZtUGFyYW0ub3B0aW9ucyA9IHNlbGVjdGVkUGFyYW0gPyBzZWxlY3RlZFBhcmFtLm9wdGlvbnMgOiBrby5vYnNlcnZhYmxlQXJyYXkoXHJcblx0XHRcdFx0XHRwYXJhbS5vcHRpb25zLm1hcChpdGVtID0+ICQuZXh0ZW5kKHRydWUsIHt9LCBpdGVtLCB7Y2hlY2tlZDoga28ub2JzZXJ2YWJsZShpdGVtLmNoZWNrZWQpfSkpXHJcblx0XHRcdFx0KTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Ly8gYWRkIGNhbGVuZGFyIGJ0biBmb3IgY3VycmVudCBmaWVsZFxyXG5cdFx0XHR2bVBhcmFtLmhhc0NhbGVuZGFyID0gaS5zZWFyY2goLyhkYXRlfHRpbWUpL2dtaSkgIT0gLTE7XHJcblxyXG5cdFx0XHQvLyBhZGQgcG9wLXVwIGJ0biBmb3IgY3VycmVudCBmaWVsZFxyXG5cdFx0XHR2bVBhcmFtLmhhc1BvcFVwID0gaS5zZWFyY2goLyhhdHRyYWN0aW9uSWR8dmVudWVJZCkvZ21pKSAhPSAtMTtcclxuXHJcblx0XHRcdGFyci5wdXNoKHZtUGFyYW0pO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIHByZXBhcmUgb3V0cHV0IGZvciByZXF1ZXN0XHJcblx0XHR0aGlzLnBhcmFtc01vZGVsKGFycik7XHJcblxyXG5cdFx0Ly9zZXQgZm9jdXMgZm9yIGZpcnN0IGVsZW1cclxuXHRcdHRoaXMucGFyYW1JbkZvY3VzKHRoaXMucGFyYW1zTW9kZWwoKVswXSk7XHJcblx0XHR0aGlzLnByZXBhcmVVcmxQYWlycyhhcnIsIHRoaXMuc2VsZWN0ZWRQYXJhbXMpO1xyXG5cdFx0cmV0dXJuIGFycjtcclxuXHR9O1xyXG5cclxuXHQvKipcclxuXHQgKiBEaXJ0eSBwYXJhbXMgZm9ybSBvYnNlcnZhYmxlIG1ldGhvZFxyXG5cdCAqIEByZXR1cm5zIHtib29sZWFufVxyXG5cdCAqL1xyXG5cdGNoZWNrRGlydHkoKSB7XHJcblx0XHR0aGlzLnByZXBhcmVVcmxQYWlycyhrby51bndyYXAodGhpcy5wYXJhbXNNb2RlbCksIHRoaXMuc2VsZWN0ZWRQYXJhbXMpO1xyXG5cdFx0dmFyIGRpcnR5ID0ga28udW53cmFwKHRoaXMucGFyYW1zTW9kZWwpLmZpbHRlcihpdGVtID0+IHtcclxuXHRcdFx0cmV0dXJuIGtvLnVud3JhcChpdGVtLmlzRGlydHkpID09PSB0cnVlO1xyXG5cdFx0fSk7XHJcblx0XHRyZXR1cm4gZGlydHkubGVuZ3RoID4gMDtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFNsaWRlIHRvZ2dsZSBmb3IgcGFyYW1zIGNvbnRhaW5lciBtZXRob2RcclxuXHQgKiBAcGFyYW0gdmlld01vZGVsXHJcblx0ICogQHBhcmFtIGV2ZW50XHJcblx0ICovXHJcblx0c2xpZGVUb2dnbGUodmlld01vZGVsLCBldmVudCkge1xyXG5cdFx0JCgnI2FwaS1leHAyLXBhcmFtcy10b2dnbGUnKVxyXG5cdFx0XHQucGFyZW50cygnLmpzLXNsaWRlLWNvbnRyb2wnKVxyXG5cdFx0XHQuZmluZCgnLmpzLXNsaWRlLXdyYXBwZXInKVxyXG5cdFx0XHQuc2xpZGVUb2dnbGUodmlld01vZGVsLmFuaW1hdGlvblNwZWVkLCBmdW5jdGlvbiAoKSB7XHJcblx0XHRcdFx0dmlld01vZGVsLmlzSGlkZGVuKCF2aWV3TW9kZWwuaXNIaWRkZW4oKSk7XHJcblx0XHRcdH0pO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogTWFjaGVzIGZvY3VzZWQgcGFyYW1cclxuXHQgKiBAcGFyYW0gaXRlbVxyXG5cdCAqL1xyXG5cdG9uRm9jdXMgPSAoaXRlbSkgPT4ge1xyXG5cdFx0dGhpcy5wYXJhbUluRm9jdXMoaXRlbSk7XHJcblx0fTtcclxuXHJcblx0LyoqXHJcblx0ICogRmlsdGVycyBwYXJhbXMgYnkgZGVmaW5lZCB2YWx1ZVxyXG5cdCAqIEBwYXJhbSBhcnJcclxuXHQgKiBAcGFyYW0ga29PYnNcclxuXHQgKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuXHQgKi9cclxuXHRwcmVwYXJlVXJsUGFpcnMoYXJyLCBrb09icykge1xyXG5cdFx0aWYgKCFhcnIgfHwgIWtvT2JzKSB7cmV0dXJuIGZhbHNlO31cclxuXHJcblx0XHRyZXR1cm4ga29PYnMoYXJyLmZpbHRlcihpdGVtID0+IHtcclxuXHRcdFx0cmV0dXJuIChpdGVtLnZhbHVlKCkgJiYgaXRlbS52YWx1ZSgpICE9PSAnbm9uZScgfHwgaXRlbS5kZWZhdWx0KTtcclxuXHRcdH0pKTtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIE9uIHNlbGVjdCB2YWx1ZSBoYW5kbGVyIGZvciBwYXJhbXMgc2VsZWN0XHJcblx0ICogQHBhcmFtIHBhcmFtIHtvYmplY3R9IHBhcmFtZXRlciB2aWV3LW1vZGVsXHJcblx0ICogQHBhcmFtIG9wdGlvbiB7b2JqZWN0fSBvcHRpb24gdmlldy1tb2RlbFxyXG5cdCAqL1xyXG5cdG9uU2VsZWN0UGFyYW1WYWx1ZShwYXJhbSwgb3B0aW9uKSB7XHJcblx0XHRwYXJhbS52YWx1ZShvcHRpb24udmFsdWUgfHwgb3B0aW9uLm5hbWUpO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogUGFyYW1zIGNsZWFyIGJ1dHRvbiBoYW5kbGVyXHJcblx0ICogQHBhcmFtIHZtIHtvYmplY3R9IHZpZXcgbW9kZWxcclxuXHQgKiBAcGFyYW0gZSB7b2JqZWN0fSBldmVudFxyXG5cdCAqL1xyXG5cdG9uUGFyYW1zQ2xlYXIgPSAodm0sIGUpID0+IHtcclxuXHRcdHZhciBhcnIgPSBrby51bndyYXAodGhpcy5wYXJhbXNNb2RlbCk7XHJcblxyXG5cdFx0dGhpcy5wYXJhbXNNb2RlbChhcnIubWFwKHBhcmFtID0+IHtcclxuXHRcdFx0cGFyYW0udmFsdWUocGFyYW0uc2VsZWN0ICYmIHBhcmFtLmRlZmF1bHQgfHwgJycpO1xyXG5cclxuXHRcdFx0aWYgKHBhcmFtLnNlbGVjdCkge1xyXG5cdFx0XHRcdHBhcmFtLm9wdGlvbnMoa28udW53cmFwKHBhcmFtLm9wdGlvbnMpLm1hcCgob3B0aW9uLCBpbmRleCkgPT4ge1xyXG5cdFx0XHRcdFx0b3B0aW9uLmNoZWNrZWQoIWluZGV4KTtcclxuXHRcdFx0XHRcdHJldHVybiBvcHRpb247XHJcblx0XHRcdFx0fSkpO1xyXG5cdFx0XHR9XHJcblx0XHRcdHJldHVybiBwYXJhbTtcclxuXHRcdH0pKTtcclxuXHJcblx0XHQvLyBwcmVwYXJlIG91dHB1dCBmb3IgcmVxdWVzdFxyXG5cdFx0dGhpcy5wYXJhbUluRm9jdXModGhpcy5wYXJhbXNNb2RlbCgpWzBdKTtcclxuXHRcdHRoaXMucHJlcGFyZVVybFBhaXJzKGFyciwgdGhpcy5zZWxlY3RlZFBhcmFtcyk7XHJcblx0fTtcclxufVxyXG5cclxua28uY29tcG9uZW50cy5yZWdpc3RlcigncGFyYW1zLWZpbHRlcicsIHtcclxuXHR2aWV3TW9kZWw6IFBhcmFtc0ZpbHRlcixcclxuXHR0ZW1wbGF0ZTpgXHJcblx0XHQ8c2VjdGlvbiBkYXRhLWJpbmQ9XCJjc3M6IHtjbG9zZWQ6IGlzSGlkZGVuLCBkaXJ0eTogaXNEaXJ0eX1cIiBjbGFzcz1cImFwaS1leHAtcGFyYW1zIGpzLXNsaWRlLWNvbnRyb2xcIj5cclxuXHRcdFxyXG5cdFx0XHQ8c2VjdGlvbiBjbGFzcz1cImFwaS1leHAtcGFyYW1zLWhlYWRsaW5lXCI+XHJcblx0XHRcdFx0PGJ1dHRvbiBpZD1cImFwaS1leHAyLXBhcmFtcy10b2dnbGVcIiBkYXRhLWJpbmQ9XCJjbGljazogc2xpZGVUb2dnbGVcIiBjbGFzcz1cImJ0biBidG4taWNvbiB0b2dnbGUtYnRuXCIgdHlwZT1cImJ1dHRvblwiPlBhcmFtZXRlcnM8L2J1dHRvbj5cclxuXHRcdFx0XHQ8c3BhbiBjbGFzcz1cImJ0biBidG4taWNvbiBzaGV2cm9uIHVwIGdyZXlcIiBkYXRhLWJpbmQ9XCJjc3M6IHtkb3duOiBpc0hpZGRlbn1cIj48L3NwYW4+XHJcblx0XHRcdFx0PGRpdiBjbGFzcz1cImFwaS1leHAtcGFyYW1zLWhlYWRsaW5lLWVkaXRcIj5cclxuXHRcdFx0XHRcdDxidXR0b24gY2xhc3M9XCJidG4gYXBpLWV4cC1wYXJhbXMtaGVhZGxpbmVfX2J0biBhcGktZXhwLXBhcmFtcy1oZWFkbGluZV9fYnRuLWNvcHlcIj4mbmJzcDs8L2J1dHRvbj5cclxuXHRcdFx0XHRcdDxidXR0b24gZGF0YS1iaW5kPVwiY2xpY2s6IG9uUGFyYW1zQ2xlYXJcIiBjbGFzcz1cImJ0biBhcGktZXhwLXBhcmFtcy1oZWFkbGluZV9fYnRuIGFwaS1leHAtcGFyYW1zLWhlYWRsaW5lX19idG4tY2xlYXJcIj4mbmJzcDs8L2J1dHRvbj5cclxuXHRcdFx0XHQ8L2Rpdj5cclxuXHRcdFx0PC9zZWN0aW9uPlxyXG5cdFx0XHRcclxuXHRcdFx0PGRpdiBjbGFzcz1cImFwaS1leHAtcGFyYW1zLXdyYXBwZXIgY2xlYXJmaXgganMtc2xpZGUtd3JhcHBlclwiPlxyXG5cdFx0XHRcdDwhLS1hYm91dC0tPlxyXG5cdFx0XHRcdDxzZWN0aW9uIGNsYXNzPVwiYXBpLWV4cC1hYm91dCB2aXNpYmxlLWxnLWJsb2NrXCI+XHJcblx0XHRcdFx0XHQ8ZGl2IGNsYXNzPVwiYXBpLWV4cC1hYm91dC13cmFwcGVyXCI+XHJcblx0XHRcdFx0XHRcdDxzcGFuIGNsYXNzPVwiYXBpLWV4cC1hYm91dF9fYnV0dG9uXCI+PC9zcGFuPlxyXG5cdFx0XHRcdFx0XHQ8YXJ0aWNsZSBjbGFzcz1cImFwaS1leHAtYWJvdXRfX2NvbnRlbnRcIj5cclxuXHRcdFx0XHRcdFx0XHQ8aDUgZGF0YS1iaW5kPVwidGV4dDogcGFyYW1JbkZvY3VzKCkubmFtZVwiIGNsYXNzPVwiYXBpLWV4cC1hYm91dF9fdGl0bGVcIj5BYm91dCBBUEkgYW5kIE1ldGhvZDo8L2g1PlxyXG5cdFx0XHRcdFx0XHRcdDxzZWN0aW9uIGNsYXNzPVwiYXBpLWV4cC1hYm91dF9fZGVzY3JpcHRpb25cIj5cclxuXHRcdFx0XHRcdFx0XHRcdDxwIGRhdGEtYmluZD1cImh0bWw6IHBhcmFtSW5Gb2N1cygpLmRvY1wiPjwvcD5cclxuXHRcdFx0XHRcdFx0XHQ8L3NlY3Rpb24+XHJcblx0XHRcdFx0XHRcdDwvYXJ0aWNsZT5cclxuXHRcdFx0XHRcdDwvZGl2PlxyXG5cdFx0XHRcdDwvc2VjdGlvbj5cclxuXHRcdFx0XHRcclxuXHRcdFx0XHQ8IS0tcGFyYW1zIGZpbHRlci0tPlxyXG5cdFx0XHRcdDxzZWN0aW9uIGNsYXNzPVwiYXBpLWV4cC1wYXJhbXMtZmlsdGVyXCI+XHJcblx0XHRcdFx0XHQ8c2VjdGlvbiBkYXRhLWJpbmQ9XCJmb3JlYWNoOiBwYXJhbXNNb2RlbFwiIGNsYXNzPVwiYXBpLWV4cC1wYXJhbXMtZmlsdGVyLWZpZWxkc1wiPlxyXG5cdFx0XHRcdFx0XHQ8IS0tc2VsZWN0LS0+XHJcblx0XHRcdFx0XHRcdDwhLS0ga28gaWZub3Q6IHN0eWxlID09PSAncmVxdWVzdEJvZHknIC0tPlxyXG5cdFx0XHRcdFx0XHRcdDxkaXYgY2xhc3M9XCJhcGktZXhwLXBhcmFtcy1maWx0ZXJfX2ZpZWxkXCI+XHJcblx0XHRcdFx0XHRcdFx0XHQ8IS0tIGtvIGlmOiBzZWxlY3QgLS0+XHJcblx0XHRcdFx0XHRcdFx0XHRcdDxjdXN0b20tc2VsZWN0IHBhcmFtcz1cIlxyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGRhdGE6ICRkYXRhLFxyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdG9wdGlvbnM6IG9wdGlvbnMsXHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0b25zZWxlY3Q6ICRjb21wb25lbnQub25TZWxlY3RQYXJhbVZhbHVlLmJpbmQoJGRhdGEsICRkYXRhKSxcclxuXHRcdFx0XHRcdFx0XHRcdFx0XHRmb2N1czogJGNvbXBvbmVudC5vbkZvY3VzLFxyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHNlbGVjdGVkOiB2YWx1ZVwiPlxyXG5cdFx0XHRcdFx0XHRcdFx0XHQ8L2N1c3RvbS1zZWxlY3Q+XHJcblx0XHRcdFx0XHRcdFx0XHQ8IS0tIC9rbyAtLT5cclxuXHRcdFx0XHRcdFx0XHRcdDwhLS0ga28gaWZub3Q6IHNlbGVjdCAtLT5cclxuXHRcdFx0XHRcdFx0XHRcdFx0PGN1c3RvbS1pbnB1dCBwYXJhbXM9XCJcclxuXHRcdFx0XHRcdFx0XHRcdFx0XHRvbkZvY3VzTWV0aG9kOiAkY29tcG9uZW50Lm9uRm9jdXMsXHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0ZGF0YTogJGRhdGEsXHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0Y3NzQ2xhc3M6IGhhc0NhbGVuZGFyID8gJ2NhbGVuZGFyJzogaGFzUG9wVXAgPyAncG9wdXAnOiAnJyxcclxuXHRcdFx0XHRcdFx0XHRcdFx0XHR2YWxpZGF0aW9uTW9kZWw6ICRyb290LnZhbGlkYXRpb25Nb2RlbFwiPlxyXG5cdFx0XHRcdFx0XHRcdFx0XHQ8L2N1c3RvbS1pbnB1dD5cclxuXHRcdFx0XHRcdFx0XHRcdDwhLS0gL2tvIC0tPlxyXG5cdFx0XHRcdFx0XHRcdDwvZGl2PlxyXG5cdFx0XHRcdFx0XHQ8IS0tIC9rbyAtLT5cclxuXHRcdFx0XHRcdFx0PCEtLSBrbyBpZjogc3R5bGUgPT09ICdyZXF1ZXN0Qm9keSctLT5cclxuXHRcdFx0XHRcdFx0XHQ8c2VjdGlvbiBjbGFzcz1cImN1c290bS10ZXh0YXJlYS13cmFwcGVyXCI+XHJcblx0XHRcdFx0XHRcdFx0XHQ8Y3VzdG9tLWlucHV0IHBhcmFtcz1cIlxyXG5cdFx0XHRcdFx0XHRcdFx0XHRvbkZvY3VzTWV0aG9kOiAkY29tcG9uZW50Lm9uRm9jdXMsXHJcblx0XHRcdFx0XHRcdFx0XHRcdGRhdGE6ICRkYXRhLFxyXG5cdFx0XHRcdFx0XHRcdFx0XHRjc3NDbGFzczogaGFzQ2FsZW5kYXIgPyAnY2FsZW5kYXInOiBoYXNQb3BVcCA/ICdwb3B1cCc6ICcnLFxyXG5cdFx0XHRcdFx0XHRcdFx0XHR2YWxpZGF0aW9uTW9kZWw6ICRyb290LnZhbGlkYXRpb25Nb2RlbFwiPlxyXG5cdFx0XHRcdFx0XHRcdFx0PC9jdXN0b20taW5wdXQ+XHJcblx0XHRcdFx0XHRcdFx0PC9zZWN0aW9uPlxyXG5cdFx0XHRcdFx0XHQ8IS0tIC9rbyAtLT5cclxuXHRcdFx0XHRcdDwvc2VjdGlvbj5cclxuXHRcdFx0XHQ8L3NlY3Rpb24+PCEtLXBhcmFtcyBmaWx0ZXItLT5cclxuXHRcdFx0PC9kaXY+XHJcblx0XHQ8L3NlY3Rpb24+PCEtLXBhcmFtZXRlcnMtLT5cclxuYH0pO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBQYXJhbXNGaWx0ZXI7XHJcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NjcmlwdHMvYXBpLWV4cGxvcmVyL3YyL3NyYy9jb21wb25lbnRzL2ZpbHRlci9wYXJhbXNGaWx0ZXIuY29tcG9uZW50LmpzIiwidmFyIHNlbGY7XHJcblxyXG5mdW5jdGlvbiBSYWRpb0ZpbHRlcihwYXJhbXMpIHtcclxuXHRzZWxmID0gdGhpcztcclxuXHR2YXIgc2VsZWN0ZWRDYXRlZ29yeSA9IGtvLnVud3JhcChwYXJhbXMuc2VsZWN0ZWRDYXRlZ29yeSk7XHJcblx0dmFyIGRhdGEgPSBwYXJhbXMuZGF0YTtcclxuXHR0aGlzLnNlbGVjdGVkTWV0aG9kVHlwZSA9IHBhcmFtcy5zZWxlY3RlZE1ldGhvZFR5cGU7XHJcblx0dGhpcy5SQURJT19JRCA9ICdhcGktZXhwLSc7XHJcblxyXG5cdHRoaXMucmFkaW9zTW9kZWwgPSBrby5vYnNlcnZhYmxlQXJyYXkoW10pO1xyXG5cdHRoaXMudXBkYXRlUmFkaW9zTW9kZWwoZGF0YVtzZWxlY3RlZENhdGVnb3J5XSk7XHJcblxyXG5cdHBhcmFtcy5zZWxlY3RlZENhdGVnb3J5LnN1YnNjcmliZShmdW5jdGlvbiAodmFsKSB7XHJcblx0XHR0aGlzLnVwZGF0ZVJhZGlvc01vZGVsKGRhdGFbdmFsXSk7XHJcblx0fSwgdGhpcyk7XHJcbn1cclxuXHJcblJhZGlvRmlsdGVyLnByb3RvdHlwZS51cGRhdGVSYWRpb3NNb2RlbCA9IGZ1bmN0aW9uIChwYXJhbSkge1xyXG5cdHZhciBvYmogPSBwYXJhbSB8fCB7fSxcclxuXHRcdGFyciA9IFtdO1xyXG5cclxuXHRmb3IgKHZhciBpIGluIG9iaikge1xyXG5cdFx0aWYgKCFvYmouaGFzT3duUHJvcGVydHkoaSkpIHsgY29udGludWU7IH1cclxuXHRcdHZhciBpdGVtID0ge1xyXG5cdFx0XHRjaGVja2VkOiBrby5vYnNlcnZhYmxlKGkgPT09ICdBTEwnKSxcclxuXHRcdFx0bmFtZTogaVxyXG5cdFx0fTtcclxuXHRcdGFyci5wdXNoKGl0ZW0pO1xyXG5cdFx0Ly8gaW5pdGlhbCBub3RpZnkgZm9yIGFsbCBzdWJzY3JpYmVyc1xyXG5cdFx0aSA9PT0gJ0FMTCcgJiYgdGhpcy5zZWxlY3RlZE1ldGhvZFR5cGUubm90aWZ5U3Vic2NyaWJlcnMoaSk7XHJcblx0fVxyXG5cclxuXHRhcnIgPSBhcnIuc29ydChjb21wYXJlTWV0aG9kcyk7XHJcblx0dGhpcy5yYWRpb3NNb2RlbChhcnIpO1xyXG5cdHJldHVybiBhcnI7XHJcbn07XHJcblxyXG4vKipcclxuICogT25jaGFuZ2UgaGFuZGxlciBmb3IgUmFkaW8gYnV0dG9uc1xyXG4gKiBAcGFyYW0gaXRlbVxyXG4gKi9cclxuUmFkaW9GaWx0ZXIucHJvdG90eXBlLm9uY2hhbmdlUmFkaW9zID0gZnVuY3Rpb24gKGl0ZW0pIHtcclxuXHR2YXIgcmFkaW9zTW9kZWwgPSBrby51bndyYXAoc2VsZi5yYWRpb3NNb2RlbCkubWFwKGZ1bmN0aW9uIChvYmopIHtcclxuXHRcdGlmIChvYmoubmFtZSA9PT0gaXRlbS5uYW1lKSB7XHJcblx0XHRcdG9iai5jaGVja2VkKHRydWUpO1xyXG5cdFx0XHRzZWxmLnNlbGVjdGVkTWV0aG9kVHlwZShvYmoubmFtZSk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRvYmouY2hlY2tlZChmYWxzZSk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gb2JqO1xyXG5cdH0pO1xyXG5cdHNlbGYucmFkaW9zTW9kZWwocmFkaW9zTW9kZWwpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFVuaXEgaWQgZm9yIHJhZGlvIGJ0blxyXG4gKiBAcGFyYW0gbmFtZVxyXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxyXG4gKi9cclxuUmFkaW9GaWx0ZXIucHJvdG90eXBlLmdldElucHV0SWQgPSBmdW5jdGlvbiAobmFtZSkge1xyXG5cdHJldHVybiBzZWxmLlJBRElPX0lEICsgbmFtZTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBTb3J0IGZ1bmN0aW9uIGZvciBtZXRob2RzIGFyYXlcclxuICogQHBhcmFtIGZcclxuICogQHBhcmFtIHNcclxuICogQHJldHVybnMge251bWJlcn1cclxuICovXHJcbmZ1bmN0aW9uIGNvbXBhcmVNZXRob2RzKGYscykge1xyXG5cdHZhciBhID0gZi5uYW1lLnRvVXBwZXJDYXNlKCk7XHJcblx0dmFyIGIgPSBzLm5hbWUudG9VcHBlckNhc2UoKTtcclxuXHJcblx0aWYgKGEgPT09IGIpIHtyZXR1cm4gMDt9XHJcblx0aWYgKGEgPT09ICdBTEwnIHx8XHJcblx0XHQoYSA9PT0gJ0dFVCcgJiYgKGIgPT09ICdQT1NUJyB8fCBiID09PSAnUFVUJyB8fCBiID09PSAnREVMRVRFJykpIHx8XHJcblx0XHQoYSA9PT0gJ1BPU1QnICYmIChiID09PSAnUFVUJyB8fCBiID09PSAnREVMRVRFJykpIHx8XHJcblx0XHQoYSA9PT0gJ1BVVCcgJiYgYiA9PT0gJ0RFTEVURScpKSB7XHJcblx0XHRyZXR1cm4gLTE7XHJcblx0fVxyXG5cdHJldHVybiAxO1xyXG59XHJcblxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBrby5jb21wb25lbnRzLnJlZ2lzdGVyKCdyYWRpby1maWx0ZXInLCB7XHJcblx0dmlld01vZGVsOiBSYWRpb0ZpbHRlcixcclxuXHR0ZW1wbGF0ZTpgXHJcblx0XHQ8IS0tcmFkaW9zLS0+XHJcblx0XHQ8c2VjdGlvbiBkYXRhLWJpbmQ9XCJmb3JlYWNoOiByYWRpb3NNb2RlbFwiIGNsYXNzPVwiYXBpLWV4cC1tZXRob2RzX19yYWRpby1idXR0b25zIHJhZGlvLWJ1dHRvbnMgY2xlYXJmaXhcIj5cclxuXHRcdFx0PGRpdiBkYXRhLWJpbmQ9XCJjc3M6IHthY3RpdmU6IGNoZWNrZWR9XCIgY2xhc3M9XCJhcGktZXhwLW1ldGhvZFwiPlxyXG5cdFx0XHRcdDxpbnB1dCBkYXRhLWJpbmQ9XCJhdHRyOiB7IGlkOiAkY29tcG9uZW50LmdldElucHV0SWQobmFtZSksIGNoZWNrZWQ6IGNoZWNrZWQgfSwgZXZlbnQ6IHtjaGFuZ2U6ICRjb21wb25lbnQub25jaGFuZ2VSYWRpb3N9XCJcclxuXHRcdFx0XHRcdFx0XHRcdGNsYXNzPVwiYXBpLWV4cC1jb250ZW50LW1ldGhvZF9fcmFkaW9cIlxyXG5cdFx0XHRcdFx0XHRcdFx0dHlwZT1cInJhZGlvXCJcclxuXHRcdFx0XHRcdFx0XHRcdG5hbWU9XCJhcGktZXhwLW1ldGhvZHNcIj5cclxuXHRcdFx0XHQ8bGFiZWwgZGF0YS1iaW5kPVwidGV4dDogbmFtZSwgYXR0cjoge2ZvcjogJGNvbXBvbmVudC5nZXRJbnB1dElkKG5hbWUpfVwiIGNsYXNzPVwicmFkaW8taW5saW5lIGFwaS1leHAtbWV0aG9kX19sYWJlbFwiPjwvbGFiZWw+XHJcblx0XHRcdDwvZGl2PlxyXG5cdFx0PC9zZWN0aW9uPlxyXG5gfSk7XHJcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NjcmlwdHMvYXBpLWV4cGxvcmVyL3YyL3NyYy9jb21wb25lbnRzL2ZpbHRlci9yYWRpb0ZpbHRlci5jb21wb25lbnQuanMiLCJyZXF1aXJlKCcuL2NvbW1vbicpO1xyXG5yZXF1aXJlKCcuL2ZpbHRlcicpO1xyXG5yZXF1aXJlKCcuL3BvcHVwcycpO1xyXG5yZXF1aXJlKCcuL3BhbmVscycpO1xyXG5yZXF1aXJlKCcuL3JlcXVlc3QnKTtcclxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc2NyaXB0cy9hcGktZXhwbG9yZXIvdjIvc3JjL2NvbXBvbmVudHMvaW5kZXguanMiLCJ2YXIgc2VsZjtcclxuXHJcbmNsYXNzIEFycmF5UGFuZWxCb2R5IHtcclxuXHRjb25zdHJ1Y3RvcihwYXJhbXMpIHtcclxuXHRcdHNlbGYgPSB0aGlzO1xyXG5cdFx0dGhpcy5kYXRhID0gcGFyYW1zLmRhdGEudmFsdWU7XHJcblx0XHR0aGlzLmNvbmZpZyA9IHBhcmFtcy5jb25maWc7XHJcblx0XHR0aGlzLl9wYW5lbE5hbWUgPSBwYXJhbXMuZGF0YS5rZXk7XHJcblx0XHR0aGlzLmNhcmRJbmRleCA9IHRoaXMuY2FyZEluZGV4IHx8IGtvLnV0aWxzLnVud3JhcE9ic2VydmFibGUocGFyYW1zLmluZGV4KTtcclxuXHRcdHRoaXMucGFuZWxHcm91cCA9IHBhcmFtcy5wYW5lbEdyb3VwO1xyXG5cdFx0dGhpcy5nZXRNb3JlID0gdGhpcy5wYW5lbEdyb3VwLmdldE1vcmU7XHJcblx0fVxyXG5cclxuXHRnZXRTdGFydERhdGEoJGRhdGEpIHtcclxuXHRcdHJldHVybiBPYmplY3QuZ2V0UHJvcCgkZGF0YSwgJ2RhdGVzLnN0YXJ0LmxvY2FsRGF0ZScpIHx8ICcnXHJcblx0fVxyXG5cdGdldFZlbnVlTmFtZSgkZGF0YSkge1xyXG5cdFx0cmV0dXJuIE9iamVjdC5nZXRQcm9wKCRkYXRhLCAnX2VtYmVkZGVkLnZlbnVlc1swXS5uYW1lJykgfHwgJydcclxuXHR9XHJcblx0c2V0QWN0aXZlKCRpbmRleCwgbW9kZWwsIGUpIHtcclxuXHRcdCQoZS5jdXJyZW50VGFyZ2V0KVxyXG5cdFx0XHQucGFyZW50cygnLnNsaWNrLXNsaWRlJylcclxuXHRcdFx0LmZpbmQoJy5pdGVtLm9iamVjdCcpXHJcblx0XHRcdC5yZW1vdmVDbGFzcygnYWN0aXZlJyk7XHJcblx0XHQkKGUuY3VycmVudFRhcmdldClcclxuXHRcdFx0LnBhcmVudCgnLml0ZW0nKVxyXG5cdFx0XHQuYWRkQ2xhc3MoJ2FjdGl2ZScpO1xyXG5cdFx0dGhpcy5nZXRNb3JlLmNhbGwobnVsbCwge3BhbmVsOiB0aGlzLCBpZDogJGluZGV4LCBkYXRhOiBtb2RlbH0pO1xyXG5cdH1cclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBrby5jb21wb25lbnRzLnJlZ2lzdGVyKCdhcnJheS1wYW5lbC1ib2R5Jywge1xyXG5cdHZpZXdNb2RlbDogQXJyYXlQYW5lbEJvZHksXHJcblx0dGVtcGxhdGU6YFxyXG5cdFx0PHNlY3Rpb24gY2xhc3M9XCJwYW5lbC1ib2R5IGFycmF5LXBhbmVsLWJvZHlcIj5cclxuXHRcdFx0PHVsIGRhdGEtYmluZD1cImZvcmVhY2g6IGRhdGEsIGNzczogeydldmVudHMnOiAkY29tcG9uZW50Ll9wYW5lbE5hbWUgPT09ICdldmVudHMnfVwiIGNsYXNzPVwibGlzdCBsaXN0LWdyb3VwXCI+XHJcblx0XHRcdFx0PGxpIGRhdGEtYmluZD1cImNzczogeydvYmplY3QnOiB0eXBlb2YgJGRhdGEgPT09ICdvYmplY3QnfVwiIGNsYXNzPVwibGlzdC1ncm91cC1pdGVtIGl0ZW1cIj5cclxuXHRcdFx0XHRcclxuXHRcdFx0XHRcdDwhLS0ga28gaWY6ICRjb21wb25lbnQuX3BhbmVsTmFtZSA9PT0gJ2ltYWdlcycgLS0+XHJcblx0XHRcdFx0XHRcdDxpbWcgZGF0YS1iaW5kPVwiYXR0cjoge3NyYzogdXJsLCBhbHQ6ICdpbWFnZS0nICsgcmF0aW99XCIgYWx0PVwiaW1nXCIgY2xhc3M9XCJpbWdcIj5cclxuXHRcdFx0XHRcdFx0PGRpdiBjbGFzcz1cImltZy1pbmZvXCI+XHJcblx0XHRcdFx0XHRcdFx0PHNwYW4gY2xhc3M9XCJpbWctcmF0aW9cIj5SYXRpbzogPGkgZGF0YS1iaW5kPVwidGV4dDogcmF0aW9cIj48L2k+PC9zcGFuPlxyXG5cdFx0XHRcdFx0XHRcdDxzcGFuIGNsYXNzPVwiaW1nLXNpemVcIj4oPGkgZGF0YS1iaW5kPVwidGV4dDogaGVpZ2h0XCI+PC9pPiB4IDxpIGRhdGEtYmluZD1cInRleHQ6IHdpZHRoXCI+PC9pPik8L3NwYW4+XHJcblx0XHRcdFx0XHRcdDwvZGl2PlxyXG5cdFx0XHRcdFx0PCEtLSAva28gLS0+XHJcblx0XHRcdFx0XHRcclxuXHRcdFx0XHRcdDwhLS0ga28gaWZub3Q6ICRjb21wb25lbnQuX3BhbmVsTmFtZSA9PT0gJ2ltYWdlcycgLS0+XHJcblx0XHRcdFx0XHRcdDxkaXYgY2xhc3M9XCJ2ZXJ0aWNhbC1hbGlnbi1jZW50ZXJcIj5cclxuXHRcdFx0XHRcdFx0XHQ8ZGl2IGNsYXNzPVwibmFtZS13cmFwcGVyXCI+XHJcblx0XHRcdFx0XHRcdFx0XHQ8c3BhbiBkYXRhLWJpbmQ9XCJ0ZXh0OiBuYW1lIHx8ICcjJyArICRpbmRleCgpLCBibG9ja0VsbGlwc2lzOiB7Y2xhbXA6IDJ9XCIgY2xhc3M9XCJuYW1lXCI+PC9zcGFuPlxyXG5cdFx0XHRcdFx0XHRcdDwvZGl2PlxyXG5cdFx0XHRcdFx0XHQ8L2Rpdj5cclxuXHRcdFx0XHRcdFx0XHJcblx0XHRcdFx0XHRcdDwhLS0ga28gaWY6ICRjb21wb25lbnQuX3BhbmVsTmFtZSA9PT0gJ2V2ZW50cycgLS0+XHJcblx0XHRcdFx0XHRcdFx0PGRpdiBjbGFzcz1cImFkZGl0aW9uYWwtaW5mb1wiPlxyXG5cdFx0XHRcdFx0XHRcdFx0PHAgZGF0YS1iaW5kPVwidGV4dDogJGNvbXBvbmVudC5nZXRTdGFydERhdGEoJGRhdGEpXCIgY2xhc3M9XCJkYXRlXCI+ZXZlbnQgZGF0ZTwvcD5cclxuXHRcdFx0XHRcdFx0XHRcdDwhLS0ga28gaWY6ICRjb21wb25lbnQuZ2V0VmVudWVOYW1lKCRkYXRhKS0tPlxyXG5cdFx0XHRcdFx0XHRcdFx0XHQ8cCBkYXRhLWJpbmQ9XCJ0ZXh0OiAkY29tcG9uZW50LmdldFZlbnVlTmFtZSgkZGF0YSlcIiBjbGFzcz1cInZlbnVlIHRydW5jYXRlXCI+ZXZlbnQgdmVudWU8L3A+XHJcblx0XHRcdFx0XHRcdFx0XHQ8IS0tL2tvLS0+XHJcblx0XHRcdFx0XHRcdFx0PC9kaXY+XHJcblx0XHRcdFx0XHRcdDwhLS0gL2tvIC0tPlxyXG5cdFx0XHRcdFx0XHRcclxuXHRcdFx0XHRcdDwhLS0gL2tvIC0tPlxyXG5cdFx0XHRcdFx0XHJcblx0XHRcdFx0XHQ8IS0tIGtvIGlmOiB0eXBlb2YgJGRhdGEgPT09ICdvYmplY3QnIC0tPlxyXG5cdFx0XHRcdFx0XHQ8YnV0dG9uIGRhdGEtYmluZD1cImNsaWNrOiAkY29tcG9uZW50LnNldEFjdGl2ZS5iaW5kKCRjb21wb25lbnQsICRpbmRleCgpKVwiIHR5cGU9XCJidXR0b25cIiBjbGFzcz1cImJ0biBidG4taWNvbiBibHVlLXNoZXZyb24tcmlnaHQgcHVsbC1yaWdodFwiPjwvYnV0dG9uPlxyXG5cdFx0XHRcdFx0PCEtLSAva28gLS0+XHJcblx0XHRcdFx0XHRcclxuXHRcdFx0XHQ8L2xpPlxyXG5cdFx0XHQ8L3VsPlxyXG5cdFx0PC9zZWN0aW9uPlxyXG5gfSk7XHJcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NjcmlwdHMvYXBpLWV4cGxvcmVyL3YyL3NyYy9jb21wb25lbnRzL3BhbmVscy9hcnJheVBhbmVsQm9keS5jb21wb25lbnQuanMiLCJyZXF1aXJlKCcuL3BhbmVsR3JvdXAuY29tcG9uZW50Jyk7XHJcbnJlcXVpcmUoJy4vcGFuZWwuY29tcG9uZW50Jyk7XHJcbnJlcXVpcmUoJy4vcGFnaW5hdGlvbi5jb21wb25lbnQnKTtcclxucmVxdWlyZSgnLi9wYW5lbEhlYWRpbmcuY29tcG9uZW50Jyk7XHJcbnJlcXVpcmUoJy4vb2JqZWN0UGFuZWxCb2R5LmNvbXBvbmVudCcpO1xyXG5yZXF1aXJlKCcuL2FycmF5UGFuZWxCb2R5LmNvbXBvbmVudCcpO1xyXG5yZXF1aXJlKCcuL21hcFBhbmVsQm9keS5jb21wb25lbnQnKTtcclxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc2NyaXB0cy9hcGktZXhwbG9yZXIvdjIvc3JjL2NvbXBvbmVudHMvcGFuZWxzL2luZGV4LmpzIiwiY2xhc3MgTWFwUGFuZWxCb2R5IHtcclxuXHRjb25zdHJ1Y3Rvcih7bGF0ID0gbnVsbCwgbG9uZyA9IG51bGwsIGFkZHJlc3MsIHNob3dNYXBQb3B1cCA9IG51bGwsIHpvb20gPSA4LCB3aWR0aCA9IDM1MCwgaGVpZ2h0ID0gNDAwLCBmb3JtYXQgPSAnSlBFRyd9KSB7XHJcblx0XHR0aGlzLmxhdCA9IHBhcnNlRmxvYXQobGF0KTtcclxuXHRcdHRoaXMubG9uZyA9IHBhcnNlRmxvYXQobG9uZyk7XHJcblx0XHR0aGlzLmFkZHJlc3MgPSBhZGRyZXNzO1xyXG5cdFx0dGhpcy5zaXplID0gYCR7d2lkdGh9eCR7aGVpZ2h0fWA7XHJcblx0XHR0aGlzLnpvb20gPSB6b29tO1xyXG5cdFx0bGV0IGNvb3JkaW5hdGVzID0gYCR7bGF0fSwke2xvbmd9YDtcclxuXHRcdHRoaXMudXJsID0ga28ucHVyZUNvbXB1dGVkKCgpID0+XHJcblx0XHRcdGBodHRwczovL21hcHMuZ29vZ2xlYXBpcy5jb20vbWFwcy9hcGkvc3RhdGljbWFwXHJcblx0XHRcdD9jZW50ZXI9JHtjb29yZGluYXRlc31cclxuXHRcdFx0Jnpvb209JHt6b29tfVxyXG5cdFx0XHQmc2l6ZT0ke3RoaXMuc2l6ZX1cclxuXHRcdFx0JmZvcm1hdD0ke2Zvcm1hdH1cclxuXHRcdFx0Jm1hcmtlcnM9Y29sb3I6cmVkJTdDbGFiZWw6ViU3QyR7Y29vcmRpbmF0ZXN9YFxyXG5cdFx0KTtcclxuXHRcdHRoaXMuc2hvd01hcFBvcHVwID0gc2hvd01hcFBvcHVwO1xyXG5cdH1cclxufVxyXG5cclxua28uY29tcG9uZW50cy5yZWdpc3RlcignbWFwLXBhbmVsLWJvZHknLCB7XHJcblx0dmlld01vZGVsOiBNYXBQYW5lbEJvZHksXHJcblx0dGVtcGxhdGU6YFxyXG5cdFx0PHNlY3Rpb24gY2xhc3M9XCJtYXAtcGFuZWwtYm9keVwiPlxyXG5cdFx0XHQ8YSBjbGFzcz1cImxvY2F0aW9uLW1hcC1saW5rXCIgZGF0YS1iaW5kPVwiY2xpY2s6IHNob3dNYXBQb3B1cFwiIGhyZWY9XCIjXCI+XHJcblx0XHRcdFx0PGltZyBkYXRhLWJpbmQ9XCJhdHRyOiB7J2RhdGEtbGF0JzogbGF0LCAnZGF0YS1sb25nJzogbG9uZywgJ2RhdGEtYWRkcmVzcyc6IGFkZHJlc3MsIHNyYzogdXJsfSwgaW1nT25FcnJvclwiPlxyXG5cdFx0XHQ8L2E+XHJcblx0XHQ8L3NlY3Rpb24+XHJcbmB9KTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gTWFwUGFuZWxCb2R5O1xyXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zY3JpcHRzL2FwaS1leHBsb3Jlci92Mi9zcmMvY29tcG9uZW50cy9wYW5lbHMvbWFwUGFuZWxCb2R5LmNvbXBvbmVudC5qcyIsImNsYXNzIE9iamVjdFBhbmVsQm9keSB7XHJcblx0Y29uc3RydWN0b3Ioe2RhdGEgPSB7fSwgY29uZmlnLCBpbmRleCA9IHRoaXMuY2FyZEluZGV4LCBwYW5lbEdyb3VwID0ge30sIHBhZ2UsIGNvbGxhcHNlSWQsIHN1YmplY3RJRH0pIHtcclxuXHRcdHRoaXMuZGF0YSA9IHRoaXMuZGF0YSB8fCBrby5vYnNlcnZhYmxlKGRhdGEudmFsdWUpO1xyXG5cdFx0dGhpcy5jb25maWcgPSBjb25maWc7XHJcblx0XHR0aGlzLl9wYW5lbE5hbWUgPSBkYXRhLmtleTtcclxuXHRcdHRoaXMuY2FyZEluZGV4ID0ga28udW53cmFwKGluZGV4KTtcclxuXHRcdHRoaXMucGFuZWxHcm91cCA9IHBhbmVsR3JvdXA7XHJcblx0XHR0aGlzLmdldE1vcmUgPSBwYW5lbEdyb3VwLmdldE1vcmU7XHJcblx0XHR0aGlzLnBhZ2UgPSBwYWdlO1xyXG5cdFx0dGhpcy5jb2xsYXBzZUlkID0gY29sbGFwc2VJZDtcclxuXHRcdHRoaXMuX2FsbEluc2lkZSA9ICEhT2JqZWN0LmdldFByb3Aoa28udW53cmFwKGNvbmZpZyksICcuX0NPTkZJRy5hbGxJbnNpZGUnKTtcclxuXHRcdHRoaXMuc29ydEJ5Q29uZmlnID0gcGFuZWxHcm91cC5zb3J0QnlDb25maWc7XHJcblx0XHR0aGlzLnN1YmplY3RJRCA9IHN1YmplY3RJRDtcclxuXHRcdHRoaXMuc2VuZElkKHRoaXMuZGF0YSk7XHJcblx0fVxyXG5cdFxyXG5cdHNlbmRJZChkYXRhKSB7XHJcblx0XHRsZXQgaWQgPSBrby51bndyYXAoZGF0YSkuaWQ7XHJcblx0XHRpZihpZCkge1xyXG5cdFx0XHR0aGlzLnN1YmplY3RJRChpZClcclxuXHRcdH1cclxuXHR9XHJcblx0XHJcblx0Y2hhbmdlUGFnZSA9IChtb2RlbCwgZXZlbnQpID0+IHtcclxuXHRcdGlmIChldmVudC5rZXlDb2RlID09PSAxMykge1xyXG5cdFx0XHRsZXQgcGFnZSA9IHRoaXMucGFnZSxcclxuXHRcdFx0XHR0b3RhbFBhZ2VzID0ga28udW53cmFwKHRoaXMuZGF0YSkudG90YWxQYWdlcyxcclxuXHRcdFx0XHR2YWx1ZSA9ICtldmVudC5jdXJyZW50VGFyZ2V0LnZhbHVlO1xyXG5cdFx0XHRcclxuXHRcdFx0dmFsdWUgPSBOdW1iZXIuaXNOYU4odmFsdWUpID8gMCA6IHZhbHVlO1xyXG5cdFx0XHRsZXQgcGFnZU51bWJlciA9IH5+dmFsdWUgPCAwID8gMCA6IH5+dmFsdWU7XHJcblx0XHRcdHBhZ2UucGFnZVBhcmFtKHBhZ2VOdW1iZXIgPCB0b3RhbFBhZ2VzID8gcGFnZU51bWJlciA6IHRvdGFsUGFnZXMgLSAxKTtcclxuXHRcdFx0cGFnZS5zZXRQYXJhbXMoe1xyXG5cdFx0XHRcdGNhdGVnb3J5OiBwYWdlLmNhdGVnb3J5LFxyXG5cdFx0XHRcdG1ldGhvZDogcGFnZS5tZXRob2QsXHJcblx0XHRcdFx0bWV0aG9kSWQ6IHBhZ2UubWV0aG9kSWQsXHJcblx0XHRcdFx0cGFyYW1zOiBwYWdlLnBhcmFtc1xyXG5cdFx0XHR9KTtcclxuXHRcdFx0JCgnI2FwaS1leHAtZ2V0LWJ0bicpLnRyaWdnZXIoJ2NsaWNrJyk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRyZXR1cm4gdHJ1ZTtcclxuXHRcdH1cclxuXHR9O1xyXG5cclxuXHRjYW5CZUNvcGllZChkYXRhKSB7XHJcblx0XHRyZXR1cm4gISFPYmplY3QuZ2V0UHJvcCh0aGlzLmNvbmZpZywgJy5fQ09ORklHLmNvcHlCdG4uJyArIGRhdGEua2V5KSAmJiB0eXBlb2YgZGF0YS52YWx1ZSAhPT0gJ29iamVjdCc7XHJcblx0fVxyXG5cclxuXHRzZXRBY3RpdmUoa2V5LCB2YWx1ZSwgbW9kZWwsIGUpe1xyXG5cdFx0JChlLmN1cnJlbnRUYXJnZXQpXHJcblx0XHRcdC5wYXJlbnRzKCcuc2xpY2stc2xpZGUnKVxyXG5cdFx0XHQuZmluZCgnLml0ZW0ub2JqZWN0JylcclxuXHRcdFx0LnJlbW92ZUNsYXNzKCdhY3RpdmUnKTtcclxuXHRcdCQoZS5jdXJyZW50VGFyZ2V0KVxyXG5cdFx0XHQucGFyZW50KCcuaXRlbScpXHJcblx0XHRcdC5hZGRDbGFzcygnYWN0aXZlJyk7XHJcblx0XHR0aGlzLmdldE1vcmUuY2FsbChudWxsLCB7cGFuZWw6IHRoaXMsIGlkOiBrZXksIGRhdGE6IHZhbHVlfSk7XHJcblx0fVxyXG59XHJcblxyXG5cclxuXHJcbm1vZHVsZS5leHBvcnRzID0ga28uY29tcG9uZW50cy5yZWdpc3Rlcignb2JqZWN0LXBhbmVsLWJvZHknLCB7XHJcblx0dmlld01vZGVsOiAgT2JqZWN0UGFuZWxCb2R5LFxyXG5cdHRlbXBsYXRlOmBcclxuXHRcdDxzZWN0aW9uIGRhdGEtYmluZD1cImNzczogeydhbGwtaW5zaWRlJzogJGNvbXBvbmVudC5fYWxsSW5zaWRlfVwiIGNsYXNzPVwicGFuZWwtYm9keSBvYmplY3QtcGFuZWwtYm9keVwiPlxyXG5cdFx0XHQ8IS0tIGtvIGlmOiAkY29tcG9uZW50Ll9wYW5lbE5hbWUgPT09ICdvYmplY3QnICYmICEhT2JqZWN0LmdldFByb3Aoa28udW53cmFwKGRhdGEpLCAnLnJhdGlvJyktLT5cclxuXHRcdFx0XHQ8aW1nIGRhdGEtYmluZD1cImF0dHI6IHtzcmM6IGtvLnV0aWxzLnVud3JhcE9ic2VydmFibGUoZGF0YSkudXJsLCBhbHQ6ICdpbWFnZS0nICsga28udXRpbHMudW53cmFwT2JzZXJ2YWJsZShkYXRhKS5yYXRpb31cIiBhbHQ9XCJpbWdcIiBjbGFzcz1cImltZyBpbWctdGh1bWJuYWlsXCI+XHJcblx0XHRcdDwhLS0gL2tvIC0tPlxyXG5cdFx0XHRcclxuXHRcdFx0PHVsIGRhdGEtYmluZD1cImZvcmVhY2hwcm9wOiB7ZGF0YTogZGF0YSwgc29ydEZuOiAkY29tcG9uZW50LnNvcnRCeUNvbmZpZy5iaW5kKCRjb21wb25lbnQpfVwiIGNsYXNzPVwibGlzdCBvYmplY3QtbGlzdFwiPlxyXG5cdFx0XHRcdDxsaSBkYXRhLWJpbmQ9XCJjc3M6IHsnb2JqZWN0JzogdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JywgJ3ByaW1pdGl2ZSc6IHR5cGVvZiB2YWx1ZSAhPT0gJ29iamVjdCd9XCIgY2xhc3M9XCJjbGVhcmZpeCBwYWRpbmcgaXRlbVwiPlxyXG5cdFx0XHRcdFxyXG5cdFx0XHRcdFx0PCEtLSBrbyBpZm5vdDogdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiAkY29tcG9uZW50Ll9hbGxJbnNpZGUgLS0+XHJcblx0XHRcdFx0XHQ8c3BhbiBkYXRhLWJpbmQ9XCJ0ZXh0OiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnID8ga2V5OiBrZXkgKyAnOidcIiBjbGFzcz1cImtleVwiPjwvc3Bhbj5cclxuXHRcdFx0XHRcdDwhLS0gL2tvIC0tPlxyXG5cdFx0XHRcdFx0XHJcblx0XHRcdFx0XHQ8IS0tIGtvIGlmbm90OiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnIHx8ICRjb21wb25lbnQuX3BhbmVsTmFtZSA9PT0gJ3BhZ2UnICYmIGtleSA9PT0gJ251bWJlcicgLS0+XHJcblx0XHRcdFx0XHRcdDxzcGFuIGRhdGEtYmluZD1cInRleHQ6IHZhbHVlXCIgY2xhc3M9XCJ2YWx1ZVwiPjwvc3Bhbj5cclxuXHRcdFx0XHRcdDwhLS0gL2tvIC0tPlxyXG5cdFx0XHRcdFx0XHJcblx0XHRcdFx0XHQ8IS0tIGtvIGlmOiAkY29tcG9uZW50Ll9wYW5lbE5hbWUgPT09ICdwYWdlJyAmJiBrZXkgPT09ICdudW1iZXInLS0+XHJcblx0XHRcdFx0XHRcdDxkaXYgY2xhc3M9XCJmb3JtLWlubGluZVwiPlxyXG5cdFx0XHRcdFx0XHRcdDxpbnB1dCBpZD1cInBhZ2luYXRpb24taW5wdXRcIiBkYXRhLWJpbmQ9XCJldmVudDoge2tleWRvd246ICRjb21wb25lbnQuY2hhbmdlUGFnZX0sIGF0dHI6IHtwbGFjZWhvbGRlcjogdmFsdWV9XCIgdHlwZT1cInRleHRcIiBwYXR0ZXJuPVwiWzAtOV0rXCIgY2xhc3M9XCJmb3JtLWNvbnRyb2xcIj5cclxuXHRcdFx0XHRcdFx0PC9kaXY+XHJcblx0XHRcdFx0XHQ8IS0tIC9rbyAtLT5cclxuXHRcdFx0XHRcdFxyXG5cdFx0XHRcdFx0PCEtLSBrbyBpZjogJGNvbXBvbmVudC5jYW5CZUNvcGllZC5jYWxsKCRjb21wb25lbnQsICRkYXRhKSAtLT5cclxuXHRcdFx0XHRcdFx0PCEtLSBjb3B5IHByb3BlcnR5IGJ0biAtLT5cclxuXHRcdFx0XHRcdFx0PGJ1dHRvbiBkYXRhLWJpbmQ9XCJjb3B5VG9DbGlwYm9hcmQ6IHt0ZXh0OiB2YWx1ZS50b1N0cmluZygpfSwgYXR0cjoge2lkOiAncHJvcC12YWx1ZS0nICsga2V5ICsgJGluZGV4KCl9LCBwb3BvdmVyOiB7dHlwZTogJ3Rvb2x0aXAnLCB0aXRsZTogJ0NvcHkgdmFsdWUnfVwiIHR5cGU9XCJidXR0b25cIiBjbGFzcz1cImJ0biBidG4taWNvbiBidG4tY29weVwiPjwvYnV0dG9uPlxyXG5cdFx0XHRcdFx0PCEtLSAva28gLS0+XHJcblx0XHRcdFx0XHRcclxuXHRcdFx0XHRcdDwhLS0ga28gaWY6IHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgJGNvbXBvbmVudC5fYWxsSW5zaWRlIC0tPlxyXG5cdFx0XHRcdFx0XHQ8cGFuZWwgcGFyYW1zPVwiJGRhdGE6ICRkYXRhLCAkaW5kZXg6ICRpbmRleCwgcGFuZWxHcm91cDogJGNvbXBvbmVudFwiPjwvcGFuZWw+XHJcblx0XHRcdFx0XHQ8IS0tIC9rbyAtLT5cclxuXHRcdFx0XHRcdDwhLS0ga28gaWY6IHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgISRjb21wb25lbnQuX2FsbEluc2lkZSAtLT5cclxuXHRcdFx0XHRcdFx0PGJ1dHRvbiBkYXRhLWJpbmQ9XCJjbGljazogJGNvbXBvbmVudC5zZXRBY3RpdmUuYmluZCgkY29tcG9uZW50LCBrZXksIHZhbHVlKVwiIHR5cGU9XCJidXR0b25cIiBjbGFzcz1cImJ0biBidG4taWNvbiBibHVlLXNoZXZyb24tcmlnaHQgcHVsbC1yaWdodFwiPjwvYnV0dG9uPlxyXG5cdFx0XHRcdFx0PCEtLSAva28gLS0+XHJcblx0XHRcdFx0PC9saT5cclxuXHRcdFx0PC91bD5cclxuXHRcdDwvc2VjdGlvbj5cclxuYH0pO1xyXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zY3JpcHRzL2FwaS1leHBsb3Jlci92Mi9zcmMvY29tcG9uZW50cy9wYW5lbHMvb2JqZWN0UGFuZWxCb2R5LmNvbXBvbmVudC5qcyIsIi8qKlxyXG4gKiBQYWdpbmF0aW9uIGVsZW1lbnRcclxuICogQHBhcmFtIHBhcmFtc1xyXG4gKi9cclxuY2xhc3MgUGFnaW5hdGlvbiB7XHJcblx0Y29uc3RydWN0b3Ioe3BhZ2UgPSB7fSwgdG90YWxQYWdlcywgbnVtYmVyfSkge1xyXG5cdFx0dGhpcy5wYWdlID0gcGFnZTtcclxuXHRcdHRoaXMudG90YWxQYWdlcyA9ICt0b3RhbFBhZ2VzO1xyXG5cdFx0dGhpcy5udW1iZXIgPSArbnVtYmVyO1xyXG5cdFx0dGhpcy5maXJzdCA9ICEhdGhpcy5udW1iZXI7XHJcblx0XHR0aGlzLmxhc3QgPSArbnVtYmVyIDwgK3RvdGFsUGFnZXMgLSAxO1xyXG5cdFx0dGhpcy5yZXF1ZXN0QnRuID0gJCgnI2FwaS1leHAtZ2V0LWJ0bicpO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogZ2V0IG5leHQgcGFnZVxyXG5cdCAqL1xyXG5cdGdldFByZXZQYWdlKCkge1xyXG5cdFx0bGV0IHBhZ2UgPSB0aGlzLnBhZ2U7XHJcblx0XHRjb25zdCB2YWwgPSBrby51bndyYXAocGFnZS5wYWdlUGFyYW0pO1xyXG5cdFx0cGFnZS5wYWdlUGFyYW0odmFsID4gMCA/IHZhbCAtIDEgOiAwKTtcclxuXHRcdHBhZ2Uuc2V0UGFyYW1zKHtcclxuXHRcdFx0Y2F0ZWdvcnk6IHBhZ2UuY2F0ZWdvcnksXHJcblx0XHRcdG1ldGhvZDogcGFnZS5tZXRob2QsXHJcblx0XHRcdG1ldGhvZElkOlx0cGFnZS5tZXRob2RJZCxcclxuXHRcdFx0cGFyYW1zOiBwYWdlLnBhcmFtc1xyXG5cdFx0fSk7XHJcblx0XHR0aGlzLnJlcXVlc3RCdG4udHJpZ2dlcignY2xpY2snKTtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIGdldCBwcmV2IHBhZ2VcclxuXHQgKi9cclxuXHRnZXROZXh0UGFnZSgpIHtcclxuXHRcdGxldCBwYWdlID0gdGhpcy5wYWdlO1xyXG5cdFx0Y29uc3QgdmFsID0ga28udW53cmFwKHRoaXMubnVtYmVyKTtcclxuXHRcdHBhZ2UucGFnZVBhcmFtKHZhbCA8IHRoaXMudG90YWxQYWdlcyAtIDEgPyB2YWwgICsgMTogdmFsKTtcclxuXHRcdHBhZ2Uuc2V0UGFyYW1zKHtcclxuXHRcdFx0Y2F0ZWdvcnk6IHBhZ2UuY2F0ZWdvcnksXHJcblx0XHRcdG1ldGhvZDogcGFnZS5tZXRob2QsXHJcblx0XHRcdG1ldGhvZElkOlx0cGFnZS5tZXRob2RJZCxcclxuXHRcdFx0cGFyYW1zOiBwYWdlLnBhcmFtc1xyXG5cdFx0fSk7XHJcblx0XHR0aGlzLnJlcXVlc3RCdG4udHJpZ2dlcignY2xpY2snKTtcclxuXHR9XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0ga28uY29tcG9uZW50cy5yZWdpc3RlcigncGFnaW5hdGlvbicsIHtcclxuXHR2aWV3TW9kZWw6IFBhZ2luYXRpb24sXHJcblx0dGVtcGxhdGU6XHJcblx0YDxzcGFuIGNsYXNzPVwibmF2aWdhdGlvbi13cmFwcGVyXCI+XHJcblx0XHQ8YnV0dG9uIGRhdGEtYmluZD1cImNsaWNrOiBnZXRQcmV2UGFnZSwgZW5hYmxlOiBmaXJzdFwiIHR5cGU9XCJidXR0b25cIiBjbGFzcz1cIm5hdmlnYXRpb24gcHJldlwiPjwvYnV0dG9uPlxyXG5cdFx0PGJ1dHRvbiBkYXRhLWJpbmQ9XCJjbGljazogZ2V0TmV4dFBhZ2UsIGVuYWJsZTogbGFzdFwiIHR5cGU9XCJidXR0b25cIiBjbGFzcz1cIm5hdmlnYXRpb24gbmV4dFwiPjwvYnV0dG9uPlxyXG5cdDwvc3Bhbj5gXHJcbn0pO1xyXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zY3JpcHRzL2FwaS1leHBsb3Jlci92Mi9zcmMvY29tcG9uZW50cy9wYW5lbHMvcGFnaW5hdGlvbi5jb21wb25lbnQuanMiLCJjbGFzcyBQYW5lbCB7XHJcblx0Y29uc3RydWN0b3IoeyRkYXRhID0ge30sIHBhbmVsR3JvdXAgPSB7fSwgJGluZGV4fSkge1xyXG5cdFx0dGhpcy4kZGF0YSA9ICRkYXRhO1xyXG5cdFx0dGhpcy5rZXkgPSAkZGF0YS5rZXk7XHJcblx0XHR0aGlzLiRpbmRleCA9IGtvLnVud3JhcCgkaW5kZXgpO1xyXG5cdFx0dGhpcy5wYW5lbEdyb3VwID0gcGFuZWxHcm91cDtcclxuXHRcdHRoaXMucGFnZSA9IHBhbmVsR3JvdXAucGFnZTtcclxuXHRcdHRoaXMuY29sb3JDbGFzcyA9IHBhbmVsR3JvdXAuY29sb3JDbGFzcyB8fCAnJztcclxuXHRcdHRoaXMuY29uZmlnID0gdGhpcy5jb25zdHJ1Y3Rvci5wYW5lbENvbmZpZyh7Y29uZmlnOiBwYW5lbEdyb3VwLmNvbmZpZywga2V5OiB0aGlzLmtleX0pO1xyXG5cdFx0dGhpcy5pc0V4cGFuZGVkID0gdGhpcy5jb25zdHJ1Y3Rvci5pc0V4cGFuZGVkKHRoaXMuY29uZmlnKTtcclxuXHRcdHRoaXMuY29sbGFwc2VJZCA9IHBhbmVsR3JvdXAuY29sbGFwc2VJZCArIHRoaXMuJGluZGV4O1xyXG5cdFx0dGhpcy5pc0FjdGl2ZSA9IGtvLm9ic2VydmFibGUodGhpcy5pc0V4cGFuZGVkKTtcclxuXHRcdHRoaXMuc3ViamVjdElEID0ga28ub2JzZXJ2YWJsZSgnJyk7XHJcblx0XHR0aGlzLmxhdCA9ICRkYXRhLnZhbHVlLmxhdGl0dWRlO1xyXG5cdFx0dGhpcy5sb25nID0gJGRhdGEudmFsdWUubG9uZ2l0dWRlO1xyXG5cdFx0dGhpcy5hZGRyZXNzID0gJGRhdGEudmFsdWUuYWRkcmVzcztcclxuXHR9XHJcblxyXG5cdHNldEFjdGl2ZShtb2RlbCwgZXZlbnQpIHtcclxuXHRcdHRoaXMuaXNBY3RpdmUoIXRoaXMuaXNBY3RpdmUoKSk7XHJcblx0fVxyXG5cdFxyXG5cdHNob3dNYXBQb3B1cCA9ICgpID0+IHtcclxuXHRcdGxldCBtYXAsIG1hcmtlciwgbWFwRWwgPSAkKCcjbWFwLXBvcHVwJyksXHJcblx0XHRcdGxhdCA9IHBhcnNlRmxvYXQodGhpcy5sYXQsIDEwKSxcclxuXHRcdFx0bG5nID0gcGFyc2VGbG9hdCh0aGlzLmxvbmcsIDEwKSxcclxuXHRcdFx0YWRkcmVzcyA9IHRoaXMuYWRkcmVzcyxcclxuXHRcdFx0Z2VvY29kZXIgPSBuZXcgZ29vZ2xlLm1hcHMuR2VvY29kZXIoKSxcclxuXHRcdFx0Y29vcmRpbmF0ZXMgPSBsYXQgJiYgbG5nID8ge2xhdCwgbG5nfSA6IG5ldyBnb29nbGUubWFwcy5MYXRMbmcoMCwgMCk7XHJcblx0XHRcclxuXHRcdC8vIGluaXRpYWxpemUgbWFwIG9iamVjdFxyXG5cdFx0bWFwID0gbmV3IGdvb2dsZS5tYXBzLk1hcChkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnbWFwJyksIHtcclxuXHRcdFx0Y2VudGVyOiBjb29yZGluYXRlcyxcclxuXHRcdFx0em9vbTogOFxyXG5cdFx0fSk7XHJcblx0XHRcclxuXHRcdGlmIChhZGRyZXNzKXsgLy8gaWYgdGhlcmUgd2FzIGFkZHJlc3MgcHJvdmlkZWRcclxuXHRcdFx0Z2VvY29kZUFkZHJlc3MoZ2VvY29kZXIsIG1hcCwgYWRkcmVzcywgcmVzdWx0ID0+IHsgLy8gZ2VvY29kZSBhZGRyZXNzIGFuZCBjZW50ZXIgdGhlIG1hcFxyXG5cdFx0XHRcdGNvb3JkaW5hdGVzID0gcmVzdWx0O1xyXG5cdFx0XHR9KTtcclxuXHRcdH0gZWxzZSB7IC8vIGlmIG5vdCAobWVhbnMgbGF0IGFuZCBsb25nIHdlcmUgcHJvdmlkZWQpXHJcblx0XHRcdG1hcmtlciA9IG5ldyBnb29nbGUubWFwcy5NYXJrZXIoeyAvL0NyZWF0ZSBhIG1hcmtlciBhbmQgc2V0IGl0cyBwb3NpdGlvbi5cclxuXHRcdFx0XHRwb3NpdGlvbjogY29vcmRpbmF0ZXMsXHJcblx0XHRcdFx0bWFwXHJcblx0XHRcdH0pO1xyXG5cdFx0fVxyXG5cdFx0Ly8gd2hlbiBtYXAgcG9wdXAgaXMgc2hvd25cclxuXHRcdG1hcEVsLm9uKFwic2hvd24uYnMubW9kYWxcIiwgZSA9PiB7XHJcblx0XHRcdGdvb2dsZS5tYXBzLmV2ZW50LnRyaWdnZXIobWFwLCBcInJlc2l6ZVwiKTtcclxuXHRcdFx0Ly8gUmVjZW50ZXIgdGhlIG1hcCBub3cgdGhhdCBpdCdzIGJlZW4gcmVkcmF3blxyXG5cdFx0XHRtYXAuc2V0Q2VudGVyKGNvb3JkaW5hdGVzKTtcclxuXHRcdH0pO1xyXG5cdFx0bWFwRWwubW9kYWwoKTsgLy8gc2hvdyBtYXAgcG9wdXBcclxuXHR9O1xyXG5cdFxyXG5cdC8qKlxyXG5cdCAqIEdldHMgY29uZmlnIGZvciBlYWNoIHBhbmVsXHJcblx0ICogQHBhcmFtIGNvbmZpZ1xyXG5cdCAqIEBwYXJhbSBrZXlcclxuXHQgKiBAcmV0dXJucyB7Knx7fX1cclxuXHQgKi9cclxuXHRzdGF0aWMgcGFuZWxDb25maWcoe2NvbmZpZywga2V5fSkge1xyXG5cdFx0bGV0IHN1YkNvbmZpZyA9IGNvbmZpZ1trZXldIHx8IHt9O1xyXG5cclxuXHRcdHN1YkNvbmZpZy5fQ09ORklHID0gJC5leHRlbmQodHJ1ZSwge30sIGNvbmZpZy5fQ09ORklHLCBzdWJDb25maWcuX0NPTkZJRyk7XHJcblx0XHRyZXR1cm4gc3ViQ29uZmlnO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogQ2hlY2tzIGZvciAnZXhwYW5kZWQnIGNvbmZpZyBmb3IgZWFjaCBwYW5lbFxyXG5cdCAqIEBwYXJhbSBjb25maWdcclxuXHQgKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuXHQgKi9cclxuXHRzdGF0aWMgaXNFeHBhbmRlZChjb25maWcpIHtcclxuXHRcdHJldHVybiAhKE9iamVjdC5nZXRQcm9wKGNvbmZpZywgJy5fQ09ORklHLmNvbGxhcHNlZCcpIHx8IGZhbHNlKTtcclxuXHR9XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0ga28uY29tcG9uZW50cy5yZWdpc3RlcigncGFuZWwnLCB7XHJcblx0dmlld01vZGVsOiBQYW5lbCxcclxuXHR0ZW1wbGF0ZTpgXHJcblx0XHQ8c2VjdGlvbiBkYXRhLWJpbmQ9XCJjc3M6IHtbY29sb3JDbGFzc106IHRydWUsIGFjdGl2ZTogaXNBY3RpdmV9XCIgY2xhc3M9XCJwYW5lbCBwYW5lbC1wcmltYXJ5XCI+XHJcblx0XHRcdDwhLS1wYW5lbC1oZWFkaW5nLS0+XHJcblx0XHRcdDxwYW5lbC1oZWFkaW5nIHBhcmFtcz1cIlxyXG5cdFx0XHRcdHNob3dNYXBQb3B1cDogc2hvd01hcFBvcHVwLFxyXG5cdFx0XHRcdHBhbmVsR3JvdXA6IHBhbmVsR3JvdXAsXHJcblx0XHRcdFx0Y29uZmlnOiBjb25maWcsXHJcblx0XHRcdFx0ZGF0YTogJGRhdGEsXHJcblx0XHRcdFx0aW5kZXg6ICRpbmRleCxcclxuXHRcdFx0XHRwYWdlOiBwYWdlLFxyXG5cdFx0XHRcdHNldEFjdGl2ZTogc2V0QWN0aXZlLmJpbmQoJGNvbXBvbmVudCksXHJcblx0XHRcdFx0Y29sbGFwc2VJZDogY29sbGFwc2VJZCxcclxuXHRcdFx0XHRjb2xvckNsYXNzOiBjb2xvckNsYXNzLFxyXG5cdFx0XHRcdGlzRXhwYW5kZWQ6IGlzRXhwYW5kZWQsXHJcblx0XHRcdFx0c3ViamVjdElEOnN1YmplY3RJRFxyXG5cdFx0XHRcIj48L3BhbmVsLWhlYWRpbmc+XHJcblx0XHRcdFxyXG5cdFx0XHQ8IS0tcGFuZWwtYm9keS0tPlxyXG5cdFx0XHQ8c2VjdGlvbiBkYXRhLWJpbmQ9XCJhdHRyOiB7J2lkJzogY29sbGFwc2VJZH0sIGNzczogeydpbic6IGlzRXhwYW5kZWR9XCIgY2xhc3M9XCJwYW5lbC1jb2xsYXBzZSBjb2xsYXBzZVwiPlx0XHRcdFx0XHJcblx0XHRcdFx0PCEtLWtvIGlmOiBrZXkgPT09ICdsb2NhdGlvbicgLS0+XHJcblx0XHRcdFx0XHQ8bWFwLXBhbmVsLWJvZHkgcGFyYW1zPVwibGF0OiBsYXQsIGxvbmc6IGxvbmcsIGFkZHJlc3M6IGFkZHJlc3MsIHNob3dNYXBQb3B1cDogc2hvd01hcFBvcHVwXCI+PC9tYXAtcGFuZWwtYm9keT5cclxuXHRcdFx0XHQ8IS0tIC9rbyAtLT5cclxuXHRcdFx0XHQ8IS0tIGtvIGlmOiAodHlwZW9mICRkYXRhLnZhbHVlID09PSAnb2JqZWN0JyAmJiAhJC5pc0FycmF5KCRkYXRhLnZhbHVlKSkgLS0+XHJcblx0XHRcdFx0XHQ8b2JqZWN0LXBhbmVsLWJvZHkgcGFyYW1zPVwiY29uZmlnOiBjb25maWcsIGRhdGE6ICRkYXRhLCBpbmRleDogJGluZGV4LCBwYW5lbEdyb3VwOiBwYW5lbEdyb3VwLCBwYWdlOiBwYWdlLCBjb2xsYXBzZUlkOiBjb2xsYXBzZUlkLCBzdWJqZWN0SUQ6IHN1YmplY3RJRFwiPjwvb2JqZWN0LXBhbmVsLWJvZHk+XHJcblx0XHRcdFx0PCEtLSAva28gLS0+XHJcblx0XHRcdFx0PCEtLSBrbyBpZjogKHR5cGVvZiAkZGF0YS52YWx1ZSA9PT0gJ29iamVjdCcgJiYgJC5pc0FycmF5KCRkYXRhLnZhbHVlKSkgLS0+XHJcblx0XHRcdFx0XHQ8YXJyYXktcGFuZWwtYm9keSBwYXJhbXM9XCJjb25maWc6IGNvbmZpZywgZGF0YTogJGRhdGEsIGluZGV4OiAkaW5kZXgsIHBhbmVsR3JvdXA6IHBhbmVsR3JvdXBcIj48L2FycmF5LXBhbmVsLWJvZHk+XHJcblx0XHRcdFx0PCEtLSAva28gLS0+XHJcblx0XHRcdDwvc2VjdGlvbj5cclxuXHRcdDwvc2VjdGlvbj5cclxuYH0pO1xyXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zY3JpcHRzL2FwaS1leHBsb3Jlci92Mi9zcmMvY29tcG9uZW50cy9wYW5lbHMvcGFuZWwuY29tcG9uZW50LmpzIiwidmFyIHNlbGY7XHJcblxyXG5jbGFzcyBDYXJkR3JvdXAge1xyXG5cdGNvbnN0cnVjdG9yKHBhcmFtcykge1xyXG5cdFx0c2VsZiA9IHRoaXM7XHJcblx0XHR0aGlzLmNvbmZpZyA9IHRoaXMuY29uc3RydWN0b3IuZ2V0Q29uZmlnKHBhcmFtcyk7XHJcblx0XHR0aGlzLmRhdGEgPSB0aGlzLnByZXBhcmVEYXRhKHtwYXJhbXMsIGNvbmZpZzogdGhpcy5jb25maWcuX0NPTkZJR30pO1xyXG5cdFx0dGhpcy5ncm91cEluZGV4ID0gcGFyYW1zLmdyb3VwSW5kZXggfHwgMDtcclxuXHRcdHRoaXMuc2VjdGlvbkluZGV4ID0ga28udW53cmFwKHBhcmFtcy5zZWN0aW9uSW5kZXgpO1xyXG5cdFx0dGhpcy5jb2xvckNsYXNzID0gcGFyYW1zLmNvbG9yQ2xhc3M7XHJcblx0XHR0aGlzLmdldE1vcmUgPSBwYXJhbXMuZ2V0TW9yZTtcclxuXHRcdHRoaXMucGFnZSA9IHRoaXMuY29uc3RydWN0b3IuZ2V0UGFnaW5nSW5mbyhwYXJhbXMsIHRoaXMuZGF0YS5wYWdlKTtcclxuXHRcdHRoaXMuY29sbGFwc2VJZCA9IHRoaXMuY29uc3RydWN0b3IuZ2V0Q29sbGFwc2VJZCgpO1xyXG5cdFx0dGhpcy5faGFzRXZlbnRzUGFuZWwgPSBmYWxzZTtcclxuXHR9XHJcblxyXG5cdHNvcnRCeUNvbmZpZyhhLCBiKSB7XHJcblx0XHRpZiAodGhpcy5jb25maWcgJiYgdGhpcy5jb25maWdbYS5rZXldICYmIHRoaXMuY29uZmlnW2Iua2V5XSAmJiB0aGlzLmNvbmZpZ1thLmtleV0uX0NPTkZJRyAmJiB0aGlzLmNvbmZpZ1tiLmtleV0uX0NPTkZJRykge1xyXG5cdFx0XHR2YXIgaTEgPSB0aGlzLmNvbmZpZ1thLmtleV0uX0NPTkZJRy5pbmRleDtcclxuXHRcdFx0dmFyIGkyID0gdGhpcy5jb25maWdbYi5rZXldLl9DT05GSUcuaW5kZXg7XHJcblx0XHRcdHJldHVybiBpMSAtIGkyO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIDA7XHJcblx0fVxyXG5cclxuXHRjaGVja0lmSGFzRXZlbnRzTGlzdChrZXkpIHtcclxuXHRcdHJldHVybiBzZWxmLl9oYXNFdmVudHNQYW5lbCA9IGtleSA9PT0gJ2V2ZW50cycgfHwgc2VsZi5faGFzRXZlbnRzUGFuZWw7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBDb25maWd1cmVzIGFuZCBwYXJhbXMgZm9yIGVhY2ggcGFuZWwgZ3JvdXBcclxuXHQgKi9cclxuXHRzdGF0aWMgZ2V0Q29uZmlnKHtkZWVwUHJvcCA9ICcnLCBjb25maWcsIGZpbHRlciwgbWV0aG9kSWR9KSB7XHJcblx0XHRzZWxmLmRlZXBQcm9wID0gZGVlcFByb3A7XHJcblx0XHQvLyBtYWluIGNvbmZpZ1xyXG5cdFx0aWYgKCFzZWxmLmRlZXBQcm9wICYmICFjb25maWcpIHtcclxuXHRcdFx0Ly8gcGFuZWxHcm91cCBpbmRleCAtIDBcclxuXHJcblx0XHRcdC8vIGdldCBmdWxsIGNvbmZpZztcclxuXHRcdFx0bGV0IHJhd0ZpbHRlciA9IGtvLnVud3JhcChmaWx0ZXIpO1xyXG5cclxuXHRcdFx0Ly8gZ2V0IGN1cnJlbnQgbWV0aG9kIGNvbmZpZ1xyXG5cdFx0XHRsZXQgbWV0aG9kQ29uZmlnID0gcmF3RmlsdGVyW21ldGhvZElkXSB8fCB7fTtcclxuXHJcblx0XHRcdC8vIG1ldGhvZCBjb25maWcgaW5oZXJpdHMgZ2xvYmFsIGNvbmZpZ1xyXG5cdFx0XHRtZXRob2RDb25maWcuX0NPTkZJRyAgPSAkLmV4dGVuZCh0cnVlLCB7fSwgcmF3RmlsdGVyLl9HTE9CQUxfQ09ORklHLCBtZXRob2RDb25maWcuX0NPTkZJRyk7XHJcblxyXG5cdFx0XHRyZXR1cm4gbWV0aG9kQ29uZmlnO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0Ly8gcGFuZWxHcm91cCBpbmRleCA+IDBcclxuXHRcdFx0cmV0dXJuIGNvbmZpZyB8fCB7fVxyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogRGF0YSBtYW5pcHVsYXRpb25zXHJcblx0ICovXHJcblx0cHJlcGFyZURhdGEoe3BhcmFtcyA9IHt9LCBjb25maWcgPSB0aGlzLmNvbmZpZy5fQ09ORklHfSkge1xyXG5cdFx0bGV0IGRhdGEgPSAkLmV4dGVuZCh0cnVlLCB7fSwgcGFyYW1zLmRhdGEpIHx8IHt9O1xyXG5cdFx0dGhpcy51bndyYXBwT2JqZWN0cyhkYXRhLCBjb25maWcpO1xyXG5cdFx0dGhpcy5yZW1vdmVEZXByZWNhdGVkKGRhdGEsIGNvbmZpZyk7XHJcblx0XHRyZXR1cm4gdGhpcy53cmFwcFByaW1pdGl2ZXMoe2RhdGEsIF9wcm9wVGl0bGU6IHBhcmFtcy5fcHJvcFRpdGxlfSk7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBHYXRoZXJzIGFsbCBzdGFuZCBhbG9uZSBwcm9wcyBpbiB0byBvbmUgb2JqZWN0XHJcblx0ICogQHBhcmFtIGRhdGEge29iamVjdH1cclxuXHQgKiBAcGFyYW0gX3Byb3BUaXRsZSB7c3RyaW5nfVxyXG5cdCAqIEByZXR1cm5zIHtvYmplY3R9IHJldmlzZWQgZGF0YVxyXG5cdCAqL1xyXG5cdHdyYXBwUHJpbWl0aXZlcyh7ZGF0YSwgX3Byb3BUaXRsZSA9ICdvYmplY3QnfSkge1xyXG5cdFx0bGV0IG5ld0RhdGEgPSB7fSwgdmFsO1xyXG5cclxuXHRcdC8vIGdhdGhlcmluZyBhbGwgcHJpbWl0aXZlIHByb3BzIGluIGFkZGl0aW9uYWwgcGFuZWxcclxuXHRcdGZvciAobGV0IGtleSBpbiBkYXRhKSB7XHJcblx0XHRcdGlmICghZGF0YS5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7Y29udGludWU7fVxyXG5cdFx0XHR2YWwgPSBkYXRhW2tleV07XHJcblxyXG5cdFx0XHRpZiAodHlwZW9mIHZhbCAhPT0gJ29iamVjdCcpIHtcclxuXHRcdFx0XHRuZXdEYXRhW19wcm9wVGl0bGVdID0gbmV3RGF0YVtfcHJvcFRpdGxlXSB8fCB7fTtcclxuXHRcdFx0XHRuZXdEYXRhW19wcm9wVGl0bGVdW2tleV0gPSB2YWw7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0bmV3RGF0YVtrZXldID0gdmFsO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIG5ld0RhdGFcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFVud3JhcHMgb2JqZWN0c1xyXG5cdCAqL1xyXG5cdHJlbW92ZURlcHJlY2F0ZWQob2JqLCBjb25maWcgPSB7fSkge1xyXG5cdFx0dmFyIGRlcHJlY2F0ZWQgPSBjb25maWcuZGVwcmVjYXRlZCB8fCBbXTtcclxuXHJcblx0XHRkZXByZWNhdGVkLm1hcChpdGVtID0+IHtcclxuXHRcdFx0aWYgKG9ialtpdGVtXSkge1xyXG5cdFx0XHRcdGRlbGV0ZSBvYmpbaXRlbV1cclxuXHRcdFx0fVxyXG5cdFx0XHRyZXR1cm4gaXRlbTtcclxuXHRcdH0pO1xyXG5cclxuXHRcdHJldHVybiBvYmo7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBSZW1vdmVzIGRlcHJlY2F0ZWQgb2JqZWN0c1xyXG5cdCAqL1xyXG5cdHVud3JhcHBPYmplY3RzKG9iaiwgY29uZmlnID0ge30pIHtcclxuXHRcdHZhciB1bndyYXBwID0gY29uZmlnLnVud3JhcHAgfHwgW107XHJcblxyXG5cdFx0dW53cmFwcC5tYXAoaXRlbSA9PiB7XHJcblx0XHRcdHZhciB2YWwgPSBvYmpbaXRlbV07XHJcblx0XHRcdGlmICh2YWwpIHtcclxuXHRcdFx0XHR2YXIgYXJyID0gT2JqZWN0LmtleXModmFsKTtcclxuXHRcdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHRcdFx0dmFyIHByb3AgPSBhcnJbaV07XHJcblx0XHRcdFx0XHRvYmpbcHJvcF0gPSB2YWxbcHJvcF07XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGRlbGV0ZSBvYmpbaXRlbV07XHJcblx0XHRcdH1cclxuXHRcdFx0cmV0dXJuIGl0ZW07XHJcblx0XHR9KTtcclxuXHJcblx0XHRyZXR1cm4gb2JqO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogUHJlcGFyZXMgZGF0YSBmb3IgcGFnaW5nXHJcblx0ICovXHJcblx0c3RhdGljIGdldFBhZ2luZ0luZm8ocGFyYW1zLCBwYWdlT2JqKSB7XHJcblx0XHRsZXQgcGFnZVBhcmFtLCBzaXplO1xyXG5cclxuXHRcdGlmIChwYWdlT2JqICYmIChwYXJhbXMucGFnZVBhcmFtIHx8IHBhcmFtcy5wYXJhbXMpKSB7IC8vdGVtcG9yYXJ5IHNvbHV0aW9uIHRvZG86IG5lZWQgdG8gYmUgcmV2aXNlZCBhbmQgcmVmYWN0b3JlZFxyXG5cdFx0XHRzaXplID0gcGFyYW1zLmNhcmRTaXplIHx8IHBhZ2VPYmouc2l6ZTtcclxuXHRcdFx0cGFnZVBhcmFtID0gcGFyYW1zLnBhZ2VQYXJhbSB8fCBwYXJhbXMucGFyYW1zLmZpbmQoaXRlbSA9PiBpdGVtLm5hbWUgPT09ICdwYWdlJyk7XHJcblxyXG5cdFx0XHRyZXR1cm4ge1xyXG5cdFx0XHRcdGNhdGVnb3J5OiBwYXJhbXMuY2F0ZWdvcnksXHJcblx0XHRcdFx0bWV0aG9kOiBwYXJhbXMubWV0aG9kLFxyXG5cdFx0XHRcdG1ldGhvZElkOiBwYXJhbXMubWV0aG9kSWQsXHJcblx0XHRcdFx0cGFyYW1zOiBwYXJhbXMucGFyYW1zLFxyXG5cdFx0XHRcdHBhZ2VQYXJhbTogcGFnZVBhcmFtICYmIHBhZ2VQYXJhbS52YWx1ZSxcclxuXHRcdFx0XHRzZXRQYXJhbXM6IHBhcmFtcy5zZXRQYXJhbXMsXHJcblx0XHRcdFx0c2l6ZTogc2l6ZVxyXG5cdFx0XHR9O1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIG51bGw7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBQcm92aWRlcyBpZCBzdHIgZm9yIHBhbmVsICdjb2xsYXBzZSB0b2dnbGUnIGxvZ2ljXHJcblx0ICogQHBhcmFtIHN0clxyXG5cdCAqIEByZXR1cm5zIHtzdHJpbmd9XHJcblx0ICovXHJcblx0c3RhdGljIGdldENvbGxhcHNlSWQoKSB7XHJcblx0XHRyZXR1cm4gYGNhcmQtcGFuZWwtYm9keS0ke3NlbGYuc2VjdGlvbkluZGV4fSR7c2VsZi5ncm91cEluZGV4fWBcclxuXHR9XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0ga28uY29tcG9uZW50cy5yZWdpc3RlcigncGFuZWwtZ3JvdXAnLCB7XHJcblx0dmlld01vZGVsOiBDYXJkR3JvdXAsXHJcblx0dGVtcGxhdGU6YFxyXG5cdFx0PHNlY3Rpb24gZGF0YS1iaW5kPVwiZm9yZWFjaHByb3A6IHtkYXRhOiBkYXRhLCBzb3J0Rm46IHNvcnRCeUNvbmZpZy5iaW5kKCRjb21wb25lbnQpfVwiIGNsYXNzPVwicGFuZWwtZ3JvdXBcIj5cclxuXHRcdFx0PCEtLXBhbmVsLS0+XHJcblx0XHRcdDxwYW5lbCBjbGFzcz1cInBhbmVsLWl0ZW1cIiBkYXRhLWJpbmQ9XCJjc3M6IHsnaGFzLWV2ZW50cy1saXN0JzogJGNvbXBvbmVudC5jaGVja0lmSGFzRXZlbnRzTGlzdChrZXkpfVwiXHJcblx0XHRcdFx0XHRcdFx0cGFyYW1zPVwiJGRhdGE6ICRkYXRhLFxyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0JGluZGV4OiAkaW5kZXgsXHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRwYW5lbEdyb3VwOiAkY29tcG9uZW50LFxyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0c29ydEJ5Q29uZmlnOiAkY29tcG9uZW50LnNvcnRCeUNvbmZpZ1wiPlxyXG5cdFx0XHQ8L3BhbmVsPlxyXG5cdFx0PC9zZWN0aW9uPlxyXG5gfSk7XHJcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NjcmlwdHMvYXBpLWV4cGxvcmVyL3YyL3NyYy9jb21wb25lbnRzL3BhbmVscy9wYW5lbEdyb3VwLmNvbXBvbmVudC5qcyIsImltcG9ydCB7Y29sb3JzU2VydmljZX0gZnJvbSAnLi4vLi4vc2VydmljZXMnO1xyXG5cclxuY2xhc3MgUGFuZWxIZWFkaW5nIHtcclxuXHRjb25zdHJ1Y3Rvcih7Y29uZmlnID0ge30sIGRhdGEgPSB7fSwgc2hvd01hcFBvcHVwID0gbnVsbCwgc2V0QWN0aXZlLCBpc0V4cGFuZGVkLCBwYWdlLCBjb2xsYXBzZUlkLCBjb2xvckNsYXNzLCBwYW5lbEdyb3VwLCBzdWJqZWN0SUR9KSB7XHJcblx0XHR0aGlzLmNvbmZpZyA9IGNvbmZpZy5fQ09ORklHO1xyXG5cdFx0dGhpcy5zZXRBY3RpdmUgPSBzZXRBY3RpdmU7XHJcblx0XHR0aGlzLmlzRXhwYW5kZWQgPSBpc0V4cGFuZGVkO1xyXG5cdFx0dGhpcy5fcGFuZWxOYW1lID0gZGF0YS5rZXk7XHJcblx0XHR0aGlzLnRpdGxlID0gdGhpcy5jb25maWcgJiYgdGhpcy5jb25maWcudGl0bGUgfHwgdGhpcy5fcGFuZWxOYW1lO1xyXG5cdFx0dGhpcy5kYXRhID0gZGF0YS52YWx1ZTtcclxuXHRcdHRoaXMuY29sbGFwc2VJZCA9IGNvbGxhcHNlSWQ7XHJcblx0XHR0aGlzLnBhZ2UgPSBwYWdlO1xyXG5cdFx0dGhpcy5wYW5lbEdyb3VwID0gcGFuZWxHcm91cDtcclxuXHRcdHRoaXMuc3ViamVjdElkID0gc3ViamVjdElEO1xyXG5cdFx0dGhpcy5zaG93TWFwUG9wdXAgPSBzaG93TWFwUG9wdXA7XHJcblx0XHR0aGlzLmluaXQoe3BhZ2UsIGNvbG9yQ2xhc3N9KTtcclxuXHR9XHJcblxyXG5cdGluaXQoe3BhZ2UsIGNvbG9yQ2xhc3N9KSB7XHJcblx0XHRpZiAocGFnZSkge1xyXG5cdFx0XHR0aGlzLmNhcmRTaXplID0gcGFnZS5zaXplO1xyXG5cdFx0fVxyXG5cdFx0aWYgKHRoaXMuY29uZmlnLnJlcXVlc3QpIHtcclxuXHRcdFx0dGhpcy5hbm90aGVyUmVxdWVzdENvbG9yID0gY29sb3JzU2VydmljZS5nZXRSYW5kb21Db2xvcihjb2xvckNsYXNzKTtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdGZvbGxvd1JlcXVlc3QodmFsdWUpIHtcclxuXHRcdGxldCB1cmwgPSBPYmplY3QuZ2V0UHJvcCh2YWx1ZSwgJy5jb25maWcucmVxdWVzdCcpO1xyXG5cdFx0aWYgKHVybCkge1xyXG5cdFx0XHRsZXQgbWV0aG9kID0ge307XHJcblx0XHRcdHVybCA9IHVybC5zcGxpdChuZXcgUmVnRXhwKCdodHRwczovL2FwcC50aWNrZXRtYXN0ZXIuY29tLycpKVsxXTtcclxuXHRcdFx0UGFuZWxIZWFkaW5nLmdldERlZXBQcm9wKHVybCwgYmFzZSwgbWV0aG9kKTtcclxuXHRcdFx0bWV0aG9kID0gbWV0aG9kLm9iamVjdDtcclxuXHJcblx0XHRcdG1ldGhvZC5wYXJhbWV0ZXJzID0gT2JqZWN0LmtleXMobWV0aG9kLnBhcmFtZXRlcnMpLm1hcChrZXkgPT4ge1xyXG5cdFx0XHRcdGxldCBwYXJhbSA9IG1ldGhvZC5wYXJhbWV0ZXJzW2tleV07XHJcblx0XHRcdFx0aWYgKHBhcmFtLm5hbWUgPT09ICdpZCcpIHtcclxuXHRcdFx0XHRcdHBhcmFtLnZhbHVlID0ga28udW53cmFwKHRoaXMuc3ViamVjdElkKTtcclxuXHRcdFx0XHR9IGVsc2UgaWYgKHBhcmFtLm5hbWUgPT09ICdmb3JtYXQnKSB7XHJcblx0XHRcdFx0XHRwYXJhbS52YWx1ZSA9ICdqc29uJ1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRyZXR1cm4gcGFyYW07XHJcblx0XHRcdH0pO1xyXG5cclxuXHJcblx0XHRcdHRoaXMuYW5vdGhlclJlcXVlc3QgPSBrby5vYnNlcnZhYmxlKHt1cmwsIG1ldGhvZCwgcGFuZWxHcm91cDogdGhpcy5wYW5lbEdyb3VwLCBjb2xvcjogdGhpcy5hbm90aGVyUmVxdWVzdENvbG9yfSkucHVibGlzaE9uKCdBTk9USEVSX1JFUVVFU1QnKTtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdGdldCBoYXNBbm90aGVyUmVxdWVzdCgpIHtcclxuXHRcdHJldHVybiAhIXRoaXMuY29uZmlnLnJlcXVlc3Q7XHJcblx0fVxyXG5cclxuXHRzdGF0aWMgZ2V0RGVlcFByb3AodmFsLCBvYmosIHJlc3VsdCkge1xyXG5cdFx0aWYgKHR5cGVvZiBvYmogIT09ICdvYmplY3QnKSByZXR1cm47XHJcblxyXG5cdFx0Zm9yIChsZXQgcHJvcCBpbiBvYmopIHtcclxuXHRcdFx0aWYgKG9iai5oYXNPd25Qcm9wZXJ0eShwcm9wKSAmJiB0eXBlb2Ygb2JqW3Byb3BdID09PSAnb2JqZWN0JyAmJiAhcmVzdWx0Lmxlbmd0aCkge1xyXG5cdFx0XHRcdGlmIChvYmpbcHJvcF0ucGF0aCA9PT0gdmFsKSB7XHJcblx0XHRcdFx0XHRyZXN1bHQub2JqZWN0ID0gb2JqW3Byb3BdO1xyXG5cdFx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdFBhbmVsSGVhZGluZy5nZXREZWVwUHJvcCh2YWwsIG9ialtwcm9wXSwgcmVzdWx0KTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9XHJcbn1cclxuXHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGtvLmNvbXBvbmVudHMucmVnaXN0ZXIoJ3BhbmVsLWhlYWRpbmcnLCB7XHJcblx0dmlld01vZGVsOiAgUGFuZWxIZWFkaW5nLFxyXG5cdHRlbXBsYXRlOmBcclxuXHRcdDxzZWN0aW9uIGNsYXNzPVwicGFuZWwtaGVhZGluZ1wiPlxyXG5cdFx0XHQ8ZGl2IGNsYXNzPVwicGFuZWwtdGl0bGVcIj5cclxuXHRcdFx0XHRcclxuXHRcdFx0XHQ8YSBkYXRhLWJpbmQ9XCJjbGljazogc2V0QWN0aXZlLCBhdHRyOiB7aHJlZjogJyMnICsgY29sbGFwc2VJZCwgJ2FyaWEtY29udHJvbHMnOiBjb2xsYXBzZUlkLCAnYXJpYS1leHBhbmRlZCc6IGlzRXhwYW5kZWR9XCIgY2xhc3M9XCJidG4gYnRuLWljb24gYnRuLXRpdGxlXCIgdHlwZT1cImJ1dHRvblwiIGRhdGEtdG9nZ2xlPVwiY29sbGFwc2VcIiBhcmlhLWV4cGFuZGVkPVwiZmFsc2VcIj5cclxuXHRcdFx0XHRcdDxzcGFuIGNsYXNzPVwiYnRuIGJ0bi1pY29uIHNoZXZyb24gd2hpdGUtc2hldnJvbi11cFwiPjwvc3Bhbj5cclxuXHRcdFx0XHRcdDxwIGRhdGEtYmluZD1cInRleHQ6IHRpdGxlXCIgY2xhc3M9XCJ0aXRsZVwiPlBhbmVsIHRpdGxlPC9wPlxyXG5cdFx0XHRcdDwvYT5cclxuXHRcdFx0XHRcclxuXHRcdFx0XHQ8IS0tIGtvIGlmOiBfcGFuZWxOYW1lID09PSAnZXZlbnRzJy0tPlxyXG5cdFx0XHRcdFx0PHNwYW4gZGF0YS1iaW5kPVwidGV4dDogY2FyZFNpemVcIiBjbGFzcz1cImNvdW50ZXJcIj48L3NwYW4+XHJcblx0XHRcdFx0PCEtLSAva28tLT5cclxuXHRcdFx0XHRcclxuXHRcdFx0XHQ8IS0tIGtvIGlmOiBfcGFuZWxOYW1lID09PSAncGFnZSctLT5cclxuXHRcdFx0XHRcdDxwYWdpbmF0aW9uIHBhcmFtcz1cIm51bWJlcjogZGF0YS5udW1iZXIsIHRvdGFsUGFnZXM6IGRhdGEudG90YWxQYWdlcywgcGFnZTogcGFnZVwiPjwvcGFnaW5hdGlvbj5cclxuXHRcdFx0XHQ8IS0tIC9rby0tPlxyXG5cdFx0XHRcdFxyXG5cdFx0XHRcdDwhLS0ga28gaWY6IGhhc0Fub3RoZXJSZXF1ZXN0IC0tPlxyXG5cdFx0XHRcdDxzZWN0aW9uIGNsYXNzPVwiZm9sbG93LXJlcXVlc3RcIj5cclxuXHRcdFx0XHRcdDxzcGFuIGRhdGEtYmluZD1cImNzczogYW5vdGhlclJlcXVlc3RDb2xvclwiIGNsYXNzPVwiY29sb3ItaW5kaWNhdG9yXCI+PC9zcGFuPlxyXG5cdFx0XHRcdFx0PGJ1dHRvbiBkYXRhLWJpbmQ9XCJjbGljazogZm9sbG93UmVxdWVzdFwiIGNsYXNzPVwiYnRuIGJ0bi1yZXF1ZXN0XCIgdHlwZT1cImJ1dHRvblwiPmFub3RoZXIgcmVxdWVzdDwvYnV0dG9uPlxyXG5cdFx0XHRcdDwvc2VjdGlvbj5cclxuXHRcdFx0XHQ8IS0tIC9rby0tPlxyXG5cdFx0XHRcdFxyXG5cdFx0XHRcdDwhLS0ga28gaWY6IF9wYW5lbE5hbWUgPT09ICdsb2NhdGlvbicgLS0+XHJcblx0XHRcdFx0PHNlY3Rpb24gY2xhc3M9XCJmb2xsb3ctcmVxdWVzdFwiPlxyXG5cdFx0XHRcdFx0PGJ1dHRvbiBjbGFzcz1cImFwaS1tYXAtYnRuXCIgZGF0YS1iaW5kPVwiY2xpY2s6IHNob3dNYXBQb3B1cFwiPjwvYnV0dG9uPlxyXG5cdFx0XHRcdDwvc2VjdGlvbj5cclxuXHRcdFx0XHQ8IS0tIC9rby0tPlxyXG5cdFx0XHQ8L2Rpdj5cclxuXHRcdDwvc2VjdGlvbj5cclxuYH0pO1xyXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zY3JpcHRzL2FwaS1leHBsb3Jlci92Mi9zcmMvY29tcG9uZW50cy9wYW5lbHMvcGFuZWxIZWFkaW5nLmNvbXBvbmVudC5qcyIsImNsYXNzIEVycm9yUG9wVXAge1xyXG5cdGNvbnN0cnVjdG9yKCkge1xyXG5cdFx0dGhpcy5zdGF0dXMgPSBrby5vYnNlcnZhYmxlKCcnKTtcclxuXHRcdHRoaXMuc3RhdHVzVGV4dCA9IGtvLm9ic2VydmFibGUoJycpO1xyXG5cdFx0dGhpcy5kZXRhaWxzID0ga28ub2JzZXJ2YWJsZShgYCk7XHJcblxyXG5cdFx0a28ucG9zdGJveC5zdWJzY3JpYmUoJ1JFUVVFU1RfRVJST1InLCBlcnJvck9iaiA9PiB7XHJcblx0XHRcdHRoaXMuc3RhdHVzKE9iamVjdC5nZXRQcm9wKGVycm9yT2JqLCAnLnJlc3BvbnNlSlNPTi5lcnJvcnNbMF0uc3RhdHVzJykgfHwgZXJyb3JPYmouc3RhdHVzIHx8ICd1bmtub3duJyk7XHJcblx0XHRcdHRoaXMuc3RhdHVzVGV4dChPYmplY3QuZ2V0UHJvcChlcnJvck9iaiwgJy5yZXNwb25zZUpTT04uZXJyb3JzWzBdLnN0YXR1c1RleHQnKSB8fCBlcnJvck9iai5zdGF0dXNUZXh0IHx8ICcnKTtcclxuXHRcdFx0dGhpcy5kZXRhaWxzKE9iamVjdC5nZXRQcm9wKGVycm9yT2JqLCAnLnJlc3BvbnNlSlNPTi5lcnJvcnNbMF0uZGV0YWlsJykgfHwgJ3Vua25vd24nKTtcclxuXHRcdFx0dGhpcy50b2dnbGVQb3BVcCgpO1xyXG5cdFx0fSlcclxuXHR9XHJcblx0dG9nZ2xlUG9wVXAoKSB7XHJcblx0XHQkKCcjZXJyb3ItbW9kYWwnKS5tb2RhbCgnc2hvdycpO1xyXG5cdH1cclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBrby5jb21wb25lbnRzLnJlZ2lzdGVyKCdlcnJvci1wb3AtdXAnLCB7XHJcblx0dmlld01vZGVsOiBFcnJvclBvcFVwLFxyXG5cdHRlbXBsYXRlOmBcclxuXHRcdDxzZWN0aW9uIGlkPVwiZXJyb3ItbW9kYWxcIiBjbGFzcz1cIm1vZGFsIGZhZGVcIiB0YWJpbmRleD1cIi0xXCIgcm9sZT1cImRpYWxvZ1wiPlxyXG5cdFx0XHQ8ZGl2IGNsYXNzPVwibW9kYWwtZGlhbG9nXCIgcm9sZT1cImRvY3VtZW50XCI+XHJcblx0XHRcdFx0PGRpdiBjbGFzcz1cIm1vZGFsLWNvbnRlbnQgZXJyb3ItcG9wLXVwXCI+XHJcblx0XHRcdFx0XHQ8ZGl2IGNsYXNzPVwibW9kYWwtaGVhZGVyXCI+XHJcblx0XHRcdFx0XHRcdDxoMiBjbGFzcz1cImVycm9yLXRpdGxlXCI+RXJyb3IgPHNwYW4gZGF0YS1iaW5kPVwidGV4dDogc3RhdHVzXCI+PC9zcGFuPjogPHNwYW4gZGF0YS1iaW5kPVwidGV4dDogc3RhdHVzVGV4dFwiPjwvc3Bhbj48L2gyPlxyXG5cdFx0XHRcdFx0PC9kaXY+XHJcblx0XHRcdFx0XHQ8ZGl2IGNsYXNzPVwibW9kYWwtYm9keVwiPlxyXG5cdFx0XHRcdFx0XHQ8cCBkYXRhLWJpbmQ9XCJ0ZXh0OiBkZXRhaWxzXCIgY2xhc3M9XCJlcnJvci1kZXRhaWxzXCI+PC9wPlxyXG5cdFx0XHRcdFx0PC9kaXY+XHJcblx0XHRcdFx0XHQ8ZGl2IGNsYXNzPVwibW9kYWwtZm9vdGVyXCI+XHJcblx0XHRcdFx0XHRcdDxidXR0b24gdHlwZT1cImJ1dHRvblwiIGNsYXNzPVwiYnRuIGJ0bi1wcmltYXJ5IGJ0bi1hY2NlcHRcIiBkYXRhLWRpc21pc3M9XCJtb2RhbFwiIGFyaWEtbGFiZWw9XCJDbG9zZVwiPk9rPC9idXR0b24+XHJcblx0XHRcdFx0XHQ8L2Rpdj5cclxuXHRcdFx0XHQ8L2Rpdj48IS0tIC8ubW9kYWwtY29udGVudCAtLT5cclxuXHRcdFx0PC9kaXY+PCEtLSAvLm1vZGFsLWRpYWxvZyAtLT5cclxuXHRcdDwvc2VjdGlvbj48IS0tIC8ubW9kYWwgLS0+XHJcbmB9KTtcclxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc2NyaXB0cy9hcGktZXhwbG9yZXIvdjIvc3JjL2NvbXBvbmVudHMvcG9wdXBzL2Vycm9yLmNvbXBvbmVudC5qcyIsInJlcXVpcmUoJy4vZXJyb3IuY29tcG9uZW50Jyk7XHJcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NjcmlwdHMvYXBpLWV4cGxvcmVyL3YyL3NyYy9jb21wb25lbnRzL3BvcHVwcy9pbmRleC5qcyIsInJlcXVpcmUoJy4vcmVxdWVzdExpc3QuY29tcG9uZW50Jyk7XHJcbnJlcXVpcmUoJy4vcmVxdWVzdC5jb21wb25lbnQnKTtcclxucmVxdWlyZSgnLi9yZXNwb25zZS5jb21wb25lbnQnKTtcclxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc2NyaXB0cy9hcGktZXhwbG9yZXIvdjIvc3JjL2NvbXBvbmVudHMvcmVxdWVzdC9pbmRleC5qcyIsImltcG9ydCB7anNvbkhMfSBmcm9tICcuLi8uLi9zZXJ2aWNlcyc7XHJcblxyXG5jbGFzcyBSZXF1ZXN0Q29tcG9uZW50e1xyXG5cdGNvbnN0cnVjdG9yKHtkYXRhLCBpbmRleCwgc2hhcmVQYXRoLCBzZXRQYXJhbXN9KSB7XHJcblx0XHRjb25zdCAkaW5kZXggPSBrby51bndyYXAoaW5kZXgpO1xyXG5cdFx0dGhpcy5kYXRhID0gZGF0YTtcclxuXHRcdHRoaXMucmVzcG9uc2UgPSBkYXRhLnJlc3BvbnNlO1xyXG5cdFx0dGhpcy5oYXNSZXNwb25zZSA9ICEhZGF0YS5yZXNwb25zZTtcclxuXHRcdHRoaXMucmVxID0gZGF0YS5yZXE7XHJcblx0XHR0aGlzLmpzb25ITCA9IGpzb25ITDtcclxuXHRcdHRoaXMuY29sb3IgPSBkYXRhLmNvbG9yO1xyXG5cdFx0dGhpcy5hY3RpdmUgPSBkYXRhLmFjdGl2ZTtcclxuXHRcdHRoaXMuaXNBY3RpdmVNb3JlTWVudSA9IGRhdGEuaXNBY3RpdmVNb3JlTWVudTtcclxuXHRcdHRoaXMuY29waWVkRm9yU2hhcmUgPSBkYXRhLmNvcGllZEZvclNoYXJlO1xyXG5cdFx0dGhpcy5wYXJhbXNBcmVTZXRlZCA9IGRhdGEucGFyYW1zQXJlU2V0ZWQ7XHJcblx0XHR0aGlzLmNvcGllZFVybCA9IGRhdGEuY29waWVkVXJsO1xyXG5cdFx0dGhpcy5yZXNIVE1MID0gZGF0YS5yZXNIVE1MO1xyXG5cdFx0dGhpcy5zaGFyZVBhdGggPSBzaGFyZVBhdGg7XHJcblx0XHR0aGlzLnJvb3RzZXRQYXJhbXMgPSBzZXRQYXJhbXM7XHJcblx0XHR0aGlzLmlkcyA9IHtcclxuXHRcdFx0d3JhcHBlcjogYGhlYWRpbmctJHskaW5kZXh9YCxcclxuXHRcdFx0ZGV0YWlsczoge1xyXG5cdFx0XHRcdGlkOiBgc2hvdy1kZXRhaWxzLSR7JGluZGV4fWAsXHJcblx0XHRcdFx0dGFyZ2V0OiBgI2NvbGxhcHNlLSR7JGluZGV4fWAsXHJcblx0XHRcdFx0Y29udHJvbHM6IGBjb2xsYXBzZS0keyRpbmRleH1gXHJcblx0XHRcdH1cclxuXHRcdH07XHJcblx0fVxyXG5cclxuXHRzZXRQYXJhbXMoKSB7XHJcblx0XHR0aGlzLnBhcmFtc0FyZVNldGVkKHRydWUpO1xyXG5cdFx0c2V0VGltZW91dCgoKSA9PiB7XHJcblx0XHRcdHRoaXMucGFyYW1zQXJlU2V0ZWQoZmFsc2UpO1xyXG5cdFx0fSwgNTAwKTtcclxuXHRcdHRoaXMucm9vdHNldFBhcmFtcyh0aGlzLmRhdGEpO1xyXG5cdH1cclxuXHJcblx0Z2V0TW9yZU1lbnUoKSB7XHJcblx0XHR0aGlzLmlzQWN0aXZlTW9yZU1lbnUoIWtvLnVud3JhcCh0aGlzLmlzQWN0aXZlTW9yZU1lbnUpKTtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIERldGFpbHMgdG9nZ2xlIGhhbmRsZXJcclxuXHQgKiBAcGFyYW0gbW9kZWxcclxuXHQgKiBAcGFyYW0gZXZlbnRcclxuXHQgKi9cclxuXHRnZXREZXRhaWxzKG1vZGVsLCBldmVudCkge1xyXG5cdFx0aWYgKCFrby51bndyYXAodGhpcy5yZXNIVE1MKS5sZW5ndGgpIHtcclxuXHRcdFx0dGhpcy5qc29uSEwodGhpcy5yZXNIVE1MLCB0aGlzLnJlc3BvbnNlKTtcclxuXHRcdH1cclxuXHJcblx0XHRsZXQgc2xpZGVyID0gJChldmVudC5jdXJyZW50VGFyZ2V0KVxyXG5cdFx0XHQucGFyZW50cygnLnBhbmVsJylcclxuXHRcdFx0LmZpbmQoJy5zbGljay1zbGlkZXInKTtcclxuXHJcblx0XHRpZiAoIXNsaWRlci5maW5kKCcuc2xpY2stdHJhY2snKS53aWR0aCgpKSB7XHJcblx0XHRcdHNldFRpbWVvdXQoKCk9PiB7XHJcblx0XHRcdFx0c2xpZGVyLnNsaWNrKCdzZXRQb3NpdGlvbicpO1xyXG5cdFx0XHR9LCAwKTtcclxuXHRcdH1cclxuXHRcdHRoaXMuYWN0aXZlKCF0aGlzLmFjdGl2ZSgpKTtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIEdldCByYXcgcmVzcG9uc2UgZGF0YVxyXG5cdCAqIEBwYXJhbSBtb2RlbCB7b2JqZWN0fVxyXG5cdCAqIEByZXR1cm5zIHtzdHJpbmd9XHJcblx0ICovXHJcblx0Z2V0UmF3RGF0YShtb2RlbCA9IHt9KSB7XHJcblx0XHR2YXIgY29udGVudCA9IG1vZGVsLnJlc3BvbnNlIHx8IGtvLnVud3JhcChtb2RlbC5kYXRhLmVycm9yKVszXSB8fCB7fTtcclxuXHRcdHZhciByYXdXaW5kb3cgPSB3aW5kb3cub3BlbihcImRhdGE6dGV4dC9qc29uLFwiICsgZW5jb2RlVVJJKEpTT04uc3RyaW5naWZ5KGNvbnRlbnQsIG51bGwsIDIpKSwgJ19ibGFuaycpO1xyXG5cdFx0cmF3V2luZG93LmZvY3VzKCk7XHJcblx0fVxyXG5cclxuXHRnZXQgc2V0UGFyYW1zUG9wb3ZlcigpIHtcclxuXHRcdHJldHVybiB7XHJcblx0XHRcdHR5cGU6ICd0b29sdGlwJyxcclxuXHRcdFx0dGl0bGU6ICdSZXBlYXQgc2V0dGluZ3Mgb2YgdGhpcyByZXF1ZXN0J1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0Z2V0IHNoYXJlUGF0aFBvcG92ZXIoKSB7XHJcblx0XHRyZXR1cm4ge1xyXG5cdFx0XHR0eXBlOiAndG9vbHRpcCcsXHJcblx0XHRcdHRpdGxlOiAnQ29weSByZXF1ZXN0IHNoYXJlIGxpbmsnXHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHRnZXQgY29weVVybFBvcG92ZXIoKSB7XHJcblx0XHRyZXR1cm4ge1xyXG5cdFx0XHR0eXBlOiAndG9vbHRpcCcsXHJcblx0XHRcdHRpdGxlOiAnQ29weSByZXF1ZXN0IFVSTCdcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdGdldCBnZXRSYXdEYXRhUG9wb3ZlcigpIHtcclxuXHRcdHJldHVybiB7XHJcblx0XHRcdHR5cGU6ICd0b29sdGlwJyxcclxuXHRcdFx0dGl0bGU6ICdTaG93IHJhdyByZXNwb25zZSBkYXRhJ1xyXG5cdFx0fVxyXG5cdH1cclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBrby5jb21wb25lbnRzLnJlZ2lzdGVyKCdyZXF1ZXN0LWNvbXBvbmVudCcsIHtcclxuXHR2aWV3TW9kZWw6IFJlcXVlc3RDb21wb25lbnQsXHJcblx0dGVtcGxhdGU6YFxyXG5cdFx0PHNlY3Rpb24gY2xhc3M9XCJyb3ctY29udGFpbmVyIHJlcXVlc3RcIiBkYXRhLWJpbmQ9XCJhdHRyOiB7aWQ6IGlkcy53cmFwcGVyfVwiIHJvbGU9XCJ0YWJcIj5cclxuXHRcdFx0PGRpdiBjbGFzcz1cImVkaXQtY29udHJvbHNcIiBkYXRhLWJpbmQ9XCJjc3M6IHsndmlzaWJsZSB3aGl0ZSc6IGlzQWN0aXZlTW9yZU1lbnV9XCI+XHJcblx0XHRcdFx0PGJ1dHRvbiBkYXRhLWJpbmQ9XCJjbGljazogc2V0UGFyYW1zLCBjc3M6IHtkb25lOiBwYXJhbXNBcmVTZXRlZH0sIHBvcG92ZXI6IHNldFBhcmFtc1BvcG92ZXJcIiBjbGFzcz1cImJ0biBidG4taWNvbiBidG4tcHJlc2V0XCIgdHlwZT1cImJ1dHRvblwiPjwvYnV0dG9uPlxyXG5cdFx0XHRcdDxidXR0b24gZGF0YS1iaW5kPVwiY29weVRvQ2xpcGJvYXJkOiB7dGV4dDogc2hhcmVQYXRofSwgcG9wb3Zlcjogc2hhcmVQYXRoUG9wb3ZlclwiIGNsYXNzPVwiYnRuIGJ0bi1pY29uIGJ0bi1zaGFyZVwiIHR5cGU9XCJidXR0b25cIj48L2J1dHRvbj5cclxuXHRcdFx0XHQ8YnV0dG9uIGRhdGEtYmluZD1cImNvcHlUb0NsaXBib2FyZDoge3RleHQ6IHJlcX0sIHBvcG92ZXI6IGNvcHlVcmxQb3BvdmVyXCIgY2xhc3M9XCJidG4gYnRuLWljb24gYnRuLWNvcHlcIiB0eXBlPVwiYnV0dG9uXCI+PC9idXR0b24+XHJcblx0XHRcdFx0PGJ1dHRvbiBkYXRhLWJpbmQ9XCJjbGljazogZ2V0UmF3RGF0YSwgcG9wb3ZlcjogZ2V0UmF3RGF0YVBvcG92ZXJcIiBjbGFzcz1cImJ0biBidG4taWNvbiBidG4tcmF3XCIgdHlwZT1cImJ1dHRvblwiPjwvYnV0dG9uPlxyXG5cdFx0XHQ8L2Rpdj5cclxuXHRcdFx0PGJ1dHRvbiBkYXRhLWJpbmQ9XCJjbGljazogZ2V0TW9yZU1lbnUsIGNzczoge2FjdGl2ZTogaXNBY3RpdmVNb3JlTWVudX1cIiBjbGFzcz1cImJ0biBidG4taWNvbiBidG4tbW9yZVwiPjwvYnV0dG9uPlxyXG5cdFx0XHQ8ZGl2IGNsYXNzPVwicGFuZWwtdGl0bGVcIj5cclxuXHRcdFx0XHQ8IS0tIGtvIGlmOiBoYXNSZXNwb25zZSAtLT5cclxuXHRcdFx0XHRcdDxidXR0b24gZGF0YS1iaW5kPVwiY2xpY2s6IGdldERldGFpbHMsIGF0dHI6IHtpZDogaWRzLmRldGFpbHMuaWQsICdkYXRhLXRhcmdldCc6IGlkcy5kZXRhaWxzLnRhcmdldCwgJ2FyaWEtY29udHJvbHMnOiBpZHMuZGV0YWlscy5jb250cm9sc31cIiB0eXBlPVwiYnV0dG9uXCIgY2xhc3M9XCJidG4gYnRuLWljb24gc2hldnJvbiB1cCBibHVlIHZpZXctY29udHJvbFwiIGRhdGEtdG9nZ2xlPVwiY29sbGFwc2VcIiBkYXRhLXBhcmVudD1cIiNyZXNwb25zZVwiIGFyaWEtZXhwYW5kZWQ9XCJmYWxzZVwiPjwvYnV0dG9uPlxyXG5cdFx0XHRcdDwhLS0gL2tvIC0tPlxyXG5cdFx0XHRcdDwhLS0ga28gaWZub3Q6IGhhc1Jlc3BvbnNlIC0tPlxyXG5cdFx0XHRcdFx0PGJ1dHRvbiBkYXRhLWJpbmQ9XCJwb3BvdmVyOiB7dHlwZTogJ3BvcG92ZXInLCB0cmlnZ2VyOiAnY2xpY2snLCBkYXRhOiBkYXRhLmVycm9yfVwiIGNsYXNzPVwiYnRuIGJ0bi1pY29uIGJ0bi1hbGVydCB2aWV3LWNvbnRyb2xcIj48L2J1dHRvbj5cclxuXHRcdFx0XHQ8IS0tIC9rbyAtLT5cclxuXHRcdFx0PC9kaXY+XHJcblx0XHRcdDxzcGFuIGRhdGEtYmluZD1cImNzczogY29sb3JcIiBjbGFzcz1cImNvbG9yLWluZGljYXRvciB2aWV3LWNvbnRyb2xcIj48L3NwYW4+XHJcblx0XHRcdDxwIGRhdGEtYmluZD1cInRleHQ6IHJlcSwgYmxvY2tFbGxpcHNpczoge2NsYW1wOiAyfVwiIGNsYXNzPVwiaXRlbV90ZXh0XCI+PC9wPlxyXG5cdFx0PC9zZWN0aW9uPlxyXG5gfSk7XHJcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NjcmlwdHMvYXBpLWV4cGxvcmVyL3YyL3NyYy9jb21wb25lbnRzL3JlcXVlc3QvcmVxdWVzdC5jb21wb25lbnQuanMiLCJpbXBvcnQge2NvbG9yc1NlcnZpY2V9IGZyb20gJy4uLy4uL3NlcnZpY2VzJztcclxudmFyIHNsaWRlciA9IHJlcXVpcmUoJy4uLy4uL21vZHVsZXMvc2xpZGVyJyk7XHJcblxyXG5jbGFzcyBSZXF1ZXN0TGlzdENvbXBvbmVudHtcclxuXHRjb25zdHJ1Y3Rvcih7c2VsZWN0ZWRQYXJhbXMsIHNoYXJlUGF0aCwgc2V0UGFyYW1zfSkge1xyXG5cdFx0dGhpcy51cmwgPSBzZWxlY3RlZFBhcmFtcztcclxuXHRcdHRoaXMuc2hhcmVQYXRoID0gc2hhcmVQYXRoO1xyXG5cdFx0dGhpcy5yZXF1ZXN0cyA9IGtvLm9ic2VydmFibGVBcnJheShbXSkuc3luY1dpdGgoJ1JFUVVFU1RTX0FSUicpO1xyXG5cdFx0dGhpcy5zZXRQYXJhbXMgPSBzZXRQYXJhbXM7XHJcblx0XHR0aGlzLmNvbG9ycyA9IGNvbG9yc1NlcnZpY2UuY29sb3JzO1xyXG5cdFx0dGhpcy52aWV3TW9kZWwgPSBrby5vYnNlcnZhYmxlQXJyYXkoW10pO1xyXG5cdFx0dGhpcy5jbGVhckJ0bklzVmlzaWJsZSA9IGtvLmNvbXB1dGVkKHRoaXMuX2lzVmlzaWJsZSwgdGhpcyk7XHJcblx0XHR0aGlzLnJlcXVlc3RzLnN1YnNjcmliZSh0aGlzLnVwZGF0ZU1vZGVsLCB0aGlzKTtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFVwZGF0ZSBWaWV3bW9kZWwgb2YgcmVxdWVzdCBsaXN0XHJcblx0ICogQHBhcmFtIGFyclxyXG5cdCAqL1xyXG5cdHVwZGF0ZU1vZGVsKGFycikge1xyXG5cdFx0dmFyIG5ld01vZGVsID0ga28udW53cmFwKHRoaXMucmVxdWVzdHMpXHJcblx0XHRcdC5tYXAob2JqID0+IHtcclxuXHRcdFx0XHR2YXIgbmV3T2JqID0ge1xyXG5cdFx0XHRcdFx0Y29sb3I6IHRoaXMuY29sb3JzW29iai5pbmRleCAlIHRoaXMuY29sb3JzLmxlbmd0aF0sXHJcblx0XHRcdFx0XHRhY3RpdmU6IGtvLm9ic2VydmFibGUoZmFsc2UpLFxyXG5cdFx0XHRcdFx0aXNBY3RpdmVNb3JlTWVudToga28ub2JzZXJ2YWJsZShmYWxzZSksXHJcblx0XHRcdFx0XHRjb3BpZWRGb3JTaGFyZToga28ub2JzZXJ2YWJsZShmYWxzZSksXHJcblx0XHRcdFx0XHRwYXJhbXNBcmVTZXRlZDoga28ub2JzZXJ2YWJsZShmYWxzZSksXHJcblx0XHRcdFx0XHRjb3BpZWRVcmw6IGtvLm9ic2VydmFibGUoZmFsc2UpLFxyXG5cdFx0XHRcdFx0cmVzSFRNTDoga28ub2JzZXJ2YWJsZSgnJylcclxuXHRcdFx0XHR9O1xyXG5cclxuXHRcdFx0XHQvLyBlcnJvciBwb3BvdmVyXHJcblx0XHRcdFx0aWYgKG9iai5lcnJvcikge1xyXG5cdFx0XHRcdFx0dmFyIGVycm9yT2JqID0gb2JqLmVycm9yO1xyXG5cdFx0XHRcdFx0bmV3T2JqLmVycm9yID0ga28ub2JzZXJ2YWJsZShbXHJcblx0XHRcdFx0XHRcdE9iamVjdC5nZXRQcm9wKGVycm9yT2JqLCAnLnJlc3BvbnNlSlNPTi5lcnJvcnNbMF0uc3RhdHVzJykgfHwgZXJyb3JPYmouc3RhdHVzICsgJycsXHJcblx0XHRcdFx0XHRcdE9iamVjdC5nZXRQcm9wKGVycm9yT2JqLCAnLnJlc3BvbnNlSlNPTi5lcnJvcnNbMF0uc3RhdHVzVGV4dCcpIHx8ICcnLFxyXG5cdFx0XHRcdFx0XHRPYmplY3QuZ2V0UHJvcChlcnJvck9iaiwgJy5yZXNwb25zZUpTT04uZXJyb3JzWzBdLmRldGFpbCcpIHx8ICd1bmtub3duJyxcclxuXHRcdFx0XHRcdFx0T2JqZWN0LmdldFByb3AoZXJyb3JPYmosICcucmVzcG9uc2VKU09OJykgfHwge31cclxuXHRcdFx0XHRcdF0pXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRyZXR1cm4gJC5leHRlbmQoe30sIG9iaiwgbmV3T2JqKTtcclxuXHRcdFx0fSk7XHJcblx0XHRzbGlkZXIucmVtb3ZlKHRoaXMudmlld01vZGVsKCkubGVuZ3RoKTtcclxuXHRcdHRoaXMudmlld01vZGVsKG5ld01vZGVsKTtcclxuXHRcdHNldFRpbWVvdXQoKCkgPT4ge1xyXG5cdFx0XHRzbGlkZXIuc2V0KHRoaXMudmlld01vZGVsKCkubGVuZ3RoKTtcclxuXHRcdFx0JCgnI3Nob3ctZGV0YWlscy0wJykudHJpZ2dlcignY2xpY2snKTtcclxuXHRcdH0sIDEwKTtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFZpc2liaWxpdHkgZmxhZyBmb3IgQ2xlYXIgYnRuXHJcblx0ICogQHJldHVybnMge2Jvb2xlYW59XHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRfaXNWaXNpYmxlKCkge1xyXG5cdFx0cmV0dXJuIGtvLnV0aWxzLnVud3JhcE9ic2VydmFibGUodGhpcy5yZXF1ZXN0cykubGVuZ3RoID4gMDtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIENsZWFyIHJlcXVlc3RzdHMgbGlzdCBoYW5kbGVyXHJcblx0ICogQHBhcmFtIHZtXHJcblx0ICogQHBhcmFtIGV2ZW50XHJcblx0ICovXHJcblx0b25DbGVhclJlcXVlc3RzKHZtLCBldmVudCkge1xyXG5cdFx0dGhpcy5yZXF1ZXN0cyhbXSk7XHJcblx0fVxyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGtvLmNvbXBvbmVudHMucmVnaXN0ZXIoJ3JlcXVlc3QtbGlzdCcsIHtcclxuXHR2aWV3TW9kZWw6IFJlcXVlc3RMaXN0Q29tcG9uZW50LFxyXG5cdHRlbXBsYXRlOmBcclxuXHQ8c2VjdGlvbiBjbGFzcz1cImNsZWFyZml4XCI+XHJcblx0XHQ8IS0ta28gaWY6IGNsZWFyQnRuSXNWaXNpYmxlLS0+XHJcblx0XHRcdDwhLS1oZWFkbGluZS0tPlxyXG5cdFx0XHQ8c2VjdGlvbiBjbGFzcz1cInJvdy1jb250YWluZXIgYXBpLWV4cC1yZXF1ZXN0LWxpc3QtaGVhZGxpbmVcIj5cclxuXHRcdFx0XHQ8aDQgY2xhc3M9XCJ0aXRsZVwiPlJlcXVlc3QgbGlzdDwvaDQ+XHJcblx0XHRcdFx0PGRpdiBjbGFzcz1cImhlYWRsaW5lLWVkaXRcIj5cclxuXHRcdFx0XHRcdDxidXR0b24gZGF0YS1iaW5kPVwiY2xpY2s6IG9uQ2xlYXJSZXF1ZXN0cywgcG9wb3Zlcjoge3R5cGU6ICd0b29sdGlwJywgdGl0bGU6ICdDbGVhciByZXF1ZXN0cyBoaXN0b3J5J31cIiBjbGFzcz1cImJ0biBidG4taWNvbiBidG4tY2xlYXJcIiB0eXBlPVwiYnV0dG9uXCI+PC9idXR0b24+XHJcblx0XHRcdFx0PC9kaXY+XHJcblx0XHRcdDwvc2VjdGlvbj5cclxuXHJcblx0XHRcdDwhLS1yZXF1ZXN0cy0tPlxyXG5cdFx0XHQ8c2VjdGlvbj5cclxuXHRcdFx0XHQ8dWwgZGF0YS1iaW5kPVwiZm9yZWFjaDogdmlld01vZGVsXCIgY2xhc3M9XCJwYW5lbC1ncm91cCBhcGktZXhwLXJlcXVlc3QtbGlzdFwiIGlkPVwicmVzcG9uc2VcIiByb2xlPVwidGFibGlzdFwiIGFyaWEtbXVsdGlzZWxlY3RhYmxlPVwidHJ1ZVwiPlxyXG5cdFx0XHRcdFx0PGxpIGRhdGEtYmluZD1cImNzczoge2FjdGl2ZTogYWN0aXZlfVwiIGNsYXNzPVwicGFuZWwgcGFuZWwtZGVmYXVsdCBhcGktZXhwLXJlcXVlc3QtbGlzdC1pdGVtIGNsZWFyZml4XCI+XHJcblx0XHRcdFx0XHRcdDxyZXF1ZXN0LWNvbXBvbmVudCBwYXJhbXM9XCJkYXRhOiAkZGF0YSwgaW5kZXg6ICRpbmRleCwgc2hhcmVQYXRoOiAkcm9vdC5zaGFyZVBhdGgsIHNldFBhcmFtczogJHJvb3Quc2V0UGFyYW1zXCI+PC9yZXF1ZXN0LWNvbXBvbmVudD5cclxuXHRcdFx0XHRcdFx0PHJlc3BvbnNlLWNvbXBvbmVudCBwYXJhbXM9XCJkYXRhOiAkZGF0YSwgaW5kZXg6ICRpbmRleCwgY29uZmlnOiAkcm9vdC5jb25maWcsIHNldFBhcmFtczogJGNvbXBvbmVudC5zZXRQYXJhbXNcIj48L3Jlc3BvbnNlLWNvbXBvbmVudD5cclxuXHRcdFx0XHRcdDwvbGk+XHJcblx0XHRcdFx0PC91bD5cclxuXHRcdFx0PC9zZWN0aW9uPlxyXG5cdFx0PCEtLSAva28gLS0+XHJcblx0PC9zZWN0aW9uPlxyXG5gfSk7XHJcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NjcmlwdHMvYXBpLWV4cGxvcmVyL3YyL3NyYy9jb21wb25lbnRzL3JlcXVlc3QvcmVxdWVzdExpc3QuY29tcG9uZW50LmpzIiwiY2xhc3MgUmVzcG9uc2VDb21wb25lbnR7XHJcblx0Y29uc3RydWN0b3Ioe2RhdGEsIGluZGV4LCBjb25maWcsIHNldFBhcmFtcywgZ2V0UmFuZG9tQ29sb3J9KSB7XHJcblx0XHR0aGlzLmluZGV4ID0ga28udW53cmFwKGluZGV4KTtcclxuXHRcdHRoaXMuZGF0YSA9IGRhdGE7XHJcblx0XHR0aGlzLmhhc1Jlc3BvbnNlID0gISFkYXRhLnJlc3BvbnNlO1xyXG5cdFx0dGhpcy5yZXNIVE1MID0gZGF0YS5yZXNIVE1MO1xyXG5cdFx0dGhpcy5jb2xvciA9IGRhdGEuY29sb3I7XHJcblx0XHR0aGlzLmNvbmZpZyA9IGNvbmZpZztcclxuXHRcdHRoaXMuc2V0UGFyYW1zID0gc2V0UGFyYW1zO1xyXG5cdFx0dGhpcy5yZXNwb25zZSA9IGRhdGEucmVzcG9uc2U7XHJcblx0XHR0aGlzLnJlcSA9IGRhdGEucmVxO1xyXG5cclxuXHRcdHRoaXMuYnJlYWRjcnVic0FyciA9IFtdO1xyXG5cdFx0dGhpcy5icmVhZGNydW1icyA9IGtvLm9ic2VydmFibGUoJycpO1xyXG5cclxuXHRcdHRoaXMuYXR0cnMgPSB7XHJcblx0XHRcdHdyYXBwZXI6IHtcclxuXHRcdFx0XHRpZDogYGNvbGxhcHNlLSR7dGhpcy5pbmRleH1gLFxyXG5cdFx0XHRcdCdhcmlhLWxhYmVsbGVkYnknOiBgaGVhZGluZy0ke3RoaXMuaW5kZXh9YCxcclxuXHRcdFx0fSxcclxuXHRcdFx0dGFiczoge1xyXG5cdFx0XHRcdGpzb246IHtcclxuXHRcdFx0XHRcdGhyZWY6IGAjanNvbi0ke3RoaXMuaW5kZXh9YCxcclxuXHRcdFx0XHRcdCdhcmlhLWNvbnRyb2xzJzogYGpzb24tJHt0aGlzLmluZGV4fWBcclxuXHRcdFx0XHR9LFxyXG5cdFx0XHRcdGJsb2Nrczoge1xyXG5cdFx0XHRcdFx0aHJlZjogYCNzbGlkZXItJHt0aGlzLmluZGV4fWAsXHJcblx0XHRcdFx0XHQnYXJpYS1jb250cm9scyc6IGBibG9ja3MtJHt0aGlzLmluZGV4fWBcclxuXHRcdFx0XHR9XHJcblx0XHRcdH0sXHJcblx0XHRcdHZpZXc6IHtcclxuXHRcdFx0XHRqc29uOiB7XHJcblx0XHRcdFx0XHRpZDogYGpzb24tJHt0aGlzLmluZGV4fWBcclxuXHRcdFx0XHR9LFxyXG5cdFx0XHRcdGJsb2Nrczoge1xyXG5cdFx0XHRcdFx0aWQ6IGBzbGlkZXItJHt0aGlzLmluZGV4fWBcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdH07XHJcblxyXG5cdFx0a28ucG9zdGJveC5zdWJzY3JpYmUoJ0FOT1RIRVJfUkVTUE9OU0UnLCAoe2RhdGEsIHBhbmVsR3JvdXAsIGNvbG9yfSkgPT4ge1xyXG5cdFx0XHRsZXQgcmVzcG9uc2UgPSBwYW5lbEdyb3VwLnByZXBhcmVEYXRhKHtwYXJhbXM6IHtkYXRhOiBkYXRhLnJlc3BvbnNlfX0pO1xyXG5cdFx0XHR0aGlzLmdldE1vcmUoe1xyXG5cdFx0XHRcdGlkOiBwYW5lbEdyb3VwLmdyb3VwSW5kZXgsXHJcblx0XHRcdFx0ZGF0YTogcmVzcG9uc2UsXHJcblx0XHRcdFx0cEdyb3VwOiBwYW5lbEdyb3VwLFxyXG5cdFx0XHRcdGNvbG9yXHJcblx0XHRcdH0pO1xyXG5cdFx0fSk7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBnZXQgZGV0YWlsc1xyXG5cdCAqL1xyXG5cdGdldE1vcmUgPSAoe3BhbmVsID0ge30sIGlkLCBkYXRhLCBwR3JvdXAsIGNvbG9yfSkgPT4ge1xyXG5cdFx0bGV0IHBhbmVsR3JvdXAgPSBwR3JvdXAgfHwgcGFuZWwucGFuZWxHcm91cDtcclxuXHRcdGxldCBjdXJyZW50U2xpZGVyID0gJCgnI3NsaWRlci0nICsgcGFuZWxHcm91cC5zZWN0aW9uSW5kZXgpO1xyXG5cdFx0bGV0IGNvbXBvbmVudCA9ICQoJzxzZWN0aW9uIGRhdGEtYmluZD1cImNvbXBvbmVudDoge25hbWU6IFxcJ3BhbmVsLWdyb3VwXFwnLCBwYXJhbXM6IHBhcmFtc31cIj48L3NlY3Rpb24+Jyk7XHJcblx0XHRsZXQgY3Vyc2xpY2sgPSBjdXJyZW50U2xpZGVyLnNsaWNrKCdnZXRTbGljaycpO1xyXG5cclxuXHRcdC8vIGV4dGVuZGluZyBhZGRpdGlvbmFsIGRhdGEgKGNvcHkpXHJcblx0XHRsZXQgcGFyYW1zID0gJC5leHRlbmQoe30sIHBhbmVsR3JvdXAsIHtcclxuXHRcdFx0ZGF0YTogZGF0YSxcclxuXHRcdFx0Z3JvdXBJbmRleDogcGFuZWxHcm91cC5ncm91cEluZGV4ICsgMSxcclxuXHRcdFx0X3Byb3BUaXRsZTogdHlwZW9mIGlkID09PSAnc3RyaW5nJyAmJiBpZCB8fCAnb2JqZWN0JyxcclxuXHRcdFx0Y29uZmlnOiBwYW5lbC5jb25maWcsXHJcblx0XHRcdGNvbG9yQ2xhc3M6IGNvbG9yXHJcblx0XHR9KTtcclxuXHJcblx0XHQvLyBhcHBseSBjb21wb25lbnQgZGF0YSBiaW5kaW5nc1xyXG5cdFx0a28uYXBwbHlCaW5kaW5ncyh7XHJcblx0XHRcdHBhcmFtczogcGFyYW1zXHJcblx0XHR9LCBjb21wb25lbnRbMF0pO1xyXG5cclxuXHRcdC8vIGJ1aWxkIGJyZWFkY3J1YnNcclxuXHRcdHRoaXMuYnVpbGRCcmVhZGNydW1icyh7aW5kZXg6IHBhbmVsR3JvdXAuZ3JvdXBJbmRleCwgcGFyZW50OiBwYW5lbC5fcGFuZWxOYW1lLCBjdXJyZW50OiBpZH0pO1xyXG5cclxuXHRcdC8vIGFkZCBzbGlkZSB3aXRoIHNlbGVjdGVkIGRhdGFcclxuXHRcdGN1cnJlbnRTbGlkZXIuc2xpY2soJ3NsaWNrQWRkJywgY29tcG9uZW50KTtcclxuXHRcdC8vIHJlbW92ZSBvdXRzdGFuZGluZyBzbGlkZXNcclxuXHRcdGZvciAodmFyIGkgPSBjdXJzbGljay5zbGlkZUNvdW50IC0gMjsgaSA+IHBhbmVsR3JvdXAuZ3JvdXBJbmRleDsgaS0tKSB7XHJcblx0XHRcdGN1cnJlbnRTbGlkZXIuc2xpY2soJ3NsaWNrUmVtb3ZlJywgaSwgZmFsc2UpO1xyXG5cdFx0fVxyXG5cdFx0Ly8gbW92ZSB0byBuZXh0IHNsaWRlXHJcblx0XHRzZXRUaW1lb3V0KCgpID0+IHtcclxuXHRcdFx0Y3VycmVudFNsaWRlci5zbGljaygnc2xpY2tOZXh0Jyk7XHJcblx0XHR9LCAzMTApO1xyXG5cdH07XHJcblxyXG5cdGJ1aWxkQnJlYWRjcnVtYnMoe2luZGV4LCBwYXJlbnQsIGN1cnJlbnR9KSB7XHJcblx0XHRsZXQgc3RyID0gaW5kZXggPyAnLycgOiAnJztcclxuXHJcblx0XHRpZiAodHlwZW9mIGN1cnJlbnQgPT09ICdudW1iZXInKSB7XHJcblx0XHRcdHN0ciArPSBgJHtwYXJlbnR9WyR7Y3VycmVudH1dYFxyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0c3RyICs9IGAke3BhcmVudH0vJHtjdXJyZW50fWBcclxuXHRcdH1cclxuXHRcdHRoaXMuYnJlYWRjcnVic0FycltpbmRleF0gPSBzdHI7XHJcblx0XHR0aGlzLmJyZWFkY3J1YnNBcnIubGVuZ3RoID0gaW5kZXggKyAxO1xyXG5cclxuXHRcdHRoaXMuYnJlYWRjcnVtYnModGhpcy5icmVhZGNydWJzQXJyLmpvaW4oJycpKTtcclxuXHR9XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0ga28uY29tcG9uZW50cy5yZWdpc3RlcigncmVzcG9uc2UtY29tcG9uZW50Jywge1xyXG5cdHZpZXdNb2RlbDogUmVzcG9uc2VDb21wb25lbnQsXHJcblx0dGVtcGxhdGU6YFxyXG5cdFx0PCEtLSBrbyBpZjogaGFzUmVzcG9uc2UgLS0+XHJcblx0XHQ8c2VjdGlvbiBjbGFzcz1cInJlc3BvbnNlIGNvbGxhcHNlXCIgZGF0YS1iaW5kPVwiYXR0cjogYXR0cnMud3JhcHBlclwiIHJvbGU9XCJ0YWJwYW5lbFwiPlxyXG5cdFx0XHRcdDxkaXYgY2xhc3M9XCJyb3ctY29udGFpbmVyXCI+XHJcblx0XHRcdFx0XHJcblx0XHRcdFx0XHQ8IS0tIE5hdiB0YWJzIC0tPlxyXG5cdFx0XHRcdFx0PHVsIGNsYXNzPVwibmF2IG5hdi10YWJzIHRhYnMtY29udHJvbGxzXCIgcm9sZT1cInRhYmxpc3RcIj5cclxuXHRcdFx0XHRcdFx0PGxpIHJvbGU9XCJwcmVzZW50YXRpb25cIiBjbGFzcz1cInRhYlwiPlxyXG5cdFx0XHRcdFx0XHRcdDxhIGRhdGEtYmluZD1cImF0dHI6IGF0dHJzLnRhYnMuanNvblwiIGNsYXNzPVwidGFiLWJ0blwiIGhyZWY9XCIjanNvblwiIGFyaWEtY29udHJvbHM9XCJqc29uXCIgcm9sZT1cInRhYlwiIGRhdGEtdG9nZ2xlPVwidGFiXCI+SnNvbjwvYT5cclxuXHRcdFx0XHRcdFx0PC9saT5cclxuXHRcdFx0XHRcdFx0PGxpIHJvbGU9XCJwcmVzZW50YXRpb25cIiBjbGFzcz1cInRhYiBhY3RpdmVcIj5cclxuXHRcdFx0XHRcdFx0XHQ8YSBkYXRhLWJpbmQ9XCJhdHRyOiBhdHRycy50YWJzLmJsb2Nrc1wiIGNsYXNzPVwidGFiLWJ0blwiIGhyZWY9XCIjYmxvY2tzXCIgYXJpYS1jb250cm9scz1cImJsb2Nrc1wiIHJvbGU9XCJ0YWJcIiBkYXRhLXRvZ2dsZT1cInRhYlwiPkJsb2NrczwvYT5cclxuXHRcdFx0XHRcdFx0PC9saT5cclxuXHRcdFx0XHRcdDwvdWw+XHJcblx0XHRcdFx0XHRcclxuXHRcdFx0XHRcdDx1bCBjbGFzcz1cIm5hdiBuYXYtdGFicyBpbmZvXCI+XHJcblx0XHRcdFx0XHRcdDxsaSBjbGFzcz1cInRhYlwiPlxyXG5cdFx0XHRcdFx0XHRcdDxkaXYgY2xhc3M9XCJ0YWItbGFiZWxcIj5cclxuXHRcdFx0XHRcdFx0XHRcdDxzcGFuIGRhdGEtYmluZD1cInZpc2libGU6IGJyZWFkY3J1bWJzXCI+U3RydWN0dXJlOjwvc3Bhbj5cclxuXHRcdFx0XHRcdFx0XHQ8L2Rpdj5cclxuXHRcdFx0XHRcdFx0PC9saT5cclxuXHRcdFx0XHRcdFx0PGxpIGNsYXNzPVwidGFiXCI+XHJcblx0XHRcdFx0XHRcdFx0PHNwYW4gZGF0YS1iaW5kPVwidGV4dDogYnJlYWRjcnVtYnNcIiBjbGFzcz1cInRhYi1sYWJlbCBicmVhZGNydW1icyB0cnVuY2F0ZVwiPjwvc3Bhbj5cclxuXHRcdFx0XHRcdFx0PC9saT5cclxuXHRcdFx0XHRcdDwvdWw+XHJcblxyXG5cdFx0XHRcdFx0PCEtLSBUYWIgcGFuZXMgLS0+XHJcblx0XHRcdFx0XHQ8ZGl2IGNsYXNzPVwicm93XCI+XHJcblx0XHRcdFx0XHRcdDxkaXYgY2xhc3M9XCJ0YWItY29udGVudCBjb2wteHMtMTJcIj5cclxuXHRcdFx0XHRcdFx0XHQ8IS0tIGpzb24gLS0+XHJcblx0XHRcdFx0XHRcdFx0PGRpdiBkYXRhLWJpbmQ9XCJzY3JvbGw6IHt4OiBmYWxzZSwgeTogdHJ1ZX0sIGF0dHI6IGF0dHJzLnZpZXcuanNvblwiIHJvbGU9XCJ0YWJwYW5lbFwiIGNsYXNzPVwidGFiLXBhbmUgcHJldHktanNvblwiIGlkPVwianNvblwiPlxyXG5cdFx0XHRcdFx0XHRcdFx0PHAgZGF0YS1iaW5kPVwiaHRtbDogcmVzSFRNTFwiPjwvcD5cclxuXHRcdFx0XHRcdFx0XHQ8L2Rpdj5cclxuXHRcdFx0XHRcdFx0XHQ8IS0tIGJsb2NrcyAtLT5cclxuXHRcdFx0XHRcdFx0XHQ8ZGl2IGRhdGEtYmluZD1cImF0dHI6IGF0dHJzLnZpZXcuYmxvY2tzXCIgcm9sZT1cInRhYnBhbmVsXCIgY2xhc3M9XCJ0YWItcGFuZSBibG9ja3MgYWN0aXZlXCIgaWQ9XCJibG9ja3NcIj5cclxuXHRcdFx0XHRcdFx0XHRcdDxwYW5lbC1ncm91cCBwYXJhbXM9XCJcclxuXHRcdFx0XHRcdFx0XHRcdFx0Y2F0ZWdvcnk6IGRhdGEuY2F0ZWdvcnksXHJcblx0XHRcdFx0XHRcdFx0XHRcdG1ldGhvZDogZGF0YS5tZXRob2QsXHJcblx0XHRcdFx0XHRcdFx0XHRcdG1ldGhvZElkOiBkYXRhLm1ldGhvZElkLFxyXG5cdFx0XHRcdFx0XHRcdFx0XHRwYXJhbXM6IGRhdGEucGFyYW1zLFxyXG5cdFx0XHRcdFx0XHRcdFx0XHRkYXRhOiBkYXRhLnJlc3BvbnNlLFxyXG5cdFx0XHRcdFx0XHRcdFx0XHRjb2xvckNsYXNzOiBkYXRhLmNvbG9yLFxyXG5cdFx0XHRcdFx0XHRcdFx0XHRzZWN0aW9uSW5kZXg6IGluZGV4LFxyXG5cdFx0XHRcdFx0XHRcdFx0XHRmaWx0ZXI6IGNvbmZpZyxcclxuXHRcdFx0XHRcdFx0XHRcdFx0c2V0UGFyYW1zOiBzZXRQYXJhbXMsXHJcblx0XHRcdFx0XHRcdFx0XHRcdGdldE1vcmU6IGdldE1vcmVcclxuXHRcdFx0XHRcdFx0XHRcdFx0XCI+XHJcblx0XHRcdFx0XHRcdFx0XHQ8L3BhbmVsLWdyb3VwPlxyXG5cdFx0XHRcdFx0XHRcdDwvZGl2PlxyXG5cdFx0XHRcdFx0XHQ8L2Rpdj5cclxuXHRcdFx0XHRcdDwvZGl2PlxyXG5cdFx0XHRcdDwvZGl2PlxyXG5cdFx0PC9zZWN0aW9uPlxyXG5cdFx0PCEtLSAva28gLS0+XHRcclxuYH0pO1xyXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zY3JpcHRzL2FwaS1leHBsb3Jlci92Mi9zcmMvY29tcG9uZW50cy9yZXF1ZXN0L3Jlc3BvbnNlLmNvbXBvbmVudC5qcyIsIi8qKlxyXG4gKiBibG9ja0VsbGlwc2lzIC0gQ2xhbXBzIChpZS4gY3V0cyBvZmYpIGFuIEhUTUwgZWxlbWVudCdzIGNvbnRlbnQgYnkgYWRkaW5nIGVsbGlwc2lzIHRvIGl0IGlmIHRoZSBjb250ZW50IGluc2lkZSBpcyB0b28gbG9uZy5cclxuICpcclxuICogZXhhbXBsZTogPHRhZyBkYXRhLWJpbmQ9XCJibG9ja0VsbGlwc2lzOiB7Y2xhbXA6IDJ9XCI+PC90YWc+XHJcbiAqIGxpbmsgdG8gc291cmNlOiBodHRwczovL2dpdGh1Yi5jb20vam9zZXBoc2NobWl0dC9DbGFtcC5qc1xyXG4gKi9cclxua28uYmluZGluZ0hhbmRsZXJzLmJsb2NrRWxsaXBzaXMgPSB7XHJcblx0aW5pdDogZnVuY3Rpb24oZWxlbWVudCwgdmFsdWVBY2Nlc3NvciwgYWxsQmluZGluZ3MsIHZpZXdNb2RlbCwgYmluZGluZ0NvbnRleHQpIHtcclxuXHRcdCRjbGFtcChlbGVtZW50LCB2YWx1ZUFjY2Vzc29yKCkpO1xyXG5cdH1cclxufTtcclxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc2NyaXB0cy9hcGktZXhwbG9yZXIvdjIvc3JjL2N1c3RvbUJpbmRpbmdzL2Jsb2NrRWxsaXBzaXMuYmluZGluZy5qcyIsImtvLmJpbmRpbmdIYW5kbGVycy5jbGFzc2lmaWNhdGlvbnNNYXAgPSB7XHJcblx0aW5pdDogZnVuY3Rpb24oZWxlbWVudCwgdmFsdWVBY2Nlc3NvciwgYWxsQmluZGluZ3MsIHZpZXdNb2RlbCwgYmluZGluZ0NvbnRleHQpIHtcclxuXHRcdGxldCBwYXJhbXMgPSB2YWx1ZUFjY2Vzc29yKCk7XHJcblx0XHRsZXQgX2FsbEJpbmRpbmdzID0gYWxsQmluZGluZ3MoKTtcclxuXHRcdGxldCBfYmluZGluZ0NvbnRleHQgPSBiaW5kaW5nQ29udGV4dDtcclxuXHJcblxyXG5cdH1cclxufTtcclxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc2NyaXB0cy9hcGktZXhwbG9yZXIvdjIvc3JjL2N1c3RvbUJpbmRpbmdzL2NsYXNzaWZpY2F0aW9uc01hcC5iaW5kaW5nLmpzIiwiLyoqXHJcbiAqIGNvcHlUb0NsaXBib2FyZCAtIEEgbW9kZXJuIGFwcHJvYWNoIHRvIGNvcHkgdGV4dCB0byBjbGlwYm9hcmRcclxuICpcclxuICogZXhhbXBsZTogPHRhZyBkYXRhLWJpbmQ9XCJjb3B5VG9DbGlwYm9hcmQ6IHt0ZXh0OiAnc29tZSB0ZXh0IHRvIGNvcHknfVwiPjwvdGFnPlxyXG4gKlxyXG4gKiBvcHRpb25zOlxyXG4gKlx0dGV4dDogJ3N0cmluZycgLSBjb3B5fGN1dCB0ZXh0XHJcbiAqXHQtLSBvcHRpb25hbCAtLVxyXG4gKiBcdHRhcmdldDogPG5vZGV8ZWxlbWVudD4gLSB0YXJnZXQgZWxlbWVudFxyXG4gKiBcdGFjdGlvbjogPHN0cmluZz4gLSB0eXBlIG9mIGFjdGlvbiAnY29weScgb3IgJ2N1dCcoY3V0IG9ubHkgZm9yIHRleHQgaW5wdXQgZmllbGQgYW5kIHRleHRhcmVhIGZpZWxkKVxyXG4gKiBcdGRvbmVDbGFzczogPHN0cmluZz4gLSBjc3MgY2xhc3MgZm9yIHN1Y2Nlc3NmdWwgYWN0aW9uIChkZWZhdWx0IGlzIGRvbmUpXHJcbiAqIFx0ZXJyb3JDbGFzczogPHN0cmluZz4gLSBjc3MgY2xhc3MgZm9yIGVycm9yIGFjdGlvbiAoZGVmYXVsdCBpcyBlcnJvcilcclxuICogXHRhbmltYXRpb25UaW1lOiA8bnVtYmVyPiAoZGVmYXVsdCBpcyA1MDApXHJcbiAqXHJcbiAqIGxpbmsgdG8gc291cmNlOiBodHRwczovL2NsaXBib2FyZGpzLmNvbVxyXG4gKi9cclxua28uYmluZGluZ0hhbmRsZXJzLmNvcHlUb0NsaXBib2FyZCA9IHtcclxuXHRpbml0OiBmdW5jdGlvbihlbGVtZW50LCB2YWx1ZUFjY2Vzc29yLCBhbGxCaW5kaW5ncywgdmlld01vZGVsLCBiaW5kaW5nQ29udGV4dCkge1xyXG5cdFx0bGV0ICRlbGVtZW50ID0gJChlbGVtZW50KTtcclxuXHRcdGxldCBwYXJhbXMgPSB2YWx1ZUFjY2Vzc29yKCk7XHJcblx0XHRsZXQgZG9uZSA9IHBhcmFtcy5kb25lQ2xhc3MgfHwgJ2RvbmUnO1xyXG5cdFx0bGV0IGVycm9yID0gcGFyYW1zLmVycm9yQ2xhc3MgfHwgJ2Vycm9yJztcclxuXHRcdGxldCBhbmltYXRpb25UaW1lID0gcGFyYW1zLmFuaW1hdGlvblRpbWUgfHwgNTAwO1xyXG5cclxuXHRcdGVsZW1lbnQuY2xpcGJvYXJkID0gbmV3IENsaXBib2FyZChlbGVtZW50LCB7XHJcblx0XHRcdGFjdGlvbih0cmlnZ2VyKSB7XHJcblx0XHRcdFx0cmV0dXJuICBwYXJhbXMuYWN0aW9uIHx8ICdjb3B5JztcclxuXHRcdFx0fSxcclxuXHRcdFx0dGFyZ2V0KHRyaWdnZXIpIHtcclxuXHRcdFx0XHRyZXR1cm4gcGFyYW1zLnRhcmdldDtcclxuXHRcdFx0fSxcclxuXHRcdFx0dGV4dCh0cmlnZ2VyKSB7XHJcblx0XHRcdFx0cmV0dXJuIGtvLnVud3JhcChwYXJhbXMudGV4dCk7XHJcblx0XHRcdH0sXHJcblx0XHR9KTtcclxuXHJcblx0XHRlbGVtZW50LmNsaXBib2FyZFxyXG5cdFx0XHQub24oJ3N1Y2Nlc3MnLCBlID0+IHtcclxuXHRcdFx0XHQkZWxlbWVudC5hZGRDbGFzcyhkb25lKTtcclxuXHRcdFx0XHRzZXRUaW1lb3V0KCgpID0+ICRlbGVtZW50LnJlbW92ZUNsYXNzKGRvbmUpLCBhbmltYXRpb25UaW1lKTtcclxuXHRcdFx0XHRlLmNsZWFyU2VsZWN0aW9uKCk7XHJcblx0XHRcdH0pXHJcblx0XHRcdC5vbignZXJyb3InLCBlID0+IHtcclxuXHRcdFx0XHQkZWxlbWVudC5hZGRDbGFzcyhlcnJvcik7XHJcblx0XHRcdFx0c2V0VGltZW91dCgoKSA9PiAkZWxlbWVudC5yZW1vdmVDbGFzcyhlcnJvciksIGFuaW1hdGlvblRpbWUpO1xyXG5cdFx0XHRcdGNvbnNvbGUuZXJyb3IoJ2NvcHlUb0NsaXBib2FyZCBjdXN0b20gYmluZGluZyAtIEFjdGlvbjonLCBlLmFjdGlvbik7XHJcblx0XHRcdFx0Y29uc29sZS5lcnJvcignY29weVRvQ2xpcGJvYXJkIGN1c3RvbSBiaW5kaW5nIC0gVHJpZ2dlcjonLCBlLnRyaWdnZXIpO1xyXG5cdFx0XHR9KTtcclxuXHJcblx0XHRrby51dGlscy5kb21Ob2RlRGlzcG9zYWwuYWRkRGlzcG9zZUNhbGxiYWNrKGVsZW1lbnQsICgpID0+IHtcclxuXHRcdFx0aWYgKCRlbGVtZW50LmNsaXBib2FyZCAmJiB0eXBlb2YgJGVsZW1lbnQuY2xpcGJvYXJkLmRlc3Ryb3kgPT09IFwiZnVuY3Rpb25cIikge1xyXG5cdFx0XHRcdCRlbGVtZW50LmNsaXBib2FyZCAmJiAkZWxlbWVudC5jbGlwYm9hcmQuZGVzdHJveSgpO1xyXG5cdFx0XHRcdGRlbGV0ZSAkZWxlbWVudC5jbGlwYm9hcmQ7XHJcblx0XHRcdH1cclxuXHRcdH0pO1xyXG5cdH1cclxufTtcclxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc2NyaXB0cy9hcGktZXhwbG9yZXIvdjIvc3JjL2N1c3RvbUJpbmRpbmdzL2NvcHlDbGlwYm9hcmQuYmluZGluZy5qcyIsIiBtb2R1bGUuZXhwb3J0cyA9IGtvLmJpbmRpbmdIYW5kbGVycy5mb3JlYWNocHJvcCA9IHtcclxuXHJcblx0dHJhbnNmb3JtT2JqZWN0OiBmdW5jdGlvbiAocGFyYW1zKSB7XHJcblx0XHR2YXIgcHJvcGVydGllcyA9IFtdO1xyXG5cdFx0dmFyIG9iaiwgc29ydEZuID0gcGFyYW1zLnNvcnRGbjtcclxuXHJcblx0XHRvYmogPSBzb3J0Rm4gPyBwYXJhbXMuZGF0YTogcGFyYW1zO1xyXG5cdFx0b2JqID0ga28udXRpbHMudW53cmFwT2JzZXJ2YWJsZShvYmopO1xyXG5cclxuXHRcdGtvLnV0aWxzLm9iamVjdEZvckVhY2gob2JqLCBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xyXG5cdFx0XHRwcm9wZXJ0aWVzLnB1c2goe1xyXG5cdFx0XHRcdGtleToga2V5LFxyXG5cdFx0XHRcdHZhbHVlOiB2YWx1ZVxyXG5cdFx0XHR9KTtcclxuXHRcdH0pO1xyXG5cclxuXHRcdGlmIChzb3J0Rm4pIHtcclxuXHRcdFx0cHJvcGVydGllcy5zb3J0KHNvcnRGbik7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHByb3BlcnRpZXM7XHJcblx0fSxcclxuXHRpbml0OiBmdW5jdGlvbihlbGVtZW50LCB2YWx1ZUFjY2Vzc29yLCBhbGxCaW5kaW5nc0FjY2Vzc29yLCB2aWV3TW9kZWwsIGJpbmRpbmdDb250ZXh0KSB7XHJcblx0XHR2YXIgcHJvcGVydGllcyA9IGtvLnB1cmVDb21wdXRlZChmdW5jdGlvbiAoKSB7XHJcblx0XHRcdHZhciBvYmogPSBrby51dGlscy51bndyYXBPYnNlcnZhYmxlKHZhbHVlQWNjZXNzb3IoKSk7XHJcblx0XHRcdHJldHVybiBrby5iaW5kaW5nSGFuZGxlcnMuZm9yZWFjaHByb3AudHJhbnNmb3JtT2JqZWN0KG9iaik7XHJcblx0XHR9KTtcclxuXHRcdGtvLmFwcGx5QmluZGluZ3NUb05vZGUoZWxlbWVudCwge1xyXG5cdFx0XHRmb3JlYWNoOiBwcm9wZXJ0aWVzXHJcblx0XHR9LCBiaW5kaW5nQ29udGV4dCk7XHJcblx0XHRyZXR1cm4ge1xyXG5cdFx0XHRjb250cm9sc0Rlc2NlbmRhbnRCaW5kaW5nczogdHJ1ZVxyXG5cdFx0fTtcclxuXHR9XHJcbn07XHJcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NjcmlwdHMvYXBpLWV4cGxvcmVyL3YyL3NyYy9jdXN0b21CaW5kaW5ncy9mb3JlYWNoUHJvcC5iaW5kaW5nLmpzIiwiXHJcbmtvLmJpbmRpbmdIYW5kbGVycy5pbWdPbkVycm9yID0ge1xyXG5cdGluaXQ6IGZ1bmN0aW9uKGVsZW1lbnQsIHZhbHVlQWNjZXNzb3IsIGFsbEJpbmRpbmdzLCB2aWV3TW9kZWwsIGJpbmRpbmdDb250ZXh0KSB7XHJcblx0XHRsZXQgJGVsZW1lbnQgPSAkKGVsZW1lbnQpO1xyXG5cdFx0bGV0IHBhcmFtcyA9IHZhbHVlQWNjZXNzb3IoKTtcclxuXHJcblx0XHQkZWxlbWVudFxyXG5cdFx0XHQub24oJ2Vycm9yJywgZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0Y29uc29sZS53YXJuKCdlcnJvcicpO1xyXG5cdFx0XHRcdCRlbGVtZW50LnBhcmVudHMoJy5tYXAtcGFuZWwtYm9keScpLmNzcygnZGlzcGxheScsICdub25lJyk7XHJcblx0XHRcdH0pO1xyXG5cdFx0a28udXRpbHMuZG9tTm9kZURpc3Bvc2FsLmFkZERpc3Bvc2VDYWxsYmFjayhlbGVtZW50LCAoKSA9PiB7XHJcblx0XHRcdGlmICgkZWxlbWVudC5jbGlwYm9hcmQgJiYgdHlwZW9mICRlbGVtZW50LmNsaXBib2FyZC5kZXN0cm95ID09PSBcImZ1bmN0aW9uXCIpIHtcclxuXHRcdFx0XHQkZWxlbWVudC5jbGlwYm9hcmQgJiYgJGVsZW1lbnQuY2xpcGJvYXJkLmRlc3Ryb3koKTtcclxuXHRcdFx0XHRkZWxldGUgJGVsZW1lbnQuY2xpcGJvYXJkO1xyXG5cdFx0XHR9XHJcblx0XHR9KTtcclxuXHR9XHJcbn07XHJcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NjcmlwdHMvYXBpLWV4cGxvcmVyL3YyL3NyYy9jdXN0b21CaW5kaW5ncy9pbWdPbkVycm9yLmJpbmRpbmcuanMiLCJyZXF1aXJlKCcuL2Jsb2NrRWxsaXBzaXMuYmluZGluZycpO1xyXG5yZXF1aXJlKCcuL2ZvcmVhY2hQcm9wLmJpbmRpbmcnKTtcclxucmVxdWlyZSgnLi9wb3BvdmVyLmJpbmRpbmcnKTtcclxucmVxdWlyZSgnLi9jb3B5Q2xpcGJvYXJkLmJpbmRpbmcnKTtcclxucmVxdWlyZSgnLi9sYXp5TG9hZGVyLmJpbmRpbmcnKTtcclxucmVxdWlyZSgnLi9jbGFzc2lmaWNhdGlvbnNNYXAuYmluZGluZycpO1xyXG5yZXF1aXJlKCcuL2ltZ09uRXJyb3IuYmluZGluZycpXHJcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NjcmlwdHMvYXBpLWV4cGxvcmVyL3YyL3NyYy9jdXN0b21CaW5kaW5ncy9pbmRleC5qcyIsImtvLmJpbmRpbmdIYW5kbGVycy5sYXp5TG9hZGVyID0ge1xyXG5cdGluaXQ6IGZ1bmN0aW9uKGVsZW1lbnQsIHZhbHVlQWNjZXNzb3IpIHtcclxuXHRcdGxldCBwYXJhbXMgPSB2YWx1ZUFjY2Vzc29yKCk7XHJcblx0XHRsZXQgbmFtZSA9IHBhcmFtcy5uYW1lLnRvTG93ZXJDYXNlKCk7XHJcblx0XHRsZXQgZGF0ZXNBcnIgPSBbXHJcblx0XHRcdCdzdGFydERhdGVUaW1lJyxcclxuXHRcdFx0J2VuZERhdGVUaW1lJyxcclxuXHRcdFx0J29uc2FsZVN0YXJ0RGF0ZVRpbWUnLFxyXG5cdFx0XHQnb25zYWxlRW5kRGF0ZVRpbWUnXHJcblx0XHRdO1xyXG5cdFx0bGV0IGRhdGVJbmRleCA9IGRhdGVzQXJyLmluZGV4T2YocGFyYW1zLm5hbWUpO1xyXG5cclxuXHRcdGxldCBzZWxlY3RvciA9IG5hbWUgPT09ICd2ZW51ZWlkJyA/ICd2ZW51ZXMnIDogbmFtZSA9PT0gJ2F0dHJhY3Rpb25pZCcgPyAnYXR0cmFjdGlvbnMnOiAnJztcclxuXHRcdGxldCB0eXBlID0gbmFtZSA9PT0gJ2NsYXNzaWZpY2F0aW9uaWQnID8gJ2lkJyA6IG5hbWUgPT09ICdjbGFzc2lmaWNhdGlvbm5hbWUnID8gJ25hbWUnIDogJyc7XHJcblxyXG5cdFx0aWYgKGRhdGVJbmRleCAhPT0gLTEpIHtcclxuXHRcdFx0YWRkQ2FsZW5kYXIoKTtcclxuXHRcdH0gZWxzZSBpZiAoc2VsZWN0b3IgfHwgdHlwZSkge1xyXG5cdFx0XHRzZWxlY3RvciA/ICQoZWxlbWVudCkubGF6eVNlbGVjdG9yKHtzZWxlY3Rvcn0pIDogJChlbGVtZW50KS5jbGFzc2lmaWNhdGlvblNlbGVjdG9yKHtzZWxlY3RvcjonY2xhc3NpZmljYXRpb25zJywgdXNlOiB0eXBlfSk7XHJcblxyXG5cdFx0XHQkKGVsZW1lbnQpLm9uKCdjaGFuZ2UnLCBmdW5jdGlvbigpIHtcclxuXHRcdFx0XHRwYXJhbXMudmFsKCQodGhpcykudmFsKCkpXHJcblx0XHRcdH0pXHJcblx0XHR9IGVsc2UgaWYocGFyYW1zLm5hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ2xhdGxvbmcnKXtcclxuXHRcdFx0YWRkTGF0bG9uZygpO1xyXG5cdFx0fVxyXG5cdFx0XHJcblx0XHRmdW5jdGlvbiBhZGRDYWxlbmRhcigpIHtcclxuXHRcdFx0bGV0IGJ0biA9ICQoJzxidXR0b24gY2xhc3M9XCJjdXN0b20taW5wdXRfX2J1dHRvblwiPiZuYnNwOzwvYnV0dG9uPicpO1xyXG5cdFx0XHRsZXQgbGFiZWwgPSBkYXRlc0FycltkYXRlSW5kZXhdO1xyXG5cdFx0XHRsZXQgc2VsZWN0b3IgPSAkKGVsZW1lbnQpO1xyXG5cclxuXHRcdFx0c2VsZWN0b3IuYWZ0ZXIoYnRuKTtcclxuXHRcdFx0YnRuLm9uKCBcImNsaWNrXCIsIGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRcdE5ld0Nzc0NhbChsYWJlbCwgJ3l5eXlNTWRkJywgJ2Ryb3Bkb3duJywgdHJ1ZSwgJzI0Jyk7XHJcblx0XHRcdH0pO1xyXG5cclxuXHRcdFx0c2VsZWN0b3Iub24oJ29uY2hhbmdlJywgZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0cGFyYW1zLnZhbCgkKHRoaXMpLnZhbCgpKVxyXG5cdFx0XHR9KVxyXG5cdFx0fVxyXG5cdFx0XHJcblx0XHRmdW5jdGlvbiBhZGRMYXRsb25nKCkge1xyXG5cdFx0XHRsZXQgJGlucHV0ID0gJChlbGVtZW50KSxcclxuXHRcdFx0XHRidG5MYXRsb25nID0gJCgnPGEgaHJlZj1cIiNcIiBpZD1cImpzX3dpZGdldF9tb2RhbF9tYXBfX29wZW5cIiBjbGFzcz1cImxhdGxvbmctcGlja2VyXCI+PC9hPicpLFxyXG5cdFx0XHRcdCR3aWRnZXRNb2RhbE1hcCA9ICQoJyNqc193aWRnZXRfbW9kYWxfbWFwJyk7XHJcblxyXG5cdFx0XHQkaW5wdXQuYWZ0ZXIoYnRuTGF0bG9uZyk7XHJcblxyXG5cdFx0XHRidG5MYXRsb25nLm9uKCdjbGljaycsIGZ1bmN0aW9uKGUpe1xyXG5cdFx0XHRcdGUucHJldmVudERlZmF1bHQoKTtcclxuXHRcdFx0XHQkd2lkZ2V0TW9kYWxNYXAubW9kYWwoJ3Nob3cnKTtcclxuXHRcdFx0XHRnb29nbGUubWFwcy5ldmVudC50cmlnZ2VyKG1hcF9sYXRsb25nLCAncmVzaXplJyk7XHJcblx0XHRcdH0pO1xyXG5cclxuXHRcdFx0JCgnI2pzX3dpZGdldF9tb2RhbF9tYXAnKS5vbignc2hvd24uYnMubW9kYWwnLCBmdW5jdGlvbigpIHtcclxuXHRcdFx0XHRnb29nbGUubWFwcy5ldmVudC50cmlnZ2VyKG1hcF9sYXRsb25nLCAncmVzaXplJyk7XHJcblx0XHRcdFx0LypzZXQgc2VudGVyIG9uIG1hcF9vcGVuKi9cclxuXHRcdFx0XHQvKlxyXG5cdFx0XHRcdHZhciB0bXBfY3VycmVudExhdExuZyA9ICRpbnB1dC52YWwoKS5zcGxpdCgnLCcpOyAvL2RvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdsYXRsb25nJykudmFsdWUuc3BsaXQoJywnKTtcclxuXHRcdFx0XHR2YXIgY3VycmVudExhdExuZyA9IG5ldyBnb29nbGUubWFwcy5MYXRMbmcocGFyc2VJbnQodG1wX2N1cnJlbnRMYXRMbmdbMF0ucmVwbGFjZSgvXFxzKy9nLCAnJykpfHw0OS4yMzM2Mjg3LCBwYXJzZUludCh0bXBfY3VycmVudExhdExuZ1sxXS5yZXBsYWNlKC9cXHMrL2csICcnKSl8fDI4LjQ2Njk0OTUpO1xyXG5cdFx0XHRcdG1hcF9sYXRsb25nLnNldENlbnRlcihjdXJyZW50TGF0TG5nKTtcclxuXHRcdFx0XHQqL1xyXG5cdFx0XHR9KTtcclxuXHJcblx0XHRcdCQoJyNqc193aWRnZXRfbW9kYWxfbWFwX19jbG9zZScpLm9uKCdjbGljaycsIGZ1bmN0aW9uKCl7XHJcblx0XHRcdFx0JHdpZGdldE1vZGFsTWFwLm1vZGFsKCdoaWRlJyk7XHJcblx0XHRcdFx0JGlucHV0LnZhbCgkaW5wdXQudmFsKCkucmVwbGFjZSgvXFxzKy9nLCAnJykpO1xyXG5cdFx0XHRcdHBhcmFtcy52YWwoJGlucHV0LnZhbCgpKTsgLy9pbnN0ZWFkIG9mICdvbmNoYW5nZSdcclxuXHRcdFx0fSk7XHJcblxyXG5cdFx0fVxyXG5cdH1cclxufTtcclxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc2NyaXB0cy9hcGktZXhwbG9yZXIvdjIvc3JjL2N1c3RvbUJpbmRpbmdzL2xhenlMb2FkZXIuYmluZGluZy5qcyIsInZhciBjb21tb24gPSB7XHJcblx0Y29udGFpbmVyOiAnYm9keScsXHJcblx0dHJpZ2dlcjogJ2hvdmVyJyxcclxuXHRwbGFjZW1lbnQ6ICdib3R0b20nXHJcbn07XHJcblxyXG5rby5iaW5kaW5nSGFuZGxlcnMucG9wb3ZlciA9IHtcclxuXHR1cGRhdGU6IGZ1bmN0aW9uKGVsZW1lbnQsIHZhbHVlQWNjZXNzb3IpIHtcclxuXHRcdHZhciAkZWxlbWVudCA9ICQoZWxlbWVudCk7XHJcblx0XHR2YXIgcGFyYW1zID0gdmFsdWVBY2Nlc3NvcigpO1xyXG5cdFx0dmFyIGNvbmZpZyA9ICQuZXh0ZW5kKHt9LCBjb21tb24sIHBhcmFtcywge2RhdGE6IG51bGx9KTtcclxuXHJcblx0XHRpZiAocGFyYW1zLnR5cGUgPT09ICdwb3BvdmVyJyAmJiBwYXJhbXMuZGF0YSkge1xyXG5cdFx0XHR2YXIgZGF0YSA9IGtvLnVud3JhcChwYXJhbXMuZGF0YSk7XHJcblx0XHRcdGNvbmZpZy50aXRsZSA9IGBFcnJvciAke2RhdGFbMF19OiAke2RhdGFbMV19YDtcclxuXHRcdFx0Y29uZmlnLmNvbnRlbnQgPSBkYXRhWzJdO1xyXG5cdFx0XHQkZWxlbWVudC5wb3BvdmVyKGNvbmZpZyk7XHJcblx0XHRcdGlmIChjb25maWcudHJpZ2dlciA9PT0gJ2NsaWNrJykge1xyXG5cdFx0XHRcdHZhciB0aW1lcjtcclxuXHRcdFx0XHQkZWxlbWVudC5vbignc2hvd24uYnMucG9wb3ZlcicsIGZ1bmN0aW9uICgpIHtcclxuXHRcdFx0XHRcdHRpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XHJcblx0XHRcdFx0XHRcdCRlbGVtZW50LnRyaWdnZXIoJ2NsaWNrJyk7XHJcblx0XHRcdFx0XHR9LCAyMDAwKTtcclxuXHRcdFx0XHR9KTtcclxuXHRcdFx0XHQkZWxlbWVudC5vbignaGlkZS5icy5wb3BvdmVyJywgZnVuY3Rpb24gKCkge1xyXG5cdFx0XHRcdFx0Y2xlYXJJbnRlcnZhbCh0aW1lcik7XHJcblx0XHRcdFx0fSk7XHJcblx0XHRcdH1cclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdGNvbmZpZy5kZWxheSA9IHtcclxuXHRcdFx0XHRcInNob3dcIjogMTUwMCxcclxuXHRcdFx0XHRcImhpZGVcIjogMTAwXHJcblx0XHRcdH07XHJcblx0XHRcdGNvbmZpZy50aXRsZSA9IHBhcmFtcy50aXRsZSB8fCBjb25maWcudGl0bGU7XHJcblx0XHRcdCRlbGVtZW50LnRvb2x0aXAoY29uZmlnKTtcclxuXHRcdH1cclxuXHR9XHJcbn07XHJcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NjcmlwdHMvYXBpLWV4cGxvcmVyL3YyL3NyYy9jdXN0b21CaW5kaW5ncy9wb3BvdmVyLmJpbmRpbmcuanMiLCJyZXF1aXJlKCdqc3RyZWUnKTtcclxucmVxdWlyZSgnbGF6eS1zZWxlY3RvcicpO1xyXG5yZXF1aXJlKCdjbGFzc2lmaWNhdGlvbi1zZWxlY3RvcicpO1xyXG5yZXF1aXJlKCdib290c3RyYXAubWluJyk7XHJcbnJlcXVpcmUoJy4vdmFsaWRhdGlvbicpO1xyXG5yZXF1aXJlKCdzbGljay5taW4nKTtcclxucmVxdWlyZSgna25vY2tvdXQtc2Nyb2xsYmFyJyk7XHJcbnJlcXVpcmUoJ2NsYW1wLm1pbicpO1xyXG5yZXF1aXJlKCdrbm9ja291dC1wb3N0Ym94Jyk7XHJcbnJlcXVpcmUoJ2RhdGV0aW1lcGlja2VyJyk7XHJcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NjcmlwdHMvYXBpLWV4cGxvcmVyL3YyL3NyYy9tb2R1bGVzL2luZGV4LmpzIiwiY29uc3QgY29uZmlnID0ge1xyXG5cdGRvdHM6IGZhbHNlLFxyXG5cdGluZmluaXRlOiBmYWxzZSxcclxuXHRzcGVlZDogMzAwLFxyXG5cdHNsaWRlc1RvU2hvdzogMyxcclxuXHRzbGlkZXNUb1Njcm9sbDogMSxcclxuXHRhdXRvcGxheTogZmFsc2UsXHJcblx0Zm9jdXNPblNlbGVjdDogdHJ1ZSxcclxuXHRyZXNwb25zaXZlOiBbXHJcblx0XHR7XHJcblx0XHRcdGJyZWFrcG9pbnQ6IDEyMDAsXHJcblx0XHRcdHNldHRpbmdzOiB7XHJcblx0XHRcdFx0ZG90czogdHJ1ZSxcclxuXHRcdFx0XHRzbGlkZXNUb1Nob3c6IDIsXHJcblx0XHRcdFx0c2xpZGVzVG9TY3JvbGw6IDEsXHJcblx0XHRcdH1cclxuXHRcdH0sXHJcblx0XHR7XHJcblx0XHRcdGJyZWFrcG9pbnQ6IDgwMCxcclxuXHRcdFx0c2V0dGluZ3M6IHtcclxuXHRcdFx0XHRkb3RzOiB0cnVlLFxyXG5cdFx0XHRcdHNsaWRlc1RvU2hvdzogMSxcclxuXHRcdFx0XHRzbGlkZXNUb1Njcm9sbDogMVxyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XVxyXG59O1xyXG5cclxuZnVuY3Rpb24gc2xpY2sodGltZXMpIHtcclxuXHRcInVzZSBzdHJpY3RcIjtcclxuXHR2YXIgc2VsZWN0b3IgPSAnI3NsaWRlci0nO1xyXG5cclxuXHRmb3IgKGxldCBpID0gMDsgaSA8IHRpbWVzOyBpKyspIHtcclxuXHRcdGxldCBzbGlkZXIgPSAkKHNlbGVjdG9yICsgaSk7XHJcblx0XHRpZihzbGlkZXIubGVuZ3RoKSB7XHJcblx0XHRcdHNsaWRlci5zbGljayhjb25maWcpO1xyXG5cdFx0fVxyXG5cdH1cclxufVxyXG5cclxuZnVuY3Rpb24gdW5zbGljayh0aW1lcykge1xyXG5cdFwidXNlIHN0cmljdFwiO1xyXG5cclxuXHRmb3IgKGxldCBpID0gMDsgaSA8IHRpbWVzOyBpKyspIHtcclxuXHRcdGxldCBzbGlkZXIgPSAkKCcjc2xpZGVyLScgKyBpKTtcclxuXHRcdHNsaWRlci5sZW5ndGggJiYgc2xpZGVyLnNsaWNrKCd1bnNsaWNrJyk7XHJcblx0fVxyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IHtcclxuXHRzZXQ6IHNsaWNrLFxyXG5cdHJlbW92ZTogdW5zbGlja1xyXG59O1xyXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zY3JpcHRzL2FwaS1leHBsb3Jlci92Mi9zcmMvbW9kdWxlcy9zbGlkZXIuanMiLCJyZXF1aXJlKCdrbm9ja291dC52YWxpZGF0aW9uJyk7XHJcblxyXG5rby52YWxpZGF0aW9uLnJ1bGVzLnBhdHRlcm4ubWVzc2FnZSA9ICdJbnZhbGlkLic7XHJcblxyXG5rby52YWxpZGF0aW9uLmluaXQoe1xyXG5cdHJlZ2lzdGVyRXh0ZW5kZXJzOiB0cnVlLFxyXG5cdG1lc3NhZ2VzT25Nb2RpZmllZDogdHJ1ZSxcclxuXHRkZWNvcmF0ZUlucHV0RWxlbWVudDogdHJ1ZSxcclxuXHRlcnJvck1lc3NhZ2VDbGFzczogJ2N1c3RvbS1pbnB1dF9fdmFsaWRhdGlvbi1tZXNzYWdlJyxcclxuXHRlcnJvckVsZW1lbnRDbGFzczogJ25vdC12YWxpZCcsXHJcblx0aW5zZXJ0TWVzc2FnZXM6IGZhbHNlLFxyXG5cdHBhcnNlSW5wdXRBdHRyaWJ1dGVzOiB0cnVlLFxyXG5cdG1lc3NhZ2VUZW1wbGF0ZTogbnVsbCxcclxuXHRncm91cGluZzoge1xyXG5cdFx0ZGVlcDogdHJ1ZSxcclxuXHRcdGxpdmU6IHRydWUsXHJcblx0XHRvYnNlcnZhYmxlOiB0cnVlXHJcblx0fVxyXG59LCB0cnVlKTtcclxuXHJcbmtvLnZhbGlkYXRpb24ucnVsZXNbJ251bGxhYmxlSW50J10gPSB7XHJcblx0dmFsaWRhdG9yOiBmdW5jdGlvbiAodmFsLCB2YWxpZGF0ZSkge1xyXG5cdFx0cmV0dXJuIHZhbCA9PT0gbnVsbCB8fCB2YWwgPT09IFwiXCIgfHwgdmFsID09PSAwIHx8ICh2YWxpZGF0ZSAmJiAvXi0/XFxkKiQvLnRlc3QodmFsLnRvU3RyaW5nKCkpKTtcclxuXHR9LFxyXG5cdG1lc3NhZ2U6ICdNdXN0IGJlIGVtcHR5IG9yIGFuIGludGVnZXIgdmFsdWUnXHJcbn07XHJcblxyXG5rby52YWxpZGF0aW9uLnJ1bGVzWydudWxsYWJsZURlY2ltYWwnXSA9IHtcclxuXHR2YWxpZGF0b3I6IGZ1bmN0aW9uICh2YWwsIHZhbGlkYXRlKSB7XHJcblx0XHRyZXR1cm4gdmFsID09PSBudWxsIHx8IHZhbCA9PT0gXCJcIiB8fCAodmFsaWRhdGUgJiYgL14tP1xcZCooPzpcXC5cXGQqKT8kLy50ZXN0KHZhbC50b1N0cmluZygpKSk7XHJcblx0fSxcclxuXHRtZXNzYWdlOiAnTXVzdCBiZSBlbXB0eSBvciBhIGRlY2ltYWwgdmFsdWUnXHJcbn07XHJcblxyXG5rby52YWxpZGF0aW9uLnJlZ2lzdGVyRXh0ZW5kZXJzKCk7XHJcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NjcmlwdHMvYXBpLWV4cGxvcmVyL3YyL3NyYy9tb2R1bGVzL3ZhbGlkYXRpb24uanMiLCIvKipcclxuICogQ29sb3JzIHNlcnZpY2UgKHNpbmdsZXRvbilcclxuICovXHJcblxyXG52YXIgbnVtID0gU3ltYm9sKCdOVU0nKTtcclxudmFyIHByZWZpeCA9IFN5bWJvbCgnUFJFRklYJyk7XHJcbmxldCBpbnN0YW5jZSA9IG51bGw7XHJcblxyXG5jbGFzcyBDb2xvcnNTZXJ2aWNlIHtcclxuXHRjb25zdHJ1Y3RvcihOVU0gPSAxMiwgUFJFRklYID0gJ2NvbG9yLScpIHtcclxuXHRcdGlmICghaW5zdGFuY2UpIHtcclxuXHRcdFx0aW5zdGFuY2UgPSB0aGlzO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXNbbnVtXSA9IE5VTTtcclxuXHRcdHRoaXNbcHJlZml4XSA9IFBSRUZJWDtcclxuXHRcdHRoaXMuY29sb3JzID0gdGhpcy5nZXRDb2xvcnMoKTtcclxuXHJcblx0XHRyZXR1cm4gaW5zdGFuY2U7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBHZXRzIHJhbmRvbSBjb2xvciBjc3MgY2xhc3NcclxuXHQgKiBAcGFyYW0gY29sb3Ige3N0cmluZ30gZXhpc3RpbmcgY3NzIGNsYXNzIHRvIHByZXZlbnQgbWFjaFxyXG5cdCAqIEByZXR1cm5zIHtzdHJpbmd9IGNzcyBjbGFzcyBuYW1lXHJcblx0ICovXHJcblx0Z2V0UmFuZG9tQ29sb3IoY29sb3IpIHtcclxuXHRcdGxldCByYW5kb21OdW1iZXI7XHJcblx0XHRsZXQgUFJFRklYID0gdGhpc1twcmVmaXhdO1xyXG5cdFx0ZG8ge1xyXG5cdFx0XHRyYW5kb21OdW1iZXIgPSB0aGlzLmNvbnN0cnVjdG9yLmdldFJhbmRvbUludCgxLCB0aGlzLmNvbG9ycy5sZW5ndGgpO1xyXG5cdFx0fSB3aGlsZSAoUFJFRklYICsgcmFuZG9tTnVtYmVyID09PSBjb2xvcik7XHJcblxyXG5cdFx0cmV0dXJuIFBSRUZJWCArIHJhbmRvbU51bWJlcjtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIEJ1aWxkcyBhcnJheSBvZiBjb2xvcnMgY3NzIGNsYXNzZXNcclxuXHQgKiBAcmV0dXJucyB7QXJyYXl9IGFycmF5IG9mIHN0cmluZ3NcclxuXHQgKi9cclxuXHRnZXRDb2xvcnMoKSB7XHJcblx0XHRsZXQgY29sb3JzID0gbmV3IEFycmF5KHRoaXNbbnVtXSk7XHJcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGNvbG9ycy5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHRjb2xvcnNbaV0gPSB0aGlzW3ByZWZpeF0gKyAoaSArIDEpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIGNvbG9ycztcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFJldHVybnMgYSByYW5kb20gaW50ZWdlciBiZXR3ZWVuIG1pbiAoaW5jbHVzaXZlKSBhbmQgbWF4IChpbmNsdXNpdmUpXHJcblx0ICogVXNpbmcgTWF0aC5yb3VuZCgpIHdpbGwgZ2l2ZSB5b3UgYSBub24tdW5pZm9ybSBkaXN0cmlidXRpb24hXHJcblx0ICovXHJcblx0c3RhdGljIGdldFJhbmRvbUludChtaW4sIG1heCkge1xyXG5cdFx0cmV0dXJuIE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIChtYXggLSBtaW4gKyAxKSkgKyBtaW47XHJcblx0fVxyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IG5ldyBDb2xvcnNTZXJ2aWNlKCk7XHJcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NjcmlwdHMvYXBpLWV4cGxvcmVyL3YyL3NyYy9zZXJ2aWNlcy9jb2xvcnMuc2VydmljZS5qcyIsInZhciBjb25maWcgPSBrby5vYnNlcnZhYmxlKCk7XHJcblxyXG4kLmFqYXgoe1xyXG5cdHR5cGU6ICdHRVQnLFxyXG5cdHVybDogW1xyXG5cdFx0J2h0dHA6Ly8nLFxyXG5cdFx0ZG9jdW1lbnQubG9jYXRpb24uaG9zdG5hbWUsXHJcblx0XHRkb2N1bWVudC5sb2NhdGlvbi5wb3J0ICYmICc6JyArIGRvY3VtZW50LmxvY2F0aW9uLnBvcnQsXHJcblx0XHQnL3NjcmlwdHMvYXBpLWV4cGxvcmVyL3YyL2NvbmZpZy5qc29uJ1xyXG5cdF0uam9pbignJyksXHJcblx0YXN5bmM6IHRydWUsXHJcblx0ZGF0YVR5cGU6IFwianNvblwiLFxyXG5cdGNvbXBsZXRlOiBmdW5jdGlvbihyZXMsIG1zZykge1xyXG5cdFx0aWYgKG1zZyA9PSAnZXJyb3InKSB7XHJcblx0XHRcdGNvbnNvbGUuZXJyb3IoJ2NhblxcJ3QgbG9hZCBjb25maWcuanNvbiEnKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdGNvbmZpZyhyZXMucmVzcG9uc2VKU09OKTtcclxuXHRcdH1cclxuXHR9XHJcbn0pO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBjb25maWc7XHJcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NjcmlwdHMvYXBpLWV4cGxvcmVyL3YyL3NyYy9zZXJ2aWNlcy9jb25maWcuc2VydmljZS5qcyIsInZhciBXb3JrZXIgPSByZXF1aXJlKCcuL2hpZ2hsaWdodEpzb24ud29ya2VyLmpzJyk7IC8vIEpzb24tZm9ybWF0dGVyIHdvcmtlclxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAob2JzZXJ2YWJsZSwgY29kZSkge1xyXG5cdHZhciBhbmltVGltZSA9IDEwMDtcclxuXHR2YXIgd29ya2VyID0gbmV3IFdvcmtlcjtcclxuXHJcblx0d29ya2VyLm9ubWVzc2FnZSA9IGZ1bmN0aW9uIChldmVudCkge1xyXG5cdFx0b2JzZXJ2YWJsZShldmVudC5kYXRhKTtcclxuXHJcblx0XHQkKGRvY3VtZW50KVxyXG5cdFx0XHQub24oJ2NsaWNrIHRvdWNoJywgJy50bS1jb2RlLWNvbnRhaW5lciAuZXhwYW5kZWQnLCBmdW5jdGlvbiBqc29uQ29kZUNvbnRhaW5lckV4cGFuZGVkKGUpIHtcclxuXHRcdFx0XHRlLnByZXZlbnREZWZhdWx0KCk7XHJcblx0XHRcdFx0ZS5zdG9wUHJvcGFnYXRpb24oKTtcclxuXHRcdFx0XHR2YXIgJHNlbGYgPSAkKHRoaXMpO1xyXG5cdFx0XHRcdCRzZWxmXHJcblx0XHRcdFx0XHQucGFyZW50KClcclxuXHRcdFx0XHRcdC5maW5kKCc+dWwnKVxyXG5cdFx0XHRcdFx0LnNsaWRlVXAoYW5pbVRpbWUsIGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRcdFx0XHQkc2VsZi5hZGRDbGFzcygnY29sbGFwc2VkJyk7XHJcblx0XHRcdFx0XHR9KTtcclxuXHRcdFx0fSlcclxuXHRcdFx0Lm9uKCdjbGljayB0b3VjaCcsICcudG0tY29kZS1jb250YWluZXIgLmV4cGFuZGVkLmNvbGxhcHNlZCcsIGZ1bmN0aW9uIGpzb25Db2RlQ29udGFpbmVyQ29sbGFwc2VkKGUpIHtcclxuXHRcdFx0XHRlLnByZXZlbnREZWZhdWx0KCk7XHJcblx0XHRcdFx0ZS5zdG9wUHJvcGFnYXRpb24oKTtcclxuXHRcdFx0XHR2YXIgJHNlbGYgPSAkKHRoaXMpO1xyXG5cdFx0XHRcdCRzZWxmXHJcblx0XHRcdFx0XHQucmVtb3ZlQ2xhc3MoJ2NvbGxhcHNlZCcpXHJcblx0XHRcdFx0XHQucGFyZW50KClcclxuXHRcdFx0XHRcdC5maW5kKCc+dWwnKVxyXG5cdFx0XHRcdFx0LnNsaWRlRG93bihhbmltVGltZSwgZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0XHRcdCRzZWxmXHJcblx0XHRcdFx0XHRcdFx0LnJlbW92ZUNsYXNzKCdjb2xsYXBzZWQnKVxyXG5cdFx0XHRcdFx0XHRcdC5yZW1vdmVDbGFzcygnaGlkZGVuJyk7XHJcblx0XHRcdFx0XHR9KTtcclxuXHRcdFx0fSlcclxuXHR9O1xyXG5cdHdvcmtlci5vbmVycm9yID0gZnVuY3Rpb24gKGV2ZW50KSB7XHJcblx0XHRjb25zb2xlLmVycm9yKGV2ZW50KTtcclxuXHR9O1xyXG5cclxuXHR3b3JrZXIucG9zdE1lc3NhZ2UoY29kZSk7XHJcbn07XHJcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NjcmlwdHMvYXBpLWV4cGxvcmVyL3YyL3NyYy9zZXJ2aWNlcy9qc29uLWhpZ2hsaWdodC9pbmRleC5qcyIsInZhciBjb3VudHJ5Q29kZXMgPSByZXF1aXJlKCcuLi8uLi8uLi8uLi8uLi8uLi9fZGF0YS9vcmdzL2Rpc2NvdmVyeS1hcGkvdjIvY291bnRyeUNvZGUuanNvbicpO1xyXG5cclxuXHJcbmV4cG9ydCBkZWZhdWx0IFt7XHJcblx0XHRuYW1lOiAnbm9uZScsXHJcblx0XHRjaGVja2VkOiB0cnVlLFxyXG5cdFx0bGluazogZmFsc2VcclxuXHR9LFxyXG5cdC4uLmNvdW50cnlDb2Rlcy5Db3VudHJ5Q29kZS5tYXAoY29kZUFuZENvdW50cnkgPT4gKHtcclxuXHRcdG5hbWU6IGNvZGVBbmRDb3VudHJ5LnN1YnN0cig0LCBjb2RlQW5kQ291bnRyeS5sZW5ndGggLSA1KSwgLy8gb3IgeW91IGNhbiB1c2UgcmVnZXhwIFxcKChbYS16QS1aXFxzXSspXFwpXHJcblx0XHR2YWx1ZTogY29kZUFuZENvdW50cnkuc3Vic3RyKDAsIDIpLFxyXG5cdFx0Y2hlY2tlZDogZmFsc2UsXHJcblx0XHRsaW5rOiBmYWxzZVxyXG5cdH0pKVxyXG5dXHJcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NjcmlwdHMvYXBpLWV4cGxvcmVyL3YyL3NyYy9zZXJ2aWNlcy9vcHRpb25zL2NvdW50cnkub3B0aW9ucy5qcyIsIi8qKlxyXG4gKiByZXF1aXJlZCB0byBpbmNsdWRlOiBjbGFzc2lmaWNhdGlvbi1zZWxlY3Rvci1tb2RhbC5odG1sXHJcbiAqXHJcbiAqIGF2YWlsaWFibGUgb3B0aW9uIDpcclxuICoge1xyXG4gKiAgICBzZWxlY3RvcjogJ2NsYXNzaWZpY2F0aW9ucydcclxuICogICAgdXNlOiAnbmFtZScsICdpZCdcclxuICogfVxyXG4gKiBcclxuICogJCgnLmpzX2xhenktc2VsZWN0b3ItYXR0cmFjdGlvbnMnKS5jbGFzc2lmaWNhdGlvblNlbGVjdG9yKHtzZWxlY3RvcjonY2xhc3NpZmljYXRpb25zJywgdXNlOiduYW1lJ30pO1xyXG4gKiAkKCcuanNfbGF6eS1zZWxlY3Rvci12ZW51ZXMnKS5jbGFzc2lmaWNhdGlvblNlbGVjdG9yKHtzZWxlY3RvcjonY2xhc3NpZmljYXRpb25zJywgdXNlOidpZCd9KTtcclxuICovXHJcblxyXG4oZnVuY3Rpb24gKCQpIHtcclxuXHJcbiAgJC5mbi5jbGFzc2lmaWNhdGlvblNlbGVjdG9yID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcclxuICAgIHZhciBkZWZhdWx0cyA9IHt9LFxyXG4gICAgICAgIHNldHRpbmdzID0gJC5leHRlbmQoe30sICQuZm4ubGF6eVNlbGVjdG9yLmRlZmF1bHRzLCBvcHRpb25zKSxcclxuICAgICAgICAkaWNvbkJ1dHRvbiA9ICQoJzxhIGNsYXNzPVwiaWNvblwiIGlkPVwiZ2V0LScrb3B0aW9ucy5zZWxlY3RvcisnLScrb3B0aW9ucy51c2UrJ1wiIGRhdGEtdG9nZ2xlPVwibW9kYWxcIiBkYXRhLXRhcmdldD1cIiNqc19scy1tb2RhbC1jbGFzc2lmaWNhdGlvblwiIC8+Jyk7XHJcblxyXG4gICAgdmFyICRpbnB1dCA9ICQodGhpcyksXHJcblx0XHRcdCRtb2RhbCA9ICQoJyNqc19scy1tb2RhbC1jbGFzc2lmaWNhdGlvbicpLFxyXG4gICAgICAkZm9ybSA9ICQoJyNqc19sYXp5LXNlbF9mb3JtJywgJG1vZGFsKSxcclxuICAgICAgJGJ0bkdFVCA9ICRtb2RhbC5maW5kKCcjanNfY2xhc3NpZmljYXRpb24tbW9kYWxfYnRuJyksXHJcbiAgICAgIGNzc1ZhbGlkYXRpb25DbGFzcyA9ICdnZXQtZXZlbnRJZF9mb3JtLXZhbGlkYXRpb24nLFxyXG4gICAgICBtb2RhbENvbnRlbnQgPSAkKCcubW9kYWwtY29udGVudCcsICRtb2RhbCksXHJcbiAgICAgICRqc3RyZWUgPSAkKCcjY2xhc3NpZmljYXRpb24tanN0cmVlJylcclxuICAgICAgO1xyXG4gICAgdmFyIGtleXdvcmQgPSAkZm9ybS5maW5kKCcja2V5d29yZCcpLFxyXG4gICAgICBhcGlrZXkgPSBhcGlLZXlTZXJ2aWNlLmNoZWNrQXBpS2V5Q29va2llKCd0ay1hcGkta2V5JykgfHwgJCgnI3ctdG0tYXBpLWtleScpLnZhbCgpIHx8IGFwaUtleVNlcnZpY2UuZ2V0QXBpRXhwbG9yZUtleSgpLFxyXG4gICAgICBzZWxlY3RvciA9IG9wdGlvbnMuc2VsZWN0b3IsXHJcbiAgICAgIHVzZSA9IG9wdGlvbnMudXNlLFxyXG4gICAgICBldmVudFVybCA9ICdodHRwczovL2FwcC50aWNrZXRtYXN0ZXIuY29tL2Rpc2NvdmVyeS92Mi8nICsgc2VsZWN0b3IgKyAnLmpzb24nO1xyXG5cclxuICAgIGZ1bmN0aW9uICBpbml0VHJlZShqc29uKSB7XHJcbiAgICAgIGpzb24gPSBzZXRDaGlsZHJlbihqc29uWydfZW1iZWRkZWQnXVsnY2xhc3NpZmljYXRpb25zJ10pO1xyXG5cclxuICAgICAgJGpzdHJlZS5qc3RyZWUoe1xyXG4gICAgICAgIFwiY29yZVwiIDoge1xyXG4gICAgICAgICAgJ2NoZWNrX2NhbGxiYWNrJzogdHJ1ZSxcclxuICAgICAgICAgICdkYXRhJyA6IGpzb25cclxuICAgICAgICB9ICxcclxuICAgICAgICBcInBsdWdpbnNcIiA6IFsgXCJzZWFyY2hcIiBdICxcclxuICAgICAgICBcInNlYXJjaFwiOiB7XHJcbiAgICAgICAgICBcInNob3dfb25seV9tYXRjaGVzXCIgOiB0cnVlLFxyXG4gICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgKiBJbmRpY2F0ZXMgaWYgYWxsIG5vZGVzIG9wZW5lZCB0byByZXZlYWwgdGhlIHNlYXJjaCByZXN1bHQsIHNob3VsZCBiZSBjbG9zZWQgd2hlbiB0aGUgc2VhcmNoIGlzIGNsZWFyZWQgb3IgYSBuZXcgc2VhcmNoIGlzIHBlcmZvcm1lZC4gRGVmYXVsdCBpcyBgdHJ1ZWAuXHJcbiAgICAgICAgICAgKiBAbmFtZSAkLmpzdHJlZS5kZWZhdWx0cy5zZWFyY2guY2xvc2Vfb3BlbmVkX29uY2xlYXJcclxuICAgICAgICAgICAqIEBwbHVnaW4gc2VhcmNoXHJcbiAgICAgICAgICAgKi9cclxuICAgICAgICAgIFwiY2FzZV9zZW5zaXRpdmVcIiA6IGZhbHNlXHJcbiAgICAgICAgfVxyXG4gICAgICB9KS5vbignc2VsZWN0X25vZGUuanN0cmVlJywgZnVuY3Rpb24gKGUsIGRhdGEpIHtcclxuICAgICAgICBkYXRhLmluc3RhbmNlLnRvZ2dsZV9ub2RlKGRhdGEubm9kZSk7IC8vc2V0IG9wZW4gb24gb25lIGNsaWNrXHJcbiAgICAgICAgdmFyIGksIGosIHIgPSBbXTtcclxuICAgICAgICBmb3IgKGkgPSAwLCBqID0gZGF0YS5zZWxlY3RlZC5sZW5ndGg7IGkgPCBqOyBpKyspIHtcclxuICAgICAgICAgIHIucHVzaChcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgIHRleHQ6IGRhdGEuaW5zdGFuY2UuZ2V0X25vZGUoZGF0YS5zZWxlY3RlZFtpXSkudGV4dCxcclxuICAgICAgICAgICAgICBpZDogZGF0YS5pbnN0YW5jZS5nZXRfbm9kZShkYXRhLnNlbGVjdGVkW2ldKS5pZFxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICApO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgJCgnYnV0dG9uJywkanN0cmVlKS5vZmYoJ2NsaWNrJywgc2V0SWRMaXN0ZW5lcikucmVtb3ZlKCk7XHJcblxyXG4gICAgICAgICQoJzxidXR0b24vPicpXHJcbiAgICAgICAgICAuYWRkQ2xhc3MoJ2J0biBidG4tc3VibWl0IGJ0bi1zbWFsbCcpXHJcbiAgICAgICAgICAudGV4dCgnVXNlJylcclxuICAgICAgICAgIC5hdHRyKCdkYXRhLWNsYXNzaWZpY2F0aW9uSWQnLCh1c2UgPT09ICduYW1lJykgPyByWzBdLnRleHQgOiByWzBdLmlkKVxyXG4gICAgICAgICAgLmluc2VydEFmdGVyKCQoJyMnK3JbMF0uaWQgKycgLmpzdHJlZS1jbGlja2VkJywgJGpzdHJlZSkpXHJcbiAgICAgICAgICAub24oJ2NsaWNrJywgc2V0SWRMaXN0ZW5lcik7XHJcbiAgICAgIH0pO1xyXG5cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiAgdXBkYXRlVHJlZShqc29uKSB7XHJcbiAgICAgIHZhciBuZXdKc29uID0gKGpzb25bJ19lbWJlZGRlZCddICYmIGpzb25bJ19lbWJlZGRlZCddWydjbGFzc2lmaWNhdGlvbnMnXSkgPyBzZXRDaGlsZHJlbihqc29uWydfZW1iZWRkZWQnXVsnY2xhc3NpZmljYXRpb25zJ10pIDogbnVsbDtcclxuICAgICAgJGpzdHJlZS5qc3RyZWUodHJ1ZSkuc2V0dGluZ3MuY29yZS5kYXRhID0gbmV3SnNvbjtcclxuICAgICAgJGpzdHJlZS5qc3RyZWUodHJ1ZSkucmVmcmVzaCgpO1xyXG5cclxuICAgICAgaWYobmV3SnNvbiAmJiBuZXdKc29uLmxlbmd0aCAmJiBuZXdKc29uWzBdLmNoaWxkcmVuLmxlbmd0aCA9PT0gMCl7XHJcbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgJCgnLmpzdHJlZS1pY29uJykuaGlkZSgpO1xyXG4gICAgICAgICAgfSwxMDAgKTtcclxuICAgICAgfTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gZGF0YSB7QXJyYXl9IC0gcmVjaXZlZCBjbGFzc2lmaWNhdGlvbnMgYXJyYXlcclxuICAgICAqIEByZXR1cm5zIHtBcnJheX1cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gc2V0Q2hpbGRyZW4oZGF0YSkge1xyXG4gICAgICB2YXIgbmV3QXJyT2JqID1bXTtcclxuICAgICAgZGF0YSA9IHJlbmFtZShkYXRhKTtcclxuXHJcbiAgICAgIC8vcmVuYW1lIHBhcmVudChnZW5yZXMpXHJcbiAgICAgIGRhdGEubWFwKGZ1bmN0aW9uKGl0ZW0pe1xyXG4gICAgICAgIG5ld0Fyck9iai5wdXNoKCB7XHJcbiAgICAgICAgICBjaGlsZHJlbjooaXRlbS5zZWdtZW50Ll9lbWJlZGRlZCAmJiBpdGVtLnNlZ21lbnQuX2VtYmVkZGVkLmdlbnJlcyk/IGl0ZW0uc2VnbWVudC5fZW1iZWRkZWQuZ2VucmVzIDpbXSxcclxuICAgICAgICAgIHRleHQgOiBpdGVtLnNlZ21lbnQudGV4dCB8fCAnJyxcclxuICAgICAgICAgIGlkIDogaXRlbS5zZWdtZW50LmlkXHJcbiAgICAgICAgfSApO1xyXG4gICAgICB9KTtcclxuICAgICAgLy9yZW5hbWUvY29weSBjaGlsZChzdWJnZW5yZXMpIGZpZWxkXHJcbiAgICAgIG5ld0Fyck9iai5tYXAoZnVuY3Rpb24oaXRlbSl7XHJcbiAgICAgICAgaXRlbS5jaGlsZHJlbi5tYXAoZnVuY3Rpb24oaXRlbSkge1xyXG4gICAgICAgICAgaWYoaXRlbS5fZW1iZWRkZWQgJiYgaXRlbS5fZW1iZWRkZWQuc3ViZ2VucmVzKXtcclxuICAgICAgICAgICAgaXRlbVsnY2hpbGRyZW4nXSA9IGl0ZW0uX2VtYmVkZGVkLnN1YmdlbnJlcyA7XHJcbiAgICAgICAgICAgIGRlbGV0ZSBpdGVtLl9lbWJlZGRlZDtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgfSk7XHJcblxyXG4gICAgICByZXR1cm4gbmV3QXJyT2JqO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVuYW1lIGZpZWxkc1xyXG4gICAgICogQHBhcmFtIGpzb25cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gcmVuYW1lKGpzb24pIHtcclxuICAgICAgdmFyIG9wdCA9e1xyXG4gICAgICAgIHJvb3Q6IHtmaWVsZE5hbWU6WydzZWdtZW50J10sIHZhbDondGV4dCcsIHRvOiduYW1lJyB9LFxyXG4gICAgICAgIHBhcmVudDoge2ZpZWxkTmFtZTpbJ2dlbnJlcyddLCdfZW1iZWRkZWQnOnRydWUgLCAgdmFsOid0ZXh0JywgdG86J25hbWUnIH0sXHJcbiAgICAgICAgY2hpbGQ6IHtmaWVsZE5hbWU6WydzdWJnZW5yZXMnXSwnX2VtYmVkZGVkJzp0cnVlLCAgIHZhbDondGV4dCcsIHRvOiduYW1lJ31cclxuICAgICAgfTtcclxuICAgICAgdmFyIGFyciA9IEpTT04uc3RyaW5naWZ5KGpzb24pOy8vY29udmVydCBhcnJheSB0byBzdHJpbmdcclxuICAgICAgYXJyID0gSlNPTi5wYXJzZShhcnIpO1xyXG5cclxuXHJcbiAgICAgIGZ1bmN0aW9uIHJlcGxhY2VBdG9CKGFycixvcHQpIHtcclxuICAgICAgICB2YXIgZ2VucmVzQXJyID0gW10sXHJcbiAgICAgICAgICAgIHN1YmdlbnJlc0FyciA9IFtdO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpPGFyci5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgYXJyW2ldW29wdC5yb290LmZpZWxkTmFtZV1bb3B0LnJvb3QudmFsXSA9IGFycltpXVtvcHQucm9vdC5maWVsZE5hbWVdW29wdC5yb290LnRvXTtcclxuICAgICAgICAgIGRlbGV0ZSBhcnJbaV1bb3B0LnJvb3QuZmllbGROYW1lXVtvcHQucm9vdC50b107XHJcblxyXG5cclxuICAgICAgICAgIGlmKCBhcnJbaV1bb3B0LnJvb3QuZmllbGROYW1lXVsnX2VtYmVkZGVkJ10gJiYgb3B0LnBhcmVudC5maWVsZE5hbWUgaW4gYXJyW2ldW29wdC5yb290LmZpZWxkTmFtZV1bJ19lbWJlZGRlZCddKSB7XHJcbiAgICAgICAgICAgIGdlbnJlc0FyciA9IGFycltpXVtvcHQucm9vdC5maWVsZE5hbWVdWydfZW1iZWRkZWQnXVtvcHQucGFyZW50LmZpZWxkTmFtZV07XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBpZiggMDxnZW5yZXNBcnIubGVuZ3RoICkge1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpaSA9IDA7IGlpIDwgZ2VucmVzQXJyLmxlbmd0aDsgaWkrKykge1xyXG4gICAgICAgICAgICAgIGdlbnJlc0FycltpaV1bb3B0LnBhcmVudC52YWxdID0gZ2VucmVzQXJyW2lpXVtvcHQucGFyZW50LnRvXTtcclxuICAgICAgICAgICAgICBkZWxldGUgZ2VucmVzQXJyW2lpXVtvcHQucGFyZW50LnRvXTtcclxuXHJcbiAgICAgICAgICAgICAgaWYoZ2VucmVzQXJyW2lpXVsnX2VtYmVkZGVkJ10gJiYgZ2VucmVzQXJyW2lpXVsnX2VtYmVkZGVkJ11bb3B0LmNoaWxkLmZpZWxkTmFtZV0pe1xyXG4gICAgICAgICAgICAgICAgc3ViZ2VucmVzQXJyID0gZ2VucmVzQXJyW2lpXVsnX2VtYmVkZGVkJ11bb3B0LmNoaWxkLmZpZWxkTmFtZV07XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIGlmKCAwPHN1YmdlbnJlc0Fyci5sZW5ndGggKSB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHN1YmdlbnJlc0Fyci5sZW5ndGg7IGorKykge1xyXG4gICAgICAgICAgICAgICAgICBzdWJnZW5yZXNBcnJbal1bb3B0LmNoaWxkLnZhbF0gPSBzdWJnZW5yZXNBcnJbal1bb3B0LmNoaWxkLnRvXTtcclxuICAgICAgICAgICAgICAgICAgaWYoaj4wKSBkZWxldGUgc3ViZ2VucmVzQXJyW2pdW29wdC5jaGlsZC50b107Ly9za2lwIHplcm8gaXRlbVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIHJlcGxhY2VBdG9CKGFycixvcHQpO1xyXG4gICAgICByZXR1cm4gYXJyO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogc2V0IGRhdGEtc2VsZWN0b3IgZm9yIFwiR0VUXCIgYnV0dG9uXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGNoYW5nZU1vZGFsVGV4dExpc3RlbmVyKCkge1xyXG4gICAgICAkYnRuR0VULmF0dHIoJ2RhdGEtc2VsZWN0b3InLCBzZWxlY3Rvcik7XHJcbiAgICAgIHN1Ym1pdEZvcm0odHJ1ZSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBzaG93L2hpZGUgbG9hZGVyXHJcbiAgICAgKiBAcGFyYW0gYWN0aW9uIC0gc3RyaW5nICgnb24nIG9yICdvZmYnKVxyXG4gICAgICovXHJcbiAgICB2YXIgbG9hZGluZyA9IGZ1bmN0aW9uIChhY3Rpb24pIHtcclxuICAgICAgdmFyIHNwaW5uZXIgPSAkKCcjc3Bpbm5lci1scycsICRtb2RhbCk7XHJcbiAgICAgIC8vIGFkZCB0aGUgb3ZlcmxheSB3aXRoIGxvYWRpbmcgaW1hZ2UgdG8gdGhlIHBhZ2VcclxuICAgICAgaWYgKGFjdGlvbiA9PSBcIm9uXCIpIHtcclxuICAgICAgICBzcGlubmVyLnNob3coKTtcclxuICAgICAgfVxyXG4gICAgICBlbHNlIGlmIChhY3Rpb24gPT0gXCJvZmZcIikge1xyXG4gICAgICAgIHNwaW5uZXIuaGlkZSgpO1xyXG4gICAgICB9XHJcblxyXG4gICAgfTtcclxuXHJcbiAgICBmdW5jdGlvbiByZXNldEZvcm0oKSB7XHJcbiAgICAgICRqc3RyZWVcclxuICAgICAgICAuanN0cmVlKFwiZGVzdHJveVwiKVxyXG4gICAgICAgIC5yZW1vdmVBdHRyKCdjbGFzcycpXHJcbiAgICAgICAgLnJlbW92ZUF0dHIoJ3JvbGUnKVxyXG4gICAgICAgIC5yZW1vdmVBdHRyKCdhcmlhLWFjdGl2ZWRlc2NlbmRhbnQnKVxyXG4gICAgICA7XHJcbiAgICAgIC8vIENsZWFyIGhpZ2hsaWdodFxyXG4gICAgICAkZm9ybS5yZW1vdmVDbGFzcyhjc3NWYWxpZGF0aW9uQ2xhc3MpO1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICAvKipcclxuICAgICAqIEhhbmRsZXIgZm9yICdHRVQnIGJ1dHRvblxyXG4gICAgICogQHBhcmFtIHBhZ2VOdW1lcm8gLSBpbnQuIHVzZWQgZm9yIHBhZ2luYXRpb25cclxuICAgICAqIEBwYXJhbSBldmVudFVybCAtIHVybCBvZiByZXF1ZXN0XHJcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gLSBkb25lL2ZhaWxcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gc3VibWl0Rm9ybShpc0luaXQpIHtcclxuICAgICAgdmFyIHVybCA9ICggaXNJbml0IClcclxuICAgICAgICA/IGV2ZW50VXJsICsgJz9hcGlrZXk9JyArIGFwaWtleVxyXG4gICAgICAgIDogZXZlbnRVcmwgKyAnP2FwaWtleT0nICsgYXBpa2V5ICsgJyZrZXl3b3JkPScgKyBrZXl3b3JkLnZhbCgpO1xyXG4gICAgICBcclxuICAgICAgJC5hamF4KHtcclxuICAgICAgICBkYXRhVHlwZTogJ2pzb24nLFxyXG4gICAgICAgIGFzeW5jOiB0cnVlLFxyXG4gICAgICAgIHVybDogdXJsLFxyXG4gICAgICAgIGRhdGE6ICRmb3JtLnNlcmlhbGl6ZSgpXHJcbiAgICAgIH0pLmRvbmUoZnVuY3Rpb24gKHJlc3VsdCkge1xyXG4gICAgICAgIGlmIChyZXN1bHQpIHtcclxuICAgICAgICAgIGlmIChyZXN1bHQucGFnZS50b3RhbEVsZW1lbnRzIDwgMSkge1xyXG4gICAgICAgICAgICBsb2FkaW5nKCdvZmYnKTtcclxuICAgICAgICAgICAgcmVuZGVyUmVzdWx0cyhudWxsLCAkanN0cmVlKTsgLy9hZGQgbWVzc2FnZSBhdCBib3R0b20gb2YgbGlzdFxyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgIChpc0luaXQpID8gaW5pdFRyZWUocmVzdWx0KSA6IHVwZGF0ZVRyZWUocmVzdWx0KTtcclxuICAgICAgICAgIGxvYWRpbmcoJ29mZicpO1xyXG4gICAgICAgICAgJGJ0bkdFVC5hdHRyKCdkaXNhYmxlZCcsIGZhbHNlKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgY29uc29sZS5sb2coJ25vIHJlc3VsdCBmb3VuZCcpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSkuZmFpbChmdW5jdGlvbiAoZSwgdGV4dFN0YXR1cywgZXJyb3JUaHJvd24pIHtcclxuICAgICAgICBjb25zb2xlLmxvZygnVGhlcmUgd2FzIGFuIGZhaWwgc3RhdHVzIC0gJyAsIGUuc3RhdHVzICwgZXJyb3JUaHJvd24pO1xyXG4gICAgICAgIGxvYWRpbmcoJ29mZicpO1xyXG4gICAgICAgIHJlbmRlclJlc3VsdHMoJ0ZBSUwnLCAkanN0cmVlICwgZSk7XHJcbiAgICAgICAgJGJ0bkdFVC5hdHRyKCdkaXNhYmxlZCcsIGZhbHNlKTtcclxuICAgICAgfSk7XHJcblxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGhhc1Njcm9sbEJhcihlbGVtZW50KSB7XHJcbiAgICAgIHJldHVybiBlbGVtZW50LmdldCgwKS5zY3JvbGxIZWlnaHQgPiBlbGVtZW50LnBhcmVudCgpLmlubmVySGVpZ2h0KCk7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIHJlbmRlclJlc3VsdHMgPSBmdW5jdGlvbiAoZGF0YSwgdWxFbGVtZW50LCBlcnJvck1zZykge1xyXG4gICAgICBmdW5jdGlvbiBzaG93TWVzc2FnZShlbGVtZW50LCBtZXNzYWdlLCAvKm9wdGlvbmFsKi9jbGVhckxpc3QpIHtcclxuICAgICAgICBpZiAoY2xlYXJMaXN0KSB7XHJcbiAgICAgICAgICAkKCdsaScsIGVsZW1lbnQpLnJlbW92ZSgpO1xyXG4gICAgICAgICAgJCgnLmVycm9yLWJveCcpLnJlbW92ZSgpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgJCgnPGRpdi8+JylcclxuICAgICAgICAgIC5hZGRDbGFzcyggJ2Vycm9yLWJveCB0ZXh0LWNlbnRlciAnKVxyXG4gICAgICAgICAgLmFkZENsYXNzKCAoZGF0YSA9PT0gJ0ZBSUwnKT8nIGVycm9yLWZhaWwgJzogJycpXHJcbiAgICAgICAgICAgIC5hcHBlbmQoJCgnPGgzLz4nKS50ZXh0KG1lc3NhZ2UubXNnKSlcclxuICAgICAgICAgICAgLmFwcGVuZCgkKCc8cC8+JykudGV4dChtZXNzYWdlLmV4cGxhbmF0aW9uKSlcclxuICAgICAgICAgIC5hcHBlbmRUbyh1bEVsZW1lbnQpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAkYnRuR0VULmF0dHIoJ2Rpc2FibGVkJywgZmFsc2UpO1xyXG5cclxuICAgICAgLy9zaG93IGZhaWwgbXNnXHJcbiAgICAgIGlmIChkYXRhID09PSAnRkFJTCcpIHtcclxuICAgICAgICB2YXIgbXNnRXJyID0gKGVycm9yTXNnLnJlc3BvbnNlSlNPTiAhPT0gbnVsbCApP2Vycm9yTXNnLnJlc3BvbnNlSlNPTi5lcnJvcnNbMF0uc3RhdHVzIDogJ3Vua25vd24nLFxyXG4gICAgICAgICAgc3RhdHVzVGV4dCA9IChlcnJvck1zZy5yZXNwb25zZUpTT04gIT09IG51bGwgKT9lcnJvck1zZy5yZXNwb25zZUpTT04uZXJyb3JzWzBdLnN0YXR1c1RleHQgIDogZXJyb3JNc2cuc3RhdHVzVGV4dCAgfHwgJycsXHJcbiAgICAgICAgICBleHBsYW5hdGlvbiA9IChlcnJvck1zZy5yZXNwb25zZUpTT04gIT09IG51bGwgKT9lcnJvck1zZy5yZXNwb25zZUpTT04uZXJyb3JzWzBdLmRldGFpbCA6ICd1bmtub3duJztcclxuXHJcbiAgICAgICAgc2hvd01lc3NhZ2UoJGpzdHJlZSwge1xyXG4gICAgICAgICAgbXNnOiAnRXJyb3IgJyArIG1zZ0VyciArICc6ICcgKyBzdGF0dXNUZXh0LFxyXG4gICAgICAgICAgZXhwbGFuYXRpb246IGV4cGxhbmF0aW9uXHJcbiAgICAgICAgfSwgdHJ1ZSk7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvL3Nob3cgTm8gcmVzdWx0cyBmb3VuZCBtc2dcclxuICAgICAgaWYgKGRhdGEgPT09IG51bGwgfHwgIWRhdGEuX2VtYmVkZGVkKSB7XHJcbiAgICAgICAgc2hvd01lc3NhZ2UodWxFbGVtZW50LCB7bXNnOiAnTm8gcmVzdWx0cyBmb3VuZC4nICwgZXhwbGFuYXRpb246ICdQbGVhc2UgdHJ5IHRvIGdldCBhbm90aGVyIGtleXdvcmQuJ30sIHRydWUpO1xyXG4gICAgICAgIG1vZGFsQ29udGVudC5yZW1vdmVDbGFzcygnbmFycm93Jyk7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIGZ1bmN0aW9uIHNldElkTGlzdGVuZXIoZSl7XHJcbiAgICAgIHZhciBzZWxlY3RlZElEID0gZS50YXJnZXQuZ2V0QXR0cmlidXRlKCdkYXRhLWNsYXNzaWZpY2F0aW9uSWQnKTtcclxuICAgICAgJGlucHV0LnZhbChzZWxlY3RlZElEKVxyXG4gICAgICAgICAgICAuYXR0cigndmFsdWUnLCBzZWxlY3RlZElEKVxyXG4gICAgICAgICAgICAudHJpZ2dlcignY2hhbmdlJyk7ICAvL3VwZGF0ZSB3aWRnZXQ6XHJcblxyXG4gICAgICAvLyBDbG9zZSBkaWFsb2dcclxuICAgICAgJG1vZGFsLm1vZGFsKCdoaWRlJyk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gRVZFTlRTXHJcbiAgICAkYnRuR0VULm9uKCdjbGljaycsIGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgIGUucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgaWYgKCRidG5HRVQuYXR0cignZGF0YS1zZWxlY3RvcicpICE9PSAkaWNvbkJ1dHRvbi5hdHRyKCdkYXRhLXNlbGVjdG9yJykpIHJldHVybiBmYWxzZTsgLy9zdG9wIHJlcXVlc3RcclxuXHJcbiAgICAgIHZhciBmb3JtID0gJGZvcm0uZ2V0KDApO1xyXG4gICAgICBpZiAoISRidG5HRVQuaXMoJzpkaXNhYmxlZCcpKSB7XHJcbiAgICAgICAgaWYgKGZvcm0uY2hlY2tWYWxpZGl0eSgpKSB7XHJcbiAgICAgICAgICAkYnRuR0VULmF0dHIoJ2Rpc2FibGVkJywgdHJ1ZSk7XHJcbiAgICAgICAgICBsb2FkaW5nKCdvbicpOyAvL3Nob3cgbG9hZGluZy1zcGlubmVyXHJcbiAgICAgICAgICBzdWJtaXRGb3JtKCk7XHJcbiAgICAgICAgICAvL3Jlc2V0Rm9ybSgpOyAvL2NsZWFyXHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIC8vIEhpZ2hsaWdodCBlcnJvcnNcclxuICAgICAgICAgIGlmIChmb3JtLnJlcG9ydFZhbGlkaXR5KSBmb3JtLnJlcG9ydFZhbGlkaXR5KCk7XHJcbiAgICAgICAgICAkZm9ybS5hZGRDbGFzcyhjc3NWYWxpZGF0aW9uQ2xhc3MpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgJGZvcm0ub24oXCJrZXl1cFwiLCBmdW5jdGlvbiAoZSkge1xyXG4gICAgICB2YXIgaW5wdXQgPSAkKGUudGFyZ2V0KTtcclxuICAgICAgaWYgKGUudGFyZ2V0LnRhZ05hbWUgPT09IFwiSU5QVVRcIil7XHJcbiAgICAgICAgaWYgKGUua2V5Q29kZSA9PSAxMyl7XHJcbiAgICAgICAgICBpbnB1dC5ibHVyKCk7XHJcblxyXG4gICAgICAgICAgbW9kYWxDb250ZW50LnJlbW92ZUNsYXNzKCduYXJyb3cnKTtcclxuICAgICAgICAgIGlmICgkYnRuR0VULmF0dHIoJ2RhdGEtc2VsZWN0b3InKSAhPT0gJGljb25CdXR0b24uYXR0cignZGF0YS1zZWxlY3RvcicpKSByZXR1cm4gZmFsc2U7XHJcblxyXG4gICAgICAgICAgaWYgKCRmb3JtLmdldCgwKS5jaGVja1ZhbGlkaXR5KCkpIHtcclxuICAgICAgICAgICAgbG9hZGluZygnb24nKTtcclxuICAgICAgICAgICAgc3VibWl0Rm9ybSgpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9KTtcclxuXHJcbiAgICAvLyBNb2JpbGUgZGV2aWNlcy4gRm9yY2UgJ2NoYW5nZScgYnkgJ0dvJyBwcmVzc1xyXG4gICAgJGZvcm0ub24oXCJzdWJtaXRcIiwgZnVuY3Rpb24gKGUpIHtcclxuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgJG1vZGFsLm9uKCdoaWRkZW4uYnMubW9kYWwnLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHJlc2V0Rm9ybSgpO1xyXG4gICAgICBrZXl3b3JkLnZhbCgnJyk7Ly9jbGVhciBzZWFyY2ggaW5wdXRcclxuICAgIH0pO1xyXG5cclxuICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKGkpIHtcclxuICAgICAgaW5pdCgkKHRoaXMpKTtcclxuXHJcbiAgICAgIGZ1bmN0aW9uIGluaXQoaW5wdXQpIHtcclxuICAgICAgICBpbnB1dC53cmFwKCc8ZGl2IGNsYXNzPVwibGF6eS1zZWxlY3Rvci13cmFwcGVyXCI+PC9kaXY+Jyk7XHJcbiAgICAgICAgaW5wdXQuYWZ0ZXIoJGljb25CdXR0b24pO1xyXG4gICAgICAgICRpY29uQnV0dG9uLmF0dHIoJ2RhdGEtc2VsZWN0b3InLCBzZWxlY3Rvcik7XHJcblxyXG4gICAgICAgICQoJyNnZXQtJytvcHRpb25zLnNlbGVjdG9yKyctJytvcHRpb25zLnVzZSkub24oJ2NsaWNrJywgY2hhbmdlTW9kYWxUZXh0TGlzdGVuZXIpO1xyXG5cclxuICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gIH07XHJcblxyXG59KShqUXVlcnkpO1xyXG5cclxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc2NyaXB0cy9jb21wb25lbnRzL2NsYXNzaWZpY2F0aW9uLXNlbGVjdG9yLmpzIiwiLyoqXHJcbiAqIHJlcXVpcmVkIHRvIGluY2x1ZGU6IGxhenktc2VsZWN0b3ItbW9kYWwuaHRtbFxyXG4gKlxyXG4gKiBhdmFpbGlhYmxlIG9wdGlvbiA6XHJcbiAqIHtcclxuICogICAgc2VsZWN0b3I6ICdhdHRyYWN0aW9ucycgLCAndmVudWVzJywgJycsXHJcbiAqICAgIGhpZGVNdWx0aVNlbGVjdG9yOiB0cnVlLCBmYWxzZVxyXG4gKiB9XHJcbiAqICQoJy5qc19sYXp5LXNlbGVjdG9yJykubGF6eVNlbGVjdG9yKCk7XHJcbiAqICQoJy5qc19sYXp5LXNlbGVjdG9yLWF0dHJhY3Rpb25zJykubGF6eVNlbGVjdG9yKCd7c2VsZWN0b3I6ICdhdHRyYWN0aW9ucyd9KTtcclxuICogJCgnLmpzX2xhenktc2VsZWN0b3ItdmVudWVzJykubGF6eVNlbGVjdG9yKHtzZWxlY3RvcjondmVudWVzJywgaGlkZU11bHRpU2VsZWN0b3I6dHJ1ZX0pO1xyXG4gKi9cclxuXHJcbihmdW5jdGlvbiAoJCkge1xyXG4gIHZhciBjb25maWcgPSBbJ2V2ZW50cycsICd2ZW51ZXMnLCAnYXR0cmFjdGlvbnMnXSxcclxuICAgIHRhZ3NJZHMgPXt9LCBpbml0aWFsVmFsPXt9O1xyXG5cclxuICBjb25maWcuZm9yRWFjaChmdW5jdGlvbiAoZWwpIHtcclxuICAgIHRhZ3NJZHNbZWxdID0gW107XHJcbiAgICBpbml0aWFsVmFsW2VsXSA9IFtdO1xyXG4gIH0pO1xyXG5cclxuICAkLmZuLmxhenlTZWxlY3RvciA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XHJcbiAgICB2YXIgZGVmYXVsdHMgPSB7fSxcclxuICAgICAgICBzZXR0aW5ncyA9ICQuZXh0ZW5kKHt9LCAkLmZuLmxhenlTZWxlY3Rvci5kZWZhdWx0cywgb3B0aW9ucyksXHJcbiAgICAgICAgJGljb25CdXR0b24gPSAkKCc8YSBjbGFzcz1cImljb25cIiBpZD1cImdldC1ldmVudC1ieS1JZC0nICsgb3B0aW9ucy5zZWxlY3RvciArICdcIiBkYXRhLXRvZ2dsZT1cIm1vZGFsXCIgZGF0YS10YXJnZXQ9XCIjanNfbHMtbW9kYWxcIiAvPicpO1xyXG5cclxuICAgIHZhciBzdGF0ZUNvbmYgPSB7XHJcbiAgICAgIHBhZ2VJbmNyZW1lbnQ6IDAsXHJcbiAgICAgIGxvYWRpbmdGbGFnOiBmYWxzZSxcclxuICAgICAgc2V0U2luZ2xlVmFsOiBmYWxzZVxyXG4gICAgfTtcclxuXHJcbiAgICB2YXIgJGlucHV0ID0gJCh0aGlzKSxcclxuXHRcdFx0JG1vZGFsID0gJCgnI2pzX2xzLW1vZGFsJyksXHJcbiAgICAgICRmb3JtID0gJCgnI2pzX2xhenktc2VsX2Zvcm0nLCAkbW9kYWwpLFxyXG4gICAgICAkdWwgPSAkKCcjanNfbGF6eS1zZWxfbGlzdCcpLFxyXG4gICAgICAkbGlGb290ZXIgPSAkKCcjbG9hZC1tb3JlLWJveCcpLFxyXG4gICAgICAkaHIgPSAkKCcjanNfbHMtdG9wLWhyJyksXHJcbiAgICAgICRidG5HRVQgPSAkbW9kYWwuZmluZCgnI2pzX2xzLW1vZGFsX2J0bicpLFxyXG4gICAgICBidG5DbG9zZU1hcCA9ICQoJy5idXR0b24tY2xvc2UtbWFwJywgJG1vZGFsKSxcclxuICAgICAgY3NzVmFsaWRhdGlvbkNsYXNzID0gJ2dldC1ldmVudElkX2Zvcm0tdmFsaWRhdGlvbicsXHJcbiAgICAgIG1vZGFsQ29udGVudCA9ICQoJy5tb2RhbC1jb250ZW50JywgJG1vZGFsKSxcclxuICAgICAgJG1zU2VsZWN0aW9uID0gJCgnLm1zLXNlbGVjdGlvbicpLFxyXG4gICAgICAkbXNMaXN0ID0gJCgnLm1zLWxpc3QnLCRtc1NlbGVjdGlvbiksXHJcbiAgICAgICRtc0J0blVzZSA9ICQoJyNqc19tcy11c2UtYnRuJywkbXNTZWxlY3Rpb24pXHJcbiAgICAgIDtcclxuXHJcbiAgICB2YXIga2V5d29yZCA9ICRmb3JtLmZpbmQoJyNrZXl3b3JkJyksXHJcbiAgICAgIGRlZmF1bHRBcGlLZXkgPSBhcGlLZXlTZXJ2aWNlLmdldEFwaUV4cGxvcmVLZXkoKSxcclxuICAgICAgYXBpa2V5ID0gYXBpS2V5U2VydmljZS5jaGVja0FwaUtleUNvb2tpZSgndGstYXBpLWtleScpIHx8ICQoJyN3LXRtLWFwaS1rZXknKS52YWwoKSB8fCBkZWZhdWx0QXBpS2V5LFxyXG4gICAgICBzZWxlY3RvciA9IG9wdGlvbnMuc2VsZWN0b3IgfHwgJ2V2ZW50cycsXHJcbiAgICAgIGV2ZW50VXJsID0gJ2h0dHBzOi8vYXBwLnRpY2tldG1hc3Rlci5jb20vZGlzY292ZXJ5L3YyLycgKyBzZWxlY3RvciArICcuanNvbidcclxuICAgICAgO1xyXG5cclxuICAgIGZ1bmN0aW9uIGZvcm1hdERhdGUoZGF0ZSkge1xyXG4gICAgICB2YXIgcmVzdWx0ID0gJyc7XHJcbiAgICAgIGlmICghZGF0ZS5kYXkpIHJldHVybiByZXN1bHQ7IC8vIERheSBpcyByZXF1aXJlZFxyXG5cclxuICAgICAgdmFyIE1PTlRIX05BTUVTID0gWydKYW4nLCAnRmViJywgJ01hcicsICdBcHInLCAnTWF5JywgJ0p1bicsICdKdWwnLCAnQXVnJywgJ1NlcCcsICdPY3QnLCAnTm92JywgJ0RlYyddLFxyXG4gICAgICAgIERBWV9OQU1FUyA9IFsnU3VuJywgJ01vbicsICdUdWUnLCAnV2VkJywgJ1RodScsICdGcmknLCAnU2F0J10sXHJcbiAgICAgICAgZGF5QXJyYXkgPSBkYXRlLmRheS5zcGxpdCgnLScpLFxyXG4gICAgICAgIGQgPSBwYXJzZUludChkYXlBcnJheVsyXSksXHJcbiAgICAgICAgTSA9IHBhcnNlSW50KGRheUFycmF5WzFdKTtcclxuXHJcbiAgICAgIHZhciBFID0gbmV3IERhdGUoZGF0ZS5kYXkpLmdldERheSgpO1xyXG5cclxuICAgICAgLy92YXIgRTEgPSBuZXcgRGF0ZSgrZGF0ZS5kYXkuc3BsaXQoJy0nKVswXSwoK2RhdGUuZGF5LnNwbGl0KCctJylbMV0pLTEsK2RhdGUuZGF5LnNwbGl0KCctJylbMl0pLmdldERheSgpO1xyXG4gICAgICAvL2lmKEUgIT09IEUxKSBjb25zb2xlLmxvZygnXFx0IGFsYXJtIGVxdWFsIC0gJyAsIEUgPT09IEUxKTtcclxuXHJcbiAgICAgIHJlc3VsdCA9IERBWV9OQU1FU1tFXSArICcsICcgKyBNT05USF9OQU1FU1tNIC0gMV0gKyAnICcgKyBkICsgJywgJyArIGRheUFycmF5WzBdO1xyXG5cclxuICAgICAgaWYgKCFkYXRlLnRpbWUpIHJldHVybiByZXN1bHQ7XHJcblxyXG4gICAgICB2YXIgdGltZUFycmF5ID0gZGF0ZS50aW1lLnNwbGl0KCc6JyksXHJcbiAgICAgICAgSCA9IHBhcnNlSW50KHRpbWVBcnJheVswXSksXHJcbiAgICAgICAgbSA9IHRpbWVBcnJheVsxXSxcclxuICAgICAgICBhID0gXCJBTVwiO1xyXG5cclxuICAgICAgaWYgKEggPiAxMSkgYSA9IFwiUE1cIjtcclxuICAgICAgaWYgKEggPT09IDApIHtcclxuICAgICAgICBIID0gMTI7XHJcbiAgICAgIH0gZWxzZSBpZiAoSCA+IDEyKSB7XHJcbiAgICAgICAgSCA9IEggLSAxMjtcclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIHJlc3VsdCArICcgJyArIGdldE5vcm1hbGl6ZWREYXRlVmFsdWUoSCkgKyAnOicgKyBtICsgJyAnICsgYTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBnZXROb3JtYWxpemVkRGF0ZVZhbHVlKHZhbCkge1xyXG4gICAgICByZXR1cm4gKHZhbCA8IDAgfHwgdmFsID4gOSA/IFwiXCIgOiBcIjBcIikgKyB2YWxcclxuICAgIH1cclxuXHJcblxyXG4gICAgdmFyIG1hcCA9IG51bGwsXHJcbiAgICAgIGRlZmF1bHRNYXBab29tID0gMTAsXHJcbiAgICAgIG1hcmtlcnMgPSBbXTtcclxuICAgIC8qKlxyXG4gICAgICogU2hvdyBvciBpbml0IG1hcCBsaXN0ZW5lclxyXG4gICAgICogQHBhcmFtIGVcclxuICAgICAqL1xyXG4gICAgdmFyIG1hcFBvcFVwTGlzdGVuZXIgPSBmdW5jdGlvbiAoZSkge1xyXG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgIHZhciBsYXQgPSAkKGUudGFyZ2V0KS5hdHRyKCdkYXRhLWxhdGl0dWRlJykgIT0gXCJ1bmRlZmluZWRcIiA/IHBhcnNlRmxvYXQoJChlLnRhcmdldCkuYXR0cignZGF0YS1sYXRpdHVkZScpKSA6IG51bGwsXHJcbiAgICAgICAgbG5nID0gJChlLnRhcmdldCkuYXR0cignZGF0YS1sb25naXR1ZGUnKSAhPSBcInVuZGVmaW5lZFwiID8gcGFyc2VGbG9hdCgkKGUudGFyZ2V0KS5hdHRyKCdkYXRhLWxvbmdpdHVkZScpKSA6IG51bGwsXHJcbiAgICAgICAgYWRkcmVzcyA9IGxhdCAmJiBsbmcgPyBudWxsIDogJChlLnRhcmdldCkuYXR0cignZGF0YS1hZGRyZXNzJyk7XHJcblxyXG4gICAgICBpZiAobGF0ICYmIGxuZyApIHtcclxuICAgICAgICBpbml0TWFwKGxhdCwgbG5nKTtcclxuICAgICAgICBtYXAuc2V0Wm9vbShkZWZhdWx0TWFwWm9vbSk7XHJcbiAgICAgICAgZ29vZ2xlLm1hcHMuZXZlbnQudHJpZ2dlcihtYXAsIFwicmVzaXplXCIpOyAvLydzZWNvbmQgaW5pdCdcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBpbml0TWFwKDAsIDApOyAvL1wiZmlyc3QgaW5pdFwiXHJcbiAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBJbml0IG1hcCBnb29nbGUgbWFwc1xyXG4gICAgICogQHBhcmFtIGxhdCAtIGZsb2F0XHJcbiAgICAgKiBAcGFyYW0gbG5nIC0gZmxvYXRcclxuICAgICAqIEBwYXJhbSBhZGRyZXNzIC0gbm90IHVzZWQgQGRlcHJlY2F0ZWRcclxuICAgICAqL1xyXG4gICAgdmFyIGluaXRNYXAgPSBmdW5jdGlvbiAobGF0LCBsbmcpIHtcclxuICAgIFx0dmFyIG1vZGFsID0gJG1vZGFsLFxyXG4gICAgICAgIG1hcENlbnRlciA9IG5ldyBnb29nbGUubWFwcy5MYXRMbmcobGF0IHx8IDU1LCBsbmcgfHwgNDMpO1xyXG5cclxuICAgICAgaWYobWFwID09PSBudWxsKXtcclxuICAgICAgICAvLyBpbml0aWFsaXplIG1hcCBvYmplY3RcclxuICAgICAgICBtYXAgPSBuZXcgZ29vZ2xlLm1hcHMuTWFwKGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdtYXAtY2FudmFzJyksIHtcclxuICAgICAgICAgIGNlbnRlcjogbWFwQ2VudGVyLFxyXG4gICAgICAgICAgem9vbTogZGVmYXVsdE1hcFpvb20sXHJcbiAgICAgICAgICBtYXBUeXBlQ29udHJvbDogZmFsc2UsXHJcbiAgICAgICAgICBzY2FsZUNvbnRyb2w6IGZhbHNlLFxyXG4gICAgICAgICAgZnVsbHNjcmVlbkNvbnRyb2w6IGZhbHNlLFxyXG4gICAgICAgICAgc3RyZWV0Vmlld0NvbnRyb2w6IGZhbHNlLFxyXG4gICAgICAgICAgcm90YXRlQ29udHJvbDogZmFsc2VcclxuICAgICAgICB9KTtcclxuICAgICAgfWVsc2Uge1xyXG4gICAgICAgIGNsZWFyTWFya2VycygpO1xyXG5cclxuICAgICAgICAvL3NldCBuZXcgY2VudGVyXHJcbiAgICAgICAgbWFwLnBhblRvKG1hcENlbnRlcik7IC8vc21vb3RoIGNlbnRlci4gSWYgdGhlIGNoYW5nZSBpcyBsZXNzIHRoYW4gYm90aCB0aGUgd2lkdGggYW5kIGhlaWdodCBvZiB0aGUgbWFwLCB0aGUgdHJhbnNpdGlvbiB3aWxsIGJlIHNtb290aGx5IGFuaW1hdGVkLlxyXG4gICAgICAgIG1hcC5zZXRDZW50ZXIobWFwQ2VudGVyKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gQWRkcyBhIG1hcmtlciBhdCB0aGUgY2VudGVyIG9mIHRoZSBtYXAuXHJcbiAgICAgIGFkZE1hcmtlcihtYXBDZW50ZXIpO1xyXG5cclxuICAgICAgLy8gd2hlbiBtYXAgcG9wdXAgaXMgc2hvd25cclxuICAgICAgbW9kYWwub24oXCJzaG93bi5icy5tb2RhbFwiLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgLy8gUmVjZW50ZXIgdGhlIG1hcCBub3cgdGhhdCBpdCdzIGJlZW4gcmVkcmF3blxyXG4gICAgICAgIGdvb2dsZS5tYXBzLmV2ZW50LnRyaWdnZXIobWFwLCBcInJlc2l6ZVwiKTtcclxuICAgICAgICBtYXAuc2V0Q2VudGVyKG1hcENlbnRlcik7XHJcbiAgICAgIH0pO1xyXG4gICAgICBtb2RhbC5tb2RhbCgpOyAvLyBzaG93IG1hcCBwb3B1cFxyXG4gICAgfTtcclxuXHJcbiAgICAvLyBBZGRzIGEgbWFya2VyIHRvIHRoZSBtYXAgYW5kIHB1c2ggdG8gdGhlIGFycmF5LlxyXG4gICAgZnVuY3Rpb24gYWRkTWFya2VyKG1hcENlbnRlcikge1xyXG4gICAgICB2YXIgbWFya2VyID0gbmV3IGdvb2dsZS5tYXBzLk1hcmtlcih7IC8vQ3JlYXRlIGEgbWFya2VyIGFuZCBzZXQgaXRzIHBvc2l0aW9uLlxyXG4gICAgICAgIG1hcDogbWFwLFxyXG4gICAgICAgIHBvc2l0aW9uOiBtYXBDZW50ZXIsXHJcbiAgICAgICAgaWNvbjogbmV3IGdvb2dsZS5tYXBzLk1hcmtlckltYWdlKCcuLi8uLi8uLi8uLi9hc3NldHMvY29udHJvbHMvcGluLWljLnN2ZycsXHJcbiAgICAgICAgICBudWxsLCBudWxsLCBudWxsLCBuZXcgZ29vZ2xlLm1hcHMuU2l6ZSgzNCwgNTIpKVxyXG4gICAgICB9KTtcclxuICAgICAgbWFya2Vycy5wdXNoKG1hcmtlcik7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gUmVtb3ZlcyB0aGUgbWFya2VycyBmcm9tIHRoZSBtYXAsIGJ1dCBrZWVwcyB0aGVtIGluIHRoZSBhcnJheS5cclxuICAgIGZ1bmN0aW9uIGNsZWFyTWFya2VycygpIHtcclxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtYXJrZXJzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgbWFya2Vyc1tpXS5zZXRNYXAobnVsbCk7XHJcbiAgICAgIH1cclxuICAgICAgbWFya2VycyA9IFtdO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGNsb3NlTWFwTGlzdGVuZXIoKSB7XHJcbiAgICAgIG1vZGFsQ29udGVudC5yZW1vdmVDbGFzcygnbmFycm93Jyk7XHJcbiAgICAgIGJ0bkNsb3NlTWFwLmhpZGUoKTsgLy8gJ1gnIC1idXR0b25cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiB0b2dnbGVUYWdzKCkge1xyXG5cdFx0XHR2YXIgaW5kVG9SZW1vdmUgPVtdLCBcclxuICAgICAgICBpbnB1dFZhbEFycmF5ID0gJGlucHV0LnZhbCgpLnNwbGl0KFwiLFwiKTtcclxuXHJcbiAgICAgICQoJ2xpJywkbXNMaXN0KS5lYWNoKGZ1bmN0aW9uIChpKSB7XHJcbiAgICAgICAgdmFyIGxpc3RJdGVtID0gJCh0aGlzKSxcclxuICAgICAgICAgICAgaWQgPSBsaXN0SXRlbS5kYXRhKCdzZWxlY3Rvci0nK3NlbGVjdG9yKTtcclxuXHJcbiAgICAgICAgaWYobGlzdEl0ZW0uZGF0YSgnc2VsZWN0b3ItJytzZWxlY3Rvcikpe1xyXG5cdFx0XHRcdFx0bGlzdEl0ZW0uc2hvdygpO1xyXG4gICAgICAgICAgaWYoIGpRdWVyeS5pbkFycmF5KCBpZCwgaW5wdXRWYWxBcnJheSApID09PSAtMSkge1xyXG5cdFx0XHRcdFx0XHRpbmRUb1JlbW92ZS5wdXNoKGlkKTtcclxuICAgICAgICAgICAgbGlzdEl0ZW0ucmVtb3ZlKCk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfWVsc2Uge1xyXG4gICAgICAgICAgbGlzdEl0ZW0uaGlkZSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcblxyXG4gICAgICAvL2ZpbHRlciBieSA6IFtpbmRUb1JlbW92ZV1cclxuICAgICAgdGFnc0lkc1tzZWxlY3Rvcl0gPSB0YWdzSWRzW3NlbGVjdG9yXS5maWx0ZXIoIGZ1bmN0aW9uKCBlbCApIHtcclxuICAgICAgICByZXR1cm4gIWluZFRvUmVtb3ZlLmluY2x1ZGVzKCBlbCApO1xyXG4gICAgICB9KTtcclxuXHJcblx0XHR9XHJcblxyXG4gICAgZnVuY3Rpb24gdG9nZ2xlTXNTZWxlY3Rpb25Cb3goKSB7XHJcbiAgICAgIGlmKCQoJ2xpJywkbXNMaXN0KS5sZW5ndGg8MSl7XHJcbiAgICAgICAgJG1zU2VsZWN0aW9uLmhpZGUoKTtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuXHJcbiAgICAgICQoJ2xpJywkbXNMaXN0KS5lYWNoKGZ1bmN0aW9uIChpKSB7XHJcbiAgICAgICAgdmFyIGxpc3RJdGVtID0gJCh0aGlzKTtcclxuICAgICAgICBpZiAobGlzdEl0ZW0uZGF0YSgnc2VsZWN0b3ItJyArIHNlbGVjdG9yKSkge1xyXG4gICAgICAgICAgJG1zU2VsZWN0aW9uLnNob3coKTtcclxuICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSAkbXNTZWxlY3Rpb24uaGlkZSgpO1xyXG4gICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIGNoYW5nZSA8TG9hZF9Nb3JlPiBidXR0b24gdGV4dCBvbiBvcGVuIG1vZGFsXHJcbiAgICAgKiBzZXQgZGF0YS1zZWxlY3RvciBnb3IgXCJHRVRcIiBidXR0b25cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gY2hhbmdlTW9kYWxUZXh0TGlzdGVuZXIoKSB7XHJcbiAgICAgIGlmIChzZWxlY3RvciAhPT0gJ2V2ZW50cycpIHtcclxuICAgICAgICAkKCcubW9kYWwtdGl0bGUgc3BhbicsICRtb2RhbCkudGV4dChzZWxlY3Rvcik7XHJcbiAgICAgICAgJCgnI2pzX2xzLW1vcmVfYnRuJywgJG1vZGFsKS50ZXh0KCdTSE9XIE1PUkUgJyArIHNlbGVjdG9yKTtcclxuICAgICAgfVxyXG4gICAgICBpZihzZWxlY3RvciA9PT0gJ3ZlbnVlcycpe1xyXG5cdFx0XHRcdCQoJy53cmFwcGVyLWxpc3QtZ3JvdXAnLCAkbW9kYWwpLmFkZENsYXNzKCdsb3ctaGVpZ2h0Jyk7XHJcbiAgICAgICAgJG1zU2VsZWN0aW9uLmFkZENsYXNzKCdoaWRkZW4teHMnKTtcclxuICAgICAgfWVsc2V7XHJcbiAgICAgICAgJCgnLndyYXBwZXItbGlzdC1ncm91cCcsICRtb2RhbCkucmVtb3ZlQ2xhc3MoJ2xvdy1oZWlnaHQnKTtcclxuICAgICAgICAkbXNTZWxlY3Rpb24ucmVtb3ZlQ2xhc3MoJ2hpZGRlbi14cycpO1xyXG4gICAgICB9XHJcblxyXG5cdFx0XHRpZihvcHRpb25zLmhpZGVNdWx0aVNlbGVjdG9yKSB7XHJcblx0XHRcdFx0JG1zU2VsZWN0aW9uLmhpZGUoKTtcclxuXHRcdFx0fWVsc2V7XHJcblx0XHRcdFx0aWYoJCgnbGknLCRtc0xpc3QpLmxlbmd0aD4wKXtcclxuXHRcdFx0XHRcdCRtc1NlbGVjdGlvbi5zaG93KCk7IC8vIGNvbnNvbGUubG9nKCdzaG93ICRtc0xpc3QnLCQoJ2xpJywkbXNMaXN0KS5sZW5ndGgpO1xyXG5cdFx0XHRcdH1cclxuICAgICAgICB0b2dnbGVUYWdzKCk7XHJcbiAgICAgICAgdG9nZ2xlTXNTZWxlY3Rpb25Cb3goKTtcclxuXHRcdFx0fVxyXG5cclxuICAgICAgJGJ0bkdFVC5hdHRyKCdkYXRhLXNlbGVjdG9yJywgc2VsZWN0b3IpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogc2hvdy9oaWRlIGxvYWRlclxyXG4gICAgICogQHBhcmFtIGFjdGlvbiAtIHN0cmluZyAoJ29uJyBvciAnb2ZmJylcclxuICAgICAqL1xyXG4gICAgdmFyIGxvYWRpbmcgPSBmdW5jdGlvbiAoYWN0aW9uKSB7XHJcbiAgICAgIHZhciBzcGlubmVyID0gJCgnI3NwaW5uZXItbHMnLCAkbW9kYWwpO1xyXG4gICAgICAvLyBhZGQgdGhlIG92ZXJsYXkgd2l0aCBsb2FkaW5nIGltYWdlIHRvIHRoZSBwYWdlXHJcbiAgICAgIGlmIChhY3Rpb24gPT0gXCJvblwiKSB7XHJcbiAgICAgICAgc3Bpbm5lci5zaG93KCk7XHJcbiAgICAgIH1cclxuICAgICAgZWxzZSBpZiAoYWN0aW9uID09IFwib2ZmXCIpIHtcclxuICAgICAgICBzcGlubmVyLmhpZGUoKTtcclxuICAgICAgfVxyXG5cclxuICAgIH07XHJcblxyXG4gICAgZnVuY3Rpb24gcmVzZXRGb3JtKCkge1xyXG4gICAgICBzdGF0ZUNvbmYucGFnZUluY3JlbWVudCA9IDA7XHJcbiAgICAgIHZhciBsaXN0SXRlbXMgPSAkdWwuZmluZCgnbGknKTtcclxuICAgICAgbGlzdEl0ZW1zLnJlbW92ZSgpO1xyXG4gICAgICAkaHIuaGlkZSgpO1xyXG4gICAgICAkbGlGb290ZXIuaGlkZSgpO1xyXG5cclxuICAgICAgLy8gQ2xlYXIgaGlnaGxpZ2h0XHJcbiAgICAgICRmb3JtLnJlbW92ZUNsYXNzKGNzc1ZhbGlkYXRpb25DbGFzcyk7XHJcblxyXG4gICAgICAvLyBDbGVhciBMaXN0ZW5lciwgcHJldmVudCBtZW1vcnkgbGVha1xyXG4gICAgICAkKCBcIiNqc19scy1tb2RhbFwiICkub2ZmKCBcImNsaWNrXCIsIFwidWwgbGkgYnV0dG9uLmpzX21zLWFkZC1saXN0X2J0blwiLCBhZGRNc0J1dHRvbkxpc3RlbmVyICk7XHJcbiAgICAgICQoJyNqc19vcGVuLW1hcF9idG4nKS5vZmYoIFwiY2xpY2tcIiwgbWFwTGlzdGVuZXIgKTtcclxuXHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBIYW5kbGVyIGZvciAnR0VUJyBidXR0b25cclxuICAgICAqIEBwYXJhbSBwYWdlTnVtZXJvIC0gaW50LiB1c2VkIGZvciBwYWdpbmF0aW9uXHJcbiAgICAgKiBAcGFyYW0gZXZlbnRVcmwgLSB1cmwgb2YgcmVxdWVzdFxyXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IC0gZG9uZS9mYWlsXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIHN1Ym1pdEZvcm0oLypvcHRpb25hbCovcGFnZU51bWVybykge1xyXG4gICAgICBwYWdlTnVtZXJvID0gcGFyc2VJbnQocGFnZU51bWVybyk7XHJcblxyXG4gICAgICB2YXIgdXJsID0gKCBpc05hTihwYWdlTnVtZXJvKSApID8gZXZlbnRVcmwgKyAnP2FwaWtleT0nICsgYXBpa2V5ICsgJyZrZXl3b3JkPScgKyBrZXl3b3JkLnZhbCgpIDpcclxuICAgICAgICBldmVudFVybCArICc/YXBpa2V5PScgKyBhcGlrZXkgKyAnJmtleXdvcmQ9JyArIGtleXdvcmQudmFsKCkgKyAnJnBhZ2U9JyArIHBhZ2VOdW1lcm87XHJcblxyXG4gICAgICAvL3N0b3AgbG9hZFxyXG4gICAgICBpZiAoaXNOYU4ocGFnZU51bWVybykgJiYgcGFnZU51bWVybyAhPT0gMCAmJiBzdGF0ZUNvbmYubG9hZGluZ0ZsYWcgPT09ICdTVE9QX0xPQUQnKSB7XHJcbiAgICAgICAgcmVuZGVyUmVzdWx0cyhudWxsLCAkdWwpO1xyXG4gICAgICAgIHJldHVybiBmYWxzZVxyXG4gICAgICB9XHJcblxyXG5cdFx0XHQvL3N0b3AgbG9hZFxyXG4gICAgICBpZiAoc3RhdGVDb25mLmxvYWRpbmdGbGFnID09PSAnRklOQUxfUEFHRScpIHJldHVybiBmYWxzZTtcclxuXHJcbiAgICAgICQuYWpheCh7XHJcbiAgICAgICAgZGF0YVR5cGU6ICdqc29uJyxcclxuICAgICAgICBhc3luYzogdHJ1ZSxcclxuICAgICAgICB1cmw6IHVybCxcclxuICAgICAgICBkYXRhOiAkZm9ybS5zZXJpYWxpemUoKVxyXG4gICAgICB9KS5kb25lKGZ1bmN0aW9uIChyZXN1bHQpIHtcclxuICAgICAgICBpZiAocmVzdWx0KSB7XHJcbiAgICAgICAgICAvL2xhc3QgcGFnZSByZWFjaGVkXHJcbiAgICAgICAgICBpZiAoc3RhdGVDb25mLnBhZ2VJbmNyZW1lbnQgPT09IHJlc3VsdC5wYWdlLnRvdGFsUGFnZXMgJiYgcmVzdWx0LnBhZ2UudG90YWxFbGVtZW50cyA+IDApIHtcclxuICAgICAgICAgICAgc3RhdGVDb25mLmxvYWRpbmdGbGFnID0gJ1NUT1BfTE9BRCc7XHJcbiAgICAgICAgICAgIGxvYWRpbmcoJ29mZicpO1xyXG4gICAgICAgICAgICByZW5kZXJSZXN1bHRzKHJlc3VsdCwgJHVsKTsgLy9hZGQgbWVzc2FnZSBhdCBib3R0b20gb2YgbGlzdFxyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgcmVuZGVyUmVzdWx0cyhyZXN1bHQsICR1bCk7XHJcbiAgICAgICAgICBsb2FkaW5nKCdvZmYnKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgY29uc29sZS5sb2coJ25vIHJlc3VsdCBmb3VuZCcpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSkuZmFpbChmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgIGNvbnNvbGUubG9nKCdUaGVyZSB3YXMgYW4gZmFpbCBzdGF0dXMgLSAnICwgZS5zdGF0dXMpO1xyXG4gICAgICAgIGxvYWRpbmcoJ29mZicpO1xyXG4gICAgICAgIHJlbmRlclJlc3VsdHMoJ0ZBSUwnLCAkdWwpO1xyXG4gICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIGZpbmQgaW1hZ2UgdGhhdCBoYXZlIHdpZHRoIG1vcmUgdGhlbiAxMjBweFxyXG4gICAgICogQHBhcmFtIGltYWdlcyAtIGFycmF5XHJcbiAgICAgKiBAcmV0dXJucyB7aW1hZ2Ugd2l0aCBsb3dlc3QrMSB3aWR0aCB9XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGdldEltYWdlRm9yRXZlbnQoaW1hZ2VzKSB7XHJcbiAgICAgIGltYWdlcy5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XHJcbiAgICAgICAgaWYgKGEud2lkdGggPCBiLndpZHRoKVxyXG4gICAgICAgICAgcmV0dXJuIC0xO1xyXG4gICAgICAgIGVsc2UgaWYgKGEud2lkdGggPiBiLndpZHRoKVxyXG4gICAgICAgICAgcmV0dXJuIDE7XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgICAgcmV0dXJuIDA7XHJcbiAgICAgIH0pO1xyXG5cdFx0XHR2YXIgc3JjID0gKGltYWdlc1swXS51cmwgKSA/IChpbWFnZXNbMV0gJiYgaW1hZ2VzWzFdLnVybCApPyBpbWFnZXNbMV0udXJsIDogaW1hZ2VzWzBdLnVybCA6ICcnO1xyXG4gICAgICByZXR1cm4gc3JjO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogcmVuZGVyIGZvciBldmVudHMtaWQtc2VsZWN0b3JcclxuICAgICAqIEBwYXJhbSBpdGVtcyAtIGFycmF5XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIHJlbmRlckxpc3RFdmVudHMoaXRlbXMpIHtcclxuICAgICAgdmFyIHNyYztcclxuICAgICAgaXRlbXMubWFwKGZ1bmN0aW9uIChpdGVtKSB7XHJcbiAgICAgICAgdmFyIGxpID0gJCgnPGxpLz4nKVxyXG4gICAgICAgICAgLmFkZENsYXNzKCdsaXN0LWdyb3VwLWl0ZW0gcm93JylcclxuICAgICAgICAgIC8vLmluc2VydEJlZm9yZSgkbGlGb290ZXIpO1xyXG4gICAgICAgICAgLmFwcGVuZFRvKCR1bCk7XHJcblxyXG4gICAgICAgIHZhciBsZWZ0Q29sID0gJCgnPGRpdiBjbGFzcz1cImNsZWFyLXBhZGRpbmdcIiAvPicpLmFwcGVuZFRvKGxpKTtcclxuICAgICAgICB2YXIgc3BhbkltZyA9ICQoJzxzcGFuIGNsYXNzPVwidGh1bWJuYWlsXCIgLz4nKVxyXG4gICAgICAgICAgLmFwcGVuZFRvKGxlZnRDb2wpO1xyXG5cclxuICAgICAgICBpZiAoaXRlbS5pbWFnZXMpIHtcclxuICAgICAgICAgIHNyYyA9IFwic3JjPVwiICsgZ2V0SW1hZ2VGb3JFdmVudChpdGVtLmltYWdlcyk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHNyYyA9ICdzdHlsZT1cImJhY2tncm91bmQtY29sb3I6ICNmN2Y5ZmE7d2lkdGg6IDEyMHB4OyBib3JkZXI6IG5vbmU7XCInO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIGltZyA9ICQoJzxpbWcgJyArIHNyYyArICcgLz4nKVxyXG4gICAgICAgICAgLmFkZENsYXNzKCdsaXN0LWdyb3VwLWl0ZW0taGVhZGluZycpXHJcbiAgICAgICAgICAuYXBwZW5kVG8oc3BhbkltZyk7XHJcblxyXG4gICAgICAgIHZhciAkd3JhcENvbCA9ICQoJzxkaXYgY2xhc3M9XCJldmVudC10ZXh0LXdyYXBwZXJcIi8+JylcclxuICAgICAgICAgIC5hcHBlbmRUbyhsaSk7XHJcbiAgICAgICAgaWYgKGl0ZW0ubmFtZSkge1xyXG4gICAgICAgICAgdmFyIHRpdGxlID0gJCgnPGg0Lz4nKVxyXG4gICAgICAgICAgICAuYWRkQ2xhc3MoJ2xpc3QtZ3JvdXAtaXRlbS1oZWFkaW5nJylcclxuICAgICAgICAgICAgLnRleHQoaXRlbS5uYW1lKVxyXG4gICAgICAgICAgICAuYXBwZW5kVG8oJHdyYXBDb2wpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLyphZGQgdGltZSovXHJcbiAgICAgICAgdmFyIGN1cnJlbnRFdmVudCA9IHt9O1xyXG4gICAgICAgIGN1cnJlbnRFdmVudC5kYXRlID0ge1xyXG4gICAgICAgICAgZGF5OiBpdGVtLmRhdGVzLnN0YXJ0LmxvY2FsRGF0ZSxcclxuICAgICAgICAgIHRpbWU6IGl0ZW0uZGF0ZXMuc3RhcnQubG9jYWxUaW1lLFxyXG4gICAgICAgICAgZGF0ZVRpbWU6IGl0ZW0uZGF0ZXMuc3RhcnQuZGF0ZVRpbWVcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICB2YXIgdGltZSA9IGZvcm1hdERhdGUoY3VycmVudEV2ZW50LmRhdGUpO1xyXG4gICAgICAgIHZhciBldmVudFRpbWUgPSAkKCc8aDQgY2xhc3M9XCJldmVudC10aW1lIGdyYXlcIi8+JylcclxuICAgICAgICAgIC50ZXh0KHRpbWUpXHJcbiAgICAgICAgICAuYXBwZW5kVG8oJHdyYXBDb2wpO1xyXG4gICAgICAgIC8qYWRkIHRpbWUgZW5kKi9cclxuXHJcbiAgICAgICAgaWYgKGl0ZW0uX2VtYmVkZGVkKSB7XHJcblxyXG4gICAgICAgICAgaWYgKGl0ZW0uX2VtYmVkZGVkLnZlbnVlcykge1xyXG4gICAgICAgICAgICB2YXIgdmVudWUgPSBpdGVtLl9lbWJlZGRlZC52ZW51ZXNbMF07XHJcbiAgICAgICAgICAgIHZhciBhZGRyZXNzTmFtZSA9ICQoJzxzcGFuLz4nKVxyXG4gICAgICAgICAgICAgIC5hZGRDbGFzcygnYWRkcmVzcy1uYW1lJylcclxuICAgICAgICAgICAgICAudGV4dCh2ZW51ZS5uYW1lICsgJy4gJylcclxuICAgICAgICAgICAgICAuYXBwZW5kVG8oJHdyYXBDb2wpO1xyXG5cclxuICAgICAgICAgICAgaWYgKCdhZGRyZXNzJyBpbiB2ZW51ZSAmJiAnbGluZTEnIGluIHZlbnVlLmFkZHJlc3MpIHtcclxuICAgICAgICAgICAgICB2YXIgYWRkcmVzc2xpbmUxID0gJCgnPHNwYW4vPicpXHJcbiAgICAgICAgICAgICAgICAuYWRkQ2xhc3MoJ2FkZHJlc3MtbGluZTEnKVxyXG4gICAgICAgICAgICAgICAgLnRleHQodmVudWUuYWRkcmVzcy5saW5lMSlcclxuICAgICAgICAgICAgICAgIC5hcHBlbmRUbygkd3JhcENvbCk7XHJcbiAgICAgICAgICAgICAgaWYgKCdsaW5lMicgaW4gdmVudWUuYWRkcmVzcykge1xyXG4gICAgICAgICAgICAgICAgdmFyIGFkZHJlc3NsaW5lMiA9ICQoJzxzcGFuLz4nKVxyXG4gICAgICAgICAgICAgICAgICAuYWRkQ2xhc3MoJ2FkZHJlc3MtbGluZTInKVxyXG4gICAgICAgICAgICAgICAgICAudGV4dCh2ZW51ZS5hZGRyZXNzLmxpbmUyKVxyXG4gICAgICAgICAgICAgICAgICAuYXBwZW5kVG8oYWRkcmVzc2xpbmUxKTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZygnbm8gX2VtYmVkZGVkIGZvdW5kJyk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoaXRlbS5pZCkge1xyXG4gICAgICAgICAgLy9hZGQgYnV0dG9uIDxTZXQgdGhpcyBJRD4gaWYgJ2xvY2F0aW9uJyBleGlzdFxyXG4gICAgICAgICAgdmFyIGJ1dHRvblNldElkID0gJChcIjxidXR0b24gZGF0YS1ldmVudD1cIiArIGl0ZW0uaWQgKyBcIi8+XCIpXHJcbiAgICAgICAgICAgIC5hZGRDbGFzcygnanNfbGF6eS1zZWxfYnRuIGJ0biBidG4tc3VibWl0JylcclxuICAgICAgICAgICAgLnRleHQoJ1VzZSB0aGlzIElEJylcclxuICAgICAgICAgICAgLmFwcGVuZFRvKGxpKVxyXG4gICAgICAgICAgICAud3JhcCgnPGRpdiBjbGFzcyA9XCJ3cmFwcGVyLWJ0bnMgdGV4dC1yaWdodFwiLz4nKTtcclxuXHJcblx0XHRcdFx0XHRcdHZhciBhZGRUb0VsID0ge2xpOiBsaSwgYnV0dG9uU2V0SWRXcmFwcGVyOiBidXR0b25TZXRJZC5wYXJlbnQoKX07XHJcblx0XHRcdFx0XHRcdGFkZE1zQnV0dG9uKCBhZGRUb0VsICwgaXRlbS5pZCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiByZW5kZXIgZm9yIHZlbnVlcy1pZC1zZWxlY3RvclxyXG4gICAgICogQHBhcmFtIGl0ZW1zIC0gYXJyYXlcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gcmVuZGVyTGlzdFZlbnVlcyhpdGVtcykge1xyXG4gICAgICBpdGVtcy5tYXAoZnVuY3Rpb24gKGl0ZW0pIHtcclxuXHJcbiAgICAgICAgdmFyIGxpID0gJCgnPGxpLz4nKVxyXG4gICAgICAgICAgLmFkZENsYXNzKCdsaXN0LWdyb3VwLWl0ZW0gcm93JylcclxuICAgICAgICAgIC5hcHBlbmRUbygkdWwpO1xyXG5cclxuICAgICAgICBpZiAoaXRlbS5pbWFnZXMpIHtcclxuICAgICAgICAgIHZhciBsZWZ0Q29sID0gJCgnPGRpdiBjbGFzcz1cImNsZWFyLXBhZGRpbmdcIiAvPicpLmFwcGVuZFRvKGxpKTtcclxuICAgICAgICAgIHZhciBzcGFuSW1nID0gJCgnPHNwYW4gY2xhc3M9XCJ0aHVtYm5haWxcIiAvPicpXHJcbiAgICAgICAgICAgIC5hcHBlbmRUbyhsZWZ0Q29sKTtcclxuICAgICAgICAgIHZhciBpbWcgPSAkKCc8aW1nIHNyYz0nICsgZ2V0SW1hZ2VGb3JFdmVudChpdGVtLmltYWdlcykgKyAnIC8+JylcclxuICAgICAgICAgICAgLmFkZENsYXNzKCdsaXN0LWdyb3VwLWl0ZW0taGVhZGluZycpXHJcbiAgICAgICAgICAgIC5hcHBlbmRUbyhzcGFuSW1nKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciAkd3JhcENvbCA9ICQoJzxkaXYgY2xhc3M9XCJldmVudC10ZXh0LXdyYXBwZXIgY2xlYXItbWFyZ2luLWxlZnRcIi8+JylcclxuICAgICAgICAgIC5hcHBlbmRUbyhsaSk7XHJcblxyXG4gICAgICAgIGlmIChpdGVtLm5hbWUpIHtcclxuICAgICAgICAgIHZhciB0aXRsZSA9ICQoJzxoMy8+JylcclxuICAgICAgICAgICAgLmFkZENsYXNzKCdsaXN0LWdyb3VwLWl0ZW0taGVhZGluZycpXHJcbiAgICAgICAgICAgIC50ZXh0KGl0ZW0ubmFtZSlcclxuICAgICAgICAgICAgLmFwcGVuZFRvKCR3cmFwQ29sKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChpdGVtLmRhdGVzKSB7XHJcbiAgICAgICAgICAvLyBjb25zb2xlLmxvZygnaXRlbS5kYXRlcycgLCBpdGVtLmRhdGVzKTtcclxuICAgICAgICAgIC8qYWRkIHRpbWUqL1xyXG4gICAgICAgICAgdmFyIGN1cnJlbnRFdmVudCA9IHt9O1xyXG4gICAgICAgICAgY3VycmVudEV2ZW50LmRhdGUgPSB7XHJcbiAgICAgICAgICAgIGRheTogaXRlbS5kYXRlcy5zdGFydC5sb2NhbERhdGUsXHJcbiAgICAgICAgICAgIHRpbWU6IGl0ZW0uZGF0ZXMuc3RhcnQubG9jYWxUaW1lLFxyXG4gICAgICAgICAgICBkYXRlVGltZTogaXRlbS5kYXRlcy5zdGFydC5kYXRlVGltZVxyXG4gICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICB2YXIgdGltZSA9IGZvcm1hdERhdGUoY3VycmVudEV2ZW50LmRhdGUpO1xyXG4gICAgICAgICAgdmFyIGV2ZW50VGltZSA9ICQoJzxoNCBjbGFzcz1cImV2ZW50LXRpbWUgZ3JheVwiLz4nKVxyXG4gICAgICAgICAgICAudGV4dCh0aW1lKVxyXG4gICAgICAgICAgICAuYXBwZW5kVG8oJHdyYXBDb2wpO1xyXG4gICAgICAgICAgLyphZGQgdGltZSBlbmQqL1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKGl0ZW0pIHtcclxuICAgICAgICAgIHZhciB2ZW51ZSA9IGl0ZW07IC8vIGl0ZW0uX2VtYmVkZGVkLnZlbnVlc1swXTtcclxuICAgICAgICAgIHZhciBjb250cnlTdGF0ZU5hbWUgPSAkKCc8aDQvPicpXHJcbiAgICAgICAgICAgIC5hZGRDbGFzcygnY291bnRyeS1uYW1lIGdyYXknKVxyXG4gICAgICAgICAgICAudGV4dCgodmVudWUuY291bnRyeSAmJiB2ZW51ZS5jb3VudHJ5Lm5hbWUpID8gdmVudWUuY291bnRyeS5uYW1lIDogJycpXHJcbiAgICAgICAgICAgIC5hcHBlbmQoKHZlbnVlLnN0YXRlICYmIHZlbnVlLnN0YXRlLm5hbWUpID8gJCgnPHNwYW4gY2xhc3M9XCJhZGQtZG90XCI+JyArdmVudWUuc3RhdGUubmFtZSsgJzwvPicpOiAnJylcclxuICAgICAgICAgICAgLmFwcGVuZFRvKCR3cmFwQ29sKTtcclxuICAgICAgICAgIHZhciBjaXR5TmFtZSA9ICQoJzxzcGFuLz4nKVxyXG4gICAgICAgICAgICAuYWRkQ2xhc3MoJ2FkZHJlc3MtbmFtZScpXHJcbiAgICAgICAgICAgIC50ZXh0KCh2ZW51ZS5jaXR5ICYmIHZlbnVlLmNpdHkubmFtZSkgPyB2ZW51ZS5jaXR5Lm5hbWUgKyAnLiAnIDogJycpXHJcbiAgICAgICAgICAgIC5hcHBlbmRUbygkd3JhcENvbCk7XHJcblxyXG4gICAgICAgICAgaWYgKCdhZGRyZXNzJyBpbiB2ZW51ZSAmJiAnbGluZTEnIGluIHZlbnVlLmFkZHJlc3MpIHtcclxuICAgICAgICAgICAgdmFyIGFkZHJlc3NsaW5lMSA9ICQoJzxzcGFuLz4nKVxyXG4gICAgICAgICAgICAgIC5hZGRDbGFzcygnYWRkcmVzcy1saW5lMScpXHJcbiAgICAgICAgICAgICAgLnRleHQodmVudWUuYWRkcmVzcy5saW5lMSArICcuJylcclxuICAgICAgICAgICAgICAuYXBwZW5kVG8oJHdyYXBDb2wpO1xyXG4gICAgICAgICAgICBpZiAoJ2xpbmUyJyBpbiB2ZW51ZS5hZGRyZXNzKSB7XHJcbiAgICAgICAgICAgICAgdmFyIGFkZHJlc3NsaW5lMiA9ICQoJzxzcGFuLz4nKVxyXG4gICAgICAgICAgICAgICAgLmFkZENsYXNzKCdhZGRyZXNzLWxpbmUyJylcclxuICAgICAgICAgICAgICAgIC50ZXh0KHZlbnVlLmFkZHJlc3MubGluZTIpXHJcbiAgICAgICAgICAgICAgICAuYXBwZW5kVG8oYWRkcmVzc2xpbmUxKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgY29uc29sZS5sb2coJ25vIF9lbWJlZGRlZCBmb3VuZCcpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKGl0ZW0uaWQpIHtcclxuICAgICAgICAgIHZhciBidXR0b25TZXRJZCA9ICQoXCI8YnV0dG9uIGRhdGEtZXZlbnQ9XCIgKyBpdGVtLmlkICsgXCIvPlwiKVxyXG4gICAgICAgICAgICAuYWRkQ2xhc3MoJ2pzX2xhenktc2VsX2J0biBidG4gYnRuLXN1Ym1pdCcpXHJcbiAgICAgICAgICAgIC50ZXh0KCdVc2UgdGhpcyBJRCcpXHJcbiAgICAgICAgICAgIC5hcHBlbmRUbyhsaSlcclxuICAgICAgICAgICAgLndyYXAoJzxkaXYgY2xhc3MgPVwid3JhcHBlci1idG5zIHRleHQtcmlnaHRcIi8+Jyk7XHJcbiAgICAgICAgICBpZiAodmVudWUubG9jYXRpb24gJiYgdmVudWUubG9jYXRpb24ubGF0aXR1ZGUgJiYgdmVudWUubG9jYXRpb24ubG9uZ2l0dWRlKSB7XHJcbiAgICAgICAgICAgIC8vY29uc29sZS5sb2coJ3ZlbnVlLmxvY2F0aW9uIC0gJyAsIHZlbnVlLmxvY2F0aW9uKTtcclxuICAgICAgICAgICAgdmFyIGJ1dHRvbk1hcCA9ICQoXCI8YnV0dG9uIGRhdGEtbGF0aXR1ZGU9XCIgKyB2ZW51ZS5sb2NhdGlvbi5sYXRpdHVkZSArIFwiIGRhdGEtbG9uZ2l0dWRlPVwiICsgdmVudWUubG9jYXRpb24ubG9uZ2l0dWRlICsgXCIvPlwiKVxyXG4gICAgICAgICAgICAgIC5hZGRDbGFzcygnanNfb3Blbi1tYXBfYnRuIGJ0biBidG4tdHJhbnNwYXJlbnQnKVxyXG4gICAgICAgICAgICAgIC50ZXh0KCdTaG93IG9uIG1hcCcpXHJcbiAgICAgICAgICAgICAgLmluc2VydEFmdGVyKGJ1dHRvblNldElkKVxyXG4gICAgICAgICAgICAgIC8vLmFwcGVuZFRvKGJ1dHRvblNldElkKVxyXG4gICAgICAgICAgICAgIC53cmFwKCc8ZGl2IGNsYXNzID1cIndyYXBwZXItbG9jYXRpb25fYnRuIHB1bGwtcmlnaHRcIi8+Jyk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICB2YXIgYWRkVG9FbCA9IHtsaTogbGksIGJ1dHRvblNldElkV3JhcHBlcjogYnV0dG9uU2V0SWQucGFyZW50KCl9O1xyXG4gICAgICAgICAgYWRkTXNCdXR0b24oIGFkZFRvRWwgLCBpdGVtLmlkKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIHJlbmRlciBmb3IgYXR0cmFjdGlvbnMtaWQtc2VsZWN0b3JcclxuICAgICAqIEBwYXJhbSBpdGVtcyAtIGFycmF5XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIHJlbmRlckxpc3RBdHRyYWN0aW9ucyhpdGVtcykge1xyXG4gICAgICBpdGVtcy5tYXAoZnVuY3Rpb24gKGl0ZW0pIHtcclxuXHJcbiAgICAgICAgdmFyIGxpID0gJCgnPGxpLz4nKVxyXG4gICAgICAgICAgLmFkZENsYXNzKCdsaXN0LWdyb3VwLWl0ZW0gcm93JylcclxuICAgICAgICAgIC5hcHBlbmRUbygkdWwpO1xyXG5cclxuICAgICAgICBpZiAoaXRlbS5pbWFnZXMpIHtcclxuICAgICAgICAgIHZhciBsZWZ0Q29sID0gJCgnPGRpdiBjbGFzcz1cImNsZWFyLXBhZGRpbmdcIiAvPicpLmFwcGVuZFRvKGxpKTtcclxuICAgICAgICAgIHZhciBzcGFuSW1nID0gJCgnPHNwYW4gY2xhc3M9XCJ0aHVtYm5haWxcIiAvPicpXHJcbiAgICAgICAgICAgIC5hcHBlbmRUbyhsZWZ0Q29sKTtcclxuICAgICAgICAgIHZhciBpbWcgPSAkKCc8aW1nIHNyYz0nICsgZ2V0SW1hZ2VGb3JFdmVudChpdGVtLmltYWdlcykgKyAnIC8+JylcclxuICAgICAgICAgICAgLmFkZENsYXNzKCdsaXN0LWdyb3VwLWl0ZW0taGVhZGluZycpXHJcbiAgICAgICAgICAgIC5hcHBlbmRUbyhzcGFuSW1nKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciAkd3JhcENvbCA9ICQoJzxkaXYgY2xhc3M9XCJldmVudC10ZXh0LXdyYXBwZXIgY2xlYXItbWFyZ2luLWxlZnRcIi8+JylcclxuICAgICAgICAgIC5hcHBlbmRUbyhsaSk7XHJcblxyXG4gICAgICAgIGlmIChpdGVtLm5hbWUpIHtcclxuICAgICAgICAgIHZhciB0aXRsZSA9ICQoJzxoMy8+JylcclxuICAgICAgICAgICAgLmFkZENsYXNzKCdsaXN0LWdyb3VwLWl0ZW0taGVhZGluZycpXHJcbiAgICAgICAgICAgIC50ZXh0KGl0ZW0ubmFtZSlcclxuICAgICAgICAgICAgLmFwcGVuZFRvKCR3cmFwQ29sKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8qYWRkIHRpbWUqL1xyXG4gICAgICAgIGlmIChpdGVtLmRhdGVzKSB7XHJcbiAgICAgICAgICB2YXIgY3VycmVudEV2ZW50ID0ge307XHJcbiAgICAgICAgICBjdXJyZW50RXZlbnQuZGF0ZSA9IHtcclxuICAgICAgICAgICAgZGF5OiBpdGVtLmRhdGVzLnN0YXJ0LmxvY2FsRGF0ZSxcclxuICAgICAgICAgICAgdGltZTogaXRlbS5kYXRlcy5zdGFydC5sb2NhbFRpbWUsXHJcbiAgICAgICAgICAgIGRhdGVUaW1lOiBpdGVtLmRhdGVzLnN0YXJ0LmRhdGVUaW1lXHJcbiAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgIHZhciB0aW1lID0gZm9ybWF0RGF0ZShjdXJyZW50RXZlbnQuZGF0ZSk7XHJcbiAgICAgICAgICB2YXIgZXZlbnRUaW1lID0gJCgnPGg0IGNsYXNzPVwiZXZlbnQtdGltZSBncmF5XCIvPicpXHJcbiAgICAgICAgICAgIC50ZXh0KHRpbWUpXHJcbiAgICAgICAgICAgIC5hcHBlbmRUbygkd3JhcENvbCk7XHJcbiAgICAgICAgfS8qYWRkIHRpbWUgZW5kKi9cclxuXHJcbiAgICAgICAgaWYoaXRlbS5jbGFzc2lmaWNhdGlvbnMpe1xyXG4gICAgICAgICAgaWYoaXRlbS5jbGFzc2lmaWNhdGlvbnMubGVuZ3RoID4gMSkgY29uc29sZS5sb2coaXRlbS5jbGFzc2lmaWNhdGlvbnMubGVuZ3RoKTtcclxuXHJcbiAgICAgICAgICB2YXIgX2dlbnJlLCBfc3ViZ2VucmUsX3NlZ21lbnQ7XHJcbiAgICAgICAgICBpZihpdGVtLmNsYXNzaWZpY2F0aW9uc1swXSl7XHJcbiAgICAgICAgICAgIF9zZWdtZW50ID0gaXRlbS5jbGFzc2lmaWNhdGlvbnNbMF0uc2VnbWVudDtcclxuICAgICAgICAgICAgX2dlbnJlID0gaXRlbS5jbGFzc2lmaWNhdGlvbnNbMF0uZ2VucmU7XHJcbiAgICAgICAgICAgIF9zdWJnZW5yZSA9IGl0ZW0uY2xhc3NpZmljYXRpb25zWzBdLnN1YkdlbnJlO1xyXG5cclxuICAgICAgICAgICAgdmFyIHNlZ21lbnRUZXh0ID0gJCgnPGg0Lz4nKVxyXG4gICAgICAgICAgICAgIC5hZGRDbGFzcygnY291bnRyeS1uYW1lIGdyYXknKVxyXG4gICAgICAgICAgICAgIC50ZXh0KCggX3NlZ21lbnQgJiYgX3NlZ21lbnQubmFtZSAmJiBfc2VnbWVudC5uYW1lICE9PSAnVW5kZWZpbmVkJykgPyBfc2VnbWVudC5uYW1lIDogJycpXHJcbiAgICAgICAgICAgICAgLmFwcGVuZFRvKCR3cmFwQ29sKTtcclxuXHJcbiAgICAgICAgICAgIHZhciBnZW5yZSA9ICQoJzxzcGFuLz4nKVxyXG4gICAgICAgICAgICAgIC5hZGRDbGFzcygnY2xhc3NpZmljYXRpb25zLW5hbWUnKVxyXG4gICAgICAgICAgICAgIC5hcHBlbmQoKCBfZ2VucmUgJiYgX2dlbnJlLm5hbWUgJiYgX2dlbnJlLm5hbWUgIT09ICdVbmRlZmluZWQnKSA/ICQoJzxzcGFuID4nICtfZ2VucmUubmFtZSsgJzwvPicpOiAnJylcclxuICAgICAgICAgICAgICAuYXBwZW5kKCggX3N1YmdlbnJlICYmIF9zdWJnZW5yZS5uYW1lICYmIF9zdWJnZW5yZS5uYW1lICE9PSAnVW5kZWZpbmVkJykgPyAkKCc8c3BhbiBjbGFzcz1cImFkZC1kb3RcIj4nICtfc3ViZ2VucmUubmFtZSsgJzwvPicpOiAnJylcclxuICAgICAgICAgICAgICAuYXBwZW5kVG8oJHdyYXBDb2wpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoaXRlbSkge1xyXG4gICAgICAgICAgdmFyIHZlbnVlID0gaXRlbTsgLy8gaXRlbS5fZW1iZWRkZWQudmVudWVzWzBdO1xyXG4gICAgICAgICAgdmFyIGNvbnRyeVN0YXRlTmFtZSA9ICQoJzxoNC8+JylcclxuICAgICAgICAgICAgLmFkZENsYXNzKCdjb3VudHJ5LW5hbWUgZ3JheScpXHJcbiAgICAgICAgICAgIC50ZXh0KCh2ZW51ZS5jb3VudHJ5ICYmIHZlbnVlLmNvdW50cnkubmFtZSkgPyB2ZW51ZS5jb3VudHJ5Lm5hbWUgKyAnLiAnIDogJycpXHJcbiAgICAgICAgICAgIC5hcHBlbmQoKHZlbnVlLnN0YXRlICYmIHZlbnVlLnN0YXRlLm5hbWUpID8gdmVudWUuc3RhdGUubmFtZSArICcuICcgOiAnJylcclxuICAgICAgICAgICAgLmFwcGVuZFRvKCR3cmFwQ29sKTtcclxuICAgICAgICAgIHZhciBjaXR5TmFtZSA9ICQoJzxzcGFuLz4nKVxyXG4gICAgICAgICAgICAuYWRkQ2xhc3MoJ2FkZHJlc3MtbmFtZScpXHJcbiAgICAgICAgICAgIC50ZXh0KCh2ZW51ZS5jaXR5ICYmIHZlbnVlLmNpdHkubmFtZSkgPyB2ZW51ZS5jaXR5Lm5hbWUgKyAnLiAnIDogJycpXHJcbiAgICAgICAgICAgIC5hcHBlbmRUbygkd3JhcENvbCk7XHJcblxyXG4gICAgICAgICAgaWYgKCdhZGRyZXNzJyBpbiB2ZW51ZSAmJiAnbGluZTEnIGluIHZlbnVlLmFkZHJlc3MpIHtcclxuICAgICAgICAgICAgdmFyIGFkZHJlc3NsaW5lMSA9ICQoJzxzcGFuLz4nKVxyXG4gICAgICAgICAgICAgIC5hZGRDbGFzcygnYWRkcmVzcy1saW5lMScpXHJcbiAgICAgICAgICAgICAgLnRleHQodmVudWUuYWRkcmVzcy5saW5lMSArICcuJylcclxuICAgICAgICAgICAgICAuYXBwZW5kVG8oJHdyYXBDb2wpO1xyXG4gICAgICAgICAgICBpZiAoJ2xpbmUyJyBpbiB2ZW51ZS5hZGRyZXNzKSB7XHJcbiAgICAgICAgICAgICAgdmFyIGFkZHJlc3NsaW5lMiA9ICQoJzxzcGFuLz4nKVxyXG4gICAgICAgICAgICAgICAgLmFkZENsYXNzKCdhZGRyZXNzLWxpbmUyJylcclxuICAgICAgICAgICAgICAgIC50ZXh0KHZlbnVlLmFkZHJlc3MubGluZTIpXHJcbiAgICAgICAgICAgICAgICAuYXBwZW5kVG8oYWRkcmVzc2xpbmUxKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgY29uc29sZS5sb2coJ25vIF9lbWJlZGRlZCBmb3VuZCcpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKGl0ZW0uaWQpIHtcclxuICAgICAgICAgIHZhciBidXR0b25TZXRJZCA9ICQoXCI8YnV0dG9uIGRhdGEtZXZlbnQ9XCIgKyBpdGVtLmlkICsgXCIvPlwiKVxyXG4gICAgICAgICAgICAuYWRkQ2xhc3MoJ2pzX2xhenktc2VsX2J0biBidG4gYnRuLXN1Ym1pdCcpXHJcbiAgICAgICAgICAgIC50ZXh0KCdVc2UgdGhpcyBJRCcpXHJcbiAgICAgICAgICAgIC5hcHBlbmRUbyhsaSlcclxuICAgICAgICAgICAgLndyYXAoJzxkaXYgY2xhc3MgPVwid3JhcHBlci1idG5zIHRleHQtcmlnaHRcIi8+Jyk7XHJcbiAgICAgICAgICBpZiAodmVudWUubG9jYXRpb24gJiYgdmVudWUubG9jYXRpb24ubGF0aXR1ZGUgJiYgdmVudWUubG9jYXRpb24ubG9uZ2l0dWRlKSB7XHJcbiAgICAgICAgICAgIC8vY29uc29sZS5sb2coJ3ZlbnVlLmxvY2F0aW9uIC0gJyAsIHZlbnVlLmxvY2F0aW9uKTtcclxuICAgICAgICAgICAgdmFyIGJ1dHRvbk1hcCA9ICQoXCI8YnV0dG9uIHN0eWxlPSdmbG9hdDogcmlnaHQ7JyBkYXRhLWxhdGl0dWRlPVwiICsgdmVudWUubG9jYXRpb24ubGF0aXR1ZGUgKyBcIiBkYXRhLWxvbmdpdHVkZT1cIiArIHZlbnVlLmxvY2F0aW9uLmxvbmdpdHVkZSArIFwiLz5cIilcclxuICAgICAgICAgICAgICAuYWRkQ2xhc3MoJ2pzX29wZW4tbWFwX2J0biBidG4gYnRuLXRyYW5zcGFyZW50JylcclxuICAgICAgICAgICAgICAudGV4dCgnU2hvdyBvbiBtYXAnKVxyXG4gICAgICAgICAgICAgIC5pbnNlcnRBZnRlcihidXR0b25TZXRJZClcclxuICAgICAgICAgICAgICAvLy5hcHBlbmRUbyhidXR0b25TZXRJZClcclxuICAgICAgICAgICAgICAud3JhcCgnPGRpdiBjbGFzcyA9XCJ3cmFwcGVyLWxvY2F0aW9uX2J0blwiLz4nKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIHZhciBhZGRUb0VsID0ge2xpOiBsaSwgYnV0dG9uU2V0SWRXcmFwcGVyOiBidXR0b25TZXRJZC5wYXJlbnQoKX07XHJcbiAgICAgICAgICBhZGRNc0J1dHRvbiggYWRkVG9FbCAsIGl0ZW0uaWQpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGhhc1Njcm9sbEJhcihlbGVtZW50LCB3cmFwcGVyKSB7XHJcbiAgICAgIHJldHVybiBlbGVtZW50LmdldCgwKS5zY3JvbGxIZWlnaHQgPiBlbGVtZW50LnBhcmVudCgpLmlubmVySGVpZ2h0KCk7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIHJlbmRlclJlc3VsdHMgPSBmdW5jdGlvbiAoZGF0YSwgdWxFbGVtZW50KSB7XHJcbiAgICAgIHZhciBpdGVtcztcclxuXHJcbiAgICAgIGZ1bmN0aW9uIHNob3dNZXNzYWdlKGVsZW1lbnQsIG1lc3NhZ2UsIC8qb3B0aW9uYWwqL2NsZWFyTGlzdCkge1xyXG4gICAgICAgICRidG5HRVQuYXR0cignZGlzYWJsZWQnLCBmYWxzZSk7XHJcblxyXG4gICAgICAgIGlmIChjbGVhckxpc3QpICQoJ2xpJywgZWxlbWVudCkucmVtb3ZlKCk7XHJcbiAgICAgICAgZWxlbWVudC5jc3MoeydvdmVyZmxvdyc6ICdhdXRvJ30pO1xyXG4gICAgICAgICQoJzxsaS8+JylcclxuICAgICAgICAgIC5hZGRDbGFzcygnbGlzdC1ncm91cC1pdGVtIHRleHQtY2VudGVyJylcclxuICAgICAgICAgIC50ZXh0KG1lc3NhZ2UpXHJcbiAgICAgICAgICAuYXBwZW5kVG8odWxFbGVtZW50KTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKHN0YXRlQ29uZi5sb2FkaW5nRmxhZyA9PT0gXCJGSU5BTF9QQUdFXCIpIHJldHVybiBmYWxzZTsgLy9leGl0IGlmIGhhcyByZWFjaGVkIGxhc3QgcGFnZVxyXG5cclxuICAgICAgLy9zaG93IGZhaWwgbXNnXHJcbiAgICAgIGlmIChkYXRhID09PSAnRkFJTCcpIHtcclxuICAgICAgICBzaG93TWVzc2FnZSgkdWwsICdGYWlsdXJlLCBwb3NzaWJsZSBrZXkgbm90IGNvcnJlY3QuJywgdHJ1ZSk7XHJcbiAgICAgICAgbW9kYWxDb250ZW50LnJlbW92ZUNsYXNzKCduYXJyb3cnKTtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChzdGF0ZUNvbmYubG9hZGluZ0ZsYWcgPT09ICdTVE9QX0xPQUQnICYmIGRhdGEubGVuZ3RoICE9PSAwKSB7XHJcbiAgICAgICAgc3RhdGVDb25mLmxvYWRpbmdGbGFnID0gXCJGSU5BTF9QQUdFXCI7XHJcbiAgICAgICAgc2hvd01lc3NhZ2UodWxFbGVtZW50LCAnTm8gbW9yZSByZXN1bHRzLicsIGZhbHNlKTtcclxuICAgICAgICAkbGlGb290ZXIuaGlkZSgpO1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKGRhdGEgPT09IG51bGwgfHwgIWRhdGEuX2VtYmVkZGVkKSB7XHJcbiAgICAgICAgc2hvd01lc3NhZ2UodWxFbGVtZW50LCAnTm8gcmVzdWx0cyBmb3VuZC4nLCB0cnVlKTtcclxuICAgICAgICBtb2RhbENvbnRlbnQucmVtb3ZlQ2xhc3MoJ25hcnJvdycpO1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy9zdGFydCByZW5kZXIgZGF0YVxyXG4gICAgICBpZiAoc2VsZWN0b3IgPT09ICdldmVudHMnKSB7XHJcbiAgICAgICAgaXRlbXMgPSAoZGF0YSAmJiBkYXRhLl9lbWJlZGRlZCAmJiBkYXRhLl9lbWJlZGRlZC5ldmVudHMpID8gZGF0YS5fZW1iZWRkZWQuZXZlbnRzIDogWycnXTtcclxuICAgICAgICByZW5kZXJMaXN0RXZlbnRzKGl0ZW1zKVxyXG4gICAgICB9IGVsc2UgaWYgKHNlbGVjdG9yID09PSAndmVudWVzJykge1xyXG4gICAgICAgIGl0ZW1zID0gKGRhdGEgJiYgZGF0YS5fZW1iZWRkZWQgJiYgZGF0YS5fZW1iZWRkZWQudmVudWVzKSA/IGRhdGEuX2VtYmVkZGVkLnZlbnVlcyA6IFsnJ107XHJcbiAgICAgICAgcmVuZGVyTGlzdFZlbnVlcyhpdGVtcyk7XHJcbiAgICAgIH0gZWxzZSBpZiAoc2VsZWN0b3IgPT09ICdhdHRyYWN0aW9ucycpIHtcclxuICAgICAgICBpdGVtcyA9IChkYXRhICYmIGRhdGEuX2VtYmVkZGVkICYmIGRhdGEuX2VtYmVkZGVkLmF0dHJhY3Rpb25zKSA/IGRhdGEuX2VtYmVkZGVkLmF0dHJhY3Rpb25zIDogWycnXTtcclxuICAgICAgICByZW5kZXJMaXN0QXR0cmFjdGlvbnMoaXRlbXMpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvL2hpZGUgc2Nyb2xsIGlmIHJlY2l2ZSBsZXNzIHRoZW4gMiBpdGVtc1xyXG4gICAgICBpZiAoaGFzU2Nyb2xsQmFyKCR1bCkpIHtcclxuICAgICAgICAkdWwucmVtb3ZlQ2xhc3MoJ25vLXNjcm9sbCcpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgICR1bC5hZGRDbGFzcygnbm8tc2Nyb2xsJyk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIGhpZGUvc2hvdyBob3Jpem9udGFsIGxpbmUgYW5kIGJ1dHRvbiA8bG9hZCBtb3JlPlxyXG4gICAgICBpZiAoZGF0YSAmJiBkYXRhLnBhZ2UgJiYgZGF0YS5wYWdlLnRvdGFsRWxlbWVudHMgPiAyMCkge1xyXG4gICAgICAgICRoci5zaG93KCk7XHJcbiAgICAgICAgJGxpRm9vdGVyLnNob3coKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICAkaHIuaGlkZSgpO1xyXG4gICAgICAgICRsaUZvb3Rlci5oaWRlKCk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIGhpZGUgYnV0dG9uIDxsb2FkIG1vcmU+IGlmIG5vdGhpbmcgbGVmdCB0byBsb2FkXHJcbiAgICAgIGlmIChzdGF0ZUNvbmYubG9hZGluZ0ZsYWcgPT09ICdTVE9QX0xPQUQnIHx8IChzdGF0ZUNvbmYucGFnZUluY3JlbWVudCArIDEpID09PSBkYXRhLnBhZ2UudG90YWxQYWdlcykge1xyXG4gICAgICAgICRoci5oaWRlKCk7XHJcbiAgICAgICAgJGxpRm9vdGVyLmhpZGUoKTtcclxuICAgICAgfVxyXG4gICAgICBpZiAoZGF0YS5wYWdlLnRvdGFsRWxlbWVudHMgPiAwIHx8IGl0ZW1zLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAkaHIuc2hvdygpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLzxzaG93IG1hcD4gYnV0dG9uXHJcbiAgICAgICQoJy5qc19vcGVuLW1hcF9idG4nKS5vbignY2xpY2snLCBtYXBMaXN0ZW5lciApO1xyXG5cclxuICAgICAgJCgnLmpzX2xhenktc2VsX2J0bicpLm9uKCdjbGljaycsIHNldElkTGlzdGVuZXIpO1xyXG5cclxuICAgICAgJCggXCIjanNfbHMtbW9kYWxcIiApLm9uKCBcImNsaWNrXCIsIFwidWwgbGkgYnV0dG9uLmpzX21zLWFkZC1saXN0X2J0blwiLCBhZGRNc0J1dHRvbkxpc3RlbmVyICk7XHJcblxyXG4gICAgICAvL3NldCBhdmFpbGlibGUgPEdldD4gYnV0dG9uIGFmdGVyIGxvYWQgaXMgZmluaXNoZWRcclxuICAgICAgJGJ0bkdFVC5hdHRyKCdkaXNhYmxlZCcsIGZhbHNlKTtcclxuXHJcbiAgICB9O1xyXG5cclxuICAgIGZ1bmN0aW9uIG1hcExpc3RlbmVyKGUpIHtcclxuICAgICAgdmFyIHNjcmVlbldpZHRoID0gTWF0aC5tYXgoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudFdpZHRoLCB3aW5kb3cuaW5uZXJXaWR0aCB8fCAwKTtcclxuICAgICAgdmFyIGlzTW9iaWxlID0gZmFsc2U7IC8vaW5pdGlhdGUgYXMgZmFsc2VcclxuICAgICAgLy8gZGV2aWNlIGRldGVjdGlvblxyXG4gICAgICBpZigvKGFuZHJvaWR8YmJcXGQrfG1lZWdvKS4rbW9iaWxlfGF2YW50Z298YmFkYVxcL3xibGFja2JlcnJ5fGJsYXplcnxjb21wYWx8ZWxhaW5lfGZlbm5lY3xoaXB0b3B8aWVtb2JpbGV8aXAoaG9uZXxvZCl8aXBhZHxpcmlzfGtpbmRsZXxBbmRyb2lkfFNpbGt8bGdlIHxtYWVtb3xtaWRwfG1tcHxuZXRmcm9udHxvcGVyYSBtKG9ifGluKWl8cGFsbSggb3MpP3xwaG9uZXxwKGl4aXxyZSlcXC98cGx1Y2tlcnxwb2NrZXR8cHNwfHNlcmllcyg0fDYpMHxzeW1iaWFufHRyZW98dXBcXC4oYnJvd3NlcnxsaW5rKXx2b2RhZm9uZXx3YXB8d2luZG93cyAoY2V8cGhvbmUpfHhkYXx4aWluby9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudClcclxuICAgICAgICB8fCAvMTIwN3w2MzEwfDY1OTB8M2dzb3w0dGhwfDUwWzEtNl1pfDc3MHN8ODAyc3xhIHdhfGFiYWN8YWMoZXJ8b298c1xcLSl8YWkoa298cm4pfGFsKGF2fGNhfGNvKXxhbW9pfGFuKGV4fG55fHl3KXxhcHR1fGFyKGNofGdvKXxhcyh0ZXx1cyl8YXR0d3xhdShkaXxcXC1tfHIgfHMgKXxhdmFufGJlKGNrfGxsfG5xKXxiaShsYnxyZCl8YmwoYWN8YXopfGJyKGV8dil3fGJ1bWJ8YndcXC0obnx1KXxjNTVcXC98Y2FwaXxjY3dhfGNkbVxcLXxjZWxsfGNodG18Y2xkY3xjbWRcXC18Y28obXB8bmQpfGNyYXd8ZGEoaXR8bGx8bmcpfGRidGV8ZGNcXC1zfGRldml8ZGljYXxkbW9ifGRvKGN8cClvfGRzKDEyfFxcLWQpfGVsKDQ5fGFpKXxlbShsMnx1bCl8ZXIoaWN8azApfGVzbDh8ZXooWzQtN10wfG9zfHdhfHplKXxmZXRjfGZseShcXC18Xyl8ZzEgdXxnNTYwfGdlbmV8Z2ZcXC01fGdcXC1tb3xnbyhcXC53fG9kKXxncihhZHx1bil8aGFpZXxoY2l0fGhkXFwtKG18cHx0KXxoZWlcXC18aGkocHR8dGEpfGhwKCBpfGlwKXxoc1xcLWN8aHQoYyhcXC18IHxffGF8Z3xwfHN8dCl8dHApfGh1KGF3fHRjKXxpXFwtKDIwfGdvfG1hKXxpMjMwfGlhYyggfFxcLXxcXC8pfGlicm98aWRlYXxpZzAxfGlrb218aW0xa3xpbm5vfGlwYXF8aXJpc3xqYSh0fHYpYXxqYnJvfGplbXV8amlnc3xrZGRpfGtlaml8a2d0KCB8XFwvKXxrbG9ufGtwdCB8a3djXFwtfGt5byhjfGspfGxlKG5vfHhpKXxsZyggZ3xcXC8oa3xsfHUpfDUwfDU0fFxcLVthLXddKXxsaWJ3fGx5bnh8bTFcXC13fG0zZ2F8bTUwXFwvfG1hKHRlfHVpfHhvKXxtYygwMXwyMXxjYSl8bVxcLWNyfG1lKHJjfHJpKXxtaShvOHxvYXx0cyl8bW1lZnxtbygwMXwwMnxiaXxkZXxkb3x0KFxcLXwgfG98dil8enopfG10KDUwfHAxfHYgKXxtd2JwfG15d2F8bjEwWzAtMl18bjIwWzItM118bjMwKDB8Mil8bjUwKDB8Mnw1KXxuNygwKDB8MSl8MTApfG5lKChjfG0pXFwtfG9ufHRmfHdmfHdnfHd0KXxub2soNnxpKXxuenBofG8yaW18b3AodGl8d3YpfG9yYW58b3dnMXxwODAwfHBhbihhfGR8dCl8cGR4Z3xwZygxM3xcXC0oWzEtOF18YykpfHBoaWx8cGlyZXxwbChheXx1Yyl8cG5cXC0yfHBvKGNrfHJ0fHNlKXxwcm94fHBzaW98cHRcXC1nfHFhXFwtYXxxYygwN3wxMnwyMXwzMnw2MHxcXC1bMi03XXxpXFwtKXxxdGVrfHIzODB8cjYwMHxyYWtzfHJpbTl8cm8odmV8em8pfHM1NVxcL3xzYShnZXxtYXxtbXxtc3xueXx2YSl8c2MoMDF8aFxcLXxvb3xwXFwtKXxzZGtcXC98c2UoYyhcXC18MHwxKXw0N3xtY3xuZHxyaSl8c2doXFwtfHNoYXJ8c2llKFxcLXxtKXxza1xcLTB8c2woNDV8aWQpfHNtKGFsfGFyfGIzfGl0fHQ1KXxzbyhmdHxueSl8c3AoMDF8aFxcLXx2XFwtfHYgKXxzeSgwMXxtYil8dDIoMTh8NTApfHQ2KDAwfDEwfDE4KXx0YShndHxsayl8dGNsXFwtfHRkZ1xcLXx0ZWwoaXxtKXx0aW1cXC18dFxcLW1vfHRvKHBsfHNoKXx0cyg3MHxtXFwtfG0zfG01KXx0eFxcLTl8dXAoXFwuYnxnMXxzaSl8dXRzdHx2NDAwfHY3NTB8dmVyaXx2aShyZ3x0ZSl8dmsoNDB8NVswLTNdfFxcLXYpfHZtNDB8dm9kYXx2dWxjfHZ4KDUyfDUzfDYwfDYxfDcwfDgwfDgxfDgzfDg1fDk4KXx3M2MoXFwtfCApfHdlYmN8d2hpdHx3aShnIHxuY3xudyl8d21sYnx3b251fHg3MDB8eWFzXFwtfHlvdXJ8emV0b3x6dGVcXC0vaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQuc3Vic3RyKDAsNCkpKSBpc01vYmlsZSA9IHRydWU7XHJcblxyXG4gICAgICBpZighaXNNb2JpbGUgfHwgc2NyZWVuV2lkdGggPj0gNzY4KSB7XHJcbiAgICAgICAgbWFwUG9wVXBMaXN0ZW5lcihlKTtcclxuICAgICAgICBtb2RhbENvbnRlbnQuYWRkQ2xhc3MoJ25hcnJvdycpO1xyXG4gICAgICAgIGJ0bkNsb3NlTWFwLnNob3coKTtcclxuICAgICAgfWVsc2UgaWYoaXNNb2JpbGUpe1xyXG4gICAgICAgIHZhciBsYXQgPSAkKGUudGFyZ2V0KS5hdHRyKCdkYXRhLWxhdGl0dWRlJykgIT0gXCJ1bmRlZmluZWRcIiA/IHBhcnNlRmxvYXQoJChlLnRhcmdldCkuYXR0cignZGF0YS1sYXRpdHVkZScpKSA6IG51bGwsXHJcbiAgICAgICAgICBsbmcgPSAkKGUudGFyZ2V0KS5hdHRyKCdkYXRhLWxvbmdpdHVkZScpICE9IFwidW5kZWZpbmVkXCIgPyBwYXJzZUZsb2F0KCQoZS50YXJnZXQpLmF0dHIoJ2RhdGEtbG9uZ2l0dWRlJykpIDogbnVsbDtcclxuICAgICAgICBpZiAobGF0ICYmIGxuZyApIHtcclxuICAgICAgICAgIGxvY2F0aW9uLmhyZWY9J2dlbzonK2xuZysnLCcrbGF0O1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBsb2NhdGlvbi5ocmVmPSdnZW86MCwwJztcclxuICAgICAgICB9XHJcblxyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gYWRkTXNCdXR0b24oZWwsIGRhdGEpe1xyXG5cdFx0XHRpZihvcHRpb25zLmhpZGVNdWx0aVNlbGVjdG9yKSByZXR1cm4gZmFsc2U7XHJcblxyXG5cdFx0XHQvL2FkZCBidXR0b24gPEFERCB0byBsaXN0PlxyXG5cdFx0XHR2YXIgYnV0dG9uQWRkSWRUb0xpc3QgPSAkKFwiPGJ1dHRvbiBkYXRhLWlkPVwiICsgZGF0YSArIFwiLz5cIilcclxuXHRcdFx0XHQuYWRkQ2xhc3MoJ2pzX21zLWFkZC1saXN0X2J0biBwdWxsLXJpZ2h0IGJ0biBidG4gYnRuLXRyYW5zcGFyZW50JylcclxuXHRcdFx0XHQudGV4dCgnQUREIHRvIGxpc3QnKVxyXG5cdFx0XHRcdC5hcHBlbmRUbyhlbC5saS5maW5kKGVsLmJ1dHRvblNldElkV3JhcHBlcikpO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHNldElkTGlzdGVuZXIoZSl7XHJcbiAgICAgIHZhciBzZWxlY3RlZElEID0gZS50YXJnZXQuZ2V0QXR0cmlidXRlKCdkYXRhLWV2ZW50Jyk7XHJcbiAgICAgICRpbnB1dC52YWwoc2VsZWN0ZWRJRClcclxuICAgICAgICAuYXR0cigndmFsdWUnLCBzZWxlY3RlZElEKVxyXG4gICAgICAgIC50cmlnZ2VyKCdjaGFuZ2UnKTsgIC8vdXBkYXRlIHdpZGdldDpcclxuICAgICAgc3RhdGVDb25mLnNldFNpbmdsZVZhbCA9IHRydWU7XHJcblxyXG4gICAgICAvL2NsZWFyIHRhZ3MgYm94IG9mIGN1cnJlbnQgc2VsZWN0b3IgKHRoYXQgZXF1YWwgJ3NlbGVjdGVkSUQnIHZhbClcclxuICAgICAgY29uZmlnLmZvckVhY2goZnVuY3Rpb24gKGVsKSB7XHJcbiAgICAgICAgdGFnc0lkc1tzZWxlY3RlZElEXSA9IFtdO1xyXG4gICAgICB9KTtcclxuICAgICAgLy8gQ2xvc2UgZGlhbG9nXHJcbiAgICAgICRtb2RhbC5tb2RhbCgnaGlkZScpO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHNldElkc0xpc3RlbmVyKGUpe1xyXG4gICAgICBpZiAoJGJ0bkdFVC5hdHRyKCdkYXRhLXNlbGVjdG9yJykgIT09ICRpY29uQnV0dG9uLmF0dHIoJ2RhdGEtc2VsZWN0b3InKSkgcmV0dXJuIGZhbHNlO1xyXG4gICAgICB2YXIgc2VsZWN0ZWRJRCA9IHRhZ3NJZHNbc2VsZWN0b3JdO1xyXG5cclxuXHRcdFx0Ly8gc2V0IGlzYWJsZT10cnVlIHRvIGFsbCBpdGVtcyBpbiB0YWdzLWxpc3RcclxuXHRcdFx0JCgnbGknLCRtc0xpc3QpXHJcblx0XHRcdFx0LmVhY2goICBmdW5jdGlvbigpIHsgJCh0aGlzKS5hdHRyKCdkYXRhLWlzYWJsZScsdHJ1ZSl9ICApO1xyXG5cclxuICAgICAgJGlucHV0LnZhbChzZWxlY3RlZElEKVxyXG4gICAgICBcdC5hdHRyKCd2YWx1ZScsIHNlbGVjdGVkSUQpXHJcbiAgICAgIFx0LnRyaWdnZXIoJ2NoYW5nZScpOyAgLy91cGRhdGUgd2lkZ2V0OlxyXG5cclxuICAgICAgLy8gQ2xvc2UgZGlhbG9nXHJcbiAgICAgICRtb2RhbC5tb2RhbCgnaGlkZScpO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGNsZWFyQnlBcnJWYWwoc2VsZWN0ZWRJRCwgaW5kVG9SZW1vdmUpIHtcclxuICAgICAgZnVuY3Rpb24gbWFwQW55KGFycmF5KSB7XHJcbiAgICAgICAgYXJyYXkubWFwKGZ1bmN0aW9uIChpdGVtKSB7XHJcbiAgICAgICAgICBzZWxlY3RlZElELnNwbGljZShzZWxlY3RlZElELmluZGV4T2YoaXRlbSksIDEpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZihzZWxlY3RlZElELmxlbmd0aCA+PSBpbmRUb1JlbW92ZS5sZW5ndGgpIHtcclxuICAgICAgICBtYXBBbnkoaW5kVG9SZW1vdmUpO1xyXG4gICAgICB9ZWxzZXtcclxuICAgICAgICBtYXBBbnkoc2VsZWN0ZWRJRCk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBkZWxJZExpc3RlbmVyKGV2ZW50KXtcclxuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgdmFyIG1lID0gJCggdGhpcyApLFxyXG4gICAgICAgIHRhZ0lEID0gbWUucGFyZW50cygnbGknKS5kYXRhKCdzZWxlY3Rvci0nK3NlbGVjdG9yKSxcclxuICAgICAgICBzZWxlY3RlZElEID0gdGFnc0lkc1tzZWxlY3Rvcl07XHJcbiAgICAgIHZhciBpbmRUb1JlbW92ZSA9W107XHJcblxyXG4gICAgICBtZS5wYXJlbnRzKCdsaScpLnJlbW92ZSgpO1xyXG4gICAgICBpbmRUb1JlbW92ZS5wdXNoKHRhZ0lEKTtcclxuICAgICAgY2xlYXJCeUFyclZhbChzZWxlY3RlZElELCBpbmRUb1JlbW92ZSk7XHJcblxyXG4gICAgICAvL3VwZGF0ZSBpbnB1dCB2YWx1ZXNcclxuICAgICAgJGlucHV0LnZhbChzZWxlY3RlZElEKVxyXG4gICAgICAgIC5hdHRyKCd2YWx1ZScsIHNlbGVjdGVkSUQpXHJcbiAgICAgICAgLnRyaWdnZXIoJ2NoYW5nZScpOyAgLy91cGRhdGUgd2lkZ2V0OlxyXG5cclxuICAgICAgdG9nZ2xlTXNTZWxlY3Rpb25Cb3goKTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBhZGRNc0J1dHRvbkxpc3RlbmVyKGV2ZW50KXtcclxuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcclxuXHJcbiAgICAgIGZ1bmN0aW9uIGlzVW5pcXVlKGxpc3QpIHtcclxuICAgICAgICB2YXIgcmVzdWx0ID0gW10sXHJcbiAgICAgICAgICB1bmlxdWUgPSBmYWxzZTtcclxuXHJcbiAgICAgICAgJC5lYWNoKGxpc3QsIGZ1bmN0aW9uKGksIGUpIHtcclxuICAgICAgICAgIGlmICgkLmluQXJyYXkoZSwgcmVzdWx0KSA9PSAtMSl7XHJcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKGUpO1xyXG4gICAgICAgICAgICB1bmlxdWUgPSB0cnVlO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHVuaXF1ZSA9IGZhbHNlO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiB1bmlxdWU7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHZhciBtZSA9ICQoIHRoaXMgKSxcclxuICAgICAgICAgIHRpdGxlID0gbWUucGFyZW50cygnbGknKS5maW5kKCcubGlzdC1ncm91cC1pdGVtLWhlYWRpbmcnLCcuZXZlbnQtdGV4dC13cmFwcGVyJykudGV4dCgpLFxyXG4gICAgICAgICAgdW5pcXVlVXBjb21pbmcsXHJcbiAgICAgICAgICBjdXJyZW50TGlzdCA9IHRhZ3NJZHNbc2VsZWN0b3JdO1xyXG5cclxuICAgICAgY3VycmVudExpc3QucHVzaChtZS5kYXRhKCdpZCcpKTtcclxuICAgICAgdW5pcXVlVXBjb21pbmcgPSBpc1VuaXF1ZShjdXJyZW50TGlzdCk7IC8vIEdldCBsaXN0IG9mIHVwY29taW5nIHRhZ3NcclxuXHJcbiAgICAgIGlmKCB1bmlxdWVVcGNvbWluZyApe1xyXG4gICAgICAgIHZhciBpdGVtID0gJCgnPGxpLz4nKVxyXG4gICAgICAgICAgLmFkZENsYXNzKCdtcy1lbGVtLXNlbGVjdGlvbicpXHJcbiAgICAgICAgICAudGV4dCh0aXRsZSlcclxuICAgICAgICAgIC5hdHRyKCdkYXRhLXNlbGVjdG9yLScrc2VsZWN0b3IsIG1lLmRhdGEoJ2lkJykpXHJcbiAgICAgICAgICAuYXR0cignZGF0YS1pc2FibGUnLGZhbHNlKVxyXG4gICAgICAgICAgLmFwcGVuZFRvKCRtc0xpc3QpO1xyXG4gICAgICAgICQoJzxzcGFuLz4nKVxyXG4gICAgICAgICAgLmFwcGVuZFRvKGl0ZW0pXHJcbiAgICAgICAgICAub24oJ2NsaWNrJywgaXRlbSwgZGVsSWRMaXN0ZW5lcik7XHJcbiAgICAgIH1lbHNlIHtcclxuICAgICAgICBjdXJyZW50TGlzdC5zcGxpY2UoY3VycmVudExpc3QubGVuZ3RoLTEgLDEpO1xyXG4gICAgICB9XHJcbiAgICAgIFxyXG4gICAgICBtZS5hZGRDbGFzcygnY2hlY2tlZCcpO1xyXG4gICAgICB0b2dnbGVNc1NlbGVjdGlvbkJveCgpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIEVWRU5UU1xyXG4gICAgJGJ0bkdFVC5vbignY2xpY2snLCBmdW5jdGlvbiAoZSkge1xyXG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgIGlmICgkYnRuR0VULmF0dHIoJ2RhdGEtc2VsZWN0b3InKSAhPT0gJGljb25CdXR0b24uYXR0cignZGF0YS1zZWxlY3RvcicpKSByZXR1cm4gZmFsc2U7IC8vc3RvcCByZXF1ZXN0XHJcblxyXG4gICAgICBtb2RhbENvbnRlbnQucmVtb3ZlQ2xhc3MoJ25hcnJvdycpO1xyXG4gICAgICB2YXIgZm9ybSA9ICRmb3JtLmdldCgwKTtcclxuICAgICAgaWYgKCEkYnRuR0VULmlzKCc6ZGlzYWJsZWQnKSkge1xyXG4gICAgICAgIGlmIChmb3JtLmNoZWNrVmFsaWRpdHkoKSkge1xyXG4gICAgICAgICAgJGJ0bkdFVC5hdHRyKCdkaXNhYmxlZCcsIHRydWUpO1xyXG4gICAgICAgICAgc3RhdGVDb25mLnBhZ2VJbmNyZW1lbnQgPSAwO1xyXG4gICAgICAgICAgc3RhdGVDb25mLmxvYWRpbmdGbGFnID0gJ0tFRVBfTE9BRCc7XHJcbiAgICAgICAgICBsb2FkaW5nKCdvbicpOyAvL3Nob3cgbG9hZGluZy1zcGlubmVyXHJcbiAgICAgICAgICByZXNldEZvcm0oKTsgLy9jbGVhclxyXG4gICAgICAgICAgc3VibWl0Rm9ybShzdGF0ZUNvbmYucGFnZUluY3JlbWVudCwgIHRydWUpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAvLyBIaWdobGlnaHQgZXJyb3JzXHJcbiAgICAgICAgICBpZiAoZm9ybS5yZXBvcnRWYWxpZGl0eSkgZm9ybS5yZXBvcnRWYWxpZGl0eSgpO1xyXG4gICAgICAgICAgJGZvcm0uYWRkQ2xhc3MoY3NzVmFsaWRhdGlvbkNsYXNzKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgICRtc0J0blVzZS5vbignY2xpY2snLCBzZXRJZHNMaXN0ZW5lcik7XHJcblxyXG4gICAgLy9DbG9zZSBNYXAgYnV0dG9uXHJcbiAgICBidG5DbG9zZU1hcC5vbignY2xpY2snLCBjbG9zZU1hcExpc3RlbmVyKTtcclxuXHJcbiAgICAkKCcjanNfbHMtbW9yZV9idG4nLCAkbGlGb290ZXIpLm9uKCdjbGljaycsIGZ1bmN0aW9uIChlbG0pIHtcclxuICAgICAgaWYgKCRidG5HRVQuYXR0cignZGF0YS1zZWxlY3RvcicpICE9PSAkaWNvbkJ1dHRvbi5hdHRyKCdkYXRhLXNlbGVjdG9yJykpIHJldHVybiBmYWxzZTtcclxuICAgICAgLy8gZXZlbnRVcmwgPSAnaHR0cHM6Ly9hcHAudGlja2V0bWFzdGVyLmNvbS9kaXNjb3ZlcnkvdjIvJyArICRpY29uQnV0dG9uLmF0dHIoJ2RhdGEtc2VsZWN0b3InKSArICcuanNvbic7XHJcblxyXG4gICAgICBzdGF0ZUNvbmYucGFnZUluY3JlbWVudCsrO1xyXG4gICAgICAkYnRuR0VULmF0dHIoJ2Rpc2FibGVkJywgdHJ1ZSk7XHJcbiAgICAgIGxvYWRpbmcoJ29uJyk7XHJcbiAgICAgIHN1Ym1pdEZvcm0oc3RhdGVDb25mLnBhZ2VJbmNyZW1lbnQpO1xyXG5cclxuICAgICAgLy9DbGVhciBMaXN0ZW5lciwgcHJldmVudCBtZW1vcnkgbGVha1xyXG4gICAgICAkKCBcIiNqc19scy1tb2RhbFwiICkub2ZmKCBcImNsaWNrXCIsIFwidWwgbGkgYnV0dG9uLmpzX21zLWFkZC1saXN0X2J0blwiLCBhZGRNc0J1dHRvbkxpc3RlbmVyICk7XHJcbiAgICB9KTtcclxuXHJcbiAgICAvL211bHRpcGxlIHNlbGVjdG9yIGV2ZW50c1xyXG5cclxuICAgICRmb3JtLm9uKFwia2V5dXBcIiwgZnVuY3Rpb24gKGUpIHtcclxuICAgICAgdmFyIGlucHV0ID0gJChlLnRhcmdldCk7XHJcbiAgICAgIGlmIChlLnRhcmdldC50YWdOYW1lID09PSBcIklOUFVUXCIpe1xyXG4gICAgICAgIGlmIChlLmtleUNvZGUgPT0gMTMpe1xyXG4gICAgICAgICAgaW5wdXQuYmx1cigpO1xyXG5cclxuICAgICAgICAgIG1vZGFsQ29udGVudC5yZW1vdmVDbGFzcygnbmFycm93Jyk7XHJcbiAgICAgICAgICBpZiAoJGJ0bkdFVC5hdHRyKCdkYXRhLXNlbGVjdG9yJykgIT09ICRpY29uQnV0dG9uLmF0dHIoJ2RhdGEtc2VsZWN0b3InKSkgcmV0dXJuIGZhbHNlO1xyXG5cclxuICAgICAgICAgIGlmICgkZm9ybS5nZXQoMCkuY2hlY2tWYWxpZGl0eSgpKSB7XHJcbiAgICAgICAgICAgIHN0YXRlQ29uZi5wYWdlSW5jcmVtZW50ID0gMDtcclxuICAgICAgICAgICAgc3RhdGVDb25mLmxvYWRpbmdGbGFnID0gJ0tFRVBfTE9BRCc7XHJcbiAgICAgICAgICAgIGxvYWRpbmcoJ29uJyk7XHJcbiAgICAgICAgICAgIHJlc2V0Rm9ybSgpO1xyXG4gICAgICAgICAgICBzdWJtaXRGb3JtKHN0YXRlQ29uZi5wYWdlSW5jcmVtZW50KTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfSk7XHJcblxyXG4gICAgLy8gTW9iaWxlIGRldmljZXMuIEZvcmNlICdjaGFuZ2UnIGJ5ICdHbycgcHJlc3NcclxuICAgICRmb3JtLm9uKFwic3VibWl0XCIsIGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgIGUucHJldmVudERlZmF1bHQoKTtcclxuICAgIH0pO1xyXG5cclxuICAgICRtb2RhbFxyXG4gICAgICAub24oJ3Nob3duLmJzLm1vZGFsJywgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIC8vc2F2ZSBkZWZhdWx0IHZhbHVlIHRvIHZhcmlhYmxlIGZvciAnZXZlbnRzJyBzZWxlY3RvciBvbmx5XHJcbiAgICAgICAgaWYodHlwZW9mICRpbnB1dC52YWwoKSAhPT0gJ3VuZGVmaW5lZCcgJiYgJGljb25CdXR0b24uYXR0cignZGF0YS1zZWxlY3RvcicpID09PSAnZXZlbnRzJyApXHJcbiAgICAgICAgICBpbml0aWFsVmFsWydldmVudHMnXSA9ICRpbnB1dC52YWwoKTtcclxuICAgICAgfSlcclxuICAgICAgLm9uKCdoaWRkZW4uYnMubW9kYWwnLCBmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgIHZhciBpbmRUb1JlbW92ZSA9W10sXHJcbiAgICAgICAgICBzZWxlY3RvckJ0biA9ICRidG5HRVQuYXR0cignZGF0YS1zZWxlY3RvcicpLFxyXG4gICAgICAgICAgdGFnc0FyciA9IHRhZ3NJZHNbc2VsZWN0b3JCdG5dO1xyXG4gICAgICAgIHJlc2V0Rm9ybSgpO1xyXG4gICAgICAgIGNsb3NlTWFwTGlzdGVuZXIoKTtcdFx0XHJcblxyXG4gICAgICAgICQoICdsaScgLCAkbXNMaXN0ICkuZWFjaCggZnVuY3Rpb24oaSkge1xyXG4gICAgICAgICAgaWYgKCAkKHRoaXMpLmRhdGEoJ2lzYWJsZScpID09PSBmYWxzZSApe1xyXG4gICAgICAgICAgICBpbmRUb1JlbW92ZS5wdXNoKCAkKHRoaXMpLmRhdGEoJ3NlbGVjdG9yLScgKyBzZWxlY3RvckJ0bikgKTtcclxuICAgICAgICAgICAgJCh0aGlzKS5yZW1vdmUoKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgY2xlYXJCeUFyclZhbCh0YWdzQXJyLCBpbmRUb1JlbW92ZSk7XHJcblxyXG4gICAgICAgIC8vY2xlYXIgdGFncyBpZiBzZXQgU2luZ2xlIElEXHJcbiAgICAgICAgaWYoc2VsZWN0b3IgPT09IHNlbGVjdG9yQnRuICYmICFzdGF0ZUNvbmYuc2V0U2luZ2xlVmFsKSB7XHJcbiAgICAgICAgICBzdGF0ZUNvbmYuc2V0U2luZ2xlVmFsID0gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGtleXdvcmQudmFsKCcnKTsvL2NsZWFyIHNlYXJjaCBpbnB1dFxyXG4gICAgfSk7XHJcblxyXG4gICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XHJcbiAgICAgIGluaXQoJCh0aGlzKSk7XHJcblxyXG4gICAgICBmdW5jdGlvbiBpbml0KGlucHV0KSB7XHJcbiAgICAgICAgaW5wdXQud3JhcCgnPGRpdiBjbGFzcz1cImxhenktc2VsZWN0b3Itd3JhcHBlclwiPjwvZGl2PicpO1xyXG4gICAgICAgIGlucHV0LmFmdGVyKCRpY29uQnV0dG9uKTtcclxuICAgICAgICAkaWNvbkJ1dHRvbi5hdHRyKCdkYXRhLXNlbGVjdG9yJywgc2VsZWN0b3IpO1xyXG5cclxuICAgICAgICAkKCcjZ2V0LWV2ZW50LWJ5LUlkLScgKyBvcHRpb25zLnNlbGVjdG9yICsgJycpLm9uKCdjbGljaycsIGNoYW5nZU1vZGFsVGV4dExpc3RlbmVyKTtcclxuICAgICAgICB0YWdzSWRzW3NlbGVjdG9yXSA9IFtdO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgfTtcclxuXHJcbn0pKGpRdWVyeSk7XHJcblxyXG4vKipcclxuICogYWRkIGxhenkgc2VsZWN0b3IgdG8gd2lkZ2V0c1xyXG4gKi9cclxuJChkb2N1bWVudCkub24oJ3JlYWR5JywgZnVuY3Rpb24gKCkge1xyXG4gICQoJy5qc19sYXp5LXNlbGVjdG9yJykubGF6eVNlbGVjdG9yKHtzZWxlY3RvcjonJywgaGlkZU11bHRpU2VsZWN0b3I6dHJ1ZX0pO1xyXG4gICQoJy5qc19sYXp5LXNlbGVjdG9yLWF0dHJhY3Rpb25zJykubGF6eVNlbGVjdG9yKHtzZWxlY3RvcjogJ2F0dHJhY3Rpb25zJ30pO1xyXG4gICQoJy5qc19sYXp5LXNlbGVjdG9yLXZlbnVlcycpLmxhenlTZWxlY3Rvcih7c2VsZWN0b3I6J3ZlbnVlcyd9KTtcclxufSk7XHJcblxyXG5cclxuLyoqXHJcbiAqIGFkZCBsYXp5IHNlbGVjdG9yIHRvIGFwaS1leHBsb3JlciB2MSAobWFkZSBieSBWLk1lbnNodXRpbilcclxuICovXHJcbiQoZG9jdW1lbnQpLm9uKCBcImZpbmlzaEluaXRcIiwgZnVuY3Rpb24oIGV2ZW50LCBmbGFnICkge1xyXG4gICQoJyN2ZW51ZUlkJykubGF6eVNlbGVjdG9yKHtzZWxlY3RvcjondmVudWVzJ30pO1xyXG4gICQoJyNhdHRyYWN0aW9uSWQnKS5sYXp5U2VsZWN0b3Ioe3NlbGVjdG9yOidhdHRyYWN0aW9ucyd9KTtcclxufSk7XHJcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NjcmlwdHMvY29tcG9uZW50cy9sYXp5LXNlbGVjdG9yLmpzIiwiLyohXHJcbiAqIEJvb3RzdHJhcCB2My4zLjYgKGh0dHA6Ly9nZXRib290c3RyYXAuY29tKVxyXG4gKiBDb3B5cmlnaHQgMjAxMS0yMDE1IFR3aXR0ZXIsIEluYy5cclxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXHJcbiAqL1xyXG5pZihcInVuZGVmaW5lZFwiPT10eXBlb2YgalF1ZXJ5KXRocm93IG5ldyBFcnJvcihcIkJvb3RzdHJhcCdzIEphdmFTY3JpcHQgcmVxdWlyZXMgalF1ZXJ5XCIpOytmdW5jdGlvbihhKXtcInVzZSBzdHJpY3RcIjt2YXIgYj1hLmZuLmpxdWVyeS5zcGxpdChcIiBcIilbMF0uc3BsaXQoXCIuXCIpO2lmKGJbMF08MiYmYlsxXTw5fHwxPT1iWzBdJiY5PT1iWzFdJiZiWzJdPDF8fGJbMF0+Mil0aHJvdyBuZXcgRXJyb3IoXCJCb290c3RyYXAncyBKYXZhU2NyaXB0IHJlcXVpcmVzIGpRdWVyeSB2ZXJzaW9uIDEuOS4xIG9yIGhpZ2hlciwgYnV0IGxvd2VyIHRoYW4gdmVyc2lvbiAzXCIpfShqUXVlcnkpLCtmdW5jdGlvbihhKXtcInVzZSBzdHJpY3RcIjtmdW5jdGlvbiBiKCl7dmFyIGE9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImJvb3RzdHJhcFwiKSxiPXtXZWJraXRUcmFuc2l0aW9uOlwid2Via2l0VHJhbnNpdGlvbkVuZFwiLE1velRyYW5zaXRpb246XCJ0cmFuc2l0aW9uZW5kXCIsT1RyYW5zaXRpb246XCJvVHJhbnNpdGlvbkVuZCBvdHJhbnNpdGlvbmVuZFwiLHRyYW5zaXRpb246XCJ0cmFuc2l0aW9uZW5kXCJ9O2Zvcih2YXIgYyBpbiBiKWlmKHZvaWQgMCE9PWEuc3R5bGVbY10pcmV0dXJue2VuZDpiW2NdfTtyZXR1cm4hMX1hLmZuLmVtdWxhdGVUcmFuc2l0aW9uRW5kPWZ1bmN0aW9uKGIpe3ZhciBjPSExLGQ9dGhpczthKHRoaXMpLm9uZShcImJzVHJhbnNpdGlvbkVuZFwiLGZ1bmN0aW9uKCl7Yz0hMH0pO3ZhciBlPWZ1bmN0aW9uKCl7Y3x8YShkKS50cmlnZ2VyKGEuc3VwcG9ydC50cmFuc2l0aW9uLmVuZCl9O3JldHVybiBzZXRUaW1lb3V0KGUsYiksdGhpc30sYShmdW5jdGlvbigpe2Euc3VwcG9ydC50cmFuc2l0aW9uPWIoKSxhLnN1cHBvcnQudHJhbnNpdGlvbiYmKGEuZXZlbnQuc3BlY2lhbC5ic1RyYW5zaXRpb25FbmQ9e2JpbmRUeXBlOmEuc3VwcG9ydC50cmFuc2l0aW9uLmVuZCxkZWxlZ2F0ZVR5cGU6YS5zdXBwb3J0LnRyYW5zaXRpb24uZW5kLGhhbmRsZTpmdW5jdGlvbihiKXtyZXR1cm4gYShiLnRhcmdldCkuaXModGhpcyk/Yi5oYW5kbGVPYmouaGFuZGxlci5hcHBseSh0aGlzLGFyZ3VtZW50cyk6dm9pZCAwfX0pfSl9KGpRdWVyeSksK2Z1bmN0aW9uKGEpe1widXNlIHN0cmljdFwiO2Z1bmN0aW9uIGIoYil7cmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpe3ZhciBjPWEodGhpcyksZT1jLmRhdGEoXCJicy5hbGVydFwiKTtlfHxjLmRhdGEoXCJicy5hbGVydFwiLGU9bmV3IGQodGhpcykpLFwic3RyaW5nXCI9PXR5cGVvZiBiJiZlW2JdLmNhbGwoYyl9KX12YXIgYz0nW2RhdGEtZGlzbWlzcz1cImFsZXJ0XCJdJyxkPWZ1bmN0aW9uKGIpe2EoYikub24oXCJjbGlja1wiLGMsdGhpcy5jbG9zZSl9O2QuVkVSU0lPTj1cIjMuMy42XCIsZC5UUkFOU0lUSU9OX0RVUkFUSU9OPTE1MCxkLnByb3RvdHlwZS5jbG9zZT1mdW5jdGlvbihiKXtmdW5jdGlvbiBjKCl7Zy5kZXRhY2goKS50cmlnZ2VyKFwiY2xvc2VkLmJzLmFsZXJ0XCIpLnJlbW92ZSgpfXZhciBlPWEodGhpcyksZj1lLmF0dHIoXCJkYXRhLXRhcmdldFwiKTtmfHwoZj1lLmF0dHIoXCJocmVmXCIpLGY9ZiYmZi5yZXBsYWNlKC8uKig/PSNbXlxcc10qJCkvLFwiXCIpKTt2YXIgZz1hKGYpO2ImJmIucHJldmVudERlZmF1bHQoKSxnLmxlbmd0aHx8KGc9ZS5jbG9zZXN0KFwiLmFsZXJ0XCIpKSxnLnRyaWdnZXIoYj1hLkV2ZW50KFwiY2xvc2UuYnMuYWxlcnRcIikpLGIuaXNEZWZhdWx0UHJldmVudGVkKCl8fChnLnJlbW92ZUNsYXNzKFwiaW5cIiksYS5zdXBwb3J0LnRyYW5zaXRpb24mJmcuaGFzQ2xhc3MoXCJmYWRlXCIpP2cub25lKFwiYnNUcmFuc2l0aW9uRW5kXCIsYykuZW11bGF0ZVRyYW5zaXRpb25FbmQoZC5UUkFOU0lUSU9OX0RVUkFUSU9OKTpjKCkpfTt2YXIgZT1hLmZuLmFsZXJ0O2EuZm4uYWxlcnQ9YixhLmZuLmFsZXJ0LkNvbnN0cnVjdG9yPWQsYS5mbi5hbGVydC5ub0NvbmZsaWN0PWZ1bmN0aW9uKCl7cmV0dXJuIGEuZm4uYWxlcnQ9ZSx0aGlzfSxhKGRvY3VtZW50KS5vbihcImNsaWNrLmJzLmFsZXJ0LmRhdGEtYXBpXCIsYyxkLnByb3RvdHlwZS5jbG9zZSl9KGpRdWVyeSksK2Z1bmN0aW9uKGEpe1widXNlIHN0cmljdFwiO2Z1bmN0aW9uIGIoYil7cmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpe3ZhciBkPWEodGhpcyksZT1kLmRhdGEoXCJicy5idXR0b25cIiksZj1cIm9iamVjdFwiPT10eXBlb2YgYiYmYjtlfHxkLmRhdGEoXCJicy5idXR0b25cIixlPW5ldyBjKHRoaXMsZikpLFwidG9nZ2xlXCI9PWI/ZS50b2dnbGUoKTpiJiZlLnNldFN0YXRlKGIpfSl9dmFyIGM9ZnVuY3Rpb24oYixkKXt0aGlzLiRlbGVtZW50PWEoYiksdGhpcy5vcHRpb25zPWEuZXh0ZW5kKHt9LGMuREVGQVVMVFMsZCksdGhpcy5pc0xvYWRpbmc9ITF9O2MuVkVSU0lPTj1cIjMuMy42XCIsYy5ERUZBVUxUUz17bG9hZGluZ1RleHQ6XCJsb2FkaW5nLi4uXCJ9LGMucHJvdG90eXBlLnNldFN0YXRlPWZ1bmN0aW9uKGIpe3ZhciBjPVwiZGlzYWJsZWRcIixkPXRoaXMuJGVsZW1lbnQsZT1kLmlzKFwiaW5wdXRcIik/XCJ2YWxcIjpcImh0bWxcIixmPWQuZGF0YSgpO2IrPVwiVGV4dFwiLG51bGw9PWYucmVzZXRUZXh0JiZkLmRhdGEoXCJyZXNldFRleHRcIixkW2VdKCkpLHNldFRpbWVvdXQoYS5wcm94eShmdW5jdGlvbigpe2RbZV0obnVsbD09ZltiXT90aGlzLm9wdGlvbnNbYl06ZltiXSksXCJsb2FkaW5nVGV4dFwiPT1iPyh0aGlzLmlzTG9hZGluZz0hMCxkLmFkZENsYXNzKGMpLmF0dHIoYyxjKSk6dGhpcy5pc0xvYWRpbmcmJih0aGlzLmlzTG9hZGluZz0hMSxkLnJlbW92ZUNsYXNzKGMpLnJlbW92ZUF0dHIoYykpfSx0aGlzKSwwKX0sYy5wcm90b3R5cGUudG9nZ2xlPWZ1bmN0aW9uKCl7dmFyIGE9ITAsYj10aGlzLiRlbGVtZW50LmNsb3Nlc3QoJ1tkYXRhLXRvZ2dsZT1cImJ1dHRvbnNcIl0nKTtpZihiLmxlbmd0aCl7dmFyIGM9dGhpcy4kZWxlbWVudC5maW5kKFwiaW5wdXRcIik7XCJyYWRpb1wiPT1jLnByb3AoXCJ0eXBlXCIpPyhjLnByb3AoXCJjaGVja2VkXCIpJiYoYT0hMSksYi5maW5kKFwiLmFjdGl2ZVwiKS5yZW1vdmVDbGFzcyhcImFjdGl2ZVwiKSx0aGlzLiRlbGVtZW50LmFkZENsYXNzKFwiYWN0aXZlXCIpKTpcImNoZWNrYm94XCI9PWMucHJvcChcInR5cGVcIikmJihjLnByb3AoXCJjaGVja2VkXCIpIT09dGhpcy4kZWxlbWVudC5oYXNDbGFzcyhcImFjdGl2ZVwiKSYmKGE9ITEpLHRoaXMuJGVsZW1lbnQudG9nZ2xlQ2xhc3MoXCJhY3RpdmVcIikpLGMucHJvcChcImNoZWNrZWRcIix0aGlzLiRlbGVtZW50Lmhhc0NsYXNzKFwiYWN0aXZlXCIpKSxhJiZjLnRyaWdnZXIoXCJjaGFuZ2VcIil9ZWxzZSB0aGlzLiRlbGVtZW50LmF0dHIoXCJhcmlhLXByZXNzZWRcIiwhdGhpcy4kZWxlbWVudC5oYXNDbGFzcyhcImFjdGl2ZVwiKSksdGhpcy4kZWxlbWVudC50b2dnbGVDbGFzcyhcImFjdGl2ZVwiKX07dmFyIGQ9YS5mbi5idXR0b247YS5mbi5idXR0b249YixhLmZuLmJ1dHRvbi5Db25zdHJ1Y3Rvcj1jLGEuZm4uYnV0dG9uLm5vQ29uZmxpY3Q9ZnVuY3Rpb24oKXtyZXR1cm4gYS5mbi5idXR0b249ZCx0aGlzfSxhKGRvY3VtZW50KS5vbihcImNsaWNrLmJzLmJ1dHRvbi5kYXRhLWFwaVwiLCdbZGF0YS10b2dnbGVePVwiYnV0dG9uXCJdJyxmdW5jdGlvbihjKXt2YXIgZD1hKGMudGFyZ2V0KTtkLmhhc0NsYXNzKFwiYnRuXCIpfHwoZD1kLmNsb3Nlc3QoXCIuYnRuXCIpKSxiLmNhbGwoZCxcInRvZ2dsZVwiKSxhKGMudGFyZ2V0KS5pcygnaW5wdXRbdHlwZT1cInJhZGlvXCJdJyl8fGEoYy50YXJnZXQpLmlzKCdpbnB1dFt0eXBlPVwiY2hlY2tib3hcIl0nKXx8Yy5wcmV2ZW50RGVmYXVsdCgpfSkub24oXCJmb2N1cy5icy5idXR0b24uZGF0YS1hcGkgYmx1ci5icy5idXR0b24uZGF0YS1hcGlcIiwnW2RhdGEtdG9nZ2xlXj1cImJ1dHRvblwiXScsZnVuY3Rpb24oYil7YShiLnRhcmdldCkuY2xvc2VzdChcIi5idG5cIikudG9nZ2xlQ2xhc3MoXCJmb2N1c1wiLC9eZm9jdXMoaW4pPyQvLnRlc3QoYi50eXBlKSl9KX0oalF1ZXJ5KSwrZnVuY3Rpb24oYSl7XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gYihiKXtyZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCl7dmFyIGQ9YSh0aGlzKSxlPWQuZGF0YShcImJzLmNhcm91c2VsXCIpLGY9YS5leHRlbmQoe30sYy5ERUZBVUxUUyxkLmRhdGEoKSxcIm9iamVjdFwiPT10eXBlb2YgYiYmYiksZz1cInN0cmluZ1wiPT10eXBlb2YgYj9iOmYuc2xpZGU7ZXx8ZC5kYXRhKFwiYnMuY2Fyb3VzZWxcIixlPW5ldyBjKHRoaXMsZikpLFwibnVtYmVyXCI9PXR5cGVvZiBiP2UudG8oYik6Zz9lW2ddKCk6Zi5pbnRlcnZhbCYmZS5wYXVzZSgpLmN5Y2xlKCl9KX12YXIgYz1mdW5jdGlvbihiLGMpe3RoaXMuJGVsZW1lbnQ9YShiKSx0aGlzLiRpbmRpY2F0b3JzPXRoaXMuJGVsZW1lbnQuZmluZChcIi5jYXJvdXNlbC1pbmRpY2F0b3JzXCIpLHRoaXMub3B0aW9ucz1jLHRoaXMucGF1c2VkPW51bGwsdGhpcy5zbGlkaW5nPW51bGwsdGhpcy5pbnRlcnZhbD1udWxsLHRoaXMuJGFjdGl2ZT1udWxsLHRoaXMuJGl0ZW1zPW51bGwsdGhpcy5vcHRpb25zLmtleWJvYXJkJiZ0aGlzLiRlbGVtZW50Lm9uKFwia2V5ZG93bi5icy5jYXJvdXNlbFwiLGEucHJveHkodGhpcy5rZXlkb3duLHRoaXMpKSxcImhvdmVyXCI9PXRoaXMub3B0aW9ucy5wYXVzZSYmIShcIm9udG91Y2hzdGFydFwiaW4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50KSYmdGhpcy4kZWxlbWVudC5vbihcIm1vdXNlZW50ZXIuYnMuY2Fyb3VzZWxcIixhLnByb3h5KHRoaXMucGF1c2UsdGhpcykpLm9uKFwibW91c2VsZWF2ZS5icy5jYXJvdXNlbFwiLGEucHJveHkodGhpcy5jeWNsZSx0aGlzKSl9O2MuVkVSU0lPTj1cIjMuMy42XCIsYy5UUkFOU0lUSU9OX0RVUkFUSU9OPTYwMCxjLkRFRkFVTFRTPXtpbnRlcnZhbDo1ZTMscGF1c2U6XCJob3ZlclwiLHdyYXA6ITAsa2V5Ym9hcmQ6ITB9LGMucHJvdG90eXBlLmtleWRvd249ZnVuY3Rpb24oYSl7aWYoIS9pbnB1dHx0ZXh0YXJlYS9pLnRlc3QoYS50YXJnZXQudGFnTmFtZSkpe3N3aXRjaChhLndoaWNoKXtjYXNlIDM3OnRoaXMucHJldigpO2JyZWFrO2Nhc2UgMzk6dGhpcy5uZXh0KCk7YnJlYWs7ZGVmYXVsdDpyZXR1cm59YS5wcmV2ZW50RGVmYXVsdCgpfX0sYy5wcm90b3R5cGUuY3ljbGU9ZnVuY3Rpb24oYil7cmV0dXJuIGJ8fCh0aGlzLnBhdXNlZD0hMSksdGhpcy5pbnRlcnZhbCYmY2xlYXJJbnRlcnZhbCh0aGlzLmludGVydmFsKSx0aGlzLm9wdGlvbnMuaW50ZXJ2YWwmJiF0aGlzLnBhdXNlZCYmKHRoaXMuaW50ZXJ2YWw9c2V0SW50ZXJ2YWwoYS5wcm94eSh0aGlzLm5leHQsdGhpcyksdGhpcy5vcHRpb25zLmludGVydmFsKSksdGhpc30sYy5wcm90b3R5cGUuZ2V0SXRlbUluZGV4PWZ1bmN0aW9uKGEpe3JldHVybiB0aGlzLiRpdGVtcz1hLnBhcmVudCgpLmNoaWxkcmVuKFwiLml0ZW1cIiksdGhpcy4kaXRlbXMuaW5kZXgoYXx8dGhpcy4kYWN0aXZlKX0sYy5wcm90b3R5cGUuZ2V0SXRlbUZvckRpcmVjdGlvbj1mdW5jdGlvbihhLGIpe3ZhciBjPXRoaXMuZ2V0SXRlbUluZGV4KGIpLGQ9XCJwcmV2XCI9PWEmJjA9PT1jfHxcIm5leHRcIj09YSYmYz09dGhpcy4kaXRlbXMubGVuZ3RoLTE7aWYoZCYmIXRoaXMub3B0aW9ucy53cmFwKXJldHVybiBiO3ZhciBlPVwicHJldlwiPT1hPy0xOjEsZj0oYytlKSV0aGlzLiRpdGVtcy5sZW5ndGg7cmV0dXJuIHRoaXMuJGl0ZW1zLmVxKGYpfSxjLnByb3RvdHlwZS50bz1mdW5jdGlvbihhKXt2YXIgYj10aGlzLGM9dGhpcy5nZXRJdGVtSW5kZXgodGhpcy4kYWN0aXZlPXRoaXMuJGVsZW1lbnQuZmluZChcIi5pdGVtLmFjdGl2ZVwiKSk7cmV0dXJuIGE+dGhpcy4kaXRlbXMubGVuZ3RoLTF8fDA+YT92b2lkIDA6dGhpcy5zbGlkaW5nP3RoaXMuJGVsZW1lbnQub25lKFwic2xpZC5icy5jYXJvdXNlbFwiLGZ1bmN0aW9uKCl7Yi50byhhKX0pOmM9PWE/dGhpcy5wYXVzZSgpLmN5Y2xlKCk6dGhpcy5zbGlkZShhPmM/XCJuZXh0XCI6XCJwcmV2XCIsdGhpcy4kaXRlbXMuZXEoYSkpfSxjLnByb3RvdHlwZS5wYXVzZT1mdW5jdGlvbihiKXtyZXR1cm4gYnx8KHRoaXMucGF1c2VkPSEwKSx0aGlzLiRlbGVtZW50LmZpbmQoXCIubmV4dCwgLnByZXZcIikubGVuZ3RoJiZhLnN1cHBvcnQudHJhbnNpdGlvbiYmKHRoaXMuJGVsZW1lbnQudHJpZ2dlcihhLnN1cHBvcnQudHJhbnNpdGlvbi5lbmQpLHRoaXMuY3ljbGUoITApKSx0aGlzLmludGVydmFsPWNsZWFySW50ZXJ2YWwodGhpcy5pbnRlcnZhbCksdGhpc30sYy5wcm90b3R5cGUubmV4dD1mdW5jdGlvbigpe3JldHVybiB0aGlzLnNsaWRpbmc/dm9pZCAwOnRoaXMuc2xpZGUoXCJuZXh0XCIpfSxjLnByb3RvdHlwZS5wcmV2PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuc2xpZGluZz92b2lkIDA6dGhpcy5zbGlkZShcInByZXZcIil9LGMucHJvdG90eXBlLnNsaWRlPWZ1bmN0aW9uKGIsZCl7dmFyIGU9dGhpcy4kZWxlbWVudC5maW5kKFwiLml0ZW0uYWN0aXZlXCIpLGY9ZHx8dGhpcy5nZXRJdGVtRm9yRGlyZWN0aW9uKGIsZSksZz10aGlzLmludGVydmFsLGg9XCJuZXh0XCI9PWI/XCJsZWZ0XCI6XCJyaWdodFwiLGk9dGhpcztpZihmLmhhc0NsYXNzKFwiYWN0aXZlXCIpKXJldHVybiB0aGlzLnNsaWRpbmc9ITE7dmFyIGo9ZlswXSxrPWEuRXZlbnQoXCJzbGlkZS5icy5jYXJvdXNlbFwiLHtyZWxhdGVkVGFyZ2V0OmosZGlyZWN0aW9uOmh9KTtpZih0aGlzLiRlbGVtZW50LnRyaWdnZXIoayksIWsuaXNEZWZhdWx0UHJldmVudGVkKCkpe2lmKHRoaXMuc2xpZGluZz0hMCxnJiZ0aGlzLnBhdXNlKCksdGhpcy4kaW5kaWNhdG9ycy5sZW5ndGgpe3RoaXMuJGluZGljYXRvcnMuZmluZChcIi5hY3RpdmVcIikucmVtb3ZlQ2xhc3MoXCJhY3RpdmVcIik7dmFyIGw9YSh0aGlzLiRpbmRpY2F0b3JzLmNoaWxkcmVuKClbdGhpcy5nZXRJdGVtSW5kZXgoZildKTtsJiZsLmFkZENsYXNzKFwiYWN0aXZlXCIpfXZhciBtPWEuRXZlbnQoXCJzbGlkLmJzLmNhcm91c2VsXCIse3JlbGF0ZWRUYXJnZXQ6aixkaXJlY3Rpb246aH0pO3JldHVybiBhLnN1cHBvcnQudHJhbnNpdGlvbiYmdGhpcy4kZWxlbWVudC5oYXNDbGFzcyhcInNsaWRlXCIpPyhmLmFkZENsYXNzKGIpLGZbMF0ub2Zmc2V0V2lkdGgsZS5hZGRDbGFzcyhoKSxmLmFkZENsYXNzKGgpLGUub25lKFwiYnNUcmFuc2l0aW9uRW5kXCIsZnVuY3Rpb24oKXtmLnJlbW92ZUNsYXNzKFtiLGhdLmpvaW4oXCIgXCIpKS5hZGRDbGFzcyhcImFjdGl2ZVwiKSxlLnJlbW92ZUNsYXNzKFtcImFjdGl2ZVwiLGhdLmpvaW4oXCIgXCIpKSxpLnNsaWRpbmc9ITEsc2V0VGltZW91dChmdW5jdGlvbigpe2kuJGVsZW1lbnQudHJpZ2dlcihtKX0sMCl9KS5lbXVsYXRlVHJhbnNpdGlvbkVuZChjLlRSQU5TSVRJT05fRFVSQVRJT04pKTooZS5yZW1vdmVDbGFzcyhcImFjdGl2ZVwiKSxmLmFkZENsYXNzKFwiYWN0aXZlXCIpLHRoaXMuc2xpZGluZz0hMSx0aGlzLiRlbGVtZW50LnRyaWdnZXIobSkpLGcmJnRoaXMuY3ljbGUoKSx0aGlzfX07dmFyIGQ9YS5mbi5jYXJvdXNlbDthLmZuLmNhcm91c2VsPWIsYS5mbi5jYXJvdXNlbC5Db25zdHJ1Y3Rvcj1jLGEuZm4uY2Fyb3VzZWwubm9Db25mbGljdD1mdW5jdGlvbigpe3JldHVybiBhLmZuLmNhcm91c2VsPWQsdGhpc307dmFyIGU9ZnVuY3Rpb24oYyl7dmFyIGQsZT1hKHRoaXMpLGY9YShlLmF0dHIoXCJkYXRhLXRhcmdldFwiKXx8KGQ9ZS5hdHRyKFwiaHJlZlwiKSkmJmQucmVwbGFjZSgvLiooPz0jW15cXHNdKyQpLyxcIlwiKSk7aWYoZi5oYXNDbGFzcyhcImNhcm91c2VsXCIpKXt2YXIgZz1hLmV4dGVuZCh7fSxmLmRhdGEoKSxlLmRhdGEoKSksaD1lLmF0dHIoXCJkYXRhLXNsaWRlLXRvXCIpO2gmJihnLmludGVydmFsPSExKSxiLmNhbGwoZixnKSxoJiZmLmRhdGEoXCJicy5jYXJvdXNlbFwiKS50byhoKSxjLnByZXZlbnREZWZhdWx0KCl9fTthKGRvY3VtZW50KS5vbihcImNsaWNrLmJzLmNhcm91c2VsLmRhdGEtYXBpXCIsXCJbZGF0YS1zbGlkZV1cIixlKS5vbihcImNsaWNrLmJzLmNhcm91c2VsLmRhdGEtYXBpXCIsXCJbZGF0YS1zbGlkZS10b11cIixlKSxhKHdpbmRvdykub24oXCJsb2FkXCIsZnVuY3Rpb24oKXthKCdbZGF0YS1yaWRlPVwiY2Fyb3VzZWxcIl0nKS5lYWNoKGZ1bmN0aW9uKCl7dmFyIGM9YSh0aGlzKTtiLmNhbGwoYyxjLmRhdGEoKSl9KX0pfShqUXVlcnkpLCtmdW5jdGlvbihhKXtcInVzZSBzdHJpY3RcIjtmdW5jdGlvbiBiKGIpe3ZhciBjLGQ9Yi5hdHRyKFwiZGF0YS10YXJnZXRcIil8fChjPWIuYXR0cihcImhyZWZcIikpJiZjLnJlcGxhY2UoLy4qKD89I1teXFxzXSskKS8sXCJcIik7cmV0dXJuIGEoZCl9ZnVuY3Rpb24gYyhiKXtyZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCl7dmFyIGM9YSh0aGlzKSxlPWMuZGF0YShcImJzLmNvbGxhcHNlXCIpLGY9YS5leHRlbmQoe30sZC5ERUZBVUxUUyxjLmRhdGEoKSxcIm9iamVjdFwiPT10eXBlb2YgYiYmYik7IWUmJmYudG9nZ2xlJiYvc2hvd3xoaWRlLy50ZXN0KGIpJiYoZi50b2dnbGU9ITEpLGV8fGMuZGF0YShcImJzLmNvbGxhcHNlXCIsZT1uZXcgZCh0aGlzLGYpKSxcInN0cmluZ1wiPT10eXBlb2YgYiYmZVtiXSgpfSl9dmFyIGQ9ZnVuY3Rpb24oYixjKXt0aGlzLiRlbGVtZW50PWEoYiksdGhpcy5vcHRpb25zPWEuZXh0ZW5kKHt9LGQuREVGQVVMVFMsYyksdGhpcy4kdHJpZ2dlcj1hKCdbZGF0YS10b2dnbGU9XCJjb2xsYXBzZVwiXVtocmVmPVwiIycrYi5pZCsnXCJdLFtkYXRhLXRvZ2dsZT1cImNvbGxhcHNlXCJdW2RhdGEtdGFyZ2V0PVwiIycrYi5pZCsnXCJdJyksdGhpcy50cmFuc2l0aW9uaW5nPW51bGwsdGhpcy5vcHRpb25zLnBhcmVudD90aGlzLiRwYXJlbnQ9dGhpcy5nZXRQYXJlbnQoKTp0aGlzLmFkZEFyaWFBbmRDb2xsYXBzZWRDbGFzcyh0aGlzLiRlbGVtZW50LHRoaXMuJHRyaWdnZXIpLHRoaXMub3B0aW9ucy50b2dnbGUmJnRoaXMudG9nZ2xlKCl9O2QuVkVSU0lPTj1cIjMuMy42XCIsZC5UUkFOU0lUSU9OX0RVUkFUSU9OPTM1MCxkLkRFRkFVTFRTPXt0b2dnbGU6ITB9LGQucHJvdG90eXBlLmRpbWVuc2lvbj1mdW5jdGlvbigpe3ZhciBhPXRoaXMuJGVsZW1lbnQuaGFzQ2xhc3MoXCJ3aWR0aFwiKTtyZXR1cm4gYT9cIndpZHRoXCI6XCJoZWlnaHRcIn0sZC5wcm90b3R5cGUuc2hvdz1mdW5jdGlvbigpe2lmKCF0aGlzLnRyYW5zaXRpb25pbmcmJiF0aGlzLiRlbGVtZW50Lmhhc0NsYXNzKFwiaW5cIikpe3ZhciBiLGU9dGhpcy4kcGFyZW50JiZ0aGlzLiRwYXJlbnQuY2hpbGRyZW4oXCIucGFuZWxcIikuY2hpbGRyZW4oXCIuaW4sIC5jb2xsYXBzaW5nXCIpO2lmKCEoZSYmZS5sZW5ndGgmJihiPWUuZGF0YShcImJzLmNvbGxhcHNlXCIpLGImJmIudHJhbnNpdGlvbmluZykpKXt2YXIgZj1hLkV2ZW50KFwic2hvdy5icy5jb2xsYXBzZVwiKTtpZih0aGlzLiRlbGVtZW50LnRyaWdnZXIoZiksIWYuaXNEZWZhdWx0UHJldmVudGVkKCkpe2UmJmUubGVuZ3RoJiYoYy5jYWxsKGUsXCJoaWRlXCIpLGJ8fGUuZGF0YShcImJzLmNvbGxhcHNlXCIsbnVsbCkpO3ZhciBnPXRoaXMuZGltZW5zaW9uKCk7dGhpcy4kZWxlbWVudC5yZW1vdmVDbGFzcyhcImNvbGxhcHNlXCIpLmFkZENsYXNzKFwiY29sbGFwc2luZ1wiKVtnXSgwKS5hdHRyKFwiYXJpYS1leHBhbmRlZFwiLCEwKSx0aGlzLiR0cmlnZ2VyLnJlbW92ZUNsYXNzKFwiY29sbGFwc2VkXCIpLmF0dHIoXCJhcmlhLWV4cGFuZGVkXCIsITApLHRoaXMudHJhbnNpdGlvbmluZz0xO3ZhciBoPWZ1bmN0aW9uKCl7dGhpcy4kZWxlbWVudC5yZW1vdmVDbGFzcyhcImNvbGxhcHNpbmdcIikuYWRkQ2xhc3MoXCJjb2xsYXBzZSBpblwiKVtnXShcIlwiKSx0aGlzLnRyYW5zaXRpb25pbmc9MCx0aGlzLiRlbGVtZW50LnRyaWdnZXIoXCJzaG93bi5icy5jb2xsYXBzZVwiKX07aWYoIWEuc3VwcG9ydC50cmFuc2l0aW9uKXJldHVybiBoLmNhbGwodGhpcyk7dmFyIGk9YS5jYW1lbENhc2UoW1wic2Nyb2xsXCIsZ10uam9pbihcIi1cIikpO3RoaXMuJGVsZW1lbnQub25lKFwiYnNUcmFuc2l0aW9uRW5kXCIsYS5wcm94eShoLHRoaXMpKS5lbXVsYXRlVHJhbnNpdGlvbkVuZChkLlRSQU5TSVRJT05fRFVSQVRJT04pW2ddKHRoaXMuJGVsZW1lbnRbMF1baV0pfX19fSxkLnByb3RvdHlwZS5oaWRlPWZ1bmN0aW9uKCl7aWYoIXRoaXMudHJhbnNpdGlvbmluZyYmdGhpcy4kZWxlbWVudC5oYXNDbGFzcyhcImluXCIpKXt2YXIgYj1hLkV2ZW50KFwiaGlkZS5icy5jb2xsYXBzZVwiKTtpZih0aGlzLiRlbGVtZW50LnRyaWdnZXIoYiksIWIuaXNEZWZhdWx0UHJldmVudGVkKCkpe3ZhciBjPXRoaXMuZGltZW5zaW9uKCk7dGhpcy4kZWxlbWVudFtjXSh0aGlzLiRlbGVtZW50W2NdKCkpWzBdLm9mZnNldEhlaWdodCx0aGlzLiRlbGVtZW50LmFkZENsYXNzKFwiY29sbGFwc2luZ1wiKS5yZW1vdmVDbGFzcyhcImNvbGxhcHNlIGluXCIpLmF0dHIoXCJhcmlhLWV4cGFuZGVkXCIsITEpLHRoaXMuJHRyaWdnZXIuYWRkQ2xhc3MoXCJjb2xsYXBzZWRcIikuYXR0cihcImFyaWEtZXhwYW5kZWRcIiwhMSksdGhpcy50cmFuc2l0aW9uaW5nPTE7dmFyIGU9ZnVuY3Rpb24oKXt0aGlzLnRyYW5zaXRpb25pbmc9MCx0aGlzLiRlbGVtZW50LnJlbW92ZUNsYXNzKFwiY29sbGFwc2luZ1wiKS5hZGRDbGFzcyhcImNvbGxhcHNlXCIpLnRyaWdnZXIoXCJoaWRkZW4uYnMuY29sbGFwc2VcIil9O3JldHVybiBhLnN1cHBvcnQudHJhbnNpdGlvbj92b2lkIHRoaXMuJGVsZW1lbnRbY10oMCkub25lKFwiYnNUcmFuc2l0aW9uRW5kXCIsYS5wcm94eShlLHRoaXMpKS5lbXVsYXRlVHJhbnNpdGlvbkVuZChkLlRSQU5TSVRJT05fRFVSQVRJT04pOmUuY2FsbCh0aGlzKX19fSxkLnByb3RvdHlwZS50b2dnbGU9ZnVuY3Rpb24oKXt0aGlzW3RoaXMuJGVsZW1lbnQuaGFzQ2xhc3MoXCJpblwiKT9cImhpZGVcIjpcInNob3dcIl0oKX0sZC5wcm90b3R5cGUuZ2V0UGFyZW50PWZ1bmN0aW9uKCl7cmV0dXJuIGEodGhpcy5vcHRpb25zLnBhcmVudCkuZmluZCgnW2RhdGEtdG9nZ2xlPVwiY29sbGFwc2VcIl1bZGF0YS1wYXJlbnQ9XCInK3RoaXMub3B0aW9ucy5wYXJlbnQrJ1wiXScpLmVhY2goYS5wcm94eShmdW5jdGlvbihjLGQpe3ZhciBlPWEoZCk7dGhpcy5hZGRBcmlhQW5kQ29sbGFwc2VkQ2xhc3MoYihlKSxlKX0sdGhpcykpLmVuZCgpfSxkLnByb3RvdHlwZS5hZGRBcmlhQW5kQ29sbGFwc2VkQ2xhc3M9ZnVuY3Rpb24oYSxiKXt2YXIgYz1hLmhhc0NsYXNzKFwiaW5cIik7YS5hdHRyKFwiYXJpYS1leHBhbmRlZFwiLGMpLGIudG9nZ2xlQ2xhc3MoXCJjb2xsYXBzZWRcIiwhYykuYXR0cihcImFyaWEtZXhwYW5kZWRcIixjKX07dmFyIGU9YS5mbi5jb2xsYXBzZTthLmZuLmNvbGxhcHNlPWMsYS5mbi5jb2xsYXBzZS5Db25zdHJ1Y3Rvcj1kLGEuZm4uY29sbGFwc2Uubm9Db25mbGljdD1mdW5jdGlvbigpe3JldHVybiBhLmZuLmNvbGxhcHNlPWUsdGhpc30sYShkb2N1bWVudCkub24oXCJjbGljay5icy5jb2xsYXBzZS5kYXRhLWFwaVwiLCdbZGF0YS10b2dnbGU9XCJjb2xsYXBzZVwiXScsZnVuY3Rpb24oZCl7dmFyIGU9YSh0aGlzKTtlLmF0dHIoXCJkYXRhLXRhcmdldFwiKXx8ZC5wcmV2ZW50RGVmYXVsdCgpO3ZhciBmPWIoZSksZz1mLmRhdGEoXCJicy5jb2xsYXBzZVwiKSxoPWc/XCJ0b2dnbGVcIjplLmRhdGEoKTtjLmNhbGwoZixoKX0pfShqUXVlcnkpLCtmdW5jdGlvbihhKXtcInVzZSBzdHJpY3RcIjtmdW5jdGlvbiBiKGIpe3ZhciBjPWIuYXR0cihcImRhdGEtdGFyZ2V0XCIpO2N8fChjPWIuYXR0cihcImhyZWZcIiksYz1jJiYvI1tBLVphLXpdLy50ZXN0KGMpJiZjLnJlcGxhY2UoLy4qKD89I1teXFxzXSokKS8sXCJcIikpO3ZhciBkPWMmJmEoYyk7cmV0dXJuIGQmJmQubGVuZ3RoP2Q6Yi5wYXJlbnQoKX1mdW5jdGlvbiBjKGMpe2MmJjM9PT1jLndoaWNofHwoYShlKS5yZW1vdmUoKSxhKGYpLmVhY2goZnVuY3Rpb24oKXt2YXIgZD1hKHRoaXMpLGU9YihkKSxmPXtyZWxhdGVkVGFyZ2V0OnRoaXN9O2UuaGFzQ2xhc3MoXCJvcGVuXCIpJiYoYyYmXCJjbGlja1wiPT1jLnR5cGUmJi9pbnB1dHx0ZXh0YXJlYS9pLnRlc3QoYy50YXJnZXQudGFnTmFtZSkmJmEuY29udGFpbnMoZVswXSxjLnRhcmdldCl8fChlLnRyaWdnZXIoYz1hLkV2ZW50KFwiaGlkZS5icy5kcm9wZG93blwiLGYpKSxjLmlzRGVmYXVsdFByZXZlbnRlZCgpfHwoZC5hdHRyKFwiYXJpYS1leHBhbmRlZFwiLFwiZmFsc2VcIiksZS5yZW1vdmVDbGFzcyhcIm9wZW5cIikudHJpZ2dlcihhLkV2ZW50KFwiaGlkZGVuLmJzLmRyb3Bkb3duXCIsZikpKSkpfSkpfWZ1bmN0aW9uIGQoYil7cmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpe3ZhciBjPWEodGhpcyksZD1jLmRhdGEoXCJicy5kcm9wZG93blwiKTtkfHxjLmRhdGEoXCJicy5kcm9wZG93blwiLGQ9bmV3IGcodGhpcykpLFwic3RyaW5nXCI9PXR5cGVvZiBiJiZkW2JdLmNhbGwoYyl9KX12YXIgZT1cIi5kcm9wZG93bi1iYWNrZHJvcFwiLGY9J1tkYXRhLXRvZ2dsZT1cImRyb3Bkb3duXCJdJyxnPWZ1bmN0aW9uKGIpe2EoYikub24oXCJjbGljay5icy5kcm9wZG93blwiLHRoaXMudG9nZ2xlKX07Zy5WRVJTSU9OPVwiMy4zLjZcIixnLnByb3RvdHlwZS50b2dnbGU9ZnVuY3Rpb24oZCl7dmFyIGU9YSh0aGlzKTtpZighZS5pcyhcIi5kaXNhYmxlZCwgOmRpc2FibGVkXCIpKXt2YXIgZj1iKGUpLGc9Zi5oYXNDbGFzcyhcIm9wZW5cIik7aWYoYygpLCFnKXtcIm9udG91Y2hzdGFydFwiaW4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50JiYhZi5jbG9zZXN0KFwiLm5hdmJhci1uYXZcIikubGVuZ3RoJiZhKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIikpLmFkZENsYXNzKFwiZHJvcGRvd24tYmFja2Ryb3BcIikuaW5zZXJ0QWZ0ZXIoYSh0aGlzKSkub24oXCJjbGlja1wiLGMpO3ZhciBoPXtyZWxhdGVkVGFyZ2V0OnRoaXN9O2lmKGYudHJpZ2dlcihkPWEuRXZlbnQoXCJzaG93LmJzLmRyb3Bkb3duXCIsaCkpLGQuaXNEZWZhdWx0UHJldmVudGVkKCkpcmV0dXJuO2UudHJpZ2dlcihcImZvY3VzXCIpLmF0dHIoXCJhcmlhLWV4cGFuZGVkXCIsXCJ0cnVlXCIpLGYudG9nZ2xlQ2xhc3MoXCJvcGVuXCIpLnRyaWdnZXIoYS5FdmVudChcInNob3duLmJzLmRyb3Bkb3duXCIsaCkpfXJldHVybiExfX0sZy5wcm90b3R5cGUua2V5ZG93bj1mdW5jdGlvbihjKXtpZigvKDM4fDQwfDI3fDMyKS8udGVzdChjLndoaWNoKSYmIS9pbnB1dHx0ZXh0YXJlYS9pLnRlc3QoYy50YXJnZXQudGFnTmFtZSkpe3ZhciBkPWEodGhpcyk7aWYoYy5wcmV2ZW50RGVmYXVsdCgpLGMuc3RvcFByb3BhZ2F0aW9uKCksIWQuaXMoXCIuZGlzYWJsZWQsIDpkaXNhYmxlZFwiKSl7dmFyIGU9YihkKSxnPWUuaGFzQ2xhc3MoXCJvcGVuXCIpO2lmKCFnJiYyNyE9Yy53aGljaHx8ZyYmMjc9PWMud2hpY2gpcmV0dXJuIDI3PT1jLndoaWNoJiZlLmZpbmQoZikudHJpZ2dlcihcImZvY3VzXCIpLGQudHJpZ2dlcihcImNsaWNrXCIpO3ZhciBoPVwiIGxpOm5vdCguZGlzYWJsZWQpOnZpc2libGUgYVwiLGk9ZS5maW5kKFwiLmRyb3Bkb3duLW1lbnVcIitoKTtpZihpLmxlbmd0aCl7dmFyIGo9aS5pbmRleChjLnRhcmdldCk7Mzg9PWMud2hpY2gmJmo+MCYmai0tLDQwPT1jLndoaWNoJiZqPGkubGVuZ3RoLTEmJmorKyx+anx8KGo9MCksaS5lcShqKS50cmlnZ2VyKFwiZm9jdXNcIil9fX19O3ZhciBoPWEuZm4uZHJvcGRvd247YS5mbi5kcm9wZG93bj1kLGEuZm4uZHJvcGRvd24uQ29uc3RydWN0b3I9ZyxhLmZuLmRyb3Bkb3duLm5vQ29uZmxpY3Q9ZnVuY3Rpb24oKXtyZXR1cm4gYS5mbi5kcm9wZG93bj1oLHRoaXN9LGEoZG9jdW1lbnQpLm9uKFwiY2xpY2suYnMuZHJvcGRvd24uZGF0YS1hcGlcIixjKS5vbihcImNsaWNrLmJzLmRyb3Bkb3duLmRhdGEtYXBpXCIsXCIuZHJvcGRvd24gZm9ybVwiLGZ1bmN0aW9uKGEpe2Euc3RvcFByb3BhZ2F0aW9uKCl9KS5vbihcImNsaWNrLmJzLmRyb3Bkb3duLmRhdGEtYXBpXCIsZixnLnByb3RvdHlwZS50b2dnbGUpLm9uKFwia2V5ZG93bi5icy5kcm9wZG93bi5kYXRhLWFwaVwiLGYsZy5wcm90b3R5cGUua2V5ZG93bikub24oXCJrZXlkb3duLmJzLmRyb3Bkb3duLmRhdGEtYXBpXCIsXCIuZHJvcGRvd24tbWVudVwiLGcucHJvdG90eXBlLmtleWRvd24pfShqUXVlcnkpLCtmdW5jdGlvbihhKXtcInVzZSBzdHJpY3RcIjtmdW5jdGlvbiBiKGIsZCl7cmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpe3ZhciBlPWEodGhpcyksZj1lLmRhdGEoXCJicy5tb2RhbFwiKSxnPWEuZXh0ZW5kKHt9LGMuREVGQVVMVFMsZS5kYXRhKCksXCJvYmplY3RcIj09dHlwZW9mIGImJmIpO2Z8fGUuZGF0YShcImJzLm1vZGFsXCIsZj1uZXcgYyh0aGlzLGcpKSxcInN0cmluZ1wiPT10eXBlb2YgYj9mW2JdKGQpOmcuc2hvdyYmZi5zaG93KGQpfSl9dmFyIGM9ZnVuY3Rpb24oYixjKXt0aGlzLm9wdGlvbnM9Yyx0aGlzLiRib2R5PWEoZG9jdW1lbnQuYm9keSksdGhpcy4kZWxlbWVudD1hKGIpLHRoaXMuJGRpYWxvZz10aGlzLiRlbGVtZW50LmZpbmQoXCIubW9kYWwtZGlhbG9nXCIpLHRoaXMuJGJhY2tkcm9wPW51bGwsdGhpcy5pc1Nob3duPW51bGwsdGhpcy5vcmlnaW5hbEJvZHlQYWQ9bnVsbCx0aGlzLnNjcm9sbGJhcldpZHRoPTAsdGhpcy5pZ25vcmVCYWNrZHJvcENsaWNrPSExLHRoaXMub3B0aW9ucy5yZW1vdGUmJnRoaXMuJGVsZW1lbnQuZmluZChcIi5tb2RhbC1jb250ZW50XCIpLmxvYWQodGhpcy5vcHRpb25zLnJlbW90ZSxhLnByb3h5KGZ1bmN0aW9uKCl7dGhpcy4kZWxlbWVudC50cmlnZ2VyKFwibG9hZGVkLmJzLm1vZGFsXCIpfSx0aGlzKSl9O2MuVkVSU0lPTj1cIjMuMy42XCIsYy5UUkFOU0lUSU9OX0RVUkFUSU9OPTMwMCxjLkJBQ0tEUk9QX1RSQU5TSVRJT05fRFVSQVRJT049MTUwLGMuREVGQVVMVFM9e2JhY2tkcm9wOiEwLGtleWJvYXJkOiEwLHNob3c6ITB9LGMucHJvdG90eXBlLnRvZ2dsZT1mdW5jdGlvbihhKXtyZXR1cm4gdGhpcy5pc1Nob3duP3RoaXMuaGlkZSgpOnRoaXMuc2hvdyhhKX0sYy5wcm90b3R5cGUuc2hvdz1mdW5jdGlvbihiKXt2YXIgZD10aGlzLGU9YS5FdmVudChcInNob3cuYnMubW9kYWxcIix7cmVsYXRlZFRhcmdldDpifSk7dGhpcy4kZWxlbWVudC50cmlnZ2VyKGUpLHRoaXMuaXNTaG93bnx8ZS5pc0RlZmF1bHRQcmV2ZW50ZWQoKXx8KHRoaXMuaXNTaG93bj0hMCx0aGlzLmNoZWNrU2Nyb2xsYmFyKCksdGhpcy5zZXRTY3JvbGxiYXIoKSx0aGlzLiRib2R5LmFkZENsYXNzKFwibW9kYWwtb3BlblwiKSx0aGlzLmVzY2FwZSgpLHRoaXMucmVzaXplKCksdGhpcy4kZWxlbWVudC5vbihcImNsaWNrLmRpc21pc3MuYnMubW9kYWxcIiwnW2RhdGEtZGlzbWlzcz1cIm1vZGFsXCJdJyxhLnByb3h5KHRoaXMuaGlkZSx0aGlzKSksdGhpcy4kZGlhbG9nLm9uKFwibW91c2Vkb3duLmRpc21pc3MuYnMubW9kYWxcIixmdW5jdGlvbigpe2QuJGVsZW1lbnQub25lKFwibW91c2V1cC5kaXNtaXNzLmJzLm1vZGFsXCIsZnVuY3Rpb24oYil7YShiLnRhcmdldCkuaXMoZC4kZWxlbWVudCkmJihkLmlnbm9yZUJhY2tkcm9wQ2xpY2s9ITApfSl9KSx0aGlzLmJhY2tkcm9wKGZ1bmN0aW9uKCl7dmFyIGU9YS5zdXBwb3J0LnRyYW5zaXRpb24mJmQuJGVsZW1lbnQuaGFzQ2xhc3MoXCJmYWRlXCIpO2QuJGVsZW1lbnQucGFyZW50KCkubGVuZ3RofHxkLiRlbGVtZW50LmFwcGVuZFRvKGQuJGJvZHkpLGQuJGVsZW1lbnQuc2hvdygpLnNjcm9sbFRvcCgwKSxkLmFkanVzdERpYWxvZygpLGUmJmQuJGVsZW1lbnRbMF0ub2Zmc2V0V2lkdGgsZC4kZWxlbWVudC5hZGRDbGFzcyhcImluXCIpLGQuZW5mb3JjZUZvY3VzKCk7dmFyIGY9YS5FdmVudChcInNob3duLmJzLm1vZGFsXCIse3JlbGF0ZWRUYXJnZXQ6Yn0pO2U/ZC4kZGlhbG9nLm9uZShcImJzVHJhbnNpdGlvbkVuZFwiLGZ1bmN0aW9uKCl7ZC4kZWxlbWVudC50cmlnZ2VyKFwiZm9jdXNcIikudHJpZ2dlcihmKX0pLmVtdWxhdGVUcmFuc2l0aW9uRW5kKGMuVFJBTlNJVElPTl9EVVJBVElPTik6ZC4kZWxlbWVudC50cmlnZ2VyKFwiZm9jdXNcIikudHJpZ2dlcihmKX0pKX0sYy5wcm90b3R5cGUuaGlkZT1mdW5jdGlvbihiKXtiJiZiLnByZXZlbnREZWZhdWx0KCksYj1hLkV2ZW50KFwiaGlkZS5icy5tb2RhbFwiKSx0aGlzLiRlbGVtZW50LnRyaWdnZXIoYiksdGhpcy5pc1Nob3duJiYhYi5pc0RlZmF1bHRQcmV2ZW50ZWQoKSYmKHRoaXMuaXNTaG93bj0hMSx0aGlzLmVzY2FwZSgpLHRoaXMucmVzaXplKCksYShkb2N1bWVudCkub2ZmKFwiZm9jdXNpbi5icy5tb2RhbFwiKSx0aGlzLiRlbGVtZW50LnJlbW92ZUNsYXNzKFwiaW5cIikub2ZmKFwiY2xpY2suZGlzbWlzcy5icy5tb2RhbFwiKS5vZmYoXCJtb3VzZXVwLmRpc21pc3MuYnMubW9kYWxcIiksdGhpcy4kZGlhbG9nLm9mZihcIm1vdXNlZG93bi5kaXNtaXNzLmJzLm1vZGFsXCIpLGEuc3VwcG9ydC50cmFuc2l0aW9uJiZ0aGlzLiRlbGVtZW50Lmhhc0NsYXNzKFwiZmFkZVwiKT90aGlzLiRlbGVtZW50Lm9uZShcImJzVHJhbnNpdGlvbkVuZFwiLGEucHJveHkodGhpcy5oaWRlTW9kYWwsdGhpcykpLmVtdWxhdGVUcmFuc2l0aW9uRW5kKGMuVFJBTlNJVElPTl9EVVJBVElPTik6dGhpcy5oaWRlTW9kYWwoKSl9LGMucHJvdG90eXBlLmVuZm9yY2VGb2N1cz1mdW5jdGlvbigpe2EoZG9jdW1lbnQpLm9mZihcImZvY3VzaW4uYnMubW9kYWxcIikub24oXCJmb2N1c2luLmJzLm1vZGFsXCIsYS5wcm94eShmdW5jdGlvbihhKXt0aGlzLiRlbGVtZW50WzBdPT09YS50YXJnZXR8fHRoaXMuJGVsZW1lbnQuaGFzKGEudGFyZ2V0KS5sZW5ndGh8fHRoaXMuJGVsZW1lbnQudHJpZ2dlcihcImZvY3VzXCIpfSx0aGlzKSl9LGMucHJvdG90eXBlLmVzY2FwZT1mdW5jdGlvbigpe3RoaXMuaXNTaG93biYmdGhpcy5vcHRpb25zLmtleWJvYXJkP3RoaXMuJGVsZW1lbnQub24oXCJrZXlkb3duLmRpc21pc3MuYnMubW9kYWxcIixhLnByb3h5KGZ1bmN0aW9uKGEpezI3PT1hLndoaWNoJiZ0aGlzLmhpZGUoKX0sdGhpcykpOnRoaXMuaXNTaG93bnx8dGhpcy4kZWxlbWVudC5vZmYoXCJrZXlkb3duLmRpc21pc3MuYnMubW9kYWxcIil9LGMucHJvdG90eXBlLnJlc2l6ZT1mdW5jdGlvbigpe3RoaXMuaXNTaG93bj9hKHdpbmRvdykub24oXCJyZXNpemUuYnMubW9kYWxcIixhLnByb3h5KHRoaXMuaGFuZGxlVXBkYXRlLHRoaXMpKTphKHdpbmRvdykub2ZmKFwicmVzaXplLmJzLm1vZGFsXCIpfSxjLnByb3RvdHlwZS5oaWRlTW9kYWw9ZnVuY3Rpb24oKXt2YXIgYT10aGlzO3RoaXMuJGVsZW1lbnQuaGlkZSgpLHRoaXMuYmFja2Ryb3AoZnVuY3Rpb24oKXthLiRib2R5LnJlbW92ZUNsYXNzKFwibW9kYWwtb3BlblwiKSxhLnJlc2V0QWRqdXN0bWVudHMoKSxhLnJlc2V0U2Nyb2xsYmFyKCksYS4kZWxlbWVudC50cmlnZ2VyKFwiaGlkZGVuLmJzLm1vZGFsXCIpfSl9LGMucHJvdG90eXBlLnJlbW92ZUJhY2tkcm9wPWZ1bmN0aW9uKCl7dGhpcy4kYmFja2Ryb3AmJnRoaXMuJGJhY2tkcm9wLnJlbW92ZSgpLHRoaXMuJGJhY2tkcm9wPW51bGx9LGMucHJvdG90eXBlLmJhY2tkcm9wPWZ1bmN0aW9uKGIpe3ZhciBkPXRoaXMsZT10aGlzLiRlbGVtZW50Lmhhc0NsYXNzKFwiZmFkZVwiKT9cImZhZGVcIjpcIlwiO2lmKHRoaXMuaXNTaG93biYmdGhpcy5vcHRpb25zLmJhY2tkcm9wKXt2YXIgZj1hLnN1cHBvcnQudHJhbnNpdGlvbiYmZTtpZih0aGlzLiRiYWNrZHJvcD1hKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIikpLmFkZENsYXNzKFwibW9kYWwtYmFja2Ryb3AgXCIrZSkuYXBwZW5kVG8odGhpcy4kYm9keSksdGhpcy4kZWxlbWVudC5vbihcImNsaWNrLmRpc21pc3MuYnMubW9kYWxcIixhLnByb3h5KGZ1bmN0aW9uKGEpe3JldHVybiB0aGlzLmlnbm9yZUJhY2tkcm9wQ2xpY2s/dm9pZCh0aGlzLmlnbm9yZUJhY2tkcm9wQ2xpY2s9ITEpOnZvaWQoYS50YXJnZXQ9PT1hLmN1cnJlbnRUYXJnZXQmJihcInN0YXRpY1wiPT10aGlzLm9wdGlvbnMuYmFja2Ryb3A/dGhpcy4kZWxlbWVudFswXS5mb2N1cygpOnRoaXMuaGlkZSgpKSl9LHRoaXMpKSxmJiZ0aGlzLiRiYWNrZHJvcFswXS5vZmZzZXRXaWR0aCx0aGlzLiRiYWNrZHJvcC5hZGRDbGFzcyhcImluXCIpLCFiKXJldHVybjtmP3RoaXMuJGJhY2tkcm9wLm9uZShcImJzVHJhbnNpdGlvbkVuZFwiLGIpLmVtdWxhdGVUcmFuc2l0aW9uRW5kKGMuQkFDS0RST1BfVFJBTlNJVElPTl9EVVJBVElPTik6YigpfWVsc2UgaWYoIXRoaXMuaXNTaG93biYmdGhpcy4kYmFja2Ryb3Ape3RoaXMuJGJhY2tkcm9wLnJlbW92ZUNsYXNzKFwiaW5cIik7dmFyIGc9ZnVuY3Rpb24oKXtkLnJlbW92ZUJhY2tkcm9wKCksYiYmYigpfTthLnN1cHBvcnQudHJhbnNpdGlvbiYmdGhpcy4kZWxlbWVudC5oYXNDbGFzcyhcImZhZGVcIik/dGhpcy4kYmFja2Ryb3Aub25lKFwiYnNUcmFuc2l0aW9uRW5kXCIsZykuZW11bGF0ZVRyYW5zaXRpb25FbmQoYy5CQUNLRFJPUF9UUkFOU0lUSU9OX0RVUkFUSU9OKTpnKCl9ZWxzZSBiJiZiKCl9LGMucHJvdG90eXBlLmhhbmRsZVVwZGF0ZT1mdW5jdGlvbigpe3RoaXMuYWRqdXN0RGlhbG9nKCl9LGMucHJvdG90eXBlLmFkanVzdERpYWxvZz1mdW5jdGlvbigpe3ZhciBhPXRoaXMuJGVsZW1lbnRbMF0uc2Nyb2xsSGVpZ2h0PmRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRIZWlnaHQ7dGhpcy4kZWxlbWVudC5jc3Moe3BhZGRpbmdMZWZ0OiF0aGlzLmJvZHlJc092ZXJmbG93aW5nJiZhP3RoaXMuc2Nyb2xsYmFyV2lkdGg6XCJcIixwYWRkaW5nUmlnaHQ6dGhpcy5ib2R5SXNPdmVyZmxvd2luZyYmIWE/dGhpcy5zY3JvbGxiYXJXaWR0aDpcIlwifSl9LGMucHJvdG90eXBlLnJlc2V0QWRqdXN0bWVudHM9ZnVuY3Rpb24oKXt0aGlzLiRlbGVtZW50LmNzcyh7cGFkZGluZ0xlZnQ6XCJcIixwYWRkaW5nUmlnaHQ6XCJcIn0pfSxjLnByb3RvdHlwZS5jaGVja1Njcm9sbGJhcj1mdW5jdGlvbigpe3ZhciBhPXdpbmRvdy5pbm5lcldpZHRoO2lmKCFhKXt2YXIgYj1kb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7YT1iLnJpZ2h0LU1hdGguYWJzKGIubGVmdCl9dGhpcy5ib2R5SXNPdmVyZmxvd2luZz1kb2N1bWVudC5ib2R5LmNsaWVudFdpZHRoPGEsdGhpcy5zY3JvbGxiYXJXaWR0aD10aGlzLm1lYXN1cmVTY3JvbGxiYXIoKX0sYy5wcm90b3R5cGUuc2V0U2Nyb2xsYmFyPWZ1bmN0aW9uKCl7dmFyIGE9cGFyc2VJbnQodGhpcy4kYm9keS5jc3MoXCJwYWRkaW5nLXJpZ2h0XCIpfHwwLDEwKTt0aGlzLm9yaWdpbmFsQm9keVBhZD1kb2N1bWVudC5ib2R5LnN0eWxlLnBhZGRpbmdSaWdodHx8XCJcIix0aGlzLmJvZHlJc092ZXJmbG93aW5nJiZ0aGlzLiRib2R5LmNzcyhcInBhZGRpbmctcmlnaHRcIixhK3RoaXMuc2Nyb2xsYmFyV2lkdGgpfSxjLnByb3RvdHlwZS5yZXNldFNjcm9sbGJhcj1mdW5jdGlvbigpe3RoaXMuJGJvZHkuY3NzKFwicGFkZGluZy1yaWdodFwiLHRoaXMub3JpZ2luYWxCb2R5UGFkKX0sYy5wcm90b3R5cGUubWVhc3VyZVNjcm9sbGJhcj1mdW5jdGlvbigpe3ZhciBhPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7YS5jbGFzc05hbWU9XCJtb2RhbC1zY3JvbGxiYXItbWVhc3VyZVwiLHRoaXMuJGJvZHkuYXBwZW5kKGEpO3ZhciBiPWEub2Zmc2V0V2lkdGgtYS5jbGllbnRXaWR0aDtyZXR1cm4gdGhpcy4kYm9keVswXS5yZW1vdmVDaGlsZChhKSxifTt2YXIgZD1hLmZuLm1vZGFsO2EuZm4ubW9kYWw9YixhLmZuLm1vZGFsLkNvbnN0cnVjdG9yPWMsYS5mbi5tb2RhbC5ub0NvbmZsaWN0PWZ1bmN0aW9uKCl7cmV0dXJuIGEuZm4ubW9kYWw9ZCx0aGlzfSxhKGRvY3VtZW50KS5vbihcImNsaWNrLmJzLm1vZGFsLmRhdGEtYXBpXCIsJ1tkYXRhLXRvZ2dsZT1cIm1vZGFsXCJdJyxmdW5jdGlvbihjKXt2YXIgZD1hKHRoaXMpLGU9ZC5hdHRyKFwiaHJlZlwiKSxmPWEoZC5hdHRyKFwiZGF0YS10YXJnZXRcIil8fGUmJmUucmVwbGFjZSgvLiooPz0jW15cXHNdKyQpLyxcIlwiKSksZz1mLmRhdGEoXCJicy5tb2RhbFwiKT9cInRvZ2dsZVwiOmEuZXh0ZW5kKHtyZW1vdGU6IS8jLy50ZXN0KGUpJiZlfSxmLmRhdGEoKSxkLmRhdGEoKSk7ZC5pcyhcImFcIikmJmMucHJldmVudERlZmF1bHQoKSxmLm9uZShcInNob3cuYnMubW9kYWxcIixmdW5jdGlvbihhKXthLmlzRGVmYXVsdFByZXZlbnRlZCgpfHxmLm9uZShcImhpZGRlbi5icy5tb2RhbFwiLGZ1bmN0aW9uKCl7ZC5pcyhcIjp2aXNpYmxlXCIpJiZkLnRyaWdnZXIoXCJmb2N1c1wiKX0pfSksYi5jYWxsKGYsZyx0aGlzKX0pfShqUXVlcnkpLCtmdW5jdGlvbihhKXtcInVzZSBzdHJpY3RcIjtmdW5jdGlvbiBiKGIpe3JldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKXt2YXIgZD1hKHRoaXMpLGU9ZC5kYXRhKFwiYnMudG9vbHRpcFwiKSxmPVwib2JqZWN0XCI9PXR5cGVvZiBiJiZiOyhlfHwhL2Rlc3Ryb3l8aGlkZS8udGVzdChiKSkmJihlfHxkLmRhdGEoXCJicy50b29sdGlwXCIsZT1uZXcgYyh0aGlzLGYpKSxcInN0cmluZ1wiPT10eXBlb2YgYiYmZVtiXSgpKX0pfXZhciBjPWZ1bmN0aW9uKGEsYil7dGhpcy50eXBlPW51bGwsdGhpcy5vcHRpb25zPW51bGwsdGhpcy5lbmFibGVkPW51bGwsdGhpcy50aW1lb3V0PW51bGwsdGhpcy5ob3ZlclN0YXRlPW51bGwsdGhpcy4kZWxlbWVudD1udWxsLHRoaXMuaW5TdGF0ZT1udWxsLHRoaXMuaW5pdChcInRvb2x0aXBcIixhLGIpfTtjLlZFUlNJT049XCIzLjMuNlwiLGMuVFJBTlNJVElPTl9EVVJBVElPTj0xNTAsYy5ERUZBVUxUUz17YW5pbWF0aW9uOiEwLHBsYWNlbWVudDpcInRvcFwiLHNlbGVjdG9yOiExLHRlbXBsYXRlOic8ZGl2IGNsYXNzPVwidG9vbHRpcFwiIHJvbGU9XCJ0b29sdGlwXCI+PGRpdiBjbGFzcz1cInRvb2x0aXAtYXJyb3dcIj48L2Rpdj48ZGl2IGNsYXNzPVwidG9vbHRpcC1pbm5lclwiPjwvZGl2PjwvZGl2PicsdHJpZ2dlcjpcImhvdmVyIGZvY3VzXCIsdGl0bGU6XCJcIixkZWxheTowLGh0bWw6ITEsY29udGFpbmVyOiExLHZpZXdwb3J0OntzZWxlY3RvcjpcImJvZHlcIixwYWRkaW5nOjB9fSxjLnByb3RvdHlwZS5pbml0PWZ1bmN0aW9uKGIsYyxkKXtpZih0aGlzLmVuYWJsZWQ9ITAsdGhpcy50eXBlPWIsdGhpcy4kZWxlbWVudD1hKGMpLHRoaXMub3B0aW9ucz10aGlzLmdldE9wdGlvbnMoZCksdGhpcy4kdmlld3BvcnQ9dGhpcy5vcHRpb25zLnZpZXdwb3J0JiZhKGEuaXNGdW5jdGlvbih0aGlzLm9wdGlvbnMudmlld3BvcnQpP3RoaXMub3B0aW9ucy52aWV3cG9ydC5jYWxsKHRoaXMsdGhpcy4kZWxlbWVudCk6dGhpcy5vcHRpb25zLnZpZXdwb3J0LnNlbGVjdG9yfHx0aGlzLm9wdGlvbnMudmlld3BvcnQpLHRoaXMuaW5TdGF0ZT17Y2xpY2s6ITEsaG92ZXI6ITEsZm9jdXM6ITF9LHRoaXMuJGVsZW1lbnRbMF1pbnN0YW5jZW9mIGRvY3VtZW50LmNvbnN0cnVjdG9yJiYhdGhpcy5vcHRpb25zLnNlbGVjdG9yKXRocm93IG5ldyBFcnJvcihcImBzZWxlY3RvcmAgb3B0aW9uIG11c3QgYmUgc3BlY2lmaWVkIHdoZW4gaW5pdGlhbGl6aW5nIFwiK3RoaXMudHlwZStcIiBvbiB0aGUgd2luZG93LmRvY3VtZW50IG9iamVjdCFcIik7Zm9yKHZhciBlPXRoaXMub3B0aW9ucy50cmlnZ2VyLnNwbGl0KFwiIFwiKSxmPWUubGVuZ3RoO2YtLTspe3ZhciBnPWVbZl07aWYoXCJjbGlja1wiPT1nKXRoaXMuJGVsZW1lbnQub24oXCJjbGljay5cIit0aGlzLnR5cGUsdGhpcy5vcHRpb25zLnNlbGVjdG9yLGEucHJveHkodGhpcy50b2dnbGUsdGhpcykpO2Vsc2UgaWYoXCJtYW51YWxcIiE9Zyl7dmFyIGg9XCJob3ZlclwiPT1nP1wibW91c2VlbnRlclwiOlwiZm9jdXNpblwiLGk9XCJob3ZlclwiPT1nP1wibW91c2VsZWF2ZVwiOlwiZm9jdXNvdXRcIjt0aGlzLiRlbGVtZW50Lm9uKGgrXCIuXCIrdGhpcy50eXBlLHRoaXMub3B0aW9ucy5zZWxlY3RvcixhLnByb3h5KHRoaXMuZW50ZXIsdGhpcykpLHRoaXMuJGVsZW1lbnQub24oaStcIi5cIit0aGlzLnR5cGUsdGhpcy5vcHRpb25zLnNlbGVjdG9yLGEucHJveHkodGhpcy5sZWF2ZSx0aGlzKSl9fXRoaXMub3B0aW9ucy5zZWxlY3Rvcj90aGlzLl9vcHRpb25zPWEuZXh0ZW5kKHt9LHRoaXMub3B0aW9ucyx7dHJpZ2dlcjpcIm1hbnVhbFwiLHNlbGVjdG9yOlwiXCJ9KTp0aGlzLmZpeFRpdGxlKCl9LGMucHJvdG90eXBlLmdldERlZmF1bHRzPWZ1bmN0aW9uKCl7cmV0dXJuIGMuREVGQVVMVFN9LGMucHJvdG90eXBlLmdldE9wdGlvbnM9ZnVuY3Rpb24oYil7cmV0dXJuIGI9YS5leHRlbmQoe30sdGhpcy5nZXREZWZhdWx0cygpLHRoaXMuJGVsZW1lbnQuZGF0YSgpLGIpLGIuZGVsYXkmJlwibnVtYmVyXCI9PXR5cGVvZiBiLmRlbGF5JiYoYi5kZWxheT17c2hvdzpiLmRlbGF5LGhpZGU6Yi5kZWxheX0pLGJ9LGMucHJvdG90eXBlLmdldERlbGVnYXRlT3B0aW9ucz1mdW5jdGlvbigpe3ZhciBiPXt9LGM9dGhpcy5nZXREZWZhdWx0cygpO3JldHVybiB0aGlzLl9vcHRpb25zJiZhLmVhY2godGhpcy5fb3B0aW9ucyxmdW5jdGlvbihhLGQpe2NbYV0hPWQmJihiW2FdPWQpfSksYn0sYy5wcm90b3R5cGUuZW50ZXI9ZnVuY3Rpb24oYil7dmFyIGM9YiBpbnN0YW5jZW9mIHRoaXMuY29uc3RydWN0b3I/YjphKGIuY3VycmVudFRhcmdldCkuZGF0YShcImJzLlwiK3RoaXMudHlwZSk7cmV0dXJuIGN8fChjPW5ldyB0aGlzLmNvbnN0cnVjdG9yKGIuY3VycmVudFRhcmdldCx0aGlzLmdldERlbGVnYXRlT3B0aW9ucygpKSxhKGIuY3VycmVudFRhcmdldCkuZGF0YShcImJzLlwiK3RoaXMudHlwZSxjKSksYiBpbnN0YW5jZW9mIGEuRXZlbnQmJihjLmluU3RhdGVbXCJmb2N1c2luXCI9PWIudHlwZT9cImZvY3VzXCI6XCJob3ZlclwiXT0hMCksYy50aXAoKS5oYXNDbGFzcyhcImluXCIpfHxcImluXCI9PWMuaG92ZXJTdGF0ZT92b2lkKGMuaG92ZXJTdGF0ZT1cImluXCIpOihjbGVhclRpbWVvdXQoYy50aW1lb3V0KSxjLmhvdmVyU3RhdGU9XCJpblwiLGMub3B0aW9ucy5kZWxheSYmYy5vcHRpb25zLmRlbGF5LnNob3c/dm9pZChjLnRpbWVvdXQ9c2V0VGltZW91dChmdW5jdGlvbigpe1wiaW5cIj09Yy5ob3ZlclN0YXRlJiZjLnNob3coKX0sYy5vcHRpb25zLmRlbGF5LnNob3cpKTpjLnNob3coKSl9LGMucHJvdG90eXBlLmlzSW5TdGF0ZVRydWU9ZnVuY3Rpb24oKXtmb3IodmFyIGEgaW4gdGhpcy5pblN0YXRlKWlmKHRoaXMuaW5TdGF0ZVthXSlyZXR1cm4hMDtyZXR1cm4hMX0sYy5wcm90b3R5cGUubGVhdmU9ZnVuY3Rpb24oYil7dmFyIGM9YiBpbnN0YW5jZW9mIHRoaXMuY29uc3RydWN0b3I/YjphKGIuY3VycmVudFRhcmdldCkuZGF0YShcImJzLlwiK3RoaXMudHlwZSk7cmV0dXJuIGN8fChjPW5ldyB0aGlzLmNvbnN0cnVjdG9yKGIuY3VycmVudFRhcmdldCx0aGlzLmdldERlbGVnYXRlT3B0aW9ucygpKSxhKGIuY3VycmVudFRhcmdldCkuZGF0YShcImJzLlwiK3RoaXMudHlwZSxjKSksYiBpbnN0YW5jZW9mIGEuRXZlbnQmJihjLmluU3RhdGVbXCJmb2N1c291dFwiPT1iLnR5cGU/XCJmb2N1c1wiOlwiaG92ZXJcIl09ITEpLGMuaXNJblN0YXRlVHJ1ZSgpP3ZvaWQgMDooY2xlYXJUaW1lb3V0KGMudGltZW91dCksYy5ob3ZlclN0YXRlPVwib3V0XCIsYy5vcHRpb25zLmRlbGF5JiZjLm9wdGlvbnMuZGVsYXkuaGlkZT92b2lkKGMudGltZW91dD1zZXRUaW1lb3V0KGZ1bmN0aW9uKCl7XCJvdXRcIj09Yy5ob3ZlclN0YXRlJiZjLmhpZGUoKX0sYy5vcHRpb25zLmRlbGF5LmhpZGUpKTpjLmhpZGUoKSl9LGMucHJvdG90eXBlLnNob3c9ZnVuY3Rpb24oKXt2YXIgYj1hLkV2ZW50KFwic2hvdy5icy5cIit0aGlzLnR5cGUpO2lmKHRoaXMuaGFzQ29udGVudCgpJiZ0aGlzLmVuYWJsZWQpe3RoaXMuJGVsZW1lbnQudHJpZ2dlcihiKTt2YXIgZD1hLmNvbnRhaW5zKHRoaXMuJGVsZW1lbnRbMF0ub3duZXJEb2N1bWVudC5kb2N1bWVudEVsZW1lbnQsdGhpcy4kZWxlbWVudFswXSk7aWYoYi5pc0RlZmF1bHRQcmV2ZW50ZWQoKXx8IWQpcmV0dXJuO3ZhciBlPXRoaXMsZj10aGlzLnRpcCgpLGc9dGhpcy5nZXRVSUQodGhpcy50eXBlKTt0aGlzLnNldENvbnRlbnQoKSxmLmF0dHIoXCJpZFwiLGcpLHRoaXMuJGVsZW1lbnQuYXR0cihcImFyaWEtZGVzY3JpYmVkYnlcIixnKSx0aGlzLm9wdGlvbnMuYW5pbWF0aW9uJiZmLmFkZENsYXNzKFwiZmFkZVwiKTt2YXIgaD1cImZ1bmN0aW9uXCI9PXR5cGVvZiB0aGlzLm9wdGlvbnMucGxhY2VtZW50P3RoaXMub3B0aW9ucy5wbGFjZW1lbnQuY2FsbCh0aGlzLGZbMF0sdGhpcy4kZWxlbWVudFswXSk6dGhpcy5vcHRpb25zLnBsYWNlbWVudCxpPS9cXHM/YXV0bz9cXHM/L2ksaj1pLnRlc3QoaCk7aiYmKGg9aC5yZXBsYWNlKGksXCJcIil8fFwidG9wXCIpLGYuZGV0YWNoKCkuY3NzKHt0b3A6MCxsZWZ0OjAsZGlzcGxheTpcImJsb2NrXCJ9KS5hZGRDbGFzcyhoKS5kYXRhKFwiYnMuXCIrdGhpcy50eXBlLHRoaXMpLHRoaXMub3B0aW9ucy5jb250YWluZXI/Zi5hcHBlbmRUbyh0aGlzLm9wdGlvbnMuY29udGFpbmVyKTpmLmluc2VydEFmdGVyKHRoaXMuJGVsZW1lbnQpLHRoaXMuJGVsZW1lbnQudHJpZ2dlcihcImluc2VydGVkLmJzLlwiK3RoaXMudHlwZSk7dmFyIGs9dGhpcy5nZXRQb3NpdGlvbigpLGw9ZlswXS5vZmZzZXRXaWR0aCxtPWZbMF0ub2Zmc2V0SGVpZ2h0O2lmKGope3ZhciBuPWgsbz10aGlzLmdldFBvc2l0aW9uKHRoaXMuJHZpZXdwb3J0KTtoPVwiYm90dG9tXCI9PWgmJmsuYm90dG9tK20+by5ib3R0b20/XCJ0b3BcIjpcInRvcFwiPT1oJiZrLnRvcC1tPG8udG9wP1wiYm90dG9tXCI6XCJyaWdodFwiPT1oJiZrLnJpZ2h0K2w+by53aWR0aD9cImxlZnRcIjpcImxlZnRcIj09aCYmay5sZWZ0LWw8by5sZWZ0P1wicmlnaHRcIjpoLGYucmVtb3ZlQ2xhc3MobikuYWRkQ2xhc3MoaCl9dmFyIHA9dGhpcy5nZXRDYWxjdWxhdGVkT2Zmc2V0KGgsayxsLG0pO3RoaXMuYXBwbHlQbGFjZW1lbnQocCxoKTt2YXIgcT1mdW5jdGlvbigpe3ZhciBhPWUuaG92ZXJTdGF0ZTtlLiRlbGVtZW50LnRyaWdnZXIoXCJzaG93bi5icy5cIitlLnR5cGUpLGUuaG92ZXJTdGF0ZT1udWxsLFwib3V0XCI9PWEmJmUubGVhdmUoZSl9O2Euc3VwcG9ydC50cmFuc2l0aW9uJiZ0aGlzLiR0aXAuaGFzQ2xhc3MoXCJmYWRlXCIpP2Yub25lKFwiYnNUcmFuc2l0aW9uRW5kXCIscSkuZW11bGF0ZVRyYW5zaXRpb25FbmQoYy5UUkFOU0lUSU9OX0RVUkFUSU9OKTpxKCl9fSxjLnByb3RvdHlwZS5hcHBseVBsYWNlbWVudD1mdW5jdGlvbihiLGMpe3ZhciBkPXRoaXMudGlwKCksZT1kWzBdLm9mZnNldFdpZHRoLGY9ZFswXS5vZmZzZXRIZWlnaHQsZz1wYXJzZUludChkLmNzcyhcIm1hcmdpbi10b3BcIiksMTApLGg9cGFyc2VJbnQoZC5jc3MoXCJtYXJnaW4tbGVmdFwiKSwxMCk7aXNOYU4oZykmJihnPTApLGlzTmFOKGgpJiYoaD0wKSxiLnRvcCs9ZyxiLmxlZnQrPWgsYS5vZmZzZXQuc2V0T2Zmc2V0KGRbMF0sYS5leHRlbmQoe3VzaW5nOmZ1bmN0aW9uKGEpe2QuY3NzKHt0b3A6TWF0aC5yb3VuZChhLnRvcCksbGVmdDpNYXRoLnJvdW5kKGEubGVmdCl9KX19LGIpLDApLGQuYWRkQ2xhc3MoXCJpblwiKTt2YXIgaT1kWzBdLm9mZnNldFdpZHRoLGo9ZFswXS5vZmZzZXRIZWlnaHQ7XCJ0b3BcIj09YyYmaiE9ZiYmKGIudG9wPWIudG9wK2Ytaik7dmFyIGs9dGhpcy5nZXRWaWV3cG9ydEFkanVzdGVkRGVsdGEoYyxiLGksaik7ay5sZWZ0P2IubGVmdCs9ay5sZWZ0OmIudG9wKz1rLnRvcDt2YXIgbD0vdG9wfGJvdHRvbS8udGVzdChjKSxtPWw/MiprLmxlZnQtZStpOjIqay50b3AtZitqLG49bD9cIm9mZnNldFdpZHRoXCI6XCJvZmZzZXRIZWlnaHRcIjtkLm9mZnNldChiKSx0aGlzLnJlcGxhY2VBcnJvdyhtLGRbMF1bbl0sbCl9LGMucHJvdG90eXBlLnJlcGxhY2VBcnJvdz1mdW5jdGlvbihhLGIsYyl7dGhpcy5hcnJvdygpLmNzcyhjP1wibGVmdFwiOlwidG9wXCIsNTAqKDEtYS9iKStcIiVcIikuY3NzKGM/XCJ0b3BcIjpcImxlZnRcIixcIlwiKX0sYy5wcm90b3R5cGUuc2V0Q29udGVudD1mdW5jdGlvbigpe3ZhciBhPXRoaXMudGlwKCksYj10aGlzLmdldFRpdGxlKCk7YS5maW5kKFwiLnRvb2x0aXAtaW5uZXJcIilbdGhpcy5vcHRpb25zLmh0bWw/XCJodG1sXCI6XCJ0ZXh0XCJdKGIpLGEucmVtb3ZlQ2xhc3MoXCJmYWRlIGluIHRvcCBib3R0b20gbGVmdCByaWdodFwiKX0sYy5wcm90b3R5cGUuaGlkZT1mdW5jdGlvbihiKXtmdW5jdGlvbiBkKCl7XCJpblwiIT1lLmhvdmVyU3RhdGUmJmYuZGV0YWNoKCksZS4kZWxlbWVudC5yZW1vdmVBdHRyKFwiYXJpYS1kZXNjcmliZWRieVwiKS50cmlnZ2VyKFwiaGlkZGVuLmJzLlwiK2UudHlwZSksYiYmYigpfXZhciBlPXRoaXMsZj1hKHRoaXMuJHRpcCksZz1hLkV2ZW50KFwiaGlkZS5icy5cIit0aGlzLnR5cGUpO3JldHVybiB0aGlzLiRlbGVtZW50LnRyaWdnZXIoZyksZy5pc0RlZmF1bHRQcmV2ZW50ZWQoKT92b2lkIDA6KGYucmVtb3ZlQ2xhc3MoXCJpblwiKSxhLnN1cHBvcnQudHJhbnNpdGlvbiYmZi5oYXNDbGFzcyhcImZhZGVcIik/Zi5vbmUoXCJic1RyYW5zaXRpb25FbmRcIixkKS5lbXVsYXRlVHJhbnNpdGlvbkVuZChjLlRSQU5TSVRJT05fRFVSQVRJT04pOmQoKSx0aGlzLmhvdmVyU3RhdGU9bnVsbCx0aGlzKX0sYy5wcm90b3R5cGUuZml4VGl0bGU9ZnVuY3Rpb24oKXt2YXIgYT10aGlzLiRlbGVtZW50OyhhLmF0dHIoXCJ0aXRsZVwiKXx8XCJzdHJpbmdcIiE9dHlwZW9mIGEuYXR0cihcImRhdGEtb3JpZ2luYWwtdGl0bGVcIikpJiZhLmF0dHIoXCJkYXRhLW9yaWdpbmFsLXRpdGxlXCIsYS5hdHRyKFwidGl0bGVcIil8fFwiXCIpLmF0dHIoXCJ0aXRsZVwiLFwiXCIpfSxjLnByb3RvdHlwZS5oYXNDb250ZW50PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZ2V0VGl0bGUoKX0sYy5wcm90b3R5cGUuZ2V0UG9zaXRpb249ZnVuY3Rpb24oYil7Yj1ifHx0aGlzLiRlbGVtZW50O3ZhciBjPWJbMF0sZD1cIkJPRFlcIj09Yy50YWdOYW1lLGU9Yy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtudWxsPT1lLndpZHRoJiYoZT1hLmV4dGVuZCh7fSxlLHt3aWR0aDplLnJpZ2h0LWUubGVmdCxoZWlnaHQ6ZS5ib3R0b20tZS50b3B9KSk7dmFyIGY9ZD97dG9wOjAsbGVmdDowfTpiLm9mZnNldCgpLGc9e3Njcm9sbDpkP2RvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxUb3B8fGRvY3VtZW50LmJvZHkuc2Nyb2xsVG9wOmIuc2Nyb2xsVG9wKCl9LGg9ZD97d2lkdGg6YSh3aW5kb3cpLndpZHRoKCksaGVpZ2h0OmEod2luZG93KS5oZWlnaHQoKX06bnVsbDtyZXR1cm4gYS5leHRlbmQoe30sZSxnLGgsZil9LGMucHJvdG90eXBlLmdldENhbGN1bGF0ZWRPZmZzZXQ9ZnVuY3Rpb24oYSxiLGMsZCl7cmV0dXJuXCJib3R0b21cIj09YT97dG9wOmIudG9wK2IuaGVpZ2h0LGxlZnQ6Yi5sZWZ0K2Iud2lkdGgvMi1jLzJ9OlwidG9wXCI9PWE/e3RvcDpiLnRvcC1kLGxlZnQ6Yi5sZWZ0K2Iud2lkdGgvMi1jLzJ9OlwibGVmdFwiPT1hP3t0b3A6Yi50b3ArYi5oZWlnaHQvMi1kLzIsbGVmdDpiLmxlZnQtY306e3RvcDpiLnRvcCtiLmhlaWdodC8yLWQvMixsZWZ0OmIubGVmdCtiLndpZHRofX0sYy5wcm90b3R5cGUuZ2V0Vmlld3BvcnRBZGp1c3RlZERlbHRhPWZ1bmN0aW9uKGEsYixjLGQpe3ZhciBlPXt0b3A6MCxsZWZ0OjB9O2lmKCF0aGlzLiR2aWV3cG9ydClyZXR1cm4gZTt2YXIgZj10aGlzLm9wdGlvbnMudmlld3BvcnQmJnRoaXMub3B0aW9ucy52aWV3cG9ydC5wYWRkaW5nfHwwLGc9dGhpcy5nZXRQb3NpdGlvbih0aGlzLiR2aWV3cG9ydCk7aWYoL3JpZ2h0fGxlZnQvLnRlc3QoYSkpe3ZhciBoPWIudG9wLWYtZy5zY3JvbGwsaT1iLnRvcCtmLWcuc2Nyb2xsK2Q7aDxnLnRvcD9lLnRvcD1nLnRvcC1oOmk+Zy50b3ArZy5oZWlnaHQmJihlLnRvcD1nLnRvcCtnLmhlaWdodC1pKX1lbHNle3ZhciBqPWIubGVmdC1mLGs9Yi5sZWZ0K2YrYztqPGcubGVmdD9lLmxlZnQ9Zy5sZWZ0LWo6az5nLnJpZ2h0JiYoZS5sZWZ0PWcubGVmdCtnLndpZHRoLWspfXJldHVybiBlfSxjLnByb3RvdHlwZS5nZXRUaXRsZT1mdW5jdGlvbigpe3ZhciBhLGI9dGhpcy4kZWxlbWVudCxjPXRoaXMub3B0aW9ucztyZXR1cm4gYT1iLmF0dHIoXCJkYXRhLW9yaWdpbmFsLXRpdGxlXCIpfHwoXCJmdW5jdGlvblwiPT10eXBlb2YgYy50aXRsZT9jLnRpdGxlLmNhbGwoYlswXSk6Yy50aXRsZSl9LGMucHJvdG90eXBlLmdldFVJRD1mdW5jdGlvbihhKXtkbyBhKz1+figxZTYqTWF0aC5yYW5kb20oKSk7d2hpbGUoZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoYSkpO3JldHVybiBhfSxjLnByb3RvdHlwZS50aXA9ZnVuY3Rpb24oKXtpZighdGhpcy4kdGlwJiYodGhpcy4kdGlwPWEodGhpcy5vcHRpb25zLnRlbXBsYXRlKSwxIT10aGlzLiR0aXAubGVuZ3RoKSl0aHJvdyBuZXcgRXJyb3IodGhpcy50eXBlK1wiIGB0ZW1wbGF0ZWAgb3B0aW9uIG11c3QgY29uc2lzdCBvZiBleGFjdGx5IDEgdG9wLWxldmVsIGVsZW1lbnQhXCIpO3JldHVybiB0aGlzLiR0aXB9LGMucHJvdG90eXBlLmFycm93PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuJGFycm93PXRoaXMuJGFycm93fHx0aGlzLnRpcCgpLmZpbmQoXCIudG9vbHRpcC1hcnJvd1wiKX0sYy5wcm90b3R5cGUuZW5hYmxlPWZ1bmN0aW9uKCl7dGhpcy5lbmFibGVkPSEwfSxjLnByb3RvdHlwZS5kaXNhYmxlPWZ1bmN0aW9uKCl7dGhpcy5lbmFibGVkPSExfSxjLnByb3RvdHlwZS50b2dnbGVFbmFibGVkPWZ1bmN0aW9uKCl7dGhpcy5lbmFibGVkPSF0aGlzLmVuYWJsZWR9LGMucHJvdG90eXBlLnRvZ2dsZT1mdW5jdGlvbihiKXt2YXIgYz10aGlzO2ImJihjPWEoYi5jdXJyZW50VGFyZ2V0KS5kYXRhKFwiYnMuXCIrdGhpcy50eXBlKSxjfHwoYz1uZXcgdGhpcy5jb25zdHJ1Y3RvcihiLmN1cnJlbnRUYXJnZXQsdGhpcy5nZXREZWxlZ2F0ZU9wdGlvbnMoKSksYShiLmN1cnJlbnRUYXJnZXQpLmRhdGEoXCJicy5cIit0aGlzLnR5cGUsYykpKSxiPyhjLmluU3RhdGUuY2xpY2s9IWMuaW5TdGF0ZS5jbGljayxjLmlzSW5TdGF0ZVRydWUoKT9jLmVudGVyKGMpOmMubGVhdmUoYykpOmMudGlwKCkuaGFzQ2xhc3MoXCJpblwiKT9jLmxlYXZlKGMpOmMuZW50ZXIoYyl9LGMucHJvdG90eXBlLmRlc3Ryb3k9ZnVuY3Rpb24oKXt2YXIgYT10aGlzO2NsZWFyVGltZW91dCh0aGlzLnRpbWVvdXQpLHRoaXMuaGlkZShmdW5jdGlvbigpe2EuJGVsZW1lbnQub2ZmKFwiLlwiK2EudHlwZSkucmVtb3ZlRGF0YShcImJzLlwiK2EudHlwZSksYS4kdGlwJiZhLiR0aXAuZGV0YWNoKCksYS4kdGlwPW51bGwsYS4kYXJyb3c9bnVsbCxhLiR2aWV3cG9ydD1udWxsfSl9O3ZhciBkPWEuZm4udG9vbHRpcDthLmZuLnRvb2x0aXA9YixhLmZuLnRvb2x0aXAuQ29uc3RydWN0b3I9YyxhLmZuLnRvb2x0aXAubm9Db25mbGljdD1mdW5jdGlvbigpe3JldHVybiBhLmZuLnRvb2x0aXA9ZCx0aGlzfX0oalF1ZXJ5KSwrZnVuY3Rpb24oYSl7XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gYihiKXtyZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCl7dmFyIGQ9YSh0aGlzKSxlPWQuZGF0YShcImJzLnBvcG92ZXJcIiksZj1cIm9iamVjdFwiPT10eXBlb2YgYiYmYjsoZXx8IS9kZXN0cm95fGhpZGUvLnRlc3QoYikpJiYoZXx8ZC5kYXRhKFwiYnMucG9wb3ZlclwiLGU9bmV3IGModGhpcyxmKSksXCJzdHJpbmdcIj09dHlwZW9mIGImJmVbYl0oKSl9KX12YXIgYz1mdW5jdGlvbihhLGIpe3RoaXMuaW5pdChcInBvcG92ZXJcIixhLGIpfTtpZighYS5mbi50b29sdGlwKXRocm93IG5ldyBFcnJvcihcIlBvcG92ZXIgcmVxdWlyZXMgdG9vbHRpcC5qc1wiKTtjLlZFUlNJT049XCIzLjMuNlwiLGMuREVGQVVMVFM9YS5leHRlbmQoe30sYS5mbi50b29sdGlwLkNvbnN0cnVjdG9yLkRFRkFVTFRTLHtwbGFjZW1lbnQ6XCJyaWdodFwiLHRyaWdnZXI6XCJjbGlja1wiLGNvbnRlbnQ6XCJcIix0ZW1wbGF0ZTonPGRpdiBjbGFzcz1cInBvcG92ZXJcIiByb2xlPVwidG9vbHRpcFwiPjxkaXYgY2xhc3M9XCJhcnJvd1wiPjwvZGl2PjxoMyBjbGFzcz1cInBvcG92ZXItdGl0bGVcIj48L2gzPjxkaXYgY2xhc3M9XCJwb3BvdmVyLWNvbnRlbnRcIj48L2Rpdj48L2Rpdj4nfSksYy5wcm90b3R5cGU9YS5leHRlbmQoe30sYS5mbi50b29sdGlwLkNvbnN0cnVjdG9yLnByb3RvdHlwZSksYy5wcm90b3R5cGUuY29uc3RydWN0b3I9YyxjLnByb3RvdHlwZS5nZXREZWZhdWx0cz1mdW5jdGlvbigpe3JldHVybiBjLkRFRkFVTFRTfSxjLnByb3RvdHlwZS5zZXRDb250ZW50PWZ1bmN0aW9uKCl7dmFyIGE9dGhpcy50aXAoKSxiPXRoaXMuZ2V0VGl0bGUoKSxjPXRoaXMuZ2V0Q29udGVudCgpO2EuZmluZChcIi5wb3BvdmVyLXRpdGxlXCIpW3RoaXMub3B0aW9ucy5odG1sP1wiaHRtbFwiOlwidGV4dFwiXShiKSxhLmZpbmQoXCIucG9wb3Zlci1jb250ZW50XCIpLmNoaWxkcmVuKCkuZGV0YWNoKCkuZW5kKClbdGhpcy5vcHRpb25zLmh0bWw/XCJzdHJpbmdcIj09dHlwZW9mIGM/XCJodG1sXCI6XCJhcHBlbmRcIjpcInRleHRcIl0oYyksYS5yZW1vdmVDbGFzcyhcImZhZGUgdG9wIGJvdHRvbSBsZWZ0IHJpZ2h0IGluXCIpLGEuZmluZChcIi5wb3BvdmVyLXRpdGxlXCIpLmh0bWwoKXx8YS5maW5kKFwiLnBvcG92ZXItdGl0bGVcIikuaGlkZSgpfSxjLnByb3RvdHlwZS5oYXNDb250ZW50PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZ2V0VGl0bGUoKXx8dGhpcy5nZXRDb250ZW50KCl9LGMucHJvdG90eXBlLmdldENvbnRlbnQ9ZnVuY3Rpb24oKXt2YXIgYT10aGlzLiRlbGVtZW50LGI9dGhpcy5vcHRpb25zO3JldHVybiBhLmF0dHIoXCJkYXRhLWNvbnRlbnRcIil8fChcImZ1bmN0aW9uXCI9PXR5cGVvZiBiLmNvbnRlbnQ/Yi5jb250ZW50LmNhbGwoYVswXSk6Yi5jb250ZW50KX0sYy5wcm90b3R5cGUuYXJyb3c9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy4kYXJyb3c9dGhpcy4kYXJyb3d8fHRoaXMudGlwKCkuZmluZChcIi5hcnJvd1wiKX07dmFyIGQ9YS5mbi5wb3BvdmVyO2EuZm4ucG9wb3Zlcj1iLGEuZm4ucG9wb3Zlci5Db25zdHJ1Y3Rvcj1jLGEuZm4ucG9wb3Zlci5ub0NvbmZsaWN0PWZ1bmN0aW9uKCl7cmV0dXJuIGEuZm4ucG9wb3Zlcj1kLHRoaXN9fShqUXVlcnkpLCtmdW5jdGlvbihhKXtcInVzZSBzdHJpY3RcIjtmdW5jdGlvbiBiKGMsZCl7dGhpcy4kYm9keT1hKGRvY3VtZW50LmJvZHkpLHRoaXMuJHNjcm9sbEVsZW1lbnQ9YShhKGMpLmlzKGRvY3VtZW50LmJvZHkpP3dpbmRvdzpjKSx0aGlzLm9wdGlvbnM9YS5leHRlbmQoe30sYi5ERUZBVUxUUyxkKSx0aGlzLnNlbGVjdG9yPSh0aGlzLm9wdGlvbnMudGFyZ2V0fHxcIlwiKStcIiAubmF2IGxpID4gYVwiLHRoaXMub2Zmc2V0cz1bXSx0aGlzLnRhcmdldHM9W10sdGhpcy5hY3RpdmVUYXJnZXQ9bnVsbCx0aGlzLnNjcm9sbEhlaWdodD0wLHRoaXMuJHNjcm9sbEVsZW1lbnQub24oXCJzY3JvbGwuYnMuc2Nyb2xsc3B5XCIsYS5wcm94eSh0aGlzLnByb2Nlc3MsdGhpcykpLHRoaXMucmVmcmVzaCgpLHRoaXMucHJvY2VzcygpfWZ1bmN0aW9uIGMoYyl7cmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpe3ZhciBkPWEodGhpcyksZT1kLmRhdGEoXCJicy5zY3JvbGxzcHlcIiksZj1cIm9iamVjdFwiPT10eXBlb2YgYyYmYztlfHxkLmRhdGEoXCJicy5zY3JvbGxzcHlcIixlPW5ldyBiKHRoaXMsZikpLFwic3RyaW5nXCI9PXR5cGVvZiBjJiZlW2NdKCl9KX1iLlZFUlNJT049XCIzLjMuNlwiLGIuREVGQVVMVFM9e29mZnNldDoxMH0sYi5wcm90b3R5cGUuZ2V0U2Nyb2xsSGVpZ2h0PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuJHNjcm9sbEVsZW1lbnRbMF0uc2Nyb2xsSGVpZ2h0fHxNYXRoLm1heCh0aGlzLiRib2R5WzBdLnNjcm9sbEhlaWdodCxkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsSGVpZ2h0KX0sYi5wcm90b3R5cGUucmVmcmVzaD1mdW5jdGlvbigpe3ZhciBiPXRoaXMsYz1cIm9mZnNldFwiLGQ9MDt0aGlzLm9mZnNldHM9W10sdGhpcy50YXJnZXRzPVtdLHRoaXMuc2Nyb2xsSGVpZ2h0PXRoaXMuZ2V0U2Nyb2xsSGVpZ2h0KCksYS5pc1dpbmRvdyh0aGlzLiRzY3JvbGxFbGVtZW50WzBdKXx8KGM9XCJwb3NpdGlvblwiLGQ9dGhpcy4kc2Nyb2xsRWxlbWVudC5zY3JvbGxUb3AoKSksdGhpcy4kYm9keS5maW5kKHRoaXMuc2VsZWN0b3IpLm1hcChmdW5jdGlvbigpe3ZhciBiPWEodGhpcyksZT1iLmRhdGEoXCJ0YXJnZXRcIil8fGIuYXR0cihcImhyZWZcIiksZj0vXiMuLy50ZXN0KGUpJiZhKGUpO3JldHVybiBmJiZmLmxlbmd0aCYmZi5pcyhcIjp2aXNpYmxlXCIpJiZbW2ZbY10oKS50b3ArZCxlXV18fG51bGx9KS5zb3J0KGZ1bmN0aW9uKGEsYil7cmV0dXJuIGFbMF0tYlswXX0pLmVhY2goZnVuY3Rpb24oKXtiLm9mZnNldHMucHVzaCh0aGlzWzBdKSxiLnRhcmdldHMucHVzaCh0aGlzWzFdKX0pfSxiLnByb3RvdHlwZS5wcm9jZXNzPWZ1bmN0aW9uKCl7dmFyIGEsYj10aGlzLiRzY3JvbGxFbGVtZW50LnNjcm9sbFRvcCgpK3RoaXMub3B0aW9ucy5vZmZzZXQsYz10aGlzLmdldFNjcm9sbEhlaWdodCgpLGQ9dGhpcy5vcHRpb25zLm9mZnNldCtjLXRoaXMuJHNjcm9sbEVsZW1lbnQuaGVpZ2h0KCksZT10aGlzLm9mZnNldHMsZj10aGlzLnRhcmdldHMsZz10aGlzLmFjdGl2ZVRhcmdldDtpZih0aGlzLnNjcm9sbEhlaWdodCE9YyYmdGhpcy5yZWZyZXNoKCksYj49ZClyZXR1cm4gZyE9KGE9ZltmLmxlbmd0aC0xXSkmJnRoaXMuYWN0aXZhdGUoYSk7aWYoZyYmYjxlWzBdKXJldHVybiB0aGlzLmFjdGl2ZVRhcmdldD1udWxsLHRoaXMuY2xlYXIoKTtmb3IoYT1lLmxlbmd0aDthLS07KWchPWZbYV0mJmI+PWVbYV0mJih2b2lkIDA9PT1lW2ErMV18fGI8ZVthKzFdKSYmdGhpcy5hY3RpdmF0ZShmW2FdKX0sYi5wcm90b3R5cGUuYWN0aXZhdGU9ZnVuY3Rpb24oYil7dGhpcy5hY3RpdmVUYXJnZXQ9Yix0aGlzLmNsZWFyKCk7dmFyIGM9dGhpcy5zZWxlY3RvcisnW2RhdGEtdGFyZ2V0PVwiJytiKydcIl0sJyt0aGlzLnNlbGVjdG9yKydbaHJlZj1cIicrYisnXCJdJyxkPWEoYykucGFyZW50cyhcImxpXCIpLmFkZENsYXNzKFwiYWN0aXZlXCIpO1xyXG5kLnBhcmVudChcIi5kcm9wZG93bi1tZW51XCIpLmxlbmd0aCYmKGQ9ZC5jbG9zZXN0KFwibGkuZHJvcGRvd25cIikuYWRkQ2xhc3MoXCJhY3RpdmVcIikpLGQudHJpZ2dlcihcImFjdGl2YXRlLmJzLnNjcm9sbHNweVwiKX0sYi5wcm90b3R5cGUuY2xlYXI9ZnVuY3Rpb24oKXthKHRoaXMuc2VsZWN0b3IpLnBhcmVudHNVbnRpbCh0aGlzLm9wdGlvbnMudGFyZ2V0LFwiLmFjdGl2ZVwiKS5yZW1vdmVDbGFzcyhcImFjdGl2ZVwiKX07dmFyIGQ9YS5mbi5zY3JvbGxzcHk7YS5mbi5zY3JvbGxzcHk9YyxhLmZuLnNjcm9sbHNweS5Db25zdHJ1Y3Rvcj1iLGEuZm4uc2Nyb2xsc3B5Lm5vQ29uZmxpY3Q9ZnVuY3Rpb24oKXtyZXR1cm4gYS5mbi5zY3JvbGxzcHk9ZCx0aGlzfSxhKHdpbmRvdykub24oXCJsb2FkLmJzLnNjcm9sbHNweS5kYXRhLWFwaVwiLGZ1bmN0aW9uKCl7YSgnW2RhdGEtc3B5PVwic2Nyb2xsXCJdJykuZWFjaChmdW5jdGlvbigpe3ZhciBiPWEodGhpcyk7Yy5jYWxsKGIsYi5kYXRhKCkpfSl9KX0oalF1ZXJ5KSwrZnVuY3Rpb24oYSl7XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gYihiKXtyZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCl7dmFyIGQ9YSh0aGlzKSxlPWQuZGF0YShcImJzLnRhYlwiKTtlfHxkLmRhdGEoXCJicy50YWJcIixlPW5ldyBjKHRoaXMpKSxcInN0cmluZ1wiPT10eXBlb2YgYiYmZVtiXSgpfSl9dmFyIGM9ZnVuY3Rpb24oYil7dGhpcy5lbGVtZW50PWEoYil9O2MuVkVSU0lPTj1cIjMuMy42XCIsYy5UUkFOU0lUSU9OX0RVUkFUSU9OPTE1MCxjLnByb3RvdHlwZS5zaG93PWZ1bmN0aW9uKCl7dmFyIGI9dGhpcy5lbGVtZW50LGM9Yi5jbG9zZXN0KFwidWw6bm90KC5kcm9wZG93bi1tZW51KVwiKSxkPWIuZGF0YShcInRhcmdldFwiKTtpZihkfHwoZD1iLmF0dHIoXCJocmVmXCIpLGQ9ZCYmZC5yZXBsYWNlKC8uKig/PSNbXlxcc10qJCkvLFwiXCIpKSwhYi5wYXJlbnQoXCJsaVwiKS5oYXNDbGFzcyhcImFjdGl2ZVwiKSl7dmFyIGU9Yy5maW5kKFwiLmFjdGl2ZTpsYXN0IGFcIiksZj1hLkV2ZW50KFwiaGlkZS5icy50YWJcIix7cmVsYXRlZFRhcmdldDpiWzBdfSksZz1hLkV2ZW50KFwic2hvdy5icy50YWJcIix7cmVsYXRlZFRhcmdldDplWzBdfSk7aWYoZS50cmlnZ2VyKGYpLGIudHJpZ2dlcihnKSwhZy5pc0RlZmF1bHRQcmV2ZW50ZWQoKSYmIWYuaXNEZWZhdWx0UHJldmVudGVkKCkpe3ZhciBoPWEoZCk7dGhpcy5hY3RpdmF0ZShiLmNsb3Nlc3QoXCJsaVwiKSxjKSx0aGlzLmFjdGl2YXRlKGgsaC5wYXJlbnQoKSxmdW5jdGlvbigpe2UudHJpZ2dlcih7dHlwZTpcImhpZGRlbi5icy50YWJcIixyZWxhdGVkVGFyZ2V0OmJbMF19KSxiLnRyaWdnZXIoe3R5cGU6XCJzaG93bi5icy50YWJcIixyZWxhdGVkVGFyZ2V0OmVbMF19KX0pfX19LGMucHJvdG90eXBlLmFjdGl2YXRlPWZ1bmN0aW9uKGIsZCxlKXtmdW5jdGlvbiBmKCl7Zy5yZW1vdmVDbGFzcyhcImFjdGl2ZVwiKS5maW5kKFwiPiAuZHJvcGRvd24tbWVudSA+IC5hY3RpdmVcIikucmVtb3ZlQ2xhc3MoXCJhY3RpdmVcIikuZW5kKCkuZmluZCgnW2RhdGEtdG9nZ2xlPVwidGFiXCJdJykuYXR0cihcImFyaWEtZXhwYW5kZWRcIiwhMSksYi5hZGRDbGFzcyhcImFjdGl2ZVwiKS5maW5kKCdbZGF0YS10b2dnbGU9XCJ0YWJcIl0nKS5hdHRyKFwiYXJpYS1leHBhbmRlZFwiLCEwKSxoPyhiWzBdLm9mZnNldFdpZHRoLGIuYWRkQ2xhc3MoXCJpblwiKSk6Yi5yZW1vdmVDbGFzcyhcImZhZGVcIiksYi5wYXJlbnQoXCIuZHJvcGRvd24tbWVudVwiKS5sZW5ndGgmJmIuY2xvc2VzdChcImxpLmRyb3Bkb3duXCIpLmFkZENsYXNzKFwiYWN0aXZlXCIpLmVuZCgpLmZpbmQoJ1tkYXRhLXRvZ2dsZT1cInRhYlwiXScpLmF0dHIoXCJhcmlhLWV4cGFuZGVkXCIsITApLGUmJmUoKX12YXIgZz1kLmZpbmQoXCI+IC5hY3RpdmVcIiksaD1lJiZhLnN1cHBvcnQudHJhbnNpdGlvbiYmKGcubGVuZ3RoJiZnLmhhc0NsYXNzKFwiZmFkZVwiKXx8ISFkLmZpbmQoXCI+IC5mYWRlXCIpLmxlbmd0aCk7Zy5sZW5ndGgmJmg/Zy5vbmUoXCJic1RyYW5zaXRpb25FbmRcIixmKS5lbXVsYXRlVHJhbnNpdGlvbkVuZChjLlRSQU5TSVRJT05fRFVSQVRJT04pOmYoKSxnLnJlbW92ZUNsYXNzKFwiaW5cIil9O3ZhciBkPWEuZm4udGFiO2EuZm4udGFiPWIsYS5mbi50YWIuQ29uc3RydWN0b3I9YyxhLmZuLnRhYi5ub0NvbmZsaWN0PWZ1bmN0aW9uKCl7cmV0dXJuIGEuZm4udGFiPWQsdGhpc307dmFyIGU9ZnVuY3Rpb24oYyl7Yy5wcmV2ZW50RGVmYXVsdCgpLGIuY2FsbChhKHRoaXMpLFwic2hvd1wiKX07YShkb2N1bWVudCkub24oXCJjbGljay5icy50YWIuZGF0YS1hcGlcIiwnW2RhdGEtdG9nZ2xlPVwidGFiXCJdJyxlKS5vbihcImNsaWNrLmJzLnRhYi5kYXRhLWFwaVwiLCdbZGF0YS10b2dnbGU9XCJwaWxsXCJdJyxlKX0oalF1ZXJ5KSwrZnVuY3Rpb24oYSl7XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gYihiKXtyZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCl7dmFyIGQ9YSh0aGlzKSxlPWQuZGF0YShcImJzLmFmZml4XCIpLGY9XCJvYmplY3RcIj09dHlwZW9mIGImJmI7ZXx8ZC5kYXRhKFwiYnMuYWZmaXhcIixlPW5ldyBjKHRoaXMsZikpLFwic3RyaW5nXCI9PXR5cGVvZiBiJiZlW2JdKCl9KX12YXIgYz1mdW5jdGlvbihiLGQpe3RoaXMub3B0aW9ucz1hLmV4dGVuZCh7fSxjLkRFRkFVTFRTLGQpLHRoaXMuJHRhcmdldD1hKHRoaXMub3B0aW9ucy50YXJnZXQpLm9uKFwic2Nyb2xsLmJzLmFmZml4LmRhdGEtYXBpXCIsYS5wcm94eSh0aGlzLmNoZWNrUG9zaXRpb24sdGhpcykpLm9uKFwiY2xpY2suYnMuYWZmaXguZGF0YS1hcGlcIixhLnByb3h5KHRoaXMuY2hlY2tQb3NpdGlvbldpdGhFdmVudExvb3AsdGhpcykpLHRoaXMuJGVsZW1lbnQ9YShiKSx0aGlzLmFmZml4ZWQ9bnVsbCx0aGlzLnVucGluPW51bGwsdGhpcy5waW5uZWRPZmZzZXQ9bnVsbCx0aGlzLmNoZWNrUG9zaXRpb24oKX07Yy5WRVJTSU9OPVwiMy4zLjZcIixjLlJFU0VUPVwiYWZmaXggYWZmaXgtdG9wIGFmZml4LWJvdHRvbVwiLGMuREVGQVVMVFM9e29mZnNldDowLHRhcmdldDp3aW5kb3d9LGMucHJvdG90eXBlLmdldFN0YXRlPWZ1bmN0aW9uKGEsYixjLGQpe3ZhciBlPXRoaXMuJHRhcmdldC5zY3JvbGxUb3AoKSxmPXRoaXMuJGVsZW1lbnQub2Zmc2V0KCksZz10aGlzLiR0YXJnZXQuaGVpZ2h0KCk7aWYobnVsbCE9YyYmXCJ0b3BcIj09dGhpcy5hZmZpeGVkKXJldHVybiBjPmU/XCJ0b3BcIjohMTtpZihcImJvdHRvbVwiPT10aGlzLmFmZml4ZWQpcmV0dXJuIG51bGwhPWM/ZSt0aGlzLnVucGluPD1mLnRvcD8hMTpcImJvdHRvbVwiOmEtZD49ZStnPyExOlwiYm90dG9tXCI7dmFyIGg9bnVsbD09dGhpcy5hZmZpeGVkLGk9aD9lOmYudG9wLGo9aD9nOmI7cmV0dXJuIG51bGwhPWMmJmM+PWU/XCJ0b3BcIjpudWxsIT1kJiZpK2o+PWEtZD9cImJvdHRvbVwiOiExfSxjLnByb3RvdHlwZS5nZXRQaW5uZWRPZmZzZXQ9ZnVuY3Rpb24oKXtpZih0aGlzLnBpbm5lZE9mZnNldClyZXR1cm4gdGhpcy5waW5uZWRPZmZzZXQ7dGhpcy4kZWxlbWVudC5yZW1vdmVDbGFzcyhjLlJFU0VUKS5hZGRDbGFzcyhcImFmZml4XCIpO3ZhciBhPXRoaXMuJHRhcmdldC5zY3JvbGxUb3AoKSxiPXRoaXMuJGVsZW1lbnQub2Zmc2V0KCk7cmV0dXJuIHRoaXMucGlubmVkT2Zmc2V0PWIudG9wLWF9LGMucHJvdG90eXBlLmNoZWNrUG9zaXRpb25XaXRoRXZlbnRMb29wPWZ1bmN0aW9uKCl7c2V0VGltZW91dChhLnByb3h5KHRoaXMuY2hlY2tQb3NpdGlvbix0aGlzKSwxKX0sYy5wcm90b3R5cGUuY2hlY2tQb3NpdGlvbj1mdW5jdGlvbigpe2lmKHRoaXMuJGVsZW1lbnQuaXMoXCI6dmlzaWJsZVwiKSl7dmFyIGI9dGhpcy4kZWxlbWVudC5oZWlnaHQoKSxkPXRoaXMub3B0aW9ucy5vZmZzZXQsZT1kLnRvcCxmPWQuYm90dG9tLGc9TWF0aC5tYXgoYShkb2N1bWVudCkuaGVpZ2h0KCksYShkb2N1bWVudC5ib2R5KS5oZWlnaHQoKSk7XCJvYmplY3RcIiE9dHlwZW9mIGQmJihmPWU9ZCksXCJmdW5jdGlvblwiPT10eXBlb2YgZSYmKGU9ZC50b3AodGhpcy4kZWxlbWVudCkpLFwiZnVuY3Rpb25cIj09dHlwZW9mIGYmJihmPWQuYm90dG9tKHRoaXMuJGVsZW1lbnQpKTt2YXIgaD10aGlzLmdldFN0YXRlKGcsYixlLGYpO2lmKHRoaXMuYWZmaXhlZCE9aCl7bnVsbCE9dGhpcy51bnBpbiYmdGhpcy4kZWxlbWVudC5jc3MoXCJ0b3BcIixcIlwiKTt2YXIgaT1cImFmZml4XCIrKGg/XCItXCIraDpcIlwiKSxqPWEuRXZlbnQoaStcIi5icy5hZmZpeFwiKTtpZih0aGlzLiRlbGVtZW50LnRyaWdnZXIoaiksai5pc0RlZmF1bHRQcmV2ZW50ZWQoKSlyZXR1cm47dGhpcy5hZmZpeGVkPWgsdGhpcy51bnBpbj1cImJvdHRvbVwiPT1oP3RoaXMuZ2V0UGlubmVkT2Zmc2V0KCk6bnVsbCx0aGlzLiRlbGVtZW50LnJlbW92ZUNsYXNzKGMuUkVTRVQpLmFkZENsYXNzKGkpLnRyaWdnZXIoaS5yZXBsYWNlKFwiYWZmaXhcIixcImFmZml4ZWRcIikrXCIuYnMuYWZmaXhcIil9XCJib3R0b21cIj09aCYmdGhpcy4kZWxlbWVudC5vZmZzZXQoe3RvcDpnLWItZn0pfX07dmFyIGQ9YS5mbi5hZmZpeDthLmZuLmFmZml4PWIsYS5mbi5hZmZpeC5Db25zdHJ1Y3Rvcj1jLGEuZm4uYWZmaXgubm9Db25mbGljdD1mdW5jdGlvbigpe3JldHVybiBhLmZuLmFmZml4PWQsdGhpc30sYSh3aW5kb3cpLm9uKFwibG9hZFwiLGZ1bmN0aW9uKCl7YSgnW2RhdGEtc3B5PVwiYWZmaXhcIl0nKS5lYWNoKGZ1bmN0aW9uKCl7dmFyIGM9YSh0aGlzKSxkPWMuZGF0YSgpO2Qub2Zmc2V0PWQub2Zmc2V0fHx7fSxudWxsIT1kLm9mZnNldEJvdHRvbSYmKGQub2Zmc2V0LmJvdHRvbT1kLm9mZnNldEJvdHRvbSksbnVsbCE9ZC5vZmZzZXRUb3AmJihkLm9mZnNldC50b3A9ZC5vZmZzZXRUb3ApLGIuY2FsbChjLGQpfSl9KX0oalF1ZXJ5KTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zY3JpcHRzL3ZlbmRvcnMvYm9vdHN0cmFwLm1pbi5qcyIsIi8qIVxyXG4qIENsYW1wLmpzIDAuNS4xXHJcbipcclxuKiBDb3B5cmlnaHQgMjAxMS0yMDEzLCBKb3NlcGggU2NobWl0dCBodHRwOi8vam9lLnNoXHJcbiogUmVsZWFzZWQgdW5kZXIgdGhlIFdURlBMIGxpY2Vuc2VcclxuKiBodHRwOi8vc2FtLnpveS5vcmcvd3RmcGwvXHJcbiovXHJcbihmdW5jdGlvbigpe3dpbmRvdy4kY2xhbXA9ZnVuY3Rpb24oYyxkKXtmdW5jdGlvbiBzKGEsYil7bi5nZXRDb21wdXRlZFN0eWxlfHwobi5nZXRDb21wdXRlZFN0eWxlPWZ1bmN0aW9uKGEsYil7dGhpcy5lbD1hO3RoaXMuZ2V0UHJvcGVydHlWYWx1ZT1mdW5jdGlvbihiKXt2YXIgYz0vKFxcLShbYS16XSl7MX0pL2c7XCJmbG9hdFwiPT1iJiYoYj1cInN0eWxlRmxvYXRcIik7Yy50ZXN0KGIpJiYoYj1iLnJlcGxhY2UoYyxmdW5jdGlvbihhLGIsYyl7cmV0dXJuIGMudG9VcHBlckNhc2UoKX0pKTtyZXR1cm4gYS5jdXJyZW50U3R5bGUmJmEuY3VycmVudFN0eWxlW2JdP2EuY3VycmVudFN0eWxlW2JdOm51bGx9O3JldHVybiB0aGlzfSk7cmV0dXJuIG4uZ2V0Q29tcHV0ZWRTdHlsZShhLG51bGwpLmdldFByb3BlcnR5VmFsdWUoYil9ZnVuY3Rpb24gdChhKXthPWF8fGMuY2xpZW50SGVpZ2h0O3ZhciBiPXUoYyk7cmV0dXJuIE1hdGgubWF4KE1hdGguZmxvb3IoYS9iKSwwKX1mdW5jdGlvbiB4KGEpe3JldHVybiB1KGMpKlxyXG5hfWZ1bmN0aW9uIHUoYSl7dmFyIGI9cyhhLFwibGluZS1oZWlnaHRcIik7XCJub3JtYWxcIj09YiYmKGI9MS4yKnBhcnNlSW50KHMoYSxcImZvbnQtc2l6ZVwiKSkpO3JldHVybiBwYXJzZUludChiKX1mdW5jdGlvbiBsKGEpe2lmKGEubGFzdENoaWxkLmNoaWxkcmVuJiYwPGEubGFzdENoaWxkLmNoaWxkcmVuLmxlbmd0aClyZXR1cm4gbChBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhLmNoaWxkcmVuKS5wb3AoKSk7aWYoYS5sYXN0Q2hpbGQmJmEubGFzdENoaWxkLm5vZGVWYWx1ZSYmXCJcIiE9YS5sYXN0Q2hpbGQubm9kZVZhbHVlJiZhLmxhc3RDaGlsZC5ub2RlVmFsdWUhPWIudHJ1bmNhdGlvbkNoYXIpcmV0dXJuIGEubGFzdENoaWxkO2EubGFzdENoaWxkLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoYS5sYXN0Q2hpbGQpO3JldHVybiBsKGMpfWZ1bmN0aW9uIHAoYSxkKXtpZihkKXt2YXIgZT1hLm5vZGVWYWx1ZS5yZXBsYWNlKGIudHJ1bmNhdGlvbkNoYXIsXCJcIik7Znx8KGg9MDxrLmxlbmd0aD9cclxuay5zaGlmdCgpOlwiXCIsZj1lLnNwbGl0KGgpKTsxPGYubGVuZ3RoPyhxPWYucG9wKCkscihhLGYuam9pbihoKSkpOmY9bnVsbDttJiYoYS5ub2RlVmFsdWU9YS5ub2RlVmFsdWUucmVwbGFjZShiLnRydW5jYXRpb25DaGFyLFwiXCIpLGMuaW5uZXJIVE1MPWEubm9kZVZhbHVlK1wiIFwiK20uaW5uZXJIVE1MK2IudHJ1bmNhdGlvbkNoYXIpO2lmKGYpe2lmKGMuY2xpZW50SGVpZ2h0PD1kKWlmKDA8PWsubGVuZ3RoJiZcIlwiIT1oKXIoYSxmLmpvaW4oaCkraCtxKSxmPW51bGw7ZWxzZSByZXR1cm4gYy5pbm5lckhUTUx9ZWxzZVwiXCI9PWgmJihyKGEsXCJcIiksYT1sKGMpLGs9Yi5zcGxpdE9uQ2hhcnMuc2xpY2UoMCksaD1rWzBdLHE9Zj1udWxsKTtpZihiLmFuaW1hdGUpc2V0VGltZW91dChmdW5jdGlvbigpe3AoYSxkKX0sITA9PT1iLmFuaW1hdGU/MTA6Yi5hbmltYXRlKTtlbHNlIHJldHVybiBwKGEsZCl9fWZ1bmN0aW9uIHIoYSxjKXthLm5vZGVWYWx1ZT1jK2IudHJ1bmNhdGlvbkNoYXJ9ZD1kfHx7fTtcclxudmFyIG49d2luZG93LGI9e2NsYW1wOmQuY2xhbXB8fDIsdXNlTmF0aXZlQ2xhbXA6XCJ1bmRlZmluZWRcIiE9dHlwZW9mIGQudXNlTmF0aXZlQ2xhbXA/ZC51c2VOYXRpdmVDbGFtcDohMCxzcGxpdE9uQ2hhcnM6ZC5zcGxpdE9uQ2hhcnN8fFtcIi5cIixcIi1cIixcIlxcdTIwMTNcIixcIlxcdTIwMTRcIixcIiBcIl0sYW5pbWF0ZTpkLmFuaW1hdGV8fCExLHRydW5jYXRpb25DaGFyOmQudHJ1bmNhdGlvbkNoYXJ8fFwiXFx1MjAyNlwiLHRydW5jYXRpb25IVE1MOmQudHJ1bmNhdGlvbkhUTUx9LGU9Yy5zdHlsZSx5PWMuaW5uZXJIVE1MLHo9XCJ1bmRlZmluZWRcIiE9dHlwZW9mIGMuc3R5bGUud2Via2l0TGluZUNsYW1wLGc9Yi5jbGFtcCx2PWcuaW5kZXhPZiYmKC0xPGcuaW5kZXhPZihcInB4XCIpfHwtMTxnLmluZGV4T2YoXCJlbVwiKSksbTtiLnRydW5jYXRpb25IVE1MJiYobT1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3BhblwiKSxtLmlubmVySFRNTD1iLnRydW5jYXRpb25IVE1MKTt2YXIgaz1iLnNwbGl0T25DaGFycy5zbGljZSgwKSxcclxuaD1rWzBdLGYscTtcImF1dG9cIj09Zz9nPXQoKTp2JiYoZz10KHBhcnNlSW50KGcpKSk7dmFyIHc7eiYmYi51c2VOYXRpdmVDbGFtcD8oZS5vdmVyZmxvdz1cImhpZGRlblwiLGUudGV4dE92ZXJmbG93PVwiZWxsaXBzaXNcIixlLndlYmtpdEJveE9yaWVudD1cInZlcnRpY2FsXCIsZS5kaXNwbGF5PVwiLXdlYmtpdC1ib3hcIixlLndlYmtpdExpbmVDbGFtcD1nLHYmJihlLmhlaWdodD1iLmNsYW1wK1wicHhcIikpOihlPXgoZyksZTw9Yy5jbGllbnRIZWlnaHQmJih3PXAobChjKSxlKSkpO3JldHVybntvcmlnaW5hbDp5LGNsYW1wZWQ6d319fSkoKTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zY3JpcHRzL3ZlbmRvcnMvY2xhbXAubWluLmpzIiwiLy9KYXZhc3JpcHQgbmFtZTogTXkgRGF0ZSBUaW1lIFBpY2tlclxyXG4vL0RhdGUgY3JlYXRlZDogMTYtTm92LTIwMDMgMjM6MTlcclxuLy9DcmVhdG9yOiBUZW5nWW9uZyBOZ1xyXG4vL1dlYnNpdGU6IGh0dHA6Ly93d3cucmFpbmZvcmVzdG5ldC5jb21cclxuLy9Db3B5cmlnaHQgKGMpIDIwMDMgVGVuZ1lvbmcgTmdcclxuLy9GaWxlTmFtZTogRGF0ZVRpbWVQaWNrZXJfY3NzLmpzXHJcbi8vVmVyc2lvbjogMi4yLjRcclxuLy8gTm90ZTogUGVybWlzc2lvbiBnaXZlbiB0byB1c2UgYW5kIG1vZGlmeSB0aGlzIHNjcmlwdCBpbiBBTlkga2luZCBvZiBhcHBsaWNhdGlvbnMgaWZcclxuLy8gICAgICAgaGVhZGVyIGxpbmVzIGFyZSBsZWZ0IHVuY2hhbmdlZC5cclxuLy9QZXJtaXNzaW9uIGlzIGdyYW50ZWQgdG8gcmVkaXN0cmlidXRlIGFuZCBtb2RpZnkgdGhpcyBqYXZhc2NyaXB0IHVuZGVyIGEgRnJlZUJTRCBMaWNlbnNlLlxyXG4vL05ldyBDc3Mgc3R5bGUgdmVyc2lvbiBhZGRlZCBieSBZdmFuIExhdm9pZSAoUXXDqWJlYywgQ2FuYWRhKSAyOS1KYW4tMjAwOVxyXG4vL0Zvcm1hdHRlZCBmb3IgSlNMaW50IGNvbXBhdGliaWxpdHkgYnkgTGFic21lZGlhLmNvbSAoMzAtRGVjLTIwMTApXHJcblxyXG5cclxuLy9HbG9iYWwgdmFyaWFibGVzXHJcblxyXG53aW5kb3cud2luQ2FsID0gdW5kZWZpbmVkO1xyXG53aW5kb3cuZHRUb2RheSA9IHVuZGVmaW5lZDtcclxud2luZG93LkNhbCA9IHVuZGVmaW5lZDtcclxud2luZG93LmV4RGF0ZVRpbWUgPSB1bmRlZmluZWQ7Ly9FeGlzdGluZyBEYXRlIGFuZCBUaW1lXHJcbndpbmRvdy5zZWxEYXRlID0gdW5kZWZpbmVkOy8vc2VsZWN0ZWQgZGF0ZS4gdmVyc2lvbiAxLjdcclxud2luZG93LmNhbFNwYW5JRCA9IFwiY2FsQm9yZGVyXCI7IC8vIHNwYW4gSURcclxud2luZG93LmRvbVN0eWxlID0gbnVsbDsgLy8gc3BhbiBET00gb2JqZWN0IHdpdGggc3R5bGVcclxud2luZG93LmNuTGVmdCA9IFwiMFwiOy8vbGVmdCBjb29yZGluYXRlIG9mIGNhbGVuZGFyIHNwYW5cclxud2luZG93LmNuVG9wID0gXCIwXCI7Ly90b3AgY29vcmRpbmF0ZSBvZiBjYWxlbmRhciBzcGFuXHJcbndpbmRvdy54cG9zID0gMDsgLy8gbW91c2UgeCBwb3NpdGlvblxyXG53aW5kb3cueXBvcyA9IDA7IC8vIG1vdXNlIHkgcG9zaXRpb25cclxud2luZG93LmNhbEhlaWdodCA9IDA7IC8vIGNhbGVuZGFyIGhlaWdodFxyXG53aW5kb3cuQ2FsV2lkdGggPSBcImF1dG9cIjsvLyBjYWxlbmRhciB3aWR0aFxyXG53aW5kb3cuQ2VsbFdpZHRoID0gMzY7Ly8gd2lkdGggb2YgZGF5IGNlbGwuXHJcbndpbmRvdy5UaW1lTW9kZSA9IDI0Oy8vIFRpbWVNb2RlIHZhbHVlLiAxMiBvciAyNFxyXG53aW5kb3cuU3RhcnRZZWFyID0gcGFyc2VJbnQobmV3IERhdGUoKS5nZXRGdWxsWWVhcigpKTsgLy9GaXJzdCBZZWFyIGluIGRyb3AgZG93biB5ZWFyIHNlbGVjdGlvblxyXG53aW5kb3cuRW5kWWVhciA9IDU7IC8vIFRoZSBsYXN0IHllYXIgb2YgcGlja2FibGUgZGF0ZS4gaWYgY3VycmVudCB5ZWFyIGlzIDIwMTEsIHRoZSBsYXN0IHllYXIgdGhhdCBzdGlsbCBwaWNrZXIgd2lsbCBiZSAyMDE2ICgyMDExKzUpXHJcbndpbmRvdy5DYWxQb3NPZmZzZXRYID0gLTIyNzsgLy9YIHBvc2l0aW9uIG9mZnNldCByZWxhdGl2ZSB0byBjYWxlbmRhciBpY29uLCBjYW4gYmUgbmVnYXRpdmUgdmFsdWVcclxud2luZG93LkNhbFBvc09mZnNldFkgPSAtMjMwOyAvL1kgcG9zaXRpb24gb2Zmc2V0IHJlbGF0aXZlIHRvIGNhbGVuZGFyIGljb24sIGNhbiBiZSBuZWdhdGl2ZSB2YWx1ZVxyXG53aW5kb3cuc2hvd01vbnRoSW5IZWFkID0gXCJkaXNwbGF5Om5vbmU7XCI7XHJcbi8vQ29uZmlndXJhYmxlIHBhcmFtZXRlcnMgc3RhcnRcclxud2luZG93LlNwYW5Cb3JkZXJDb2xvciA9IFwiI2NjY2NjY1wiOy8vc3BhbiBib3JkZXIgY29sb3Jcclxud2luZG93LlNwYW5CZ0NvbG9yID0gXCIjRkZGRkZGXCI7IC8vc3BhbiBiYWNrZ3JvdW5kIGNvbG9yXHJcbndpbmRvdy5Nb250aFllYXJDb2xvciA9IFwiI2NjMDAzM1wiOyAvL0ZvbnQgQ29sb3Igb2YgTW9udGggYW5kIFllYXIgaW4gQ2FsZW5kYXIgaGVhZGVyLlxyXG53aW5kb3cuV2Vla0hlYWRDb2xvciA9IFwiI2I3YzlkM1wiOyAvL3ZhciBXZWVrSGVhZENvbG9yPVwiIzE4ODYxQlwiOy8vQmFja2dyb3VuZCBDb2xvciBpbiBXZWVrIGhlYWRlci5cclxud2luZG93LldlZWtIZWFkQmFja2dyb3VuZCA9IFwiI2ZmZmZmZlwiOyAvL3ZhciBXZWVrSGVhZENvbG9yPVwiIzE4ODYxQlwiOy8vQmFja2dyb3VuZCBDb2xvciBpbiBXZWVrIGhlYWRlci5cclxud2luZG93LlN1bmRheUNvbG9yID0gXCJcIjsgLy92YXIgU3VuZGF5Q29sb3I9XCIjQzBGNjRGXCI7Ly9CYWNrZ3JvdW5kIGNvbG9yIG9mIFN1bmRheS5cclxud2luZG93LlNhdHVyZGF5Q29sb3IgPSBcIlwiOyAvL0JhY2tncm91bmQgY29sb3Igb2YgU2F0dXJkYXkuXHJcbndpbmRvdy5XZWVrRGF5Q29sb3IgPSBcIlwiOyAvL0JhY2tncm91bmQgY29sb3Igb2Ygd2Vla2RheXMuXHJcbndpbmRvdy5Gb250Q29sb3IgPSBcImJsdWVcIjsgLy9jb2xvciBvZiBmb250IGluIENhbGVuZGFyIGRheSBjZWxsLlxyXG53aW5kb3cuVG9kYXlDb2xvciA9ICdmb250LWZhbWlseTpcIlRNU2Fucy1Cb2xkXCIsSGVsdmV0aWNhLEFyaWFsLHNhbnMtc2VyaWY7Ym94LXNoYWRvdzowIDAgMnB4IHJnYmEoMCwwLDAsMSk7Jztcclxud2luZG93LlNlbERhdGVDb2xvciA9ICdmb250LWZhbWlseTpcIlRNU2Fucy1Cb2xkXCIsSGVsdmV0aWNhLEFyaWFsLHNhbnMtc2VyaWY7Y29sb3I6I2ZmZjtiYWNrZ3JvdW5kOiMxNzljZGI7Jztcclxud2luZG93LllyU2VsQ29sb3IgPSBcIiNjYzAwMzNcIjsgLy9jb2xvciBvZiBmb250IG9mIFllYXIgc2VsZWN0b3IuXHJcbndpbmRvdy5NdGhTZWxDb2xvciA9IFwiI2NjMDAzM1wiOyAvL2NvbG9yIG9mIGZvbnQgb2YgTW9udGggc2VsZWN0b3IgaWYgXCJNb250aFNlbGVjdG9yXCIgaXMgXCJhcnJvd1wiLlxyXG53aW5kb3cuSG92ZXJDb2xvciA9IFwiI0UwRkYzOFwiOyAvL2NvbG9yIHdoZW4gbW91c2UgbW92ZSBvdmVyLlxyXG53aW5kb3cuRGlzYWJsZUNvbG9yID0gXCIjOTk5OTY2XCI7IC8vY29sb3Igb2YgZGlzYWJsZWQgY2VsbC5cclxud2luZG93LkNhbEJnQ29sb3IgPSBcIiNmZmZmZmZcIjsgLy9CYWNrZ3JvdW5kIGNvbG9yIG9mIENhbGVuZGFyIHdpbmRvdy5cclxud2luZG93LnRvcFNlbGVjdG9yQmcgPSBcIiNmMWY0ZjZcIjtcclxuXHJcbndpbmRvdy5XZWVrQ2hhciA9IDI7Ly9udW1iZXIgb2YgY2hhcmFjdGVyIGZvciB3ZWVrIGRheS4gaWYgMiB0aGVuIE1vLFR1LFdlLiBpZiAzIHRoZW4gTW9uLFR1ZSxXZWQuXHJcbndpbmRvdy5EYXRlU2VwYXJhdG9yID0gXCItXCI7Ly9EYXRlIFNlcGFyYXRvciwgeW91IGNhbiBjaGFuZ2UgaXQgdG8gXCItXCIgaWYgeW91IHdhbnQuXHJcbndpbmRvdy5TaG93TG9uZ01vbnRoID0gdHJ1ZTsvL1Nob3cgbG9uZyBtb250aCBuYW1lIGluIENhbGVuZGFyIGhlYWRlci4gZXhhbXBsZTogXCJKYW51YXJ5XCIuXHJcbndpbmRvdy5TaG93TW9udGhZZWFyID0gdHJ1ZTsvL1Nob3cgTW9udGggYW5kIFllYXIgaW4gQ2FsZW5kYXIgaGVhZGVyLlxyXG53aW5kb3cuVGhlbWVCZyA9IFwiXCI7Ly9CYWNrZ3JvdW5kIGltYWdlIG9mIENhbGVuZGFyIHdpbmRvdy5cclxud2luZG93LlByZWNlZGVaZXJvID0gdHJ1ZTsvL1ByZWNlZGluZyB6ZXJvIFt0cnVlfGZhbHNlXVxyXG53aW5kb3cuTW9uZGF5Rmlyc3REYXkgPSBmYWxzZTsvL3RydWU6VXNlIE1vbmRheSBhcyBmaXJzdCBkYXk7IGZhbHNlOlN1bmRheSBhcyBmaXJzdCBkYXkuIFt0cnVlfGZhbHNlXSAgLy9hZGRlZCBpbiB2ZXJzaW9uIDEuN1xyXG53aW5kb3cuVXNlSW1hZ2VGaWxlcyA9IGZhbHNlOy8vVXNlIGltYWdlIGZpbGVzIHdpdGggXCJhcnJvd3NcIiBhbmQgXCJjbG9zZVwiIGJ1dHRvblxyXG53aW5kb3cuaW1hZ2VGaWxlc1BhdGggPSBcImltYWdlczIvXCI7XHJcbi8vQ29uZmlndXJhYmxlIHBhcmFtZXRlcnMgZW5kXHJcblxyXG4vL3VzZSB0aGUgTW9udGggYW5kIFdlZWtkYXkgaW4geW91ciBwcmVmZXJyZWQgbGFuZ3VhZ2UuXHJcbndpbmRvdy5Nb250aE5hbWUgPSBbXCJKYW51YXJ5XCIsIFwiRmVicnVhcnlcIiwgXCJNYXJjaFwiLCBcIkFwcmlsXCIsIFwiTWF5XCIsIFwiSnVuZVwiLCBcIkp1bHlcIiwgXCJBdWd1c3RcIiwgXCJTZXB0ZW1iZXJcIiwgXCJPY3RvYmVyXCIsIFwiTm92ZW1iZXJcIiwgXCJEZWNlbWJlclwiXTtcclxud2luZG93LldlZWtEYXlOYW1lMSA9IFtcIlNcIiwgXCJNXCIsIFwiVFwiLCBcIldcIiwgXCJUXCIsIFwiRlwiLCBcIlNcIl07XHJcbndpbmRvdy5XZWVrRGF5TmFtZTIgPSBbXCJNb25kYXlcIiwgXCJUdWVzZGF5XCIsIFwiV2VkbmVzZGF5XCIsIFwiVGh1cnNkYXlcIiwgXCJGcmlkYXlcIiwgXCJTYXR1cmRheVwiLCBcIlN1bmRheVwiXTtcclxuXHJcbi8vZW5kIENvbmZpZ3VyYWJsZSBwYXJhbWV0ZXJzXHJcblxyXG4vL2VuZCBHbG9iYWwgdmFyaWFibGVcclxuXHJcbi8vIENhbGVuZGFyIHByb3RvdHlwZVxyXG5mdW5jdGlvbiBDYWxlbmRhcihwRGF0ZSwgcEN0cmwpIHtcclxuXHQvL1Byb3BlcnRpZXNcclxuXHR0aGlzLkRhdGUgPSBwRGF0ZS5nZXREYXRlKCk7Ly9zZWxlY3RlZCBkYXRlXHJcblx0dGhpcy5Nb250aCA9IHBEYXRlLmdldE1vbnRoKCk7Ly9zZWxlY3RlZCBtb250aCBudW1iZXJcclxuXHR0aGlzLlllYXIgPSBwRGF0ZS5nZXRGdWxsWWVhcigpOy8vc2VsZWN0ZWQgeWVhciBpbiA0IGRpZ2l0c1xyXG5cdHRoaXMuSG91cnMgPSBwRGF0ZS5nZXRIb3VycygpO1xyXG5cclxuXHRpZiAocERhdGUuZ2V0TWludXRlcygpIDwgMTApIHtcclxuXHRcdHRoaXMuTWludXRlcyA9IFwiMFwiICsgcERhdGUuZ2V0TWludXRlcygpO1xyXG5cdH0gZWxzZSB7XHJcblx0XHR0aGlzLk1pbnV0ZXMgPSBwRGF0ZS5nZXRNaW51dGVzKCk7XHJcblx0fVxyXG5cclxuXHRpZiAocERhdGUuZ2V0U2Vjb25kcygpIDwgMTApIHtcclxuXHRcdHRoaXMuU2Vjb25kcyA9IFwiMFwiICsgcERhdGUuZ2V0U2Vjb25kcygpO1xyXG5cdH0gZWxzZSB7XHJcblx0XHR0aGlzLlNlY29uZHMgPSBwRGF0ZS5nZXRTZWNvbmRzKCk7XHJcblx0fVxyXG5cclxuXHR0aGlzLk15V2luZG93ID0gd2luQ2FsO1xyXG5cdHRoaXMuQ3RybCA9IHBDdHJsO1xyXG5cdHRoaXMuRm9ybWF0ID0gXCJkZE1NeXl5eVwiO1xyXG5cdHRoaXMuU2VwYXJhdG9yID0gRGF0ZVNlcGFyYXRvcjtcclxuXHR0aGlzLlNob3dUaW1lID0gZmFsc2U7XHJcblx0dGhpcy5TY3JvbGxlciA9IFwiRFJPUERPV05cIjtcclxuXHJcblx0aWYgKHBEYXRlLmdldEhvdXJzKCkgPCAxMikge1xyXG5cdFx0dGhpcy5BTW9yUE0gPSBcIkFNXCI7XHJcblx0fSBlbHNlIHtcclxuXHRcdHRoaXMuQU1vclBNID0gXCJQTVwiO1xyXG5cdH1cclxuXHJcblx0dGhpcy5TaG93U2Vjb25kcyA9IGZhbHNlO1xyXG5cdHRoaXMuRW5hYmxlRGF0ZU1vZGUgPSBcIlwiXHJcbn1cclxuXHJcbkNhbGVuZGFyLnByb3RvdHlwZS5HZXRNb250aEluZGV4ID0gZnVuY3Rpb24gKHNob3J0TW9udGhOYW1lKSB7XHJcblx0Zm9yICh2YXIgaSA9IDA7IGkgPCAxMjsgaSArPSAxKSB7XHJcblx0XHRpZiAoTW9udGhOYW1lW2ldLnN1YnN0cmluZygwLCAzKS50b1VwcGVyQ2FzZSgpID09PSBzaG9ydE1vbnRoTmFtZS50b1VwcGVyQ2FzZSgpKSB7XHJcblx0XHRcdHJldHVybiBpO1xyXG5cdFx0fVxyXG5cdH1cclxufTtcclxuXHJcbkNhbGVuZGFyLnByb3RvdHlwZS5JbmNZZWFyID0gZnVuY3Rpb24gKCkge1xyXG5cdGlmIChDYWwuWWVhciA8PSBkdFRvZGF5LmdldEZ1bGxZZWFyKCkrRW5kWWVhcilcclxuXHRcdENhbC5ZZWFyICs9IDE7XHJcbn07XHJcblxyXG5DYWxlbmRhci5wcm90b3R5cGUuRGVjWWVhciA9IGZ1bmN0aW9uICgpIHtcclxuXHRpZiAoQ2FsLlllYXIgPiBTdGFydFllYXIpXHJcblx0XHRDYWwuWWVhciAtPSAxO1xyXG59O1xyXG5cclxuQ2FsZW5kYXIucHJvdG90eXBlLkluY01vbnRoID0gZnVuY3Rpb24oKSB7XHJcblx0aWYgKENhbC5ZZWFyIDw9IGR0VG9kYXkuZ2V0RnVsbFllYXIoKSArIEVuZFllYXIpIHtcclxuXHRcdENhbC5Nb250aCArPSAxO1xyXG5cdFx0aWYgKENhbC5Nb250aCA+PSAxMikge1xyXG5cdFx0XHRDYWwuTW9udGggPSAwO1xyXG5cdFx0XHRDYWwuSW5jWWVhcigpO1xyXG5cdFx0fVxyXG5cdH1cclxufTtcclxuXHJcbkNhbGVuZGFyLnByb3RvdHlwZS5EZWNNb250aCA9IGZ1bmN0aW9uKCkge1xyXG5cdGlmIChDYWwuWWVhciA+PSBTdGFydFllYXIpIHtcclxuXHRcdENhbC5Nb250aCAtPSAxO1xyXG5cdFx0aWYgKENhbC5Nb250aCA8IDApIHtcclxuXHRcdFx0Q2FsLk1vbnRoID0gMTE7XHJcblx0XHRcdENhbC5EZWNZZWFyKCk7XHJcblx0XHR9XHJcblx0fVxyXG59O1xyXG5cclxuQ2FsZW5kYXIucHJvdG90eXBlLlN3aXRjaE10aCA9IGZ1bmN0aW9uIChpbnRNdGgpIHtcclxuXHRDYWwuTW9udGggPSBwYXJzZUludChpbnRNdGgsIDEwKTtcclxufTtcclxuXHJcbkNhbGVuZGFyLnByb3RvdHlwZS5Td2l0Y2hZZWFyID0gZnVuY3Rpb24gKGludFllYXIpIHtcclxuXHRDYWwuWWVhciA9IHBhcnNlSW50KGludFllYXIsIDEwKTtcclxufTtcclxuXHJcbkNhbGVuZGFyLnByb3RvdHlwZS5TZXRIb3VyID0gZnVuY3Rpb24oaW50SG91cikge1xyXG5cdHZhciBNYXhIb3VyLFxyXG5cdFx0TWluSG91cixcclxuXHRcdEhvdXJFeHAgPSBuZXcgUmVnRXhwKFwiXlxcXFxkXFxcXGRcIiksXHJcblx0XHRTaW5nbGVEaWdpdCA9IG5ldyBSZWdFeHAoXCJeXFxcXGR7MX0kXCIpO1xyXG5cclxuXHRpZiAoVGltZU1vZGUgPT09IDI0KSB7XHJcblx0XHRNYXhIb3VyID0gMjM7XHJcblx0XHRNaW5Ib3VyID0gMDtcclxuXHR9XHJcblx0ZWxzZSBpZiAoVGltZU1vZGUgPT09IDEyKSB7XHJcblx0XHRNYXhIb3VyID0gMTI7XHJcblx0XHRNaW5Ib3VyID0gMTtcclxuXHR9XHJcblx0ZWxzZSB7XHJcblx0XHRhbGVydChcIlRpbWVNb2RlIGNhbiBvbmx5IGJlIDEyIG9yIDI0XCIpO1xyXG5cdH1cclxuXHJcblx0aWYgKChIb3VyRXhwLnRlc3QoaW50SG91cikgfHwgU2luZ2xlRGlnaXQudGVzdChpbnRIb3VyKSkgJiYgKHBhcnNlSW50KGludEhvdXIsIDEwKSA+IE1heEhvdXIpKSB7XHJcblx0XHRpbnRIb3VyID0gTWluSG91cjtcclxuXHR9XHJcblxyXG5cdGVsc2UgaWYgKChIb3VyRXhwLnRlc3QoaW50SG91cikgfHwgU2luZ2xlRGlnaXQudGVzdChpbnRIb3VyKSkgJiYgKHBhcnNlSW50KGludEhvdXIsIDEwKSA8IE1pbkhvdXIpKSB7XHJcblx0XHRpbnRIb3VyID0gTWF4SG91cjtcclxuXHR9XHJcblxyXG5cdGludEhvdXIgPSBwYXJzZUludChpbnRIb3VyLCAxMCk7XHJcblx0aWYgKFNpbmdsZURpZ2l0LnRlc3QoaW50SG91cikpIHtcclxuXHRcdGludEhvdXIgPSBcIjBcIiArIGludEhvdXI7XHJcblx0fVxyXG5cclxuXHRpZiAoSG91ckV4cC50ZXN0KGludEhvdXIpICYmIChwYXJzZUludChpbnRIb3VyLCAxMCkgPD0gTWF4SG91cikgJiYgKHBhcnNlSW50KGludEhvdXIsIDEwKSA+PSBNaW5Ib3VyKSkge1xyXG5cdFx0aWYgKChUaW1lTW9kZSA9PT0gMTIpICYmIChDYWwuQU1vclBNID09PSBcIlBNXCIpKSB7XHJcblx0XHRcdGlmIChwYXJzZUludChpbnRIb3VyLCAxMCkgPT09IDEyKSB7XHJcblx0XHRcdFx0Q2FsLkhvdXJzID0gMTI7XHJcblx0XHRcdH1cclxuXHRcdFx0ZWxzZSB7XHJcblx0XHRcdFx0Q2FsLkhvdXJzID0gcGFyc2VJbnQoaW50SG91ciwgMTApICsgMTI7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRlbHNlIGlmICgoVGltZU1vZGUgPT09IDEyKSAmJiAoQ2FsLkFNb3JQTSA9PT0gXCJBTVwiKSkge1xyXG5cdFx0XHRpZiAoaW50SG91ciA9PT0gMTIpIHtcclxuXHRcdFx0XHRpbnRIb3VyIC09IDEyO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRDYWwuSG91cnMgPSBwYXJzZUludChpbnRIb3VyLCAxMCk7XHJcblx0XHR9XHJcblxyXG5cdFx0ZWxzZSBpZiAoVGltZU1vZGUgPT09IDI0KSB7XHJcblx0XHRcdENhbC5Ib3VycyA9IHBhcnNlSW50KGludEhvdXIsIDEwKTtcclxuXHRcdH1cclxuXHR9XHJcblxyXG59O1xyXG5cclxuQ2FsZW5kYXIucHJvdG90eXBlLlNldE1pbnV0ZSA9IGZ1bmN0aW9uIChpbnRNaW4pIHtcclxuXHR2YXIgTWF4TWluID0gNTksXHJcblx0XHRNaW5NaW4gPSAwLFxyXG5cclxuXHRcdFNpbmdsZURpZ2l0ID0gbmV3IFJlZ0V4cChcIlxcXFxkXCIpLFxyXG5cdFx0U2luZ2xlRGlnaXQyID0gbmV3IFJlZ0V4cChcIl5cXFxcZHsxfSRcIiksXHJcblx0XHRNaW5FeHAgPSBuZXcgUmVnRXhwKFwiXlxcXFxkezJ9JFwiKSxcclxuXHJcblx0XHRzdHJNaW4gPSAwO1xyXG5cclxuXHRpZiAoKE1pbkV4cC50ZXN0KGludE1pbikgfHwgU2luZ2xlRGlnaXQudGVzdChpbnRNaW4pKSAmJiAocGFyc2VJbnQoaW50TWluLCAxMCkgPiBNYXhNaW4pKVxyXG5cdHtcclxuXHRcdGludE1pbiA9IE1pbk1pbjtcclxuXHR9XHJcblxyXG5cdGVsc2UgaWYgKChNaW5FeHAudGVzdChpbnRNaW4pIHx8IFNpbmdsZURpZ2l0LnRlc3QoaW50TWluKSkgJiYgKHBhcnNlSW50KGludE1pbiwgMTApIDwgTWluTWluKSlcclxuXHR7XHJcblx0XHRpbnRNaW4gPSBNYXhNaW47XHJcblx0fVxyXG5cclxuXHRzdHJNaW4gPSBpbnRNaW4gKyBcIlwiO1xyXG5cdGlmIChTaW5nbGVEaWdpdDIudGVzdChpbnRNaW4pKVxyXG5cdHtcclxuXHRcdHN0ck1pbiA9IFwiMFwiICsgc3RyTWluO1xyXG5cdH1cclxuXHJcblx0aWYgKChNaW5FeHAudGVzdChpbnRNaW4pIHx8IFNpbmdsZURpZ2l0LnRlc3QoaW50TWluKSkgJiYgKHBhcnNlSW50KGludE1pbiwgMTApIDw9IDU5KSAmJiAocGFyc2VJbnQoaW50TWluLCAxMCkgPj0gMCkpXHJcblx0e1xyXG5cdFx0Q2FsLk1pbnV0ZXMgPSBzdHJNaW47XHJcblx0fVxyXG59O1xyXG5cclxuQ2FsZW5kYXIucHJvdG90eXBlLlNldFNlY29uZCA9IGZ1bmN0aW9uIChpbnRTZWMpIHtcclxuXHR2YXIgTWF4U2VjID0gNTksXHJcblx0XHRNaW5TZWMgPSAwLFxyXG5cclxuXHRcdFNpbmdsZURpZ2l0ID0gbmV3IFJlZ0V4cChcIlxcXFxkXCIpLFxyXG5cdFx0U2luZ2xlRGlnaXQyID0gbmV3IFJlZ0V4cChcIl5cXFxcZHsxfSRcIiksXHJcblx0XHRTZWNFeHAgPSBuZXcgUmVnRXhwKFwiXlxcXFxkezJ9JFwiKSxcclxuXHJcblx0XHRzdHJTZWMgPSAwO1xyXG5cclxuXHRpZiAoKFNlY0V4cC50ZXN0KGludFNlYykgfHwgU2luZ2xlRGlnaXQudGVzdChpbnRTZWMpKSAmJiAocGFyc2VJbnQoaW50U2VjLCAxMCkgPiBNYXhTZWMpKVxyXG5cdHtcclxuXHRcdGludFNlYyA9IE1pblNlYztcclxuXHR9XHJcblxyXG5cdGVsc2UgaWYgKChTZWNFeHAudGVzdChpbnRTZWMpIHx8IFNpbmdsZURpZ2l0LnRlc3QoaW50U2VjKSkgJiYgKHBhcnNlSW50KGludFNlYywgMTApIDwgTWluU2VjKSlcclxuXHR7XHJcblx0XHRpbnRTZWMgPSBNYXhTZWM7XHJcblx0fVxyXG5cclxuXHRzdHJTZWMgPSBpbnRTZWMgKyBcIlwiO1xyXG5cdGlmIChTaW5nbGVEaWdpdDIudGVzdChpbnRTZWMpKVxyXG5cdHtcclxuXHRcdHN0clNlYyA9IFwiMFwiICsgc3RyU2VjO1xyXG5cdH1cclxuXHJcblx0aWYgKChTZWNFeHAudGVzdChpbnRTZWMpIHx8IFNpbmdsZURpZ2l0LnRlc3QoaW50U2VjKSkgJiYgKHBhcnNlSW50KGludFNlYywgMTApIDw9IDU5KSAmJiAocGFyc2VJbnQoaW50U2VjLCAxMCkgPj0gMCkpXHJcblx0e1xyXG5cdFx0Q2FsLlNlY29uZHMgPSBzdHJTZWM7XHJcblx0fVxyXG5cclxufTtcclxuXHJcbkNhbGVuZGFyLnByb3RvdHlwZS5TZXRBbVBtID0gZnVuY3Rpb24gKHB2YWx1ZSkge1xyXG5cdHRoaXMuQU1vclBNID0gcHZhbHVlO1xyXG5cdGlmIChwdmFsdWUgPT09IFwiUE1cIilcclxuXHR7XHJcblx0XHR0aGlzLkhvdXJzID0gcGFyc2VJbnQodGhpcy5Ib3VycywgMTApICsgMTI7XHJcblx0XHRpZiAodGhpcy5Ib3VycyA9PT0gMjQpXHJcblx0XHR7XHJcblx0XHRcdHRoaXMuSG91cnMgPSAxMjtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdGVsc2UgaWYgKHB2YWx1ZSA9PT0gXCJBTVwiKVxyXG5cdHtcclxuXHRcdHRoaXMuSG91cnMgLT0gMTI7XHJcblx0fVxyXG59O1xyXG5cclxuQ2FsZW5kYXIucHJvdG90eXBlLmdldFNob3dIb3VyID0gZnVuY3Rpb24oKSB7XHJcblx0dmFyIGZpbmFsSG91cjtcclxuXHJcblx0aWYgKFRpbWVNb2RlID09PSAxMikge1xyXG5cdFx0aWYgKHBhcnNlSW50KHRoaXMuSG91cnMsIDEwKSA9PT0gMCkge1xyXG5cdFx0XHR0aGlzLkFNb3JQTSA9IFwiQU1cIjtcclxuXHRcdFx0ZmluYWxIb3VyID0gcGFyc2VJbnQodGhpcy5Ib3VycywgMTApICsgMTI7XHJcblx0XHR9XHJcblxyXG5cdFx0ZWxzZSBpZiAocGFyc2VJbnQodGhpcy5Ib3VycywgMTApID09PSAxMikge1xyXG5cdFx0XHR0aGlzLkFNb3JQTSA9IFwiUE1cIjtcclxuXHRcdFx0ZmluYWxIb3VyID0gMTI7XHJcblx0XHR9XHJcblxyXG5cdFx0ZWxzZSBpZiAodGhpcy5Ib3VycyA+IDEyKSB7XHJcblx0XHRcdHRoaXMuQU1vclBNID0gXCJQTVwiO1xyXG5cdFx0XHRpZiAoKHRoaXMuSG91cnMgLSAxMikgPCAxMCkge1xyXG5cdFx0XHRcdGZpbmFsSG91ciA9IFwiMFwiICsgKChwYXJzZUludCh0aGlzLkhvdXJzLCAxMCkpIC0gMTIpO1xyXG5cdFx0XHR9XHJcblx0XHRcdGVsc2Uge1xyXG5cdFx0XHRcdGZpbmFsSG91ciA9IHBhcnNlSW50KHRoaXMuSG91cnMsIDEwKSAtIDEyO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRlbHNlIHtcclxuXHRcdFx0dGhpcy5BTW9yUE0gPSBcIkFNXCI7XHJcblx0XHRcdGlmICh0aGlzLkhvdXJzIDwgMTApIHtcclxuXHRcdFx0XHRmaW5hbEhvdXIgPSBcIjBcIiArIHBhcnNlSW50KHRoaXMuSG91cnMsIDEwKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRlbHNlIHtcclxuXHRcdFx0XHRmaW5hbEhvdXIgPSB0aGlzLkhvdXJzO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHRlbHNlIGlmIChUaW1lTW9kZSA9PT0gMjQpIHtcclxuXHRcdGlmICh0aGlzLkhvdXJzIDwgMTApIHtcclxuXHRcdFx0ZmluYWxIb3VyID0gXCIwXCIgKyBwYXJzZUludCh0aGlzLkhvdXJzLCAxMCk7XHJcblx0XHR9XHJcblx0XHRlbHNlIHtcclxuXHRcdFx0ZmluYWxIb3VyID0gdGhpcy5Ib3VycztcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdHJldHVybiBmaW5hbEhvdXI7XHJcbn07XHJcblxyXG5DYWxlbmRhci5wcm90b3R5cGUuZ2V0U2hvd0FNb3JQTSA9IGZ1bmN0aW9uICgpIHtcclxuXHRyZXR1cm4gdGhpcy5BTW9yUE07XHJcbn07XHJcblxyXG5DYWxlbmRhci5wcm90b3R5cGUuR2V0TW9udGhOYW1lID0gZnVuY3Rpb24gKElzTG9uZykge1xyXG5cdHZhciBNb250aCA9IE1vbnRoTmFtZVt0aGlzLk1vbnRoXTtcclxuXHRpZiAoSXNMb25nKVxyXG5cdHtcclxuXHRcdHJldHVybiBNb250aDtcclxuXHR9XHJcblx0ZWxzZVxyXG5cdHtcclxuXHRcdHJldHVybiBNb250aC5zdWJzdHIoMCwgMyk7XHJcblx0fVxyXG59O1xyXG5cclxuQ2FsZW5kYXIucHJvdG90eXBlLkdldE1vbkRheXMgPSBmdW5jdGlvbigpIHsgLy9HZXQgbnVtYmVyIG9mIGRheXMgaW4gYSBtb250aFxyXG5cclxuXHR2YXIgRGF5c0luTW9udGggPSBbMzEsIDI4LCAzMSwgMzAsIDMxLCAzMCwgMzEsIDMxLCAzMCwgMzEsIDMwLCAzMV07XHJcblx0aWYgKENhbC5Jc0xlYXBZZWFyKCkpIHtcclxuXHRcdERheXNJbk1vbnRoWzFdID0gMjk7XHJcblx0fVxyXG5cclxuXHRyZXR1cm4gRGF5c0luTW9udGhbdGhpcy5Nb250aF07XHJcbn07XHJcblxyXG5DYWxlbmRhci5wcm90b3R5cGUuSXNMZWFwWWVhciA9IGZ1bmN0aW9uICgpIHtcclxuXHRpZiAoKHRoaXMuWWVhciAlIDQpID09PSAwKVxyXG5cdHtcclxuXHRcdGlmICgodGhpcy5ZZWFyICUgMTAwID09PSAwKSAmJiAodGhpcy5ZZWFyICUgNDAwKSAhPT0gMClcclxuXHRcdHtcclxuXHRcdFx0cmV0dXJuIGZhbHNlO1xyXG5cdFx0fVxyXG5cdFx0ZWxzZVxyXG5cdFx0e1xyXG5cdFx0XHRyZXR1cm4gdHJ1ZTtcclxuXHRcdH1cclxuXHR9XHJcblx0ZWxzZVxyXG5cdHtcclxuXHRcdHJldHVybiBmYWxzZTtcclxuXHR9XHJcbn07XHJcblxyXG5DYWxlbmRhci5wcm90b3R5cGUuRm9ybWF0RGF0ZSA9IGZ1bmN0aW9uIChwRGF0ZSkge1xyXG5cdHZhciBNb250aERpZ2l0ID0gdGhpcy5Nb250aCArIDE7XHJcblx0aWYgKFByZWNlZGVaZXJvID09PSB0cnVlKVxyXG5cdHtcclxuXHRcdGlmICgocERhdGUgPCAxMCkgJiYgU3RyaW5nKHBEYXRlKS5sZW5ndGg9PT0xKSAvL2xlbmd0aCBjaGVja2luZyBhZGRlZCBpbiB2ZXJzaW9uIDIuMlxyXG5cdFx0e1xyXG5cdFx0XHRwRGF0ZSA9IFwiMFwiICsgcERhdGU7XHJcblx0XHR9XHJcblx0XHRpZiAoTW9udGhEaWdpdCA8IDEwKVxyXG5cdFx0e1xyXG5cdFx0XHRNb250aERpZ2l0ID0gXCIwXCIgKyBNb250aERpZ2l0O1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0c3dpdGNoICh0aGlzLkZvcm1hdC50b1VwcGVyQ2FzZSgpKVxyXG5cdHtcclxuXHRcdGNhc2UgXCJERE1NWVlZWVwiOlxyXG5cdFx0XHRyZXR1cm4gKHBEYXRlICsgRGF0ZVNlcGFyYXRvciArIE1vbnRoRGlnaXQgKyBEYXRlU2VwYXJhdG9yICsgdGhpcy5ZZWFyKTtcclxuXHRcdGNhc2UgXCJERE1NTVlZWVlcIjpcclxuXHRcdFx0cmV0dXJuIChwRGF0ZSArIERhdGVTZXBhcmF0b3IgKyB0aGlzLkdldE1vbnRoTmFtZShmYWxzZSkgKyBEYXRlU2VwYXJhdG9yICsgdGhpcy5ZZWFyKTtcclxuXHRcdGNhc2UgXCJNTUREWVlZWVwiOlxyXG5cdFx0XHRyZXR1cm4gKE1vbnRoRGlnaXQgKyBEYXRlU2VwYXJhdG9yICsgcERhdGUgKyBEYXRlU2VwYXJhdG9yICsgdGhpcy5ZZWFyKTtcclxuXHRcdGNhc2UgXCJNTU1ERFlZWVlcIjpcclxuXHRcdFx0cmV0dXJuICh0aGlzLkdldE1vbnRoTmFtZShmYWxzZSkgKyBEYXRlU2VwYXJhdG9yICsgcERhdGUgKyBEYXRlU2VwYXJhdG9yICsgdGhpcy5ZZWFyKTtcclxuXHRcdGNhc2UgXCJZWVlZTU1ERFwiOlxyXG5cdFx0XHRyZXR1cm4gKHRoaXMuWWVhciArIERhdGVTZXBhcmF0b3IgKyBNb250aERpZ2l0ICsgRGF0ZVNlcGFyYXRvciArIHBEYXRlKTtcclxuXHRcdGNhc2UgXCJZWU1NRERcIjpcclxuXHRcdFx0cmV0dXJuIChTdHJpbmcodGhpcy5ZZWFyKS5zdWJzdHJpbmcoMiwgNCkgKyBEYXRlU2VwYXJhdG9yICsgTW9udGhEaWdpdCArIERhdGVTZXBhcmF0b3IgKyBwRGF0ZSk7XHJcblx0XHRjYXNlIFwiWVlNTU1ERFwiOlxyXG5cdFx0XHRyZXR1cm4gKFN0cmluZyh0aGlzLlllYXIpLnN1YnN0cmluZygyLCA0KSArIERhdGVTZXBhcmF0b3IgKyB0aGlzLkdldE1vbnRoTmFtZShmYWxzZSkgKyBEYXRlU2VwYXJhdG9yICsgcERhdGUpO1xyXG5cdFx0Y2FzZSBcIllZWVlNTU1ERFwiOlxyXG5cdFx0XHRyZXR1cm4gKHRoaXMuWWVhciArIERhdGVTZXBhcmF0b3IgKyB0aGlzLkdldE1vbnRoTmFtZShmYWxzZSkgKyBEYXRlU2VwYXJhdG9yICsgcERhdGUpO1xyXG5cdFx0ZGVmYXVsdDpcclxuXHRcdFx0cmV0dXJuIChwRGF0ZSArIERhdGVTZXBhcmF0b3IgKyAodGhpcy5Nb250aCArIDEpICsgRGF0ZVNlcGFyYXRvciArIHRoaXMuWWVhcik7XHJcblx0fVxyXG59O1xyXG5cclxuLy8gZW5kIENhbGVuZGFyIHByb3RvdHlwZVxyXG5cclxuZnVuY3Rpb24gR2VuQ2VsbChwVmFsdWUsIHBIaWdoTGlnaHQsIHBDb2xvciwgcENsaWNrYWJsZSkgeyAvL0dlbmVyYXRlIHRhYmxlIGNlbGwgd2l0aCB2YWx1ZVxyXG5cdHZhciBQVmFsdWUsXHJcblx0XHRQQ2VsbFN0cixcclxuXHRcdFBDbGlja2FibGUsXHJcblx0XHR2VGltZVN0cjtcclxuXHJcblx0aWYgKCFwVmFsdWUpIHtcclxuXHRcdFBWYWx1ZSA9IFwiXCI7XHJcblx0fSBlbHNlIHtcclxuXHRcdFBWYWx1ZSA9IHBWYWx1ZTtcclxuXHR9XHJcblxyXG5cdGlmIChwQ29sb3IgPT09IHVuZGVmaW5lZClcclxuXHRcdHBDb2xvciA9IENhbEJnQ29sb3I7XHJcblxyXG5cdGlmIChwQ2xpY2thYmxlICE9PSB1bmRlZmluZWQpe1xyXG5cdFx0UENsaWNrYWJsZSA9IHBDbGlja2FibGU7XHJcblx0fSBlbHNlIHtcclxuXHRcdFBDbGlja2FibGUgPSB0cnVlO1xyXG5cdH1cclxuXHJcblx0aWYgKENhbC5TaG93VGltZSkge1xyXG5cdFx0dlRpbWVTdHIgPSAnICcgKyBDYWwuSG91cnMgKyAnOicgKyBDYWwuTWludXRlcztcclxuXHRcdGlmIChDYWwuU2hvd1NlY29uZHMpXHJcblx0XHR7XHJcblx0XHRcdHZUaW1lU3RyICs9ICc6JyArIENhbC5TZWNvbmRzO1xyXG5cdFx0fVxyXG5cdFx0aWYgKFRpbWVNb2RlID09PSAxMilcclxuXHRcdHtcclxuXHRcdFx0dlRpbWVTdHIgKz0gJyAnICsgQ2FsLkFNb3JQTTtcclxuXHRcdH1cclxuXHR9IGVsc2Uge1xyXG5cdFx0dlRpbWVTdHIgPSBcIlwiO1xyXG5cdH1cclxuXHJcblx0aWYgKFBWYWx1ZSAhPT0gXCJcIikge1xyXG5cdFx0aWYgKFBDbGlja2FibGUgPT09IHRydWUpIHtcclxuXHRcdFx0aWYgKENhbC5TaG93VGltZSA9PT0gdHJ1ZSkge1xyXG5cdFx0XHRcdFBDZWxsU3RyID0gXCI8dGQgaWQ9J2NcIiArXHJcblx0XHRcdFx0XHRQVmFsdWUgK1xyXG5cdFx0XHRcdFx0XCInIGNsYXNzPSdjYWxURCcgc3R5bGU9J3RleHQtYWxpZ246Y2VudGVyO2N1cnNvcjpwb2ludGVyO1wiICtcclxuXHRcdFx0XHRcdHBDb2xvciArXHJcblx0XHRcdFx0XHRcIicgb25tb3VzZWRvd249J3NlbGVjdERhdGUodGhpcyxcIiArXHJcblx0XHRcdFx0XHRQVmFsdWUgK1xyXG5cdFx0XHRcdFx0XCIpOyc+XCIgK1xyXG5cdFx0XHRcdFx0UFZhbHVlICtcclxuXHRcdFx0XHRcdFwiPC90ZD5cIjtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRQQ2VsbFN0ciA9XHJcblx0XHRcdFx0XHRcIjx0ZCBjbGFzcz0nY2FsVEQnIHN0eWxlPSd0ZXh0LWFsaWduOmNlbnRlcjtjdXJzb3I6cG9pbnRlcjtiYWNrZ3JvdW5kLWNvbG9yOlwiICtcclxuXHRcdFx0XHRcdHBDb2xvciArXHJcblx0XHRcdFx0XHRcIicgb25tb3VzZW92ZXI9J2NoYW5nZUJvcmRlcih0aGlzLCAwKTsnIG9ubW91c2VvdXQ9XFxcImNoYW5nZUJvcmRlcih0aGlzLCAxLCAnXCIgK1xyXG5cdFx0XHRcdFx0cENvbG9yICtcclxuXHRcdFx0XHRcdFwiJyk7XFxcIiBvbkNsaWNrPVxcXCJqYXZhc2NyaXB0OmNhbGxiYWNrKCdcIiArXHJcblx0XHRcdFx0XHRDYWwuQ3RybCArXHJcblx0XHRcdFx0XHRcIicsJ1wiICtcclxuXHRcdFx0XHRcdENhbC5Gb3JtYXREYXRlKFBWYWx1ZSkgK1xyXG5cdFx0XHRcdFx0XCInKTtcXFwiPlwiICtcclxuXHRcdFx0XHRcdFBWYWx1ZSArXHJcblx0XHRcdFx0XHRcIjwvdGQ+XCI7XHJcblx0XHRcdH1cclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdFBDZWxsU3RyID1cclxuXHRcdFx0XHRcIjx0ZCBzdHlsZT0ndGV4dC1hbGlnbjpjZW50ZXI7YmFja2dyb3VuZC1jb2xvcjpcIiArXHJcblx0XHRcdFx0cENvbG9yICtcclxuXHRcdFx0XHRcIicgY2xhc3M9J2NhbFREJz5cIiArXHJcblx0XHRcdFx0UFZhbHVlICtcclxuXHRcdFx0XHRcIjwvdGQ+XCI7XHJcblx0XHR9XHJcblx0fSBlbHNlIHtcclxuXHRcdFBDZWxsU3RyID1cclxuXHRcdFx0XCI8dGQgc3R5bGU9J3RleHQtYWxpZ246Y2VudGVyO2JhY2tncm91bmQtY29sb3I6XCIgK1xyXG5cdFx0XHRwQ29sb3IgK1xyXG5cdFx0XHRcIicgY2xhc3M9J2NhbFREJz4mbmJzcDs8L3RkPlwiO1xyXG5cdH1cclxuXHJcblx0cmV0dXJuIFBDZWxsU3RyO1xyXG59XHJcblxyXG5mdW5jdGlvbiBSZW5kZXJDc3NDYWwoYk5ld0NhbCkge1xyXG5cdGlmICh0eXBlb2YgYk5ld0NhbCA9PT0gXCJ1bmRlZmluZWRcIiB8fCBiTmV3Q2FsICE9PSB0cnVlKVxyXG5cdHtcclxuXHRcdGJOZXdDYWwgPSBmYWxzZTtcclxuXHR9XHJcblx0dmFyIHZDYWxIZWFkZXIsXHJcblx0XHR2Q2FsRGF0YSxcclxuXHRcdHZDYWxUaW1lID0gXCJcIixcclxuXHRcdHZDYWxDbG9zaW5nID0gXCJcIixcclxuXHRcdHdpbkNhbERhdGEgPSBcIlwiLFxyXG5cdFx0Q2FsRGF0ZSxcclxuXHJcblx0XHRpLFxyXG5cdFx0aixcclxuXHJcblx0XHRTZWxlY3RTdHIsXHJcblx0XHR2RGF5Q291bnQgPSAwLFxyXG5cdFx0dkZpcnN0RGF5LFxyXG5cclxuXHRcdFdlZWtEYXlOYW1lID0gW10sLy9BZGRlZCB2ZXJzaW9uIDEuN1xyXG5cdFx0c3RyQ2VsbCxcclxuXHJcblx0XHRzaG93SG91cixcclxuXHRcdFNob3dBcnJvd3MgPSBmYWxzZSxcclxuXHRcdEhvdXJDZWxsV2lkdGggPSBcIjM1cHhcIiwgLy9jZWxsIHdpZHRoIHdpdGggc2Vjb25kcy5cclxuXHJcblx0XHRTZWxlY3RBbSxcclxuXHRcdFNlbGVjdFBtLFxyXG5cclxuXHRcdGZ1bmNDYWxiYWNrLFxyXG5cclxuXHRcdGhlYWRJRCxcclxuXHRcdGUsXHJcblx0XHRjc3NTdHIsXHJcblx0XHRzdHlsZSxcclxuXHRcdGNzc1RleHQsXHJcblx0XHRzcGFuO1xyXG5cclxuXHRjYWxIZWlnaHQgPSAwOyAvLyByZXNldCB0aGUgd2luZG93IGhlaWdodCBvbiByZWZyZXNoXHJcblxyXG5cdC8vIFNldCB0aGUgZGVmYXVsdCBjdXJzb3IgZm9yIHRoZSBjYWxlbmRhclxyXG5cclxuXHR3aW5DYWxEYXRhID0gXCI8c3BhbiBzdHlsZT0nY3Vyc29yOmF1dG87Jz5cIjtcclxuXHR2Q2FsSGVhZGVyID0gXCI8dGFibGUgc3R5bGU9J2JhY2tncm91bmQtY29sb3I6XCIrQ2FsQmdDb2xvcitcIjt3aWR0aDphdXRvO3BhZGRpbmc6MDtib3JkZXI6bm9uZTsnPjx0Ym9keT5cIjtcclxuXHJcblx0Ly9UYWJsZSBmb3IgTW9udGggJiBZZWFyIFNlbGVjdG9yXHJcblxyXG5cdHZDYWxIZWFkZXIgKz0gXCI8dHI+PHRkIGNvbHNwYW49JzcnPjx0YWJsZSBib3JkZXI9JzAnIHdpZHRoPScxMDAlJyBjZWxscGFkZGluZz0nMCcgY2VsbHNwYWNpbmc9JzAnIHN0eWxlPSdib3JkZXI6bm9uZTtwYWRkaW5nOjVweDsnPjx0cj5cIjtcclxuXHQvLyoqKioqKioqKioqKioqKioqKk1vbnRoIGFuZCBZZWFyIHNlbGVjdG9yIGluIGRyb3Bkb3duIGxpc3QqKioqKioqKioqKioqKioqKioqKioqKipcclxuXHJcblx0aWYgKENhbC5TY3JvbGxlciA9PT0gXCJEUk9QRE9XTlwiKVxyXG5cdHtcclxuXHRcdHZDYWxIZWFkZXIgKz0gXCI8dGQgYWxpZ249J2xlZnQnIHN0eWxlPSdwYWRkaW5nOjEwcHggNXB4IDEwcHggMTBweDttYXJnaW46MDtiYWNrZ3JvdW5kOlwiK3RvcFNlbGVjdG9yQmcrXCInPlxcblwiO1xyXG5cdFx0dkNhbEhlYWRlciArPSBcIjxzZWxlY3QgbmFtZT0nTW9udGhTZWxlY3RvcicgaWQ9J01vbnRoU2VsZWN0b3JTZWxlY3QnIHN0eWxlPSdtYXJnaW4tYm90dG9tOjVweDsgZGlzcGxheTogbm9uZTsnIG9uQ2hhbmdlPSdqYXZhc2NyaXB0OkNhbC5Td2l0Y2hNdGgodGhpcy5zZWxlY3RlZEluZGV4KTtSZW5kZXJDc3NDYWwoKTsnPlwiO1xyXG5cdFx0Zm9yIChpID0gMDsgaSA8IDEyOyBpICs9IDEpXHJcblx0XHR7XHJcblx0XHRcdGlmIChpID09PSBDYWwuTW9udGgpXHJcblx0XHRcdHtcclxuXHRcdFx0XHRTZWxlY3RTdHIgPSBcIlNlbGVjdGVkXCI7XHJcblx0XHRcdH1cclxuXHRcdFx0ZWxzZVxyXG5cdFx0XHR7XHJcblx0XHRcdFx0U2VsZWN0U3RyID0gXCJcIjtcclxuXHRcdFx0fVxyXG5cdFx0XHR2Q2FsSGVhZGVyICs9IFwiPG9wdGlvbiBcIiArIFNlbGVjdFN0ciArIFwiIHZhbHVlPVwiICsgaSArIFwiPlwiICsgTW9udGhOYW1lW2ldICsgXCI8L29wdGlvbj5cIjtcclxuXHRcdH1cclxuXHRcdHZDYWxIZWFkZXIgKz0gJzwvc2VsZWN0Pic7XHJcblxyXG5cdFx0LyogdWwgbW9udGggZm9yIGN1c3RvbSBzZWxlY3QgKi9cclxuXHRcdHZDYWxIZWFkZXIgKz0gJzxzcGFuIGNsYXNzPVwiTW9udGhTZWxlY3RvclRpdGxlXCI+JyArICBNb250aE5hbWVbQ2FsLk1vbnRoXSArICc8L3NwYW4+JztcclxuXHRcdHZDYWxIZWFkZXIgKz0gJzx1bCBuYW1lPVwiTW9udGhTZWxlY3RvclwiIGNsYXNzPVwiTW9udGhTZWxlY3RvclwiIG9uQ2hhbmdlPVwiamF2YXNjcmlwdDpDYWwuU3dpdGNoTXRoKHRoaXMuc2VsZWN0ZWRJbmRleCk7UmVuZGVyQ3NzQ2FsKCk7XCI+JztcclxuXHRcdGZvciAoaSA9IDA7IGkgPCAxMjsgaSArPSAxKVxyXG5cdFx0e1xyXG5cdFx0XHRpZiAoaSA9PT0gQ2FsLk1vbnRoKVxyXG5cdFx0XHR7XHJcblx0XHRcdFx0U2VsZWN0U3RyID0gXCJTZWxlY3RlZFwiO1xyXG5cdFx0XHR9XHJcblx0XHRcdGVsc2VcclxuXHRcdFx0e1xyXG5cdFx0XHRcdFNlbGVjdFN0ciA9IFwiXCI7XHJcblx0XHRcdH1cclxuXHRcdFx0dkNhbEhlYWRlciArPSAnPGxpPicgKyBNb250aE5hbWVbaV0gKyAnPC9saT4nO1xyXG5cdFx0fVxyXG5cdFx0dkNhbEhlYWRlciArPSBcIjwvdWw+XCI7XHJcblx0XHR2Q2FsSGVhZGVyICs9IFwiPC90ZD5cIjtcclxuXHRcdC8vWWVhciBzZWxlY3RvclxyXG5cclxuXHRcdHZDYWxIZWFkZXIgKz0gXCI8dGQgYWxpZ249J3JpZ2h0JyBzdHlsZT0ncGFkZGluZzoxMHB4IDEwcHggMTBweCA1cHg7bWFyZ2luOjA7YmFja2dyb3VuZDpcIit0b3BTZWxlY3RvckJnK1wiJz5cIjtcclxuXHRcdHZDYWxIZWFkZXIgKz0gXCI8c2VsZWN0IG5hbWU9J1llYXJTZWxlY3Rvcicgc3R5bGU9J2Rpc3BsYXk6bm9uZTsgbWFyZ2luLWJvdHRvbTo1cHg7JyBzaXplPScxJyBvbkNoYW5nZT0namF2YXNjcmlwdDpDYWwuU3dpdGNoWWVhcih0aGlzLnZhbHVlKTtSZW5kZXJDc3NDYWwoKTsnPlwiO1xyXG5cdFx0Zm9yIChpID0gU3RhcnRZZWFyOyBpIDw9IChkdFRvZGF5LmdldEZ1bGxZZWFyKCkgKyBFbmRZZWFyKTsgaSArPSAxKVxyXG5cdFx0e1xyXG5cdFx0XHRpZiAoaSA9PT0gQ2FsLlllYXIpXHJcblx0XHRcdHtcclxuXHRcdFx0XHRTZWxlY3RTdHIgPSAnc2VsZWN0ZWQ9XCJzZWxlY3RlZFwiJztcclxuXHRcdFx0fVxyXG5cdFx0XHRlbHNlXHJcblx0XHRcdHtcclxuXHRcdFx0XHRTZWxlY3RTdHIgPSAnJztcclxuXHRcdFx0fVxyXG5cdFx0XHR2Q2FsSGVhZGVyICs9IFwiPG9wdGlvbiBcIiArIFNlbGVjdFN0ciArIFwiIHZhbHVlPVwiICsgaSArIFwiPlwiICsgaSArIFwiPC9vcHRpb24+XFxuXCI7XHJcblx0XHR9XHJcblx0XHR2Q2FsSGVhZGVyICs9IFwiPC9zZWxlY3Q+XCI7XHJcblxyXG5cdFx0LyogdWwgeWVhciBmb3IgY3VzdG9tIHNlbGVjdCAqL1xyXG5cdFx0dkNhbEhlYWRlciArPSAnPHNwYW4gY2xhc3M9XCJNb250aFNlbGVjdG9yVGl0bGUgWWVhclwiPicgKyBDYWwuWWVhciArICc8L3NwYW4+JztcclxuXHRcdHZDYWxIZWFkZXIgKz0gJzx1bCBuYW1lPVwiWWVhclNlbGVjdG9yXCIgY2xhc3M9XCJNb250aFNlbGVjdG9yIFllYXJcIiBvbkNoYW5nZT1cImphdmFzY3JpcHQ6Q2FsLlN3aXRjaE10aCh0aGlzLnNlbGVjdGVkSW5kZXgpO1JlbmRlckNzc0NhbCgpO1wiPic7XHJcblx0XHRmb3IgKGkgPSBTdGFydFllYXI7IGkgPD0gKGR0VG9kYXkuZ2V0RnVsbFllYXIoKSArIEVuZFllYXIpOyBpICs9IDEpXHJcblx0XHR7XHJcblx0XHRcdGlmIChpID09PSBDYWwuWWVhcilcclxuXHRcdFx0e1xyXG5cdFx0XHRcdFNlbGVjdFN0ciA9ICdzZWxlY3RlZD1cInNlbGVjdGVkXCInO1xyXG5cdFx0XHR9XHJcblx0XHRcdGVsc2VcclxuXHRcdFx0e1xyXG5cdFx0XHRcdFNlbGVjdFN0ciA9ICcnO1xyXG5cdFx0XHR9XHJcblx0XHRcdHZDYWxIZWFkZXIgKz0gJzxsaT4nICsgaSArICc8L2xpPic7XHJcblx0XHR9XHJcblx0XHR2Q2FsSGVhZGVyICs9IFwiPC91bD5cIjtcclxuXHRcdHZDYWxIZWFkZXIgKz0gXCI8L3RkPlxcblwiO1xyXG5cdFx0Y2FsSGVpZ2h0ICs9IDMwO1xyXG5cdH1cclxuXHJcblx0Ly8qKioqKioqKioqKioqKioqKipFbmQgTW9udGggYW5kIFllYXIgc2VsZWN0b3IgaW4gZHJvcGRvd24gbGlzdCoqKioqKioqKioqKioqKioqKioqKlxyXG5cclxuXHQvLyoqKioqKioqKioqKioqKioqKk1vbnRoIGFuZCBZZWFyIHNlbGVjdG9yIGluIGFycm93KioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcblxyXG5cdGVsc2UgaWYgKENhbC5TY3JvbGxlciA9PT0gXCJBUlJPV1wiKVxyXG5cdHtcclxuXHRcdGlmIChVc2VJbWFnZUZpbGVzKVxyXG5cdFx0e1xyXG5cdFx0XHR2Q2FsSGVhZGVyICs9IFwiPHRkPjxpbWcgb25tb3VzZWRvd249J2phdmFzY3JpcHQ6Q2FsLkRlY1llYXIoKTtSZW5kZXJDc3NDYWwoKTsnIHNyYz0nXCIraW1hZ2VGaWxlc1BhdGgrXCJjYWxfZmFzdHJldmVyc2UuZ2lmJyB3aWR0aD0nMTNweCcgaGVpZ2h0PSc5JyBvbm1vdXNlb3Zlcj0nY2hhbmdlQm9yZGVyKHRoaXMsIDApJyBvbm1vdXNlb3V0PSdjaGFuZ2VCb3JkZXIodGhpcywgMSknIHN0eWxlPSdib3JkZXI6MXB4IHNvbGlkIHdoaXRlJz48L3RkPlxcblwiOy8vWWVhciBzY3JvbGxlciAoZGVjcmVhc2UgMSB5ZWFyKVxyXG5cdFx0XHR2Q2FsSGVhZGVyICs9IFwiPHRkPjxpbWcgb25tb3VzZWRvd249J2phdmFzY3JpcHQ6Q2FsLkRlY01vbnRoKCk7UmVuZGVyQ3NzQ2FsKCk7JyBzcmM9J1wiICsgaW1hZ2VGaWxlc1BhdGggKyBcImNhbF9yZXZlcnNlLmdpZicgd2lkdGg9JzEzcHgnIGhlaWdodD0nOScgb25tb3VzZW92ZXI9J2NoYW5nZUJvcmRlcih0aGlzLCAwKScgb25tb3VzZW91dD0nY2hhbmdlQm9yZGVyKHRoaXMsIDEpJyBzdHlsZT0nYm9yZGVyOjFweCBzb2xpZCB3aGl0ZSc+PC90ZD5cXG5cIjsgLy9Nb250aCBzY3JvbGxlciAoZGVjcmVhc2UgMSBtb250aClcclxuXHRcdFx0dkNhbEhlYWRlciArPSBcIjx0ZCB3aWR0aD0nNzAlJyBjbGFzcz0nY2FsUicgc3R5bGU9J2NvbG9yOlwiK1lyU2VsQ29sb3IrXCInPlwiKyBDYWwuR2V0TW9udGhOYW1lKFNob3dMb25nTW9udGgpICsgXCIgXCIgKyBDYWwuWWVhciArIFwiPC90ZD5cIjsgLy9Nb250aCBhbmQgWWVhclxyXG5cdFx0XHR2Q2FsSGVhZGVyICs9IFwiPHRkPjxpbWcgb25tb3VzZWRvd249J2phdmFzY3JpcHQ6Q2FsLkluY01vbnRoKCk7UmVuZGVyQ3NzQ2FsKCk7JyBzcmM9J1wiICsgaW1hZ2VGaWxlc1BhdGggKyBcImNhbF9mb3J3YXJkLmdpZicgd2lkdGg9JzEzcHgnIGhlaWdodD0nOScgb25tb3VzZW92ZXI9J2NoYW5nZUJvcmRlcih0aGlzLCAwKScgb25tb3VzZW91dD0nY2hhbmdlQm9yZGVyKHRoaXMsIDEpJyBzdHlsZT0nYm9yZGVyOjFweCBzb2xpZCB3aGl0ZSc+PC90ZD5cXG5cIjsgLy9Nb250aCBzY3JvbGxlciAoaW5jcmVhc2UgMSBtb250aClcclxuXHRcdFx0dkNhbEhlYWRlciArPSBcIjx0ZD48aW1nIG9ubW91c2Vkb3duPSdqYXZhc2NyaXB0OkNhbC5JbmNZZWFyKCk7UmVuZGVyQ3NzQ2FsKCk7JyBzcmM9J1wiICsgaW1hZ2VGaWxlc1BhdGggKyBcImNhbF9mYXN0Zm9yd2FyZC5naWYnIHdpZHRoPScxM3B4JyBoZWlnaHQ9JzknIG9ubW91c2VvdmVyPSdjaGFuZ2VCb3JkZXIodGhpcywgMCknIG9ubW91c2VvdXQ9J2NoYW5nZUJvcmRlcih0aGlzLCAxKScgc3R5bGU9J2JvcmRlcjoxcHggc29saWQgd2hpdGUnPjwvdGQ+XFxuXCI7IC8vWWVhciBzY3JvbGxlciAoaW5jcmVhc2UgMSB5ZWFyKVxyXG5cdFx0XHRjYWxIZWlnaHQgKz0gMjI7XHJcblx0XHR9XHJcblx0XHRlbHNlXHJcblx0XHR7XHJcblx0XHRcdHZDYWxIZWFkZXIgKz0gXCI8dGQ+PHNwYW4gaWQ9J2RlY195ZWFyJyB0aXRsZT0ncmV2ZXJzZSB5ZWFyJyBvbm1vdXNlZG93bj0namF2YXNjcmlwdDpDYWwuRGVjWWVhcigpO1JlbmRlckNzc0NhbCgpOycgb25tb3VzZW92ZXI9J2NoYW5nZUJvcmRlcih0aGlzLCAwKScgb25tb3VzZW91dD0nY2hhbmdlQm9yZGVyKHRoaXMsIDEpJyBzdHlsZT0nYm9yZGVyOjFweCBzb2xpZCB3aGl0ZTsgY29sb3I6XCIgKyBZclNlbENvbG9yICsgXCInPi08L3NwYW4+PC90ZD5cIjsvL1llYXIgc2Nyb2xsZXIgKGRlY3JlYXNlIDEgeWVhcilcclxuXHRcdFx0dkNhbEhlYWRlciArPSBcIjx0ZD48c3BhbiBpZD0nZGVjX21vbnRoJyB0aXRsZT0ncmV2ZXJzZSBtb250aCcgb25tb3VzZWRvd249J2phdmFzY3JpcHQ6Q2FsLkRlY01vbnRoKCk7UmVuZGVyQ3NzQ2FsKCk7JyBvbm1vdXNlb3Zlcj0nY2hhbmdlQm9yZGVyKHRoaXMsIDApJyBvbm1vdXNlb3V0PSdjaGFuZ2VCb3JkZXIodGhpcywgMSknIHN0eWxlPSdib3JkZXI6MXB4IHNvbGlkIHdoaXRlJz4mbHQ7PC9zcGFuPjwvdGQ+XFxuXCI7Ly9Nb250aCBzY3JvbGxlciAoZGVjcmVhc2UgMSBtb250aClcclxuXHRcdFx0dkNhbEhlYWRlciArPSBcIjx0ZCB3aWR0aD0nNzAlJyBjbGFzcz0nY2FsUicgc3R5bGU9J2NvbG9yOlwiICsgWXJTZWxDb2xvciArIFwiJz5cIiArIENhbC5HZXRNb250aE5hbWUoU2hvd0xvbmdNb250aCkgKyBcIiBcIiArIENhbC5ZZWFyICsgXCI8L3RkPlxcblwiOyAvL01vbnRoIGFuZCBZZWFyXHJcblx0XHRcdHZDYWxIZWFkZXIgKz0gXCI8dGQ+PHNwYW4gaWQ9J2luY19tb250aCcgdGl0bGU9J2ZvcndhcmQgbW9udGgnIG9ubW91c2Vkb3duPSdqYXZhc2NyaXB0OkNhbC5JbmNNb250aCgpO1JlbmRlckNzc0NhbCgpOycgb25tb3VzZW92ZXI9J2NoYW5nZUJvcmRlcih0aGlzLCAwKScgb25tb3VzZW91dD0nY2hhbmdlQm9yZGVyKHRoaXMsIDEpJyBzdHlsZT0nYm9yZGVyOjFweCBzb2xpZCB3aGl0ZSc+Jmd0Ozwvc3Bhbj48L3RkPlxcblwiOy8vTW9udGggc2Nyb2xsZXIgKGluY3JlYXNlIDEgbW9udGgpXHJcblx0XHRcdHZDYWxIZWFkZXIgKz0gXCI8dGQ+PHNwYW4gaWQ9J2luY195ZWFyJyB0aXRsZT0nZm9yd2FyZCB5ZWFyJyBvbm1vdXNlZG93bj0namF2YXNjcmlwdDpDYWwuSW5jWWVhcigpO1JlbmRlckNzc0NhbCgpOycgIG9ubW91c2VvdmVyPSdjaGFuZ2VCb3JkZXIodGhpcywgMCknIG9ubW91c2VvdXQ9J2NoYW5nZUJvcmRlcih0aGlzLCAxKScgc3R5bGU9J2JvcmRlcjoxcHggc29saWQgd2hpdGU7IGNvbG9yOlwiICsgWXJTZWxDb2xvciArIFwiJz4rPC9zcGFuPjwvdGQ+XFxuXCI7Ly9ZZWFyIHNjcm9sbGVyIChpbmNyZWFzZSAxIHllYXIpXHJcblx0XHRcdGNhbEhlaWdodCArPSAyMjtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdHZDYWxIZWFkZXIgKz0gXCI8L3RyPjwvdGFibGU+PC90ZD48L3RyPlwiO1xyXG5cclxuXHQvLyoqKioqKioqKioqKioqKioqKkVuZCBNb250aCBhbmQgWWVhciBzZWxlY3RvciBpbiBhcnJvdyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG5cclxuXHQvL0NhbGVuZGFyIGhlYWRlciBzaG93cyBNb250aCBhbmQgWWVhclxyXG5cdGlmIChTaG93TW9udGhZZWFyICYmIENhbC5TY3JvbGxlciA9PT0gXCJEUk9QRE9XTlwiKVxyXG5cdHtcclxuXHRcdHZDYWxIZWFkZXIgKz0gXCI8dHI+PHRkIGNvbHNwYW49JzcnIGNsYXNzPSdjYWxSJyBzdHlsZT0nY29sb3I6XCIgKyBNb250aFllYXJDb2xvciArIFwiJz5cIiArIENhbC5HZXRNb250aE5hbWUoU2hvd0xvbmdNb250aCkgKyBcIiBcIiArIENhbC5ZZWFyICsgXCI8L3RkPjwvdHI+XCI7XHJcblx0XHRjYWxIZWlnaHQgKz0gMTk7XHJcblx0fVxyXG5cclxuXHQvL1dlZWsgZGF5IGhlYWRlclxyXG5cclxuXHR2Q2FsSGVhZGVyICs9IFwiPHRyPjx0ZCBjb2xzcGFuPVxcXCI3XFxcIj48dGFibGUgc3R5bGU9J2JvcmRlci1zcGFjaW5nOjA7Ym9yZGVyLWNvbGxhcHNlOmNvbGxhcHNlO2JveC1zaXppbmc6Ym9yZGVyLWJveDsgbWFyZ2luOiA1cHggNXB4IDVweCA0cHg7Jz48dHI+XCI7XHJcblx0aWYgKE1vbmRheUZpcnN0RGF5ID09PSB0cnVlKVxyXG5cdHtcclxuXHRcdFdlZWtEYXlOYW1lID0gV2Vla0RheU5hbWUyO1xyXG5cdH1cclxuXHRlbHNlXHJcblx0e1xyXG5cdFx0V2Vla0RheU5hbWUgPSBXZWVrRGF5TmFtZTE7XHJcblx0fVxyXG5cdGZvciAoaSA9IDA7IGkgPCA3OyBpICs9IDEpXHJcblx0e1xyXG5cdFx0dkNhbEhlYWRlciArPSBcIjx0ZCBzdHlsZT0nYmFja2dyb3VuZC1jb2xvcjpcIitXZWVrSGVhZEJhY2tncm91bmQrXCI7d2lkdGg6XCIrQ2VsbFdpZHRoK1wicHg7Y29sb3I6XCIrV2Vla0hlYWRDb2xvcitcIicgY2xhc3M9J2NhbFREJz5cIiArIFdlZWtEYXlOYW1lW2ldLnN1YnN0cigwLCBXZWVrQ2hhcikgKyBcIjwvdGQ+XCI7XHJcblx0fVxyXG5cclxuXHRjYWxIZWlnaHQgKz0gMTk7XHJcblx0dkNhbEhlYWRlciArPSBcIjwvdHI+XCI7XHJcblx0Ly9DYWxlbmRhciBkZXRhaWxcclxuXHRDYWxEYXRlID0gbmV3IERhdGUoQ2FsLlllYXIsIENhbC5Nb250aCk7XHJcblx0Q2FsRGF0ZS5zZXREYXRlKDEpO1xyXG5cclxuXHR2Rmlyc3REYXkgPSBDYWxEYXRlLmdldERheSgpO1xyXG5cclxuXHQvL0FkZGVkIHZlcnNpb24gMS43XHJcblx0aWYgKE1vbmRheUZpcnN0RGF5ID09PSB0cnVlKVxyXG5cdHtcclxuXHRcdHZGaXJzdERheSAtPSAxO1xyXG5cdFx0aWYgKHZGaXJzdERheSA9PT0gLTEpXHJcblx0XHR7XHJcblx0XHRcdHZGaXJzdERheSA9IDY7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHQvL0FkZGVkIHZlcnNpb24gMS43XHJcblx0dkNhbERhdGEgPSBcIjx0cj5cIjtcclxuXHRjYWxIZWlnaHQgKz0gMTk7XHJcblx0Zm9yIChpID0gMDsgaSA8IHZGaXJzdERheTsgaSArPSAxKVxyXG5cdHtcclxuXHRcdHZDYWxEYXRhID0gdkNhbERhdGEgKyBHZW5DZWxsKCk7XHJcblx0XHR2RGF5Q291bnQgPSB2RGF5Q291bnQgKyAxO1xyXG5cdH1cclxuXHJcblx0Ly9BZGRlZCB2ZXJzaW9uIDEuN1xyXG5cdGZvciAoaiA9IDE7IGogPD0gQ2FsLkdldE1vbkRheXMoKTsgaiArPSAxKVxyXG5cdHtcclxuXHRcdGlmICgodkRheUNvdW50ICUgNyA9PT0gMCkgJiYgKGogPiAxKSlcclxuXHRcdHtcclxuXHRcdFx0dkNhbERhdGEgPSB2Q2FsRGF0YSArIFwiPHRyPlwiO1xyXG5cdFx0fVxyXG5cclxuXHRcdHZEYXlDb3VudCA9IHZEYXlDb3VudCArIDE7XHJcblx0XHQvL2FkZGVkIHZlcnNpb24gMi4xLjJcclxuXHRcdGlmIChDYWwuRW5hYmxlRGF0ZU1vZGUgPT09IFwiZnV0dXJlXCIgJiYgKChqIDwgZHRUb2RheS5nZXREYXRlKCkpICYmIChDYWwuTW9udGggPT09IGR0VG9kYXkuZ2V0TW9udGgoKSkgJiYgKENhbC5ZZWFyID09PSBkdFRvZGF5LmdldEZ1bGxZZWFyKCkpIHx8IChDYWwuTW9udGggPCBkdFRvZGF5LmdldE1vbnRoKCkpICYmIChDYWwuWWVhciA9PT0gZHRUb2RheS5nZXRGdWxsWWVhcigpKSB8fCAoQ2FsLlllYXIgPCBkdFRvZGF5LmdldEZ1bGxZZWFyKCkpKSlcclxuXHRcdHtcclxuXHRcdFx0c3RyQ2VsbCA9IEdlbkNlbGwoaiwgZmFsc2UsIERpc2FibGVDb2xvciwgZmFsc2UpOyAvL0JlZm9yZSB0b2RheSdzIGRhdGUgaXMgbm90IGNsaWNrYWJsZVxyXG5cdFx0fVxyXG5cdFx0ZWxzZSBpZiAoQ2FsLkVuYWJsZURhdGVNb2RlID09PSBcInBhc3RcIiAmJiAoKGogPj0gZHRUb2RheS5nZXREYXRlKCkpICYmIChDYWwuTW9udGggPT09IGR0VG9kYXkuZ2V0TW9udGgoKSkgJiYgKENhbC5ZZWFyID09PSBkdFRvZGF5LmdldEZ1bGxZZWFyKCkpIHx8IChDYWwuTW9udGggPiBkdFRvZGF5LmdldE1vbnRoKCkpICYmIChDYWwuWWVhciA9PT0gZHRUb2RheS5nZXRGdWxsWWVhcigpKSB8fCAoQ2FsLlllYXIgPiBkdFRvZGF5LmdldEZ1bGxZZWFyKCkpKSkge1xyXG5cdFx0XHRzdHJDZWxsID0gR2VuQ2VsbChqLCBmYWxzZSwgRGlzYWJsZUNvbG9yLCBmYWxzZSk7IC8vQWZ0ZXIgdG9kYXkncyBkYXRlIGlzIG5vdCBjbGlja2FibGVcclxuXHRcdH1cclxuXHRcdC8vaWYgRW5kIFllYXIgKyBDdXJyZW50IFllYXIgPSBDYWwuWWVhci4gRGlzYWJsZS5cclxuXHRcdGVsc2UgaWYgKENhbC5ZZWFyID4gKGR0VG9kYXkuZ2V0RnVsbFllYXIoKStFbmRZZWFyKSlcclxuXHRcdHtcclxuXHRcdFx0c3RyQ2VsbCA9IEdlbkNlbGwoaiwgZmFsc2UsIERpc2FibGVDb2xvciwgZmFsc2UpO1xyXG5cdFx0fVxyXG5cdFx0ZWxzZSBpZiAoKGogPT09IGR0VG9kYXkuZ2V0RGF0ZSgpKSAmJiAoQ2FsLk1vbnRoID09PSBkdFRvZGF5LmdldE1vbnRoKCkpICYmIChDYWwuWWVhciA9PT0gZHRUb2RheS5nZXRGdWxsWWVhcigpKSlcclxuXHRcdHtcclxuXHRcdFx0c3RyQ2VsbCA9IEdlbkNlbGwoaiwgdHJ1ZSwgVG9kYXlDb2xvcik7Ly9IaWdobGlnaHQgdG9kYXkncyBkYXRlXHJcblx0XHR9XHJcblx0XHRlbHNlXHJcblx0XHR7XHJcblx0XHRcdGlmICgoaiA9PT0gc2VsRGF0ZS5nZXREYXRlKCkpICYmIChDYWwuTW9udGggPT09IHNlbERhdGUuZ2V0TW9udGgoKSkgJiYgKENhbC5ZZWFyID09PSBzZWxEYXRlLmdldEZ1bGxZZWFyKCkpKXtcclxuXHRcdFx0XHQvL21vZGlmaWVkIHZlcnNpb24gMS43XHJcblx0XHRcdFx0c3RyQ2VsbCA9IEdlbkNlbGwoaiwgdHJ1ZSwgU2VsRGF0ZUNvbG9yKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRlbHNlXHJcblx0XHRcdHtcclxuXHRcdFx0XHRpZiAoTW9uZGF5Rmlyc3REYXkgPT09IHRydWUpXHJcblx0XHRcdFx0e1xyXG5cdFx0XHRcdFx0aWYgKHZEYXlDb3VudCAlIDcgPT09IDApXHJcblx0XHRcdFx0XHR7XHJcblx0XHRcdFx0XHRcdHN0ckNlbGwgPSBHZW5DZWxsKGosIGZhbHNlLCBTdW5kYXlDb2xvcik7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRlbHNlIGlmICgodkRheUNvdW50ICsgMSkgJSA3ID09PSAwKVxyXG5cdFx0XHRcdFx0e1xyXG5cdFx0XHRcdFx0XHRzdHJDZWxsID0gR2VuQ2VsbChqLCBmYWxzZSwgU2F0dXJkYXlDb2xvcik7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRlbHNlXHJcblx0XHRcdFx0XHR7XHJcblx0XHRcdFx0XHRcdHN0ckNlbGwgPSBHZW5DZWxsKGosIG51bGwsIFdlZWtEYXlDb2xvcik7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGVsc2VcclxuXHRcdFx0XHR7XHJcblx0XHRcdFx0XHRpZiAodkRheUNvdW50ICUgNyA9PT0gMClcclxuXHRcdFx0XHRcdHtcclxuXHRcdFx0XHRcdFx0c3RyQ2VsbCA9IEdlbkNlbGwoaiwgZmFsc2UsIFNhdHVyZGF5Q29sb3IpO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0ZWxzZSBpZiAoKHZEYXlDb3VudCArIDYpICUgNyA9PT0gMClcclxuXHRcdFx0XHRcdHtcclxuXHRcdFx0XHRcdFx0c3RyQ2VsbCA9IEdlbkNlbGwoaiwgZmFsc2UsIFN1bmRheUNvbG9yKTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdGVsc2VcclxuXHRcdFx0XHRcdHtcclxuXHRcdFx0XHRcdFx0c3RyQ2VsbCA9IEdlbkNlbGwoaiwgbnVsbCwgV2Vla0RheUNvbG9yKTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHR2Q2FsRGF0YSA9IHZDYWxEYXRhICsgc3RyQ2VsbDtcclxuXHJcblx0XHRpZiAoKHZEYXlDb3VudCAlIDcgPT09IDApICYmIChqIDwgQ2FsLkdldE1vbkRheXMoKSkpXHJcblx0XHR7XHJcblx0XHRcdHZDYWxEYXRhID0gdkNhbERhdGEgKyBcIjwvdHI+XCI7XHJcblx0XHRcdGNhbEhlaWdodCArPSAxOTtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdC8vIGZpbmlzaCB0aGUgdGFibGUgcHJvcGVyXHJcblxyXG5cdGlmICh2RGF5Q291bnQgJSA3ICE9PSAwKVxyXG5cdHtcclxuXHRcdHdoaWxlICh2RGF5Q291bnQgJSA3ICE9PSAwKVxyXG5cdFx0e1xyXG5cdFx0XHR2Q2FsRGF0YSA9IHZDYWxEYXRhICsgR2VuQ2VsbCgpO1xyXG5cdFx0XHR2RGF5Q291bnQgPSB2RGF5Q291bnQgKyAxO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0dkNhbERhdGEgPSB2Q2FsRGF0YSArIFwiPC90YWJsZT48L3RkPjwvdHI+XCI7XHJcblxyXG5cclxuXHQvL1RpbWUgcGlja2VyXHJcblx0aWYgKENhbC5TaG93VGltZSA9PT0gdHJ1ZSlcclxuXHR7XHJcblx0XHRzaG93SG91ciA9IENhbC5nZXRTaG93SG91cigpO1xyXG5cclxuXHRcdGlmIChDYWwuU2hvd1NlY29uZHMgPT09IGZhbHNlICYmIFRpbWVNb2RlID09PSAyNClcclxuXHRcdHtcclxuXHRcdFx0U2hvd0Fycm93cyA9IHRydWU7XHJcblx0XHRcdEhvdXJDZWxsV2lkdGggPSBcIjEwcHhcIjtcclxuXHRcdH1cclxuXHJcblx0XHR2Q2FsVGltZSA9IFwiPHRyPjx0ZCBjb2xzcGFuPSc3JyBzdHlsZT1cXFwidGV4dC1hbGlnbjpjZW50ZXI7XFxcIj48dGFibGUgYm9yZGVyPScwJyB3aWR0aD0nMTAwJScgY2VsbHBhZGRpbmc9JzAnIGNlbGxzcGFjaW5nPScwJz48dGJvZHk+PHRyPjx0ZCBoZWlnaHQ9JzVweCcgd2lkdGg9J1wiICsgSG91ckNlbGxXaWR0aCArIFwiJz4mbmJzcDs8L3RkPlwiO1xyXG5cclxuXHRcdGlmIChTaG93QXJyb3dzICYmIFVzZUltYWdlRmlsZXMpIC8vdGhpcyBpcyB3aGVyZSB0aGUgdXAgYW5kIGRvd24gYXJyb3cgY29udHJvbCB0aGUgaG91ci5cclxuXHRcdHtcclxuXHRcdFx0dkNhbFRpbWUgKz0gXCI8dGQgc3R5bGU9J3ZlcnRpY2FsLWFsaWduOm1pZGRsZTsnPjx0YWJsZSBjZWxsc3BhY2luZz0nMCcgY2VsbHBhZGRpbmc9JzAnIHN0eWxlPSdsaW5lLWhlaWdodDowcHQ7d2lkdGg6MTAwJTsnPjx0cj48dGQgc3R5bGU9J3RleHQtYWxpZ246Y2VudGVyOyc+PGltZyBvbmNsaWNrPSduZXh0U3RlcChcXFwiSG91clxcXCIsIFxcXCJwbHVzXFxcIik7JyBvbm1vdXNlZG93bj0nc3RhcnRTcGluKFxcXCJIb3VyXFxcIiwgXFxcInBsdXNcXFwiKTsnIG9ubW91c2V1cD0nc3RvcFNwaW4oKTsnIHNyYz0nXCIgKyBpbWFnZUZpbGVzUGF0aCArIFwiY2FsX3BsdXMuZ2lmJyB3aWR0aD0nMTNweCcgaGVpZ2h0PSc5cHgnIG9ubW91c2VvdmVyPSdjaGFuZ2VCb3JkZXIodGhpcywgMCknIG9ubW91c2VvdXQ9J2NoYW5nZUJvcmRlcih0aGlzLCAxKScgc3R5bGU9J2JvcmRlcjoxcHggc29saWQgd2hpdGUnPjwvdGQ+PC90cj48dHI+PHRkIHN0eWxlPSd0ZXh0LWFsaWduOmNlbnRlcjsnPjxpbWcgb25jbGljaz0nbmV4dFN0ZXAoXFxcIkhvdXJcXFwiLCBcXFwibWludXNcXFwiKTsnIG9ubW91c2Vkb3duPSdzdGFydFNwaW4oXFxcIkhvdXJcXFwiLCBcXFwibWludXNcXFwiKTsnIG9ubW91c2V1cD0nc3RvcFNwaW4oKTsnIHNyYz0nXCIgKyBpbWFnZUZpbGVzUGF0aCArIFwiY2FsX21pbnVzLmdpZicgd2lkdGg9JzEzcHgnIGhlaWdodD0nOXB4JyBvbm1vdXNlb3Zlcj0nY2hhbmdlQm9yZGVyKHRoaXMsIDApJyBvbm1vdXNlb3V0PSdjaGFuZ2VCb3JkZXIodGhpcywgMSknIHN0eWxlPSdib3JkZXI6MXB4IHNvbGlkIHdoaXRlJz48L3RkPjwvdHI+PC90YWJsZT48L3RkPlxcblwiO1xyXG5cdFx0fVxyXG5cclxuXHRcdHZDYWxUaW1lICs9IFwiPHRkIHN0eWxlPSdib3JkZXItdG9wOjFweCBzb2xpZCAjYjdjOWQzOyc+PGlucHV0IHR5cGU9J3RleHQnIG5hbWU9J2hvdXInIG1heGxlbmd0aD0yIHNpemU9MSBzdHlsZT0nd2lkdGg6YXV0bztwYWRkaW5nOjVweCAxMHB4O21hcmdpbjoxMHB4IGF1dG87ZmxvYXQ6cmlnaHQ7JyB2YWx1ZT1cIiArIHNob3dIb3VyICsgXCIgb25rZXl1cD1cXFwiamF2YXNjcmlwdDpDYWwuU2V0SG91cih0aGlzLnZhbHVlKVxcXCI+XCI7XHJcblx0XHR2Q2FsVGltZSArPSBcIjwvdGQ+PHRkIHN0eWxlPSdmb250LXdlaWdodDpib2xkO3RleHQtYWxpZ246Y2VudGVyO3BhZGRpbmc6MCAzcHg7Ym9yZGVyLXRvcDoxcHggc29saWQgI2I3YzlkMzsnPjo8L3RkPjx0ZCBzdHlsZT0nYm9yZGVyLXRvcDoxcHggc29saWQgI2I3YzlkMzsnPlwiO1xyXG5cdFx0dkNhbFRpbWUgKz0gXCI8aW5wdXQgdHlwZT0ndGV4dCcgbmFtZT0nbWludXRlJyBtYXhsZW5ndGg9MiBzaXplPTEgc3R5bGU9J2JvcmRlci10b3A6MXB4IHNvbGlkICNiN2M5ZDM7IHdpZHRoOmF1dG87cGFkZGluZzo1cHggMTBweDttYXJnaW46MCBhdXRvO2Zsb2F0OmxlZnQ7JyB2YWx1ZT1cIiArIENhbC5NaW51dGVzICsgXCIgb25rZXl1cD1cXFwiamF2YXNjcmlwdDpDYWwuU2V0TWludXRlKHRoaXMudmFsdWUpXFxcIj5cIjtcclxuXHJcblx0XHRpZiAoQ2FsLlNob3dTZWNvbmRzKVxyXG5cdFx0e1xyXG5cdFx0XHR2Q2FsVGltZSArPSBcIjwvdGQ+PHRkIHN0eWxlPSdmb250LXdlaWdodDpib2xkO2JvcmRlci10b3A6MXB4IHNvbGlkICNiN2M5ZDM7Jz46PC90ZD48dGQgc3R5bGU9J2JvcmRlci10b3A6MXB4IHNvbGlkICNiN2M5ZDM7Jz5cIjtcclxuXHRcdFx0dkNhbFRpbWUgKz0gXCI8aW5wdXQgdHlwZT0ndGV4dCcgbmFtZT0nc2Vjb25kJyBtYXhsZW5ndGg9MiBzaXplPTEgc3R5bGU9J3dpZHRoOmF1dG87cGFkZGluZzo1cHggMTBweDttYXJnaW46MCBhdXRvO2Zsb2F0OmxlZnQ7JyB2YWx1ZT1cIiArIENhbC5TZWNvbmRzICsgXCIgb25rZXl1cD1cXFwiamF2YXNjcmlwdDpDYWwuU2V0U2Vjb25kKHBhcnNlSW50KHRoaXMudmFsdWUsMTApKVxcXCI+XCI7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKFRpbWVNb2RlID09PSAxMilcclxuXHRcdHtcclxuXHRcdFx0U2VsZWN0QW0gPSAoQ2FsLkFNb3JQTSA9PT0gXCJBTVwiKSA/IFwiU2VsZWN0ZWRcIiA6IFwiXCI7XHJcblx0XHRcdFNlbGVjdFBtID0gKENhbC5BTW9yUE0gPT09IFwiUE1cIikgPyBcIlNlbGVjdGVkXCIgOiBcIlwiO1xyXG5cclxuXHRcdFx0dkNhbFRpbWUgKz0gXCI8L3RkPjx0ZD5cIjtcclxuXHRcdFx0dkNhbFRpbWUgKz0gXCI8c2VsZWN0IG5hbWU9XFxcImFtcG1cXFwiIG9uQ2hhbmdlPVxcXCJqYXZhc2NyaXB0OkNhbC5TZXRBbVBtKHRoaXMub3B0aW9uc1t0aGlzLnNlbGVjdGVkSW5kZXhdLnZhbHVlKTtcXFwiPlxcblwiO1xyXG5cdFx0XHR2Q2FsVGltZSArPSBcIjxvcHRpb24gXCIgKyBTZWxlY3RBbSArIFwiIHZhbHVlPVxcXCJBTVxcXCI+QU08L29wdGlvbj5cIjtcclxuXHRcdFx0dkNhbFRpbWUgKz0gXCI8b3B0aW9uIFwiICsgU2VsZWN0UG0gKyBcIiB2YWx1ZT1cXFwiUE1cXFwiPlBNPG9wdGlvbj5cIjtcclxuXHRcdFx0dkNhbFRpbWUgKz0gXCI8L3NlbGVjdD5cIjtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoU2hvd0Fycm93cyAmJiBVc2VJbWFnZUZpbGVzKSAvL3RoaXMgaXMgd2hlcmUgdGhlIHVwIGFuZCBkb3duIGFycm93IHRvIGNoYW5nZSB0aGUgXCJNaW51dGVcIi5cclxuXHRcdHtcclxuXHRcdFx0dkNhbFRpbWUgKz0gXCI8L3RkPlxcbjx0ZCBzdHlsZT0ndmVydGljYWwtYWxpZ246bWlkZGxlOyc+PHRhYmxlIGNlbGxzcGFjaW5nPScwJyBjZWxscGFkZGluZz0nMCcgc3R5bGU9J2xpbmUtaGVpZ2h0OjBwdDt3aWR0aDoxMDAlJz48dHI+PHRkIHN0eWxlPSd0ZXh0LWFsaWduOmNlbnRlcjsnPjxpbWcgb25jbGljaz0nbmV4dFN0ZXAoXFxcIk1pbnV0ZVxcXCIsIFxcXCJwbHVzXFxcIik7JyBvbm1vdXNlZG93bj0nc3RhcnRTcGluKFxcXCJNaW51dGVcXFwiLCBcXFwicGx1c1xcXCIpOycgb25tb3VzZXVwPSdzdG9wU3BpbigpOycgc3JjPSdcIiArIGltYWdlRmlsZXNQYXRoICsgXCJjYWxfcGx1cy5naWYnIHdpZHRoPScxM3B4JyBoZWlnaHQ9JzlweCcgb25tb3VzZW92ZXI9J2NoYW5nZUJvcmRlcih0aGlzLCAwKScgb25tb3VzZW91dD0nY2hhbmdlQm9yZGVyKHRoaXMsIDEpJyBzdHlsZT0nYm9yZGVyOjFweCBzb2xpZCB3aGl0ZSc+PC90ZD48L3RyPjx0cj48dGQgc3R5bGU9J3RleHQtYWxpZ246Y2VudGVyOyc+PGltZyBvbm1vdXNlZG93bj0nc3RhcnRTcGluKFxcXCJNaW51dGVcXFwiLCBcXFwibWludXNcXFwiKTsnIG9ubW91c2V1cD0nc3RvcFNwaW4oKTsnIG9uY2xpY2s9J25leHRTdGVwKFxcXCJNaW51dGVcXFwiLFxcXCJtaW51c1xcXCIpOycgc3JjPSdcIiArIGltYWdlRmlsZXNQYXRoICsgXCJjYWxfbWludXMuZ2lmJyB3aWR0aD0nMTNweCcgaGVpZ2h0PSc5cHgnIG9ubW91c2VvdmVyPSdjaGFuZ2VCb3JkZXIodGhpcywgMCknIG9ubW91c2VvdXQ9J2NoYW5nZUJvcmRlcih0aGlzLCAxKScgc3R5bGU9J2JvcmRlcjoxcHggc29saWQgd2hpdGUnPjwvdGQ+PC90cj48L3RhYmxlPlwiO1xyXG5cdFx0fVxyXG5cclxuXHRcdHZDYWxUaW1lICs9IFwiPC90ZD5cXG48dGQgYWxpZ249J3JpZ2h0JyB2YWxpZ249J2JvdHRvbScgd2lkdGg9J1wiICsgSG91ckNlbGxXaWR0aCArIFwicHgnPjwvdGQ+PC90cj5cIjtcclxuXHRcdHZDYWxUaW1lICs9IFwiPHRyPjx0ZCBoZWlnaHQ9JzVweCcgd2lkdGg9J1wiICsgSG91ckNlbGxXaWR0aCArIFwiJz4mbmJzcDs8L3RkPjx0ZCBjb2xzcGFuPSczJyBzdHlsZT0ndGV4dC1hbGlnbjpjZW50ZXI7Ym9yZGVyLXRvcDoxcHggc29saWQgI2I3YzlkMzsnPjxpbnB1dCBvbkNsaWNrPSdqYXZhc2NyaXB0OmNsb3Nld2luKFxcXCJcIiArIENhbC5DdHJsICsgXCJcXFwiKTsnICB0eXBlPVxcXCJidXR0b25cXFwiIHZhbHVlPVxcXCJPS1xcXCI+Jm5ic3A7PGlucHV0IG9uQ2xpY2s9J2phdmFzY3JpcHQ6d2luY2xvc2UoKScgdHlwZT1cXFwiYnV0dG9uXFxcIiB2YWx1ZT1cXFwiQ2FuY2VsXFxcIj48L3RkPjx0ZCBoZWlnaHQ9JzVweCcgd2lkdGg9J1wiICsgSG91ckNlbGxXaWR0aCArIFwiJz4mbmJzcDs8L3RkPjwvdHI+XCI7XHJcblx0fVxyXG5cdGVsc2UgLy9pZiBub3QgdG8gc2hvdyB0aW1lLlxyXG5cdHtcclxuXHRcdHZDYWxUaW1lICs9IFwiXFxuPHRyPlxcbjx0ZCBjb2xzcGFuPSc3JyBzdHlsZT1cXFwidGV4dC1hbGlnbjpyaWdodDtcXFwiPlwiO1xyXG5cdFx0Ly9jbG9zZSBidXR0b25cclxuXHRcdGlmIChVc2VJbWFnZUZpbGVzKSB7XHJcblx0XHRcdHZDYWxDbG9zaW5nICs9IFwiPGltZyBvbm1vdXNlZG93bj0namF2YXNjcmlwdDpjbG9zZXdpbihcXFwiXCIgKyBDYWwuQ3RybCArIFwiXFxcIik7IHN0b3BTcGluKCk7JyBzcmM9J1wiK2ltYWdlRmlsZXNQYXRoK1wiY2FsX2Nsb3NlLmdpZicgd2lkdGg9JzE2cHgnIGhlaWdodD0nMTRweCcgb25tb3VzZW92ZXI9J2NoYW5nZUJvcmRlcih0aGlzLDApJyBvbm1vdXNlb3V0PSdjaGFuZ2VCb3JkZXIodGhpcywgMSknIHN0eWxlPSdib3JkZXI6MXB4IHNvbGlkIHdoaXRlJz48L3RkPlwiO1xyXG5cdFx0fVxyXG5cdFx0ZWxzZSB7XHJcblx0XHRcdHZDYWxDbG9zaW5nICs9IFwiPHNwYW4gaWQ9J2Nsb3NlX2NhbCcgdGl0bGU9J2Nsb3NlJ29ubW91c2Vkb3duPSdqYXZhc2NyaXB0OmNsb3Nld2luKFxcXCJcIiArIENhbC5DdHJsICsgXCJcXFwiKTtzdG9wU3BpbigpOycgb25tb3VzZW92ZXI9J2NoYW5nZUJvcmRlcih0aGlzLCAwKSdvbm1vdXNlb3V0PSdjaGFuZ2VCb3JkZXIodGhpcywgMSknIHN0eWxlPSdib3JkZXI6MXB4IHNvbGlkIHdoaXRlOyBmb250LWZhbWlseTogQXJpYWw7Zm9udC1zaXplOiAxMHB0Oyc+eDwvc3Bhbj48L3RkPlwiO1xyXG5cdFx0fVxyXG5cdFx0dkNhbENsb3NpbmcgKz0gXCI8L3RyPlwiO1xyXG5cdH1cclxuXHR2Q2FsQ2xvc2luZyArPSBcIjwvdGJvZHk+PC90YWJsZT48L3RkPjwvdHI+XCI7XHJcblx0Y2FsSGVpZ2h0ICs9IDMxO1xyXG5cdHZDYWxDbG9zaW5nICs9IFwiPC90Ym9keT48L3RhYmxlPlxcbjwvc3Bhbj5cIjtcclxuXHJcblx0Ly9lbmQgdGltZSBwaWNrZXJcclxuXHRmdW5jQ2FsYmFjayA9IFwiZnVuY3Rpb24gY2FsbGJhY2soaWQsIGRhdHVtKSB7XCI7XHJcblx0ZnVuY0NhbGJhY2sgKz0gXCIgdmFyIENhbElkID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoaWQpO2lmIChkYXR1bT09PSAndW5kZWZpbmVkJykgeyB2YXIgZCA9IG5ldyBEYXRlKCk7IGRhdHVtID0gZC5nZXREYXRlKCkgKyAnLycgKyhkLmdldE1vbnRoKCkrMSkgKyAnLycgKyBkLmdldEZ1bGxZZWFyKCk7IH0gd2luZG93LmNhbERhdHVtPWRhdHVtO0NhbElkLnZhbHVlPWRhdHVtO1wiO1xyXG5cdGZ1bmNDYWxiYWNrICs9IFwiIGlmKENhbC5TaG93VGltZSl7XCI7XHJcblx0ZnVuY0NhbGJhY2sgKz0gXCIgQ2FsSWQudmFsdWUrPSdUJytDYWwuZ2V0U2hvd0hvdXIoKSsnOicrQ2FsLk1pbnV0ZXMrJzowMFonO1wiO1xyXG5cdGZ1bmNDYWxiYWNrICs9IFwiIGlmIChDYWwuU2hvd1NlY29uZHMpICBDYWxJZC52YWx1ZSs9JzonK0NhbC5TZWNvbmRzO1wiO1xyXG5cdGZ1bmNDYWxiYWNrICs9IFwiIGlmIChUaW1lTW9kZSA9PT0gMTIpICBDYWxJZC52YWx1ZSs9JycrQ2FsLmdldFNob3dBTW9yUE0oKTtcIjtcclxuXHRmdW5jQ2FsYmFjayArPSBcIn1pZihDYWxJZC5vbmNoYW5nZSE9dW5kZWZpbmVkKSBDYWxJZC5vbmNoYW5nZSgpO0NhbElkLmZvY3VzKCk7d2luQ2FsLnN0eWxlLnZpc2liaWxpdHk9J2hpZGRlbic7ICQoQ2FsSWQpLnRyaWdnZXIoJ2NoYW5nZScpfVwiO1xyXG5cclxuXHJcblx0Ly8gZGV0ZXJtaW5lcyBpZiB0aGVyZSBpcyBlbm91Z2ggc3BhY2UgdG8gb3BlbiB0aGUgY2FsIGFib3ZlIHRoZSBwb3NpdGlvbiB3aGVyZSBpdCBpcyBjYWxsZWRcclxuXHRpZiAoeXBvcyA+IGNhbEhlaWdodClcclxuXHR7XHJcblx0XHR5cG9zID0geXBvcyAtIGNhbEhlaWdodDtcclxuXHR9XHJcblxyXG5cdGlmICghd2luQ2FsKVxyXG5cdHtcclxuXHRcdGhlYWRJRCA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiaGVhZFwiKVswXTtcclxuXHJcblx0XHQvLyBhZGQgamF2YXNjcmlwdCBmdW5jdGlvbiB0byB0aGUgc3BhbiBjYWxcclxuXHRcdGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic2NyaXB0XCIpO1xyXG5cdFx0ZS50eXBlID0gXCJ0ZXh0L2phdmFzY3JpcHRcIjtcclxuXHRcdGUubGFuZ3VhZ2UgPSBcImphdmFzY3JpcHRcIjtcclxuXHRcdGUudGV4dCA9IGZ1bmNDYWxiYWNrO1xyXG5cdFx0aGVhZElELmFwcGVuZENoaWxkKGUpO1xyXG5cdFx0Ly8gYWRkIHN0eWxlc2hlZXQgdG8gdGhlIHNwYW4gY2FsXHJcblxyXG5cdFx0Y3NzU3RyID0gXCIuY2FsVEQge3RleHQtYWxpZ246IGNlbnRlcjsgYm9yZGVyOjA7IHdpZHRoOjM2cHg7IGhlaWdodDozNnB4OyBib3JkZXItcmFkaXVzOjUwJX1cXG5cIjtcclxuXHRcdGNzc1N0ciArPSBcIiNjYWxCb3JkZXIge2ZvbnQtc2l6ZTogMTRweDsgYm9yZGVyLXJhZGl1czowcHggMHB4IDRweCA0cHh9XFxuXCI7XHJcblx0XHRjc3NTdHIgKz0gXCIuY2FsUiB7dGV4dC1hbGlnbjogY2VudGVyOyBmb250LXdlaWdodDogYm9sZDtcIitzaG93TW9udGhJbkhlYWQrXCJ9XFxuXCI7XHJcblx0XHRjc3NTdHIgKz0gXCIjY2FsQm9yZGVyIHRhYmxlLCAjY2FsQm9yZGVyIHRhYmxlIHRoLCAjY2FsQm9yZGVyIHRhYmxlIHRkIHttYXJnaW46MDsgcGFkZGluZzowOyBib3JkZXItc3BhY2luZzowOyBib3JkZXItY29sbGFwc2U6Y29sbGFwc2U7IGJvcmRlcjowOyBib3gtc2l6aW5nOmJvcmRlci1ib3g7IC13ZWJraXQtdXNlci1zZWxlY3Q6IG5vbmU7IC1tb3otdXNlci1zZWxlY3Q6IG5vbmU7IC1tcy11c2VyLXNlbGVjdDogbm9uZTsgdXNlci1zZWxlY3Q6IG5vbmU7fVxcblwiO1xyXG5cdFx0Y3NzU3RyICs9IFwiI2NhbEJvcmRlciBpbnB1dCwgI2NhbEJvcmRlciBzZWxlY3Qge2hlaWdodDphdXRvO31cXG5cIjtcclxuXHRcdGNzc1N0ciArPSBcIiNjYWxCb3JkZXIgc2VsZWN0IHsgLXdlYmtpdC1hcHBlYXJhbmNlOiBtZW51bGlzdDsgLW1vei1hcHBlYXJhbmNlOiBtZW51bGlzdDt9XFxuXCI7XHJcblx0XHRjc3NTdHIgKz0gXCIjY2FsQm9yZGVyIHRhYmxlIHRyOm50aC1jaGlsZChldmVuKSB7YmFja2dyb3VuZDogbm9uZTt9XFxuXCI7XHJcblx0XHRjc3NTdHIgKz0gJyNjYWxCb3JkZXIgaW5wdXRbdHlwZT1cImJ1dHRvblwiXSwgI2NhbEJvcmRlcmlucHV0W3R5cGU9XCJyZXNldFwiXSwgI2NhbEJvcmRlciBpbnB1dFt0eXBlPVwic3VibWl0XCJdIHttYXJnaW4tdG9wOiAxNXB4OyBmb250LWZhbWlseTpcIlRNU2Fucy1Cb2xkXCIsSGVsdmV0aWNhLEFyaWFsLHNhbnMtc2VyaWY7IGZvbnQtc2l6ZToxMnB4OyB3aWR0aDo0NSU7IGJvcmRlcjoycHggc29saWQgI2I3YzlkMzsgYm9yZGVyLXJhZGl1czo0cHg7IHRleHQtdHJhbnNmb3JtOnVwcGVyY2FzZTsgY29sb3I6I2I3YzlkMzsgcGFkZGluZzo0cHg7IG1hcmdpbi1ib3R0b206MTJweDt9XFxuJztcclxuXHRcdGNzc1N0ciArPSAnI2NhbEJvcmRlciAuTW9udGhTZWxlY3RvclRpdGxlIHtwb3NpdGlvbjogcmVsYXRpdmU7IGZvbnQtZmFtaWx5OiBcIlRNU2Fucy1Cb2xkXCIsIEFyaWFsLCBzZXJpZjsgZm9udC1zaXplOiAxNHB4OyBjb2xvcjogI2I3YzlkMzsgZGlzcGxheTogYmxvY2s7IGZsb2F0OiBsZWZ0OyBtYXJnaW4tbGVmdDogNXB4OyBwYWRkaW5nLXJpZ2h0OjI0cHg7IC13ZWJraXQtdHJhbnNpdGlvbjogY29sb3IgMC4zcyBlYXNlLWluLW91dDsgLW8tdHJhbnNpdGlvbjogY29sb3IgMC4zcyBlYXNlLWluLW91dDsgdHJhbnNpdGlvbjogY29sb3IgMC4zcyBlYXNlLWluLW91dDsgLXdlYmtpdC11c2VyLXNlbGVjdDogbm9uZTsgLW1vei11c2VyLXNlbGVjdDogbm9uZTsgLW1zLXVzZXItc2VsZWN0OiBub25lOyB1c2VyLXNlbGVjdDogbm9uZTt9XFxuJztcclxuXHRcdGNzc1N0ciArPSAnI2NhbEJvcmRlciAuTW9udGhTZWxlY3RvclRpdGxlOmhvdmVyIHtjb2xvcjogIzE4OWRkYzsgY3Vyc29yOiBwb2ludGVyO31cXG4nO1xyXG5cdFx0Y3NzU3RyICs9ICcjY2FsQm9yZGVyIC5Nb250aFNlbGVjdG9yVGl0bGU6aG92ZXI6YmVmb3JlIHtvcGFjaXR5OjE7fVxcbic7XHJcblx0XHRjc3NTdHIgKz0gJyNjYWxCb3JkZXIgLk1vbnRoU2VsZWN0b3JUaXRsZTpob3ZlcjphZnRlciB7b3BhY2l0eTowO31cXG4nO1xyXG5cdFx0Y3NzU3RyICs9ICcjY2FsQm9yZGVyIC5Nb250aFNlbGVjdG9yVGl0bGU6aG92ZXI6YWZ0ZXIge2NvbG9yOiAjMTg5ZGRjOyBjdXJzb3I6IHBvaW50ZXI7fVxcbic7XHJcblx0XHRjc3NTdHIgKz0gJyNjYWxCb3JkZXIgLk1vbnRoU2VsZWN0b3JUaXRsZS5ZZWFyIHtmbG9hdDogcmlnaHQ7fVxcbic7XHJcblx0XHRjc3NTdHIgKz0gJyNjYWxCb3JkZXIgLk1vbnRoU2VsZWN0b3JUaXRsZTpiZWZvcmUsICNjYWxCb3JkZXIgLk1vbnRoU2VsZWN0b3JUaXRsZTphZnRlciB7Y29udGVudDogXCJcIjsgcG9zaXRpb246IGFic29sdXRlOyByaWdodDogMDsgdG9wOiA1MCU7IHdpZHRoOiAxNXB4OyBoZWlnaHQ6IDEwcHg7IG1hcmdpbi10b3A6IC01cHg7IGJhY2tncm91bmQtcG9zaXRpb246IGNlbnRlciBjZW50ZXI7IGJhY2tncm91bmQtcmVwZWF0OiBuby1yZXBlYXQ7IC13ZWJraXQtdHJhbnNpdGlvbjogb3BhY2l0eSAwLjJzIGVhc2UtaW4tb3V0OyAtby10cmFuc2l0aW9uOiBvcGFjaXR5IDAuMnMgZWFzZS1pbi1vdXQ7IHRyYW5zaXRpb246IG9wYWNpdHkgMC4ycyBlYXNlLWluLW91dDt9XFxuJztcclxuXHRcdGNzc1N0ciArPSAnI2NhbEJvcmRlciAuTW9udGhTZWxlY3RvclRpdGxlOmJlZm9yZSB7b3BhY2l0eTowOyBiYWNrZ3JvdW5kOiB1cmwoXCJodHRwOi8vZGV2ZWxvcGVyLnRpY2tldG1hc3Rlci5jb20vYXNzZXRzL3dpZGdldHMvMS4wLjAvaW1nL3NtYWxsLXNoZXZyb24taG92ZXIuc3ZnXCIpIGNlbnRlciBjZW50ZXIgbm8tcmVwZWF0O1xcbn0nO1xyXG5cdFx0Y3NzU3RyICs9ICcjY2FsQm9yZGVyIC5Nb250aFNlbGVjdG9yVGl0bGU6YWZ0ZXIge2JhY2tncm91bmQ6IHVybChcImh0dHA6Ly9kZXZlbG9wZXIudGlja2V0bWFzdGVyLmNvbS9hc3NldHMvd2lkZ2V0cy8xLjAuMC9pbWcvc21hbGwtc2hldnJvbi5zdmdcIikgY2VudGVyIGNlbnRlciBuby1yZXBlYXQ7fVxcbic7XHJcblx0XHRjc3NTdHIgKz0gJyNjYWxCb3JkZXIgdWwuTW9udGhTZWxlY3RvciB7ZGlzcGxheTogbm9uZTsgYmFja2dyb3VuZDojYjdjOWQyOyBtYXJnaW4tYm90dG9tOjVweDsgZm9udC1mYW1pbHk6IFwiVE1TYW5zLUJvbGRcIiwgQXJpYWwsIHNlcmlmOyBmb250LXNpemU6IDE0cHg7IHBhZGRpbmc6IDEwcHggMTVweDsgbWFyZ2luOjA7IHRvcDozNXB4OyBsZWZ0OjA7IHBvc2l0aW9uOiBhYnNvbHV0ZTt9XFxuJztcclxuXHRcdGNzc1N0ciArPSAnI2NhbEJvcmRlciB1bC5Nb250aFNlbGVjdG9yLnNob3cge2Rpc3BsYXk6IGJsb2NrO31cXG4nO1xyXG5cdFx0Y3NzU3RyICs9ICcjY2FsQm9yZGVyIHVsLk1vbnRoU2VsZWN0b3IuWWVhciB7bGVmdDphdXRvOyByaWdodDowOyBwYWRkaW5nOiAxMHB4IDM0cHg7fVxcbic7XHJcblx0XHRjc3NTdHIgKz0gJyNjYWxCb3JkZXIgdWwuTW9udGhTZWxlY3Rvci5ZZWFyLnNob3cge2Rpc3BsYXk6IGJsb2NrO31cXG4nO1xyXG5cdFx0Y3NzU3RyICs9ICcjY2FsQm9yZGVyIHVsLk1vbnRoU2VsZWN0b3IgbGkgeyBmb250LWZhbWlseTogXCJUTVNhbnMtQm9sZFwiLCBBcmlhbCwgc2VyaWY7IGZvbnQtc2l6ZTogMTRweDsgbWFyZ2luOjA7IHBhZGRpbmc6MDsgbGluZS1oZWlnaHQ6MjdweDsgY29sb3I6ICNmZmY7IC13ZWJraXQtdXNlci1zZWxlY3Q6IG5vbmU7IC1tb3otdXNlci1zZWxlY3Q6IG5vbmU7IC1tcy11c2VyLXNlbGVjdDogbm9uZTsgdXNlci1zZWxlY3Q6IG5vbmU7fVxcbic7XHJcblx0XHRjc3NTdHIgKz0gJyNjYWxCb3JkZXIgdWwuTW9udGhTZWxlY3RvciBsaTpob3ZlciB7Y29sb3I6ICMxODlkZGM7IGN1cnNvcjogcG9pbnRlcjt9XFxuJztcclxuXHRcdGNzc1N0ciArPSAnI2NhbE92ZXJsYXkge3dpZHRoOiAxMDAlOyBoZWlnaHQ6IDEwMCU7IHBvc2l0aW9uOiBmaXhlZDsgdG9wOiAwOyBsZWZ0OiAwOyBkaXNwbGF5OiBub25lO31cXG4nO1xyXG5cdFx0Y3NzU3RyICs9ICcjY2FsT3ZlcmxheS5zaG93IHtkaXNwbGF5OiBibG9jazt9XFxuJztcclxuXHJcblx0XHRzdHlsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzdHlsZVwiKTtcclxuXHRcdHN0eWxlLnR5cGUgPSBcInRleHQvY3NzXCI7XHJcblx0XHRzdHlsZS5yZWwgPSBcInN0eWxlc2hlZXRcIjtcclxuXHRcdGlmIChzdHlsZS5zdHlsZVNoZWV0KVxyXG5cdFx0eyAvLyBJRVxyXG5cdFx0XHRzdHlsZS5zdHlsZVNoZWV0LmNzc1RleHQgPSBjc3NTdHI7XHJcblx0XHR9XHJcblxyXG5cdFx0ZWxzZVxyXG5cdFx0eyAvLyB3M2NcclxuXHRcdFx0Y3NzVGV4dCA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGNzc1N0cik7XHJcblx0XHRcdHN0eWxlLmFwcGVuZENoaWxkKGNzc1RleHQpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGhlYWRJRC5hcHBlbmRDaGlsZChzdHlsZSk7XHJcblx0XHQvLyBjcmVhdGUgdGhlIG91dGVyIGZyYW1lIHRoYXQgYWxsb3dzIHRoZSBjYWwuIHRvIGJlIG1vdmVkXHJcblx0XHRzcGFuID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNwYW5cIik7XHJcblx0XHRzcGFuLmlkID0gY2FsU3BhbklEO1xyXG5cdFx0c3Bhbi5zdHlsZS5wb3NpdGlvbiA9IFwiYWJzb2x1dGVcIjtcclxuXHRcdHNwYW4uc3R5bGUubGVmdCA9ICh4cG9zICsgQ2FsUG9zT2Zmc2V0WCkgKyAncHgnO1xyXG5cdFx0c3Bhbi5zdHlsZS50b3AgPSAoeXBvcyAtIENhbFBvc09mZnNldFkpICsgJ3B4JztcclxuXHRcdHNwYW4uc3R5bGUud2lkdGggPSBDYWxXaWR0aCArICdweCc7XHJcblx0XHRzcGFuLnN0eWxlLmJvcmRlciA9IFwic29saWQgMXB4IFwiICsgU3BhbkJvcmRlckNvbG9yO1xyXG5cdFx0c3Bhbi5zdHlsZS5wYWRkaW5nID0gXCIwXCI7XHJcblx0XHRzcGFuLnN0eWxlLmN1cnNvciA9IFwibW92ZVwiO1xyXG5cdFx0c3Bhbi5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSBTcGFuQmdDb2xvcjtcclxuXHRcdHNwYW4uc3R5bGUuekluZGV4ID0gMTtcclxuXHRcdHZhciBvdmVybGF5ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcclxuXHRcdG92ZXJsYXkuaWQgPSBcImNhbE92ZXJsYXlcIjtcclxuXHRcdG92ZXJsYXkuY2xhc3NMaXN0LmFkZChcInNob3dcIik7XHJcblx0XHRkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHNwYW4pO1xyXG5cdFx0ZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChvdmVybGF5KTtcclxuXHRcdHdpbkNhbCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGNhbFNwYW5JRCk7XHJcblx0fVxyXG5cclxuXHRlbHNlXHJcblx0e1xyXG5cdFx0d2luQ2FsLnN0eWxlLnZpc2liaWxpdHkgPSBcInZpc2libGVcIjtcclxuXHRcdHdpbkNhbC5zdHlsZS5IZWlnaHQgPSBjYWxIZWlnaHQ7XHJcblxyXG5cdFx0Ly8gc2V0IHRoZSBwb3NpdGlvbiBmb3IgYSBuZXcgY2FsZW5kYXIgb25seVxyXG5cdFx0aWYgKGJOZXdDYWwgPT09IHRydWUpXHJcblx0XHR7XHJcblx0XHRcdHdpbkNhbC5zdHlsZS5sZWZ0ID0gKHhwb3MgKyBDYWxQb3NPZmZzZXRYKSArICdweCc7XHJcblx0XHRcdHdpbkNhbC5zdHlsZS50b3AgPSAoeXBvcyAtIENhbFBvc09mZnNldFkpICsgJ3B4JztcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdHdpbkNhbC5pbm5lckhUTUwgPSB3aW5DYWxEYXRhICsgdkNhbEhlYWRlciArIHZDYWxEYXRhICsgdkNhbFRpbWUgKyB2Q2FsQ2xvc2luZztcclxuXHRyZXR1cm4gdHJ1ZTtcclxufVxyXG5cclxuZnVuY3Rpb24gTmV3Q3NzQ2FsKHBDdHJsLCBwRm9ybWF0LCBwU2Nyb2xsZXIsIHBTaG93VGltZSwgcFRpbWVNb2RlLCBwU2hvd1NlY29uZHMsIHBFbmFibGVEYXRlTW9kZSkge1xyXG5cdC8vIGdldCBjdXJyZW50IGRhdGUgYW5kIHRpbWVcclxuXHJcblx0ZHRUb2RheSA9IG5ldyBEYXRlKCk7XHJcblx0Q2FsID0gbmV3IENhbGVuZGFyKGR0VG9kYXkpO1xyXG5cclxuXHRpZiAocFNob3dUaW1lICE9PSB1bmRlZmluZWQpIHtcclxuXHRcdGlmIChwU2hvd1RpbWUpIHtcclxuXHRcdFx0Q2FsLlNob3dUaW1lID0gdHJ1ZTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdENhbC5TaG93VGltZSA9IGZhbHNlO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChwVGltZU1vZGUpIHtcclxuXHRcdFx0cFRpbWVNb2RlID0gcGFyc2VJbnQocFRpbWVNb2RlLCAxMCk7XHJcblx0XHR9XHJcblx0XHRpZiAocFRpbWVNb2RlID09PSAxMiB8fCBwVGltZU1vZGUgPT09IDI0KSB7XHJcblx0XHRcdFRpbWVNb2RlID0gcFRpbWVNb2RlO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0VGltZU1vZGUgPSAyNDtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAocFNob3dTZWNvbmRzICE9PSB1bmRlZmluZWQpIHtcclxuXHRcdFx0aWYgKHBTaG93U2Vjb25kcykge1xyXG5cdFx0XHRcdENhbC5TaG93U2Vjb25kcyA9IHRydWU7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0Q2FsLlNob3dTZWNvbmRzID0gZmFsc2U7XHJcblx0XHRcdH1cclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdENhbC5TaG93U2Vjb25kcyA9IGZhbHNlO1xyXG5cdFx0fVxyXG5cclxuXHR9XHJcblxyXG5cdGlmIChwQ3RybCAhPT0gdW5kZWZpbmVkKSB7XHJcblx0XHRDYWwuQ3RybCA9IHBDdHJsO1xyXG5cdH1cclxuXHJcblx0aWYgKHBGb3JtYXQhPT0gdW5kZWZpbmVkICYmIHBGb3JtYXQgIT09XCJcIikge1xyXG5cdFx0Q2FsLkZvcm1hdCA9IHBGb3JtYXQudG9VcHBlckNhc2UoKTtcclxuXHR9IGVsc2Uge1xyXG5cdFx0Q2FsLkZvcm1hdCA9IFwiTU1ERFlZWVlcIjtcclxuXHR9XHJcblxyXG5cdGlmIChwU2Nyb2xsZXIhPT0gdW5kZWZpbmVkICYmIHBTY3JvbGxlciE9PVwiXCIpIHtcclxuXHRcdGlmIChwU2Nyb2xsZXIudG9VcHBlckNhc2UoKSA9PT0gXCJBUlJPV1wiKSB7XHJcblx0XHRcdENhbC5TY3JvbGxlciA9IFwiQVJST1dcIjtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdENhbC5TY3JvbGxlciA9IFwiRFJPUERPV05cIjtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdGlmIChwRW5hYmxlRGF0ZU1vZGUgIT09IHVuZGVmaW5lZCAmJiAocEVuYWJsZURhdGVNb2RlID09PSBcImZ1dHVyZVwiIHx8IHBFbmFibGVEYXRlTW9kZSA9PT0gXCJwYXN0XCIpKSB7XHJcblx0XHRDYWwuRW5hYmxlRGF0ZU1vZGU9IHBFbmFibGVEYXRlTW9kZTtcclxuXHR9XHJcblxyXG5cdGV4RGF0ZVRpbWUgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChwQ3RybCkudmFsdWU7IC8vRXhpc3RpbmcgRGF0ZSBUaW1lIHZhbHVlIGluIHRleHRib3guXHJcblxyXG5cdGlmIChleERhdGVUaW1lKSB7IC8vUGFyc2UgZXhpc3RpbmcgRGF0ZSBTdHJpbmdcclxuXHRcdHZhciBTcDEgPSBleERhdGVUaW1lLmluZGV4T2YoRGF0ZVNlcGFyYXRvciwgMCksLy9JbmRleCBvZiBEYXRlIFNlcGFyYXRvciAxXHJcblx0XHRcdFNwMiA9IGV4RGF0ZVRpbWUuaW5kZXhPZihEYXRlU2VwYXJhdG9yLCBwYXJzZUludChTcDEsIDEwKSArIDEpLC8vSW5kZXggb2YgRGF0ZSBTZXBhcmF0b3IgMlxyXG5cdFx0XHR0U3AxLC8vSW5kZXggb2YgVGltZSBTZXBhcmF0b3IgMVxyXG5cdFx0XHR0U3AyLC8vSW5kZXggb2YgVGltZSBTZXBhcmF0b3IgMlxyXG5cdFx0XHRzdHJNb250aCxcclxuXHRcdFx0c3RyRGF0ZSxcclxuXHRcdFx0c3RyWWVhcixcclxuXHRcdFx0aW50TW9udGgsXHJcblx0XHRcdFllYXJQYXR0ZXJuLFxyXG5cdFx0XHRzdHJIb3VyLFxyXG5cdFx0XHRzdHJNaW51dGUsXHJcblx0XHRcdHN0clNlY29uZCxcclxuXHRcdFx0d2luSGVpZ2h0LFxyXG5cdFx0XHRvZmZzZXQgPSBwYXJzZUludChDYWwuRm9ybWF0LnRvVXBwZXJDYXNlKCkubGFzdEluZGV4T2YoXCJNXCIpLCAxMCkgLSBwYXJzZUludChDYWwuRm9ybWF0LnRvVXBwZXJDYXNlKCkuaW5kZXhPZihcIk1cIiksIDEwKSAtIDEsXHJcblx0XHRcdHN0ckFNUE0gPSBcIlwiO1xyXG5cdFx0Ly9wYXJzZSBtb250aFxyXG5cclxuXHRcdGlmIChDYWwuRm9ybWF0LnRvVXBwZXJDYXNlKCkgPT09IFwiRERNTVlZWVlcIiB8fCBDYWwuRm9ybWF0LnRvVXBwZXJDYXNlKCkgPT09IFwiRERNTU1ZWVlZXCIpIHtcclxuXHRcdFx0aWYgKERhdGVTZXBhcmF0b3IgPT09IFwiXCIpXHJcblx0XHRcdHtcclxuXHRcdFx0XHRzdHJNb250aCA9IGV4RGF0ZVRpbWUuc3Vic3RyaW5nKDIsIDQgKyBvZmZzZXQpO1xyXG5cdFx0XHRcdHN0ckRhdGUgPSBleERhdGVUaW1lLnN1YnN0cmluZygwLCAyKTtcclxuXHRcdFx0XHRzdHJZZWFyID0gZXhEYXRlVGltZS5zdWJzdHJpbmcoNCArIG9mZnNldCwgOCArIG9mZnNldCk7XHJcblx0XHRcdH1cclxuXHRcdFx0ZWxzZVxyXG5cdFx0XHR7XHJcblx0XHRcdFx0aWYgKGV4RGF0ZVRpbWUuaW5kZXhPZihcIkQqXCIpICE9PSAtMSlcclxuXHRcdFx0XHR7ICAgLy9EVEdcclxuXHRcdFx0XHRcdHN0ck1vbnRoID0gZXhEYXRlVGltZS5zdWJzdHJpbmcoOCwgMTEpO1xyXG5cdFx0XHRcdFx0c3RyRGF0ZSAgPSBleERhdGVUaW1lLnN1YnN0cmluZygwLCAyKTtcclxuXHRcdFx0XHRcdHN0clllYXIgID0gXCIyMFwiICsgZXhEYXRlVGltZS5zdWJzdHJpbmcoMTEsIDEzKTsgIC8vSGFjaywgbnVyIGbDvHIgSmFocmVzemFobGVuIGFiIDIwMDBcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0ZWxzZVxyXG5cdFx0XHRcdHtcclxuXHRcdFx0XHRcdHN0ck1vbnRoID0gZXhEYXRlVGltZS5zdWJzdHJpbmcoU3AxICsgMSwgU3AyKTtcclxuXHRcdFx0XHRcdHN0ckRhdGUgPSBleERhdGVUaW1lLnN1YnN0cmluZygwLCBTcDEpO1xyXG5cdFx0XHRcdFx0c3RyWWVhciA9IGV4RGF0ZVRpbWUuc3Vic3RyaW5nKFNwMiArIDEsIFNwMiArIDUpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdGVsc2UgaWYgKENhbC5Gb3JtYXQudG9VcHBlckNhc2UoKSA9PT0gXCJNTUREWVlZWVwiIHx8IENhbC5Gb3JtYXQudG9VcHBlckNhc2UoKSA9PT0gXCJNTU1ERFlZWVlcIikge1xyXG5cdFx0XHRpZiAoRGF0ZVNlcGFyYXRvciA9PT0gXCJcIikge1xyXG5cdFx0XHRcdHN0ck1vbnRoID0gZXhEYXRlVGltZS5zdWJzdHJpbmcoMCwgMiArIG9mZnNldCk7XHJcblx0XHRcdFx0c3RyRGF0ZSA9IGV4RGF0ZVRpbWUuc3Vic3RyaW5nKDIgKyBvZmZzZXQsIDQgKyBvZmZzZXQpO1xyXG5cdFx0XHRcdHN0clllYXIgPSBleERhdGVUaW1lLnN1YnN0cmluZyg0ICsgb2Zmc2V0LCA4ICsgb2Zmc2V0KTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRzdHJNb250aCA9IGV4RGF0ZVRpbWUuc3Vic3RyaW5nKDAsIFNwMSk7XHJcblx0XHRcdFx0c3RyRGF0ZSA9IGV4RGF0ZVRpbWUuc3Vic3RyaW5nKFNwMSArIDEsIFNwMik7XHJcblx0XHRcdFx0c3RyWWVhciA9IGV4RGF0ZVRpbWUuc3Vic3RyaW5nKFNwMiArIDEsIFNwMiArIDUpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHRlbHNlIGlmIChDYWwuRm9ybWF0LnRvVXBwZXJDYXNlKCkgPT09IFwiWVlZWU1NRERcIiB8fCBDYWwuRm9ybWF0LnRvVXBwZXJDYXNlKCkgPT09IFwiWVlZWU1NTUREXCIpIHtcclxuXHRcdFx0aWYgKERhdGVTZXBhcmF0b3IgPT09IFwiXCIpIHtcclxuXHRcdFx0XHRzdHJNb250aCA9IGV4RGF0ZVRpbWUuc3Vic3RyaW5nKDQsIDYgKyBvZmZzZXQpO1xyXG5cdFx0XHRcdHN0ckRhdGUgPSBleERhdGVUaW1lLnN1YnN0cmluZyg2ICsgb2Zmc2V0LCA4ICsgb2Zmc2V0KTtcclxuXHRcdFx0XHRzdHJZZWFyID0gZXhEYXRlVGltZS5zdWJzdHJpbmcoMCwgNCk7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0c3RyTW9udGggPSBleERhdGVUaW1lLnN1YnN0cmluZyhTcDEgKyAxLCBTcDIpO1xyXG5cdFx0XHRcdHN0ckRhdGUgPSBleERhdGVUaW1lLnN1YnN0cmluZyhTcDIgKyAxLCBTcDIgKyAzKTtcclxuXHRcdFx0XHRzdHJZZWFyID0gZXhEYXRlVGltZS5zdWJzdHJpbmcoMCwgU3AxKTtcclxuXHRcdFx0fVxyXG5cdFx0fSBlbHNlIGlmIChDYWwuRm9ybWF0LnRvVXBwZXJDYXNlKCkgPT09IFwiWVlNTUREXCIgfHwgQ2FsLkZvcm1hdC50b1VwcGVyQ2FzZSgpID09PSBcIllZTU1NRERcIikge1xyXG5cdFx0XHRpZiAoRGF0ZVNlcGFyYXRvciA9PT0gXCJcIilcclxuXHRcdFx0e1xyXG5cdFx0XHRcdHN0ck1vbnRoID0gZXhEYXRlVGltZS5zdWJzdHJpbmcoMiwgNCArIG9mZnNldCk7XHJcblx0XHRcdFx0c3RyRGF0ZSA9IGV4RGF0ZVRpbWUuc3Vic3RyaW5nKDQgKyBvZmZzZXQsIDYgKyBvZmZzZXQpO1xyXG5cdFx0XHRcdHN0clllYXIgPSBleERhdGVUaW1lLnN1YnN0cmluZygwLCAyKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRlbHNlXHJcblx0XHRcdHtcclxuXHRcdFx0XHRzdHJNb250aCA9IGV4RGF0ZVRpbWUuc3Vic3RyaW5nKFNwMSArIDEsIFNwMik7XHJcblx0XHRcdFx0c3RyRGF0ZSA9IGV4RGF0ZVRpbWUuc3Vic3RyaW5nKFNwMiArIDEsIFNwMiArIDMpO1xyXG5cdFx0XHRcdHN0clllYXIgPSBleERhdGVUaW1lLnN1YnN0cmluZygwLCBTcDEpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKGlzTmFOKHN0ck1vbnRoKSkge1xyXG5cdFx0XHRpbnRNb250aCA9IENhbC5HZXRNb250aEluZGV4KHN0ck1vbnRoKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdGludE1vbnRoID0gcGFyc2VJbnQoc3RyTW9udGgsIDEwKSAtIDE7XHJcblx0XHR9XHJcblx0XHRpZiAoKHBhcnNlSW50KGludE1vbnRoLCAxMCkgPj0gMCkgJiYgKHBhcnNlSW50KGludE1vbnRoLCAxMCkgPCAxMikpXHR7XHJcblx0XHRcdENhbC5Nb250aCA9IGludE1vbnRoO1xyXG5cdFx0fVxyXG5cdFx0Ly9lbmQgcGFyc2UgbW9udGhcclxuXHJcblx0XHQvL3BhcnNlIHllYXJcclxuXHRcdFllYXJQYXR0ZXJuID0gL15cXGR7NH0kLztcclxuXHRcdGlmIChZZWFyUGF0dGVybi50ZXN0KHN0clllYXIpKSB7XHJcblx0XHRcdGlmICgocGFyc2VJbnQoc3RyWWVhciwgMTApPj1TdGFydFllYXIpICYmIChwYXJzZUludChzdHJZZWFyLCAxMCk8PSAoZHRUb2RheS5nZXRGdWxsWWVhcigpK0VuZFllYXIpKSlcclxuXHRcdFx0XHRDYWwuWWVhciA9IHBhcnNlSW50KHN0clllYXIsIDEwKTtcclxuXHRcdH1cclxuXHRcdC8vZW5kIHBhcnNlIHllYXJcclxuXHJcblx0XHQvL3BhcnNlIERhdGVcclxuXHRcdGlmICgocGFyc2VJbnQoc3RyRGF0ZSwgMTApIDw9IENhbC5HZXRNb25EYXlzKCkpICYmIChwYXJzZUludChzdHJEYXRlLCAxMCkgPj0gMSkpIHtcclxuXHRcdFx0Q2FsLkRhdGUgPSBzdHJEYXRlO1xyXG5cdFx0fVxyXG5cdFx0Ly9lbmQgcGFyc2UgRGF0ZVxyXG5cclxuXHRcdC8vcGFyc2UgdGltZVxyXG5cclxuXHRcdGlmIChDYWwuU2hvd1RpbWUgPT09IHRydWUpIHtcclxuXHRcdFx0Ly9wYXJzZSBBTSBvciBQTVxyXG5cdFx0XHRpZiAoVGltZU1vZGUgPT09IDEyKSB7XHJcblx0XHRcdFx0c3RyQU1QTSA9IGV4RGF0ZVRpbWUuc3Vic3RyaW5nKGV4RGF0ZVRpbWUubGVuZ3RoIC0gMiwgZXhEYXRlVGltZS5sZW5ndGgpO1xyXG5cdFx0XHRcdENhbC5BTW9yUE0gPSBzdHJBTVBNO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR0U3AxID0gZXhEYXRlVGltZS5pbmRleE9mKFwiOlwiLCAwKTtcclxuXHRcdFx0dFNwMiA9IGV4RGF0ZVRpbWUuaW5kZXhPZihcIjpcIiwgKHBhcnNlSW50KHRTcDEsIDEwKSArIDEpKTtcclxuXHJcblx0XHRcdGlmICh0U3AxID4gMCkge1xyXG5cdFx0XHRcdHN0ckhvdXIgPSBleERhdGVUaW1lLnN1YnN0cmluZyh0U3AxLCB0U3AxIC0gMik7XHJcblx0XHRcdFx0Q2FsLlNldEhvdXIoc3RySG91cik7XHJcblx0XHRcdFx0c3RyTWludXRlID0gZXhEYXRlVGltZS5zdWJzdHJpbmcodFNwMSArIDEsIHRTcDEgKyAzKTtcclxuXHRcdFx0XHRDYWwuU2V0TWludXRlKHN0ck1pbnV0ZSk7XHJcblx0XHRcdFx0c3RyU2Vjb25kID0gZXhEYXRlVGltZS5zdWJzdHJpbmcodFNwMiArIDEsIHRTcDIgKyAzKTtcclxuXHRcdFx0XHRDYWwuU2V0U2Vjb25kKHN0clNlY29uZCk7XHJcblx0XHRcdH0gZWxzZSBpZiAoZXhEYXRlVGltZS5pbmRleE9mKFwiRCpcIikgIT09IC0xKSB7ICAgLy9EVEdcclxuXHRcdFx0XHRzdHJIb3VyID0gZXhEYXRlVGltZS5zdWJzdHJpbmcoMiwgNCk7XHJcblx0XHRcdFx0Q2FsLlNldEhvdXIoc3RySG91cik7XHJcblx0XHRcdFx0c3RyTWludXRlID0gZXhEYXRlVGltZS5zdWJzdHJpbmcoNCwgNik7XHJcblx0XHRcdFx0Q2FsLlNldE1pbnV0ZShzdHJNaW51dGUpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fVxyXG5cdHNlbERhdGUgPSBuZXcgRGF0ZShDYWwuWWVhciwgQ2FsLk1vbnRoLCBDYWwuRGF0ZSk7IC8vdmVyc2lvbiAxLjdcclxuXHRSZW5kZXJDc3NDYWwodHJ1ZSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNsb3Nld2luKGlkKSB7XHJcblx0aWYgKENhbC5TaG93VGltZSA9PT0gdHJ1ZSkge1xyXG5cdFx0dmFyIE1heFllYXIgPSBkdFRvZGF5LmdldEZ1bGxZZWFyKCkgKyBFbmRZZWFyO1xyXG5cdFx0dmFyIGJlZm9yZVRvZGF5ID1cclxuXHRcdFx0KENhbC5EYXRlIDwgZHRUb2RheS5nZXREYXRlKCkpICYmXHJcblx0XHRcdChDYWwuTW9udGggPT09IGR0VG9kYXkuZ2V0TW9udGgoKSkgJiZcclxuXHRcdFx0KENhbC5ZZWFyID09PSBkdFRvZGF5LmdldEZ1bGxZZWFyKCkpXHJcblx0XHRcdHx8XHJcblx0XHRcdChDYWwuTW9udGggPCBkdFRvZGF5LmdldE1vbnRoKCkpICYmXHJcblx0XHRcdChDYWwuWWVhciA9PT0gZHRUb2RheS5nZXRGdWxsWWVhcigpKVxyXG5cdFx0XHR8fFxyXG5cdFx0XHQoQ2FsLlllYXIgPCBkdFRvZGF5LmdldEZ1bGxZZWFyKCkpO1xyXG5cclxuXHRcdGlmICgoQ2FsLlllYXIgPD0gTWF4WWVhcikgJiYgKENhbC5ZZWFyID49IFN0YXJ0WWVhcikgJiYgKENhbC5Nb250aCA9PT0gc2VsRGF0ZS5nZXRNb250aCgpKSAmJiAoQ2FsLlllYXIgPT09IHNlbERhdGUuZ2V0RnVsbFllYXIoKSkpIHtcclxuXHRcdFx0aWYgKENhbC5FbmFibGVEYXRlTW9kZSA9PT0gXCJmdXR1cmVcIikge1xyXG5cdFx0XHRcdGlmIChiZWZvcmVUb2RheSA9PT0gZmFsc2UpIHtcclxuXHRcdFx0XHRcdGNhbGxiYWNrKGlkLCBDYWwuRm9ybWF0RGF0ZShDYWwuRGF0ZSkpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0XHRlbHNlXHJcblx0XHRcdFx0Y2FsbGJhY2soaWQsIENhbC5Gb3JtYXREYXRlKENhbC5EYXRlKSk7XHJcblx0XHR9XHJcblx0fVxyXG5cdHZhciBDYWxJZCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGlkKTtcclxuXHRDYWxJZC5mb2N1cygpO1xyXG5cdHdpbkNhbC5zdHlsZS52aXNpYmlsaXR5ID0gJ2hpZGRlbic7XHJcblx0ZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2NhbE92ZXJsYXknKS5jbGFzc0xpc3QucmVtb3ZlKCdzaG93Jyk7XHJcblx0dmFyIGFjdGl2ZUljb25zID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnLmR0LWljbycpO1xyXG5cdHZhciBhaUNvdW50TGVuZ2h0ID0gYWN0aXZlSWNvbnMubGVuZ3RoO1xyXG5cdGZvciAodmFyIGFpQ291bnQgPSAwOyBhaUNvdW50IDwgYWlDb3VudExlbmdodDsgKythaUNvdW50KSB7XHJcblx0XHRhY3RpdmVJY29uc1thaUNvdW50XS5jbGFzc0xpc3QucmVtb3ZlKCdhY3RpdmUnKTtcclxuXHR9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHdpbmNsb3NlKCkge1xyXG5cdHdpbkNhbC5zdHlsZS52aXNpYmlsaXR5ID0gJ2hpZGRlbic7XHJcblx0ZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2NhbE92ZXJsYXknKS5jbGFzc0xpc3QucmVtb3ZlKCdzaG93Jyk7XHJcblx0dmFyIGFjdGl2ZUljb25zID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnLmR0LWljbycpO1xyXG5cdHZhciBhaUNvdW50TGVuZ2h0ID0gYWN0aXZlSWNvbnMubGVuZ3RoO1xyXG5cdGZvciAodmFyIGFpQ291bnQgPSAwOyBhaUNvdW50IDwgYWlDb3VudExlbmdodDsgKythaUNvdW50KSB7XHJcblx0XHRhY3RpdmVJY29uc1thaUNvdW50XS5jbGFzc0xpc3QucmVtb3ZlKCdhY3RpdmUnKTtcclxuXHR9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNoYW5nZUJvcmRlcihlbGVtZW50LCBjb2wsIG9sZEJnQ29sb3IpIHtcclxuXHRpZiAoY29sID09PSAwKVxyXG5cdHtcclxuXHRcdGVsZW1lbnQuc3R5bGUuYmFja2dyb3VuZCA9IEhvdmVyQ29sb3I7XHJcblx0XHRlbGVtZW50LnN0eWxlLmJvcmRlckNvbG9yID0gXCJibGFja1wiO1xyXG5cdFx0ZWxlbWVudC5zdHlsZS5jdXJzb3IgPSBcInBvaW50ZXJcIjtcclxuXHR9XHJcblxyXG5cdGVsc2VcclxuXHR7XHJcblx0XHRpZiAob2xkQmdDb2xvcilcclxuXHRcdHtcclxuXHRcdFx0ZWxlbWVudC5zdHlsZS5iYWNrZ3JvdW5kID0gb2xkQmdDb2xvcjtcclxuXHRcdH1cclxuXHRcdGVsc2VcclxuXHRcdHtcclxuXHRcdFx0ZWxlbWVudC5zdHlsZS5iYWNrZ3JvdW5kID0gXCJ3aGl0ZVwiO1xyXG5cdFx0fVxyXG5cdFx0ZWxlbWVudC5zdHlsZS5ib3JkZXJDb2xvciA9IFwid2hpdGVcIjtcclxuXHRcdGVsZW1lbnQuc3R5bGUuY3Vyc29yID0gXCJhdXRvXCI7XHJcblx0fVxyXG59XHJcblxyXG5mdW5jdGlvbiBzZWxlY3REYXRlKGVsZW1lbnQsIGRhdGUpIHtcclxuXHRDYWwuRGF0ZSA9IGRhdGU7XHJcblx0c2VsRGF0ZSA9IG5ldyBEYXRlKENhbC5ZZWFyLCBDYWwuTW9udGgsIENhbC5EYXRlKTtcclxuXHRlbGVtZW50LnN0eWxlLmJhY2tncm91bmQgPSBTZWxEYXRlQ29sb3I7XHJcblx0UmVuZGVyQ3NzQ2FsKCk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGZpbmRQb3Mob2JqKSB7XHJcblx0dmFyIGN1cmxlZnQgPSAwLCBjdXJ0b3AgPSAwO1xyXG5cdGlmIChvYmoub2Zmc2V0UGFyZW50KSB7XHJcblx0XHRkbyB7XHJcblx0XHRcdGN1cmxlZnQgKz0gb2JqLm9mZnNldExlZnQ7XHJcblx0XHRcdGN1cnRvcCArPSBvYmoub2Zmc2V0VG9wO1xyXG5cdFx0fSB3aGlsZSAob2JqID0gb2JqLm9mZnNldFBhcmVudCk7XHJcblx0XHRyZXR1cm4geyB4OiBjdXJsZWZ0LCB5OiBjdXJ0b3AgfTtcclxuXHR9XHJcblx0cmV0dXJuIHVuZGVmaW5lZDtcclxufVxyXG5cclxuZnVuY3Rpb24gcGlja0l0KGV2dCkge1xyXG5cdHZhciBvYmplY3RJRCxcclxuXHRcdGRvbSxcclxuXHRcdGRlLFxyXG5cdFx0YjtcclxuXHQvLyBhY2Nlc3NlcyB0aGUgZWxlbWVudCB0aGF0IGdlbmVyYXRlcyB0aGUgZXZlbnQgYW5kIHJldHJpZXZlcyBpdHMgSURcclxuXHRpZiAoZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcilcclxuXHR7IC8vIHczY1xyXG5cdFx0b2JqZWN0SUQgPSBldnQudGFyZ2V0LmlkO1xyXG5cdFx0LypcclxuXHRcdCBpZiAob2JqZWN0SUQuaW5kZXhPZihjYWxTcGFuSUQpICE9PSAtMSlcclxuXHRcdCB7XHJcblx0XHQgZG9tID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQob2JqZWN0SUQpO1xyXG5cdFx0IGNuTGVmdCA9IGV2dC5wYWdlWDtcclxuXHRcdCBjblRvcCA9IGV2dC5wYWdlWTtcclxuXHJcblx0XHQgaWYgKGRvbS5vZmZzZXRMZWZ0KVxyXG5cdFx0IHtcclxuXHRcdCBjbkxlZnQgPSAoY25MZWZ0IC0gZG9tLm9mZnNldExlZnQpO1xyXG5cdFx0IGNuVG9wID0gKGNuVG9wIC0gZG9tLm9mZnNldFRvcCk7XHJcblx0XHQgfVxyXG5cdFx0IH1cclxuXHRcdCAqL1xyXG5cdFx0Ly8gZ2V0IG1vdXNlIHBvc2l0aW9uIG9uIGNsaWNrXHJcblx0XHQvKlxyXG5cdFx0IHhwb3MgPSAoZXZ0LnBhZ2VYKTtcclxuXHRcdCB5cG9zID0gKGV2dC5wYWdlWSk7XHJcblx0XHQgKi9cclxuXHRcdGlmIChvYmplY3RJRCA9PSAnJykge1xyXG5cdFx0XHR2YXIgcG9zRXZUYXJnZXQgPSBmaW5kUG9zKGV2dC50YXJnZXQpO1xyXG5cdFx0XHRpZiAocG9zRXZUYXJnZXQpIHtcclxuXHRcdFx0XHR4cG9zID0gcG9zRXZUYXJnZXQueDtcclxuXHRcdFx0XHR5cG9zID0gcG9zRXZUYXJnZXQueTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHR9XHJcblxyXG5cdGVsc2VcclxuXHR7IC8vIElFXHJcblx0XHRvYmplY3RJRCA9IGV2ZW50LnNyY0VsZW1lbnQuaWQ7XHJcblx0XHRjbkxlZnQgPSBldmVudC5vZmZzZXRYO1xyXG5cdFx0Y25Ub3AgPSAoZXZlbnQub2Zmc2V0WSk7XHJcblxyXG5cdFx0Ly8gZ2V0IG1vdXNlIHBvc2l0aW9uIG9uIGNsaWNrXHJcblx0XHRkZSA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcclxuXHRcdGIgPSBkb2N1bWVudC5ib2R5O1xyXG5cclxuXHRcdHhwb3MgPSBldmVudC5jbGllbnRYICsgKGRlLnNjcm9sbExlZnQgfHwgYi5zY3JvbGxMZWZ0KSAtIChkZS5jbGllbnRMZWZ0IHx8IDApO1xyXG5cdFx0eXBvcyA9IGV2ZW50LmNsaWVudFkgKyAoZGUuc2Nyb2xsVG9wIHx8IGIuc2Nyb2xsVG9wKSAtIChkZS5jbGllbnRUb3AgfHwgMCk7XHJcblx0fVxyXG5cclxuXHQvLyB2ZXJpZnkgaWYgdGhpcyBpcyBhIHZhbGlkIGVsZW1lbnQgdG8gcGlja1xyXG5cdGlmIChvYmplY3RJRC5pbmRleE9mKGNhbFNwYW5JRCkgIT09IC0xKVxyXG5cdHtcclxuXHRcdGRvbVN0eWxlID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQob2JqZWN0SUQpLnN0eWxlO1xyXG5cdH1cclxuXHJcblx0aWYgKGRvbVN0eWxlKVxyXG5cdHtcclxuXHRcdGRvbVN0eWxlLnpJbmRleCA9IDEwMDtcclxuXHRcdHJldHVybiBmYWxzZTtcclxuXHR9XHJcblxyXG5cdGVsc2VcclxuXHR7XHJcblx0XHRkb21TdHlsZSA9IG51bGw7XHJcblx0XHRyZXR1cm47XHJcblx0fVxyXG59XHJcblxyXG5mdW5jdGlvbiBkcmFnSXQoZXZ0KSB7XHJcblx0aWYgKGRvbVN0eWxlKVxyXG5cdHtcclxuXHRcdGlmIChkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKVxyXG5cdFx0eyAvL2ZvciBJRVxyXG5cdFx0XHRkb21TdHlsZS5sZWZ0ID0gKGV2ZW50LmNsaWVudFggLSBjbkxlZnQgKyBkb2N1bWVudC5ib2R5LnNjcm9sbExlZnQpICsgJ3B4JztcclxuXHRcdFx0ZG9tU3R5bGUudG9wID0gKGV2ZW50LmNsaWVudFkgLSBjblRvcCArIGRvY3VtZW50LmJvZHkuc2Nyb2xsVG9wKSArICdweCc7XHJcblx0XHR9XHJcblx0XHRlbHNlXHJcblx0XHR7ICAvL0ZpcmVmb3hcclxuXHRcdFx0ZG9tU3R5bGUubGVmdCA9IChldnQuY2xpZW50WCAtIGNuTGVmdCArIGRvY3VtZW50LmJvZHkuc2Nyb2xsTGVmdCkgKyAncHgnO1xyXG5cdFx0XHRkb21TdHlsZS50b3AgPSAoZXZ0LmNsaWVudFkgLSBjblRvcCArIGRvY3VtZW50LmJvZHkuc2Nyb2xsVG9wKSArICdweCc7XHJcblx0XHR9XHJcblx0fVxyXG59XHJcblxyXG4vLyBwZXJmb3JtcyBhIHNpbmdsZSBpbmNyZW1lbnQgb3IgZGVjcmVtZW50XHJcbmZ1bmN0aW9uIG5leHRTdGVwKHdoYXRTcGlubmVyLCBkaXJlY3Rpb24pIHtcclxuXHRpZiAod2hhdFNwaW5uZXIgPT09IFwiSG91clwiKVxyXG5cdHtcclxuXHRcdGlmIChkaXJlY3Rpb24gPT09IFwicGx1c1wiKVxyXG5cdFx0e1xyXG5cdFx0XHRDYWwuU2V0SG91cihDYWwuSG91cnMgKyAxKTtcclxuXHRcdFx0UmVuZGVyQ3NzQ2FsKCk7XHJcblx0XHR9XHJcblx0XHRlbHNlIGlmIChkaXJlY3Rpb24gPT09IFwibWludXNcIilcclxuXHRcdHtcclxuXHRcdFx0Q2FsLlNldEhvdXIoQ2FsLkhvdXJzIC0gMSk7XHJcblx0XHRcdFJlbmRlckNzc0NhbCgpO1xyXG5cdFx0fVxyXG5cdH1cclxuXHRlbHNlIGlmICh3aGF0U3Bpbm5lciA9PT0gXCJNaW51dGVcIilcclxuXHR7XHJcblx0XHRpZiAoZGlyZWN0aW9uID09PSBcInBsdXNcIilcclxuXHRcdHtcclxuXHRcdFx0Q2FsLlNldE1pbnV0ZShwYXJzZUludChDYWwuTWludXRlcywgMTApICsgMSk7XHJcblx0XHRcdFJlbmRlckNzc0NhbCgpO1xyXG5cdFx0fVxyXG5cdFx0ZWxzZSBpZiAoZGlyZWN0aW9uID09PSBcIm1pbnVzXCIpXHJcblx0XHR7XHJcblx0XHRcdENhbC5TZXRNaW51dGUocGFyc2VJbnQoQ2FsLk1pbnV0ZXMsIDEwKSAtIDEpO1xyXG5cdFx0XHRSZW5kZXJDc3NDYWwoKTtcclxuXHRcdH1cclxuXHR9XHJcblxyXG59XHJcblxyXG4vLyBzdGFydHMgdGhlIHRpbWUgc3Bpbm5lclxyXG5mdW5jdGlvbiBzdGFydFNwaW4od2hhdFNwaW5uZXIsIGRpcmVjdGlvbikge1xyXG5cdGRvY3VtZW50LnRoaXNMb29wID0gc2V0SW50ZXJ2YWwoZnVuY3Rpb24gKClcclxuXHR7XHJcblx0XHRuZXh0U3RlcCh3aGF0U3Bpbm5lciwgZGlyZWN0aW9uKTtcclxuXHR9LCAxMjUpOyAvLzEyNSBtc1xyXG59XHJcblxyXG4vL3N0b3BzIHRoZSB0aW1lIHNwaW5uZXJcclxuZnVuY3Rpb24gc3RvcFNwaW4oKSB7XHJcblx0Y2xlYXJJbnRlcnZhbChkb2N1bWVudC50aGlzTG9vcCk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGRyb3BJdCgpIHtcclxuXHRzdG9wU3BpbigpO1xyXG5cclxuXHRpZiAoZG9tU3R5bGUpXHJcblx0e1xyXG5cdFx0ZG9tU3R5bGUgPSBudWxsO1xyXG5cdH1cclxufVxyXG5cclxuLy8gRGVmYXVsdCBldmVudHMgY29uZmlndXJhdGlvblxyXG5cclxuZG9jdW1lbnQub25tb3VzZWRvd24gPSBwaWNrSXQ7XHJcbi8qXHJcbiBkb2N1bWVudC5vbm1vdXNlbW92ZSA9IGRyYWdJdDtcclxuIGRvY3VtZW50Lm9ubW91c2V1cCA9IGRyb3BJdDtcclxuICovXHJcblxyXG5kb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGZ1bmN0aW9uIChlKSB7XHJcblxyXG5cdGlmIChlLnRhcmdldC5jbGFzc0xpc3RbMF0gPT0gJ2R0LWljbycpIHtcclxuXHRcdGlmIChlLnRhcmdldC5jbGFzc0xpc3RbMV0gIT09IHVuZGVmaW5lZCkge1xyXG5cdFx0XHRlLnRhcmdldC5jbGFzc0xpc3QucmVtb3ZlKCdhY3RpdmUnKTtcclxuXHRcdFx0ZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2NhbEJvcmRlcicpLnN0eWxlLnZpc2liaWxpdHkgPSAnaGlkZGVuJztcclxuXHRcdFx0ZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2NhbE92ZXJsYXknKS5jbGFzc0xpc3QucmVtb3ZlKCdzaG93Jyk7XHJcblx0XHR9XHJcblx0XHRlbHNlIHtcclxuXHRcdFx0ZS50YXJnZXQuY2xhc3NMaXN0LmFkZCgnYWN0aXZlJyk7XHJcblx0XHRcdGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdjYWxCb3JkZXInKS5zdHlsZS52aXNpYmlsaXR5ID0gJ3Zpc2libGUnO1xyXG5cdFx0XHRkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnY2FsT3ZlcmxheScpLmNsYXNzTGlzdC5hZGQoJ3Nob3cnKTtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdGlmIChlLnRhcmdldC5pZCA9PT0gJ2NhbE92ZXJsYXknKSB7XHJcblx0XHRkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnY2FsQm9yZGVyJykuc3R5bGUudmlzaWJpbGl0eSA9ICdoaWRkZW4nO1xyXG5cdFx0ZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2NhbE92ZXJsYXknKS5jbGFzc0xpc3QucmVtb3ZlKCdzaG93Jyk7XHJcblx0XHR2YXIgYWN0aXZlSWNvbnMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCcuZHQtaWNvJyk7XHJcblx0XHR2YXIgYWlDb3VudExlbmdodCA9IGFjdGl2ZUljb25zLmxlbmd0aDtcclxuXHRcdGZvciAodmFyIGFpQ291bnQgPSAwOyBhaUNvdW50IDwgYWlDb3VudExlbmdodDsgKythaUNvdW50KSB7XHJcblx0XHRcdGFjdGl2ZUljb25zW2FpQ291bnRdLmNsYXNzTGlzdC5yZW1vdmUoJ2FjdGl2ZScpO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0aWYgKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJyNjYWxCb3JkZXIgLk1vbnRoU2VsZWN0b3InKSAhPT0gbnVsbCkge1xyXG5cclxuXHRcdHZhciB0YXJnZXRDbGFzcyA9IGUudGFyZ2V0LmNsYXNzTGlzdFswXTtcclxuXHRcdGlmIChlLnRhcmdldC5jbGFzc0xpc3RbMV0gIT09IHVuZGVmaW5lZCkgdGFyZ2V0Q2xhc3MgPSBlLnRhcmdldC5jbGFzc0xpc3RbMV07XHJcblx0XHRpZiAodGFyZ2V0Q2xhc3MgPT09IHVuZGVmaW5lZCkgdGFyZ2V0Q2xhc3MgPSBlLnRhcmdldC5wYXJlbnROb2RlLmNsYXNzTGlzdFswXTtcclxuXHJcblx0XHRpZiAodGFyZ2V0Q2xhc3MgPT0gJ01vbnRoU2VsZWN0b3JUaXRsZScpIHtcclxuXHRcdFx0aWYgKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJyNjYWxCb3JkZXIgLk1vbnRoU2VsZWN0b3InKS5jbGFzc0xpc3QuY29udGFpbnMoXCJzaG93XCIpKSB7XHJcblx0XHRcdFx0ZG9jdW1lbnQucXVlcnlTZWxlY3RvcignI2NhbEJvcmRlciAuTW9udGhTZWxlY3RvcicpLmNsYXNzTGlzdC5yZW1vdmUoXCJzaG93XCIpO1xyXG5cdFx0XHR9XHJcblx0XHRcdGVsc2Uge1xyXG5cdFx0XHRcdGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJyNjYWxCb3JkZXIgLk1vbnRoU2VsZWN0b3InKS5jbGFzc0xpc3QuYWRkKFwic2hvd1wiKTtcclxuXHRcdFx0XHRkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjY2FsQm9yZGVyIC5Nb250aFNlbGVjdG9yLlllYXInKS5jbGFzc0xpc3QucmVtb3ZlKFwic2hvd1wiKTtcclxuXHRcdFx0fVxyXG5cdFx0fTtcclxuXHJcblx0XHRpZiAodGFyZ2V0Q2xhc3MgPT0gJ01vbnRoU2VsZWN0b3InKSB7XHJcblxyXG5cdFx0XHR2YXIgc2VsZWN0Q2xhc3MgPSBlLnRhcmdldC5wYXJlbnROb2RlLmNsYXNzTGlzdFsxXTtcclxuXHJcblx0XHRcdGlmIChlLnRhcmdldC50YWdOYW1lID09PSAnTEknICYmIHNlbGVjdENsYXNzID09PSAnc2hvdycpIHtcclxuXHRcdFx0XHRkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjY2FsQm9yZGVyIC5Nb250aFNlbGVjdG9yVGl0bGUnKS5pbm5lckhUTUwgPSBlLnRhcmdldC5pbm5lckhUTUw7XHJcblx0XHRcdFx0Q2FsLlN3aXRjaE10aChbXS5pbmRleE9mLmNhbGwoZS50YXJnZXQucGFyZW50Tm9kZS5jaGlsZHJlbiwgKGUgPyBlLnRhcmdldCA6IGUuc3JjRWxlbWVudCkpKTtcclxuXHRcdFx0XHRSZW5kZXJDc3NDYWwoKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRpZiAoZS50YXJnZXQudGFnTmFtZSA9PT0gJ0xJJyAmJiBzZWxlY3RDbGFzcyA9PT0gJ1llYXInKSB7XHJcblx0XHRcdFx0ZG9jdW1lbnQucXVlcnlTZWxlY3RvcignI2NhbEJvcmRlciAuTW9udGhTZWxlY3RvclRpdGxlLlllYXInKS5pbm5lckhUTUwgPSBlLnRhcmdldC5pbm5lckhUTUw7XHJcblx0XHRcdFx0Q2FsLlN3aXRjaFllYXIoZS50YXJnZXQuaW5uZXJIVE1MKTtcclxuXHRcdFx0XHRSZW5kZXJDc3NDYWwoKTtcclxuXHRcdFx0fVxyXG5cdFx0fTtcclxuXHJcblx0XHRpZiAodGFyZ2V0Q2xhc3MgPT0gJ1llYXInKSB7XHJcblx0XHRcdGlmIChkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjY2FsQm9yZGVyIC5Nb250aFNlbGVjdG9yLlllYXInKS5jbGFzc0xpc3QuY29udGFpbnMoXCJzaG93XCIpKSB7XHJcblx0XHRcdFx0ZG9jdW1lbnQucXVlcnlTZWxlY3RvcignI2NhbEJvcmRlciAuTW9udGhTZWxlY3Rvci5ZZWFyJykuY2xhc3NMaXN0LnJlbW92ZShcInNob3dcIik7XHJcblx0XHRcdH1cclxuXHRcdFx0ZWxzZSB7XHJcblx0XHRcdFx0ZG9jdW1lbnQucXVlcnlTZWxlY3RvcignI2NhbEJvcmRlciAuTW9udGhTZWxlY3Rvci5ZZWFyJykuY2xhc3NMaXN0LmFkZChcInNob3dcIik7XHJcblx0XHRcdFx0ZG9jdW1lbnQucXVlcnlTZWxlY3RvcignI2NhbEJvcmRlciAuTW9udGhTZWxlY3RvcicpLmNsYXNzTGlzdC5yZW1vdmUoXCJzaG93XCIpO1xyXG5cdFx0XHR9XHJcblx0XHR9O1xyXG5cclxuXHR9XHJcblxyXG59KTtcclxuXHJcbnRyeSB7XHJcblx0d2luZG93Lk5ld0Nzc0NhbCA9IE5ld0Nzc0NhbDtcclxuXHR3aW5kb3cuQ2FsZW5kYXIgPSBDYWxlbmRhcjtcclxuXHR3aW5kb3cuR2VuQ2VsbCA9IEdlbkNlbGw7XHJcblx0d2luZG93LlJlbmRlckNzc0NhbCA9IFJlbmRlckNzc0NhbDtcclxuXHR3aW5kb3cuTmV3Q3NzQ2FsID0gTmV3Q3NzQ2FsO1xyXG5cdHdpbmRvdy5jbG9zZXdpbiA9IGNsb3Nld2luO1xyXG5cdHdpbmRvdy53aW5jbG9zZSA9IHdpbmNsb3NlO1xyXG5cdHdpbmRvdy5jaGFuZ2VCb3JkZXIgPSBjaGFuZ2VCb3JkZXI7XHJcblx0d2luZG93LnNlbGVjdERhdGUgPSBzZWxlY3REYXRlO1xyXG5cdHdpbmRvdy5maW5kUG9zID0gZmluZFBvcztcclxuXHR3aW5kb3cucGlja0l0ID0gcGlja0l0O1xyXG5cdHdpbmRvdy5kcmFnSXQgPSBkcmFnSXQ7XHJcblx0d2luZG93Lm5leHRTdGVwID0gbmV4dFN0ZXA7XHJcblx0d2luZG93LnN0YXJ0U3BpbiA9IHN0YXJ0U3BpbjtcclxuXHR3aW5kb3cuZHJvcEl0ID0gZHJvcEl0O1xyXG59IGNhdGNoIChlcnIpIHtcclxuXHRjb25zb2xlLmxvZyhlcnIpO1xyXG59XHJcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NjcmlwdHMvdmVuZG9ycy9kYXRldGltZXBpY2tlci5qcyIsIihmdW5jdGlvbiBlKHQsbixyKXtmdW5jdGlvbiBzKG8sdSl7aWYoIW5bb10pe2lmKCF0W29dKXt2YXIgYT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2lmKCF1JiZhKXJldHVybiBhKG8sITApO2lmKGkpcmV0dXJuIGkobywhMCk7dmFyIGY9bmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitvK1wiJ1wiKTt0aHJvdyBmLmNvZGU9XCJNT0RVTEVfTk9UX0ZPVU5EXCIsZn12YXIgbD1uW29dPXtleHBvcnRzOnt9fTt0W29dWzBdLmNhbGwobC5leHBvcnRzLGZ1bmN0aW9uKGUpe3ZhciBuPXRbb11bMV1bZV07cmV0dXJuIHMobj9uOmUpfSxsLGwuZXhwb3J0cyxlLHQsbixyKX1yZXR1cm4gbltvXS5leHBvcnRzfXZhciBpPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7Zm9yKHZhciBvPTA7bzxyLmxlbmd0aDtvKyspcyhyW29dKTtyZXR1cm4gc30pKHsxOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcclxuKGZ1bmN0aW9uIChnbG9iYWwpe1xyXG5cclxudmFyIFJlc2l6ZVNlbnNvciA9IHJlcXVpcmUoJ2Nzcy1lbGVtZW50LXF1ZXJpZXMvc3JjL1Jlc2l6ZVNlbnNvcicpXHJcbnZhciBSZXNpemVTZW5zb3IgPSByZXF1aXJlKCdjc3MtZWxlbWVudC1xdWVyaWVzL3NyYy9SZXNpemVTZW5zb3InKVxyXG52YXIgUHMgPSByZXF1aXJlKCdwZXJmZWN0LXNjcm9sbGJhcicpXHJcbnZhciBrbyA9ICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93WydrbyddIDogdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbFsna28nXSA6IG51bGwpXHJcblxyXG5mdW5jdGlvbiBnZXRPcHRzKGFjYykge1xyXG4gICAgdmFyIG9wdHMgPSBrby51bndyYXAoYWNjKCkpXHJcbiAgICBpZiAob3B0cy54ID09PSB1bmRlZmluZWQpIG9wdHMueCA9IHRydWVcclxuICAgIGlmIChvcHRzLnkgPT09IHVuZGVmaW5lZCkgb3B0cy55ID0gdHJ1ZVxyXG4gICAgcmV0dXJuIG9wdHNcclxufVxyXG5cclxuZnVuY3Rpb24gcHNPcHRzKG9wdHMpIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgc3VwcHJlc3NTY3JvbGxYOiAhb3B0cy54LFxyXG4gICAgICAgIHN1cHByZXNzU2Nyb2xsWTogIW9wdHMueSxcclxuICAgIH1cclxufVxyXG5cclxudmFyIHNjcm9sbEJpbmRpbmcgPSB7XHJcbiAgICBpbml0OiBmdW5jdGlvbiAoZWxlbWVudCwgdmFsQWNjLCBiaW5kaW5ncywgdm0sIGN0eCkge1xyXG4gICAgICAgIHZhciBvcHRzID0gZ2V0T3B0cyh2YWxBY2MpXHJcbiAgICAgICAgUHMuaW5pdGlhbGl6ZShlbGVtZW50LCBwc09wdHMob3B0cykpXHJcbiAgICAgICAgdmFyIHNlbnNvciA9IG5ldyBSZXNpemVTZW5zb3IoZWxlbWVudCwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBQcy51cGRhdGUoZWxlbWVudClcclxuICAgICAgICB9KVxyXG4gICAgICAgIGtvLnV0aWxzLmRvbU5vZGVEaXNwb3NhbC5hZGREaXNwb3NlQ2FsbGJhY2soZWxlbWVudCwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBzZW5zb3IuZGV0YWNoKClcclxuICAgICAgICAgICAgUHMuZGVzdHJveShlbGVtZW50KVxyXG4gICAgICAgIH0pXHJcbiAgICB9LFxyXG4gICAgdXBkYXRlOiBmdW5jdGlvbiAoZWxlbWVudCwgdmFsQWNjLCBiaW5kaW5ncywgdm0sIGN0eCkge1xyXG4gICAgICAgIHZhciBvcHRzID0gZ2V0T3B0cyh2YWxBY2MpXHJcbiAgICAgICAgaWYgKGN0eC5fZmlyc3RVcGRhdGVDb21wbGV0ZSkge1xyXG4gICAgICAgICAgICBQcy5kZXN0cm95KGVsZW1lbnQpXHJcbiAgICAgICAgICAgIGtvLmJpbmRpbmdIYW5kbGVycy5zY3JvbGwuaW5pdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBPYmplY3QuYXNzaWduKGVsZW1lbnQuc3R5bGUsIHtcclxuICAgICAgICAgICAgb3ZlcmZsb3dYOiBvcHRzLnggPyAnc2Nyb2xsJyA6ICdoaWRkZW4nLFxyXG4gICAgICAgICAgICBvdmVyZmxvd1k6IG9wdHMueSA/ICdzY3JvbGwnIDogJ2hpZGRlbicsXHJcbiAgICAgICAgfSlcclxuICAgICAgICBjdHguX2ZpcnN0VXBkYXRlQ29tcGxldGUgPSB0cnVlXHJcbiAgICB9LFxyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGtvLmJpbmRpbmdIYW5kbGVycy5zY3JvbGwgPSBzY3JvbGxCaW5kaW5nXHJcblxyXG59KS5jYWxsKHRoaXMsdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSlcclxufSx7XCJjc3MtZWxlbWVudC1xdWVyaWVzL3NyYy9SZXNpemVTZW5zb3JcIjoyLFwicGVyZmVjdC1zY3JvbGxiYXJcIjozfV0sMjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XHJcbi8qKlxyXG4gKiBDb3B5cmlnaHQgTWFyYyBKLiBTY2htaWR0LiBTZWUgdGhlIExJQ0VOU0UgZmlsZSBhdCB0aGUgdG9wLWxldmVsXHJcbiAqIGRpcmVjdG9yeSBvZiB0aGlzIGRpc3RyaWJ1dGlvbiBhbmQgYXRcclxuICogaHR0cHM6Ly9naXRodWIuY29tL21hcmNqL2Nzcy1lbGVtZW50LXF1ZXJpZXMvYmxvYi9tYXN0ZXIvTElDRU5TRS5cclxuICovXHJcbjtcclxuKGZ1bmN0aW9uKCkge1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ2xhc3MgZm9yIGRpbWVuc2lvbiBjaGFuZ2UgZGV0ZWN0aW9uLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7RWxlbWVudHxFbGVtZW50W118RWxlbWVudHN8alF1ZXJ5fSBlbGVtZW50XHJcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xyXG4gICAgICpcclxuICAgICAqIEBjb25zdHJ1Y3RvclxyXG4gICAgICovXHJcbiAgICB2YXIgUmVzaXplU2Vuc29yID0gZnVuY3Rpb24oZWxlbWVudCwgY2FsbGJhY2spIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBjb25zdHJ1Y3RvclxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGZ1bmN0aW9uIEV2ZW50UXVldWUoKSB7XHJcbiAgICAgICAgICAgIHRoaXMucSA9IFtdO1xyXG4gICAgICAgICAgICB0aGlzLmFkZCA9IGZ1bmN0aW9uKGV2KSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnEucHVzaChldik7XHJcbiAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICB2YXIgaSwgajtcclxuICAgICAgICAgICAgdGhpcy5jYWxsID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwLCBqID0gdGhpcy5xLmxlbmd0aDsgaSA8IGo7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucVtpXS5jYWxsKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50XHJcbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9ICAgICAgcHJvcFxyXG4gICAgICAgICAqIEByZXR1cm5zIHtTdHJpbmd8TnVtYmVyfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGZ1bmN0aW9uIGdldENvbXB1dGVkU3R5bGUoZWxlbWVudCwgcHJvcCkge1xyXG4gICAgICAgICAgICBpZiAoZWxlbWVudC5jdXJyZW50U3R5bGUpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBlbGVtZW50LmN1cnJlbnRTdHlsZVtwcm9wXTtcclxuICAgICAgICAgICAgfSBlbHNlIGlmICh3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQsIG51bGwpLmdldFByb3BlcnR5VmFsdWUocHJvcCk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZWxlbWVudC5zdHlsZVtwcm9wXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50XHJcbiAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gICAgcmVzaXplZFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGZ1bmN0aW9uIGF0dGFjaFJlc2l6ZUV2ZW50KGVsZW1lbnQsIHJlc2l6ZWQpIHtcclxuICAgICAgICAgICAgaWYgKCFlbGVtZW50LnJlc2l6ZWRBdHRhY2hlZCkge1xyXG4gICAgICAgICAgICAgICAgZWxlbWVudC5yZXNpemVkQXR0YWNoZWQgPSBuZXcgRXZlbnRRdWV1ZSgpO1xyXG4gICAgICAgICAgICAgICAgZWxlbWVudC5yZXNpemVkQXR0YWNoZWQuYWRkKHJlc2l6ZWQpO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGVsZW1lbnQucmVzaXplZEF0dGFjaGVkKSB7XHJcbiAgICAgICAgICAgICAgICBlbGVtZW50LnJlc2l6ZWRBdHRhY2hlZC5hZGQocmVzaXplZCk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGVsZW1lbnQucmVzaXplU2Vuc29yID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XHJcbiAgICAgICAgICAgIGVsZW1lbnQucmVzaXplU2Vuc29yLmNsYXNzTmFtZSA9ICdyZXNpemUtc2Vuc29yJztcclxuICAgICAgICAgICAgdmFyIHN0eWxlID0gJ3Bvc2l0aW9uOiBhYnNvbHV0ZTsgbGVmdDogMDsgdG9wOiAwOyByaWdodDogMDsgYm90dG9tOiAwOyBvdmVyZmxvdzogaGlkZGVuOyB6LWluZGV4OiAtMTsgdmlzaWJpbGl0eTogaGlkZGVuOyc7XHJcbiAgICAgICAgICAgIHZhciBzdHlsZUNoaWxkID0gJ3Bvc2l0aW9uOiBhYnNvbHV0ZTsgbGVmdDogMDsgdG9wOiAwOyB0cmFuc2l0aW9uOiAwczsnO1xyXG5cclxuICAgICAgICAgICAgZWxlbWVudC5yZXNpemVTZW5zb3Iuc3R5bGUuY3NzVGV4dCA9IHN0eWxlO1xyXG4gICAgICAgICAgICBlbGVtZW50LnJlc2l6ZVNlbnNvci5pbm5lckhUTUwgPVxyXG4gICAgICAgICAgICAgICAgJzxkaXYgY2xhc3M9XCJyZXNpemUtc2Vuc29yLWV4cGFuZFwiIHN0eWxlPVwiJyArIHN0eWxlICsgJ1wiPicgK1xyXG4gICAgICAgICAgICAgICAgICAgICc8ZGl2IHN0eWxlPVwiJyArIHN0eWxlQ2hpbGQgKyAnXCI+PC9kaXY+JyArXHJcbiAgICAgICAgICAgICAgICAnPC9kaXY+JyArXHJcbiAgICAgICAgICAgICAgICAnPGRpdiBjbGFzcz1cInJlc2l6ZS1zZW5zb3Itc2hyaW5rXCIgc3R5bGU9XCInICsgc3R5bGUgKyAnXCI+JyArXHJcbiAgICAgICAgICAgICAgICAgICAgJzxkaXYgc3R5bGU9XCInICsgc3R5bGVDaGlsZCArICcgd2lkdGg6IDIwMCU7IGhlaWdodDogMjAwJVwiPjwvZGl2PicgK1xyXG4gICAgICAgICAgICAgICAgJzwvZGl2Pic7XHJcbiAgICAgICAgICAgIGVsZW1lbnQuYXBwZW5kQ2hpbGQoZWxlbWVudC5yZXNpemVTZW5zb3IpO1xyXG5cclxuICAgICAgICAgICAgaWYgKCF7Zml4ZWQ6IDEsIGFic29sdXRlOiAxfVtnZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQsICdwb3NpdGlvbicpXSkge1xyXG4gICAgICAgICAgICAgICAgZWxlbWVudC5zdHlsZS5wb3NpdGlvbiA9ICdyZWxhdGl2ZSc7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHZhciBleHBhbmQgPSBlbGVtZW50LnJlc2l6ZVNlbnNvci5jaGlsZE5vZGVzWzBdO1xyXG4gICAgICAgICAgICB2YXIgZXhwYW5kQ2hpbGQgPSBleHBhbmQuY2hpbGROb2Rlc1swXTtcclxuICAgICAgICAgICAgdmFyIHNocmluayA9IGVsZW1lbnQucmVzaXplU2Vuc29yLmNoaWxkTm9kZXNbMV07XHJcbiAgICAgICAgICAgIHZhciBzaHJpbmtDaGlsZCA9IHNocmluay5jaGlsZE5vZGVzWzBdO1xyXG5cclxuICAgICAgICAgICAgdmFyIGxhc3RXaWR0aCwgbGFzdEhlaWdodDtcclxuXHJcbiAgICAgICAgICAgIHZhciByZXNldCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgZXhwYW5kQ2hpbGQuc3R5bGUud2lkdGggPSBleHBhbmQub2Zmc2V0V2lkdGggKyAxMCArICdweCc7XHJcbiAgICAgICAgICAgICAgICBleHBhbmRDaGlsZC5zdHlsZS5oZWlnaHQgPSBleHBhbmQub2Zmc2V0SGVpZ2h0ICsgMTAgKyAncHgnO1xyXG4gICAgICAgICAgICAgICAgZXhwYW5kLnNjcm9sbExlZnQgPSBleHBhbmQuc2Nyb2xsV2lkdGg7XHJcbiAgICAgICAgICAgICAgICBleHBhbmQuc2Nyb2xsVG9wID0gZXhwYW5kLnNjcm9sbEhlaWdodDtcclxuICAgICAgICAgICAgICAgIHNocmluay5zY3JvbGxMZWZ0ID0gc2hyaW5rLnNjcm9sbFdpZHRoO1xyXG4gICAgICAgICAgICAgICAgc2hyaW5rLnNjcm9sbFRvcCA9IHNocmluay5zY3JvbGxIZWlnaHQ7XHJcbiAgICAgICAgICAgICAgICBsYXN0V2lkdGggPSBlbGVtZW50Lm9mZnNldFdpZHRoO1xyXG4gICAgICAgICAgICAgICAgbGFzdEhlaWdodCA9IGVsZW1lbnQub2Zmc2V0SGVpZ2h0O1xyXG4gICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgcmVzZXQoKTtcclxuXHJcbiAgICAgICAgICAgIHZhciBjaGFuZ2VkID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZWxlbWVudC5yZXNpemVkQXR0YWNoZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICBlbGVtZW50LnJlc2l6ZWRBdHRhY2hlZC5jYWxsKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICB2YXIgYWRkRXZlbnQgPSBmdW5jdGlvbihlbCwgbmFtZSwgY2IpIHtcclxuICAgICAgICAgICAgICAgIGlmIChlbC5hdHRhY2hFdmVudCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGVsLmF0dGFjaEV2ZW50KCdvbicgKyBuYW1lLCBjYik7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIobmFtZSwgY2IpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgdmFyIG9uU2Nyb2xsID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgaWYgKGVsZW1lbnQub2Zmc2V0V2lkdGggIT0gbGFzdFdpZHRoIHx8IGVsZW1lbnQub2Zmc2V0SGVpZ2h0ICE9IGxhc3RIZWlnaHQpIHtcclxuICAgICAgICAgICAgICAgICAgY2hhbmdlZCgpO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICByZXNldCgpO1xyXG4gICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgYWRkRXZlbnQoZXhwYW5kLCAnc2Nyb2xsJywgb25TY3JvbGwpO1xyXG4gICAgICAgICAgICBhZGRFdmVudChzaHJpbmssICdzY3JvbGwnLCBvblNjcm9sbCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgZWxlbWVudFR5cGUgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoZWxlbWVudCk7XHJcbiAgICAgICAgdmFyIGlzQ29sbGVjdGlvblR5cGVkID0gKCdbb2JqZWN0IEFycmF5XScgPT09IGVsZW1lbnRUeXBlXHJcbiAgICAgICAgICAgIHx8ICgnW29iamVjdCBOb2RlTGlzdF0nID09PSBlbGVtZW50VHlwZSlcclxuICAgICAgICAgICAgfHwgKCdbb2JqZWN0IEhUTUxDb2xsZWN0aW9uXScgPT09IGVsZW1lbnRUeXBlKVxyXG4gICAgICAgICAgICB8fCAoJ3VuZGVmaW5lZCcgIT09IHR5cGVvZiBqUXVlcnkgJiYgZWxlbWVudCBpbnN0YW5jZW9mIGpRdWVyeSkgLy9qcXVlcnlcclxuICAgICAgICAgICAgfHwgKCd1bmRlZmluZWQnICE9PSB0eXBlb2YgRWxlbWVudHMgJiYgZWxlbWVudCBpbnN0YW5jZW9mIEVsZW1lbnRzKSAvL21vb3Rvb2xzXHJcbiAgICAgICAgKTtcclxuXHJcbiAgICAgICAgaWYgKGlzQ29sbGVjdGlvblR5cGVkKSB7XHJcbiAgICAgICAgICAgIHZhciBpID0gMCwgaiA9IGVsZW1lbnQubGVuZ3RoO1xyXG4gICAgICAgICAgICBmb3IgKDsgaSA8IGo7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgYXR0YWNoUmVzaXplRXZlbnQoZWxlbWVudFtpXSwgY2FsbGJhY2spO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgYXR0YWNoUmVzaXplRXZlbnQoZWxlbWVudCwgY2FsbGJhY2spO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5kZXRhY2ggPSBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgaWYgKGlzQ29sbGVjdGlvblR5cGVkKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgaSA9IDAsIGogPSBlbGVtZW50Lmxlbmd0aDtcclxuICAgICAgICAgICAgICAgIGZvciAoOyBpIDwgajsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgUmVzaXplU2Vuc29yLmRldGFjaChlbGVtZW50W2ldKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIFJlc2l6ZVNlbnNvci5kZXRhY2goZWxlbWVudCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgfTtcclxuXHJcbiAgICBSZXNpemVTZW5zb3IuZGV0YWNoID0gZnVuY3Rpb24oZWxlbWVudCkge1xyXG4gICAgICAgIGlmIChlbGVtZW50LnJlc2l6ZVNlbnNvcikge1xyXG4gICAgICAgICAgICBlbGVtZW50LnJlbW92ZUNoaWxkKGVsZW1lbnQucmVzaXplU2Vuc29yKTtcclxuICAgICAgICAgICAgZGVsZXRlIGVsZW1lbnQucmVzaXplU2Vuc29yO1xyXG4gICAgICAgICAgICBkZWxldGUgZWxlbWVudC5yZXNpemVkQXR0YWNoZWQ7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICAvLyBtYWtlIGF2YWlsYWJsZSB0byBjb21tb24gbW9kdWxlIGxvYWRlclxyXG4gICAgaWYgKHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBtb2R1bGUuZXhwb3J0cyAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IFJlc2l6ZVNlbnNvcjtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHdpbmRvdy5SZXNpemVTZW5zb3IgPSBSZXNpemVTZW5zb3I7XHJcbiAgICB9XHJcblxyXG59KSgpO1xyXG5cclxufSx7fV0sMzpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XHJcbid1c2Ugc3RyaWN0JztcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9zcmMvanMvbWFpbicpO1xyXG5cclxufSx7XCIuL3NyYy9qcy9tYWluXCI6OX1dLDQ6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xyXG4ndXNlIHN0cmljdCc7XHJcblxyXG5mdW5jdGlvbiBvbGRBZGQoZWxlbWVudCwgY2xhc3NOYW1lKSB7XHJcbiAgdmFyIGNsYXNzZXMgPSBlbGVtZW50LmNsYXNzTmFtZS5zcGxpdCgnICcpO1xyXG4gIGlmIChjbGFzc2VzLmluZGV4T2YoY2xhc3NOYW1lKSA8IDApIHtcclxuICAgIGNsYXNzZXMucHVzaChjbGFzc05hbWUpO1xyXG4gIH1cclxuICBlbGVtZW50LmNsYXNzTmFtZSA9IGNsYXNzZXMuam9pbignICcpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBvbGRSZW1vdmUoZWxlbWVudCwgY2xhc3NOYW1lKSB7XHJcbiAgdmFyIGNsYXNzZXMgPSBlbGVtZW50LmNsYXNzTmFtZS5zcGxpdCgnICcpO1xyXG4gIHZhciBpZHggPSBjbGFzc2VzLmluZGV4T2YoY2xhc3NOYW1lKTtcclxuICBpZiAoaWR4ID49IDApIHtcclxuICAgIGNsYXNzZXMuc3BsaWNlKGlkeCwgMSk7XHJcbiAgfVxyXG4gIGVsZW1lbnQuY2xhc3NOYW1lID0gY2xhc3Nlcy5qb2luKCcgJyk7XHJcbn1cclxuXHJcbmV4cG9ydHMuYWRkID0gZnVuY3Rpb24gKGVsZW1lbnQsIGNsYXNzTmFtZSkge1xyXG4gIGlmIChlbGVtZW50LmNsYXNzTGlzdCkge1xyXG4gICAgZWxlbWVudC5jbGFzc0xpc3QuYWRkKGNsYXNzTmFtZSk7XHJcbiAgfSBlbHNlIHtcclxuICAgIG9sZEFkZChlbGVtZW50LCBjbGFzc05hbWUpO1xyXG4gIH1cclxufTtcclxuXHJcbmV4cG9ydHMucmVtb3ZlID0gZnVuY3Rpb24gKGVsZW1lbnQsIGNsYXNzTmFtZSkge1xyXG4gIGlmIChlbGVtZW50LmNsYXNzTGlzdCkge1xyXG4gICAgZWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKGNsYXNzTmFtZSk7XHJcbiAgfSBlbHNlIHtcclxuICAgIG9sZFJlbW92ZShlbGVtZW50LCBjbGFzc05hbWUpO1xyXG4gIH1cclxufTtcclxuXHJcbmV4cG9ydHMubGlzdCA9IGZ1bmN0aW9uIChlbGVtZW50KSB7XHJcbiAgaWYgKGVsZW1lbnQuY2xhc3NMaXN0KSB7XHJcbiAgICByZXR1cm4gQXJyYXkucHJvdG90eXBlLnNsaWNlLmFwcGx5KGVsZW1lbnQuY2xhc3NMaXN0KTtcclxuICB9IGVsc2Uge1xyXG4gICAgcmV0dXJuIGVsZW1lbnQuY2xhc3NOYW1lLnNwbGl0KCcgJyk7XHJcbiAgfVxyXG59O1xyXG5cclxufSx7fV0sNTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XHJcbid1c2Ugc3RyaWN0JztcclxuXHJcbnZhciBET00gPSB7fTtcclxuXHJcbkRPTS5lID0gZnVuY3Rpb24gKHRhZ05hbWUsIGNsYXNzTmFtZSkge1xyXG4gIHZhciBlbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWdOYW1lKTtcclxuICBlbGVtZW50LmNsYXNzTmFtZSA9IGNsYXNzTmFtZTtcclxuICByZXR1cm4gZWxlbWVudDtcclxufTtcclxuXHJcbkRPTS5hcHBlbmRUbyA9IGZ1bmN0aW9uIChjaGlsZCwgcGFyZW50KSB7XHJcbiAgcGFyZW50LmFwcGVuZENoaWxkKGNoaWxkKTtcclxuICByZXR1cm4gY2hpbGQ7XHJcbn07XHJcblxyXG5mdW5jdGlvbiBjc3NHZXQoZWxlbWVudCwgc3R5bGVOYW1lKSB7XHJcbiAgcmV0dXJuIHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpW3N0eWxlTmFtZV07XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNzc1NldChlbGVtZW50LCBzdHlsZU5hbWUsIHN0eWxlVmFsdWUpIHtcclxuICBpZiAodHlwZW9mIHN0eWxlVmFsdWUgPT09ICdudW1iZXInKSB7XHJcbiAgICBzdHlsZVZhbHVlID0gc3R5bGVWYWx1ZS50b1N0cmluZygpICsgJ3B4JztcclxuICB9XHJcbiAgZWxlbWVudC5zdHlsZVtzdHlsZU5hbWVdID0gc3R5bGVWYWx1ZTtcclxuICByZXR1cm4gZWxlbWVudDtcclxufVxyXG5cclxuZnVuY3Rpb24gY3NzTXVsdGlTZXQoZWxlbWVudCwgb2JqKSB7XHJcbiAgZm9yICh2YXIga2V5IGluIG9iaikge1xyXG4gICAgdmFyIHZhbCA9IG9ialtrZXldO1xyXG4gICAgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XHJcbiAgICAgIHZhbCA9IHZhbC50b1N0cmluZygpICsgJ3B4JztcclxuICAgIH1cclxuICAgIGVsZW1lbnQuc3R5bGVba2V5XSA9IHZhbDtcclxuICB9XHJcbiAgcmV0dXJuIGVsZW1lbnQ7XHJcbn1cclxuXHJcbkRPTS5jc3MgPSBmdW5jdGlvbiAoZWxlbWVudCwgc3R5bGVOYW1lT3JPYmplY3QsIHN0eWxlVmFsdWUpIHtcclxuICBpZiAodHlwZW9mIHN0eWxlTmFtZU9yT2JqZWN0ID09PSAnb2JqZWN0Jykge1xyXG4gICAgLy8gbXVsdGlwbGUgc2V0IHdpdGggb2JqZWN0XHJcbiAgICByZXR1cm4gY3NzTXVsdGlTZXQoZWxlbWVudCwgc3R5bGVOYW1lT3JPYmplY3QpO1xyXG4gIH0gZWxzZSB7XHJcbiAgICBpZiAodHlwZW9mIHN0eWxlVmFsdWUgPT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgIHJldHVybiBjc3NHZXQoZWxlbWVudCwgc3R5bGVOYW1lT3JPYmplY3QpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgcmV0dXJuIGNzc1NldChlbGVtZW50LCBzdHlsZU5hbWVPck9iamVjdCwgc3R5bGVWYWx1ZSk7XHJcbiAgICB9XHJcbiAgfVxyXG59O1xyXG5cclxuRE9NLm1hdGNoZXMgPSBmdW5jdGlvbiAoZWxlbWVudCwgcXVlcnkpIHtcclxuICBpZiAodHlwZW9mIGVsZW1lbnQubWF0Y2hlcyAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgIHJldHVybiBlbGVtZW50Lm1hdGNoZXMocXVlcnkpO1xyXG4gIH0gZWxzZSB7XHJcbiAgICBpZiAodHlwZW9mIGVsZW1lbnQubWF0Y2hlc1NlbGVjdG9yICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICByZXR1cm4gZWxlbWVudC5tYXRjaGVzU2VsZWN0b3IocXVlcnkpO1xyXG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZWxlbWVudC53ZWJraXRNYXRjaGVzU2VsZWN0b3IgIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgIHJldHVybiBlbGVtZW50LndlYmtpdE1hdGNoZXNTZWxlY3RvcihxdWVyeSk7XHJcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBlbGVtZW50Lm1vek1hdGNoZXNTZWxlY3RvciAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgcmV0dXJuIGVsZW1lbnQubW96TWF0Y2hlc1NlbGVjdG9yKHF1ZXJ5KTtcclxuICAgIH0gZWxzZSBpZiAodHlwZW9mIGVsZW1lbnQubXNNYXRjaGVzU2VsZWN0b3IgIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgIHJldHVybiBlbGVtZW50Lm1zTWF0Y2hlc1NlbGVjdG9yKHF1ZXJ5KTtcclxuICAgIH1cclxuICB9XHJcbn07XHJcblxyXG5ET00ucmVtb3ZlID0gZnVuY3Rpb24gKGVsZW1lbnQpIHtcclxuICBpZiAodHlwZW9mIGVsZW1lbnQucmVtb3ZlICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgZWxlbWVudC5yZW1vdmUoKTtcclxuICB9IGVsc2Uge1xyXG4gICAgaWYgKGVsZW1lbnQucGFyZW50Tm9kZSkge1xyXG4gICAgICBlbGVtZW50LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZWxlbWVudCk7XHJcbiAgICB9XHJcbiAgfVxyXG59O1xyXG5cclxuRE9NLnF1ZXJ5Q2hpbGRyZW4gPSBmdW5jdGlvbiAoZWxlbWVudCwgc2VsZWN0b3IpIHtcclxuICByZXR1cm4gQXJyYXkucHJvdG90eXBlLmZpbHRlci5jYWxsKGVsZW1lbnQuY2hpbGROb2RlcywgZnVuY3Rpb24gKGNoaWxkKSB7XHJcbiAgICByZXR1cm4gRE9NLm1hdGNoZXMoY2hpbGQsIHNlbGVjdG9yKTtcclxuICB9KTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gRE9NO1xyXG5cclxufSx7fV0sNjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XHJcbid1c2Ugc3RyaWN0JztcclxuXHJcbnZhciBFdmVudEVsZW1lbnQgPSBmdW5jdGlvbiAoZWxlbWVudCkge1xyXG4gIHRoaXMuZWxlbWVudCA9IGVsZW1lbnQ7XHJcbiAgdGhpcy5ldmVudHMgPSB7fTtcclxufTtcclxuXHJcbkV2ZW50RWxlbWVudC5wcm90b3R5cGUuYmluZCA9IGZ1bmN0aW9uIChldmVudE5hbWUsIGhhbmRsZXIpIHtcclxuICBpZiAodHlwZW9mIHRoaXMuZXZlbnRzW2V2ZW50TmFtZV0gPT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICB0aGlzLmV2ZW50c1tldmVudE5hbWVdID0gW107XHJcbiAgfVxyXG4gIHRoaXMuZXZlbnRzW2V2ZW50TmFtZV0ucHVzaChoYW5kbGVyKTtcclxuICB0aGlzLmVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIGhhbmRsZXIsIGZhbHNlKTtcclxufTtcclxuXHJcbkV2ZW50RWxlbWVudC5wcm90b3R5cGUudW5iaW5kID0gZnVuY3Rpb24gKGV2ZW50TmFtZSwgaGFuZGxlcikge1xyXG4gIHZhciBpc0hhbmRsZXJQcm92aWRlZCA9ICh0eXBlb2YgaGFuZGxlciAhPT0gJ3VuZGVmaW5lZCcpO1xyXG4gIHRoaXMuZXZlbnRzW2V2ZW50TmFtZV0gPSB0aGlzLmV2ZW50c1tldmVudE5hbWVdLmZpbHRlcihmdW5jdGlvbiAoaGRscikge1xyXG4gICAgaWYgKGlzSGFuZGxlclByb3ZpZGVkICYmIGhkbHIgIT09IGhhbmRsZXIpIHtcclxuICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbiAgICB0aGlzLmVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIGhkbHIsIGZhbHNlKTtcclxuICAgIHJldHVybiBmYWxzZTtcclxuICB9LCB0aGlzKTtcclxufTtcclxuXHJcbkV2ZW50RWxlbWVudC5wcm90b3R5cGUudW5iaW5kQWxsID0gZnVuY3Rpb24gKCkge1xyXG4gIGZvciAodmFyIG5hbWUgaW4gdGhpcy5ldmVudHMpIHtcclxuICAgIHRoaXMudW5iaW5kKG5hbWUpO1xyXG4gIH1cclxufTtcclxuXHJcbnZhciBFdmVudE1hbmFnZXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgdGhpcy5ldmVudEVsZW1lbnRzID0gW107XHJcbn07XHJcblxyXG5FdmVudE1hbmFnZXIucHJvdG90eXBlLmV2ZW50RWxlbWVudCA9IGZ1bmN0aW9uIChlbGVtZW50KSB7XHJcbiAgdmFyIGVlID0gdGhpcy5ldmVudEVsZW1lbnRzLmZpbHRlcihmdW5jdGlvbiAoZXZlbnRFbGVtZW50KSB7XHJcbiAgICByZXR1cm4gZXZlbnRFbGVtZW50LmVsZW1lbnQgPT09IGVsZW1lbnQ7XHJcbiAgfSlbMF07XHJcbiAgaWYgKHR5cGVvZiBlZSA9PT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgIGVlID0gbmV3IEV2ZW50RWxlbWVudChlbGVtZW50KTtcclxuICAgIHRoaXMuZXZlbnRFbGVtZW50cy5wdXNoKGVlKTtcclxuICB9XHJcbiAgcmV0dXJuIGVlO1xyXG59O1xyXG5cclxuRXZlbnRNYW5hZ2VyLnByb3RvdHlwZS5iaW5kID0gZnVuY3Rpb24gKGVsZW1lbnQsIGV2ZW50TmFtZSwgaGFuZGxlcikge1xyXG4gIHRoaXMuZXZlbnRFbGVtZW50KGVsZW1lbnQpLmJpbmQoZXZlbnROYW1lLCBoYW5kbGVyKTtcclxufTtcclxuXHJcbkV2ZW50TWFuYWdlci5wcm90b3R5cGUudW5iaW5kID0gZnVuY3Rpb24gKGVsZW1lbnQsIGV2ZW50TmFtZSwgaGFuZGxlcikge1xyXG4gIHRoaXMuZXZlbnRFbGVtZW50KGVsZW1lbnQpLnVuYmluZChldmVudE5hbWUsIGhhbmRsZXIpO1xyXG59O1xyXG5cclxuRXZlbnRNYW5hZ2VyLnByb3RvdHlwZS51bmJpbmRBbGwgPSBmdW5jdGlvbiAoKSB7XHJcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmV2ZW50RWxlbWVudHMubGVuZ3RoOyBpKyspIHtcclxuICAgIHRoaXMuZXZlbnRFbGVtZW50c1tpXS51bmJpbmRBbGwoKTtcclxuICB9XHJcbn07XHJcblxyXG5FdmVudE1hbmFnZXIucHJvdG90eXBlLm9uY2UgPSBmdW5jdGlvbiAoZWxlbWVudCwgZXZlbnROYW1lLCBoYW5kbGVyKSB7XHJcbiAgdmFyIGVlID0gdGhpcy5ldmVudEVsZW1lbnQoZWxlbWVudCk7XHJcbiAgdmFyIG9uY2VIYW5kbGVyID0gZnVuY3Rpb24gKGUpIHtcclxuICAgIGVlLnVuYmluZChldmVudE5hbWUsIG9uY2VIYW5kbGVyKTtcclxuICAgIGhhbmRsZXIoZSk7XHJcbiAgfTtcclxuICBlZS5iaW5kKGV2ZW50TmFtZSwgb25jZUhhbmRsZXIpO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBFdmVudE1hbmFnZXI7XHJcblxyXG59LHt9XSw3OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSAoZnVuY3Rpb24gKCkge1xyXG4gIGZ1bmN0aW9uIHM0KCkge1xyXG4gICAgcmV0dXJuIE1hdGguZmxvb3IoKDEgKyBNYXRoLnJhbmRvbSgpKSAqIDB4MTAwMDApXHJcbiAgICAgICAgICAgICAgIC50b1N0cmluZygxNilcclxuICAgICAgICAgICAgICAgLnN1YnN0cmluZygxKTtcclxuICB9XHJcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcclxuICAgIHJldHVybiBzNCgpICsgczQoKSArICctJyArIHM0KCkgKyAnLScgKyBzNCgpICsgJy0nICtcclxuICAgICAgICAgICBzNCgpICsgJy0nICsgczQoKSArIHM0KCkgKyBzNCgpO1xyXG4gIH07XHJcbn0pKCk7XHJcblxyXG59LHt9XSw4OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyIGNscyA9IHJlcXVpcmUoJy4vY2xhc3MnKTtcclxudmFyIGRvbSA9IHJlcXVpcmUoJy4vZG9tJyk7XHJcblxyXG52YXIgdG9JbnQgPSBleHBvcnRzLnRvSW50ID0gZnVuY3Rpb24gKHgpIHtcclxuICByZXR1cm4gcGFyc2VJbnQoeCwgMTApIHx8IDA7XHJcbn07XHJcblxyXG52YXIgY2xvbmUgPSBleHBvcnRzLmNsb25lID0gZnVuY3Rpb24gKG9iaikge1xyXG4gIGlmIChvYmogPT09IG51bGwpIHtcclxuICAgIHJldHVybiBudWxsO1xyXG4gIH0gZWxzZSBpZiAob2JqLmNvbnN0cnVjdG9yID09PSBBcnJheSkge1xyXG4gICAgcmV0dXJuIG9iai5tYXAoY2xvbmUpO1xyXG4gIH0gZWxzZSBpZiAodHlwZW9mIG9iaiA9PT0gJ29iamVjdCcpIHtcclxuICAgIHZhciByZXN1bHQgPSB7fTtcclxuICAgIGZvciAodmFyIGtleSBpbiBvYmopIHtcclxuICAgICAgcmVzdWx0W2tleV0gPSBjbG9uZShvYmpba2V5XSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG4gIH0gZWxzZSB7XHJcbiAgICByZXR1cm4gb2JqO1xyXG4gIH1cclxufTtcclxuXHJcbmV4cG9ydHMuZXh0ZW5kID0gZnVuY3Rpb24gKG9yaWdpbmFsLCBzb3VyY2UpIHtcclxuICB2YXIgcmVzdWx0ID0gY2xvbmUob3JpZ2luYWwpO1xyXG4gIGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHtcclxuICAgIHJlc3VsdFtrZXldID0gY2xvbmUoc291cmNlW2tleV0pO1xyXG4gIH1cclxuICByZXR1cm4gcmVzdWx0O1xyXG59O1xyXG5cclxuZXhwb3J0cy5pc0VkaXRhYmxlID0gZnVuY3Rpb24gKGVsKSB7XHJcbiAgcmV0dXJuIGRvbS5tYXRjaGVzKGVsLCBcImlucHV0LFtjb250ZW50ZWRpdGFibGVdXCIpIHx8XHJcbiAgICAgICAgIGRvbS5tYXRjaGVzKGVsLCBcInNlbGVjdCxbY29udGVudGVkaXRhYmxlXVwiKSB8fFxyXG4gICAgICAgICBkb20ubWF0Y2hlcyhlbCwgXCJ0ZXh0YXJlYSxbY29udGVudGVkaXRhYmxlXVwiKSB8fFxyXG4gICAgICAgICBkb20ubWF0Y2hlcyhlbCwgXCJidXR0b24sW2NvbnRlbnRlZGl0YWJsZV1cIik7XHJcbn07XHJcblxyXG5leHBvcnRzLnJlbW92ZVBzQ2xhc3NlcyA9IGZ1bmN0aW9uIChlbGVtZW50KSB7XHJcbiAgdmFyIGNsc0xpc3QgPSBjbHMubGlzdChlbGVtZW50KTtcclxuICBmb3IgKHZhciBpID0gMDsgaSA8IGNsc0xpc3QubGVuZ3RoOyBpKyspIHtcclxuICAgIHZhciBjbGFzc05hbWUgPSBjbHNMaXN0W2ldO1xyXG4gICAgaWYgKGNsYXNzTmFtZS5pbmRleE9mKCdwcy0nKSA9PT0gMCkge1xyXG4gICAgICBjbHMucmVtb3ZlKGVsZW1lbnQsIGNsYXNzTmFtZSk7XHJcbiAgICB9XHJcbiAgfVxyXG59O1xyXG5cclxuZXhwb3J0cy5vdXRlcldpZHRoID0gZnVuY3Rpb24gKGVsZW1lbnQpIHtcclxuICByZXR1cm4gdG9JbnQoZG9tLmNzcyhlbGVtZW50LCAnd2lkdGgnKSkgK1xyXG4gICAgICAgICB0b0ludChkb20uY3NzKGVsZW1lbnQsICdwYWRkaW5nTGVmdCcpKSArXHJcbiAgICAgICAgIHRvSW50KGRvbS5jc3MoZWxlbWVudCwgJ3BhZGRpbmdSaWdodCcpKSArXHJcbiAgICAgICAgIHRvSW50KGRvbS5jc3MoZWxlbWVudCwgJ2JvcmRlckxlZnRXaWR0aCcpKSArXHJcbiAgICAgICAgIHRvSW50KGRvbS5jc3MoZWxlbWVudCwgJ2JvcmRlclJpZ2h0V2lkdGgnKSk7XHJcbn07XHJcblxyXG5leHBvcnRzLnN0YXJ0U2Nyb2xsaW5nID0gZnVuY3Rpb24gKGVsZW1lbnQsIGF4aXMpIHtcclxuICBjbHMuYWRkKGVsZW1lbnQsICdwcy1pbi1zY3JvbGxpbmcnKTtcclxuICBpZiAodHlwZW9mIGF4aXMgIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICBjbHMuYWRkKGVsZW1lbnQsICdwcy0nICsgYXhpcyk7XHJcbiAgfSBlbHNlIHtcclxuICAgIGNscy5hZGQoZWxlbWVudCwgJ3BzLXgnKTtcclxuICAgIGNscy5hZGQoZWxlbWVudCwgJ3BzLXknKTtcclxuICB9XHJcbn07XHJcblxyXG5leHBvcnRzLnN0b3BTY3JvbGxpbmcgPSBmdW5jdGlvbiAoZWxlbWVudCwgYXhpcykge1xyXG4gIGNscy5yZW1vdmUoZWxlbWVudCwgJ3BzLWluLXNjcm9sbGluZycpO1xyXG4gIGlmICh0eXBlb2YgYXhpcyAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgIGNscy5yZW1vdmUoZWxlbWVudCwgJ3BzLScgKyBheGlzKTtcclxuICB9IGVsc2Uge1xyXG4gICAgY2xzLnJlbW92ZShlbGVtZW50LCAncHMteCcpO1xyXG4gICAgY2xzLnJlbW92ZShlbGVtZW50LCAncHMteScpO1xyXG4gIH1cclxufTtcclxuXHJcbmV4cG9ydHMuZW52ID0ge1xyXG4gIGlzV2ViS2l0OiAnV2Via2l0QXBwZWFyYW5jZScgaW4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlLFxyXG4gIHN1cHBvcnRzVG91Y2g6ICgoJ29udG91Y2hzdGFydCcgaW4gd2luZG93KSB8fCB3aW5kb3cuRG9jdW1lbnRUb3VjaCAmJiBkb2N1bWVudCBpbnN0YW5jZW9mIHdpbmRvdy5Eb2N1bWVudFRvdWNoKSxcclxuICBzdXBwb3J0c0llUG9pbnRlcjogd2luZG93Lm5hdmlnYXRvci5tc01heFRvdWNoUG9pbnRzICE9PSBudWxsXHJcbn07XHJcblxyXG59LHtcIi4vY2xhc3NcIjo0LFwiLi9kb21cIjo1fV0sOTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XHJcbid1c2Ugc3RyaWN0JztcclxuXHJcbnZhciBkZXN0cm95ID0gcmVxdWlyZSgnLi9wbHVnaW4vZGVzdHJveScpO1xyXG52YXIgaW5pdGlhbGl6ZSA9IHJlcXVpcmUoJy4vcGx1Z2luL2luaXRpYWxpemUnKTtcclxudmFyIHVwZGF0ZSA9IHJlcXVpcmUoJy4vcGx1Z2luL3VwZGF0ZScpO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSB7XHJcbiAgaW5pdGlhbGl6ZTogaW5pdGlhbGl6ZSxcclxuICB1cGRhdGU6IHVwZGF0ZSxcclxuICBkZXN0cm95OiBkZXN0cm95XHJcbn07XHJcblxyXG59LHtcIi4vcGx1Z2luL2Rlc3Ryb3lcIjoxMSxcIi4vcGx1Z2luL2luaXRpYWxpemVcIjoxOSxcIi4vcGx1Z2luL3VwZGF0ZVwiOjIzfV0sMTA6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xyXG4ndXNlIHN0cmljdCc7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IHtcclxuICBoYW5kbGVyczogWydjbGljay1yYWlsJywgJ2RyYWctc2Nyb2xsYmFyJywgJ2tleWJvYXJkJywgJ3doZWVsJywgJ3RvdWNoJ10sXHJcbiAgbWF4U2Nyb2xsYmFyTGVuZ3RoOiBudWxsLFxyXG4gIG1pblNjcm9sbGJhckxlbmd0aDogbnVsbCxcclxuICBzY3JvbGxYTWFyZ2luT2Zmc2V0OiAwLFxyXG4gIHNjcm9sbFlNYXJnaW5PZmZzZXQ6IDAsXHJcbiAgc3RvcFByb3BhZ2F0aW9uT25DbGljazogdHJ1ZSxcclxuICBzdXBwcmVzc1Njcm9sbFg6IGZhbHNlLFxyXG4gIHN1cHByZXNzU2Nyb2xsWTogZmFsc2UsXHJcbiAgc3dpcGVQcm9wYWdhdGlvbjogdHJ1ZSxcclxuICB1c2VCb3RoV2hlZWxBeGVzOiBmYWxzZSxcclxuICB3aGVlbFByb3BhZ2F0aW9uOiBmYWxzZSxcclxuICB3aGVlbFNwZWVkOiAxLFxyXG4gIHRoZW1lOiAnZGVmYXVsdCdcclxufTtcclxuXHJcbn0se31dLDExOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyIF8gPSByZXF1aXJlKCcuLi9saWIvaGVscGVyJyk7XHJcbnZhciBkb20gPSByZXF1aXJlKCcuLi9saWIvZG9tJyk7XHJcbnZhciBpbnN0YW5jZXMgPSByZXF1aXJlKCcuL2luc3RhbmNlcycpO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZWxlbWVudCkge1xyXG4gIHZhciBpID0gaW5zdGFuY2VzLmdldChlbGVtZW50KTtcclxuXHJcbiAgaWYgKCFpKSB7XHJcbiAgICByZXR1cm47XHJcbiAgfVxyXG5cclxuICBpLmV2ZW50LnVuYmluZEFsbCgpO1xyXG4gIGRvbS5yZW1vdmUoaS5zY3JvbGxiYXJYKTtcclxuICBkb20ucmVtb3ZlKGkuc2Nyb2xsYmFyWSk7XHJcbiAgZG9tLnJlbW92ZShpLnNjcm9sbGJhclhSYWlsKTtcclxuICBkb20ucmVtb3ZlKGkuc2Nyb2xsYmFyWVJhaWwpO1xyXG4gIF8ucmVtb3ZlUHNDbGFzc2VzKGVsZW1lbnQpO1xyXG5cclxuICBpbnN0YW5jZXMucmVtb3ZlKGVsZW1lbnQpO1xyXG59O1xyXG5cclxufSx7XCIuLi9saWIvZG9tXCI6NSxcIi4uL2xpYi9oZWxwZXJcIjo4LFwiLi9pbnN0YW5jZXNcIjoyMH1dLDEyOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyIF8gPSByZXF1aXJlKCcuLi8uLi9saWIvaGVscGVyJyk7XHJcbnZhciBpbnN0YW5jZXMgPSByZXF1aXJlKCcuLi9pbnN0YW5jZXMnKTtcclxudmFyIHVwZGF0ZUdlb21ldHJ5ID0gcmVxdWlyZSgnLi4vdXBkYXRlLWdlb21ldHJ5Jyk7XHJcbnZhciB1cGRhdGVTY3JvbGwgPSByZXF1aXJlKCcuLi91cGRhdGUtc2Nyb2xsJyk7XHJcblxyXG5mdW5jdGlvbiBiaW5kQ2xpY2tSYWlsSGFuZGxlcihlbGVtZW50LCBpKSB7XHJcbiAgZnVuY3Rpb24gcGFnZU9mZnNldChlbCkge1xyXG4gICAgcmV0dXJuIGVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xyXG4gIH1cclxuICB2YXIgc3RvcFByb3BhZ2F0aW9uID0gZnVuY3Rpb24gKGUpIHsgZS5zdG9wUHJvcGFnYXRpb24oKTsgfTtcclxuXHJcbiAgaWYgKGkuc2V0dGluZ3Muc3RvcFByb3BhZ2F0aW9uT25DbGljaykge1xyXG4gICAgaS5ldmVudC5iaW5kKGkuc2Nyb2xsYmFyWSwgJ2NsaWNrJywgc3RvcFByb3BhZ2F0aW9uKTtcclxuICB9XHJcbiAgaS5ldmVudC5iaW5kKGkuc2Nyb2xsYmFyWVJhaWwsICdjbGljaycsIGZ1bmN0aW9uIChlKSB7XHJcbiAgICB2YXIgaGFsZk9mU2Nyb2xsYmFyTGVuZ3RoID0gXy50b0ludChpLnNjcm9sbGJhcllIZWlnaHQgLyAyKTtcclxuICAgIHZhciBwb3NpdGlvblRvcCA9IGkucmFpbFlSYXRpbyAqIChlLnBhZ2VZIC0gd2luZG93LnBhZ2VZT2Zmc2V0IC0gcGFnZU9mZnNldChpLnNjcm9sbGJhcllSYWlsKS50b3AgLSBoYWxmT2ZTY3JvbGxiYXJMZW5ndGgpO1xyXG4gICAgdmFyIG1heFBvc2l0aW9uVG9wID0gaS5yYWlsWVJhdGlvICogKGkucmFpbFlIZWlnaHQgLSBpLnNjcm9sbGJhcllIZWlnaHQpO1xyXG4gICAgdmFyIHBvc2l0aW9uUmF0aW8gPSBwb3NpdGlvblRvcCAvIG1heFBvc2l0aW9uVG9wO1xyXG5cclxuICAgIGlmIChwb3NpdGlvblJhdGlvIDwgMCkge1xyXG4gICAgICBwb3NpdGlvblJhdGlvID0gMDtcclxuICAgIH0gZWxzZSBpZiAocG9zaXRpb25SYXRpbyA+IDEpIHtcclxuICAgICAgcG9zaXRpb25SYXRpbyA9IDE7XHJcbiAgICB9XHJcblxyXG4gICAgdXBkYXRlU2Nyb2xsKGVsZW1lbnQsICd0b3AnLCAoaS5jb250ZW50SGVpZ2h0IC0gaS5jb250YWluZXJIZWlnaHQpICogcG9zaXRpb25SYXRpbyk7XHJcbiAgICB1cGRhdGVHZW9tZXRyeShlbGVtZW50KTtcclxuXHJcbiAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xyXG4gIH0pO1xyXG5cclxuICBpZiAoaS5zZXR0aW5ncy5zdG9wUHJvcGFnYXRpb25PbkNsaWNrKSB7XHJcbiAgICBpLmV2ZW50LmJpbmQoaS5zY3JvbGxiYXJYLCAnY2xpY2snLCBzdG9wUHJvcGFnYXRpb24pO1xyXG4gIH1cclxuICBpLmV2ZW50LmJpbmQoaS5zY3JvbGxiYXJYUmFpbCwgJ2NsaWNrJywgZnVuY3Rpb24gKGUpIHtcclxuICAgIHZhciBoYWxmT2ZTY3JvbGxiYXJMZW5ndGggPSBfLnRvSW50KGkuc2Nyb2xsYmFyWFdpZHRoIC8gMik7XHJcbiAgICB2YXIgcG9zaXRpb25MZWZ0ID0gaS5yYWlsWFJhdGlvICogKGUucGFnZVggLSB3aW5kb3cucGFnZVhPZmZzZXQgLSBwYWdlT2Zmc2V0KGkuc2Nyb2xsYmFyWFJhaWwpLmxlZnQgLSBoYWxmT2ZTY3JvbGxiYXJMZW5ndGgpO1xyXG4gICAgdmFyIG1heFBvc2l0aW9uTGVmdCA9IGkucmFpbFhSYXRpbyAqIChpLnJhaWxYV2lkdGggLSBpLnNjcm9sbGJhclhXaWR0aCk7XHJcbiAgICB2YXIgcG9zaXRpb25SYXRpbyA9IHBvc2l0aW9uTGVmdCAvIG1heFBvc2l0aW9uTGVmdDtcclxuXHJcbiAgICBpZiAocG9zaXRpb25SYXRpbyA8IDApIHtcclxuICAgICAgcG9zaXRpb25SYXRpbyA9IDA7XHJcbiAgICB9IGVsc2UgaWYgKHBvc2l0aW9uUmF0aW8gPiAxKSB7XHJcbiAgICAgIHBvc2l0aW9uUmF0aW8gPSAxO1xyXG4gICAgfVxyXG5cclxuICAgIHVwZGF0ZVNjcm9sbChlbGVtZW50LCAnbGVmdCcsICgoaS5jb250ZW50V2lkdGggLSBpLmNvbnRhaW5lcldpZHRoKSAqIHBvc2l0aW9uUmF0aW8pIC0gaS5uZWdhdGl2ZVNjcm9sbEFkanVzdG1lbnQpO1xyXG4gICAgdXBkYXRlR2VvbWV0cnkoZWxlbWVudCk7XHJcblxyXG4gICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcclxuICB9KTtcclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZWxlbWVudCkge1xyXG4gIHZhciBpID0gaW5zdGFuY2VzLmdldChlbGVtZW50KTtcclxuICBiaW5kQ2xpY2tSYWlsSGFuZGxlcihlbGVtZW50LCBpKTtcclxufTtcclxuXHJcbn0se1wiLi4vLi4vbGliL2hlbHBlclwiOjgsXCIuLi9pbnN0YW5jZXNcIjoyMCxcIi4uL3VwZGF0ZS1nZW9tZXRyeVwiOjIxLFwiLi4vdXBkYXRlLXNjcm9sbFwiOjIyfV0sMTM6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xyXG4ndXNlIHN0cmljdCc7XHJcblxyXG52YXIgXyA9IHJlcXVpcmUoJy4uLy4uL2xpYi9oZWxwZXInKTtcclxudmFyIGRvbSA9IHJlcXVpcmUoJy4uLy4uL2xpYi9kb20nKTtcclxudmFyIGluc3RhbmNlcyA9IHJlcXVpcmUoJy4uL2luc3RhbmNlcycpO1xyXG52YXIgdXBkYXRlR2VvbWV0cnkgPSByZXF1aXJlKCcuLi91cGRhdGUtZ2VvbWV0cnknKTtcclxudmFyIHVwZGF0ZVNjcm9sbCA9IHJlcXVpcmUoJy4uL3VwZGF0ZS1zY3JvbGwnKTtcclxuXHJcbmZ1bmN0aW9uIGJpbmRNb3VzZVNjcm9sbFhIYW5kbGVyKGVsZW1lbnQsIGkpIHtcclxuICB2YXIgY3VycmVudExlZnQgPSBudWxsO1xyXG4gIHZhciBjdXJyZW50UGFnZVggPSBudWxsO1xyXG5cclxuICBmdW5jdGlvbiB1cGRhdGVTY3JvbGxMZWZ0KGRlbHRhWCkge1xyXG4gICAgdmFyIG5ld0xlZnQgPSBjdXJyZW50TGVmdCArIChkZWx0YVggKiBpLnJhaWxYUmF0aW8pO1xyXG4gICAgdmFyIG1heExlZnQgPSBNYXRoLm1heCgwLCBpLnNjcm9sbGJhclhSYWlsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmxlZnQpICsgKGkucmFpbFhSYXRpbyAqIChpLnJhaWxYV2lkdGggLSBpLnNjcm9sbGJhclhXaWR0aCkpO1xyXG5cclxuICAgIGlmIChuZXdMZWZ0IDwgMCkge1xyXG4gICAgICBpLnNjcm9sbGJhclhMZWZ0ID0gMDtcclxuICAgIH0gZWxzZSBpZiAobmV3TGVmdCA+IG1heExlZnQpIHtcclxuICAgICAgaS5zY3JvbGxiYXJYTGVmdCA9IG1heExlZnQ7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBpLnNjcm9sbGJhclhMZWZ0ID0gbmV3TGVmdDtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgc2Nyb2xsTGVmdCA9IF8udG9JbnQoaS5zY3JvbGxiYXJYTGVmdCAqIChpLmNvbnRlbnRXaWR0aCAtIGkuY29udGFpbmVyV2lkdGgpIC8gKGkuY29udGFpbmVyV2lkdGggLSAoaS5yYWlsWFJhdGlvICogaS5zY3JvbGxiYXJYV2lkdGgpKSkgLSBpLm5lZ2F0aXZlU2Nyb2xsQWRqdXN0bWVudDtcclxuICAgIHVwZGF0ZVNjcm9sbChlbGVtZW50LCAnbGVmdCcsIHNjcm9sbExlZnQpO1xyXG4gIH1cclxuXHJcbiAgdmFyIG1vdXNlTW92ZUhhbmRsZXIgPSBmdW5jdGlvbiAoZSkge1xyXG4gICAgdXBkYXRlU2Nyb2xsTGVmdChlLnBhZ2VYIC0gY3VycmVudFBhZ2VYKTtcclxuICAgIHVwZGF0ZUdlb21ldHJ5KGVsZW1lbnQpO1xyXG4gICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcclxuICAgIGUucHJldmVudERlZmF1bHQoKTtcclxuICB9O1xyXG5cclxuICB2YXIgbW91c2VVcEhhbmRsZXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICBfLnN0b3BTY3JvbGxpbmcoZWxlbWVudCwgJ3gnKTtcclxuICAgIGkuZXZlbnQudW5iaW5kKGkub3duZXJEb2N1bWVudCwgJ21vdXNlbW92ZScsIG1vdXNlTW92ZUhhbmRsZXIpO1xyXG4gIH07XHJcblxyXG4gIGkuZXZlbnQuYmluZChpLnNjcm9sbGJhclgsICdtb3VzZWRvd24nLCBmdW5jdGlvbiAoZSkge1xyXG4gICAgY3VycmVudFBhZ2VYID0gZS5wYWdlWDtcclxuICAgIGN1cnJlbnRMZWZ0ID0gXy50b0ludChkb20uY3NzKGkuc2Nyb2xsYmFyWCwgJ2xlZnQnKSkgKiBpLnJhaWxYUmF0aW87XHJcbiAgICBfLnN0YXJ0U2Nyb2xsaW5nKGVsZW1lbnQsICd4Jyk7XHJcblxyXG4gICAgaS5ldmVudC5iaW5kKGkub3duZXJEb2N1bWVudCwgJ21vdXNlbW92ZScsIG1vdXNlTW92ZUhhbmRsZXIpO1xyXG4gICAgaS5ldmVudC5vbmNlKGkub3duZXJEb2N1bWVudCwgJ21vdXNldXAnLCBtb3VzZVVwSGFuZGxlcik7XHJcblxyXG4gICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcclxuICAgIGUucHJldmVudERlZmF1bHQoKTtcclxuICB9KTtcclxufVxyXG5cclxuZnVuY3Rpb24gYmluZE1vdXNlU2Nyb2xsWUhhbmRsZXIoZWxlbWVudCwgaSkge1xyXG4gIHZhciBjdXJyZW50VG9wID0gbnVsbDtcclxuICB2YXIgY3VycmVudFBhZ2VZID0gbnVsbDtcclxuXHJcbiAgZnVuY3Rpb24gdXBkYXRlU2Nyb2xsVG9wKGRlbHRhWSkge1xyXG4gICAgdmFyIG5ld1RvcCA9IGN1cnJlbnRUb3AgKyAoZGVsdGFZICogaS5yYWlsWVJhdGlvKTtcclxuICAgIHZhciBtYXhUb3AgPSBNYXRoLm1heCgwLCBpLnNjcm9sbGJhcllSYWlsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLnRvcCkgKyAoaS5yYWlsWVJhdGlvICogKGkucmFpbFlIZWlnaHQgLSBpLnNjcm9sbGJhcllIZWlnaHQpKTtcclxuXHJcbiAgICBpZiAobmV3VG9wIDwgMCkge1xyXG4gICAgICBpLnNjcm9sbGJhcllUb3AgPSAwO1xyXG4gICAgfSBlbHNlIGlmIChuZXdUb3AgPiBtYXhUb3ApIHtcclxuICAgICAgaS5zY3JvbGxiYXJZVG9wID0gbWF4VG9wO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgaS5zY3JvbGxiYXJZVG9wID0gbmV3VG9wO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBzY3JvbGxUb3AgPSBfLnRvSW50KGkuc2Nyb2xsYmFyWVRvcCAqIChpLmNvbnRlbnRIZWlnaHQgLSBpLmNvbnRhaW5lckhlaWdodCkgLyAoaS5jb250YWluZXJIZWlnaHQgLSAoaS5yYWlsWVJhdGlvICogaS5zY3JvbGxiYXJZSGVpZ2h0KSkpO1xyXG4gICAgdXBkYXRlU2Nyb2xsKGVsZW1lbnQsICd0b3AnLCBzY3JvbGxUb3ApO1xyXG4gIH1cclxuXHJcbiAgdmFyIG1vdXNlTW92ZUhhbmRsZXIgPSBmdW5jdGlvbiAoZSkge1xyXG4gICAgdXBkYXRlU2Nyb2xsVG9wKGUucGFnZVkgLSBjdXJyZW50UGFnZVkpO1xyXG4gICAgdXBkYXRlR2VvbWV0cnkoZWxlbWVudCk7XHJcbiAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xyXG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gIH07XHJcblxyXG4gIHZhciBtb3VzZVVwSGFuZGxlciA9IGZ1bmN0aW9uICgpIHtcclxuICAgIF8uc3RvcFNjcm9sbGluZyhlbGVtZW50LCAneScpO1xyXG4gICAgaS5ldmVudC51bmJpbmQoaS5vd25lckRvY3VtZW50LCAnbW91c2Vtb3ZlJywgbW91c2VNb3ZlSGFuZGxlcik7XHJcbiAgfTtcclxuXHJcbiAgaS5ldmVudC5iaW5kKGkuc2Nyb2xsYmFyWSwgJ21vdXNlZG93bicsIGZ1bmN0aW9uIChlKSB7XHJcbiAgICBjdXJyZW50UGFnZVkgPSBlLnBhZ2VZO1xyXG4gICAgY3VycmVudFRvcCA9IF8udG9JbnQoZG9tLmNzcyhpLnNjcm9sbGJhclksICd0b3AnKSkgKiBpLnJhaWxZUmF0aW87XHJcbiAgICBfLnN0YXJ0U2Nyb2xsaW5nKGVsZW1lbnQsICd5Jyk7XHJcblxyXG4gICAgaS5ldmVudC5iaW5kKGkub3duZXJEb2N1bWVudCwgJ21vdXNlbW92ZScsIG1vdXNlTW92ZUhhbmRsZXIpO1xyXG4gICAgaS5ldmVudC5vbmNlKGkub3duZXJEb2N1bWVudCwgJ21vdXNldXAnLCBtb3VzZVVwSGFuZGxlcik7XHJcblxyXG4gICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcclxuICAgIGUucHJldmVudERlZmF1bHQoKTtcclxuICB9KTtcclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZWxlbWVudCkge1xyXG4gIHZhciBpID0gaW5zdGFuY2VzLmdldChlbGVtZW50KTtcclxuICBiaW5kTW91c2VTY3JvbGxYSGFuZGxlcihlbGVtZW50LCBpKTtcclxuICBiaW5kTW91c2VTY3JvbGxZSGFuZGxlcihlbGVtZW50LCBpKTtcclxufTtcclxuXHJcbn0se1wiLi4vLi4vbGliL2RvbVwiOjUsXCIuLi8uLi9saWIvaGVscGVyXCI6OCxcIi4uL2luc3RhbmNlc1wiOjIwLFwiLi4vdXBkYXRlLWdlb21ldHJ5XCI6MjEsXCIuLi91cGRhdGUtc2Nyb2xsXCI6MjJ9XSwxNDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XHJcbid1c2Ugc3RyaWN0JztcclxuXHJcbnZhciBfID0gcmVxdWlyZSgnLi4vLi4vbGliL2hlbHBlcicpO1xyXG52YXIgZG9tID0gcmVxdWlyZSgnLi4vLi4vbGliL2RvbScpO1xyXG52YXIgaW5zdGFuY2VzID0gcmVxdWlyZSgnLi4vaW5zdGFuY2VzJyk7XHJcbnZhciB1cGRhdGVHZW9tZXRyeSA9IHJlcXVpcmUoJy4uL3VwZGF0ZS1nZW9tZXRyeScpO1xyXG52YXIgdXBkYXRlU2Nyb2xsID0gcmVxdWlyZSgnLi4vdXBkYXRlLXNjcm9sbCcpO1xyXG5cclxuZnVuY3Rpb24gYmluZEtleWJvYXJkSGFuZGxlcihlbGVtZW50LCBpKSB7XHJcbiAgdmFyIGhvdmVyZWQgPSBmYWxzZTtcclxuICBpLmV2ZW50LmJpbmQoZWxlbWVudCwgJ21vdXNlZW50ZXInLCBmdW5jdGlvbiAoKSB7XHJcbiAgICBob3ZlcmVkID0gdHJ1ZTtcclxuICB9KTtcclxuICBpLmV2ZW50LmJpbmQoZWxlbWVudCwgJ21vdXNlbGVhdmUnLCBmdW5jdGlvbiAoKSB7XHJcbiAgICBob3ZlcmVkID0gZmFsc2U7XHJcbiAgfSk7XHJcblxyXG4gIHZhciBzaG91bGRQcmV2ZW50ID0gZmFsc2U7XHJcbiAgZnVuY3Rpb24gc2hvdWxkUHJldmVudERlZmF1bHQoZGVsdGFYLCBkZWx0YVkpIHtcclxuICAgIHZhciBzY3JvbGxUb3AgPSBlbGVtZW50LnNjcm9sbFRvcDtcclxuICAgIGlmIChkZWx0YVggPT09IDApIHtcclxuICAgICAgaWYgKCFpLnNjcm9sbGJhcllBY3RpdmUpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKChzY3JvbGxUb3AgPT09IDAgJiYgZGVsdGFZID4gMCkgfHwgKHNjcm9sbFRvcCA+PSBpLmNvbnRlbnRIZWlnaHQgLSBpLmNvbnRhaW5lckhlaWdodCAmJiBkZWx0YVkgPCAwKSkge1xyXG4gICAgICAgIHJldHVybiAhaS5zZXR0aW5ncy53aGVlbFByb3BhZ2F0aW9uO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIHNjcm9sbExlZnQgPSBlbGVtZW50LnNjcm9sbExlZnQ7XHJcbiAgICBpZiAoZGVsdGFZID09PSAwKSB7XHJcbiAgICAgIGlmICghaS5zY3JvbGxiYXJYQWN0aXZlKSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICB9XHJcbiAgICAgIGlmICgoc2Nyb2xsTGVmdCA9PT0gMCAmJiBkZWx0YVggPCAwKSB8fCAoc2Nyb2xsTGVmdCA+PSBpLmNvbnRlbnRXaWR0aCAtIGkuY29udGFpbmVyV2lkdGggJiYgZGVsdGFYID4gMCkpIHtcclxuICAgICAgICByZXR1cm4gIWkuc2V0dGluZ3Mud2hlZWxQcm9wYWdhdGlvbjtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRydWU7XHJcbiAgfVxyXG5cclxuICBpLmV2ZW50LmJpbmQoaS5vd25lckRvY3VtZW50LCAna2V5ZG93bicsIGZ1bmN0aW9uIChlKSB7XHJcbiAgICBpZiAoKGUuaXNEZWZhdWx0UHJldmVudGVkICYmIGUuaXNEZWZhdWx0UHJldmVudGVkKCkpIHx8IGUuZGVmYXVsdFByZXZlbnRlZCkge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIGZvY3VzZWQgPSBkb20ubWF0Y2hlcyhpLnNjcm9sbGJhclgsICc6Zm9jdXMnKSB8fFxyXG4gICAgICAgICAgICAgICAgICBkb20ubWF0Y2hlcyhpLnNjcm9sbGJhclksICc6Zm9jdXMnKTtcclxuXHJcbiAgICBpZiAoIWhvdmVyZWQgJiYgIWZvY3VzZWQpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBhY3RpdmVFbGVtZW50ID0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudCA/IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgOiBpLm93bmVyRG9jdW1lbnQuYWN0aXZlRWxlbWVudDtcclxuICAgIGlmIChhY3RpdmVFbGVtZW50KSB7XHJcbiAgICAgIGlmIChhY3RpdmVFbGVtZW50LnRhZ05hbWUgPT09ICdJRlJBTUUnKSB7XHJcbiAgICAgICAgYWN0aXZlRWxlbWVudCA9IGFjdGl2ZUVsZW1lbnQuY29udGVudERvY3VtZW50LmFjdGl2ZUVsZW1lbnQ7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgLy8gZ28gZGVlcGVyIGlmIGVsZW1lbnQgaXMgYSB3ZWJjb21wb25lbnRcclxuICAgICAgICB3aGlsZSAoYWN0aXZlRWxlbWVudC5zaGFkb3dSb290KSB7XHJcbiAgICAgICAgICBhY3RpdmVFbGVtZW50ID0gYWN0aXZlRWxlbWVudC5zaGFkb3dSb290LmFjdGl2ZUVsZW1lbnQ7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIGlmIChfLmlzRWRpdGFibGUoYWN0aXZlRWxlbWVudCkpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICB2YXIgZGVsdGFYID0gMDtcclxuICAgIHZhciBkZWx0YVkgPSAwO1xyXG5cclxuICAgIHN3aXRjaCAoZS53aGljaCkge1xyXG4gICAgY2FzZSAzNzogLy8gbGVmdFxyXG4gICAgICBkZWx0YVggPSAtMzA7XHJcbiAgICAgIGJyZWFrO1xyXG4gICAgY2FzZSAzODogLy8gdXBcclxuICAgICAgZGVsdGFZID0gMzA7XHJcbiAgICAgIGJyZWFrO1xyXG4gICAgY2FzZSAzOTogLy8gcmlnaHRcclxuICAgICAgZGVsdGFYID0gMzA7XHJcbiAgICAgIGJyZWFrO1xyXG4gICAgY2FzZSA0MDogLy8gZG93blxyXG4gICAgICBkZWx0YVkgPSAtMzA7XHJcbiAgICAgIGJyZWFrO1xyXG4gICAgY2FzZSAzMzogLy8gcGFnZSB1cFxyXG4gICAgICBkZWx0YVkgPSA5MDtcclxuICAgICAgYnJlYWs7XHJcbiAgICBjYXNlIDMyOiAvLyBzcGFjZSBiYXJcclxuICAgICAgaWYgKGUuc2hpZnRLZXkpIHtcclxuICAgICAgICBkZWx0YVkgPSA5MDtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBkZWx0YVkgPSAtOTA7XHJcbiAgICAgIH1cclxuICAgICAgYnJlYWs7XHJcbiAgICBjYXNlIDM0OiAvLyBwYWdlIGRvd25cclxuICAgICAgZGVsdGFZID0gLTkwO1xyXG4gICAgICBicmVhaztcclxuICAgIGNhc2UgMzU6IC8vIGVuZFxyXG4gICAgICBpZiAoZS5jdHJsS2V5KSB7XHJcbiAgICAgICAgZGVsdGFZID0gLWkuY29udGVudEhlaWdodDtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBkZWx0YVkgPSAtaS5jb250YWluZXJIZWlnaHQ7XHJcbiAgICAgIH1cclxuICAgICAgYnJlYWs7XHJcbiAgICBjYXNlIDM2OiAvLyBob21lXHJcbiAgICAgIGlmIChlLmN0cmxLZXkpIHtcclxuICAgICAgICBkZWx0YVkgPSBlbGVtZW50LnNjcm9sbFRvcDtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBkZWx0YVkgPSBpLmNvbnRhaW5lckhlaWdodDtcclxuICAgICAgfVxyXG4gICAgICBicmVhaztcclxuICAgIGRlZmF1bHQ6XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICB1cGRhdGVTY3JvbGwoZWxlbWVudCwgJ3RvcCcsIGVsZW1lbnQuc2Nyb2xsVG9wIC0gZGVsdGFZKTtcclxuICAgIHVwZGF0ZVNjcm9sbChlbGVtZW50LCAnbGVmdCcsIGVsZW1lbnQuc2Nyb2xsTGVmdCArIGRlbHRhWCk7XHJcbiAgICB1cGRhdGVHZW9tZXRyeShlbGVtZW50KTtcclxuXHJcbiAgICBzaG91bGRQcmV2ZW50ID0gc2hvdWxkUHJldmVudERlZmF1bHQoZGVsdGFYLCBkZWx0YVkpO1xyXG4gICAgaWYgKHNob3VsZFByZXZlbnQpIHtcclxuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgfVxyXG4gIH0pO1xyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChlbGVtZW50KSB7XHJcbiAgdmFyIGkgPSBpbnN0YW5jZXMuZ2V0KGVsZW1lbnQpO1xyXG4gIGJpbmRLZXlib2FyZEhhbmRsZXIoZWxlbWVudCwgaSk7XHJcbn07XHJcblxyXG59LHtcIi4uLy4uL2xpYi9kb21cIjo1LFwiLi4vLi4vbGliL2hlbHBlclwiOjgsXCIuLi9pbnN0YW5jZXNcIjoyMCxcIi4uL3VwZGF0ZS1nZW9tZXRyeVwiOjIxLFwiLi4vdXBkYXRlLXNjcm9sbFwiOjIyfV0sMTU6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xyXG4ndXNlIHN0cmljdCc7XHJcblxyXG52YXIgaW5zdGFuY2VzID0gcmVxdWlyZSgnLi4vaW5zdGFuY2VzJyk7XHJcbnZhciB1cGRhdGVHZW9tZXRyeSA9IHJlcXVpcmUoJy4uL3VwZGF0ZS1nZW9tZXRyeScpO1xyXG52YXIgdXBkYXRlU2Nyb2xsID0gcmVxdWlyZSgnLi4vdXBkYXRlLXNjcm9sbCcpO1xyXG5cclxuZnVuY3Rpb24gYmluZE1vdXNlV2hlZWxIYW5kbGVyKGVsZW1lbnQsIGkpIHtcclxuICB2YXIgc2hvdWxkUHJldmVudCA9IGZhbHNlO1xyXG5cclxuICBmdW5jdGlvbiBzaG91bGRQcmV2ZW50RGVmYXVsdChkZWx0YVgsIGRlbHRhWSkge1xyXG4gICAgdmFyIHNjcm9sbFRvcCA9IGVsZW1lbnQuc2Nyb2xsVG9wO1xyXG4gICAgaWYgKGRlbHRhWCA9PT0gMCkge1xyXG4gICAgICBpZiAoIWkuc2Nyb2xsYmFyWUFjdGl2ZSkge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgfVxyXG4gICAgICBpZiAoKHNjcm9sbFRvcCA9PT0gMCAmJiBkZWx0YVkgPiAwKSB8fCAoc2Nyb2xsVG9wID49IGkuY29udGVudEhlaWdodCAtIGkuY29udGFpbmVySGVpZ2h0ICYmIGRlbHRhWSA8IDApKSB7XHJcbiAgICAgICAgcmV0dXJuICFpLnNldHRpbmdzLndoZWVsUHJvcGFnYXRpb247XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICB2YXIgc2Nyb2xsTGVmdCA9IGVsZW1lbnQuc2Nyb2xsTGVmdDtcclxuICAgIGlmIChkZWx0YVkgPT09IDApIHtcclxuICAgICAgaWYgKCFpLnNjcm9sbGJhclhBY3RpdmUpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKChzY3JvbGxMZWZ0ID09PSAwICYmIGRlbHRhWCA8IDApIHx8IChzY3JvbGxMZWZ0ID49IGkuY29udGVudFdpZHRoIC0gaS5jb250YWluZXJXaWR0aCAmJiBkZWx0YVggPiAwKSkge1xyXG4gICAgICAgIHJldHVybiAhaS5zZXR0aW5ncy53aGVlbFByb3BhZ2F0aW9uO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdHJ1ZTtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGdldERlbHRhRnJvbUV2ZW50KGUpIHtcclxuICAgIHZhciBkZWx0YVggPSBlLmRlbHRhWDtcclxuICAgIHZhciBkZWx0YVkgPSAtMSAqIGUuZGVsdGFZO1xyXG5cclxuICAgIGlmICh0eXBlb2YgZGVsdGFYID09PSBcInVuZGVmaW5lZFwiIHx8IHR5cGVvZiBkZWx0YVkgPT09IFwidW5kZWZpbmVkXCIpIHtcclxuICAgICAgLy8gT1MgWCBTYWZhcmlcclxuICAgICAgZGVsdGFYID0gLTEgKiBlLndoZWVsRGVsdGFYIC8gNjtcclxuICAgICAgZGVsdGFZID0gZS53aGVlbERlbHRhWSAvIDY7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGUuZGVsdGFNb2RlICYmIGUuZGVsdGFNb2RlID09PSAxKSB7XHJcbiAgICAgIC8vIEZpcmVmb3ggaW4gZGVsdGFNb2RlIDE6IExpbmUgc2Nyb2xsaW5nXHJcbiAgICAgIGRlbHRhWCAqPSAxMDtcclxuICAgICAgZGVsdGFZICo9IDEwO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChkZWx0YVggIT09IGRlbHRhWCAmJiBkZWx0YVkgIT09IGRlbHRhWS8qIE5hTiBjaGVja3MgKi8pIHtcclxuICAgICAgLy8gSUUgaW4gc29tZSBtb3VzZSBkcml2ZXJzXHJcbiAgICAgIGRlbHRhWCA9IDA7XHJcbiAgICAgIGRlbHRhWSA9IGUud2hlZWxEZWx0YTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gW2RlbHRhWCwgZGVsdGFZXTtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIHNob3VsZEJlQ29uc3VtZWRCeUNoaWxkKGRlbHRhWCwgZGVsdGFZKSB7XHJcbiAgICB2YXIgY2hpbGQgPSBlbGVtZW50LnF1ZXJ5U2VsZWN0b3IoJ3RleHRhcmVhOmhvdmVyLCBzZWxlY3RbbXVsdGlwbGVdOmhvdmVyLCAucHMtY2hpbGQ6aG92ZXInKTtcclxuICAgIGlmIChjaGlsZCkge1xyXG4gICAgICBpZiAoY2hpbGQudGFnTmFtZSAhPT0gJ1RFWFRBUkVBJyAmJiAhd2luZG93LmdldENvbXB1dGVkU3R5bGUoY2hpbGQpLm92ZXJmbG93Lm1hdGNoKC8oc2Nyb2xsfGF1dG8pLykpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHZhciBtYXhTY3JvbGxUb3AgPSBjaGlsZC5zY3JvbGxIZWlnaHQgLSBjaGlsZC5jbGllbnRIZWlnaHQ7XHJcbiAgICAgIGlmIChtYXhTY3JvbGxUb3AgPiAwKSB7XHJcbiAgICAgICAgaWYgKCEoY2hpbGQuc2Nyb2xsVG9wID09PSAwICYmIGRlbHRhWSA+IDApICYmICEoY2hpbGQuc2Nyb2xsVG9wID09PSBtYXhTY3JvbGxUb3AgJiYgZGVsdGFZIDwgMCkpIHtcclxuICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICB2YXIgbWF4U2Nyb2xsTGVmdCA9IGNoaWxkLnNjcm9sbExlZnQgLSBjaGlsZC5jbGllbnRXaWR0aDtcclxuICAgICAgaWYgKG1heFNjcm9sbExlZnQgPiAwKSB7XHJcbiAgICAgICAgaWYgKCEoY2hpbGQuc2Nyb2xsTGVmdCA9PT0gMCAmJiBkZWx0YVggPCAwKSAmJiAhKGNoaWxkLnNjcm9sbExlZnQgPT09IG1heFNjcm9sbExlZnQgJiYgZGVsdGFYID4gMCkpIHtcclxuICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gbW91c2V3aGVlbEhhbmRsZXIoZSkge1xyXG4gICAgdmFyIGRlbHRhID0gZ2V0RGVsdGFGcm9tRXZlbnQoZSk7XHJcblxyXG4gICAgdmFyIGRlbHRhWCA9IGRlbHRhWzBdO1xyXG4gICAgdmFyIGRlbHRhWSA9IGRlbHRhWzFdO1xyXG5cclxuICAgIGlmIChzaG91bGRCZUNvbnN1bWVkQnlDaGlsZChkZWx0YVgsIGRlbHRhWSkpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIHNob3VsZFByZXZlbnQgPSBmYWxzZTtcclxuICAgIGlmICghaS5zZXR0aW5ncy51c2VCb3RoV2hlZWxBeGVzKSB7XHJcbiAgICAgIC8vIGRlbHRhWCB3aWxsIG9ubHkgYmUgdXNlZCBmb3IgaG9yaXpvbnRhbCBzY3JvbGxpbmcgYW5kIGRlbHRhWSB3aWxsXHJcbiAgICAgIC8vIG9ubHkgYmUgdXNlZCBmb3IgdmVydGljYWwgc2Nyb2xsaW5nIC0gdGhpcyBpcyB0aGUgZGVmYXVsdFxyXG4gICAgICB1cGRhdGVTY3JvbGwoZWxlbWVudCwgJ3RvcCcsIGVsZW1lbnQuc2Nyb2xsVG9wIC0gKGRlbHRhWSAqIGkuc2V0dGluZ3Mud2hlZWxTcGVlZCkpO1xyXG4gICAgICB1cGRhdGVTY3JvbGwoZWxlbWVudCwgJ2xlZnQnLCBlbGVtZW50LnNjcm9sbExlZnQgKyAoZGVsdGFYICogaS5zZXR0aW5ncy53aGVlbFNwZWVkKSk7XHJcbiAgICB9IGVsc2UgaWYgKGkuc2Nyb2xsYmFyWUFjdGl2ZSAmJiAhaS5zY3JvbGxiYXJYQWN0aXZlKSB7XHJcbiAgICAgIC8vIG9ubHkgdmVydGljYWwgc2Nyb2xsYmFyIGlzIGFjdGl2ZSBhbmQgdXNlQm90aFdoZWVsQXhlcyBvcHRpb24gaXNcclxuICAgICAgLy8gYWN0aXZlLCBzbyBsZXQncyBzY3JvbGwgdmVydGljYWwgYmFyIHVzaW5nIGJvdGggbW91c2Ugd2hlZWwgYXhlc1xyXG4gICAgICBpZiAoZGVsdGFZKSB7XHJcbiAgICAgICAgdXBkYXRlU2Nyb2xsKGVsZW1lbnQsICd0b3AnLCBlbGVtZW50LnNjcm9sbFRvcCAtIChkZWx0YVkgKiBpLnNldHRpbmdzLndoZWVsU3BlZWQpKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICB1cGRhdGVTY3JvbGwoZWxlbWVudCwgJ3RvcCcsIGVsZW1lbnQuc2Nyb2xsVG9wICsgKGRlbHRhWCAqIGkuc2V0dGluZ3Mud2hlZWxTcGVlZCkpO1xyXG4gICAgICB9XHJcbiAgICAgIHNob3VsZFByZXZlbnQgPSB0cnVlO1xyXG4gICAgfSBlbHNlIGlmIChpLnNjcm9sbGJhclhBY3RpdmUgJiYgIWkuc2Nyb2xsYmFyWUFjdGl2ZSkge1xyXG4gICAgICAvLyB1c2VCb3RoV2hlZWxBeGVzIGFuZCBvbmx5IGhvcml6b250YWwgYmFyIGlzIGFjdGl2ZSwgc28gdXNlIGJvdGhcclxuICAgICAgLy8gd2hlZWwgYXhlcyBmb3IgaG9yaXpvbnRhbCBiYXJcclxuICAgICAgaWYgKGRlbHRhWCkge1xyXG4gICAgICAgIHVwZGF0ZVNjcm9sbChlbGVtZW50LCAnbGVmdCcsIGVsZW1lbnQuc2Nyb2xsTGVmdCArIChkZWx0YVggKiBpLnNldHRpbmdzLndoZWVsU3BlZWQpKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICB1cGRhdGVTY3JvbGwoZWxlbWVudCwgJ2xlZnQnLCBlbGVtZW50LnNjcm9sbExlZnQgLSAoZGVsdGFZICogaS5zZXR0aW5ncy53aGVlbFNwZWVkKSk7XHJcbiAgICAgIH1cclxuICAgICAgc2hvdWxkUHJldmVudCA9IHRydWU7XHJcbiAgICB9XHJcblxyXG4gICAgdXBkYXRlR2VvbWV0cnkoZWxlbWVudCk7XHJcblxyXG4gICAgc2hvdWxkUHJldmVudCA9IChzaG91bGRQcmV2ZW50IHx8IHNob3VsZFByZXZlbnREZWZhdWx0KGRlbHRhWCwgZGVsdGFZKSk7XHJcbiAgICBpZiAoc2hvdWxkUHJldmVudCkge1xyXG4gICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xyXG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBpZiAodHlwZW9mIHdpbmRvdy5vbndoZWVsICE9PSBcInVuZGVmaW5lZFwiKSB7XHJcbiAgICBpLmV2ZW50LmJpbmQoZWxlbWVudCwgJ3doZWVsJywgbW91c2V3aGVlbEhhbmRsZXIpO1xyXG4gIH0gZWxzZSBpZiAodHlwZW9mIHdpbmRvdy5vbm1vdXNld2hlZWwgIT09IFwidW5kZWZpbmVkXCIpIHtcclxuICAgIGkuZXZlbnQuYmluZChlbGVtZW50LCAnbW91c2V3aGVlbCcsIG1vdXNld2hlZWxIYW5kbGVyKTtcclxuICB9XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGVsZW1lbnQpIHtcclxuICB2YXIgaSA9IGluc3RhbmNlcy5nZXQoZWxlbWVudCk7XHJcbiAgYmluZE1vdXNlV2hlZWxIYW5kbGVyKGVsZW1lbnQsIGkpO1xyXG59O1xyXG5cclxufSx7XCIuLi9pbnN0YW5jZXNcIjoyMCxcIi4uL3VwZGF0ZS1nZW9tZXRyeVwiOjIxLFwiLi4vdXBkYXRlLXNjcm9sbFwiOjIyfV0sMTY6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xyXG4ndXNlIHN0cmljdCc7XHJcblxyXG52YXIgaW5zdGFuY2VzID0gcmVxdWlyZSgnLi4vaW5zdGFuY2VzJyk7XHJcbnZhciB1cGRhdGVHZW9tZXRyeSA9IHJlcXVpcmUoJy4uL3VwZGF0ZS1nZW9tZXRyeScpO1xyXG5cclxuZnVuY3Rpb24gYmluZE5hdGl2ZVNjcm9sbEhhbmRsZXIoZWxlbWVudCwgaSkge1xyXG4gIGkuZXZlbnQuYmluZChlbGVtZW50LCAnc2Nyb2xsJywgZnVuY3Rpb24gKCkge1xyXG4gICAgdXBkYXRlR2VvbWV0cnkoZWxlbWVudCk7XHJcbiAgfSk7XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGVsZW1lbnQpIHtcclxuICB2YXIgaSA9IGluc3RhbmNlcy5nZXQoZWxlbWVudCk7XHJcbiAgYmluZE5hdGl2ZVNjcm9sbEhhbmRsZXIoZWxlbWVudCwgaSk7XHJcbn07XHJcblxyXG59LHtcIi4uL2luc3RhbmNlc1wiOjIwLFwiLi4vdXBkYXRlLWdlb21ldHJ5XCI6MjF9XSwxNzpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XHJcbid1c2Ugc3RyaWN0JztcclxuXHJcbnZhciBfID0gcmVxdWlyZSgnLi4vLi4vbGliL2hlbHBlcicpO1xyXG52YXIgaW5zdGFuY2VzID0gcmVxdWlyZSgnLi4vaW5zdGFuY2VzJyk7XHJcbnZhciB1cGRhdGVHZW9tZXRyeSA9IHJlcXVpcmUoJy4uL3VwZGF0ZS1nZW9tZXRyeScpO1xyXG52YXIgdXBkYXRlU2Nyb2xsID0gcmVxdWlyZSgnLi4vdXBkYXRlLXNjcm9sbCcpO1xyXG5cclxuZnVuY3Rpb24gYmluZFNlbGVjdGlvbkhhbmRsZXIoZWxlbWVudCwgaSkge1xyXG4gIGZ1bmN0aW9uIGdldFJhbmdlTm9kZSgpIHtcclxuICAgIHZhciBzZWxlY3Rpb24gPSB3aW5kb3cuZ2V0U2VsZWN0aW9uID8gd2luZG93LmdldFNlbGVjdGlvbigpIDpcclxuICAgICAgICAgICAgICAgICAgICBkb2N1bWVudC5nZXRTZWxlY3Rpb24gPyBkb2N1bWVudC5nZXRTZWxlY3Rpb24oKSA6ICcnO1xyXG4gICAgaWYgKHNlbGVjdGlvbi50b1N0cmluZygpLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICByZXR1cm4gbnVsbDtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHJldHVybiBzZWxlY3Rpb24uZ2V0UmFuZ2VBdCgwKS5jb21tb25BbmNlc3RvckNvbnRhaW5lcjtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHZhciBzY3JvbGxpbmdMb29wID0gbnVsbDtcclxuICB2YXIgc2Nyb2xsRGlmZiA9IHt0b3A6IDAsIGxlZnQ6IDB9O1xyXG4gIGZ1bmN0aW9uIHN0YXJ0U2Nyb2xsaW5nKCkge1xyXG4gICAgaWYgKCFzY3JvbGxpbmdMb29wKSB7XHJcbiAgICAgIHNjcm9sbGluZ0xvb3AgPSBzZXRJbnRlcnZhbChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKCFpbnN0YW5jZXMuZ2V0KGVsZW1lbnQpKSB7XHJcbiAgICAgICAgICBjbGVhckludGVydmFsKHNjcm9sbGluZ0xvb3ApO1xyXG4gICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdXBkYXRlU2Nyb2xsKGVsZW1lbnQsICd0b3AnLCBlbGVtZW50LnNjcm9sbFRvcCArIHNjcm9sbERpZmYudG9wKTtcclxuICAgICAgICB1cGRhdGVTY3JvbGwoZWxlbWVudCwgJ2xlZnQnLCBlbGVtZW50LnNjcm9sbExlZnQgKyBzY3JvbGxEaWZmLmxlZnQpO1xyXG4gICAgICAgIHVwZGF0ZUdlb21ldHJ5KGVsZW1lbnQpO1xyXG4gICAgICB9LCA1MCk7IC8vIGV2ZXJ5IC4xIHNlY1xyXG4gICAgfVxyXG4gIH1cclxuICBmdW5jdGlvbiBzdG9wU2Nyb2xsaW5nKCkge1xyXG4gICAgaWYgKHNjcm9sbGluZ0xvb3ApIHtcclxuICAgICAgY2xlYXJJbnRlcnZhbChzY3JvbGxpbmdMb29wKTtcclxuICAgICAgc2Nyb2xsaW5nTG9vcCA9IG51bGw7XHJcbiAgICB9XHJcbiAgICBfLnN0b3BTY3JvbGxpbmcoZWxlbWVudCk7XHJcbiAgfVxyXG5cclxuICB2YXIgaXNTZWxlY3RlZCA9IGZhbHNlO1xyXG4gIGkuZXZlbnQuYmluZChpLm93bmVyRG9jdW1lbnQsICdzZWxlY3Rpb25jaGFuZ2UnLCBmdW5jdGlvbiAoKSB7XHJcbiAgICBpZiAoZWxlbWVudC5jb250YWlucyhnZXRSYW5nZU5vZGUoKSkpIHtcclxuICAgICAgaXNTZWxlY3RlZCA9IHRydWU7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBpc1NlbGVjdGVkID0gZmFsc2U7XHJcbiAgICAgIHN0b3BTY3JvbGxpbmcoKTtcclxuICAgIH1cclxuICB9KTtcclxuICBpLmV2ZW50LmJpbmQod2luZG93LCAnbW91c2V1cCcsIGZ1bmN0aW9uICgpIHtcclxuICAgIGlmIChpc1NlbGVjdGVkKSB7XHJcbiAgICAgIGlzU2VsZWN0ZWQgPSBmYWxzZTtcclxuICAgICAgc3RvcFNjcm9sbGluZygpO1xyXG4gICAgfVxyXG4gIH0pO1xyXG5cclxuICBpLmV2ZW50LmJpbmQod2luZG93LCAnbW91c2Vtb3ZlJywgZnVuY3Rpb24gKGUpIHtcclxuICAgIGlmIChpc1NlbGVjdGVkKSB7XHJcbiAgICAgIHZhciBtb3VzZVBvc2l0aW9uID0ge3g6IGUucGFnZVgsIHk6IGUucGFnZVl9O1xyXG4gICAgICB2YXIgY29udGFpbmVyR2VvbWV0cnkgPSB7XHJcbiAgICAgICAgbGVmdDogZWxlbWVudC5vZmZzZXRMZWZ0LFxyXG4gICAgICAgIHJpZ2h0OiBlbGVtZW50Lm9mZnNldExlZnQgKyBlbGVtZW50Lm9mZnNldFdpZHRoLFxyXG4gICAgICAgIHRvcDogZWxlbWVudC5vZmZzZXRUb3AsXHJcbiAgICAgICAgYm90dG9tOiBlbGVtZW50Lm9mZnNldFRvcCArIGVsZW1lbnQub2Zmc2V0SGVpZ2h0XHJcbiAgICAgIH07XHJcblxyXG4gICAgICBpZiAobW91c2VQb3NpdGlvbi54IDwgY29udGFpbmVyR2VvbWV0cnkubGVmdCArIDMpIHtcclxuICAgICAgICBzY3JvbGxEaWZmLmxlZnQgPSAtNTtcclxuICAgICAgICBfLnN0YXJ0U2Nyb2xsaW5nKGVsZW1lbnQsICd4Jyk7XHJcbiAgICAgIH0gZWxzZSBpZiAobW91c2VQb3NpdGlvbi54ID4gY29udGFpbmVyR2VvbWV0cnkucmlnaHQgLSAzKSB7XHJcbiAgICAgICAgc2Nyb2xsRGlmZi5sZWZ0ID0gNTtcclxuICAgICAgICBfLnN0YXJ0U2Nyb2xsaW5nKGVsZW1lbnQsICd4Jyk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgc2Nyb2xsRGlmZi5sZWZ0ID0gMDtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKG1vdXNlUG9zaXRpb24ueSA8IGNvbnRhaW5lckdlb21ldHJ5LnRvcCArIDMpIHtcclxuICAgICAgICBpZiAoY29udGFpbmVyR2VvbWV0cnkudG9wICsgMyAtIG1vdXNlUG9zaXRpb24ueSA8IDUpIHtcclxuICAgICAgICAgIHNjcm9sbERpZmYudG9wID0gLTU7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHNjcm9sbERpZmYudG9wID0gLTIwO1xyXG4gICAgICAgIH1cclxuICAgICAgICBfLnN0YXJ0U2Nyb2xsaW5nKGVsZW1lbnQsICd5Jyk7XHJcbiAgICAgIH0gZWxzZSBpZiAobW91c2VQb3NpdGlvbi55ID4gY29udGFpbmVyR2VvbWV0cnkuYm90dG9tIC0gMykge1xyXG4gICAgICAgIGlmIChtb3VzZVBvc2l0aW9uLnkgLSBjb250YWluZXJHZW9tZXRyeS5ib3R0b20gKyAzIDwgNSkge1xyXG4gICAgICAgICAgc2Nyb2xsRGlmZi50b3AgPSA1O1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBzY3JvbGxEaWZmLnRvcCA9IDIwO1xyXG4gICAgICAgIH1cclxuICAgICAgICBfLnN0YXJ0U2Nyb2xsaW5nKGVsZW1lbnQsICd5Jyk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgc2Nyb2xsRGlmZi50b3AgPSAwO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoc2Nyb2xsRGlmZi50b3AgPT09IDAgJiYgc2Nyb2xsRGlmZi5sZWZ0ID09PSAwKSB7XHJcbiAgICAgICAgc3RvcFNjcm9sbGluZygpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHN0YXJ0U2Nyb2xsaW5nKCk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9KTtcclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZWxlbWVudCkge1xyXG4gIHZhciBpID0gaW5zdGFuY2VzLmdldChlbGVtZW50KTtcclxuICBiaW5kU2VsZWN0aW9uSGFuZGxlcihlbGVtZW50LCBpKTtcclxufTtcclxuXHJcbn0se1wiLi4vLi4vbGliL2hlbHBlclwiOjgsXCIuLi9pbnN0YW5jZXNcIjoyMCxcIi4uL3VwZGF0ZS1nZW9tZXRyeVwiOjIxLFwiLi4vdXBkYXRlLXNjcm9sbFwiOjIyfV0sMTg6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xyXG4ndXNlIHN0cmljdCc7XHJcblxyXG52YXIgXyA9IHJlcXVpcmUoJy4uLy4uL2xpYi9oZWxwZXInKTtcclxudmFyIGluc3RhbmNlcyA9IHJlcXVpcmUoJy4uL2luc3RhbmNlcycpO1xyXG52YXIgdXBkYXRlR2VvbWV0cnkgPSByZXF1aXJlKCcuLi91cGRhdGUtZ2VvbWV0cnknKTtcclxudmFyIHVwZGF0ZVNjcm9sbCA9IHJlcXVpcmUoJy4uL3VwZGF0ZS1zY3JvbGwnKTtcclxuXHJcbmZ1bmN0aW9uIGJpbmRUb3VjaEhhbmRsZXIoZWxlbWVudCwgaSwgc3VwcG9ydHNUb3VjaCwgc3VwcG9ydHNJZVBvaW50ZXIpIHtcclxuICBmdW5jdGlvbiBzaG91bGRQcmV2ZW50RGVmYXVsdChkZWx0YVgsIGRlbHRhWSkge1xyXG4gICAgdmFyIHNjcm9sbFRvcCA9IGVsZW1lbnQuc2Nyb2xsVG9wO1xyXG4gICAgdmFyIHNjcm9sbExlZnQgPSBlbGVtZW50LnNjcm9sbExlZnQ7XHJcbiAgICB2YXIgbWFnbml0dWRlWCA9IE1hdGguYWJzKGRlbHRhWCk7XHJcbiAgICB2YXIgbWFnbml0dWRlWSA9IE1hdGguYWJzKGRlbHRhWSk7XHJcblxyXG4gICAgaWYgKG1hZ25pdHVkZVkgPiBtYWduaXR1ZGVYKSB7XHJcbiAgICAgIC8vIHVzZXIgaXMgcGVyaGFwcyB0cnlpbmcgdG8gc3dpcGUgdXAvZG93biB0aGUgcGFnZVxyXG5cclxuICAgICAgaWYgKCgoZGVsdGFZIDwgMCkgJiYgKHNjcm9sbFRvcCA9PT0gaS5jb250ZW50SGVpZ2h0IC0gaS5jb250YWluZXJIZWlnaHQpKSB8fFxyXG4gICAgICAgICAgKChkZWx0YVkgPiAwKSAmJiAoc2Nyb2xsVG9wID09PSAwKSkpIHtcclxuICAgICAgICByZXR1cm4gIWkuc2V0dGluZ3Muc3dpcGVQcm9wYWdhdGlvbjtcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIGlmIChtYWduaXR1ZGVYID4gbWFnbml0dWRlWSkge1xyXG4gICAgICAvLyB1c2VyIGlzIHBlcmhhcHMgdHJ5aW5nIHRvIHN3aXBlIGxlZnQvcmlnaHQgYWNyb3NzIHRoZSBwYWdlXHJcblxyXG4gICAgICBpZiAoKChkZWx0YVggPCAwKSAmJiAoc2Nyb2xsTGVmdCA9PT0gaS5jb250ZW50V2lkdGggLSBpLmNvbnRhaW5lcldpZHRoKSkgfHxcclxuICAgICAgICAgICgoZGVsdGFYID4gMCkgJiYgKHNjcm9sbExlZnQgPT09IDApKSkge1xyXG4gICAgICAgIHJldHVybiAhaS5zZXR0aW5ncy5zd2lwZVByb3BhZ2F0aW9uO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHRydWU7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBhcHBseVRvdWNoTW92ZShkaWZmZXJlbmNlWCwgZGlmZmVyZW5jZVkpIHtcclxuICAgIHVwZGF0ZVNjcm9sbChlbGVtZW50LCAndG9wJywgZWxlbWVudC5zY3JvbGxUb3AgLSBkaWZmZXJlbmNlWSk7XHJcbiAgICB1cGRhdGVTY3JvbGwoZWxlbWVudCwgJ2xlZnQnLCBlbGVtZW50LnNjcm9sbExlZnQgLSBkaWZmZXJlbmNlWCk7XHJcblxyXG4gICAgdXBkYXRlR2VvbWV0cnkoZWxlbWVudCk7XHJcbiAgfVxyXG5cclxuICB2YXIgc3RhcnRPZmZzZXQgPSB7fTtcclxuICB2YXIgc3RhcnRUaW1lID0gMDtcclxuICB2YXIgc3BlZWQgPSB7fTtcclxuICB2YXIgZWFzaW5nTG9vcCA9IG51bGw7XHJcbiAgdmFyIGluR2xvYmFsVG91Y2ggPSBmYWxzZTtcclxuICB2YXIgaW5Mb2NhbFRvdWNoID0gZmFsc2U7XHJcblxyXG4gIGZ1bmN0aW9uIGdsb2JhbFRvdWNoU3RhcnQoKSB7XHJcbiAgICBpbkdsb2JhbFRvdWNoID0gdHJ1ZTtcclxuICB9XHJcbiAgZnVuY3Rpb24gZ2xvYmFsVG91Y2hFbmQoKSB7XHJcbiAgICBpbkdsb2JhbFRvdWNoID0gZmFsc2U7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBnZXRUb3VjaChlKSB7XHJcbiAgICBpZiAoZS50YXJnZXRUb3VjaGVzKSB7XHJcbiAgICAgIHJldHVybiBlLnRhcmdldFRvdWNoZXNbMF07XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAvLyBNYXliZSBJRSBwb2ludGVyXHJcbiAgICAgIHJldHVybiBlO1xyXG4gICAgfVxyXG4gIH1cclxuICBmdW5jdGlvbiBzaG91bGRIYW5kbGUoZSkge1xyXG4gICAgaWYgKGUudGFyZ2V0VG91Y2hlcyAmJiBlLnRhcmdldFRvdWNoZXMubGVuZ3RoID09PSAxKSB7XHJcbiAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG4gICAgaWYgKGUucG9pbnRlclR5cGUgJiYgZS5wb2ludGVyVHlwZSAhPT0gJ21vdXNlJyAmJiBlLnBvaW50ZXJUeXBlICE9PSBlLk1TUE9JTlRFUl9UWVBFX01PVVNFKSB7XHJcbiAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG4gIH1cclxuICBmdW5jdGlvbiB0b3VjaFN0YXJ0KGUpIHtcclxuICAgIGlmIChzaG91bGRIYW5kbGUoZSkpIHtcclxuICAgICAgaW5Mb2NhbFRvdWNoID0gdHJ1ZTtcclxuXHJcbiAgICAgIHZhciB0b3VjaCA9IGdldFRvdWNoKGUpO1xyXG5cclxuICAgICAgc3RhcnRPZmZzZXQucGFnZVggPSB0b3VjaC5wYWdlWDtcclxuICAgICAgc3RhcnRPZmZzZXQucGFnZVkgPSB0b3VjaC5wYWdlWTtcclxuXHJcbiAgICAgIHN0YXJ0VGltZSA9IChuZXcgRGF0ZSgpKS5nZXRUaW1lKCk7XHJcblxyXG4gICAgICBpZiAoZWFzaW5nTG9vcCAhPT0gbnVsbCkge1xyXG4gICAgICAgIGNsZWFySW50ZXJ2YWwoZWFzaW5nTG9vcCk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XHJcbiAgICB9XHJcbiAgfVxyXG4gIGZ1bmN0aW9uIHRvdWNoTW92ZShlKSB7XHJcbiAgICBpZiAoIWluTG9jYWxUb3VjaCAmJiBpLnNldHRpbmdzLnN3aXBlUHJvcGFnYXRpb24pIHtcclxuICAgICAgdG91Y2hTdGFydChlKTtcclxuICAgIH1cclxuICAgIGlmICghaW5HbG9iYWxUb3VjaCAmJiBpbkxvY2FsVG91Y2ggJiYgc2hvdWxkSGFuZGxlKGUpKSB7XHJcbiAgICAgIHZhciB0b3VjaCA9IGdldFRvdWNoKGUpO1xyXG5cclxuICAgICAgdmFyIGN1cnJlbnRPZmZzZXQgPSB7cGFnZVg6IHRvdWNoLnBhZ2VYLCBwYWdlWTogdG91Y2gucGFnZVl9O1xyXG5cclxuICAgICAgdmFyIGRpZmZlcmVuY2VYID0gY3VycmVudE9mZnNldC5wYWdlWCAtIHN0YXJ0T2Zmc2V0LnBhZ2VYO1xyXG4gICAgICB2YXIgZGlmZmVyZW5jZVkgPSBjdXJyZW50T2Zmc2V0LnBhZ2VZIC0gc3RhcnRPZmZzZXQucGFnZVk7XHJcblxyXG4gICAgICBhcHBseVRvdWNoTW92ZShkaWZmZXJlbmNlWCwgZGlmZmVyZW5jZVkpO1xyXG4gICAgICBzdGFydE9mZnNldCA9IGN1cnJlbnRPZmZzZXQ7XHJcblxyXG4gICAgICB2YXIgY3VycmVudFRpbWUgPSAobmV3IERhdGUoKSkuZ2V0VGltZSgpO1xyXG5cclxuICAgICAgdmFyIHRpbWVHYXAgPSBjdXJyZW50VGltZSAtIHN0YXJ0VGltZTtcclxuICAgICAgaWYgKHRpbWVHYXAgPiAwKSB7XHJcbiAgICAgICAgc3BlZWQueCA9IGRpZmZlcmVuY2VYIC8gdGltZUdhcDtcclxuICAgICAgICBzcGVlZC55ID0gZGlmZmVyZW5jZVkgLyB0aW1lR2FwO1xyXG4gICAgICAgIHN0YXJ0VGltZSA9IGN1cnJlbnRUaW1lO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoc2hvdWxkUHJldmVudERlZmF1bHQoZGlmZmVyZW5jZVgsIGRpZmZlcmVuY2VZKSkge1xyXG4gICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XHJcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG4gIGZ1bmN0aW9uIHRvdWNoRW5kKCkge1xyXG4gICAgaWYgKCFpbkdsb2JhbFRvdWNoICYmIGluTG9jYWxUb3VjaCkge1xyXG4gICAgICBpbkxvY2FsVG91Y2ggPSBmYWxzZTtcclxuXHJcbiAgICAgIGNsZWFySW50ZXJ2YWwoZWFzaW5nTG9vcCk7XHJcbiAgICAgIGVhc2luZ0xvb3AgPSBzZXRJbnRlcnZhbChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKCFpbnN0YW5jZXMuZ2V0KGVsZW1lbnQpKSB7XHJcbiAgICAgICAgICBjbGVhckludGVydmFsKGVhc2luZ0xvb3ApO1xyXG4gICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKE1hdGguYWJzKHNwZWVkLngpIDwgMC4wMSAmJiBNYXRoLmFicyhzcGVlZC55KSA8IDAuMDEpIHtcclxuICAgICAgICAgIGNsZWFySW50ZXJ2YWwoZWFzaW5nTG9vcCk7XHJcbiAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBhcHBseVRvdWNoTW92ZShzcGVlZC54ICogMzAsIHNwZWVkLnkgKiAzMCk7XHJcblxyXG4gICAgICAgIHNwZWVkLnggKj0gMC44O1xyXG4gICAgICAgIHNwZWVkLnkgKj0gMC44O1xyXG4gICAgICB9LCAxMCk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBpZiAoc3VwcG9ydHNUb3VjaCkge1xyXG4gICAgaS5ldmVudC5iaW5kKHdpbmRvdywgJ3RvdWNoc3RhcnQnLCBnbG9iYWxUb3VjaFN0YXJ0KTtcclxuICAgIGkuZXZlbnQuYmluZCh3aW5kb3csICd0b3VjaGVuZCcsIGdsb2JhbFRvdWNoRW5kKTtcclxuICAgIGkuZXZlbnQuYmluZChlbGVtZW50LCAndG91Y2hzdGFydCcsIHRvdWNoU3RhcnQpO1xyXG4gICAgaS5ldmVudC5iaW5kKGVsZW1lbnQsICd0b3VjaG1vdmUnLCB0b3VjaE1vdmUpO1xyXG4gICAgaS5ldmVudC5iaW5kKGVsZW1lbnQsICd0b3VjaGVuZCcsIHRvdWNoRW5kKTtcclxuICB9XHJcblxyXG4gIGlmIChzdXBwb3J0c0llUG9pbnRlcikge1xyXG4gICAgaWYgKHdpbmRvdy5Qb2ludGVyRXZlbnQpIHtcclxuICAgICAgaS5ldmVudC5iaW5kKHdpbmRvdywgJ3BvaW50ZXJkb3duJywgZ2xvYmFsVG91Y2hTdGFydCk7XHJcbiAgICAgIGkuZXZlbnQuYmluZCh3aW5kb3csICdwb2ludGVydXAnLCBnbG9iYWxUb3VjaEVuZCk7XHJcbiAgICAgIGkuZXZlbnQuYmluZChlbGVtZW50LCAncG9pbnRlcmRvd24nLCB0b3VjaFN0YXJ0KTtcclxuICAgICAgaS5ldmVudC5iaW5kKGVsZW1lbnQsICdwb2ludGVybW92ZScsIHRvdWNoTW92ZSk7XHJcbiAgICAgIGkuZXZlbnQuYmluZChlbGVtZW50LCAncG9pbnRlcnVwJywgdG91Y2hFbmQpO1xyXG4gICAgfSBlbHNlIGlmICh3aW5kb3cuTVNQb2ludGVyRXZlbnQpIHtcclxuICAgICAgaS5ldmVudC5iaW5kKHdpbmRvdywgJ01TUG9pbnRlckRvd24nLCBnbG9iYWxUb3VjaFN0YXJ0KTtcclxuICAgICAgaS5ldmVudC5iaW5kKHdpbmRvdywgJ01TUG9pbnRlclVwJywgZ2xvYmFsVG91Y2hFbmQpO1xyXG4gICAgICBpLmV2ZW50LmJpbmQoZWxlbWVudCwgJ01TUG9pbnRlckRvd24nLCB0b3VjaFN0YXJ0KTtcclxuICAgICAgaS5ldmVudC5iaW5kKGVsZW1lbnQsICdNU1BvaW50ZXJNb3ZlJywgdG91Y2hNb3ZlKTtcclxuICAgICAgaS5ldmVudC5iaW5kKGVsZW1lbnQsICdNU1BvaW50ZXJVcCcsIHRvdWNoRW5kKTtcclxuICAgIH1cclxuICB9XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGVsZW1lbnQpIHtcclxuICBpZiAoIV8uZW52LnN1cHBvcnRzVG91Y2ggJiYgIV8uZW52LnN1cHBvcnRzSWVQb2ludGVyKSB7XHJcbiAgICByZXR1cm47XHJcbiAgfVxyXG5cclxuICB2YXIgaSA9IGluc3RhbmNlcy5nZXQoZWxlbWVudCk7XHJcbiAgYmluZFRvdWNoSGFuZGxlcihlbGVtZW50LCBpLCBfLmVudi5zdXBwb3J0c1RvdWNoLCBfLmVudi5zdXBwb3J0c0llUG9pbnRlcik7XHJcbn07XHJcblxyXG59LHtcIi4uLy4uL2xpYi9oZWxwZXJcIjo4LFwiLi4vaW5zdGFuY2VzXCI6MjAsXCIuLi91cGRhdGUtZ2VvbWV0cnlcIjoyMSxcIi4uL3VwZGF0ZS1zY3JvbGxcIjoyMn1dLDE5OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyIF8gPSByZXF1aXJlKCcuLi9saWIvaGVscGVyJyk7XHJcbnZhciBjbHMgPSByZXF1aXJlKCcuLi9saWIvY2xhc3MnKTtcclxudmFyIGluc3RhbmNlcyA9IHJlcXVpcmUoJy4vaW5zdGFuY2VzJyk7XHJcbnZhciB1cGRhdGVHZW9tZXRyeSA9IHJlcXVpcmUoJy4vdXBkYXRlLWdlb21ldHJ5Jyk7XHJcblxyXG4vLyBIYW5kbGVyc1xyXG52YXIgaGFuZGxlcnMgPSB7XHJcbiAgJ2NsaWNrLXJhaWwnOiByZXF1aXJlKCcuL2hhbmRsZXIvY2xpY2stcmFpbCcpLFxyXG4gICdkcmFnLXNjcm9sbGJhcic6IHJlcXVpcmUoJy4vaGFuZGxlci9kcmFnLXNjcm9sbGJhcicpLFxyXG4gICdrZXlib2FyZCc6IHJlcXVpcmUoJy4vaGFuZGxlci9rZXlib2FyZCcpLFxyXG4gICd3aGVlbCc6IHJlcXVpcmUoJy4vaGFuZGxlci9tb3VzZS13aGVlbCcpLFxyXG4gICd0b3VjaCc6IHJlcXVpcmUoJy4vaGFuZGxlci90b3VjaCcpLFxyXG4gICdzZWxlY3Rpb24nOiByZXF1aXJlKCcuL2hhbmRsZXIvc2VsZWN0aW9uJylcclxufTtcclxudmFyIG5hdGl2ZVNjcm9sbEhhbmRsZXIgPSByZXF1aXJlKCcuL2hhbmRsZXIvbmF0aXZlLXNjcm9sbCcpO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZWxlbWVudCwgdXNlclNldHRpbmdzKSB7XHJcbiAgdXNlclNldHRpbmdzID0gdHlwZW9mIHVzZXJTZXR0aW5ncyA9PT0gJ29iamVjdCcgPyB1c2VyU2V0dGluZ3MgOiB7fTtcclxuXHJcbiAgY2xzLmFkZChlbGVtZW50LCAncHMtY29udGFpbmVyJyk7XHJcblxyXG4gIC8vIENyZWF0ZSBhIHBsdWdpbiBpbnN0YW5jZS5cclxuICB2YXIgaSA9IGluc3RhbmNlcy5hZGQoZWxlbWVudCk7XHJcblxyXG4gIGkuc2V0dGluZ3MgPSBfLmV4dGVuZChpLnNldHRpbmdzLCB1c2VyU2V0dGluZ3MpO1xyXG4gIGNscy5hZGQoZWxlbWVudCwgJ3BzLXRoZW1lLScgKyBpLnNldHRpbmdzLnRoZW1lKTtcclxuXHJcbiAgaS5zZXR0aW5ncy5oYW5kbGVycy5mb3JFYWNoKGZ1bmN0aW9uIChoYW5kbGVyTmFtZSkge1xyXG4gICAgaGFuZGxlcnNbaGFuZGxlck5hbWVdKGVsZW1lbnQpO1xyXG4gIH0pO1xyXG5cclxuICBuYXRpdmVTY3JvbGxIYW5kbGVyKGVsZW1lbnQpO1xyXG5cclxuICB1cGRhdGVHZW9tZXRyeShlbGVtZW50KTtcclxufTtcclxuXHJcbn0se1wiLi4vbGliL2NsYXNzXCI6NCxcIi4uL2xpYi9oZWxwZXJcIjo4LFwiLi9oYW5kbGVyL2NsaWNrLXJhaWxcIjoxMixcIi4vaGFuZGxlci9kcmFnLXNjcm9sbGJhclwiOjEzLFwiLi9oYW5kbGVyL2tleWJvYXJkXCI6MTQsXCIuL2hhbmRsZXIvbW91c2Utd2hlZWxcIjoxNSxcIi4vaGFuZGxlci9uYXRpdmUtc2Nyb2xsXCI6MTYsXCIuL2hhbmRsZXIvc2VsZWN0aW9uXCI6MTcsXCIuL2hhbmRsZXIvdG91Y2hcIjoxOCxcIi4vaW5zdGFuY2VzXCI6MjAsXCIuL3VwZGF0ZS1nZW9tZXRyeVwiOjIxfV0sMjA6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xyXG4ndXNlIHN0cmljdCc7XHJcblxyXG52YXIgXyA9IHJlcXVpcmUoJy4uL2xpYi9oZWxwZXInKTtcclxudmFyIGNscyA9IHJlcXVpcmUoJy4uL2xpYi9jbGFzcycpO1xyXG52YXIgZGVmYXVsdFNldHRpbmdzID0gcmVxdWlyZSgnLi9kZWZhdWx0LXNldHRpbmcnKTtcclxudmFyIGRvbSA9IHJlcXVpcmUoJy4uL2xpYi9kb20nKTtcclxudmFyIEV2ZW50TWFuYWdlciA9IHJlcXVpcmUoJy4uL2xpYi9ldmVudC1tYW5hZ2VyJyk7XHJcbnZhciBndWlkID0gcmVxdWlyZSgnLi4vbGliL2d1aWQnKTtcclxuXHJcbnZhciBpbnN0YW5jZXMgPSB7fTtcclxuXHJcbmZ1bmN0aW9uIEluc3RhbmNlKGVsZW1lbnQpIHtcclxuICB2YXIgaSA9IHRoaXM7XHJcblxyXG4gIGkuc2V0dGluZ3MgPSBfLmNsb25lKGRlZmF1bHRTZXR0aW5ncyk7XHJcbiAgaS5jb250YWluZXJXaWR0aCA9IG51bGw7XHJcbiAgaS5jb250YWluZXJIZWlnaHQgPSBudWxsO1xyXG4gIGkuY29udGVudFdpZHRoID0gbnVsbDtcclxuICBpLmNvbnRlbnRIZWlnaHQgPSBudWxsO1xyXG5cclxuICBpLmlzUnRsID0gZG9tLmNzcyhlbGVtZW50LCAnZGlyZWN0aW9uJykgPT09IFwicnRsXCI7XHJcbiAgaS5pc05lZ2F0aXZlU2Nyb2xsID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIHZhciBvcmlnaW5hbFNjcm9sbExlZnQgPSBlbGVtZW50LnNjcm9sbExlZnQ7XHJcbiAgICB2YXIgcmVzdWx0ID0gbnVsbDtcclxuICAgIGVsZW1lbnQuc2Nyb2xsTGVmdCA9IC0xO1xyXG4gICAgcmVzdWx0ID0gZWxlbWVudC5zY3JvbGxMZWZ0IDwgMDtcclxuICAgIGVsZW1lbnQuc2Nyb2xsTGVmdCA9IG9yaWdpbmFsU2Nyb2xsTGVmdDtcclxuICAgIHJldHVybiByZXN1bHQ7XHJcbiAgfSkoKTtcclxuICBpLm5lZ2F0aXZlU2Nyb2xsQWRqdXN0bWVudCA9IGkuaXNOZWdhdGl2ZVNjcm9sbCA/IGVsZW1lbnQuc2Nyb2xsV2lkdGggLSBlbGVtZW50LmNsaWVudFdpZHRoIDogMDtcclxuICBpLmV2ZW50ID0gbmV3IEV2ZW50TWFuYWdlcigpO1xyXG4gIGkub3duZXJEb2N1bWVudCA9IGVsZW1lbnQub3duZXJEb2N1bWVudCB8fCBkb2N1bWVudDtcclxuXHJcbiAgZnVuY3Rpb24gZm9jdXMoKSB7XHJcbiAgICBjbHMuYWRkKGVsZW1lbnQsICdwcy1mb2N1cycpO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gYmx1cigpIHtcclxuICAgIGNscy5yZW1vdmUoZWxlbWVudCwgJ3BzLWZvY3VzJyk7XHJcbiAgfVxyXG5cclxuICBpLnNjcm9sbGJhclhSYWlsID0gZG9tLmFwcGVuZFRvKGRvbS5lKCdkaXYnLCAncHMtc2Nyb2xsYmFyLXgtcmFpbCcpLCBlbGVtZW50KTtcclxuICBpLnNjcm9sbGJhclggPSBkb20uYXBwZW5kVG8oZG9tLmUoJ2RpdicsICdwcy1zY3JvbGxiYXIteCcpLCBpLnNjcm9sbGJhclhSYWlsKTtcclxuICBpLnNjcm9sbGJhclguc2V0QXR0cmlidXRlKCd0YWJpbmRleCcsIDApO1xyXG4gIGkuZXZlbnQuYmluZChpLnNjcm9sbGJhclgsICdmb2N1cycsIGZvY3VzKTtcclxuICBpLmV2ZW50LmJpbmQoaS5zY3JvbGxiYXJYLCAnYmx1cicsIGJsdXIpO1xyXG4gIGkuc2Nyb2xsYmFyWEFjdGl2ZSA9IG51bGw7XHJcbiAgaS5zY3JvbGxiYXJYV2lkdGggPSBudWxsO1xyXG4gIGkuc2Nyb2xsYmFyWExlZnQgPSBudWxsO1xyXG4gIGkuc2Nyb2xsYmFyWEJvdHRvbSA9IF8udG9JbnQoZG9tLmNzcyhpLnNjcm9sbGJhclhSYWlsLCAnYm90dG9tJykpO1xyXG4gIGkuaXNTY3JvbGxiYXJYVXNpbmdCb3R0b20gPSBpLnNjcm9sbGJhclhCb3R0b20gPT09IGkuc2Nyb2xsYmFyWEJvdHRvbTsgLy8gIWlzTmFOXHJcbiAgaS5zY3JvbGxiYXJYVG9wID0gaS5pc1Njcm9sbGJhclhVc2luZ0JvdHRvbSA/IG51bGwgOiBfLnRvSW50KGRvbS5jc3MoaS5zY3JvbGxiYXJYUmFpbCwgJ3RvcCcpKTtcclxuICBpLnJhaWxCb3JkZXJYV2lkdGggPSBfLnRvSW50KGRvbS5jc3MoaS5zY3JvbGxiYXJYUmFpbCwgJ2JvcmRlckxlZnRXaWR0aCcpKSArIF8udG9JbnQoZG9tLmNzcyhpLnNjcm9sbGJhclhSYWlsLCAnYm9yZGVyUmlnaHRXaWR0aCcpKTtcclxuICAvLyBTZXQgcmFpbCB0byBkaXNwbGF5OmJsb2NrIHRvIGNhbGN1bGF0ZSBtYXJnaW5zXHJcbiAgZG9tLmNzcyhpLnNjcm9sbGJhclhSYWlsLCAnZGlzcGxheScsICdibG9jaycpO1xyXG4gIGkucmFpbFhNYXJnaW5XaWR0aCA9IF8udG9JbnQoZG9tLmNzcyhpLnNjcm9sbGJhclhSYWlsLCAnbWFyZ2luTGVmdCcpKSArIF8udG9JbnQoZG9tLmNzcyhpLnNjcm9sbGJhclhSYWlsLCAnbWFyZ2luUmlnaHQnKSk7XHJcbiAgZG9tLmNzcyhpLnNjcm9sbGJhclhSYWlsLCAnZGlzcGxheScsICcnKTtcclxuICBpLnJhaWxYV2lkdGggPSBudWxsO1xyXG4gIGkucmFpbFhSYXRpbyA9IG51bGw7XHJcblxyXG4gIGkuc2Nyb2xsYmFyWVJhaWwgPSBkb20uYXBwZW5kVG8oZG9tLmUoJ2RpdicsICdwcy1zY3JvbGxiYXIteS1yYWlsJyksIGVsZW1lbnQpO1xyXG4gIGkuc2Nyb2xsYmFyWSA9IGRvbS5hcHBlbmRUbyhkb20uZSgnZGl2JywgJ3BzLXNjcm9sbGJhci15JyksIGkuc2Nyb2xsYmFyWVJhaWwpO1xyXG4gIGkuc2Nyb2xsYmFyWS5zZXRBdHRyaWJ1dGUoJ3RhYmluZGV4JywgMCk7XHJcbiAgaS5ldmVudC5iaW5kKGkuc2Nyb2xsYmFyWSwgJ2ZvY3VzJywgZm9jdXMpO1xyXG4gIGkuZXZlbnQuYmluZChpLnNjcm9sbGJhclksICdibHVyJywgYmx1cik7XHJcbiAgaS5zY3JvbGxiYXJZQWN0aXZlID0gbnVsbDtcclxuICBpLnNjcm9sbGJhcllIZWlnaHQgPSBudWxsO1xyXG4gIGkuc2Nyb2xsYmFyWVRvcCA9IG51bGw7XHJcbiAgaS5zY3JvbGxiYXJZUmlnaHQgPSBfLnRvSW50KGRvbS5jc3MoaS5zY3JvbGxiYXJZUmFpbCwgJ3JpZ2h0JykpO1xyXG4gIGkuaXNTY3JvbGxiYXJZVXNpbmdSaWdodCA9IGkuc2Nyb2xsYmFyWVJpZ2h0ID09PSBpLnNjcm9sbGJhcllSaWdodDsgLy8gIWlzTmFOXHJcbiAgaS5zY3JvbGxiYXJZTGVmdCA9IGkuaXNTY3JvbGxiYXJZVXNpbmdSaWdodCA/IG51bGwgOiBfLnRvSW50KGRvbS5jc3MoaS5zY3JvbGxiYXJZUmFpbCwgJ2xlZnQnKSk7XHJcbiAgaS5zY3JvbGxiYXJZT3V0ZXJXaWR0aCA9IGkuaXNSdGwgPyBfLm91dGVyV2lkdGgoaS5zY3JvbGxiYXJZKSA6IG51bGw7XHJcbiAgaS5yYWlsQm9yZGVyWVdpZHRoID0gXy50b0ludChkb20uY3NzKGkuc2Nyb2xsYmFyWVJhaWwsICdib3JkZXJUb3BXaWR0aCcpKSArIF8udG9JbnQoZG9tLmNzcyhpLnNjcm9sbGJhcllSYWlsLCAnYm9yZGVyQm90dG9tV2lkdGgnKSk7XHJcbiAgZG9tLmNzcyhpLnNjcm9sbGJhcllSYWlsLCAnZGlzcGxheScsICdibG9jaycpO1xyXG4gIGkucmFpbFlNYXJnaW5IZWlnaHQgPSBfLnRvSW50KGRvbS5jc3MoaS5zY3JvbGxiYXJZUmFpbCwgJ21hcmdpblRvcCcpKSArIF8udG9JbnQoZG9tLmNzcyhpLnNjcm9sbGJhcllSYWlsLCAnbWFyZ2luQm90dG9tJykpO1xyXG4gIGRvbS5jc3MoaS5zY3JvbGxiYXJZUmFpbCwgJ2Rpc3BsYXknLCAnJyk7XHJcbiAgaS5yYWlsWUhlaWdodCA9IG51bGw7XHJcbiAgaS5yYWlsWVJhdGlvID0gbnVsbDtcclxufVxyXG5cclxuZnVuY3Rpb24gZ2V0SWQoZWxlbWVudCkge1xyXG4gIHJldHVybiBlbGVtZW50LmdldEF0dHJpYnV0ZSgnZGF0YS1wcy1pZCcpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBzZXRJZChlbGVtZW50LCBpZCkge1xyXG4gIGVsZW1lbnQuc2V0QXR0cmlidXRlKCdkYXRhLXBzLWlkJywgaWQpO1xyXG59XHJcblxyXG5mdW5jdGlvbiByZW1vdmVJZChlbGVtZW50KSB7XHJcbiAgZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoJ2RhdGEtcHMtaWQnKTtcclxufVxyXG5cclxuZXhwb3J0cy5hZGQgPSBmdW5jdGlvbiAoZWxlbWVudCkge1xyXG4gIHZhciBuZXdJZCA9IGd1aWQoKTtcclxuICBzZXRJZChlbGVtZW50LCBuZXdJZCk7XHJcbiAgaW5zdGFuY2VzW25ld0lkXSA9IG5ldyBJbnN0YW5jZShlbGVtZW50KTtcclxuICByZXR1cm4gaW5zdGFuY2VzW25ld0lkXTtcclxufTtcclxuXHJcbmV4cG9ydHMucmVtb3ZlID0gZnVuY3Rpb24gKGVsZW1lbnQpIHtcclxuICBkZWxldGUgaW5zdGFuY2VzW2dldElkKGVsZW1lbnQpXTtcclxuICByZW1vdmVJZChlbGVtZW50KTtcclxufTtcclxuXHJcbmV4cG9ydHMuZ2V0ID0gZnVuY3Rpb24gKGVsZW1lbnQpIHtcclxuICByZXR1cm4gaW5zdGFuY2VzW2dldElkKGVsZW1lbnQpXTtcclxufTtcclxuXHJcbn0se1wiLi4vbGliL2NsYXNzXCI6NCxcIi4uL2xpYi9kb21cIjo1LFwiLi4vbGliL2V2ZW50LW1hbmFnZXJcIjo2LFwiLi4vbGliL2d1aWRcIjo3LFwiLi4vbGliL2hlbHBlclwiOjgsXCIuL2RlZmF1bHQtc2V0dGluZ1wiOjEwfV0sMjE6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xyXG4ndXNlIHN0cmljdCc7XHJcblxyXG52YXIgXyA9IHJlcXVpcmUoJy4uL2xpYi9oZWxwZXInKTtcclxudmFyIGNscyA9IHJlcXVpcmUoJy4uL2xpYi9jbGFzcycpO1xyXG52YXIgZG9tID0gcmVxdWlyZSgnLi4vbGliL2RvbScpO1xyXG52YXIgaW5zdGFuY2VzID0gcmVxdWlyZSgnLi9pbnN0YW5jZXMnKTtcclxudmFyIHVwZGF0ZVNjcm9sbCA9IHJlcXVpcmUoJy4vdXBkYXRlLXNjcm9sbCcpO1xyXG5cclxuZnVuY3Rpb24gZ2V0VGh1bWJTaXplKGksIHRodW1iU2l6ZSkge1xyXG4gIGlmIChpLnNldHRpbmdzLm1pblNjcm9sbGJhckxlbmd0aCkge1xyXG4gICAgdGh1bWJTaXplID0gTWF0aC5tYXgodGh1bWJTaXplLCBpLnNldHRpbmdzLm1pblNjcm9sbGJhckxlbmd0aCk7XHJcbiAgfVxyXG4gIGlmIChpLnNldHRpbmdzLm1heFNjcm9sbGJhckxlbmd0aCkge1xyXG4gICAgdGh1bWJTaXplID0gTWF0aC5taW4odGh1bWJTaXplLCBpLnNldHRpbmdzLm1heFNjcm9sbGJhckxlbmd0aCk7XHJcbiAgfVxyXG4gIHJldHVybiB0aHVtYlNpemU7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHVwZGF0ZUNzcyhlbGVtZW50LCBpKSB7XHJcbiAgdmFyIHhSYWlsT2Zmc2V0ID0ge3dpZHRoOiBpLnJhaWxYV2lkdGh9O1xyXG4gIGlmIChpLmlzUnRsKSB7XHJcbiAgICB4UmFpbE9mZnNldC5sZWZ0ID0gaS5uZWdhdGl2ZVNjcm9sbEFkanVzdG1lbnQgKyBlbGVtZW50LnNjcm9sbExlZnQgKyBpLmNvbnRhaW5lcldpZHRoIC0gaS5jb250ZW50V2lkdGg7XHJcbiAgfSBlbHNlIHtcclxuICAgIHhSYWlsT2Zmc2V0LmxlZnQgPSBlbGVtZW50LnNjcm9sbExlZnQ7XHJcbiAgfVxyXG4gIGlmIChpLmlzU2Nyb2xsYmFyWFVzaW5nQm90dG9tKSB7XHJcbiAgICB4UmFpbE9mZnNldC5ib3R0b20gPSBpLnNjcm9sbGJhclhCb3R0b20gLSBlbGVtZW50LnNjcm9sbFRvcDtcclxuICB9IGVsc2Uge1xyXG4gICAgeFJhaWxPZmZzZXQudG9wID0gaS5zY3JvbGxiYXJYVG9wICsgZWxlbWVudC5zY3JvbGxUb3A7XHJcbiAgfVxyXG4gIGRvbS5jc3MoaS5zY3JvbGxiYXJYUmFpbCwgeFJhaWxPZmZzZXQpO1xyXG5cclxuICB2YXIgeVJhaWxPZmZzZXQgPSB7dG9wOiBlbGVtZW50LnNjcm9sbFRvcCwgaGVpZ2h0OiBpLnJhaWxZSGVpZ2h0fTtcclxuICBpZiAoaS5pc1Njcm9sbGJhcllVc2luZ1JpZ2h0KSB7XHJcbiAgICBpZiAoaS5pc1J0bCkge1xyXG4gICAgICB5UmFpbE9mZnNldC5yaWdodCA9IGkuY29udGVudFdpZHRoIC0gKGkubmVnYXRpdmVTY3JvbGxBZGp1c3RtZW50ICsgZWxlbWVudC5zY3JvbGxMZWZ0KSAtIGkuc2Nyb2xsYmFyWVJpZ2h0IC0gaS5zY3JvbGxiYXJZT3V0ZXJXaWR0aDtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHlSYWlsT2Zmc2V0LnJpZ2h0ID0gaS5zY3JvbGxiYXJZUmlnaHQgLSBlbGVtZW50LnNjcm9sbExlZnQ7XHJcbiAgICB9XHJcbiAgfSBlbHNlIHtcclxuICAgIGlmIChpLmlzUnRsKSB7XHJcbiAgICAgIHlSYWlsT2Zmc2V0LmxlZnQgPSBpLm5lZ2F0aXZlU2Nyb2xsQWRqdXN0bWVudCArIGVsZW1lbnQuc2Nyb2xsTGVmdCArIGkuY29udGFpbmVyV2lkdGggKiAyIC0gaS5jb250ZW50V2lkdGggLSBpLnNjcm9sbGJhcllMZWZ0IC0gaS5zY3JvbGxiYXJZT3V0ZXJXaWR0aDtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHlSYWlsT2Zmc2V0LmxlZnQgPSBpLnNjcm9sbGJhcllMZWZ0ICsgZWxlbWVudC5zY3JvbGxMZWZ0O1xyXG4gICAgfVxyXG4gIH1cclxuICBkb20uY3NzKGkuc2Nyb2xsYmFyWVJhaWwsIHlSYWlsT2Zmc2V0KTtcclxuXHJcbiAgZG9tLmNzcyhpLnNjcm9sbGJhclgsIHtsZWZ0OiBpLnNjcm9sbGJhclhMZWZ0LCB3aWR0aDogaS5zY3JvbGxiYXJYV2lkdGggLSBpLnJhaWxCb3JkZXJYV2lkdGh9KTtcclxuICBkb20uY3NzKGkuc2Nyb2xsYmFyWSwge3RvcDogaS5zY3JvbGxiYXJZVG9wLCBoZWlnaHQ6IGkuc2Nyb2xsYmFyWUhlaWdodCAtIGkucmFpbEJvcmRlcllXaWR0aH0pO1xyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChlbGVtZW50KSB7XHJcbiAgdmFyIGkgPSBpbnN0YW5jZXMuZ2V0KGVsZW1lbnQpO1xyXG5cclxuICBpLmNvbnRhaW5lcldpZHRoID0gZWxlbWVudC5jbGllbnRXaWR0aDtcclxuICBpLmNvbnRhaW5lckhlaWdodCA9IGVsZW1lbnQuY2xpZW50SGVpZ2h0O1xyXG4gIGkuY29udGVudFdpZHRoID0gZWxlbWVudC5zY3JvbGxXaWR0aDtcclxuICBpLmNvbnRlbnRIZWlnaHQgPSBlbGVtZW50LnNjcm9sbEhlaWdodDtcclxuXHJcbiAgdmFyIGV4aXN0aW5nUmFpbHM7XHJcbiAgaWYgKCFlbGVtZW50LmNvbnRhaW5zKGkuc2Nyb2xsYmFyWFJhaWwpKSB7XHJcbiAgICBleGlzdGluZ1JhaWxzID0gZG9tLnF1ZXJ5Q2hpbGRyZW4oZWxlbWVudCwgJy5wcy1zY3JvbGxiYXIteC1yYWlsJyk7XHJcbiAgICBpZiAoZXhpc3RpbmdSYWlscy5sZW5ndGggPiAwKSB7XHJcbiAgICAgIGV4aXN0aW5nUmFpbHMuZm9yRWFjaChmdW5jdGlvbiAocmFpbCkge1xyXG4gICAgICAgIGRvbS5yZW1vdmUocmFpbCk7XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgZG9tLmFwcGVuZFRvKGkuc2Nyb2xsYmFyWFJhaWwsIGVsZW1lbnQpO1xyXG4gIH1cclxuICBpZiAoIWVsZW1lbnQuY29udGFpbnMoaS5zY3JvbGxiYXJZUmFpbCkpIHtcclxuICAgIGV4aXN0aW5nUmFpbHMgPSBkb20ucXVlcnlDaGlsZHJlbihlbGVtZW50LCAnLnBzLXNjcm9sbGJhci15LXJhaWwnKTtcclxuICAgIGlmIChleGlzdGluZ1JhaWxzLmxlbmd0aCA+IDApIHtcclxuICAgICAgZXhpc3RpbmdSYWlscy5mb3JFYWNoKGZ1bmN0aW9uIChyYWlsKSB7XHJcbiAgICAgICAgZG9tLnJlbW92ZShyYWlsKTtcclxuICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBkb20uYXBwZW5kVG8oaS5zY3JvbGxiYXJZUmFpbCwgZWxlbWVudCk7XHJcbiAgfVxyXG5cclxuICBpZiAoIWkuc2V0dGluZ3Muc3VwcHJlc3NTY3JvbGxYICYmIGkuY29udGFpbmVyV2lkdGggKyBpLnNldHRpbmdzLnNjcm9sbFhNYXJnaW5PZmZzZXQgPCBpLmNvbnRlbnRXaWR0aCkge1xyXG4gICAgaS5zY3JvbGxiYXJYQWN0aXZlID0gdHJ1ZTtcclxuICAgIGkucmFpbFhXaWR0aCA9IGkuY29udGFpbmVyV2lkdGggLSBpLnJhaWxYTWFyZ2luV2lkdGg7XHJcbiAgICBpLnJhaWxYUmF0aW8gPSBpLmNvbnRhaW5lcldpZHRoIC8gaS5yYWlsWFdpZHRoO1xyXG4gICAgaS5zY3JvbGxiYXJYV2lkdGggPSBnZXRUaHVtYlNpemUoaSwgXy50b0ludChpLnJhaWxYV2lkdGggKiBpLmNvbnRhaW5lcldpZHRoIC8gaS5jb250ZW50V2lkdGgpKTtcclxuICAgIGkuc2Nyb2xsYmFyWExlZnQgPSBfLnRvSW50KChpLm5lZ2F0aXZlU2Nyb2xsQWRqdXN0bWVudCArIGVsZW1lbnQuc2Nyb2xsTGVmdCkgKiAoaS5yYWlsWFdpZHRoIC0gaS5zY3JvbGxiYXJYV2lkdGgpIC8gKGkuY29udGVudFdpZHRoIC0gaS5jb250YWluZXJXaWR0aCkpO1xyXG4gIH0gZWxzZSB7XHJcbiAgICBpLnNjcm9sbGJhclhBY3RpdmUgPSBmYWxzZTtcclxuICB9XHJcblxyXG4gIGlmICghaS5zZXR0aW5ncy5zdXBwcmVzc1Njcm9sbFkgJiYgaS5jb250YWluZXJIZWlnaHQgKyBpLnNldHRpbmdzLnNjcm9sbFlNYXJnaW5PZmZzZXQgPCBpLmNvbnRlbnRIZWlnaHQpIHtcclxuICAgIGkuc2Nyb2xsYmFyWUFjdGl2ZSA9IHRydWU7XHJcbiAgICBpLnJhaWxZSGVpZ2h0ID0gaS5jb250YWluZXJIZWlnaHQgLSBpLnJhaWxZTWFyZ2luSGVpZ2h0O1xyXG4gICAgaS5yYWlsWVJhdGlvID0gaS5jb250YWluZXJIZWlnaHQgLyBpLnJhaWxZSGVpZ2h0O1xyXG4gICAgaS5zY3JvbGxiYXJZSGVpZ2h0ID0gZ2V0VGh1bWJTaXplKGksIF8udG9JbnQoaS5yYWlsWUhlaWdodCAqIGkuY29udGFpbmVySGVpZ2h0IC8gaS5jb250ZW50SGVpZ2h0KSk7XHJcbiAgICBpLnNjcm9sbGJhcllUb3AgPSBfLnRvSW50KGVsZW1lbnQuc2Nyb2xsVG9wICogKGkucmFpbFlIZWlnaHQgLSBpLnNjcm9sbGJhcllIZWlnaHQpIC8gKGkuY29udGVudEhlaWdodCAtIGkuY29udGFpbmVySGVpZ2h0KSk7XHJcbiAgfSBlbHNlIHtcclxuICAgIGkuc2Nyb2xsYmFyWUFjdGl2ZSA9IGZhbHNlO1xyXG4gIH1cclxuXHJcbiAgaWYgKGkuc2Nyb2xsYmFyWExlZnQgPj0gaS5yYWlsWFdpZHRoIC0gaS5zY3JvbGxiYXJYV2lkdGgpIHtcclxuICAgIGkuc2Nyb2xsYmFyWExlZnQgPSBpLnJhaWxYV2lkdGggLSBpLnNjcm9sbGJhclhXaWR0aDtcclxuICB9XHJcbiAgaWYgKGkuc2Nyb2xsYmFyWVRvcCA+PSBpLnJhaWxZSGVpZ2h0IC0gaS5zY3JvbGxiYXJZSGVpZ2h0KSB7XHJcbiAgICBpLnNjcm9sbGJhcllUb3AgPSBpLnJhaWxZSGVpZ2h0IC0gaS5zY3JvbGxiYXJZSGVpZ2h0O1xyXG4gIH1cclxuXHJcbiAgdXBkYXRlQ3NzKGVsZW1lbnQsIGkpO1xyXG5cclxuICBpZiAoaS5zY3JvbGxiYXJYQWN0aXZlKSB7XHJcbiAgICBjbHMuYWRkKGVsZW1lbnQsICdwcy1hY3RpdmUteCcpO1xyXG4gIH0gZWxzZSB7XHJcbiAgICBjbHMucmVtb3ZlKGVsZW1lbnQsICdwcy1hY3RpdmUteCcpO1xyXG4gICAgaS5zY3JvbGxiYXJYV2lkdGggPSAwO1xyXG4gICAgaS5zY3JvbGxiYXJYTGVmdCA9IDA7XHJcbiAgICB1cGRhdGVTY3JvbGwoZWxlbWVudCwgJ2xlZnQnLCAwKTtcclxuICB9XHJcbiAgaWYgKGkuc2Nyb2xsYmFyWUFjdGl2ZSkge1xyXG4gICAgY2xzLmFkZChlbGVtZW50LCAncHMtYWN0aXZlLXknKTtcclxuICB9IGVsc2Uge1xyXG4gICAgY2xzLnJlbW92ZShlbGVtZW50LCAncHMtYWN0aXZlLXknKTtcclxuICAgIGkuc2Nyb2xsYmFyWUhlaWdodCA9IDA7XHJcbiAgICBpLnNjcm9sbGJhcllUb3AgPSAwO1xyXG4gICAgdXBkYXRlU2Nyb2xsKGVsZW1lbnQsICd0b3AnLCAwKTtcclxuICB9XHJcbn07XHJcblxyXG59LHtcIi4uL2xpYi9jbGFzc1wiOjQsXCIuLi9saWIvZG9tXCI6NSxcIi4uL2xpYi9oZWxwZXJcIjo4LFwiLi9pbnN0YW5jZXNcIjoyMCxcIi4vdXBkYXRlLXNjcm9sbFwiOjIyfV0sMjI6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xyXG4ndXNlIHN0cmljdCc7XHJcblxyXG52YXIgaW5zdGFuY2VzID0gcmVxdWlyZSgnLi9pbnN0YW5jZXMnKTtcclxuXHJcbnZhciB1cEV2ZW50ID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoJ0V2ZW50Jyk7XHJcbnZhciBkb3duRXZlbnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnRXZlbnQnKTtcclxudmFyIGxlZnRFdmVudCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdFdmVudCcpO1xyXG52YXIgcmlnaHRFdmVudCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdFdmVudCcpO1xyXG52YXIgeUV2ZW50ID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoJ0V2ZW50Jyk7XHJcbnZhciB4RXZlbnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnRXZlbnQnKTtcclxudmFyIHhTdGFydEV2ZW50ID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoJ0V2ZW50Jyk7XHJcbnZhciB4RW5kRXZlbnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnRXZlbnQnKTtcclxudmFyIHlTdGFydEV2ZW50ID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoJ0V2ZW50Jyk7XHJcbnZhciB5RW5kRXZlbnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnRXZlbnQnKTtcclxudmFyIGxhc3RUb3A7XHJcbnZhciBsYXN0TGVmdDtcclxuXHJcbnVwRXZlbnQuaW5pdEV2ZW50KCdwcy1zY3JvbGwtdXAnLCB0cnVlLCB0cnVlKTtcclxuZG93bkV2ZW50LmluaXRFdmVudCgncHMtc2Nyb2xsLWRvd24nLCB0cnVlLCB0cnVlKTtcclxubGVmdEV2ZW50LmluaXRFdmVudCgncHMtc2Nyb2xsLWxlZnQnLCB0cnVlLCB0cnVlKTtcclxucmlnaHRFdmVudC5pbml0RXZlbnQoJ3BzLXNjcm9sbC1yaWdodCcsIHRydWUsIHRydWUpO1xyXG55RXZlbnQuaW5pdEV2ZW50KCdwcy1zY3JvbGwteScsIHRydWUsIHRydWUpO1xyXG54RXZlbnQuaW5pdEV2ZW50KCdwcy1zY3JvbGwteCcsIHRydWUsIHRydWUpO1xyXG54U3RhcnRFdmVudC5pbml0RXZlbnQoJ3BzLXgtcmVhY2gtc3RhcnQnLCB0cnVlLCB0cnVlKTtcclxueEVuZEV2ZW50LmluaXRFdmVudCgncHMteC1yZWFjaC1lbmQnLCB0cnVlLCB0cnVlKTtcclxueVN0YXJ0RXZlbnQuaW5pdEV2ZW50KCdwcy15LXJlYWNoLXN0YXJ0JywgdHJ1ZSwgdHJ1ZSk7XHJcbnlFbmRFdmVudC5pbml0RXZlbnQoJ3BzLXktcmVhY2gtZW5kJywgdHJ1ZSwgdHJ1ZSk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChlbGVtZW50LCBheGlzLCB2YWx1ZSkge1xyXG4gIGlmICh0eXBlb2YgZWxlbWVudCA9PT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgIHRocm93ICdZb3UgbXVzdCBwcm92aWRlIGFuIGVsZW1lbnQgdG8gdGhlIHVwZGF0ZS1zY3JvbGwgZnVuY3Rpb24nO1xyXG4gIH1cclxuXHJcbiAgaWYgKHR5cGVvZiBheGlzID09PSAndW5kZWZpbmVkJykge1xyXG4gICAgdGhyb3cgJ1lvdSBtdXN0IHByb3ZpZGUgYW4gYXhpcyB0byB0aGUgdXBkYXRlLXNjcm9sbCBmdW5jdGlvbic7XHJcbiAgfVxyXG5cclxuICBpZiAodHlwZW9mIHZhbHVlID09PSAndW5kZWZpbmVkJykge1xyXG4gICAgdGhyb3cgJ1lvdSBtdXN0IHByb3ZpZGUgYSB2YWx1ZSB0byB0aGUgdXBkYXRlLXNjcm9sbCBmdW5jdGlvbic7XHJcbiAgfVxyXG5cclxuICBpZiAoYXhpcyA9PT0gJ3RvcCcgJiYgdmFsdWUgPD0gMCkge1xyXG4gICAgZWxlbWVudC5zY3JvbGxUb3AgPSB2YWx1ZSA9IDA7IC8vIGRvbid0IGFsbG93IG5lZ2F0aXZlIHNjcm9sbFxyXG4gICAgZWxlbWVudC5kaXNwYXRjaEV2ZW50KHlTdGFydEV2ZW50KTtcclxuICB9XHJcblxyXG4gIGlmIChheGlzID09PSAnbGVmdCcgJiYgdmFsdWUgPD0gMCkge1xyXG4gICAgZWxlbWVudC5zY3JvbGxMZWZ0ID0gdmFsdWUgPSAwOyAvLyBkb24ndCBhbGxvdyBuZWdhdGl2ZSBzY3JvbGxcclxuICAgIGVsZW1lbnQuZGlzcGF0Y2hFdmVudCh4U3RhcnRFdmVudCk7XHJcbiAgfVxyXG5cclxuICB2YXIgaSA9IGluc3RhbmNlcy5nZXQoZWxlbWVudCk7XHJcblxyXG4gIGlmIChheGlzID09PSAndG9wJyAmJiB2YWx1ZSA+PSBpLmNvbnRlbnRIZWlnaHQgLSBpLmNvbnRhaW5lckhlaWdodCkge1xyXG4gICAgLy8gZG9uJ3QgYWxsb3cgc2Nyb2xsIHBhc3QgY29udGFpbmVyXHJcbiAgICB2YWx1ZSA9IGkuY29udGVudEhlaWdodCAtIGkuY29udGFpbmVySGVpZ2h0O1xyXG4gICAgaWYgKHZhbHVlIC0gZWxlbWVudC5zY3JvbGxUb3AgPD0gMSkge1xyXG4gICAgICAvLyBtaXRpZ2F0ZXMgcm91bmRpbmcgZXJyb3JzIG9uIG5vbi1zdWJwaXhlbCBzY3JvbGwgdmFsdWVzXHJcbiAgICAgIHZhbHVlID0gZWxlbWVudC5zY3JvbGxUb3A7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBlbGVtZW50LnNjcm9sbFRvcCA9IHZhbHVlO1xyXG4gICAgfVxyXG4gICAgZWxlbWVudC5kaXNwYXRjaEV2ZW50KHlFbmRFdmVudCk7XHJcbiAgfVxyXG5cclxuICBpZiAoYXhpcyA9PT0gJ2xlZnQnICYmIHZhbHVlID49IGkuY29udGVudFdpZHRoIC0gaS5jb250YWluZXJXaWR0aCkge1xyXG4gICAgLy8gZG9uJ3QgYWxsb3cgc2Nyb2xsIHBhc3QgY29udGFpbmVyXHJcbiAgICB2YWx1ZSA9IGkuY29udGVudFdpZHRoIC0gaS5jb250YWluZXJXaWR0aDtcclxuICAgIGlmICh2YWx1ZSAtIGVsZW1lbnQuc2Nyb2xsTGVmdCA8PSAxKSB7XHJcbiAgICAgIC8vIG1pdGlnYXRlcyByb3VuZGluZyBlcnJvcnMgb24gbm9uLXN1YnBpeGVsIHNjcm9sbCB2YWx1ZXNcclxuICAgICAgdmFsdWUgPSBlbGVtZW50LnNjcm9sbExlZnQ7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBlbGVtZW50LnNjcm9sbExlZnQgPSB2YWx1ZTtcclxuICAgIH1cclxuICAgIGVsZW1lbnQuZGlzcGF0Y2hFdmVudCh4RW5kRXZlbnQpO1xyXG4gIH1cclxuXHJcbiAgaWYgKCFsYXN0VG9wKSB7XHJcbiAgICBsYXN0VG9wID0gZWxlbWVudC5zY3JvbGxUb3A7XHJcbiAgfVxyXG5cclxuICBpZiAoIWxhc3RMZWZ0KSB7XHJcbiAgICBsYXN0TGVmdCA9IGVsZW1lbnQuc2Nyb2xsTGVmdDtcclxuICB9XHJcblxyXG4gIGlmIChheGlzID09PSAndG9wJyAmJiB2YWx1ZSA8IGxhc3RUb3ApIHtcclxuICAgIGVsZW1lbnQuZGlzcGF0Y2hFdmVudCh1cEV2ZW50KTtcclxuICB9XHJcblxyXG4gIGlmIChheGlzID09PSAndG9wJyAmJiB2YWx1ZSA+IGxhc3RUb3ApIHtcclxuICAgIGVsZW1lbnQuZGlzcGF0Y2hFdmVudChkb3duRXZlbnQpO1xyXG4gIH1cclxuXHJcbiAgaWYgKGF4aXMgPT09ICdsZWZ0JyAmJiB2YWx1ZSA8IGxhc3RMZWZ0KSB7XHJcbiAgICBlbGVtZW50LmRpc3BhdGNoRXZlbnQobGVmdEV2ZW50KTtcclxuICB9XHJcblxyXG4gIGlmIChheGlzID09PSAnbGVmdCcgJiYgdmFsdWUgPiBsYXN0TGVmdCkge1xyXG4gICAgZWxlbWVudC5kaXNwYXRjaEV2ZW50KHJpZ2h0RXZlbnQpO1xyXG4gIH1cclxuXHJcbiAgaWYgKGF4aXMgPT09ICd0b3AnKSB7XHJcbiAgICBlbGVtZW50LnNjcm9sbFRvcCA9IGxhc3RUb3AgPSB2YWx1ZTtcclxuICAgIGVsZW1lbnQuZGlzcGF0Y2hFdmVudCh5RXZlbnQpO1xyXG4gIH1cclxuXHJcbiAgaWYgKGF4aXMgPT09ICdsZWZ0Jykge1xyXG4gICAgZWxlbWVudC5zY3JvbGxMZWZ0ID0gbGFzdExlZnQgPSB2YWx1ZTtcclxuICAgIGVsZW1lbnQuZGlzcGF0Y2hFdmVudCh4RXZlbnQpO1xyXG4gIH1cclxuXHJcbn07XHJcblxyXG59LHtcIi4vaW5zdGFuY2VzXCI6MjB9XSwyMzpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XHJcbid1c2Ugc3RyaWN0JztcclxuXHJcbnZhciBfID0gcmVxdWlyZSgnLi4vbGliL2hlbHBlcicpO1xyXG52YXIgZG9tID0gcmVxdWlyZSgnLi4vbGliL2RvbScpO1xyXG52YXIgaW5zdGFuY2VzID0gcmVxdWlyZSgnLi9pbnN0YW5jZXMnKTtcclxudmFyIHVwZGF0ZUdlb21ldHJ5ID0gcmVxdWlyZSgnLi91cGRhdGUtZ2VvbWV0cnknKTtcclxudmFyIHVwZGF0ZVNjcm9sbCA9IHJlcXVpcmUoJy4vdXBkYXRlLXNjcm9sbCcpO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZWxlbWVudCkge1xyXG4gIHZhciBpID0gaW5zdGFuY2VzLmdldChlbGVtZW50KTtcclxuXHJcbiAgaWYgKCFpKSB7XHJcbiAgICByZXR1cm47XHJcbiAgfVxyXG5cclxuICAvLyBSZWNhbGN1YXRlIG5lZ2F0aXZlIHNjcm9sbExlZnQgYWRqdXN0bWVudFxyXG4gIGkubmVnYXRpdmVTY3JvbGxBZGp1c3RtZW50ID0gaS5pc05lZ2F0aXZlU2Nyb2xsID8gZWxlbWVudC5zY3JvbGxXaWR0aCAtIGVsZW1lbnQuY2xpZW50V2lkdGggOiAwO1xyXG5cclxuICAvLyBSZWNhbGN1bGF0ZSByYWlsIG1hcmdpbnNcclxuICBkb20uY3NzKGkuc2Nyb2xsYmFyWFJhaWwsICdkaXNwbGF5JywgJ2Jsb2NrJyk7XHJcbiAgZG9tLmNzcyhpLnNjcm9sbGJhcllSYWlsLCAnZGlzcGxheScsICdibG9jaycpO1xyXG4gIGkucmFpbFhNYXJnaW5XaWR0aCA9IF8udG9JbnQoZG9tLmNzcyhpLnNjcm9sbGJhclhSYWlsLCAnbWFyZ2luTGVmdCcpKSArIF8udG9JbnQoZG9tLmNzcyhpLnNjcm9sbGJhclhSYWlsLCAnbWFyZ2luUmlnaHQnKSk7XHJcbiAgaS5yYWlsWU1hcmdpbkhlaWdodCA9IF8udG9JbnQoZG9tLmNzcyhpLnNjcm9sbGJhcllSYWlsLCAnbWFyZ2luVG9wJykpICsgXy50b0ludChkb20uY3NzKGkuc2Nyb2xsYmFyWVJhaWwsICdtYXJnaW5Cb3R0b20nKSk7XHJcblxyXG4gIC8vIEhpZGUgc2Nyb2xsYmFycyBub3QgdG8gYWZmZWN0IHNjcm9sbFdpZHRoIGFuZCBzY3JvbGxIZWlnaHRcclxuICBkb20uY3NzKGkuc2Nyb2xsYmFyWFJhaWwsICdkaXNwbGF5JywgJ25vbmUnKTtcclxuICBkb20uY3NzKGkuc2Nyb2xsYmFyWVJhaWwsICdkaXNwbGF5JywgJ25vbmUnKTtcclxuXHJcbiAgdXBkYXRlR2VvbWV0cnkoZWxlbWVudCk7XHJcblxyXG4gIC8vIFVwZGF0ZSB0b3AvbGVmdCBzY3JvbGwgdG8gdHJpZ2dlciBldmVudHNcclxuICB1cGRhdGVTY3JvbGwoZWxlbWVudCwgJ3RvcCcsIGVsZW1lbnQuc2Nyb2xsVG9wKTtcclxuICB1cGRhdGVTY3JvbGwoZWxlbWVudCwgJ2xlZnQnLCBlbGVtZW50LnNjcm9sbExlZnQpO1xyXG5cclxuICBkb20uY3NzKGkuc2Nyb2xsYmFyWFJhaWwsICdkaXNwbGF5JywgJycpO1xyXG4gIGRvbS5jc3MoaS5zY3JvbGxiYXJZUmFpbCwgJ2Rpc3BsYXknLCAnJyk7XHJcbn07XHJcblxyXG59LHtcIi4uL2xpYi9kb21cIjo1LFwiLi4vbGliL2hlbHBlclwiOjgsXCIuL2luc3RhbmNlc1wiOjIwLFwiLi91cGRhdGUtZ2VvbWV0cnlcIjoyMSxcIi4vdXBkYXRlLXNjcm9sbFwiOjIyfV19LHt9LFsxXSk7XHJcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NjcmlwdHMvdmVuZG9ycy9rbm9ja291dC1zY3JvbGxiYXIuanMiLCIvKlxyXG4gXyBfICAgICAgXyAgICAgICBfXHJcbiBfX198IChfKSBfX198IHwgX18gIChfKV9fX1xyXG4gLyBfX3wgfCB8LyBfX3wgfC8gLyAgfCAvIF9ffFxyXG4gXFxfXyBcXCB8IHwgKF9ffCAgIDwgXyB8IFxcX18gXFxcclxuIHxfX18vX3xffFxcX19ffF98XFxfKF8pLyB8X19fL1xyXG4gfF9fL1xyXG5cclxuIFZlcnNpb246IDEuNS45XHJcbiBBdXRob3I6IEtlbiBXaGVlbGVyXHJcbiBXZWJzaXRlOiBodHRwOi8va2Vud2hlZWxlci5naXRodWIuaW9cclxuIERvY3M6IGh0dHA6Ly9rZW53aGVlbGVyLmdpdGh1Yi5pby9zbGlja1xyXG4gUmVwbzogaHR0cDovL2dpdGh1Yi5jb20va2Vud2hlZWxlci9zbGlja1xyXG4gSXNzdWVzOiBodHRwOi8vZ2l0aHViLmNvbS9rZW53aGVlbGVyL3NsaWNrL2lzc3Vlc1xyXG5cclxuICovXHJcbiFmdW5jdGlvbihhKXtcInVzZSBzdHJpY3RcIjtcImZ1bmN0aW9uXCI9PXR5cGVvZiBkZWZpbmUmJmRlZmluZS5hbWQ/ZGVmaW5lKFtcImpxdWVyeVwiXSxhKTpcInVuZGVmaW5lZFwiIT10eXBlb2YgZXhwb3J0cz9tb2R1bGUuZXhwb3J0cz1hKHJlcXVpcmUoXCJqcXVlcnlcIikpOmEoalF1ZXJ5KX0oZnVuY3Rpb24oYSl7XCJ1c2Ugc3RyaWN0XCI7dmFyIGI9d2luZG93LlNsaWNrfHx7fTtiPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gYyhjLGQpe3ZhciBmLGU9dGhpcztlLmRlZmF1bHRzPXthY2Nlc3NpYmlsaXR5OiEwLGFkYXB0aXZlSGVpZ2h0OiExLGFwcGVuZEFycm93czphKGMpLGFwcGVuZERvdHM6YShjKSxhcnJvd3M6ITAsYXNOYXZGb3I6bnVsbCxwcmV2QXJyb3c6JzxidXR0b24gdHlwZT1cImJ1dHRvblwiIGRhdGEtcm9sZT1cIm5vbmVcIiBjbGFzcz1cInNsaWNrLXByZXZcIiBhcmlhLWxhYmVsPVwiUHJldmlvdXNcIiB0YWJpbmRleD1cIjBcIiByb2xlPVwiYnV0dG9uXCI+UHJldmlvdXM8L2J1dHRvbj4nLG5leHRBcnJvdzonPGJ1dHRvbiB0eXBlPVwiYnV0dG9uXCIgZGF0YS1yb2xlPVwibm9uZVwiIGNsYXNzPVwic2xpY2stbmV4dFwiIGFyaWEtbGFiZWw9XCJOZXh0XCIgdGFiaW5kZXg9XCIwXCIgcm9sZT1cImJ1dHRvblwiPk5leHQ8L2J1dHRvbj4nLGF1dG9wbGF5OiExLGF1dG9wbGF5U3BlZWQ6M2UzLGNlbnRlck1vZGU6ITEsY2VudGVyUGFkZGluZzpcIjUwcHhcIixjc3NFYXNlOlwiZWFzZVwiLGN1c3RvbVBhZ2luZzpmdW5jdGlvbihhLGIpe3JldHVybic8YnV0dG9uIHR5cGU9XCJidXR0b25cIiBkYXRhLXJvbGU9XCJub25lXCIgcm9sZT1cImJ1dHRvblwiIGFyaWEtcmVxdWlyZWQ9XCJmYWxzZVwiIHRhYmluZGV4PVwiMFwiPicrKGIrMSkrXCI8L2J1dHRvbj5cIn0sZG90czohMSxkb3RzQ2xhc3M6XCJzbGljay1kb3RzXCIsZHJhZ2dhYmxlOiEwLGVhc2luZzpcImxpbmVhclwiLGVkZ2VGcmljdGlvbjouMzUsZmFkZTohMSxmb2N1c09uU2VsZWN0OiExLGluZmluaXRlOiEwLGluaXRpYWxTbGlkZTowLGxhenlMb2FkOlwib25kZW1hbmRcIixtb2JpbGVGaXJzdDohMSxwYXVzZU9uSG92ZXI6ITAscGF1c2VPbkRvdHNIb3ZlcjohMSxyZXNwb25kVG86XCJ3aW5kb3dcIixyZXNwb25zaXZlOm51bGwscm93czoxLHJ0bDohMSxzbGlkZTpcIlwiLHNsaWRlc1BlclJvdzoxLHNsaWRlc1RvU2hvdzoxLHNsaWRlc1RvU2Nyb2xsOjEsc3BlZWQ6NTAwLHN3aXBlOiEwLHN3aXBlVG9TbGlkZTohMSx0b3VjaE1vdmU6ITAsdG91Y2hUaHJlc2hvbGQ6NSx1c2VDU1M6ITAsdXNlVHJhbnNmb3JtOiExLHZhcmlhYmxlV2lkdGg6ITEsdmVydGljYWw6ITEsdmVydGljYWxTd2lwaW5nOiExLHdhaXRGb3JBbmltYXRlOiEwLHpJbmRleDoxZTN9LGUuaW5pdGlhbHM9e2FuaW1hdGluZzohMSxkcmFnZ2luZzohMSxhdXRvUGxheVRpbWVyOm51bGwsY3VycmVudERpcmVjdGlvbjowLGN1cnJlbnRMZWZ0Om51bGwsY3VycmVudFNsaWRlOjAsZGlyZWN0aW9uOjEsJGRvdHM6bnVsbCxsaXN0V2lkdGg6bnVsbCxsaXN0SGVpZ2h0Om51bGwsbG9hZEluZGV4OjAsJG5leHRBcnJvdzpudWxsLCRwcmV2QXJyb3c6bnVsbCxzbGlkZUNvdW50Om51bGwsc2xpZGVXaWR0aDpudWxsLCRzbGlkZVRyYWNrOm51bGwsJHNsaWRlczpudWxsLHNsaWRpbmc6ITEsc2xpZGVPZmZzZXQ6MCxzd2lwZUxlZnQ6bnVsbCwkbGlzdDpudWxsLHRvdWNoT2JqZWN0Ont9LHRyYW5zZm9ybXNFbmFibGVkOiExLHVuc2xpY2tlZDohMX0sYS5leHRlbmQoZSxlLmluaXRpYWxzKSxlLmFjdGl2ZUJyZWFrcG9pbnQ9bnVsbCxlLmFuaW1UeXBlPW51bGwsZS5hbmltUHJvcD1udWxsLGUuYnJlYWtwb2ludHM9W10sZS5icmVha3BvaW50U2V0dGluZ3M9W10sZS5jc3NUcmFuc2l0aW9ucz0hMSxlLmhpZGRlbj1cImhpZGRlblwiLGUucGF1c2VkPSExLGUucG9zaXRpb25Qcm9wPW51bGwsZS5yZXNwb25kVG89bnVsbCxlLnJvd0NvdW50PTEsZS5zaG91bGRDbGljaz0hMCxlLiRzbGlkZXI9YShjKSxlLiRzbGlkZXNDYWNoZT1udWxsLGUudHJhbnNmb3JtVHlwZT1udWxsLGUudHJhbnNpdGlvblR5cGU9bnVsbCxlLnZpc2liaWxpdHlDaGFuZ2U9XCJ2aXNpYmlsaXR5Y2hhbmdlXCIsZS53aW5kb3dXaWR0aD0wLGUud2luZG93VGltZXI9bnVsbCxmPWEoYykuZGF0YShcInNsaWNrXCIpfHx7fSxlLm9wdGlvbnM9YS5leHRlbmQoe30sZS5kZWZhdWx0cyxmLGQpLGUuY3VycmVudFNsaWRlPWUub3B0aW9ucy5pbml0aWFsU2xpZGUsZS5vcmlnaW5hbFNldHRpbmdzPWUub3B0aW9ucyxcInVuZGVmaW5lZFwiIT10eXBlb2YgZG9jdW1lbnQubW96SGlkZGVuPyhlLmhpZGRlbj1cIm1vekhpZGRlblwiLGUudmlzaWJpbGl0eUNoYW5nZT1cIm1venZpc2liaWxpdHljaGFuZ2VcIik6XCJ1bmRlZmluZWRcIiE9dHlwZW9mIGRvY3VtZW50LndlYmtpdEhpZGRlbiYmKGUuaGlkZGVuPVwid2Via2l0SGlkZGVuXCIsZS52aXNpYmlsaXR5Q2hhbmdlPVwid2Via2l0dmlzaWJpbGl0eWNoYW5nZVwiKSxlLmF1dG9QbGF5PWEucHJveHkoZS5hdXRvUGxheSxlKSxlLmF1dG9QbGF5Q2xlYXI9YS5wcm94eShlLmF1dG9QbGF5Q2xlYXIsZSksZS5jaGFuZ2VTbGlkZT1hLnByb3h5KGUuY2hhbmdlU2xpZGUsZSksZS5jbGlja0hhbmRsZXI9YS5wcm94eShlLmNsaWNrSGFuZGxlcixlKSxlLnNlbGVjdEhhbmRsZXI9YS5wcm94eShlLnNlbGVjdEhhbmRsZXIsZSksZS5zZXRQb3NpdGlvbj1hLnByb3h5KGUuc2V0UG9zaXRpb24sZSksZS5zd2lwZUhhbmRsZXI9YS5wcm94eShlLnN3aXBlSGFuZGxlcixlKSxlLmRyYWdIYW5kbGVyPWEucHJveHkoZS5kcmFnSGFuZGxlcixlKSxlLmtleUhhbmRsZXI9YS5wcm94eShlLmtleUhhbmRsZXIsZSksZS5hdXRvUGxheUl0ZXJhdG9yPWEucHJveHkoZS5hdXRvUGxheUl0ZXJhdG9yLGUpLGUuaW5zdGFuY2VVaWQ9YisrLGUuaHRtbEV4cHI9L14oPzpcXHMqKDxbXFx3XFxXXSs+KVtePl0qKSQvLGUucmVnaXN0ZXJCcmVha3BvaW50cygpLGUuaW5pdCghMCksZS5jaGVja1Jlc3BvbnNpdmUoITApfXZhciBiPTA7cmV0dXJuIGN9KCksYi5wcm90b3R5cGUuYWRkU2xpZGU9Yi5wcm90b3R5cGUuc2xpY2tBZGQ9ZnVuY3Rpb24oYixjLGQpe3ZhciBlPXRoaXM7aWYoXCJib29sZWFuXCI9PXR5cGVvZiBjKWQ9YyxjPW51bGw7ZWxzZSBpZigwPmN8fGM+PWUuc2xpZGVDb3VudClyZXR1cm4hMTtlLnVubG9hZCgpLFwibnVtYmVyXCI9PXR5cGVvZiBjPzA9PT1jJiYwPT09ZS4kc2xpZGVzLmxlbmd0aD9hKGIpLmFwcGVuZFRvKGUuJHNsaWRlVHJhY2spOmQ/YShiKS5pbnNlcnRCZWZvcmUoZS4kc2xpZGVzLmVxKGMpKTphKGIpLmluc2VydEFmdGVyKGUuJHNsaWRlcy5lcShjKSk6ZD09PSEwP2EoYikucHJlcGVuZFRvKGUuJHNsaWRlVHJhY2spOmEoYikuYXBwZW5kVG8oZS4kc2xpZGVUcmFjayksZS4kc2xpZGVzPWUuJHNsaWRlVHJhY2suY2hpbGRyZW4odGhpcy5vcHRpb25zLnNsaWRlKSxlLiRzbGlkZVRyYWNrLmNoaWxkcmVuKHRoaXMub3B0aW9ucy5zbGlkZSkuZGV0YWNoKCksZS4kc2xpZGVUcmFjay5hcHBlbmQoZS4kc2xpZGVzKSxlLiRzbGlkZXMuZWFjaChmdW5jdGlvbihiLGMpe2EoYykuYXR0cihcImRhdGEtc2xpY2staW5kZXhcIixiKX0pLGUuJHNsaWRlc0NhY2hlPWUuJHNsaWRlcyxlLnJlaW5pdCgpfSxiLnByb3RvdHlwZS5hbmltYXRlSGVpZ2h0PWZ1bmN0aW9uKCl7dmFyIGE9dGhpcztpZigxPT09YS5vcHRpb25zLnNsaWRlc1RvU2hvdyYmYS5vcHRpb25zLmFkYXB0aXZlSGVpZ2h0PT09ITAmJmEub3B0aW9ucy52ZXJ0aWNhbD09PSExKXt2YXIgYj1hLiRzbGlkZXMuZXEoYS5jdXJyZW50U2xpZGUpLm91dGVySGVpZ2h0KCEwKTthLiRsaXN0LmFuaW1hdGUoe2hlaWdodDpifSxhLm9wdGlvbnMuc3BlZWQpfX0sYi5wcm90b3R5cGUuYW5pbWF0ZVNsaWRlPWZ1bmN0aW9uKGIsYyl7dmFyIGQ9e30sZT10aGlzO2UuYW5pbWF0ZUhlaWdodCgpLGUub3B0aW9ucy5ydGw9PT0hMCYmZS5vcHRpb25zLnZlcnRpY2FsPT09ITEmJihiPS1iKSxlLnRyYW5zZm9ybXNFbmFibGVkPT09ITE/ZS5vcHRpb25zLnZlcnRpY2FsPT09ITE/ZS4kc2xpZGVUcmFjay5hbmltYXRlKHtsZWZ0OmJ9LGUub3B0aW9ucy5zcGVlZCxlLm9wdGlvbnMuZWFzaW5nLGMpOmUuJHNsaWRlVHJhY2suYW5pbWF0ZSh7dG9wOmJ9LGUub3B0aW9ucy5zcGVlZCxlLm9wdGlvbnMuZWFzaW5nLGMpOmUuY3NzVHJhbnNpdGlvbnM9PT0hMT8oZS5vcHRpb25zLnJ0bD09PSEwJiYoZS5jdXJyZW50TGVmdD0tZS5jdXJyZW50TGVmdCksYSh7YW5pbVN0YXJ0OmUuY3VycmVudExlZnR9KS5hbmltYXRlKHthbmltU3RhcnQ6Yn0se2R1cmF0aW9uOmUub3B0aW9ucy5zcGVlZCxlYXNpbmc6ZS5vcHRpb25zLmVhc2luZyxzdGVwOmZ1bmN0aW9uKGEpe2E9TWF0aC5jZWlsKGEpLGUub3B0aW9ucy52ZXJ0aWNhbD09PSExPyhkW2UuYW5pbVR5cGVdPVwidHJhbnNsYXRlKFwiK2ErXCJweCwgMHB4KVwiLGUuJHNsaWRlVHJhY2suY3NzKGQpKTooZFtlLmFuaW1UeXBlXT1cInRyYW5zbGF0ZSgwcHgsXCIrYStcInB4KVwiLGUuJHNsaWRlVHJhY2suY3NzKGQpKX0sY29tcGxldGU6ZnVuY3Rpb24oKXtjJiZjLmNhbGwoKX19KSk6KGUuYXBwbHlUcmFuc2l0aW9uKCksYj1NYXRoLmNlaWwoYiksZS5vcHRpb25zLnZlcnRpY2FsPT09ITE/ZFtlLmFuaW1UeXBlXT1cInRyYW5zbGF0ZTNkKFwiK2IrXCJweCwgMHB4LCAwcHgpXCI6ZFtlLmFuaW1UeXBlXT1cInRyYW5zbGF0ZTNkKDBweCxcIitiK1wicHgsIDBweClcIixlLiRzbGlkZVRyYWNrLmNzcyhkKSxjJiZzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7ZS5kaXNhYmxlVHJhbnNpdGlvbigpLGMuY2FsbCgpfSxlLm9wdGlvbnMuc3BlZWQpKX0sYi5wcm90b3R5cGUuYXNOYXZGb3I9ZnVuY3Rpb24oYil7dmFyIGM9dGhpcyxkPWMub3B0aW9ucy5hc05hdkZvcjtkJiZudWxsIT09ZCYmKGQ9YShkKS5ub3QoYy4kc2xpZGVyKSksbnVsbCE9PWQmJlwib2JqZWN0XCI9PXR5cGVvZiBkJiZkLmVhY2goZnVuY3Rpb24oKXt2YXIgYz1hKHRoaXMpLnNsaWNrKFwiZ2V0U2xpY2tcIik7Yy51bnNsaWNrZWR8fGMuc2xpZGVIYW5kbGVyKGIsITApfSl9LGIucHJvdG90eXBlLmFwcGx5VHJhbnNpdGlvbj1mdW5jdGlvbihhKXt2YXIgYj10aGlzLGM9e307Yi5vcHRpb25zLmZhZGU9PT0hMT9jW2IudHJhbnNpdGlvblR5cGVdPWIudHJhbnNmb3JtVHlwZStcIiBcIitiLm9wdGlvbnMuc3BlZWQrXCJtcyBcIitiLm9wdGlvbnMuY3NzRWFzZTpjW2IudHJhbnNpdGlvblR5cGVdPVwib3BhY2l0eSBcIitiLm9wdGlvbnMuc3BlZWQrXCJtcyBcIitiLm9wdGlvbnMuY3NzRWFzZSxiLm9wdGlvbnMuZmFkZT09PSExP2IuJHNsaWRlVHJhY2suY3NzKGMpOmIuJHNsaWRlcy5lcShhKS5jc3MoYyl9LGIucHJvdG90eXBlLmF1dG9QbGF5PWZ1bmN0aW9uKCl7dmFyIGE9dGhpczthLmF1dG9QbGF5VGltZXImJmNsZWFySW50ZXJ2YWwoYS5hdXRvUGxheVRpbWVyKSxhLnNsaWRlQ291bnQ+YS5vcHRpb25zLnNsaWRlc1RvU2hvdyYmYS5wYXVzZWQhPT0hMCYmKGEuYXV0b1BsYXlUaW1lcj1zZXRJbnRlcnZhbChhLmF1dG9QbGF5SXRlcmF0b3IsYS5vcHRpb25zLmF1dG9wbGF5U3BlZWQpKX0sYi5wcm90b3R5cGUuYXV0b1BsYXlDbGVhcj1mdW5jdGlvbigpe3ZhciBhPXRoaXM7YS5hdXRvUGxheVRpbWVyJiZjbGVhckludGVydmFsKGEuYXV0b1BsYXlUaW1lcil9LGIucHJvdG90eXBlLmF1dG9QbGF5SXRlcmF0b3I9ZnVuY3Rpb24oKXt2YXIgYT10aGlzO2Eub3B0aW9ucy5pbmZpbml0ZT09PSExPzE9PT1hLmRpcmVjdGlvbj8oYS5jdXJyZW50U2xpZGUrMT09PWEuc2xpZGVDb3VudC0xJiYoYS5kaXJlY3Rpb249MCksYS5zbGlkZUhhbmRsZXIoYS5jdXJyZW50U2xpZGUrYS5vcHRpb25zLnNsaWRlc1RvU2Nyb2xsKSk6KGEuY3VycmVudFNsaWRlLTE9PT0wJiYoYS5kaXJlY3Rpb249MSksYS5zbGlkZUhhbmRsZXIoYS5jdXJyZW50U2xpZGUtYS5vcHRpb25zLnNsaWRlc1RvU2Nyb2xsKSk6YS5zbGlkZUhhbmRsZXIoYS5jdXJyZW50U2xpZGUrYS5vcHRpb25zLnNsaWRlc1RvU2Nyb2xsKX0sYi5wcm90b3R5cGUuYnVpbGRBcnJvd3M9ZnVuY3Rpb24oKXt2YXIgYj10aGlzO2Iub3B0aW9ucy5hcnJvd3M9PT0hMCYmKGIuJHByZXZBcnJvdz1hKGIub3B0aW9ucy5wcmV2QXJyb3cpLmFkZENsYXNzKFwic2xpY2stYXJyb3dcIiksYi4kbmV4dEFycm93PWEoYi5vcHRpb25zLm5leHRBcnJvdykuYWRkQ2xhc3MoXCJzbGljay1hcnJvd1wiKSxiLnNsaWRlQ291bnQ+Yi5vcHRpb25zLnNsaWRlc1RvU2hvdz8oYi4kcHJldkFycm93LnJlbW92ZUNsYXNzKFwic2xpY2staGlkZGVuXCIpLnJlbW92ZUF0dHIoXCJhcmlhLWhpZGRlbiB0YWJpbmRleFwiKSxiLiRuZXh0QXJyb3cucmVtb3ZlQ2xhc3MoXCJzbGljay1oaWRkZW5cIikucmVtb3ZlQXR0cihcImFyaWEtaGlkZGVuIHRhYmluZGV4XCIpLGIuaHRtbEV4cHIudGVzdChiLm9wdGlvbnMucHJldkFycm93KSYmYi4kcHJldkFycm93LnByZXBlbmRUbyhiLm9wdGlvbnMuYXBwZW5kQXJyb3dzKSxiLmh0bWxFeHByLnRlc3QoYi5vcHRpb25zLm5leHRBcnJvdykmJmIuJG5leHRBcnJvdy5hcHBlbmRUbyhiLm9wdGlvbnMuYXBwZW5kQXJyb3dzKSxiLm9wdGlvbnMuaW5maW5pdGUhPT0hMCYmYi4kcHJldkFycm93LmFkZENsYXNzKFwic2xpY2stZGlzYWJsZWRcIikuYXR0cihcImFyaWEtZGlzYWJsZWRcIixcInRydWVcIikpOmIuJHByZXZBcnJvdy5hZGQoYi4kbmV4dEFycm93KS5hZGRDbGFzcyhcInNsaWNrLWhpZGRlblwiKS5hdHRyKHtcImFyaWEtZGlzYWJsZWRcIjpcInRydWVcIix0YWJpbmRleDpcIi0xXCJ9KSl9LGIucHJvdG90eXBlLmJ1aWxkRG90cz1mdW5jdGlvbigpe3ZhciBjLGQsYj10aGlzO2lmKGIub3B0aW9ucy5kb3RzPT09ITAmJmIuc2xpZGVDb3VudD5iLm9wdGlvbnMuc2xpZGVzVG9TaG93KXtmb3IoZD0nPHVsIGNsYXNzPVwiJytiLm9wdGlvbnMuZG90c0NsYXNzKydcIj4nLGM9MDtjPD1iLmdldERvdENvdW50KCk7Yys9MSlkKz1cIjxsaT5cIitiLm9wdGlvbnMuY3VzdG9tUGFnaW5nLmNhbGwodGhpcyxiLGMpK1wiPC9saT5cIjtkKz1cIjwvdWw+XCIsYi4kZG90cz1hKGQpLmFwcGVuZFRvKGIub3B0aW9ucy5hcHBlbmREb3RzKSxiLiRkb3RzLmZpbmQoXCJsaVwiKS5maXJzdCgpLmFkZENsYXNzKFwic2xpY2stYWN0aXZlXCIpLmF0dHIoXCJhcmlhLWhpZGRlblwiLFwiZmFsc2VcIil9fSxiLnByb3RvdHlwZS5idWlsZE91dD1mdW5jdGlvbigpe3ZhciBiPXRoaXM7Yi4kc2xpZGVzPWIuJHNsaWRlci5jaGlsZHJlbihiLm9wdGlvbnMuc2xpZGUrXCI6bm90KC5zbGljay1jbG9uZWQpXCIpLmFkZENsYXNzKFwic2xpY2stc2xpZGVcIiksYi5zbGlkZUNvdW50PWIuJHNsaWRlcy5sZW5ndGgsYi4kc2xpZGVzLmVhY2goZnVuY3Rpb24oYixjKXthKGMpLmF0dHIoXCJkYXRhLXNsaWNrLWluZGV4XCIsYikuZGF0YShcIm9yaWdpbmFsU3R5bGluZ1wiLGEoYykuYXR0cihcInN0eWxlXCIpfHxcIlwiKX0pLGIuJHNsaWRlci5hZGRDbGFzcyhcInNsaWNrLXNsaWRlclwiKSxiLiRzbGlkZVRyYWNrPTA9PT1iLnNsaWRlQ291bnQ/YSgnPGRpdiBjbGFzcz1cInNsaWNrLXRyYWNrXCIvPicpLmFwcGVuZFRvKGIuJHNsaWRlcik6Yi4kc2xpZGVzLndyYXBBbGwoJzxkaXYgY2xhc3M9XCJzbGljay10cmFja1wiLz4nKS5wYXJlbnQoKSxiLiRsaXN0PWIuJHNsaWRlVHJhY2sud3JhcCgnPGRpdiBhcmlhLWxpdmU9XCJwb2xpdGVcIiBjbGFzcz1cInNsaWNrLWxpc3RcIi8+JykucGFyZW50KCksYi4kc2xpZGVUcmFjay5jc3MoXCJvcGFjaXR5XCIsMCksKGIub3B0aW9ucy5jZW50ZXJNb2RlPT09ITB8fGIub3B0aW9ucy5zd2lwZVRvU2xpZGU9PT0hMCkmJihiLm9wdGlvbnMuc2xpZGVzVG9TY3JvbGw9MSksYShcImltZ1tkYXRhLWxhenldXCIsYi4kc2xpZGVyKS5ub3QoXCJbc3JjXVwiKS5hZGRDbGFzcyhcInNsaWNrLWxvYWRpbmdcIiksYi5zZXR1cEluZmluaXRlKCksYi5idWlsZEFycm93cygpLGIuYnVpbGREb3RzKCksYi51cGRhdGVEb3RzKCksYi5zZXRTbGlkZUNsYXNzZXMoXCJudW1iZXJcIj09dHlwZW9mIGIuY3VycmVudFNsaWRlP2IuY3VycmVudFNsaWRlOjApLGIub3B0aW9ucy5kcmFnZ2FibGU9PT0hMCYmYi4kbGlzdC5hZGRDbGFzcyhcImRyYWdnYWJsZVwiKX0sYi5wcm90b3R5cGUuYnVpbGRSb3dzPWZ1bmN0aW9uKCl7dmFyIGIsYyxkLGUsZixnLGgsYT10aGlzO2lmKGU9ZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpLGc9YS4kc2xpZGVyLmNoaWxkcmVuKCksYS5vcHRpb25zLnJvd3M+MSl7Zm9yKGg9YS5vcHRpb25zLnNsaWRlc1BlclJvdyphLm9wdGlvbnMucm93cyxmPU1hdGguY2VpbChnLmxlbmd0aC9oKSxiPTA7Zj5iO2IrKyl7dmFyIGk9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtmb3IoYz0wO2M8YS5vcHRpb25zLnJvd3M7YysrKXt2YXIgaj1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO2ZvcihkPTA7ZDxhLm9wdGlvbnMuc2xpZGVzUGVyUm93O2QrKyl7dmFyIGs9YipoKyhjKmEub3B0aW9ucy5zbGlkZXNQZXJSb3crZCk7Zy5nZXQoaykmJmouYXBwZW5kQ2hpbGQoZy5nZXQoaykpfWkuYXBwZW5kQ2hpbGQoail9ZS5hcHBlbmRDaGlsZChpKX1hLiRzbGlkZXIuaHRtbChlKSxhLiRzbGlkZXIuY2hpbGRyZW4oKS5jaGlsZHJlbigpLmNoaWxkcmVuKCkuY3NzKHt3aWR0aDoxMDAvYS5vcHRpb25zLnNsaWRlc1BlclJvdytcIiVcIixkaXNwbGF5OlwiaW5saW5lLWJsb2NrXCJ9KX19LGIucHJvdG90eXBlLmNoZWNrUmVzcG9uc2l2ZT1mdW5jdGlvbihiLGMpe3ZhciBlLGYsZyxkPXRoaXMsaD0hMSxpPWQuJHNsaWRlci53aWR0aCgpLGo9d2luZG93LmlubmVyV2lkdGh8fGEod2luZG93KS53aWR0aCgpO2lmKFwid2luZG93XCI9PT1kLnJlc3BvbmRUbz9nPWo6XCJzbGlkZXJcIj09PWQucmVzcG9uZFRvP2c9aTpcIm1pblwiPT09ZC5yZXNwb25kVG8mJihnPU1hdGgubWluKGosaSkpLGQub3B0aW9ucy5yZXNwb25zaXZlJiZkLm9wdGlvbnMucmVzcG9uc2l2ZS5sZW5ndGgmJm51bGwhPT1kLm9wdGlvbnMucmVzcG9uc2l2ZSl7Zj1udWxsO2ZvcihlIGluIGQuYnJlYWtwb2ludHMpZC5icmVha3BvaW50cy5oYXNPd25Qcm9wZXJ0eShlKSYmKGQub3JpZ2luYWxTZXR0aW5ncy5tb2JpbGVGaXJzdD09PSExP2c8ZC5icmVha3BvaW50c1tlXSYmKGY9ZC5icmVha3BvaW50c1tlXSk6Zz5kLmJyZWFrcG9pbnRzW2VdJiYoZj1kLmJyZWFrcG9pbnRzW2VdKSk7bnVsbCE9PWY/bnVsbCE9PWQuYWN0aXZlQnJlYWtwb2ludD8oZiE9PWQuYWN0aXZlQnJlYWtwb2ludHx8YykmJihkLmFjdGl2ZUJyZWFrcG9pbnQ9ZixcInVuc2xpY2tcIj09PWQuYnJlYWtwb2ludFNldHRpbmdzW2ZdP2QudW5zbGljayhmKTooZC5vcHRpb25zPWEuZXh0ZW5kKHt9LGQub3JpZ2luYWxTZXR0aW5ncyxkLmJyZWFrcG9pbnRTZXR0aW5nc1tmXSksYj09PSEwJiYoZC5jdXJyZW50U2xpZGU9ZC5vcHRpb25zLmluaXRpYWxTbGlkZSksZC5yZWZyZXNoKGIpKSxoPWYpOihkLmFjdGl2ZUJyZWFrcG9pbnQ9ZixcInVuc2xpY2tcIj09PWQuYnJlYWtwb2ludFNldHRpbmdzW2ZdP2QudW5zbGljayhmKTooZC5vcHRpb25zPWEuZXh0ZW5kKHt9LGQub3JpZ2luYWxTZXR0aW5ncyxkLmJyZWFrcG9pbnRTZXR0aW5nc1tmXSksYj09PSEwJiYoZC5jdXJyZW50U2xpZGU9ZC5vcHRpb25zLmluaXRpYWxTbGlkZSksZC5yZWZyZXNoKGIpKSxoPWYpOm51bGwhPT1kLmFjdGl2ZUJyZWFrcG9pbnQmJihkLmFjdGl2ZUJyZWFrcG9pbnQ9bnVsbCxkLm9wdGlvbnM9ZC5vcmlnaW5hbFNldHRpbmdzLGI9PT0hMCYmKGQuY3VycmVudFNsaWRlPWQub3B0aW9ucy5pbml0aWFsU2xpZGUpLGQucmVmcmVzaChiKSxoPWYpLGJ8fGg9PT0hMXx8ZC4kc2xpZGVyLnRyaWdnZXIoXCJicmVha3BvaW50XCIsW2QsaF0pfX0sYi5wcm90b3R5cGUuY2hhbmdlU2xpZGU9ZnVuY3Rpb24oYixjKXt2YXIgZixnLGgsZD10aGlzLGU9YShiLnRhcmdldCk7c3dpdGNoKGUuaXMoXCJhXCIpJiZiLnByZXZlbnREZWZhdWx0KCksZS5pcyhcImxpXCIpfHwoZT1lLmNsb3Nlc3QoXCJsaVwiKSksaD1kLnNsaWRlQ291bnQlZC5vcHRpb25zLnNsaWRlc1RvU2Nyb2xsIT09MCxmPWg/MDooZC5zbGlkZUNvdW50LWQuY3VycmVudFNsaWRlKSVkLm9wdGlvbnMuc2xpZGVzVG9TY3JvbGwsYi5kYXRhLm1lc3NhZ2Upe2Nhc2VcInByZXZpb3VzXCI6Zz0wPT09Zj9kLm9wdGlvbnMuc2xpZGVzVG9TY3JvbGw6ZC5vcHRpb25zLnNsaWRlc1RvU2hvdy1mLGQuc2xpZGVDb3VudD5kLm9wdGlvbnMuc2xpZGVzVG9TaG93JiZkLnNsaWRlSGFuZGxlcihkLmN1cnJlbnRTbGlkZS1nLCExLGMpO2JyZWFrO2Nhc2VcIm5leHRcIjpnPTA9PT1mP2Qub3B0aW9ucy5zbGlkZXNUb1Njcm9sbDpmLGQuc2xpZGVDb3VudD5kLm9wdGlvbnMuc2xpZGVzVG9TaG93JiZkLnNsaWRlSGFuZGxlcihkLmN1cnJlbnRTbGlkZStnLCExLGMpO2JyZWFrO2Nhc2VcImluZGV4XCI6dmFyIGk9MD09PWIuZGF0YS5pbmRleD8wOmIuZGF0YS5pbmRleHx8ZS5pbmRleCgpKmQub3B0aW9ucy5zbGlkZXNUb1Njcm9sbDtkLnNsaWRlSGFuZGxlcihkLmNoZWNrTmF2aWdhYmxlKGkpLCExLGMpLGUuY2hpbGRyZW4oKS50cmlnZ2VyKFwiZm9jdXNcIik7YnJlYWs7ZGVmYXVsdDpyZXR1cm59fSxiLnByb3RvdHlwZS5jaGVja05hdmlnYWJsZT1mdW5jdGlvbihhKXt2YXIgYyxkLGI9dGhpcztpZihjPWIuZ2V0TmF2aWdhYmxlSW5kZXhlcygpLGQ9MCxhPmNbYy5sZW5ndGgtMV0pYT1jW2MubGVuZ3RoLTFdO2Vsc2UgZm9yKHZhciBlIGluIGMpe2lmKGE8Y1tlXSl7YT1kO2JyZWFrfWQ9Y1tlXX1yZXR1cm4gYX0sYi5wcm90b3R5cGUuY2xlYW5VcEV2ZW50cz1mdW5jdGlvbigpe3ZhciBiPXRoaXM7Yi5vcHRpb25zLmRvdHMmJm51bGwhPT1iLiRkb3RzJiYoYShcImxpXCIsYi4kZG90cykub2ZmKFwiY2xpY2suc2xpY2tcIixiLmNoYW5nZVNsaWRlKSxiLm9wdGlvbnMucGF1c2VPbkRvdHNIb3Zlcj09PSEwJiZiLm9wdGlvbnMuYXV0b3BsYXk9PT0hMCYmYShcImxpXCIsYi4kZG90cykub2ZmKFwibW91c2VlbnRlci5zbGlja1wiLGEucHJveHkoYi5zZXRQYXVzZWQsYiwhMCkpLm9mZihcIm1vdXNlbGVhdmUuc2xpY2tcIixhLnByb3h5KGIuc2V0UGF1c2VkLGIsITEpKSksYi5vcHRpb25zLmFycm93cz09PSEwJiZiLnNsaWRlQ291bnQ+Yi5vcHRpb25zLnNsaWRlc1RvU2hvdyYmKGIuJHByZXZBcnJvdyYmYi4kcHJldkFycm93Lm9mZihcImNsaWNrLnNsaWNrXCIsYi5jaGFuZ2VTbGlkZSksYi4kbmV4dEFycm93JiZiLiRuZXh0QXJyb3cub2ZmKFwiY2xpY2suc2xpY2tcIixiLmNoYW5nZVNsaWRlKSksYi4kbGlzdC5vZmYoXCJ0b3VjaHN0YXJ0LnNsaWNrIG1vdXNlZG93bi5zbGlja1wiLGIuc3dpcGVIYW5kbGVyKSxiLiRsaXN0Lm9mZihcInRvdWNobW92ZS5zbGljayBtb3VzZW1vdmUuc2xpY2tcIixiLnN3aXBlSGFuZGxlciksYi4kbGlzdC5vZmYoXCJ0b3VjaGVuZC5zbGljayBtb3VzZXVwLnNsaWNrXCIsYi5zd2lwZUhhbmRsZXIpLGIuJGxpc3Qub2ZmKFwidG91Y2hjYW5jZWwuc2xpY2sgbW91c2VsZWF2ZS5zbGlja1wiLGIuc3dpcGVIYW5kbGVyKSxiLiRsaXN0Lm9mZihcImNsaWNrLnNsaWNrXCIsYi5jbGlja0hhbmRsZXIpLGEoZG9jdW1lbnQpLm9mZihiLnZpc2liaWxpdHlDaGFuZ2UsYi52aXNpYmlsaXR5KSxiLiRsaXN0Lm9mZihcIm1vdXNlZW50ZXIuc2xpY2tcIixhLnByb3h5KGIuc2V0UGF1c2VkLGIsITApKSxiLiRsaXN0Lm9mZihcIm1vdXNlbGVhdmUuc2xpY2tcIixhLnByb3h5KGIuc2V0UGF1c2VkLGIsITEpKSxiLm9wdGlvbnMuYWNjZXNzaWJpbGl0eT09PSEwJiZiLiRsaXN0Lm9mZihcImtleWRvd24uc2xpY2tcIixiLmtleUhhbmRsZXIpLGIub3B0aW9ucy5mb2N1c09uU2VsZWN0PT09ITAmJmEoYi4kc2xpZGVUcmFjaykuY2hpbGRyZW4oKS5vZmYoXCJjbGljay5zbGlja1wiLGIuc2VsZWN0SGFuZGxlciksYSh3aW5kb3cpLm9mZihcIm9yaWVudGF0aW9uY2hhbmdlLnNsaWNrLnNsaWNrLVwiK2IuaW5zdGFuY2VVaWQsYi5vcmllbnRhdGlvbkNoYW5nZSksYSh3aW5kb3cpLm9mZihcInJlc2l6ZS5zbGljay5zbGljay1cIitiLmluc3RhbmNlVWlkLGIucmVzaXplKSxhKFwiW2RyYWdnYWJsZSE9dHJ1ZV1cIixiLiRzbGlkZVRyYWNrKS5vZmYoXCJkcmFnc3RhcnRcIixiLnByZXZlbnREZWZhdWx0KSxhKHdpbmRvdykub2ZmKFwibG9hZC5zbGljay5zbGljay1cIitiLmluc3RhbmNlVWlkLGIuc2V0UG9zaXRpb24pLGEoZG9jdW1lbnQpLm9mZihcInJlYWR5LnNsaWNrLnNsaWNrLVwiK2IuaW5zdGFuY2VVaWQsYi5zZXRQb3NpdGlvbil9LGIucHJvdG90eXBlLmNsZWFuVXBSb3dzPWZ1bmN0aW9uKCl7dmFyIGIsYT10aGlzO2Eub3B0aW9ucy5yb3dzPjEmJihiPWEuJHNsaWRlcy5jaGlsZHJlbigpLmNoaWxkcmVuKCksYi5yZW1vdmVBdHRyKFwic3R5bGVcIiksYS4kc2xpZGVyLmh0bWwoYikpfSxiLnByb3RvdHlwZS5jbGlja0hhbmRsZXI9ZnVuY3Rpb24oYSl7dmFyIGI9dGhpcztiLnNob3VsZENsaWNrPT09ITEmJihhLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpLGEuc3RvcFByb3BhZ2F0aW9uKCksYS5wcmV2ZW50RGVmYXVsdCgpKX0sYi5wcm90b3R5cGUuZGVzdHJveT1mdW5jdGlvbihiKXt2YXIgYz10aGlzO2MuYXV0b1BsYXlDbGVhcigpLGMudG91Y2hPYmplY3Q9e30sYy5jbGVhblVwRXZlbnRzKCksYShcIi5zbGljay1jbG9uZWRcIixjLiRzbGlkZXIpLmRldGFjaCgpLGMuJGRvdHMmJmMuJGRvdHMucmVtb3ZlKCksYy4kcHJldkFycm93JiZjLiRwcmV2QXJyb3cubGVuZ3RoJiYoYy4kcHJldkFycm93LnJlbW92ZUNsYXNzKFwic2xpY2stZGlzYWJsZWQgc2xpY2stYXJyb3cgc2xpY2staGlkZGVuXCIpLnJlbW92ZUF0dHIoXCJhcmlhLWhpZGRlbiBhcmlhLWRpc2FibGVkIHRhYmluZGV4XCIpLmNzcyhcImRpc3BsYXlcIixcIlwiKSxjLmh0bWxFeHByLnRlc3QoYy5vcHRpb25zLnByZXZBcnJvdykmJmMuJHByZXZBcnJvdy5yZW1vdmUoKSksYy4kbmV4dEFycm93JiZjLiRuZXh0QXJyb3cubGVuZ3RoJiYoYy4kbmV4dEFycm93LnJlbW92ZUNsYXNzKFwic2xpY2stZGlzYWJsZWQgc2xpY2stYXJyb3cgc2xpY2staGlkZGVuXCIpLnJlbW92ZUF0dHIoXCJhcmlhLWhpZGRlbiBhcmlhLWRpc2FibGVkIHRhYmluZGV4XCIpLmNzcyhcImRpc3BsYXlcIixcIlwiKSxjLmh0bWxFeHByLnRlc3QoYy5vcHRpb25zLm5leHRBcnJvdykmJmMuJG5leHRBcnJvdy5yZW1vdmUoKSksYy4kc2xpZGVzJiYoYy4kc2xpZGVzLnJlbW92ZUNsYXNzKFwic2xpY2stc2xpZGUgc2xpY2stYWN0aXZlIHNsaWNrLWNlbnRlciBzbGljay12aXNpYmxlIHNsaWNrLWN1cnJlbnRcIikucmVtb3ZlQXR0cihcImFyaWEtaGlkZGVuXCIpLnJlbW92ZUF0dHIoXCJkYXRhLXNsaWNrLWluZGV4XCIpLmVhY2goZnVuY3Rpb24oKXthKHRoaXMpLmF0dHIoXCJzdHlsZVwiLGEodGhpcykuZGF0YShcIm9yaWdpbmFsU3R5bGluZ1wiKSl9KSxjLiRzbGlkZVRyYWNrLmNoaWxkcmVuKHRoaXMub3B0aW9ucy5zbGlkZSkuZGV0YWNoKCksYy4kc2xpZGVUcmFjay5kZXRhY2goKSxjLiRsaXN0LmRldGFjaCgpLGMuJHNsaWRlci5hcHBlbmQoYy4kc2xpZGVzKSksYy5jbGVhblVwUm93cygpLGMuJHNsaWRlci5yZW1vdmVDbGFzcyhcInNsaWNrLXNsaWRlclwiKSxjLiRzbGlkZXIucmVtb3ZlQ2xhc3MoXCJzbGljay1pbml0aWFsaXplZFwiKSxjLnVuc2xpY2tlZD0hMCxifHxjLiRzbGlkZXIudHJpZ2dlcihcImRlc3Ryb3lcIixbY10pfSxiLnByb3RvdHlwZS5kaXNhYmxlVHJhbnNpdGlvbj1mdW5jdGlvbihhKXt2YXIgYj10aGlzLGM9e307Y1tiLnRyYW5zaXRpb25UeXBlXT1cIlwiLGIub3B0aW9ucy5mYWRlPT09ITE/Yi4kc2xpZGVUcmFjay5jc3MoYyk6Yi4kc2xpZGVzLmVxKGEpLmNzcyhjKX0sYi5wcm90b3R5cGUuZmFkZVNsaWRlPWZ1bmN0aW9uKGEsYil7dmFyIGM9dGhpcztjLmNzc1RyYW5zaXRpb25zPT09ITE/KGMuJHNsaWRlcy5lcShhKS5jc3Moe3pJbmRleDpjLm9wdGlvbnMuekluZGV4fSksYy4kc2xpZGVzLmVxKGEpLmFuaW1hdGUoe29wYWNpdHk6MX0sYy5vcHRpb25zLnNwZWVkLGMub3B0aW9ucy5lYXNpbmcsYikpOihjLmFwcGx5VHJhbnNpdGlvbihhKSxjLiRzbGlkZXMuZXEoYSkuY3NzKHtvcGFjaXR5OjEsekluZGV4OmMub3B0aW9ucy56SW5kZXh9KSxiJiZzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7Yy5kaXNhYmxlVHJhbnNpdGlvbihhKSxiLmNhbGwoKX0sYy5vcHRpb25zLnNwZWVkKSl9LGIucHJvdG90eXBlLmZhZGVTbGlkZU91dD1mdW5jdGlvbihhKXt2YXIgYj10aGlzO2IuY3NzVHJhbnNpdGlvbnM9PT0hMT9iLiRzbGlkZXMuZXEoYSkuYW5pbWF0ZSh7b3BhY2l0eTowLHpJbmRleDpiLm9wdGlvbnMuekluZGV4LTJ9LGIub3B0aW9ucy5zcGVlZCxiLm9wdGlvbnMuZWFzaW5nKTooYi5hcHBseVRyYW5zaXRpb24oYSksYi4kc2xpZGVzLmVxKGEpLmNzcyh7b3BhY2l0eTowLHpJbmRleDpiLm9wdGlvbnMuekluZGV4LTJ9KSl9LGIucHJvdG90eXBlLmZpbHRlclNsaWRlcz1iLnByb3RvdHlwZS5zbGlja0ZpbHRlcj1mdW5jdGlvbihhKXt2YXIgYj10aGlzO251bGwhPT1hJiYoYi4kc2xpZGVzQ2FjaGU9Yi4kc2xpZGVzLGIudW5sb2FkKCksYi4kc2xpZGVUcmFjay5jaGlsZHJlbih0aGlzLm9wdGlvbnMuc2xpZGUpLmRldGFjaCgpLGIuJHNsaWRlc0NhY2hlLmZpbHRlcihhKS5hcHBlbmRUbyhiLiRzbGlkZVRyYWNrKSxiLnJlaW5pdCgpKX0sYi5wcm90b3R5cGUuZ2V0Q3VycmVudD1iLnByb3RvdHlwZS5zbGlja0N1cnJlbnRTbGlkZT1mdW5jdGlvbigpe3ZhciBhPXRoaXM7cmV0dXJuIGEuY3VycmVudFNsaWRlfSxiLnByb3RvdHlwZS5nZXREb3RDb3VudD1mdW5jdGlvbigpe3ZhciBhPXRoaXMsYj0wLGM9MCxkPTA7aWYoYS5vcHRpb25zLmluZmluaXRlPT09ITApZm9yKDtiPGEuc2xpZGVDb3VudDspKytkLGI9YythLm9wdGlvbnMuc2xpZGVzVG9TY3JvbGwsYys9YS5vcHRpb25zLnNsaWRlc1RvU2Nyb2xsPD1hLm9wdGlvbnMuc2xpZGVzVG9TaG93P2Eub3B0aW9ucy5zbGlkZXNUb1Njcm9sbDphLm9wdGlvbnMuc2xpZGVzVG9TaG93O2Vsc2UgaWYoYS5vcHRpb25zLmNlbnRlck1vZGU9PT0hMClkPWEuc2xpZGVDb3VudDtlbHNlIGZvcig7YjxhLnNsaWRlQ291bnQ7KSsrZCxiPWMrYS5vcHRpb25zLnNsaWRlc1RvU2Nyb2xsLGMrPWEub3B0aW9ucy5zbGlkZXNUb1Njcm9sbDw9YS5vcHRpb25zLnNsaWRlc1RvU2hvdz9hLm9wdGlvbnMuc2xpZGVzVG9TY3JvbGw6YS5vcHRpb25zLnNsaWRlc1RvU2hvdztyZXR1cm4gZC0xfSxiLnByb3RvdHlwZS5nZXRMZWZ0PWZ1bmN0aW9uKGEpe3ZhciBjLGQsZixiPXRoaXMsZT0wO3JldHVybiBiLnNsaWRlT2Zmc2V0PTAsZD1iLiRzbGlkZXMuZmlyc3QoKS5vdXRlckhlaWdodCghMCksYi5vcHRpb25zLmluZmluaXRlPT09ITA/KGIuc2xpZGVDb3VudD5iLm9wdGlvbnMuc2xpZGVzVG9TaG93JiYoYi5zbGlkZU9mZnNldD1iLnNsaWRlV2lkdGgqYi5vcHRpb25zLnNsaWRlc1RvU2hvdyotMSxlPWQqYi5vcHRpb25zLnNsaWRlc1RvU2hvdyotMSksYi5zbGlkZUNvdW50JWIub3B0aW9ucy5zbGlkZXNUb1Njcm9sbCE9PTAmJmErYi5vcHRpb25zLnNsaWRlc1RvU2Nyb2xsPmIuc2xpZGVDb3VudCYmYi5zbGlkZUNvdW50PmIub3B0aW9ucy5zbGlkZXNUb1Nob3cmJihhPmIuc2xpZGVDb3VudD8oYi5zbGlkZU9mZnNldD0oYi5vcHRpb25zLnNsaWRlc1RvU2hvdy0oYS1iLnNsaWRlQ291bnQpKSpiLnNsaWRlV2lkdGgqLTEsZT0oYi5vcHRpb25zLnNsaWRlc1RvU2hvdy0oYS1iLnNsaWRlQ291bnQpKSpkKi0xKTooYi5zbGlkZU9mZnNldD1iLnNsaWRlQ291bnQlYi5vcHRpb25zLnNsaWRlc1RvU2Nyb2xsKmIuc2xpZGVXaWR0aCotMSxlPWIuc2xpZGVDb3VudCViLm9wdGlvbnMuc2xpZGVzVG9TY3JvbGwqZCotMSkpKTphK2Iub3B0aW9ucy5zbGlkZXNUb1Nob3c+Yi5zbGlkZUNvdW50JiYoYi5zbGlkZU9mZnNldD0oYStiLm9wdGlvbnMuc2xpZGVzVG9TaG93LWIuc2xpZGVDb3VudCkqYi5zbGlkZVdpZHRoLGU9KGErYi5vcHRpb25zLnNsaWRlc1RvU2hvdy1iLnNsaWRlQ291bnQpKmQpLGIuc2xpZGVDb3VudDw9Yi5vcHRpb25zLnNsaWRlc1RvU2hvdyYmKGIuc2xpZGVPZmZzZXQ9MCxlPTApLGIub3B0aW9ucy5jZW50ZXJNb2RlPT09ITAmJmIub3B0aW9ucy5pbmZpbml0ZT09PSEwP2Iuc2xpZGVPZmZzZXQrPWIuc2xpZGVXaWR0aCpNYXRoLmZsb29yKGIub3B0aW9ucy5zbGlkZXNUb1Nob3cvMiktYi5zbGlkZVdpZHRoOmIub3B0aW9ucy5jZW50ZXJNb2RlPT09ITAmJihiLnNsaWRlT2Zmc2V0PTAsYi5zbGlkZU9mZnNldCs9Yi5zbGlkZVdpZHRoKk1hdGguZmxvb3IoYi5vcHRpb25zLnNsaWRlc1RvU2hvdy8yKSksYz1iLm9wdGlvbnMudmVydGljYWw9PT0hMT9hKmIuc2xpZGVXaWR0aCotMStiLnNsaWRlT2Zmc2V0OmEqZCotMStlLGIub3B0aW9ucy52YXJpYWJsZVdpZHRoPT09ITAmJihmPWIuc2xpZGVDb3VudDw9Yi5vcHRpb25zLnNsaWRlc1RvU2hvd3x8Yi5vcHRpb25zLmluZmluaXRlPT09ITE/Yi4kc2xpZGVUcmFjay5jaGlsZHJlbihcIi5zbGljay1zbGlkZVwiKS5lcShhKTpiLiRzbGlkZVRyYWNrLmNoaWxkcmVuKFwiLnNsaWNrLXNsaWRlXCIpLmVxKGErYi5vcHRpb25zLnNsaWRlc1RvU2hvdyksYz1iLm9wdGlvbnMucnRsPT09ITA/ZlswXT8tMSooYi4kc2xpZGVUcmFjay53aWR0aCgpLWZbMF0ub2Zmc2V0TGVmdC1mLndpZHRoKCkpOjA6ZlswXT8tMSpmWzBdLm9mZnNldExlZnQ6MCxiLm9wdGlvbnMuY2VudGVyTW9kZT09PSEwJiYoZj1iLnNsaWRlQ291bnQ8PWIub3B0aW9ucy5zbGlkZXNUb1Nob3d8fGIub3B0aW9ucy5pbmZpbml0ZT09PSExP2IuJHNsaWRlVHJhY2suY2hpbGRyZW4oXCIuc2xpY2stc2xpZGVcIikuZXEoYSk6Yi4kc2xpZGVUcmFjay5jaGlsZHJlbihcIi5zbGljay1zbGlkZVwiKS5lcShhK2Iub3B0aW9ucy5zbGlkZXNUb1Nob3crMSksYz1iLm9wdGlvbnMucnRsPT09ITA/ZlswXT8tMSooYi4kc2xpZGVUcmFjay53aWR0aCgpLWZbMF0ub2Zmc2V0TGVmdC1mLndpZHRoKCkpOjA6ZlswXT8tMSpmWzBdLm9mZnNldExlZnQ6MCxjKz0oYi4kbGlzdC53aWR0aCgpLWYub3V0ZXJXaWR0aCgpKS8yKSksY30sYi5wcm90b3R5cGUuZ2V0T3B0aW9uPWIucHJvdG90eXBlLnNsaWNrR2V0T3B0aW9uPWZ1bmN0aW9uKGEpe3ZhciBiPXRoaXM7cmV0dXJuIGIub3B0aW9uc1thXX0sYi5wcm90b3R5cGUuZ2V0TmF2aWdhYmxlSW5kZXhlcz1mdW5jdGlvbigpe3ZhciBlLGE9dGhpcyxiPTAsYz0wLGQ9W107Zm9yKGEub3B0aW9ucy5pbmZpbml0ZT09PSExP2U9YS5zbGlkZUNvdW50OihiPS0xKmEub3B0aW9ucy5zbGlkZXNUb1Njcm9sbCxjPS0xKmEub3B0aW9ucy5zbGlkZXNUb1Njcm9sbCxlPTIqYS5zbGlkZUNvdW50KTtlPmI7KWQucHVzaChiKSxiPWMrYS5vcHRpb25zLnNsaWRlc1RvU2Nyb2xsLGMrPWEub3B0aW9ucy5zbGlkZXNUb1Njcm9sbDw9YS5vcHRpb25zLnNsaWRlc1RvU2hvdz9hLm9wdGlvbnMuc2xpZGVzVG9TY3JvbGw6YS5vcHRpb25zLnNsaWRlc1RvU2hvdztyZXR1cm4gZH0sYi5wcm90b3R5cGUuZ2V0U2xpY2s9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpc30sYi5wcm90b3R5cGUuZ2V0U2xpZGVDb3VudD1mdW5jdGlvbigpe3ZhciBjLGQsZSxiPXRoaXM7cmV0dXJuIGU9Yi5vcHRpb25zLmNlbnRlck1vZGU9PT0hMD9iLnNsaWRlV2lkdGgqTWF0aC5mbG9vcihiLm9wdGlvbnMuc2xpZGVzVG9TaG93LzIpOjAsYi5vcHRpb25zLnN3aXBlVG9TbGlkZT09PSEwPyhiLiRzbGlkZVRyYWNrLmZpbmQoXCIuc2xpY2stc2xpZGVcIikuZWFjaChmdW5jdGlvbihjLGYpe3JldHVybiBmLm9mZnNldExlZnQtZSthKGYpLm91dGVyV2lkdGgoKS8yPi0xKmIuc3dpcGVMZWZ0PyhkPWYsITEpOnZvaWQgMH0pLGM9TWF0aC5hYnMoYShkKS5hdHRyKFwiZGF0YS1zbGljay1pbmRleFwiKS1iLmN1cnJlbnRTbGlkZSl8fDEpOmIub3B0aW9ucy5zbGlkZXNUb1Njcm9sbH0sYi5wcm90b3R5cGUuZ29Ubz1iLnByb3RvdHlwZS5zbGlja0dvVG89ZnVuY3Rpb24oYSxiKXt2YXIgYz10aGlzO2MuY2hhbmdlU2xpZGUoe2RhdGE6e21lc3NhZ2U6XCJpbmRleFwiLGluZGV4OnBhcnNlSW50KGEpfX0sYil9LGIucHJvdG90eXBlLmluaXQ9ZnVuY3Rpb24oYil7dmFyIGM9dGhpczthKGMuJHNsaWRlcikuaGFzQ2xhc3MoXCJzbGljay1pbml0aWFsaXplZFwiKXx8KGEoYy4kc2xpZGVyKS5hZGRDbGFzcyhcInNsaWNrLWluaXRpYWxpemVkXCIpLGMuYnVpbGRSb3dzKCksYy5idWlsZE91dCgpLGMuc2V0UHJvcHMoKSxjLnN0YXJ0TG9hZCgpLGMubG9hZFNsaWRlcigpLGMuaW5pdGlhbGl6ZUV2ZW50cygpLGMudXBkYXRlQXJyb3dzKCksYy51cGRhdGVEb3RzKCkpLGImJmMuJHNsaWRlci50cmlnZ2VyKFwiaW5pdFwiLFtjXSksYy5vcHRpb25zLmFjY2Vzc2liaWxpdHk9PT0hMCYmYy5pbml0QURBKCl9LGIucHJvdG90eXBlLmluaXRBcnJvd0V2ZW50cz1mdW5jdGlvbigpe3ZhciBhPXRoaXM7YS5vcHRpb25zLmFycm93cz09PSEwJiZhLnNsaWRlQ291bnQ+YS5vcHRpb25zLnNsaWRlc1RvU2hvdyYmKGEuJHByZXZBcnJvdy5vbihcImNsaWNrLnNsaWNrXCIse21lc3NhZ2U6XCJwcmV2aW91c1wifSxhLmNoYW5nZVNsaWRlKSxhLiRuZXh0QXJyb3cub24oXCJjbGljay5zbGlja1wiLHttZXNzYWdlOlwibmV4dFwifSxhLmNoYW5nZVNsaWRlKSl9LGIucHJvdG90eXBlLmluaXREb3RFdmVudHM9ZnVuY3Rpb24oKXt2YXIgYj10aGlzO2Iub3B0aW9ucy5kb3RzPT09ITAmJmIuc2xpZGVDb3VudD5iLm9wdGlvbnMuc2xpZGVzVG9TaG93JiZhKFwibGlcIixiLiRkb3RzKS5vbihcImNsaWNrLnNsaWNrXCIse21lc3NhZ2U6XCJpbmRleFwifSxiLmNoYW5nZVNsaWRlKSxiLm9wdGlvbnMuZG90cz09PSEwJiZiLm9wdGlvbnMucGF1c2VPbkRvdHNIb3Zlcj09PSEwJiZiLm9wdGlvbnMuYXV0b3BsYXk9PT0hMCYmYShcImxpXCIsYi4kZG90cykub24oXCJtb3VzZWVudGVyLnNsaWNrXCIsYS5wcm94eShiLnNldFBhdXNlZCxiLCEwKSkub24oXCJtb3VzZWxlYXZlLnNsaWNrXCIsYS5wcm94eShiLnNldFBhdXNlZCxiLCExKSl9LGIucHJvdG90eXBlLmluaXRpYWxpemVFdmVudHM9ZnVuY3Rpb24oKXt2YXIgYj10aGlzO2IuaW5pdEFycm93RXZlbnRzKCksYi5pbml0RG90RXZlbnRzKCksYi4kbGlzdC5vbihcInRvdWNoc3RhcnQuc2xpY2sgbW91c2Vkb3duLnNsaWNrXCIse2FjdGlvbjpcInN0YXJ0XCJ9LGIuc3dpcGVIYW5kbGVyKSxiLiRsaXN0Lm9uKFwidG91Y2htb3ZlLnNsaWNrIG1vdXNlbW92ZS5zbGlja1wiLHthY3Rpb246XCJtb3ZlXCJ9LGIuc3dpcGVIYW5kbGVyKSxiLiRsaXN0Lm9uKFwidG91Y2hlbmQuc2xpY2sgbW91c2V1cC5zbGlja1wiLHthY3Rpb246XCJlbmRcIn0sYi5zd2lwZUhhbmRsZXIpLGIuJGxpc3Qub24oXCJ0b3VjaGNhbmNlbC5zbGljayBtb3VzZWxlYXZlLnNsaWNrXCIse2FjdGlvbjpcImVuZFwifSxiLnN3aXBlSGFuZGxlciksYi4kbGlzdC5vbihcImNsaWNrLnNsaWNrXCIsYi5jbGlja0hhbmRsZXIpLGEoZG9jdW1lbnQpLm9uKGIudmlzaWJpbGl0eUNoYW5nZSxhLnByb3h5KGIudmlzaWJpbGl0eSxiKSksYi4kbGlzdC5vbihcIm1vdXNlZW50ZXIuc2xpY2tcIixhLnByb3h5KGIuc2V0UGF1c2VkLGIsITApKSxiLiRsaXN0Lm9uKFwibW91c2VsZWF2ZS5zbGlja1wiLGEucHJveHkoYi5zZXRQYXVzZWQsYiwhMSkpLGIub3B0aW9ucy5hY2Nlc3NpYmlsaXR5PT09ITAmJmIuJGxpc3Qub24oXCJrZXlkb3duLnNsaWNrXCIsYi5rZXlIYW5kbGVyKSxiLm9wdGlvbnMuZm9jdXNPblNlbGVjdD09PSEwJiZhKGIuJHNsaWRlVHJhY2spLmNoaWxkcmVuKCkub24oXCJjbGljay5zbGlja1wiLGIuc2VsZWN0SGFuZGxlciksYSh3aW5kb3cpLm9uKFwib3JpZW50YXRpb25jaGFuZ2Uuc2xpY2suc2xpY2stXCIrYi5pbnN0YW5jZVVpZCxhLnByb3h5KGIub3JpZW50YXRpb25DaGFuZ2UsYikpLGEod2luZG93KS5vbihcInJlc2l6ZS5zbGljay5zbGljay1cIitiLmluc3RhbmNlVWlkLGEucHJveHkoYi5yZXNpemUsYikpLGEoXCJbZHJhZ2dhYmxlIT10cnVlXVwiLGIuJHNsaWRlVHJhY2spLm9uKFwiZHJhZ3N0YXJ0XCIsYi5wcmV2ZW50RGVmYXVsdCksYSh3aW5kb3cpLm9uKFwibG9hZC5zbGljay5zbGljay1cIitiLmluc3RhbmNlVWlkLGIuc2V0UG9zaXRpb24pLGEoZG9jdW1lbnQpLm9uKFwicmVhZHkuc2xpY2suc2xpY2stXCIrYi5pbnN0YW5jZVVpZCxiLnNldFBvc2l0aW9uKX0sYi5wcm90b3R5cGUuaW5pdFVJPWZ1bmN0aW9uKCl7dmFyIGE9dGhpczthLm9wdGlvbnMuYXJyb3dzPT09ITAmJmEuc2xpZGVDb3VudD5hLm9wdGlvbnMuc2xpZGVzVG9TaG93JiYoYS4kcHJldkFycm93LnNob3coKSxhLiRuZXh0QXJyb3cuc2hvdygpKSxhLm9wdGlvbnMuZG90cz09PSEwJiZhLnNsaWRlQ291bnQ+YS5vcHRpb25zLnNsaWRlc1RvU2hvdyYmYS4kZG90cy5zaG93KCksYS5vcHRpb25zLmF1dG9wbGF5PT09ITAmJmEuYXV0b1BsYXkoKX0sYi5wcm90b3R5cGUua2V5SGFuZGxlcj1mdW5jdGlvbihhKXt2YXIgYj10aGlzO2EudGFyZ2V0LnRhZ05hbWUubWF0Y2goXCJURVhUQVJFQXxJTlBVVHxTRUxFQ1RcIil8fCgzNz09PWEua2V5Q29kZSYmYi5vcHRpb25zLmFjY2Vzc2liaWxpdHk9PT0hMD9iLmNoYW5nZVNsaWRlKHtkYXRhOnttZXNzYWdlOlwicHJldmlvdXNcIn19KTozOT09PWEua2V5Q29kZSYmYi5vcHRpb25zLmFjY2Vzc2liaWxpdHk9PT0hMCYmYi5jaGFuZ2VTbGlkZSh7ZGF0YTp7bWVzc2FnZTpcIm5leHRcIn19KSl9LGIucHJvdG90eXBlLmxhenlMb2FkPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gZyhiKXthKFwiaW1nW2RhdGEtbGF6eV1cIixiKS5lYWNoKGZ1bmN0aW9uKCl7dmFyIGI9YSh0aGlzKSxjPWEodGhpcykuYXR0cihcImRhdGEtbGF6eVwiKSxkPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpbWdcIik7ZC5vbmxvYWQ9ZnVuY3Rpb24oKXtiLmFuaW1hdGUoe29wYWNpdHk6MH0sMTAwLGZ1bmN0aW9uKCl7Yi5hdHRyKFwic3JjXCIsYykuYW5pbWF0ZSh7b3BhY2l0eToxfSwyMDAsZnVuY3Rpb24oKXtiLnJlbW92ZUF0dHIoXCJkYXRhLWxhenlcIikucmVtb3ZlQ2xhc3MoXCJzbGljay1sb2FkaW5nXCIpfSl9KX0sZC5zcmM9Y30pfXZhciBjLGQsZSxmLGI9dGhpcztiLm9wdGlvbnMuY2VudGVyTW9kZT09PSEwP2Iub3B0aW9ucy5pbmZpbml0ZT09PSEwPyhlPWIuY3VycmVudFNsaWRlKyhiLm9wdGlvbnMuc2xpZGVzVG9TaG93LzIrMSksZj1lK2Iub3B0aW9ucy5zbGlkZXNUb1Nob3crMik6KGU9TWF0aC5tYXgoMCxiLmN1cnJlbnRTbGlkZS0oYi5vcHRpb25zLnNsaWRlc1RvU2hvdy8yKzEpKSxmPTIrKGIub3B0aW9ucy5zbGlkZXNUb1Nob3cvMisxKStiLmN1cnJlbnRTbGlkZSk6KGU9Yi5vcHRpb25zLmluZmluaXRlP2Iub3B0aW9ucy5zbGlkZXNUb1Nob3crYi5jdXJyZW50U2xpZGU6Yi5jdXJyZW50U2xpZGUsZj1lK2Iub3B0aW9ucy5zbGlkZXNUb1Nob3csYi5vcHRpb25zLmZhZGU9PT0hMCYmKGU+MCYmZS0tLGY8PWIuc2xpZGVDb3VudCYmZisrKSksYz1iLiRzbGlkZXIuZmluZChcIi5zbGljay1zbGlkZVwiKS5zbGljZShlLGYpLGcoYyksYi5zbGlkZUNvdW50PD1iLm9wdGlvbnMuc2xpZGVzVG9TaG93PyhkPWIuJHNsaWRlci5maW5kKFwiLnNsaWNrLXNsaWRlXCIpLGcoZCkpOmIuY3VycmVudFNsaWRlPj1iLnNsaWRlQ291bnQtYi5vcHRpb25zLnNsaWRlc1RvU2hvdz8oZD1iLiRzbGlkZXIuZmluZChcIi5zbGljay1jbG9uZWRcIikuc2xpY2UoMCxiLm9wdGlvbnMuc2xpZGVzVG9TaG93KSxnKGQpKTowPT09Yi5jdXJyZW50U2xpZGUmJihkPWIuJHNsaWRlci5maW5kKFwiLnNsaWNrLWNsb25lZFwiKS5zbGljZSgtMSpiLm9wdGlvbnMuc2xpZGVzVG9TaG93KSxnKGQpKX0sYi5wcm90b3R5cGUubG9hZFNsaWRlcj1mdW5jdGlvbigpe3ZhciBhPXRoaXM7YS5zZXRQb3NpdGlvbigpLGEuJHNsaWRlVHJhY2suY3NzKHtvcGFjaXR5OjF9KSxhLiRzbGlkZXIucmVtb3ZlQ2xhc3MoXCJzbGljay1sb2FkaW5nXCIpLGEuaW5pdFVJKCksXCJwcm9ncmVzc2l2ZVwiPT09YS5vcHRpb25zLmxhenlMb2FkJiZhLnByb2dyZXNzaXZlTGF6eUxvYWQoKX0sYi5wcm90b3R5cGUubmV4dD1iLnByb3RvdHlwZS5zbGlja05leHQ9ZnVuY3Rpb24oKXt2YXIgYT10aGlzO2EuY2hhbmdlU2xpZGUoe2RhdGE6e21lc3NhZ2U6XCJuZXh0XCJ9fSl9LGIucHJvdG90eXBlLm9yaWVudGF0aW9uQ2hhbmdlPWZ1bmN0aW9uKCl7dmFyIGE9dGhpczthLmNoZWNrUmVzcG9uc2l2ZSgpLGEuc2V0UG9zaXRpb24oKX0sYi5wcm90b3R5cGUucGF1c2U9Yi5wcm90b3R5cGUuc2xpY2tQYXVzZT1mdW5jdGlvbigpe3ZhciBhPXRoaXM7YS5hdXRvUGxheUNsZWFyKCksYS5wYXVzZWQ9ITB9LGIucHJvdG90eXBlLnBsYXk9Yi5wcm90b3R5cGUuc2xpY2tQbGF5PWZ1bmN0aW9uKCl7dmFyIGE9dGhpczthLnBhdXNlZD0hMSxhLmF1dG9QbGF5KCl9LGIucHJvdG90eXBlLnBvc3RTbGlkZT1mdW5jdGlvbihhKXt2YXIgYj10aGlzO2IuJHNsaWRlci50cmlnZ2VyKFwiYWZ0ZXJDaGFuZ2VcIixbYixhXSksYi5hbmltYXRpbmc9ITEsYi5zZXRQb3NpdGlvbigpLGIuc3dpcGVMZWZ0PW51bGwsYi5vcHRpb25zLmF1dG9wbGF5PT09ITAmJmIucGF1c2VkPT09ITEmJmIuYXV0b1BsYXkoKSxiLm9wdGlvbnMuYWNjZXNzaWJpbGl0eT09PSEwJiZiLmluaXRBREEoKX0sYi5wcm90b3R5cGUucHJldj1iLnByb3RvdHlwZS5zbGlja1ByZXY9ZnVuY3Rpb24oKXt2YXIgYT10aGlzO2EuY2hhbmdlU2xpZGUoe2RhdGE6e21lc3NhZ2U6XCJwcmV2aW91c1wifX0pfSxiLnByb3RvdHlwZS5wcmV2ZW50RGVmYXVsdD1mdW5jdGlvbihhKXthLnByZXZlbnREZWZhdWx0KCl9LGIucHJvdG90eXBlLnByb2dyZXNzaXZlTGF6eUxvYWQ9ZnVuY3Rpb24oKXt2YXIgYyxkLGI9dGhpcztjPWEoXCJpbWdbZGF0YS1sYXp5XVwiLGIuJHNsaWRlcikubGVuZ3RoLGM+MCYmKGQ9YShcImltZ1tkYXRhLWxhenldXCIsYi4kc2xpZGVyKS5maXJzdCgpLGQuYXR0cihcInNyY1wiLG51bGwpLGQuYXR0cihcInNyY1wiLGQuYXR0cihcImRhdGEtbGF6eVwiKSkucmVtb3ZlQ2xhc3MoXCJzbGljay1sb2FkaW5nXCIpLmxvYWQoZnVuY3Rpb24oKXtkLnJlbW92ZUF0dHIoXCJkYXRhLWxhenlcIiksYi5wcm9ncmVzc2l2ZUxhenlMb2FkKCksYi5vcHRpb25zLmFkYXB0aXZlSGVpZ2h0PT09ITAmJmIuc2V0UG9zaXRpb24oKX0pLmVycm9yKGZ1bmN0aW9uKCl7ZC5yZW1vdmVBdHRyKFwiZGF0YS1sYXp5XCIpLGIucHJvZ3Jlc3NpdmVMYXp5TG9hZCgpfSkpfSxiLnByb3RvdHlwZS5yZWZyZXNoPWZ1bmN0aW9uKGIpe3ZhciBkLGUsYz10aGlzO2U9Yy5zbGlkZUNvdW50LWMub3B0aW9ucy5zbGlkZXNUb1Nob3csYy5vcHRpb25zLmluZmluaXRlfHwoYy5zbGlkZUNvdW50PD1jLm9wdGlvbnMuc2xpZGVzVG9TaG93P2MuY3VycmVudFNsaWRlPTA6Yy5jdXJyZW50U2xpZGU+ZSYmKGMuY3VycmVudFNsaWRlPWUpKSxkPWMuY3VycmVudFNsaWRlLGMuZGVzdHJveSghMCksYS5leHRlbmQoYyxjLmluaXRpYWxzLHtjdXJyZW50U2xpZGU6ZH0pLGMuaW5pdCgpLGJ8fGMuY2hhbmdlU2xpZGUoe2RhdGE6e21lc3NhZ2U6XCJpbmRleFwiLGluZGV4OmR9fSwhMSl9LGIucHJvdG90eXBlLnJlZ2lzdGVyQnJlYWtwb2ludHM9ZnVuY3Rpb24oKXt2YXIgYyxkLGUsYj10aGlzLGY9Yi5vcHRpb25zLnJlc3BvbnNpdmV8fG51bGw7aWYoXCJhcnJheVwiPT09YS50eXBlKGYpJiZmLmxlbmd0aCl7Yi5yZXNwb25kVG89Yi5vcHRpb25zLnJlc3BvbmRUb3x8XCJ3aW5kb3dcIjtmb3IoYyBpbiBmKWlmKGU9Yi5icmVha3BvaW50cy5sZW5ndGgtMSxkPWZbY10uYnJlYWtwb2ludCxmLmhhc093blByb3BlcnR5KGMpKXtmb3IoO2U+PTA7KWIuYnJlYWtwb2ludHNbZV0mJmIuYnJlYWtwb2ludHNbZV09PT1kJiZiLmJyZWFrcG9pbnRzLnNwbGljZShlLDEpLGUtLTtiLmJyZWFrcG9pbnRzLnB1c2goZCksYi5icmVha3BvaW50U2V0dGluZ3NbZF09ZltjXS5zZXR0aW5nc31iLmJyZWFrcG9pbnRzLnNvcnQoZnVuY3Rpb24oYSxjKXtyZXR1cm4gYi5vcHRpb25zLm1vYmlsZUZpcnN0P2EtYzpjLWF9KX19LGIucHJvdG90eXBlLnJlaW5pdD1mdW5jdGlvbigpe3ZhciBiPXRoaXM7Yi4kc2xpZGVzPWIuJHNsaWRlVHJhY2suY2hpbGRyZW4oYi5vcHRpb25zLnNsaWRlKS5hZGRDbGFzcyhcInNsaWNrLXNsaWRlXCIpLGIuc2xpZGVDb3VudD1iLiRzbGlkZXMubGVuZ3RoLGIuY3VycmVudFNsaWRlPj1iLnNsaWRlQ291bnQmJjAhPT1iLmN1cnJlbnRTbGlkZSYmKGIuY3VycmVudFNsaWRlPWIuY3VycmVudFNsaWRlLWIub3B0aW9ucy5zbGlkZXNUb1Njcm9sbCksYi5zbGlkZUNvdW50PD1iLm9wdGlvbnMuc2xpZGVzVG9TaG93JiYoYi5jdXJyZW50U2xpZGU9MCksYi5yZWdpc3RlckJyZWFrcG9pbnRzKCksYi5zZXRQcm9wcygpLGIuc2V0dXBJbmZpbml0ZSgpLGIuYnVpbGRBcnJvd3MoKSxiLnVwZGF0ZUFycm93cygpLGIuaW5pdEFycm93RXZlbnRzKCksYi5idWlsZERvdHMoKSxiLnVwZGF0ZURvdHMoKSxiLmluaXREb3RFdmVudHMoKSxiLmNoZWNrUmVzcG9uc2l2ZSghMSwhMCksYi5vcHRpb25zLmZvY3VzT25TZWxlY3Q9PT0hMCYmYShiLiRzbGlkZVRyYWNrKS5jaGlsZHJlbigpLm9uKFwiY2xpY2suc2xpY2tcIixiLnNlbGVjdEhhbmRsZXIpLGIuc2V0U2xpZGVDbGFzc2VzKDApLGIuc2V0UG9zaXRpb24oKSxiLiRzbGlkZXIudHJpZ2dlcihcInJlSW5pdFwiLFtiXSksYi5vcHRpb25zLmF1dG9wbGF5PT09ITAmJmIuZm9jdXNIYW5kbGVyKCl9LGIucHJvdG90eXBlLnJlc2l6ZT1mdW5jdGlvbigpe3ZhciBiPXRoaXM7YSh3aW5kb3cpLndpZHRoKCkhPT1iLndpbmRvd1dpZHRoJiYoY2xlYXJUaW1lb3V0KGIud2luZG93RGVsYXkpLGIud2luZG93RGVsYXk9d2luZG93LnNldFRpbWVvdXQoZnVuY3Rpb24oKXtiLndpbmRvd1dpZHRoPWEod2luZG93KS53aWR0aCgpLGIuY2hlY2tSZXNwb25zaXZlKCksYi51bnNsaWNrZWR8fGIuc2V0UG9zaXRpb24oKX0sNTApKX0sYi5wcm90b3R5cGUucmVtb3ZlU2xpZGU9Yi5wcm90b3R5cGUuc2xpY2tSZW1vdmU9ZnVuY3Rpb24oYSxiLGMpe3ZhciBkPXRoaXM7cmV0dXJuXCJib29sZWFuXCI9PXR5cGVvZiBhPyhiPWEsYT1iPT09ITA/MDpkLnNsaWRlQ291bnQtMSk6YT1iPT09ITA/LS1hOmEsZC5zbGlkZUNvdW50PDF8fDA+YXx8YT5kLnNsaWRlQ291bnQtMT8hMTooZC51bmxvYWQoKSxjPT09ITA/ZC4kc2xpZGVUcmFjay5jaGlsZHJlbigpLnJlbW92ZSgpOmQuJHNsaWRlVHJhY2suY2hpbGRyZW4odGhpcy5vcHRpb25zLnNsaWRlKS5lcShhKS5yZW1vdmUoKSxkLiRzbGlkZXM9ZC4kc2xpZGVUcmFjay5jaGlsZHJlbih0aGlzLm9wdGlvbnMuc2xpZGUpLGQuJHNsaWRlVHJhY2suY2hpbGRyZW4odGhpcy5vcHRpb25zLnNsaWRlKS5kZXRhY2goKSxkLiRzbGlkZVRyYWNrLmFwcGVuZChkLiRzbGlkZXMpLGQuJHNsaWRlc0NhY2hlPWQuJHNsaWRlcyx2b2lkIGQucmVpbml0KCkpfSxiLnByb3RvdHlwZS5zZXRDU1M9ZnVuY3Rpb24oYSl7dmFyIGQsZSxiPXRoaXMsYz17fTtiLm9wdGlvbnMucnRsPT09ITAmJihhPS1hKSxkPVwibGVmdFwiPT1iLnBvc2l0aW9uUHJvcD9NYXRoLmNlaWwoYSkrXCJweFwiOlwiMHB4XCIsZT1cInRvcFwiPT1iLnBvc2l0aW9uUHJvcD9NYXRoLmNlaWwoYSkrXCJweFwiOlwiMHB4XCIsY1tiLnBvc2l0aW9uUHJvcF09YSxiLnRyYW5zZm9ybXNFbmFibGVkPT09ITE/Yi4kc2xpZGVUcmFjay5jc3MoYyk6KGM9e30sYi5jc3NUcmFuc2l0aW9ucz09PSExPyhjW2IuYW5pbVR5cGVdPVwidHJhbnNsYXRlKFwiK2QrXCIsIFwiK2UrXCIpXCIsYi4kc2xpZGVUcmFjay5jc3MoYykpOihjW2IuYW5pbVR5cGVdPVwidHJhbnNsYXRlM2QoXCIrZCtcIiwgXCIrZStcIiwgMHB4KVwiLGIuJHNsaWRlVHJhY2suY3NzKGMpKSl9LGIucHJvdG90eXBlLnNldERpbWVuc2lvbnM9ZnVuY3Rpb24oKXt2YXIgYT10aGlzO2Eub3B0aW9ucy52ZXJ0aWNhbD09PSExP2Eub3B0aW9ucy5jZW50ZXJNb2RlPT09ITAmJmEuJGxpc3QuY3NzKHtwYWRkaW5nOlwiMHB4IFwiK2Eub3B0aW9ucy5jZW50ZXJQYWRkaW5nfSk6KGEuJGxpc3QuaGVpZ2h0KGEuJHNsaWRlcy5maXJzdCgpLm91dGVySGVpZ2h0KCEwKSphLm9wdGlvbnMuc2xpZGVzVG9TaG93KSxhLm9wdGlvbnMuY2VudGVyTW9kZT09PSEwJiZhLiRsaXN0LmNzcyh7cGFkZGluZzphLm9wdGlvbnMuY2VudGVyUGFkZGluZytcIiAwcHhcIn0pKSxhLmxpc3RXaWR0aD1hLiRsaXN0LndpZHRoKCksYS5saXN0SGVpZ2h0PWEuJGxpc3QuaGVpZ2h0KCksYS5vcHRpb25zLnZlcnRpY2FsPT09ITEmJmEub3B0aW9ucy52YXJpYWJsZVdpZHRoPT09ITE/KGEuc2xpZGVXaWR0aD1NYXRoLmNlaWwoYS5saXN0V2lkdGgvYS5vcHRpb25zLnNsaWRlc1RvU2hvdyksYS4kc2xpZGVUcmFjay53aWR0aChNYXRoLmNlaWwoYS5zbGlkZVdpZHRoKmEuJHNsaWRlVHJhY2suY2hpbGRyZW4oXCIuc2xpY2stc2xpZGVcIikubGVuZ3RoKSkpOmEub3B0aW9ucy52YXJpYWJsZVdpZHRoPT09ITA/YS4kc2xpZGVUcmFjay53aWR0aCg1ZTMqYS5zbGlkZUNvdW50KTooYS5zbGlkZVdpZHRoPU1hdGguY2VpbChhLmxpc3RXaWR0aCksYS4kc2xpZGVUcmFjay5oZWlnaHQoTWF0aC5jZWlsKGEuJHNsaWRlcy5maXJzdCgpLm91dGVySGVpZ2h0KCEwKSphLiRzbGlkZVRyYWNrLmNoaWxkcmVuKFwiLnNsaWNrLXNsaWRlXCIpLmxlbmd0aCkpKTt2YXIgYj1hLiRzbGlkZXMuZmlyc3QoKS5vdXRlcldpZHRoKCEwKS1hLiRzbGlkZXMuZmlyc3QoKS53aWR0aCgpO2Eub3B0aW9ucy52YXJpYWJsZVdpZHRoPT09ITEmJmEuJHNsaWRlVHJhY2suY2hpbGRyZW4oXCIuc2xpY2stc2xpZGVcIikud2lkdGgoYS5zbGlkZVdpZHRoLWIpfSxiLnByb3RvdHlwZS5zZXRGYWRlPWZ1bmN0aW9uKCl7dmFyIGMsYj10aGlzO2IuJHNsaWRlcy5lYWNoKGZ1bmN0aW9uKGQsZSl7Yz1iLnNsaWRlV2lkdGgqZCotMSxiLm9wdGlvbnMucnRsPT09ITA/YShlKS5jc3Moe3Bvc2l0aW9uOlwicmVsYXRpdmVcIixyaWdodDpjLHRvcDowLHpJbmRleDpiLm9wdGlvbnMuekluZGV4LTIsb3BhY2l0eTowfSk6YShlKS5jc3Moe3Bvc2l0aW9uOlwicmVsYXRpdmVcIixsZWZ0OmMsdG9wOjAsekluZGV4OmIub3B0aW9ucy56SW5kZXgtMixvcGFjaXR5OjB9KX0pLGIuJHNsaWRlcy5lcShiLmN1cnJlbnRTbGlkZSkuY3NzKHt6SW5kZXg6Yi5vcHRpb25zLnpJbmRleC0xLG9wYWNpdHk6MX0pfSxiLnByb3RvdHlwZS5zZXRIZWlnaHQ9ZnVuY3Rpb24oKXt2YXIgYT10aGlzO2lmKDE9PT1hLm9wdGlvbnMuc2xpZGVzVG9TaG93JiZhLm9wdGlvbnMuYWRhcHRpdmVIZWlnaHQ9PT0hMCYmYS5vcHRpb25zLnZlcnRpY2FsPT09ITEpe3ZhciBiPWEuJHNsaWRlcy5lcShhLmN1cnJlbnRTbGlkZSkub3V0ZXJIZWlnaHQoITApO2EuJGxpc3QuY3NzKFwiaGVpZ2h0XCIsYil9fSxiLnByb3RvdHlwZS5zZXRPcHRpb249Yi5wcm90b3R5cGUuc2xpY2tTZXRPcHRpb249ZnVuY3Rpb24oYixjLGQpe3ZhciBmLGcsZT10aGlzO2lmKFwicmVzcG9uc2l2ZVwiPT09YiYmXCJhcnJheVwiPT09YS50eXBlKGMpKWZvcihnIGluIGMpaWYoXCJhcnJheVwiIT09YS50eXBlKGUub3B0aW9ucy5yZXNwb25zaXZlKSllLm9wdGlvbnMucmVzcG9uc2l2ZT1bY1tnXV07ZWxzZXtmb3IoZj1lLm9wdGlvbnMucmVzcG9uc2l2ZS5sZW5ndGgtMTtmPj0wOyllLm9wdGlvbnMucmVzcG9uc2l2ZVtmXS5icmVha3BvaW50PT09Y1tnXS5icmVha3BvaW50JiZlLm9wdGlvbnMucmVzcG9uc2l2ZS5zcGxpY2UoZiwxKSxmLS07ZS5vcHRpb25zLnJlc3BvbnNpdmUucHVzaChjW2ddKX1lbHNlIGUub3B0aW9uc1tiXT1jO2Q9PT0hMCYmKGUudW5sb2FkKCksZS5yZWluaXQoKSl9LGIucHJvdG90eXBlLnNldFBvc2l0aW9uPWZ1bmN0aW9uKCl7dmFyIGE9dGhpczthLnNldERpbWVuc2lvbnMoKSxhLnNldEhlaWdodCgpLGEub3B0aW9ucy5mYWRlPT09ITE/YS5zZXRDU1MoYS5nZXRMZWZ0KGEuY3VycmVudFNsaWRlKSk6YS5zZXRGYWRlKCksYS4kc2xpZGVyLnRyaWdnZXIoXCJzZXRQb3NpdGlvblwiLFthXSl9LGIucHJvdG90eXBlLnNldFByb3BzPWZ1bmN0aW9uKCl7dmFyIGE9dGhpcyxiPWRvY3VtZW50LmJvZHkuc3R5bGU7YS5wb3NpdGlvblByb3A9YS5vcHRpb25zLnZlcnRpY2FsPT09ITA/XCJ0b3BcIjpcImxlZnRcIixcInRvcFwiPT09YS5wb3NpdGlvblByb3A/YS4kc2xpZGVyLmFkZENsYXNzKFwic2xpY2stdmVydGljYWxcIik6YS4kc2xpZGVyLnJlbW92ZUNsYXNzKFwic2xpY2stdmVydGljYWxcIiksKHZvaWQgMCE9PWIuV2Via2l0VHJhbnNpdGlvbnx8dm9pZCAwIT09Yi5Nb3pUcmFuc2l0aW9ufHx2b2lkIDAhPT1iLm1zVHJhbnNpdGlvbikmJmEub3B0aW9ucy51c2VDU1M9PT0hMCYmKGEuY3NzVHJhbnNpdGlvbnM9ITApLGEub3B0aW9ucy5mYWRlJiYoXCJudW1iZXJcIj09dHlwZW9mIGEub3B0aW9ucy56SW5kZXg/YS5vcHRpb25zLnpJbmRleDwzJiYoYS5vcHRpb25zLnpJbmRleD0zKTphLm9wdGlvbnMuekluZGV4PWEuZGVmYXVsdHMuekluZGV4KSx2b2lkIDAhPT1iLk9UcmFuc2Zvcm0mJihhLmFuaW1UeXBlPVwiT1RyYW5zZm9ybVwiLGEudHJhbnNmb3JtVHlwZT1cIi1vLXRyYW5zZm9ybVwiLGEudHJhbnNpdGlvblR5cGU9XCJPVHJhbnNpdGlvblwiLHZvaWQgMD09PWIucGVyc3BlY3RpdmVQcm9wZXJ0eSYmdm9pZCAwPT09Yi53ZWJraXRQZXJzcGVjdGl2ZSYmKGEuYW5pbVR5cGU9ITEpKSx2b2lkIDAhPT1iLk1velRyYW5zZm9ybSYmKGEuYW5pbVR5cGU9XCJNb3pUcmFuc2Zvcm1cIixhLnRyYW5zZm9ybVR5cGU9XCItbW96LXRyYW5zZm9ybVwiLGEudHJhbnNpdGlvblR5cGU9XCJNb3pUcmFuc2l0aW9uXCIsdm9pZCAwPT09Yi5wZXJzcGVjdGl2ZVByb3BlcnR5JiZ2b2lkIDA9PT1iLk1velBlcnNwZWN0aXZlJiYoYS5hbmltVHlwZT0hMSkpLHZvaWQgMCE9PWIud2Via2l0VHJhbnNmb3JtJiYoYS5hbmltVHlwZT1cIndlYmtpdFRyYW5zZm9ybVwiLGEudHJhbnNmb3JtVHlwZT1cIi13ZWJraXQtdHJhbnNmb3JtXCIsYS50cmFuc2l0aW9uVHlwZT1cIndlYmtpdFRyYW5zaXRpb25cIix2b2lkIDA9PT1iLnBlcnNwZWN0aXZlUHJvcGVydHkmJnZvaWQgMD09PWIud2Via2l0UGVyc3BlY3RpdmUmJihhLmFuaW1UeXBlPSExKSksdm9pZCAwIT09Yi5tc1RyYW5zZm9ybSYmKGEuYW5pbVR5cGU9XCJtc1RyYW5zZm9ybVwiLGEudHJhbnNmb3JtVHlwZT1cIi1tcy10cmFuc2Zvcm1cIixhLnRyYW5zaXRpb25UeXBlPVwibXNUcmFuc2l0aW9uXCIsdm9pZCAwPT09Yi5tc1RyYW5zZm9ybSYmKGEuYW5pbVR5cGU9ITEpKSx2b2lkIDAhPT1iLnRyYW5zZm9ybSYmYS5hbmltVHlwZSE9PSExJiYoYS5hbmltVHlwZT1cInRyYW5zZm9ybVwiLGEudHJhbnNmb3JtVHlwZT1cInRyYW5zZm9ybVwiLGEudHJhbnNpdGlvblR5cGU9XCJ0cmFuc2l0aW9uXCIpLGEudHJhbnNmb3Jtc0VuYWJsZWQ9YS5vcHRpb25zLnVzZVRyYW5zZm9ybSYmbnVsbCE9PWEuYW5pbVR5cGUmJmEuYW5pbVR5cGUhPT0hMX0sYi5wcm90b3R5cGUuc2V0U2xpZGVDbGFzc2VzPWZ1bmN0aW9uKGEpe3ZhciBjLGQsZSxmLGI9dGhpcztkPWIuJHNsaWRlci5maW5kKFwiLnNsaWNrLXNsaWRlXCIpLnJlbW92ZUNsYXNzKFwic2xpY2stYWN0aXZlIHNsaWNrLWNlbnRlciBzbGljay1jdXJyZW50XCIpLmF0dHIoXCJhcmlhLWhpZGRlblwiLFwidHJ1ZVwiKSxiLiRzbGlkZXMuZXEoYSkuYWRkQ2xhc3MoXCJzbGljay1jdXJyZW50XCIpLGIub3B0aW9ucy5jZW50ZXJNb2RlPT09ITA/KGM9TWF0aC5mbG9vcihiLm9wdGlvbnMuc2xpZGVzVG9TaG93LzIpLGIub3B0aW9ucy5pbmZpbml0ZT09PSEwJiYoYT49YyYmYTw9Yi5zbGlkZUNvdW50LTEtYz9iLiRzbGlkZXMuc2xpY2UoYS1jLGErYysxKS5hZGRDbGFzcyhcInNsaWNrLWFjdGl2ZVwiKS5hdHRyKFwiYXJpYS1oaWRkZW5cIixcImZhbHNlXCIpOihlPWIub3B0aW9ucy5zbGlkZXNUb1Nob3crYSxkLnNsaWNlKGUtYysxLGUrYysyKS5hZGRDbGFzcyhcInNsaWNrLWFjdGl2ZVwiKS5hdHRyKFwiYXJpYS1oaWRkZW5cIixcImZhbHNlXCIpKSwwPT09YT9kLmVxKGQubGVuZ3RoLTEtYi5vcHRpb25zLnNsaWRlc1RvU2hvdykuYWRkQ2xhc3MoXCJzbGljay1jZW50ZXJcIik6YT09PWIuc2xpZGVDb3VudC0xJiZkLmVxKGIub3B0aW9ucy5zbGlkZXNUb1Nob3cpLmFkZENsYXNzKFwic2xpY2stY2VudGVyXCIpKSxiLiRzbGlkZXMuZXEoYSkuYWRkQ2xhc3MoXCJzbGljay1jZW50ZXJcIikpOmE+PTAmJmE8PWIuc2xpZGVDb3VudC1iLm9wdGlvbnMuc2xpZGVzVG9TaG93P2IuJHNsaWRlcy5zbGljZShhLGErYi5vcHRpb25zLnNsaWRlc1RvU2hvdykuYWRkQ2xhc3MoXCJzbGljay1hY3RpdmVcIikuYXR0cihcImFyaWEtaGlkZGVuXCIsXCJmYWxzZVwiKTpkLmxlbmd0aDw9Yi5vcHRpb25zLnNsaWRlc1RvU2hvdz9kLmFkZENsYXNzKFwic2xpY2stYWN0aXZlXCIpLmF0dHIoXCJhcmlhLWhpZGRlblwiLFwiZmFsc2VcIik6KGY9Yi5zbGlkZUNvdW50JWIub3B0aW9ucy5zbGlkZXNUb1Nob3csZT1iLm9wdGlvbnMuaW5maW5pdGU9PT0hMD9iLm9wdGlvbnMuc2xpZGVzVG9TaG93K2E6YSxiLm9wdGlvbnMuc2xpZGVzVG9TaG93PT1iLm9wdGlvbnMuc2xpZGVzVG9TY3JvbGwmJmIuc2xpZGVDb3VudC1hPGIub3B0aW9ucy5zbGlkZXNUb1Nob3c/ZC5zbGljZShlLShiLm9wdGlvbnMuc2xpZGVzVG9TaG93LWYpLGUrZikuYWRkQ2xhc3MoXCJzbGljay1hY3RpdmVcIikuYXR0cihcImFyaWEtaGlkZGVuXCIsXCJmYWxzZVwiKTpkLnNsaWNlKGUsZStiLm9wdGlvbnMuc2xpZGVzVG9TaG93KS5hZGRDbGFzcyhcInNsaWNrLWFjdGl2ZVwiKS5hdHRyKFwiYXJpYS1oaWRkZW5cIixcImZhbHNlXCIpKSxcIm9uZGVtYW5kXCI9PT1iLm9wdGlvbnMubGF6eUxvYWQmJmIubGF6eUxvYWQoKX0sYi5wcm90b3R5cGUuc2V0dXBJbmZpbml0ZT1mdW5jdGlvbigpe3ZhciBjLGQsZSxiPXRoaXM7aWYoYi5vcHRpb25zLmZhZGU9PT0hMCYmKGIub3B0aW9ucy5jZW50ZXJNb2RlPSExKSxiLm9wdGlvbnMuaW5maW5pdGU9PT0hMCYmYi5vcHRpb25zLmZhZGU9PT0hMSYmKGQ9bnVsbCxiLnNsaWRlQ291bnQ+Yi5vcHRpb25zLnNsaWRlc1RvU2hvdykpe2ZvcihlPWIub3B0aW9ucy5jZW50ZXJNb2RlPT09ITA/Yi5vcHRpb25zLnNsaWRlc1RvU2hvdysxOmIub3B0aW9ucy5zbGlkZXNUb1Nob3csYz1iLnNsaWRlQ291bnQ7Yz5iLnNsaWRlQ291bnQtZTtjLT0xKWQ9Yy0xLGEoYi4kc2xpZGVzW2RdKS5jbG9uZSghMCkuYXR0cihcImlkXCIsXCJcIikuYXR0cihcImRhdGEtc2xpY2staW5kZXhcIixkLWIuc2xpZGVDb3VudCkucHJlcGVuZFRvKGIuJHNsaWRlVHJhY2spLmFkZENsYXNzKFwic2xpY2stY2xvbmVkXCIpO2ZvcihjPTA7ZT5jO2MrPTEpZD1jLGEoYi4kc2xpZGVzW2RdKS5jbG9uZSghMCkuYXR0cihcImlkXCIsXCJcIikuYXR0cihcImRhdGEtc2xpY2staW5kZXhcIixkK2Iuc2xpZGVDb3VudCkuYXBwZW5kVG8oYi4kc2xpZGVUcmFjaykuYWRkQ2xhc3MoXCJzbGljay1jbG9uZWRcIik7Yi4kc2xpZGVUcmFjay5maW5kKFwiLnNsaWNrLWNsb25lZFwiKS5maW5kKFwiW2lkXVwiKS5lYWNoKGZ1bmN0aW9uKCl7YSh0aGlzKS5hdHRyKFwiaWRcIixcIlwiKX0pfX0sYi5wcm90b3R5cGUuc2V0UGF1c2VkPWZ1bmN0aW9uKGEpe3ZhciBiPXRoaXM7Yi5vcHRpb25zLmF1dG9wbGF5PT09ITAmJmIub3B0aW9ucy5wYXVzZU9uSG92ZXI9PT0hMCYmKGIucGF1c2VkPWEsYT9iLmF1dG9QbGF5Q2xlYXIoKTpiLmF1dG9QbGF5KCkpfSxiLnByb3RvdHlwZS5zZWxlY3RIYW5kbGVyPWZ1bmN0aW9uKGIpe3ZhciBjPXRoaXMsZD1hKGIudGFyZ2V0KS5pcyhcIi5zbGljay1zbGlkZVwiKT9hKGIudGFyZ2V0KTphKGIudGFyZ2V0KS5wYXJlbnRzKFwiLnNsaWNrLXNsaWRlXCIpLGU9cGFyc2VJbnQoZC5hdHRyKFwiZGF0YS1zbGljay1pbmRleFwiKSk7cmV0dXJuIGV8fChlPTApLGMuc2xpZGVDb3VudDw9Yy5vcHRpb25zLnNsaWRlc1RvU2hvdz8oYy5zZXRTbGlkZUNsYXNzZXMoZSksdm9pZCBjLmFzTmF2Rm9yKGUpKTp2b2lkIGMuc2xpZGVIYW5kbGVyKGUpfSxiLnByb3RvdHlwZS5zbGlkZUhhbmRsZXI9ZnVuY3Rpb24oYSxiLGMpe3ZhciBkLGUsZixnLGg9bnVsbCxpPXRoaXM7cmV0dXJuIGI9Ynx8ITEsaS5hbmltYXRpbmc9PT0hMCYmaS5vcHRpb25zLndhaXRGb3JBbmltYXRlPT09ITB8fGkub3B0aW9ucy5mYWRlPT09ITAmJmkuY3VycmVudFNsaWRlPT09YXx8aS5zbGlkZUNvdW50PD1pLm9wdGlvbnMuc2xpZGVzVG9TaG93P3ZvaWQgMDooYj09PSExJiZpLmFzTmF2Rm9yKGEpLGQ9YSxoPWkuZ2V0TGVmdChkKSxnPWkuZ2V0TGVmdChpLmN1cnJlbnRTbGlkZSksaS5jdXJyZW50TGVmdD1udWxsPT09aS5zd2lwZUxlZnQ/ZzppLnN3aXBlTGVmdCxpLm9wdGlvbnMuaW5maW5pdGU9PT0hMSYmaS5vcHRpb25zLmNlbnRlck1vZGU9PT0hMSYmKDA+YXx8YT5pLmdldERvdENvdW50KCkqaS5vcHRpb25zLnNsaWRlc1RvU2Nyb2xsKT92b2lkKGkub3B0aW9ucy5mYWRlPT09ITEmJihkPWkuY3VycmVudFNsaWRlLGMhPT0hMD9pLmFuaW1hdGVTbGlkZShnLGZ1bmN0aW9uKCl7aS5wb3N0U2xpZGUoZCk7XHJcbn0pOmkucG9zdFNsaWRlKGQpKSk6aS5vcHRpb25zLmluZmluaXRlPT09ITEmJmkub3B0aW9ucy5jZW50ZXJNb2RlPT09ITAmJigwPmF8fGE+aS5zbGlkZUNvdW50LWkub3B0aW9ucy5zbGlkZXNUb1Njcm9sbCk/dm9pZChpLm9wdGlvbnMuZmFkZT09PSExJiYoZD1pLmN1cnJlbnRTbGlkZSxjIT09ITA/aS5hbmltYXRlU2xpZGUoZyxmdW5jdGlvbigpe2kucG9zdFNsaWRlKGQpfSk6aS5wb3N0U2xpZGUoZCkpKTooaS5vcHRpb25zLmF1dG9wbGF5PT09ITAmJmNsZWFySW50ZXJ2YWwoaS5hdXRvUGxheVRpbWVyKSxlPTA+ZD9pLnNsaWRlQ291bnQlaS5vcHRpb25zLnNsaWRlc1RvU2Nyb2xsIT09MD9pLnNsaWRlQ291bnQtaS5zbGlkZUNvdW50JWkub3B0aW9ucy5zbGlkZXNUb1Njcm9sbDppLnNsaWRlQ291bnQrZDpkPj1pLnNsaWRlQ291bnQ/aS5zbGlkZUNvdW50JWkub3B0aW9ucy5zbGlkZXNUb1Njcm9sbCE9PTA/MDpkLWkuc2xpZGVDb3VudDpkLGkuYW5pbWF0aW5nPSEwLGkuJHNsaWRlci50cmlnZ2VyKFwiYmVmb3JlQ2hhbmdlXCIsW2ksaS5jdXJyZW50U2xpZGUsZV0pLGY9aS5jdXJyZW50U2xpZGUsaS5jdXJyZW50U2xpZGU9ZSxpLnNldFNsaWRlQ2xhc3NlcyhpLmN1cnJlbnRTbGlkZSksaS51cGRhdGVEb3RzKCksaS51cGRhdGVBcnJvd3MoKSxpLm9wdGlvbnMuZmFkZT09PSEwPyhjIT09ITA/KGkuZmFkZVNsaWRlT3V0KGYpLGkuZmFkZVNsaWRlKGUsZnVuY3Rpb24oKXtpLnBvc3RTbGlkZShlKX0pKTppLnBvc3RTbGlkZShlKSx2b2lkIGkuYW5pbWF0ZUhlaWdodCgpKTp2b2lkKGMhPT0hMD9pLmFuaW1hdGVTbGlkZShoLGZ1bmN0aW9uKCl7aS5wb3N0U2xpZGUoZSl9KTppLnBvc3RTbGlkZShlKSkpKX0sYi5wcm90b3R5cGUuc3RhcnRMb2FkPWZ1bmN0aW9uKCl7dmFyIGE9dGhpczthLm9wdGlvbnMuYXJyb3dzPT09ITAmJmEuc2xpZGVDb3VudD5hLm9wdGlvbnMuc2xpZGVzVG9TaG93JiYoYS4kcHJldkFycm93LmhpZGUoKSxhLiRuZXh0QXJyb3cuaGlkZSgpKSxhLm9wdGlvbnMuZG90cz09PSEwJiZhLnNsaWRlQ291bnQ+YS5vcHRpb25zLnNsaWRlc1RvU2hvdyYmYS4kZG90cy5oaWRlKCksYS4kc2xpZGVyLmFkZENsYXNzKFwic2xpY2stbG9hZGluZ1wiKX0sYi5wcm90b3R5cGUuc3dpcGVEaXJlY3Rpb249ZnVuY3Rpb24oKXt2YXIgYSxiLGMsZCxlPXRoaXM7cmV0dXJuIGE9ZS50b3VjaE9iamVjdC5zdGFydFgtZS50b3VjaE9iamVjdC5jdXJYLGI9ZS50b3VjaE9iamVjdC5zdGFydFktZS50b3VjaE9iamVjdC5jdXJZLGM9TWF0aC5hdGFuMihiLGEpLGQ9TWF0aC5yb3VuZCgxODAqYy9NYXRoLlBJKSwwPmQmJihkPTM2MC1NYXRoLmFicyhkKSksNDU+PWQmJmQ+PTA/ZS5vcHRpb25zLnJ0bD09PSExP1wibGVmdFwiOlwicmlnaHRcIjozNjA+PWQmJmQ+PTMxNT9lLm9wdGlvbnMucnRsPT09ITE/XCJsZWZ0XCI6XCJyaWdodFwiOmQ+PTEzNSYmMjI1Pj1kP2Uub3B0aW9ucy5ydGw9PT0hMT9cInJpZ2h0XCI6XCJsZWZ0XCI6ZS5vcHRpb25zLnZlcnRpY2FsU3dpcGluZz09PSEwP2Q+PTM1JiYxMzU+PWQ/XCJsZWZ0XCI6XCJyaWdodFwiOlwidmVydGljYWxcIn0sYi5wcm90b3R5cGUuc3dpcGVFbmQ9ZnVuY3Rpb24oYSl7dmFyIGMsYj10aGlzO2lmKGIuZHJhZ2dpbmc9ITEsYi5zaG91bGRDbGljaz1iLnRvdWNoT2JqZWN0LnN3aXBlTGVuZ3RoPjEwPyExOiEwLHZvaWQgMD09PWIudG91Y2hPYmplY3QuY3VyWClyZXR1cm4hMTtpZihiLnRvdWNoT2JqZWN0LmVkZ2VIaXQ9PT0hMCYmYi4kc2xpZGVyLnRyaWdnZXIoXCJlZGdlXCIsW2IsYi5zd2lwZURpcmVjdGlvbigpXSksYi50b3VjaE9iamVjdC5zd2lwZUxlbmd0aD49Yi50b3VjaE9iamVjdC5taW5Td2lwZSlzd2l0Y2goYi5zd2lwZURpcmVjdGlvbigpKXtjYXNlXCJsZWZ0XCI6Yz1iLm9wdGlvbnMuc3dpcGVUb1NsaWRlP2IuY2hlY2tOYXZpZ2FibGUoYi5jdXJyZW50U2xpZGUrYi5nZXRTbGlkZUNvdW50KCkpOmIuY3VycmVudFNsaWRlK2IuZ2V0U2xpZGVDb3VudCgpLGIuc2xpZGVIYW5kbGVyKGMpLGIuY3VycmVudERpcmVjdGlvbj0wLGIudG91Y2hPYmplY3Q9e30sYi4kc2xpZGVyLnRyaWdnZXIoXCJzd2lwZVwiLFtiLFwibGVmdFwiXSk7YnJlYWs7Y2FzZVwicmlnaHRcIjpjPWIub3B0aW9ucy5zd2lwZVRvU2xpZGU/Yi5jaGVja05hdmlnYWJsZShiLmN1cnJlbnRTbGlkZS1iLmdldFNsaWRlQ291bnQoKSk6Yi5jdXJyZW50U2xpZGUtYi5nZXRTbGlkZUNvdW50KCksYi5zbGlkZUhhbmRsZXIoYyksYi5jdXJyZW50RGlyZWN0aW9uPTEsYi50b3VjaE9iamVjdD17fSxiLiRzbGlkZXIudHJpZ2dlcihcInN3aXBlXCIsW2IsXCJyaWdodFwiXSl9ZWxzZSBiLnRvdWNoT2JqZWN0LnN0YXJ0WCE9PWIudG91Y2hPYmplY3QuY3VyWCYmKGIuc2xpZGVIYW5kbGVyKGIuY3VycmVudFNsaWRlKSxiLnRvdWNoT2JqZWN0PXt9KX0sYi5wcm90b3R5cGUuc3dpcGVIYW5kbGVyPWZ1bmN0aW9uKGEpe3ZhciBiPXRoaXM7aWYoIShiLm9wdGlvbnMuc3dpcGU9PT0hMXx8XCJvbnRvdWNoZW5kXCJpbiBkb2N1bWVudCYmYi5vcHRpb25zLnN3aXBlPT09ITF8fGIub3B0aW9ucy5kcmFnZ2FibGU9PT0hMSYmLTEhPT1hLnR5cGUuaW5kZXhPZihcIm1vdXNlXCIpKSlzd2l0Y2goYi50b3VjaE9iamVjdC5maW5nZXJDb3VudD1hLm9yaWdpbmFsRXZlbnQmJnZvaWQgMCE9PWEub3JpZ2luYWxFdmVudC50b3VjaGVzP2Eub3JpZ2luYWxFdmVudC50b3VjaGVzLmxlbmd0aDoxLGIudG91Y2hPYmplY3QubWluU3dpcGU9Yi5saXN0V2lkdGgvYi5vcHRpb25zLnRvdWNoVGhyZXNob2xkLGIub3B0aW9ucy52ZXJ0aWNhbFN3aXBpbmc9PT0hMCYmKGIudG91Y2hPYmplY3QubWluU3dpcGU9Yi5saXN0SGVpZ2h0L2Iub3B0aW9ucy50b3VjaFRocmVzaG9sZCksYS5kYXRhLmFjdGlvbil7Y2FzZVwic3RhcnRcIjpiLnN3aXBlU3RhcnQoYSk7YnJlYWs7Y2FzZVwibW92ZVwiOmIuc3dpcGVNb3ZlKGEpO2JyZWFrO2Nhc2VcImVuZFwiOmIuc3dpcGVFbmQoYSl9fSxiLnByb3RvdHlwZS5zd2lwZU1vdmU9ZnVuY3Rpb24oYSl7dmFyIGQsZSxmLGcsaCxiPXRoaXM7cmV0dXJuIGg9dm9pZCAwIT09YS5vcmlnaW5hbEV2ZW50P2Eub3JpZ2luYWxFdmVudC50b3VjaGVzOm51bGwsIWIuZHJhZ2dpbmd8fGgmJjEhPT1oLmxlbmd0aD8hMTooZD1iLmdldExlZnQoYi5jdXJyZW50U2xpZGUpLGIudG91Y2hPYmplY3QuY3VyWD12b2lkIDAhPT1oP2hbMF0ucGFnZVg6YS5jbGllbnRYLGIudG91Y2hPYmplY3QuY3VyWT12b2lkIDAhPT1oP2hbMF0ucGFnZVk6YS5jbGllbnRZLGIudG91Y2hPYmplY3Quc3dpcGVMZW5ndGg9TWF0aC5yb3VuZChNYXRoLnNxcnQoTWF0aC5wb3coYi50b3VjaE9iamVjdC5jdXJYLWIudG91Y2hPYmplY3Quc3RhcnRYLDIpKSksYi5vcHRpb25zLnZlcnRpY2FsU3dpcGluZz09PSEwJiYoYi50b3VjaE9iamVjdC5zd2lwZUxlbmd0aD1NYXRoLnJvdW5kKE1hdGguc3FydChNYXRoLnBvdyhiLnRvdWNoT2JqZWN0LmN1clktYi50b3VjaE9iamVjdC5zdGFydFksMikpKSksZT1iLnN3aXBlRGlyZWN0aW9uKCksXCJ2ZXJ0aWNhbFwiIT09ZT8odm9pZCAwIT09YS5vcmlnaW5hbEV2ZW50JiZiLnRvdWNoT2JqZWN0LnN3aXBlTGVuZ3RoPjQmJmEucHJldmVudERlZmF1bHQoKSxnPShiLm9wdGlvbnMucnRsPT09ITE/MTotMSkqKGIudG91Y2hPYmplY3QuY3VyWD5iLnRvdWNoT2JqZWN0LnN0YXJ0WD8xOi0xKSxiLm9wdGlvbnMudmVydGljYWxTd2lwaW5nPT09ITAmJihnPWIudG91Y2hPYmplY3QuY3VyWT5iLnRvdWNoT2JqZWN0LnN0YXJ0WT8xOi0xKSxmPWIudG91Y2hPYmplY3Quc3dpcGVMZW5ndGgsYi50b3VjaE9iamVjdC5lZGdlSGl0PSExLGIub3B0aW9ucy5pbmZpbml0ZT09PSExJiYoMD09PWIuY3VycmVudFNsaWRlJiZcInJpZ2h0XCI9PT1lfHxiLmN1cnJlbnRTbGlkZT49Yi5nZXREb3RDb3VudCgpJiZcImxlZnRcIj09PWUpJiYoZj1iLnRvdWNoT2JqZWN0LnN3aXBlTGVuZ3RoKmIub3B0aW9ucy5lZGdlRnJpY3Rpb24sYi50b3VjaE9iamVjdC5lZGdlSGl0PSEwKSxiLm9wdGlvbnMudmVydGljYWw9PT0hMT9iLnN3aXBlTGVmdD1kK2YqZzpiLnN3aXBlTGVmdD1kK2YqKGIuJGxpc3QuaGVpZ2h0KCkvYi5saXN0V2lkdGgpKmcsYi5vcHRpb25zLnZlcnRpY2FsU3dpcGluZz09PSEwJiYoYi5zd2lwZUxlZnQ9ZCtmKmcpLGIub3B0aW9ucy5mYWRlPT09ITB8fGIub3B0aW9ucy50b3VjaE1vdmU9PT0hMT8hMTpiLmFuaW1hdGluZz09PSEwPyhiLnN3aXBlTGVmdD1udWxsLCExKTp2b2lkIGIuc2V0Q1NTKGIuc3dpcGVMZWZ0KSk6dm9pZCAwKX0sYi5wcm90b3R5cGUuc3dpcGVTdGFydD1mdW5jdGlvbihhKXt2YXIgYyxiPXRoaXM7cmV0dXJuIDEhPT1iLnRvdWNoT2JqZWN0LmZpbmdlckNvdW50fHxiLnNsaWRlQ291bnQ8PWIub3B0aW9ucy5zbGlkZXNUb1Nob3c/KGIudG91Y2hPYmplY3Q9e30sITEpOih2b2lkIDAhPT1hLm9yaWdpbmFsRXZlbnQmJnZvaWQgMCE9PWEub3JpZ2luYWxFdmVudC50b3VjaGVzJiYoYz1hLm9yaWdpbmFsRXZlbnQudG91Y2hlc1swXSksYi50b3VjaE9iamVjdC5zdGFydFg9Yi50b3VjaE9iamVjdC5jdXJYPXZvaWQgMCE9PWM/Yy5wYWdlWDphLmNsaWVudFgsYi50b3VjaE9iamVjdC5zdGFydFk9Yi50b3VjaE9iamVjdC5jdXJZPXZvaWQgMCE9PWM/Yy5wYWdlWTphLmNsaWVudFksdm9pZChiLmRyYWdnaW5nPSEwKSl9LGIucHJvdG90eXBlLnVuZmlsdGVyU2xpZGVzPWIucHJvdG90eXBlLnNsaWNrVW5maWx0ZXI9ZnVuY3Rpb24oKXt2YXIgYT10aGlzO251bGwhPT1hLiRzbGlkZXNDYWNoZSYmKGEudW5sb2FkKCksYS4kc2xpZGVUcmFjay5jaGlsZHJlbih0aGlzLm9wdGlvbnMuc2xpZGUpLmRldGFjaCgpLGEuJHNsaWRlc0NhY2hlLmFwcGVuZFRvKGEuJHNsaWRlVHJhY2spLGEucmVpbml0KCkpfSxiLnByb3RvdHlwZS51bmxvYWQ9ZnVuY3Rpb24oKXt2YXIgYj10aGlzO2EoXCIuc2xpY2stY2xvbmVkXCIsYi4kc2xpZGVyKS5yZW1vdmUoKSxiLiRkb3RzJiZiLiRkb3RzLnJlbW92ZSgpLGIuJHByZXZBcnJvdyYmYi5odG1sRXhwci50ZXN0KGIub3B0aW9ucy5wcmV2QXJyb3cpJiZiLiRwcmV2QXJyb3cucmVtb3ZlKCksYi4kbmV4dEFycm93JiZiLmh0bWxFeHByLnRlc3QoYi5vcHRpb25zLm5leHRBcnJvdykmJmIuJG5leHRBcnJvdy5yZW1vdmUoKSxiLiRzbGlkZXMucmVtb3ZlQ2xhc3MoXCJzbGljay1zbGlkZSBzbGljay1hY3RpdmUgc2xpY2stdmlzaWJsZSBzbGljay1jdXJyZW50XCIpLmF0dHIoXCJhcmlhLWhpZGRlblwiLFwidHJ1ZVwiKS5jc3MoXCJ3aWR0aFwiLFwiXCIpfSxiLnByb3RvdHlwZS51bnNsaWNrPWZ1bmN0aW9uKGEpe3ZhciBiPXRoaXM7Yi4kc2xpZGVyLnRyaWdnZXIoXCJ1bnNsaWNrXCIsW2IsYV0pLGIuZGVzdHJveSgpfSxiLnByb3RvdHlwZS51cGRhdGVBcnJvd3M9ZnVuY3Rpb24oKXt2YXIgYixhPXRoaXM7Yj1NYXRoLmZsb29yKGEub3B0aW9ucy5zbGlkZXNUb1Nob3cvMiksYS5vcHRpb25zLmFycm93cz09PSEwJiZhLnNsaWRlQ291bnQ+YS5vcHRpb25zLnNsaWRlc1RvU2hvdyYmIWEub3B0aW9ucy5pbmZpbml0ZSYmKGEuJHByZXZBcnJvdy5yZW1vdmVDbGFzcyhcInNsaWNrLWRpc2FibGVkXCIpLmF0dHIoXCJhcmlhLWRpc2FibGVkXCIsXCJmYWxzZVwiKSxhLiRuZXh0QXJyb3cucmVtb3ZlQ2xhc3MoXCJzbGljay1kaXNhYmxlZFwiKS5hdHRyKFwiYXJpYS1kaXNhYmxlZFwiLFwiZmFsc2VcIiksMD09PWEuY3VycmVudFNsaWRlPyhhLiRwcmV2QXJyb3cuYWRkQ2xhc3MoXCJzbGljay1kaXNhYmxlZFwiKS5hdHRyKFwiYXJpYS1kaXNhYmxlZFwiLFwidHJ1ZVwiKSxhLiRuZXh0QXJyb3cucmVtb3ZlQ2xhc3MoXCJzbGljay1kaXNhYmxlZFwiKS5hdHRyKFwiYXJpYS1kaXNhYmxlZFwiLFwiZmFsc2VcIikpOmEuY3VycmVudFNsaWRlPj1hLnNsaWRlQ291bnQtYS5vcHRpb25zLnNsaWRlc1RvU2hvdyYmYS5vcHRpb25zLmNlbnRlck1vZGU9PT0hMT8oYS4kbmV4dEFycm93LmFkZENsYXNzKFwic2xpY2stZGlzYWJsZWRcIikuYXR0cihcImFyaWEtZGlzYWJsZWRcIixcInRydWVcIiksYS4kcHJldkFycm93LnJlbW92ZUNsYXNzKFwic2xpY2stZGlzYWJsZWRcIikuYXR0cihcImFyaWEtZGlzYWJsZWRcIixcImZhbHNlXCIpKTphLmN1cnJlbnRTbGlkZT49YS5zbGlkZUNvdW50LTEmJmEub3B0aW9ucy5jZW50ZXJNb2RlPT09ITAmJihhLiRuZXh0QXJyb3cuYWRkQ2xhc3MoXCJzbGljay1kaXNhYmxlZFwiKS5hdHRyKFwiYXJpYS1kaXNhYmxlZFwiLFwidHJ1ZVwiKSxhLiRwcmV2QXJyb3cucmVtb3ZlQ2xhc3MoXCJzbGljay1kaXNhYmxlZFwiKS5hdHRyKFwiYXJpYS1kaXNhYmxlZFwiLFwiZmFsc2VcIikpKX0sYi5wcm90b3R5cGUudXBkYXRlRG90cz1mdW5jdGlvbigpe3ZhciBhPXRoaXM7bnVsbCE9PWEuJGRvdHMmJihhLiRkb3RzLmZpbmQoXCJsaVwiKS5yZW1vdmVDbGFzcyhcInNsaWNrLWFjdGl2ZVwiKS5hdHRyKFwiYXJpYS1oaWRkZW5cIixcInRydWVcIiksYS4kZG90cy5maW5kKFwibGlcIikuZXEoTWF0aC5mbG9vcihhLmN1cnJlbnRTbGlkZS9hLm9wdGlvbnMuc2xpZGVzVG9TY3JvbGwpKS5hZGRDbGFzcyhcInNsaWNrLWFjdGl2ZVwiKS5hdHRyKFwiYXJpYS1oaWRkZW5cIixcImZhbHNlXCIpKX0sYi5wcm90b3R5cGUudmlzaWJpbGl0eT1mdW5jdGlvbigpe3ZhciBhPXRoaXM7ZG9jdW1lbnRbYS5oaWRkZW5dPyhhLnBhdXNlZD0hMCxhLmF1dG9QbGF5Q2xlYXIoKSk6YS5vcHRpb25zLmF1dG9wbGF5PT09ITAmJihhLnBhdXNlZD0hMSxhLmF1dG9QbGF5KCkpfSxiLnByb3RvdHlwZS5pbml0QURBPWZ1bmN0aW9uKCl7dmFyIGI9dGhpcztiLiRzbGlkZXMuYWRkKGIuJHNsaWRlVHJhY2suZmluZChcIi5zbGljay1jbG9uZWRcIikpLmF0dHIoe1wiYXJpYS1oaWRkZW5cIjpcInRydWVcIix0YWJpbmRleDpcIi0xXCJ9KS5maW5kKFwiYSwgaW5wdXQsIGJ1dHRvbiwgc2VsZWN0XCIpLmF0dHIoe3RhYmluZGV4OlwiLTFcIn0pLGIuJHNsaWRlVHJhY2suYXR0cihcInJvbGVcIixcImxpc3Rib3hcIiksYi4kc2xpZGVzLm5vdChiLiRzbGlkZVRyYWNrLmZpbmQoXCIuc2xpY2stY2xvbmVkXCIpKS5lYWNoKGZ1bmN0aW9uKGMpe2EodGhpcykuYXR0cih7cm9sZTpcIm9wdGlvblwiLFwiYXJpYS1kZXNjcmliZWRieVwiOlwic2xpY2stc2xpZGVcIitiLmluc3RhbmNlVWlkK2N9KX0pLG51bGwhPT1iLiRkb3RzJiZiLiRkb3RzLmF0dHIoXCJyb2xlXCIsXCJ0YWJsaXN0XCIpLmZpbmQoXCJsaVwiKS5lYWNoKGZ1bmN0aW9uKGMpe2EodGhpcykuYXR0cih7cm9sZTpcInByZXNlbnRhdGlvblwiLFwiYXJpYS1zZWxlY3RlZFwiOlwiZmFsc2VcIixcImFyaWEtY29udHJvbHNcIjpcIm5hdmlnYXRpb25cIitiLmluc3RhbmNlVWlkK2MsaWQ6XCJzbGljay1zbGlkZVwiK2IuaW5zdGFuY2VVaWQrY30pfSkuZmlyc3QoKS5hdHRyKFwiYXJpYS1zZWxlY3RlZFwiLFwidHJ1ZVwiKS5lbmQoKS5maW5kKFwiYnV0dG9uXCIpLmF0dHIoXCJyb2xlXCIsXCJidXR0b25cIikuZW5kKCkuY2xvc2VzdChcImRpdlwiKS5hdHRyKFwicm9sZVwiLFwidG9vbGJhclwiKSxiLmFjdGl2YXRlQURBKCl9LGIucHJvdG90eXBlLmFjdGl2YXRlQURBPWZ1bmN0aW9uKCl7dmFyIGE9dGhpczthLiRzbGlkZVRyYWNrLmZpbmQoXCIuc2xpY2stYWN0aXZlXCIpLmF0dHIoe1wiYXJpYS1oaWRkZW5cIjpcImZhbHNlXCJ9KS5maW5kKFwiYSwgaW5wdXQsIGJ1dHRvbiwgc2VsZWN0XCIpLmF0dHIoe3RhYmluZGV4OlwiMFwifSl9LGIucHJvdG90eXBlLmZvY3VzSGFuZGxlcj1mdW5jdGlvbigpe3ZhciBiPXRoaXM7Yi4kc2xpZGVyLm9uKFwiZm9jdXMuc2xpY2sgYmx1ci5zbGlja1wiLFwiKlwiLGZ1bmN0aW9uKGMpe2Muc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7dmFyIGQ9YSh0aGlzKTtzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7Yi5pc1BsYXkmJihkLmlzKFwiOmZvY3VzXCIpPyhiLmF1dG9QbGF5Q2xlYXIoKSxiLnBhdXNlZD0hMCk6KGIucGF1c2VkPSExLGIuYXV0b1BsYXkoKSkpfSwwKX0pfSxhLmZuLnNsaWNrPWZ1bmN0aW9uKCl7dmFyIGYsZyxhPXRoaXMsYz1hcmd1bWVudHNbMF0sZD1BcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsMSksZT1hLmxlbmd0aDtmb3IoZj0wO2U+ZjtmKyspaWYoXCJvYmplY3RcIj09dHlwZW9mIGN8fFwidW5kZWZpbmVkXCI9PXR5cGVvZiBjP2FbZl0uc2xpY2s9bmV3IGIoYVtmXSxjKTpnPWFbZl0uc2xpY2tbY10uYXBwbHkoYVtmXS5zbGljayxkKSxcInVuZGVmaW5lZFwiIT10eXBlb2YgZylyZXR1cm4gZztyZXR1cm4gYX19KTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zY3JpcHRzL3ZlbmRvcnMvc2xpY2subWluLmpzIiwiLyohXHJcbiAqIGNsaXBib2FyZC5qcyB2MS41LjVcclxuICogaHR0cHM6Ly96ZW5vcm9jaGEuZ2l0aHViLmlvL2NsaXBib2FyZC5qc1xyXG4gKlxyXG4gKiBMaWNlbnNlZCBNSVQgwqkgWmVubyBSb2NoYVxyXG4gKi9cclxuIWZ1bmN0aW9uKHQpe2lmKFwib2JqZWN0XCI9PXR5cGVvZiBleHBvcnRzJiZcInVuZGVmaW5lZFwiIT10eXBlb2YgbW9kdWxlKW1vZHVsZS5leHBvcnRzPXQoKTtlbHNlIGlmKFwiZnVuY3Rpb25cIj09dHlwZW9mIGRlZmluZSYmZGVmaW5lLmFtZClkZWZpbmUoW10sdCk7ZWxzZXt2YXIgZTtlPVwidW5kZWZpbmVkXCIhPXR5cGVvZiB3aW5kb3c/d2luZG93OlwidW5kZWZpbmVkXCIhPXR5cGVvZiBnbG9iYWw/Z2xvYmFsOlwidW5kZWZpbmVkXCIhPXR5cGVvZiBzZWxmP3NlbGY6dGhpcyxlLkNsaXBib2FyZD10KCl9fShmdW5jdGlvbigpe3ZhciB0LGUsbjtyZXR1cm4gZnVuY3Rpb24gdChlLG4scil7ZnVuY3Rpb24gbyhhLGMpe2lmKCFuW2FdKXtpZighZVthXSl7dmFyIHM9XCJmdW5jdGlvblwiPT10eXBlb2YgcmVxdWlyZSYmcmVxdWlyZTtpZighYyYmcylyZXR1cm4gcyhhLCEwKTtpZihpKXJldHVybiBpKGEsITApO3ZhciB1PW5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIrYStcIidcIik7dGhyb3cgdS5jb2RlPVwiTU9EVUxFX05PVF9GT1VORFwiLHV9dmFyIGw9blthXT17ZXhwb3J0czp7fX07ZVthXVswXS5jYWxsKGwuZXhwb3J0cyxmdW5jdGlvbih0KXt2YXIgbj1lW2FdWzFdW3RdO3JldHVybiBvKG4/bjp0KX0sbCxsLmV4cG9ydHMsdCxlLG4scil9cmV0dXJuIG5bYV0uZXhwb3J0c31mb3IodmFyIGk9XCJmdW5jdGlvblwiPT10eXBlb2YgcmVxdWlyZSYmcmVxdWlyZSxhPTA7YTxyLmxlbmd0aDthKyspbyhyW2FdKTtyZXR1cm4gb30oezE6W2Z1bmN0aW9uKHQsZSxuKXt2YXIgcj10KFwibWF0Y2hlcy1zZWxlY3RvclwiKTtlLmV4cG9ydHM9ZnVuY3Rpb24odCxlLG4pe2Zvcih2YXIgbz1uP3Q6dC5wYXJlbnROb2RlO28mJm8hPT1kb2N1bWVudDspe2lmKHIobyxlKSlyZXR1cm4gbztvPW8ucGFyZW50Tm9kZX19fSx7XCJtYXRjaGVzLXNlbGVjdG9yXCI6Mn1dLDI6W2Z1bmN0aW9uKHQsZSxuKXtmdW5jdGlvbiByKHQsZSl7aWYoaSlyZXR1cm4gaS5jYWxsKHQsZSk7Zm9yKHZhciBuPXQucGFyZW50Tm9kZS5xdWVyeVNlbGVjdG9yQWxsKGUpLHI9MDtyPG4ubGVuZ3RoOysrcilpZihuW3JdPT10KXJldHVybiEwO3JldHVybiExfXZhciBvPUVsZW1lbnQucHJvdG90eXBlLGk9by5tYXRjaGVzU2VsZWN0b3J8fG8ud2Via2l0TWF0Y2hlc1NlbGVjdG9yfHxvLm1vek1hdGNoZXNTZWxlY3Rvcnx8by5tc01hdGNoZXNTZWxlY3Rvcnx8by5vTWF0Y2hlc1NlbGVjdG9yO2UuZXhwb3J0cz1yfSx7fV0sMzpbZnVuY3Rpb24odCxlLG4pe2Z1bmN0aW9uIHIodCxlLG4scil7dmFyIGk9by5hcHBseSh0aGlzLGFyZ3VtZW50cyk7cmV0dXJuIHQuYWRkRXZlbnRMaXN0ZW5lcihuLGkpLHtkZXN0cm95OmZ1bmN0aW9uKCl7dC5yZW1vdmVFdmVudExpc3RlbmVyKG4saSl9fX1mdW5jdGlvbiBvKHQsZSxuLHIpe3JldHVybiBmdW5jdGlvbihuKXtuLmRlbGVnYXRlVGFyZ2V0PWkobi50YXJnZXQsZSwhMCksbi5kZWxlZ2F0ZVRhcmdldCYmci5jYWxsKHQsbil9fXZhciBpPXQoXCJjbG9zZXN0XCIpO2UuZXhwb3J0cz1yfSx7Y2xvc2VzdDoxfV0sNDpbZnVuY3Rpb24odCxlLG4pe24ubm9kZT1mdW5jdGlvbih0KXtyZXR1cm4gdm9pZCAwIT09dCYmdCBpbnN0YW5jZW9mIEhUTUxFbGVtZW50JiYxPT09dC5ub2RlVHlwZX0sbi5ub2RlTGlzdD1mdW5jdGlvbih0KXt2YXIgZT1PYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodCk7cmV0dXJuIHZvaWQgMCE9PXQmJihcIltvYmplY3QgTm9kZUxpc3RdXCI9PT1lfHxcIltvYmplY3QgSFRNTENvbGxlY3Rpb25dXCI9PT1lKSYmXCJsZW5ndGhcImluIHQmJigwPT09dC5sZW5ndGh8fG4ubm9kZSh0WzBdKSl9LG4uc3RyaW5nPWZ1bmN0aW9uKHQpe3JldHVyblwic3RyaW5nXCI9PXR5cGVvZiB0fHx0IGluc3RhbmNlb2YgU3RyaW5nfSxuLmZ1bmN0aW9uPWZ1bmN0aW9uKHQpe3ZhciBlPU9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh0KTtyZXR1cm5cIltvYmplY3QgRnVuY3Rpb25dXCI9PT1lfX0se31dLDU6W2Z1bmN0aW9uKHQsZSxuKXtmdW5jdGlvbiByKHQsZSxuKXtpZighdCYmIWUmJiFuKXRocm93IG5ldyBFcnJvcihcIk1pc3NpbmcgcmVxdWlyZWQgYXJndW1lbnRzXCIpO2lmKCFjLnN0cmluZyhlKSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiU2Vjb25kIGFyZ3VtZW50IG11c3QgYmUgYSBTdHJpbmdcIik7aWYoIWMuZnVuY3Rpb24obikpdGhyb3cgbmV3IFR5cGVFcnJvcihcIlRoaXJkIGFyZ3VtZW50IG11c3QgYmUgYSBGdW5jdGlvblwiKTtpZihjLm5vZGUodCkpcmV0dXJuIG8odCxlLG4pO2lmKGMubm9kZUxpc3QodCkpcmV0dXJuIGkodCxlLG4pO2lmKGMuc3RyaW5nKHQpKXJldHVybiBhKHQsZSxuKTt0aHJvdyBuZXcgVHlwZUVycm9yKFwiRmlyc3QgYXJndW1lbnQgbXVzdCBiZSBhIFN0cmluZywgSFRNTEVsZW1lbnQsIEhUTUxDb2xsZWN0aW9uLCBvciBOb2RlTGlzdFwiKX1mdW5jdGlvbiBvKHQsZSxuKXtyZXR1cm4gdC5hZGRFdmVudExpc3RlbmVyKGUsbikse2Rlc3Ryb3k6ZnVuY3Rpb24oKXt0LnJlbW92ZUV2ZW50TGlzdGVuZXIoZSxuKX19fWZ1bmN0aW9uIGkodCxlLG4pe3JldHVybiBBcnJheS5wcm90b3R5cGUuZm9yRWFjaC5jYWxsKHQsZnVuY3Rpb24odCl7dC5hZGRFdmVudExpc3RlbmVyKGUsbil9KSx7ZGVzdHJveTpmdW5jdGlvbigpe0FycmF5LnByb3RvdHlwZS5mb3JFYWNoLmNhbGwodCxmdW5jdGlvbih0KXt0LnJlbW92ZUV2ZW50TGlzdGVuZXIoZSxuKX0pfX19ZnVuY3Rpb24gYSh0LGUsbil7cmV0dXJuIHMoZG9jdW1lbnQuYm9keSx0LGUsbil9dmFyIGM9dChcIi4vaXNcIikscz10KFwiZGVsZWdhdGVcIik7ZS5leHBvcnRzPXJ9LHtcIi4vaXNcIjo0LGRlbGVnYXRlOjN9XSw2OltmdW5jdGlvbih0LGUsbil7ZnVuY3Rpb24gcih0KXt2YXIgZTtpZihcIklOUFVUXCI9PT10Lm5vZGVOYW1lfHxcIlRFWFRBUkVBXCI9PT10Lm5vZGVOYW1lKXQuZm9jdXMoKSx0LnNldFNlbGVjdGlvblJhbmdlKDAsdC52YWx1ZS5sZW5ndGgpLGU9dC52YWx1ZTtlbHNle3QuaGFzQXR0cmlidXRlKFwiY29udGVudGVkaXRhYmxlXCIpJiZ0LmZvY3VzKCk7dmFyIG49d2luZG93LmdldFNlbGVjdGlvbigpLHI9ZG9jdW1lbnQuY3JlYXRlUmFuZ2UoKTtyLnNlbGVjdE5vZGVDb250ZW50cyh0KSxuLnJlbW92ZUFsbFJhbmdlcygpLG4uYWRkUmFuZ2UociksZT1uLnRvU3RyaW5nKCl9cmV0dXJuIGV9ZS5leHBvcnRzPXJ9LHt9XSw3OltmdW5jdGlvbih0LGUsbil7ZnVuY3Rpb24gcigpe31yLnByb3RvdHlwZT17b246ZnVuY3Rpb24odCxlLG4pe3ZhciByPXRoaXMuZXx8KHRoaXMuZT17fSk7cmV0dXJuKHJbdF18fChyW3RdPVtdKSkucHVzaCh7Zm46ZSxjdHg6bn0pLHRoaXN9LG9uY2U6ZnVuY3Rpb24odCxlLG4pe2Z1bmN0aW9uIHIoKXtvLm9mZih0LHIpLGUuYXBwbHkobixhcmd1bWVudHMpfXZhciBvPXRoaXM7cmV0dXJuIHIuXz1lLHRoaXMub24odCxyLG4pfSxlbWl0OmZ1bmN0aW9uKHQpe3ZhciBlPVtdLnNsaWNlLmNhbGwoYXJndW1lbnRzLDEpLG49KCh0aGlzLmV8fCh0aGlzLmU9e30pKVt0XXx8W10pLnNsaWNlKCkscj0wLG89bi5sZW5ndGg7Zm9yKHI7bz5yO3IrKyluW3JdLmZuLmFwcGx5KG5bcl0uY3R4LGUpO3JldHVybiB0aGlzfSxvZmY6ZnVuY3Rpb24odCxlKXt2YXIgbj10aGlzLmV8fCh0aGlzLmU9e30pLHI9blt0XSxvPVtdO2lmKHImJmUpZm9yKHZhciBpPTAsYT1yLmxlbmd0aDthPmk7aSsrKXJbaV0uZm4hPT1lJiZyW2ldLmZuLl8hPT1lJiZvLnB1c2gocltpXSk7cmV0dXJuIG8ubGVuZ3RoP25bdF09bzpkZWxldGUgblt0XSx0aGlzfX0sZS5leHBvcnRzPXJ9LHt9XSw4OltmdW5jdGlvbih0LGUsbil7XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gcih0KXtyZXR1cm4gdCYmdC5fX2VzTW9kdWxlP3Q6e1wiZGVmYXVsdFwiOnR9fWZ1bmN0aW9uIG8odCxlKXtpZighKHQgaW5zdGFuY2VvZiBlKSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpfW4uX19lc01vZHVsZT0hMDt2YXIgaT1mdW5jdGlvbigpe2Z1bmN0aW9uIHQodCxlKXtmb3IodmFyIG49MDtuPGUubGVuZ3RoO24rKyl7dmFyIHI9ZVtuXTtyLmVudW1lcmFibGU9ci5lbnVtZXJhYmxlfHwhMSxyLmNvbmZpZ3VyYWJsZT0hMCxcInZhbHVlXCJpbiByJiYoci53cml0YWJsZT0hMCksT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsci5rZXkscil9fXJldHVybiBmdW5jdGlvbihlLG4scil7cmV0dXJuIG4mJnQoZS5wcm90b3R5cGUsbiksciYmdChlLHIpLGV9fSgpLGE9dChcInNlbGVjdFwiKSxjPXIoYSkscz1mdW5jdGlvbigpe2Z1bmN0aW9uIHQoZSl7byh0aGlzLHQpLHRoaXMucmVzb2x2ZU9wdGlvbnMoZSksdGhpcy5pbml0U2VsZWN0aW9uKCl9cmV0dXJuIHQucHJvdG90eXBlLnJlc29sdmVPcHRpb25zPWZ1bmN0aW9uIHQoKXt2YXIgZT1hcmd1bWVudHMubGVuZ3RoPD0wfHx2b2lkIDA9PT1hcmd1bWVudHNbMF0/e306YXJndW1lbnRzWzBdO3RoaXMuYWN0aW9uPWUuYWN0aW9uLHRoaXMuZW1pdHRlcj1lLmVtaXR0ZXIsdGhpcy50YXJnZXQ9ZS50YXJnZXQsdGhpcy50ZXh0PWUudGV4dCx0aGlzLnRyaWdnZXI9ZS50cmlnZ2VyLHRoaXMuc2VsZWN0ZWRUZXh0PVwiXCJ9LHQucHJvdG90eXBlLmluaXRTZWxlY3Rpb249ZnVuY3Rpb24gdCgpe2lmKHRoaXMudGV4dCYmdGhpcy50YXJnZXQpdGhyb3cgbmV3IEVycm9yKCdNdWx0aXBsZSBhdHRyaWJ1dGVzIGRlY2xhcmVkLCB1c2UgZWl0aGVyIFwidGFyZ2V0XCIgb3IgXCJ0ZXh0XCInKTtpZih0aGlzLnRleHQpdGhpcy5zZWxlY3RGYWtlKCk7ZWxzZXtpZighdGhpcy50YXJnZXQpdGhyb3cgbmV3IEVycm9yKCdNaXNzaW5nIHJlcXVpcmVkIGF0dHJpYnV0ZXMsIHVzZSBlaXRoZXIgXCJ0YXJnZXRcIiBvciBcInRleHRcIicpO3RoaXMuc2VsZWN0VGFyZ2V0KCl9fSx0LnByb3RvdHlwZS5zZWxlY3RGYWtlPWZ1bmN0aW9uIHQoKXt2YXIgZT10aGlzO3RoaXMucmVtb3ZlRmFrZSgpLHRoaXMuZmFrZUhhbmRsZXI9ZG9jdW1lbnQuYm9keS5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIixmdW5jdGlvbigpe3JldHVybiBlLnJlbW92ZUZha2UoKX0pLHRoaXMuZmFrZUVsZW09ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInRleHRhcmVhXCIpLHRoaXMuZmFrZUVsZW0uc3R5bGUucG9zaXRpb249XCJhYnNvbHV0ZVwiLHRoaXMuZmFrZUVsZW0uc3R5bGUubGVmdD1cIi05OTk5cHhcIix0aGlzLmZha2VFbGVtLnN0eWxlLnRvcD0od2luZG93LnBhZ2VZT2Zmc2V0fHxkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsVG9wKStcInB4XCIsdGhpcy5mYWtlRWxlbS5zZXRBdHRyaWJ1dGUoXCJyZWFkb25seVwiLFwiXCIpLHRoaXMuZmFrZUVsZW0udmFsdWU9dGhpcy50ZXh0LGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQodGhpcy5mYWtlRWxlbSksdGhpcy5zZWxlY3RlZFRleHQ9Yy5kZWZhdWx0KHRoaXMuZmFrZUVsZW0pLHRoaXMuY29weVRleHQoKX0sdC5wcm90b3R5cGUucmVtb3ZlRmFrZT1mdW5jdGlvbiB0KCl7dGhpcy5mYWtlSGFuZGxlciYmKGRvY3VtZW50LmJvZHkucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIpLHRoaXMuZmFrZUhhbmRsZXI9bnVsbCksdGhpcy5mYWtlRWxlbSYmKGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQodGhpcy5mYWtlRWxlbSksdGhpcy5mYWtlRWxlbT1udWxsKX0sdC5wcm90b3R5cGUuc2VsZWN0VGFyZ2V0PWZ1bmN0aW9uIHQoKXt0aGlzLnNlbGVjdGVkVGV4dD1jLmRlZmF1bHQodGhpcy50YXJnZXQpLHRoaXMuY29weVRleHQoKX0sdC5wcm90b3R5cGUuY29weVRleHQ9ZnVuY3Rpb24gdCgpe3ZhciBlPXZvaWQgMDt0cnl7ZT1kb2N1bWVudC5leGVjQ29tbWFuZCh0aGlzLmFjdGlvbil9Y2F0Y2gobil7ZT0hMX10aGlzLmhhbmRsZVJlc3VsdChlKX0sdC5wcm90b3R5cGUuaGFuZGxlUmVzdWx0PWZ1bmN0aW9uIHQoZSl7ZT90aGlzLmVtaXR0ZXIuZW1pdChcInN1Y2Nlc3NcIix7YWN0aW9uOnRoaXMuYWN0aW9uLHRleHQ6dGhpcy5zZWxlY3RlZFRleHQsdHJpZ2dlcjp0aGlzLnRyaWdnZXIsY2xlYXJTZWxlY3Rpb246dGhpcy5jbGVhclNlbGVjdGlvbi5iaW5kKHRoaXMpfSk6dGhpcy5lbWl0dGVyLmVtaXQoXCJlcnJvclwiLHthY3Rpb246dGhpcy5hY3Rpb24sdHJpZ2dlcjp0aGlzLnRyaWdnZXIsY2xlYXJTZWxlY3Rpb246dGhpcy5jbGVhclNlbGVjdGlvbi5iaW5kKHRoaXMpfSl9LHQucHJvdG90eXBlLmNsZWFyU2VsZWN0aW9uPWZ1bmN0aW9uIHQoKXt0aGlzLnRhcmdldCYmdGhpcy50YXJnZXQuYmx1cigpLHdpbmRvdy5nZXRTZWxlY3Rpb24oKS5yZW1vdmVBbGxSYW5nZXMoKX0sdC5wcm90b3R5cGUuZGVzdHJveT1mdW5jdGlvbiB0KCl7dGhpcy5yZW1vdmVGYWtlKCl9LGkodCxbe2tleTpcImFjdGlvblwiLHNldDpmdW5jdGlvbiB0KCl7dmFyIGU9YXJndW1lbnRzLmxlbmd0aDw9MHx8dm9pZCAwPT09YXJndW1lbnRzWzBdP1wiY29weVwiOmFyZ3VtZW50c1swXTtpZih0aGlzLl9hY3Rpb249ZSxcImNvcHlcIiE9PXRoaXMuX2FjdGlvbiYmXCJjdXRcIiE9PXRoaXMuX2FjdGlvbil0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgXCJhY3Rpb25cIiB2YWx1ZSwgdXNlIGVpdGhlciBcImNvcHlcIiBvciBcImN1dFwiJyl9LGdldDpmdW5jdGlvbiB0KCl7cmV0dXJuIHRoaXMuX2FjdGlvbn19LHtrZXk6XCJ0YXJnZXRcIixzZXQ6ZnVuY3Rpb24gdChlKXtpZih2b2lkIDAhPT1lKXtpZighZXx8XCJvYmplY3RcIiE9dHlwZW9mIGV8fDEhPT1lLm5vZGVUeXBlKXRocm93IG5ldyBFcnJvcignSW52YWxpZCBcInRhcmdldFwiIHZhbHVlLCB1c2UgYSB2YWxpZCBFbGVtZW50Jyk7dGhpcy5fdGFyZ2V0PWV9fSxnZXQ6ZnVuY3Rpb24gdCgpe3JldHVybiB0aGlzLl90YXJnZXR9fV0pLHR9KCk7bi5kZWZhdWx0PXMsZS5leHBvcnRzPW4uZGVmYXVsdH0se3NlbGVjdDo2fV0sOTpbZnVuY3Rpb24odCxlLG4pe1widXNlIHN0cmljdFwiO2Z1bmN0aW9uIHIodCl7cmV0dXJuIHQmJnQuX19lc01vZHVsZT90OntcImRlZmF1bHRcIjp0fX1mdW5jdGlvbiBvKHQsZSl7aWYoISh0IGluc3RhbmNlb2YgZSkpdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKX1mdW5jdGlvbiBpKHQsZSl7aWYoXCJmdW5jdGlvblwiIT10eXBlb2YgZSYmbnVsbCE9PWUpdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIrdHlwZW9mIGUpO3QucHJvdG90eXBlPU9iamVjdC5jcmVhdGUoZSYmZS5wcm90b3R5cGUse2NvbnN0cnVjdG9yOnt2YWx1ZTp0LGVudW1lcmFibGU6ITEsd3JpdGFibGU6ITAsY29uZmlndXJhYmxlOiEwfX0pLGUmJihPYmplY3Quc2V0UHJvdG90eXBlT2Y/T2JqZWN0LnNldFByb3RvdHlwZU9mKHQsZSk6dC5fX3Byb3RvX189ZSl9ZnVuY3Rpb24gYSh0LGUpe3ZhciBuPVwiZGF0YS1jbGlwYm9hcmQtXCIrdDtpZihlLmhhc0F0dHJpYnV0ZShuKSlyZXR1cm4gZS5nZXRBdHRyaWJ1dGUobil9bi5fX2VzTW9kdWxlPSEwO3ZhciBjPXQoXCIuL2NsaXBib2FyZC1hY3Rpb25cIikscz1yKGMpLHU9dChcInRpbnktZW1pdHRlclwiKSxsPXIodSksZj10KFwiZ29vZC1saXN0ZW5lclwiKSxkPXIoZiksaD1mdW5jdGlvbih0KXtmdW5jdGlvbiBlKG4scil7byh0aGlzLGUpLHQuY2FsbCh0aGlzKSx0aGlzLnJlc29sdmVPcHRpb25zKHIpLHRoaXMubGlzdGVuQ2xpY2sobil9cmV0dXJuIGkoZSx0KSxlLnByb3RvdHlwZS5yZXNvbHZlT3B0aW9ucz1mdW5jdGlvbiB0KCl7dmFyIGU9YXJndW1lbnRzLmxlbmd0aDw9MHx8dm9pZCAwPT09YXJndW1lbnRzWzBdP3t9OmFyZ3VtZW50c1swXTt0aGlzLmFjdGlvbj1cImZ1bmN0aW9uXCI9PXR5cGVvZiBlLmFjdGlvbj9lLmFjdGlvbjp0aGlzLmRlZmF1bHRBY3Rpb24sdGhpcy50YXJnZXQ9XCJmdW5jdGlvblwiPT10eXBlb2YgZS50YXJnZXQ/ZS50YXJnZXQ6dGhpcy5kZWZhdWx0VGFyZ2V0LHRoaXMudGV4dD1cImZ1bmN0aW9uXCI9PXR5cGVvZiBlLnRleHQ/ZS50ZXh0OnRoaXMuZGVmYXVsdFRleHR9LGUucHJvdG90eXBlLmxpc3RlbkNsaWNrPWZ1bmN0aW9uIHQoZSl7dmFyIG49dGhpczt0aGlzLmxpc3RlbmVyPWQuZGVmYXVsdChlLFwiY2xpY2tcIixmdW5jdGlvbih0KXtyZXR1cm4gbi5vbkNsaWNrKHQpfSl9LGUucHJvdG90eXBlLm9uQ2xpY2s9ZnVuY3Rpb24gdChlKXt2YXIgbj1lLmRlbGVnYXRlVGFyZ2V0fHxlLmN1cnJlbnRUYXJnZXQ7dGhpcy5jbGlwYm9hcmRBY3Rpb24mJih0aGlzLmNsaXBib2FyZEFjdGlvbj1udWxsKSx0aGlzLmNsaXBib2FyZEFjdGlvbj1uZXcgcy5kZWZhdWx0KHthY3Rpb246dGhpcy5hY3Rpb24obiksdGFyZ2V0OnRoaXMudGFyZ2V0KG4pLHRleHQ6dGhpcy50ZXh0KG4pLHRyaWdnZXI6bixlbWl0dGVyOnRoaXN9KX0sZS5wcm90b3R5cGUuZGVmYXVsdEFjdGlvbj1mdW5jdGlvbiB0KGUpe3JldHVybiBhKFwiYWN0aW9uXCIsZSl9LGUucHJvdG90eXBlLmRlZmF1bHRUYXJnZXQ9ZnVuY3Rpb24gdChlKXt2YXIgbj1hKFwidGFyZ2V0XCIsZSk7cmV0dXJuIG4/ZG9jdW1lbnQucXVlcnlTZWxlY3RvcihuKTp2b2lkIDB9LGUucHJvdG90eXBlLmRlZmF1bHRUZXh0PWZ1bmN0aW9uIHQoZSl7cmV0dXJuIGEoXCJ0ZXh0XCIsZSl9LGUucHJvdG90eXBlLmRlc3Ryb3k9ZnVuY3Rpb24gdCgpe3RoaXMubGlzdGVuZXIuZGVzdHJveSgpLHRoaXMuY2xpcGJvYXJkQWN0aW9uJiYodGhpcy5jbGlwYm9hcmRBY3Rpb24uZGVzdHJveSgpLHRoaXMuY2xpcGJvYXJkQWN0aW9uPW51bGwpfSxlfShsLmRlZmF1bHQpO24uZGVmYXVsdD1oLGUuZXhwb3J0cz1uLmRlZmF1bHR9LHtcIi4vY2xpcGJvYXJkLWFjdGlvblwiOjgsXCJnb29kLWxpc3RlbmVyXCI6NSxcInRpbnktZW1pdHRlclwiOjd9XX0se30sWzldKSg5KX0pO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NjcmlwdHMvdmVuZG9ycy9jbGlwYm9hcmQuanMiLCJtb2R1bGUuZXhwb3J0cyA9IGdsb2JhbFtcIkNsaXBib2FyZFwiXSA9IHJlcXVpcmUoXCItIUQ6XFxcXHRpY2tldG1hc3RlclxcXFx0aWNrZXRtYXN0ZXItYXBpLXN0YWdpbmcuZ2l0aHViLmlvXFxcXG5vZGVfbW9kdWxlc1xcXFxiYWJlbC1sb2FkZXJcXFxcbGliXFxcXGluZGV4LmpzPz9yZWYtLTAhLlxcXFxjbGlwYm9hcmQuanNcIik7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2V4cG9zZS1sb2FkZXI/Q2xpcGJvYXJkIS4vc2NyaXB0cy92ZW5kb3JzL2NsaXBib2FyZC5qc1xuLy8gbW9kdWxlIGlkID0gNTdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSB7XG5cdFwiQ291bnRyeUNvZGVcIjogW1xuXHRcdFwiVVMgKFVuaXRlZCBTdGF0ZXMgT2YgQW1lcmljYSlcIixcblx0XHRcIkFEIChBbmRvcnJhKVwiLFxuXHRcdFwiQUkgKEFuZ3VpbGxhKVwiLFxuXHRcdFwiQVIgKEFyZ2VudGluYSlcIixcblx0XHRcIkFVIChBdXN0cmFsaWEpXCIsXG5cdFx0XCJBVCAoQXVzdHJpYSlcIixcblx0XHRcIkFaIChBemVyYmFpamFuKVwiLFxuXHRcdFwiQlMgKEJhaGFtYXMpXCIsXG5cdFx0XCJCSCAoQmFocmFpbilcIixcblx0XHRcIkJCIChCYXJiYWRvcylcIixcblx0XHRcIkJFIChCZWxnaXVtKVwiLFxuXHRcdFwiQk0gKEJlcm11ZGEpXCIsXG5cdFx0XCJCUiAoQnJhemlsKVwiLFxuXHRcdFwiQkcgKEJ1bGdhcmlhKVwiLFxuXHRcdFwiQ0EgKENhbmFkYSlcIixcblx0XHRcIkNMIChDaGlsZSlcIixcblx0XHRcIkNOIChDaGluYSlcIixcblx0XHRcIkNPIChDb2xvbWJpYSlcIixcblx0XHRcIkNSIChDb3N0YSBSaWNhKVwiLFxuXHRcdFwiSFIgKENyb2F0aWEpXCIsXG5cdFx0XCJDWSAoQ3lwcnVzKVwiLFxuXHRcdFwiQ1ogKEN6ZWNoIFJlcHVibGljKVwiLFxuXHRcdFwiREsgKERlbm1hcmspXCIsXG5cdFx0XCJETyAoRG9taW5pY2FuIFJlcHVibGljKVwiLFxuXHRcdFwiRUMgKEVjdWFkb3IpXCIsXG5cdFx0XCJFRSAoRXN0b25pYSlcIixcblx0XHRcIkZPIChGYXJvZSBJc2xhbmRzKVwiLFxuXHRcdFwiRkkgKEZpbmxhbmQpXCIsXG5cdFx0XCJGUiAoRnJhbmNlKVwiLFxuXHRcdFwiR0UgKEdlb3JnaWEpXCIsXG5cdFx0XCJERSAoR2VybWFueSlcIixcblx0XHRcIkdIIChHaGFuYSlcIixcblx0XHRcIkdJIChHaWJyYWx0YXIpXCIsXG5cdFx0XCJHQiAoR3JlYXQgQnJpdGFpbilcIixcblx0XHRcIkdSIChHcmVlY2UpXCIsXG5cdFx0XCJISyAoSG9uZyBLb25nKVwiLFxuXHRcdFwiSFUgKEh1bmdhcnkpXCIsXG5cdFx0XCJJUyAoSWNlbGFuZClcIixcblx0XHRcIklOIChJbmRpYSlcIixcblx0XHRcIklFIChJcmVsYW5kKVwiLFxuXHRcdFwiSUwgKElzcmFlbClcIixcblx0XHRcIklUIChJdGFseSlcIixcblx0XHRcIkpNIChKYW1haWNhKVwiLFxuXHRcdFwiSlAgKEphcGFuKVwiLFxuXHRcdFwiS1IgKEtvcmVhLCBSZXB1YmxpYyBvZilcIixcblx0XHRcIkxWIChMYXR2aWEpXCIsXG5cdFx0XCJMQiAoTGViYW5vbilcIixcblx0XHRcIkxUIChMaXRodWFuaWEpXCIsXG5cdFx0XCJMVSAoTHV4ZW1ib3VyZylcIixcblx0XHRcIk1ZIChNYWxheXNpYSlcIixcblx0XHRcIk1UIChNYWx0YSlcIixcblx0XHRcIk1YIChNZXhpY28pXCIsXG5cdFx0XCJNQyAoTW9uYWNvKVwiLFxuXHRcdFwiTUUgKE1vbnRlbmVncm8pXCIsXG5cdFx0XCJNQSAoTW9yb2NjbylcIixcblx0XHRcIk5MIChOZXRoZXJsYW5kcylcIixcblx0XHRcIkFOIChOZXRoZXJsYW5kcyBBbnRpbGxlcylcIixcblx0XHRcIk5aIChOZXcgWmVhbGFuZClcIixcblx0XHRcIk5EIChOb3J0aGVybiBJcmVsYW5kKVwiLFxuXHRcdFwiTk8gKE5vcndheSlcIixcblx0XHRcIlBFIChQZXJ1KVwiLFxuXHRcdFwiUEwgKFBvbGFuZClcIixcblx0XHRcIlBUIChQb3J0dWdhbClcIixcblx0XHRcIlJPIChSb21hbmlhKVwiLFxuXHRcdFwiUlUgKFJ1c3NpYW4gRmVkZXJhdGlvbilcIixcblx0XHRcIkxDIChTYWludCBMdWNpYSlcIixcblx0XHRcIlNBIChTYXVkaSBBcmFiaWEpXCIsXG5cdFx0XCJSUyAoU2VyYmlhKVwiLFxuXHRcdFwiU0cgKFNpbmdhcG9yZSlcIixcblx0XHRcIlNLIChTbG92YWtpYSlcIixcblx0XHRcIlNJIChTbG92ZW5pYSlcIixcblx0XHRcIlpBIChTb3V0aCBBZnJpY2EpXCIsXG5cdFx0XCJFUyAoU3BhaW4pXCIsXG5cdFx0XCJTRSAoU3dlZGVuKVwiLFxuXHRcdFwiQ0ggKFN3aXR6ZXJsYW5kKVwiLFxuXHRcdFwiVFcgKFRhaXdhbilcIixcblx0XHRcIlRIIChUaGFpbGFuZClcIixcblx0XHRcIlRUIChUcmluaWRhZCBhbmQgVG9iYWdvKVwiLFxuXHRcdFwiVFIgKFR1cmtleSlcIixcblx0XHRcIlVBIChVa3JhaW5lKVwiLFxuXHRcdFwiQUUgKFVuaXRlZCBBcmFiIEVtaXJhdGVzKVwiLFxuXHRcdFwiVVkgKFVydWd1YXkpXCIsXG5cdFx0XCJWRSAoVmVuZXp1ZWxhKVwiXG5cdF1cbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9fZGF0YS9vcmdzL2Rpc2NvdmVyeS1hcGkvdjIvY291bnRyeUNvZGUuanNvblxuLy8gbW9kdWxlIGlkID0gNThcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLypnbG9iYWxzIGpRdWVyeSwgZGVmaW5lLCBtb2R1bGUsIGV4cG9ydHMsIHJlcXVpcmUsIHdpbmRvdywgZG9jdW1lbnQsIHBvc3RNZXNzYWdlICovXG4oZnVuY3Rpb24gKGZhY3RvcnkpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cdGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIHtcblx0XHRkZWZpbmUoWydqcXVlcnknXSwgZmFjdG9yeSk7XG5cdH1cblx0ZWxzZSBpZih0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyAmJiBtb2R1bGUuZXhwb3J0cykge1xuXHRcdG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeShyZXF1aXJlKCdqcXVlcnknKSk7XG5cdH1cblx0ZWxzZSB7XG5cdFx0ZmFjdG9yeShqUXVlcnkpO1xuXHR9XG59KGZ1bmN0aW9uICgkLCB1bmRlZmluZWQpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG4vKiFcbiAqIGpzVHJlZSAzLjMuM1xuICogaHR0cDovL2pzdHJlZS5jb20vXG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDE0IEl2YW4gQm96aGFub3YgKGh0dHA6Ly92YWthdGEuY29tKVxuICpcbiAqIExpY2Vuc2VkIHNhbWUgYXMganF1ZXJ5IC0gdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBNSVQgTGljZW5zZVxuICogICBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocFxuICovXG4vKiFcbiAqIGlmIHVzaW5nIGpzbGludCBwbGVhc2UgYWxsb3cgZm9yIHRoZSBqUXVlcnkgZ2xvYmFsIGFuZCB1c2UgZm9sbG93aW5nIG9wdGlvbnM6XG4gKiBqc2xpbnQ6IGxvb3BmdW5jOiB0cnVlLCBicm93c2VyOiB0cnVlLCBhc3M6IHRydWUsIGJpdHdpc2U6IHRydWUsIGNvbnRpbnVlOiB0cnVlLCBub21lbjogdHJ1ZSwgcGx1c3BsdXM6IHRydWUsIHJlZ2V4cDogdHJ1ZSwgdW5wYXJhbTogdHJ1ZSwgdG9kbzogdHJ1ZSwgd2hpdGU6IHRydWVcbiAqL1xuLypqc2hpbnQgLVcwODMgKi9cblxuXHQvLyBwcmV2ZW50IGFub3RoZXIgbG9hZD8gbWF5YmUgdGhlcmUgaXMgYSBiZXR0ZXIgd2F5P1xuXHRpZigkLmpzdHJlZSkge1xuXHRcdHJldHVybjtcblx0fVxuXG5cdC8qKlxuXHQgKiAjIyMganNUcmVlIGNvcmUgZnVuY3Rpb25hbGl0eVxuXHQgKi9cblxuXHQvLyBpbnRlcm5hbCB2YXJpYWJsZXNcblx0dmFyIGluc3RhbmNlX2NvdW50ZXIgPSAwLFxuXHRcdGNjcF9ub2RlID0gZmFsc2UsXG5cdFx0Y2NwX21vZGUgPSBmYWxzZSxcblx0XHRjY3BfaW5zdCA9IGZhbHNlLFxuXHRcdHRoZW1lc19sb2FkZWQgPSBbXSxcblx0XHRzcmMgPSAkKCdzY3JpcHQ6bGFzdCcpLmF0dHIoJ3NyYycpLFxuXHRcdGRvY3VtZW50ID0gd2luZG93LmRvY3VtZW50OyAvLyBsb2NhbCB2YXJpYWJsZSBpcyBhbHdheXMgZmFzdGVyIHRvIGFjY2VzcyB0aGVuIGEgZ2xvYmFsXG5cblx0LyoqXG5cdCAqIGhvbGRzIGFsbCBqc3RyZWUgcmVsYXRlZCBmdW5jdGlvbnMgYW5kIHZhcmlhYmxlcywgaW5jbHVkaW5nIHRoZSBhY3R1YWwgY2xhc3MgYW5kIG1ldGhvZHMgdG8gY3JlYXRlLCBhY2Nlc3MgYW5kIG1hbmlwdWxhdGUgaW5zdGFuY2VzLlxuXHQgKiBAbmFtZSAkLmpzdHJlZVxuXHQgKi9cblx0JC5qc3RyZWUgPSB7XG5cdFx0LyoqXG5cdFx0ICogc3BlY2lmaWVzIHRoZSBqc3RyZWUgdmVyc2lvbiBpbiB1c2Vcblx0XHQgKiBAbmFtZSAkLmpzdHJlZS52ZXJzaW9uXG5cdFx0ICovXG5cdFx0dmVyc2lvbiA6ICczLjMuMycsXG5cdFx0LyoqXG5cdFx0ICogaG9sZHMgYWxsIHRoZSBkZWZhdWx0IG9wdGlvbnMgdXNlZCB3aGVuIGNyZWF0aW5nIG5ldyBpbnN0YW5jZXNcblx0XHQgKiBAbmFtZSAkLmpzdHJlZS5kZWZhdWx0c1xuXHRcdCAqL1xuXHRcdGRlZmF1bHRzIDoge1xuXHRcdFx0LyoqXG5cdFx0XHQgKiBjb25maWd1cmUgd2hpY2ggcGx1Z2lucyB3aWxsIGJlIGFjdGl2ZSBvbiBhbiBpbnN0YW5jZS4gU2hvdWxkIGJlIGFuIGFycmF5IG9mIHN0cmluZ3MsIHdoZXJlIGVhY2ggZWxlbWVudCBpcyBhIHBsdWdpbiBuYW1lLiBUaGUgZGVmYXVsdCBpcyBgW11gXG5cdFx0XHQgKiBAbmFtZSAkLmpzdHJlZS5kZWZhdWx0cy5wbHVnaW5zXG5cdFx0XHQgKi9cblx0XHRcdHBsdWdpbnMgOiBbXVxuXHRcdH0sXG5cdFx0LyoqXG5cdFx0ICogc3RvcmVzIGFsbCBsb2FkZWQganN0cmVlIHBsdWdpbnMgKHVzZWQgaW50ZXJuYWxseSlcblx0XHQgKiBAbmFtZSAkLmpzdHJlZS5wbHVnaW5zXG5cdFx0ICovXG5cdFx0cGx1Z2lucyA6IHt9LFxuXHRcdHBhdGggOiBzcmMgJiYgc3JjLmluZGV4T2YoJy8nKSAhPT0gLTEgPyBzcmMucmVwbGFjZSgvXFwvW15cXC9dKyQvLCcnKSA6ICcnLFxuXHRcdGlkcmVnZXggOiAvW1xcXFw6JiFefCgpXFxbXFxdPD5AKicrfiNcIjsuLD1cXC0gXFwvJHt9JT9gXS9nLFxuXHRcdHJvb3QgOiAnIydcblx0fTtcblx0XG5cdC8qKlxuXHQgKiBjcmVhdGVzIGEganN0cmVlIGluc3RhbmNlXG5cdCAqIEBuYW1lICQuanN0cmVlLmNyZWF0ZShlbCBbLCBvcHRpb25zXSlcblx0ICogQHBhcmFtIHtET01FbGVtZW50fGpRdWVyeXxTdHJpbmd9IGVsIHRoZSBlbGVtZW50IHRvIGNyZWF0ZSB0aGUgaW5zdGFuY2Ugb24sIGNhbiBiZSBqUXVlcnkgZXh0ZW5kZWQgb3IgYSBzZWxlY3RvclxuXHQgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBvcHRpb25zIGZvciB0aGlzIGluc3RhbmNlIChleHRlbmRzIGAkLmpzdHJlZS5kZWZhdWx0c2ApXG5cdCAqIEByZXR1cm4ge2pzVHJlZX0gdGhlIG5ldyBpbnN0YW5jZVxuXHQgKi9cblx0JC5qc3RyZWUuY3JlYXRlID0gZnVuY3Rpb24gKGVsLCBvcHRpb25zKSB7XG5cdFx0dmFyIHRtcCA9IG5ldyAkLmpzdHJlZS5jb3JlKCsraW5zdGFuY2VfY291bnRlciksXG5cdFx0XHRvcHQgPSBvcHRpb25zO1xuXHRcdG9wdGlvbnMgPSAkLmV4dGVuZCh0cnVlLCB7fSwgJC5qc3RyZWUuZGVmYXVsdHMsIG9wdGlvbnMpO1xuXHRcdGlmKG9wdCAmJiBvcHQucGx1Z2lucykge1xuXHRcdFx0b3B0aW9ucy5wbHVnaW5zID0gb3B0LnBsdWdpbnM7XG5cdFx0fVxuXHRcdCQuZWFjaChvcHRpb25zLnBsdWdpbnMsIGZ1bmN0aW9uIChpLCBrKSB7XG5cdFx0XHRpZihpICE9PSAnY29yZScpIHtcblx0XHRcdFx0dG1wID0gdG1wLnBsdWdpbihrLCBvcHRpb25zW2tdKTtcblx0XHRcdH1cblx0XHR9KTtcblx0XHQkKGVsKS5kYXRhKCdqc3RyZWUnLCB0bXApO1xuXHRcdHRtcC5pbml0KGVsLCBvcHRpb25zKTtcblx0XHRyZXR1cm4gdG1wO1xuXHR9O1xuXHQvKipcblx0ICogcmVtb3ZlIGFsbCB0cmFjZXMgb2YganN0cmVlIGZyb20gdGhlIERPTSBhbmQgZGVzdHJveSBhbGwgaW5zdGFuY2VzXG5cdCAqIEBuYW1lICQuanN0cmVlLmRlc3Ryb3koKVxuXHQgKi9cblx0JC5qc3RyZWUuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcblx0XHQkKCcuanN0cmVlOmpzdHJlZScpLmpzdHJlZSgnZGVzdHJveScpO1xuXHRcdCQoZG9jdW1lbnQpLm9mZignLmpzdHJlZScpO1xuXHR9O1xuXHQvKipcblx0ICogdGhlIGpzdHJlZSBjbGFzcyBjb25zdHJ1Y3RvciwgdXNlZCBvbmx5IGludGVybmFsbHlcblx0ICogQHByaXZhdGVcblx0ICogQG5hbWUgJC5qc3RyZWUuY29yZShpZClcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGlkIHRoaXMgaW5zdGFuY2UncyBpbmRleFxuXHQgKi9cblx0JC5qc3RyZWUuY29yZSA9IGZ1bmN0aW9uIChpZCkge1xuXHRcdHRoaXMuX2lkID0gaWQ7XG5cdFx0dGhpcy5fY250ID0gMDtcblx0XHR0aGlzLl93cmsgPSBudWxsO1xuXHRcdHRoaXMuX2RhdGEgPSB7XG5cdFx0XHRjb3JlIDoge1xuXHRcdFx0XHR0aGVtZXMgOiB7XG5cdFx0XHRcdFx0bmFtZSA6IGZhbHNlLFxuXHRcdFx0XHRcdGRvdHMgOiBmYWxzZSxcblx0XHRcdFx0XHRpY29ucyA6IGZhbHNlLFxuXHRcdFx0XHRcdGVsbGlwc2lzIDogZmFsc2Vcblx0XHRcdFx0fSxcblx0XHRcdFx0c2VsZWN0ZWQgOiBbXSxcblx0XHRcdFx0bGFzdF9lcnJvciA6IHt9LFxuXHRcdFx0XHR3b3JraW5nIDogZmFsc2UsXG5cdFx0XHRcdHdvcmtlcl9xdWV1ZSA6IFtdLFxuXHRcdFx0XHRmb2N1c2VkIDogbnVsbFxuXHRcdFx0fVxuXHRcdH07XG5cdH07XG5cdC8qKlxuXHQgKiBnZXQgYSByZWZlcmVuY2UgdG8gYW4gZXhpc3RpbmcgaW5zdGFuY2Vcblx0ICpcblx0ICogX19FeGFtcGxlc19fXG5cdCAqXG5cdCAqXHQvLyBwcm92aWRlZCBhIGNvbnRhaW5lciB3aXRoIGFuIElEIG9mIFwidHJlZVwiLCBhbmQgYSBuZXN0ZWQgbm9kZSB3aXRoIGFuIElEIG9mIFwiYnJhbmNoXCJcblx0ICpcdC8vIGFsbCBvZiB0aGVyZSB3aWxsIHJldHVybiB0aGUgc2FtZSBpbnN0YW5jZVxuXHQgKlx0JC5qc3RyZWUucmVmZXJlbmNlKCd0cmVlJyk7XG5cdCAqXHQkLmpzdHJlZS5yZWZlcmVuY2UoJyN0cmVlJyk7XG5cdCAqXHQkLmpzdHJlZS5yZWZlcmVuY2UoJCgnI3RyZWUnKSk7XG5cdCAqXHQkLmpzdHJlZS5yZWZlcmVuY2UoZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SUQoJ3RyZWUnKSk7XG5cdCAqXHQkLmpzdHJlZS5yZWZlcmVuY2UoJ2JyYW5jaCcpO1xuXHQgKlx0JC5qc3RyZWUucmVmZXJlbmNlKCcjYnJhbmNoJyk7XG5cdCAqXHQkLmpzdHJlZS5yZWZlcmVuY2UoJCgnI2JyYW5jaCcpKTtcblx0ICpcdCQuanN0cmVlLnJlZmVyZW5jZShkb2N1bWVudC5nZXRFbGVtZW50QnlJRCgnYnJhbmNoJykpO1xuXHQgKlxuXHQgKiBAbmFtZSAkLmpzdHJlZS5yZWZlcmVuY2UobmVlZGxlKVxuXHQgKiBAcGFyYW0ge0RPTUVsZW1lbnR8alF1ZXJ5fFN0cmluZ30gbmVlZGxlXG5cdCAqIEByZXR1cm4ge2pzVHJlZXxudWxsfSB0aGUgaW5zdGFuY2Ugb3IgYG51bGxgIGlmIG5vdCBmb3VuZFxuXHQgKi9cblx0JC5qc3RyZWUucmVmZXJlbmNlID0gZnVuY3Rpb24gKG5lZWRsZSkge1xuXHRcdHZhciB0bXAgPSBudWxsLFxuXHRcdFx0b2JqID0gbnVsbDtcblx0XHRpZihuZWVkbGUgJiYgbmVlZGxlLmlkICYmICghbmVlZGxlLnRhZ05hbWUgfHwgIW5lZWRsZS5ub2RlVHlwZSkpIHsgbmVlZGxlID0gbmVlZGxlLmlkOyB9XG5cblx0XHRpZighb2JqIHx8ICFvYmoubGVuZ3RoKSB7XG5cdFx0XHR0cnkgeyBvYmogPSAkKG5lZWRsZSk7IH0gY2F0Y2ggKGlnbm9yZSkgeyB9XG5cdFx0fVxuXHRcdGlmKCFvYmogfHwgIW9iai5sZW5ndGgpIHtcblx0XHRcdHRyeSB7IG9iaiA9ICQoJyMnICsgbmVlZGxlLnJlcGxhY2UoJC5qc3RyZWUuaWRyZWdleCwnXFxcXCQmJykpOyB9IGNhdGNoIChpZ25vcmUpIHsgfVxuXHRcdH1cblx0XHRpZihvYmogJiYgb2JqLmxlbmd0aCAmJiAob2JqID0gb2JqLmNsb3Nlc3QoJy5qc3RyZWUnKSkubGVuZ3RoICYmIChvYmogPSBvYmouZGF0YSgnanN0cmVlJykpKSB7XG5cdFx0XHR0bXAgPSBvYmo7XG5cdFx0fVxuXHRcdGVsc2Uge1xuXHRcdFx0JCgnLmpzdHJlZScpLmVhY2goZnVuY3Rpb24gKCkge1xuXHRcdFx0XHR2YXIgaW5zdCA9ICQodGhpcykuZGF0YSgnanN0cmVlJyk7XG5cdFx0XHRcdGlmKGluc3QgJiYgaW5zdC5fbW9kZWwuZGF0YVtuZWVkbGVdKSB7XG5cdFx0XHRcdFx0dG1wID0gaW5zdDtcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdH1cblx0XHRyZXR1cm4gdG1wO1xuXHR9O1xuXHQvKipcblx0ICogQ3JlYXRlIGFuIGluc3RhbmNlLCBnZXQgYW4gaW5zdGFuY2Ugb3IgaW52b2tlIGEgY29tbWFuZCBvbiBhIGluc3RhbmNlLlxuXHQgKlxuXHQgKiBJZiB0aGVyZSBpcyBubyBpbnN0YW5jZSBhc3NvY2lhdGVkIHdpdGggdGhlIGN1cnJlbnQgbm9kZSBhIG5ldyBvbmUgaXMgY3JlYXRlZCBhbmQgYGFyZ2AgaXMgdXNlZCB0byBleHRlbmQgYCQuanN0cmVlLmRlZmF1bHRzYCBmb3IgdGhpcyBuZXcgaW5zdGFuY2UuIFRoZXJlIHdvdWxkIGJlIG5vIHJldHVybiB2YWx1ZSAoY2hhaW5pbmcgaXMgbm90IGJyb2tlbikuXG5cdCAqXG5cdCAqIElmIHRoZXJlIGlzIGFuIGV4aXN0aW5nIGluc3RhbmNlIGFuZCBgYXJnYCBpcyBhIHN0cmluZyB0aGUgY29tbWFuZCBzcGVjaWZpZWQgYnkgYGFyZ2AgaXMgZXhlY3V0ZWQgb24gdGhlIGluc3RhbmNlLCB3aXRoIGFueSBhZGRpdGlvbmFsIGFyZ3VtZW50cyBwYXNzZWQgdG8gdGhlIGZ1bmN0aW9uLiBJZiB0aGUgZnVuY3Rpb24gcmV0dXJucyBhIHZhbHVlIGl0IHdpbGwgYmUgcmV0dXJuZWQgKGNoYWluaW5nIGNvdWxkIGJyZWFrIGRlcGVuZGluZyBvbiBmdW5jdGlvbikuXG5cdCAqXG5cdCAqIElmIHRoZXJlIGlzIGFuIGV4aXN0aW5nIGluc3RhbmNlIGFuZCBgYXJnYCBpcyBub3QgYSBzdHJpbmcgdGhlIGluc3RhbmNlIGl0c2VsZiBpcyByZXR1cm5lZCAoc2ltaWxhciB0byBgJC5qc3RyZWUucmVmZXJlbmNlYCkuXG5cdCAqXG5cdCAqIEluIGFueSBvdGhlciBjYXNlIC0gbm90aGluZyBpcyByZXR1cm5lZCBhbmQgY2hhaW5pbmcgaXMgbm90IGJyb2tlbi5cblx0ICpcblx0ICogX19FeGFtcGxlc19fXG5cdCAqXG5cdCAqXHQkKCcjdHJlZTEnKS5qc3RyZWUoKTsgLy8gY3JlYXRlcyBhbiBpbnN0YW5jZVxuXHQgKlx0JCgnI3RyZWUyJykuanN0cmVlKHsgcGx1Z2lucyA6IFtdIH0pOyAvLyBjcmVhdGUgYW4gaW5zdGFuY2Ugd2l0aCBzb21lIG9wdGlvbnNcblx0ICpcdCQoJyN0cmVlMScpLmpzdHJlZSgnb3Blbl9ub2RlJywgJyNicmFuY2hfMScpOyAvLyBjYWxsIGEgbWV0aG9kIG9uIGFuIGV4aXN0aW5nIGluc3RhbmNlLCBwYXNzaW5nIGFkZGl0aW9uYWwgYXJndW1lbnRzXG5cdCAqXHQkKCcjdHJlZTInKS5qc3RyZWUoKTsgLy8gZ2V0IGFuIGV4aXN0aW5nIGluc3RhbmNlIChvciBjcmVhdGUgYW4gaW5zdGFuY2UpXG5cdCAqXHQkKCcjdHJlZTInKS5qc3RyZWUodHJ1ZSk7IC8vIGdldCBhbiBleGlzdGluZyBpbnN0YW5jZSAod2lsbCBub3QgY3JlYXRlIG5ldyBpbnN0YW5jZSlcblx0ICpcdCQoJyNicmFuY2hfMScpLmpzdHJlZSgpLnNlbGVjdF9ub2RlKCcjYnJhbmNoXzEnKTsgLy8gZ2V0IGFuIGluc3RhbmNlICh1c2luZyBhIG5lc3RlZCBlbGVtZW50IGFuZCBjYWxsIGEgbWV0aG9kKVxuXHQgKlxuXHQgKiBAbmFtZSAkKCkuanN0cmVlKFthcmddKVxuXHQgKiBAcGFyYW0ge1N0cmluZ3xPYmplY3R9IGFyZ1xuXHQgKiBAcmV0dXJuIHtNaXhlZH1cblx0ICovXG5cdCQuZm4uanN0cmVlID0gZnVuY3Rpb24gKGFyZykge1xuXHRcdC8vIGNoZWNrIGZvciBzdHJpbmcgYXJndW1lbnRcblx0XHR2YXIgaXNfbWV0aG9kXHQ9ICh0eXBlb2YgYXJnID09PSAnc3RyaW5nJyksXG5cdFx0XHRhcmdzXHRcdD0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKSxcblx0XHRcdHJlc3VsdFx0XHQ9IG51bGw7XG5cdFx0aWYoYXJnID09PSB0cnVlICYmICF0aGlzLmxlbmd0aCkgeyByZXR1cm4gZmFsc2U7IH1cblx0XHR0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xuXHRcdFx0Ly8gZ2V0IHRoZSBpbnN0YW5jZSAoaWYgdGhlcmUgaXMgb25lKSBhbmQgbWV0aG9kIChpZiBpdCBleGlzdHMpXG5cdFx0XHR2YXIgaW5zdGFuY2UgPSAkLmpzdHJlZS5yZWZlcmVuY2UodGhpcyksXG5cdFx0XHRcdG1ldGhvZCA9IGlzX21ldGhvZCAmJiBpbnN0YW5jZSA/IGluc3RhbmNlW2FyZ10gOiBudWxsO1xuXHRcdFx0Ly8gaWYgY2FsbGluZyBhIG1ldGhvZCwgYW5kIG1ldGhvZCBpcyBhdmFpbGFibGUgLSBleGVjdXRlIG9uIHRoZSBpbnN0YW5jZVxuXHRcdFx0cmVzdWx0ID0gaXNfbWV0aG9kICYmIG1ldGhvZCA/XG5cdFx0XHRcdG1ldGhvZC5hcHBseShpbnN0YW5jZSwgYXJncykgOlxuXHRcdFx0XHRudWxsO1xuXHRcdFx0Ly8gaWYgdGhlcmUgaXMgbm8gaW5zdGFuY2UgYW5kIG5vIG1ldGhvZCBpcyBiZWluZyBjYWxsZWQgLSBjcmVhdGUgb25lXG5cdFx0XHRpZighaW5zdGFuY2UgJiYgIWlzX21ldGhvZCAmJiAoYXJnID09PSB1bmRlZmluZWQgfHwgJC5pc1BsYWluT2JqZWN0KGFyZykpKSB7XG5cdFx0XHRcdCQuanN0cmVlLmNyZWF0ZSh0aGlzLCBhcmcpO1xuXHRcdFx0fVxuXHRcdFx0Ly8gaWYgdGhlcmUgaXMgYW4gaW5zdGFuY2UgYW5kIG5vIG1ldGhvZCBpcyBjYWxsZWQgLSByZXR1cm4gdGhlIGluc3RhbmNlXG5cdFx0XHRpZiggKGluc3RhbmNlICYmICFpc19tZXRob2QpIHx8IGFyZyA9PT0gdHJ1ZSApIHtcblx0XHRcdFx0cmVzdWx0ID0gaW5zdGFuY2UgfHwgZmFsc2U7XG5cdFx0XHR9XG5cdFx0XHQvLyBpZiB0aGVyZSB3YXMgYSBtZXRob2QgY2FsbCB3aGljaCByZXR1cm5lZCBhIHJlc3VsdCAtIGJyZWFrIGFuZCByZXR1cm4gdGhlIHZhbHVlXG5cdFx0XHRpZihyZXN1bHQgIT09IG51bGwgJiYgcmVzdWx0ICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHRcdC8vIGlmIHRoZXJlIHdhcyBhIG1ldGhvZCBjYWxsIHdpdGggYSB2YWxpZCByZXR1cm4gdmFsdWUgLSByZXR1cm4gdGhhdCwgb3RoZXJ3aXNlIGNvbnRpbnVlIHRoZSBjaGFpblxuXHRcdHJldHVybiByZXN1bHQgIT09IG51bGwgJiYgcmVzdWx0ICE9PSB1bmRlZmluZWQgP1xuXHRcdFx0cmVzdWx0IDogdGhpcztcblx0fTtcblx0LyoqXG5cdCAqIHVzZWQgdG8gZmluZCBlbGVtZW50cyBjb250YWluaW5nIGFuIGluc3RhbmNlXG5cdCAqXG5cdCAqIF9fRXhhbXBsZXNfX1xuXHQgKlxuXHQgKlx0JCgnZGl2OmpzdHJlZScpLmVhY2goZnVuY3Rpb24gKCkge1xuXHQgKlx0XHQkKHRoaXMpLmpzdHJlZSgnZGVzdHJveScpO1xuXHQgKlx0fSk7XG5cdCAqXG5cdCAqIEBuYW1lICQoJzpqc3RyZWUnKVxuXHQgKiBAcmV0dXJuIHtqUXVlcnl9XG5cdCAqL1xuXHQkLmV4cHIucHNldWRvcy5qc3RyZWUgPSAkLmV4cHIuY3JlYXRlUHNldWRvKGZ1bmN0aW9uKHNlYXJjaCkge1xuXHRcdHJldHVybiBmdW5jdGlvbihhKSB7XG5cdFx0XHRyZXR1cm4gJChhKS5oYXNDbGFzcygnanN0cmVlJykgJiZcblx0XHRcdFx0JChhKS5kYXRhKCdqc3RyZWUnKSAhPT0gdW5kZWZpbmVkO1xuXHRcdH07XG5cdH0pO1xuXG5cdC8qKlxuXHQgKiBzdG9yZXMgYWxsIGRlZmF1bHRzIGZvciB0aGUgY29yZVxuXHQgKiBAbmFtZSAkLmpzdHJlZS5kZWZhdWx0cy5jb3JlXG5cdCAqL1xuXHQkLmpzdHJlZS5kZWZhdWx0cy5jb3JlID0ge1xuXHRcdC8qKlxuXHRcdCAqIGRhdGEgY29uZmlndXJhdGlvblxuXHRcdCAqXG5cdFx0ICogSWYgbGVmdCBhcyBgZmFsc2VgIHRoZSBIVE1MIGluc2lkZSB0aGUganN0cmVlIGNvbnRhaW5lciBlbGVtZW50IGlzIHVzZWQgdG8gcG9wdWxhdGUgdGhlIHRyZWUgKHRoYXQgc2hvdWxkIGJlIGFuIHVub3JkZXJlZCBsaXN0IHdpdGggbGlzdCBpdGVtcykuXG5cdFx0ICpcblx0XHQgKiBZb3UgY2FuIGFsc28gcGFzcyBpbiBhIEhUTUwgc3RyaW5nIG9yIGEgSlNPTiBhcnJheSBoZXJlLlxuXHRcdCAqXG5cdFx0ICogSXQgaXMgcG9zc2libGUgdG8gcGFzcyBpbiBhIHN0YW5kYXJkIGpRdWVyeS1saWtlIEFKQVggY29uZmlnIGFuZCBqc3RyZWUgd2lsbCBhdXRvbWF0aWNhbGx5IGRldGVybWluZSBpZiB0aGUgcmVzcG9uc2UgaXMgSlNPTiBvciBIVE1MIGFuZCB1c2UgdGhhdCB0byBwb3B1bGF0ZSB0aGUgdHJlZS5cblx0XHQgKiBJbiBhZGRpdGlvbiB0byB0aGUgc3RhbmRhcmQgalF1ZXJ5IGFqYXggb3B0aW9ucyBoZXJlIHlvdSBjYW4gc3VwcHkgZnVuY3Rpb25zIGZvciBgZGF0YWAgYW5kIGB1cmxgLCB0aGUgZnVuY3Rpb25zIHdpbGwgYmUgcnVuIGluIHRoZSBjdXJyZW50IGluc3RhbmNlJ3Mgc2NvcGUgYW5kIGEgcGFyYW0gd2lsbCBiZSBwYXNzZWQgaW5kaWNhdGluZyB3aGljaCBub2RlIGlzIGJlaW5nIGxvYWRlZCwgdGhlIHJldHVybiB2YWx1ZSBvZiB0aG9zZSBmdW5jdGlvbnMgd2lsbCBiZSB1c2VkLlxuXHRcdCAqXG5cdFx0ICogVGhlIGxhc3Qgb3B0aW9uIGlzIHRvIHNwZWNpZnkgYSBmdW5jdGlvbiwgdGhhdCBmdW5jdGlvbiB3aWxsIHJlY2VpdmUgdGhlIG5vZGUgYmVpbmcgbG9hZGVkIGFzIGFyZ3VtZW50IGFuZCBhIHNlY29uZCBwYXJhbSB3aGljaCBpcyBhIGZ1bmN0aW9uIHdoaWNoIHNob3VsZCBiZSBjYWxsZWQgd2l0aCB0aGUgcmVzdWx0LlxuXHRcdCAqXG5cdFx0ICogX19FeGFtcGxlc19fXG5cdFx0ICpcblx0XHQgKlx0Ly8gQUpBWFxuXHRcdCAqXHQkKCcjdHJlZScpLmpzdHJlZSh7XG5cdFx0ICpcdFx0J2NvcmUnIDoge1xuXHRcdCAqXHRcdFx0J2RhdGEnIDoge1xuXHRcdCAqXHRcdFx0XHQndXJsJyA6ICcvZ2V0L2NoaWxkcmVuLycsXG5cdFx0ICpcdFx0XHRcdCdkYXRhJyA6IGZ1bmN0aW9uIChub2RlKSB7XG5cdFx0ICpcdFx0XHRcdFx0cmV0dXJuIHsgJ2lkJyA6IG5vZGUuaWQgfTtcblx0XHQgKlx0XHRcdFx0fVxuXHRcdCAqXHRcdFx0fVxuXHRcdCAqXHRcdH0pO1xuXHRcdCAqXG5cdFx0ICpcdC8vIGRpcmVjdCBkYXRhXG5cdFx0ICpcdCQoJyN0cmVlJykuanN0cmVlKHtcblx0XHQgKlx0XHQnY29yZScgOiB7XG5cdFx0ICpcdFx0XHQnZGF0YScgOiBbXG5cdFx0ICpcdFx0XHRcdCdTaW1wbGUgcm9vdCBub2RlJyxcblx0XHQgKlx0XHRcdFx0e1xuXHRcdCAqXHRcdFx0XHRcdCdpZCcgOiAnbm9kZV8yJyxcblx0XHQgKlx0XHRcdFx0XHQndGV4dCcgOiAnUm9vdCBub2RlIHdpdGggb3B0aW9ucycsXG5cdFx0ICpcdFx0XHRcdFx0J3N0YXRlJyA6IHsgJ29wZW5lZCcgOiB0cnVlLCAnc2VsZWN0ZWQnIDogdHJ1ZSB9LFxuXHRcdCAqXHRcdFx0XHRcdCdjaGlsZHJlbicgOiBbIHsgJ3RleHQnIDogJ0NoaWxkIDEnIH0sICdDaGlsZCAyJ11cblx0XHQgKlx0XHRcdFx0fVxuXHRcdCAqXHRcdFx0XVxuXHRcdCAqXHRcdH1cblx0XHQgKlx0fSk7XG5cdFx0ICpcblx0XHQgKlx0Ly8gZnVuY3Rpb25cblx0XHQgKlx0JCgnI3RyZWUnKS5qc3RyZWUoe1xuXHRcdCAqXHRcdCdjb3JlJyA6IHtcblx0XHQgKlx0XHRcdCdkYXRhJyA6IGZ1bmN0aW9uIChvYmosIGNhbGxiYWNrKSB7XG5cdFx0ICpcdFx0XHRcdGNhbGxiYWNrLmNhbGwodGhpcywgWydSb290IDEnLCAnUm9vdCAyJ10pO1xuXHRcdCAqXHRcdFx0fVxuXHRcdCAqXHRcdH0pO1xuXHRcdCAqXG5cdFx0ICogQG5hbWUgJC5qc3RyZWUuZGVmYXVsdHMuY29yZS5kYXRhXG5cdFx0ICovXG5cdFx0ZGF0YVx0XHRcdDogZmFsc2UsXG5cdFx0LyoqXG5cdFx0ICogY29uZmlndXJlIHRoZSB2YXJpb3VzIHN0cmluZ3MgdXNlZCB0aHJvdWdob3V0IHRoZSB0cmVlXG5cdFx0ICpcblx0XHQgKiBZb3UgY2FuIHVzZSBhbiBvYmplY3Qgd2hlcmUgdGhlIGtleSBpcyB0aGUgc3RyaW5nIHlvdSBuZWVkIHRvIHJlcGxhY2UgYW5kIHRoZSB2YWx1ZSBpcyB5b3VyIHJlcGxhY2VtZW50LlxuXHRcdCAqIEFub3RoZXIgb3B0aW9uIGlzIHRvIHNwZWNpZnkgYSBmdW5jdGlvbiB3aGljaCB3aWxsIGJlIGNhbGxlZCB3aXRoIGFuIGFyZ3VtZW50IG9mIHRoZSBuZWVkZWQgc3RyaW5nIGFuZCBzaG91bGQgcmV0dXJuIHRoZSByZXBsYWNlbWVudC5cblx0XHQgKiBJZiBsZWZ0IGFzIGBmYWxzZWAgbm8gcmVwbGFjZW1lbnQgaXMgbWFkZS5cblx0XHQgKlxuXHRcdCAqIF9fRXhhbXBsZXNfX1xuXHRcdCAqXG5cdFx0ICpcdCQoJyN0cmVlJykuanN0cmVlKHtcblx0XHQgKlx0XHQnY29yZScgOiB7XG5cdFx0ICpcdFx0XHQnc3RyaW5ncycgOiB7XG5cdFx0ICpcdFx0XHRcdCdMb2FkaW5nIC4uLicgOiAnUGxlYXNlIHdhaXQgLi4uJ1xuXHRcdCAqXHRcdFx0fVxuXHRcdCAqXHRcdH1cblx0XHQgKlx0fSk7XG5cdFx0ICpcblx0XHQgKiBAbmFtZSAkLmpzdHJlZS5kZWZhdWx0cy5jb3JlLnN0cmluZ3Ncblx0XHQgKi9cblx0XHRzdHJpbmdzXHRcdFx0OiBmYWxzZSxcblx0XHQvKipcblx0XHQgKiBkZXRlcm1pbmVzIHdoYXQgaGFwcGVucyB3aGVuIGEgdXNlciB0cmllcyB0byBtb2RpZnkgdGhlIHN0cnVjdHVyZSBvZiB0aGUgdHJlZVxuXHRcdCAqIElmIGxlZnQgYXMgYGZhbHNlYCBhbGwgb3BlcmF0aW9ucyBsaWtlIGNyZWF0ZSwgcmVuYW1lLCBkZWxldGUsIG1vdmUgb3IgY29weSBhcmUgcHJldmVudGVkLlxuXHRcdCAqIFlvdSBjYW4gc2V0IHRoaXMgdG8gYHRydWVgIHRvIGFsbG93IGFsbCBpbnRlcmFjdGlvbnMgb3IgdXNlIGEgZnVuY3Rpb24gdG8gaGF2ZSBiZXR0ZXIgY29udHJvbC5cblx0XHQgKlxuXHRcdCAqIF9fRXhhbXBsZXNfX1xuXHRcdCAqXG5cdFx0ICpcdCQoJyN0cmVlJykuanN0cmVlKHtcblx0XHQgKlx0XHQnY29yZScgOiB7XG5cdFx0ICpcdFx0XHQnY2hlY2tfY2FsbGJhY2snIDogZnVuY3Rpb24gKG9wZXJhdGlvbiwgbm9kZSwgbm9kZV9wYXJlbnQsIG5vZGVfcG9zaXRpb24sIG1vcmUpIHtcblx0XHQgKlx0XHRcdFx0Ly8gb3BlcmF0aW9uIGNhbiBiZSAnY3JlYXRlX25vZGUnLCAncmVuYW1lX25vZGUnLCAnZGVsZXRlX25vZGUnLCAnbW92ZV9ub2RlJyBvciAnY29weV9ub2RlJ1xuXHRcdCAqXHRcdFx0XHQvLyBpbiBjYXNlIG9mICdyZW5hbWVfbm9kZScgbm9kZV9wb3NpdGlvbiBpcyBmaWxsZWQgd2l0aCB0aGUgbmV3IG5vZGUgbmFtZVxuXHRcdCAqXHRcdFx0XHRyZXR1cm4gb3BlcmF0aW9uID09PSAncmVuYW1lX25vZGUnID8gdHJ1ZSA6IGZhbHNlO1xuXHRcdCAqXHRcdFx0fVxuXHRcdCAqXHRcdH1cblx0XHQgKlx0fSk7XG5cdFx0ICpcblx0XHQgKiBAbmFtZSAkLmpzdHJlZS5kZWZhdWx0cy5jb3JlLmNoZWNrX2NhbGxiYWNrXG5cdFx0ICovXG5cdFx0Y2hlY2tfY2FsbGJhY2tcdDogZmFsc2UsXG5cdFx0LyoqXG5cdFx0ICogYSBjYWxsYmFjayBjYWxsZWQgd2l0aCBhIHNpbmdsZSBvYmplY3QgcGFyYW1ldGVyIGluIHRoZSBpbnN0YW5jZSdzIHNjb3BlIHdoZW4gc29tZXRoaW5nIGdvZXMgd3JvbmcgKG9wZXJhdGlvbiBwcmV2ZW50ZWQsIGFqYXggZmFpbGVkLCBldGMpXG5cdFx0ICogQG5hbWUgJC5qc3RyZWUuZGVmYXVsdHMuY29yZS5lcnJvclxuXHRcdCAqL1xuXHRcdGVycm9yXHRcdFx0OiAkLm5vb3AsXG5cdFx0LyoqXG5cdFx0ICogdGhlIG9wZW4gLyBjbG9zZSBhbmltYXRpb24gZHVyYXRpb24gaW4gbWlsbGlzZWNvbmRzIC0gc2V0IHRoaXMgdG8gYGZhbHNlYCB0byBkaXNhYmxlIHRoZSBhbmltYXRpb24gKGRlZmF1bHQgaXMgYDIwMGApXG5cdFx0ICogQG5hbWUgJC5qc3RyZWUuZGVmYXVsdHMuY29yZS5hbmltYXRpb25cblx0XHQgKi9cblx0XHRhbmltYXRpb25cdFx0OiAyMDAsXG5cdFx0LyoqXG5cdFx0ICogYSBib29sZWFuIGluZGljYXRpbmcgaWYgbXVsdGlwbGUgbm9kZXMgY2FuIGJlIHNlbGVjdGVkXG5cdFx0ICogQG5hbWUgJC5qc3RyZWUuZGVmYXVsdHMuY29yZS5tdWx0aXBsZVxuXHRcdCAqL1xuXHRcdG11bHRpcGxlXHRcdDogdHJ1ZSxcblx0XHQvKipcblx0XHQgKiB0aGVtZSBjb25maWd1cmF0aW9uIG9iamVjdFxuXHRcdCAqIEBuYW1lICQuanN0cmVlLmRlZmF1bHRzLmNvcmUudGhlbWVzXG5cdFx0ICovXG5cdFx0dGhlbWVzXHRcdFx0OiB7XG5cdFx0XHQvKipcblx0XHRcdCAqIHRoZSBuYW1lIG9mIHRoZSB0aGVtZSB0byB1c2UgKGlmIGxlZnQgYXMgYGZhbHNlYCB0aGUgZGVmYXVsdCB0aGVtZSBpcyB1c2VkKVxuXHRcdFx0ICogQG5hbWUgJC5qc3RyZWUuZGVmYXVsdHMuY29yZS50aGVtZXMubmFtZVxuXHRcdFx0ICovXG5cdFx0XHRuYW1lXHRcdFx0OiBmYWxzZSxcblx0XHRcdC8qKlxuXHRcdFx0ICogdGhlIFVSTCBvZiB0aGUgdGhlbWUncyBDU1MgZmlsZSwgbGVhdmUgdGhpcyBhcyBgZmFsc2VgIGlmIHlvdSBoYXZlIG1hbnVhbGx5IGluY2x1ZGVkIHRoZSB0aGVtZSBDU1MgKHJlY29tbWVuZGVkKS4gWW91IGNhbiBzZXQgdGhpcyB0byBgdHJ1ZWAgdG9vIHdoaWNoIHdpbGwgdHJ5IHRvIGF1dG9sb2FkIHRoZSB0aGVtZS5cblx0XHRcdCAqIEBuYW1lICQuanN0cmVlLmRlZmF1bHRzLmNvcmUudGhlbWVzLnVybFxuXHRcdFx0ICovXG5cdFx0XHR1cmxcdFx0XHRcdDogZmFsc2UsXG5cdFx0XHQvKipcblx0XHRcdCAqIHRoZSBsb2NhdGlvbiBvZiBhbGwganN0cmVlIHRoZW1lcyAtIG9ubHkgdXNlZCBpZiBgdXJsYCBpcyBzZXQgdG8gYHRydWVgXG5cdFx0XHQgKiBAbmFtZSAkLmpzdHJlZS5kZWZhdWx0cy5jb3JlLnRoZW1lcy5kaXJcblx0XHRcdCAqL1xuXHRcdFx0ZGlyXHRcdFx0XHQ6IGZhbHNlLFxuXHRcdFx0LyoqXG5cdFx0XHQgKiBhIGJvb2xlYW4gaW5kaWNhdGluZyBpZiBjb25uZWN0aW5nIGRvdHMgYXJlIHNob3duXG5cdFx0XHQgKiBAbmFtZSAkLmpzdHJlZS5kZWZhdWx0cy5jb3JlLnRoZW1lcy5kb3RzXG5cdFx0XHQgKi9cblx0XHRcdGRvdHNcdFx0XHQ6IHRydWUsXG5cdFx0XHQvKipcblx0XHRcdCAqIGEgYm9vbGVhbiBpbmRpY2F0aW5nIGlmIG5vZGUgaWNvbnMgYXJlIHNob3duXG5cdFx0XHQgKiBAbmFtZSAkLmpzdHJlZS5kZWZhdWx0cy5jb3JlLnRoZW1lcy5pY29uc1xuXHRcdFx0ICovXG5cdFx0XHRpY29uc1x0XHRcdDogdHJ1ZSxcblx0XHRcdC8qKlxuXHRcdFx0ICogYSBib29sZWFuIGluZGljYXRpbmcgaWYgbm9kZSBlbGxpcHNpcyBzaG91bGQgYmUgc2hvd24gLSB0aGlzIG9ubHkgd29ya3Mgd2l0aCBhIGZpeGVkIHdpdGggb24gdGhlIGNvbnRhaW5lclxuXHRcdFx0ICogQG5hbWUgJC5qc3RyZWUuZGVmYXVsdHMuY29yZS50aGVtZXMuZWxsaXBzaXNcblx0XHRcdCAqL1xuXHRcdFx0ZWxsaXBzaXNcdFx0OiBmYWxzZSxcblx0XHRcdC8qKlxuXHRcdFx0ICogYSBib29sZWFuIGluZGljYXRpbmcgaWYgdGhlIHRyZWUgYmFja2dyb3VuZCBpcyBzdHJpcGVkXG5cdFx0XHQgKiBAbmFtZSAkLmpzdHJlZS5kZWZhdWx0cy5jb3JlLnRoZW1lcy5zdHJpcGVzXG5cdFx0XHQgKi9cblx0XHRcdHN0cmlwZXNcdFx0XHQ6IGZhbHNlLFxuXHRcdFx0LyoqXG5cdFx0XHQgKiBhIHN0cmluZyAob3IgYm9vbGVhbiBgZmFsc2VgKSBzcGVjaWZ5aW5nIHRoZSB0aGVtZSB2YXJpYW50IHRvIHVzZSAoaWYgdGhlIHRoZW1lIHN1cHBvcnRzIHZhcmlhbnRzKVxuXHRcdFx0ICogQG5hbWUgJC5qc3RyZWUuZGVmYXVsdHMuY29yZS50aGVtZXMudmFyaWFudFxuXHRcdFx0ICovXG5cdFx0XHR2YXJpYW50XHRcdFx0OiBmYWxzZSxcblx0XHRcdC8qKlxuXHRcdFx0ICogYSBib29sZWFuIHNwZWNpZnlpbmcgaWYgYSByZXBvbnNpdmUgdmVyc2lvbiBvZiB0aGUgdGhlbWUgc2hvdWxkIGtpY2sgaW4gb24gc21hbGxlciBzY3JlZW5zIChpZiB0aGUgdGhlbWUgc3VwcG9ydHMgaXQpLiBEZWZhdWx0cyB0byBgZmFsc2VgLlxuXHRcdFx0ICogQG5hbWUgJC5qc3RyZWUuZGVmYXVsdHMuY29yZS50aGVtZXMucmVzcG9uc2l2ZVxuXHRcdFx0ICovXG5cdFx0XHRyZXNwb25zaXZlXHRcdDogZmFsc2Vcblx0XHR9LFxuXHRcdC8qKlxuXHRcdCAqIGlmIGxlZnQgYXMgYHRydWVgIGFsbCBwYXJlbnRzIG9mIGFsbCBzZWxlY3RlZCBub2RlcyB3aWxsIGJlIG9wZW5lZCBvbmNlIHRoZSB0cmVlIGxvYWRzIChzbyB0aGF0IGFsbCBzZWxlY3RlZCBub2RlcyBhcmUgdmlzaWJsZSB0byB0aGUgdXNlcilcblx0XHQgKiBAbmFtZSAkLmpzdHJlZS5kZWZhdWx0cy5jb3JlLmV4cGFuZF9zZWxlY3RlZF9vbmxvYWRcblx0XHQgKi9cblx0XHRleHBhbmRfc2VsZWN0ZWRfb25sb2FkIDogdHJ1ZSxcblx0XHQvKipcblx0XHQgKiBpZiBsZWZ0IGFzIGB0cnVlYCB3ZWIgd29ya2VycyB3aWxsIGJlIHVzZWQgdG8gcGFyc2UgaW5jb21pbmcgSlNPTiBkYXRhIHdoZXJlIHBvc3NpYmxlLCBzbyB0aGF0IHRoZSBVSSB3aWxsIG5vdCBiZSBibG9ja2VkIGJ5IGxhcmdlIHJlcXVlc3RzLiBXb3JrZXJzIGFyZSBob3dldmVyIGFib3V0IDMwJSBzbG93ZXIuIERlZmF1bHRzIHRvIGB0cnVlYFxuXHRcdCAqIEBuYW1lICQuanN0cmVlLmRlZmF1bHRzLmNvcmUud29ya2VyXG5cdFx0ICovXG5cdFx0d29ya2VyIDogdHJ1ZSxcblx0XHQvKipcblx0XHQgKiBGb3JjZSBub2RlIHRleHQgdG8gcGxhaW4gdGV4dCAoYW5kIGVzY2FwZSBIVE1MKS4gRGVmYXVsdHMgdG8gYGZhbHNlYFxuXHRcdCAqIEBuYW1lICQuanN0cmVlLmRlZmF1bHRzLmNvcmUuZm9yY2VfdGV4dFxuXHRcdCAqL1xuXHRcdGZvcmNlX3RleHQgOiBmYWxzZSxcblx0XHQvKipcblx0XHQgKiBTaG91bGQgdGhlIG5vZGUgc2hvdWxkIGJlIHRvZ2dsZWQgaWYgdGhlIHRleHQgaXMgZG91YmxlIGNsaWNrZWQgLiBEZWZhdWx0cyB0byBgdHJ1ZWBcblx0XHQgKiBAbmFtZSAkLmpzdHJlZS5kZWZhdWx0cy5jb3JlLmRibGNsaWNrX3RvZ2dsZVxuXHRcdCAqL1xuXHRcdGRibGNsaWNrX3RvZ2dsZSA6IHRydWVcblx0fTtcblx0JC5qc3RyZWUuY29yZS5wcm90b3R5cGUgPSB7XG5cdFx0LyoqXG5cdFx0ICogdXNlZCB0byBkZWNvcmF0ZSBhbiBpbnN0YW5jZSB3aXRoIGEgcGx1Z2luLiBVc2VkIGludGVybmFsbHkuXG5cdFx0ICogQHByaXZhdGVcblx0XHQgKiBAbmFtZSBwbHVnaW4oZGVjbyBbLCBvcHRzXSlcblx0XHQgKiBAcGFyYW0gIHtTdHJpbmd9IGRlY28gdGhlIHBsdWdpbiB0byBkZWNvcmF0ZSB3aXRoXG5cdFx0ICogQHBhcmFtICB7T2JqZWN0fSBvcHRzIG9wdGlvbnMgZm9yIHRoZSBwbHVnaW5cblx0XHQgKiBAcmV0dXJuIHtqc1RyZWV9XG5cdFx0ICovXG5cdFx0cGx1Z2luIDogZnVuY3Rpb24gKGRlY28sIG9wdHMpIHtcblx0XHRcdHZhciBDaGlsZCA9ICQuanN0cmVlLnBsdWdpbnNbZGVjb107XG5cdFx0XHRpZihDaGlsZCkge1xuXHRcdFx0XHR0aGlzLl9kYXRhW2RlY29dID0ge307XG5cdFx0XHRcdENoaWxkLnByb3RvdHlwZSA9IHRoaXM7XG5cdFx0XHRcdHJldHVybiBuZXcgQ2hpbGQob3B0cywgdGhpcyk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9LFxuXHRcdC8qKlxuXHRcdCAqIGluaXRpYWxpemUgdGhlIGluc3RhbmNlLiBVc2VkIGludGVybmFsbHkuXG5cdFx0ICogQHByaXZhdGVcblx0XHQgKiBAbmFtZSBpbml0KGVsLCBvcHRvbnMpXG5cdFx0ICogQHBhcmFtIHtET01FbGVtZW50fGpRdWVyeXxTdHJpbmd9IGVsIHRoZSBlbGVtZW50IHdlIGFyZSB0cmFuc2Zvcm1pbmdcblx0XHQgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBvcHRpb25zIGZvciB0aGlzIGluc3RhbmNlXG5cdFx0ICogQHRyaWdnZXIgaW5pdC5qc3RyZWUsIGxvYWRpbmcuanN0cmVlLCBsb2FkZWQuanN0cmVlLCByZWFkeS5qc3RyZWUsIGNoYW5nZWQuanN0cmVlXG5cdFx0ICovXG5cdFx0aW5pdCA6IGZ1bmN0aW9uIChlbCwgb3B0aW9ucykge1xuXHRcdFx0dGhpcy5fbW9kZWwgPSB7XG5cdFx0XHRcdGRhdGEgOiB7fSxcblx0XHRcdFx0Y2hhbmdlZCA6IFtdLFxuXHRcdFx0XHRmb3JjZV9mdWxsX3JlZHJhdyA6IGZhbHNlLFxuXHRcdFx0XHRyZWRyYXdfdGltZW91dCA6IGZhbHNlLFxuXHRcdFx0XHRkZWZhdWx0X3N0YXRlIDoge1xuXHRcdFx0XHRcdGxvYWRlZCA6IHRydWUsXG5cdFx0XHRcdFx0b3BlbmVkIDogZmFsc2UsXG5cdFx0XHRcdFx0c2VsZWN0ZWQgOiBmYWxzZSxcblx0XHRcdFx0XHRkaXNhYmxlZCA6IGZhbHNlXG5cdFx0XHRcdH1cblx0XHRcdH07XG5cdFx0XHR0aGlzLl9tb2RlbC5kYXRhWyQuanN0cmVlLnJvb3RdID0ge1xuXHRcdFx0XHRpZCA6ICQuanN0cmVlLnJvb3QsXG5cdFx0XHRcdHBhcmVudCA6IG51bGwsXG5cdFx0XHRcdHBhcmVudHMgOiBbXSxcblx0XHRcdFx0Y2hpbGRyZW4gOiBbXSxcblx0XHRcdFx0Y2hpbGRyZW5fZCA6IFtdLFxuXHRcdFx0XHRzdGF0ZSA6IHsgbG9hZGVkIDogZmFsc2UgfVxuXHRcdFx0fTtcblxuXHRcdFx0dGhpcy5lbGVtZW50ID0gJChlbCkuYWRkQ2xhc3MoJ2pzdHJlZSBqc3RyZWUtJyArIHRoaXMuX2lkKTtcblx0XHRcdHRoaXMuc2V0dGluZ3MgPSBvcHRpb25zO1xuXG5cdFx0XHR0aGlzLl9kYXRhLmNvcmUucmVhZHkgPSBmYWxzZTtcblx0XHRcdHRoaXMuX2RhdGEuY29yZS5sb2FkZWQgPSBmYWxzZTtcblx0XHRcdHRoaXMuX2RhdGEuY29yZS5ydGwgPSAodGhpcy5lbGVtZW50LmNzcyhcImRpcmVjdGlvblwiKSA9PT0gXCJydGxcIik7XG5cdFx0XHR0aGlzLmVsZW1lbnRbdGhpcy5fZGF0YS5jb3JlLnJ0bCA/ICdhZGRDbGFzcycgOiAncmVtb3ZlQ2xhc3MnXShcImpzdHJlZS1ydGxcIik7XG5cdFx0XHR0aGlzLmVsZW1lbnQuYXR0cigncm9sZScsJ3RyZWUnKTtcblx0XHRcdGlmKHRoaXMuc2V0dGluZ3MuY29yZS5tdWx0aXBsZSkge1xuXHRcdFx0XHR0aGlzLmVsZW1lbnQuYXR0cignYXJpYS1tdWx0aXNlbGVjdGFibGUnLCB0cnVlKTtcblx0XHRcdH1cblx0XHRcdGlmKCF0aGlzLmVsZW1lbnQuYXR0cigndGFiaW5kZXgnKSkge1xuXHRcdFx0XHR0aGlzLmVsZW1lbnQuYXR0cigndGFiaW5kZXgnLCcwJyk7XG5cdFx0XHR9XG5cblx0XHRcdHRoaXMuYmluZCgpO1xuXHRcdFx0LyoqXG5cdFx0XHQgKiB0cmlnZ2VyZWQgYWZ0ZXIgYWxsIGV2ZW50cyBhcmUgYm91bmRcblx0XHRcdCAqIEBldmVudFxuXHRcdFx0ICogQG5hbWUgaW5pdC5qc3RyZWVcblx0XHRcdCAqL1xuXHRcdFx0dGhpcy50cmlnZ2VyKFwiaW5pdFwiKTtcblxuXHRcdFx0dGhpcy5fZGF0YS5jb3JlLm9yaWdpbmFsX2NvbnRhaW5lcl9odG1sID0gdGhpcy5lbGVtZW50LmZpbmQoXCIgPiB1bCA+IGxpXCIpLmNsb25lKHRydWUpO1xuXHRcdFx0dGhpcy5fZGF0YS5jb3JlLm9yaWdpbmFsX2NvbnRhaW5lcl9odG1sXG5cdFx0XHRcdC5maW5kKFwibGlcIikuYWRkQmFjaygpXG5cdFx0XHRcdC5jb250ZW50cygpLmZpbHRlcihmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRyZXR1cm4gdGhpcy5ub2RlVHlwZSA9PT0gMyAmJiAoIXRoaXMubm9kZVZhbHVlIHx8IC9eXFxzKyQvLnRlc3QodGhpcy5ub2RlVmFsdWUpKTtcblx0XHRcdFx0fSlcblx0XHRcdFx0LnJlbW92ZSgpO1xuXHRcdFx0dGhpcy5lbGVtZW50Lmh0bWwoXCI8XCIrXCJ1bCBjbGFzcz0nanN0cmVlLWNvbnRhaW5lci11bCBqc3RyZWUtY2hpbGRyZW4nIHJvbGU9J2dyb3VwJz48XCIrXCJsaSBpZD0nalwiK3RoaXMuX2lkK1wiX2xvYWRpbmcnIGNsYXNzPSdqc3RyZWUtaW5pdGlhbC1ub2RlIGpzdHJlZS1sb2FkaW5nIGpzdHJlZS1sZWFmIGpzdHJlZS1sYXN0JyByb2xlPSd0cmVlLWl0ZW0nPjxpIGNsYXNzPSdqc3RyZWUtaWNvbiBqc3RyZWUtb2NsJz48L2k+PFwiK1wiYSBjbGFzcz0nanN0cmVlLWFuY2hvcicgaHJlZj0nIyc+PGkgY2xhc3M9J2pzdHJlZS1pY29uIGpzdHJlZS10aGVtZWljb24taGlkZGVuJz48L2k+XCIgKyB0aGlzLmdldF9zdHJpbmcoXCJMb2FkaW5nIC4uLlwiKSArIFwiPC9hPjwvbGk+PC91bD5cIik7XG5cdFx0XHR0aGlzLmVsZW1lbnQuYXR0cignYXJpYS1hY3RpdmVkZXNjZW5kYW50JywnaicgKyB0aGlzLl9pZCArICdfbG9hZGluZycpO1xuXHRcdFx0dGhpcy5fZGF0YS5jb3JlLmxpX2hlaWdodCA9IHRoaXMuZ2V0X2NvbnRhaW5lcl91bCgpLmNoaWxkcmVuKFwibGlcIikuZmlyc3QoKS5oZWlnaHQoKSB8fCAyNDtcblx0XHRcdHRoaXMuX2RhdGEuY29yZS5ub2RlID0gdGhpcy5fY3JlYXRlX3Byb3RvdHlwZV9ub2RlKCk7XG5cdFx0XHQvKipcblx0XHRcdCAqIHRyaWdnZXJlZCBhZnRlciB0aGUgbG9hZGluZyB0ZXh0IGlzIHNob3duIGFuZCBiZWZvcmUgbG9hZGluZyBzdGFydHNcblx0XHRcdCAqIEBldmVudFxuXHRcdFx0ICogQG5hbWUgbG9hZGluZy5qc3RyZWVcblx0XHRcdCAqL1xuXHRcdFx0dGhpcy50cmlnZ2VyKFwibG9hZGluZ1wiKTtcblx0XHRcdHRoaXMubG9hZF9ub2RlKCQuanN0cmVlLnJvb3QpO1xuXHRcdH0sXG5cdFx0LyoqXG5cdFx0ICogZGVzdHJveSBhbiBpbnN0YW5jZVxuXHRcdCAqIEBuYW1lIGRlc3Ryb3koKVxuXHRcdCAqIEBwYXJhbSAge0Jvb2xlYW59IGtlZXBfaHRtbCBpZiBub3Qgc2V0IHRvIGB0cnVlYCB0aGUgY29udGFpbmVyIHdpbGwgYmUgZW1wdGllZCwgb3RoZXJ3aXNlIHRoZSBjdXJyZW50IERPTSBlbGVtZW50cyB3aWxsIGJlIGtlcHQgaW50YWN0XG5cdFx0ICovXG5cdFx0ZGVzdHJveSA6IGZ1bmN0aW9uIChrZWVwX2h0bWwpIHtcblx0XHRcdGlmKHRoaXMuX3dyaykge1xuXHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdHdpbmRvdy5VUkwucmV2b2tlT2JqZWN0VVJMKHRoaXMuX3dyayk7XG5cdFx0XHRcdFx0dGhpcy5fd3JrID0gbnVsbDtcblx0XHRcdFx0fVxuXHRcdFx0XHRjYXRjaCAoaWdub3JlKSB7IH1cblx0XHRcdH1cblx0XHRcdGlmKCFrZWVwX2h0bWwpIHsgdGhpcy5lbGVtZW50LmVtcHR5KCk7IH1cblx0XHRcdHRoaXMudGVhcmRvd24oKTtcblx0XHR9LFxuXHRcdC8qKlxuXHRcdCAqIENyZWF0ZSBwcm90b3R5cGUgbm9kZVxuXHRcdCAqL1xuXHRcdF9jcmVhdGVfcHJvdG90eXBlX25vZGUgOiBmdW5jdGlvbiAoKSB7XG5cdFx0XHR2YXIgX25vZGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdMSScpLCBfdGVtcDEsIF90ZW1wMjtcblx0XHRcdF9ub2RlLnNldEF0dHJpYnV0ZSgncm9sZScsICd0cmVlaXRlbScpO1xuXHRcdFx0X3RlbXAxID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnSScpO1xuXHRcdFx0X3RlbXAxLmNsYXNzTmFtZSA9ICdqc3RyZWUtaWNvbiBqc3RyZWUtb2NsJztcblx0XHRcdF90ZW1wMS5zZXRBdHRyaWJ1dGUoJ3JvbGUnLCAncHJlc2VudGF0aW9uJyk7XG5cdFx0XHRfbm9kZS5hcHBlbmRDaGlsZChfdGVtcDEpO1xuXHRcdFx0X3RlbXAxID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnQScpO1xuXHRcdFx0X3RlbXAxLmNsYXNzTmFtZSA9ICdqc3RyZWUtYW5jaG9yJztcblx0XHRcdF90ZW1wMS5zZXRBdHRyaWJ1dGUoJ2hyZWYnLCcjJyk7XG5cdFx0XHRfdGVtcDEuc2V0QXR0cmlidXRlKCd0YWJpbmRleCcsJy0xJyk7XG5cdFx0XHRfdGVtcDIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdJJyk7XG5cdFx0XHRfdGVtcDIuY2xhc3NOYW1lID0gJ2pzdHJlZS1pY29uIGpzdHJlZS10aGVtZWljb24nO1xuXHRcdFx0X3RlbXAyLnNldEF0dHJpYnV0ZSgncm9sZScsICdwcmVzZW50YXRpb24nKTtcblx0XHRcdF90ZW1wMS5hcHBlbmRDaGlsZChfdGVtcDIpO1xuXHRcdFx0X25vZGUuYXBwZW5kQ2hpbGQoX3RlbXAxKTtcblx0XHRcdF90ZW1wMSA9IF90ZW1wMiA9IG51bGw7XG5cblx0XHRcdHJldHVybiBfbm9kZTtcblx0XHR9LFxuXHRcdC8qKlxuXHRcdCAqIHBhcnQgb2YgdGhlIGRlc3Ryb3lpbmcgb2YgYW4gaW5zdGFuY2UuIFVzZWQgaW50ZXJuYWxseS5cblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqIEBuYW1lIHRlYXJkb3duKClcblx0XHQgKi9cblx0XHR0ZWFyZG93biA6IGZ1bmN0aW9uICgpIHtcblx0XHRcdHRoaXMudW5iaW5kKCk7XG5cdFx0XHR0aGlzLmVsZW1lbnRcblx0XHRcdFx0LnJlbW92ZUNsYXNzKCdqc3RyZWUnKVxuXHRcdFx0XHQucmVtb3ZlRGF0YSgnanN0cmVlJylcblx0XHRcdFx0LmZpbmQoXCJbY2xhc3NePSdqc3RyZWUnXVwiKVxuXHRcdFx0XHRcdC5hZGRCYWNrKClcblx0XHRcdFx0XHQuYXR0cihcImNsYXNzXCIsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuY2xhc3NOYW1lLnJlcGxhY2UoL2pzdHJlZVteIF0qfCQvaWcsJycpOyB9KTtcblx0XHRcdHRoaXMuZWxlbWVudCA9IG51bGw7XG5cdFx0fSxcblx0XHQvKipcblx0XHQgKiBiaW5kIGFsbCBldmVudHMuIFVzZWQgaW50ZXJuYWxseS5cblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqIEBuYW1lIGJpbmQoKVxuXHRcdCAqL1xuXHRcdGJpbmQgOiBmdW5jdGlvbiAoKSB7XG5cdFx0XHR2YXIgd29yZCA9ICcnLFxuXHRcdFx0XHR0b3V0ID0gbnVsbCxcblx0XHRcdFx0d2FzX2NsaWNrID0gMDtcblx0XHRcdHRoaXMuZWxlbWVudFxuXHRcdFx0XHQub24oXCJkYmxjbGljay5qc3RyZWVcIiwgZnVuY3Rpb24gKGUpIHtcblx0XHRcdFx0XHRcdGlmKGUudGFyZ2V0LnRhZ05hbWUgJiYgZS50YXJnZXQudGFnTmFtZS50b0xvd2VyQ2FzZSgpID09PSBcImlucHV0XCIpIHsgcmV0dXJuIHRydWU7IH1cblx0XHRcdFx0XHRcdGlmKGRvY3VtZW50LnNlbGVjdGlvbiAmJiBkb2N1bWVudC5zZWxlY3Rpb24uZW1wdHkpIHtcblx0XHRcdFx0XHRcdFx0ZG9jdW1lbnQuc2VsZWN0aW9uLmVtcHR5KCk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRcdFx0aWYod2luZG93LmdldFNlbGVjdGlvbikge1xuXHRcdFx0XHRcdFx0XHRcdHZhciBzZWwgPSB3aW5kb3cuZ2V0U2VsZWN0aW9uKCk7XG5cdFx0XHRcdFx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRcdFx0XHRcdHNlbC5yZW1vdmVBbGxSYW5nZXMoKTtcblx0XHRcdFx0XHRcdFx0XHRcdHNlbC5jb2xsYXBzZSgpO1xuXHRcdFx0XHRcdFx0XHRcdH0gY2F0Y2ggKGlnbm9yZSkgeyB9XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9KVxuXHRcdFx0XHQub24oXCJtb3VzZWRvd24uanN0cmVlXCIsICQucHJveHkoZnVuY3Rpb24gKGUpIHtcblx0XHRcdFx0XHRcdGlmKGUudGFyZ2V0ID09PSB0aGlzLmVsZW1lbnRbMF0pIHtcblx0XHRcdFx0XHRcdFx0ZS5wcmV2ZW50RGVmYXVsdCgpOyAvLyBwcmV2ZW50IGxvc2luZyBmb2N1cyB3aGVuIGNsaWNraW5nIHNjcm9sbCBhcnJvd3MgKEZGLCBDaHJvbWUpXG5cdFx0XHRcdFx0XHRcdHdhc19jbGljayA9ICsobmV3IERhdGUoKSk7IC8vIGllIGRvZXMgbm90IGFsbG93IHRvIHByZXZlbnQgbG9zaW5nIGZvY3VzXG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSwgdGhpcykpXG5cdFx0XHRcdC5vbihcIm1vdXNlZG93bi5qc3RyZWVcIiwgXCIuanN0cmVlLW9jbFwiLCBmdW5jdGlvbiAoZSkge1xuXHRcdFx0XHRcdFx0ZS5wcmV2ZW50RGVmYXVsdCgpOyAvLyBwcmV2ZW50IGFueSBub2RlIGluc2lkZSBmcm9tIGxvc2luZyBmb2N1cyB3aGVuIGNsaWNraW5nIHRoZSBvcGVuL2Nsb3NlIGljb25cblx0XHRcdFx0XHR9KVxuXHRcdFx0XHQub24oXCJjbGljay5qc3RyZWVcIiwgXCIuanN0cmVlLW9jbFwiLCAkLnByb3h5KGZ1bmN0aW9uIChlKSB7XG5cdFx0XHRcdFx0XHR0aGlzLnRvZ2dsZV9ub2RlKGUudGFyZ2V0KTtcblx0XHRcdFx0XHR9LCB0aGlzKSlcblx0XHRcdFx0Lm9uKFwiZGJsY2xpY2suanN0cmVlXCIsIFwiLmpzdHJlZS1hbmNob3JcIiwgJC5wcm94eShmdW5jdGlvbiAoZSkge1xuXHRcdFx0XHRcdFx0aWYoZS50YXJnZXQudGFnTmFtZSAmJiBlLnRhcmdldC50YWdOYW1lLnRvTG93ZXJDYXNlKCkgPT09IFwiaW5wdXRcIikgeyByZXR1cm4gdHJ1ZTsgfVxuXHRcdFx0XHRcdFx0aWYodGhpcy5zZXR0aW5ncy5jb3JlLmRibGNsaWNrX3RvZ2dsZSkge1xuXHRcdFx0XHRcdFx0XHR0aGlzLnRvZ2dsZV9ub2RlKGUudGFyZ2V0KTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9LCB0aGlzKSlcblx0XHRcdFx0Lm9uKFwiY2xpY2suanN0cmVlXCIsIFwiLmpzdHJlZS1hbmNob3JcIiwgJC5wcm94eShmdW5jdGlvbiAoZSkge1xuXHRcdFx0XHRcdFx0ZS5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0XHRcdFx0aWYoZS5jdXJyZW50VGFyZ2V0ICE9PSBkb2N1bWVudC5hY3RpdmVFbGVtZW50KSB7ICQoZS5jdXJyZW50VGFyZ2V0KS5mb2N1cygpOyB9XG5cdFx0XHRcdFx0XHR0aGlzLmFjdGl2YXRlX25vZGUoZS5jdXJyZW50VGFyZ2V0LCBlKTtcblx0XHRcdFx0XHR9LCB0aGlzKSlcblx0XHRcdFx0Lm9uKCdrZXlkb3duLmpzdHJlZScsICcuanN0cmVlLWFuY2hvcicsICQucHJveHkoZnVuY3Rpb24gKGUpIHtcblx0XHRcdFx0XHRcdGlmKGUudGFyZ2V0LnRhZ05hbWUgJiYgZS50YXJnZXQudGFnTmFtZS50b0xvd2VyQ2FzZSgpID09PSBcImlucHV0XCIpIHsgcmV0dXJuIHRydWU7IH1cblx0XHRcdFx0XHRcdGlmKGUud2hpY2ggIT09IDMyICYmIGUud2hpY2ggIT09IDEzICYmIChlLnNoaWZ0S2V5IHx8IGUuY3RybEtleSB8fCBlLmFsdEtleSB8fCBlLm1ldGFLZXkpKSB7IHJldHVybiB0cnVlOyB9XG5cdFx0XHRcdFx0XHR2YXIgbyA9IG51bGw7XG5cdFx0XHRcdFx0XHRpZih0aGlzLl9kYXRhLmNvcmUucnRsKSB7XG5cdFx0XHRcdFx0XHRcdGlmKGUud2hpY2ggPT09IDM3KSB7IGUud2hpY2ggPSAzOTsgfVxuXHRcdFx0XHRcdFx0XHRlbHNlIGlmKGUud2hpY2ggPT09IDM5KSB7IGUud2hpY2ggPSAzNzsgfVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0c3dpdGNoKGUud2hpY2gpIHtcblx0XHRcdFx0XHRcdFx0Y2FzZSAzMjogLy8gYXJpYSBkZWZpbmVzIHNwYWNlIG9ubHkgd2l0aCBDdHJsXG5cdFx0XHRcdFx0XHRcdFx0aWYoZS5jdHJsS2V5KSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRlLnR5cGUgPSBcImNsaWNrXCI7XG5cdFx0XHRcdFx0XHRcdFx0XHQkKGUuY3VycmVudFRhcmdldCkudHJpZ2dlcihlKTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRcdGNhc2UgMTM6IC8vIGVudGVyXG5cdFx0XHRcdFx0XHRcdFx0ZS50eXBlID0gXCJjbGlja1wiO1xuXHRcdFx0XHRcdFx0XHRcdCQoZS5jdXJyZW50VGFyZ2V0KS50cmlnZ2VyKGUpO1xuXHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0XHRjYXNlIDM3OiAvLyBsZWZ0XG5cdFx0XHRcdFx0XHRcdFx0ZS5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0XHRcdFx0XHRcdGlmKHRoaXMuaXNfb3BlbihlLmN1cnJlbnRUYXJnZXQpKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHR0aGlzLmNsb3NlX25vZGUoZS5jdXJyZW50VGFyZ2V0KTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRvID0gdGhpcy5nZXRfcGFyZW50KGUuY3VycmVudFRhcmdldCk7XG5cdFx0XHRcdFx0XHRcdFx0XHRpZihvICYmIG8uaWQgIT09ICQuanN0cmVlLnJvb3QpIHsgdGhpcy5nZXRfbm9kZShvLCB0cnVlKS5jaGlsZHJlbignLmpzdHJlZS1hbmNob3InKS5mb2N1cygpOyB9XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0XHRjYXNlIDM4OiAvLyB1cFxuXHRcdFx0XHRcdFx0XHRcdGUucHJldmVudERlZmF1bHQoKTtcblx0XHRcdFx0XHRcdFx0XHRvID0gdGhpcy5nZXRfcHJldl9kb20oZS5jdXJyZW50VGFyZ2V0KTtcblx0XHRcdFx0XHRcdFx0XHRpZihvICYmIG8ubGVuZ3RoKSB7IG8uY2hpbGRyZW4oJy5qc3RyZWUtYW5jaG9yJykuZm9jdXMoKTsgfVxuXHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0XHRjYXNlIDM5OiAvLyByaWdodFxuXHRcdFx0XHRcdFx0XHRcdGUucHJldmVudERlZmF1bHQoKTtcblx0XHRcdFx0XHRcdFx0XHRpZih0aGlzLmlzX2Nsb3NlZChlLmN1cnJlbnRUYXJnZXQpKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHR0aGlzLm9wZW5fbm9kZShlLmN1cnJlbnRUYXJnZXQsIGZ1bmN0aW9uIChvKSB7IHRoaXMuZ2V0X25vZGUobywgdHJ1ZSkuY2hpbGRyZW4oJy5qc3RyZWUtYW5jaG9yJykuZm9jdXMoKTsgfSk7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdGVsc2UgaWYgKHRoaXMuaXNfb3BlbihlLmN1cnJlbnRUYXJnZXQpKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRvID0gdGhpcy5nZXRfbm9kZShlLmN1cnJlbnRUYXJnZXQsIHRydWUpLmNoaWxkcmVuKCcuanN0cmVlLWNoaWxkcmVuJylbMF07XG5cdFx0XHRcdFx0XHRcdFx0XHRpZihvKSB7ICQodGhpcy5fZmlyc3RDaGlsZChvKSkuY2hpbGRyZW4oJy5qc3RyZWUtYW5jaG9yJykuZm9jdXMoKTsgfVxuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdFx0Y2FzZSA0MDogLy8gZG93blxuXHRcdFx0XHRcdFx0XHRcdGUucHJldmVudERlZmF1bHQoKTtcblx0XHRcdFx0XHRcdFx0XHRvID0gdGhpcy5nZXRfbmV4dF9kb20oZS5jdXJyZW50VGFyZ2V0KTtcblx0XHRcdFx0XHRcdFx0XHRpZihvICYmIG8ubGVuZ3RoKSB7IG8uY2hpbGRyZW4oJy5qc3RyZWUtYW5jaG9yJykuZm9jdXMoKTsgfVxuXHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0XHRjYXNlIDEwNjogLy8gYXJpYSBkZWZpbmVzICogb24gbnVtcGFkIGFzIG9wZW5fYWxsIC0gbm90IHZlcnkgY29tbW9uXG5cdFx0XHRcdFx0XHRcdFx0dGhpcy5vcGVuX2FsbCgpO1xuXHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0XHRjYXNlIDM2OiAvLyBob21lXG5cdFx0XHRcdFx0XHRcdFx0ZS5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0XHRcdFx0XHRcdG8gPSB0aGlzLl9maXJzdENoaWxkKHRoaXMuZ2V0X2NvbnRhaW5lcl91bCgpWzBdKTtcblx0XHRcdFx0XHRcdFx0XHRpZihvKSB7ICQobykuY2hpbGRyZW4oJy5qc3RyZWUtYW5jaG9yJykuZmlsdGVyKCc6dmlzaWJsZScpLmZvY3VzKCk7IH1cblx0XHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdFx0Y2FzZSAzNTogLy8gZW5kXG5cdFx0XHRcdFx0XHRcdFx0ZS5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0XHRcdFx0XHRcdHRoaXMuZWxlbWVudC5maW5kKCcuanN0cmVlLWFuY2hvcicpLmZpbHRlcignOnZpc2libGUnKS5sYXN0KCkuZm9jdXMoKTtcblx0XHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdFx0Y2FzZSAxMTM6IC8vIGYyIC0gc2FmZSB0byBpbmNsdWRlIC0gaWYgY2hlY2tfY2FsbGJhY2sgaXMgZmFsc2UgaXQgd2lsbCBmYWlsXG5cdFx0XHRcdFx0XHRcdFx0ZS5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0XHRcdFx0XHRcdHRoaXMuZWRpdChlLmN1cnJlbnRUYXJnZXQpO1xuXHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0XHQvKiFcblx0XHRcdFx0XHRcdFx0Ly8gZGVsZXRlXG5cdFx0XHRcdFx0XHRcdGNhc2UgNDY6XG5cdFx0XHRcdFx0XHRcdFx0ZS5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0XHRcdFx0XHRcdG8gPSB0aGlzLmdldF9ub2RlKGUuY3VycmVudFRhcmdldCk7XG5cdFx0XHRcdFx0XHRcdFx0aWYobyAmJiBvLmlkICYmIG8uaWQgIT09ICQuanN0cmVlLnJvb3QpIHtcblx0XHRcdFx0XHRcdFx0XHRcdG8gPSB0aGlzLmlzX3NlbGVjdGVkKG8pID8gdGhpcy5nZXRfc2VsZWN0ZWQoKSA6IG87XG5cdFx0XHRcdFx0XHRcdFx0XHR0aGlzLmRlbGV0ZV9ub2RlKG8pO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdFx0XHQqL1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0sIHRoaXMpKVxuXHRcdFx0XHQub24oXCJsb2FkX25vZGUuanN0cmVlXCIsICQucHJveHkoZnVuY3Rpb24gKGUsIGRhdGEpIHtcblx0XHRcdFx0XHRcdGlmKGRhdGEuc3RhdHVzKSB7XG5cdFx0XHRcdFx0XHRcdGlmKGRhdGEubm9kZS5pZCA9PT0gJC5qc3RyZWUucm9vdCAmJiAhdGhpcy5fZGF0YS5jb3JlLmxvYWRlZCkge1xuXHRcdFx0XHRcdFx0XHRcdHRoaXMuX2RhdGEuY29yZS5sb2FkZWQgPSB0cnVlO1xuXHRcdFx0XHRcdFx0XHRcdGlmKHRoaXMuX2ZpcnN0Q2hpbGQodGhpcy5nZXRfY29udGFpbmVyX3VsKClbMF0pKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHR0aGlzLmVsZW1lbnQuYXR0cignYXJpYS1hY3RpdmVkZXNjZW5kYW50Jyx0aGlzLl9maXJzdENoaWxkKHRoaXMuZ2V0X2NvbnRhaW5lcl91bCgpWzBdKS5pZCk7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdC8qKlxuXHRcdFx0XHRcdFx0XHRcdCAqIHRyaWdnZXJlZCBhZnRlciB0aGUgcm9vdCBub2RlIGlzIGxvYWRlZCBmb3IgdGhlIGZpcnN0IHRpbWVcblx0XHRcdFx0XHRcdFx0XHQgKiBAZXZlbnRcblx0XHRcdFx0XHRcdFx0XHQgKiBAbmFtZSBsb2FkZWQuanN0cmVlXG5cdFx0XHRcdFx0XHRcdFx0ICovXG5cdFx0XHRcdFx0XHRcdFx0dGhpcy50cmlnZ2VyKFwibG9hZGVkXCIpO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdGlmKCF0aGlzLl9kYXRhLmNvcmUucmVhZHkpIHtcblx0XHRcdFx0XHRcdFx0XHRzZXRUaW1lb3V0KCQucHJveHkoZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRpZih0aGlzLmVsZW1lbnQgJiYgIXRoaXMuZ2V0X2NvbnRhaW5lcl91bCgpLmZpbmQoJy5qc3RyZWUtbG9hZGluZycpLmxlbmd0aCkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0aGlzLl9kYXRhLmNvcmUucmVhZHkgPSB0cnVlO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZih0aGlzLl9kYXRhLmNvcmUuc2VsZWN0ZWQubGVuZ3RoKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0aWYodGhpcy5zZXR0aW5ncy5jb3JlLmV4cGFuZF9zZWxlY3RlZF9vbmxvYWQpIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHZhciB0bXAgPSBbXSwgaSwgajtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGZvcihpID0gMCwgaiA9IHRoaXMuX2RhdGEuY29yZS5zZWxlY3RlZC5sZW5ndGg7IGkgPCBqOyBpKyspIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0dG1wID0gdG1wLmNvbmNhdCh0aGlzLl9tb2RlbC5kYXRhW3RoaXMuX2RhdGEuY29yZS5zZWxlY3RlZFtpXV0ucGFyZW50cyk7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR0bXAgPSAkLnZha2F0YS5hcnJheV91bmlxdWUodG1wKTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGZvcihpID0gMCwgaiA9IHRtcC5sZW5ndGg7IGkgPCBqOyBpKyspIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0dGhpcy5vcGVuX25vZGUodG1wW2ldLCBmYWxzZSwgMCk7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHRoaXMudHJpZ2dlcignY2hhbmdlZCcsIHsgJ2FjdGlvbicgOiAncmVhZHknLCAnc2VsZWN0ZWQnIDogdGhpcy5fZGF0YS5jb3JlLnNlbGVjdGVkIH0pO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8qKlxuXHRcdFx0XHRcdFx0XHRcdFx0XHQgKiB0cmlnZ2VyZWQgYWZ0ZXIgYWxsIG5vZGVzIGFyZSBmaW5pc2hlZCBsb2FkaW5nXG5cdFx0XHRcdFx0XHRcdFx0XHRcdCAqIEBldmVudFxuXHRcdFx0XHRcdFx0XHRcdFx0XHQgKiBAbmFtZSByZWFkeS5qc3RyZWVcblx0XHRcdFx0XHRcdFx0XHRcdFx0ICovXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHRoaXMudHJpZ2dlcihcInJlYWR5XCIpO1xuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH0sIHRoaXMpLCAwKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0sIHRoaXMpKVxuXHRcdFx0XHQvLyBxdWljayBzZWFyY2hpbmcgd2hlbiB0aGUgdHJlZSBpcyBmb2N1c2VkXG5cdFx0XHRcdC5vbigna2V5cHJlc3MuanN0cmVlJywgJC5wcm94eShmdW5jdGlvbiAoZSkge1xuXHRcdFx0XHRcdFx0aWYoZS50YXJnZXQudGFnTmFtZSAmJiBlLnRhcmdldC50YWdOYW1lLnRvTG93ZXJDYXNlKCkgPT09IFwiaW5wdXRcIikgeyByZXR1cm4gdHJ1ZTsgfVxuXHRcdFx0XHRcdFx0aWYodG91dCkgeyBjbGVhclRpbWVvdXQodG91dCk7IH1cblx0XHRcdFx0XHRcdHRvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0XHRcdFx0d29yZCA9ICcnO1xuXHRcdFx0XHRcdFx0fSwgNTAwKTtcblxuXHRcdFx0XHRcdFx0dmFyIGNociA9IFN0cmluZy5mcm9tQ2hhckNvZGUoZS53aGljaCkudG9Mb3dlckNhc2UoKSxcblx0XHRcdFx0XHRcdFx0Y29sID0gdGhpcy5lbGVtZW50LmZpbmQoJy5qc3RyZWUtYW5jaG9yJykuZmlsdGVyKCc6dmlzaWJsZScpLFxuXHRcdFx0XHRcdFx0XHRpbmQgPSBjb2wuaW5kZXgoZG9jdW1lbnQuYWN0aXZlRWxlbWVudCkgfHwgMCxcblx0XHRcdFx0XHRcdFx0ZW5kID0gZmFsc2U7XG5cdFx0XHRcdFx0XHR3b3JkICs9IGNocjtcblxuXHRcdFx0XHRcdFx0Ly8gbWF0Y2ggZm9yIHdob2xlIHdvcmQgZnJvbSBjdXJyZW50IG5vZGUgZG93biAoaW5jbHVkaW5nIHRoZSBjdXJyZW50IG5vZGUpXG5cdFx0XHRcdFx0XHRpZih3b3JkLmxlbmd0aCA+IDEpIHtcblx0XHRcdFx0XHRcdFx0Y29sLnNsaWNlKGluZCkuZWFjaCgkLnByb3h5KGZ1bmN0aW9uIChpLCB2KSB7XG5cdFx0XHRcdFx0XHRcdFx0aWYoJCh2KS50ZXh0KCkudG9Mb3dlckNhc2UoKS5pbmRleE9mKHdvcmQpID09PSAwKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHQkKHYpLmZvY3VzKCk7XG5cdFx0XHRcdFx0XHRcdFx0XHRlbmQgPSB0cnVlO1xuXHRcdFx0XHRcdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fSwgdGhpcykpO1xuXHRcdFx0XHRcdFx0XHRpZihlbmQpIHsgcmV0dXJuOyB9XG5cblx0XHRcdFx0XHRcdFx0Ly8gbWF0Y2ggZm9yIHdob2xlIHdvcmQgZnJvbSB0aGUgYmVnaW5uaW5nIG9mIHRoZSB0cmVlXG5cdFx0XHRcdFx0XHRcdGNvbC5zbGljZSgwLCBpbmQpLmVhY2goJC5wcm94eShmdW5jdGlvbiAoaSwgdikge1xuXHRcdFx0XHRcdFx0XHRcdGlmKCQodikudGV4dCgpLnRvTG93ZXJDYXNlKCkuaW5kZXhPZih3b3JkKSA9PT0gMCkge1xuXHRcdFx0XHRcdFx0XHRcdFx0JCh2KS5mb2N1cygpO1xuXHRcdFx0XHRcdFx0XHRcdFx0ZW5kID0gdHJ1ZTtcblx0XHRcdFx0XHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0sIHRoaXMpKTtcblx0XHRcdFx0XHRcdFx0aWYoZW5kKSB7IHJldHVybjsgfVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0Ly8gbGlzdCBub2RlcyB0aGF0IHN0YXJ0IHdpdGggdGhhdCBsZXR0ZXIgKG9ubHkgaWYgd29yZCBjb25zaXN0cyBvZiBhIHNpbmdsZSBjaGFyKVxuXHRcdFx0XHRcdFx0aWYobmV3IFJlZ0V4cCgnXicgKyBjaHIucmVwbGFjZSgvWy1cXC9cXFxcXiQqKz8uKCl8W1xcXXt9XS9nLCAnXFxcXCQmJykgKyAnKyQnKS50ZXN0KHdvcmQpKSB7XG5cdFx0XHRcdFx0XHRcdC8vIHNlYXJjaCBmb3IgdGhlIG5leHQgbm9kZSBzdGFydGluZyB3aXRoIHRoYXQgbGV0dGVyXG5cdFx0XHRcdFx0XHRcdGNvbC5zbGljZShpbmQgKyAxKS5lYWNoKCQucHJveHkoZnVuY3Rpb24gKGksIHYpIHtcblx0XHRcdFx0XHRcdFx0XHRpZigkKHYpLnRleHQoKS50b0xvd2VyQ2FzZSgpLmNoYXJBdCgwKSA9PT0gY2hyKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHQkKHYpLmZvY3VzKCk7XG5cdFx0XHRcdFx0XHRcdFx0XHRlbmQgPSB0cnVlO1xuXHRcdFx0XHRcdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fSwgdGhpcykpO1xuXHRcdFx0XHRcdFx0XHRpZihlbmQpIHsgcmV0dXJuOyB9XG5cblx0XHRcdFx0XHRcdFx0Ly8gc2VhcmNoIGZyb20gdGhlIGJlZ2lubmluZ1xuXHRcdFx0XHRcdFx0XHRjb2wuc2xpY2UoMCwgaW5kICsgMSkuZWFjaCgkLnByb3h5KGZ1bmN0aW9uIChpLCB2KSB7XG5cdFx0XHRcdFx0XHRcdFx0aWYoJCh2KS50ZXh0KCkudG9Mb3dlckNhc2UoKS5jaGFyQXQoMCkgPT09IGNocikge1xuXHRcdFx0XHRcdFx0XHRcdFx0JCh2KS5mb2N1cygpO1xuXHRcdFx0XHRcdFx0XHRcdFx0ZW5kID0gdHJ1ZTtcblx0XHRcdFx0XHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0sIHRoaXMpKTtcblx0XHRcdFx0XHRcdFx0aWYoZW5kKSB7IHJldHVybjsgfVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0sIHRoaXMpKVxuXHRcdFx0XHQvLyBUSEVNRSBSRUxBVEVEXG5cdFx0XHRcdC5vbihcImluaXQuanN0cmVlXCIsICQucHJveHkoZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdFx0dmFyIHMgPSB0aGlzLnNldHRpbmdzLmNvcmUudGhlbWVzO1xuXHRcdFx0XHRcdFx0dGhpcy5fZGF0YS5jb3JlLnRoZW1lcy5kb3RzXHRcdFx0PSBzLmRvdHM7XG5cdFx0XHRcdFx0XHR0aGlzLl9kYXRhLmNvcmUudGhlbWVzLnN0cmlwZXNcdFx0PSBzLnN0cmlwZXM7XG5cdFx0XHRcdFx0XHR0aGlzLl9kYXRhLmNvcmUudGhlbWVzLmljb25zXHRcdD0gcy5pY29ucztcblx0XHRcdFx0XHRcdHRoaXMuX2RhdGEuY29yZS50aGVtZXMuZWxsaXBzaXNcdFx0PSBzLmVsbGlwc2lzO1xuXHRcdFx0XHRcdFx0dGhpcy5zZXRfdGhlbWUocy5uYW1lIHx8IFwiZGVmYXVsdFwiLCBzLnVybCk7XG5cdFx0XHRcdFx0XHR0aGlzLnNldF90aGVtZV92YXJpYW50KHMudmFyaWFudCk7XG5cdFx0XHRcdFx0fSwgdGhpcykpXG5cdFx0XHRcdC5vbihcImxvYWRpbmcuanN0cmVlXCIsICQucHJveHkoZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdFx0dGhpc1sgdGhpcy5fZGF0YS5jb3JlLnRoZW1lcy5kb3RzID8gXCJzaG93X2RvdHNcIiA6IFwiaGlkZV9kb3RzXCIgXSgpO1xuXHRcdFx0XHRcdFx0dGhpc1sgdGhpcy5fZGF0YS5jb3JlLnRoZW1lcy5pY29ucyA/IFwic2hvd19pY29uc1wiIDogXCJoaWRlX2ljb25zXCIgXSgpO1xuXHRcdFx0XHRcdFx0dGhpc1sgdGhpcy5fZGF0YS5jb3JlLnRoZW1lcy5zdHJpcGVzID8gXCJzaG93X3N0cmlwZXNcIiA6IFwiaGlkZV9zdHJpcGVzXCIgXSgpO1xuXHRcdFx0XHRcdFx0dGhpc1sgdGhpcy5fZGF0YS5jb3JlLnRoZW1lcy5lbGxpcHNpcyA/IFwic2hvd19lbGxpcHNpc1wiIDogXCJoaWRlX2VsbGlwc2lzXCIgXSgpO1xuXHRcdFx0XHRcdH0sIHRoaXMpKVxuXHRcdFx0XHQub24oJ2JsdXIuanN0cmVlJywgJy5qc3RyZWUtYW5jaG9yJywgJC5wcm94eShmdW5jdGlvbiAoZSkge1xuXHRcdFx0XHRcdFx0dGhpcy5fZGF0YS5jb3JlLmZvY3VzZWQgPSBudWxsO1xuXHRcdFx0XHRcdFx0JChlLmN1cnJlbnRUYXJnZXQpLmZpbHRlcignLmpzdHJlZS1ob3ZlcmVkJykubW91c2VsZWF2ZSgpO1xuXHRcdFx0XHRcdFx0dGhpcy5lbGVtZW50LmF0dHIoJ3RhYmluZGV4JywgJzAnKTtcblx0XHRcdFx0XHR9LCB0aGlzKSlcblx0XHRcdFx0Lm9uKCdmb2N1cy5qc3RyZWUnLCAnLmpzdHJlZS1hbmNob3InLCAkLnByb3h5KGZ1bmN0aW9uIChlKSB7XG5cdFx0XHRcdFx0XHR2YXIgdG1wID0gdGhpcy5nZXRfbm9kZShlLmN1cnJlbnRUYXJnZXQpO1xuXHRcdFx0XHRcdFx0aWYodG1wICYmIHRtcC5pZCkge1xuXHRcdFx0XHRcdFx0XHR0aGlzLl9kYXRhLmNvcmUuZm9jdXNlZCA9IHRtcC5pZDtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdHRoaXMuZWxlbWVudC5maW5kKCcuanN0cmVlLWhvdmVyZWQnKS5ub3QoZS5jdXJyZW50VGFyZ2V0KS5tb3VzZWxlYXZlKCk7XG5cdFx0XHRcdFx0XHQkKGUuY3VycmVudFRhcmdldCkubW91c2VlbnRlcigpO1xuXHRcdFx0XHRcdFx0dGhpcy5lbGVtZW50LmF0dHIoJ3RhYmluZGV4JywgJy0xJyk7XG5cdFx0XHRcdFx0fSwgdGhpcykpXG5cdFx0XHRcdC5vbignZm9jdXMuanN0cmVlJywgJC5wcm94eShmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdFx0XHRpZigrKG5ldyBEYXRlKCkpIC0gd2FzX2NsaWNrID4gNTAwICYmICF0aGlzLl9kYXRhLmNvcmUuZm9jdXNlZCkge1xuXHRcdFx0XHRcdFx0XHR3YXNfY2xpY2sgPSAwO1xuXHRcdFx0XHRcdFx0XHR2YXIgYWN0ID0gdGhpcy5nZXRfbm9kZSh0aGlzLmVsZW1lbnQuYXR0cignYXJpYS1hY3RpdmVkZXNjZW5kYW50JyksIHRydWUpO1xuXHRcdFx0XHRcdFx0XHRpZihhY3QpIHtcblx0XHRcdFx0XHRcdFx0XHRhY3QuZmluZCgnPiAuanN0cmVlLWFuY2hvcicpLmZvY3VzKCk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9LCB0aGlzKSlcblx0XHRcdFx0Lm9uKCdtb3VzZWVudGVyLmpzdHJlZScsICcuanN0cmVlLWFuY2hvcicsICQucHJveHkoZnVuY3Rpb24gKGUpIHtcblx0XHRcdFx0XHRcdHRoaXMuaG92ZXJfbm9kZShlLmN1cnJlbnRUYXJnZXQpO1xuXHRcdFx0XHRcdH0sIHRoaXMpKVxuXHRcdFx0XHQub24oJ21vdXNlbGVhdmUuanN0cmVlJywgJy5qc3RyZWUtYW5jaG9yJywgJC5wcm94eShmdW5jdGlvbiAoZSkge1xuXHRcdFx0XHRcdFx0dGhpcy5kZWhvdmVyX25vZGUoZS5jdXJyZW50VGFyZ2V0KTtcblx0XHRcdFx0XHR9LCB0aGlzKSk7XG5cdFx0fSxcblx0XHQvKipcblx0XHQgKiBwYXJ0IG9mIHRoZSBkZXN0cm95aW5nIG9mIGFuIGluc3RhbmNlLiBVc2VkIGludGVybmFsbHkuXG5cdFx0ICogQHByaXZhdGVcblx0XHQgKiBAbmFtZSB1bmJpbmQoKVxuXHRcdCAqL1xuXHRcdHVuYmluZCA6IGZ1bmN0aW9uICgpIHtcblx0XHRcdHRoaXMuZWxlbWVudC5vZmYoJy5qc3RyZWUnKTtcblx0XHRcdCQoZG9jdW1lbnQpLm9mZignLmpzdHJlZS0nICsgdGhpcy5faWQpO1xuXHRcdH0sXG5cdFx0LyoqXG5cdFx0ICogdHJpZ2dlciBhbiBldmVudC4gVXNlZCBpbnRlcm5hbGx5LlxuXHRcdCAqIEBwcml2YXRlXG5cdFx0ICogQG5hbWUgdHJpZ2dlcihldiBbLCBkYXRhXSlcblx0XHQgKiBAcGFyYW0gIHtTdHJpbmd9IGV2IHRoZSBuYW1lIG9mIHRoZSBldmVudCB0byB0cmlnZ2VyXG5cdFx0ICogQHBhcmFtICB7T2JqZWN0fSBkYXRhIGFkZGl0aW9uYWwgZGF0YSB0byBwYXNzIHdpdGggdGhlIGV2ZW50XG5cdFx0ICovXG5cdFx0dHJpZ2dlciA6IGZ1bmN0aW9uIChldiwgZGF0YSkge1xuXHRcdFx0aWYoIWRhdGEpIHtcblx0XHRcdFx0ZGF0YSA9IHt9O1xuXHRcdFx0fVxuXHRcdFx0ZGF0YS5pbnN0YW5jZSA9IHRoaXM7XG5cdFx0XHR0aGlzLmVsZW1lbnQudHJpZ2dlckhhbmRsZXIoZXYucmVwbGFjZSgnLmpzdHJlZScsJycpICsgJy5qc3RyZWUnLCBkYXRhKTtcblx0XHR9LFxuXHRcdC8qKlxuXHRcdCAqIHJldHVybnMgdGhlIGpRdWVyeSBleHRlbmRlZCBpbnN0YW5jZSBjb250YWluZXJcblx0XHQgKiBAbmFtZSBnZXRfY29udGFpbmVyKClcblx0XHQgKiBAcmV0dXJuIHtqUXVlcnl9XG5cdFx0ICovXG5cdFx0Z2V0X2NvbnRhaW5lciA6IGZ1bmN0aW9uICgpIHtcblx0XHRcdHJldHVybiB0aGlzLmVsZW1lbnQ7XG5cdFx0fSxcblx0XHQvKipcblx0XHQgKiByZXR1cm5zIHRoZSBqUXVlcnkgZXh0ZW5kZWQgbWFpbiBVTCBub2RlIGluc2lkZSB0aGUgaW5zdGFuY2UgY29udGFpbmVyLiBVc2VkIGludGVybmFsbHkuXG5cdFx0ICogQHByaXZhdGVcblx0XHQgKiBAbmFtZSBnZXRfY29udGFpbmVyX3VsKClcblx0XHQgKiBAcmV0dXJuIHtqUXVlcnl9XG5cdFx0ICovXG5cdFx0Z2V0X2NvbnRhaW5lcl91bCA6IGZ1bmN0aW9uICgpIHtcblx0XHRcdHJldHVybiB0aGlzLmVsZW1lbnQuY2hpbGRyZW4oXCIuanN0cmVlLWNoaWxkcmVuXCIpLmZpcnN0KCk7XG5cdFx0fSxcblx0XHQvKipcblx0XHQgKiBnZXRzIHN0cmluZyByZXBsYWNlbWVudHMgKGxvY2FsaXphdGlvbikuIFVzZWQgaW50ZXJuYWxseS5cblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqIEBuYW1lIGdldF9zdHJpbmcoa2V5KVxuXHRcdCAqIEBwYXJhbSAge1N0cmluZ30ga2V5XG5cdFx0ICogQHJldHVybiB7U3RyaW5nfVxuXHRcdCAqL1xuXHRcdGdldF9zdHJpbmcgOiBmdW5jdGlvbiAoa2V5KSB7XG5cdFx0XHR2YXIgYSA9IHRoaXMuc2V0dGluZ3MuY29yZS5zdHJpbmdzO1xuXHRcdFx0aWYoJC5pc0Z1bmN0aW9uKGEpKSB7IHJldHVybiBhLmNhbGwodGhpcywga2V5KTsgfVxuXHRcdFx0aWYoYSAmJiBhW2tleV0pIHsgcmV0dXJuIGFba2V5XTsgfVxuXHRcdFx0cmV0dXJuIGtleTtcblx0XHR9LFxuXHRcdC8qKlxuXHRcdCAqIGdldHMgdGhlIGZpcnN0IGNoaWxkIG9mIGEgRE9NIG5vZGUuIFVzZWQgaW50ZXJuYWxseS5cblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqIEBuYW1lIF9maXJzdENoaWxkKGRvbSlcblx0XHQgKiBAcGFyYW0gIHtET01FbGVtZW50fSBkb21cblx0XHQgKiBAcmV0dXJuIHtET01FbGVtZW50fVxuXHRcdCAqL1xuXHRcdF9maXJzdENoaWxkIDogZnVuY3Rpb24gKGRvbSkge1xuXHRcdFx0ZG9tID0gZG9tID8gZG9tLmZpcnN0Q2hpbGQgOiBudWxsO1xuXHRcdFx0d2hpbGUoZG9tICE9PSBudWxsICYmIGRvbS5ub2RlVHlwZSAhPT0gMSkge1xuXHRcdFx0XHRkb20gPSBkb20ubmV4dFNpYmxpbmc7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gZG9tO1xuXHRcdH0sXG5cdFx0LyoqXG5cdFx0ICogZ2V0cyB0aGUgbmV4dCBzaWJsaW5nIG9mIGEgRE9NIG5vZGUuIFVzZWQgaW50ZXJuYWxseS5cblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqIEBuYW1lIF9uZXh0U2libGluZyhkb20pXG5cdFx0ICogQHBhcmFtICB7RE9NRWxlbWVudH0gZG9tXG5cdFx0ICogQHJldHVybiB7RE9NRWxlbWVudH1cblx0XHQgKi9cblx0XHRfbmV4dFNpYmxpbmcgOiBmdW5jdGlvbiAoZG9tKSB7XG5cdFx0XHRkb20gPSBkb20gPyBkb20ubmV4dFNpYmxpbmcgOiBudWxsO1xuXHRcdFx0d2hpbGUoZG9tICE9PSBudWxsICYmIGRvbS5ub2RlVHlwZSAhPT0gMSkge1xuXHRcdFx0XHRkb20gPSBkb20ubmV4dFNpYmxpbmc7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gZG9tO1xuXHRcdH0sXG5cdFx0LyoqXG5cdFx0ICogZ2V0cyB0aGUgcHJldmlvdXMgc2libGluZyBvZiBhIERPTSBub2RlLiBVc2VkIGludGVybmFsbHkuXG5cdFx0ICogQHByaXZhdGVcblx0XHQgKiBAbmFtZSBfcHJldmlvdXNTaWJsaW5nKGRvbSlcblx0XHQgKiBAcGFyYW0gIHtET01FbGVtZW50fSBkb21cblx0XHQgKiBAcmV0dXJuIHtET01FbGVtZW50fVxuXHRcdCAqL1xuXHRcdF9wcmV2aW91c1NpYmxpbmcgOiBmdW5jdGlvbiAoZG9tKSB7XG5cdFx0XHRkb20gPSBkb20gPyBkb20ucHJldmlvdXNTaWJsaW5nIDogbnVsbDtcblx0XHRcdHdoaWxlKGRvbSAhPT0gbnVsbCAmJiBkb20ubm9kZVR5cGUgIT09IDEpIHtcblx0XHRcdFx0ZG9tID0gZG9tLnByZXZpb3VzU2libGluZztcblx0XHRcdH1cblx0XHRcdHJldHVybiBkb207XG5cdFx0fSxcblx0XHQvKipcblx0XHQgKiBnZXQgdGhlIEpTT04gcmVwcmVzZW50YXRpb24gb2YgYSBub2RlIChvciB0aGUgYWN0dWFsIGpRdWVyeSBleHRlbmRlZCBET00gbm9kZSkgYnkgdXNpbmcgYW55IGlucHV0IChjaGlsZCBET00gZWxlbWVudCwgSUQgc3RyaW5nLCBzZWxlY3RvciwgZXRjKVxuXHRcdCAqIEBuYW1lIGdldF9ub2RlKG9iaiBbLCBhc19kb21dKVxuXHRcdCAqIEBwYXJhbSAge21peGVkfSBvYmpcblx0XHQgKiBAcGFyYW0gIHtCb29sZWFufSBhc19kb21cblx0XHQgKiBAcmV0dXJuIHtPYmplY3R8alF1ZXJ5fVxuXHRcdCAqL1xuXHRcdGdldF9ub2RlIDogZnVuY3Rpb24gKG9iaiwgYXNfZG9tKSB7XG5cdFx0XHRpZihvYmogJiYgb2JqLmlkKSB7XG5cdFx0XHRcdG9iaiA9IG9iai5pZDtcblx0XHRcdH1cblx0XHRcdHZhciBkb207XG5cdFx0XHR0cnkge1xuXHRcdFx0XHRpZih0aGlzLl9tb2RlbC5kYXRhW29ial0pIHtcblx0XHRcdFx0XHRvYmogPSB0aGlzLl9tb2RlbC5kYXRhW29ial07XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSBpZih0eXBlb2Ygb2JqID09PSBcInN0cmluZ1wiICYmIHRoaXMuX21vZGVsLmRhdGFbb2JqLnJlcGxhY2UoL14jLywgJycpXSkge1xuXHRcdFx0XHRcdG9iaiA9IHRoaXMuX21vZGVsLmRhdGFbb2JqLnJlcGxhY2UoL14jLywgJycpXTtcblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIGlmKHR5cGVvZiBvYmogPT09IFwic3RyaW5nXCIgJiYgKGRvbSA9ICQoJyMnICsgb2JqLnJlcGxhY2UoJC5qc3RyZWUuaWRyZWdleCwnXFxcXCQmJyksIHRoaXMuZWxlbWVudCkpLmxlbmd0aCAmJiB0aGlzLl9tb2RlbC5kYXRhW2RvbS5jbG9zZXN0KCcuanN0cmVlLW5vZGUnKS5hdHRyKCdpZCcpXSkge1xuXHRcdFx0XHRcdG9iaiA9IHRoaXMuX21vZGVsLmRhdGFbZG9tLmNsb3Nlc3QoJy5qc3RyZWUtbm9kZScpLmF0dHIoJ2lkJyldO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2UgaWYoKGRvbSA9ICQob2JqLCB0aGlzLmVsZW1lbnQpKS5sZW5ndGggJiYgdGhpcy5fbW9kZWwuZGF0YVtkb20uY2xvc2VzdCgnLmpzdHJlZS1ub2RlJykuYXR0cignaWQnKV0pIHtcblx0XHRcdFx0XHRvYmogPSB0aGlzLl9tb2RlbC5kYXRhW2RvbS5jbG9zZXN0KCcuanN0cmVlLW5vZGUnKS5hdHRyKCdpZCcpXTtcblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIGlmKChkb20gPSAkKG9iaiwgdGhpcy5lbGVtZW50KSkubGVuZ3RoICYmIGRvbS5oYXNDbGFzcygnanN0cmVlJykpIHtcblx0XHRcdFx0XHRvYmogPSB0aGlzLl9tb2RlbC5kYXRhWyQuanN0cmVlLnJvb3RdO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmKGFzX2RvbSkge1xuXHRcdFx0XHRcdG9iaiA9IG9iai5pZCA9PT0gJC5qc3RyZWUucm9vdCA/IHRoaXMuZWxlbWVudCA6ICQoJyMnICsgb2JqLmlkLnJlcGxhY2UoJC5qc3RyZWUuaWRyZWdleCwnXFxcXCQmJyksIHRoaXMuZWxlbWVudCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIG9iajtcblx0XHRcdH0gY2F0Y2ggKGV4KSB7IHJldHVybiBmYWxzZTsgfVxuXHRcdH0sXG5cdFx0LyoqXG5cdFx0ICogZ2V0IHRoZSBwYXRoIHRvIGEgbm9kZSwgZWl0aGVyIGNvbnNpc3Rpbmcgb2Ygbm9kZSB0ZXh0cywgb3Igb2Ygbm9kZSBJRHMsIG9wdGlvbmFsbHkgZ2x1ZWQgdG9nZXRoZXIgKG90aGVyd2lzZSBhbiBhcnJheSlcblx0XHQgKiBAbmFtZSBnZXRfcGF0aChvYmogWywgZ2x1ZSwgaWRzXSlcblx0XHQgKiBAcGFyYW0gIHttaXhlZH0gb2JqIHRoZSBub2RlXG5cdFx0ICogQHBhcmFtICB7U3RyaW5nfSBnbHVlIGlmIHlvdSB3YW50IHRoZSBwYXRoIGFzIGEgc3RyaW5nIC0gcGFzcyB0aGUgZ2x1ZSBoZXJlIChmb3IgZXhhbXBsZSAnLycpLCBpZiBhIGZhbHN5IHZhbHVlIGlzIHN1cHBsaWVkIGhlcmUsIGFuIGFycmF5IGlzIHJldHVybmVkXG5cdFx0ICogQHBhcmFtICB7Qm9vbGVhbn0gaWRzIGlmIHNldCB0byB0cnVlIGJ1aWxkIHRoZSBwYXRoIHVzaW5nIElELCBvdGhlcndpc2Ugbm9kZSB0ZXh0IGlzIHVzZWRcblx0XHQgKiBAcmV0dXJuIHttaXhlZH1cblx0XHQgKi9cblx0XHRnZXRfcGF0aCA6IGZ1bmN0aW9uIChvYmosIGdsdWUsIGlkcykge1xuXHRcdFx0b2JqID0gb2JqLnBhcmVudHMgPyBvYmogOiB0aGlzLmdldF9ub2RlKG9iaik7XG5cdFx0XHRpZighb2JqIHx8IG9iai5pZCA9PT0gJC5qc3RyZWUucm9vdCB8fCAhb2JqLnBhcmVudHMpIHtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXHRcdFx0dmFyIGksIGosIHAgPSBbXTtcblx0XHRcdHAucHVzaChpZHMgPyBvYmouaWQgOiBvYmoudGV4dCk7XG5cdFx0XHRmb3IoaSA9IDAsIGogPSBvYmoucGFyZW50cy5sZW5ndGg7IGkgPCBqOyBpKyspIHtcblx0XHRcdFx0cC5wdXNoKGlkcyA/IG9iai5wYXJlbnRzW2ldIDogdGhpcy5nZXRfdGV4dChvYmoucGFyZW50c1tpXSkpO1xuXHRcdFx0fVxuXHRcdFx0cCA9IHAucmV2ZXJzZSgpLnNsaWNlKDEpO1xuXHRcdFx0cmV0dXJuIGdsdWUgPyBwLmpvaW4oZ2x1ZSkgOiBwO1xuXHRcdH0sXG5cdFx0LyoqXG5cdFx0ICogZ2V0IHRoZSBuZXh0IHZpc2libGUgbm9kZSB0aGF0IGlzIGJlbG93IHRoZSBgb2JqYCBub2RlLiBJZiBgc3RyaWN0YCBpcyBzZXQgdG8gYHRydWVgIG9ubHkgc2libGluZyBub2RlcyBhcmUgcmV0dXJuZWQuXG5cdFx0ICogQG5hbWUgZ2V0X25leHRfZG9tKG9iaiBbLCBzdHJpY3RdKVxuXHRcdCAqIEBwYXJhbSAge21peGVkfSBvYmpcblx0XHQgKiBAcGFyYW0gIHtCb29sZWFufSBzdHJpY3Rcblx0XHQgKiBAcmV0dXJuIHtqUXVlcnl9XG5cdFx0ICovXG5cdFx0Z2V0X25leHRfZG9tIDogZnVuY3Rpb24gKG9iaiwgc3RyaWN0KSB7XG5cdFx0XHR2YXIgdG1wO1xuXHRcdFx0b2JqID0gdGhpcy5nZXRfbm9kZShvYmosIHRydWUpO1xuXHRcdFx0aWYob2JqWzBdID09PSB0aGlzLmVsZW1lbnRbMF0pIHtcblx0XHRcdFx0dG1wID0gdGhpcy5fZmlyc3RDaGlsZCh0aGlzLmdldF9jb250YWluZXJfdWwoKVswXSk7XG5cdFx0XHRcdHdoaWxlICh0bXAgJiYgdG1wLm9mZnNldEhlaWdodCA9PT0gMCkge1xuXHRcdFx0XHRcdHRtcCA9IHRoaXMuX25leHRTaWJsaW5nKHRtcCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHRtcCA/ICQodG1wKSA6IGZhbHNlO1xuXHRcdFx0fVxuXHRcdFx0aWYoIW9iaiB8fCAhb2JqLmxlbmd0aCkge1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cdFx0XHRpZihzdHJpY3QpIHtcblx0XHRcdFx0dG1wID0gb2JqWzBdO1xuXHRcdFx0XHRkbyB7XG5cdFx0XHRcdFx0dG1wID0gdGhpcy5fbmV4dFNpYmxpbmcodG1wKTtcblx0XHRcdFx0fSB3aGlsZSAodG1wICYmIHRtcC5vZmZzZXRIZWlnaHQgPT09IDApO1xuXHRcdFx0XHRyZXR1cm4gdG1wID8gJCh0bXApIDogZmFsc2U7XG5cdFx0XHR9XG5cdFx0XHRpZihvYmouaGFzQ2xhc3MoXCJqc3RyZWUtb3BlblwiKSkge1xuXHRcdFx0XHR0bXAgPSB0aGlzLl9maXJzdENoaWxkKG9iai5jaGlsZHJlbignLmpzdHJlZS1jaGlsZHJlbicpWzBdKTtcblx0XHRcdFx0d2hpbGUgKHRtcCAmJiB0bXAub2Zmc2V0SGVpZ2h0ID09PSAwKSB7XG5cdFx0XHRcdFx0dG1wID0gdGhpcy5fbmV4dFNpYmxpbmcodG1wKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZih0bXAgIT09IG51bGwpIHtcblx0XHRcdFx0XHRyZXR1cm4gJCh0bXApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHR0bXAgPSBvYmpbMF07XG5cdFx0XHRkbyB7XG5cdFx0XHRcdHRtcCA9IHRoaXMuX25leHRTaWJsaW5nKHRtcCk7XG5cdFx0XHR9IHdoaWxlICh0bXAgJiYgdG1wLm9mZnNldEhlaWdodCA9PT0gMCk7XG5cdFx0XHRpZih0bXAgIT09IG51bGwpIHtcblx0XHRcdFx0cmV0dXJuICQodG1wKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBvYmoucGFyZW50c1VudGlsKFwiLmpzdHJlZVwiLFwiLmpzdHJlZS1ub2RlXCIpLm5leHRBbGwoXCIuanN0cmVlLW5vZGU6dmlzaWJsZVwiKS5maXJzdCgpO1xuXHRcdH0sXG5cdFx0LyoqXG5cdFx0ICogZ2V0IHRoZSBwcmV2aW91cyB2aXNpYmxlIG5vZGUgdGhhdCBpcyBhYm92ZSB0aGUgYG9iamAgbm9kZS4gSWYgYHN0cmljdGAgaXMgc2V0IHRvIGB0cnVlYCBvbmx5IHNpYmxpbmcgbm9kZXMgYXJlIHJldHVybmVkLlxuXHRcdCAqIEBuYW1lIGdldF9wcmV2X2RvbShvYmogWywgc3RyaWN0XSlcblx0XHQgKiBAcGFyYW0gIHttaXhlZH0gb2JqXG5cdFx0ICogQHBhcmFtICB7Qm9vbGVhbn0gc3RyaWN0XG5cdFx0ICogQHJldHVybiB7alF1ZXJ5fVxuXHRcdCAqL1xuXHRcdGdldF9wcmV2X2RvbSA6IGZ1bmN0aW9uIChvYmosIHN0cmljdCkge1xuXHRcdFx0dmFyIHRtcDtcblx0XHRcdG9iaiA9IHRoaXMuZ2V0X25vZGUob2JqLCB0cnVlKTtcblx0XHRcdGlmKG9ialswXSA9PT0gdGhpcy5lbGVtZW50WzBdKSB7XG5cdFx0XHRcdHRtcCA9IHRoaXMuZ2V0X2NvbnRhaW5lcl91bCgpWzBdLmxhc3RDaGlsZDtcblx0XHRcdFx0d2hpbGUgKHRtcCAmJiB0bXAub2Zmc2V0SGVpZ2h0ID09PSAwKSB7XG5cdFx0XHRcdFx0dG1wID0gdGhpcy5fcHJldmlvdXNTaWJsaW5nKHRtcCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHRtcCA/ICQodG1wKSA6IGZhbHNlO1xuXHRcdFx0fVxuXHRcdFx0aWYoIW9iaiB8fCAhb2JqLmxlbmd0aCkge1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cdFx0XHRpZihzdHJpY3QpIHtcblx0XHRcdFx0dG1wID0gb2JqWzBdO1xuXHRcdFx0XHRkbyB7XG5cdFx0XHRcdFx0dG1wID0gdGhpcy5fcHJldmlvdXNTaWJsaW5nKHRtcCk7XG5cdFx0XHRcdH0gd2hpbGUgKHRtcCAmJiB0bXAub2Zmc2V0SGVpZ2h0ID09PSAwKTtcblx0XHRcdFx0cmV0dXJuIHRtcCA/ICQodG1wKSA6IGZhbHNlO1xuXHRcdFx0fVxuXHRcdFx0dG1wID0gb2JqWzBdO1xuXHRcdFx0ZG8ge1xuXHRcdFx0XHR0bXAgPSB0aGlzLl9wcmV2aW91c1NpYmxpbmcodG1wKTtcblx0XHRcdH0gd2hpbGUgKHRtcCAmJiB0bXAub2Zmc2V0SGVpZ2h0ID09PSAwKTtcblx0XHRcdGlmKHRtcCAhPT0gbnVsbCkge1xuXHRcdFx0XHRvYmogPSAkKHRtcCk7XG5cdFx0XHRcdHdoaWxlKG9iai5oYXNDbGFzcyhcImpzdHJlZS1vcGVuXCIpKSB7XG5cdFx0XHRcdFx0b2JqID0gb2JqLmNoaWxkcmVuKFwiLmpzdHJlZS1jaGlsZHJlblwiKS5maXJzdCgpLmNoaWxkcmVuKFwiLmpzdHJlZS1ub2RlOnZpc2libGU6bGFzdFwiKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gb2JqO1xuXHRcdFx0fVxuXHRcdFx0dG1wID0gb2JqWzBdLnBhcmVudE5vZGUucGFyZW50Tm9kZTtcblx0XHRcdHJldHVybiB0bXAgJiYgdG1wLmNsYXNzTmFtZSAmJiB0bXAuY2xhc3NOYW1lLmluZGV4T2YoJ2pzdHJlZS1ub2RlJykgIT09IC0xID8gJCh0bXApIDogZmFsc2U7XG5cdFx0fSxcblx0XHQvKipcblx0XHQgKiBnZXQgdGhlIHBhcmVudCBJRCBvZiBhIG5vZGVcblx0XHQgKiBAbmFtZSBnZXRfcGFyZW50KG9iailcblx0XHQgKiBAcGFyYW0gIHttaXhlZH0gb2JqXG5cdFx0ICogQHJldHVybiB7U3RyaW5nfVxuXHRcdCAqL1xuXHRcdGdldF9wYXJlbnQgOiBmdW5jdGlvbiAob2JqKSB7XG5cdFx0XHRvYmogPSB0aGlzLmdldF9ub2RlKG9iaik7XG5cdFx0XHRpZighb2JqIHx8IG9iai5pZCA9PT0gJC5qc3RyZWUucm9vdCkge1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gb2JqLnBhcmVudDtcblx0XHR9LFxuXHRcdC8qKlxuXHRcdCAqIGdldCBhIGpRdWVyeSBjb2xsZWN0aW9uIG9mIGFsbCB0aGUgY2hpbGRyZW4gb2YgYSBub2RlIChub2RlIG11c3QgYmUgcmVuZGVyZWQpXG5cdFx0ICogQG5hbWUgZ2V0X2NoaWxkcmVuX2RvbShvYmopXG5cdFx0ICogQHBhcmFtICB7bWl4ZWR9IG9ialxuXHRcdCAqIEByZXR1cm4ge2pRdWVyeX1cblx0XHQgKi9cblx0XHRnZXRfY2hpbGRyZW5fZG9tIDogZnVuY3Rpb24gKG9iaikge1xuXHRcdFx0b2JqID0gdGhpcy5nZXRfbm9kZShvYmosIHRydWUpO1xuXHRcdFx0aWYob2JqWzBdID09PSB0aGlzLmVsZW1lbnRbMF0pIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuZ2V0X2NvbnRhaW5lcl91bCgpLmNoaWxkcmVuKFwiLmpzdHJlZS1ub2RlXCIpO1xuXHRcdFx0fVxuXHRcdFx0aWYoIW9iaiB8fCAhb2JqLmxlbmd0aCkge1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gb2JqLmNoaWxkcmVuKFwiLmpzdHJlZS1jaGlsZHJlblwiKS5jaGlsZHJlbihcIi5qc3RyZWUtbm9kZVwiKTtcblx0XHR9LFxuXHRcdC8qKlxuXHRcdCAqIGNoZWNrcyBpZiBhIG5vZGUgaGFzIGNoaWxkcmVuXG5cdFx0ICogQG5hbWUgaXNfcGFyZW50KG9iailcblx0XHQgKiBAcGFyYW0gIHttaXhlZH0gb2JqXG5cdFx0ICogQHJldHVybiB7Qm9vbGVhbn1cblx0XHQgKi9cblx0XHRpc19wYXJlbnQgOiBmdW5jdGlvbiAob2JqKSB7XG5cdFx0XHRvYmogPSB0aGlzLmdldF9ub2RlKG9iaik7XG5cdFx0XHRyZXR1cm4gb2JqICYmIChvYmouc3RhdGUubG9hZGVkID09PSBmYWxzZSB8fCBvYmouY2hpbGRyZW4ubGVuZ3RoID4gMCk7XG5cdFx0fSxcblx0XHQvKipcblx0XHQgKiBjaGVja3MgaWYgYSBub2RlIGlzIGxvYWRlZCAoaXRzIGNoaWxkcmVuIGFyZSBhdmFpbGFibGUpXG5cdFx0ICogQG5hbWUgaXNfbG9hZGVkKG9iailcblx0XHQgKiBAcGFyYW0gIHttaXhlZH0gb2JqXG5cdFx0ICogQHJldHVybiB7Qm9vbGVhbn1cblx0XHQgKi9cblx0XHRpc19sb2FkZWQgOiBmdW5jdGlvbiAob2JqKSB7XG5cdFx0XHRvYmogPSB0aGlzLmdldF9ub2RlKG9iaik7XG5cdFx0XHRyZXR1cm4gb2JqICYmIG9iai5zdGF0ZS5sb2FkZWQ7XG5cdFx0fSxcblx0XHQvKipcblx0XHQgKiBjaGVjayBpZiBhIG5vZGUgaXMgY3VycmVudGx5IGxvYWRpbmcgKGZldGNoaW5nIGNoaWxkcmVuKVxuXHRcdCAqIEBuYW1lIGlzX2xvYWRpbmcob2JqKVxuXHRcdCAqIEBwYXJhbSAge21peGVkfSBvYmpcblx0XHQgKiBAcmV0dXJuIHtCb29sZWFufVxuXHRcdCAqL1xuXHRcdGlzX2xvYWRpbmcgOiBmdW5jdGlvbiAob2JqKSB7XG5cdFx0XHRvYmogPSB0aGlzLmdldF9ub2RlKG9iaik7XG5cdFx0XHRyZXR1cm4gb2JqICYmIG9iai5zdGF0ZSAmJiBvYmouc3RhdGUubG9hZGluZztcblx0XHR9LFxuXHRcdC8qKlxuXHRcdCAqIGNoZWNrIGlmIGEgbm9kZSBpcyBvcGVuZWRcblx0XHQgKiBAbmFtZSBpc19vcGVuKG9iailcblx0XHQgKiBAcGFyYW0gIHttaXhlZH0gb2JqXG5cdFx0ICogQHJldHVybiB7Qm9vbGVhbn1cblx0XHQgKi9cblx0XHRpc19vcGVuIDogZnVuY3Rpb24gKG9iaikge1xuXHRcdFx0b2JqID0gdGhpcy5nZXRfbm9kZShvYmopO1xuXHRcdFx0cmV0dXJuIG9iaiAmJiBvYmouc3RhdGUub3BlbmVkO1xuXHRcdH0sXG5cdFx0LyoqXG5cdFx0ICogY2hlY2sgaWYgYSBub2RlIGlzIGluIGEgY2xvc2VkIHN0YXRlXG5cdFx0ICogQG5hbWUgaXNfY2xvc2VkKG9iailcblx0XHQgKiBAcGFyYW0gIHttaXhlZH0gb2JqXG5cdFx0ICogQHJldHVybiB7Qm9vbGVhbn1cblx0XHQgKi9cblx0XHRpc19jbG9zZWQgOiBmdW5jdGlvbiAob2JqKSB7XG5cdFx0XHRvYmogPSB0aGlzLmdldF9ub2RlKG9iaik7XG5cdFx0XHRyZXR1cm4gb2JqICYmIHRoaXMuaXNfcGFyZW50KG9iaikgJiYgIW9iai5zdGF0ZS5vcGVuZWQ7XG5cdFx0fSxcblx0XHQvKipcblx0XHQgKiBjaGVjayBpZiBhIG5vZGUgaGFzIG5vIGNoaWxkcmVuXG5cdFx0ICogQG5hbWUgaXNfbGVhZihvYmopXG5cdFx0ICogQHBhcmFtICB7bWl4ZWR9IG9ialxuXHRcdCAqIEByZXR1cm4ge0Jvb2xlYW59XG5cdFx0ICovXG5cdFx0aXNfbGVhZiA6IGZ1bmN0aW9uIChvYmopIHtcblx0XHRcdHJldHVybiAhdGhpcy5pc19wYXJlbnQob2JqKTtcblx0XHR9LFxuXHRcdC8qKlxuXHRcdCAqIGxvYWRzIGEgbm9kZSAoZmV0Y2hlcyBpdHMgY2hpbGRyZW4gdXNpbmcgdGhlIGBjb3JlLmRhdGFgIHNldHRpbmcpLiBNdWx0aXBsZSBub2RlcyBjYW4gYmUgcGFzc2VkIHRvIGJ5IHVzaW5nIGFuIGFycmF5LlxuXHRcdCAqIEBuYW1lIGxvYWRfbm9kZShvYmogWywgY2FsbGJhY2tdKVxuXHRcdCAqIEBwYXJhbSAge21peGVkfSBvYmpcblx0XHQgKiBAcGFyYW0gIHtmdW5jdGlvbn0gY2FsbGJhY2sgYSBmdW5jdGlvbiB0byBiZSBleGVjdXRlZCBvbmNlIGxvYWRpbmcgaXMgY29tcGxldGUsIHRoZSBmdW5jdGlvbiBpcyBleGVjdXRlZCBpbiB0aGUgaW5zdGFuY2UncyBzY29wZSBhbmQgcmVjZWl2ZXMgdHdvIGFyZ3VtZW50cyAtIHRoZSBub2RlIGFuZCBhIGJvb2xlYW4gc3RhdHVzXG5cdFx0ICogQHJldHVybiB7Qm9vbGVhbn1cblx0XHQgKiBAdHJpZ2dlciBsb2FkX25vZGUuanN0cmVlXG5cdFx0ICovXG5cdFx0bG9hZF9ub2RlIDogZnVuY3Rpb24gKG9iaiwgY2FsbGJhY2spIHtcblx0XHRcdHZhciBrLCBsLCBpLCBqLCBjO1xuXHRcdFx0aWYoJC5pc0FycmF5KG9iaikpIHtcblx0XHRcdFx0dGhpcy5fbG9hZF9ub2RlcyhvYmouc2xpY2UoKSwgY2FsbGJhY2spO1xuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblx0XHRcdG9iaiA9IHRoaXMuZ2V0X25vZGUob2JqKTtcblx0XHRcdGlmKCFvYmopIHtcblx0XHRcdFx0aWYoY2FsbGJhY2spIHsgY2FsbGJhY2suY2FsbCh0aGlzLCBvYmosIGZhbHNlKTsgfVxuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cdFx0XHQvLyBpZihvYmouc3RhdGUubG9hZGluZykgeyB9IC8vIHRoZSBub2RlIGlzIGFscmVhZHkgbG9hZGluZyAtIGp1c3Qgd2FpdCBmb3IgaXQgdG8gbG9hZCBhbmQgaW52b2tlIGNhbGxiYWNrPyBidXQgaWYgY2FsbGVkIGltcGxpY2l0bHkgaXQgc2hvdWxkIGJlIGxvYWRlZCBhZ2Fpbj9cblx0XHRcdGlmKG9iai5zdGF0ZS5sb2FkZWQpIHtcblx0XHRcdFx0b2JqLnN0YXRlLmxvYWRlZCA9IGZhbHNlO1xuXHRcdFx0XHRmb3IoaSA9IDAsIGogPSBvYmoucGFyZW50cy5sZW5ndGg7IGkgPCBqOyBpKyspIHtcblx0XHRcdFx0XHR0aGlzLl9tb2RlbC5kYXRhW29iai5wYXJlbnRzW2ldXS5jaGlsZHJlbl9kID0gJC52YWthdGEuYXJyYXlfZmlsdGVyKHRoaXMuX21vZGVsLmRhdGFbb2JqLnBhcmVudHNbaV1dLmNoaWxkcmVuX2QsIGZ1bmN0aW9uICh2KSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gJC5pbkFycmF5KHYsIG9iai5jaGlsZHJlbl9kKSA9PT0gLTE7XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0Zm9yKGsgPSAwLCBsID0gb2JqLmNoaWxkcmVuX2QubGVuZ3RoOyBrIDwgbDsgaysrKSB7XG5cdFx0XHRcdFx0aWYodGhpcy5fbW9kZWwuZGF0YVtvYmouY2hpbGRyZW5fZFtrXV0uc3RhdGUuc2VsZWN0ZWQpIHtcblx0XHRcdFx0XHRcdGMgPSB0cnVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRkZWxldGUgdGhpcy5fbW9kZWwuZGF0YVtvYmouY2hpbGRyZW5fZFtrXV07XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKGMpIHtcblx0XHRcdFx0XHR0aGlzLl9kYXRhLmNvcmUuc2VsZWN0ZWQgPSAkLnZha2F0YS5hcnJheV9maWx0ZXIodGhpcy5fZGF0YS5jb3JlLnNlbGVjdGVkLCBmdW5jdGlvbiAodikge1xuXHRcdFx0XHRcdFx0cmV0dXJuICQuaW5BcnJheSh2LCBvYmouY2hpbGRyZW5fZCkgPT09IC0xO1xuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9XG5cdFx0XHRcdG9iai5jaGlsZHJlbiA9IFtdO1xuXHRcdFx0XHRvYmouY2hpbGRyZW5fZCA9IFtdO1xuXHRcdFx0XHRpZihjKSB7XG5cdFx0XHRcdFx0dGhpcy50cmlnZ2VyKCdjaGFuZ2VkJywgeyAnYWN0aW9uJyA6ICdsb2FkX25vZGUnLCAnbm9kZScgOiBvYmosICdzZWxlY3RlZCcgOiB0aGlzLl9kYXRhLmNvcmUuc2VsZWN0ZWQgfSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdG9iai5zdGF0ZS5mYWlsZWQgPSBmYWxzZTtcblx0XHRcdG9iai5zdGF0ZS5sb2FkaW5nID0gdHJ1ZTtcblx0XHRcdHRoaXMuZ2V0X25vZGUob2JqLCB0cnVlKS5hZGRDbGFzcyhcImpzdHJlZS1sb2FkaW5nXCIpLmF0dHIoJ2FyaWEtYnVzeScsdHJ1ZSk7XG5cdFx0XHR0aGlzLl9sb2FkX25vZGUob2JqLCAkLnByb3h5KGZ1bmN0aW9uIChzdGF0dXMpIHtcblx0XHRcdFx0b2JqID0gdGhpcy5fbW9kZWwuZGF0YVtvYmouaWRdO1xuXHRcdFx0XHRvYmouc3RhdGUubG9hZGluZyA9IGZhbHNlO1xuXHRcdFx0XHRvYmouc3RhdGUubG9hZGVkID0gc3RhdHVzO1xuXHRcdFx0XHRvYmouc3RhdGUuZmFpbGVkID0gIW9iai5zdGF0ZS5sb2FkZWQ7XG5cdFx0XHRcdHZhciBkb20gPSB0aGlzLmdldF9ub2RlKG9iaiwgdHJ1ZSksIGkgPSAwLCBqID0gMCwgbSA9IHRoaXMuX21vZGVsLmRhdGEsIGhhc19jaGlsZHJlbiA9IGZhbHNlO1xuXHRcdFx0XHRmb3IoaSA9IDAsIGogPSBvYmouY2hpbGRyZW4ubGVuZ3RoOyBpIDwgajsgaSsrKSB7XG5cdFx0XHRcdFx0aWYobVtvYmouY2hpbGRyZW5baV1dICYmICFtW29iai5jaGlsZHJlbltpXV0uc3RhdGUuaGlkZGVuKSB7XG5cdFx0XHRcdFx0XHRoYXNfY2hpbGRyZW4gPSB0cnVlO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdGlmKG9iai5zdGF0ZS5sb2FkZWQgJiYgZG9tICYmIGRvbS5sZW5ndGgpIHtcblx0XHRcdFx0XHRkb20ucmVtb3ZlQ2xhc3MoJ2pzdHJlZS1jbG9zZWQganN0cmVlLW9wZW4ganN0cmVlLWxlYWYnKTtcblx0XHRcdFx0XHRpZiAoIWhhc19jaGlsZHJlbikge1xuXHRcdFx0XHRcdFx0ZG9tLmFkZENsYXNzKCdqc3RyZWUtbGVhZicpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRcdGlmIChvYmouaWQgIT09ICcjJykge1xuXHRcdFx0XHRcdFx0XHRkb20uYWRkQ2xhc3Mob2JqLnN0YXRlLm9wZW5lZCA/ICdqc3RyZWUtb3BlbicgOiAnanN0cmVlLWNsb3NlZCcpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRkb20ucmVtb3ZlQ2xhc3MoXCJqc3RyZWUtbG9hZGluZ1wiKS5hdHRyKCdhcmlhLWJ1c3knLGZhbHNlKTtcblx0XHRcdFx0LyoqXG5cdFx0XHRcdCAqIHRyaWdnZXJlZCBhZnRlciBhIG5vZGUgaXMgbG9hZGVkXG5cdFx0XHRcdCAqIEBldmVudFxuXHRcdFx0XHQgKiBAbmFtZSBsb2FkX25vZGUuanN0cmVlXG5cdFx0XHRcdCAqIEBwYXJhbSB7T2JqZWN0fSBub2RlIHRoZSBub2RlIHRoYXQgd2FzIGxvYWRpbmdcblx0XHRcdFx0ICogQHBhcmFtIHtCb29sZWFufSBzdGF0dXMgd2FzIHRoZSBub2RlIGxvYWRlZCBzdWNjZXNzZnVsbHlcblx0XHRcdFx0ICovXG5cdFx0XHRcdHRoaXMudHJpZ2dlcignbG9hZF9ub2RlJywgeyBcIm5vZGVcIiA6IG9iaiwgXCJzdGF0dXNcIiA6IHN0YXR1cyB9KTtcblx0XHRcdFx0aWYoY2FsbGJhY2spIHtcblx0XHRcdFx0XHRjYWxsYmFjay5jYWxsKHRoaXMsIG9iaiwgc3RhdHVzKTtcblx0XHRcdFx0fVxuXHRcdFx0fSwgdGhpcykpO1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fSxcblx0XHQvKipcblx0XHQgKiBsb2FkIGFuIGFycmF5IG9mIG5vZGVzICh3aWxsIGFsc28gbG9hZCB1bmF2YWlsYWJsZSBub2RlcyBhcyBzb29uIGFzIHRoZSBhcHBlYXIgaW4gdGhlIHN0cnVjdHVyZSkuIFVzZWQgaW50ZXJuYWxseS5cblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqIEBuYW1lIF9sb2FkX25vZGVzKG5vZGVzIFssIGNhbGxiYWNrXSlcblx0XHQgKiBAcGFyYW0gIHthcnJheX0gbm9kZXNcblx0XHQgKiBAcGFyYW0gIHtmdW5jdGlvbn0gY2FsbGJhY2sgYSBmdW5jdGlvbiB0byBiZSBleGVjdXRlZCBvbmNlIGxvYWRpbmcgaXMgY29tcGxldGUsIHRoZSBmdW5jdGlvbiBpcyBleGVjdXRlZCBpbiB0aGUgaW5zdGFuY2UncyBzY29wZSBhbmQgcmVjZWl2ZXMgb25lIGFyZ3VtZW50IC0gdGhlIGFycmF5IHBhc3NlZCB0byBfbG9hZF9ub2Rlc1xuXHRcdCAqL1xuXHRcdF9sb2FkX25vZGVzIDogZnVuY3Rpb24gKG5vZGVzLCBjYWxsYmFjaywgaXNfY2FsbGJhY2ssIGZvcmNlX3JlbG9hZCkge1xuXHRcdFx0dmFyIHIgPSB0cnVlLFxuXHRcdFx0XHRjID0gZnVuY3Rpb24gKCkgeyB0aGlzLl9sb2FkX25vZGVzKG5vZGVzLCBjYWxsYmFjaywgdHJ1ZSk7IH0sXG5cdFx0XHRcdG0gPSB0aGlzLl9tb2RlbC5kYXRhLCBpLCBqLCB0bXAgPSBbXTtcblx0XHRcdGZvcihpID0gMCwgaiA9IG5vZGVzLmxlbmd0aDsgaSA8IGo7IGkrKykge1xuXHRcdFx0XHRpZihtW25vZGVzW2ldXSAmJiAoICghbVtub2Rlc1tpXV0uc3RhdGUubG9hZGVkICYmICFtW25vZGVzW2ldXS5zdGF0ZS5mYWlsZWQpIHx8ICghaXNfY2FsbGJhY2sgJiYgZm9yY2VfcmVsb2FkKSApKSB7XG5cdFx0XHRcdFx0aWYoIXRoaXMuaXNfbG9hZGluZyhub2Rlc1tpXSkpIHtcblx0XHRcdFx0XHRcdHRoaXMubG9hZF9ub2RlKG5vZGVzW2ldLCBjKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ciA9IGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRpZihyKSB7XG5cdFx0XHRcdGZvcihpID0gMCwgaiA9IG5vZGVzLmxlbmd0aDsgaSA8IGo7IGkrKykge1xuXHRcdFx0XHRcdGlmKG1bbm9kZXNbaV1dICYmIG1bbm9kZXNbaV1dLnN0YXRlLmxvYWRlZCkge1xuXHRcdFx0XHRcdFx0dG1wLnB1c2gobm9kZXNbaV0pO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRpZihjYWxsYmFjayAmJiAhY2FsbGJhY2suZG9uZSkge1xuXHRcdFx0XHRcdGNhbGxiYWNrLmNhbGwodGhpcywgdG1wKTtcblx0XHRcdFx0XHRjYWxsYmFjay5kb25lID0gdHJ1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0LyoqXG5cdFx0ICogbG9hZHMgYWxsIHVubG9hZGVkIG5vZGVzXG5cdFx0ICogQG5hbWUgbG9hZF9hbGwoW29iaiwgY2FsbGJhY2tdKVxuXHRcdCAqIEBwYXJhbSB7bWl4ZWR9IG9iaiB0aGUgbm9kZSB0byBsb2FkIHJlY3Vyc2l2ZWx5LCBvbWl0IHRvIGxvYWQgYWxsIG5vZGVzIGluIHRoZSB0cmVlXG5cdFx0ICogQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2sgYSBmdW5jdGlvbiB0byBiZSBleGVjdXRlZCBvbmNlIGxvYWRpbmcgYWxsIHRoZSBub2RlcyBpcyBjb21wbGV0ZSxcblx0XHQgKiBAdHJpZ2dlciBsb2FkX2FsbC5qc3RyZWVcblx0XHQgKi9cblx0XHRsb2FkX2FsbCA6IGZ1bmN0aW9uIChvYmosIGNhbGxiYWNrKSB7XG5cdFx0XHRpZighb2JqKSB7IG9iaiA9ICQuanN0cmVlLnJvb3Q7IH1cblx0XHRcdG9iaiA9IHRoaXMuZ2V0X25vZGUob2JqKTtcblx0XHRcdGlmKCFvYmopIHsgcmV0dXJuIGZhbHNlOyB9XG5cdFx0XHR2YXIgdG9fbG9hZCA9IFtdLFxuXHRcdFx0XHRtID0gdGhpcy5fbW9kZWwuZGF0YSxcblx0XHRcdFx0YyA9IG1bb2JqLmlkXS5jaGlsZHJlbl9kLFxuXHRcdFx0XHRpLCBqO1xuXHRcdFx0aWYob2JqLnN0YXRlICYmICFvYmouc3RhdGUubG9hZGVkKSB7XG5cdFx0XHRcdHRvX2xvYWQucHVzaChvYmouaWQpO1xuXHRcdFx0fVxuXHRcdFx0Zm9yKGkgPSAwLCBqID0gYy5sZW5ndGg7IGkgPCBqOyBpKyspIHtcblx0XHRcdFx0aWYobVtjW2ldXSAmJiBtW2NbaV1dLnN0YXRlICYmICFtW2NbaV1dLnN0YXRlLmxvYWRlZCkge1xuXHRcdFx0XHRcdHRvX2xvYWQucHVzaChjW2ldKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0aWYodG9fbG9hZC5sZW5ndGgpIHtcblx0XHRcdFx0dGhpcy5fbG9hZF9ub2Rlcyh0b19sb2FkLCBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdFx0dGhpcy5sb2FkX2FsbChvYmosIGNhbGxiYWNrKTtcblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIHtcblx0XHRcdFx0LyoqXG5cdFx0XHRcdCAqIHRyaWdnZXJlZCBhZnRlciBhIGxvYWRfYWxsIGNhbGwgY29tcGxldGVzXG5cdFx0XHRcdCAqIEBldmVudFxuXHRcdFx0XHQgKiBAbmFtZSBsb2FkX2FsbC5qc3RyZWVcblx0XHRcdFx0ICogQHBhcmFtIHtPYmplY3R9IG5vZGUgdGhlIHJlY3Vyc2l2ZWx5IGxvYWRlZCBub2RlXG5cdFx0XHRcdCAqL1xuXHRcdFx0XHRpZihjYWxsYmFjaykgeyBjYWxsYmFjay5jYWxsKHRoaXMsIG9iaik7IH1cblx0XHRcdFx0dGhpcy50cmlnZ2VyKCdsb2FkX2FsbCcsIHsgXCJub2RlXCIgOiBvYmogfSk7XG5cdFx0XHR9XG5cdFx0fSxcblx0XHQvKipcblx0XHQgKiBoYW5kbGVzIHRoZSBhY3R1YWwgbG9hZGluZyBvZiBhIG5vZGUuIFVzZWQgb25seSBpbnRlcm5hbGx5LlxuXHRcdCAqIEBwcml2YXRlXG5cdFx0ICogQG5hbWUgX2xvYWRfbm9kZShvYmogWywgY2FsbGJhY2tdKVxuXHRcdCAqIEBwYXJhbSAge21peGVkfSBvYmpcblx0XHQgKiBAcGFyYW0gIHtmdW5jdGlvbn0gY2FsbGJhY2sgYSBmdW5jdGlvbiB0byBiZSBleGVjdXRlZCBvbmNlIGxvYWRpbmcgaXMgY29tcGxldGUsIHRoZSBmdW5jdGlvbiBpcyBleGVjdXRlZCBpbiB0aGUgaW5zdGFuY2UncyBzY29wZSBhbmQgcmVjZWl2ZXMgb25lIGFyZ3VtZW50IC0gYSBib29sZWFuIHN0YXR1c1xuXHRcdCAqIEByZXR1cm4ge0Jvb2xlYW59XG5cdFx0ICovXG5cdFx0X2xvYWRfbm9kZSA6IGZ1bmN0aW9uIChvYmosIGNhbGxiYWNrKSB7XG5cdFx0XHR2YXIgcyA9IHRoaXMuc2V0dGluZ3MuY29yZS5kYXRhLCB0O1xuXHRcdFx0dmFyIG5vdFRleHRPckNvbW1lbnROb2RlID0gZnVuY3Rpb24gbm90VGV4dE9yQ29tbWVudE5vZGUgKCkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5ub2RlVHlwZSAhPT0gMyAmJiB0aGlzLm5vZGVUeXBlICE9PSA4O1xuXHRcdFx0fTtcblx0XHRcdC8vIHVzZSBvcmlnaW5hbCBIVE1MXG5cdFx0XHRpZighcykge1xuXHRcdFx0XHRpZihvYmouaWQgPT09ICQuanN0cmVlLnJvb3QpIHtcblx0XHRcdFx0XHRyZXR1cm4gdGhpcy5fYXBwZW5kX2h0bWxfZGF0YShvYmosIHRoaXMuX2RhdGEuY29yZS5vcmlnaW5hbF9jb250YWluZXJfaHRtbC5jbG9uZSh0cnVlKSwgZnVuY3Rpb24gKHN0YXR1cykge1xuXHRcdFx0XHRcdFx0Y2FsbGJhY2suY2FsbCh0aGlzLCBzdGF0dXMpO1xuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdHJldHVybiBjYWxsYmFjay5jYWxsKHRoaXMsIGZhbHNlKTtcblx0XHRcdFx0fVxuXHRcdFx0XHQvLyByZXR1cm4gY2FsbGJhY2suY2FsbCh0aGlzLCBvYmouaWQgPT09ICQuanN0cmVlLnJvb3QgPyB0aGlzLl9hcHBlbmRfaHRtbF9kYXRhKG9iaiwgdGhpcy5fZGF0YS5jb3JlLm9yaWdpbmFsX2NvbnRhaW5lcl9odG1sLmNsb25lKHRydWUpKSA6IGZhbHNlKTtcblx0XHRcdH1cblx0XHRcdGlmKCQuaXNGdW5jdGlvbihzKSkge1xuXHRcdFx0XHRyZXR1cm4gcy5jYWxsKHRoaXMsIG9iaiwgJC5wcm94eShmdW5jdGlvbiAoZCkge1xuXHRcdFx0XHRcdGlmKGQgPT09IGZhbHNlKSB7XG5cdFx0XHRcdFx0XHRjYWxsYmFjay5jYWxsKHRoaXMsIGZhbHNlKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0XHR0aGlzW3R5cGVvZiBkID09PSAnc3RyaW5nJyA/ICdfYXBwZW5kX2h0bWxfZGF0YScgOiAnX2FwcGVuZF9qc29uX2RhdGEnXShvYmosIHR5cGVvZiBkID09PSAnc3RyaW5nJyA/ICQoJC5wYXJzZUhUTUwoZCkpLmZpbHRlcihub3RUZXh0T3JDb21tZW50Tm9kZSkgOiBkLCBmdW5jdGlvbiAoc3RhdHVzKSB7XG5cdFx0XHRcdFx0XHRcdGNhbGxiYWNrLmNhbGwodGhpcywgc3RhdHVzKTtcblx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHQvLyByZXR1cm4gZCA9PT0gZmFsc2UgPyBjYWxsYmFjay5jYWxsKHRoaXMsIGZhbHNlKSA6IGNhbGxiYWNrLmNhbGwodGhpcywgdGhpc1t0eXBlb2YgZCA9PT0gJ3N0cmluZycgPyAnX2FwcGVuZF9odG1sX2RhdGEnIDogJ19hcHBlbmRfanNvbl9kYXRhJ10ob2JqLCB0eXBlb2YgZCA9PT0gJ3N0cmluZycgPyAkKGQpIDogZCkpO1xuXHRcdFx0XHR9LCB0aGlzKSk7XG5cdFx0XHR9XG5cdFx0XHRpZih0eXBlb2YgcyA9PT0gJ29iamVjdCcpIHtcblx0XHRcdFx0aWYocy51cmwpIHtcblx0XHRcdFx0XHRzID0gJC5leHRlbmQodHJ1ZSwge30sIHMpO1xuXHRcdFx0XHRcdGlmKCQuaXNGdW5jdGlvbihzLnVybCkpIHtcblx0XHRcdFx0XHRcdHMudXJsID0gcy51cmwuY2FsbCh0aGlzLCBvYmopO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZigkLmlzRnVuY3Rpb24ocy5kYXRhKSkge1xuXHRcdFx0XHRcdFx0cy5kYXRhID0gcy5kYXRhLmNhbGwodGhpcywgb2JqKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuICQuYWpheChzKVxuXHRcdFx0XHRcdFx0LmRvbmUoJC5wcm94eShmdW5jdGlvbiAoZCx0LHgpIHtcblx0XHRcdFx0XHRcdFx0XHR2YXIgdHlwZSA9IHguZ2V0UmVzcG9uc2VIZWFkZXIoJ0NvbnRlbnQtVHlwZScpO1xuXHRcdFx0XHRcdFx0XHRcdGlmKCh0eXBlICYmIHR5cGUuaW5kZXhPZignanNvbicpICE9PSAtMSkgfHwgdHlwZW9mIGQgPT09IFwib2JqZWN0XCIpIHtcblx0XHRcdFx0XHRcdFx0XHRcdHJldHVybiB0aGlzLl9hcHBlbmRfanNvbl9kYXRhKG9iaiwgZCwgZnVuY3Rpb24gKHN0YXR1cykgeyBjYWxsYmFjay5jYWxsKHRoaXMsIHN0YXR1cyk7IH0pO1xuXHRcdFx0XHRcdFx0XHRcdFx0Ly9yZXR1cm4gY2FsbGJhY2suY2FsbCh0aGlzLCB0aGlzLl9hcHBlbmRfanNvbl9kYXRhKG9iaiwgZCkpO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRpZigodHlwZSAmJiB0eXBlLmluZGV4T2YoJ2h0bWwnKSAhPT0gLTEpIHx8IHR5cGVvZiBkID09PSBcInN0cmluZ1wiKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gdGhpcy5fYXBwZW5kX2h0bWxfZGF0YShvYmosICQoJC5wYXJzZUhUTUwoZCkpLmZpbHRlcihub3RUZXh0T3JDb21tZW50Tm9kZSksIGZ1bmN0aW9uIChzdGF0dXMpIHsgY2FsbGJhY2suY2FsbCh0aGlzLCBzdGF0dXMpOyB9KTtcblx0XHRcdFx0XHRcdFx0XHRcdC8vIHJldHVybiBjYWxsYmFjay5jYWxsKHRoaXMsIHRoaXMuX2FwcGVuZF9odG1sX2RhdGEob2JqLCAkKGQpKSk7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdHRoaXMuX2RhdGEuY29yZS5sYXN0X2Vycm9yID0geyAnZXJyb3InIDogJ2FqYXgnLCAncGx1Z2luJyA6ICdjb3JlJywgJ2lkJyA6ICdjb3JlXzA0JywgJ3JlYXNvbicgOiAnQ291bGQgbm90IGxvYWQgbm9kZScsICdkYXRhJyA6IEpTT04uc3RyaW5naWZ5KHsgJ2lkJyA6IG9iai5pZCwgJ3hocicgOiB4IH0pIH07XG5cdFx0XHRcdFx0XHRcdFx0dGhpcy5zZXR0aW5ncy5jb3JlLmVycm9yLmNhbGwodGhpcywgdGhpcy5fZGF0YS5jb3JlLmxhc3RfZXJyb3IpO1xuXHRcdFx0XHRcdFx0XHRcdHJldHVybiBjYWxsYmFjay5jYWxsKHRoaXMsIGZhbHNlKTtcblx0XHRcdFx0XHRcdFx0fSwgdGhpcykpXG5cdFx0XHRcdFx0XHQuZmFpbCgkLnByb3h5KGZ1bmN0aW9uIChmKSB7XG5cdFx0XHRcdFx0XHRcdFx0Y2FsbGJhY2suY2FsbCh0aGlzLCBmYWxzZSk7XG5cdFx0XHRcdFx0XHRcdFx0dGhpcy5fZGF0YS5jb3JlLmxhc3RfZXJyb3IgPSB7ICdlcnJvcicgOiAnYWpheCcsICdwbHVnaW4nIDogJ2NvcmUnLCAnaWQnIDogJ2NvcmVfMDQnLCAncmVhc29uJyA6ICdDb3VsZCBub3QgbG9hZCBub2RlJywgJ2RhdGEnIDogSlNPTi5zdHJpbmdpZnkoeyAnaWQnIDogb2JqLmlkLCAneGhyJyA6IGYgfSkgfTtcblx0XHRcdFx0XHRcdFx0XHR0aGlzLnNldHRpbmdzLmNvcmUuZXJyb3IuY2FsbCh0aGlzLCB0aGlzLl9kYXRhLmNvcmUubGFzdF9lcnJvcik7XG5cdFx0XHRcdFx0XHRcdH0sIHRoaXMpKTtcblx0XHRcdFx0fVxuXHRcdFx0XHR0ID0gKCQuaXNBcnJheShzKSB8fCAkLmlzUGxhaW5PYmplY3QocykpID8gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShzKSkgOiBzO1xuXHRcdFx0XHRpZihvYmouaWQgPT09ICQuanN0cmVlLnJvb3QpIHtcblx0XHRcdFx0XHRyZXR1cm4gdGhpcy5fYXBwZW5kX2pzb25fZGF0YShvYmosIHQsIGZ1bmN0aW9uIChzdGF0dXMpIHtcblx0XHRcdFx0XHRcdGNhbGxiYWNrLmNhbGwodGhpcywgc3RhdHVzKTtcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHR0aGlzLl9kYXRhLmNvcmUubGFzdF9lcnJvciA9IHsgJ2Vycm9yJyA6ICdub2RhdGEnLCAncGx1Z2luJyA6ICdjb3JlJywgJ2lkJyA6ICdjb3JlXzA1JywgJ3JlYXNvbicgOiAnQ291bGQgbm90IGxvYWQgbm9kZScsICdkYXRhJyA6IEpTT04uc3RyaW5naWZ5KHsgJ2lkJyA6IG9iai5pZCB9KSB9O1xuXHRcdFx0XHRcdHRoaXMuc2V0dGluZ3MuY29yZS5lcnJvci5jYWxsKHRoaXMsIHRoaXMuX2RhdGEuY29yZS5sYXN0X2Vycm9yKTtcblx0XHRcdFx0XHRyZXR1cm4gY2FsbGJhY2suY2FsbCh0aGlzLCBmYWxzZSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0Ly9yZXR1cm4gY2FsbGJhY2suY2FsbCh0aGlzLCAob2JqLmlkID09PSAkLmpzdHJlZS5yb290ID8gdGhpcy5fYXBwZW5kX2pzb25fZGF0YShvYmosIHQpIDogZmFsc2UpICk7XG5cdFx0XHR9XG5cdFx0XHRpZih0eXBlb2YgcyA9PT0gJ3N0cmluZycpIHtcblx0XHRcdFx0aWYob2JqLmlkID09PSAkLmpzdHJlZS5yb290KSB7XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXMuX2FwcGVuZF9odG1sX2RhdGEob2JqLCAkKCQucGFyc2VIVE1MKHMpKS5maWx0ZXIobm90VGV4dE9yQ29tbWVudE5vZGUpLCBmdW5jdGlvbiAoc3RhdHVzKSB7XG5cdFx0XHRcdFx0XHRjYWxsYmFjay5jYWxsKHRoaXMsIHN0YXR1cyk7XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0dGhpcy5fZGF0YS5jb3JlLmxhc3RfZXJyb3IgPSB7ICdlcnJvcicgOiAnbm9kYXRhJywgJ3BsdWdpbicgOiAnY29yZScsICdpZCcgOiAnY29yZV8wNicsICdyZWFzb24nIDogJ0NvdWxkIG5vdCBsb2FkIG5vZGUnLCAnZGF0YScgOiBKU09OLnN0cmluZ2lmeSh7ICdpZCcgOiBvYmouaWQgfSkgfTtcblx0XHRcdFx0XHR0aGlzLnNldHRpbmdzLmNvcmUuZXJyb3IuY2FsbCh0aGlzLCB0aGlzLl9kYXRhLmNvcmUubGFzdF9lcnJvcik7XG5cdFx0XHRcdFx0cmV0dXJuIGNhbGxiYWNrLmNhbGwodGhpcywgZmFsc2UpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdC8vcmV0dXJuIGNhbGxiYWNrLmNhbGwodGhpcywgKG9iai5pZCA9PT0gJC5qc3RyZWUucm9vdCA/IHRoaXMuX2FwcGVuZF9odG1sX2RhdGEob2JqLCAkKHMpKSA6IGZhbHNlKSApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGNhbGxiYWNrLmNhbGwodGhpcywgZmFsc2UpO1xuXHRcdH0sXG5cdFx0LyoqXG5cdFx0ICogYWRkcyBhIG5vZGUgdG8gdGhlIGxpc3Qgb2Ygbm9kZXMgdG8gcmVkcmF3LiBVc2VkIG9ubHkgaW50ZXJuYWxseS5cblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqIEBuYW1lIF9ub2RlX2NoYW5nZWQob2JqIFssIGNhbGxiYWNrXSlcblx0XHQgKiBAcGFyYW0gIHttaXhlZH0gb2JqXG5cdFx0ICovXG5cdFx0X25vZGVfY2hhbmdlZCA6IGZ1bmN0aW9uIChvYmopIHtcblx0XHRcdG9iaiA9IHRoaXMuZ2V0X25vZGUob2JqKTtcblx0XHRcdGlmKG9iaikge1xuXHRcdFx0XHR0aGlzLl9tb2RlbC5jaGFuZ2VkLnB1c2gob2JqLmlkKTtcblx0XHRcdH1cblx0XHR9LFxuXHRcdC8qKlxuXHRcdCAqIGFwcGVuZHMgSFRNTCBjb250ZW50IHRvIHRoZSB0cmVlLiBVc2VkIGludGVybmFsbHkuXG5cdFx0ICogQHByaXZhdGVcblx0XHQgKiBAbmFtZSBfYXBwZW5kX2h0bWxfZGF0YShvYmosIGRhdGEpXG5cdFx0ICogQHBhcmFtICB7bWl4ZWR9IG9iaiB0aGUgbm9kZSB0byBhcHBlbmQgdG9cblx0XHQgKiBAcGFyYW0gIHtTdHJpbmd9IGRhdGEgdGhlIEhUTUwgc3RyaW5nIHRvIHBhcnNlIGFuZCBhcHBlbmRcblx0XHQgKiBAdHJpZ2dlciBtb2RlbC5qc3RyZWUsIGNoYW5nZWQuanN0cmVlXG5cdFx0ICovXG5cdFx0X2FwcGVuZF9odG1sX2RhdGEgOiBmdW5jdGlvbiAoZG9tLCBkYXRhLCBjYikge1xuXHRcdFx0ZG9tID0gdGhpcy5nZXRfbm9kZShkb20pO1xuXHRcdFx0ZG9tLmNoaWxkcmVuID0gW107XG5cdFx0XHRkb20uY2hpbGRyZW5fZCA9IFtdO1xuXHRcdFx0dmFyIGRhdCA9IGRhdGEuaXMoJ3VsJykgPyBkYXRhLmNoaWxkcmVuKCkgOiBkYXRhLFxuXHRcdFx0XHRwYXIgPSBkb20uaWQsXG5cdFx0XHRcdGNoZCA9IFtdLFxuXHRcdFx0XHRkcGMgPSBbXSxcblx0XHRcdFx0bSA9IHRoaXMuX21vZGVsLmRhdGEsXG5cdFx0XHRcdHAgPSBtW3Bhcl0sXG5cdFx0XHRcdHMgPSB0aGlzLl9kYXRhLmNvcmUuc2VsZWN0ZWQubGVuZ3RoLFxuXHRcdFx0XHR0bXAsIGksIGo7XG5cdFx0XHRkYXQuZWFjaCgkLnByb3h5KGZ1bmN0aW9uIChpLCB2KSB7XG5cdFx0XHRcdHRtcCA9IHRoaXMuX3BhcnNlX21vZGVsX2Zyb21faHRtbCgkKHYpLCBwYXIsIHAucGFyZW50cy5jb25jYXQoKSk7XG5cdFx0XHRcdGlmKHRtcCkge1xuXHRcdFx0XHRcdGNoZC5wdXNoKHRtcCk7XG5cdFx0XHRcdFx0ZHBjLnB1c2godG1wKTtcblx0XHRcdFx0XHRpZihtW3RtcF0uY2hpbGRyZW5fZC5sZW5ndGgpIHtcblx0XHRcdFx0XHRcdGRwYyA9IGRwYy5jb25jYXQobVt0bXBdLmNoaWxkcmVuX2QpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSwgdGhpcykpO1xuXHRcdFx0cC5jaGlsZHJlbiA9IGNoZDtcblx0XHRcdHAuY2hpbGRyZW5fZCA9IGRwYztcblx0XHRcdGZvcihpID0gMCwgaiA9IHAucGFyZW50cy5sZW5ndGg7IGkgPCBqOyBpKyspIHtcblx0XHRcdFx0bVtwLnBhcmVudHNbaV1dLmNoaWxkcmVuX2QgPSBtW3AucGFyZW50c1tpXV0uY2hpbGRyZW5fZC5jb25jYXQoZHBjKTtcblx0XHRcdH1cblx0XHRcdC8qKlxuXHRcdFx0ICogdHJpZ2dlcmVkIHdoZW4gbmV3IGRhdGEgaXMgaW5zZXJ0ZWQgdG8gdGhlIHRyZWUgbW9kZWxcblx0XHRcdCAqIEBldmVudFxuXHRcdFx0ICogQG5hbWUgbW9kZWwuanN0cmVlXG5cdFx0XHQgKiBAcGFyYW0ge0FycmF5fSBub2RlcyBhbiBhcnJheSBvZiBub2RlIElEc1xuXHRcdFx0ICogQHBhcmFtIHtTdHJpbmd9IHBhcmVudCB0aGUgcGFyZW50IElEIG9mIHRoZSBub2Rlc1xuXHRcdFx0ICovXG5cdFx0XHR0aGlzLnRyaWdnZXIoJ21vZGVsJywgeyBcIm5vZGVzXCIgOiBkcGMsICdwYXJlbnQnIDogcGFyIH0pO1xuXHRcdFx0aWYocGFyICE9PSAkLmpzdHJlZS5yb290KSB7XG5cdFx0XHRcdHRoaXMuX25vZGVfY2hhbmdlZChwYXIpO1xuXHRcdFx0XHR0aGlzLnJlZHJhdygpO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSB7XG5cdFx0XHRcdHRoaXMuZ2V0X2NvbnRhaW5lcl91bCgpLmNoaWxkcmVuKCcuanN0cmVlLWluaXRpYWwtbm9kZScpLnJlbW92ZSgpO1xuXHRcdFx0XHR0aGlzLnJlZHJhdyh0cnVlKTtcblx0XHRcdH1cblx0XHRcdGlmKHRoaXMuX2RhdGEuY29yZS5zZWxlY3RlZC5sZW5ndGggIT09IHMpIHtcblx0XHRcdFx0dGhpcy50cmlnZ2VyKCdjaGFuZ2VkJywgeyAnYWN0aW9uJyA6ICdtb2RlbCcsICdzZWxlY3RlZCcgOiB0aGlzLl9kYXRhLmNvcmUuc2VsZWN0ZWQgfSk7XG5cdFx0XHR9XG5cdFx0XHRjYi5jYWxsKHRoaXMsIHRydWUpO1xuXHRcdH0sXG5cdFx0LyoqXG5cdFx0ICogYXBwZW5kcyBKU09OIGNvbnRlbnQgdG8gdGhlIHRyZWUuIFVzZWQgaW50ZXJuYWxseS5cblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqIEBuYW1lIF9hcHBlbmRfanNvbl9kYXRhKG9iaiwgZGF0YSlcblx0XHQgKiBAcGFyYW0gIHttaXhlZH0gb2JqIHRoZSBub2RlIHRvIGFwcGVuZCB0b1xuXHRcdCAqIEBwYXJhbSAge1N0cmluZ30gZGF0YSB0aGUgSlNPTiBvYmplY3QgdG8gcGFyc2UgYW5kIGFwcGVuZFxuXHRcdCAqIEBwYXJhbSAge0Jvb2xlYW59IGZvcmNlX3Byb2Nlc3NpbmcgaW50ZXJuYWwgcGFyYW0gLSBkbyBub3Qgc2V0XG5cdFx0ICogQHRyaWdnZXIgbW9kZWwuanN0cmVlLCBjaGFuZ2VkLmpzdHJlZVxuXHRcdCAqL1xuXHRcdF9hcHBlbmRfanNvbl9kYXRhIDogZnVuY3Rpb24gKGRvbSwgZGF0YSwgY2IsIGZvcmNlX3Byb2Nlc3NpbmcpIHtcblx0XHRcdGlmKHRoaXMuZWxlbWVudCA9PT0gbnVsbCkgeyByZXR1cm47IH1cblx0XHRcdGRvbSA9IHRoaXMuZ2V0X25vZGUoZG9tKTtcblx0XHRcdGRvbS5jaGlsZHJlbiA9IFtdO1xuXHRcdFx0ZG9tLmNoaWxkcmVuX2QgPSBbXTtcblx0XHRcdC8vIColJEAhISFcblx0XHRcdGlmKGRhdGEuZCkge1xuXHRcdFx0XHRkYXRhID0gZGF0YS5kO1xuXHRcdFx0XHRpZih0eXBlb2YgZGF0YSA9PT0gXCJzdHJpbmdcIikge1xuXHRcdFx0XHRcdGRhdGEgPSBKU09OLnBhcnNlKGRhdGEpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRpZighJC5pc0FycmF5KGRhdGEpKSB7IGRhdGEgPSBbZGF0YV07IH1cblx0XHRcdHZhciB3ID0gbnVsbCxcblx0XHRcdFx0YXJncyA9IHtcblx0XHRcdFx0XHQnZGYnXHQ6IHRoaXMuX21vZGVsLmRlZmF1bHRfc3RhdGUsXG5cdFx0XHRcdFx0J2RhdCdcdDogZGF0YSxcblx0XHRcdFx0XHQncGFyJ1x0OiBkb20uaWQsXG5cdFx0XHRcdFx0J20nXHRcdDogdGhpcy5fbW9kZWwuZGF0YSxcblx0XHRcdFx0XHQndF9pZCdcdDogdGhpcy5faWQsXG5cdFx0XHRcdFx0J3RfY250J1x0OiB0aGlzLl9jbnQsXG5cdFx0XHRcdFx0J3NlbCdcdDogdGhpcy5fZGF0YS5jb3JlLnNlbGVjdGVkXG5cdFx0XHRcdH0sXG5cdFx0XHRcdGZ1bmMgPSBmdW5jdGlvbiAoZGF0YSwgdW5kZWZpbmVkKSB7XG5cdFx0XHRcdFx0aWYoZGF0YS5kYXRhKSB7IGRhdGEgPSBkYXRhLmRhdGE7IH1cblx0XHRcdFx0XHR2YXIgZGF0ID0gZGF0YS5kYXQsXG5cdFx0XHRcdFx0XHRwYXIgPSBkYXRhLnBhcixcblx0XHRcdFx0XHRcdGNoZCA9IFtdLFxuXHRcdFx0XHRcdFx0ZHBjID0gW10sXG5cdFx0XHRcdFx0XHRhZGQgPSBbXSxcblx0XHRcdFx0XHRcdGRmID0gZGF0YS5kZixcblx0XHRcdFx0XHRcdHRfaWQgPSBkYXRhLnRfaWQsXG5cdFx0XHRcdFx0XHR0X2NudCA9IGRhdGEudF9jbnQsXG5cdFx0XHRcdFx0XHRtID0gZGF0YS5tLFxuXHRcdFx0XHRcdFx0cCA9IG1bcGFyXSxcblx0XHRcdFx0XHRcdHNlbCA9IGRhdGEuc2VsLFxuXHRcdFx0XHRcdFx0dG1wLCBpLCBqLCByc2x0LFxuXHRcdFx0XHRcdFx0cGFyc2VfZmxhdCA9IGZ1bmN0aW9uIChkLCBwLCBwcykge1xuXHRcdFx0XHRcdFx0XHRpZighcHMpIHsgcHMgPSBbXTsgfVxuXHRcdFx0XHRcdFx0XHRlbHNlIHsgcHMgPSBwcy5jb25jYXQoKTsgfVxuXHRcdFx0XHRcdFx0XHRpZihwKSB7IHBzLnVuc2hpZnQocCk7IH1cblx0XHRcdFx0XHRcdFx0dmFyIHRpZCA9IGQuaWQudG9TdHJpbmcoKSxcblx0XHRcdFx0XHRcdFx0XHRpLCBqLCBjLCBlLFxuXHRcdFx0XHRcdFx0XHRcdHRtcCA9IHtcblx0XHRcdFx0XHRcdFx0XHRcdGlkXHRcdFx0OiB0aWQsXG5cdFx0XHRcdFx0XHRcdFx0XHR0ZXh0XHRcdDogZC50ZXh0IHx8ICcnLFxuXHRcdFx0XHRcdFx0XHRcdFx0aWNvblx0XHQ6IGQuaWNvbiAhPT0gdW5kZWZpbmVkID8gZC5pY29uIDogdHJ1ZSxcblx0XHRcdFx0XHRcdFx0XHRcdHBhcmVudFx0XHQ6IHAsXG5cdFx0XHRcdFx0XHRcdFx0XHRwYXJlbnRzXHRcdDogcHMsXG5cdFx0XHRcdFx0XHRcdFx0XHRjaGlsZHJlblx0OiBkLmNoaWxkcmVuIHx8IFtdLFxuXHRcdFx0XHRcdFx0XHRcdFx0Y2hpbGRyZW5fZFx0OiBkLmNoaWxkcmVuX2QgfHwgW10sXG5cdFx0XHRcdFx0XHRcdFx0XHRkYXRhXHRcdDogZC5kYXRhLFxuXHRcdFx0XHRcdFx0XHRcdFx0c3RhdGVcdFx0OiB7IH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRsaV9hdHRyXHRcdDogeyBpZCA6IGZhbHNlIH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRhX2F0dHJcdFx0OiB7IGhyZWYgOiAnIycgfSxcblx0XHRcdFx0XHRcdFx0XHRcdG9yaWdpbmFsXHQ6IGZhbHNlXG5cdFx0XHRcdFx0XHRcdFx0fTtcblx0XHRcdFx0XHRcdFx0Zm9yKGkgaW4gZGYpIHtcblx0XHRcdFx0XHRcdFx0XHRpZihkZi5oYXNPd25Qcm9wZXJ0eShpKSkge1xuXHRcdFx0XHRcdFx0XHRcdFx0dG1wLnN0YXRlW2ldID0gZGZbaV07XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdGlmKGQgJiYgZC5kYXRhICYmIGQuZGF0YS5qc3RyZWUgJiYgZC5kYXRhLmpzdHJlZS5pY29uKSB7XG5cdFx0XHRcdFx0XHRcdFx0dG1wLmljb24gPSBkLmRhdGEuanN0cmVlLmljb247XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0aWYodG1wLmljb24gPT09IHVuZGVmaW5lZCB8fCB0bXAuaWNvbiA9PT0gbnVsbCB8fCB0bXAuaWNvbiA9PT0gXCJcIikge1xuXHRcdFx0XHRcdFx0XHRcdHRtcC5pY29uID0gdHJ1ZTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRpZihkICYmIGQuZGF0YSkge1xuXHRcdFx0XHRcdFx0XHRcdHRtcC5kYXRhID0gZC5kYXRhO1xuXHRcdFx0XHRcdFx0XHRcdGlmKGQuZGF0YS5qc3RyZWUpIHtcblx0XHRcdFx0XHRcdFx0XHRcdGZvcihpIGluIGQuZGF0YS5qc3RyZWUpIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWYoZC5kYXRhLmpzdHJlZS5oYXNPd25Qcm9wZXJ0eShpKSkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHRtcC5zdGF0ZVtpXSA9IGQuZGF0YS5qc3RyZWVbaV07XG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0aWYoZCAmJiB0eXBlb2YgZC5zdGF0ZSA9PT0gJ29iamVjdCcpIHtcblx0XHRcdFx0XHRcdFx0XHRmb3IgKGkgaW4gZC5zdGF0ZSkge1xuXHRcdFx0XHRcdFx0XHRcdFx0aWYoZC5zdGF0ZS5oYXNPd25Qcm9wZXJ0eShpKSkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0bXAuc3RhdGVbaV0gPSBkLnN0YXRlW2ldO1xuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRpZihkICYmIHR5cGVvZiBkLmxpX2F0dHIgPT09ICdvYmplY3QnKSB7XG5cdFx0XHRcdFx0XHRcdFx0Zm9yIChpIGluIGQubGlfYXR0cikge1xuXHRcdFx0XHRcdFx0XHRcdFx0aWYoZC5saV9hdHRyLmhhc093blByb3BlcnR5KGkpKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHRtcC5saV9hdHRyW2ldID0gZC5saV9hdHRyW2ldO1xuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRpZighdG1wLmxpX2F0dHIuaWQpIHtcblx0XHRcdFx0XHRcdFx0XHR0bXAubGlfYXR0ci5pZCA9IHRpZDtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRpZihkICYmIHR5cGVvZiBkLmFfYXR0ciA9PT0gJ29iamVjdCcpIHtcblx0XHRcdFx0XHRcdFx0XHRmb3IgKGkgaW4gZC5hX2F0dHIpIHtcblx0XHRcdFx0XHRcdFx0XHRcdGlmKGQuYV9hdHRyLmhhc093blByb3BlcnR5KGkpKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHRtcC5hX2F0dHJbaV0gPSBkLmFfYXR0cltpXTtcblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0aWYoZCAmJiBkLmNoaWxkcmVuICYmIGQuY2hpbGRyZW4gPT09IHRydWUpIHtcblx0XHRcdFx0XHRcdFx0XHR0bXAuc3RhdGUubG9hZGVkID0gZmFsc2U7XG5cdFx0XHRcdFx0XHRcdFx0dG1wLmNoaWxkcmVuID0gW107XG5cdFx0XHRcdFx0XHRcdFx0dG1wLmNoaWxkcmVuX2QgPSBbXTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRtW3RtcC5pZF0gPSB0bXA7XG5cdFx0XHRcdFx0XHRcdGZvcihpID0gMCwgaiA9IHRtcC5jaGlsZHJlbi5sZW5ndGg7IGkgPCBqOyBpKyspIHtcblx0XHRcdFx0XHRcdFx0XHRjID0gcGFyc2VfZmxhdChtW3RtcC5jaGlsZHJlbltpXV0sIHRtcC5pZCwgcHMpO1xuXHRcdFx0XHRcdFx0XHRcdGUgPSBtW2NdO1xuXHRcdFx0XHRcdFx0XHRcdHRtcC5jaGlsZHJlbl9kLnB1c2goYyk7XG5cdFx0XHRcdFx0XHRcdFx0aWYoZS5jaGlsZHJlbl9kLmxlbmd0aCkge1xuXHRcdFx0XHRcdFx0XHRcdFx0dG1wLmNoaWxkcmVuX2QgPSB0bXAuY2hpbGRyZW5fZC5jb25jYXQoZS5jaGlsZHJlbl9kKTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0ZGVsZXRlIGQuZGF0YTtcblx0XHRcdFx0XHRcdFx0ZGVsZXRlIGQuY2hpbGRyZW47XG5cdFx0XHRcdFx0XHRcdG1bdG1wLmlkXS5vcmlnaW5hbCA9IGQ7XG5cdFx0XHRcdFx0XHRcdGlmKHRtcC5zdGF0ZS5zZWxlY3RlZCkge1xuXHRcdFx0XHRcdFx0XHRcdGFkZC5wdXNoKHRtcC5pZCk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0cmV0dXJuIHRtcC5pZDtcblx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRwYXJzZV9uZXN0ID0gZnVuY3Rpb24gKGQsIHAsIHBzKSB7XG5cdFx0XHRcdFx0XHRcdGlmKCFwcykgeyBwcyA9IFtdOyB9XG5cdFx0XHRcdFx0XHRcdGVsc2UgeyBwcyA9IHBzLmNvbmNhdCgpOyB9XG5cdFx0XHRcdFx0XHRcdGlmKHApIHsgcHMudW5zaGlmdChwKTsgfVxuXHRcdFx0XHRcdFx0XHR2YXIgdGlkID0gZmFsc2UsIGksIGosIGMsIGUsIHRtcDtcblx0XHRcdFx0XHRcdFx0ZG8ge1xuXHRcdFx0XHRcdFx0XHRcdHRpZCA9ICdqJyArIHRfaWQgKyAnXycgKyAoKyt0X2NudCk7XG5cdFx0XHRcdFx0XHRcdH0gd2hpbGUobVt0aWRdKTtcblxuXHRcdFx0XHRcdFx0XHR0bXAgPSB7XG5cdFx0XHRcdFx0XHRcdFx0aWRcdFx0XHQ6IGZhbHNlLFxuXHRcdFx0XHRcdFx0XHRcdHRleHRcdFx0OiB0eXBlb2YgZCA9PT0gJ3N0cmluZycgPyBkIDogJycsXG5cdFx0XHRcdFx0XHRcdFx0aWNvblx0XHQ6IHR5cGVvZiBkID09PSAnb2JqZWN0JyAmJiBkLmljb24gIT09IHVuZGVmaW5lZCA/IGQuaWNvbiA6IHRydWUsXG5cdFx0XHRcdFx0XHRcdFx0cGFyZW50XHRcdDogcCxcblx0XHRcdFx0XHRcdFx0XHRwYXJlbnRzXHRcdDogcHMsXG5cdFx0XHRcdFx0XHRcdFx0Y2hpbGRyZW5cdDogW10sXG5cdFx0XHRcdFx0XHRcdFx0Y2hpbGRyZW5fZFx0OiBbXSxcblx0XHRcdFx0XHRcdFx0XHRkYXRhXHRcdDogbnVsbCxcblx0XHRcdFx0XHRcdFx0XHRzdGF0ZVx0XHQ6IHsgfSxcblx0XHRcdFx0XHRcdFx0XHRsaV9hdHRyXHRcdDogeyBpZCA6IGZhbHNlIH0sXG5cdFx0XHRcdFx0XHRcdFx0YV9hdHRyXHRcdDogeyBocmVmIDogJyMnIH0sXG5cdFx0XHRcdFx0XHRcdFx0b3JpZ2luYWxcdDogZmFsc2Vcblx0XHRcdFx0XHRcdFx0fTtcblx0XHRcdFx0XHRcdFx0Zm9yKGkgaW4gZGYpIHtcblx0XHRcdFx0XHRcdFx0XHRpZihkZi5oYXNPd25Qcm9wZXJ0eShpKSkge1xuXHRcdFx0XHRcdFx0XHRcdFx0dG1wLnN0YXRlW2ldID0gZGZbaV07XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdGlmKGQgJiYgZC5pZCkgeyB0bXAuaWQgPSBkLmlkLnRvU3RyaW5nKCk7IH1cblx0XHRcdFx0XHRcdFx0aWYoZCAmJiBkLnRleHQpIHsgdG1wLnRleHQgPSBkLnRleHQ7IH1cblx0XHRcdFx0XHRcdFx0aWYoZCAmJiBkLmRhdGEgJiYgZC5kYXRhLmpzdHJlZSAmJiBkLmRhdGEuanN0cmVlLmljb24pIHtcblx0XHRcdFx0XHRcdFx0XHR0bXAuaWNvbiA9IGQuZGF0YS5qc3RyZWUuaWNvbjtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRpZih0bXAuaWNvbiA9PT0gdW5kZWZpbmVkIHx8IHRtcC5pY29uID09PSBudWxsIHx8IHRtcC5pY29uID09PSBcIlwiKSB7XG5cdFx0XHRcdFx0XHRcdFx0dG1wLmljb24gPSB0cnVlO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdGlmKGQgJiYgZC5kYXRhKSB7XG5cdFx0XHRcdFx0XHRcdFx0dG1wLmRhdGEgPSBkLmRhdGE7XG5cdFx0XHRcdFx0XHRcdFx0aWYoZC5kYXRhLmpzdHJlZSkge1xuXHRcdFx0XHRcdFx0XHRcdFx0Zm9yKGkgaW4gZC5kYXRhLmpzdHJlZSkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZihkLmRhdGEuanN0cmVlLmhhc093blByb3BlcnR5KGkpKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0dG1wLnN0YXRlW2ldID0gZC5kYXRhLmpzdHJlZVtpXTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRpZihkICYmIHR5cGVvZiBkLnN0YXRlID09PSAnb2JqZWN0Jykge1xuXHRcdFx0XHRcdFx0XHRcdGZvciAoaSBpbiBkLnN0YXRlKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRpZihkLnN0YXRlLmhhc093blByb3BlcnR5KGkpKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHRtcC5zdGF0ZVtpXSA9IGQuc3RhdGVbaV07XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdGlmKGQgJiYgdHlwZW9mIGQubGlfYXR0ciA9PT0gJ29iamVjdCcpIHtcblx0XHRcdFx0XHRcdFx0XHRmb3IgKGkgaW4gZC5saV9hdHRyKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRpZihkLmxpX2F0dHIuaGFzT3duUHJvcGVydHkoaSkpIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dG1wLmxpX2F0dHJbaV0gPSBkLmxpX2F0dHJbaV07XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdGlmKHRtcC5saV9hdHRyLmlkICYmICF0bXAuaWQpIHtcblx0XHRcdFx0XHRcdFx0XHR0bXAuaWQgPSB0bXAubGlfYXR0ci5pZC50b1N0cmluZygpO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdGlmKCF0bXAuaWQpIHtcblx0XHRcdFx0XHRcdFx0XHR0bXAuaWQgPSB0aWQ7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0aWYoIXRtcC5saV9hdHRyLmlkKSB7XG5cdFx0XHRcdFx0XHRcdFx0dG1wLmxpX2F0dHIuaWQgPSB0bXAuaWQ7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0aWYoZCAmJiB0eXBlb2YgZC5hX2F0dHIgPT09ICdvYmplY3QnKSB7XG5cdFx0XHRcdFx0XHRcdFx0Zm9yIChpIGluIGQuYV9hdHRyKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRpZihkLmFfYXR0ci5oYXNPd25Qcm9wZXJ0eShpKSkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0bXAuYV9hdHRyW2ldID0gZC5hX2F0dHJbaV07XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdGlmKGQgJiYgZC5jaGlsZHJlbiAmJiBkLmNoaWxkcmVuLmxlbmd0aCkge1xuXHRcdFx0XHRcdFx0XHRcdGZvcihpID0gMCwgaiA9IGQuY2hpbGRyZW4ubGVuZ3RoOyBpIDwgajsgaSsrKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRjID0gcGFyc2VfbmVzdChkLmNoaWxkcmVuW2ldLCB0bXAuaWQsIHBzKTtcblx0XHRcdFx0XHRcdFx0XHRcdGUgPSBtW2NdO1xuXHRcdFx0XHRcdFx0XHRcdFx0dG1wLmNoaWxkcmVuLnB1c2goYyk7XG5cdFx0XHRcdFx0XHRcdFx0XHRpZihlLmNoaWxkcmVuX2QubGVuZ3RoKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHRtcC5jaGlsZHJlbl9kID0gdG1wLmNoaWxkcmVuX2QuY29uY2F0KGUuY2hpbGRyZW5fZCk7XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdHRtcC5jaGlsZHJlbl9kID0gdG1wLmNoaWxkcmVuX2QuY29uY2F0KHRtcC5jaGlsZHJlbik7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0aWYoZCAmJiBkLmNoaWxkcmVuICYmIGQuY2hpbGRyZW4gPT09IHRydWUpIHtcblx0XHRcdFx0XHRcdFx0XHR0bXAuc3RhdGUubG9hZGVkID0gZmFsc2U7XG5cdFx0XHRcdFx0XHRcdFx0dG1wLmNoaWxkcmVuID0gW107XG5cdFx0XHRcdFx0XHRcdFx0dG1wLmNoaWxkcmVuX2QgPSBbXTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRkZWxldGUgZC5kYXRhO1xuXHRcdFx0XHRcdFx0XHRkZWxldGUgZC5jaGlsZHJlbjtcblx0XHRcdFx0XHRcdFx0dG1wLm9yaWdpbmFsID0gZDtcblx0XHRcdFx0XHRcdFx0bVt0bXAuaWRdID0gdG1wO1xuXHRcdFx0XHRcdFx0XHRpZih0bXAuc3RhdGUuc2VsZWN0ZWQpIHtcblx0XHRcdFx0XHRcdFx0XHRhZGQucHVzaCh0bXAuaWQpO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdHJldHVybiB0bXAuaWQ7XG5cdFx0XHRcdFx0XHR9O1xuXG5cdFx0XHRcdFx0aWYoZGF0Lmxlbmd0aCAmJiBkYXRbMF0uaWQgIT09IHVuZGVmaW5lZCAmJiBkYXRbMF0ucGFyZW50ICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHRcdC8vIEZsYXQgSlNPTiBzdXBwb3J0IChmb3IgZWFzeSBpbXBvcnQgZnJvbSBEQik6XG5cdFx0XHRcdFx0XHQvLyAxKSBjb252ZXJ0IHRvIG9iamVjdCAoZm9yZWFjaClcblx0XHRcdFx0XHRcdGZvcihpID0gMCwgaiA9IGRhdC5sZW5ndGg7IGkgPCBqOyBpKyspIHtcblx0XHRcdFx0XHRcdFx0aWYoIWRhdFtpXS5jaGlsZHJlbikge1xuXHRcdFx0XHRcdFx0XHRcdGRhdFtpXS5jaGlsZHJlbiA9IFtdO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdG1bZGF0W2ldLmlkLnRvU3RyaW5nKCldID0gZGF0W2ldO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0Ly8gMikgcG9wdWxhdGUgY2hpbGRyZW4gKGZvcmVhY2gpXG5cdFx0XHRcdFx0XHRmb3IoaSA9IDAsIGogPSBkYXQubGVuZ3RoOyBpIDwgajsgaSsrKSB7XG5cdFx0XHRcdFx0XHRcdG1bZGF0W2ldLnBhcmVudC50b1N0cmluZygpXS5jaGlsZHJlbi5wdXNoKGRhdFtpXS5pZC50b1N0cmluZygpKTtcblx0XHRcdFx0XHRcdFx0Ly8gcG9wdWxhdGUgcGFyZW50LmNoaWxkcmVuX2Rcblx0XHRcdFx0XHRcdFx0cC5jaGlsZHJlbl9kLnB1c2goZGF0W2ldLmlkLnRvU3RyaW5nKCkpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0Ly8gMykgbm9ybWFsaXplICYmIHBvcHVsYXRlIHBhcmVudHMgYW5kIGNoaWxkcmVuX2Qgd2l0aCByZWN1cnNpb25cblx0XHRcdFx0XHRcdGZvcihpID0gMCwgaiA9IHAuY2hpbGRyZW4ubGVuZ3RoOyBpIDwgajsgaSsrKSB7XG5cdFx0XHRcdFx0XHRcdHRtcCA9IHBhcnNlX2ZsYXQobVtwLmNoaWxkcmVuW2ldXSwgcGFyLCBwLnBhcmVudHMuY29uY2F0KCkpO1xuXHRcdFx0XHRcdFx0XHRkcGMucHVzaCh0bXApO1xuXHRcdFx0XHRcdFx0XHRpZihtW3RtcF0uY2hpbGRyZW5fZC5sZW5ndGgpIHtcblx0XHRcdFx0XHRcdFx0XHRkcGMgPSBkcGMuY29uY2F0KG1bdG1wXS5jaGlsZHJlbl9kKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0Zm9yKGkgPSAwLCBqID0gcC5wYXJlbnRzLmxlbmd0aDsgaSA8IGo7IGkrKykge1xuXHRcdFx0XHRcdFx0XHRtW3AucGFyZW50c1tpXV0uY2hpbGRyZW5fZCA9IG1bcC5wYXJlbnRzW2ldXS5jaGlsZHJlbl9kLmNvbmNhdChkcGMpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0Ly8gPykgdGhyZWVfc3RhdGUgc2VsZWN0aW9uIC0gcC5zdGF0ZS5zZWxlY3RlZCAmJiB0IC0gKGlmIHRocmVlX3N0YXRlIGZvcmVhY2goZGF0ID0+IGNoKSAtPiBmb3JlYWNoKHBhcmVudHMpIGlmKHBhcmVudC5zZWxlY3RlZCkgY2hpbGQuc2VsZWN0ZWQgPSB0cnVlO1xuXHRcdFx0XHRcdFx0cnNsdCA9IHtcblx0XHRcdFx0XHRcdFx0J2NudCcgOiB0X2NudCxcblx0XHRcdFx0XHRcdFx0J21vZCcgOiBtLFxuXHRcdFx0XHRcdFx0XHQnc2VsJyA6IHNlbCxcblx0XHRcdFx0XHRcdFx0J3BhcicgOiBwYXIsXG5cdFx0XHRcdFx0XHRcdCdkcGMnIDogZHBjLFxuXHRcdFx0XHRcdFx0XHQnYWRkJyA6IGFkZFxuXHRcdFx0XHRcdFx0fTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0XHRmb3IoaSA9IDAsIGogPSBkYXQubGVuZ3RoOyBpIDwgajsgaSsrKSB7XG5cdFx0XHRcdFx0XHRcdHRtcCA9IHBhcnNlX25lc3QoZGF0W2ldLCBwYXIsIHAucGFyZW50cy5jb25jYXQoKSk7XG5cdFx0XHRcdFx0XHRcdGlmKHRtcCkge1xuXHRcdFx0XHRcdFx0XHRcdGNoZC5wdXNoKHRtcCk7XG5cdFx0XHRcdFx0XHRcdFx0ZHBjLnB1c2godG1wKTtcblx0XHRcdFx0XHRcdFx0XHRpZihtW3RtcF0uY2hpbGRyZW5fZC5sZW5ndGgpIHtcblx0XHRcdFx0XHRcdFx0XHRcdGRwYyA9IGRwYy5jb25jYXQobVt0bXBdLmNoaWxkcmVuX2QpO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0cC5jaGlsZHJlbiA9IGNoZDtcblx0XHRcdFx0XHRcdHAuY2hpbGRyZW5fZCA9IGRwYztcblx0XHRcdFx0XHRcdGZvcihpID0gMCwgaiA9IHAucGFyZW50cy5sZW5ndGg7IGkgPCBqOyBpKyspIHtcblx0XHRcdFx0XHRcdFx0bVtwLnBhcmVudHNbaV1dLmNoaWxkcmVuX2QgPSBtW3AucGFyZW50c1tpXV0uY2hpbGRyZW5fZC5jb25jYXQoZHBjKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdHJzbHQgPSB7XG5cdFx0XHRcdFx0XHRcdCdjbnQnIDogdF9jbnQsXG5cdFx0XHRcdFx0XHRcdCdtb2QnIDogbSxcblx0XHRcdFx0XHRcdFx0J3NlbCcgOiBzZWwsXG5cdFx0XHRcdFx0XHRcdCdwYXInIDogcGFyLFxuXHRcdFx0XHRcdFx0XHQnZHBjJyA6IGRwYyxcblx0XHRcdFx0XHRcdFx0J2FkZCcgOiBhZGRcblx0XHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnIHx8IHR5cGVvZiB3aW5kb3cuZG9jdW1lbnQgPT09ICd1bmRlZmluZWQnKSB7XG5cdFx0XHRcdFx0XHRwb3N0TWVzc2FnZShyc2x0KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gcnNsdDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0sXG5cdFx0XHRcdHJzbHQgPSBmdW5jdGlvbiAocnNsdCwgd29ya2VyKSB7XG5cdFx0XHRcdFx0aWYodGhpcy5lbGVtZW50ID09PSBudWxsKSB7IHJldHVybjsgfVxuXHRcdFx0XHRcdHRoaXMuX2NudCA9IHJzbHQuY250O1xuXHRcdFx0XHRcdHZhciBpLCBtID0gdGhpcy5fbW9kZWwuZGF0YTtcblx0XHRcdFx0XHRmb3IgKGkgaW4gbSkge1xuXHRcdFx0XHRcdFx0aWYgKG0uaGFzT3duUHJvcGVydHkoaSkgJiYgbVtpXS5zdGF0ZSAmJiBtW2ldLnN0YXRlLmxvYWRpbmcgJiYgcnNsdC5tb2RbaV0pIHtcblx0XHRcdFx0XHRcdFx0cnNsdC5tb2RbaV0uc3RhdGUubG9hZGluZyA9IHRydWU7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHRoaXMuX21vZGVsLmRhdGEgPSByc2x0Lm1vZDsgLy8gYnJlYWtzIHRoZSByZWZlcmVuY2UgaW4gbG9hZF9ub2RlIC0gY2FyZWZ1bFxuXG5cdFx0XHRcdFx0aWYod29ya2VyKSB7XG5cdFx0XHRcdFx0XHR2YXIgaiwgYSA9IHJzbHQuYWRkLCByID0gcnNsdC5zZWwsIHMgPSB0aGlzLl9kYXRhLmNvcmUuc2VsZWN0ZWQuc2xpY2UoKTtcblx0XHRcdFx0XHRcdG0gPSB0aGlzLl9tb2RlbC5kYXRhO1xuXHRcdFx0XHRcdFx0Ly8gaWYgc2VsZWN0aW9uIHdhcyBjaGFuZ2VkIHdoaWxlIGNhbGN1bGF0aW5nIGluIHdvcmtlclxuXHRcdFx0XHRcdFx0aWYoci5sZW5ndGggIT09IHMubGVuZ3RoIHx8ICQudmFrYXRhLmFycmF5X3VuaXF1ZShyLmNvbmNhdChzKSkubGVuZ3RoICE9PSByLmxlbmd0aCkge1xuXHRcdFx0XHRcdFx0XHQvLyBkZXNlbGVjdCBub2RlcyB0aGF0IGFyZSBubyBsb25nZXIgc2VsZWN0ZWRcblx0XHRcdFx0XHRcdFx0Zm9yKGkgPSAwLCBqID0gci5sZW5ndGg7IGkgPCBqOyBpKyspIHtcblx0XHRcdFx0XHRcdFx0XHRpZigkLmluQXJyYXkocltpXSwgYSkgPT09IC0xICYmICQuaW5BcnJheShyW2ldLCBzKSA9PT0gLTEpIHtcblx0XHRcdFx0XHRcdFx0XHRcdG1bcltpXV0uc3RhdGUuc2VsZWN0ZWQgPSBmYWxzZTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0Ly8gc2VsZWN0IG5vZGVzIHRoYXQgd2VyZSBzZWxlY3RlZCBpbiB0aGUgbWVhbiB0aW1lXG5cdFx0XHRcdFx0XHRcdGZvcihpID0gMCwgaiA9IHMubGVuZ3RoOyBpIDwgajsgaSsrKSB7XG5cdFx0XHRcdFx0XHRcdFx0aWYoJC5pbkFycmF5KHNbaV0sIHIpID09PSAtMSkge1xuXHRcdFx0XHRcdFx0XHRcdFx0bVtzW2ldXS5zdGF0ZS5zZWxlY3RlZCA9IHRydWU7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmKHJzbHQuYWRkLmxlbmd0aCkge1xuXHRcdFx0XHRcdFx0dGhpcy5fZGF0YS5jb3JlLnNlbGVjdGVkID0gdGhpcy5fZGF0YS5jb3JlLnNlbGVjdGVkLmNvbmNhdChyc2x0LmFkZCk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0dGhpcy50cmlnZ2VyKCdtb2RlbCcsIHsgXCJub2Rlc1wiIDogcnNsdC5kcGMsICdwYXJlbnQnIDogcnNsdC5wYXIgfSk7XG5cblx0XHRcdFx0XHRpZihyc2x0LnBhciAhPT0gJC5qc3RyZWUucm9vdCkge1xuXHRcdFx0XHRcdFx0dGhpcy5fbm9kZV9jaGFuZ2VkKHJzbHQucGFyKTtcblx0XHRcdFx0XHRcdHRoaXMucmVkcmF3KCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdFx0Ly8gdGhpcy5nZXRfY29udGFpbmVyX3VsKCkuY2hpbGRyZW4oJy5qc3RyZWUtaW5pdGlhbC1ub2RlJykucmVtb3ZlKCk7XG5cdFx0XHRcdFx0XHR0aGlzLnJlZHJhdyh0cnVlKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYocnNsdC5hZGQubGVuZ3RoKSB7XG5cdFx0XHRcdFx0XHR0aGlzLnRyaWdnZXIoJ2NoYW5nZWQnLCB7ICdhY3Rpb24nIDogJ21vZGVsJywgJ3NlbGVjdGVkJyA6IHRoaXMuX2RhdGEuY29yZS5zZWxlY3RlZCB9KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0Y2IuY2FsbCh0aGlzLCB0cnVlKTtcblx0XHRcdFx0fTtcblx0XHRcdGlmKHRoaXMuc2V0dGluZ3MuY29yZS53b3JrZXIgJiYgd2luZG93LkJsb2IgJiYgd2luZG93LlVSTCAmJiB3aW5kb3cuV29ya2VyKSB7XG5cdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0aWYodGhpcy5fd3JrID09PSBudWxsKSB7XG5cdFx0XHRcdFx0XHR0aGlzLl93cmsgPSB3aW5kb3cuVVJMLmNyZWF0ZU9iamVjdFVSTChcblx0XHRcdFx0XHRcdFx0bmV3IHdpbmRvdy5CbG9iKFxuXHRcdFx0XHRcdFx0XHRcdFsnc2VsZi5vbm1lc3NhZ2UgPSAnICsgZnVuYy50b1N0cmluZygpXSxcblx0XHRcdFx0XHRcdFx0XHR7dHlwZTpcInRleHQvamF2YXNjcmlwdFwifVxuXHRcdFx0XHRcdFx0XHQpXG5cdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZighdGhpcy5fZGF0YS5jb3JlLndvcmtpbmcgfHwgZm9yY2VfcHJvY2Vzc2luZykge1xuXHRcdFx0XHRcdFx0dGhpcy5fZGF0YS5jb3JlLndvcmtpbmcgPSB0cnVlO1xuXHRcdFx0XHRcdFx0dyA9IG5ldyB3aW5kb3cuV29ya2VyKHRoaXMuX3dyayk7XG5cdFx0XHRcdFx0XHR3Lm9ubWVzc2FnZSA9ICQucHJveHkoZnVuY3Rpb24gKGUpIHtcblx0XHRcdFx0XHRcdFx0cnNsdC5jYWxsKHRoaXMsIGUuZGF0YSwgdHJ1ZSk7XG5cdFx0XHRcdFx0XHRcdHRyeSB7IHcudGVybWluYXRlKCk7IHcgPSBudWxsOyB9IGNhdGNoKGlnbm9yZSkgeyB9XG5cdFx0XHRcdFx0XHRcdGlmKHRoaXMuX2RhdGEuY29yZS53b3JrZXJfcXVldWUubGVuZ3RoKSB7XG5cdFx0XHRcdFx0XHRcdFx0dGhpcy5fYXBwZW5kX2pzb25fZGF0YS5hcHBseSh0aGlzLCB0aGlzLl9kYXRhLmNvcmUud29ya2VyX3F1ZXVlLnNoaWZ0KCkpO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdHRoaXMuX2RhdGEuY29yZS53b3JraW5nID0gZmFsc2U7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH0sIHRoaXMpO1xuXHRcdFx0XHRcdFx0aWYoIWFyZ3MucGFyKSB7XG5cdFx0XHRcdFx0XHRcdGlmKHRoaXMuX2RhdGEuY29yZS53b3JrZXJfcXVldWUubGVuZ3RoKSB7XG5cdFx0XHRcdFx0XHRcdFx0dGhpcy5fYXBwZW5kX2pzb25fZGF0YS5hcHBseSh0aGlzLCB0aGlzLl9kYXRhLmNvcmUud29ya2VyX3F1ZXVlLnNoaWZ0KCkpO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdHRoaXMuX2RhdGEuY29yZS53b3JraW5nID0gZmFsc2U7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdFx0XHR3LnBvc3RNZXNzYWdlKGFyZ3MpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRcdHRoaXMuX2RhdGEuY29yZS53b3JrZXJfcXVldWUucHVzaChbZG9tLCBkYXRhLCBjYiwgdHJ1ZV0pO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRjYXRjaChlKSB7XG5cdFx0XHRcdFx0cnNsdC5jYWxsKHRoaXMsIGZ1bmMoYXJncyksIGZhbHNlKTtcblx0XHRcdFx0XHRpZih0aGlzLl9kYXRhLmNvcmUud29ya2VyX3F1ZXVlLmxlbmd0aCkge1xuXHRcdFx0XHRcdFx0dGhpcy5fYXBwZW5kX2pzb25fZGF0YS5hcHBseSh0aGlzLCB0aGlzLl9kYXRhLmNvcmUud29ya2VyX3F1ZXVlLnNoaWZ0KCkpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRcdHRoaXMuX2RhdGEuY29yZS53b3JraW5nID0gZmFsc2U7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRlbHNlIHtcblx0XHRcdFx0cnNsdC5jYWxsKHRoaXMsIGZ1bmMoYXJncyksIGZhbHNlKTtcblx0XHRcdH1cblx0XHR9LFxuXHRcdC8qKlxuXHRcdCAqIHBhcnNlcyBhIG5vZGUgZnJvbSBhIGpRdWVyeSBvYmplY3QgYW5kIGFwcGVuZHMgdGhlbSB0byB0aGUgaW4gbWVtb3J5IHRyZWUgbW9kZWwuIFVzZWQgaW50ZXJuYWxseS5cblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqIEBuYW1lIF9wYXJzZV9tb2RlbF9mcm9tX2h0bWwoZCBbLCBwLCBwc10pXG5cdFx0ICogQHBhcmFtICB7alF1ZXJ5fSBkIHRoZSBqUXVlcnkgb2JqZWN0IHRvIHBhcnNlXG5cdFx0ICogQHBhcmFtICB7U3RyaW5nfSBwIHRoZSBwYXJlbnQgSURcblx0XHQgKiBAcGFyYW0gIHtBcnJheX0gcHMgbGlzdCBvZiBhbGwgcGFyZW50c1xuXHRcdCAqIEByZXR1cm4ge1N0cmluZ30gdGhlIElEIG9mIHRoZSBvYmplY3QgYWRkZWQgdG8gdGhlIG1vZGVsXG5cdFx0ICovXG5cdFx0X3BhcnNlX21vZGVsX2Zyb21faHRtbCA6IGZ1bmN0aW9uIChkLCBwLCBwcykge1xuXHRcdFx0aWYoIXBzKSB7IHBzID0gW107IH1cblx0XHRcdGVsc2UgeyBwcyA9IFtdLmNvbmNhdChwcyk7IH1cblx0XHRcdGlmKHApIHsgcHMudW5zaGlmdChwKTsgfVxuXHRcdFx0dmFyIGMsIGUsIG0gPSB0aGlzLl9tb2RlbC5kYXRhLFxuXHRcdFx0XHRkYXRhID0ge1xuXHRcdFx0XHRcdGlkXHRcdFx0OiBmYWxzZSxcblx0XHRcdFx0XHR0ZXh0XHRcdDogZmFsc2UsXG5cdFx0XHRcdFx0aWNvblx0XHQ6IHRydWUsXG5cdFx0XHRcdFx0cGFyZW50XHRcdDogcCxcblx0XHRcdFx0XHRwYXJlbnRzXHRcdDogcHMsXG5cdFx0XHRcdFx0Y2hpbGRyZW5cdDogW10sXG5cdFx0XHRcdFx0Y2hpbGRyZW5fZFx0OiBbXSxcblx0XHRcdFx0XHRkYXRhXHRcdDogbnVsbCxcblx0XHRcdFx0XHRzdGF0ZVx0XHQ6IHsgfSxcblx0XHRcdFx0XHRsaV9hdHRyXHRcdDogeyBpZCA6IGZhbHNlIH0sXG5cdFx0XHRcdFx0YV9hdHRyXHRcdDogeyBocmVmIDogJyMnIH0sXG5cdFx0XHRcdFx0b3JpZ2luYWxcdDogZmFsc2Vcblx0XHRcdFx0fSwgaSwgdG1wLCB0aWQ7XG5cdFx0XHRmb3IoaSBpbiB0aGlzLl9tb2RlbC5kZWZhdWx0X3N0YXRlKSB7XG5cdFx0XHRcdGlmKHRoaXMuX21vZGVsLmRlZmF1bHRfc3RhdGUuaGFzT3duUHJvcGVydHkoaSkpIHtcblx0XHRcdFx0XHRkYXRhLnN0YXRlW2ldID0gdGhpcy5fbW9kZWwuZGVmYXVsdF9zdGF0ZVtpXTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0dG1wID0gJC52YWthdGEuYXR0cmlidXRlcyhkLCB0cnVlKTtcblx0XHRcdCQuZWFjaCh0bXAsIGZ1bmN0aW9uIChpLCB2KSB7XG5cdFx0XHRcdHYgPSAkLnRyaW0odik7XG5cdFx0XHRcdGlmKCF2Lmxlbmd0aCkgeyByZXR1cm4gdHJ1ZTsgfVxuXHRcdFx0XHRkYXRhLmxpX2F0dHJbaV0gPSB2O1xuXHRcdFx0XHRpZihpID09PSAnaWQnKSB7XG5cdFx0XHRcdFx0ZGF0YS5pZCA9IHYudG9TdHJpbmcoKTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0XHR0bXAgPSBkLmNoaWxkcmVuKCdhJykuZmlyc3QoKTtcblx0XHRcdGlmKHRtcC5sZW5ndGgpIHtcblx0XHRcdFx0dG1wID0gJC52YWthdGEuYXR0cmlidXRlcyh0bXAsIHRydWUpO1xuXHRcdFx0XHQkLmVhY2godG1wLCBmdW5jdGlvbiAoaSwgdikge1xuXHRcdFx0XHRcdHYgPSAkLnRyaW0odik7XG5cdFx0XHRcdFx0aWYodi5sZW5ndGgpIHtcblx0XHRcdFx0XHRcdGRhdGEuYV9hdHRyW2ldID0gdjtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXHRcdFx0dG1wID0gZC5jaGlsZHJlbihcImFcIikuZmlyc3QoKS5sZW5ndGggPyBkLmNoaWxkcmVuKFwiYVwiKS5maXJzdCgpLmNsb25lKCkgOiBkLmNsb25lKCk7XG5cdFx0XHR0bXAuY2hpbGRyZW4oXCJpbnMsIGksIHVsXCIpLnJlbW92ZSgpO1xuXHRcdFx0dG1wID0gdG1wLmh0bWwoKTtcblx0XHRcdHRtcCA9ICQoJzxkaXYgLz4nKS5odG1sKHRtcCk7XG5cdFx0XHRkYXRhLnRleHQgPSB0aGlzLnNldHRpbmdzLmNvcmUuZm9yY2VfdGV4dCA/IHRtcC50ZXh0KCkgOiB0bXAuaHRtbCgpO1xuXHRcdFx0dG1wID0gZC5kYXRhKCk7XG5cdFx0XHRkYXRhLmRhdGEgPSB0bXAgPyAkLmV4dGVuZCh0cnVlLCB7fSwgdG1wKSA6IG51bGw7XG5cdFx0XHRkYXRhLnN0YXRlLm9wZW5lZCA9IGQuaGFzQ2xhc3MoJ2pzdHJlZS1vcGVuJyk7XG5cdFx0XHRkYXRhLnN0YXRlLnNlbGVjdGVkID0gZC5jaGlsZHJlbignYScpLmhhc0NsYXNzKCdqc3RyZWUtY2xpY2tlZCcpO1xuXHRcdFx0ZGF0YS5zdGF0ZS5kaXNhYmxlZCA9IGQuY2hpbGRyZW4oJ2EnKS5oYXNDbGFzcygnanN0cmVlLWRpc2FibGVkJyk7XG5cdFx0XHRpZihkYXRhLmRhdGEgJiYgZGF0YS5kYXRhLmpzdHJlZSkge1xuXHRcdFx0XHRmb3IoaSBpbiBkYXRhLmRhdGEuanN0cmVlKSB7XG5cdFx0XHRcdFx0aWYoZGF0YS5kYXRhLmpzdHJlZS5oYXNPd25Qcm9wZXJ0eShpKSkge1xuXHRcdFx0XHRcdFx0ZGF0YS5zdGF0ZVtpXSA9IGRhdGEuZGF0YS5qc3RyZWVbaV07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHR0bXAgPSBkLmNoaWxkcmVuKFwiYVwiKS5jaGlsZHJlbihcIi5qc3RyZWUtdGhlbWVpY29uXCIpO1xuXHRcdFx0aWYodG1wLmxlbmd0aCkge1xuXHRcdFx0XHRkYXRhLmljb24gPSB0bXAuaGFzQ2xhc3MoJ2pzdHJlZS10aGVtZWljb24taGlkZGVuJykgPyBmYWxzZSA6IHRtcC5hdHRyKCdyZWwnKTtcblx0XHRcdH1cblx0XHRcdGlmKGRhdGEuc3RhdGUuaWNvbiAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdGRhdGEuaWNvbiA9IGRhdGEuc3RhdGUuaWNvbjtcblx0XHRcdH1cblx0XHRcdGlmKGRhdGEuaWNvbiA9PT0gdW5kZWZpbmVkIHx8IGRhdGEuaWNvbiA9PT0gbnVsbCB8fCBkYXRhLmljb24gPT09IFwiXCIpIHtcblx0XHRcdFx0ZGF0YS5pY29uID0gdHJ1ZTtcblx0XHRcdH1cblx0XHRcdHRtcCA9IGQuY2hpbGRyZW4oXCJ1bFwiKS5jaGlsZHJlbihcImxpXCIpO1xuXHRcdFx0ZG8ge1xuXHRcdFx0XHR0aWQgPSAnaicgKyB0aGlzLl9pZCArICdfJyArICgrK3RoaXMuX2NudCk7XG5cdFx0XHR9IHdoaWxlKG1bdGlkXSk7XG5cdFx0XHRkYXRhLmlkID0gZGF0YS5saV9hdHRyLmlkID8gZGF0YS5saV9hdHRyLmlkLnRvU3RyaW5nKCkgOiB0aWQ7XG5cdFx0XHRpZih0bXAubGVuZ3RoKSB7XG5cdFx0XHRcdHRtcC5lYWNoKCQucHJveHkoZnVuY3Rpb24gKGksIHYpIHtcblx0XHRcdFx0XHRjID0gdGhpcy5fcGFyc2VfbW9kZWxfZnJvbV9odG1sKCQodiksIGRhdGEuaWQsIHBzKTtcblx0XHRcdFx0XHRlID0gdGhpcy5fbW9kZWwuZGF0YVtjXTtcblx0XHRcdFx0XHRkYXRhLmNoaWxkcmVuLnB1c2goYyk7XG5cdFx0XHRcdFx0aWYoZS5jaGlsZHJlbl9kLmxlbmd0aCkge1xuXHRcdFx0XHRcdFx0ZGF0YS5jaGlsZHJlbl9kID0gZGF0YS5jaGlsZHJlbl9kLmNvbmNhdChlLmNoaWxkcmVuX2QpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSwgdGhpcykpO1xuXHRcdFx0XHRkYXRhLmNoaWxkcmVuX2QgPSBkYXRhLmNoaWxkcmVuX2QuY29uY2F0KGRhdGEuY2hpbGRyZW4pO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSB7XG5cdFx0XHRcdGlmKGQuaGFzQ2xhc3MoJ2pzdHJlZS1jbG9zZWQnKSkge1xuXHRcdFx0XHRcdGRhdGEuc3RhdGUubG9hZGVkID0gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGlmKGRhdGEubGlfYXR0clsnY2xhc3MnXSkge1xuXHRcdFx0XHRkYXRhLmxpX2F0dHJbJ2NsYXNzJ10gPSBkYXRhLmxpX2F0dHJbJ2NsYXNzJ10ucmVwbGFjZSgnanN0cmVlLWNsb3NlZCcsJycpLnJlcGxhY2UoJ2pzdHJlZS1vcGVuJywnJyk7XG5cdFx0XHR9XG5cdFx0XHRpZihkYXRhLmFfYXR0clsnY2xhc3MnXSkge1xuXHRcdFx0XHRkYXRhLmFfYXR0clsnY2xhc3MnXSA9IGRhdGEuYV9hdHRyWydjbGFzcyddLnJlcGxhY2UoJ2pzdHJlZS1jbGlja2VkJywnJykucmVwbGFjZSgnanN0cmVlLWRpc2FibGVkJywnJyk7XG5cdFx0XHR9XG5cdFx0XHRtW2RhdGEuaWRdID0gZGF0YTtcblx0XHRcdGlmKGRhdGEuc3RhdGUuc2VsZWN0ZWQpIHtcblx0XHRcdFx0dGhpcy5fZGF0YS5jb3JlLnNlbGVjdGVkLnB1c2goZGF0YS5pZCk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gZGF0YS5pZDtcblx0XHR9LFxuXHRcdC8qKlxuXHRcdCAqIHBhcnNlcyBhIG5vZGUgZnJvbSBhIEpTT04gb2JqZWN0ICh1c2VkIHdoZW4gZGVhbGluZyB3aXRoIGZsYXQgZGF0YSwgd2hpY2ggaGFzIG5vIG5lc3Rpbmcgb2YgY2hpbGRyZW4sIGJ1dCBoYXMgaWQgYW5kIHBhcmVudCBwcm9wZXJ0aWVzKSBhbmQgYXBwZW5kcyBpdCB0byB0aGUgaW4gbWVtb3J5IHRyZWUgbW9kZWwuIFVzZWQgaW50ZXJuYWxseS5cblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqIEBuYW1lIF9wYXJzZV9tb2RlbF9mcm9tX2ZsYXRfanNvbihkIFssIHAsIHBzXSlcblx0XHQgKiBAcGFyYW0gIHtPYmplY3R9IGQgdGhlIEpTT04gb2JqZWN0IHRvIHBhcnNlXG5cdFx0ICogQHBhcmFtICB7U3RyaW5nfSBwIHRoZSBwYXJlbnQgSURcblx0XHQgKiBAcGFyYW0gIHtBcnJheX0gcHMgbGlzdCBvZiBhbGwgcGFyZW50c1xuXHRcdCAqIEByZXR1cm4ge1N0cmluZ30gdGhlIElEIG9mIHRoZSBvYmplY3QgYWRkZWQgdG8gdGhlIG1vZGVsXG5cdFx0ICovXG5cdFx0X3BhcnNlX21vZGVsX2Zyb21fZmxhdF9qc29uIDogZnVuY3Rpb24gKGQsIHAsIHBzKSB7XG5cdFx0XHRpZighcHMpIHsgcHMgPSBbXTsgfVxuXHRcdFx0ZWxzZSB7IHBzID0gcHMuY29uY2F0KCk7IH1cblx0XHRcdGlmKHApIHsgcHMudW5zaGlmdChwKTsgfVxuXHRcdFx0dmFyIHRpZCA9IGQuaWQudG9TdHJpbmcoKSxcblx0XHRcdFx0bSA9IHRoaXMuX21vZGVsLmRhdGEsXG5cdFx0XHRcdGRmID0gdGhpcy5fbW9kZWwuZGVmYXVsdF9zdGF0ZSxcblx0XHRcdFx0aSwgaiwgYywgZSxcblx0XHRcdFx0dG1wID0ge1xuXHRcdFx0XHRcdGlkXHRcdFx0OiB0aWQsXG5cdFx0XHRcdFx0dGV4dFx0XHQ6IGQudGV4dCB8fCAnJyxcblx0XHRcdFx0XHRpY29uXHRcdDogZC5pY29uICE9PSB1bmRlZmluZWQgPyBkLmljb24gOiB0cnVlLFxuXHRcdFx0XHRcdHBhcmVudFx0XHQ6IHAsXG5cdFx0XHRcdFx0cGFyZW50c1x0XHQ6IHBzLFxuXHRcdFx0XHRcdGNoaWxkcmVuXHQ6IGQuY2hpbGRyZW4gfHwgW10sXG5cdFx0XHRcdFx0Y2hpbGRyZW5fZFx0OiBkLmNoaWxkcmVuX2QgfHwgW10sXG5cdFx0XHRcdFx0ZGF0YVx0XHQ6IGQuZGF0YSxcblx0XHRcdFx0XHRzdGF0ZVx0XHQ6IHsgfSxcblx0XHRcdFx0XHRsaV9hdHRyXHRcdDogeyBpZCA6IGZhbHNlIH0sXG5cdFx0XHRcdFx0YV9hdHRyXHRcdDogeyBocmVmIDogJyMnIH0sXG5cdFx0XHRcdFx0b3JpZ2luYWxcdDogZmFsc2Vcblx0XHRcdFx0fTtcblx0XHRcdGZvcihpIGluIGRmKSB7XG5cdFx0XHRcdGlmKGRmLmhhc093blByb3BlcnR5KGkpKSB7XG5cdFx0XHRcdFx0dG1wLnN0YXRlW2ldID0gZGZbaV07XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGlmKGQgJiYgZC5kYXRhICYmIGQuZGF0YS5qc3RyZWUgJiYgZC5kYXRhLmpzdHJlZS5pY29uKSB7XG5cdFx0XHRcdHRtcC5pY29uID0gZC5kYXRhLmpzdHJlZS5pY29uO1xuXHRcdFx0fVxuXHRcdFx0aWYodG1wLmljb24gPT09IHVuZGVmaW5lZCB8fCB0bXAuaWNvbiA9PT0gbnVsbCB8fCB0bXAuaWNvbiA9PT0gXCJcIikge1xuXHRcdFx0XHR0bXAuaWNvbiA9IHRydWU7XG5cdFx0XHR9XG5cdFx0XHRpZihkICYmIGQuZGF0YSkge1xuXHRcdFx0XHR0bXAuZGF0YSA9IGQuZGF0YTtcblx0XHRcdFx0aWYoZC5kYXRhLmpzdHJlZSkge1xuXHRcdFx0XHRcdGZvcihpIGluIGQuZGF0YS5qc3RyZWUpIHtcblx0XHRcdFx0XHRcdGlmKGQuZGF0YS5qc3RyZWUuaGFzT3duUHJvcGVydHkoaSkpIHtcblx0XHRcdFx0XHRcdFx0dG1wLnN0YXRlW2ldID0gZC5kYXRhLmpzdHJlZVtpXTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGlmKGQgJiYgdHlwZW9mIGQuc3RhdGUgPT09ICdvYmplY3QnKSB7XG5cdFx0XHRcdGZvciAoaSBpbiBkLnN0YXRlKSB7XG5cdFx0XHRcdFx0aWYoZC5zdGF0ZS5oYXNPd25Qcm9wZXJ0eShpKSkge1xuXHRcdFx0XHRcdFx0dG1wLnN0YXRlW2ldID0gZC5zdGF0ZVtpXTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGlmKGQgJiYgdHlwZW9mIGQubGlfYXR0ciA9PT0gJ29iamVjdCcpIHtcblx0XHRcdFx0Zm9yIChpIGluIGQubGlfYXR0cikge1xuXHRcdFx0XHRcdGlmKGQubGlfYXR0ci5oYXNPd25Qcm9wZXJ0eShpKSkge1xuXHRcdFx0XHRcdFx0dG1wLmxpX2F0dHJbaV0gPSBkLmxpX2F0dHJbaV07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRpZighdG1wLmxpX2F0dHIuaWQpIHtcblx0XHRcdFx0dG1wLmxpX2F0dHIuaWQgPSB0aWQ7XG5cdFx0XHR9XG5cdFx0XHRpZihkICYmIHR5cGVvZiBkLmFfYXR0ciA9PT0gJ29iamVjdCcpIHtcblx0XHRcdFx0Zm9yIChpIGluIGQuYV9hdHRyKSB7XG5cdFx0XHRcdFx0aWYoZC5hX2F0dHIuaGFzT3duUHJvcGVydHkoaSkpIHtcblx0XHRcdFx0XHRcdHRtcC5hX2F0dHJbaV0gPSBkLmFfYXR0cltpXTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGlmKGQgJiYgZC5jaGlsZHJlbiAmJiBkLmNoaWxkcmVuID09PSB0cnVlKSB7XG5cdFx0XHRcdHRtcC5zdGF0ZS5sb2FkZWQgPSBmYWxzZTtcblx0XHRcdFx0dG1wLmNoaWxkcmVuID0gW107XG5cdFx0XHRcdHRtcC5jaGlsZHJlbl9kID0gW107XG5cdFx0XHR9XG5cdFx0XHRtW3RtcC5pZF0gPSB0bXA7XG5cdFx0XHRmb3IoaSA9IDAsIGogPSB0bXAuY2hpbGRyZW4ubGVuZ3RoOyBpIDwgajsgaSsrKSB7XG5cdFx0XHRcdGMgPSB0aGlzLl9wYXJzZV9tb2RlbF9mcm9tX2ZsYXRfanNvbihtW3RtcC5jaGlsZHJlbltpXV0sIHRtcC5pZCwgcHMpO1xuXHRcdFx0XHRlID0gbVtjXTtcblx0XHRcdFx0dG1wLmNoaWxkcmVuX2QucHVzaChjKTtcblx0XHRcdFx0aWYoZS5jaGlsZHJlbl9kLmxlbmd0aCkge1xuXHRcdFx0XHRcdHRtcC5jaGlsZHJlbl9kID0gdG1wLmNoaWxkcmVuX2QuY29uY2F0KGUuY2hpbGRyZW5fZCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGRlbGV0ZSBkLmRhdGE7XG5cdFx0XHRkZWxldGUgZC5jaGlsZHJlbjtcblx0XHRcdG1bdG1wLmlkXS5vcmlnaW5hbCA9IGQ7XG5cdFx0XHRpZih0bXAuc3RhdGUuc2VsZWN0ZWQpIHtcblx0XHRcdFx0dGhpcy5fZGF0YS5jb3JlLnNlbGVjdGVkLnB1c2godG1wLmlkKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiB0bXAuaWQ7XG5cdFx0fSxcblx0XHQvKipcblx0XHQgKiBwYXJzZXMgYSBub2RlIGZyb20gYSBKU09OIG9iamVjdCBhbmQgYXBwZW5kcyBpdCB0byB0aGUgaW4gbWVtb3J5IHRyZWUgbW9kZWwuIFVzZWQgaW50ZXJuYWxseS5cblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqIEBuYW1lIF9wYXJzZV9tb2RlbF9mcm9tX2pzb24oZCBbLCBwLCBwc10pXG5cdFx0ICogQHBhcmFtICB7T2JqZWN0fSBkIHRoZSBKU09OIG9iamVjdCB0byBwYXJzZVxuXHRcdCAqIEBwYXJhbSAge1N0cmluZ30gcCB0aGUgcGFyZW50IElEXG5cdFx0ICogQHBhcmFtICB7QXJyYXl9IHBzIGxpc3Qgb2YgYWxsIHBhcmVudHNcblx0XHQgKiBAcmV0dXJuIHtTdHJpbmd9IHRoZSBJRCBvZiB0aGUgb2JqZWN0IGFkZGVkIHRvIHRoZSBtb2RlbFxuXHRcdCAqL1xuXHRcdF9wYXJzZV9tb2RlbF9mcm9tX2pzb24gOiBmdW5jdGlvbiAoZCwgcCwgcHMpIHtcblx0XHRcdGlmKCFwcykgeyBwcyA9IFtdOyB9XG5cdFx0XHRlbHNlIHsgcHMgPSBwcy5jb25jYXQoKTsgfVxuXHRcdFx0aWYocCkgeyBwcy51bnNoaWZ0KHApOyB9XG5cdFx0XHR2YXIgdGlkID0gZmFsc2UsIGksIGosIGMsIGUsIG0gPSB0aGlzLl9tb2RlbC5kYXRhLCBkZiA9IHRoaXMuX21vZGVsLmRlZmF1bHRfc3RhdGUsIHRtcDtcblx0XHRcdGRvIHtcblx0XHRcdFx0dGlkID0gJ2onICsgdGhpcy5faWQgKyAnXycgKyAoKyt0aGlzLl9jbnQpO1xuXHRcdFx0fSB3aGlsZShtW3RpZF0pO1xuXG5cdFx0XHR0bXAgPSB7XG5cdFx0XHRcdGlkXHRcdFx0OiBmYWxzZSxcblx0XHRcdFx0dGV4dFx0XHQ6IHR5cGVvZiBkID09PSAnc3RyaW5nJyA/IGQgOiAnJyxcblx0XHRcdFx0aWNvblx0XHQ6IHR5cGVvZiBkID09PSAnb2JqZWN0JyAmJiBkLmljb24gIT09IHVuZGVmaW5lZCA/IGQuaWNvbiA6IHRydWUsXG5cdFx0XHRcdHBhcmVudFx0XHQ6IHAsXG5cdFx0XHRcdHBhcmVudHNcdFx0OiBwcyxcblx0XHRcdFx0Y2hpbGRyZW5cdDogW10sXG5cdFx0XHRcdGNoaWxkcmVuX2RcdDogW10sXG5cdFx0XHRcdGRhdGFcdFx0OiBudWxsLFxuXHRcdFx0XHRzdGF0ZVx0XHQ6IHsgfSxcblx0XHRcdFx0bGlfYXR0clx0XHQ6IHsgaWQgOiBmYWxzZSB9LFxuXHRcdFx0XHRhX2F0dHJcdFx0OiB7IGhyZWYgOiAnIycgfSxcblx0XHRcdFx0b3JpZ2luYWxcdDogZmFsc2Vcblx0XHRcdH07XG5cdFx0XHRmb3IoaSBpbiBkZikge1xuXHRcdFx0XHRpZihkZi5oYXNPd25Qcm9wZXJ0eShpKSkge1xuXHRcdFx0XHRcdHRtcC5zdGF0ZVtpXSA9IGRmW2ldO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRpZihkICYmIGQuaWQpIHsgdG1wLmlkID0gZC5pZC50b1N0cmluZygpOyB9XG5cdFx0XHRpZihkICYmIGQudGV4dCkgeyB0bXAudGV4dCA9IGQudGV4dDsgfVxuXHRcdFx0aWYoZCAmJiBkLmRhdGEgJiYgZC5kYXRhLmpzdHJlZSAmJiBkLmRhdGEuanN0cmVlLmljb24pIHtcblx0XHRcdFx0dG1wLmljb24gPSBkLmRhdGEuanN0cmVlLmljb247XG5cdFx0XHR9XG5cdFx0XHRpZih0bXAuaWNvbiA9PT0gdW5kZWZpbmVkIHx8IHRtcC5pY29uID09PSBudWxsIHx8IHRtcC5pY29uID09PSBcIlwiKSB7XG5cdFx0XHRcdHRtcC5pY29uID0gdHJ1ZTtcblx0XHRcdH1cblx0XHRcdGlmKGQgJiYgZC5kYXRhKSB7XG5cdFx0XHRcdHRtcC5kYXRhID0gZC5kYXRhO1xuXHRcdFx0XHRpZihkLmRhdGEuanN0cmVlKSB7XG5cdFx0XHRcdFx0Zm9yKGkgaW4gZC5kYXRhLmpzdHJlZSkge1xuXHRcdFx0XHRcdFx0aWYoZC5kYXRhLmpzdHJlZS5oYXNPd25Qcm9wZXJ0eShpKSkge1xuXHRcdFx0XHRcdFx0XHR0bXAuc3RhdGVbaV0gPSBkLmRhdGEuanN0cmVlW2ldO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0aWYoZCAmJiB0eXBlb2YgZC5zdGF0ZSA9PT0gJ29iamVjdCcpIHtcblx0XHRcdFx0Zm9yIChpIGluIGQuc3RhdGUpIHtcblx0XHRcdFx0XHRpZihkLnN0YXRlLmhhc093blByb3BlcnR5KGkpKSB7XG5cdFx0XHRcdFx0XHR0bXAuc3RhdGVbaV0gPSBkLnN0YXRlW2ldO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0aWYoZCAmJiB0eXBlb2YgZC5saV9hdHRyID09PSAnb2JqZWN0Jykge1xuXHRcdFx0XHRmb3IgKGkgaW4gZC5saV9hdHRyKSB7XG5cdFx0XHRcdFx0aWYoZC5saV9hdHRyLmhhc093blByb3BlcnR5KGkpKSB7XG5cdFx0XHRcdFx0XHR0bXAubGlfYXR0cltpXSA9IGQubGlfYXR0cltpXTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGlmKHRtcC5saV9hdHRyLmlkICYmICF0bXAuaWQpIHtcblx0XHRcdFx0dG1wLmlkID0gdG1wLmxpX2F0dHIuaWQudG9TdHJpbmcoKTtcblx0XHRcdH1cblx0XHRcdGlmKCF0bXAuaWQpIHtcblx0XHRcdFx0dG1wLmlkID0gdGlkO1xuXHRcdFx0fVxuXHRcdFx0aWYoIXRtcC5saV9hdHRyLmlkKSB7XG5cdFx0XHRcdHRtcC5saV9hdHRyLmlkID0gdG1wLmlkO1xuXHRcdFx0fVxuXHRcdFx0aWYoZCAmJiB0eXBlb2YgZC5hX2F0dHIgPT09ICdvYmplY3QnKSB7XG5cdFx0XHRcdGZvciAoaSBpbiBkLmFfYXR0cikge1xuXHRcdFx0XHRcdGlmKGQuYV9hdHRyLmhhc093blByb3BlcnR5KGkpKSB7XG5cdFx0XHRcdFx0XHR0bXAuYV9hdHRyW2ldID0gZC5hX2F0dHJbaV07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRpZihkICYmIGQuY2hpbGRyZW4gJiYgZC5jaGlsZHJlbi5sZW5ndGgpIHtcblx0XHRcdFx0Zm9yKGkgPSAwLCBqID0gZC5jaGlsZHJlbi5sZW5ndGg7IGkgPCBqOyBpKyspIHtcblx0XHRcdFx0XHRjID0gdGhpcy5fcGFyc2VfbW9kZWxfZnJvbV9qc29uKGQuY2hpbGRyZW5baV0sIHRtcC5pZCwgcHMpO1xuXHRcdFx0XHRcdGUgPSBtW2NdO1xuXHRcdFx0XHRcdHRtcC5jaGlsZHJlbi5wdXNoKGMpO1xuXHRcdFx0XHRcdGlmKGUuY2hpbGRyZW5fZC5sZW5ndGgpIHtcblx0XHRcdFx0XHRcdHRtcC5jaGlsZHJlbl9kID0gdG1wLmNoaWxkcmVuX2QuY29uY2F0KGUuY2hpbGRyZW5fZCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdHRtcC5jaGlsZHJlbl9kID0gdG1wLmNoaWxkcmVuX2QuY29uY2F0KHRtcC5jaGlsZHJlbik7XG5cdFx0XHR9XG5cdFx0XHRpZihkICYmIGQuY2hpbGRyZW4gJiYgZC5jaGlsZHJlbiA9PT0gdHJ1ZSkge1xuXHRcdFx0XHR0bXAuc3RhdGUubG9hZGVkID0gZmFsc2U7XG5cdFx0XHRcdHRtcC5jaGlsZHJlbiA9IFtdO1xuXHRcdFx0XHR0bXAuY2hpbGRyZW5fZCA9IFtdO1xuXHRcdFx0fVxuXHRcdFx0ZGVsZXRlIGQuZGF0YTtcblx0XHRcdGRlbGV0ZSBkLmNoaWxkcmVuO1xuXHRcdFx0dG1wLm9yaWdpbmFsID0gZDtcblx0XHRcdG1bdG1wLmlkXSA9IHRtcDtcblx0XHRcdGlmKHRtcC5zdGF0ZS5zZWxlY3RlZCkge1xuXHRcdFx0XHR0aGlzLl9kYXRhLmNvcmUuc2VsZWN0ZWQucHVzaCh0bXAuaWQpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRtcC5pZDtcblx0XHR9LFxuXHRcdC8qKlxuXHRcdCAqIHJlZHJhd3MgYWxsIG5vZGVzIHRoYXQgbmVlZCB0byBiZSByZWRyYXduLiBVc2VkIGludGVybmFsbHkuXG5cdFx0ICogQHByaXZhdGVcblx0XHQgKiBAbmFtZSBfcmVkcmF3KClcblx0XHQgKiBAdHJpZ2dlciByZWRyYXcuanN0cmVlXG5cdFx0ICovXG5cdFx0X3JlZHJhdyA6IGZ1bmN0aW9uICgpIHtcblx0XHRcdHZhciBub2RlcyA9IHRoaXMuX21vZGVsLmZvcmNlX2Z1bGxfcmVkcmF3ID8gdGhpcy5fbW9kZWwuZGF0YVskLmpzdHJlZS5yb290XS5jaGlsZHJlbi5jb25jYXQoW10pIDogdGhpcy5fbW9kZWwuY2hhbmdlZC5jb25jYXQoW10pLFxuXHRcdFx0XHRmID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnVUwnKSwgdG1wLCBpLCBqLCBmZSA9IHRoaXMuX2RhdGEuY29yZS5mb2N1c2VkO1xuXHRcdFx0Zm9yKGkgPSAwLCBqID0gbm9kZXMubGVuZ3RoOyBpIDwgajsgaSsrKSB7XG5cdFx0XHRcdHRtcCA9IHRoaXMucmVkcmF3X25vZGUobm9kZXNbaV0sIHRydWUsIHRoaXMuX21vZGVsLmZvcmNlX2Z1bGxfcmVkcmF3KTtcblx0XHRcdFx0aWYodG1wICYmIHRoaXMuX21vZGVsLmZvcmNlX2Z1bGxfcmVkcmF3KSB7XG5cdFx0XHRcdFx0Zi5hcHBlbmRDaGlsZCh0bXApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRpZih0aGlzLl9tb2RlbC5mb3JjZV9mdWxsX3JlZHJhdykge1xuXHRcdFx0XHRmLmNsYXNzTmFtZSA9IHRoaXMuZ2V0X2NvbnRhaW5lcl91bCgpWzBdLmNsYXNzTmFtZTtcblx0XHRcdFx0Zi5zZXRBdHRyaWJ1dGUoJ3JvbGUnLCdncm91cCcpO1xuXHRcdFx0XHR0aGlzLmVsZW1lbnQuZW1wdHkoKS5hcHBlbmQoZik7XG5cdFx0XHRcdC8vdGhpcy5nZXRfY29udGFpbmVyX3VsKClbMF0uYXBwZW5kQ2hpbGQoZik7XG5cdFx0XHR9XG5cdFx0XHRpZihmZSAhPT0gbnVsbCkge1xuXHRcdFx0XHR0bXAgPSB0aGlzLmdldF9ub2RlKGZlLCB0cnVlKTtcblx0XHRcdFx0aWYodG1wICYmIHRtcC5sZW5ndGggJiYgdG1wLmNoaWxkcmVuKCcuanN0cmVlLWFuY2hvcicpWzBdICE9PSBkb2N1bWVudC5hY3RpdmVFbGVtZW50KSB7XG5cdFx0XHRcdFx0dG1wLmNoaWxkcmVuKCcuanN0cmVlLWFuY2hvcicpLmZvY3VzKCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0dGhpcy5fZGF0YS5jb3JlLmZvY3VzZWQgPSBudWxsO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHR0aGlzLl9tb2RlbC5mb3JjZV9mdWxsX3JlZHJhdyA9IGZhbHNlO1xuXHRcdFx0dGhpcy5fbW9kZWwuY2hhbmdlZCA9IFtdO1xuXHRcdFx0LyoqXG5cdFx0XHQgKiB0cmlnZ2VyZWQgYWZ0ZXIgbm9kZXMgYXJlIHJlZHJhd25cblx0XHRcdCAqIEBldmVudFxuXHRcdFx0ICogQG5hbWUgcmVkcmF3LmpzdHJlZVxuXHRcdFx0ICogQHBhcmFtIHthcnJheX0gbm9kZXMgdGhlIHJlZHJhd24gbm9kZXNcblx0XHRcdCAqL1xuXHRcdFx0dGhpcy50cmlnZ2VyKCdyZWRyYXcnLCB7IFwibm9kZXNcIiA6IG5vZGVzIH0pO1xuXHRcdH0sXG5cdFx0LyoqXG5cdFx0ICogcmVkcmF3cyBhbGwgbm9kZXMgdGhhdCBuZWVkIHRvIGJlIHJlZHJhd24gb3Igb3B0aW9uYWxseSAtIHRoZSB3aG9sZSB0cmVlXG5cdFx0ICogQG5hbWUgcmVkcmF3KFtmdWxsXSlcblx0XHQgKiBAcGFyYW0ge0Jvb2xlYW59IGZ1bGwgaWYgc2V0IHRvIGB0cnVlYCBhbGwgbm9kZXMgYXJlIHJlZHJhd24uXG5cdFx0ICovXG5cdFx0cmVkcmF3IDogZnVuY3Rpb24gKGZ1bGwpIHtcblx0XHRcdGlmKGZ1bGwpIHtcblx0XHRcdFx0dGhpcy5fbW9kZWwuZm9yY2VfZnVsbF9yZWRyYXcgPSB0cnVlO1xuXHRcdFx0fVxuXHRcdFx0Ly9pZih0aGlzLl9tb2RlbC5yZWRyYXdfdGltZW91dCkge1xuXHRcdFx0Ly9cdGNsZWFyVGltZW91dCh0aGlzLl9tb2RlbC5yZWRyYXdfdGltZW91dCk7XG5cdFx0XHQvL31cblx0XHRcdC8vdGhpcy5fbW9kZWwucmVkcmF3X3RpbWVvdXQgPSBzZXRUaW1lb3V0KCQucHJveHkodGhpcy5fcmVkcmF3LCB0aGlzKSwwKTtcblx0XHRcdHRoaXMuX3JlZHJhdygpO1xuXHRcdH0sXG5cdFx0LyoqXG5cdFx0ICogcmVkcmF3cyBhIHNpbmdsZSBub2RlJ3MgY2hpbGRyZW4uIFVzZWQgaW50ZXJuYWxseS5cblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqIEBuYW1lIGRyYXdfY2hpbGRyZW4obm9kZSlcblx0XHQgKiBAcGFyYW0ge21peGVkfSBub2RlIHRoZSBub2RlIHdob3NlIGNoaWxkcmVuIHdpbGwgYmUgcmVkcmF3blxuXHRcdCAqL1xuXHRcdGRyYXdfY2hpbGRyZW4gOiBmdW5jdGlvbiAobm9kZSkge1xuXHRcdFx0dmFyIG9iaiA9IHRoaXMuZ2V0X25vZGUobm9kZSksXG5cdFx0XHRcdGkgPSBmYWxzZSxcblx0XHRcdFx0aiA9IGZhbHNlLFxuXHRcdFx0XHRrID0gZmFsc2UsXG5cdFx0XHRcdGQgPSBkb2N1bWVudDtcblx0XHRcdGlmKCFvYmopIHsgcmV0dXJuIGZhbHNlOyB9XG5cdFx0XHRpZihvYmouaWQgPT09ICQuanN0cmVlLnJvb3QpIHsgcmV0dXJuIHRoaXMucmVkcmF3KHRydWUpOyB9XG5cdFx0XHRub2RlID0gdGhpcy5nZXRfbm9kZShub2RlLCB0cnVlKTtcblx0XHRcdGlmKCFub2RlIHx8ICFub2RlLmxlbmd0aCkgeyByZXR1cm4gZmFsc2U7IH0gLy8gVE9ETzogcXVpY2sgdG9nZ2xlXG5cblx0XHRcdG5vZGUuY2hpbGRyZW4oJy5qc3RyZWUtY2hpbGRyZW4nKS5yZW1vdmUoKTtcblx0XHRcdG5vZGUgPSBub2RlWzBdO1xuXHRcdFx0aWYob2JqLmNoaWxkcmVuLmxlbmd0aCAmJiBvYmouc3RhdGUubG9hZGVkKSB7XG5cdFx0XHRcdGsgPSBkLmNyZWF0ZUVsZW1lbnQoJ1VMJyk7XG5cdFx0XHRcdGsuc2V0QXR0cmlidXRlKCdyb2xlJywgJ2dyb3VwJyk7XG5cdFx0XHRcdGsuY2xhc3NOYW1lID0gJ2pzdHJlZS1jaGlsZHJlbic7XG5cdFx0XHRcdGZvcihpID0gMCwgaiA9IG9iai5jaGlsZHJlbi5sZW5ndGg7IGkgPCBqOyBpKyspIHtcblx0XHRcdFx0XHRrLmFwcGVuZENoaWxkKHRoaXMucmVkcmF3X25vZGUob2JqLmNoaWxkcmVuW2ldLCB0cnVlLCB0cnVlKSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0bm9kZS5hcHBlbmRDaGlsZChrKTtcblx0XHRcdH1cblx0XHR9LFxuXHRcdC8qKlxuXHRcdCAqIHJlZHJhd3MgYSBzaW5nbGUgbm9kZS4gVXNlZCBpbnRlcm5hbGx5LlxuXHRcdCAqIEBwcml2YXRlXG5cdFx0ICogQG5hbWUgcmVkcmF3X25vZGUobm9kZSwgZGVlcCwgaXNfY2FsbGJhY2ssIGZvcmNlX3JlbmRlcilcblx0XHQgKiBAcGFyYW0ge21peGVkfSBub2RlIHRoZSBub2RlIHRvIHJlZHJhd1xuXHRcdCAqIEBwYXJhbSB7Qm9vbGVhbn0gZGVlcCBzaG91bGQgY2hpbGQgbm9kZXMgYmUgcmVkcmF3biB0b29cblx0XHQgKiBAcGFyYW0ge0Jvb2xlYW59IGlzX2NhbGxiYWNrIGlzIHRoaXMgYSByZWN1cnNpb24gY2FsbFxuXHRcdCAqIEBwYXJhbSB7Qm9vbGVhbn0gZm9yY2VfcmVuZGVyIHNob3VsZCBjaGlsZHJlbiBvZiBjbG9zZWQgcGFyZW50cyBiZSBkcmF3biBhbnl3YXlcblx0XHQgKi9cblx0XHRyZWRyYXdfbm9kZSA6IGZ1bmN0aW9uIChub2RlLCBkZWVwLCBpc19jYWxsYmFjaywgZm9yY2VfcmVuZGVyKSB7XG5cdFx0XHR2YXIgb2JqID0gdGhpcy5nZXRfbm9kZShub2RlKSxcblx0XHRcdFx0cGFyID0gZmFsc2UsXG5cdFx0XHRcdGluZCA9IGZhbHNlLFxuXHRcdFx0XHRvbGQgPSBmYWxzZSxcblx0XHRcdFx0aSA9IGZhbHNlLFxuXHRcdFx0XHRqID0gZmFsc2UsXG5cdFx0XHRcdGsgPSBmYWxzZSxcblx0XHRcdFx0YyA9ICcnLFxuXHRcdFx0XHRkID0gZG9jdW1lbnQsXG5cdFx0XHRcdG0gPSB0aGlzLl9tb2RlbC5kYXRhLFxuXHRcdFx0XHRmID0gZmFsc2UsXG5cdFx0XHRcdHMgPSBmYWxzZSxcblx0XHRcdFx0dG1wID0gbnVsbCxcblx0XHRcdFx0dCA9IDAsXG5cdFx0XHRcdGwgPSAwLFxuXHRcdFx0XHRoYXNfY2hpbGRyZW4gPSBmYWxzZSxcblx0XHRcdFx0bGFzdF9zaWJsaW5nID0gZmFsc2U7XG5cdFx0XHRpZighb2JqKSB7IHJldHVybiBmYWxzZTsgfVxuXHRcdFx0aWYob2JqLmlkID09PSAkLmpzdHJlZS5yb290KSB7ICByZXR1cm4gdGhpcy5yZWRyYXcodHJ1ZSk7IH1cblx0XHRcdGRlZXAgPSBkZWVwIHx8IG9iai5jaGlsZHJlbi5sZW5ndGggPT09IDA7XG5cdFx0XHRub2RlID0gIWRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IgPyBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChvYmouaWQpIDogdGhpcy5lbGVtZW50WzBdLnF1ZXJ5U2VsZWN0b3IoJyMnICsgKFwiMDEyMzQ1Njc4OVwiLmluZGV4T2Yob2JqLmlkWzBdKSAhPT0gLTEgPyAnXFxcXDMnICsgb2JqLmlkWzBdICsgJyAnICsgb2JqLmlkLnN1YnN0cigxKS5yZXBsYWNlKCQuanN0cmVlLmlkcmVnZXgsJ1xcXFwkJicpIDogb2JqLmlkLnJlcGxhY2UoJC5qc3RyZWUuaWRyZWdleCwnXFxcXCQmJykpICk7IC8vLCB0aGlzLmVsZW1lbnQpO1xuXHRcdFx0aWYoIW5vZGUpIHtcblx0XHRcdFx0ZGVlcCA9IHRydWU7XG5cdFx0XHRcdC8vbm9kZSA9IGQuY3JlYXRlRWxlbWVudCgnTEknKTtcblx0XHRcdFx0aWYoIWlzX2NhbGxiYWNrKSB7XG5cdFx0XHRcdFx0cGFyID0gb2JqLnBhcmVudCAhPT0gJC5qc3RyZWUucm9vdCA/ICQoJyMnICsgb2JqLnBhcmVudC5yZXBsYWNlKCQuanN0cmVlLmlkcmVnZXgsJ1xcXFwkJicpLCB0aGlzLmVsZW1lbnQpWzBdIDogbnVsbDtcblx0XHRcdFx0XHRpZihwYXIgIT09IG51bGwgJiYgKCFwYXIgfHwgIW1bb2JqLnBhcmVudF0uc3RhdGUub3BlbmVkKSkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpbmQgPSAkLmluQXJyYXkob2JqLmlkLCBwYXIgPT09IG51bGwgPyBtWyQuanN0cmVlLnJvb3RdLmNoaWxkcmVuIDogbVtvYmoucGFyZW50XS5jaGlsZHJlbik7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGVsc2Uge1xuXHRcdFx0XHRub2RlID0gJChub2RlKTtcblx0XHRcdFx0aWYoIWlzX2NhbGxiYWNrKSB7XG5cdFx0XHRcdFx0cGFyID0gbm9kZS5wYXJlbnQoKS5wYXJlbnQoKVswXTtcblx0XHRcdFx0XHRpZihwYXIgPT09IHRoaXMuZWxlbWVudFswXSkge1xuXHRcdFx0XHRcdFx0cGFyID0gbnVsbDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aW5kID0gbm9kZS5pbmRleCgpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdC8vIG1bb2JqLmlkXS5kYXRhID0gbm9kZS5kYXRhKCk7IC8vIHVzZSBvbmx5IG5vZGUncyBkYXRhLCBubyBuZWVkIHRvIHRvdWNoIGpxdWVyeSBzdG9yYWdlXG5cdFx0XHRcdGlmKCFkZWVwICYmIG9iai5jaGlsZHJlbi5sZW5ndGggJiYgIW5vZGUuY2hpbGRyZW4oJy5qc3RyZWUtY2hpbGRyZW4nKS5sZW5ndGgpIHtcblx0XHRcdFx0XHRkZWVwID0gdHJ1ZTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZighZGVlcCkge1xuXHRcdFx0XHRcdG9sZCA9IG5vZGUuY2hpbGRyZW4oJy5qc3RyZWUtY2hpbGRyZW4nKVswXTtcblx0XHRcdFx0fVxuXHRcdFx0XHRmID0gbm9kZS5jaGlsZHJlbignLmpzdHJlZS1hbmNob3InKVswXSA9PT0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudDtcblx0XHRcdFx0bm9kZS5yZW1vdmUoKTtcblx0XHRcdFx0Ly9ub2RlID0gZC5jcmVhdGVFbGVtZW50KCdMSScpO1xuXHRcdFx0XHQvL25vZGUgPSBub2RlWzBdO1xuXHRcdFx0fVxuXHRcdFx0bm9kZSA9IHRoaXMuX2RhdGEuY29yZS5ub2RlLmNsb25lTm9kZSh0cnVlKTtcblx0XHRcdC8vIG5vZGUgaXMgRE9NLCBkZWVwIGlzIGJvb2xlYW5cblxuXHRcdFx0YyA9ICdqc3RyZWUtbm9kZSAnO1xuXHRcdFx0Zm9yKGkgaW4gb2JqLmxpX2F0dHIpIHtcblx0XHRcdFx0aWYob2JqLmxpX2F0dHIuaGFzT3duUHJvcGVydHkoaSkpIHtcblx0XHRcdFx0XHRpZihpID09PSAnaWQnKSB7IGNvbnRpbnVlOyB9XG5cdFx0XHRcdFx0aWYoaSAhPT0gJ2NsYXNzJykge1xuXHRcdFx0XHRcdFx0bm9kZS5zZXRBdHRyaWJ1dGUoaSwgb2JqLmxpX2F0dHJbaV0pO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRcdGMgKz0gb2JqLmxpX2F0dHJbaV07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRpZighb2JqLmFfYXR0ci5pZCkge1xuXHRcdFx0XHRvYmouYV9hdHRyLmlkID0gb2JqLmlkICsgJ19hbmNob3InO1xuXHRcdFx0fVxuXHRcdFx0bm9kZS5zZXRBdHRyaWJ1dGUoJ2FyaWEtc2VsZWN0ZWQnLCAhIW9iai5zdGF0ZS5zZWxlY3RlZCk7XG5cdFx0XHRub2RlLnNldEF0dHJpYnV0ZSgnYXJpYS1sZXZlbCcsIG9iai5wYXJlbnRzLmxlbmd0aCk7XG5cdFx0XHRub2RlLnNldEF0dHJpYnV0ZSgnYXJpYS1sYWJlbGxlZGJ5Jywgb2JqLmFfYXR0ci5pZCk7XG5cdFx0XHRpZihvYmouc3RhdGUuZGlzYWJsZWQpIHtcblx0XHRcdFx0bm9kZS5zZXRBdHRyaWJ1dGUoJ2FyaWEtZGlzYWJsZWQnLCB0cnVlKTtcblx0XHRcdH1cblxuXHRcdFx0Zm9yKGkgPSAwLCBqID0gb2JqLmNoaWxkcmVuLmxlbmd0aDsgaSA8IGo7IGkrKykge1xuXHRcdFx0XHRpZighbVtvYmouY2hpbGRyZW5baV1dLnN0YXRlLmhpZGRlbikge1xuXHRcdFx0XHRcdGhhc19jaGlsZHJlbiA9IHRydWU7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGlmKG9iai5wYXJlbnQgIT09IG51bGwgJiYgbVtvYmoucGFyZW50XSAmJiAhb2JqLnN0YXRlLmhpZGRlbikge1xuXHRcdFx0XHRpID0gJC5pbkFycmF5KG9iai5pZCwgbVtvYmoucGFyZW50XS5jaGlsZHJlbik7XG5cdFx0XHRcdGxhc3Rfc2libGluZyA9IG9iai5pZDtcblx0XHRcdFx0aWYoaSAhPT0gLTEpIHtcblx0XHRcdFx0XHRpKys7XG5cdFx0XHRcdFx0Zm9yKGogPSBtW29iai5wYXJlbnRdLmNoaWxkcmVuLmxlbmd0aDsgaSA8IGo7IGkrKykge1xuXHRcdFx0XHRcdFx0aWYoIW1bbVtvYmoucGFyZW50XS5jaGlsZHJlbltpXV0uc3RhdGUuaGlkZGVuKSB7XG5cdFx0XHRcdFx0XHRcdGxhc3Rfc2libGluZyA9IG1bb2JqLnBhcmVudF0uY2hpbGRyZW5baV07XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRpZihsYXN0X3NpYmxpbmcgIT09IG9iai5pZCkge1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0aWYob2JqLnN0YXRlLmhpZGRlbikge1xuXHRcdFx0XHRjICs9ICcganN0cmVlLWhpZGRlbic7XG5cdFx0XHR9XG5cdFx0XHRpZihvYmouc3RhdGUubG9hZGVkICYmICFoYXNfY2hpbGRyZW4pIHtcblx0XHRcdFx0YyArPSAnIGpzdHJlZS1sZWFmJztcblx0XHRcdH1cblx0XHRcdGVsc2Uge1xuXHRcdFx0XHRjICs9IG9iai5zdGF0ZS5vcGVuZWQgJiYgb2JqLnN0YXRlLmxvYWRlZCA/ICcganN0cmVlLW9wZW4nIDogJyBqc3RyZWUtY2xvc2VkJztcblx0XHRcdFx0bm9kZS5zZXRBdHRyaWJ1dGUoJ2FyaWEtZXhwYW5kZWQnLCAob2JqLnN0YXRlLm9wZW5lZCAmJiBvYmouc3RhdGUubG9hZGVkKSApO1xuXHRcdFx0fVxuXHRcdFx0aWYobGFzdF9zaWJsaW5nID09PSBvYmouaWQpIHtcblx0XHRcdFx0YyArPSAnIGpzdHJlZS1sYXN0Jztcblx0XHRcdH1cblx0XHRcdG5vZGUuaWQgPSBvYmouaWQ7XG5cdFx0XHRub2RlLmNsYXNzTmFtZSA9IGM7XG5cdFx0XHRjID0gKCBvYmouc3RhdGUuc2VsZWN0ZWQgPyAnIGpzdHJlZS1jbGlja2VkJyA6ICcnKSArICggb2JqLnN0YXRlLmRpc2FibGVkID8gJyBqc3RyZWUtZGlzYWJsZWQnIDogJycpO1xuXHRcdFx0Zm9yKGogaW4gb2JqLmFfYXR0cikge1xuXHRcdFx0XHRpZihvYmouYV9hdHRyLmhhc093blByb3BlcnR5KGopKSB7XG5cdFx0XHRcdFx0aWYoaiA9PT0gJ2hyZWYnICYmIG9iai5hX2F0dHJbal0gPT09ICcjJykgeyBjb250aW51ZTsgfVxuXHRcdFx0XHRcdGlmKGogIT09ICdjbGFzcycpIHtcblx0XHRcdFx0XHRcdG5vZGUuY2hpbGROb2Rlc1sxXS5zZXRBdHRyaWJ1dGUoaiwgb2JqLmFfYXR0cltqXSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdFx0YyArPSAnICcgKyBvYmouYV9hdHRyW2pdO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0aWYoYy5sZW5ndGgpIHtcblx0XHRcdFx0bm9kZS5jaGlsZE5vZGVzWzFdLmNsYXNzTmFtZSA9ICdqc3RyZWUtYW5jaG9yICcgKyBjO1xuXHRcdFx0fVxuXHRcdFx0aWYoKG9iai5pY29uICYmIG9iai5pY29uICE9PSB0cnVlKSB8fCBvYmouaWNvbiA9PT0gZmFsc2UpIHtcblx0XHRcdFx0aWYob2JqLmljb24gPT09IGZhbHNlKSB7XG5cdFx0XHRcdFx0bm9kZS5jaGlsZE5vZGVzWzFdLmNoaWxkTm9kZXNbMF0uY2xhc3NOYW1lICs9ICcganN0cmVlLXRoZW1laWNvbi1oaWRkZW4nO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2UgaWYob2JqLmljb24uaW5kZXhPZignLycpID09PSAtMSAmJiBvYmouaWNvbi5pbmRleE9mKCcuJykgPT09IC0xKSB7XG5cdFx0XHRcdFx0bm9kZS5jaGlsZE5vZGVzWzFdLmNoaWxkTm9kZXNbMF0uY2xhc3NOYW1lICs9ICcgJyArIG9iai5pY29uICsgJyBqc3RyZWUtdGhlbWVpY29uLWN1c3RvbSc7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0bm9kZS5jaGlsZE5vZGVzWzFdLmNoaWxkTm9kZXNbMF0uc3R5bGUuYmFja2dyb3VuZEltYWdlID0gJ3VybChcIicrb2JqLmljb24rJ1wiKSc7XG5cdFx0XHRcdFx0bm9kZS5jaGlsZE5vZGVzWzFdLmNoaWxkTm9kZXNbMF0uc3R5bGUuYmFja2dyb3VuZFBvc2l0aW9uID0gJ2NlbnRlciBjZW50ZXInO1xuXHRcdFx0XHRcdG5vZGUuY2hpbGROb2Rlc1sxXS5jaGlsZE5vZGVzWzBdLnN0eWxlLmJhY2tncm91bmRTaXplID0gJ2F1dG8nO1xuXHRcdFx0XHRcdG5vZGUuY2hpbGROb2Rlc1sxXS5jaGlsZE5vZGVzWzBdLmNsYXNzTmFtZSArPSAnIGpzdHJlZS10aGVtZWljb24tY3VzdG9tJztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRpZih0aGlzLnNldHRpbmdzLmNvcmUuZm9yY2VfdGV4dCkge1xuXHRcdFx0XHRub2RlLmNoaWxkTm9kZXNbMV0uYXBwZW5kQ2hpbGQoZC5jcmVhdGVUZXh0Tm9kZShvYmoudGV4dCkpO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSB7XG5cdFx0XHRcdG5vZGUuY2hpbGROb2Rlc1sxXS5pbm5lckhUTUwgKz0gb2JqLnRleHQ7XG5cdFx0XHR9XG5cblxuXHRcdFx0aWYoZGVlcCAmJiBvYmouY2hpbGRyZW4ubGVuZ3RoICYmIChvYmouc3RhdGUub3BlbmVkIHx8IGZvcmNlX3JlbmRlcikgJiYgb2JqLnN0YXRlLmxvYWRlZCkge1xuXHRcdFx0XHRrID0gZC5jcmVhdGVFbGVtZW50KCdVTCcpO1xuXHRcdFx0XHRrLnNldEF0dHJpYnV0ZSgncm9sZScsICdncm91cCcpO1xuXHRcdFx0XHRrLmNsYXNzTmFtZSA9ICdqc3RyZWUtY2hpbGRyZW4nO1xuXHRcdFx0XHRmb3IoaSA9IDAsIGogPSBvYmouY2hpbGRyZW4ubGVuZ3RoOyBpIDwgajsgaSsrKSB7XG5cdFx0XHRcdFx0ay5hcHBlbmRDaGlsZCh0aGlzLnJlZHJhd19ub2RlKG9iai5jaGlsZHJlbltpXSwgZGVlcCwgdHJ1ZSkpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdG5vZGUuYXBwZW5kQ2hpbGQoayk7XG5cdFx0XHR9XG5cdFx0XHRpZihvbGQpIHtcblx0XHRcdFx0bm9kZS5hcHBlbmRDaGlsZChvbGQpO1xuXHRcdFx0fVxuXHRcdFx0aWYoIWlzX2NhbGxiYWNrKSB7XG5cdFx0XHRcdC8vIGFwcGVuZCBiYWNrIHVzaW5nIHBhciAvIGluZFxuXHRcdFx0XHRpZighcGFyKSB7XG5cdFx0XHRcdFx0cGFyID0gdGhpcy5lbGVtZW50WzBdO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGZvcihpID0gMCwgaiA9IHBhci5jaGlsZE5vZGVzLmxlbmd0aDsgaSA8IGo7IGkrKykge1xuXHRcdFx0XHRcdGlmKHBhci5jaGlsZE5vZGVzW2ldICYmIHBhci5jaGlsZE5vZGVzW2ldLmNsYXNzTmFtZSAmJiBwYXIuY2hpbGROb2Rlc1tpXS5jbGFzc05hbWUuaW5kZXhPZignanN0cmVlLWNoaWxkcmVuJykgIT09IC0xKSB7XG5cdFx0XHRcdFx0XHR0bXAgPSBwYXIuY2hpbGROb2Rlc1tpXTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRpZighdG1wKSB7XG5cdFx0XHRcdFx0dG1wID0gZC5jcmVhdGVFbGVtZW50KCdVTCcpO1xuXHRcdFx0XHRcdHRtcC5zZXRBdHRyaWJ1dGUoJ3JvbGUnLCAnZ3JvdXAnKTtcblx0XHRcdFx0XHR0bXAuY2xhc3NOYW1lID0gJ2pzdHJlZS1jaGlsZHJlbic7XG5cdFx0XHRcdFx0cGFyLmFwcGVuZENoaWxkKHRtcCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cGFyID0gdG1wO1xuXG5cdFx0XHRcdGlmKGluZCA8IHBhci5jaGlsZE5vZGVzLmxlbmd0aCkge1xuXHRcdFx0XHRcdHBhci5pbnNlcnRCZWZvcmUobm9kZSwgcGFyLmNoaWxkTm9kZXNbaW5kXSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0cGFyLmFwcGVuZENoaWxkKG5vZGUpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmKGYpIHtcblx0XHRcdFx0XHR0ID0gdGhpcy5lbGVtZW50WzBdLnNjcm9sbFRvcDtcblx0XHRcdFx0XHRsID0gdGhpcy5lbGVtZW50WzBdLnNjcm9sbExlZnQ7XG5cdFx0XHRcdFx0bm9kZS5jaGlsZE5vZGVzWzFdLmZvY3VzKCk7XG5cdFx0XHRcdFx0dGhpcy5lbGVtZW50WzBdLnNjcm9sbFRvcCA9IHQ7XG5cdFx0XHRcdFx0dGhpcy5lbGVtZW50WzBdLnNjcm9sbExlZnQgPSBsO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRpZihvYmouc3RhdGUub3BlbmVkICYmICFvYmouc3RhdGUubG9hZGVkKSB7XG5cdFx0XHRcdG9iai5zdGF0ZS5vcGVuZWQgPSBmYWxzZTtcblx0XHRcdFx0c2V0VGltZW91dCgkLnByb3h5KGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0XHR0aGlzLm9wZW5fbm9kZShvYmouaWQsIGZhbHNlLCAwKTtcblx0XHRcdFx0fSwgdGhpcyksIDApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG5vZGU7XG5cdFx0fSxcblx0XHQvKipcblx0XHQgKiBvcGVucyBhIG5vZGUsIHJldmFsaW5nIGl0cyBjaGlsZHJlbi4gSWYgdGhlIG5vZGUgaXMgbm90IGxvYWRlZCBpdCB3aWxsIGJlIGxvYWRlZCBhbmQgb3BlbmVkIG9uY2UgcmVhZHkuXG5cdFx0ICogQG5hbWUgb3Blbl9ub2RlKG9iaiBbLCBjYWxsYmFjaywgYW5pbWF0aW9uXSlcblx0XHQgKiBAcGFyYW0ge21peGVkfSBvYmogdGhlIG5vZGUgdG8gb3BlblxuXHRcdCAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIGEgZnVuY3Rpb24gdG8gZXhlY3V0ZSBvbmNlIHRoZSBub2RlIGlzIG9wZW5lZFxuXHRcdCAqIEBwYXJhbSB7TnVtYmVyfSBhbmltYXRpb24gdGhlIGFuaW1hdGlvbiBkdXJhdGlvbiBpbiBtaWxsaXNlY29uZHMgd2hlbiBvcGVuaW5nIHRoZSBub2RlIChvdmVycmlkZXMgdGhlIGBjb3JlLmFuaW1hdGlvbmAgc2V0dGluZykuIFVzZSBgZmFsc2VgIGZvciBubyBhbmltYXRpb24uXG5cdFx0ICogQHRyaWdnZXIgb3Blbl9ub2RlLmpzdHJlZSwgYWZ0ZXJfb3Blbi5qc3RyZWUsIGJlZm9yZV9vcGVuLmpzdHJlZVxuXHRcdCAqL1xuXHRcdG9wZW5fbm9kZSA6IGZ1bmN0aW9uIChvYmosIGNhbGxiYWNrLCBhbmltYXRpb24pIHtcblx0XHRcdHZhciB0MSwgdDIsIGQsIHQ7XG5cdFx0XHRpZigkLmlzQXJyYXkob2JqKSkge1xuXHRcdFx0XHRvYmogPSBvYmouc2xpY2UoKTtcblx0XHRcdFx0Zm9yKHQxID0gMCwgdDIgPSBvYmoubGVuZ3RoOyB0MSA8IHQyOyB0MSsrKSB7XG5cdFx0XHRcdFx0dGhpcy5vcGVuX25vZGUob2JqW3QxXSwgY2FsbGJhY2ssIGFuaW1hdGlvbik7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9XG5cdFx0XHRvYmogPSB0aGlzLmdldF9ub2RlKG9iaik7XG5cdFx0XHRpZighb2JqIHx8IG9iai5pZCA9PT0gJC5qc3RyZWUucm9vdCkge1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cdFx0XHRhbmltYXRpb24gPSBhbmltYXRpb24gPT09IHVuZGVmaW5lZCA/IHRoaXMuc2V0dGluZ3MuY29yZS5hbmltYXRpb24gOiBhbmltYXRpb247XG5cdFx0XHRpZighdGhpcy5pc19jbG9zZWQob2JqKSkge1xuXHRcdFx0XHRpZihjYWxsYmFjaykge1xuXHRcdFx0XHRcdGNhbGxiYWNrLmNhbGwodGhpcywgb2JqLCBmYWxzZSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXHRcdFx0aWYoIXRoaXMuaXNfbG9hZGVkKG9iaikpIHtcblx0XHRcdFx0aWYodGhpcy5pc19sb2FkaW5nKG9iaikpIHtcblx0XHRcdFx0XHRyZXR1cm4gc2V0VGltZW91dCgkLnByb3h5KGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0XHRcdHRoaXMub3Blbl9ub2RlKG9iaiwgY2FsbGJhY2ssIGFuaW1hdGlvbik7XG5cdFx0XHRcdFx0fSwgdGhpcyksIDUwMCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0dGhpcy5sb2FkX25vZGUob2JqLCBmdW5jdGlvbiAobywgb2spIHtcblx0XHRcdFx0XHRyZXR1cm4gb2sgPyB0aGlzLm9wZW5fbm9kZShvLCBjYWxsYmFjaywgYW5pbWF0aW9uKSA6IChjYWxsYmFjayA/IGNhbGxiYWNrLmNhbGwodGhpcywgbywgZmFsc2UpIDogZmFsc2UpO1xuXHRcdFx0XHR9KTtcblx0XHRcdH1cblx0XHRcdGVsc2Uge1xuXHRcdFx0XHRkID0gdGhpcy5nZXRfbm9kZShvYmosIHRydWUpO1xuXHRcdFx0XHR0ID0gdGhpcztcblx0XHRcdFx0aWYoZC5sZW5ndGgpIHtcblx0XHRcdFx0XHRpZihhbmltYXRpb24gJiYgZC5jaGlsZHJlbihcIi5qc3RyZWUtY2hpbGRyZW5cIikubGVuZ3RoKSB7XG5cdFx0XHRcdFx0XHRkLmNoaWxkcmVuKFwiLmpzdHJlZS1jaGlsZHJlblwiKS5zdG9wKHRydWUsIHRydWUpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZihvYmouY2hpbGRyZW4ubGVuZ3RoICYmICF0aGlzLl9maXJzdENoaWxkKGQuY2hpbGRyZW4oJy5qc3RyZWUtY2hpbGRyZW4nKVswXSkpIHtcblx0XHRcdFx0XHRcdHRoaXMuZHJhd19jaGlsZHJlbihvYmopO1xuXHRcdFx0XHRcdFx0Ly9kID0gdGhpcy5nZXRfbm9kZShvYmosIHRydWUpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZighYW5pbWF0aW9uKSB7XG5cdFx0XHRcdFx0XHR0aGlzLnRyaWdnZXIoJ2JlZm9yZV9vcGVuJywgeyBcIm5vZGVcIiA6IG9iaiB9KTtcblx0XHRcdFx0XHRcdGRbMF0uY2xhc3NOYW1lID0gZFswXS5jbGFzc05hbWUucmVwbGFjZSgnanN0cmVlLWNsb3NlZCcsICdqc3RyZWUtb3BlbicpO1xuXHRcdFx0XHRcdFx0ZFswXS5zZXRBdHRyaWJ1dGUoXCJhcmlhLWV4cGFuZGVkXCIsIHRydWUpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRcdHRoaXMudHJpZ2dlcignYmVmb3JlX29wZW4nLCB7IFwibm9kZVwiIDogb2JqIH0pO1xuXHRcdFx0XHRcdFx0ZFxuXHRcdFx0XHRcdFx0XHQuY2hpbGRyZW4oXCIuanN0cmVlLWNoaWxkcmVuXCIpLmNzcyhcImRpc3BsYXlcIixcIm5vbmVcIikuZW5kKClcblx0XHRcdFx0XHRcdFx0LnJlbW92ZUNsYXNzKFwianN0cmVlLWNsb3NlZFwiKS5hZGRDbGFzcyhcImpzdHJlZS1vcGVuXCIpLmF0dHIoXCJhcmlhLWV4cGFuZGVkXCIsIHRydWUpXG5cdFx0XHRcdFx0XHRcdC5jaGlsZHJlbihcIi5qc3RyZWUtY2hpbGRyZW5cIikuc3RvcCh0cnVlLCB0cnVlKVxuXHRcdFx0XHRcdFx0XHRcdC5zbGlkZURvd24oYW5pbWF0aW9uLCBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHR0aGlzLnN0eWxlLmRpc3BsYXkgPSBcIlwiO1xuXHRcdFx0XHRcdFx0XHRcdFx0aWYgKHQuZWxlbWVudCkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0LnRyaWdnZXIoXCJhZnRlcl9vcGVuXCIsIHsgXCJub2RlXCIgOiBvYmogfSk7XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdG9iai5zdGF0ZS5vcGVuZWQgPSB0cnVlO1xuXHRcdFx0XHRpZihjYWxsYmFjaykge1xuXHRcdFx0XHRcdGNhbGxiYWNrLmNhbGwodGhpcywgb2JqLCB0cnVlKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZighZC5sZW5ndGgpIHtcblx0XHRcdFx0XHQvKipcblx0XHRcdFx0XHQgKiB0cmlnZ2VyZWQgd2hlbiBhIG5vZGUgaXMgYWJvdXQgdG8gYmUgb3BlbmVkIChpZiB0aGUgbm9kZSBpcyBzdXBwb3NlZCB0byBiZSBpbiB0aGUgRE9NLCBpdCB3aWxsIGJlLCBidXQgaXQgd29uJ3QgYmUgdmlzaWJsZSB5ZXQpXG5cdFx0XHRcdFx0ICogQGV2ZW50XG5cdFx0XHRcdFx0ICogQG5hbWUgYmVmb3JlX29wZW4uanN0cmVlXG5cdFx0XHRcdFx0ICogQHBhcmFtIHtPYmplY3R9IG5vZGUgdGhlIG9wZW5lZCBub2RlXG5cdFx0XHRcdFx0ICovXG5cdFx0XHRcdFx0dGhpcy50cmlnZ2VyKCdiZWZvcmVfb3BlbicsIHsgXCJub2RlXCIgOiBvYmogfSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0LyoqXG5cdFx0XHRcdCAqIHRyaWdnZXJlZCB3aGVuIGEgbm9kZSBpcyBvcGVuZWQgKGlmIHRoZXJlIGlzIGFuIGFuaW1hdGlvbiBpdCB3aWxsIG5vdCBiZSBjb21wbGV0ZWQgeWV0KVxuXHRcdFx0XHQgKiBAZXZlbnRcblx0XHRcdFx0ICogQG5hbWUgb3Blbl9ub2RlLmpzdHJlZVxuXHRcdFx0XHQgKiBAcGFyYW0ge09iamVjdH0gbm9kZSB0aGUgb3BlbmVkIG5vZGVcblx0XHRcdFx0ICovXG5cdFx0XHRcdHRoaXMudHJpZ2dlcignb3Blbl9ub2RlJywgeyBcIm5vZGVcIiA6IG9iaiB9KTtcblx0XHRcdFx0aWYoIWFuaW1hdGlvbiB8fCAhZC5sZW5ndGgpIHtcblx0XHRcdFx0XHQvKipcblx0XHRcdFx0XHQgKiB0cmlnZ2VyZWQgd2hlbiBhIG5vZGUgaXMgb3BlbmVkIGFuZCB0aGUgYW5pbWF0aW9uIGlzIGNvbXBsZXRlXG5cdFx0XHRcdFx0ICogQGV2ZW50XG5cdFx0XHRcdFx0ICogQG5hbWUgYWZ0ZXJfb3Blbi5qc3RyZWVcblx0XHRcdFx0XHQgKiBAcGFyYW0ge09iamVjdH0gbm9kZSB0aGUgb3BlbmVkIG5vZGVcblx0XHRcdFx0XHQgKi9cblx0XHRcdFx0XHR0aGlzLnRyaWdnZXIoXCJhZnRlcl9vcGVuXCIsIHsgXCJub2RlXCIgOiBvYmogfSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9XG5cdFx0fSxcblx0XHQvKipcblx0XHQgKiBvcGVucyBldmVyeSBwYXJlbnQgb2YgYSBub2RlIChub2RlIHNob3VsZCBiZSBsb2FkZWQpXG5cdFx0ICogQG5hbWUgX29wZW5fdG8ob2JqKVxuXHRcdCAqIEBwYXJhbSB7bWl4ZWR9IG9iaiB0aGUgbm9kZSB0byByZXZlYWxcblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqL1xuXHRcdF9vcGVuX3RvIDogZnVuY3Rpb24gKG9iaikge1xuXHRcdFx0b2JqID0gdGhpcy5nZXRfbm9kZShvYmopO1xuXHRcdFx0aWYoIW9iaiB8fCBvYmouaWQgPT09ICQuanN0cmVlLnJvb3QpIHtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXHRcdFx0dmFyIGksIGosIHAgPSBvYmoucGFyZW50cztcblx0XHRcdGZvcihpID0gMCwgaiA9IHAubGVuZ3RoOyBpIDwgajsgaSs9MSkge1xuXHRcdFx0XHRpZihpICE9PSAkLmpzdHJlZS5yb290KSB7XG5cdFx0XHRcdFx0dGhpcy5vcGVuX25vZGUocFtpXSwgZmFsc2UsIDApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gJCgnIycgKyBvYmouaWQucmVwbGFjZSgkLmpzdHJlZS5pZHJlZ2V4LCdcXFxcJCYnKSwgdGhpcy5lbGVtZW50KTtcblx0XHR9LFxuXHRcdC8qKlxuXHRcdCAqIGNsb3NlcyBhIG5vZGUsIGhpZGluZyBpdHMgY2hpbGRyZW5cblx0XHQgKiBAbmFtZSBjbG9zZV9ub2RlKG9iaiBbLCBhbmltYXRpb25dKVxuXHRcdCAqIEBwYXJhbSB7bWl4ZWR9IG9iaiB0aGUgbm9kZSB0byBjbG9zZVxuXHRcdCAqIEBwYXJhbSB7TnVtYmVyfSBhbmltYXRpb24gdGhlIGFuaW1hdGlvbiBkdXJhdGlvbiBpbiBtaWxsaXNlY29uZHMgd2hlbiBjbG9zaW5nIHRoZSBub2RlIChvdmVycmlkZXMgdGhlIGBjb3JlLmFuaW1hdGlvbmAgc2V0dGluZykuIFVzZSBgZmFsc2VgIGZvciBubyBhbmltYXRpb24uXG5cdFx0ICogQHRyaWdnZXIgY2xvc2Vfbm9kZS5qc3RyZWUsIGFmdGVyX2Nsb3NlLmpzdHJlZVxuXHRcdCAqL1xuXHRcdGNsb3NlX25vZGUgOiBmdW5jdGlvbiAob2JqLCBhbmltYXRpb24pIHtcblx0XHRcdHZhciB0MSwgdDIsIHQsIGQ7XG5cdFx0XHRpZigkLmlzQXJyYXkob2JqKSkge1xuXHRcdFx0XHRvYmogPSBvYmouc2xpY2UoKTtcblx0XHRcdFx0Zm9yKHQxID0gMCwgdDIgPSBvYmoubGVuZ3RoOyB0MSA8IHQyOyB0MSsrKSB7XG5cdFx0XHRcdFx0dGhpcy5jbG9zZV9ub2RlKG9ialt0MV0sIGFuaW1hdGlvbik7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9XG5cdFx0XHRvYmogPSB0aGlzLmdldF9ub2RlKG9iaik7XG5cdFx0XHRpZighb2JqIHx8IG9iai5pZCA9PT0gJC5qc3RyZWUucm9vdCkge1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cdFx0XHRpZih0aGlzLmlzX2Nsb3NlZChvYmopKSB7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblx0XHRcdGFuaW1hdGlvbiA9IGFuaW1hdGlvbiA9PT0gdW5kZWZpbmVkID8gdGhpcy5zZXR0aW5ncy5jb3JlLmFuaW1hdGlvbiA6IGFuaW1hdGlvbjtcblx0XHRcdHQgPSB0aGlzO1xuXHRcdFx0ZCA9IHRoaXMuZ2V0X25vZGUob2JqLCB0cnVlKTtcblxuXHRcdFx0b2JqLnN0YXRlLm9wZW5lZCA9IGZhbHNlO1xuXHRcdFx0LyoqXG5cdFx0XHQgKiB0cmlnZ2VyZWQgd2hlbiBhIG5vZGUgaXMgY2xvc2VkIChpZiB0aGVyZSBpcyBhbiBhbmltYXRpb24gaXQgd2lsbCBub3QgYmUgY29tcGxldGUgeWV0KVxuXHRcdFx0ICogQGV2ZW50XG5cdFx0XHQgKiBAbmFtZSBjbG9zZV9ub2RlLmpzdHJlZVxuXHRcdFx0ICogQHBhcmFtIHtPYmplY3R9IG5vZGUgdGhlIGNsb3NlZCBub2RlXG5cdFx0XHQgKi9cblx0XHRcdHRoaXMudHJpZ2dlcignY2xvc2Vfbm9kZScseyBcIm5vZGVcIiA6IG9iaiB9KTtcblx0XHRcdGlmKCFkLmxlbmd0aCkge1xuXHRcdFx0XHQvKipcblx0XHRcdFx0ICogdHJpZ2dlcmVkIHdoZW4gYSBub2RlIGlzIGNsb3NlZCBhbmQgdGhlIGFuaW1hdGlvbiBpcyBjb21wbGV0ZVxuXHRcdFx0XHQgKiBAZXZlbnRcblx0XHRcdFx0ICogQG5hbWUgYWZ0ZXJfY2xvc2UuanN0cmVlXG5cdFx0XHRcdCAqIEBwYXJhbSB7T2JqZWN0fSBub2RlIHRoZSBjbG9zZWQgbm9kZVxuXHRcdFx0XHQgKi9cblx0XHRcdFx0dGhpcy50cmlnZ2VyKFwiYWZ0ZXJfY2xvc2VcIiwgeyBcIm5vZGVcIiA6IG9iaiB9KTtcblx0XHRcdH1cblx0XHRcdGVsc2Uge1xuXHRcdFx0XHRpZighYW5pbWF0aW9uKSB7XG5cdFx0XHRcdFx0ZFswXS5jbGFzc05hbWUgPSBkWzBdLmNsYXNzTmFtZS5yZXBsYWNlKCdqc3RyZWUtb3BlbicsICdqc3RyZWUtY2xvc2VkJyk7XG5cdFx0XHRcdFx0ZC5hdHRyKFwiYXJpYS1leHBhbmRlZFwiLCBmYWxzZSkuY2hpbGRyZW4oJy5qc3RyZWUtY2hpbGRyZW4nKS5yZW1vdmUoKTtcblx0XHRcdFx0XHR0aGlzLnRyaWdnZXIoXCJhZnRlcl9jbG9zZVwiLCB7IFwibm9kZVwiIDogb2JqIH0pO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdGRcblx0XHRcdFx0XHRcdC5jaGlsZHJlbihcIi5qc3RyZWUtY2hpbGRyZW5cIikuYXR0cihcInN0eWxlXCIsXCJkaXNwbGF5OmJsb2NrICFpbXBvcnRhbnRcIikuZW5kKClcblx0XHRcdFx0XHRcdC5yZW1vdmVDbGFzcyhcImpzdHJlZS1vcGVuXCIpLmFkZENsYXNzKFwianN0cmVlLWNsb3NlZFwiKS5hdHRyKFwiYXJpYS1leHBhbmRlZFwiLCBmYWxzZSlcblx0XHRcdFx0XHRcdC5jaGlsZHJlbihcIi5qc3RyZWUtY2hpbGRyZW5cIikuc3RvcCh0cnVlLCB0cnVlKS5zbGlkZVVwKGFuaW1hdGlvbiwgZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdFx0XHR0aGlzLnN0eWxlLmRpc3BsYXkgPSBcIlwiO1xuXHRcdFx0XHRcdFx0XHRkLmNoaWxkcmVuKCcuanN0cmVlLWNoaWxkcmVuJykucmVtb3ZlKCk7XG5cdFx0XHRcdFx0XHRcdGlmICh0LmVsZW1lbnQpIHtcblx0XHRcdFx0XHRcdFx0XHR0LnRyaWdnZXIoXCJhZnRlcl9jbG9zZVwiLCB7IFwibm9kZVwiIDogb2JqIH0pO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0LyoqXG5cdFx0ICogdG9nZ2xlcyBhIG5vZGUgLSBjbG9zaW5nIGl0IGlmIGl0IGlzIG9wZW4sIG9wZW5pbmcgaXQgaWYgaXQgaXMgY2xvc2VkXG5cdFx0ICogQG5hbWUgdG9nZ2xlX25vZGUob2JqKVxuXHRcdCAqIEBwYXJhbSB7bWl4ZWR9IG9iaiB0aGUgbm9kZSB0byB0b2dnbGVcblx0XHQgKi9cblx0XHR0b2dnbGVfbm9kZSA6IGZ1bmN0aW9uIChvYmopIHtcblx0XHRcdHZhciB0MSwgdDI7XG5cdFx0XHRpZigkLmlzQXJyYXkob2JqKSkge1xuXHRcdFx0XHRvYmogPSBvYmouc2xpY2UoKTtcblx0XHRcdFx0Zm9yKHQxID0gMCwgdDIgPSBvYmoubGVuZ3RoOyB0MSA8IHQyOyB0MSsrKSB7XG5cdFx0XHRcdFx0dGhpcy50b2dnbGVfbm9kZShvYmpbdDFdKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblx0XHRcdGlmKHRoaXMuaXNfY2xvc2VkKG9iaikpIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMub3Blbl9ub2RlKG9iaik7XG5cdFx0XHR9XG5cdFx0XHRpZih0aGlzLmlzX29wZW4ob2JqKSkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5jbG9zZV9ub2RlKG9iaik7XG5cdFx0XHR9XG5cdFx0fSxcblx0XHQvKipcblx0XHQgKiBvcGVucyBhbGwgbm9kZXMgd2l0aGluIGEgbm9kZSAob3IgdGhlIHRyZWUpLCByZXZhbGluZyB0aGVpciBjaGlsZHJlbi4gSWYgdGhlIG5vZGUgaXMgbm90IGxvYWRlZCBpdCB3aWxsIGJlIGxvYWRlZCBhbmQgb3BlbmVkIG9uY2UgcmVhZHkuXG5cdFx0ICogQG5hbWUgb3Blbl9hbGwoW29iaiwgYW5pbWF0aW9uLCBvcmlnaW5hbF9vYmpdKVxuXHRcdCAqIEBwYXJhbSB7bWl4ZWR9IG9iaiB0aGUgbm9kZSB0byBvcGVuIHJlY3Vyc2l2ZWx5LCBvbWl0IHRvIG9wZW4gYWxsIG5vZGVzIGluIHRoZSB0cmVlXG5cdFx0ICogQHBhcmFtIHtOdW1iZXJ9IGFuaW1hdGlvbiB0aGUgYW5pbWF0aW9uIGR1cmF0aW9uIGluIG1pbGxpc2Vjb25kcyB3aGVuIG9wZW5pbmcgdGhlIG5vZGVzLCB0aGUgZGVmYXVsdCBpcyBubyBhbmltYXRpb25cblx0XHQgKiBAcGFyYW0ge2pRdWVyeX0gcmVmZXJlbmNlIHRvIHRoZSBub2RlIHRoYXQgc3RhcnRlZCB0aGUgcHJvY2VzcyAoaW50ZXJuYWwgdXNlKVxuXHRcdCAqIEB0cmlnZ2VyIG9wZW5fYWxsLmpzdHJlZVxuXHRcdCAqL1xuXHRcdG9wZW5fYWxsIDogZnVuY3Rpb24gKG9iaiwgYW5pbWF0aW9uLCBvcmlnaW5hbF9vYmopIHtcblx0XHRcdGlmKCFvYmopIHsgb2JqID0gJC5qc3RyZWUucm9vdDsgfVxuXHRcdFx0b2JqID0gdGhpcy5nZXRfbm9kZShvYmopO1xuXHRcdFx0aWYoIW9iaikgeyByZXR1cm4gZmFsc2U7IH1cblx0XHRcdHZhciBkb20gPSBvYmouaWQgPT09ICQuanN0cmVlLnJvb3QgPyB0aGlzLmdldF9jb250YWluZXJfdWwoKSA6IHRoaXMuZ2V0X25vZGUob2JqLCB0cnVlKSwgaSwgaiwgX3RoaXM7XG5cdFx0XHRpZighZG9tLmxlbmd0aCkge1xuXHRcdFx0XHRmb3IoaSA9IDAsIGogPSBvYmouY2hpbGRyZW5fZC5sZW5ndGg7IGkgPCBqOyBpKyspIHtcblx0XHRcdFx0XHRpZih0aGlzLmlzX2Nsb3NlZCh0aGlzLl9tb2RlbC5kYXRhW29iai5jaGlsZHJlbl9kW2ldXSkpIHtcblx0XHRcdFx0XHRcdHRoaXMuX21vZGVsLmRhdGFbb2JqLmNoaWxkcmVuX2RbaV1dLnN0YXRlLm9wZW5lZCA9IHRydWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB0aGlzLnRyaWdnZXIoJ29wZW5fYWxsJywgeyBcIm5vZGVcIiA6IG9iaiB9KTtcblx0XHRcdH1cblx0XHRcdG9yaWdpbmFsX29iaiA9IG9yaWdpbmFsX29iaiB8fCBkb207XG5cdFx0XHRfdGhpcyA9IHRoaXM7XG5cdFx0XHRkb20gPSB0aGlzLmlzX2Nsb3NlZChvYmopID8gZG9tLmZpbmQoJy5qc3RyZWUtY2xvc2VkJykuYWRkQmFjaygpIDogZG9tLmZpbmQoJy5qc3RyZWUtY2xvc2VkJyk7XG5cdFx0XHRkb20uZWFjaChmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdF90aGlzLm9wZW5fbm9kZShcblx0XHRcdFx0XHR0aGlzLFxuXHRcdFx0XHRcdGZ1bmN0aW9uKG5vZGUsIHN0YXR1cykgeyBpZihzdGF0dXMgJiYgdGhpcy5pc19wYXJlbnQobm9kZSkpIHsgdGhpcy5vcGVuX2FsbChub2RlLCBhbmltYXRpb24sIG9yaWdpbmFsX29iaik7IH0gfSxcblx0XHRcdFx0XHRhbmltYXRpb24gfHwgMFxuXHRcdFx0XHQpO1xuXHRcdFx0fSk7XG5cdFx0XHRpZihvcmlnaW5hbF9vYmouZmluZCgnLmpzdHJlZS1jbG9zZWQnKS5sZW5ndGggPT09IDApIHtcblx0XHRcdFx0LyoqXG5cdFx0XHRcdCAqIHRyaWdnZXJlZCB3aGVuIGFuIGBvcGVuX2FsbGAgY2FsbCBjb21wbGV0ZXNcblx0XHRcdFx0ICogQGV2ZW50XG5cdFx0XHRcdCAqIEBuYW1lIG9wZW5fYWxsLmpzdHJlZVxuXHRcdFx0XHQgKiBAcGFyYW0ge09iamVjdH0gbm9kZSB0aGUgb3BlbmVkIG5vZGVcblx0XHRcdFx0ICovXG5cdFx0XHRcdHRoaXMudHJpZ2dlcignb3Blbl9hbGwnLCB7IFwibm9kZVwiIDogdGhpcy5nZXRfbm9kZShvcmlnaW5hbF9vYmopIH0pO1xuXHRcdFx0fVxuXHRcdH0sXG5cdFx0LyoqXG5cdFx0ICogY2xvc2VzIGFsbCBub2RlcyB3aXRoaW4gYSBub2RlIChvciB0aGUgdHJlZSksIHJldmFsaW5nIHRoZWlyIGNoaWxkcmVuXG5cdFx0ICogQG5hbWUgY2xvc2VfYWxsKFtvYmosIGFuaW1hdGlvbl0pXG5cdFx0ICogQHBhcmFtIHttaXhlZH0gb2JqIHRoZSBub2RlIHRvIGNsb3NlIHJlY3Vyc2l2ZWx5LCBvbWl0IHRvIGNsb3NlIGFsbCBub2RlcyBpbiB0aGUgdHJlZVxuXHRcdCAqIEBwYXJhbSB7TnVtYmVyfSBhbmltYXRpb24gdGhlIGFuaW1hdGlvbiBkdXJhdGlvbiBpbiBtaWxsaXNlY29uZHMgd2hlbiBjbG9zaW5nIHRoZSBub2RlcywgdGhlIGRlZmF1bHQgaXMgbm8gYW5pbWF0aW9uXG5cdFx0ICogQHRyaWdnZXIgY2xvc2VfYWxsLmpzdHJlZVxuXHRcdCAqL1xuXHRcdGNsb3NlX2FsbCA6IGZ1bmN0aW9uIChvYmosIGFuaW1hdGlvbikge1xuXHRcdFx0aWYoIW9iaikgeyBvYmogPSAkLmpzdHJlZS5yb290OyB9XG5cdFx0XHRvYmogPSB0aGlzLmdldF9ub2RlKG9iaik7XG5cdFx0XHRpZighb2JqKSB7IHJldHVybiBmYWxzZTsgfVxuXHRcdFx0dmFyIGRvbSA9IG9iai5pZCA9PT0gJC5qc3RyZWUucm9vdCA/IHRoaXMuZ2V0X2NvbnRhaW5lcl91bCgpIDogdGhpcy5nZXRfbm9kZShvYmosIHRydWUpLFxuXHRcdFx0XHRfdGhpcyA9IHRoaXMsIGksIGo7XG5cdFx0XHRpZihkb20ubGVuZ3RoKSB7XG5cdFx0XHRcdGRvbSA9IHRoaXMuaXNfb3BlbihvYmopID8gZG9tLmZpbmQoJy5qc3RyZWUtb3BlbicpLmFkZEJhY2soKSA6IGRvbS5maW5kKCcuanN0cmVlLW9wZW4nKTtcblx0XHRcdFx0JChkb20uZ2V0KCkucmV2ZXJzZSgpKS5lYWNoKGZ1bmN0aW9uICgpIHsgX3RoaXMuY2xvc2Vfbm9kZSh0aGlzLCBhbmltYXRpb24gfHwgMCk7IH0pO1xuXHRcdFx0fVxuXHRcdFx0Zm9yKGkgPSAwLCBqID0gb2JqLmNoaWxkcmVuX2QubGVuZ3RoOyBpIDwgajsgaSsrKSB7XG5cdFx0XHRcdHRoaXMuX21vZGVsLmRhdGFbb2JqLmNoaWxkcmVuX2RbaV1dLnN0YXRlLm9wZW5lZCA9IGZhbHNlO1xuXHRcdFx0fVxuXHRcdFx0LyoqXG5cdFx0XHQgKiB0cmlnZ2VyZWQgd2hlbiBhbiBgY2xvc2VfYWxsYCBjYWxsIGNvbXBsZXRlc1xuXHRcdFx0ICogQGV2ZW50XG5cdFx0XHQgKiBAbmFtZSBjbG9zZV9hbGwuanN0cmVlXG5cdFx0XHQgKiBAcGFyYW0ge09iamVjdH0gbm9kZSB0aGUgY2xvc2VkIG5vZGVcblx0XHRcdCAqL1xuXHRcdFx0dGhpcy50cmlnZ2VyKCdjbG9zZV9hbGwnLCB7IFwibm9kZVwiIDogb2JqIH0pO1xuXHRcdH0sXG5cdFx0LyoqXG5cdFx0ICogY2hlY2tzIGlmIGEgbm9kZSBpcyBkaXNhYmxlZCAobm90IHNlbGVjdGFibGUpXG5cdFx0ICogQG5hbWUgaXNfZGlzYWJsZWQob2JqKVxuXHRcdCAqIEBwYXJhbSAge21peGVkfSBvYmpcblx0XHQgKiBAcmV0dXJuIHtCb29sZWFufVxuXHRcdCAqL1xuXHRcdGlzX2Rpc2FibGVkIDogZnVuY3Rpb24gKG9iaikge1xuXHRcdFx0b2JqID0gdGhpcy5nZXRfbm9kZShvYmopO1xuXHRcdFx0cmV0dXJuIG9iaiAmJiBvYmouc3RhdGUgJiYgb2JqLnN0YXRlLmRpc2FibGVkO1xuXHRcdH0sXG5cdFx0LyoqXG5cdFx0ICogZW5hYmxlcyBhIG5vZGUgLSBzbyB0aGF0IGl0IGNhbiBiZSBzZWxlY3RlZFxuXHRcdCAqIEBuYW1lIGVuYWJsZV9ub2RlKG9iailcblx0XHQgKiBAcGFyYW0ge21peGVkfSBvYmogdGhlIG5vZGUgdG8gZW5hYmxlXG5cdFx0ICogQHRyaWdnZXIgZW5hYmxlX25vZGUuanN0cmVlXG5cdFx0ICovXG5cdFx0ZW5hYmxlX25vZGUgOiBmdW5jdGlvbiAob2JqKSB7XG5cdFx0XHR2YXIgdDEsIHQyO1xuXHRcdFx0aWYoJC5pc0FycmF5KG9iaikpIHtcblx0XHRcdFx0b2JqID0gb2JqLnNsaWNlKCk7XG5cdFx0XHRcdGZvcih0MSA9IDAsIHQyID0gb2JqLmxlbmd0aDsgdDEgPCB0MjsgdDErKykge1xuXHRcdFx0XHRcdHRoaXMuZW5hYmxlX25vZGUob2JqW3QxXSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9XG5cdFx0XHRvYmogPSB0aGlzLmdldF9ub2RlKG9iaik7XG5cdFx0XHRpZighb2JqIHx8IG9iai5pZCA9PT0gJC5qc3RyZWUucm9vdCkge1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cdFx0XHRvYmouc3RhdGUuZGlzYWJsZWQgPSBmYWxzZTtcblx0XHRcdHRoaXMuZ2V0X25vZGUob2JqLHRydWUpLmNoaWxkcmVuKCcuanN0cmVlLWFuY2hvcicpLnJlbW92ZUNsYXNzKCdqc3RyZWUtZGlzYWJsZWQnKS5hdHRyKCdhcmlhLWRpc2FibGVkJywgZmFsc2UpO1xuXHRcdFx0LyoqXG5cdFx0XHQgKiB0cmlnZ2VyZWQgd2hlbiBhbiBub2RlIGlzIGVuYWJsZWRcblx0XHRcdCAqIEBldmVudFxuXHRcdFx0ICogQG5hbWUgZW5hYmxlX25vZGUuanN0cmVlXG5cdFx0XHQgKiBAcGFyYW0ge09iamVjdH0gbm9kZSB0aGUgZW5hYmxlZCBub2RlXG5cdFx0XHQgKi9cblx0XHRcdHRoaXMudHJpZ2dlcignZW5hYmxlX25vZGUnLCB7ICdub2RlJyA6IG9iaiB9KTtcblx0XHR9LFxuXHRcdC8qKlxuXHRcdCAqIGRpc2FibGVzIGEgbm9kZSAtIHNvIHRoYXQgaXQgY2FuIG5vdCBiZSBzZWxlY3RlZFxuXHRcdCAqIEBuYW1lIGRpc2FibGVfbm9kZShvYmopXG5cdFx0ICogQHBhcmFtIHttaXhlZH0gb2JqIHRoZSBub2RlIHRvIGRpc2FibGVcblx0XHQgKiBAdHJpZ2dlciBkaXNhYmxlX25vZGUuanN0cmVlXG5cdFx0ICovXG5cdFx0ZGlzYWJsZV9ub2RlIDogZnVuY3Rpb24gKG9iaikge1xuXHRcdFx0dmFyIHQxLCB0Mjtcblx0XHRcdGlmKCQuaXNBcnJheShvYmopKSB7XG5cdFx0XHRcdG9iaiA9IG9iai5zbGljZSgpO1xuXHRcdFx0XHRmb3IodDEgPSAwLCB0MiA9IG9iai5sZW5ndGg7IHQxIDwgdDI7IHQxKyspIHtcblx0XHRcdFx0XHR0aGlzLmRpc2FibGVfbm9kZShvYmpbdDFdKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblx0XHRcdG9iaiA9IHRoaXMuZ2V0X25vZGUob2JqKTtcblx0XHRcdGlmKCFvYmogfHwgb2JqLmlkID09PSAkLmpzdHJlZS5yb290KSB7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblx0XHRcdG9iai5zdGF0ZS5kaXNhYmxlZCA9IHRydWU7XG5cdFx0XHR0aGlzLmdldF9ub2RlKG9iaix0cnVlKS5jaGlsZHJlbignLmpzdHJlZS1hbmNob3InKS5hZGRDbGFzcygnanN0cmVlLWRpc2FibGVkJykuYXR0cignYXJpYS1kaXNhYmxlZCcsIHRydWUpO1xuXHRcdFx0LyoqXG5cdFx0XHQgKiB0cmlnZ2VyZWQgd2hlbiBhbiBub2RlIGlzIGRpc2FibGVkXG5cdFx0XHQgKiBAZXZlbnRcblx0XHRcdCAqIEBuYW1lIGRpc2FibGVfbm9kZS5qc3RyZWVcblx0XHRcdCAqIEBwYXJhbSB7T2JqZWN0fSBub2RlIHRoZSBkaXNhYmxlZCBub2RlXG5cdFx0XHQgKi9cblx0XHRcdHRoaXMudHJpZ2dlcignZGlzYWJsZV9ub2RlJywgeyAnbm9kZScgOiBvYmogfSk7XG5cdFx0fSxcblx0XHQvKipcblx0XHQgKiBkZXRlcm1pbmVzIGlmIGEgbm9kZSBpcyBoaWRkZW5cblx0XHQgKiBAbmFtZSBpc19oaWRkZW4ob2JqKVxuXHRcdCAqIEBwYXJhbSB7bWl4ZWR9IG9iaiB0aGUgbm9kZVxuXHRcdCAqL1xuXHRcdGlzX2hpZGRlbiA6IGZ1bmN0aW9uIChvYmopIHtcblx0XHRcdG9iaiA9IHRoaXMuZ2V0X25vZGUob2JqKTtcblx0XHRcdHJldHVybiBvYmouc3RhdGUuaGlkZGVuID09PSB0cnVlO1xuXHRcdH0sXG5cdFx0LyoqXG5cdFx0ICogaGlkZXMgYSBub2RlIC0gaXQgaXMgc3RpbGwgaW4gdGhlIHN0cnVjdHVyZSBidXQgd2lsbCBub3QgYmUgdmlzaWJsZVxuXHRcdCAqIEBuYW1lIGhpZGVfbm9kZShvYmopXG5cdFx0ICogQHBhcmFtIHttaXhlZH0gb2JqIHRoZSBub2RlIHRvIGhpZGVcblx0XHQgKiBAcGFyYW0ge0Jvb2xlYW59IHNraXBfcmVkcmF3IGludGVybmFsIHBhcmFtZXRlciBjb250cm9sbGluZyBpZiByZWRyYXcgaXMgY2FsbGVkXG5cdFx0ICogQHRyaWdnZXIgaGlkZV9ub2RlLmpzdHJlZVxuXHRcdCAqL1xuXHRcdGhpZGVfbm9kZSA6IGZ1bmN0aW9uIChvYmosIHNraXBfcmVkcmF3KSB7XG5cdFx0XHR2YXIgdDEsIHQyO1xuXHRcdFx0aWYoJC5pc0FycmF5KG9iaikpIHtcblx0XHRcdFx0b2JqID0gb2JqLnNsaWNlKCk7XG5cdFx0XHRcdGZvcih0MSA9IDAsIHQyID0gb2JqLmxlbmd0aDsgdDEgPCB0MjsgdDErKykge1xuXHRcdFx0XHRcdHRoaXMuaGlkZV9ub2RlKG9ialt0MV0sIHRydWUpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICghc2tpcF9yZWRyYXcpIHtcblx0XHRcdFx0XHR0aGlzLnJlZHJhdygpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fVxuXHRcdFx0b2JqID0gdGhpcy5nZXRfbm9kZShvYmopO1xuXHRcdFx0aWYoIW9iaiB8fCBvYmouaWQgPT09ICQuanN0cmVlLnJvb3QpIHtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXHRcdFx0aWYoIW9iai5zdGF0ZS5oaWRkZW4pIHtcblx0XHRcdFx0b2JqLnN0YXRlLmhpZGRlbiA9IHRydWU7XG5cdFx0XHRcdHRoaXMuX25vZGVfY2hhbmdlZChvYmoucGFyZW50KTtcblx0XHRcdFx0aWYoIXNraXBfcmVkcmF3KSB7XG5cdFx0XHRcdFx0dGhpcy5yZWRyYXcoKTtcblx0XHRcdFx0fVxuXHRcdFx0XHQvKipcblx0XHRcdFx0ICogdHJpZ2dlcmVkIHdoZW4gYW4gbm9kZSBpcyBoaWRkZW5cblx0XHRcdFx0ICogQGV2ZW50XG5cdFx0XHRcdCAqIEBuYW1lIGhpZGVfbm9kZS5qc3RyZWVcblx0XHRcdFx0ICogQHBhcmFtIHtPYmplY3R9IG5vZGUgdGhlIGhpZGRlbiBub2RlXG5cdFx0XHRcdCAqL1xuXHRcdFx0XHR0aGlzLnRyaWdnZXIoJ2hpZGVfbm9kZScsIHsgJ25vZGUnIDogb2JqIH0pO1xuXHRcdFx0fVxuXHRcdH0sXG5cdFx0LyoqXG5cdFx0ICogc2hvd3MgYSBub2RlXG5cdFx0ICogQG5hbWUgc2hvd19ub2RlKG9iailcblx0XHQgKiBAcGFyYW0ge21peGVkfSBvYmogdGhlIG5vZGUgdG8gc2hvd1xuXHRcdCAqIEBwYXJhbSB7Qm9vbGVhbn0gc2tpcF9yZWRyYXcgaW50ZXJuYWwgcGFyYW1ldGVyIGNvbnRyb2xsaW5nIGlmIHJlZHJhdyBpcyBjYWxsZWRcblx0XHQgKiBAdHJpZ2dlciBzaG93X25vZGUuanN0cmVlXG5cdFx0ICovXG5cdFx0c2hvd19ub2RlIDogZnVuY3Rpb24gKG9iaiwgc2tpcF9yZWRyYXcpIHtcblx0XHRcdHZhciB0MSwgdDI7XG5cdFx0XHRpZigkLmlzQXJyYXkob2JqKSkge1xuXHRcdFx0XHRvYmogPSBvYmouc2xpY2UoKTtcblx0XHRcdFx0Zm9yKHQxID0gMCwgdDIgPSBvYmoubGVuZ3RoOyB0MSA8IHQyOyB0MSsrKSB7XG5cdFx0XHRcdFx0dGhpcy5zaG93X25vZGUob2JqW3QxXSwgdHJ1ZSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCFza2lwX3JlZHJhdykge1xuXHRcdFx0XHRcdHRoaXMucmVkcmF3KCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9XG5cdFx0XHRvYmogPSB0aGlzLmdldF9ub2RlKG9iaik7XG5cdFx0XHRpZighb2JqIHx8IG9iai5pZCA9PT0gJC5qc3RyZWUucm9vdCkge1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cdFx0XHRpZihvYmouc3RhdGUuaGlkZGVuKSB7XG5cdFx0XHRcdG9iai5zdGF0ZS5oaWRkZW4gPSBmYWxzZTtcblx0XHRcdFx0dGhpcy5fbm9kZV9jaGFuZ2VkKG9iai5wYXJlbnQpO1xuXHRcdFx0XHRpZighc2tpcF9yZWRyYXcpIHtcblx0XHRcdFx0XHR0aGlzLnJlZHJhdygpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdC8qKlxuXHRcdFx0XHQgKiB0cmlnZ2VyZWQgd2hlbiBhbiBub2RlIGlzIHNob3duXG5cdFx0XHRcdCAqIEBldmVudFxuXHRcdFx0XHQgKiBAbmFtZSBzaG93X25vZGUuanN0cmVlXG5cdFx0XHRcdCAqIEBwYXJhbSB7T2JqZWN0fSBub2RlIHRoZSBzaG93biBub2RlXG5cdFx0XHRcdCAqL1xuXHRcdFx0XHR0aGlzLnRyaWdnZXIoJ3Nob3dfbm9kZScsIHsgJ25vZGUnIDogb2JqIH0pO1xuXHRcdFx0fVxuXHRcdH0sXG5cdFx0LyoqXG5cdFx0ICogaGlkZXMgYWxsIG5vZGVzXG5cdFx0ICogQG5hbWUgaGlkZV9hbGwoKVxuXHRcdCAqIEB0cmlnZ2VyIGhpZGVfYWxsLmpzdHJlZVxuXHRcdCAqL1xuXHRcdGhpZGVfYWxsIDogZnVuY3Rpb24gKHNraXBfcmVkcmF3KSB7XG5cdFx0XHR2YXIgaSwgbSA9IHRoaXMuX21vZGVsLmRhdGEsIGlkcyA9IFtdO1xuXHRcdFx0Zm9yKGkgaW4gbSkge1xuXHRcdFx0XHRpZihtLmhhc093blByb3BlcnR5KGkpICYmIGkgIT09ICQuanN0cmVlLnJvb3QgJiYgIW1baV0uc3RhdGUuaGlkZGVuKSB7XG5cdFx0XHRcdFx0bVtpXS5zdGF0ZS5oaWRkZW4gPSB0cnVlO1xuXHRcdFx0XHRcdGlkcy5wdXNoKGkpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHR0aGlzLl9tb2RlbC5mb3JjZV9mdWxsX3JlZHJhdyA9IHRydWU7XG5cdFx0XHRpZighc2tpcF9yZWRyYXcpIHtcblx0XHRcdFx0dGhpcy5yZWRyYXcoKTtcblx0XHRcdH1cblx0XHRcdC8qKlxuXHRcdFx0ICogdHJpZ2dlcmVkIHdoZW4gYWxsIG5vZGVzIGFyZSBoaWRkZW5cblx0XHRcdCAqIEBldmVudFxuXHRcdFx0ICogQG5hbWUgaGlkZV9hbGwuanN0cmVlXG5cdFx0XHQgKiBAcGFyYW0ge0FycmF5fSBub2RlcyB0aGUgSURzIG9mIGFsbCBoaWRkZW4gbm9kZXNcblx0XHRcdCAqL1xuXHRcdFx0dGhpcy50cmlnZ2VyKCdoaWRlX2FsbCcsIHsgJ25vZGVzJyA6IGlkcyB9KTtcblx0XHRcdHJldHVybiBpZHM7XG5cdFx0fSxcblx0XHQvKipcblx0XHQgKiBzaG93cyBhbGwgbm9kZXNcblx0XHQgKiBAbmFtZSBzaG93X2FsbCgpXG5cdFx0ICogQHRyaWdnZXIgc2hvd19hbGwuanN0cmVlXG5cdFx0ICovXG5cdFx0c2hvd19hbGwgOiBmdW5jdGlvbiAoc2tpcF9yZWRyYXcpIHtcblx0XHRcdHZhciBpLCBtID0gdGhpcy5fbW9kZWwuZGF0YSwgaWRzID0gW107XG5cdFx0XHRmb3IoaSBpbiBtKSB7XG5cdFx0XHRcdGlmKG0uaGFzT3duUHJvcGVydHkoaSkgJiYgaSAhPT0gJC5qc3RyZWUucm9vdCAmJiBtW2ldLnN0YXRlLmhpZGRlbikge1xuXHRcdFx0XHRcdG1baV0uc3RhdGUuaGlkZGVuID0gZmFsc2U7XG5cdFx0XHRcdFx0aWRzLnB1c2goaSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHRoaXMuX21vZGVsLmZvcmNlX2Z1bGxfcmVkcmF3ID0gdHJ1ZTtcblx0XHRcdGlmKCFza2lwX3JlZHJhdykge1xuXHRcdFx0XHR0aGlzLnJlZHJhdygpO1xuXHRcdFx0fVxuXHRcdFx0LyoqXG5cdFx0XHQgKiB0cmlnZ2VyZWQgd2hlbiBhbGwgbm9kZXMgYXJlIHNob3duXG5cdFx0XHQgKiBAZXZlbnRcblx0XHRcdCAqIEBuYW1lIHNob3dfYWxsLmpzdHJlZVxuXHRcdFx0ICogQHBhcmFtIHtBcnJheX0gbm9kZXMgdGhlIElEcyBvZiBhbGwgc2hvd24gbm9kZXNcblx0XHRcdCAqL1xuXHRcdFx0dGhpcy50cmlnZ2VyKCdzaG93X2FsbCcsIHsgJ25vZGVzJyA6IGlkcyB9KTtcblx0XHRcdHJldHVybiBpZHM7XG5cdFx0fSxcblx0XHQvKipcblx0XHQgKiBjYWxsZWQgd2hlbiBhIG5vZGUgaXMgc2VsZWN0ZWQgYnkgdGhlIHVzZXIuIFVzZWQgaW50ZXJuYWxseS5cblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqIEBuYW1lIGFjdGl2YXRlX25vZGUob2JqLCBlKVxuXHRcdCAqIEBwYXJhbSB7bWl4ZWR9IG9iaiB0aGUgbm9kZVxuXHRcdCAqIEBwYXJhbSB7T2JqZWN0fSBlIHRoZSByZWxhdGVkIGV2ZW50XG5cdFx0ICogQHRyaWdnZXIgYWN0aXZhdGVfbm9kZS5qc3RyZWUsIGNoYW5nZWQuanN0cmVlXG5cdFx0ICovXG5cdFx0YWN0aXZhdGVfbm9kZSA6IGZ1bmN0aW9uIChvYmosIGUpIHtcblx0XHRcdGlmKHRoaXMuaXNfZGlzYWJsZWQob2JqKSkge1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cdFx0XHRpZighZSB8fCB0eXBlb2YgZSAhPT0gJ29iamVjdCcpIHtcblx0XHRcdFx0ZSA9IHt9O1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBlbnN1cmUgbGFzdF9jbGlja2VkIGlzIHN0aWxsIGluIHRoZSBET00sIG1ha2UgaXQgZnJlc2ggKG1heWJlIGl0IHdhcyBtb3ZlZD8pIGFuZCBtYWtlIHN1cmUgaXQgaXMgc3RpbGwgc2VsZWN0ZWQsIGlmIG5vdCAtIG1ha2UgbGFzdF9jbGlja2VkIHRoZSBsYXN0IHNlbGVjdGVkIG5vZGVcblx0XHRcdHRoaXMuX2RhdGEuY29yZS5sYXN0X2NsaWNrZWQgPSB0aGlzLl9kYXRhLmNvcmUubGFzdF9jbGlja2VkICYmIHRoaXMuX2RhdGEuY29yZS5sYXN0X2NsaWNrZWQuaWQgIT09IHVuZGVmaW5lZCA/IHRoaXMuZ2V0X25vZGUodGhpcy5fZGF0YS5jb3JlLmxhc3RfY2xpY2tlZC5pZCkgOiBudWxsO1xuXHRcdFx0aWYodGhpcy5fZGF0YS5jb3JlLmxhc3RfY2xpY2tlZCAmJiAhdGhpcy5fZGF0YS5jb3JlLmxhc3RfY2xpY2tlZC5zdGF0ZS5zZWxlY3RlZCkgeyB0aGlzLl9kYXRhLmNvcmUubGFzdF9jbGlja2VkID0gbnVsbDsgfVxuXHRcdFx0aWYoIXRoaXMuX2RhdGEuY29yZS5sYXN0X2NsaWNrZWQgJiYgdGhpcy5fZGF0YS5jb3JlLnNlbGVjdGVkLmxlbmd0aCkgeyB0aGlzLl9kYXRhLmNvcmUubGFzdF9jbGlja2VkID0gdGhpcy5nZXRfbm9kZSh0aGlzLl9kYXRhLmNvcmUuc2VsZWN0ZWRbdGhpcy5fZGF0YS5jb3JlLnNlbGVjdGVkLmxlbmd0aCAtIDFdKTsgfVxuXG5cdFx0XHRpZighdGhpcy5zZXR0aW5ncy5jb3JlLm11bHRpcGxlIHx8ICghZS5tZXRhS2V5ICYmICFlLmN0cmxLZXkgJiYgIWUuc2hpZnRLZXkpIHx8IChlLnNoaWZ0S2V5ICYmICghdGhpcy5fZGF0YS5jb3JlLmxhc3RfY2xpY2tlZCB8fCAhdGhpcy5nZXRfcGFyZW50KG9iaikgfHwgdGhpcy5nZXRfcGFyZW50KG9iaikgIT09IHRoaXMuX2RhdGEuY29yZS5sYXN0X2NsaWNrZWQucGFyZW50ICkgKSkge1xuXHRcdFx0XHRpZighdGhpcy5zZXR0aW5ncy5jb3JlLm11bHRpcGxlICYmIChlLm1ldGFLZXkgfHwgZS5jdHJsS2V5IHx8IGUuc2hpZnRLZXkpICYmIHRoaXMuaXNfc2VsZWN0ZWQob2JqKSkge1xuXHRcdFx0XHRcdHRoaXMuZGVzZWxlY3Rfbm9kZShvYmosIGZhbHNlLCBlKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHR0aGlzLmRlc2VsZWN0X2FsbCh0cnVlKTtcblx0XHRcdFx0XHR0aGlzLnNlbGVjdF9ub2RlKG9iaiwgZmFsc2UsIGZhbHNlLCBlKTtcblx0XHRcdFx0XHR0aGlzLl9kYXRhLmNvcmUubGFzdF9jbGlja2VkID0gdGhpcy5nZXRfbm9kZShvYmopO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRlbHNlIHtcblx0XHRcdFx0aWYoZS5zaGlmdEtleSkge1xuXHRcdFx0XHRcdHZhciBvID0gdGhpcy5nZXRfbm9kZShvYmopLmlkLFxuXHRcdFx0XHRcdFx0bCA9IHRoaXMuX2RhdGEuY29yZS5sYXN0X2NsaWNrZWQuaWQsXG5cdFx0XHRcdFx0XHRwID0gdGhpcy5nZXRfbm9kZSh0aGlzLl9kYXRhLmNvcmUubGFzdF9jbGlja2VkLnBhcmVudCkuY2hpbGRyZW4sXG5cdFx0XHRcdFx0XHRjID0gZmFsc2UsXG5cdFx0XHRcdFx0XHRpLCBqO1xuXHRcdFx0XHRcdGZvcihpID0gMCwgaiA9IHAubGVuZ3RoOyBpIDwgajsgaSArPSAxKSB7XG5cdFx0XHRcdFx0XHQvLyBzZXBhcmF0ZSBJRnMgd29yayB3aGVtIG8gYW5kIGwgYXJlIHRoZSBzYW1lXG5cdFx0XHRcdFx0XHRpZihwW2ldID09PSBvKSB7XG5cdFx0XHRcdFx0XHRcdGMgPSAhYztcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGlmKHBbaV0gPT09IGwpIHtcblx0XHRcdFx0XHRcdFx0YyA9ICFjO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0aWYoIXRoaXMuaXNfZGlzYWJsZWQocFtpXSkgJiYgKGMgfHwgcFtpXSA9PT0gbyB8fCBwW2ldID09PSBsKSkge1xuXHRcdFx0XHRcdFx0XHRpZiAoIXRoaXMuaXNfaGlkZGVuKHBbaV0pKSB7XG5cdFx0XHRcdFx0XHRcdFx0dGhpcy5zZWxlY3Rfbm9kZShwW2ldLCB0cnVlLCBmYWxzZSwgZSk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdFx0XHR0aGlzLmRlc2VsZWN0X25vZGUocFtpXSwgdHJ1ZSwgZSk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHRoaXMudHJpZ2dlcignY2hhbmdlZCcsIHsgJ2FjdGlvbicgOiAnc2VsZWN0X25vZGUnLCAnbm9kZScgOiB0aGlzLmdldF9ub2RlKG9iaiksICdzZWxlY3RlZCcgOiB0aGlzLl9kYXRhLmNvcmUuc2VsZWN0ZWQsICdldmVudCcgOiBlIH0pO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdGlmKCF0aGlzLmlzX3NlbGVjdGVkKG9iaikpIHtcblx0XHRcdFx0XHRcdHRoaXMuc2VsZWN0X25vZGUob2JqLCBmYWxzZSwgZmFsc2UsIGUpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRcdHRoaXMuZGVzZWxlY3Rfbm9kZShvYmosIGZhbHNlLCBlKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdC8qKlxuXHRcdFx0ICogdHJpZ2dlcmVkIHdoZW4gYW4gbm9kZSBpcyBjbGlja2VkIG9yIGludGVyY2F0ZWQgd2l0aCBieSB0aGUgdXNlclxuXHRcdFx0ICogQGV2ZW50XG5cdFx0XHQgKiBAbmFtZSBhY3RpdmF0ZV9ub2RlLmpzdHJlZVxuXHRcdFx0ICogQHBhcmFtIHtPYmplY3R9IG5vZGVcblx0XHRcdCAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCB0aGUgb29yaWdpbmFsIGV2ZW50IChpZiBhbnkpIHdoaWNoIHRyaWdnZXJlZCB0aGUgY2FsbCAobWF5IGJlIGFuIGVtcHR5IG9iamVjdClcblx0XHRcdCAqL1xuXHRcdFx0dGhpcy50cmlnZ2VyKCdhY3RpdmF0ZV9ub2RlJywgeyAnbm9kZScgOiB0aGlzLmdldF9ub2RlKG9iaiksICdldmVudCcgOiBlIH0pO1xuXHRcdH0sXG5cdFx0LyoqXG5cdFx0ICogYXBwbGllcyB0aGUgaG92ZXIgc3RhdGUgb24gYSBub2RlLCBjYWxsZWQgd2hlbiBhIG5vZGUgaXMgaG92ZXJlZCBieSB0aGUgdXNlci4gVXNlZCBpbnRlcm5hbGx5LlxuXHRcdCAqIEBwcml2YXRlXG5cdFx0ICogQG5hbWUgaG92ZXJfbm9kZShvYmopXG5cdFx0ICogQHBhcmFtIHttaXhlZH0gb2JqXG5cdFx0ICogQHRyaWdnZXIgaG92ZXJfbm9kZS5qc3RyZWVcblx0XHQgKi9cblx0XHRob3Zlcl9ub2RlIDogZnVuY3Rpb24gKG9iaikge1xuXHRcdFx0b2JqID0gdGhpcy5nZXRfbm9kZShvYmosIHRydWUpO1xuXHRcdFx0aWYoIW9iaiB8fCAhb2JqLmxlbmd0aCB8fCBvYmouY2hpbGRyZW4oJy5qc3RyZWUtaG92ZXJlZCcpLmxlbmd0aCkge1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cdFx0XHR2YXIgbyA9IHRoaXMuZWxlbWVudC5maW5kKCcuanN0cmVlLWhvdmVyZWQnKSwgdCA9IHRoaXMuZWxlbWVudDtcblx0XHRcdGlmKG8gJiYgby5sZW5ndGgpIHsgdGhpcy5kZWhvdmVyX25vZGUobyk7IH1cblxuXHRcdFx0b2JqLmNoaWxkcmVuKCcuanN0cmVlLWFuY2hvcicpLmFkZENsYXNzKCdqc3RyZWUtaG92ZXJlZCcpO1xuXHRcdFx0LyoqXG5cdFx0XHQgKiB0cmlnZ2VyZWQgd2hlbiBhbiBub2RlIGlzIGhvdmVyZWRcblx0XHRcdCAqIEBldmVudFxuXHRcdFx0ICogQG5hbWUgaG92ZXJfbm9kZS5qc3RyZWVcblx0XHRcdCAqIEBwYXJhbSB7T2JqZWN0fSBub2RlXG5cdFx0XHQgKi9cblx0XHRcdHRoaXMudHJpZ2dlcignaG92ZXJfbm9kZScsIHsgJ25vZGUnIDogdGhpcy5nZXRfbm9kZShvYmopIH0pO1xuXHRcdFx0c2V0VGltZW91dChmdW5jdGlvbiAoKSB7IHQuYXR0cignYXJpYS1hY3RpdmVkZXNjZW5kYW50Jywgb2JqWzBdLmlkKTsgfSwgMCk7XG5cdFx0fSxcblx0XHQvKipcblx0XHQgKiByZW1vdmVzIHRoZSBob3ZlciBzdGF0ZSBmcm9tIGEgbm9kZWNhbGxlZCB3aGVuIGEgbm9kZSBpcyBubyBsb25nZXIgaG92ZXJlZCBieSB0aGUgdXNlci4gVXNlZCBpbnRlcm5hbGx5LlxuXHRcdCAqIEBwcml2YXRlXG5cdFx0ICogQG5hbWUgZGVob3Zlcl9ub2RlKG9iailcblx0XHQgKiBAcGFyYW0ge21peGVkfSBvYmpcblx0XHQgKiBAdHJpZ2dlciBkZWhvdmVyX25vZGUuanN0cmVlXG5cdFx0ICovXG5cdFx0ZGVob3Zlcl9ub2RlIDogZnVuY3Rpb24gKG9iaikge1xuXHRcdFx0b2JqID0gdGhpcy5nZXRfbm9kZShvYmosIHRydWUpO1xuXHRcdFx0aWYoIW9iaiB8fCAhb2JqLmxlbmd0aCB8fCAhb2JqLmNoaWxkcmVuKCcuanN0cmVlLWhvdmVyZWQnKS5sZW5ndGgpIHtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXHRcdFx0b2JqLmNoaWxkcmVuKCcuanN0cmVlLWFuY2hvcicpLnJlbW92ZUNsYXNzKCdqc3RyZWUtaG92ZXJlZCcpO1xuXHRcdFx0LyoqXG5cdFx0XHQgKiB0cmlnZ2VyZWQgd2hlbiBhbiBub2RlIGlzIG5vIGxvbmdlciBob3ZlcmVkXG5cdFx0XHQgKiBAZXZlbnRcblx0XHRcdCAqIEBuYW1lIGRlaG92ZXJfbm9kZS5qc3RyZWVcblx0XHRcdCAqIEBwYXJhbSB7T2JqZWN0fSBub2RlXG5cdFx0XHQgKi9cblx0XHRcdHRoaXMudHJpZ2dlcignZGVob3Zlcl9ub2RlJywgeyAnbm9kZScgOiB0aGlzLmdldF9ub2RlKG9iaikgfSk7XG5cdFx0fSxcblx0XHQvKipcblx0XHQgKiBzZWxlY3QgYSBub2RlXG5cdFx0ICogQG5hbWUgc2VsZWN0X25vZGUob2JqIFssIHN1cHJlc3NfZXZlbnQsIHByZXZlbnRfb3Blbl0pXG5cdFx0ICogQHBhcmFtIHttaXhlZH0gb2JqIGFuIGFycmF5IGNhbiBiZSB1c2VkIHRvIHNlbGVjdCBtdWx0aXBsZSBub2Rlc1xuXHRcdCAqIEBwYXJhbSB7Qm9vbGVhbn0gc3VwcmVzc19ldmVudCBpZiBzZXQgdG8gYHRydWVgIHRoZSBgY2hhbmdlZC5qc3RyZWVgIGV2ZW50IHdvbid0IGJlIHRyaWdnZXJlZFxuXHRcdCAqIEBwYXJhbSB7Qm9vbGVhbn0gcHJldmVudF9vcGVuIGlmIHNldCB0byBgdHJ1ZWAgcGFyZW50cyBvZiB0aGUgc2VsZWN0ZWQgbm9kZSB3b24ndCBiZSBvcGVuZWRcblx0XHQgKiBAdHJpZ2dlciBzZWxlY3Rfbm9kZS5qc3RyZWUsIGNoYW5nZWQuanN0cmVlXG5cdFx0ICovXG5cdFx0c2VsZWN0X25vZGUgOiBmdW5jdGlvbiAob2JqLCBzdXByZXNzX2V2ZW50LCBwcmV2ZW50X29wZW4sIGUpIHtcblx0XHRcdHZhciBkb20sIHQxLCB0MiwgdGg7XG5cdFx0XHRpZigkLmlzQXJyYXkob2JqKSkge1xuXHRcdFx0XHRvYmogPSBvYmouc2xpY2UoKTtcblx0XHRcdFx0Zm9yKHQxID0gMCwgdDIgPSBvYmoubGVuZ3RoOyB0MSA8IHQyOyB0MSsrKSB7XG5cdFx0XHRcdFx0dGhpcy5zZWxlY3Rfbm9kZShvYmpbdDFdLCBzdXByZXNzX2V2ZW50LCBwcmV2ZW50X29wZW4sIGUpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fVxuXHRcdFx0b2JqID0gdGhpcy5nZXRfbm9kZShvYmopO1xuXHRcdFx0aWYoIW9iaiB8fCBvYmouaWQgPT09ICQuanN0cmVlLnJvb3QpIHtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXHRcdFx0ZG9tID0gdGhpcy5nZXRfbm9kZShvYmosIHRydWUpO1xuXHRcdFx0aWYoIW9iai5zdGF0ZS5zZWxlY3RlZCkge1xuXHRcdFx0XHRvYmouc3RhdGUuc2VsZWN0ZWQgPSB0cnVlO1xuXHRcdFx0XHR0aGlzLl9kYXRhLmNvcmUuc2VsZWN0ZWQucHVzaChvYmouaWQpO1xuXHRcdFx0XHRpZighcHJldmVudF9vcGVuKSB7XG5cdFx0XHRcdFx0ZG9tID0gdGhpcy5fb3Blbl90byhvYmopO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmKGRvbSAmJiBkb20ubGVuZ3RoKSB7XG5cdFx0XHRcdFx0ZG9tLmF0dHIoJ2FyaWEtc2VsZWN0ZWQnLCB0cnVlKS5jaGlsZHJlbignLmpzdHJlZS1hbmNob3InKS5hZGRDbGFzcygnanN0cmVlLWNsaWNrZWQnKTtcblx0XHRcdFx0fVxuXHRcdFx0XHQvKipcblx0XHRcdFx0ICogdHJpZ2dlcmVkIHdoZW4gYW4gbm9kZSBpcyBzZWxlY3RlZFxuXHRcdFx0XHQgKiBAZXZlbnRcblx0XHRcdFx0ICogQG5hbWUgc2VsZWN0X25vZGUuanN0cmVlXG5cdFx0XHRcdCAqIEBwYXJhbSB7T2JqZWN0fSBub2RlXG5cdFx0XHRcdCAqIEBwYXJhbSB7QXJyYXl9IHNlbGVjdGVkIHRoZSBjdXJyZW50IHNlbGVjdGlvblxuXHRcdFx0XHQgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgdGhlIGV2ZW50IChpZiBhbnkpIHRoYXQgdHJpZ2dlcmVkIHRoaXMgc2VsZWN0X25vZGVcblx0XHRcdFx0ICovXG5cdFx0XHRcdHRoaXMudHJpZ2dlcignc2VsZWN0X25vZGUnLCB7ICdub2RlJyA6IG9iaiwgJ3NlbGVjdGVkJyA6IHRoaXMuX2RhdGEuY29yZS5zZWxlY3RlZCwgJ2V2ZW50JyA6IGUgfSk7XG5cdFx0XHRcdGlmKCFzdXByZXNzX2V2ZW50KSB7XG5cdFx0XHRcdFx0LyoqXG5cdFx0XHRcdFx0ICogdHJpZ2dlcmVkIHdoZW4gc2VsZWN0aW9uIGNoYW5nZXNcblx0XHRcdFx0XHQgKiBAZXZlbnRcblx0XHRcdFx0XHQgKiBAbmFtZSBjaGFuZ2VkLmpzdHJlZVxuXHRcdFx0XHRcdCAqIEBwYXJhbSB7T2JqZWN0fSBub2RlXG5cdFx0XHRcdFx0ICogQHBhcmFtIHtPYmplY3R9IGFjdGlvbiB0aGUgYWN0aW9uIHRoYXQgY2F1c2VkIHRoZSBzZWxlY3Rpb24gdG8gY2hhbmdlXG5cdFx0XHRcdFx0ICogQHBhcmFtIHtBcnJheX0gc2VsZWN0ZWQgdGhlIGN1cnJlbnQgc2VsZWN0aW9uXG5cdFx0XHRcdFx0ICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IHRoZSBldmVudCAoaWYgYW55KSB0aGF0IHRyaWdnZXJlZCB0aGlzIGNoYW5nZWQgZXZlbnRcblx0XHRcdFx0XHQgKi9cblx0XHRcdFx0XHR0aGlzLnRyaWdnZXIoJ2NoYW5nZWQnLCB7ICdhY3Rpb24nIDogJ3NlbGVjdF9ub2RlJywgJ25vZGUnIDogb2JqLCAnc2VsZWN0ZWQnIDogdGhpcy5fZGF0YS5jb3JlLnNlbGVjdGVkLCAnZXZlbnQnIDogZSB9KTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0LyoqXG5cdFx0ICogZGVzZWxlY3QgYSBub2RlXG5cdFx0ICogQG5hbWUgZGVzZWxlY3Rfbm9kZShvYmogWywgc3VwcmVzc19ldmVudF0pXG5cdFx0ICogQHBhcmFtIHttaXhlZH0gb2JqIGFuIGFycmF5IGNhbiBiZSB1c2VkIHRvIGRlc2VsZWN0IG11bHRpcGxlIG5vZGVzXG5cdFx0ICogQHBhcmFtIHtCb29sZWFufSBzdXByZXNzX2V2ZW50IGlmIHNldCB0byBgdHJ1ZWAgdGhlIGBjaGFuZ2VkLmpzdHJlZWAgZXZlbnQgd29uJ3QgYmUgdHJpZ2dlcmVkXG5cdFx0ICogQHRyaWdnZXIgZGVzZWxlY3Rfbm9kZS5qc3RyZWUsIGNoYW5nZWQuanN0cmVlXG5cdFx0ICovXG5cdFx0ZGVzZWxlY3Rfbm9kZSA6IGZ1bmN0aW9uIChvYmosIHN1cHJlc3NfZXZlbnQsIGUpIHtcblx0XHRcdHZhciB0MSwgdDIsIGRvbTtcblx0XHRcdGlmKCQuaXNBcnJheShvYmopKSB7XG5cdFx0XHRcdG9iaiA9IG9iai5zbGljZSgpO1xuXHRcdFx0XHRmb3IodDEgPSAwLCB0MiA9IG9iai5sZW5ndGg7IHQxIDwgdDI7IHQxKyspIHtcblx0XHRcdFx0XHR0aGlzLmRlc2VsZWN0X25vZGUob2JqW3QxXSwgc3VwcmVzc19ldmVudCwgZSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9XG5cdFx0XHRvYmogPSB0aGlzLmdldF9ub2RlKG9iaik7XG5cdFx0XHRpZighb2JqIHx8IG9iai5pZCA9PT0gJC5qc3RyZWUucm9vdCkge1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cdFx0XHRkb20gPSB0aGlzLmdldF9ub2RlKG9iaiwgdHJ1ZSk7XG5cdFx0XHRpZihvYmouc3RhdGUuc2VsZWN0ZWQpIHtcblx0XHRcdFx0b2JqLnN0YXRlLnNlbGVjdGVkID0gZmFsc2U7XG5cdFx0XHRcdHRoaXMuX2RhdGEuY29yZS5zZWxlY3RlZCA9ICQudmFrYXRhLmFycmF5X3JlbW92ZV9pdGVtKHRoaXMuX2RhdGEuY29yZS5zZWxlY3RlZCwgb2JqLmlkKTtcblx0XHRcdFx0aWYoZG9tLmxlbmd0aCkge1xuXHRcdFx0XHRcdGRvbS5hdHRyKCdhcmlhLXNlbGVjdGVkJywgZmFsc2UpLmNoaWxkcmVuKCcuanN0cmVlLWFuY2hvcicpLnJlbW92ZUNsYXNzKCdqc3RyZWUtY2xpY2tlZCcpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdC8qKlxuXHRcdFx0XHQgKiB0cmlnZ2VyZWQgd2hlbiBhbiBub2RlIGlzIGRlc2VsZWN0ZWRcblx0XHRcdFx0ICogQGV2ZW50XG5cdFx0XHRcdCAqIEBuYW1lIGRlc2VsZWN0X25vZGUuanN0cmVlXG5cdFx0XHRcdCAqIEBwYXJhbSB7T2JqZWN0fSBub2RlXG5cdFx0XHRcdCAqIEBwYXJhbSB7QXJyYXl9IHNlbGVjdGVkIHRoZSBjdXJyZW50IHNlbGVjdGlvblxuXHRcdFx0XHQgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgdGhlIGV2ZW50IChpZiBhbnkpIHRoYXQgdHJpZ2dlcmVkIHRoaXMgZGVzZWxlY3Rfbm9kZVxuXHRcdFx0XHQgKi9cblx0XHRcdFx0dGhpcy50cmlnZ2VyKCdkZXNlbGVjdF9ub2RlJywgeyAnbm9kZScgOiBvYmosICdzZWxlY3RlZCcgOiB0aGlzLl9kYXRhLmNvcmUuc2VsZWN0ZWQsICdldmVudCcgOiBlIH0pO1xuXHRcdFx0XHRpZighc3VwcmVzc19ldmVudCkge1xuXHRcdFx0XHRcdHRoaXMudHJpZ2dlcignY2hhbmdlZCcsIHsgJ2FjdGlvbicgOiAnZGVzZWxlY3Rfbm9kZScsICdub2RlJyA6IG9iaiwgJ3NlbGVjdGVkJyA6IHRoaXMuX2RhdGEuY29yZS5zZWxlY3RlZCwgJ2V2ZW50JyA6IGUgfSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9LFxuXHRcdC8qKlxuXHRcdCAqIHNlbGVjdCBhbGwgbm9kZXMgaW4gdGhlIHRyZWVcblx0XHQgKiBAbmFtZSBzZWxlY3RfYWxsKFtzdXByZXNzX2V2ZW50XSlcblx0XHQgKiBAcGFyYW0ge0Jvb2xlYW59IHN1cHJlc3NfZXZlbnQgaWYgc2V0IHRvIGB0cnVlYCB0aGUgYGNoYW5nZWQuanN0cmVlYCBldmVudCB3b24ndCBiZSB0cmlnZ2VyZWRcblx0XHQgKiBAdHJpZ2dlciBzZWxlY3RfYWxsLmpzdHJlZSwgY2hhbmdlZC5qc3RyZWVcblx0XHQgKi9cblx0XHRzZWxlY3RfYWxsIDogZnVuY3Rpb24gKHN1cHJlc3NfZXZlbnQpIHtcblx0XHRcdHZhciB0bXAgPSB0aGlzLl9kYXRhLmNvcmUuc2VsZWN0ZWQuY29uY2F0KFtdKSwgaSwgajtcblx0XHRcdHRoaXMuX2RhdGEuY29yZS5zZWxlY3RlZCA9IHRoaXMuX21vZGVsLmRhdGFbJC5qc3RyZWUucm9vdF0uY2hpbGRyZW5fZC5jb25jYXQoKTtcblx0XHRcdGZvcihpID0gMCwgaiA9IHRoaXMuX2RhdGEuY29yZS5zZWxlY3RlZC5sZW5ndGg7IGkgPCBqOyBpKyspIHtcblx0XHRcdFx0aWYodGhpcy5fbW9kZWwuZGF0YVt0aGlzLl9kYXRhLmNvcmUuc2VsZWN0ZWRbaV1dKSB7XG5cdFx0XHRcdFx0dGhpcy5fbW9kZWwuZGF0YVt0aGlzLl9kYXRhLmNvcmUuc2VsZWN0ZWRbaV1dLnN0YXRlLnNlbGVjdGVkID0gdHJ1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0dGhpcy5yZWRyYXcodHJ1ZSk7XG5cdFx0XHQvKipcblx0XHRcdCAqIHRyaWdnZXJlZCB3aGVuIGFsbCBub2RlcyBhcmUgc2VsZWN0ZWRcblx0XHRcdCAqIEBldmVudFxuXHRcdFx0ICogQG5hbWUgc2VsZWN0X2FsbC5qc3RyZWVcblx0XHRcdCAqIEBwYXJhbSB7QXJyYXl9IHNlbGVjdGVkIHRoZSBjdXJyZW50IHNlbGVjdGlvblxuXHRcdFx0ICovXG5cdFx0XHR0aGlzLnRyaWdnZXIoJ3NlbGVjdF9hbGwnLCB7ICdzZWxlY3RlZCcgOiB0aGlzLl9kYXRhLmNvcmUuc2VsZWN0ZWQgfSk7XG5cdFx0XHRpZighc3VwcmVzc19ldmVudCkge1xuXHRcdFx0XHR0aGlzLnRyaWdnZXIoJ2NoYW5nZWQnLCB7ICdhY3Rpb24nIDogJ3NlbGVjdF9hbGwnLCAnc2VsZWN0ZWQnIDogdGhpcy5fZGF0YS5jb3JlLnNlbGVjdGVkLCAnb2xkX3NlbGVjdGlvbicgOiB0bXAgfSk7XG5cdFx0XHR9XG5cdFx0fSxcblx0XHQvKipcblx0XHQgKiBkZXNlbGVjdCBhbGwgc2VsZWN0ZWQgbm9kZXNcblx0XHQgKiBAbmFtZSBkZXNlbGVjdF9hbGwoW3N1cHJlc3NfZXZlbnRdKVxuXHRcdCAqIEBwYXJhbSB7Qm9vbGVhbn0gc3VwcmVzc19ldmVudCBpZiBzZXQgdG8gYHRydWVgIHRoZSBgY2hhbmdlZC5qc3RyZWVgIGV2ZW50IHdvbid0IGJlIHRyaWdnZXJlZFxuXHRcdCAqIEB0cmlnZ2VyIGRlc2VsZWN0X2FsbC5qc3RyZWUsIGNoYW5nZWQuanN0cmVlXG5cdFx0ICovXG5cdFx0ZGVzZWxlY3RfYWxsIDogZnVuY3Rpb24gKHN1cHJlc3NfZXZlbnQpIHtcblx0XHRcdHZhciB0bXAgPSB0aGlzLl9kYXRhLmNvcmUuc2VsZWN0ZWQuY29uY2F0KFtdKSwgaSwgajtcblx0XHRcdGZvcihpID0gMCwgaiA9IHRoaXMuX2RhdGEuY29yZS5zZWxlY3RlZC5sZW5ndGg7IGkgPCBqOyBpKyspIHtcblx0XHRcdFx0aWYodGhpcy5fbW9kZWwuZGF0YVt0aGlzLl9kYXRhLmNvcmUuc2VsZWN0ZWRbaV1dKSB7XG5cdFx0XHRcdFx0dGhpcy5fbW9kZWwuZGF0YVt0aGlzLl9kYXRhLmNvcmUuc2VsZWN0ZWRbaV1dLnN0YXRlLnNlbGVjdGVkID0gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHRoaXMuX2RhdGEuY29yZS5zZWxlY3RlZCA9IFtdO1xuXHRcdFx0dGhpcy5lbGVtZW50LmZpbmQoJy5qc3RyZWUtY2xpY2tlZCcpLnJlbW92ZUNsYXNzKCdqc3RyZWUtY2xpY2tlZCcpLnBhcmVudCgpLmF0dHIoJ2FyaWEtc2VsZWN0ZWQnLCBmYWxzZSk7XG5cdFx0XHQvKipcblx0XHRcdCAqIHRyaWdnZXJlZCB3aGVuIGFsbCBub2RlcyBhcmUgZGVzZWxlY3RlZFxuXHRcdFx0ICogQGV2ZW50XG5cdFx0XHQgKiBAbmFtZSBkZXNlbGVjdF9hbGwuanN0cmVlXG5cdFx0XHQgKiBAcGFyYW0ge09iamVjdH0gbm9kZSB0aGUgcHJldmlvdXMgc2VsZWN0aW9uXG5cdFx0XHQgKiBAcGFyYW0ge0FycmF5fSBzZWxlY3RlZCB0aGUgY3VycmVudCBzZWxlY3Rpb25cblx0XHRcdCAqL1xuXHRcdFx0dGhpcy50cmlnZ2VyKCdkZXNlbGVjdF9hbGwnLCB7ICdzZWxlY3RlZCcgOiB0aGlzLl9kYXRhLmNvcmUuc2VsZWN0ZWQsICdub2RlJyA6IHRtcCB9KTtcblx0XHRcdGlmKCFzdXByZXNzX2V2ZW50KSB7XG5cdFx0XHRcdHRoaXMudHJpZ2dlcignY2hhbmdlZCcsIHsgJ2FjdGlvbicgOiAnZGVzZWxlY3RfYWxsJywgJ3NlbGVjdGVkJyA6IHRoaXMuX2RhdGEuY29yZS5zZWxlY3RlZCwgJ29sZF9zZWxlY3Rpb24nIDogdG1wIH0pO1xuXHRcdFx0fVxuXHRcdH0sXG5cdFx0LyoqXG5cdFx0ICogY2hlY2tzIGlmIGEgbm9kZSBpcyBzZWxlY3RlZFxuXHRcdCAqIEBuYW1lIGlzX3NlbGVjdGVkKG9iailcblx0XHQgKiBAcGFyYW0gIHttaXhlZH0gIG9ialxuXHRcdCAqIEByZXR1cm4ge0Jvb2xlYW59XG5cdFx0ICovXG5cdFx0aXNfc2VsZWN0ZWQgOiBmdW5jdGlvbiAob2JqKSB7XG5cdFx0XHRvYmogPSB0aGlzLmdldF9ub2RlKG9iaik7XG5cdFx0XHRpZighb2JqIHx8IG9iai5pZCA9PT0gJC5qc3RyZWUucm9vdCkge1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gb2JqLnN0YXRlLnNlbGVjdGVkO1xuXHRcdH0sXG5cdFx0LyoqXG5cdFx0ICogZ2V0IGFuIGFycmF5IG9mIGFsbCBzZWxlY3RlZCBub2Rlc1xuXHRcdCAqIEBuYW1lIGdldF9zZWxlY3RlZChbZnVsbF0pXG5cdFx0ICogQHBhcmFtICB7bWl4ZWR9ICBmdWxsIGlmIHNldCB0byBgdHJ1ZWAgdGhlIHJldHVybmVkIGFycmF5IHdpbGwgY29uc2lzdCBvZiB0aGUgZnVsbCBub2RlIG9iamVjdHMsIG90aGVyd2lzZSAtIG9ubHkgSURzIHdpbGwgYmUgcmV0dXJuZWRcblx0XHQgKiBAcmV0dXJuIHtBcnJheX1cblx0XHQgKi9cblx0XHRnZXRfc2VsZWN0ZWQgOiBmdW5jdGlvbiAoZnVsbCkge1xuXHRcdFx0cmV0dXJuIGZ1bGwgPyAkLm1hcCh0aGlzLl9kYXRhLmNvcmUuc2VsZWN0ZWQsICQucHJveHkoZnVuY3Rpb24gKGkpIHsgcmV0dXJuIHRoaXMuZ2V0X25vZGUoaSk7IH0sIHRoaXMpKSA6IHRoaXMuX2RhdGEuY29yZS5zZWxlY3RlZC5zbGljZSgpO1xuXHRcdH0sXG5cdFx0LyoqXG5cdFx0ICogZ2V0IGFuIGFycmF5IG9mIGFsbCB0b3AgbGV2ZWwgc2VsZWN0ZWQgbm9kZXMgKGlnbm9yaW5nIGNoaWxkcmVuIG9mIHNlbGVjdGVkIG5vZGVzKVxuXHRcdCAqIEBuYW1lIGdldF90b3Bfc2VsZWN0ZWQoW2Z1bGxdKVxuXHRcdCAqIEBwYXJhbSAge21peGVkfSAgZnVsbCBpZiBzZXQgdG8gYHRydWVgIHRoZSByZXR1cm5lZCBhcnJheSB3aWxsIGNvbnNpc3Qgb2YgdGhlIGZ1bGwgbm9kZSBvYmplY3RzLCBvdGhlcndpc2UgLSBvbmx5IElEcyB3aWxsIGJlIHJldHVybmVkXG5cdFx0ICogQHJldHVybiB7QXJyYXl9XG5cdFx0ICovXG5cdFx0Z2V0X3RvcF9zZWxlY3RlZCA6IGZ1bmN0aW9uIChmdWxsKSB7XG5cdFx0XHR2YXIgdG1wID0gdGhpcy5nZXRfc2VsZWN0ZWQodHJ1ZSksXG5cdFx0XHRcdG9iaiA9IHt9LCBpLCBqLCBrLCBsO1xuXHRcdFx0Zm9yKGkgPSAwLCBqID0gdG1wLmxlbmd0aDsgaSA8IGo7IGkrKykge1xuXHRcdFx0XHRvYmpbdG1wW2ldLmlkXSA9IHRtcFtpXTtcblx0XHRcdH1cblx0XHRcdGZvcihpID0gMCwgaiA9IHRtcC5sZW5ndGg7IGkgPCBqOyBpKyspIHtcblx0XHRcdFx0Zm9yKGsgPSAwLCBsID0gdG1wW2ldLmNoaWxkcmVuX2QubGVuZ3RoOyBrIDwgbDsgaysrKSB7XG5cdFx0XHRcdFx0aWYob2JqW3RtcFtpXS5jaGlsZHJlbl9kW2tdXSkge1xuXHRcdFx0XHRcdFx0ZGVsZXRlIG9ialt0bXBbaV0uY2hpbGRyZW5fZFtrXV07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHR0bXAgPSBbXTtcblx0XHRcdGZvcihpIGluIG9iaikge1xuXHRcdFx0XHRpZihvYmouaGFzT3duUHJvcGVydHkoaSkpIHtcblx0XHRcdFx0XHR0bXAucHVzaChpKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGZ1bGwgPyAkLm1hcCh0bXAsICQucHJveHkoZnVuY3Rpb24gKGkpIHsgcmV0dXJuIHRoaXMuZ2V0X25vZGUoaSk7IH0sIHRoaXMpKSA6IHRtcDtcblx0XHR9LFxuXHRcdC8qKlxuXHRcdCAqIGdldCBhbiBhcnJheSBvZiBhbGwgYm90dG9tIGxldmVsIHNlbGVjdGVkIG5vZGVzIChpZ25vcmluZyBzZWxlY3RlZCBwYXJlbnRzKVxuXHRcdCAqIEBuYW1lIGdldF9ib3R0b21fc2VsZWN0ZWQoW2Z1bGxdKVxuXHRcdCAqIEBwYXJhbSAge21peGVkfSAgZnVsbCBpZiBzZXQgdG8gYHRydWVgIHRoZSByZXR1cm5lZCBhcnJheSB3aWxsIGNvbnNpc3Qgb2YgdGhlIGZ1bGwgbm9kZSBvYmplY3RzLCBvdGhlcndpc2UgLSBvbmx5IElEcyB3aWxsIGJlIHJldHVybmVkXG5cdFx0ICogQHJldHVybiB7QXJyYXl9XG5cdFx0ICovXG5cdFx0Z2V0X2JvdHRvbV9zZWxlY3RlZCA6IGZ1bmN0aW9uIChmdWxsKSB7XG5cdFx0XHR2YXIgdG1wID0gdGhpcy5nZXRfc2VsZWN0ZWQodHJ1ZSksXG5cdFx0XHRcdG9iaiA9IFtdLCBpLCBqO1xuXHRcdFx0Zm9yKGkgPSAwLCBqID0gdG1wLmxlbmd0aDsgaSA8IGo7IGkrKykge1xuXHRcdFx0XHRpZighdG1wW2ldLmNoaWxkcmVuLmxlbmd0aCkge1xuXHRcdFx0XHRcdG9iai5wdXNoKHRtcFtpXS5pZCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiBmdWxsID8gJC5tYXAob2JqLCAkLnByb3h5KGZ1bmN0aW9uIChpKSB7IHJldHVybiB0aGlzLmdldF9ub2RlKGkpOyB9LCB0aGlzKSkgOiBvYmo7XG5cdFx0fSxcblx0XHQvKipcblx0XHQgKiBnZXRzIHRoZSBjdXJyZW50IHN0YXRlIG9mIHRoZSB0cmVlIHNvIHRoYXQgaXQgY2FuIGJlIHJlc3RvcmVkIGxhdGVyIHdpdGggYHNldF9zdGF0ZShzdGF0ZSlgLiBVc2VkIGludGVybmFsbHkuXG5cdFx0ICogQG5hbWUgZ2V0X3N0YXRlKClcblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqIEByZXR1cm4ge09iamVjdH1cblx0XHQgKi9cblx0XHRnZXRfc3RhdGUgOiBmdW5jdGlvbiAoKSB7XG5cdFx0XHR2YXIgc3RhdGVcdD0ge1xuXHRcdFx0XHQnY29yZScgOiB7XG5cdFx0XHRcdFx0J29wZW4nIDogW10sXG5cdFx0XHRcdFx0J3Njcm9sbCcgOiB7XG5cdFx0XHRcdFx0XHQnbGVmdCcgOiB0aGlzLmVsZW1lbnQuc2Nyb2xsTGVmdCgpLFxuXHRcdFx0XHRcdFx0J3RvcCcgOiB0aGlzLmVsZW1lbnQuc2Nyb2xsVG9wKClcblx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdC8qIVxuXHRcdFx0XHRcdCd0aGVtZXMnIDoge1xuXHRcdFx0XHRcdFx0J25hbWUnIDogdGhpcy5nZXRfdGhlbWUoKSxcblx0XHRcdFx0XHRcdCdpY29ucycgOiB0aGlzLl9kYXRhLmNvcmUudGhlbWVzLmljb25zLFxuXHRcdFx0XHRcdFx0J2RvdHMnIDogdGhpcy5fZGF0YS5jb3JlLnRoZW1lcy5kb3RzXG5cdFx0XHRcdFx0fSxcblx0XHRcdFx0XHQqL1xuXHRcdFx0XHRcdCdzZWxlY3RlZCcgOiBbXVxuXHRcdFx0XHR9XG5cdFx0XHR9LCBpO1xuXHRcdFx0Zm9yKGkgaW4gdGhpcy5fbW9kZWwuZGF0YSkge1xuXHRcdFx0XHRpZih0aGlzLl9tb2RlbC5kYXRhLmhhc093blByb3BlcnR5KGkpKSB7XG5cdFx0XHRcdFx0aWYoaSAhPT0gJC5qc3RyZWUucm9vdCkge1xuXHRcdFx0XHRcdFx0aWYodGhpcy5fbW9kZWwuZGF0YVtpXS5zdGF0ZS5vcGVuZWQpIHtcblx0XHRcdFx0XHRcdFx0c3RhdGUuY29yZS5vcGVuLnB1c2goaSk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRpZih0aGlzLl9tb2RlbC5kYXRhW2ldLnN0YXRlLnNlbGVjdGVkKSB7XG5cdFx0XHRcdFx0XHRcdHN0YXRlLmNvcmUuc2VsZWN0ZWQucHVzaChpKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiBzdGF0ZTtcblx0XHR9LFxuXHRcdC8qKlxuXHRcdCAqIHNldHMgdGhlIHN0YXRlIG9mIHRoZSB0cmVlLiBVc2VkIGludGVybmFsbHkuXG5cdFx0ICogQG5hbWUgc2V0X3N0YXRlKHN0YXRlIFssIGNhbGxiYWNrXSlcblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqIEBwYXJhbSB7T2JqZWN0fSBzdGF0ZSB0aGUgc3RhdGUgdG8gcmVzdG9yZS4gS2VlcCBpbiBtaW5kIHRoaXMgb2JqZWN0IGlzIHBhc3NlZCBieSByZWZlcmVuY2UgYW5kIGpzdHJlZSB3aWxsIG1vZGlmeSBpdC5cblx0XHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBhbiBvcHRpb25hbCBmdW5jdGlvbiB0byBleGVjdXRlIG9uY2UgdGhlIHN0YXRlIGlzIHJlc3RvcmVkLlxuXHRcdCAqIEB0cmlnZ2VyIHNldF9zdGF0ZS5qc3RyZWVcblx0XHQgKi9cblx0XHRzZXRfc3RhdGUgOiBmdW5jdGlvbiAoc3RhdGUsIGNhbGxiYWNrKSB7XG5cdFx0XHRpZihzdGF0ZSkge1xuXHRcdFx0XHRpZihzdGF0ZS5jb3JlKSB7XG5cdFx0XHRcdFx0dmFyIHJlcywgbiwgdCwgX3RoaXMsIGk7XG5cdFx0XHRcdFx0aWYoc3RhdGUuY29yZS5vcGVuKSB7XG5cdFx0XHRcdFx0XHRpZighJC5pc0FycmF5KHN0YXRlLmNvcmUub3BlbikgfHwgIXN0YXRlLmNvcmUub3Blbi5sZW5ndGgpIHtcblx0XHRcdFx0XHRcdFx0ZGVsZXRlIHN0YXRlLmNvcmUub3Blbjtcblx0XHRcdFx0XHRcdFx0dGhpcy5zZXRfc3RhdGUoc3RhdGUsIGNhbGxiYWNrKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdFx0XHR0aGlzLl9sb2FkX25vZGVzKHN0YXRlLmNvcmUub3BlbiwgZnVuY3Rpb24gKG5vZGVzKSB7XG5cdFx0XHRcdFx0XHRcdFx0dGhpcy5vcGVuX25vZGUobm9kZXMsIGZhbHNlLCAwKTtcblx0XHRcdFx0XHRcdFx0XHRkZWxldGUgc3RhdGUuY29yZS5vcGVuO1xuXHRcdFx0XHRcdFx0XHRcdHRoaXMuc2V0X3N0YXRlKHN0YXRlLCBjYWxsYmFjayk7XG5cdFx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZihzdGF0ZS5jb3JlLnNjcm9sbCkge1xuXHRcdFx0XHRcdFx0aWYoc3RhdGUuY29yZS5zY3JvbGwgJiYgc3RhdGUuY29yZS5zY3JvbGwubGVmdCAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdFx0XHRcdHRoaXMuZWxlbWVudC5zY3JvbGxMZWZ0KHN0YXRlLmNvcmUuc2Nyb2xsLmxlZnQpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0aWYoc3RhdGUuY29yZS5zY3JvbGwgJiYgc3RhdGUuY29yZS5zY3JvbGwudG9wICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHRcdFx0dGhpcy5lbGVtZW50LnNjcm9sbFRvcChzdGF0ZS5jb3JlLnNjcm9sbC50b3ApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0ZGVsZXRlIHN0YXRlLmNvcmUuc2Nyb2xsO1xuXHRcdFx0XHRcdFx0dGhpcy5zZXRfc3RhdGUoc3RhdGUsIGNhbGxiYWNrKTtcblx0XHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYoc3RhdGUuY29yZS5zZWxlY3RlZCkge1xuXHRcdFx0XHRcdFx0X3RoaXMgPSB0aGlzO1xuXHRcdFx0XHRcdFx0dGhpcy5kZXNlbGVjdF9hbGwoKTtcblx0XHRcdFx0XHRcdCQuZWFjaChzdGF0ZS5jb3JlLnNlbGVjdGVkLCBmdW5jdGlvbiAoaSwgdikge1xuXHRcdFx0XHRcdFx0XHRfdGhpcy5zZWxlY3Rfbm9kZSh2LCBmYWxzZSwgdHJ1ZSk7XG5cdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRcdGRlbGV0ZSBzdGF0ZS5jb3JlLnNlbGVjdGVkO1xuXHRcdFx0XHRcdFx0dGhpcy5zZXRfc3RhdGUoc3RhdGUsIGNhbGxiYWNrKTtcblx0XHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0Zm9yKGkgaW4gc3RhdGUpIHtcblx0XHRcdFx0XHRcdGlmKHN0YXRlLmhhc093blByb3BlcnR5KGkpICYmIGkgIT09IFwiY29yZVwiICYmICQuaW5BcnJheShpLCB0aGlzLnNldHRpbmdzLnBsdWdpbnMpID09PSAtMSkge1xuXHRcdFx0XHRcdFx0XHRkZWxldGUgc3RhdGVbaV07XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmKCQuaXNFbXB0eU9iamVjdChzdGF0ZS5jb3JlKSkge1xuXHRcdFx0XHRcdFx0ZGVsZXRlIHN0YXRlLmNvcmU7XG5cdFx0XHRcdFx0XHR0aGlzLnNldF9zdGF0ZShzdGF0ZSwgY2FsbGJhY2spO1xuXHRcdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRpZigkLmlzRW1wdHlPYmplY3Qoc3RhdGUpKSB7XG5cdFx0XHRcdFx0c3RhdGUgPSBudWxsO1xuXHRcdFx0XHRcdGlmKGNhbGxiYWNrKSB7IGNhbGxiYWNrLmNhbGwodGhpcyk7IH1cblx0XHRcdFx0XHQvKipcblx0XHRcdFx0XHQgKiB0cmlnZ2VyZWQgd2hlbiBhIGBzZXRfc3RhdGVgIGNhbGwgY29tcGxldGVzXG5cdFx0XHRcdFx0ICogQGV2ZW50XG5cdFx0XHRcdFx0ICogQG5hbWUgc2V0X3N0YXRlLmpzdHJlZVxuXHRcdFx0XHRcdCAqL1xuXHRcdFx0XHRcdHRoaXMudHJpZ2dlcignc2V0X3N0YXRlJyk7XG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH0sXG5cdFx0LyoqXG5cdFx0ICogcmVmcmVzaGVzIHRoZSB0cmVlIC0gYWxsIG5vZGVzIGFyZSByZWxvYWRlZCB3aXRoIGNhbGxzIHRvIGBsb2FkX25vZGVgLlxuXHRcdCAqIEBuYW1lIHJlZnJlc2goKVxuXHRcdCAqIEBwYXJhbSB7Qm9vbGVhbn0gc2tpcF9sb2FkaW5nIGFuIG9wdGlvbiB0byBza2lwIHNob3dpbmcgdGhlIGxvYWRpbmcgaW5kaWNhdG9yXG5cdFx0ICogQHBhcmFtIHtNaXhlZH0gZm9yZ2V0X3N0YXRlIGlmIHNldCB0byBgdHJ1ZWAgc3RhdGUgd2lsbCBub3QgYmUgcmVhcHBsaWVkLCBpZiBzZXQgdG8gYSBmdW5jdGlvbiAocmVjZWl2aW5nIHRoZSBjdXJyZW50IHN0YXRlIGFzIGFyZ3VtZW50KSB0aGUgcmVzdWx0IG9mIHRoYXQgZnVuY3Rpb24gd2lsbCBiZSB1c2VkIGFzIHN0YXRlXG5cdFx0ICogQHRyaWdnZXIgcmVmcmVzaC5qc3RyZWVcblx0XHQgKi9cblx0XHRyZWZyZXNoIDogZnVuY3Rpb24gKHNraXBfbG9hZGluZywgZm9yZ2V0X3N0YXRlKSB7XG5cdFx0XHR0aGlzLl9kYXRhLmNvcmUuc3RhdGUgPSBmb3JnZXRfc3RhdGUgPT09IHRydWUgPyB7fSA6IHRoaXMuZ2V0X3N0YXRlKCk7XG5cdFx0XHRpZihmb3JnZXRfc3RhdGUgJiYgJC5pc0Z1bmN0aW9uKGZvcmdldF9zdGF0ZSkpIHsgdGhpcy5fZGF0YS5jb3JlLnN0YXRlID0gZm9yZ2V0X3N0YXRlLmNhbGwodGhpcywgdGhpcy5fZGF0YS5jb3JlLnN0YXRlKTsgfVxuXHRcdFx0dGhpcy5fY250ID0gMDtcblx0XHRcdHRoaXMuX21vZGVsLmRhdGEgPSB7fTtcblx0XHRcdHRoaXMuX21vZGVsLmRhdGFbJC5qc3RyZWUucm9vdF0gPSB7XG5cdFx0XHRcdGlkIDogJC5qc3RyZWUucm9vdCxcblx0XHRcdFx0cGFyZW50IDogbnVsbCxcblx0XHRcdFx0cGFyZW50cyA6IFtdLFxuXHRcdFx0XHRjaGlsZHJlbiA6IFtdLFxuXHRcdFx0XHRjaGlsZHJlbl9kIDogW10sXG5cdFx0XHRcdHN0YXRlIDogeyBsb2FkZWQgOiBmYWxzZSB9XG5cdFx0XHR9O1xuXHRcdFx0dGhpcy5fZGF0YS5jb3JlLnNlbGVjdGVkID0gW107XG5cdFx0XHR0aGlzLl9kYXRhLmNvcmUubGFzdF9jbGlja2VkID0gbnVsbDtcblx0XHRcdHRoaXMuX2RhdGEuY29yZS5mb2N1c2VkID0gbnVsbDtcblxuXHRcdFx0dmFyIGMgPSB0aGlzLmdldF9jb250YWluZXJfdWwoKVswXS5jbGFzc05hbWU7XG5cdFx0XHRpZighc2tpcF9sb2FkaW5nKSB7XG5cdFx0XHRcdHRoaXMuZWxlbWVudC5odG1sKFwiPFwiK1widWwgY2xhc3M9J1wiK2MrXCInIHJvbGU9J2dyb3VwJz48XCIrXCJsaSBjbGFzcz0nanN0cmVlLWluaXRpYWwtbm9kZSBqc3RyZWUtbG9hZGluZyBqc3RyZWUtbGVhZiBqc3RyZWUtbGFzdCcgcm9sZT0ndHJlZWl0ZW0nIGlkPSdqXCIrdGhpcy5faWQrXCJfbG9hZGluZyc+PGkgY2xhc3M9J2pzdHJlZS1pY29uIGpzdHJlZS1vY2wnPjwvaT48XCIrXCJhIGNsYXNzPSdqc3RyZWUtYW5jaG9yJyBocmVmPScjJz48aSBjbGFzcz0nanN0cmVlLWljb24ganN0cmVlLXRoZW1laWNvbi1oaWRkZW4nPjwvaT5cIiArIHRoaXMuZ2V0X3N0cmluZyhcIkxvYWRpbmcgLi4uXCIpICsgXCI8L2E+PC9saT48L3VsPlwiKTtcblx0XHRcdFx0dGhpcy5lbGVtZW50LmF0dHIoJ2FyaWEtYWN0aXZlZGVzY2VuZGFudCcsJ2onK3RoaXMuX2lkKydfbG9hZGluZycpO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5sb2FkX25vZGUoJC5qc3RyZWUucm9vdCwgZnVuY3Rpb24gKG8sIHMpIHtcblx0XHRcdFx0aWYocykge1xuXHRcdFx0XHRcdHRoaXMuZ2V0X2NvbnRhaW5lcl91bCgpWzBdLmNsYXNzTmFtZSA9IGM7XG5cdFx0XHRcdFx0aWYodGhpcy5fZmlyc3RDaGlsZCh0aGlzLmdldF9jb250YWluZXJfdWwoKVswXSkpIHtcblx0XHRcdFx0XHRcdHRoaXMuZWxlbWVudC5hdHRyKCdhcmlhLWFjdGl2ZWRlc2NlbmRhbnQnLHRoaXMuX2ZpcnN0Q2hpbGQodGhpcy5nZXRfY29udGFpbmVyX3VsKClbMF0pLmlkKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0dGhpcy5zZXRfc3RhdGUoJC5leHRlbmQodHJ1ZSwge30sIHRoaXMuX2RhdGEuY29yZS5zdGF0ZSksIGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0XHRcdC8qKlxuXHRcdFx0XHRcdFx0ICogdHJpZ2dlcmVkIHdoZW4gYSBgcmVmcmVzaGAgY2FsbCBjb21wbGV0ZXNcblx0XHRcdFx0XHRcdCAqIEBldmVudFxuXHRcdFx0XHRcdFx0ICogQG5hbWUgcmVmcmVzaC5qc3RyZWVcblx0XHRcdFx0XHRcdCAqL1xuXHRcdFx0XHRcdFx0dGhpcy50cmlnZ2VyKCdyZWZyZXNoJyk7XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0dGhpcy5fZGF0YS5jb3JlLnN0YXRlID0gbnVsbDtcblx0XHRcdH0pO1xuXHRcdH0sXG5cdFx0LyoqXG5cdFx0ICogcmVmcmVzaGVzIGEgbm9kZSBpbiB0aGUgdHJlZSAocmVsb2FkIGl0cyBjaGlsZHJlbikgYWxsIG9wZW5lZCBub2RlcyBpbnNpZGUgdGhhdCBub2RlIGFyZSByZWxvYWRlZCB3aXRoIGNhbGxzIHRvIGBsb2FkX25vZGVgLlxuXHRcdCAqIEBuYW1lIHJlZnJlc2hfbm9kZShvYmopXG5cdFx0ICogQHBhcmFtICB7bWl4ZWR9IG9iaiB0aGUgbm9kZVxuXHRcdCAqIEB0cmlnZ2VyIHJlZnJlc2hfbm9kZS5qc3RyZWVcblx0XHQgKi9cblx0XHRyZWZyZXNoX25vZGUgOiBmdW5jdGlvbiAob2JqKSB7XG5cdFx0XHRvYmogPSB0aGlzLmdldF9ub2RlKG9iaik7XG5cdFx0XHRpZighb2JqIHx8IG9iai5pZCA9PT0gJC5qc3RyZWUucm9vdCkgeyByZXR1cm4gZmFsc2U7IH1cblx0XHRcdHZhciBvcGVuZWQgPSBbXSwgdG9fbG9hZCA9IFtdLCBzID0gdGhpcy5fZGF0YS5jb3JlLnNlbGVjdGVkLmNvbmNhdChbXSk7XG5cdFx0XHR0b19sb2FkLnB1c2gob2JqLmlkKTtcblx0XHRcdGlmKG9iai5zdGF0ZS5vcGVuZWQgPT09IHRydWUpIHsgb3BlbmVkLnB1c2gob2JqLmlkKTsgfVxuXHRcdFx0dGhpcy5nZXRfbm9kZShvYmosIHRydWUpLmZpbmQoJy5qc3RyZWUtb3BlbicpLmVhY2goZnVuY3Rpb24oKSB7IHRvX2xvYWQucHVzaCh0aGlzLmlkKTsgb3BlbmVkLnB1c2godGhpcy5pZCk7IH0pO1xuXHRcdFx0dGhpcy5fbG9hZF9ub2Rlcyh0b19sb2FkLCAkLnByb3h5KGZ1bmN0aW9uIChub2Rlcykge1xuXHRcdFx0XHR0aGlzLm9wZW5fbm9kZShvcGVuZWQsIGZhbHNlLCAwKTtcblx0XHRcdFx0dGhpcy5zZWxlY3Rfbm9kZShzKTtcblx0XHRcdFx0LyoqXG5cdFx0XHRcdCAqIHRyaWdnZXJlZCB3aGVuIGEgbm9kZSBpcyByZWZyZXNoZWRcblx0XHRcdFx0ICogQGV2ZW50XG5cdFx0XHRcdCAqIEBuYW1lIHJlZnJlc2hfbm9kZS5qc3RyZWVcblx0XHRcdFx0ICogQHBhcmFtIHtPYmplY3R9IG5vZGUgLSB0aGUgcmVmcmVzaGVkIG5vZGVcblx0XHRcdFx0ICogQHBhcmFtIHtBcnJheX0gbm9kZXMgLSBhbiBhcnJheSBvZiB0aGUgSURzIG9mIHRoZSBub2RlcyB0aGF0IHdlcmUgcmVsb2FkZWRcblx0XHRcdFx0ICovXG5cdFx0XHRcdHRoaXMudHJpZ2dlcigncmVmcmVzaF9ub2RlJywgeyAnbm9kZScgOiBvYmosICdub2RlcycgOiBub2RlcyB9KTtcblx0XHRcdH0sIHRoaXMpLCBmYWxzZSwgdHJ1ZSk7XG5cdFx0fSxcblx0XHQvKipcblx0XHQgKiBzZXQgKGNoYW5nZSkgdGhlIElEIG9mIGEgbm9kZVxuXHRcdCAqIEBuYW1lIHNldF9pZChvYmosIGlkKVxuXHRcdCAqIEBwYXJhbSAge21peGVkfSBvYmogdGhlIG5vZGVcblx0XHQgKiBAcGFyYW0gIHtTdHJpbmd9IGlkIHRoZSBuZXcgSURcblx0XHQgKiBAcmV0dXJuIHtCb29sZWFufVxuXHRcdCAqIEB0cmlnZ2VyIHNldF9pZC5qc3RyZWVcblx0XHQgKi9cblx0XHRzZXRfaWQgOiBmdW5jdGlvbiAob2JqLCBpZCkge1xuXHRcdFx0b2JqID0gdGhpcy5nZXRfbm9kZShvYmopO1xuXHRcdFx0aWYoIW9iaiB8fCBvYmouaWQgPT09ICQuanN0cmVlLnJvb3QpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdFx0XHR2YXIgaSwgaiwgbSA9IHRoaXMuX21vZGVsLmRhdGEsIG9sZCA9IG9iai5pZDtcblx0XHRcdGlkID0gaWQudG9TdHJpbmcoKTtcblx0XHRcdC8vIHVwZGF0ZSBwYXJlbnRzIChyZXBsYWNlIGN1cnJlbnQgSUQgd2l0aCBuZXcgb25lIGluIGNoaWxkcmVuIGFuZCBjaGlsZHJlbl9kKVxuXHRcdFx0bVtvYmoucGFyZW50XS5jaGlsZHJlblskLmluQXJyYXkob2JqLmlkLCBtW29iai5wYXJlbnRdLmNoaWxkcmVuKV0gPSBpZDtcblx0XHRcdGZvcihpID0gMCwgaiA9IG9iai5wYXJlbnRzLmxlbmd0aDsgaSA8IGo7IGkrKykge1xuXHRcdFx0XHRtW29iai5wYXJlbnRzW2ldXS5jaGlsZHJlbl9kWyQuaW5BcnJheShvYmouaWQsIG1bb2JqLnBhcmVudHNbaV1dLmNoaWxkcmVuX2QpXSA9IGlkO1xuXHRcdFx0fVxuXHRcdFx0Ly8gdXBkYXRlIGNoaWxkcmVuIChyZXBsYWNlIGN1cnJlbnQgSUQgd2l0aCBuZXcgb25lIGluIHBhcmVudCBhbmQgcGFyZW50cylcblx0XHRcdGZvcihpID0gMCwgaiA9IG9iai5jaGlsZHJlbi5sZW5ndGg7IGkgPCBqOyBpKyspIHtcblx0XHRcdFx0bVtvYmouY2hpbGRyZW5baV1dLnBhcmVudCA9IGlkO1xuXHRcdFx0fVxuXHRcdFx0Zm9yKGkgPSAwLCBqID0gb2JqLmNoaWxkcmVuX2QubGVuZ3RoOyBpIDwgajsgaSsrKSB7XG5cdFx0XHRcdG1bb2JqLmNoaWxkcmVuX2RbaV1dLnBhcmVudHNbJC5pbkFycmF5KG9iai5pZCwgbVtvYmouY2hpbGRyZW5fZFtpXV0ucGFyZW50cyldID0gaWQ7XG5cdFx0XHR9XG5cdFx0XHRpID0gJC5pbkFycmF5KG9iai5pZCwgdGhpcy5fZGF0YS5jb3JlLnNlbGVjdGVkKTtcblx0XHRcdGlmKGkgIT09IC0xKSB7IHRoaXMuX2RhdGEuY29yZS5zZWxlY3RlZFtpXSA9IGlkOyB9XG5cdFx0XHQvLyB1cGRhdGUgbW9kZWwgYW5kIG9iaiBpdHNlbGYgKG9iai5pZCwgdGhpcy5fbW9kZWwuZGF0YVtLRVldKVxuXHRcdFx0aSA9IHRoaXMuZ2V0X25vZGUob2JqLmlkLCB0cnVlKTtcblx0XHRcdGlmKGkpIHtcblx0XHRcdFx0aS5hdHRyKCdpZCcsIGlkKTsgLy8uY2hpbGRyZW4oJy5qc3RyZWUtYW5jaG9yJykuYXR0cignaWQnLCBpZCArICdfYW5jaG9yJykuZW5kKCkuYXR0cignYXJpYS1sYWJlbGxlZGJ5JywgaWQgKyAnX2FuY2hvcicpO1xuXHRcdFx0XHRpZih0aGlzLmVsZW1lbnQuYXR0cignYXJpYS1hY3RpdmVkZXNjZW5kYW50JykgPT09IG9iai5pZCkge1xuXHRcdFx0XHRcdHRoaXMuZWxlbWVudC5hdHRyKCdhcmlhLWFjdGl2ZWRlc2NlbmRhbnQnLCBpZCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGRlbGV0ZSBtW29iai5pZF07XG5cdFx0XHRvYmouaWQgPSBpZDtcblx0XHRcdG9iai5saV9hdHRyLmlkID0gaWQ7XG5cdFx0XHRtW2lkXSA9IG9iajtcblx0XHRcdC8qKlxuXHRcdFx0ICogdHJpZ2dlcmVkIHdoZW4gYSBub2RlIGlkIHZhbHVlIGlzIGNoYW5nZWRcblx0XHRcdCAqIEBldmVudFxuXHRcdFx0ICogQG5hbWUgc2V0X2lkLmpzdHJlZVxuXHRcdFx0ICogQHBhcmFtIHtPYmplY3R9IG5vZGVcblx0XHRcdCAqIEBwYXJhbSB7U3RyaW5nfSBvbGQgdGhlIG9sZCBpZFxuXHRcdFx0ICovXG5cdFx0XHR0aGlzLnRyaWdnZXIoJ3NldF9pZCcseyBcIm5vZGVcIiA6IG9iaiwgXCJuZXdcIiA6IG9iai5pZCwgXCJvbGRcIiA6IG9sZCB9KTtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH0sXG5cdFx0LyoqXG5cdFx0ICogZ2V0IHRoZSB0ZXh0IHZhbHVlIG9mIGEgbm9kZVxuXHRcdCAqIEBuYW1lIGdldF90ZXh0KG9iailcblx0XHQgKiBAcGFyYW0gIHttaXhlZH0gb2JqIHRoZSBub2RlXG5cdFx0ICogQHJldHVybiB7U3RyaW5nfVxuXHRcdCAqL1xuXHRcdGdldF90ZXh0IDogZnVuY3Rpb24gKG9iaikge1xuXHRcdFx0b2JqID0gdGhpcy5nZXRfbm9kZShvYmopO1xuXHRcdFx0cmV0dXJuICghb2JqIHx8IG9iai5pZCA9PT0gJC5qc3RyZWUucm9vdCkgPyBmYWxzZSA6IG9iai50ZXh0O1xuXHRcdH0sXG5cdFx0LyoqXG5cdFx0ICogc2V0IHRoZSB0ZXh0IHZhbHVlIG9mIGEgbm9kZS4gVXNlZCBpbnRlcm5hbGx5LCBwbGVhc2UgdXNlIGByZW5hbWVfbm9kZShvYmosIHZhbClgLlxuXHRcdCAqIEBwcml2YXRlXG5cdFx0ICogQG5hbWUgc2V0X3RleHQob2JqLCB2YWwpXG5cdFx0ICogQHBhcmFtICB7bWl4ZWR9IG9iaiB0aGUgbm9kZSwgeW91IGNhbiBwYXNzIGFuIGFycmF5IHRvIHNldCB0aGUgdGV4dCBvbiBtdWx0aXBsZSBub2Rlc1xuXHRcdCAqIEBwYXJhbSAge1N0cmluZ30gdmFsIHRoZSBuZXcgdGV4dCB2YWx1ZVxuXHRcdCAqIEByZXR1cm4ge0Jvb2xlYW59XG5cdFx0ICogQHRyaWdnZXIgc2V0X3RleHQuanN0cmVlXG5cdFx0ICovXG5cdFx0c2V0X3RleHQgOiBmdW5jdGlvbiAob2JqLCB2YWwpIHtcblx0XHRcdHZhciB0MSwgdDI7XG5cdFx0XHRpZigkLmlzQXJyYXkob2JqKSkge1xuXHRcdFx0XHRvYmogPSBvYmouc2xpY2UoKTtcblx0XHRcdFx0Zm9yKHQxID0gMCwgdDIgPSBvYmoubGVuZ3RoOyB0MSA8IHQyOyB0MSsrKSB7XG5cdFx0XHRcdFx0dGhpcy5zZXRfdGV4dChvYmpbdDFdLCB2YWwpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fVxuXHRcdFx0b2JqID0gdGhpcy5nZXRfbm9kZShvYmopO1xuXHRcdFx0aWYoIW9iaiB8fCBvYmouaWQgPT09ICQuanN0cmVlLnJvb3QpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdFx0XHRvYmoudGV4dCA9IHZhbDtcblx0XHRcdGlmKHRoaXMuZ2V0X25vZGUob2JqLCB0cnVlKS5sZW5ndGgpIHtcblx0XHRcdFx0dGhpcy5yZWRyYXdfbm9kZShvYmouaWQpO1xuXHRcdFx0fVxuXHRcdFx0LyoqXG5cdFx0XHQgKiB0cmlnZ2VyZWQgd2hlbiBhIG5vZGUgdGV4dCB2YWx1ZSBpcyBjaGFuZ2VkXG5cdFx0XHQgKiBAZXZlbnRcblx0XHRcdCAqIEBuYW1lIHNldF90ZXh0LmpzdHJlZVxuXHRcdFx0ICogQHBhcmFtIHtPYmplY3R9IG9ialxuXHRcdFx0ICogQHBhcmFtIHtTdHJpbmd9IHRleHQgdGhlIG5ldyB2YWx1ZVxuXHRcdFx0ICovXG5cdFx0XHR0aGlzLnRyaWdnZXIoJ3NldF90ZXh0Jyx7IFwib2JqXCIgOiBvYmosIFwidGV4dFwiIDogdmFsIH0pO1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fSxcblx0XHQvKipcblx0XHQgKiBnZXRzIGEgSlNPTiByZXByZXNlbnRhdGlvbiBvZiBhIG5vZGUgKG9yIHRoZSB3aG9sZSB0cmVlKVxuXHRcdCAqIEBuYW1lIGdldF9qc29uKFtvYmosIG9wdGlvbnNdKVxuXHRcdCAqIEBwYXJhbSAge21peGVkfSBvYmpcblx0XHQgKiBAcGFyYW0gIHtPYmplY3R9IG9wdGlvbnNcblx0XHQgKiBAcGFyYW0gIHtCb29sZWFufSBvcHRpb25zLm5vX3N0YXRlIGRvIG5vdCByZXR1cm4gc3RhdGUgaW5mb3JtYXRpb25cblx0XHQgKiBAcGFyYW0gIHtCb29sZWFufSBvcHRpb25zLm5vX2lkIGRvIG5vdCByZXR1cm4gSURcblx0XHQgKiBAcGFyYW0gIHtCb29sZWFufSBvcHRpb25zLm5vX2NoaWxkcmVuIGRvIG5vdCBpbmNsdWRlIGNoaWxkcmVuXG5cdFx0ICogQHBhcmFtICB7Qm9vbGVhbn0gb3B0aW9ucy5ub19kYXRhIGRvIG5vdCBpbmNsdWRlIG5vZGUgZGF0YVxuXHRcdCAqIEBwYXJhbSAge0Jvb2xlYW59IG9wdGlvbnMubm9fbGlfYXR0ciBkbyBub3QgaW5jbHVkZSBMSSBhdHRyaWJ1dGVzXG5cdFx0ICogQHBhcmFtICB7Qm9vbGVhbn0gb3B0aW9ucy5ub19hX2F0dHIgZG8gbm90IGluY2x1ZGUgQSBhdHRyaWJ1dGVzXG5cdFx0ICogQHBhcmFtICB7Qm9vbGVhbn0gb3B0aW9ucy5mbGF0IHJldHVybiBmbGF0IEpTT04gaW5zdGVhZCBvZiBuZXN0ZWRcblx0XHQgKiBAcmV0dXJuIHtPYmplY3R9XG5cdFx0ICovXG5cdFx0Z2V0X2pzb24gOiBmdW5jdGlvbiAob2JqLCBvcHRpb25zLCBmbGF0KSB7XG5cdFx0XHRvYmogPSB0aGlzLmdldF9ub2RlKG9iaiB8fCAkLmpzdHJlZS5yb290KTtcblx0XHRcdGlmKCFvYmopIHsgcmV0dXJuIGZhbHNlOyB9XG5cdFx0XHRpZihvcHRpb25zICYmIG9wdGlvbnMuZmxhdCAmJiAhZmxhdCkgeyBmbGF0ID0gW107IH1cblx0XHRcdHZhciB0bXAgPSB7XG5cdFx0XHRcdCdpZCcgOiBvYmouaWQsXG5cdFx0XHRcdCd0ZXh0JyA6IG9iai50ZXh0LFxuXHRcdFx0XHQnaWNvbicgOiB0aGlzLmdldF9pY29uKG9iaiksXG5cdFx0XHRcdCdsaV9hdHRyJyA6ICQuZXh0ZW5kKHRydWUsIHt9LCBvYmoubGlfYXR0ciksXG5cdFx0XHRcdCdhX2F0dHInIDogJC5leHRlbmQodHJ1ZSwge30sIG9iai5hX2F0dHIpLFxuXHRcdFx0XHQnc3RhdGUnIDoge30sXG5cdFx0XHRcdCdkYXRhJyA6IG9wdGlvbnMgJiYgb3B0aW9ucy5ub19kYXRhID8gZmFsc2UgOiAkLmV4dGVuZCh0cnVlLCB7fSwgb2JqLmRhdGEpXG5cdFx0XHRcdC8vKCB0aGlzLmdldF9ub2RlKG9iaiwgdHJ1ZSkubGVuZ3RoID8gdGhpcy5nZXRfbm9kZShvYmosIHRydWUpLmRhdGEoKSA6IG9iai5kYXRhICksXG5cdFx0XHR9LCBpLCBqO1xuXHRcdFx0aWYob3B0aW9ucyAmJiBvcHRpb25zLmZsYXQpIHtcblx0XHRcdFx0dG1wLnBhcmVudCA9IG9iai5wYXJlbnQ7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIHtcblx0XHRcdFx0dG1wLmNoaWxkcmVuID0gW107XG5cdFx0XHR9XG5cdFx0XHRpZighb3B0aW9ucyB8fCAhb3B0aW9ucy5ub19zdGF0ZSkge1xuXHRcdFx0XHRmb3IoaSBpbiBvYmouc3RhdGUpIHtcblx0XHRcdFx0XHRpZihvYmouc3RhdGUuaGFzT3duUHJvcGVydHkoaSkpIHtcblx0XHRcdFx0XHRcdHRtcC5zdGF0ZVtpXSA9IG9iai5zdGF0ZVtpXTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGRlbGV0ZSB0bXAuc3RhdGU7XG5cdFx0XHR9XG5cdFx0XHRpZihvcHRpb25zICYmIG9wdGlvbnMubm9fbGlfYXR0cikge1xuXHRcdFx0XHRkZWxldGUgdG1wLmxpX2F0dHI7XG5cdFx0XHR9XG5cdFx0XHRpZihvcHRpb25zICYmIG9wdGlvbnMubm9fYV9hdHRyKSB7XG5cdFx0XHRcdGRlbGV0ZSB0bXAuYV9hdHRyO1xuXHRcdFx0fVxuXHRcdFx0aWYob3B0aW9ucyAmJiBvcHRpb25zLm5vX2lkKSB7XG5cdFx0XHRcdGRlbGV0ZSB0bXAuaWQ7XG5cdFx0XHRcdGlmKHRtcC5saV9hdHRyICYmIHRtcC5saV9hdHRyLmlkKSB7XG5cdFx0XHRcdFx0ZGVsZXRlIHRtcC5saV9hdHRyLmlkO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmKHRtcC5hX2F0dHIgJiYgdG1wLmFfYXR0ci5pZCkge1xuXHRcdFx0XHRcdGRlbGV0ZSB0bXAuYV9hdHRyLmlkO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRpZihvcHRpb25zICYmIG9wdGlvbnMuZmxhdCAmJiBvYmouaWQgIT09ICQuanN0cmVlLnJvb3QpIHtcblx0XHRcdFx0ZmxhdC5wdXNoKHRtcCk7XG5cdFx0XHR9XG5cdFx0XHRpZighb3B0aW9ucyB8fCAhb3B0aW9ucy5ub19jaGlsZHJlbikge1xuXHRcdFx0XHRmb3IoaSA9IDAsIGogPSBvYmouY2hpbGRyZW4ubGVuZ3RoOyBpIDwgajsgaSsrKSB7XG5cdFx0XHRcdFx0aWYob3B0aW9ucyAmJiBvcHRpb25zLmZsYXQpIHtcblx0XHRcdFx0XHRcdHRoaXMuZ2V0X2pzb24ob2JqLmNoaWxkcmVuW2ldLCBvcHRpb25zLCBmbGF0KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0XHR0bXAuY2hpbGRyZW4ucHVzaCh0aGlzLmdldF9qc29uKG9iai5jaGlsZHJlbltpXSwgb3B0aW9ucykpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG9wdGlvbnMgJiYgb3B0aW9ucy5mbGF0ID8gZmxhdCA6IChvYmouaWQgPT09ICQuanN0cmVlLnJvb3QgPyB0bXAuY2hpbGRyZW4gOiB0bXApO1xuXHRcdH0sXG5cdFx0LyoqXG5cdFx0ICogY3JlYXRlIGEgbmV3IG5vZGUgKGRvIG5vdCBjb25mdXNlIHdpdGggbG9hZF9ub2RlKVxuXHRcdCAqIEBuYW1lIGNyZWF0ZV9ub2RlKFtwYXIsIG5vZGUsIHBvcywgY2FsbGJhY2ssIGlzX2xvYWRlZF0pXG5cdFx0ICogQHBhcmFtICB7bWl4ZWR9ICAgcGFyICAgICAgIHRoZSBwYXJlbnQgbm9kZSAodG8gY3JlYXRlIGEgcm9vdCBub2RlIHVzZSBlaXRoZXIgXCIjXCIgKHN0cmluZykgb3IgYG51bGxgKVxuXHRcdCAqIEBwYXJhbSAge21peGVkfSAgIG5vZGUgICAgICB0aGUgZGF0YSBmb3IgdGhlIG5ldyBub2RlIChhIHZhbGlkIEpTT04gb2JqZWN0LCBvciBhIHNpbXBsZSBzdHJpbmcgd2l0aCB0aGUgbmFtZSlcblx0XHQgKiBAcGFyYW0gIHttaXhlZH0gICBwb3MgICAgICAgdGhlIGluZGV4IGF0IHdoaWNoIHRvIGluc2VydCB0aGUgbm9kZSwgXCJmaXJzdFwiIGFuZCBcImxhc3RcIiBhcmUgYWxzbyBzdXBwb3J0ZWQsIGRlZmF1bHQgaXMgXCJsYXN0XCJcblx0XHQgKiBAcGFyYW0gIHtGdW5jdGlvbn0gY2FsbGJhY2sgYSBmdW5jdGlvbiB0byBiZSBjYWxsZWQgb25jZSB0aGUgbm9kZSBpcyBjcmVhdGVkXG5cdFx0ICogQHBhcmFtICB7Qm9vbGVhbn0gaXNfbG9hZGVkIGludGVybmFsIGFyZ3VtZW50IGluZGljYXRpbmcgaWYgdGhlIHBhcmVudCBub2RlIHdhcyBzdWNjZXNmdWxseSBsb2FkZWRcblx0XHQgKiBAcmV0dXJuIHtTdHJpbmd9ICAgICAgICAgICAgdGhlIElEIG9mIHRoZSBuZXdseSBjcmVhdGUgbm9kZVxuXHRcdCAqIEB0cmlnZ2VyIG1vZGVsLmpzdHJlZSwgY3JlYXRlX25vZGUuanN0cmVlXG5cdFx0ICovXG5cdFx0Y3JlYXRlX25vZGUgOiBmdW5jdGlvbiAocGFyLCBub2RlLCBwb3MsIGNhbGxiYWNrLCBpc19sb2FkZWQpIHtcblx0XHRcdGlmKHBhciA9PT0gbnVsbCkgeyBwYXIgPSAkLmpzdHJlZS5yb290OyB9XG5cdFx0XHRwYXIgPSB0aGlzLmdldF9ub2RlKHBhcik7XG5cdFx0XHRpZighcGFyKSB7IHJldHVybiBmYWxzZTsgfVxuXHRcdFx0cG9zID0gcG9zID09PSB1bmRlZmluZWQgPyBcImxhc3RcIiA6IHBvcztcblx0XHRcdGlmKCFwb3MudG9TdHJpbmcoKS5tYXRjaCgvXihiZWZvcmV8YWZ0ZXIpJC8pICYmICFpc19sb2FkZWQgJiYgIXRoaXMuaXNfbG9hZGVkKHBhcikpIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMubG9hZF9ub2RlKHBhciwgZnVuY3Rpb24gKCkgeyB0aGlzLmNyZWF0ZV9ub2RlKHBhciwgbm9kZSwgcG9zLCBjYWxsYmFjaywgdHJ1ZSk7IH0pO1xuXHRcdFx0fVxuXHRcdFx0aWYoIW5vZGUpIHsgbm9kZSA9IHsgXCJ0ZXh0XCIgOiB0aGlzLmdldF9zdHJpbmcoJ05ldyBub2RlJykgfTsgfVxuXHRcdFx0aWYodHlwZW9mIG5vZGUgPT09IFwic3RyaW5nXCIpIHsgbm9kZSA9IHsgXCJ0ZXh0XCIgOiBub2RlIH07IH1cblx0XHRcdGlmKG5vZGUudGV4dCA9PT0gdW5kZWZpbmVkKSB7IG5vZGUudGV4dCA9IHRoaXMuZ2V0X3N0cmluZygnTmV3IG5vZGUnKTsgfVxuXHRcdFx0dmFyIHRtcCwgZHBjLCBpLCBqO1xuXG5cdFx0XHRpZihwYXIuaWQgPT09ICQuanN0cmVlLnJvb3QpIHtcblx0XHRcdFx0aWYocG9zID09PSBcImJlZm9yZVwiKSB7IHBvcyA9IFwiZmlyc3RcIjsgfVxuXHRcdFx0XHRpZihwb3MgPT09IFwiYWZ0ZXJcIikgeyBwb3MgPSBcImxhc3RcIjsgfVxuXHRcdFx0fVxuXHRcdFx0c3dpdGNoKHBvcykge1xuXHRcdFx0XHRjYXNlIFwiYmVmb3JlXCI6XG5cdFx0XHRcdFx0dG1wID0gdGhpcy5nZXRfbm9kZShwYXIucGFyZW50KTtcblx0XHRcdFx0XHRwb3MgPSAkLmluQXJyYXkocGFyLmlkLCB0bXAuY2hpbGRyZW4pO1xuXHRcdFx0XHRcdHBhciA9IHRtcDtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0Y2FzZSBcImFmdGVyXCIgOlxuXHRcdFx0XHRcdHRtcCA9IHRoaXMuZ2V0X25vZGUocGFyLnBhcmVudCk7XG5cdFx0XHRcdFx0cG9zID0gJC5pbkFycmF5KHBhci5pZCwgdG1wLmNoaWxkcmVuKSArIDE7XG5cdFx0XHRcdFx0cGFyID0gdG1wO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRjYXNlIFwiaW5zaWRlXCI6XG5cdFx0XHRcdGNhc2UgXCJmaXJzdFwiOlxuXHRcdFx0XHRcdHBvcyA9IDA7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGNhc2UgXCJsYXN0XCI6XG5cdFx0XHRcdFx0cG9zID0gcGFyLmNoaWxkcmVuLmxlbmd0aDtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0XHRpZighcG9zKSB7IHBvcyA9IDA7IH1cblx0XHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHRcdGlmKHBvcyA+IHBhci5jaGlsZHJlbi5sZW5ndGgpIHsgcG9zID0gcGFyLmNoaWxkcmVuLmxlbmd0aDsgfVxuXHRcdFx0aWYoIW5vZGUuaWQpIHsgbm9kZS5pZCA9IHRydWU7IH1cblx0XHRcdGlmKCF0aGlzLmNoZWNrKFwiY3JlYXRlX25vZGVcIiwgbm9kZSwgcGFyLCBwb3MpKSB7XG5cdFx0XHRcdHRoaXMuc2V0dGluZ3MuY29yZS5lcnJvci5jYWxsKHRoaXMsIHRoaXMuX2RhdGEuY29yZS5sYXN0X2Vycm9yKTtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXHRcdFx0aWYobm9kZS5pZCA9PT0gdHJ1ZSkgeyBkZWxldGUgbm9kZS5pZDsgfVxuXHRcdFx0bm9kZSA9IHRoaXMuX3BhcnNlX21vZGVsX2Zyb21fanNvbihub2RlLCBwYXIuaWQsIHBhci5wYXJlbnRzLmNvbmNhdCgpKTtcblx0XHRcdGlmKCFub2RlKSB7IHJldHVybiBmYWxzZTsgfVxuXHRcdFx0dG1wID0gdGhpcy5nZXRfbm9kZShub2RlKTtcblx0XHRcdGRwYyA9IFtdO1xuXHRcdFx0ZHBjLnB1c2gobm9kZSk7XG5cdFx0XHRkcGMgPSBkcGMuY29uY2F0KHRtcC5jaGlsZHJlbl9kKTtcblx0XHRcdHRoaXMudHJpZ2dlcignbW9kZWwnLCB7IFwibm9kZXNcIiA6IGRwYywgXCJwYXJlbnRcIiA6IHBhci5pZCB9KTtcblxuXHRcdFx0cGFyLmNoaWxkcmVuX2QgPSBwYXIuY2hpbGRyZW5fZC5jb25jYXQoZHBjKTtcblx0XHRcdGZvcihpID0gMCwgaiA9IHBhci5wYXJlbnRzLmxlbmd0aDsgaSA8IGo7IGkrKykge1xuXHRcdFx0XHR0aGlzLl9tb2RlbC5kYXRhW3Bhci5wYXJlbnRzW2ldXS5jaGlsZHJlbl9kID0gdGhpcy5fbW9kZWwuZGF0YVtwYXIucGFyZW50c1tpXV0uY2hpbGRyZW5fZC5jb25jYXQoZHBjKTtcblx0XHRcdH1cblx0XHRcdG5vZGUgPSB0bXA7XG5cdFx0XHR0bXAgPSBbXTtcblx0XHRcdGZvcihpID0gMCwgaiA9IHBhci5jaGlsZHJlbi5sZW5ndGg7IGkgPCBqOyBpKyspIHtcblx0XHRcdFx0dG1wW2kgPj0gcG9zID8gaSsxIDogaV0gPSBwYXIuY2hpbGRyZW5baV07XG5cdFx0XHR9XG5cdFx0XHR0bXBbcG9zXSA9IG5vZGUuaWQ7XG5cdFx0XHRwYXIuY2hpbGRyZW4gPSB0bXA7XG5cblx0XHRcdHRoaXMucmVkcmF3X25vZGUocGFyLCB0cnVlKTtcblx0XHRcdGlmKGNhbGxiYWNrKSB7IGNhbGxiYWNrLmNhbGwodGhpcywgdGhpcy5nZXRfbm9kZShub2RlKSk7IH1cblx0XHRcdC8qKlxuXHRcdFx0ICogdHJpZ2dlcmVkIHdoZW4gYSBub2RlIGlzIGNyZWF0ZWRcblx0XHRcdCAqIEBldmVudFxuXHRcdFx0ICogQG5hbWUgY3JlYXRlX25vZGUuanN0cmVlXG5cdFx0XHQgKiBAcGFyYW0ge09iamVjdH0gbm9kZVxuXHRcdFx0ICogQHBhcmFtIHtTdHJpbmd9IHBhcmVudCB0aGUgcGFyZW50J3MgSURcblx0XHRcdCAqIEBwYXJhbSB7TnVtYmVyfSBwb3NpdGlvbiB0aGUgcG9zaXRpb24gb2YgdGhlIG5ldyBub2RlIGFtb25nIHRoZSBwYXJlbnQncyBjaGlsZHJlblxuXHRcdFx0ICovXG5cdFx0XHR0aGlzLnRyaWdnZXIoJ2NyZWF0ZV9ub2RlJywgeyBcIm5vZGVcIiA6IHRoaXMuZ2V0X25vZGUobm9kZSksIFwicGFyZW50XCIgOiBwYXIuaWQsIFwicG9zaXRpb25cIiA6IHBvcyB9KTtcblx0XHRcdHJldHVybiBub2RlLmlkO1xuXHRcdH0sXG5cdFx0LyoqXG5cdFx0ICogc2V0IHRoZSB0ZXh0IHZhbHVlIG9mIGEgbm9kZVxuXHRcdCAqIEBuYW1lIHJlbmFtZV9ub2RlKG9iaiwgdmFsKVxuXHRcdCAqIEBwYXJhbSAge21peGVkfSBvYmogdGhlIG5vZGUsIHlvdSBjYW4gcGFzcyBhbiBhcnJheSB0byByZW5hbWUgbXVsdGlwbGUgbm9kZXMgdG8gdGhlIHNhbWUgbmFtZVxuXHRcdCAqIEBwYXJhbSAge1N0cmluZ30gdmFsIHRoZSBuZXcgdGV4dCB2YWx1ZVxuXHRcdCAqIEByZXR1cm4ge0Jvb2xlYW59XG5cdFx0ICogQHRyaWdnZXIgcmVuYW1lX25vZGUuanN0cmVlXG5cdFx0ICovXG5cdFx0cmVuYW1lX25vZGUgOiBmdW5jdGlvbiAob2JqLCB2YWwpIHtcblx0XHRcdHZhciB0MSwgdDIsIG9sZDtcblx0XHRcdGlmKCQuaXNBcnJheShvYmopKSB7XG5cdFx0XHRcdG9iaiA9IG9iai5zbGljZSgpO1xuXHRcdFx0XHRmb3IodDEgPSAwLCB0MiA9IG9iai5sZW5ndGg7IHQxIDwgdDI7IHQxKyspIHtcblx0XHRcdFx0XHR0aGlzLnJlbmFtZV9ub2RlKG9ialt0MV0sIHZhbCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9XG5cdFx0XHRvYmogPSB0aGlzLmdldF9ub2RlKG9iaik7XG5cdFx0XHRpZighb2JqIHx8IG9iai5pZCA9PT0gJC5qc3RyZWUucm9vdCkgeyByZXR1cm4gZmFsc2U7IH1cblx0XHRcdG9sZCA9IG9iai50ZXh0O1xuXHRcdFx0aWYoIXRoaXMuY2hlY2soXCJyZW5hbWVfbm9kZVwiLCBvYmosIHRoaXMuZ2V0X3BhcmVudChvYmopLCB2YWwpKSB7XG5cdFx0XHRcdHRoaXMuc2V0dGluZ3MuY29yZS5lcnJvci5jYWxsKHRoaXMsIHRoaXMuX2RhdGEuY29yZS5sYXN0X2Vycm9yKTtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5zZXRfdGV4dChvYmosIHZhbCk7IC8vIC5hcHBseSh0aGlzLCBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpKVxuXHRcdFx0LyoqXG5cdFx0XHQgKiB0cmlnZ2VyZWQgd2hlbiBhIG5vZGUgaXMgcmVuYW1lZFxuXHRcdFx0ICogQGV2ZW50XG5cdFx0XHQgKiBAbmFtZSByZW5hbWVfbm9kZS5qc3RyZWVcblx0XHRcdCAqIEBwYXJhbSB7T2JqZWN0fSBub2RlXG5cdFx0XHQgKiBAcGFyYW0ge1N0cmluZ30gdGV4dCB0aGUgbmV3IHZhbHVlXG5cdFx0XHQgKiBAcGFyYW0ge1N0cmluZ30gb2xkIHRoZSBvbGQgdmFsdWVcblx0XHRcdCAqL1xuXHRcdFx0dGhpcy50cmlnZ2VyKCdyZW5hbWVfbm9kZScsIHsgXCJub2RlXCIgOiBvYmosIFwidGV4dFwiIDogdmFsLCBcIm9sZFwiIDogb2xkIH0pO1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fSxcblx0XHQvKipcblx0XHQgKiByZW1vdmUgYSBub2RlXG5cdFx0ICogQG5hbWUgZGVsZXRlX25vZGUob2JqKVxuXHRcdCAqIEBwYXJhbSAge21peGVkfSBvYmogdGhlIG5vZGUsIHlvdSBjYW4gcGFzcyBhbiBhcnJheSB0byBkZWxldGUgbXVsdGlwbGUgbm9kZXNcblx0XHQgKiBAcmV0dXJuIHtCb29sZWFufVxuXHRcdCAqIEB0cmlnZ2VyIGRlbGV0ZV9ub2RlLmpzdHJlZSwgY2hhbmdlZC5qc3RyZWVcblx0XHQgKi9cblx0XHRkZWxldGVfbm9kZSA6IGZ1bmN0aW9uIChvYmopIHtcblx0XHRcdHZhciB0MSwgdDIsIHBhciwgcG9zLCB0bXAsIGksIGosIGssIGwsIGMsIHRvcCwgbGZ0O1xuXHRcdFx0aWYoJC5pc0FycmF5KG9iaikpIHtcblx0XHRcdFx0b2JqID0gb2JqLnNsaWNlKCk7XG5cdFx0XHRcdGZvcih0MSA9IDAsIHQyID0gb2JqLmxlbmd0aDsgdDEgPCB0MjsgdDErKykge1xuXHRcdFx0XHRcdHRoaXMuZGVsZXRlX25vZGUob2JqW3QxXSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9XG5cdFx0XHRvYmogPSB0aGlzLmdldF9ub2RlKG9iaik7XG5cdFx0XHRpZighb2JqIHx8IG9iai5pZCA9PT0gJC5qc3RyZWUucm9vdCkgeyByZXR1cm4gZmFsc2U7IH1cblx0XHRcdHBhciA9IHRoaXMuZ2V0X25vZGUob2JqLnBhcmVudCk7XG5cdFx0XHRwb3MgPSAkLmluQXJyYXkob2JqLmlkLCBwYXIuY2hpbGRyZW4pO1xuXHRcdFx0YyA9IGZhbHNlO1xuXHRcdFx0aWYoIXRoaXMuY2hlY2soXCJkZWxldGVfbm9kZVwiLCBvYmosIHBhciwgcG9zKSkge1xuXHRcdFx0XHR0aGlzLnNldHRpbmdzLmNvcmUuZXJyb3IuY2FsbCh0aGlzLCB0aGlzLl9kYXRhLmNvcmUubGFzdF9lcnJvcik7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblx0XHRcdGlmKHBvcyAhPT0gLTEpIHtcblx0XHRcdFx0cGFyLmNoaWxkcmVuID0gJC52YWthdGEuYXJyYXlfcmVtb3ZlKHBhci5jaGlsZHJlbiwgcG9zKTtcblx0XHRcdH1cblx0XHRcdHRtcCA9IG9iai5jaGlsZHJlbl9kLmNvbmNhdChbXSk7XG5cdFx0XHR0bXAucHVzaChvYmouaWQpO1xuXHRcdFx0Zm9yKGkgPSAwLCBqID0gb2JqLnBhcmVudHMubGVuZ3RoOyBpIDwgajsgaSsrKSB7XG5cdFx0XHRcdHRoaXMuX21vZGVsLmRhdGFbb2JqLnBhcmVudHNbaV1dLmNoaWxkcmVuX2QgPSAkLnZha2F0YS5hcnJheV9maWx0ZXIodGhpcy5fbW9kZWwuZGF0YVtvYmoucGFyZW50c1tpXV0uY2hpbGRyZW5fZCwgZnVuY3Rpb24gKHYpIHtcblx0XHRcdFx0XHRyZXR1cm4gJC5pbkFycmF5KHYsIHRtcCkgPT09IC0xO1xuXHRcdFx0XHR9KTtcblx0XHRcdH1cblx0XHRcdGZvcihrID0gMCwgbCA9IHRtcC5sZW5ndGg7IGsgPCBsOyBrKyspIHtcblx0XHRcdFx0aWYodGhpcy5fbW9kZWwuZGF0YVt0bXBba11dLnN0YXRlLnNlbGVjdGVkKSB7XG5cdFx0XHRcdFx0YyA9IHRydWU7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGlmIChjKSB7XG5cdFx0XHRcdHRoaXMuX2RhdGEuY29yZS5zZWxlY3RlZCA9ICQudmFrYXRhLmFycmF5X2ZpbHRlcih0aGlzLl9kYXRhLmNvcmUuc2VsZWN0ZWQsIGZ1bmN0aW9uICh2KSB7XG5cdFx0XHRcdFx0cmV0dXJuICQuaW5BcnJheSh2LCB0bXApID09PSAtMTtcblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cdFx0XHQvKipcblx0XHRcdCAqIHRyaWdnZXJlZCB3aGVuIGEgbm9kZSBpcyBkZWxldGVkXG5cdFx0XHQgKiBAZXZlbnRcblx0XHRcdCAqIEBuYW1lIGRlbGV0ZV9ub2RlLmpzdHJlZVxuXHRcdFx0ICogQHBhcmFtIHtPYmplY3R9IG5vZGVcblx0XHRcdCAqIEBwYXJhbSB7U3RyaW5nfSBwYXJlbnQgdGhlIHBhcmVudCdzIElEXG5cdFx0XHQgKi9cblx0XHRcdHRoaXMudHJpZ2dlcignZGVsZXRlX25vZGUnLCB7IFwibm9kZVwiIDogb2JqLCBcInBhcmVudFwiIDogcGFyLmlkIH0pO1xuXHRcdFx0aWYoYykge1xuXHRcdFx0XHR0aGlzLnRyaWdnZXIoJ2NoYW5nZWQnLCB7ICdhY3Rpb24nIDogJ2RlbGV0ZV9ub2RlJywgJ25vZGUnIDogb2JqLCAnc2VsZWN0ZWQnIDogdGhpcy5fZGF0YS5jb3JlLnNlbGVjdGVkLCAncGFyZW50JyA6IHBhci5pZCB9KTtcblx0XHRcdH1cblx0XHRcdGZvcihrID0gMCwgbCA9IHRtcC5sZW5ndGg7IGsgPCBsOyBrKyspIHtcblx0XHRcdFx0ZGVsZXRlIHRoaXMuX21vZGVsLmRhdGFbdG1wW2tdXTtcblx0XHRcdH1cblx0XHRcdGlmKCQuaW5BcnJheSh0aGlzLl9kYXRhLmNvcmUuZm9jdXNlZCwgdG1wKSAhPT0gLTEpIHtcblx0XHRcdFx0dGhpcy5fZGF0YS5jb3JlLmZvY3VzZWQgPSBudWxsO1xuXHRcdFx0XHR0b3AgPSB0aGlzLmVsZW1lbnRbMF0uc2Nyb2xsVG9wO1xuXHRcdFx0XHRsZnQgPSB0aGlzLmVsZW1lbnRbMF0uc2Nyb2xsTGVmdDtcblx0XHRcdFx0aWYocGFyLmlkID09PSAkLmpzdHJlZS5yb290KSB7XG5cdFx0XHRcdFx0aWYgKHRoaXMuX21vZGVsLmRhdGFbJC5qc3RyZWUucm9vdF0uY2hpbGRyZW5bMF0pIHtcblx0XHRcdFx0XHRcdHRoaXMuZ2V0X25vZGUodGhpcy5fbW9kZWwuZGF0YVskLmpzdHJlZS5yb290XS5jaGlsZHJlblswXSwgdHJ1ZSkuY2hpbGRyZW4oJy5qc3RyZWUtYW5jaG9yJykuZm9jdXMoKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0dGhpcy5nZXRfbm9kZShwYXIsIHRydWUpLmNoaWxkcmVuKCcuanN0cmVlLWFuY2hvcicpLmZvY3VzKCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0dGhpcy5lbGVtZW50WzBdLnNjcm9sbFRvcCAgPSB0b3A7XG5cdFx0XHRcdHRoaXMuZWxlbWVudFswXS5zY3JvbGxMZWZ0ID0gbGZ0O1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5yZWRyYXdfbm9kZShwYXIsIHRydWUpO1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fSxcblx0XHQvKipcblx0XHQgKiBjaGVjayBpZiBhbiBvcGVyYXRpb24gaXMgcHJlbWl0dGVkIG9uIHRoZSB0cmVlLiBVc2VkIGludGVybmFsbHkuXG5cdFx0ICogQHByaXZhdGVcblx0XHQgKiBAbmFtZSBjaGVjayhjaGssIG9iaiwgcGFyLCBwb3MpXG5cdFx0ICogQHBhcmFtICB7U3RyaW5nfSBjaGsgdGhlIG9wZXJhdGlvbiB0byBjaGVjaywgY2FuIGJlIFwiY3JlYXRlX25vZGVcIiwgXCJyZW5hbWVfbm9kZVwiLCBcImRlbGV0ZV9ub2RlXCIsIFwiY29weV9ub2RlXCIgb3IgXCJtb3ZlX25vZGVcIlxuXHRcdCAqIEBwYXJhbSAge21peGVkfSBvYmogdGhlIG5vZGVcblx0XHQgKiBAcGFyYW0gIHttaXhlZH0gcGFyIHRoZSBwYXJlbnRcblx0XHQgKiBAcGFyYW0gIHttaXhlZH0gcG9zIHRoZSBwb3NpdGlvbiB0byBpbnNlcnQgYXQsIG9yIGlmIFwicmVuYW1lX25vZGVcIiAtIHRoZSBuZXcgbmFtZVxuXHRcdCAqIEBwYXJhbSAge21peGVkfSBtb3JlIHNvbWUgdmFyaW91cyBhZGRpdGlvbmFsIGluZm9ybWF0aW9uLCBmb3IgZXhhbXBsZSBpZiBhIFwibW92ZV9ub2RlXCIgb3BlcmF0aW9ucyBpcyB0cmlnZ2VyZWQgYnkgRE5EIHRoaXMgd2lsbCBiZSB0aGUgaG92ZXJlZCBub2RlXG5cdFx0ICogQHJldHVybiB7Qm9vbGVhbn1cblx0XHQgKi9cblx0XHRjaGVjayA6IGZ1bmN0aW9uIChjaGssIG9iaiwgcGFyLCBwb3MsIG1vcmUpIHtcblx0XHRcdG9iaiA9IG9iaiAmJiBvYmouaWQgPyBvYmogOiB0aGlzLmdldF9ub2RlKG9iaik7XG5cdFx0XHRwYXIgPSBwYXIgJiYgcGFyLmlkID8gcGFyIDogdGhpcy5nZXRfbm9kZShwYXIpO1xuXHRcdFx0dmFyIHRtcCA9IGNoay5tYXRjaCgvXm1vdmVfbm9kZXxjb3B5X25vZGV8Y3JlYXRlX25vZGUkL2kpID8gcGFyIDogb2JqLFxuXHRcdFx0XHRjaGMgPSB0aGlzLnNldHRpbmdzLmNvcmUuY2hlY2tfY2FsbGJhY2s7XG5cdFx0XHRpZihjaGsgPT09IFwibW92ZV9ub2RlXCIgfHwgY2hrID09PSBcImNvcHlfbm9kZVwiKSB7XG5cdFx0XHRcdGlmKCghbW9yZSB8fCAhbW9yZS5pc19tdWx0aSkgJiYgKG9iai5pZCA9PT0gcGFyLmlkIHx8IChjaGsgPT09IFwibW92ZV9ub2RlXCIgJiYgJC5pbkFycmF5KG9iai5pZCwgcGFyLmNoaWxkcmVuKSA9PT0gcG9zKSB8fCAkLmluQXJyYXkocGFyLmlkLCBvYmouY2hpbGRyZW5fZCkgIT09IC0xKSkge1xuXHRcdFx0XHRcdHRoaXMuX2RhdGEuY29yZS5sYXN0X2Vycm9yID0geyAnZXJyb3InIDogJ2NoZWNrJywgJ3BsdWdpbicgOiAnY29yZScsICdpZCcgOiAnY29yZV8wMScsICdyZWFzb24nIDogJ01vdmluZyBwYXJlbnQgaW5zaWRlIGNoaWxkJywgJ2RhdGEnIDogSlNPTi5zdHJpbmdpZnkoeyAnY2hrJyA6IGNoaywgJ3BvcycgOiBwb3MsICdvYmonIDogb2JqICYmIG9iai5pZCA/IG9iai5pZCA6IGZhbHNlLCAncGFyJyA6IHBhciAmJiBwYXIuaWQgPyBwYXIuaWQgOiBmYWxzZSB9KSB9O1xuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0aWYodG1wICYmIHRtcC5kYXRhKSB7IHRtcCA9IHRtcC5kYXRhOyB9XG5cdFx0XHRpZih0bXAgJiYgdG1wLmZ1bmN0aW9ucyAmJiAodG1wLmZ1bmN0aW9uc1tjaGtdID09PSBmYWxzZSB8fCB0bXAuZnVuY3Rpb25zW2Noa10gPT09IHRydWUpKSB7XG5cdFx0XHRcdGlmKHRtcC5mdW5jdGlvbnNbY2hrXSA9PT0gZmFsc2UpIHtcblx0XHRcdFx0XHR0aGlzLl9kYXRhLmNvcmUubGFzdF9lcnJvciA9IHsgJ2Vycm9yJyA6ICdjaGVjaycsICdwbHVnaW4nIDogJ2NvcmUnLCAnaWQnIDogJ2NvcmVfMDInLCAncmVhc29uJyA6ICdOb2RlIGRhdGEgcHJldmVudHMgZnVuY3Rpb246ICcgKyBjaGssICdkYXRhJyA6IEpTT04uc3RyaW5naWZ5KHsgJ2NoaycgOiBjaGssICdwb3MnIDogcG9zLCAnb2JqJyA6IG9iaiAmJiBvYmouaWQgPyBvYmouaWQgOiBmYWxzZSwgJ3BhcicgOiBwYXIgJiYgcGFyLmlkID8gcGFyLmlkIDogZmFsc2UgfSkgfTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdG1wLmZ1bmN0aW9uc1tjaGtdO1xuXHRcdFx0fVxuXHRcdFx0aWYoY2hjID09PSBmYWxzZSB8fCAoJC5pc0Z1bmN0aW9uKGNoYykgJiYgY2hjLmNhbGwodGhpcywgY2hrLCBvYmosIHBhciwgcG9zLCBtb3JlKSA9PT0gZmFsc2UpIHx8IChjaGMgJiYgY2hjW2Noa10gPT09IGZhbHNlKSkge1xuXHRcdFx0XHR0aGlzLl9kYXRhLmNvcmUubGFzdF9lcnJvciA9IHsgJ2Vycm9yJyA6ICdjaGVjaycsICdwbHVnaW4nIDogJ2NvcmUnLCAnaWQnIDogJ2NvcmVfMDMnLCAncmVhc29uJyA6ICdVc2VyIGNvbmZpZyBmb3IgY29yZS5jaGVja19jYWxsYmFjayBwcmV2ZW50cyBmdW5jdGlvbjogJyArIGNoaywgJ2RhdGEnIDogSlNPTi5zdHJpbmdpZnkoeyAnY2hrJyA6IGNoaywgJ3BvcycgOiBwb3MsICdvYmonIDogb2JqICYmIG9iai5pZCA/IG9iai5pZCA6IGZhbHNlLCAncGFyJyA6IHBhciAmJiBwYXIuaWQgPyBwYXIuaWQgOiBmYWxzZSB9KSB9O1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9LFxuXHRcdC8qKlxuXHRcdCAqIGdldCB0aGUgbGFzdCBlcnJvclxuXHRcdCAqIEBuYW1lIGxhc3RfZXJyb3IoKVxuXHRcdCAqIEByZXR1cm4ge09iamVjdH1cblx0XHQgKi9cblx0XHRsYXN0X2Vycm9yIDogZnVuY3Rpb24gKCkge1xuXHRcdFx0cmV0dXJuIHRoaXMuX2RhdGEuY29yZS5sYXN0X2Vycm9yO1xuXHRcdH0sXG5cdFx0LyoqXG5cdFx0ICogbW92ZSBhIG5vZGUgdG8gYSBuZXcgcGFyZW50XG5cdFx0ICogQG5hbWUgbW92ZV9ub2RlKG9iaiwgcGFyIFssIHBvcywgY2FsbGJhY2ssIGlzX2xvYWRlZF0pXG5cdFx0ICogQHBhcmFtICB7bWl4ZWR9IG9iaiB0aGUgbm9kZSB0byBtb3ZlLCBwYXNzIGFuIGFycmF5IHRvIG1vdmUgbXVsdGlwbGUgbm9kZXNcblx0XHQgKiBAcGFyYW0gIHttaXhlZH0gcGFyIHRoZSBuZXcgcGFyZW50XG5cdFx0ICogQHBhcmFtICB7bWl4ZWR9IHBvcyB0aGUgcG9zaXRpb24gdG8gaW5zZXJ0IGF0IChiZXNpZGVzIGludGVnZXIgdmFsdWVzLCBcImZpcnN0XCIgYW5kIFwibGFzdFwiIGFyZSBzdXBwb3J0ZWQsIGFzIHdlbGwgYXMgXCJiZWZvcmVcIiBhbmQgXCJhZnRlclwiKSwgZGVmYXVsdHMgdG8gaW50ZWdlciBgMGBcblx0XHQgKiBAcGFyYW0gIHtmdW5jdGlvbn0gY2FsbGJhY2sgYSBmdW5jdGlvbiB0byBjYWxsIG9uY2UgdGhlIG1vdmUgaXMgY29tcGxldGVkLCByZWNlaXZlcyAzIGFyZ3VtZW50cyAtIHRoZSBub2RlLCB0aGUgbmV3IHBhcmVudCBhbmQgdGhlIHBvc2l0aW9uXG5cdFx0ICogQHBhcmFtICB7Qm9vbGVhbn0gaXNfbG9hZGVkIGludGVybmFsIHBhcmFtZXRlciBpbmRpY2F0aW5nIGlmIHRoZSBwYXJlbnQgbm9kZSBoYXMgYmVlbiBsb2FkZWRcblx0XHQgKiBAcGFyYW0gIHtCb29sZWFufSBza2lwX3JlZHJhdyBpbnRlcm5hbCBwYXJhbWV0ZXIgaW5kaWNhdGluZyBpZiB0aGUgdHJlZSBzaG91bGQgYmUgcmVkcmF3blxuXHRcdCAqIEBwYXJhbSAge0Jvb2xlYW59IGluc3RhbmNlIGludGVybmFsIHBhcmFtZXRlciBpbmRpY2F0aW5nIGlmIHRoZSBub2RlIGNvbWVzIGZyb20gYW5vdGhlciBpbnN0YW5jZVxuXHRcdCAqIEB0cmlnZ2VyIG1vdmVfbm9kZS5qc3RyZWVcblx0XHQgKi9cblx0XHRtb3ZlX25vZGUgOiBmdW5jdGlvbiAob2JqLCBwYXIsIHBvcywgY2FsbGJhY2ssIGlzX2xvYWRlZCwgc2tpcF9yZWRyYXcsIG9yaWdpbikge1xuXHRcdFx0dmFyIHQxLCB0Miwgb2xkX3Bhciwgb2xkX3BvcywgbmV3X3Bhciwgb2xkX2lucywgaXNfbXVsdGksIGRwYywgdG1wLCBpLCBqLCBrLCBsLCBwO1xuXG5cdFx0XHRwYXIgPSB0aGlzLmdldF9ub2RlKHBhcik7XG5cdFx0XHRwb3MgPSBwb3MgPT09IHVuZGVmaW5lZCA/IDAgOiBwb3M7XG5cdFx0XHRpZighcGFyKSB7IHJldHVybiBmYWxzZTsgfVxuXHRcdFx0aWYoIXBvcy50b1N0cmluZygpLm1hdGNoKC9eKGJlZm9yZXxhZnRlcikkLykgJiYgIWlzX2xvYWRlZCAmJiAhdGhpcy5pc19sb2FkZWQocGFyKSkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5sb2FkX25vZGUocGFyLCBmdW5jdGlvbiAoKSB7IHRoaXMubW92ZV9ub2RlKG9iaiwgcGFyLCBwb3MsIGNhbGxiYWNrLCB0cnVlLCBmYWxzZSwgb3JpZ2luKTsgfSk7XG5cdFx0XHR9XG5cblx0XHRcdGlmKCQuaXNBcnJheShvYmopKSB7XG5cdFx0XHRcdGlmKG9iai5sZW5ndGggPT09IDEpIHtcblx0XHRcdFx0XHRvYmogPSBvYmpbMF07XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0Ly9vYmogPSBvYmouc2xpY2UoKTtcblx0XHRcdFx0XHRmb3IodDEgPSAwLCB0MiA9IG9iai5sZW5ndGg7IHQxIDwgdDI7IHQxKyspIHtcblx0XHRcdFx0XHRcdGlmKCh0bXAgPSB0aGlzLm1vdmVfbm9kZShvYmpbdDFdLCBwYXIsIHBvcywgY2FsbGJhY2ssIGlzX2xvYWRlZCwgZmFsc2UsIG9yaWdpbikpKSB7XG5cdFx0XHRcdFx0XHRcdHBhciA9IHRtcDtcblx0XHRcdFx0XHRcdFx0cG9zID0gXCJhZnRlclwiO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHR0aGlzLnJlZHJhdygpO1xuXHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRvYmogPSBvYmogJiYgb2JqLmlkID8gb2JqIDogdGhpcy5nZXRfbm9kZShvYmopO1xuXG5cdFx0XHRpZighb2JqIHx8IG9iai5pZCA9PT0gJC5qc3RyZWUucm9vdCkgeyByZXR1cm4gZmFsc2U7IH1cblxuXHRcdFx0b2xkX3BhciA9IChvYmoucGFyZW50IHx8ICQuanN0cmVlLnJvb3QpLnRvU3RyaW5nKCk7XG5cdFx0XHRuZXdfcGFyID0gKCFwb3MudG9TdHJpbmcoKS5tYXRjaCgvXihiZWZvcmV8YWZ0ZXIpJC8pIHx8IHBhci5pZCA9PT0gJC5qc3RyZWUucm9vdCkgPyBwYXIgOiB0aGlzLmdldF9ub2RlKHBhci5wYXJlbnQpO1xuXHRcdFx0b2xkX2lucyA9IG9yaWdpbiA/IG9yaWdpbiA6ICh0aGlzLl9tb2RlbC5kYXRhW29iai5pZF0gPyB0aGlzIDogJC5qc3RyZWUucmVmZXJlbmNlKG9iai5pZCkpO1xuXHRcdFx0aXNfbXVsdGkgPSAhb2xkX2lucyB8fCAhb2xkX2lucy5faWQgfHwgKHRoaXMuX2lkICE9PSBvbGRfaW5zLl9pZCk7XG5cdFx0XHRvbGRfcG9zID0gb2xkX2lucyAmJiBvbGRfaW5zLl9pZCAmJiBvbGRfcGFyICYmIG9sZF9pbnMuX21vZGVsLmRhdGFbb2xkX3Bhcl0gJiYgb2xkX2lucy5fbW9kZWwuZGF0YVtvbGRfcGFyXS5jaGlsZHJlbiA/ICQuaW5BcnJheShvYmouaWQsIG9sZF9pbnMuX21vZGVsLmRhdGFbb2xkX3Bhcl0uY2hpbGRyZW4pIDogLTE7XG5cdFx0XHRpZihvbGRfaW5zICYmIG9sZF9pbnMuX2lkKSB7XG5cdFx0XHRcdG9iaiA9IG9sZF9pbnMuX21vZGVsLmRhdGFbb2JqLmlkXTtcblx0XHRcdH1cblxuXHRcdFx0aWYoaXNfbXVsdGkpIHtcblx0XHRcdFx0aWYoKHRtcCA9IHRoaXMuY29weV9ub2RlKG9iaiwgcGFyLCBwb3MsIGNhbGxiYWNrLCBpc19sb2FkZWQsIGZhbHNlLCBvcmlnaW4pKSkge1xuXHRcdFx0XHRcdGlmKG9sZF9pbnMpIHsgb2xkX2lucy5kZWxldGVfbm9kZShvYmopOyB9XG5cdFx0XHRcdFx0cmV0dXJuIHRtcDtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cdFx0XHQvL3ZhciBtID0gdGhpcy5fbW9kZWwuZGF0YTtcblx0XHRcdGlmKHBhci5pZCA9PT0gJC5qc3RyZWUucm9vdCkge1xuXHRcdFx0XHRpZihwb3MgPT09IFwiYmVmb3JlXCIpIHsgcG9zID0gXCJmaXJzdFwiOyB9XG5cdFx0XHRcdGlmKHBvcyA9PT0gXCJhZnRlclwiKSB7IHBvcyA9IFwibGFzdFwiOyB9XG5cdFx0XHR9XG5cdFx0XHRzd2l0Y2gocG9zKSB7XG5cdFx0XHRcdGNhc2UgXCJiZWZvcmVcIjpcblx0XHRcdFx0XHRwb3MgPSAkLmluQXJyYXkocGFyLmlkLCBuZXdfcGFyLmNoaWxkcmVuKTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0Y2FzZSBcImFmdGVyXCIgOlxuXHRcdFx0XHRcdHBvcyA9ICQuaW5BcnJheShwYXIuaWQsIG5ld19wYXIuY2hpbGRyZW4pICsgMTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0Y2FzZSBcImluc2lkZVwiOlxuXHRcdFx0XHRjYXNlIFwiZmlyc3RcIjpcblx0XHRcdFx0XHRwb3MgPSAwO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRjYXNlIFwibGFzdFwiOlxuXHRcdFx0XHRcdHBvcyA9IG5ld19wYXIuY2hpbGRyZW4ubGVuZ3RoO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRcdGlmKCFwb3MpIHsgcG9zID0gMDsgfVxuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdFx0aWYocG9zID4gbmV3X3Bhci5jaGlsZHJlbi5sZW5ndGgpIHsgcG9zID0gbmV3X3Bhci5jaGlsZHJlbi5sZW5ndGg7IH1cblx0XHRcdGlmKCF0aGlzLmNoZWNrKFwibW92ZV9ub2RlXCIsIG9iaiwgbmV3X3BhciwgcG9zLCB7ICdjb3JlJyA6IHRydWUsICdvcmlnaW4nIDogb3JpZ2luLCAnaXNfbXVsdGknIDogKG9sZF9pbnMgJiYgb2xkX2lucy5faWQgJiYgb2xkX2lucy5faWQgIT09IHRoaXMuX2lkKSwgJ2lzX2ZvcmVpZ24nIDogKCFvbGRfaW5zIHx8ICFvbGRfaW5zLl9pZCkgfSkpIHtcblx0XHRcdFx0dGhpcy5zZXR0aW5ncy5jb3JlLmVycm9yLmNhbGwodGhpcywgdGhpcy5fZGF0YS5jb3JlLmxhc3RfZXJyb3IpO1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cdFx0XHRpZihvYmoucGFyZW50ID09PSBuZXdfcGFyLmlkKSB7XG5cdFx0XHRcdGRwYyA9IG5ld19wYXIuY2hpbGRyZW4uY29uY2F0KCk7XG5cdFx0XHRcdHRtcCA9ICQuaW5BcnJheShvYmouaWQsIGRwYyk7XG5cdFx0XHRcdGlmKHRtcCAhPT0gLTEpIHtcblx0XHRcdFx0XHRkcGMgPSAkLnZha2F0YS5hcnJheV9yZW1vdmUoZHBjLCB0bXApO1xuXHRcdFx0XHRcdGlmKHBvcyA+IHRtcCkgeyBwb3MtLTsgfVxuXHRcdFx0XHR9XG5cdFx0XHRcdHRtcCA9IFtdO1xuXHRcdFx0XHRmb3IoaSA9IDAsIGogPSBkcGMubGVuZ3RoOyBpIDwgajsgaSsrKSB7XG5cdFx0XHRcdFx0dG1wW2kgPj0gcG9zID8gaSsxIDogaV0gPSBkcGNbaV07XG5cdFx0XHRcdH1cblx0XHRcdFx0dG1wW3Bvc10gPSBvYmouaWQ7XG5cdFx0XHRcdG5ld19wYXIuY2hpbGRyZW4gPSB0bXA7XG5cdFx0XHRcdHRoaXMuX25vZGVfY2hhbmdlZChuZXdfcGFyLmlkKTtcblx0XHRcdFx0dGhpcy5yZWRyYXcobmV3X3Bhci5pZCA9PT0gJC5qc3RyZWUucm9vdCk7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIHtcblx0XHRcdFx0Ly8gY2xlYW4gb2xkIHBhcmVudCBhbmQgdXBcblx0XHRcdFx0dG1wID0gb2JqLmNoaWxkcmVuX2QuY29uY2F0KCk7XG5cdFx0XHRcdHRtcC5wdXNoKG9iai5pZCk7XG5cdFx0XHRcdGZvcihpID0gMCwgaiA9IG9iai5wYXJlbnRzLmxlbmd0aDsgaSA8IGo7IGkrKykge1xuXHRcdFx0XHRcdGRwYyA9IFtdO1xuXHRcdFx0XHRcdHAgPSBvbGRfaW5zLl9tb2RlbC5kYXRhW29iai5wYXJlbnRzW2ldXS5jaGlsZHJlbl9kO1xuXHRcdFx0XHRcdGZvcihrID0gMCwgbCA9IHAubGVuZ3RoOyBrIDwgbDsgaysrKSB7XG5cdFx0XHRcdFx0XHRpZigkLmluQXJyYXkocFtrXSwgdG1wKSA9PT0gLTEpIHtcblx0XHRcdFx0XHRcdFx0ZHBjLnB1c2gocFtrXSk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdG9sZF9pbnMuX21vZGVsLmRhdGFbb2JqLnBhcmVudHNbaV1dLmNoaWxkcmVuX2QgPSBkcGM7XG5cdFx0XHRcdH1cblx0XHRcdFx0b2xkX2lucy5fbW9kZWwuZGF0YVtvbGRfcGFyXS5jaGlsZHJlbiA9ICQudmFrYXRhLmFycmF5X3JlbW92ZV9pdGVtKG9sZF9pbnMuX21vZGVsLmRhdGFbb2xkX3Bhcl0uY2hpbGRyZW4sIG9iai5pZCk7XG5cblx0XHRcdFx0Ly8gaW5zZXJ0IGludG8gbmV3IHBhcmVudCBhbmQgdXBcblx0XHRcdFx0Zm9yKGkgPSAwLCBqID0gbmV3X3Bhci5wYXJlbnRzLmxlbmd0aDsgaSA8IGo7IGkrKykge1xuXHRcdFx0XHRcdHRoaXMuX21vZGVsLmRhdGFbbmV3X3Bhci5wYXJlbnRzW2ldXS5jaGlsZHJlbl9kID0gdGhpcy5fbW9kZWwuZGF0YVtuZXdfcGFyLnBhcmVudHNbaV1dLmNoaWxkcmVuX2QuY29uY2F0KHRtcCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZHBjID0gW107XG5cdFx0XHRcdGZvcihpID0gMCwgaiA9IG5ld19wYXIuY2hpbGRyZW4ubGVuZ3RoOyBpIDwgajsgaSsrKSB7XG5cdFx0XHRcdFx0ZHBjW2kgPj0gcG9zID8gaSsxIDogaV0gPSBuZXdfcGFyLmNoaWxkcmVuW2ldO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGRwY1twb3NdID0gb2JqLmlkO1xuXHRcdFx0XHRuZXdfcGFyLmNoaWxkcmVuID0gZHBjO1xuXHRcdFx0XHRuZXdfcGFyLmNoaWxkcmVuX2QucHVzaChvYmouaWQpO1xuXHRcdFx0XHRuZXdfcGFyLmNoaWxkcmVuX2QgPSBuZXdfcGFyLmNoaWxkcmVuX2QuY29uY2F0KG9iai5jaGlsZHJlbl9kKTtcblxuXHRcdFx0XHQvLyB1cGRhdGUgb2JqZWN0XG5cdFx0XHRcdG9iai5wYXJlbnQgPSBuZXdfcGFyLmlkO1xuXHRcdFx0XHR0bXAgPSBuZXdfcGFyLnBhcmVudHMuY29uY2F0KCk7XG5cdFx0XHRcdHRtcC51bnNoaWZ0KG5ld19wYXIuaWQpO1xuXHRcdFx0XHRwID0gb2JqLnBhcmVudHMubGVuZ3RoO1xuXHRcdFx0XHRvYmoucGFyZW50cyA9IHRtcDtcblxuXHRcdFx0XHQvLyB1cGRhdGUgb2JqZWN0IGNoaWxkcmVuXG5cdFx0XHRcdHRtcCA9IHRtcC5jb25jYXQoKTtcblx0XHRcdFx0Zm9yKGkgPSAwLCBqID0gb2JqLmNoaWxkcmVuX2QubGVuZ3RoOyBpIDwgajsgaSsrKSB7XG5cdFx0XHRcdFx0dGhpcy5fbW9kZWwuZGF0YVtvYmouY2hpbGRyZW5fZFtpXV0ucGFyZW50cyA9IHRoaXMuX21vZGVsLmRhdGFbb2JqLmNoaWxkcmVuX2RbaV1dLnBhcmVudHMuc2xpY2UoMCxwKi0xKTtcblx0XHRcdFx0XHRBcnJheS5wcm90b3R5cGUucHVzaC5hcHBseSh0aGlzLl9tb2RlbC5kYXRhW29iai5jaGlsZHJlbl9kW2ldXS5wYXJlbnRzLCB0bXApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYob2xkX3BhciA9PT0gJC5qc3RyZWUucm9vdCB8fCBuZXdfcGFyLmlkID09PSAkLmpzdHJlZS5yb290KSB7XG5cdFx0XHRcdFx0dGhpcy5fbW9kZWwuZm9yY2VfZnVsbF9yZWRyYXcgPSB0cnVlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmKCF0aGlzLl9tb2RlbC5mb3JjZV9mdWxsX3JlZHJhdykge1xuXHRcdFx0XHRcdHRoaXMuX25vZGVfY2hhbmdlZChvbGRfcGFyKTtcblx0XHRcdFx0XHR0aGlzLl9ub2RlX2NoYW5nZWQobmV3X3Bhci5pZCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYoIXNraXBfcmVkcmF3KSB7XG5cdFx0XHRcdFx0dGhpcy5yZWRyYXcoKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0aWYoY2FsbGJhY2spIHsgY2FsbGJhY2suY2FsbCh0aGlzLCBvYmosIG5ld19wYXIsIHBvcyk7IH1cblx0XHRcdC8qKlxuXHRcdFx0ICogdHJpZ2dlcmVkIHdoZW4gYSBub2RlIGlzIG1vdmVkXG5cdFx0XHQgKiBAZXZlbnRcblx0XHRcdCAqIEBuYW1lIG1vdmVfbm9kZS5qc3RyZWVcblx0XHRcdCAqIEBwYXJhbSB7T2JqZWN0fSBub2RlXG5cdFx0XHQgKiBAcGFyYW0ge1N0cmluZ30gcGFyZW50IHRoZSBwYXJlbnQncyBJRFxuXHRcdFx0ICogQHBhcmFtIHtOdW1iZXJ9IHBvc2l0aW9uIHRoZSBwb3NpdGlvbiBvZiB0aGUgbm9kZSBhbW9uZyB0aGUgcGFyZW50J3MgY2hpbGRyZW5cblx0XHRcdCAqIEBwYXJhbSB7U3RyaW5nfSBvbGRfcGFyZW50IHRoZSBvbGQgcGFyZW50IG9mIHRoZSBub2RlXG5cdFx0XHQgKiBAcGFyYW0ge051bWJlcn0gb2xkX3Bvc2l0aW9uIHRoZSBvbGQgcG9zaXRpb24gb2YgdGhlIG5vZGVcblx0XHRcdCAqIEBwYXJhbSB7Qm9vbGVhbn0gaXNfbXVsdGkgZG8gdGhlIG5vZGUgYW5kIG5ldyBwYXJlbnQgYmVsb25nIHRvIGRpZmZlcmVudCBpbnN0YW5jZXNcblx0XHRcdCAqIEBwYXJhbSB7anNUcmVlfSBvbGRfaW5zdGFuY2UgdGhlIGluc3RhbmNlIHRoZSBub2RlIGNhbWUgZnJvbVxuXHRcdFx0ICogQHBhcmFtIHtqc1RyZWV9IG5ld19pbnN0YW5jZSB0aGUgaW5zdGFuY2Ugb2YgdGhlIG5ldyBwYXJlbnRcblx0XHRcdCAqL1xuXHRcdFx0dGhpcy50cmlnZ2VyKCdtb3ZlX25vZGUnLCB7IFwibm9kZVwiIDogb2JqLCBcInBhcmVudFwiIDogbmV3X3Bhci5pZCwgXCJwb3NpdGlvblwiIDogcG9zLCBcIm9sZF9wYXJlbnRcIiA6IG9sZF9wYXIsIFwib2xkX3Bvc2l0aW9uXCIgOiBvbGRfcG9zLCAnaXNfbXVsdGknIDogKG9sZF9pbnMgJiYgb2xkX2lucy5faWQgJiYgb2xkX2lucy5faWQgIT09IHRoaXMuX2lkKSwgJ2lzX2ZvcmVpZ24nIDogKCFvbGRfaW5zIHx8ICFvbGRfaW5zLl9pZCksICdvbGRfaW5zdGFuY2UnIDogb2xkX2lucywgJ25ld19pbnN0YW5jZScgOiB0aGlzIH0pO1xuXHRcdFx0cmV0dXJuIG9iai5pZDtcblx0XHR9LFxuXHRcdC8qKlxuXHRcdCAqIGNvcHkgYSBub2RlIHRvIGEgbmV3IHBhcmVudFxuXHRcdCAqIEBuYW1lIGNvcHlfbm9kZShvYmosIHBhciBbLCBwb3MsIGNhbGxiYWNrLCBpc19sb2FkZWRdKVxuXHRcdCAqIEBwYXJhbSAge21peGVkfSBvYmogdGhlIG5vZGUgdG8gY29weSwgcGFzcyBhbiBhcnJheSB0byBjb3B5IG11bHRpcGxlIG5vZGVzXG5cdFx0ICogQHBhcmFtICB7bWl4ZWR9IHBhciB0aGUgbmV3IHBhcmVudFxuXHRcdCAqIEBwYXJhbSAge21peGVkfSBwb3MgdGhlIHBvc2l0aW9uIHRvIGluc2VydCBhdCAoYmVzaWRlcyBpbnRlZ2VyIHZhbHVlcywgXCJmaXJzdFwiIGFuZCBcImxhc3RcIiBhcmUgc3VwcG9ydGVkLCBhcyB3ZWxsIGFzIFwiYmVmb3JlXCIgYW5kIFwiYWZ0ZXJcIiksIGRlZmF1bHRzIHRvIGludGVnZXIgYDBgXG5cdFx0ICogQHBhcmFtICB7ZnVuY3Rpb259IGNhbGxiYWNrIGEgZnVuY3Rpb24gdG8gY2FsbCBvbmNlIHRoZSBtb3ZlIGlzIGNvbXBsZXRlZCwgcmVjZWl2ZXMgMyBhcmd1bWVudHMgLSB0aGUgbm9kZSwgdGhlIG5ldyBwYXJlbnQgYW5kIHRoZSBwb3NpdGlvblxuXHRcdCAqIEBwYXJhbSAge0Jvb2xlYW59IGlzX2xvYWRlZCBpbnRlcm5hbCBwYXJhbWV0ZXIgaW5kaWNhdGluZyBpZiB0aGUgcGFyZW50IG5vZGUgaGFzIGJlZW4gbG9hZGVkXG5cdFx0ICogQHBhcmFtICB7Qm9vbGVhbn0gc2tpcF9yZWRyYXcgaW50ZXJuYWwgcGFyYW1ldGVyIGluZGljYXRpbmcgaWYgdGhlIHRyZWUgc2hvdWxkIGJlIHJlZHJhd25cblx0XHQgKiBAcGFyYW0gIHtCb29sZWFufSBpbnN0YW5jZSBpbnRlcm5hbCBwYXJhbWV0ZXIgaW5kaWNhdGluZyBpZiB0aGUgbm9kZSBjb21lcyBmcm9tIGFub3RoZXIgaW5zdGFuY2Vcblx0XHQgKiBAdHJpZ2dlciBtb2RlbC5qc3RyZWUgY29weV9ub2RlLmpzdHJlZVxuXHRcdCAqL1xuXHRcdGNvcHlfbm9kZSA6IGZ1bmN0aW9uIChvYmosIHBhciwgcG9zLCBjYWxsYmFjaywgaXNfbG9hZGVkLCBza2lwX3JlZHJhdywgb3JpZ2luKSB7XG5cdFx0XHR2YXIgdDEsIHQyLCBkcGMsIHRtcCwgaSwgaiwgbm9kZSwgb2xkX3BhciwgbmV3X3Bhciwgb2xkX2lucywgaXNfbXVsdGk7XG5cblx0XHRcdHBhciA9IHRoaXMuZ2V0X25vZGUocGFyKTtcblx0XHRcdHBvcyA9IHBvcyA9PT0gdW5kZWZpbmVkID8gMCA6IHBvcztcblx0XHRcdGlmKCFwYXIpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdFx0XHRpZighcG9zLnRvU3RyaW5nKCkubWF0Y2goL14oYmVmb3JlfGFmdGVyKSQvKSAmJiAhaXNfbG9hZGVkICYmICF0aGlzLmlzX2xvYWRlZChwYXIpKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLmxvYWRfbm9kZShwYXIsIGZ1bmN0aW9uICgpIHsgdGhpcy5jb3B5X25vZGUob2JqLCBwYXIsIHBvcywgY2FsbGJhY2ssIHRydWUsIGZhbHNlLCBvcmlnaW4pOyB9KTtcblx0XHRcdH1cblxuXHRcdFx0aWYoJC5pc0FycmF5KG9iaikpIHtcblx0XHRcdFx0aWYob2JqLmxlbmd0aCA9PT0gMSkge1xuXHRcdFx0XHRcdG9iaiA9IG9ialswXTtcblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHQvL29iaiA9IG9iai5zbGljZSgpO1xuXHRcdFx0XHRcdGZvcih0MSA9IDAsIHQyID0gb2JqLmxlbmd0aDsgdDEgPCB0MjsgdDErKykge1xuXHRcdFx0XHRcdFx0aWYoKHRtcCA9IHRoaXMuY29weV9ub2RlKG9ialt0MV0sIHBhciwgcG9zLCBjYWxsYmFjaywgaXNfbG9hZGVkLCB0cnVlLCBvcmlnaW4pKSkge1xuXHRcdFx0XHRcdFx0XHRwYXIgPSB0bXA7XG5cdFx0XHRcdFx0XHRcdHBvcyA9IFwiYWZ0ZXJcIjtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0dGhpcy5yZWRyYXcoKTtcblx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0b2JqID0gb2JqICYmIG9iai5pZCA/IG9iaiA6IHRoaXMuZ2V0X25vZGUob2JqKTtcblx0XHRcdGlmKCFvYmogfHwgb2JqLmlkID09PSAkLmpzdHJlZS5yb290KSB7IHJldHVybiBmYWxzZTsgfVxuXG5cdFx0XHRvbGRfcGFyID0gKG9iai5wYXJlbnQgfHwgJC5qc3RyZWUucm9vdCkudG9TdHJpbmcoKTtcblx0XHRcdG5ld19wYXIgPSAoIXBvcy50b1N0cmluZygpLm1hdGNoKC9eKGJlZm9yZXxhZnRlcikkLykgfHwgcGFyLmlkID09PSAkLmpzdHJlZS5yb290KSA/IHBhciA6IHRoaXMuZ2V0X25vZGUocGFyLnBhcmVudCk7XG5cdFx0XHRvbGRfaW5zID0gb3JpZ2luID8gb3JpZ2luIDogKHRoaXMuX21vZGVsLmRhdGFbb2JqLmlkXSA/IHRoaXMgOiAkLmpzdHJlZS5yZWZlcmVuY2Uob2JqLmlkKSk7XG5cdFx0XHRpc19tdWx0aSA9ICFvbGRfaW5zIHx8ICFvbGRfaW5zLl9pZCB8fCAodGhpcy5faWQgIT09IG9sZF9pbnMuX2lkKTtcblxuXHRcdFx0aWYob2xkX2lucyAmJiBvbGRfaW5zLl9pZCkge1xuXHRcdFx0XHRvYmogPSBvbGRfaW5zLl9tb2RlbC5kYXRhW29iai5pZF07XG5cdFx0XHR9XG5cblx0XHRcdGlmKHBhci5pZCA9PT0gJC5qc3RyZWUucm9vdCkge1xuXHRcdFx0XHRpZihwb3MgPT09IFwiYmVmb3JlXCIpIHsgcG9zID0gXCJmaXJzdFwiOyB9XG5cdFx0XHRcdGlmKHBvcyA9PT0gXCJhZnRlclwiKSB7IHBvcyA9IFwibGFzdFwiOyB9XG5cdFx0XHR9XG5cdFx0XHRzd2l0Y2gocG9zKSB7XG5cdFx0XHRcdGNhc2UgXCJiZWZvcmVcIjpcblx0XHRcdFx0XHRwb3MgPSAkLmluQXJyYXkocGFyLmlkLCBuZXdfcGFyLmNoaWxkcmVuKTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0Y2FzZSBcImFmdGVyXCIgOlxuXHRcdFx0XHRcdHBvcyA9ICQuaW5BcnJheShwYXIuaWQsIG5ld19wYXIuY2hpbGRyZW4pICsgMTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0Y2FzZSBcImluc2lkZVwiOlxuXHRcdFx0XHRjYXNlIFwiZmlyc3RcIjpcblx0XHRcdFx0XHRwb3MgPSAwO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRjYXNlIFwibGFzdFwiOlxuXHRcdFx0XHRcdHBvcyA9IG5ld19wYXIuY2hpbGRyZW4ubGVuZ3RoO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRcdGlmKCFwb3MpIHsgcG9zID0gMDsgfVxuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdFx0aWYocG9zID4gbmV3X3Bhci5jaGlsZHJlbi5sZW5ndGgpIHsgcG9zID0gbmV3X3Bhci5jaGlsZHJlbi5sZW5ndGg7IH1cblx0XHRcdGlmKCF0aGlzLmNoZWNrKFwiY29weV9ub2RlXCIsIG9iaiwgbmV3X3BhciwgcG9zLCB7ICdjb3JlJyA6IHRydWUsICdvcmlnaW4nIDogb3JpZ2luLCAnaXNfbXVsdGknIDogKG9sZF9pbnMgJiYgb2xkX2lucy5faWQgJiYgb2xkX2lucy5faWQgIT09IHRoaXMuX2lkKSwgJ2lzX2ZvcmVpZ24nIDogKCFvbGRfaW5zIHx8ICFvbGRfaW5zLl9pZCkgfSkpIHtcblx0XHRcdFx0dGhpcy5zZXR0aW5ncy5jb3JlLmVycm9yLmNhbGwodGhpcywgdGhpcy5fZGF0YS5jb3JlLmxhc3RfZXJyb3IpO1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cdFx0XHRub2RlID0gb2xkX2lucyA/IG9sZF9pbnMuZ2V0X2pzb24ob2JqLCB7IG5vX2lkIDogdHJ1ZSwgbm9fZGF0YSA6IHRydWUsIG5vX3N0YXRlIDogdHJ1ZSB9KSA6IG9iajtcblx0XHRcdGlmKCFub2RlKSB7IHJldHVybiBmYWxzZTsgfVxuXHRcdFx0aWYobm9kZS5pZCA9PT0gdHJ1ZSkgeyBkZWxldGUgbm9kZS5pZDsgfVxuXHRcdFx0bm9kZSA9IHRoaXMuX3BhcnNlX21vZGVsX2Zyb21fanNvbihub2RlLCBuZXdfcGFyLmlkLCBuZXdfcGFyLnBhcmVudHMuY29uY2F0KCkpO1xuXHRcdFx0aWYoIW5vZGUpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdFx0XHR0bXAgPSB0aGlzLmdldF9ub2RlKG5vZGUpO1xuXHRcdFx0aWYob2JqICYmIG9iai5zdGF0ZSAmJiBvYmouc3RhdGUubG9hZGVkID09PSBmYWxzZSkgeyB0bXAuc3RhdGUubG9hZGVkID0gZmFsc2U7IH1cblx0XHRcdGRwYyA9IFtdO1xuXHRcdFx0ZHBjLnB1c2gobm9kZSk7XG5cdFx0XHRkcGMgPSBkcGMuY29uY2F0KHRtcC5jaGlsZHJlbl9kKTtcblx0XHRcdHRoaXMudHJpZ2dlcignbW9kZWwnLCB7IFwibm9kZXNcIiA6IGRwYywgXCJwYXJlbnRcIiA6IG5ld19wYXIuaWQgfSk7XG5cblx0XHRcdC8vIGluc2VydCBpbnRvIG5ldyBwYXJlbnQgYW5kIHVwXG5cdFx0XHRmb3IoaSA9IDAsIGogPSBuZXdfcGFyLnBhcmVudHMubGVuZ3RoOyBpIDwgajsgaSsrKSB7XG5cdFx0XHRcdHRoaXMuX21vZGVsLmRhdGFbbmV3X3Bhci5wYXJlbnRzW2ldXS5jaGlsZHJlbl9kID0gdGhpcy5fbW9kZWwuZGF0YVtuZXdfcGFyLnBhcmVudHNbaV1dLmNoaWxkcmVuX2QuY29uY2F0KGRwYyk7XG5cdFx0XHR9XG5cdFx0XHRkcGMgPSBbXTtcblx0XHRcdGZvcihpID0gMCwgaiA9IG5ld19wYXIuY2hpbGRyZW4ubGVuZ3RoOyBpIDwgajsgaSsrKSB7XG5cdFx0XHRcdGRwY1tpID49IHBvcyA/IGkrMSA6IGldID0gbmV3X3Bhci5jaGlsZHJlbltpXTtcblx0XHRcdH1cblx0XHRcdGRwY1twb3NdID0gdG1wLmlkO1xuXHRcdFx0bmV3X3Bhci5jaGlsZHJlbiA9IGRwYztcblx0XHRcdG5ld19wYXIuY2hpbGRyZW5fZC5wdXNoKHRtcC5pZCk7XG5cdFx0XHRuZXdfcGFyLmNoaWxkcmVuX2QgPSBuZXdfcGFyLmNoaWxkcmVuX2QuY29uY2F0KHRtcC5jaGlsZHJlbl9kKTtcblxuXHRcdFx0aWYobmV3X3Bhci5pZCA9PT0gJC5qc3RyZWUucm9vdCkge1xuXHRcdFx0XHR0aGlzLl9tb2RlbC5mb3JjZV9mdWxsX3JlZHJhdyA9IHRydWU7XG5cdFx0XHR9XG5cdFx0XHRpZighdGhpcy5fbW9kZWwuZm9yY2VfZnVsbF9yZWRyYXcpIHtcblx0XHRcdFx0dGhpcy5fbm9kZV9jaGFuZ2VkKG5ld19wYXIuaWQpO1xuXHRcdFx0fVxuXHRcdFx0aWYoIXNraXBfcmVkcmF3KSB7XG5cdFx0XHRcdHRoaXMucmVkcmF3KG5ld19wYXIuaWQgPT09ICQuanN0cmVlLnJvb3QpO1xuXHRcdFx0fVxuXHRcdFx0aWYoY2FsbGJhY2spIHsgY2FsbGJhY2suY2FsbCh0aGlzLCB0bXAsIG5ld19wYXIsIHBvcyk7IH1cblx0XHRcdC8qKlxuXHRcdFx0ICogdHJpZ2dlcmVkIHdoZW4gYSBub2RlIGlzIGNvcGllZFxuXHRcdFx0ICogQGV2ZW50XG5cdFx0XHQgKiBAbmFtZSBjb3B5X25vZGUuanN0cmVlXG5cdFx0XHQgKiBAcGFyYW0ge09iamVjdH0gbm9kZSB0aGUgY29waWVkIG5vZGVcblx0XHRcdCAqIEBwYXJhbSB7T2JqZWN0fSBvcmlnaW5hbCB0aGUgb3JpZ2luYWwgbm9kZVxuXHRcdFx0ICogQHBhcmFtIHtTdHJpbmd9IHBhcmVudCB0aGUgcGFyZW50J3MgSURcblx0XHRcdCAqIEBwYXJhbSB7TnVtYmVyfSBwb3NpdGlvbiB0aGUgcG9zaXRpb24gb2YgdGhlIG5vZGUgYW1vbmcgdGhlIHBhcmVudCdzIGNoaWxkcmVuXG5cdFx0XHQgKiBAcGFyYW0ge1N0cmluZ30gb2xkX3BhcmVudCB0aGUgb2xkIHBhcmVudCBvZiB0aGUgbm9kZVxuXHRcdFx0ICogQHBhcmFtIHtOdW1iZXJ9IG9sZF9wb3NpdGlvbiB0aGUgcG9zaXRpb24gb2YgdGhlIG9yaWdpbmFsIG5vZGVcblx0XHRcdCAqIEBwYXJhbSB7Qm9vbGVhbn0gaXNfbXVsdGkgZG8gdGhlIG5vZGUgYW5kIG5ldyBwYXJlbnQgYmVsb25nIHRvIGRpZmZlcmVudCBpbnN0YW5jZXNcblx0XHRcdCAqIEBwYXJhbSB7anNUcmVlfSBvbGRfaW5zdGFuY2UgdGhlIGluc3RhbmNlIHRoZSBub2RlIGNhbWUgZnJvbVxuXHRcdFx0ICogQHBhcmFtIHtqc1RyZWV9IG5ld19pbnN0YW5jZSB0aGUgaW5zdGFuY2Ugb2YgdGhlIG5ldyBwYXJlbnRcblx0XHRcdCAqL1xuXHRcdFx0dGhpcy50cmlnZ2VyKCdjb3B5X25vZGUnLCB7IFwibm9kZVwiIDogdG1wLCBcIm9yaWdpbmFsXCIgOiBvYmosIFwicGFyZW50XCIgOiBuZXdfcGFyLmlkLCBcInBvc2l0aW9uXCIgOiBwb3MsIFwib2xkX3BhcmVudFwiIDogb2xkX3BhciwgXCJvbGRfcG9zaXRpb25cIiA6IG9sZF9pbnMgJiYgb2xkX2lucy5faWQgJiYgb2xkX3BhciAmJiBvbGRfaW5zLl9tb2RlbC5kYXRhW29sZF9wYXJdICYmIG9sZF9pbnMuX21vZGVsLmRhdGFbb2xkX3Bhcl0uY2hpbGRyZW4gPyAkLmluQXJyYXkob2JqLmlkLCBvbGRfaW5zLl9tb2RlbC5kYXRhW29sZF9wYXJdLmNoaWxkcmVuKSA6IC0xLCdpc19tdWx0aScgOiAob2xkX2lucyAmJiBvbGRfaW5zLl9pZCAmJiBvbGRfaW5zLl9pZCAhPT0gdGhpcy5faWQpLCAnaXNfZm9yZWlnbicgOiAoIW9sZF9pbnMgfHwgIW9sZF9pbnMuX2lkKSwgJ29sZF9pbnN0YW5jZScgOiBvbGRfaW5zLCAnbmV3X2luc3RhbmNlJyA6IHRoaXMgfSk7XG5cdFx0XHRyZXR1cm4gdG1wLmlkO1xuXHRcdH0sXG5cdFx0LyoqXG5cdFx0ICogY3V0IGEgbm9kZSAoYSBsYXRlciBjYWxsIHRvIGBwYXN0ZShvYmopYCB3b3VsZCBtb3ZlIHRoZSBub2RlKVxuXHRcdCAqIEBuYW1lIGN1dChvYmopXG5cdFx0ICogQHBhcmFtICB7bWl4ZWR9IG9iaiBtdWx0aXBsZSBvYmplY3RzIGNhbiBiZSBwYXNzZWQgdXNpbmcgYW4gYXJyYXlcblx0XHQgKiBAdHJpZ2dlciBjdXQuanN0cmVlXG5cdFx0ICovXG5cdFx0Y3V0IDogZnVuY3Rpb24gKG9iaikge1xuXHRcdFx0aWYoIW9iaikgeyBvYmogPSB0aGlzLl9kYXRhLmNvcmUuc2VsZWN0ZWQuY29uY2F0KCk7IH1cblx0XHRcdGlmKCEkLmlzQXJyYXkob2JqKSkgeyBvYmogPSBbb2JqXTsgfVxuXHRcdFx0aWYoIW9iai5sZW5ndGgpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdFx0XHR2YXIgdG1wID0gW10sIG8sIHQxLCB0Mjtcblx0XHRcdGZvcih0MSA9IDAsIHQyID0gb2JqLmxlbmd0aDsgdDEgPCB0MjsgdDErKykge1xuXHRcdFx0XHRvID0gdGhpcy5nZXRfbm9kZShvYmpbdDFdKTtcblx0XHRcdFx0aWYobyAmJiBvLmlkICYmIG8uaWQgIT09ICQuanN0cmVlLnJvb3QpIHsgdG1wLnB1c2gobyk7IH1cblx0XHRcdH1cblx0XHRcdGlmKCF0bXAubGVuZ3RoKSB7IHJldHVybiBmYWxzZTsgfVxuXHRcdFx0Y2NwX25vZGUgPSB0bXA7XG5cdFx0XHRjY3BfaW5zdCA9IHRoaXM7XG5cdFx0XHRjY3BfbW9kZSA9ICdtb3ZlX25vZGUnO1xuXHRcdFx0LyoqXG5cdFx0XHQgKiB0cmlnZ2VyZWQgd2hlbiBub2RlcyBhcmUgYWRkZWQgdG8gdGhlIGJ1ZmZlciBmb3IgbW92aW5nXG5cdFx0XHQgKiBAZXZlbnRcblx0XHRcdCAqIEBuYW1lIGN1dC5qc3RyZWVcblx0XHRcdCAqIEBwYXJhbSB7QXJyYXl9IG5vZGVcblx0XHRcdCAqL1xuXHRcdFx0dGhpcy50cmlnZ2VyKCdjdXQnLCB7IFwibm9kZVwiIDogb2JqIH0pO1xuXHRcdH0sXG5cdFx0LyoqXG5cdFx0ICogY29weSBhIG5vZGUgKGEgbGF0ZXIgY2FsbCB0byBgcGFzdGUob2JqKWAgd291bGQgY29weSB0aGUgbm9kZSlcblx0XHQgKiBAbmFtZSBjb3B5KG9iailcblx0XHQgKiBAcGFyYW0gIHttaXhlZH0gb2JqIG11bHRpcGxlIG9iamVjdHMgY2FuIGJlIHBhc3NlZCB1c2luZyBhbiBhcnJheVxuXHRcdCAqIEB0cmlnZ2VyIGNvcHkuanN0cmVlXG5cdFx0ICovXG5cdFx0Y29weSA6IGZ1bmN0aW9uIChvYmopIHtcblx0XHRcdGlmKCFvYmopIHsgb2JqID0gdGhpcy5fZGF0YS5jb3JlLnNlbGVjdGVkLmNvbmNhdCgpOyB9XG5cdFx0XHRpZighJC5pc0FycmF5KG9iaikpIHsgb2JqID0gW29ial07IH1cblx0XHRcdGlmKCFvYmoubGVuZ3RoKSB7IHJldHVybiBmYWxzZTsgfVxuXHRcdFx0dmFyIHRtcCA9IFtdLCBvLCB0MSwgdDI7XG5cdFx0XHRmb3IodDEgPSAwLCB0MiA9IG9iai5sZW5ndGg7IHQxIDwgdDI7IHQxKyspIHtcblx0XHRcdFx0byA9IHRoaXMuZ2V0X25vZGUob2JqW3QxXSk7XG5cdFx0XHRcdGlmKG8gJiYgby5pZCAmJiBvLmlkICE9PSAkLmpzdHJlZS5yb290KSB7IHRtcC5wdXNoKG8pOyB9XG5cdFx0XHR9XG5cdFx0XHRpZighdG1wLmxlbmd0aCkgeyByZXR1cm4gZmFsc2U7IH1cblx0XHRcdGNjcF9ub2RlID0gdG1wO1xuXHRcdFx0Y2NwX2luc3QgPSB0aGlzO1xuXHRcdFx0Y2NwX21vZGUgPSAnY29weV9ub2RlJztcblx0XHRcdC8qKlxuXHRcdFx0ICogdHJpZ2dlcmVkIHdoZW4gbm9kZXMgYXJlIGFkZGVkIHRvIHRoZSBidWZmZXIgZm9yIGNvcHlpbmdcblx0XHRcdCAqIEBldmVudFxuXHRcdFx0ICogQG5hbWUgY29weS5qc3RyZWVcblx0XHRcdCAqIEBwYXJhbSB7QXJyYXl9IG5vZGVcblx0XHRcdCAqL1xuXHRcdFx0dGhpcy50cmlnZ2VyKCdjb3B5JywgeyBcIm5vZGVcIiA6IG9iaiB9KTtcblx0XHR9LFxuXHRcdC8qKlxuXHRcdCAqIGdldCB0aGUgY3VycmVudCBidWZmZXIgKGFueSBub2RlcyB0aGF0IGFyZSB3YWl0aW5nIGZvciBhIHBhc3RlIG9wZXJhdGlvbilcblx0XHQgKiBAbmFtZSBnZXRfYnVmZmVyKClcblx0XHQgKiBAcmV0dXJuIHtPYmplY3R9IGFuIG9iamVjdCBjb25zaXN0aW5nIG9mIGBtb2RlYCAoXCJjb3B5X25vZGVcIiBvciBcIm1vdmVfbm9kZVwiKSwgYG5vZGVgIChhbiBhcnJheSBvZiBvYmplY3RzKSBhbmQgYGluc3RgICh0aGUgaW5zdGFuY2UpXG5cdFx0ICovXG5cdFx0Z2V0X2J1ZmZlciA6IGZ1bmN0aW9uICgpIHtcblx0XHRcdHJldHVybiB7ICdtb2RlJyA6IGNjcF9tb2RlLCAnbm9kZScgOiBjY3Bfbm9kZSwgJ2luc3QnIDogY2NwX2luc3QgfTtcblx0XHR9LFxuXHRcdC8qKlxuXHRcdCAqIGNoZWNrIGlmIHRoZXJlIGlzIHNvbWV0aGluZyBpbiB0aGUgYnVmZmVyIHRvIHBhc3RlXG5cdFx0ICogQG5hbWUgY2FuX3Bhc3RlKClcblx0XHQgKiBAcmV0dXJuIHtCb29sZWFufVxuXHRcdCAqL1xuXHRcdGNhbl9wYXN0ZSA6IGZ1bmN0aW9uICgpIHtcblx0XHRcdHJldHVybiBjY3BfbW9kZSAhPT0gZmFsc2UgJiYgY2NwX25vZGUgIT09IGZhbHNlOyAvLyAmJiBjY3BfaW5zdC5fbW9kZWwuZGF0YVtjY3Bfbm9kZV07XG5cdFx0fSxcblx0XHQvKipcblx0XHQgKiBjb3B5IG9yIG1vdmUgdGhlIHByZXZpb3VzbHkgY3V0IG9yIGNvcGllZCBub2RlcyB0byBhIG5ldyBwYXJlbnRcblx0XHQgKiBAbmFtZSBwYXN0ZShvYmogWywgcG9zXSlcblx0XHQgKiBAcGFyYW0gIHttaXhlZH0gb2JqIHRoZSBuZXcgcGFyZW50XG5cdFx0ICogQHBhcmFtICB7bWl4ZWR9IHBvcyB0aGUgcG9zaXRpb24gdG8gaW5zZXJ0IGF0IChiZXNpZGVzIGludGVnZXIsIFwiZmlyc3RcIiBhbmQgXCJsYXN0XCIgYXJlIHN1cHBvcnRlZCksIGRlZmF1bHRzIHRvIGludGVnZXIgYDBgXG5cdFx0ICogQHRyaWdnZXIgcGFzdGUuanN0cmVlXG5cdFx0ICovXG5cdFx0cGFzdGUgOiBmdW5jdGlvbiAob2JqLCBwb3MpIHtcblx0XHRcdG9iaiA9IHRoaXMuZ2V0X25vZGUob2JqKTtcblx0XHRcdGlmKCFvYmogfHwgIWNjcF9tb2RlIHx8ICFjY3BfbW9kZS5tYXRjaCgvXihjb3B5X25vZGV8bW92ZV9ub2RlKSQvKSB8fCAhY2NwX25vZGUpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdFx0XHRpZih0aGlzW2NjcF9tb2RlXShjY3Bfbm9kZSwgb2JqLCBwb3MsIGZhbHNlLCBmYWxzZSwgZmFsc2UsIGNjcF9pbnN0KSkge1xuXHRcdFx0XHQvKipcblx0XHRcdFx0ICogdHJpZ2dlcmVkIHdoZW4gcGFzdGUgaXMgaW52b2tlZFxuXHRcdFx0XHQgKiBAZXZlbnRcblx0XHRcdFx0ICogQG5hbWUgcGFzdGUuanN0cmVlXG5cdFx0XHRcdCAqIEBwYXJhbSB7U3RyaW5nfSBwYXJlbnQgdGhlIElEIG9mIHRoZSByZWNlaXZpbmcgbm9kZVxuXHRcdFx0XHQgKiBAcGFyYW0ge0FycmF5fSBub2RlIHRoZSBub2RlcyBpbiB0aGUgYnVmZmVyXG5cdFx0XHRcdCAqIEBwYXJhbSB7U3RyaW5nfSBtb2RlIHRoZSBwZXJmb3JtZWQgb3BlcmF0aW9uIC0gXCJjb3B5X25vZGVcIiBvciBcIm1vdmVfbm9kZVwiXG5cdFx0XHRcdCAqL1xuXHRcdFx0XHR0aGlzLnRyaWdnZXIoJ3Bhc3RlJywgeyBcInBhcmVudFwiIDogb2JqLmlkLCBcIm5vZGVcIiA6IGNjcF9ub2RlLCBcIm1vZGVcIiA6IGNjcF9tb2RlIH0pO1xuXHRcdFx0fVxuXHRcdFx0Y2NwX25vZGUgPSBmYWxzZTtcblx0XHRcdGNjcF9tb2RlID0gZmFsc2U7XG5cdFx0XHRjY3BfaW5zdCA9IGZhbHNlO1xuXHRcdH0sXG5cdFx0LyoqXG5cdFx0ICogY2xlYXIgdGhlIGJ1ZmZlciBvZiBwcmV2aW91c2x5IGNvcGllZCBvciBjdXQgbm9kZXNcblx0XHQgKiBAbmFtZSBjbGVhcl9idWZmZXIoKVxuXHRcdCAqIEB0cmlnZ2VyIGNsZWFyX2J1ZmZlci5qc3RyZWVcblx0XHQgKi9cblx0XHRjbGVhcl9idWZmZXIgOiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRjY3Bfbm9kZSA9IGZhbHNlO1xuXHRcdFx0Y2NwX21vZGUgPSBmYWxzZTtcblx0XHRcdGNjcF9pbnN0ID0gZmFsc2U7XG5cdFx0XHQvKipcblx0XHRcdCAqIHRyaWdnZXJlZCB3aGVuIHRoZSBjb3B5IC8gY3V0IGJ1ZmZlciBpcyBjbGVhcmVkXG5cdFx0XHQgKiBAZXZlbnRcblx0XHRcdCAqIEBuYW1lIGNsZWFyX2J1ZmZlci5qc3RyZWVcblx0XHRcdCAqL1xuXHRcdFx0dGhpcy50cmlnZ2VyKCdjbGVhcl9idWZmZXInKTtcblx0XHR9LFxuXHRcdC8qKlxuXHRcdCAqIHB1dCBhIG5vZGUgaW4gZWRpdCBtb2RlIChpbnB1dCBmaWVsZCB0byByZW5hbWUgdGhlIG5vZGUpXG5cdFx0ICogQG5hbWUgZWRpdChvYmogWywgZGVmYXVsdF90ZXh0LCBjYWxsYmFja10pXG5cdFx0ICogQHBhcmFtICB7bWl4ZWR9IG9ialxuXHRcdCAqIEBwYXJhbSAge1N0cmluZ30gZGVmYXVsdF90ZXh0IHRoZSB0ZXh0IHRvIHBvcHVsYXRlIHRoZSBpbnB1dCB3aXRoIChpZiBvbWl0dGVkIG9yIHNldCB0byBhIG5vbi1zdHJpbmcgdmFsdWUgdGhlIG5vZGUncyB0ZXh0IHZhbHVlIGlzIHVzZWQpXG5cdFx0ICogQHBhcmFtICB7RnVuY3Rpb259IGNhbGxiYWNrIGEgZnVuY3Rpb24gdG8gYmUgY2FsbGVkIG9uY2UgdGhlIHRleHQgYm94IGlzIGJsdXJyZWQsIGl0IGlzIGNhbGxlZCBpbiB0aGUgaW5zdGFuY2UncyBzY29wZSBhbmQgcmVjZWl2ZXMgdGhlIG5vZGUsIGEgc3RhdHVzIHBhcmFtZXRlciAodHJ1ZSBpZiB0aGUgcmVuYW1lIGlzIHN1Y2Nlc3NmdWwsIGZhbHNlIG90aGVyd2lzZSkgYW5kIGEgYm9vbGVhbiBpbmRpY2F0aW5nIGlmIHRoZSB1c2VyIGNhbmNlbGxlZCB0aGUgZWRpdC4gWW91IGNhbiBhY2Nlc3MgdGhlIG5vZGUncyB0aXRsZSB1c2luZyAudGV4dFxuXHRcdCAqL1xuXHRcdGVkaXQgOiBmdW5jdGlvbiAob2JqLCBkZWZhdWx0X3RleHQsIGNhbGxiYWNrKSB7XG5cdFx0XHR2YXIgcnRsLCB3LCBhLCBzLCB0LCBoMSwgaDIsIGZuLCB0bXAsIGNhbmNlbCA9IGZhbHNlO1xuXHRcdFx0b2JqID0gdGhpcy5nZXRfbm9kZShvYmopO1xuXHRcdFx0aWYoIW9iaikgeyByZXR1cm4gZmFsc2U7IH1cblx0XHRcdGlmKHRoaXMuc2V0dGluZ3MuY29yZS5jaGVja19jYWxsYmFjayA9PT0gZmFsc2UpIHtcblx0XHRcdFx0dGhpcy5fZGF0YS5jb3JlLmxhc3RfZXJyb3IgPSB7ICdlcnJvcicgOiAnY2hlY2snLCAncGx1Z2luJyA6ICdjb3JlJywgJ2lkJyA6ICdjb3JlXzA3JywgJ3JlYXNvbicgOiAnQ291bGQgbm90IGVkaXQgbm9kZSBiZWNhdXNlIG9mIGNoZWNrX2NhbGxiYWNrJyB9O1xuXHRcdFx0XHR0aGlzLnNldHRpbmdzLmNvcmUuZXJyb3IuY2FsbCh0aGlzLCB0aGlzLl9kYXRhLmNvcmUubGFzdF9lcnJvcik7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblx0XHRcdHRtcCA9IG9iajtcblx0XHRcdGRlZmF1bHRfdGV4dCA9IHR5cGVvZiBkZWZhdWx0X3RleHQgPT09ICdzdHJpbmcnID8gZGVmYXVsdF90ZXh0IDogb2JqLnRleHQ7XG5cdFx0XHR0aGlzLnNldF90ZXh0KG9iaiwgXCJcIik7XG5cdFx0XHRvYmogPSB0aGlzLl9vcGVuX3RvKG9iaik7XG5cdFx0XHR0bXAudGV4dCA9IGRlZmF1bHRfdGV4dDtcblxuXHRcdFx0cnRsID0gdGhpcy5fZGF0YS5jb3JlLnJ0bDtcblx0XHRcdHcgID0gdGhpcy5lbGVtZW50LndpZHRoKCk7XG5cdFx0XHR0aGlzLl9kYXRhLmNvcmUuZm9jdXNlZCA9IHRtcC5pZDtcblx0XHRcdGEgID0gb2JqLmNoaWxkcmVuKCcuanN0cmVlLWFuY2hvcicpLmZvY3VzKCk7XG5cdFx0XHRzICA9ICQoJzxzcGFuPicpO1xuXHRcdFx0LyohXG5cdFx0XHRvaSA9IG9iai5jaGlsZHJlbihcImk6dmlzaWJsZVwiKSxcblx0XHRcdGFpID0gYS5jaGlsZHJlbihcImk6dmlzaWJsZVwiKSxcblx0XHRcdHcxID0gb2kud2lkdGgoKSAqIG9pLmxlbmd0aCxcblx0XHRcdHcyID0gYWkud2lkdGgoKSAqIGFpLmxlbmd0aCxcblx0XHRcdCovXG5cdFx0XHR0ICA9IGRlZmF1bHRfdGV4dDtcblx0XHRcdGgxID0gJChcIjxcIitcImRpdiAvPlwiLCB7IGNzcyA6IHsgXCJwb3NpdGlvblwiIDogXCJhYnNvbHV0ZVwiLCBcInRvcFwiIDogXCItMjAwcHhcIiwgXCJsZWZ0XCIgOiAocnRsID8gXCIwcHhcIiA6IFwiLTEwMDBweFwiKSwgXCJ2aXNpYmlsaXR5XCIgOiBcImhpZGRlblwiIH0gfSkuYXBwZW5kVG8oXCJib2R5XCIpO1xuXHRcdFx0aDIgPSAkKFwiPFwiK1wiaW5wdXQgLz5cIiwge1xuXHRcdFx0XHRcdFx0XCJ2YWx1ZVwiIDogdCxcblx0XHRcdFx0XHRcdFwiY2xhc3NcIiA6IFwianN0cmVlLXJlbmFtZS1pbnB1dFwiLFxuXHRcdFx0XHRcdFx0Ly8gXCJzaXplXCIgOiB0Lmxlbmd0aCxcblx0XHRcdFx0XHRcdFwiY3NzXCIgOiB7XG5cdFx0XHRcdFx0XHRcdFwicGFkZGluZ1wiIDogXCIwXCIsXG5cdFx0XHRcdFx0XHRcdFwiYm9yZGVyXCIgOiBcIjFweCBzb2xpZCBzaWx2ZXJcIixcblx0XHRcdFx0XHRcdFx0XCJib3gtc2l6aW5nXCIgOiBcImJvcmRlci1ib3hcIixcblx0XHRcdFx0XHRcdFx0XCJkaXNwbGF5XCIgOiBcImlubGluZS1ibG9ja1wiLFxuXHRcdFx0XHRcdFx0XHRcImhlaWdodFwiIDogKHRoaXMuX2RhdGEuY29yZS5saV9oZWlnaHQpICsgXCJweFwiLFxuXHRcdFx0XHRcdFx0XHRcImxpbmVIZWlnaHRcIiA6ICh0aGlzLl9kYXRhLmNvcmUubGlfaGVpZ2h0KSArIFwicHhcIixcblx0XHRcdFx0XHRcdFx0XCJ3aWR0aFwiIDogXCIxNTBweFwiIC8vIHdpbGwgYmUgc2V0IGEgYml0IGZ1cnRoZXIgZG93blxuXHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFwiYmx1clwiIDogJC5wcm94eShmdW5jdGlvbiAoZSkge1xuXHRcdFx0XHRcdFx0XHRlLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xuXHRcdFx0XHRcdFx0XHRlLnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHRcdFx0XHRcdHZhciBpID0gcy5jaGlsZHJlbihcIi5qc3RyZWUtcmVuYW1lLWlucHV0XCIpLFxuXHRcdFx0XHRcdFx0XHRcdHYgPSBpLnZhbCgpLFxuXHRcdFx0XHRcdFx0XHRcdGYgPSB0aGlzLnNldHRpbmdzLmNvcmUuZm9yY2VfdGV4dCxcblx0XHRcdFx0XHRcdFx0XHRudjtcblx0XHRcdFx0XHRcdFx0aWYodiA9PT0gXCJcIikgeyB2ID0gdDsgfVxuXHRcdFx0XHRcdFx0XHRoMS5yZW1vdmUoKTtcblx0XHRcdFx0XHRcdFx0cy5yZXBsYWNlV2l0aChhKTtcblx0XHRcdFx0XHRcdFx0cy5yZW1vdmUoKTtcblx0XHRcdFx0XHRcdFx0dCA9IGYgPyB0IDogJCgnPGRpdj48L2Rpdj4nKS5hcHBlbmQoJC5wYXJzZUhUTUwodCkpLmh0bWwoKTtcblx0XHRcdFx0XHRcdFx0dGhpcy5zZXRfdGV4dChvYmosIHQpO1xuXHRcdFx0XHRcdFx0XHRudiA9ICEhdGhpcy5yZW5hbWVfbm9kZShvYmosIGYgPyAkKCc8ZGl2PjwvZGl2PicpLnRleHQodikudGV4dCgpIDogJCgnPGRpdj48L2Rpdj4nKS5hcHBlbmQoJC5wYXJzZUhUTUwodikpLmh0bWwoKSk7XG5cdFx0XHRcdFx0XHRcdGlmKCFudikge1xuXHRcdFx0XHRcdFx0XHRcdHRoaXMuc2V0X3RleHQob2JqLCB0KTsgLy8gbW92ZSB0aGlzIHVwPyBhbmQgZml4ICM0ODNcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR0aGlzLl9kYXRhLmNvcmUuZm9jdXNlZCA9IHRtcC5pZDtcblx0XHRcdFx0XHRcdFx0c2V0VGltZW91dCgkLnByb3h5KGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0XHRcdFx0XHR2YXIgbm9kZSA9IHRoaXMuZ2V0X25vZGUodG1wLmlkLCB0cnVlKTtcblx0XHRcdFx0XHRcdFx0XHRpZihub2RlLmxlbmd0aCkge1xuXHRcdFx0XHRcdFx0XHRcdFx0dGhpcy5fZGF0YS5jb3JlLmZvY3VzZWQgPSB0bXAuaWQ7XG5cdFx0XHRcdFx0XHRcdFx0XHRub2RlLmNoaWxkcmVuKCcuanN0cmVlLWFuY2hvcicpLmZvY3VzKCk7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9LCB0aGlzKSwgMCk7XG5cdFx0XHRcdFx0XHRcdGlmKGNhbGxiYWNrKSB7XG5cdFx0XHRcdFx0XHRcdFx0Y2FsbGJhY2suY2FsbCh0aGlzLCB0bXAsIG52LCBjYW5jZWwpO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdGgyID0gbnVsbDtcblx0XHRcdFx0XHRcdH0sIHRoaXMpLFxuXHRcdFx0XHRcdFx0XCJrZXlkb3duXCIgOiBmdW5jdGlvbiAoZSkge1xuXHRcdFx0XHRcdFx0XHR2YXIga2V5ID0gZS53aGljaDtcblx0XHRcdFx0XHRcdFx0aWYoa2V5ID09PSAyNykge1xuXHRcdFx0XHRcdFx0XHRcdGNhbmNlbCA9IHRydWU7XG5cdFx0XHRcdFx0XHRcdFx0dGhpcy52YWx1ZSA9IHQ7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0aWYoa2V5ID09PSAyNyB8fCBrZXkgPT09IDEzIHx8IGtleSA9PT0gMzcgfHwga2V5ID09PSAzOCB8fCBrZXkgPT09IDM5IHx8IGtleSA9PT0gNDAgfHwga2V5ID09PSAzMikge1xuXHRcdFx0XHRcdFx0XHRcdGUuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0aWYoa2V5ID09PSAyNyB8fCBrZXkgPT09IDEzKSB7XG5cdFx0XHRcdFx0XHRcdFx0ZS5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0XHRcdFx0XHRcdHRoaXMuYmx1cigpO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XCJjbGlja1wiIDogZnVuY3Rpb24gKGUpIHsgZS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTsgfSxcblx0XHRcdFx0XHRcdFwibW91c2Vkb3duXCIgOiBmdW5jdGlvbiAoZSkgeyBlLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpOyB9LFxuXHRcdFx0XHRcdFx0XCJrZXl1cFwiIDogZnVuY3Rpb24gKGUpIHtcblx0XHRcdFx0XHRcdFx0aDIud2lkdGgoTWF0aC5taW4oaDEudGV4dChcInBXXCIgKyB0aGlzLnZhbHVlKS53aWR0aCgpLHcpKTtcblx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcImtleXByZXNzXCIgOiBmdW5jdGlvbihlKSB7XG5cdFx0XHRcdFx0XHRcdGlmKGUud2hpY2ggPT09IDEzKSB7IHJldHVybiBmYWxzZTsgfVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRmbiA9IHtcblx0XHRcdFx0XHRcdGZvbnRGYW1pbHlcdFx0OiBhLmNzcygnZm9udEZhbWlseScpXHRcdHx8ICcnLFxuXHRcdFx0XHRcdFx0Zm9udFNpemVcdFx0OiBhLmNzcygnZm9udFNpemUnKVx0XHRcdHx8ICcnLFxuXHRcdFx0XHRcdFx0Zm9udFdlaWdodFx0XHQ6IGEuY3NzKCdmb250V2VpZ2h0JylcdFx0fHwgJycsXG5cdFx0XHRcdFx0XHRmb250U3R5bGVcdFx0OiBhLmNzcygnZm9udFN0eWxlJylcdFx0fHwgJycsXG5cdFx0XHRcdFx0XHRmb250U3RyZXRjaFx0XHQ6IGEuY3NzKCdmb250U3RyZXRjaCcpXHRcdHx8ICcnLFxuXHRcdFx0XHRcdFx0Zm9udFZhcmlhbnRcdFx0OiBhLmNzcygnZm9udFZhcmlhbnQnKVx0XHR8fCAnJyxcblx0XHRcdFx0XHRcdGxldHRlclNwYWNpbmdcdDogYS5jc3MoJ2xldHRlclNwYWNpbmcnKVx0fHwgJycsXG5cdFx0XHRcdFx0XHR3b3JkU3BhY2luZ1x0XHQ6IGEuY3NzKCd3b3JkU3BhY2luZycpXHRcdHx8ICcnXG5cdFx0XHRcdH07XG5cdFx0XHRzLmF0dHIoJ2NsYXNzJywgYS5hdHRyKCdjbGFzcycpKS5hcHBlbmQoYS5jb250ZW50cygpLmNsb25lKCkpLmFwcGVuZChoMik7XG5cdFx0XHRhLnJlcGxhY2VXaXRoKHMpO1xuXHRcdFx0aDEuY3NzKGZuKTtcblx0XHRcdGgyLmNzcyhmbikud2lkdGgoTWF0aC5taW4oaDEudGV4dChcInBXXCIgKyBoMlswXS52YWx1ZSkud2lkdGgoKSx3KSlbMF0uc2VsZWN0KCk7XG5cdFx0XHQkKGRvY3VtZW50KS5vbmUoJ21vdXNlZG93bi5qc3RyZWUgdG91Y2hzdGFydC5qc3RyZWUgZG5kX3N0YXJ0LnZha2F0YScsIGZ1bmN0aW9uIChlKSB7XG5cdFx0XHRcdGlmIChoMiAmJiBlLnRhcmdldCAhPT0gaDIpIHtcblx0XHRcdFx0XHQkKGgyKS5ibHVyKCk7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdH0sXG5cblxuXHRcdC8qKlxuXHRcdCAqIGNoYW5nZXMgdGhlIHRoZW1lXG5cdFx0ICogQG5hbWUgc2V0X3RoZW1lKHRoZW1lX25hbWUgWywgdGhlbWVfdXJsXSlcblx0XHQgKiBAcGFyYW0ge1N0cmluZ30gdGhlbWVfbmFtZSB0aGUgbmFtZSBvZiB0aGUgbmV3IHRoZW1lIHRvIGFwcGx5XG5cdFx0ICogQHBhcmFtIHttaXhlZH0gdGhlbWVfdXJsICB0aGUgbG9jYXRpb24gb2YgdGhlIENTUyBmaWxlIGZvciB0aGlzIHRoZW1lLiBPbWl0IG9yIHNldCB0byBgZmFsc2VgIGlmIHlvdSBtYW51YWxseSBpbmNsdWRlZCB0aGUgZmlsZS4gU2V0IHRvIGB0cnVlYCB0byBhdXRvbG9hZCBmcm9tIHRoZSBgY29yZS50aGVtZXMuZGlyYCBkaXJlY3RvcnkuXG5cdFx0ICogQHRyaWdnZXIgc2V0X3RoZW1lLmpzdHJlZVxuXHRcdCAqL1xuXHRcdHNldF90aGVtZSA6IGZ1bmN0aW9uICh0aGVtZV9uYW1lLCB0aGVtZV91cmwpIHtcblx0XHRcdGlmKCF0aGVtZV9uYW1lKSB7IHJldHVybiBmYWxzZTsgfVxuXHRcdFx0aWYodGhlbWVfdXJsID09PSB0cnVlKSB7XG5cdFx0XHRcdHZhciBkaXIgPSB0aGlzLnNldHRpbmdzLmNvcmUudGhlbWVzLmRpcjtcblx0XHRcdFx0aWYoIWRpcikgeyBkaXIgPSAkLmpzdHJlZS5wYXRoICsgJy90aGVtZXMnOyB9XG5cdFx0XHRcdHRoZW1lX3VybCA9IGRpciArICcvJyArIHRoZW1lX25hbWUgKyAnL3N0eWxlLmNzcyc7XG5cdFx0XHR9XG5cdFx0XHRpZih0aGVtZV91cmwgJiYgJC5pbkFycmF5KHRoZW1lX3VybCwgdGhlbWVzX2xvYWRlZCkgPT09IC0xKSB7XG5cdFx0XHRcdCQoJ2hlYWQnKS5hcHBlbmQoJzwnKydsaW5rIHJlbD1cInN0eWxlc2hlZXRcIiBocmVmPVwiJyArIHRoZW1lX3VybCArICdcIiB0eXBlPVwidGV4dC9jc3NcIiAvPicpO1xuXHRcdFx0XHR0aGVtZXNfbG9hZGVkLnB1c2godGhlbWVfdXJsKTtcblx0XHRcdH1cblx0XHRcdGlmKHRoaXMuX2RhdGEuY29yZS50aGVtZXMubmFtZSkge1xuXHRcdFx0XHR0aGlzLmVsZW1lbnQucmVtb3ZlQ2xhc3MoJ2pzdHJlZS0nICsgdGhpcy5fZGF0YS5jb3JlLnRoZW1lcy5uYW1lKTtcblx0XHRcdH1cblx0XHRcdHRoaXMuX2RhdGEuY29yZS50aGVtZXMubmFtZSA9IHRoZW1lX25hbWU7XG5cdFx0XHR0aGlzLmVsZW1lbnQuYWRkQ2xhc3MoJ2pzdHJlZS0nICsgdGhlbWVfbmFtZSk7XG5cdFx0XHR0aGlzLmVsZW1lbnRbdGhpcy5zZXR0aW5ncy5jb3JlLnRoZW1lcy5yZXNwb25zaXZlID8gJ2FkZENsYXNzJyA6ICdyZW1vdmVDbGFzcycgXSgnanN0cmVlLScgKyB0aGVtZV9uYW1lICsgJy1yZXNwb25zaXZlJyk7XG5cdFx0XHQvKipcblx0XHRcdCAqIHRyaWdnZXJlZCB3aGVuIGEgdGhlbWUgaXMgc2V0XG5cdFx0XHQgKiBAZXZlbnRcblx0XHRcdCAqIEBuYW1lIHNldF90aGVtZS5qc3RyZWVcblx0XHRcdCAqIEBwYXJhbSB7U3RyaW5nfSB0aGVtZSB0aGUgbmV3IHRoZW1lXG5cdFx0XHQgKi9cblx0XHRcdHRoaXMudHJpZ2dlcignc2V0X3RoZW1lJywgeyAndGhlbWUnIDogdGhlbWVfbmFtZSB9KTtcblx0XHR9LFxuXHRcdC8qKlxuXHRcdCAqIGdldHMgdGhlIG5hbWUgb2YgdGhlIGN1cnJlbnRseSBhcHBsaWVkIHRoZW1lIG5hbWVcblx0XHQgKiBAbmFtZSBnZXRfdGhlbWUoKVxuXHRcdCAqIEByZXR1cm4ge1N0cmluZ31cblx0XHQgKi9cblx0XHRnZXRfdGhlbWUgOiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9kYXRhLmNvcmUudGhlbWVzLm5hbWU7IH0sXG5cdFx0LyoqXG5cdFx0ICogY2hhbmdlcyB0aGUgdGhlbWUgdmFyaWFudCAoaWYgdGhlIHRoZW1lIGhhcyB2YXJpYW50cylcblx0XHQgKiBAbmFtZSBzZXRfdGhlbWVfdmFyaWFudCh2YXJpYW50X25hbWUpXG5cdFx0ICogQHBhcmFtIHtTdHJpbmd8Qm9vbGVhbn0gdmFyaWFudF9uYW1lIHRoZSB2YXJpYW50IHRvIGFwcGx5IChpZiBgZmFsc2VgIGlzIHVzZWQgdGhlIGN1cnJlbnQgdmFyaWFudCBpcyByZW1vdmVkKVxuXHRcdCAqL1xuXHRcdHNldF90aGVtZV92YXJpYW50IDogZnVuY3Rpb24gKHZhcmlhbnRfbmFtZSkge1xuXHRcdFx0aWYodGhpcy5fZGF0YS5jb3JlLnRoZW1lcy52YXJpYW50KSB7XG5cdFx0XHRcdHRoaXMuZWxlbWVudC5yZW1vdmVDbGFzcygnanN0cmVlLScgKyB0aGlzLl9kYXRhLmNvcmUudGhlbWVzLm5hbWUgKyAnLScgKyB0aGlzLl9kYXRhLmNvcmUudGhlbWVzLnZhcmlhbnQpO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5fZGF0YS5jb3JlLnRoZW1lcy52YXJpYW50ID0gdmFyaWFudF9uYW1lO1xuXHRcdFx0aWYodmFyaWFudF9uYW1lKSB7XG5cdFx0XHRcdHRoaXMuZWxlbWVudC5hZGRDbGFzcygnanN0cmVlLScgKyB0aGlzLl9kYXRhLmNvcmUudGhlbWVzLm5hbWUgKyAnLScgKyB0aGlzLl9kYXRhLmNvcmUudGhlbWVzLnZhcmlhbnQpO1xuXHRcdFx0fVxuXHRcdH0sXG5cdFx0LyoqXG5cdFx0ICogZ2V0cyB0aGUgbmFtZSBvZiB0aGUgY3VycmVudGx5IGFwcGxpZWQgdGhlbWUgdmFyaWFudFxuXHRcdCAqIEBuYW1lIGdldF90aGVtZSgpXG5cdFx0ICogQHJldHVybiB7U3RyaW5nfVxuXHRcdCAqL1xuXHRcdGdldF90aGVtZV92YXJpYW50IDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fZGF0YS5jb3JlLnRoZW1lcy52YXJpYW50OyB9LFxuXHRcdC8qKlxuXHRcdCAqIHNob3dzIGEgc3RyaXBlZCBiYWNrZ3JvdW5kIG9uIHRoZSBjb250YWluZXIgKGlmIHRoZSB0aGVtZSBzdXBwb3J0cyBpdClcblx0XHQgKiBAbmFtZSBzaG93X3N0cmlwZXMoKVxuXHRcdCAqL1xuXHRcdHNob3dfc3RyaXBlcyA6IGZ1bmN0aW9uICgpIHtcblx0XHRcdHRoaXMuX2RhdGEuY29yZS50aGVtZXMuc3RyaXBlcyA9IHRydWU7XG5cdFx0XHR0aGlzLmdldF9jb250YWluZXJfdWwoKS5hZGRDbGFzcyhcImpzdHJlZS1zdHJpcGVkXCIpO1xuXHRcdFx0LyoqXG5cdFx0XHQgKiB0cmlnZ2VyZWQgd2hlbiBzdHJpcGVzIGFyZSBzaG93blxuXHRcdFx0ICogQGV2ZW50XG5cdFx0XHQgKiBAbmFtZSBzaG93X3N0cmlwZXMuanN0cmVlXG5cdFx0XHQgKi9cblx0XHRcdHRoaXMudHJpZ2dlcignc2hvd19zdHJpcGVzJyk7XG5cdFx0fSxcblx0XHQvKipcblx0XHQgKiBoaWRlcyB0aGUgc3RyaXBlZCBiYWNrZ3JvdW5kIG9uIHRoZSBjb250YWluZXJcblx0XHQgKiBAbmFtZSBoaWRlX3N0cmlwZXMoKVxuXHRcdCAqL1xuXHRcdGhpZGVfc3RyaXBlcyA6IGZ1bmN0aW9uICgpIHtcblx0XHRcdHRoaXMuX2RhdGEuY29yZS50aGVtZXMuc3RyaXBlcyA9IGZhbHNlO1xuXHRcdFx0dGhpcy5nZXRfY29udGFpbmVyX3VsKCkucmVtb3ZlQ2xhc3MoXCJqc3RyZWUtc3RyaXBlZFwiKTtcblx0XHRcdC8qKlxuXHRcdFx0ICogdHJpZ2dlcmVkIHdoZW4gc3RyaXBlcyBhcmUgaGlkZGVuXG5cdFx0XHQgKiBAZXZlbnRcblx0XHRcdCAqIEBuYW1lIGhpZGVfc3RyaXBlcy5qc3RyZWVcblx0XHRcdCAqL1xuXHRcdFx0dGhpcy50cmlnZ2VyKCdoaWRlX3N0cmlwZXMnKTtcblx0XHR9LFxuXHRcdC8qKlxuXHRcdCAqIHRvZ2dsZXMgdGhlIHN0cmlwZWQgYmFja2dyb3VuZCBvbiB0aGUgY29udGFpbmVyXG5cdFx0ICogQG5hbWUgdG9nZ2xlX3N0cmlwZXMoKVxuXHRcdCAqL1xuXHRcdHRvZ2dsZV9zdHJpcGVzIDogZnVuY3Rpb24gKCkgeyBpZih0aGlzLl9kYXRhLmNvcmUudGhlbWVzLnN0cmlwZXMpIHsgdGhpcy5oaWRlX3N0cmlwZXMoKTsgfSBlbHNlIHsgdGhpcy5zaG93X3N0cmlwZXMoKTsgfSB9LFxuXHRcdC8qKlxuXHRcdCAqIHNob3dzIHRoZSBjb25uZWN0aW5nIGRvdHMgKGlmIHRoZSB0aGVtZSBzdXBwb3J0cyBpdClcblx0XHQgKiBAbmFtZSBzaG93X2RvdHMoKVxuXHRcdCAqL1xuXHRcdHNob3dfZG90cyA6IGZ1bmN0aW9uICgpIHtcblx0XHRcdHRoaXMuX2RhdGEuY29yZS50aGVtZXMuZG90cyA9IHRydWU7XG5cdFx0XHR0aGlzLmdldF9jb250YWluZXJfdWwoKS5yZW1vdmVDbGFzcyhcImpzdHJlZS1uby1kb3RzXCIpO1xuXHRcdFx0LyoqXG5cdFx0XHQgKiB0cmlnZ2VyZWQgd2hlbiBkb3RzIGFyZSBzaG93blxuXHRcdFx0ICogQGV2ZW50XG5cdFx0XHQgKiBAbmFtZSBzaG93X2RvdHMuanN0cmVlXG5cdFx0XHQgKi9cblx0XHRcdHRoaXMudHJpZ2dlcignc2hvd19kb3RzJyk7XG5cdFx0fSxcblx0XHQvKipcblx0XHQgKiBoaWRlcyB0aGUgY29ubmVjdGluZyBkb3RzXG5cdFx0ICogQG5hbWUgaGlkZV9kb3RzKClcblx0XHQgKi9cblx0XHRoaWRlX2RvdHMgOiBmdW5jdGlvbiAoKSB7XG5cdFx0XHR0aGlzLl9kYXRhLmNvcmUudGhlbWVzLmRvdHMgPSBmYWxzZTtcblx0XHRcdHRoaXMuZ2V0X2NvbnRhaW5lcl91bCgpLmFkZENsYXNzKFwianN0cmVlLW5vLWRvdHNcIik7XG5cdFx0XHQvKipcblx0XHRcdCAqIHRyaWdnZXJlZCB3aGVuIGRvdHMgYXJlIGhpZGRlblxuXHRcdFx0ICogQGV2ZW50XG5cdFx0XHQgKiBAbmFtZSBoaWRlX2RvdHMuanN0cmVlXG5cdFx0XHQgKi9cblx0XHRcdHRoaXMudHJpZ2dlcignaGlkZV9kb3RzJyk7XG5cdFx0fSxcblx0XHQvKipcblx0XHQgKiB0b2dnbGVzIHRoZSBjb25uZWN0aW5nIGRvdHNcblx0XHQgKiBAbmFtZSB0b2dnbGVfZG90cygpXG5cdFx0ICovXG5cdFx0dG9nZ2xlX2RvdHMgOiBmdW5jdGlvbiAoKSB7IGlmKHRoaXMuX2RhdGEuY29yZS50aGVtZXMuZG90cykgeyB0aGlzLmhpZGVfZG90cygpOyB9IGVsc2UgeyB0aGlzLnNob3dfZG90cygpOyB9IH0sXG5cdFx0LyoqXG5cdFx0ICogc2hvdyB0aGUgbm9kZSBpY29uc1xuXHRcdCAqIEBuYW1lIHNob3dfaWNvbnMoKVxuXHRcdCAqL1xuXHRcdHNob3dfaWNvbnMgOiBmdW5jdGlvbiAoKSB7XG5cdFx0XHR0aGlzLl9kYXRhLmNvcmUudGhlbWVzLmljb25zID0gdHJ1ZTtcblx0XHRcdHRoaXMuZ2V0X2NvbnRhaW5lcl91bCgpLnJlbW92ZUNsYXNzKFwianN0cmVlLW5vLWljb25zXCIpO1xuXHRcdFx0LyoqXG5cdFx0XHQgKiB0cmlnZ2VyZWQgd2hlbiBpY29ucyBhcmUgc2hvd25cblx0XHRcdCAqIEBldmVudFxuXHRcdFx0ICogQG5hbWUgc2hvd19pY29ucy5qc3RyZWVcblx0XHRcdCAqL1xuXHRcdFx0dGhpcy50cmlnZ2VyKCdzaG93X2ljb25zJyk7XG5cdFx0fSxcblx0XHQvKipcblx0XHQgKiBoaWRlIHRoZSBub2RlIGljb25zXG5cdFx0ICogQG5hbWUgaGlkZV9pY29ucygpXG5cdFx0ICovXG5cdFx0aGlkZV9pY29ucyA6IGZ1bmN0aW9uICgpIHtcblx0XHRcdHRoaXMuX2RhdGEuY29yZS50aGVtZXMuaWNvbnMgPSBmYWxzZTtcblx0XHRcdHRoaXMuZ2V0X2NvbnRhaW5lcl91bCgpLmFkZENsYXNzKFwianN0cmVlLW5vLWljb25zXCIpO1xuXHRcdFx0LyoqXG5cdFx0XHQgKiB0cmlnZ2VyZWQgd2hlbiBpY29ucyBhcmUgaGlkZGVuXG5cdFx0XHQgKiBAZXZlbnRcblx0XHRcdCAqIEBuYW1lIGhpZGVfaWNvbnMuanN0cmVlXG5cdFx0XHQgKi9cblx0XHRcdHRoaXMudHJpZ2dlcignaGlkZV9pY29ucycpO1xuXHRcdH0sXG5cdFx0LyoqXG5cdFx0ICogdG9nZ2xlIHRoZSBub2RlIGljb25zXG5cdFx0ICogQG5hbWUgdG9nZ2xlX2ljb25zKClcblx0XHQgKi9cblx0XHR0b2dnbGVfaWNvbnMgOiBmdW5jdGlvbiAoKSB7IGlmKHRoaXMuX2RhdGEuY29yZS50aGVtZXMuaWNvbnMpIHsgdGhpcy5oaWRlX2ljb25zKCk7IH0gZWxzZSB7IHRoaXMuc2hvd19pY29ucygpOyB9IH0sXG5cdFx0LyoqXG5cdFx0ICogc2hvdyB0aGUgbm9kZSBlbGxpcHNpc1xuXHRcdCAqIEBuYW1lIHNob3dfaWNvbnMoKVxuXHRcdCAqL1xuXHRcdHNob3dfZWxsaXBzaXMgOiBmdW5jdGlvbiAoKSB7XG5cdFx0XHR0aGlzLl9kYXRhLmNvcmUudGhlbWVzLmVsbGlwc2lzID0gdHJ1ZTtcblx0XHRcdHRoaXMuZ2V0X2NvbnRhaW5lcl91bCgpLmFkZENsYXNzKFwianN0cmVlLWVsbGlwc2lzXCIpO1xuXHRcdFx0LyoqXG5cdFx0XHQgKiB0cmlnZ2VyZWQgd2hlbiBlbGxpc2lzIGlzIHNob3duXG5cdFx0XHQgKiBAZXZlbnRcblx0XHRcdCAqIEBuYW1lIHNob3dfZWxsaXBzaXMuanN0cmVlXG5cdFx0XHQgKi9cblx0XHRcdHRoaXMudHJpZ2dlcignc2hvd19lbGxpcHNpcycpO1xuXHRcdH0sXG5cdFx0LyoqXG5cdFx0ICogaGlkZSB0aGUgbm9kZSBlbGxpcHNpc1xuXHRcdCAqIEBuYW1lIGhpZGVfZWxsaXBzaXMoKVxuXHRcdCAqL1xuXHRcdGhpZGVfZWxsaXBzaXMgOiBmdW5jdGlvbiAoKSB7XG5cdFx0XHR0aGlzLl9kYXRhLmNvcmUudGhlbWVzLmVsbGlwc2lzID0gZmFsc2U7XG5cdFx0XHR0aGlzLmdldF9jb250YWluZXJfdWwoKS5yZW1vdmVDbGFzcyhcImpzdHJlZS1lbGxpcHNpc1wiKTtcblx0XHRcdC8qKlxuXHRcdFx0ICogdHJpZ2dlcmVkIHdoZW4gZWxsaXNpcyBpcyBoaWRkZW5cblx0XHRcdCAqIEBldmVudFxuXHRcdFx0ICogQG5hbWUgaGlkZV9lbGxpcHNpcy5qc3RyZWVcblx0XHRcdCAqL1xuXHRcdFx0dGhpcy50cmlnZ2VyKCdoaWRlX2VsbGlwc2lzJyk7XG5cdFx0fSxcblx0XHQvKipcblx0XHQgKiB0b2dnbGUgdGhlIG5vZGUgZWxsaXBzaXNcblx0XHQgKiBAbmFtZSB0b2dnbGVfaWNvbnMoKVxuXHRcdCAqL1xuXHRcdHRvZ2dsZV9lbGxpcHNpcyA6IGZ1bmN0aW9uICgpIHsgaWYodGhpcy5fZGF0YS5jb3JlLnRoZW1lcy5lbGxpcHNpcykgeyB0aGlzLmhpZGVfZWxsaXBzaXMoKTsgfSBlbHNlIHsgdGhpcy5zaG93X2VsbGlwc2lzKCk7IH0gfSxcblx0XHQvKipcblx0XHQgKiBzZXQgdGhlIG5vZGUgaWNvbiBmb3IgYSBub2RlXG5cdFx0ICogQG5hbWUgc2V0X2ljb24ob2JqLCBpY29uKVxuXHRcdCAqIEBwYXJhbSB7bWl4ZWR9IG9ialxuXHRcdCAqIEBwYXJhbSB7U3RyaW5nfSBpY29uIHRoZSBuZXcgaWNvbiAtIGNhbiBiZSBhIHBhdGggdG8gYW4gaWNvbiBvciBhIGNsYXNzTmFtZSwgaWYgdXNpbmcgYW4gaW1hZ2UgdGhhdCBpcyBpbiB0aGUgY3VycmVudCBkaXJlY3RvcnkgdXNlIGEgYC4vYCBwcmVmaXgsIG90aGVyd2lzZSBpdCB3aWxsIGJlIGRldGVjdGVkIGFzIGEgY2xhc3Ncblx0XHQgKi9cblx0XHRzZXRfaWNvbiA6IGZ1bmN0aW9uIChvYmosIGljb24pIHtcblx0XHRcdHZhciB0MSwgdDIsIGRvbSwgb2xkO1xuXHRcdFx0aWYoJC5pc0FycmF5KG9iaikpIHtcblx0XHRcdFx0b2JqID0gb2JqLnNsaWNlKCk7XG5cdFx0XHRcdGZvcih0MSA9IDAsIHQyID0gb2JqLmxlbmd0aDsgdDEgPCB0MjsgdDErKykge1xuXHRcdFx0XHRcdHRoaXMuc2V0X2ljb24ob2JqW3QxXSwgaWNvbik7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9XG5cdFx0XHRvYmogPSB0aGlzLmdldF9ub2RlKG9iaik7XG5cdFx0XHRpZighb2JqIHx8IG9iai5pZCA9PT0gJC5qc3RyZWUucm9vdCkgeyByZXR1cm4gZmFsc2U7IH1cblx0XHRcdG9sZCA9IG9iai5pY29uO1xuXHRcdFx0b2JqLmljb24gPSBpY29uID09PSB0cnVlIHx8IGljb24gPT09IG51bGwgfHwgaWNvbiA9PT0gdW5kZWZpbmVkIHx8IGljb24gPT09ICcnID8gdHJ1ZSA6IGljb247XG5cdFx0XHRkb20gPSB0aGlzLmdldF9ub2RlKG9iaiwgdHJ1ZSkuY2hpbGRyZW4oXCIuanN0cmVlLWFuY2hvclwiKS5jaGlsZHJlbihcIi5qc3RyZWUtdGhlbWVpY29uXCIpO1xuXHRcdFx0aWYoaWNvbiA9PT0gZmFsc2UpIHtcblx0XHRcdFx0dGhpcy5oaWRlX2ljb24ob2JqKTtcblx0XHRcdH1cblx0XHRcdGVsc2UgaWYoaWNvbiA9PT0gdHJ1ZSB8fCBpY29uID09PSBudWxsIHx8IGljb24gPT09IHVuZGVmaW5lZCB8fCBpY29uID09PSAnJykge1xuXHRcdFx0XHRkb20ucmVtb3ZlQ2xhc3MoJ2pzdHJlZS10aGVtZWljb24tY3VzdG9tICcgKyBvbGQpLmNzcyhcImJhY2tncm91bmRcIixcIlwiKS5yZW1vdmVBdHRyKFwicmVsXCIpO1xuXHRcdFx0XHRpZihvbGQgPT09IGZhbHNlKSB7IHRoaXMuc2hvd19pY29uKG9iaik7IH1cblx0XHRcdH1cblx0XHRcdGVsc2UgaWYoaWNvbi5pbmRleE9mKFwiL1wiKSA9PT0gLTEgJiYgaWNvbi5pbmRleE9mKFwiLlwiKSA9PT0gLTEpIHtcblx0XHRcdFx0ZG9tLnJlbW92ZUNsYXNzKG9sZCkuY3NzKFwiYmFja2dyb3VuZFwiLFwiXCIpO1xuXHRcdFx0XHRkb20uYWRkQ2xhc3MoaWNvbiArICcganN0cmVlLXRoZW1laWNvbi1jdXN0b20nKS5hdHRyKFwicmVsXCIsaWNvbik7XG5cdFx0XHRcdGlmKG9sZCA9PT0gZmFsc2UpIHsgdGhpcy5zaG93X2ljb24ob2JqKTsgfVxuXHRcdFx0fVxuXHRcdFx0ZWxzZSB7XG5cdFx0XHRcdGRvbS5yZW1vdmVDbGFzcyhvbGQpLmNzcyhcImJhY2tncm91bmRcIixcIlwiKTtcblx0XHRcdFx0ZG9tLmFkZENsYXNzKCdqc3RyZWUtdGhlbWVpY29uLWN1c3RvbScpLmNzcyhcImJhY2tncm91bmRcIiwgXCJ1cmwoJ1wiICsgaWNvbiArIFwiJykgY2VudGVyIGNlbnRlciBuby1yZXBlYXRcIikuYXR0cihcInJlbFwiLGljb24pO1xuXHRcdFx0XHRpZihvbGQgPT09IGZhbHNlKSB7IHRoaXMuc2hvd19pY29uKG9iaik7IH1cblx0XHRcdH1cblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH0sXG5cdFx0LyoqXG5cdFx0ICogZ2V0IHRoZSBub2RlIGljb24gZm9yIGEgbm9kZVxuXHRcdCAqIEBuYW1lIGdldF9pY29uKG9iailcblx0XHQgKiBAcGFyYW0ge21peGVkfSBvYmpcblx0XHQgKiBAcmV0dXJuIHtTdHJpbmd9XG5cdFx0ICovXG5cdFx0Z2V0X2ljb24gOiBmdW5jdGlvbiAob2JqKSB7XG5cdFx0XHRvYmogPSB0aGlzLmdldF9ub2RlKG9iaik7XG5cdFx0XHRyZXR1cm4gKCFvYmogfHwgb2JqLmlkID09PSAkLmpzdHJlZS5yb290KSA/IGZhbHNlIDogb2JqLmljb247XG5cdFx0fSxcblx0XHQvKipcblx0XHQgKiBoaWRlIHRoZSBpY29uIG9uIGFuIGluZGl2aWR1YWwgbm9kZVxuXHRcdCAqIEBuYW1lIGhpZGVfaWNvbihvYmopXG5cdFx0ICogQHBhcmFtIHttaXhlZH0gb2JqXG5cdFx0ICovXG5cdFx0aGlkZV9pY29uIDogZnVuY3Rpb24gKG9iaikge1xuXHRcdFx0dmFyIHQxLCB0Mjtcblx0XHRcdGlmKCQuaXNBcnJheShvYmopKSB7XG5cdFx0XHRcdG9iaiA9IG9iai5zbGljZSgpO1xuXHRcdFx0XHRmb3IodDEgPSAwLCB0MiA9IG9iai5sZW5ndGg7IHQxIDwgdDI7IHQxKyspIHtcblx0XHRcdFx0XHR0aGlzLmhpZGVfaWNvbihvYmpbdDFdKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblx0XHRcdG9iaiA9IHRoaXMuZ2V0X25vZGUob2JqKTtcblx0XHRcdGlmKCFvYmogfHwgb2JqID09PSAkLmpzdHJlZS5yb290KSB7IHJldHVybiBmYWxzZTsgfVxuXHRcdFx0b2JqLmljb24gPSBmYWxzZTtcblx0XHRcdHRoaXMuZ2V0X25vZGUob2JqLCB0cnVlKS5jaGlsZHJlbihcIi5qc3RyZWUtYW5jaG9yXCIpLmNoaWxkcmVuKFwiLmpzdHJlZS10aGVtZWljb25cIikuYWRkQ2xhc3MoJ2pzdHJlZS10aGVtZWljb24taGlkZGVuJyk7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9LFxuXHRcdC8qKlxuXHRcdCAqIHNob3cgdGhlIGljb24gb24gYW4gaW5kaXZpZHVhbCBub2RlXG5cdFx0ICogQG5hbWUgc2hvd19pY29uKG9iailcblx0XHQgKiBAcGFyYW0ge21peGVkfSBvYmpcblx0XHQgKi9cblx0XHRzaG93X2ljb24gOiBmdW5jdGlvbiAob2JqKSB7XG5cdFx0XHR2YXIgdDEsIHQyLCBkb207XG5cdFx0XHRpZigkLmlzQXJyYXkob2JqKSkge1xuXHRcdFx0XHRvYmogPSBvYmouc2xpY2UoKTtcblx0XHRcdFx0Zm9yKHQxID0gMCwgdDIgPSBvYmoubGVuZ3RoOyB0MSA8IHQyOyB0MSsrKSB7XG5cdFx0XHRcdFx0dGhpcy5zaG93X2ljb24ob2JqW3QxXSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9XG5cdFx0XHRvYmogPSB0aGlzLmdldF9ub2RlKG9iaik7XG5cdFx0XHRpZighb2JqIHx8IG9iaiA9PT0gJC5qc3RyZWUucm9vdCkgeyByZXR1cm4gZmFsc2U7IH1cblx0XHRcdGRvbSA9IHRoaXMuZ2V0X25vZGUob2JqLCB0cnVlKTtcblx0XHRcdG9iai5pY29uID0gZG9tLmxlbmd0aCA/IGRvbS5jaGlsZHJlbihcIi5qc3RyZWUtYW5jaG9yXCIpLmNoaWxkcmVuKFwiLmpzdHJlZS10aGVtZWljb25cIikuYXR0cigncmVsJykgOiB0cnVlO1xuXHRcdFx0aWYoIW9iai5pY29uKSB7IG9iai5pY29uID0gdHJ1ZTsgfVxuXHRcdFx0ZG9tLmNoaWxkcmVuKFwiLmpzdHJlZS1hbmNob3JcIikuY2hpbGRyZW4oXCIuanN0cmVlLXRoZW1laWNvblwiKS5yZW1vdmVDbGFzcygnanN0cmVlLXRoZW1laWNvbi1oaWRkZW4nKTtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblx0fTtcblxuXHQvLyBoZWxwZXJzXG5cdCQudmFrYXRhID0ge307XG5cdC8vIGNvbGxlY3QgYXR0cmlidXRlc1xuXHQkLnZha2F0YS5hdHRyaWJ1dGVzID0gZnVuY3Rpb24obm9kZSwgd2l0aF92YWx1ZXMpIHtcblx0XHRub2RlID0gJChub2RlKVswXTtcblx0XHR2YXIgYXR0ciA9IHdpdGhfdmFsdWVzID8ge30gOiBbXTtcblx0XHRpZihub2RlICYmIG5vZGUuYXR0cmlidXRlcykge1xuXHRcdFx0JC5lYWNoKG5vZGUuYXR0cmlidXRlcywgZnVuY3Rpb24gKGksIHYpIHtcblx0XHRcdFx0aWYoJC5pbkFycmF5KHYubmFtZS50b0xvd2VyQ2FzZSgpLFsnc3R5bGUnLCdjb250ZW50ZWRpdGFibGUnLCdoYXNmb2N1cycsJ3RhYmluZGV4J10pICE9PSAtMSkgeyByZXR1cm47IH1cblx0XHRcdFx0aWYodi52YWx1ZSAhPT0gbnVsbCAmJiAkLnRyaW0odi52YWx1ZSkgIT09ICcnKSB7XG5cdFx0XHRcdFx0aWYod2l0aF92YWx1ZXMpIHsgYXR0clt2Lm5hbWVdID0gdi52YWx1ZTsgfVxuXHRcdFx0XHRcdGVsc2UgeyBhdHRyLnB1c2godi5uYW1lKTsgfVxuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHR9XG5cdFx0cmV0dXJuIGF0dHI7XG5cdH07XG5cdCQudmFrYXRhLmFycmF5X3VuaXF1ZSA9IGZ1bmN0aW9uKGFycmF5KSB7XG5cdFx0dmFyIGEgPSBbXSwgaSwgaiwgbCwgbyA9IHt9O1xuXHRcdGZvcihpID0gMCwgbCA9IGFycmF5Lmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0aWYob1thcnJheVtpXV0gPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRhLnB1c2goYXJyYXlbaV0pO1xuXHRcdFx0XHRvW2FycmF5W2ldXSA9IHRydWU7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBhO1xuXHR9O1xuXHQvLyByZW1vdmUgaXRlbSBmcm9tIGFycmF5XG5cdCQudmFrYXRhLmFycmF5X3JlbW92ZSA9IGZ1bmN0aW9uKGFycmF5LCBmcm9tKSB7XG5cdFx0YXJyYXkuc3BsaWNlKGZyb20sIDEpO1xuXHRcdHJldHVybiBhcnJheTtcblx0XHQvL3ZhciByZXN0ID0gYXJyYXkuc2xpY2UoKHRvIHx8IGZyb20pICsgMSB8fCBhcnJheS5sZW5ndGgpO1xuXHRcdC8vYXJyYXkubGVuZ3RoID0gZnJvbSA8IDAgPyBhcnJheS5sZW5ndGggKyBmcm9tIDogZnJvbTtcblx0XHQvL2FycmF5LnB1c2guYXBwbHkoYXJyYXksIHJlc3QpO1xuXHRcdC8vcmV0dXJuIGFycmF5O1xuXHR9O1xuXHQvLyByZW1vdmUgaXRlbSBmcm9tIGFycmF5XG5cdCQudmFrYXRhLmFycmF5X3JlbW92ZV9pdGVtID0gZnVuY3Rpb24oYXJyYXksIGl0ZW0pIHtcblx0XHR2YXIgdG1wID0gJC5pbkFycmF5KGl0ZW0sIGFycmF5KTtcblx0XHRyZXR1cm4gdG1wICE9PSAtMSA/ICQudmFrYXRhLmFycmF5X3JlbW92ZShhcnJheSwgdG1wKSA6IGFycmF5O1xuXHR9O1xuXHQkLnZha2F0YS5hcnJheV9maWx0ZXIgPSBmdW5jdGlvbihjLGEsYixkLGUpIHtcblx0XHRpZiAoYy5maWx0ZXIpIHtcblx0XHRcdHJldHVybiBjLmZpbHRlcihhLCBiKTtcblx0XHR9XG5cdFx0ZD1bXTtcblx0XHRmb3IgKGUgaW4gYykge1xuXHRcdFx0aWYgKH5+ZSsnJz09PWUrJycgJiYgZT49MCAmJiBhLmNhbGwoYixjW2VdLCtlLGMpKSB7XG5cdFx0XHRcdGQucHVzaChjW2VdKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIGQ7XG5cdH07XG5cblxuLyoqXG4gKiAjIyMgQ2hhbmdlZCBwbHVnaW5cbiAqXG4gKiBUaGlzIHBsdWdpbiBhZGRzIG1vcmUgaW5mb3JtYXRpb24gdG8gdGhlIGBjaGFuZ2VkLmpzdHJlZWAgZXZlbnQuIFRoZSBuZXcgZGF0YSBpcyBjb250YWluZWQgaW4gdGhlIGBjaGFuZ2VkYCBldmVudCBkYXRhIHByb3BlcnR5LCBhbmQgY29udGFpbnMgYSBsaXN0cyBvZiBgc2VsZWN0ZWRgIGFuZCBgZGVzZWxlY3RlZGAgbm9kZXMuXG4gKi9cblxuXHQkLmpzdHJlZS5wbHVnaW5zLmNoYW5nZWQgPSBmdW5jdGlvbiAob3B0aW9ucywgcGFyZW50KSB7XG5cdFx0dmFyIGxhc3QgPSBbXTtcblx0XHR0aGlzLnRyaWdnZXIgPSBmdW5jdGlvbiAoZXYsIGRhdGEpIHtcblx0XHRcdHZhciBpLCBqO1xuXHRcdFx0aWYoIWRhdGEpIHtcblx0XHRcdFx0ZGF0YSA9IHt9O1xuXHRcdFx0fVxuXHRcdFx0aWYoZXYucmVwbGFjZSgnLmpzdHJlZScsJycpID09PSAnY2hhbmdlZCcpIHtcblx0XHRcdFx0ZGF0YS5jaGFuZ2VkID0geyBzZWxlY3RlZCA6IFtdLCBkZXNlbGVjdGVkIDogW10gfTtcblx0XHRcdFx0dmFyIHRtcCA9IHt9O1xuXHRcdFx0XHRmb3IoaSA9IDAsIGogPSBsYXN0Lmxlbmd0aDsgaSA8IGo7IGkrKykge1xuXHRcdFx0XHRcdHRtcFtsYXN0W2ldXSA9IDE7XG5cdFx0XHRcdH1cblx0XHRcdFx0Zm9yKGkgPSAwLCBqID0gZGF0YS5zZWxlY3RlZC5sZW5ndGg7IGkgPCBqOyBpKyspIHtcblx0XHRcdFx0XHRpZighdG1wW2RhdGEuc2VsZWN0ZWRbaV1dKSB7XG5cdFx0XHRcdFx0XHRkYXRhLmNoYW5nZWQuc2VsZWN0ZWQucHVzaChkYXRhLnNlbGVjdGVkW2ldKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0XHR0bXBbZGF0YS5zZWxlY3RlZFtpXV0gPSAyO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRmb3IoaSA9IDAsIGogPSBsYXN0Lmxlbmd0aDsgaSA8IGo7IGkrKykge1xuXHRcdFx0XHRcdGlmKHRtcFtsYXN0W2ldXSA9PT0gMSkge1xuXHRcdFx0XHRcdFx0ZGF0YS5jaGFuZ2VkLmRlc2VsZWN0ZWQucHVzaChsYXN0W2ldKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0bGFzdCA9IGRhdGEuc2VsZWN0ZWQuc2xpY2UoKTtcblx0XHRcdH1cblx0XHRcdC8qKlxuXHRcdFx0ICogdHJpZ2dlcmVkIHdoZW4gc2VsZWN0aW9uIGNoYW5nZXMgKHRoZSBcImNoYW5nZWRcIiBwbHVnaW4gZW5oYW5jZXMgdGhlIG9yaWdpbmFsIGV2ZW50IHdpdGggbW9yZSBkYXRhKVxuXHRcdFx0ICogQGV2ZW50XG5cdFx0XHQgKiBAbmFtZSBjaGFuZ2VkLmpzdHJlZVxuXHRcdFx0ICogQHBhcmFtIHtPYmplY3R9IG5vZGVcblx0XHRcdCAqIEBwYXJhbSB7T2JqZWN0fSBhY3Rpb24gdGhlIGFjdGlvbiB0aGF0IGNhdXNlZCB0aGUgc2VsZWN0aW9uIHRvIGNoYW5nZVxuXHRcdFx0ICogQHBhcmFtIHtBcnJheX0gc2VsZWN0ZWQgdGhlIGN1cnJlbnQgc2VsZWN0aW9uXG5cdFx0XHQgKiBAcGFyYW0ge09iamVjdH0gY2hhbmdlZCBhbiBvYmplY3QgY29udGFpbmluZyB0d28gcHJvcGVydGllcyBgc2VsZWN0ZWRgIGFuZCBgZGVzZWxlY3RlZGAgLSBib3RoIGFycmF5cyBvZiBub2RlIElEcywgd2hpY2ggd2VyZSBzZWxlY3RlZCBvciBkZXNlbGVjdGVkIHNpbmNlIHRoZSBsYXN0IGNoYW5nZWQgZXZlbnRcblx0XHRcdCAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCB0aGUgZXZlbnQgKGlmIGFueSkgdGhhdCB0cmlnZ2VyZWQgdGhpcyBjaGFuZ2VkIGV2ZW50XG5cdFx0XHQgKiBAcGx1Z2luIGNoYW5nZWRcblx0XHRcdCAqL1xuXHRcdFx0cGFyZW50LnRyaWdnZXIuY2FsbCh0aGlzLCBldiwgZGF0YSk7XG5cdFx0fTtcblx0XHR0aGlzLnJlZnJlc2ggPSBmdW5jdGlvbiAoc2tpcF9sb2FkaW5nLCBmb3JnZXRfc3RhdGUpIHtcblx0XHRcdGxhc3QgPSBbXTtcblx0XHRcdHJldHVybiBwYXJlbnQucmVmcmVzaC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHRcdH07XG5cdH07XG5cbi8qKlxuICogIyMjIENoZWNrYm94IHBsdWdpblxuICpcbiAqIFRoaXMgcGx1Z2luIHJlbmRlcnMgY2hlY2tib3ggaWNvbnMgaW4gZnJvbnQgb2YgZWFjaCBub2RlLCBtYWtpbmcgbXVsdGlwbGUgc2VsZWN0aW9uIG11Y2ggZWFzaWVyLlxuICogSXQgYWxzbyBzdXBwb3J0cyB0cmktc3RhdGUgYmVoYXZpb3IsIG1lYW5pbmcgdGhhdCBpZiBhIG5vZGUgaGFzIGEgZmV3IG9mIGl0cyBjaGlsZHJlbiBjaGVja2VkIGl0IHdpbGwgYmUgcmVuZGVyZWQgYXMgdW5kZXRlcm1pbmVkLCBhbmQgc3RhdGUgd2lsbCBiZSBwcm9wYWdhdGVkIHVwLlxuICovXG5cblx0dmFyIF9pID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnSScpO1xuXHRfaS5jbGFzc05hbWUgPSAnanN0cmVlLWljb24ganN0cmVlLWNoZWNrYm94Jztcblx0X2kuc2V0QXR0cmlidXRlKCdyb2xlJywgJ3ByZXNlbnRhdGlvbicpO1xuXHQvKipcblx0ICogc3RvcmVzIGFsbCBkZWZhdWx0cyBmb3IgdGhlIGNoZWNrYm94IHBsdWdpblxuXHQgKiBAbmFtZSAkLmpzdHJlZS5kZWZhdWx0cy5jaGVja2JveFxuXHQgKiBAcGx1Z2luIGNoZWNrYm94XG5cdCAqL1xuXHQkLmpzdHJlZS5kZWZhdWx0cy5jaGVja2JveCA9IHtcblx0XHQvKipcblx0XHQgKiBhIGJvb2xlYW4gaW5kaWNhdGluZyBpZiBjaGVja2JveGVzIHNob3VsZCBiZSB2aXNpYmxlIChjYW4gYmUgY2hhbmdlZCBhdCBhIGxhdGVyIHRpbWUgdXNpbmcgYHNob3dfY2hlY2tib3hlcygpYCBhbmQgYGhpZGVfY2hlY2tib3hlc2ApLiBEZWZhdWx0cyB0byBgdHJ1ZWAuXG5cdFx0ICogQG5hbWUgJC5qc3RyZWUuZGVmYXVsdHMuY2hlY2tib3gudmlzaWJsZVxuXHRcdCAqIEBwbHVnaW4gY2hlY2tib3hcblx0XHQgKi9cblx0XHR2aXNpYmxlXHRcdFx0XHQ6IHRydWUsXG5cdFx0LyoqXG5cdFx0ICogYSBib29sZWFuIGluZGljYXRpbmcgaWYgY2hlY2tib3hlcyBzaG91bGQgY2FzY2FkZSBkb3duIGFuZCBoYXZlIGFuIHVuZGV0ZXJtaW5lZCBzdGF0ZS4gRGVmYXVsdHMgdG8gYHRydWVgLlxuXHRcdCAqIEBuYW1lICQuanN0cmVlLmRlZmF1bHRzLmNoZWNrYm94LnRocmVlX3N0YXRlXG5cdFx0ICogQHBsdWdpbiBjaGVja2JveFxuXHRcdCAqL1xuXHRcdHRocmVlX3N0YXRlXHRcdFx0OiB0cnVlLFxuXHRcdC8qKlxuXHRcdCAqIGEgYm9vbGVhbiBpbmRpY2F0aW5nIGlmIGNsaWNraW5nIGFueXdoZXJlIG9uIHRoZSBub2RlIHNob3VsZCBhY3QgYXMgY2xpY2tpbmcgb24gdGhlIGNoZWNrYm94LiBEZWZhdWx0cyB0byBgdHJ1ZWAuXG5cdFx0ICogQG5hbWUgJC5qc3RyZWUuZGVmYXVsdHMuY2hlY2tib3gud2hvbGVfbm9kZVxuXHRcdCAqIEBwbHVnaW4gY2hlY2tib3hcblx0XHQgKi9cblx0XHR3aG9sZV9ub2RlXHRcdFx0OiB0cnVlLFxuXHRcdC8qKlxuXHRcdCAqIGEgYm9vbGVhbiBpbmRpY2F0aW5nIGlmIHRoZSBzZWxlY3RlZCBzdHlsZSBvZiBhIG5vZGUgc2hvdWxkIGJlIGtlcHQsIG9yIHJlbW92ZWQuIERlZmF1bHRzIHRvIGB0cnVlYC5cblx0XHQgKiBAbmFtZSAkLmpzdHJlZS5kZWZhdWx0cy5jaGVja2JveC5rZWVwX3NlbGVjdGVkX3N0eWxlXG5cdFx0ICogQHBsdWdpbiBjaGVja2JveFxuXHRcdCAqL1xuXHRcdGtlZXBfc2VsZWN0ZWRfc3R5bGVcdDogdHJ1ZSxcblx0XHQvKipcblx0XHQgKiBUaGlzIHNldHRpbmcgY29udHJvbHMgaG93IGNhc2NhZGluZyBhbmQgdW5kZXRlcm1pbmVkIG5vZGVzIGFyZSBhcHBsaWVkLlxuXHRcdCAqIElmICd1cCcgaXMgaW4gdGhlIHN0cmluZyAtIGNhc2NhZGluZyB1cCBpcyBlbmFibGVkLCBpZiAnZG93bicgaXMgaW4gdGhlIHN0cmluZyAtIGNhc2NhZGluZyBkb3duIGlzIGVuYWJsZWQsIGlmICd1bmRldGVybWluZWQnIGlzIGluIHRoZSBzdHJpbmcgLSB1bmRldGVybWluZWQgbm9kZXMgd2lsbCBiZSB1c2VkLlxuXHRcdCAqIElmIGB0aHJlZV9zdGF0ZWAgaXMgc2V0IHRvIGB0cnVlYCB0aGlzIHNldHRpbmcgaXMgYXV0b21hdGljYWxseSBzZXQgdG8gJ3VwK2Rvd24rdW5kZXRlcm1pbmVkJy4gRGVmYXVsdHMgdG8gJycuXG5cdFx0ICogQG5hbWUgJC5qc3RyZWUuZGVmYXVsdHMuY2hlY2tib3guY2FzY2FkZVxuXHRcdCAqIEBwbHVnaW4gY2hlY2tib3hcblx0XHQgKi9cblx0XHRjYXNjYWRlXHRcdFx0XHQ6ICcnLFxuXHRcdC8qKlxuXHRcdCAqIFRoaXMgc2V0dGluZyBjb250cm9scyBpZiBjaGVja2JveCBhcmUgYm91bmQgdG8gdGhlIGdlbmVyYWwgdHJlZSBzZWxlY3Rpb24gb3IgdG8gYW4gaW50ZXJuYWwgYXJyYXkgbWFpbnRhaW5lZCBieSB0aGUgY2hlY2tib3ggcGx1Z2luLiBEZWZhdWx0cyB0byBgdHJ1ZWAsIG9ubHkgc2V0IHRvIGBmYWxzZWAgaWYgeW91IGtub3cgZXhhY3RseSB3aGF0IHlvdSBhcmUgZG9pbmcuXG5cdFx0ICogQG5hbWUgJC5qc3RyZWUuZGVmYXVsdHMuY2hlY2tib3gudGllX3NlbGVjdGlvblxuXHRcdCAqIEBwbHVnaW4gY2hlY2tib3hcblx0XHQgKi9cblx0XHR0aWVfc2VsZWN0aW9uXHRcdDogdHJ1ZVxuXHR9O1xuXHQkLmpzdHJlZS5wbHVnaW5zLmNoZWNrYm94ID0gZnVuY3Rpb24gKG9wdGlvbnMsIHBhcmVudCkge1xuXHRcdHRoaXMuYmluZCA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdHBhcmVudC5iaW5kLmNhbGwodGhpcyk7XG5cdFx0XHR0aGlzLl9kYXRhLmNoZWNrYm94LnV0byA9IGZhbHNlO1xuXHRcdFx0dGhpcy5fZGF0YS5jaGVja2JveC5zZWxlY3RlZCA9IFtdO1xuXHRcdFx0aWYodGhpcy5zZXR0aW5ncy5jaGVja2JveC50aHJlZV9zdGF0ZSkge1xuXHRcdFx0XHR0aGlzLnNldHRpbmdzLmNoZWNrYm94LmNhc2NhZGUgPSAndXArZG93bit1bmRldGVybWluZWQnO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5lbGVtZW50XG5cdFx0XHRcdC5vbihcImluaXQuanN0cmVlXCIsICQucHJveHkoZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdFx0dGhpcy5fZGF0YS5jaGVja2JveC52aXNpYmxlID0gdGhpcy5zZXR0aW5ncy5jaGVja2JveC52aXNpYmxlO1xuXHRcdFx0XHRcdFx0aWYoIXRoaXMuc2V0dGluZ3MuY2hlY2tib3gua2VlcF9zZWxlY3RlZF9zdHlsZSkge1xuXHRcdFx0XHRcdFx0XHR0aGlzLmVsZW1lbnQuYWRkQ2xhc3MoJ2pzdHJlZS1jaGVja2JveC1uby1jbGlja2VkJyk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRpZih0aGlzLnNldHRpbmdzLmNoZWNrYm94LnRpZV9zZWxlY3Rpb24pIHtcblx0XHRcdFx0XHRcdFx0dGhpcy5lbGVtZW50LmFkZENsYXNzKCdqc3RyZWUtY2hlY2tib3gtc2VsZWN0aW9uJyk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSwgdGhpcykpXG5cdFx0XHRcdC5vbihcImxvYWRpbmcuanN0cmVlXCIsICQucHJveHkoZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdFx0dGhpc1sgdGhpcy5fZGF0YS5jaGVja2JveC52aXNpYmxlID8gJ3Nob3dfY2hlY2tib3hlcycgOiAnaGlkZV9jaGVja2JveGVzJyBdKCk7XG5cdFx0XHRcdFx0fSwgdGhpcykpO1xuXHRcdFx0aWYodGhpcy5zZXR0aW5ncy5jaGVja2JveC5jYXNjYWRlLmluZGV4T2YoJ3VuZGV0ZXJtaW5lZCcpICE9PSAtMSkge1xuXHRcdFx0XHR0aGlzLmVsZW1lbnRcblx0XHRcdFx0XHQub24oJ2NoYW5nZWQuanN0cmVlIHVuY2hlY2tfbm9kZS5qc3RyZWUgY2hlY2tfbm9kZS5qc3RyZWUgdW5jaGVja19hbGwuanN0cmVlIGNoZWNrX2FsbC5qc3RyZWUgbW92ZV9ub2RlLmpzdHJlZSBjb3B5X25vZGUuanN0cmVlIHJlZHJhdy5qc3RyZWUgb3Blbl9ub2RlLmpzdHJlZScsICQucHJveHkoZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdFx0XHQvLyBvbmx5IGlmIHVuZGV0ZXJtaW5lZCBpcyBpbiBzZXR0aW5nXG5cdFx0XHRcdFx0XHRcdGlmKHRoaXMuX2RhdGEuY2hlY2tib3gudXRvKSB7IGNsZWFyVGltZW91dCh0aGlzLl9kYXRhLmNoZWNrYm94LnV0byk7IH1cblx0XHRcdFx0XHRcdFx0dGhpcy5fZGF0YS5jaGVja2JveC51dG8gPSBzZXRUaW1lb3V0KCQucHJveHkodGhpcy5fdW5kZXRlcm1pbmVkLCB0aGlzKSwgNTApO1xuXHRcdFx0XHRcdFx0fSwgdGhpcykpO1xuXHRcdFx0fVxuXHRcdFx0aWYoIXRoaXMuc2V0dGluZ3MuY2hlY2tib3gudGllX3NlbGVjdGlvbikge1xuXHRcdFx0XHR0aGlzLmVsZW1lbnRcblx0XHRcdFx0XHQub24oJ21vZGVsLmpzdHJlZScsICQucHJveHkoZnVuY3Rpb24gKGUsIGRhdGEpIHtcblx0XHRcdFx0XHRcdHZhciBtID0gdGhpcy5fbW9kZWwuZGF0YSxcblx0XHRcdFx0XHRcdFx0cCA9IG1bZGF0YS5wYXJlbnRdLFxuXHRcdFx0XHRcdFx0XHRkcGMgPSBkYXRhLm5vZGVzLFxuXHRcdFx0XHRcdFx0XHRpLCBqO1xuXHRcdFx0XHRcdFx0Zm9yKGkgPSAwLCBqID0gZHBjLmxlbmd0aDsgaSA8IGo7IGkrKykge1xuXHRcdFx0XHRcdFx0XHRtW2RwY1tpXV0uc3RhdGUuY2hlY2tlZCA9IG1bZHBjW2ldXS5zdGF0ZS5jaGVja2VkIHx8IChtW2RwY1tpXV0ub3JpZ2luYWwgJiYgbVtkcGNbaV1dLm9yaWdpbmFsLnN0YXRlICYmIG1bZHBjW2ldXS5vcmlnaW5hbC5zdGF0ZS5jaGVja2VkKTtcblx0XHRcdFx0XHRcdFx0aWYobVtkcGNbaV1dLnN0YXRlLmNoZWNrZWQpIHtcblx0XHRcdFx0XHRcdFx0XHR0aGlzLl9kYXRhLmNoZWNrYm94LnNlbGVjdGVkLnB1c2goZHBjW2ldKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0sIHRoaXMpKTtcblx0XHRcdH1cblx0XHRcdGlmKHRoaXMuc2V0dGluZ3MuY2hlY2tib3guY2FzY2FkZS5pbmRleE9mKCd1cCcpICE9PSAtMSB8fCB0aGlzLnNldHRpbmdzLmNoZWNrYm94LmNhc2NhZGUuaW5kZXhPZignZG93bicpICE9PSAtMSkge1xuXHRcdFx0XHR0aGlzLmVsZW1lbnRcblx0XHRcdFx0XHQub24oJ21vZGVsLmpzdHJlZScsICQucHJveHkoZnVuY3Rpb24gKGUsIGRhdGEpIHtcblx0XHRcdFx0XHRcdFx0dmFyIG0gPSB0aGlzLl9tb2RlbC5kYXRhLFxuXHRcdFx0XHRcdFx0XHRcdHAgPSBtW2RhdGEucGFyZW50XSxcblx0XHRcdFx0XHRcdFx0XHRkcGMgPSBkYXRhLm5vZGVzLFxuXHRcdFx0XHRcdFx0XHRcdGNoZCA9IFtdLFxuXHRcdFx0XHRcdFx0XHRcdGMsIGksIGosIGssIGwsIHRtcCwgcyA9IHRoaXMuc2V0dGluZ3MuY2hlY2tib3guY2FzY2FkZSwgdCA9IHRoaXMuc2V0dGluZ3MuY2hlY2tib3gudGllX3NlbGVjdGlvbjtcblxuXHRcdFx0XHRcdFx0XHRpZihzLmluZGV4T2YoJ2Rvd24nKSAhPT0gLTEpIHtcblx0XHRcdFx0XHRcdFx0XHQvLyBhcHBseSBkb3duXG5cdFx0XHRcdFx0XHRcdFx0aWYocC5zdGF0ZVsgdCA/ICdzZWxlY3RlZCcgOiAnY2hlY2tlZCcgXSkge1xuXHRcdFx0XHRcdFx0XHRcdFx0Zm9yKGkgPSAwLCBqID0gZHBjLmxlbmd0aDsgaSA8IGo7IGkrKykge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRtW2RwY1tpXV0uc3RhdGVbIHQgPyAnc2VsZWN0ZWQnIDogJ2NoZWNrZWQnIF0gPSB0cnVlO1xuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0dGhpcy5fZGF0YVsgdCA/ICdjb3JlJyA6ICdjaGVja2JveCcgXS5zZWxlY3RlZCA9IHRoaXMuX2RhdGFbIHQgPyAnY29yZScgOiAnY2hlY2tib3gnIF0uc2VsZWN0ZWQuY29uY2F0KGRwYyk7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdFx0Zm9yKGkgPSAwLCBqID0gZHBjLmxlbmd0aDsgaSA8IGo7IGkrKykge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZihtW2RwY1tpXV0uc3RhdGVbIHQgPyAnc2VsZWN0ZWQnIDogJ2NoZWNrZWQnIF0pIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRmb3IoayA9IDAsIGwgPSBtW2RwY1tpXV0uY2hpbGRyZW5fZC5sZW5ndGg7IGsgPCBsOyBrKyspIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdG1bbVtkcGNbaV1dLmNoaWxkcmVuX2Rba11dLnN0YXRlWyB0ID8gJ3NlbGVjdGVkJyA6ICdjaGVja2VkJyBdID0gdHJ1ZTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0dGhpcy5fZGF0YVsgdCA/ICdjb3JlJyA6ICdjaGVja2JveCcgXS5zZWxlY3RlZCA9IHRoaXMuX2RhdGFbIHQgPyAnY29yZScgOiAnY2hlY2tib3gnIF0uc2VsZWN0ZWQuY29uY2F0KG1bZHBjW2ldXS5jaGlsZHJlbl9kKTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdGlmKHMuaW5kZXhPZigndXAnKSAhPT0gLTEpIHtcblx0XHRcdFx0XHRcdFx0XHQvLyBhcHBseSB1cFxuXHRcdFx0XHRcdFx0XHRcdGZvcihpID0gMCwgaiA9IHAuY2hpbGRyZW5fZC5sZW5ndGg7IGkgPCBqOyBpKyspIHtcblx0XHRcdFx0XHRcdFx0XHRcdGlmKCFtW3AuY2hpbGRyZW5fZFtpXV0uY2hpbGRyZW4ubGVuZ3RoKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGNoZC5wdXNoKG1bcC5jaGlsZHJlbl9kW2ldXS5wYXJlbnQpO1xuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRjaGQgPSAkLnZha2F0YS5hcnJheV91bmlxdWUoY2hkKTtcblx0XHRcdFx0XHRcdFx0XHRmb3IoayA9IDAsIGwgPSBjaGQubGVuZ3RoOyBrIDwgbDsgaysrKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRwID0gbVtjaGRba11dO1xuXHRcdFx0XHRcdFx0XHRcdFx0d2hpbGUocCAmJiBwLmlkICE9PSAkLmpzdHJlZS5yb290KSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGMgPSAwO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRmb3IoaSA9IDAsIGogPSBwLmNoaWxkcmVuLmxlbmd0aDsgaSA8IGo7IGkrKykge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGMgKz0gbVtwLmNoaWxkcmVuW2ldXS5zdGF0ZVsgdCA/ICdzZWxlY3RlZCcgOiAnY2hlY2tlZCcgXTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZihjID09PSBqKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0cC5zdGF0ZVsgdCA/ICdzZWxlY3RlZCcgOiAnY2hlY2tlZCcgXSA9IHRydWU7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0dGhpcy5fZGF0YVsgdCA/ICdjb3JlJyA6ICdjaGVja2JveCcgXS5zZWxlY3RlZC5wdXNoKHAuaWQpO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHRtcCA9IHRoaXMuZ2V0X25vZGUocCwgdHJ1ZSk7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0aWYodG1wICYmIHRtcC5sZW5ndGgpIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHRtcC5hdHRyKCdhcmlhLXNlbGVjdGVkJywgdHJ1ZSkuY2hpbGRyZW4oJy5qc3RyZWUtYW5jaG9yJykuYWRkQ2xhc3MoIHQgPyAnanN0cmVlLWNsaWNrZWQnIDogJ2pzdHJlZS1jaGVja2VkJyk7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHAgPSB0aGlzLmdldF9ub2RlKHAucGFyZW50KTtcblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHR0aGlzLl9kYXRhWyB0ID8gJ2NvcmUnIDogJ2NoZWNrYm94JyBdLnNlbGVjdGVkID0gJC52YWthdGEuYXJyYXlfdW5pcXVlKHRoaXMuX2RhdGFbIHQgPyAnY29yZScgOiAnY2hlY2tib3gnIF0uc2VsZWN0ZWQpO1xuXHRcdFx0XHRcdFx0fSwgdGhpcykpXG5cdFx0XHRcdFx0Lm9uKHRoaXMuc2V0dGluZ3MuY2hlY2tib3gudGllX3NlbGVjdGlvbiA/ICdzZWxlY3Rfbm9kZS5qc3RyZWUnIDogJ2NoZWNrX25vZGUuanN0cmVlJywgJC5wcm94eShmdW5jdGlvbiAoZSwgZGF0YSkge1xuXHRcdFx0XHRcdFx0XHR2YXIgb2JqID0gZGF0YS5ub2RlLFxuXHRcdFx0XHRcdFx0XHRcdG0gPSB0aGlzLl9tb2RlbC5kYXRhLFxuXHRcdFx0XHRcdFx0XHRcdHBhciA9IHRoaXMuZ2V0X25vZGUob2JqLnBhcmVudCksXG5cdFx0XHRcdFx0XHRcdFx0ZG9tID0gdGhpcy5nZXRfbm9kZShvYmosIHRydWUpLFxuXHRcdFx0XHRcdFx0XHRcdGksIGosIGMsIHRtcCwgcyA9IHRoaXMuc2V0dGluZ3MuY2hlY2tib3guY2FzY2FkZSwgdCA9IHRoaXMuc2V0dGluZ3MuY2hlY2tib3gudGllX3NlbGVjdGlvbixcblx0XHRcdFx0XHRcdFx0XHRzZWwgPSB7fSwgY3VyID0gdGhpcy5fZGF0YVsgdCA/ICdjb3JlJyA6ICdjaGVja2JveCcgXS5zZWxlY3RlZDtcblxuXHRcdFx0XHRcdFx0XHRmb3IgKGkgPSAwLCBqID0gY3VyLmxlbmd0aDsgaSA8IGo7IGkrKykge1xuXHRcdFx0XHRcdFx0XHRcdHNlbFtjdXJbaV1dID0gdHJ1ZTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHQvLyBhcHBseSBkb3duXG5cdFx0XHRcdFx0XHRcdGlmKHMuaW5kZXhPZignZG93bicpICE9PSAtMSkge1xuXHRcdFx0XHRcdFx0XHRcdC8vdGhpcy5fZGF0YVsgdCA/ICdjb3JlJyA6ICdjaGVja2JveCcgXS5zZWxlY3RlZCA9ICQudmFrYXRhLmFycmF5X3VuaXF1ZSh0aGlzLl9kYXRhWyB0ID8gJ2NvcmUnIDogJ2NoZWNrYm94JyBdLnNlbGVjdGVkLmNvbmNhdChvYmouY2hpbGRyZW5fZCkpO1xuXHRcdFx0XHRcdFx0XHRcdGZvcihpID0gMCwgaiA9IG9iai5jaGlsZHJlbl9kLmxlbmd0aDsgaSA8IGo7IGkrKykge1xuXHRcdFx0XHRcdFx0XHRcdFx0c2VsW29iai5jaGlsZHJlbl9kW2ldXSA9IHRydWU7XG5cdFx0XHRcdFx0XHRcdFx0XHR0bXAgPSBtW29iai5jaGlsZHJlbl9kW2ldXTtcblx0XHRcdFx0XHRcdFx0XHRcdHRtcC5zdGF0ZVsgdCA/ICdzZWxlY3RlZCcgOiAnY2hlY2tlZCcgXSA9IHRydWU7XG5cdFx0XHRcdFx0XHRcdFx0XHRpZih0bXAgJiYgdG1wLm9yaWdpbmFsICYmIHRtcC5vcmlnaW5hbC5zdGF0ZSAmJiB0bXAub3JpZ2luYWwuc3RhdGUudW5kZXRlcm1pbmVkKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHRtcC5vcmlnaW5hbC5zdGF0ZS51bmRldGVybWluZWQgPSBmYWxzZTtcblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHQvLyBhcHBseSB1cFxuXHRcdFx0XHRcdFx0XHRpZihzLmluZGV4T2YoJ3VwJykgIT09IC0xKSB7XG5cdFx0XHRcdFx0XHRcdFx0d2hpbGUocGFyICYmIHBhci5pZCAhPT0gJC5qc3RyZWUucm9vdCkge1xuXHRcdFx0XHRcdFx0XHRcdFx0YyA9IDA7XG5cdFx0XHRcdFx0XHRcdFx0XHRmb3IoaSA9IDAsIGogPSBwYXIuY2hpbGRyZW4ubGVuZ3RoOyBpIDwgajsgaSsrKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGMgKz0gbVtwYXIuY2hpbGRyZW5baV1dLnN0YXRlWyB0ID8gJ3NlbGVjdGVkJyA6ICdjaGVja2VkJyBdO1xuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0aWYoYyA9PT0gaikge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRwYXIuc3RhdGVbIHQgPyAnc2VsZWN0ZWQnIDogJ2NoZWNrZWQnIF0gPSB0cnVlO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRzZWxbcGFyLmlkXSA9IHRydWU7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8vdGhpcy5fZGF0YVsgdCA/ICdjb3JlJyA6ICdjaGVja2JveCcgXS5zZWxlY3RlZC5wdXNoKHBhci5pZCk7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHRtcCA9IHRoaXMuZ2V0X25vZGUocGFyLCB0cnVlKTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWYodG1wICYmIHRtcC5sZW5ndGgpIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR0bXAuYXR0cignYXJpYS1zZWxlY3RlZCcsIHRydWUpLmNoaWxkcmVuKCcuanN0cmVlLWFuY2hvcicpLmFkZENsYXNzKHQgPyAnanN0cmVlLWNsaWNrZWQnIDogJ2pzdHJlZS1jaGVja2VkJyk7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdHBhciA9IHRoaXMuZ2V0X25vZGUocGFyLnBhcmVudCk7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0Y3VyID0gW107XG5cdFx0XHRcdFx0XHRcdGZvciAoaSBpbiBzZWwpIHtcblx0XHRcdFx0XHRcdFx0XHRpZiAoc2VsLmhhc093blByb3BlcnR5KGkpKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRjdXIucHVzaChpKTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0dGhpcy5fZGF0YVsgdCA/ICdjb3JlJyA6ICdjaGVja2JveCcgXS5zZWxlY3RlZCA9IGN1cjtcblxuXHRcdFx0XHRcdFx0XHQvLyBhcHBseSBkb3duIChwcm9jZXNzIC5jaGlsZHJlbiBzZXBhcmF0ZWx5Pylcblx0XHRcdFx0XHRcdFx0aWYocy5pbmRleE9mKCdkb3duJykgIT09IC0xICYmIGRvbS5sZW5ndGgpIHtcblx0XHRcdFx0XHRcdFx0XHRkb20uZmluZCgnLmpzdHJlZS1hbmNob3InKS5hZGRDbGFzcyh0ID8gJ2pzdHJlZS1jbGlja2VkJyA6ICdqc3RyZWUtY2hlY2tlZCcpLnBhcmVudCgpLmF0dHIoJ2FyaWEtc2VsZWN0ZWQnLCB0cnVlKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fSwgdGhpcykpXG5cdFx0XHRcdFx0Lm9uKHRoaXMuc2V0dGluZ3MuY2hlY2tib3gudGllX3NlbGVjdGlvbiA/ICdkZXNlbGVjdF9hbGwuanN0cmVlJyA6ICd1bmNoZWNrX2FsbC5qc3RyZWUnLCAkLnByb3h5KGZ1bmN0aW9uIChlLCBkYXRhKSB7XG5cdFx0XHRcdFx0XHRcdHZhciBvYmogPSB0aGlzLmdldF9ub2RlKCQuanN0cmVlLnJvb3QpLFxuXHRcdFx0XHRcdFx0XHRcdG0gPSB0aGlzLl9tb2RlbC5kYXRhLFxuXHRcdFx0XHRcdFx0XHRcdGksIGosIHRtcDtcblx0XHRcdFx0XHRcdFx0Zm9yKGkgPSAwLCBqID0gb2JqLmNoaWxkcmVuX2QubGVuZ3RoOyBpIDwgajsgaSsrKSB7XG5cdFx0XHRcdFx0XHRcdFx0dG1wID0gbVtvYmouY2hpbGRyZW5fZFtpXV07XG5cdFx0XHRcdFx0XHRcdFx0aWYodG1wICYmIHRtcC5vcmlnaW5hbCAmJiB0bXAub3JpZ2luYWwuc3RhdGUgJiYgdG1wLm9yaWdpbmFsLnN0YXRlLnVuZGV0ZXJtaW5lZCkge1xuXHRcdFx0XHRcdFx0XHRcdFx0dG1wLm9yaWdpbmFsLnN0YXRlLnVuZGV0ZXJtaW5lZCA9IGZhbHNlO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fSwgdGhpcykpXG5cdFx0XHRcdFx0Lm9uKHRoaXMuc2V0dGluZ3MuY2hlY2tib3gudGllX3NlbGVjdGlvbiA/ICdkZXNlbGVjdF9ub2RlLmpzdHJlZScgOiAndW5jaGVja19ub2RlLmpzdHJlZScsICQucHJveHkoZnVuY3Rpb24gKGUsIGRhdGEpIHtcblx0XHRcdFx0XHRcdFx0dmFyIG9iaiA9IGRhdGEubm9kZSxcblx0XHRcdFx0XHRcdFx0XHRkb20gPSB0aGlzLmdldF9ub2RlKG9iaiwgdHJ1ZSksXG5cdFx0XHRcdFx0XHRcdFx0aSwgaiwgdG1wLCBzID0gdGhpcy5zZXR0aW5ncy5jaGVja2JveC5jYXNjYWRlLCB0ID0gdGhpcy5zZXR0aW5ncy5jaGVja2JveC50aWVfc2VsZWN0aW9uLFxuXHRcdFx0XHRcdFx0XHRcdGN1ciA9IHRoaXMuX2RhdGFbIHQgPyAnY29yZScgOiAnY2hlY2tib3gnIF0uc2VsZWN0ZWQsIHNlbCA9IHt9O1xuXHRcdFx0XHRcdFx0XHRpZihvYmogJiYgb2JqLm9yaWdpbmFsICYmIG9iai5vcmlnaW5hbC5zdGF0ZSAmJiBvYmoub3JpZ2luYWwuc3RhdGUudW5kZXRlcm1pbmVkKSB7XG5cdFx0XHRcdFx0XHRcdFx0b2JqLm9yaWdpbmFsLnN0YXRlLnVuZGV0ZXJtaW5lZCA9IGZhbHNlO1xuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0Ly8gYXBwbHkgZG93blxuXHRcdFx0XHRcdFx0XHRpZihzLmluZGV4T2YoJ2Rvd24nKSAhPT0gLTEpIHtcblx0XHRcdFx0XHRcdFx0XHRmb3IoaSA9IDAsIGogPSBvYmouY2hpbGRyZW5fZC5sZW5ndGg7IGkgPCBqOyBpKyspIHtcblx0XHRcdFx0XHRcdFx0XHRcdHRtcCA9IHRoaXMuX21vZGVsLmRhdGFbb2JqLmNoaWxkcmVuX2RbaV1dO1xuXHRcdFx0XHRcdFx0XHRcdFx0dG1wLnN0YXRlWyB0ID8gJ3NlbGVjdGVkJyA6ICdjaGVja2VkJyBdID0gZmFsc2U7XG5cdFx0XHRcdFx0XHRcdFx0XHRpZih0bXAgJiYgdG1wLm9yaWdpbmFsICYmIHRtcC5vcmlnaW5hbC5zdGF0ZSAmJiB0bXAub3JpZ2luYWwuc3RhdGUudW5kZXRlcm1pbmVkKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHRtcC5vcmlnaW5hbC5zdGF0ZS51bmRldGVybWluZWQgPSBmYWxzZTtcblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHQvLyBhcHBseSB1cFxuXHRcdFx0XHRcdFx0XHRpZihzLmluZGV4T2YoJ3VwJykgIT09IC0xKSB7XG5cdFx0XHRcdFx0XHRcdFx0Zm9yKGkgPSAwLCBqID0gb2JqLnBhcmVudHMubGVuZ3RoOyBpIDwgajsgaSsrKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHR0bXAgPSB0aGlzLl9tb2RlbC5kYXRhW29iai5wYXJlbnRzW2ldXTtcblx0XHRcdFx0XHRcdFx0XHRcdHRtcC5zdGF0ZVsgdCA/ICdzZWxlY3RlZCcgOiAnY2hlY2tlZCcgXSA9IGZhbHNlO1xuXHRcdFx0XHRcdFx0XHRcdFx0aWYodG1wICYmIHRtcC5vcmlnaW5hbCAmJiB0bXAub3JpZ2luYWwuc3RhdGUgJiYgdG1wLm9yaWdpbmFsLnN0YXRlLnVuZGV0ZXJtaW5lZCkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0bXAub3JpZ2luYWwuc3RhdGUudW5kZXRlcm1pbmVkID0gZmFsc2U7XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHR0bXAgPSB0aGlzLmdldF9ub2RlKG9iai5wYXJlbnRzW2ldLCB0cnVlKTtcblx0XHRcdFx0XHRcdFx0XHRcdGlmKHRtcCAmJiB0bXAubGVuZ3RoKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHRtcC5hdHRyKCdhcmlhLXNlbGVjdGVkJywgZmFsc2UpLmNoaWxkcmVuKCcuanN0cmVlLWFuY2hvcicpLnJlbW92ZUNsYXNzKHQgPyAnanN0cmVlLWNsaWNrZWQnIDogJ2pzdHJlZS1jaGVja2VkJyk7XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdHNlbCA9IHt9O1xuXHRcdFx0XHRcdFx0XHRmb3IoaSA9IDAsIGogPSBjdXIubGVuZ3RoOyBpIDwgajsgaSsrKSB7XG5cdFx0XHRcdFx0XHRcdFx0Ly8gYXBwbHkgZG93biArIGFwcGx5IHVwXG5cdFx0XHRcdFx0XHRcdFx0aWYoXG5cdFx0XHRcdFx0XHRcdFx0XHQocy5pbmRleE9mKCdkb3duJykgPT09IC0xIHx8ICQuaW5BcnJheShjdXJbaV0sIG9iai5jaGlsZHJlbl9kKSA9PT0gLTEpICYmXG5cdFx0XHRcdFx0XHRcdFx0XHQocy5pbmRleE9mKCd1cCcpID09PSAtMSB8fCAkLmluQXJyYXkoY3VyW2ldLCBvYmoucGFyZW50cykgPT09IC0xKVxuXHRcdFx0XHRcdFx0XHRcdCkge1xuXHRcdFx0XHRcdFx0XHRcdFx0c2VsW2N1cltpXV0gPSB0cnVlO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRjdXIgPSBbXTtcblx0XHRcdFx0XHRcdFx0Zm9yIChpIGluIHNlbCkge1xuXHRcdFx0XHRcdFx0XHRcdGlmIChzZWwuaGFzT3duUHJvcGVydHkoaSkpIHtcblx0XHRcdFx0XHRcdFx0XHRcdGN1ci5wdXNoKGkpO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR0aGlzLl9kYXRhWyB0ID8gJ2NvcmUnIDogJ2NoZWNrYm94JyBdLnNlbGVjdGVkID0gY3VyO1xuXHRcdFx0XHRcdFx0XHRcblx0XHRcdFx0XHRcdFx0Ly8gYXBwbHkgZG93biAocHJvY2VzcyAuY2hpbGRyZW4gc2VwYXJhdGVseT8pXG5cdFx0XHRcdFx0XHRcdGlmKHMuaW5kZXhPZignZG93bicpICE9PSAtMSAmJiBkb20ubGVuZ3RoKSB7XG5cdFx0XHRcdFx0XHRcdFx0ZG9tLmZpbmQoJy5qc3RyZWUtYW5jaG9yJykucmVtb3ZlQ2xhc3ModCA/ICdqc3RyZWUtY2xpY2tlZCcgOiAnanN0cmVlLWNoZWNrZWQnKS5wYXJlbnQoKS5hdHRyKCdhcmlhLXNlbGVjdGVkJywgZmFsc2UpO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9LCB0aGlzKSk7XG5cdFx0XHR9XG5cdFx0XHRpZih0aGlzLnNldHRpbmdzLmNoZWNrYm94LmNhc2NhZGUuaW5kZXhPZigndXAnKSAhPT0gLTEpIHtcblx0XHRcdFx0dGhpcy5lbGVtZW50XG5cdFx0XHRcdFx0Lm9uKCdkZWxldGVfbm9kZS5qc3RyZWUnLCAkLnByb3h5KGZ1bmN0aW9uIChlLCBkYXRhKSB7XG5cdFx0XHRcdFx0XHRcdC8vIGFwcGx5IHVwICh3aG9sZSBoYW5kbGVyKVxuXHRcdFx0XHRcdFx0XHR2YXIgcCA9IHRoaXMuZ2V0X25vZGUoZGF0YS5wYXJlbnQpLFxuXHRcdFx0XHRcdFx0XHRcdG0gPSB0aGlzLl9tb2RlbC5kYXRhLFxuXHRcdFx0XHRcdFx0XHRcdGksIGosIGMsIHRtcCwgdCA9IHRoaXMuc2V0dGluZ3MuY2hlY2tib3gudGllX3NlbGVjdGlvbjtcblx0XHRcdFx0XHRcdFx0d2hpbGUocCAmJiBwLmlkICE9PSAkLmpzdHJlZS5yb290ICYmICFwLnN0YXRlWyB0ID8gJ3NlbGVjdGVkJyA6ICdjaGVja2VkJyBdKSB7XG5cdFx0XHRcdFx0XHRcdFx0YyA9IDA7XG5cdFx0XHRcdFx0XHRcdFx0Zm9yKGkgPSAwLCBqID0gcC5jaGlsZHJlbi5sZW5ndGg7IGkgPCBqOyBpKyspIHtcblx0XHRcdFx0XHRcdFx0XHRcdGMgKz0gbVtwLmNoaWxkcmVuW2ldXS5zdGF0ZVsgdCA/ICdzZWxlY3RlZCcgOiAnY2hlY2tlZCcgXTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0aWYoaiA+IDAgJiYgYyA9PT0gaikge1xuXHRcdFx0XHRcdFx0XHRcdFx0cC5zdGF0ZVsgdCA/ICdzZWxlY3RlZCcgOiAnY2hlY2tlZCcgXSA9IHRydWU7XG5cdFx0XHRcdFx0XHRcdFx0XHR0aGlzLl9kYXRhWyB0ID8gJ2NvcmUnIDogJ2NoZWNrYm94JyBdLnNlbGVjdGVkLnB1c2gocC5pZCk7XG5cdFx0XHRcdFx0XHRcdFx0XHR0bXAgPSB0aGlzLmdldF9ub2RlKHAsIHRydWUpO1xuXHRcdFx0XHRcdFx0XHRcdFx0aWYodG1wICYmIHRtcC5sZW5ndGgpIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dG1wLmF0dHIoJ2FyaWEtc2VsZWN0ZWQnLCB0cnVlKS5jaGlsZHJlbignLmpzdHJlZS1hbmNob3InKS5hZGRDbGFzcyh0ID8gJ2pzdHJlZS1jbGlja2VkJyA6ICdqc3RyZWUtY2hlY2tlZCcpO1xuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRwID0gdGhpcy5nZXRfbm9kZShwLnBhcmVudCk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH0sIHRoaXMpKVxuXHRcdFx0XHRcdC5vbignbW92ZV9ub2RlLmpzdHJlZScsICQucHJveHkoZnVuY3Rpb24gKGUsIGRhdGEpIHtcblx0XHRcdFx0XHRcdFx0Ly8gYXBwbHkgdXAgKHdob2xlIGhhbmRsZXIpXG5cdFx0XHRcdFx0XHRcdHZhciBpc19tdWx0aSA9IGRhdGEuaXNfbXVsdGksXG5cdFx0XHRcdFx0XHRcdFx0b2xkX3BhciA9IGRhdGEub2xkX3BhcmVudCxcblx0XHRcdFx0XHRcdFx0XHRuZXdfcGFyID0gdGhpcy5nZXRfbm9kZShkYXRhLnBhcmVudCksXG5cdFx0XHRcdFx0XHRcdFx0bSA9IHRoaXMuX21vZGVsLmRhdGEsXG5cdFx0XHRcdFx0XHRcdFx0cCwgYywgaSwgaiwgdG1wLCB0ID0gdGhpcy5zZXR0aW5ncy5jaGVja2JveC50aWVfc2VsZWN0aW9uO1xuXHRcdFx0XHRcdFx0XHRpZighaXNfbXVsdGkpIHtcblx0XHRcdFx0XHRcdFx0XHRwID0gdGhpcy5nZXRfbm9kZShvbGRfcGFyKTtcblx0XHRcdFx0XHRcdFx0XHR3aGlsZShwICYmIHAuaWQgIT09ICQuanN0cmVlLnJvb3QgJiYgIXAuc3RhdGVbIHQgPyAnc2VsZWN0ZWQnIDogJ2NoZWNrZWQnIF0pIHtcblx0XHRcdFx0XHRcdFx0XHRcdGMgPSAwO1xuXHRcdFx0XHRcdFx0XHRcdFx0Zm9yKGkgPSAwLCBqID0gcC5jaGlsZHJlbi5sZW5ndGg7IGkgPCBqOyBpKyspIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0YyArPSBtW3AuY2hpbGRyZW5baV1dLnN0YXRlWyB0ID8gJ3NlbGVjdGVkJyA6ICdjaGVja2VkJyBdO1xuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0aWYoaiA+IDAgJiYgYyA9PT0gaikge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRwLnN0YXRlWyB0ID8gJ3NlbGVjdGVkJyA6ICdjaGVja2VkJyBdID0gdHJ1ZTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dGhpcy5fZGF0YVsgdCA/ICdjb3JlJyA6ICdjaGVja2JveCcgXS5zZWxlY3RlZC5wdXNoKHAuaWQpO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0bXAgPSB0aGlzLmdldF9ub2RlKHAsIHRydWUpO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZih0bXAgJiYgdG1wLmxlbmd0aCkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHRtcC5hdHRyKCdhcmlhLXNlbGVjdGVkJywgdHJ1ZSkuY2hpbGRyZW4oJy5qc3RyZWUtYW5jaG9yJykuYWRkQ2xhc3ModCA/ICdqc3RyZWUtY2xpY2tlZCcgOiAnanN0cmVlLWNoZWNrZWQnKTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0cCA9IHRoaXMuZ2V0X25vZGUocC5wYXJlbnQpO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRwID0gbmV3X3Bhcjtcblx0XHRcdFx0XHRcdFx0d2hpbGUocCAmJiBwLmlkICE9PSAkLmpzdHJlZS5yb290KSB7XG5cdFx0XHRcdFx0XHRcdFx0YyA9IDA7XG5cdFx0XHRcdFx0XHRcdFx0Zm9yKGkgPSAwLCBqID0gcC5jaGlsZHJlbi5sZW5ndGg7IGkgPCBqOyBpKyspIHtcblx0XHRcdFx0XHRcdFx0XHRcdGMgKz0gbVtwLmNoaWxkcmVuW2ldXS5zdGF0ZVsgdCA/ICdzZWxlY3RlZCcgOiAnY2hlY2tlZCcgXTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0aWYoYyA9PT0gaikge1xuXHRcdFx0XHRcdFx0XHRcdFx0aWYoIXAuc3RhdGVbIHQgPyAnc2VsZWN0ZWQnIDogJ2NoZWNrZWQnIF0pIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0cC5zdGF0ZVsgdCA/ICdzZWxlY3RlZCcgOiAnY2hlY2tlZCcgXSA9IHRydWU7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHRoaXMuX2RhdGFbIHQgPyAnY29yZScgOiAnY2hlY2tib3gnIF0uc2VsZWN0ZWQucHVzaChwLmlkKTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dG1wID0gdGhpcy5nZXRfbm9kZShwLCB0cnVlKTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWYodG1wICYmIHRtcC5sZW5ndGgpIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR0bXAuYXR0cignYXJpYS1zZWxlY3RlZCcsIHRydWUpLmNoaWxkcmVuKCcuanN0cmVlLWFuY2hvcicpLmFkZENsYXNzKHQgPyAnanN0cmVlLWNsaWNrZWQnIDogJ2pzdHJlZS1jaGVja2VkJyk7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRpZihwLnN0YXRlWyB0ID8gJ3NlbGVjdGVkJyA6ICdjaGVja2VkJyBdKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHAuc3RhdGVbIHQgPyAnc2VsZWN0ZWQnIDogJ2NoZWNrZWQnIF0gPSBmYWxzZTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dGhpcy5fZGF0YVsgdCA/ICdjb3JlJyA6ICdjaGVja2JveCcgXS5zZWxlY3RlZCA9ICQudmFrYXRhLmFycmF5X3JlbW92ZV9pdGVtKHRoaXMuX2RhdGFbIHQgPyAnY29yZScgOiAnY2hlY2tib3gnIF0uc2VsZWN0ZWQsIHAuaWQpO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0bXAgPSB0aGlzLmdldF9ub2RlKHAsIHRydWUpO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZih0bXAgJiYgdG1wLmxlbmd0aCkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHRtcC5hdHRyKCdhcmlhLXNlbGVjdGVkJywgZmFsc2UpLmNoaWxkcmVuKCcuanN0cmVlLWFuY2hvcicpLnJlbW92ZUNsYXNzKHQgPyAnanN0cmVlLWNsaWNrZWQnIDogJ2pzdHJlZS1jaGVja2VkJyk7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0cCA9IHRoaXMuZ2V0X25vZGUocC5wYXJlbnQpO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9LCB0aGlzKSk7XG5cdFx0XHR9XG5cdFx0fTtcblx0XHQvKipcblx0XHQgKiBzZXQgdGhlIHVuZGV0ZXJtaW5lZCBzdGF0ZSB3aGVyZSBhbmQgaWYgbmVjZXNzYXJ5LiBVc2VkIGludGVybmFsbHkuXG5cdFx0ICogQHByaXZhdGVcblx0XHQgKiBAbmFtZSBfdW5kZXRlcm1pbmVkKClcblx0XHQgKiBAcGx1Z2luIGNoZWNrYm94XG5cdFx0ICovXG5cdFx0dGhpcy5fdW5kZXRlcm1pbmVkID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0aWYodGhpcy5lbGVtZW50ID09PSBudWxsKSB7IHJldHVybjsgfVxuXHRcdFx0dmFyIGksIGosIGssIGwsIG8gPSB7fSwgbSA9IHRoaXMuX21vZGVsLmRhdGEsIHQgPSB0aGlzLnNldHRpbmdzLmNoZWNrYm94LnRpZV9zZWxlY3Rpb24sIHMgPSB0aGlzLl9kYXRhWyB0ID8gJ2NvcmUnIDogJ2NoZWNrYm94JyBdLnNlbGVjdGVkLCBwID0gW10sIHR0ID0gdGhpcztcblx0XHRcdGZvcihpID0gMCwgaiA9IHMubGVuZ3RoOyBpIDwgajsgaSsrKSB7XG5cdFx0XHRcdGlmKG1bc1tpXV0gJiYgbVtzW2ldXS5wYXJlbnRzKSB7XG5cdFx0XHRcdFx0Zm9yKGsgPSAwLCBsID0gbVtzW2ldXS5wYXJlbnRzLmxlbmd0aDsgayA8IGw7IGsrKykge1xuXHRcdFx0XHRcdFx0aWYob1ttW3NbaV1dLnBhcmVudHNba11dICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRpZihtW3NbaV1dLnBhcmVudHNba10gIT09ICQuanN0cmVlLnJvb3QpIHtcblx0XHRcdFx0XHRcdFx0b1ttW3NbaV1dLnBhcmVudHNba11dID0gdHJ1ZTtcblx0XHRcdFx0XHRcdFx0cC5wdXNoKG1bc1tpXV0ucGFyZW50c1trXSk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHQvLyBhdHRlbXB0IGZvciBzZXJ2ZXIgc2lkZSB1bmRldGVybWluZWQgc3RhdGVcblx0XHRcdHRoaXMuZWxlbWVudC5maW5kKCcuanN0cmVlLWNsb3NlZCcpLm5vdCgnOmhhcyguanN0cmVlLWNoaWxkcmVuKScpXG5cdFx0XHRcdC5lYWNoKGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0XHR2YXIgdG1wID0gdHQuZ2V0X25vZGUodGhpcyksIHRtcDI7XG5cdFx0XHRcdFx0aWYoIXRtcC5zdGF0ZS5sb2FkZWQpIHtcblx0XHRcdFx0XHRcdGlmKHRtcC5vcmlnaW5hbCAmJiB0bXAub3JpZ2luYWwuc3RhdGUgJiYgdG1wLm9yaWdpbmFsLnN0YXRlLnVuZGV0ZXJtaW5lZCAmJiB0bXAub3JpZ2luYWwuc3RhdGUudW5kZXRlcm1pbmVkID09PSB0cnVlKSB7XG5cdFx0XHRcdFx0XHRcdGlmKG9bdG1wLmlkXSA9PT0gdW5kZWZpbmVkICYmIHRtcC5pZCAhPT0gJC5qc3RyZWUucm9vdCkge1xuXHRcdFx0XHRcdFx0XHRcdG9bdG1wLmlkXSA9IHRydWU7XG5cdFx0XHRcdFx0XHRcdFx0cC5wdXNoKHRtcC5pZCk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0Zm9yKGsgPSAwLCBsID0gdG1wLnBhcmVudHMubGVuZ3RoOyBrIDwgbDsgaysrKSB7XG5cdFx0XHRcdFx0XHRcdFx0aWYob1t0bXAucGFyZW50c1trXV0gPT09IHVuZGVmaW5lZCAmJiB0bXAucGFyZW50c1trXSAhPT0gJC5qc3RyZWUucm9vdCkge1xuXHRcdFx0XHRcdFx0XHRcdFx0b1t0bXAucGFyZW50c1trXV0gPSB0cnVlO1xuXHRcdFx0XHRcdFx0XHRcdFx0cC5wdXNoKHRtcC5wYXJlbnRzW2tdKTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0XHRmb3IoaSA9IDAsIGogPSB0bXAuY2hpbGRyZW5fZC5sZW5ndGg7IGkgPCBqOyBpKyspIHtcblx0XHRcdFx0XHRcdFx0dG1wMiA9IG1bdG1wLmNoaWxkcmVuX2RbaV1dO1xuXHRcdFx0XHRcdFx0XHRpZighdG1wMi5zdGF0ZS5sb2FkZWQgJiYgdG1wMi5vcmlnaW5hbCAmJiB0bXAyLm9yaWdpbmFsLnN0YXRlICYmIHRtcDIub3JpZ2luYWwuc3RhdGUudW5kZXRlcm1pbmVkICYmIHRtcDIub3JpZ2luYWwuc3RhdGUudW5kZXRlcm1pbmVkID09PSB0cnVlKSB7XG5cdFx0XHRcdFx0XHRcdFx0aWYob1t0bXAyLmlkXSA9PT0gdW5kZWZpbmVkICYmIHRtcDIuaWQgIT09ICQuanN0cmVlLnJvb3QpIHtcblx0XHRcdFx0XHRcdFx0XHRcdG9bdG1wMi5pZF0gPSB0cnVlO1xuXHRcdFx0XHRcdFx0XHRcdFx0cC5wdXNoKHRtcDIuaWQpO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRmb3IoayA9IDAsIGwgPSB0bXAyLnBhcmVudHMubGVuZ3RoOyBrIDwgbDsgaysrKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRpZihvW3RtcDIucGFyZW50c1trXV0gPT09IHVuZGVmaW5lZCAmJiB0bXAyLnBhcmVudHNba10gIT09ICQuanN0cmVlLnJvb3QpIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0b1t0bXAyLnBhcmVudHNba11dID0gdHJ1ZTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0cC5wdXNoKHRtcDIucGFyZW50c1trXSk7XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KTtcblxuXHRcdFx0dGhpcy5lbGVtZW50LmZpbmQoJy5qc3RyZWUtdW5kZXRlcm1pbmVkJykucmVtb3ZlQ2xhc3MoJ2pzdHJlZS11bmRldGVybWluZWQnKTtcblx0XHRcdGZvcihpID0gMCwgaiA9IHAubGVuZ3RoOyBpIDwgajsgaSsrKSB7XG5cdFx0XHRcdGlmKCFtW3BbaV1dLnN0YXRlWyB0ID8gJ3NlbGVjdGVkJyA6ICdjaGVja2VkJyBdKSB7XG5cdFx0XHRcdFx0cyA9IHRoaXMuZ2V0X25vZGUocFtpXSwgdHJ1ZSk7XG5cdFx0XHRcdFx0aWYocyAmJiBzLmxlbmd0aCkge1xuXHRcdFx0XHRcdFx0cy5jaGlsZHJlbignLmpzdHJlZS1hbmNob3InKS5jaGlsZHJlbignLmpzdHJlZS1jaGVja2JveCcpLmFkZENsYXNzKCdqc3RyZWUtdW5kZXRlcm1pbmVkJyk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fTtcblx0XHR0aGlzLnJlZHJhd19ub2RlID0gZnVuY3Rpb24ob2JqLCBkZWVwLCBpc19jYWxsYmFjaywgZm9yY2VfcmVuZGVyKSB7XG5cdFx0XHRvYmogPSBwYXJlbnQucmVkcmF3X25vZGUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0XHRcdGlmKG9iaikge1xuXHRcdFx0XHR2YXIgaSwgaiwgdG1wID0gbnVsbCwgaWNvbiA9IG51bGw7XG5cdFx0XHRcdGZvcihpID0gMCwgaiA9IG9iai5jaGlsZE5vZGVzLmxlbmd0aDsgaSA8IGo7IGkrKykge1xuXHRcdFx0XHRcdGlmKG9iai5jaGlsZE5vZGVzW2ldICYmIG9iai5jaGlsZE5vZGVzW2ldLmNsYXNzTmFtZSAmJiBvYmouY2hpbGROb2Rlc1tpXS5jbGFzc05hbWUuaW5kZXhPZihcImpzdHJlZS1hbmNob3JcIikgIT09IC0xKSB7XG5cdFx0XHRcdFx0XHR0bXAgPSBvYmouY2hpbGROb2Rlc1tpXTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRpZih0bXApIHtcblx0XHRcdFx0XHRpZighdGhpcy5zZXR0aW5ncy5jaGVja2JveC50aWVfc2VsZWN0aW9uICYmIHRoaXMuX21vZGVsLmRhdGFbb2JqLmlkXS5zdGF0ZS5jaGVja2VkKSB7IHRtcC5jbGFzc05hbWUgKz0gJyBqc3RyZWUtY2hlY2tlZCc7IH1cblx0XHRcdFx0XHRpY29uID0gX2kuY2xvbmVOb2RlKGZhbHNlKTtcblx0XHRcdFx0XHRpZih0aGlzLl9tb2RlbC5kYXRhW29iai5pZF0uc3RhdGUuY2hlY2tib3hfZGlzYWJsZWQpIHsgaWNvbi5jbGFzc05hbWUgKz0gJyBqc3RyZWUtY2hlY2tib3gtZGlzYWJsZWQnOyB9XG5cdFx0XHRcdFx0dG1wLmluc2VydEJlZm9yZShpY29uLCB0bXAuY2hpbGROb2Rlc1swXSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGlmKCFpc19jYWxsYmFjayAmJiB0aGlzLnNldHRpbmdzLmNoZWNrYm94LmNhc2NhZGUuaW5kZXhPZigndW5kZXRlcm1pbmVkJykgIT09IC0xKSB7XG5cdFx0XHRcdGlmKHRoaXMuX2RhdGEuY2hlY2tib3gudXRvKSB7IGNsZWFyVGltZW91dCh0aGlzLl9kYXRhLmNoZWNrYm94LnV0byk7IH1cblx0XHRcdFx0dGhpcy5fZGF0YS5jaGVja2JveC51dG8gPSBzZXRUaW1lb3V0KCQucHJveHkodGhpcy5fdW5kZXRlcm1pbmVkLCB0aGlzKSwgNTApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG9iajtcblx0XHR9O1xuXHRcdC8qKlxuXHRcdCAqIHNob3cgdGhlIG5vZGUgY2hlY2tib3ggaWNvbnNcblx0XHQgKiBAbmFtZSBzaG93X2NoZWNrYm94ZXMoKVxuXHRcdCAqIEBwbHVnaW4gY2hlY2tib3hcblx0XHQgKi9cblx0XHR0aGlzLnNob3dfY2hlY2tib3hlcyA9IGZ1bmN0aW9uICgpIHsgdGhpcy5fZGF0YS5jb3JlLnRoZW1lcy5jaGVja2JveGVzID0gdHJ1ZTsgdGhpcy5nZXRfY29udGFpbmVyX3VsKCkucmVtb3ZlQ2xhc3MoXCJqc3RyZWUtbm8tY2hlY2tib3hlc1wiKTsgfTtcblx0XHQvKipcblx0XHQgKiBoaWRlIHRoZSBub2RlIGNoZWNrYm94IGljb25zXG5cdFx0ICogQG5hbWUgaGlkZV9jaGVja2JveGVzKClcblx0XHQgKiBAcGx1Z2luIGNoZWNrYm94XG5cdFx0ICovXG5cdFx0dGhpcy5oaWRlX2NoZWNrYm94ZXMgPSBmdW5jdGlvbiAoKSB7IHRoaXMuX2RhdGEuY29yZS50aGVtZXMuY2hlY2tib3hlcyA9IGZhbHNlOyB0aGlzLmdldF9jb250YWluZXJfdWwoKS5hZGRDbGFzcyhcImpzdHJlZS1uby1jaGVja2JveGVzXCIpOyB9O1xuXHRcdC8qKlxuXHRcdCAqIHRvZ2dsZSB0aGUgbm9kZSBpY29uc1xuXHRcdCAqIEBuYW1lIHRvZ2dsZV9jaGVja2JveGVzKClcblx0XHQgKiBAcGx1Z2luIGNoZWNrYm94XG5cdFx0ICovXG5cdFx0dGhpcy50b2dnbGVfY2hlY2tib3hlcyA9IGZ1bmN0aW9uICgpIHsgaWYodGhpcy5fZGF0YS5jb3JlLnRoZW1lcy5jaGVja2JveGVzKSB7IHRoaXMuaGlkZV9jaGVja2JveGVzKCk7IH0gZWxzZSB7IHRoaXMuc2hvd19jaGVja2JveGVzKCk7IH0gfTtcblx0XHQvKipcblx0XHQgKiBjaGVja3MgaWYgYSBub2RlIGlzIGluIGFuIHVuZGV0ZXJtaW5lZCBzdGF0ZVxuXHRcdCAqIEBuYW1lIGlzX3VuZGV0ZXJtaW5lZChvYmopXG5cdFx0ICogQHBhcmFtICB7bWl4ZWR9IG9ialxuXHRcdCAqIEByZXR1cm4ge0Jvb2xlYW59XG5cdFx0ICovXG5cdFx0dGhpcy5pc191bmRldGVybWluZWQgPSBmdW5jdGlvbiAob2JqKSB7XG5cdFx0XHRvYmogPSB0aGlzLmdldF9ub2RlKG9iaik7XG5cdFx0XHR2YXIgcyA9IHRoaXMuc2V0dGluZ3MuY2hlY2tib3guY2FzY2FkZSwgaSwgaiwgdCA9IHRoaXMuc2V0dGluZ3MuY2hlY2tib3gudGllX3NlbGVjdGlvbiwgZCA9IHRoaXMuX2RhdGFbIHQgPyAnY29yZScgOiAnY2hlY2tib3gnIF0uc2VsZWN0ZWQsIG0gPSB0aGlzLl9tb2RlbC5kYXRhO1xuXHRcdFx0aWYoIW9iaiB8fCBvYmouc3RhdGVbIHQgPyAnc2VsZWN0ZWQnIDogJ2NoZWNrZWQnIF0gPT09IHRydWUgfHwgcy5pbmRleE9mKCd1bmRldGVybWluZWQnKSA9PT0gLTEgfHwgKHMuaW5kZXhPZignZG93bicpID09PSAtMSAmJiBzLmluZGV4T2YoJ3VwJykgPT09IC0xKSkge1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cdFx0XHRpZighb2JqLnN0YXRlLmxvYWRlZCAmJiBvYmoub3JpZ2luYWwuc3RhdGUudW5kZXRlcm1pbmVkID09PSB0cnVlKSB7XG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fVxuXHRcdFx0Zm9yKGkgPSAwLCBqID0gb2JqLmNoaWxkcmVuX2QubGVuZ3RoOyBpIDwgajsgaSsrKSB7XG5cdFx0XHRcdGlmKCQuaW5BcnJheShvYmouY2hpbGRyZW5fZFtpXSwgZCkgIT09IC0xIHx8ICghbVtvYmouY2hpbGRyZW5fZFtpXV0uc3RhdGUubG9hZGVkICYmIG1bb2JqLmNoaWxkcmVuX2RbaV1dLm9yaWdpbmFsLnN0YXRlLnVuZGV0ZXJtaW5lZCkpIHtcblx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH07XG5cdFx0LyoqXG5cdFx0ICogZGlzYWJsZSBhIG5vZGUncyBjaGVja2JveFxuXHRcdCAqIEBuYW1lIGRpc2FibGVfY2hlY2tib3gob2JqKVxuXHRcdCAqIEBwYXJhbSB7bWl4ZWR9IG9iaiBhbiBhcnJheSBjYW4gYmUgdXNlZCB0b29cblx0XHQgKiBAdHJpZ2dlciBkaXNhYmxlX2NoZWNrYm94LmpzdHJlZVxuXHRcdCAqIEBwbHVnaW4gY2hlY2tib3hcblx0XHQgKi9cblx0XHR0aGlzLmRpc2FibGVfY2hlY2tib3ggPSBmdW5jdGlvbiAob2JqKSB7XG5cdFx0XHR2YXIgdDEsIHQyLCBkb207XG5cdFx0XHRpZigkLmlzQXJyYXkob2JqKSkge1xuXHRcdFx0XHRvYmogPSBvYmouc2xpY2UoKTtcblx0XHRcdFx0Zm9yKHQxID0gMCwgdDIgPSBvYmoubGVuZ3RoOyB0MSA8IHQyOyB0MSsrKSB7XG5cdFx0XHRcdFx0dGhpcy5kaXNhYmxlX2NoZWNrYm94KG9ialt0MV0pO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fVxuXHRcdFx0b2JqID0gdGhpcy5nZXRfbm9kZShvYmopO1xuXHRcdFx0aWYoIW9iaiB8fCBvYmouaWQgPT09ICQuanN0cmVlLnJvb3QpIHtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXHRcdFx0ZG9tID0gdGhpcy5nZXRfbm9kZShvYmosIHRydWUpO1xuXHRcdFx0aWYoIW9iai5zdGF0ZS5jaGVja2JveF9kaXNhYmxlZCkge1xuXHRcdFx0XHRvYmouc3RhdGUuY2hlY2tib3hfZGlzYWJsZWQgPSB0cnVlO1xuXHRcdFx0XHRpZihkb20gJiYgZG9tLmxlbmd0aCkge1xuXHRcdFx0XHRcdGRvbS5jaGlsZHJlbignLmpzdHJlZS1hbmNob3InKS5jaGlsZHJlbignLmpzdHJlZS1jaGVja2JveCcpLmFkZENsYXNzKCdqc3RyZWUtY2hlY2tib3gtZGlzYWJsZWQnKTtcblx0XHRcdFx0fVxuXHRcdFx0XHQvKipcblx0XHRcdFx0ICogdHJpZ2dlcmVkIHdoZW4gYW4gbm9kZSdzIGNoZWNrYm94IGlzIGRpc2FibGVkXG5cdFx0XHRcdCAqIEBldmVudFxuXHRcdFx0XHQgKiBAbmFtZSBkaXNhYmxlX2NoZWNrYm94LmpzdHJlZVxuXHRcdFx0XHQgKiBAcGFyYW0ge09iamVjdH0gbm9kZVxuXHRcdFx0XHQgKiBAcGx1Z2luIGNoZWNrYm94XG5cdFx0XHRcdCAqL1xuXHRcdFx0XHR0aGlzLnRyaWdnZXIoJ2Rpc2FibGVfY2hlY2tib3gnLCB7ICdub2RlJyA6IG9iaiB9KTtcblx0XHRcdH1cblx0XHR9O1xuXHRcdC8qKlxuXHRcdCAqIGVuYWJsZSBhIG5vZGUncyBjaGVja2JveFxuXHRcdCAqIEBuYW1lIGRpc2FibGVfY2hlY2tib3gob2JqKVxuXHRcdCAqIEBwYXJhbSB7bWl4ZWR9IG9iaiBhbiBhcnJheSBjYW4gYmUgdXNlZCB0b29cblx0XHQgKiBAdHJpZ2dlciBlbmFibGVfY2hlY2tib3guanN0cmVlXG5cdFx0ICogQHBsdWdpbiBjaGVja2JveFxuXHRcdCAqL1xuXHRcdHRoaXMuZW5hYmxlX2NoZWNrYm94ID0gZnVuY3Rpb24gKG9iaikge1xuXHRcdFx0dmFyIHQxLCB0MiwgZG9tO1xuXHRcdFx0aWYoJC5pc0FycmF5KG9iaikpIHtcblx0XHRcdFx0b2JqID0gb2JqLnNsaWNlKCk7XG5cdFx0XHRcdGZvcih0MSA9IDAsIHQyID0gb2JqLmxlbmd0aDsgdDEgPCB0MjsgdDErKykge1xuXHRcdFx0XHRcdHRoaXMuZW5hYmxlX2NoZWNrYm94KG9ialt0MV0pO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fVxuXHRcdFx0b2JqID0gdGhpcy5nZXRfbm9kZShvYmopO1xuXHRcdFx0aWYoIW9iaiB8fCBvYmouaWQgPT09ICQuanN0cmVlLnJvb3QpIHtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXHRcdFx0ZG9tID0gdGhpcy5nZXRfbm9kZShvYmosIHRydWUpO1xuXHRcdFx0aWYob2JqLnN0YXRlLmNoZWNrYm94X2Rpc2FibGVkKSB7XG5cdFx0XHRcdG9iai5zdGF0ZS5jaGVja2JveF9kaXNhYmxlZCA9IGZhbHNlO1xuXHRcdFx0XHRpZihkb20gJiYgZG9tLmxlbmd0aCkge1xuXHRcdFx0XHRcdGRvbS5jaGlsZHJlbignLmpzdHJlZS1hbmNob3InKS5jaGlsZHJlbignLmpzdHJlZS1jaGVja2JveCcpLnJlbW92ZUNsYXNzKCdqc3RyZWUtY2hlY2tib3gtZGlzYWJsZWQnKTtcblx0XHRcdFx0fVxuXHRcdFx0XHQvKipcblx0XHRcdFx0ICogdHJpZ2dlcmVkIHdoZW4gYW4gbm9kZSdzIGNoZWNrYm94IGlzIGVuYWJsZWRcblx0XHRcdFx0ICogQGV2ZW50XG5cdFx0XHRcdCAqIEBuYW1lIGVuYWJsZV9jaGVja2JveC5qc3RyZWVcblx0XHRcdFx0ICogQHBhcmFtIHtPYmplY3R9IG5vZGVcblx0XHRcdFx0ICogQHBsdWdpbiBjaGVja2JveFxuXHRcdFx0XHQgKi9cblx0XHRcdFx0dGhpcy50cmlnZ2VyKCdlbmFibGVfY2hlY2tib3gnLCB7ICdub2RlJyA6IG9iaiB9KTtcblx0XHRcdH1cblx0XHR9O1xuXG5cdFx0dGhpcy5hY3RpdmF0ZV9ub2RlID0gZnVuY3Rpb24gKG9iaiwgZSkge1xuXHRcdFx0aWYoJChlLnRhcmdldCkuaGFzQ2xhc3MoJ2pzdHJlZS1jaGVja2JveC1kaXNhYmxlZCcpKSB7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblx0XHRcdGlmKHRoaXMuc2V0dGluZ3MuY2hlY2tib3gudGllX3NlbGVjdGlvbiAmJiAodGhpcy5zZXR0aW5ncy5jaGVja2JveC53aG9sZV9ub2RlIHx8ICQoZS50YXJnZXQpLmhhc0NsYXNzKCdqc3RyZWUtY2hlY2tib3gnKSkpIHtcblx0XHRcdFx0ZS5jdHJsS2V5ID0gdHJ1ZTtcblx0XHRcdH1cblx0XHRcdGlmKHRoaXMuc2V0dGluZ3MuY2hlY2tib3gudGllX3NlbGVjdGlvbiB8fCAoIXRoaXMuc2V0dGluZ3MuY2hlY2tib3gud2hvbGVfbm9kZSAmJiAhJChlLnRhcmdldCkuaGFzQ2xhc3MoJ2pzdHJlZS1jaGVja2JveCcpKSkge1xuXHRcdFx0XHRyZXR1cm4gcGFyZW50LmFjdGl2YXRlX25vZGUuY2FsbCh0aGlzLCBvYmosIGUpO1xuXHRcdFx0fVxuXHRcdFx0aWYodGhpcy5pc19kaXNhYmxlZChvYmopKSB7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblx0XHRcdGlmKHRoaXMuaXNfY2hlY2tlZChvYmopKSB7XG5cdFx0XHRcdHRoaXMudW5jaGVja19ub2RlKG9iaiwgZSk7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIHtcblx0XHRcdFx0dGhpcy5jaGVja19ub2RlKG9iaiwgZSk7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLnRyaWdnZXIoJ2FjdGl2YXRlX25vZGUnLCB7ICdub2RlJyA6IHRoaXMuZ2V0X25vZGUob2JqKSB9KTtcblx0XHR9O1xuXG5cdFx0LyoqXG5cdFx0ICogY2hlY2sgYSBub2RlIChvbmx5IGlmIHRpZV9zZWxlY3Rpb24gaW4gY2hlY2tib3ggc2V0dGluZ3MgaXMgZmFsc2UsIG90aGVyd2lzZSBzZWxlY3Rfbm9kZSB3aWxsIGJlIGNhbGxlZCBpbnRlcm5hbGx5KVxuXHRcdCAqIEBuYW1lIGNoZWNrX25vZGUob2JqKVxuXHRcdCAqIEBwYXJhbSB7bWl4ZWR9IG9iaiBhbiBhcnJheSBjYW4gYmUgdXNlZCB0byBjaGVjayBtdWx0aXBsZSBub2Rlc1xuXHRcdCAqIEB0cmlnZ2VyIGNoZWNrX25vZGUuanN0cmVlXG5cdFx0ICogQHBsdWdpbiBjaGVja2JveFxuXHRcdCAqL1xuXHRcdHRoaXMuY2hlY2tfbm9kZSA9IGZ1bmN0aW9uIChvYmosIGUpIHtcblx0XHRcdGlmKHRoaXMuc2V0dGluZ3MuY2hlY2tib3gudGllX3NlbGVjdGlvbikgeyByZXR1cm4gdGhpcy5zZWxlY3Rfbm9kZShvYmosIGZhbHNlLCB0cnVlLCBlKTsgfVxuXHRcdFx0dmFyIGRvbSwgdDEsIHQyLCB0aDtcblx0XHRcdGlmKCQuaXNBcnJheShvYmopKSB7XG5cdFx0XHRcdG9iaiA9IG9iai5zbGljZSgpO1xuXHRcdFx0XHRmb3IodDEgPSAwLCB0MiA9IG9iai5sZW5ndGg7IHQxIDwgdDI7IHQxKyspIHtcblx0XHRcdFx0XHR0aGlzLmNoZWNrX25vZGUob2JqW3QxXSwgZSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9XG5cdFx0XHRvYmogPSB0aGlzLmdldF9ub2RlKG9iaik7XG5cdFx0XHRpZighb2JqIHx8IG9iai5pZCA9PT0gJC5qc3RyZWUucm9vdCkge1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cdFx0XHRkb20gPSB0aGlzLmdldF9ub2RlKG9iaiwgdHJ1ZSk7XG5cdFx0XHRpZighb2JqLnN0YXRlLmNoZWNrZWQpIHtcblx0XHRcdFx0b2JqLnN0YXRlLmNoZWNrZWQgPSB0cnVlO1xuXHRcdFx0XHR0aGlzLl9kYXRhLmNoZWNrYm94LnNlbGVjdGVkLnB1c2gob2JqLmlkKTtcblx0XHRcdFx0aWYoZG9tICYmIGRvbS5sZW5ndGgpIHtcblx0XHRcdFx0XHRkb20uY2hpbGRyZW4oJy5qc3RyZWUtYW5jaG9yJykuYWRkQ2xhc3MoJ2pzdHJlZS1jaGVja2VkJyk7XG5cdFx0XHRcdH1cblx0XHRcdFx0LyoqXG5cdFx0XHRcdCAqIHRyaWdnZXJlZCB3aGVuIGFuIG5vZGUgaXMgY2hlY2tlZCAob25seSBpZiB0aWVfc2VsZWN0aW9uIGluIGNoZWNrYm94IHNldHRpbmdzIGlzIGZhbHNlKVxuXHRcdFx0XHQgKiBAZXZlbnRcblx0XHRcdFx0ICogQG5hbWUgY2hlY2tfbm9kZS5qc3RyZWVcblx0XHRcdFx0ICogQHBhcmFtIHtPYmplY3R9IG5vZGVcblx0XHRcdFx0ICogQHBhcmFtIHtBcnJheX0gc2VsZWN0ZWQgdGhlIGN1cnJlbnQgc2VsZWN0aW9uXG5cdFx0XHRcdCAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCB0aGUgZXZlbnQgKGlmIGFueSkgdGhhdCB0cmlnZ2VyZWQgdGhpcyBjaGVja19ub2RlXG5cdFx0XHRcdCAqIEBwbHVnaW4gY2hlY2tib3hcblx0XHRcdFx0ICovXG5cdFx0XHRcdHRoaXMudHJpZ2dlcignY2hlY2tfbm9kZScsIHsgJ25vZGUnIDogb2JqLCAnc2VsZWN0ZWQnIDogdGhpcy5fZGF0YS5jaGVja2JveC5zZWxlY3RlZCwgJ2V2ZW50JyA6IGUgfSk7XG5cdFx0XHR9XG5cdFx0fTtcblx0XHQvKipcblx0XHQgKiB1bmNoZWNrIGEgbm9kZSAob25seSBpZiB0aWVfc2VsZWN0aW9uIGluIGNoZWNrYm94IHNldHRpbmdzIGlzIGZhbHNlLCBvdGhlcndpc2UgZGVzZWxlY3Rfbm9kZSB3aWxsIGJlIGNhbGxlZCBpbnRlcm5hbGx5KVxuXHRcdCAqIEBuYW1lIHVuY2hlY2tfbm9kZShvYmopXG5cdFx0ICogQHBhcmFtIHttaXhlZH0gb2JqIGFuIGFycmF5IGNhbiBiZSB1c2VkIHRvIHVuY2hlY2sgbXVsdGlwbGUgbm9kZXNcblx0XHQgKiBAdHJpZ2dlciB1bmNoZWNrX25vZGUuanN0cmVlXG5cdFx0ICogQHBsdWdpbiBjaGVja2JveFxuXHRcdCAqL1xuXHRcdHRoaXMudW5jaGVja19ub2RlID0gZnVuY3Rpb24gKG9iaiwgZSkge1xuXHRcdFx0aWYodGhpcy5zZXR0aW5ncy5jaGVja2JveC50aWVfc2VsZWN0aW9uKSB7IHJldHVybiB0aGlzLmRlc2VsZWN0X25vZGUob2JqLCBmYWxzZSwgZSk7IH1cblx0XHRcdHZhciB0MSwgdDIsIGRvbTtcblx0XHRcdGlmKCQuaXNBcnJheShvYmopKSB7XG5cdFx0XHRcdG9iaiA9IG9iai5zbGljZSgpO1xuXHRcdFx0XHRmb3IodDEgPSAwLCB0MiA9IG9iai5sZW5ndGg7IHQxIDwgdDI7IHQxKyspIHtcblx0XHRcdFx0XHR0aGlzLnVuY2hlY2tfbm9kZShvYmpbdDFdLCBlKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblx0XHRcdG9iaiA9IHRoaXMuZ2V0X25vZGUob2JqKTtcblx0XHRcdGlmKCFvYmogfHwgb2JqLmlkID09PSAkLmpzdHJlZS5yb290KSB7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblx0XHRcdGRvbSA9IHRoaXMuZ2V0X25vZGUob2JqLCB0cnVlKTtcblx0XHRcdGlmKG9iai5zdGF0ZS5jaGVja2VkKSB7XG5cdFx0XHRcdG9iai5zdGF0ZS5jaGVja2VkID0gZmFsc2U7XG5cdFx0XHRcdHRoaXMuX2RhdGEuY2hlY2tib3guc2VsZWN0ZWQgPSAkLnZha2F0YS5hcnJheV9yZW1vdmVfaXRlbSh0aGlzLl9kYXRhLmNoZWNrYm94LnNlbGVjdGVkLCBvYmouaWQpO1xuXHRcdFx0XHRpZihkb20ubGVuZ3RoKSB7XG5cdFx0XHRcdFx0ZG9tLmNoaWxkcmVuKCcuanN0cmVlLWFuY2hvcicpLnJlbW92ZUNsYXNzKCdqc3RyZWUtY2hlY2tlZCcpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdC8qKlxuXHRcdFx0XHQgKiB0cmlnZ2VyZWQgd2hlbiBhbiBub2RlIGlzIHVuY2hlY2tlZCAob25seSBpZiB0aWVfc2VsZWN0aW9uIGluIGNoZWNrYm94IHNldHRpbmdzIGlzIGZhbHNlKVxuXHRcdFx0XHQgKiBAZXZlbnRcblx0XHRcdFx0ICogQG5hbWUgdW5jaGVja19ub2RlLmpzdHJlZVxuXHRcdFx0XHQgKiBAcGFyYW0ge09iamVjdH0gbm9kZVxuXHRcdFx0XHQgKiBAcGFyYW0ge0FycmF5fSBzZWxlY3RlZCB0aGUgY3VycmVudCBzZWxlY3Rpb25cblx0XHRcdFx0ICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IHRoZSBldmVudCAoaWYgYW55KSB0aGF0IHRyaWdnZXJlZCB0aGlzIHVuY2hlY2tfbm9kZVxuXHRcdFx0XHQgKiBAcGx1Z2luIGNoZWNrYm94XG5cdFx0XHRcdCAqL1xuXHRcdFx0XHR0aGlzLnRyaWdnZXIoJ3VuY2hlY2tfbm9kZScsIHsgJ25vZGUnIDogb2JqLCAnc2VsZWN0ZWQnIDogdGhpcy5fZGF0YS5jaGVja2JveC5zZWxlY3RlZCwgJ2V2ZW50JyA6IGUgfSk7XG5cdFx0XHR9XG5cdFx0fTtcblx0XHQvKipcblx0XHQgKiBjaGVja3MgYWxsIG5vZGVzIGluIHRoZSB0cmVlIChvbmx5IGlmIHRpZV9zZWxlY3Rpb24gaW4gY2hlY2tib3ggc2V0dGluZ3MgaXMgZmFsc2UsIG90aGVyd2lzZSBzZWxlY3RfYWxsIHdpbGwgYmUgY2FsbGVkIGludGVybmFsbHkpXG5cdFx0ICogQG5hbWUgY2hlY2tfYWxsKClcblx0XHQgKiBAdHJpZ2dlciBjaGVja19hbGwuanN0cmVlLCBjaGFuZ2VkLmpzdHJlZVxuXHRcdCAqIEBwbHVnaW4gY2hlY2tib3hcblx0XHQgKi9cblx0XHR0aGlzLmNoZWNrX2FsbCA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdGlmKHRoaXMuc2V0dGluZ3MuY2hlY2tib3gudGllX3NlbGVjdGlvbikgeyByZXR1cm4gdGhpcy5zZWxlY3RfYWxsKCk7IH1cblx0XHRcdHZhciB0bXAgPSB0aGlzLl9kYXRhLmNoZWNrYm94LnNlbGVjdGVkLmNvbmNhdChbXSksIGksIGo7XG5cdFx0XHR0aGlzLl9kYXRhLmNoZWNrYm94LnNlbGVjdGVkID0gdGhpcy5fbW9kZWwuZGF0YVskLmpzdHJlZS5yb290XS5jaGlsZHJlbl9kLmNvbmNhdCgpO1xuXHRcdFx0Zm9yKGkgPSAwLCBqID0gdGhpcy5fZGF0YS5jaGVja2JveC5zZWxlY3RlZC5sZW5ndGg7IGkgPCBqOyBpKyspIHtcblx0XHRcdFx0aWYodGhpcy5fbW9kZWwuZGF0YVt0aGlzLl9kYXRhLmNoZWNrYm94LnNlbGVjdGVkW2ldXSkge1xuXHRcdFx0XHRcdHRoaXMuX21vZGVsLmRhdGFbdGhpcy5fZGF0YS5jaGVja2JveC5zZWxlY3RlZFtpXV0uc3RhdGUuY2hlY2tlZCA9IHRydWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHRoaXMucmVkcmF3KHRydWUpO1xuXHRcdFx0LyoqXG5cdFx0XHQgKiB0cmlnZ2VyZWQgd2hlbiBhbGwgbm9kZXMgYXJlIGNoZWNrZWQgKG9ubHkgaWYgdGllX3NlbGVjdGlvbiBpbiBjaGVja2JveCBzZXR0aW5ncyBpcyBmYWxzZSlcblx0XHRcdCAqIEBldmVudFxuXHRcdFx0ICogQG5hbWUgY2hlY2tfYWxsLmpzdHJlZVxuXHRcdFx0ICogQHBhcmFtIHtBcnJheX0gc2VsZWN0ZWQgdGhlIGN1cnJlbnQgc2VsZWN0aW9uXG5cdFx0XHQgKiBAcGx1Z2luIGNoZWNrYm94XG5cdFx0XHQgKi9cblx0XHRcdHRoaXMudHJpZ2dlcignY2hlY2tfYWxsJywgeyAnc2VsZWN0ZWQnIDogdGhpcy5fZGF0YS5jaGVja2JveC5zZWxlY3RlZCB9KTtcblx0XHR9O1xuXHRcdC8qKlxuXHRcdCAqIHVuY2hlY2sgYWxsIGNoZWNrZWQgbm9kZXMgKG9ubHkgaWYgdGllX3NlbGVjdGlvbiBpbiBjaGVja2JveCBzZXR0aW5ncyBpcyBmYWxzZSwgb3RoZXJ3aXNlIGRlc2VsZWN0X2FsbCB3aWxsIGJlIGNhbGxlZCBpbnRlcm5hbGx5KVxuXHRcdCAqIEBuYW1lIHVuY2hlY2tfYWxsKClcblx0XHQgKiBAdHJpZ2dlciB1bmNoZWNrX2FsbC5qc3RyZWVcblx0XHQgKiBAcGx1Z2luIGNoZWNrYm94XG5cdFx0ICovXG5cdFx0dGhpcy51bmNoZWNrX2FsbCA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdGlmKHRoaXMuc2V0dGluZ3MuY2hlY2tib3gudGllX3NlbGVjdGlvbikgeyByZXR1cm4gdGhpcy5kZXNlbGVjdF9hbGwoKTsgfVxuXHRcdFx0dmFyIHRtcCA9IHRoaXMuX2RhdGEuY2hlY2tib3guc2VsZWN0ZWQuY29uY2F0KFtdKSwgaSwgajtcblx0XHRcdGZvcihpID0gMCwgaiA9IHRoaXMuX2RhdGEuY2hlY2tib3guc2VsZWN0ZWQubGVuZ3RoOyBpIDwgajsgaSsrKSB7XG5cdFx0XHRcdGlmKHRoaXMuX21vZGVsLmRhdGFbdGhpcy5fZGF0YS5jaGVja2JveC5zZWxlY3RlZFtpXV0pIHtcblx0XHRcdFx0XHR0aGlzLl9tb2RlbC5kYXRhW3RoaXMuX2RhdGEuY2hlY2tib3guc2VsZWN0ZWRbaV1dLnN0YXRlLmNoZWNrZWQgPSBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0dGhpcy5fZGF0YS5jaGVja2JveC5zZWxlY3RlZCA9IFtdO1xuXHRcdFx0dGhpcy5lbGVtZW50LmZpbmQoJy5qc3RyZWUtY2hlY2tlZCcpLnJlbW92ZUNsYXNzKCdqc3RyZWUtY2hlY2tlZCcpO1xuXHRcdFx0LyoqXG5cdFx0XHQgKiB0cmlnZ2VyZWQgd2hlbiBhbGwgbm9kZXMgYXJlIHVuY2hlY2tlZCAob25seSBpZiB0aWVfc2VsZWN0aW9uIGluIGNoZWNrYm94IHNldHRpbmdzIGlzIGZhbHNlKVxuXHRcdFx0ICogQGV2ZW50XG5cdFx0XHQgKiBAbmFtZSB1bmNoZWNrX2FsbC5qc3RyZWVcblx0XHRcdCAqIEBwYXJhbSB7T2JqZWN0fSBub2RlIHRoZSBwcmV2aW91cyBzZWxlY3Rpb25cblx0XHRcdCAqIEBwYXJhbSB7QXJyYXl9IHNlbGVjdGVkIHRoZSBjdXJyZW50IHNlbGVjdGlvblxuXHRcdFx0ICogQHBsdWdpbiBjaGVja2JveFxuXHRcdFx0ICovXG5cdFx0XHR0aGlzLnRyaWdnZXIoJ3VuY2hlY2tfYWxsJywgeyAnc2VsZWN0ZWQnIDogdGhpcy5fZGF0YS5jaGVja2JveC5zZWxlY3RlZCwgJ25vZGUnIDogdG1wIH0pO1xuXHRcdH07XG5cdFx0LyoqXG5cdFx0ICogY2hlY2tzIGlmIGEgbm9kZSBpcyBjaGVja2VkIChpZiB0aWVfc2VsZWN0aW9uIGlzIG9uIGluIHRoZSBzZXR0aW5ncyB0aGlzIGZ1bmN0aW9uIHdpbGwgcmV0dXJuIHRoZSBzYW1lIGFzIGlzX3NlbGVjdGVkKVxuXHRcdCAqIEBuYW1lIGlzX2NoZWNrZWQob2JqKVxuXHRcdCAqIEBwYXJhbSAge21peGVkfSAgb2JqXG5cdFx0ICogQHJldHVybiB7Qm9vbGVhbn1cblx0XHQgKiBAcGx1Z2luIGNoZWNrYm94XG5cdFx0ICovXG5cdFx0dGhpcy5pc19jaGVja2VkID0gZnVuY3Rpb24gKG9iaikge1xuXHRcdFx0aWYodGhpcy5zZXR0aW5ncy5jaGVja2JveC50aWVfc2VsZWN0aW9uKSB7IHJldHVybiB0aGlzLmlzX3NlbGVjdGVkKG9iaik7IH1cblx0XHRcdG9iaiA9IHRoaXMuZ2V0X25vZGUob2JqKTtcblx0XHRcdGlmKCFvYmogfHwgb2JqLmlkID09PSAkLmpzdHJlZS5yb290KSB7IHJldHVybiBmYWxzZTsgfVxuXHRcdFx0cmV0dXJuIG9iai5zdGF0ZS5jaGVja2VkO1xuXHRcdH07XG5cdFx0LyoqXG5cdFx0ICogZ2V0IGFuIGFycmF5IG9mIGFsbCBjaGVja2VkIG5vZGVzIChpZiB0aWVfc2VsZWN0aW9uIGlzIG9uIGluIHRoZSBzZXR0aW5ncyB0aGlzIGZ1bmN0aW9uIHdpbGwgcmV0dXJuIHRoZSBzYW1lIGFzIGdldF9zZWxlY3RlZClcblx0XHQgKiBAbmFtZSBnZXRfY2hlY2tlZChbZnVsbF0pXG5cdFx0ICogQHBhcmFtICB7bWl4ZWR9ICBmdWxsIGlmIHNldCB0byBgdHJ1ZWAgdGhlIHJldHVybmVkIGFycmF5IHdpbGwgY29uc2lzdCBvZiB0aGUgZnVsbCBub2RlIG9iamVjdHMsIG90aGVyd2lzZSAtIG9ubHkgSURzIHdpbGwgYmUgcmV0dXJuZWRcblx0XHQgKiBAcmV0dXJuIHtBcnJheX1cblx0XHQgKiBAcGx1Z2luIGNoZWNrYm94XG5cdFx0ICovXG5cdFx0dGhpcy5nZXRfY2hlY2tlZCA9IGZ1bmN0aW9uIChmdWxsKSB7XG5cdFx0XHRpZih0aGlzLnNldHRpbmdzLmNoZWNrYm94LnRpZV9zZWxlY3Rpb24pIHsgcmV0dXJuIHRoaXMuZ2V0X3NlbGVjdGVkKGZ1bGwpOyB9XG5cdFx0XHRyZXR1cm4gZnVsbCA/ICQubWFwKHRoaXMuX2RhdGEuY2hlY2tib3guc2VsZWN0ZWQsICQucHJveHkoZnVuY3Rpb24gKGkpIHsgcmV0dXJuIHRoaXMuZ2V0X25vZGUoaSk7IH0sIHRoaXMpKSA6IHRoaXMuX2RhdGEuY2hlY2tib3guc2VsZWN0ZWQ7XG5cdFx0fTtcblx0XHQvKipcblx0XHQgKiBnZXQgYW4gYXJyYXkgb2YgYWxsIHRvcCBsZXZlbCBjaGVja2VkIG5vZGVzIChpZ25vcmluZyBjaGlsZHJlbiBvZiBjaGVja2VkIG5vZGVzKSAoaWYgdGllX3NlbGVjdGlvbiBpcyBvbiBpbiB0aGUgc2V0dGluZ3MgdGhpcyBmdW5jdGlvbiB3aWxsIHJldHVybiB0aGUgc2FtZSBhcyBnZXRfdG9wX3NlbGVjdGVkKVxuXHRcdCAqIEBuYW1lIGdldF90b3BfY2hlY2tlZChbZnVsbF0pXG5cdFx0ICogQHBhcmFtICB7bWl4ZWR9ICBmdWxsIGlmIHNldCB0byBgdHJ1ZWAgdGhlIHJldHVybmVkIGFycmF5IHdpbGwgY29uc2lzdCBvZiB0aGUgZnVsbCBub2RlIG9iamVjdHMsIG90aGVyd2lzZSAtIG9ubHkgSURzIHdpbGwgYmUgcmV0dXJuZWRcblx0XHQgKiBAcmV0dXJuIHtBcnJheX1cblx0XHQgKiBAcGx1Z2luIGNoZWNrYm94XG5cdFx0ICovXG5cdFx0dGhpcy5nZXRfdG9wX2NoZWNrZWQgPSBmdW5jdGlvbiAoZnVsbCkge1xuXHRcdFx0aWYodGhpcy5zZXR0aW5ncy5jaGVja2JveC50aWVfc2VsZWN0aW9uKSB7IHJldHVybiB0aGlzLmdldF90b3Bfc2VsZWN0ZWQoZnVsbCk7IH1cblx0XHRcdHZhciB0bXAgPSB0aGlzLmdldF9jaGVja2VkKHRydWUpLFxuXHRcdFx0XHRvYmogPSB7fSwgaSwgaiwgaywgbDtcblx0XHRcdGZvcihpID0gMCwgaiA9IHRtcC5sZW5ndGg7IGkgPCBqOyBpKyspIHtcblx0XHRcdFx0b2JqW3RtcFtpXS5pZF0gPSB0bXBbaV07XG5cdFx0XHR9XG5cdFx0XHRmb3IoaSA9IDAsIGogPSB0bXAubGVuZ3RoOyBpIDwgajsgaSsrKSB7XG5cdFx0XHRcdGZvcihrID0gMCwgbCA9IHRtcFtpXS5jaGlsZHJlbl9kLmxlbmd0aDsgayA8IGw7IGsrKykge1xuXHRcdFx0XHRcdGlmKG9ialt0bXBbaV0uY2hpbGRyZW5fZFtrXV0pIHtcblx0XHRcdFx0XHRcdGRlbGV0ZSBvYmpbdG1wW2ldLmNoaWxkcmVuX2Rba11dO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0dG1wID0gW107XG5cdFx0XHRmb3IoaSBpbiBvYmopIHtcblx0XHRcdFx0aWYob2JqLmhhc093blByb3BlcnR5KGkpKSB7XG5cdFx0XHRcdFx0dG1wLnB1c2goaSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiBmdWxsID8gJC5tYXAodG1wLCAkLnByb3h5KGZ1bmN0aW9uIChpKSB7IHJldHVybiB0aGlzLmdldF9ub2RlKGkpOyB9LCB0aGlzKSkgOiB0bXA7XG5cdFx0fTtcblx0XHQvKipcblx0XHQgKiBnZXQgYW4gYXJyYXkgb2YgYWxsIGJvdHRvbSBsZXZlbCBjaGVja2VkIG5vZGVzIChpZ25vcmluZyBzZWxlY3RlZCBwYXJlbnRzKSAoaWYgdGllX3NlbGVjdGlvbiBpcyBvbiBpbiB0aGUgc2V0dGluZ3MgdGhpcyBmdW5jdGlvbiB3aWxsIHJldHVybiB0aGUgc2FtZSBhcyBnZXRfYm90dG9tX3NlbGVjdGVkKVxuXHRcdCAqIEBuYW1lIGdldF9ib3R0b21fY2hlY2tlZChbZnVsbF0pXG5cdFx0ICogQHBhcmFtICB7bWl4ZWR9ICBmdWxsIGlmIHNldCB0byBgdHJ1ZWAgdGhlIHJldHVybmVkIGFycmF5IHdpbGwgY29uc2lzdCBvZiB0aGUgZnVsbCBub2RlIG9iamVjdHMsIG90aGVyd2lzZSAtIG9ubHkgSURzIHdpbGwgYmUgcmV0dXJuZWRcblx0XHQgKiBAcmV0dXJuIHtBcnJheX1cblx0XHQgKiBAcGx1Z2luIGNoZWNrYm94XG5cdFx0ICovXG5cdFx0dGhpcy5nZXRfYm90dG9tX2NoZWNrZWQgPSBmdW5jdGlvbiAoZnVsbCkge1xuXHRcdFx0aWYodGhpcy5zZXR0aW5ncy5jaGVja2JveC50aWVfc2VsZWN0aW9uKSB7IHJldHVybiB0aGlzLmdldF9ib3R0b21fc2VsZWN0ZWQoZnVsbCk7IH1cblx0XHRcdHZhciB0bXAgPSB0aGlzLmdldF9jaGVja2VkKHRydWUpLFxuXHRcdFx0XHRvYmogPSBbXSwgaSwgajtcblx0XHRcdGZvcihpID0gMCwgaiA9IHRtcC5sZW5ndGg7IGkgPCBqOyBpKyspIHtcblx0XHRcdFx0aWYoIXRtcFtpXS5jaGlsZHJlbi5sZW5ndGgpIHtcblx0XHRcdFx0XHRvYmoucHVzaCh0bXBbaV0uaWQpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gZnVsbCA/ICQubWFwKG9iaiwgJC5wcm94eShmdW5jdGlvbiAoaSkgeyByZXR1cm4gdGhpcy5nZXRfbm9kZShpKTsgfSwgdGhpcykpIDogb2JqO1xuXHRcdH07XG5cdFx0dGhpcy5sb2FkX25vZGUgPSBmdW5jdGlvbiAob2JqLCBjYWxsYmFjaykge1xuXHRcdFx0dmFyIGssIGwsIGksIGosIGMsIHRtcDtcblx0XHRcdGlmKCEkLmlzQXJyYXkob2JqKSAmJiAhdGhpcy5zZXR0aW5ncy5jaGVja2JveC50aWVfc2VsZWN0aW9uKSB7XG5cdFx0XHRcdHRtcCA9IHRoaXMuZ2V0X25vZGUob2JqKTtcblx0XHRcdFx0aWYodG1wICYmIHRtcC5zdGF0ZS5sb2FkZWQpIHtcblx0XHRcdFx0XHRmb3IoayA9IDAsIGwgPSB0bXAuY2hpbGRyZW5fZC5sZW5ndGg7IGsgPCBsOyBrKyspIHtcblx0XHRcdFx0XHRcdGlmKHRoaXMuX21vZGVsLmRhdGFbdG1wLmNoaWxkcmVuX2Rba11dLnN0YXRlLmNoZWNrZWQpIHtcblx0XHRcdFx0XHRcdFx0YyA9IHRydWU7XG5cdFx0XHRcdFx0XHRcdHRoaXMuX2RhdGEuY2hlY2tib3guc2VsZWN0ZWQgPSAkLnZha2F0YS5hcnJheV9yZW1vdmVfaXRlbSh0aGlzLl9kYXRhLmNoZWNrYm94LnNlbGVjdGVkLCB0bXAuY2hpbGRyZW5fZFtrXSk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcGFyZW50LmxvYWRfbm9kZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHRcdH07XG5cdFx0dGhpcy5nZXRfc3RhdGUgPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHR2YXIgc3RhdGUgPSBwYXJlbnQuZ2V0X3N0YXRlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdFx0XHRpZih0aGlzLnNldHRpbmdzLmNoZWNrYm94LnRpZV9zZWxlY3Rpb24pIHsgcmV0dXJuIHN0YXRlOyB9XG5cdFx0XHRzdGF0ZS5jaGVja2JveCA9IHRoaXMuX2RhdGEuY2hlY2tib3guc2VsZWN0ZWQuc2xpY2UoKTtcblx0XHRcdHJldHVybiBzdGF0ZTtcblx0XHR9O1xuXHRcdHRoaXMuc2V0X3N0YXRlID0gZnVuY3Rpb24gKHN0YXRlLCBjYWxsYmFjaykge1xuXHRcdFx0dmFyIHJlcyA9IHBhcmVudC5zZXRfc3RhdGUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0XHRcdGlmKHJlcyAmJiBzdGF0ZS5jaGVja2JveCkge1xuXHRcdFx0XHRpZighdGhpcy5zZXR0aW5ncy5jaGVja2JveC50aWVfc2VsZWN0aW9uKSB7XG5cdFx0XHRcdFx0dGhpcy51bmNoZWNrX2FsbCgpO1xuXHRcdFx0XHRcdHZhciBfdGhpcyA9IHRoaXM7XG5cdFx0XHRcdFx0JC5lYWNoKHN0YXRlLmNoZWNrYm94LCBmdW5jdGlvbiAoaSwgdikge1xuXHRcdFx0XHRcdFx0X3RoaXMuY2hlY2tfbm9kZSh2KTtcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0fVxuXHRcdFx0XHRkZWxldGUgc3RhdGUuY2hlY2tib3g7XG5cdFx0XHRcdHRoaXMuc2V0X3N0YXRlKHN0YXRlLCBjYWxsYmFjayk7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblx0XHRcdHJldHVybiByZXM7XG5cdFx0fTtcblx0XHR0aGlzLnJlZnJlc2ggPSBmdW5jdGlvbiAoc2tpcF9sb2FkaW5nLCBmb3JnZXRfc3RhdGUpIHtcblx0XHRcdGlmKCF0aGlzLnNldHRpbmdzLmNoZWNrYm94LnRpZV9zZWxlY3Rpb24pIHtcblx0XHRcdFx0dGhpcy5fZGF0YS5jaGVja2JveC5zZWxlY3RlZCA9IFtdO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHBhcmVudC5yZWZyZXNoLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdFx0fTtcblx0fTtcblxuXHQvLyBpbmNsdWRlIHRoZSBjaGVja2JveCBwbHVnaW4gYnkgZGVmYXVsdFxuXHQvLyAkLmpzdHJlZS5kZWZhdWx0cy5wbHVnaW5zLnB1c2goXCJjaGVja2JveFwiKTtcblxuLyoqXG4gKiAjIyMgQ29uZGl0aW9uYWxzZWxlY3QgcGx1Z2luXG4gKlxuICogVGhpcyBwbHVnaW4gYWxsb3dzIGRlZmluaW5nIGEgY2FsbGJhY2sgdG8gYWxsb3cgb3IgZGVueSBub2RlIHNlbGVjdGlvbiBieSB1c2VyIGlucHV0IChhY3RpdmF0ZSBub2RlIG1ldGhvZCkuXG4gKi9cblxuXHQvKipcblx0ICogYSBjYWxsYmFjayAoZnVuY3Rpb24pIHdoaWNoIGlzIGludm9rZWQgaW4gdGhlIGluc3RhbmNlJ3Mgc2NvcGUgYW5kIHJlY2VpdmVzIHR3byBhcmd1bWVudHMgLSB0aGUgbm9kZSBhbmQgdGhlIGV2ZW50IHRoYXQgdHJpZ2dlcmVkIHRoZSBgYWN0aXZhdGVfbm9kZWAgY2FsbC4gUmV0dXJuaW5nIGZhbHNlIHByZXZlbnRzIHdvcmtpbmcgd2l0aCB0aGUgbm9kZSwgcmV0dXJuaW5nIHRydWUgYWxsb3dzIGludm9raW5nIGFjdGl2YXRlX25vZGUuIERlZmF1bHRzIHRvIHJldHVybmluZyBgdHJ1ZWAuXG5cdCAqIEBuYW1lICQuanN0cmVlLmRlZmF1bHRzLmNoZWNrYm94LnZpc2libGVcblx0ICogQHBsdWdpbiBjaGVja2JveFxuXHQgKi9cblx0JC5qc3RyZWUuZGVmYXVsdHMuY29uZGl0aW9uYWxzZWxlY3QgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0cnVlOyB9O1xuXHQkLmpzdHJlZS5wbHVnaW5zLmNvbmRpdGlvbmFsc2VsZWN0ID0gZnVuY3Rpb24gKG9wdGlvbnMsIHBhcmVudCkge1xuXHRcdC8vIG93biBmdW5jdGlvblxuXHRcdHRoaXMuYWN0aXZhdGVfbm9kZSA9IGZ1bmN0aW9uIChvYmosIGUpIHtcblx0XHRcdGlmKHRoaXMuc2V0dGluZ3MuY29uZGl0aW9uYWxzZWxlY3QuY2FsbCh0aGlzLCB0aGlzLmdldF9ub2RlKG9iaiksIGUpKSB7XG5cdFx0XHRcdHBhcmVudC5hY3RpdmF0ZV9ub2RlLmNhbGwodGhpcywgb2JqLCBlKTtcblx0XHRcdH1cblx0XHR9O1xuXHR9O1xuXG5cbi8qKlxuICogIyMjIENvbnRleHRtZW51IHBsdWdpblxuICpcbiAqIFNob3dzIGEgY29udGV4dCBtZW51IHdoZW4gYSBub2RlIGlzIHJpZ2h0LWNsaWNrZWQuXG4gKi9cblxuXHQvKipcblx0ICogc3RvcmVzIGFsbCBkZWZhdWx0cyBmb3IgdGhlIGNvbnRleHRtZW51IHBsdWdpblxuXHQgKiBAbmFtZSAkLmpzdHJlZS5kZWZhdWx0cy5jb250ZXh0bWVudVxuXHQgKiBAcGx1Z2luIGNvbnRleHRtZW51XG5cdCAqL1xuXHQkLmpzdHJlZS5kZWZhdWx0cy5jb250ZXh0bWVudSA9IHtcblx0XHQvKipcblx0XHQgKiBhIGJvb2xlYW4gaW5kaWNhdGluZyBpZiB0aGUgbm9kZSBzaG91bGQgYmUgc2VsZWN0ZWQgd2hlbiB0aGUgY29udGV4dCBtZW51IGlzIGludm9rZWQgb24gaXQuIERlZmF1bHRzIHRvIGB0cnVlYC5cblx0XHQgKiBAbmFtZSAkLmpzdHJlZS5kZWZhdWx0cy5jb250ZXh0bWVudS5zZWxlY3Rfbm9kZVxuXHRcdCAqIEBwbHVnaW4gY29udGV4dG1lbnVcblx0XHQgKi9cblx0XHRzZWxlY3Rfbm9kZSA6IHRydWUsXG5cdFx0LyoqXG5cdFx0ICogYSBib29sZWFuIGluZGljYXRpbmcgaWYgdGhlIG1lbnUgc2hvdWxkIGJlIHNob3duIGFsaWduZWQgd2l0aCB0aGUgbm9kZS4gRGVmYXVsdHMgdG8gYHRydWVgLCBvdGhlcndpc2UgdGhlIG1vdXNlIGNvb3JkaW5hdGVzIGFyZSB1c2VkLlxuXHRcdCAqIEBuYW1lICQuanN0cmVlLmRlZmF1bHRzLmNvbnRleHRtZW51LnNob3dfYXRfbm9kZVxuXHRcdCAqIEBwbHVnaW4gY29udGV4dG1lbnVcblx0XHQgKi9cblx0XHRzaG93X2F0X25vZGUgOiB0cnVlLFxuXHRcdC8qKlxuXHRcdCAqIGFuIG9iamVjdCBvZiBhY3Rpb25zLCBvciBhIGZ1bmN0aW9uIHRoYXQgYWNjZXB0cyBhIG5vZGUgYW5kIGEgY2FsbGJhY2sgZnVuY3Rpb24gYW5kIGNhbGxzIHRoZSBjYWxsYmFjayBmdW5jdGlvbiB3aXRoIGFuIG9iamVjdCBvZiBhY3Rpb25zIGF2YWlsYWJsZSBmb3IgdGhhdCBub2RlICh5b3UgY2FuIGFsc28gcmV0dXJuIHRoZSBpdGVtcyB0b28pLlxuXHRcdCAqXG5cdFx0ICogRWFjaCBhY3Rpb24gY29uc2lzdHMgb2YgYSBrZXkgKGEgdW5pcXVlIG5hbWUpIGFuZCBhIHZhbHVlIHdoaWNoIGlzIGFuIG9iamVjdCB3aXRoIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllcyAob25seSBsYWJlbCBhbmQgYWN0aW9uIGFyZSByZXF1aXJlZCkuIE9uY2UgYSBtZW51IGl0ZW0gaXMgYWN0aXZhdGVkIHRoZSBgYWN0aW9uYCBmdW5jdGlvbiB3aWxsIGJlIGludm9rZWQgd2l0aCBhbiBvYmplY3QgY29udGFpbmluZyB0aGUgZm9sbG93aW5nIGtleXM6IGl0ZW0gLSB0aGUgY29udGV4dG1lbnUgaXRlbSBkZWZpbml0aW9uIGFzIHNlZW4gYmVsb3csIHJlZmVyZW5jZSAtIHRoZSBET00gbm9kZSB0aGF0IHdhcyB1c2VkICh0aGUgdHJlZSBub2RlKSwgZWxlbWVudCAtIHRoZSBjb250ZXh0bWVudSBET00gZWxlbWVudCwgcG9zaXRpb24gLSBhbiBvYmplY3Qgd2l0aCB4L3kgcHJvcGVydGllcyBpbmRpY2F0aW5nIHRoZSBwb3NpdGlvbiBvZiB0aGUgbWVudS5cblx0XHQgKlxuXHRcdCAqICogYHNlcGFyYXRvcl9iZWZvcmVgIC0gYSBib29sZWFuIGluZGljYXRpbmcgaWYgdGhlcmUgc2hvdWxkIGJlIGEgc2VwYXJhdG9yIGJlZm9yZSB0aGlzIGl0ZW1cblx0XHQgKiAqIGBzZXBhcmF0b3JfYWZ0ZXJgIC0gYSBib29sZWFuIGluZGljYXRpbmcgaWYgdGhlcmUgc2hvdWxkIGJlIGEgc2VwYXJhdG9yIGFmdGVyIHRoaXMgaXRlbVxuXHRcdCAqICogYF9kaXNhYmxlZGAgLSBhIGJvb2xlYW4gaW5kaWNhdGluZyBpZiB0aGlzIGFjdGlvbiBzaG91bGQgYmUgZGlzYWJsZWRcblx0XHQgKiAqIGBsYWJlbGAgLSBhIHN0cmluZyAtIHRoZSBuYW1lIG9mIHRoZSBhY3Rpb24gKGNvdWxkIGJlIGEgZnVuY3Rpb24gcmV0dXJuaW5nIGEgc3RyaW5nKVxuXHRcdCAqICogYHRpdGxlYCAtIGEgc3RyaW5nIC0gYW4gb3B0aW9uYWwgdG9vbHRpcCBmb3IgdGhlIGl0ZW1cblx0XHQgKiAqIGBhY3Rpb25gIC0gYSBmdW5jdGlvbiB0byBiZSBleGVjdXRlZCBpZiB0aGlzIGl0ZW0gaXMgY2hvc2VuLCB0aGUgZnVuY3Rpb24gd2lsbCByZWNlaXZlIFxuXHRcdCAqICogYGljb25gIC0gYSBzdHJpbmcsIGNhbiBiZSBhIHBhdGggdG8gYW4gaWNvbiBvciBhIGNsYXNzTmFtZSwgaWYgdXNpbmcgYW4gaW1hZ2UgdGhhdCBpcyBpbiB0aGUgY3VycmVudCBkaXJlY3RvcnkgdXNlIGEgYC4vYCBwcmVmaXgsIG90aGVyd2lzZSBpdCB3aWxsIGJlIGRldGVjdGVkIGFzIGEgY2xhc3Ncblx0XHQgKiAqIGBzaG9ydGN1dGAgLSBrZXlDb2RlIHdoaWNoIHdpbGwgdHJpZ2dlciB0aGUgYWN0aW9uIGlmIHRoZSBtZW51IGlzIG9wZW4gKGZvciBleGFtcGxlIGAxMTNgIGZvciByZW5hbWUsIHdoaWNoIGVxdWFscyBGMilcblx0XHQgKiAqIGBzaG9ydGN1dF9sYWJlbGAgLSBzaG9ydGN1dCBsYWJlbCAobGlrZSBmb3IgZXhhbXBsZSBgRjJgIGZvciByZW5hbWUpXG5cdFx0ICogKiBgc3VibWVudWAgLSBhbiBvYmplY3Qgd2l0aCB0aGUgc2FtZSBzdHJ1Y3R1cmUgYXMgJC5qc3RyZWUuZGVmYXVsdHMuY29udGV4dG1lbnUuaXRlbXMgd2hpY2ggY2FuIGJlIHVzZWQgdG8gY3JlYXRlIGEgc3VibWVudSAtIGVhY2gga2V5IHdpbGwgYmUgcmVuZGVyZWQgYXMgYSBzZXBhcmF0ZSBvcHRpb24gaW4gYSBzdWJtZW51IHRoYXQgd2lsbCBhcHBlYXIgb25jZSB0aGUgY3VycmVudCBpdGVtIGlzIGhvdmVyZWRcblx0XHQgKlxuXHRcdCAqIEBuYW1lICQuanN0cmVlLmRlZmF1bHRzLmNvbnRleHRtZW51Lml0ZW1zXG5cdFx0ICogQHBsdWdpbiBjb250ZXh0bWVudVxuXHRcdCAqL1xuXHRcdGl0ZW1zIDogZnVuY3Rpb24gKG8sIGNiKSB7IC8vIENvdWxkIGJlIGFuIG9iamVjdCBkaXJlY3RseVxuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0XCJjcmVhdGVcIiA6IHtcblx0XHRcdFx0XHRcInNlcGFyYXRvcl9iZWZvcmVcIlx0OiBmYWxzZSxcblx0XHRcdFx0XHRcInNlcGFyYXRvcl9hZnRlclwiXHQ6IHRydWUsXG5cdFx0XHRcdFx0XCJfZGlzYWJsZWRcIlx0XHRcdDogZmFsc2UsIC8vKHRoaXMuY2hlY2soXCJjcmVhdGVfbm9kZVwiLCBkYXRhLnJlZmVyZW5jZSwge30sIFwibGFzdFwiKSksXG5cdFx0XHRcdFx0XCJsYWJlbFwiXHRcdFx0XHQ6IFwiQ3JlYXRlXCIsXG5cdFx0XHRcdFx0XCJhY3Rpb25cIlx0XHRcdDogZnVuY3Rpb24gKGRhdGEpIHtcblx0XHRcdFx0XHRcdHZhciBpbnN0ID0gJC5qc3RyZWUucmVmZXJlbmNlKGRhdGEucmVmZXJlbmNlKSxcblx0XHRcdFx0XHRcdFx0b2JqID0gaW5zdC5nZXRfbm9kZShkYXRhLnJlZmVyZW5jZSk7XG5cdFx0XHRcdFx0XHRpbnN0LmNyZWF0ZV9ub2RlKG9iaiwge30sIFwibGFzdFwiLCBmdW5jdGlvbiAobmV3X25vZGUpIHtcblx0XHRcdFx0XHRcdFx0c2V0VGltZW91dChmdW5jdGlvbiAoKSB7IGluc3QuZWRpdChuZXdfbm9kZSk7IH0sMCk7XG5cdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0sXG5cdFx0XHRcdFwicmVuYW1lXCIgOiB7XG5cdFx0XHRcdFx0XCJzZXBhcmF0b3JfYmVmb3JlXCJcdDogZmFsc2UsXG5cdFx0XHRcdFx0XCJzZXBhcmF0b3JfYWZ0ZXJcIlx0OiBmYWxzZSxcblx0XHRcdFx0XHRcIl9kaXNhYmxlZFwiXHRcdFx0OiBmYWxzZSwgLy8odGhpcy5jaGVjayhcInJlbmFtZV9ub2RlXCIsIGRhdGEucmVmZXJlbmNlLCB0aGlzLmdldF9wYXJlbnQoZGF0YS5yZWZlcmVuY2UpLCBcIlwiKSksXG5cdFx0XHRcdFx0XCJsYWJlbFwiXHRcdFx0XHQ6IFwiUmVuYW1lXCIsXG5cdFx0XHRcdFx0LyohXG5cdFx0XHRcdFx0XCJzaG9ydGN1dFwiXHRcdFx0OiAxMTMsXG5cdFx0XHRcdFx0XCJzaG9ydGN1dF9sYWJlbFwiXHQ6ICdGMicsXG5cdFx0XHRcdFx0XCJpY29uXCJcdFx0XHRcdDogXCJnbHlwaGljb24gZ2x5cGhpY29uLWxlYWZcIixcblx0XHRcdFx0XHQqL1xuXHRcdFx0XHRcdFwiYWN0aW9uXCJcdFx0XHQ6IGZ1bmN0aW9uIChkYXRhKSB7XG5cdFx0XHRcdFx0XHR2YXIgaW5zdCA9ICQuanN0cmVlLnJlZmVyZW5jZShkYXRhLnJlZmVyZW5jZSksXG5cdFx0XHRcdFx0XHRcdG9iaiA9IGluc3QuZ2V0X25vZGUoZGF0YS5yZWZlcmVuY2UpO1xuXHRcdFx0XHRcdFx0aW5zdC5lZGl0KG9iaik7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9LFxuXHRcdFx0XHRcInJlbW92ZVwiIDoge1xuXHRcdFx0XHRcdFwic2VwYXJhdG9yX2JlZm9yZVwiXHQ6IGZhbHNlLFxuXHRcdFx0XHRcdFwiaWNvblwiXHRcdFx0XHQ6IGZhbHNlLFxuXHRcdFx0XHRcdFwic2VwYXJhdG9yX2FmdGVyXCJcdDogZmFsc2UsXG5cdFx0XHRcdFx0XCJfZGlzYWJsZWRcIlx0XHRcdDogZmFsc2UsIC8vKHRoaXMuY2hlY2soXCJkZWxldGVfbm9kZVwiLCBkYXRhLnJlZmVyZW5jZSwgdGhpcy5nZXRfcGFyZW50KGRhdGEucmVmZXJlbmNlKSwgXCJcIikpLFxuXHRcdFx0XHRcdFwibGFiZWxcIlx0XHRcdFx0OiBcIkRlbGV0ZVwiLFxuXHRcdFx0XHRcdFwiYWN0aW9uXCJcdFx0XHQ6IGZ1bmN0aW9uIChkYXRhKSB7XG5cdFx0XHRcdFx0XHR2YXIgaW5zdCA9ICQuanN0cmVlLnJlZmVyZW5jZShkYXRhLnJlZmVyZW5jZSksXG5cdFx0XHRcdFx0XHRcdG9iaiA9IGluc3QuZ2V0X25vZGUoZGF0YS5yZWZlcmVuY2UpO1xuXHRcdFx0XHRcdFx0aWYoaW5zdC5pc19zZWxlY3RlZChvYmopKSB7XG5cdFx0XHRcdFx0XHRcdGluc3QuZGVsZXRlX25vZGUoaW5zdC5nZXRfc2VsZWN0ZWQoKSk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRcdFx0aW5zdC5kZWxldGVfbm9kZShvYmopO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSxcblx0XHRcdFx0XCJjY3BcIiA6IHtcblx0XHRcdFx0XHRcInNlcGFyYXRvcl9iZWZvcmVcIlx0OiB0cnVlLFxuXHRcdFx0XHRcdFwiaWNvblwiXHRcdFx0XHQ6IGZhbHNlLFxuXHRcdFx0XHRcdFwic2VwYXJhdG9yX2FmdGVyXCJcdDogZmFsc2UsXG5cdFx0XHRcdFx0XCJsYWJlbFwiXHRcdFx0XHQ6IFwiRWRpdFwiLFxuXHRcdFx0XHRcdFwiYWN0aW9uXCJcdFx0XHQ6IGZhbHNlLFxuXHRcdFx0XHRcdFwic3VibWVudVwiIDoge1xuXHRcdFx0XHRcdFx0XCJjdXRcIiA6IHtcblx0XHRcdFx0XHRcdFx0XCJzZXBhcmF0b3JfYmVmb3JlXCJcdDogZmFsc2UsXG5cdFx0XHRcdFx0XHRcdFwic2VwYXJhdG9yX2FmdGVyXCJcdDogZmFsc2UsXG5cdFx0XHRcdFx0XHRcdFwibGFiZWxcIlx0XHRcdFx0OiBcIkN1dFwiLFxuXHRcdFx0XHRcdFx0XHRcImFjdGlvblwiXHRcdFx0OiBmdW5jdGlvbiAoZGF0YSkge1xuXHRcdFx0XHRcdFx0XHRcdHZhciBpbnN0ID0gJC5qc3RyZWUucmVmZXJlbmNlKGRhdGEucmVmZXJlbmNlKSxcblx0XHRcdFx0XHRcdFx0XHRcdG9iaiA9IGluc3QuZ2V0X25vZGUoZGF0YS5yZWZlcmVuY2UpO1xuXHRcdFx0XHRcdFx0XHRcdGlmKGluc3QuaXNfc2VsZWN0ZWQob2JqKSkge1xuXHRcdFx0XHRcdFx0XHRcdFx0aW5zdC5jdXQoaW5zdC5nZXRfdG9wX3NlbGVjdGVkKCkpO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRcdGluc3QuY3V0KG9iaik7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XCJjb3B5XCIgOiB7XG5cdFx0XHRcdFx0XHRcdFwic2VwYXJhdG9yX2JlZm9yZVwiXHQ6IGZhbHNlLFxuXHRcdFx0XHRcdFx0XHRcImljb25cIlx0XHRcdFx0OiBmYWxzZSxcblx0XHRcdFx0XHRcdFx0XCJzZXBhcmF0b3JfYWZ0ZXJcIlx0OiBmYWxzZSxcblx0XHRcdFx0XHRcdFx0XCJsYWJlbFwiXHRcdFx0XHQ6IFwiQ29weVwiLFxuXHRcdFx0XHRcdFx0XHRcImFjdGlvblwiXHRcdFx0OiBmdW5jdGlvbiAoZGF0YSkge1xuXHRcdFx0XHRcdFx0XHRcdHZhciBpbnN0ID0gJC5qc3RyZWUucmVmZXJlbmNlKGRhdGEucmVmZXJlbmNlKSxcblx0XHRcdFx0XHRcdFx0XHRcdG9iaiA9IGluc3QuZ2V0X25vZGUoZGF0YS5yZWZlcmVuY2UpO1xuXHRcdFx0XHRcdFx0XHRcdGlmKGluc3QuaXNfc2VsZWN0ZWQob2JqKSkge1xuXHRcdFx0XHRcdFx0XHRcdFx0aW5zdC5jb3B5KGluc3QuZ2V0X3RvcF9zZWxlY3RlZCgpKTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRpbnN0LmNvcHkob2JqKTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcInBhc3RlXCIgOiB7XG5cdFx0XHRcdFx0XHRcdFwic2VwYXJhdG9yX2JlZm9yZVwiXHQ6IGZhbHNlLFxuXHRcdFx0XHRcdFx0XHRcImljb25cIlx0XHRcdFx0OiBmYWxzZSxcblx0XHRcdFx0XHRcdFx0XCJfZGlzYWJsZWRcIlx0XHRcdDogZnVuY3Rpb24gKGRhdGEpIHtcblx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gISQuanN0cmVlLnJlZmVyZW5jZShkYXRhLnJlZmVyZW5jZSkuY2FuX3Bhc3RlKCk7XG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFwic2VwYXJhdG9yX2FmdGVyXCJcdDogZmFsc2UsXG5cdFx0XHRcdFx0XHRcdFwibGFiZWxcIlx0XHRcdFx0OiBcIlBhc3RlXCIsXG5cdFx0XHRcdFx0XHRcdFwiYWN0aW9uXCJcdFx0XHQ6IGZ1bmN0aW9uIChkYXRhKSB7XG5cdFx0XHRcdFx0XHRcdFx0dmFyIGluc3QgPSAkLmpzdHJlZS5yZWZlcmVuY2UoZGF0YS5yZWZlcmVuY2UpLFxuXHRcdFx0XHRcdFx0XHRcdFx0b2JqID0gaW5zdC5nZXRfbm9kZShkYXRhLnJlZmVyZW5jZSk7XG5cdFx0XHRcdFx0XHRcdFx0aW5zdC5wYXN0ZShvYmopO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXHRcdH1cblx0fTtcblxuXHQkLmpzdHJlZS5wbHVnaW5zLmNvbnRleHRtZW51ID0gZnVuY3Rpb24gKG9wdGlvbnMsIHBhcmVudCkge1xuXHRcdHRoaXMuYmluZCA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdHBhcmVudC5iaW5kLmNhbGwodGhpcyk7XG5cblx0XHRcdHZhciBsYXN0X3RzID0gMCwgY3RvID0gbnVsbCwgZXgsIGV5O1xuXHRcdFx0dGhpcy5lbGVtZW50XG5cdFx0XHRcdC5vbihcImNvbnRleHRtZW51LmpzdHJlZVwiLCBcIi5qc3RyZWUtYW5jaG9yXCIsICQucHJveHkoZnVuY3Rpb24gKGUsIGRhdGEpIHtcblx0XHRcdFx0XHRcdGlmIChlLnRhcmdldC50YWdOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdpbnB1dCcpIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0ZS5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0XHRcdFx0bGFzdF90cyA9IGUuY3RybEtleSA/ICtuZXcgRGF0ZSgpIDogMDtcblx0XHRcdFx0XHRcdGlmKGRhdGEgfHwgY3RvKSB7XG5cdFx0XHRcdFx0XHRcdGxhc3RfdHMgPSAoK25ldyBEYXRlKCkpICsgMTAwMDA7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRpZihjdG8pIHtcblx0XHRcdFx0XHRcdFx0Y2xlYXJUaW1lb3V0KGN0byk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRpZighdGhpcy5pc19sb2FkaW5nKGUuY3VycmVudFRhcmdldCkpIHtcblx0XHRcdFx0XHRcdFx0dGhpcy5zaG93X2NvbnRleHRtZW51KGUuY3VycmVudFRhcmdldCwgZS5wYWdlWCwgZS5wYWdlWSwgZSk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSwgdGhpcykpXG5cdFx0XHRcdC5vbihcImNsaWNrLmpzdHJlZVwiLCBcIi5qc3RyZWUtYW5jaG9yXCIsICQucHJveHkoZnVuY3Rpb24gKGUpIHtcblx0XHRcdFx0XHRcdGlmKHRoaXMuX2RhdGEuY29udGV4dG1lbnUudmlzaWJsZSAmJiAoIWxhc3RfdHMgfHwgKCtuZXcgRGF0ZSgpKSAtIGxhc3RfdHMgPiAyNTApKSB7IC8vIHdvcmsgYXJvdW5kIHNhZmFyaSAmIG1hY09TIGN0cmwrY2xpY2tcblx0XHRcdFx0XHRcdFx0JC52YWthdGEuY29udGV4dC5oaWRlKCk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRsYXN0X3RzID0gMDtcblx0XHRcdFx0XHR9LCB0aGlzKSlcblx0XHRcdFx0Lm9uKFwidG91Y2hzdGFydC5qc3RyZWVcIiwgXCIuanN0cmVlLWFuY2hvclwiLCBmdW5jdGlvbiAoZSkge1xuXHRcdFx0XHRcdFx0aWYoIWUub3JpZ2luYWxFdmVudCB8fCAhZS5vcmlnaW5hbEV2ZW50LmNoYW5nZWRUb3VjaGVzIHx8ICFlLm9yaWdpbmFsRXZlbnQuY2hhbmdlZFRvdWNoZXNbMF0pIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0ZXggPSBlLm9yaWdpbmFsRXZlbnQuY2hhbmdlZFRvdWNoZXNbMF0uY2xpZW50WDtcblx0XHRcdFx0XHRcdGV5ID0gZS5vcmlnaW5hbEV2ZW50LmNoYW5nZWRUb3VjaGVzWzBdLmNsaWVudFk7XG5cdFx0XHRcdFx0XHRjdG8gPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0XHRcdFx0JChlLmN1cnJlbnRUYXJnZXQpLnRyaWdnZXIoJ2NvbnRleHRtZW51JywgdHJ1ZSk7XG5cdFx0XHRcdFx0XHR9LCA3NTApO1xuXHRcdFx0XHRcdH0pXG5cdFx0XHRcdC5vbigndG91Y2htb3ZlLnZha2F0YS5qc3RyZWUnLCBmdW5jdGlvbiAoZSkge1xuXHRcdFx0XHRcdFx0aWYoY3RvICYmIGUub3JpZ2luYWxFdmVudCAmJiBlLm9yaWdpbmFsRXZlbnQuY2hhbmdlZFRvdWNoZXMgJiYgZS5vcmlnaW5hbEV2ZW50LmNoYW5nZWRUb3VjaGVzWzBdICYmIChNYXRoLmFicyhleCAtIGUub3JpZ2luYWxFdmVudC5jaGFuZ2VkVG91Y2hlc1swXS5jbGllbnRYKSA+IDUwIHx8IE1hdGguYWJzKGV5IC0gZS5vcmlnaW5hbEV2ZW50LmNoYW5nZWRUb3VjaGVzWzBdLmNsaWVudFkpID4gNTApKSB7XG5cdFx0XHRcdFx0XHRcdGNsZWFyVGltZW91dChjdG8pO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0pXG5cdFx0XHRcdC5vbigndG91Y2hlbmQudmFrYXRhLmpzdHJlZScsIGZ1bmN0aW9uIChlKSB7XG5cdFx0XHRcdFx0XHRpZihjdG8pIHtcblx0XHRcdFx0XHRcdFx0Y2xlYXJUaW1lb3V0KGN0byk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSk7XG5cblx0XHRcdC8qIVxuXHRcdFx0aWYoISgnb25jb250ZXh0bWVudScgaW4gZG9jdW1lbnQuYm9keSkgJiYgKCdvbnRvdWNoc3RhcnQnIGluIGRvY3VtZW50LmJvZHkpKSB7XG5cdFx0XHRcdHZhciBlbCA9IG51bGwsIHRtID0gbnVsbDtcblx0XHRcdFx0dGhpcy5lbGVtZW50XG5cdFx0XHRcdFx0Lm9uKFwidG91Y2hzdGFydFwiLCBcIi5qc3RyZWUtYW5jaG9yXCIsIGZ1bmN0aW9uIChlKSB7XG5cdFx0XHRcdFx0XHRlbCA9IGUuY3VycmVudFRhcmdldDtcblx0XHRcdFx0XHRcdHRtID0gK25ldyBEYXRlKCk7XG5cdFx0XHRcdFx0XHQkKGRvY3VtZW50KS5vbmUoXCJ0b3VjaGVuZFwiLCBmdW5jdGlvbiAoZSkge1xuXHRcdFx0XHRcdFx0XHRlLnRhcmdldCA9IGRvY3VtZW50LmVsZW1lbnRGcm9tUG9pbnQoZS5vcmlnaW5hbEV2ZW50LnRhcmdldFRvdWNoZXNbMF0ucGFnZVggLSB3aW5kb3cucGFnZVhPZmZzZXQsIGUub3JpZ2luYWxFdmVudC50YXJnZXRUb3VjaGVzWzBdLnBhZ2VZIC0gd2luZG93LnBhZ2VZT2Zmc2V0KTtcblx0XHRcdFx0XHRcdFx0ZS5jdXJyZW50VGFyZ2V0ID0gZS50YXJnZXQ7XG5cdFx0XHRcdFx0XHRcdHRtID0gKCgrKG5ldyBEYXRlKCkpKSAtIHRtKTtcblx0XHRcdFx0XHRcdFx0aWYoZS50YXJnZXQgPT09IGVsICYmIHRtID4gNjAwICYmIHRtIDwgMTAwMCkge1xuXHRcdFx0XHRcdFx0XHRcdGUucHJldmVudERlZmF1bHQoKTtcblx0XHRcdFx0XHRcdFx0XHQkKGVsKS50cmlnZ2VyKCdjb250ZXh0bWVudScsIGUpO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdGVsID0gbnVsbDtcblx0XHRcdFx0XHRcdFx0dG0gPSBudWxsO1xuXHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cdFx0XHQqL1xuXHRcdFx0JChkb2N1bWVudCkub24oXCJjb250ZXh0X2hpZGUudmFrYXRhLmpzdHJlZVwiLCAkLnByb3h5KGZ1bmN0aW9uIChlLCBkYXRhKSB7XG5cdFx0XHRcdHRoaXMuX2RhdGEuY29udGV4dG1lbnUudmlzaWJsZSA9IGZhbHNlO1xuXHRcdFx0XHQkKGRhdGEucmVmZXJlbmNlKS5yZW1vdmVDbGFzcygnanN0cmVlLWNvbnRleHQnKTtcblx0XHRcdH0sIHRoaXMpKTtcblx0XHR9O1xuXHRcdHRoaXMudGVhcmRvd24gPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHRpZih0aGlzLl9kYXRhLmNvbnRleHRtZW51LnZpc2libGUpIHtcblx0XHRcdFx0JC52YWthdGEuY29udGV4dC5oaWRlKCk7XG5cdFx0XHR9XG5cdFx0XHRwYXJlbnQudGVhcmRvd24uY2FsbCh0aGlzKTtcblx0XHR9O1xuXG5cdFx0LyoqXG5cdFx0ICogcHJlcGFyZSBhbmQgc2hvdyB0aGUgY29udGV4dCBtZW51IGZvciBhIG5vZGVcblx0XHQgKiBAbmFtZSBzaG93X2NvbnRleHRtZW51KG9iaiBbLCB4LCB5XSlcblx0XHQgKiBAcGFyYW0ge21peGVkfSBvYmogdGhlIG5vZGVcblx0XHQgKiBAcGFyYW0ge051bWJlcn0geCB0aGUgeC1jb29yZGluYXRlIHJlbGF0aXZlIHRvIHRoZSBkb2N1bWVudCB0byBzaG93IHRoZSBtZW51IGF0XG5cdFx0ICogQHBhcmFtIHtOdW1iZXJ9IHkgdGhlIHktY29vcmRpbmF0ZSByZWxhdGl2ZSB0byB0aGUgZG9jdW1lbnQgdG8gc2hvdyB0aGUgbWVudSBhdFxuXHRcdCAqIEBwYXJhbSB7T2JqZWN0fSBlIHRoZSBldmVudCBpZiBhdmFpbGFibGUgdGhhdCB0cmlnZ2VyZWQgdGhlIGNvbnRleHRtZW51XG5cdFx0ICogQHBsdWdpbiBjb250ZXh0bWVudVxuXHRcdCAqIEB0cmlnZ2VyIHNob3dfY29udGV4dG1lbnUuanN0cmVlXG5cdFx0ICovXG5cdFx0dGhpcy5zaG93X2NvbnRleHRtZW51ID0gZnVuY3Rpb24gKG9iaiwgeCwgeSwgZSkge1xuXHRcdFx0b2JqID0gdGhpcy5nZXRfbm9kZShvYmopO1xuXHRcdFx0aWYoIW9iaiB8fCBvYmouaWQgPT09ICQuanN0cmVlLnJvb3QpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdFx0XHR2YXIgcyA9IHRoaXMuc2V0dGluZ3MuY29udGV4dG1lbnUsXG5cdFx0XHRcdGQgPSB0aGlzLmdldF9ub2RlKG9iaiwgdHJ1ZSksXG5cdFx0XHRcdGEgPSBkLmNoaWxkcmVuKFwiLmpzdHJlZS1hbmNob3JcIiksXG5cdFx0XHRcdG8gPSBmYWxzZSxcblx0XHRcdFx0aSA9IGZhbHNlO1xuXHRcdFx0aWYocy5zaG93X2F0X25vZGUgfHwgeCA9PT0gdW5kZWZpbmVkIHx8IHkgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRvID0gYS5vZmZzZXQoKTtcblx0XHRcdFx0eCA9IG8ubGVmdDtcblx0XHRcdFx0eSA9IG8udG9wICsgdGhpcy5fZGF0YS5jb3JlLmxpX2hlaWdodDtcblx0XHRcdH1cblx0XHRcdGlmKHRoaXMuc2V0dGluZ3MuY29udGV4dG1lbnUuc2VsZWN0X25vZGUgJiYgIXRoaXMuaXNfc2VsZWN0ZWQob2JqKSkge1xuXHRcdFx0XHR0aGlzLmFjdGl2YXRlX25vZGUob2JqLCBlKTtcblx0XHRcdH1cblxuXHRcdFx0aSA9IHMuaXRlbXM7XG5cdFx0XHRpZigkLmlzRnVuY3Rpb24oaSkpIHtcblx0XHRcdFx0aSA9IGkuY2FsbCh0aGlzLCBvYmosICQucHJveHkoZnVuY3Rpb24gKGkpIHtcblx0XHRcdFx0XHR0aGlzLl9zaG93X2NvbnRleHRtZW51KG9iaiwgeCwgeSwgaSk7XG5cdFx0XHRcdH0sIHRoaXMpKTtcblx0XHRcdH1cblx0XHRcdGlmKCQuaXNQbGFpbk9iamVjdChpKSkge1xuXHRcdFx0XHR0aGlzLl9zaG93X2NvbnRleHRtZW51KG9iaiwgeCwgeSwgaSk7XG5cdFx0XHR9XG5cdFx0fTtcblx0XHQvKipcblx0XHQgKiBzaG93IHRoZSBwcmVwYXJlZCBjb250ZXh0IG1lbnUgZm9yIGEgbm9kZVxuXHRcdCAqIEBuYW1lIF9zaG93X2NvbnRleHRtZW51KG9iaiwgeCwgeSwgaSlcblx0XHQgKiBAcGFyYW0ge21peGVkfSBvYmogdGhlIG5vZGVcblx0XHQgKiBAcGFyYW0ge051bWJlcn0geCB0aGUgeC1jb29yZGluYXRlIHJlbGF0aXZlIHRvIHRoZSBkb2N1bWVudCB0byBzaG93IHRoZSBtZW51IGF0XG5cdFx0ICogQHBhcmFtIHtOdW1iZXJ9IHkgdGhlIHktY29vcmRpbmF0ZSByZWxhdGl2ZSB0byB0aGUgZG9jdW1lbnQgdG8gc2hvdyB0aGUgbWVudSBhdFxuXHRcdCAqIEBwYXJhbSB7TnVtYmVyfSBpIHRoZSBvYmplY3Qgb2YgaXRlbXMgdG8gc2hvd1xuXHRcdCAqIEBwbHVnaW4gY29udGV4dG1lbnVcblx0XHQgKiBAdHJpZ2dlciBzaG93X2NvbnRleHRtZW51LmpzdHJlZVxuXHRcdCAqIEBwcml2YXRlXG5cdFx0ICovXG5cdFx0dGhpcy5fc2hvd19jb250ZXh0bWVudSA9IGZ1bmN0aW9uIChvYmosIHgsIHksIGkpIHtcblx0XHRcdHZhciBkID0gdGhpcy5nZXRfbm9kZShvYmosIHRydWUpLFxuXHRcdFx0XHRhID0gZC5jaGlsZHJlbihcIi5qc3RyZWUtYW5jaG9yXCIpO1xuXHRcdFx0JChkb2N1bWVudCkub25lKFwiY29udGV4dF9zaG93LnZha2F0YS5qc3RyZWVcIiwgJC5wcm94eShmdW5jdGlvbiAoZSwgZGF0YSkge1xuXHRcdFx0XHR2YXIgY2xzID0gJ2pzdHJlZS1jb250ZXh0bWVudSBqc3RyZWUtJyArIHRoaXMuZ2V0X3RoZW1lKCkgKyAnLWNvbnRleHRtZW51Jztcblx0XHRcdFx0JChkYXRhLmVsZW1lbnQpLmFkZENsYXNzKGNscyk7XG5cdFx0XHRcdGEuYWRkQ2xhc3MoJ2pzdHJlZS1jb250ZXh0Jyk7XG5cdFx0XHR9LCB0aGlzKSk7XG5cdFx0XHR0aGlzLl9kYXRhLmNvbnRleHRtZW51LnZpc2libGUgPSB0cnVlO1xuXHRcdFx0JC52YWthdGEuY29udGV4dC5zaG93KGEsIHsgJ3gnIDogeCwgJ3knIDogeSB9LCBpKTtcblx0XHRcdC8qKlxuXHRcdFx0ICogdHJpZ2dlcmVkIHdoZW4gdGhlIGNvbnRleHRtZW51IGlzIHNob3duIGZvciBhIG5vZGVcblx0XHRcdCAqIEBldmVudFxuXHRcdFx0ICogQG5hbWUgc2hvd19jb250ZXh0bWVudS5qc3RyZWVcblx0XHRcdCAqIEBwYXJhbSB7T2JqZWN0fSBub2RlIHRoZSBub2RlXG5cdFx0XHQgKiBAcGFyYW0ge051bWJlcn0geCB0aGUgeC1jb29yZGluYXRlIG9mIHRoZSBtZW51IHJlbGF0aXZlIHRvIHRoZSBkb2N1bWVudFxuXHRcdFx0ICogQHBhcmFtIHtOdW1iZXJ9IHkgdGhlIHktY29vcmRpbmF0ZSBvZiB0aGUgbWVudSByZWxhdGl2ZSB0byB0aGUgZG9jdW1lbnRcblx0XHRcdCAqIEBwbHVnaW4gY29udGV4dG1lbnVcblx0XHRcdCAqL1xuXHRcdFx0dGhpcy50cmlnZ2VyKCdzaG93X2NvbnRleHRtZW51JywgeyBcIm5vZGVcIiA6IG9iaiwgXCJ4XCIgOiB4LCBcInlcIiA6IHkgfSk7XG5cdFx0fTtcblx0fTtcblxuXHQvLyBjb250ZXh0bWVudSBoZWxwZXJcblx0KGZ1bmN0aW9uICgkKSB7XG5cdFx0dmFyIHJpZ2h0X3RvX2xlZnQgPSBmYWxzZSxcblx0XHRcdHZha2F0YV9jb250ZXh0ID0ge1xuXHRcdFx0XHRlbGVtZW50XHRcdDogZmFsc2UsXG5cdFx0XHRcdHJlZmVyZW5jZVx0OiBmYWxzZSxcblx0XHRcdFx0cG9zaXRpb25feFx0OiAwLFxuXHRcdFx0XHRwb3NpdGlvbl95XHQ6IDAsXG5cdFx0XHRcdGl0ZW1zXHRcdDogW10sXG5cdFx0XHRcdGh0bWxcdFx0OiBcIlwiLFxuXHRcdFx0XHRpc192aXNpYmxlXHQ6IGZhbHNlXG5cdFx0XHR9O1xuXG5cdFx0JC52YWthdGEuY29udGV4dCA9IHtcblx0XHRcdHNldHRpbmdzIDoge1xuXHRcdFx0XHRoaWRlX29ubW91c2VsZWF2ZVx0OiAwLFxuXHRcdFx0XHRpY29uc1x0XHRcdFx0OiB0cnVlXG5cdFx0XHR9LFxuXHRcdFx0X3RyaWdnZXIgOiBmdW5jdGlvbiAoZXZlbnRfbmFtZSkge1xuXHRcdFx0XHQkKGRvY3VtZW50KS50cmlnZ2VySGFuZGxlcihcImNvbnRleHRfXCIgKyBldmVudF9uYW1lICsgXCIudmFrYXRhXCIsIHtcblx0XHRcdFx0XHRcInJlZmVyZW5jZVwiXHQ6IHZha2F0YV9jb250ZXh0LnJlZmVyZW5jZSxcblx0XHRcdFx0XHRcImVsZW1lbnRcIlx0OiB2YWthdGFfY29udGV4dC5lbGVtZW50LFxuXHRcdFx0XHRcdFwicG9zaXRpb25cIlx0OiB7XG5cdFx0XHRcdFx0XHRcInhcIiA6IHZha2F0YV9jb250ZXh0LnBvc2l0aW9uX3gsXG5cdFx0XHRcdFx0XHRcInlcIiA6IHZha2F0YV9jb250ZXh0LnBvc2l0aW9uX3lcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pO1xuXHRcdFx0fSxcblx0XHRcdF9leGVjdXRlIDogZnVuY3Rpb24gKGkpIHtcblx0XHRcdFx0aSA9IHZha2F0YV9jb250ZXh0Lml0ZW1zW2ldO1xuXHRcdFx0XHRyZXR1cm4gaSAmJiAoIWkuX2Rpc2FibGVkIHx8ICgkLmlzRnVuY3Rpb24oaS5fZGlzYWJsZWQpICYmICFpLl9kaXNhYmxlZCh7IFwiaXRlbVwiIDogaSwgXCJyZWZlcmVuY2VcIiA6IHZha2F0YV9jb250ZXh0LnJlZmVyZW5jZSwgXCJlbGVtZW50XCIgOiB2YWthdGFfY29udGV4dC5lbGVtZW50IH0pKSkgJiYgaS5hY3Rpb24gPyBpLmFjdGlvbi5jYWxsKG51bGwsIHtcblx0XHRcdFx0XHRcdFx0XCJpdGVtXCJcdFx0OiBpLFxuXHRcdFx0XHRcdFx0XHRcInJlZmVyZW5jZVwiXHQ6IHZha2F0YV9jb250ZXh0LnJlZmVyZW5jZSxcblx0XHRcdFx0XHRcdFx0XCJlbGVtZW50XCJcdDogdmFrYXRhX2NvbnRleHQuZWxlbWVudCxcblx0XHRcdFx0XHRcdFx0XCJwb3NpdGlvblwiXHQ6IHtcblx0XHRcdFx0XHRcdFx0XHRcInhcIiA6IHZha2F0YV9jb250ZXh0LnBvc2l0aW9uX3gsXG5cdFx0XHRcdFx0XHRcdFx0XCJ5XCIgOiB2YWthdGFfY29udGV4dC5wb3NpdGlvbl95XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH0pIDogZmFsc2U7XG5cdFx0XHR9LFxuXHRcdFx0X3BhcnNlIDogZnVuY3Rpb24gKG8sIGlzX2NhbGxiYWNrKSB7XG5cdFx0XHRcdGlmKCFvKSB7IHJldHVybiBmYWxzZTsgfVxuXHRcdFx0XHRpZighaXNfY2FsbGJhY2spIHtcblx0XHRcdFx0XHR2YWthdGFfY29udGV4dC5odG1sXHRcdD0gXCJcIjtcblx0XHRcdFx0XHR2YWthdGFfY29udGV4dC5pdGVtc1x0PSBbXTtcblx0XHRcdFx0fVxuXHRcdFx0XHR2YXIgc3RyID0gXCJcIixcblx0XHRcdFx0XHRzZXAgPSBmYWxzZSxcblx0XHRcdFx0XHR0bXA7XG5cblx0XHRcdFx0aWYoaXNfY2FsbGJhY2spIHsgc3RyICs9IFwiPFwiK1widWw+XCI7IH1cblx0XHRcdFx0JC5lYWNoKG8sIGZ1bmN0aW9uIChpLCB2YWwpIHtcblx0XHRcdFx0XHRpZighdmFsKSB7IHJldHVybiB0cnVlOyB9XG5cdFx0XHRcdFx0dmFrYXRhX2NvbnRleHQuaXRlbXMucHVzaCh2YWwpO1xuXHRcdFx0XHRcdGlmKCFzZXAgJiYgdmFsLnNlcGFyYXRvcl9iZWZvcmUpIHtcblx0XHRcdFx0XHRcdHN0ciArPSBcIjxcIitcImxpIGNsYXNzPSd2YWthdGEtY29udGV4dC1zZXBhcmF0b3InPjxcIitcImEgaHJlZj0nIycgXCIgKyAoJC52YWthdGEuY29udGV4dC5zZXR0aW5ncy5pY29ucyA/ICcnIDogJ3N0eWxlPVwibWFyZ2luLWxlZnQ6MHB4O1wiJykgKyBcIj4mIzE2MDs8XCIrXCIvYT48XCIrXCIvbGk+XCI7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHNlcCA9IGZhbHNlO1xuXHRcdFx0XHRcdHN0ciArPSBcIjxcIitcImxpIGNsYXNzPSdcIiArICh2YWwuX2NsYXNzIHx8IFwiXCIpICsgKHZhbC5fZGlzYWJsZWQgPT09IHRydWUgfHwgKCQuaXNGdW5jdGlvbih2YWwuX2Rpc2FibGVkKSAmJiB2YWwuX2Rpc2FibGVkKHsgXCJpdGVtXCIgOiB2YWwsIFwicmVmZXJlbmNlXCIgOiB2YWthdGFfY29udGV4dC5yZWZlcmVuY2UsIFwiZWxlbWVudFwiIDogdmFrYXRhX2NvbnRleHQuZWxlbWVudCB9KSkgPyBcIiB2YWthdGEtY29udGV4dG1lbnUtZGlzYWJsZWQgXCIgOiBcIlwiKSArIFwiJyBcIisodmFsLnNob3J0Y3V0P1wiIGRhdGEtc2hvcnRjdXQ9J1wiK3ZhbC5zaG9ydGN1dCtcIicgXCI6JycpK1wiPlwiO1xuXHRcdFx0XHRcdHN0ciArPSBcIjxcIitcImEgaHJlZj0nIycgcmVsPSdcIiArICh2YWthdGFfY29udGV4dC5pdGVtcy5sZW5ndGggLSAxKSArIFwiJyBcIiArICh2YWwudGl0bGUgPyBcInRpdGxlPSdcIiArIHZhbC50aXRsZSArIFwiJ1wiIDogXCJcIikgKyBcIj5cIjtcblx0XHRcdFx0XHRpZigkLnZha2F0YS5jb250ZXh0LnNldHRpbmdzLmljb25zKSB7XG5cdFx0XHRcdFx0XHRzdHIgKz0gXCI8XCIrXCJpIFwiO1xuXHRcdFx0XHRcdFx0aWYodmFsLmljb24pIHtcblx0XHRcdFx0XHRcdFx0aWYodmFsLmljb24uaW5kZXhPZihcIi9cIikgIT09IC0xIHx8IHZhbC5pY29uLmluZGV4T2YoXCIuXCIpICE9PSAtMSkgeyBzdHIgKz0gXCIgc3R5bGU9J2JhY2tncm91bmQ6dXJsKFxcXCJcIiArIHZhbC5pY29uICsgXCJcXFwiKSBjZW50ZXIgY2VudGVyIG5vLXJlcGVhdCcgXCI7IH1cblx0XHRcdFx0XHRcdFx0ZWxzZSB7IHN0ciArPSBcIiBjbGFzcz0nXCIgKyB2YWwuaWNvbiArIFwiJyBcIjsgfVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0c3RyICs9IFwiPjxcIitcIi9pPjxcIitcInNwYW4gY2xhc3M9J3Zha2F0YS1jb250ZXh0bWVudS1zZXAnPiYjMTYwOzxcIitcIi9zcGFuPlwiO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRzdHIgKz0gKCQuaXNGdW5jdGlvbih2YWwubGFiZWwpID8gdmFsLmxhYmVsKHsgXCJpdGVtXCIgOiBpLCBcInJlZmVyZW5jZVwiIDogdmFrYXRhX2NvbnRleHQucmVmZXJlbmNlLCBcImVsZW1lbnRcIiA6IHZha2F0YV9jb250ZXh0LmVsZW1lbnQgfSkgOiB2YWwubGFiZWwpICsgKHZhbC5zaG9ydGN1dD8nIDxzcGFuIGNsYXNzPVwidmFrYXRhLWNvbnRleHRtZW51LXNob3J0Y3V0IHZha2F0YS1jb250ZXh0bWVudS1zaG9ydGN1dC0nK3ZhbC5zaG9ydGN1dCsnXCI+JysgKHZhbC5zaG9ydGN1dF9sYWJlbCB8fCAnJykgKyc8L3NwYW4+JzonJykgKyBcIjxcIitcIi9hPlwiO1xuXHRcdFx0XHRcdGlmKHZhbC5zdWJtZW51KSB7XG5cdFx0XHRcdFx0XHR0bXAgPSAkLnZha2F0YS5jb250ZXh0Ll9wYXJzZSh2YWwuc3VibWVudSwgdHJ1ZSk7XG5cdFx0XHRcdFx0XHRpZih0bXApIHsgc3RyICs9IHRtcDsgfVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRzdHIgKz0gXCI8XCIrXCIvbGk+XCI7XG5cdFx0XHRcdFx0aWYodmFsLnNlcGFyYXRvcl9hZnRlcikge1xuXHRcdFx0XHRcdFx0c3RyICs9IFwiPFwiK1wibGkgY2xhc3M9J3Zha2F0YS1jb250ZXh0LXNlcGFyYXRvcic+PFwiK1wiYSBocmVmPScjJyBcIiArICgkLnZha2F0YS5jb250ZXh0LnNldHRpbmdzLmljb25zID8gJycgOiAnc3R5bGU9XCJtYXJnaW4tbGVmdDowcHg7XCInKSArIFwiPiYjMTYwOzxcIitcIi9hPjxcIitcIi9saT5cIjtcblx0XHRcdFx0XHRcdHNlcCA9IHRydWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KTtcblx0XHRcdFx0c3RyICA9IHN0ci5yZXBsYWNlKC88bGkgY2xhc3NcXD0ndmFrYXRhLWNvbnRleHQtc2VwYXJhdG9yJ1xcPjxcXC9saVxcPiQvLFwiXCIpO1xuXHRcdFx0XHRpZihpc19jYWxsYmFjaykgeyBzdHIgKz0gXCI8L3VsPlwiOyB9XG5cdFx0XHRcdC8qKlxuXHRcdFx0XHQgKiB0cmlnZ2VyZWQgb24gdGhlIGRvY3VtZW50IHdoZW4gdGhlIGNvbnRleHRtZW51IGlzIHBhcnNlZCAoSFRNTCBpcyBidWlsdClcblx0XHRcdFx0ICogQGV2ZW50XG5cdFx0XHRcdCAqIEBwbHVnaW4gY29udGV4dG1lbnVcblx0XHRcdFx0ICogQG5hbWUgY29udGV4dF9wYXJzZS52YWthdGFcblx0XHRcdFx0ICogQHBhcmFtIHtqUXVlcnl9IHJlZmVyZW5jZSB0aGUgZWxlbWVudCB0aGF0IHdhcyByaWdodCBjbGlja2VkXG5cdFx0XHRcdCAqIEBwYXJhbSB7alF1ZXJ5fSBlbGVtZW50IHRoZSBET00gZWxlbWVudCBvZiB0aGUgbWVudSBpdHNlbGZcblx0XHRcdFx0ICogQHBhcmFtIHtPYmplY3R9IHBvc2l0aW9uIHRoZSB4ICYgeSBjb29yZGluYXRlcyBvZiB0aGUgbWVudVxuXHRcdFx0XHQgKi9cblx0XHRcdFx0aWYoIWlzX2NhbGxiYWNrKSB7IHZha2F0YV9jb250ZXh0Lmh0bWwgPSBzdHI7ICQudmFrYXRhLmNvbnRleHQuX3RyaWdnZXIoXCJwYXJzZVwiKTsgfVxuXHRcdFx0XHRyZXR1cm4gc3RyLmxlbmd0aCA+IDEwID8gc3RyIDogZmFsc2U7XG5cdFx0XHR9LFxuXHRcdFx0X3Nob3dfc3VibWVudSA6IGZ1bmN0aW9uIChvKSB7XG5cdFx0XHRcdG8gPSAkKG8pO1xuXHRcdFx0XHRpZighby5sZW5ndGggfHwgIW8uY2hpbGRyZW4oXCJ1bFwiKS5sZW5ndGgpIHsgcmV0dXJuOyB9XG5cdFx0XHRcdHZhciBlID0gby5jaGlsZHJlbihcInVsXCIpLFxuXHRcdFx0XHRcdHhsID0gby5vZmZzZXQoKS5sZWZ0LFxuXHRcdFx0XHRcdHggPSB4bCArIG8ub3V0ZXJXaWR0aCgpLFxuXHRcdFx0XHRcdHkgPSBvLm9mZnNldCgpLnRvcCxcblx0XHRcdFx0XHR3ID0gZS53aWR0aCgpLFxuXHRcdFx0XHRcdGggPSBlLmhlaWdodCgpLFxuXHRcdFx0XHRcdGR3ID0gJCh3aW5kb3cpLndpZHRoKCkgKyAkKHdpbmRvdykuc2Nyb2xsTGVmdCgpLFxuXHRcdFx0XHRcdGRoID0gJCh3aW5kb3cpLmhlaWdodCgpICsgJCh3aW5kb3cpLnNjcm9sbFRvcCgpO1xuXHRcdFx0XHQvLyDQvNC+0LbQtSDQtNCwINGB0LUg0YHQv9C10YHRgtC4INC1INC10LTQvdCwINC/0YDQvtCy0LXRgNC60LAgLSDQtNCw0LvQuCDQvdGP0LzQsCDQvdGP0LrQvtC5INC+0YIg0LrQu9Cw0YHQvtCy0LXRgtC1INCy0LXRh9C1INC90LDQs9C+0YDQtVxuXHRcdFx0XHRpZihyaWdodF90b19sZWZ0KSB7XG5cdFx0XHRcdFx0b1t4IC0gKHcgKyAxMCArIG8ub3V0ZXJXaWR0aCgpKSA8IDAgPyBcImFkZENsYXNzXCIgOiBcInJlbW92ZUNsYXNzXCJdKFwidmFrYXRhLWNvbnRleHQtbGVmdFwiKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRvW3ggKyB3ID4gZHcgICYmIHhsID4gZHcgLSB4ID8gXCJhZGRDbGFzc1wiIDogXCJyZW1vdmVDbGFzc1wiXShcInZha2F0YS1jb250ZXh0LXJpZ2h0XCIpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmKHkgKyBoICsgMTAgPiBkaCkge1xuXHRcdFx0XHRcdGUuY3NzKFwiYm90dG9tXCIsXCItMXB4XCIpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly9pZiBkb2VzIG5vdCBmaXQgLSBzdGljayBpdCB0byB0aGUgc2lkZVxuXHRcdFx0XHRpZiAoby5oYXNDbGFzcygndmFrYXRhLWNvbnRleHQtcmlnaHQnKSkge1xuXHRcdFx0XHRcdGlmICh4bCA8IHcpIHtcblx0XHRcdFx0XHRcdGUuY3NzKFwibWFyZ2luLXJpZ2h0XCIsIHhsIC0gdyk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGlmIChkdyAtIHggPCB3KSB7XG5cdFx0XHRcdFx0XHRlLmNzcyhcIm1hcmdpbi1sZWZ0XCIsIGR3IC0geCAtIHcpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGUuc2hvdygpO1xuXHRcdFx0fSxcblx0XHRcdHNob3cgOiBmdW5jdGlvbiAocmVmZXJlbmNlLCBwb3NpdGlvbiwgZGF0YSkge1xuXHRcdFx0XHR2YXIgbywgZSwgeCwgeSwgdywgaCwgZHcsIGRoLCBjb25kID0gdHJ1ZTtcblx0XHRcdFx0aWYodmFrYXRhX2NvbnRleHQuZWxlbWVudCAmJiB2YWthdGFfY29udGV4dC5lbGVtZW50Lmxlbmd0aCkge1xuXHRcdFx0XHRcdHZha2F0YV9jb250ZXh0LmVsZW1lbnQud2lkdGgoJycpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHN3aXRjaChjb25kKSB7XG5cdFx0XHRcdFx0Y2FzZSAoIXBvc2l0aW9uICYmICFyZWZlcmVuY2UpOlxuXHRcdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHRcdGNhc2UgKCEhcG9zaXRpb24gJiYgISFyZWZlcmVuY2UpOlxuXHRcdFx0XHRcdFx0dmFrYXRhX2NvbnRleHQucmVmZXJlbmNlXHQ9IHJlZmVyZW5jZTtcblx0XHRcdFx0XHRcdHZha2F0YV9jb250ZXh0LnBvc2l0aW9uX3hcdD0gcG9zaXRpb24ueDtcblx0XHRcdFx0XHRcdHZha2F0YV9jb250ZXh0LnBvc2l0aW9uX3lcdD0gcG9zaXRpb24ueTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdGNhc2UgKCFwb3NpdGlvbiAmJiAhIXJlZmVyZW5jZSk6XG5cdFx0XHRcdFx0XHR2YWthdGFfY29udGV4dC5yZWZlcmVuY2VcdD0gcmVmZXJlbmNlO1xuXHRcdFx0XHRcdFx0byA9IHJlZmVyZW5jZS5vZmZzZXQoKTtcblx0XHRcdFx0XHRcdHZha2F0YV9jb250ZXh0LnBvc2l0aW9uX3hcdD0gby5sZWZ0ICsgcmVmZXJlbmNlLm91dGVySGVpZ2h0KCk7XG5cdFx0XHRcdFx0XHR2YWthdGFfY29udGV4dC5wb3NpdGlvbl95XHQ9IG8udG9wO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0Y2FzZSAoISFwb3NpdGlvbiAmJiAhcmVmZXJlbmNlKTpcblx0XHRcdFx0XHRcdHZha2F0YV9jb250ZXh0LnBvc2l0aW9uX3hcdD0gcG9zaXRpb24ueDtcblx0XHRcdFx0XHRcdHZha2F0YV9jb250ZXh0LnBvc2l0aW9uX3lcdD0gcG9zaXRpb24ueTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmKCEhcmVmZXJlbmNlICYmICFkYXRhICYmICQocmVmZXJlbmNlKS5kYXRhKCd2YWthdGFfY29udGV4dG1lbnUnKSkge1xuXHRcdFx0XHRcdGRhdGEgPSAkKHJlZmVyZW5jZSkuZGF0YSgndmFrYXRhX2NvbnRleHRtZW51Jyk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYoJC52YWthdGEuY29udGV4dC5fcGFyc2UoZGF0YSkpIHtcblx0XHRcdFx0XHR2YWthdGFfY29udGV4dC5lbGVtZW50Lmh0bWwodmFrYXRhX2NvbnRleHQuaHRtbCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYodmFrYXRhX2NvbnRleHQuaXRlbXMubGVuZ3RoKSB7XG5cdFx0XHRcdFx0dmFrYXRhX2NvbnRleHQuZWxlbWVudC5hcHBlbmRUbyhcImJvZHlcIik7XG5cdFx0XHRcdFx0ZSA9IHZha2F0YV9jb250ZXh0LmVsZW1lbnQ7XG5cdFx0XHRcdFx0eCA9IHZha2F0YV9jb250ZXh0LnBvc2l0aW9uX3g7XG5cdFx0XHRcdFx0eSA9IHZha2F0YV9jb250ZXh0LnBvc2l0aW9uX3k7XG5cdFx0XHRcdFx0dyA9IGUud2lkdGgoKTtcblx0XHRcdFx0XHRoID0gZS5oZWlnaHQoKTtcblx0XHRcdFx0XHRkdyA9ICQod2luZG93KS53aWR0aCgpICsgJCh3aW5kb3cpLnNjcm9sbExlZnQoKTtcblx0XHRcdFx0XHRkaCA9ICQod2luZG93KS5oZWlnaHQoKSArICQod2luZG93KS5zY3JvbGxUb3AoKTtcblx0XHRcdFx0XHRpZihyaWdodF90b19sZWZ0KSB7XG5cdFx0XHRcdFx0XHR4IC09IChlLm91dGVyV2lkdGgoKSAtICQocmVmZXJlbmNlKS5vdXRlcldpZHRoKCkpO1xuXHRcdFx0XHRcdFx0aWYoeCA8ICQod2luZG93KS5zY3JvbGxMZWZ0KCkgKyAyMCkge1xuXHRcdFx0XHRcdFx0XHR4ID0gJCh3aW5kb3cpLnNjcm9sbExlZnQoKSArIDIwO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZih4ICsgdyArIDIwID4gZHcpIHtcblx0XHRcdFx0XHRcdHggPSBkdyAtICh3ICsgMjApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZih5ICsgaCArIDIwID4gZGgpIHtcblx0XHRcdFx0XHRcdHkgPSBkaCAtIChoICsgMjApO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHZha2F0YV9jb250ZXh0LmVsZW1lbnRcblx0XHRcdFx0XHRcdC5jc3MoeyBcImxlZnRcIiA6IHgsIFwidG9wXCIgOiB5IH0pXG5cdFx0XHRcdFx0XHQuc2hvdygpXG5cdFx0XHRcdFx0XHQuZmluZCgnYScpLmZpcnN0KCkuZm9jdXMoKS5wYXJlbnQoKS5hZGRDbGFzcyhcInZha2F0YS1jb250ZXh0LWhvdmVyXCIpO1xuXHRcdFx0XHRcdHZha2F0YV9jb250ZXh0LmlzX3Zpc2libGUgPSB0cnVlO1xuXHRcdFx0XHRcdC8qKlxuXHRcdFx0XHRcdCAqIHRyaWdnZXJlZCBvbiB0aGUgZG9jdW1lbnQgd2hlbiB0aGUgY29udGV4dG1lbnUgaXMgc2hvd25cblx0XHRcdFx0XHQgKiBAZXZlbnRcblx0XHRcdFx0XHQgKiBAcGx1Z2luIGNvbnRleHRtZW51XG5cdFx0XHRcdFx0ICogQG5hbWUgY29udGV4dF9zaG93LnZha2F0YVxuXHRcdFx0XHRcdCAqIEBwYXJhbSB7alF1ZXJ5fSByZWZlcmVuY2UgdGhlIGVsZW1lbnQgdGhhdCB3YXMgcmlnaHQgY2xpY2tlZFxuXHRcdFx0XHRcdCAqIEBwYXJhbSB7alF1ZXJ5fSBlbGVtZW50IHRoZSBET00gZWxlbWVudCBvZiB0aGUgbWVudSBpdHNlbGZcblx0XHRcdFx0XHQgKiBAcGFyYW0ge09iamVjdH0gcG9zaXRpb24gdGhlIHggJiB5IGNvb3JkaW5hdGVzIG9mIHRoZSBtZW51XG5cdFx0XHRcdFx0ICovXG5cdFx0XHRcdFx0JC52YWthdGEuY29udGV4dC5fdHJpZ2dlcihcInNob3dcIik7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHRoaWRlIDogZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRpZih2YWthdGFfY29udGV4dC5pc192aXNpYmxlKSB7XG5cdFx0XHRcdFx0dmFrYXRhX2NvbnRleHQuZWxlbWVudC5oaWRlKCkuZmluZChcInVsXCIpLmhpZGUoKS5lbmQoKS5maW5kKCc6Zm9jdXMnKS5ibHVyKCkuZW5kKCkuZGV0YWNoKCk7XG5cdFx0XHRcdFx0dmFrYXRhX2NvbnRleHQuaXNfdmlzaWJsZSA9IGZhbHNlO1xuXHRcdFx0XHRcdC8qKlxuXHRcdFx0XHRcdCAqIHRyaWdnZXJlZCBvbiB0aGUgZG9jdW1lbnQgd2hlbiB0aGUgY29udGV4dG1lbnUgaXMgaGlkZGVuXG5cdFx0XHRcdFx0ICogQGV2ZW50XG5cdFx0XHRcdFx0ICogQHBsdWdpbiBjb250ZXh0bWVudVxuXHRcdFx0XHRcdCAqIEBuYW1lIGNvbnRleHRfaGlkZS52YWthdGFcblx0XHRcdFx0XHQgKiBAcGFyYW0ge2pRdWVyeX0gcmVmZXJlbmNlIHRoZSBlbGVtZW50IHRoYXQgd2FzIHJpZ2h0IGNsaWNrZWRcblx0XHRcdFx0XHQgKiBAcGFyYW0ge2pRdWVyeX0gZWxlbWVudCB0aGUgRE9NIGVsZW1lbnQgb2YgdGhlIG1lbnUgaXRzZWxmXG5cdFx0XHRcdFx0ICogQHBhcmFtIHtPYmplY3R9IHBvc2l0aW9uIHRoZSB4ICYgeSBjb29yZGluYXRlcyBvZiB0aGUgbWVudVxuXHRcdFx0XHRcdCAqL1xuXHRcdFx0XHRcdCQudmFrYXRhLmNvbnRleHQuX3RyaWdnZXIoXCJoaWRlXCIpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fTtcblx0XHQkKGZ1bmN0aW9uICgpIHtcblx0XHRcdHJpZ2h0X3RvX2xlZnQgPSAkKFwiYm9keVwiKS5jc3MoXCJkaXJlY3Rpb25cIikgPT09IFwicnRsXCI7XG5cdFx0XHR2YXIgdG8gPSBmYWxzZTtcblxuXHRcdFx0dmFrYXRhX2NvbnRleHQuZWxlbWVudCA9ICQoXCI8dWwgY2xhc3M9J3Zha2F0YS1jb250ZXh0Jz48L3VsPlwiKTtcblx0XHRcdHZha2F0YV9jb250ZXh0LmVsZW1lbnRcblx0XHRcdFx0Lm9uKFwibW91c2VlbnRlclwiLCBcImxpXCIsIGZ1bmN0aW9uIChlKSB7XG5cdFx0XHRcdFx0ZS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcblxuXHRcdFx0XHRcdGlmKCQuY29udGFpbnModGhpcywgZS5yZWxhdGVkVGFyZ2V0KSkge1xuXHRcdFx0XHRcdFx0Ly8g0L/RgNC10LzQsNGF0L3QsNGC0L4g0LfQsNGA0LDQtNC4IGRlbGVnYXRlIG1vdXNlbGVhdmUg0L/Qvi3QtNC+0LvRg1xuXHRcdFx0XHRcdFx0Ly8gJCh0aGlzKS5maW5kKFwiLnZha2F0YS1jb250ZXh0LWhvdmVyXCIpLnJlbW92ZUNsYXNzKFwidmFrYXRhLWNvbnRleHQtaG92ZXJcIik7XG5cdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0aWYodG8pIHsgY2xlYXJUaW1lb3V0KHRvKTsgfVxuXHRcdFx0XHRcdHZha2F0YV9jb250ZXh0LmVsZW1lbnQuZmluZChcIi52YWthdGEtY29udGV4dC1ob3ZlclwiKS5yZW1vdmVDbGFzcyhcInZha2F0YS1jb250ZXh0LWhvdmVyXCIpLmVuZCgpO1xuXG5cdFx0XHRcdFx0JCh0aGlzKVxuXHRcdFx0XHRcdFx0LnNpYmxpbmdzKCkuZmluZChcInVsXCIpLmhpZGUoKS5lbmQoKS5lbmQoKVxuXHRcdFx0XHRcdFx0LnBhcmVudHNVbnRpbChcIi52YWthdGEtY29udGV4dFwiLCBcImxpXCIpLmFkZEJhY2soKS5hZGRDbGFzcyhcInZha2F0YS1jb250ZXh0LWhvdmVyXCIpO1xuXHRcdFx0XHRcdCQudmFrYXRhLmNvbnRleHQuX3Nob3dfc3VibWVudSh0aGlzKTtcblx0XHRcdFx0fSlcblx0XHRcdFx0Ly8g0YLQtdGB0YLQvtCy0L4gLSDQtNCw0LvQuCDQvdC1INC90LDRgtC+0LLQsNGA0LLQsD9cblx0XHRcdFx0Lm9uKFwibW91c2VsZWF2ZVwiLCBcImxpXCIsIGZ1bmN0aW9uIChlKSB7XG5cdFx0XHRcdFx0aWYoJC5jb250YWlucyh0aGlzLCBlLnJlbGF0ZWRUYXJnZXQpKSB7IHJldHVybjsgfVxuXHRcdFx0XHRcdCQodGhpcykuZmluZChcIi52YWthdGEtY29udGV4dC1ob3ZlclwiKS5hZGRCYWNrKCkucmVtb3ZlQ2xhc3MoXCJ2YWthdGEtY29udGV4dC1ob3ZlclwiKTtcblx0XHRcdFx0fSlcblx0XHRcdFx0Lm9uKFwibW91c2VsZWF2ZVwiLCBmdW5jdGlvbiAoZSkge1xuXHRcdFx0XHRcdCQodGhpcykuZmluZChcIi52YWthdGEtY29udGV4dC1ob3ZlclwiKS5yZW1vdmVDbGFzcyhcInZha2F0YS1jb250ZXh0LWhvdmVyXCIpO1xuXHRcdFx0XHRcdGlmKCQudmFrYXRhLmNvbnRleHQuc2V0dGluZ3MuaGlkZV9vbm1vdXNlbGVhdmUpIHtcblx0XHRcdFx0XHRcdHRvID0gc2V0VGltZW91dChcblx0XHRcdFx0XHRcdFx0KGZ1bmN0aW9uICh0KSB7XG5cdFx0XHRcdFx0XHRcdFx0cmV0dXJuIGZ1bmN0aW9uICgpIHsgJC52YWthdGEuY29udGV4dC5oaWRlKCk7IH07XG5cdFx0XHRcdFx0XHRcdH0odGhpcykpLCAkLnZha2F0YS5jb250ZXh0LnNldHRpbmdzLmhpZGVfb25tb3VzZWxlYXZlKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pXG5cdFx0XHRcdC5vbihcImNsaWNrXCIsIFwiYVwiLCBmdW5jdGlvbiAoZSkge1xuXHRcdFx0XHRcdGUucHJldmVudERlZmF1bHQoKTtcblx0XHRcdFx0Ly99KVxuXHRcdFx0XHQvLy5vbihcIm1vdXNldXBcIiwgXCJhXCIsIGZ1bmN0aW9uIChlKSB7XG5cdFx0XHRcdFx0aWYoISQodGhpcykuYmx1cigpLnBhcmVudCgpLmhhc0NsYXNzKFwidmFrYXRhLWNvbnRleHQtZGlzYWJsZWRcIikgJiYgJC52YWthdGEuY29udGV4dC5fZXhlY3V0ZSgkKHRoaXMpLmF0dHIoXCJyZWxcIikpICE9PSBmYWxzZSkge1xuXHRcdFx0XHRcdFx0JC52YWthdGEuY29udGV4dC5oaWRlKCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KVxuXHRcdFx0XHQub24oJ2tleWRvd24nLCAnYScsIGZ1bmN0aW9uIChlKSB7XG5cdFx0XHRcdFx0XHR2YXIgbyA9IG51bGw7XG5cdFx0XHRcdFx0XHRzd2l0Y2goZS53aGljaCkge1xuXHRcdFx0XHRcdFx0XHRjYXNlIDEzOlxuXHRcdFx0XHRcdFx0XHRjYXNlIDMyOlxuXHRcdFx0XHRcdFx0XHRcdGUudHlwZSA9IFwiY2xpY2tcIjtcblx0XHRcdFx0XHRcdFx0XHRlLnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHRcdFx0XHRcdFx0JChlLmN1cnJlbnRUYXJnZXQpLnRyaWdnZXIoZSk7XG5cdFx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRcdGNhc2UgMzc6XG5cdFx0XHRcdFx0XHRcdFx0aWYodmFrYXRhX2NvbnRleHQuaXNfdmlzaWJsZSkge1xuXHRcdFx0XHRcdFx0XHRcdFx0dmFrYXRhX2NvbnRleHQuZWxlbWVudC5maW5kKFwiLnZha2F0YS1jb250ZXh0LWhvdmVyXCIpLmxhc3QoKS5jbG9zZXN0KFwibGlcIikuZmlyc3QoKS5maW5kKFwidWxcIikuaGlkZSgpLmZpbmQoXCIudmFrYXRhLWNvbnRleHQtaG92ZXJcIikucmVtb3ZlQ2xhc3MoXCJ2YWthdGEtY29udGV4dC1ob3ZlclwiKS5lbmQoKS5lbmQoKS5jaGlsZHJlbignYScpLmZvY3VzKCk7XG5cdFx0XHRcdFx0XHRcdFx0XHRlLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xuXHRcdFx0XHRcdFx0XHRcdFx0ZS5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdFx0Y2FzZSAzODpcblx0XHRcdFx0XHRcdFx0XHRpZih2YWthdGFfY29udGV4dC5pc192aXNpYmxlKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRvID0gdmFrYXRhX2NvbnRleHQuZWxlbWVudC5maW5kKFwidWw6dmlzaWJsZVwiKS5hZGRCYWNrKCkubGFzdCgpLmNoaWxkcmVuKFwiLnZha2F0YS1jb250ZXh0LWhvdmVyXCIpLnJlbW92ZUNsYXNzKFwidmFrYXRhLWNvbnRleHQtaG92ZXJcIikucHJldkFsbChcImxpOm5vdCgudmFrYXRhLWNvbnRleHQtc2VwYXJhdG9yKVwiKS5maXJzdCgpO1xuXHRcdFx0XHRcdFx0XHRcdFx0aWYoIW8ubGVuZ3RoKSB7IG8gPSB2YWthdGFfY29udGV4dC5lbGVtZW50LmZpbmQoXCJ1bDp2aXNpYmxlXCIpLmFkZEJhY2soKS5sYXN0KCkuY2hpbGRyZW4oXCJsaTpub3QoLnZha2F0YS1jb250ZXh0LXNlcGFyYXRvcilcIikubGFzdCgpOyB9XG5cdFx0XHRcdFx0XHRcdFx0XHRvLmFkZENsYXNzKFwidmFrYXRhLWNvbnRleHQtaG92ZXJcIikuY2hpbGRyZW4oJ2EnKS5mb2N1cygpO1xuXHRcdFx0XHRcdFx0XHRcdFx0ZS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcblx0XHRcdFx0XHRcdFx0XHRcdGUucHJldmVudERlZmF1bHQoKTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRcdGNhc2UgMzk6XG5cdFx0XHRcdFx0XHRcdFx0aWYodmFrYXRhX2NvbnRleHQuaXNfdmlzaWJsZSkge1xuXHRcdFx0XHRcdFx0XHRcdFx0dmFrYXRhX2NvbnRleHQuZWxlbWVudC5maW5kKFwiLnZha2F0YS1jb250ZXh0LWhvdmVyXCIpLmxhc3QoKS5jaGlsZHJlbihcInVsXCIpLnNob3coKS5jaGlsZHJlbihcImxpOm5vdCgudmFrYXRhLWNvbnRleHQtc2VwYXJhdG9yKVwiKS5yZW1vdmVDbGFzcyhcInZha2F0YS1jb250ZXh0LWhvdmVyXCIpLmZpcnN0KCkuYWRkQ2xhc3MoXCJ2YWthdGEtY29udGV4dC1ob3ZlclwiKS5jaGlsZHJlbignYScpLmZvY3VzKCk7XG5cdFx0XHRcdFx0XHRcdFx0XHRlLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xuXHRcdFx0XHRcdFx0XHRcdFx0ZS5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdFx0Y2FzZSA0MDpcblx0XHRcdFx0XHRcdFx0XHRpZih2YWthdGFfY29udGV4dC5pc192aXNpYmxlKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRvID0gdmFrYXRhX2NvbnRleHQuZWxlbWVudC5maW5kKFwidWw6dmlzaWJsZVwiKS5hZGRCYWNrKCkubGFzdCgpLmNoaWxkcmVuKFwiLnZha2F0YS1jb250ZXh0LWhvdmVyXCIpLnJlbW92ZUNsYXNzKFwidmFrYXRhLWNvbnRleHQtaG92ZXJcIikubmV4dEFsbChcImxpOm5vdCgudmFrYXRhLWNvbnRleHQtc2VwYXJhdG9yKVwiKS5maXJzdCgpO1xuXHRcdFx0XHRcdFx0XHRcdFx0aWYoIW8ubGVuZ3RoKSB7IG8gPSB2YWthdGFfY29udGV4dC5lbGVtZW50LmZpbmQoXCJ1bDp2aXNpYmxlXCIpLmFkZEJhY2soKS5sYXN0KCkuY2hpbGRyZW4oXCJsaTpub3QoLnZha2F0YS1jb250ZXh0LXNlcGFyYXRvcilcIikuZmlyc3QoKTsgfVxuXHRcdFx0XHRcdFx0XHRcdFx0by5hZGRDbGFzcyhcInZha2F0YS1jb250ZXh0LWhvdmVyXCIpLmNoaWxkcmVuKCdhJykuZm9jdXMoKTtcblx0XHRcdFx0XHRcdFx0XHRcdGUuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG5cdFx0XHRcdFx0XHRcdFx0XHRlLnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0XHRjYXNlIDI3OlxuXHRcdFx0XHRcdFx0XHRcdCQudmFrYXRhLmNvbnRleHQuaGlkZSgpO1xuXHRcdFx0XHRcdFx0XHRcdGUucHJldmVudERlZmF1bHQoKTtcblx0XHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0XHRcdFx0XHQvL2NvbnNvbGUubG9nKGUud2hpY2gpO1xuXHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0pXG5cdFx0XHRcdC5vbigna2V5ZG93bicsIGZ1bmN0aW9uIChlKSB7XG5cdFx0XHRcdFx0ZS5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0XHRcdHZhciBhID0gdmFrYXRhX2NvbnRleHQuZWxlbWVudC5maW5kKCcudmFrYXRhLWNvbnRleHRtZW51LXNob3J0Y3V0LScgKyBlLndoaWNoKS5wYXJlbnQoKTtcblx0XHRcdFx0XHRpZihhLnBhcmVudCgpLm5vdCgnLnZha2F0YS1jb250ZXh0LWRpc2FibGVkJykpIHtcblx0XHRcdFx0XHRcdGEuY2xpY2soKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pO1xuXG5cdFx0XHQkKGRvY3VtZW50KVxuXHRcdFx0XHQub24oXCJtb3VzZWRvd24udmFrYXRhLmpzdHJlZVwiLCBmdW5jdGlvbiAoZSkge1xuXHRcdFx0XHRcdGlmKHZha2F0YV9jb250ZXh0LmlzX3Zpc2libGUgJiYgISQuY29udGFpbnModmFrYXRhX2NvbnRleHQuZWxlbWVudFswXSwgZS50YXJnZXQpKSB7XG5cdFx0XHRcdFx0XHQkLnZha2F0YS5jb250ZXh0LmhpZGUoKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pXG5cdFx0XHRcdC5vbihcImNvbnRleHRfc2hvdy52YWthdGEuanN0cmVlXCIsIGZ1bmN0aW9uIChlLCBkYXRhKSB7XG5cdFx0XHRcdFx0dmFrYXRhX2NvbnRleHQuZWxlbWVudC5maW5kKFwibGk6aGFzKHVsKVwiKS5jaGlsZHJlbihcImFcIikuYWRkQ2xhc3MoXCJ2YWthdGEtY29udGV4dC1wYXJlbnRcIik7XG5cdFx0XHRcdFx0aWYocmlnaHRfdG9fbGVmdCkge1xuXHRcdFx0XHRcdFx0dmFrYXRhX2NvbnRleHQuZWxlbWVudC5hZGRDbGFzcyhcInZha2F0YS1jb250ZXh0LXJ0bFwiKS5jc3MoXCJkaXJlY3Rpb25cIiwgXCJydGxcIik7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdC8vIGFsc28gYXBwbHkgYSBSVEwgY2xhc3M/XG5cdFx0XHRcdFx0dmFrYXRhX2NvbnRleHQuZWxlbWVudC5maW5kKFwidWxcIikuaGlkZSgpLmVuZCgpO1xuXHRcdFx0XHR9KTtcblx0XHR9KTtcblx0fSgkKSk7XG5cdC8vICQuanN0cmVlLmRlZmF1bHRzLnBsdWdpbnMucHVzaChcImNvbnRleHRtZW51XCIpO1xuXG5cbi8qKlxuICogIyMjIERyYWcnbidkcm9wIHBsdWdpblxuICpcbiAqIEVuYWJsZXMgZHJhZ2dpbmcgYW5kIGRyb3BwaW5nIG9mIG5vZGVzIGluIHRoZSB0cmVlLCByZXN1bHRpbmcgaW4gYSBtb3ZlIG9yIGNvcHkgb3BlcmF0aW9ucy5cbiAqL1xuXG5cdC8qKlxuXHQgKiBzdG9yZXMgYWxsIGRlZmF1bHRzIGZvciB0aGUgZHJhZyduJ2Ryb3AgcGx1Z2luXG5cdCAqIEBuYW1lICQuanN0cmVlLmRlZmF1bHRzLmRuZFxuXHQgKiBAcGx1Z2luIGRuZFxuXHQgKi9cblx0JC5qc3RyZWUuZGVmYXVsdHMuZG5kID0ge1xuXHRcdC8qKlxuXHRcdCAqIGEgYm9vbGVhbiBpbmRpY2F0aW5nIGlmIGEgY29weSBzaG91bGQgYmUgcG9zc2libGUgd2hpbGUgZHJhZ2dpbmcgKGJ5IHByZXNzaW50IHRoZSBtZXRhIGtleSBvciBDdHJsKS4gRGVmYXVsdHMgdG8gYHRydWVgLlxuXHRcdCAqIEBuYW1lICQuanN0cmVlLmRlZmF1bHRzLmRuZC5jb3B5XG5cdFx0ICogQHBsdWdpbiBkbmRcblx0XHQgKi9cblx0XHRjb3B5IDogdHJ1ZSxcblx0XHQvKipcblx0XHQgKiBhIG51bWJlciBpbmRpY2F0aW5nIGhvdyBsb25nIGEgbm9kZSBzaG91bGQgcmVtYWluIGhvdmVyZWQgd2hpbGUgZHJhZ2dpbmcgdG8gYmUgb3BlbmVkLiBEZWZhdWx0cyB0byBgNTAwYC5cblx0XHQgKiBAbmFtZSAkLmpzdHJlZS5kZWZhdWx0cy5kbmQub3Blbl90aW1lb3V0XG5cdFx0ICogQHBsdWdpbiBkbmRcblx0XHQgKi9cblx0XHRvcGVuX3RpbWVvdXQgOiA1MDAsXG5cdFx0LyoqXG5cdFx0ICogYSBmdW5jdGlvbiBpbnZva2VkIGVhY2ggdGltZSBhIG5vZGUgaXMgYWJvdXQgdG8gYmUgZHJhZ2dlZCwgaW52b2tlZCBpbiB0aGUgdHJlZSdzIHNjb3BlIGFuZCByZWNlaXZlcyB0aGUgbm9kZXMgYWJvdXQgdG8gYmUgZHJhZ2dlZCBhcyBhbiBhcmd1bWVudCAoYXJyYXkpIGFuZCB0aGUgZXZlbnQgdGhhdCBzdGFydGVkIHRoZSBkcmFnIC0gcmV0dXJuIGBmYWxzZWAgdG8gcHJldmVudCBkcmFnZ2luZ1xuXHRcdCAqIEBuYW1lICQuanN0cmVlLmRlZmF1bHRzLmRuZC5pc19kcmFnZ2FibGVcblx0XHQgKiBAcGx1Z2luIGRuZFxuXHRcdCAqL1xuXHRcdGlzX2RyYWdnYWJsZSA6IHRydWUsXG5cdFx0LyoqXG5cdFx0ICogYSBib29sZWFuIGluZGljYXRpbmcgaWYgY2hlY2tzIHNob3VsZCBjb25zdGFudGx5IGJlIG1hZGUgd2hpbGUgdGhlIHVzZXIgaXMgZHJhZ2dpbmcgdGhlIG5vZGUgKGFzIG9wcG9zZWQgdG8gY2hlY2tpbmcgb25seSBvbiBkcm9wKSwgZGVmYXVsdCBpcyBgdHJ1ZWBcblx0XHQgKiBAbmFtZSAkLmpzdHJlZS5kZWZhdWx0cy5kbmQuY2hlY2tfd2hpbGVfZHJhZ2dpbmdcblx0XHQgKiBAcGx1Z2luIGRuZFxuXHRcdCAqL1xuXHRcdGNoZWNrX3doaWxlX2RyYWdnaW5nIDogdHJ1ZSxcblx0XHQvKipcblx0XHQgKiBhIGJvb2xlYW4gaW5kaWNhdGluZyBpZiBub2RlcyBmcm9tIHRoaXMgdHJlZSBzaG91bGQgb25seSBiZSBjb3BpZWQgd2l0aCBkbmQgKGFzIG9wcG9zZWQgdG8gbW92ZWQpLCBkZWZhdWx0IGlzIGBmYWxzZWBcblx0XHQgKiBAbmFtZSAkLmpzdHJlZS5kZWZhdWx0cy5kbmQuYWx3YXlzX2NvcHlcblx0XHQgKiBAcGx1Z2luIGRuZFxuXHRcdCAqL1xuXHRcdGFsd2F5c19jb3B5IDogZmFsc2UsXG5cdFx0LyoqXG5cdFx0ICogd2hlbiBkcm9wcGluZyBhIG5vZGUgXCJpbnNpZGVcIiwgdGhpcyBzZXR0aW5nIGluZGljYXRlcyB0aGUgcG9zaXRpb24gdGhlIG5vZGUgc2hvdWxkIGdvIHRvIC0gaXQgY2FuIGJlIGFuIGludGVnZXIgb3IgYSBzdHJpbmc6IFwiZmlyc3RcIiAoc2FtZSBhcyAwKSBvciBcImxhc3RcIiwgZGVmYXVsdCBpcyBgMGBcblx0XHQgKiBAbmFtZSAkLmpzdHJlZS5kZWZhdWx0cy5kbmQuaW5zaWRlX3Bvc1xuXHRcdCAqIEBwbHVnaW4gZG5kXG5cdFx0ICovXG5cdFx0aW5zaWRlX3BvcyA6IDAsXG5cdFx0LyoqXG5cdFx0ICogd2hlbiBzdGFydGluZyB0aGUgZHJhZyBvbiBhIG5vZGUgdGhhdCBpcyBzZWxlY3RlZCB0aGlzIHNldHRpbmcgY29udHJvbHMgaWYgYWxsIHNlbGVjdGVkIG5vZGVzIGFyZSBkcmFnZ2VkIG9yIG9ubHkgdGhlIHNpbmdsZSBub2RlLCBkZWZhdWx0IGlzIGB0cnVlYCwgd2hpY2ggbWVhbnMgYWxsIHNlbGVjdGVkIG5vZGVzIGFyZSBkcmFnZ2VkIHdoZW4gdGhlIGRyYWcgaXMgc3RhcnRlZCBvbiBhIHNlbGVjdGVkIG5vZGVcblx0XHQgKiBAbmFtZSAkLmpzdHJlZS5kZWZhdWx0cy5kbmQuZHJhZ19zZWxlY3Rpb25cblx0XHQgKiBAcGx1Z2luIGRuZFxuXHRcdCAqL1xuXHRcdGRyYWdfc2VsZWN0aW9uIDogdHJ1ZSxcblx0XHQvKipcblx0XHQgKiBjb250cm9scyB3aGV0aGVyIGRuZCB3b3JrcyBvbiB0b3VjaCBkZXZpY2VzLiBJZiBsZWZ0IGFzIGJvb2xlYW4gdHJ1ZSBkbmQgd2lsbCB3b3JrIHRoZSBzYW1lIGFzIGluIGRlc2t0b3AgYnJvd3NlcnMsIHdoaWNoIGluIHNvbWUgY2FzZXMgbWF5IGltcGFpciBzY3JvbGxpbmcuIElmIHNldCB0byBib29sZWFuIGZhbHNlIGRuZCB3aWxsIG5vdCB3b3JrIG9uIHRvdWNoIGRldmljZXMuIFRoZXJlIGlzIGEgc3BlY2lhbCB0aGlyZCBvcHRpb24gLSBzdHJpbmcgXCJzZWxlY3RlZFwiIHdoaWNoIG1lYW5zIG9ubHkgc2VsZWN0ZWQgbm9kZXMgY2FuIGJlIGRyYWdnZWQgb24gdG91Y2ggZGV2aWNlcy5cblx0XHQgKiBAbmFtZSAkLmpzdHJlZS5kZWZhdWx0cy5kbmQudG91Y2hcblx0XHQgKiBAcGx1Z2luIGRuZFxuXHRcdCAqL1xuXHRcdHRvdWNoIDogdHJ1ZSxcblx0XHQvKipcblx0XHQgKiBjb250cm9scyB3aGV0aGVyIGl0ZW1zIGNhbiBiZSBkcm9wcGVkIGFueXdoZXJlIG9uIHRoZSBub2RlLCBub3QganVzdCBvbiB0aGUgYW5jaG9yLCBieSBkZWZhdWx0IG9ubHkgdGhlIG5vZGUgYW5jaG9yIGlzIGEgdmFsaWQgZHJvcCB0YXJnZXQuIFdvcmtzIGJlc3Qgd2l0aCB0aGUgd2hvbGVyb3cgcGx1Z2luLiBJZiBlbmFibGVkIG9uIG1vYmlsZSBkZXBlbmRpbmcgb24gdGhlIGludGVyZmFjZSBpdCBtaWdodCBiZSBoYXJkIGZvciB0aGUgdXNlciB0byBjYW5jZWwgdGhlIGRyb3AsIHNpbmNlIHRoZSB3aG9sZSB0cmVlIGNvbnRhaW5lciB3aWxsIGJlIGEgdmFsaWQgZHJvcCB0YXJnZXQuXG5cdFx0ICogQG5hbWUgJC5qc3RyZWUuZGVmYXVsdHMuZG5kLmxhcmdlX2Ryb3BfdGFyZ2V0XG5cdFx0ICogQHBsdWdpbiBkbmRcblx0XHQgKi9cblx0XHRsYXJnZV9kcm9wX3RhcmdldCA6IGZhbHNlLFxuXHRcdC8qKlxuXHRcdCAqIGNvbnRyb2xzIHdoZXRoZXIgYSBkcmFnIGNhbiBiZSBpbml0aWF0ZWQgZnJvbSBhbnkgcGFydCBvZiB0aGUgbm9kZSBhbmQgbm90IGp1c3QgdGhlIHRleHQvaWNvbiBwYXJ0LCB3b3JrcyBiZXN0IHdpdGggdGhlIHdob2xlcm93IHBsdWdpbi4gS2VlcCBpbiBtaW5kIGl0IGNhbiBjYXVzZSBwcm9ibGVtcyB3aXRoIHRyZWUgc2Nyb2xsaW5nIG9uIG1vYmlsZSBkZXBlbmRpbmcgb24gdGhlIGludGVyZmFjZSAtIGluIHRoYXQgY2FzZSBzZXQgdGhlIHRvdWNoIG9wdGlvbiB0byBcInNlbGVjdGVkXCIuXG5cdFx0ICogQG5hbWUgJC5qc3RyZWUuZGVmYXVsdHMuZG5kLmxhcmdlX2RyYWdfdGFyZ2V0XG5cdFx0ICogQHBsdWdpbiBkbmRcblx0XHQgKi9cblx0XHRsYXJnZV9kcmFnX3RhcmdldCA6IGZhbHNlLFxuXHRcdC8qKlxuXHRcdCAqIGNvbnRyb2xzIHdoZXRoZXIgdXNlIEhUTUw1IGRuZCBhcGkgaW5zdGVhZCBvZiBjbGFzc2ljYWwuIFRoYXQgd2lsbCBhbGxvdyBiZXR0ZXIgaW50ZWdyYXRpb24gb2YgZG5kIGV2ZW50cyB3aXRoIG90aGVyIEhUTUw1IGNvbnRyb2xzLlxuXHRcdCAqIEByZWZlcmVuY2UgaHR0cDovL2Nhbml1c2UuY29tLyNmZWF0PWRyYWduZHJvcFxuXHRcdCAqIEBuYW1lICQuanN0cmVlLmRlZmF1bHRzLmRuZC51c2VfaHRtbDVcblx0XHQgKiBAcGx1Z2luIGRuZFxuXHRcdCAqL1xuXHRcdHVzZV9odG1sNTogZmFsc2Vcblx0fTtcblx0dmFyIGRyZywgZWxtO1xuXHQvLyBUT0RPOiBub3cgY2hlY2sgd29ya3MgYnkgY2hlY2tpbmcgZm9yIGVhY2ggbm9kZSBpbmRpdmlkdWFsbHksIGhvdyBhYm91dCBtYXhfY2hpbGRyZW4sIHVuaXF1ZSwgZXRjP1xuXHQkLmpzdHJlZS5wbHVnaW5zLmRuZCA9IGZ1bmN0aW9uIChvcHRpb25zLCBwYXJlbnQpIHtcblx0XHR0aGlzLmluaXQgPSBmdW5jdGlvbiAoZWwsIG9wdGlvbnMpIHtcblx0XHRcdHBhcmVudC5pbml0LmNhbGwodGhpcywgZWwsIG9wdGlvbnMpO1xuXHRcdFx0dGhpcy5zZXR0aW5ncy5kbmQudXNlX2h0bWw1ID0gdGhpcy5zZXR0aW5ncy5kbmQudXNlX2h0bWw1ICYmICgnZHJhZ2dhYmxlJyBpbiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzcGFuJykpO1xuXHRcdH07XG5cdFx0dGhpcy5iaW5kID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0cGFyZW50LmJpbmQuY2FsbCh0aGlzKTtcblxuXHRcdFx0dGhpcy5lbGVtZW50XG5cdFx0XHRcdC5vbih0aGlzLnNldHRpbmdzLmRuZC51c2VfaHRtbDUgPyAnZHJhZ3N0YXJ0LmpzdHJlZScgOiAnbW91c2Vkb3duLmpzdHJlZSB0b3VjaHN0YXJ0LmpzdHJlZScsIHRoaXMuc2V0dGluZ3MuZG5kLmxhcmdlX2RyYWdfdGFyZ2V0ID8gJy5qc3RyZWUtbm9kZScgOiAnLmpzdHJlZS1hbmNob3InLCAkLnByb3h5KGZ1bmN0aW9uIChlKSB7XG5cdFx0XHRcdFx0XHRpZih0aGlzLnNldHRpbmdzLmRuZC5sYXJnZV9kcmFnX3RhcmdldCAmJiAkKGUudGFyZ2V0KS5jbG9zZXN0KCcuanN0cmVlLW5vZGUnKVswXSAhPT0gZS5jdXJyZW50VGFyZ2V0KSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0aWYoZS50eXBlID09PSBcInRvdWNoc3RhcnRcIiAmJiAoIXRoaXMuc2V0dGluZ3MuZG5kLnRvdWNoIHx8ICh0aGlzLnNldHRpbmdzLmRuZC50b3VjaCA9PT0gJ3NlbGVjdGVkJyAmJiAhJChlLmN1cnJlbnRUYXJnZXQpLmNsb3Nlc3QoJy5qc3RyZWUtbm9kZScpLmNoaWxkcmVuKCcuanN0cmVlLWFuY2hvcicpLmhhc0NsYXNzKCdqc3RyZWUtY2xpY2tlZCcpKSkpIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR2YXIgb2JqID0gdGhpcy5nZXRfbm9kZShlLnRhcmdldCksXG5cdFx0XHRcdFx0XHRcdG1sdCA9IHRoaXMuaXNfc2VsZWN0ZWQob2JqKSAmJiB0aGlzLnNldHRpbmdzLmRuZC5kcmFnX3NlbGVjdGlvbiA/IHRoaXMuZ2V0X3RvcF9zZWxlY3RlZCgpLmxlbmd0aCA6IDEsXG5cdFx0XHRcdFx0XHRcdHR4dCA9IChtbHQgPiAxID8gbWx0ICsgJyAnICsgdGhpcy5nZXRfc3RyaW5nKCdub2RlcycpIDogdGhpcy5nZXRfdGV4dChlLmN1cnJlbnRUYXJnZXQpKTtcblx0XHRcdFx0XHRcdGlmKHRoaXMuc2V0dGluZ3MuY29yZS5mb3JjZV90ZXh0KSB7XG5cdFx0XHRcdFx0XHRcdHR4dCA9ICQudmFrYXRhLmh0bWwuZXNjYXBlKHR4dCk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRpZihvYmogJiYgb2JqLmlkICYmIG9iai5pZCAhPT0gJC5qc3RyZWUucm9vdCAmJiAoZS53aGljaCA9PT0gMSB8fCBlLnR5cGUgPT09IFwidG91Y2hzdGFydFwiIHx8IGUudHlwZSA9PT0gXCJkcmFnc3RhcnRcIikgJiZcblx0XHRcdFx0XHRcdFx0KHRoaXMuc2V0dGluZ3MuZG5kLmlzX2RyYWdnYWJsZSA9PT0gdHJ1ZSB8fCAoJC5pc0Z1bmN0aW9uKHRoaXMuc2V0dGluZ3MuZG5kLmlzX2RyYWdnYWJsZSkgJiYgdGhpcy5zZXR0aW5ncy5kbmQuaXNfZHJhZ2dhYmxlLmNhbGwodGhpcywgKG1sdCA+IDEgPyB0aGlzLmdldF90b3Bfc2VsZWN0ZWQodHJ1ZSkgOiBbb2JqXSksIGUpKSlcblx0XHRcdFx0XHRcdCkge1xuXHRcdFx0XHRcdFx0XHRkcmcgPSB7ICdqc3RyZWUnIDogdHJ1ZSwgJ29yaWdpbicgOiB0aGlzLCAnb2JqJyA6IHRoaXMuZ2V0X25vZGUob2JqLHRydWUpLCAnbm9kZXMnIDogbWx0ID4gMSA/IHRoaXMuZ2V0X3RvcF9zZWxlY3RlZCgpIDogW29iai5pZF0gfTtcblx0XHRcdFx0XHRcdFx0ZWxtID0gZS5jdXJyZW50VGFyZ2V0O1xuXHRcdFx0XHRcdFx0XHRpZiAodGhpcy5zZXR0aW5ncy5kbmQudXNlX2h0bWw1KSB7XG5cdFx0XHRcdFx0XHRcdFx0JC52YWthdGEuZG5kLl90cmlnZ2VyKCdzdGFydCcsIGUsIHsgJ2hlbHBlcic6ICQoKSwgJ2VsZW1lbnQnOiBlbG0sICdkYXRhJzogZHJnIH0pO1xuXHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdHRoaXMuZWxlbWVudC50cmlnZ2VyKCdtb3VzZWRvd24uanN0cmVlJyk7XG5cdFx0XHRcdFx0XHRcdFx0cmV0dXJuICQudmFrYXRhLmRuZC5zdGFydChlLCBkcmcsICc8ZGl2IGlkPVwianN0cmVlLWRuZFwiIGNsYXNzPVwianN0cmVlLScgKyB0aGlzLmdldF90aGVtZSgpICsgJyBqc3RyZWUtJyArIHRoaXMuZ2V0X3RoZW1lKCkgKyAnLScgKyB0aGlzLmdldF90aGVtZV92YXJpYW50KCkgKyAnICcgKyAoIHRoaXMuc2V0dGluZ3MuY29yZS50aGVtZXMucmVzcG9uc2l2ZSA/ICcganN0cmVlLWRuZC1yZXNwb25zaXZlJyA6ICcnICkgKyAnXCI+PGkgY2xhc3M9XCJqc3RyZWUtaWNvbiBqc3RyZWUtZXJcIj48L2k+JyArIHR4dCArICc8aW5zIGNsYXNzPVwianN0cmVlLWNvcHlcIiBzdHlsZT1cImRpc3BsYXk6bm9uZTtcIj4rPC9pbnM+PC9kaXY+Jyk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9LCB0aGlzKSk7XG5cdFx0XHRpZiAodGhpcy5zZXR0aW5ncy5kbmQudXNlX2h0bWw1KSB7XG5cdFx0XHRcdHRoaXMuZWxlbWVudFxuXHRcdFx0XHRcdC5vbignZHJhZ292ZXIuanN0cmVlJywgZnVuY3Rpb24gKGUpIHtcblx0XHRcdFx0XHRcdFx0ZS5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0XHRcdFx0XHQkLnZha2F0YS5kbmQuX3RyaWdnZXIoJ21vdmUnLCBlLCB7ICdoZWxwZXInOiAkKCksICdlbGVtZW50JzogZWxtLCAnZGF0YSc6IGRyZyB9KTtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHRcdFx0fSlcblx0XHRcdFx0XHQvLy5vbignZHJhZ2VudGVyLmpzdHJlZScsIHRoaXMuc2V0dGluZ3MuZG5kLmxhcmdlX2Ryb3BfdGFyZ2V0ID8gJy5qc3RyZWUtbm9kZScgOiAnLmpzdHJlZS1hbmNob3InLCAkLnByb3h5KGZ1bmN0aW9uIChlKSB7XG5cdFx0XHRcdFx0Ly9cdFx0ZS5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0XHRcdC8vXHRcdCQudmFrYXRhLmRuZC5fdHJpZ2dlcignbW92ZScsIGUsIHsgJ2hlbHBlcic6ICQoKSwgJ2VsZW1lbnQnOiBlbG0sICdkYXRhJzogZHJnIH0pO1xuXHRcdFx0XHRcdC8vXHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0XHQvL1x0fSwgdGhpcykpXG5cdFx0XHRcdFx0Lm9uKCdkcm9wLmpzdHJlZScsICQucHJveHkoZnVuY3Rpb24gKGUpIHtcblx0XHRcdFx0XHRcdFx0ZS5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0XHRcdFx0XHQkLnZha2F0YS5kbmQuX3RyaWdnZXIoJ3N0b3AnLCBlLCB7ICdoZWxwZXInOiAkKCksICdlbGVtZW50JzogZWxtLCAnZGF0YSc6IGRyZyB9KTtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHRcdFx0fSwgdGhpcykpO1xuXHRcdFx0fVxuXHRcdH07XG5cdFx0dGhpcy5yZWRyYXdfbm9kZSA9IGZ1bmN0aW9uKG9iaiwgZGVlcCwgY2FsbGJhY2ssIGZvcmNlX3JlbmRlcikge1xuXHRcdFx0b2JqID0gcGFyZW50LnJlZHJhd19ub2RlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdFx0XHRpZiAob2JqICYmIHRoaXMuc2V0dGluZ3MuZG5kLnVzZV9odG1sNSkge1xuXHRcdFx0XHRpZiAodGhpcy5zZXR0aW5ncy5kbmQubGFyZ2VfZHJhZ190YXJnZXQpIHtcblx0XHRcdFx0XHRvYmouc2V0QXR0cmlidXRlKCdkcmFnZ2FibGUnLCB0cnVlKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR2YXIgaSwgaiwgdG1wID0gbnVsbDtcblx0XHRcdFx0XHRmb3IoaSA9IDAsIGogPSBvYmouY2hpbGROb2Rlcy5sZW5ndGg7IGkgPCBqOyBpKyspIHtcblx0XHRcdFx0XHRcdGlmKG9iai5jaGlsZE5vZGVzW2ldICYmIG9iai5jaGlsZE5vZGVzW2ldLmNsYXNzTmFtZSAmJiBvYmouY2hpbGROb2Rlc1tpXS5jbGFzc05hbWUuaW5kZXhPZihcImpzdHJlZS1hbmNob3JcIikgIT09IC0xKSB7XG5cdFx0XHRcdFx0XHRcdHRtcCA9IG9iai5jaGlsZE5vZGVzW2ldO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYodG1wKSB7XG5cdFx0XHRcdFx0XHR0bXAuc2V0QXR0cmlidXRlKCdkcmFnZ2FibGUnLCB0cnVlKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiBvYmo7XG5cdFx0fTtcblx0fTtcblxuXHQkKGZ1bmN0aW9uKCkge1xuXHRcdC8vIGJpbmQgb25seSBvbmNlIGZvciBhbGwgaW5zdGFuY2VzXG5cdFx0dmFyIGxhc3RtdiA9IGZhbHNlLFxuXHRcdFx0bGFzdGVyID0gZmFsc2UsXG5cdFx0XHRsYXN0ZXYgPSBmYWxzZSxcblx0XHRcdG9wZW50byA9IGZhbHNlLFxuXHRcdFx0bWFya2VyID0gJCgnPGRpdiBpZD1cImpzdHJlZS1tYXJrZXJcIj4mIzE2MDs8L2Rpdj4nKS5oaWRlKCk7IC8vLmFwcGVuZFRvKCdib2R5Jyk7XG5cblx0XHQkKGRvY3VtZW50KVxuXHRcdFx0Lm9uKCdkbmRfc3RhcnQudmFrYXRhLmpzdHJlZScsIGZ1bmN0aW9uIChlLCBkYXRhKSB7XG5cdFx0XHRcdGxhc3RtdiA9IGZhbHNlO1xuXHRcdFx0XHRsYXN0ZXYgPSBmYWxzZTtcblx0XHRcdFx0aWYoIWRhdGEgfHwgIWRhdGEuZGF0YSB8fCAhZGF0YS5kYXRhLmpzdHJlZSkgeyByZXR1cm47IH1cblx0XHRcdFx0bWFya2VyLmFwcGVuZFRvKCdib2R5Jyk7IC8vLnNob3coKTtcblx0XHRcdH0pXG5cdFx0XHQub24oJ2RuZF9tb3ZlLnZha2F0YS5qc3RyZWUnLCBmdW5jdGlvbiAoZSwgZGF0YSkge1xuXHRcdFx0XHRpZihvcGVudG8pIHtcblx0XHRcdFx0XHRpZiAoIWRhdGEuZXZlbnQgfHwgZGF0YS5ldmVudC50eXBlICE9PSAnZHJhZ292ZXInIHx8IGRhdGEuZXZlbnQudGFyZ2V0ICE9PSBsYXN0ZXYudGFyZ2V0KSB7XG5cdFx0XHRcdFx0XHRjbGVhclRpbWVvdXQob3BlbnRvKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYoIWRhdGEgfHwgIWRhdGEuZGF0YSB8fCAhZGF0YS5kYXRhLmpzdHJlZSkgeyByZXR1cm47IH1cblxuXHRcdFx0XHQvLyBpZiB3ZSBhcmUgaG92ZXJpbmcgdGhlIG1hcmtlciBpbWFnZSBkbyBub3RoaW5nIChjYW4gaGFwcGVuIG9uIFwiaW5zaWRlXCIgZHJhZ3MpXG5cdFx0XHRcdGlmKGRhdGEuZXZlbnQudGFyZ2V0LmlkICYmIGRhdGEuZXZlbnQudGFyZ2V0LmlkID09PSAnanN0cmVlLW1hcmtlcicpIHtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblx0XHRcdFx0bGFzdGV2ID0gZGF0YS5ldmVudDtcblxuXHRcdFx0XHR2YXIgaW5zID0gJC5qc3RyZWUucmVmZXJlbmNlKGRhdGEuZXZlbnQudGFyZ2V0KSxcblx0XHRcdFx0XHRyZWYgPSBmYWxzZSxcblx0XHRcdFx0XHRvZmYgPSBmYWxzZSxcblx0XHRcdFx0XHRyZWwgPSBmYWxzZSxcblx0XHRcdFx0XHR0bXAsIGwsIHQsIGgsIHAsIGksIG8sIG9rLCB0MSwgdDIsIG9wLCBwcywgcHIsIGlwLCB0bSwgaXNfY29weSwgcG47XG5cdFx0XHRcdC8vIGlmIHdlIGFyZSBvdmVyIGFuIGluc3RhbmNlXG5cdFx0XHRcdGlmKGlucyAmJiBpbnMuX2RhdGEgJiYgaW5zLl9kYXRhLmRuZCkge1xuXHRcdFx0XHRcdG1hcmtlci5hdHRyKCdjbGFzcycsICdqc3RyZWUtJyArIGlucy5nZXRfdGhlbWUoKSArICggaW5zLnNldHRpbmdzLmNvcmUudGhlbWVzLnJlc3BvbnNpdmUgPyAnIGpzdHJlZS1kbmQtcmVzcG9uc2l2ZScgOiAnJyApKTtcblx0XHRcdFx0XHRpc19jb3B5ID0gZGF0YS5kYXRhLm9yaWdpbiAmJiAoZGF0YS5kYXRhLm9yaWdpbi5zZXR0aW5ncy5kbmQuYWx3YXlzX2NvcHkgfHwgKGRhdGEuZGF0YS5vcmlnaW4uc2V0dGluZ3MuZG5kLmNvcHkgJiYgKGRhdGEuZXZlbnQubWV0YUtleSB8fCBkYXRhLmV2ZW50LmN0cmxLZXkpKSk7XG5cdFx0XHRcdFx0ZGF0YS5oZWxwZXJcblx0XHRcdFx0XHRcdC5jaGlsZHJlbigpLmF0dHIoJ2NsYXNzJywgJ2pzdHJlZS0nICsgaW5zLmdldF90aGVtZSgpICsgJyBqc3RyZWUtJyArIGlucy5nZXRfdGhlbWUoKSArICctJyArIGlucy5nZXRfdGhlbWVfdmFyaWFudCgpICsgJyAnICsgKCBpbnMuc2V0dGluZ3MuY29yZS50aGVtZXMucmVzcG9uc2l2ZSA/ICcganN0cmVlLWRuZC1yZXNwb25zaXZlJyA6ICcnICkpXG5cdFx0XHRcdFx0XHQuZmluZCgnLmpzdHJlZS1jb3B5JykuZmlyc3QoKVsgaXNfY29weSA/ICdzaG93JyA6ICdoaWRlJyBdKCk7XG5cblx0XHRcdFx0XHQvLyBpZiBhcmUgaG92ZXJpbmcgdGhlIGNvbnRhaW5lciBpdHNlbGYgYWRkIGEgbmV3IHJvb3Qgbm9kZVxuXHRcdFx0XHRcdC8vY29uc29sZS5sb2coZGF0YS5ldmVudCk7XG5cdFx0XHRcdFx0aWYoIChkYXRhLmV2ZW50LnRhcmdldCA9PT0gaW5zLmVsZW1lbnRbMF0gfHwgZGF0YS5ldmVudC50YXJnZXQgPT09IGlucy5nZXRfY29udGFpbmVyX3VsKClbMF0pICYmIGlucy5nZXRfY29udGFpbmVyX3VsKCkuY2hpbGRyZW4oKS5sZW5ndGggPT09IDApIHtcblx0XHRcdFx0XHRcdG9rID0gdHJ1ZTtcblx0XHRcdFx0XHRcdGZvcih0MSA9IDAsIHQyID0gZGF0YS5kYXRhLm5vZGVzLmxlbmd0aDsgdDEgPCB0MjsgdDErKykge1xuXHRcdFx0XHRcdFx0XHRvayA9IG9rICYmIGlucy5jaGVjayggKGRhdGEuZGF0YS5vcmlnaW4gJiYgKGRhdGEuZGF0YS5vcmlnaW4uc2V0dGluZ3MuZG5kLmFsd2F5c19jb3B5IHx8IChkYXRhLmRhdGEub3JpZ2luLnNldHRpbmdzLmRuZC5jb3B5ICYmIChkYXRhLmV2ZW50Lm1ldGFLZXkgfHwgZGF0YS5ldmVudC5jdHJsS2V5KSkgKSA/IFwiY29weV9ub2RlXCIgOiBcIm1vdmVfbm9kZVwiKSwgKGRhdGEuZGF0YS5vcmlnaW4gJiYgZGF0YS5kYXRhLm9yaWdpbiAhPT0gaW5zID8gZGF0YS5kYXRhLm9yaWdpbi5nZXRfbm9kZShkYXRhLmRhdGEubm9kZXNbdDFdKSA6IGRhdGEuZGF0YS5ub2Rlc1t0MV0pLCAkLmpzdHJlZS5yb290LCAnbGFzdCcsIHsgJ2RuZCcgOiB0cnVlLCAncmVmJyA6IGlucy5nZXRfbm9kZSgkLmpzdHJlZS5yb290KSwgJ3BvcycgOiAnaScsICdvcmlnaW4nIDogZGF0YS5kYXRhLm9yaWdpbiwgJ2lzX211bHRpJyA6IChkYXRhLmRhdGEub3JpZ2luICYmIGRhdGEuZGF0YS5vcmlnaW4gIT09IGlucyksICdpc19mb3JlaWduJyA6ICghZGF0YS5kYXRhLm9yaWdpbikgfSk7XG5cdFx0XHRcdFx0XHRcdGlmKCFvaykgeyBicmVhazsgfVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0aWYob2spIHtcblx0XHRcdFx0XHRcdFx0bGFzdG12ID0geyAnaW5zJyA6IGlucywgJ3BhcicgOiAkLmpzdHJlZS5yb290LCAncG9zJyA6ICdsYXN0JyB9O1xuXHRcdFx0XHRcdFx0XHRtYXJrZXIuaGlkZSgpO1xuXHRcdFx0XHRcdFx0XHRkYXRhLmhlbHBlci5maW5kKCcuanN0cmVlLWljb24nKS5maXJzdCgpLnJlbW92ZUNsYXNzKCdqc3RyZWUtZXInKS5hZGRDbGFzcygnanN0cmVlLW9rJyk7XG5cdFx0XHRcdFx0XHRcdGlmIChkYXRhLmV2ZW50Lm9yaWdpbmFsRXZlbnQgJiYgZGF0YS5ldmVudC5vcmlnaW5hbEV2ZW50LmRhdGFUcmFuc2Zlcikge1xuXHRcdFx0XHRcdFx0XHRcdGRhdGEuZXZlbnQub3JpZ2luYWxFdmVudC5kYXRhVHJhbnNmZXIuZHJvcEVmZmVjdCA9IGlzX2NvcHkgPyAnY29weScgOiAnbW92ZSc7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRcdC8vIGlmIHdlIGFyZSBob3ZlcmluZyBhIHRyZWUgbm9kZVxuXHRcdFx0XHRcdFx0cmVmID0gaW5zLnNldHRpbmdzLmRuZC5sYXJnZV9kcm9wX3RhcmdldCA/ICQoZGF0YS5ldmVudC50YXJnZXQpLmNsb3Nlc3QoJy5qc3RyZWUtbm9kZScpLmNoaWxkcmVuKCcuanN0cmVlLWFuY2hvcicpIDogJChkYXRhLmV2ZW50LnRhcmdldCkuY2xvc2VzdCgnLmpzdHJlZS1hbmNob3InKTtcblx0XHRcdFx0XHRcdGlmKHJlZiAmJiByZWYubGVuZ3RoICYmIHJlZi5wYXJlbnQoKS5pcygnLmpzdHJlZS1jbG9zZWQsIC5qc3RyZWUtb3BlbiwgLmpzdHJlZS1sZWFmJykpIHtcblx0XHRcdFx0XHRcdFx0b2ZmID0gcmVmLm9mZnNldCgpO1xuXHRcdFx0XHRcdFx0XHRyZWwgPSAoZGF0YS5ldmVudC5wYWdlWSAhPT0gdW5kZWZpbmVkID8gZGF0YS5ldmVudC5wYWdlWSA6IGRhdGEuZXZlbnQub3JpZ2luYWxFdmVudC5wYWdlWSkgLSBvZmYudG9wO1xuXHRcdFx0XHRcdFx0XHRoID0gcmVmLm91dGVySGVpZ2h0KCk7XG5cdFx0XHRcdFx0XHRcdGlmKHJlbCA8IGggLyAzKSB7XG5cdFx0XHRcdFx0XHRcdFx0byA9IFsnYicsICdpJywgJ2EnXTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRlbHNlIGlmKHJlbCA+IGggLSBoIC8gMykge1xuXHRcdFx0XHRcdFx0XHRcdG8gPSBbJ2EnLCAnaScsICdiJ107XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0byA9IHJlbCA+IGggLyAyID8gWydpJywgJ2EnLCAnYiddIDogWydpJywgJ2InLCAnYSddO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdCQuZWFjaChvLCBmdW5jdGlvbiAoaiwgdikge1xuXHRcdFx0XHRcdFx0XHRcdHN3aXRjaCh2KSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRjYXNlICdiJzpcblx0XHRcdFx0XHRcdFx0XHRcdFx0bCA9IG9mZi5sZWZ0IC0gNjtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dCA9IG9mZi50b3A7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHAgPSBpbnMuZ2V0X3BhcmVudChyZWYpO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRpID0gcmVmLnBhcmVudCgpLmluZGV4KCk7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0XHRcdFx0Y2FzZSAnaSc6XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlwID0gaW5zLnNldHRpbmdzLmRuZC5pbnNpZGVfcG9zO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0bSA9IGlucy5nZXRfbm9kZShyZWYucGFyZW50KCkpO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRsID0gb2ZmLmxlZnQgLSAyO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0ID0gb2ZmLnRvcCArIGggLyAyICsgMTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0cCA9IHRtLmlkO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRpID0gaXAgPT09ICdmaXJzdCcgPyAwIDogKGlwID09PSAnbGFzdCcgPyB0bS5jaGlsZHJlbi5sZW5ndGggOiBNYXRoLm1pbihpcCwgdG0uY2hpbGRyZW4ubGVuZ3RoKSk7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0XHRcdFx0Y2FzZSAnYSc6XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGwgPSBvZmYubGVmdCAtIDY7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHQgPSBvZmYudG9wICsgaDtcblx0XHRcdFx0XHRcdFx0XHRcdFx0cCA9IGlucy5nZXRfcGFyZW50KHJlZik7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGkgPSByZWYucGFyZW50KCkuaW5kZXgoKSArIDE7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRvayA9IHRydWU7XG5cdFx0XHRcdFx0XHRcdFx0Zm9yKHQxID0gMCwgdDIgPSBkYXRhLmRhdGEubm9kZXMubGVuZ3RoOyB0MSA8IHQyOyB0MSsrKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRvcCA9IGRhdGEuZGF0YS5vcmlnaW4gJiYgKGRhdGEuZGF0YS5vcmlnaW4uc2V0dGluZ3MuZG5kLmFsd2F5c19jb3B5IHx8IChkYXRhLmRhdGEub3JpZ2luLnNldHRpbmdzLmRuZC5jb3B5ICYmIChkYXRhLmV2ZW50Lm1ldGFLZXkgfHwgZGF0YS5ldmVudC5jdHJsS2V5KSkpID8gXCJjb3B5X25vZGVcIiA6IFwibW92ZV9ub2RlXCI7XG5cdFx0XHRcdFx0XHRcdFx0XHRwcyA9IGk7XG5cdFx0XHRcdFx0XHRcdFx0XHRpZihvcCA9PT0gXCJtb3ZlX25vZGVcIiAmJiB2ID09PSAnYScgJiYgKGRhdGEuZGF0YS5vcmlnaW4gJiYgZGF0YS5kYXRhLm9yaWdpbiA9PT0gaW5zKSAmJiBwID09PSBpbnMuZ2V0X3BhcmVudChkYXRhLmRhdGEubm9kZXNbdDFdKSkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRwciA9IGlucy5nZXRfbm9kZShwKTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWYocHMgPiAkLmluQXJyYXkoZGF0YS5kYXRhLm5vZGVzW3QxXSwgcHIuY2hpbGRyZW4pKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0cHMgLT0gMTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0b2sgPSBvayAmJiAoIChpbnMgJiYgaW5zLnNldHRpbmdzICYmIGlucy5zZXR0aW5ncy5kbmQgJiYgaW5zLnNldHRpbmdzLmRuZC5jaGVja193aGlsZV9kcmFnZ2luZyA9PT0gZmFsc2UpIHx8IGlucy5jaGVjayhvcCwgKGRhdGEuZGF0YS5vcmlnaW4gJiYgZGF0YS5kYXRhLm9yaWdpbiAhPT0gaW5zID8gZGF0YS5kYXRhLm9yaWdpbi5nZXRfbm9kZShkYXRhLmRhdGEubm9kZXNbdDFdKSA6IGRhdGEuZGF0YS5ub2Rlc1t0MV0pLCBwLCBwcywgeyAnZG5kJyA6IHRydWUsICdyZWYnIDogaW5zLmdldF9ub2RlKHJlZi5wYXJlbnQoKSksICdwb3MnIDogdiwgJ29yaWdpbicgOiBkYXRhLmRhdGEub3JpZ2luLCAnaXNfbXVsdGknIDogKGRhdGEuZGF0YS5vcmlnaW4gJiYgZGF0YS5kYXRhLm9yaWdpbiAhPT0gaW5zKSwgJ2lzX2ZvcmVpZ24nIDogKCFkYXRhLmRhdGEub3JpZ2luKSB9KSApO1xuXHRcdFx0XHRcdFx0XHRcdFx0aWYoIW9rKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlmKGlucyAmJiBpbnMubGFzdF9lcnJvcikgeyBsYXN0ZXIgPSBpbnMubGFzdF9lcnJvcigpOyB9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRpZih2ID09PSAnaScgJiYgcmVmLnBhcmVudCgpLmlzKCcuanN0cmVlLWNsb3NlZCcpICYmIGlucy5zZXR0aW5ncy5kbmQub3Blbl90aW1lb3V0KSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRvcGVudG8gPSBzZXRUaW1lb3V0KChmdW5jdGlvbiAoeCwgeikgeyByZXR1cm4gZnVuY3Rpb24gKCkgeyB4Lm9wZW5fbm9kZSh6KTsgfTsgfShpbnMsIHJlZikpLCBpbnMuc2V0dGluZ3MuZG5kLm9wZW5fdGltZW91dCk7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdGlmKG9rKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRwbiA9IGlucy5nZXRfbm9kZShwLCB0cnVlKTtcblx0XHRcdFx0XHRcdFx0XHRcdGlmICghcG4uaGFzQ2xhc3MoJy5qc3RyZWUtZG5kLXBhcmVudCcpKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdCQoJy5qc3RyZWUtZG5kLXBhcmVudCcpLnJlbW92ZUNsYXNzKCdqc3RyZWUtZG5kLXBhcmVudCcpO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRwbi5hZGRDbGFzcygnanN0cmVlLWRuZC1wYXJlbnQnKTtcblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdGxhc3RtdiA9IHsgJ2lucycgOiBpbnMsICdwYXInIDogcCwgJ3BvcycgOiB2ID09PSAnaScgJiYgaXAgPT09ICdsYXN0JyAmJiBpID09PSAwICYmICFpbnMuaXNfbG9hZGVkKHRtKSA/ICdsYXN0JyA6IGkgfTtcblx0XHRcdFx0XHRcdFx0XHRcdG1hcmtlci5jc3MoeyAnbGVmdCcgOiBsICsgJ3B4JywgJ3RvcCcgOiB0ICsgJ3B4JyB9KS5zaG93KCk7XG5cdFx0XHRcdFx0XHRcdFx0XHRkYXRhLmhlbHBlci5maW5kKCcuanN0cmVlLWljb24nKS5maXJzdCgpLnJlbW92ZUNsYXNzKCdqc3RyZWUtZXInKS5hZGRDbGFzcygnanN0cmVlLW9rJyk7XG5cdFx0XHRcdFx0XHRcdFx0XHRpZiAoZGF0YS5ldmVudC5vcmlnaW5hbEV2ZW50ICYmIGRhdGEuZXZlbnQub3JpZ2luYWxFdmVudC5kYXRhVHJhbnNmZXIpIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0ZGF0YS5ldmVudC5vcmlnaW5hbEV2ZW50LmRhdGFUcmFuc2Zlci5kcm9wRWZmZWN0ID0gaXNfY29weSA/ICdjb3B5JyA6ICdtb3ZlJztcblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdGxhc3RlciA9IHt9O1xuXHRcdFx0XHRcdFx0XHRcdFx0byA9IHRydWU7XG5cdFx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRcdFx0aWYobyA9PT0gdHJ1ZSkgeyByZXR1cm47IH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0JCgnLmpzdHJlZS1kbmQtcGFyZW50JykucmVtb3ZlQ2xhc3MoJ2pzdHJlZS1kbmQtcGFyZW50Jyk7XG5cdFx0XHRcdGxhc3RtdiA9IGZhbHNlO1xuXHRcdFx0XHRkYXRhLmhlbHBlci5maW5kKCcuanN0cmVlLWljb24nKS5yZW1vdmVDbGFzcygnanN0cmVlLW9rJykuYWRkQ2xhc3MoJ2pzdHJlZS1lcicpO1xuXHRcdFx0XHRpZiAoZGF0YS5ldmVudC5vcmlnaW5hbEV2ZW50ICYmIGRhdGEuZXZlbnQub3JpZ2luYWxFdmVudC5kYXRhVHJhbnNmZXIpIHtcblx0XHRcdFx0XHRkYXRhLmV2ZW50Lm9yaWdpbmFsRXZlbnQuZGF0YVRyYW5zZmVyLmRyb3BFZmZlY3QgPSAnbm9uZSc7XG5cdFx0XHRcdH1cblx0XHRcdFx0bWFya2VyLmhpZGUoKTtcblx0XHRcdH0pXG5cdFx0XHQub24oJ2RuZF9zY3JvbGwudmFrYXRhLmpzdHJlZScsIGZ1bmN0aW9uIChlLCBkYXRhKSB7XG5cdFx0XHRcdGlmKCFkYXRhIHx8ICFkYXRhLmRhdGEgfHwgIWRhdGEuZGF0YS5qc3RyZWUpIHsgcmV0dXJuOyB9XG5cdFx0XHRcdG1hcmtlci5oaWRlKCk7XG5cdFx0XHRcdGxhc3RtdiA9IGZhbHNlO1xuXHRcdFx0XHRsYXN0ZXYgPSBmYWxzZTtcblx0XHRcdFx0ZGF0YS5oZWxwZXIuZmluZCgnLmpzdHJlZS1pY29uJykuZmlyc3QoKS5yZW1vdmVDbGFzcygnanN0cmVlLW9rJykuYWRkQ2xhc3MoJ2pzdHJlZS1lcicpO1xuXHRcdFx0fSlcblx0XHRcdC5vbignZG5kX3N0b3AudmFrYXRhLmpzdHJlZScsIGZ1bmN0aW9uIChlLCBkYXRhKSB7XG5cdFx0XHRcdCQoJy5qc3RyZWUtZG5kLXBhcmVudCcpLnJlbW92ZUNsYXNzKCdqc3RyZWUtZG5kLXBhcmVudCcpO1xuXHRcdFx0XHRpZihvcGVudG8pIHsgY2xlYXJUaW1lb3V0KG9wZW50byk7IH1cblx0XHRcdFx0aWYoIWRhdGEgfHwgIWRhdGEuZGF0YSB8fCAhZGF0YS5kYXRhLmpzdHJlZSkgeyByZXR1cm47IH1cblx0XHRcdFx0bWFya2VyLmhpZGUoKS5kZXRhY2goKTtcblx0XHRcdFx0dmFyIGksIGosIG5vZGVzID0gW107XG5cdFx0XHRcdGlmKGxhc3Rtdikge1xuXHRcdFx0XHRcdGZvcihpID0gMCwgaiA9IGRhdGEuZGF0YS5ub2Rlcy5sZW5ndGg7IGkgPCBqOyBpKyspIHtcblx0XHRcdFx0XHRcdG5vZGVzW2ldID0gZGF0YS5kYXRhLm9yaWdpbiA/IGRhdGEuZGF0YS5vcmlnaW4uZ2V0X25vZGUoZGF0YS5kYXRhLm5vZGVzW2ldKSA6IGRhdGEuZGF0YS5ub2Rlc1tpXTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0bGFzdG12Lmluc1sgZGF0YS5kYXRhLm9yaWdpbiAmJiAoZGF0YS5kYXRhLm9yaWdpbi5zZXR0aW5ncy5kbmQuYWx3YXlzX2NvcHkgfHwgKGRhdGEuZGF0YS5vcmlnaW4uc2V0dGluZ3MuZG5kLmNvcHkgJiYgKGRhdGEuZXZlbnQubWV0YUtleSB8fCBkYXRhLmV2ZW50LmN0cmxLZXkpKSkgPyAnY29weV9ub2RlJyA6ICdtb3ZlX25vZGUnIF0obm9kZXMsIGxhc3Rtdi5wYXIsIGxhc3Rtdi5wb3MsIGZhbHNlLCBmYWxzZSwgZmFsc2UsIGRhdGEuZGF0YS5vcmlnaW4pO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdGkgPSAkKGRhdGEuZXZlbnQudGFyZ2V0KS5jbG9zZXN0KCcuanN0cmVlJyk7XG5cdFx0XHRcdFx0aWYoaS5sZW5ndGggJiYgbGFzdGVyICYmIGxhc3Rlci5lcnJvciAmJiBsYXN0ZXIuZXJyb3IgPT09ICdjaGVjaycpIHtcblx0XHRcdFx0XHRcdGkgPSBpLmpzdHJlZSh0cnVlKTtcblx0XHRcdFx0XHRcdGlmKGkpIHtcblx0XHRcdFx0XHRcdFx0aS5zZXR0aW5ncy5jb3JlLmVycm9yLmNhbGwodGhpcywgbGFzdGVyKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0bGFzdGV2ID0gZmFsc2U7XG5cdFx0XHRcdGxhc3RtdiA9IGZhbHNlO1xuXHRcdFx0fSlcblx0XHRcdC5vbigna2V5dXAuanN0cmVlIGtleWRvd24uanN0cmVlJywgZnVuY3Rpb24gKGUsIGRhdGEpIHtcblx0XHRcdFx0ZGF0YSA9ICQudmFrYXRhLmRuZC5fZ2V0KCk7XG5cdFx0XHRcdGlmKGRhdGEgJiYgZGF0YS5kYXRhICYmIGRhdGEuZGF0YS5qc3RyZWUpIHtcblx0XHRcdFx0XHRpZiAoZS50eXBlID09PSBcImtleXVwXCIgJiYgZS53aGljaCA9PT0gMjcpIHtcblx0XHRcdFx0XHRcdGlmIChvcGVudG8pIHsgY2xlYXJUaW1lb3V0KG9wZW50byk7IH1cblx0XHRcdFx0XHRcdGxhc3RtdiA9IGZhbHNlO1xuXHRcdFx0XHRcdFx0bGFzdGVyID0gZmFsc2U7XG5cdFx0XHRcdFx0XHRsYXN0ZXYgPSBmYWxzZTtcblx0XHRcdFx0XHRcdG9wZW50byA9IGZhbHNlO1xuXHRcdFx0XHRcdFx0bWFya2VyLmhpZGUoKS5kZXRhY2goKTtcblx0XHRcdFx0XHRcdCQudmFrYXRhLmRuZC5fY2xlYW4oKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0ZGF0YS5oZWxwZXIuZmluZCgnLmpzdHJlZS1jb3B5JykuZmlyc3QoKVsgZGF0YS5kYXRhLm9yaWdpbiAmJiAoZGF0YS5kYXRhLm9yaWdpbi5zZXR0aW5ncy5kbmQuYWx3YXlzX2NvcHkgfHwgKGRhdGEuZGF0YS5vcmlnaW4uc2V0dGluZ3MuZG5kLmNvcHkgJiYgKGUubWV0YUtleSB8fCBlLmN0cmxLZXkpKSkgPyAnc2hvdycgOiAnaGlkZScgXSgpO1xuXHRcdFx0XHRcdFx0aWYobGFzdGV2KSB7XG5cdFx0XHRcdFx0XHRcdGxhc3Rldi5tZXRhS2V5ID0gZS5tZXRhS2V5O1xuXHRcdFx0XHRcdFx0XHRsYXN0ZXYuY3RybEtleSA9IGUuY3RybEtleTtcblx0XHRcdFx0XHRcdFx0JC52YWthdGEuZG5kLl90cmlnZ2VyKCdtb3ZlJywgbGFzdGV2KTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHR9KTtcblxuXHQvLyBoZWxwZXJzXG5cdChmdW5jdGlvbiAoJCkge1xuXHRcdCQudmFrYXRhLmh0bWwgPSB7XG5cdFx0XHRkaXYgOiAkKCc8ZGl2IC8+JyksXG5cdFx0XHRlc2NhcGUgOiBmdW5jdGlvbiAoc3RyKSB7XG5cdFx0XHRcdHJldHVybiAkLnZha2F0YS5odG1sLmRpdi50ZXh0KHN0cikuaHRtbCgpO1xuXHRcdFx0fSxcblx0XHRcdHN0cmlwIDogZnVuY3Rpb24gKHN0cikge1xuXHRcdFx0XHRyZXR1cm4gJC52YWthdGEuaHRtbC5kaXYuZW1wdHkoKS5hcHBlbmQoJC5wYXJzZUhUTUwoc3RyKSkudGV4dCgpO1xuXHRcdFx0fVxuXHRcdH07XG5cdFx0Ly8gcHJpdmF0ZSB2YXJpYWJsZVxuXHRcdHZhciB2YWthdGFfZG5kID0ge1xuXHRcdFx0ZWxlbWVudFx0OiBmYWxzZSxcblx0XHRcdHRhcmdldFx0OiBmYWxzZSxcblx0XHRcdGlzX2Rvd25cdDogZmFsc2UsXG5cdFx0XHRpc19kcmFnXHQ6IGZhbHNlLFxuXHRcdFx0aGVscGVyXHQ6IGZhbHNlLFxuXHRcdFx0aGVscGVyX3c6IDAsXG5cdFx0XHRkYXRhXHQ6IGZhbHNlLFxuXHRcdFx0aW5pdF94XHQ6IDAsXG5cdFx0XHRpbml0X3lcdDogMCxcblx0XHRcdHNjcm9sbF9sOiAwLFxuXHRcdFx0c2Nyb2xsX3Q6IDAsXG5cdFx0XHRzY3JvbGxfZTogZmFsc2UsXG5cdFx0XHRzY3JvbGxfaTogZmFsc2UsXG5cdFx0XHRpc190b3VjaDogZmFsc2Vcblx0XHR9O1xuXHRcdCQudmFrYXRhLmRuZCA9IHtcblx0XHRcdHNldHRpbmdzIDoge1xuXHRcdFx0XHRzY3JvbGxfc3BlZWRcdFx0OiAxMCxcblx0XHRcdFx0c2Nyb2xsX3Byb3hpbWl0eVx0OiAyMCxcblx0XHRcdFx0aGVscGVyX2xlZnRcdFx0XHQ6IDUsXG5cdFx0XHRcdGhlbHBlcl90b3BcdFx0XHQ6IDEwLFxuXHRcdFx0XHR0aHJlc2hvbGRcdFx0XHQ6IDUsXG5cdFx0XHRcdHRocmVzaG9sZF90b3VjaFx0XHQ6IDUwXG5cdFx0XHR9LFxuXHRcdFx0X3RyaWdnZXIgOiBmdW5jdGlvbiAoZXZlbnRfbmFtZSwgZSwgZGF0YSkge1xuXHRcdFx0XHRpZiAoZGF0YSA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdFx0ZGF0YSA9ICQudmFrYXRhLmRuZC5fZ2V0KCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZGF0YS5ldmVudCA9IGU7XG5cdFx0XHRcdCQoZG9jdW1lbnQpLnRyaWdnZXJIYW5kbGVyKFwiZG5kX1wiICsgZXZlbnRfbmFtZSArIFwiLnZha2F0YVwiLCBkYXRhKTtcblx0XHRcdH0sXG5cdFx0XHRfZ2V0IDogZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRcdFwiZGF0YVwiXHRcdDogdmFrYXRhX2RuZC5kYXRhLFxuXHRcdFx0XHRcdFwiZWxlbWVudFwiXHQ6IHZha2F0YV9kbmQuZWxlbWVudCxcblx0XHRcdFx0XHRcImhlbHBlclwiXHQ6IHZha2F0YV9kbmQuaGVscGVyXG5cdFx0XHRcdH07XG5cdFx0XHR9LFxuXHRcdFx0X2NsZWFuIDogZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRpZih2YWthdGFfZG5kLmhlbHBlcikgeyB2YWthdGFfZG5kLmhlbHBlci5yZW1vdmUoKTsgfVxuXHRcdFx0XHRpZih2YWthdGFfZG5kLnNjcm9sbF9pKSB7IGNsZWFySW50ZXJ2YWwodmFrYXRhX2RuZC5zY3JvbGxfaSk7IHZha2F0YV9kbmQuc2Nyb2xsX2kgPSBmYWxzZTsgfVxuXHRcdFx0XHR2YWthdGFfZG5kID0ge1xuXHRcdFx0XHRcdGVsZW1lbnRcdDogZmFsc2UsXG5cdFx0XHRcdFx0dGFyZ2V0XHQ6IGZhbHNlLFxuXHRcdFx0XHRcdGlzX2Rvd25cdDogZmFsc2UsXG5cdFx0XHRcdFx0aXNfZHJhZ1x0OiBmYWxzZSxcblx0XHRcdFx0XHRoZWxwZXJcdDogZmFsc2UsXG5cdFx0XHRcdFx0aGVscGVyX3c6IDAsXG5cdFx0XHRcdFx0ZGF0YVx0OiBmYWxzZSxcblx0XHRcdFx0XHRpbml0X3hcdDogMCxcblx0XHRcdFx0XHRpbml0X3lcdDogMCxcblx0XHRcdFx0XHRzY3JvbGxfbDogMCxcblx0XHRcdFx0XHRzY3JvbGxfdDogMCxcblx0XHRcdFx0XHRzY3JvbGxfZTogZmFsc2UsXG5cdFx0XHRcdFx0c2Nyb2xsX2k6IGZhbHNlLFxuXHRcdFx0XHRcdGlzX3RvdWNoOiBmYWxzZVxuXHRcdFx0XHR9O1xuXHRcdFx0XHQkKGRvY3VtZW50KS5vZmYoXCJtb3VzZW1vdmUudmFrYXRhLmpzdHJlZSB0b3VjaG1vdmUudmFrYXRhLmpzdHJlZVwiLCAkLnZha2F0YS5kbmQuZHJhZyk7XG5cdFx0XHRcdCQoZG9jdW1lbnQpLm9mZihcIm1vdXNldXAudmFrYXRhLmpzdHJlZSB0b3VjaGVuZC52YWthdGEuanN0cmVlXCIsICQudmFrYXRhLmRuZC5zdG9wKTtcblx0XHRcdH0sXG5cdFx0XHRfc2Nyb2xsIDogZnVuY3Rpb24gKGluaXRfb25seSkge1xuXHRcdFx0XHRpZighdmFrYXRhX2RuZC5zY3JvbGxfZSB8fCAoIXZha2F0YV9kbmQuc2Nyb2xsX2wgJiYgIXZha2F0YV9kbmQuc2Nyb2xsX3QpKSB7XG5cdFx0XHRcdFx0aWYodmFrYXRhX2RuZC5zY3JvbGxfaSkgeyBjbGVhckludGVydmFsKHZha2F0YV9kbmQuc2Nyb2xsX2kpOyB2YWthdGFfZG5kLnNjcm9sbF9pID0gZmFsc2U7IH1cblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYoIXZha2F0YV9kbmQuc2Nyb2xsX2kpIHtcblx0XHRcdFx0XHR2YWthdGFfZG5kLnNjcm9sbF9pID0gc2V0SW50ZXJ2YWwoJC52YWthdGEuZG5kLl9zY3JvbGwsIDEwMCk7XG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmKGluaXRfb25seSA9PT0gdHJ1ZSkgeyByZXR1cm4gZmFsc2U7IH1cblxuXHRcdFx0XHR2YXIgaSA9IHZha2F0YV9kbmQuc2Nyb2xsX2Uuc2Nyb2xsVG9wKCksXG5cdFx0XHRcdFx0aiA9IHZha2F0YV9kbmQuc2Nyb2xsX2Uuc2Nyb2xsTGVmdCgpO1xuXHRcdFx0XHR2YWthdGFfZG5kLnNjcm9sbF9lLnNjcm9sbFRvcChpICsgdmFrYXRhX2RuZC5zY3JvbGxfdCAqICQudmFrYXRhLmRuZC5zZXR0aW5ncy5zY3JvbGxfc3BlZWQpO1xuXHRcdFx0XHR2YWthdGFfZG5kLnNjcm9sbF9lLnNjcm9sbExlZnQoaiArIHZha2F0YV9kbmQuc2Nyb2xsX2wgKiAkLnZha2F0YS5kbmQuc2V0dGluZ3Muc2Nyb2xsX3NwZWVkKTtcblx0XHRcdFx0aWYoaSAhPT0gdmFrYXRhX2RuZC5zY3JvbGxfZS5zY3JvbGxUb3AoKSB8fCBqICE9PSB2YWthdGFfZG5kLnNjcm9sbF9lLnNjcm9sbExlZnQoKSkge1xuXHRcdFx0XHRcdC8qKlxuXHRcdFx0XHRcdCAqIHRyaWdnZXJlZCBvbiB0aGUgZG9jdW1lbnQgd2hlbiBhIGRyYWcgY2F1c2VzIGFuIGVsZW1lbnQgdG8gc2Nyb2xsXG5cdFx0XHRcdFx0ICogQGV2ZW50XG5cdFx0XHRcdFx0ICogQHBsdWdpbiBkbmRcblx0XHRcdFx0XHQgKiBAbmFtZSBkbmRfc2Nyb2xsLnZha2F0YVxuXHRcdFx0XHRcdCAqIEBwYXJhbSB7TWl4ZWR9IGRhdGEgYW55IGRhdGEgc3VwcGxpZWQgd2l0aCB0aGUgY2FsbCB0byAkLnZha2F0YS5kbmQuc3RhcnRcblx0XHRcdFx0XHQgKiBAcGFyYW0ge0RPTX0gZWxlbWVudCB0aGUgRE9NIGVsZW1lbnQgYmVpbmcgZHJhZ2dlZFxuXHRcdFx0XHRcdCAqIEBwYXJhbSB7alF1ZXJ5fSBoZWxwZXIgdGhlIGhlbHBlciBzaG93biBuZXh0IHRvIHRoZSBtb3VzZVxuXHRcdFx0XHRcdCAqIEBwYXJhbSB7alF1ZXJ5fSBldmVudCB0aGUgZWxlbWVudCB0aGF0IGlzIHNjcm9sbGluZ1xuXHRcdFx0XHRcdCAqL1xuXHRcdFx0XHRcdCQudmFrYXRhLmRuZC5fdHJpZ2dlcihcInNjcm9sbFwiLCB2YWthdGFfZG5kLnNjcm9sbF9lKTtcblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdHN0YXJ0IDogZnVuY3Rpb24gKGUsIGRhdGEsIGh0bWwpIHtcblx0XHRcdFx0aWYoZS50eXBlID09PSBcInRvdWNoc3RhcnRcIiAmJiBlLm9yaWdpbmFsRXZlbnQgJiYgZS5vcmlnaW5hbEV2ZW50LmNoYW5nZWRUb3VjaGVzICYmIGUub3JpZ2luYWxFdmVudC5jaGFuZ2VkVG91Y2hlc1swXSkge1xuXHRcdFx0XHRcdGUucGFnZVggPSBlLm9yaWdpbmFsRXZlbnQuY2hhbmdlZFRvdWNoZXNbMF0ucGFnZVg7XG5cdFx0XHRcdFx0ZS5wYWdlWSA9IGUub3JpZ2luYWxFdmVudC5jaGFuZ2VkVG91Y2hlc1swXS5wYWdlWTtcblx0XHRcdFx0XHRlLnRhcmdldCA9IGRvY3VtZW50LmVsZW1lbnRGcm9tUG9pbnQoZS5vcmlnaW5hbEV2ZW50LmNoYW5nZWRUb3VjaGVzWzBdLnBhZ2VYIC0gd2luZG93LnBhZ2VYT2Zmc2V0LCBlLm9yaWdpbmFsRXZlbnQuY2hhbmdlZFRvdWNoZXNbMF0ucGFnZVkgLSB3aW5kb3cucGFnZVlPZmZzZXQpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmKHZha2F0YV9kbmQuaXNfZHJhZykgeyAkLnZha2F0YS5kbmQuc3RvcCh7fSk7IH1cblx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRlLmN1cnJlbnRUYXJnZXQudW5zZWxlY3RhYmxlID0gXCJvblwiO1xuXHRcdFx0XHRcdGUuY3VycmVudFRhcmdldC5vbnNlbGVjdHN0YXJ0ID0gZnVuY3Rpb24oKSB7IHJldHVybiBmYWxzZTsgfTtcblx0XHRcdFx0XHRpZihlLmN1cnJlbnRUYXJnZXQuc3R5bGUpIHtcblx0XHRcdFx0XHRcdGUuY3VycmVudFRhcmdldC5zdHlsZS50b3VjaEFjdGlvbiA9IFwibm9uZVwiO1xuXHRcdFx0XHRcdFx0ZS5jdXJyZW50VGFyZ2V0LnN0eWxlLm1zVG91Y2hBY3Rpb24gPSBcIm5vbmVcIjtcblx0XHRcdFx0XHRcdGUuY3VycmVudFRhcmdldC5zdHlsZS5Nb3pVc2VyU2VsZWN0ID0gXCJub25lXCI7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGNhdGNoKGlnbm9yZSkgeyB9XG5cdFx0XHRcdHZha2F0YV9kbmQuaW5pdF94XHQ9IGUucGFnZVg7XG5cdFx0XHRcdHZha2F0YV9kbmQuaW5pdF95XHQ9IGUucGFnZVk7XG5cdFx0XHRcdHZha2F0YV9kbmQuZGF0YVx0XHQ9IGRhdGE7XG5cdFx0XHRcdHZha2F0YV9kbmQuaXNfZG93blx0PSB0cnVlO1xuXHRcdFx0XHR2YWthdGFfZG5kLmVsZW1lbnRcdD0gZS5jdXJyZW50VGFyZ2V0O1xuXHRcdFx0XHR2YWthdGFfZG5kLnRhcmdldFx0PSBlLnRhcmdldDtcblx0XHRcdFx0dmFrYXRhX2RuZC5pc190b3VjaFx0PSBlLnR5cGUgPT09IFwidG91Y2hzdGFydFwiO1xuXHRcdFx0XHRpZihodG1sICE9PSBmYWxzZSkge1xuXHRcdFx0XHRcdHZha2F0YV9kbmQuaGVscGVyID0gJChcIjxkaXYgaWQ9J3Zha2F0YS1kbmQnPjwvZGl2PlwiKS5odG1sKGh0bWwpLmNzcyh7XG5cdFx0XHRcdFx0XHRcImRpc3BsYXlcIlx0XHQ6IFwiYmxvY2tcIixcblx0XHRcdFx0XHRcdFwibWFyZ2luXCJcdFx0OiBcIjBcIixcblx0XHRcdFx0XHRcdFwicGFkZGluZ1wiXHRcdDogXCIwXCIsXG5cdFx0XHRcdFx0XHRcInBvc2l0aW9uXCJcdFx0OiBcImFic29sdXRlXCIsXG5cdFx0XHRcdFx0XHRcInRvcFwiXHRcdFx0OiBcIi0yMDAwcHhcIixcblx0XHRcdFx0XHRcdFwibGluZUhlaWdodFwiXHQ6IFwiMTZweFwiLFxuXHRcdFx0XHRcdFx0XCJ6SW5kZXhcIlx0XHQ6IFwiMTAwMDBcIlxuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9XG5cdFx0XHRcdCQoZG9jdW1lbnQpLm9uKFwibW91c2Vtb3ZlLnZha2F0YS5qc3RyZWUgdG91Y2htb3ZlLnZha2F0YS5qc3RyZWVcIiwgJC52YWthdGEuZG5kLmRyYWcpO1xuXHRcdFx0XHQkKGRvY3VtZW50KS5vbihcIm1vdXNldXAudmFrYXRhLmpzdHJlZSB0b3VjaGVuZC52YWthdGEuanN0cmVlXCIsICQudmFrYXRhLmRuZC5zdG9wKTtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fSxcblx0XHRcdGRyYWcgOiBmdW5jdGlvbiAoZSkge1xuXHRcdFx0XHRpZihlLnR5cGUgPT09IFwidG91Y2htb3ZlXCIgJiYgZS5vcmlnaW5hbEV2ZW50ICYmIGUub3JpZ2luYWxFdmVudC5jaGFuZ2VkVG91Y2hlcyAmJiBlLm9yaWdpbmFsRXZlbnQuY2hhbmdlZFRvdWNoZXNbMF0pIHtcblx0XHRcdFx0XHRlLnBhZ2VYID0gZS5vcmlnaW5hbEV2ZW50LmNoYW5nZWRUb3VjaGVzWzBdLnBhZ2VYO1xuXHRcdFx0XHRcdGUucGFnZVkgPSBlLm9yaWdpbmFsRXZlbnQuY2hhbmdlZFRvdWNoZXNbMF0ucGFnZVk7XG5cdFx0XHRcdFx0ZS50YXJnZXQgPSBkb2N1bWVudC5lbGVtZW50RnJvbVBvaW50KGUub3JpZ2luYWxFdmVudC5jaGFuZ2VkVG91Y2hlc1swXS5wYWdlWCAtIHdpbmRvdy5wYWdlWE9mZnNldCwgZS5vcmlnaW5hbEV2ZW50LmNoYW5nZWRUb3VjaGVzWzBdLnBhZ2VZIC0gd2luZG93LnBhZ2VZT2Zmc2V0KTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZighdmFrYXRhX2RuZC5pc19kb3duKSB7IHJldHVybjsgfVxuXHRcdFx0XHRpZighdmFrYXRhX2RuZC5pc19kcmFnKSB7XG5cdFx0XHRcdFx0aWYoXG5cdFx0XHRcdFx0XHRNYXRoLmFicyhlLnBhZ2VYIC0gdmFrYXRhX2RuZC5pbml0X3gpID4gKHZha2F0YV9kbmQuaXNfdG91Y2ggPyAkLnZha2F0YS5kbmQuc2V0dGluZ3MudGhyZXNob2xkX3RvdWNoIDogJC52YWthdGEuZG5kLnNldHRpbmdzLnRocmVzaG9sZCkgfHxcblx0XHRcdFx0XHRcdE1hdGguYWJzKGUucGFnZVkgLSB2YWthdGFfZG5kLmluaXRfeSkgPiAodmFrYXRhX2RuZC5pc190b3VjaCA/ICQudmFrYXRhLmRuZC5zZXR0aW5ncy50aHJlc2hvbGRfdG91Y2ggOiAkLnZha2F0YS5kbmQuc2V0dGluZ3MudGhyZXNob2xkKVxuXHRcdFx0XHRcdCkge1xuXHRcdFx0XHRcdFx0aWYodmFrYXRhX2RuZC5oZWxwZXIpIHtcblx0XHRcdFx0XHRcdFx0dmFrYXRhX2RuZC5oZWxwZXIuYXBwZW5kVG8oXCJib2R5XCIpO1xuXHRcdFx0XHRcdFx0XHR2YWthdGFfZG5kLmhlbHBlcl93ID0gdmFrYXRhX2RuZC5oZWxwZXIub3V0ZXJXaWR0aCgpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0dmFrYXRhX2RuZC5pc19kcmFnID0gdHJ1ZTtcblx0XHRcdFx0XHRcdCQodmFrYXRhX2RuZC50YXJnZXQpLm9uZSgnY2xpY2sudmFrYXRhJywgZmFsc2UpO1xuXHRcdFx0XHRcdFx0LyoqXG5cdFx0XHRcdFx0XHQgKiB0cmlnZ2VyZWQgb24gdGhlIGRvY3VtZW50IHdoZW4gYSBkcmFnIHN0YXJ0c1xuXHRcdFx0XHRcdFx0ICogQGV2ZW50XG5cdFx0XHRcdFx0XHQgKiBAcGx1Z2luIGRuZFxuXHRcdFx0XHRcdFx0ICogQG5hbWUgZG5kX3N0YXJ0LnZha2F0YVxuXHRcdFx0XHRcdFx0ICogQHBhcmFtIHtNaXhlZH0gZGF0YSBhbnkgZGF0YSBzdXBwbGllZCB3aXRoIHRoZSBjYWxsIHRvICQudmFrYXRhLmRuZC5zdGFydFxuXHRcdFx0XHRcdFx0ICogQHBhcmFtIHtET019IGVsZW1lbnQgdGhlIERPTSBlbGVtZW50IGJlaW5nIGRyYWdnZWRcblx0XHRcdFx0XHRcdCAqIEBwYXJhbSB7alF1ZXJ5fSBoZWxwZXIgdGhlIGhlbHBlciBzaG93biBuZXh0IHRvIHRoZSBtb3VzZVxuXHRcdFx0XHRcdFx0ICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IHRoZSBldmVudCB0aGF0IGNhdXNlZCB0aGUgc3RhcnQgKHByb2JhYmx5IG1vdXNlbW92ZSlcblx0XHRcdFx0XHRcdCAqL1xuXHRcdFx0XHRcdFx0JC52YWthdGEuZG5kLl90cmlnZ2VyKFwic3RhcnRcIiwgZSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGVsc2UgeyByZXR1cm47IH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHZhciBkICA9IGZhbHNlLCB3ICA9IGZhbHNlLFxuXHRcdFx0XHRcdGRoID0gZmFsc2UsIHdoID0gZmFsc2UsXG5cdFx0XHRcdFx0ZHcgPSBmYWxzZSwgd3cgPSBmYWxzZSxcblx0XHRcdFx0XHRkdCA9IGZhbHNlLCBkbCA9IGZhbHNlLFxuXHRcdFx0XHRcdGh0ID0gZmFsc2UsIGhsID0gZmFsc2U7XG5cblx0XHRcdFx0dmFrYXRhX2RuZC5zY3JvbGxfdCA9IDA7XG5cdFx0XHRcdHZha2F0YV9kbmQuc2Nyb2xsX2wgPSAwO1xuXHRcdFx0XHR2YWthdGFfZG5kLnNjcm9sbF9lID0gZmFsc2U7XG5cdFx0XHRcdCQoJChlLnRhcmdldCkucGFyZW50c1VudGlsKFwiYm9keVwiKS5hZGRCYWNrKCkuZ2V0KCkucmV2ZXJzZSgpKVxuXHRcdFx0XHRcdC5maWx0ZXIoZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdFx0cmV0dXJuXHQoL15hdXRvfHNjcm9sbCQvKS50ZXN0KCQodGhpcykuY3NzKFwib3ZlcmZsb3dcIikpICYmXG5cdFx0XHRcdFx0XHRcdFx0KHRoaXMuc2Nyb2xsSGVpZ2h0ID4gdGhpcy5vZmZzZXRIZWlnaHQgfHwgdGhpcy5zY3JvbGxXaWR0aCA+IHRoaXMub2Zmc2V0V2lkdGgpO1xuXHRcdFx0XHRcdH0pXG5cdFx0XHRcdFx0LmVhY2goZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdFx0dmFyIHQgPSAkKHRoaXMpLCBvID0gdC5vZmZzZXQoKTtcblx0XHRcdFx0XHRcdGlmKHRoaXMuc2Nyb2xsSGVpZ2h0ID4gdGhpcy5vZmZzZXRIZWlnaHQpIHtcblx0XHRcdFx0XHRcdFx0aWYoby50b3AgKyB0LmhlaWdodCgpIC0gZS5wYWdlWSA8ICQudmFrYXRhLmRuZC5zZXR0aW5ncy5zY3JvbGxfcHJveGltaXR5KVx0eyB2YWthdGFfZG5kLnNjcm9sbF90ID0gMTsgfVxuXHRcdFx0XHRcdFx0XHRpZihlLnBhZ2VZIC0gby50b3AgPCAkLnZha2F0YS5kbmQuc2V0dGluZ3Muc2Nyb2xsX3Byb3hpbWl0eSlcdFx0XHRcdHsgdmFrYXRhX2RuZC5zY3JvbGxfdCA9IC0xOyB9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRpZih0aGlzLnNjcm9sbFdpZHRoID4gdGhpcy5vZmZzZXRXaWR0aCkge1xuXHRcdFx0XHRcdFx0XHRpZihvLmxlZnQgKyB0LndpZHRoKCkgLSBlLnBhZ2VYIDwgJC52YWthdGEuZG5kLnNldHRpbmdzLnNjcm9sbF9wcm94aW1pdHkpXHR7IHZha2F0YV9kbmQuc2Nyb2xsX2wgPSAxOyB9XG5cdFx0XHRcdFx0XHRcdGlmKGUucGFnZVggLSBvLmxlZnQgPCAkLnZha2F0YS5kbmQuc2V0dGluZ3Muc2Nyb2xsX3Byb3hpbWl0eSlcdFx0XHRcdHsgdmFrYXRhX2RuZC5zY3JvbGxfbCA9IC0xOyB9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRpZih2YWthdGFfZG5kLnNjcm9sbF90IHx8IHZha2F0YV9kbmQuc2Nyb2xsX2wpIHtcblx0XHRcdFx0XHRcdFx0dmFrYXRhX2RuZC5zY3JvbGxfZSA9ICQodGhpcyk7XG5cdFx0XHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9KTtcblxuXHRcdFx0XHRpZighdmFrYXRhX2RuZC5zY3JvbGxfZSkge1xuXHRcdFx0XHRcdGQgID0gJChkb2N1bWVudCk7IHcgPSAkKHdpbmRvdyk7XG5cdFx0XHRcdFx0ZGggPSBkLmhlaWdodCgpOyB3aCA9IHcuaGVpZ2h0KCk7XG5cdFx0XHRcdFx0ZHcgPSBkLndpZHRoKCk7IHd3ID0gdy53aWR0aCgpO1xuXHRcdFx0XHRcdGR0ID0gZC5zY3JvbGxUb3AoKTsgZGwgPSBkLnNjcm9sbExlZnQoKTtcblx0XHRcdFx0XHRpZihkaCA+IHdoICYmIGUucGFnZVkgLSBkdCA8ICQudmFrYXRhLmRuZC5zZXR0aW5ncy5zY3JvbGxfcHJveGltaXR5KVx0XHR7IHZha2F0YV9kbmQuc2Nyb2xsX3QgPSAtMTsgIH1cblx0XHRcdFx0XHRpZihkaCA+IHdoICYmIHdoIC0gKGUucGFnZVkgLSBkdCkgPCAkLnZha2F0YS5kbmQuc2V0dGluZ3Muc2Nyb2xsX3Byb3hpbWl0eSlcdHsgdmFrYXRhX2RuZC5zY3JvbGxfdCA9IDE7IH1cblx0XHRcdFx0XHRpZihkdyA+IHd3ICYmIGUucGFnZVggLSBkbCA8ICQudmFrYXRhLmRuZC5zZXR0aW5ncy5zY3JvbGxfcHJveGltaXR5KVx0XHR7IHZha2F0YV9kbmQuc2Nyb2xsX2wgPSAtMTsgfVxuXHRcdFx0XHRcdGlmKGR3ID4gd3cgJiYgd3cgLSAoZS5wYWdlWCAtIGRsKSA8ICQudmFrYXRhLmRuZC5zZXR0aW5ncy5zY3JvbGxfcHJveGltaXR5KVx0eyB2YWthdGFfZG5kLnNjcm9sbF9sID0gMTsgfVxuXHRcdFx0XHRcdGlmKHZha2F0YV9kbmQuc2Nyb2xsX3QgfHwgdmFrYXRhX2RuZC5zY3JvbGxfbCkge1xuXHRcdFx0XHRcdFx0dmFrYXRhX2RuZC5zY3JvbGxfZSA9IGQ7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdGlmKHZha2F0YV9kbmQuc2Nyb2xsX2UpIHsgJC52YWthdGEuZG5kLl9zY3JvbGwodHJ1ZSk7IH1cblxuXHRcdFx0XHRpZih2YWthdGFfZG5kLmhlbHBlcikge1xuXHRcdFx0XHRcdGh0ID0gcGFyc2VJbnQoZS5wYWdlWSArICQudmFrYXRhLmRuZC5zZXR0aW5ncy5oZWxwZXJfdG9wLCAxMCk7XG5cdFx0XHRcdFx0aGwgPSBwYXJzZUludChlLnBhZ2VYICsgJC52YWthdGEuZG5kLnNldHRpbmdzLmhlbHBlcl9sZWZ0LCAxMCk7XG5cdFx0XHRcdFx0aWYoZGggJiYgaHQgKyAyNSA+IGRoKSB7IGh0ID0gZGggLSA1MDsgfVxuXHRcdFx0XHRcdGlmKGR3ICYmIGhsICsgdmFrYXRhX2RuZC5oZWxwZXJfdyA+IGR3KSB7IGhsID0gZHcgLSAodmFrYXRhX2RuZC5oZWxwZXJfdyArIDIpOyB9XG5cdFx0XHRcdFx0dmFrYXRhX2RuZC5oZWxwZXIuY3NzKHtcblx0XHRcdFx0XHRcdGxlZnRcdDogaGwgKyBcInB4XCIsXG5cdFx0XHRcdFx0XHR0b3BcdFx0OiBodCArIFwicHhcIlxuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9XG5cdFx0XHRcdC8qKlxuXHRcdFx0XHQgKiB0cmlnZ2VyZWQgb24gdGhlIGRvY3VtZW50IHdoZW4gYSBkcmFnIGlzIGluIHByb2dyZXNzXG5cdFx0XHRcdCAqIEBldmVudFxuXHRcdFx0XHQgKiBAcGx1Z2luIGRuZFxuXHRcdFx0XHQgKiBAbmFtZSBkbmRfbW92ZS52YWthdGFcblx0XHRcdFx0ICogQHBhcmFtIHtNaXhlZH0gZGF0YSBhbnkgZGF0YSBzdXBwbGllZCB3aXRoIHRoZSBjYWxsIHRvICQudmFrYXRhLmRuZC5zdGFydFxuXHRcdFx0XHQgKiBAcGFyYW0ge0RPTX0gZWxlbWVudCB0aGUgRE9NIGVsZW1lbnQgYmVpbmcgZHJhZ2dlZFxuXHRcdFx0XHQgKiBAcGFyYW0ge2pRdWVyeX0gaGVscGVyIHRoZSBoZWxwZXIgc2hvd24gbmV4dCB0byB0aGUgbW91c2Vcblx0XHRcdFx0ICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IHRoZSBldmVudCB0aGF0IGNhdXNlZCB0aGlzIHRvIHRyaWdnZXIgKG1vc3QgbGlrZWx5IG1vdXNlbW92ZSlcblx0XHRcdFx0ICovXG5cdFx0XHRcdCQudmFrYXRhLmRuZC5fdHJpZ2dlcihcIm1vdmVcIiwgZSk7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH0sXG5cdFx0XHRzdG9wIDogZnVuY3Rpb24gKGUpIHtcblx0XHRcdFx0aWYoZS50eXBlID09PSBcInRvdWNoZW5kXCIgJiYgZS5vcmlnaW5hbEV2ZW50ICYmIGUub3JpZ2luYWxFdmVudC5jaGFuZ2VkVG91Y2hlcyAmJiBlLm9yaWdpbmFsRXZlbnQuY2hhbmdlZFRvdWNoZXNbMF0pIHtcblx0XHRcdFx0XHRlLnBhZ2VYID0gZS5vcmlnaW5hbEV2ZW50LmNoYW5nZWRUb3VjaGVzWzBdLnBhZ2VYO1xuXHRcdFx0XHRcdGUucGFnZVkgPSBlLm9yaWdpbmFsRXZlbnQuY2hhbmdlZFRvdWNoZXNbMF0ucGFnZVk7XG5cdFx0XHRcdFx0ZS50YXJnZXQgPSBkb2N1bWVudC5lbGVtZW50RnJvbVBvaW50KGUub3JpZ2luYWxFdmVudC5jaGFuZ2VkVG91Y2hlc1swXS5wYWdlWCAtIHdpbmRvdy5wYWdlWE9mZnNldCwgZS5vcmlnaW5hbEV2ZW50LmNoYW5nZWRUb3VjaGVzWzBdLnBhZ2VZIC0gd2luZG93LnBhZ2VZT2Zmc2V0KTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZih2YWthdGFfZG5kLmlzX2RyYWcpIHtcblx0XHRcdFx0XHQvKipcblx0XHRcdFx0XHQgKiB0cmlnZ2VyZWQgb24gdGhlIGRvY3VtZW50IHdoZW4gYSBkcmFnIHN0b3BzICh0aGUgZHJhZ2dlZCBlbGVtZW50IGlzIGRyb3BwZWQpXG5cdFx0XHRcdFx0ICogQGV2ZW50XG5cdFx0XHRcdFx0ICogQHBsdWdpbiBkbmRcblx0XHRcdFx0XHQgKiBAbmFtZSBkbmRfc3RvcC52YWthdGFcblx0XHRcdFx0XHQgKiBAcGFyYW0ge01peGVkfSBkYXRhIGFueSBkYXRhIHN1cHBsaWVkIHdpdGggdGhlIGNhbGwgdG8gJC52YWthdGEuZG5kLnN0YXJ0XG5cdFx0XHRcdFx0ICogQHBhcmFtIHtET019IGVsZW1lbnQgdGhlIERPTSBlbGVtZW50IGJlaW5nIGRyYWdnZWRcblx0XHRcdFx0XHQgKiBAcGFyYW0ge2pRdWVyeX0gaGVscGVyIHRoZSBoZWxwZXIgc2hvd24gbmV4dCB0byB0aGUgbW91c2Vcblx0XHRcdFx0XHQgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgdGhlIGV2ZW50IHRoYXQgY2F1c2VkIHRoZSBzdG9wXG5cdFx0XHRcdFx0ICovXG5cdFx0XHRcdFx0aWYgKGUudGFyZ2V0ICE9PSB2YWthdGFfZG5kLnRhcmdldCkge1xuXHRcdFx0XHRcdFx0JCh2YWthdGFfZG5kLnRhcmdldCkub2ZmKCdjbGljay52YWthdGEnKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0JC52YWthdGEuZG5kLl90cmlnZ2VyKFwic3RvcFwiLCBlKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRpZihlLnR5cGUgPT09IFwidG91Y2hlbmRcIiAmJiBlLnRhcmdldCA9PT0gdmFrYXRhX2RuZC50YXJnZXQpIHtcblx0XHRcdFx0XHRcdHZhciB0byA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkgeyAkKGUudGFyZ2V0KS5jbGljaygpOyB9LCAxMDApO1xuXHRcdFx0XHRcdFx0JChlLnRhcmdldCkub25lKCdjbGljaycsIGZ1bmN0aW9uKCkgeyBpZih0bykgeyBjbGVhclRpbWVvdXQodG8pOyB9IH0pO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHQkLnZha2F0YS5kbmQuX2NsZWFuKCk7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblx0XHR9O1xuXHR9KCQpKTtcblxuXHQvLyBpbmNsdWRlIHRoZSBkbmQgcGx1Z2luIGJ5IGRlZmF1bHRcblx0Ly8gJC5qc3RyZWUuZGVmYXVsdHMucGx1Z2lucy5wdXNoKFwiZG5kXCIpO1xuXG5cbi8qKlxuICogIyMjIE1hc3Nsb2FkIHBsdWdpblxuICpcbiAqIEFkZHMgbWFzc2xvYWQgZnVuY3Rpb25hbGl0eSB0byBqc1RyZWUsIHNvIHRoYXQgbXVsdGlwbGUgbm9kZXMgY2FuIGJlIGxvYWRlZCBpbiBhIHNpbmdsZSByZXF1ZXN0IChvbmx5IHVzZWZ1bCB3aXRoIGxhenkgbG9hZGluZykuXG4gKi9cblxuXHQvKipcblx0ICogbWFzc2xvYWQgY29uZmlndXJhdGlvblxuXHQgKlxuXHQgKiBJdCBpcyBwb3NzaWJsZSB0byBzZXQgdGhpcyB0byBhIHN0YW5kYXJkIGpRdWVyeS1saWtlIEFKQVggY29uZmlnLlxuXHQgKiBJbiBhZGRpdGlvbiB0byB0aGUgc3RhbmRhcmQgalF1ZXJ5IGFqYXggb3B0aW9ucyBoZXJlIHlvdSBjYW4gc3VwcGx5IGZ1bmN0aW9ucyBmb3IgYGRhdGFgIGFuZCBgdXJsYCwgdGhlIGZ1bmN0aW9ucyB3aWxsIGJlIHJ1biBpbiB0aGUgY3VycmVudCBpbnN0YW5jZSdzIHNjb3BlIGFuZCBhIHBhcmFtIHdpbGwgYmUgcGFzc2VkIGluZGljYXRpbmcgd2hpY2ggbm9kZSBJRHMgbmVlZCB0byBiZSBsb2FkZWQsIHRoZSByZXR1cm4gdmFsdWUgb2YgdGhvc2UgZnVuY3Rpb25zIHdpbGwgYmUgdXNlZC5cblx0ICpcblx0ICogWW91IGNhbiBhbHNvIHNldCB0aGlzIHRvIGEgZnVuY3Rpb24sIHRoYXQgZnVuY3Rpb24gd2lsbCByZWNlaXZlIHRoZSBub2RlIElEcyBiZWluZyBsb2FkZWQgYXMgYXJndW1lbnQgYW5kIGEgc2Vjb25kIHBhcmFtIHdoaWNoIGlzIGEgZnVuY3Rpb24gKGNhbGxiYWNrKSB3aGljaCBzaG91bGQgYmUgY2FsbGVkIHdpdGggdGhlIHJlc3VsdC5cblx0ICpcblx0ICogQm90aCB0aGUgQUpBWCBhbmQgdGhlIGZ1bmN0aW9uIGFwcHJvYWNoIHJlbHkgb24gdGhlIHNhbWUgcmV0dXJuIHZhbHVlIC0gYW4gb2JqZWN0IHdoZXJlIHRoZSBrZXlzIGFyZSB0aGUgbm9kZSBJRHMsIGFuZCB0aGUgdmFsdWUgaXMgdGhlIGNoaWxkcmVuIG9mIHRoYXQgbm9kZSBhcyBhbiBhcnJheS5cblx0ICpcblx0ICpcdHtcblx0ICpcdFx0XCJpZDFcIiA6IFt7IFwidGV4dFwiIDogXCJDaGlsZCBvZiBJRDFcIiwgXCJpZFwiIDogXCJjMVwiIH0sIHsgXCJ0ZXh0XCIgOiBcIkFub3RoZXIgY2hpbGQgb2YgSUQxXCIsIFwiaWRcIiA6IFwiYzJcIiB9XSxcblx0ICpcdFx0XCJpZDJcIiA6IFt7IFwidGV4dFwiIDogXCJDaGlsZCBvZiBJRDJcIiwgXCJpZFwiIDogXCJjM1wiIH1dXG5cdCAqXHR9XG5cdCAqIFxuXHQgKiBAbmFtZSAkLmpzdHJlZS5kZWZhdWx0cy5tYXNzbG9hZFxuXHQgKiBAcGx1Z2luIG1hc3Nsb2FkXG5cdCAqL1xuXHQkLmpzdHJlZS5kZWZhdWx0cy5tYXNzbG9hZCA9IG51bGw7XG5cdCQuanN0cmVlLnBsdWdpbnMubWFzc2xvYWQgPSBmdW5jdGlvbiAob3B0aW9ucywgcGFyZW50KSB7XG5cdFx0dGhpcy5pbml0ID0gZnVuY3Rpb24gKGVsLCBvcHRpb25zKSB7XG5cdFx0XHR0aGlzLl9kYXRhLm1hc3Nsb2FkID0ge307XG5cdFx0XHRwYXJlbnQuaW5pdC5jYWxsKHRoaXMsIGVsLCBvcHRpb25zKTtcblx0XHR9O1xuXHRcdHRoaXMuX2xvYWRfbm9kZXMgPSBmdW5jdGlvbiAobm9kZXMsIGNhbGxiYWNrLCBpc19jYWxsYmFjaywgZm9yY2VfcmVsb2FkKSB7XG5cdFx0XHR2YXIgcyA9IHRoaXMuc2V0dGluZ3MubWFzc2xvYWQsXG5cdFx0XHRcdG5vZGVzU3RyaW5nID0gSlNPTi5zdHJpbmdpZnkobm9kZXMpLFxuXHRcdFx0XHR0b0xvYWQgPSBbXSxcblx0XHRcdFx0bSA9IHRoaXMuX21vZGVsLmRhdGEsXG5cdFx0XHRcdGksIGosIGRvbTtcblx0XHRcdGlmICghaXNfY2FsbGJhY2spIHtcblx0XHRcdFx0Zm9yKGkgPSAwLCBqID0gbm9kZXMubGVuZ3RoOyBpIDwgajsgaSsrKSB7XG5cdFx0XHRcdFx0aWYoIW1bbm9kZXNbaV1dIHx8ICggKCFtW25vZGVzW2ldXS5zdGF0ZS5sb2FkZWQgJiYgIW1bbm9kZXNbaV1dLnN0YXRlLmZhaWxlZCkgfHwgZm9yY2VfcmVsb2FkKSApIHtcblx0XHRcdFx0XHRcdHRvTG9hZC5wdXNoKG5vZGVzW2ldKTtcblx0XHRcdFx0XHRcdGRvbSA9IHRoaXMuZ2V0X25vZGUobm9kZXNbaV0sIHRydWUpO1xuXHRcdFx0XHRcdFx0aWYgKGRvbSAmJiBkb20ubGVuZ3RoKSB7XG5cdFx0XHRcdFx0XHRcdGRvbS5hZGRDbGFzcyhcImpzdHJlZS1sb2FkaW5nXCIpLmF0dHIoJ2FyaWEtYnVzeScsdHJ1ZSk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdHRoaXMuX2RhdGEubWFzc2xvYWQgPSB7fTtcblx0XHRcdFx0aWYgKHRvTG9hZC5sZW5ndGgpIHtcblx0XHRcdFx0XHRpZigkLmlzRnVuY3Rpb24ocykpIHtcblx0XHRcdFx0XHRcdHJldHVybiBzLmNhbGwodGhpcywgdG9Mb2FkLCAkLnByb3h5KGZ1bmN0aW9uIChkYXRhKSB7XG5cdFx0XHRcdFx0XHRcdHZhciBpLCBqO1xuXHRcdFx0XHRcdFx0XHRpZihkYXRhKSB7XG5cdFx0XHRcdFx0XHRcdFx0Zm9yKGkgaW4gZGF0YSkge1xuXHRcdFx0XHRcdFx0XHRcdFx0aWYoZGF0YS5oYXNPd25Qcm9wZXJ0eShpKSkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0aGlzLl9kYXRhLm1hc3Nsb2FkW2ldID0gZGF0YVtpXTtcblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0Zm9yKGkgPSAwLCBqID0gbm9kZXMubGVuZ3RoOyBpIDwgajsgaSsrKSB7XG5cdFx0XHRcdFx0XHRcdFx0ZG9tID0gdGhpcy5nZXRfbm9kZShub2Rlc1tpXSwgdHJ1ZSk7XG5cdFx0XHRcdFx0XHRcdFx0aWYgKGRvbSAmJiBkb20ubGVuZ3RoKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRkb20ucmVtb3ZlQ2xhc3MoXCJqc3RyZWUtbG9hZGluZ1wiKS5hdHRyKCdhcmlhLWJ1c3knLGZhbHNlKTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0cGFyZW50Ll9sb2FkX25vZGVzLmNhbGwodGhpcywgbm9kZXMsIGNhbGxiYWNrLCBpc19jYWxsYmFjaywgZm9yY2VfcmVsb2FkKTtcblx0XHRcdFx0XHRcdH0sIHRoaXMpKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYodHlwZW9mIHMgPT09ICdvYmplY3QnICYmIHMgJiYgcy51cmwpIHtcblx0XHRcdFx0XHRcdHMgPSAkLmV4dGVuZCh0cnVlLCB7fSwgcyk7XG5cdFx0XHRcdFx0XHRpZigkLmlzRnVuY3Rpb24ocy51cmwpKSB7XG5cdFx0XHRcdFx0XHRcdHMudXJsID0gcy51cmwuY2FsbCh0aGlzLCB0b0xvYWQpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0aWYoJC5pc0Z1bmN0aW9uKHMuZGF0YSkpIHtcblx0XHRcdFx0XHRcdFx0cy5kYXRhID0gcy5kYXRhLmNhbGwodGhpcywgdG9Mb2FkKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdHJldHVybiAkLmFqYXgocylcblx0XHRcdFx0XHRcdFx0LmRvbmUoJC5wcm94eShmdW5jdGlvbiAoZGF0YSx0LHgpIHtcblx0XHRcdFx0XHRcdFx0XHRcdHZhciBpLCBqO1xuXHRcdFx0XHRcdFx0XHRcdFx0aWYoZGF0YSkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRmb3IoaSBpbiBkYXRhKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0aWYoZGF0YS5oYXNPd25Qcm9wZXJ0eShpKSkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0dGhpcy5fZGF0YS5tYXNzbG9hZFtpXSA9IGRhdGFbaV07XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHRmb3IoaSA9IDAsIGogPSBub2Rlcy5sZW5ndGg7IGkgPCBqOyBpKyspIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0ZG9tID0gdGhpcy5nZXRfbm9kZShub2Rlc1tpXSwgdHJ1ZSk7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlmIChkb20gJiYgZG9tLmxlbmd0aCkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGRvbS5yZW1vdmVDbGFzcyhcImpzdHJlZS1sb2FkaW5nXCIpLmF0dHIoJ2FyaWEtYnVzeScsZmFsc2UpO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHRwYXJlbnQuX2xvYWRfbm9kZXMuY2FsbCh0aGlzLCBub2RlcywgY2FsbGJhY2ssIGlzX2NhbGxiYWNrLCBmb3JjZV9yZWxvYWQpO1xuXHRcdFx0XHRcdFx0XHRcdH0sIHRoaXMpKVxuXHRcdFx0XHRcdFx0XHQuZmFpbCgkLnByb3h5KGZ1bmN0aW9uIChmKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRwYXJlbnQuX2xvYWRfbm9kZXMuY2FsbCh0aGlzLCBub2RlcywgY2FsbGJhY2ssIGlzX2NhbGxiYWNrLCBmb3JjZV9yZWxvYWQpO1xuXHRcdFx0XHRcdFx0XHRcdH0sIHRoaXMpKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiBwYXJlbnQuX2xvYWRfbm9kZXMuY2FsbCh0aGlzLCBub2RlcywgY2FsbGJhY2ssIGlzX2NhbGxiYWNrLCBmb3JjZV9yZWxvYWQpO1xuXHRcdH07XG5cdFx0dGhpcy5fbG9hZF9ub2RlID0gZnVuY3Rpb24gKG9iaiwgY2FsbGJhY2spIHtcblx0XHRcdHZhciBkYXRhID0gdGhpcy5fZGF0YS5tYXNzbG9hZFtvYmouaWRdLFxuXHRcdFx0XHRyc2x0ID0gbnVsbCwgZG9tO1xuXHRcdFx0aWYoZGF0YSkge1xuXHRcdFx0XHRyc2x0ID0gdGhpc1t0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZycgPyAnX2FwcGVuZF9odG1sX2RhdGEnIDogJ19hcHBlbmRfanNvbl9kYXRhJ10oXG5cdFx0XHRcdFx0b2JqLFxuXHRcdFx0XHRcdHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJyA/ICQoJC5wYXJzZUhUTUwoZGF0YSkpLmZpbHRlcihmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLm5vZGVUeXBlICE9PSAzOyB9KSA6IGRhdGEsXG5cdFx0XHRcdFx0ZnVuY3Rpb24gKHN0YXR1cykgeyBjYWxsYmFjay5jYWxsKHRoaXMsIHN0YXR1cyk7IH1cblx0XHRcdFx0KTtcblx0XHRcdFx0ZG9tID0gdGhpcy5nZXRfbm9kZShvYmouaWQsIHRydWUpO1xuXHRcdFx0XHRpZiAoZG9tICYmIGRvbS5sZW5ndGgpIHtcblx0XHRcdFx0XHRkb20ucmVtb3ZlQ2xhc3MoXCJqc3RyZWUtbG9hZGluZ1wiKS5hdHRyKCdhcmlhLWJ1c3knLGZhbHNlKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRkZWxldGUgdGhpcy5fZGF0YS5tYXNzbG9hZFtvYmouaWRdO1xuXHRcdFx0XHRyZXR1cm4gcnNsdDtcblx0XHRcdH1cblx0XHRcdHJldHVybiBwYXJlbnQuX2xvYWRfbm9kZS5jYWxsKHRoaXMsIG9iaiwgY2FsbGJhY2spO1xuXHRcdH07XG5cdH07XG5cbi8qKlxuICogIyMjIFNlYXJjaCBwbHVnaW5cbiAqXG4gKiBBZGRzIHNlYXJjaCBmdW5jdGlvbmFsaXR5IHRvIGpzVHJlZS5cbiAqL1xuXG5cdC8qKlxuXHQgKiBzdG9yZXMgYWxsIGRlZmF1bHRzIGZvciB0aGUgc2VhcmNoIHBsdWdpblxuXHQgKiBAbmFtZSAkLmpzdHJlZS5kZWZhdWx0cy5zZWFyY2hcblx0ICogQHBsdWdpbiBzZWFyY2hcblx0ICovXG5cdCQuanN0cmVlLmRlZmF1bHRzLnNlYXJjaCA9IHtcblx0XHQvKipcblx0XHQgKiBhIGpRdWVyeS1saWtlIEFKQVggY29uZmlnLCB3aGljaCBqc3RyZWUgdXNlcyBpZiBhIHNlcnZlciBzaG91bGQgYmUgcXVlcmllZCBmb3IgcmVzdWx0cy5cblx0XHQgKlxuXHRcdCAqIEEgYHN0cmAgKHdoaWNoIGlzIHRoZSBzZWFyY2ggc3RyaW5nKSBwYXJhbWV0ZXIgd2lsbCBiZSBhZGRlZCB3aXRoIHRoZSByZXF1ZXN0LCBhbiBvcHRpb25hbCBgaW5zaWRlYCBwYXJhbWV0ZXIgd2lsbCBiZSBhZGRlZCBpZiB0aGUgc2VhcmNoIGlzIGxpbWl0ZWQgdG8gYSBub2RlIGlkLiBUaGUgZXhwZWN0ZWQgcmVzdWx0IGlzIGEgSlNPTiBhcnJheSB3aXRoIG5vZGVzIHRoYXQgbmVlZCB0byBiZSBvcGVuZWQgc28gdGhhdCBtYXRjaGluZyBub2RlcyB3aWxsIGJlIHJldmVhbGVkLlxuXHRcdCAqIExlYXZlIHRoaXMgc2V0dGluZyBhcyBgZmFsc2VgIHRvIG5vdCBxdWVyeSB0aGUgc2VydmVyLiBZb3UgY2FuIGFsc28gc2V0IHRoaXMgdG8gYSBmdW5jdGlvbiwgd2hpY2ggd2lsbCBiZSBpbnZva2VkIGluIHRoZSBpbnN0YW5jZSdzIHNjb3BlIGFuZCByZWNlaXZlIDMgcGFyYW1ldGVycyAtIHRoZSBzZWFyY2ggc3RyaW5nLCB0aGUgY2FsbGJhY2sgdG8gY2FsbCB3aXRoIHRoZSBhcnJheSBvZiBub2RlcyB0byBsb2FkLCBhbmQgdGhlIG9wdGlvbmFsIG5vZGUgSUQgdG8gbGltaXQgdGhlIHNlYXJjaCB0b1xuXHRcdCAqIEBuYW1lICQuanN0cmVlLmRlZmF1bHRzLnNlYXJjaC5hamF4XG5cdFx0ICogQHBsdWdpbiBzZWFyY2hcblx0XHQgKi9cblx0XHRhamF4IDogZmFsc2UsXG5cdFx0LyoqXG5cdFx0ICogSW5kaWNhdGVzIGlmIHRoZSBzZWFyY2ggc2hvdWxkIGJlIGZ1enp5IG9yIG5vdCAoc2hvdWxkIGBjaG5kM2AgbWF0Y2ggYGNoaWxkIG5vZGUgM2ApLiBEZWZhdWx0IGlzIGBmYWxzZWAuXG5cdFx0ICogQG5hbWUgJC5qc3RyZWUuZGVmYXVsdHMuc2VhcmNoLmZ1enp5XG5cdFx0ICogQHBsdWdpbiBzZWFyY2hcblx0XHQgKi9cblx0XHRmdXp6eSA6IGZhbHNlLFxuXHRcdC8qKlxuXHRcdCAqIEluZGljYXRlcyBpZiB0aGUgc2VhcmNoIHNob3VsZCBiZSBjYXNlIHNlbnNpdGl2ZS4gRGVmYXVsdCBpcyBgZmFsc2VgLlxuXHRcdCAqIEBuYW1lICQuanN0cmVlLmRlZmF1bHRzLnNlYXJjaC5jYXNlX3NlbnNpdGl2ZVxuXHRcdCAqIEBwbHVnaW4gc2VhcmNoXG5cdFx0ICovXG5cdFx0Y2FzZV9zZW5zaXRpdmUgOiBmYWxzZSxcblx0XHQvKipcblx0XHQgKiBJbmRpY2F0ZXMgaWYgdGhlIHRyZWUgc2hvdWxkIGJlIGZpbHRlcmVkIChieSBkZWZhdWx0KSB0byBzaG93IG9ubHkgbWF0Y2hpbmcgbm9kZXMgKGtlZXAgaW4gbWluZCB0aGlzIGNhbiBiZSBhIGhlYXZ5IG9uIGxhcmdlIHRyZWVzIGluIG9sZCBicm93c2VycykuXG5cdFx0ICogVGhpcyBzZXR0aW5nIGNhbiBiZSBjaGFuZ2VkIGF0IHJ1bnRpbWUgd2hlbiBjYWxsaW5nIHRoZSBzZWFyY2ggbWV0aG9kLiBEZWZhdWx0IGlzIGBmYWxzZWAuXG5cdFx0ICogQG5hbWUgJC5qc3RyZWUuZGVmYXVsdHMuc2VhcmNoLnNob3dfb25seV9tYXRjaGVzXG5cdFx0ICogQHBsdWdpbiBzZWFyY2hcblx0XHQgKi9cblx0XHRzaG93X29ubHlfbWF0Y2hlcyA6IGZhbHNlLFxuXHRcdC8qKlxuXHRcdCAqIEluZGljYXRlcyBpZiB0aGUgY2hpbGRyZW4gb2YgbWF0Y2hlZCBlbGVtZW50IGFyZSBzaG93biAod2hlbiBzaG93X29ubHlfbWF0Y2hlcyBpcyB0cnVlKVxuXHRcdCAqIFRoaXMgc2V0dGluZyBjYW4gYmUgY2hhbmdlZCBhdCBydW50aW1lIHdoZW4gY2FsbGluZyB0aGUgc2VhcmNoIG1ldGhvZC4gRGVmYXVsdCBpcyBgZmFsc2VgLlxuXHRcdCAqIEBuYW1lICQuanN0cmVlLmRlZmF1bHRzLnNlYXJjaC5zaG93X29ubHlfbWF0Y2hlc19jaGlsZHJlblxuXHRcdCAqIEBwbHVnaW4gc2VhcmNoXG5cdFx0ICovXG5cdFx0c2hvd19vbmx5X21hdGNoZXNfY2hpbGRyZW4gOiBmYWxzZSxcblx0XHQvKipcblx0XHQgKiBJbmRpY2F0ZXMgaWYgYWxsIG5vZGVzIG9wZW5lZCB0byByZXZlYWwgdGhlIHNlYXJjaCByZXN1bHQsIHNob3VsZCBiZSBjbG9zZWQgd2hlbiB0aGUgc2VhcmNoIGlzIGNsZWFyZWQgb3IgYSBuZXcgc2VhcmNoIGlzIHBlcmZvcm1lZC4gRGVmYXVsdCBpcyBgdHJ1ZWAuXG5cdFx0ICogQG5hbWUgJC5qc3RyZWUuZGVmYXVsdHMuc2VhcmNoLmNsb3NlX29wZW5lZF9vbmNsZWFyXG5cdFx0ICogQHBsdWdpbiBzZWFyY2hcblx0XHQgKi9cblx0XHRjbG9zZV9vcGVuZWRfb25jbGVhciA6IHRydWUsXG5cdFx0LyoqXG5cdFx0ICogSW5kaWNhdGVzIGlmIG9ubHkgbGVhZiBub2RlcyBzaG91bGQgYmUgaW5jbHVkZWQgaW4gc2VhcmNoIHJlc3VsdHMuIERlZmF1bHQgaXMgYGZhbHNlYC5cblx0XHQgKiBAbmFtZSAkLmpzdHJlZS5kZWZhdWx0cy5zZWFyY2guc2VhcmNoX2xlYXZlc19vbmx5XG5cdFx0ICogQHBsdWdpbiBzZWFyY2hcblx0XHQgKi9cblx0XHRzZWFyY2hfbGVhdmVzX29ubHkgOiBmYWxzZSxcblx0XHQvKipcblx0XHQgKiBJZiBzZXQgdG8gYSBmdW5jdGlvbiBpdCB3aWwgYmUgY2FsbGVkIGluIHRoZSBpbnN0YW5jZSdzIHNjb3BlIHdpdGggdHdvIGFyZ3VtZW50cyAtIHNlYXJjaCBzdHJpbmcgYW5kIG5vZGUgKHdoZXJlIG5vZGUgd2lsbCBiZSBldmVyeSBub2RlIGluIHRoZSBzdHJ1Y3R1cmUsIHNvIHVzZSB3aXRoIGNhdXRpb24pLlxuXHRcdCAqIElmIHRoZSBmdW5jdGlvbiByZXR1cm5zIGEgdHJ1dGh5IHZhbHVlIHRoZSBub2RlIHdpbGwgYmUgY29uc2lkZXJlZCBhIG1hdGNoIChpdCBtaWdodCBub3QgYmUgZGlzcGxheWVkIGlmIHNlYXJjaF9vbmx5X2xlYXZlcyBpcyBzZXQgdG8gdHJ1ZSBhbmQgdGhlIG5vZGUgaXMgbm90IGEgbGVhZikuIERlZmF1bHQgaXMgYGZhbHNlYC5cblx0XHQgKiBAbmFtZSAkLmpzdHJlZS5kZWZhdWx0cy5zZWFyY2guc2VhcmNoX2NhbGxiYWNrXG5cdFx0ICogQHBsdWdpbiBzZWFyY2hcblx0XHQgKi9cblx0XHRzZWFyY2hfY2FsbGJhY2sgOiBmYWxzZVxuXHR9O1xuXG5cdCQuanN0cmVlLnBsdWdpbnMuc2VhcmNoID0gZnVuY3Rpb24gKG9wdGlvbnMsIHBhcmVudCkge1xuXHRcdHRoaXMuYmluZCA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdHBhcmVudC5iaW5kLmNhbGwodGhpcyk7XG5cblx0XHRcdHRoaXMuX2RhdGEuc2VhcmNoLnN0ciA9IFwiXCI7XG5cdFx0XHR0aGlzLl9kYXRhLnNlYXJjaC5kb20gPSAkKCk7XG5cdFx0XHR0aGlzLl9kYXRhLnNlYXJjaC5yZXMgPSBbXTtcblx0XHRcdHRoaXMuX2RhdGEuc2VhcmNoLm9wbiA9IFtdO1xuXHRcdFx0dGhpcy5fZGF0YS5zZWFyY2guc29tID0gZmFsc2U7XG5cdFx0XHR0aGlzLl9kYXRhLnNlYXJjaC5zbWMgPSBmYWxzZTtcblx0XHRcdHRoaXMuX2RhdGEuc2VhcmNoLmhkbiA9IFtdO1xuXG5cdFx0XHR0aGlzLmVsZW1lbnRcblx0XHRcdFx0Lm9uKFwic2VhcmNoLmpzdHJlZVwiLCAkLnByb3h5KGZ1bmN0aW9uIChlLCBkYXRhKSB7XG5cdFx0XHRcdFx0XHRpZih0aGlzLl9kYXRhLnNlYXJjaC5zb20gJiYgZGF0YS5yZXMubGVuZ3RoKSB7XG5cdFx0XHRcdFx0XHRcdHZhciBtID0gdGhpcy5fbW9kZWwuZGF0YSwgaSwgaiwgcCA9IFtdLCBrLCBsO1xuXHRcdFx0XHRcdFx0XHRmb3IoaSA9IDAsIGogPSBkYXRhLnJlcy5sZW5ndGg7IGkgPCBqOyBpKyspIHtcblx0XHRcdFx0XHRcdFx0XHRpZihtW2RhdGEucmVzW2ldXSAmJiAhbVtkYXRhLnJlc1tpXV0uc3RhdGUuaGlkZGVuKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRwLnB1c2goZGF0YS5yZXNbaV0pO1xuXHRcdFx0XHRcdFx0XHRcdFx0cCA9IHAuY29uY2F0KG1bZGF0YS5yZXNbaV1dLnBhcmVudHMpO1xuXHRcdFx0XHRcdFx0XHRcdFx0aWYodGhpcy5fZGF0YS5zZWFyY2guc21jKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGZvciAoayA9IDAsIGwgPSBtW2RhdGEucmVzW2ldXS5jaGlsZHJlbl9kLmxlbmd0aDsgayA8IGw7IGsrKykge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGlmIChtW21bZGF0YS5yZXNbaV1dLmNoaWxkcmVuX2Rba11dICYmICFtW21bZGF0YS5yZXNbaV1dLmNoaWxkcmVuX2Rba11dLnN0YXRlLmhpZGRlbikge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0cC5wdXNoKG1bZGF0YS5yZXNbaV1dLmNoaWxkcmVuX2Rba10pO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRwID0gJC52YWthdGEuYXJyYXlfcmVtb3ZlX2l0ZW0oJC52YWthdGEuYXJyYXlfdW5pcXVlKHApLCAkLmpzdHJlZS5yb290KTtcblx0XHRcdFx0XHRcdFx0dGhpcy5fZGF0YS5zZWFyY2guaGRuID0gdGhpcy5oaWRlX2FsbCh0cnVlKTtcblx0XHRcdFx0XHRcdFx0dGhpcy5zaG93X25vZGUocCwgdHJ1ZSk7XG5cdFx0XHRcdFx0XHRcdHRoaXMucmVkcmF3KHRydWUpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0sIHRoaXMpKVxuXHRcdFx0XHQub24oXCJjbGVhcl9zZWFyY2guanN0cmVlXCIsICQucHJveHkoZnVuY3Rpb24gKGUsIGRhdGEpIHtcblx0XHRcdFx0XHRcdGlmKHRoaXMuX2RhdGEuc2VhcmNoLnNvbSAmJiBkYXRhLnJlcy5sZW5ndGgpIHtcblx0XHRcdFx0XHRcdFx0dGhpcy5zaG93X25vZGUodGhpcy5fZGF0YS5zZWFyY2guaGRuLCB0cnVlKTtcblx0XHRcdFx0XHRcdFx0dGhpcy5yZWRyYXcodHJ1ZSk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSwgdGhpcykpO1xuXHRcdH07XG5cdFx0LyoqXG5cdFx0ICogdXNlZCB0byBzZWFyY2ggdGhlIHRyZWUgbm9kZXMgZm9yIGEgZ2l2ZW4gc3RyaW5nXG5cdFx0ICogQG5hbWUgc2VhcmNoKHN0ciBbLCBza2lwX2FzeW5jXSlcblx0XHQgKiBAcGFyYW0ge1N0cmluZ30gc3RyIHRoZSBzZWFyY2ggc3RyaW5nXG5cdFx0ICogQHBhcmFtIHtCb29sZWFufSBza2lwX2FzeW5jIGlmIHNldCB0byB0cnVlIHNlcnZlciB3aWxsIG5vdCBiZSBxdWVyaWVkIGV2ZW4gaWYgY29uZmlndXJlZFxuXHRcdCAqIEBwYXJhbSB7Qm9vbGVhbn0gc2hvd19vbmx5X21hdGNoZXMgaWYgc2V0IHRvIHRydWUgb25seSBtYXRjaGluZyBub2RlcyB3aWxsIGJlIHNob3duIChrZWVwIGluIG1pbmQgdGhpcyBjYW4gYmUgdmVyeSBzbG93IG9uIGxhcmdlIHRyZWVzIG9yIG9sZCBicm93c2Vycylcblx0XHQgKiBAcGFyYW0ge21peGVkfSBpbnNpZGUgYW4gb3B0aW9uYWwgbm9kZSB0byB3aG9zZSBjaGlsZHJlbiB0byBsaW1pdCB0aGUgc2VhcmNoXG5cdFx0ICogQHBhcmFtIHtCb29sZWFufSBhcHBlbmQgaWYgc2V0IHRvIHRydWUgdGhlIHJlc3VsdHMgb2YgdGhpcyBzZWFyY2ggYXJlIGFwcGVuZGVkIHRvIHRoZSBwcmV2aW91cyBzZWFyY2hcblx0XHQgKiBAcGx1Z2luIHNlYXJjaFxuXHRcdCAqIEB0cmlnZ2VyIHNlYXJjaC5qc3RyZWVcblx0XHQgKi9cblx0XHR0aGlzLnNlYXJjaCA9IGZ1bmN0aW9uIChzdHIsIHNraXBfYXN5bmMsIHNob3dfb25seV9tYXRjaGVzLCBpbnNpZGUsIGFwcGVuZCwgc2hvd19vbmx5X21hdGNoZXNfY2hpbGRyZW4pIHtcblx0XHRcdGlmKHN0ciA9PT0gZmFsc2UgfHwgJC50cmltKHN0ci50b1N0cmluZygpKSA9PT0gXCJcIikge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5jbGVhcl9zZWFyY2goKTtcblx0XHRcdH1cblx0XHRcdGluc2lkZSA9IHRoaXMuZ2V0X25vZGUoaW5zaWRlKTtcblx0XHRcdGluc2lkZSA9IGluc2lkZSAmJiBpbnNpZGUuaWQgPyBpbnNpZGUuaWQgOiBudWxsO1xuXHRcdFx0c3RyID0gc3RyLnRvU3RyaW5nKCk7XG5cdFx0XHR2YXIgcyA9IHRoaXMuc2V0dGluZ3Muc2VhcmNoLFxuXHRcdFx0XHRhID0gcy5hamF4ID8gcy5hamF4IDogZmFsc2UsXG5cdFx0XHRcdG0gPSB0aGlzLl9tb2RlbC5kYXRhLFxuXHRcdFx0XHRmID0gbnVsbCxcblx0XHRcdFx0ciA9IFtdLFxuXHRcdFx0XHRwID0gW10sIGksIGo7XG5cdFx0XHRpZih0aGlzLl9kYXRhLnNlYXJjaC5yZXMubGVuZ3RoICYmICFhcHBlbmQpIHtcblx0XHRcdFx0dGhpcy5jbGVhcl9zZWFyY2goKTtcblx0XHRcdH1cblx0XHRcdGlmKHNob3dfb25seV9tYXRjaGVzID09PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0c2hvd19vbmx5X21hdGNoZXMgPSBzLnNob3dfb25seV9tYXRjaGVzO1xuXHRcdFx0fVxuXHRcdFx0aWYoc2hvd19vbmx5X21hdGNoZXNfY2hpbGRyZW4gPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRzaG93X29ubHlfbWF0Y2hlc19jaGlsZHJlbiA9IHMuc2hvd19vbmx5X21hdGNoZXNfY2hpbGRyZW47XG5cdFx0XHR9XG5cdFx0XHRpZighc2tpcF9hc3luYyAmJiBhICE9PSBmYWxzZSkge1xuXHRcdFx0XHRpZigkLmlzRnVuY3Rpb24oYSkpIHtcblx0XHRcdFx0XHRyZXR1cm4gYS5jYWxsKHRoaXMsIHN0ciwgJC5wcm94eShmdW5jdGlvbiAoZCkge1xuXHRcdFx0XHRcdFx0XHRpZihkICYmIGQuZCkgeyBkID0gZC5kOyB9XG5cdFx0XHRcdFx0XHRcdHRoaXMuX2xvYWRfbm9kZXMoISQuaXNBcnJheShkKSA/IFtdIDogJC52YWthdGEuYXJyYXlfdW5pcXVlKGQpLCBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdFx0XHRcdFx0dGhpcy5zZWFyY2goc3RyLCB0cnVlLCBzaG93X29ubHlfbWF0Y2hlcywgaW5zaWRlLCBhcHBlbmQsIHNob3dfb25seV9tYXRjaGVzX2NoaWxkcmVuKTtcblx0XHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0XHR9LCB0aGlzKSwgaW5zaWRlKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRhID0gJC5leHRlbmQoe30sIGEpO1xuXHRcdFx0XHRcdGlmKCFhLmRhdGEpIHsgYS5kYXRhID0ge307IH1cblx0XHRcdFx0XHRhLmRhdGEuc3RyID0gc3RyO1xuXHRcdFx0XHRcdGlmKGluc2lkZSkge1xuXHRcdFx0XHRcdFx0YS5kYXRhLmluc2lkZSA9IGluc2lkZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKHRoaXMuX2RhdGEuc2VhcmNoLmxhc3RSZXF1ZXN0KSB7XG5cdFx0XHRcdFx0XHR0aGlzLl9kYXRhLnNlYXJjaC5sYXN0UmVxdWVzdC5hYm9ydCgpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHR0aGlzLl9kYXRhLnNlYXJjaC5sYXN0UmVxdWVzdCA9ICQuYWpheChhKVxuXHRcdFx0XHRcdFx0LmZhaWwoJC5wcm94eShmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdFx0XHRcdHRoaXMuX2RhdGEuY29yZS5sYXN0X2Vycm9yID0geyAnZXJyb3InIDogJ2FqYXgnLCAncGx1Z2luJyA6ICdzZWFyY2gnLCAnaWQnIDogJ3NlYXJjaF8wMScsICdyZWFzb24nIDogJ0NvdWxkIG5vdCBsb2FkIHNlYXJjaCBwYXJlbnRzJywgJ2RhdGEnIDogSlNPTi5zdHJpbmdpZnkoYSkgfTtcblx0XHRcdFx0XHRcdFx0dGhpcy5zZXR0aW5ncy5jb3JlLmVycm9yLmNhbGwodGhpcywgdGhpcy5fZGF0YS5jb3JlLmxhc3RfZXJyb3IpO1xuXHRcdFx0XHRcdFx0fSwgdGhpcykpXG5cdFx0XHRcdFx0XHQuZG9uZSgkLnByb3h5KGZ1bmN0aW9uIChkKSB7XG5cdFx0XHRcdFx0XHRcdGlmKGQgJiYgZC5kKSB7IGQgPSBkLmQ7IH1cblx0XHRcdFx0XHRcdFx0dGhpcy5fbG9hZF9ub2RlcyghJC5pc0FycmF5KGQpID8gW10gOiAkLnZha2F0YS5hcnJheV91bmlxdWUoZCksIGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0XHRcdFx0XHR0aGlzLnNlYXJjaChzdHIsIHRydWUsIHNob3dfb25seV9tYXRjaGVzLCBpbnNpZGUsIGFwcGVuZCwgc2hvd19vbmx5X21hdGNoZXNfY2hpbGRyZW4pO1xuXHRcdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRcdH0sIHRoaXMpKTtcblx0XHRcdFx0XHRyZXR1cm4gdGhpcy5fZGF0YS5zZWFyY2gubGFzdFJlcXVlc3Q7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGlmKCFhcHBlbmQpIHtcblx0XHRcdFx0dGhpcy5fZGF0YS5zZWFyY2guc3RyID0gc3RyO1xuXHRcdFx0XHR0aGlzLl9kYXRhLnNlYXJjaC5kb20gPSAkKCk7XG5cdFx0XHRcdHRoaXMuX2RhdGEuc2VhcmNoLnJlcyA9IFtdO1xuXHRcdFx0XHR0aGlzLl9kYXRhLnNlYXJjaC5vcG4gPSBbXTtcblx0XHRcdFx0dGhpcy5fZGF0YS5zZWFyY2guc29tID0gc2hvd19vbmx5X21hdGNoZXM7XG5cdFx0XHRcdHRoaXMuX2RhdGEuc2VhcmNoLnNtYyA9IHNob3dfb25seV9tYXRjaGVzX2NoaWxkcmVuO1xuXHRcdFx0fVxuXG5cdFx0XHRmID0gbmV3ICQudmFrYXRhLnNlYXJjaChzdHIsIHRydWUsIHsgY2FzZVNlbnNpdGl2ZSA6IHMuY2FzZV9zZW5zaXRpdmUsIGZ1enp5IDogcy5mdXp6eSB9KTtcblx0XHRcdCQuZWFjaChtW2luc2lkZSA/IGluc2lkZSA6ICQuanN0cmVlLnJvb3RdLmNoaWxkcmVuX2QsIGZ1bmN0aW9uIChpaSwgaSkge1xuXHRcdFx0XHR2YXIgdiA9IG1baV07XG5cdFx0XHRcdGlmKHYudGV4dCAmJiAhdi5zdGF0ZS5oaWRkZW4gJiYgKCFzLnNlYXJjaF9sZWF2ZXNfb25seSB8fCAodi5zdGF0ZS5sb2FkZWQgJiYgdi5jaGlsZHJlbi5sZW5ndGggPT09IDApKSAmJiAoIChzLnNlYXJjaF9jYWxsYmFjayAmJiBzLnNlYXJjaF9jYWxsYmFjay5jYWxsKHRoaXMsIHN0ciwgdikpIHx8ICghcy5zZWFyY2hfY2FsbGJhY2sgJiYgZi5zZWFyY2godi50ZXh0KS5pc01hdGNoKSApICkge1xuXHRcdFx0XHRcdHIucHVzaChpKTtcblx0XHRcdFx0XHRwID0gcC5jb25jYXQodi5wYXJlbnRzKTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0XHRpZihyLmxlbmd0aCkge1xuXHRcdFx0XHRwID0gJC52YWthdGEuYXJyYXlfdW5pcXVlKHApO1xuXHRcdFx0XHRmb3IoaSA9IDAsIGogPSBwLmxlbmd0aDsgaSA8IGo7IGkrKykge1xuXHRcdFx0XHRcdGlmKHBbaV0gIT09ICQuanN0cmVlLnJvb3QgJiYgbVtwW2ldXSAmJiB0aGlzLm9wZW5fbm9kZShwW2ldLCBudWxsLCAwKSA9PT0gdHJ1ZSkge1xuXHRcdFx0XHRcdFx0dGhpcy5fZGF0YS5zZWFyY2gub3BuLnB1c2gocFtpXSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdGlmKCFhcHBlbmQpIHtcblx0XHRcdFx0XHR0aGlzLl9kYXRhLnNlYXJjaC5kb20gPSAkKHRoaXMuZWxlbWVudFswXS5xdWVyeVNlbGVjdG9yQWxsKCcjJyArICQubWFwKHIsIGZ1bmN0aW9uICh2KSB7IHJldHVybiBcIjAxMjM0NTY3ODlcIi5pbmRleE9mKHZbMF0pICE9PSAtMSA/ICdcXFxcMycgKyB2WzBdICsgJyAnICsgdi5zdWJzdHIoMSkucmVwbGFjZSgkLmpzdHJlZS5pZHJlZ2V4LCdcXFxcJCYnKSA6IHYucmVwbGFjZSgkLmpzdHJlZS5pZHJlZ2V4LCdcXFxcJCYnKTsgfSkuam9pbignLCAjJykpKTtcblx0XHRcdFx0XHR0aGlzLl9kYXRhLnNlYXJjaC5yZXMgPSByO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdHRoaXMuX2RhdGEuc2VhcmNoLmRvbSA9IHRoaXMuX2RhdGEuc2VhcmNoLmRvbS5hZGQoJCh0aGlzLmVsZW1lbnRbMF0ucXVlcnlTZWxlY3RvckFsbCgnIycgKyAkLm1hcChyLCBmdW5jdGlvbiAodikgeyByZXR1cm4gXCIwMTIzNDU2Nzg5XCIuaW5kZXhPZih2WzBdKSAhPT0gLTEgPyAnXFxcXDMnICsgdlswXSArICcgJyArIHYuc3Vic3RyKDEpLnJlcGxhY2UoJC5qc3RyZWUuaWRyZWdleCwnXFxcXCQmJykgOiB2LnJlcGxhY2UoJC5qc3RyZWUuaWRyZWdleCwnXFxcXCQmJyk7IH0pLmpvaW4oJywgIycpKSkpO1xuXHRcdFx0XHRcdHRoaXMuX2RhdGEuc2VhcmNoLnJlcyA9ICQudmFrYXRhLmFycmF5X3VuaXF1ZSh0aGlzLl9kYXRhLnNlYXJjaC5yZXMuY29uY2F0KHIpKTtcblx0XHRcdFx0fVxuXHRcdFx0XHR0aGlzLl9kYXRhLnNlYXJjaC5kb20uY2hpbGRyZW4oXCIuanN0cmVlLWFuY2hvclwiKS5hZGRDbGFzcygnanN0cmVlLXNlYXJjaCcpO1xuXHRcdFx0fVxuXHRcdFx0LyoqXG5cdFx0XHQgKiB0cmlnZ2VyZWQgYWZ0ZXIgc2VhcmNoIGlzIGNvbXBsZXRlXG5cdFx0XHQgKiBAZXZlbnRcblx0XHRcdCAqIEBuYW1lIHNlYXJjaC5qc3RyZWVcblx0XHRcdCAqIEBwYXJhbSB7alF1ZXJ5fSBub2RlcyBhIGpRdWVyeSBjb2xsZWN0aW9uIG9mIG1hdGNoaW5nIG5vZGVzXG5cdFx0XHQgKiBAcGFyYW0ge1N0cmluZ30gc3RyIHRoZSBzZWFyY2ggc3RyaW5nXG5cdFx0XHQgKiBAcGFyYW0ge0FycmF5fSByZXMgYSBjb2xsZWN0aW9uIG9mIG9iamVjdHMgcmVwcmVzZWluZyB0aGUgbWF0Y2hpbmcgbm9kZXNcblx0XHRcdCAqIEBwbHVnaW4gc2VhcmNoXG5cdFx0XHQgKi9cblx0XHRcdHRoaXMudHJpZ2dlcignc2VhcmNoJywgeyBub2RlcyA6IHRoaXMuX2RhdGEuc2VhcmNoLmRvbSwgc3RyIDogc3RyLCByZXMgOiB0aGlzLl9kYXRhLnNlYXJjaC5yZXMsIHNob3dfb25seV9tYXRjaGVzIDogc2hvd19vbmx5X21hdGNoZXMgfSk7XG5cdFx0fTtcblx0XHQvKipcblx0XHQgKiB1c2VkIHRvIGNsZWFyIHRoZSBsYXN0IHNlYXJjaCAocmVtb3ZlcyBjbGFzc2VzIGFuZCBzaG93cyBhbGwgbm9kZXMgaWYgZmlsdGVyaW5nIGlzIG9uKVxuXHRcdCAqIEBuYW1lIGNsZWFyX3NlYXJjaCgpXG5cdFx0ICogQHBsdWdpbiBzZWFyY2hcblx0XHQgKiBAdHJpZ2dlciBjbGVhcl9zZWFyY2guanN0cmVlXG5cdFx0ICovXG5cdFx0dGhpcy5jbGVhcl9zZWFyY2ggPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHRpZih0aGlzLnNldHRpbmdzLnNlYXJjaC5jbG9zZV9vcGVuZWRfb25jbGVhcikge1xuXHRcdFx0XHR0aGlzLmNsb3NlX25vZGUodGhpcy5fZGF0YS5zZWFyY2gub3BuLCAwKTtcblx0XHRcdH1cblx0XHRcdC8qKlxuXHRcdFx0ICogdHJpZ2dlcmVkIGFmdGVyIHNlYXJjaCBpcyBjb21wbGV0ZVxuXHRcdFx0ICogQGV2ZW50XG5cdFx0XHQgKiBAbmFtZSBjbGVhcl9zZWFyY2guanN0cmVlXG5cdFx0XHQgKiBAcGFyYW0ge2pRdWVyeX0gbm9kZXMgYSBqUXVlcnkgY29sbGVjdGlvbiBvZiBtYXRjaGluZyBub2RlcyAodGhlIHJlc3VsdCBmcm9tIHRoZSBsYXN0IHNlYXJjaClcblx0XHRcdCAqIEBwYXJhbSB7U3RyaW5nfSBzdHIgdGhlIHNlYXJjaCBzdHJpbmcgKHRoZSBsYXN0IHNlYXJjaCBzdHJpbmcpXG5cdFx0XHQgKiBAcGFyYW0ge0FycmF5fSByZXMgYSBjb2xsZWN0aW9uIG9mIG9iamVjdHMgcmVwcmVzZWluZyB0aGUgbWF0Y2hpbmcgbm9kZXMgKHRoZSByZXN1bHQgZnJvbSB0aGUgbGFzdCBzZWFyY2gpXG5cdFx0XHQgKiBAcGx1Z2luIHNlYXJjaFxuXHRcdFx0ICovXG5cdFx0XHR0aGlzLnRyaWdnZXIoJ2NsZWFyX3NlYXJjaCcsIHsgJ25vZGVzJyA6IHRoaXMuX2RhdGEuc2VhcmNoLmRvbSwgc3RyIDogdGhpcy5fZGF0YS5zZWFyY2guc3RyLCByZXMgOiB0aGlzLl9kYXRhLnNlYXJjaC5yZXMgfSk7XG5cdFx0XHRpZih0aGlzLl9kYXRhLnNlYXJjaC5yZXMubGVuZ3RoKSB7XG5cdFx0XHRcdHRoaXMuX2RhdGEuc2VhcmNoLmRvbSA9ICQodGhpcy5lbGVtZW50WzBdLnF1ZXJ5U2VsZWN0b3JBbGwoJyMnICsgJC5tYXAodGhpcy5fZGF0YS5zZWFyY2gucmVzLCBmdW5jdGlvbiAodikge1xuXHRcdFx0XHRcdHJldHVybiBcIjAxMjM0NTY3ODlcIi5pbmRleE9mKHZbMF0pICE9PSAtMSA/ICdcXFxcMycgKyB2WzBdICsgJyAnICsgdi5zdWJzdHIoMSkucmVwbGFjZSgkLmpzdHJlZS5pZHJlZ2V4LCdcXFxcJCYnKSA6IHYucmVwbGFjZSgkLmpzdHJlZS5pZHJlZ2V4LCdcXFxcJCYnKTtcblx0XHRcdFx0fSkuam9pbignLCAjJykpKTtcblx0XHRcdFx0dGhpcy5fZGF0YS5zZWFyY2guZG9tLmNoaWxkcmVuKFwiLmpzdHJlZS1hbmNob3JcIikucmVtb3ZlQ2xhc3MoXCJqc3RyZWUtc2VhcmNoXCIpO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5fZGF0YS5zZWFyY2guc3RyID0gXCJcIjtcblx0XHRcdHRoaXMuX2RhdGEuc2VhcmNoLnJlcyA9IFtdO1xuXHRcdFx0dGhpcy5fZGF0YS5zZWFyY2gub3BuID0gW107XG5cdFx0XHR0aGlzLl9kYXRhLnNlYXJjaC5kb20gPSAkKCk7XG5cdFx0fTtcblxuXHRcdHRoaXMucmVkcmF3X25vZGUgPSBmdW5jdGlvbihvYmosIGRlZXAsIGNhbGxiYWNrLCBmb3JjZV9yZW5kZXIpIHtcblx0XHRcdG9iaiA9IHBhcmVudC5yZWRyYXdfbm9kZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHRcdFx0aWYob2JqKSB7XG5cdFx0XHRcdGlmKCQuaW5BcnJheShvYmouaWQsIHRoaXMuX2RhdGEuc2VhcmNoLnJlcykgIT09IC0xKSB7XG5cdFx0XHRcdFx0dmFyIGksIGosIHRtcCA9IG51bGw7XG5cdFx0XHRcdFx0Zm9yKGkgPSAwLCBqID0gb2JqLmNoaWxkTm9kZXMubGVuZ3RoOyBpIDwgajsgaSsrKSB7XG5cdFx0XHRcdFx0XHRpZihvYmouY2hpbGROb2Rlc1tpXSAmJiBvYmouY2hpbGROb2Rlc1tpXS5jbGFzc05hbWUgJiYgb2JqLmNoaWxkTm9kZXNbaV0uY2xhc3NOYW1lLmluZGV4T2YoXCJqc3RyZWUtYW5jaG9yXCIpICE9PSAtMSkge1xuXHRcdFx0XHRcdFx0XHR0bXAgPSBvYmouY2hpbGROb2Rlc1tpXTtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmKHRtcCkge1xuXHRcdFx0XHRcdFx0dG1wLmNsYXNzTmFtZSArPSAnIGpzdHJlZS1zZWFyY2gnO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG9iajtcblx0XHR9O1xuXHR9O1xuXG5cdC8vIGhlbHBlcnNcblx0KGZ1bmN0aW9uICgkKSB7XG5cdFx0Ly8gZnJvbSBodHRwOi8va2lyby5tZS9wcm9qZWN0cy9mdXNlLmh0bWxcblx0XHQkLnZha2F0YS5zZWFyY2ggPSBmdW5jdGlvbihwYXR0ZXJuLCB0eHQsIG9wdGlvbnMpIHtcblx0XHRcdG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXHRcdFx0b3B0aW9ucyA9ICQuZXh0ZW5kKHt9LCAkLnZha2F0YS5zZWFyY2guZGVmYXVsdHMsIG9wdGlvbnMpO1xuXHRcdFx0aWYob3B0aW9ucy5mdXp6eSAhPT0gZmFsc2UpIHtcblx0XHRcdFx0b3B0aW9ucy5mdXp6eSA9IHRydWU7XG5cdFx0XHR9XG5cdFx0XHRwYXR0ZXJuID0gb3B0aW9ucy5jYXNlU2Vuc2l0aXZlID8gcGF0dGVybiA6IHBhdHRlcm4udG9Mb3dlckNhc2UoKTtcblx0XHRcdHZhciBNQVRDSF9MT0NBVElPTlx0PSBvcHRpb25zLmxvY2F0aW9uLFxuXHRcdFx0XHRNQVRDSF9ESVNUQU5DRVx0PSBvcHRpb25zLmRpc3RhbmNlLFxuXHRcdFx0XHRNQVRDSF9USFJFU0hPTERcdD0gb3B0aW9ucy50aHJlc2hvbGQsXG5cdFx0XHRcdHBhdHRlcm5MZW4gPSBwYXR0ZXJuLmxlbmd0aCxcblx0XHRcdFx0bWF0Y2htYXNrLCBwYXR0ZXJuX2FscGhhYmV0LCBtYXRjaF9iaXRhcFNjb3JlLCBzZWFyY2g7XG5cdFx0XHRpZihwYXR0ZXJuTGVuID4gMzIpIHtcblx0XHRcdFx0b3B0aW9ucy5mdXp6eSA9IGZhbHNlO1xuXHRcdFx0fVxuXHRcdFx0aWYob3B0aW9ucy5mdXp6eSkge1xuXHRcdFx0XHRtYXRjaG1hc2sgPSAxIDw8IChwYXR0ZXJuTGVuIC0gMSk7XG5cdFx0XHRcdHBhdHRlcm5fYWxwaGFiZXQgPSAoZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdHZhciBtYXNrID0ge30sXG5cdFx0XHRcdFx0XHRpID0gMDtcblx0XHRcdFx0XHRmb3IgKGkgPSAwOyBpIDwgcGF0dGVybkxlbjsgaSsrKSB7XG5cdFx0XHRcdFx0XHRtYXNrW3BhdHRlcm4uY2hhckF0KGkpXSA9IDA7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGZvciAoaSA9IDA7IGkgPCBwYXR0ZXJuTGVuOyBpKyspIHtcblx0XHRcdFx0XHRcdG1hc2tbcGF0dGVybi5jaGFyQXQoaSldIHw9IDEgPDwgKHBhdHRlcm5MZW4gLSBpIC0gMSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiBtYXNrO1xuXHRcdFx0XHR9KCkpO1xuXHRcdFx0XHRtYXRjaF9iaXRhcFNjb3JlID0gZnVuY3Rpb24gKGUsIHgpIHtcblx0XHRcdFx0XHR2YXIgYWNjdXJhY3kgPSBlIC8gcGF0dGVybkxlbixcblx0XHRcdFx0XHRcdHByb3hpbWl0eSA9IE1hdGguYWJzKE1BVENIX0xPQ0FUSU9OIC0geCk7XG5cdFx0XHRcdFx0aWYoIU1BVENIX0RJU1RBTkNFKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gcHJveGltaXR5ID8gMS4wIDogYWNjdXJhY3k7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiBhY2N1cmFjeSArIChwcm94aW1pdHkgLyBNQVRDSF9ESVNUQU5DRSk7XG5cdFx0XHRcdH07XG5cdFx0XHR9XG5cdFx0XHRzZWFyY2ggPSBmdW5jdGlvbiAodGV4dCkge1xuXHRcdFx0XHR0ZXh0ID0gb3B0aW9ucy5jYXNlU2Vuc2l0aXZlID8gdGV4dCA6IHRleHQudG9Mb3dlckNhc2UoKTtcblx0XHRcdFx0aWYocGF0dGVybiA9PT0gdGV4dCB8fCB0ZXh0LmluZGV4T2YocGF0dGVybikgIT09IC0xKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0XHRcdGlzTWF0Y2g6IHRydWUsXG5cdFx0XHRcdFx0XHRzY29yZTogMFxuXHRcdFx0XHRcdH07XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYoIW9wdGlvbnMuZnV6enkpIHtcblx0XHRcdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRcdFx0aXNNYXRjaDogZmFsc2UsXG5cdFx0XHRcdFx0XHRzY29yZTogMVxuXHRcdFx0XHRcdH07XG5cdFx0XHRcdH1cblx0XHRcdFx0dmFyIGksIGosXG5cdFx0XHRcdFx0dGV4dExlbiA9IHRleHQubGVuZ3RoLFxuXHRcdFx0XHRcdHNjb3JlVGhyZXNob2xkID0gTUFUQ0hfVEhSRVNIT0xELFxuXHRcdFx0XHRcdGJlc3RMb2MgPSB0ZXh0LmluZGV4T2YocGF0dGVybiwgTUFUQ0hfTE9DQVRJT04pLFxuXHRcdFx0XHRcdGJpbk1pbiwgYmluTWlkLFxuXHRcdFx0XHRcdGJpbk1heCA9IHBhdHRlcm5MZW4gKyB0ZXh0TGVuLFxuXHRcdFx0XHRcdGxhc3RSZCwgc3RhcnQsIGZpbmlzaCwgcmQsIGNoYXJNYXRjaCxcblx0XHRcdFx0XHRzY29yZSA9IDEsXG5cdFx0XHRcdFx0bG9jYXRpb25zID0gW107XG5cdFx0XHRcdGlmIChiZXN0TG9jICE9PSAtMSkge1xuXHRcdFx0XHRcdHNjb3JlVGhyZXNob2xkID0gTWF0aC5taW4obWF0Y2hfYml0YXBTY29yZSgwLCBiZXN0TG9jKSwgc2NvcmVUaHJlc2hvbGQpO1xuXHRcdFx0XHRcdGJlc3RMb2MgPSB0ZXh0Lmxhc3RJbmRleE9mKHBhdHRlcm4sIE1BVENIX0xPQ0FUSU9OICsgcGF0dGVybkxlbik7XG5cdFx0XHRcdFx0aWYgKGJlc3RMb2MgIT09IC0xKSB7XG5cdFx0XHRcdFx0XHRzY29yZVRocmVzaG9sZCA9IE1hdGgubWluKG1hdGNoX2JpdGFwU2NvcmUoMCwgYmVzdExvYyksIHNjb3JlVGhyZXNob2xkKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0YmVzdExvYyA9IC0xO1xuXHRcdFx0XHRmb3IgKGkgPSAwOyBpIDwgcGF0dGVybkxlbjsgaSsrKSB7XG5cdFx0XHRcdFx0YmluTWluID0gMDtcblx0XHRcdFx0XHRiaW5NaWQgPSBiaW5NYXg7XG5cdFx0XHRcdFx0d2hpbGUgKGJpbk1pbiA8IGJpbk1pZCkge1xuXHRcdFx0XHRcdFx0aWYgKG1hdGNoX2JpdGFwU2NvcmUoaSwgTUFUQ0hfTE9DQVRJT04gKyBiaW5NaWQpIDw9IHNjb3JlVGhyZXNob2xkKSB7XG5cdFx0XHRcdFx0XHRcdGJpbk1pbiA9IGJpbk1pZDtcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdGJpbk1heCA9IGJpbk1pZDtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGJpbk1pZCA9IE1hdGguZmxvb3IoKGJpbk1heCAtIGJpbk1pbikgLyAyICsgYmluTWluKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0YmluTWF4ID0gYmluTWlkO1xuXHRcdFx0XHRcdHN0YXJ0ID0gTWF0aC5tYXgoMSwgTUFUQ0hfTE9DQVRJT04gLSBiaW5NaWQgKyAxKTtcblx0XHRcdFx0XHRmaW5pc2ggPSBNYXRoLm1pbihNQVRDSF9MT0NBVElPTiArIGJpbk1pZCwgdGV4dExlbikgKyBwYXR0ZXJuTGVuO1xuXHRcdFx0XHRcdHJkID0gbmV3IEFycmF5KGZpbmlzaCArIDIpO1xuXHRcdFx0XHRcdHJkW2ZpbmlzaCArIDFdID0gKDEgPDwgaSkgLSAxO1xuXHRcdFx0XHRcdGZvciAoaiA9IGZpbmlzaDsgaiA+PSBzdGFydDsgai0tKSB7XG5cdFx0XHRcdFx0XHRjaGFyTWF0Y2ggPSBwYXR0ZXJuX2FscGhhYmV0W3RleHQuY2hhckF0KGogLSAxKV07XG5cdFx0XHRcdFx0XHRpZiAoaSA9PT0gMCkge1xuXHRcdFx0XHRcdFx0XHRyZFtqXSA9ICgocmRbaiArIDFdIDw8IDEpIHwgMSkgJiBjaGFyTWF0Y2g7XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRyZFtqXSA9ICgocmRbaiArIDFdIDw8IDEpIHwgMSkgJiBjaGFyTWF0Y2ggfCAoKChsYXN0UmRbaiArIDFdIHwgbGFzdFJkW2pdKSA8PCAxKSB8IDEpIHwgbGFzdFJkW2ogKyAxXTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGlmIChyZFtqXSAmIG1hdGNobWFzaykge1xuXHRcdFx0XHRcdFx0XHRzY29yZSA9IG1hdGNoX2JpdGFwU2NvcmUoaSwgaiAtIDEpO1xuXHRcdFx0XHRcdFx0XHRpZiAoc2NvcmUgPD0gc2NvcmVUaHJlc2hvbGQpIHtcblx0XHRcdFx0XHRcdFx0XHRzY29yZVRocmVzaG9sZCA9IHNjb3JlO1xuXHRcdFx0XHRcdFx0XHRcdGJlc3RMb2MgPSBqIC0gMTtcblx0XHRcdFx0XHRcdFx0XHRsb2NhdGlvbnMucHVzaChiZXN0TG9jKTtcblx0XHRcdFx0XHRcdFx0XHRpZiAoYmVzdExvYyA+IE1BVENIX0xPQ0FUSU9OKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRzdGFydCA9IE1hdGgubWF4KDEsIDIgKiBNQVRDSF9MT0NBVElPTiAtIGJlc3RMb2MpO1xuXHRcdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKG1hdGNoX2JpdGFwU2NvcmUoaSArIDEsIE1BVENIX0xPQ0FUSU9OKSA+IHNjb3JlVGhyZXNob2xkKSB7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0bGFzdFJkID0gcmQ7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0XHRpc01hdGNoOiBiZXN0TG9jID49IDAsXG5cdFx0XHRcdFx0c2NvcmU6IHNjb3JlXG5cdFx0XHRcdH07XG5cdFx0XHR9O1xuXHRcdFx0cmV0dXJuIHR4dCA9PT0gdHJ1ZSA/IHsgJ3NlYXJjaCcgOiBzZWFyY2ggfSA6IHNlYXJjaCh0eHQpO1xuXHRcdH07XG5cdFx0JC52YWthdGEuc2VhcmNoLmRlZmF1bHRzID0ge1xuXHRcdFx0bG9jYXRpb24gOiAwLFxuXHRcdFx0ZGlzdGFuY2UgOiAxMDAsXG5cdFx0XHR0aHJlc2hvbGQgOiAwLjYsXG5cdFx0XHRmdXp6eSA6IGZhbHNlLFxuXHRcdFx0Y2FzZVNlbnNpdGl2ZSA6IGZhbHNlXG5cdFx0fTtcblx0fSgkKSk7XG5cblx0Ly8gaW5jbHVkZSB0aGUgc2VhcmNoIHBsdWdpbiBieSBkZWZhdWx0XG5cdC8vICQuanN0cmVlLmRlZmF1bHRzLnBsdWdpbnMucHVzaChcInNlYXJjaFwiKTtcblxuXG4vKipcbiAqICMjIyBTb3J0IHBsdWdpblxuICpcbiAqIEF1dG9tYXRpY2FsbHkgc29ydHMgYWxsIHNpYmxpbmdzIGluIHRoZSB0cmVlIGFjY29yZGluZyB0byBhIHNvcnRpbmcgZnVuY3Rpb24uXG4gKi9cblxuXHQvKipcblx0ICogdGhlIHNldHRpbmdzIGZ1bmN0aW9uIHVzZWQgdG8gc29ydCB0aGUgbm9kZXMuXG5cdCAqIEl0IGlzIGV4ZWN1dGVkIGluIHRoZSB0cmVlJ3MgY29udGV4dCwgYWNjZXB0cyB0d28gbm9kZXMgYXMgYXJndW1lbnRzIGFuZCBzaG91bGQgcmV0dXJuIGAxYCBvciBgLTFgLlxuXHQgKiBAbmFtZSAkLmpzdHJlZS5kZWZhdWx0cy5zb3J0XG5cdCAqIEBwbHVnaW4gc29ydFxuXHQgKi9cblx0JC5qc3RyZWUuZGVmYXVsdHMuc29ydCA9IGZ1bmN0aW9uIChhLCBiKSB7XG5cdFx0Ly9yZXR1cm4gdGhpcy5nZXRfdHlwZShhKSA9PT0gdGhpcy5nZXRfdHlwZShiKSA/ICh0aGlzLmdldF90ZXh0KGEpID4gdGhpcy5nZXRfdGV4dChiKSA/IDEgOiAtMSkgOiB0aGlzLmdldF90eXBlKGEpID49IHRoaXMuZ2V0X3R5cGUoYik7XG5cdFx0cmV0dXJuIHRoaXMuZ2V0X3RleHQoYSkgPiB0aGlzLmdldF90ZXh0KGIpID8gMSA6IC0xO1xuXHR9O1xuXHQkLmpzdHJlZS5wbHVnaW5zLnNvcnQgPSBmdW5jdGlvbiAob3B0aW9ucywgcGFyZW50KSB7XG5cdFx0dGhpcy5iaW5kID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0cGFyZW50LmJpbmQuY2FsbCh0aGlzKTtcblx0XHRcdHRoaXMuZWxlbWVudFxuXHRcdFx0XHQub24oXCJtb2RlbC5qc3RyZWVcIiwgJC5wcm94eShmdW5jdGlvbiAoZSwgZGF0YSkge1xuXHRcdFx0XHRcdFx0dGhpcy5zb3J0KGRhdGEucGFyZW50LCB0cnVlKTtcblx0XHRcdFx0XHR9LCB0aGlzKSlcblx0XHRcdFx0Lm9uKFwicmVuYW1lX25vZGUuanN0cmVlIGNyZWF0ZV9ub2RlLmpzdHJlZVwiLCAkLnByb3h5KGZ1bmN0aW9uIChlLCBkYXRhKSB7XG5cdFx0XHRcdFx0XHR0aGlzLnNvcnQoZGF0YS5wYXJlbnQgfHwgZGF0YS5ub2RlLnBhcmVudCwgZmFsc2UpO1xuXHRcdFx0XHRcdFx0dGhpcy5yZWRyYXdfbm9kZShkYXRhLnBhcmVudCB8fCBkYXRhLm5vZGUucGFyZW50LCB0cnVlKTtcblx0XHRcdFx0XHR9LCB0aGlzKSlcblx0XHRcdFx0Lm9uKFwibW92ZV9ub2RlLmpzdHJlZSBjb3B5X25vZGUuanN0cmVlXCIsICQucHJveHkoZnVuY3Rpb24gKGUsIGRhdGEpIHtcblx0XHRcdFx0XHRcdHRoaXMuc29ydChkYXRhLnBhcmVudCwgZmFsc2UpO1xuXHRcdFx0XHRcdFx0dGhpcy5yZWRyYXdfbm9kZShkYXRhLnBhcmVudCwgdHJ1ZSk7XG5cdFx0XHRcdFx0fSwgdGhpcykpO1xuXHRcdH07XG5cdFx0LyoqXG5cdFx0ICogdXNlZCB0byBzb3J0IGEgbm9kZSdzIGNoaWxkcmVuXG5cdFx0ICogQHByaXZhdGVcblx0XHQgKiBAbmFtZSBzb3J0KG9iaiBbLCBkZWVwXSlcblx0XHQgKiBAcGFyYW0gIHttaXhlZH0gb2JqIHRoZSBub2RlXG5cdFx0ICogQHBhcmFtIHtCb29sZWFufSBkZWVwIGlmIHNldCB0byBgdHJ1ZWAgbm9kZXMgYXJlIHNvcnRlZCByZWN1cnNpdmVseS5cblx0XHQgKiBAcGx1Z2luIHNvcnRcblx0XHQgKiBAdHJpZ2dlciBzZWFyY2guanN0cmVlXG5cdFx0ICovXG5cdFx0dGhpcy5zb3J0ID0gZnVuY3Rpb24gKG9iaiwgZGVlcCkge1xuXHRcdFx0dmFyIGksIGo7XG5cdFx0XHRvYmogPSB0aGlzLmdldF9ub2RlKG9iaik7XG5cdFx0XHRpZihvYmogJiYgb2JqLmNoaWxkcmVuICYmIG9iai5jaGlsZHJlbi5sZW5ndGgpIHtcblx0XHRcdFx0b2JqLmNoaWxkcmVuLnNvcnQoJC5wcm94eSh0aGlzLnNldHRpbmdzLnNvcnQsIHRoaXMpKTtcblx0XHRcdFx0aWYoZGVlcCkge1xuXHRcdFx0XHRcdGZvcihpID0gMCwgaiA9IG9iai5jaGlsZHJlbl9kLmxlbmd0aDsgaSA8IGo7IGkrKykge1xuXHRcdFx0XHRcdFx0dGhpcy5zb3J0KG9iai5jaGlsZHJlbl9kW2ldLCBmYWxzZSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fTtcblx0fTtcblxuXHQvLyBpbmNsdWRlIHRoZSBzb3J0IHBsdWdpbiBieSBkZWZhdWx0XG5cdC8vICQuanN0cmVlLmRlZmF1bHRzLnBsdWdpbnMucHVzaChcInNvcnRcIik7XG5cbi8qKlxuICogIyMjIFN0YXRlIHBsdWdpblxuICpcbiAqIFNhdmVzIHRoZSBzdGF0ZSBvZiB0aGUgdHJlZSAoc2VsZWN0ZWQgbm9kZXMsIG9wZW5lZCBub2Rlcykgb24gdGhlIHVzZXIncyBjb21wdXRlciB1c2luZyBhdmFpbGFibGUgb3B0aW9ucyAobG9jYWxTdG9yYWdlLCBjb29raWVzLCBldGMpXG4gKi9cblxuXHR2YXIgdG8gPSBmYWxzZTtcblx0LyoqXG5cdCAqIHN0b3JlcyBhbGwgZGVmYXVsdHMgZm9yIHRoZSBzdGF0ZSBwbHVnaW5cblx0ICogQG5hbWUgJC5qc3RyZWUuZGVmYXVsdHMuc3RhdGVcblx0ICogQHBsdWdpbiBzdGF0ZVxuXHQgKi9cblx0JC5qc3RyZWUuZGVmYXVsdHMuc3RhdGUgPSB7XG5cdFx0LyoqXG5cdFx0ICogQSBzdHJpbmcgZm9yIHRoZSBrZXkgdG8gdXNlIHdoZW4gc2F2aW5nIHRoZSBjdXJyZW50IHRyZWUgKGNoYW5nZSBpZiB1c2luZyBtdWx0aXBsZSB0cmVlcyBpbiB5b3VyIHByb2plY3QpLiBEZWZhdWx0cyB0byBganN0cmVlYC5cblx0XHQgKiBAbmFtZSAkLmpzdHJlZS5kZWZhdWx0cy5zdGF0ZS5rZXlcblx0XHQgKiBAcGx1Z2luIHN0YXRlXG5cdFx0ICovXG5cdFx0a2V5XHRcdDogJ2pzdHJlZScsXG5cdFx0LyoqXG5cdFx0ICogQSBzcGFjZSBzZXBhcmF0ZWQgbGlzdCBvZiBldmVudHMgdGhhdCB0cmlnZ2VyIGEgc3RhdGUgc2F2ZS4gRGVmYXVsdHMgdG8gYGNoYW5nZWQuanN0cmVlIG9wZW5fbm9kZS5qc3RyZWUgY2xvc2Vfbm9kZS5qc3RyZWVgLlxuXHRcdCAqIEBuYW1lICQuanN0cmVlLmRlZmF1bHRzLnN0YXRlLmV2ZW50c1xuXHRcdCAqIEBwbHVnaW4gc3RhdGVcblx0XHQgKi9cblx0XHRldmVudHNcdDogJ2NoYW5nZWQuanN0cmVlIG9wZW5fbm9kZS5qc3RyZWUgY2xvc2Vfbm9kZS5qc3RyZWUgY2hlY2tfbm9kZS5qc3RyZWUgdW5jaGVja19ub2RlLmpzdHJlZScsXG5cdFx0LyoqXG5cdFx0ICogVGltZSBpbiBtaWxsaXNlY29uZHMgYWZ0ZXIgd2hpY2ggdGhlIHN0YXRlIHdpbGwgZXhwaXJlLiBEZWZhdWx0cyB0byAnZmFsc2UnIG1lYW5pbmcgLSBubyBleHBpcmUuXG5cdFx0ICogQG5hbWUgJC5qc3RyZWUuZGVmYXVsdHMuc3RhdGUudHRsXG5cdFx0ICogQHBsdWdpbiBzdGF0ZVxuXHRcdCAqL1xuXHRcdHR0bFx0XHQ6IGZhbHNlLFxuXHRcdC8qKlxuXHRcdCAqIEEgZnVuY3Rpb24gdGhhdCB3aWxsIGJlIGV4ZWN1dGVkIHByaW9yIHRvIHJlc3RvcmluZyBzdGF0ZSB3aXRoIG9uZSBhcmd1bWVudCAtIHRoZSBzdGF0ZSBvYmplY3QuIENhbiBiZSB1c2VkIHRvIGNsZWFyIHVud2FudGVkIHBhcnRzIG9mIHRoZSBzdGF0ZS5cblx0XHQgKiBAbmFtZSAkLmpzdHJlZS5kZWZhdWx0cy5zdGF0ZS5maWx0ZXJcblx0XHQgKiBAcGx1Z2luIHN0YXRlXG5cdFx0ICovXG5cdFx0ZmlsdGVyXHQ6IGZhbHNlXG5cdH07XG5cdCQuanN0cmVlLnBsdWdpbnMuc3RhdGUgPSBmdW5jdGlvbiAob3B0aW9ucywgcGFyZW50KSB7XG5cdFx0dGhpcy5iaW5kID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0cGFyZW50LmJpbmQuY2FsbCh0aGlzKTtcblx0XHRcdHZhciBiaW5kID0gJC5wcm94eShmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdHRoaXMuZWxlbWVudC5vbih0aGlzLnNldHRpbmdzLnN0YXRlLmV2ZW50cywgJC5wcm94eShmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdFx0aWYodG8pIHsgY2xlYXJUaW1lb3V0KHRvKTsgfVxuXHRcdFx0XHRcdHRvID0gc2V0VGltZW91dCgkLnByb3h5KGZ1bmN0aW9uICgpIHsgdGhpcy5zYXZlX3N0YXRlKCk7IH0sIHRoaXMpLCAxMDApO1xuXHRcdFx0XHR9LCB0aGlzKSk7XG5cdFx0XHRcdC8qKlxuXHRcdFx0XHQgKiB0cmlnZ2VyZWQgd2hlbiB0aGUgc3RhdGUgcGx1Z2luIGlzIGZpbmlzaGVkIHJlc3RvcmluZyB0aGUgc3RhdGUgKGFuZCBpbW1lZGlhdGVseSBhZnRlciByZWFkeSBpZiB0aGVyZSBpcyBubyBzdGF0ZSB0byByZXN0b3JlKS5cblx0XHRcdFx0ICogQGV2ZW50XG5cdFx0XHRcdCAqIEBuYW1lIHN0YXRlX3JlYWR5LmpzdHJlZVxuXHRcdFx0XHQgKiBAcGx1Z2luIHN0YXRlXG5cdFx0XHRcdCAqL1xuXHRcdFx0XHR0aGlzLnRyaWdnZXIoJ3N0YXRlX3JlYWR5Jyk7XG5cdFx0XHR9LCB0aGlzKTtcblx0XHRcdHRoaXMuZWxlbWVudFxuXHRcdFx0XHQub24oXCJyZWFkeS5qc3RyZWVcIiwgJC5wcm94eShmdW5jdGlvbiAoZSwgZGF0YSkge1xuXHRcdFx0XHRcdFx0dGhpcy5lbGVtZW50Lm9uZShcInJlc3RvcmVfc3RhdGUuanN0cmVlXCIsIGJpbmQpO1xuXHRcdFx0XHRcdFx0aWYoIXRoaXMucmVzdG9yZV9zdGF0ZSgpKSB7IGJpbmQoKTsgfVxuXHRcdFx0XHRcdH0sIHRoaXMpKTtcblx0XHR9O1xuXHRcdC8qKlxuXHRcdCAqIHNhdmUgdGhlIHN0YXRlXG5cdFx0ICogQG5hbWUgc2F2ZV9zdGF0ZSgpXG5cdFx0ICogQHBsdWdpbiBzdGF0ZVxuXHRcdCAqL1xuXHRcdHRoaXMuc2F2ZV9zdGF0ZSA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdHZhciBzdCA9IHsgJ3N0YXRlJyA6IHRoaXMuZ2V0X3N0YXRlKCksICd0dGwnIDogdGhpcy5zZXR0aW5ncy5zdGF0ZS50dGwsICdzZWMnIDogKyhuZXcgRGF0ZSgpKSB9O1xuXHRcdFx0JC52YWthdGEuc3RvcmFnZS5zZXQodGhpcy5zZXR0aW5ncy5zdGF0ZS5rZXksIEpTT04uc3RyaW5naWZ5KHN0KSk7XG5cdFx0fTtcblx0XHQvKipcblx0XHQgKiByZXN0b3JlIHRoZSBzdGF0ZSBmcm9tIHRoZSB1c2VyJ3MgY29tcHV0ZXJcblx0XHQgKiBAbmFtZSByZXN0b3JlX3N0YXRlKClcblx0XHQgKiBAcGx1Z2luIHN0YXRlXG5cdFx0ICovXG5cdFx0dGhpcy5yZXN0b3JlX3N0YXRlID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0dmFyIGsgPSAkLnZha2F0YS5zdG9yYWdlLmdldCh0aGlzLnNldHRpbmdzLnN0YXRlLmtleSk7XG5cdFx0XHRpZighIWspIHsgdHJ5IHsgayA9IEpTT04ucGFyc2Uoayk7IH0gY2F0Y2goZXgpIHsgcmV0dXJuIGZhbHNlOyB9IH1cblx0XHRcdGlmKCEhayAmJiBrLnR0bCAmJiBrLnNlYyAmJiArKG5ldyBEYXRlKCkpIC0gay5zZWMgPiBrLnR0bCkgeyByZXR1cm4gZmFsc2U7IH1cblx0XHRcdGlmKCEhayAmJiBrLnN0YXRlKSB7IGsgPSBrLnN0YXRlOyB9XG5cdFx0XHRpZighIWsgJiYgJC5pc0Z1bmN0aW9uKHRoaXMuc2V0dGluZ3Muc3RhdGUuZmlsdGVyKSkgeyBrID0gdGhpcy5zZXR0aW5ncy5zdGF0ZS5maWx0ZXIuY2FsbCh0aGlzLCBrKTsgfVxuXHRcdFx0aWYoISFrKSB7XG5cdFx0XHRcdHRoaXMuZWxlbWVudC5vbmUoXCJzZXRfc3RhdGUuanN0cmVlXCIsIGZ1bmN0aW9uIChlLCBkYXRhKSB7IGRhdGEuaW5zdGFuY2UudHJpZ2dlcigncmVzdG9yZV9zdGF0ZScsIHsgJ3N0YXRlJyA6ICQuZXh0ZW5kKHRydWUsIHt9LCBrKSB9KTsgfSk7XG5cdFx0XHRcdHRoaXMuc2V0X3N0YXRlKGspO1xuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9O1xuXHRcdC8qKlxuXHRcdCAqIGNsZWFyIHRoZSBzdGF0ZSBvbiB0aGUgdXNlcidzIGNvbXB1dGVyXG5cdFx0ICogQG5hbWUgY2xlYXJfc3RhdGUoKVxuXHRcdCAqIEBwbHVnaW4gc3RhdGVcblx0XHQgKi9cblx0XHR0aGlzLmNsZWFyX3N0YXRlID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0cmV0dXJuICQudmFrYXRhLnN0b3JhZ2UuZGVsKHRoaXMuc2V0dGluZ3Muc3RhdGUua2V5KTtcblx0XHR9O1xuXHR9O1xuXG5cdChmdW5jdGlvbiAoJCwgdW5kZWZpbmVkKSB7XG5cdFx0JC52YWthdGEuc3RvcmFnZSA9IHtcblx0XHRcdC8vIHNpbXBseSBzcGVjaWZ5aW5nIHRoZSBmdW5jdGlvbnMgaW4gRkYgdGhyb3dzIGFuIGVycm9yXG5cdFx0XHRzZXQgOiBmdW5jdGlvbiAoa2V5LCB2YWwpIHsgcmV0dXJuIHdpbmRvdy5sb2NhbFN0b3JhZ2Uuc2V0SXRlbShrZXksIHZhbCk7IH0sXG5cdFx0XHRnZXQgOiBmdW5jdGlvbiAoa2V5KSB7IHJldHVybiB3aW5kb3cubG9jYWxTdG9yYWdlLmdldEl0ZW0oa2V5KTsgfSxcblx0XHRcdGRlbCA6IGZ1bmN0aW9uIChrZXkpIHsgcmV0dXJuIHdpbmRvdy5sb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbShrZXkpOyB9XG5cdFx0fTtcblx0fSgkKSk7XG5cblx0Ly8gaW5jbHVkZSB0aGUgc3RhdGUgcGx1Z2luIGJ5IGRlZmF1bHRcblx0Ly8gJC5qc3RyZWUuZGVmYXVsdHMucGx1Z2lucy5wdXNoKFwic3RhdGVcIik7XG5cbi8qKlxuICogIyMjIFR5cGVzIHBsdWdpblxuICpcbiAqIE1ha2VzIGl0IHBvc3NpYmxlIHRvIGFkZCBwcmVkZWZpbmVkIHR5cGVzIGZvciBncm91cHMgb2Ygbm9kZXMsIHdoaWNoIG1ha2UgaXQgcG9zc2libGUgdG8gZWFzaWx5IGNvbnRyb2wgbmVzdGluZyBydWxlcyBhbmQgaWNvbiBmb3IgZWFjaCBncm91cC5cbiAqL1xuXG5cdC8qKlxuXHQgKiBBbiBvYmplY3Qgc3RvcmluZyBhbGwgdHlwZXMgYXMga2V5IHZhbHVlIHBhaXJzLCB3aGVyZSB0aGUga2V5IGlzIHRoZSB0eXBlIG5hbWUgYW5kIHRoZSB2YWx1ZSBpcyBhbiBvYmplY3QgdGhhdCBjb3VsZCBjb250YWluIGZvbGxvd2luZyBrZXlzIChhbGwgb3B0aW9uYWwpLlxuXHQgKlxuXHQgKiAqIGBtYXhfY2hpbGRyZW5gIHRoZSBtYXhpbXVtIG51bWJlciBvZiBpbW1lZGlhdGUgY2hpbGRyZW4gdGhpcyBub2RlIHR5cGUgY2FuIGhhdmUuIERvIG5vdCBzcGVjaWZ5IG9yIHNldCB0byBgLTFgIGZvciB1bmxpbWl0ZWQuXG5cdCAqICogYG1heF9kZXB0aGAgdGhlIG1heGltdW0gbnVtYmVyIG9mIG5lc3RpbmcgdGhpcyBub2RlIHR5cGUgY2FuIGhhdmUuIEEgdmFsdWUgb2YgYDFgIHdvdWxkIG1lYW4gdGhhdCB0aGUgbm9kZSBjYW4gaGF2ZSBjaGlsZHJlbiwgYnV0IG5vIGdyYW5kY2hpbGRyZW4uIERvIG5vdCBzcGVjaWZ5IG9yIHNldCB0byBgLTFgIGZvciB1bmxpbWl0ZWQuXG5cdCAqICogYHZhbGlkX2NoaWxkcmVuYCBhbiBhcnJheSBvZiBub2RlIHR5cGUgc3RyaW5ncywgdGhhdCBub2RlcyBvZiB0aGlzIHR5cGUgY2FuIGhhdmUgYXMgY2hpbGRyZW4uIERvIG5vdCBzcGVjaWZ5IG9yIHNldCB0byBgLTFgIGZvciBubyBsaW1pdHMuXG5cdCAqICogYGljb25gIGEgc3RyaW5nIC0gY2FuIGJlIGEgcGF0aCB0byBhbiBpY29uIG9yIGEgY2xhc3NOYW1lLCBpZiB1c2luZyBhbiBpbWFnZSB0aGF0IGlzIGluIHRoZSBjdXJyZW50IGRpcmVjdG9yeSB1c2UgYSBgLi9gIHByZWZpeCwgb3RoZXJ3aXNlIGl0IHdpbGwgYmUgZGV0ZWN0ZWQgYXMgYSBjbGFzcy4gT21pdCB0byB1c2UgdGhlIGRlZmF1bHQgaWNvbiBmcm9tIHlvdXIgdGhlbWUuXG5cdCAqICogYGxpX2F0dHJgIGFuIG9iamVjdCBvZiB2YWx1ZXMgd2hpY2ggd2lsbCBiZSB1c2VkIHRvIGFkZCBIVE1MIGF0dHJpYnV0ZXMgb24gdGhlIHJlc3VsdGluZyBMSSBET00gbm9kZSAobWVyZ2VkIHdpdGggdGhlIG5vZGUncyBvd24gZGF0YSlcblx0ICogKiBgYV9hdHRyYCBhbiBvYmplY3Qgb2YgdmFsdWVzIHdoaWNoIHdpbGwgYmUgdXNlZCB0byBhZGQgSFRNTCBhdHRyaWJ1dGVzIG9uIHRoZSByZXN1bHRpbmcgQSBET00gbm9kZSAobWVyZ2VkIHdpdGggdGhlIG5vZGUncyBvd24gZGF0YSlcblx0ICpcblx0ICogVGhlcmUgYXJlIHR3byBwcmVkZWZpbmVkIHR5cGVzOlxuXHQgKlxuXHQgKiAqIGAjYCByZXByZXNlbnRzIHRoZSByb290IG9mIHRoZSB0cmVlLCBmb3IgZXhhbXBsZSBgbWF4X2NoaWxkcmVuYCB3b3VsZCBjb250cm9sIHRoZSBtYXhpbXVtIG51bWJlciBvZiByb290IG5vZGVzLlxuXHQgKiAqIGBkZWZhdWx0YCByZXByZXNlbnRzIHRoZSBkZWZhdWx0IG5vZGUgLSBhbnkgc2V0dGluZ3MgaGVyZSB3aWxsIGJlIGFwcGxpZWQgdG8gYWxsIG5vZGVzIHRoYXQgZG8gbm90IGhhdmUgYSB0eXBlIHNwZWNpZmllZC5cblx0ICpcblx0ICogQG5hbWUgJC5qc3RyZWUuZGVmYXVsdHMudHlwZXNcblx0ICogQHBsdWdpbiB0eXBlc1xuXHQgKi9cblx0JC5qc3RyZWUuZGVmYXVsdHMudHlwZXMgPSB7XG5cdFx0J2RlZmF1bHQnIDoge31cblx0fTtcblx0JC5qc3RyZWUuZGVmYXVsdHMudHlwZXNbJC5qc3RyZWUucm9vdF0gPSB7fTtcblxuXHQkLmpzdHJlZS5wbHVnaW5zLnR5cGVzID0gZnVuY3Rpb24gKG9wdGlvbnMsIHBhcmVudCkge1xuXHRcdHRoaXMuaW5pdCA9IGZ1bmN0aW9uIChlbCwgb3B0aW9ucykge1xuXHRcdFx0dmFyIGksIGo7XG5cdFx0XHRpZihvcHRpb25zICYmIG9wdGlvbnMudHlwZXMgJiYgb3B0aW9ucy50eXBlc1snZGVmYXVsdCddKSB7XG5cdFx0XHRcdGZvcihpIGluIG9wdGlvbnMudHlwZXMpIHtcblx0XHRcdFx0XHRpZihpICE9PSBcImRlZmF1bHRcIiAmJiBpICE9PSAkLmpzdHJlZS5yb290ICYmIG9wdGlvbnMudHlwZXMuaGFzT3duUHJvcGVydHkoaSkpIHtcblx0XHRcdFx0XHRcdGZvcihqIGluIG9wdGlvbnMudHlwZXNbJ2RlZmF1bHQnXSkge1xuXHRcdFx0XHRcdFx0XHRpZihvcHRpb25zLnR5cGVzWydkZWZhdWx0J10uaGFzT3duUHJvcGVydHkoaikgJiYgb3B0aW9ucy50eXBlc1tpXVtqXSA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdFx0XHRcdFx0b3B0aW9ucy50eXBlc1tpXVtqXSA9IG9wdGlvbnMudHlwZXNbJ2RlZmF1bHQnXVtqXTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cGFyZW50LmluaXQuY2FsbCh0aGlzLCBlbCwgb3B0aW9ucyk7XG5cdFx0XHR0aGlzLl9tb2RlbC5kYXRhWyQuanN0cmVlLnJvb3RdLnR5cGUgPSAkLmpzdHJlZS5yb290O1xuXHRcdH07XG5cdFx0dGhpcy5yZWZyZXNoID0gZnVuY3Rpb24gKHNraXBfbG9hZGluZywgZm9yZ2V0X3N0YXRlKSB7XG5cdFx0XHRwYXJlbnQucmVmcmVzaC5jYWxsKHRoaXMsIHNraXBfbG9hZGluZywgZm9yZ2V0X3N0YXRlKTtcblx0XHRcdHRoaXMuX21vZGVsLmRhdGFbJC5qc3RyZWUucm9vdF0udHlwZSA9ICQuanN0cmVlLnJvb3Q7XG5cdFx0fTtcblx0XHR0aGlzLmJpbmQgPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHR0aGlzLmVsZW1lbnRcblx0XHRcdFx0Lm9uKCdtb2RlbC5qc3RyZWUnLCAkLnByb3h5KGZ1bmN0aW9uIChlLCBkYXRhKSB7XG5cdFx0XHRcdFx0XHR2YXIgbSA9IHRoaXMuX21vZGVsLmRhdGEsXG5cdFx0XHRcdFx0XHRcdGRwYyA9IGRhdGEubm9kZXMsXG5cdFx0XHRcdFx0XHRcdHQgPSB0aGlzLnNldHRpbmdzLnR5cGVzLFxuXHRcdFx0XHRcdFx0XHRpLCBqLCBjID0gJ2RlZmF1bHQnLCBrO1xuXHRcdFx0XHRcdFx0Zm9yKGkgPSAwLCBqID0gZHBjLmxlbmd0aDsgaSA8IGo7IGkrKykge1xuXHRcdFx0XHRcdFx0XHRjID0gJ2RlZmF1bHQnO1xuXHRcdFx0XHRcdFx0XHRpZihtW2RwY1tpXV0ub3JpZ2luYWwgJiYgbVtkcGNbaV1dLm9yaWdpbmFsLnR5cGUgJiYgdFttW2RwY1tpXV0ub3JpZ2luYWwudHlwZV0pIHtcblx0XHRcdFx0XHRcdFx0XHRjID0gbVtkcGNbaV1dLm9yaWdpbmFsLnR5cGU7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0aWYobVtkcGNbaV1dLmRhdGEgJiYgbVtkcGNbaV1dLmRhdGEuanN0cmVlICYmIG1bZHBjW2ldXS5kYXRhLmpzdHJlZS50eXBlICYmIHRbbVtkcGNbaV1dLmRhdGEuanN0cmVlLnR5cGVdKSB7XG5cdFx0XHRcdFx0XHRcdFx0YyA9IG1bZHBjW2ldXS5kYXRhLmpzdHJlZS50eXBlO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdG1bZHBjW2ldXS50eXBlID0gYztcblx0XHRcdFx0XHRcdFx0aWYobVtkcGNbaV1dLmljb24gPT09IHRydWUgJiYgdFtjXS5pY29uICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHRcdFx0XHRtW2RwY1tpXV0uaWNvbiA9IHRbY10uaWNvbjtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRpZih0W2NdLmxpX2F0dHIgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2YgdFtjXS5saV9hdHRyID09PSAnb2JqZWN0Jykge1xuXHRcdFx0XHRcdFx0XHRcdGZvciAoayBpbiB0W2NdLmxpX2F0dHIpIHtcblx0XHRcdFx0XHRcdFx0XHRcdGlmICh0W2NdLmxpX2F0dHIuaGFzT3duUHJvcGVydHkoaykpIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWYgKGsgPT09ICdpZCcpIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRlbHNlIGlmIChtW2RwY1tpXV0ubGlfYXR0cltrXSA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0bVtkcGNbaV1dLmxpX2F0dHJba10gPSB0W2NdLmxpX2F0dHJba107XG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0ZWxzZSBpZiAoayA9PT0gJ2NsYXNzJykge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdG1bZHBjW2ldXS5saV9hdHRyWydjbGFzcyddID0gdFtjXS5saV9hdHRyWydjbGFzcyddICsgJyAnICsgbVtkcGNbaV1dLmxpX2F0dHJbJ2NsYXNzJ107XG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0aWYodFtjXS5hX2F0dHIgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2YgdFtjXS5hX2F0dHIgPT09ICdvYmplY3QnKSB7XG5cdFx0XHRcdFx0XHRcdFx0Zm9yIChrIGluIHRbY10uYV9hdHRyKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRpZiAodFtjXS5hX2F0dHIuaGFzT3duUHJvcGVydHkoaykpIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWYgKGsgPT09ICdpZCcpIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRlbHNlIGlmIChtW2RwY1tpXV0uYV9hdHRyW2tdID09PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRtW2RwY1tpXV0uYV9hdHRyW2tdID0gdFtjXS5hX2F0dHJba107XG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0ZWxzZSBpZiAoayA9PT0gJ2hyZWYnICYmIG1bZHBjW2ldXS5hX2F0dHJba10gPT09ICcjJykge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdG1bZHBjW2ldXS5hX2F0dHJbJ2hyZWYnXSA9IHRbY10uYV9hdHRyWydocmVmJ107XG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0ZWxzZSBpZiAoayA9PT0gJ2NsYXNzJykge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdG1bZHBjW2ldXS5hX2F0dHJbJ2NsYXNzJ10gPSB0W2NdLmFfYXR0clsnY2xhc3MnXSArICcgJyArIG1bZHBjW2ldXS5hX2F0dHJbJ2NsYXNzJ107XG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdG1bJC5qc3RyZWUucm9vdF0udHlwZSA9ICQuanN0cmVlLnJvb3Q7XG5cdFx0XHRcdFx0fSwgdGhpcykpO1xuXHRcdFx0cGFyZW50LmJpbmQuY2FsbCh0aGlzKTtcblx0XHR9O1xuXHRcdHRoaXMuZ2V0X2pzb24gPSBmdW5jdGlvbiAob2JqLCBvcHRpb25zLCBmbGF0KSB7XG5cdFx0XHR2YXIgaSwgaixcblx0XHRcdFx0bSA9IHRoaXMuX21vZGVsLmRhdGEsXG5cdFx0XHRcdG9wdCA9IG9wdGlvbnMgPyAkLmV4dGVuZCh0cnVlLCB7fSwgb3B0aW9ucywge25vX2lkOmZhbHNlfSkgOiB7fSxcblx0XHRcdFx0dG1wID0gcGFyZW50LmdldF9qc29uLmNhbGwodGhpcywgb2JqLCBvcHQsIGZsYXQpO1xuXHRcdFx0aWYodG1wID09PSBmYWxzZSkgeyByZXR1cm4gZmFsc2U7IH1cblx0XHRcdGlmKCQuaXNBcnJheSh0bXApKSB7XG5cdFx0XHRcdGZvcihpID0gMCwgaiA9IHRtcC5sZW5ndGg7IGkgPCBqOyBpKyspIHtcblx0XHRcdFx0XHR0bXBbaV0udHlwZSA9IHRtcFtpXS5pZCAmJiBtW3RtcFtpXS5pZF0gJiYgbVt0bXBbaV0uaWRdLnR5cGUgPyBtW3RtcFtpXS5pZF0udHlwZSA6IFwiZGVmYXVsdFwiO1xuXHRcdFx0XHRcdGlmKG9wdGlvbnMgJiYgb3B0aW9ucy5ub19pZCkge1xuXHRcdFx0XHRcdFx0ZGVsZXRlIHRtcFtpXS5pZDtcblx0XHRcdFx0XHRcdGlmKHRtcFtpXS5saV9hdHRyICYmIHRtcFtpXS5saV9hdHRyLmlkKSB7XG5cdFx0XHRcdFx0XHRcdGRlbGV0ZSB0bXBbaV0ubGlfYXR0ci5pZDtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGlmKHRtcFtpXS5hX2F0dHIgJiYgdG1wW2ldLmFfYXR0ci5pZCkge1xuXHRcdFx0XHRcdFx0XHRkZWxldGUgdG1wW2ldLmFfYXR0ci5pZDtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGVsc2Uge1xuXHRcdFx0XHR0bXAudHlwZSA9IHRtcC5pZCAmJiBtW3RtcC5pZF0gJiYgbVt0bXAuaWRdLnR5cGUgPyBtW3RtcC5pZF0udHlwZSA6IFwiZGVmYXVsdFwiO1xuXHRcdFx0XHRpZihvcHRpb25zICYmIG9wdGlvbnMubm9faWQpIHtcblx0XHRcdFx0XHR0bXAgPSB0aGlzLl9kZWxldGVfaWRzKHRtcCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiB0bXA7XG5cdFx0fTtcblx0XHR0aGlzLl9kZWxldGVfaWRzID0gZnVuY3Rpb24gKHRtcCkge1xuXHRcdFx0aWYoJC5pc0FycmF5KHRtcCkpIHtcblx0XHRcdFx0Zm9yKHZhciBpID0gMCwgaiA9IHRtcC5sZW5ndGg7IGkgPCBqOyBpKyspIHtcblx0XHRcdFx0XHR0bXBbaV0gPSB0aGlzLl9kZWxldGVfaWRzKHRtcFtpXSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHRtcDtcblx0XHRcdH1cblx0XHRcdGRlbGV0ZSB0bXAuaWQ7XG5cdFx0XHRpZih0bXAubGlfYXR0ciAmJiB0bXAubGlfYXR0ci5pZCkge1xuXHRcdFx0XHRkZWxldGUgdG1wLmxpX2F0dHIuaWQ7XG5cdFx0XHR9XG5cdFx0XHRpZih0bXAuYV9hdHRyICYmIHRtcC5hX2F0dHIuaWQpIHtcblx0XHRcdFx0ZGVsZXRlIHRtcC5hX2F0dHIuaWQ7XG5cdFx0XHR9XG5cdFx0XHRpZih0bXAuY2hpbGRyZW4gJiYgJC5pc0FycmF5KHRtcC5jaGlsZHJlbikpIHtcblx0XHRcdFx0dG1wLmNoaWxkcmVuID0gdGhpcy5fZGVsZXRlX2lkcyh0bXAuY2hpbGRyZW4pO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRtcDtcblx0XHR9O1xuXHRcdHRoaXMuY2hlY2sgPSBmdW5jdGlvbiAoY2hrLCBvYmosIHBhciwgcG9zLCBtb3JlKSB7XG5cdFx0XHRpZihwYXJlbnQuY2hlY2suY2FsbCh0aGlzLCBjaGssIG9iaiwgcGFyLCBwb3MsIG1vcmUpID09PSBmYWxzZSkgeyByZXR1cm4gZmFsc2U7IH1cblx0XHRcdG9iaiA9IG9iaiAmJiBvYmouaWQgPyBvYmogOiB0aGlzLmdldF9ub2RlKG9iaik7XG5cdFx0XHRwYXIgPSBwYXIgJiYgcGFyLmlkID8gcGFyIDogdGhpcy5nZXRfbm9kZShwYXIpO1xuXHRcdFx0dmFyIG0gPSBvYmogJiYgb2JqLmlkID8gKG1vcmUgJiYgbW9yZS5vcmlnaW4gPyBtb3JlLm9yaWdpbiA6ICQuanN0cmVlLnJlZmVyZW5jZShvYmouaWQpKSA6IG51bGwsIHRtcCwgZCwgaSwgajtcblx0XHRcdG0gPSBtICYmIG0uX21vZGVsICYmIG0uX21vZGVsLmRhdGEgPyBtLl9tb2RlbC5kYXRhIDogbnVsbDtcblx0XHRcdHN3aXRjaChjaGspIHtcblx0XHRcdFx0Y2FzZSBcImNyZWF0ZV9ub2RlXCI6XG5cdFx0XHRcdGNhc2UgXCJtb3ZlX25vZGVcIjpcblx0XHRcdFx0Y2FzZSBcImNvcHlfbm9kZVwiOlxuXHRcdFx0XHRcdGlmKGNoayAhPT0gJ21vdmVfbm9kZScgfHwgJC5pbkFycmF5KG9iai5pZCwgcGFyLmNoaWxkcmVuKSA9PT0gLTEpIHtcblx0XHRcdFx0XHRcdHRtcCA9IHRoaXMuZ2V0X3J1bGVzKHBhcik7XG5cdFx0XHRcdFx0XHRpZih0bXAubWF4X2NoaWxkcmVuICE9PSB1bmRlZmluZWQgJiYgdG1wLm1heF9jaGlsZHJlbiAhPT0gLTEgJiYgdG1wLm1heF9jaGlsZHJlbiA9PT0gcGFyLmNoaWxkcmVuLmxlbmd0aCkge1xuXHRcdFx0XHRcdFx0XHR0aGlzLl9kYXRhLmNvcmUubGFzdF9lcnJvciA9IHsgJ2Vycm9yJyA6ICdjaGVjaycsICdwbHVnaW4nIDogJ3R5cGVzJywgJ2lkJyA6ICd0eXBlc18wMScsICdyZWFzb24nIDogJ21heF9jaGlsZHJlbiBwcmV2ZW50cyBmdW5jdGlvbjogJyArIGNoaywgJ2RhdGEnIDogSlNPTi5zdHJpbmdpZnkoeyAnY2hrJyA6IGNoaywgJ3BvcycgOiBwb3MsICdvYmonIDogb2JqICYmIG9iai5pZCA/IG9iai5pZCA6IGZhbHNlLCAncGFyJyA6IHBhciAmJiBwYXIuaWQgPyBwYXIuaWQgOiBmYWxzZSB9KSB9O1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRpZih0bXAudmFsaWRfY2hpbGRyZW4gIT09IHVuZGVmaW5lZCAmJiB0bXAudmFsaWRfY2hpbGRyZW4gIT09IC0xICYmICQuaW5BcnJheSgob2JqLnR5cGUgfHwgJ2RlZmF1bHQnKSwgdG1wLnZhbGlkX2NoaWxkcmVuKSA9PT0gLTEpIHtcblx0XHRcdFx0XHRcdFx0dGhpcy5fZGF0YS5jb3JlLmxhc3RfZXJyb3IgPSB7ICdlcnJvcicgOiAnY2hlY2snLCAncGx1Z2luJyA6ICd0eXBlcycsICdpZCcgOiAndHlwZXNfMDInLCAncmVhc29uJyA6ICd2YWxpZF9jaGlsZHJlbiBwcmV2ZW50cyBmdW5jdGlvbjogJyArIGNoaywgJ2RhdGEnIDogSlNPTi5zdHJpbmdpZnkoeyAnY2hrJyA6IGNoaywgJ3BvcycgOiBwb3MsICdvYmonIDogb2JqICYmIG9iai5pZCA/IG9iai5pZCA6IGZhbHNlLCAncGFyJyA6IHBhciAmJiBwYXIuaWQgPyBwYXIuaWQgOiBmYWxzZSB9KSB9O1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRpZihtICYmIG9iai5jaGlsZHJlbl9kICYmIG9iai5wYXJlbnRzKSB7XG5cdFx0XHRcdFx0XHRcdGQgPSAwO1xuXHRcdFx0XHRcdFx0XHRmb3IoaSA9IDAsIGogPSBvYmouY2hpbGRyZW5fZC5sZW5ndGg7IGkgPCBqOyBpKyspIHtcblx0XHRcdFx0XHRcdFx0XHRkID0gTWF0aC5tYXgoZCwgbVtvYmouY2hpbGRyZW5fZFtpXV0ucGFyZW50cy5sZW5ndGgpO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdGQgPSBkIC0gb2JqLnBhcmVudHMubGVuZ3RoICsgMTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGlmKGQgPD0gMCB8fCBkID09PSB1bmRlZmluZWQpIHsgZCA9IDE7IH1cblx0XHRcdFx0XHRcdGRvIHtcblx0XHRcdFx0XHRcdFx0aWYodG1wLm1heF9kZXB0aCAhPT0gdW5kZWZpbmVkICYmIHRtcC5tYXhfZGVwdGggIT09IC0xICYmIHRtcC5tYXhfZGVwdGggPCBkKSB7XG5cdFx0XHRcdFx0XHRcdFx0dGhpcy5fZGF0YS5jb3JlLmxhc3RfZXJyb3IgPSB7ICdlcnJvcicgOiAnY2hlY2snLCAncGx1Z2luJyA6ICd0eXBlcycsICdpZCcgOiAndHlwZXNfMDMnLCAncmVhc29uJyA6ICdtYXhfZGVwdGggcHJldmVudHMgZnVuY3Rpb246ICcgKyBjaGssICdkYXRhJyA6IEpTT04uc3RyaW5naWZ5KHsgJ2NoaycgOiBjaGssICdwb3MnIDogcG9zLCAnb2JqJyA6IG9iaiAmJiBvYmouaWQgPyBvYmouaWQgOiBmYWxzZSwgJ3BhcicgOiBwYXIgJiYgcGFyLmlkID8gcGFyLmlkIDogZmFsc2UgfSkgfTtcblx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0cGFyID0gdGhpcy5nZXRfbm9kZShwYXIucGFyZW50KTtcblx0XHRcdFx0XHRcdFx0dG1wID0gdGhpcy5nZXRfcnVsZXMocGFyKTtcblx0XHRcdFx0XHRcdFx0ZCsrO1xuXHRcdFx0XHRcdFx0fSB3aGlsZShwYXIpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH07XG5cdFx0LyoqXG5cdFx0ICogdXNlZCB0byByZXRyaWV2ZSB0aGUgdHlwZSBzZXR0aW5ncyBvYmplY3QgZm9yIGEgbm9kZVxuXHRcdCAqIEBuYW1lIGdldF9ydWxlcyhvYmopXG5cdFx0ICogQHBhcmFtIHttaXhlZH0gb2JqIHRoZSBub2RlIHRvIGZpbmQgdGhlIHJ1bGVzIGZvclxuXHRcdCAqIEByZXR1cm4ge09iamVjdH1cblx0XHQgKiBAcGx1Z2luIHR5cGVzXG5cdFx0ICovXG5cdFx0dGhpcy5nZXRfcnVsZXMgPSBmdW5jdGlvbiAob2JqKSB7XG5cdFx0XHRvYmogPSB0aGlzLmdldF9ub2RlKG9iaik7XG5cdFx0XHRpZighb2JqKSB7IHJldHVybiBmYWxzZTsgfVxuXHRcdFx0dmFyIHRtcCA9IHRoaXMuZ2V0X3R5cGUob2JqLCB0cnVlKTtcblx0XHRcdGlmKHRtcC5tYXhfZGVwdGggPT09IHVuZGVmaW5lZCkgeyB0bXAubWF4X2RlcHRoID0gLTE7IH1cblx0XHRcdGlmKHRtcC5tYXhfY2hpbGRyZW4gPT09IHVuZGVmaW5lZCkgeyB0bXAubWF4X2NoaWxkcmVuID0gLTE7IH1cblx0XHRcdGlmKHRtcC52YWxpZF9jaGlsZHJlbiA9PT0gdW5kZWZpbmVkKSB7IHRtcC52YWxpZF9jaGlsZHJlbiA9IC0xOyB9XG5cdFx0XHRyZXR1cm4gdG1wO1xuXHRcdH07XG5cdFx0LyoqXG5cdFx0ICogdXNlZCB0byByZXRyaWV2ZSB0aGUgdHlwZSBzdHJpbmcgb3Igc2V0dGluZ3Mgb2JqZWN0IGZvciBhIG5vZGVcblx0XHQgKiBAbmFtZSBnZXRfdHlwZShvYmogWywgcnVsZXNdKVxuXHRcdCAqIEBwYXJhbSB7bWl4ZWR9IG9iaiB0aGUgbm9kZSB0byBmaW5kIHRoZSBydWxlcyBmb3Jcblx0XHQgKiBAcGFyYW0ge0Jvb2xlYW59IHJ1bGVzIGlmIHNldCB0byBgdHJ1ZWAgaW5zdGVhZCBvZiBhIHN0cmluZyB0aGUgc2V0dGluZ3Mgb2JqZWN0IHdpbGwgYmUgcmV0dXJuZWRcblx0XHQgKiBAcmV0dXJuIHtTdHJpbmd8T2JqZWN0fVxuXHRcdCAqIEBwbHVnaW4gdHlwZXNcblx0XHQgKi9cblx0XHR0aGlzLmdldF90eXBlID0gZnVuY3Rpb24gKG9iaiwgcnVsZXMpIHtcblx0XHRcdG9iaiA9IHRoaXMuZ2V0X25vZGUob2JqKTtcblx0XHRcdHJldHVybiAoIW9iaikgPyBmYWxzZSA6ICggcnVsZXMgPyAkLmV4dGVuZCh7ICd0eXBlJyA6IG9iai50eXBlIH0sIHRoaXMuc2V0dGluZ3MudHlwZXNbb2JqLnR5cGVdKSA6IG9iai50eXBlKTtcblx0XHR9O1xuXHRcdC8qKlxuXHRcdCAqIHVzZWQgdG8gY2hhbmdlIGEgbm9kZSdzIHR5cGVcblx0XHQgKiBAbmFtZSBzZXRfdHlwZShvYmosIHR5cGUpXG5cdFx0ICogQHBhcmFtIHttaXhlZH0gb2JqIHRoZSBub2RlIHRvIGNoYW5nZVxuXHRcdCAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIHRoZSBuZXcgdHlwZVxuXHRcdCAqIEBwbHVnaW4gdHlwZXNcblx0XHQgKi9cblx0XHR0aGlzLnNldF90eXBlID0gZnVuY3Rpb24gKG9iaiwgdHlwZSkge1xuXHRcdFx0dmFyIG0gPSB0aGlzLl9tb2RlbC5kYXRhLCB0LCB0MSwgdDIsIG9sZF90eXBlLCBvbGRfaWNvbiwgaywgZCwgYTtcblx0XHRcdGlmKCQuaXNBcnJheShvYmopKSB7XG5cdFx0XHRcdG9iaiA9IG9iai5zbGljZSgpO1xuXHRcdFx0XHRmb3IodDEgPSAwLCB0MiA9IG9iai5sZW5ndGg7IHQxIDwgdDI7IHQxKyspIHtcblx0XHRcdFx0XHR0aGlzLnNldF90eXBlKG9ialt0MV0sIHR5cGUpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fVxuXHRcdFx0dCA9IHRoaXMuc2V0dGluZ3MudHlwZXM7XG5cdFx0XHRvYmogPSB0aGlzLmdldF9ub2RlKG9iaik7XG5cdFx0XHRpZighdFt0eXBlXSB8fCAhb2JqKSB7IHJldHVybiBmYWxzZTsgfVxuXHRcdFx0ZCA9IHRoaXMuZ2V0X25vZGUob2JqLCB0cnVlKTtcblx0XHRcdGlmIChkICYmIGQubGVuZ3RoKSB7XG5cdFx0XHRcdGEgPSBkLmNoaWxkcmVuKCcuanN0cmVlLWFuY2hvcicpO1xuXHRcdFx0fVxuXHRcdFx0b2xkX3R5cGUgPSBvYmoudHlwZTtcblx0XHRcdG9sZF9pY29uID0gdGhpcy5nZXRfaWNvbihvYmopO1xuXHRcdFx0b2JqLnR5cGUgPSB0eXBlO1xuXHRcdFx0aWYob2xkX2ljb24gPT09IHRydWUgfHwgIXRbb2xkX3R5cGVdIHx8ICh0W29sZF90eXBlXS5pY29uICE9PSB1bmRlZmluZWQgJiYgb2xkX2ljb24gPT09IHRbb2xkX3R5cGVdLmljb24pKSB7XG5cdFx0XHRcdHRoaXMuc2V0X2ljb24ob2JqLCB0W3R5cGVdLmljb24gIT09IHVuZGVmaW5lZCA/IHRbdHlwZV0uaWNvbiA6IHRydWUpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyByZW1vdmUgb2xkIHR5cGUgcHJvcHNcblx0XHRcdGlmKHRbb2xkX3R5cGVdICYmIHRbb2xkX3R5cGVdLmxpX2F0dHIgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2YgdFtvbGRfdHlwZV0ubGlfYXR0ciA9PT0gJ29iamVjdCcpIHtcblx0XHRcdFx0Zm9yIChrIGluIHRbb2xkX3R5cGVdLmxpX2F0dHIpIHtcblx0XHRcdFx0XHRpZiAodFtvbGRfdHlwZV0ubGlfYXR0ci5oYXNPd25Qcm9wZXJ0eShrKSkge1xuXHRcdFx0XHRcdFx0aWYgKGsgPT09ICdpZCcpIHtcblx0XHRcdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRlbHNlIGlmIChrID09PSAnY2xhc3MnKSB7XG5cdFx0XHRcdFx0XHRcdG1bb2JqLmlkXS5saV9hdHRyWydjbGFzcyddID0gKG1bb2JqLmlkXS5saV9hdHRyWydjbGFzcyddIHx8ICcnKS5yZXBsYWNlKHRbb2xkX3R5cGVdLmxpX2F0dHJba10sICcnKTtcblx0XHRcdFx0XHRcdFx0aWYgKGQpIHsgZC5yZW1vdmVDbGFzcyh0W29sZF90eXBlXS5saV9hdHRyW2tdKTsgfVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0ZWxzZSBpZiAobVtvYmouaWRdLmxpX2F0dHJba10gPT09IHRbb2xkX3R5cGVdLmxpX2F0dHJba10pIHtcblx0XHRcdFx0XHRcdFx0bVtvYmouaWRdLmxpX2F0dHJba10gPSBudWxsO1xuXHRcdFx0XHRcdFx0XHRpZiAoZCkgeyBkLnJlbW92ZUF0dHIoayk7IH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGlmKHRbb2xkX3R5cGVdICYmIHRbb2xkX3R5cGVdLmFfYXR0ciAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiB0W29sZF90eXBlXS5hX2F0dHIgPT09ICdvYmplY3QnKSB7XG5cdFx0XHRcdGZvciAoayBpbiB0W29sZF90eXBlXS5hX2F0dHIpIHtcblx0XHRcdFx0XHRpZiAodFtvbGRfdHlwZV0uYV9hdHRyLmhhc093blByb3BlcnR5KGspKSB7XG5cdFx0XHRcdFx0XHRpZiAoayA9PT0gJ2lkJykge1xuXHRcdFx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGVsc2UgaWYgKGsgPT09ICdjbGFzcycpIHtcblx0XHRcdFx0XHRcdFx0bVtvYmouaWRdLmFfYXR0clsnY2xhc3MnXSA9IChtW29iai5pZF0uYV9hdHRyWydjbGFzcyddIHx8ICcnKS5yZXBsYWNlKHRbb2xkX3R5cGVdLmFfYXR0cltrXSwgJycpO1xuXHRcdFx0XHRcdFx0XHRpZiAoYSkgeyBhLnJlbW92ZUNsYXNzKHRbb2xkX3R5cGVdLmFfYXR0cltrXSk7IH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGVsc2UgaWYgKG1bb2JqLmlkXS5hX2F0dHJba10gPT09IHRbb2xkX3R5cGVdLmFfYXR0cltrXSkge1xuXHRcdFx0XHRcdFx0XHRpZiAoayA9PT0gJ2hyZWYnKSB7XG5cdFx0XHRcdFx0XHRcdFx0bVtvYmouaWRdLmFfYXR0cltrXSA9ICcjJztcblx0XHRcdFx0XHRcdFx0XHRpZiAoYSkgeyBhLmF0dHIoJ2hyZWYnLCAnIycpOyB9XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0ZGVsZXRlIG1bb2JqLmlkXS5hX2F0dHJba107XG5cdFx0XHRcdFx0XHRcdFx0aWYgKGEpIHsgYS5yZW1vdmVBdHRyKGspOyB9XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gYWRkIG5ldyBwcm9wc1xuXHRcdFx0aWYodFt0eXBlXS5saV9hdHRyICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIHRbdHlwZV0ubGlfYXR0ciA9PT0gJ29iamVjdCcpIHtcblx0XHRcdFx0Zm9yIChrIGluIHRbdHlwZV0ubGlfYXR0cikge1xuXHRcdFx0XHRcdGlmICh0W3R5cGVdLmxpX2F0dHIuaGFzT3duUHJvcGVydHkoaykpIHtcblx0XHRcdFx0XHRcdGlmIChrID09PSAnaWQnKSB7XG5cdFx0XHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0ZWxzZSBpZiAobVtvYmouaWRdLmxpX2F0dHJba10gPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRcdFx0XHRtW29iai5pZF0ubGlfYXR0cltrXSA9IHRbdHlwZV0ubGlfYXR0cltrXTtcblx0XHRcdFx0XHRcdFx0aWYgKGQpIHtcblx0XHRcdFx0XHRcdFx0XHRpZiAoayA9PT0gJ2NsYXNzJykge1xuXHRcdFx0XHRcdFx0XHRcdFx0ZC5hZGRDbGFzcyh0W3R5cGVdLmxpX2F0dHJba10pO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRcdGQuYXR0cihrLCB0W3R5cGVdLmxpX2F0dHJba10pO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0ZWxzZSBpZiAoayA9PT0gJ2NsYXNzJykge1xuXHRcdFx0XHRcdFx0XHRtW29iai5pZF0ubGlfYXR0clsnY2xhc3MnXSA9IHRbdHlwZV0ubGlfYXR0cltrXSArICcgJyArIG1bb2JqLmlkXS5saV9hdHRyWydjbGFzcyddO1xuXHRcdFx0XHRcdFx0XHRpZiAoZCkgeyBkLmFkZENsYXNzKHRbdHlwZV0ubGlfYXR0cltrXSk7IH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGlmKHRbdHlwZV0uYV9hdHRyICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIHRbdHlwZV0uYV9hdHRyID09PSAnb2JqZWN0Jykge1xuXHRcdFx0XHRmb3IgKGsgaW4gdFt0eXBlXS5hX2F0dHIpIHtcblx0XHRcdFx0XHRpZiAodFt0eXBlXS5hX2F0dHIuaGFzT3duUHJvcGVydHkoaykpIHtcblx0XHRcdFx0XHRcdGlmIChrID09PSAnaWQnKSB7XG5cdFx0XHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0ZWxzZSBpZiAobVtvYmouaWRdLmFfYXR0cltrXSA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdFx0XHRcdG1bb2JqLmlkXS5hX2F0dHJba10gPSB0W3R5cGVdLmFfYXR0cltrXTtcblx0XHRcdFx0XHRcdFx0aWYgKGEpIHtcblx0XHRcdFx0XHRcdFx0XHRpZiAoayA9PT0gJ2NsYXNzJykge1xuXHRcdFx0XHRcdFx0XHRcdFx0YS5hZGRDbGFzcyh0W3R5cGVdLmFfYXR0cltrXSk7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdFx0YS5hdHRyKGssIHRbdHlwZV0uYV9hdHRyW2tdKTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGVsc2UgaWYgKGsgPT09ICdocmVmJyAmJiBtW29iai5pZF0uYV9hdHRyW2tdID09PSAnIycpIHtcblx0XHRcdFx0XHRcdFx0bVtvYmouaWRdLmFfYXR0clsnaHJlZiddID0gdFt0eXBlXS5hX2F0dHJbJ2hyZWYnXTtcblx0XHRcdFx0XHRcdFx0aWYgKGEpIHsgYS5hdHRyKCdocmVmJywgdFt0eXBlXS5hX2F0dHJbJ2hyZWYnXSk7IH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGVsc2UgaWYgKGsgPT09ICdjbGFzcycpIHtcblx0XHRcdFx0XHRcdFx0bVtvYmouaWRdLmFfYXR0clsnY2xhc3MnXSA9IHRbdHlwZV0uYV9hdHRyWydjbGFzcyddICsgJyAnICsgbVtvYmouaWRdLmFfYXR0clsnY2xhc3MnXTtcblx0XHRcdFx0XHRcdFx0aWYgKGEpIHsgYS5hZGRDbGFzcyh0W3R5cGVdLmFfYXR0cltrXSk7IH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fTtcblx0fTtcblx0Ly8gaW5jbHVkZSB0aGUgdHlwZXMgcGx1Z2luIGJ5IGRlZmF1bHRcblx0Ly8gJC5qc3RyZWUuZGVmYXVsdHMucGx1Z2lucy5wdXNoKFwidHlwZXNcIik7XG5cblxuLyoqXG4gKiAjIyMgVW5pcXVlIHBsdWdpblxuICpcbiAqIEVuZm9yY2VzIHRoYXQgbm8gbm9kZXMgd2l0aCB0aGUgc2FtZSBuYW1lIGNhbiBjb2V4aXN0IGFzIHNpYmxpbmdzLlxuICovXG5cblx0LyoqXG5cdCAqIHN0b3JlcyBhbGwgZGVmYXVsdHMgZm9yIHRoZSB1bmlxdWUgcGx1Z2luXG5cdCAqIEBuYW1lICQuanN0cmVlLmRlZmF1bHRzLnVuaXF1ZVxuXHQgKiBAcGx1Z2luIHVuaXF1ZVxuXHQgKi9cblx0JC5qc3RyZWUuZGVmYXVsdHMudW5pcXVlID0ge1xuXHRcdC8qKlxuXHRcdCAqIEluZGljYXRlcyBpZiB0aGUgY29tcGFyaXNvbiBzaG91bGQgYmUgY2FzZSBzZW5zaXRpdmUuIERlZmF1bHQgaXMgYGZhbHNlYC5cblx0XHQgKiBAbmFtZSAkLmpzdHJlZS5kZWZhdWx0cy51bmlxdWUuY2FzZV9zZW5zaXRpdmVcblx0XHQgKiBAcGx1Z2luIHVuaXF1ZVxuXHRcdCAqL1xuXHRcdGNhc2Vfc2Vuc2l0aXZlIDogZmFsc2UsXG5cdFx0LyoqXG5cdFx0ICogQSBjYWxsYmFjayBleGVjdXRlZCBpbiB0aGUgaW5zdGFuY2UncyBzY29wZSB3aGVuIGEgbmV3IG5vZGUgaXMgY3JlYXRlZCBhbmQgdGhlIG5hbWUgaXMgYWxyZWFkeSB0YWtlbiwgdGhlIHR3byBhcmd1bWVudHMgYXJlIHRoZSBjb25mbGljdGluZyBuYW1lIGFuZCB0aGUgY291bnRlci4gVGhlIGRlZmF1bHQgd2lsbCBwcm9kdWNlIHJlc3VsdHMgbGlrZSBgTmV3IG5vZGUgKDIpYC5cblx0XHQgKiBAbmFtZSAkLmpzdHJlZS5kZWZhdWx0cy51bmlxdWUuZHVwbGljYXRlXG5cdFx0ICogQHBsdWdpbiB1bmlxdWVcblx0XHQgKi9cblx0XHRkdXBsaWNhdGUgOiBmdW5jdGlvbiAobmFtZSwgY291bnRlcikge1xuXHRcdFx0cmV0dXJuIG5hbWUgKyAnICgnICsgY291bnRlciArICcpJztcblx0XHR9XG5cdH07XG5cblx0JC5qc3RyZWUucGx1Z2lucy51bmlxdWUgPSBmdW5jdGlvbiAob3B0aW9ucywgcGFyZW50KSB7XG5cdFx0dGhpcy5jaGVjayA9IGZ1bmN0aW9uIChjaGssIG9iaiwgcGFyLCBwb3MsIG1vcmUpIHtcblx0XHRcdGlmKHBhcmVudC5jaGVjay5jYWxsKHRoaXMsIGNoaywgb2JqLCBwYXIsIHBvcywgbW9yZSkgPT09IGZhbHNlKSB7IHJldHVybiBmYWxzZTsgfVxuXHRcdFx0b2JqID0gb2JqICYmIG9iai5pZCA/IG9iaiA6IHRoaXMuZ2V0X25vZGUob2JqKTtcblx0XHRcdHBhciA9IHBhciAmJiBwYXIuaWQgPyBwYXIgOiB0aGlzLmdldF9ub2RlKHBhcik7XG5cdFx0XHRpZighcGFyIHx8ICFwYXIuY2hpbGRyZW4pIHsgcmV0dXJuIHRydWU7IH1cblx0XHRcdHZhciBuID0gY2hrID09PSBcInJlbmFtZV9ub2RlXCIgPyBwb3MgOiBvYmoudGV4dCxcblx0XHRcdFx0YyA9IFtdLFxuXHRcdFx0XHRzID0gdGhpcy5zZXR0aW5ncy51bmlxdWUuY2FzZV9zZW5zaXRpdmUsXG5cdFx0XHRcdG0gPSB0aGlzLl9tb2RlbC5kYXRhLCBpLCBqO1xuXHRcdFx0Zm9yKGkgPSAwLCBqID0gcGFyLmNoaWxkcmVuLmxlbmd0aDsgaSA8IGo7IGkrKykge1xuXHRcdFx0XHRjLnB1c2gocyA/IG1bcGFyLmNoaWxkcmVuW2ldXS50ZXh0IDogbVtwYXIuY2hpbGRyZW5baV1dLnRleHQudG9Mb3dlckNhc2UoKSk7XG5cdFx0XHR9XG5cdFx0XHRpZighcykgeyBuID0gbi50b0xvd2VyQ2FzZSgpOyB9XG5cdFx0XHRzd2l0Y2goY2hrKSB7XG5cdFx0XHRcdGNhc2UgXCJkZWxldGVfbm9kZVwiOlxuXHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHRjYXNlIFwicmVuYW1lX25vZGVcIjpcblx0XHRcdFx0XHRpID0gKCQuaW5BcnJheShuLCBjKSA9PT0gLTEgfHwgKG9iai50ZXh0ICYmIG9iai50ZXh0WyBzID8gJ3RvU3RyaW5nJyA6ICd0b0xvd2VyQ2FzZSddKCkgPT09IG4pKTtcblx0XHRcdFx0XHRpZighaSkge1xuXHRcdFx0XHRcdFx0dGhpcy5fZGF0YS5jb3JlLmxhc3RfZXJyb3IgPSB7ICdlcnJvcicgOiAnY2hlY2snLCAncGx1Z2luJyA6ICd1bmlxdWUnLCAnaWQnIDogJ3VuaXF1ZV8wMScsICdyZWFzb24nIDogJ0NoaWxkIHdpdGggbmFtZSAnICsgbiArICcgYWxyZWFkeSBleGlzdHMuIFByZXZlbnRpbmc6ICcgKyBjaGssICdkYXRhJyA6IEpTT04uc3RyaW5naWZ5KHsgJ2NoaycgOiBjaGssICdwb3MnIDogcG9zLCAnb2JqJyA6IG9iaiAmJiBvYmouaWQgPyBvYmouaWQgOiBmYWxzZSwgJ3BhcicgOiBwYXIgJiYgcGFyLmlkID8gcGFyLmlkIDogZmFsc2UgfSkgfTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIGk7XG5cdFx0XHRcdGNhc2UgXCJjcmVhdGVfbm9kZVwiOlxuXHRcdFx0XHRcdGkgPSAoJC5pbkFycmF5KG4sIGMpID09PSAtMSk7XG5cdFx0XHRcdFx0aWYoIWkpIHtcblx0XHRcdFx0XHRcdHRoaXMuX2RhdGEuY29yZS5sYXN0X2Vycm9yID0geyAnZXJyb3InIDogJ2NoZWNrJywgJ3BsdWdpbicgOiAndW5pcXVlJywgJ2lkJyA6ICd1bmlxdWVfMDQnLCAncmVhc29uJyA6ICdDaGlsZCB3aXRoIG5hbWUgJyArIG4gKyAnIGFscmVhZHkgZXhpc3RzLiBQcmV2ZW50aW5nOiAnICsgY2hrLCAnZGF0YScgOiBKU09OLnN0cmluZ2lmeSh7ICdjaGsnIDogY2hrLCAncG9zJyA6IHBvcywgJ29iaicgOiBvYmogJiYgb2JqLmlkID8gb2JqLmlkIDogZmFsc2UsICdwYXInIDogcGFyICYmIHBhci5pZCA/IHBhci5pZCA6IGZhbHNlIH0pIH07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiBpO1xuXHRcdFx0XHRjYXNlIFwiY29weV9ub2RlXCI6XG5cdFx0XHRcdFx0aSA9ICgkLmluQXJyYXkobiwgYykgPT09IC0xKTtcblx0XHRcdFx0XHRpZighaSkge1xuXHRcdFx0XHRcdFx0dGhpcy5fZGF0YS5jb3JlLmxhc3RfZXJyb3IgPSB7ICdlcnJvcicgOiAnY2hlY2snLCAncGx1Z2luJyA6ICd1bmlxdWUnLCAnaWQnIDogJ3VuaXF1ZV8wMicsICdyZWFzb24nIDogJ0NoaWxkIHdpdGggbmFtZSAnICsgbiArICcgYWxyZWFkeSBleGlzdHMuIFByZXZlbnRpbmc6ICcgKyBjaGssICdkYXRhJyA6IEpTT04uc3RyaW5naWZ5KHsgJ2NoaycgOiBjaGssICdwb3MnIDogcG9zLCAnb2JqJyA6IG9iaiAmJiBvYmouaWQgPyBvYmouaWQgOiBmYWxzZSwgJ3BhcicgOiBwYXIgJiYgcGFyLmlkID8gcGFyLmlkIDogZmFsc2UgfSkgfTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIGk7XG5cdFx0XHRcdGNhc2UgXCJtb3ZlX25vZGVcIjpcblx0XHRcdFx0XHRpID0gKCAob2JqLnBhcmVudCA9PT0gcGFyLmlkICYmICghbW9yZSB8fCAhbW9yZS5pc19tdWx0aSkpIHx8ICQuaW5BcnJheShuLCBjKSA9PT0gLTEpO1xuXHRcdFx0XHRcdGlmKCFpKSB7XG5cdFx0XHRcdFx0XHR0aGlzLl9kYXRhLmNvcmUubGFzdF9lcnJvciA9IHsgJ2Vycm9yJyA6ICdjaGVjaycsICdwbHVnaW4nIDogJ3VuaXF1ZScsICdpZCcgOiAndW5pcXVlXzAzJywgJ3JlYXNvbicgOiAnQ2hpbGQgd2l0aCBuYW1lICcgKyBuICsgJyBhbHJlYWR5IGV4aXN0cy4gUHJldmVudGluZzogJyArIGNoaywgJ2RhdGEnIDogSlNPTi5zdHJpbmdpZnkoeyAnY2hrJyA6IGNoaywgJ3BvcycgOiBwb3MsICdvYmonIDogb2JqICYmIG9iai5pZCA/IG9iai5pZCA6IGZhbHNlLCAncGFyJyA6IHBhciAmJiBwYXIuaWQgPyBwYXIuaWQgOiBmYWxzZSB9KSB9O1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gaTtcblx0XHRcdH1cblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH07XG5cdFx0dGhpcy5jcmVhdGVfbm9kZSA9IGZ1bmN0aW9uIChwYXIsIG5vZGUsIHBvcywgY2FsbGJhY2ssIGlzX2xvYWRlZCkge1xuXHRcdFx0aWYoIW5vZGUgfHwgbm9kZS50ZXh0ID09PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0aWYocGFyID09PSBudWxsKSB7XG5cdFx0XHRcdFx0cGFyID0gJC5qc3RyZWUucm9vdDtcblx0XHRcdFx0fVxuXHRcdFx0XHRwYXIgPSB0aGlzLmdldF9ub2RlKHBhcik7XG5cdFx0XHRcdGlmKCFwYXIpIHtcblx0XHRcdFx0XHRyZXR1cm4gcGFyZW50LmNyZWF0ZV9ub2RlLmNhbGwodGhpcywgcGFyLCBub2RlLCBwb3MsIGNhbGxiYWNrLCBpc19sb2FkZWQpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHBvcyA9IHBvcyA9PT0gdW5kZWZpbmVkID8gXCJsYXN0XCIgOiBwb3M7XG5cdFx0XHRcdGlmKCFwb3MudG9TdHJpbmcoKS5tYXRjaCgvXihiZWZvcmV8YWZ0ZXIpJC8pICYmICFpc19sb2FkZWQgJiYgIXRoaXMuaXNfbG9hZGVkKHBhcikpIHtcblx0XHRcdFx0XHRyZXR1cm4gcGFyZW50LmNyZWF0ZV9ub2RlLmNhbGwodGhpcywgcGFyLCBub2RlLCBwb3MsIGNhbGxiYWNrLCBpc19sb2FkZWQpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmKCFub2RlKSB7IG5vZGUgPSB7fTsgfVxuXHRcdFx0XHR2YXIgdG1wLCBuLCBkcGMsIGksIGosIG0gPSB0aGlzLl9tb2RlbC5kYXRhLCBzID0gdGhpcy5zZXR0aW5ncy51bmlxdWUuY2FzZV9zZW5zaXRpdmUsIGNiID0gdGhpcy5zZXR0aW5ncy51bmlxdWUuZHVwbGljYXRlO1xuXHRcdFx0XHRuID0gdG1wID0gdGhpcy5nZXRfc3RyaW5nKCdOZXcgbm9kZScpO1xuXHRcdFx0XHRkcGMgPSBbXTtcblx0XHRcdFx0Zm9yKGkgPSAwLCBqID0gcGFyLmNoaWxkcmVuLmxlbmd0aDsgaSA8IGo7IGkrKykge1xuXHRcdFx0XHRcdGRwYy5wdXNoKHMgPyBtW3Bhci5jaGlsZHJlbltpXV0udGV4dCA6IG1bcGFyLmNoaWxkcmVuW2ldXS50ZXh0LnRvTG93ZXJDYXNlKCkpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGkgPSAxO1xuXHRcdFx0XHR3aGlsZSgkLmluQXJyYXkocyA/IG4gOiBuLnRvTG93ZXJDYXNlKCksIGRwYykgIT09IC0xKSB7XG5cdFx0XHRcdFx0biA9IGNiLmNhbGwodGhpcywgdG1wLCAoKytpKSkudG9TdHJpbmcoKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRub2RlLnRleHQgPSBuO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHBhcmVudC5jcmVhdGVfbm9kZS5jYWxsKHRoaXMsIHBhciwgbm9kZSwgcG9zLCBjYWxsYmFjaywgaXNfbG9hZGVkKTtcblx0XHR9O1xuXHR9O1xuXG5cdC8vIGluY2x1ZGUgdGhlIHVuaXF1ZSBwbHVnaW4gYnkgZGVmYXVsdFxuXHQvLyAkLmpzdHJlZS5kZWZhdWx0cy5wbHVnaW5zLnB1c2goXCJ1bmlxdWVcIik7XG5cblxuLyoqXG4gKiAjIyMgV2hvbGVyb3cgcGx1Z2luXG4gKlxuICogTWFrZXMgZWFjaCBub2RlIGFwcGVhciBibG9jayBsZXZlbC4gTWFraW5nIHNlbGVjdGlvbiBlYXNpZXIuIE1heSBjYXVzZSBzbG93IGRvd24gZm9yIGxhcmdlIHRyZWVzIGluIG9sZCBicm93c2Vycy5cbiAqL1xuXG5cdHZhciBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdESVYnKTtcblx0ZGl2LnNldEF0dHJpYnV0ZSgndW5zZWxlY3RhYmxlJywnb24nKTtcblx0ZGl2LnNldEF0dHJpYnV0ZSgncm9sZScsJ3ByZXNlbnRhdGlvbicpO1xuXHRkaXYuY2xhc3NOYW1lID0gJ2pzdHJlZS13aG9sZXJvdyc7XG5cdGRpdi5pbm5lckhUTUwgPSAnJiMxNjA7Jztcblx0JC5qc3RyZWUucGx1Z2lucy53aG9sZXJvdyA9IGZ1bmN0aW9uIChvcHRpb25zLCBwYXJlbnQpIHtcblx0XHR0aGlzLmJpbmQgPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHRwYXJlbnQuYmluZC5jYWxsKHRoaXMpO1xuXG5cdFx0XHR0aGlzLmVsZW1lbnRcblx0XHRcdFx0Lm9uKCdyZWFkeS5qc3RyZWUgc2V0X3N0YXRlLmpzdHJlZScsICQucHJveHkoZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdFx0dGhpcy5oaWRlX2RvdHMoKTtcblx0XHRcdFx0XHR9LCB0aGlzKSlcblx0XHRcdFx0Lm9uKFwiaW5pdC5qc3RyZWUgbG9hZGluZy5qc3RyZWUgcmVhZHkuanN0cmVlXCIsICQucHJveHkoZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdFx0Ly9kaXYuc3R5bGUuaGVpZ2h0ID0gdGhpcy5fZGF0YS5jb3JlLmxpX2hlaWdodCArICdweCc7XG5cdFx0XHRcdFx0XHR0aGlzLmdldF9jb250YWluZXJfdWwoKS5hZGRDbGFzcygnanN0cmVlLXdob2xlcm93LXVsJyk7XG5cdFx0XHRcdFx0fSwgdGhpcykpXG5cdFx0XHRcdC5vbihcImRlc2VsZWN0X2FsbC5qc3RyZWVcIiwgJC5wcm94eShmdW5jdGlvbiAoZSwgZGF0YSkge1xuXHRcdFx0XHRcdFx0dGhpcy5lbGVtZW50LmZpbmQoJy5qc3RyZWUtd2hvbGVyb3ctY2xpY2tlZCcpLnJlbW92ZUNsYXNzKCdqc3RyZWUtd2hvbGVyb3ctY2xpY2tlZCcpO1xuXHRcdFx0XHRcdH0sIHRoaXMpKVxuXHRcdFx0XHQub24oXCJjaGFuZ2VkLmpzdHJlZVwiLCAkLnByb3h5KGZ1bmN0aW9uIChlLCBkYXRhKSB7XG5cdFx0XHRcdFx0XHR0aGlzLmVsZW1lbnQuZmluZCgnLmpzdHJlZS13aG9sZXJvdy1jbGlja2VkJykucmVtb3ZlQ2xhc3MoJ2pzdHJlZS13aG9sZXJvdy1jbGlja2VkJyk7XG5cdFx0XHRcdFx0XHR2YXIgdG1wID0gZmFsc2UsIGksIGo7XG5cdFx0XHRcdFx0XHRmb3IoaSA9IDAsIGogPSBkYXRhLnNlbGVjdGVkLmxlbmd0aDsgaSA8IGo7IGkrKykge1xuXHRcdFx0XHRcdFx0XHR0bXAgPSB0aGlzLmdldF9ub2RlKGRhdGEuc2VsZWN0ZWRbaV0sIHRydWUpO1xuXHRcdFx0XHRcdFx0XHRpZih0bXAgJiYgdG1wLmxlbmd0aCkge1xuXHRcdFx0XHRcdFx0XHRcdHRtcC5jaGlsZHJlbignLmpzdHJlZS13aG9sZXJvdycpLmFkZENsYXNzKCdqc3RyZWUtd2hvbGVyb3ctY2xpY2tlZCcpO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSwgdGhpcykpXG5cdFx0XHRcdC5vbihcIm9wZW5fbm9kZS5qc3RyZWVcIiwgJC5wcm94eShmdW5jdGlvbiAoZSwgZGF0YSkge1xuXHRcdFx0XHRcdFx0dGhpcy5nZXRfbm9kZShkYXRhLm5vZGUsIHRydWUpLmZpbmQoJy5qc3RyZWUtY2xpY2tlZCcpLnBhcmVudCgpLmNoaWxkcmVuKCcuanN0cmVlLXdob2xlcm93JykuYWRkQ2xhc3MoJ2pzdHJlZS13aG9sZXJvdy1jbGlja2VkJyk7XG5cdFx0XHRcdFx0fSwgdGhpcykpXG5cdFx0XHRcdC5vbihcImhvdmVyX25vZGUuanN0cmVlIGRlaG92ZXJfbm9kZS5qc3RyZWVcIiwgJC5wcm94eShmdW5jdGlvbiAoZSwgZGF0YSkge1xuXHRcdFx0XHRcdFx0aWYoZS50eXBlID09PSBcImhvdmVyX25vZGVcIiAmJiB0aGlzLmlzX2Rpc2FibGVkKGRhdGEubm9kZSkpIHsgcmV0dXJuOyB9XG5cdFx0XHRcdFx0XHR0aGlzLmdldF9ub2RlKGRhdGEubm9kZSwgdHJ1ZSkuY2hpbGRyZW4oJy5qc3RyZWUtd2hvbGVyb3cnKVtlLnR5cGUgPT09IFwiaG92ZXJfbm9kZVwiP1wiYWRkQ2xhc3NcIjpcInJlbW92ZUNsYXNzXCJdKCdqc3RyZWUtd2hvbGVyb3ctaG92ZXJlZCcpO1xuXHRcdFx0XHRcdH0sIHRoaXMpKVxuXHRcdFx0XHQub24oXCJjb250ZXh0bWVudS5qc3RyZWVcIiwgXCIuanN0cmVlLXdob2xlcm93XCIsICQucHJveHkoZnVuY3Rpb24gKGUpIHtcblx0XHRcdFx0XHRcdGlmICh0aGlzLl9kYXRhLmNvbnRleHRtZW51KSB7XG5cdFx0XHRcdFx0XHRcdGUucHJldmVudERlZmF1bHQoKTtcblx0XHRcdFx0XHRcdFx0dmFyIHRtcCA9ICQuRXZlbnQoJ2NvbnRleHRtZW51JywgeyBtZXRhS2V5IDogZS5tZXRhS2V5LCBjdHJsS2V5IDogZS5jdHJsS2V5LCBhbHRLZXkgOiBlLmFsdEtleSwgc2hpZnRLZXkgOiBlLnNoaWZ0S2V5LCBwYWdlWCA6IGUucGFnZVgsIHBhZ2VZIDogZS5wYWdlWSB9KTtcblx0XHRcdFx0XHRcdFx0JChlLmN1cnJlbnRUYXJnZXQpLmNsb3Nlc3QoXCIuanN0cmVlLW5vZGVcIikuY2hpbGRyZW4oXCIuanN0cmVlLWFuY2hvclwiKS5maXJzdCgpLnRyaWdnZXIodG1wKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9LCB0aGlzKSlcblx0XHRcdFx0LyohXG5cdFx0XHRcdC5vbihcIm1vdXNlZG93bi5qc3RyZWUgdG91Y2hzdGFydC5qc3RyZWVcIiwgXCIuanN0cmVlLXdob2xlcm93XCIsIGZ1bmN0aW9uIChlKSB7XG5cdFx0XHRcdFx0XHRpZihlLnRhcmdldCA9PT0gZS5jdXJyZW50VGFyZ2V0KSB7XG5cdFx0XHRcdFx0XHRcdHZhciBhID0gJChlLmN1cnJlbnRUYXJnZXQpLmNsb3Nlc3QoXCIuanN0cmVlLW5vZGVcIikuY2hpbGRyZW4oXCIuanN0cmVlLWFuY2hvclwiKTtcblx0XHRcdFx0XHRcdFx0ZS50YXJnZXQgPSBhWzBdO1xuXHRcdFx0XHRcdFx0XHRhLnRyaWdnZXIoZSk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSlcblx0XHRcdFx0Ki9cblx0XHRcdFx0Lm9uKFwiY2xpY2suanN0cmVlXCIsIFwiLmpzdHJlZS13aG9sZXJvd1wiLCBmdW5jdGlvbiAoZSkge1xuXHRcdFx0XHRcdFx0ZS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcblx0XHRcdFx0XHRcdHZhciB0bXAgPSAkLkV2ZW50KCdjbGljaycsIHsgbWV0YUtleSA6IGUubWV0YUtleSwgY3RybEtleSA6IGUuY3RybEtleSwgYWx0S2V5IDogZS5hbHRLZXksIHNoaWZ0S2V5IDogZS5zaGlmdEtleSB9KTtcblx0XHRcdFx0XHRcdCQoZS5jdXJyZW50VGFyZ2V0KS5jbG9zZXN0KFwiLmpzdHJlZS1ub2RlXCIpLmNoaWxkcmVuKFwiLmpzdHJlZS1hbmNob3JcIikuZmlyc3QoKS50cmlnZ2VyKHRtcCkuZm9jdXMoKTtcblx0XHRcdFx0XHR9KVxuXHRcdFx0XHQub24oXCJkYmxjbGljay5qc3RyZWVcIiwgXCIuanN0cmVlLXdob2xlcm93XCIsIGZ1bmN0aW9uIChlKSB7XG5cdFx0XHRcdFx0XHRlLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xuXHRcdFx0XHRcdFx0dmFyIHRtcCA9ICQuRXZlbnQoJ2RibGNsaWNrJywgeyBtZXRhS2V5IDogZS5tZXRhS2V5LCBjdHJsS2V5IDogZS5jdHJsS2V5LCBhbHRLZXkgOiBlLmFsdEtleSwgc2hpZnRLZXkgOiBlLnNoaWZ0S2V5IH0pO1xuXHRcdFx0XHRcdFx0JChlLmN1cnJlbnRUYXJnZXQpLmNsb3Nlc3QoXCIuanN0cmVlLW5vZGVcIikuY2hpbGRyZW4oXCIuanN0cmVlLWFuY2hvclwiKS5maXJzdCgpLnRyaWdnZXIodG1wKS5mb2N1cygpO1xuXHRcdFx0XHRcdH0pXG5cdFx0XHRcdC5vbihcImNsaWNrLmpzdHJlZVwiLCBcIi5qc3RyZWUtbGVhZiA+IC5qc3RyZWUtb2NsXCIsICQucHJveHkoZnVuY3Rpb24gKGUpIHtcblx0XHRcdFx0XHRcdGUuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG5cdFx0XHRcdFx0XHR2YXIgdG1wID0gJC5FdmVudCgnY2xpY2snLCB7IG1ldGFLZXkgOiBlLm1ldGFLZXksIGN0cmxLZXkgOiBlLmN0cmxLZXksIGFsdEtleSA6IGUuYWx0S2V5LCBzaGlmdEtleSA6IGUuc2hpZnRLZXkgfSk7XG5cdFx0XHRcdFx0XHQkKGUuY3VycmVudFRhcmdldCkuY2xvc2VzdChcIi5qc3RyZWUtbm9kZVwiKS5jaGlsZHJlbihcIi5qc3RyZWUtYW5jaG9yXCIpLmZpcnN0KCkudHJpZ2dlcih0bXApLmZvY3VzKCk7XG5cdFx0XHRcdFx0fSwgdGhpcykpXG5cdFx0XHRcdC5vbihcIm1vdXNlb3Zlci5qc3RyZWVcIiwgXCIuanN0cmVlLXdob2xlcm93LCAuanN0cmVlLWljb25cIiwgJC5wcm94eShmdW5jdGlvbiAoZSkge1xuXHRcdFx0XHRcdFx0ZS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcblx0XHRcdFx0XHRcdGlmKCF0aGlzLmlzX2Rpc2FibGVkKGUuY3VycmVudFRhcmdldCkpIHtcblx0XHRcdFx0XHRcdFx0dGhpcy5ob3Zlcl9ub2RlKGUuY3VycmVudFRhcmdldCk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdFx0fSwgdGhpcykpXG5cdFx0XHRcdC5vbihcIm1vdXNlbGVhdmUuanN0cmVlXCIsIFwiLmpzdHJlZS1ub2RlXCIsICQucHJveHkoZnVuY3Rpb24gKGUpIHtcblx0XHRcdFx0XHRcdHRoaXMuZGVob3Zlcl9ub2RlKGUuY3VycmVudFRhcmdldCk7XG5cdFx0XHRcdFx0fSwgdGhpcykpO1xuXHRcdH07XG5cdFx0dGhpcy50ZWFyZG93biA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdGlmKHRoaXMuc2V0dGluZ3Mud2hvbGVyb3cpIHtcblx0XHRcdFx0dGhpcy5lbGVtZW50LmZpbmQoXCIuanN0cmVlLXdob2xlcm93XCIpLnJlbW92ZSgpO1xuXHRcdFx0fVxuXHRcdFx0cGFyZW50LnRlYXJkb3duLmNhbGwodGhpcyk7XG5cdFx0fTtcblx0XHR0aGlzLnJlZHJhd19ub2RlID0gZnVuY3Rpb24ob2JqLCBkZWVwLCBjYWxsYmFjaywgZm9yY2VfcmVuZGVyKSB7XG5cdFx0XHRvYmogPSBwYXJlbnQucmVkcmF3X25vZGUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0XHRcdGlmKG9iaikge1xuXHRcdFx0XHR2YXIgdG1wID0gZGl2LmNsb25lTm9kZSh0cnVlKTtcblx0XHRcdFx0Ly90bXAuc3R5bGUuaGVpZ2h0ID0gdGhpcy5fZGF0YS5jb3JlLmxpX2hlaWdodCArICdweCc7XG5cdFx0XHRcdGlmKCQuaW5BcnJheShvYmouaWQsIHRoaXMuX2RhdGEuY29yZS5zZWxlY3RlZCkgIT09IC0xKSB7IHRtcC5jbGFzc05hbWUgKz0gJyBqc3RyZWUtd2hvbGVyb3ctY2xpY2tlZCc7IH1cblx0XHRcdFx0aWYodGhpcy5fZGF0YS5jb3JlLmZvY3VzZWQgJiYgdGhpcy5fZGF0YS5jb3JlLmZvY3VzZWQgPT09IG9iai5pZCkgeyB0bXAuY2xhc3NOYW1lICs9ICcganN0cmVlLXdob2xlcm93LWhvdmVyZWQnOyB9XG5cdFx0XHRcdG9iai5pbnNlcnRCZWZvcmUodG1wLCBvYmouY2hpbGROb2Rlc1swXSk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gb2JqO1xuXHRcdH07XG5cdH07XG5cdC8vIGluY2x1ZGUgdGhlIHdob2xlcm93IHBsdWdpbiBieSBkZWZhdWx0XG5cdC8vICQuanN0cmVlLmRlZmF1bHRzLnBsdWdpbnMucHVzaChcIndob2xlcm93XCIpO1xuXHRpZihkb2N1bWVudC5yZWdpc3RlckVsZW1lbnQgJiYgT2JqZWN0ICYmIE9iamVjdC5jcmVhdGUpIHtcblx0XHR2YXIgcHJvdG8gPSBPYmplY3QuY3JlYXRlKEhUTUxFbGVtZW50LnByb3RvdHlwZSk7XG5cdFx0cHJvdG8uY3JlYXRlZENhbGxiYWNrID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0dmFyIGMgPSB7IGNvcmUgOiB7fSwgcGx1Z2lucyA6IFtdIH0sIGk7XG5cdFx0XHRmb3IoaSBpbiAkLmpzdHJlZS5wbHVnaW5zKSB7XG5cdFx0XHRcdGlmKCQuanN0cmVlLnBsdWdpbnMuaGFzT3duUHJvcGVydHkoaSkgJiYgdGhpcy5hdHRyaWJ1dGVzW2ldKSB7XG5cdFx0XHRcdFx0Yy5wbHVnaW5zLnB1c2goaSk7XG5cdFx0XHRcdFx0aWYodGhpcy5nZXRBdHRyaWJ1dGUoaSkgJiYgSlNPTi5wYXJzZSh0aGlzLmdldEF0dHJpYnV0ZShpKSkpIHtcblx0XHRcdFx0XHRcdGNbaV0gPSBKU09OLnBhcnNlKHRoaXMuZ2V0QXR0cmlidXRlKGkpKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGZvcihpIGluICQuanN0cmVlLmRlZmF1bHRzLmNvcmUpIHtcblx0XHRcdFx0aWYoJC5qc3RyZWUuZGVmYXVsdHMuY29yZS5oYXNPd25Qcm9wZXJ0eShpKSAmJiB0aGlzLmF0dHJpYnV0ZXNbaV0pIHtcblx0XHRcdFx0XHRjLmNvcmVbaV0gPSBKU09OLnBhcnNlKHRoaXMuZ2V0QXR0cmlidXRlKGkpKSB8fCB0aGlzLmdldEF0dHJpYnV0ZShpKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0JCh0aGlzKS5qc3RyZWUoYyk7XG5cdFx0fTtcblx0XHQvLyBwcm90by5hdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2sgPSBmdW5jdGlvbiAobmFtZSwgcHJldmlvdXMsIHZhbHVlKSB7IH07XG5cdFx0dHJ5IHtcblx0XHRcdGRvY3VtZW50LnJlZ2lzdGVyRWxlbWVudChcInZha2F0YS1qc3RyZWVcIiwgeyBwcm90b3R5cGU6IHByb3RvIH0pO1xuXHRcdH0gY2F0Y2goaWdub3JlKSB7IH1cblx0fVxuXG59KSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2pzdHJlZS9kaXN0L2pzdHJlZS5qc1xuLy8gbW9kdWxlIGlkID0gNTlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8ga25vY2tvdXQtcG9zdGJveCAwLjUuMiB8IChjKSAyMDE1IFJ5YW4gTmllbWV5ZXIgfCAgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZVxuOyhmdW5jdGlvbihmYWN0b3J5KSB7XG4gICAgLy9Db21tb25KU1xuICAgIGlmICh0eXBlb2YgcmVxdWlyZSA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBleHBvcnRzID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBtb2R1bGUgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgZmFjdG9yeShyZXF1aXJlKFwia25vY2tvdXRcIiksIGV4cG9ydHMpO1xuICAgIC8vQU1EXG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCkge1xuICAgICAgICBkZWZpbmUoW1wia25vY2tvdXRcIiwgXCJleHBvcnRzXCJdLCBmYWN0b3J5KTtcbiAgICAvL25vcm1hbCBzY3JpcHQgdGFnXG4gICAgfSBlbHNlIHtcbiAgICAgICAgZmFjdG9yeShrbywga28ucG9zdGJveCA9IHt9KTtcbiAgICB9XG59KGZ1bmN0aW9uKGtvLCBleHBvcnRzLCB1bmRlZmluZWQpIHtcbiAgICB2YXIgZGlzcG9zZVRvcGljU3Vic2NyaXB0aW9uLCBleGlzdGluZ1N1YnNjcmliZSxcblx0XHRzdWJzY3JpcHRpb25zID0ge30sXG5cdFx0c3ViSWQgPSAxO1xuXG5cdGV4cG9ydHMuc3Vic2NyaXB0aW9ucyA9IHN1YnNjcmlwdGlvbnM7XG5cbiAgICAvL2NyZWF0ZSBhIGdsb2JhbCBwb3N0Ym94IHRoYXQgc3VwcG9ydHMgc3Vic2NyaWJpbmcvcHVibGlzaGluZ1xuICAgIGtvLnN1YnNjcmliYWJsZS5jYWxsKGV4cG9ydHMpO1xuXG4gICAgLy9rZWVwIGEgY2FjaGUgb2YgdGhlIGxhdGVzdCB2YWx1ZSBhbmQgc3Vic2NyaWJlcnNcbiAgICBleHBvcnRzLnRvcGljQ2FjaGUgPSB7fTtcblxuICAgIC8vYWxsb3cgY3VzdG9taXphdGlvbiBvZiB0aGUgZnVuY3Rpb24gdXNlZCB0byBzZXJpYWxpemUgdmFsdWVzIGZvciB0aGUgdG9waWMgY2FjaGVcbiAgICBleHBvcnRzLnNlcmlhbGl6ZXIgPSBrby50b0pTT047XG5cbiAgICAvL3dyYXAgbm90aWZ5U3Vic2NyaWJlcnMgcGFzc2luZyB0b3BpYyBmaXJzdCBhbmQgY2FjaGluZyBsYXRlc3QgdmFsdWVcbiAgICBleHBvcnRzLnB1Ymxpc2ggPSBmdW5jdGlvbih0b3BpYywgdmFsdWUpIHtcbiAgICAgICAgaWYgKHRvcGljKSB7XG4gICAgICAgICAgICAvL2tlZXAgdGhlIHZhbHVlIGFuZCBhIHNlcmlhbGl6ZWQgdmVyc2lvbiBmb3IgY29tcGFyaXNvblxuICAgICAgICAgICAgZXhwb3J0cy50b3BpY0NhY2hlW3RvcGljXSA9IHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgICAgICAgICAgc2VyaWFsaXplZDogZXhwb3J0cy5zZXJpYWxpemVyKHZhbHVlKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGV4cG9ydHMubm90aWZ5U3Vic2NyaWJlcnModmFsdWUsIHRvcGljKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvL3Byb3ZpZGUgYSBzdWJzY3JpYmUgQVBJIGZvciB0aGUgcG9zdGJveCB0aGF0IHRha2VzIGluIHRoZSB0b3BpYyBhcyBmaXJzdCBhcmdcbiAgICBleGlzdGluZ1N1YnNjcmliZSA9IGV4cG9ydHMuc3Vic2NyaWJlO1xuICAgIGV4cG9ydHMuc3Vic2NyaWJlID0gZnVuY3Rpb24odG9waWMsIGFjdGlvbiwgdGFyZ2V0LCBpbml0aWFsaXplV2l0aExhdGVzdFZhbHVlKSB7XG4gICAgICAgIHZhciBzdWJzY3JpcHRpb24sIGN1cnJlbnQsIGV4aXN0aW5nRGlzcG9zZTtcblxuICAgICAgICBpZiAodG9waWMpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdGFyZ2V0ID09PSBcImJvb2xlYW5cIikge1xuICAgICAgICAgICAgICAgIGluaXRpYWxpemVXaXRoTGF0ZXN0VmFsdWUgPSB0YXJnZXQ7XG4gICAgICAgICAgICAgICAgdGFyZ2V0ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzdWJzY3JpcHRpb24gPSBleGlzdGluZ1N1YnNjcmliZS5jYWxsKGV4cG9ydHMsIGFjdGlvbiwgdGFyZ2V0LCB0b3BpYyk7XG5cdFx0XHRzdWJzY3JpcHRpb24uc3ViSWQgPSArK3N1YklkO1xuXHRcdFx0c3Vic2NyaXB0aW9uc1sgc3ViSWQgXSA9IHN1YnNjcmlwdGlvbjtcblxuICAgICAgICAgICAgaWYgKGluaXRpYWxpemVXaXRoTGF0ZXN0VmFsdWUpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50ID0gZXhwb3J0cy50b3BpY0NhY2hlW3RvcGljXTtcblxuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgYWN0aW9uLmNhbGwodGFyZ2V0LCBjdXJyZW50LnZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cblx0XHRcdGV4aXN0aW5nRGlzcG9zZSA9IHN1YnNjcmlwdGlvbi5kaXNwb3NlO1xuXHRcdFx0c3Vic2NyaXB0aW9uLmRpc3Bvc2UgPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0ZGVsZXRlIHN1YnNjcmlwdGlvbnNbc3Vic2NyaXB0aW9uLnN1YklkXTtcblx0XHRcdFx0ZXhpc3RpbmdEaXNwb3NlLmNhbGwoc3Vic2NyaXB0aW9uKTtcblx0XHRcdH07XG5cbiAgICAgICAgICAgIHJldHVybiBzdWJzY3JpcHRpb247XG4gICAgICAgIH1cbiAgICB9O1xuXG5cdC8vY2xlYW4gdXAgYWxsIHN1YnNjcmlwdGlvbnMgYW5kIHJlZmVyZW5jZXNcblx0ZXhwb3J0cy5yZXNldCA9IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBzdWJzY3JpcHRpb247XG5cblx0XHRmb3IgKHZhciBpZCBpbiBzdWJzY3JpcHRpb25zKSB7XG5cdFx0XHRpZiAoc3Vic2NyaXB0aW9ucy5oYXNPd25Qcm9wZXJ0eShpZCkpIHtcblx0XHRcdFx0c3Vic2NyaXB0aW9uID0gc3Vic2NyaXB0aW9uc1tpZF07XG5cblx0XHRcdFx0aWYgKHN1YnNjcmlwdGlvbiAmJiB0eXBlb2Ygc3Vic2NyaXB0aW9uLmRpc3Bvc2UgPT09IFwiZnVuY3Rpb25cIikge1xuXHRcdFx0XHRcdHN1YnNjcmlwdGlvbi5kaXNwb3NlKCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRleHBvcnRzLnRvcGljQ2FjaGUgPSB7fTtcblx0fTtcblxuICAgIC8vYnkgZGVmYXVsdCBwdWJsaXNoIHdoZW4gdGhlIHByZXZpb3VzIGNhY2hlZCB2YWx1ZSBkb2VzIG5vdCBlcXVhbCB0aGUgbmV3IHZhbHVlXG4gICAgZXhwb3J0cy5kZWZhdWx0Q29tcGFyZXIgPSBmdW5jdGlvbihuZXdWYWx1ZSwgY2FjaGVJdGVtKSB7XG4gICAgICAgIHJldHVybiBjYWNoZUl0ZW0gJiYgZXhwb3J0cy5zZXJpYWxpemVyKG5ld1ZhbHVlKSA9PT0gY2FjaGVJdGVtLnNlcmlhbGl6ZWQ7XG4gICAgfTtcblxuICAgIC8vYXVnbWVudCBvYnNlcnZhYmxlcy9jb21wdXRlZHMgd2l0aCB0aGUgYWJpbGl0eSB0byBhdXRvbWF0aWNhbGx5IHB1Ymxpc2ggdXBkYXRlcyBvbiBhIHRvcGljXG4gICAga28uc3Vic2NyaWJhYmxlLmZuLnB1Ymxpc2hPbiA9IGZ1bmN0aW9uKHRvcGljLCBza2lwSW5pdGlhbE9yRXF1YWxpdHlDb21wYXJlciwgZXF1YWxpdHlDb21wYXJlcikge1xuICAgICAgICB2YXIgc2tpcEluaXRpYWxQdWJsaXNoLCBzdWJzY3JpcHRpb24sIGV4aXN0aW5nRGlzcG9zZTtcblxuICAgICAgICBpZiAodG9waWMpIHtcbiAgICAgICAgICAgIC8vYWxsb3cgcGFzc2luZyB0aGUgZXF1YWxpdHlDb21wYXJlciBhcyB0aGUgc2Vjb25kIGFyZ3VtZW50XG4gICAgICAgICAgICBpZiAodHlwZW9mIHNraXBJbml0aWFsT3JFcXVhbGl0eUNvbXBhcmVyID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICBlcXVhbGl0eUNvbXBhcmVyID0gc2tpcEluaXRpYWxPckVxdWFsaXR5Q29tcGFyZXI7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHNraXBJbml0aWFsUHVibGlzaCA9IHNraXBJbml0aWFsT3JFcXVhbGl0eUNvbXBhcmVyO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBlcXVhbGl0eUNvbXBhcmVyID0gZXF1YWxpdHlDb21wYXJlciB8fCBleHBvcnRzLmRlZmF1bHRDb21wYXJlcjtcblxuICAgICAgICAgICAgLy9yZW1vdmUgYW55IGV4aXN0aW5nIHN1YnNcbiAgICAgICAgICAgIGRpc3Bvc2VUb3BpY1N1YnNjcmlwdGlvbi5jYWxsKHRoaXMsIHRvcGljLCBcInB1Ymxpc2hPblwiKTtcblxuICAgICAgICAgICAgLy9rZWVwIGEgcmVmZXJlbmNlIHRvIHRoZSBzdWJzY3JpcHRpb24sIHNvIHdlIGNhbiBzdG9wIHB1Ymxpc2hpbmdcbiAgICAgICAgICAgIHN1YnNjcmlwdGlvbiA9IHRoaXMuc3Vic2NyaWJlKGZ1bmN0aW9uKG5ld1ZhbHVlKSB7XG5cdFx0XHRcdGlmICghZXF1YWxpdHlDb21wYXJlci5jYWxsKHRoaXMsIG5ld1ZhbHVlLCBleHBvcnRzLnRvcGljQ2FjaGVbdG9waWNdKSkge1xuXHRcdFx0XHRcdGV4cG9ydHMucHVibGlzaCh0b3BpYywgbmV3VmFsdWUpO1xuXHRcdFx0XHR9XG5cdFx0XHR9LCB0aGlzKTtcblxuXHRcdFx0Ly90cmFjayB0aGUgc3Vic2NyaXB0aW9uIGluIGNhc2Ugb2YgYSByZXNldFxuXHRcdFx0c3Vic2NyaXB0aW9uLmlkID0gKytzdWJJZDtcblx0XHRcdHN1YnNjcmlwdGlvbnNbc3ViSWRdID0gc3Vic2NyaXB0aW9uO1xuXG5cdFx0XHQvL2Vuc3VyZSB0aGF0IHdlIGNsZWFudXAgcG9pbnRlcnMgdG8gc3Vic2NyaXB0aW9uIG9uIGRpc3Bvc2Vcblx0XHRcdGV4aXN0aW5nRGlzcG9zZSA9IHN1YnNjcmlwdGlvbi5kaXNwb3NlO1xuXHRcdFx0c3Vic2NyaXB0aW9uLmRpc3Bvc2UgPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0ZGVsZXRlIHRoaXMucG9zdGJveFN1YnNbdG9waWNdLnB1Ymxpc2hPbjtcblx0XHRcdFx0ZGVsZXRlIHN1YnNjcmlwdGlvbnNbc3Vic2NyaXB0aW9uLmlkXTtcblxuXHRcdFx0XHRleGlzdGluZ0Rpc3Bvc2UuY2FsbChzdWJzY3JpcHRpb24pO1xuXHRcdFx0fS5iaW5kKHRoaXMpO1xuXG5cdFx0XHR0aGlzLnBvc3Rib3hTdWJzW3RvcGljXS5wdWJsaXNoT24gPSBzdWJzY3JpcHRpb247XG5cbiAgICAgICAgICAgIC8vZG8gYW4gaW5pdGlhbCBwdWJsaXNoXG4gICAgICAgICAgICBpZiAoIXNraXBJbml0aWFsUHVibGlzaCkge1xuICAgICAgICAgICAgICAgIGV4cG9ydHMucHVibGlzaCh0b3BpYywgdGhpcygpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICAvL2hhbmRsZSBkaXNwb3NpbmcgYSBzdWJzY3JpcHRpb24gdXNlZCB0byBwdWJsaXNoIG9yIHN1YnNjcmliZSB0byBhIHRvcGljXG4gICAgZGlzcG9zZVRvcGljU3Vic2NyaXB0aW9uID0gZnVuY3Rpb24odG9waWMsIHR5cGUpIHtcbiAgICAgICAgdmFyIHN1YnMgPSB0aGlzLnBvc3Rib3hTdWJzID0gdGhpcy5wb3N0Ym94U3VicyB8fCB7fTtcbiAgICAgICAgc3Vic1t0b3BpY10gPSBzdWJzW3RvcGljXSB8fCB7fTtcblxuICAgICAgICBpZiAoc3Vic1t0b3BpY11bdHlwZV0pIHtcbiAgICAgICAgICAgIHN1YnNbdG9waWNdW3R5cGVdLmRpc3Bvc2UoKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvL2Rpc2NvbnRpbnVlIGF1dG9tYXRpY2FsbHkgcHVibGlzaGluZyBvbiBhIHRvcGljXG4gICAga28uc3Vic2NyaWJhYmxlLmZuLnN0b3BQdWJsaXNoaW5nT24gPSBmdW5jdGlvbih0b3BpYykge1xuICAgICAgICBkaXNwb3NlVG9waWNTdWJzY3JpcHRpb24uY2FsbCh0aGlzLCB0b3BpYywgXCJwdWJsaXNoT25cIik7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIC8vYXVnbWVudCBvYnNlcnZhYmxlcy9jb21wdXRlZHMgdG8gYXV0b21hdGljYWxseSBiZSB1cGRhdGVkIGJ5IG5vdGlmaWNhdGlvbnMgb24gYSB0b3BpY1xuICAgIGtvLnN1YnNjcmliYWJsZS5mbi5zdWJzY3JpYmVUbyA9IGZ1bmN0aW9uKHRvcGljLCBpbml0aWFsaXplV2l0aExhdGVzdFZhbHVlT3JUcmFuc2Zvcm0sIHRyYW5zZm9ybSkge1xuICAgICAgICB2YXIgaW5pdGlhbGl6ZVdpdGhMYXRlc3RWYWx1ZSwgY3VycmVudCwgY2FsbGJhY2ssIHN1YnNjcmlwdGlvbiwgZXhpc3RpbmdEaXNwb3NlLFxuICAgICAgICAgICAgc2VsZiA9IHRoaXM7XG5cbiAgICAgICAgLy9hbGxvdyBwYXNzaW5nIHRoZSBmaWx0ZXIgYXMgdGhlIHNlY29uZCBhcmd1bWVudFxuICAgICAgICBpZiAodHlwZW9mIGluaXRpYWxpemVXaXRoTGF0ZXN0VmFsdWVPclRyYW5zZm9ybSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm0gPSBpbml0aWFsaXplV2l0aExhdGVzdFZhbHVlT3JUcmFuc2Zvcm07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpbml0aWFsaXplV2l0aExhdGVzdFZhbHVlID0gaW5pdGlhbGl6ZVdpdGhMYXRlc3RWYWx1ZU9yVHJhbnNmb3JtO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRvcGljICYmIGtvLmlzV3JpdGVhYmxlT2JzZXJ2YWJsZSh0aGlzKSkge1xuICAgICAgICAgICAgLy9yZW1vdmUgYW55IGV4aXN0aW5nIHN1YnNcbiAgICAgICAgICAgIGRpc3Bvc2VUb3BpY1N1YnNjcmlwdGlvbi5jYWxsKHRoaXMsIHRvcGljLCBcInN1YnNjcmliZVRvXCIpO1xuXG4gICAgICAgICAgICAvL2lmIHNwZWNpZmllZCwgYXBwbHkgYSBmaWx0ZXIgZnVuY3Rpb24gaW4gdGhlIHN1YnNjcmlwdGlvblxuICAgICAgICAgICAgY2FsbGJhY2sgPSBmdW5jdGlvbihuZXdWYWx1ZSkge1xuICAgICAgICAgICAgICAgIHNlbGYodHJhbnNmb3JtID8gdHJhbnNmb3JtLmNhbGwoc2VsZiwgbmV3VmFsdWUpIDogbmV3VmFsdWUpO1xuICAgICAgICAgICAgfTtcblxuXHRcdFx0Ly8vL2tlZXAgYSByZWZlcmVuY2UgdG8gdGhlIHN1YnNjcmlwdGlvbiwgc28gd2UgY2FuIHVuc3Vic2NyaWJlLCBpZiBuZWNlc3Nhcnlcblx0XHRcdHN1YnNjcmlwdGlvbiA9IGV4cG9ydHMuc3Vic2NyaWJlKHRvcGljLCBjYWxsYmFjayk7XG5cdFx0XHR0aGlzLnBvc3Rib3hTdWJzW3RvcGljXS5zdWJzY3JpYmVUbyA9IHN1YnNjcmlwdGlvbjtcblxuXHRcdFx0Ly9lbnN1cmUgdGhhdCB3ZSBjbGVhbnVwIHBvaW50ZXJzIHRvIHN1YnNjcmlwdGlvbiBvbiBkaXNwb3NlXG5cdFx0XHRleGlzdGluZ0Rpc3Bvc2UgPSBzdWJzY3JpcHRpb24uZGlzcG9zZTtcblx0XHRcdHN1YnNjcmlwdGlvbi5kaXNwb3NlID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGRlbGV0ZSB0aGlzLnBvc3Rib3hTdWJzW3RvcGljXS5zdWJzY3JpYmVUbztcblx0XHRcdFx0ZXhpc3RpbmdEaXNwb3NlLmNhbGwoc3Vic2NyaXB0aW9uKTtcblx0XHRcdH0uYmluZCh0aGlzKTtcblxuICAgICAgICAgICAgaWYgKGluaXRpYWxpemVXaXRoTGF0ZXN0VmFsdWUpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50ID0gZXhwb3J0cy50b3BpY0NhY2hlW3RvcGljXTtcblxuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soY3VycmVudC52YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIC8vZGlzY29udGludWUgcmVjZWl2aW5nIHVwZGF0ZXMgb24gYSB0b3BpY1xuICAgIGtvLnN1YnNjcmliYWJsZS5mbi51bnN1YnNjcmliZUZyb20gPSBmdW5jdGlvbih0b3BpYykge1xuICAgICAgICBkaXNwb3NlVG9waWNTdWJzY3JpcHRpb24uY2FsbCh0aGlzLCB0b3BpYywgXCJzdWJzY3JpYmVUb1wiKTtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgLy8gYm90aCBzdWJzY3JpYmUgYW5kIHB1Ymxpc2ggb24gdGhlIHNhbWUgdG9waWNcbiAgICAvLyAgIC1hbGxvd3MgdGhlIGFiaWxpdHkgdG8gc3luYyBhbiBvYnNlcnZhYmxlL3dyaXRlYWJsZSBjb21wdXRlZC9vYnNlcnZhYmxlQXJyYXkgYmV0d2VlbiB2aWV3IG1vZGVsc1xuICAgIC8vICAgLXN1YnNjcmliZVRvIHNob3VsZCByZWFsbHkgbm90IHVzZSBhIGZpbHRlciBmdW5jdGlvbiwgYXMgaXQgd291bGQgbGlrZWx5IGNhdXNlIGluZmluaXRlIHJlY3Vyc2lvblxuICAgIGtvLnN1YnNjcmliYWJsZS5mbi5zeW5jV2l0aCA9IGZ1bmN0aW9uKHRvcGljLCBpbml0aWFsaXplV2l0aExhdGVzdFZhbHVlLCBza2lwSW5pdGlhbE9yRXF1YWxpdHlDb21wYXJlciwgZXF1YWxpdHlDb21wYXJlcikge1xuICAgICAgICB0aGlzLnN1YnNjcmliZVRvKHRvcGljLCBpbml0aWFsaXplV2l0aExhdGVzdFZhbHVlKS5wdWJsaXNoT24odG9waWMsIHNraXBJbml0aWFsT3JFcXVhbGl0eUNvbXBhcmVyLCBlcXVhbGl0eUNvbXBhcmVyKTtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAga28ucG9zdGJveCA9IGV4cG9ydHM7XG59KSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34va25vY2tvdXQtcG9zdGJveC9idWlsZC9rbm9ja291dC1wb3N0Ym94LmpzXG4vLyBtb2R1bGUgaWQgPSA2MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKj09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cdEF1dGhvcjpcdFx0XHRFcmljIE0uIEJhcm5hcmQgLSBAZXJpY21iYXJuYXJkXHRcdFx0XHRcdFx0XHRcdFxuXHRMaWNlbnNlOlx0XHRNSVQgKGh0dHA6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHApXHRcdFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFxuXHREZXNjcmlwdGlvbjpcdFZhbGlkYXRpb24gTGlicmFyeSBmb3IgS25vY2tvdXRKU1x0XHRcdFx0XHRcdFx0XG5cdFZlcnNpb246XHRcdDIuMC4zXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFxuPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuKi9cbi8qZ2xvYmFscyByZXF1aXJlOiBmYWxzZSwgZXhwb3J0czogZmFsc2UsIGRlZmluZTogZmFsc2UsIGtvOiBmYWxzZSAqL1xuXG4oZnVuY3Rpb24gKGZhY3RvcnkpIHtcblx0Ly8gTW9kdWxlIHN5c3RlbXMgbWFnaWMgZGFuY2UuXG5cblx0aWYgKHR5cGVvZiByZXF1aXJlID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIGV4cG9ydHMgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIG1vZHVsZSA9PT0gXCJvYmplY3RcIikge1xuXHRcdC8vIENvbW1vbkpTIG9yIE5vZGU6IGhhcmQtY29kZWQgZGVwZW5kZW5jeSBvbiBcImtub2Nrb3V0XCJcblx0XHRmYWN0b3J5KHJlcXVpcmUoXCJrbm9ja291dFwiKSwgZXhwb3J0cyk7XG5cdH0gZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIGRlZmluZVtcImFtZFwiXSkge1xuXHRcdC8vIEFNRCBhbm9ueW1vdXMgbW9kdWxlIHdpdGggaGFyZC1jb2RlZCBkZXBlbmRlbmN5IG9uIFwia25vY2tvdXRcIlxuXHRcdGRlZmluZShbXCJrbm9ja291dFwiLCBcImV4cG9ydHNcIl0sIGZhY3RvcnkpO1xuXHR9IGVsc2Uge1xuXHRcdC8vIDxzY3JpcHQ+IHRhZzogdXNlIHRoZSBnbG9iYWwgYGtvYCBvYmplY3QsIGF0dGFjaGluZyBhIGBtYXBwaW5nYCBwcm9wZXJ0eVxuXHRcdGZhY3Rvcnkoa28sIGtvLnZhbGlkYXRpb24gPSB7fSk7XG5cdH1cbn0oZnVuY3Rpb24gKCBrbywgZXhwb3J0cyApIHtcblxuXHRpZiAodHlwZW9mIChrbykgPT09ICd1bmRlZmluZWQnKSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKCdLbm9ja291dCBpcyByZXF1aXJlZCwgcGxlYXNlIGVuc3VyZSBpdCBpcyBsb2FkZWQgYmVmb3JlIGxvYWRpbmcgdGhpcyB2YWxpZGF0aW9uIHBsdWctaW4nKTtcblx0fVxuXG5cdC8vIGNyZWF0ZSBvdXIgbmFtZXNwYWNlIG9iamVjdFxuXHRrby52YWxpZGF0aW9uID0gZXhwb3J0cztcblxuXHR2YXIga3YgPSBrby52YWxpZGF0aW9uLFxuXHRcdGtvVXRpbHMgPSBrby51dGlscyxcblx0XHR1bndyYXAgPSBrb1V0aWxzLnVud3JhcE9ic2VydmFibGUsXG5cdFx0Zm9yRWFjaCA9IGtvVXRpbHMuYXJyYXlGb3JFYWNoLFxuXHRcdGV4dGVuZCA9IGtvVXRpbHMuZXh0ZW5kO1xuOy8qZ2xvYmFsIGtvOiBmYWxzZSovXG5cbnZhciBkZWZhdWx0cyA9IHtcblx0cmVnaXN0ZXJFeHRlbmRlcnM6IHRydWUsXG5cdG1lc3NhZ2VzT25Nb2RpZmllZDogdHJ1ZSxcblx0ZXJyb3JzQXNUaXRsZTogdHJ1ZSwgICAgICAgICAgICAvLyBlbmFibGVzL2Rpc2FibGVzIHNob3dpbmcgb2YgZXJyb3JzIGFzIHRpdGxlIGF0dHJpYnV0ZSBvZiB0aGUgdGFyZ2V0IGVsZW1lbnQuXG5cdGVycm9yc0FzVGl0bGVPbk1vZGlmaWVkOiBmYWxzZSwgLy8gc2hvd3MgdGhlIGVycm9yIHdoZW4gaG92ZXJpbmcgdGhlIGlucHV0IGZpZWxkIChkZWNvcmF0ZUVsZW1lbnQgbXVzdCBiZSB0cnVlKVxuXHRtZXNzYWdlVGVtcGxhdGU6IG51bGwsXG5cdGluc2VydE1lc3NhZ2VzOiB0cnVlLCAgICAgICAgICAgLy8gYXV0b21hdGljYWxseSBpbnNlcnRzIHZhbGlkYXRpb24gbWVzc2FnZXMgYXMgPHNwYW4+PC9zcGFuPlxuXHRwYXJzZUlucHV0QXR0cmlidXRlczogZmFsc2UsICAgIC8vIHBhcnNlcyB0aGUgSFRNTDUgdmFsaWRhdGlvbiBhdHRyaWJ1dGUgZnJvbSBhIGZvcm0gZWxlbWVudCBhbmQgYWRkcyB0aGF0IHRvIHRoZSBvYmplY3Rcblx0d3JpdGVJbnB1dEF0dHJpYnV0ZXM6IGZhbHNlLCAgICAvLyBhZGRzIEhUTUw1IGlucHV0IHZhbGlkYXRpb24gYXR0cmlidXRlcyB0byBmb3JtIGVsZW1lbnRzIHRoYXQga28gb2JzZXJ2YWJsZSdzIGFyZSBib3VuZCB0b1xuXHRkZWNvcmF0ZUlucHV0RWxlbWVudDogZmFsc2UsICAgICAgICAgLy8gZmFsc2UgdG8ga2VlcCBiYWNrd2FyZCBjb21wYXRpYmlsaXR5XG5cdGRlY29yYXRlRWxlbWVudE9uTW9kaWZpZWQ6IHRydWUsLy8gdHJ1ZSB0byBrZWVwIGJhY2t3YXJkIGNvbXBhdGliaWxpdHlcblx0ZXJyb3JDbGFzczogbnVsbCwgICAgICAgICAgICAgICAvLyBzaW5nbGUgY2xhc3MgZm9yIGVycm9yIG1lc3NhZ2UgYW5kIGVsZW1lbnRcblx0ZXJyb3JFbGVtZW50Q2xhc3M6ICd2YWxpZGF0aW9uRWxlbWVudCcsICAvLyBjbGFzcyB0byBkZWNvcmF0ZSBlcnJvciBlbGVtZW50XG5cdGVycm9yTWVzc2FnZUNsYXNzOiAndmFsaWRhdGlvbk1lc3NhZ2UnLCAgLy8gY2xhc3MgdG8gZGVjb3JhdGUgZXJyb3IgbWVzc2FnZVxuXHRhbGxvd0h0bWxNZXNzYWdlczogZmFsc2UsXHRcdC8vIGFsbG93cyBIVE1MIGluIHZhbGlkYXRpb24gbWVzc2FnZXNcblx0Z3JvdXBpbmc6IHtcblx0XHRkZWVwOiBmYWxzZSwgICAgICAgIC8vYnkgZGVmYXVsdCBncm91cGluZyBpcyBzaGFsbG93XG5cdFx0b2JzZXJ2YWJsZTogdHJ1ZSwgICAvL2FuZCB1c2luZyBvYnNlcnZhYmxlc1xuXHRcdGxpdmU6IGZhbHNlXHRcdCAgICAvL3JlYWN0IHRvIGNoYW5nZXMgdG8gb2JzZXJ2YWJsZUFycmF5cyBpZiBvYnNlcnZhYmxlID09PSB0cnVlXG5cdH0sXG5cdHZhbGlkYXRlOiB7XG5cdFx0Ly8gdGhyb3R0bGU6IDEwXG5cdH1cbn07XG5cbi8vIG1ha2UgYSBjb3B5ICBzbyB3ZSBjYW4gdXNlICdyZXNldCcgbGF0ZXJcbnZhciBjb25maWd1cmF0aW9uID0gZXh0ZW5kKHt9LCBkZWZhdWx0cyk7XG5cbmNvbmZpZ3VyYXRpb24uaHRtbDVBdHRyaWJ1dGVzID0gWydyZXF1aXJlZCcsICdwYXR0ZXJuJywgJ21pbicsICdtYXgnLCAnc3RlcCddO1xuY29uZmlndXJhdGlvbi5odG1sNUlucHV0VHlwZXMgPSBbJ2VtYWlsJywgJ251bWJlcicsICdkYXRlJ107XG5cbmNvbmZpZ3VyYXRpb24ucmVzZXQgPSBmdW5jdGlvbiAoKSB7XG5cdGV4dGVuZChjb25maWd1cmF0aW9uLCBkZWZhdWx0cyk7XG59O1xuXG5rdi5jb25maWd1cmF0aW9uID0gY29uZmlndXJhdGlvbjtcbjtrdi51dGlscyA9IChmdW5jdGlvbiAoKSB7XG5cdHZhciBzZWVkSWQgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcblxuXHR2YXIgZG9tRGF0YSA9IHt9OyAvL2hhc2ggb2YgZGF0YSBvYmplY3RzIHRoYXQgd2UgcmVmZXJlbmNlIGZyb20gZG9tIGVsZW1lbnRzXG5cdHZhciBkb21EYXRhS2V5ID0gJ19fa29fdmFsaWRhdGlvbl9fJztcblxuXHRyZXR1cm4ge1xuXHRcdGlzQXJyYXk6IGZ1bmN0aW9uIChvKSB7XG5cdFx0XHRyZXR1cm4gby5pc0FycmF5IHx8IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKSA9PT0gJ1tvYmplY3QgQXJyYXldJztcblx0XHR9LFxuXHRcdGlzT2JqZWN0OiBmdW5jdGlvbiAobykge1xuXHRcdFx0cmV0dXJuIG8gIT09IG51bGwgJiYgdHlwZW9mIG8gPT09ICdvYmplY3QnO1xuXHRcdH0sXG5cdFx0aXNOdW1iZXI6IGZ1bmN0aW9uKG8pIHtcblx0XHRcdHJldHVybiAhaXNOYU4obyk7XHRcblx0XHR9LFxuXHRcdGlzT2JzZXJ2YWJsZUFycmF5OiBmdW5jdGlvbihpbnN0YW5jZSkge1xuXHRcdFx0cmV0dXJuICEhaW5zdGFuY2UgJiZcblx0XHRcdFx0XHR0eXBlb2YgaW5zdGFuY2VbXCJyZW1vdmVcIl0gPT09IFwiZnVuY3Rpb25cIiAmJlxuXHRcdFx0XHRcdHR5cGVvZiBpbnN0YW5jZVtcInJlbW92ZUFsbFwiXSA9PT0gXCJmdW5jdGlvblwiICYmXG5cdFx0XHRcdFx0dHlwZW9mIGluc3RhbmNlW1wiZGVzdHJveVwiXSA9PT0gXCJmdW5jdGlvblwiICYmXG5cdFx0XHRcdFx0dHlwZW9mIGluc3RhbmNlW1wiZGVzdHJveUFsbFwiXSA9PT0gXCJmdW5jdGlvblwiICYmXG5cdFx0XHRcdFx0dHlwZW9mIGluc3RhbmNlW1wiaW5kZXhPZlwiXSA9PT0gXCJmdW5jdGlvblwiICYmXG5cdFx0XHRcdFx0dHlwZW9mIGluc3RhbmNlW1wicmVwbGFjZVwiXSA9PT0gXCJmdW5jdGlvblwiO1xuXHRcdH0sXG5cdFx0dmFsdWVzOiBmdW5jdGlvbiAobykge1xuXHRcdFx0dmFyIHIgPSBbXTtcblx0XHRcdGZvciAodmFyIGkgaW4gbykge1xuXHRcdFx0XHRpZiAoby5oYXNPd25Qcm9wZXJ0eShpKSkge1xuXHRcdFx0XHRcdHIucHVzaChvW2ldKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHI7XG5cdFx0fSxcblx0XHRnZXRWYWx1ZTogZnVuY3Rpb24gKG8pIHtcblx0XHRcdHJldHVybiAodHlwZW9mIG8gPT09ICdmdW5jdGlvbicgPyBvKCkgOiBvKTtcblx0XHR9LFxuXHRcdGhhc0F0dHJpYnV0ZTogZnVuY3Rpb24gKG5vZGUsIGF0dHIpIHtcblx0XHRcdHJldHVybiBub2RlLmdldEF0dHJpYnV0ZShhdHRyKSAhPT0gbnVsbDtcblx0XHR9LFxuXHRcdGdldEF0dHJpYnV0ZTogZnVuY3Rpb24gKGVsZW1lbnQsIGF0dHIpIHtcblx0XHRcdHJldHVybiBlbGVtZW50LmdldEF0dHJpYnV0ZShhdHRyKTtcblx0XHR9LFxuXHRcdHNldEF0dHJpYnV0ZTogZnVuY3Rpb24gKGVsZW1lbnQsIGF0dHIsIHZhbHVlKSB7XG5cdFx0XHRyZXR1cm4gZWxlbWVudC5zZXRBdHRyaWJ1dGUoYXR0ciwgdmFsdWUpO1xuXHRcdH0sXG5cdFx0aXNWYWxpZGF0YWJsZTogZnVuY3Rpb24gKG8pIHtcblx0XHRcdHJldHVybiAhIShvICYmIG8ucnVsZXMgJiYgby5pc1ZhbGlkICYmIG8uaXNNb2RpZmllZCk7XG5cdFx0fSxcblx0XHRpbnNlcnRBZnRlcjogZnVuY3Rpb24gKG5vZGUsIG5ld05vZGUpIHtcblx0XHRcdG5vZGUucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUobmV3Tm9kZSwgbm9kZS5uZXh0U2libGluZyk7XG5cdFx0fSxcblx0XHRuZXdJZDogZnVuY3Rpb24gKCkge1xuXHRcdFx0cmV0dXJuIHNlZWRJZCArPSAxO1xuXHRcdH0sXG5cdFx0Z2V0Q29uZmlnT3B0aW9uczogZnVuY3Rpb24gKGVsZW1lbnQpIHtcblx0XHRcdHZhciBvcHRpb25zID0ga3YudXRpbHMuY29udGV4dEZvcihlbGVtZW50KTtcblxuXHRcdFx0cmV0dXJuIG9wdGlvbnMgfHwga3YuY29uZmlndXJhdGlvbjtcblx0XHR9LFxuXHRcdHNldERvbURhdGE6IGZ1bmN0aW9uIChub2RlLCBkYXRhKSB7XG5cdFx0XHR2YXIga2V5ID0gbm9kZVtkb21EYXRhS2V5XTtcblxuXHRcdFx0aWYgKCFrZXkpIHtcblx0XHRcdFx0bm9kZVtkb21EYXRhS2V5XSA9IGtleSA9IGt2LnV0aWxzLm5ld0lkKCk7XG5cdFx0XHR9XG5cblx0XHRcdGRvbURhdGFba2V5XSA9IGRhdGE7XG5cdFx0fSxcblx0XHRnZXREb21EYXRhOiBmdW5jdGlvbiAobm9kZSkge1xuXHRcdFx0dmFyIGtleSA9IG5vZGVbZG9tRGF0YUtleV07XG5cblx0XHRcdGlmICgha2V5KSB7XG5cdFx0XHRcdHJldHVybiB1bmRlZmluZWQ7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBkb21EYXRhW2tleV07XG5cdFx0fSxcblx0XHRjb250ZXh0Rm9yOiBmdW5jdGlvbiAobm9kZSkge1xuXHRcdFx0c3dpdGNoIChub2RlLm5vZGVUeXBlKSB7XG5cdFx0XHRcdGNhc2UgMTpcblx0XHRcdFx0Y2FzZSA4OlxuXHRcdFx0XHRcdHZhciBjb250ZXh0ID0ga3YudXRpbHMuZ2V0RG9tRGF0YShub2RlKTtcblx0XHRcdFx0XHRpZiAoY29udGV4dCkgeyByZXR1cm4gY29udGV4dDsgfVxuXHRcdFx0XHRcdGlmIChub2RlLnBhcmVudE5vZGUpIHsgcmV0dXJuIGt2LnV0aWxzLmNvbnRleHRGb3Iobm9kZS5wYXJlbnROb2RlKTsgfVxuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHVuZGVmaW5lZDtcblx0XHR9LFxuXHRcdGlzRW1wdHlWYWw6IGZ1bmN0aW9uICh2YWwpIHtcblx0XHRcdGlmICh2YWwgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblx0XHRcdGlmICh2YWwgPT09IG51bGwpIHtcblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9XG5cdFx0XHRpZiAodmFsID09PSBcIlwiKSB7XG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fVxuXHRcdH0sXG5cdFx0Z2V0T3JpZ2luYWxFbGVtZW50VGl0bGU6IGZ1bmN0aW9uIChlbGVtZW50KSB7XG5cdFx0XHR2YXIgc2F2ZWRPcmlnaW5hbFRpdGxlID0ga3YudXRpbHMuZ2V0QXR0cmlidXRlKGVsZW1lbnQsICdkYXRhLW9yaWctdGl0bGUnKSxcblx0XHRcdFx0Y3VycmVudFRpdGxlID0gZWxlbWVudC50aXRsZSxcblx0XHRcdFx0aGFzU2F2ZWRPcmlnaW5hbFRpdGxlID0ga3YudXRpbHMuaGFzQXR0cmlidXRlKGVsZW1lbnQsICdkYXRhLW9yaWctdGl0bGUnKTtcblxuXHRcdFx0cmV0dXJuIGhhc1NhdmVkT3JpZ2luYWxUaXRsZSA/XG5cdFx0XHRcdHNhdmVkT3JpZ2luYWxUaXRsZSA6IGN1cnJlbnRUaXRsZTtcblx0XHR9LFxuXHRcdGFzeW5jOiBmdW5jdGlvbiAoZXhwcikge1xuXHRcdFx0aWYgKHdpbmRvdy5zZXRJbW1lZGlhdGUpIHsgd2luZG93LnNldEltbWVkaWF0ZShleHByKTsgfVxuXHRcdFx0ZWxzZSB7IHdpbmRvdy5zZXRUaW1lb3V0KGV4cHIsIDApOyB9XG5cdFx0fSxcblx0XHRmb3JFYWNoOiBmdW5jdGlvbiAob2JqZWN0LCBjYWxsYmFjaykge1xuXHRcdFx0aWYgKGt2LnV0aWxzLmlzQXJyYXkob2JqZWN0KSkge1xuXHRcdFx0XHRyZXR1cm4gZm9yRWFjaChvYmplY3QsIGNhbGxiYWNrKTtcblx0XHRcdH1cblx0XHRcdGZvciAodmFyIHByb3AgaW4gb2JqZWN0KSB7XG5cdFx0XHRcdGlmIChvYmplY3QuaGFzT3duUHJvcGVydHkocHJvcCkpIHtcblx0XHRcdFx0XHRjYWxsYmFjayhvYmplY3RbcHJvcF0sIHByb3ApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xufSgpKTs7dmFyIGFwaSA9IChmdW5jdGlvbiAoKSB7XG5cblx0dmFyIGlzSW5pdGlhbGl6ZWQgPSAwLFxuXHRcdGNvbmZpZ3VyYXRpb24gPSBrdi5jb25maWd1cmF0aW9uLFxuXHRcdHV0aWxzID0ga3YudXRpbHM7XG5cblx0ZnVuY3Rpb24gY2xlYW5VcFN1YnNjcmlwdGlvbnMoY29udGV4dCkge1xuXHRcdGZvckVhY2goY29udGV4dC5zdWJzY3JpcHRpb25zLCBmdW5jdGlvbiAoc3Vic2NyaXB0aW9uKSB7XG5cdFx0XHRzdWJzY3JpcHRpb24uZGlzcG9zZSgpO1xuXHRcdH0pO1xuXHRcdGNvbnRleHQuc3Vic2NyaXB0aW9ucyA9IFtdO1xuXHR9XG5cblx0ZnVuY3Rpb24gZGlzcG9zZShjb250ZXh0KSB7XG5cdFx0aWYgKGNvbnRleHQub3B0aW9ucy5kZWVwKSB7XG5cdFx0XHRmb3JFYWNoKGNvbnRleHQuZmxhZ2dlZCwgZnVuY3Rpb24gKG9iaikge1xuXHRcdFx0XHRkZWxldGUgb2JqLl9fa3ZfdHJhdmVyc2VkO1xuXHRcdFx0fSk7XG5cdFx0XHRjb250ZXh0LmZsYWdnZWQubGVuZ3RoID0gMDtcblx0XHR9XG5cblx0XHRpZiAoIWNvbnRleHQub3B0aW9ucy5saXZlKSB7XG5cdFx0XHRjbGVhblVwU3Vic2NyaXB0aW9ucyhjb250ZXh0KTtcblx0XHR9XG5cdH1cblxuXHRmdW5jdGlvbiBydW5UcmF2ZXJzYWwob2JqLCBjb250ZXh0KSB7XG5cdFx0Y29udGV4dC52YWxpZGF0YWJsZXMgPSBbXTtcblx0XHRjbGVhblVwU3Vic2NyaXB0aW9ucyhjb250ZXh0KTtcblx0XHR0cmF2ZXJzZUdyYXBoKG9iaiwgY29udGV4dCk7XG5cdFx0ZGlzcG9zZShjb250ZXh0KTtcblx0fVxuXG5cdGZ1bmN0aW9uIHRyYXZlcnNlR3JhcGgob2JqLCBjb250ZXh0LCBsZXZlbCkge1xuXHRcdHZhciBvYmpWYWx1ZXMgPSBbXSxcblx0XHRcdHZhbCA9IG9iai5wZWVrID8gb2JqLnBlZWsoKSA6IG9iajtcblxuXHRcdGlmIChvYmouX19rdl90cmF2ZXJzZWQgPT09IHRydWUpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRpZiAoY29udGV4dC5vcHRpb25zLmRlZXApIHtcblx0XHRcdG9iai5fX2t2X3RyYXZlcnNlZCA9IHRydWU7XG5cdFx0XHRjb250ZXh0LmZsYWdnZWQucHVzaChvYmopO1xuXHRcdH1cblxuXHRcdC8vZGVmYXVsdCBsZXZlbCB2YWx1ZSBkZXBlbmRzIG9uIGRlZXAgb3B0aW9uLlxuXHRcdGxldmVsID0gKGxldmVsICE9PSB1bmRlZmluZWQgPyBsZXZlbCA6IGNvbnRleHQub3B0aW9ucy5kZWVwID8gMSA6IC0xKTtcblxuXHRcdC8vIGlmIG9iamVjdCBpcyBvYnNlcnZhYmxlIHRoZW4gYWRkIGl0IHRvIHRoZSBsaXN0XG5cdFx0aWYgKGtvLmlzT2JzZXJ2YWJsZShvYmopKSB7XG5cdFx0XHQvLyBlbnN1cmUgaXQncyB2YWxpZGF0YWJsZSBidXQgZG9uJ3QgZXh0ZW5kIHZhbGlkYXRlZE9ic2VydmFibGUgYmVjYXVzZSBpdFxuXHRcdFx0Ly8gd291bGQgb3ZlcndyaXRlIGlzVmFsaWQgcHJvcGVydHkuXG5cdFx0XHRpZiAoIW9iai5lcnJvcnMgJiYgIXV0aWxzLmlzVmFsaWRhdGFibGUob2JqKSkge1xuXHRcdFx0XHRvYmouZXh0ZW5kKHsgdmFsaWRhdGFibGU6IHRydWUgfSk7XG5cdFx0XHR9XG5cdFx0XHRjb250ZXh0LnZhbGlkYXRhYmxlcy5wdXNoKG9iaik7XG5cblx0XHRcdGlmIChjb250ZXh0Lm9wdGlvbnMubGl2ZSAmJiB1dGlscy5pc09ic2VydmFibGVBcnJheShvYmopKSB7XG5cdFx0XHRcdGNvbnRleHQuc3Vic2NyaXB0aW9ucy5wdXNoKG9iai5zdWJzY3JpYmUoZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdGNvbnRleHQuZ3JhcGhNb25pdG9yLnZhbHVlSGFzTXV0YXRlZCgpO1xuXHRcdFx0XHR9KSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly9nZXQgbGlzdCBvZiB2YWx1ZXMgZWl0aGVyIGZyb20gYXJyYXkgb3Igb2JqZWN0IGJ1dCBpZ25vcmUgbm9uLW9iamVjdHNcblx0XHQvLyBhbmQgZGVzdHJveWVkIG9iamVjdHNcblx0XHRpZiAodmFsICYmICF2YWwuX2Rlc3Ryb3kpIHtcblx0XHRcdGlmICh1dGlscy5pc0FycmF5KHZhbCkpIHtcblx0XHRcdFx0b2JqVmFsdWVzID0gdmFsO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSBpZiAodXRpbHMuaXNPYmplY3QodmFsKSkge1xuXHRcdFx0XHRvYmpWYWx1ZXMgPSB1dGlscy52YWx1ZXModmFsKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvL3Byb2Nlc3MgcmVjdXJzaXZlbHkgaWYgaXQgaXMgZGVlcCBncm91cGluZ1xuXHRcdGlmIChsZXZlbCAhPT0gMCkge1xuXHRcdFx0dXRpbHMuZm9yRWFjaChvYmpWYWx1ZXMsIGZ1bmN0aW9uIChvYnNlcnZhYmxlKSB7XG5cdFx0XHRcdC8vYnV0IG5vdCBmYWxzeSB0aGluZ3MgYW5kIG5vdCBIVE1MIEVsZW1lbnRzXG5cdFx0XHRcdGlmIChvYnNlcnZhYmxlICYmICFvYnNlcnZhYmxlLm5vZGVUeXBlICYmICgha28uaXNDb21wdXRlZChvYnNlcnZhYmxlKSB8fCBvYnNlcnZhYmxlLnJ1bGVzKSkge1xuXHRcdFx0XHRcdHRyYXZlcnNlR3JhcGgob2JzZXJ2YWJsZSwgY29udGV4dCwgbGV2ZWwgKyAxKTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0fVxuXHR9XG5cblx0ZnVuY3Rpb24gY29sbGVjdEVycm9ycyhhcnJheSkge1xuXHRcdHZhciBlcnJvcnMgPSBbXTtcblx0XHRmb3JFYWNoKGFycmF5LCBmdW5jdGlvbiAob2JzZXJ2YWJsZSkge1xuXHRcdFx0Ly8gRG8gbm90IGNvbGxlY3QgdmFsaWRhdGVkT2JzZXJ2YWJsZSBlcnJvcnNcblx0XHRcdGlmICh1dGlscy5pc1ZhbGlkYXRhYmxlKG9ic2VydmFibGUpICYmICFvYnNlcnZhYmxlLmlzVmFsaWQoKSkge1xuXHRcdFx0XHQvLyBVc2UgcGVlayBiZWNhdXNlIHdlIGRvbid0IHdhbnQgYSBkZXBlbmRlbmN5IGZvciAnZXJyb3InIHByb3BlcnR5IGJlY2F1c2UgaXRcblx0XHRcdFx0Ly8gY2hhbmdlcyBiZWZvcmUgJ2lzVmFsaWQnIGRvZXMuIChJc3N1ZSAjOTkpXG5cdFx0XHRcdGVycm9ycy5wdXNoKG9ic2VydmFibGUuZXJyb3IucGVlaygpKTtcblx0XHRcdH1cblx0XHR9KTtcblx0XHRyZXR1cm4gZXJyb3JzO1xuXHR9XG5cblx0cmV0dXJuIHtcblx0XHQvL0NhbGwgdGhpcyBvbiBzdGFydHVwXG5cdFx0Ly9hbnkgY29uZmlnIGNhbiBiZSBvdmVycmlkZGVuIHdpdGggdGhlIHBhc3NlZCBpbiBvcHRpb25zXG5cdFx0aW5pdDogZnVuY3Rpb24gKG9wdGlvbnMsIGZvcmNlKSB7XG5cdFx0XHQvL2RvbmUgcnVuIHRoaXMgbXVsdGlwbGUgdGltZXMgaWYgd2UgZG9uJ3QgcmVhbGx5IHdhbnQgdG9cblx0XHRcdGlmIChpc0luaXRpYWxpemVkID4gMCAmJiAhZm9yY2UpIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHQvL2JlY2F1c2Ugd2Ugd2lsbCBiZSBhY2Nlc3Npbmcgb3B0aW9ucyBwcm9wZXJ0aWVzIGl0IGhhcyB0byBiZSBhbiBvYmplY3QgYXQgbGVhc3Rcblx0XHRcdG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXHRcdFx0Ly9pZiBzcGVjaWZpYyBlcnJvciBjbGFzc2VzIGFyZSBub3QgcHJvdmlkZWQgdGhlbiBhcHBseSBnZW5lcmljIGVycm9yQ2xhc3Ncblx0XHRcdC8vaXQgaGFzIHRvIGJlIGRvbmUgb24gb3B0aW9uIHNvIHRoYXQgb3B0aW9ucy5lcnJvckNsYXNzIGNhbiBvdmVycmlkZSBkZWZhdWx0XG5cdFx0XHQvL2Vycm9yRWxlbWVudENsYXNzIGFuZCBlcnJvck1lc3NhZ2UgY2xhc3MgYnV0IG5vdCB0aG9zZSBwcm92aWRlZCBpbiBvcHRpb25zXG5cdFx0XHRvcHRpb25zLmVycm9yRWxlbWVudENsYXNzID0gb3B0aW9ucy5lcnJvckVsZW1lbnRDbGFzcyB8fCBvcHRpb25zLmVycm9yQ2xhc3MgfHwgY29uZmlndXJhdGlvbi5lcnJvckVsZW1lbnRDbGFzcztcblx0XHRcdG9wdGlvbnMuZXJyb3JNZXNzYWdlQ2xhc3MgPSBvcHRpb25zLmVycm9yTWVzc2FnZUNsYXNzIHx8IG9wdGlvbnMuZXJyb3JDbGFzcyB8fCBjb25maWd1cmF0aW9uLmVycm9yTWVzc2FnZUNsYXNzO1xuXG5cdFx0XHRleHRlbmQoY29uZmlndXJhdGlvbiwgb3B0aW9ucyk7XG5cblx0XHRcdGlmIChjb25maWd1cmF0aW9uLnJlZ2lzdGVyRXh0ZW5kZXJzKSB7XG5cdFx0XHRcdGt2LnJlZ2lzdGVyRXh0ZW5kZXJzKCk7XG5cdFx0XHR9XG5cblx0XHRcdGlzSW5pdGlhbGl6ZWQgPSAxO1xuXHRcdH0sXG5cblx0XHQvLyByZXNldHMgdGhlIGNvbmZpZyBiYWNrIHRvIGl0cyBvcmlnaW5hbCBzdGF0ZVxuXHRcdHJlc2V0OiBrdi5jb25maWd1cmF0aW9uLnJlc2V0LFxuXG5cdFx0Ly8gcmVjdXJzaXZlbHkgd2Fsa3MgYSB2aWV3TW9kZWwgYW5kIGNyZWF0ZXMgYW4gb2JqZWN0IHRoYXRcblx0XHQvLyBwcm92aWRlcyB2YWxpZGF0aW9uIGluZm9ybWF0aW9uIGZvciB0aGUgZW50aXJlIHZpZXdNb2RlbFxuXHRcdC8vIG9iaiAtPiB0aGUgdmlld01vZGVsIHRvIHdhbGtcblx0XHQvLyBvcHRpb25zIC0+IHtcblx0XHQvL1x0ICBkZWVwOiBmYWxzZSwgLy8gaWYgdHJ1ZSwgd2lsbCB3YWxrIHBhc3QgdGhlIGZpcnN0IGxldmVsIG9mIHZpZXdNb2RlbCBwcm9wZXJ0aWVzXG5cdFx0Ly9cdCAgb2JzZXJ2YWJsZTogZmFsc2UgLy8gaWYgdHJ1ZSwgcmV0dXJucyBhIGNvbXB1dGVkIG9ic2VydmFibGUgaW5kaWNhdGluZyBpZiB0aGUgdmlld01vZGVsIGlzIHZhbGlkXG5cdFx0Ly8gfVxuXHRcdGdyb3VwOiBmdW5jdGlvbiBncm91cChvYmosIG9wdGlvbnMpIHsgLy8gYXJyYXkgb2Ygb2JzZXJ2YWJsZXMgb3Igdmlld01vZGVsXG5cdFx0XHRvcHRpb25zID0gZXh0ZW5kKGV4dGVuZCh7fSwgY29uZmlndXJhdGlvbi5ncm91cGluZyksIG9wdGlvbnMpO1xuXG5cdFx0XHR2YXIgY29udGV4dCA9IHtcblx0XHRcdFx0b3B0aW9uczogb3B0aW9ucyxcblx0XHRcdFx0Z3JhcGhNb25pdG9yOiBrby5vYnNlcnZhYmxlKCksXG5cdFx0XHRcdGZsYWdnZWQ6IFtdLFxuXHRcdFx0XHRzdWJzY3JpcHRpb25zOiBbXSxcblx0XHRcdFx0dmFsaWRhdGFibGVzOiBbXVxuXHRcdFx0fTtcblxuXHRcdFx0dmFyIHJlc3VsdCA9IG51bGw7XG5cblx0XHRcdC8vaWYgdXNpbmcgb2JzZXJ2YWJsZXMgdGhlbiB0cmF2ZXJzZSBzdHJ1Y3R1cmUgb25jZSBhbmQgYWRkIG9ic2VydmFibGVzXG5cdFx0XHRpZiAob3B0aW9ucy5vYnNlcnZhYmxlKSB7XG5cdFx0XHRcdHJlc3VsdCA9IGtvLmNvbXB1dGVkKGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0XHRjb250ZXh0LmdyYXBoTW9uaXRvcigpOyAvL3JlZ2lzdGVyIGRlcGVuZGVuY3lcblx0XHRcdFx0XHRydW5UcmF2ZXJzYWwob2JqLCBjb250ZXh0KTtcblx0XHRcdFx0XHRyZXR1cm4gY29sbGVjdEVycm9ycyhjb250ZXh0LnZhbGlkYXRhYmxlcyk7XG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSB7IC8vaWYgbm90IHVzaW5nIG9ic2VydmFibGVzIHRoZW4gZXZlcnkgY2FsbCB0byBlcnJvcigpIHNob3VsZCB0cmF2ZXJzZSB0aGUgc3RydWN0dXJlXG5cdFx0XHRcdHJlc3VsdCA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0XHRydW5UcmF2ZXJzYWwob2JqLCBjb250ZXh0KTtcblx0XHRcdFx0XHRyZXR1cm4gY29sbGVjdEVycm9ycyhjb250ZXh0LnZhbGlkYXRhYmxlcyk7XG5cdFx0XHRcdH07XG5cdFx0XHR9XG5cblx0XHRcdHJlc3VsdC5zaG93QWxsTWVzc2FnZXMgPSBmdW5jdGlvbiAoc2hvdykgeyAvLyB0aGFua3MgQGhlbGlvc1BvcnRhbFxuXHRcdFx0XHRpZiAoc2hvdyA9PT0gdW5kZWZpbmVkKSB7Ly9kZWZhdWx0IHRvIHRydWVcblx0XHRcdFx0XHRzaG93ID0gdHJ1ZTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJlc3VsdC5mb3JFYWNoKGZ1bmN0aW9uIChvYnNlcnZhYmxlKSB7XG5cdFx0XHRcdFx0aWYgKHV0aWxzLmlzVmFsaWRhdGFibGUob2JzZXJ2YWJsZSkpIHtcblx0XHRcdFx0XHRcdG9ic2VydmFibGUuaXNNb2RpZmllZChzaG93KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pO1xuXHRcdFx0fTtcblxuXHRcdFx0cmVzdWx0LmlzQW55TWVzc2FnZVNob3duID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0XHR2YXIgaW52YWxpZEFuZE1vZGlmaWVkUHJlc2VudDtcblxuXHRcdFx0XHRpbnZhbGlkQW5kTW9kaWZpZWRQcmVzZW50ID0gISFyZXN1bHQuZmluZChmdW5jdGlvbiAob2JzZXJ2YWJsZSkge1xuXHRcdFx0XHRcdHJldHVybiB1dGlscy5pc1ZhbGlkYXRhYmxlKG9ic2VydmFibGUpICYmICFvYnNlcnZhYmxlLmlzVmFsaWQoKSAmJiBvYnNlcnZhYmxlLmlzTW9kaWZpZWQoKTtcblx0XHRcdFx0fSk7XG5cdFx0XHRcdHJldHVybiBpbnZhbGlkQW5kTW9kaWZpZWRQcmVzZW50O1xuXHRcdFx0fTtcblxuXHRcdFx0cmVzdWx0LmZpbHRlciA9IGZ1bmN0aW9uKHByZWRpY2F0ZSkge1xuXHRcdFx0XHRwcmVkaWNhdGUgPSBwcmVkaWNhdGUgfHwgZnVuY3Rpb24gKCkgeyByZXR1cm4gdHJ1ZTsgfTtcblx0XHRcdFx0Ly8gZW5zdXJlIHdlIGhhdmUgbGF0ZXN0IGNoYW5nZXNcblx0XHRcdFx0cmVzdWx0KCk7XG5cblx0XHRcdFx0cmV0dXJuIGtvVXRpbHMuYXJyYXlGaWx0ZXIoY29udGV4dC52YWxpZGF0YWJsZXMsIHByZWRpY2F0ZSk7XG5cdFx0XHR9O1xuXG5cdFx0XHRyZXN1bHQuZmluZCA9IGZ1bmN0aW9uKHByZWRpY2F0ZSkge1xuXHRcdFx0XHRwcmVkaWNhdGUgPSBwcmVkaWNhdGUgfHwgZnVuY3Rpb24gKCkgeyByZXR1cm4gdHJ1ZTsgfTtcblx0XHRcdFx0Ly8gZW5zdXJlIHdlIGhhdmUgbGF0ZXN0IGNoYW5nZXNcblx0XHRcdFx0cmVzdWx0KCk7XG5cblx0XHRcdFx0cmV0dXJuIGtvVXRpbHMuYXJyYXlGaXJzdChjb250ZXh0LnZhbGlkYXRhYmxlcywgcHJlZGljYXRlKTtcblx0XHRcdH07XG5cblx0XHRcdHJlc3VsdC5mb3JFYWNoID0gZnVuY3Rpb24oY2FsbGJhY2spIHtcblx0XHRcdFx0Y2FsbGJhY2sgPSBjYWxsYmFjayB8fCBmdW5jdGlvbiAoKSB7IH07XG5cdFx0XHRcdC8vIGVuc3VyZSB3ZSBoYXZlIGxhdGVzdCBjaGFuZ2VzXG5cdFx0XHRcdHJlc3VsdCgpO1xuXG5cdFx0XHRcdGZvckVhY2goY29udGV4dC52YWxpZGF0YWJsZXMsIGNhbGxiYWNrKTtcblx0XHRcdH07XG5cblx0XHRcdHJlc3VsdC5tYXAgPSBmdW5jdGlvbihtYXBwaW5nKSB7XG5cdFx0XHRcdG1hcHBpbmcgPSBtYXBwaW5nIHx8IGZ1bmN0aW9uIChpdGVtKSB7IHJldHVybiBpdGVtOyB9O1xuXHRcdFx0XHQvLyBlbnN1cmUgd2UgaGF2ZSBsYXRlc3QgY2hhbmdlc1xuXHRcdFx0XHRyZXN1bHQoKTtcblxuXHRcdFx0XHRyZXR1cm4ga29VdGlscy5hcnJheU1hcChjb250ZXh0LnZhbGlkYXRhYmxlcywgbWFwcGluZyk7XG5cdFx0XHR9O1xuXG5cdFx0XHQvKipcblx0XHRcdCAqIEBwcml2YXRlIFlvdSBzaG91bGQgbm90IHJlbHkgb24gdGhpcyBtZXRob2QgYmVpbmcgaGVyZS5cblx0XHRcdCAqIEl0J3MgYSBwcml2YXRlIG1ldGhvZCBhbmQgaXQgbWF5IGNoYW5nZSBpbiB0aGUgZnV0dXJlLlxuXHRcdFx0ICpcblx0XHRcdCAqIEBkZXNjcmlwdGlvbiBVcGRhdGVzIHRoZSB2YWxpZGF0ZWQgb2JqZWN0IGFuZCBjb2xsZWN0cyBlcnJvcnMgZnJvbSBpdC5cblx0XHRcdCAqL1xuXHRcdFx0cmVzdWx0Ll91cGRhdGVTdGF0ZSA9IGZ1bmN0aW9uKG5ld1ZhbHVlKSB7XG5cdFx0XHRcdGlmICghdXRpbHMuaXNPYmplY3QobmV3VmFsdWUpKSB7XG5cdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCdBbiBvYmplY3QgaXMgcmVxdWlyZWQuJyk7XG5cdFx0XHRcdH1cblx0XHRcdFx0b2JqID0gbmV3VmFsdWU7XG5cdFx0XHRcdGlmIChvcHRpb25zLm9ic2VydmFibGUpIHtcblx0XHRcdFx0XHRjb250ZXh0LmdyYXBoTW9uaXRvci52YWx1ZUhhc011dGF0ZWQoKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRydW5UcmF2ZXJzYWwobmV3VmFsdWUsIGNvbnRleHQpO1xuXHRcdFx0XHRcdHJldHVybiBjb2xsZWN0RXJyb3JzKGNvbnRleHQudmFsaWRhdGFibGVzKTtcblx0XHRcdFx0fVxuXHRcdFx0fTtcblx0XHRcdHJldHVybiByZXN1bHQ7XG5cdFx0fSxcblxuXHRcdGZvcm1hdE1lc3NhZ2U6IGZ1bmN0aW9uIChtZXNzYWdlLCBwYXJhbXMsIG9ic2VydmFibGUpIHtcblx0XHRcdGlmICh1dGlscy5pc09iamVjdChwYXJhbXMpICYmIHBhcmFtcy50eXBlQXR0cikge1xuXHRcdFx0XHRwYXJhbXMgPSBwYXJhbXMudmFsdWU7XG5cdFx0XHR9XG5cdFx0XHRpZiAodHlwZW9mIG1lc3NhZ2UgPT09ICdmdW5jdGlvbicpIHtcblx0XHRcdFx0cmV0dXJuIG1lc3NhZ2UocGFyYW1zLCBvYnNlcnZhYmxlKTtcblx0XHRcdH1cblx0XHRcdHZhciByZXBsYWNlbWVudHMgPSB1bndyYXAocGFyYW1zKTtcbiAgICAgICAgICAgIGlmIChyZXBsYWNlbWVudHMgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJlcGxhY2VtZW50cyA9IFtdO1xuICAgICAgICAgICAgfVxuXHRcdFx0aWYgKCF1dGlscy5pc0FycmF5KHJlcGxhY2VtZW50cykpIHtcblx0XHRcdFx0cmVwbGFjZW1lbnRzID0gW3JlcGxhY2VtZW50c107XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gbWVzc2FnZS5yZXBsYWNlKC97KFxcZCspfS9naSwgZnVuY3Rpb24obWF0Y2gsIGluZGV4KSB7XG5cdFx0XHRcdGlmICh0eXBlb2YgcmVwbGFjZW1lbnRzW2luZGV4XSAhPT0gJ3VuZGVmaW5lZCcpIHtcblx0XHRcdFx0XHRyZXR1cm4gcmVwbGFjZW1lbnRzW2luZGV4XTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gbWF0Y2g7XG5cdFx0XHR9KTtcblx0XHR9LFxuXG5cdFx0Ly8gYWRkUnVsZTpcblx0XHQvLyBUaGlzIHRha2VzIGluIGEga28ub2JzZXJ2YWJsZSBhbmQgYSBSdWxlIENvbnRleHQgLSB3aGljaCBpcyBqdXN0IGEgcnVsZSBuYW1lIGFuZCBwYXJhbXMgdG8gc3VwcGx5IHRvIHRoZSB2YWxpZGF0b3Jcblx0XHQvLyBpZToga3YuYWRkUnVsZShteU9ic2VydmFibGUsIHtcblx0XHQvL1x0XHQgIHJ1bGU6ICdyZXF1aXJlZCcsXG5cdFx0Ly9cdFx0ICBwYXJhbXM6IHRydWVcblx0XHQvL1x0ICB9KTtcblx0XHQvL1xuXHRcdGFkZFJ1bGU6IGZ1bmN0aW9uIChvYnNlcnZhYmxlLCBydWxlKSB7XG5cdFx0XHRvYnNlcnZhYmxlLmV4dGVuZCh7IHZhbGlkYXRhYmxlOiB0cnVlIH0pO1xuXG5cdFx0XHR2YXIgaGFzUnVsZSA9ICEha29VdGlscy5hcnJheUZpcnN0KG9ic2VydmFibGUucnVsZXMoKSwgZnVuY3Rpb24oaXRlbSkge1xuXHRcdFx0XHRyZXR1cm4gaXRlbS5ydWxlICYmIGl0ZW0ucnVsZSA9PT0gcnVsZS5ydWxlO1xuXHRcdFx0fSk7XG5cblx0XHRcdGlmICghaGFzUnVsZSkge1xuXHRcdFx0XHQvL3B1c2ggYSBSdWxlIENvbnRleHQgdG8gdGhlIG9ic2VydmFibGVzIGxvY2FsIGFycmF5IG9mIFJ1bGUgQ29udGV4dHNcblx0XHRcdFx0b2JzZXJ2YWJsZS5ydWxlcy5wdXNoKHJ1bGUpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG9ic2VydmFibGU7XG5cdFx0fSxcblxuXHRcdC8vIGFkZEFub255bW91c1J1bGU6XG5cdFx0Ly8gQW5vbnltb3VzIFJ1bGVzIGVzc2VudGlhbGx5IGhhdmUgYWxsIHRoZSBwcm9wZXJ0aWVzIG9mIGEgUnVsZSwgYnV0IGFyZSBvbmx5IHNwZWNpZmljIGZvciBhIGNlcnRhaW4gcHJvcGVydHlcblx0XHQvLyBhbmQgZGV2ZWxvcGVycyB0eXBpY2FsbHkgYXJlIHdhbnRpbmcgdG8gYWRkIHRoZW0gb24gdGhlIGZseSBvciBub3QgcmVnaXN0ZXIgYSBydWxlIHdpdGggdGhlICdrdi5ydWxlcycgb2JqZWN0XG5cdFx0Ly9cblx0XHQvLyBFeGFtcGxlOlxuXHRcdC8vIHZhciB0ZXN0ID0ga28ub2JzZXJ2YWJsZSgnc29tZXRoaW5nJykuZXh0ZW5keyhcblx0XHQvL1x0ICB2YWxpZGF0aW9uOiB7XG5cdFx0Ly9cdFx0ICB2YWxpZGF0b3I6IGZ1bmN0aW9uKHZhbCwgc29tZU90aGVyVmFsKXtcblx0XHQvL1x0XHRcdCAgcmV0dXJuIHRydWU7XG5cdFx0Ly9cdFx0ICB9LFxuXHRcdC8vXHRcdCAgbWVzc2FnZTogXCJTb21ldGhpbmcgbXVzdCBiZSByZWFsbHkgd3JvbmchJyxcblx0XHQvL1x0XHQgIHBhcmFtczogdHJ1ZVxuXHRcdC8vXHQgIH1cblx0XHQvLyAgKX07XG5cdFx0YWRkQW5vbnltb3VzUnVsZTogZnVuY3Rpb24gKG9ic2VydmFibGUsIHJ1bGVPYmopIHtcblx0XHRcdGlmIChydWxlT2JqWydtZXNzYWdlJ10gPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRydWxlT2JqWydtZXNzYWdlJ10gPSAnRXJyb3InO1xuXHRcdFx0fVxuXG5cdFx0XHQvL21ha2Ugc3VyZSBvbmx5SWYgaXMgaG9ub3VyZWRcblx0XHRcdGlmIChydWxlT2JqLm9ubHlJZikge1xuXHRcdFx0XHRydWxlT2JqLmNvbmRpdGlvbiA9IHJ1bGVPYmoub25seUlmO1xuXHRcdFx0fVxuXG5cdFx0XHQvL2FkZCB0aGUgYW5vbnltb3VzIHJ1bGUgdG8gdGhlIG9ic2VydmFibGVcblx0XHRcdGt2LmFkZFJ1bGUob2JzZXJ2YWJsZSwgcnVsZU9iaik7XG5cdFx0fSxcblxuXHRcdGFkZEV4dGVuZGVyOiBmdW5jdGlvbiAocnVsZU5hbWUpIHtcblx0XHRcdGtvLmV4dGVuZGVyc1tydWxlTmFtZV0gPSBmdW5jdGlvbiAob2JzZXJ2YWJsZSwgcGFyYW1zKSB7XG5cdFx0XHRcdC8vcGFyYW1zIGNhbiBjb21lIGluIGEgZmV3IGZsYXZvcnNcblx0XHRcdFx0Ly8gMS4gSnVzdCB0aGUgcGFyYW1zIHRvIGJlIHBhc3NlZCB0byB0aGUgdmFsaWRhdG9yXG5cdFx0XHRcdC8vIDIuIEFuIG9iamVjdCBjb250YWluaW5nIHRoZSBNZXNzYWdlIHRvIGJlIHVzZWQgYW5kIHRoZSBQYXJhbXMgdG8gcGFzcyB0byB0aGUgdmFsaWRhdG9yXG5cdFx0XHRcdC8vIDMuIEEgY29uZGl0aW9uIHdoZW4gdGhlIHZhbGlkYXRpb24gcnVsZSB0byBiZSBhcHBsaWVkXG5cdFx0XHRcdC8vXG5cdFx0XHRcdC8vIEV4YW1wbGU6XG5cdFx0XHRcdC8vIHZhciB0ZXN0ID0ga28ub2JzZXJ2YWJsZSgzKS5leHRlbmQoe1xuXHRcdFx0XHQvL1x0ICBtYXg6IHtcblx0XHRcdFx0Ly9cdFx0ICBtZXNzYWdlOiAnVGhpcyBzcGVjaWFsIGZpZWxkIGhhcyBhIE1heCBvZiB7MH0nLFxuXHRcdFx0XHQvL1x0XHQgIHBhcmFtczogMixcblx0XHRcdFx0Ly9cdFx0ICBvbmx5SWY6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHQvL1x0XHRcdFx0XHQgIHJldHVybiBzcGVjaWFsRmllbGQuSXNWaXNpYmxlKCk7XG5cdFx0XHRcdC8vXHRcdFx0XHQgIH1cblx0XHRcdFx0Ly9cdCAgfVxuXHRcdFx0XHQvLyAgKX07XG5cdFx0XHRcdC8vXG5cdFx0XHRcdGlmIChwYXJhbXMgJiYgKHBhcmFtcy5tZXNzYWdlIHx8IHBhcmFtcy5vbmx5SWYpKSB7IC8vaWYgaXQgaGFzIGEgbWVzc2FnZSBvciBjb25kaXRpb24gb2JqZWN0LCB0aGVuIGl0cyBhbiBvYmplY3QgbGl0ZXJhbCB0byB1c2Vcblx0XHRcdFx0XHRyZXR1cm4ga3YuYWRkUnVsZShvYnNlcnZhYmxlLCB7XG5cdFx0XHRcdFx0XHRydWxlOiBydWxlTmFtZSxcblx0XHRcdFx0XHRcdG1lc3NhZ2U6IHBhcmFtcy5tZXNzYWdlLFxuXHRcdFx0XHRcdFx0cGFyYW1zOiB1dGlscy5pc0VtcHR5VmFsKHBhcmFtcy5wYXJhbXMpID8gdHJ1ZSA6IHBhcmFtcy5wYXJhbXMsXG5cdFx0XHRcdFx0XHRjb25kaXRpb246IHBhcmFtcy5vbmx5SWZcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRyZXR1cm4ga3YuYWRkUnVsZShvYnNlcnZhYmxlLCB7XG5cdFx0XHRcdFx0XHRydWxlOiBydWxlTmFtZSxcblx0XHRcdFx0XHRcdHBhcmFtczogcGFyYW1zXG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cdFx0fSxcblxuXHRcdC8vIGxvb3BzIHRocm91Z2ggYWxsIGt2LnJ1bGVzIGFuZCBhZGRzIHRoZW0gYXMgZXh0ZW5kZXJzIHRvXG5cdFx0Ly8ga28uZXh0ZW5kZXJzXG5cdFx0cmVnaXN0ZXJFeHRlbmRlcnM6IGZ1bmN0aW9uICgpIHsgLy8gcm9vdCBleHRlbmRlcnMgb3B0aW9uYWwsIHVzZSAndmFsaWRhdGlvbicgZXh0ZW5kZXIgaWYgd291bGQgY2F1c2UgY29uZmxpY3RzXG5cdFx0XHRpZiAoY29uZmlndXJhdGlvbi5yZWdpc3RlckV4dGVuZGVycykge1xuXHRcdFx0XHRmb3IgKHZhciBydWxlTmFtZSBpbiBrdi5ydWxlcykge1xuXHRcdFx0XHRcdGlmIChrdi5ydWxlcy5oYXNPd25Qcm9wZXJ0eShydWxlTmFtZSkpIHtcblx0XHRcdFx0XHRcdGlmICgha28uZXh0ZW5kZXJzW3J1bGVOYW1lXSkge1xuXHRcdFx0XHRcdFx0XHRrdi5hZGRFeHRlbmRlcihydWxlTmFtZSk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdC8vY3JlYXRlcyBhIHNwYW4gbmV4dCB0byB0aGUgQGVsZW1lbnQgd2l0aCB0aGUgc3BlY2lmaWVkIGVycm9yIGNsYXNzXG5cdFx0aW5zZXJ0VmFsaWRhdGlvbk1lc3NhZ2U6IGZ1bmN0aW9uIChlbGVtZW50KSB7XG5cdFx0XHR2YXIgc3BhbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ1NQQU4nKTtcblx0XHRcdHNwYW4uY2xhc3NOYW1lID0gdXRpbHMuZ2V0Q29uZmlnT3B0aW9ucyhlbGVtZW50KS5lcnJvck1lc3NhZ2VDbGFzcztcblx0XHRcdHV0aWxzLmluc2VydEFmdGVyKGVsZW1lbnQsIHNwYW4pO1xuXHRcdFx0cmV0dXJuIHNwYW47XG5cdFx0fSxcblxuXHRcdC8vIGlmIGh0bWwtNSB2YWxpZGF0aW9uIGF0dHJpYnV0ZXMgaGF2ZSBiZWVuIHNwZWNpZmllZCwgdGhpcyBwYXJzZXNcblx0XHQvLyB0aGUgYXR0cmlidXRlcyBvbiBAZWxlbWVudFxuXHRcdHBhcnNlSW5wdXRWYWxpZGF0aW9uQXR0cmlidXRlczogZnVuY3Rpb24gKGVsZW1lbnQsIHZhbHVlQWNjZXNzb3IpIHtcblx0XHRcdGZvckVhY2goa3YuY29uZmlndXJhdGlvbi5odG1sNUF0dHJpYnV0ZXMsIGZ1bmN0aW9uIChhdHRyKSB7XG5cdFx0XHRcdGlmICh1dGlscy5oYXNBdHRyaWJ1dGUoZWxlbWVudCwgYXR0cikpIHtcblxuXHRcdFx0XHRcdHZhciBwYXJhbXMgPSBlbGVtZW50LmdldEF0dHJpYnV0ZShhdHRyKSB8fCB0cnVlO1xuXG5cdFx0XHRcdFx0aWYgKGF0dHIgPT09ICdtaW4nIHx8IGF0dHIgPT09ICdtYXgnKVxuXHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdC8vIElmIHdlJ3JlIHZhbGlkYXRpbmcgYmFzZWQgb24gdGhlIG1pbiBhbmQgbWF4IGF0dHJpYnV0ZXMsIHdlJ2xsXG5cdFx0XHRcdFx0XHQvLyBuZWVkIHRvIGtub3cgd2hhdCB0aGUgJ3R5cGUnIGF0dHJpYnV0ZSBpcyBzZXQgdG9cblx0XHRcdFx0XHRcdHZhciB0eXBlQXR0ciA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCd0eXBlJyk7XG5cdFx0XHRcdFx0XHRpZiAodHlwZW9mIHR5cGVBdHRyID09PSBcInVuZGVmaW5lZFwiIHx8ICF0eXBlQXR0cilcblx0XHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdFx0Ly8gRnJvbSBodHRwOi8vd3d3LnczLm9yZy9UUi9odG1sLW1hcmt1cC9pbnB1dDpcblx0XHRcdFx0XHRcdFx0Ly8gICBBbiBpbnB1dCBlbGVtZW50IHdpdGggbm8gdHlwZSBhdHRyaWJ1dGUgc3BlY2lmaWVkIHJlcHJlc2VudHMgdGhlXG5cdFx0XHRcdFx0XHRcdC8vICAgc2FtZSB0aGluZyBhcyBhbiBpbnB1dCBlbGVtZW50IHdpdGggaXRzIHR5cGUgYXR0cmlidXRlIHNldCB0byBcInRleHRcIi5cblx0XHRcdFx0XHRcdFx0dHlwZUF0dHIgPSBcInRleHRcIjtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdHBhcmFtcyA9IHt0eXBlQXR0cjogdHlwZUF0dHIsIHZhbHVlOiBwYXJhbXN9O1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGt2LmFkZFJ1bGUodmFsdWVBY2Nlc3NvcigpLCB7XG5cdFx0XHRcdFx0XHRydWxlOiBhdHRyLFxuXHRcdFx0XHRcdFx0cGFyYW1zOiBwYXJhbXNcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cblx0XHRcdHZhciBjdXJyZW50VHlwZSA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCd0eXBlJyk7XG5cdFx0XHRmb3JFYWNoKGt2LmNvbmZpZ3VyYXRpb24uaHRtbDVJbnB1dFR5cGVzLCBmdW5jdGlvbiAodHlwZSkge1xuXHRcdFx0XHRpZiAodHlwZSA9PT0gY3VycmVudFR5cGUpIHtcblx0XHRcdFx0XHRrdi5hZGRSdWxlKHZhbHVlQWNjZXNzb3IoKSwge1xuXHRcdFx0XHRcdFx0cnVsZTogKHR5cGUgPT09ICdkYXRlJykgPyAnZGF0ZUlTTycgOiB0eXBlLFxuXHRcdFx0XHRcdFx0cGFyYW1zOiB0cnVlXG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdH0sXG5cblx0XHQvLyB3cml0ZXMgaHRtbDUgdmFsaWRhdGlvbiBhdHRyaWJ1dGVzIG9uIHRoZSBlbGVtZW50IHBhc3NlZCBpblxuXHRcdHdyaXRlSW5wdXRWYWxpZGF0aW9uQXR0cmlidXRlczogZnVuY3Rpb24gKGVsZW1lbnQsIHZhbHVlQWNjZXNzb3IpIHtcblx0XHRcdHZhciBvYnNlcnZhYmxlID0gdmFsdWVBY2Nlc3NvcigpO1xuXG5cdFx0XHRpZiAoIW9ic2VydmFibGUgfHwgIW9ic2VydmFibGUucnVsZXMpIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHR2YXIgY29udGV4dHMgPSBvYnNlcnZhYmxlLnJ1bGVzKCk7IC8vIG9ic2VydmFibGUgYXJyYXlcblxuXHRcdFx0Ly8gbG9vcCB0aHJvdWdoIHRoZSBhdHRyaWJ1dGVzIGFuZCBhZGQgdGhlIGluZm9ybWF0aW9uIG5lZWRlZFxuXHRcdFx0Zm9yRWFjaChrdi5jb25maWd1cmF0aW9uLmh0bWw1QXR0cmlidXRlcywgZnVuY3Rpb24gKGF0dHIpIHtcblx0XHRcdFx0dmFyIGN0eCA9IGtvVXRpbHMuYXJyYXlGaXJzdChjb250ZXh0cywgZnVuY3Rpb24gKGN0eCkge1xuXHRcdFx0XHRcdHJldHVybiBjdHgucnVsZSAmJiBjdHgucnVsZS50b0xvd2VyQ2FzZSgpID09PSBhdHRyLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHRcdH0pO1xuXG5cdFx0XHRcdGlmICghY3R4KSB7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gd2UgaGF2ZSBhIHJ1bGUgbWF0Y2hpbmcgYSB2YWxpZGF0aW9uIGF0dHJpYnV0ZSBhdCB0aGlzIHBvaW50XG5cdFx0XHRcdC8vIHNvIGxldHMgYWRkIGl0IHRvIHRoZSBlbGVtZW50IGFsb25nIHdpdGggdGhlIHBhcmFtc1xuXHRcdFx0XHRrby5jb21wdXRlZCh7XG5cdFx0XHRcdFx0cmVhZDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHR2YXIgcGFyYW1zID0ga28udW53cmFwKGN0eC5wYXJhbXMpO1xuXG5cdFx0XHRcdFx0XHQvLyB3ZSBoYXZlIHRvIGRvIHNvbWUgc3BlY2lhbCB0aGluZ3MgZm9yIHRoZSBwYXR0ZXJuIHZhbGlkYXRpb25cblx0XHRcdFx0XHRcdGlmIChjdHgucnVsZSA9PT0gXCJwYXR0ZXJuXCIgJiYgcGFyYW1zIGluc3RhbmNlb2YgUmVnRXhwKSB7XG5cdFx0XHRcdFx0XHRcdC8vIHdlIG5lZWQgdGhlIHB1cmUgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBSZWdFeHByIHdpdGhvdXQgdGhlIC8vZ2kgc3R1ZmZcblx0XHRcdFx0XHRcdFx0cGFyYW1zID0gcGFyYW1zLnNvdXJjZTtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0ZWxlbWVudC5zZXRBdHRyaWJ1dGUoYXR0ciwgcGFyYW1zKTtcblx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdGRpc3Bvc2VXaGVuTm9kZUlzUmVtb3ZlZDogZWxlbWVudFxuXHRcdFx0XHR9KTtcblx0XHRcdH0pO1xuXG5cdFx0XHRjb250ZXh0cyA9IG51bGw7XG5cdFx0fSxcblxuXHRcdC8vdGFrZSBhbiBleGlzdGluZyBiaW5kaW5nIGhhbmRsZXIgYW5kIG1ha2UgaXQgY2F1c2UgYXV0b21hdGljIHZhbGlkYXRpb25zXG5cdFx0bWFrZUJpbmRpbmdIYW5kbGVyVmFsaWRhdGFibGU6IGZ1bmN0aW9uIChoYW5kbGVyTmFtZSkge1xuXHRcdFx0dmFyIGluaXQgPSBrby5iaW5kaW5nSGFuZGxlcnNbaGFuZGxlck5hbWVdLmluaXQ7XG5cblx0XHRcdGtvLmJpbmRpbmdIYW5kbGVyc1toYW5kbGVyTmFtZV0uaW5pdCA9IGZ1bmN0aW9uIChlbGVtZW50LCB2YWx1ZUFjY2Vzc29yLCBhbGxCaW5kaW5nc0FjY2Vzc29yLCB2aWV3TW9kZWwsIGJpbmRpbmdDb250ZXh0KSB7XG5cblx0XHRcdFx0aW5pdChlbGVtZW50LCB2YWx1ZUFjY2Vzc29yLCBhbGxCaW5kaW5nc0FjY2Vzc29yLCB2aWV3TW9kZWwsIGJpbmRpbmdDb250ZXh0KTtcblxuXHRcdFx0XHRyZXR1cm4ga28uYmluZGluZ0hhbmRsZXJzWyd2YWxpZGF0aW9uQ29yZSddLmluaXQoZWxlbWVudCwgdmFsdWVBY2Nlc3NvciwgYWxsQmluZGluZ3NBY2Nlc3Nvciwgdmlld01vZGVsLCBiaW5kaW5nQ29udGV4dCk7XG5cdFx0XHR9O1xuXHRcdH0sXG5cblx0XHQvLyB2aXNpdCBhbiBvYmplY3RzIHByb3BlcnRpZXMgYW5kIGFwcGx5IHZhbGlkYXRpb24gcnVsZXMgZnJvbSBhIGRlZmluaXRpb25cblx0XHRzZXRSdWxlczogZnVuY3Rpb24gKHRhcmdldCwgZGVmaW5pdGlvbikge1xuXHRcdFx0dmFyIHNldFJ1bGVzID0gZnVuY3Rpb24gKHRhcmdldCwgZGVmaW5pdGlvbikge1xuXHRcdFx0XHRpZiAoIXRhcmdldCB8fCAhZGVmaW5pdGlvbikgeyByZXR1cm47IH1cblxuXHRcdFx0XHRmb3IgKHZhciBwcm9wIGluIGRlZmluaXRpb24pIHtcblx0XHRcdFx0XHRpZiAoIWRlZmluaXRpb24uaGFzT3duUHJvcGVydHkocHJvcCkpIHsgY29udGludWU7IH1cblx0XHRcdFx0XHR2YXIgcnVsZURlZmluaXRpb25zID0gZGVmaW5pdGlvbltwcm9wXTtcblxuXHRcdFx0XHRcdC8vY2hlY2sgdGhlIHRhcmdldCBwcm9wZXJ0eSBleGlzdHMgYW5kIGhhcyBhIHZhbHVlXG5cdFx0XHRcdFx0aWYgKCF0YXJnZXRbcHJvcF0pIHsgY29udGludWU7IH1cblx0XHRcdFx0XHR2YXIgdGFyZ2V0VmFsdWUgPSB0YXJnZXRbcHJvcF0sXG5cdFx0XHRcdFx0XHR1bndyYXBwZWRUYXJnZXRWYWx1ZSA9IHVud3JhcCh0YXJnZXRWYWx1ZSksXG5cdFx0XHRcdFx0XHRydWxlcyA9IHt9LFxuXHRcdFx0XHRcdFx0bm9uUnVsZXMgPSB7fTtcblxuXHRcdFx0XHRcdGZvciAodmFyIHJ1bGUgaW4gcnVsZURlZmluaXRpb25zKSB7XG5cdFx0XHRcdFx0XHRpZiAoIXJ1bGVEZWZpbml0aW9ucy5oYXNPd25Qcm9wZXJ0eShydWxlKSkgeyBjb250aW51ZTsgfVxuXHRcdFx0XHRcdFx0aWYgKGt2LnJ1bGVzW3J1bGVdKSB7XG5cdFx0XHRcdFx0XHRcdHJ1bGVzW3J1bGVdID0gcnVsZURlZmluaXRpb25zW3J1bGVdO1xuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0bm9uUnVsZXNbcnVsZV0gPSBydWxlRGVmaW5pdGlvbnNbcnVsZV07XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly9hcHBseSBydWxlc1xuXHRcdFx0XHRcdGlmIChrby5pc09ic2VydmFibGUodGFyZ2V0VmFsdWUpKSB7XG5cdFx0XHRcdFx0XHR0YXJnZXRWYWx1ZS5leHRlbmQocnVsZXMpO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vdGhlbiBhcHBseSBjaGlsZCBydWxlc1xuXHRcdFx0XHRcdC8vaWYgaXQncyBhbiBhcnJheSwgYXBwbHkgcnVsZXMgdG8gYWxsIGNoaWxkcmVuXG5cdFx0XHRcdFx0aWYgKHVud3JhcHBlZFRhcmdldFZhbHVlICYmIHV0aWxzLmlzQXJyYXkodW53cmFwcGVkVGFyZ2V0VmFsdWUpKSB7XG5cdFx0XHRcdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHVud3JhcHBlZFRhcmdldFZhbHVlLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdFx0XHRcdHNldFJ1bGVzKHVud3JhcHBlZFRhcmdldFZhbHVlW2ldLCBub25SdWxlcyk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHQvL290aGVyd2lzZSwganVzdCBhcHBseSB0byB0aGlzIHByb3BlcnR5XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHNldFJ1bGVzKHVud3JhcHBlZFRhcmdldFZhbHVlLCBub25SdWxlcyk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXHRcdFx0c2V0UnVsZXModGFyZ2V0LCBkZWZpbml0aW9uKTtcblx0XHR9XG5cdH07XG5cbn0oKSk7XG5cbi8vIGV4cG9zZSBhcGkgcHVibGljbHlcbmV4dGVuZChrby52YWxpZGF0aW9uLCBhcGkpO1xuOy8vVmFsaWRhdGlvbiBSdWxlczpcbi8vIFlvdSBjYW4gdmlldyBhbmQgb3ZlcnJpZGUgbWVzc2FnZXMgb3IgcnVsZXMgdmlhOlxuLy8ga3YucnVsZXNbcnVsZU5hbWVdXG4vL1xuLy8gVG8gaW1wbGVtZW50IGEgY3VzdG9tIFJ1bGUsIHNpbXBseSB1c2UgdGhpcyB0ZW1wbGF0ZTpcbi8vIGt2LnJ1bGVzWyc8Y3VzdG9tIHJ1bGUgbmFtZT4nXSA9IHtcbi8vICAgICAgdmFsaWRhdG9yOiBmdW5jdGlvbiAodmFsLCBwYXJhbSkge1xuLy8gICAgICAgICAgPGN1c3RvbSBsb2dpYz5cbi8vICAgICAgICAgIHJldHVybiA8dHJ1ZSBvciBmYWxzZT47XG4vLyAgICAgIH0sXG4vLyAgICAgIG1lc3NhZ2U6ICc8Y3VzdG9tIHZhbGlkYXRpb24gbWVzc2FnZT4nIC8vb3B0aW9uYWxseSB5b3UgY2FuIGFsc28gdXNlIGEgJ3swfScgdG8gZGVub3RlIGEgcGxhY2Vob2xkZXIgdGhhdCB3aWxsIGJlIHJlcGxhY2VkIHdpdGggeW91ciAncGFyYW0nXG4vLyB9O1xuLy9cbi8vIEV4YW1wbGU6XG4vLyBrdi5ydWxlc1snbXVzdEVxdWFsJ10gPSB7XG4vLyAgICAgIHZhbGlkYXRvcjogZnVuY3Rpb24oIHZhbCwgbXVzdEVxdWFsVmFsICl7XG4vLyAgICAgICAgICByZXR1cm4gdmFsID09PSBtdXN0RXF1YWxWYWw7XG4vLyAgICAgIH0sXG4vLyAgICAgIG1lc3NhZ2U6ICdUaGlzIGZpZWxkIG11c3QgZXF1YWwgezB9J1xuLy8gfTtcbi8vXG5rdi5ydWxlcyA9IHt9O1xua3YucnVsZXNbJ3JlcXVpcmVkJ10gPSB7XG5cdHZhbGlkYXRvcjogZnVuY3Rpb24gKHZhbCwgcmVxdWlyZWQpIHtcblx0XHR2YXIgdGVzdFZhbDtcblxuXHRcdGlmICh2YWwgPT09IHVuZGVmaW5lZCB8fCB2YWwgPT09IG51bGwpIHtcblx0XHRcdHJldHVybiAhcmVxdWlyZWQ7XG5cdFx0fVxuXG5cdFx0dGVzdFZhbCA9IHZhbDtcblx0XHRpZiAodHlwZW9mICh2YWwpID09PSAnc3RyaW5nJykge1xuXHRcdFx0aWYgKFN0cmluZy5wcm90b3R5cGUudHJpbSkge1xuXHRcdFx0XHR0ZXN0VmFsID0gdmFsLnRyaW0oKTtcblx0XHRcdH1cblx0XHRcdGVsc2Uge1xuXHRcdFx0XHR0ZXN0VmFsID0gdmFsLnJlcGxhY2UoL15cXHMrfFxccyskL2csICcnKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoIXJlcXVpcmVkKSB7Ly8gaWYgdGhleSBwYXNzZWQ6IHsgcmVxdWlyZWQ6IGZhbHNlIH0sIHRoZW4gZG9uJ3QgcmVxdWlyZSB0aGlzXG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cblx0XHRyZXR1cm4gKCh0ZXN0VmFsICsgJycpLmxlbmd0aCA+IDApO1xuXHR9LFxuXHRtZXNzYWdlOiAnVGhpcyBmaWVsZCBpcyByZXF1aXJlZC4nXG59O1xuXG5mdW5jdGlvbiBtaW5NYXhWYWxpZGF0b3JGYWN0b3J5KHZhbGlkYXRvck5hbWUpIHtcbiAgICB2YXIgaXNNYXhWYWxpZGF0aW9uID0gdmFsaWRhdG9yTmFtZSA9PT0gXCJtYXhcIjtcblxuICAgIHJldHVybiBmdW5jdGlvbiAodmFsLCBvcHRpb25zKSB7XG4gICAgICAgIGlmIChrdi51dGlscy5pc0VtcHR5VmFsKHZhbCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGNvbXBhcmlzb25WYWx1ZSwgdHlwZTtcbiAgICAgICAgaWYgKG9wdGlvbnMudHlwZUF0dHIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgLy8gVGhpcyB2YWxpZGF0b3IgaXMgYmVpbmcgY2FsbGVkIGZyb20gamF2YXNjcmlwdCByYXRoZXIgdGhhblxuICAgICAgICAgICAgLy8gYmVpbmcgYm91bmQgZnJvbSBtYXJrdXBcbiAgICAgICAgICAgIHR5cGUgPSBcInRleHRcIjtcbiAgICAgICAgICAgIGNvbXBhcmlzb25WYWx1ZSA9IG9wdGlvbnM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0eXBlID0gb3B0aW9ucy50eXBlQXR0cjtcbiAgICAgICAgICAgIGNvbXBhcmlzb25WYWx1ZSA9IG9wdGlvbnMudmFsdWU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBGcm9tIGh0dHA6Ly93d3cudzMub3JnL1RSLzIwMTIvV0QtaHRtbDUtMjAxMjEwMjUvY29tbW9uLWlucHV0LWVsZW1lbnQtYXR0cmlidXRlcy5odG1sI2F0dHItaW5wdXQtbWluLFxuICAgICAgICAvLyBpZiB0aGUgdmFsdWUgaXMgcGFyc2VhYmxlIHRvIGEgbnVtYmVyLCB0aGVuIHRoZSBtaW5pbXVtIHNob3VsZCBiZSBudW1lcmljXG4gICAgICAgIGlmICghaXNOYU4oY29tcGFyaXNvblZhbHVlKSAmJiAhKGNvbXBhcmlzb25WYWx1ZSBpbnN0YW5jZW9mIERhdGUpKSB7XG4gICAgICAgICAgICB0eXBlID0gXCJudW1iZXJcIjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciByZWdleCwgdmFsTWF0Y2hlcywgY29tcGFyaXNvblZhbHVlTWF0Y2hlcztcbiAgICAgICAgc3dpdGNoICh0eXBlLnRvTG93ZXJDYXNlKCkpIHtcbiAgICAgICAgICAgIGNhc2UgXCJ3ZWVrXCI6XG4gICAgICAgICAgICAgICAgcmVnZXggPSAvXihcXGR7NH0pLVcoXFxkezJ9KSQvO1xuICAgICAgICAgICAgICAgIHZhbE1hdGNoZXMgPSB2YWwubWF0Y2gocmVnZXgpO1xuICAgICAgICAgICAgICAgIGlmICh2YWxNYXRjaGVzID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgdmFsdWUgZm9yIFwiICsgdmFsaWRhdG9yTmFtZSArIFwiIGF0dHJpYnV0ZSBmb3Igd2VlayBpbnB1dC4gIFNob3VsZCBsb29rIGxpa2UgXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgXCInMjAwMC1XMzMnIGh0dHA6Ly93d3cudzMub3JnL1RSL2h0bWwtbWFya3VwL2lucHV0LndlZWsuaHRtbCNpbnB1dC53ZWVrLmF0dHJzLm1pblwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29tcGFyaXNvblZhbHVlTWF0Y2hlcyA9IGNvbXBhcmlzb25WYWx1ZS5tYXRjaChyZWdleCk7XG4gICAgICAgICAgICAgICAgLy8gSWYgbm8gcmVnZXggbWF0Y2hlcyB3ZXJlIGZvdW5kLCB2YWxpZGF0aW9uIGZhaWxzXG4gICAgICAgICAgICAgICAgaWYgKCFjb21wYXJpc29uVmFsdWVNYXRjaGVzKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoaXNNYXhWYWxpZGF0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAodmFsTWF0Y2hlc1sxXSA8IGNvbXBhcmlzb25WYWx1ZU1hdGNoZXNbMV0pIHx8IC8vIG9sZGVyIHllYXJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNhbWUgeWVhciwgb2xkZXIgd2Vla1xuICAgICAgICAgICAgICAgICAgICAgICAgKCh2YWxNYXRjaGVzWzFdID09PSBjb21wYXJpc29uVmFsdWVNYXRjaGVzWzFdKSAmJiAodmFsTWF0Y2hlc1syXSA8PSBjb21wYXJpc29uVmFsdWVNYXRjaGVzWzJdKSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICh2YWxNYXRjaGVzWzFdID4gY29tcGFyaXNvblZhbHVlTWF0Y2hlc1sxXSkgfHwgLy8gbmV3ZXIgeWVhclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gc2FtZSB5ZWFyLCBuZXdlciB3ZWVrXG4gICAgICAgICAgICAgICAgICAgICAgICAoKHZhbE1hdGNoZXNbMV0gPT09IGNvbXBhcmlzb25WYWx1ZU1hdGNoZXNbMV0pICYmICh2YWxNYXRjaGVzWzJdID49IGNvbXBhcmlzb25WYWx1ZU1hdGNoZXNbMl0pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgXCJtb250aFwiOlxuICAgICAgICAgICAgICAgIHJlZ2V4ID0gL14oXFxkezR9KS0oXFxkezJ9KSQvO1xuICAgICAgICAgICAgICAgIHZhbE1hdGNoZXMgPSB2YWwubWF0Y2gocmVnZXgpO1xuICAgICAgICAgICAgICAgIGlmICh2YWxNYXRjaGVzID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgdmFsdWUgZm9yIFwiICsgdmFsaWRhdG9yTmFtZSArIFwiIGF0dHJpYnV0ZSBmb3IgbW9udGggaW5wdXQuICBTaG91bGQgbG9vayBsaWtlIFwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiJzIwMDAtMDMnIGh0dHA6Ly93d3cudzMub3JnL1RSL2h0bWwtbWFya3VwL2lucHV0Lm1vbnRoLmh0bWwjaW5wdXQubW9udGguYXR0cnMubWluXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb21wYXJpc29uVmFsdWVNYXRjaGVzID0gY29tcGFyaXNvblZhbHVlLm1hdGNoKHJlZ2V4KTtcbiAgICAgICAgICAgICAgICAvLyBJZiBubyByZWdleCBtYXRjaGVzIHdlcmUgZm91bmQsIHZhbGlkYXRpb24gZmFpbHNcbiAgICAgICAgICAgICAgICBpZiAoIWNvbXBhcmlzb25WYWx1ZU1hdGNoZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChpc01heFZhbGlkYXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICgodmFsTWF0Y2hlc1sxXSA8IGNvbXBhcmlzb25WYWx1ZU1hdGNoZXNbMV0pIHx8IC8vIG9sZGVyIHllYXJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNhbWUgeWVhciwgb2xkZXIgbW9udGhcbiAgICAgICAgICAgICAgICAgICAgICAgICgodmFsTWF0Y2hlc1sxXSA9PT0gY29tcGFyaXNvblZhbHVlTWF0Y2hlc1sxXSkgJiYgKHZhbE1hdGNoZXNbMl0gPD0gY29tcGFyaXNvblZhbHVlTWF0Y2hlc1syXSkpKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKHZhbE1hdGNoZXNbMV0gPiBjb21wYXJpc29uVmFsdWVNYXRjaGVzWzFdKSB8fCAvLyBuZXdlciB5ZWFyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBzYW1lIHllYXIsIG5ld2VyIG1vbnRoXG4gICAgICAgICAgICAgICAgICAgICAgICAoKHZhbE1hdGNoZXNbMV0gPT09IGNvbXBhcmlzb25WYWx1ZU1hdGNoZXNbMV0pICYmICh2YWxNYXRjaGVzWzJdID49IGNvbXBhcmlzb25WYWx1ZU1hdGNoZXNbMl0pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgXCJudW1iZXJcIjpcbiAgICAgICAgICAgIGNhc2UgXCJyYW5nZVwiOlxuICAgICAgICAgICAgICAgIGlmIChpc01heFZhbGlkYXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICghaXNOYU4odmFsKSAmJiBwYXJzZUZsb2F0KHZhbCkgPD0gcGFyc2VGbG9hdChjb21wYXJpc29uVmFsdWUpKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKCFpc05hTih2YWwpICYmIHBhcnNlRmxvYXQodmFsKSA+PSBwYXJzZUZsb2F0KGNvbXBhcmlzb25WYWx1ZSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBpZiAoaXNNYXhWYWxpZGF0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWwgPD0gY29tcGFyaXNvblZhbHVlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWwgPj0gY29tcGFyaXNvblZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG59XG5cbmt2LnJ1bGVzWydtaW4nXSA9IHtcblx0dmFsaWRhdG9yOiBtaW5NYXhWYWxpZGF0b3JGYWN0b3J5KFwibWluXCIpLFxuXHRtZXNzYWdlOiAnUGxlYXNlIGVudGVyIGEgdmFsdWUgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIHswfS4nXG59O1xuXG5rdi5ydWxlc1snbWF4J10gPSB7XG5cdHZhbGlkYXRvcjogbWluTWF4VmFsaWRhdG9yRmFjdG9yeShcIm1heFwiKSxcblx0bWVzc2FnZTogJ1BsZWFzZSBlbnRlciBhIHZhbHVlIGxlc3MgdGhhbiBvciBlcXVhbCB0byB7MH0uJ1xufTtcblxua3YucnVsZXNbJ21pbkxlbmd0aCddID0ge1xuXHR2YWxpZGF0b3I6IGZ1bmN0aW9uICh2YWwsIG1pbkxlbmd0aCkge1xuXHRcdGlmKGt2LnV0aWxzLmlzRW1wdHlWYWwodmFsKSkgeyByZXR1cm4gdHJ1ZTsgfVxuXHRcdHZhciBub3JtYWxpemVkVmFsID0ga3YudXRpbHMuaXNOdW1iZXIodmFsKSA/ICgnJyArIHZhbCkgOiB2YWw7XG5cdFx0cmV0dXJuIG5vcm1hbGl6ZWRWYWwubGVuZ3RoID49IG1pbkxlbmd0aDtcblx0fSxcblx0bWVzc2FnZTogJ1BsZWFzZSBlbnRlciBhdCBsZWFzdCB7MH0gY2hhcmFjdGVycy4nXG59O1xuXG5rdi5ydWxlc1snbWF4TGVuZ3RoJ10gPSB7XG5cdHZhbGlkYXRvcjogZnVuY3Rpb24gKHZhbCwgbWF4TGVuZ3RoKSB7XG5cdFx0aWYoa3YudXRpbHMuaXNFbXB0eVZhbCh2YWwpKSB7IHJldHVybiB0cnVlOyB9XG5cdFx0dmFyIG5vcm1hbGl6ZWRWYWwgPSBrdi51dGlscy5pc051bWJlcih2YWwpID8gKCcnICsgdmFsKSA6IHZhbDtcblx0XHRyZXR1cm4gbm9ybWFsaXplZFZhbC5sZW5ndGggPD0gbWF4TGVuZ3RoO1xuXHR9LFxuXHRtZXNzYWdlOiAnUGxlYXNlIGVudGVyIG5vIG1vcmUgdGhhbiB7MH0gY2hhcmFjdGVycy4nXG59O1xuXG5rdi5ydWxlc1sncGF0dGVybiddID0ge1xuXHR2YWxpZGF0b3I6IGZ1bmN0aW9uICh2YWwsIHJlZ2V4KSB7XG5cdFx0cmV0dXJuIGt2LnV0aWxzLmlzRW1wdHlWYWwodmFsKSB8fCB2YWwudG9TdHJpbmcoKS5tYXRjaChyZWdleCkgIT09IG51bGw7XG5cdH0sXG5cdG1lc3NhZ2U6ICdQbGVhc2UgY2hlY2sgdGhpcyB2YWx1ZS4nXG59O1xuXG5rdi5ydWxlc1snc3RlcCddID0ge1xuXHR2YWxpZGF0b3I6IGZ1bmN0aW9uICh2YWwsIHN0ZXApIHtcblxuXHRcdC8vIGluIG9yZGVyIHRvIGhhbmRsZSBzdGVwcyBvZiAuMSAmIC4wMSBldGMuLiBNb2R1bHVzIHdvbid0IHdvcmtcblx0XHQvLyBpZiB0aGUgdmFsdWUgaXMgYSBkZWNpbWFsLCBzbyB3ZSBoYXZlIHRvIGNvcnJlY3QgZm9yIHRoYXRcblx0XHRpZiAoa3YudXRpbHMuaXNFbXB0eVZhbCh2YWwpIHx8IHN0ZXAgPT09ICdhbnknKSB7IHJldHVybiB0cnVlOyB9XG5cdFx0dmFyIGRpZiA9ICh2YWwgKiAxMDApICUgKHN0ZXAgKiAxMDApO1xuXHRcdHJldHVybiBNYXRoLmFicyhkaWYpIDwgMC4wMDAwMSB8fCBNYXRoLmFicygxIC0gZGlmKSA8IDAuMDAwMDE7XG5cdH0sXG5cdG1lc3NhZ2U6ICdUaGUgdmFsdWUgbXVzdCBpbmNyZW1lbnQgYnkgezB9Lidcbn07XG5cbmt2LnJ1bGVzWydlbWFpbCddID0ge1xuXHR2YWxpZGF0b3I6IGZ1bmN0aW9uICh2YWwsIHZhbGlkYXRlKSB7XG5cdFx0aWYgKCF2YWxpZGF0ZSkgeyByZXR1cm4gdHJ1ZTsgfVxuXG5cdFx0Ly9JIHRoaW5rIGFuIGVtcHR5IGVtYWlsIGFkZHJlc3MgaXMgYWxzbyBhIHZhbGlkIGVudHJ5XG5cdFx0Ly9pZiBvbmUgd2FudCdzIHRvIGVuZm9yY2UgZW50cnkgaXQgc2hvdWxkIGJlIGRvbmUgd2l0aCAncmVxdWlyZWQ6IHRydWUnXG5cdFx0cmV0dXJuIGt2LnV0aWxzLmlzRW1wdHlWYWwodmFsKSB8fCAoXG5cdFx0XHQvLyBqcXVlcnkgdmFsaWRhdGUgcmVnZXggLSB0aGFua3MgU2NvdHQgR29uemFsZXpcblx0XHRcdHZhbGlkYXRlICYmIC9eKCgoW2Etel18XFxkfFshI1xcJCUmJ1xcKlxcK1xcLVxcLz1cXD9cXF5fYHtcXHx9fl18W1xcdTAwQTAtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZFRl0pKyhcXC4oW2Etel18XFxkfFshI1xcJCUmJ1xcKlxcK1xcLVxcLz1cXD9cXF5fYHtcXHx9fl18W1xcdTAwQTAtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZFRl0pKykqKXwoKFxceDIyKSgoKChcXHgyMHxcXHgwOSkqKFxceDBkXFx4MGEpKT8oXFx4MjB8XFx4MDkpKyk/KChbXFx4MDEtXFx4MDhcXHgwYlxceDBjXFx4MGUtXFx4MWZcXHg3Zl18XFx4MjF8W1xceDIzLVxceDViXXxbXFx4NWQtXFx4N2VdfFtcXHUwMEEwLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRUZdKXwoXFxcXChbXFx4MDEtXFx4MDlcXHgwYlxceDBjXFx4MGQtXFx4N2ZdfFtcXHUwMEEwLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRUZdKSkpKSooKChcXHgyMHxcXHgwOSkqKFxceDBkXFx4MGEpKT8oXFx4MjB8XFx4MDkpKyk/KFxceDIyKSkpQCgoKFthLXpdfFxcZHxbXFx1MDBBMC1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkVGXSl8KChbYS16XXxcXGR8W1xcdTAwQTAtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZFRl0pKFthLXpdfFxcZHwtfFxcLnxffH58W1xcdTAwQTAtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZFRl0pKihbYS16XXxcXGR8W1xcdTAwQTAtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZFRl0pKSlcXC4pKygoW2Etel18W1xcdTAwQTAtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZFRl0pfCgoW2Etel18W1xcdTAwQTAtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZFRl0pKFthLXpdfFxcZHwtfFxcLnxffH58W1xcdTAwQTAtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZFRl0pKihbYS16XXxbXFx1MDBBMC1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkVGXSkpKSQvaS50ZXN0KHZhbClcblx0XHQpO1xuXHR9LFxuXHRtZXNzYWdlOiAnUGxlYXNlIGVudGVyIGEgcHJvcGVyIGVtYWlsIGFkZHJlc3MuJ1xufTtcblxua3YucnVsZXNbJ2RhdGUnXSA9IHtcblx0dmFsaWRhdG9yOiBmdW5jdGlvbiAodmFsdWUsIHZhbGlkYXRlKSB7XG5cdFx0aWYgKCF2YWxpZGF0ZSkgeyByZXR1cm4gdHJ1ZTsgfVxuXHRcdHJldHVybiBrdi51dGlscy5pc0VtcHR5VmFsKHZhbHVlKSB8fCAodmFsaWRhdGUgJiYgIS9JbnZhbGlkfE5hTi8udGVzdChuZXcgRGF0ZSh2YWx1ZSkpKTtcblx0fSxcblx0bWVzc2FnZTogJ1BsZWFzZSBlbnRlciBhIHByb3BlciBkYXRlLidcbn07XG5cbmt2LnJ1bGVzWydkYXRlSVNPJ10gPSB7XG5cdHZhbGlkYXRvcjogZnVuY3Rpb24gKHZhbHVlLCB2YWxpZGF0ZSkge1xuXHRcdGlmICghdmFsaWRhdGUpIHsgcmV0dXJuIHRydWU7IH1cblx0XHRyZXR1cm4ga3YudXRpbHMuaXNFbXB0eVZhbCh2YWx1ZSkgfHwgKHZhbGlkYXRlICYmIC9eXFxkezR9Wy0vXSg/OjA/WzEtOV18MVswMTJdKVstL10oPzowP1sxLTldfFsxMl1bMC05XXwzWzAxXSkkLy50ZXN0KHZhbHVlKSk7XG5cdH0sXG5cdG1lc3NhZ2U6ICdQbGVhc2UgZW50ZXIgYSBwcm9wZXIgZGF0ZS4nXG59O1xuXG5rdi5ydWxlc1snbnVtYmVyJ10gPSB7XG5cdHZhbGlkYXRvcjogZnVuY3Rpb24gKHZhbHVlLCB2YWxpZGF0ZSkge1xuXHRcdGlmICghdmFsaWRhdGUpIHsgcmV0dXJuIHRydWU7IH1cblx0XHRyZXR1cm4ga3YudXRpbHMuaXNFbXB0eVZhbCh2YWx1ZSkgfHwgKHZhbGlkYXRlICYmIC9eLT8oPzpcXGQrfFxcZHsxLDN9KD86LFxcZHszfSkrKT8oPzpcXC5cXGQrKT8kLy50ZXN0KHZhbHVlKSk7XG5cdH0sXG5cdG1lc3NhZ2U6ICdQbGVhc2UgZW50ZXIgYSBudW1iZXIuJ1xufTtcblxua3YucnVsZXNbJ2RpZ2l0J10gPSB7XG5cdHZhbGlkYXRvcjogZnVuY3Rpb24gKHZhbHVlLCB2YWxpZGF0ZSkge1xuXHRcdGlmICghdmFsaWRhdGUpIHsgcmV0dXJuIHRydWU7IH1cblx0XHRyZXR1cm4ga3YudXRpbHMuaXNFbXB0eVZhbCh2YWx1ZSkgfHwgKHZhbGlkYXRlICYmIC9eXFxkKyQvLnRlc3QodmFsdWUpKTtcblx0fSxcblx0bWVzc2FnZTogJ1BsZWFzZSBlbnRlciBhIGRpZ2l0Lidcbn07XG5cbmt2LnJ1bGVzWydwaG9uZVVTJ10gPSB7XG5cdHZhbGlkYXRvcjogZnVuY3Rpb24gKHBob25lTnVtYmVyLCB2YWxpZGF0ZSkge1xuXHRcdGlmICghdmFsaWRhdGUpIHsgcmV0dXJuIHRydWU7IH1cblx0XHRpZiAoa3YudXRpbHMuaXNFbXB0eVZhbChwaG9uZU51bWJlcikpIHsgcmV0dXJuIHRydWU7IH0gLy8gbWFrZXMgaXQgb3B0aW9uYWwsIHVzZSAncmVxdWlyZWQnIHJ1bGUgaWYgaXQgc2hvdWxkIGJlIHJlcXVpcmVkXG5cdFx0aWYgKHR5cGVvZiAocGhvbmVOdW1iZXIpICE9PSAnc3RyaW5nJykgeyByZXR1cm4gZmFsc2U7IH1cblx0XHRwaG9uZU51bWJlciA9IHBob25lTnVtYmVyLnJlcGxhY2UoL1xccysvZywgXCJcIik7XG5cdFx0cmV0dXJuIHZhbGlkYXRlICYmIHBob25lTnVtYmVyLmxlbmd0aCA+IDkgJiYgcGhvbmVOdW1iZXIubWF0Y2goL14oMS0/KT8oXFwoWzItOV1cXGR7Mn1cXCl8WzItOV1cXGR7Mn0pLT9bMi05XVxcZHsyfS0/XFxkezR9JC8pO1xuXHR9LFxuXHRtZXNzYWdlOiAnUGxlYXNlIHNwZWNpZnkgYSB2YWxpZCBwaG9uZSBudW1iZXIuJ1xufTtcblxua3YucnVsZXNbJ2VxdWFsJ10gPSB7XG5cdHZhbGlkYXRvcjogZnVuY3Rpb24gKHZhbCwgcGFyYW1zKSB7XG5cdFx0dmFyIG90aGVyVmFsdWUgPSBwYXJhbXM7XG5cdFx0cmV0dXJuIHZhbCA9PT0ga3YudXRpbHMuZ2V0VmFsdWUob3RoZXJWYWx1ZSk7XG5cdH0sXG5cdG1lc3NhZ2U6ICdWYWx1ZXMgbXVzdCBlcXVhbC4nXG59O1xuXG5rdi5ydWxlc1snbm90RXF1YWwnXSA9IHtcblx0dmFsaWRhdG9yOiBmdW5jdGlvbiAodmFsLCBwYXJhbXMpIHtcblx0XHR2YXIgb3RoZXJWYWx1ZSA9IHBhcmFtcztcblx0XHRyZXR1cm4gdmFsICE9PSBrdi51dGlscy5nZXRWYWx1ZShvdGhlclZhbHVlKTtcblx0fSxcblx0bWVzc2FnZTogJ1BsZWFzZSBjaG9vc2UgYW5vdGhlciB2YWx1ZS4nXG59O1xuXG4vL3VuaXF1ZSBpbiBjb2xsZWN0aW9uXG4vLyBvcHRpb25zIGFyZTpcbi8vICAgIGNvbGxlY3Rpb246IGFycmF5IG9yIGZ1bmN0aW9uIHJldHVybmluZyAob2JzZXJ2YWJsZSkgYXJyYXlcbi8vICAgICAgICAgICAgICBpbiB3aGljaCB0aGUgdmFsdWUgaGFzIHRvIGJlIHVuaXF1ZVxuLy8gICAgdmFsdWVBY2Nlc3NvcjogZnVuY3Rpb24gdGhhdCByZXR1cm5zIHZhbHVlIGZyb20gYW4gb2JqZWN0IHN0b3JlZCBpbiBjb2xsZWN0aW9uXG4vLyAgICAgICAgICAgICAgaWYgaXQgaXMgbnVsbCB0aGUgdmFsdWUgaXMgY29tcGFyZWQgZGlyZWN0bHlcbi8vICAgIGV4dGVybmFsOiBzZXQgdG8gdHJ1ZSB3aGVuIG9iamVjdCB5b3UgYXJlIHZhbGlkYXRpbmcgaXMgYXV0b21hdGljYWxseSB1cGRhdGluZyBjb2xsZWN0aW9uXG5rdi5ydWxlc1sndW5pcXVlJ10gPSB7XG5cdHZhbGlkYXRvcjogZnVuY3Rpb24gKHZhbCwgb3B0aW9ucykge1xuXHRcdHZhciBjID0ga3YudXRpbHMuZ2V0VmFsdWUob3B0aW9ucy5jb2xsZWN0aW9uKSxcblx0XHRcdGV4dGVybmFsID0ga3YudXRpbHMuZ2V0VmFsdWUob3B0aW9ucy5leHRlcm5hbFZhbHVlKSxcblx0XHRcdGNvdW50ZXIgPSAwO1xuXG5cdFx0aWYgKCF2YWwgfHwgIWMpIHsgcmV0dXJuIHRydWU7IH1cblxuXHRcdGtvVXRpbHMuYXJyYXlGaWx0ZXIoYywgZnVuY3Rpb24gKGl0ZW0pIHtcblx0XHRcdGlmICh2YWwgPT09IChvcHRpb25zLnZhbHVlQWNjZXNzb3IgPyBvcHRpb25zLnZhbHVlQWNjZXNzb3IoaXRlbSkgOiBpdGVtKSkgeyBjb3VudGVyKys7IH1cblx0XHR9KTtcblx0XHQvLyBpZiB2YWx1ZSBpcyBleHRlcm5hbCBldmVuIDEgc2FtZSB2YWx1ZSBpbiBjb2xsZWN0aW9uIG1lYW5zIHRoZSB2YWx1ZSBpcyBub3QgdW5pcXVlXG5cdFx0cmV0dXJuIGNvdW50ZXIgPCAoISFleHRlcm5hbCA/IDEgOiAyKTtcblx0fSxcblx0bWVzc2FnZTogJ1BsZWFzZSBtYWtlIHN1cmUgdGhlIHZhbHVlIGlzIHVuaXF1ZS4nXG59O1xuXG5cbi8vbm93IHJlZ2lzdGVyIGFsbCBvZiB0aGVzZSFcbihmdW5jdGlvbiAoKSB7XG5cdGt2LnJlZ2lzdGVyRXh0ZW5kZXJzKCk7XG59KCkpO1xuOy8vIFRoZSBjb3JlIGJpbmRpbmcgaGFuZGxlclxuLy8gdGhpcyBhbGxvd3MgdXMgdG8gc2V0dXAgYW55IHZhbHVlIGJpbmRpbmcgdGhhdCBpbnRlcm5hbGx5IGFsd2F5c1xuLy8gcGVyZm9ybXMgdGhlIHNhbWUgZnVuY3Rpb25hbGl0eVxua28uYmluZGluZ0hhbmRsZXJzWyd2YWxpZGF0aW9uQ29yZSddID0gKGZ1bmN0aW9uICgpIHtcblxuXHRyZXR1cm4ge1xuXHRcdGluaXQ6IGZ1bmN0aW9uIChlbGVtZW50LCB2YWx1ZUFjY2Vzc29yLCBhbGxCaW5kaW5nc0FjY2Vzc29yLCB2aWV3TW9kZWwsIGJpbmRpbmdDb250ZXh0KSB7XG5cdFx0XHR2YXIgY29uZmlnID0ga3YudXRpbHMuZ2V0Q29uZmlnT3B0aW9ucyhlbGVtZW50KTtcblx0XHRcdHZhciBvYnNlcnZhYmxlID0gdmFsdWVBY2Nlc3NvcigpO1xuXG5cdFx0XHQvLyBwYXJzZSBodG1sNSBpbnB1dCB2YWxpZGF0aW9uIGF0dHJpYnV0ZXMsIG9wdGlvbmFsIGZlYXR1cmVcblx0XHRcdGlmIChjb25maWcucGFyc2VJbnB1dEF0dHJpYnV0ZXMpIHtcblx0XHRcdFx0a3YudXRpbHMuYXN5bmMoZnVuY3Rpb24gKCkgeyBrdi5wYXJzZUlucHV0VmFsaWRhdGlvbkF0dHJpYnV0ZXMoZWxlbWVudCwgdmFsdWVBY2Nlc3Nvcik7IH0pO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBpZiByZXF1ZXN0ZWQgaW5zZXJ0IG1lc3NhZ2UgZWxlbWVudCBhbmQgYXBwbHkgYmluZGluZ3Ncblx0XHRcdGlmIChjb25maWcuaW5zZXJ0TWVzc2FnZXMgJiYga3YudXRpbHMuaXNWYWxpZGF0YWJsZShvYnNlcnZhYmxlKSkge1xuXG5cdFx0XHRcdC8vIGluc2VydCB0aGUgPHNwYW4+PC9zcGFuPlxuXHRcdFx0XHR2YXIgdmFsaWRhdGlvbk1lc3NhZ2VFbGVtZW50ID0ga3YuaW5zZXJ0VmFsaWRhdGlvbk1lc3NhZ2UoZWxlbWVudCk7XG5cblx0XHRcdFx0Ly8gaWYgd2UncmUgdG9sZCB0byB1c2UgYSB0ZW1wbGF0ZSwgbWFrZSBzdXJlIHRoYXQgZ2V0cyByZW5kZXJlZFxuXHRcdFx0XHRpZiAoY29uZmlnLm1lc3NhZ2VUZW1wbGF0ZSkge1xuXHRcdFx0XHRcdGtvLnJlbmRlclRlbXBsYXRlKGNvbmZpZy5tZXNzYWdlVGVtcGxhdGUsIHsgZmllbGQ6IG9ic2VydmFibGUgfSwgbnVsbCwgdmFsaWRhdGlvbk1lc3NhZ2VFbGVtZW50LCAncmVwbGFjZU5vZGUnKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRrby5hcHBseUJpbmRpbmdzVG9Ob2RlKHZhbGlkYXRpb25NZXNzYWdlRWxlbWVudCwgeyB2YWxpZGF0aW9uTWVzc2FnZTogb2JzZXJ2YWJsZSB9KTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyB3cml0ZSB0aGUgaHRtbDUgYXR0cmlidXRlcyBpZiBpbmRpY2F0ZWQgYnkgdGhlIGNvbmZpZ1xuXHRcdFx0aWYgKGNvbmZpZy53cml0ZUlucHV0QXR0cmlidXRlcyAmJiBrdi51dGlscy5pc1ZhbGlkYXRhYmxlKG9ic2VydmFibGUpKSB7XG5cblx0XHRcdFx0a3Yud3JpdGVJbnB1dFZhbGlkYXRpb25BdHRyaWJ1dGVzKGVsZW1lbnQsIHZhbHVlQWNjZXNzb3IpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBpZiByZXF1ZXN0ZWQsIGFkZCBiaW5kaW5nIHRvIGRlY29yYXRlIGVsZW1lbnRcblx0XHRcdGlmIChjb25maWcuZGVjb3JhdGVJbnB1dEVsZW1lbnQgJiYga3YudXRpbHMuaXNWYWxpZGF0YWJsZShvYnNlcnZhYmxlKSkge1xuXHRcdFx0XHRrby5hcHBseUJpbmRpbmdzVG9Ob2RlKGVsZW1lbnQsIHsgdmFsaWRhdGlvbkVsZW1lbnQ6IG9ic2VydmFibGUgfSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xuXG59KCkpO1xuXG4vLyBvdmVycmlkZSBmb3IgS08ncyBkZWZhdWx0ICd2YWx1ZScsICdjaGVja2VkJywgJ3RleHRJbnB1dCcgYW5kIHNlbGVjdGVkT3B0aW9ucyBiaW5kaW5nc1xua3YubWFrZUJpbmRpbmdIYW5kbGVyVmFsaWRhdGFibGUoXCJ2YWx1ZVwiKTtcbmt2Lm1ha2VCaW5kaW5nSGFuZGxlclZhbGlkYXRhYmxlKFwiY2hlY2tlZFwiKTtcbmlmIChrby5iaW5kaW5nSGFuZGxlcnMudGV4dElucHV0KSB7XG5cdGt2Lm1ha2VCaW5kaW5nSGFuZGxlclZhbGlkYXRhYmxlKFwidGV4dElucHV0XCIpO1xufVxua3YubWFrZUJpbmRpbmdIYW5kbGVyVmFsaWRhdGFibGUoXCJzZWxlY3RlZE9wdGlvbnNcIik7XG5cblxua28uYmluZGluZ0hhbmRsZXJzWyd2YWxpZGF0aW9uTWVzc2FnZSddID0geyAvLyBpbmRpdmlkdWFsIGVycm9yIG1lc3NhZ2UsIGlmIG1vZGlmaWVkIG9yIHBvc3QgYmluZGluZ1xuXHR1cGRhdGU6IGZ1bmN0aW9uIChlbGVtZW50LCB2YWx1ZUFjY2Vzc29yKSB7XG5cdFx0dmFyIG9ic3YgPSB2YWx1ZUFjY2Vzc29yKCksXG5cdFx0XHRjb25maWcgPSBrdi51dGlscy5nZXRDb25maWdPcHRpb25zKGVsZW1lbnQpLFxuXHRcdFx0dmFsID0gdW53cmFwKG9ic3YpLFxuXHRcdFx0bXNnID0gbnVsbCxcblx0XHRcdGlzTW9kaWZpZWQgPSBmYWxzZSxcblx0XHRcdGlzVmFsaWQgPSBmYWxzZTtcblxuXHRcdGlmIChvYnN2ID09PSBudWxsIHx8IHR5cGVvZiBvYnN2ID09PSAndW5kZWZpbmVkJykge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgYmluZCB2YWxpZGF0aW9uTWVzc2FnZSB0byB1bmRlZmluZWQgdmFsdWUuIGRhdGEtYmluZCBleHByZXNzaW9uOiAnICtcblx0XHRcdFx0ZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2RhdGEtYmluZCcpKTtcblx0XHR9XG5cblx0XHRpc01vZGlmaWVkID0gb2Jzdi5pc01vZGlmaWVkICYmIG9ic3YuaXNNb2RpZmllZCgpO1xuXHRcdGlzVmFsaWQgPSBvYnN2LmlzVmFsaWQgJiYgb2Jzdi5pc1ZhbGlkKCk7XG5cblx0XHR2YXIgZXJyb3IgPSBudWxsO1xuXHRcdGlmICghY29uZmlnLm1lc3NhZ2VzT25Nb2RpZmllZCB8fCBpc01vZGlmaWVkKSB7XG5cdFx0XHRlcnJvciA9IGlzVmFsaWQgPyBudWxsIDogb2Jzdi5lcnJvcjtcblx0XHR9XG5cblx0XHR2YXIgaXNWaXNpYmxlID0gIWNvbmZpZy5tZXNzYWdlc09uTW9kaWZpZWQgfHwgaXNNb2RpZmllZCA/ICFpc1ZhbGlkIDogZmFsc2U7XG5cdFx0dmFyIGlzQ3VycmVudGx5VmlzaWJsZSA9IGVsZW1lbnQuc3R5bGUuZGlzcGxheSAhPT0gXCJub25lXCI7XG5cblx0XHRpZiAoY29uZmlnLmFsbG93SHRtbE1lc3NhZ2VzKSB7XG5cdFx0XHRrb1V0aWxzLnNldEh0bWwoZWxlbWVudCwgZXJyb3IpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRrby5iaW5kaW5nSGFuZGxlcnMudGV4dC51cGRhdGUoZWxlbWVudCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gZXJyb3I7IH0pO1xuXHRcdH1cblxuXHRcdGlmIChpc0N1cnJlbnRseVZpc2libGUgJiYgIWlzVmlzaWJsZSkge1xuXHRcdFx0ZWxlbWVudC5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuXHRcdH0gZWxzZSBpZiAoIWlzQ3VycmVudGx5VmlzaWJsZSAmJiBpc1Zpc2libGUpIHtcblx0XHRcdGVsZW1lbnQuc3R5bGUuZGlzcGxheSA9ICcnO1xuXHRcdH1cblx0fVxufTtcblxua28uYmluZGluZ0hhbmRsZXJzWyd2YWxpZGF0aW9uRWxlbWVudCddID0ge1xuXHR1cGRhdGU6IGZ1bmN0aW9uIChlbGVtZW50LCB2YWx1ZUFjY2Vzc29yLCBhbGxCaW5kaW5nc0FjY2Vzc29yKSB7XG5cdFx0dmFyIG9ic3YgPSB2YWx1ZUFjY2Vzc29yKCksXG5cdFx0XHRjb25maWcgPSBrdi51dGlscy5nZXRDb25maWdPcHRpb25zKGVsZW1lbnQpLFxuXHRcdFx0dmFsID0gdW53cmFwKG9ic3YpLFxuXHRcdFx0bXNnID0gbnVsbCxcblx0XHRcdGlzTW9kaWZpZWQgPSBmYWxzZSxcblx0XHRcdGlzVmFsaWQgPSBmYWxzZTtcblxuXHRcdGlmIChvYnN2ID09PSBudWxsIHx8IHR5cGVvZiBvYnN2ID09PSAndW5kZWZpbmVkJykge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgYmluZCB2YWxpZGF0aW9uRWxlbWVudCB0byB1bmRlZmluZWQgdmFsdWUuIGRhdGEtYmluZCBleHByZXNzaW9uOiAnICtcblx0XHRcdFx0ZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2RhdGEtYmluZCcpKTtcblx0XHR9XG5cblx0XHRpc01vZGlmaWVkID0gb2Jzdi5pc01vZGlmaWVkICYmIG9ic3YuaXNNb2RpZmllZCgpO1xuXHRcdGlzVmFsaWQgPSBvYnN2LmlzVmFsaWQgJiYgb2Jzdi5pc1ZhbGlkKCk7XG5cblx0XHQvLyBjcmVhdGUgYW4gZXZhbHVhdG9yIGZ1bmN0aW9uIHRoYXQgd2lsbCByZXR1cm4gc29tZXRoaW5nIGxpa2U6XG5cdFx0Ly8gY3NzOiB7IHZhbGlkYXRpb25FbGVtZW50OiB0cnVlIH1cblx0XHR2YXIgY3NzU2V0dGluZ3NBY2Nlc3NvciA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdHZhciBjc3MgPSB7fTtcblxuXHRcdFx0dmFyIHNob3VsZFNob3cgPSAoKCFjb25maWcuZGVjb3JhdGVFbGVtZW50T25Nb2RpZmllZCB8fCBpc01vZGlmaWVkKSA/ICFpc1ZhbGlkIDogZmFsc2UpO1xuXG5cdFx0XHQvLyBjc3M6IHsgdmFsaWRhdGlvbkVsZW1lbnQ6IGZhbHNlIH1cblx0XHRcdGNzc1tjb25maWcuZXJyb3JFbGVtZW50Q2xhc3NdID0gc2hvdWxkU2hvdztcblxuXHRcdFx0cmV0dXJuIGNzcztcblx0XHR9O1xuXG5cdFx0Ly9hZGQgb3IgcmVtb3ZlIGNsYXNzIG9uIHRoZSBlbGVtZW50O1xuXHRcdGtvLmJpbmRpbmdIYW5kbGVycy5jc3MudXBkYXRlKGVsZW1lbnQsIGNzc1NldHRpbmdzQWNjZXNzb3IsIGFsbEJpbmRpbmdzQWNjZXNzb3IpO1xuXHRcdGlmICghY29uZmlnLmVycm9yc0FzVGl0bGUpIHsgcmV0dXJuOyB9XG5cblx0XHRrby5iaW5kaW5nSGFuZGxlcnMuYXR0ci51cGRhdGUoZWxlbWVudCwgZnVuY3Rpb24gKCkge1xuXHRcdFx0dmFyXG5cdFx0XHRcdGhhc01vZGlmaWNhdGlvbiA9ICFjb25maWcuZXJyb3JzQXNUaXRsZU9uTW9kaWZpZWQgfHwgaXNNb2RpZmllZCxcblx0XHRcdFx0dGl0bGUgPSBrdi51dGlscy5nZXRPcmlnaW5hbEVsZW1lbnRUaXRsZShlbGVtZW50KTtcblxuXHRcdFx0aWYgKGhhc01vZGlmaWNhdGlvbiAmJiAhaXNWYWxpZCkge1xuXHRcdFx0XHRyZXR1cm4geyB0aXRsZTogb2Jzdi5lcnJvciwgJ2RhdGEtb3JpZy10aXRsZSc6IHRpdGxlIH07XG5cdFx0XHR9IGVsc2UgaWYgKCFoYXNNb2RpZmljYXRpb24gfHwgaXNWYWxpZCkge1xuXHRcdFx0XHRyZXR1cm4geyB0aXRsZTogdGl0bGUsICdkYXRhLW9yaWctdGl0bGUnOiBudWxsIH07XG5cdFx0XHR9XG5cdFx0fSk7XG5cdH1cbn07XG5cbi8vIFZhbGlkYXRpb25PcHRpb25zOlxuLy8gVGhpcyBiaW5kaW5nIGhhbmRsZXIgYWxsb3dzIHlvdSB0byBvdmVycmlkZSB0aGUgaW5pdGlhbCBjb25maWcgYnkgc2V0dGluZyBhbnkgb2YgdGhlIG9wdGlvbnMgZm9yIGEgc3BlY2lmaWMgZWxlbWVudCBvciBjb250ZXh0IG9mIGVsZW1lbnRzXG4vL1xuLy8gRXhhbXBsZTpcbi8vIDxkaXYgZGF0YS1iaW5kPVwidmFsaWRhdGlvbk9wdGlvbnM6IHsgaW5zZXJ0TWVzc2FnZXM6IHRydWUsIG1lc3NhZ2VUZW1wbGF0ZTogJ2N1c3RvbVRlbXBsYXRlJywgZXJyb3JNZXNzYWdlQ2xhc3M6ICdteVNwZWNpYWxDbGFzcyd9XCI+XG4vLyAgICAgIDxpbnB1dCB0eXBlPVwidGV4dFwiIGRhdGEtYmluZD1cInZhbHVlOiBzb21lVmFsdWVcIi8+XG4vLyAgICAgIDxpbnB1dCB0eXBlPVwidGV4dFwiIGRhdGEtYmluZD1cInZhbHVlOiBzb21lVmFsdWUyXCIvPlxuLy8gPC9kaXY+XG5rby5iaW5kaW5nSGFuZGxlcnNbJ3ZhbGlkYXRpb25PcHRpb25zJ10gPSAoZnVuY3Rpb24gKCkge1xuXHRyZXR1cm4ge1xuXHRcdGluaXQ6IGZ1bmN0aW9uIChlbGVtZW50LCB2YWx1ZUFjY2Vzc29yLCBhbGxCaW5kaW5nc0FjY2Vzc29yLCB2aWV3TW9kZWwsIGJpbmRpbmdDb250ZXh0KSB7XG5cdFx0XHR2YXIgb3B0aW9ucyA9IHVud3JhcCh2YWx1ZUFjY2Vzc29yKCkpO1xuXHRcdFx0aWYgKG9wdGlvbnMpIHtcblx0XHRcdFx0dmFyIG5ld0NvbmZpZyA9IGV4dGVuZCh7fSwga3YuY29uZmlndXJhdGlvbik7XG5cdFx0XHRcdGV4dGVuZChuZXdDb25maWcsIG9wdGlvbnMpO1xuXG5cdFx0XHRcdC8vc3RvcmUgdGhlIHZhbGlkYXRpb24gb3B0aW9ucyBvbiB0aGUgbm9kZSBzbyB3ZSBjYW4gcmV0cmlldmUgaXQgbGF0ZXJcblx0XHRcdFx0a3YudXRpbHMuc2V0RG9tRGF0YShlbGVtZW50LCBuZXdDb25maWcpO1xuXHRcdFx0fVxuXHRcdH1cblx0fTtcbn0oKSk7XG47Ly8gVmFsaWRhdGlvbiBFeHRlbmRlcjpcbi8vIFRoaXMgaXMgZm9yIGNyZWF0aW5nIGN1c3RvbSB2YWxpZGF0aW9uIGxvZ2ljIG9uIHRoZSBmbHlcbi8vIEV4YW1wbGU6XG4vLyB2YXIgdGVzdCA9IGtvLm9ic2VydmFibGUoJ3NvbWV0aGluZycpLmV4dGVuZHsoXG4vLyAgICAgIHZhbGlkYXRpb246IHtcbi8vICAgICAgICAgIHZhbGlkYXRvcjogZnVuY3Rpb24odmFsLCBzb21lT3RoZXJWYWwpe1xuLy8gICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuLy8gICAgICAgICAgfSxcbi8vICAgICAgICAgIG1lc3NhZ2U6IFwiU29tZXRoaW5nIG11c3QgYmUgcmVhbGx5IHdyb25nIScsXG4vLyAgICAgICAgICBwYXJhbXM6IHRydWVcbi8vICAgICAgfVxuLy8gICl9O1xua28uZXh0ZW5kZXJzWyd2YWxpZGF0aW9uJ10gPSBmdW5jdGlvbiAob2JzZXJ2YWJsZSwgcnVsZXMpIHsgLy8gYWxsb3cgc2luZ2xlIHJ1bGUgb3IgYXJyYXlcblx0Zm9yRWFjaChrdi51dGlscy5pc0FycmF5KHJ1bGVzKSA/IHJ1bGVzIDogW3J1bGVzXSwgZnVuY3Rpb24gKHJ1bGUpIHtcblx0XHQvLyB0aGUgJ3J1bGUnIGJlaW5nIHBhc3NlZCBpbiBoZXJlIGhhcyBubyBuYW1lIHRvIGlkZW50aWZ5IGEgY29yZSBSdWxlLFxuXHRcdC8vIHNvIHdlIGFkZCBpdCBhcyBhbiBhbm9ueW1vdXMgcnVsZVxuXHRcdC8vIElmIHRoZSBkZXZlbG9wZXIgaXMgd2FudGluZyB0byB1c2UgYSBjb3JlIFJ1bGUsIGJ1dCB1c2UgYSBkaWZmZXJlbnQgbWVzc2FnZSBzZWUgdGhlICdhZGRFeHRlbmRlcicgbG9naWMgZm9yIGV4YW1wbGVzXG5cdFx0a3YuYWRkQW5vbnltb3VzUnVsZShvYnNlcnZhYmxlLCBydWxlKTtcblx0fSk7XG5cdHJldHVybiBvYnNlcnZhYmxlO1xufTtcblxuLy9UaGlzIGlzIHRoZSBleHRlbmRlciB0aGF0IG1ha2VzIGEgS25vY2tvdXQgT2JzZXJ2YWJsZSBhbHNvICdWYWxpZGF0YWJsZSdcbi8vZXhhbXBsZXMgaW5jbHVkZTpcbi8vIDEuIHZhciB0ZXN0ID0ga28ub2JzZXJ2YWJsZSgnc29tZXRoaW5nJykuZXh0ZW5kKHt2YWxpZGF0YWJsZTogdHJ1ZX0pO1xuLy8gdGhpcyB3aWxsIGVuc3VyZSB0aGF0IHRoZSBPYnNlcnZhYmxlIG9iamVjdCBpcyBzZXR1cCBwcm9wZXJseSB0byByZXNwb25kIHRvIHJ1bGVzXG4vL1xuLy8gMi4gdGVzdC5leHRlbmQoe3ZhbGlkYXRhYmxlOiBmYWxzZX0pO1xuLy8gdGhpcyB3aWxsIHJlbW92ZSB0aGUgdmFsaWRhdGlvbiBwcm9wZXJ0aWVzIGZyb20gdGhlIE9ic2VydmFibGUgb2JqZWN0IHNob3VsZCB5b3UgbmVlZCB0byBkbyB0aGF0Llxua28uZXh0ZW5kZXJzWyd2YWxpZGF0YWJsZSddID0gZnVuY3Rpb24gKG9ic2VydmFibGUsIG9wdGlvbnMpIHtcblx0aWYgKCFrdi51dGlscy5pc09iamVjdChvcHRpb25zKSkge1xuXHRcdG9wdGlvbnMgPSB7IGVuYWJsZTogb3B0aW9ucyB9O1xuXHR9XG5cblx0aWYgKCEoJ2VuYWJsZScgaW4gb3B0aW9ucykpIHtcblx0XHRvcHRpb25zLmVuYWJsZSA9IHRydWU7XG5cdH1cblxuXHRpZiAob3B0aW9ucy5lbmFibGUgJiYgIWt2LnV0aWxzLmlzVmFsaWRhdGFibGUob2JzZXJ2YWJsZSkpIHtcblx0XHR2YXIgY29uZmlnID0ga3YuY29uZmlndXJhdGlvbi52YWxpZGF0ZSB8fCB7fTtcblx0XHR2YXIgdmFsaWRhdGlvbk9wdGlvbnMgPSB7XG5cdFx0XHR0aHJvdHRsZUV2YWx1YXRpb24gOiBvcHRpb25zLnRocm90dGxlIHx8IGNvbmZpZy50aHJvdHRsZVxuXHRcdH07XG5cblx0XHRvYnNlcnZhYmxlLmVycm9yID0ga28ub2JzZXJ2YWJsZShudWxsKTsgLy8gaG9sZHMgdGhlIGVycm9yIG1lc3NhZ2UsIHdlIG9ubHkgbmVlZCBvbmUgc2luY2Ugd2Ugc3RvcCBwcm9jZXNzaW5nIHZhbGlkYXRvcnMgd2hlbiBvbmUgaXMgaW52YWxpZFxuXG5cdFx0Ly8gb2JzZXJ2YWJsZS5ydWxlczpcblx0XHQvLyBPYnNlcnZhYmxlQXJyYXkgb2YgUnVsZSBDb250ZXh0cywgd2hlcmUgYSBSdWxlIENvbnRleHQgaXMgc2ltcGx5IHRoZSBuYW1lIG9mIGEgcnVsZSBhbmQgdGhlIHBhcmFtcyB0byBzdXBwbHkgdG8gaXRcblx0XHQvL1xuXHRcdC8vIFJ1bGUgQ29udGV4dCA9IHsgcnVsZTogJzxydWxlIG5hbWU+JywgcGFyYW1zOiAnPHBhc3NlZCBpbiBwYXJhbXM+JywgbWVzc2FnZTogJzxPdmVycmlkZSBvZiBkZWZhdWx0IE1lc3NhZ2U+JyB9XG5cdFx0b2JzZXJ2YWJsZS5ydWxlcyA9IGtvLm9ic2VydmFibGVBcnJheSgpOyAvL2hvbGRzIHRoZSBydWxlIENvbnRleHRzIHRvIHVzZSBhcyBwYXJ0IG9mIHZhbGlkYXRpb25cblxuXHRcdC8vaW4gY2FzZSBhc3luYyB2YWxpZGF0aW9uIGlzIG9jY3VycmluZ1xuXHRcdG9ic2VydmFibGUuaXNWYWxpZGF0aW5nID0ga28ub2JzZXJ2YWJsZShmYWxzZSk7XG5cblx0XHQvL3RoZSB0cnVlIGhvbGRlciBvZiB3aGV0aGVyIHRoZSBvYnNlcnZhYmxlIGlzIHZhbGlkIG9yIG5vdFxuXHRcdG9ic2VydmFibGUuX192YWxpZF9fID0ga28ub2JzZXJ2YWJsZSh0cnVlKTtcblxuXHRcdG9ic2VydmFibGUuaXNNb2RpZmllZCA9IGtvLm9ic2VydmFibGUoZmFsc2UpO1xuXG5cdFx0Ly8gYSBzZW1pLXByb3RlY3RlZCBvYnNlcnZhYmxlXG5cdFx0b2JzZXJ2YWJsZS5pc1ZhbGlkID0ga28uY29tcHV0ZWQob2JzZXJ2YWJsZS5fX3ZhbGlkX18pO1xuXG5cdFx0Ly9tYW51YWxseSBzZXQgZXJyb3Igc3RhdGVcblx0XHRvYnNlcnZhYmxlLnNldEVycm9yID0gZnVuY3Rpb24gKGVycm9yKSB7XG5cdFx0XHR2YXIgcHJldmlvdXNFcnJvciA9IG9ic2VydmFibGUuZXJyb3IucGVlaygpO1xuXHRcdFx0dmFyIHByZXZpb3VzSXNWYWxpZCA9IG9ic2VydmFibGUuX192YWxpZF9fLnBlZWsoKTtcblxuXHRcdFx0b2JzZXJ2YWJsZS5lcnJvcihlcnJvcik7XG5cdFx0XHRvYnNlcnZhYmxlLl9fdmFsaWRfXyhmYWxzZSk7XG5cblx0XHRcdGlmIChwcmV2aW91c0Vycm9yICE9PSBlcnJvciAmJiAhcHJldmlvdXNJc1ZhbGlkKSB7XG5cdFx0XHRcdC8vIGlmIHRoZSBvYnNlcnZhYmxlIHdhcyBub3QgdmFsaWQgYmVmb3JlIHRoZW4gaXNWYWxpZCB3aWxsIG5vdCBtdXRhdGUsXG5cdFx0XHRcdC8vIGhlbmNlIGNhdXNpbmcgYW55IGdyb3VwaW5nIHRvIG5vdCBkaXNwbGF5IHRoZSBsYXRlc3QgZXJyb3IuXG5cdFx0XHRcdG9ic2VydmFibGUuaXNWYWxpZC5ub3RpZnlTdWJzY3JpYmVycygpO1xuXHRcdFx0fVxuXHRcdH07XG5cblx0XHQvL21hbnVhbGx5IGNsZWFyIGVycm9yIHN0YXRlXG5cdFx0b2JzZXJ2YWJsZS5jbGVhckVycm9yID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0b2JzZXJ2YWJsZS5lcnJvcihudWxsKTtcblx0XHRcdG9ic2VydmFibGUuX192YWxpZF9fKHRydWUpO1xuXHRcdFx0cmV0dXJuIG9ic2VydmFibGU7XG5cdFx0fTtcblxuXHRcdC8vc3Vic2NyaWJlIHRvIGNoYW5nZXMgaW4gdGhlIG9ic2VydmFibGVcblx0XHR2YXIgaF9jaGFuZ2UgPSBvYnNlcnZhYmxlLnN1YnNjcmliZShmdW5jdGlvbiAoKSB7XG5cdFx0XHRvYnNlcnZhYmxlLmlzTW9kaWZpZWQodHJ1ZSk7XG5cdFx0fSk7XG5cblx0XHQvLyB3ZSB1c2UgYSBjb21wdXRlZCBoZXJlIHRvIGVuc3VyZSB0aGF0IGFueXRpbWUgYSBkZXBlbmRlbmN5IGNoYW5nZXMsIHRoZVxuXHRcdC8vIHZhbGlkYXRpb24gbG9naWMgZXZhbHVhdGVzXG5cdFx0dmFyIGhfb2JzVmFsaWRhdGlvblRyaWdnZXIgPSBrby5jb21wdXRlZChleHRlbmQoe1xuXHRcdFx0cmVhZDogZnVuY3Rpb24gKCkge1xuXHRcdFx0XHR2YXIgb2JzID0gb2JzZXJ2YWJsZSgpLFxuXHRcdFx0XHRcdHJ1bGVDb250ZXh0cyA9IG9ic2VydmFibGUucnVsZXMoKTtcblxuXHRcdFx0XHRrdi52YWxpZGF0ZU9ic2VydmFibGUob2JzZXJ2YWJsZSk7XG5cblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9XG5cdFx0fSwgdmFsaWRhdGlvbk9wdGlvbnMpKTtcblxuXHRcdGV4dGVuZChoX29ic1ZhbGlkYXRpb25UcmlnZ2VyLCB2YWxpZGF0aW9uT3B0aW9ucyk7XG5cblx0XHRvYnNlcnZhYmxlLl9kaXNwb3NlVmFsaWRhdGlvbiA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdC8vZmlyc3QgZGlzcG9zZSBvZiB0aGUgc3Vic2NyaXB0aW9uc1xuXHRcdFx0b2JzZXJ2YWJsZS5pc1ZhbGlkLmRpc3Bvc2UoKTtcblx0XHRcdG9ic2VydmFibGUucnVsZXMucmVtb3ZlQWxsKCk7XG5cdFx0XHRoX2NoYW5nZS5kaXNwb3NlKCk7XG5cdFx0XHRoX29ic1ZhbGlkYXRpb25UcmlnZ2VyLmRpc3Bvc2UoKTtcblxuXHRcdFx0ZGVsZXRlIG9ic2VydmFibGVbJ3J1bGVzJ107XG5cdFx0XHRkZWxldGUgb2JzZXJ2YWJsZVsnZXJyb3InXTtcblx0XHRcdGRlbGV0ZSBvYnNlcnZhYmxlWydpc1ZhbGlkJ107XG5cdFx0XHRkZWxldGUgb2JzZXJ2YWJsZVsnaXNWYWxpZGF0aW5nJ107XG5cdFx0XHRkZWxldGUgb2JzZXJ2YWJsZVsnX192YWxpZF9fJ107XG5cdFx0XHRkZWxldGUgb2JzZXJ2YWJsZVsnaXNNb2RpZmllZCddO1xuICAgICAgICAgICAgZGVsZXRlIG9ic2VydmFibGVbJ3NldEVycm9yJ107XG4gICAgICAgICAgICBkZWxldGUgb2JzZXJ2YWJsZVsnY2xlYXJFcnJvciddO1xuICAgICAgICAgICAgZGVsZXRlIG9ic2VydmFibGVbJ19kaXNwb3NlVmFsaWRhdGlvbiddO1xuXHRcdH07XG5cdH0gZWxzZSBpZiAob3B0aW9ucy5lbmFibGUgPT09IGZhbHNlICYmIG9ic2VydmFibGUuX2Rpc3Bvc2VWYWxpZGF0aW9uKSB7XG5cdFx0b2JzZXJ2YWJsZS5fZGlzcG9zZVZhbGlkYXRpb24oKTtcblx0fVxuXHRyZXR1cm4gb2JzZXJ2YWJsZTtcbn07XG5cbmZ1bmN0aW9uIHZhbGlkYXRlU3luYyhvYnNlcnZhYmxlLCBydWxlLCBjdHgpIHtcblx0Ly9FeGVjdXRlIHRoZSB2YWxpZGF0b3IgYW5kIHNlZSBpZiBpdHMgdmFsaWRcblx0aWYgKCFydWxlLnZhbGlkYXRvcihvYnNlcnZhYmxlKCksIChjdHgucGFyYW1zID09PSB1bmRlZmluZWQgPyB0cnVlIDogdW53cmFwKGN0eC5wYXJhbXMpKSkpIHsgLy8gZGVmYXVsdCBwYXJhbSBpcyB0cnVlLCBlZy4gcmVxdWlyZWQgPSB0cnVlXG5cblx0XHQvL25vdCB2YWxpZCwgc28gZm9ybWF0IHRoZSBlcnJvciBtZXNzYWdlIGFuZCBzdGljayBpdCBpbiB0aGUgJ2Vycm9yJyB2YXJpYWJsZVxuXHRcdG9ic2VydmFibGUuc2V0RXJyb3Ioa3YuZm9ybWF0TWVzc2FnZShcblx0XHRcdFx0XHRjdHgubWVzc2FnZSB8fCBydWxlLm1lc3NhZ2UsXG5cdFx0XHRcdFx0dW53cmFwKGN0eC5wYXJhbXMpLFxuXHRcdFx0XHRcdG9ic2VydmFibGUpKTtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH0gZWxzZSB7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVBc3luYyhvYnNlcnZhYmxlLCBydWxlLCBjdHgpIHtcblx0b2JzZXJ2YWJsZS5pc1ZhbGlkYXRpbmcodHJ1ZSk7XG5cblx0dmFyIGNhbGxCYWNrID0gZnVuY3Rpb24gKHZhbE9iaikge1xuXHRcdHZhciBpc1ZhbGlkID0gZmFsc2UsXG5cdFx0XHRtc2cgPSAnJztcblxuXHRcdGlmICghb2JzZXJ2YWJsZS5fX3ZhbGlkX18oKSkge1xuXG5cdFx0XHQvLyBzaW5jZSB3ZSdyZSByZXR1cm5pbmcgZWFybHksIG1ha2Ugc3VyZSB3ZSB0dXJuIHRoaXMgb2ZmXG5cdFx0XHRvYnNlcnZhYmxlLmlzVmFsaWRhdGluZyhmYWxzZSk7XG5cblx0XHRcdHJldHVybjsgLy9pZiBpdHMgYWxyZWFkeSBOT1QgdmFsaWQsIGRvbid0IGFkZCB0byB0aGF0XG5cdFx0fVxuXG5cdFx0Ly93ZSB3ZXJlIGhhbmRlZCBiYWNrIGEgY29tcGxleCBvYmplY3Rcblx0XHRpZiAodmFsT2JqWydtZXNzYWdlJ10pIHtcblx0XHRcdGlzVmFsaWQgPSB2YWxPYmouaXNWYWxpZDtcblx0XHRcdG1zZyA9IHZhbE9iai5tZXNzYWdlO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRpc1ZhbGlkID0gdmFsT2JqO1xuXHRcdH1cblxuXHRcdGlmICghaXNWYWxpZCkge1xuXHRcdFx0Ly9ub3QgdmFsaWQsIHNvIGZvcm1hdCB0aGUgZXJyb3IgbWVzc2FnZSBhbmQgc3RpY2sgaXQgaW4gdGhlICdlcnJvcicgdmFyaWFibGVcblx0XHRcdG9ic2VydmFibGUuZXJyb3Ioa3YuZm9ybWF0TWVzc2FnZShcblx0XHRcdFx0bXNnIHx8IGN0eC5tZXNzYWdlIHx8IHJ1bGUubWVzc2FnZSxcblx0XHRcdFx0dW53cmFwKGN0eC5wYXJhbXMpLFxuXHRcdFx0XHRvYnNlcnZhYmxlKSk7XG5cdFx0XHRvYnNlcnZhYmxlLl9fdmFsaWRfXyhpc1ZhbGlkKTtcblx0XHR9XG5cblx0XHQvLyB0ZWxsIGl0IHRoYXQgd2UncmUgZG9uZVxuXHRcdG9ic2VydmFibGUuaXNWYWxpZGF0aW5nKGZhbHNlKTtcblx0fTtcblxuXHRrdi51dGlscy5hc3luYyhmdW5jdGlvbigpIHtcblx0ICAgIC8vZmlyZSB0aGUgdmFsaWRhdG9yIGFuZCBoYW5kIGl0IHRoZSBjYWxsYmFja1xuICAgICAgICBydWxlLnZhbGlkYXRvcihvYnNlcnZhYmxlKCksIGN0eC5wYXJhbXMgPT09IHVuZGVmaW5lZCA/IHRydWUgOiB1bndyYXAoY3R4LnBhcmFtcyksIGNhbGxCYWNrKTtcblx0fSk7XG59XG5cbmt2LnZhbGlkYXRlT2JzZXJ2YWJsZSA9IGZ1bmN0aW9uIChvYnNlcnZhYmxlKSB7XG5cdHZhciBpID0gMCxcblx0XHRydWxlLCAvLyB0aGUgcnVsZSB2YWxpZGF0b3IgdG8gZXhlY3V0ZVxuXHRcdGN0eCwgLy8gdGhlIGN1cnJlbnQgUnVsZSBDb250ZXh0IGZvciB0aGUgbG9vcFxuXHRcdHJ1bGVDb250ZXh0cyA9IG9ic2VydmFibGUucnVsZXMoKSwgLy9jYWNoZSBmb3IgaXRlcmF0b3Jcblx0XHRsZW4gPSBydWxlQ29udGV4dHMubGVuZ3RoOyAvL2NhY2hlIGZvciBpdGVyYXRvclxuXG5cdGZvciAoOyBpIDwgbGVuOyBpKyspIHtcblxuXHRcdC8vZ2V0IHRoZSBSdWxlIENvbnRleHQgaW5mbyB0byBnaXZlIHRvIHRoZSBjb3JlIFJ1bGVcblx0XHRjdHggPSBydWxlQ29udGV4dHNbaV07XG5cblx0XHQvLyBjaGVja3MgYW4gJ29ubHlJZicgY29uZGl0aW9uXG5cdFx0aWYgKGN0eC5jb25kaXRpb24gJiYgIWN0eC5jb25kaXRpb24oKSkge1xuXHRcdFx0Y29udGludWU7XG5cdFx0fVxuXG5cdFx0Ly9nZXQgdGhlIGNvcmUgUnVsZSB0byB1c2UgZm9yIHZhbGlkYXRpb25cblx0XHRydWxlID0gY3R4LnJ1bGUgPyBrdi5ydWxlc1tjdHgucnVsZV0gOiBjdHg7XG5cblx0XHRpZiAocnVsZVsnYXN5bmMnXSB8fCBjdHhbJ2FzeW5jJ10pIHtcblx0XHRcdC8vcnVuIGFzeW5jIHZhbGlkYXRpb25cblx0XHRcdHZhbGlkYXRlQXN5bmMob2JzZXJ2YWJsZSwgcnVsZSwgY3R4KTtcblxuXHRcdH0gZWxzZSB7XG5cdFx0XHQvL3J1biBub3JtYWwgc3luYyB2YWxpZGF0aW9uXG5cdFx0XHRpZiAoIXZhbGlkYXRlU3luYyhvYnNlcnZhYmxlLCBydWxlLCBjdHgpKSB7XG5cdFx0XHRcdHJldHVybiBmYWxzZTsgLy9icmVhayBvdXQgb2YgdGhlIGxvb3Bcblx0XHRcdH1cblx0XHR9XG5cdH1cblx0Ly9maW5hbGx5IGlmIHdlIGdvdCB0aGlzIGZhciwgbWFrZSB0aGUgb2JzZXJ2YWJsZSB2YWxpZCBhZ2FpbiFcblx0b2JzZXJ2YWJsZS5jbGVhckVycm9yKCk7XG5cdHJldHVybiB0cnVlO1xufTtcbjtcbnZhciBfbG9jYWxlcyA9IHt9O1xudmFyIF9jdXJyZW50TG9jYWxlO1xuXG5rdi5kZWZpbmVMb2NhbGUgPSBmdW5jdGlvbihuYW1lLCB2YWx1ZXMpIHtcblx0aWYgKG5hbWUgJiYgdmFsdWVzKSB7XG5cdFx0X2xvY2FsZXNbbmFtZS50b0xvd2VyQ2FzZSgpXSA9IHZhbHVlcztcblx0XHRyZXR1cm4gdmFsdWVzO1xuXHR9XG5cdHJldHVybiBudWxsO1xufTtcblxua3YubG9jYWxlID0gZnVuY3Rpb24obmFtZSkge1xuXHRpZiAobmFtZSkge1xuXHRcdG5hbWUgPSBuYW1lLnRvTG93ZXJDYXNlKCk7XG5cblx0XHRpZiAoX2xvY2FsZXMuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcblx0XHRcdGt2LmxvY2FsaXplKF9sb2NhbGVzW25hbWVdKTtcblx0XHRcdF9jdXJyZW50TG9jYWxlID0gbmFtZTtcblx0XHR9XG5cdFx0ZWxzZSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ0xvY2FsaXphdGlvbiAnICsgbmFtZSArICcgaGFzIG5vdCBiZWVuIGxvYWRlZC4nKTtcblx0XHR9XG5cdH1cblx0cmV0dXJuIF9jdXJyZW50TG9jYWxlO1xufTtcblxuLy9xdWljayBmdW5jdGlvbiB0byBvdmVycmlkZSBydWxlIG1lc3NhZ2VzXG5rdi5sb2NhbGl6ZSA9IGZ1bmN0aW9uIChtc2dUcmFuc2xhdGlvbnMpIHtcblx0dmFyIHJ1bGVzID0ga3YucnVsZXM7XG5cblx0Ly9sb29wIHRoZSBwcm9wZXJ0aWVzIGluIHRoZSBvYmplY3QgYW5kIGFzc2lnbiB0aGUgbXNnIHRvIHRoZSBydWxlXG5cdGZvciAodmFyIHJ1bGVOYW1lIGluIG1zZ1RyYW5zbGF0aW9ucykge1xuXHRcdGlmIChydWxlcy5oYXNPd25Qcm9wZXJ0eShydWxlTmFtZSkpIHtcblx0XHRcdHJ1bGVzW3J1bGVOYW1lXS5tZXNzYWdlID0gbXNnVHJhbnNsYXRpb25zW3J1bGVOYW1lXTtcblx0XHR9XG5cdH1cbn07XG5cbi8vIFBvcHVsYXRlIGRlZmF1bHQgbG9jYWxlICh0aGlzIHdpbGwgbWFrZSBlbi1VUy5qcyBzb21ld2hhdCByZWR1bmRhbnQpXG4oZnVuY3Rpb24oKSB7XG5cdHZhciBsb2NhbGVEYXRhID0ge307XG5cdHZhciBydWxlcyA9IGt2LnJ1bGVzO1xuXG5cdGZvciAodmFyIHJ1bGVOYW1lIGluIHJ1bGVzKSB7XG5cdFx0aWYgKHJ1bGVzLmhhc093blByb3BlcnR5KHJ1bGVOYW1lKSkge1xuXHRcdFx0bG9jYWxlRGF0YVtydWxlTmFtZV0gPSBydWxlc1tydWxlTmFtZV0ubWVzc2FnZTtcblx0XHR9XG5cdH1cblx0a3YuZGVmaW5lTG9jYWxlKCdlbi11cycsIGxvY2FsZURhdGEpO1xufSkoKTtcblxuLy8gTm8gbmVlZCB0byBpbnZva2UgbG9jYWxlIGJlY2F1c2UgdGhlIG1lc3NhZ2VzIGFyZSBhbHJlYWR5IGRlZmluZWQgYWxvbmcgd2l0aCB0aGUgcnVsZXMgZm9yIGVuLVVTXG5fY3VycmVudExvY2FsZSA9ICdlbi11cyc7XG47LyoqXG4gKiBQb3NzaWJsZSBpbnZvY2F0aW9uczpcbiAqIFx0XHRhcHBseUJpbmRpbmdzV2l0aFZhbGlkYXRpb24odmlld01vZGVsKVxuICogXHRcdGFwcGx5QmluZGluZ3NXaXRoVmFsaWRhdGlvbih2aWV3TW9kZWwsIG9wdGlvbnMpXG4gKiBcdFx0YXBwbHlCaW5kaW5nc1dpdGhWYWxpZGF0aW9uKHZpZXdNb2RlbCwgcm9vdE5vZGUpXG4gKlx0XHRhcHBseUJpbmRpbmdzV2l0aFZhbGlkYXRpb24odmlld01vZGVsLCByb290Tm9kZSwgb3B0aW9ucylcbiAqL1xua28uYXBwbHlCaW5kaW5nc1dpdGhWYWxpZGF0aW9uID0gZnVuY3Rpb24gKHZpZXdNb2RlbCwgcm9vdE5vZGUsIG9wdGlvbnMpIHtcblx0dmFyIG5vZGUgPSBkb2N1bWVudC5ib2R5LFxuXHRcdGNvbmZpZztcblxuXHRpZiAocm9vdE5vZGUgJiYgcm9vdE5vZGUubm9kZVR5cGUpIHtcblx0XHRub2RlID0gcm9vdE5vZGU7XG5cdFx0Y29uZmlnID0gb3B0aW9ucztcblx0fVxuXHRlbHNlIHtcblx0XHRjb25maWcgPSByb290Tm9kZTtcblx0fVxuXG5cdGt2LmluaXQoKTtcblxuXHRpZiAoY29uZmlnKSB7XG5cdFx0Y29uZmlnID0gZXh0ZW5kKGV4dGVuZCh7fSwga3YuY29uZmlndXJhdGlvbiksIGNvbmZpZyk7XG5cdFx0a3YudXRpbHMuc2V0RG9tRGF0YShub2RlLCBjb25maWcpO1xuXHR9XG5cblx0a28uYXBwbHlCaW5kaW5ncyh2aWV3TW9kZWwsIG5vZGUpO1xufTtcblxuLy9vdmVycmlkZSB0aGUgb3JpZ2luYWwgYXBwbHlCaW5kaW5ncyBzbyB0aGF0IHdlIGNhbiBlbnN1cmUgYWxsIG5ldyBydWxlcyBhbmQgd2hhdCBub3QgYXJlIGNvcnJlY3RseSByZWdpc3RlcmVkXG52YXIgb3JpZ0FwcGx5QmluZGluZ3MgPSBrby5hcHBseUJpbmRpbmdzO1xua28uYXBwbHlCaW5kaW5ncyA9IGZ1bmN0aW9uICh2aWV3TW9kZWwsIHJvb3ROb2RlKSB7XG5cblx0a3YuaW5pdCgpO1xuXG5cdG9yaWdBcHBseUJpbmRpbmdzKHZpZXdNb2RlbCwgcm9vdE5vZGUpO1xufTtcblxua28udmFsaWRhdGVkT2JzZXJ2YWJsZSA9IGZ1bmN0aW9uIChpbml0aWFsVmFsdWUsIG9wdGlvbnMpIHtcblx0aWYgKCFvcHRpb25zICYmICFrdi51dGlscy5pc09iamVjdChpbml0aWFsVmFsdWUpKSB7XG5cdFx0cmV0dXJuIGtvLm9ic2VydmFibGUoaW5pdGlhbFZhbHVlKS5leHRlbmQoeyB2YWxpZGF0YWJsZTogdHJ1ZSB9KTtcblx0fVxuXG5cdHZhciBvYnN2ID0ga28ub2JzZXJ2YWJsZShpbml0aWFsVmFsdWUpO1xuXHRvYnN2LmVycm9ycyA9IGt2Lmdyb3VwKGt2LnV0aWxzLmlzT2JqZWN0KGluaXRpYWxWYWx1ZSkgPyBpbml0aWFsVmFsdWUgOiB7fSwgb3B0aW9ucyk7XG5cdG9ic3YuaXNWYWxpZCA9IGtvLm9ic2VydmFibGUob2Jzdi5lcnJvcnMoKS5sZW5ndGggPT09IDApO1xuXG5cdGlmIChrby5pc09ic2VydmFibGUob2Jzdi5lcnJvcnMpKSB7XG5cdFx0b2Jzdi5lcnJvcnMuc3Vic2NyaWJlKGZ1bmN0aW9uKGVycm9ycykge1xuXHRcdFx0b2Jzdi5pc1ZhbGlkKGVycm9ycy5sZW5ndGggPT09IDApO1xuXHRcdH0pO1xuXHR9XG5cdGVsc2Uge1xuXHRcdGtvLmNvbXB1dGVkKG9ic3YuZXJyb3JzKS5zdWJzY3JpYmUoZnVuY3Rpb24gKGVycm9ycykge1xuXHRcdFx0b2Jzdi5pc1ZhbGlkKGVycm9ycy5sZW5ndGggPT09IDApO1xuXHRcdH0pO1xuXHR9XG5cblx0b2Jzdi5zdWJzY3JpYmUoZnVuY3Rpb24obmV3VmFsdWUpIHtcblx0XHRpZiAoIWt2LnV0aWxzLmlzT2JqZWN0KG5ld1ZhbHVlKSkge1xuXHRcdFx0Lypcblx0XHRcdCAqIFRoZSB2YWxpZGF0aW9uIGdyb3VwIHdvcmtzIG9uIG9iamVjdHMuXG5cdFx0XHQgKiBTaW5jZSB0aGUgbmV3IHZhbHVlIGlzIGEgcHJpbWl0aXZlIChzY2FsYXIsIG51bGwgb3IgdW5kZWZpbmVkKSB3ZSBuZWVkXG5cdFx0XHQgKiB0byBjcmVhdGUgYW4gZW1wdHkgb2JqZWN0IHRvIHBhc3MgYWxvbmcuXG5cdFx0XHQgKi9cblx0XHRcdG5ld1ZhbHVlID0ge307XG5cdFx0fVxuXHRcdC8vIEZvcmNlIHRoZSBncm91cCB0byByZWZyZXNoXG5cdFx0b2Jzdi5lcnJvcnMuX3VwZGF0ZVN0YXRlKG5ld1ZhbHVlKTtcblx0XHRvYnN2LmlzVmFsaWQob2Jzdi5lcnJvcnMoKS5sZW5ndGggPT09IDApO1xuXHR9KTtcblxuXHRyZXR1cm4gb2Jzdjtcbn07XG47fSkpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9rbm9ja291dC52YWxpZGF0aW9uL2Rpc3Qva25vY2tvdXQudmFsaWRhdGlvbi5qc1xuLy8gbW9kdWxlIGlkID0gNjFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8xMDM0MzkxMy9ob3ctdG8tY3JlYXRlLWEtd2ViLXdvcmtlci1mcm9tLWEtc3RyaW5nXHJcblxyXG52YXIgVVJMID0gd2luZG93LlVSTCB8fCB3aW5kb3cud2Via2l0VVJMO1xyXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGNvbnRlbnQsIHVybCkge1xyXG5cdHRyeSB7XHJcblx0XHR0cnkge1xyXG5cdFx0XHR2YXIgYmxvYjtcclxuXHRcdFx0dHJ5IHsgLy8gQmxvYkJ1aWxkZXIgPSBEZXByZWNhdGVkLCBidXQgd2lkZWx5IGltcGxlbWVudGVkXHJcblx0XHRcdFx0dmFyIEJsb2JCdWlsZGVyID0gd2luZG93LkJsb2JCdWlsZGVyIHx8IHdpbmRvdy5XZWJLaXRCbG9iQnVpbGRlciB8fCB3aW5kb3cuTW96QmxvYkJ1aWxkZXIgfHwgd2luZG93Lk1TQmxvYkJ1aWxkZXI7XHJcblx0XHRcdFx0YmxvYiA9IG5ldyBCbG9iQnVpbGRlcigpO1xyXG5cdFx0XHRcdGJsb2IuYXBwZW5kKGNvbnRlbnQpO1xyXG5cdFx0XHRcdGJsb2IgPSBibG9iLmdldEJsb2IoKTtcclxuXHRcdFx0fSBjYXRjaChlKSB7IC8vIFRoZSBwcm9wb3NlZCBBUElcclxuXHRcdFx0XHRibG9iID0gbmV3IEJsb2IoW2NvbnRlbnRdKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRyZXR1cm4gbmV3IFdvcmtlcihVUkwuY3JlYXRlT2JqZWN0VVJMKGJsb2IpKTtcclxuXHRcdH0gY2F0Y2goZSkge1xyXG5cdFx0XHRyZXR1cm4gbmV3IFdvcmtlcignZGF0YTphcHBsaWNhdGlvbi9qYXZhc2NyaXB0LCcgKyBlbmNvZGVVUklDb21wb25lbnQoY29udGVudCkpO1xyXG5cdFx0fVxyXG5cdH0gY2F0Y2goZSkge1xyXG5cdFx0cmV0dXJuIG5ldyBXb3JrZXIodXJsKTtcclxuXHR9XHJcbn1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vd29ya2VyLWxvYWRlci9jcmVhdGVJbmxpbmVXb3JrZXIuanNcbi8vIG1vZHVsZSBpZCA9IDYyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=