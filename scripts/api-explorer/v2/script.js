var base =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(1);


/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function($) {'use strict';
	
	var _keys = __webpack_require__(73);
	
	var _keys2 = _interopRequireDefault(_keys);
	
	var _slicedToArray2 = __webpack_require__(77);
	
	var _slicedToArray3 = _interopRequireDefault(_slicedToArray2);
	
	var _classCallCheck2 = __webpack_require__(86);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _createClass2 = __webpack_require__(87);
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	var _typeof2 = __webpack_require__(4);
	
	var _typeof3 = _interopRequireDefault(_typeof2);
	
	var _modules = __webpack_require__(91);
	
	var modules = _interopRequireWildcard(_modules);
	
	var _customBindings = __webpack_require__(122);
	
	var customBindings = _interopRequireWildcard(_customBindings);
	
	var _components = __webpack_require__(129);
	
	var components = _interopRequireWildcard(_components);
	
	var _services = __webpack_require__(146);
	
	var services = _interopRequireWildcard(_services);
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * Gets deep prop
	 * @returns {*[]}
	 */
	/**
	 * Main file for Api Explrer v2.0
	 * For development please use Webpack to bundle all modules
	 * It can be made using npm scripts cmd - 'webpack'
	 */
	
	// custom bindings
	Object.getProp = function (o, s) {
		if (((typeof o === 'undefined' ? 'undefined' : (0, _typeof3.default)(o)) !== 'object' || o == null) && !s) {
			return;
		}
		s = s.replace(/\[(\w+)\]/g, '.$1'); // convert indexes to properties
		s = s.replace(/^\./, ''); // strip a leading dot
		var a = s.split('.');
		for (var i = 0, n = a.length; i < n; ++i) {
			var k = a[i];
			if (o && k in o) {
				o = o[k];
			} else {
				return;
			}
		}
		return o;
	};
	
	var AppViewModel = function () {
		function AppViewModel(_ref) {
			var _this = this;
	
			var _ref$base = _ref.base,
			    base = _ref$base === undefined ? {} : _ref$base,
			    apiKey = _ref.apiKey,
			    config = _ref.config,
			    rest = _ref.rest;
			(0, _classCallCheck3.default)(this, AppViewModel);
	
			this.setParams = function (_ref2) {
				var category = _ref2.category,
				    _ref2$method = _ref2.method,
				    method = _ref2$method === undefined ? 'ALL' : _ref2$method,
				    methodId = _ref2.methodId,
				    params = _ref2.params;
	
				_this.selectedCategory(category);
				_this.selectedMethodType(method);
				_this.selectedMethod(methodId);
				_this.selectedParams.notifySubscribers(params, 'paramsSet');
			};
	
			this.base = base;
			this.apiKey = apiKey;
			this.config = config;
			this.restService = rest;
	
			var parsedUrl = this.parseUrl();
			// observables
			this.selectedCategory = ko.observable(parsedUrl.apiCategory || '').syncWith('SELECTED_CATEGORY');
			this.selectedMethodType = ko.observable('ALL').syncWith('SELECTED_METHOD_TYPE');
			this.selectedMethod = ko.observable(parsedUrl.methodId || '').syncWith('SELECTED_METHOD');
			this.selectedParams = ko.observableArray([]).syncWith('SELECTED_PARAMS');
			this.selectedMethodData = ko.observable(this.getMethodData({}));
	
			this.initValidation();
	
			// computed
			this.sendButtonText = ko.pureComputed(function () {
				return ko.unwrap(_this.selectedMethodData).method;
			});
	
			this.sharePath = ko.pureComputed(function () {
				return _this.formDeepLinkingUrl();
			});
	
			this.selectedMethod.subscribe(function (val) {
				_this.validationModel($.extend({}, ko.unwrap(_this.apiKeyValidationModel)));
				_this.selectedMethodData(_this.getMethodData({ methodId: val }));
			});
		}
	
		/**
	  * Validation watchers and logic
	  */
	
	
		(0, _createClass3.default)(AppViewModel, [{
			key: 'initValidation',
			value: function initValidation() {
				var _this2 = this;
	
				this.apiKeyValidationModel = ko.observable({});
				this.validationModel = ko.observable({});
	
				this.sendBtnValidationText = ko.observable('');
				this.formIsValid = ko.observable(true);
				ko.computed(function () {
					var validationModel = ko.validatedObservable($.extend({}, ko.unwrap(_this2.validationModel), ko.unwrap(_this2.apiKeyValidationModel)));
					var validationFlag = validationModel.isValid() || !$('.custom-input__field.not-valid').length;
					_this2.sendBtnValidationText(validationFlag ? '' : _this2.validationText);
					_this2.formIsValid(validationFlag);
				});
			}
	
			/**
	   * Send request method
	   */
	
		}, {
			key: 'onClickSendBtn',
			value: function onClickSendBtn() {
				var model = ko.validatedObservable($.extend({}, ko.unwrap(this.validationModel), ko.unwrap(this.apiKeyValidationModel)));
	
				if (model.isValid()) {
					this.restService.sendRequest();
				} else {
					this.formIsValid(false);
					this.sendBtnValidationText(this.validationText);
					model.errors.showAllMessages();
				}
			}
		}, {
			key: 'formDeepLinkingUrl',
			value: function formDeepLinkingUrl() {
				var location = window.location;
				var category = ko.unwrap(this.selectedCategory);
				var method = ko.unwrap(this.selectedMethod);
				var params = ko.unwrap(this.selectedParams);
	
				var querys = ['apiCategory=' + encodeURI(category), 'methodId=' + encodeURI(method)];
	
				params.map(function (param) {
					var value = ko.unwrap(param.value);
					var defaultValue = ko.unwrap(param.default);
					querys.push(param.name + '=' + (value !== '' ? value : defaultValue)); //todo: remove default from here when set up it in source like value by default
					return param;
				});
	
				return '' + location.origin + location.pathname.replace(/\/$/gmi, '') + '?' + querys.join('&');
			}
	
			//rest service
	
		}, {
			key: 'getMethodData',
			value: function getMethodData(_ref3) {
				var apiCategory = _ref3.apiCategory,
				    type = _ref3.type,
				    methodId = _ref3.methodId;
	
				var category = ko.unwrap(apiCategory || this.selectedCategory);
				var methodType = ko.unwrap(type || this.selectedMethodType || 'ALL');
				var method = ko.unwrap(methodId || this.selectedMethod);
				return this.base[category] && this.base[category][methodType] && this.base[category][methodType][method] || {};
			}
	
			//**********
	
		}, {
			key: 'parseUrl',
			value: function parseUrl() {
				var _this3 = this;
	
				var location = window.location.search;
	
				if (location) {
					var querys;
					var obj;
	
					var _ret = function () {
						querys = location.replace(/^\?/g, '').split('&');
						obj = {
							apiCategory: '',
							methodId: '',
							parameters: []
						};
	
	
						var globalQueryObj = window.location.query = {};
						querys.map(function (query) {
							var _decodeURI$split = decodeURI(query).split('='),
							    _decodeURI$split2 = (0, _slicedToArray3.default)(_decodeURI$split, 2),
							    key = _decodeURI$split2[0],
							    val = _decodeURI$split2[1];
	
							if ((0, _keys2.default)(obj).indexOf(key) !== -1) {
								try {
									obj[key] = globalQueryObj[key] = JSON.parse(val);
								} catch (exception_var) {
									obj[key] = globalQueryObj[key] = val;
								}
							} else {
								try {
									globalQueryObj[key] = JSON.parse(val);
								} catch (exception_var) {
									globalQueryObj[key] = val;
								}
	
								obj.parameters.push({
									name: key,
									value: globalQueryObj[key]
								});
							}
						});
	
						var methodData = _this3.getMethodData(obj);
						var parameters = methodData.parameters;
	
						obj.parameters.map(function (obj) {
							parameters[obj.name].value = obj.value;
							return obj;
						});
						obj.parameters = parameters;
						return {
							v: obj
						};
					}();
	
					if ((typeof _ret === 'undefined' ? 'undefined' : (0, _typeof3.default)(_ret)) === "object") return _ret.v;
				}
				return {};
			}
			//**********
	
		}, {
			key: 'validationText',
			get: function get() {
				return 'Please solve form validation issues';
			}
		}]);
		return AppViewModel;
	}();
	
	/**
	 * Activates knockout.js
	 */
	
	
	ko.applyBindings(new AppViewModel(services));
	
	/**
	 * exports global variable
	 */
	module.exports = services.base;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ },
/* 2 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/* WEBPACK VAR INJECTION */(function(module) {"use strict";
	
	var _typeof2 = __webpack_require__(4);
	
	var _typeof3 = _interopRequireDefault(_typeof2);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/*! jQuery v1.11.3 | (c) 2005, 2015 jQuery Foundation, Inc. | jquery.org/license */
	!function (a, b) {
	  "object" == ( false ? "undefined" : (0, _typeof3.default)(module)) && "object" == (0, _typeof3.default)(module.exports) ? module.exports = a.document ? b(a, !0) : function (a) {
	    if (!a.document) throw new Error("jQuery requires a window with a document");return b(a);
	  } : b(a);
	}("undefined" != typeof window ? window : undefined, function (a, b) {
	  var c = [],
	      d = c.slice,
	      e = c.concat,
	      f = c.push,
	      g = c.indexOf,
	      h = {},
	      i = h.toString,
	      j = h.hasOwnProperty,
	      k = {},
	      l = "1.11.3",
	      m = function m(a, b) {
	    return new m.fn.init(a, b);
	  },
	      n = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,
	      o = /^-ms-/,
	      p = /-([\da-z])/gi,
	      q = function q(a, b) {
	    return b.toUpperCase();
	  };m.fn = m.prototype = { jquery: l, constructor: m, selector: "", length: 0, toArray: function toArray() {
	      return d.call(this);
	    }, get: function get(a) {
	      return null != a ? 0 > a ? this[a + this.length] : this[a] : d.call(this);
	    }, pushStack: function pushStack(a) {
	      var b = m.merge(this.constructor(), a);return b.prevObject = this, b.context = this.context, b;
	    }, each: function each(a, b) {
	      return m.each(this, a, b);
	    }, map: function map(a) {
	      return this.pushStack(m.map(this, function (b, c) {
	        return a.call(b, c, b);
	      }));
	    }, slice: function slice() {
	      return this.pushStack(d.apply(this, arguments));
	    }, first: function first() {
	      return this.eq(0);
	    }, last: function last() {
	      return this.eq(-1);
	    }, eq: function eq(a) {
	      var b = this.length,
	          c = +a + (0 > a ? b : 0);return this.pushStack(c >= 0 && b > c ? [this[c]] : []);
	    }, end: function end() {
	      return this.prevObject || this.constructor(null);
	    }, push: f, sort: c.sort, splice: c.splice }, m.extend = m.fn.extend = function () {
	    var a,
	        b,
	        c,
	        d,
	        e,
	        f,
	        g = arguments[0] || {},
	        h = 1,
	        i = arguments.length,
	        j = !1;for ("boolean" == typeof g && (j = g, g = arguments[h] || {}, h++), "object" == (typeof g === "undefined" ? "undefined" : (0, _typeof3.default)(g)) || m.isFunction(g) || (g = {}), h === i && (g = this, h--); i > h; h++) {
	      if (null != (e = arguments[h])) for (d in e) {
	        a = g[d], c = e[d], g !== c && (j && c && (m.isPlainObject(c) || (b = m.isArray(c))) ? (b ? (b = !1, f = a && m.isArray(a) ? a : []) : f = a && m.isPlainObject(a) ? a : {}, g[d] = m.extend(j, f, c)) : void 0 !== c && (g[d] = c));
	      }
	    }return g;
	  }, m.extend({ expando: "jQuery" + (l + Math.random()).replace(/\D/g, ""), isReady: !0, error: function error(a) {
	      throw new Error(a);
	    }, noop: function noop() {}, isFunction: function isFunction(a) {
	      return "function" === m.type(a);
	    }, isArray: Array.isArray || function (a) {
	      return "array" === m.type(a);
	    }, isWindow: function isWindow(a) {
	      return null != a && a == a.window;
	    }, isNumeric: function isNumeric(a) {
	      return !m.isArray(a) && a - parseFloat(a) + 1 >= 0;
	    }, isEmptyObject: function isEmptyObject(a) {
	      var b;for (b in a) {
	        return !1;
	      }return !0;
	    }, isPlainObject: function isPlainObject(a) {
	      var b;if (!a || "object" !== m.type(a) || a.nodeType || m.isWindow(a)) return !1;try {
	        if (a.constructor && !j.call(a, "constructor") && !j.call(a.constructor.prototype, "isPrototypeOf")) return !1;
	      } catch (c) {
	        return !1;
	      }if (k.ownLast) for (b in a) {
	        return j.call(a, b);
	      }for (b in a) {}return void 0 === b || j.call(a, b);
	    }, type: function type(a) {
	      return null == a ? a + "" : "object" == (typeof a === "undefined" ? "undefined" : (0, _typeof3.default)(a)) || "function" == typeof a ? h[i.call(a)] || "object" : typeof a === "undefined" ? "undefined" : (0, _typeof3.default)(a);
	    }, globalEval: function globalEval(b) {
	      b && m.trim(b) && (a.execScript || function (b) {
	        a.eval.call(a, b);
	      })(b);
	    }, camelCase: function camelCase(a) {
	      return a.replace(o, "ms-").replace(p, q);
	    }, nodeName: function nodeName(a, b) {
	      return a.nodeName && a.nodeName.toLowerCase() === b.toLowerCase();
	    }, each: function each(a, b, c) {
	      var d,
	          e = 0,
	          f = a.length,
	          g = r(a);if (c) {
	        if (g) {
	          for (; f > e; e++) {
	            if (d = b.apply(a[e], c), d === !1) break;
	          }
	        } else for (e in a) {
	          if (d = b.apply(a[e], c), d === !1) break;
	        }
	      } else if (g) {
	        for (; f > e; e++) {
	          if (d = b.call(a[e], e, a[e]), d === !1) break;
	        }
	      } else for (e in a) {
	        if (d = b.call(a[e], e, a[e]), d === !1) break;
	      }return a;
	    }, trim: function trim(a) {
	      return null == a ? "" : (a + "").replace(n, "");
	    }, makeArray: function makeArray(a, b) {
	      var c = b || [];return null != a && (r(Object(a)) ? m.merge(c, "string" == typeof a ? [a] : a) : f.call(c, a)), c;
	    }, inArray: function inArray(a, b, c) {
	      var d;if (b) {
	        if (g) return g.call(b, a, c);for (d = b.length, c = c ? 0 > c ? Math.max(0, d + c) : c : 0; d > c; c++) {
	          if (c in b && b[c] === a) return c;
	        }
	      }return -1;
	    }, merge: function merge(a, b) {
	      var c = +b.length,
	          d = 0,
	          e = a.length;while (c > d) {
	        a[e++] = b[d++];
	      }if (c !== c) while (void 0 !== b[d]) {
	        a[e++] = b[d++];
	      }return a.length = e, a;
	    }, grep: function grep(a, b, c) {
	      for (var d, e = [], f = 0, g = a.length, h = !c; g > f; f++) {
	        d = !b(a[f], f), d !== h && e.push(a[f]);
	      }return e;
	    }, map: function map(a, b, c) {
	      var d,
	          f = 0,
	          g = a.length,
	          h = r(a),
	          i = [];if (h) for (; g > f; f++) {
	        d = b(a[f], f, c), null != d && i.push(d);
	      } else for (f in a) {
	        d = b(a[f], f, c), null != d && i.push(d);
	      }return e.apply([], i);
	    }, guid: 1, proxy: function proxy(a, b) {
	      var c, e, f;return "string" == typeof b && (f = a[b], b = a, a = f), m.isFunction(a) ? (c = d.call(arguments, 2), e = function e() {
	        return a.apply(b || this, c.concat(d.call(arguments)));
	      }, e.guid = a.guid = a.guid || m.guid++, e) : void 0;
	    }, now: function now() {
	      return +new Date();
	    }, support: k }), m.each("Boolean Number String Function Array Date RegExp Object Error".split(" "), function (a, b) {
	    h["[object " + b + "]"] = b.toLowerCase();
	  });function r(a) {
	    var b = "length" in a && a.length,
	        c = m.type(a);return "function" === c || m.isWindow(a) ? !1 : 1 === a.nodeType && b ? !0 : "array" === c || 0 === b || "number" == typeof b && b > 0 && b - 1 in a;
	  }var s = function (a) {
	    var b,
	        c,
	        d,
	        e,
	        f,
	        g,
	        h,
	        i,
	        j,
	        k,
	        l,
	        m,
	        n,
	        o,
	        p,
	        q,
	        r,
	        s,
	        t,
	        u = "sizzle" + 1 * new Date(),
	        v = a.document,
	        w = 0,
	        x = 0,
	        y = ha(),
	        z = ha(),
	        A = ha(),
	        B = function B(a, b) {
	      return a === b && (l = !0), 0;
	    },
	        C = 1 << 31,
	        D = {}.hasOwnProperty,
	        E = [],
	        F = E.pop,
	        G = E.push,
	        H = E.push,
	        I = E.slice,
	        J = function J(a, b) {
	      for (var c = 0, d = a.length; d > c; c++) {
	        if (a[c] === b) return c;
	      }return -1;
	    },
	        K = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",
	        L = "[\\x20\\t\\r\\n\\f]",
	        M = "(?:\\\\.|[\\w-]|[^\\x00-\\xa0])+",
	        N = M.replace("w", "w#"),
	        O = "\\[" + L + "*(" + M + ")(?:" + L + "*([*^$|!~]?=)" + L + "*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + N + "))|)" + L + "*\\]",
	        P = ":(" + M + ")(?:\\((('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|((?:\\\\.|[^\\\\()[\\]]|" + O + ")*)|.*)\\)|)",
	        Q = new RegExp(L + "+", "g"),
	        R = new RegExp("^" + L + "+|((?:^|[^\\\\])(?:\\\\.)*)" + L + "+$", "g"),
	        S = new RegExp("^" + L + "*," + L + "*"),
	        T = new RegExp("^" + L + "*([>+~]|" + L + ")" + L + "*"),
	        U = new RegExp("=" + L + "*([^\\]'\"]*?)" + L + "*\\]", "g"),
	        V = new RegExp(P),
	        W = new RegExp("^" + N + "$"),
	        X = { ID: new RegExp("^#(" + M + ")"), CLASS: new RegExp("^\\.(" + M + ")"), TAG: new RegExp("^(" + M.replace("w", "w*") + ")"), ATTR: new RegExp("^" + O), PSEUDO: new RegExp("^" + P), CHILD: new RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + L + "*(even|odd|(([+-]|)(\\d*)n|)" + L + "*(?:([+-]|)" + L + "*(\\d+)|))" + L + "*\\)|)", "i"), bool: new RegExp("^(?:" + K + ")$", "i"), needsContext: new RegExp("^" + L + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" + L + "*((?:-\\d)?\\d*)" + L + "*\\)|)(?=[^-]|$)", "i") },
	        Y = /^(?:input|select|textarea|button)$/i,
	        Z = /^h\d$/i,
	        $ = /^[^{]+\{\s*\[native \w/,
	        _ = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,
	        aa = /[+~]/,
	        ba = /'|\\/g,
	        ca = new RegExp("\\\\([\\da-f]{1,6}" + L + "?|(" + L + ")|.)", "ig"),
	        da = function da(a, b, c) {
	      var d = "0x" + b - 65536;return d !== d || c ? b : 0 > d ? String.fromCharCode(d + 65536) : String.fromCharCode(d >> 10 | 55296, 1023 & d | 56320);
	    },
	        ea = function ea() {
	      m();
	    };try {
	      H.apply(E = I.call(v.childNodes), v.childNodes), E[v.childNodes.length].nodeType;
	    } catch (fa) {
	      H = { apply: E.length ? function (a, b) {
	          G.apply(a, I.call(b));
	        } : function (a, b) {
	          var c = a.length,
	              d = 0;while (a[c++] = b[d++]) {}a.length = c - 1;
	        } };
	    }function ga(a, b, d, e) {
	      var f, h, j, k, l, o, r, s, w, x;if ((b ? b.ownerDocument || b : v) !== n && m(b), b = b || n, d = d || [], k = b.nodeType, "string" != typeof a || !a || 1 !== k && 9 !== k && 11 !== k) return d;if (!e && p) {
	        if (11 !== k && (f = _.exec(a))) if (j = f[1]) {
	          if (9 === k) {
	            if (h = b.getElementById(j), !h || !h.parentNode) return d;if (h.id === j) return d.push(h), d;
	          } else if (b.ownerDocument && (h = b.ownerDocument.getElementById(j)) && t(b, h) && h.id === j) return d.push(h), d;
	        } else {
	          if (f[2]) return H.apply(d, b.getElementsByTagName(a)), d;if ((j = f[3]) && c.getElementsByClassName) return H.apply(d, b.getElementsByClassName(j)), d;
	        }if (c.qsa && (!q || !q.test(a))) {
	          if (s = r = u, w = b, x = 1 !== k && a, 1 === k && "object" !== b.nodeName.toLowerCase()) {
	            o = g(a), (r = b.getAttribute("id")) ? s = r.replace(ba, "\\$&") : b.setAttribute("id", s), s = "[id='" + s + "'] ", l = o.length;while (l--) {
	              o[l] = s + ra(o[l]);
	            }w = aa.test(a) && pa(b.parentNode) || b, x = o.join(",");
	          }if (x) try {
	            return H.apply(d, w.querySelectorAll(x)), d;
	          } catch (y) {} finally {
	            r || b.removeAttribute("id");
	          }
	        }
	      }return i(a.replace(R, "$1"), b, d, e);
	    }function ha() {
	      var a = [];function b(c, e) {
	        return a.push(c + " ") > d.cacheLength && delete b[a.shift()], b[c + " "] = e;
	      }return b;
	    }function ia(a) {
	      return a[u] = !0, a;
	    }function ja(a) {
	      var b = n.createElement("div");try {
	        return !!a(b);
	      } catch (c) {
	        return !1;
	      } finally {
	        b.parentNode && b.parentNode.removeChild(b), b = null;
	      }
	    }function ka(a, b) {
	      var c = a.split("|"),
	          e = a.length;while (e--) {
	        d.attrHandle[c[e]] = b;
	      }
	    }function la(a, b) {
	      var c = b && a,
	          d = c && 1 === a.nodeType && 1 === b.nodeType && (~b.sourceIndex || C) - (~a.sourceIndex || C);if (d) return d;if (c) while (c = c.nextSibling) {
	        if (c === b) return -1;
	      }return a ? 1 : -1;
	    }function ma(a) {
	      return function (b) {
	        var c = b.nodeName.toLowerCase();return "input" === c && b.type === a;
	      };
	    }function na(a) {
	      return function (b) {
	        var c = b.nodeName.toLowerCase();return ("input" === c || "button" === c) && b.type === a;
	      };
	    }function oa(a) {
	      return ia(function (b) {
	        return b = +b, ia(function (c, d) {
	          var e,
	              f = a([], c.length, b),
	              g = f.length;while (g--) {
	            c[e = f[g]] && (c[e] = !(d[e] = c[e]));
	          }
	        });
	      });
	    }function pa(a) {
	      return a && "undefined" != typeof a.getElementsByTagName && a;
	    }c = ga.support = {}, f = ga.isXML = function (a) {
	      var b = a && (a.ownerDocument || a).documentElement;return b ? "HTML" !== b.nodeName : !1;
	    }, m = ga.setDocument = function (a) {
	      var b,
	          e,
	          g = a ? a.ownerDocument || a : v;return g !== n && 9 === g.nodeType && g.documentElement ? (n = g, o = g.documentElement, e = g.defaultView, e && e !== e.top && (e.addEventListener ? e.addEventListener("unload", ea, !1) : e.attachEvent && e.attachEvent("onunload", ea)), p = !f(g), c.attributes = ja(function (a) {
	        return a.className = "i", !a.getAttribute("className");
	      }), c.getElementsByTagName = ja(function (a) {
	        return a.appendChild(g.createComment("")), !a.getElementsByTagName("*").length;
	      }), c.getElementsByClassName = $.test(g.getElementsByClassName), c.getById = ja(function (a) {
	        return o.appendChild(a).id = u, !g.getElementsByName || !g.getElementsByName(u).length;
	      }), c.getById ? (d.find.ID = function (a, b) {
	        if ("undefined" != typeof b.getElementById && p) {
	          var c = b.getElementById(a);return c && c.parentNode ? [c] : [];
	        }
	      }, d.filter.ID = function (a) {
	        var b = a.replace(ca, da);return function (a) {
	          return a.getAttribute("id") === b;
	        };
	      }) : (delete d.find.ID, d.filter.ID = function (a) {
	        var b = a.replace(ca, da);return function (a) {
	          var c = "undefined" != typeof a.getAttributeNode && a.getAttributeNode("id");return c && c.value === b;
	        };
	      }), d.find.TAG = c.getElementsByTagName ? function (a, b) {
	        return "undefined" != typeof b.getElementsByTagName ? b.getElementsByTagName(a) : c.qsa ? b.querySelectorAll(a) : void 0;
	      } : function (a, b) {
	        var c,
	            d = [],
	            e = 0,
	            f = b.getElementsByTagName(a);if ("*" === a) {
	          while (c = f[e++]) {
	            1 === c.nodeType && d.push(c);
	          }return d;
	        }return f;
	      }, d.find.CLASS = c.getElementsByClassName && function (a, b) {
	        return p ? b.getElementsByClassName(a) : void 0;
	      }, r = [], q = [], (c.qsa = $.test(g.querySelectorAll)) && (ja(function (a) {
	        o.appendChild(a).innerHTML = "<a id='" + u + "'></a><select id='" + u + "-\f]' msallowcapture=''><option selected=''></option></select>", a.querySelectorAll("[msallowcapture^='']").length && q.push("[*^$]=" + L + "*(?:''|\"\")"), a.querySelectorAll("[selected]").length || q.push("\\[" + L + "*(?:value|" + K + ")"), a.querySelectorAll("[id~=" + u + "-]").length || q.push("~="), a.querySelectorAll(":checked").length || q.push(":checked"), a.querySelectorAll("a#" + u + "+*").length || q.push(".#.+[+~]");
	      }), ja(function (a) {
	        var b = g.createElement("input");b.setAttribute("type", "hidden"), a.appendChild(b).setAttribute("name", "D"), a.querySelectorAll("[name=d]").length && q.push("name" + L + "*[*^$|!~]?="), a.querySelectorAll(":enabled").length || q.push(":enabled", ":disabled"), a.querySelectorAll("*,:x"), q.push(",.*:");
	      })), (c.matchesSelector = $.test(s = o.matches || o.webkitMatchesSelector || o.mozMatchesSelector || o.oMatchesSelector || o.msMatchesSelector)) && ja(function (a) {
	        c.disconnectedMatch = s.call(a, "div"), s.call(a, "[s!='']:x"), r.push("!=", P);
	      }), q = q.length && new RegExp(q.join("|")), r = r.length && new RegExp(r.join("|")), b = $.test(o.compareDocumentPosition), t = b || $.test(o.contains) ? function (a, b) {
	        var c = 9 === a.nodeType ? a.documentElement : a,
	            d = b && b.parentNode;return a === d || !(!d || 1 !== d.nodeType || !(c.contains ? c.contains(d) : a.compareDocumentPosition && 16 & a.compareDocumentPosition(d)));
	      } : function (a, b) {
	        if (b) while (b = b.parentNode) {
	          if (b === a) return !0;
	        }return !1;
	      }, B = b ? function (a, b) {
	        if (a === b) return l = !0, 0;var d = !a.compareDocumentPosition - !b.compareDocumentPosition;return d ? d : (d = (a.ownerDocument || a) === (b.ownerDocument || b) ? a.compareDocumentPosition(b) : 1, 1 & d || !c.sortDetached && b.compareDocumentPosition(a) === d ? a === g || a.ownerDocument === v && t(v, a) ? -1 : b === g || b.ownerDocument === v && t(v, b) ? 1 : k ? J(k, a) - J(k, b) : 0 : 4 & d ? -1 : 1);
	      } : function (a, b) {
	        if (a === b) return l = !0, 0;var c,
	            d = 0,
	            e = a.parentNode,
	            f = b.parentNode,
	            h = [a],
	            i = [b];if (!e || !f) return a === g ? -1 : b === g ? 1 : e ? -1 : f ? 1 : k ? J(k, a) - J(k, b) : 0;if (e === f) return la(a, b);c = a;while (c = c.parentNode) {
	          h.unshift(c);
	        }c = b;while (c = c.parentNode) {
	          i.unshift(c);
	        }while (h[d] === i[d]) {
	          d++;
	        }return d ? la(h[d], i[d]) : h[d] === v ? -1 : i[d] === v ? 1 : 0;
	      }, g) : n;
	    }, ga.matches = function (a, b) {
	      return ga(a, null, null, b);
	    }, ga.matchesSelector = function (a, b) {
	      if ((a.ownerDocument || a) !== n && m(a), b = b.replace(U, "='$1']"), !(!c.matchesSelector || !p || r && r.test(b) || q && q.test(b))) try {
	        var d = s.call(a, b);if (d || c.disconnectedMatch || a.document && 11 !== a.document.nodeType) return d;
	      } catch (e) {}return ga(b, n, null, [a]).length > 0;
	    }, ga.contains = function (a, b) {
	      return (a.ownerDocument || a) !== n && m(a), t(a, b);
	    }, ga.attr = function (a, b) {
	      (a.ownerDocument || a) !== n && m(a);var e = d.attrHandle[b.toLowerCase()],
	          f = e && D.call(d.attrHandle, b.toLowerCase()) ? e(a, b, !p) : void 0;return void 0 !== f ? f : c.attributes || !p ? a.getAttribute(b) : (f = a.getAttributeNode(b)) && f.specified ? f.value : null;
	    }, ga.error = function (a) {
	      throw new Error("Syntax error, unrecognized expression: " + a);
	    }, ga.uniqueSort = function (a) {
	      var b,
	          d = [],
	          e = 0,
	          f = 0;if (l = !c.detectDuplicates, k = !c.sortStable && a.slice(0), a.sort(B), l) {
	        while (b = a[f++]) {
	          b === a[f] && (e = d.push(f));
	        }while (e--) {
	          a.splice(d[e], 1);
	        }
	      }return k = null, a;
	    }, e = ga.getText = function (a) {
	      var b,
	          c = "",
	          d = 0,
	          f = a.nodeType;if (f) {
	        if (1 === f || 9 === f || 11 === f) {
	          if ("string" == typeof a.textContent) return a.textContent;for (a = a.firstChild; a; a = a.nextSibling) {
	            c += e(a);
	          }
	        } else if (3 === f || 4 === f) return a.nodeValue;
	      } else while (b = a[d++]) {
	        c += e(b);
	      }return c;
	    }, d = ga.selectors = { cacheLength: 50, createPseudo: ia, match: X, attrHandle: {}, find: {}, relative: { ">": { dir: "parentNode", first: !0 }, " ": { dir: "parentNode" }, "+": { dir: "previousSibling", first: !0 }, "~": { dir: "previousSibling" } }, preFilter: { ATTR: function ATTR(a) {
	          return a[1] = a[1].replace(ca, da), a[3] = (a[3] || a[4] || a[5] || "").replace(ca, da), "~=" === a[2] && (a[3] = " " + a[3] + " "), a.slice(0, 4);
	        }, CHILD: function CHILD(a) {
	          return a[1] = a[1].toLowerCase(), "nth" === a[1].slice(0, 3) ? (a[3] || ga.error(a[0]), a[4] = +(a[4] ? a[5] + (a[6] || 1) : 2 * ("even" === a[3] || "odd" === a[3])), a[5] = +(a[7] + a[8] || "odd" === a[3])) : a[3] && ga.error(a[0]), a;
	        }, PSEUDO: function PSEUDO(a) {
	          var b,
	              c = !a[6] && a[2];return X.CHILD.test(a[0]) ? null : (a[3] ? a[2] = a[4] || a[5] || "" : c && V.test(c) && (b = g(c, !0)) && (b = c.indexOf(")", c.length - b) - c.length) && (a[0] = a[0].slice(0, b), a[2] = c.slice(0, b)), a.slice(0, 3));
	        } }, filter: { TAG: function TAG(a) {
	          var b = a.replace(ca, da).toLowerCase();return "*" === a ? function () {
	            return !0;
	          } : function (a) {
	            return a.nodeName && a.nodeName.toLowerCase() === b;
	          };
	        }, CLASS: function CLASS(a) {
	          var b = y[a + " "];return b || (b = new RegExp("(^|" + L + ")" + a + "(" + L + "|$)")) && y(a, function (a) {
	            return b.test("string" == typeof a.className && a.className || "undefined" != typeof a.getAttribute && a.getAttribute("class") || "");
	          });
	        }, ATTR: function ATTR(a, b, c) {
	          return function (d) {
	            var e = ga.attr(d, a);return null == e ? "!=" === b : b ? (e += "", "=" === b ? e === c : "!=" === b ? e !== c : "^=" === b ? c && 0 === e.indexOf(c) : "*=" === b ? c && e.indexOf(c) > -1 : "$=" === b ? c && e.slice(-c.length) === c : "~=" === b ? (" " + e.replace(Q, " ") + " ").indexOf(c) > -1 : "|=" === b ? e === c || e.slice(0, c.length + 1) === c + "-" : !1) : !0;
	          };
	        }, CHILD: function CHILD(a, b, c, d, e) {
	          var f = "nth" !== a.slice(0, 3),
	              g = "last" !== a.slice(-4),
	              h = "of-type" === b;return 1 === d && 0 === e ? function (a) {
	            return !!a.parentNode;
	          } : function (b, c, i) {
	            var j,
	                k,
	                l,
	                m,
	                n,
	                o,
	                p = f !== g ? "nextSibling" : "previousSibling",
	                q = b.parentNode,
	                r = h && b.nodeName.toLowerCase(),
	                s = !i && !h;if (q) {
	              if (f) {
	                while (p) {
	                  l = b;while (l = l[p]) {
	                    if (h ? l.nodeName.toLowerCase() === r : 1 === l.nodeType) return !1;
	                  }o = p = "only" === a && !o && "nextSibling";
	                }return !0;
	              }if (o = [g ? q.firstChild : q.lastChild], g && s) {
	                k = q[u] || (q[u] = {}), j = k[a] || [], n = j[0] === w && j[1], m = j[0] === w && j[2], l = n && q.childNodes[n];while (l = ++n && l && l[p] || (m = n = 0) || o.pop()) {
	                  if (1 === l.nodeType && ++m && l === b) {
	                    k[a] = [w, n, m];break;
	                  }
	                }
	              } else if (s && (j = (b[u] || (b[u] = {}))[a]) && j[0] === w) m = j[1];else while (l = ++n && l && l[p] || (m = n = 0) || o.pop()) {
	                if ((h ? l.nodeName.toLowerCase() === r : 1 === l.nodeType) && ++m && (s && ((l[u] || (l[u] = {}))[a] = [w, m]), l === b)) break;
	              }return m -= e, m === d || m % d === 0 && m / d >= 0;
	            }
	          };
	        }, PSEUDO: function PSEUDO(a, b) {
	          var c,
	              e = d.pseudos[a] || d.setFilters[a.toLowerCase()] || ga.error("unsupported pseudo: " + a);return e[u] ? e(b) : e.length > 1 ? (c = [a, a, "", b], d.setFilters.hasOwnProperty(a.toLowerCase()) ? ia(function (a, c) {
	            var d,
	                f = e(a, b),
	                g = f.length;while (g--) {
	              d = J(a, f[g]), a[d] = !(c[d] = f[g]);
	            }
	          }) : function (a) {
	            return e(a, 0, c);
	          }) : e;
	        } }, pseudos: { not: ia(function (a) {
	          var b = [],
	              c = [],
	              d = h(a.replace(R, "$1"));return d[u] ? ia(function (a, b, c, e) {
	            var f,
	                g = d(a, null, e, []),
	                h = a.length;while (h--) {
	              (f = g[h]) && (a[h] = !(b[h] = f));
	            }
	          }) : function (a, e, f) {
	            return b[0] = a, d(b, null, f, c), b[0] = null, !c.pop();
	          };
	        }), has: ia(function (a) {
	          return function (b) {
	            return ga(a, b).length > 0;
	          };
	        }), contains: ia(function (a) {
	          return a = a.replace(ca, da), function (b) {
	            return (b.textContent || b.innerText || e(b)).indexOf(a) > -1;
	          };
	        }), lang: ia(function (a) {
	          return W.test(a || "") || ga.error("unsupported lang: " + a), a = a.replace(ca, da).toLowerCase(), function (b) {
	            var c;do {
	              if (c = p ? b.lang : b.getAttribute("xml:lang") || b.getAttribute("lang")) return c = c.toLowerCase(), c === a || 0 === c.indexOf(a + "-");
	            } while ((b = b.parentNode) && 1 === b.nodeType);return !1;
	          };
	        }), target: function target(b) {
	          var c = a.location && a.location.hash;return c && c.slice(1) === b.id;
	        }, root: function root(a) {
	          return a === o;
	        }, focus: function focus(a) {
	          return a === n.activeElement && (!n.hasFocus || n.hasFocus()) && !!(a.type || a.href || ~a.tabIndex);
	        }, enabled: function enabled(a) {
	          return a.disabled === !1;
	        }, disabled: function disabled(a) {
	          return a.disabled === !0;
	        }, checked: function checked(a) {
	          var b = a.nodeName.toLowerCase();return "input" === b && !!a.checked || "option" === b && !!a.selected;
	        }, selected: function selected(a) {
	          return a.parentNode && a.parentNode.selectedIndex, a.selected === !0;
	        }, empty: function empty(a) {
	          for (a = a.firstChild; a; a = a.nextSibling) {
	            if (a.nodeType < 6) return !1;
	          }return !0;
	        }, parent: function parent(a) {
	          return !d.pseudos.empty(a);
	        }, header: function header(a) {
	          return Z.test(a.nodeName);
	        }, input: function input(a) {
	          return Y.test(a.nodeName);
	        }, button: function button(a) {
	          var b = a.nodeName.toLowerCase();return "input" === b && "button" === a.type || "button" === b;
	        }, text: function text(a) {
	          var b;return "input" === a.nodeName.toLowerCase() && "text" === a.type && (null == (b = a.getAttribute("type")) || "text" === b.toLowerCase());
	        }, first: oa(function () {
	          return [0];
	        }), last: oa(function (a, b) {
	          return [b - 1];
	        }), eq: oa(function (a, b, c) {
	          return [0 > c ? c + b : c];
	        }), even: oa(function (a, b) {
	          for (var c = 0; b > c; c += 2) {
	            a.push(c);
	          }return a;
	        }), odd: oa(function (a, b) {
	          for (var c = 1; b > c; c += 2) {
	            a.push(c);
	          }return a;
	        }), lt: oa(function (a, b, c) {
	          for (var d = 0 > c ? c + b : c; --d >= 0;) {
	            a.push(d);
	          }return a;
	        }), gt: oa(function (a, b, c) {
	          for (var d = 0 > c ? c + b : c; ++d < b;) {
	            a.push(d);
	          }return a;
	        }) } }, d.pseudos.nth = d.pseudos.eq;for (b in { radio: !0, checkbox: !0, file: !0, password: !0, image: !0 }) {
	      d.pseudos[b] = ma(b);
	    }for (b in { submit: !0, reset: !0 }) {
	      d.pseudos[b] = na(b);
	    }function qa() {}qa.prototype = d.filters = d.pseudos, d.setFilters = new qa(), g = ga.tokenize = function (a, b) {
	      var c,
	          e,
	          f,
	          g,
	          h,
	          i,
	          j,
	          k = z[a + " "];if (k) return b ? 0 : k.slice(0);h = a, i = [], j = d.preFilter;while (h) {
	        (!c || (e = S.exec(h))) && (e && (h = h.slice(e[0].length) || h), i.push(f = [])), c = !1, (e = T.exec(h)) && (c = e.shift(), f.push({ value: c, type: e[0].replace(R, " ") }), h = h.slice(c.length));for (g in d.filter) {
	          !(e = X[g].exec(h)) || j[g] && !(e = j[g](e)) || (c = e.shift(), f.push({ value: c, type: g, matches: e }), h = h.slice(c.length));
	        }if (!c) break;
	      }return b ? h.length : h ? ga.error(a) : z(a, i).slice(0);
	    };function ra(a) {
	      for (var b = 0, c = a.length, d = ""; c > b; b++) {
	        d += a[b].value;
	      }return d;
	    }function sa(a, b, c) {
	      var d = b.dir,
	          e = c && "parentNode" === d,
	          f = x++;return b.first ? function (b, c, f) {
	        while (b = b[d]) {
	          if (1 === b.nodeType || e) return a(b, c, f);
	        }
	      } : function (b, c, g) {
	        var h,
	            i,
	            j = [w, f];if (g) {
	          while (b = b[d]) {
	            if ((1 === b.nodeType || e) && a(b, c, g)) return !0;
	          }
	        } else while (b = b[d]) {
	          if (1 === b.nodeType || e) {
	            if (i = b[u] || (b[u] = {}), (h = i[d]) && h[0] === w && h[1] === f) return j[2] = h[2];if (i[d] = j, j[2] = a(b, c, g)) return !0;
	          }
	        }
	      };
	    }function ta(a) {
	      return a.length > 1 ? function (b, c, d) {
	        var e = a.length;while (e--) {
	          if (!a[e](b, c, d)) return !1;
	        }return !0;
	      } : a[0];
	    }function ua(a, b, c) {
	      for (var d = 0, e = b.length; e > d; d++) {
	        ga(a, b[d], c);
	      }return c;
	    }function va(a, b, c, d, e) {
	      for (var f, g = [], h = 0, i = a.length, j = null != b; i > h; h++) {
	        (f = a[h]) && (!c || c(f, d, e)) && (g.push(f), j && b.push(h));
	      }return g;
	    }function wa(a, b, c, d, e, f) {
	      return d && !d[u] && (d = wa(d)), e && !e[u] && (e = wa(e, f)), ia(function (f, g, h, i) {
	        var j,
	            k,
	            l,
	            m = [],
	            n = [],
	            o = g.length,
	            p = f || ua(b || "*", h.nodeType ? [h] : h, []),
	            q = !a || !f && b ? p : va(p, m, a, h, i),
	            r = c ? e || (f ? a : o || d) ? [] : g : q;if (c && c(q, r, h, i), d) {
	          j = va(r, n), d(j, [], h, i), k = j.length;while (k--) {
	            (l = j[k]) && (r[n[k]] = !(q[n[k]] = l));
	          }
	        }if (f) {
	          if (e || a) {
	            if (e) {
	              j = [], k = r.length;while (k--) {
	                (l = r[k]) && j.push(q[k] = l);
	              }e(null, r = [], j, i);
	            }k = r.length;while (k--) {
	              (l = r[k]) && (j = e ? J(f, l) : m[k]) > -1 && (f[j] = !(g[j] = l));
	            }
	          }
	        } else r = va(r === g ? r.splice(o, r.length) : r), e ? e(null, g, r, i) : H.apply(g, r);
	      });
	    }function xa(a) {
	      for (var b, c, e, f = a.length, g = d.relative[a[0].type], h = g || d.relative[" "], i = g ? 1 : 0, k = sa(function (a) {
	        return a === b;
	      }, h, !0), l = sa(function (a) {
	        return J(b, a) > -1;
	      }, h, !0), m = [function (a, c, d) {
	        var e = !g && (d || c !== j) || ((b = c).nodeType ? k(a, c, d) : l(a, c, d));return b = null, e;
	      }]; f > i; i++) {
	        if (c = d.relative[a[i].type]) m = [sa(ta(m), c)];else {
	          if (c = d.filter[a[i].type].apply(null, a[i].matches), c[u]) {
	            for (e = ++i; f > e; e++) {
	              if (d.relative[a[e].type]) break;
	            }return wa(i > 1 && ta(m), i > 1 && ra(a.slice(0, i - 1).concat({ value: " " === a[i - 2].type ? "*" : "" })).replace(R, "$1"), c, e > i && xa(a.slice(i, e)), f > e && xa(a = a.slice(e)), f > e && ra(a));
	          }m.push(c);
	        }
	      }return ta(m);
	    }function ya(a, b) {
	      var c = b.length > 0,
	          e = a.length > 0,
	          f = function f(_f, g, h, i, k) {
	        var l,
	            m,
	            o,
	            p = 0,
	            q = "0",
	            r = _f && [],
	            s = [],
	            t = j,
	            u = _f || e && d.find.TAG("*", k),
	            v = w += null == t ? 1 : Math.random() || .1,
	            x = u.length;for (k && (j = g !== n && g); q !== x && null != (l = u[q]); q++) {
	          if (e && l) {
	            m = 0;while (o = a[m++]) {
	              if (o(l, g, h)) {
	                i.push(l);break;
	              }
	            }k && (w = v);
	          }c && ((l = !o && l) && p--, _f && r.push(l));
	        }if (p += q, c && q !== p) {
	          m = 0;while (o = b[m++]) {
	            o(r, s, g, h);
	          }if (_f) {
	            if (p > 0) while (q--) {
	              r[q] || s[q] || (s[q] = F.call(i));
	            }s = va(s);
	          }H.apply(i, s), k && !_f && s.length > 0 && p + b.length > 1 && ga.uniqueSort(i);
	        }return k && (w = v, j = t), r;
	      };return c ? ia(f) : f;
	    }return h = ga.compile = function (a, b) {
	      var c,
	          d = [],
	          e = [],
	          f = A[a + " "];if (!f) {
	        b || (b = g(a)), c = b.length;while (c--) {
	          f = xa(b[c]), f[u] ? d.push(f) : e.push(f);
	        }f = A(a, ya(e, d)), f.selector = a;
	      }return f;
	    }, i = ga.select = function (a, b, e, f) {
	      var i,
	          j,
	          k,
	          l,
	          m,
	          n = "function" == typeof a && a,
	          o = !f && g(a = n.selector || a);if (e = e || [], 1 === o.length) {
	        if (j = o[0] = o[0].slice(0), j.length > 2 && "ID" === (k = j[0]).type && c.getById && 9 === b.nodeType && p && d.relative[j[1].type]) {
	          if (b = (d.find.ID(k.matches[0].replace(ca, da), b) || [])[0], !b) return e;n && (b = b.parentNode), a = a.slice(j.shift().value.length);
	        }i = X.needsContext.test(a) ? 0 : j.length;while (i--) {
	          if (k = j[i], d.relative[l = k.type]) break;if ((m = d.find[l]) && (f = m(k.matches[0].replace(ca, da), aa.test(j[0].type) && pa(b.parentNode) || b))) {
	            if (j.splice(i, 1), a = f.length && ra(j), !a) return H.apply(e, f), e;break;
	          }
	        }
	      }return (n || h(a, o))(f, b, !p, e, aa.test(a) && pa(b.parentNode) || b), e;
	    }, c.sortStable = u.split("").sort(B).join("") === u, c.detectDuplicates = !!l, m(), c.sortDetached = ja(function (a) {
	      return 1 & a.compareDocumentPosition(n.createElement("div"));
	    }), ja(function (a) {
	      return a.innerHTML = "<a href='#'></a>", "#" === a.firstChild.getAttribute("href");
	    }) || ka("type|href|height|width", function (a, b, c) {
	      return c ? void 0 : a.getAttribute(b, "type" === b.toLowerCase() ? 1 : 2);
	    }), c.attributes && ja(function (a) {
	      return a.innerHTML = "<input/>", a.firstChild.setAttribute("value", ""), "" === a.firstChild.getAttribute("value");
	    }) || ka("value", function (a, b, c) {
	      return c || "input" !== a.nodeName.toLowerCase() ? void 0 : a.defaultValue;
	    }), ja(function (a) {
	      return null == a.getAttribute("disabled");
	    }) || ka(K, function (a, b, c) {
	      var d;return c ? void 0 : a[b] === !0 ? b.toLowerCase() : (d = a.getAttributeNode(b)) && d.specified ? d.value : null;
	    }), ga;
	  }(a);m.find = s, m.expr = s.selectors, m.expr[":"] = m.expr.pseudos, m.unique = s.uniqueSort, m.text = s.getText, m.isXMLDoc = s.isXML, m.contains = s.contains;var t = m.expr.match.needsContext,
	      u = /^<(\w+)\s*\/?>(?:<\/\1>|)$/,
	      v = /^.[^:#\[\.,]*$/;function w(a, b, c) {
	    if (m.isFunction(b)) return m.grep(a, function (a, d) {
	      return !!b.call(a, d, a) !== c;
	    });if (b.nodeType) return m.grep(a, function (a) {
	      return a === b !== c;
	    });if ("string" == typeof b) {
	      if (v.test(b)) return m.filter(b, a, c);b = m.filter(b, a);
	    }return m.grep(a, function (a) {
	      return m.inArray(a, b) >= 0 !== c;
	    });
	  }m.filter = function (a, b, c) {
	    var d = b[0];return c && (a = ":not(" + a + ")"), 1 === b.length && 1 === d.nodeType ? m.find.matchesSelector(d, a) ? [d] : [] : m.find.matches(a, m.grep(b, function (a) {
	      return 1 === a.nodeType;
	    }));
	  }, m.fn.extend({ find: function find(a) {
	      var b,
	          c = [],
	          d = this,
	          e = d.length;if ("string" != typeof a) return this.pushStack(m(a).filter(function () {
	        for (b = 0; e > b; b++) {
	          if (m.contains(d[b], this)) return !0;
	        }
	      }));for (b = 0; e > b; b++) {
	        m.find(a, d[b], c);
	      }return c = this.pushStack(e > 1 ? m.unique(c) : c), c.selector = this.selector ? this.selector + " " + a : a, c;
	    }, filter: function filter(a) {
	      return this.pushStack(w(this, a || [], !1));
	    }, not: function not(a) {
	      return this.pushStack(w(this, a || [], !0));
	    }, is: function is(a) {
	      return !!w(this, "string" == typeof a && t.test(a) ? m(a) : a || [], !1).length;
	    } });var x,
	      y = a.document,
	      z = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]*))$/,
	      A = m.fn.init = function (a, b) {
	    var c, d;if (!a) return this;if ("string" == typeof a) {
	      if (c = "<" === a.charAt(0) && ">" === a.charAt(a.length - 1) && a.length >= 3 ? [null, a, null] : z.exec(a), !c || !c[1] && b) return !b || b.jquery ? (b || x).find(a) : this.constructor(b).find(a);if (c[1]) {
	        if (b = b instanceof m ? b[0] : b, m.merge(this, m.parseHTML(c[1], b && b.nodeType ? b.ownerDocument || b : y, !0)), u.test(c[1]) && m.isPlainObject(b)) for (c in b) {
	          m.isFunction(this[c]) ? this[c](b[c]) : this.attr(c, b[c]);
	        }return this;
	      }if (d = y.getElementById(c[2]), d && d.parentNode) {
	        if (d.id !== c[2]) return x.find(a);this.length = 1, this[0] = d;
	      }return this.context = y, this.selector = a, this;
	    }return a.nodeType ? (this.context = this[0] = a, this.length = 1, this) : m.isFunction(a) ? "undefined" != typeof x.ready ? x.ready(a) : a(m) : (void 0 !== a.selector && (this.selector = a.selector, this.context = a.context), m.makeArray(a, this));
	  };A.prototype = m.fn, x = m(y);var B = /^(?:parents|prev(?:Until|All))/,
	      C = { children: !0, contents: !0, next: !0, prev: !0 };m.extend({ dir: function dir(a, b, c) {
	      var d = [],
	          e = a[b];while (e && 9 !== e.nodeType && (void 0 === c || 1 !== e.nodeType || !m(e).is(c))) {
	        1 === e.nodeType && d.push(e), e = e[b];
	      }return d;
	    }, sibling: function sibling(a, b) {
	      for (var c = []; a; a = a.nextSibling) {
	        1 === a.nodeType && a !== b && c.push(a);
	      }return c;
	    } }), m.fn.extend({ has: function has(a) {
	      var b,
	          c = m(a, this),
	          d = c.length;return this.filter(function () {
	        for (b = 0; d > b; b++) {
	          if (m.contains(this, c[b])) return !0;
	        }
	      });
	    }, closest: function closest(a, b) {
	      for (var c, d = 0, e = this.length, f = [], g = t.test(a) || "string" != typeof a ? m(a, b || this.context) : 0; e > d; d++) {
	        for (c = this[d]; c && c !== b; c = c.parentNode) {
	          if (c.nodeType < 11 && (g ? g.index(c) > -1 : 1 === c.nodeType && m.find.matchesSelector(c, a))) {
	            f.push(c);break;
	          }
	        }
	      }return this.pushStack(f.length > 1 ? m.unique(f) : f);
	    }, index: function index(a) {
	      return a ? "string" == typeof a ? m.inArray(this[0], m(a)) : m.inArray(a.jquery ? a[0] : a, this) : this[0] && this[0].parentNode ? this.first().prevAll().length : -1;
	    }, add: function add(a, b) {
	      return this.pushStack(m.unique(m.merge(this.get(), m(a, b))));
	    }, addBack: function addBack(a) {
	      return this.add(null == a ? this.prevObject : this.prevObject.filter(a));
	    } });function D(a, b) {
	    do {
	      a = a[b];
	    } while (a && 1 !== a.nodeType);return a;
	  }m.each({ parent: function parent(a) {
	      var b = a.parentNode;return b && 11 !== b.nodeType ? b : null;
	    }, parents: function parents(a) {
	      return m.dir(a, "parentNode");
	    }, parentsUntil: function parentsUntil(a, b, c) {
	      return m.dir(a, "parentNode", c);
	    }, next: function next(a) {
	      return D(a, "nextSibling");
	    }, prev: function prev(a) {
	      return D(a, "previousSibling");
	    }, nextAll: function nextAll(a) {
	      return m.dir(a, "nextSibling");
	    }, prevAll: function prevAll(a) {
	      return m.dir(a, "previousSibling");
	    }, nextUntil: function nextUntil(a, b, c) {
	      return m.dir(a, "nextSibling", c);
	    }, prevUntil: function prevUntil(a, b, c) {
	      return m.dir(a, "previousSibling", c);
	    }, siblings: function siblings(a) {
	      return m.sibling((a.parentNode || {}).firstChild, a);
	    }, children: function children(a) {
	      return m.sibling(a.firstChild);
	    }, contents: function contents(a) {
	      return m.nodeName(a, "iframe") ? a.contentDocument || a.contentWindow.document : m.merge([], a.childNodes);
	    } }, function (a, b) {
	    m.fn[a] = function (c, d) {
	      var e = m.map(this, b, c);return "Until" !== a.slice(-5) && (d = c), d && "string" == typeof d && (e = m.filter(d, e)), this.length > 1 && (C[a] || (e = m.unique(e)), B.test(a) && (e = e.reverse())), this.pushStack(e);
	    };
	  });var E = /\S+/g,
	      F = {};function G(a) {
	    var b = F[a] = {};return m.each(a.match(E) || [], function (a, c) {
	      b[c] = !0;
	    }), b;
	  }m.Callbacks = function (a) {
	    a = "string" == typeof a ? F[a] || G(a) : m.extend({}, a);var b,
	        c,
	        d,
	        e,
	        f,
	        g,
	        h = [],
	        i = !a.once && [],
	        j = function j(l) {
	      for (c = a.memory && l, d = !0, f = g || 0, g = 0, e = h.length, b = !0; h && e > f; f++) {
	        if (h[f].apply(l[0], l[1]) === !1 && a.stopOnFalse) {
	          c = !1;break;
	        }
	      }b = !1, h && (i ? i.length && j(i.shift()) : c ? h = [] : k.disable());
	    },
	        k = { add: function add() {
	        if (h) {
	          var d = h.length;!function f(b) {
	            m.each(b, function (b, c) {
	              var d = m.type(c);"function" === d ? a.unique && k.has(c) || h.push(c) : c && c.length && "string" !== d && f(c);
	            });
	          }(arguments), b ? e = h.length : c && (g = d, j(c));
	        }return this;
	      }, remove: function remove() {
	        return h && m.each(arguments, function (a, c) {
	          var d;while ((d = m.inArray(c, h, d)) > -1) {
	            h.splice(d, 1), b && (e >= d && e--, f >= d && f--);
	          }
	        }), this;
	      }, has: function has(a) {
	        return a ? m.inArray(a, h) > -1 : !(!h || !h.length);
	      }, empty: function empty() {
	        return h = [], e = 0, this;
	      }, disable: function disable() {
	        return h = i = c = void 0, this;
	      }, disabled: function disabled() {
	        return !h;
	      }, lock: function lock() {
	        return i = void 0, c || k.disable(), this;
	      }, locked: function locked() {
	        return !i;
	      }, fireWith: function fireWith(a, c) {
	        return !h || d && !i || (c = c || [], c = [a, c.slice ? c.slice() : c], b ? i.push(c) : j(c)), this;
	      }, fire: function fire() {
	        return k.fireWith(this, arguments), this;
	      }, fired: function fired() {
	        return !!d;
	      } };return k;
	  }, m.extend({ Deferred: function Deferred(a) {
	      var b = [["resolve", "done", m.Callbacks("once memory"), "resolved"], ["reject", "fail", m.Callbacks("once memory"), "rejected"], ["notify", "progress", m.Callbacks("memory")]],
	          c = "pending",
	          d = { state: function state() {
	          return c;
	        }, always: function always() {
	          return e.done(arguments).fail(arguments), this;
	        }, then: function then() {
	          var a = arguments;return m.Deferred(function (c) {
	            m.each(b, function (b, f) {
	              var g = m.isFunction(a[b]) && a[b];e[f[1]](function () {
	                var a = g && g.apply(this, arguments);a && m.isFunction(a.promise) ? a.promise().done(c.resolve).fail(c.reject).progress(c.notify) : c[f[0] + "With"](this === d ? c.promise() : this, g ? [a] : arguments);
	              });
	            }), a = null;
	          }).promise();
	        }, promise: function promise(a) {
	          return null != a ? m.extend(a, d) : d;
	        } },
	          e = {};return d.pipe = d.then, m.each(b, function (a, f) {
	        var g = f[2],
	            h = f[3];d[f[1]] = g.add, h && g.add(function () {
	          c = h;
	        }, b[1 ^ a][2].disable, b[2][2].lock), e[f[0]] = function () {
	          return e[f[0] + "With"](this === e ? d : this, arguments), this;
	        }, e[f[0] + "With"] = g.fireWith;
	      }), d.promise(e), a && a.call(e, e), e;
	    }, when: function when(a) {
	      var b = 0,
	          c = d.call(arguments),
	          e = c.length,
	          f = 1 !== e || a && m.isFunction(a.promise) ? e : 0,
	          g = 1 === f ? a : m.Deferred(),
	          h = function h(a, b, c) {
	        return function (e) {
	          b[a] = this, c[a] = arguments.length > 1 ? d.call(arguments) : e, c === i ? g.notifyWith(b, c) : --f || g.resolveWith(b, c);
	        };
	      },
	          i,
	          j,
	          k;if (e > 1) for (i = new Array(e), j = new Array(e), k = new Array(e); e > b; b++) {
	        c[b] && m.isFunction(c[b].promise) ? c[b].promise().done(h(b, k, c)).fail(g.reject).progress(h(b, j, i)) : --f;
	      }return f || g.resolveWith(k, c), g.promise();
	    } });var H;m.fn.ready = function (a) {
	    return m.ready.promise().done(a), this;
	  }, m.extend({ isReady: !1, readyWait: 1, holdReady: function holdReady(a) {
	      a ? m.readyWait++ : m.ready(!0);
	    }, ready: function ready(a) {
	      if (a === !0 ? ! --m.readyWait : !m.isReady) {
	        if (!y.body) return setTimeout(m.ready);m.isReady = !0, a !== !0 && --m.readyWait > 0 || (H.resolveWith(y, [m]), m.fn.triggerHandler && (m(y).triggerHandler("ready"), m(y).off("ready")));
	      }
	    } });function I() {
	    y.addEventListener ? (y.removeEventListener("DOMContentLoaded", J, !1), a.removeEventListener("load", J, !1)) : (y.detachEvent("onreadystatechange", J), a.detachEvent("onload", J));
	  }function J() {
	    (y.addEventListener || "load" === event.type || "complete" === y.readyState) && (I(), m.ready());
	  }m.ready.promise = function (b) {
	    if (!H) if (H = m.Deferred(), "complete" === y.readyState) setTimeout(m.ready);else if (y.addEventListener) y.addEventListener("DOMContentLoaded", J, !1), a.addEventListener("load", J, !1);else {
	      y.attachEvent("onreadystatechange", J), a.attachEvent("onload", J);var c = !1;try {
	        c = null == a.frameElement && y.documentElement;
	      } catch (d) {}c && c.doScroll && !function e() {
	        if (!m.isReady) {
	          try {
	            c.doScroll("left");
	          } catch (a) {
	            return setTimeout(e, 50);
	          }I(), m.ready();
	        }
	      }();
	    }return H.promise(b);
	  };var K = "undefined",
	      L;for (L in m(k)) {
	    break;
	  }k.ownLast = "0" !== L, k.inlineBlockNeedsLayout = !1, m(function () {
	    var a, b, c, d;c = y.getElementsByTagName("body")[0], c && c.style && (b = y.createElement("div"), d = y.createElement("div"), d.style.cssText = "position:absolute;border:0;width:0;height:0;top:0;left:-9999px", c.appendChild(d).appendChild(b), (0, _typeof3.default)(b.style.zoom) !== K && (b.style.cssText = "display:inline;margin:0;border:0;padding:1px;width:1px;zoom:1", k.inlineBlockNeedsLayout = a = 3 === b.offsetWidth, a && (c.style.zoom = 1)), c.removeChild(d));
	  }), function () {
	    var a = y.createElement("div");if (null == k.deleteExpando) {
	      k.deleteExpando = !0;try {
	        delete a.test;
	      } catch (b) {
	        k.deleteExpando = !1;
	      }
	    }a = null;
	  }(), m.acceptData = function (a) {
	    var b = m.noData[(a.nodeName + " ").toLowerCase()],
	        c = +a.nodeType || 1;return 1 !== c && 9 !== c ? !1 : !b || b !== !0 && a.getAttribute("classid") === b;
	  };var M = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
	      N = /([A-Z])/g;function O(a, b, c) {
	    if (void 0 === c && 1 === a.nodeType) {
	      var d = "data-" + b.replace(N, "-$1").toLowerCase();if (c = a.getAttribute(d), "string" == typeof c) {
	        try {
	          c = "true" === c ? !0 : "false" === c ? !1 : "null" === c ? null : +c + "" === c ? +c : M.test(c) ? m.parseJSON(c) : c;
	        } catch (e) {}m.data(a, b, c);
	      } else c = void 0;
	    }return c;
	  }function P(a) {
	    var b;for (b in a) {
	      if (("data" !== b || !m.isEmptyObject(a[b])) && "toJSON" !== b) return !1;
	    }return !0;
	  }function Q(a, b, d, e) {
	    if (m.acceptData(a)) {
	      var f,
	          g,
	          h = m.expando,
	          i = a.nodeType,
	          j = i ? m.cache : a,
	          k = i ? a[h] : a[h] && h;if (k && j[k] && (e || j[k].data) || void 0 !== d || "string" != typeof b) return k || (k = i ? a[h] = c.pop() || m.guid++ : h), j[k] || (j[k] = i ? {} : { toJSON: m.noop }), ("object" == (typeof b === "undefined" ? "undefined" : (0, _typeof3.default)(b)) || "function" == typeof b) && (e ? j[k] = m.extend(j[k], b) : j[k].data = m.extend(j[k].data, b)), g = j[k], e || (g.data || (g.data = {}), g = g.data), void 0 !== d && (g[m.camelCase(b)] = d), "string" == typeof b ? (f = g[b], null == f && (f = g[m.camelCase(b)])) : f = g, f;
	    }
	  }function R(a, b, c) {
	    if (m.acceptData(a)) {
	      var d,
	          e,
	          f = a.nodeType,
	          g = f ? m.cache : a,
	          h = f ? a[m.expando] : m.expando;if (g[h]) {
	        if (b && (d = c ? g[h] : g[h].data)) {
	          m.isArray(b) ? b = b.concat(m.map(b, m.camelCase)) : b in d ? b = [b] : (b = m.camelCase(b), b = b in d ? [b] : b.split(" ")), e = b.length;while (e--) {
	            delete d[b[e]];
	          }if (c ? !P(d) : !m.isEmptyObject(d)) return;
	        }(c || (delete g[h].data, P(g[h]))) && (f ? m.cleanData([a], !0) : k.deleteExpando || g != g.window ? delete g[h] : g[h] = null);
	      }
	    }
	  }m.extend({ cache: {}, noData: { "applet ": !0, "embed ": !0, "object ": "clsid:D27CDB6E-AE6D-11cf-96B8-444553540000" }, hasData: function hasData(a) {
	      return a = a.nodeType ? m.cache[a[m.expando]] : a[m.expando], !!a && !P(a);
	    }, data: function data(a, b, c) {
	      return Q(a, b, c);
	    }, removeData: function removeData(a, b) {
	      return R(a, b);
	    }, _data: function _data(a, b, c) {
	      return Q(a, b, c, !0);
	    }, _removeData: function _removeData(a, b) {
	      return R(a, b, !0);
	    } }), m.fn.extend({ data: function data(a, b) {
	      var c,
	          d,
	          e,
	          f = this[0],
	          g = f && f.attributes;if (void 0 === a) {
	        if (this.length && (e = m.data(f), 1 === f.nodeType && !m._data(f, "parsedAttrs"))) {
	          c = g.length;while (c--) {
	            g[c] && (d = g[c].name, 0 === d.indexOf("data-") && (d = m.camelCase(d.slice(5)), O(f, d, e[d])));
	          }m._data(f, "parsedAttrs", !0);
	        }return e;
	      }return "object" == (typeof a === "undefined" ? "undefined" : (0, _typeof3.default)(a)) ? this.each(function () {
	        m.data(this, a);
	      }) : arguments.length > 1 ? this.each(function () {
	        m.data(this, a, b);
	      }) : f ? O(f, a, m.data(f, a)) : void 0;
	    }, removeData: function removeData(a) {
	      return this.each(function () {
	        m.removeData(this, a);
	      });
	    } }), m.extend({ queue: function queue(a, b, c) {
	      var d;return a ? (b = (b || "fx") + "queue", d = m._data(a, b), c && (!d || m.isArray(c) ? d = m._data(a, b, m.makeArray(c)) : d.push(c)), d || []) : void 0;
	    }, dequeue: function dequeue(a, b) {
	      b = b || "fx";var c = m.queue(a, b),
	          d = c.length,
	          e = c.shift(),
	          f = m._queueHooks(a, b),
	          g = function g() {
	        m.dequeue(a, b);
	      };"inprogress" === e && (e = c.shift(), d--), e && ("fx" === b && c.unshift("inprogress"), delete f.stop, e.call(a, g, f)), !d && f && f.empty.fire();
	    }, _queueHooks: function _queueHooks(a, b) {
	      var c = b + "queueHooks";return m._data(a, c) || m._data(a, c, { empty: m.Callbacks("once memory").add(function () {
	          m._removeData(a, b + "queue"), m._removeData(a, c);
	        }) });
	    } }), m.fn.extend({ queue: function queue(a, b) {
	      var c = 2;return "string" != typeof a && (b = a, a = "fx", c--), arguments.length < c ? m.queue(this[0], a) : void 0 === b ? this : this.each(function () {
	        var c = m.queue(this, a, b);m._queueHooks(this, a), "fx" === a && "inprogress" !== c[0] && m.dequeue(this, a);
	      });
	    }, dequeue: function dequeue(a) {
	      return this.each(function () {
	        m.dequeue(this, a);
	      });
	    }, clearQueue: function clearQueue(a) {
	      return this.queue(a || "fx", []);
	    }, promise: function promise(a, b) {
	      var c,
	          d = 1,
	          e = m.Deferred(),
	          f = this,
	          g = this.length,
	          h = function h() {
	        --d || e.resolveWith(f, [f]);
	      };"string" != typeof a && (b = a, a = void 0), a = a || "fx";while (g--) {
	        c = m._data(f[g], a + "queueHooks"), c && c.empty && (d++, c.empty.add(h));
	      }return h(), e.promise(b);
	    } });var S = /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source,
	      T = ["Top", "Right", "Bottom", "Left"],
	      U = function U(a, b) {
	    return a = b || a, "none" === m.css(a, "display") || !m.contains(a.ownerDocument, a);
	  },
	      V = m.access = function (a, b, c, d, e, f, g) {
	    var h = 0,
	        i = a.length,
	        j = null == c;if ("object" === m.type(c)) {
	      e = !0;for (h in c) {
	        m.access(a, b, h, c[h], !0, f, g);
	      }
	    } else if (void 0 !== d && (e = !0, m.isFunction(d) || (g = !0), j && (g ? (b.call(a, d), b = null) : (j = b, b = function b(a, _b2, c) {
	      return j.call(m(a), c);
	    })), b)) for (; i > h; h++) {
	      b(a[h], c, g ? d : d.call(a[h], h, b(a[h], c)));
	    }return e ? a : j ? b.call(a) : i ? b(a[0], c) : f;
	  },
	      W = /^(?:checkbox|radio)$/i;!function () {
	    var a = y.createElement("input"),
	        b = y.createElement("div"),
	        c = y.createDocumentFragment();if (b.innerHTML = "  <link/><table></table><a href='/a'>a</a><input type='checkbox'/>", k.leadingWhitespace = 3 === b.firstChild.nodeType, k.tbody = !b.getElementsByTagName("tbody").length, k.htmlSerialize = !!b.getElementsByTagName("link").length, k.html5Clone = "<:nav></:nav>" !== y.createElement("nav").cloneNode(!0).outerHTML, a.type = "checkbox", a.checked = !0, c.appendChild(a), k.appendChecked = a.checked, b.innerHTML = "<textarea>x</textarea>", k.noCloneChecked = !!b.cloneNode(!0).lastChild.defaultValue, c.appendChild(b), b.innerHTML = "<input type='radio' checked='checked' name='t'/>", k.checkClone = b.cloneNode(!0).cloneNode(!0).lastChild.checked, k.noCloneEvent = !0, b.attachEvent && (b.attachEvent("onclick", function () {
	      k.noCloneEvent = !1;
	    }), b.cloneNode(!0).click()), null == k.deleteExpando) {
	      k.deleteExpando = !0;try {
	        delete b.test;
	      } catch (d) {
	        k.deleteExpando = !1;
	      }
	    }
	  }(), function () {
	    var b,
	        c,
	        d = y.createElement("div");for (b in { submit: !0, change: !0, focusin: !0 }) {
	      c = "on" + b, (k[b + "Bubbles"] = c in a) || (d.setAttribute(c, "t"), k[b + "Bubbles"] = d.attributes[c].expando === !1);
	    }d = null;
	  }();var X = /^(?:input|select|textarea)$/i,
	      Y = /^key/,
	      Z = /^(?:mouse|pointer|contextmenu)|click/,
	      $ = /^(?:focusinfocus|focusoutblur)$/,
	      _ = /^([^.]*)(?:\.(.+)|)$/;function aa() {
	    return !0;
	  }function ba() {
	    return !1;
	  }function ca() {
	    try {
	      return y.activeElement;
	    } catch (a) {}
	  }m.event = { global: {}, add: function add(a, b, c, d, e) {
	      var f,
	          g,
	          h,
	          i,
	          j,
	          k,
	          l,
	          n,
	          o,
	          p,
	          q,
	          r = m._data(a);if (r) {
	        c.handler && (i = c, c = i.handler, e = i.selector), c.guid || (c.guid = m.guid++), (g = r.events) || (g = r.events = {}), (k = r.handle) || (k = r.handle = function (a) {
	          return (typeof m === "undefined" ? "undefined" : (0, _typeof3.default)(m)) === K || a && m.event.triggered === a.type ? void 0 : m.event.dispatch.apply(k.elem, arguments);
	        }, k.elem = a), b = (b || "").match(E) || [""], h = b.length;while (h--) {
	          f = _.exec(b[h]) || [], o = q = f[1], p = (f[2] || "").split(".").sort(), o && (j = m.event.special[o] || {}, o = (e ? j.delegateType : j.bindType) || o, j = m.event.special[o] || {}, l = m.extend({ type: o, origType: q, data: d, handler: c, guid: c.guid, selector: e, needsContext: e && m.expr.match.needsContext.test(e), namespace: p.join(".") }, i), (n = g[o]) || (n = g[o] = [], n.delegateCount = 0, j.setup && j.setup.call(a, d, p, k) !== !1 || (a.addEventListener ? a.addEventListener(o, k, !1) : a.attachEvent && a.attachEvent("on" + o, k))), j.add && (j.add.call(a, l), l.handler.guid || (l.handler.guid = c.guid)), e ? n.splice(n.delegateCount++, 0, l) : n.push(l), m.event.global[o] = !0);
	        }a = null;
	      }
	    }, remove: function remove(a, b, c, d, e) {
	      var f,
	          g,
	          h,
	          i,
	          j,
	          k,
	          l,
	          n,
	          o,
	          p,
	          q,
	          r = m.hasData(a) && m._data(a);if (r && (k = r.events)) {
	        b = (b || "").match(E) || [""], j = b.length;while (j--) {
	          if (h = _.exec(b[j]) || [], o = q = h[1], p = (h[2] || "").split(".").sort(), o) {
	            l = m.event.special[o] || {}, o = (d ? l.delegateType : l.bindType) || o, n = k[o] || [], h = h[2] && new RegExp("(^|\\.)" + p.join("\\.(?:.*\\.|)") + "(\\.|$)"), i = f = n.length;while (f--) {
	              g = n[f], !e && q !== g.origType || c && c.guid !== g.guid || h && !h.test(g.namespace) || d && d !== g.selector && ("**" !== d || !g.selector) || (n.splice(f, 1), g.selector && n.delegateCount--, l.remove && l.remove.call(a, g));
	            }i && !n.length && (l.teardown && l.teardown.call(a, p, r.handle) !== !1 || m.removeEvent(a, o, r.handle), delete k[o]);
	          } else for (o in k) {
	            m.event.remove(a, o + b[j], c, d, !0);
	          }
	        }m.isEmptyObject(k) && (delete r.handle, m._removeData(a, "events"));
	      }
	    }, trigger: function trigger(b, c, d, e) {
	      var f,
	          g,
	          h,
	          i,
	          k,
	          l,
	          n,
	          o = [d || y],
	          p = j.call(b, "type") ? b.type : b,
	          q = j.call(b, "namespace") ? b.namespace.split(".") : [];if (h = l = d = d || y, 3 !== d.nodeType && 8 !== d.nodeType && !$.test(p + m.event.triggered) && (p.indexOf(".") >= 0 && (q = p.split("."), p = q.shift(), q.sort()), g = p.indexOf(":") < 0 && "on" + p, b = b[m.expando] ? b : new m.Event(p, "object" == (typeof b === "undefined" ? "undefined" : (0, _typeof3.default)(b)) && b), b.isTrigger = e ? 2 : 3, b.namespace = q.join("."), b.namespace_re = b.namespace ? new RegExp("(^|\\.)" + q.join("\\.(?:.*\\.|)") + "(\\.|$)") : null, b.result = void 0, b.target || (b.target = d), c = null == c ? [b] : m.makeArray(c, [b]), k = m.event.special[p] || {}, e || !k.trigger || k.trigger.apply(d, c) !== !1)) {
	        if (!e && !k.noBubble && !m.isWindow(d)) {
	          for (i = k.delegateType || p, $.test(i + p) || (h = h.parentNode); h; h = h.parentNode) {
	            o.push(h), l = h;
	          }l === (d.ownerDocument || y) && o.push(l.defaultView || l.parentWindow || a);
	        }n = 0;while ((h = o[n++]) && !b.isPropagationStopped()) {
	          b.type = n > 1 ? i : k.bindType || p, f = (m._data(h, "events") || {})[b.type] && m._data(h, "handle"), f && f.apply(h, c), f = g && h[g], f && f.apply && m.acceptData(h) && (b.result = f.apply(h, c), b.result === !1 && b.preventDefault());
	        }if (b.type = p, !e && !b.isDefaultPrevented() && (!k._default || k._default.apply(o.pop(), c) === !1) && m.acceptData(d) && g && d[p] && !m.isWindow(d)) {
	          l = d[g], l && (d[g] = null), m.event.triggered = p;try {
	            d[p]();
	          } catch (r) {}m.event.triggered = void 0, l && (d[g] = l);
	        }return b.result;
	      }
	    }, dispatch: function dispatch(a) {
	      a = m.event.fix(a);var b,
	          c,
	          e,
	          f,
	          g,
	          h = [],
	          i = d.call(arguments),
	          j = (m._data(this, "events") || {})[a.type] || [],
	          k = m.event.special[a.type] || {};if (i[0] = a, a.delegateTarget = this, !k.preDispatch || k.preDispatch.call(this, a) !== !1) {
	        h = m.event.handlers.call(this, a, j), b = 0;while ((f = h[b++]) && !a.isPropagationStopped()) {
	          a.currentTarget = f.elem, g = 0;while ((e = f.handlers[g++]) && !a.isImmediatePropagationStopped()) {
	            (!a.namespace_re || a.namespace_re.test(e.namespace)) && (a.handleObj = e, a.data = e.data, c = ((m.event.special[e.origType] || {}).handle || e.handler).apply(f.elem, i), void 0 !== c && (a.result = c) === !1 && (a.preventDefault(), a.stopPropagation()));
	          }
	        }return k.postDispatch && k.postDispatch.call(this, a), a.result;
	      }
	    }, handlers: function handlers(a, b) {
	      var c,
	          d,
	          e,
	          f,
	          g = [],
	          h = b.delegateCount,
	          i = a.target;if (h && i.nodeType && (!a.button || "click" !== a.type)) for (; i != this; i = i.parentNode || this) {
	        if (1 === i.nodeType && (i.disabled !== !0 || "click" !== a.type)) {
	          for (e = [], f = 0; h > f; f++) {
	            d = b[f], c = d.selector + " ", void 0 === e[c] && (e[c] = d.needsContext ? m(c, this).index(i) >= 0 : m.find(c, this, null, [i]).length), e[c] && e.push(d);
	          }e.length && g.push({ elem: i, handlers: e });
	        }
	      }return h < b.length && g.push({ elem: this, handlers: b.slice(h) }), g;
	    }, fix: function fix(a) {
	      if (a[m.expando]) return a;var b,
	          c,
	          d,
	          e = a.type,
	          f = a,
	          g = this.fixHooks[e];g || (this.fixHooks[e] = g = Z.test(e) ? this.mouseHooks : Y.test(e) ? this.keyHooks : {}), d = g.props ? this.props.concat(g.props) : this.props, a = new m.Event(f), b = d.length;while (b--) {
	        c = d[b], a[c] = f[c];
	      }return a.target || (a.target = f.srcElement || y), 3 === a.target.nodeType && (a.target = a.target.parentNode), a.metaKey = !!a.metaKey, g.filter ? g.filter(a, f) : a;
	    }, props: "altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which".split(" "), fixHooks: {}, keyHooks: { props: "char charCode key keyCode".split(" "), filter: function filter(a, b) {
	        return null == a.which && (a.which = null != b.charCode ? b.charCode : b.keyCode), a;
	      } }, mouseHooks: { props: "button buttons clientX clientY fromElement offsetX offsetY pageX pageY screenX screenY toElement".split(" "), filter: function filter(a, b) {
	        var c,
	            d,
	            e,
	            f = b.button,
	            g = b.fromElement;return null == a.pageX && null != b.clientX && (d = a.target.ownerDocument || y, e = d.documentElement, c = d.body, a.pageX = b.clientX + (e && e.scrollLeft || c && c.scrollLeft || 0) - (e && e.clientLeft || c && c.clientLeft || 0), a.pageY = b.clientY + (e && e.scrollTop || c && c.scrollTop || 0) - (e && e.clientTop || c && c.clientTop || 0)), !a.relatedTarget && g && (a.relatedTarget = g === a.target ? b.toElement : g), a.which || void 0 === f || (a.which = 1 & f ? 1 : 2 & f ? 3 : 4 & f ? 2 : 0), a;
	      } }, special: { load: { noBubble: !0 }, focus: { trigger: function trigger() {
	          if (this !== ca() && this.focus) try {
	            return this.focus(), !1;
	          } catch (a) {}
	        }, delegateType: "focusin" }, blur: { trigger: function trigger() {
	          return this === ca() && this.blur ? (this.blur(), !1) : void 0;
	        }, delegateType: "focusout" }, click: { trigger: function trigger() {
	          return m.nodeName(this, "input") && "checkbox" === this.type && this.click ? (this.click(), !1) : void 0;
	        }, _default: function _default(a) {
	          return m.nodeName(a.target, "a");
	        } }, beforeunload: { postDispatch: function postDispatch(a) {
	          void 0 !== a.result && a.originalEvent && (a.originalEvent.returnValue = a.result);
	        } } }, simulate: function simulate(a, b, c, d) {
	      var e = m.extend(new m.Event(), c, { type: a, isSimulated: !0, originalEvent: {} });d ? m.event.trigger(e, null, b) : m.event.dispatch.call(b, e), e.isDefaultPrevented() && c.preventDefault();
	    } }, m.removeEvent = y.removeEventListener ? function (a, b, c) {
	    a.removeEventListener && a.removeEventListener(b, c, !1);
	  } : function (a, b, c) {
	    var d = "on" + b;a.detachEvent && ((0, _typeof3.default)(a[d]) === K && (a[d] = null), a.detachEvent(d, c));
	  }, m.Event = function (a, b) {
	    return this instanceof m.Event ? (a && a.type ? (this.originalEvent = a, this.type = a.type, this.isDefaultPrevented = a.defaultPrevented || void 0 === a.defaultPrevented && a.returnValue === !1 ? aa : ba) : this.type = a, b && m.extend(this, b), this.timeStamp = a && a.timeStamp || m.now(), void (this[m.expando] = !0)) : new m.Event(a, b);
	  }, m.Event.prototype = { isDefaultPrevented: ba, isPropagationStopped: ba, isImmediatePropagationStopped: ba, preventDefault: function preventDefault() {
	      var a = this.originalEvent;this.isDefaultPrevented = aa, a && (a.preventDefault ? a.preventDefault() : a.returnValue = !1);
	    }, stopPropagation: function stopPropagation() {
	      var a = this.originalEvent;this.isPropagationStopped = aa, a && (a.stopPropagation && a.stopPropagation(), a.cancelBubble = !0);
	    }, stopImmediatePropagation: function stopImmediatePropagation() {
	      var a = this.originalEvent;this.isImmediatePropagationStopped = aa, a && a.stopImmediatePropagation && a.stopImmediatePropagation(), this.stopPropagation();
	    } }, m.each({ mouseenter: "mouseover", mouseleave: "mouseout", pointerenter: "pointerover", pointerleave: "pointerout" }, function (a, b) {
	    m.event.special[a] = { delegateType: b, bindType: b, handle: function handle(a) {
	        var c,
	            d = this,
	            e = a.relatedTarget,
	            f = a.handleObj;return (!e || e !== d && !m.contains(d, e)) && (a.type = f.origType, c = f.handler.apply(this, arguments), a.type = b), c;
	      } };
	  }), k.submitBubbles || (m.event.special.submit = { setup: function setup() {
	      return m.nodeName(this, "form") ? !1 : void m.event.add(this, "click._submit keypress._submit", function (a) {
	        var b = a.target,
	            c = m.nodeName(b, "input") || m.nodeName(b, "button") ? b.form : void 0;c && !m._data(c, "submitBubbles") && (m.event.add(c, "submit._submit", function (a) {
	          a._submit_bubble = !0;
	        }), m._data(c, "submitBubbles", !0));
	      });
	    }, postDispatch: function postDispatch(a) {
	      a._submit_bubble && (delete a._submit_bubble, this.parentNode && !a.isTrigger && m.event.simulate("submit", this.parentNode, a, !0));
	    }, teardown: function teardown() {
	      return m.nodeName(this, "form") ? !1 : void m.event.remove(this, "._submit");
	    } }), k.changeBubbles || (m.event.special.change = { setup: function setup() {
	      return X.test(this.nodeName) ? (("checkbox" === this.type || "radio" === this.type) && (m.event.add(this, "propertychange._change", function (a) {
	        "checked" === a.originalEvent.propertyName && (this._just_changed = !0);
	      }), m.event.add(this, "click._change", function (a) {
	        this._just_changed && !a.isTrigger && (this._just_changed = !1), m.event.simulate("change", this, a, !0);
	      })), !1) : void m.event.add(this, "beforeactivate._change", function (a) {
	        var b = a.target;X.test(b.nodeName) && !m._data(b, "changeBubbles") && (m.event.add(b, "change._change", function (a) {
	          !this.parentNode || a.isSimulated || a.isTrigger || m.event.simulate("change", this.parentNode, a, !0);
	        }), m._data(b, "changeBubbles", !0));
	      });
	    }, handle: function handle(a) {
	      var b = a.target;return this !== b || a.isSimulated || a.isTrigger || "radio" !== b.type && "checkbox" !== b.type ? a.handleObj.handler.apply(this, arguments) : void 0;
	    }, teardown: function teardown() {
	      return m.event.remove(this, "._change"), !X.test(this.nodeName);
	    } }), k.focusinBubbles || m.each({ focus: "focusin", blur: "focusout" }, function (a, b) {
	    var c = function c(a) {
	      m.event.simulate(b, a.target, m.event.fix(a), !0);
	    };m.event.special[b] = { setup: function setup() {
	        var d = this.ownerDocument || this,
	            e = m._data(d, b);e || d.addEventListener(a, c, !0), m._data(d, b, (e || 0) + 1);
	      }, teardown: function teardown() {
	        var d = this.ownerDocument || this,
	            e = m._data(d, b) - 1;e ? m._data(d, b, e) : (d.removeEventListener(a, c, !0), m._removeData(d, b));
	      } };
	  }), m.fn.extend({ on: function on(a, b, c, d, e) {
	      var f, g;if ("object" == (typeof a === "undefined" ? "undefined" : (0, _typeof3.default)(a))) {
	        "string" != typeof b && (c = c || b, b = void 0);for (f in a) {
	          this.on(f, b, c, a[f], e);
	        }return this;
	      }if (null == c && null == d ? (d = b, c = b = void 0) : null == d && ("string" == typeof b ? (d = c, c = void 0) : (d = c, c = b, b = void 0)), d === !1) d = ba;else if (!d) return this;return 1 === e && (g = d, d = function d(a) {
	        return m().off(a), g.apply(this, arguments);
	      }, d.guid = g.guid || (g.guid = m.guid++)), this.each(function () {
	        m.event.add(this, a, d, c, b);
	      });
	    }, one: function one(a, b, c, d) {
	      return this.on(a, b, c, d, 1);
	    }, off: function off(a, b, c) {
	      var d, e;if (a && a.preventDefault && a.handleObj) return d = a.handleObj, m(a.delegateTarget).off(d.namespace ? d.origType + "." + d.namespace : d.origType, d.selector, d.handler), this;if ("object" == (typeof a === "undefined" ? "undefined" : (0, _typeof3.default)(a))) {
	        for (e in a) {
	          this.off(e, b, a[e]);
	        }return this;
	      }return (b === !1 || "function" == typeof b) && (c = b, b = void 0), c === !1 && (c = ba), this.each(function () {
	        m.event.remove(this, a, c, b);
	      });
	    }, trigger: function trigger(a, b) {
	      return this.each(function () {
	        m.event.trigger(a, b, this);
	      });
	    }, triggerHandler: function triggerHandler(a, b) {
	      var c = this[0];return c ? m.event.trigger(a, b, c, !0) : void 0;
	    } });function da(a) {
	    var b = ea.split("|"),
	        c = a.createDocumentFragment();if (c.createElement) while (b.length) {
	      c.createElement(b.pop());
	    }return c;
	  }var ea = "abbr|article|aside|audio|bdi|canvas|data|datalist|details|figcaption|figure|footer|header|hgroup|mark|meter|nav|output|progress|section|summary|time|video",
	      fa = / jQuery\d+="(?:null|\d+)"/g,
	      ga = new RegExp("<(?:" + ea + ")[\\s/>]", "i"),
	      ha = /^\s+/,
	      ia = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/gi,
	      ja = /<([\w:]+)/,
	      ka = /<tbody/i,
	      la = /<|&#?\w+;/,
	      ma = /<(?:script|style|link)/i,
	      na = /checked\s*(?:[^=]|=\s*.checked.)/i,
	      oa = /^$|\/(?:java|ecma)script/i,
	      pa = /^true\/(.*)/,
	      qa = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g,
	      ra = { option: [1, "<select multiple='multiple'>", "</select>"], legend: [1, "<fieldset>", "</fieldset>"], area: [1, "<map>", "</map>"], param: [1, "<object>", "</object>"], thead: [1, "<table>", "</table>"], tr: [2, "<table><tbody>", "</tbody></table>"], col: [2, "<table><tbody></tbody><colgroup>", "</colgroup></table>"], td: [3, "<table><tbody><tr>", "</tr></tbody></table>"], _default: k.htmlSerialize ? [0, "", ""] : [1, "X<div>", "</div>"] },
	      sa = da(y),
	      ta = sa.appendChild(y.createElement("div"));ra.optgroup = ra.option, ra.tbody = ra.tfoot = ra.colgroup = ra.caption = ra.thead, ra.th = ra.td;function ua(a, b) {
	    var c,
	        d,
	        e = 0,
	        f = (0, _typeof3.default)(a.getElementsByTagName) !== K ? a.getElementsByTagName(b || "*") : (0, _typeof3.default)(a.querySelectorAll) !== K ? a.querySelectorAll(b || "*") : void 0;if (!f) for (f = [], c = a.childNodes || a; null != (d = c[e]); e++) {
	      !b || m.nodeName(d, b) ? f.push(d) : m.merge(f, ua(d, b));
	    }return void 0 === b || b && m.nodeName(a, b) ? m.merge([a], f) : f;
	  }function va(a) {
	    W.test(a.type) && (a.defaultChecked = a.checked);
	  }function wa(a, b) {
	    return m.nodeName(a, "table") && m.nodeName(11 !== b.nodeType ? b : b.firstChild, "tr") ? a.getElementsByTagName("tbody")[0] || a.appendChild(a.ownerDocument.createElement("tbody")) : a;
	  }function xa(a) {
	    return a.type = (null !== m.find.attr(a, "type")) + "/" + a.type, a;
	  }function ya(a) {
	    var b = pa.exec(a.type);return b ? a.type = b[1] : a.removeAttribute("type"), a;
	  }function za(a, b) {
	    for (var c, d = 0; null != (c = a[d]); d++) {
	      m._data(c, "globalEval", !b || m._data(b[d], "globalEval"));
	    }
	  }function Aa(a, b) {
	    if (1 === b.nodeType && m.hasData(a)) {
	      var c,
	          d,
	          e,
	          f = m._data(a),
	          g = m._data(b, f),
	          h = f.events;if (h) {
	        delete g.handle, g.events = {};for (c in h) {
	          for (d = 0, e = h[c].length; e > d; d++) {
	            m.event.add(b, c, h[c][d]);
	          }
	        }
	      }g.data && (g.data = m.extend({}, g.data));
	    }
	  }function Ba(a, b) {
	    var c, d, e;if (1 === b.nodeType) {
	      if (c = b.nodeName.toLowerCase(), !k.noCloneEvent && b[m.expando]) {
	        e = m._data(b);for (d in e.events) {
	          m.removeEvent(b, d, e.handle);
	        }b.removeAttribute(m.expando);
	      }"script" === c && b.text !== a.text ? (xa(b).text = a.text, ya(b)) : "object" === c ? (b.parentNode && (b.outerHTML = a.outerHTML), k.html5Clone && a.innerHTML && !m.trim(b.innerHTML) && (b.innerHTML = a.innerHTML)) : "input" === c && W.test(a.type) ? (b.defaultChecked = b.checked = a.checked, b.value !== a.value && (b.value = a.value)) : "option" === c ? b.defaultSelected = b.selected = a.defaultSelected : ("input" === c || "textarea" === c) && (b.defaultValue = a.defaultValue);
	    }
	  }m.extend({ clone: function clone(a, b, c) {
	      var d,
	          e,
	          f,
	          g,
	          h,
	          i = m.contains(a.ownerDocument, a);if (k.html5Clone || m.isXMLDoc(a) || !ga.test("<" + a.nodeName + ">") ? f = a.cloneNode(!0) : (ta.innerHTML = a.outerHTML, ta.removeChild(f = ta.firstChild)), !(k.noCloneEvent && k.noCloneChecked || 1 !== a.nodeType && 11 !== a.nodeType || m.isXMLDoc(a))) for (d = ua(f), h = ua(a), g = 0; null != (e = h[g]); ++g) {
	        d[g] && Ba(e, d[g]);
	      }if (b) if (c) for (h = h || ua(a), d = d || ua(f), g = 0; null != (e = h[g]); g++) {
	        Aa(e, d[g]);
	      } else Aa(a, f);return d = ua(f, "script"), d.length > 0 && za(d, !i && ua(a, "script")), d = h = e = null, f;
	    }, buildFragment: function buildFragment(a, b, c, d) {
	      for (var e, f, g, h, i, j, l, n = a.length, o = da(b), p = [], q = 0; n > q; q++) {
	        if (f = a[q], f || 0 === f) if ("object" === m.type(f)) m.merge(p, f.nodeType ? [f] : f);else if (la.test(f)) {
	          h = h || o.appendChild(b.createElement("div")), i = (ja.exec(f) || ["", ""])[1].toLowerCase(), l = ra[i] || ra._default, h.innerHTML = l[1] + f.replace(ia, "<$1></$2>") + l[2], e = l[0];while (e--) {
	            h = h.lastChild;
	          }if (!k.leadingWhitespace && ha.test(f) && p.push(b.createTextNode(ha.exec(f)[0])), !k.tbody) {
	            f = "table" !== i || ka.test(f) ? "<table>" !== l[1] || ka.test(f) ? 0 : h : h.firstChild, e = f && f.childNodes.length;while (e--) {
	              m.nodeName(j = f.childNodes[e], "tbody") && !j.childNodes.length && f.removeChild(j);
	            }
	          }m.merge(p, h.childNodes), h.textContent = "";while (h.firstChild) {
	            h.removeChild(h.firstChild);
	          }h = o.lastChild;
	        } else p.push(b.createTextNode(f));
	      }h && o.removeChild(h), k.appendChecked || m.grep(ua(p, "input"), va), q = 0;while (f = p[q++]) {
	        if ((!d || -1 === m.inArray(f, d)) && (g = m.contains(f.ownerDocument, f), h = ua(o.appendChild(f), "script"), g && za(h), c)) {
	          e = 0;while (f = h[e++]) {
	            oa.test(f.type || "") && c.push(f);
	          }
	        }
	      }return h = null, o;
	    }, cleanData: function cleanData(a, b) {
	      for (var d, e, f, g, h = 0, i = m.expando, j = m.cache, l = k.deleteExpando, n = m.event.special; null != (d = a[h]); h++) {
	        if ((b || m.acceptData(d)) && (f = d[i], g = f && j[f])) {
	          if (g.events) for (e in g.events) {
	            n[e] ? m.event.remove(d, e) : m.removeEvent(d, e, g.handle);
	          }j[f] && (delete j[f], l ? delete d[i] : (0, _typeof3.default)(d.removeAttribute) !== K ? d.removeAttribute(i) : d[i] = null, c.push(f));
	        }
	      }
	    } }), m.fn.extend({ text: function text(a) {
	      return V(this, function (a) {
	        return void 0 === a ? m.text(this) : this.empty().append((this[0] && this[0].ownerDocument || y).createTextNode(a));
	      }, null, a, arguments.length);
	    }, append: function append() {
	      return this.domManip(arguments, function (a) {
	        if (1 === this.nodeType || 11 === this.nodeType || 9 === this.nodeType) {
	          var b = wa(this, a);b.appendChild(a);
	        }
	      });
	    }, prepend: function prepend() {
	      return this.domManip(arguments, function (a) {
	        if (1 === this.nodeType || 11 === this.nodeType || 9 === this.nodeType) {
	          var b = wa(this, a);b.insertBefore(a, b.firstChild);
	        }
	      });
	    }, before: function before() {
	      return this.domManip(arguments, function (a) {
	        this.parentNode && this.parentNode.insertBefore(a, this);
	      });
	    }, after: function after() {
	      return this.domManip(arguments, function (a) {
	        this.parentNode && this.parentNode.insertBefore(a, this.nextSibling);
	      });
	    }, remove: function remove(a, b) {
	      for (var c, d = a ? m.filter(a, this) : this, e = 0; null != (c = d[e]); e++) {
	        b || 1 !== c.nodeType || m.cleanData(ua(c)), c.parentNode && (b && m.contains(c.ownerDocument, c) && za(ua(c, "script")), c.parentNode.removeChild(c));
	      }return this;
	    }, empty: function empty() {
	      for (var a, b = 0; null != (a = this[b]); b++) {
	        1 === a.nodeType && m.cleanData(ua(a, !1));while (a.firstChild) {
	          a.removeChild(a.firstChild);
	        }a.options && m.nodeName(a, "select") && (a.options.length = 0);
	      }return this;
	    }, clone: function clone(a, b) {
	      return a = null == a ? !1 : a, b = null == b ? a : b, this.map(function () {
	        return m.clone(this, a, b);
	      });
	    }, html: function html(a) {
	      return V(this, function (a) {
	        var b = this[0] || {},
	            c = 0,
	            d = this.length;if (void 0 === a) return 1 === b.nodeType ? b.innerHTML.replace(fa, "") : void 0;if (!("string" != typeof a || ma.test(a) || !k.htmlSerialize && ga.test(a) || !k.leadingWhitespace && ha.test(a) || ra[(ja.exec(a) || ["", ""])[1].toLowerCase()])) {
	          a = a.replace(ia, "<$1></$2>");try {
	            for (; d > c; c++) {
	              b = this[c] || {}, 1 === b.nodeType && (m.cleanData(ua(b, !1)), b.innerHTML = a);
	            }b = 0;
	          } catch (e) {}
	        }b && this.empty().append(a);
	      }, null, a, arguments.length);
	    }, replaceWith: function replaceWith() {
	      var a = arguments[0];return this.domManip(arguments, function (b) {
	        a = this.parentNode, m.cleanData(ua(this)), a && a.replaceChild(b, this);
	      }), a && (a.length || a.nodeType) ? this : this.remove();
	    }, detach: function detach(a) {
	      return this.remove(a, !0);
	    }, domManip: function domManip(a, b) {
	      a = e.apply([], a);var c,
	          d,
	          f,
	          g,
	          h,
	          i,
	          j = 0,
	          l = this.length,
	          n = this,
	          o = l - 1,
	          p = a[0],
	          q = m.isFunction(p);if (q || l > 1 && "string" == typeof p && !k.checkClone && na.test(p)) return this.each(function (c) {
	        var d = n.eq(c);q && (a[0] = p.call(this, c, d.html())), d.domManip(a, b);
	      });if (l && (i = m.buildFragment(a, this[0].ownerDocument, !1, this), c = i.firstChild, 1 === i.childNodes.length && (i = c), c)) {
	        for (g = m.map(ua(i, "script"), xa), f = g.length; l > j; j++) {
	          d = i, j !== o && (d = m.clone(d, !0, !0), f && m.merge(g, ua(d, "script"))), b.call(this[j], d, j);
	        }if (f) for (h = g[g.length - 1].ownerDocument, m.map(g, ya), j = 0; f > j; j++) {
	          d = g[j], oa.test(d.type || "") && !m._data(d, "globalEval") && m.contains(h, d) && (d.src ? m._evalUrl && m._evalUrl(d.src) : m.globalEval((d.text || d.textContent || d.innerHTML || "").replace(qa, "")));
	        }i = c = null;
	      }return this;
	    } }), m.each({ appendTo: "append", prependTo: "prepend", insertBefore: "before", insertAfter: "after", replaceAll: "replaceWith" }, function (a, b) {
	    m.fn[a] = function (a) {
	      for (var c, d = 0, e = [], g = m(a), h = g.length - 1; h >= d; d++) {
	        c = d === h ? this : this.clone(!0), m(g[d])[b](c), f.apply(e, c.get());
	      }return this.pushStack(e);
	    };
	  });var Ca,
	      Da = {};function Ea(b, c) {
	    var d,
	        e = m(c.createElement(b)).appendTo(c.body),
	        f = a.getDefaultComputedStyle && (d = a.getDefaultComputedStyle(e[0])) ? d.display : m.css(e[0], "display");return e.detach(), f;
	  }function Fa(a) {
	    var b = y,
	        c = Da[a];return c || (c = Ea(a, b), "none" !== c && c || (Ca = (Ca || m("<iframe frameborder='0' width='0' height='0'/>")).appendTo(b.documentElement), b = (Ca[0].contentWindow || Ca[0].contentDocument).document, b.write(), b.close(), c = Ea(a, b), Ca.detach()), Da[a] = c), c;
	  }!function () {
	    var a;k.shrinkWrapBlocks = function () {
	      if (null != a) return a;a = !1;var b, c, d;return c = y.getElementsByTagName("body")[0], c && c.style ? (b = y.createElement("div"), d = y.createElement("div"), d.style.cssText = "position:absolute;border:0;width:0;height:0;top:0;left:-9999px", c.appendChild(d).appendChild(b), (0, _typeof3.default)(b.style.zoom) !== K && (b.style.cssText = "-webkit-box-sizing:content-box;-moz-box-sizing:content-box;box-sizing:content-box;display:block;margin:0;border:0;padding:1px;width:1px;zoom:1", b.appendChild(y.createElement("div")).style.width = "5px", a = 3 !== b.offsetWidth), c.removeChild(d), a) : void 0;
	    };
	  }();var Ga = /^margin/,
	      Ha = new RegExp("^(" + S + ")(?!px)[a-z%]+$", "i"),
	      Ia,
	      Ja,
	      Ka = /^(top|right|bottom|left)$/;a.getComputedStyle ? (Ia = function Ia(b) {
	    return b.ownerDocument.defaultView.opener ? b.ownerDocument.defaultView.getComputedStyle(b, null) : a.getComputedStyle(b, null);
	  }, Ja = function Ja(a, b, c) {
	    var d,
	        e,
	        f,
	        g,
	        h = a.style;return c = c || Ia(a), g = c ? c.getPropertyValue(b) || c[b] : void 0, c && ("" !== g || m.contains(a.ownerDocument, a) || (g = m.style(a, b)), Ha.test(g) && Ga.test(b) && (d = h.width, e = h.minWidth, f = h.maxWidth, h.minWidth = h.maxWidth = h.width = g, g = c.width, h.width = d, h.minWidth = e, h.maxWidth = f)), void 0 === g ? g : g + "";
	  }) : y.documentElement.currentStyle && (Ia = function Ia(a) {
	    return a.currentStyle;
	  }, Ja = function Ja(a, b, c) {
	    var d,
	        e,
	        f,
	        g,
	        h = a.style;return c = c || Ia(a), g = c ? c[b] : void 0, null == g && h && h[b] && (g = h[b]), Ha.test(g) && !Ka.test(b) && (d = h.left, e = a.runtimeStyle, f = e && e.left, f && (e.left = a.currentStyle.left), h.left = "fontSize" === b ? "1em" : g, g = h.pixelLeft + "px", h.left = d, f && (e.left = f)), void 0 === g ? g : g + "" || "auto";
	  });function La(a, b) {
	    return { get: function get() {
	        var c = a();if (null != c) return c ? void delete this.get : (this.get = b).apply(this, arguments);
	      } };
	  }!function () {
	    var b, c, d, e, f, g, h;if (b = y.createElement("div"), b.innerHTML = "  <link/><table></table><a href='/a'>a</a><input type='checkbox'/>", d = b.getElementsByTagName("a")[0], c = d && d.style) {
	      (function () {
	        var i = function i() {
	          var b, c, d, i;c = y.getElementsByTagName("body")[0], c && c.style && (b = y.createElement("div"), d = y.createElement("div"), d.style.cssText = "position:absolute;border:0;width:0;height:0;top:0;left:-9999px", c.appendChild(d).appendChild(b), b.style.cssText = "-webkit-box-sizing:border-box;-moz-box-sizing:border-box;box-sizing:border-box;display:block;margin-top:1%;top:1%;border:1px;padding:1px;width:4px;position:absolute", e = f = !1, h = !0, a.getComputedStyle && (e = "1%" !== (a.getComputedStyle(b, null) || {}).top, f = "4px" === (a.getComputedStyle(b, null) || { width: "4px" }).width, i = b.appendChild(y.createElement("div")), i.style.cssText = b.style.cssText = "-webkit-box-sizing:content-box;-moz-box-sizing:content-box;box-sizing:content-box;display:block;margin:0;border:0;padding:0", i.style.marginRight = i.style.width = "0", b.style.width = "1px", h = !parseFloat((a.getComputedStyle(i, null) || {}).marginRight), b.removeChild(i)), b.innerHTML = "<table><tr><td></td><td>t</td></tr></table>", i = b.getElementsByTagName("td"), i[0].style.cssText = "margin:0;border:0;padding:0;display:none", g = 0 === i[0].offsetHeight, g && (i[0].style.display = "", i[1].style.display = "none", g = 0 === i[0].offsetHeight), c.removeChild(d));
	        };
	
	        c.cssText = "float:left;opacity:.5", k.opacity = "0.5" === c.opacity, k.cssFloat = !!c.cssFloat, b.style.backgroundClip = "content-box", b.cloneNode(!0).style.backgroundClip = "", k.clearCloneStyle = "content-box" === b.style.backgroundClip, k.boxSizing = "" === c.boxSizing || "" === c.MozBoxSizing || "" === c.WebkitBoxSizing, m.extend(k, { reliableHiddenOffsets: function reliableHiddenOffsets() {
	            return null == g && i(), g;
	          }, boxSizingReliable: function boxSizingReliable() {
	            return null == f && i(), f;
	          }, pixelPosition: function pixelPosition() {
	            return null == e && i(), e;
	          }, reliableMarginRight: function reliableMarginRight() {
	            return null == h && i(), h;
	          } });
	      })();
	    }
	  }(), m.swap = function (a, b, c, d) {
	    var e,
	        f,
	        g = {};for (f in b) {
	      g[f] = a.style[f], a.style[f] = b[f];
	    }e = c.apply(a, d || []);for (f in b) {
	      a.style[f] = g[f];
	    }return e;
	  };var Ma = /alpha\([^)]*\)/i,
	      Na = /opacity\s*=\s*([^)]*)/,
	      Oa = /^(none|table(?!-c[ea]).+)/,
	      Pa = new RegExp("^(" + S + ")(.*)$", "i"),
	      Qa = new RegExp("^([+-])=(" + S + ")", "i"),
	      Ra = { position: "absolute", visibility: "hidden", display: "block" },
	      Sa = { letterSpacing: "0", fontWeight: "400" },
	      Ta = ["Webkit", "O", "Moz", "ms"];function Ua(a, b) {
	    if (b in a) return b;var c = b.charAt(0).toUpperCase() + b.slice(1),
	        d = b,
	        e = Ta.length;while (e--) {
	      if (b = Ta[e] + c, b in a) return b;
	    }return d;
	  }function Va(a, b) {
	    for (var c, d, e, f = [], g = 0, h = a.length; h > g; g++) {
	      d = a[g], d.style && (f[g] = m._data(d, "olddisplay"), c = d.style.display, b ? (f[g] || "none" !== c || (d.style.display = ""), "" === d.style.display && U(d) && (f[g] = m._data(d, "olddisplay", Fa(d.nodeName)))) : (e = U(d), (c && "none" !== c || !e) && m._data(d, "olddisplay", e ? c : m.css(d, "display"))));
	    }for (g = 0; h > g; g++) {
	      d = a[g], d.style && (b && "none" !== d.style.display && "" !== d.style.display || (d.style.display = b ? f[g] || "" : "none"));
	    }return a;
	  }function Wa(a, b, c) {
	    var d = Pa.exec(b);return d ? Math.max(0, d[1] - (c || 0)) + (d[2] || "px") : b;
	  }function Xa(a, b, c, d, e) {
	    for (var f = c === (d ? "border" : "content") ? 4 : "width" === b ? 1 : 0, g = 0; 4 > f; f += 2) {
	      "margin" === c && (g += m.css(a, c + T[f], !0, e)), d ? ("content" === c && (g -= m.css(a, "padding" + T[f], !0, e)), "margin" !== c && (g -= m.css(a, "border" + T[f] + "Width", !0, e))) : (g += m.css(a, "padding" + T[f], !0, e), "padding" !== c && (g += m.css(a, "border" + T[f] + "Width", !0, e)));
	    }return g;
	  }function Ya(a, b, c) {
	    var d = !0,
	        e = "width" === b ? a.offsetWidth : a.offsetHeight,
	        f = Ia(a),
	        g = k.boxSizing && "border-box" === m.css(a, "boxSizing", !1, f);if (0 >= e || null == e) {
	      if (e = Ja(a, b, f), (0 > e || null == e) && (e = a.style[b]), Ha.test(e)) return e;d = g && (k.boxSizingReliable() || e === a.style[b]), e = parseFloat(e) || 0;
	    }return e + Xa(a, b, c || (g ? "border" : "content"), d, f) + "px";
	  }m.extend({ cssHooks: { opacity: { get: function get(a, b) {
	          if (b) {
	            var c = Ja(a, "opacity");return "" === c ? "1" : c;
	          }
	        } } }, cssNumber: { columnCount: !0, fillOpacity: !0, flexGrow: !0, flexShrink: !0, fontWeight: !0, lineHeight: !0, opacity: !0, order: !0, orphans: !0, widows: !0, zIndex: !0, zoom: !0 }, cssProps: { "float": k.cssFloat ? "cssFloat" : "styleFloat" }, style: function style(a, b, c, d) {
	      if (a && 3 !== a.nodeType && 8 !== a.nodeType && a.style) {
	        var e,
	            f,
	            g,
	            h = m.camelCase(b),
	            i = a.style;if (b = m.cssProps[h] || (m.cssProps[h] = Ua(i, h)), g = m.cssHooks[b] || m.cssHooks[h], void 0 === c) return g && "get" in g && void 0 !== (e = g.get(a, !1, d)) ? e : i[b];if (f = typeof c === "undefined" ? "undefined" : (0, _typeof3.default)(c), "string" === f && (e = Qa.exec(c)) && (c = (e[1] + 1) * e[2] + parseFloat(m.css(a, b)), f = "number"), null != c && c === c && ("number" !== f || m.cssNumber[h] || (c += "px"), k.clearCloneStyle || "" !== c || 0 !== b.indexOf("background") || (i[b] = "inherit"), !(g && "set" in g && void 0 === (c = g.set(a, c, d))))) try {
	          i[b] = c;
	        } catch (j) {}
	      }
	    }, css: function css(a, b, c, d) {
	      var e,
	          f,
	          g,
	          h = m.camelCase(b);return b = m.cssProps[h] || (m.cssProps[h] = Ua(a.style, h)), g = m.cssHooks[b] || m.cssHooks[h], g && "get" in g && (f = g.get(a, !0, c)), void 0 === f && (f = Ja(a, b, d)), "normal" === f && b in Sa && (f = Sa[b]), "" === c || c ? (e = parseFloat(f), c === !0 || m.isNumeric(e) ? e || 0 : f) : f;
	    } }), m.each(["height", "width"], function (a, b) {
	    m.cssHooks[b] = { get: function get(a, c, d) {
	        return c ? Oa.test(m.css(a, "display")) && 0 === a.offsetWidth ? m.swap(a, Ra, function () {
	          return Ya(a, b, d);
	        }) : Ya(a, b, d) : void 0;
	      }, set: function set(a, c, d) {
	        var e = d && Ia(a);return Wa(a, c, d ? Xa(a, b, d, k.boxSizing && "border-box" === m.css(a, "boxSizing", !1, e), e) : 0);
	      } };
	  }), k.opacity || (m.cssHooks.opacity = { get: function get(a, b) {
	      return Na.test((b && a.currentStyle ? a.currentStyle.filter : a.style.filter) || "") ? .01 * parseFloat(RegExp.$1) + "" : b ? "1" : "";
	    }, set: function set(a, b) {
	      var c = a.style,
	          d = a.currentStyle,
	          e = m.isNumeric(b) ? "alpha(opacity=" + 100 * b + ")" : "",
	          f = d && d.filter || c.filter || "";c.zoom = 1, (b >= 1 || "" === b) && "" === m.trim(f.replace(Ma, "")) && c.removeAttribute && (c.removeAttribute("filter"), "" === b || d && !d.filter) || (c.filter = Ma.test(f) ? f.replace(Ma, e) : f + " " + e);
	    } }), m.cssHooks.marginRight = La(k.reliableMarginRight, function (a, b) {
	    return b ? m.swap(a, { display: "inline-block" }, Ja, [a, "marginRight"]) : void 0;
	  }), m.each({ margin: "", padding: "", border: "Width" }, function (a, b) {
	    m.cssHooks[a + b] = { expand: function expand(c) {
	        for (var d = 0, e = {}, f = "string" == typeof c ? c.split(" ") : [c]; 4 > d; d++) {
	          e[a + T[d] + b] = f[d] || f[d - 2] || f[0];
	        }return e;
	      } }, Ga.test(a) || (m.cssHooks[a + b].set = Wa);
	  }), m.fn.extend({ css: function css(a, b) {
	      return V(this, function (a, b, c) {
	        var d,
	            e,
	            f = {},
	            g = 0;if (m.isArray(b)) {
	          for (d = Ia(a), e = b.length; e > g; g++) {
	            f[b[g]] = m.css(a, b[g], !1, d);
	          }return f;
	        }return void 0 !== c ? m.style(a, b, c) : m.css(a, b);
	      }, a, b, arguments.length > 1);
	    }, show: function show() {
	      return Va(this, !0);
	    }, hide: function hide() {
	      return Va(this);
	    }, toggle: function toggle(a) {
	      return "boolean" == typeof a ? a ? this.show() : this.hide() : this.each(function () {
	        U(this) ? m(this).show() : m(this).hide();
	      });
	    } });function Za(a, b, c, d, e) {
	    return new Za.prototype.init(a, b, c, d, e);
	  }m.Tween = Za, Za.prototype = { constructor: Za, init: function init(a, b, c, d, e, f) {
	      this.elem = a, this.prop = c, this.easing = e || "swing", this.options = b, this.start = this.now = this.cur(), this.end = d, this.unit = f || (m.cssNumber[c] ? "" : "px");
	    }, cur: function cur() {
	      var a = Za.propHooks[this.prop];return a && a.get ? a.get(this) : Za.propHooks._default.get(this);
	    }, run: function run(a) {
	      var b,
	          c = Za.propHooks[this.prop];return this.options.duration ? this.pos = b = m.easing[this.easing](a, this.options.duration * a, 0, 1, this.options.duration) : this.pos = b = a, this.now = (this.end - this.start) * b + this.start, this.options.step && this.options.step.call(this.elem, this.now, this), c && c.set ? c.set(this) : Za.propHooks._default.set(this), this;
	    } }, Za.prototype.init.prototype = Za.prototype, Za.propHooks = { _default: { get: function get(a) {
	        var b;return null == a.elem[a.prop] || a.elem.style && null != a.elem.style[a.prop] ? (b = m.css(a.elem, a.prop, ""), b && "auto" !== b ? b : 0) : a.elem[a.prop];
	      }, set: function set(a) {
	        m.fx.step[a.prop] ? m.fx.step[a.prop](a) : a.elem.style && (null != a.elem.style[m.cssProps[a.prop]] || m.cssHooks[a.prop]) ? m.style(a.elem, a.prop, a.now + a.unit) : a.elem[a.prop] = a.now;
	      } } }, Za.propHooks.scrollTop = Za.propHooks.scrollLeft = { set: function set(a) {
	      a.elem.nodeType && a.elem.parentNode && (a.elem[a.prop] = a.now);
	    } }, m.easing = { linear: function linear(a) {
	      return a;
	    }, swing: function swing(a) {
	      return .5 - Math.cos(a * Math.PI) / 2;
	    } }, m.fx = Za.prototype.init, m.fx.step = {};var $a,
	      _a,
	      ab = /^(?:toggle|show|hide)$/,
	      bb = new RegExp("^(?:([+-])=|)(" + S + ")([a-z%]*)$", "i"),
	      cb = /queueHooks$/,
	      db = [ib],
	      eb = { "*": [function (a, b) {
	      var c = this.createTween(a, b),
	          d = c.cur(),
	          e = bb.exec(b),
	          f = e && e[3] || (m.cssNumber[a] ? "" : "px"),
	          g = (m.cssNumber[a] || "px" !== f && +d) && bb.exec(m.css(c.elem, a)),
	          h = 1,
	          i = 20;if (g && g[3] !== f) {
	        f = f || g[3], e = e || [], g = +d || 1;do {
	          h = h || ".5", g /= h, m.style(c.elem, a, g + f);
	        } while (h !== (h = c.cur() / d) && 1 !== h && --i);
	      }return e && (g = c.start = +g || +d || 0, c.unit = f, c.end = e[1] ? g + (e[1] + 1) * e[2] : +e[2]), c;
	    }] };function fb() {
	    return setTimeout(function () {
	      $a = void 0;
	    }), $a = m.now();
	  }function gb(a, b) {
	    var c,
	        d = { height: a },
	        e = 0;for (b = b ? 1 : 0; 4 > e; e += 2 - b) {
	      c = T[e], d["margin" + c] = d["padding" + c] = a;
	    }return b && (d.opacity = d.width = a), d;
	  }function hb(a, b, c) {
	    for (var d, e = (eb[b] || []).concat(eb["*"]), f = 0, g = e.length; g > f; f++) {
	      if (d = e[f].call(c, b, a)) return d;
	    }
	  }function ib(a, b, c) {
	    var d,
	        e,
	        f,
	        g,
	        h,
	        i,
	        j,
	        l,
	        n = this,
	        o = {},
	        p = a.style,
	        q = a.nodeType && U(a),
	        r = m._data(a, "fxshow");c.queue || (h = m._queueHooks(a, "fx"), null == h.unqueued && (h.unqueued = 0, i = h.empty.fire, h.empty.fire = function () {
	      h.unqueued || i();
	    }), h.unqueued++, n.always(function () {
	      n.always(function () {
	        h.unqueued--, m.queue(a, "fx").length || h.empty.fire();
	      });
	    })), 1 === a.nodeType && ("height" in b || "width" in b) && (c.overflow = [p.overflow, p.overflowX, p.overflowY], j = m.css(a, "display"), l = "none" === j ? m._data(a, "olddisplay") || Fa(a.nodeName) : j, "inline" === l && "none" === m.css(a, "float") && (k.inlineBlockNeedsLayout && "inline" !== Fa(a.nodeName) ? p.zoom = 1 : p.display = "inline-block")), c.overflow && (p.overflow = "hidden", k.shrinkWrapBlocks() || n.always(function () {
	      p.overflow = c.overflow[0], p.overflowX = c.overflow[1], p.overflowY = c.overflow[2];
	    }));for (d in b) {
	      if (e = b[d], ab.exec(e)) {
	        if (delete b[d], f = f || "toggle" === e, e === (q ? "hide" : "show")) {
	          if ("show" !== e || !r || void 0 === r[d]) continue;q = !0;
	        }o[d] = r && r[d] || m.style(a, d);
	      } else j = void 0;
	    }if (m.isEmptyObject(o)) "inline" === ("none" === j ? Fa(a.nodeName) : j) && (p.display = j);else {
	      r ? "hidden" in r && (q = r.hidden) : r = m._data(a, "fxshow", {}), f && (r.hidden = !q), q ? m(a).show() : n.done(function () {
	        m(a).hide();
	      }), n.done(function () {
	        var b;m._removeData(a, "fxshow");for (b in o) {
	          m.style(a, b, o[b]);
	        }
	      });for (d in o) {
	        g = hb(q ? r[d] : 0, d, n), d in r || (r[d] = g.start, q && (g.end = g.start, g.start = "width" === d || "height" === d ? 1 : 0));
	      }
	    }
	  }function jb(a, b) {
	    var c, d, e, f, g;for (c in a) {
	      if (d = m.camelCase(c), e = b[d], f = a[c], m.isArray(f) && (e = f[1], f = a[c] = f[0]), c !== d && (a[d] = f, delete a[c]), g = m.cssHooks[d], g && "expand" in g) {
	        f = g.expand(f), delete a[d];for (c in f) {
	          c in a || (a[c] = f[c], b[c] = e);
	        }
	      } else b[d] = e;
	    }
	  }function kb(a, b, c) {
	    var d,
	        e,
	        f = 0,
	        g = db.length,
	        h = m.Deferred().always(function () {
	      delete i.elem;
	    }),
	        i = function i() {
	      if (e) return !1;for (var b = $a || fb(), c = Math.max(0, j.startTime + j.duration - b), d = c / j.duration || 0, f = 1 - d, g = 0, i = j.tweens.length; i > g; g++) {
	        j.tweens[g].run(f);
	      }return h.notifyWith(a, [j, f, c]), 1 > f && i ? c : (h.resolveWith(a, [j]), !1);
	    },
	        j = h.promise({ elem: a, props: m.extend({}, b), opts: m.extend(!0, { specialEasing: {} }, c), originalProperties: b, originalOptions: c, startTime: $a || fb(), duration: c.duration, tweens: [], createTween: function createTween(b, c) {
	        var d = m.Tween(a, j.opts, b, c, j.opts.specialEasing[b] || j.opts.easing);return j.tweens.push(d), d;
	      }, stop: function stop(b) {
	        var c = 0,
	            d = b ? j.tweens.length : 0;if (e) return this;for (e = !0; d > c; c++) {
	          j.tweens[c].run(1);
	        }return b ? h.resolveWith(a, [j, b]) : h.rejectWith(a, [j, b]), this;
	      } }),
	        k = j.props;for (jb(k, j.opts.specialEasing); g > f; f++) {
	      if (d = db[f].call(j, a, k, j.opts)) return d;
	    }return m.map(k, hb, j), m.isFunction(j.opts.start) && j.opts.start.call(a, j), m.fx.timer(m.extend(i, { elem: a, anim: j, queue: j.opts.queue })), j.progress(j.opts.progress).done(j.opts.done, j.opts.complete).fail(j.opts.fail).always(j.opts.always);
	  }m.Animation = m.extend(kb, { tweener: function tweener(a, b) {
	      m.isFunction(a) ? (b = a, a = ["*"]) : a = a.split(" ");for (var c, d = 0, e = a.length; e > d; d++) {
	        c = a[d], eb[c] = eb[c] || [], eb[c].unshift(b);
	      }
	    }, prefilter: function prefilter(a, b) {
	      b ? db.unshift(a) : db.push(a);
	    } }), m.speed = function (a, b, c) {
	    var d = a && "object" == (typeof a === "undefined" ? "undefined" : (0, _typeof3.default)(a)) ? m.extend({}, a) : { complete: c || !c && b || m.isFunction(a) && a, duration: a, easing: c && b || b && !m.isFunction(b) && b };return d.duration = m.fx.off ? 0 : "number" == typeof d.duration ? d.duration : d.duration in m.fx.speeds ? m.fx.speeds[d.duration] : m.fx.speeds._default, (null == d.queue || d.queue === !0) && (d.queue = "fx"), d.old = d.complete, d.complete = function () {
	      m.isFunction(d.old) && d.old.call(this), d.queue && m.dequeue(this, d.queue);
	    }, d;
	  }, m.fn.extend({ fadeTo: function fadeTo(a, b, c, d) {
	      return this.filter(U).css("opacity", 0).show().end().animate({ opacity: b }, a, c, d);
	    }, animate: function animate(a, b, c, d) {
	      var e = m.isEmptyObject(a),
	          f = m.speed(b, c, d),
	          g = function g() {
	        var b = kb(this, m.extend({}, a), f);(e || m._data(this, "finish")) && b.stop(!0);
	      };return g.finish = g, e || f.queue === !1 ? this.each(g) : this.queue(f.queue, g);
	    }, stop: function stop(a, b, c) {
	      var d = function d(a) {
	        var b = a.stop;delete a.stop, b(c);
	      };return "string" != typeof a && (c = b, b = a, a = void 0), b && a !== !1 && this.queue(a || "fx", []), this.each(function () {
	        var b = !0,
	            e = null != a && a + "queueHooks",
	            f = m.timers,
	            g = m._data(this);if (e) g[e] && g[e].stop && d(g[e]);else for (e in g) {
	          g[e] && g[e].stop && cb.test(e) && d(g[e]);
	        }for (e = f.length; e--;) {
	          f[e].elem !== this || null != a && f[e].queue !== a || (f[e].anim.stop(c), b = !1, f.splice(e, 1));
	        }(b || !c) && m.dequeue(this, a);
	      });
	    }, finish: function finish(a) {
	      return a !== !1 && (a = a || "fx"), this.each(function () {
	        var b,
	            c = m._data(this),
	            d = c[a + "queue"],
	            e = c[a + "queueHooks"],
	            f = m.timers,
	            g = d ? d.length : 0;for (c.finish = !0, m.queue(this, a, []), e && e.stop && e.stop.call(this, !0), b = f.length; b--;) {
	          f[b].elem === this && f[b].queue === a && (f[b].anim.stop(!0), f.splice(b, 1));
	        }for (b = 0; g > b; b++) {
	          d[b] && d[b].finish && d[b].finish.call(this);
	        }delete c.finish;
	      });
	    } }), m.each(["toggle", "show", "hide"], function (a, b) {
	    var c = m.fn[b];m.fn[b] = function (a, d, e) {
	      return null == a || "boolean" == typeof a ? c.apply(this, arguments) : this.animate(gb(b, !0), a, d, e);
	    };
	  }), m.each({ slideDown: gb("show"), slideUp: gb("hide"), slideToggle: gb("toggle"), fadeIn: { opacity: "show" }, fadeOut: { opacity: "hide" }, fadeToggle: { opacity: "toggle" } }, function (a, b) {
	    m.fn[a] = function (a, c, d) {
	      return this.animate(b, a, c, d);
	    };
	  }), m.timers = [], m.fx.tick = function () {
	    var a,
	        b = m.timers,
	        c = 0;for ($a = m.now(); c < b.length; c++) {
	      a = b[c], a() || b[c] !== a || b.splice(c--, 1);
	    }b.length || m.fx.stop(), $a = void 0;
	  }, m.fx.timer = function (a) {
	    m.timers.push(a), a() ? m.fx.start() : m.timers.pop();
	  }, m.fx.interval = 13, m.fx.start = function () {
	    _a || (_a = setInterval(m.fx.tick, m.fx.interval));
	  }, m.fx.stop = function () {
	    clearInterval(_a), _a = null;
	  }, m.fx.speeds = { slow: 600, fast: 200, _default: 400 }, m.fn.delay = function (a, b) {
	    return a = m.fx ? m.fx.speeds[a] || a : a, b = b || "fx", this.queue(b, function (b, c) {
	      var d = setTimeout(b, a);c.stop = function () {
	        clearTimeout(d);
	      };
	    });
	  }, function () {
	    var a, b, c, d, e;b = y.createElement("div"), b.setAttribute("className", "t"), b.innerHTML = "  <link/><table></table><a href='/a'>a</a><input type='checkbox'/>", d = b.getElementsByTagName("a")[0], c = y.createElement("select"), e = c.appendChild(y.createElement("option")), a = b.getElementsByTagName("input")[0], d.style.cssText = "top:1px", k.getSetAttribute = "t" !== b.className, k.style = /top/.test(d.getAttribute("style")), k.hrefNormalized = "/a" === d.getAttribute("href"), k.checkOn = !!a.value, k.optSelected = e.selected, k.enctype = !!y.createElement("form").enctype, c.disabled = !0, k.optDisabled = !e.disabled, a = y.createElement("input"), a.setAttribute("value", ""), k.input = "" === a.getAttribute("value"), a.value = "t", a.setAttribute("type", "radio"), k.radioValue = "t" === a.value;
	  }();var lb = /\r/g;m.fn.extend({ val: function val(a) {
	      var b,
	          c,
	          d,
	          e = this[0];{
	        if (arguments.length) return d = m.isFunction(a), this.each(function (c) {
	          var e;1 === this.nodeType && (e = d ? a.call(this, c, m(this).val()) : a, null == e ? e = "" : "number" == typeof e ? e += "" : m.isArray(e) && (e = m.map(e, function (a) {
	            return null == a ? "" : a + "";
	          })), b = m.valHooks[this.type] || m.valHooks[this.nodeName.toLowerCase()], b && "set" in b && void 0 !== b.set(this, e, "value") || (this.value = e));
	        });if (e) return b = m.valHooks[e.type] || m.valHooks[e.nodeName.toLowerCase()], b && "get" in b && void 0 !== (c = b.get(e, "value")) ? c : (c = e.value, "string" == typeof c ? c.replace(lb, "") : null == c ? "" : c);
	      }
	    } }), m.extend({ valHooks: { option: { get: function get(a) {
	          var b = m.find.attr(a, "value");return null != b ? b : m.trim(m.text(a));
	        } }, select: { get: function get(a) {
	          for (var b, c, d = a.options, e = a.selectedIndex, f = "select-one" === a.type || 0 > e, g = f ? null : [], h = f ? e + 1 : d.length, i = 0 > e ? h : f ? e : 0; h > i; i++) {
	            if (c = d[i], !(!c.selected && i !== e || (k.optDisabled ? c.disabled : null !== c.getAttribute("disabled")) || c.parentNode.disabled && m.nodeName(c.parentNode, "optgroup"))) {
	              if (b = m(c).val(), f) return b;g.push(b);
	            }
	          }return g;
	        }, set: function set(a, b) {
	          var c,
	              d,
	              e = a.options,
	              f = m.makeArray(b),
	              g = e.length;while (g--) {
	            if (d = e[g], m.inArray(m.valHooks.option.get(d), f) >= 0) try {
	              d.selected = c = !0;
	            } catch (h) {
	              d.scrollHeight;
	            } else d.selected = !1;
	          }return c || (a.selectedIndex = -1), e;
	        } } } }), m.each(["radio", "checkbox"], function () {
	    m.valHooks[this] = { set: function set(a, b) {
	        return m.isArray(b) ? a.checked = m.inArray(m(a).val(), b) >= 0 : void 0;
	      } }, k.checkOn || (m.valHooks[this].get = function (a) {
	      return null === a.getAttribute("value") ? "on" : a.value;
	    });
	  });var mb,
	      nb,
	      ob = m.expr.attrHandle,
	      pb = /^(?:checked|selected)$/i,
	      qb = k.getSetAttribute,
	      rb = k.input;m.fn.extend({ attr: function attr(a, b) {
	      return V(this, m.attr, a, b, arguments.length > 1);
	    }, removeAttr: function removeAttr(a) {
	      return this.each(function () {
	        m.removeAttr(this, a);
	      });
	    } }), m.extend({ attr: function attr(a, b, c) {
	      var d,
	          e,
	          f = a.nodeType;if (a && 3 !== f && 8 !== f && 2 !== f) return (0, _typeof3.default)(a.getAttribute) === K ? m.prop(a, b, c) : (1 === f && m.isXMLDoc(a) || (b = b.toLowerCase(), d = m.attrHooks[b] || (m.expr.match.bool.test(b) ? nb : mb)), void 0 === c ? d && "get" in d && null !== (e = d.get(a, b)) ? e : (e = m.find.attr(a, b), null == e ? void 0 : e) : null !== c ? d && "set" in d && void 0 !== (e = d.set(a, c, b)) ? e : (a.setAttribute(b, c + ""), c) : void m.removeAttr(a, b));
	    }, removeAttr: function removeAttr(a, b) {
	      var c,
	          d,
	          e = 0,
	          f = b && b.match(E);if (f && 1 === a.nodeType) while (c = f[e++]) {
	        d = m.propFix[c] || c, m.expr.match.bool.test(c) ? rb && qb || !pb.test(c) ? a[d] = !1 : a[m.camelCase("default-" + c)] = a[d] = !1 : m.attr(a, c, ""), a.removeAttribute(qb ? c : d);
	      }
	    }, attrHooks: { type: { set: function set(a, b) {
	          if (!k.radioValue && "radio" === b && m.nodeName(a, "input")) {
	            var c = a.value;return a.setAttribute("type", b), c && (a.value = c), b;
	          }
	        } } } }), nb = { set: function set(a, b, c) {
	      return b === !1 ? m.removeAttr(a, c) : rb && qb || !pb.test(c) ? a.setAttribute(!qb && m.propFix[c] || c, c) : a[m.camelCase("default-" + c)] = a[c] = !0, c;
	    } }, m.each(m.expr.match.bool.source.match(/\w+/g), function (a, b) {
	    var c = ob[b] || m.find.attr;ob[b] = rb && qb || !pb.test(b) ? function (a, b, d) {
	      var e, f;return d || (f = ob[b], ob[b] = e, e = null != c(a, b, d) ? b.toLowerCase() : null, ob[b] = f), e;
	    } : function (a, b, c) {
	      return c ? void 0 : a[m.camelCase("default-" + b)] ? b.toLowerCase() : null;
	    };
	  }), rb && qb || (m.attrHooks.value = { set: function set(a, b, c) {
	      return m.nodeName(a, "input") ? void (a.defaultValue = b) : mb && mb.set(a, b, c);
	    } }), qb || (mb = { set: function set(a, b, c) {
	      var d = a.getAttributeNode(c);return d || a.setAttributeNode(d = a.ownerDocument.createAttribute(c)), d.value = b += "", "value" === c || b === a.getAttribute(c) ? b : void 0;
	    } }, ob.id = ob.name = ob.coords = function (a, b, c) {
	    var d;return c ? void 0 : (d = a.getAttributeNode(b)) && "" !== d.value ? d.value : null;
	  }, m.valHooks.button = { get: function get(a, b) {
	      var c = a.getAttributeNode(b);return c && c.specified ? c.value : void 0;
	    }, set: mb.set }, m.attrHooks.contenteditable = { set: function set(a, b, c) {
	      mb.set(a, "" === b ? !1 : b, c);
	    } }, m.each(["width", "height"], function (a, b) {
	    m.attrHooks[b] = { set: function set(a, c) {
	        return "" === c ? (a.setAttribute(b, "auto"), c) : void 0;
	      } };
	  })), k.style || (m.attrHooks.style = { get: function get(a) {
	      return a.style.cssText || void 0;
	    }, set: function set(a, b) {
	      return a.style.cssText = b + "";
	    } });var sb = /^(?:input|select|textarea|button|object)$/i,
	      tb = /^(?:a|area)$/i;m.fn.extend({ prop: function prop(a, b) {
	      return V(this, m.prop, a, b, arguments.length > 1);
	    }, removeProp: function removeProp(a) {
	      return a = m.propFix[a] || a, this.each(function () {
	        try {
	          this[a] = void 0, delete this[a];
	        } catch (b) {}
	      });
	    } }), m.extend({ propFix: { "for": "htmlFor", "class": "className" }, prop: function prop(a, b, c) {
	      var d,
	          e,
	          f,
	          g = a.nodeType;if (a && 3 !== g && 8 !== g && 2 !== g) return f = 1 !== g || !m.isXMLDoc(a), f && (b = m.propFix[b] || b, e = m.propHooks[b]), void 0 !== c ? e && "set" in e && void 0 !== (d = e.set(a, c, b)) ? d : a[b] = c : e && "get" in e && null !== (d = e.get(a, b)) ? d : a[b];
	    }, propHooks: { tabIndex: { get: function get(a) {
	          var b = m.find.attr(a, "tabindex");return b ? parseInt(b, 10) : sb.test(a.nodeName) || tb.test(a.nodeName) && a.href ? 0 : -1;
	        } } } }), k.hrefNormalized || m.each(["href", "src"], function (a, b) {
	    m.propHooks[b] = { get: function get(a) {
	        return a.getAttribute(b, 4);
	      } };
	  }), k.optSelected || (m.propHooks.selected = { get: function get(a) {
	      var b = a.parentNode;return b && (b.selectedIndex, b.parentNode && b.parentNode.selectedIndex), null;
	    } }), m.each(["tabIndex", "readOnly", "maxLength", "cellSpacing", "cellPadding", "rowSpan", "colSpan", "useMap", "frameBorder", "contentEditable"], function () {
	    m.propFix[this.toLowerCase()] = this;
	  }), k.enctype || (m.propFix.enctype = "encoding");var ub = /[\t\r\n\f]/g;m.fn.extend({ addClass: function addClass(a) {
	      var b,
	          c,
	          d,
	          e,
	          f,
	          g,
	          h = 0,
	          i = this.length,
	          j = "string" == typeof a && a;if (m.isFunction(a)) return this.each(function (b) {
	        m(this).addClass(a.call(this, b, this.className));
	      });if (j) for (b = (a || "").match(E) || []; i > h; h++) {
	        if (c = this[h], d = 1 === c.nodeType && (c.className ? (" " + c.className + " ").replace(ub, " ") : " ")) {
	          f = 0;while (e = b[f++]) {
	            d.indexOf(" " + e + " ") < 0 && (d += e + " ");
	          }g = m.trim(d), c.className !== g && (c.className = g);
	        }
	      }return this;
	    }, removeClass: function removeClass(a) {
	      var b,
	          c,
	          d,
	          e,
	          f,
	          g,
	          h = 0,
	          i = this.length,
	          j = 0 === arguments.length || "string" == typeof a && a;if (m.isFunction(a)) return this.each(function (b) {
	        m(this).removeClass(a.call(this, b, this.className));
	      });if (j) for (b = (a || "").match(E) || []; i > h; h++) {
	        if (c = this[h], d = 1 === c.nodeType && (c.className ? (" " + c.className + " ").replace(ub, " ") : "")) {
	          f = 0;while (e = b[f++]) {
	            while (d.indexOf(" " + e + " ") >= 0) {
	              d = d.replace(" " + e + " ", " ");
	            }
	          }g = a ? m.trim(d) : "", c.className !== g && (c.className = g);
	        }
	      }return this;
	    }, toggleClass: function toggleClass(a, b) {
	      var c = typeof a === "undefined" ? "undefined" : (0, _typeof3.default)(a);return "boolean" == typeof b && "string" === c ? b ? this.addClass(a) : this.removeClass(a) : this.each(m.isFunction(a) ? function (c) {
	        m(this).toggleClass(a.call(this, c, this.className, b), b);
	      } : function () {
	        if ("string" === c) {
	          var b,
	              d = 0,
	              e = m(this),
	              f = a.match(E) || [];while (b = f[d++]) {
	            e.hasClass(b) ? e.removeClass(b) : e.addClass(b);
	          }
	        } else (c === K || "boolean" === c) && (this.className && m._data(this, "__className__", this.className), this.className = this.className || a === !1 ? "" : m._data(this, "__className__") || "");
	      });
	    }, hasClass: function hasClass(a) {
	      for (var b = " " + a + " ", c = 0, d = this.length; d > c; c++) {
	        if (1 === this[c].nodeType && (" " + this[c].className + " ").replace(ub, " ").indexOf(b) >= 0) return !0;
	      }return !1;
	    } }), m.each("blur focus focusin focusout load resize scroll unload click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup error contextmenu".split(" "), function (a, b) {
	    m.fn[b] = function (a, c) {
	      return arguments.length > 0 ? this.on(b, null, a, c) : this.trigger(b);
	    };
	  }), m.fn.extend({ hover: function hover(a, b) {
	      return this.mouseenter(a).mouseleave(b || a);
	    }, bind: function bind(a, b, c) {
	      return this.on(a, null, b, c);
	    }, unbind: function unbind(a, b) {
	      return this.off(a, null, b);
	    }, delegate: function delegate(a, b, c, d) {
	      return this.on(b, a, c, d);
	    }, undelegate: function undelegate(a, b, c) {
	      return 1 === arguments.length ? this.off(a, "**") : this.off(b, a || "**", c);
	    } });var vb = m.now(),
	      wb = /\?/,
	      xb = /(,)|(\[|{)|(}|])|"(?:[^"\\\r\n]|\\["\\\/bfnrt]|\\u[\da-fA-F]{4})*"\s*:?|true|false|null|-?(?!0\d)\d+(?:\.\d+|)(?:[eE][+-]?\d+|)/g;m.parseJSON = function (b) {
	    if (a.JSON && a.JSON.parse) return a.JSON.parse(b + "");var c,
	        d = null,
	        e = m.trim(b + "");return e && !m.trim(e.replace(xb, function (a, b, e, f) {
	      return c && b && (d = 0), 0 === d ? a : (c = e || b, d += !f - !e, "");
	    })) ? Function("return " + e)() : m.error("Invalid JSON: " + b);
	  }, m.parseXML = function (b) {
	    var c, d;if (!b || "string" != typeof b) return null;try {
	      a.DOMParser ? (d = new DOMParser(), c = d.parseFromString(b, "text/xml")) : (c = new ActiveXObject("Microsoft.XMLDOM"), c.async = "false", c.loadXML(b));
	    } catch (e) {
	      c = void 0;
	    }return c && c.documentElement && !c.getElementsByTagName("parsererror").length || m.error("Invalid XML: " + b), c;
	  };var yb,
	      zb,
	      Ab = /#.*$/,
	      Bb = /([?&])_=[^&]*/,
	      Cb = /^(.*?):[ \t]*([^\r\n]*)\r?$/gm,
	      Db = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,
	      Eb = /^(?:GET|HEAD)$/,
	      Fb = /^\/\//,
	      Gb = /^([\w.+-]+:)(?:\/\/(?:[^\/?#]*@|)([^\/?#:]*)(?::(\d+)|)|)/,
	      Hb = {},
	      Ib = {},
	      Jb = "*/".concat("*");try {
	    zb = location.href;
	  } catch (Kb) {
	    zb = y.createElement("a"), zb.href = "", zb = zb.href;
	  }yb = Gb.exec(zb.toLowerCase()) || [];function Lb(a) {
	    return function (b, c) {
	      "string" != typeof b && (c = b, b = "*");var d,
	          e = 0,
	          f = b.toLowerCase().match(E) || [];if (m.isFunction(c)) while (d = f[e++]) {
	        "+" === d.charAt(0) ? (d = d.slice(1) || "*", (a[d] = a[d] || []).unshift(c)) : (a[d] = a[d] || []).push(c);
	      }
	    };
	  }function Mb(a, b, c, d) {
	    var e = {},
	        f = a === Ib;function g(h) {
	      var i;return e[h] = !0, m.each(a[h] || [], function (a, h) {
	        var j = h(b, c, d);return "string" != typeof j || f || e[j] ? f ? !(i = j) : void 0 : (b.dataTypes.unshift(j), g(j), !1);
	      }), i;
	    }return g(b.dataTypes[0]) || !e["*"] && g("*");
	  }function Nb(a, b) {
	    var c,
	        d,
	        e = m.ajaxSettings.flatOptions || {};for (d in b) {
	      void 0 !== b[d] && ((e[d] ? a : c || (c = {}))[d] = b[d]);
	    }return c && m.extend(!0, a, c), a;
	  }function Ob(a, b, c) {
	    var d,
	        e,
	        f,
	        g,
	        h = a.contents,
	        i = a.dataTypes;while ("*" === i[0]) {
	      i.shift(), void 0 === e && (e = a.mimeType || b.getResponseHeader("Content-Type"));
	    }if (e) for (g in h) {
	      if (h[g] && h[g].test(e)) {
	        i.unshift(g);break;
	      }
	    }if (i[0] in c) f = i[0];else {
	      for (g in c) {
	        if (!i[0] || a.converters[g + " " + i[0]]) {
	          f = g;break;
	        }d || (d = g);
	      }f = f || d;
	    }return f ? (f !== i[0] && i.unshift(f), c[f]) : void 0;
	  }function Pb(a, b, c, d) {
	    var e,
	        f,
	        g,
	        h,
	        i,
	        j = {},
	        k = a.dataTypes.slice();if (k[1]) for (g in a.converters) {
	      j[g.toLowerCase()] = a.converters[g];
	    }f = k.shift();while (f) {
	      if (a.responseFields[f] && (c[a.responseFields[f]] = b), !i && d && a.dataFilter && (b = a.dataFilter(b, a.dataType)), i = f, f = k.shift()) if ("*" === f) f = i;else if ("*" !== i && i !== f) {
	        if (g = j[i + " " + f] || j["* " + f], !g) for (e in j) {
	          if (h = e.split(" "), h[1] === f && (g = j[i + " " + h[0]] || j["* " + h[0]])) {
	            g === !0 ? g = j[e] : j[e] !== !0 && (f = h[0], k.unshift(h[1]));break;
	          }
	        }if (g !== !0) if (g && a["throws"]) b = g(b);else try {
	          b = g(b);
	        } catch (l) {
	          return { state: "parsererror", error: g ? l : "No conversion from " + i + " to " + f };
	        }
	      }
	    }return { state: "success", data: b };
	  }m.extend({ active: 0, lastModified: {}, etag: {}, ajaxSettings: { url: zb, type: "GET", isLocal: Db.test(yb[1]), global: !0, processData: !0, async: !0, contentType: "application/x-www-form-urlencoded; charset=UTF-8", accepts: { "*": Jb, text: "text/plain", html: "text/html", xml: "application/xml, text/xml", json: "application/json, text/javascript" }, contents: { xml: /xml/, html: /html/, json: /json/ }, responseFields: { xml: "responseXML", text: "responseText", json: "responseJSON" }, converters: { "* text": String, "text html": !0, "text json": m.parseJSON, "text xml": m.parseXML }, flatOptions: { url: !0, context: !0 } }, ajaxSetup: function ajaxSetup(a, b) {
	      return b ? Nb(Nb(a, m.ajaxSettings), b) : Nb(m.ajaxSettings, a);
	    }, ajaxPrefilter: Lb(Hb), ajaxTransport: Lb(Ib), ajax: function ajax(a, b) {
	      "object" == (typeof a === "undefined" ? "undefined" : (0, _typeof3.default)(a)) && (b = a, a = void 0), b = b || {};var c,
	          d,
	          e,
	          f,
	          g,
	          h,
	          i,
	          j,
	          k = m.ajaxSetup({}, b),
	          l = k.context || k,
	          n = k.context && (l.nodeType || l.jquery) ? m(l) : m.event,
	          o = m.Deferred(),
	          p = m.Callbacks("once memory"),
	          q = k.statusCode || {},
	          r = {},
	          s = {},
	          t = 0,
	          u = "canceled",
	          v = { readyState: 0, getResponseHeader: function getResponseHeader(a) {
	          var b;if (2 === t) {
	            if (!j) {
	              j = {};while (b = Cb.exec(f)) {
	                j[b[1].toLowerCase()] = b[2];
	              }
	            }b = j[a.toLowerCase()];
	          }return null == b ? null : b;
	        }, getAllResponseHeaders: function getAllResponseHeaders() {
	          return 2 === t ? f : null;
	        }, setRequestHeader: function setRequestHeader(a, b) {
	          var c = a.toLowerCase();return t || (a = s[c] = s[c] || a, r[a] = b), this;
	        }, overrideMimeType: function overrideMimeType(a) {
	          return t || (k.mimeType = a), this;
	        }, statusCode: function statusCode(a) {
	          var b;if (a) if (2 > t) for (b in a) {
	            q[b] = [q[b], a[b]];
	          } else v.always(a[v.status]);return this;
	        }, abort: function abort(a) {
	          var b = a || u;return i && i.abort(b), x(0, b), this;
	        } };if (o.promise(v).complete = p.add, v.success = v.done, v.error = v.fail, k.url = ((a || k.url || zb) + "").replace(Ab, "").replace(Fb, yb[1] + "//"), k.type = b.method || b.type || k.method || k.type, k.dataTypes = m.trim(k.dataType || "*").toLowerCase().match(E) || [""], null == k.crossDomain && (c = Gb.exec(k.url.toLowerCase()), k.crossDomain = !(!c || c[1] === yb[1] && c[2] === yb[2] && (c[3] || ("http:" === c[1] ? "80" : "443")) === (yb[3] || ("http:" === yb[1] ? "80" : "443")))), k.data && k.processData && "string" != typeof k.data && (k.data = m.param(k.data, k.traditional)), Mb(Hb, k, b, v), 2 === t) return v;h = m.event && k.global, h && 0 === m.active++ && m.event.trigger("ajaxStart"), k.type = k.type.toUpperCase(), k.hasContent = !Eb.test(k.type), e = k.url, k.hasContent || (k.data && (e = k.url += (wb.test(e) ? "&" : "?") + k.data, delete k.data), k.cache === !1 && (k.url = Bb.test(e) ? e.replace(Bb, "$1_=" + vb++) : e + (wb.test(e) ? "&" : "?") + "_=" + vb++)), k.ifModified && (m.lastModified[e] && v.setRequestHeader("If-Modified-Since", m.lastModified[e]), m.etag[e] && v.setRequestHeader("If-None-Match", m.etag[e])), (k.data && k.hasContent && k.contentType !== !1 || b.contentType) && v.setRequestHeader("Content-Type", k.contentType), v.setRequestHeader("Accept", k.dataTypes[0] && k.accepts[k.dataTypes[0]] ? k.accepts[k.dataTypes[0]] + ("*" !== k.dataTypes[0] ? ", " + Jb + "; q=0.01" : "") : k.accepts["*"]);for (d in k.headers) {
	        v.setRequestHeader(d, k.headers[d]);
	      }if (k.beforeSend && (k.beforeSend.call(l, v, k) === !1 || 2 === t)) return v.abort();u = "abort";for (d in { success: 1, error: 1, complete: 1 }) {
	        v[d](k[d]);
	      }if (i = Mb(Ib, k, b, v)) {
	        v.readyState = 1, h && n.trigger("ajaxSend", [v, k]), k.async && k.timeout > 0 && (g = setTimeout(function () {
	          v.abort("timeout");
	        }, k.timeout));try {
	          t = 1, i.send(r, x);
	        } catch (w) {
	          if (!(2 > t)) throw w;x(-1, w);
	        }
	      } else x(-1, "No Transport");function x(a, b, c, d) {
	        var j,
	            r,
	            s,
	            u,
	            w,
	            x = b;2 !== t && (t = 2, g && clearTimeout(g), i = void 0, f = d || "", v.readyState = a > 0 ? 4 : 0, j = a >= 200 && 300 > a || 304 === a, c && (u = Ob(k, v, c)), u = Pb(k, u, v, j), j ? (k.ifModified && (w = v.getResponseHeader("Last-Modified"), w && (m.lastModified[e] = w), w = v.getResponseHeader("etag"), w && (m.etag[e] = w)), 204 === a || "HEAD" === k.type ? x = "nocontent" : 304 === a ? x = "notmodified" : (x = u.state, r = u.data, s = u.error, j = !s)) : (s = x, (a || !x) && (x = "error", 0 > a && (a = 0))), v.status = a, v.statusText = (b || x) + "", j ? o.resolveWith(l, [r, x, v]) : o.rejectWith(l, [v, x, s]), v.statusCode(q), q = void 0, h && n.trigger(j ? "ajaxSuccess" : "ajaxError", [v, k, j ? r : s]), p.fireWith(l, [v, x]), h && (n.trigger("ajaxComplete", [v, k]), --m.active || m.event.trigger("ajaxStop")));
	      }return v;
	    }, getJSON: function getJSON(a, b, c) {
	      return m.get(a, b, c, "json");
	    }, getScript: function getScript(a, b) {
	      return m.get(a, void 0, b, "script");
	    } }), m.each(["get", "post"], function (a, b) {
	    m[b] = function (a, c, d, e) {
	      return m.isFunction(c) && (e = e || d, d = c, c = void 0), m.ajax({ url: a, type: b, dataType: e, data: c, success: d });
	    };
	  }), m._evalUrl = function (a) {
	    return m.ajax({ url: a, type: "GET", dataType: "script", async: !1, global: !1, "throws": !0 });
	  }, m.fn.extend({ wrapAll: function wrapAll(a) {
	      if (m.isFunction(a)) return this.each(function (b) {
	        m(this).wrapAll(a.call(this, b));
	      });if (this[0]) {
	        var b = m(a, this[0].ownerDocument).eq(0).clone(!0);this[0].parentNode && b.insertBefore(this[0]), b.map(function () {
	          var a = this;while (a.firstChild && 1 === a.firstChild.nodeType) {
	            a = a.firstChild;
	          }return a;
	        }).append(this);
	      }return this;
	    }, wrapInner: function wrapInner(a) {
	      return this.each(m.isFunction(a) ? function (b) {
	        m(this).wrapInner(a.call(this, b));
	      } : function () {
	        var b = m(this),
	            c = b.contents();c.length ? c.wrapAll(a) : b.append(a);
	      });
	    }, wrap: function wrap(a) {
	      var b = m.isFunction(a);return this.each(function (c) {
	        m(this).wrapAll(b ? a.call(this, c) : a);
	      });
	    }, unwrap: function unwrap() {
	      return this.parent().each(function () {
	        m.nodeName(this, "body") || m(this).replaceWith(this.childNodes);
	      }).end();
	    } }), m.expr.filters.hidden = function (a) {
	    return a.offsetWidth <= 0 && a.offsetHeight <= 0 || !k.reliableHiddenOffsets() && "none" === (a.style && a.style.display || m.css(a, "display"));
	  }, m.expr.filters.visible = function (a) {
	    return !m.expr.filters.hidden(a);
	  };var Qb = /%20/g,
	      Rb = /\[\]$/,
	      Sb = /\r?\n/g,
	      Tb = /^(?:submit|button|image|reset|file)$/i,
	      Ub = /^(?:input|select|textarea|keygen)/i;function Vb(a, b, c, d) {
	    var e;if (m.isArray(b)) m.each(b, function (b, e) {
	      c || Rb.test(a) ? d(a, e) : Vb(a + "[" + ("object" == (typeof e === "undefined" ? "undefined" : (0, _typeof3.default)(e)) ? b : "") + "]", e, c, d);
	    });else if (c || "object" !== m.type(b)) d(a, b);else for (e in b) {
	      Vb(a + "[" + e + "]", b[e], c, d);
	    }
	  }m.param = function (a, b) {
	    var c,
	        d = [],
	        e = function e(a, b) {
	      b = m.isFunction(b) ? b() : null == b ? "" : b, d[d.length] = encodeURIComponent(a) + "=" + encodeURIComponent(b);
	    };if (void 0 === b && (b = m.ajaxSettings && m.ajaxSettings.traditional), m.isArray(a) || a.jquery && !m.isPlainObject(a)) m.each(a, function () {
	      e(this.name, this.value);
	    });else for (c in a) {
	      Vb(c, a[c], b, e);
	    }return d.join("&").replace(Qb, "+");
	  }, m.fn.extend({ serialize: function serialize() {
	      return m.param(this.serializeArray());
	    }, serializeArray: function serializeArray() {
	      return this.map(function () {
	        var a = m.prop(this, "elements");return a ? m.makeArray(a) : this;
	      }).filter(function () {
	        var a = this.type;return this.name && !m(this).is(":disabled") && Ub.test(this.nodeName) && !Tb.test(a) && (this.checked || !W.test(a));
	      }).map(function (a, b) {
	        var c = m(this).val();return null == c ? null : m.isArray(c) ? m.map(c, function (a) {
	          return { name: b.name, value: a.replace(Sb, "\r\n") };
	        }) : { name: b.name, value: c.replace(Sb, "\r\n") };
	      }).get();
	    } }), m.ajaxSettings.xhr = void 0 !== a.ActiveXObject ? function () {
	    return !this.isLocal && /^(get|post|head|put|delete|options)$/i.test(this.type) && Zb() || $b();
	  } : Zb;var Wb = 0,
	      Xb = {},
	      Yb = m.ajaxSettings.xhr();a.attachEvent && a.attachEvent("onunload", function () {
	    for (var a in Xb) {
	      Xb[a](void 0, !0);
	    }
	  }), k.cors = !!Yb && "withCredentials" in Yb, Yb = k.ajax = !!Yb, Yb && m.ajaxTransport(function (a) {
	    if (!a.crossDomain || k.cors) {
	      var _b3;return { send: function send(c, d) {
	          var e,
	              f = a.xhr(),
	              g = ++Wb;if (f.open(a.type, a.url, a.async, a.username, a.password), a.xhrFields) for (e in a.xhrFields) {
	            f[e] = a.xhrFields[e];
	          }a.mimeType && f.overrideMimeType && f.overrideMimeType(a.mimeType), a.crossDomain || c["X-Requested-With"] || (c["X-Requested-With"] = "XMLHttpRequest");for (e in c) {
	            void 0 !== c[e] && f.setRequestHeader(e, c[e] + "");
	          }f.send(a.hasContent && a.data || null), _b3 = function b(c, e) {
	            var h, i, j;if (_b3 && (e || 4 === f.readyState)) if (delete Xb[g], _b3 = void 0, f.onreadystatechange = m.noop, e) 4 !== f.readyState && f.abort();else {
	              j = {}, h = f.status, "string" == typeof f.responseText && (j.text = f.responseText);try {
	                i = f.statusText;
	              } catch (k) {
	                i = "";
	              }h || !a.isLocal || a.crossDomain ? 1223 === h && (h = 204) : h = j.text ? 200 : 404;
	            }j && d(h, i, j, f.getAllResponseHeaders());
	          }, a.async ? 4 === f.readyState ? setTimeout(_b3) : f.onreadystatechange = Xb[g] = _b3 : _b3();
	        }, abort: function abort() {
	          _b3 && _b3(void 0, !0);
	        } };
	    }
	  });function Zb() {
	    try {
	      return new a.XMLHttpRequest();
	    } catch (b) {}
	  }function $b() {
	    try {
	      return new a.ActiveXObject("Microsoft.XMLHTTP");
	    } catch (b) {}
	  }m.ajaxSetup({ accepts: { script: "text/javascript, application/javascript, application/ecmascript, application/x-ecmascript" }, contents: { script: /(?:java|ecma)script/ }, converters: { "text script": function textScript(a) {
	        return m.globalEval(a), a;
	      } } }), m.ajaxPrefilter("script", function (a) {
	    void 0 === a.cache && (a.cache = !1), a.crossDomain && (a.type = "GET", a.global = !1);
	  }), m.ajaxTransport("script", function (a) {
	    if (a.crossDomain) {
	      var b,
	          c = y.head || m("head")[0] || y.documentElement;return { send: function send(d, e) {
	          b = y.createElement("script"), b.async = !0, a.scriptCharset && (b.charset = a.scriptCharset), b.src = a.url, b.onload = b.onreadystatechange = function (a, c) {
	            (c || !b.readyState || /loaded|complete/.test(b.readyState)) && (b.onload = b.onreadystatechange = null, b.parentNode && b.parentNode.removeChild(b), b = null, c || e(200, "success"));
	          }, c.insertBefore(b, c.firstChild);
	        }, abort: function abort() {
	          b && b.onload(void 0, !0);
	        } };
	    }
	  });var _b = [],
	      ac = /(=)\?(?=&|$)|\?\?/;m.ajaxSetup({ jsonp: "callback", jsonpCallback: function jsonpCallback() {
	      var a = _b.pop() || m.expando + "_" + vb++;return this[a] = !0, a;
	    } }), m.ajaxPrefilter("json jsonp", function (b, c, d) {
	    var e,
	        f,
	        g,
	        h = b.jsonp !== !1 && (ac.test(b.url) ? "url" : "string" == typeof b.data && !(b.contentType || "").indexOf("application/x-www-form-urlencoded") && ac.test(b.data) && "data");return h || "jsonp" === b.dataTypes[0] ? (e = b.jsonpCallback = m.isFunction(b.jsonpCallback) ? b.jsonpCallback() : b.jsonpCallback, h ? b[h] = b[h].replace(ac, "$1" + e) : b.jsonp !== !1 && (b.url += (wb.test(b.url) ? "&" : "?") + b.jsonp + "=" + e), b.converters["script json"] = function () {
	      return g || m.error(e + " was not called"), g[0];
	    }, b.dataTypes[0] = "json", f = a[e], a[e] = function () {
	      g = arguments;
	    }, d.always(function () {
	      a[e] = f, b[e] && (b.jsonpCallback = c.jsonpCallback, _b.push(e)), g && m.isFunction(f) && f(g[0]), g = f = void 0;
	    }), "script") : void 0;
	  }), m.parseHTML = function (a, b, c) {
	    if (!a || "string" != typeof a) return null;"boolean" == typeof b && (c = b, b = !1), b = b || y;var d = u.exec(a),
	        e = !c && [];return d ? [b.createElement(d[1])] : (d = m.buildFragment([a], b, e), e && e.length && m(e).remove(), m.merge([], d.childNodes));
	  };var bc = m.fn.load;m.fn.load = function (a, b, c) {
	    if ("string" != typeof a && bc) return bc.apply(this, arguments);var d,
	        e,
	        f,
	        g = this,
	        h = a.indexOf(" ");return h >= 0 && (d = m.trim(a.slice(h, a.length)), a = a.slice(0, h)), m.isFunction(b) ? (c = b, b = void 0) : b && "object" == (typeof b === "undefined" ? "undefined" : (0, _typeof3.default)(b)) && (f = "POST"), g.length > 0 && m.ajax({ url: a, type: f, dataType: "html", data: b }).done(function (a) {
	      e = arguments, g.html(d ? m("<div>").append(m.parseHTML(a)).find(d) : a);
	    }).complete(c && function (a, b) {
	      g.each(c, e || [a.responseText, b, a]);
	    }), this;
	  }, m.each(["ajaxStart", "ajaxStop", "ajaxComplete", "ajaxError", "ajaxSuccess", "ajaxSend"], function (a, b) {
	    m.fn[b] = function (a) {
	      return this.on(b, a);
	    };
	  }), m.expr.filters.animated = function (a) {
	    return m.grep(m.timers, function (b) {
	      return a === b.elem;
	    }).length;
	  };var cc = a.document.documentElement;function dc(a) {
	    return m.isWindow(a) ? a : 9 === a.nodeType ? a.defaultView || a.parentWindow : !1;
	  }m.offset = { setOffset: function setOffset(a, b, c) {
	      var d,
	          e,
	          f,
	          g,
	          h,
	          i,
	          j,
	          k = m.css(a, "position"),
	          l = m(a),
	          n = {};"static" === k && (a.style.position = "relative"), h = l.offset(), f = m.css(a, "top"), i = m.css(a, "left"), j = ("absolute" === k || "fixed" === k) && m.inArray("auto", [f, i]) > -1, j ? (d = l.position(), g = d.top, e = d.left) : (g = parseFloat(f) || 0, e = parseFloat(i) || 0), m.isFunction(b) && (b = b.call(a, c, h)), null != b.top && (n.top = b.top - h.top + g), null != b.left && (n.left = b.left - h.left + e), "using" in b ? b.using.call(a, n) : l.css(n);
	    } }, m.fn.extend({ offset: function offset(a) {
	      if (arguments.length) return void 0 === a ? this : this.each(function (b) {
	        m.offset.setOffset(this, a, b);
	      });var b,
	          c,
	          d = { top: 0, left: 0 },
	          e = this[0],
	          f = e && e.ownerDocument;if (f) return b = f.documentElement, m.contains(b, e) ? ((0, _typeof3.default)(e.getBoundingClientRect) !== K && (d = e.getBoundingClientRect()), c = dc(f), { top: d.top + (c.pageYOffset || b.scrollTop) - (b.clientTop || 0), left: d.left + (c.pageXOffset || b.scrollLeft) - (b.clientLeft || 0) }) : d;
	    }, position: function position() {
	      if (this[0]) {
	        var a,
	            b,
	            c = { top: 0, left: 0 },
	            d = this[0];return "fixed" === m.css(d, "position") ? b = d.getBoundingClientRect() : (a = this.offsetParent(), b = this.offset(), m.nodeName(a[0], "html") || (c = a.offset()), c.top += m.css(a[0], "borderTopWidth", !0), c.left += m.css(a[0], "borderLeftWidth", !0)), { top: b.top - c.top - m.css(d, "marginTop", !0), left: b.left - c.left - m.css(d, "marginLeft", !0) };
	      }
	    }, offsetParent: function offsetParent() {
	      return this.map(function () {
	        var a = this.offsetParent || cc;while (a && !m.nodeName(a, "html") && "static" === m.css(a, "position")) {
	          a = a.offsetParent;
	        }return a || cc;
	      });
	    } }), m.each({ scrollLeft: "pageXOffset", scrollTop: "pageYOffset" }, function (a, b) {
	    var c = /Y/.test(b);m.fn[a] = function (d) {
	      return V(this, function (a, d, e) {
	        var f = dc(a);return void 0 === e ? f ? b in f ? f[b] : f.document.documentElement[d] : a[d] : void (f ? f.scrollTo(c ? m(f).scrollLeft() : e, c ? e : m(f).scrollTop()) : a[d] = e);
	      }, a, d, arguments.length, null);
	    };
	  }), m.each(["top", "left"], function (a, b) {
	    m.cssHooks[b] = La(k.pixelPosition, function (a, c) {
	      return c ? (c = Ja(a, b), Ha.test(c) ? m(a).position()[b] + "px" : c) : void 0;
	    });
	  }), m.each({ Height: "height", Width: "width" }, function (a, b) {
	    m.each({ padding: "inner" + a, content: b, "": "outer" + a }, function (c, d) {
	      m.fn[d] = function (d, e) {
	        var f = arguments.length && (c || "boolean" != typeof d),
	            g = c || (d === !0 || e === !0 ? "margin" : "border");return V(this, function (b, c, d) {
	          var e;return m.isWindow(b) ? b.document.documentElement["client" + a] : 9 === b.nodeType ? (e = b.documentElement, Math.max(b.body["scroll" + a], e["scroll" + a], b.body["offset" + a], e["offset" + a], e["client" + a])) : void 0 === d ? m.css(b, c, g) : m.style(b, c, d, g);
	        }, b, f ? d : void 0, f, null);
	      };
	    });
	  }), m.fn.size = function () {
	    return this.length;
	  }, m.fn.andSelf = m.fn.addBack, "function" == "function" && __webpack_require__(72) && !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function () {
	    return m;
	  }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));var ec = a.jQuery,
	      fc = a.$;return m.noConflict = function (b) {
	    return a.$ === m && (a.$ = fc), b && a.jQuery === m && (a.jQuery = ec), m;
	  }, (typeof b === "undefined" ? "undefined" : (0, _typeof3.default)(b)) === K && (a.jQuery = a.$ = m), m;
	});
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)(module)))

/***/ },
/* 3 */
/***/ function(module, exports) {

	module.exports = function(module) {
		if(!module.webpackPolyfill) {
			module.deprecate = function() {};
			module.paths = [];
			// module.parent = undefined by default
			module.children = [];
			module.webpackPolyfill = 1;
		}
		return module;
	}


/***/ },
/* 4 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	exports.__esModule = true;
	
	var _iterator = __webpack_require__(5);
	
	var _iterator2 = _interopRequireDefault(_iterator);
	
	var _symbol = __webpack_require__(56);
	
	var _symbol2 = _interopRequireDefault(_symbol);
	
	var _typeof = typeof _symbol2.default === "function" && typeof _iterator2.default === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof _symbol2.default === "function" && obj.constructor === _symbol2.default && obj !== _symbol2.default.prototype ? "symbol" : typeof obj; };
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = typeof _symbol2.default === "function" && _typeof(_iterator2.default) === "symbol" ? function (obj) {
	  return typeof obj === "undefined" ? "undefined" : _typeof(obj);
	} : function (obj) {
	  return obj && typeof _symbol2.default === "function" && obj.constructor === _symbol2.default && obj !== _symbol2.default.prototype ? "symbol" : typeof obj === "undefined" ? "undefined" : _typeof(obj);
	};

/***/ },
/* 5 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(6), __esModule: true };

/***/ },
/* 6 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(7);
	__webpack_require__(51);
	module.exports = __webpack_require__(55).f('iterator');

/***/ },
/* 7 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $at  = __webpack_require__(8)(true);
	
	// 21.1.3.27 String.prototype[@@iterator]()
	__webpack_require__(11)(String, 'String', function(iterated){
	  this._t = String(iterated); // target
	  this._i = 0;                // next index
	// 21.1.5.2.1 %StringIteratorPrototype%.next()
	}, function(){
	  var O     = this._t
	    , index = this._i
	    , point;
	  if(index >= O.length)return {value: undefined, done: true};
	  point = $at(O, index);
	  this._i += point.length;
	  return {value: point, done: false};
	});

/***/ },
/* 8 */
/***/ function(module, exports, __webpack_require__) {

	var toInteger = __webpack_require__(9)
	  , defined   = __webpack_require__(10);
	// true  -> String#at
	// false -> String#codePointAt
	module.exports = function(TO_STRING){
	  return function(that, pos){
	    var s = String(defined(that))
	      , i = toInteger(pos)
	      , l = s.length
	      , a, b;
	    if(i < 0 || i >= l)return TO_STRING ? '' : undefined;
	    a = s.charCodeAt(i);
	    return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff
	      ? TO_STRING ? s.charAt(i) : a
	      : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;
	  };
	};

/***/ },
/* 9 */
/***/ function(module, exports) {

	// 7.1.4 ToInteger
	var ceil  = Math.ceil
	  , floor = Math.floor;
	module.exports = function(it){
	  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
	};

/***/ },
/* 10 */
/***/ function(module, exports) {

	// 7.2.1 RequireObjectCoercible(argument)
	module.exports = function(it){
	  if(it == undefined)throw TypeError("Can't call method on  " + it);
	  return it;
	};

/***/ },
/* 11 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var LIBRARY        = __webpack_require__(12)
	  , $export        = __webpack_require__(13)
	  , redefine       = __webpack_require__(28)
	  , hide           = __webpack_require__(18)
	  , has            = __webpack_require__(29)
	  , Iterators      = __webpack_require__(30)
	  , $iterCreate    = __webpack_require__(31)
	  , setToStringTag = __webpack_require__(47)
	  , getPrototypeOf = __webpack_require__(49)
	  , ITERATOR       = __webpack_require__(48)('iterator')
	  , BUGGY          = !([].keys && 'next' in [].keys()) // Safari has buggy iterators w/o `next`
	  , FF_ITERATOR    = '@@iterator'
	  , KEYS           = 'keys'
	  , VALUES         = 'values';
	
	var returnThis = function(){ return this; };
	
	module.exports = function(Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED){
	  $iterCreate(Constructor, NAME, next);
	  var getMethod = function(kind){
	    if(!BUGGY && kind in proto)return proto[kind];
	    switch(kind){
	      case KEYS: return function keys(){ return new Constructor(this, kind); };
	      case VALUES: return function values(){ return new Constructor(this, kind); };
	    } return function entries(){ return new Constructor(this, kind); };
	  };
	  var TAG        = NAME + ' Iterator'
	    , DEF_VALUES = DEFAULT == VALUES
	    , VALUES_BUG = false
	    , proto      = Base.prototype
	    , $native    = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT]
	    , $default   = $native || getMethod(DEFAULT)
	    , $entries   = DEFAULT ? !DEF_VALUES ? $default : getMethod('entries') : undefined
	    , $anyNative = NAME == 'Array' ? proto.entries || $native : $native
	    , methods, key, IteratorPrototype;
	  // Fix native
	  if($anyNative){
	    IteratorPrototype = getPrototypeOf($anyNative.call(new Base));
	    if(IteratorPrototype !== Object.prototype){
	      // Set @@toStringTag to native iterators
	      setToStringTag(IteratorPrototype, TAG, true);
	      // fix for some old engines
	      if(!LIBRARY && !has(IteratorPrototype, ITERATOR))hide(IteratorPrototype, ITERATOR, returnThis);
	    }
	  }
	  // fix Array#{values, @@iterator}.name in V8 / FF
	  if(DEF_VALUES && $native && $native.name !== VALUES){
	    VALUES_BUG = true;
	    $default = function values(){ return $native.call(this); };
	  }
	  // Define iterator
	  if((!LIBRARY || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])){
	    hide(proto, ITERATOR, $default);
	  }
	  // Plug for library
	  Iterators[NAME] = $default;
	  Iterators[TAG]  = returnThis;
	  if(DEFAULT){
	    methods = {
	      values:  DEF_VALUES ? $default : getMethod(VALUES),
	      keys:    IS_SET     ? $default : getMethod(KEYS),
	      entries: $entries
	    };
	    if(FORCED)for(key in methods){
	      if(!(key in proto))redefine(proto, key, methods[key]);
	    } else $export($export.P + $export.F * (BUGGY || VALUES_BUG), NAME, methods);
	  }
	  return methods;
	};

/***/ },
/* 12 */
/***/ function(module, exports) {

	module.exports = true;

/***/ },
/* 13 */
/***/ function(module, exports, __webpack_require__) {

	var global    = __webpack_require__(14)
	  , core      = __webpack_require__(15)
	  , ctx       = __webpack_require__(16)
	  , hide      = __webpack_require__(18)
	  , PROTOTYPE = 'prototype';
	
	var $export = function(type, name, source){
	  var IS_FORCED = type & $export.F
	    , IS_GLOBAL = type & $export.G
	    , IS_STATIC = type & $export.S
	    , IS_PROTO  = type & $export.P
	    , IS_BIND   = type & $export.B
	    , IS_WRAP   = type & $export.W
	    , exports   = IS_GLOBAL ? core : core[name] || (core[name] = {})
	    , expProto  = exports[PROTOTYPE]
	    , target    = IS_GLOBAL ? global : IS_STATIC ? global[name] : (global[name] || {})[PROTOTYPE]
	    , key, own, out;
	  if(IS_GLOBAL)source = name;
	  for(key in source){
	    // contains in native
	    own = !IS_FORCED && target && target[key] !== undefined;
	    if(own && key in exports)continue;
	    // export native or passed
	    out = own ? target[key] : source[key];
	    // prevent global pollution for namespaces
	    exports[key] = IS_GLOBAL && typeof target[key] != 'function' ? source[key]
	    // bind timers to global for call from export context
	    : IS_BIND && own ? ctx(out, global)
	    // wrap global constructors for prevent change them in library
	    : IS_WRAP && target[key] == out ? (function(C){
	      var F = function(a, b, c){
	        if(this instanceof C){
	          switch(arguments.length){
	            case 0: return new C;
	            case 1: return new C(a);
	            case 2: return new C(a, b);
	          } return new C(a, b, c);
	        } return C.apply(this, arguments);
	      };
	      F[PROTOTYPE] = C[PROTOTYPE];
	      return F;
	    // make static versions for prototype methods
	    })(out) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;
	    // export proto methods to core.%CONSTRUCTOR%.methods.%NAME%
	    if(IS_PROTO){
	      (exports.virtual || (exports.virtual = {}))[key] = out;
	      // export proto methods to core.%CONSTRUCTOR%.prototype.%NAME%
	      if(type & $export.R && expProto && !expProto[key])hide(expProto, key, out);
	    }
	  }
	};
	// type bitmap
	$export.F = 1;   // forced
	$export.G = 2;   // global
	$export.S = 4;   // static
	$export.P = 8;   // proto
	$export.B = 16;  // bind
	$export.W = 32;  // wrap
	$export.U = 64;  // safe
	$export.R = 128; // real proto method for `library` 
	module.exports = $export;

/***/ },
/* 14 */
/***/ function(module, exports) {

	// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
	var global = module.exports = typeof window != 'undefined' && window.Math == Math
	  ? window : typeof self != 'undefined' && self.Math == Math ? self : Function('return this')();
	if(typeof __g == 'number')__g = global; // eslint-disable-line no-undef

/***/ },
/* 15 */
/***/ function(module, exports) {

	var core = module.exports = {version: '2.4.0'};
	if(typeof __e == 'number')__e = core; // eslint-disable-line no-undef

/***/ },
/* 16 */
/***/ function(module, exports, __webpack_require__) {

	// optional / simple context binding
	var aFunction = __webpack_require__(17);
	module.exports = function(fn, that, length){
	  aFunction(fn);
	  if(that === undefined)return fn;
	  switch(length){
	    case 1: return function(a){
	      return fn.call(that, a);
	    };
	    case 2: return function(a, b){
	      return fn.call(that, a, b);
	    };
	    case 3: return function(a, b, c){
	      return fn.call(that, a, b, c);
	    };
	  }
	  return function(/* ...args */){
	    return fn.apply(that, arguments);
	  };
	};

/***/ },
/* 17 */
/***/ function(module, exports) {

	module.exports = function(it){
	  if(typeof it != 'function')throw TypeError(it + ' is not a function!');
	  return it;
	};

/***/ },
/* 18 */
/***/ function(module, exports, __webpack_require__) {

	var dP         = __webpack_require__(19)
	  , createDesc = __webpack_require__(27);
	module.exports = __webpack_require__(23) ? function(object, key, value){
	  return dP.f(object, key, createDesc(1, value));
	} : function(object, key, value){
	  object[key] = value;
	  return object;
	};

/***/ },
/* 19 */
/***/ function(module, exports, __webpack_require__) {

	var anObject       = __webpack_require__(20)
	  , IE8_DOM_DEFINE = __webpack_require__(22)
	  , toPrimitive    = __webpack_require__(26)
	  , dP             = Object.defineProperty;
	
	exports.f = __webpack_require__(23) ? Object.defineProperty : function defineProperty(O, P, Attributes){
	  anObject(O);
	  P = toPrimitive(P, true);
	  anObject(Attributes);
	  if(IE8_DOM_DEFINE)try {
	    return dP(O, P, Attributes);
	  } catch(e){ /* empty */ }
	  if('get' in Attributes || 'set' in Attributes)throw TypeError('Accessors not supported!');
	  if('value' in Attributes)O[P] = Attributes.value;
	  return O;
	};

/***/ },
/* 20 */
/***/ function(module, exports, __webpack_require__) {

	var isObject = __webpack_require__(21);
	module.exports = function(it){
	  if(!isObject(it))throw TypeError(it + ' is not an object!');
	  return it;
	};

/***/ },
/* 21 */
/***/ function(module, exports) {

	module.exports = function(it){
	  return typeof it === 'object' ? it !== null : typeof it === 'function';
	};

/***/ },
/* 22 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = !__webpack_require__(23) && !__webpack_require__(24)(function(){
	  return Object.defineProperty(__webpack_require__(25)('div'), 'a', {get: function(){ return 7; }}).a != 7;
	});

/***/ },
/* 23 */
/***/ function(module, exports, __webpack_require__) {

	// Thank's IE8 for his funny defineProperty
	module.exports = !__webpack_require__(24)(function(){
	  return Object.defineProperty({}, 'a', {get: function(){ return 7; }}).a != 7;
	});

/***/ },
/* 24 */
/***/ function(module, exports) {

	module.exports = function(exec){
	  try {
	    return !!exec();
	  } catch(e){
	    return true;
	  }
	};

/***/ },
/* 25 */
/***/ function(module, exports, __webpack_require__) {

	var isObject = __webpack_require__(21)
	  , document = __webpack_require__(14).document
	  // in old IE typeof document.createElement is 'object'
	  , is = isObject(document) && isObject(document.createElement);
	module.exports = function(it){
	  return is ? document.createElement(it) : {};
	};

/***/ },
/* 26 */
/***/ function(module, exports, __webpack_require__) {

	// 7.1.1 ToPrimitive(input [, PreferredType])
	var isObject = __webpack_require__(21);
	// instead of the ES6 spec version, we didn't implement @@toPrimitive case
	// and the second argument - flag - preferred type is a string
	module.exports = function(it, S){
	  if(!isObject(it))return it;
	  var fn, val;
	  if(S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it)))return val;
	  if(typeof (fn = it.valueOf) == 'function' && !isObject(val = fn.call(it)))return val;
	  if(!S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it)))return val;
	  throw TypeError("Can't convert object to primitive value");
	};

/***/ },
/* 27 */
/***/ function(module, exports) {

	module.exports = function(bitmap, value){
	  return {
	    enumerable  : !(bitmap & 1),
	    configurable: !(bitmap & 2),
	    writable    : !(bitmap & 4),
	    value       : value
	  };
	};

/***/ },
/* 28 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(18);

/***/ },
/* 29 */
/***/ function(module, exports) {

	var hasOwnProperty = {}.hasOwnProperty;
	module.exports = function(it, key){
	  return hasOwnProperty.call(it, key);
	};

/***/ },
/* 30 */
/***/ function(module, exports) {

	module.exports = {};

/***/ },
/* 31 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var create         = __webpack_require__(32)
	  , descriptor     = __webpack_require__(27)
	  , setToStringTag = __webpack_require__(47)
	  , IteratorPrototype = {};
	
	// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()
	__webpack_require__(18)(IteratorPrototype, __webpack_require__(48)('iterator'), function(){ return this; });
	
	module.exports = function(Constructor, NAME, next){
	  Constructor.prototype = create(IteratorPrototype, {next: descriptor(1, next)});
	  setToStringTag(Constructor, NAME + ' Iterator');
	};

/***/ },
/* 32 */
/***/ function(module, exports, __webpack_require__) {

	// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
	var anObject    = __webpack_require__(20)
	  , dPs         = __webpack_require__(33)
	  , enumBugKeys = __webpack_require__(45)
	  , IE_PROTO    = __webpack_require__(42)('IE_PROTO')
	  , Empty       = function(){ /* empty */ }
	  , PROTOTYPE   = 'prototype';
	
	// Create object with fake `null` prototype: use iframe Object with cleared prototype
	var createDict = function(){
	  // Thrash, waste and sodomy: IE GC bug
	  var iframe = __webpack_require__(25)('iframe')
	    , i      = enumBugKeys.length
	    , gt     = '>'
	    , iframeDocument;
	  iframe.style.display = 'none';
	  __webpack_require__(46).appendChild(iframe);
	  iframe.src = 'javascript:'; // eslint-disable-line no-script-url
	  // createDict = iframe.contentWindow.Object;
	  // html.removeChild(iframe);
	  iframeDocument = iframe.contentWindow.document;
	  iframeDocument.open();
	  iframeDocument.write('<script>document.F=Object</script' + gt);
	  iframeDocument.close();
	  createDict = iframeDocument.F;
	  while(i--)delete createDict[PROTOTYPE][enumBugKeys[i]];
	  return createDict();
	};
	
	module.exports = Object.create || function create(O, Properties){
	  var result;
	  if(O !== null){
	    Empty[PROTOTYPE] = anObject(O);
	    result = new Empty;
	    Empty[PROTOTYPE] = null;
	    // add "__proto__" for Object.getPrototypeOf polyfill
	    result[IE_PROTO] = O;
	  } else result = createDict();
	  return Properties === undefined ? result : dPs(result, Properties);
	};

/***/ },
/* 33 */
/***/ function(module, exports, __webpack_require__) {

	var dP       = __webpack_require__(19)
	  , anObject = __webpack_require__(20)
	  , getKeys  = __webpack_require__(34);
	
	module.exports = __webpack_require__(23) ? Object.defineProperties : function defineProperties(O, Properties){
	  anObject(O);
	  var keys   = getKeys(Properties)
	    , length = keys.length
	    , i = 0
	    , P;
	  while(length > i)dP.f(O, P = keys[i++], Properties[P]);
	  return O;
	};

/***/ },
/* 34 */
/***/ function(module, exports, __webpack_require__) {

	// 19.1.2.14 / 15.2.3.14 Object.keys(O)
	var $keys       = __webpack_require__(35)
	  , enumBugKeys = __webpack_require__(45);
	
	module.exports = Object.keys || function keys(O){
	  return $keys(O, enumBugKeys);
	};

/***/ },
/* 35 */
/***/ function(module, exports, __webpack_require__) {

	var has          = __webpack_require__(29)
	  , toIObject    = __webpack_require__(36)
	  , arrayIndexOf = __webpack_require__(39)(false)
	  , IE_PROTO     = __webpack_require__(42)('IE_PROTO');
	
	module.exports = function(object, names){
	  var O      = toIObject(object)
	    , i      = 0
	    , result = []
	    , key;
	  for(key in O)if(key != IE_PROTO)has(O, key) && result.push(key);
	  // Don't enum bug & hidden keys
	  while(names.length > i)if(has(O, key = names[i++])){
	    ~arrayIndexOf(result, key) || result.push(key);
	  }
	  return result;
	};

/***/ },
/* 36 */
/***/ function(module, exports, __webpack_require__) {

	// to indexed object, toObject with fallback for non-array-like ES3 strings
	var IObject = __webpack_require__(37)
	  , defined = __webpack_require__(10);
	module.exports = function(it){
	  return IObject(defined(it));
	};

/***/ },
/* 37 */
/***/ function(module, exports, __webpack_require__) {

	// fallback for non-array-like ES3 and non-enumerable old V8 strings
	var cof = __webpack_require__(38);
	module.exports = Object('z').propertyIsEnumerable(0) ? Object : function(it){
	  return cof(it) == 'String' ? it.split('') : Object(it);
	};

/***/ },
/* 38 */
/***/ function(module, exports) {

	var toString = {}.toString;
	
	module.exports = function(it){
	  return toString.call(it).slice(8, -1);
	};

/***/ },
/* 39 */
/***/ function(module, exports, __webpack_require__) {

	// false -> Array#indexOf
	// true  -> Array#includes
	var toIObject = __webpack_require__(36)
	  , toLength  = __webpack_require__(40)
	  , toIndex   = __webpack_require__(41);
	module.exports = function(IS_INCLUDES){
	  return function($this, el, fromIndex){
	    var O      = toIObject($this)
	      , length = toLength(O.length)
	      , index  = toIndex(fromIndex, length)
	      , value;
	    // Array#includes uses SameValueZero equality algorithm
	    if(IS_INCLUDES && el != el)while(length > index){
	      value = O[index++];
	      if(value != value)return true;
	    // Array#toIndex ignores holes, Array#includes - not
	    } else for(;length > index; index++)if(IS_INCLUDES || index in O){
	      if(O[index] === el)return IS_INCLUDES || index || 0;
	    } return !IS_INCLUDES && -1;
	  };
	};

/***/ },
/* 40 */
/***/ function(module, exports, __webpack_require__) {

	// 7.1.15 ToLength
	var toInteger = __webpack_require__(9)
	  , min       = Math.min;
	module.exports = function(it){
	  return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991
	};

/***/ },
/* 41 */
/***/ function(module, exports, __webpack_require__) {

	var toInteger = __webpack_require__(9)
	  , max       = Math.max
	  , min       = Math.min;
	module.exports = function(index, length){
	  index = toInteger(index);
	  return index < 0 ? max(index + length, 0) : min(index, length);
	};

/***/ },
/* 42 */
/***/ function(module, exports, __webpack_require__) {

	var shared = __webpack_require__(43)('keys')
	  , uid    = __webpack_require__(44);
	module.exports = function(key){
	  return shared[key] || (shared[key] = uid(key));
	};

/***/ },
/* 43 */
/***/ function(module, exports, __webpack_require__) {

	var global = __webpack_require__(14)
	  , SHARED = '__core-js_shared__'
	  , store  = global[SHARED] || (global[SHARED] = {});
	module.exports = function(key){
	  return store[key] || (store[key] = {});
	};

/***/ },
/* 44 */
/***/ function(module, exports) {

	var id = 0
	  , px = Math.random();
	module.exports = function(key){
	  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));
	};

/***/ },
/* 45 */
/***/ function(module, exports) {

	// IE 8- don't enum bug keys
	module.exports = (
	  'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'
	).split(',');

/***/ },
/* 46 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(14).document && document.documentElement;

/***/ },
/* 47 */
/***/ function(module, exports, __webpack_require__) {

	var def = __webpack_require__(19).f
	  , has = __webpack_require__(29)
	  , TAG = __webpack_require__(48)('toStringTag');
	
	module.exports = function(it, tag, stat){
	  if(it && !has(it = stat ? it : it.prototype, TAG))def(it, TAG, {configurable: true, value: tag});
	};

/***/ },
/* 48 */
/***/ function(module, exports, __webpack_require__) {

	var store      = __webpack_require__(43)('wks')
	  , uid        = __webpack_require__(44)
	  , Symbol     = __webpack_require__(14).Symbol
	  , USE_SYMBOL = typeof Symbol == 'function';
	
	var $exports = module.exports = function(name){
	  return store[name] || (store[name] =
	    USE_SYMBOL && Symbol[name] || (USE_SYMBOL ? Symbol : uid)('Symbol.' + name));
	};
	
	$exports.store = store;

/***/ },
/* 49 */
/***/ function(module, exports, __webpack_require__) {

	// 19.1.2.9 / 15.2.3.2 Object.getPrototypeOf(O)
	var has         = __webpack_require__(29)
	  , toObject    = __webpack_require__(50)
	  , IE_PROTO    = __webpack_require__(42)('IE_PROTO')
	  , ObjectProto = Object.prototype;
	
	module.exports = Object.getPrototypeOf || function(O){
	  O = toObject(O);
	  if(has(O, IE_PROTO))return O[IE_PROTO];
	  if(typeof O.constructor == 'function' && O instanceof O.constructor){
	    return O.constructor.prototype;
	  } return O instanceof Object ? ObjectProto : null;
	};

/***/ },
/* 50 */
/***/ function(module, exports, __webpack_require__) {

	// 7.1.13 ToObject(argument)
	var defined = __webpack_require__(10);
	module.exports = function(it){
	  return Object(defined(it));
	};

/***/ },
/* 51 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(52);
	var global        = __webpack_require__(14)
	  , hide          = __webpack_require__(18)
	  , Iterators     = __webpack_require__(30)
	  , TO_STRING_TAG = __webpack_require__(48)('toStringTag');
	
	for(var collections = ['NodeList', 'DOMTokenList', 'MediaList', 'StyleSheetList', 'CSSRuleList'], i = 0; i < 5; i++){
	  var NAME       = collections[i]
	    , Collection = global[NAME]
	    , proto      = Collection && Collection.prototype;
	  if(proto && !proto[TO_STRING_TAG])hide(proto, TO_STRING_TAG, NAME);
	  Iterators[NAME] = Iterators.Array;
	}

/***/ },
/* 52 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var addToUnscopables = __webpack_require__(53)
	  , step             = __webpack_require__(54)
	  , Iterators        = __webpack_require__(30)
	  , toIObject        = __webpack_require__(36);
	
	// 22.1.3.4 Array.prototype.entries()
	// 22.1.3.13 Array.prototype.keys()
	// 22.1.3.29 Array.prototype.values()
	// 22.1.3.30 Array.prototype[@@iterator]()
	module.exports = __webpack_require__(11)(Array, 'Array', function(iterated, kind){
	  this._t = toIObject(iterated); // target
	  this._i = 0;                   // next index
	  this._k = kind;                // kind
	// 22.1.5.2.1 %ArrayIteratorPrototype%.next()
	}, function(){
	  var O     = this._t
	    , kind  = this._k
	    , index = this._i++;
	  if(!O || index >= O.length){
	    this._t = undefined;
	    return step(1);
	  }
	  if(kind == 'keys'  )return step(0, index);
	  if(kind == 'values')return step(0, O[index]);
	  return step(0, [index, O[index]]);
	}, 'values');
	
	// argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7)
	Iterators.Arguments = Iterators.Array;
	
	addToUnscopables('keys');
	addToUnscopables('values');
	addToUnscopables('entries');

/***/ },
/* 53 */
/***/ function(module, exports) {

	module.exports = function(){ /* empty */ };

/***/ },
/* 54 */
/***/ function(module, exports) {

	module.exports = function(done, value){
	  return {value: value, done: !!done};
	};

/***/ },
/* 55 */
/***/ function(module, exports, __webpack_require__) {

	exports.f = __webpack_require__(48);

/***/ },
/* 56 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(57), __esModule: true };

/***/ },
/* 57 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(58);
	__webpack_require__(69);
	__webpack_require__(70);
	__webpack_require__(71);
	module.exports = __webpack_require__(15).Symbol;

/***/ },
/* 58 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// ECMAScript 6 symbols shim
	var global         = __webpack_require__(14)
	  , has            = __webpack_require__(29)
	  , DESCRIPTORS    = __webpack_require__(23)
	  , $export        = __webpack_require__(13)
	  , redefine       = __webpack_require__(28)
	  , META           = __webpack_require__(59).KEY
	  , $fails         = __webpack_require__(24)
	  , shared         = __webpack_require__(43)
	  , setToStringTag = __webpack_require__(47)
	  , uid            = __webpack_require__(44)
	  , wks            = __webpack_require__(48)
	  , wksExt         = __webpack_require__(55)
	  , wksDefine      = __webpack_require__(60)
	  , keyOf          = __webpack_require__(61)
	  , enumKeys       = __webpack_require__(62)
	  , isArray        = __webpack_require__(65)
	  , anObject       = __webpack_require__(20)
	  , toIObject      = __webpack_require__(36)
	  , toPrimitive    = __webpack_require__(26)
	  , createDesc     = __webpack_require__(27)
	  , _create        = __webpack_require__(32)
	  , gOPNExt        = __webpack_require__(66)
	  , $GOPD          = __webpack_require__(68)
	  , $DP            = __webpack_require__(19)
	  , $keys          = __webpack_require__(34)
	  , gOPD           = $GOPD.f
	  , dP             = $DP.f
	  , gOPN           = gOPNExt.f
	  , $Symbol        = global.Symbol
	  , $JSON          = global.JSON
	  , _stringify     = $JSON && $JSON.stringify
	  , PROTOTYPE      = 'prototype'
	  , HIDDEN         = wks('_hidden')
	  , TO_PRIMITIVE   = wks('toPrimitive')
	  , isEnum         = {}.propertyIsEnumerable
	  , SymbolRegistry = shared('symbol-registry')
	  , AllSymbols     = shared('symbols')
	  , OPSymbols      = shared('op-symbols')
	  , ObjectProto    = Object[PROTOTYPE]
	  , USE_NATIVE     = typeof $Symbol == 'function'
	  , QObject        = global.QObject;
	// Don't use setters in Qt Script, https://github.com/zloirock/core-js/issues/173
	var setter = !QObject || !QObject[PROTOTYPE] || !QObject[PROTOTYPE].findChild;
	
	// fallback for old Android, https://code.google.com/p/v8/issues/detail?id=687
	var setSymbolDesc = DESCRIPTORS && $fails(function(){
	  return _create(dP({}, 'a', {
	    get: function(){ return dP(this, 'a', {value: 7}).a; }
	  })).a != 7;
	}) ? function(it, key, D){
	  var protoDesc = gOPD(ObjectProto, key);
	  if(protoDesc)delete ObjectProto[key];
	  dP(it, key, D);
	  if(protoDesc && it !== ObjectProto)dP(ObjectProto, key, protoDesc);
	} : dP;
	
	var wrap = function(tag){
	  var sym = AllSymbols[tag] = _create($Symbol[PROTOTYPE]);
	  sym._k = tag;
	  return sym;
	};
	
	var isSymbol = USE_NATIVE && typeof $Symbol.iterator == 'symbol' ? function(it){
	  return typeof it == 'symbol';
	} : function(it){
	  return it instanceof $Symbol;
	};
	
	var $defineProperty = function defineProperty(it, key, D){
	  if(it === ObjectProto)$defineProperty(OPSymbols, key, D);
	  anObject(it);
	  key = toPrimitive(key, true);
	  anObject(D);
	  if(has(AllSymbols, key)){
	    if(!D.enumerable){
	      if(!has(it, HIDDEN))dP(it, HIDDEN, createDesc(1, {}));
	      it[HIDDEN][key] = true;
	    } else {
	      if(has(it, HIDDEN) && it[HIDDEN][key])it[HIDDEN][key] = false;
	      D = _create(D, {enumerable: createDesc(0, false)});
	    } return setSymbolDesc(it, key, D);
	  } return dP(it, key, D);
	};
	var $defineProperties = function defineProperties(it, P){
	  anObject(it);
	  var keys = enumKeys(P = toIObject(P))
	    , i    = 0
	    , l = keys.length
	    , key;
	  while(l > i)$defineProperty(it, key = keys[i++], P[key]);
	  return it;
	};
	var $create = function create(it, P){
	  return P === undefined ? _create(it) : $defineProperties(_create(it), P);
	};
	var $propertyIsEnumerable = function propertyIsEnumerable(key){
	  var E = isEnum.call(this, key = toPrimitive(key, true));
	  if(this === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key))return false;
	  return E || !has(this, key) || !has(AllSymbols, key) || has(this, HIDDEN) && this[HIDDEN][key] ? E : true;
	};
	var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(it, key){
	  it  = toIObject(it);
	  key = toPrimitive(key, true);
	  if(it === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key))return;
	  var D = gOPD(it, key);
	  if(D && has(AllSymbols, key) && !(has(it, HIDDEN) && it[HIDDEN][key]))D.enumerable = true;
	  return D;
	};
	var $getOwnPropertyNames = function getOwnPropertyNames(it){
	  var names  = gOPN(toIObject(it))
	    , result = []
	    , i      = 0
	    , key;
	  while(names.length > i){
	    if(!has(AllSymbols, key = names[i++]) && key != HIDDEN && key != META)result.push(key);
	  } return result;
	};
	var $getOwnPropertySymbols = function getOwnPropertySymbols(it){
	  var IS_OP  = it === ObjectProto
	    , names  = gOPN(IS_OP ? OPSymbols : toIObject(it))
	    , result = []
	    , i      = 0
	    , key;
	  while(names.length > i){
	    if(has(AllSymbols, key = names[i++]) && (IS_OP ? has(ObjectProto, key) : true))result.push(AllSymbols[key]);
	  } return result;
	};
	
	// 19.4.1.1 Symbol([description])
	if(!USE_NATIVE){
	  $Symbol = function Symbol(){
	    if(this instanceof $Symbol)throw TypeError('Symbol is not a constructor!');
	    var tag = uid(arguments.length > 0 ? arguments[0] : undefined);
	    var $set = function(value){
	      if(this === ObjectProto)$set.call(OPSymbols, value);
	      if(has(this, HIDDEN) && has(this[HIDDEN], tag))this[HIDDEN][tag] = false;
	      setSymbolDesc(this, tag, createDesc(1, value));
	    };
	    if(DESCRIPTORS && setter)setSymbolDesc(ObjectProto, tag, {configurable: true, set: $set});
	    return wrap(tag);
	  };
	  redefine($Symbol[PROTOTYPE], 'toString', function toString(){
	    return this._k;
	  });
	
	  $GOPD.f = $getOwnPropertyDescriptor;
	  $DP.f   = $defineProperty;
	  __webpack_require__(67).f = gOPNExt.f = $getOwnPropertyNames;
	  __webpack_require__(64).f  = $propertyIsEnumerable;
	  __webpack_require__(63).f = $getOwnPropertySymbols;
	
	  if(DESCRIPTORS && !__webpack_require__(12)){
	    redefine(ObjectProto, 'propertyIsEnumerable', $propertyIsEnumerable, true);
	  }
	
	  wksExt.f = function(name){
	    return wrap(wks(name));
	  }
	}
	
	$export($export.G + $export.W + $export.F * !USE_NATIVE, {Symbol: $Symbol});
	
	for(var symbols = (
	  // 19.4.2.2, 19.4.2.3, 19.4.2.4, 19.4.2.6, 19.4.2.8, 19.4.2.9, 19.4.2.10, 19.4.2.11, 19.4.2.12, 19.4.2.13, 19.4.2.14
	  'hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables'
	).split(','), i = 0; symbols.length > i; )wks(symbols[i++]);
	
	for(var symbols = $keys(wks.store), i = 0; symbols.length > i; )wksDefine(symbols[i++]);
	
	$export($export.S + $export.F * !USE_NATIVE, 'Symbol', {
	  // 19.4.2.1 Symbol.for(key)
	  'for': function(key){
	    return has(SymbolRegistry, key += '')
	      ? SymbolRegistry[key]
	      : SymbolRegistry[key] = $Symbol(key);
	  },
	  // 19.4.2.5 Symbol.keyFor(sym)
	  keyFor: function keyFor(key){
	    if(isSymbol(key))return keyOf(SymbolRegistry, key);
	    throw TypeError(key + ' is not a symbol!');
	  },
	  useSetter: function(){ setter = true; },
	  useSimple: function(){ setter = false; }
	});
	
	$export($export.S + $export.F * !USE_NATIVE, 'Object', {
	  // 19.1.2.2 Object.create(O [, Properties])
	  create: $create,
	  // 19.1.2.4 Object.defineProperty(O, P, Attributes)
	  defineProperty: $defineProperty,
	  // 19.1.2.3 Object.defineProperties(O, Properties)
	  defineProperties: $defineProperties,
	  // 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
	  getOwnPropertyDescriptor: $getOwnPropertyDescriptor,
	  // 19.1.2.7 Object.getOwnPropertyNames(O)
	  getOwnPropertyNames: $getOwnPropertyNames,
	  // 19.1.2.8 Object.getOwnPropertySymbols(O)
	  getOwnPropertySymbols: $getOwnPropertySymbols
	});
	
	// 24.3.2 JSON.stringify(value [, replacer [, space]])
	$JSON && $export($export.S + $export.F * (!USE_NATIVE || $fails(function(){
	  var S = $Symbol();
	  // MS Edge converts symbol values to JSON as {}
	  // WebKit converts symbol values to JSON as null
	  // V8 throws on boxed symbols
	  return _stringify([S]) != '[null]' || _stringify({a: S}) != '{}' || _stringify(Object(S)) != '{}';
	})), 'JSON', {
	  stringify: function stringify(it){
	    if(it === undefined || isSymbol(it))return; // IE8 returns string on undefined
	    var args = [it]
	      , i    = 1
	      , replacer, $replacer;
	    while(arguments.length > i)args.push(arguments[i++]);
	    replacer = args[1];
	    if(typeof replacer == 'function')$replacer = replacer;
	    if($replacer || !isArray(replacer))replacer = function(key, value){
	      if($replacer)value = $replacer.call(this, key, value);
	      if(!isSymbol(value))return value;
	    };
	    args[1] = replacer;
	    return _stringify.apply($JSON, args);
	  }
	});
	
	// 19.4.3.4 Symbol.prototype[@@toPrimitive](hint)
	$Symbol[PROTOTYPE][TO_PRIMITIVE] || __webpack_require__(18)($Symbol[PROTOTYPE], TO_PRIMITIVE, $Symbol[PROTOTYPE].valueOf);
	// 19.4.3.5 Symbol.prototype[@@toStringTag]
	setToStringTag($Symbol, 'Symbol');
	// 20.2.1.9 Math[@@toStringTag]
	setToStringTag(Math, 'Math', true);
	// 24.3.3 JSON[@@toStringTag]
	setToStringTag(global.JSON, 'JSON', true);

/***/ },
/* 59 */
/***/ function(module, exports, __webpack_require__) {

	var META     = __webpack_require__(44)('meta')
	  , isObject = __webpack_require__(21)
	  , has      = __webpack_require__(29)
	  , setDesc  = __webpack_require__(19).f
	  , id       = 0;
	var isExtensible = Object.isExtensible || function(){
	  return true;
	};
	var FREEZE = !__webpack_require__(24)(function(){
	  return isExtensible(Object.preventExtensions({}));
	});
	var setMeta = function(it){
	  setDesc(it, META, {value: {
	    i: 'O' + ++id, // object ID
	    w: {}          // weak collections IDs
	  }});
	};
	var fastKey = function(it, create){
	  // return primitive with prefix
	  if(!isObject(it))return typeof it == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;
	  if(!has(it, META)){
	    // can't set metadata to uncaught frozen object
	    if(!isExtensible(it))return 'F';
	    // not necessary to add metadata
	    if(!create)return 'E';
	    // add missing metadata
	    setMeta(it);
	  // return object ID
	  } return it[META].i;
	};
	var getWeak = function(it, create){
	  if(!has(it, META)){
	    // can't set metadata to uncaught frozen object
	    if(!isExtensible(it))return true;
	    // not necessary to add metadata
	    if(!create)return false;
	    // add missing metadata
	    setMeta(it);
	  // return hash weak collections IDs
	  } return it[META].w;
	};
	// add metadata on freeze-family methods calling
	var onFreeze = function(it){
	  if(FREEZE && meta.NEED && isExtensible(it) && !has(it, META))setMeta(it);
	  return it;
	};
	var meta = module.exports = {
	  KEY:      META,
	  NEED:     false,
	  fastKey:  fastKey,
	  getWeak:  getWeak,
	  onFreeze: onFreeze
	};

/***/ },
/* 60 */
/***/ function(module, exports, __webpack_require__) {

	var global         = __webpack_require__(14)
	  , core           = __webpack_require__(15)
	  , LIBRARY        = __webpack_require__(12)
	  , wksExt         = __webpack_require__(55)
	  , defineProperty = __webpack_require__(19).f;
	module.exports = function(name){
	  var $Symbol = core.Symbol || (core.Symbol = LIBRARY ? {} : global.Symbol || {});
	  if(name.charAt(0) != '_' && !(name in $Symbol))defineProperty($Symbol, name, {value: wksExt.f(name)});
	};

/***/ },
/* 61 */
/***/ function(module, exports, __webpack_require__) {

	var getKeys   = __webpack_require__(34)
	  , toIObject = __webpack_require__(36);
	module.exports = function(object, el){
	  var O      = toIObject(object)
	    , keys   = getKeys(O)
	    , length = keys.length
	    , index  = 0
	    , key;
	  while(length > index)if(O[key = keys[index++]] === el)return key;
	};

/***/ },
/* 62 */
/***/ function(module, exports, __webpack_require__) {

	// all enumerable object keys, includes symbols
	var getKeys = __webpack_require__(34)
	  , gOPS    = __webpack_require__(63)
	  , pIE     = __webpack_require__(64);
	module.exports = function(it){
	  var result     = getKeys(it)
	    , getSymbols = gOPS.f;
	  if(getSymbols){
	    var symbols = getSymbols(it)
	      , isEnum  = pIE.f
	      , i       = 0
	      , key;
	    while(symbols.length > i)if(isEnum.call(it, key = symbols[i++]))result.push(key);
	  } return result;
	};

/***/ },
/* 63 */
/***/ function(module, exports) {

	exports.f = Object.getOwnPropertySymbols;

/***/ },
/* 64 */
/***/ function(module, exports) {

	exports.f = {}.propertyIsEnumerable;

/***/ },
/* 65 */
/***/ function(module, exports, __webpack_require__) {

	// 7.2.2 IsArray(argument)
	var cof = __webpack_require__(38);
	module.exports = Array.isArray || function isArray(arg){
	  return cof(arg) == 'Array';
	};

/***/ },
/* 66 */
/***/ function(module, exports, __webpack_require__) {

	// fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window
	var toIObject = __webpack_require__(36)
	  , gOPN      = __webpack_require__(67).f
	  , toString  = {}.toString;
	
	var windowNames = typeof window == 'object' && window && Object.getOwnPropertyNames
	  ? Object.getOwnPropertyNames(window) : [];
	
	var getWindowNames = function(it){
	  try {
	    return gOPN(it);
	  } catch(e){
	    return windowNames.slice();
	  }
	};
	
	module.exports.f = function getOwnPropertyNames(it){
	  return windowNames && toString.call(it) == '[object Window]' ? getWindowNames(it) : gOPN(toIObject(it));
	};


/***/ },
/* 67 */
/***/ function(module, exports, __webpack_require__) {

	// 19.1.2.7 / 15.2.3.4 Object.getOwnPropertyNames(O)
	var $keys      = __webpack_require__(35)
	  , hiddenKeys = __webpack_require__(45).concat('length', 'prototype');
	
	exports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O){
	  return $keys(O, hiddenKeys);
	};

/***/ },
/* 68 */
/***/ function(module, exports, __webpack_require__) {

	var pIE            = __webpack_require__(64)
	  , createDesc     = __webpack_require__(27)
	  , toIObject      = __webpack_require__(36)
	  , toPrimitive    = __webpack_require__(26)
	  , has            = __webpack_require__(29)
	  , IE8_DOM_DEFINE = __webpack_require__(22)
	  , gOPD           = Object.getOwnPropertyDescriptor;
	
	exports.f = __webpack_require__(23) ? gOPD : function getOwnPropertyDescriptor(O, P){
	  O = toIObject(O);
	  P = toPrimitive(P, true);
	  if(IE8_DOM_DEFINE)try {
	    return gOPD(O, P);
	  } catch(e){ /* empty */ }
	  if(has(O, P))return createDesc(!pIE.f.call(O, P), O[P]);
	};

/***/ },
/* 69 */
/***/ function(module, exports) {



/***/ },
/* 70 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(60)('asyncIterator');

/***/ },
/* 71 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(60)('observable');

/***/ },
/* 72 */
/***/ function(module, exports) {

	/* WEBPACK VAR INJECTION */(function(__webpack_amd_options__) {module.exports = __webpack_amd_options__;
	
	/* WEBPACK VAR INJECTION */}.call(exports, {}))

/***/ },
/* 73 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(74), __esModule: true };

/***/ },
/* 74 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(75);
	module.exports = __webpack_require__(15).Object.keys;

/***/ },
/* 75 */
/***/ function(module, exports, __webpack_require__) {

	// 19.1.2.14 Object.keys(O)
	var toObject = __webpack_require__(50)
	  , $keys    = __webpack_require__(34);
	
	__webpack_require__(76)('keys', function(){
	  return function keys(it){
	    return $keys(toObject(it));
	  };
	});

/***/ },
/* 76 */
/***/ function(module, exports, __webpack_require__) {

	// most Object methods by ES6 should accept primitives
	var $export = __webpack_require__(13)
	  , core    = __webpack_require__(15)
	  , fails   = __webpack_require__(24);
	module.exports = function(KEY, exec){
	  var fn  = (core.Object || {})[KEY] || Object[KEY]
	    , exp = {};
	  exp[KEY] = exec(fn);
	  $export($export.S + $export.F * fails(function(){ fn(1); }), 'Object', exp);
	};

/***/ },
/* 77 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	exports.__esModule = true;
	
	var _isIterable2 = __webpack_require__(78);
	
	var _isIterable3 = _interopRequireDefault(_isIterable2);
	
	var _getIterator2 = __webpack_require__(82);
	
	var _getIterator3 = _interopRequireDefault(_getIterator2);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = function () {
	  function sliceIterator(arr, i) {
	    var _arr = [];
	    var _n = true;
	    var _d = false;
	    var _e = undefined;
	
	    try {
	      for (var _i = (0, _getIterator3.default)(arr), _s; !(_n = (_s = _i.next()).done); _n = true) {
	        _arr.push(_s.value);
	
	        if (i && _arr.length === i) break;
	      }
	    } catch (err) {
	      _d = true;
	      _e = err;
	    } finally {
	      try {
	        if (!_n && _i["return"]) _i["return"]();
	      } finally {
	        if (_d) throw _e;
	      }
	    }
	
	    return _arr;
	  }
	
	  return function (arr, i) {
	    if (Array.isArray(arr)) {
	      return arr;
	    } else if ((0, _isIterable3.default)(Object(arr))) {
	      return sliceIterator(arr, i);
	    } else {
	      throw new TypeError("Invalid attempt to destructure non-iterable instance");
	    }
	  };
	}();

/***/ },
/* 78 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(79), __esModule: true };

/***/ },
/* 79 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(51);
	__webpack_require__(7);
	module.exports = __webpack_require__(80);

/***/ },
/* 80 */
/***/ function(module, exports, __webpack_require__) {

	var classof   = __webpack_require__(81)
	  , ITERATOR  = __webpack_require__(48)('iterator')
	  , Iterators = __webpack_require__(30);
	module.exports = __webpack_require__(15).isIterable = function(it){
	  var O = Object(it);
	  return O[ITERATOR] !== undefined
	    || '@@iterator' in O
	    || Iterators.hasOwnProperty(classof(O));
	};

/***/ },
/* 81 */
/***/ function(module, exports, __webpack_require__) {

	// getting tag from 19.1.3.6 Object.prototype.toString()
	var cof = __webpack_require__(38)
	  , TAG = __webpack_require__(48)('toStringTag')
	  // ES3 wrong here
	  , ARG = cof(function(){ return arguments; }()) == 'Arguments';
	
	// fallback for IE11 Script Access Denied error
	var tryGet = function(it, key){
	  try {
	    return it[key];
	  } catch(e){ /* empty */ }
	};
	
	module.exports = function(it){
	  var O, T, B;
	  return it === undefined ? 'Undefined' : it === null ? 'Null'
	    // @@toStringTag case
	    : typeof (T = tryGet(O = Object(it), TAG)) == 'string' ? T
	    // builtinTag case
	    : ARG ? cof(O)
	    // ES3 arguments fallback
	    : (B = cof(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : B;
	};

/***/ },
/* 82 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(83), __esModule: true };

/***/ },
/* 83 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(51);
	__webpack_require__(7);
	module.exports = __webpack_require__(84);

/***/ },
/* 84 */
/***/ function(module, exports, __webpack_require__) {

	var anObject = __webpack_require__(20)
	  , get      = __webpack_require__(85);
	module.exports = __webpack_require__(15).getIterator = function(it){
	  var iterFn = get(it);
	  if(typeof iterFn != 'function')throw TypeError(it + ' is not iterable!');
	  return anObject(iterFn.call(it));
	};

/***/ },
/* 85 */
/***/ function(module, exports, __webpack_require__) {

	var classof   = __webpack_require__(81)
	  , ITERATOR  = __webpack_require__(48)('iterator')
	  , Iterators = __webpack_require__(30);
	module.exports = __webpack_require__(15).getIteratorMethod = function(it){
	  if(it != undefined)return it[ITERATOR]
	    || it['@@iterator']
	    || Iterators[classof(it)];
	};

/***/ },
/* 86 */
/***/ function(module, exports) {

	"use strict";
	
	exports.__esModule = true;
	
	exports.default = function (instance, Constructor) {
	  if (!(instance instanceof Constructor)) {
	    throw new TypeError("Cannot call a class as a function");
	  }
	};

/***/ },
/* 87 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	exports.__esModule = true;
	
	var _defineProperty = __webpack_require__(88);
	
	var _defineProperty2 = _interopRequireDefault(_defineProperty);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = function () {
	  function defineProperties(target, props) {
	    for (var i = 0; i < props.length; i++) {
	      var descriptor = props[i];
	      descriptor.enumerable = descriptor.enumerable || false;
	      descriptor.configurable = true;
	      if ("value" in descriptor) descriptor.writable = true;
	      (0, _defineProperty2.default)(target, descriptor.key, descriptor);
	    }
	  }
	
	  return function (Constructor, protoProps, staticProps) {
	    if (protoProps) defineProperties(Constructor.prototype, protoProps);
	    if (staticProps) defineProperties(Constructor, staticProps);
	    return Constructor;
	  };
	}();

/***/ },
/* 88 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(89), __esModule: true };

/***/ },
/* 89 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(90);
	var $Object = __webpack_require__(15).Object;
	module.exports = function defineProperty(it, key, desc){
	  return $Object.defineProperty(it, key, desc);
	};

/***/ },
/* 90 */
/***/ function(module, exports, __webpack_require__) {

	var $export = __webpack_require__(13);
	// 19.1.2.4 / 15.2.3.6 Object.defineProperty(O, P, Attributes)
	$export($export.S + $export.F * !__webpack_require__(23), 'Object', {defineProperty: __webpack_require__(19).f});

/***/ },
/* 91 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	__webpack_require__(92);
	__webpack_require__(93);
	__webpack_require__(96);
	__webpack_require__(97);
	__webpack_require__(98);
	__webpack_require__(101);
	__webpack_require__(102);
	__webpack_require__(104);
	__webpack_require__(105);
	__webpack_require__(110);
	__webpack_require__(119);
	__webpack_require__(120);
	__webpack_require__(121);

/***/ },
/* 92 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(jQuery) {"use strict";
	
	var _defineProperty = __webpack_require__(88);
	
	var _defineProperty2 = _interopRequireDefault(_defineProperty);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/*! jQuery Migrate v1.3.0 | (c) jQuery Foundation and other contributors | jquery.org/license */
	"undefined" == typeof jQuery.migrateMute && (jQuery.migrateMute = !0), function (a, b, c) {
	  function d(c) {
	    var d = b.console;f[c] || (f[c] = !0, a.migrateWarnings.push(c), d && d.warn && !a.migrateMute && (d.warn("JQMIGRATE: " + c), a.migrateTrace && d.trace && d.trace()));
	  }function e(b, c, e, f) {
	    if (_defineProperty2.default) try {
	      return void (0, _defineProperty2.default)(b, c, { configurable: !0, enumerable: !0, get: function get() {
	          return d(f), e;
	        }, set: function set(a) {
	          d(f), e = a;
	        } });
	    } catch (g) {}a._definePropertyBroken = !0, b[c] = e;
	  }a.migrateVersion = "1.3.0";var f = {};a.migrateWarnings = [], !a.migrateMute && b.console && b.console.log && b.console.log("JQMIGRATE: Logging is active"), a.migrateTrace === c && (a.migrateTrace = !0), a.migrateReset = function () {
	    f = {}, a.migrateWarnings.length = 0;
	  }, "BackCompat" === document.compatMode && d("jQuery is not compatible with Quirks Mode");var g = a("<input/>", { size: 1 }).attr("size") && a.attrFn,
	      h = a.attr,
	      i = a.attrHooks.value && a.attrHooks.value.get || function () {
	    return null;
	  },
	      j = a.attrHooks.value && a.attrHooks.value.set || function () {
	    return c;
	  },
	      k = /^(?:input|button)$/i,
	      l = /^[238]$/,
	      m = /^(?:autofocus|autoplay|async|checked|controls|defer|disabled|hidden|loop|multiple|open|readonly|required|scoped|selected)$/i,
	      n = /^(?:checked|selected)$/i;e(a, "attrFn", g || {}, "jQuery.attrFn is deprecated"), a.attr = function (b, e, f, i) {
	    var j = e.toLowerCase(),
	        o = b && b.nodeType;return i && (h.length < 4 && d("jQuery.fn.attr( props, pass ) is deprecated"), b && !l.test(o) && (g ? e in g : a.isFunction(a.fn[e]))) ? a(b)[e](f) : ("type" === e && f !== c && k.test(b.nodeName) && b.parentNode && d("Can't change the 'type' of an input or button in IE 6/7/8"), !a.attrHooks[j] && m.test(j) && (a.attrHooks[j] = { get: function get(b, d) {
	        var e,
	            f = a.prop(b, d);return f === !0 || "boolean" != typeof f && (e = b.getAttributeNode(d)) && e.nodeValue !== !1 ? d.toLowerCase() : c;
	      }, set: function set(b, c, d) {
	        var e;return c === !1 ? a.removeAttr(b, d) : (e = a.propFix[d] || d, e in b && (b[e] = !0), b.setAttribute(d, d.toLowerCase())), d;
	      } }, n.test(j) && d("jQuery.fn.attr('" + j + "') might use property instead of attribute")), h.call(a, b, e, f));
	  }, a.attrHooks.value = { get: function get(a, b) {
	      var c = (a.nodeName || "").toLowerCase();return "button" === c ? i.apply(this, arguments) : ("input" !== c && "option" !== c && d("jQuery.fn.attr('value') no longer gets properties"), b in a ? a.value : null);
	    }, set: function set(a, b) {
	      var c = (a.nodeName || "").toLowerCase();return "button" === c ? j.apply(this, arguments) : ("input" !== c && "option" !== c && d("jQuery.fn.attr('value', val) no longer sets properties"), void (a.value = b));
	    } };var o,
	      p,
	      q = a.fn.init,
	      r = a.parseJSON,
	      s = /^\s*</,
	      t = /^([^<]*)(<[\w\W]+>)([^>]*)$/;a.fn.init = function (b, e, f) {
	    var g, h;return b && "string" == typeof b && !a.isPlainObject(e) && (g = t.exec(a.trim(b))) && g[0] && (s.test(b) || d("$(html) HTML strings must start with '<' character"), g[3] && d("$(html) HTML text after last tag is ignored"), "#" === g[0].charAt(0) && (d("HTML string cannot start with a '#' character"), a.error("JQMIGRATE: Invalid selector string (XSS)")), e && e.context && (e = e.context), a.parseHTML) ? q.call(this, a.parseHTML(g[2], e && e.ownerDocument || e || document, !0), e, f) : ("#" === b && (d("jQuery( '#' ) is not a valid selector"), b = []), h = q.apply(this, arguments), b && b.selector !== c ? (h.selector = b.selector, h.context = b.context) : (h.selector = "string" == typeof b ? b : "", b && (h.context = b.nodeType ? b : e || document)), h);
	  }, a.fn.init.prototype = a.fn, a.parseJSON = function (a) {
	    return a ? r.apply(this, arguments) : (d("jQuery.parseJSON requires a valid JSON string"), null);
	  }, a.uaMatch = function (a) {
	    a = a.toLowerCase();var b = /(chrome)[ \/]([\w.]+)/.exec(a) || /(webkit)[ \/]([\w.]+)/.exec(a) || /(opera)(?:.*version|)[ \/]([\w.]+)/.exec(a) || /(msie) ([\w.]+)/.exec(a) || a.indexOf("compatible") < 0 && /(mozilla)(?:.*? rv:([\w.]+)|)/.exec(a) || [];return { browser: b[1] || "", version: b[2] || "0" };
	  }, a.browser || (o = a.uaMatch(navigator.userAgent), p = {}, o.browser && (p[o.browser] = !0, p.version = o.version), p.chrome ? p.webkit = !0 : p.webkit && (p.safari = !0), a.browser = p), e(a, "browser", a.browser, "jQuery.browser is deprecated"), a.boxModel = a.support.boxModel = "CSS1Compat" === document.compatMode, e(a, "boxModel", a.boxModel, "jQuery.boxModel is deprecated"), e(a.support, "boxModel", a.support.boxModel, "jQuery.support.boxModel is deprecated"), a.sub = function () {
	    function b(a, c) {
	      return new b.fn.init(a, c);
	    }a.extend(!0, b, this), b.superclass = this, b.fn = b.prototype = this(), b.fn.constructor = b, b.sub = this.sub, b.fn.init = function (d, e) {
	      var f = a.fn.init.call(this, d, e, c);return f instanceof b ? f : b(f);
	    }, b.fn.init.prototype = b.fn;var c = b(document);return d("jQuery.sub() is deprecated"), b;
	  }, a.fn.size = function () {
	    return d("jQuery.fn.size() is deprecated; use the .length property"), this.length;
	  };var u = !1;a.swap && a.each(["height", "width", "reliableMarginRight"], function (b, c) {
	    var d = a.cssHooks[c] && a.cssHooks[c].get;d && (a.cssHooks[c].get = function () {
	      var a;return u = !0, a = d.apply(this, arguments), u = !1, a;
	    });
	  }), a.swap = function (a, b, c, e) {
	    var f,
	        g,
	        h = {};u || d("jQuery.swap() is undocumented and deprecated");for (g in b) {
	      h[g] = a.style[g], a.style[g] = b[g];
	    }f = c.apply(a, e || []);for (g in b) {
	      a.style[g] = h[g];
	    }return f;
	  }, a.ajaxSetup({ converters: { "text json": a.parseJSON } });var v = a.fn.data;a.fn.data = function (b) {
	    var e,
	        f,
	        g = this[0];return !g || "events" !== b || 1 !== arguments.length || (e = a.data(g, b), f = a._data(g, b), e !== c && e !== f || f === c) ? v.apply(this, arguments) : (d("Use of jQuery.fn.data('events') is deprecated"), f);
	  };var w = /\/(java|ecma)script/i;a.clean || (a.clean = function (b, c, e, f) {
	    c = c || document, c = !c.nodeType && c[0] || c, c = c.ownerDocument || c, d("jQuery.clean() is deprecated");var g,
	        h,
	        i,
	        j,
	        k = [];if (a.merge(k, a.buildFragment(b, c).childNodes), e) for (i = function i(a) {
	      return !a.type || w.test(a.type) ? f ? f.push(a.parentNode ? a.parentNode.removeChild(a) : a) : e.appendChild(a) : void 0;
	    }, g = 0; null != (h = k[g]); g++) {
	      a.nodeName(h, "script") && i(h) || (e.appendChild(h), "undefined" != typeof h.getElementsByTagName && (j = a.grep(a.merge([], h.getElementsByTagName("script")), i), k.splice.apply(k, [g + 1, 0].concat(j)), g += j.length));
	    }return k;
	  });var x = a.event.add,
	      y = a.event.remove,
	      z = a.event.trigger,
	      A = a.fn.toggle,
	      B = a.fn.live,
	      C = a.fn.die,
	      D = a.fn.load,
	      E = "ajaxStart|ajaxStop|ajaxSend|ajaxComplete|ajaxError|ajaxSuccess",
	      F = new RegExp("\\b(?:" + E + ")\\b"),
	      G = /(?:^|\s)hover(\.\S+|)\b/,
	      H = function H(b) {
	    return "string" != typeof b || a.event.special.hover ? b : (G.test(b) && d("'hover' pseudo-event is deprecated, use 'mouseenter mouseleave'"), b && b.replace(G, "mouseenter$1 mouseleave$1"));
	  };a.event.props && "attrChange" !== a.event.props[0] && a.event.props.unshift("attrChange", "attrName", "relatedNode", "srcElement"), a.event.dispatch && e(a.event, "handle", a.event.dispatch, "jQuery.event.handle is undocumented and deprecated"), a.event.add = function (a, b, c, e, f) {
	    a !== document && F.test(b) && d("AJAX events should be attached to document: " + b), x.call(this, a, H(b || ""), c, e, f);
	  }, a.event.remove = function (a, b, c, d, e) {
	    y.call(this, a, H(b) || "", c, d, e);
	  }, a.each(["load", "unload", "error"], function (b, c) {
	    a.fn[c] = function () {
	      var a = Array.prototype.slice.call(arguments, 0);return d("jQuery.fn." + c + "() is deprecated"), "load" === c && "string" == typeof arguments[0] ? D.apply(this, arguments) : (a.splice(0, 0, c), arguments.length ? this.bind.apply(this, a) : (this.triggerHandler.apply(this, a), this));
	    };
	  }), a.fn.toggle = function (b, c) {
	    if (!a.isFunction(b) || !a.isFunction(c)) return A.apply(this, arguments);d("jQuery.fn.toggle(handler, handler...) is deprecated");var e = arguments,
	        f = b.guid || a.guid++,
	        g = 0,
	        h = function h(c) {
	      var d = (a._data(this, "lastToggle" + b.guid) || 0) % g;return a._data(this, "lastToggle" + b.guid, d + 1), c.preventDefault(), e[d].apply(this, arguments) || !1;
	    };for (h.guid = f; g < e.length;) {
	      e[g++].guid = f;
	    }return this.click(h);
	  }, a.fn.live = function (b, c, e) {
	    return d("jQuery.fn.live() is deprecated"), B ? B.apply(this, arguments) : (a(this.context).on(b, this.selector, c, e), this);
	  }, a.fn.die = function (b, c) {
	    return d("jQuery.fn.die() is deprecated"), C ? C.apply(this, arguments) : (a(this.context).off(b, this.selector || "**", c), this);
	  }, a.event.trigger = function (a, b, c, e) {
	    return c || F.test(a) || d("Global events are undocumented and deprecated"), z.call(this, a, b, c || document, e);
	  }, a.each(E.split("|"), function (b, c) {
	    a.event.special[c] = { setup: function setup() {
	        var b = this;return b !== document && (a.event.add(document, c + "." + a.guid, function () {
	          a.event.trigger(c, Array.prototype.slice.call(arguments, 1), b, !0);
	        }), a._data(this, c, a.guid++)), !1;
	      }, teardown: function teardown() {
	        return this !== document && a.event.remove(document, c + "." + a._data(this, c)), !1;
	      } };
	  }), a.event.special.ready = { setup: function setup() {
	      d("'ready' event is deprecated");
	    } };var I = a.fn.andSelf || a.fn.addBack,
	      J = a.fn.find;if (a.fn.andSelf = function () {
	    return d("jQuery.fn.andSelf() replaced by jQuery.fn.addBack()"), I.apply(this, arguments);
	  }, a.fn.find = function (a) {
	    var b = J.apply(this, arguments);return b.context = this.context, b.selector = this.selector ? this.selector + " " + a : a, b;
	  }, a.Callbacks) {
	    var K = a.Deferred,
	        L = [["resolve", "done", a.Callbacks("once memory"), a.Callbacks("once memory"), "resolved"], ["reject", "fail", a.Callbacks("once memory"), a.Callbacks("once memory"), "rejected"], ["notify", "progress", a.Callbacks("memory"), a.Callbacks("memory")]];a.Deferred = function (b) {
	      var c = K(),
	          e = c.promise();return c.pipe = e.pipe = function () {
	        var b = arguments;return d("deferred.pipe() is deprecated"), a.Deferred(function (d) {
	          a.each(L, function (f, g) {
	            var h = a.isFunction(b[f]) && b[f];c[g[1]](function () {
	              var b = h && h.apply(this, arguments);b && a.isFunction(b.promise) ? b.promise().done(d.resolve).fail(d.reject).progress(d.notify) : d[g[0] + "With"](this === e ? d.promise() : this, h ? [b] : arguments);
	            });
	          }), b = null;
	        }).promise();
	      }, c.isResolved = function () {
	        return d("deferred.isResolved is deprecated"), "resolved" === c.state();
	      }, c.isRejected = function () {
	        return d("deferred.isRejected is deprecated"), "rejected" === c.state();
	      }, b && b.call(c, c), c;
	    };
	  }
	}(jQuery, window);
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ },
/* 93 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {module.exports = global["ko"] = __webpack_require__(94);
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 94 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/* WEBPACK VAR INJECTION */(function(module) {/*!
	 * Knockout JavaScript library v3.4.1
	 * (c) The Knockout.js team - http://knockoutjs.com/
	 * License: MIT (http://www.opensource.org/licenses/mit-license.php)
	 */
	
	(function(){
	var DEBUG=true;
	(function(undefined){
	    // (0, eval)('this') is a robust way of getting a reference to the global object
	    // For details, see http://stackoverflow.com/questions/14119988/return-this-0-evalthis/14120023#14120023
	    var window = this || (0, eval)('this'),
	        document = window['document'],
	        navigator = window['navigator'],
	        jQueryInstance = window["jQuery"],
	        JSON = window["JSON"];
	(function(factory) {
	    // Support three module loading scenarios
	    if ("function" === 'function' && __webpack_require__(95)['amd']) {
	        // [1] AMD anonymous module
	        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports, __webpack_require__], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	    } else if (true) {
	        // [2] CommonJS/Node.js
	        factory(module['exports'] || exports);  // module.exports is for Node.js
	    } else {
	        // [3] No module loader (plain <script> tag) - put directly in global namespace
	        factory(window['ko'] = {});
	    }
	}(function(koExports, amdRequire){
	// Internally, all KO objects are attached to koExports (even the non-exported ones whose names will be minified by the closure compiler).
	// In the future, the following "ko" variable may be made distinct from "koExports" so that private objects are not externally reachable.
	var ko = typeof koExports !== 'undefined' ? koExports : {};
	// Google Closure Compiler helpers (used only to make the minified file smaller)
	ko.exportSymbol = function(koPath, object) {
	    var tokens = koPath.split(".");
	
	    // In the future, "ko" may become distinct from "koExports" (so that non-exported objects are not reachable)
	    // At that point, "target" would be set to: (typeof koExports !== "undefined" ? koExports : ko)
	    var target = ko;
	
	    for (var i = 0; i < tokens.length - 1; i++)
	        target = target[tokens[i]];
	    target[tokens[tokens.length - 1]] = object;
	};
	ko.exportProperty = function(owner, publicName, object) {
	    owner[publicName] = object;
	};
	ko.version = "3.4.1";
	
	ko.exportSymbol('version', ko.version);
	// For any options that may affect various areas of Knockout and aren't directly associated with data binding.
	ko.options = {
	    'deferUpdates': false,
	    'useOnlyNativeEvents': false
	};
	
	//ko.exportSymbol('options', ko.options);   // 'options' isn't minified
	ko.utils = (function () {
	    function objectForEach(obj, action) {
	        for (var prop in obj) {
	            if (obj.hasOwnProperty(prop)) {
	                action(prop, obj[prop]);
	            }
	        }
	    }
	
	    function extend(target, source) {
	        if (source) {
	            for(var prop in source) {
	                if(source.hasOwnProperty(prop)) {
	                    target[prop] = source[prop];
	                }
	            }
	        }
	        return target;
	    }
	
	    function setPrototypeOf(obj, proto) {
	        obj.__proto__ = proto;
	        return obj;
	    }
	
	    var canSetPrototype = ({ __proto__: [] } instanceof Array);
	    var canUseSymbols = !DEBUG && typeof Symbol === 'function';
	
	    // Represent the known event types in a compact way, then at runtime transform it into a hash with event name as key (for fast lookup)
	    var knownEvents = {}, knownEventTypesByEventName = {};
	    var keyEventTypeName = (navigator && /Firefox\/2/i.test(navigator.userAgent)) ? 'KeyboardEvent' : 'UIEvents';
	    knownEvents[keyEventTypeName] = ['keyup', 'keydown', 'keypress'];
	    knownEvents['MouseEvents'] = ['click', 'dblclick', 'mousedown', 'mouseup', 'mousemove', 'mouseover', 'mouseout', 'mouseenter', 'mouseleave'];
	    objectForEach(knownEvents, function(eventType, knownEventsForType) {
	        if (knownEventsForType.length) {
	            for (var i = 0, j = knownEventsForType.length; i < j; i++)
	                knownEventTypesByEventName[knownEventsForType[i]] = eventType;
	        }
	    });
	    var eventsThatMustBeRegisteredUsingAttachEvent = { 'propertychange': true }; // Workaround for an IE9 issue - https://github.com/SteveSanderson/knockout/issues/406
	
	    // Detect IE versions for bug workarounds (uses IE conditionals, not UA string, for robustness)
	    // Note that, since IE 10 does not support conditional comments, the following logic only detects IE < 10.
	    // Currently this is by design, since IE 10+ behaves correctly when treated as a standard browser.
	    // If there is a future need to detect specific versions of IE10+, we will amend this.
	    var ieVersion = document && (function() {
	        var version = 3, div = document.createElement('div'), iElems = div.getElementsByTagName('i');
	
	        // Keep constructing conditional HTML blocks until we hit one that resolves to an empty fragment
	        while (
	            div.innerHTML = '<!--[if gt IE ' + (++version) + ']><i></i><![endif]-->',
	            iElems[0]
	        ) {}
	        return version > 4 ? version : undefined;
	    }());
	    var isIe6 = ieVersion === 6,
	        isIe7 = ieVersion === 7;
	
	    function isClickOnCheckableElement(element, eventType) {
	        if ((ko.utils.tagNameLower(element) !== "input") || !element.type) return false;
	        if (eventType.toLowerCase() != "click") return false;
	        var inputType = element.type;
	        return (inputType == "checkbox") || (inputType == "radio");
	    }
	
	    // For details on the pattern for changing node classes
	    // see: https://github.com/knockout/knockout/issues/1597
	    var cssClassNameRegex = /\S+/g;
	
	    function toggleDomNodeCssClass(node, classNames, shouldHaveClass) {
	        var addOrRemoveFn;
	        if (classNames) {
	            if (typeof node.classList === 'object') {
	                addOrRemoveFn = node.classList[shouldHaveClass ? 'add' : 'remove'];
	                ko.utils.arrayForEach(classNames.match(cssClassNameRegex), function(className) {
	                    addOrRemoveFn.call(node.classList, className);
	                });
	            } else if (typeof node.className['baseVal'] === 'string') {
	                // SVG tag .classNames is an SVGAnimatedString instance
	                toggleObjectClassPropertyString(node.className, 'baseVal', classNames, shouldHaveClass);
	            } else {
	                // node.className ought to be a string.
	                toggleObjectClassPropertyString(node, 'className', classNames, shouldHaveClass);
	            }
	        }
	    }
	
	    function toggleObjectClassPropertyString(obj, prop, classNames, shouldHaveClass) {
	        // obj/prop is either a node/'className' or a SVGAnimatedString/'baseVal'.
	        var currentClassNames = obj[prop].match(cssClassNameRegex) || [];
	        ko.utils.arrayForEach(classNames.match(cssClassNameRegex), function(className) {
	            ko.utils.addOrRemoveItem(currentClassNames, className, shouldHaveClass);
	        });
	        obj[prop] = currentClassNames.join(" ");
	    }
	
	    return {
	        fieldsIncludedWithJsonPost: ['authenticity_token', /^__RequestVerificationToken(_.*)?$/],
	
	        arrayForEach: function (array, action) {
	            for (var i = 0, j = array.length; i < j; i++)
	                action(array[i], i);
	        },
	
	        arrayIndexOf: function (array, item) {
	            if (typeof Array.prototype.indexOf == "function")
	                return Array.prototype.indexOf.call(array, item);
	            for (var i = 0, j = array.length; i < j; i++)
	                if (array[i] === item)
	                    return i;
	            return -1;
	        },
	
	        arrayFirst: function (array, predicate, predicateOwner) {
	            for (var i = 0, j = array.length; i < j; i++)
	                if (predicate.call(predicateOwner, array[i], i))
	                    return array[i];
	            return null;
	        },
	
	        arrayRemoveItem: function (array, itemToRemove) {
	            var index = ko.utils.arrayIndexOf(array, itemToRemove);
	            if (index > 0) {
	                array.splice(index, 1);
	            }
	            else if (index === 0) {
	                array.shift();
	            }
	        },
	
	        arrayGetDistinctValues: function (array) {
	            array = array || [];
	            var result = [];
	            for (var i = 0, j = array.length; i < j; i++) {
	                if (ko.utils.arrayIndexOf(result, array[i]) < 0)
	                    result.push(array[i]);
	            }
	            return result;
	        },
	
	        arrayMap: function (array, mapping) {
	            array = array || [];
	            var result = [];
	            for (var i = 0, j = array.length; i < j; i++)
	                result.push(mapping(array[i], i));
	            return result;
	        },
	
	        arrayFilter: function (array, predicate) {
	            array = array || [];
	            var result = [];
	            for (var i = 0, j = array.length; i < j; i++)
	                if (predicate(array[i], i))
	                    result.push(array[i]);
	            return result;
	        },
	
	        arrayPushAll: function (array, valuesToPush) {
	            if (valuesToPush instanceof Array)
	                array.push.apply(array, valuesToPush);
	            else
	                for (var i = 0, j = valuesToPush.length; i < j; i++)
	                    array.push(valuesToPush[i]);
	            return array;
	        },
	
	        addOrRemoveItem: function(array, value, included) {
	            var existingEntryIndex = ko.utils.arrayIndexOf(ko.utils.peekObservable(array), value);
	            if (existingEntryIndex < 0) {
	                if (included)
	                    array.push(value);
	            } else {
	                if (!included)
	                    array.splice(existingEntryIndex, 1);
	            }
	        },
	
	        canSetPrototype: canSetPrototype,
	
	        extend: extend,
	
	        setPrototypeOf: setPrototypeOf,
	
	        setPrototypeOfOrExtend: canSetPrototype ? setPrototypeOf : extend,
	
	        objectForEach: objectForEach,
	
	        objectMap: function(source, mapping) {
	            if (!source)
	                return source;
	            var target = {};
	            for (var prop in source) {
	                if (source.hasOwnProperty(prop)) {
	                    target[prop] = mapping(source[prop], prop, source);
	                }
	            }
	            return target;
	        },
	
	        emptyDomNode: function (domNode) {
	            while (domNode.firstChild) {
	                ko.removeNode(domNode.firstChild);
	            }
	        },
	
	        moveCleanedNodesToContainerElement: function(nodes) {
	            // Ensure it's a real array, as we're about to reparent the nodes and
	            // we don't want the underlying collection to change while we're doing that.
	            var nodesArray = ko.utils.makeArray(nodes);
	            var templateDocument = (nodesArray[0] && nodesArray[0].ownerDocument) || document;
	
	            var container = templateDocument.createElement('div');
	            for (var i = 0, j = nodesArray.length; i < j; i++) {
	                container.appendChild(ko.cleanNode(nodesArray[i]));
	            }
	            return container;
	        },
	
	        cloneNodes: function (nodesArray, shouldCleanNodes) {
	            for (var i = 0, j = nodesArray.length, newNodesArray = []; i < j; i++) {
	                var clonedNode = nodesArray[i].cloneNode(true);
	                newNodesArray.push(shouldCleanNodes ? ko.cleanNode(clonedNode) : clonedNode);
	            }
	            return newNodesArray;
	        },
	
	        setDomNodeChildren: function (domNode, childNodes) {
	            ko.utils.emptyDomNode(domNode);
	            if (childNodes) {
	                for (var i = 0, j = childNodes.length; i < j; i++)
	                    domNode.appendChild(childNodes[i]);
	            }
	        },
	
	        replaceDomNodes: function (nodeToReplaceOrNodeArray, newNodesArray) {
	            var nodesToReplaceArray = nodeToReplaceOrNodeArray.nodeType ? [nodeToReplaceOrNodeArray] : nodeToReplaceOrNodeArray;
	            if (nodesToReplaceArray.length > 0) {
	                var insertionPoint = nodesToReplaceArray[0];
	                var parent = insertionPoint.parentNode;
	                for (var i = 0, j = newNodesArray.length; i < j; i++)
	                    parent.insertBefore(newNodesArray[i], insertionPoint);
	                for (var i = 0, j = nodesToReplaceArray.length; i < j; i++) {
	                    ko.removeNode(nodesToReplaceArray[i]);
	                }
	            }
	        },
	
	        fixUpContinuousNodeArray: function(continuousNodeArray, parentNode) {
	            // Before acting on a set of nodes that were previously outputted by a template function, we have to reconcile
	            // them against what is in the DOM right now. It may be that some of the nodes have already been removed, or that
	            // new nodes might have been inserted in the middle, for example by a binding. Also, there may previously have been
	            // leading comment nodes (created by rewritten string-based templates) that have since been removed during binding.
	            // So, this function translates the old "map" output array into its best guess of the set of current DOM nodes.
	            //
	            // Rules:
	            //   [A] Any leading nodes that have been removed should be ignored
	            //       These most likely correspond to memoization nodes that were already removed during binding
	            //       See https://github.com/knockout/knockout/pull/440
	            //   [B] Any trailing nodes that have been remove should be ignored
	            //       This prevents the code here from adding unrelated nodes to the array while processing rule [C]
	            //       See https://github.com/knockout/knockout/pull/1903
	            //   [C] We want to output a continuous series of nodes. So, ignore any nodes that have already been removed,
	            //       and include any nodes that have been inserted among the previous collection
	
	            if (continuousNodeArray.length) {
	                // The parent node can be a virtual element; so get the real parent node
	                parentNode = (parentNode.nodeType === 8 && parentNode.parentNode) || parentNode;
	
	                // Rule [A]
	                while (continuousNodeArray.length && continuousNodeArray[0].parentNode !== parentNode)
	                    continuousNodeArray.splice(0, 1);
	
	                // Rule [B]
	                while (continuousNodeArray.length > 1 && continuousNodeArray[continuousNodeArray.length - 1].parentNode !== parentNode)
	                    continuousNodeArray.length--;
	
	                // Rule [C]
	                if (continuousNodeArray.length > 1) {
	                    var current = continuousNodeArray[0], last = continuousNodeArray[continuousNodeArray.length - 1];
	                    // Replace with the actual new continuous node set
	                    continuousNodeArray.length = 0;
	                    while (current !== last) {
	                        continuousNodeArray.push(current);
	                        current = current.nextSibling;
	                    }
	                    continuousNodeArray.push(last);
	                }
	            }
	            return continuousNodeArray;
	        },
	
	        setOptionNodeSelectionState: function (optionNode, isSelected) {
	            // IE6 sometimes throws "unknown error" if you try to write to .selected directly, whereas Firefox struggles with setAttribute. Pick one based on browser.
	            if (ieVersion < 7)
	                optionNode.setAttribute("selected", isSelected);
	            else
	                optionNode.selected = isSelected;
	        },
	
	        stringTrim: function (string) {
	            return string === null || string === undefined ? '' :
	                string.trim ?
	                    string.trim() :
	                    string.toString().replace(/^[\s\xa0]+|[\s\xa0]+$/g, '');
	        },
	
	        stringStartsWith: function (string, startsWith) {
	            string = string || "";
	            if (startsWith.length > string.length)
	                return false;
	            return string.substring(0, startsWith.length) === startsWith;
	        },
	
	        domNodeIsContainedBy: function (node, containedByNode) {
	            if (node === containedByNode)
	                return true;
	            if (node.nodeType === 11)
	                return false; // Fixes issue #1162 - can't use node.contains for document fragments on IE8
	            if (containedByNode.contains)
	                return containedByNode.contains(node.nodeType === 3 ? node.parentNode : node);
	            if (containedByNode.compareDocumentPosition)
	                return (containedByNode.compareDocumentPosition(node) & 16) == 16;
	            while (node && node != containedByNode) {
	                node = node.parentNode;
	            }
	            return !!node;
	        },
	
	        domNodeIsAttachedToDocument: function (node) {
	            return ko.utils.domNodeIsContainedBy(node, node.ownerDocument.documentElement);
	        },
	
	        anyDomNodeIsAttachedToDocument: function(nodes) {
	            return !!ko.utils.arrayFirst(nodes, ko.utils.domNodeIsAttachedToDocument);
	        },
	
	        tagNameLower: function(element) {
	            // For HTML elements, tagName will always be upper case; for XHTML elements, it'll be lower case.
	            // Possible future optimization: If we know it's an element from an XHTML document (not HTML),
	            // we don't need to do the .toLowerCase() as it will always be lower case anyway.
	            return element && element.tagName && element.tagName.toLowerCase();
	        },
	
	        catchFunctionErrors: function (delegate) {
	            return ko['onError'] ? function () {
	                try {
	                    return delegate.apply(this, arguments);
	                } catch (e) {
	                    ko['onError'] && ko['onError'](e);
	                    throw e;
	                }
	            } : delegate;
	        },
	
	        setTimeout: function (handler, timeout) {
	            return setTimeout(ko.utils.catchFunctionErrors(handler), timeout);
	        },
	
	        deferError: function (error) {
	            setTimeout(function () {
	                ko['onError'] && ko['onError'](error);
	                throw error;
	            }, 0);
	        },
	
	        registerEventHandler: function (element, eventType, handler) {
	            var wrappedHandler = ko.utils.catchFunctionErrors(handler);
	
	            var mustUseAttachEvent = ieVersion && eventsThatMustBeRegisteredUsingAttachEvent[eventType];
	            if (!ko.options['useOnlyNativeEvents'] && !mustUseAttachEvent && jQueryInstance) {
	                jQueryInstance(element)['bind'](eventType, wrappedHandler);
	            } else if (!mustUseAttachEvent && typeof element.addEventListener == "function")
	                element.addEventListener(eventType, wrappedHandler, false);
	            else if (typeof element.attachEvent != "undefined") {
	                var attachEventHandler = function (event) { wrappedHandler.call(element, event); },
	                    attachEventName = "on" + eventType;
	                element.attachEvent(attachEventName, attachEventHandler);
	
	                // IE does not dispose attachEvent handlers automatically (unlike with addEventListener)
	                // so to avoid leaks, we have to remove them manually. See bug #856
	                ko.utils.domNodeDisposal.addDisposeCallback(element, function() {
	                    element.detachEvent(attachEventName, attachEventHandler);
	                });
	            } else
	                throw new Error("Browser doesn't support addEventListener or attachEvent");
	        },
	
	        triggerEvent: function (element, eventType) {
	            if (!(element && element.nodeType))
	                throw new Error("element must be a DOM node when calling triggerEvent");
	
	            // For click events on checkboxes and radio buttons, jQuery toggles the element checked state *after* the
	            // event handler runs instead of *before*. (This was fixed in 1.9 for checkboxes but not for radio buttons.)
	            // IE doesn't change the checked state when you trigger the click event using "fireEvent".
	            // In both cases, we'll use the click method instead.
	            var useClickWorkaround = isClickOnCheckableElement(element, eventType);
	
	            if (!ko.options['useOnlyNativeEvents'] && jQueryInstance && !useClickWorkaround) {
	                jQueryInstance(element)['trigger'](eventType);
	            } else if (typeof document.createEvent == "function") {
	                if (typeof element.dispatchEvent == "function") {
	                    var eventCategory = knownEventTypesByEventName[eventType] || "HTMLEvents";
	                    var event = document.createEvent(eventCategory);
	                    event.initEvent(eventType, true, true, window, 0, 0, 0, 0, 0, false, false, false, false, 0, element);
	                    element.dispatchEvent(event);
	                }
	                else
	                    throw new Error("The supplied element doesn't support dispatchEvent");
	            } else if (useClickWorkaround && element.click) {
	                element.click();
	            } else if (typeof element.fireEvent != "undefined") {
	                element.fireEvent("on" + eventType);
	            } else {
	                throw new Error("Browser doesn't support triggering events");
	            }
	        },
	
	        unwrapObservable: function (value) {
	            return ko.isObservable(value) ? value() : value;
	        },
	
	        peekObservable: function (value) {
	            return ko.isObservable(value) ? value.peek() : value;
	        },
	
	        toggleDomNodeCssClass: toggleDomNodeCssClass,
	
	        setTextContent: function(element, textContent) {
	            var value = ko.utils.unwrapObservable(textContent);
	            if ((value === null) || (value === undefined))
	                value = "";
	
	            // We need there to be exactly one child: a text node.
	            // If there are no children, more than one, or if it's not a text node,
	            // we'll clear everything and create a single text node.
	            var innerTextNode = ko.virtualElements.firstChild(element);
	            if (!innerTextNode || innerTextNode.nodeType != 3 || ko.virtualElements.nextSibling(innerTextNode)) {
	                ko.virtualElements.setDomNodeChildren(element, [element.ownerDocument.createTextNode(value)]);
	            } else {
	                innerTextNode.data = value;
	            }
	
	            ko.utils.forceRefresh(element);
	        },
	
	        setElementName: function(element, name) {
	            element.name = name;
	
	            // Workaround IE 6/7 issue
	            // - https://github.com/SteveSanderson/knockout/issues/197
	            // - http://www.matts411.com/post/setting_the_name_attribute_in_ie_dom/
	            if (ieVersion <= 7) {
	                try {
	                    element.mergeAttributes(document.createElement("<input name='" + element.name + "'/>"), false);
	                }
	                catch(e) {} // For IE9 with doc mode "IE9 Standards" and browser mode "IE9 Compatibility View"
	            }
	        },
	
	        forceRefresh: function(node) {
	            // Workaround for an IE9 rendering bug - https://github.com/SteveSanderson/knockout/issues/209
	            if (ieVersion >= 9) {
	                // For text nodes and comment nodes (most likely virtual elements), we will have to refresh the container
	                var elem = node.nodeType == 1 ? node : node.parentNode;
	                if (elem.style)
	                    elem.style.zoom = elem.style.zoom;
	            }
	        },
	
	        ensureSelectElementIsRenderedCorrectly: function(selectElement) {
	            // Workaround for IE9 rendering bug - it doesn't reliably display all the text in dynamically-added select boxes unless you force it to re-render by updating the width.
	            // (See https://github.com/SteveSanderson/knockout/issues/312, http://stackoverflow.com/questions/5908494/select-only-shows-first-char-of-selected-option)
	            // Also fixes IE7 and IE8 bug that causes selects to be zero width if enclosed by 'if' or 'with'. (See issue #839)
	            if (ieVersion) {
	                var originalWidth = selectElement.style.width;
	                selectElement.style.width = 0;
	                selectElement.style.width = originalWidth;
	            }
	        },
	
	        range: function (min, max) {
	            min = ko.utils.unwrapObservable(min);
	            max = ko.utils.unwrapObservable(max);
	            var result = [];
	            for (var i = min; i <= max; i++)
	                result.push(i);
	            return result;
	        },
	
	        makeArray: function(arrayLikeObject) {
	            var result = [];
	            for (var i = 0, j = arrayLikeObject.length; i < j; i++) {
	                result.push(arrayLikeObject[i]);
	            };
	            return result;
	        },
	
	        createSymbolOrString: function(identifier) {
	            return canUseSymbols ? Symbol(identifier) : identifier;
	        },
	
	        isIe6 : isIe6,
	        isIe7 : isIe7,
	        ieVersion : ieVersion,
	
	        getFormFields: function(form, fieldName) {
	            var fields = ko.utils.makeArray(form.getElementsByTagName("input")).concat(ko.utils.makeArray(form.getElementsByTagName("textarea")));
	            var isMatchingField = (typeof fieldName == 'string')
	                ? function(field) { return field.name === fieldName }
	                : function(field) { return fieldName.test(field.name) }; // Treat fieldName as regex or object containing predicate
	            var matches = [];
	            for (var i = fields.length - 1; i >= 0; i--) {
	                if (isMatchingField(fields[i]))
	                    matches.push(fields[i]);
	            };
	            return matches;
	        },
	
	        parseJson: function (jsonString) {
	            if (typeof jsonString == "string") {
	                jsonString = ko.utils.stringTrim(jsonString);
	                if (jsonString) {
	                    if (JSON && JSON.parse) // Use native parsing where available
	                        return JSON.parse(jsonString);
	                    return (new Function("return " + jsonString))(); // Fallback on less safe parsing for older browsers
	                }
	            }
	            return null;
	        },
	
	        stringifyJson: function (data, replacer, space) {   // replacer and space are optional
	            if (!JSON || !JSON.stringify)
	                throw new Error("Cannot find JSON.stringify(). Some browsers (e.g., IE < 8) don't support it natively, but you can overcome this by adding a script reference to json2.js, downloadable from http://www.json.org/json2.js");
	            return JSON.stringify(ko.utils.unwrapObservable(data), replacer, space);
	        },
	
	        postJson: function (urlOrForm, data, options) {
	            options = options || {};
	            var params = options['params'] || {};
	            var includeFields = options['includeFields'] || this.fieldsIncludedWithJsonPost;
	            var url = urlOrForm;
	
	            // If we were given a form, use its 'action' URL and pick out any requested field values
	            if((typeof urlOrForm == 'object') && (ko.utils.tagNameLower(urlOrForm) === "form")) {
	                var originalForm = urlOrForm;
	                url = originalForm.action;
	                for (var i = includeFields.length - 1; i >= 0; i--) {
	                    var fields = ko.utils.getFormFields(originalForm, includeFields[i]);
	                    for (var j = fields.length - 1; j >= 0; j--)
	                        params[fields[j].name] = fields[j].value;
	                }
	            }
	
	            data = ko.utils.unwrapObservable(data);
	            var form = document.createElement("form");
	            form.style.display = "none";
	            form.action = url;
	            form.method = "post";
	            for (var key in data) {
	                // Since 'data' this is a model object, we include all properties including those inherited from its prototype
	                var input = document.createElement("input");
	                input.type = "hidden";
	                input.name = key;
	                input.value = ko.utils.stringifyJson(ko.utils.unwrapObservable(data[key]));
	                form.appendChild(input);
	            }
	            objectForEach(params, function(key, value) {
	                var input = document.createElement("input");
	                input.type = "hidden";
	                input.name = key;
	                input.value = value;
	                form.appendChild(input);
	            });
	            document.body.appendChild(form);
	            options['submitter'] ? options['submitter'](form) : form.submit();
	            setTimeout(function () { form.parentNode.removeChild(form); }, 0);
	        }
	    }
	}());
	
	ko.exportSymbol('utils', ko.utils);
	ko.exportSymbol('utils.arrayForEach', ko.utils.arrayForEach);
	ko.exportSymbol('utils.arrayFirst', ko.utils.arrayFirst);
	ko.exportSymbol('utils.arrayFilter', ko.utils.arrayFilter);
	ko.exportSymbol('utils.arrayGetDistinctValues', ko.utils.arrayGetDistinctValues);
	ko.exportSymbol('utils.arrayIndexOf', ko.utils.arrayIndexOf);
	ko.exportSymbol('utils.arrayMap', ko.utils.arrayMap);
	ko.exportSymbol('utils.arrayPushAll', ko.utils.arrayPushAll);
	ko.exportSymbol('utils.arrayRemoveItem', ko.utils.arrayRemoveItem);
	ko.exportSymbol('utils.extend', ko.utils.extend);
	ko.exportSymbol('utils.fieldsIncludedWithJsonPost', ko.utils.fieldsIncludedWithJsonPost);
	ko.exportSymbol('utils.getFormFields', ko.utils.getFormFields);
	ko.exportSymbol('utils.peekObservable', ko.utils.peekObservable);
	ko.exportSymbol('utils.postJson', ko.utils.postJson);
	ko.exportSymbol('utils.parseJson', ko.utils.parseJson);
	ko.exportSymbol('utils.registerEventHandler', ko.utils.registerEventHandler);
	ko.exportSymbol('utils.stringifyJson', ko.utils.stringifyJson);
	ko.exportSymbol('utils.range', ko.utils.range);
	ko.exportSymbol('utils.toggleDomNodeCssClass', ko.utils.toggleDomNodeCssClass);
	ko.exportSymbol('utils.triggerEvent', ko.utils.triggerEvent);
	ko.exportSymbol('utils.unwrapObservable', ko.utils.unwrapObservable);
	ko.exportSymbol('utils.objectForEach', ko.utils.objectForEach);
	ko.exportSymbol('utils.addOrRemoveItem', ko.utils.addOrRemoveItem);
	ko.exportSymbol('utils.setTextContent', ko.utils.setTextContent);
	ko.exportSymbol('unwrap', ko.utils.unwrapObservable); // Convenient shorthand, because this is used so commonly
	
	if (!Function.prototype['bind']) {
	    // Function.prototype.bind is a standard part of ECMAScript 5th Edition (December 2009, http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-262.pdf)
	    // In case the browser doesn't implement it natively, provide a JavaScript implementation. This implementation is based on the one in prototype.js
	    Function.prototype['bind'] = function (object) {
	        var originalFunction = this;
	        if (arguments.length === 1) {
	            return function () {
	                return originalFunction.apply(object, arguments);
	            };
	        } else {
	            var partialArgs = Array.prototype.slice.call(arguments, 1);
	            return function () {
	                var args = partialArgs.slice(0);
	                args.push.apply(args, arguments);
	                return originalFunction.apply(object, args);
	            };
	        }
	    };
	}
	
	ko.utils.domData = new (function () {
	    var uniqueId = 0;
	    var dataStoreKeyExpandoPropertyName = "__ko__" + (new Date).getTime();
	    var dataStore = {};
	
	    function getAll(node, createIfNotFound) {
	        var dataStoreKey = node[dataStoreKeyExpandoPropertyName];
	        var hasExistingDataStore = dataStoreKey && (dataStoreKey !== "null") && dataStore[dataStoreKey];
	        if (!hasExistingDataStore) {
	            if (!createIfNotFound)
	                return undefined;
	            dataStoreKey = node[dataStoreKeyExpandoPropertyName] = "ko" + uniqueId++;
	            dataStore[dataStoreKey] = {};
	        }
	        return dataStore[dataStoreKey];
	    }
	
	    return {
	        get: function (node, key) {
	            var allDataForNode = getAll(node, false);
	            return allDataForNode === undefined ? undefined : allDataForNode[key];
	        },
	        set: function (node, key, value) {
	            if (value === undefined) {
	                // Make sure we don't actually create a new domData key if we are actually deleting a value
	                if (getAll(node, false) === undefined)
	                    return;
	            }
	            var allDataForNode = getAll(node, true);
	            allDataForNode[key] = value;
	        },
	        clear: function (node) {
	            var dataStoreKey = node[dataStoreKeyExpandoPropertyName];
	            if (dataStoreKey) {
	                delete dataStore[dataStoreKey];
	                node[dataStoreKeyExpandoPropertyName] = null;
	                return true; // Exposing "did clean" flag purely so specs can infer whether things have been cleaned up as intended
	            }
	            return false;
	        },
	
	        nextKey: function () {
	            return (uniqueId++) + dataStoreKeyExpandoPropertyName;
	        }
	    };
	})();
	
	ko.exportSymbol('utils.domData', ko.utils.domData);
	ko.exportSymbol('utils.domData.clear', ko.utils.domData.clear); // Exporting only so specs can clear up after themselves fully
	
	ko.utils.domNodeDisposal = new (function () {
	    var domDataKey = ko.utils.domData.nextKey();
	    var cleanableNodeTypes = { 1: true, 8: true, 9: true };       // Element, Comment, Document
	    var cleanableNodeTypesWithDescendants = { 1: true, 9: true }; // Element, Document
	
	    function getDisposeCallbacksCollection(node, createIfNotFound) {
	        var allDisposeCallbacks = ko.utils.domData.get(node, domDataKey);
	        if ((allDisposeCallbacks === undefined) && createIfNotFound) {
	            allDisposeCallbacks = [];
	            ko.utils.domData.set(node, domDataKey, allDisposeCallbacks);
	        }
	        return allDisposeCallbacks;
	    }
	    function destroyCallbacksCollection(node) {
	        ko.utils.domData.set(node, domDataKey, undefined);
	    }
	
	    function cleanSingleNode(node) {
	        // Run all the dispose callbacks
	        var callbacks = getDisposeCallbacksCollection(node, false);
	        if (callbacks) {
	            callbacks = callbacks.slice(0); // Clone, as the array may be modified during iteration (typically, callbacks will remove themselves)
	            for (var i = 0; i < callbacks.length; i++)
	                callbacks[i](node);
	        }
	
	        // Erase the DOM data
	        ko.utils.domData.clear(node);
	
	        // Perform cleanup needed by external libraries (currently only jQuery, but can be extended)
	        ko.utils.domNodeDisposal["cleanExternalData"](node);
	
	        // Clear any immediate-child comment nodes, as these wouldn't have been found by
	        // node.getElementsByTagName("*") in cleanNode() (comment nodes aren't elements)
	        if (cleanableNodeTypesWithDescendants[node.nodeType])
	            cleanImmediateCommentTypeChildren(node);
	    }
	
	    function cleanImmediateCommentTypeChildren(nodeWithChildren) {
	        var child, nextChild = nodeWithChildren.firstChild;
	        while (child = nextChild) {
	            nextChild = child.nextSibling;
	            if (child.nodeType === 8)
	                cleanSingleNode(child);
	        }
	    }
	
	    return {
	        addDisposeCallback : function(node, callback) {
	            if (typeof callback != "function")
	                throw new Error("Callback must be a function");
	            getDisposeCallbacksCollection(node, true).push(callback);
	        },
	
	        removeDisposeCallback : function(node, callback) {
	            var callbacksCollection = getDisposeCallbacksCollection(node, false);
	            if (callbacksCollection) {
	                ko.utils.arrayRemoveItem(callbacksCollection, callback);
	                if (callbacksCollection.length == 0)
	                    destroyCallbacksCollection(node);
	            }
	        },
	
	        cleanNode : function(node) {
	            // First clean this node, where applicable
	            if (cleanableNodeTypes[node.nodeType]) {
	                cleanSingleNode(node);
	
	                // ... then its descendants, where applicable
	                if (cleanableNodeTypesWithDescendants[node.nodeType]) {
	                    // Clone the descendants list in case it changes during iteration
	                    var descendants = [];
	                    ko.utils.arrayPushAll(descendants, node.getElementsByTagName("*"));
	                    for (var i = 0, j = descendants.length; i < j; i++)
	                        cleanSingleNode(descendants[i]);
	                }
	            }
	            return node;
	        },
	
	        removeNode : function(node) {
	            ko.cleanNode(node);
	            if (node.parentNode)
	                node.parentNode.removeChild(node);
	        },
	
	        "cleanExternalData" : function (node) {
	            // Special support for jQuery here because it's so commonly used.
	            // Many jQuery plugins (including jquery.tmpl) store data using jQuery's equivalent of domData
	            // so notify it to tear down any resources associated with the node & descendants here.
	            if (jQueryInstance && (typeof jQueryInstance['cleanData'] == "function"))
	                jQueryInstance['cleanData']([node]);
	        }
	    };
	})();
	ko.cleanNode = ko.utils.domNodeDisposal.cleanNode; // Shorthand name for convenience
	ko.removeNode = ko.utils.domNodeDisposal.removeNode; // Shorthand name for convenience
	ko.exportSymbol('cleanNode', ko.cleanNode);
	ko.exportSymbol('removeNode', ko.removeNode);
	ko.exportSymbol('utils.domNodeDisposal', ko.utils.domNodeDisposal);
	ko.exportSymbol('utils.domNodeDisposal.addDisposeCallback', ko.utils.domNodeDisposal.addDisposeCallback);
	ko.exportSymbol('utils.domNodeDisposal.removeDisposeCallback', ko.utils.domNodeDisposal.removeDisposeCallback);
	(function () {
	    var none = [0, "", ""],
	        table = [1, "<table>", "</table>"],
	        tbody = [2, "<table><tbody>", "</tbody></table>"],
	        tr = [3, "<table><tbody><tr>", "</tr></tbody></table>"],
	        select = [1, "<select multiple='multiple'>", "</select>"],
	        lookup = {
	            'thead': table,
	            'tbody': table,
	            'tfoot': table,
	            'tr': tbody,
	            'td': tr,
	            'th': tr,
	            'option': select,
	            'optgroup': select
	        },
	
	        // This is needed for old IE if you're *not* using either jQuery or innerShiv. Doesn't affect other cases.
	        mayRequireCreateElementHack = ko.utils.ieVersion <= 8;
	
	    function getWrap(tags) {
	        var m = tags.match(/^<([a-z]+)[ >]/);
	        return (m && lookup[m[1]]) || none;
	    }
	
	    function simpleHtmlParse(html, documentContext) {
	        documentContext || (documentContext = document);
	        var windowContext = documentContext['parentWindow'] || documentContext['defaultView'] || window;
	
	        // Based on jQuery's "clean" function, but only accounting for table-related elements.
	        // If you have referenced jQuery, this won't be used anyway - KO will use jQuery's "clean" function directly
	
	        // Note that there's still an issue in IE < 9 whereby it will discard comment nodes that are the first child of
	        // a descendant node. For example: "<div><!-- mycomment -->abc</div>" will get parsed as "<div>abc</div>"
	        // This won't affect anyone who has referenced jQuery, and there's always the workaround of inserting a dummy node
	        // (possibly a text node) in front of the comment. So, KO does not attempt to workaround this IE issue automatically at present.
	
	        // Trim whitespace, otherwise indexOf won't work as expected
	        var tags = ko.utils.stringTrim(html).toLowerCase(), div = documentContext.createElement("div"),
	            wrap = getWrap(tags),
	            depth = wrap[0];
	
	        // Go to html and back, then peel off extra wrappers
	        // Note that we always prefix with some dummy text, because otherwise, IE<9 will strip out leading comment nodes in descendants. Total madness.
	        var markup = "ignored<div>" + wrap[1] + html + wrap[2] + "</div>";
	        if (typeof windowContext['innerShiv'] == "function") {
	            // Note that innerShiv is deprecated in favour of html5shiv. We should consider adding
	            // support for html5shiv (except if no explicit support is needed, e.g., if html5shiv
	            // somehow shims the native APIs so it just works anyway)
	            div.appendChild(windowContext['innerShiv'](markup));
	        } else {
	            if (mayRequireCreateElementHack) {
	                // The document.createElement('my-element') trick to enable custom elements in IE6-8
	                // only works if we assign innerHTML on an element associated with that document.
	                documentContext.appendChild(div);
	            }
	
	            div.innerHTML = markup;
	
	            if (mayRequireCreateElementHack) {
	                div.parentNode.removeChild(div);
	            }
	        }
	
	        // Move to the right depth
	        while (depth--)
	            div = div.lastChild;
	
	        return ko.utils.makeArray(div.lastChild.childNodes);
	    }
	
	    function jQueryHtmlParse(html, documentContext) {
	        // jQuery's "parseHTML" function was introduced in jQuery 1.8.0 and is a documented public API.
	        if (jQueryInstance['parseHTML']) {
	            return jQueryInstance['parseHTML'](html, documentContext) || []; // Ensure we always return an array and never null
	        } else {
	            // For jQuery < 1.8.0, we fall back on the undocumented internal "clean" function.
	            var elems = jQueryInstance['clean']([html], documentContext);
	
	            // As of jQuery 1.7.1, jQuery parses the HTML by appending it to some dummy parent nodes held in an in-memory document fragment.
	            // Unfortunately, it never clears the dummy parent nodes from the document fragment, so it leaks memory over time.
	            // Fix this by finding the top-most dummy parent element, and detaching it from its owner fragment.
	            if (elems && elems[0]) {
	                // Find the top-most parent element that's a direct child of a document fragment
	                var elem = elems[0];
	                while (elem.parentNode && elem.parentNode.nodeType !== 11 /* i.e., DocumentFragment */)
	                    elem = elem.parentNode;
	                // ... then detach it
	                if (elem.parentNode)
	                    elem.parentNode.removeChild(elem);
	            }
	
	            return elems;
	        }
	    }
	
	    ko.utils.parseHtmlFragment = function(html, documentContext) {
	        return jQueryInstance ?
	            jQueryHtmlParse(html, documentContext) :   // As below, benefit from jQuery's optimisations where possible
	            simpleHtmlParse(html, documentContext);  // ... otherwise, this simple logic will do in most common cases.
	    };
	
	    ko.utils.setHtml = function(node, html) {
	        ko.utils.emptyDomNode(node);
	
	        // There's no legitimate reason to display a stringified observable without unwrapping it, so we'll unwrap it
	        html = ko.utils.unwrapObservable(html);
	
	        if ((html !== null) && (html !== undefined)) {
	            if (typeof html != 'string')
	                html = html.toString();
	
	            // jQuery contains a lot of sophisticated code to parse arbitrary HTML fragments,
	            // for example <tr> elements which are not normally allowed to exist on their own.
	            // If you've referenced jQuery we'll use that rather than duplicating its code.
	            if (jQueryInstance) {
	                jQueryInstance(node)['html'](html);
	            } else {
	                // ... otherwise, use KO's own parsing logic.
	                var parsedNodes = ko.utils.parseHtmlFragment(html, node.ownerDocument);
	                for (var i = 0; i < parsedNodes.length; i++)
	                    node.appendChild(parsedNodes[i]);
	            }
	        }
	    };
	})();
	
	ko.exportSymbol('utils.parseHtmlFragment', ko.utils.parseHtmlFragment);
	ko.exportSymbol('utils.setHtml', ko.utils.setHtml);
	
	ko.memoization = (function () {
	    var memos = {};
	
	    function randomMax8HexChars() {
	        return (((1 + Math.random()) * 0x100000000) | 0).toString(16).substring(1);
	    }
	    function generateRandomId() {
	        return randomMax8HexChars() + randomMax8HexChars();
	    }
	    function findMemoNodes(rootNode, appendToArray) {
	        if (!rootNode)
	            return;
	        if (rootNode.nodeType == 8) {
	            var memoId = ko.memoization.parseMemoText(rootNode.nodeValue);
	            if (memoId != null)
	                appendToArray.push({ domNode: rootNode, memoId: memoId });
	        } else if (rootNode.nodeType == 1) {
	            for (var i = 0, childNodes = rootNode.childNodes, j = childNodes.length; i < j; i++)
	                findMemoNodes(childNodes[i], appendToArray);
	        }
	    }
	
	    return {
	        memoize: function (callback) {
	            if (typeof callback != "function")
	                throw new Error("You can only pass a function to ko.memoization.memoize()");
	            var memoId = generateRandomId();
	            memos[memoId] = callback;
	            return "<!--[ko_memo:" + memoId + "]-->";
	        },
	
	        unmemoize: function (memoId, callbackParams) {
	            var callback = memos[memoId];
	            if (callback === undefined)
	                throw new Error("Couldn't find any memo with ID " + memoId + ". Perhaps it's already been unmemoized.");
	            try {
	                callback.apply(null, callbackParams || []);
	                return true;
	            }
	            finally { delete memos[memoId]; }
	        },
	
	        unmemoizeDomNodeAndDescendants: function (domNode, extraCallbackParamsArray) {
	            var memos = [];
	            findMemoNodes(domNode, memos);
	            for (var i = 0, j = memos.length; i < j; i++) {
	                var node = memos[i].domNode;
	                var combinedParams = [node];
	                if (extraCallbackParamsArray)
	                    ko.utils.arrayPushAll(combinedParams, extraCallbackParamsArray);
	                ko.memoization.unmemoize(memos[i].memoId, combinedParams);
	                node.nodeValue = ""; // Neuter this node so we don't try to unmemoize it again
	                if (node.parentNode)
	                    node.parentNode.removeChild(node); // If possible, erase it totally (not always possible - someone else might just hold a reference to it then call unmemoizeDomNodeAndDescendants again)
	            }
	        },
	
	        parseMemoText: function (memoText) {
	            var match = memoText.match(/^\[ko_memo\:(.*?)\]$/);
	            return match ? match[1] : null;
	        }
	    };
	})();
	
	ko.exportSymbol('memoization', ko.memoization);
	ko.exportSymbol('memoization.memoize', ko.memoization.memoize);
	ko.exportSymbol('memoization.unmemoize', ko.memoization.unmemoize);
	ko.exportSymbol('memoization.parseMemoText', ko.memoization.parseMemoText);
	ko.exportSymbol('memoization.unmemoizeDomNodeAndDescendants', ko.memoization.unmemoizeDomNodeAndDescendants);
	ko.tasks = (function () {
	    var scheduler,
	        taskQueue = [],
	        taskQueueLength = 0,
	        nextHandle = 1,
	        nextIndexToProcess = 0;
	
	    if (window['MutationObserver']) {
	        // Chrome 27+, Firefox 14+, IE 11+, Opera 15+, Safari 6.1+
	        // From https://github.com/petkaantonov/bluebird * Copyright (c) 2014 Petka Antonov * License: MIT
	        scheduler = (function (callback) {
	            var div = document.createElement("div");
	            new MutationObserver(callback).observe(div, {attributes: true});
	            return function () { div.classList.toggle("foo"); };
	        })(scheduledProcess);
	    } else if (document && "onreadystatechange" in document.createElement("script")) {
	        // IE 6-10
	        // From https://github.com/YuzuJS/setImmediate * Copyright (c) 2012 Barnesandnoble.com, llc, Donavon West, and Domenic Denicola * License: MIT
	        scheduler = function (callback) {
	            var script = document.createElement("script");
	            script.onreadystatechange = function () {
	                script.onreadystatechange = null;
	                document.documentElement.removeChild(script);
	                script = null;
	                callback();
	            };
	            document.documentElement.appendChild(script);
	        };
	    } else {
	        scheduler = function (callback) {
	            setTimeout(callback, 0);
	        };
	    }
	
	    function processTasks() {
	        if (taskQueueLength) {
	            // Each mark represents the end of a logical group of tasks and the number of these groups is
	            // limited to prevent unchecked recursion.
	            var mark = taskQueueLength, countMarks = 0;
	
	            // nextIndexToProcess keeps track of where we are in the queue; processTasks can be called recursively without issue
	            for (var task; nextIndexToProcess < taskQueueLength; ) {
	                if (task = taskQueue[nextIndexToProcess++]) {
	                    if (nextIndexToProcess > mark) {
	                        if (++countMarks >= 5000) {
	                            nextIndexToProcess = taskQueueLength;   // skip all tasks remaining in the queue since any of them could be causing the recursion
	                            ko.utils.deferError(Error("'Too much recursion' after processing " + countMarks + " task groups."));
	                            break;
	                        }
	                        mark = taskQueueLength;
	                    }
	                    try {
	                        task();
	                    } catch (ex) {
	                        ko.utils.deferError(ex);
	                    }
	                }
	            }
	        }
	    }
	
	    function scheduledProcess() {
	        processTasks();
	
	        // Reset the queue
	        nextIndexToProcess = taskQueueLength = taskQueue.length = 0;
	    }
	
	    function scheduleTaskProcessing() {
	        ko.tasks['scheduler'](scheduledProcess);
	    }
	
	    var tasks = {
	        'scheduler': scheduler,     // Allow overriding the scheduler
	
	        schedule: function (func) {
	            if (!taskQueueLength) {
	                scheduleTaskProcessing();
	            }
	
	            taskQueue[taskQueueLength++] = func;
	            return nextHandle++;
	        },
	
	        cancel: function (handle) {
	            var index = handle - (nextHandle - taskQueueLength);
	            if (index >= nextIndexToProcess && index < taskQueueLength) {
	                taskQueue[index] = null;
	            }
	        },
	
	        // For testing only: reset the queue and return the previous queue length
	        'resetForTesting': function () {
	            var length = taskQueueLength - nextIndexToProcess;
	            nextIndexToProcess = taskQueueLength = taskQueue.length = 0;
	            return length;
	        },
	
	        runEarly: processTasks
	    };
	
	    return tasks;
	})();
	
	ko.exportSymbol('tasks', ko.tasks);
	ko.exportSymbol('tasks.schedule', ko.tasks.schedule);
	//ko.exportSymbol('tasks.cancel', ko.tasks.cancel);  "cancel" isn't minified
	ko.exportSymbol('tasks.runEarly', ko.tasks.runEarly);
	ko.extenders = {
	    'throttle': function(target, timeout) {
	        // Throttling means two things:
	
	        // (1) For dependent observables, we throttle *evaluations* so that, no matter how fast its dependencies
	        //     notify updates, the target doesn't re-evaluate (and hence doesn't notify) faster than a certain rate
	        target['throttleEvaluation'] = timeout;
	
	        // (2) For writable targets (observables, or writable dependent observables), we throttle *writes*
	        //     so the target cannot change value synchronously or faster than a certain rate
	        var writeTimeoutInstance = null;
	        return ko.dependentObservable({
	            'read': target,
	            'write': function(value) {
	                clearTimeout(writeTimeoutInstance);
	                writeTimeoutInstance = ko.utils.setTimeout(function() {
	                    target(value);
	                }, timeout);
	            }
	        });
	    },
	
	    'rateLimit': function(target, options) {
	        var timeout, method, limitFunction;
	
	        if (typeof options == 'number') {
	            timeout = options;
	        } else {
	            timeout = options['timeout'];
	            method = options['method'];
	        }
	
	        // rateLimit supersedes deferred updates
	        target._deferUpdates = false;
	
	        limitFunction = method == 'notifyWhenChangesStop' ?  debounce : throttle;
	        target.limit(function(callback) {
	            return limitFunction(callback, timeout);
	        });
	    },
	
	    'deferred': function(target, options) {
	        if (options !== true) {
	            throw new Error('The \'deferred\' extender only accepts the value \'true\', because it is not supported to turn deferral off once enabled.')
	        }
	
	        if (!target._deferUpdates) {
	            target._deferUpdates = true;
	            target.limit(function (callback) {
	                var handle;
	                return function () {
	                    ko.tasks.cancel(handle);
	                    handle = ko.tasks.schedule(callback);
	                    target['notifySubscribers'](undefined, 'dirty');
	                };
	            });
	        }
	    },
	
	    'notify': function(target, notifyWhen) {
	        target["equalityComparer"] = notifyWhen == "always" ?
	            null :  // null equalityComparer means to always notify
	            valuesArePrimitiveAndEqual;
	    }
	};
	
	var primitiveTypes = { 'undefined':1, 'boolean':1, 'number':1, 'string':1 };
	function valuesArePrimitiveAndEqual(a, b) {
	    var oldValueIsPrimitive = (a === null) || (typeof(a) in primitiveTypes);
	    return oldValueIsPrimitive ? (a === b) : false;
	}
	
	function throttle(callback, timeout) {
	    var timeoutInstance;
	    return function () {
	        if (!timeoutInstance) {
	            timeoutInstance = ko.utils.setTimeout(function () {
	                timeoutInstance = undefined;
	                callback();
	            }, timeout);
	        }
	    };
	}
	
	function debounce(callback, timeout) {
	    var timeoutInstance;
	    return function () {
	        clearTimeout(timeoutInstance);
	        timeoutInstance = ko.utils.setTimeout(callback, timeout);
	    };
	}
	
	function applyExtenders(requestedExtenders) {
	    var target = this;
	    if (requestedExtenders) {
	        ko.utils.objectForEach(requestedExtenders, function(key, value) {
	            var extenderHandler = ko.extenders[key];
	            if (typeof extenderHandler == 'function') {
	                target = extenderHandler(target, value) || target;
	            }
	        });
	    }
	    return target;
	}
	
	ko.exportSymbol('extenders', ko.extenders);
	
	ko.subscription = function (target, callback, disposeCallback) {
	    this._target = target;
	    this.callback = callback;
	    this.disposeCallback = disposeCallback;
	    this.isDisposed = false;
	    ko.exportProperty(this, 'dispose', this.dispose);
	};
	ko.subscription.prototype.dispose = function () {
	    this.isDisposed = true;
	    this.disposeCallback();
	};
	
	ko.subscribable = function () {
	    ko.utils.setPrototypeOfOrExtend(this, ko_subscribable_fn);
	    ko_subscribable_fn.init(this);
	}
	
	var defaultEvent = "change";
	
	// Moved out of "limit" to avoid the extra closure
	function limitNotifySubscribers(value, event) {
	    if (!event || event === defaultEvent) {
	        this._limitChange(value);
	    } else if (event === 'beforeChange') {
	        this._limitBeforeChange(value);
	    } else {
	        this._origNotifySubscribers(value, event);
	    }
	}
	
	var ko_subscribable_fn = {
	    init: function(instance) {
	        instance._subscriptions = {};
	        instance._versionNumber = 1;
	    },
	
	    subscribe: function (callback, callbackTarget, event) {
	        var self = this;
	
	        event = event || defaultEvent;
	        var boundCallback = callbackTarget ? callback.bind(callbackTarget) : callback;
	
	        var subscription = new ko.subscription(self, boundCallback, function () {
	            ko.utils.arrayRemoveItem(self._subscriptions[event], subscription);
	            if (self.afterSubscriptionRemove)
	                self.afterSubscriptionRemove(event);
	        });
	
	        if (self.beforeSubscriptionAdd)
	            self.beforeSubscriptionAdd(event);
	
	        if (!self._subscriptions[event])
	            self._subscriptions[event] = [];
	        self._subscriptions[event].push(subscription);
	
	        return subscription;
	    },
	
	    "notifySubscribers": function (valueToNotify, event) {
	        event = event || defaultEvent;
	        if (event === defaultEvent) {
	            this.updateVersion();
	        }
	        if (this.hasSubscriptionsForEvent(event)) {
	            try {
	                ko.dependencyDetection.begin(); // Begin suppressing dependency detection (by setting the top frame to undefined)
	                for (var a = this._subscriptions[event].slice(0), i = 0, subscription; subscription = a[i]; ++i) {
	                    // In case a subscription was disposed during the arrayForEach cycle, check
	                    // for isDisposed on each subscription before invoking its callback
	                    if (!subscription.isDisposed)
	                        subscription.callback(valueToNotify);
	                }
	            } finally {
	                ko.dependencyDetection.end(); // End suppressing dependency detection
	            }
	        }
	    },
	
	    getVersion: function () {
	        return this._versionNumber;
	    },
	
	    hasChanged: function (versionToCheck) {
	        return this.getVersion() !== versionToCheck;
	    },
	
	    updateVersion: function () {
	        ++this._versionNumber;
	    },
	
	    limit: function(limitFunction) {
	        var self = this, selfIsObservable = ko.isObservable(self),
	            ignoreBeforeChange, previousValue, pendingValue, beforeChange = 'beforeChange';
	
	        if (!self._origNotifySubscribers) {
	            self._origNotifySubscribers = self["notifySubscribers"];
	            self["notifySubscribers"] = limitNotifySubscribers;
	        }
	
	        var finish = limitFunction(function() {
	            self._notificationIsPending = false;
	
	            // If an observable provided a reference to itself, access it to get the latest value.
	            // This allows computed observables to delay calculating their value until needed.
	            if (selfIsObservable && pendingValue === self) {
	                pendingValue = self();
	            }
	            ignoreBeforeChange = false;
	            if (self.isDifferent(previousValue, pendingValue)) {
	                self._origNotifySubscribers(previousValue = pendingValue);
	            }
	        });
	
	        self._limitChange = function(value) {
	            self._notificationIsPending = ignoreBeforeChange = true;
	            pendingValue = value;
	            finish();
	        };
	        self._limitBeforeChange = function(value) {
	            if (!ignoreBeforeChange) {
	                previousValue = value;
	                self._origNotifySubscribers(value, beforeChange);
	            }
	        };
	    },
	
	    hasSubscriptionsForEvent: function(event) {
	        return this._subscriptions[event] && this._subscriptions[event].length;
	    },
	
	    getSubscriptionsCount: function (event) {
	        if (event) {
	            return this._subscriptions[event] && this._subscriptions[event].length || 0;
	        } else {
	            var total = 0;
	            ko.utils.objectForEach(this._subscriptions, function(eventName, subscriptions) {
	                if (eventName !== 'dirty')
	                    total += subscriptions.length;
	            });
	            return total;
	        }
	    },
	
	    isDifferent: function(oldValue, newValue) {
	        return !this['equalityComparer'] || !this['equalityComparer'](oldValue, newValue);
	    },
	
	    extend: applyExtenders
	};
	
	ko.exportProperty(ko_subscribable_fn, 'subscribe', ko_subscribable_fn.subscribe);
	ko.exportProperty(ko_subscribable_fn, 'extend', ko_subscribable_fn.extend);
	ko.exportProperty(ko_subscribable_fn, 'getSubscriptionsCount', ko_subscribable_fn.getSubscriptionsCount);
	
	// For browsers that support proto assignment, we overwrite the prototype of each
	// observable instance. Since observables are functions, we need Function.prototype
	// to still be in the prototype chain.
	if (ko.utils.canSetPrototype) {
	    ko.utils.setPrototypeOf(ko_subscribable_fn, Function.prototype);
	}
	
	ko.subscribable['fn'] = ko_subscribable_fn;
	
	
	ko.isSubscribable = function (instance) {
	    return instance != null && typeof instance.subscribe == "function" && typeof instance["notifySubscribers"] == "function";
	};
	
	ko.exportSymbol('subscribable', ko.subscribable);
	ko.exportSymbol('isSubscribable', ko.isSubscribable);
	
	ko.computedContext = ko.dependencyDetection = (function () {
	    var outerFrames = [],
	        currentFrame,
	        lastId = 0;
	
	    // Return a unique ID that can be assigned to an observable for dependency tracking.
	    // Theoretically, you could eventually overflow the number storage size, resulting
	    // in duplicate IDs. But in JavaScript, the largest exact integral value is 2^53
	    // or 9,007,199,254,740,992. If you created 1,000,000 IDs per second, it would
	    // take over 285 years to reach that number.
	    // Reference http://blog.vjeux.com/2010/javascript/javascript-max_int-number-limits.html
	    function getId() {
	        return ++lastId;
	    }
	
	    function begin(options) {
	        outerFrames.push(currentFrame);
	        currentFrame = options;
	    }
	
	    function end() {
	        currentFrame = outerFrames.pop();
	    }
	
	    return {
	        begin: begin,
	
	        end: end,
	
	        registerDependency: function (subscribable) {
	            if (currentFrame) {
	                if (!ko.isSubscribable(subscribable))
	                    throw new Error("Only subscribable things can act as dependencies");
	                currentFrame.callback.call(currentFrame.callbackTarget, subscribable, subscribable._id || (subscribable._id = getId()));
	            }
	        },
	
	        ignore: function (callback, callbackTarget, callbackArgs) {
	            try {
	                begin();
	                return callback.apply(callbackTarget, callbackArgs || []);
	            } finally {
	                end();
	            }
	        },
	
	        getDependenciesCount: function () {
	            if (currentFrame)
	                return currentFrame.computed.getDependenciesCount();
	        },
	
	        isInitial: function() {
	            if (currentFrame)
	                return currentFrame.isInitial;
	        }
	    };
	})();
	
	ko.exportSymbol('computedContext', ko.computedContext);
	ko.exportSymbol('computedContext.getDependenciesCount', ko.computedContext.getDependenciesCount);
	ko.exportSymbol('computedContext.isInitial', ko.computedContext.isInitial);
	
	ko.exportSymbol('ignoreDependencies', ko.ignoreDependencies = ko.dependencyDetection.ignore);
	var observableLatestValue = ko.utils.createSymbolOrString('_latestValue');
	
	ko.observable = function (initialValue) {
	    function observable() {
	        if (arguments.length > 0) {
	            // Write
	
	            // Ignore writes if the value hasn't changed
	            if (observable.isDifferent(observable[observableLatestValue], arguments[0])) {
	                observable.valueWillMutate();
	                observable[observableLatestValue] = arguments[0];
	                observable.valueHasMutated();
	            }
	            return this; // Permits chained assignments
	        }
	        else {
	            // Read
	            ko.dependencyDetection.registerDependency(observable); // The caller only needs to be notified of changes if they did a "read" operation
	            return observable[observableLatestValue];
	        }
	    }
	
	    observable[observableLatestValue] = initialValue;
	
	    // Inherit from 'subscribable'
	    if (!ko.utils.canSetPrototype) {
	        // 'subscribable' won't be on the prototype chain unless we put it there directly
	        ko.utils.extend(observable, ko.subscribable['fn']);
	    }
	    ko.subscribable['fn'].init(observable);
	
	    // Inherit from 'observable'
	    ko.utils.setPrototypeOfOrExtend(observable, observableFn);
	
	    if (ko.options['deferUpdates']) {
	        ko.extenders['deferred'](observable, true);
	    }
	
	    return observable;
	}
	
	// Define prototype for observables
	var observableFn = {
	    'equalityComparer': valuesArePrimitiveAndEqual,
	    peek: function() { return this[observableLatestValue]; },
	    valueHasMutated: function () { this['notifySubscribers'](this[observableLatestValue]); },
	    valueWillMutate: function () { this['notifySubscribers'](this[observableLatestValue], 'beforeChange'); }
	};
	
	// Note that for browsers that don't support proto assignment, the
	// inheritance chain is created manually in the ko.observable constructor
	if (ko.utils.canSetPrototype) {
	    ko.utils.setPrototypeOf(observableFn, ko.subscribable['fn']);
	}
	
	var protoProperty = ko.observable.protoProperty = '__ko_proto__';
	observableFn[protoProperty] = ko.observable;
	
	ko.hasPrototype = function(instance, prototype) {
	    if ((instance === null) || (instance === undefined) || (instance[protoProperty] === undefined)) return false;
	    if (instance[protoProperty] === prototype) return true;
	    return ko.hasPrototype(instance[protoProperty], prototype); // Walk the prototype chain
	};
	
	ko.isObservable = function (instance) {
	    return ko.hasPrototype(instance, ko.observable);
	}
	ko.isWriteableObservable = function (instance) {
	    // Observable
	    if ((typeof instance == 'function') && instance[protoProperty] === ko.observable)
	        return true;
	    // Writeable dependent observable
	    if ((typeof instance == 'function') && (instance[protoProperty] === ko.dependentObservable) && (instance.hasWriteFunction))
	        return true;
	    // Anything else
	    return false;
	}
	
	ko.exportSymbol('observable', ko.observable);
	ko.exportSymbol('isObservable', ko.isObservable);
	ko.exportSymbol('isWriteableObservable', ko.isWriteableObservable);
	ko.exportSymbol('isWritableObservable', ko.isWriteableObservable);
	ko.exportSymbol('observable.fn', observableFn);
	ko.exportProperty(observableFn, 'peek', observableFn.peek);
	ko.exportProperty(observableFn, 'valueHasMutated', observableFn.valueHasMutated);
	ko.exportProperty(observableFn, 'valueWillMutate', observableFn.valueWillMutate);
	ko.observableArray = function (initialValues) {
	    initialValues = initialValues || [];
	
	    if (typeof initialValues != 'object' || !('length' in initialValues))
	        throw new Error("The argument passed when initializing an observable array must be an array, or null, or undefined.");
	
	    var result = ko.observable(initialValues);
	    ko.utils.setPrototypeOfOrExtend(result, ko.observableArray['fn']);
	    return result.extend({'trackArrayChanges':true});
	};
	
	ko.observableArray['fn'] = {
	    'remove': function (valueOrPredicate) {
	        var underlyingArray = this.peek();
	        var removedValues = [];
	        var predicate = typeof valueOrPredicate == "function" && !ko.isObservable(valueOrPredicate) ? valueOrPredicate : function (value) { return value === valueOrPredicate; };
	        for (var i = 0; i < underlyingArray.length; i++) {
	            var value = underlyingArray[i];
	            if (predicate(value)) {
	                if (removedValues.length === 0) {
	                    this.valueWillMutate();
	                }
	                removedValues.push(value);
	                underlyingArray.splice(i, 1);
	                i--;
	            }
	        }
	        if (removedValues.length) {
	            this.valueHasMutated();
	        }
	        return removedValues;
	    },
	
	    'removeAll': function (arrayOfValues) {
	        // If you passed zero args, we remove everything
	        if (arrayOfValues === undefined) {
	            var underlyingArray = this.peek();
	            var allValues = underlyingArray.slice(0);
	            this.valueWillMutate();
	            underlyingArray.splice(0, underlyingArray.length);
	            this.valueHasMutated();
	            return allValues;
	        }
	        // If you passed an arg, we interpret it as an array of entries to remove
	        if (!arrayOfValues)
	            return [];
	        return this['remove'](function (value) {
	            return ko.utils.arrayIndexOf(arrayOfValues, value) >= 0;
	        });
	    },
	
	    'destroy': function (valueOrPredicate) {
	        var underlyingArray = this.peek();
	        var predicate = typeof valueOrPredicate == "function" && !ko.isObservable(valueOrPredicate) ? valueOrPredicate : function (value) { return value === valueOrPredicate; };
	        this.valueWillMutate();
	        for (var i = underlyingArray.length - 1; i >= 0; i--) {
	            var value = underlyingArray[i];
	            if (predicate(value))
	                underlyingArray[i]["_destroy"] = true;
	        }
	        this.valueHasMutated();
	    },
	
	    'destroyAll': function (arrayOfValues) {
	        // If you passed zero args, we destroy everything
	        if (arrayOfValues === undefined)
	            return this['destroy'](function() { return true });
	
	        // If you passed an arg, we interpret it as an array of entries to destroy
	        if (!arrayOfValues)
	            return [];
	        return this['destroy'](function (value) {
	            return ko.utils.arrayIndexOf(arrayOfValues, value) >= 0;
	        });
	    },
	
	    'indexOf': function (item) {
	        var underlyingArray = this();
	        return ko.utils.arrayIndexOf(underlyingArray, item);
	    },
	
	    'replace': function(oldItem, newItem) {
	        var index = this['indexOf'](oldItem);
	        if (index >= 0) {
	            this.valueWillMutate();
	            this.peek()[index] = newItem;
	            this.valueHasMutated();
	        }
	    }
	};
	
	// Note that for browsers that don't support proto assignment, the
	// inheritance chain is created manually in the ko.observableArray constructor
	if (ko.utils.canSetPrototype) {
	    ko.utils.setPrototypeOf(ko.observableArray['fn'], ko.observable['fn']);
	}
	
	// Populate ko.observableArray.fn with read/write functions from native arrays
	// Important: Do not add any additional functions here that may reasonably be used to *read* data from the array
	// because we'll eval them without causing subscriptions, so ko.computed output could end up getting stale
	ko.utils.arrayForEach(["pop", "push", "reverse", "shift", "sort", "splice", "unshift"], function (methodName) {
	    ko.observableArray['fn'][methodName] = function () {
	        // Use "peek" to avoid creating a subscription in any computed that we're executing in the context of
	        // (for consistency with mutating regular observables)
	        var underlyingArray = this.peek();
	        this.valueWillMutate();
	        this.cacheDiffForKnownOperation(underlyingArray, methodName, arguments);
	        var methodCallResult = underlyingArray[methodName].apply(underlyingArray, arguments);
	        this.valueHasMutated();
	        // The native sort and reverse methods return a reference to the array, but it makes more sense to return the observable array instead.
	        return methodCallResult === underlyingArray ? this : methodCallResult;
	    };
	});
	
	// Populate ko.observableArray.fn with read-only functions from native arrays
	ko.utils.arrayForEach(["slice"], function (methodName) {
	    ko.observableArray['fn'][methodName] = function () {
	        var underlyingArray = this();
	        return underlyingArray[methodName].apply(underlyingArray, arguments);
	    };
	});
	
	ko.exportSymbol('observableArray', ko.observableArray);
	var arrayChangeEventName = 'arrayChange';
	ko.extenders['trackArrayChanges'] = function(target, options) {
	    // Use the provided options--each call to trackArrayChanges overwrites the previously set options
	    target.compareArrayOptions = {};
	    if (options && typeof options == "object") {
	        ko.utils.extend(target.compareArrayOptions, options);
	    }
	    target.compareArrayOptions['sparse'] = true;
	
	    // Only modify the target observable once
	    if (target.cacheDiffForKnownOperation) {
	        return;
	    }
	    var trackingChanges = false,
	        cachedDiff = null,
	        arrayChangeSubscription,
	        pendingNotifications = 0,
	        underlyingNotifySubscribersFunction,
	        underlyingBeforeSubscriptionAddFunction = target.beforeSubscriptionAdd,
	        underlyingAfterSubscriptionRemoveFunction = target.afterSubscriptionRemove;
	
	    // Watch "subscribe" calls, and for array change events, ensure change tracking is enabled
	    target.beforeSubscriptionAdd = function (event) {
	        if (underlyingBeforeSubscriptionAddFunction)
	            underlyingBeforeSubscriptionAddFunction.call(target, event);
	        if (event === arrayChangeEventName) {
	            trackChanges();
	        }
	    };
	    // Watch "dispose" calls, and for array change events, ensure change tracking is disabled when all are disposed
	    target.afterSubscriptionRemove = function (event) {
	        if (underlyingAfterSubscriptionRemoveFunction)
	            underlyingAfterSubscriptionRemoveFunction.call(target, event);
	        if (event === arrayChangeEventName && !target.hasSubscriptionsForEvent(arrayChangeEventName)) {
	            if (underlyingNotifySubscribersFunction) {
	                target['notifySubscribers'] = underlyingNotifySubscribersFunction;
	                underlyingNotifySubscribersFunction = undefined;
	            }
	            arrayChangeSubscription.dispose();
	            trackingChanges = false;
	        }
	    };
	
	    function trackChanges() {
	        // Calling 'trackChanges' multiple times is the same as calling it once
	        if (trackingChanges) {
	            return;
	        }
	
	        trackingChanges = true;
	
	        // Intercept "notifySubscribers" to track how many times it was called.
	        underlyingNotifySubscribersFunction = target['notifySubscribers'];
	        target['notifySubscribers'] = function(valueToNotify, event) {
	            if (!event || event === defaultEvent) {
	                ++pendingNotifications;
	            }
	            return underlyingNotifySubscribersFunction.apply(this, arguments);
	        };
	
	        // Each time the array changes value, capture a clone so that on the next
	        // change it's possible to produce a diff
	        var previousContents = [].concat(target.peek() || []);
	        cachedDiff = null;
	        arrayChangeSubscription = target.subscribe(function(currentContents) {
	            // Make a copy of the current contents and ensure it's an array
	            currentContents = [].concat(currentContents || []);
	
	            // Compute the diff and issue notifications, but only if someone is listening
	            if (target.hasSubscriptionsForEvent(arrayChangeEventName)) {
	                var changes = getChanges(previousContents, currentContents);
	            }
	
	            // Eliminate references to the old, removed items, so they can be GCed
	            previousContents = currentContents;
	            cachedDiff = null;
	            pendingNotifications = 0;
	
	            if (changes && changes.length) {
	                target['notifySubscribers'](changes, arrayChangeEventName);
	            }
	        });
	    }
	
	    function getChanges(previousContents, currentContents) {
	        // We try to re-use cached diffs.
	        // The scenarios where pendingNotifications > 1 are when using rate-limiting or the Deferred Updates
	        // plugin, which without this check would not be compatible with arrayChange notifications. Normally,
	        // notifications are issued immediately so we wouldn't be queueing up more than one.
	        if (!cachedDiff || pendingNotifications > 1) {
	            cachedDiff = ko.utils.compareArrays(previousContents, currentContents, target.compareArrayOptions);
	        }
	
	        return cachedDiff;
	    }
	
	    target.cacheDiffForKnownOperation = function(rawArray, operationName, args) {
	        // Only run if we're currently tracking changes for this observable array
	        // and there aren't any pending deferred notifications.
	        if (!trackingChanges || pendingNotifications) {
	            return;
	        }
	        var diff = [],
	            arrayLength = rawArray.length,
	            argsLength = args.length,
	            offset = 0;
	
	        function pushDiff(status, value, index) {
	            return diff[diff.length] = { 'status': status, 'value': value, 'index': index };
	        }
	        switch (operationName) {
	            case 'push':
	                offset = arrayLength;
	            case 'unshift':
	                for (var index = 0; index < argsLength; index++) {
	                    pushDiff('added', args[index], offset + index);
	                }
	                break;
	
	            case 'pop':
	                offset = arrayLength - 1;
	            case 'shift':
	                if (arrayLength) {
	                    pushDiff('deleted', rawArray[offset], offset);
	                }
	                break;
	
	            case 'splice':
	                // Negative start index means 'from end of array'. After that we clamp to [0...arrayLength].
	                // See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/splice
	                var startIndex = Math.min(Math.max(0, args[0] < 0 ? arrayLength + args[0] : args[0]), arrayLength),
	                    endDeleteIndex = argsLength === 1 ? arrayLength : Math.min(startIndex + (args[1] || 0), arrayLength),
	                    endAddIndex = startIndex + argsLength - 2,
	                    endIndex = Math.max(endDeleteIndex, endAddIndex),
	                    additions = [], deletions = [];
	                for (var index = startIndex, argsIndex = 2; index < endIndex; ++index, ++argsIndex) {
	                    if (index < endDeleteIndex)
	                        deletions.push(pushDiff('deleted', rawArray[index], index));
	                    if (index < endAddIndex)
	                        additions.push(pushDiff('added', args[argsIndex], index));
	                }
	                ko.utils.findMovesInArrayComparison(deletions, additions);
	                break;
	
	            default:
	                return;
	        }
	        cachedDiff = diff;
	    };
	};
	var computedState = ko.utils.createSymbolOrString('_state');
	
	ko.computed = ko.dependentObservable = function (evaluatorFunctionOrOptions, evaluatorFunctionTarget, options) {
	    if (typeof evaluatorFunctionOrOptions === "object") {
	        // Single-parameter syntax - everything is on this "options" param
	        options = evaluatorFunctionOrOptions;
	    } else {
	        // Multi-parameter syntax - construct the options according to the params passed
	        options = options || {};
	        if (evaluatorFunctionOrOptions) {
	            options["read"] = evaluatorFunctionOrOptions;
	        }
	    }
	    if (typeof options["read"] != "function")
	        throw Error("Pass a function that returns the value of the ko.computed");
	
	    var writeFunction = options["write"];
	    var state = {
	        latestValue: undefined,
	        isStale: true,
	        isBeingEvaluated: false,
	        suppressDisposalUntilDisposeWhenReturnsFalse: false,
	        isDisposed: false,
	        pure: false,
	        isSleeping: false,
	        readFunction: options["read"],
	        evaluatorFunctionTarget: evaluatorFunctionTarget || options["owner"],
	        disposeWhenNodeIsRemoved: options["disposeWhenNodeIsRemoved"] || options.disposeWhenNodeIsRemoved || null,
	        disposeWhen: options["disposeWhen"] || options.disposeWhen,
	        domNodeDisposalCallback: null,
	        dependencyTracking: {},
	        dependenciesCount: 0,
	        evaluationTimeoutInstance: null
	    };
	
	    function computedObservable() {
	        if (arguments.length > 0) {
	            if (typeof writeFunction === "function") {
	                // Writing a value
	                writeFunction.apply(state.evaluatorFunctionTarget, arguments);
	            } else {
	                throw new Error("Cannot write a value to a ko.computed unless you specify a 'write' option. If you wish to read the current value, don't pass any parameters.");
	            }
	            return this; // Permits chained assignments
	        } else {
	            // Reading the value
	            ko.dependencyDetection.registerDependency(computedObservable);
	            if (state.isStale || (state.isSleeping && computedObservable.haveDependenciesChanged())) {
	                computedObservable.evaluateImmediate();
	            }
	            return state.latestValue;
	        }
	    }
	
	    computedObservable[computedState] = state;
	    computedObservable.hasWriteFunction = typeof writeFunction === "function";
	
	    // Inherit from 'subscribable'
	    if (!ko.utils.canSetPrototype) {
	        // 'subscribable' won't be on the prototype chain unless we put it there directly
	        ko.utils.extend(computedObservable, ko.subscribable['fn']);
	    }
	    ko.subscribable['fn'].init(computedObservable);
	
	    // Inherit from 'computed'
	    ko.utils.setPrototypeOfOrExtend(computedObservable, computedFn);
	
	    if (options['pure']) {
	        state.pure = true;
	        state.isSleeping = true;     // Starts off sleeping; will awake on the first subscription
	        ko.utils.extend(computedObservable, pureComputedOverrides);
	    } else if (options['deferEvaluation']) {
	        ko.utils.extend(computedObservable, deferEvaluationOverrides);
	    }
	
	    if (ko.options['deferUpdates']) {
	        ko.extenders['deferred'](computedObservable, true);
	    }
	
	    if (DEBUG) {
	        // #1731 - Aid debugging by exposing the computed's options
	        computedObservable["_options"] = options;
	    }
	
	    if (state.disposeWhenNodeIsRemoved) {
	        // Since this computed is associated with a DOM node, and we don't want to dispose the computed
	        // until the DOM node is *removed* from the document (as opposed to never having been in the document),
	        // we'll prevent disposal until "disposeWhen" first returns false.
	        state.suppressDisposalUntilDisposeWhenReturnsFalse = true;
	
	        // disposeWhenNodeIsRemoved: true can be used to opt into the "only dispose after first false result"
	        // behaviour even if there's no specific node to watch. In that case, clear the option so we don't try
	        // to watch for a non-node's disposal. This technique is intended for KO's internal use only and shouldn't
	        // be documented or used by application code, as it's likely to change in a future version of KO.
	        if (!state.disposeWhenNodeIsRemoved.nodeType) {
	            state.disposeWhenNodeIsRemoved = null;
	        }
	    }
	
	    // Evaluate, unless sleeping or deferEvaluation is true
	    if (!state.isSleeping && !options['deferEvaluation']) {
	        computedObservable.evaluateImmediate();
	    }
	
	    // Attach a DOM node disposal callback so that the computed will be proactively disposed as soon as the node is
	    // removed using ko.removeNode. But skip if isActive is false (there will never be any dependencies to dispose).
	    if (state.disposeWhenNodeIsRemoved && computedObservable.isActive()) {
	        ko.utils.domNodeDisposal.addDisposeCallback(state.disposeWhenNodeIsRemoved, state.domNodeDisposalCallback = function () {
	            computedObservable.dispose();
	        });
	    }
	
	    return computedObservable;
	};
	
	// Utility function that disposes a given dependencyTracking entry
	function computedDisposeDependencyCallback(id, entryToDispose) {
	    if (entryToDispose !== null && entryToDispose.dispose) {
	        entryToDispose.dispose();
	    }
	}
	
	// This function gets called each time a dependency is detected while evaluating a computed.
	// It's factored out as a shared function to avoid creating unnecessary function instances during evaluation.
	function computedBeginDependencyDetectionCallback(subscribable, id) {
	    var computedObservable = this.computedObservable,
	        state = computedObservable[computedState];
	    if (!state.isDisposed) {
	        if (this.disposalCount && this.disposalCandidates[id]) {
	            // Don't want to dispose this subscription, as it's still being used
	            computedObservable.addDependencyTracking(id, subscribable, this.disposalCandidates[id]);
	            this.disposalCandidates[id] = null; // No need to actually delete the property - disposalCandidates is a transient object anyway
	            --this.disposalCount;
	        } else if (!state.dependencyTracking[id]) {
	            // Brand new subscription - add it
	            computedObservable.addDependencyTracking(id, subscribable, state.isSleeping ? { _target: subscribable } : computedObservable.subscribeToDependency(subscribable));
	        }
	    }
	}
	
	var computedFn = {
	    "equalityComparer": valuesArePrimitiveAndEqual,
	    getDependenciesCount: function () {
	        return this[computedState].dependenciesCount;
	    },
	    addDependencyTracking: function (id, target, trackingObj) {
	        if (this[computedState].pure && target === this) {
	            throw Error("A 'pure' computed must not be called recursively");
	        }
	
	        this[computedState].dependencyTracking[id] = trackingObj;
	        trackingObj._order = this[computedState].dependenciesCount++;
	        trackingObj._version = target.getVersion();
	    },
	    haveDependenciesChanged: function () {
	        var id, dependency, dependencyTracking = this[computedState].dependencyTracking;
	        for (id in dependencyTracking) {
	            if (dependencyTracking.hasOwnProperty(id)) {
	                dependency = dependencyTracking[id];
	                if (dependency._target.hasChanged(dependency._version)) {
	                    return true;
	                }
	            }
	        }
	    },
	    markDirty: function () {
	        // Process "dirty" events if we can handle delayed notifications
	        if (this._evalDelayed && !this[computedState].isBeingEvaluated) {
	            this._evalDelayed();
	        }
	    },
	    isActive: function () {
	        return this[computedState].isStale || this[computedState].dependenciesCount > 0;
	    },
	    respondToChange: function () {
	        // Ignore "change" events if we've already scheduled a delayed notification
	        if (!this._notificationIsPending) {
	            this.evaluatePossiblyAsync();
	        }
	    },
	    subscribeToDependency: function (target) {
	        if (target._deferUpdates && !this[computedState].disposeWhenNodeIsRemoved) {
	            var dirtySub = target.subscribe(this.markDirty, this, 'dirty'),
	                changeSub = target.subscribe(this.respondToChange, this);
	            return {
	                _target: target,
	                dispose: function () {
	                    dirtySub.dispose();
	                    changeSub.dispose();
	                }
	            };
	        } else {
	            return target.subscribe(this.evaluatePossiblyAsync, this);
	        }
	    },
	    evaluatePossiblyAsync: function () {
	        var computedObservable = this,
	            throttleEvaluationTimeout = computedObservable['throttleEvaluation'];
	        if (throttleEvaluationTimeout && throttleEvaluationTimeout >= 0) {
	            clearTimeout(this[computedState].evaluationTimeoutInstance);
	            this[computedState].evaluationTimeoutInstance = ko.utils.setTimeout(function () {
	                computedObservable.evaluateImmediate(true /*notifyChange*/);
	            }, throttleEvaluationTimeout);
	        } else if (computedObservable._evalDelayed) {
	            computedObservable._evalDelayed();
	        } else {
	            computedObservable.evaluateImmediate(true /*notifyChange*/);
	        }
	    },
	    evaluateImmediate: function (notifyChange) {
	        var computedObservable = this,
	            state = computedObservable[computedState],
	            disposeWhen = state.disposeWhen,
	            changed = false;
	
	        if (state.isBeingEvaluated) {
	            // If the evaluation of a ko.computed causes side effects, it's possible that it will trigger its own re-evaluation.
	            // This is not desirable (it's hard for a developer to realise a chain of dependencies might cause this, and they almost
	            // certainly didn't intend infinite re-evaluations). So, for predictability, we simply prevent ko.computeds from causing
	            // their own re-evaluation. Further discussion at https://github.com/SteveSanderson/knockout/pull/387
	            return;
	        }
	
	        // Do not evaluate (and possibly capture new dependencies) if disposed
	        if (state.isDisposed) {
	            return;
	        }
	
	        if (state.disposeWhenNodeIsRemoved && !ko.utils.domNodeIsAttachedToDocument(state.disposeWhenNodeIsRemoved) || disposeWhen && disposeWhen()) {
	            // See comment above about suppressDisposalUntilDisposeWhenReturnsFalse
	            if (!state.suppressDisposalUntilDisposeWhenReturnsFalse) {
	                computedObservable.dispose();
	                return;
	            }
	        } else {
	            // It just did return false, so we can stop suppressing now
	            state.suppressDisposalUntilDisposeWhenReturnsFalse = false;
	        }
	
	        state.isBeingEvaluated = true;
	        try {
	            changed = this.evaluateImmediate_CallReadWithDependencyDetection(notifyChange);
	        } finally {
	            state.isBeingEvaluated = false;
	        }
	
	        if (!state.dependenciesCount) {
	            computedObservable.dispose();
	        }
	
	        return changed;
	    },
	    evaluateImmediate_CallReadWithDependencyDetection: function (notifyChange) {
	        // This function is really just part of the evaluateImmediate logic. You would never call it from anywhere else.
	        // Factoring it out into a separate function means it can be independent of the try/catch block in evaluateImmediate,
	        // which contributes to saving about 40% off the CPU overhead of computed evaluation (on V8 at least).
	
	        var computedObservable = this,
	            state = computedObservable[computedState],
	            changed = false;
	
	        // Initially, we assume that none of the subscriptions are still being used (i.e., all are candidates for disposal).
	        // Then, during evaluation, we cross off any that are in fact still being used.
	        var isInitial = state.pure ? undefined : !state.dependenciesCount,   // If we're evaluating when there are no previous dependencies, it must be the first time
	            dependencyDetectionContext = {
	                computedObservable: computedObservable,
	                disposalCandidates: state.dependencyTracking,
	                disposalCount: state.dependenciesCount
	            };
	
	        ko.dependencyDetection.begin({
	            callbackTarget: dependencyDetectionContext,
	            callback: computedBeginDependencyDetectionCallback,
	            computed: computedObservable,
	            isInitial: isInitial
	        });
	
	        state.dependencyTracking = {};
	        state.dependenciesCount = 0;
	
	        var newValue = this.evaluateImmediate_CallReadThenEndDependencyDetection(state, dependencyDetectionContext);
	
	        if (computedObservable.isDifferent(state.latestValue, newValue)) {
	            if (!state.isSleeping) {
	                computedObservable["notifySubscribers"](state.latestValue, "beforeChange");
	            }
	
	            state.latestValue = newValue;
	            if (DEBUG) computedObservable._latestValue = newValue;
	
	            if (state.isSleeping) {
	                computedObservable.updateVersion();
	            } else if (notifyChange) {
	                computedObservable["notifySubscribers"](state.latestValue);
	            }
	
	            changed = true;
	        }
	
	        if (isInitial) {
	            computedObservable["notifySubscribers"](state.latestValue, "awake");
	        }
	
	        return changed;
	    },
	    evaluateImmediate_CallReadThenEndDependencyDetection: function (state, dependencyDetectionContext) {
	        // This function is really part of the evaluateImmediate_CallReadWithDependencyDetection logic.
	        // You'd never call it from anywhere else. Factoring it out means that evaluateImmediate_CallReadWithDependencyDetection
	        // can be independent of try/finally blocks, which contributes to saving about 40% off the CPU
	        // overhead of computed evaluation (on V8 at least).
	
	        try {
	            var readFunction = state.readFunction;
	            return state.evaluatorFunctionTarget ? readFunction.call(state.evaluatorFunctionTarget) : readFunction();
	        } finally {
	            ko.dependencyDetection.end();
	
	            // For each subscription no longer being used, remove it from the active subscriptions list and dispose it
	            if (dependencyDetectionContext.disposalCount && !state.isSleeping) {
	                ko.utils.objectForEach(dependencyDetectionContext.disposalCandidates, computedDisposeDependencyCallback);
	            }
	
	            state.isStale = false;
	        }
	    },
	    peek: function () {
	        // Peek won't re-evaluate, except while the computed is sleeping or to get the initial value when "deferEvaluation" is set.
	        var state = this[computedState];
	        if ((state.isStale && !state.dependenciesCount) || (state.isSleeping && this.haveDependenciesChanged())) {
	            this.evaluateImmediate();
	        }
	        return state.latestValue;
	    },
	    limit: function (limitFunction) {
	        // Override the limit function with one that delays evaluation as well
	        ko.subscribable['fn'].limit.call(this, limitFunction);
	        this._evalDelayed = function () {
	            this._limitBeforeChange(this[computedState].latestValue);
	
	            this[computedState].isStale = true; // Mark as dirty
	
	            // Pass the observable to the "limit" code, which will access it when
	            // it's time to do the notification.
	            this._limitChange(this);
	        }
	    },
	    dispose: function () {
	        var state = this[computedState];
	        if (!state.isSleeping && state.dependencyTracking) {
	            ko.utils.objectForEach(state.dependencyTracking, function (id, dependency) {
	                if (dependency.dispose)
	                    dependency.dispose();
	            });
	        }
	        if (state.disposeWhenNodeIsRemoved && state.domNodeDisposalCallback) {
	            ko.utils.domNodeDisposal.removeDisposeCallback(state.disposeWhenNodeIsRemoved, state.domNodeDisposalCallback);
	        }
	        state.dependencyTracking = null;
	        state.dependenciesCount = 0;
	        state.isDisposed = true;
	        state.isStale = false;
	        state.isSleeping = false;
	        state.disposeWhenNodeIsRemoved = null;
	    }
	};
	
	var pureComputedOverrides = {
	    beforeSubscriptionAdd: function (event) {
	        // If asleep, wake up the computed by subscribing to any dependencies.
	        var computedObservable = this,
	            state = computedObservable[computedState];
	        if (!state.isDisposed && state.isSleeping && event == 'change') {
	            state.isSleeping = false;
	            if (state.isStale || computedObservable.haveDependenciesChanged()) {
	                state.dependencyTracking = null;
	                state.dependenciesCount = 0;
	                state.isStale = true;
	                if (computedObservable.evaluateImmediate()) {
	                    computedObservable.updateVersion();
	                }
	            } else {
	                // First put the dependencies in order
	                var dependeciesOrder = [];
	                ko.utils.objectForEach(state.dependencyTracking, function (id, dependency) {
	                    dependeciesOrder[dependency._order] = id;
	                });
	                // Next, subscribe to each one
	                ko.utils.arrayForEach(dependeciesOrder, function (id, order) {
	                    var dependency = state.dependencyTracking[id],
	                        subscription = computedObservable.subscribeToDependency(dependency._target);
	                    subscription._order = order;
	                    subscription._version = dependency._version;
	                    state.dependencyTracking[id] = subscription;
	                });
	            }
	            if (!state.isDisposed) {     // test since evaluating could trigger disposal
	                computedObservable["notifySubscribers"](state.latestValue, "awake");
	            }
	        }
	    },
	    afterSubscriptionRemove: function (event) {
	        var state = this[computedState];
	        if (!state.isDisposed && event == 'change' && !this.hasSubscriptionsForEvent('change')) {
	            ko.utils.objectForEach(state.dependencyTracking, function (id, dependency) {
	                if (dependency.dispose) {
	                    state.dependencyTracking[id] = {
	                        _target: dependency._target,
	                        _order: dependency._order,
	                        _version: dependency._version
	                    };
	                    dependency.dispose();
	                }
	            });
	            state.isSleeping = true;
	            this["notifySubscribers"](undefined, "asleep");
	        }
	    },
	    getVersion: function () {
	        // Because a pure computed is not automatically updated while it is sleeping, we can't
	        // simply return the version number. Instead, we check if any of the dependencies have
	        // changed and conditionally re-evaluate the computed observable.
	        var state = this[computedState];
	        if (state.isSleeping && (state.isStale || this.haveDependenciesChanged())) {
	            this.evaluateImmediate();
	        }
	        return ko.subscribable['fn'].getVersion.call(this);
	    }
	};
	
	var deferEvaluationOverrides = {
	    beforeSubscriptionAdd: function (event) {
	        // This will force a computed with deferEvaluation to evaluate when the first subscription is registered.
	        if (event == 'change' || event == 'beforeChange') {
	            this.peek();
	        }
	    }
	};
	
	// Note that for browsers that don't support proto assignment, the
	// inheritance chain is created manually in the ko.computed constructor
	if (ko.utils.canSetPrototype) {
	    ko.utils.setPrototypeOf(computedFn, ko.subscribable['fn']);
	}
	
	// Set the proto chain values for ko.hasPrototype
	var protoProp = ko.observable.protoProperty; // == "__ko_proto__"
	ko.computed[protoProp] = ko.observable;
	computedFn[protoProp] = ko.computed;
	
	ko.isComputed = function (instance) {
	    return ko.hasPrototype(instance, ko.computed);
	};
	
	ko.isPureComputed = function (instance) {
	    return ko.hasPrototype(instance, ko.computed)
	        && instance[computedState] && instance[computedState].pure;
	};
	
	ko.exportSymbol('computed', ko.computed);
	ko.exportSymbol('dependentObservable', ko.computed);    // export ko.dependentObservable for backwards compatibility (1.x)
	ko.exportSymbol('isComputed', ko.isComputed);
	ko.exportSymbol('isPureComputed', ko.isPureComputed);
	ko.exportSymbol('computed.fn', computedFn);
	ko.exportProperty(computedFn, 'peek', computedFn.peek);
	ko.exportProperty(computedFn, 'dispose', computedFn.dispose);
	ko.exportProperty(computedFn, 'isActive', computedFn.isActive);
	ko.exportProperty(computedFn, 'getDependenciesCount', computedFn.getDependenciesCount);
	
	ko.pureComputed = function (evaluatorFunctionOrOptions, evaluatorFunctionTarget) {
	    if (typeof evaluatorFunctionOrOptions === 'function') {
	        return ko.computed(evaluatorFunctionOrOptions, evaluatorFunctionTarget, {'pure':true});
	    } else {
	        evaluatorFunctionOrOptions = ko.utils.extend({}, evaluatorFunctionOrOptions);   // make a copy of the parameter object
	        evaluatorFunctionOrOptions['pure'] = true;
	        return ko.computed(evaluatorFunctionOrOptions, evaluatorFunctionTarget);
	    }
	}
	ko.exportSymbol('pureComputed', ko.pureComputed);
	
	(function() {
	    var maxNestedObservableDepth = 10; // Escape the (unlikely) pathalogical case where an observable's current value is itself (or similar reference cycle)
	
	    ko.toJS = function(rootObject) {
	        if (arguments.length == 0)
	            throw new Error("When calling ko.toJS, pass the object you want to convert.");
	
	        // We just unwrap everything at every level in the object graph
	        return mapJsObjectGraph(rootObject, function(valueToMap) {
	            // Loop because an observable's value might in turn be another observable wrapper
	            for (var i = 0; ko.isObservable(valueToMap) && (i < maxNestedObservableDepth); i++)
	                valueToMap = valueToMap();
	            return valueToMap;
	        });
	    };
	
	    ko.toJSON = function(rootObject, replacer, space) {     // replacer and space are optional
	        var plainJavaScriptObject = ko.toJS(rootObject);
	        return ko.utils.stringifyJson(plainJavaScriptObject, replacer, space);
	    };
	
	    function mapJsObjectGraph(rootObject, mapInputCallback, visitedObjects) {
	        visitedObjects = visitedObjects || new objectLookup();
	
	        rootObject = mapInputCallback(rootObject);
	        var canHaveProperties = (typeof rootObject == "object") && (rootObject !== null) && (rootObject !== undefined) && (!(rootObject instanceof RegExp)) && (!(rootObject instanceof Date)) && (!(rootObject instanceof String)) && (!(rootObject instanceof Number)) && (!(rootObject instanceof Boolean));
	        if (!canHaveProperties)
	            return rootObject;
	
	        var outputProperties = rootObject instanceof Array ? [] : {};
	        visitedObjects.save(rootObject, outputProperties);
	
	        visitPropertiesOrArrayEntries(rootObject, function(indexer) {
	            var propertyValue = mapInputCallback(rootObject[indexer]);
	
	            switch (typeof propertyValue) {
	                case "boolean":
	                case "number":
	                case "string":
	                case "function":
	                    outputProperties[indexer] = propertyValue;
	                    break;
	                case "object":
	                case "undefined":
	                    var previouslyMappedValue = visitedObjects.get(propertyValue);
	                    outputProperties[indexer] = (previouslyMappedValue !== undefined)
	                        ? previouslyMappedValue
	                        : mapJsObjectGraph(propertyValue, mapInputCallback, visitedObjects);
	                    break;
	            }
	        });
	
	        return outputProperties;
	    }
	
	    function visitPropertiesOrArrayEntries(rootObject, visitorCallback) {
	        if (rootObject instanceof Array) {
	            for (var i = 0; i < rootObject.length; i++)
	                visitorCallback(i);
	
	            // For arrays, also respect toJSON property for custom mappings (fixes #278)
	            if (typeof rootObject['toJSON'] == 'function')
	                visitorCallback('toJSON');
	        } else {
	            for (var propertyName in rootObject) {
	                visitorCallback(propertyName);
	            }
	        }
	    };
	
	    function objectLookup() {
	        this.keys = [];
	        this.values = [];
	    };
	
	    objectLookup.prototype = {
	        constructor: objectLookup,
	        save: function(key, value) {
	            var existingIndex = ko.utils.arrayIndexOf(this.keys, key);
	            if (existingIndex >= 0)
	                this.values[existingIndex] = value;
	            else {
	                this.keys.push(key);
	                this.values.push(value);
	            }
	        },
	        get: function(key) {
	            var existingIndex = ko.utils.arrayIndexOf(this.keys, key);
	            return (existingIndex >= 0) ? this.values[existingIndex] : undefined;
	        }
	    };
	})();
	
	ko.exportSymbol('toJS', ko.toJS);
	ko.exportSymbol('toJSON', ko.toJSON);
	(function () {
	    var hasDomDataExpandoProperty = '__ko__hasDomDataOptionValue__';
	
	    // Normally, SELECT elements and their OPTIONs can only take value of type 'string' (because the values
	    // are stored on DOM attributes). ko.selectExtensions provides a way for SELECTs/OPTIONs to have values
	    // that are arbitrary objects. This is very convenient when implementing things like cascading dropdowns.
	    ko.selectExtensions = {
	        readValue : function(element) {
	            switch (ko.utils.tagNameLower(element)) {
	                case 'option':
	                    if (element[hasDomDataExpandoProperty] === true)
	                        return ko.utils.domData.get(element, ko.bindingHandlers.options.optionValueDomDataKey);
	                    return ko.utils.ieVersion <= 7
	                        ? (element.getAttributeNode('value') && element.getAttributeNode('value').specified ? element.value : element.text)
	                        : element.value;
	                case 'select':
	                    return element.selectedIndex >= 0 ? ko.selectExtensions.readValue(element.options[element.selectedIndex]) : undefined;
	                default:
	                    return element.value;
	            }
	        },
	
	        writeValue: function(element, value, allowUnset) {
	            switch (ko.utils.tagNameLower(element)) {
	                case 'option':
	                    switch(typeof value) {
	                        case "string":
	                            ko.utils.domData.set(element, ko.bindingHandlers.options.optionValueDomDataKey, undefined);
	                            if (hasDomDataExpandoProperty in element) { // IE <= 8 throws errors if you delete non-existent properties from a DOM node
	                                delete element[hasDomDataExpandoProperty];
	                            }
	                            element.value = value;
	                            break;
	                        default:
	                            // Store arbitrary object using DomData
	                            ko.utils.domData.set(element, ko.bindingHandlers.options.optionValueDomDataKey, value);
	                            element[hasDomDataExpandoProperty] = true;
	
	                            // Special treatment of numbers is just for backward compatibility. KO 1.2.1 wrote numerical values to element.value.
	                            element.value = typeof value === "number" ? value : "";
	                            break;
	                    }
	                    break;
	                case 'select':
	                    if (value === "" || value === null)       // A blank string or null value will select the caption
	                        value = undefined;
	                    var selection = -1;
	                    for (var i = 0, n = element.options.length, optionValue; i < n; ++i) {
	                        optionValue = ko.selectExtensions.readValue(element.options[i]);
	                        // Include special check to handle selecting a caption with a blank string value
	                        if (optionValue == value || (optionValue == "" && value === undefined)) {
	                            selection = i;
	                            break;
	                        }
	                    }
	                    if (allowUnset || selection >= 0 || (value === undefined && element.size > 1)) {
	                        element.selectedIndex = selection;
	                    }
	                    break;
	                default:
	                    if ((value === null) || (value === undefined))
	                        value = "";
	                    element.value = value;
	                    break;
	            }
	        }
	    };
	})();
	
	ko.exportSymbol('selectExtensions', ko.selectExtensions);
	ko.exportSymbol('selectExtensions.readValue', ko.selectExtensions.readValue);
	ko.exportSymbol('selectExtensions.writeValue', ko.selectExtensions.writeValue);
	ko.expressionRewriting = (function () {
	    var javaScriptReservedWords = ["true", "false", "null", "undefined"];
	
	    // Matches something that can be assigned to--either an isolated identifier or something ending with a property accessor
	    // This is designed to be simple and avoid false negatives, but could produce false positives (e.g., a+b.c).
	    // This also will not properly handle nested brackets (e.g., obj1[obj2['prop']]; see #911).
	    var javaScriptAssignmentTarget = /^(?:[$_a-z][$\w]*|(.+)(\.\s*[$_a-z][$\w]*|\[.+\]))$/i;
	
	    function getWriteableValue(expression) {
	        if (ko.utils.arrayIndexOf(javaScriptReservedWords, expression) >= 0)
	            return false;
	        var match = expression.match(javaScriptAssignmentTarget);
	        return match === null ? false : match[1] ? ('Object(' + match[1] + ')' + match[2]) : expression;
	    }
	
	    // The following regular expressions will be used to split an object-literal string into tokens
	
	        // These two match strings, either with double quotes or single quotes
	    var stringDouble = '"(?:[^"\\\\]|\\\\.)*"',
	        stringSingle = "'(?:[^'\\\\]|\\\\.)*'",
	        // Matches a regular expression (text enclosed by slashes), but will also match sets of divisions
	        // as a regular expression (this is handled by the parsing loop below).
	        stringRegexp = '/(?:[^/\\\\]|\\\\.)*/\w*',
	        // These characters have special meaning to the parser and must not appear in the middle of a
	        // token, except as part of a string.
	        specials = ',"\'{}()/:[\\]',
	        // Match text (at least two characters) that does not contain any of the above special characters,
	        // although some of the special characters are allowed to start it (all but the colon and comma).
	        // The text can contain spaces, but leading or trailing spaces are skipped.
	        everyThingElse = '[^\\s:,/][^' + specials + ']*[^\\s' + specials + ']',
	        // Match any non-space character not matched already. This will match colons and commas, since they're
	        // not matched by "everyThingElse", but will also match any other single character that wasn't already
	        // matched (for example: in "a: 1, b: 2", each of the non-space characters will be matched by oneNotSpace).
	        oneNotSpace = '[^\\s]',
	
	        // Create the actual regular expression by or-ing the above strings. The order is important.
	        bindingToken = RegExp(stringDouble + '|' + stringSingle + '|' + stringRegexp + '|' + everyThingElse + '|' + oneNotSpace, 'g'),
	
	        // Match end of previous token to determine whether a slash is a division or regex.
	        divisionLookBehind = /[\])"'A-Za-z0-9_$]+$/,
	        keywordRegexLookBehind = {'in':1,'return':1,'typeof':1};
	
	    function parseObjectLiteral(objectLiteralString) {
	        // Trim leading and trailing spaces from the string
	        var str = ko.utils.stringTrim(objectLiteralString);
	
	        // Trim braces '{' surrounding the whole object literal
	        if (str.charCodeAt(0) === 123) str = str.slice(1, -1);
	
	        // Split into tokens
	        var result = [], toks = str.match(bindingToken), key, values = [], depth = 0;
	
	        if (toks) {
	            // Append a comma so that we don't need a separate code block to deal with the last item
	            toks.push(',');
	
	            for (var i = 0, tok; tok = toks[i]; ++i) {
	                var c = tok.charCodeAt(0);
	                // A comma signals the end of a key/value pair if depth is zero
	                if (c === 44) { // ","
	                    if (depth <= 0) {
	                        result.push((key && values.length) ? {key: key, value: values.join('')} : {'unknown': key || values.join('')});
	                        key = depth = 0;
	                        values = [];
	                        continue;
	                    }
	                // Simply skip the colon that separates the name and value
	                } else if (c === 58) { // ":"
	                    if (!depth && !key && values.length === 1) {
	                        key = values.pop();
	                        continue;
	                    }
	                // A set of slashes is initially matched as a regular expression, but could be division
	                } else if (c === 47 && i && tok.length > 1) {  // "/"
	                    // Look at the end of the previous token to determine if the slash is actually division
	                    var match = toks[i-1].match(divisionLookBehind);
	                    if (match && !keywordRegexLookBehind[match[0]]) {
	                        // The slash is actually a division punctuator; re-parse the remainder of the string (not including the slash)
	                        str = str.substr(str.indexOf(tok) + 1);
	                        toks = str.match(bindingToken);
	                        toks.push(',');
	                        i = -1;
	                        // Continue with just the slash
	                        tok = '/';
	                    }
	                // Increment depth for parentheses, braces, and brackets so that interior commas are ignored
	                } else if (c === 40 || c === 123 || c === 91) { // '(', '{', '['
	                    ++depth;
	                } else if (c === 41 || c === 125 || c === 93) { // ')', '}', ']'
	                    --depth;
	                // The key will be the first token; if it's a string, trim the quotes
	                } else if (!key && !values.length && (c === 34 || c === 39)) { // '"', "'"
	                    tok = tok.slice(1, -1);
	                }
	                values.push(tok);
	            }
	        }
	        return result;
	    }
	
	    // Two-way bindings include a write function that allow the handler to update the value even if it's not an observable.
	    var twoWayBindings = {};
	
	    function preProcessBindings(bindingsStringOrKeyValueArray, bindingOptions) {
	        bindingOptions = bindingOptions || {};
	
	        function processKeyValue(key, val) {
	            var writableVal;
	            function callPreprocessHook(obj) {
	                return (obj && obj['preprocess']) ? (val = obj['preprocess'](val, key, processKeyValue)) : true;
	            }
	            if (!bindingParams) {
	                if (!callPreprocessHook(ko['getBindingHandler'](key)))
	                    return;
	
	                if (twoWayBindings[key] && (writableVal = getWriteableValue(val))) {
	                    // For two-way bindings, provide a write method in case the value
	                    // isn't a writable observable.
	                    propertyAccessorResultStrings.push("'" + key + "':function(_z){" + writableVal + "=_z}");
	                }
	            }
	            // Values are wrapped in a function so that each value can be accessed independently
	            if (makeValueAccessors) {
	                val = 'function(){return ' + val + ' }';
	            }
	            resultStrings.push("'" + key + "':" + val);
	        }
	
	        var resultStrings = [],
	            propertyAccessorResultStrings = [],
	            makeValueAccessors = bindingOptions['valueAccessors'],
	            bindingParams = bindingOptions['bindingParams'],
	            keyValueArray = typeof bindingsStringOrKeyValueArray === "string" ?
	                parseObjectLiteral(bindingsStringOrKeyValueArray) : bindingsStringOrKeyValueArray;
	
	        ko.utils.arrayForEach(keyValueArray, function(keyValue) {
	            processKeyValue(keyValue.key || keyValue['unknown'], keyValue.value);
	        });
	
	        if (propertyAccessorResultStrings.length)
	            processKeyValue('_ko_property_writers', "{" + propertyAccessorResultStrings.join(",") + " }");
	
	        return resultStrings.join(",");
	    }
	
	    return {
	        bindingRewriteValidators: [],
	
	        twoWayBindings: twoWayBindings,
	
	        parseObjectLiteral: parseObjectLiteral,
	
	        preProcessBindings: preProcessBindings,
	
	        keyValueArrayContainsKey: function(keyValueArray, key) {
	            for (var i = 0; i < keyValueArray.length; i++)
	                if (keyValueArray[i]['key'] == key)
	                    return true;
	            return false;
	        },
	
	        // Internal, private KO utility for updating model properties from within bindings
	        // property:            If the property being updated is (or might be) an observable, pass it here
	        //                      If it turns out to be a writable observable, it will be written to directly
	        // allBindings:         An object with a get method to retrieve bindings in the current execution context.
	        //                      This will be searched for a '_ko_property_writers' property in case you're writing to a non-observable
	        // key:                 The key identifying the property to be written. Example: for { hasFocus: myValue }, write to 'myValue' by specifying the key 'hasFocus'
	        // value:               The value to be written
	        // checkIfDifferent:    If true, and if the property being written is a writable observable, the value will only be written if
	        //                      it is !== existing value on that writable observable
	        writeValueToProperty: function(property, allBindings, key, value, checkIfDifferent) {
	            if (!property || !ko.isObservable(property)) {
	                var propWriters = allBindings.get('_ko_property_writers');
	                if (propWriters && propWriters[key])
	                    propWriters[key](value);
	            } else if (ko.isWriteableObservable(property) && (!checkIfDifferent || property.peek() !== value)) {
	                property(value);
	            }
	        }
	    };
	})();
	
	ko.exportSymbol('expressionRewriting', ko.expressionRewriting);
	ko.exportSymbol('expressionRewriting.bindingRewriteValidators', ko.expressionRewriting.bindingRewriteValidators);
	ko.exportSymbol('expressionRewriting.parseObjectLiteral', ko.expressionRewriting.parseObjectLiteral);
	ko.exportSymbol('expressionRewriting.preProcessBindings', ko.expressionRewriting.preProcessBindings);
	
	// Making bindings explicitly declare themselves as "two way" isn't ideal in the long term (it would be better if
	// all bindings could use an official 'property writer' API without needing to declare that they might). However,
	// since this is not, and has never been, a public API (_ko_property_writers was never documented), it's acceptable
	// as an internal implementation detail in the short term.
	// For those developers who rely on _ko_property_writers in their custom bindings, we expose _twoWayBindings as an
	// undocumented feature that makes it relatively easy to upgrade to KO 3.0. However, this is still not an official
	// public API, and we reserve the right to remove it at any time if we create a real public property writers API.
	ko.exportSymbol('expressionRewriting._twoWayBindings', ko.expressionRewriting.twoWayBindings);
	
	// For backward compatibility, define the following aliases. (Previously, these function names were misleading because
	// they referred to JSON specifically, even though they actually work with arbitrary JavaScript object literal expressions.)
	ko.exportSymbol('jsonExpressionRewriting', ko.expressionRewriting);
	ko.exportSymbol('jsonExpressionRewriting.insertPropertyAccessorsIntoJson', ko.expressionRewriting.preProcessBindings);
	(function() {
	    // "Virtual elements" is an abstraction on top of the usual DOM API which understands the notion that comment nodes
	    // may be used to represent hierarchy (in addition to the DOM's natural hierarchy).
	    // If you call the DOM-manipulating functions on ko.virtualElements, you will be able to read and write the state
	    // of that virtual hierarchy
	    //
	    // The point of all this is to support containerless templates (e.g., <!-- ko foreach:someCollection -->blah<!-- /ko -->)
	    // without having to scatter special cases all over the binding and templating code.
	
	    // IE 9 cannot reliably read the "nodeValue" property of a comment node (see https://github.com/SteveSanderson/knockout/issues/186)
	    // but it does give them a nonstandard alternative property called "text" that it can read reliably. Other browsers don't have that property.
	    // So, use node.text where available, and node.nodeValue elsewhere
	    var commentNodesHaveTextProperty = document && document.createComment("test").text === "<!--test-->";
	
	    var startCommentRegex = commentNodesHaveTextProperty ? /^<!--\s*ko(?:\s+([\s\S]+))?\s*-->$/ : /^\s*ko(?:\s+([\s\S]+))?\s*$/;
	    var endCommentRegex =   commentNodesHaveTextProperty ? /^<!--\s*\/ko\s*-->$/ : /^\s*\/ko\s*$/;
	    var htmlTagsWithOptionallyClosingChildren = { 'ul': true, 'ol': true };
	
	    function isStartComment(node) {
	        return (node.nodeType == 8) && startCommentRegex.test(commentNodesHaveTextProperty ? node.text : node.nodeValue);
	    }
	
	    function isEndComment(node) {
	        return (node.nodeType == 8) && endCommentRegex.test(commentNodesHaveTextProperty ? node.text : node.nodeValue);
	    }
	
	    function getVirtualChildren(startComment, allowUnbalanced) {
	        var currentNode = startComment;
	        var depth = 1;
	        var children = [];
	        while (currentNode = currentNode.nextSibling) {
	            if (isEndComment(currentNode)) {
	                depth--;
	                if (depth === 0)
	                    return children;
	            }
	
	            children.push(currentNode);
	
	            if (isStartComment(currentNode))
	                depth++;
	        }
	        if (!allowUnbalanced)
	            throw new Error("Cannot find closing comment tag to match: " + startComment.nodeValue);
	        return null;
	    }
	
	    function getMatchingEndComment(startComment, allowUnbalanced) {
	        var allVirtualChildren = getVirtualChildren(startComment, allowUnbalanced);
	        if (allVirtualChildren) {
	            if (allVirtualChildren.length > 0)
	                return allVirtualChildren[allVirtualChildren.length - 1].nextSibling;
	            return startComment.nextSibling;
	        } else
	            return null; // Must have no matching end comment, and allowUnbalanced is true
	    }
	
	    function getUnbalancedChildTags(node) {
	        // e.g., from <div>OK</div><!-- ko blah --><span>Another</span>, returns: <!-- ko blah --><span>Another</span>
	        //       from <div>OK</div><!-- /ko --><!-- /ko -->,             returns: <!-- /ko --><!-- /ko -->
	        var childNode = node.firstChild, captureRemaining = null;
	        if (childNode) {
	            do {
	                if (captureRemaining)                   // We already hit an unbalanced node and are now just scooping up all subsequent nodes
	                    captureRemaining.push(childNode);
	                else if (isStartComment(childNode)) {
	                    var matchingEndComment = getMatchingEndComment(childNode, /* allowUnbalanced: */ true);
	                    if (matchingEndComment)             // It's a balanced tag, so skip immediately to the end of this virtual set
	                        childNode = matchingEndComment;
	                    else
	                        captureRemaining = [childNode]; // It's unbalanced, so start capturing from this point
	                } else if (isEndComment(childNode)) {
	                    captureRemaining = [childNode];     // It's unbalanced (if it wasn't, we'd have skipped over it already), so start capturing
	                }
	            } while (childNode = childNode.nextSibling);
	        }
	        return captureRemaining;
	    }
	
	    ko.virtualElements = {
	        allowedBindings: {},
	
	        childNodes: function(node) {
	            return isStartComment(node) ? getVirtualChildren(node) : node.childNodes;
	        },
	
	        emptyNode: function(node) {
	            if (!isStartComment(node))
	                ko.utils.emptyDomNode(node);
	            else {
	                var virtualChildren = ko.virtualElements.childNodes(node);
	                for (var i = 0, j = virtualChildren.length; i < j; i++)
	                    ko.removeNode(virtualChildren[i]);
	            }
	        },
	
	        setDomNodeChildren: function(node, childNodes) {
	            if (!isStartComment(node))
	                ko.utils.setDomNodeChildren(node, childNodes);
	            else {
	                ko.virtualElements.emptyNode(node);
	                var endCommentNode = node.nextSibling; // Must be the next sibling, as we just emptied the children
	                for (var i = 0, j = childNodes.length; i < j; i++)
	                    endCommentNode.parentNode.insertBefore(childNodes[i], endCommentNode);
	            }
	        },
	
	        prepend: function(containerNode, nodeToPrepend) {
	            if (!isStartComment(containerNode)) {
	                if (containerNode.firstChild)
	                    containerNode.insertBefore(nodeToPrepend, containerNode.firstChild);
	                else
	                    containerNode.appendChild(nodeToPrepend);
	            } else {
	                // Start comments must always have a parent and at least one following sibling (the end comment)
	                containerNode.parentNode.insertBefore(nodeToPrepend, containerNode.nextSibling);
	            }
	        },
	
	        insertAfter: function(containerNode, nodeToInsert, insertAfterNode) {
	            if (!insertAfterNode) {
	                ko.virtualElements.prepend(containerNode, nodeToInsert);
	            } else if (!isStartComment(containerNode)) {
	                // Insert after insertion point
	                if (insertAfterNode.nextSibling)
	                    containerNode.insertBefore(nodeToInsert, insertAfterNode.nextSibling);
	                else
	                    containerNode.appendChild(nodeToInsert);
	            } else {
	                // Children of start comments must always have a parent and at least one following sibling (the end comment)
	                containerNode.parentNode.insertBefore(nodeToInsert, insertAfterNode.nextSibling);
	            }
	        },
	
	        firstChild: function(node) {
	            if (!isStartComment(node))
	                return node.firstChild;
	            if (!node.nextSibling || isEndComment(node.nextSibling))
	                return null;
	            return node.nextSibling;
	        },
	
	        nextSibling: function(node) {
	            if (isStartComment(node))
	                node = getMatchingEndComment(node);
	            if (node.nextSibling && isEndComment(node.nextSibling))
	                return null;
	            return node.nextSibling;
	        },
	
	        hasBindingValue: isStartComment,
	
	        virtualNodeBindingValue: function(node) {
	            var regexMatch = (commentNodesHaveTextProperty ? node.text : node.nodeValue).match(startCommentRegex);
	            return regexMatch ? regexMatch[1] : null;
	        },
	
	        normaliseVirtualElementDomStructure: function(elementVerified) {
	            // Workaround for https://github.com/SteveSanderson/knockout/issues/155
	            // (IE <= 8 or IE 9 quirks mode parses your HTML weirdly, treating closing </li> tags as if they don't exist, thereby moving comment nodes
	            // that are direct descendants of <ul> into the preceding <li>)
	            if (!htmlTagsWithOptionallyClosingChildren[ko.utils.tagNameLower(elementVerified)])
	                return;
	
	            // Scan immediate children to see if they contain unbalanced comment tags. If they do, those comment tags
	            // must be intended to appear *after* that child, so move them there.
	            var childNode = elementVerified.firstChild;
	            if (childNode) {
	                do {
	                    if (childNode.nodeType === 1) {
	                        var unbalancedTags = getUnbalancedChildTags(childNode);
	                        if (unbalancedTags) {
	                            // Fix up the DOM by moving the unbalanced tags to where they most likely were intended to be placed - *after* the child
	                            var nodeToInsertBefore = childNode.nextSibling;
	                            for (var i = 0; i < unbalancedTags.length; i++) {
	                                if (nodeToInsertBefore)
	                                    elementVerified.insertBefore(unbalancedTags[i], nodeToInsertBefore);
	                                else
	                                    elementVerified.appendChild(unbalancedTags[i]);
	                            }
	                        }
	                    }
	                } while (childNode = childNode.nextSibling);
	            }
	        }
	    };
	})();
	ko.exportSymbol('virtualElements', ko.virtualElements);
	ko.exportSymbol('virtualElements.allowedBindings', ko.virtualElements.allowedBindings);
	ko.exportSymbol('virtualElements.emptyNode', ko.virtualElements.emptyNode);
	//ko.exportSymbol('virtualElements.firstChild', ko.virtualElements.firstChild);     // firstChild is not minified
	ko.exportSymbol('virtualElements.insertAfter', ko.virtualElements.insertAfter);
	//ko.exportSymbol('virtualElements.nextSibling', ko.virtualElements.nextSibling);   // nextSibling is not minified
	ko.exportSymbol('virtualElements.prepend', ko.virtualElements.prepend);
	ko.exportSymbol('virtualElements.setDomNodeChildren', ko.virtualElements.setDomNodeChildren);
	(function() {
	    var defaultBindingAttributeName = "data-bind";
	
	    ko.bindingProvider = function() {
	        this.bindingCache = {};
	    };
	
	    ko.utils.extend(ko.bindingProvider.prototype, {
	        'nodeHasBindings': function(node) {
	            switch (node.nodeType) {
	                case 1: // Element
	                    return node.getAttribute(defaultBindingAttributeName) != null
	                        || ko.components['getComponentNameForNode'](node);
	                case 8: // Comment node
	                    return ko.virtualElements.hasBindingValue(node);
	                default: return false;
	            }
	        },
	
	        'getBindings': function(node, bindingContext) {
	            var bindingsString = this['getBindingsString'](node, bindingContext),
	                parsedBindings = bindingsString ? this['parseBindingsString'](bindingsString, bindingContext, node) : null;
	            return ko.components.addBindingsForCustomElement(parsedBindings, node, bindingContext, /* valueAccessors */ false);
	        },
	
	        'getBindingAccessors': function(node, bindingContext) {
	            var bindingsString = this['getBindingsString'](node, bindingContext),
	                parsedBindings = bindingsString ? this['parseBindingsString'](bindingsString, bindingContext, node, { 'valueAccessors': true }) : null;
	            return ko.components.addBindingsForCustomElement(parsedBindings, node, bindingContext, /* valueAccessors */ true);
	        },
	
	        // The following function is only used internally by this default provider.
	        // It's not part of the interface definition for a general binding provider.
	        'getBindingsString': function(node, bindingContext) {
	            switch (node.nodeType) {
	                case 1: return node.getAttribute(defaultBindingAttributeName);   // Element
	                case 8: return ko.virtualElements.virtualNodeBindingValue(node); // Comment node
	                default: return null;
	            }
	        },
	
	        // The following function is only used internally by this default provider.
	        // It's not part of the interface definition for a general binding provider.
	        'parseBindingsString': function(bindingsString, bindingContext, node, options) {
	            try {
	                var bindingFunction = createBindingsStringEvaluatorViaCache(bindingsString, this.bindingCache, options);
	                return bindingFunction(bindingContext, node);
	            } catch (ex) {
	                ex.message = "Unable to parse bindings.\nBindings value: " + bindingsString + "\nMessage: " + ex.message;
	                throw ex;
	            }
	        }
	    });
	
	    ko.bindingProvider['instance'] = new ko.bindingProvider();
	
	    function createBindingsStringEvaluatorViaCache(bindingsString, cache, options) {
	        var cacheKey = bindingsString + (options && options['valueAccessors'] || '');
	        return cache[cacheKey]
	            || (cache[cacheKey] = createBindingsStringEvaluator(bindingsString, options));
	    }
	
	    function createBindingsStringEvaluator(bindingsString, options) {
	        // Build the source for a function that evaluates "expression"
	        // For each scope variable, add an extra level of "with" nesting
	        // Example result: with(sc1) { with(sc0) { return (expression) } }
	        var rewrittenBindings = ko.expressionRewriting.preProcessBindings(bindingsString, options),
	            functionBody = "with($context){with($data||{}){return{" + rewrittenBindings + "}}}";
	        return new Function("$context", "$element", functionBody);
	    }
	})();
	
	ko.exportSymbol('bindingProvider', ko.bindingProvider);
	(function () {
	    ko.bindingHandlers = {};
	
	    // The following element types will not be recursed into during binding.
	    var bindingDoesNotRecurseIntoElementTypes = {
	        // Don't want bindings that operate on text nodes to mutate <script> and <textarea> contents,
	        // because it's unexpected and a potential XSS issue.
	        // Also bindings should not operate on <template> elements since this breaks in Internet Explorer
	        // and because such elements' contents are always intended to be bound in a different context
	        // from where they appear in the document.
	        'script': true,
	        'textarea': true,
	        'template': true
	    };
	
	    // Use an overridable method for retrieving binding handlers so that a plugins may support dynamically created handlers
	    ko['getBindingHandler'] = function(bindingKey) {
	        return ko.bindingHandlers[bindingKey];
	    };
	
	    // The ko.bindingContext constructor is only called directly to create the root context. For child
	    // contexts, use bindingContext.createChildContext or bindingContext.extend.
	    ko.bindingContext = function(dataItemOrAccessor, parentContext, dataItemAlias, extendCallback, options) {
	
	        // The binding context object includes static properties for the current, parent, and root view models.
	        // If a view model is actually stored in an observable, the corresponding binding context object, and
	        // any child contexts, must be updated when the view model is changed.
	        function updateContext() {
	            // Most of the time, the context will directly get a view model object, but if a function is given,
	            // we call the function to retrieve the view model. If the function accesses any observables or returns
	            // an observable, the dependency is tracked, and those observables can later cause the binding
	            // context to be updated.
	            var dataItemOrObservable = isFunc ? dataItemOrAccessor() : dataItemOrAccessor,
	                dataItem = ko.utils.unwrapObservable(dataItemOrObservable);
	
	            if (parentContext) {
	                // When a "parent" context is given, register a dependency on the parent context. Thus whenever the
	                // parent context is updated, this context will also be updated.
	                if (parentContext._subscribable)
	                    parentContext._subscribable();
	
	                // Copy $root and any custom properties from the parent context
	                ko.utils.extend(self, parentContext);
	
	                // Because the above copy overwrites our own properties, we need to reset them.
	                self._subscribable = subscribable;
	            } else {
	                self['$parents'] = [];
	                self['$root'] = dataItem;
	
	                // Export 'ko' in the binding context so it will be available in bindings and templates
	                // even if 'ko' isn't exported as a global, such as when using an AMD loader.
	                // See https://github.com/SteveSanderson/knockout/issues/490
	                self['ko'] = ko;
	            }
	            self['$rawData'] = dataItemOrObservable;
	            self['$data'] = dataItem;
	            if (dataItemAlias)
	                self[dataItemAlias] = dataItem;
	
	            // The extendCallback function is provided when creating a child context or extending a context.
	            // It handles the specific actions needed to finish setting up the binding context. Actions in this
	            // function could also add dependencies to this binding context.
	            if (extendCallback)
	                extendCallback(self, parentContext, dataItem);
	
	            return self['$data'];
	        }
	        function disposeWhen() {
	            return nodes && !ko.utils.anyDomNodeIsAttachedToDocument(nodes);
	        }
	
	        var self = this,
	            isFunc = typeof(dataItemOrAccessor) == "function" && !ko.isObservable(dataItemOrAccessor),
	            nodes,
	            subscribable;
	
	        if (options && options['exportDependencies']) {
	            // The "exportDependencies" option means that the calling code will track any dependencies and re-create
	            // the binding context when they change.
	            updateContext();
	        } else {
	            subscribable = ko.dependentObservable(updateContext, null, { disposeWhen: disposeWhen, disposeWhenNodeIsRemoved: true });
	
	            // At this point, the binding context has been initialized, and the "subscribable" computed observable is
	            // subscribed to any observables that were accessed in the process. If there is nothing to track, the
	            // computed will be inactive, and we can safely throw it away. If it's active, the computed is stored in
	            // the context object.
	            if (subscribable.isActive()) {
	                self._subscribable = subscribable;
	
	                // Always notify because even if the model ($data) hasn't changed, other context properties might have changed
	                subscribable['equalityComparer'] = null;
	
	                // We need to be able to dispose of this computed observable when it's no longer needed. This would be
	                // easy if we had a single node to watch, but binding contexts can be used by many different nodes, and
	                // we cannot assume that those nodes have any relation to each other. So instead we track any node that
	                // the context is attached to, and dispose the computed when all of those nodes have been cleaned.
	
	                // Add properties to *subscribable* instead of *self* because any properties added to *self* may be overwritten on updates
	                nodes = [];
	                subscribable._addNode = function(node) {
	                    nodes.push(node);
	                    ko.utils.domNodeDisposal.addDisposeCallback(node, function(node) {
	                        ko.utils.arrayRemoveItem(nodes, node);
	                        if (!nodes.length) {
	                            subscribable.dispose();
	                            self._subscribable = subscribable = undefined;
	                        }
	                    });
	                };
	            }
	        }
	    }
	
	    // Extend the binding context hierarchy with a new view model object. If the parent context is watching
	    // any observables, the new child context will automatically get a dependency on the parent context.
	    // But this does not mean that the $data value of the child context will also get updated. If the child
	    // view model also depends on the parent view model, you must provide a function that returns the correct
	    // view model on each update.
	    ko.bindingContext.prototype['createChildContext'] = function (dataItemOrAccessor, dataItemAlias, extendCallback, options) {
	        return new ko.bindingContext(dataItemOrAccessor, this, dataItemAlias, function(self, parentContext) {
	            // Extend the context hierarchy by setting the appropriate pointers
	            self['$parentContext'] = parentContext;
	            self['$parent'] = parentContext['$data'];
	            self['$parents'] = (parentContext['$parents'] || []).slice(0);
	            self['$parents'].unshift(self['$parent']);
	            if (extendCallback)
	                extendCallback(self);
	        }, options);
	    };
	
	    // Extend the binding context with new custom properties. This doesn't change the context hierarchy.
	    // Similarly to "child" contexts, provide a function here to make sure that the correct values are set
	    // when an observable view model is updated.
	    ko.bindingContext.prototype['extend'] = function(properties) {
	        // If the parent context references an observable view model, "_subscribable" will always be the
	        // latest view model object. If not, "_subscribable" isn't set, and we can use the static "$data" value.
	        return new ko.bindingContext(this._subscribable || this['$data'], this, null, function(self, parentContext) {
	            // This "child" context doesn't directly track a parent observable view model,
	            // so we need to manually set the $rawData value to match the parent.
	            self['$rawData'] = parentContext['$rawData'];
	            ko.utils.extend(self, typeof(properties) == "function" ? properties() : properties);
	        });
	    };
	
	    ko.bindingContext.prototype.createStaticChildContext = function (dataItemOrAccessor, dataItemAlias) {
	        return this['createChildContext'](dataItemOrAccessor, dataItemAlias, null, { "exportDependencies": true });
	    };
	
	    // Returns the valueAccesor function for a binding value
	    function makeValueAccessor(value) {
	        return function() {
	            return value;
	        };
	    }
	
	    // Returns the value of a valueAccessor function
	    function evaluateValueAccessor(valueAccessor) {
	        return valueAccessor();
	    }
	
	    // Given a function that returns bindings, create and return a new object that contains
	    // binding value-accessors functions. Each accessor function calls the original function
	    // so that it always gets the latest value and all dependencies are captured. This is used
	    // by ko.applyBindingsToNode and getBindingsAndMakeAccessors.
	    function makeAccessorsFromFunction(callback) {
	        return ko.utils.objectMap(ko.dependencyDetection.ignore(callback), function(value, key) {
	            return function() {
	                return callback()[key];
	            };
	        });
	    }
	
	    // Given a bindings function or object, create and return a new object that contains
	    // binding value-accessors functions. This is used by ko.applyBindingsToNode.
	    function makeBindingAccessors(bindings, context, node) {
	        if (typeof bindings === 'function') {
	            return makeAccessorsFromFunction(bindings.bind(null, context, node));
	        } else {
	            return ko.utils.objectMap(bindings, makeValueAccessor);
	        }
	    }
	
	    // This function is used if the binding provider doesn't include a getBindingAccessors function.
	    // It must be called with 'this' set to the provider instance.
	    function getBindingsAndMakeAccessors(node, context) {
	        return makeAccessorsFromFunction(this['getBindings'].bind(this, node, context));
	    }
	
	    function validateThatBindingIsAllowedForVirtualElements(bindingName) {
	        var validator = ko.virtualElements.allowedBindings[bindingName];
	        if (!validator)
	            throw new Error("The binding '" + bindingName + "' cannot be used with virtual elements")
	    }
	
	    function applyBindingsToDescendantsInternal (bindingContext, elementOrVirtualElement, bindingContextsMayDifferFromDomParentElement) {
	        var currentChild,
	            nextInQueue = ko.virtualElements.firstChild(elementOrVirtualElement),
	            provider = ko.bindingProvider['instance'],
	            preprocessNode = provider['preprocessNode'];
	
	        // Preprocessing allows a binding provider to mutate a node before bindings are applied to it. For example it's
	        // possible to insert new siblings after it, and/or replace the node with a different one. This can be used to
	        // implement custom binding syntaxes, such as {{ value }} for string interpolation, or custom element types that
	        // trigger insertion of <template> contents at that point in the document.
	        if (preprocessNode) {
	            while (currentChild = nextInQueue) {
	                nextInQueue = ko.virtualElements.nextSibling(currentChild);
	                preprocessNode.call(provider, currentChild);
	            }
	            // Reset nextInQueue for the next loop
	            nextInQueue = ko.virtualElements.firstChild(elementOrVirtualElement);
	        }
	
	        while (currentChild = nextInQueue) {
	            // Keep a record of the next child *before* applying bindings, in case the binding removes the current child from its position
	            nextInQueue = ko.virtualElements.nextSibling(currentChild);
	            applyBindingsToNodeAndDescendantsInternal(bindingContext, currentChild, bindingContextsMayDifferFromDomParentElement);
	        }
	    }
	
	    function applyBindingsToNodeAndDescendantsInternal (bindingContext, nodeVerified, bindingContextMayDifferFromDomParentElement) {
	        var shouldBindDescendants = true;
	
	        // Perf optimisation: Apply bindings only if...
	        // (1) We need to store the binding context on this node (because it may differ from the DOM parent node's binding context)
	        //     Note that we can't store binding contexts on non-elements (e.g., text nodes), as IE doesn't allow expando properties for those
	        // (2) It might have bindings (e.g., it has a data-bind attribute, or it's a marker for a containerless template)
	        var isElement = (nodeVerified.nodeType === 1);
	        if (isElement) // Workaround IE <= 8 HTML parsing weirdness
	            ko.virtualElements.normaliseVirtualElementDomStructure(nodeVerified);
	
	        var shouldApplyBindings = (isElement && bindingContextMayDifferFromDomParentElement)             // Case (1)
	                               || ko.bindingProvider['instance']['nodeHasBindings'](nodeVerified);       // Case (2)
	        if (shouldApplyBindings)
	            shouldBindDescendants = applyBindingsToNodeInternal(nodeVerified, null, bindingContext, bindingContextMayDifferFromDomParentElement)['shouldBindDescendants'];
	
	        if (shouldBindDescendants && !bindingDoesNotRecurseIntoElementTypes[ko.utils.tagNameLower(nodeVerified)]) {
	            // We're recursing automatically into (real or virtual) child nodes without changing binding contexts. So,
	            //  * For children of a *real* element, the binding context is certainly the same as on their DOM .parentNode,
	            //    hence bindingContextsMayDifferFromDomParentElement is false
	            //  * For children of a *virtual* element, we can't be sure. Evaluating .parentNode on those children may
	            //    skip over any number of intermediate virtual elements, any of which might define a custom binding context,
	            //    hence bindingContextsMayDifferFromDomParentElement is true
	            applyBindingsToDescendantsInternal(bindingContext, nodeVerified, /* bindingContextsMayDifferFromDomParentElement: */ !isElement);
	        }
	    }
	
	    var boundElementDomDataKey = ko.utils.domData.nextKey();
	
	
	    function topologicalSortBindings(bindings) {
	        // Depth-first sort
	        var result = [],                // The list of key/handler pairs that we will return
	            bindingsConsidered = {},    // A temporary record of which bindings are already in 'result'
	            cyclicDependencyStack = []; // Keeps track of a depth-search so that, if there's a cycle, we know which bindings caused it
	        ko.utils.objectForEach(bindings, function pushBinding(bindingKey) {
	            if (!bindingsConsidered[bindingKey]) {
	                var binding = ko['getBindingHandler'](bindingKey);
	                if (binding) {
	                    // First add dependencies (if any) of the current binding
	                    if (binding['after']) {
	                        cyclicDependencyStack.push(bindingKey);
	                        ko.utils.arrayForEach(binding['after'], function(bindingDependencyKey) {
	                            if (bindings[bindingDependencyKey]) {
	                                if (ko.utils.arrayIndexOf(cyclicDependencyStack, bindingDependencyKey) !== -1) {
	                                    throw Error("Cannot combine the following bindings, because they have a cyclic dependency: " + cyclicDependencyStack.join(", "));
	                                } else {
	                                    pushBinding(bindingDependencyKey);
	                                }
	                            }
	                        });
	                        cyclicDependencyStack.length--;
	                    }
	                    // Next add the current binding
	                    result.push({ key: bindingKey, handler: binding });
	                }
	                bindingsConsidered[bindingKey] = true;
	            }
	        });
	
	        return result;
	    }
	
	    function applyBindingsToNodeInternal(node, sourceBindings, bindingContext, bindingContextMayDifferFromDomParentElement) {
	        // Prevent multiple applyBindings calls for the same node, except when a binding value is specified
	        var alreadyBound = ko.utils.domData.get(node, boundElementDomDataKey);
	        if (!sourceBindings) {
	            if (alreadyBound) {
	                throw Error("You cannot apply bindings multiple times to the same element.");
	            }
	            ko.utils.domData.set(node, boundElementDomDataKey, true);
	        }
	
	        // Optimization: Don't store the binding context on this node if it's definitely the same as on node.parentNode, because
	        // we can easily recover it just by scanning up the node's ancestors in the DOM
	        // (note: here, parent node means "real DOM parent" not "virtual parent", as there's no O(1) way to find the virtual parent)
	        if (!alreadyBound && bindingContextMayDifferFromDomParentElement)
	            ko.storedBindingContextForNode(node, bindingContext);
	
	        // Use bindings if given, otherwise fall back on asking the bindings provider to give us some bindings
	        var bindings;
	        if (sourceBindings && typeof sourceBindings !== 'function') {
	            bindings = sourceBindings;
	        } else {
	            var provider = ko.bindingProvider['instance'],
	                getBindings = provider['getBindingAccessors'] || getBindingsAndMakeAccessors;
	
	            // Get the binding from the provider within a computed observable so that we can update the bindings whenever
	            // the binding context is updated or if the binding provider accesses observables.
	            var bindingsUpdater = ko.dependentObservable(
	                function() {
	                    bindings = sourceBindings ? sourceBindings(bindingContext, node) : getBindings.call(provider, node, bindingContext);
	                    // Register a dependency on the binding context to support observable view models.
	                    if (bindings && bindingContext._subscribable)
	                        bindingContext._subscribable();
	                    return bindings;
	                },
	                null, { disposeWhenNodeIsRemoved: node }
	            );
	
	            if (!bindings || !bindingsUpdater.isActive())
	                bindingsUpdater = null;
	        }
	
	        var bindingHandlerThatControlsDescendantBindings;
	        if (bindings) {
	            // Return the value accessor for a given binding. When bindings are static (won't be updated because of a binding
	            // context update), just return the value accessor from the binding. Otherwise, return a function that always gets
	            // the latest binding value and registers a dependency on the binding updater.
	            var getValueAccessor = bindingsUpdater
	                ? function(bindingKey) {
	                    return function() {
	                        return evaluateValueAccessor(bindingsUpdater()[bindingKey]);
	                    };
	                } : function(bindingKey) {
	                    return bindings[bindingKey];
	                };
	
	            // Use of allBindings as a function is maintained for backwards compatibility, but its use is deprecated
	            function allBindings() {
	                return ko.utils.objectMap(bindingsUpdater ? bindingsUpdater() : bindings, evaluateValueAccessor);
	            }
	            // The following is the 3.x allBindings API
	            allBindings['get'] = function(key) {
	                return bindings[key] && evaluateValueAccessor(getValueAccessor(key));
	            };
	            allBindings['has'] = function(key) {
	                return key in bindings;
	            };
	
	            // First put the bindings into the right order
	            var orderedBindings = topologicalSortBindings(bindings);
	
	            // Go through the sorted bindings, calling init and update for each
	            ko.utils.arrayForEach(orderedBindings, function(bindingKeyAndHandler) {
	                // Note that topologicalSortBindings has already filtered out any nonexistent binding handlers,
	                // so bindingKeyAndHandler.handler will always be nonnull.
	                var handlerInitFn = bindingKeyAndHandler.handler["init"],
	                    handlerUpdateFn = bindingKeyAndHandler.handler["update"],
	                    bindingKey = bindingKeyAndHandler.key;
	
	                if (node.nodeType === 8) {
	                    validateThatBindingIsAllowedForVirtualElements(bindingKey);
	                }
	
	                try {
	                    // Run init, ignoring any dependencies
	                    if (typeof handlerInitFn == "function") {
	                        ko.dependencyDetection.ignore(function() {
	                            var initResult = handlerInitFn(node, getValueAccessor(bindingKey), allBindings, bindingContext['$data'], bindingContext);
	
	                            // If this binding handler claims to control descendant bindings, make a note of this
	                            if (initResult && initResult['controlsDescendantBindings']) {
	                                if (bindingHandlerThatControlsDescendantBindings !== undefined)
	                                    throw new Error("Multiple bindings (" + bindingHandlerThatControlsDescendantBindings + " and " + bindingKey + ") are trying to control descendant bindings of the same element. You cannot use these bindings together on the same element.");
	                                bindingHandlerThatControlsDescendantBindings = bindingKey;
	                            }
	                        });
	                    }
	
	                    // Run update in its own computed wrapper
	                    if (typeof handlerUpdateFn == "function") {
	                        ko.dependentObservable(
	                            function() {
	                                handlerUpdateFn(node, getValueAccessor(bindingKey), allBindings, bindingContext['$data'], bindingContext);
	                            },
	                            null,
	                            { disposeWhenNodeIsRemoved: node }
	                        );
	                    }
	                } catch (ex) {
	                    ex.message = "Unable to process binding \"" + bindingKey + ": " + bindings[bindingKey] + "\"\nMessage: " + ex.message;
	                    throw ex;
	                }
	            });
	        }
	
	        return {
	            'shouldBindDescendants': bindingHandlerThatControlsDescendantBindings === undefined
	        };
	    };
	
	    var storedBindingContextDomDataKey = ko.utils.domData.nextKey();
	    ko.storedBindingContextForNode = function (node, bindingContext) {
	        if (arguments.length == 2) {
	            ko.utils.domData.set(node, storedBindingContextDomDataKey, bindingContext);
	            if (bindingContext._subscribable)
	                bindingContext._subscribable._addNode(node);
	        } else {
	            return ko.utils.domData.get(node, storedBindingContextDomDataKey);
	        }
	    }
	
	    function getBindingContext(viewModelOrBindingContext) {
	        return viewModelOrBindingContext && (viewModelOrBindingContext instanceof ko.bindingContext)
	            ? viewModelOrBindingContext
	            : new ko.bindingContext(viewModelOrBindingContext);
	    }
	
	    ko.applyBindingAccessorsToNode = function (node, bindings, viewModelOrBindingContext) {
	        if (node.nodeType === 1) // If it's an element, workaround IE <= 8 HTML parsing weirdness
	            ko.virtualElements.normaliseVirtualElementDomStructure(node);
	        return applyBindingsToNodeInternal(node, bindings, getBindingContext(viewModelOrBindingContext), true);
	    };
	
	    ko.applyBindingsToNode = function (node, bindings, viewModelOrBindingContext) {
	        var context = getBindingContext(viewModelOrBindingContext);
	        return ko.applyBindingAccessorsToNode(node, makeBindingAccessors(bindings, context, node), context);
	    };
	
	    ko.applyBindingsToDescendants = function(viewModelOrBindingContext, rootNode) {
	        if (rootNode.nodeType === 1 || rootNode.nodeType === 8)
	            applyBindingsToDescendantsInternal(getBindingContext(viewModelOrBindingContext), rootNode, true);
	    };
	
	    ko.applyBindings = function (viewModelOrBindingContext, rootNode) {
	        // If jQuery is loaded after Knockout, we won't initially have access to it. So save it here.
	        if (!jQueryInstance && window['jQuery']) {
	            jQueryInstance = window['jQuery'];
	        }
	
	        if (rootNode && (rootNode.nodeType !== 1) && (rootNode.nodeType !== 8))
	            throw new Error("ko.applyBindings: first parameter should be your view model; second parameter should be a DOM node");
	        rootNode = rootNode || window.document.body; // Make "rootNode" parameter optional
	
	        applyBindingsToNodeAndDescendantsInternal(getBindingContext(viewModelOrBindingContext), rootNode, true);
	    };
	
	    // Retrieving binding context from arbitrary nodes
	    ko.contextFor = function(node) {
	        // We can only do something meaningful for elements and comment nodes (in particular, not text nodes, as IE can't store domdata for them)
	        switch (node.nodeType) {
	            case 1:
	            case 8:
	                var context = ko.storedBindingContextForNode(node);
	                if (context) return context;
	                if (node.parentNode) return ko.contextFor(node.parentNode);
	                break;
	        }
	        return undefined;
	    };
	    ko.dataFor = function(node) {
	        var context = ko.contextFor(node);
	        return context ? context['$data'] : undefined;
	    };
	
	    ko.exportSymbol('bindingHandlers', ko.bindingHandlers);
	    ko.exportSymbol('applyBindings', ko.applyBindings);
	    ko.exportSymbol('applyBindingsToDescendants', ko.applyBindingsToDescendants);
	    ko.exportSymbol('applyBindingAccessorsToNode', ko.applyBindingAccessorsToNode);
	    ko.exportSymbol('applyBindingsToNode', ko.applyBindingsToNode);
	    ko.exportSymbol('contextFor', ko.contextFor);
	    ko.exportSymbol('dataFor', ko.dataFor);
	})();
	(function(undefined) {
	    var loadingSubscribablesCache = {}, // Tracks component loads that are currently in flight
	        loadedDefinitionsCache = {};    // Tracks component loads that have already completed
	
	    ko.components = {
	        get: function(componentName, callback) {
	            var cachedDefinition = getObjectOwnProperty(loadedDefinitionsCache, componentName);
	            if (cachedDefinition) {
	                // It's already loaded and cached. Reuse the same definition object.
	                // Note that for API consistency, even cache hits complete asynchronously by default.
	                // You can bypass this by putting synchronous:true on your component config.
	                if (cachedDefinition.isSynchronousComponent) {
	                    ko.dependencyDetection.ignore(function() { // See comment in loaderRegistryBehaviors.js for reasoning
	                        callback(cachedDefinition.definition);
	                    });
	                } else {
	                    ko.tasks.schedule(function() { callback(cachedDefinition.definition); });
	                }
	            } else {
	                // Join the loading process that is already underway, or start a new one.
	                loadComponentAndNotify(componentName, callback);
	            }
	        },
	
	        clearCachedDefinition: function(componentName) {
	            delete loadedDefinitionsCache[componentName];
	        },
	
	        _getFirstResultFromLoaders: getFirstResultFromLoaders
	    };
	
	    function getObjectOwnProperty(obj, propName) {
	        return obj.hasOwnProperty(propName) ? obj[propName] : undefined;
	    }
	
	    function loadComponentAndNotify(componentName, callback) {
	        var subscribable = getObjectOwnProperty(loadingSubscribablesCache, componentName),
	            completedAsync;
	        if (!subscribable) {
	            // It's not started loading yet. Start loading, and when it's done, move it to loadedDefinitionsCache.
	            subscribable = loadingSubscribablesCache[componentName] = new ko.subscribable();
	            subscribable.subscribe(callback);
	
	            beginLoadingComponent(componentName, function(definition, config) {
	                var isSynchronousComponent = !!(config && config['synchronous']);
	                loadedDefinitionsCache[componentName] = { definition: definition, isSynchronousComponent: isSynchronousComponent };
	                delete loadingSubscribablesCache[componentName];
	
	                // For API consistency, all loads complete asynchronously. However we want to avoid
	                // adding an extra task schedule if it's unnecessary (i.e., the completion is already
	                // async).
	                //
	                // You can bypass the 'always asynchronous' feature by putting the synchronous:true
	                // flag on your component configuration when you register it.
	                if (completedAsync || isSynchronousComponent) {
	                    // Note that notifySubscribers ignores any dependencies read within the callback.
	                    // See comment in loaderRegistryBehaviors.js for reasoning
	                    subscribable['notifySubscribers'](definition);
	                } else {
	                    ko.tasks.schedule(function() {
	                        subscribable['notifySubscribers'](definition);
	                    });
	                }
	            });
	            completedAsync = true;
	        } else {
	            subscribable.subscribe(callback);
	        }
	    }
	
	    function beginLoadingComponent(componentName, callback) {
	        getFirstResultFromLoaders('getConfig', [componentName], function(config) {
	            if (config) {
	                // We have a config, so now load its definition
	                getFirstResultFromLoaders('loadComponent', [componentName, config], function(definition) {
	                    callback(definition, config);
	                });
	            } else {
	                // The component has no config - it's unknown to all the loaders.
	                // Note that this is not an error (e.g., a module loading error) - that would abort the
	                // process and this callback would not run. For this callback to run, all loaders must
	                // have confirmed they don't know about this component.
	                callback(null, null);
	            }
	        });
	    }
	
	    function getFirstResultFromLoaders(methodName, argsExceptCallback, callback, candidateLoaders) {
	        // On the first call in the stack, start with the full set of loaders
	        if (!candidateLoaders) {
	            candidateLoaders = ko.components['loaders'].slice(0); // Use a copy, because we'll be mutating this array
	        }
	
	        // Try the next candidate
	        var currentCandidateLoader = candidateLoaders.shift();
	        if (currentCandidateLoader) {
	            var methodInstance = currentCandidateLoader[methodName];
	            if (methodInstance) {
	                var wasAborted = false,
	                    synchronousReturnValue = methodInstance.apply(currentCandidateLoader, argsExceptCallback.concat(function(result) {
	                        if (wasAborted) {
	                            callback(null);
	                        } else if (result !== null) {
	                            // This candidate returned a value. Use it.
	                            callback(result);
	                        } else {
	                            // Try the next candidate
	                            getFirstResultFromLoaders(methodName, argsExceptCallback, callback, candidateLoaders);
	                        }
	                    }));
	
	                // Currently, loaders may not return anything synchronously. This leaves open the possibility
	                // that we'll extend the API to support synchronous return values in the future. It won't be
	                // a breaking change, because currently no loader is allowed to return anything except undefined.
	                if (synchronousReturnValue !== undefined) {
	                    wasAborted = true;
	
	                    // Method to suppress exceptions will remain undocumented. This is only to keep
	                    // KO's specs running tidily, since we can observe the loading got aborted without
	                    // having exceptions cluttering up the console too.
	                    if (!currentCandidateLoader['suppressLoaderExceptions']) {
	                        throw new Error('Component loaders must supply values by invoking the callback, not by returning values synchronously.');
	                    }
	                }
	            } else {
	                // This candidate doesn't have the relevant handler. Synchronously move on to the next one.
	                getFirstResultFromLoaders(methodName, argsExceptCallback, callback, candidateLoaders);
	            }
	        } else {
	            // No candidates returned a value
	            callback(null);
	        }
	    }
	
	    // Reference the loaders via string name so it's possible for developers
	    // to replace the whole array by assigning to ko.components.loaders
	    ko.components['loaders'] = [];
	
	    ko.exportSymbol('components', ko.components);
	    ko.exportSymbol('components.get', ko.components.get);
	    ko.exportSymbol('components.clearCachedDefinition', ko.components.clearCachedDefinition);
	})();
	(function(undefined) {
	
	    // The default loader is responsible for two things:
	    // 1. Maintaining the default in-memory registry of component configuration objects
	    //    (i.e., the thing you're writing to when you call ko.components.register(someName, ...))
	    // 2. Answering requests for components by fetching configuration objects
	    //    from that default in-memory registry and resolving them into standard
	    //    component definition objects (of the form { createViewModel: ..., template: ... })
	    // Custom loaders may override either of these facilities, i.e.,
	    // 1. To supply configuration objects from some other source (e.g., conventions)
	    // 2. Or, to resolve configuration objects by loading viewmodels/templates via arbitrary logic.
	
	    var defaultConfigRegistry = {};
	
	    ko.components.register = function(componentName, config) {
	        if (!config) {
	            throw new Error('Invalid configuration for ' + componentName);
	        }
	
	        if (ko.components.isRegistered(componentName)) {
	            throw new Error('Component ' + componentName + ' is already registered');
	        }
	
	        defaultConfigRegistry[componentName] = config;
	    };
	
	    ko.components.isRegistered = function(componentName) {
	        return defaultConfigRegistry.hasOwnProperty(componentName);
	    };
	
	    ko.components.unregister = function(componentName) {
	        delete defaultConfigRegistry[componentName];
	        ko.components.clearCachedDefinition(componentName);
	    };
	
	    ko.components.defaultLoader = {
	        'getConfig': function(componentName, callback) {
	            var result = defaultConfigRegistry.hasOwnProperty(componentName)
	                ? defaultConfigRegistry[componentName]
	                : null;
	            callback(result);
	        },
	
	        'loadComponent': function(componentName, config, callback) {
	            var errorCallback = makeErrorCallback(componentName);
	            possiblyGetConfigFromAmd(errorCallback, config, function(loadedConfig) {
	                resolveConfig(componentName, errorCallback, loadedConfig, callback);
	            });
	        },
	
	        'loadTemplate': function(componentName, templateConfig, callback) {
	            resolveTemplate(makeErrorCallback(componentName), templateConfig, callback);
	        },
	
	        'loadViewModel': function(componentName, viewModelConfig, callback) {
	            resolveViewModel(makeErrorCallback(componentName), viewModelConfig, callback);
	        }
	    };
	
	    var createViewModelKey = 'createViewModel';
	
	    // Takes a config object of the form { template: ..., viewModel: ... }, and asynchronously convert it
	    // into the standard component definition format:
	    //    { template: <ArrayOfDomNodes>, createViewModel: function(params, componentInfo) { ... } }.
	    // Since both template and viewModel may need to be resolved asynchronously, both tasks are performed
	    // in parallel, and the results joined when both are ready. We don't depend on any promises infrastructure,
	    // so this is implemented manually below.
	    function resolveConfig(componentName, errorCallback, config, callback) {
	        var result = {},
	            makeCallBackWhenZero = 2,
	            tryIssueCallback = function() {
	                if (--makeCallBackWhenZero === 0) {
	                    callback(result);
	                }
	            },
	            templateConfig = config['template'],
	            viewModelConfig = config['viewModel'];
	
	        if (templateConfig) {
	            possiblyGetConfigFromAmd(errorCallback, templateConfig, function(loadedConfig) {
	                ko.components._getFirstResultFromLoaders('loadTemplate', [componentName, loadedConfig], function(resolvedTemplate) {
	                    result['template'] = resolvedTemplate;
	                    tryIssueCallback();
	                });
	            });
	        } else {
	            tryIssueCallback();
	        }
	
	        if (viewModelConfig) {
	            possiblyGetConfigFromAmd(errorCallback, viewModelConfig, function(loadedConfig) {
	                ko.components._getFirstResultFromLoaders('loadViewModel', [componentName, loadedConfig], function(resolvedViewModel) {
	                    result[createViewModelKey] = resolvedViewModel;
	                    tryIssueCallback();
	                });
	            });
	        } else {
	            tryIssueCallback();
	        }
	    }
	
	    function resolveTemplate(errorCallback, templateConfig, callback) {
	        if (typeof templateConfig === 'string') {
	            // Markup - parse it
	            callback(ko.utils.parseHtmlFragment(templateConfig));
	        } else if (templateConfig instanceof Array) {
	            // Assume already an array of DOM nodes - pass through unchanged
	            callback(templateConfig);
	        } else if (isDocumentFragment(templateConfig)) {
	            // Document fragment - use its child nodes
	            callback(ko.utils.makeArray(templateConfig.childNodes));
	        } else if (templateConfig['element']) {
	            var element = templateConfig['element'];
	            if (isDomElement(element)) {
	                // Element instance - copy its child nodes
	                callback(cloneNodesFromTemplateSourceElement(element));
	            } else if (typeof element === 'string') {
	                // Element ID - find it, then copy its child nodes
	                var elemInstance = document.getElementById(element);
	                if (elemInstance) {
	                    callback(cloneNodesFromTemplateSourceElement(elemInstance));
	                } else {
	                    errorCallback('Cannot find element with ID ' + element);
	                }
	            } else {
	                errorCallback('Unknown element type: ' + element);
	            }
	        } else {
	            errorCallback('Unknown template value: ' + templateConfig);
	        }
	    }
	
	    function resolveViewModel(errorCallback, viewModelConfig, callback) {
	        if (typeof viewModelConfig === 'function') {
	            // Constructor - convert to standard factory function format
	            // By design, this does *not* supply componentInfo to the constructor, as the intent is that
	            // componentInfo contains non-viewmodel data (e.g., the component's element) that should only
	            // be used in factory functions, not viewmodel constructors.
	            callback(function (params /*, componentInfo */) {
	                return new viewModelConfig(params);
	            });
	        } else if (typeof viewModelConfig[createViewModelKey] === 'function') {
	            // Already a factory function - use it as-is
	            callback(viewModelConfig[createViewModelKey]);
	        } else if ('instance' in viewModelConfig) {
	            // Fixed object instance - promote to createViewModel format for API consistency
	            var fixedInstance = viewModelConfig['instance'];
	            callback(function (params, componentInfo) {
	                return fixedInstance;
	            });
	        } else if ('viewModel' in viewModelConfig) {
	            // Resolved AMD module whose value is of the form { viewModel: ... }
	            resolveViewModel(errorCallback, viewModelConfig['viewModel'], callback);
	        } else {
	            errorCallback('Unknown viewModel value: ' + viewModelConfig);
	        }
	    }
	
	    function cloneNodesFromTemplateSourceElement(elemInstance) {
	        switch (ko.utils.tagNameLower(elemInstance)) {
	            case 'script':
	                return ko.utils.parseHtmlFragment(elemInstance.text);
	            case 'textarea':
	                return ko.utils.parseHtmlFragment(elemInstance.value);
	            case 'template':
	                // For browsers with proper <template> element support (i.e., where the .content property
	                // gives a document fragment), use that document fragment.
	                if (isDocumentFragment(elemInstance.content)) {
	                    return ko.utils.cloneNodes(elemInstance.content.childNodes);
	                }
	        }
	
	        // Regular elements such as <div>, and <template> elements on old browsers that don't really
	        // understand <template> and just treat it as a regular container
	        return ko.utils.cloneNodes(elemInstance.childNodes);
	    }
	
	    function isDomElement(obj) {
	        if (window['HTMLElement']) {
	            return obj instanceof HTMLElement;
	        } else {
	            return obj && obj.tagName && obj.nodeType === 1;
	        }
	    }
	
	    function isDocumentFragment(obj) {
	        if (window['DocumentFragment']) {
	            return obj instanceof DocumentFragment;
	        } else {
	            return obj && obj.nodeType === 11;
	        }
	    }
	
	    function possiblyGetConfigFromAmd(errorCallback, config, callback) {
	        if (typeof config['require'] === 'string') {
	            // The config is the value of an AMD module
	            if (amdRequire || window['require']) {
	                (amdRequire || window['require'])([config['require']], callback);
	            } else {
	                errorCallback('Uses require, but no AMD loader is present');
	            }
	        } else {
	            callback(config);
	        }
	    }
	
	    function makeErrorCallback(componentName) {
	        return function (message) {
	            throw new Error('Component \'' + componentName + '\': ' + message);
	        };
	    }
	
	    ko.exportSymbol('components.register', ko.components.register);
	    ko.exportSymbol('components.isRegistered', ko.components.isRegistered);
	    ko.exportSymbol('components.unregister', ko.components.unregister);
	
	    // Expose the default loader so that developers can directly ask it for configuration
	    // or to resolve configuration
	    ko.exportSymbol('components.defaultLoader', ko.components.defaultLoader);
	
	    // By default, the default loader is the only registered component loader
	    ko.components['loaders'].push(ko.components.defaultLoader);
	
	    // Privately expose the underlying config registry for use in old-IE shim
	    ko.components._allRegisteredComponents = defaultConfigRegistry;
	})();
	(function (undefined) {
	    // Overridable API for determining which component name applies to a given node. By overriding this,
	    // you can for example map specific tagNames to components that are not preregistered.
	    ko.components['getComponentNameForNode'] = function(node) {
	        var tagNameLower = ko.utils.tagNameLower(node);
	        if (ko.components.isRegistered(tagNameLower)) {
	            // Try to determine that this node can be considered a *custom* element; see https://github.com/knockout/knockout/issues/1603
	            if (tagNameLower.indexOf('-') != -1 || ('' + node) == "[object HTMLUnknownElement]" || (ko.utils.ieVersion <= 8 && node.tagName === tagNameLower)) {
	                return tagNameLower;
	            }
	        }
	    };
	
	    ko.components.addBindingsForCustomElement = function(allBindings, node, bindingContext, valueAccessors) {
	        // Determine if it's really a custom element matching a component
	        if (node.nodeType === 1) {
	            var componentName = ko.components['getComponentNameForNode'](node);
	            if (componentName) {
	                // It does represent a component, so add a component binding for it
	                allBindings = allBindings || {};
	
	                if (allBindings['component']) {
	                    // Avoid silently overwriting some other 'component' binding that may already be on the element
	                    throw new Error('Cannot use the "component" binding on a custom element matching a component');
	                }
	
	                var componentBindingValue = { 'name': componentName, 'params': getComponentParamsFromCustomElement(node, bindingContext) };
	
	                allBindings['component'] = valueAccessors
	                    ? function() { return componentBindingValue; }
	                    : componentBindingValue;
	            }
	        }
	
	        return allBindings;
	    }
	
	    var nativeBindingProviderInstance = new ko.bindingProvider();
	
	    function getComponentParamsFromCustomElement(elem, bindingContext) {
	        var paramsAttribute = elem.getAttribute('params');
	
	        if (paramsAttribute) {
	            var params = nativeBindingProviderInstance['parseBindingsString'](paramsAttribute, bindingContext, elem, { 'valueAccessors': true, 'bindingParams': true }),
	                rawParamComputedValues = ko.utils.objectMap(params, function(paramValue, paramName) {
	                    return ko.computed(paramValue, null, { disposeWhenNodeIsRemoved: elem });
	                }),
	                result = ko.utils.objectMap(rawParamComputedValues, function(paramValueComputed, paramName) {
	                    var paramValue = paramValueComputed.peek();
	                    // Does the evaluation of the parameter value unwrap any observables?
	                    if (!paramValueComputed.isActive()) {
	                        // No it doesn't, so there's no need for any computed wrapper. Just pass through the supplied value directly.
	                        // Example: "someVal: firstName, age: 123" (whether or not firstName is an observable/computed)
	                        return paramValue;
	                    } else {
	                        // Yes it does. Supply a computed property that unwraps both the outer (binding expression)
	                        // level of observability, and any inner (resulting model value) level of observability.
	                        // This means the component doesn't have to worry about multiple unwrapping. If the value is a
	                        // writable observable, the computed will also be writable and pass the value on to the observable.
	                        return ko.computed({
	                            'read': function() {
	                                return ko.utils.unwrapObservable(paramValueComputed());
	                            },
	                            'write': ko.isWriteableObservable(paramValue) && function(value) {
	                                paramValueComputed()(value);
	                            },
	                            disposeWhenNodeIsRemoved: elem
	                        });
	                    }
	                });
	
	            // Give access to the raw computeds, as long as that wouldn't overwrite any custom param also called '$raw'
	            // This is in case the developer wants to react to outer (binding) observability separately from inner
	            // (model value) observability, or in case the model value observable has subobservables.
	            if (!result.hasOwnProperty('$raw')) {
	                result['$raw'] = rawParamComputedValues;
	            }
	
	            return result;
	        } else {
	            // For consistency, absence of a "params" attribute is treated the same as the presence of
	            // any empty one. Otherwise component viewmodels need special code to check whether or not
	            // 'params' or 'params.$raw' is null/undefined before reading subproperties, which is annoying.
	            return { '$raw': {} };
	        }
	    }
	
	    // --------------------------------------------------------------------------------
	    // Compatibility code for older (pre-HTML5) IE browsers
	
	    if (ko.utils.ieVersion < 9) {
	        // Whenever you preregister a component, enable it as a custom element in the current document
	        ko.components['register'] = (function(originalFunction) {
	            return function(componentName) {
	                document.createElement(componentName); // Allows IE<9 to parse markup containing the custom element
	                return originalFunction.apply(this, arguments);
	            }
	        })(ko.components['register']);
	
	        // Whenever you create a document fragment, enable all preregistered component names as custom elements
	        // This is needed to make innerShiv/jQuery HTML parsing correctly handle the custom elements
	        document.createDocumentFragment = (function(originalFunction) {
	            return function() {
	                var newDocFrag = originalFunction(),
	                    allComponents = ko.components._allRegisteredComponents;
	                for (var componentName in allComponents) {
	                    if (allComponents.hasOwnProperty(componentName)) {
	                        newDocFrag.createElement(componentName);
	                    }
	                }
	                return newDocFrag;
	            };
	        })(document.createDocumentFragment);
	    }
	})();(function(undefined) {
	
	    var componentLoadingOperationUniqueId = 0;
	
	    ko.bindingHandlers['component'] = {
	        'init': function(element, valueAccessor, ignored1, ignored2, bindingContext) {
	            var currentViewModel,
	                currentLoadingOperationId,
	                disposeAssociatedComponentViewModel = function () {
	                    var currentViewModelDispose = currentViewModel && currentViewModel['dispose'];
	                    if (typeof currentViewModelDispose === 'function') {
	                        currentViewModelDispose.call(currentViewModel);
	                    }
	                    currentViewModel = null;
	                    // Any in-flight loading operation is no longer relevant, so make sure we ignore its completion
	                    currentLoadingOperationId = null;
	                },
	                originalChildNodes = ko.utils.makeArray(ko.virtualElements.childNodes(element));
	
	            ko.utils.domNodeDisposal.addDisposeCallback(element, disposeAssociatedComponentViewModel);
	
	            ko.computed(function () {
	                var value = ko.utils.unwrapObservable(valueAccessor()),
	                    componentName, componentParams;
	
	                if (typeof value === 'string') {
	                    componentName = value;
	                } else {
	                    componentName = ko.utils.unwrapObservable(value['name']);
	                    componentParams = ko.utils.unwrapObservable(value['params']);
	                }
	
	                if (!componentName) {
	                    throw new Error('No component name specified');
	                }
	
	                var loadingOperationId = currentLoadingOperationId = ++componentLoadingOperationUniqueId;
	                ko.components.get(componentName, function(componentDefinition) {
	                    // If this is not the current load operation for this element, ignore it.
	                    if (currentLoadingOperationId !== loadingOperationId) {
	                        return;
	                    }
	
	                    // Clean up previous state
	                    disposeAssociatedComponentViewModel();
	
	                    // Instantiate and bind new component. Implicitly this cleans any old DOM nodes.
	                    if (!componentDefinition) {
	                        throw new Error('Unknown component \'' + componentName + '\'');
	                    }
	                    cloneTemplateIntoElement(componentName, componentDefinition, element);
	                    var componentViewModel = createViewModel(componentDefinition, element, originalChildNodes, componentParams),
	                        childBindingContext = bindingContext['createChildContext'](componentViewModel, /* dataItemAlias */ undefined, function(ctx) {
	                            ctx['$component'] = componentViewModel;
	                            ctx['$componentTemplateNodes'] = originalChildNodes;
	                        });
	                    currentViewModel = componentViewModel;
	                    ko.applyBindingsToDescendants(childBindingContext, element);
	                });
	            }, null, { disposeWhenNodeIsRemoved: element });
	
	            return { 'controlsDescendantBindings': true };
	        }
	    };
	
	    ko.virtualElements.allowedBindings['component'] = true;
	
	    function cloneTemplateIntoElement(componentName, componentDefinition, element) {
	        var template = componentDefinition['template'];
	        if (!template) {
	            throw new Error('Component \'' + componentName + '\' has no template');
	        }
	
	        var clonedNodesArray = ko.utils.cloneNodes(template);
	        ko.virtualElements.setDomNodeChildren(element, clonedNodesArray);
	    }
	
	    function createViewModel(componentDefinition, element, originalChildNodes, componentParams) {
	        var componentViewModelFactory = componentDefinition['createViewModel'];
	        return componentViewModelFactory
	            ? componentViewModelFactory.call(componentDefinition, componentParams, { 'element': element, 'templateNodes': originalChildNodes })
	            : componentParams; // Template-only component
	    }
	
	})();
	var attrHtmlToJavascriptMap = { 'class': 'className', 'for': 'htmlFor' };
	ko.bindingHandlers['attr'] = {
	    'update': function(element, valueAccessor, allBindings) {
	        var value = ko.utils.unwrapObservable(valueAccessor()) || {};
	        ko.utils.objectForEach(value, function(attrName, attrValue) {
	            attrValue = ko.utils.unwrapObservable(attrValue);
	
	            // To cover cases like "attr: { checked:someProp }", we want to remove the attribute entirely
	            // when someProp is a "no value"-like value (strictly null, false, or undefined)
	            // (because the absence of the "checked" attr is how to mark an element as not checked, etc.)
	            var toRemove = (attrValue === false) || (attrValue === null) || (attrValue === undefined);
	            if (toRemove)
	                element.removeAttribute(attrName);
	
	            // In IE <= 7 and IE8 Quirks Mode, you have to use the Javascript property name instead of the
	            // HTML attribute name for certain attributes. IE8 Standards Mode supports the correct behavior,
	            // but instead of figuring out the mode, we'll just set the attribute through the Javascript
	            // property for IE <= 8.
	            if (ko.utils.ieVersion <= 8 && attrName in attrHtmlToJavascriptMap) {
	                attrName = attrHtmlToJavascriptMap[attrName];
	                if (toRemove)
	                    element.removeAttribute(attrName);
	                else
	                    element[attrName] = attrValue;
	            } else if (!toRemove) {
	                element.setAttribute(attrName, attrValue.toString());
	            }
	
	            // Treat "name" specially - although you can think of it as an attribute, it also needs
	            // special handling on older versions of IE (https://github.com/SteveSanderson/knockout/pull/333)
	            // Deliberately being case-sensitive here because XHTML would regard "Name" as a different thing
	            // entirely, and there's no strong reason to allow for such casing in HTML.
	            if (attrName === "name") {
	                ko.utils.setElementName(element, toRemove ? "" : attrValue.toString());
	            }
	        });
	    }
	};
	(function() {
	
	ko.bindingHandlers['checked'] = {
	    'after': ['value', 'attr'],
	    'init': function (element, valueAccessor, allBindings) {
	        var checkedValue = ko.pureComputed(function() {
	            // Treat "value" like "checkedValue" when it is included with "checked" binding
	            if (allBindings['has']('checkedValue')) {
	                return ko.utils.unwrapObservable(allBindings.get('checkedValue'));
	            } else if (allBindings['has']('value')) {
	                return ko.utils.unwrapObservable(allBindings.get('value'));
	            }
	
	            return element.value;
	        });
	
	        function updateModel() {
	            // This updates the model value from the view value.
	            // It runs in response to DOM events (click) and changes in checkedValue.
	            var isChecked = element.checked,
	                elemValue = useCheckedValue ? checkedValue() : isChecked;
	
	            // When we're first setting up this computed, don't change any model state.
	            if (ko.computedContext.isInitial()) {
	                return;
	            }
	
	            // We can ignore unchecked radio buttons, because some other radio
	            // button will be getting checked, and that one can take care of updating state.
	            if (isRadio && !isChecked) {
	                return;
	            }
	
	            var modelValue = ko.dependencyDetection.ignore(valueAccessor);
	            if (valueIsArray) {
	                var writableValue = rawValueIsNonArrayObservable ? modelValue.peek() : modelValue;
	                if (oldElemValue !== elemValue) {
	                    // When we're responding to the checkedValue changing, and the element is
	                    // currently checked, replace the old elem value with the new elem value
	                    // in the model array.
	                    if (isChecked) {
	                        ko.utils.addOrRemoveItem(writableValue, elemValue, true);
	                        ko.utils.addOrRemoveItem(writableValue, oldElemValue, false);
	                    }
	
	                    oldElemValue = elemValue;
	                } else {
	                    // When we're responding to the user having checked/unchecked a checkbox,
	                    // add/remove the element value to the model array.
	                    ko.utils.addOrRemoveItem(writableValue, elemValue, isChecked);
	                }
	                if (rawValueIsNonArrayObservable && ko.isWriteableObservable(modelValue)) {
	                    modelValue(writableValue);
	                }
	            } else {
	                ko.expressionRewriting.writeValueToProperty(modelValue, allBindings, 'checked', elemValue, true);
	            }
	        };
	
	        function updateView() {
	            // This updates the view value from the model value.
	            // It runs in response to changes in the bound (checked) value.
	            var modelValue = ko.utils.unwrapObservable(valueAccessor());
	
	            if (valueIsArray) {
	                // When a checkbox is bound to an array, being checked represents its value being present in that array
	                element.checked = ko.utils.arrayIndexOf(modelValue, checkedValue()) >= 0;
	            } else if (isCheckbox) {
	                // When a checkbox is bound to any other value (not an array), being checked represents the value being trueish
	                element.checked = modelValue;
	            } else {
	                // For radio buttons, being checked means that the radio button's value corresponds to the model value
	                element.checked = (checkedValue() === modelValue);
	            }
	        };
	
	        var isCheckbox = element.type == "checkbox",
	            isRadio = element.type == "radio";
	
	        // Only bind to check boxes and radio buttons
	        if (!isCheckbox && !isRadio) {
	            return;
	        }
	
	        var rawValue = valueAccessor(),
	            valueIsArray = isCheckbox && (ko.utils.unwrapObservable(rawValue) instanceof Array),
	            rawValueIsNonArrayObservable = !(valueIsArray && rawValue.push && rawValue.splice),
	            oldElemValue = valueIsArray ? checkedValue() : undefined,
	            useCheckedValue = isRadio || valueIsArray;
	
	        // IE 6 won't allow radio buttons to be selected unless they have a name
	        if (isRadio && !element.name)
	            ko.bindingHandlers['uniqueName']['init'](element, function() { return true });
	
	        // Set up two computeds to update the binding:
	
	        // The first responds to changes in the checkedValue value and to element clicks
	        ko.computed(updateModel, null, { disposeWhenNodeIsRemoved: element });
	        ko.utils.registerEventHandler(element, "click", updateModel);
	
	        // The second responds to changes in the model value (the one associated with the checked binding)
	        ko.computed(updateView, null, { disposeWhenNodeIsRemoved: element });
	
	        rawValue = undefined;
	    }
	};
	ko.expressionRewriting.twoWayBindings['checked'] = true;
	
	ko.bindingHandlers['checkedValue'] = {
	    'update': function (element, valueAccessor) {
	        element.value = ko.utils.unwrapObservable(valueAccessor());
	    }
	};
	
	})();var classesWrittenByBindingKey = '__ko__cssValue';
	ko.bindingHandlers['css'] = {
	    'update': function (element, valueAccessor) {
	        var value = ko.utils.unwrapObservable(valueAccessor());
	        if (value !== null && typeof value == "object") {
	            ko.utils.objectForEach(value, function(className, shouldHaveClass) {
	                shouldHaveClass = ko.utils.unwrapObservable(shouldHaveClass);
	                ko.utils.toggleDomNodeCssClass(element, className, shouldHaveClass);
	            });
	        } else {
	            value = ko.utils.stringTrim(String(value || '')); // Make sure we don't try to store or set a non-string value
	            ko.utils.toggleDomNodeCssClass(element, element[classesWrittenByBindingKey], false);
	            element[classesWrittenByBindingKey] = value;
	            ko.utils.toggleDomNodeCssClass(element, value, true);
	        }
	    }
	};
	ko.bindingHandlers['enable'] = {
	    'update': function (element, valueAccessor) {
	        var value = ko.utils.unwrapObservable(valueAccessor());
	        if (value && element.disabled)
	            element.removeAttribute("disabled");
	        else if ((!value) && (!element.disabled))
	            element.disabled = true;
	    }
	};
	
	ko.bindingHandlers['disable'] = {
	    'update': function (element, valueAccessor) {
	        ko.bindingHandlers['enable']['update'](element, function() { return !ko.utils.unwrapObservable(valueAccessor()) });
	    }
	};
	// For certain common events (currently just 'click'), allow a simplified data-binding syntax
	// e.g. click:handler instead of the usual full-length event:{click:handler}
	function makeEventHandlerShortcut(eventName) {
	    ko.bindingHandlers[eventName] = {
	        'init': function(element, valueAccessor, allBindings, viewModel, bindingContext) {
	            var newValueAccessor = function () {
	                var result = {};
	                result[eventName] = valueAccessor();
	                return result;
	            };
	            return ko.bindingHandlers['event']['init'].call(this, element, newValueAccessor, allBindings, viewModel, bindingContext);
	        }
	    }
	}
	
	ko.bindingHandlers['event'] = {
	    'init' : function (element, valueAccessor, allBindings, viewModel, bindingContext) {
	        var eventsToHandle = valueAccessor() || {};
	        ko.utils.objectForEach(eventsToHandle, function(eventName) {
	            if (typeof eventName == "string") {
	                ko.utils.registerEventHandler(element, eventName, function (event) {
	                    var handlerReturnValue;
	                    var handlerFunction = valueAccessor()[eventName];
	                    if (!handlerFunction)
	                        return;
	
	                    try {
	                        // Take all the event args, and prefix with the viewmodel
	                        var argsForHandler = ko.utils.makeArray(arguments);
	                        viewModel = bindingContext['$data'];
	                        argsForHandler.unshift(viewModel);
	                        handlerReturnValue = handlerFunction.apply(viewModel, argsForHandler);
	                    } finally {
	                        if (handlerReturnValue !== true) { // Normally we want to prevent default action. Developer can override this be explicitly returning true.
	                            if (event.preventDefault)
	                                event.preventDefault();
	                            else
	                                event.returnValue = false;
	                        }
	                    }
	
	                    var bubble = allBindings.get(eventName + 'Bubble') !== false;
	                    if (!bubble) {
	                        event.cancelBubble = true;
	                        if (event.stopPropagation)
	                            event.stopPropagation();
	                    }
	                });
	            }
	        });
	    }
	};
	// "foreach: someExpression" is equivalent to "template: { foreach: someExpression }"
	// "foreach: { data: someExpression, afterAdd: myfn }" is equivalent to "template: { foreach: someExpression, afterAdd: myfn }"
	ko.bindingHandlers['foreach'] = {
	    makeTemplateValueAccessor: function(valueAccessor) {
	        return function() {
	            var modelValue = valueAccessor(),
	                unwrappedValue = ko.utils.peekObservable(modelValue);    // Unwrap without setting a dependency here
	
	            // If unwrappedValue is the array, pass in the wrapped value on its own
	            // The value will be unwrapped and tracked within the template binding
	            // (See https://github.com/SteveSanderson/knockout/issues/523)
	            if ((!unwrappedValue) || typeof unwrappedValue.length == "number")
	                return { 'foreach': modelValue, 'templateEngine': ko.nativeTemplateEngine.instance };
	
	            // If unwrappedValue.data is the array, preserve all relevant options and unwrap again value so we get updates
	            ko.utils.unwrapObservable(modelValue);
	            return {
	                'foreach': unwrappedValue['data'],
	                'as': unwrappedValue['as'],
	                'includeDestroyed': unwrappedValue['includeDestroyed'],
	                'afterAdd': unwrappedValue['afterAdd'],
	                'beforeRemove': unwrappedValue['beforeRemove'],
	                'afterRender': unwrappedValue['afterRender'],
	                'beforeMove': unwrappedValue['beforeMove'],
	                'afterMove': unwrappedValue['afterMove'],
	                'templateEngine': ko.nativeTemplateEngine.instance
	            };
	        };
	    },
	    'init': function(element, valueAccessor, allBindings, viewModel, bindingContext) {
	        return ko.bindingHandlers['template']['init'](element, ko.bindingHandlers['foreach'].makeTemplateValueAccessor(valueAccessor));
	    },
	    'update': function(element, valueAccessor, allBindings, viewModel, bindingContext) {
	        return ko.bindingHandlers['template']['update'](element, ko.bindingHandlers['foreach'].makeTemplateValueAccessor(valueAccessor), allBindings, viewModel, bindingContext);
	    }
	};
	ko.expressionRewriting.bindingRewriteValidators['foreach'] = false; // Can't rewrite control flow bindings
	ko.virtualElements.allowedBindings['foreach'] = true;
	var hasfocusUpdatingProperty = '__ko_hasfocusUpdating';
	var hasfocusLastValue = '__ko_hasfocusLastValue';
	ko.bindingHandlers['hasfocus'] = {
	    'init': function(element, valueAccessor, allBindings) {
	        var handleElementFocusChange = function(isFocused) {
	            // Where possible, ignore which event was raised and determine focus state using activeElement,
	            // as this avoids phantom focus/blur events raised when changing tabs in modern browsers.
	            // However, not all KO-targeted browsers (Firefox 2) support activeElement. For those browsers,
	            // prevent a loss of focus when changing tabs/windows by setting a flag that prevents hasfocus
	            // from calling 'blur()' on the element when it loses focus.
	            // Discussion at https://github.com/SteveSanderson/knockout/pull/352
	            element[hasfocusUpdatingProperty] = true;
	            var ownerDoc = element.ownerDocument;
	            if ("activeElement" in ownerDoc) {
	                var active;
	                try {
	                    active = ownerDoc.activeElement;
	                } catch(e) {
	                    // IE9 throws if you access activeElement during page load (see issue #703)
	                    active = ownerDoc.body;
	                }
	                isFocused = (active === element);
	            }
	            var modelValue = valueAccessor();
	            ko.expressionRewriting.writeValueToProperty(modelValue, allBindings, 'hasfocus', isFocused, true);
	
	            //cache the latest value, so we can avoid unnecessarily calling focus/blur in the update function
	            element[hasfocusLastValue] = isFocused;
	            element[hasfocusUpdatingProperty] = false;
	        };
	        var handleElementFocusIn = handleElementFocusChange.bind(null, true);
	        var handleElementFocusOut = handleElementFocusChange.bind(null, false);
	
	        ko.utils.registerEventHandler(element, "focus", handleElementFocusIn);
	        ko.utils.registerEventHandler(element, "focusin", handleElementFocusIn); // For IE
	        ko.utils.registerEventHandler(element, "blur",  handleElementFocusOut);
	        ko.utils.registerEventHandler(element, "focusout",  handleElementFocusOut); // For IE
	    },
	    'update': function(element, valueAccessor) {
	        var value = !!ko.utils.unwrapObservable(valueAccessor());
	
	        if (!element[hasfocusUpdatingProperty] && element[hasfocusLastValue] !== value) {
	            value ? element.focus() : element.blur();
	
	            // In IE, the blur method doesn't always cause the element to lose focus (for example, if the window is not in focus).
	            // Setting focus to the body element does seem to be reliable in IE, but should only be used if we know that the current
	            // element was focused already.
	            if (!value && element[hasfocusLastValue]) {
	                element.ownerDocument.body.focus();
	            }
	
	            // For IE, which doesn't reliably fire "focus" or "blur" events synchronously
	            ko.dependencyDetection.ignore(ko.utils.triggerEvent, null, [element, value ? "focusin" : "focusout"]);
	        }
	    }
	};
	ko.expressionRewriting.twoWayBindings['hasfocus'] = true;
	
	ko.bindingHandlers['hasFocus'] = ko.bindingHandlers['hasfocus']; // Make "hasFocus" an alias
	ko.expressionRewriting.twoWayBindings['hasFocus'] = true;
	ko.bindingHandlers['html'] = {
	    'init': function() {
	        // Prevent binding on the dynamically-injected HTML (as developers are unlikely to expect that, and it has security implications)
	        return { 'controlsDescendantBindings': true };
	    },
	    'update': function (element, valueAccessor) {
	        // setHtml will unwrap the value if needed
	        ko.utils.setHtml(element, valueAccessor());
	    }
	};
	// Makes a binding like with or if
	function makeWithIfBinding(bindingKey, isWith, isNot, makeContextCallback) {
	    ko.bindingHandlers[bindingKey] = {
	        'init': function(element, valueAccessor, allBindings, viewModel, bindingContext) {
	            var didDisplayOnLastUpdate,
	                savedNodes;
	            ko.computed(function() {
	                var rawValue = valueAccessor(),
	                    dataValue = ko.utils.unwrapObservable(rawValue),
	                    shouldDisplay = !isNot !== !dataValue, // equivalent to isNot ? !dataValue : !!dataValue
	                    isFirstRender = !savedNodes,
	                    needsRefresh = isFirstRender || isWith || (shouldDisplay !== didDisplayOnLastUpdate);
	
	                if (needsRefresh) {
	                    // Save a copy of the inner nodes on the initial update, but only if we have dependencies.
	                    if (isFirstRender && ko.computedContext.getDependenciesCount()) {
	                        savedNodes = ko.utils.cloneNodes(ko.virtualElements.childNodes(element), true /* shouldCleanNodes */);
	                    }
	
	                    if (shouldDisplay) {
	                        if (!isFirstRender) {
	                            ko.virtualElements.setDomNodeChildren(element, ko.utils.cloneNodes(savedNodes));
	                        }
	                        ko.applyBindingsToDescendants(makeContextCallback ? makeContextCallback(bindingContext, rawValue) : bindingContext, element);
	                    } else {
	                        ko.virtualElements.emptyNode(element);
	                    }
	
	                    didDisplayOnLastUpdate = shouldDisplay;
	                }
	            }, null, { disposeWhenNodeIsRemoved: element });
	            return { 'controlsDescendantBindings': true };
	        }
	    };
	    ko.expressionRewriting.bindingRewriteValidators[bindingKey] = false; // Can't rewrite control flow bindings
	    ko.virtualElements.allowedBindings[bindingKey] = true;
	}
	
	// Construct the actual binding handlers
	makeWithIfBinding('if');
	makeWithIfBinding('ifnot', false /* isWith */, true /* isNot */);
	makeWithIfBinding('with', true /* isWith */, false /* isNot */,
	    function(bindingContext, dataValue) {
	        return bindingContext.createStaticChildContext(dataValue);
	    }
	);
	var captionPlaceholder = {};
	ko.bindingHandlers['options'] = {
	    'init': function(element) {
	        if (ko.utils.tagNameLower(element) !== "select")
	            throw new Error("options binding applies only to SELECT elements");
	
	        // Remove all existing <option>s.
	        while (element.length > 0) {
	            element.remove(0);
	        }
	
	        // Ensures that the binding processor doesn't try to bind the options
	        return { 'controlsDescendantBindings': true };
	    },
	    'update': function (element, valueAccessor, allBindings) {
	        function selectedOptions() {
	            return ko.utils.arrayFilter(element.options, function (node) { return node.selected; });
	        }
	
	        var selectWasPreviouslyEmpty = element.length == 0,
	            multiple = element.multiple,
	            previousScrollTop = (!selectWasPreviouslyEmpty && multiple) ? element.scrollTop : null,
	            unwrappedArray = ko.utils.unwrapObservable(valueAccessor()),
	            valueAllowUnset = allBindings.get('valueAllowUnset') && allBindings['has']('value'),
	            includeDestroyed = allBindings.get('optionsIncludeDestroyed'),
	            arrayToDomNodeChildrenOptions = {},
	            captionValue,
	            filteredArray,
	            previousSelectedValues = [];
	
	        if (!valueAllowUnset) {
	            if (multiple) {
	                previousSelectedValues = ko.utils.arrayMap(selectedOptions(), ko.selectExtensions.readValue);
	            } else if (element.selectedIndex >= 0) {
	                previousSelectedValues.push(ko.selectExtensions.readValue(element.options[element.selectedIndex]));
	            }
	        }
	
	        if (unwrappedArray) {
	            if (typeof unwrappedArray.length == "undefined") // Coerce single value into array
	                unwrappedArray = [unwrappedArray];
	
	            // Filter out any entries marked as destroyed
	            filteredArray = ko.utils.arrayFilter(unwrappedArray, function(item) {
	                return includeDestroyed || item === undefined || item === null || !ko.utils.unwrapObservable(item['_destroy']);
	            });
	
	            // If caption is included, add it to the array
	            if (allBindings['has']('optionsCaption')) {
	                captionValue = ko.utils.unwrapObservable(allBindings.get('optionsCaption'));
	                // If caption value is null or undefined, don't show a caption
	                if (captionValue !== null && captionValue !== undefined) {
	                    filteredArray.unshift(captionPlaceholder);
	                }
	            }
	        } else {
	            // If a falsy value is provided (e.g. null), we'll simply empty the select element
	        }
	
	        function applyToObject(object, predicate, defaultValue) {
	            var predicateType = typeof predicate;
	            if (predicateType == "function")    // Given a function; run it against the data value
	                return predicate(object);
	            else if (predicateType == "string") // Given a string; treat it as a property name on the data value
	                return object[predicate];
	            else                                // Given no optionsText arg; use the data value itself
	                return defaultValue;
	        }
	
	        // The following functions can run at two different times:
	        // The first is when the whole array is being updated directly from this binding handler.
	        // The second is when an observable value for a specific array entry is updated.
	        // oldOptions will be empty in the first case, but will be filled with the previously generated option in the second.
	        var itemUpdate = false;
	        function optionForArrayItem(arrayEntry, index, oldOptions) {
	            if (oldOptions.length) {
	                previousSelectedValues = !valueAllowUnset && oldOptions[0].selected ? [ ko.selectExtensions.readValue(oldOptions[0]) ] : [];
	                itemUpdate = true;
	            }
	            var option = element.ownerDocument.createElement("option");
	            if (arrayEntry === captionPlaceholder) {
	                ko.utils.setTextContent(option, allBindings.get('optionsCaption'));
	                ko.selectExtensions.writeValue(option, undefined);
	            } else {
	                // Apply a value to the option element
	                var optionValue = applyToObject(arrayEntry, allBindings.get('optionsValue'), arrayEntry);
	                ko.selectExtensions.writeValue(option, ko.utils.unwrapObservable(optionValue));
	
	                // Apply some text to the option element
	                var optionText = applyToObject(arrayEntry, allBindings.get('optionsText'), optionValue);
	                ko.utils.setTextContent(option, optionText);
	            }
	            return [option];
	        }
	
	        // By using a beforeRemove callback, we delay the removal until after new items are added. This fixes a selection
	        // problem in IE<=8 and Firefox. See https://github.com/knockout/knockout/issues/1208
	        arrayToDomNodeChildrenOptions['beforeRemove'] =
	            function (option) {
	                element.removeChild(option);
	            };
	
	        function setSelectionCallback(arrayEntry, newOptions) {
	            if (itemUpdate && valueAllowUnset) {
	                // The model value is authoritative, so make sure its value is the one selected
	                // There is no need to use dependencyDetection.ignore since setDomNodeChildrenFromArrayMapping does so already.
	                ko.selectExtensions.writeValue(element, ko.utils.unwrapObservable(allBindings.get('value')), true /* allowUnset */);
	            } else if (previousSelectedValues.length) {
	                // IE6 doesn't like us to assign selection to OPTION nodes before they're added to the document.
	                // That's why we first added them without selection. Now it's time to set the selection.
	                var isSelected = ko.utils.arrayIndexOf(previousSelectedValues, ko.selectExtensions.readValue(newOptions[0])) >= 0;
	                ko.utils.setOptionNodeSelectionState(newOptions[0], isSelected);
	
	                // If this option was changed from being selected during a single-item update, notify the change
	                if (itemUpdate && !isSelected) {
	                    ko.dependencyDetection.ignore(ko.utils.triggerEvent, null, [element, "change"]);
	                }
	            }
	        }
	
	        var callback = setSelectionCallback;
	        if (allBindings['has']('optionsAfterRender') && typeof allBindings.get('optionsAfterRender') == "function") {
	            callback = function(arrayEntry, newOptions) {
	                setSelectionCallback(arrayEntry, newOptions);
	                ko.dependencyDetection.ignore(allBindings.get('optionsAfterRender'), null, [newOptions[0], arrayEntry !== captionPlaceholder ? arrayEntry : undefined]);
	            }
	        }
	
	        ko.utils.setDomNodeChildrenFromArrayMapping(element, filteredArray, optionForArrayItem, arrayToDomNodeChildrenOptions, callback);
	
	        ko.dependencyDetection.ignore(function () {
	            if (valueAllowUnset) {
	                // The model value is authoritative, so make sure its value is the one selected
	                ko.selectExtensions.writeValue(element, ko.utils.unwrapObservable(allBindings.get('value')), true /* allowUnset */);
	            } else {
	                // Determine if the selection has changed as a result of updating the options list
	                var selectionChanged;
	                if (multiple) {
	                    // For a multiple-select box, compare the new selection count to the previous one
	                    // But if nothing was selected before, the selection can't have changed
	                    selectionChanged = previousSelectedValues.length && selectedOptions().length < previousSelectedValues.length;
	                } else {
	                    // For a single-select box, compare the current value to the previous value
	                    // But if nothing was selected before or nothing is selected now, just look for a change in selection
	                    selectionChanged = (previousSelectedValues.length && element.selectedIndex >= 0)
	                        ? (ko.selectExtensions.readValue(element.options[element.selectedIndex]) !== previousSelectedValues[0])
	                        : (previousSelectedValues.length || element.selectedIndex >= 0);
	                }
	
	                // Ensure consistency between model value and selected option.
	                // If the dropdown was changed so that selection is no longer the same,
	                // notify the value or selectedOptions binding.
	                if (selectionChanged) {
	                    ko.utils.triggerEvent(element, "change");
	                }
	            }
	        });
	
	        // Workaround for IE bug
	        ko.utils.ensureSelectElementIsRenderedCorrectly(element);
	
	        if (previousScrollTop && Math.abs(previousScrollTop - element.scrollTop) > 20)
	            element.scrollTop = previousScrollTop;
	    }
	};
	ko.bindingHandlers['options'].optionValueDomDataKey = ko.utils.domData.nextKey();
	ko.bindingHandlers['selectedOptions'] = {
	    'after': ['options', 'foreach'],
	    'init': function (element, valueAccessor, allBindings) {
	        ko.utils.registerEventHandler(element, "change", function () {
	            var value = valueAccessor(), valueToWrite = [];
	            ko.utils.arrayForEach(element.getElementsByTagName("option"), function(node) {
	                if (node.selected)
	                    valueToWrite.push(ko.selectExtensions.readValue(node));
	            });
	            ko.expressionRewriting.writeValueToProperty(value, allBindings, 'selectedOptions', valueToWrite);
	        });
	    },
	    'update': function (element, valueAccessor) {
	        if (ko.utils.tagNameLower(element) != "select")
	            throw new Error("values binding applies only to SELECT elements");
	
	        var newValue = ko.utils.unwrapObservable(valueAccessor()),
	            previousScrollTop = element.scrollTop;
	
	        if (newValue && typeof newValue.length == "number") {
	            ko.utils.arrayForEach(element.getElementsByTagName("option"), function(node) {
	                var isSelected = ko.utils.arrayIndexOf(newValue, ko.selectExtensions.readValue(node)) >= 0;
	                if (node.selected != isSelected) {      // This check prevents flashing of the select element in IE
	                    ko.utils.setOptionNodeSelectionState(node, isSelected);
	                }
	            });
	        }
	
	        element.scrollTop = previousScrollTop;
	    }
	};
	ko.expressionRewriting.twoWayBindings['selectedOptions'] = true;
	ko.bindingHandlers['style'] = {
	    'update': function (element, valueAccessor) {
	        var value = ko.utils.unwrapObservable(valueAccessor() || {});
	        ko.utils.objectForEach(value, function(styleName, styleValue) {
	            styleValue = ko.utils.unwrapObservable(styleValue);
	
	            if (styleValue === null || styleValue === undefined || styleValue === false) {
	                // Empty string removes the value, whereas null/undefined have no effect
	                styleValue = "";
	            }
	
	            element.style[styleName] = styleValue;
	        });
	    }
	};
	ko.bindingHandlers['submit'] = {
	    'init': function (element, valueAccessor, allBindings, viewModel, bindingContext) {
	        if (typeof valueAccessor() != "function")
	            throw new Error("The value for a submit binding must be a function");
	        ko.utils.registerEventHandler(element, "submit", function (event) {
	            var handlerReturnValue;
	            var value = valueAccessor();
	            try { handlerReturnValue = value.call(bindingContext['$data'], element); }
	            finally {
	                if (handlerReturnValue !== true) { // Normally we want to prevent default action. Developer can override this be explicitly returning true.
	                    if (event.preventDefault)
	                        event.preventDefault();
	                    else
	                        event.returnValue = false;
	                }
	            }
	        });
	    }
	};
	ko.bindingHandlers['text'] = {
	    'init': function() {
	        // Prevent binding on the dynamically-injected text node (as developers are unlikely to expect that, and it has security implications).
	        // It should also make things faster, as we no longer have to consider whether the text node might be bindable.
	        return { 'controlsDescendantBindings': true };
	    },
	    'update': function (element, valueAccessor) {
	        ko.utils.setTextContent(element, valueAccessor());
	    }
	};
	ko.virtualElements.allowedBindings['text'] = true;
	(function () {
	
	if (window && window.navigator) {
	    var parseVersion = function (matches) {
	        if (matches) {
	            return parseFloat(matches[1]);
	        }
	    };
	
	    // Detect various browser versions because some old versions don't fully support the 'input' event
	    var operaVersion = window.opera && window.opera.version && parseInt(window.opera.version()),
	        userAgent = window.navigator.userAgent,
	        safariVersion = parseVersion(userAgent.match(/^(?:(?!chrome).)*version\/([^ ]*) safari/i)),
	        firefoxVersion = parseVersion(userAgent.match(/Firefox\/([^ ]*)/));
	}
	
	// IE 8 and 9 have bugs that prevent the normal events from firing when the value changes.
	// But it does fire the 'selectionchange' event on many of those, presumably because the
	// cursor is moving and that counts as the selection changing. The 'selectionchange' event is
	// fired at the document level only and doesn't directly indicate which element changed. We
	// set up just one event handler for the document and use 'activeElement' to determine which
	// element was changed.
	if (ko.utils.ieVersion < 10) {
	    var selectionChangeRegisteredName = ko.utils.domData.nextKey(),
	        selectionChangeHandlerName = ko.utils.domData.nextKey();
	    var selectionChangeHandler = function(event) {
	        var target = this.activeElement,
	            handler = target && ko.utils.domData.get(target, selectionChangeHandlerName);
	        if (handler) {
	            handler(event);
	        }
	    };
	    var registerForSelectionChangeEvent = function (element, handler) {
	        var ownerDoc = element.ownerDocument;
	        if (!ko.utils.domData.get(ownerDoc, selectionChangeRegisteredName)) {
	            ko.utils.domData.set(ownerDoc, selectionChangeRegisteredName, true);
	            ko.utils.registerEventHandler(ownerDoc, 'selectionchange', selectionChangeHandler);
	        }
	        ko.utils.domData.set(element, selectionChangeHandlerName, handler);
	    };
	}
	
	ko.bindingHandlers['textInput'] = {
	    'init': function (element, valueAccessor, allBindings) {
	
	        var previousElementValue = element.value,
	            timeoutHandle,
	            elementValueBeforeEvent;
	
	        var updateModel = function (event) {
	            clearTimeout(timeoutHandle);
	            elementValueBeforeEvent = timeoutHandle = undefined;
	
	            var elementValue = element.value;
	            if (previousElementValue !== elementValue) {
	                // Provide a way for tests to know exactly which event was processed
	                if (DEBUG && event) element['_ko_textInputProcessedEvent'] = event.type;
	                previousElementValue = elementValue;
	                ko.expressionRewriting.writeValueToProperty(valueAccessor(), allBindings, 'textInput', elementValue);
	            }
	        };
	
	        var deferUpdateModel = function (event) {
	            if (!timeoutHandle) {
	                // The elementValueBeforeEvent variable is set *only* during the brief gap between an
	                // event firing and the updateModel function running. This allows us to ignore model
	                // updates that are from the previous state of the element, usually due to techniques
	                // such as rateLimit. Such updates, if not ignored, can cause keystrokes to be lost.
	                elementValueBeforeEvent = element.value;
	                var handler = DEBUG ? updateModel.bind(element, {type: event.type}) : updateModel;
	                timeoutHandle = ko.utils.setTimeout(handler, 4);
	            }
	        };
	
	        // IE9 will mess up the DOM if you handle events synchronously which results in DOM changes (such as other bindings);
	        // so we'll make sure all updates are asynchronous
	        var ieUpdateModel = ko.utils.ieVersion == 9 ? deferUpdateModel : updateModel;
	
	        var updateView = function () {
	            var modelValue = ko.utils.unwrapObservable(valueAccessor());
	
	            if (modelValue === null || modelValue === undefined) {
	                modelValue = '';
	            }
	
	            if (elementValueBeforeEvent !== undefined && modelValue === elementValueBeforeEvent) {
	                ko.utils.setTimeout(updateView, 4);
	                return;
	            }
	
	            // Update the element only if the element and model are different. On some browsers, updating the value
	            // will move the cursor to the end of the input, which would be bad while the user is typing.
	            if (element.value !== modelValue) {
	                previousElementValue = modelValue;  // Make sure we ignore events (propertychange) that result from updating the value
	                element.value = modelValue;
	            }
	        };
	
	        var onEvent = function (event, handler) {
	            ko.utils.registerEventHandler(element, event, handler);
	        };
	
	        if (DEBUG && ko.bindingHandlers['textInput']['_forceUpdateOn']) {
	            // Provide a way for tests to specify exactly which events are bound
	            ko.utils.arrayForEach(ko.bindingHandlers['textInput']['_forceUpdateOn'], function(eventName) {
	                if (eventName.slice(0,5) == 'after') {
	                    onEvent(eventName.slice(5), deferUpdateModel);
	                } else {
	                    onEvent(eventName, updateModel);
	                }
	            });
	        } else {
	            if (ko.utils.ieVersion < 10) {
	                // Internet Explorer <= 8 doesn't support the 'input' event, but does include 'propertychange' that fires whenever
	                // any property of an element changes. Unlike 'input', it also fires if a property is changed from JavaScript code,
	                // but that's an acceptable compromise for this binding. IE 9 does support 'input', but since it doesn't fire it
	                // when using autocomplete, we'll use 'propertychange' for it also.
	                onEvent('propertychange', function(event) {
	                    if (event.propertyName === 'value') {
	                        ieUpdateModel(event);
	                    }
	                });
	
	                if (ko.utils.ieVersion == 8) {
	                    // IE 8 has a bug where it fails to fire 'propertychange' on the first update following a value change from
	                    // JavaScript code. It also doesn't fire if you clear the entire value. To fix this, we bind to the following
	                    // events too.
	                    onEvent('keyup', updateModel);      // A single keystoke
	                    onEvent('keydown', updateModel);    // The first character when a key is held down
	                }
	                if (ko.utils.ieVersion >= 8) {
	                    // Internet Explorer 9 doesn't fire the 'input' event when deleting text, including using
	                    // the backspace, delete, or ctrl-x keys, clicking the 'x' to clear the input, dragging text
	                    // out of the field, and cutting or deleting text using the context menu. 'selectionchange'
	                    // can detect all of those except dragging text out of the field, for which we use 'dragend'.
	                    // These are also needed in IE8 because of the bug described above.
	                    registerForSelectionChangeEvent(element, ieUpdateModel);  // 'selectionchange' covers cut, paste, drop, delete, etc.
	                    onEvent('dragend', deferUpdateModel);
	                }
	            } else {
	                // All other supported browsers support the 'input' event, which fires whenever the content of the element is changed
	                // through the user interface.
	                onEvent('input', updateModel);
	
	                if (safariVersion < 5 && ko.utils.tagNameLower(element) === "textarea") {
	                    // Safari <5 doesn't fire the 'input' event for <textarea> elements (it does fire 'textInput'
	                    // but only when typing). So we'll just catch as much as we can with keydown, cut, and paste.
	                    onEvent('keydown', deferUpdateModel);
	                    onEvent('paste', deferUpdateModel);
	                    onEvent('cut', deferUpdateModel);
	                } else if (operaVersion < 11) {
	                    // Opera 10 doesn't always fire the 'input' event for cut, paste, undo & drop operations.
	                    // We can try to catch some of those using 'keydown'.
	                    onEvent('keydown', deferUpdateModel);
	                } else if (firefoxVersion < 4.0) {
	                    // Firefox <= 3.6 doesn't fire the 'input' event when text is filled in through autocomplete
	                    onEvent('DOMAutoComplete', updateModel);
	
	                    // Firefox <=3.5 doesn't fire the 'input' event when text is dropped into the input.
	                    onEvent('dragdrop', updateModel);       // <3.5
	                    onEvent('drop', updateModel);           // 3.5
	                }
	            }
	        }
	
	        // Bind to the change event so that we can catch programmatic updates of the value that fire this event.
	        onEvent('change', updateModel);
	
	        ko.computed(updateView, null, { disposeWhenNodeIsRemoved: element });
	    }
	};
	ko.expressionRewriting.twoWayBindings['textInput'] = true;
	
	// textinput is an alias for textInput
	ko.bindingHandlers['textinput'] = {
	    // preprocess is the only way to set up a full alias
	    'preprocess': function (value, name, addBinding) {
	        addBinding('textInput', value);
	    }
	};
	
	})();ko.bindingHandlers['uniqueName'] = {
	    'init': function (element, valueAccessor) {
	        if (valueAccessor()) {
	            var name = "ko_unique_" + (++ko.bindingHandlers['uniqueName'].currentIndex);
	            ko.utils.setElementName(element, name);
	        }
	    }
	};
	ko.bindingHandlers['uniqueName'].currentIndex = 0;
	ko.bindingHandlers['value'] = {
	    'after': ['options', 'foreach'],
	    'init': function (element, valueAccessor, allBindings) {
	        // If the value binding is placed on a radio/checkbox, then just pass through to checkedValue and quit
	        if (element.tagName.toLowerCase() == "input" && (element.type == "checkbox" || element.type == "radio")) {
	            ko.applyBindingAccessorsToNode(element, { 'checkedValue': valueAccessor });
	            return;
	        }
	
	        // Always catch "change" event; possibly other events too if asked
	        var eventsToCatch = ["change"];
	        var requestedEventsToCatch = allBindings.get("valueUpdate");
	        var propertyChangedFired = false;
	        var elementValueBeforeEvent = null;
	
	        if (requestedEventsToCatch) {
	            if (typeof requestedEventsToCatch == "string") // Allow both individual event names, and arrays of event names
	                requestedEventsToCatch = [requestedEventsToCatch];
	            ko.utils.arrayPushAll(eventsToCatch, requestedEventsToCatch);
	            eventsToCatch = ko.utils.arrayGetDistinctValues(eventsToCatch);
	        }
	
	        var valueUpdateHandler = function() {
	            elementValueBeforeEvent = null;
	            propertyChangedFired = false;
	            var modelValue = valueAccessor();
	            var elementValue = ko.selectExtensions.readValue(element);
	            ko.expressionRewriting.writeValueToProperty(modelValue, allBindings, 'value', elementValue);
	        }
	
	        // Workaround for https://github.com/SteveSanderson/knockout/issues/122
	        // IE doesn't fire "change" events on textboxes if the user selects a value from its autocomplete list
	        var ieAutoCompleteHackNeeded = ko.utils.ieVersion && element.tagName.toLowerCase() == "input" && element.type == "text"
	                                       && element.autocomplete != "off" && (!element.form || element.form.autocomplete != "off");
	        if (ieAutoCompleteHackNeeded && ko.utils.arrayIndexOf(eventsToCatch, "propertychange") == -1) {
	            ko.utils.registerEventHandler(element, "propertychange", function () { propertyChangedFired = true });
	            ko.utils.registerEventHandler(element, "focus", function () { propertyChangedFired = false });
	            ko.utils.registerEventHandler(element, "blur", function() {
	                if (propertyChangedFired) {
	                    valueUpdateHandler();
	                }
	            });
	        }
	
	        ko.utils.arrayForEach(eventsToCatch, function(eventName) {
	            // The syntax "after<eventname>" means "run the handler asynchronously after the event"
	            // This is useful, for example, to catch "keydown" events after the browser has updated the control
	            // (otherwise, ko.selectExtensions.readValue(this) will receive the control's value *before* the key event)
	            var handler = valueUpdateHandler;
	            if (ko.utils.stringStartsWith(eventName, "after")) {
	                handler = function() {
	                    // The elementValueBeforeEvent variable is non-null *only* during the brief gap between
	                    // a keyX event firing and the valueUpdateHandler running, which is scheduled to happen
	                    // at the earliest asynchronous opportunity. We store this temporary information so that
	                    // if, between keyX and valueUpdateHandler, the underlying model value changes separately,
	                    // we can overwrite that model value change with the value the user just typed. Otherwise,
	                    // techniques like rateLimit can trigger model changes at critical moments that will
	                    // override the user's inputs, causing keystrokes to be lost.
	                    elementValueBeforeEvent = ko.selectExtensions.readValue(element);
	                    ko.utils.setTimeout(valueUpdateHandler, 0);
	                };
	                eventName = eventName.substring("after".length);
	            }
	            ko.utils.registerEventHandler(element, eventName, handler);
	        });
	
	        var updateFromModel = function () {
	            var newValue = ko.utils.unwrapObservable(valueAccessor());
	            var elementValue = ko.selectExtensions.readValue(element);
	
	            if (elementValueBeforeEvent !== null && newValue === elementValueBeforeEvent) {
	                ko.utils.setTimeout(updateFromModel, 0);
	                return;
	            }
	
	            var valueHasChanged = (newValue !== elementValue);
	
	            if (valueHasChanged) {
	                if (ko.utils.tagNameLower(element) === "select") {
	                    var allowUnset = allBindings.get('valueAllowUnset');
	                    var applyValueAction = function () {
	                        ko.selectExtensions.writeValue(element, newValue, allowUnset);
	                    };
	                    applyValueAction();
	
	                    if (!allowUnset && newValue !== ko.selectExtensions.readValue(element)) {
	                        // If you try to set a model value that can't be represented in an already-populated dropdown, reject that change,
	                        // because you're not allowed to have a model value that disagrees with a visible UI selection.
	                        ko.dependencyDetection.ignore(ko.utils.triggerEvent, null, [element, "change"]);
	                    } else {
	                        // Workaround for IE6 bug: It won't reliably apply values to SELECT nodes during the same execution thread
	                        // right after you've changed the set of OPTION nodes on it. So for that node type, we'll schedule a second thread
	                        // to apply the value as well.
	                        ko.utils.setTimeout(applyValueAction, 0);
	                    }
	                } else {
	                    ko.selectExtensions.writeValue(element, newValue);
	                }
	            }
	        };
	
	        ko.computed(updateFromModel, null, { disposeWhenNodeIsRemoved: element });
	    },
	    'update': function() {} // Keep for backwards compatibility with code that may have wrapped value binding
	};
	ko.expressionRewriting.twoWayBindings['value'] = true;
	ko.bindingHandlers['visible'] = {
	    'update': function (element, valueAccessor) {
	        var value = ko.utils.unwrapObservable(valueAccessor());
	        var isCurrentlyVisible = !(element.style.display == "none");
	        if (value && !isCurrentlyVisible)
	            element.style.display = "";
	        else if ((!value) && isCurrentlyVisible)
	            element.style.display = "none";
	    }
	};
	// 'click' is just a shorthand for the usual full-length event:{click:handler}
	makeEventHandlerShortcut('click');
	// If you want to make a custom template engine,
	//
	// [1] Inherit from this class (like ko.nativeTemplateEngine does)
	// [2] Override 'renderTemplateSource', supplying a function with this signature:
	//
	//        function (templateSource, bindingContext, options) {
	//            // - templateSource.text() is the text of the template you should render
	//            // - bindingContext.$data is the data you should pass into the template
	//            //   - you might also want to make bindingContext.$parent, bindingContext.$parents,
	//            //     and bindingContext.$root available in the template too
	//            // - options gives you access to any other properties set on "data-bind: { template: options }"
	//            // - templateDocument is the document object of the template
	//            //
	//            // Return value: an array of DOM nodes
	//        }
	//
	// [3] Override 'createJavaScriptEvaluatorBlock', supplying a function with this signature:
	//
	//        function (script) {
	//            // Return value: Whatever syntax means "Evaluate the JavaScript statement 'script' and output the result"
	//            //               For example, the jquery.tmpl template engine converts 'someScript' to '${ someScript }'
	//        }
	//
	//     This is only necessary if you want to allow data-bind attributes to reference arbitrary template variables.
	//     If you don't want to allow that, you can set the property 'allowTemplateRewriting' to false (like ko.nativeTemplateEngine does)
	//     and then you don't need to override 'createJavaScriptEvaluatorBlock'.
	
	ko.templateEngine = function () { };
	
	ko.templateEngine.prototype['renderTemplateSource'] = function (templateSource, bindingContext, options, templateDocument) {
	    throw new Error("Override renderTemplateSource");
	};
	
	ko.templateEngine.prototype['createJavaScriptEvaluatorBlock'] = function (script) {
	    throw new Error("Override createJavaScriptEvaluatorBlock");
	};
	
	ko.templateEngine.prototype['makeTemplateSource'] = function(template, templateDocument) {
	    // Named template
	    if (typeof template == "string") {
	        templateDocument = templateDocument || document;
	        var elem = templateDocument.getElementById(template);
	        if (!elem)
	            throw new Error("Cannot find template with ID " + template);
	        return new ko.templateSources.domElement(elem);
	    } else if ((template.nodeType == 1) || (template.nodeType == 8)) {
	        // Anonymous template
	        return new ko.templateSources.anonymousTemplate(template);
	    } else
	        throw new Error("Unknown template type: " + template);
	};
	
	ko.templateEngine.prototype['renderTemplate'] = function (template, bindingContext, options, templateDocument) {
	    var templateSource = this['makeTemplateSource'](template, templateDocument);
	    return this['renderTemplateSource'](templateSource, bindingContext, options, templateDocument);
	};
	
	ko.templateEngine.prototype['isTemplateRewritten'] = function (template, templateDocument) {
	    // Skip rewriting if requested
	    if (this['allowTemplateRewriting'] === false)
	        return true;
	    return this['makeTemplateSource'](template, templateDocument)['data']("isRewritten");
	};
	
	ko.templateEngine.prototype['rewriteTemplate'] = function (template, rewriterCallback, templateDocument) {
	    var templateSource = this['makeTemplateSource'](template, templateDocument);
	    var rewritten = rewriterCallback(templateSource['text']());
	    templateSource['text'](rewritten);
	    templateSource['data']("isRewritten", true);
	};
	
	ko.exportSymbol('templateEngine', ko.templateEngine);
	
	ko.templateRewriting = (function () {
	    var memoizeDataBindingAttributeSyntaxRegex = /(<([a-z]+\d*)(?:\s+(?!data-bind\s*=\s*)[a-z0-9\-]+(?:=(?:\"[^\"]*\"|\'[^\']*\'|[^>]*))?)*\s+)data-bind\s*=\s*(["'])([\s\S]*?)\3/gi;
	    var memoizeVirtualContainerBindingSyntaxRegex = /<!--\s*ko\b\s*([\s\S]*?)\s*-->/g;
	
	    function validateDataBindValuesForRewriting(keyValueArray) {
	        var allValidators = ko.expressionRewriting.bindingRewriteValidators;
	        for (var i = 0; i < keyValueArray.length; i++) {
	            var key = keyValueArray[i]['key'];
	            if (allValidators.hasOwnProperty(key)) {
	                var validator = allValidators[key];
	
	                if (typeof validator === "function") {
	                    var possibleErrorMessage = validator(keyValueArray[i]['value']);
	                    if (possibleErrorMessage)
	                        throw new Error(possibleErrorMessage);
	                } else if (!validator) {
	                    throw new Error("This template engine does not support the '" + key + "' binding within its templates");
	                }
	            }
	        }
	    }
	
	    function constructMemoizedTagReplacement(dataBindAttributeValue, tagToRetain, nodeName, templateEngine) {
	        var dataBindKeyValueArray = ko.expressionRewriting.parseObjectLiteral(dataBindAttributeValue);
	        validateDataBindValuesForRewriting(dataBindKeyValueArray);
	        var rewrittenDataBindAttributeValue = ko.expressionRewriting.preProcessBindings(dataBindKeyValueArray, {'valueAccessors':true});
	
	        // For no obvious reason, Opera fails to evaluate rewrittenDataBindAttributeValue unless it's wrapped in an additional
	        // anonymous function, even though Opera's built-in debugger can evaluate it anyway. No other browser requires this
	        // extra indirection.
	        var applyBindingsToNextSiblingScript =
	            "ko.__tr_ambtns(function($context,$element){return(function(){return{ " + rewrittenDataBindAttributeValue + " } })()},'" + nodeName.toLowerCase() + "')";
	        return templateEngine['createJavaScriptEvaluatorBlock'](applyBindingsToNextSiblingScript) + tagToRetain;
	    }
	
	    return {
	        ensureTemplateIsRewritten: function (template, templateEngine, templateDocument) {
	            if (!templateEngine['isTemplateRewritten'](template, templateDocument))
	                templateEngine['rewriteTemplate'](template, function (htmlString) {
	                    return ko.templateRewriting.memoizeBindingAttributeSyntax(htmlString, templateEngine);
	                }, templateDocument);
	        },
	
	        memoizeBindingAttributeSyntax: function (htmlString, templateEngine) {
	            return htmlString.replace(memoizeDataBindingAttributeSyntaxRegex, function () {
	                return constructMemoizedTagReplacement(/* dataBindAttributeValue: */ arguments[4], /* tagToRetain: */ arguments[1], /* nodeName: */ arguments[2], templateEngine);
	            }).replace(memoizeVirtualContainerBindingSyntaxRegex, function() {
	                return constructMemoizedTagReplacement(/* dataBindAttributeValue: */ arguments[1], /* tagToRetain: */ "<!-- ko -->", /* nodeName: */ "#comment", templateEngine);
	            });
	        },
	
	        applyMemoizedBindingsToNextSibling: function (bindings, nodeName) {
	            return ko.memoization.memoize(function (domNode, bindingContext) {
	                var nodeToBind = domNode.nextSibling;
	                if (nodeToBind && nodeToBind.nodeName.toLowerCase() === nodeName) {
	                    ko.applyBindingAccessorsToNode(nodeToBind, bindings, bindingContext);
	                }
	            });
	        }
	    }
	})();
	
	
	// Exported only because it has to be referenced by string lookup from within rewritten template
	ko.exportSymbol('__tr_ambtns', ko.templateRewriting.applyMemoizedBindingsToNextSibling);
	(function() {
	    // A template source represents a read/write way of accessing a template. This is to eliminate the need for template loading/saving
	    // logic to be duplicated in every template engine (and means they can all work with anonymous templates, etc.)
	    //
	    // Two are provided by default:
	    //  1. ko.templateSources.domElement       - reads/writes the text content of an arbitrary DOM element
	    //  2. ko.templateSources.anonymousElement - uses ko.utils.domData to read/write text *associated* with the DOM element, but
	    //                                           without reading/writing the actual element text content, since it will be overwritten
	    //                                           with the rendered template output.
	    // You can implement your own template source if you want to fetch/store templates somewhere other than in DOM elements.
	    // Template sources need to have the following functions:
	    //   text() 			- returns the template text from your storage location
	    //   text(value)		- writes the supplied template text to your storage location
	    //   data(key)			- reads values stored using data(key, value) - see below
	    //   data(key, value)	- associates "value" with this template and the key "key". Is used to store information like "isRewritten".
	    //
	    // Optionally, template sources can also have the following functions:
	    //   nodes()            - returns a DOM element containing the nodes of this template, where available
	    //   nodes(value)       - writes the given DOM element to your storage location
	    // If a DOM element is available for a given template source, template engines are encouraged to use it in preference over text()
	    // for improved speed. However, all templateSources must supply text() even if they don't supply nodes().
	    //
	    // Once you've implemented a templateSource, make your template engine use it by subclassing whatever template engine you were
	    // using and overriding "makeTemplateSource" to return an instance of your custom template source.
	
	    ko.templateSources = {};
	
	    // ---- ko.templateSources.domElement -----
	
	    // template types
	    var templateScript = 1,
	        templateTextArea = 2,
	        templateTemplate = 3,
	        templateElement = 4;
	
	    ko.templateSources.domElement = function(element) {
	        this.domElement = element;
	
	        if (element) {
	            var tagNameLower = ko.utils.tagNameLower(element);
	            this.templateType =
	                tagNameLower === "script" ? templateScript :
	                tagNameLower === "textarea" ? templateTextArea :
	                    // For browsers with proper <template> element support, where the .content property gives a document fragment
	                tagNameLower == "template" && element.content && element.content.nodeType === 11 ? templateTemplate :
	                templateElement;
	        }
	    }
	
	    ko.templateSources.domElement.prototype['text'] = function(/* valueToWrite */) {
	        var elemContentsProperty = this.templateType === templateScript ? "text"
	                                 : this.templateType === templateTextArea ? "value"
	                                 : "innerHTML";
	
	        if (arguments.length == 0) {
	            return this.domElement[elemContentsProperty];
	        } else {
	            var valueToWrite = arguments[0];
	            if (elemContentsProperty === "innerHTML")
	                ko.utils.setHtml(this.domElement, valueToWrite);
	            else
	                this.domElement[elemContentsProperty] = valueToWrite;
	        }
	    };
	
	    var dataDomDataPrefix = ko.utils.domData.nextKey() + "_";
	    ko.templateSources.domElement.prototype['data'] = function(key /*, valueToWrite */) {
	        if (arguments.length === 1) {
	            return ko.utils.domData.get(this.domElement, dataDomDataPrefix + key);
	        } else {
	            ko.utils.domData.set(this.domElement, dataDomDataPrefix + key, arguments[1]);
	        }
	    };
	
	    var templatesDomDataKey = ko.utils.domData.nextKey();
	    function getTemplateDomData(element) {
	        return ko.utils.domData.get(element, templatesDomDataKey) || {};
	    }
	    function setTemplateDomData(element, data) {
	        ko.utils.domData.set(element, templatesDomDataKey, data);
	    }
	
	    ko.templateSources.domElement.prototype['nodes'] = function(/* valueToWrite */) {
	        var element = this.domElement;
	        if (arguments.length == 0) {
	            var templateData = getTemplateDomData(element),
	                containerData = templateData.containerData;
	            return containerData || (
	                this.templateType === templateTemplate ? element.content :
	                this.templateType === templateElement ? element :
	                undefined);
	        } else {
	            var valueToWrite = arguments[0];
	            setTemplateDomData(element, {containerData: valueToWrite});
	        }
	    };
	
	    // ---- ko.templateSources.anonymousTemplate -----
	    // Anonymous templates are normally saved/retrieved as DOM nodes through "nodes".
	    // For compatibility, you can also read "text"; it will be serialized from the nodes on demand.
	    // Writing to "text" is still supported, but then the template data will not be available as DOM nodes.
	
	    ko.templateSources.anonymousTemplate = function(element) {
	        this.domElement = element;
	    }
	    ko.templateSources.anonymousTemplate.prototype = new ko.templateSources.domElement();
	    ko.templateSources.anonymousTemplate.prototype.constructor = ko.templateSources.anonymousTemplate;
	    ko.templateSources.anonymousTemplate.prototype['text'] = function(/* valueToWrite */) {
	        if (arguments.length == 0) {
	            var templateData = getTemplateDomData(this.domElement);
	            if (templateData.textData === undefined && templateData.containerData)
	                templateData.textData = templateData.containerData.innerHTML;
	            return templateData.textData;
	        } else {
	            var valueToWrite = arguments[0];
	            setTemplateDomData(this.domElement, {textData: valueToWrite});
	        }
	    };
	
	    ko.exportSymbol('templateSources', ko.templateSources);
	    ko.exportSymbol('templateSources.domElement', ko.templateSources.domElement);
	    ko.exportSymbol('templateSources.anonymousTemplate', ko.templateSources.anonymousTemplate);
	})();
	(function () {
	    var _templateEngine;
	    ko.setTemplateEngine = function (templateEngine) {
	        if ((templateEngine != undefined) && !(templateEngine instanceof ko.templateEngine))
	            throw new Error("templateEngine must inherit from ko.templateEngine");
	        _templateEngine = templateEngine;
	    }
	
	    function invokeForEachNodeInContinuousRange(firstNode, lastNode, action) {
	        var node, nextInQueue = firstNode, firstOutOfRangeNode = ko.virtualElements.nextSibling(lastNode);
	        while (nextInQueue && ((node = nextInQueue) !== firstOutOfRangeNode)) {
	            nextInQueue = ko.virtualElements.nextSibling(node);
	            action(node, nextInQueue);
	        }
	    }
	
	    function activateBindingsOnContinuousNodeArray(continuousNodeArray, bindingContext) {
	        // To be used on any nodes that have been rendered by a template and have been inserted into some parent element
	        // Walks through continuousNodeArray (which *must* be continuous, i.e., an uninterrupted sequence of sibling nodes, because
	        // the algorithm for walking them relies on this), and for each top-level item in the virtual-element sense,
	        // (1) Does a regular "applyBindings" to associate bindingContext with this node and to activate any non-memoized bindings
	        // (2) Unmemoizes any memos in the DOM subtree (e.g., to activate bindings that had been memoized during template rewriting)
	
	        if (continuousNodeArray.length) {
	            var firstNode = continuousNodeArray[0],
	                lastNode = continuousNodeArray[continuousNodeArray.length - 1],
	                parentNode = firstNode.parentNode,
	                provider = ko.bindingProvider['instance'],
	                preprocessNode = provider['preprocessNode'];
	
	            if (preprocessNode) {
	                invokeForEachNodeInContinuousRange(firstNode, lastNode, function(node, nextNodeInRange) {
	                    var nodePreviousSibling = node.previousSibling;
	                    var newNodes = preprocessNode.call(provider, node);
	                    if (newNodes) {
	                        if (node === firstNode)
	                            firstNode = newNodes[0] || nextNodeInRange;
	                        if (node === lastNode)
	                            lastNode = newNodes[newNodes.length - 1] || nodePreviousSibling;
	                    }
	                });
	
	                // Because preprocessNode can change the nodes, including the first and last nodes, update continuousNodeArray to match.
	                // We need the full set, including inner nodes, because the unmemoize step might remove the first node (and so the real
	                // first node needs to be in the array).
	                continuousNodeArray.length = 0;
	                if (!firstNode) { // preprocessNode might have removed all the nodes, in which case there's nothing left to do
	                    return;
	                }
	                if (firstNode === lastNode) {
	                    continuousNodeArray.push(firstNode);
	                } else {
	                    continuousNodeArray.push(firstNode, lastNode);
	                    ko.utils.fixUpContinuousNodeArray(continuousNodeArray, parentNode);
	                }
	            }
	
	            // Need to applyBindings *before* unmemoziation, because unmemoization might introduce extra nodes (that we don't want to re-bind)
	            // whereas a regular applyBindings won't introduce new memoized nodes
	            invokeForEachNodeInContinuousRange(firstNode, lastNode, function(node) {
	                if (node.nodeType === 1 || node.nodeType === 8)
	                    ko.applyBindings(bindingContext, node);
	            });
	            invokeForEachNodeInContinuousRange(firstNode, lastNode, function(node) {
	                if (node.nodeType === 1 || node.nodeType === 8)
	                    ko.memoization.unmemoizeDomNodeAndDescendants(node, [bindingContext]);
	            });
	
	            // Make sure any changes done by applyBindings or unmemoize are reflected in the array
	            ko.utils.fixUpContinuousNodeArray(continuousNodeArray, parentNode);
	        }
	    }
	
	    function getFirstNodeFromPossibleArray(nodeOrNodeArray) {
	        return nodeOrNodeArray.nodeType ? nodeOrNodeArray
	                                        : nodeOrNodeArray.length > 0 ? nodeOrNodeArray[0]
	                                        : null;
	    }
	
	    function executeTemplate(targetNodeOrNodeArray, renderMode, template, bindingContext, options) {
	        options = options || {};
	        var firstTargetNode = targetNodeOrNodeArray && getFirstNodeFromPossibleArray(targetNodeOrNodeArray);
	        var templateDocument = (firstTargetNode || template || {}).ownerDocument;
	        var templateEngineToUse = (options['templateEngine'] || _templateEngine);
	        ko.templateRewriting.ensureTemplateIsRewritten(template, templateEngineToUse, templateDocument);
	        var renderedNodesArray = templateEngineToUse['renderTemplate'](template, bindingContext, options, templateDocument);
	
	        // Loosely check result is an array of DOM nodes
	        if ((typeof renderedNodesArray.length != "number") || (renderedNodesArray.length > 0 && typeof renderedNodesArray[0].nodeType != "number"))
	            throw new Error("Template engine must return an array of DOM nodes");
	
	        var haveAddedNodesToParent = false;
	        switch (renderMode) {
	            case "replaceChildren":
	                ko.virtualElements.setDomNodeChildren(targetNodeOrNodeArray, renderedNodesArray);
	                haveAddedNodesToParent = true;
	                break;
	            case "replaceNode":
	                ko.utils.replaceDomNodes(targetNodeOrNodeArray, renderedNodesArray);
	                haveAddedNodesToParent = true;
	                break;
	            case "ignoreTargetNode": break;
	            default:
	                throw new Error("Unknown renderMode: " + renderMode);
	        }
	
	        if (haveAddedNodesToParent) {
	            activateBindingsOnContinuousNodeArray(renderedNodesArray, bindingContext);
	            if (options['afterRender'])
	                ko.dependencyDetection.ignore(options['afterRender'], null, [renderedNodesArray, bindingContext['$data']]);
	        }
	
	        return renderedNodesArray;
	    }
	
	    function resolveTemplateName(template, data, context) {
	        // The template can be specified as:
	        if (ko.isObservable(template)) {
	            // 1. An observable, with string value
	            return template();
	        } else if (typeof template === 'function') {
	            // 2. A function of (data, context) returning a string
	            return template(data, context);
	        } else {
	            // 3. A string
	            return template;
	        }
	    }
	
	    ko.renderTemplate = function (template, dataOrBindingContext, options, targetNodeOrNodeArray, renderMode) {
	        options = options || {};
	        if ((options['templateEngine'] || _templateEngine) == undefined)
	            throw new Error("Set a template engine before calling renderTemplate");
	        renderMode = renderMode || "replaceChildren";
	
	        if (targetNodeOrNodeArray) {
	            var firstTargetNode = getFirstNodeFromPossibleArray(targetNodeOrNodeArray);
	
	            var whenToDispose = function () { return (!firstTargetNode) || !ko.utils.domNodeIsAttachedToDocument(firstTargetNode); }; // Passive disposal (on next evaluation)
	            var activelyDisposeWhenNodeIsRemoved = (firstTargetNode && renderMode == "replaceNode") ? firstTargetNode.parentNode : firstTargetNode;
	
	            return ko.dependentObservable( // So the DOM is automatically updated when any dependency changes
	                function () {
	                    // Ensure we've got a proper binding context to work with
	                    var bindingContext = (dataOrBindingContext && (dataOrBindingContext instanceof ko.bindingContext))
	                        ? dataOrBindingContext
	                        : new ko.bindingContext(dataOrBindingContext, null, null, null, { "exportDependencies": true });
	
	                    var templateName = resolveTemplateName(template, bindingContext['$data'], bindingContext),
	                        renderedNodesArray = executeTemplate(targetNodeOrNodeArray, renderMode, templateName, bindingContext, options);
	
	                    if (renderMode == "replaceNode") {
	                        targetNodeOrNodeArray = renderedNodesArray;
	                        firstTargetNode = getFirstNodeFromPossibleArray(targetNodeOrNodeArray);
	                    }
	                },
	                null,
	                { disposeWhen: whenToDispose, disposeWhenNodeIsRemoved: activelyDisposeWhenNodeIsRemoved }
	            );
	        } else {
	            // We don't yet have a DOM node to evaluate, so use a memo and render the template later when there is a DOM node
	            return ko.memoization.memoize(function (domNode) {
	                ko.renderTemplate(template, dataOrBindingContext, options, domNode, "replaceNode");
	            });
	        }
	    };
	
	    ko.renderTemplateForEach = function (template, arrayOrObservableArray, options, targetNode, parentBindingContext) {
	        // Since setDomNodeChildrenFromArrayMapping always calls executeTemplateForArrayItem and then
	        // activateBindingsCallback for added items, we can store the binding context in the former to use in the latter.
	        var arrayItemContext;
	
	        // This will be called by setDomNodeChildrenFromArrayMapping to get the nodes to add to targetNode
	        var executeTemplateForArrayItem = function (arrayValue, index) {
	            // Support selecting template as a function of the data being rendered
	            arrayItemContext = parentBindingContext['createChildContext'](arrayValue, options['as'], function(context) {
	                context['$index'] = index;
	            });
	
	            var templateName = resolveTemplateName(template, arrayValue, arrayItemContext);
	            return executeTemplate(null, "ignoreTargetNode", templateName, arrayItemContext, options);
	        }
	
	        // This will be called whenever setDomNodeChildrenFromArrayMapping has added nodes to targetNode
	        var activateBindingsCallback = function(arrayValue, addedNodesArray, index) {
	            activateBindingsOnContinuousNodeArray(addedNodesArray, arrayItemContext);
	            if (options['afterRender'])
	                options['afterRender'](addedNodesArray, arrayValue);
	
	            // release the "cache" variable, so that it can be collected by
	            // the GC when its value isn't used from within the bindings anymore.
	            arrayItemContext = null;
	        };
	
	        return ko.dependentObservable(function () {
	            var unwrappedArray = ko.utils.unwrapObservable(arrayOrObservableArray) || [];
	            if (typeof unwrappedArray.length == "undefined") // Coerce single value into array
	                unwrappedArray = [unwrappedArray];
	
	            // Filter out any entries marked as destroyed
	            var filteredArray = ko.utils.arrayFilter(unwrappedArray, function(item) {
	                return options['includeDestroyed'] || item === undefined || item === null || !ko.utils.unwrapObservable(item['_destroy']);
	            });
	
	            // Call setDomNodeChildrenFromArrayMapping, ignoring any observables unwrapped within (most likely from a callback function).
	            // If the array items are observables, though, they will be unwrapped in executeTemplateForArrayItem and managed within setDomNodeChildrenFromArrayMapping.
	            ko.dependencyDetection.ignore(ko.utils.setDomNodeChildrenFromArrayMapping, null, [targetNode, filteredArray, executeTemplateForArrayItem, options, activateBindingsCallback]);
	
	        }, null, { disposeWhenNodeIsRemoved: targetNode });
	    };
	
	    var templateComputedDomDataKey = ko.utils.domData.nextKey();
	    function disposeOldComputedAndStoreNewOne(element, newComputed) {
	        var oldComputed = ko.utils.domData.get(element, templateComputedDomDataKey);
	        if (oldComputed && (typeof(oldComputed.dispose) == 'function'))
	            oldComputed.dispose();
	        ko.utils.domData.set(element, templateComputedDomDataKey, (newComputed && newComputed.isActive()) ? newComputed : undefined);
	    }
	
	    ko.bindingHandlers['template'] = {
	        'init': function(element, valueAccessor) {
	            // Support anonymous templates
	            var bindingValue = ko.utils.unwrapObservable(valueAccessor());
	            if (typeof bindingValue == "string" || bindingValue['name']) {
	                // It's a named template - clear the element
	                ko.virtualElements.emptyNode(element);
	            } else if ('nodes' in bindingValue) {
	                // We've been given an array of DOM nodes. Save them as the template source.
	                // There is no known use case for the node array being an observable array (if the output
	                // varies, put that behavior *into* your template - that's what templates are for), and
	                // the implementation would be a mess, so assert that it's not observable.
	                var nodes = bindingValue['nodes'] || [];
	                if (ko.isObservable(nodes)) {
	                    throw new Error('The "nodes" option must be a plain, non-observable array.');
	                }
	                var container = ko.utils.moveCleanedNodesToContainerElement(nodes); // This also removes the nodes from their current parent
	                new ko.templateSources.anonymousTemplate(element)['nodes'](container);
	            } else {
	                // It's an anonymous template - store the element contents, then clear the element
	                var templateNodes = ko.virtualElements.childNodes(element),
	                    container = ko.utils.moveCleanedNodesToContainerElement(templateNodes); // This also removes the nodes from their current parent
	                new ko.templateSources.anonymousTemplate(element)['nodes'](container);
	            }
	            return { 'controlsDescendantBindings': true };
	        },
	        'update': function (element, valueAccessor, allBindings, viewModel, bindingContext) {
	            var value = valueAccessor(),
	                options = ko.utils.unwrapObservable(value),
	                shouldDisplay = true,
	                templateComputed = null,
	                templateName;
	
	            if (typeof options == "string") {
	                templateName = value;
	                options = {};
	            } else {
	                templateName = options['name'];
	
	                // Support "if"/"ifnot" conditions
	                if ('if' in options)
	                    shouldDisplay = ko.utils.unwrapObservable(options['if']);
	                if (shouldDisplay && 'ifnot' in options)
	                    shouldDisplay = !ko.utils.unwrapObservable(options['ifnot']);
	            }
	
	            if ('foreach' in options) {
	                // Render once for each data point (treating data set as empty if shouldDisplay==false)
	                var dataArray = (shouldDisplay && options['foreach']) || [];
	                templateComputed = ko.renderTemplateForEach(templateName || element, dataArray, options, element, bindingContext);
	            } else if (!shouldDisplay) {
	                ko.virtualElements.emptyNode(element);
	            } else {
	                // Render once for this single data point (or use the viewModel if no data was provided)
	                var innerBindingContext = ('data' in options) ?
	                    bindingContext.createStaticChildContext(options['data'], options['as']) :  // Given an explitit 'data' value, we create a child binding context for it
	                    bindingContext;                                                        // Given no explicit 'data' value, we retain the same binding context
	                templateComputed = ko.renderTemplate(templateName || element, innerBindingContext, options, element);
	            }
	
	            // It only makes sense to have a single template computed per element (otherwise which one should have its output displayed?)
	            disposeOldComputedAndStoreNewOne(element, templateComputed);
	        }
	    };
	
	    // Anonymous templates can't be rewritten. Give a nice error message if you try to do it.
	    ko.expressionRewriting.bindingRewriteValidators['template'] = function(bindingValue) {
	        var parsedBindingValue = ko.expressionRewriting.parseObjectLiteral(bindingValue);
	
	        if ((parsedBindingValue.length == 1) && parsedBindingValue[0]['unknown'])
	            return null; // It looks like a string literal, not an object literal, so treat it as a named template (which is allowed for rewriting)
	
	        if (ko.expressionRewriting.keyValueArrayContainsKey(parsedBindingValue, "name"))
	            return null; // Named templates can be rewritten, so return "no error"
	        return "This template engine does not support anonymous templates nested within its templates";
	    };
	
	    ko.virtualElements.allowedBindings['template'] = true;
	})();
	
	ko.exportSymbol('setTemplateEngine', ko.setTemplateEngine);
	ko.exportSymbol('renderTemplate', ko.renderTemplate);
	// Go through the items that have been added and deleted and try to find matches between them.
	ko.utils.findMovesInArrayComparison = function (left, right, limitFailedCompares) {
	    if (left.length && right.length) {
	        var failedCompares, l, r, leftItem, rightItem;
	        for (failedCompares = l = 0; (!limitFailedCompares || failedCompares < limitFailedCompares) && (leftItem = left[l]); ++l) {
	            for (r = 0; rightItem = right[r]; ++r) {
	                if (leftItem['value'] === rightItem['value']) {
	                    leftItem['moved'] = rightItem['index'];
	                    rightItem['moved'] = leftItem['index'];
	                    right.splice(r, 1);         // This item is marked as moved; so remove it from right list
	                    failedCompares = r = 0;     // Reset failed compares count because we're checking for consecutive failures
	                    break;
	                }
	            }
	            failedCompares += r;
	        }
	    }
	};
	
	ko.utils.compareArrays = (function () {
	    var statusNotInOld = 'added', statusNotInNew = 'deleted';
	
	    // Simple calculation based on Levenshtein distance.
	    function compareArrays(oldArray, newArray, options) {
	        // For backward compatibility, if the third arg is actually a bool, interpret
	        // it as the old parameter 'dontLimitMoves'. Newer code should use { dontLimitMoves: true }.
	        options = (typeof options === 'boolean') ? { 'dontLimitMoves': options } : (options || {});
	        oldArray = oldArray || [];
	        newArray = newArray || [];
	
	        if (oldArray.length < newArray.length)
	            return compareSmallArrayToBigArray(oldArray, newArray, statusNotInOld, statusNotInNew, options);
	        else
	            return compareSmallArrayToBigArray(newArray, oldArray, statusNotInNew, statusNotInOld, options);
	    }
	
	    function compareSmallArrayToBigArray(smlArray, bigArray, statusNotInSml, statusNotInBig, options) {
	        var myMin = Math.min,
	            myMax = Math.max,
	            editDistanceMatrix = [],
	            smlIndex, smlIndexMax = smlArray.length,
	            bigIndex, bigIndexMax = bigArray.length,
	            compareRange = (bigIndexMax - smlIndexMax) || 1,
	            maxDistance = smlIndexMax + bigIndexMax + 1,
	            thisRow, lastRow,
	            bigIndexMaxForRow, bigIndexMinForRow;
	
	        for (smlIndex = 0; smlIndex <= smlIndexMax; smlIndex++) {
	            lastRow = thisRow;
	            editDistanceMatrix.push(thisRow = []);
	            bigIndexMaxForRow = myMin(bigIndexMax, smlIndex + compareRange);
	            bigIndexMinForRow = myMax(0, smlIndex - 1);
	            for (bigIndex = bigIndexMinForRow; bigIndex <= bigIndexMaxForRow; bigIndex++) {
	                if (!bigIndex)
	                    thisRow[bigIndex] = smlIndex + 1;
	                else if (!smlIndex)  // Top row - transform empty array into new array via additions
	                    thisRow[bigIndex] = bigIndex + 1;
	                else if (smlArray[smlIndex - 1] === bigArray[bigIndex - 1])
	                    thisRow[bigIndex] = lastRow[bigIndex - 1];                  // copy value (no edit)
	                else {
	                    var northDistance = lastRow[bigIndex] || maxDistance;       // not in big (deletion)
	                    var westDistance = thisRow[bigIndex - 1] || maxDistance;    // not in small (addition)
	                    thisRow[bigIndex] = myMin(northDistance, westDistance) + 1;
	                }
	            }
	        }
	
	        var editScript = [], meMinusOne, notInSml = [], notInBig = [];
	        for (smlIndex = smlIndexMax, bigIndex = bigIndexMax; smlIndex || bigIndex;) {
	            meMinusOne = editDistanceMatrix[smlIndex][bigIndex] - 1;
	            if (bigIndex && meMinusOne === editDistanceMatrix[smlIndex][bigIndex-1]) {
	                notInSml.push(editScript[editScript.length] = {     // added
	                    'status': statusNotInSml,
	                    'value': bigArray[--bigIndex],
	                    'index': bigIndex });
	            } else if (smlIndex && meMinusOne === editDistanceMatrix[smlIndex - 1][bigIndex]) {
	                notInBig.push(editScript[editScript.length] = {     // deleted
	                    'status': statusNotInBig,
	                    'value': smlArray[--smlIndex],
	                    'index': smlIndex });
	            } else {
	                --bigIndex;
	                --smlIndex;
	                if (!options['sparse']) {
	                    editScript.push({
	                        'status': "retained",
	                        'value': bigArray[bigIndex] });
	                }
	            }
	        }
	
	        // Set a limit on the number of consecutive non-matching comparisons; having it a multiple of
	        // smlIndexMax keeps the time complexity of this algorithm linear.
	        ko.utils.findMovesInArrayComparison(notInBig, notInSml, !options['dontLimitMoves'] && smlIndexMax * 10);
	
	        return editScript.reverse();
	    }
	
	    return compareArrays;
	})();
	
	ko.exportSymbol('utils.compareArrays', ko.utils.compareArrays);
	(function () {
	    // Objective:
	    // * Given an input array, a container DOM node, and a function from array elements to arrays of DOM nodes,
	    //   map the array elements to arrays of DOM nodes, concatenate together all these arrays, and use them to populate the container DOM node
	    // * Next time we're given the same combination of things (with the array possibly having mutated), update the container DOM node
	    //   so that its children is again the concatenation of the mappings of the array elements, but don't re-map any array elements that we
	    //   previously mapped - retain those nodes, and just insert/delete other ones
	
	    // "callbackAfterAddingNodes" will be invoked after any "mapping"-generated nodes are inserted into the container node
	    // You can use this, for example, to activate bindings on those nodes.
	
	    function mapNodeAndRefreshWhenChanged(containerNode, mapping, valueToMap, callbackAfterAddingNodes, index) {
	        // Map this array value inside a dependentObservable so we re-map when any dependency changes
	        var mappedNodes = [];
	        var dependentObservable = ko.dependentObservable(function() {
	            var newMappedNodes = mapping(valueToMap, index, ko.utils.fixUpContinuousNodeArray(mappedNodes, containerNode)) || [];
	
	            // On subsequent evaluations, just replace the previously-inserted DOM nodes
	            if (mappedNodes.length > 0) {
	                ko.utils.replaceDomNodes(mappedNodes, newMappedNodes);
	                if (callbackAfterAddingNodes)
	                    ko.dependencyDetection.ignore(callbackAfterAddingNodes, null, [valueToMap, newMappedNodes, index]);
	            }
	
	            // Replace the contents of the mappedNodes array, thereby updating the record
	            // of which nodes would be deleted if valueToMap was itself later removed
	            mappedNodes.length = 0;
	            ko.utils.arrayPushAll(mappedNodes, newMappedNodes);
	        }, null, { disposeWhenNodeIsRemoved: containerNode, disposeWhen: function() { return !ko.utils.anyDomNodeIsAttachedToDocument(mappedNodes); } });
	        return { mappedNodes : mappedNodes, dependentObservable : (dependentObservable.isActive() ? dependentObservable : undefined) };
	    }
	
	    var lastMappingResultDomDataKey = ko.utils.domData.nextKey(),
	        deletedItemDummyValue = ko.utils.domData.nextKey();
	
	    ko.utils.setDomNodeChildrenFromArrayMapping = function (domNode, array, mapping, options, callbackAfterAddingNodes) {
	        // Compare the provided array against the previous one
	        array = array || [];
	        options = options || {};
	        var isFirstExecution = ko.utils.domData.get(domNode, lastMappingResultDomDataKey) === undefined;
	        var lastMappingResult = ko.utils.domData.get(domNode, lastMappingResultDomDataKey) || [];
	        var lastArray = ko.utils.arrayMap(lastMappingResult, function (x) { return x.arrayEntry; });
	        var editScript = ko.utils.compareArrays(lastArray, array, options['dontLimitMoves']);
	
	        // Build the new mapping result
	        var newMappingResult = [];
	        var lastMappingResultIndex = 0;
	        var newMappingResultIndex = 0;
	
	        var nodesToDelete = [];
	        var itemsToProcess = [];
	        var itemsForBeforeRemoveCallbacks = [];
	        var itemsForMoveCallbacks = [];
	        var itemsForAfterAddCallbacks = [];
	        var mapData;
	
	        function itemMovedOrRetained(editScriptIndex, oldPosition) {
	            mapData = lastMappingResult[oldPosition];
	            if (newMappingResultIndex !== oldPosition)
	                itemsForMoveCallbacks[editScriptIndex] = mapData;
	            // Since updating the index might change the nodes, do so before calling fixUpContinuousNodeArray
	            mapData.indexObservable(newMappingResultIndex++);
	            ko.utils.fixUpContinuousNodeArray(mapData.mappedNodes, domNode);
	            newMappingResult.push(mapData);
	            itemsToProcess.push(mapData);
	        }
	
	        function callCallback(callback, items) {
	            if (callback) {
	                for (var i = 0, n = items.length; i < n; i++) {
	                    if (items[i]) {
	                        ko.utils.arrayForEach(items[i].mappedNodes, function(node) {
	                            callback(node, i, items[i].arrayEntry);
	                        });
	                    }
	                }
	            }
	        }
	
	        for (var i = 0, editScriptItem, movedIndex; editScriptItem = editScript[i]; i++) {
	            movedIndex = editScriptItem['moved'];
	            switch (editScriptItem['status']) {
	                case "deleted":
	                    if (movedIndex === undefined) {
	                        mapData = lastMappingResult[lastMappingResultIndex];
	
	                        // Stop tracking changes to the mapping for these nodes
	                        if (mapData.dependentObservable) {
	                            mapData.dependentObservable.dispose();
	                            mapData.dependentObservable = undefined;
	                        }
	
	                        // Queue these nodes for later removal
	                        if (ko.utils.fixUpContinuousNodeArray(mapData.mappedNodes, domNode).length) {
	                            if (options['beforeRemove']) {
	                                newMappingResult.push(mapData);
	                                itemsToProcess.push(mapData);
	                                if (mapData.arrayEntry === deletedItemDummyValue) {
	                                    mapData = null;
	                                } else {
	                                    itemsForBeforeRemoveCallbacks[i] = mapData;
	                                }
	                            }
	                            if (mapData) {
	                                nodesToDelete.push.apply(nodesToDelete, mapData.mappedNodes);
	                            }
	                        }
	                    }
	                    lastMappingResultIndex++;
	                    break;
	
	                case "retained":
	                    itemMovedOrRetained(i, lastMappingResultIndex++);
	                    break;
	
	                case "added":
	                    if (movedIndex !== undefined) {
	                        itemMovedOrRetained(i, movedIndex);
	                    } else {
	                        mapData = { arrayEntry: editScriptItem['value'], indexObservable: ko.observable(newMappingResultIndex++) };
	                        newMappingResult.push(mapData);
	                        itemsToProcess.push(mapData);
	                        if (!isFirstExecution)
	                            itemsForAfterAddCallbacks[i] = mapData;
	                    }
	                    break;
	            }
	        }
	
	        // Store a copy of the array items we just considered so we can difference it next time
	        ko.utils.domData.set(domNode, lastMappingResultDomDataKey, newMappingResult);
	
	        // Call beforeMove first before any changes have been made to the DOM
	        callCallback(options['beforeMove'], itemsForMoveCallbacks);
	
	        // Next remove nodes for deleted items (or just clean if there's a beforeRemove callback)
	        ko.utils.arrayForEach(nodesToDelete, options['beforeRemove'] ? ko.cleanNode : ko.removeNode);
	
	        // Next add/reorder the remaining items (will include deleted items if there's a beforeRemove callback)
	        for (var i = 0, nextNode = ko.virtualElements.firstChild(domNode), lastNode, node; mapData = itemsToProcess[i]; i++) {
	            // Get nodes for newly added items
	            if (!mapData.mappedNodes)
	                ko.utils.extend(mapData, mapNodeAndRefreshWhenChanged(domNode, mapping, mapData.arrayEntry, callbackAfterAddingNodes, mapData.indexObservable));
	
	            // Put nodes in the right place if they aren't there already
	            for (var j = 0; node = mapData.mappedNodes[j]; nextNode = node.nextSibling, lastNode = node, j++) {
	                if (node !== nextNode)
	                    ko.virtualElements.insertAfter(domNode, node, lastNode);
	            }
	
	            // Run the callbacks for newly added nodes (for example, to apply bindings, etc.)
	            if (!mapData.initialized && callbackAfterAddingNodes) {
	                callbackAfterAddingNodes(mapData.arrayEntry, mapData.mappedNodes, mapData.indexObservable);
	                mapData.initialized = true;
	            }
	        }
	
	        // If there's a beforeRemove callback, call it after reordering.
	        // Note that we assume that the beforeRemove callback will usually be used to remove the nodes using
	        // some sort of animation, which is why we first reorder the nodes that will be removed. If the
	        // callback instead removes the nodes right away, it would be more efficient to skip reordering them.
	        // Perhaps we'll make that change in the future if this scenario becomes more common.
	        callCallback(options['beforeRemove'], itemsForBeforeRemoveCallbacks);
	
	        // Replace the stored values of deleted items with a dummy value. This provides two benefits: it marks this item
	        // as already "removed" so we won't call beforeRemove for it again, and it ensures that the item won't match up
	        // with an actual item in the array and appear as "retained" or "moved".
	        for (i = 0; i < itemsForBeforeRemoveCallbacks.length; ++i) {
	            if (itemsForBeforeRemoveCallbacks[i]) {
	                itemsForBeforeRemoveCallbacks[i].arrayEntry = deletedItemDummyValue;
	            }
	        }
	
	        // Finally call afterMove and afterAdd callbacks
	        callCallback(options['afterMove'], itemsForMoveCallbacks);
	        callCallback(options['afterAdd'], itemsForAfterAddCallbacks);
	    }
	})();
	
	ko.exportSymbol('utils.setDomNodeChildrenFromArrayMapping', ko.utils.setDomNodeChildrenFromArrayMapping);
	ko.nativeTemplateEngine = function () {
	    this['allowTemplateRewriting'] = false;
	}
	
	ko.nativeTemplateEngine.prototype = new ko.templateEngine();
	ko.nativeTemplateEngine.prototype.constructor = ko.nativeTemplateEngine;
	ko.nativeTemplateEngine.prototype['renderTemplateSource'] = function (templateSource, bindingContext, options, templateDocument) {
	    var useNodesIfAvailable = !(ko.utils.ieVersion < 9), // IE<9 cloneNode doesn't work properly
	        templateNodesFunc = useNodesIfAvailable ? templateSource['nodes'] : null,
	        templateNodes = templateNodesFunc ? templateSource['nodes']() : null;
	
	    if (templateNodes) {
	        return ko.utils.makeArray(templateNodes.cloneNode(true).childNodes);
	    } else {
	        var templateText = templateSource['text']();
	        return ko.utils.parseHtmlFragment(templateText, templateDocument);
	    }
	};
	
	ko.nativeTemplateEngine.instance = new ko.nativeTemplateEngine();
	ko.setTemplateEngine(ko.nativeTemplateEngine.instance);
	
	ko.exportSymbol('nativeTemplateEngine', ko.nativeTemplateEngine);
	(function() {
	    ko.jqueryTmplTemplateEngine = function () {
	        // Detect which version of jquery-tmpl you're using. Unfortunately jquery-tmpl
	        // doesn't expose a version number, so we have to infer it.
	        // Note that as of Knockout 1.3, we only support jQuery.tmpl 1.0.0pre and later,
	        // which KO internally refers to as version "2", so older versions are no longer detected.
	        var jQueryTmplVersion = this.jQueryTmplVersion = (function() {
	            if (!jQueryInstance || !(jQueryInstance['tmpl']))
	                return 0;
	            // Since it exposes no official version number, we use our own numbering system. To be updated as jquery-tmpl evolves.
	            try {
	                if (jQueryInstance['tmpl']['tag']['tmpl']['open'].toString().indexOf('__') >= 0) {
	                    // Since 1.0.0pre, custom tags should append markup to an array called "__"
	                    return 2; // Final version of jquery.tmpl
	                }
	            } catch(ex) { /* Apparently not the version we were looking for */ }
	
	            return 1; // Any older version that we don't support
	        })();
	
	        function ensureHasReferencedJQueryTemplates() {
	            if (jQueryTmplVersion < 2)
	                throw new Error("Your version of jQuery.tmpl is too old. Please upgrade to jQuery.tmpl 1.0.0pre or later.");
	        }
	
	        function executeTemplate(compiledTemplate, data, jQueryTemplateOptions) {
	            return jQueryInstance['tmpl'](compiledTemplate, data, jQueryTemplateOptions);
	        }
	
	        this['renderTemplateSource'] = function(templateSource, bindingContext, options, templateDocument) {
	            templateDocument = templateDocument || document;
	            options = options || {};
	            ensureHasReferencedJQueryTemplates();
	
	            // Ensure we have stored a precompiled version of this template (don't want to reparse on every render)
	            var precompiled = templateSource['data']('precompiled');
	            if (!precompiled) {
	                var templateText = templateSource['text']() || "";
	                // Wrap in "with($whatever.koBindingContext) { ... }"
	                templateText = "{{ko_with $item.koBindingContext}}" + templateText + "{{/ko_with}}";
	
	                precompiled = jQueryInstance['template'](null, templateText);
	                templateSource['data']('precompiled', precompiled);
	            }
	
	            var data = [bindingContext['$data']]; // Prewrap the data in an array to stop jquery.tmpl from trying to unwrap any arrays
	            var jQueryTemplateOptions = jQueryInstance['extend']({ 'koBindingContext': bindingContext }, options['templateOptions']);
	
	            var resultNodes = executeTemplate(precompiled, data, jQueryTemplateOptions);
	            resultNodes['appendTo'](templateDocument.createElement("div")); // Using "appendTo" forces jQuery/jQuery.tmpl to perform necessary cleanup work
	
	            jQueryInstance['fragments'] = {}; // Clear jQuery's fragment cache to avoid a memory leak after a large number of template renders
	            return resultNodes;
	        };
	
	        this['createJavaScriptEvaluatorBlock'] = function(script) {
	            return "{{ko_code ((function() { return " + script + " })()) }}";
	        };
	
	        this['addTemplate'] = function(templateName, templateMarkup) {
	            document.write("<script type='text/html' id='" + templateName + "'>" + templateMarkup + "<" + "/script>");
	        };
	
	        if (jQueryTmplVersion > 0) {
	            jQueryInstance['tmpl']['tag']['ko_code'] = {
	                open: "__.push($1 || '');"
	            };
	            jQueryInstance['tmpl']['tag']['ko_with'] = {
	                open: "with($1) {",
	                close: "} "
	            };
	        }
	    };
	
	    ko.jqueryTmplTemplateEngine.prototype = new ko.templateEngine();
	    ko.jqueryTmplTemplateEngine.prototype.constructor = ko.jqueryTmplTemplateEngine;
	
	    // Use this one by default *only if jquery.tmpl is referenced*
	    var jqueryTmplTemplateEngineInstance = new ko.jqueryTmplTemplateEngine();
	    if (jqueryTmplTemplateEngineInstance.jQueryTmplVersion > 0)
	        ko.setTemplateEngine(jqueryTmplTemplateEngineInstance);
	
	    ko.exportSymbol('jqueryTmplTemplateEngine', ko.jqueryTmplTemplateEngine);
	})();
	}));
	}());
	})();
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)(module)))

/***/ },
/* 95 */
/***/ function(module, exports) {

	module.exports = function() { throw new Error("define cannot be used indirect"); };


/***/ },
/* 96 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*globals jQuery, define, module, exports, require, window, document, postMessage */
	(function (factory) {
		"use strict";
		if (true) {
			!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(2)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
		}
		else if(typeof module !== 'undefined' && module.exports) {
			module.exports = factory(require('jquery'));
		}
		else {
			factory(jQuery);
		}
	}(function ($, undefined) {
		"use strict";
	/*!
	 * jsTree 3.3.3
	 * http://jstree.com/
	 *
	 * Copyright (c) 2014 Ivan Bozhanov (http://vakata.com)
	 *
	 * Licensed same as jquery - under the terms of the MIT License
	 *   http://www.opensource.org/licenses/mit-license.php
	 */
	/*!
	 * if using jslint please allow for the jQuery global and use following options:
	 * jslint: loopfunc: true, browser: true, ass: true, bitwise: true, continue: true, nomen: true, plusplus: true, regexp: true, unparam: true, todo: true, white: true
	 */
	/*jshint -W083 */
	
		// prevent another load? maybe there is a better way?
		if($.jstree) {
			return;
		}
	
		/**
		 * ### jsTree core functionality
		 */
	
		// internal variables
		var instance_counter = 0,
			ccp_node = false,
			ccp_mode = false,
			ccp_inst = false,
			themes_loaded = [],
			src = $('script:last').attr('src'),
			document = window.document; // local variable is always faster to access then a global
	
		/**
		 * holds all jstree related functions and variables, including the actual class and methods to create, access and manipulate instances.
		 * @name $.jstree
		 */
		$.jstree = {
			/**
			 * specifies the jstree version in use
			 * @name $.jstree.version
			 */
			version : '3.3.3',
			/**
			 * holds all the default options used when creating new instances
			 * @name $.jstree.defaults
			 */
			defaults : {
				/**
				 * configure which plugins will be active on an instance. Should be an array of strings, where each element is a plugin name. The default is `[]`
				 * @name $.jstree.defaults.plugins
				 */
				plugins : []
			},
			/**
			 * stores all loaded jstree plugins (used internally)
			 * @name $.jstree.plugins
			 */
			plugins : {},
			path : src && src.indexOf('/') !== -1 ? src.replace(/\/[^\/]+$/,'') : '',
			idregex : /[\\:&!^|()\[\]<>@*'+~#";.,=\- \/${}%?`]/g,
			root : '#'
		};
		
		/**
		 * creates a jstree instance
		 * @name $.jstree.create(el [, options])
		 * @param {DOMElement|jQuery|String} el the element to create the instance on, can be jQuery extended or a selector
		 * @param {Object} options options for this instance (extends `$.jstree.defaults`)
		 * @return {jsTree} the new instance
		 */
		$.jstree.create = function (el, options) {
			var tmp = new $.jstree.core(++instance_counter),
				opt = options;
			options = $.extend(true, {}, $.jstree.defaults, options);
			if(opt && opt.plugins) {
				options.plugins = opt.plugins;
			}
			$.each(options.plugins, function (i, k) {
				if(i !== 'core') {
					tmp = tmp.plugin(k, options[k]);
				}
			});
			$(el).data('jstree', tmp);
			tmp.init(el, options);
			return tmp;
		};
		/**
		 * remove all traces of jstree from the DOM and destroy all instances
		 * @name $.jstree.destroy()
		 */
		$.jstree.destroy = function () {
			$('.jstree:jstree').jstree('destroy');
			$(document).off('.jstree');
		};
		/**
		 * the jstree class constructor, used only internally
		 * @private
		 * @name $.jstree.core(id)
		 * @param {Number} id this instance's index
		 */
		$.jstree.core = function (id) {
			this._id = id;
			this._cnt = 0;
			this._wrk = null;
			this._data = {
				core : {
					themes : {
						name : false,
						dots : false,
						icons : false,
						ellipsis : false
					},
					selected : [],
					last_error : {},
					working : false,
					worker_queue : [],
					focused : null
				}
			};
		};
		/**
		 * get a reference to an existing instance
		 *
		 * __Examples__
		 *
		 *	// provided a container with an ID of "tree", and a nested node with an ID of "branch"
		 *	// all of there will return the same instance
		 *	$.jstree.reference('tree');
		 *	$.jstree.reference('#tree');
		 *	$.jstree.reference($('#tree'));
		 *	$.jstree.reference(document.getElementByID('tree'));
		 *	$.jstree.reference('branch');
		 *	$.jstree.reference('#branch');
		 *	$.jstree.reference($('#branch'));
		 *	$.jstree.reference(document.getElementByID('branch'));
		 *
		 * @name $.jstree.reference(needle)
		 * @param {DOMElement|jQuery|String} needle
		 * @return {jsTree|null} the instance or `null` if not found
		 */
		$.jstree.reference = function (needle) {
			var tmp = null,
				obj = null;
			if(needle && needle.id && (!needle.tagName || !needle.nodeType)) { needle = needle.id; }
	
			if(!obj || !obj.length) {
				try { obj = $(needle); } catch (ignore) { }
			}
			if(!obj || !obj.length) {
				try { obj = $('#' + needle.replace($.jstree.idregex,'\\$&')); } catch (ignore) { }
			}
			if(obj && obj.length && (obj = obj.closest('.jstree')).length && (obj = obj.data('jstree'))) {
				tmp = obj;
			}
			else {
				$('.jstree').each(function () {
					var inst = $(this).data('jstree');
					if(inst && inst._model.data[needle]) {
						tmp = inst;
						return false;
					}
				});
			}
			return tmp;
		};
		/**
		 * Create an instance, get an instance or invoke a command on a instance.
		 *
		 * If there is no instance associated with the current node a new one is created and `arg` is used to extend `$.jstree.defaults` for this new instance. There would be no return value (chaining is not broken).
		 *
		 * If there is an existing instance and `arg` is a string the command specified by `arg` is executed on the instance, with any additional arguments passed to the function. If the function returns a value it will be returned (chaining could break depending on function).
		 *
		 * If there is an existing instance and `arg` is not a string the instance itself is returned (similar to `$.jstree.reference`).
		 *
		 * In any other case - nothing is returned and chaining is not broken.
		 *
		 * __Examples__
		 *
		 *	$('#tree1').jstree(); // creates an instance
		 *	$('#tree2').jstree({ plugins : [] }); // create an instance with some options
		 *	$('#tree1').jstree('open_node', '#branch_1'); // call a method on an existing instance, passing additional arguments
		 *	$('#tree2').jstree(); // get an existing instance (or create an instance)
		 *	$('#tree2').jstree(true); // get an existing instance (will not create new instance)
		 *	$('#branch_1').jstree().select_node('#branch_1'); // get an instance (using a nested element and call a method)
		 *
		 * @name $().jstree([arg])
		 * @param {String|Object} arg
		 * @return {Mixed}
		 */
		$.fn.jstree = function (arg) {
			// check for string argument
			var is_method	= (typeof arg === 'string'),
				args		= Array.prototype.slice.call(arguments, 1),
				result		= null;
			if(arg === true && !this.length) { return false; }
			this.each(function () {
				// get the instance (if there is one) and method (if it exists)
				var instance = $.jstree.reference(this),
					method = is_method && instance ? instance[arg] : null;
				// if calling a method, and method is available - execute on the instance
				result = is_method && method ?
					method.apply(instance, args) :
					null;
				// if there is no instance and no method is being called - create one
				if(!instance && !is_method && (arg === undefined || $.isPlainObject(arg))) {
					$.jstree.create(this, arg);
				}
				// if there is an instance and no method is called - return the instance
				if( (instance && !is_method) || arg === true ) {
					result = instance || false;
				}
				// if there was a method call which returned a result - break and return the value
				if(result !== null && result !== undefined) {
					return false;
				}
			});
			// if there was a method call with a valid return value - return that, otherwise continue the chain
			return result !== null && result !== undefined ?
				result : this;
		};
		/**
		 * used to find elements containing an instance
		 *
		 * __Examples__
		 *
		 *	$('div:jstree').each(function () {
		 *		$(this).jstree('destroy');
		 *	});
		 *
		 * @name $(':jstree')
		 * @return {jQuery}
		 */
		$.expr.pseudos.jstree = $.expr.createPseudo(function(search) {
			return function(a) {
				return $(a).hasClass('jstree') &&
					$(a).data('jstree') !== undefined;
			};
		});
	
		/**
		 * stores all defaults for the core
		 * @name $.jstree.defaults.core
		 */
		$.jstree.defaults.core = {
			/**
			 * data configuration
			 *
			 * If left as `false` the HTML inside the jstree container element is used to populate the tree (that should be an unordered list with list items).
			 *
			 * You can also pass in a HTML string or a JSON array here.
			 *
			 * It is possible to pass in a standard jQuery-like AJAX config and jstree will automatically determine if the response is JSON or HTML and use that to populate the tree.
			 * In addition to the standard jQuery ajax options here you can suppy functions for `data` and `url`, the functions will be run in the current instance's scope and a param will be passed indicating which node is being loaded, the return value of those functions will be used.
			 *
			 * The last option is to specify a function, that function will receive the node being loaded as argument and a second param which is a function which should be called with the result.
			 *
			 * __Examples__
			 *
			 *	// AJAX
			 *	$('#tree').jstree({
			 *		'core' : {
			 *			'data' : {
			 *				'url' : '/get/children/',
			 *				'data' : function (node) {
			 *					return { 'id' : node.id };
			 *				}
			 *			}
			 *		});
			 *
			 *	// direct data
			 *	$('#tree').jstree({
			 *		'core' : {
			 *			'data' : [
			 *				'Simple root node',
			 *				{
			 *					'id' : 'node_2',
			 *					'text' : 'Root node with options',
			 *					'state' : { 'opened' : true, 'selected' : true },
			 *					'children' : [ { 'text' : 'Child 1' }, 'Child 2']
			 *				}
			 *			]
			 *		}
			 *	});
			 *
			 *	// function
			 *	$('#tree').jstree({
			 *		'core' : {
			 *			'data' : function (obj, callback) {
			 *				callback.call(this, ['Root 1', 'Root 2']);
			 *			}
			 *		});
			 *
			 * @name $.jstree.defaults.core.data
			 */
			data			: false,
			/**
			 * configure the various strings used throughout the tree
			 *
			 * You can use an object where the key is the string you need to replace and the value is your replacement.
			 * Another option is to specify a function which will be called with an argument of the needed string and should return the replacement.
			 * If left as `false` no replacement is made.
			 *
			 * __Examples__
			 *
			 *	$('#tree').jstree({
			 *		'core' : {
			 *			'strings' : {
			 *				'Loading ...' : 'Please wait ...'
			 *			}
			 *		}
			 *	});
			 *
			 * @name $.jstree.defaults.core.strings
			 */
			strings			: false,
			/**
			 * determines what happens when a user tries to modify the structure of the tree
			 * If left as `false` all operations like create, rename, delete, move or copy are prevented.
			 * You can set this to `true` to allow all interactions or use a function to have better control.
			 *
			 * __Examples__
			 *
			 *	$('#tree').jstree({
			 *		'core' : {
			 *			'check_callback' : function (operation, node, node_parent, node_position, more) {
			 *				// operation can be 'create_node', 'rename_node', 'delete_node', 'move_node' or 'copy_node'
			 *				// in case of 'rename_node' node_position is filled with the new node name
			 *				return operation === 'rename_node' ? true : false;
			 *			}
			 *		}
			 *	});
			 *
			 * @name $.jstree.defaults.core.check_callback
			 */
			check_callback	: false,
			/**
			 * a callback called with a single object parameter in the instance's scope when something goes wrong (operation prevented, ajax failed, etc)
			 * @name $.jstree.defaults.core.error
			 */
			error			: $.noop,
			/**
			 * the open / close animation duration in milliseconds - set this to `false` to disable the animation (default is `200`)
			 * @name $.jstree.defaults.core.animation
			 */
			animation		: 200,
			/**
			 * a boolean indicating if multiple nodes can be selected
			 * @name $.jstree.defaults.core.multiple
			 */
			multiple		: true,
			/**
			 * theme configuration object
			 * @name $.jstree.defaults.core.themes
			 */
			themes			: {
				/**
				 * the name of the theme to use (if left as `false` the default theme is used)
				 * @name $.jstree.defaults.core.themes.name
				 */
				name			: false,
				/**
				 * the URL of the theme's CSS file, leave this as `false` if you have manually included the theme CSS (recommended). You can set this to `true` too which will try to autoload the theme.
				 * @name $.jstree.defaults.core.themes.url
				 */
				url				: false,
				/**
				 * the location of all jstree themes - only used if `url` is set to `true`
				 * @name $.jstree.defaults.core.themes.dir
				 */
				dir				: false,
				/**
				 * a boolean indicating if connecting dots are shown
				 * @name $.jstree.defaults.core.themes.dots
				 */
				dots			: true,
				/**
				 * a boolean indicating if node icons are shown
				 * @name $.jstree.defaults.core.themes.icons
				 */
				icons			: true,
				/**
				 * a boolean indicating if node ellipsis should be shown - this only works with a fixed with on the container
				 * @name $.jstree.defaults.core.themes.ellipsis
				 */
				ellipsis		: false,
				/**
				 * a boolean indicating if the tree background is striped
				 * @name $.jstree.defaults.core.themes.stripes
				 */
				stripes			: false,
				/**
				 * a string (or boolean `false`) specifying the theme variant to use (if the theme supports variants)
				 * @name $.jstree.defaults.core.themes.variant
				 */
				variant			: false,
				/**
				 * a boolean specifying if a reponsive version of the theme should kick in on smaller screens (if the theme supports it). Defaults to `false`.
				 * @name $.jstree.defaults.core.themes.responsive
				 */
				responsive		: false
			},
			/**
			 * if left as `true` all parents of all selected nodes will be opened once the tree loads (so that all selected nodes are visible to the user)
			 * @name $.jstree.defaults.core.expand_selected_onload
			 */
			expand_selected_onload : true,
			/**
			 * if left as `true` web workers will be used to parse incoming JSON data where possible, so that the UI will not be blocked by large requests. Workers are however about 30% slower. Defaults to `true`
			 * @name $.jstree.defaults.core.worker
			 */
			worker : true,
			/**
			 * Force node text to plain text (and escape HTML). Defaults to `false`
			 * @name $.jstree.defaults.core.force_text
			 */
			force_text : false,
			/**
			 * Should the node should be toggled if the text is double clicked . Defaults to `true`
			 * @name $.jstree.defaults.core.dblclick_toggle
			 */
			dblclick_toggle : true
		};
		$.jstree.core.prototype = {
			/**
			 * used to decorate an instance with a plugin. Used internally.
			 * @private
			 * @name plugin(deco [, opts])
			 * @param  {String} deco the plugin to decorate with
			 * @param  {Object} opts options for the plugin
			 * @return {jsTree}
			 */
			plugin : function (deco, opts) {
				var Child = $.jstree.plugins[deco];
				if(Child) {
					this._data[deco] = {};
					Child.prototype = this;
					return new Child(opts, this);
				}
				return this;
			},
			/**
			 * initialize the instance. Used internally.
			 * @private
			 * @name init(el, optons)
			 * @param {DOMElement|jQuery|String} el the element we are transforming
			 * @param {Object} options options for this instance
			 * @trigger init.jstree, loading.jstree, loaded.jstree, ready.jstree, changed.jstree
			 */
			init : function (el, options) {
				this._model = {
					data : {},
					changed : [],
					force_full_redraw : false,
					redraw_timeout : false,
					default_state : {
						loaded : true,
						opened : false,
						selected : false,
						disabled : false
					}
				};
				this._model.data[$.jstree.root] = {
					id : $.jstree.root,
					parent : null,
					parents : [],
					children : [],
					children_d : [],
					state : { loaded : false }
				};
	
				this.element = $(el).addClass('jstree jstree-' + this._id);
				this.settings = options;
	
				this._data.core.ready = false;
				this._data.core.loaded = false;
				this._data.core.rtl = (this.element.css("direction") === "rtl");
				this.element[this._data.core.rtl ? 'addClass' : 'removeClass']("jstree-rtl");
				this.element.attr('role','tree');
				if(this.settings.core.multiple) {
					this.element.attr('aria-multiselectable', true);
				}
				if(!this.element.attr('tabindex')) {
					this.element.attr('tabindex','0');
				}
	
				this.bind();
				/**
				 * triggered after all events are bound
				 * @event
				 * @name init.jstree
				 */
				this.trigger("init");
	
				this._data.core.original_container_html = this.element.find(" > ul > li").clone(true);
				this._data.core.original_container_html
					.find("li").addBack()
					.contents().filter(function() {
						return this.nodeType === 3 && (!this.nodeValue || /^\s+$/.test(this.nodeValue));
					})
					.remove();
				this.element.html("<"+"ul class='jstree-container-ul jstree-children' role='group'><"+"li id='j"+this._id+"_loading' class='jstree-initial-node jstree-loading jstree-leaf jstree-last' role='tree-item'><i class='jstree-icon jstree-ocl'></i><"+"a class='jstree-anchor' href='#'><i class='jstree-icon jstree-themeicon-hidden'></i>" + this.get_string("Loading ...") + "</a></li></ul>");
				this.element.attr('aria-activedescendant','j' + this._id + '_loading');
				this._data.core.li_height = this.get_container_ul().children("li").first().height() || 24;
				this._data.core.node = this._create_prototype_node();
				/**
				 * triggered after the loading text is shown and before loading starts
				 * @event
				 * @name loading.jstree
				 */
				this.trigger("loading");
				this.load_node($.jstree.root);
			},
			/**
			 * destroy an instance
			 * @name destroy()
			 * @param  {Boolean} keep_html if not set to `true` the container will be emptied, otherwise the current DOM elements will be kept intact
			 */
			destroy : function (keep_html) {
				if(this._wrk) {
					try {
						window.URL.revokeObjectURL(this._wrk);
						this._wrk = null;
					}
					catch (ignore) { }
				}
				if(!keep_html) { this.element.empty(); }
				this.teardown();
			},
			/**
			 * Create prototype node
			 */
			_create_prototype_node : function () {
				var _node = document.createElement('LI'), _temp1, _temp2;
				_node.setAttribute('role', 'treeitem');
				_temp1 = document.createElement('I');
				_temp1.className = 'jstree-icon jstree-ocl';
				_temp1.setAttribute('role', 'presentation');
				_node.appendChild(_temp1);
				_temp1 = document.createElement('A');
				_temp1.className = 'jstree-anchor';
				_temp1.setAttribute('href','#');
				_temp1.setAttribute('tabindex','-1');
				_temp2 = document.createElement('I');
				_temp2.className = 'jstree-icon jstree-themeicon';
				_temp2.setAttribute('role', 'presentation');
				_temp1.appendChild(_temp2);
				_node.appendChild(_temp1);
				_temp1 = _temp2 = null;
	
				return _node;
			},
			/**
			 * part of the destroying of an instance. Used internally.
			 * @private
			 * @name teardown()
			 */
			teardown : function () {
				this.unbind();
				this.element
					.removeClass('jstree')
					.removeData('jstree')
					.find("[class^='jstree']")
						.addBack()
						.attr("class", function () { return this.className.replace(/jstree[^ ]*|$/ig,''); });
				this.element = null;
			},
			/**
			 * bind all events. Used internally.
			 * @private
			 * @name bind()
			 */
			bind : function () {
				var word = '',
					tout = null,
					was_click = 0;
				this.element
					.on("dblclick.jstree", function (e) {
							if(e.target.tagName && e.target.tagName.toLowerCase() === "input") { return true; }
							if(document.selection && document.selection.empty) {
								document.selection.empty();
							}
							else {
								if(window.getSelection) {
									var sel = window.getSelection();
									try {
										sel.removeAllRanges();
										sel.collapse();
									} catch (ignore) { }
								}
							}
						})
					.on("mousedown.jstree", $.proxy(function (e) {
							if(e.target === this.element[0]) {
								e.preventDefault(); // prevent losing focus when clicking scroll arrows (FF, Chrome)
								was_click = +(new Date()); // ie does not allow to prevent losing focus
							}
						}, this))
					.on("mousedown.jstree", ".jstree-ocl", function (e) {
							e.preventDefault(); // prevent any node inside from losing focus when clicking the open/close icon
						})
					.on("click.jstree", ".jstree-ocl", $.proxy(function (e) {
							this.toggle_node(e.target);
						}, this))
					.on("dblclick.jstree", ".jstree-anchor", $.proxy(function (e) {
							if(e.target.tagName && e.target.tagName.toLowerCase() === "input") { return true; }
							if(this.settings.core.dblclick_toggle) {
								this.toggle_node(e.target);
							}
						}, this))
					.on("click.jstree", ".jstree-anchor", $.proxy(function (e) {
							e.preventDefault();
							if(e.currentTarget !== document.activeElement) { $(e.currentTarget).focus(); }
							this.activate_node(e.currentTarget, e);
						}, this))
					.on('keydown.jstree', '.jstree-anchor', $.proxy(function (e) {
							if(e.target.tagName && e.target.tagName.toLowerCase() === "input") { return true; }
							if(e.which !== 32 && e.which !== 13 && (e.shiftKey || e.ctrlKey || e.altKey || e.metaKey)) { return true; }
							var o = null;
							if(this._data.core.rtl) {
								if(e.which === 37) { e.which = 39; }
								else if(e.which === 39) { e.which = 37; }
							}
							switch(e.which) {
								case 32: // aria defines space only with Ctrl
									if(e.ctrlKey) {
										e.type = "click";
										$(e.currentTarget).trigger(e);
									}
									break;
								case 13: // enter
									e.type = "click";
									$(e.currentTarget).trigger(e);
									break;
								case 37: // left
									e.preventDefault();
									if(this.is_open(e.currentTarget)) {
										this.close_node(e.currentTarget);
									}
									else {
										o = this.get_parent(e.currentTarget);
										if(o && o.id !== $.jstree.root) { this.get_node(o, true).children('.jstree-anchor').focus(); }
									}
									break;
								case 38: // up
									e.preventDefault();
									o = this.get_prev_dom(e.currentTarget);
									if(o && o.length) { o.children('.jstree-anchor').focus(); }
									break;
								case 39: // right
									e.preventDefault();
									if(this.is_closed(e.currentTarget)) {
										this.open_node(e.currentTarget, function (o) { this.get_node(o, true).children('.jstree-anchor').focus(); });
									}
									else if (this.is_open(e.currentTarget)) {
										o = this.get_node(e.currentTarget, true).children('.jstree-children')[0];
										if(o) { $(this._firstChild(o)).children('.jstree-anchor').focus(); }
									}
									break;
								case 40: // down
									e.preventDefault();
									o = this.get_next_dom(e.currentTarget);
									if(o && o.length) { o.children('.jstree-anchor').focus(); }
									break;
								case 106: // aria defines * on numpad as open_all - not very common
									this.open_all();
									break;
								case 36: // home
									e.preventDefault();
									o = this._firstChild(this.get_container_ul()[0]);
									if(o) { $(o).children('.jstree-anchor').filter(':visible').focus(); }
									break;
								case 35: // end
									e.preventDefault();
									this.element.find('.jstree-anchor').filter(':visible').last().focus();
									break;
								case 113: // f2 - safe to include - if check_callback is false it will fail
									e.preventDefault();
									this.edit(e.currentTarget);
									break;
								default:
									break;
								/*!
								// delete
								case 46:
									e.preventDefault();
									o = this.get_node(e.currentTarget);
									if(o && o.id && o.id !== $.jstree.root) {
										o = this.is_selected(o) ? this.get_selected() : o;
										this.delete_node(o);
									}
									break;
	
								*/
							}
						}, this))
					.on("load_node.jstree", $.proxy(function (e, data) {
							if(data.status) {
								if(data.node.id === $.jstree.root && !this._data.core.loaded) {
									this._data.core.loaded = true;
									if(this._firstChild(this.get_container_ul()[0])) {
										this.element.attr('aria-activedescendant',this._firstChild(this.get_container_ul()[0]).id);
									}
									/**
									 * triggered after the root node is loaded for the first time
									 * @event
									 * @name loaded.jstree
									 */
									this.trigger("loaded");
								}
								if(!this._data.core.ready) {
									setTimeout($.proxy(function() {
										if(this.element && !this.get_container_ul().find('.jstree-loading').length) {
											this._data.core.ready = true;
											if(this._data.core.selected.length) {
												if(this.settings.core.expand_selected_onload) {
													var tmp = [], i, j;
													for(i = 0, j = this._data.core.selected.length; i < j; i++) {
														tmp = tmp.concat(this._model.data[this._data.core.selected[i]].parents);
													}
													tmp = $.vakata.array_unique(tmp);
													for(i = 0, j = tmp.length; i < j; i++) {
														this.open_node(tmp[i], false, 0);
													}
												}
												this.trigger('changed', { 'action' : 'ready', 'selected' : this._data.core.selected });
											}
											/**
											 * triggered after all nodes are finished loading
											 * @event
											 * @name ready.jstree
											 */
											this.trigger("ready");
										}
									}, this), 0);
								}
							}
						}, this))
					// quick searching when the tree is focused
					.on('keypress.jstree', $.proxy(function (e) {
							if(e.target.tagName && e.target.tagName.toLowerCase() === "input") { return true; }
							if(tout) { clearTimeout(tout); }
							tout = setTimeout(function () {
								word = '';
							}, 500);
	
							var chr = String.fromCharCode(e.which).toLowerCase(),
								col = this.element.find('.jstree-anchor').filter(':visible'),
								ind = col.index(document.activeElement) || 0,
								end = false;
							word += chr;
	
							// match for whole word from current node down (including the current node)
							if(word.length > 1) {
								col.slice(ind).each($.proxy(function (i, v) {
									if($(v).text().toLowerCase().indexOf(word) === 0) {
										$(v).focus();
										end = true;
										return false;
									}
								}, this));
								if(end) { return; }
	
								// match for whole word from the beginning of the tree
								col.slice(0, ind).each($.proxy(function (i, v) {
									if($(v).text().toLowerCase().indexOf(word) === 0) {
										$(v).focus();
										end = true;
										return false;
									}
								}, this));
								if(end) { return; }
							}
							// list nodes that start with that letter (only if word consists of a single char)
							if(new RegExp('^' + chr.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&') + '+$').test(word)) {
								// search for the next node starting with that letter
								col.slice(ind + 1).each($.proxy(function (i, v) {
									if($(v).text().toLowerCase().charAt(0) === chr) {
										$(v).focus();
										end = true;
										return false;
									}
								}, this));
								if(end) { return; }
	
								// search from the beginning
								col.slice(0, ind + 1).each($.proxy(function (i, v) {
									if($(v).text().toLowerCase().charAt(0) === chr) {
										$(v).focus();
										end = true;
										return false;
									}
								}, this));
								if(end) { return; }
							}
						}, this))
					// THEME RELATED
					.on("init.jstree", $.proxy(function () {
							var s = this.settings.core.themes;
							this._data.core.themes.dots			= s.dots;
							this._data.core.themes.stripes		= s.stripes;
							this._data.core.themes.icons		= s.icons;
							this._data.core.themes.ellipsis		= s.ellipsis;
							this.set_theme(s.name || "default", s.url);
							this.set_theme_variant(s.variant);
						}, this))
					.on("loading.jstree", $.proxy(function () {
							this[ this._data.core.themes.dots ? "show_dots" : "hide_dots" ]();
							this[ this._data.core.themes.icons ? "show_icons" : "hide_icons" ]();
							this[ this._data.core.themes.stripes ? "show_stripes" : "hide_stripes" ]();
							this[ this._data.core.themes.ellipsis ? "show_ellipsis" : "hide_ellipsis" ]();
						}, this))
					.on('blur.jstree', '.jstree-anchor', $.proxy(function (e) {
							this._data.core.focused = null;
							$(e.currentTarget).filter('.jstree-hovered').mouseleave();
							this.element.attr('tabindex', '0');
						}, this))
					.on('focus.jstree', '.jstree-anchor', $.proxy(function (e) {
							var tmp = this.get_node(e.currentTarget);
							if(tmp && tmp.id) {
								this._data.core.focused = tmp.id;
							}
							this.element.find('.jstree-hovered').not(e.currentTarget).mouseleave();
							$(e.currentTarget).mouseenter();
							this.element.attr('tabindex', '-1');
						}, this))
					.on('focus.jstree', $.proxy(function () {
							if(+(new Date()) - was_click > 500 && !this._data.core.focused) {
								was_click = 0;
								var act = this.get_node(this.element.attr('aria-activedescendant'), true);
								if(act) {
									act.find('> .jstree-anchor').focus();
								}
							}
						}, this))
					.on('mouseenter.jstree', '.jstree-anchor', $.proxy(function (e) {
							this.hover_node(e.currentTarget);
						}, this))
					.on('mouseleave.jstree', '.jstree-anchor', $.proxy(function (e) {
							this.dehover_node(e.currentTarget);
						}, this));
			},
			/**
			 * part of the destroying of an instance. Used internally.
			 * @private
			 * @name unbind()
			 */
			unbind : function () {
				this.element.off('.jstree');
				$(document).off('.jstree-' + this._id);
			},
			/**
			 * trigger an event. Used internally.
			 * @private
			 * @name trigger(ev [, data])
			 * @param  {String} ev the name of the event to trigger
			 * @param  {Object} data additional data to pass with the event
			 */
			trigger : function (ev, data) {
				if(!data) {
					data = {};
				}
				data.instance = this;
				this.element.triggerHandler(ev.replace('.jstree','') + '.jstree', data);
			},
			/**
			 * returns the jQuery extended instance container
			 * @name get_container()
			 * @return {jQuery}
			 */
			get_container : function () {
				return this.element;
			},
			/**
			 * returns the jQuery extended main UL node inside the instance container. Used internally.
			 * @private
			 * @name get_container_ul()
			 * @return {jQuery}
			 */
			get_container_ul : function () {
				return this.element.children(".jstree-children").first();
			},
			/**
			 * gets string replacements (localization). Used internally.
			 * @private
			 * @name get_string(key)
			 * @param  {String} key
			 * @return {String}
			 */
			get_string : function (key) {
				var a = this.settings.core.strings;
				if($.isFunction(a)) { return a.call(this, key); }
				if(a && a[key]) { return a[key]; }
				return key;
			},
			/**
			 * gets the first child of a DOM node. Used internally.
			 * @private
			 * @name _firstChild(dom)
			 * @param  {DOMElement} dom
			 * @return {DOMElement}
			 */
			_firstChild : function (dom) {
				dom = dom ? dom.firstChild : null;
				while(dom !== null && dom.nodeType !== 1) {
					dom = dom.nextSibling;
				}
				return dom;
			},
			/**
			 * gets the next sibling of a DOM node. Used internally.
			 * @private
			 * @name _nextSibling(dom)
			 * @param  {DOMElement} dom
			 * @return {DOMElement}
			 */
			_nextSibling : function (dom) {
				dom = dom ? dom.nextSibling : null;
				while(dom !== null && dom.nodeType !== 1) {
					dom = dom.nextSibling;
				}
				return dom;
			},
			/**
			 * gets the previous sibling of a DOM node. Used internally.
			 * @private
			 * @name _previousSibling(dom)
			 * @param  {DOMElement} dom
			 * @return {DOMElement}
			 */
			_previousSibling : function (dom) {
				dom = dom ? dom.previousSibling : null;
				while(dom !== null && dom.nodeType !== 1) {
					dom = dom.previousSibling;
				}
				return dom;
			},
			/**
			 * get the JSON representation of a node (or the actual jQuery extended DOM node) by using any input (child DOM element, ID string, selector, etc)
			 * @name get_node(obj [, as_dom])
			 * @param  {mixed} obj
			 * @param  {Boolean} as_dom
			 * @return {Object|jQuery}
			 */
			get_node : function (obj, as_dom) {
				if(obj && obj.id) {
					obj = obj.id;
				}
				var dom;
				try {
					if(this._model.data[obj]) {
						obj = this._model.data[obj];
					}
					else if(typeof obj === "string" && this._model.data[obj.replace(/^#/, '')]) {
						obj = this._model.data[obj.replace(/^#/, '')];
					}
					else if(typeof obj === "string" && (dom = $('#' + obj.replace($.jstree.idregex,'\\$&'), this.element)).length && this._model.data[dom.closest('.jstree-node').attr('id')]) {
						obj = this._model.data[dom.closest('.jstree-node').attr('id')];
					}
					else if((dom = $(obj, this.element)).length && this._model.data[dom.closest('.jstree-node').attr('id')]) {
						obj = this._model.data[dom.closest('.jstree-node').attr('id')];
					}
					else if((dom = $(obj, this.element)).length && dom.hasClass('jstree')) {
						obj = this._model.data[$.jstree.root];
					}
					else {
						return false;
					}
	
					if(as_dom) {
						obj = obj.id === $.jstree.root ? this.element : $('#' + obj.id.replace($.jstree.idregex,'\\$&'), this.element);
					}
					return obj;
				} catch (ex) { return false; }
			},
			/**
			 * get the path to a node, either consisting of node texts, or of node IDs, optionally glued together (otherwise an array)
			 * @name get_path(obj [, glue, ids])
			 * @param  {mixed} obj the node
			 * @param  {String} glue if you want the path as a string - pass the glue here (for example '/'), if a falsy value is supplied here, an array is returned
			 * @param  {Boolean} ids if set to true build the path using ID, otherwise node text is used
			 * @return {mixed}
			 */
			get_path : function (obj, glue, ids) {
				obj = obj.parents ? obj : this.get_node(obj);
				if(!obj || obj.id === $.jstree.root || !obj.parents) {
					return false;
				}
				var i, j, p = [];
				p.push(ids ? obj.id : obj.text);
				for(i = 0, j = obj.parents.length; i < j; i++) {
					p.push(ids ? obj.parents[i] : this.get_text(obj.parents[i]));
				}
				p = p.reverse().slice(1);
				return glue ? p.join(glue) : p;
			},
			/**
			 * get the next visible node that is below the `obj` node. If `strict` is set to `true` only sibling nodes are returned.
			 * @name get_next_dom(obj [, strict])
			 * @param  {mixed} obj
			 * @param  {Boolean} strict
			 * @return {jQuery}
			 */
			get_next_dom : function (obj, strict) {
				var tmp;
				obj = this.get_node(obj, true);
				if(obj[0] === this.element[0]) {
					tmp = this._firstChild(this.get_container_ul()[0]);
					while (tmp && tmp.offsetHeight === 0) {
						tmp = this._nextSibling(tmp);
					}
					return tmp ? $(tmp) : false;
				}
				if(!obj || !obj.length) {
					return false;
				}
				if(strict) {
					tmp = obj[0];
					do {
						tmp = this._nextSibling(tmp);
					} while (tmp && tmp.offsetHeight === 0);
					return tmp ? $(tmp) : false;
				}
				if(obj.hasClass("jstree-open")) {
					tmp = this._firstChild(obj.children('.jstree-children')[0]);
					while (tmp && tmp.offsetHeight === 0) {
						tmp = this._nextSibling(tmp);
					}
					if(tmp !== null) {
						return $(tmp);
					}
				}
				tmp = obj[0];
				do {
					tmp = this._nextSibling(tmp);
				} while (tmp && tmp.offsetHeight === 0);
				if(tmp !== null) {
					return $(tmp);
				}
				return obj.parentsUntil(".jstree",".jstree-node").nextAll(".jstree-node:visible").first();
			},
			/**
			 * get the previous visible node that is above the `obj` node. If `strict` is set to `true` only sibling nodes are returned.
			 * @name get_prev_dom(obj [, strict])
			 * @param  {mixed} obj
			 * @param  {Boolean} strict
			 * @return {jQuery}
			 */
			get_prev_dom : function (obj, strict) {
				var tmp;
				obj = this.get_node(obj, true);
				if(obj[0] === this.element[0]) {
					tmp = this.get_container_ul()[0].lastChild;
					while (tmp && tmp.offsetHeight === 0) {
						tmp = this._previousSibling(tmp);
					}
					return tmp ? $(tmp) : false;
				}
				if(!obj || !obj.length) {
					return false;
				}
				if(strict) {
					tmp = obj[0];
					do {
						tmp = this._previousSibling(tmp);
					} while (tmp && tmp.offsetHeight === 0);
					return tmp ? $(tmp) : false;
				}
				tmp = obj[0];
				do {
					tmp = this._previousSibling(tmp);
				} while (tmp && tmp.offsetHeight === 0);
				if(tmp !== null) {
					obj = $(tmp);
					while(obj.hasClass("jstree-open")) {
						obj = obj.children(".jstree-children").first().children(".jstree-node:visible:last");
					}
					return obj;
				}
				tmp = obj[0].parentNode.parentNode;
				return tmp && tmp.className && tmp.className.indexOf('jstree-node') !== -1 ? $(tmp) : false;
			},
			/**
			 * get the parent ID of a node
			 * @name get_parent(obj)
			 * @param  {mixed} obj
			 * @return {String}
			 */
			get_parent : function (obj) {
				obj = this.get_node(obj);
				if(!obj || obj.id === $.jstree.root) {
					return false;
				}
				return obj.parent;
			},
			/**
			 * get a jQuery collection of all the children of a node (node must be rendered)
			 * @name get_children_dom(obj)
			 * @param  {mixed} obj
			 * @return {jQuery}
			 */
			get_children_dom : function (obj) {
				obj = this.get_node(obj, true);
				if(obj[0] === this.element[0]) {
					return this.get_container_ul().children(".jstree-node");
				}
				if(!obj || !obj.length) {
					return false;
				}
				return obj.children(".jstree-children").children(".jstree-node");
			},
			/**
			 * checks if a node has children
			 * @name is_parent(obj)
			 * @param  {mixed} obj
			 * @return {Boolean}
			 */
			is_parent : function (obj) {
				obj = this.get_node(obj);
				return obj && (obj.state.loaded === false || obj.children.length > 0);
			},
			/**
			 * checks if a node is loaded (its children are available)
			 * @name is_loaded(obj)
			 * @param  {mixed} obj
			 * @return {Boolean}
			 */
			is_loaded : function (obj) {
				obj = this.get_node(obj);
				return obj && obj.state.loaded;
			},
			/**
			 * check if a node is currently loading (fetching children)
			 * @name is_loading(obj)
			 * @param  {mixed} obj
			 * @return {Boolean}
			 */
			is_loading : function (obj) {
				obj = this.get_node(obj);
				return obj && obj.state && obj.state.loading;
			},
			/**
			 * check if a node is opened
			 * @name is_open(obj)
			 * @param  {mixed} obj
			 * @return {Boolean}
			 */
			is_open : function (obj) {
				obj = this.get_node(obj);
				return obj && obj.state.opened;
			},
			/**
			 * check if a node is in a closed state
			 * @name is_closed(obj)
			 * @param  {mixed} obj
			 * @return {Boolean}
			 */
			is_closed : function (obj) {
				obj = this.get_node(obj);
				return obj && this.is_parent(obj) && !obj.state.opened;
			},
			/**
			 * check if a node has no children
			 * @name is_leaf(obj)
			 * @param  {mixed} obj
			 * @return {Boolean}
			 */
			is_leaf : function (obj) {
				return !this.is_parent(obj);
			},
			/**
			 * loads a node (fetches its children using the `core.data` setting). Multiple nodes can be passed to by using an array.
			 * @name load_node(obj [, callback])
			 * @param  {mixed} obj
			 * @param  {function} callback a function to be executed once loading is complete, the function is executed in the instance's scope and receives two arguments - the node and a boolean status
			 * @return {Boolean}
			 * @trigger load_node.jstree
			 */
			load_node : function (obj, callback) {
				var k, l, i, j, c;
				if($.isArray(obj)) {
					this._load_nodes(obj.slice(), callback);
					return true;
				}
				obj = this.get_node(obj);
				if(!obj) {
					if(callback) { callback.call(this, obj, false); }
					return false;
				}
				// if(obj.state.loading) { } // the node is already loading - just wait for it to load and invoke callback? but if called implicitly it should be loaded again?
				if(obj.state.loaded) {
					obj.state.loaded = false;
					for(i = 0, j = obj.parents.length; i < j; i++) {
						this._model.data[obj.parents[i]].children_d = $.vakata.array_filter(this._model.data[obj.parents[i]].children_d, function (v) {
							return $.inArray(v, obj.children_d) === -1;
						});
					}
					for(k = 0, l = obj.children_d.length; k < l; k++) {
						if(this._model.data[obj.children_d[k]].state.selected) {
							c = true;
						}
						delete this._model.data[obj.children_d[k]];
					}
					if (c) {
						this._data.core.selected = $.vakata.array_filter(this._data.core.selected, function (v) {
							return $.inArray(v, obj.children_d) === -1;
						});
					}
					obj.children = [];
					obj.children_d = [];
					if(c) {
						this.trigger('changed', { 'action' : 'load_node', 'node' : obj, 'selected' : this._data.core.selected });
					}
				}
				obj.state.failed = false;
				obj.state.loading = true;
				this.get_node(obj, true).addClass("jstree-loading").attr('aria-busy',true);
				this._load_node(obj, $.proxy(function (status) {
					obj = this._model.data[obj.id];
					obj.state.loading = false;
					obj.state.loaded = status;
					obj.state.failed = !obj.state.loaded;
					var dom = this.get_node(obj, true), i = 0, j = 0, m = this._model.data, has_children = false;
					for(i = 0, j = obj.children.length; i < j; i++) {
						if(m[obj.children[i]] && !m[obj.children[i]].state.hidden) {
							has_children = true;
							break;
						}
					}
					if(obj.state.loaded && dom && dom.length) {
						dom.removeClass('jstree-closed jstree-open jstree-leaf');
						if (!has_children) {
							dom.addClass('jstree-leaf');
						}
						else {
							if (obj.id !== '#') {
								dom.addClass(obj.state.opened ? 'jstree-open' : 'jstree-closed');
							}
						}
					}
					dom.removeClass("jstree-loading").attr('aria-busy',false);
					/**
					 * triggered after a node is loaded
					 * @event
					 * @name load_node.jstree
					 * @param {Object} node the node that was loading
					 * @param {Boolean} status was the node loaded successfully
					 */
					this.trigger('load_node', { "node" : obj, "status" : status });
					if(callback) {
						callback.call(this, obj, status);
					}
				}, this));
				return true;
			},
			/**
			 * load an array of nodes (will also load unavailable nodes as soon as the appear in the structure). Used internally.
			 * @private
			 * @name _load_nodes(nodes [, callback])
			 * @param  {array} nodes
			 * @param  {function} callback a function to be executed once loading is complete, the function is executed in the instance's scope and receives one argument - the array passed to _load_nodes
			 */
			_load_nodes : function (nodes, callback, is_callback, force_reload) {
				var r = true,
					c = function () { this._load_nodes(nodes, callback, true); },
					m = this._model.data, i, j, tmp = [];
				for(i = 0, j = nodes.length; i < j; i++) {
					if(m[nodes[i]] && ( (!m[nodes[i]].state.loaded && !m[nodes[i]].state.failed) || (!is_callback && force_reload) )) {
						if(!this.is_loading(nodes[i])) {
							this.load_node(nodes[i], c);
						}
						r = false;
					}
				}
				if(r) {
					for(i = 0, j = nodes.length; i < j; i++) {
						if(m[nodes[i]] && m[nodes[i]].state.loaded) {
							tmp.push(nodes[i]);
						}
					}
					if(callback && !callback.done) {
						callback.call(this, tmp);
						callback.done = true;
					}
				}
			},
			/**
			 * loads all unloaded nodes
			 * @name load_all([obj, callback])
			 * @param {mixed} obj the node to load recursively, omit to load all nodes in the tree
			 * @param {function} callback a function to be executed once loading all the nodes is complete,
			 * @trigger load_all.jstree
			 */
			load_all : function (obj, callback) {
				if(!obj) { obj = $.jstree.root; }
				obj = this.get_node(obj);
				if(!obj) { return false; }
				var to_load = [],
					m = this._model.data,
					c = m[obj.id].children_d,
					i, j;
				if(obj.state && !obj.state.loaded) {
					to_load.push(obj.id);
				}
				for(i = 0, j = c.length; i < j; i++) {
					if(m[c[i]] && m[c[i]].state && !m[c[i]].state.loaded) {
						to_load.push(c[i]);
					}
				}
				if(to_load.length) {
					this._load_nodes(to_load, function () {
						this.load_all(obj, callback);
					});
				}
				else {
					/**
					 * triggered after a load_all call completes
					 * @event
					 * @name load_all.jstree
					 * @param {Object} node the recursively loaded node
					 */
					if(callback) { callback.call(this, obj); }
					this.trigger('load_all', { "node" : obj });
				}
			},
			/**
			 * handles the actual loading of a node. Used only internally.
			 * @private
			 * @name _load_node(obj [, callback])
			 * @param  {mixed} obj
			 * @param  {function} callback a function to be executed once loading is complete, the function is executed in the instance's scope and receives one argument - a boolean status
			 * @return {Boolean}
			 */
			_load_node : function (obj, callback) {
				var s = this.settings.core.data, t;
				var notTextOrCommentNode = function notTextOrCommentNode () {
					return this.nodeType !== 3 && this.nodeType !== 8;
				};
				// use original HTML
				if(!s) {
					if(obj.id === $.jstree.root) {
						return this._append_html_data(obj, this._data.core.original_container_html.clone(true), function (status) {
							callback.call(this, status);
						});
					}
					else {
						return callback.call(this, false);
					}
					// return callback.call(this, obj.id === $.jstree.root ? this._append_html_data(obj, this._data.core.original_container_html.clone(true)) : false);
				}
				if($.isFunction(s)) {
					return s.call(this, obj, $.proxy(function (d) {
						if(d === false) {
							callback.call(this, false);
						}
						else {
							this[typeof d === 'string' ? '_append_html_data' : '_append_json_data'](obj, typeof d === 'string' ? $($.parseHTML(d)).filter(notTextOrCommentNode) : d, function (status) {
								callback.call(this, status);
							});
						}
						// return d === false ? callback.call(this, false) : callback.call(this, this[typeof d === 'string' ? '_append_html_data' : '_append_json_data'](obj, typeof d === 'string' ? $(d) : d));
					}, this));
				}
				if(typeof s === 'object') {
					if(s.url) {
						s = $.extend(true, {}, s);
						if($.isFunction(s.url)) {
							s.url = s.url.call(this, obj);
						}
						if($.isFunction(s.data)) {
							s.data = s.data.call(this, obj);
						}
						return $.ajax(s)
							.done($.proxy(function (d,t,x) {
									var type = x.getResponseHeader('Content-Type');
									if((type && type.indexOf('json') !== -1) || typeof d === "object") {
										return this._append_json_data(obj, d, function (status) { callback.call(this, status); });
										//return callback.call(this, this._append_json_data(obj, d));
									}
									if((type && type.indexOf('html') !== -1) || typeof d === "string") {
										return this._append_html_data(obj, $($.parseHTML(d)).filter(notTextOrCommentNode), function (status) { callback.call(this, status); });
										// return callback.call(this, this._append_html_data(obj, $(d)));
									}
									this._data.core.last_error = { 'error' : 'ajax', 'plugin' : 'core', 'id' : 'core_04', 'reason' : 'Could not load node', 'data' : JSON.stringify({ 'id' : obj.id, 'xhr' : x }) };
									this.settings.core.error.call(this, this._data.core.last_error);
									return callback.call(this, false);
								}, this))
							.fail($.proxy(function (f) {
									callback.call(this, false);
									this._data.core.last_error = { 'error' : 'ajax', 'plugin' : 'core', 'id' : 'core_04', 'reason' : 'Could not load node', 'data' : JSON.stringify({ 'id' : obj.id, 'xhr' : f }) };
									this.settings.core.error.call(this, this._data.core.last_error);
								}, this));
					}
					t = ($.isArray(s) || $.isPlainObject(s)) ? JSON.parse(JSON.stringify(s)) : s;
					if(obj.id === $.jstree.root) {
						return this._append_json_data(obj, t, function (status) {
							callback.call(this, status);
						});
					}
					else {
						this._data.core.last_error = { 'error' : 'nodata', 'plugin' : 'core', 'id' : 'core_05', 'reason' : 'Could not load node', 'data' : JSON.stringify({ 'id' : obj.id }) };
						this.settings.core.error.call(this, this._data.core.last_error);
						return callback.call(this, false);
					}
					//return callback.call(this, (obj.id === $.jstree.root ? this._append_json_data(obj, t) : false) );
				}
				if(typeof s === 'string') {
					if(obj.id === $.jstree.root) {
						return this._append_html_data(obj, $($.parseHTML(s)).filter(notTextOrCommentNode), function (status) {
							callback.call(this, status);
						});
					}
					else {
						this._data.core.last_error = { 'error' : 'nodata', 'plugin' : 'core', 'id' : 'core_06', 'reason' : 'Could not load node', 'data' : JSON.stringify({ 'id' : obj.id }) };
						this.settings.core.error.call(this, this._data.core.last_error);
						return callback.call(this, false);
					}
					//return callback.call(this, (obj.id === $.jstree.root ? this._append_html_data(obj, $(s)) : false) );
				}
				return callback.call(this, false);
			},
			/**
			 * adds a node to the list of nodes to redraw. Used only internally.
			 * @private
			 * @name _node_changed(obj [, callback])
			 * @param  {mixed} obj
			 */
			_node_changed : function (obj) {
				obj = this.get_node(obj);
				if(obj) {
					this._model.changed.push(obj.id);
				}
			},
			/**
			 * appends HTML content to the tree. Used internally.
			 * @private
			 * @name _append_html_data(obj, data)
			 * @param  {mixed} obj the node to append to
			 * @param  {String} data the HTML string to parse and append
			 * @trigger model.jstree, changed.jstree
			 */
			_append_html_data : function (dom, data, cb) {
				dom = this.get_node(dom);
				dom.children = [];
				dom.children_d = [];
				var dat = data.is('ul') ? data.children() : data,
					par = dom.id,
					chd = [],
					dpc = [],
					m = this._model.data,
					p = m[par],
					s = this._data.core.selected.length,
					tmp, i, j;
				dat.each($.proxy(function (i, v) {
					tmp = this._parse_model_from_html($(v), par, p.parents.concat());
					if(tmp) {
						chd.push(tmp);
						dpc.push(tmp);
						if(m[tmp].children_d.length) {
							dpc = dpc.concat(m[tmp].children_d);
						}
					}
				}, this));
				p.children = chd;
				p.children_d = dpc;
				for(i = 0, j = p.parents.length; i < j; i++) {
					m[p.parents[i]].children_d = m[p.parents[i]].children_d.concat(dpc);
				}
				/**
				 * triggered when new data is inserted to the tree model
				 * @event
				 * @name model.jstree
				 * @param {Array} nodes an array of node IDs
				 * @param {String} parent the parent ID of the nodes
				 */
				this.trigger('model', { "nodes" : dpc, 'parent' : par });
				if(par !== $.jstree.root) {
					this._node_changed(par);
					this.redraw();
				}
				else {
					this.get_container_ul().children('.jstree-initial-node').remove();
					this.redraw(true);
				}
				if(this._data.core.selected.length !== s) {
					this.trigger('changed', { 'action' : 'model', 'selected' : this._data.core.selected });
				}
				cb.call(this, true);
			},
			/**
			 * appends JSON content to the tree. Used internally.
			 * @private
			 * @name _append_json_data(obj, data)
			 * @param  {mixed} obj the node to append to
			 * @param  {String} data the JSON object to parse and append
			 * @param  {Boolean} force_processing internal param - do not set
			 * @trigger model.jstree, changed.jstree
			 */
			_append_json_data : function (dom, data, cb, force_processing) {
				if(this.element === null) { return; }
				dom = this.get_node(dom);
				dom.children = [];
				dom.children_d = [];
				// *%$@!!!
				if(data.d) {
					data = data.d;
					if(typeof data === "string") {
						data = JSON.parse(data);
					}
				}
				if(!$.isArray(data)) { data = [data]; }
				var w = null,
					args = {
						'df'	: this._model.default_state,
						'dat'	: data,
						'par'	: dom.id,
						'm'		: this._model.data,
						't_id'	: this._id,
						't_cnt'	: this._cnt,
						'sel'	: this._data.core.selected
					},
					func = function (data, undefined) {
						if(data.data) { data = data.data; }
						var dat = data.dat,
							par = data.par,
							chd = [],
							dpc = [],
							add = [],
							df = data.df,
							t_id = data.t_id,
							t_cnt = data.t_cnt,
							m = data.m,
							p = m[par],
							sel = data.sel,
							tmp, i, j, rslt,
							parse_flat = function (d, p, ps) {
								if(!ps) { ps = []; }
								else { ps = ps.concat(); }
								if(p) { ps.unshift(p); }
								var tid = d.id.toString(),
									i, j, c, e,
									tmp = {
										id			: tid,
										text		: d.text || '',
										icon		: d.icon !== undefined ? d.icon : true,
										parent		: p,
										parents		: ps,
										children	: d.children || [],
										children_d	: d.children_d || [],
										data		: d.data,
										state		: { },
										li_attr		: { id : false },
										a_attr		: { href : '#' },
										original	: false
									};
								for(i in df) {
									if(df.hasOwnProperty(i)) {
										tmp.state[i] = df[i];
									}
								}
								if(d && d.data && d.data.jstree && d.data.jstree.icon) {
									tmp.icon = d.data.jstree.icon;
								}
								if(tmp.icon === undefined || tmp.icon === null || tmp.icon === "") {
									tmp.icon = true;
								}
								if(d && d.data) {
									tmp.data = d.data;
									if(d.data.jstree) {
										for(i in d.data.jstree) {
											if(d.data.jstree.hasOwnProperty(i)) {
												tmp.state[i] = d.data.jstree[i];
											}
										}
									}
								}
								if(d && typeof d.state === 'object') {
									for (i in d.state) {
										if(d.state.hasOwnProperty(i)) {
											tmp.state[i] = d.state[i];
										}
									}
								}
								if(d && typeof d.li_attr === 'object') {
									for (i in d.li_attr) {
										if(d.li_attr.hasOwnProperty(i)) {
											tmp.li_attr[i] = d.li_attr[i];
										}
									}
								}
								if(!tmp.li_attr.id) {
									tmp.li_attr.id = tid;
								}
								if(d && typeof d.a_attr === 'object') {
									for (i in d.a_attr) {
										if(d.a_attr.hasOwnProperty(i)) {
											tmp.a_attr[i] = d.a_attr[i];
										}
									}
								}
								if(d && d.children && d.children === true) {
									tmp.state.loaded = false;
									tmp.children = [];
									tmp.children_d = [];
								}
								m[tmp.id] = tmp;
								for(i = 0, j = tmp.children.length; i < j; i++) {
									c = parse_flat(m[tmp.children[i]], tmp.id, ps);
									e = m[c];
									tmp.children_d.push(c);
									if(e.children_d.length) {
										tmp.children_d = tmp.children_d.concat(e.children_d);
									}
								}
								delete d.data;
								delete d.children;
								m[tmp.id].original = d;
								if(tmp.state.selected) {
									add.push(tmp.id);
								}
								return tmp.id;
							},
							parse_nest = function (d, p, ps) {
								if(!ps) { ps = []; }
								else { ps = ps.concat(); }
								if(p) { ps.unshift(p); }
								var tid = false, i, j, c, e, tmp;
								do {
									tid = 'j' + t_id + '_' + (++t_cnt);
								} while(m[tid]);
	
								tmp = {
									id			: false,
									text		: typeof d === 'string' ? d : '',
									icon		: typeof d === 'object' && d.icon !== undefined ? d.icon : true,
									parent		: p,
									parents		: ps,
									children	: [],
									children_d	: [],
									data		: null,
									state		: { },
									li_attr		: { id : false },
									a_attr		: { href : '#' },
									original	: false
								};
								for(i in df) {
									if(df.hasOwnProperty(i)) {
										tmp.state[i] = df[i];
									}
								}
								if(d && d.id) { tmp.id = d.id.toString(); }
								if(d && d.text) { tmp.text = d.text; }
								if(d && d.data && d.data.jstree && d.data.jstree.icon) {
									tmp.icon = d.data.jstree.icon;
								}
								if(tmp.icon === undefined || tmp.icon === null || tmp.icon === "") {
									tmp.icon = true;
								}
								if(d && d.data) {
									tmp.data = d.data;
									if(d.data.jstree) {
										for(i in d.data.jstree) {
											if(d.data.jstree.hasOwnProperty(i)) {
												tmp.state[i] = d.data.jstree[i];
											}
										}
									}
								}
								if(d && typeof d.state === 'object') {
									for (i in d.state) {
										if(d.state.hasOwnProperty(i)) {
											tmp.state[i] = d.state[i];
										}
									}
								}
								if(d && typeof d.li_attr === 'object') {
									for (i in d.li_attr) {
										if(d.li_attr.hasOwnProperty(i)) {
											tmp.li_attr[i] = d.li_attr[i];
										}
									}
								}
								if(tmp.li_attr.id && !tmp.id) {
									tmp.id = tmp.li_attr.id.toString();
								}
								if(!tmp.id) {
									tmp.id = tid;
								}
								if(!tmp.li_attr.id) {
									tmp.li_attr.id = tmp.id;
								}
								if(d && typeof d.a_attr === 'object') {
									for (i in d.a_attr) {
										if(d.a_attr.hasOwnProperty(i)) {
											tmp.a_attr[i] = d.a_attr[i];
										}
									}
								}
								if(d && d.children && d.children.length) {
									for(i = 0, j = d.children.length; i < j; i++) {
										c = parse_nest(d.children[i], tmp.id, ps);
										e = m[c];
										tmp.children.push(c);
										if(e.children_d.length) {
											tmp.children_d = tmp.children_d.concat(e.children_d);
										}
									}
									tmp.children_d = tmp.children_d.concat(tmp.children);
								}
								if(d && d.children && d.children === true) {
									tmp.state.loaded = false;
									tmp.children = [];
									tmp.children_d = [];
								}
								delete d.data;
								delete d.children;
								tmp.original = d;
								m[tmp.id] = tmp;
								if(tmp.state.selected) {
									add.push(tmp.id);
								}
								return tmp.id;
							};
	
						if(dat.length && dat[0].id !== undefined && dat[0].parent !== undefined) {
							// Flat JSON support (for easy import from DB):
							// 1) convert to object (foreach)
							for(i = 0, j = dat.length; i < j; i++) {
								if(!dat[i].children) {
									dat[i].children = [];
								}
								m[dat[i].id.toString()] = dat[i];
							}
							// 2) populate children (foreach)
							for(i = 0, j = dat.length; i < j; i++) {
								m[dat[i].parent.toString()].children.push(dat[i].id.toString());
								// populate parent.children_d
								p.children_d.push(dat[i].id.toString());
							}
							// 3) normalize && populate parents and children_d with recursion
							for(i = 0, j = p.children.length; i < j; i++) {
								tmp = parse_flat(m[p.children[i]], par, p.parents.concat());
								dpc.push(tmp);
								if(m[tmp].children_d.length) {
									dpc = dpc.concat(m[tmp].children_d);
								}
							}
							for(i = 0, j = p.parents.length; i < j; i++) {
								m[p.parents[i]].children_d = m[p.parents[i]].children_d.concat(dpc);
							}
							// ?) three_state selection - p.state.selected && t - (if three_state foreach(dat => ch) -> foreach(parents) if(parent.selected) child.selected = true;
							rslt = {
								'cnt' : t_cnt,
								'mod' : m,
								'sel' : sel,
								'par' : par,
								'dpc' : dpc,
								'add' : add
							};
						}
						else {
							for(i = 0, j = dat.length; i < j; i++) {
								tmp = parse_nest(dat[i], par, p.parents.concat());
								if(tmp) {
									chd.push(tmp);
									dpc.push(tmp);
									if(m[tmp].children_d.length) {
										dpc = dpc.concat(m[tmp].children_d);
									}
								}
							}
							p.children = chd;
							p.children_d = dpc;
							for(i = 0, j = p.parents.length; i < j; i++) {
								m[p.parents[i]].children_d = m[p.parents[i]].children_d.concat(dpc);
							}
							rslt = {
								'cnt' : t_cnt,
								'mod' : m,
								'sel' : sel,
								'par' : par,
								'dpc' : dpc,
								'add' : add
							};
						}
						if(typeof window === 'undefined' || typeof window.document === 'undefined') {
							postMessage(rslt);
						}
						else {
							return rslt;
						}
					},
					rslt = function (rslt, worker) {
						if(this.element === null) { return; }
						this._cnt = rslt.cnt;
						var i, m = this._model.data;
						for (i in m) {
							if (m.hasOwnProperty(i) && m[i].state && m[i].state.loading && rslt.mod[i]) {
								rslt.mod[i].state.loading = true;
							}
						}
						this._model.data = rslt.mod; // breaks the reference in load_node - careful
	
						if(worker) {
							var j, a = rslt.add, r = rslt.sel, s = this._data.core.selected.slice();
							m = this._model.data;
							// if selection was changed while calculating in worker
							if(r.length !== s.length || $.vakata.array_unique(r.concat(s)).length !== r.length) {
								// deselect nodes that are no longer selected
								for(i = 0, j = r.length; i < j; i++) {
									if($.inArray(r[i], a) === -1 && $.inArray(r[i], s) === -1) {
										m[r[i]].state.selected = false;
									}
								}
								// select nodes that were selected in the mean time
								for(i = 0, j = s.length; i < j; i++) {
									if($.inArray(s[i], r) === -1) {
										m[s[i]].state.selected = true;
									}
								}
							}
						}
						if(rslt.add.length) {
							this._data.core.selected = this._data.core.selected.concat(rslt.add);
						}
	
						this.trigger('model', { "nodes" : rslt.dpc, 'parent' : rslt.par });
	
						if(rslt.par !== $.jstree.root) {
							this._node_changed(rslt.par);
							this.redraw();
						}
						else {
							// this.get_container_ul().children('.jstree-initial-node').remove();
							this.redraw(true);
						}
						if(rslt.add.length) {
							this.trigger('changed', { 'action' : 'model', 'selected' : this._data.core.selected });
						}
						cb.call(this, true);
					};
				if(this.settings.core.worker && window.Blob && window.URL && window.Worker) {
					try {
						if(this._wrk === null) {
							this._wrk = window.URL.createObjectURL(
								new window.Blob(
									['self.onmessage = ' + func.toString()],
									{type:"text/javascript"}
								)
							);
						}
						if(!this._data.core.working || force_processing) {
							this._data.core.working = true;
							w = new window.Worker(this._wrk);
							w.onmessage = $.proxy(function (e) {
								rslt.call(this, e.data, true);
								try { w.terminate(); w = null; } catch(ignore) { }
								if(this._data.core.worker_queue.length) {
									this._append_json_data.apply(this, this._data.core.worker_queue.shift());
								}
								else {
									this._data.core.working = false;
								}
							}, this);
							if(!args.par) {
								if(this._data.core.worker_queue.length) {
									this._append_json_data.apply(this, this._data.core.worker_queue.shift());
								}
								else {
									this._data.core.working = false;
								}
							}
							else {
								w.postMessage(args);
							}
						}
						else {
							this._data.core.worker_queue.push([dom, data, cb, true]);
						}
					}
					catch(e) {
						rslt.call(this, func(args), false);
						if(this._data.core.worker_queue.length) {
							this._append_json_data.apply(this, this._data.core.worker_queue.shift());
						}
						else {
							this._data.core.working = false;
						}
					}
				}
				else {
					rslt.call(this, func(args), false);
				}
			},
			/**
			 * parses a node from a jQuery object and appends them to the in memory tree model. Used internally.
			 * @private
			 * @name _parse_model_from_html(d [, p, ps])
			 * @param  {jQuery} d the jQuery object to parse
			 * @param  {String} p the parent ID
			 * @param  {Array} ps list of all parents
			 * @return {String} the ID of the object added to the model
			 */
			_parse_model_from_html : function (d, p, ps) {
				if(!ps) { ps = []; }
				else { ps = [].concat(ps); }
				if(p) { ps.unshift(p); }
				var c, e, m = this._model.data,
					data = {
						id			: false,
						text		: false,
						icon		: true,
						parent		: p,
						parents		: ps,
						children	: [],
						children_d	: [],
						data		: null,
						state		: { },
						li_attr		: { id : false },
						a_attr		: { href : '#' },
						original	: false
					}, i, tmp, tid;
				for(i in this._model.default_state) {
					if(this._model.default_state.hasOwnProperty(i)) {
						data.state[i] = this._model.default_state[i];
					}
				}
				tmp = $.vakata.attributes(d, true);
				$.each(tmp, function (i, v) {
					v = $.trim(v);
					if(!v.length) { return true; }
					data.li_attr[i] = v;
					if(i === 'id') {
						data.id = v.toString();
					}
				});
				tmp = d.children('a').first();
				if(tmp.length) {
					tmp = $.vakata.attributes(tmp, true);
					$.each(tmp, function (i, v) {
						v = $.trim(v);
						if(v.length) {
							data.a_attr[i] = v;
						}
					});
				}
				tmp = d.children("a").first().length ? d.children("a").first().clone() : d.clone();
				tmp.children("ins, i, ul").remove();
				tmp = tmp.html();
				tmp = $('<div />').html(tmp);
				data.text = this.settings.core.force_text ? tmp.text() : tmp.html();
				tmp = d.data();
				data.data = tmp ? $.extend(true, {}, tmp) : null;
				data.state.opened = d.hasClass('jstree-open');
				data.state.selected = d.children('a').hasClass('jstree-clicked');
				data.state.disabled = d.children('a').hasClass('jstree-disabled');
				if(data.data && data.data.jstree) {
					for(i in data.data.jstree) {
						if(data.data.jstree.hasOwnProperty(i)) {
							data.state[i] = data.data.jstree[i];
						}
					}
				}
				tmp = d.children("a").children(".jstree-themeicon");
				if(tmp.length) {
					data.icon = tmp.hasClass('jstree-themeicon-hidden') ? false : tmp.attr('rel');
				}
				if(data.state.icon !== undefined) {
					data.icon = data.state.icon;
				}
				if(data.icon === undefined || data.icon === null || data.icon === "") {
					data.icon = true;
				}
				tmp = d.children("ul").children("li");
				do {
					tid = 'j' + this._id + '_' + (++this._cnt);
				} while(m[tid]);
				data.id = data.li_attr.id ? data.li_attr.id.toString() : tid;
				if(tmp.length) {
					tmp.each($.proxy(function (i, v) {
						c = this._parse_model_from_html($(v), data.id, ps);
						e = this._model.data[c];
						data.children.push(c);
						if(e.children_d.length) {
							data.children_d = data.children_d.concat(e.children_d);
						}
					}, this));
					data.children_d = data.children_d.concat(data.children);
				}
				else {
					if(d.hasClass('jstree-closed')) {
						data.state.loaded = false;
					}
				}
				if(data.li_attr['class']) {
					data.li_attr['class'] = data.li_attr['class'].replace('jstree-closed','').replace('jstree-open','');
				}
				if(data.a_attr['class']) {
					data.a_attr['class'] = data.a_attr['class'].replace('jstree-clicked','').replace('jstree-disabled','');
				}
				m[data.id] = data;
				if(data.state.selected) {
					this._data.core.selected.push(data.id);
				}
				return data.id;
			},
			/**
			 * parses a node from a JSON object (used when dealing with flat data, which has no nesting of children, but has id and parent properties) and appends it to the in memory tree model. Used internally.
			 * @private
			 * @name _parse_model_from_flat_json(d [, p, ps])
			 * @param  {Object} d the JSON object to parse
			 * @param  {String} p the parent ID
			 * @param  {Array} ps list of all parents
			 * @return {String} the ID of the object added to the model
			 */
			_parse_model_from_flat_json : function (d, p, ps) {
				if(!ps) { ps = []; }
				else { ps = ps.concat(); }
				if(p) { ps.unshift(p); }
				var tid = d.id.toString(),
					m = this._model.data,
					df = this._model.default_state,
					i, j, c, e,
					tmp = {
						id			: tid,
						text		: d.text || '',
						icon		: d.icon !== undefined ? d.icon : true,
						parent		: p,
						parents		: ps,
						children	: d.children || [],
						children_d	: d.children_d || [],
						data		: d.data,
						state		: { },
						li_attr		: { id : false },
						a_attr		: { href : '#' },
						original	: false
					};
				for(i in df) {
					if(df.hasOwnProperty(i)) {
						tmp.state[i] = df[i];
					}
				}
				if(d && d.data && d.data.jstree && d.data.jstree.icon) {
					tmp.icon = d.data.jstree.icon;
				}
				if(tmp.icon === undefined || tmp.icon === null || tmp.icon === "") {
					tmp.icon = true;
				}
				if(d && d.data) {
					tmp.data = d.data;
					if(d.data.jstree) {
						for(i in d.data.jstree) {
							if(d.data.jstree.hasOwnProperty(i)) {
								tmp.state[i] = d.data.jstree[i];
							}
						}
					}
				}
				if(d && typeof d.state === 'object') {
					for (i in d.state) {
						if(d.state.hasOwnProperty(i)) {
							tmp.state[i] = d.state[i];
						}
					}
				}
				if(d && typeof d.li_attr === 'object') {
					for (i in d.li_attr) {
						if(d.li_attr.hasOwnProperty(i)) {
							tmp.li_attr[i] = d.li_attr[i];
						}
					}
				}
				if(!tmp.li_attr.id) {
					tmp.li_attr.id = tid;
				}
				if(d && typeof d.a_attr === 'object') {
					for (i in d.a_attr) {
						if(d.a_attr.hasOwnProperty(i)) {
							tmp.a_attr[i] = d.a_attr[i];
						}
					}
				}
				if(d && d.children && d.children === true) {
					tmp.state.loaded = false;
					tmp.children = [];
					tmp.children_d = [];
				}
				m[tmp.id] = tmp;
				for(i = 0, j = tmp.children.length; i < j; i++) {
					c = this._parse_model_from_flat_json(m[tmp.children[i]], tmp.id, ps);
					e = m[c];
					tmp.children_d.push(c);
					if(e.children_d.length) {
						tmp.children_d = tmp.children_d.concat(e.children_d);
					}
				}
				delete d.data;
				delete d.children;
				m[tmp.id].original = d;
				if(tmp.state.selected) {
					this._data.core.selected.push(tmp.id);
				}
				return tmp.id;
			},
			/**
			 * parses a node from a JSON object and appends it to the in memory tree model. Used internally.
			 * @private
			 * @name _parse_model_from_json(d [, p, ps])
			 * @param  {Object} d the JSON object to parse
			 * @param  {String} p the parent ID
			 * @param  {Array} ps list of all parents
			 * @return {String} the ID of the object added to the model
			 */
			_parse_model_from_json : function (d, p, ps) {
				if(!ps) { ps = []; }
				else { ps = ps.concat(); }
				if(p) { ps.unshift(p); }
				var tid = false, i, j, c, e, m = this._model.data, df = this._model.default_state, tmp;
				do {
					tid = 'j' + this._id + '_' + (++this._cnt);
				} while(m[tid]);
	
				tmp = {
					id			: false,
					text		: typeof d === 'string' ? d : '',
					icon		: typeof d === 'object' && d.icon !== undefined ? d.icon : true,
					parent		: p,
					parents		: ps,
					children	: [],
					children_d	: [],
					data		: null,
					state		: { },
					li_attr		: { id : false },
					a_attr		: { href : '#' },
					original	: false
				};
				for(i in df) {
					if(df.hasOwnProperty(i)) {
						tmp.state[i] = df[i];
					}
				}
				if(d && d.id) { tmp.id = d.id.toString(); }
				if(d && d.text) { tmp.text = d.text; }
				if(d && d.data && d.data.jstree && d.data.jstree.icon) {
					tmp.icon = d.data.jstree.icon;
				}
				if(tmp.icon === undefined || tmp.icon === null || tmp.icon === "") {
					tmp.icon = true;
				}
				if(d && d.data) {
					tmp.data = d.data;
					if(d.data.jstree) {
						for(i in d.data.jstree) {
							if(d.data.jstree.hasOwnProperty(i)) {
								tmp.state[i] = d.data.jstree[i];
							}
						}
					}
				}
				if(d && typeof d.state === 'object') {
					for (i in d.state) {
						if(d.state.hasOwnProperty(i)) {
							tmp.state[i] = d.state[i];
						}
					}
				}
				if(d && typeof d.li_attr === 'object') {
					for (i in d.li_attr) {
						if(d.li_attr.hasOwnProperty(i)) {
							tmp.li_attr[i] = d.li_attr[i];
						}
					}
				}
				if(tmp.li_attr.id && !tmp.id) {
					tmp.id = tmp.li_attr.id.toString();
				}
				if(!tmp.id) {
					tmp.id = tid;
				}
				if(!tmp.li_attr.id) {
					tmp.li_attr.id = tmp.id;
				}
				if(d && typeof d.a_attr === 'object') {
					for (i in d.a_attr) {
						if(d.a_attr.hasOwnProperty(i)) {
							tmp.a_attr[i] = d.a_attr[i];
						}
					}
				}
				if(d && d.children && d.children.length) {
					for(i = 0, j = d.children.length; i < j; i++) {
						c = this._parse_model_from_json(d.children[i], tmp.id, ps);
						e = m[c];
						tmp.children.push(c);
						if(e.children_d.length) {
							tmp.children_d = tmp.children_d.concat(e.children_d);
						}
					}
					tmp.children_d = tmp.children_d.concat(tmp.children);
				}
				if(d && d.children && d.children === true) {
					tmp.state.loaded = false;
					tmp.children = [];
					tmp.children_d = [];
				}
				delete d.data;
				delete d.children;
				tmp.original = d;
				m[tmp.id] = tmp;
				if(tmp.state.selected) {
					this._data.core.selected.push(tmp.id);
				}
				return tmp.id;
			},
			/**
			 * redraws all nodes that need to be redrawn. Used internally.
			 * @private
			 * @name _redraw()
			 * @trigger redraw.jstree
			 */
			_redraw : function () {
				var nodes = this._model.force_full_redraw ? this._model.data[$.jstree.root].children.concat([]) : this._model.changed.concat([]),
					f = document.createElement('UL'), tmp, i, j, fe = this._data.core.focused;
				for(i = 0, j = nodes.length; i < j; i++) {
					tmp = this.redraw_node(nodes[i], true, this._model.force_full_redraw);
					if(tmp && this._model.force_full_redraw) {
						f.appendChild(tmp);
					}
				}
				if(this._model.force_full_redraw) {
					f.className = this.get_container_ul()[0].className;
					f.setAttribute('role','group');
					this.element.empty().append(f);
					//this.get_container_ul()[0].appendChild(f);
				}
				if(fe !== null) {
					tmp = this.get_node(fe, true);
					if(tmp && tmp.length && tmp.children('.jstree-anchor')[0] !== document.activeElement) {
						tmp.children('.jstree-anchor').focus();
					}
					else {
						this._data.core.focused = null;
					}
				}
				this._model.force_full_redraw = false;
				this._model.changed = [];
				/**
				 * triggered after nodes are redrawn
				 * @event
				 * @name redraw.jstree
				 * @param {array} nodes the redrawn nodes
				 */
				this.trigger('redraw', { "nodes" : nodes });
			},
			/**
			 * redraws all nodes that need to be redrawn or optionally - the whole tree
			 * @name redraw([full])
			 * @param {Boolean} full if set to `true` all nodes are redrawn.
			 */
			redraw : function (full) {
				if(full) {
					this._model.force_full_redraw = true;
				}
				//if(this._model.redraw_timeout) {
				//	clearTimeout(this._model.redraw_timeout);
				//}
				//this._model.redraw_timeout = setTimeout($.proxy(this._redraw, this),0);
				this._redraw();
			},
			/**
			 * redraws a single node's children. Used internally.
			 * @private
			 * @name draw_children(node)
			 * @param {mixed} node the node whose children will be redrawn
			 */
			draw_children : function (node) {
				var obj = this.get_node(node),
					i = false,
					j = false,
					k = false,
					d = document;
				if(!obj) { return false; }
				if(obj.id === $.jstree.root) { return this.redraw(true); }
				node = this.get_node(node, true);
				if(!node || !node.length) { return false; } // TODO: quick toggle
	
				node.children('.jstree-children').remove();
				node = node[0];
				if(obj.children.length && obj.state.loaded) {
					k = d.createElement('UL');
					k.setAttribute('role', 'group');
					k.className = 'jstree-children';
					for(i = 0, j = obj.children.length; i < j; i++) {
						k.appendChild(this.redraw_node(obj.children[i], true, true));
					}
					node.appendChild(k);
				}
			},
			/**
			 * redraws a single node. Used internally.
			 * @private
			 * @name redraw_node(node, deep, is_callback, force_render)
			 * @param {mixed} node the node to redraw
			 * @param {Boolean} deep should child nodes be redrawn too
			 * @param {Boolean} is_callback is this a recursion call
			 * @param {Boolean} force_render should children of closed parents be drawn anyway
			 */
			redraw_node : function (node, deep, is_callback, force_render) {
				var obj = this.get_node(node),
					par = false,
					ind = false,
					old = false,
					i = false,
					j = false,
					k = false,
					c = '',
					d = document,
					m = this._model.data,
					f = false,
					s = false,
					tmp = null,
					t = 0,
					l = 0,
					has_children = false,
					last_sibling = false;
				if(!obj) { return false; }
				if(obj.id === $.jstree.root) {  return this.redraw(true); }
				deep = deep || obj.children.length === 0;
				node = !document.querySelector ? document.getElementById(obj.id) : this.element[0].querySelector('#' + ("0123456789".indexOf(obj.id[0]) !== -1 ? '\\3' + obj.id[0] + ' ' + obj.id.substr(1).replace($.jstree.idregex,'\\$&') : obj.id.replace($.jstree.idregex,'\\$&')) ); //, this.element);
				if(!node) {
					deep = true;
					//node = d.createElement('LI');
					if(!is_callback) {
						par = obj.parent !== $.jstree.root ? $('#' + obj.parent.replace($.jstree.idregex,'\\$&'), this.element)[0] : null;
						if(par !== null && (!par || !m[obj.parent].state.opened)) {
							return false;
						}
						ind = $.inArray(obj.id, par === null ? m[$.jstree.root].children : m[obj.parent].children);
					}
				}
				else {
					node = $(node);
					if(!is_callback) {
						par = node.parent().parent()[0];
						if(par === this.element[0]) {
							par = null;
						}
						ind = node.index();
					}
					// m[obj.id].data = node.data(); // use only node's data, no need to touch jquery storage
					if(!deep && obj.children.length && !node.children('.jstree-children').length) {
						deep = true;
					}
					if(!deep) {
						old = node.children('.jstree-children')[0];
					}
					f = node.children('.jstree-anchor')[0] === document.activeElement;
					node.remove();
					//node = d.createElement('LI');
					//node = node[0];
				}
				node = this._data.core.node.cloneNode(true);
				// node is DOM, deep is boolean
	
				c = 'jstree-node ';
				for(i in obj.li_attr) {
					if(obj.li_attr.hasOwnProperty(i)) {
						if(i === 'id') { continue; }
						if(i !== 'class') {
							node.setAttribute(i, obj.li_attr[i]);
						}
						else {
							c += obj.li_attr[i];
						}
					}
				}
				if(!obj.a_attr.id) {
					obj.a_attr.id = obj.id + '_anchor';
				}
				node.setAttribute('aria-selected', !!obj.state.selected);
				node.setAttribute('aria-level', obj.parents.length);
				node.setAttribute('aria-labelledby', obj.a_attr.id);
				if(obj.state.disabled) {
					node.setAttribute('aria-disabled', true);
				}
	
				for(i = 0, j = obj.children.length; i < j; i++) {
					if(!m[obj.children[i]].state.hidden) {
						has_children = true;
						break;
					}
				}
				if(obj.parent !== null && m[obj.parent] && !obj.state.hidden) {
					i = $.inArray(obj.id, m[obj.parent].children);
					last_sibling = obj.id;
					if(i !== -1) {
						i++;
						for(j = m[obj.parent].children.length; i < j; i++) {
							if(!m[m[obj.parent].children[i]].state.hidden) {
								last_sibling = m[obj.parent].children[i];
							}
							if(last_sibling !== obj.id) {
								break;
							}
						}
					}
				}
	
				if(obj.state.hidden) {
					c += ' jstree-hidden';
				}
				if(obj.state.loaded && !has_children) {
					c += ' jstree-leaf';
				}
				else {
					c += obj.state.opened && obj.state.loaded ? ' jstree-open' : ' jstree-closed';
					node.setAttribute('aria-expanded', (obj.state.opened && obj.state.loaded) );
				}
				if(last_sibling === obj.id) {
					c += ' jstree-last';
				}
				node.id = obj.id;
				node.className = c;
				c = ( obj.state.selected ? ' jstree-clicked' : '') + ( obj.state.disabled ? ' jstree-disabled' : '');
				for(j in obj.a_attr) {
					if(obj.a_attr.hasOwnProperty(j)) {
						if(j === 'href' && obj.a_attr[j] === '#') { continue; }
						if(j !== 'class') {
							node.childNodes[1].setAttribute(j, obj.a_attr[j]);
						}
						else {
							c += ' ' + obj.a_attr[j];
						}
					}
				}
				if(c.length) {
					node.childNodes[1].className = 'jstree-anchor ' + c;
				}
				if((obj.icon && obj.icon !== true) || obj.icon === false) {
					if(obj.icon === false) {
						node.childNodes[1].childNodes[0].className += ' jstree-themeicon-hidden';
					}
					else if(obj.icon.indexOf('/') === -1 && obj.icon.indexOf('.') === -1) {
						node.childNodes[1].childNodes[0].className += ' ' + obj.icon + ' jstree-themeicon-custom';
					}
					else {
						node.childNodes[1].childNodes[0].style.backgroundImage = 'url("'+obj.icon+'")';
						node.childNodes[1].childNodes[0].style.backgroundPosition = 'center center';
						node.childNodes[1].childNodes[0].style.backgroundSize = 'auto';
						node.childNodes[1].childNodes[0].className += ' jstree-themeicon-custom';
					}
				}
	
				if(this.settings.core.force_text) {
					node.childNodes[1].appendChild(d.createTextNode(obj.text));
				}
				else {
					node.childNodes[1].innerHTML += obj.text;
				}
	
	
				if(deep && obj.children.length && (obj.state.opened || force_render) && obj.state.loaded) {
					k = d.createElement('UL');
					k.setAttribute('role', 'group');
					k.className = 'jstree-children';
					for(i = 0, j = obj.children.length; i < j; i++) {
						k.appendChild(this.redraw_node(obj.children[i], deep, true));
					}
					node.appendChild(k);
				}
				if(old) {
					node.appendChild(old);
				}
				if(!is_callback) {
					// append back using par / ind
					if(!par) {
						par = this.element[0];
					}
					for(i = 0, j = par.childNodes.length; i < j; i++) {
						if(par.childNodes[i] && par.childNodes[i].className && par.childNodes[i].className.indexOf('jstree-children') !== -1) {
							tmp = par.childNodes[i];
							break;
						}
					}
					if(!tmp) {
						tmp = d.createElement('UL');
						tmp.setAttribute('role', 'group');
						tmp.className = 'jstree-children';
						par.appendChild(tmp);
					}
					par = tmp;
	
					if(ind < par.childNodes.length) {
						par.insertBefore(node, par.childNodes[ind]);
					}
					else {
						par.appendChild(node);
					}
					if(f) {
						t = this.element[0].scrollTop;
						l = this.element[0].scrollLeft;
						node.childNodes[1].focus();
						this.element[0].scrollTop = t;
						this.element[0].scrollLeft = l;
					}
				}
				if(obj.state.opened && !obj.state.loaded) {
					obj.state.opened = false;
					setTimeout($.proxy(function () {
						this.open_node(obj.id, false, 0);
					}, this), 0);
				}
				return node;
			},
			/**
			 * opens a node, revaling its children. If the node is not loaded it will be loaded and opened once ready.
			 * @name open_node(obj [, callback, animation])
			 * @param {mixed} obj the node to open
			 * @param {Function} callback a function to execute once the node is opened
			 * @param {Number} animation the animation duration in milliseconds when opening the node (overrides the `core.animation` setting). Use `false` for no animation.
			 * @trigger open_node.jstree, after_open.jstree, before_open.jstree
			 */
			open_node : function (obj, callback, animation) {
				var t1, t2, d, t;
				if($.isArray(obj)) {
					obj = obj.slice();
					for(t1 = 0, t2 = obj.length; t1 < t2; t1++) {
						this.open_node(obj[t1], callback, animation);
					}
					return true;
				}
				obj = this.get_node(obj);
				if(!obj || obj.id === $.jstree.root) {
					return false;
				}
				animation = animation === undefined ? this.settings.core.animation : animation;
				if(!this.is_closed(obj)) {
					if(callback) {
						callback.call(this, obj, false);
					}
					return false;
				}
				if(!this.is_loaded(obj)) {
					if(this.is_loading(obj)) {
						return setTimeout($.proxy(function () {
							this.open_node(obj, callback, animation);
						}, this), 500);
					}
					this.load_node(obj, function (o, ok) {
						return ok ? this.open_node(o, callback, animation) : (callback ? callback.call(this, o, false) : false);
					});
				}
				else {
					d = this.get_node(obj, true);
					t = this;
					if(d.length) {
						if(animation && d.children(".jstree-children").length) {
							d.children(".jstree-children").stop(true, true);
						}
						if(obj.children.length && !this._firstChild(d.children('.jstree-children')[0])) {
							this.draw_children(obj);
							//d = this.get_node(obj, true);
						}
						if(!animation) {
							this.trigger('before_open', { "node" : obj });
							d[0].className = d[0].className.replace('jstree-closed', 'jstree-open');
							d[0].setAttribute("aria-expanded", true);
						}
						else {
							this.trigger('before_open', { "node" : obj });
							d
								.children(".jstree-children").css("display","none").end()
								.removeClass("jstree-closed").addClass("jstree-open").attr("aria-expanded", true)
								.children(".jstree-children").stop(true, true)
									.slideDown(animation, function () {
										this.style.display = "";
										if (t.element) {
											t.trigger("after_open", { "node" : obj });
										}
									});
						}
					}
					obj.state.opened = true;
					if(callback) {
						callback.call(this, obj, true);
					}
					if(!d.length) {
						/**
						 * triggered when a node is about to be opened (if the node is supposed to be in the DOM, it will be, but it won't be visible yet)
						 * @event
						 * @name before_open.jstree
						 * @param {Object} node the opened node
						 */
						this.trigger('before_open', { "node" : obj });
					}
					/**
					 * triggered when a node is opened (if there is an animation it will not be completed yet)
					 * @event
					 * @name open_node.jstree
					 * @param {Object} node the opened node
					 */
					this.trigger('open_node', { "node" : obj });
					if(!animation || !d.length) {
						/**
						 * triggered when a node is opened and the animation is complete
						 * @event
						 * @name after_open.jstree
						 * @param {Object} node the opened node
						 */
						this.trigger("after_open", { "node" : obj });
					}
					return true;
				}
			},
			/**
			 * opens every parent of a node (node should be loaded)
			 * @name _open_to(obj)
			 * @param {mixed} obj the node to reveal
			 * @private
			 */
			_open_to : function (obj) {
				obj = this.get_node(obj);
				if(!obj || obj.id === $.jstree.root) {
					return false;
				}
				var i, j, p = obj.parents;
				for(i = 0, j = p.length; i < j; i+=1) {
					if(i !== $.jstree.root) {
						this.open_node(p[i], false, 0);
					}
				}
				return $('#' + obj.id.replace($.jstree.idregex,'\\$&'), this.element);
			},
			/**
			 * closes a node, hiding its children
			 * @name close_node(obj [, animation])
			 * @param {mixed} obj the node to close
			 * @param {Number} animation the animation duration in milliseconds when closing the node (overrides the `core.animation` setting). Use `false` for no animation.
			 * @trigger close_node.jstree, after_close.jstree
			 */
			close_node : function (obj, animation) {
				var t1, t2, t, d;
				if($.isArray(obj)) {
					obj = obj.slice();
					for(t1 = 0, t2 = obj.length; t1 < t2; t1++) {
						this.close_node(obj[t1], animation);
					}
					return true;
				}
				obj = this.get_node(obj);
				if(!obj || obj.id === $.jstree.root) {
					return false;
				}
				if(this.is_closed(obj)) {
					return false;
				}
				animation = animation === undefined ? this.settings.core.animation : animation;
				t = this;
				d = this.get_node(obj, true);
	
				obj.state.opened = false;
				/**
				 * triggered when a node is closed (if there is an animation it will not be complete yet)
				 * @event
				 * @name close_node.jstree
				 * @param {Object} node the closed node
				 */
				this.trigger('close_node',{ "node" : obj });
				if(!d.length) {
					/**
					 * triggered when a node is closed and the animation is complete
					 * @event
					 * @name after_close.jstree
					 * @param {Object} node the closed node
					 */
					this.trigger("after_close", { "node" : obj });
				}
				else {
					if(!animation) {
						d[0].className = d[0].className.replace('jstree-open', 'jstree-closed');
						d.attr("aria-expanded", false).children('.jstree-children').remove();
						this.trigger("after_close", { "node" : obj });
					}
					else {
						d
							.children(".jstree-children").attr("style","display:block !important").end()
							.removeClass("jstree-open").addClass("jstree-closed").attr("aria-expanded", false)
							.children(".jstree-children").stop(true, true).slideUp(animation, function () {
								this.style.display = "";
								d.children('.jstree-children').remove();
								if (t.element) {
									t.trigger("after_close", { "node" : obj });
								}
							});
					}
				}
			},
			/**
			 * toggles a node - closing it if it is open, opening it if it is closed
			 * @name toggle_node(obj)
			 * @param {mixed} obj the node to toggle
			 */
			toggle_node : function (obj) {
				var t1, t2;
				if($.isArray(obj)) {
					obj = obj.slice();
					for(t1 = 0, t2 = obj.length; t1 < t2; t1++) {
						this.toggle_node(obj[t1]);
					}
					return true;
				}
				if(this.is_closed(obj)) {
					return this.open_node(obj);
				}
				if(this.is_open(obj)) {
					return this.close_node(obj);
				}
			},
			/**
			 * opens all nodes within a node (or the tree), revaling their children. If the node is not loaded it will be loaded and opened once ready.
			 * @name open_all([obj, animation, original_obj])
			 * @param {mixed} obj the node to open recursively, omit to open all nodes in the tree
			 * @param {Number} animation the animation duration in milliseconds when opening the nodes, the default is no animation
			 * @param {jQuery} reference to the node that started the process (internal use)
			 * @trigger open_all.jstree
			 */
			open_all : function (obj, animation, original_obj) {
				if(!obj) { obj = $.jstree.root; }
				obj = this.get_node(obj);
				if(!obj) { return false; }
				var dom = obj.id === $.jstree.root ? this.get_container_ul() : this.get_node(obj, true), i, j, _this;
				if(!dom.length) {
					for(i = 0, j = obj.children_d.length; i < j; i++) {
						if(this.is_closed(this._model.data[obj.children_d[i]])) {
							this._model.data[obj.children_d[i]].state.opened = true;
						}
					}
					return this.trigger('open_all', { "node" : obj });
				}
				original_obj = original_obj || dom;
				_this = this;
				dom = this.is_closed(obj) ? dom.find('.jstree-closed').addBack() : dom.find('.jstree-closed');
				dom.each(function () {
					_this.open_node(
						this,
						function(node, status) { if(status && this.is_parent(node)) { this.open_all(node, animation, original_obj); } },
						animation || 0
					);
				});
				if(original_obj.find('.jstree-closed').length === 0) {
					/**
					 * triggered when an `open_all` call completes
					 * @event
					 * @name open_all.jstree
					 * @param {Object} node the opened node
					 */
					this.trigger('open_all', { "node" : this.get_node(original_obj) });
				}
			},
			/**
			 * closes all nodes within a node (or the tree), revaling their children
			 * @name close_all([obj, animation])
			 * @param {mixed} obj the node to close recursively, omit to close all nodes in the tree
			 * @param {Number} animation the animation duration in milliseconds when closing the nodes, the default is no animation
			 * @trigger close_all.jstree
			 */
			close_all : function (obj, animation) {
				if(!obj) { obj = $.jstree.root; }
				obj = this.get_node(obj);
				if(!obj) { return false; }
				var dom = obj.id === $.jstree.root ? this.get_container_ul() : this.get_node(obj, true),
					_this = this, i, j;
				if(dom.length) {
					dom = this.is_open(obj) ? dom.find('.jstree-open').addBack() : dom.find('.jstree-open');
					$(dom.get().reverse()).each(function () { _this.close_node(this, animation || 0); });
				}
				for(i = 0, j = obj.children_d.length; i < j; i++) {
					this._model.data[obj.children_d[i]].state.opened = false;
				}
				/**
				 * triggered when an `close_all` call completes
				 * @event
				 * @name close_all.jstree
				 * @param {Object} node the closed node
				 */
				this.trigger('close_all', { "node" : obj });
			},
			/**
			 * checks if a node is disabled (not selectable)
			 * @name is_disabled(obj)
			 * @param  {mixed} obj
			 * @return {Boolean}
			 */
			is_disabled : function (obj) {
				obj = this.get_node(obj);
				return obj && obj.state && obj.state.disabled;
			},
			/**
			 * enables a node - so that it can be selected
			 * @name enable_node(obj)
			 * @param {mixed} obj the node to enable
			 * @trigger enable_node.jstree
			 */
			enable_node : function (obj) {
				var t1, t2;
				if($.isArray(obj)) {
					obj = obj.slice();
					for(t1 = 0, t2 = obj.length; t1 < t2; t1++) {
						this.enable_node(obj[t1]);
					}
					return true;
				}
				obj = this.get_node(obj);
				if(!obj || obj.id === $.jstree.root) {
					return false;
				}
				obj.state.disabled = false;
				this.get_node(obj,true).children('.jstree-anchor').removeClass('jstree-disabled').attr('aria-disabled', false);
				/**
				 * triggered when an node is enabled
				 * @event
				 * @name enable_node.jstree
				 * @param {Object} node the enabled node
				 */
				this.trigger('enable_node', { 'node' : obj });
			},
			/**
			 * disables a node - so that it can not be selected
			 * @name disable_node(obj)
			 * @param {mixed} obj the node to disable
			 * @trigger disable_node.jstree
			 */
			disable_node : function (obj) {
				var t1, t2;
				if($.isArray(obj)) {
					obj = obj.slice();
					for(t1 = 0, t2 = obj.length; t1 < t2; t1++) {
						this.disable_node(obj[t1]);
					}
					return true;
				}
				obj = this.get_node(obj);
				if(!obj || obj.id === $.jstree.root) {
					return false;
				}
				obj.state.disabled = true;
				this.get_node(obj,true).children('.jstree-anchor').addClass('jstree-disabled').attr('aria-disabled', true);
				/**
				 * triggered when an node is disabled
				 * @event
				 * @name disable_node.jstree
				 * @param {Object} node the disabled node
				 */
				this.trigger('disable_node', { 'node' : obj });
			},
			/**
			 * determines if a node is hidden
			 * @name is_hidden(obj)
			 * @param {mixed} obj the node
			 */
			is_hidden : function (obj) {
				obj = this.get_node(obj);
				return obj.state.hidden === true;
			},
			/**
			 * hides a node - it is still in the structure but will not be visible
			 * @name hide_node(obj)
			 * @param {mixed} obj the node to hide
			 * @param {Boolean} skip_redraw internal parameter controlling if redraw is called
			 * @trigger hide_node.jstree
			 */
			hide_node : function (obj, skip_redraw) {
				var t1, t2;
				if($.isArray(obj)) {
					obj = obj.slice();
					for(t1 = 0, t2 = obj.length; t1 < t2; t1++) {
						this.hide_node(obj[t1], true);
					}
					if (!skip_redraw) {
						this.redraw();
					}
					return true;
				}
				obj = this.get_node(obj);
				if(!obj || obj.id === $.jstree.root) {
					return false;
				}
				if(!obj.state.hidden) {
					obj.state.hidden = true;
					this._node_changed(obj.parent);
					if(!skip_redraw) {
						this.redraw();
					}
					/**
					 * triggered when an node is hidden
					 * @event
					 * @name hide_node.jstree
					 * @param {Object} node the hidden node
					 */
					this.trigger('hide_node', { 'node' : obj });
				}
			},
			/**
			 * shows a node
			 * @name show_node(obj)
			 * @param {mixed} obj the node to show
			 * @param {Boolean} skip_redraw internal parameter controlling if redraw is called
			 * @trigger show_node.jstree
			 */
			show_node : function (obj, skip_redraw) {
				var t1, t2;
				if($.isArray(obj)) {
					obj = obj.slice();
					for(t1 = 0, t2 = obj.length; t1 < t2; t1++) {
						this.show_node(obj[t1], true);
					}
					if (!skip_redraw) {
						this.redraw();
					}
					return true;
				}
				obj = this.get_node(obj);
				if(!obj || obj.id === $.jstree.root) {
					return false;
				}
				if(obj.state.hidden) {
					obj.state.hidden = false;
					this._node_changed(obj.parent);
					if(!skip_redraw) {
						this.redraw();
					}
					/**
					 * triggered when an node is shown
					 * @event
					 * @name show_node.jstree
					 * @param {Object} node the shown node
					 */
					this.trigger('show_node', { 'node' : obj });
				}
			},
			/**
			 * hides all nodes
			 * @name hide_all()
			 * @trigger hide_all.jstree
			 */
			hide_all : function (skip_redraw) {
				var i, m = this._model.data, ids = [];
				for(i in m) {
					if(m.hasOwnProperty(i) && i !== $.jstree.root && !m[i].state.hidden) {
						m[i].state.hidden = true;
						ids.push(i);
					}
				}
				this._model.force_full_redraw = true;
				if(!skip_redraw) {
					this.redraw();
				}
				/**
				 * triggered when all nodes are hidden
				 * @event
				 * @name hide_all.jstree
				 * @param {Array} nodes the IDs of all hidden nodes
				 */
				this.trigger('hide_all', { 'nodes' : ids });
				return ids;
			},
			/**
			 * shows all nodes
			 * @name show_all()
			 * @trigger show_all.jstree
			 */
			show_all : function (skip_redraw) {
				var i, m = this._model.data, ids = [];
				for(i in m) {
					if(m.hasOwnProperty(i) && i !== $.jstree.root && m[i].state.hidden) {
						m[i].state.hidden = false;
						ids.push(i);
					}
				}
				this._model.force_full_redraw = true;
				if(!skip_redraw) {
					this.redraw();
				}
				/**
				 * triggered when all nodes are shown
				 * @event
				 * @name show_all.jstree
				 * @param {Array} nodes the IDs of all shown nodes
				 */
				this.trigger('show_all', { 'nodes' : ids });
				return ids;
			},
			/**
			 * called when a node is selected by the user. Used internally.
			 * @private
			 * @name activate_node(obj, e)
			 * @param {mixed} obj the node
			 * @param {Object} e the related event
			 * @trigger activate_node.jstree, changed.jstree
			 */
			activate_node : function (obj, e) {
				if(this.is_disabled(obj)) {
					return false;
				}
				if(!e || typeof e !== 'object') {
					e = {};
				}
	
				// ensure last_clicked is still in the DOM, make it fresh (maybe it was moved?) and make sure it is still selected, if not - make last_clicked the last selected node
				this._data.core.last_clicked = this._data.core.last_clicked && this._data.core.last_clicked.id !== undefined ? this.get_node(this._data.core.last_clicked.id) : null;
				if(this._data.core.last_clicked && !this._data.core.last_clicked.state.selected) { this._data.core.last_clicked = null; }
				if(!this._data.core.last_clicked && this._data.core.selected.length) { this._data.core.last_clicked = this.get_node(this._data.core.selected[this._data.core.selected.length - 1]); }
	
				if(!this.settings.core.multiple || (!e.metaKey && !e.ctrlKey && !e.shiftKey) || (e.shiftKey && (!this._data.core.last_clicked || !this.get_parent(obj) || this.get_parent(obj) !== this._data.core.last_clicked.parent ) )) {
					if(!this.settings.core.multiple && (e.metaKey || e.ctrlKey || e.shiftKey) && this.is_selected(obj)) {
						this.deselect_node(obj, false, e);
					}
					else {
						this.deselect_all(true);
						this.select_node(obj, false, false, e);
						this._data.core.last_clicked = this.get_node(obj);
					}
				}
				else {
					if(e.shiftKey) {
						var o = this.get_node(obj).id,
							l = this._data.core.last_clicked.id,
							p = this.get_node(this._data.core.last_clicked.parent).children,
							c = false,
							i, j;
						for(i = 0, j = p.length; i < j; i += 1) {
							// separate IFs work whem o and l are the same
							if(p[i] === o) {
								c = !c;
							}
							if(p[i] === l) {
								c = !c;
							}
							if(!this.is_disabled(p[i]) && (c || p[i] === o || p[i] === l)) {
								if (!this.is_hidden(p[i])) {
									this.select_node(p[i], true, false, e);
								}
							}
							else {
								this.deselect_node(p[i], true, e);
							}
						}
						this.trigger('changed', { 'action' : 'select_node', 'node' : this.get_node(obj), 'selected' : this._data.core.selected, 'event' : e });
					}
					else {
						if(!this.is_selected(obj)) {
							this.select_node(obj, false, false, e);
						}
						else {
							this.deselect_node(obj, false, e);
						}
					}
				}
				/**
				 * triggered when an node is clicked or intercated with by the user
				 * @event
				 * @name activate_node.jstree
				 * @param {Object} node
				 * @param {Object} event the ooriginal event (if any) which triggered the call (may be an empty object)
				 */
				this.trigger('activate_node', { 'node' : this.get_node(obj), 'event' : e });
			},
			/**
			 * applies the hover state on a node, called when a node is hovered by the user. Used internally.
			 * @private
			 * @name hover_node(obj)
			 * @param {mixed} obj
			 * @trigger hover_node.jstree
			 */
			hover_node : function (obj) {
				obj = this.get_node(obj, true);
				if(!obj || !obj.length || obj.children('.jstree-hovered').length) {
					return false;
				}
				var o = this.element.find('.jstree-hovered'), t = this.element;
				if(o && o.length) { this.dehover_node(o); }
	
				obj.children('.jstree-anchor').addClass('jstree-hovered');
				/**
				 * triggered when an node is hovered
				 * @event
				 * @name hover_node.jstree
				 * @param {Object} node
				 */
				this.trigger('hover_node', { 'node' : this.get_node(obj) });
				setTimeout(function () { t.attr('aria-activedescendant', obj[0].id); }, 0);
			},
			/**
			 * removes the hover state from a nodecalled when a node is no longer hovered by the user. Used internally.
			 * @private
			 * @name dehover_node(obj)
			 * @param {mixed} obj
			 * @trigger dehover_node.jstree
			 */
			dehover_node : function (obj) {
				obj = this.get_node(obj, true);
				if(!obj || !obj.length || !obj.children('.jstree-hovered').length) {
					return false;
				}
				obj.children('.jstree-anchor').removeClass('jstree-hovered');
				/**
				 * triggered when an node is no longer hovered
				 * @event
				 * @name dehover_node.jstree
				 * @param {Object} node
				 */
				this.trigger('dehover_node', { 'node' : this.get_node(obj) });
			},
			/**
			 * select a node
			 * @name select_node(obj [, supress_event, prevent_open])
			 * @param {mixed} obj an array can be used to select multiple nodes
			 * @param {Boolean} supress_event if set to `true` the `changed.jstree` event won't be triggered
			 * @param {Boolean} prevent_open if set to `true` parents of the selected node won't be opened
			 * @trigger select_node.jstree, changed.jstree
			 */
			select_node : function (obj, supress_event, prevent_open, e) {
				var dom, t1, t2, th;
				if($.isArray(obj)) {
					obj = obj.slice();
					for(t1 = 0, t2 = obj.length; t1 < t2; t1++) {
						this.select_node(obj[t1], supress_event, prevent_open, e);
					}
					return true;
				}
				obj = this.get_node(obj);
				if(!obj || obj.id === $.jstree.root) {
					return false;
				}
				dom = this.get_node(obj, true);
				if(!obj.state.selected) {
					obj.state.selected = true;
					this._data.core.selected.push(obj.id);
					if(!prevent_open) {
						dom = this._open_to(obj);
					}
					if(dom && dom.length) {
						dom.attr('aria-selected', true).children('.jstree-anchor').addClass('jstree-clicked');
					}
					/**
					 * triggered when an node is selected
					 * @event
					 * @name select_node.jstree
					 * @param {Object} node
					 * @param {Array} selected the current selection
					 * @param {Object} event the event (if any) that triggered this select_node
					 */
					this.trigger('select_node', { 'node' : obj, 'selected' : this._data.core.selected, 'event' : e });
					if(!supress_event) {
						/**
						 * triggered when selection changes
						 * @event
						 * @name changed.jstree
						 * @param {Object} node
						 * @param {Object} action the action that caused the selection to change
						 * @param {Array} selected the current selection
						 * @param {Object} event the event (if any) that triggered this changed event
						 */
						this.trigger('changed', { 'action' : 'select_node', 'node' : obj, 'selected' : this._data.core.selected, 'event' : e });
					}
				}
			},
			/**
			 * deselect a node
			 * @name deselect_node(obj [, supress_event])
			 * @param {mixed} obj an array can be used to deselect multiple nodes
			 * @param {Boolean} supress_event if set to `true` the `changed.jstree` event won't be triggered
			 * @trigger deselect_node.jstree, changed.jstree
			 */
			deselect_node : function (obj, supress_event, e) {
				var t1, t2, dom;
				if($.isArray(obj)) {
					obj = obj.slice();
					for(t1 = 0, t2 = obj.length; t1 < t2; t1++) {
						this.deselect_node(obj[t1], supress_event, e);
					}
					return true;
				}
				obj = this.get_node(obj);
				if(!obj || obj.id === $.jstree.root) {
					return false;
				}
				dom = this.get_node(obj, true);
				if(obj.state.selected) {
					obj.state.selected = false;
					this._data.core.selected = $.vakata.array_remove_item(this._data.core.selected, obj.id);
					if(dom.length) {
						dom.attr('aria-selected', false).children('.jstree-anchor').removeClass('jstree-clicked');
					}
					/**
					 * triggered when an node is deselected
					 * @event
					 * @name deselect_node.jstree
					 * @param {Object} node
					 * @param {Array} selected the current selection
					 * @param {Object} event the event (if any) that triggered this deselect_node
					 */
					this.trigger('deselect_node', { 'node' : obj, 'selected' : this._data.core.selected, 'event' : e });
					if(!supress_event) {
						this.trigger('changed', { 'action' : 'deselect_node', 'node' : obj, 'selected' : this._data.core.selected, 'event' : e });
					}
				}
			},
			/**
			 * select all nodes in the tree
			 * @name select_all([supress_event])
			 * @param {Boolean} supress_event if set to `true` the `changed.jstree` event won't be triggered
			 * @trigger select_all.jstree, changed.jstree
			 */
			select_all : function (supress_event) {
				var tmp = this._data.core.selected.concat([]), i, j;
				this._data.core.selected = this._model.data[$.jstree.root].children_d.concat();
				for(i = 0, j = this._data.core.selected.length; i < j; i++) {
					if(this._model.data[this._data.core.selected[i]]) {
						this._model.data[this._data.core.selected[i]].state.selected = true;
					}
				}
				this.redraw(true);
				/**
				 * triggered when all nodes are selected
				 * @event
				 * @name select_all.jstree
				 * @param {Array} selected the current selection
				 */
				this.trigger('select_all', { 'selected' : this._data.core.selected });
				if(!supress_event) {
					this.trigger('changed', { 'action' : 'select_all', 'selected' : this._data.core.selected, 'old_selection' : tmp });
				}
			},
			/**
			 * deselect all selected nodes
			 * @name deselect_all([supress_event])
			 * @param {Boolean} supress_event if set to `true` the `changed.jstree` event won't be triggered
			 * @trigger deselect_all.jstree, changed.jstree
			 */
			deselect_all : function (supress_event) {
				var tmp = this._data.core.selected.concat([]), i, j;
				for(i = 0, j = this._data.core.selected.length; i < j; i++) {
					if(this._model.data[this._data.core.selected[i]]) {
						this._model.data[this._data.core.selected[i]].state.selected = false;
					}
				}
				this._data.core.selected = [];
				this.element.find('.jstree-clicked').removeClass('jstree-clicked').parent().attr('aria-selected', false);
				/**
				 * triggered when all nodes are deselected
				 * @event
				 * @name deselect_all.jstree
				 * @param {Object} node the previous selection
				 * @param {Array} selected the current selection
				 */
				this.trigger('deselect_all', { 'selected' : this._data.core.selected, 'node' : tmp });
				if(!supress_event) {
					this.trigger('changed', { 'action' : 'deselect_all', 'selected' : this._data.core.selected, 'old_selection' : tmp });
				}
			},
			/**
			 * checks if a node is selected
			 * @name is_selected(obj)
			 * @param  {mixed}  obj
			 * @return {Boolean}
			 */
			is_selected : function (obj) {
				obj = this.get_node(obj);
				if(!obj || obj.id === $.jstree.root) {
					return false;
				}
				return obj.state.selected;
			},
			/**
			 * get an array of all selected nodes
			 * @name get_selected([full])
			 * @param  {mixed}  full if set to `true` the returned array will consist of the full node objects, otherwise - only IDs will be returned
			 * @return {Array}
			 */
			get_selected : function (full) {
				return full ? $.map(this._data.core.selected, $.proxy(function (i) { return this.get_node(i); }, this)) : this._data.core.selected.slice();
			},
			/**
			 * get an array of all top level selected nodes (ignoring children of selected nodes)
			 * @name get_top_selected([full])
			 * @param  {mixed}  full if set to `true` the returned array will consist of the full node objects, otherwise - only IDs will be returned
			 * @return {Array}
			 */
			get_top_selected : function (full) {
				var tmp = this.get_selected(true),
					obj = {}, i, j, k, l;
				for(i = 0, j = tmp.length; i < j; i++) {
					obj[tmp[i].id] = tmp[i];
				}
				for(i = 0, j = tmp.length; i < j; i++) {
					for(k = 0, l = tmp[i].children_d.length; k < l; k++) {
						if(obj[tmp[i].children_d[k]]) {
							delete obj[tmp[i].children_d[k]];
						}
					}
				}
				tmp = [];
				for(i in obj) {
					if(obj.hasOwnProperty(i)) {
						tmp.push(i);
					}
				}
				return full ? $.map(tmp, $.proxy(function (i) { return this.get_node(i); }, this)) : tmp;
			},
			/**
			 * get an array of all bottom level selected nodes (ignoring selected parents)
			 * @name get_bottom_selected([full])
			 * @param  {mixed}  full if set to `true` the returned array will consist of the full node objects, otherwise - only IDs will be returned
			 * @return {Array}
			 */
			get_bottom_selected : function (full) {
				var tmp = this.get_selected(true),
					obj = [], i, j;
				for(i = 0, j = tmp.length; i < j; i++) {
					if(!tmp[i].children.length) {
						obj.push(tmp[i].id);
					}
				}
				return full ? $.map(obj, $.proxy(function (i) { return this.get_node(i); }, this)) : obj;
			},
			/**
			 * gets the current state of the tree so that it can be restored later with `set_state(state)`. Used internally.
			 * @name get_state()
			 * @private
			 * @return {Object}
			 */
			get_state : function () {
				var state	= {
					'core' : {
						'open' : [],
						'scroll' : {
							'left' : this.element.scrollLeft(),
							'top' : this.element.scrollTop()
						},
						/*!
						'themes' : {
							'name' : this.get_theme(),
							'icons' : this._data.core.themes.icons,
							'dots' : this._data.core.themes.dots
						},
						*/
						'selected' : []
					}
				}, i;
				for(i in this._model.data) {
					if(this._model.data.hasOwnProperty(i)) {
						if(i !== $.jstree.root) {
							if(this._model.data[i].state.opened) {
								state.core.open.push(i);
							}
							if(this._model.data[i].state.selected) {
								state.core.selected.push(i);
							}
						}
					}
				}
				return state;
			},
			/**
			 * sets the state of the tree. Used internally.
			 * @name set_state(state [, callback])
			 * @private
			 * @param {Object} state the state to restore. Keep in mind this object is passed by reference and jstree will modify it.
			 * @param {Function} callback an optional function to execute once the state is restored.
			 * @trigger set_state.jstree
			 */
			set_state : function (state, callback) {
				if(state) {
					if(state.core) {
						var res, n, t, _this, i;
						if(state.core.open) {
							if(!$.isArray(state.core.open) || !state.core.open.length) {
								delete state.core.open;
								this.set_state(state, callback);
							}
							else {
								this._load_nodes(state.core.open, function (nodes) {
									this.open_node(nodes, false, 0);
									delete state.core.open;
									this.set_state(state, callback);
								});
							}
							return false;
						}
						if(state.core.scroll) {
							if(state.core.scroll && state.core.scroll.left !== undefined) {
								this.element.scrollLeft(state.core.scroll.left);
							}
							if(state.core.scroll && state.core.scroll.top !== undefined) {
								this.element.scrollTop(state.core.scroll.top);
							}
							delete state.core.scroll;
							this.set_state(state, callback);
							return false;
						}
						if(state.core.selected) {
							_this = this;
							this.deselect_all();
							$.each(state.core.selected, function (i, v) {
								_this.select_node(v, false, true);
							});
							delete state.core.selected;
							this.set_state(state, callback);
							return false;
						}
						for(i in state) {
							if(state.hasOwnProperty(i) && i !== "core" && $.inArray(i, this.settings.plugins) === -1) {
								delete state[i];
							}
						}
						if($.isEmptyObject(state.core)) {
							delete state.core;
							this.set_state(state, callback);
							return false;
						}
					}
					if($.isEmptyObject(state)) {
						state = null;
						if(callback) { callback.call(this); }
						/**
						 * triggered when a `set_state` call completes
						 * @event
						 * @name set_state.jstree
						 */
						this.trigger('set_state');
						return false;
					}
					return true;
				}
				return false;
			},
			/**
			 * refreshes the tree - all nodes are reloaded with calls to `load_node`.
			 * @name refresh()
			 * @param {Boolean} skip_loading an option to skip showing the loading indicator
			 * @param {Mixed} forget_state if set to `true` state will not be reapplied, if set to a function (receiving the current state as argument) the result of that function will be used as state
			 * @trigger refresh.jstree
			 */
			refresh : function (skip_loading, forget_state) {
				this._data.core.state = forget_state === true ? {} : this.get_state();
				if(forget_state && $.isFunction(forget_state)) { this._data.core.state = forget_state.call(this, this._data.core.state); }
				this._cnt = 0;
				this._model.data = {};
				this._model.data[$.jstree.root] = {
					id : $.jstree.root,
					parent : null,
					parents : [],
					children : [],
					children_d : [],
					state : { loaded : false }
				};
				this._data.core.selected = [];
				this._data.core.last_clicked = null;
				this._data.core.focused = null;
	
				var c = this.get_container_ul()[0].className;
				if(!skip_loading) {
					this.element.html("<"+"ul class='"+c+"' role='group'><"+"li class='jstree-initial-node jstree-loading jstree-leaf jstree-last' role='treeitem' id='j"+this._id+"_loading'><i class='jstree-icon jstree-ocl'></i><"+"a class='jstree-anchor' href='#'><i class='jstree-icon jstree-themeicon-hidden'></i>" + this.get_string("Loading ...") + "</a></li></ul>");
					this.element.attr('aria-activedescendant','j'+this._id+'_loading');
				}
				this.load_node($.jstree.root, function (o, s) {
					if(s) {
						this.get_container_ul()[0].className = c;
						if(this._firstChild(this.get_container_ul()[0])) {
							this.element.attr('aria-activedescendant',this._firstChild(this.get_container_ul()[0]).id);
						}
						this.set_state($.extend(true, {}, this._data.core.state), function () {
							/**
							 * triggered when a `refresh` call completes
							 * @event
							 * @name refresh.jstree
							 */
							this.trigger('refresh');
						});
					}
					this._data.core.state = null;
				});
			},
			/**
			 * refreshes a node in the tree (reload its children) all opened nodes inside that node are reloaded with calls to `load_node`.
			 * @name refresh_node(obj)
			 * @param  {mixed} obj the node
			 * @trigger refresh_node.jstree
			 */
			refresh_node : function (obj) {
				obj = this.get_node(obj);
				if(!obj || obj.id === $.jstree.root) { return false; }
				var opened = [], to_load = [], s = this._data.core.selected.concat([]);
				to_load.push(obj.id);
				if(obj.state.opened === true) { opened.push(obj.id); }
				this.get_node(obj, true).find('.jstree-open').each(function() { to_load.push(this.id); opened.push(this.id); });
				this._load_nodes(to_load, $.proxy(function (nodes) {
					this.open_node(opened, false, 0);
					this.select_node(s);
					/**
					 * triggered when a node is refreshed
					 * @event
					 * @name refresh_node.jstree
					 * @param {Object} node - the refreshed node
					 * @param {Array} nodes - an array of the IDs of the nodes that were reloaded
					 */
					this.trigger('refresh_node', { 'node' : obj, 'nodes' : nodes });
				}, this), false, true);
			},
			/**
			 * set (change) the ID of a node
			 * @name set_id(obj, id)
			 * @param  {mixed} obj the node
			 * @param  {String} id the new ID
			 * @return {Boolean}
			 * @trigger set_id.jstree
			 */
			set_id : function (obj, id) {
				obj = this.get_node(obj);
				if(!obj || obj.id === $.jstree.root) { return false; }
				var i, j, m = this._model.data, old = obj.id;
				id = id.toString();
				// update parents (replace current ID with new one in children and children_d)
				m[obj.parent].children[$.inArray(obj.id, m[obj.parent].children)] = id;
				for(i = 0, j = obj.parents.length; i < j; i++) {
					m[obj.parents[i]].children_d[$.inArray(obj.id, m[obj.parents[i]].children_d)] = id;
				}
				// update children (replace current ID with new one in parent and parents)
				for(i = 0, j = obj.children.length; i < j; i++) {
					m[obj.children[i]].parent = id;
				}
				for(i = 0, j = obj.children_d.length; i < j; i++) {
					m[obj.children_d[i]].parents[$.inArray(obj.id, m[obj.children_d[i]].parents)] = id;
				}
				i = $.inArray(obj.id, this._data.core.selected);
				if(i !== -1) { this._data.core.selected[i] = id; }
				// update model and obj itself (obj.id, this._model.data[KEY])
				i = this.get_node(obj.id, true);
				if(i) {
					i.attr('id', id); //.children('.jstree-anchor').attr('id', id + '_anchor').end().attr('aria-labelledby', id + '_anchor');
					if(this.element.attr('aria-activedescendant') === obj.id) {
						this.element.attr('aria-activedescendant', id);
					}
				}
				delete m[obj.id];
				obj.id = id;
				obj.li_attr.id = id;
				m[id] = obj;
				/**
				 * triggered when a node id value is changed
				 * @event
				 * @name set_id.jstree
				 * @param {Object} node
				 * @param {String} old the old id
				 */
				this.trigger('set_id',{ "node" : obj, "new" : obj.id, "old" : old });
				return true;
			},
			/**
			 * get the text value of a node
			 * @name get_text(obj)
			 * @param  {mixed} obj the node
			 * @return {String}
			 */
			get_text : function (obj) {
				obj = this.get_node(obj);
				return (!obj || obj.id === $.jstree.root) ? false : obj.text;
			},
			/**
			 * set the text value of a node. Used internally, please use `rename_node(obj, val)`.
			 * @private
			 * @name set_text(obj, val)
			 * @param  {mixed} obj the node, you can pass an array to set the text on multiple nodes
			 * @param  {String} val the new text value
			 * @return {Boolean}
			 * @trigger set_text.jstree
			 */
			set_text : function (obj, val) {
				var t1, t2;
				if($.isArray(obj)) {
					obj = obj.slice();
					for(t1 = 0, t2 = obj.length; t1 < t2; t1++) {
						this.set_text(obj[t1], val);
					}
					return true;
				}
				obj = this.get_node(obj);
				if(!obj || obj.id === $.jstree.root) { return false; }
				obj.text = val;
				if(this.get_node(obj, true).length) {
					this.redraw_node(obj.id);
				}
				/**
				 * triggered when a node text value is changed
				 * @event
				 * @name set_text.jstree
				 * @param {Object} obj
				 * @param {String} text the new value
				 */
				this.trigger('set_text',{ "obj" : obj, "text" : val });
				return true;
			},
			/**
			 * gets a JSON representation of a node (or the whole tree)
			 * @name get_json([obj, options])
			 * @param  {mixed} obj
			 * @param  {Object} options
			 * @param  {Boolean} options.no_state do not return state information
			 * @param  {Boolean} options.no_id do not return ID
			 * @param  {Boolean} options.no_children do not include children
			 * @param  {Boolean} options.no_data do not include node data
			 * @param  {Boolean} options.no_li_attr do not include LI attributes
			 * @param  {Boolean} options.no_a_attr do not include A attributes
			 * @param  {Boolean} options.flat return flat JSON instead of nested
			 * @return {Object}
			 */
			get_json : function (obj, options, flat) {
				obj = this.get_node(obj || $.jstree.root);
				if(!obj) { return false; }
				if(options && options.flat && !flat) { flat = []; }
				var tmp = {
					'id' : obj.id,
					'text' : obj.text,
					'icon' : this.get_icon(obj),
					'li_attr' : $.extend(true, {}, obj.li_attr),
					'a_attr' : $.extend(true, {}, obj.a_attr),
					'state' : {},
					'data' : options && options.no_data ? false : $.extend(true, {}, obj.data)
					//( this.get_node(obj, true).length ? this.get_node(obj, true).data() : obj.data ),
				}, i, j;
				if(options && options.flat) {
					tmp.parent = obj.parent;
				}
				else {
					tmp.children = [];
				}
				if(!options || !options.no_state) {
					for(i in obj.state) {
						if(obj.state.hasOwnProperty(i)) {
							tmp.state[i] = obj.state[i];
						}
					}
				} else {
					delete tmp.state;
				}
				if(options && options.no_li_attr) {
					delete tmp.li_attr;
				}
				if(options && options.no_a_attr) {
					delete tmp.a_attr;
				}
				if(options && options.no_id) {
					delete tmp.id;
					if(tmp.li_attr && tmp.li_attr.id) {
						delete tmp.li_attr.id;
					}
					if(tmp.a_attr && tmp.a_attr.id) {
						delete tmp.a_attr.id;
					}
				}
				if(options && options.flat && obj.id !== $.jstree.root) {
					flat.push(tmp);
				}
				if(!options || !options.no_children) {
					for(i = 0, j = obj.children.length; i < j; i++) {
						if(options && options.flat) {
							this.get_json(obj.children[i], options, flat);
						}
						else {
							tmp.children.push(this.get_json(obj.children[i], options));
						}
					}
				}
				return options && options.flat ? flat : (obj.id === $.jstree.root ? tmp.children : tmp);
			},
			/**
			 * create a new node (do not confuse with load_node)
			 * @name create_node([par, node, pos, callback, is_loaded])
			 * @param  {mixed}   par       the parent node (to create a root node use either "#" (string) or `null`)
			 * @param  {mixed}   node      the data for the new node (a valid JSON object, or a simple string with the name)
			 * @param  {mixed}   pos       the index at which to insert the node, "first" and "last" are also supported, default is "last"
			 * @param  {Function} callback a function to be called once the node is created
			 * @param  {Boolean} is_loaded internal argument indicating if the parent node was succesfully loaded
			 * @return {String}            the ID of the newly create node
			 * @trigger model.jstree, create_node.jstree
			 */
			create_node : function (par, node, pos, callback, is_loaded) {
				if(par === null) { par = $.jstree.root; }
				par = this.get_node(par);
				if(!par) { return false; }
				pos = pos === undefined ? "last" : pos;
				if(!pos.toString().match(/^(before|after)$/) && !is_loaded && !this.is_loaded(par)) {
					return this.load_node(par, function () { this.create_node(par, node, pos, callback, true); });
				}
				if(!node) { node = { "text" : this.get_string('New node') }; }
				if(typeof node === "string") { node = { "text" : node }; }
				if(node.text === undefined) { node.text = this.get_string('New node'); }
				var tmp, dpc, i, j;
	
				if(par.id === $.jstree.root) {
					if(pos === "before") { pos = "first"; }
					if(pos === "after") { pos = "last"; }
				}
				switch(pos) {
					case "before":
						tmp = this.get_node(par.parent);
						pos = $.inArray(par.id, tmp.children);
						par = tmp;
						break;
					case "after" :
						tmp = this.get_node(par.parent);
						pos = $.inArray(par.id, tmp.children) + 1;
						par = tmp;
						break;
					case "inside":
					case "first":
						pos = 0;
						break;
					case "last":
						pos = par.children.length;
						break;
					default:
						if(!pos) { pos = 0; }
						break;
				}
				if(pos > par.children.length) { pos = par.children.length; }
				if(!node.id) { node.id = true; }
				if(!this.check("create_node", node, par, pos)) {
					this.settings.core.error.call(this, this._data.core.last_error);
					return false;
				}
				if(node.id === true) { delete node.id; }
				node = this._parse_model_from_json(node, par.id, par.parents.concat());
				if(!node) { return false; }
				tmp = this.get_node(node);
				dpc = [];
				dpc.push(node);
				dpc = dpc.concat(tmp.children_d);
				this.trigger('model', { "nodes" : dpc, "parent" : par.id });
	
				par.children_d = par.children_d.concat(dpc);
				for(i = 0, j = par.parents.length; i < j; i++) {
					this._model.data[par.parents[i]].children_d = this._model.data[par.parents[i]].children_d.concat(dpc);
				}
				node = tmp;
				tmp = [];
				for(i = 0, j = par.children.length; i < j; i++) {
					tmp[i >= pos ? i+1 : i] = par.children[i];
				}
				tmp[pos] = node.id;
				par.children = tmp;
	
				this.redraw_node(par, true);
				if(callback) { callback.call(this, this.get_node(node)); }
				/**
				 * triggered when a node is created
				 * @event
				 * @name create_node.jstree
				 * @param {Object} node
				 * @param {String} parent the parent's ID
				 * @param {Number} position the position of the new node among the parent's children
				 */
				this.trigger('create_node', { "node" : this.get_node(node), "parent" : par.id, "position" : pos });
				return node.id;
			},
			/**
			 * set the text value of a node
			 * @name rename_node(obj, val)
			 * @param  {mixed} obj the node, you can pass an array to rename multiple nodes to the same name
			 * @param  {String} val the new text value
			 * @return {Boolean}
			 * @trigger rename_node.jstree
			 */
			rename_node : function (obj, val) {
				var t1, t2, old;
				if($.isArray(obj)) {
					obj = obj.slice();
					for(t1 = 0, t2 = obj.length; t1 < t2; t1++) {
						this.rename_node(obj[t1], val);
					}
					return true;
				}
				obj = this.get_node(obj);
				if(!obj || obj.id === $.jstree.root) { return false; }
				old = obj.text;
				if(!this.check("rename_node", obj, this.get_parent(obj), val)) {
					this.settings.core.error.call(this, this._data.core.last_error);
					return false;
				}
				this.set_text(obj, val); // .apply(this, Array.prototype.slice.call(arguments))
				/**
				 * triggered when a node is renamed
				 * @event
				 * @name rename_node.jstree
				 * @param {Object} node
				 * @param {String} text the new value
				 * @param {String} old the old value
				 */
				this.trigger('rename_node', { "node" : obj, "text" : val, "old" : old });
				return true;
			},
			/**
			 * remove a node
			 * @name delete_node(obj)
			 * @param  {mixed} obj the node, you can pass an array to delete multiple nodes
			 * @return {Boolean}
			 * @trigger delete_node.jstree, changed.jstree
			 */
			delete_node : function (obj) {
				var t1, t2, par, pos, tmp, i, j, k, l, c, top, lft;
				if($.isArray(obj)) {
					obj = obj.slice();
					for(t1 = 0, t2 = obj.length; t1 < t2; t1++) {
						this.delete_node(obj[t1]);
					}
					return true;
				}
				obj = this.get_node(obj);
				if(!obj || obj.id === $.jstree.root) { return false; }
				par = this.get_node(obj.parent);
				pos = $.inArray(obj.id, par.children);
				c = false;
				if(!this.check("delete_node", obj, par, pos)) {
					this.settings.core.error.call(this, this._data.core.last_error);
					return false;
				}
				if(pos !== -1) {
					par.children = $.vakata.array_remove(par.children, pos);
				}
				tmp = obj.children_d.concat([]);
				tmp.push(obj.id);
				for(i = 0, j = obj.parents.length; i < j; i++) {
					this._model.data[obj.parents[i]].children_d = $.vakata.array_filter(this._model.data[obj.parents[i]].children_d, function (v) {
						return $.inArray(v, tmp) === -1;
					});
				}
				for(k = 0, l = tmp.length; k < l; k++) {
					if(this._model.data[tmp[k]].state.selected) {
						c = true;
						break;
					}
				}
				if (c) {
					this._data.core.selected = $.vakata.array_filter(this._data.core.selected, function (v) {
						return $.inArray(v, tmp) === -1;
					});
				}
				/**
				 * triggered when a node is deleted
				 * @event
				 * @name delete_node.jstree
				 * @param {Object} node
				 * @param {String} parent the parent's ID
				 */
				this.trigger('delete_node', { "node" : obj, "parent" : par.id });
				if(c) {
					this.trigger('changed', { 'action' : 'delete_node', 'node' : obj, 'selected' : this._data.core.selected, 'parent' : par.id });
				}
				for(k = 0, l = tmp.length; k < l; k++) {
					delete this._model.data[tmp[k]];
				}
				if($.inArray(this._data.core.focused, tmp) !== -1) {
					this._data.core.focused = null;
					top = this.element[0].scrollTop;
					lft = this.element[0].scrollLeft;
					if(par.id === $.jstree.root) {
						if (this._model.data[$.jstree.root].children[0]) {
							this.get_node(this._model.data[$.jstree.root].children[0], true).children('.jstree-anchor').focus();
						}
					}
					else {
						this.get_node(par, true).children('.jstree-anchor').focus();
					}
					this.element[0].scrollTop  = top;
					this.element[0].scrollLeft = lft;
				}
				this.redraw_node(par, true);
				return true;
			},
			/**
			 * check if an operation is premitted on the tree. Used internally.
			 * @private
			 * @name check(chk, obj, par, pos)
			 * @param  {String} chk the operation to check, can be "create_node", "rename_node", "delete_node", "copy_node" or "move_node"
			 * @param  {mixed} obj the node
			 * @param  {mixed} par the parent
			 * @param  {mixed} pos the position to insert at, or if "rename_node" - the new name
			 * @param  {mixed} more some various additional information, for example if a "move_node" operations is triggered by DND this will be the hovered node
			 * @return {Boolean}
			 */
			check : function (chk, obj, par, pos, more) {
				obj = obj && obj.id ? obj : this.get_node(obj);
				par = par && par.id ? par : this.get_node(par);
				var tmp = chk.match(/^move_node|copy_node|create_node$/i) ? par : obj,
					chc = this.settings.core.check_callback;
				if(chk === "move_node" || chk === "copy_node") {
					if((!more || !more.is_multi) && (obj.id === par.id || (chk === "move_node" && $.inArray(obj.id, par.children) === pos) || $.inArray(par.id, obj.children_d) !== -1)) {
						this._data.core.last_error = { 'error' : 'check', 'plugin' : 'core', 'id' : 'core_01', 'reason' : 'Moving parent inside child', 'data' : JSON.stringify({ 'chk' : chk, 'pos' : pos, 'obj' : obj && obj.id ? obj.id : false, 'par' : par && par.id ? par.id : false }) };
						return false;
					}
				}
				if(tmp && tmp.data) { tmp = tmp.data; }
				if(tmp && tmp.functions && (tmp.functions[chk] === false || tmp.functions[chk] === true)) {
					if(tmp.functions[chk] === false) {
						this._data.core.last_error = { 'error' : 'check', 'plugin' : 'core', 'id' : 'core_02', 'reason' : 'Node data prevents function: ' + chk, 'data' : JSON.stringify({ 'chk' : chk, 'pos' : pos, 'obj' : obj && obj.id ? obj.id : false, 'par' : par && par.id ? par.id : false }) };
					}
					return tmp.functions[chk];
				}
				if(chc === false || ($.isFunction(chc) && chc.call(this, chk, obj, par, pos, more) === false) || (chc && chc[chk] === false)) {
					this._data.core.last_error = { 'error' : 'check', 'plugin' : 'core', 'id' : 'core_03', 'reason' : 'User config for core.check_callback prevents function: ' + chk, 'data' : JSON.stringify({ 'chk' : chk, 'pos' : pos, 'obj' : obj && obj.id ? obj.id : false, 'par' : par && par.id ? par.id : false }) };
					return false;
				}
				return true;
			},
			/**
			 * get the last error
			 * @name last_error()
			 * @return {Object}
			 */
			last_error : function () {
				return this._data.core.last_error;
			},
			/**
			 * move a node to a new parent
			 * @name move_node(obj, par [, pos, callback, is_loaded])
			 * @param  {mixed} obj the node to move, pass an array to move multiple nodes
			 * @param  {mixed} par the new parent
			 * @param  {mixed} pos the position to insert at (besides integer values, "first" and "last" are supported, as well as "before" and "after"), defaults to integer `0`
			 * @param  {function} callback a function to call once the move is completed, receives 3 arguments - the node, the new parent and the position
			 * @param  {Boolean} is_loaded internal parameter indicating if the parent node has been loaded
			 * @param  {Boolean} skip_redraw internal parameter indicating if the tree should be redrawn
			 * @param  {Boolean} instance internal parameter indicating if the node comes from another instance
			 * @trigger move_node.jstree
			 */
			move_node : function (obj, par, pos, callback, is_loaded, skip_redraw, origin) {
				var t1, t2, old_par, old_pos, new_par, old_ins, is_multi, dpc, tmp, i, j, k, l, p;
	
				par = this.get_node(par);
				pos = pos === undefined ? 0 : pos;
				if(!par) { return false; }
				if(!pos.toString().match(/^(before|after)$/) && !is_loaded && !this.is_loaded(par)) {
					return this.load_node(par, function () { this.move_node(obj, par, pos, callback, true, false, origin); });
				}
	
				if($.isArray(obj)) {
					if(obj.length === 1) {
						obj = obj[0];
					}
					else {
						//obj = obj.slice();
						for(t1 = 0, t2 = obj.length; t1 < t2; t1++) {
							if((tmp = this.move_node(obj[t1], par, pos, callback, is_loaded, false, origin))) {
								par = tmp;
								pos = "after";
							}
						}
						this.redraw();
						return true;
					}
				}
				obj = obj && obj.id ? obj : this.get_node(obj);
	
				if(!obj || obj.id === $.jstree.root) { return false; }
	
				old_par = (obj.parent || $.jstree.root).toString();
				new_par = (!pos.toString().match(/^(before|after)$/) || par.id === $.jstree.root) ? par : this.get_node(par.parent);
				old_ins = origin ? origin : (this._model.data[obj.id] ? this : $.jstree.reference(obj.id));
				is_multi = !old_ins || !old_ins._id || (this._id !== old_ins._id);
				old_pos = old_ins && old_ins._id && old_par && old_ins._model.data[old_par] && old_ins._model.data[old_par].children ? $.inArray(obj.id, old_ins._model.data[old_par].children) : -1;
				if(old_ins && old_ins._id) {
					obj = old_ins._model.data[obj.id];
				}
	
				if(is_multi) {
					if((tmp = this.copy_node(obj, par, pos, callback, is_loaded, false, origin))) {
						if(old_ins) { old_ins.delete_node(obj); }
						return tmp;
					}
					return false;
				}
				//var m = this._model.data;
				if(par.id === $.jstree.root) {
					if(pos === "before") { pos = "first"; }
					if(pos === "after") { pos = "last"; }
				}
				switch(pos) {
					case "before":
						pos = $.inArray(par.id, new_par.children);
						break;
					case "after" :
						pos = $.inArray(par.id, new_par.children) + 1;
						break;
					case "inside":
					case "first":
						pos = 0;
						break;
					case "last":
						pos = new_par.children.length;
						break;
					default:
						if(!pos) { pos = 0; }
						break;
				}
				if(pos > new_par.children.length) { pos = new_par.children.length; }
				if(!this.check("move_node", obj, new_par, pos, { 'core' : true, 'origin' : origin, 'is_multi' : (old_ins && old_ins._id && old_ins._id !== this._id), 'is_foreign' : (!old_ins || !old_ins._id) })) {
					this.settings.core.error.call(this, this._data.core.last_error);
					return false;
				}
				if(obj.parent === new_par.id) {
					dpc = new_par.children.concat();
					tmp = $.inArray(obj.id, dpc);
					if(tmp !== -1) {
						dpc = $.vakata.array_remove(dpc, tmp);
						if(pos > tmp) { pos--; }
					}
					tmp = [];
					for(i = 0, j = dpc.length; i < j; i++) {
						tmp[i >= pos ? i+1 : i] = dpc[i];
					}
					tmp[pos] = obj.id;
					new_par.children = tmp;
					this._node_changed(new_par.id);
					this.redraw(new_par.id === $.jstree.root);
				}
				else {
					// clean old parent and up
					tmp = obj.children_d.concat();
					tmp.push(obj.id);
					for(i = 0, j = obj.parents.length; i < j; i++) {
						dpc = [];
						p = old_ins._model.data[obj.parents[i]].children_d;
						for(k = 0, l = p.length; k < l; k++) {
							if($.inArray(p[k], tmp) === -1) {
								dpc.push(p[k]);
							}
						}
						old_ins._model.data[obj.parents[i]].children_d = dpc;
					}
					old_ins._model.data[old_par].children = $.vakata.array_remove_item(old_ins._model.data[old_par].children, obj.id);
	
					// insert into new parent and up
					for(i = 0, j = new_par.parents.length; i < j; i++) {
						this._model.data[new_par.parents[i]].children_d = this._model.data[new_par.parents[i]].children_d.concat(tmp);
					}
					dpc = [];
					for(i = 0, j = new_par.children.length; i < j; i++) {
						dpc[i >= pos ? i+1 : i] = new_par.children[i];
					}
					dpc[pos] = obj.id;
					new_par.children = dpc;
					new_par.children_d.push(obj.id);
					new_par.children_d = new_par.children_d.concat(obj.children_d);
	
					// update object
					obj.parent = new_par.id;
					tmp = new_par.parents.concat();
					tmp.unshift(new_par.id);
					p = obj.parents.length;
					obj.parents = tmp;
	
					// update object children
					tmp = tmp.concat();
					for(i = 0, j = obj.children_d.length; i < j; i++) {
						this._model.data[obj.children_d[i]].parents = this._model.data[obj.children_d[i]].parents.slice(0,p*-1);
						Array.prototype.push.apply(this._model.data[obj.children_d[i]].parents, tmp);
					}
	
					if(old_par === $.jstree.root || new_par.id === $.jstree.root) {
						this._model.force_full_redraw = true;
					}
					if(!this._model.force_full_redraw) {
						this._node_changed(old_par);
						this._node_changed(new_par.id);
					}
					if(!skip_redraw) {
						this.redraw();
					}
				}
				if(callback) { callback.call(this, obj, new_par, pos); }
				/**
				 * triggered when a node is moved
				 * @event
				 * @name move_node.jstree
				 * @param {Object} node
				 * @param {String} parent the parent's ID
				 * @param {Number} position the position of the node among the parent's children
				 * @param {String} old_parent the old parent of the node
				 * @param {Number} old_position the old position of the node
				 * @param {Boolean} is_multi do the node and new parent belong to different instances
				 * @param {jsTree} old_instance the instance the node came from
				 * @param {jsTree} new_instance the instance of the new parent
				 */
				this.trigger('move_node', { "node" : obj, "parent" : new_par.id, "position" : pos, "old_parent" : old_par, "old_position" : old_pos, 'is_multi' : (old_ins && old_ins._id && old_ins._id !== this._id), 'is_foreign' : (!old_ins || !old_ins._id), 'old_instance' : old_ins, 'new_instance' : this });
				return obj.id;
			},
			/**
			 * copy a node to a new parent
			 * @name copy_node(obj, par [, pos, callback, is_loaded])
			 * @param  {mixed} obj the node to copy, pass an array to copy multiple nodes
			 * @param  {mixed} par the new parent
			 * @param  {mixed} pos the position to insert at (besides integer values, "first" and "last" are supported, as well as "before" and "after"), defaults to integer `0`
			 * @param  {function} callback a function to call once the move is completed, receives 3 arguments - the node, the new parent and the position
			 * @param  {Boolean} is_loaded internal parameter indicating if the parent node has been loaded
			 * @param  {Boolean} skip_redraw internal parameter indicating if the tree should be redrawn
			 * @param  {Boolean} instance internal parameter indicating if the node comes from another instance
			 * @trigger model.jstree copy_node.jstree
			 */
			copy_node : function (obj, par, pos, callback, is_loaded, skip_redraw, origin) {
				var t1, t2, dpc, tmp, i, j, node, old_par, new_par, old_ins, is_multi;
	
				par = this.get_node(par);
				pos = pos === undefined ? 0 : pos;
				if(!par) { return false; }
				if(!pos.toString().match(/^(before|after)$/) && !is_loaded && !this.is_loaded(par)) {
					return this.load_node(par, function () { this.copy_node(obj, par, pos, callback, true, false, origin); });
				}
	
				if($.isArray(obj)) {
					if(obj.length === 1) {
						obj = obj[0];
					}
					else {
						//obj = obj.slice();
						for(t1 = 0, t2 = obj.length; t1 < t2; t1++) {
							if((tmp = this.copy_node(obj[t1], par, pos, callback, is_loaded, true, origin))) {
								par = tmp;
								pos = "after";
							}
						}
						this.redraw();
						return true;
					}
				}
				obj = obj && obj.id ? obj : this.get_node(obj);
				if(!obj || obj.id === $.jstree.root) { return false; }
	
				old_par = (obj.parent || $.jstree.root).toString();
				new_par = (!pos.toString().match(/^(before|after)$/) || par.id === $.jstree.root) ? par : this.get_node(par.parent);
				old_ins = origin ? origin : (this._model.data[obj.id] ? this : $.jstree.reference(obj.id));
				is_multi = !old_ins || !old_ins._id || (this._id !== old_ins._id);
	
				if(old_ins && old_ins._id) {
					obj = old_ins._model.data[obj.id];
				}
	
				if(par.id === $.jstree.root) {
					if(pos === "before") { pos = "first"; }
					if(pos === "after") { pos = "last"; }
				}
				switch(pos) {
					case "before":
						pos = $.inArray(par.id, new_par.children);
						break;
					case "after" :
						pos = $.inArray(par.id, new_par.children) + 1;
						break;
					case "inside":
					case "first":
						pos = 0;
						break;
					case "last":
						pos = new_par.children.length;
						break;
					default:
						if(!pos) { pos = 0; }
						break;
				}
				if(pos > new_par.children.length) { pos = new_par.children.length; }
				if(!this.check("copy_node", obj, new_par, pos, { 'core' : true, 'origin' : origin, 'is_multi' : (old_ins && old_ins._id && old_ins._id !== this._id), 'is_foreign' : (!old_ins || !old_ins._id) })) {
					this.settings.core.error.call(this, this._data.core.last_error);
					return false;
				}
				node = old_ins ? old_ins.get_json(obj, { no_id : true, no_data : true, no_state : true }) : obj;
				if(!node) { return false; }
				if(node.id === true) { delete node.id; }
				node = this._parse_model_from_json(node, new_par.id, new_par.parents.concat());
				if(!node) { return false; }
				tmp = this.get_node(node);
				if(obj && obj.state && obj.state.loaded === false) { tmp.state.loaded = false; }
				dpc = [];
				dpc.push(node);
				dpc = dpc.concat(tmp.children_d);
				this.trigger('model', { "nodes" : dpc, "parent" : new_par.id });
	
				// insert into new parent and up
				for(i = 0, j = new_par.parents.length; i < j; i++) {
					this._model.data[new_par.parents[i]].children_d = this._model.data[new_par.parents[i]].children_d.concat(dpc);
				}
				dpc = [];
				for(i = 0, j = new_par.children.length; i < j; i++) {
					dpc[i >= pos ? i+1 : i] = new_par.children[i];
				}
				dpc[pos] = tmp.id;
				new_par.children = dpc;
				new_par.children_d.push(tmp.id);
				new_par.children_d = new_par.children_d.concat(tmp.children_d);
	
				if(new_par.id === $.jstree.root) {
					this._model.force_full_redraw = true;
				}
				if(!this._model.force_full_redraw) {
					this._node_changed(new_par.id);
				}
				if(!skip_redraw) {
					this.redraw(new_par.id === $.jstree.root);
				}
				if(callback) { callback.call(this, tmp, new_par, pos); }
				/**
				 * triggered when a node is copied
				 * @event
				 * @name copy_node.jstree
				 * @param {Object} node the copied node
				 * @param {Object} original the original node
				 * @param {String} parent the parent's ID
				 * @param {Number} position the position of the node among the parent's children
				 * @param {String} old_parent the old parent of the node
				 * @param {Number} old_position the position of the original node
				 * @param {Boolean} is_multi do the node and new parent belong to different instances
				 * @param {jsTree} old_instance the instance the node came from
				 * @param {jsTree} new_instance the instance of the new parent
				 */
				this.trigger('copy_node', { "node" : tmp, "original" : obj, "parent" : new_par.id, "position" : pos, "old_parent" : old_par, "old_position" : old_ins && old_ins._id && old_par && old_ins._model.data[old_par] && old_ins._model.data[old_par].children ? $.inArray(obj.id, old_ins._model.data[old_par].children) : -1,'is_multi' : (old_ins && old_ins._id && old_ins._id !== this._id), 'is_foreign' : (!old_ins || !old_ins._id), 'old_instance' : old_ins, 'new_instance' : this });
				return tmp.id;
			},
			/**
			 * cut a node (a later call to `paste(obj)` would move the node)
			 * @name cut(obj)
			 * @param  {mixed} obj multiple objects can be passed using an array
			 * @trigger cut.jstree
			 */
			cut : function (obj) {
				if(!obj) { obj = this._data.core.selected.concat(); }
				if(!$.isArray(obj)) { obj = [obj]; }
				if(!obj.length) { return false; }
				var tmp = [], o, t1, t2;
				for(t1 = 0, t2 = obj.length; t1 < t2; t1++) {
					o = this.get_node(obj[t1]);
					if(o && o.id && o.id !== $.jstree.root) { tmp.push(o); }
				}
				if(!tmp.length) { return false; }
				ccp_node = tmp;
				ccp_inst = this;
				ccp_mode = 'move_node';
				/**
				 * triggered when nodes are added to the buffer for moving
				 * @event
				 * @name cut.jstree
				 * @param {Array} node
				 */
				this.trigger('cut', { "node" : obj });
			},
			/**
			 * copy a node (a later call to `paste(obj)` would copy the node)
			 * @name copy(obj)
			 * @param  {mixed} obj multiple objects can be passed using an array
			 * @trigger copy.jstree
			 */
			copy : function (obj) {
				if(!obj) { obj = this._data.core.selected.concat(); }
				if(!$.isArray(obj)) { obj = [obj]; }
				if(!obj.length) { return false; }
				var tmp = [], o, t1, t2;
				for(t1 = 0, t2 = obj.length; t1 < t2; t1++) {
					o = this.get_node(obj[t1]);
					if(o && o.id && o.id !== $.jstree.root) { tmp.push(o); }
				}
				if(!tmp.length) { return false; }
				ccp_node = tmp;
				ccp_inst = this;
				ccp_mode = 'copy_node';
				/**
				 * triggered when nodes are added to the buffer for copying
				 * @event
				 * @name copy.jstree
				 * @param {Array} node
				 */
				this.trigger('copy', { "node" : obj });
			},
			/**
			 * get the current buffer (any nodes that are waiting for a paste operation)
			 * @name get_buffer()
			 * @return {Object} an object consisting of `mode` ("copy_node" or "move_node"), `node` (an array of objects) and `inst` (the instance)
			 */
			get_buffer : function () {
				return { 'mode' : ccp_mode, 'node' : ccp_node, 'inst' : ccp_inst };
			},
			/**
			 * check if there is something in the buffer to paste
			 * @name can_paste()
			 * @return {Boolean}
			 */
			can_paste : function () {
				return ccp_mode !== false && ccp_node !== false; // && ccp_inst._model.data[ccp_node];
			},
			/**
			 * copy or move the previously cut or copied nodes to a new parent
			 * @name paste(obj [, pos])
			 * @param  {mixed} obj the new parent
			 * @param  {mixed} pos the position to insert at (besides integer, "first" and "last" are supported), defaults to integer `0`
			 * @trigger paste.jstree
			 */
			paste : function (obj, pos) {
				obj = this.get_node(obj);
				if(!obj || !ccp_mode || !ccp_mode.match(/^(copy_node|move_node)$/) || !ccp_node) { return false; }
				if(this[ccp_mode](ccp_node, obj, pos, false, false, false, ccp_inst)) {
					/**
					 * triggered when paste is invoked
					 * @event
					 * @name paste.jstree
					 * @param {String} parent the ID of the receiving node
					 * @param {Array} node the nodes in the buffer
					 * @param {String} mode the performed operation - "copy_node" or "move_node"
					 */
					this.trigger('paste', { "parent" : obj.id, "node" : ccp_node, "mode" : ccp_mode });
				}
				ccp_node = false;
				ccp_mode = false;
				ccp_inst = false;
			},
			/**
			 * clear the buffer of previously copied or cut nodes
			 * @name clear_buffer()
			 * @trigger clear_buffer.jstree
			 */
			clear_buffer : function () {
				ccp_node = false;
				ccp_mode = false;
				ccp_inst = false;
				/**
				 * triggered when the copy / cut buffer is cleared
				 * @event
				 * @name clear_buffer.jstree
				 */
				this.trigger('clear_buffer');
			},
			/**
			 * put a node in edit mode (input field to rename the node)
			 * @name edit(obj [, default_text, callback])
			 * @param  {mixed} obj
			 * @param  {String} default_text the text to populate the input with (if omitted or set to a non-string value the node's text value is used)
			 * @param  {Function} callback a function to be called once the text box is blurred, it is called in the instance's scope and receives the node, a status parameter (true if the rename is successful, false otherwise) and a boolean indicating if the user cancelled the edit. You can access the node's title using .text
			 */
			edit : function (obj, default_text, callback) {
				var rtl, w, a, s, t, h1, h2, fn, tmp, cancel = false;
				obj = this.get_node(obj);
				if(!obj) { return false; }
				if(this.settings.core.check_callback === false) {
					this._data.core.last_error = { 'error' : 'check', 'plugin' : 'core', 'id' : 'core_07', 'reason' : 'Could not edit node because of check_callback' };
					this.settings.core.error.call(this, this._data.core.last_error);
					return false;
				}
				tmp = obj;
				default_text = typeof default_text === 'string' ? default_text : obj.text;
				this.set_text(obj, "");
				obj = this._open_to(obj);
				tmp.text = default_text;
	
				rtl = this._data.core.rtl;
				w  = this.element.width();
				this._data.core.focused = tmp.id;
				a  = obj.children('.jstree-anchor').focus();
				s  = $('<span>');
				/*!
				oi = obj.children("i:visible"),
				ai = a.children("i:visible"),
				w1 = oi.width() * oi.length,
				w2 = ai.width() * ai.length,
				*/
				t  = default_text;
				h1 = $("<"+"div />", { css : { "position" : "absolute", "top" : "-200px", "left" : (rtl ? "0px" : "-1000px"), "visibility" : "hidden" } }).appendTo("body");
				h2 = $("<"+"input />", {
							"value" : t,
							"class" : "jstree-rename-input",
							// "size" : t.length,
							"css" : {
								"padding" : "0",
								"border" : "1px solid silver",
								"box-sizing" : "border-box",
								"display" : "inline-block",
								"height" : (this._data.core.li_height) + "px",
								"lineHeight" : (this._data.core.li_height) + "px",
								"width" : "150px" // will be set a bit further down
							},
							"blur" : $.proxy(function (e) {
								e.stopImmediatePropagation();
								e.preventDefault();
								var i = s.children(".jstree-rename-input"),
									v = i.val(),
									f = this.settings.core.force_text,
									nv;
								if(v === "") { v = t; }
								h1.remove();
								s.replaceWith(a);
								s.remove();
								t = f ? t : $('<div></div>').append($.parseHTML(t)).html();
								this.set_text(obj, t);
								nv = !!this.rename_node(obj, f ? $('<div></div>').text(v).text() : $('<div></div>').append($.parseHTML(v)).html());
								if(!nv) {
									this.set_text(obj, t); // move this up? and fix #483
								}
								this._data.core.focused = tmp.id;
								setTimeout($.proxy(function () {
									var node = this.get_node(tmp.id, true);
									if(node.length) {
										this._data.core.focused = tmp.id;
										node.children('.jstree-anchor').focus();
									}
								}, this), 0);
								if(callback) {
									callback.call(this, tmp, nv, cancel);
								}
								h2 = null;
							}, this),
							"keydown" : function (e) {
								var key = e.which;
								if(key === 27) {
									cancel = true;
									this.value = t;
								}
								if(key === 27 || key === 13 || key === 37 || key === 38 || key === 39 || key === 40 || key === 32) {
									e.stopImmediatePropagation();
								}
								if(key === 27 || key === 13) {
									e.preventDefault();
									this.blur();
								}
							},
							"click" : function (e) { e.stopImmediatePropagation(); },
							"mousedown" : function (e) { e.stopImmediatePropagation(); },
							"keyup" : function (e) {
								h2.width(Math.min(h1.text("pW" + this.value).width(),w));
							},
							"keypress" : function(e) {
								if(e.which === 13) { return false; }
							}
						});
					fn = {
							fontFamily		: a.css('fontFamily')		|| '',
							fontSize		: a.css('fontSize')			|| '',
							fontWeight		: a.css('fontWeight')		|| '',
							fontStyle		: a.css('fontStyle')		|| '',
							fontStretch		: a.css('fontStretch')		|| '',
							fontVariant		: a.css('fontVariant')		|| '',
							letterSpacing	: a.css('letterSpacing')	|| '',
							wordSpacing		: a.css('wordSpacing')		|| ''
					};
				s.attr('class', a.attr('class')).append(a.contents().clone()).append(h2);
				a.replaceWith(s);
				h1.css(fn);
				h2.css(fn).width(Math.min(h1.text("pW" + h2[0].value).width(),w))[0].select();
				$(document).one('mousedown.jstree touchstart.jstree dnd_start.vakata', function (e) {
					if (h2 && e.target !== h2) {
						$(h2).blur();
					}
				});
			},
	
	
			/**
			 * changes the theme
			 * @name set_theme(theme_name [, theme_url])
			 * @param {String} theme_name the name of the new theme to apply
			 * @param {mixed} theme_url  the location of the CSS file for this theme. Omit or set to `false` if you manually included the file. Set to `true` to autoload from the `core.themes.dir` directory.
			 * @trigger set_theme.jstree
			 */
			set_theme : function (theme_name, theme_url) {
				if(!theme_name) { return false; }
				if(theme_url === true) {
					var dir = this.settings.core.themes.dir;
					if(!dir) { dir = $.jstree.path + '/themes'; }
					theme_url = dir + '/' + theme_name + '/style.css';
				}
				if(theme_url && $.inArray(theme_url, themes_loaded) === -1) {
					$('head').append('<'+'link rel="stylesheet" href="' + theme_url + '" type="text/css" />');
					themes_loaded.push(theme_url);
				}
				if(this._data.core.themes.name) {
					this.element.removeClass('jstree-' + this._data.core.themes.name);
				}
				this._data.core.themes.name = theme_name;
				this.element.addClass('jstree-' + theme_name);
				this.element[this.settings.core.themes.responsive ? 'addClass' : 'removeClass' ]('jstree-' + theme_name + '-responsive');
				/**
				 * triggered when a theme is set
				 * @event
				 * @name set_theme.jstree
				 * @param {String} theme the new theme
				 */
				this.trigger('set_theme', { 'theme' : theme_name });
			},
			/**
			 * gets the name of the currently applied theme name
			 * @name get_theme()
			 * @return {String}
			 */
			get_theme : function () { return this._data.core.themes.name; },
			/**
			 * changes the theme variant (if the theme has variants)
			 * @name set_theme_variant(variant_name)
			 * @param {String|Boolean} variant_name the variant to apply (if `false` is used the current variant is removed)
			 */
			set_theme_variant : function (variant_name) {
				if(this._data.core.themes.variant) {
					this.element.removeClass('jstree-' + this._data.core.themes.name + '-' + this._data.core.themes.variant);
				}
				this._data.core.themes.variant = variant_name;
				if(variant_name) {
					this.element.addClass('jstree-' + this._data.core.themes.name + '-' + this._data.core.themes.variant);
				}
			},
			/**
			 * gets the name of the currently applied theme variant
			 * @name get_theme()
			 * @return {String}
			 */
			get_theme_variant : function () { return this._data.core.themes.variant; },
			/**
			 * shows a striped background on the container (if the theme supports it)
			 * @name show_stripes()
			 */
			show_stripes : function () {
				this._data.core.themes.stripes = true;
				this.get_container_ul().addClass("jstree-striped");
				/**
				 * triggered when stripes are shown
				 * @event
				 * @name show_stripes.jstree
				 */
				this.trigger('show_stripes');
			},
			/**
			 * hides the striped background on the container
			 * @name hide_stripes()
			 */
			hide_stripes : function () {
				this._data.core.themes.stripes = false;
				this.get_container_ul().removeClass("jstree-striped");
				/**
				 * triggered when stripes are hidden
				 * @event
				 * @name hide_stripes.jstree
				 */
				this.trigger('hide_stripes');
			},
			/**
			 * toggles the striped background on the container
			 * @name toggle_stripes()
			 */
			toggle_stripes : function () { if(this._data.core.themes.stripes) { this.hide_stripes(); } else { this.show_stripes(); } },
			/**
			 * shows the connecting dots (if the theme supports it)
			 * @name show_dots()
			 */
			show_dots : function () {
				this._data.core.themes.dots = true;
				this.get_container_ul().removeClass("jstree-no-dots");
				/**
				 * triggered when dots are shown
				 * @event
				 * @name show_dots.jstree
				 */
				this.trigger('show_dots');
			},
			/**
			 * hides the connecting dots
			 * @name hide_dots()
			 */
			hide_dots : function () {
				this._data.core.themes.dots = false;
				this.get_container_ul().addClass("jstree-no-dots");
				/**
				 * triggered when dots are hidden
				 * @event
				 * @name hide_dots.jstree
				 */
				this.trigger('hide_dots');
			},
			/**
			 * toggles the connecting dots
			 * @name toggle_dots()
			 */
			toggle_dots : function () { if(this._data.core.themes.dots) { this.hide_dots(); } else { this.show_dots(); } },
			/**
			 * show the node icons
			 * @name show_icons()
			 */
			show_icons : function () {
				this._data.core.themes.icons = true;
				this.get_container_ul().removeClass("jstree-no-icons");
				/**
				 * triggered when icons are shown
				 * @event
				 * @name show_icons.jstree
				 */
				this.trigger('show_icons');
			},
			/**
			 * hide the node icons
			 * @name hide_icons()
			 */
			hide_icons : function () {
				this._data.core.themes.icons = false;
				this.get_container_ul().addClass("jstree-no-icons");
				/**
				 * triggered when icons are hidden
				 * @event
				 * @name hide_icons.jstree
				 */
				this.trigger('hide_icons');
			},
			/**
			 * toggle the node icons
			 * @name toggle_icons()
			 */
			toggle_icons : function () { if(this._data.core.themes.icons) { this.hide_icons(); } else { this.show_icons(); } },
			/**
			 * show the node ellipsis
			 * @name show_icons()
			 */
			show_ellipsis : function () {
				this._data.core.themes.ellipsis = true;
				this.get_container_ul().addClass("jstree-ellipsis");
				/**
				 * triggered when ellisis is shown
				 * @event
				 * @name show_ellipsis.jstree
				 */
				this.trigger('show_ellipsis');
			},
			/**
			 * hide the node ellipsis
			 * @name hide_ellipsis()
			 */
			hide_ellipsis : function () {
				this._data.core.themes.ellipsis = false;
				this.get_container_ul().removeClass("jstree-ellipsis");
				/**
				 * triggered when ellisis is hidden
				 * @event
				 * @name hide_ellipsis.jstree
				 */
				this.trigger('hide_ellipsis');
			},
			/**
			 * toggle the node ellipsis
			 * @name toggle_icons()
			 */
			toggle_ellipsis : function () { if(this._data.core.themes.ellipsis) { this.hide_ellipsis(); } else { this.show_ellipsis(); } },
			/**
			 * set the node icon for a node
			 * @name set_icon(obj, icon)
			 * @param {mixed} obj
			 * @param {String} icon the new icon - can be a path to an icon or a className, if using an image that is in the current directory use a `./` prefix, otherwise it will be detected as a class
			 */
			set_icon : function (obj, icon) {
				var t1, t2, dom, old;
				if($.isArray(obj)) {
					obj = obj.slice();
					for(t1 = 0, t2 = obj.length; t1 < t2; t1++) {
						this.set_icon(obj[t1], icon);
					}
					return true;
				}
				obj = this.get_node(obj);
				if(!obj || obj.id === $.jstree.root) { return false; }
				old = obj.icon;
				obj.icon = icon === true || icon === null || icon === undefined || icon === '' ? true : icon;
				dom = this.get_node(obj, true).children(".jstree-anchor").children(".jstree-themeicon");
				if(icon === false) {
					this.hide_icon(obj);
				}
				else if(icon === true || icon === null || icon === undefined || icon === '') {
					dom.removeClass('jstree-themeicon-custom ' + old).css("background","").removeAttr("rel");
					if(old === false) { this.show_icon(obj); }
				}
				else if(icon.indexOf("/") === -1 && icon.indexOf(".") === -1) {
					dom.removeClass(old).css("background","");
					dom.addClass(icon + ' jstree-themeicon-custom').attr("rel",icon);
					if(old === false) { this.show_icon(obj); }
				}
				else {
					dom.removeClass(old).css("background","");
					dom.addClass('jstree-themeicon-custom').css("background", "url('" + icon + "') center center no-repeat").attr("rel",icon);
					if(old === false) { this.show_icon(obj); }
				}
				return true;
			},
			/**
			 * get the node icon for a node
			 * @name get_icon(obj)
			 * @param {mixed} obj
			 * @return {String}
			 */
			get_icon : function (obj) {
				obj = this.get_node(obj);
				return (!obj || obj.id === $.jstree.root) ? false : obj.icon;
			},
			/**
			 * hide the icon on an individual node
			 * @name hide_icon(obj)
			 * @param {mixed} obj
			 */
			hide_icon : function (obj) {
				var t1, t2;
				if($.isArray(obj)) {
					obj = obj.slice();
					for(t1 = 0, t2 = obj.length; t1 < t2; t1++) {
						this.hide_icon(obj[t1]);
					}
					return true;
				}
				obj = this.get_node(obj);
				if(!obj || obj === $.jstree.root) { return false; }
				obj.icon = false;
				this.get_node(obj, true).children(".jstree-anchor").children(".jstree-themeicon").addClass('jstree-themeicon-hidden');
				return true;
			},
			/**
			 * show the icon on an individual node
			 * @name show_icon(obj)
			 * @param {mixed} obj
			 */
			show_icon : function (obj) {
				var t1, t2, dom;
				if($.isArray(obj)) {
					obj = obj.slice();
					for(t1 = 0, t2 = obj.length; t1 < t2; t1++) {
						this.show_icon(obj[t1]);
					}
					return true;
				}
				obj = this.get_node(obj);
				if(!obj || obj === $.jstree.root) { return false; }
				dom = this.get_node(obj, true);
				obj.icon = dom.length ? dom.children(".jstree-anchor").children(".jstree-themeicon").attr('rel') : true;
				if(!obj.icon) { obj.icon = true; }
				dom.children(".jstree-anchor").children(".jstree-themeicon").removeClass('jstree-themeicon-hidden');
				return true;
			}
		};
	
		// helpers
		$.vakata = {};
		// collect attributes
		$.vakata.attributes = function(node, with_values) {
			node = $(node)[0];
			var attr = with_values ? {} : [];
			if(node && node.attributes) {
				$.each(node.attributes, function (i, v) {
					if($.inArray(v.name.toLowerCase(),['style','contenteditable','hasfocus','tabindex']) !== -1) { return; }
					if(v.value !== null && $.trim(v.value) !== '') {
						if(with_values) { attr[v.name] = v.value; }
						else { attr.push(v.name); }
					}
				});
			}
			return attr;
		};
		$.vakata.array_unique = function(array) {
			var a = [], i, j, l, o = {};
			for(i = 0, l = array.length; i < l; i++) {
				if(o[array[i]] === undefined) {
					a.push(array[i]);
					o[array[i]] = true;
				}
			}
			return a;
		};
		// remove item from array
		$.vakata.array_remove = function(array, from) {
			array.splice(from, 1);
			return array;
			//var rest = array.slice((to || from) + 1 || array.length);
			//array.length = from < 0 ? array.length + from : from;
			//array.push.apply(array, rest);
			//return array;
		};
		// remove item from array
		$.vakata.array_remove_item = function(array, item) {
			var tmp = $.inArray(item, array);
			return tmp !== -1 ? $.vakata.array_remove(array, tmp) : array;
		};
		$.vakata.array_filter = function(c,a,b,d,e) {
			if (c.filter) {
				return c.filter(a, b);
			}
			d=[];
			for (e in c) {
				if (~~e+''===e+'' && e>=0 && a.call(b,c[e],+e,c)) {
					d.push(c[e]);
				}
			}
			return d;
		};
	
	
	/**
	 * ### Changed plugin
	 *
	 * This plugin adds more information to the `changed.jstree` event. The new data is contained in the `changed` event data property, and contains a lists of `selected` and `deselected` nodes.
	 */
	
		$.jstree.plugins.changed = function (options, parent) {
			var last = [];
			this.trigger = function (ev, data) {
				var i, j;
				if(!data) {
					data = {};
				}
				if(ev.replace('.jstree','') === 'changed') {
					data.changed = { selected : [], deselected : [] };
					var tmp = {};
					for(i = 0, j = last.length; i < j; i++) {
						tmp[last[i]] = 1;
					}
					for(i = 0, j = data.selected.length; i < j; i++) {
						if(!tmp[data.selected[i]]) {
							data.changed.selected.push(data.selected[i]);
						}
						else {
							tmp[data.selected[i]] = 2;
						}
					}
					for(i = 0, j = last.length; i < j; i++) {
						if(tmp[last[i]] === 1) {
							data.changed.deselected.push(last[i]);
						}
					}
					last = data.selected.slice();
				}
				/**
				 * triggered when selection changes (the "changed" plugin enhances the original event with more data)
				 * @event
				 * @name changed.jstree
				 * @param {Object} node
				 * @param {Object} action the action that caused the selection to change
				 * @param {Array} selected the current selection
				 * @param {Object} changed an object containing two properties `selected` and `deselected` - both arrays of node IDs, which were selected or deselected since the last changed event
				 * @param {Object} event the event (if any) that triggered this changed event
				 * @plugin changed
				 */
				parent.trigger.call(this, ev, data);
			};
			this.refresh = function (skip_loading, forget_state) {
				last = [];
				return parent.refresh.apply(this, arguments);
			};
		};
	
	/**
	 * ### Checkbox plugin
	 *
	 * This plugin renders checkbox icons in front of each node, making multiple selection much easier.
	 * It also supports tri-state behavior, meaning that if a node has a few of its children checked it will be rendered as undetermined, and state will be propagated up.
	 */
	
		var _i = document.createElement('I');
		_i.className = 'jstree-icon jstree-checkbox';
		_i.setAttribute('role', 'presentation');
		/**
		 * stores all defaults for the checkbox plugin
		 * @name $.jstree.defaults.checkbox
		 * @plugin checkbox
		 */
		$.jstree.defaults.checkbox = {
			/**
			 * a boolean indicating if checkboxes should be visible (can be changed at a later time using `show_checkboxes()` and `hide_checkboxes`). Defaults to `true`.
			 * @name $.jstree.defaults.checkbox.visible
			 * @plugin checkbox
			 */
			visible				: true,
			/**
			 * a boolean indicating if checkboxes should cascade down and have an undetermined state. Defaults to `true`.
			 * @name $.jstree.defaults.checkbox.three_state
			 * @plugin checkbox
			 */
			three_state			: true,
			/**
			 * a boolean indicating if clicking anywhere on the node should act as clicking on the checkbox. Defaults to `true`.
			 * @name $.jstree.defaults.checkbox.whole_node
			 * @plugin checkbox
			 */
			whole_node			: true,
			/**
			 * a boolean indicating if the selected style of a node should be kept, or removed. Defaults to `true`.
			 * @name $.jstree.defaults.checkbox.keep_selected_style
			 * @plugin checkbox
			 */
			keep_selected_style	: true,
			/**
			 * This setting controls how cascading and undetermined nodes are applied.
			 * If 'up' is in the string - cascading up is enabled, if 'down' is in the string - cascading down is enabled, if 'undetermined' is in the string - undetermined nodes will be used.
			 * If `three_state` is set to `true` this setting is automatically set to 'up+down+undetermined'. Defaults to ''.
			 * @name $.jstree.defaults.checkbox.cascade
			 * @plugin checkbox
			 */
			cascade				: '',
			/**
			 * This setting controls if checkbox are bound to the general tree selection or to an internal array maintained by the checkbox plugin. Defaults to `true`, only set to `false` if you know exactly what you are doing.
			 * @name $.jstree.defaults.checkbox.tie_selection
			 * @plugin checkbox
			 */
			tie_selection		: true
		};
		$.jstree.plugins.checkbox = function (options, parent) {
			this.bind = function () {
				parent.bind.call(this);
				this._data.checkbox.uto = false;
				this._data.checkbox.selected = [];
				if(this.settings.checkbox.three_state) {
					this.settings.checkbox.cascade = 'up+down+undetermined';
				}
				this.element
					.on("init.jstree", $.proxy(function () {
							this._data.checkbox.visible = this.settings.checkbox.visible;
							if(!this.settings.checkbox.keep_selected_style) {
								this.element.addClass('jstree-checkbox-no-clicked');
							}
							if(this.settings.checkbox.tie_selection) {
								this.element.addClass('jstree-checkbox-selection');
							}
						}, this))
					.on("loading.jstree", $.proxy(function () {
							this[ this._data.checkbox.visible ? 'show_checkboxes' : 'hide_checkboxes' ]();
						}, this));
				if(this.settings.checkbox.cascade.indexOf('undetermined') !== -1) {
					this.element
						.on('changed.jstree uncheck_node.jstree check_node.jstree uncheck_all.jstree check_all.jstree move_node.jstree copy_node.jstree redraw.jstree open_node.jstree', $.proxy(function () {
								// only if undetermined is in setting
								if(this._data.checkbox.uto) { clearTimeout(this._data.checkbox.uto); }
								this._data.checkbox.uto = setTimeout($.proxy(this._undetermined, this), 50);
							}, this));
				}
				if(!this.settings.checkbox.tie_selection) {
					this.element
						.on('model.jstree', $.proxy(function (e, data) {
							var m = this._model.data,
								p = m[data.parent],
								dpc = data.nodes,
								i, j;
							for(i = 0, j = dpc.length; i < j; i++) {
								m[dpc[i]].state.checked = m[dpc[i]].state.checked || (m[dpc[i]].original && m[dpc[i]].original.state && m[dpc[i]].original.state.checked);
								if(m[dpc[i]].state.checked) {
									this._data.checkbox.selected.push(dpc[i]);
								}
							}
						}, this));
				}
				if(this.settings.checkbox.cascade.indexOf('up') !== -1 || this.settings.checkbox.cascade.indexOf('down') !== -1) {
					this.element
						.on('model.jstree', $.proxy(function (e, data) {
								var m = this._model.data,
									p = m[data.parent],
									dpc = data.nodes,
									chd = [],
									c, i, j, k, l, tmp, s = this.settings.checkbox.cascade, t = this.settings.checkbox.tie_selection;
	
								if(s.indexOf('down') !== -1) {
									// apply down
									if(p.state[ t ? 'selected' : 'checked' ]) {
										for(i = 0, j = dpc.length; i < j; i++) {
											m[dpc[i]].state[ t ? 'selected' : 'checked' ] = true;
										}
										this._data[ t ? 'core' : 'checkbox' ].selected = this._data[ t ? 'core' : 'checkbox' ].selected.concat(dpc);
									}
									else {
										for(i = 0, j = dpc.length; i < j; i++) {
											if(m[dpc[i]].state[ t ? 'selected' : 'checked' ]) {
												for(k = 0, l = m[dpc[i]].children_d.length; k < l; k++) {
													m[m[dpc[i]].children_d[k]].state[ t ? 'selected' : 'checked' ] = true;
												}
												this._data[ t ? 'core' : 'checkbox' ].selected = this._data[ t ? 'core' : 'checkbox' ].selected.concat(m[dpc[i]].children_d);
											}
										}
									}
								}
	
								if(s.indexOf('up') !== -1) {
									// apply up
									for(i = 0, j = p.children_d.length; i < j; i++) {
										if(!m[p.children_d[i]].children.length) {
											chd.push(m[p.children_d[i]].parent);
										}
									}
									chd = $.vakata.array_unique(chd);
									for(k = 0, l = chd.length; k < l; k++) {
										p = m[chd[k]];
										while(p && p.id !== $.jstree.root) {
											c = 0;
											for(i = 0, j = p.children.length; i < j; i++) {
												c += m[p.children[i]].state[ t ? 'selected' : 'checked' ];
											}
											if(c === j) {
												p.state[ t ? 'selected' : 'checked' ] = true;
												this._data[ t ? 'core' : 'checkbox' ].selected.push(p.id);
												tmp = this.get_node(p, true);
												if(tmp && tmp.length) {
													tmp.attr('aria-selected', true).children('.jstree-anchor').addClass( t ? 'jstree-clicked' : 'jstree-checked');
												}
											}
											else {
												break;
											}
											p = this.get_node(p.parent);
										}
									}
								}
	
								this._data[ t ? 'core' : 'checkbox' ].selected = $.vakata.array_unique(this._data[ t ? 'core' : 'checkbox' ].selected);
							}, this))
						.on(this.settings.checkbox.tie_selection ? 'select_node.jstree' : 'check_node.jstree', $.proxy(function (e, data) {
								var obj = data.node,
									m = this._model.data,
									par = this.get_node(obj.parent),
									dom = this.get_node(obj, true),
									i, j, c, tmp, s = this.settings.checkbox.cascade, t = this.settings.checkbox.tie_selection,
									sel = {}, cur = this._data[ t ? 'core' : 'checkbox' ].selected;
	
								for (i = 0, j = cur.length; i < j; i++) {
									sel[cur[i]] = true;
								}
								// apply down
								if(s.indexOf('down') !== -1) {
									//this._data[ t ? 'core' : 'checkbox' ].selected = $.vakata.array_unique(this._data[ t ? 'core' : 'checkbox' ].selected.concat(obj.children_d));
									for(i = 0, j = obj.children_d.length; i < j; i++) {
										sel[obj.children_d[i]] = true;
										tmp = m[obj.children_d[i]];
										tmp.state[ t ? 'selected' : 'checked' ] = true;
										if(tmp && tmp.original && tmp.original.state && tmp.original.state.undetermined) {
											tmp.original.state.undetermined = false;
										}
									}
								}
	
								// apply up
								if(s.indexOf('up') !== -1) {
									while(par && par.id !== $.jstree.root) {
										c = 0;
										for(i = 0, j = par.children.length; i < j; i++) {
											c += m[par.children[i]].state[ t ? 'selected' : 'checked' ];
										}
										if(c === j) {
											par.state[ t ? 'selected' : 'checked' ] = true;
											sel[par.id] = true;
											//this._data[ t ? 'core' : 'checkbox' ].selected.push(par.id);
											tmp = this.get_node(par, true);
											if(tmp && tmp.length) {
												tmp.attr('aria-selected', true).children('.jstree-anchor').addClass(t ? 'jstree-clicked' : 'jstree-checked');
											}
										}
										else {
											break;
										}
										par = this.get_node(par.parent);
									}
								}
	
								cur = [];
								for (i in sel) {
									if (sel.hasOwnProperty(i)) {
										cur.push(i);
									}
								}
								this._data[ t ? 'core' : 'checkbox' ].selected = cur;
	
								// apply down (process .children separately?)
								if(s.indexOf('down') !== -1 && dom.length) {
									dom.find('.jstree-anchor').addClass(t ? 'jstree-clicked' : 'jstree-checked').parent().attr('aria-selected', true);
								}
							}, this))
						.on(this.settings.checkbox.tie_selection ? 'deselect_all.jstree' : 'uncheck_all.jstree', $.proxy(function (e, data) {
								var obj = this.get_node($.jstree.root),
									m = this._model.data,
									i, j, tmp;
								for(i = 0, j = obj.children_d.length; i < j; i++) {
									tmp = m[obj.children_d[i]];
									if(tmp && tmp.original && tmp.original.state && tmp.original.state.undetermined) {
										tmp.original.state.undetermined = false;
									}
								}
							}, this))
						.on(this.settings.checkbox.tie_selection ? 'deselect_node.jstree' : 'uncheck_node.jstree', $.proxy(function (e, data) {
								var obj = data.node,
									dom = this.get_node(obj, true),
									i, j, tmp, s = this.settings.checkbox.cascade, t = this.settings.checkbox.tie_selection,
									cur = this._data[ t ? 'core' : 'checkbox' ].selected, sel = {};
								if(obj && obj.original && obj.original.state && obj.original.state.undetermined) {
									obj.original.state.undetermined = false;
								}
	
								// apply down
								if(s.indexOf('down') !== -1) {
									for(i = 0, j = obj.children_d.length; i < j; i++) {
										tmp = this._model.data[obj.children_d[i]];
										tmp.state[ t ? 'selected' : 'checked' ] = false;
										if(tmp && tmp.original && tmp.original.state && tmp.original.state.undetermined) {
											tmp.original.state.undetermined = false;
										}
									}
								}
	
								// apply up
								if(s.indexOf('up') !== -1) {
									for(i = 0, j = obj.parents.length; i < j; i++) {
										tmp = this._model.data[obj.parents[i]];
										tmp.state[ t ? 'selected' : 'checked' ] = false;
										if(tmp && tmp.original && tmp.original.state && tmp.original.state.undetermined) {
											tmp.original.state.undetermined = false;
										}
										tmp = this.get_node(obj.parents[i], true);
										if(tmp && tmp.length) {
											tmp.attr('aria-selected', false).children('.jstree-anchor').removeClass(t ? 'jstree-clicked' : 'jstree-checked');
										}
									}
								}
								sel = {};
								for(i = 0, j = cur.length; i < j; i++) {
									// apply down + apply up
									if(
										(s.indexOf('down') === -1 || $.inArray(cur[i], obj.children_d) === -1) &&
										(s.indexOf('up') === -1 || $.inArray(cur[i], obj.parents) === -1)
									) {
										sel[cur[i]] = true;
									}
								}
								cur = [];
								for (i in sel) {
									if (sel.hasOwnProperty(i)) {
										cur.push(i);
									}
								}
								this._data[ t ? 'core' : 'checkbox' ].selected = cur;
								
								// apply down (process .children separately?)
								if(s.indexOf('down') !== -1 && dom.length) {
									dom.find('.jstree-anchor').removeClass(t ? 'jstree-clicked' : 'jstree-checked').parent().attr('aria-selected', false);
								}
							}, this));
				}
				if(this.settings.checkbox.cascade.indexOf('up') !== -1) {
					this.element
						.on('delete_node.jstree', $.proxy(function (e, data) {
								// apply up (whole handler)
								var p = this.get_node(data.parent),
									m = this._model.data,
									i, j, c, tmp, t = this.settings.checkbox.tie_selection;
								while(p && p.id !== $.jstree.root && !p.state[ t ? 'selected' : 'checked' ]) {
									c = 0;
									for(i = 0, j = p.children.length; i < j; i++) {
										c += m[p.children[i]].state[ t ? 'selected' : 'checked' ];
									}
									if(j > 0 && c === j) {
										p.state[ t ? 'selected' : 'checked' ] = true;
										this._data[ t ? 'core' : 'checkbox' ].selected.push(p.id);
										tmp = this.get_node(p, true);
										if(tmp && tmp.length) {
											tmp.attr('aria-selected', true).children('.jstree-anchor').addClass(t ? 'jstree-clicked' : 'jstree-checked');
										}
									}
									else {
										break;
									}
									p = this.get_node(p.parent);
								}
							}, this))
						.on('move_node.jstree', $.proxy(function (e, data) {
								// apply up (whole handler)
								var is_multi = data.is_multi,
									old_par = data.old_parent,
									new_par = this.get_node(data.parent),
									m = this._model.data,
									p, c, i, j, tmp, t = this.settings.checkbox.tie_selection;
								if(!is_multi) {
									p = this.get_node(old_par);
									while(p && p.id !== $.jstree.root && !p.state[ t ? 'selected' : 'checked' ]) {
										c = 0;
										for(i = 0, j = p.children.length; i < j; i++) {
											c += m[p.children[i]].state[ t ? 'selected' : 'checked' ];
										}
										if(j > 0 && c === j) {
											p.state[ t ? 'selected' : 'checked' ] = true;
											this._data[ t ? 'core' : 'checkbox' ].selected.push(p.id);
											tmp = this.get_node(p, true);
											if(tmp && tmp.length) {
												tmp.attr('aria-selected', true).children('.jstree-anchor').addClass(t ? 'jstree-clicked' : 'jstree-checked');
											}
										}
										else {
											break;
										}
										p = this.get_node(p.parent);
									}
								}
								p = new_par;
								while(p && p.id !== $.jstree.root) {
									c = 0;
									for(i = 0, j = p.children.length; i < j; i++) {
										c += m[p.children[i]].state[ t ? 'selected' : 'checked' ];
									}
									if(c === j) {
										if(!p.state[ t ? 'selected' : 'checked' ]) {
											p.state[ t ? 'selected' : 'checked' ] = true;
											this._data[ t ? 'core' : 'checkbox' ].selected.push(p.id);
											tmp = this.get_node(p, true);
											if(tmp && tmp.length) {
												tmp.attr('aria-selected', true).children('.jstree-anchor').addClass(t ? 'jstree-clicked' : 'jstree-checked');
											}
										}
									}
									else {
										if(p.state[ t ? 'selected' : 'checked' ]) {
											p.state[ t ? 'selected' : 'checked' ] = false;
											this._data[ t ? 'core' : 'checkbox' ].selected = $.vakata.array_remove_item(this._data[ t ? 'core' : 'checkbox' ].selected, p.id);
											tmp = this.get_node(p, true);
											if(tmp && tmp.length) {
												tmp.attr('aria-selected', false).children('.jstree-anchor').removeClass(t ? 'jstree-clicked' : 'jstree-checked');
											}
										}
										else {
											break;
										}
									}
									p = this.get_node(p.parent);
								}
							}, this));
				}
			};
			/**
			 * set the undetermined state where and if necessary. Used internally.
			 * @private
			 * @name _undetermined()
			 * @plugin checkbox
			 */
			this._undetermined = function () {
				if(this.element === null) { return; }
				var i, j, k, l, o = {}, m = this._model.data, t = this.settings.checkbox.tie_selection, s = this._data[ t ? 'core' : 'checkbox' ].selected, p = [], tt = this;
				for(i = 0, j = s.length; i < j; i++) {
					if(m[s[i]] && m[s[i]].parents) {
						for(k = 0, l = m[s[i]].parents.length; k < l; k++) {
							if(o[m[s[i]].parents[k]] !== undefined) {
								break;
							}
							if(m[s[i]].parents[k] !== $.jstree.root) {
								o[m[s[i]].parents[k]] = true;
								p.push(m[s[i]].parents[k]);
							}
						}
					}
				}
				// attempt for server side undetermined state
				this.element.find('.jstree-closed').not(':has(.jstree-children)')
					.each(function () {
						var tmp = tt.get_node(this), tmp2;
						if(!tmp.state.loaded) {
							if(tmp.original && tmp.original.state && tmp.original.state.undetermined && tmp.original.state.undetermined === true) {
								if(o[tmp.id] === undefined && tmp.id !== $.jstree.root) {
									o[tmp.id] = true;
									p.push(tmp.id);
								}
								for(k = 0, l = tmp.parents.length; k < l; k++) {
									if(o[tmp.parents[k]] === undefined && tmp.parents[k] !== $.jstree.root) {
										o[tmp.parents[k]] = true;
										p.push(tmp.parents[k]);
									}
								}
							}
						}
						else {
							for(i = 0, j = tmp.children_d.length; i < j; i++) {
								tmp2 = m[tmp.children_d[i]];
								if(!tmp2.state.loaded && tmp2.original && tmp2.original.state && tmp2.original.state.undetermined && tmp2.original.state.undetermined === true) {
									if(o[tmp2.id] === undefined && tmp2.id !== $.jstree.root) {
										o[tmp2.id] = true;
										p.push(tmp2.id);
									}
									for(k = 0, l = tmp2.parents.length; k < l; k++) {
										if(o[tmp2.parents[k]] === undefined && tmp2.parents[k] !== $.jstree.root) {
											o[tmp2.parents[k]] = true;
											p.push(tmp2.parents[k]);
										}
									}
								}
							}
						}
					});
	
				this.element.find('.jstree-undetermined').removeClass('jstree-undetermined');
				for(i = 0, j = p.length; i < j; i++) {
					if(!m[p[i]].state[ t ? 'selected' : 'checked' ]) {
						s = this.get_node(p[i], true);
						if(s && s.length) {
							s.children('.jstree-anchor').children('.jstree-checkbox').addClass('jstree-undetermined');
						}
					}
				}
			};
			this.redraw_node = function(obj, deep, is_callback, force_render) {
				obj = parent.redraw_node.apply(this, arguments);
				if(obj) {
					var i, j, tmp = null, icon = null;
					for(i = 0, j = obj.childNodes.length; i < j; i++) {
						if(obj.childNodes[i] && obj.childNodes[i].className && obj.childNodes[i].className.indexOf("jstree-anchor") !== -1) {
							tmp = obj.childNodes[i];
							break;
						}
					}
					if(tmp) {
						if(!this.settings.checkbox.tie_selection && this._model.data[obj.id].state.checked) { tmp.className += ' jstree-checked'; }
						icon = _i.cloneNode(false);
						if(this._model.data[obj.id].state.checkbox_disabled) { icon.className += ' jstree-checkbox-disabled'; }
						tmp.insertBefore(icon, tmp.childNodes[0]);
					}
				}
				if(!is_callback && this.settings.checkbox.cascade.indexOf('undetermined') !== -1) {
					if(this._data.checkbox.uto) { clearTimeout(this._data.checkbox.uto); }
					this._data.checkbox.uto = setTimeout($.proxy(this._undetermined, this), 50);
				}
				return obj;
			};
			/**
			 * show the node checkbox icons
			 * @name show_checkboxes()
			 * @plugin checkbox
			 */
			this.show_checkboxes = function () { this._data.core.themes.checkboxes = true; this.get_container_ul().removeClass("jstree-no-checkboxes"); };
			/**
			 * hide the node checkbox icons
			 * @name hide_checkboxes()
			 * @plugin checkbox
			 */
			this.hide_checkboxes = function () { this._data.core.themes.checkboxes = false; this.get_container_ul().addClass("jstree-no-checkboxes"); };
			/**
			 * toggle the node icons
			 * @name toggle_checkboxes()
			 * @plugin checkbox
			 */
			this.toggle_checkboxes = function () { if(this._data.core.themes.checkboxes) { this.hide_checkboxes(); } else { this.show_checkboxes(); } };
			/**
			 * checks if a node is in an undetermined state
			 * @name is_undetermined(obj)
			 * @param  {mixed} obj
			 * @return {Boolean}
			 */
			this.is_undetermined = function (obj) {
				obj = this.get_node(obj);
				var s = this.settings.checkbox.cascade, i, j, t = this.settings.checkbox.tie_selection, d = this._data[ t ? 'core' : 'checkbox' ].selected, m = this._model.data;
				if(!obj || obj.state[ t ? 'selected' : 'checked' ] === true || s.indexOf('undetermined') === -1 || (s.indexOf('down') === -1 && s.indexOf('up') === -1)) {
					return false;
				}
				if(!obj.state.loaded && obj.original.state.undetermined === true) {
					return true;
				}
				for(i = 0, j = obj.children_d.length; i < j; i++) {
					if($.inArray(obj.children_d[i], d) !== -1 || (!m[obj.children_d[i]].state.loaded && m[obj.children_d[i]].original.state.undetermined)) {
						return true;
					}
				}
				return false;
			};
			/**
			 * disable a node's checkbox
			 * @name disable_checkbox(obj)
			 * @param {mixed} obj an array can be used too
			 * @trigger disable_checkbox.jstree
			 * @plugin checkbox
			 */
			this.disable_checkbox = function (obj) {
				var t1, t2, dom;
				if($.isArray(obj)) {
					obj = obj.slice();
					for(t1 = 0, t2 = obj.length; t1 < t2; t1++) {
						this.disable_checkbox(obj[t1]);
					}
					return true;
				}
				obj = this.get_node(obj);
				if(!obj || obj.id === $.jstree.root) {
					return false;
				}
				dom = this.get_node(obj, true);
				if(!obj.state.checkbox_disabled) {
					obj.state.checkbox_disabled = true;
					if(dom && dom.length) {
						dom.children('.jstree-anchor').children('.jstree-checkbox').addClass('jstree-checkbox-disabled');
					}
					/**
					 * triggered when an node's checkbox is disabled
					 * @event
					 * @name disable_checkbox.jstree
					 * @param {Object} node
					 * @plugin checkbox
					 */
					this.trigger('disable_checkbox', { 'node' : obj });
				}
			};
			/**
			 * enable a node's checkbox
			 * @name disable_checkbox(obj)
			 * @param {mixed} obj an array can be used too
			 * @trigger enable_checkbox.jstree
			 * @plugin checkbox
			 */
			this.enable_checkbox = function (obj) {
				var t1, t2, dom;
				if($.isArray(obj)) {
					obj = obj.slice();
					for(t1 = 0, t2 = obj.length; t1 < t2; t1++) {
						this.enable_checkbox(obj[t1]);
					}
					return true;
				}
				obj = this.get_node(obj);
				if(!obj || obj.id === $.jstree.root) {
					return false;
				}
				dom = this.get_node(obj, true);
				if(obj.state.checkbox_disabled) {
					obj.state.checkbox_disabled = false;
					if(dom && dom.length) {
						dom.children('.jstree-anchor').children('.jstree-checkbox').removeClass('jstree-checkbox-disabled');
					}
					/**
					 * triggered when an node's checkbox is enabled
					 * @event
					 * @name enable_checkbox.jstree
					 * @param {Object} node
					 * @plugin checkbox
					 */
					this.trigger('enable_checkbox', { 'node' : obj });
				}
			};
	
			this.activate_node = function (obj, e) {
				if($(e.target).hasClass('jstree-checkbox-disabled')) {
					return false;
				}
				if(this.settings.checkbox.tie_selection && (this.settings.checkbox.whole_node || $(e.target).hasClass('jstree-checkbox'))) {
					e.ctrlKey = true;
				}
				if(this.settings.checkbox.tie_selection || (!this.settings.checkbox.whole_node && !$(e.target).hasClass('jstree-checkbox'))) {
					return parent.activate_node.call(this, obj, e);
				}
				if(this.is_disabled(obj)) {
					return false;
				}
				if(this.is_checked(obj)) {
					this.uncheck_node(obj, e);
				}
				else {
					this.check_node(obj, e);
				}
				this.trigger('activate_node', { 'node' : this.get_node(obj) });
			};
	
			/**
			 * check a node (only if tie_selection in checkbox settings is false, otherwise select_node will be called internally)
			 * @name check_node(obj)
			 * @param {mixed} obj an array can be used to check multiple nodes
			 * @trigger check_node.jstree
			 * @plugin checkbox
			 */
			this.check_node = function (obj, e) {
				if(this.settings.checkbox.tie_selection) { return this.select_node(obj, false, true, e); }
				var dom, t1, t2, th;
				if($.isArray(obj)) {
					obj = obj.slice();
					for(t1 = 0, t2 = obj.length; t1 < t2; t1++) {
						this.check_node(obj[t1], e);
					}
					return true;
				}
				obj = this.get_node(obj);
				if(!obj || obj.id === $.jstree.root) {
					return false;
				}
				dom = this.get_node(obj, true);
				if(!obj.state.checked) {
					obj.state.checked = true;
					this._data.checkbox.selected.push(obj.id);
					if(dom && dom.length) {
						dom.children('.jstree-anchor').addClass('jstree-checked');
					}
					/**
					 * triggered when an node is checked (only if tie_selection in checkbox settings is false)
					 * @event
					 * @name check_node.jstree
					 * @param {Object} node
					 * @param {Array} selected the current selection
					 * @param {Object} event the event (if any) that triggered this check_node
					 * @plugin checkbox
					 */
					this.trigger('check_node', { 'node' : obj, 'selected' : this._data.checkbox.selected, 'event' : e });
				}
			};
			/**
			 * uncheck a node (only if tie_selection in checkbox settings is false, otherwise deselect_node will be called internally)
			 * @name uncheck_node(obj)
			 * @param {mixed} obj an array can be used to uncheck multiple nodes
			 * @trigger uncheck_node.jstree
			 * @plugin checkbox
			 */
			this.uncheck_node = function (obj, e) {
				if(this.settings.checkbox.tie_selection) { return this.deselect_node(obj, false, e); }
				var t1, t2, dom;
				if($.isArray(obj)) {
					obj = obj.slice();
					for(t1 = 0, t2 = obj.length; t1 < t2; t1++) {
						this.uncheck_node(obj[t1], e);
					}
					return true;
				}
				obj = this.get_node(obj);
				if(!obj || obj.id === $.jstree.root) {
					return false;
				}
				dom = this.get_node(obj, true);
				if(obj.state.checked) {
					obj.state.checked = false;
					this._data.checkbox.selected = $.vakata.array_remove_item(this._data.checkbox.selected, obj.id);
					if(dom.length) {
						dom.children('.jstree-anchor').removeClass('jstree-checked');
					}
					/**
					 * triggered when an node is unchecked (only if tie_selection in checkbox settings is false)
					 * @event
					 * @name uncheck_node.jstree
					 * @param {Object} node
					 * @param {Array} selected the current selection
					 * @param {Object} event the event (if any) that triggered this uncheck_node
					 * @plugin checkbox
					 */
					this.trigger('uncheck_node', { 'node' : obj, 'selected' : this._data.checkbox.selected, 'event' : e });
				}
			};
			/**
			 * checks all nodes in the tree (only if tie_selection in checkbox settings is false, otherwise select_all will be called internally)
			 * @name check_all()
			 * @trigger check_all.jstree, changed.jstree
			 * @plugin checkbox
			 */
			this.check_all = function () {
				if(this.settings.checkbox.tie_selection) { return this.select_all(); }
				var tmp = this._data.checkbox.selected.concat([]), i, j;
				this._data.checkbox.selected = this._model.data[$.jstree.root].children_d.concat();
				for(i = 0, j = this._data.checkbox.selected.length; i < j; i++) {
					if(this._model.data[this._data.checkbox.selected[i]]) {
						this._model.data[this._data.checkbox.selected[i]].state.checked = true;
					}
				}
				this.redraw(true);
				/**
				 * triggered when all nodes are checked (only if tie_selection in checkbox settings is false)
				 * @event
				 * @name check_all.jstree
				 * @param {Array} selected the current selection
				 * @plugin checkbox
				 */
				this.trigger('check_all', { 'selected' : this._data.checkbox.selected });
			};
			/**
			 * uncheck all checked nodes (only if tie_selection in checkbox settings is false, otherwise deselect_all will be called internally)
			 * @name uncheck_all()
			 * @trigger uncheck_all.jstree
			 * @plugin checkbox
			 */
			this.uncheck_all = function () {
				if(this.settings.checkbox.tie_selection) { return this.deselect_all(); }
				var tmp = this._data.checkbox.selected.concat([]), i, j;
				for(i = 0, j = this._data.checkbox.selected.length; i < j; i++) {
					if(this._model.data[this._data.checkbox.selected[i]]) {
						this._model.data[this._data.checkbox.selected[i]].state.checked = false;
					}
				}
				this._data.checkbox.selected = [];
				this.element.find('.jstree-checked').removeClass('jstree-checked');
				/**
				 * triggered when all nodes are unchecked (only if tie_selection in checkbox settings is false)
				 * @event
				 * @name uncheck_all.jstree
				 * @param {Object} node the previous selection
				 * @param {Array} selected the current selection
				 * @plugin checkbox
				 */
				this.trigger('uncheck_all', { 'selected' : this._data.checkbox.selected, 'node' : tmp });
			};
			/**
			 * checks if a node is checked (if tie_selection is on in the settings this function will return the same as is_selected)
			 * @name is_checked(obj)
			 * @param  {mixed}  obj
			 * @return {Boolean}
			 * @plugin checkbox
			 */
			this.is_checked = function (obj) {
				if(this.settings.checkbox.tie_selection) { return this.is_selected(obj); }
				obj = this.get_node(obj);
				if(!obj || obj.id === $.jstree.root) { return false; }
				return obj.state.checked;
			};
			/**
			 * get an array of all checked nodes (if tie_selection is on in the settings this function will return the same as get_selected)
			 * @name get_checked([full])
			 * @param  {mixed}  full if set to `true` the returned array will consist of the full node objects, otherwise - only IDs will be returned
			 * @return {Array}
			 * @plugin checkbox
			 */
			this.get_checked = function (full) {
				if(this.settings.checkbox.tie_selection) { return this.get_selected(full); }
				return full ? $.map(this._data.checkbox.selected, $.proxy(function (i) { return this.get_node(i); }, this)) : this._data.checkbox.selected;
			};
			/**
			 * get an array of all top level checked nodes (ignoring children of checked nodes) (if tie_selection is on in the settings this function will return the same as get_top_selected)
			 * @name get_top_checked([full])
			 * @param  {mixed}  full if set to `true` the returned array will consist of the full node objects, otherwise - only IDs will be returned
			 * @return {Array}
			 * @plugin checkbox
			 */
			this.get_top_checked = function (full) {
				if(this.settings.checkbox.tie_selection) { return this.get_top_selected(full); }
				var tmp = this.get_checked(true),
					obj = {}, i, j, k, l;
				for(i = 0, j = tmp.length; i < j; i++) {
					obj[tmp[i].id] = tmp[i];
				}
				for(i = 0, j = tmp.length; i < j; i++) {
					for(k = 0, l = tmp[i].children_d.length; k < l; k++) {
						if(obj[tmp[i].children_d[k]]) {
							delete obj[tmp[i].children_d[k]];
						}
					}
				}
				tmp = [];
				for(i in obj) {
					if(obj.hasOwnProperty(i)) {
						tmp.push(i);
					}
				}
				return full ? $.map(tmp, $.proxy(function (i) { return this.get_node(i); }, this)) : tmp;
			};
			/**
			 * get an array of all bottom level checked nodes (ignoring selected parents) (if tie_selection is on in the settings this function will return the same as get_bottom_selected)
			 * @name get_bottom_checked([full])
			 * @param  {mixed}  full if set to `true` the returned array will consist of the full node objects, otherwise - only IDs will be returned
			 * @return {Array}
			 * @plugin checkbox
			 */
			this.get_bottom_checked = function (full) {
				if(this.settings.checkbox.tie_selection) { return this.get_bottom_selected(full); }
				var tmp = this.get_checked(true),
					obj = [], i, j;
				for(i = 0, j = tmp.length; i < j; i++) {
					if(!tmp[i].children.length) {
						obj.push(tmp[i].id);
					}
				}
				return full ? $.map(obj, $.proxy(function (i) { return this.get_node(i); }, this)) : obj;
			};
			this.load_node = function (obj, callback) {
				var k, l, i, j, c, tmp;
				if(!$.isArray(obj) && !this.settings.checkbox.tie_selection) {
					tmp = this.get_node(obj);
					if(tmp && tmp.state.loaded) {
						for(k = 0, l = tmp.children_d.length; k < l; k++) {
							if(this._model.data[tmp.children_d[k]].state.checked) {
								c = true;
								this._data.checkbox.selected = $.vakata.array_remove_item(this._data.checkbox.selected, tmp.children_d[k]);
							}
						}
					}
				}
				return parent.load_node.apply(this, arguments);
			};
			this.get_state = function () {
				var state = parent.get_state.apply(this, arguments);
				if(this.settings.checkbox.tie_selection) { return state; }
				state.checkbox = this._data.checkbox.selected.slice();
				return state;
			};
			this.set_state = function (state, callback) {
				var res = parent.set_state.apply(this, arguments);
				if(res && state.checkbox) {
					if(!this.settings.checkbox.tie_selection) {
						this.uncheck_all();
						var _this = this;
						$.each(state.checkbox, function (i, v) {
							_this.check_node(v);
						});
					}
					delete state.checkbox;
					this.set_state(state, callback);
					return false;
				}
				return res;
			};
			this.refresh = function (skip_loading, forget_state) {
				if(!this.settings.checkbox.tie_selection) {
					this._data.checkbox.selected = [];
				}
				return parent.refresh.apply(this, arguments);
			};
		};
	
		// include the checkbox plugin by default
		// $.jstree.defaults.plugins.push("checkbox");
	
	/**
	 * ### Conditionalselect plugin
	 *
	 * This plugin allows defining a callback to allow or deny node selection by user input (activate node method).
	 */
	
		/**
		 * a callback (function) which is invoked in the instance's scope and receives two arguments - the node and the event that triggered the `activate_node` call. Returning false prevents working with the node, returning true allows invoking activate_node. Defaults to returning `true`.
		 * @name $.jstree.defaults.checkbox.visible
		 * @plugin checkbox
		 */
		$.jstree.defaults.conditionalselect = function () { return true; };
		$.jstree.plugins.conditionalselect = function (options, parent) {
			// own function
			this.activate_node = function (obj, e) {
				if(this.settings.conditionalselect.call(this, this.get_node(obj), e)) {
					parent.activate_node.call(this, obj, e);
				}
			};
		};
	
	
	/**
	 * ### Contextmenu plugin
	 *
	 * Shows a context menu when a node is right-clicked.
	 */
	
		/**
		 * stores all defaults for the contextmenu plugin
		 * @name $.jstree.defaults.contextmenu
		 * @plugin contextmenu
		 */
		$.jstree.defaults.contextmenu = {
			/**
			 * a boolean indicating if the node should be selected when the context menu is invoked on it. Defaults to `true`.
			 * @name $.jstree.defaults.contextmenu.select_node
			 * @plugin contextmenu
			 */
			select_node : true,
			/**
			 * a boolean indicating if the menu should be shown aligned with the node. Defaults to `true`, otherwise the mouse coordinates are used.
			 * @name $.jstree.defaults.contextmenu.show_at_node
			 * @plugin contextmenu
			 */
			show_at_node : true,
			/**
			 * an object of actions, or a function that accepts a node and a callback function and calls the callback function with an object of actions available for that node (you can also return the items too).
			 *
			 * Each action consists of a key (a unique name) and a value which is an object with the following properties (only label and action are required). Once a menu item is activated the `action` function will be invoked with an object containing the following keys: item - the contextmenu item definition as seen below, reference - the DOM node that was used (the tree node), element - the contextmenu DOM element, position - an object with x/y properties indicating the position of the menu.
			 *
			 * * `separator_before` - a boolean indicating if there should be a separator before this item
			 * * `separator_after` - a boolean indicating if there should be a separator after this item
			 * * `_disabled` - a boolean indicating if this action should be disabled
			 * * `label` - a string - the name of the action (could be a function returning a string)
			 * * `title` - a string - an optional tooltip for the item
			 * * `action` - a function to be executed if this item is chosen, the function will receive 
			 * * `icon` - a string, can be a path to an icon or a className, if using an image that is in the current directory use a `./` prefix, otherwise it will be detected as a class
			 * * `shortcut` - keyCode which will trigger the action if the menu is open (for example `113` for rename, which equals F2)
			 * * `shortcut_label` - shortcut label (like for example `F2` for rename)
			 * * `submenu` - an object with the same structure as $.jstree.defaults.contextmenu.items which can be used to create a submenu - each key will be rendered as a separate option in a submenu that will appear once the current item is hovered
			 *
			 * @name $.jstree.defaults.contextmenu.items
			 * @plugin contextmenu
			 */
			items : function (o, cb) { // Could be an object directly
				return {
					"create" : {
						"separator_before"	: false,
						"separator_after"	: true,
						"_disabled"			: false, //(this.check("create_node", data.reference, {}, "last")),
						"label"				: "Create",
						"action"			: function (data) {
							var inst = $.jstree.reference(data.reference),
								obj = inst.get_node(data.reference);
							inst.create_node(obj, {}, "last", function (new_node) {
								setTimeout(function () { inst.edit(new_node); },0);
							});
						}
					},
					"rename" : {
						"separator_before"	: false,
						"separator_after"	: false,
						"_disabled"			: false, //(this.check("rename_node", data.reference, this.get_parent(data.reference), "")),
						"label"				: "Rename",
						/*!
						"shortcut"			: 113,
						"shortcut_label"	: 'F2',
						"icon"				: "glyphicon glyphicon-leaf",
						*/
						"action"			: function (data) {
							var inst = $.jstree.reference(data.reference),
								obj = inst.get_node(data.reference);
							inst.edit(obj);
						}
					},
					"remove" : {
						"separator_before"	: false,
						"icon"				: false,
						"separator_after"	: false,
						"_disabled"			: false, //(this.check("delete_node", data.reference, this.get_parent(data.reference), "")),
						"label"				: "Delete",
						"action"			: function (data) {
							var inst = $.jstree.reference(data.reference),
								obj = inst.get_node(data.reference);
							if(inst.is_selected(obj)) {
								inst.delete_node(inst.get_selected());
							}
							else {
								inst.delete_node(obj);
							}
						}
					},
					"ccp" : {
						"separator_before"	: true,
						"icon"				: false,
						"separator_after"	: false,
						"label"				: "Edit",
						"action"			: false,
						"submenu" : {
							"cut" : {
								"separator_before"	: false,
								"separator_after"	: false,
								"label"				: "Cut",
								"action"			: function (data) {
									var inst = $.jstree.reference(data.reference),
										obj = inst.get_node(data.reference);
									if(inst.is_selected(obj)) {
										inst.cut(inst.get_top_selected());
									}
									else {
										inst.cut(obj);
									}
								}
							},
							"copy" : {
								"separator_before"	: false,
								"icon"				: false,
								"separator_after"	: false,
								"label"				: "Copy",
								"action"			: function (data) {
									var inst = $.jstree.reference(data.reference),
										obj = inst.get_node(data.reference);
									if(inst.is_selected(obj)) {
										inst.copy(inst.get_top_selected());
									}
									else {
										inst.copy(obj);
									}
								}
							},
							"paste" : {
								"separator_before"	: false,
								"icon"				: false,
								"_disabled"			: function (data) {
									return !$.jstree.reference(data.reference).can_paste();
								},
								"separator_after"	: false,
								"label"				: "Paste",
								"action"			: function (data) {
									var inst = $.jstree.reference(data.reference),
										obj = inst.get_node(data.reference);
									inst.paste(obj);
								}
							}
						}
					}
				};
			}
		};
	
		$.jstree.plugins.contextmenu = function (options, parent) {
			this.bind = function () {
				parent.bind.call(this);
	
				var last_ts = 0, cto = null, ex, ey;
				this.element
					.on("contextmenu.jstree", ".jstree-anchor", $.proxy(function (e, data) {
							if (e.target.tagName.toLowerCase() === 'input') {
								return;
							}
							e.preventDefault();
							last_ts = e.ctrlKey ? +new Date() : 0;
							if(data || cto) {
								last_ts = (+new Date()) + 10000;
							}
							if(cto) {
								clearTimeout(cto);
							}
							if(!this.is_loading(e.currentTarget)) {
								this.show_contextmenu(e.currentTarget, e.pageX, e.pageY, e);
							}
						}, this))
					.on("click.jstree", ".jstree-anchor", $.proxy(function (e) {
							if(this._data.contextmenu.visible && (!last_ts || (+new Date()) - last_ts > 250)) { // work around safari & macOS ctrl+click
								$.vakata.context.hide();
							}
							last_ts = 0;
						}, this))
					.on("touchstart.jstree", ".jstree-anchor", function (e) {
							if(!e.originalEvent || !e.originalEvent.changedTouches || !e.originalEvent.changedTouches[0]) {
								return;
							}
							ex = e.originalEvent.changedTouches[0].clientX;
							ey = e.originalEvent.changedTouches[0].clientY;
							cto = setTimeout(function () {
								$(e.currentTarget).trigger('contextmenu', true);
							}, 750);
						})
					.on('touchmove.vakata.jstree', function (e) {
							if(cto && e.originalEvent && e.originalEvent.changedTouches && e.originalEvent.changedTouches[0] && (Math.abs(ex - e.originalEvent.changedTouches[0].clientX) > 50 || Math.abs(ey - e.originalEvent.changedTouches[0].clientY) > 50)) {
								clearTimeout(cto);
							}
						})
					.on('touchend.vakata.jstree', function (e) {
							if(cto) {
								clearTimeout(cto);
							}
						});
	
				/*!
				if(!('oncontextmenu' in document.body) && ('ontouchstart' in document.body)) {
					var el = null, tm = null;
					this.element
						.on("touchstart", ".jstree-anchor", function (e) {
							el = e.currentTarget;
							tm = +new Date();
							$(document).one("touchend", function (e) {
								e.target = document.elementFromPoint(e.originalEvent.targetTouches[0].pageX - window.pageXOffset, e.originalEvent.targetTouches[0].pageY - window.pageYOffset);
								e.currentTarget = e.target;
								tm = ((+(new Date())) - tm);
								if(e.target === el && tm > 600 && tm < 1000) {
									e.preventDefault();
									$(el).trigger('contextmenu', e);
								}
								el = null;
								tm = null;
							});
						});
				}
				*/
				$(document).on("context_hide.vakata.jstree", $.proxy(function (e, data) {
					this._data.contextmenu.visible = false;
					$(data.reference).removeClass('jstree-context');
				}, this));
			};
			this.teardown = function () {
				if(this._data.contextmenu.visible) {
					$.vakata.context.hide();
				}
				parent.teardown.call(this);
			};
	
			/**
			 * prepare and show the context menu for a node
			 * @name show_contextmenu(obj [, x, y])
			 * @param {mixed} obj the node
			 * @param {Number} x the x-coordinate relative to the document to show the menu at
			 * @param {Number} y the y-coordinate relative to the document to show the menu at
			 * @param {Object} e the event if available that triggered the contextmenu
			 * @plugin contextmenu
			 * @trigger show_contextmenu.jstree
			 */
			this.show_contextmenu = function (obj, x, y, e) {
				obj = this.get_node(obj);
				if(!obj || obj.id === $.jstree.root) { return false; }
				var s = this.settings.contextmenu,
					d = this.get_node(obj, true),
					a = d.children(".jstree-anchor"),
					o = false,
					i = false;
				if(s.show_at_node || x === undefined || y === undefined) {
					o = a.offset();
					x = o.left;
					y = o.top + this._data.core.li_height;
				}
				if(this.settings.contextmenu.select_node && !this.is_selected(obj)) {
					this.activate_node(obj, e);
				}
	
				i = s.items;
				if($.isFunction(i)) {
					i = i.call(this, obj, $.proxy(function (i) {
						this._show_contextmenu(obj, x, y, i);
					}, this));
				}
				if($.isPlainObject(i)) {
					this._show_contextmenu(obj, x, y, i);
				}
			};
			/**
			 * show the prepared context menu for a node
			 * @name _show_contextmenu(obj, x, y, i)
			 * @param {mixed} obj the node
			 * @param {Number} x the x-coordinate relative to the document to show the menu at
			 * @param {Number} y the y-coordinate relative to the document to show the menu at
			 * @param {Number} i the object of items to show
			 * @plugin contextmenu
			 * @trigger show_contextmenu.jstree
			 * @private
			 */
			this._show_contextmenu = function (obj, x, y, i) {
				var d = this.get_node(obj, true),
					a = d.children(".jstree-anchor");
				$(document).one("context_show.vakata.jstree", $.proxy(function (e, data) {
					var cls = 'jstree-contextmenu jstree-' + this.get_theme() + '-contextmenu';
					$(data.element).addClass(cls);
					a.addClass('jstree-context');
				}, this));
				this._data.contextmenu.visible = true;
				$.vakata.context.show(a, { 'x' : x, 'y' : y }, i);
				/**
				 * triggered when the contextmenu is shown for a node
				 * @event
				 * @name show_contextmenu.jstree
				 * @param {Object} node the node
				 * @param {Number} x the x-coordinate of the menu relative to the document
				 * @param {Number} y the y-coordinate of the menu relative to the document
				 * @plugin contextmenu
				 */
				this.trigger('show_contextmenu', { "node" : obj, "x" : x, "y" : y });
			};
		};
	
		// contextmenu helper
		(function ($) {
			var right_to_left = false,
				vakata_context = {
					element		: false,
					reference	: false,
					position_x	: 0,
					position_y	: 0,
					items		: [],
					html		: "",
					is_visible	: false
				};
	
			$.vakata.context = {
				settings : {
					hide_onmouseleave	: 0,
					icons				: true
				},
				_trigger : function (event_name) {
					$(document).triggerHandler("context_" + event_name + ".vakata", {
						"reference"	: vakata_context.reference,
						"element"	: vakata_context.element,
						"position"	: {
							"x" : vakata_context.position_x,
							"y" : vakata_context.position_y
						}
					});
				},
				_execute : function (i) {
					i = vakata_context.items[i];
					return i && (!i._disabled || ($.isFunction(i._disabled) && !i._disabled({ "item" : i, "reference" : vakata_context.reference, "element" : vakata_context.element }))) && i.action ? i.action.call(null, {
								"item"		: i,
								"reference"	: vakata_context.reference,
								"element"	: vakata_context.element,
								"position"	: {
									"x" : vakata_context.position_x,
									"y" : vakata_context.position_y
								}
							}) : false;
				},
				_parse : function (o, is_callback) {
					if(!o) { return false; }
					if(!is_callback) {
						vakata_context.html		= "";
						vakata_context.items	= [];
					}
					var str = "",
						sep = false,
						tmp;
	
					if(is_callback) { str += "<"+"ul>"; }
					$.each(o, function (i, val) {
						if(!val) { return true; }
						vakata_context.items.push(val);
						if(!sep && val.separator_before) {
							str += "<"+"li class='vakata-context-separator'><"+"a href='#' " + ($.vakata.context.settings.icons ? '' : 'style="margin-left:0px;"') + ">&#160;<"+"/a><"+"/li>";
						}
						sep = false;
						str += "<"+"li class='" + (val._class || "") + (val._disabled === true || ($.isFunction(val._disabled) && val._disabled({ "item" : val, "reference" : vakata_context.reference, "element" : vakata_context.element })) ? " vakata-contextmenu-disabled " : "") + "' "+(val.shortcut?" data-shortcut='"+val.shortcut+"' ":'')+">";
						str += "<"+"a href='#' rel='" + (vakata_context.items.length - 1) + "' " + (val.title ? "title='" + val.title + "'" : "") + ">";
						if($.vakata.context.settings.icons) {
							str += "<"+"i ";
							if(val.icon) {
								if(val.icon.indexOf("/") !== -1 || val.icon.indexOf(".") !== -1) { str += " style='background:url(\"" + val.icon + "\") center center no-repeat' "; }
								else { str += " class='" + val.icon + "' "; }
							}
							str += "><"+"/i><"+"span class='vakata-contextmenu-sep'>&#160;<"+"/span>";
						}
						str += ($.isFunction(val.label) ? val.label({ "item" : i, "reference" : vakata_context.reference, "element" : vakata_context.element }) : val.label) + (val.shortcut?' <span class="vakata-contextmenu-shortcut vakata-contextmenu-shortcut-'+val.shortcut+'">'+ (val.shortcut_label || '') +'</span>':'') + "<"+"/a>";
						if(val.submenu) {
							tmp = $.vakata.context._parse(val.submenu, true);
							if(tmp) { str += tmp; }
						}
						str += "<"+"/li>";
						if(val.separator_after) {
							str += "<"+"li class='vakata-context-separator'><"+"a href='#' " + ($.vakata.context.settings.icons ? '' : 'style="margin-left:0px;"') + ">&#160;<"+"/a><"+"/li>";
							sep = true;
						}
					});
					str  = str.replace(/<li class\='vakata-context-separator'\><\/li\>$/,"");
					if(is_callback) { str += "</ul>"; }
					/**
					 * triggered on the document when the contextmenu is parsed (HTML is built)
					 * @event
					 * @plugin contextmenu
					 * @name context_parse.vakata
					 * @param {jQuery} reference the element that was right clicked
					 * @param {jQuery} element the DOM element of the menu itself
					 * @param {Object} position the x & y coordinates of the menu
					 */
					if(!is_callback) { vakata_context.html = str; $.vakata.context._trigger("parse"); }
					return str.length > 10 ? str : false;
				},
				_show_submenu : function (o) {
					o = $(o);
					if(!o.length || !o.children("ul").length) { return; }
					var e = o.children("ul"),
						xl = o.offset().left,
						x = xl + o.outerWidth(),
						y = o.offset().top,
						w = e.width(),
						h = e.height(),
						dw = $(window).width() + $(window).scrollLeft(),
						dh = $(window).height() + $(window).scrollTop();
					// може да се спести е една проверка - дали няма някой от класовете вече нагоре
					if(right_to_left) {
						o[x - (w + 10 + o.outerWidth()) < 0 ? "addClass" : "removeClass"]("vakata-context-left");
					}
					else {
						o[x + w > dw  && xl > dw - x ? "addClass" : "removeClass"]("vakata-context-right");
					}
					if(y + h + 10 > dh) {
						e.css("bottom","-1px");
					}
	
					//if does not fit - stick it to the side
					if (o.hasClass('vakata-context-right')) {
						if (xl < w) {
							e.css("margin-right", xl - w);
						}
					} else {
						if (dw - x < w) {
							e.css("margin-left", dw - x - w);
						}
					}
	
					e.show();
				},
				show : function (reference, position, data) {
					var o, e, x, y, w, h, dw, dh, cond = true;
					if(vakata_context.element && vakata_context.element.length) {
						vakata_context.element.width('');
					}
					switch(cond) {
						case (!position && !reference):
							return false;
						case (!!position && !!reference):
							vakata_context.reference	= reference;
							vakata_context.position_x	= position.x;
							vakata_context.position_y	= position.y;
							break;
						case (!position && !!reference):
							vakata_context.reference	= reference;
							o = reference.offset();
							vakata_context.position_x	= o.left + reference.outerHeight();
							vakata_context.position_y	= o.top;
							break;
						case (!!position && !reference):
							vakata_context.position_x	= position.x;
							vakata_context.position_y	= position.y;
							break;
					}
					if(!!reference && !data && $(reference).data('vakata_contextmenu')) {
						data = $(reference).data('vakata_contextmenu');
					}
					if($.vakata.context._parse(data)) {
						vakata_context.element.html(vakata_context.html);
					}
					if(vakata_context.items.length) {
						vakata_context.element.appendTo("body");
						e = vakata_context.element;
						x = vakata_context.position_x;
						y = vakata_context.position_y;
						w = e.width();
						h = e.height();
						dw = $(window).width() + $(window).scrollLeft();
						dh = $(window).height() + $(window).scrollTop();
						if(right_to_left) {
							x -= (e.outerWidth() - $(reference).outerWidth());
							if(x < $(window).scrollLeft() + 20) {
								x = $(window).scrollLeft() + 20;
							}
						}
						if(x + w + 20 > dw) {
							x = dw - (w + 20);
						}
						if(y + h + 20 > dh) {
							y = dh - (h + 20);
						}
	
						vakata_context.element
							.css({ "left" : x, "top" : y })
							.show()
							.find('a').first().focus().parent().addClass("vakata-context-hover");
						vakata_context.is_visible = true;
						/**
						 * triggered on the document when the contextmenu is shown
						 * @event
						 * @plugin contextmenu
						 * @name context_show.vakata
						 * @param {jQuery} reference the element that was right clicked
						 * @param {jQuery} element the DOM element of the menu itself
						 * @param {Object} position the x & y coordinates of the menu
						 */
						$.vakata.context._trigger("show");
					}
				},
				hide : function () {
					if(vakata_context.is_visible) {
						vakata_context.element.hide().find("ul").hide().end().find(':focus').blur().end().detach();
						vakata_context.is_visible = false;
						/**
						 * triggered on the document when the contextmenu is hidden
						 * @event
						 * @plugin contextmenu
						 * @name context_hide.vakata
						 * @param {jQuery} reference the element that was right clicked
						 * @param {jQuery} element the DOM element of the menu itself
						 * @param {Object} position the x & y coordinates of the menu
						 */
						$.vakata.context._trigger("hide");
					}
				}
			};
			$(function () {
				right_to_left = $("body").css("direction") === "rtl";
				var to = false;
	
				vakata_context.element = $("<ul class='vakata-context'></ul>");
				vakata_context.element
					.on("mouseenter", "li", function (e) {
						e.stopImmediatePropagation();
	
						if($.contains(this, e.relatedTarget)) {
							// премахнато заради delegate mouseleave по-долу
							// $(this).find(".vakata-context-hover").removeClass("vakata-context-hover");
							return;
						}
	
						if(to) { clearTimeout(to); }
						vakata_context.element.find(".vakata-context-hover").removeClass("vakata-context-hover").end();
	
						$(this)
							.siblings().find("ul").hide().end().end()
							.parentsUntil(".vakata-context", "li").addBack().addClass("vakata-context-hover");
						$.vakata.context._show_submenu(this);
					})
					// тестово - дали не натоварва?
					.on("mouseleave", "li", function (e) {
						if($.contains(this, e.relatedTarget)) { return; }
						$(this).find(".vakata-context-hover").addBack().removeClass("vakata-context-hover");
					})
					.on("mouseleave", function (e) {
						$(this).find(".vakata-context-hover").removeClass("vakata-context-hover");
						if($.vakata.context.settings.hide_onmouseleave) {
							to = setTimeout(
								(function (t) {
									return function () { $.vakata.context.hide(); };
								}(this)), $.vakata.context.settings.hide_onmouseleave);
						}
					})
					.on("click", "a", function (e) {
						e.preventDefault();
					//})
					//.on("mouseup", "a", function (e) {
						if(!$(this).blur().parent().hasClass("vakata-context-disabled") && $.vakata.context._execute($(this).attr("rel")) !== false) {
							$.vakata.context.hide();
						}
					})
					.on('keydown', 'a', function (e) {
							var o = null;
							switch(e.which) {
								case 13:
								case 32:
									e.type = "click";
									e.preventDefault();
									$(e.currentTarget).trigger(e);
									break;
								case 37:
									if(vakata_context.is_visible) {
										vakata_context.element.find(".vakata-context-hover").last().closest("li").first().find("ul").hide().find(".vakata-context-hover").removeClass("vakata-context-hover").end().end().children('a').focus();
										e.stopImmediatePropagation();
										e.preventDefault();
									}
									break;
								case 38:
									if(vakata_context.is_visible) {
										o = vakata_context.element.find("ul:visible").addBack().last().children(".vakata-context-hover").removeClass("vakata-context-hover").prevAll("li:not(.vakata-context-separator)").first();
										if(!o.length) { o = vakata_context.element.find("ul:visible").addBack().last().children("li:not(.vakata-context-separator)").last(); }
										o.addClass("vakata-context-hover").children('a').focus();
										e.stopImmediatePropagation();
										e.preventDefault();
									}
									break;
								case 39:
									if(vakata_context.is_visible) {
										vakata_context.element.find(".vakata-context-hover").last().children("ul").show().children("li:not(.vakata-context-separator)").removeClass("vakata-context-hover").first().addClass("vakata-context-hover").children('a').focus();
										e.stopImmediatePropagation();
										e.preventDefault();
									}
									break;
								case 40:
									if(vakata_context.is_visible) {
										o = vakata_context.element.find("ul:visible").addBack().last().children(".vakata-context-hover").removeClass("vakata-context-hover").nextAll("li:not(.vakata-context-separator)").first();
										if(!o.length) { o = vakata_context.element.find("ul:visible").addBack().last().children("li:not(.vakata-context-separator)").first(); }
										o.addClass("vakata-context-hover").children('a').focus();
										e.stopImmediatePropagation();
										e.preventDefault();
									}
									break;
								case 27:
									$.vakata.context.hide();
									e.preventDefault();
									break;
								default:
									//console.log(e.which);
									break;
							}
						})
					.on('keydown', function (e) {
						e.preventDefault();
						var a = vakata_context.element.find('.vakata-contextmenu-shortcut-' + e.which).parent();
						if(a.parent().not('.vakata-context-disabled')) {
							a.click();
						}
					});
	
				$(document)
					.on("mousedown.vakata.jstree", function (e) {
						if(vakata_context.is_visible && !$.contains(vakata_context.element[0], e.target)) {
							$.vakata.context.hide();
						}
					})
					.on("context_show.vakata.jstree", function (e, data) {
						vakata_context.element.find("li:has(ul)").children("a").addClass("vakata-context-parent");
						if(right_to_left) {
							vakata_context.element.addClass("vakata-context-rtl").css("direction", "rtl");
						}
						// also apply a RTL class?
						vakata_context.element.find("ul").hide().end();
					});
			});
		}($));
		// $.jstree.defaults.plugins.push("contextmenu");
	
	
	/**
	 * ### Drag'n'drop plugin
	 *
	 * Enables dragging and dropping of nodes in the tree, resulting in a move or copy operations.
	 */
	
		/**
		 * stores all defaults for the drag'n'drop plugin
		 * @name $.jstree.defaults.dnd
		 * @plugin dnd
		 */
		$.jstree.defaults.dnd = {
			/**
			 * a boolean indicating if a copy should be possible while dragging (by pressint the meta key or Ctrl). Defaults to `true`.
			 * @name $.jstree.defaults.dnd.copy
			 * @plugin dnd
			 */
			copy : true,
			/**
			 * a number indicating how long a node should remain hovered while dragging to be opened. Defaults to `500`.
			 * @name $.jstree.defaults.dnd.open_timeout
			 * @plugin dnd
			 */
			open_timeout : 500,
			/**
			 * a function invoked each time a node is about to be dragged, invoked in the tree's scope and receives the nodes about to be dragged as an argument (array) and the event that started the drag - return `false` to prevent dragging
			 * @name $.jstree.defaults.dnd.is_draggable
			 * @plugin dnd
			 */
			is_draggable : true,
			/**
			 * a boolean indicating if checks should constantly be made while the user is dragging the node (as opposed to checking only on drop), default is `true`
			 * @name $.jstree.defaults.dnd.check_while_dragging
			 * @plugin dnd
			 */
			check_while_dragging : true,
			/**
			 * a boolean indicating if nodes from this tree should only be copied with dnd (as opposed to moved), default is `false`
			 * @name $.jstree.defaults.dnd.always_copy
			 * @plugin dnd
			 */
			always_copy : false,
			/**
			 * when dropping a node "inside", this setting indicates the position the node should go to - it can be an integer or a string: "first" (same as 0) or "last", default is `0`
			 * @name $.jstree.defaults.dnd.inside_pos
			 * @plugin dnd
			 */
			inside_pos : 0,
			/**
			 * when starting the drag on a node that is selected this setting controls if all selected nodes are dragged or only the single node, default is `true`, which means all selected nodes are dragged when the drag is started on a selected node
			 * @name $.jstree.defaults.dnd.drag_selection
			 * @plugin dnd
			 */
			drag_selection : true,
			/**
			 * controls whether dnd works on touch devices. If left as boolean true dnd will work the same as in desktop browsers, which in some cases may impair scrolling. If set to boolean false dnd will not work on touch devices. There is a special third option - string "selected" which means only selected nodes can be dragged on touch devices.
			 * @name $.jstree.defaults.dnd.touch
			 * @plugin dnd
			 */
			touch : true,
			/**
			 * controls whether items can be dropped anywhere on the node, not just on the anchor, by default only the node anchor is a valid drop target. Works best with the wholerow plugin. If enabled on mobile depending on the interface it might be hard for the user to cancel the drop, since the whole tree container will be a valid drop target.
			 * @name $.jstree.defaults.dnd.large_drop_target
			 * @plugin dnd
			 */
			large_drop_target : false,
			/**
			 * controls whether a drag can be initiated from any part of the node and not just the text/icon part, works best with the wholerow plugin. Keep in mind it can cause problems with tree scrolling on mobile depending on the interface - in that case set the touch option to "selected".
			 * @name $.jstree.defaults.dnd.large_drag_target
			 * @plugin dnd
			 */
			large_drag_target : false,
			/**
			 * controls whether use HTML5 dnd api instead of classical. That will allow better integration of dnd events with other HTML5 controls.
			 * @reference http://caniuse.com/#feat=dragndrop
			 * @name $.jstree.defaults.dnd.use_html5
			 * @plugin dnd
			 */
			use_html5: false
		};
		var drg, elm;
		// TODO: now check works by checking for each node individually, how about max_children, unique, etc?
		$.jstree.plugins.dnd = function (options, parent) {
			this.init = function (el, options) {
				parent.init.call(this, el, options);
				this.settings.dnd.use_html5 = this.settings.dnd.use_html5 && ('draggable' in document.createElement('span'));
			};
			this.bind = function () {
				parent.bind.call(this);
	
				this.element
					.on(this.settings.dnd.use_html5 ? 'dragstart.jstree' : 'mousedown.jstree touchstart.jstree', this.settings.dnd.large_drag_target ? '.jstree-node' : '.jstree-anchor', $.proxy(function (e) {
							if(this.settings.dnd.large_drag_target && $(e.target).closest('.jstree-node')[0] !== e.currentTarget) {
								return true;
							}
							if(e.type === "touchstart" && (!this.settings.dnd.touch || (this.settings.dnd.touch === 'selected' && !$(e.currentTarget).closest('.jstree-node').children('.jstree-anchor').hasClass('jstree-clicked')))) {
								return true;
							}
							var obj = this.get_node(e.target),
								mlt = this.is_selected(obj) && this.settings.dnd.drag_selection ? this.get_top_selected().length : 1,
								txt = (mlt > 1 ? mlt + ' ' + this.get_string('nodes') : this.get_text(e.currentTarget));
							if(this.settings.core.force_text) {
								txt = $.vakata.html.escape(txt);
							}
							if(obj && obj.id && obj.id !== $.jstree.root && (e.which === 1 || e.type === "touchstart" || e.type === "dragstart") &&
								(this.settings.dnd.is_draggable === true || ($.isFunction(this.settings.dnd.is_draggable) && this.settings.dnd.is_draggable.call(this, (mlt > 1 ? this.get_top_selected(true) : [obj]), e)))
							) {
								drg = { 'jstree' : true, 'origin' : this, 'obj' : this.get_node(obj,true), 'nodes' : mlt > 1 ? this.get_top_selected() : [obj.id] };
								elm = e.currentTarget;
								if (this.settings.dnd.use_html5) {
									$.vakata.dnd._trigger('start', e, { 'helper': $(), 'element': elm, 'data': drg });
								} else {
									this.element.trigger('mousedown.jstree');
									return $.vakata.dnd.start(e, drg, '<div id="jstree-dnd" class="jstree-' + this.get_theme() + ' jstree-' + this.get_theme() + '-' + this.get_theme_variant() + ' ' + ( this.settings.core.themes.responsive ? ' jstree-dnd-responsive' : '' ) + '"><i class="jstree-icon jstree-er"></i>' + txt + '<ins class="jstree-copy" style="display:none;">+</ins></div>');
								}
							}
						}, this));
				if (this.settings.dnd.use_html5) {
					this.element
						.on('dragover.jstree', function (e) {
								e.preventDefault();
								$.vakata.dnd._trigger('move', e, { 'helper': $(), 'element': elm, 'data': drg });
								return false;
							})
						//.on('dragenter.jstree', this.settings.dnd.large_drop_target ? '.jstree-node' : '.jstree-anchor', $.proxy(function (e) {
						//		e.preventDefault();
						//		$.vakata.dnd._trigger('move', e, { 'helper': $(), 'element': elm, 'data': drg });
						//		return false;
						//	}, this))
						.on('drop.jstree', $.proxy(function (e) {
								e.preventDefault();
								$.vakata.dnd._trigger('stop', e, { 'helper': $(), 'element': elm, 'data': drg });
								return false;
							}, this));
				}
			};
			this.redraw_node = function(obj, deep, callback, force_render) {
				obj = parent.redraw_node.apply(this, arguments);
				if (obj && this.settings.dnd.use_html5) {
					if (this.settings.dnd.large_drag_target) {
						obj.setAttribute('draggable', true);
					} else {
						var i, j, tmp = null;
						for(i = 0, j = obj.childNodes.length; i < j; i++) {
							if(obj.childNodes[i] && obj.childNodes[i].className && obj.childNodes[i].className.indexOf("jstree-anchor") !== -1) {
								tmp = obj.childNodes[i];
								break;
							}
						}
						if(tmp) {
							tmp.setAttribute('draggable', true);
						}
					}
				}
				return obj;
			};
		};
	
		$(function() {
			// bind only once for all instances
			var lastmv = false,
				laster = false,
				lastev = false,
				opento = false,
				marker = $('<div id="jstree-marker">&#160;</div>').hide(); //.appendTo('body');
	
			$(document)
				.on('dnd_start.vakata.jstree', function (e, data) {
					lastmv = false;
					lastev = false;
					if(!data || !data.data || !data.data.jstree) { return; }
					marker.appendTo('body'); //.show();
				})
				.on('dnd_move.vakata.jstree', function (e, data) {
					if(opento) {
						if (!data.event || data.event.type !== 'dragover' || data.event.target !== lastev.target) {
							clearTimeout(opento);
						}
					}
					if(!data || !data.data || !data.data.jstree) { return; }
	
					// if we are hovering the marker image do nothing (can happen on "inside" drags)
					if(data.event.target.id && data.event.target.id === 'jstree-marker') {
						return;
					}
					lastev = data.event;
	
					var ins = $.jstree.reference(data.event.target),
						ref = false,
						off = false,
						rel = false,
						tmp, l, t, h, p, i, o, ok, t1, t2, op, ps, pr, ip, tm, is_copy, pn;
					// if we are over an instance
					if(ins && ins._data && ins._data.dnd) {
						marker.attr('class', 'jstree-' + ins.get_theme() + ( ins.settings.core.themes.responsive ? ' jstree-dnd-responsive' : '' ));
						is_copy = data.data.origin && (data.data.origin.settings.dnd.always_copy || (data.data.origin.settings.dnd.copy && (data.event.metaKey || data.event.ctrlKey)));
						data.helper
							.children().attr('class', 'jstree-' + ins.get_theme() + ' jstree-' + ins.get_theme() + '-' + ins.get_theme_variant() + ' ' + ( ins.settings.core.themes.responsive ? ' jstree-dnd-responsive' : '' ))
							.find('.jstree-copy').first()[ is_copy ? 'show' : 'hide' ]();
	
						// if are hovering the container itself add a new root node
						//console.log(data.event);
						if( (data.event.target === ins.element[0] || data.event.target === ins.get_container_ul()[0]) && ins.get_container_ul().children().length === 0) {
							ok = true;
							for(t1 = 0, t2 = data.data.nodes.length; t1 < t2; t1++) {
								ok = ok && ins.check( (data.data.origin && (data.data.origin.settings.dnd.always_copy || (data.data.origin.settings.dnd.copy && (data.event.metaKey || data.event.ctrlKey)) ) ? "copy_node" : "move_node"), (data.data.origin && data.data.origin !== ins ? data.data.origin.get_node(data.data.nodes[t1]) : data.data.nodes[t1]), $.jstree.root, 'last', { 'dnd' : true, 'ref' : ins.get_node($.jstree.root), 'pos' : 'i', 'origin' : data.data.origin, 'is_multi' : (data.data.origin && data.data.origin !== ins), 'is_foreign' : (!data.data.origin) });
								if(!ok) { break; }
							}
							if(ok) {
								lastmv = { 'ins' : ins, 'par' : $.jstree.root, 'pos' : 'last' };
								marker.hide();
								data.helper.find('.jstree-icon').first().removeClass('jstree-er').addClass('jstree-ok');
								if (data.event.originalEvent && data.event.originalEvent.dataTransfer) {
									data.event.originalEvent.dataTransfer.dropEffect = is_copy ? 'copy' : 'move';
								}
								return;
							}
						}
						else {
							// if we are hovering a tree node
							ref = ins.settings.dnd.large_drop_target ? $(data.event.target).closest('.jstree-node').children('.jstree-anchor') : $(data.event.target).closest('.jstree-anchor');
							if(ref && ref.length && ref.parent().is('.jstree-closed, .jstree-open, .jstree-leaf')) {
								off = ref.offset();
								rel = (data.event.pageY !== undefined ? data.event.pageY : data.event.originalEvent.pageY) - off.top;
								h = ref.outerHeight();
								if(rel < h / 3) {
									o = ['b', 'i', 'a'];
								}
								else if(rel > h - h / 3) {
									o = ['a', 'i', 'b'];
								}
								else {
									o = rel > h / 2 ? ['i', 'a', 'b'] : ['i', 'b', 'a'];
								}
								$.each(o, function (j, v) {
									switch(v) {
										case 'b':
											l = off.left - 6;
											t = off.top;
											p = ins.get_parent(ref);
											i = ref.parent().index();
											break;
										case 'i':
											ip = ins.settings.dnd.inside_pos;
											tm = ins.get_node(ref.parent());
											l = off.left - 2;
											t = off.top + h / 2 + 1;
											p = tm.id;
											i = ip === 'first' ? 0 : (ip === 'last' ? tm.children.length : Math.min(ip, tm.children.length));
											break;
										case 'a':
											l = off.left - 6;
											t = off.top + h;
											p = ins.get_parent(ref);
											i = ref.parent().index() + 1;
											break;
									}
									ok = true;
									for(t1 = 0, t2 = data.data.nodes.length; t1 < t2; t1++) {
										op = data.data.origin && (data.data.origin.settings.dnd.always_copy || (data.data.origin.settings.dnd.copy && (data.event.metaKey || data.event.ctrlKey))) ? "copy_node" : "move_node";
										ps = i;
										if(op === "move_node" && v === 'a' && (data.data.origin && data.data.origin === ins) && p === ins.get_parent(data.data.nodes[t1])) {
											pr = ins.get_node(p);
											if(ps > $.inArray(data.data.nodes[t1], pr.children)) {
												ps -= 1;
											}
										}
										ok = ok && ( (ins && ins.settings && ins.settings.dnd && ins.settings.dnd.check_while_dragging === false) || ins.check(op, (data.data.origin && data.data.origin !== ins ? data.data.origin.get_node(data.data.nodes[t1]) : data.data.nodes[t1]), p, ps, { 'dnd' : true, 'ref' : ins.get_node(ref.parent()), 'pos' : v, 'origin' : data.data.origin, 'is_multi' : (data.data.origin && data.data.origin !== ins), 'is_foreign' : (!data.data.origin) }) );
										if(!ok) {
											if(ins && ins.last_error) { laster = ins.last_error(); }
											break;
										}
									}
									if(v === 'i' && ref.parent().is('.jstree-closed') && ins.settings.dnd.open_timeout) {
										opento = setTimeout((function (x, z) { return function () { x.open_node(z); }; }(ins, ref)), ins.settings.dnd.open_timeout);
									}
									if(ok) {
										pn = ins.get_node(p, true);
										if (!pn.hasClass('.jstree-dnd-parent')) {
											$('.jstree-dnd-parent').removeClass('jstree-dnd-parent');
											pn.addClass('jstree-dnd-parent');
										}
										lastmv = { 'ins' : ins, 'par' : p, 'pos' : v === 'i' && ip === 'last' && i === 0 && !ins.is_loaded(tm) ? 'last' : i };
										marker.css({ 'left' : l + 'px', 'top' : t + 'px' }).show();
										data.helper.find('.jstree-icon').first().removeClass('jstree-er').addClass('jstree-ok');
										if (data.event.originalEvent && data.event.originalEvent.dataTransfer) {
											data.event.originalEvent.dataTransfer.dropEffect = is_copy ? 'copy' : 'move';
										}
										laster = {};
										o = true;
										return false;
									}
								});
								if(o === true) { return; }
							}
						}
					}
					$('.jstree-dnd-parent').removeClass('jstree-dnd-parent');
					lastmv = false;
					data.helper.find('.jstree-icon').removeClass('jstree-ok').addClass('jstree-er');
					if (data.event.originalEvent && data.event.originalEvent.dataTransfer) {
						data.event.originalEvent.dataTransfer.dropEffect = 'none';
					}
					marker.hide();
				})
				.on('dnd_scroll.vakata.jstree', function (e, data) {
					if(!data || !data.data || !data.data.jstree) { return; }
					marker.hide();
					lastmv = false;
					lastev = false;
					data.helper.find('.jstree-icon').first().removeClass('jstree-ok').addClass('jstree-er');
				})
				.on('dnd_stop.vakata.jstree', function (e, data) {
					$('.jstree-dnd-parent').removeClass('jstree-dnd-parent');
					if(opento) { clearTimeout(opento); }
					if(!data || !data.data || !data.data.jstree) { return; }
					marker.hide().detach();
					var i, j, nodes = [];
					if(lastmv) {
						for(i = 0, j = data.data.nodes.length; i < j; i++) {
							nodes[i] = data.data.origin ? data.data.origin.get_node(data.data.nodes[i]) : data.data.nodes[i];
						}
						lastmv.ins[ data.data.origin && (data.data.origin.settings.dnd.always_copy || (data.data.origin.settings.dnd.copy && (data.event.metaKey || data.event.ctrlKey))) ? 'copy_node' : 'move_node' ](nodes, lastmv.par, lastmv.pos, false, false, false, data.data.origin);
					}
					else {
						i = $(data.event.target).closest('.jstree');
						if(i.length && laster && laster.error && laster.error === 'check') {
							i = i.jstree(true);
							if(i) {
								i.settings.core.error.call(this, laster);
							}
						}
					}
					lastev = false;
					lastmv = false;
				})
				.on('keyup.jstree keydown.jstree', function (e, data) {
					data = $.vakata.dnd._get();
					if(data && data.data && data.data.jstree) {
						if (e.type === "keyup" && e.which === 27) {
							if (opento) { clearTimeout(opento); }
							lastmv = false;
							laster = false;
							lastev = false;
							opento = false;
							marker.hide().detach();
							$.vakata.dnd._clean();
						} else {
							data.helper.find('.jstree-copy').first()[ data.data.origin && (data.data.origin.settings.dnd.always_copy || (data.data.origin.settings.dnd.copy && (e.metaKey || e.ctrlKey))) ? 'show' : 'hide' ]();
							if(lastev) {
								lastev.metaKey = e.metaKey;
								lastev.ctrlKey = e.ctrlKey;
								$.vakata.dnd._trigger('move', lastev);
							}
						}
					}
				});
		});
	
		// helpers
		(function ($) {
			$.vakata.html = {
				div : $('<div />'),
				escape : function (str) {
					return $.vakata.html.div.text(str).html();
				},
				strip : function (str) {
					return $.vakata.html.div.empty().append($.parseHTML(str)).text();
				}
			};
			// private variable
			var vakata_dnd = {
				element	: false,
				target	: false,
				is_down	: false,
				is_drag	: false,
				helper	: false,
				helper_w: 0,
				data	: false,
				init_x	: 0,
				init_y	: 0,
				scroll_l: 0,
				scroll_t: 0,
				scroll_e: false,
				scroll_i: false,
				is_touch: false
			};
			$.vakata.dnd = {
				settings : {
					scroll_speed		: 10,
					scroll_proximity	: 20,
					helper_left			: 5,
					helper_top			: 10,
					threshold			: 5,
					threshold_touch		: 50
				},
				_trigger : function (event_name, e, data) {
					if (data === undefined) {
						data = $.vakata.dnd._get();
					}
					data.event = e;
					$(document).triggerHandler("dnd_" + event_name + ".vakata", data);
				},
				_get : function () {
					return {
						"data"		: vakata_dnd.data,
						"element"	: vakata_dnd.element,
						"helper"	: vakata_dnd.helper
					};
				},
				_clean : function () {
					if(vakata_dnd.helper) { vakata_dnd.helper.remove(); }
					if(vakata_dnd.scroll_i) { clearInterval(vakata_dnd.scroll_i); vakata_dnd.scroll_i = false; }
					vakata_dnd = {
						element	: false,
						target	: false,
						is_down	: false,
						is_drag	: false,
						helper	: false,
						helper_w: 0,
						data	: false,
						init_x	: 0,
						init_y	: 0,
						scroll_l: 0,
						scroll_t: 0,
						scroll_e: false,
						scroll_i: false,
						is_touch: false
					};
					$(document).off("mousemove.vakata.jstree touchmove.vakata.jstree", $.vakata.dnd.drag);
					$(document).off("mouseup.vakata.jstree touchend.vakata.jstree", $.vakata.dnd.stop);
				},
				_scroll : function (init_only) {
					if(!vakata_dnd.scroll_e || (!vakata_dnd.scroll_l && !vakata_dnd.scroll_t)) {
						if(vakata_dnd.scroll_i) { clearInterval(vakata_dnd.scroll_i); vakata_dnd.scroll_i = false; }
						return false;
					}
					if(!vakata_dnd.scroll_i) {
						vakata_dnd.scroll_i = setInterval($.vakata.dnd._scroll, 100);
						return false;
					}
					if(init_only === true) { return false; }
	
					var i = vakata_dnd.scroll_e.scrollTop(),
						j = vakata_dnd.scroll_e.scrollLeft();
					vakata_dnd.scroll_e.scrollTop(i + vakata_dnd.scroll_t * $.vakata.dnd.settings.scroll_speed);
					vakata_dnd.scroll_e.scrollLeft(j + vakata_dnd.scroll_l * $.vakata.dnd.settings.scroll_speed);
					if(i !== vakata_dnd.scroll_e.scrollTop() || j !== vakata_dnd.scroll_e.scrollLeft()) {
						/**
						 * triggered on the document when a drag causes an element to scroll
						 * @event
						 * @plugin dnd
						 * @name dnd_scroll.vakata
						 * @param {Mixed} data any data supplied with the call to $.vakata.dnd.start
						 * @param {DOM} element the DOM element being dragged
						 * @param {jQuery} helper the helper shown next to the mouse
						 * @param {jQuery} event the element that is scrolling
						 */
						$.vakata.dnd._trigger("scroll", vakata_dnd.scroll_e);
					}
				},
				start : function (e, data, html) {
					if(e.type === "touchstart" && e.originalEvent && e.originalEvent.changedTouches && e.originalEvent.changedTouches[0]) {
						e.pageX = e.originalEvent.changedTouches[0].pageX;
						e.pageY = e.originalEvent.changedTouches[0].pageY;
						e.target = document.elementFromPoint(e.originalEvent.changedTouches[0].pageX - window.pageXOffset, e.originalEvent.changedTouches[0].pageY - window.pageYOffset);
					}
					if(vakata_dnd.is_drag) { $.vakata.dnd.stop({}); }
					try {
						e.currentTarget.unselectable = "on";
						e.currentTarget.onselectstart = function() { return false; };
						if(e.currentTarget.style) {
							e.currentTarget.style.touchAction = "none";
							e.currentTarget.style.msTouchAction = "none";
							e.currentTarget.style.MozUserSelect = "none";
						}
					} catch(ignore) { }
					vakata_dnd.init_x	= e.pageX;
					vakata_dnd.init_y	= e.pageY;
					vakata_dnd.data		= data;
					vakata_dnd.is_down	= true;
					vakata_dnd.element	= e.currentTarget;
					vakata_dnd.target	= e.target;
					vakata_dnd.is_touch	= e.type === "touchstart";
					if(html !== false) {
						vakata_dnd.helper = $("<div id='vakata-dnd'></div>").html(html).css({
							"display"		: "block",
							"margin"		: "0",
							"padding"		: "0",
							"position"		: "absolute",
							"top"			: "-2000px",
							"lineHeight"	: "16px",
							"zIndex"		: "10000"
						});
					}
					$(document).on("mousemove.vakata.jstree touchmove.vakata.jstree", $.vakata.dnd.drag);
					$(document).on("mouseup.vakata.jstree touchend.vakata.jstree", $.vakata.dnd.stop);
					return false;
				},
				drag : function (e) {
					if(e.type === "touchmove" && e.originalEvent && e.originalEvent.changedTouches && e.originalEvent.changedTouches[0]) {
						e.pageX = e.originalEvent.changedTouches[0].pageX;
						e.pageY = e.originalEvent.changedTouches[0].pageY;
						e.target = document.elementFromPoint(e.originalEvent.changedTouches[0].pageX - window.pageXOffset, e.originalEvent.changedTouches[0].pageY - window.pageYOffset);
					}
					if(!vakata_dnd.is_down) { return; }
					if(!vakata_dnd.is_drag) {
						if(
							Math.abs(e.pageX - vakata_dnd.init_x) > (vakata_dnd.is_touch ? $.vakata.dnd.settings.threshold_touch : $.vakata.dnd.settings.threshold) ||
							Math.abs(e.pageY - vakata_dnd.init_y) > (vakata_dnd.is_touch ? $.vakata.dnd.settings.threshold_touch : $.vakata.dnd.settings.threshold)
						) {
							if(vakata_dnd.helper) {
								vakata_dnd.helper.appendTo("body");
								vakata_dnd.helper_w = vakata_dnd.helper.outerWidth();
							}
							vakata_dnd.is_drag = true;
							$(vakata_dnd.target).one('click.vakata', false);
							/**
							 * triggered on the document when a drag starts
							 * @event
							 * @plugin dnd
							 * @name dnd_start.vakata
							 * @param {Mixed} data any data supplied with the call to $.vakata.dnd.start
							 * @param {DOM} element the DOM element being dragged
							 * @param {jQuery} helper the helper shown next to the mouse
							 * @param {Object} event the event that caused the start (probably mousemove)
							 */
							$.vakata.dnd._trigger("start", e);
						}
						else { return; }
					}
	
					var d  = false, w  = false,
						dh = false, wh = false,
						dw = false, ww = false,
						dt = false, dl = false,
						ht = false, hl = false;
	
					vakata_dnd.scroll_t = 0;
					vakata_dnd.scroll_l = 0;
					vakata_dnd.scroll_e = false;
					$($(e.target).parentsUntil("body").addBack().get().reverse())
						.filter(function () {
							return	(/^auto|scroll$/).test($(this).css("overflow")) &&
									(this.scrollHeight > this.offsetHeight || this.scrollWidth > this.offsetWidth);
						})
						.each(function () {
							var t = $(this), o = t.offset();
							if(this.scrollHeight > this.offsetHeight) {
								if(o.top + t.height() - e.pageY < $.vakata.dnd.settings.scroll_proximity)	{ vakata_dnd.scroll_t = 1; }
								if(e.pageY - o.top < $.vakata.dnd.settings.scroll_proximity)				{ vakata_dnd.scroll_t = -1; }
							}
							if(this.scrollWidth > this.offsetWidth) {
								if(o.left + t.width() - e.pageX < $.vakata.dnd.settings.scroll_proximity)	{ vakata_dnd.scroll_l = 1; }
								if(e.pageX - o.left < $.vakata.dnd.settings.scroll_proximity)				{ vakata_dnd.scroll_l = -1; }
							}
							if(vakata_dnd.scroll_t || vakata_dnd.scroll_l) {
								vakata_dnd.scroll_e = $(this);
								return false;
							}
						});
	
					if(!vakata_dnd.scroll_e) {
						d  = $(document); w = $(window);
						dh = d.height(); wh = w.height();
						dw = d.width(); ww = w.width();
						dt = d.scrollTop(); dl = d.scrollLeft();
						if(dh > wh && e.pageY - dt < $.vakata.dnd.settings.scroll_proximity)		{ vakata_dnd.scroll_t = -1;  }
						if(dh > wh && wh - (e.pageY - dt) < $.vakata.dnd.settings.scroll_proximity)	{ vakata_dnd.scroll_t = 1; }
						if(dw > ww && e.pageX - dl < $.vakata.dnd.settings.scroll_proximity)		{ vakata_dnd.scroll_l = -1; }
						if(dw > ww && ww - (e.pageX - dl) < $.vakata.dnd.settings.scroll_proximity)	{ vakata_dnd.scroll_l = 1; }
						if(vakata_dnd.scroll_t || vakata_dnd.scroll_l) {
							vakata_dnd.scroll_e = d;
						}
					}
					if(vakata_dnd.scroll_e) { $.vakata.dnd._scroll(true); }
	
					if(vakata_dnd.helper) {
						ht = parseInt(e.pageY + $.vakata.dnd.settings.helper_top, 10);
						hl = parseInt(e.pageX + $.vakata.dnd.settings.helper_left, 10);
						if(dh && ht + 25 > dh) { ht = dh - 50; }
						if(dw && hl + vakata_dnd.helper_w > dw) { hl = dw - (vakata_dnd.helper_w + 2); }
						vakata_dnd.helper.css({
							left	: hl + "px",
							top		: ht + "px"
						});
					}
					/**
					 * triggered on the document when a drag is in progress
					 * @event
					 * @plugin dnd
					 * @name dnd_move.vakata
					 * @param {Mixed} data any data supplied with the call to $.vakata.dnd.start
					 * @param {DOM} element the DOM element being dragged
					 * @param {jQuery} helper the helper shown next to the mouse
					 * @param {Object} event the event that caused this to trigger (most likely mousemove)
					 */
					$.vakata.dnd._trigger("move", e);
					return false;
				},
				stop : function (e) {
					if(e.type === "touchend" && e.originalEvent && e.originalEvent.changedTouches && e.originalEvent.changedTouches[0]) {
						e.pageX = e.originalEvent.changedTouches[0].pageX;
						e.pageY = e.originalEvent.changedTouches[0].pageY;
						e.target = document.elementFromPoint(e.originalEvent.changedTouches[0].pageX - window.pageXOffset, e.originalEvent.changedTouches[0].pageY - window.pageYOffset);
					}
					if(vakata_dnd.is_drag) {
						/**
						 * triggered on the document when a drag stops (the dragged element is dropped)
						 * @event
						 * @plugin dnd
						 * @name dnd_stop.vakata
						 * @param {Mixed} data any data supplied with the call to $.vakata.dnd.start
						 * @param {DOM} element the DOM element being dragged
						 * @param {jQuery} helper the helper shown next to the mouse
						 * @param {Object} event the event that caused the stop
						 */
						if (e.target !== vakata_dnd.target) {
							$(vakata_dnd.target).off('click.vakata');
						}
						$.vakata.dnd._trigger("stop", e);
					}
					else {
						if(e.type === "touchend" && e.target === vakata_dnd.target) {
							var to = setTimeout(function () { $(e.target).click(); }, 100);
							$(e.target).one('click', function() { if(to) { clearTimeout(to); } });
						}
					}
					$.vakata.dnd._clean();
					return false;
				}
			};
		}($));
	
		// include the dnd plugin by default
		// $.jstree.defaults.plugins.push("dnd");
	
	
	/**
	 * ### Massload plugin
	 *
	 * Adds massload functionality to jsTree, so that multiple nodes can be loaded in a single request (only useful with lazy loading).
	 */
	
		/**
		 * massload configuration
		 *
		 * It is possible to set this to a standard jQuery-like AJAX config.
		 * In addition to the standard jQuery ajax options here you can supply functions for `data` and `url`, the functions will be run in the current instance's scope and a param will be passed indicating which node IDs need to be loaded, the return value of those functions will be used.
		 *
		 * You can also set this to a function, that function will receive the node IDs being loaded as argument and a second param which is a function (callback) which should be called with the result.
		 *
		 * Both the AJAX and the function approach rely on the same return value - an object where the keys are the node IDs, and the value is the children of that node as an array.
		 *
		 *	{
		 *		"id1" : [{ "text" : "Child of ID1", "id" : "c1" }, { "text" : "Another child of ID1", "id" : "c2" }],
		 *		"id2" : [{ "text" : "Child of ID2", "id" : "c3" }]
		 *	}
		 * 
		 * @name $.jstree.defaults.massload
		 * @plugin massload
		 */
		$.jstree.defaults.massload = null;
		$.jstree.plugins.massload = function (options, parent) {
			this.init = function (el, options) {
				this._data.massload = {};
				parent.init.call(this, el, options);
			};
			this._load_nodes = function (nodes, callback, is_callback, force_reload) {
				var s = this.settings.massload,
					nodesString = JSON.stringify(nodes),
					toLoad = [],
					m = this._model.data,
					i, j, dom;
				if (!is_callback) {
					for(i = 0, j = nodes.length; i < j; i++) {
						if(!m[nodes[i]] || ( (!m[nodes[i]].state.loaded && !m[nodes[i]].state.failed) || force_reload) ) {
							toLoad.push(nodes[i]);
							dom = this.get_node(nodes[i], true);
							if (dom && dom.length) {
								dom.addClass("jstree-loading").attr('aria-busy',true);
							}
						}
					}
					this._data.massload = {};
					if (toLoad.length) {
						if($.isFunction(s)) {
							return s.call(this, toLoad, $.proxy(function (data) {
								var i, j;
								if(data) {
									for(i in data) {
										if(data.hasOwnProperty(i)) {
											this._data.massload[i] = data[i];
										}
									}
								}
								for(i = 0, j = nodes.length; i < j; i++) {
									dom = this.get_node(nodes[i], true);
									if (dom && dom.length) {
										dom.removeClass("jstree-loading").attr('aria-busy',false);
									}
								}
								parent._load_nodes.call(this, nodes, callback, is_callback, force_reload);
							}, this));
						}
						if(typeof s === 'object' && s && s.url) {
							s = $.extend(true, {}, s);
							if($.isFunction(s.url)) {
								s.url = s.url.call(this, toLoad);
							}
							if($.isFunction(s.data)) {
								s.data = s.data.call(this, toLoad);
							}
							return $.ajax(s)
								.done($.proxy(function (data,t,x) {
										var i, j;
										if(data) {
											for(i in data) {
												if(data.hasOwnProperty(i)) {
													this._data.massload[i] = data[i];
												}
											}
										}
										for(i = 0, j = nodes.length; i < j; i++) {
											dom = this.get_node(nodes[i], true);
											if (dom && dom.length) {
												dom.removeClass("jstree-loading").attr('aria-busy',false);
											}
										}
										parent._load_nodes.call(this, nodes, callback, is_callback, force_reload);
									}, this))
								.fail($.proxy(function (f) {
										parent._load_nodes.call(this, nodes, callback, is_callback, force_reload);
									}, this));
						}
					}
				}
				return parent._load_nodes.call(this, nodes, callback, is_callback, force_reload);
			};
			this._load_node = function (obj, callback) {
				var data = this._data.massload[obj.id],
					rslt = null, dom;
				if(data) {
					rslt = this[typeof data === 'string' ? '_append_html_data' : '_append_json_data'](
						obj,
						typeof data === 'string' ? $($.parseHTML(data)).filter(function () { return this.nodeType !== 3; }) : data,
						function (status) { callback.call(this, status); }
					);
					dom = this.get_node(obj.id, true);
					if (dom && dom.length) {
						dom.removeClass("jstree-loading").attr('aria-busy',false);
					}
					delete this._data.massload[obj.id];
					return rslt;
				}
				return parent._load_node.call(this, obj, callback);
			};
		};
	
	/**
	 * ### Search plugin
	 *
	 * Adds search functionality to jsTree.
	 */
	
		/**
		 * stores all defaults for the search plugin
		 * @name $.jstree.defaults.search
		 * @plugin search
		 */
		$.jstree.defaults.search = {
			/**
			 * a jQuery-like AJAX config, which jstree uses if a server should be queried for results.
			 *
			 * A `str` (which is the search string) parameter will be added with the request, an optional `inside` parameter will be added if the search is limited to a node id. The expected result is a JSON array with nodes that need to be opened so that matching nodes will be revealed.
			 * Leave this setting as `false` to not query the server. You can also set this to a function, which will be invoked in the instance's scope and receive 3 parameters - the search string, the callback to call with the array of nodes to load, and the optional node ID to limit the search to
			 * @name $.jstree.defaults.search.ajax
			 * @plugin search
			 */
			ajax : false,
			/**
			 * Indicates if the search should be fuzzy or not (should `chnd3` match `child node 3`). Default is `false`.
			 * @name $.jstree.defaults.search.fuzzy
			 * @plugin search
			 */
			fuzzy : false,
			/**
			 * Indicates if the search should be case sensitive. Default is `false`.
			 * @name $.jstree.defaults.search.case_sensitive
			 * @plugin search
			 */
			case_sensitive : false,
			/**
			 * Indicates if the tree should be filtered (by default) to show only matching nodes (keep in mind this can be a heavy on large trees in old browsers).
			 * This setting can be changed at runtime when calling the search method. Default is `false`.
			 * @name $.jstree.defaults.search.show_only_matches
			 * @plugin search
			 */
			show_only_matches : false,
			/**
			 * Indicates if the children of matched element are shown (when show_only_matches is true)
			 * This setting can be changed at runtime when calling the search method. Default is `false`.
			 * @name $.jstree.defaults.search.show_only_matches_children
			 * @plugin search
			 */
			show_only_matches_children : false,
			/**
			 * Indicates if all nodes opened to reveal the search result, should be closed when the search is cleared or a new search is performed. Default is `true`.
			 * @name $.jstree.defaults.search.close_opened_onclear
			 * @plugin search
			 */
			close_opened_onclear : true,
			/**
			 * Indicates if only leaf nodes should be included in search results. Default is `false`.
			 * @name $.jstree.defaults.search.search_leaves_only
			 * @plugin search
			 */
			search_leaves_only : false,
			/**
			 * If set to a function it wil be called in the instance's scope with two arguments - search string and node (where node will be every node in the structure, so use with caution).
			 * If the function returns a truthy value the node will be considered a match (it might not be displayed if search_only_leaves is set to true and the node is not a leaf). Default is `false`.
			 * @name $.jstree.defaults.search.search_callback
			 * @plugin search
			 */
			search_callback : false
		};
	
		$.jstree.plugins.search = function (options, parent) {
			this.bind = function () {
				parent.bind.call(this);
	
				this._data.search.str = "";
				this._data.search.dom = $();
				this._data.search.res = [];
				this._data.search.opn = [];
				this._data.search.som = false;
				this._data.search.smc = false;
				this._data.search.hdn = [];
	
				this.element
					.on("search.jstree", $.proxy(function (e, data) {
							if(this._data.search.som && data.res.length) {
								var m = this._model.data, i, j, p = [], k, l;
								for(i = 0, j = data.res.length; i < j; i++) {
									if(m[data.res[i]] && !m[data.res[i]].state.hidden) {
										p.push(data.res[i]);
										p = p.concat(m[data.res[i]].parents);
										if(this._data.search.smc) {
											for (k = 0, l = m[data.res[i]].children_d.length; k < l; k++) {
												if (m[m[data.res[i]].children_d[k]] && !m[m[data.res[i]].children_d[k]].state.hidden) {
													p.push(m[data.res[i]].children_d[k]);
												}
											}
										}
									}
								}
								p = $.vakata.array_remove_item($.vakata.array_unique(p), $.jstree.root);
								this._data.search.hdn = this.hide_all(true);
								this.show_node(p, true);
								this.redraw(true);
							}
						}, this))
					.on("clear_search.jstree", $.proxy(function (e, data) {
							if(this._data.search.som && data.res.length) {
								this.show_node(this._data.search.hdn, true);
								this.redraw(true);
							}
						}, this));
			};
			/**
			 * used to search the tree nodes for a given string
			 * @name search(str [, skip_async])
			 * @param {String} str the search string
			 * @param {Boolean} skip_async if set to true server will not be queried even if configured
			 * @param {Boolean} show_only_matches if set to true only matching nodes will be shown (keep in mind this can be very slow on large trees or old browsers)
			 * @param {mixed} inside an optional node to whose children to limit the search
			 * @param {Boolean} append if set to true the results of this search are appended to the previous search
			 * @plugin search
			 * @trigger search.jstree
			 */
			this.search = function (str, skip_async, show_only_matches, inside, append, show_only_matches_children) {
				if(str === false || $.trim(str.toString()) === "") {
					return this.clear_search();
				}
				inside = this.get_node(inside);
				inside = inside && inside.id ? inside.id : null;
				str = str.toString();
				var s = this.settings.search,
					a = s.ajax ? s.ajax : false,
					m = this._model.data,
					f = null,
					r = [],
					p = [], i, j;
				if(this._data.search.res.length && !append) {
					this.clear_search();
				}
				if(show_only_matches === undefined) {
					show_only_matches = s.show_only_matches;
				}
				if(show_only_matches_children === undefined) {
					show_only_matches_children = s.show_only_matches_children;
				}
				if(!skip_async && a !== false) {
					if($.isFunction(a)) {
						return a.call(this, str, $.proxy(function (d) {
								if(d && d.d) { d = d.d; }
								this._load_nodes(!$.isArray(d) ? [] : $.vakata.array_unique(d), function () {
									this.search(str, true, show_only_matches, inside, append, show_only_matches_children);
								});
							}, this), inside);
					}
					else {
						a = $.extend({}, a);
						if(!a.data) { a.data = {}; }
						a.data.str = str;
						if(inside) {
							a.data.inside = inside;
						}
						if (this._data.search.lastRequest) {
							this._data.search.lastRequest.abort();
						}
						this._data.search.lastRequest = $.ajax(a)
							.fail($.proxy(function () {
								this._data.core.last_error = { 'error' : 'ajax', 'plugin' : 'search', 'id' : 'search_01', 'reason' : 'Could not load search parents', 'data' : JSON.stringify(a) };
								this.settings.core.error.call(this, this._data.core.last_error);
							}, this))
							.done($.proxy(function (d) {
								if(d && d.d) { d = d.d; }
								this._load_nodes(!$.isArray(d) ? [] : $.vakata.array_unique(d), function () {
									this.search(str, true, show_only_matches, inside, append, show_only_matches_children);
								});
							}, this));
						return this._data.search.lastRequest;
					}
				}
				if(!append) {
					this._data.search.str = str;
					this._data.search.dom = $();
					this._data.search.res = [];
					this._data.search.opn = [];
					this._data.search.som = show_only_matches;
					this._data.search.smc = show_only_matches_children;
				}
	
				f = new $.vakata.search(str, true, { caseSensitive : s.case_sensitive, fuzzy : s.fuzzy });
				$.each(m[inside ? inside : $.jstree.root].children_d, function (ii, i) {
					var v = m[i];
					if(v.text && !v.state.hidden && (!s.search_leaves_only || (v.state.loaded && v.children.length === 0)) && ( (s.search_callback && s.search_callback.call(this, str, v)) || (!s.search_callback && f.search(v.text).isMatch) ) ) {
						r.push(i);
						p = p.concat(v.parents);
					}
				});
				if(r.length) {
					p = $.vakata.array_unique(p);
					for(i = 0, j = p.length; i < j; i++) {
						if(p[i] !== $.jstree.root && m[p[i]] && this.open_node(p[i], null, 0) === true) {
							this._data.search.opn.push(p[i]);
						}
					}
					if(!append) {
						this._data.search.dom = $(this.element[0].querySelectorAll('#' + $.map(r, function (v) { return "0123456789".indexOf(v[0]) !== -1 ? '\\3' + v[0] + ' ' + v.substr(1).replace($.jstree.idregex,'\\$&') : v.replace($.jstree.idregex,'\\$&'); }).join(', #')));
						this._data.search.res = r;
					}
					else {
						this._data.search.dom = this._data.search.dom.add($(this.element[0].querySelectorAll('#' + $.map(r, function (v) { return "0123456789".indexOf(v[0]) !== -1 ? '\\3' + v[0] + ' ' + v.substr(1).replace($.jstree.idregex,'\\$&') : v.replace($.jstree.idregex,'\\$&'); }).join(', #'))));
						this._data.search.res = $.vakata.array_unique(this._data.search.res.concat(r));
					}
					this._data.search.dom.children(".jstree-anchor").addClass('jstree-search');
				}
				/**
				 * triggered after search is complete
				 * @event
				 * @name search.jstree
				 * @param {jQuery} nodes a jQuery collection of matching nodes
				 * @param {String} str the search string
				 * @param {Array} res a collection of objects represeing the matching nodes
				 * @plugin search
				 */
				this.trigger('search', { nodes : this._data.search.dom, str : str, res : this._data.search.res, show_only_matches : show_only_matches });
			};
			/**
			 * used to clear the last search (removes classes and shows all nodes if filtering is on)
			 * @name clear_search()
			 * @plugin search
			 * @trigger clear_search.jstree
			 */
			this.clear_search = function () {
				if(this.settings.search.close_opened_onclear) {
					this.close_node(this._data.search.opn, 0);
				}
				/**
				 * triggered after search is complete
				 * @event
				 * @name clear_search.jstree
				 * @param {jQuery} nodes a jQuery collection of matching nodes (the result from the last search)
				 * @param {String} str the search string (the last search string)
				 * @param {Array} res a collection of objects represeing the matching nodes (the result from the last search)
				 * @plugin search
				 */
				this.trigger('clear_search', { 'nodes' : this._data.search.dom, str : this._data.search.str, res : this._data.search.res });
				if(this._data.search.res.length) {
					this._data.search.dom = $(this.element[0].querySelectorAll('#' + $.map(this._data.search.res, function (v) {
						return "0123456789".indexOf(v[0]) !== -1 ? '\\3' + v[0] + ' ' + v.substr(1).replace($.jstree.idregex,'\\$&') : v.replace($.jstree.idregex,'\\$&');
					}).join(', #')));
					this._data.search.dom.children(".jstree-anchor").removeClass("jstree-search");
				}
				this._data.search.str = "";
				this._data.search.res = [];
				this._data.search.opn = [];
				this._data.search.dom = $();
			};
	
			this.redraw_node = function(obj, deep, callback, force_render) {
				obj = parent.redraw_node.apply(this, arguments);
				if(obj) {
					if($.inArray(obj.id, this._data.search.res) !== -1) {
						var i, j, tmp = null;
						for(i = 0, j = obj.childNodes.length; i < j; i++) {
							if(obj.childNodes[i] && obj.childNodes[i].className && obj.childNodes[i].className.indexOf("jstree-anchor") !== -1) {
								tmp = obj.childNodes[i];
								break;
							}
						}
						if(tmp) {
							tmp.className += ' jstree-search';
						}
					}
				}
				return obj;
			};
		};
	
		// helpers
		(function ($) {
			// from http://kiro.me/projects/fuse.html
			$.vakata.search = function(pattern, txt, options) {
				options = options || {};
				options = $.extend({}, $.vakata.search.defaults, options);
				if(options.fuzzy !== false) {
					options.fuzzy = true;
				}
				pattern = options.caseSensitive ? pattern : pattern.toLowerCase();
				var MATCH_LOCATION	= options.location,
					MATCH_DISTANCE	= options.distance,
					MATCH_THRESHOLD	= options.threshold,
					patternLen = pattern.length,
					matchmask, pattern_alphabet, match_bitapScore, search;
				if(patternLen > 32) {
					options.fuzzy = false;
				}
				if(options.fuzzy) {
					matchmask = 1 << (patternLen - 1);
					pattern_alphabet = (function () {
						var mask = {},
							i = 0;
						for (i = 0; i < patternLen; i++) {
							mask[pattern.charAt(i)] = 0;
						}
						for (i = 0; i < patternLen; i++) {
							mask[pattern.charAt(i)] |= 1 << (patternLen - i - 1);
						}
						return mask;
					}());
					match_bitapScore = function (e, x) {
						var accuracy = e / patternLen,
							proximity = Math.abs(MATCH_LOCATION - x);
						if(!MATCH_DISTANCE) {
							return proximity ? 1.0 : accuracy;
						}
						return accuracy + (proximity / MATCH_DISTANCE);
					};
				}
				search = function (text) {
					text = options.caseSensitive ? text : text.toLowerCase();
					if(pattern === text || text.indexOf(pattern) !== -1) {
						return {
							isMatch: true,
							score: 0
						};
					}
					if(!options.fuzzy) {
						return {
							isMatch: false,
							score: 1
						};
					}
					var i, j,
						textLen = text.length,
						scoreThreshold = MATCH_THRESHOLD,
						bestLoc = text.indexOf(pattern, MATCH_LOCATION),
						binMin, binMid,
						binMax = patternLen + textLen,
						lastRd, start, finish, rd, charMatch,
						score = 1,
						locations = [];
					if (bestLoc !== -1) {
						scoreThreshold = Math.min(match_bitapScore(0, bestLoc), scoreThreshold);
						bestLoc = text.lastIndexOf(pattern, MATCH_LOCATION + patternLen);
						if (bestLoc !== -1) {
							scoreThreshold = Math.min(match_bitapScore(0, bestLoc), scoreThreshold);
						}
					}
					bestLoc = -1;
					for (i = 0; i < patternLen; i++) {
						binMin = 0;
						binMid = binMax;
						while (binMin < binMid) {
							if (match_bitapScore(i, MATCH_LOCATION + binMid) <= scoreThreshold) {
								binMin = binMid;
							} else {
								binMax = binMid;
							}
							binMid = Math.floor((binMax - binMin) / 2 + binMin);
						}
						binMax = binMid;
						start = Math.max(1, MATCH_LOCATION - binMid + 1);
						finish = Math.min(MATCH_LOCATION + binMid, textLen) + patternLen;
						rd = new Array(finish + 2);
						rd[finish + 1] = (1 << i) - 1;
						for (j = finish; j >= start; j--) {
							charMatch = pattern_alphabet[text.charAt(j - 1)];
							if (i === 0) {
								rd[j] = ((rd[j + 1] << 1) | 1) & charMatch;
							} else {
								rd[j] = ((rd[j + 1] << 1) | 1) & charMatch | (((lastRd[j + 1] | lastRd[j]) << 1) | 1) | lastRd[j + 1];
							}
							if (rd[j] & matchmask) {
								score = match_bitapScore(i, j - 1);
								if (score <= scoreThreshold) {
									scoreThreshold = score;
									bestLoc = j - 1;
									locations.push(bestLoc);
									if (bestLoc > MATCH_LOCATION) {
										start = Math.max(1, 2 * MATCH_LOCATION - bestLoc);
									} else {
										break;
									}
								}
							}
						}
						if (match_bitapScore(i + 1, MATCH_LOCATION) > scoreThreshold) {
							break;
						}
						lastRd = rd;
					}
					return {
						isMatch: bestLoc >= 0,
						score: score
					};
				};
				return txt === true ? { 'search' : search } : search(txt);
			};
			$.vakata.search.defaults = {
				location : 0,
				distance : 100,
				threshold : 0.6,
				fuzzy : false,
				caseSensitive : false
			};
		}($));
	
		// include the search plugin by default
		// $.jstree.defaults.plugins.push("search");
	
	
	/**
	 * ### Sort plugin
	 *
	 * Automatically sorts all siblings in the tree according to a sorting function.
	 */
	
		/**
		 * the settings function used to sort the nodes.
		 * It is executed in the tree's context, accepts two nodes as arguments and should return `1` or `-1`.
		 * @name $.jstree.defaults.sort
		 * @plugin sort
		 */
		$.jstree.defaults.sort = function (a, b) {
			//return this.get_type(a) === this.get_type(b) ? (this.get_text(a) > this.get_text(b) ? 1 : -1) : this.get_type(a) >= this.get_type(b);
			return this.get_text(a) > this.get_text(b) ? 1 : -1;
		};
		$.jstree.plugins.sort = function (options, parent) {
			this.bind = function () {
				parent.bind.call(this);
				this.element
					.on("model.jstree", $.proxy(function (e, data) {
							this.sort(data.parent, true);
						}, this))
					.on("rename_node.jstree create_node.jstree", $.proxy(function (e, data) {
							this.sort(data.parent || data.node.parent, false);
							this.redraw_node(data.parent || data.node.parent, true);
						}, this))
					.on("move_node.jstree copy_node.jstree", $.proxy(function (e, data) {
							this.sort(data.parent, false);
							this.redraw_node(data.parent, true);
						}, this));
			};
			/**
			 * used to sort a node's children
			 * @private
			 * @name sort(obj [, deep])
			 * @param  {mixed} obj the node
			 * @param {Boolean} deep if set to `true` nodes are sorted recursively.
			 * @plugin sort
			 * @trigger search.jstree
			 */
			this.sort = function (obj, deep) {
				var i, j;
				obj = this.get_node(obj);
				if(obj && obj.children && obj.children.length) {
					obj.children.sort($.proxy(this.settings.sort, this));
					if(deep) {
						for(i = 0, j = obj.children_d.length; i < j; i++) {
							this.sort(obj.children_d[i], false);
						}
					}
				}
			};
		};
	
		// include the sort plugin by default
		// $.jstree.defaults.plugins.push("sort");
	
	/**
	 * ### State plugin
	 *
	 * Saves the state of the tree (selected nodes, opened nodes) on the user's computer using available options (localStorage, cookies, etc)
	 */
	
		var to = false;
		/**
		 * stores all defaults for the state plugin
		 * @name $.jstree.defaults.state
		 * @plugin state
		 */
		$.jstree.defaults.state = {
			/**
			 * A string for the key to use when saving the current tree (change if using multiple trees in your project). Defaults to `jstree`.
			 * @name $.jstree.defaults.state.key
			 * @plugin state
			 */
			key		: 'jstree',
			/**
			 * A space separated list of events that trigger a state save. Defaults to `changed.jstree open_node.jstree close_node.jstree`.
			 * @name $.jstree.defaults.state.events
			 * @plugin state
			 */
			events	: 'changed.jstree open_node.jstree close_node.jstree check_node.jstree uncheck_node.jstree',
			/**
			 * Time in milliseconds after which the state will expire. Defaults to 'false' meaning - no expire.
			 * @name $.jstree.defaults.state.ttl
			 * @plugin state
			 */
			ttl		: false,
			/**
			 * A function that will be executed prior to restoring state with one argument - the state object. Can be used to clear unwanted parts of the state.
			 * @name $.jstree.defaults.state.filter
			 * @plugin state
			 */
			filter	: false
		};
		$.jstree.plugins.state = function (options, parent) {
			this.bind = function () {
				parent.bind.call(this);
				var bind = $.proxy(function () {
					this.element.on(this.settings.state.events, $.proxy(function () {
						if(to) { clearTimeout(to); }
						to = setTimeout($.proxy(function () { this.save_state(); }, this), 100);
					}, this));
					/**
					 * triggered when the state plugin is finished restoring the state (and immediately after ready if there is no state to restore).
					 * @event
					 * @name state_ready.jstree
					 * @plugin state
					 */
					this.trigger('state_ready');
				}, this);
				this.element
					.on("ready.jstree", $.proxy(function (e, data) {
							this.element.one("restore_state.jstree", bind);
							if(!this.restore_state()) { bind(); }
						}, this));
			};
			/**
			 * save the state
			 * @name save_state()
			 * @plugin state
			 */
			this.save_state = function () {
				var st = { 'state' : this.get_state(), 'ttl' : this.settings.state.ttl, 'sec' : +(new Date()) };
				$.vakata.storage.set(this.settings.state.key, JSON.stringify(st));
			};
			/**
			 * restore the state from the user's computer
			 * @name restore_state()
			 * @plugin state
			 */
			this.restore_state = function () {
				var k = $.vakata.storage.get(this.settings.state.key);
				if(!!k) { try { k = JSON.parse(k); } catch(ex) { return false; } }
				if(!!k && k.ttl && k.sec && +(new Date()) - k.sec > k.ttl) { return false; }
				if(!!k && k.state) { k = k.state; }
				if(!!k && $.isFunction(this.settings.state.filter)) { k = this.settings.state.filter.call(this, k); }
				if(!!k) {
					this.element.one("set_state.jstree", function (e, data) { data.instance.trigger('restore_state', { 'state' : $.extend(true, {}, k) }); });
					this.set_state(k);
					return true;
				}
				return false;
			};
			/**
			 * clear the state on the user's computer
			 * @name clear_state()
			 * @plugin state
			 */
			this.clear_state = function () {
				return $.vakata.storage.del(this.settings.state.key);
			};
		};
	
		(function ($, undefined) {
			$.vakata.storage = {
				// simply specifying the functions in FF throws an error
				set : function (key, val) { return window.localStorage.setItem(key, val); },
				get : function (key) { return window.localStorage.getItem(key); },
				del : function (key) { return window.localStorage.removeItem(key); }
			};
		}($));
	
		// include the state plugin by default
		// $.jstree.defaults.plugins.push("state");
	
	/**
	 * ### Types plugin
	 *
	 * Makes it possible to add predefined types for groups of nodes, which make it possible to easily control nesting rules and icon for each group.
	 */
	
		/**
		 * An object storing all types as key value pairs, where the key is the type name and the value is an object that could contain following keys (all optional).
		 *
		 * * `max_children` the maximum number of immediate children this node type can have. Do not specify or set to `-1` for unlimited.
		 * * `max_depth` the maximum number of nesting this node type can have. A value of `1` would mean that the node can have children, but no grandchildren. Do not specify or set to `-1` for unlimited.
		 * * `valid_children` an array of node type strings, that nodes of this type can have as children. Do not specify or set to `-1` for no limits.
		 * * `icon` a string - can be a path to an icon or a className, if using an image that is in the current directory use a `./` prefix, otherwise it will be detected as a class. Omit to use the default icon from your theme.
		 * * `li_attr` an object of values which will be used to add HTML attributes on the resulting LI DOM node (merged with the node's own data)
		 * * `a_attr` an object of values which will be used to add HTML attributes on the resulting A DOM node (merged with the node's own data)
		 *
		 * There are two predefined types:
		 *
		 * * `#` represents the root of the tree, for example `max_children` would control the maximum number of root nodes.
		 * * `default` represents the default node - any settings here will be applied to all nodes that do not have a type specified.
		 *
		 * @name $.jstree.defaults.types
		 * @plugin types
		 */
		$.jstree.defaults.types = {
			'default' : {}
		};
		$.jstree.defaults.types[$.jstree.root] = {};
	
		$.jstree.plugins.types = function (options, parent) {
			this.init = function (el, options) {
				var i, j;
				if(options && options.types && options.types['default']) {
					for(i in options.types) {
						if(i !== "default" && i !== $.jstree.root && options.types.hasOwnProperty(i)) {
							for(j in options.types['default']) {
								if(options.types['default'].hasOwnProperty(j) && options.types[i][j] === undefined) {
									options.types[i][j] = options.types['default'][j];
								}
							}
						}
					}
				}
				parent.init.call(this, el, options);
				this._model.data[$.jstree.root].type = $.jstree.root;
			};
			this.refresh = function (skip_loading, forget_state) {
				parent.refresh.call(this, skip_loading, forget_state);
				this._model.data[$.jstree.root].type = $.jstree.root;
			};
			this.bind = function () {
				this.element
					.on('model.jstree', $.proxy(function (e, data) {
							var m = this._model.data,
								dpc = data.nodes,
								t = this.settings.types,
								i, j, c = 'default', k;
							for(i = 0, j = dpc.length; i < j; i++) {
								c = 'default';
								if(m[dpc[i]].original && m[dpc[i]].original.type && t[m[dpc[i]].original.type]) {
									c = m[dpc[i]].original.type;
								}
								if(m[dpc[i]].data && m[dpc[i]].data.jstree && m[dpc[i]].data.jstree.type && t[m[dpc[i]].data.jstree.type]) {
									c = m[dpc[i]].data.jstree.type;
								}
								m[dpc[i]].type = c;
								if(m[dpc[i]].icon === true && t[c].icon !== undefined) {
									m[dpc[i]].icon = t[c].icon;
								}
								if(t[c].li_attr !== undefined && typeof t[c].li_attr === 'object') {
									for (k in t[c].li_attr) {
										if (t[c].li_attr.hasOwnProperty(k)) {
											if (k === 'id') {
												continue;
											}
											else if (m[dpc[i]].li_attr[k] === undefined) {
												m[dpc[i]].li_attr[k] = t[c].li_attr[k];
											}
											else if (k === 'class') {
												m[dpc[i]].li_attr['class'] = t[c].li_attr['class'] + ' ' + m[dpc[i]].li_attr['class'];
											}
										}
									}
								}
								if(t[c].a_attr !== undefined && typeof t[c].a_attr === 'object') {
									for (k in t[c].a_attr) {
										if (t[c].a_attr.hasOwnProperty(k)) {
											if (k === 'id') {
												continue;
											}
											else if (m[dpc[i]].a_attr[k] === undefined) {
												m[dpc[i]].a_attr[k] = t[c].a_attr[k];
											}
											else if (k === 'href' && m[dpc[i]].a_attr[k] === '#') {
												m[dpc[i]].a_attr['href'] = t[c].a_attr['href'];
											}
											else if (k === 'class') {
												m[dpc[i]].a_attr['class'] = t[c].a_attr['class'] + ' ' + m[dpc[i]].a_attr['class'];
											}
										}
									}
								}
							}
							m[$.jstree.root].type = $.jstree.root;
						}, this));
				parent.bind.call(this);
			};
			this.get_json = function (obj, options, flat) {
				var i, j,
					m = this._model.data,
					opt = options ? $.extend(true, {}, options, {no_id:false}) : {},
					tmp = parent.get_json.call(this, obj, opt, flat);
				if(tmp === false) { return false; }
				if($.isArray(tmp)) {
					for(i = 0, j = tmp.length; i < j; i++) {
						tmp[i].type = tmp[i].id && m[tmp[i].id] && m[tmp[i].id].type ? m[tmp[i].id].type : "default";
						if(options && options.no_id) {
							delete tmp[i].id;
							if(tmp[i].li_attr && tmp[i].li_attr.id) {
								delete tmp[i].li_attr.id;
							}
							if(tmp[i].a_attr && tmp[i].a_attr.id) {
								delete tmp[i].a_attr.id;
							}
						}
					}
				}
				else {
					tmp.type = tmp.id && m[tmp.id] && m[tmp.id].type ? m[tmp.id].type : "default";
					if(options && options.no_id) {
						tmp = this._delete_ids(tmp);
					}
				}
				return tmp;
			};
			this._delete_ids = function (tmp) {
				if($.isArray(tmp)) {
					for(var i = 0, j = tmp.length; i < j; i++) {
						tmp[i] = this._delete_ids(tmp[i]);
					}
					return tmp;
				}
				delete tmp.id;
				if(tmp.li_attr && tmp.li_attr.id) {
					delete tmp.li_attr.id;
				}
				if(tmp.a_attr && tmp.a_attr.id) {
					delete tmp.a_attr.id;
				}
				if(tmp.children && $.isArray(tmp.children)) {
					tmp.children = this._delete_ids(tmp.children);
				}
				return tmp;
			};
			this.check = function (chk, obj, par, pos, more) {
				if(parent.check.call(this, chk, obj, par, pos, more) === false) { return false; }
				obj = obj && obj.id ? obj : this.get_node(obj);
				par = par && par.id ? par : this.get_node(par);
				var m = obj && obj.id ? (more && more.origin ? more.origin : $.jstree.reference(obj.id)) : null, tmp, d, i, j;
				m = m && m._model && m._model.data ? m._model.data : null;
				switch(chk) {
					case "create_node":
					case "move_node":
					case "copy_node":
						if(chk !== 'move_node' || $.inArray(obj.id, par.children) === -1) {
							tmp = this.get_rules(par);
							if(tmp.max_children !== undefined && tmp.max_children !== -1 && tmp.max_children === par.children.length) {
								this._data.core.last_error = { 'error' : 'check', 'plugin' : 'types', 'id' : 'types_01', 'reason' : 'max_children prevents function: ' + chk, 'data' : JSON.stringify({ 'chk' : chk, 'pos' : pos, 'obj' : obj && obj.id ? obj.id : false, 'par' : par && par.id ? par.id : false }) };
								return false;
							}
							if(tmp.valid_children !== undefined && tmp.valid_children !== -1 && $.inArray((obj.type || 'default'), tmp.valid_children) === -1) {
								this._data.core.last_error = { 'error' : 'check', 'plugin' : 'types', 'id' : 'types_02', 'reason' : 'valid_children prevents function: ' + chk, 'data' : JSON.stringify({ 'chk' : chk, 'pos' : pos, 'obj' : obj && obj.id ? obj.id : false, 'par' : par && par.id ? par.id : false }) };
								return false;
							}
							if(m && obj.children_d && obj.parents) {
								d = 0;
								for(i = 0, j = obj.children_d.length; i < j; i++) {
									d = Math.max(d, m[obj.children_d[i]].parents.length);
								}
								d = d - obj.parents.length + 1;
							}
							if(d <= 0 || d === undefined) { d = 1; }
							do {
								if(tmp.max_depth !== undefined && tmp.max_depth !== -1 && tmp.max_depth < d) {
									this._data.core.last_error = { 'error' : 'check', 'plugin' : 'types', 'id' : 'types_03', 'reason' : 'max_depth prevents function: ' + chk, 'data' : JSON.stringify({ 'chk' : chk, 'pos' : pos, 'obj' : obj && obj.id ? obj.id : false, 'par' : par && par.id ? par.id : false }) };
									return false;
								}
								par = this.get_node(par.parent);
								tmp = this.get_rules(par);
								d++;
							} while(par);
						}
						break;
				}
				return true;
			};
			/**
			 * used to retrieve the type settings object for a node
			 * @name get_rules(obj)
			 * @param {mixed} obj the node to find the rules for
			 * @return {Object}
			 * @plugin types
			 */
			this.get_rules = function (obj) {
				obj = this.get_node(obj);
				if(!obj) { return false; }
				var tmp = this.get_type(obj, true);
				if(tmp.max_depth === undefined) { tmp.max_depth = -1; }
				if(tmp.max_children === undefined) { tmp.max_children = -1; }
				if(tmp.valid_children === undefined) { tmp.valid_children = -1; }
				return tmp;
			};
			/**
			 * used to retrieve the type string or settings object for a node
			 * @name get_type(obj [, rules])
			 * @param {mixed} obj the node to find the rules for
			 * @param {Boolean} rules if set to `true` instead of a string the settings object will be returned
			 * @return {String|Object}
			 * @plugin types
			 */
			this.get_type = function (obj, rules) {
				obj = this.get_node(obj);
				return (!obj) ? false : ( rules ? $.extend({ 'type' : obj.type }, this.settings.types[obj.type]) : obj.type);
			};
			/**
			 * used to change a node's type
			 * @name set_type(obj, type)
			 * @param {mixed} obj the node to change
			 * @param {String} type the new type
			 * @plugin types
			 */
			this.set_type = function (obj, type) {
				var m = this._model.data, t, t1, t2, old_type, old_icon, k, d, a;
				if($.isArray(obj)) {
					obj = obj.slice();
					for(t1 = 0, t2 = obj.length; t1 < t2; t1++) {
						this.set_type(obj[t1], type);
					}
					return true;
				}
				t = this.settings.types;
				obj = this.get_node(obj);
				if(!t[type] || !obj) { return false; }
				d = this.get_node(obj, true);
				if (d && d.length) {
					a = d.children('.jstree-anchor');
				}
				old_type = obj.type;
				old_icon = this.get_icon(obj);
				obj.type = type;
				if(old_icon === true || !t[old_type] || (t[old_type].icon !== undefined && old_icon === t[old_type].icon)) {
					this.set_icon(obj, t[type].icon !== undefined ? t[type].icon : true);
				}
	
				// remove old type props
				if(t[old_type] && t[old_type].li_attr !== undefined && typeof t[old_type].li_attr === 'object') {
					for (k in t[old_type].li_attr) {
						if (t[old_type].li_attr.hasOwnProperty(k)) {
							if (k === 'id') {
								continue;
							}
							else if (k === 'class') {
								m[obj.id].li_attr['class'] = (m[obj.id].li_attr['class'] || '').replace(t[old_type].li_attr[k], '');
								if (d) { d.removeClass(t[old_type].li_attr[k]); }
							}
							else if (m[obj.id].li_attr[k] === t[old_type].li_attr[k]) {
								m[obj.id].li_attr[k] = null;
								if (d) { d.removeAttr(k); }
							}
						}
					}
				}
				if(t[old_type] && t[old_type].a_attr !== undefined && typeof t[old_type].a_attr === 'object') {
					for (k in t[old_type].a_attr) {
						if (t[old_type].a_attr.hasOwnProperty(k)) {
							if (k === 'id') {
								continue;
							}
							else if (k === 'class') {
								m[obj.id].a_attr['class'] = (m[obj.id].a_attr['class'] || '').replace(t[old_type].a_attr[k], '');
								if (a) { a.removeClass(t[old_type].a_attr[k]); }
							}
							else if (m[obj.id].a_attr[k] === t[old_type].a_attr[k]) {
								if (k === 'href') {
									m[obj.id].a_attr[k] = '#';
									if (a) { a.attr('href', '#'); }
								}
								else {
									delete m[obj.id].a_attr[k];
									if (a) { a.removeAttr(k); }
								}
							}
						}
					}
				}
	
				// add new props
				if(t[type].li_attr !== undefined && typeof t[type].li_attr === 'object') {
					for (k in t[type].li_attr) {
						if (t[type].li_attr.hasOwnProperty(k)) {
							if (k === 'id') {
								continue;
							}
							else if (m[obj.id].li_attr[k] === undefined) {
								m[obj.id].li_attr[k] = t[type].li_attr[k];
								if (d) {
									if (k === 'class') {
										d.addClass(t[type].li_attr[k]);
									}
									else {
										d.attr(k, t[type].li_attr[k]);
									}
								}
							}
							else if (k === 'class') {
								m[obj.id].li_attr['class'] = t[type].li_attr[k] + ' ' + m[obj.id].li_attr['class'];
								if (d) { d.addClass(t[type].li_attr[k]); }
							}
						}
					}
				}
				if(t[type].a_attr !== undefined && typeof t[type].a_attr === 'object') {
					for (k in t[type].a_attr) {
						if (t[type].a_attr.hasOwnProperty(k)) {
							if (k === 'id') {
								continue;
							}
							else if (m[obj.id].a_attr[k] === undefined) {
								m[obj.id].a_attr[k] = t[type].a_attr[k];
								if (a) {
									if (k === 'class') {
										a.addClass(t[type].a_attr[k]);
									}
									else {
										a.attr(k, t[type].a_attr[k]);
									}
								}
							}
							else if (k === 'href' && m[obj.id].a_attr[k] === '#') {
								m[obj.id].a_attr['href'] = t[type].a_attr['href'];
								if (a) { a.attr('href', t[type].a_attr['href']); }
							}
							else if (k === 'class') {
								m[obj.id].a_attr['class'] = t[type].a_attr['class'] + ' ' + m[obj.id].a_attr['class'];
								if (a) { a.addClass(t[type].a_attr[k]); }
							}
						}
					}
				}
	
				return true;
			};
		};
		// include the types plugin by default
		// $.jstree.defaults.plugins.push("types");
	
	
	/**
	 * ### Unique plugin
	 *
	 * Enforces that no nodes with the same name can coexist as siblings.
	 */
	
		/**
		 * stores all defaults for the unique plugin
		 * @name $.jstree.defaults.unique
		 * @plugin unique
		 */
		$.jstree.defaults.unique = {
			/**
			 * Indicates if the comparison should be case sensitive. Default is `false`.
			 * @name $.jstree.defaults.unique.case_sensitive
			 * @plugin unique
			 */
			case_sensitive : false,
			/**
			 * A callback executed in the instance's scope when a new node is created and the name is already taken, the two arguments are the conflicting name and the counter. The default will produce results like `New node (2)`.
			 * @name $.jstree.defaults.unique.duplicate
			 * @plugin unique
			 */
			duplicate : function (name, counter) {
				return name + ' (' + counter + ')';
			}
		};
	
		$.jstree.plugins.unique = function (options, parent) {
			this.check = function (chk, obj, par, pos, more) {
				if(parent.check.call(this, chk, obj, par, pos, more) === false) { return false; }
				obj = obj && obj.id ? obj : this.get_node(obj);
				par = par && par.id ? par : this.get_node(par);
				if(!par || !par.children) { return true; }
				var n = chk === "rename_node" ? pos : obj.text,
					c = [],
					s = this.settings.unique.case_sensitive,
					m = this._model.data, i, j;
				for(i = 0, j = par.children.length; i < j; i++) {
					c.push(s ? m[par.children[i]].text : m[par.children[i]].text.toLowerCase());
				}
				if(!s) { n = n.toLowerCase(); }
				switch(chk) {
					case "delete_node":
						return true;
					case "rename_node":
						i = ($.inArray(n, c) === -1 || (obj.text && obj.text[ s ? 'toString' : 'toLowerCase']() === n));
						if(!i) {
							this._data.core.last_error = { 'error' : 'check', 'plugin' : 'unique', 'id' : 'unique_01', 'reason' : 'Child with name ' + n + ' already exists. Preventing: ' + chk, 'data' : JSON.stringify({ 'chk' : chk, 'pos' : pos, 'obj' : obj && obj.id ? obj.id : false, 'par' : par && par.id ? par.id : false }) };
						}
						return i;
					case "create_node":
						i = ($.inArray(n, c) === -1);
						if(!i) {
							this._data.core.last_error = { 'error' : 'check', 'plugin' : 'unique', 'id' : 'unique_04', 'reason' : 'Child with name ' + n + ' already exists. Preventing: ' + chk, 'data' : JSON.stringify({ 'chk' : chk, 'pos' : pos, 'obj' : obj && obj.id ? obj.id : false, 'par' : par && par.id ? par.id : false }) };
						}
						return i;
					case "copy_node":
						i = ($.inArray(n, c) === -1);
						if(!i) {
							this._data.core.last_error = { 'error' : 'check', 'plugin' : 'unique', 'id' : 'unique_02', 'reason' : 'Child with name ' + n + ' already exists. Preventing: ' + chk, 'data' : JSON.stringify({ 'chk' : chk, 'pos' : pos, 'obj' : obj && obj.id ? obj.id : false, 'par' : par && par.id ? par.id : false }) };
						}
						return i;
					case "move_node":
						i = ( (obj.parent === par.id && (!more || !more.is_multi)) || $.inArray(n, c) === -1);
						if(!i) {
							this._data.core.last_error = { 'error' : 'check', 'plugin' : 'unique', 'id' : 'unique_03', 'reason' : 'Child with name ' + n + ' already exists. Preventing: ' + chk, 'data' : JSON.stringify({ 'chk' : chk, 'pos' : pos, 'obj' : obj && obj.id ? obj.id : false, 'par' : par && par.id ? par.id : false }) };
						}
						return i;
				}
				return true;
			};
			this.create_node = function (par, node, pos, callback, is_loaded) {
				if(!node || node.text === undefined) {
					if(par === null) {
						par = $.jstree.root;
					}
					par = this.get_node(par);
					if(!par) {
						return parent.create_node.call(this, par, node, pos, callback, is_loaded);
					}
					pos = pos === undefined ? "last" : pos;
					if(!pos.toString().match(/^(before|after)$/) && !is_loaded && !this.is_loaded(par)) {
						return parent.create_node.call(this, par, node, pos, callback, is_loaded);
					}
					if(!node) { node = {}; }
					var tmp, n, dpc, i, j, m = this._model.data, s = this.settings.unique.case_sensitive, cb = this.settings.unique.duplicate;
					n = tmp = this.get_string('New node');
					dpc = [];
					for(i = 0, j = par.children.length; i < j; i++) {
						dpc.push(s ? m[par.children[i]].text : m[par.children[i]].text.toLowerCase());
					}
					i = 1;
					while($.inArray(s ? n : n.toLowerCase(), dpc) !== -1) {
						n = cb.call(this, tmp, (++i)).toString();
					}
					node.text = n;
				}
				return parent.create_node.call(this, par, node, pos, callback, is_loaded);
			};
		};
	
		// include the unique plugin by default
		// $.jstree.defaults.plugins.push("unique");
	
	
	/**
	 * ### Wholerow plugin
	 *
	 * Makes each node appear block level. Making selection easier. May cause slow down for large trees in old browsers.
	 */
	
		var div = document.createElement('DIV');
		div.setAttribute('unselectable','on');
		div.setAttribute('role','presentation');
		div.className = 'jstree-wholerow';
		div.innerHTML = '&#160;';
		$.jstree.plugins.wholerow = function (options, parent) {
			this.bind = function () {
				parent.bind.call(this);
	
				this.element
					.on('ready.jstree set_state.jstree', $.proxy(function () {
							this.hide_dots();
						}, this))
					.on("init.jstree loading.jstree ready.jstree", $.proxy(function () {
							//div.style.height = this._data.core.li_height + 'px';
							this.get_container_ul().addClass('jstree-wholerow-ul');
						}, this))
					.on("deselect_all.jstree", $.proxy(function (e, data) {
							this.element.find('.jstree-wholerow-clicked').removeClass('jstree-wholerow-clicked');
						}, this))
					.on("changed.jstree", $.proxy(function (e, data) {
							this.element.find('.jstree-wholerow-clicked').removeClass('jstree-wholerow-clicked');
							var tmp = false, i, j;
							for(i = 0, j = data.selected.length; i < j; i++) {
								tmp = this.get_node(data.selected[i], true);
								if(tmp && tmp.length) {
									tmp.children('.jstree-wholerow').addClass('jstree-wholerow-clicked');
								}
							}
						}, this))
					.on("open_node.jstree", $.proxy(function (e, data) {
							this.get_node(data.node, true).find('.jstree-clicked').parent().children('.jstree-wholerow').addClass('jstree-wholerow-clicked');
						}, this))
					.on("hover_node.jstree dehover_node.jstree", $.proxy(function (e, data) {
							if(e.type === "hover_node" && this.is_disabled(data.node)) { return; }
							this.get_node(data.node, true).children('.jstree-wholerow')[e.type === "hover_node"?"addClass":"removeClass"]('jstree-wholerow-hovered');
						}, this))
					.on("contextmenu.jstree", ".jstree-wholerow", $.proxy(function (e) {
							if (this._data.contextmenu) {
								e.preventDefault();
								var tmp = $.Event('contextmenu', { metaKey : e.metaKey, ctrlKey : e.ctrlKey, altKey : e.altKey, shiftKey : e.shiftKey, pageX : e.pageX, pageY : e.pageY });
								$(e.currentTarget).closest(".jstree-node").children(".jstree-anchor").first().trigger(tmp);
							}
						}, this))
					/*!
					.on("mousedown.jstree touchstart.jstree", ".jstree-wholerow", function (e) {
							if(e.target === e.currentTarget) {
								var a = $(e.currentTarget).closest(".jstree-node").children(".jstree-anchor");
								e.target = a[0];
								a.trigger(e);
							}
						})
					*/
					.on("click.jstree", ".jstree-wholerow", function (e) {
							e.stopImmediatePropagation();
							var tmp = $.Event('click', { metaKey : e.metaKey, ctrlKey : e.ctrlKey, altKey : e.altKey, shiftKey : e.shiftKey });
							$(e.currentTarget).closest(".jstree-node").children(".jstree-anchor").first().trigger(tmp).focus();
						})
					.on("dblclick.jstree", ".jstree-wholerow", function (e) {
							e.stopImmediatePropagation();
							var tmp = $.Event('dblclick', { metaKey : e.metaKey, ctrlKey : e.ctrlKey, altKey : e.altKey, shiftKey : e.shiftKey });
							$(e.currentTarget).closest(".jstree-node").children(".jstree-anchor").first().trigger(tmp).focus();
						})
					.on("click.jstree", ".jstree-leaf > .jstree-ocl", $.proxy(function (e) {
							e.stopImmediatePropagation();
							var tmp = $.Event('click', { metaKey : e.metaKey, ctrlKey : e.ctrlKey, altKey : e.altKey, shiftKey : e.shiftKey });
							$(e.currentTarget).closest(".jstree-node").children(".jstree-anchor").first().trigger(tmp).focus();
						}, this))
					.on("mouseover.jstree", ".jstree-wholerow, .jstree-icon", $.proxy(function (e) {
							e.stopImmediatePropagation();
							if(!this.is_disabled(e.currentTarget)) {
								this.hover_node(e.currentTarget);
							}
							return false;
						}, this))
					.on("mouseleave.jstree", ".jstree-node", $.proxy(function (e) {
							this.dehover_node(e.currentTarget);
						}, this));
			};
			this.teardown = function () {
				if(this.settings.wholerow) {
					this.element.find(".jstree-wholerow").remove();
				}
				parent.teardown.call(this);
			};
			this.redraw_node = function(obj, deep, callback, force_render) {
				obj = parent.redraw_node.apply(this, arguments);
				if(obj) {
					var tmp = div.cloneNode(true);
					//tmp.style.height = this._data.core.li_height + 'px';
					if($.inArray(obj.id, this._data.core.selected) !== -1) { tmp.className += ' jstree-wholerow-clicked'; }
					if(this._data.core.focused && this._data.core.focused === obj.id) { tmp.className += ' jstree-wholerow-hovered'; }
					obj.insertBefore(tmp, obj.childNodes[0]);
				}
				return obj;
			};
		};
		// include the wholerow plugin by default
		// $.jstree.defaults.plugins.push("wholerow");
		if(document.registerElement && Object && Object.create) {
			var proto = Object.create(HTMLElement.prototype);
			proto.createdCallback = function () {
				var c = { core : {}, plugins : [] }, i;
				for(i in $.jstree.plugins) {
					if($.jstree.plugins.hasOwnProperty(i) && this.attributes[i]) {
						c.plugins.push(i);
						if(this.getAttribute(i) && JSON.parse(this.getAttribute(i))) {
							c[i] = JSON.parse(this.getAttribute(i));
						}
					}
				}
				for(i in $.jstree.defaults.core) {
					if($.jstree.defaults.core.hasOwnProperty(i) && this.attributes[i]) {
						c.core[i] = JSON.parse(this.getAttribute(i)) || this.getAttribute(i);
					}
				}
				$(this).jstree(c);
			};
			// proto.attributeChangedCallback = function (name, previous, value) { };
			try {
				document.registerElement("vakata-jstree", { prototype: proto });
			} catch(ignore) { }
		}
	
	}));

/***/ },
/* 97 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(jQuery, $) {'use strict';
	
	/**
	 * required to include: lazy-selector-modal.html
	 *
	 * availiable option :
	 * {
	 *    selector: 'attractions' , 'venues', '',
	 *    hideMultiSelector: true, false
	 * }
	 * $('.js_lazy-selector').lazySelector();
	 * $('.js_lazy-selector-attractions').lazySelector('{selector: 'attractions'});
	 * $('.js_lazy-selector-venues').lazySelector({selector:'venues', hideMultiSelector:true});
	 */
	
	(function ($) {
	  var config = ['events', 'venues', 'attractions'],
	      tagsIds = {},
	      initialVal = {};
	
	  config.forEach(function (el) {
	    tagsIds[el] = [];
	    initialVal[el] = [];
	  });
	
	  $.fn.lazySelector = function (options) {
	    var defaults = {},
	        settings = $.extend({}, $.fn.lazySelector.defaults, options),
	        $iconButton = $('<a class="icon" id="get-event-by-Id-' + options.selector + '" data-toggle="modal" data-target="#js_ls-modal" />');
	
	    var stateConf = {
	      pageIncrement: 0,
	      loadingFlag: false,
	      setSingleVal: false
	    };
	
	    var $input = $(this),
	        $modal = $('#js_ls-modal'),
	        $form = $('#js_lazy-sel_form', $modal),
	        $ul = $('#js_lazy-sel_list'),
	        $liFooter = $('#load-more-box'),
	        $hr = $('#js_ls-top-hr'),
	        $btnGET = $modal.find('#js_ls-modal_btn'),
	        btnCloseMap = $('.button-close-map', $modal),
	        cssValidationClass = 'get-eventId_form-validation',
	        modalContent = $('.modal-content', $modal),
	        $msSelection = $('.ms-selection'),
	        $msList = $('.ms-list', $msSelection),
	        $msBtnUse = $('#js_ms-use-btn', $msSelection);
	
	    var keyword = $form.find('#keyword'),
	        defaultApiKey = apiKeyService.getApiExploreKey(),
	        apikey = apiKeyService.checkApiKeyCookie('tk-api-key') || $('#w-tm-api-key').val() || defaultApiKey,
	        selector = options.selector || 'events',
	        eventUrl = 'https://app.ticketmaster.com/discovery/v2/' + selector + '.json';
	
	    function formatDate(date) {
	      var result = '';
	      if (!date.day) return result; // Day is required
	
	      var MONTH_NAMES = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'],
	          DAY_NAMES = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'],
	          dayArray = date.day.split('-'),
	          d = parseInt(dayArray[2]),
	          M = parseInt(dayArray[1]);
	
	      var E = new Date(date.day).getDay();
	
	      //var E1 = new Date(+date.day.split('-')[0],(+date.day.split('-')[1])-1,+date.day.split('-')[2]).getDay();
	      //if(E !== E1) console.log('\t alarm equal - ' , E === E1);
	
	      result = DAY_NAMES[E] + ', ' + MONTH_NAMES[M - 1] + ' ' + d + ', ' + dayArray[0];
	
	      if (!date.time) return result;
	
	      var timeArray = date.time.split(':'),
	          H = parseInt(timeArray[0]),
	          m = timeArray[1],
	          a = "AM";
	
	      if (H > 11) a = "PM";
	      if (H === 0) {
	        H = 12;
	      } else if (H > 12) {
	        H = H - 12;
	      }
	
	      return result + ' ' + getNormalizedDateValue(H) + ':' + m + ' ' + a;
	    }
	
	    function getNormalizedDateValue(val) {
	      return (val < 0 || val > 9 ? "" : "0") + val;
	    }
	
	    /**
	     * Show or init map listener
	     * @param e
	     */
	    var mapPopUpListener = function mapPopUpListener(e) {
	      e.preventDefault();
	      var lat = $(e.target).attr('data-latitude') != "undefined" ? parseFloat($(e.target).attr('data-latitude')) : null,
	          lng = $(e.target).attr('data-longitude') != "undefined" ? parseFloat($(e.target).attr('data-longitude')) : null,
	          address = lat && lng ? null : $(e.target).attr('data-address');
	
	      if (lat && lng) {
	        initMap(lat, lng);
	        google.maps.event.trigger(map, "resize"); //'second init'
	      } else {
	        initMap(0, 0); //"first init"
	      }
	    };
	
	    /**
	     * Init map google maps
	     * @param lat - float
	     * @param lng - float
	     * @param address - not used @deprecated
	     */
	    var map = null,
	        markers = [];
	
	    var initMap = function initMap(lat, lng) {
	      var modal = $modal,
	          mapCenter = new google.maps.LatLng(lat || 55, lng || 43);
	
	      if (map === null) {
	        // initialize map object
	        map = new google.maps.Map(document.getElementById('map-canvas'), {
	          center: mapCenter,
	          zoom: 10,
	          mapTypeControl: false,
	          scaleControl: false,
	          fullscreenControl: false,
	          streetViewControl: false,
	          rotateControl: false
	        });
	      } else {
	        clearMarkers();
	
	        //set new center
	        map.panTo(mapCenter); //smooth center. If the change is less than both the width and height of the map, the transition will be smoothly animated.
	        map.setCenter(mapCenter);
	      }
	
	      // Adds a marker at the center of the map.
	      addMarker(mapCenter);
	
	      // when map popup is shown
	      modal.on("shown.bs.modal", function () {
	        // Recenter the map now that it's been redrawn
	        google.maps.event.trigger(map, "resize");
	        map.setCenter(mapCenter);
	      });
	      modal.modal(); // show map popup
	    };
	
	    // Adds a marker to the map and push to the array.
	    function addMarker(mapCenter) {
	      var marker = new google.maps.Marker({ //Create a marker and set its position.
	        map: map,
	        position: mapCenter,
	        icon: new google.maps.MarkerImage('../../../../assets/controls/pin-ic.svg', null, null, null, new google.maps.Size(34, 52))
	      });
	      markers.push(marker);
	    }
	
	    // Removes the markers from the map, but keeps them in the array.
	    function clearMarkers() {
	      for (var i = 0; i < markers.length; i++) {
	        markers[i].setMap(null);
	      }
	      markers = [];
	    }
	
	    function closeMapListener() {
	      modalContent.removeClass('narrow');
	      btnCloseMap.hide(); // 'X' -button
	    }
	
	    function toggleTags() {
	      var indToRemove = [],
	          inputValArray = $input.val().split(",");
	
	      $('li', $msList).each(function (i) {
	        var listItem = $(this),
	            id = listItem.data('selector-' + selector);
	
	        if (listItem.data('selector-' + selector)) {
	          listItem.show();
	          if (jQuery.inArray(id, inputValArray) === -1) {
	            indToRemove.push(id);
	            listItem.remove();
	          }
	        } else {
	          listItem.hide();
	        }
	      });
	
	      //filter by : [indToRemove]
	      tagsIds[selector] = tagsIds[selector].filter(function (el) {
	        return !indToRemove.includes(el);
	      });
	    }
	
	    function toggleMsSelectionBox() {
	      if ($('li', $msList).length < 1) {
	        $msSelection.hide();
	        return;
	      }
	
	      $('li', $msList).each(function (i) {
	        var listItem = $(this);
	        if (listItem.data('selector-' + selector)) {
	          $msSelection.show();
	          return false;
	        } else $msSelection.hide();
	      });
	    }
	
	    /**
	     * change <Load_More> button text on open modal
	     * set data-selector gor "GET" button
	     */
	    function changeModalTextListener() {
	      if (selector !== 'events') {
	        $('.modal-title span', $modal).text(selector);
	        $('#js_ls-more_btn', $modal).text('SHOW MORE ' + selector);
	      }
	      if (selector === 'venues') {
	        $('.wrapper-list-group', $modal).addClass('low-height');
	        $msSelection.addClass('hidden-xs');
	      } else {
	        $('.wrapper-list-group', $modal).removeClass('low-height');
	        $msSelection.removeClass('hidden-xs');
	      }
	
	      if (options.hideMultiSelector) {
	        $msSelection.hide();
	      } else {
	        if ($('li', $msList).length > 0) {
	          $msSelection.show(); // console.log('show $msList',$('li',$msList).length);
	        }
	        toggleTags();
	        toggleMsSelectionBox();
	      }
	
	      $btnGET.attr('data-selector', selector);
	    }
	
	    /**
	     * show/hide loader
	     * @param action - string ('on' or 'off')
	     */
	    var loading = function loading(action) {
	      var spinner = $('#spinner-ls', $modal);
	      // add the overlay with loading image to the page
	      if (action == "on") {
	        spinner.show();
	      } else if (action == "off") {
	        spinner.hide();
	      }
	    };
	
	    function resetForm() {
	      stateConf.pageIncrement = 0;
	      var listItems = $ul.find('li');
	      listItems.remove();
	      $hr.hide();
	      $liFooter.hide();
	
	      // Clear highlight
	      $form.removeClass(cssValidationClass);
	
	      // Clear Listener, prevent memory leak
	      $("#js_ls-modal").off("click", "ul li button.js_ms-add-list_btn", addMsButtonListener);
	      $('#js_open-map_btn').off("click", mapListener);
	    }
	
	    /**
	     * Handler for 'GET' button
	     * @param pageNumero - int. used for pagination
	     * @param eventUrl - url of request
	     * @returns {boolean} - done/fail
	     */
	    function submitForm( /*optional*/pageNumero) {
	      pageNumero = parseInt(pageNumero);
	
	      var url = isNaN(pageNumero) ? eventUrl + '?apikey=' + apikey + '&keyword=' + keyword.val() : eventUrl + '?apikey=' + apikey + '&keyword=' + keyword.val() + '&page=' + pageNumero;
	
	      //stop load
	      if (isNaN(pageNumero) && pageNumero !== 0 && stateConf.loadingFlag === 'STOP_LOAD') {
	        renderResults(null, $ul);
	        return false;
	      }
	
	      //stop load
	      if (stateConf.loadingFlag === 'FINAL_PAGE') return false;
	
	      $.ajax({
	        dataType: 'json',
	        async: true,
	        url: url,
	        data: $form.serialize()
	      }).done(function (result) {
	        if (result) {
	          //last page reached
	          if (stateConf.pageIncrement === result.page.totalPages && result.page.totalElements > 0) {
	            stateConf.loadingFlag = 'STOP_LOAD';
	            loading('off');
	            renderResults(result, $ul); //add message at bottom of list
	            return false;
	          }
	
	          renderResults(result, $ul);
	          loading('off');
	        } else {
	          console.log('no result found');
	        }
	      }).fail(function (e) {
	        console.log('There was an fail status - ', e.status);
	        loading('off');
	        renderResults('FAIL', $ul);
	      });
	    }
	
	    /**
	     * find image that have width more then 120px
	     * @param images - array
	     * @returns {image with lowest+1 width }
	     */
	    function getImageForEvent(images) {
	      images.sort(function (a, b) {
	        if (a.width < b.width) return -1;else if (a.width > b.width) return 1;else return 0;
	      });
	      return images[1].url;
	    }
	
	    /**
	     * render for events-id-selector
	     * @param items - array
	     */
	    function renderListEvents(items) {
	      var src;
	      items.map(function (item) {
	        var li = $('<li/>').addClass('list-group-item row')
	        //.insertBefore($liFooter);
	        .appendTo($ul);
	
	        var leftCol = $('<div class="clear-padding" />').appendTo(li);
	        var spanImg = $('<span class="thumbnail" />').appendTo(leftCol);
	
	        if (item.images) {
	          src = "src=" + getImageForEvent(item.images);
	        } else {
	          src = 'style="background-color: #f7f9fa;width: 120px; border: none;"';
	        }
	
	        var img = $('<img ' + src + ' />').addClass('list-group-item-heading').appendTo(spanImg);
	
	        var $wrapCol = $('<div class="event-text-wrapper"/>').appendTo(li);
	        if (item.name) {
	          var title = $('<h4/>').addClass('list-group-item-heading').text(item.name).appendTo($wrapCol);
	        }
	
	        /*add time*/
	        var currentEvent = {};
	        currentEvent.date = {
	          day: item.dates.start.localDate,
	          time: item.dates.start.localTime,
	          dateTime: item.dates.start.dateTime
	        };
	
	        var time = formatDate(currentEvent.date);
	        var eventTime = $('<h4 class="event-time gray"/>').text(time).appendTo($wrapCol);
	        /*add time end*/
	
	        if (item._embedded) {
	
	          if (item._embedded.venues) {
	            var venue = item._embedded.venues[0];
	            var addressName = $('<span/>').addClass('address-name').text(venue.name + '. ').appendTo($wrapCol);
	
	            if ('address' in venue && 'line1' in venue.address) {
	              var addressline1 = $('<span/>').addClass('address-line1').text(venue.address.line1).appendTo($wrapCol);
	              if ('line2' in venue.address) {
	                var addressline2 = $('<span/>').addClass('address-line2').text(venue.address.line2).appendTo(addressline1);
	              }
	            }
	          } else {
	            console.log('no _embedded found');
	          }
	        }
	
	        if (item.id) {
	          //add button <Set this ID> if 'location' exist
	          var buttonSetId = $("<button data-event=" + item.id + "/>").addClass('js_lazy-sel_btn btn btn-submit').text('Use this ID').appendTo(li).wrap('<div class ="wrapper-btns text-right"/>');
	
	          var addToEl = { li: li, buttonSetIdWrapper: buttonSetId.parent() };
	          addMsButton(addToEl, item.id);
	        }
	      });
	    }
	
	    /**
	     * render for venues-id-selector
	     * @param items - array
	     */
	    function renderListVenues(items) {
	      items.map(function (item) {
	
	        var li = $('<li/>').addClass('list-group-item row').appendTo($ul);
	
	        if (item.images) {
	          var leftCol = $('<div class="clear-padding" />').appendTo(li);
	          var spanImg = $('<span class="thumbnail" />').appendTo(leftCol);
	          var img = $('<img src=' + getImageForEvent(item.images) + ' />').addClass('list-group-item-heading').appendTo(spanImg);
	        }
	
	        var $wrapCol = $('<div class="event-text-wrapper clear-margin-left"/>').appendTo(li);
	
	        if (item.name) {
	          var title = $('<h3/>').addClass('list-group-item-heading').text(item.name).appendTo($wrapCol);
	        }
	
	        if (item.dates) {
	          // console.log('item.dates' , item.dates);
	          /*add time*/
	          var currentEvent = {};
	          currentEvent.date = {
	            day: item.dates.start.localDate,
	            time: item.dates.start.localTime,
	            dateTime: item.dates.start.dateTime
	          };
	
	          var time = formatDate(currentEvent.date);
	          var eventTime = $('<h4 class="event-time gray"/>').text(time).appendTo($wrapCol);
	          /*add time end*/
	        }
	
	        if (item) {
	          var venue = item; // item._embedded.venues[0];
	          var contryStateName = $('<h4/>').addClass('country-name gray').text(venue.country && venue.country.name ? venue.country.name : '').append(venue.state && venue.state.name ? $('<span class="add-dot">' + venue.state.name + '</>') : '').appendTo($wrapCol);
	          var cityName = $('<span/>').addClass('address-name').text(venue.city && venue.city.name ? venue.city.name + '. ' : '').appendTo($wrapCol);
	
	          if ('address' in venue && 'line1' in venue.address) {
	            var addressline1 = $('<span/>').addClass('address-line1').text(venue.address.line1 + '.').appendTo($wrapCol);
	            if ('line2' in venue.address) {
	              var addressline2 = $('<span/>').addClass('address-line2').text(venue.address.line2).appendTo(addressline1);
	            }
	          }
	        } else {
	          console.log('no _embedded found');
	        }
	
	        if (item.id) {
	          var buttonSetId = $("<button data-event=" + item.id + "/>").addClass('js_lazy-sel_btn btn btn-submit').text('Use this ID').appendTo(li).wrap('<div class ="wrapper-btns text-right"/>');
	          if (venue.location && venue.location.latitude && venue.location.longitude) {
	            //console.log('venue.location - ' , venue.location);
	            var buttonMap = $("<button data-latitude=" + venue.location.latitude + " data-longitude=" + venue.location.longitude + "/>").addClass('js_open-map_btn btn btn-transparent').text('Show on map').insertAfter(buttonSetId)
	            //.appendTo(buttonSetId)
	            .wrap('<div class ="wrapper-location_btn pull-right"/>');
	          }
	          var addToEl = { li: li, buttonSetIdWrapper: buttonSetId.parent() };
	          addMsButton(addToEl, item.id);
	        }
	      });
	    }
	
	    /**
	     * render for attractions-id-selector
	     * @param items - array
	     */
	    function renderListAttractions(items) {
	      items.map(function (item) {
	
	        var li = $('<li/>').addClass('list-group-item row').appendTo($ul);
	
	        if (item.images) {
	          var leftCol = $('<div class="clear-padding" />').appendTo(li);
	          var spanImg = $('<span class="thumbnail" />').appendTo(leftCol);
	          var img = $('<img src=' + getImageForEvent(item.images) + ' />').addClass('list-group-item-heading').appendTo(spanImg);
	        }
	
	        var $wrapCol = $('<div class="event-text-wrapper clear-margin-left"/>').appendTo(li);
	
	        if (item.name) {
	          var title = $('<h3/>').addClass('list-group-item-heading').text(item.name).appendTo($wrapCol);
	        }
	
	        /*add time*/
	        if (item.dates) {
	          var currentEvent = {};
	          currentEvent.date = {
	            day: item.dates.start.localDate,
	            time: item.dates.start.localTime,
	            dateTime: item.dates.start.dateTime
	          };
	
	          var time = formatDate(currentEvent.date);
	          var eventTime = $('<h4 class="event-time gray"/>').text(time).appendTo($wrapCol);
	        } /*add time end*/
	
	        if (item.classifications) {
	          if (item.classifications.length > 1) console.log(item.classifications.length);
	
	          var _genre, _subgenre, _segment;
	          if (item.classifications[0]) {
	            _segment = item.classifications[0].segment;
	            _genre = item.classifications[0].genre;
	            _subgenre = item.classifications[0].subGenre;
	
	            var segmentText = $('<h4/>').addClass('country-name gray').text(_segment && _segment.name && _segment.name !== 'Undefined' ? _segment.name : '').appendTo($wrapCol);
	
	            var genre = $('<span/>').addClass('classifications-name').append(_genre && _genre.name && _genre.name !== 'Undefined' ? $('<span >' + _genre.name + '</>') : '').append(_subgenre && _subgenre.name && _subgenre.name !== 'Undefined' ? $('<span class="add-dot">' + _subgenre.name + '</>') : '').appendTo($wrapCol);
	          }
	        }
	        if (item) {
	          var venue = item; // item._embedded.venues[0];
	          var contryStateName = $('<h4/>').addClass('country-name gray').text(venue.country && venue.country.name ? venue.country.name + '. ' : '').append(venue.state && venue.state.name ? venue.state.name + '. ' : '').appendTo($wrapCol);
	          var cityName = $('<span/>').addClass('address-name').text(venue.city && venue.city.name ? venue.city.name + '. ' : '').appendTo($wrapCol);
	
	          if ('address' in venue && 'line1' in venue.address) {
	            var addressline1 = $('<span/>').addClass('address-line1').text(venue.address.line1 + '.').appendTo($wrapCol);
	            if ('line2' in venue.address) {
	              var addressline2 = $('<span/>').addClass('address-line2').text(venue.address.line2).appendTo(addressline1);
	            }
	          }
	        } else {
	          console.log('no _embedded found');
	        }
	
	        if (item.id) {
	          var buttonSetId = $("<button data-event=" + item.id + "/>").addClass('js_lazy-sel_btn btn btn-submit').text('Use this ID').appendTo(li).wrap('<div class ="wrapper-btns text-right"/>');
	          if (venue.location && venue.location.latitude && venue.location.longitude) {
	            //console.log('venue.location - ' , venue.location);
	            var buttonMap = $("<button style='float: right;' data-latitude=" + venue.location.latitude + " data-longitude=" + venue.location.longitude + "/>").addClass('js_open-map_btn btn btn-transparent').text('Show on map').insertAfter(buttonSetId)
	            //.appendTo(buttonSetId)
	            .wrap('<div class ="wrapper-location_btn"/>');
	          }
	          var addToEl = { li: li, buttonSetIdWrapper: buttonSetId.parent() };
	          addMsButton(addToEl, item.id);
	        }
	      });
	    }
	
	    function hasScrollBar(element, wrapper) {
	      return element.get(0).scrollHeight > element.parent().innerHeight();
	    }
	
	    var renderResults = function renderResults(data, ulElement) {
	      var items;
	
	      function showMessage(element, message, /*optional*/clearList) {
	        $btnGET.attr('disabled', false);
	
	        if (clearList) $('li', element).remove();
	        element.css({ 'overflow': 'auto' });
	        $('<li/>').addClass('list-group-item text-center').text(message).appendTo(ulElement);
	      }
	
	      if (stateConf.loadingFlag === "FINAL_PAGE") return false; //exit if has reached last page
	
	      //show fail msg
	      if (data === 'FAIL') {
	        showMessage($ul, 'Failure, possible key not correct.', true);
	        modalContent.removeClass('narrow');
	        return false;
	      }
	
	      if (stateConf.loadingFlag === 'STOP_LOAD' && data.length !== 0) {
	        stateConf.loadingFlag = "FINAL_PAGE";
	        showMessage(ulElement, 'No more results.', false);
	        $liFooter.hide();
	        return false;
	      }
	
	      if (data === null || !data._embedded) {
	        showMessage(ulElement, 'No results found.', true);
	        modalContent.removeClass('narrow');
	        return false;
	      }
	
	      //start render data
	      if (selector === 'events') {
	        items = data && data._embedded && data._embedded.events ? data._embedded.events : [''];
	        renderListEvents(items);
	      } else if (selector === 'venues') {
	        items = data && data._embedded && data._embedded.venues ? data._embedded.venues : [''];
	        renderListVenues(items);
	      } else if (selector === 'attractions') {
	        items = data && data._embedded && data._embedded.attractions ? data._embedded.attractions : [''];
	        renderListAttractions(items);
	      }
	
	      //hide scroll if recive less then 2 items
	      if (hasScrollBar($ul)) {
	        $ul.removeClass('no-scroll');
	      } else {
	        $ul.addClass('no-scroll');
	      }
	
	      // hide/show horizontal line and button <load more>
	      if (data && data.page && data.page.totalElements > 20) {
	        $hr.show();
	        $liFooter.show();
	      } else {
	        $hr.hide();
	        $liFooter.hide();
	      }
	
	      // hide button <load more> if nothing left to load
	      if (stateConf.loadingFlag === 'STOP_LOAD' || stateConf.pageIncrement + 1 === data.page.totalPages) {
	        $hr.hide();
	        $liFooter.hide();
	      }
	      if (data.page.totalElements > 0 || items.length > 0) {
	        $hr.show();
	      }
	
	      //<show map> button
	      $('.js_open-map_btn').on('click', mapListener);
	
	      $('.js_lazy-sel_btn').on('click', setIdListener);
	
	      $("#js_ls-modal").on("click", "ul li button.js_ms-add-list_btn", addMsButtonListener);
	
	      //set availible <Get> button after load is finished
	      $btnGET.attr('disabled', false);
	    };
	
	    function mapListener(e) {
	      var screenWidth = Math.max(document.documentElement.clientWidth, window.innerWidth || 0);
	      var isMobile = false; //initiate as false
	      // device detection
	      if (/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|ipad|iris|kindle|Android|Silk|lge |maemo|midp|mmp|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows (ce|phone)|xda|xiino/i.test(navigator.userAgent) || /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(navigator.userAgent.substr(0, 4))) isMobile = true;
	
	      if (!isMobile || screenWidth >= 768) {
	        mapPopUpListener(e);
	        modalContent.addClass('narrow');
	        btnCloseMap.show();
	      } else if (isMobile) {
	        var lat = $(e.target).attr('data-latitude') != "undefined" ? parseFloat($(e.target).attr('data-latitude')) : null,
	            lng = $(e.target).attr('data-longitude') != "undefined" ? parseFloat($(e.target).attr('data-longitude')) : null;
	        if (lat && lng) {
	          location.href = 'geo:' + lng + ',' + lat;
	        } else {
	          location.href = 'geo:0,0';
	        }
	      }
	    }
	
	    function addMsButton(el, data) {
	      if (options.hideMultiSelector) return false;
	
	      //add button <ADD to list>
	      var buttonAddIdToList = $("<button data-id=" + data + "/>").addClass('js_ms-add-list_btn pull-right btn btn btn-transparent').text('ADD to list').appendTo(el.li.find(el.buttonSetIdWrapper));
	    }
	
	    function setIdListener(e) {
	      var selectedID = e.target.getAttribute('data-event');
	      $input.val(selectedID).attr('value', selectedID).trigger('change'); //update widget:
	      stateConf.setSingleVal = true;
	
	      //clear tags box of current selector (that equal 'selectedID' val)
	      config.forEach(function (el) {
	        tagsIds[selectedID] = [];
	      });
	      // Close dialog
	      $modal.modal('hide');
	    }
	
	    function setIdsListener(e) {
	      if ($btnGET.attr('data-selector') !== $iconButton.attr('data-selector')) return false;
	      var selectedID = tagsIds[selector];
	
	      // set isable=true to all items in tags-list
	      $('li', $msList).each(function () {
	        $(this).attr('data-isable', true);
	      });
	
	      $input.val(selectedID).attr('value', selectedID).trigger('change'); //update widget:
	
	      // Close dialog
	      $modal.modal('hide');
	    }
	
	    function clearByArrVal(selectedID, indToRemove) {
	      function mapAny(array) {
	        array.map(function (item) {
	          selectedID.splice(selectedID.indexOf(item), 1);
	        });
	      }
	
	      if (selectedID.length >= indToRemove.length) {
	        mapAny(indToRemove);
	      } else {
	        mapAny(selectedID);
	      }
	    }
	
	    function delIdListener(event) {
	      event.preventDefault();
	      var me = $(this),
	          tagID = me.parents('li').data('selector-' + selector),
	          selectedID = tagsIds[selector];
	      var indToRemove = [];
	
	      me.parents('li').remove();
	      indToRemove.push(tagID);
	      clearByArrVal(selectedID, indToRemove);
	
	      //update input values
	      $input.val(selectedID).attr('value', selectedID).trigger('change'); //update widget:
	
	      toggleMsSelectionBox();
	    }
	
	    function addMsButtonListener(event) {
	      event.preventDefault();
	
	      function isUnique(list) {
	        var result = [],
	            unique = false;
	
	        $.each(list, function (i, e) {
	          if ($.inArray(e, result) == -1) {
	            result.push(e);
	            unique = true;
	          } else {
	            unique = false;
	          }
	        });
	        return unique;
	      }
	
	      var me = $(this),
	          title = me.parents('li').find('.list-group-item-heading', '.event-text-wrapper').text(),
	          uniqueUpcoming,
	          currentList = tagsIds[selector];
	
	      currentList.push(me.data('id'));
	      uniqueUpcoming = isUnique(currentList); // Get list of upcoming tags
	
	      if (uniqueUpcoming) {
	        var item = $('<li/>').addClass('ms-elem-selection').text(title).attr('data-selector-' + selector, me.data('id')).attr('data-isable', false).appendTo($msList);
	        $('<span/>').appendTo(item).on('click', item, delIdListener);
	      } else {
	        currentList.splice(currentList.length - 1, 1);
	      }
	
	      me.addClass('checked');
	      toggleMsSelectionBox();
	    }
	
	    // EVENTS
	    $btnGET.on('click', function (e) {
	      e.preventDefault();
	      if ($btnGET.attr('data-selector') !== $iconButton.attr('data-selector')) return false; //stop request
	
	      modalContent.removeClass('narrow');
	      var form = $form.get(0);
	      if (!$btnGET.is(':disabled')) {
	        if (form.checkValidity()) {
	          $btnGET.attr('disabled', true);
	          stateConf.pageIncrement = 0;
	          stateConf.loadingFlag = 'KEEP_LOAD';
	          loading('on'); //show loading-spinner
	          resetForm(); //clear
	          submitForm(stateConf.pageIncrement, true);
	        } else {
	          // Highlight errors
	          if (form.reportValidity) form.reportValidity();
	          $form.addClass(cssValidationClass);
	        }
	      }
	    });
	
	    $msBtnUse.on('click', setIdsListener);
	
	    //Close Map button
	    btnCloseMap.on('click', closeMapListener);
	
	    $('#js_ls-more_btn', $liFooter).on('click', function (elm) {
	      if ($btnGET.attr('data-selector') !== $iconButton.attr('data-selector')) return false;
	      // eventUrl = 'https://app.ticketmaster.com/discovery/v2/' + $iconButton.attr('data-selector') + '.json';
	
	      stateConf.pageIncrement++;
	      $btnGET.attr('disabled', true);
	      loading('on');
	      submitForm(stateConf.pageIncrement);
	
	      //Clear Listener, prevent memory leak
	      $("#js_ls-modal").off("click", "ul li button.js_ms-add-list_btn", addMsButtonListener);
	    });
	
	    //multiple selector events
	
	    $form.on("keyup", function (e) {
	      var input = $(e.target);
	      if (e.target.tagName === "INPUT") {
	        if (e.keyCode == 13) {
	          input.blur();
	
	          modalContent.removeClass('narrow');
	          if ($btnGET.attr('data-selector') !== $iconButton.attr('data-selector')) return false;
	
	          if ($form.get(0).checkValidity()) {
	            stateConf.pageIncrement = 0;
	            stateConf.loadingFlag = 'KEEP_LOAD';
	            loading('on');
	            resetForm();
	            submitForm(stateConf.pageIncrement);
	          }
	        }
	      }
	      return false;
	    });
	
	    // Mobile devices. Force 'change' by 'Go' press
	    $form.on("submit", function (e) {
	      e.preventDefault();
	    });
	
	    $modal.on('shown.bs.modal', function () {
	      //save default value to variable for 'events' selector only
	      if (typeof $input.val() !== 'undefined' && $iconButton.attr('data-selector') === 'events') initialVal['events'] = $input.val();
	    }).on('hidden.bs.modal', function (e) {
	      resetForm();
	      closeMapListener();
	
	      var indToRemove = [],
	          selectorBtn = $btnGET.attr('data-selector'),
	          tagsArr = tagsIds[selectorBtn];
	
	      $('li', $msList).each(function (i) {
	        if ($(this).data('isable') === false) {
	          indToRemove.push($(this).data('selector-' + selectorBtn));
	          $(this).remove();
	        }
	      });
	
	      clearByArrVal(tagsArr, indToRemove);
	
	      //clear tags if set Single ID
	      if (selector === selectorBtn && !stateConf.setSingleVal) {
	        //$input.val(tagsArr).attr('value', tagsArr).trigger('change');  //update widget:
	        stateConf.setSingleVal = false;
	      }
	      keyword.val(''); //clear search input
	    });
	
	    return this.each(function () {
	      init($(this));
	
	      function init(input) {
	        input.wrap('<div class="lazy-selector-wrapper"></div>');
	        input.after($iconButton);
	        $iconButton.attr('data-selector', selector);
	
	        $('#get-event-by-Id-' + options.selector + '').on('click', changeModalTextListener);
	        tagsIds[selector] = [];
	      }
	    });
	  };
	})(jQuery);
	
	/**
	 * add lazy selector to widgets
	 */
	$(document).on('ready', function () {
	  $('.js_lazy-selector').lazySelector({ selector: '', hideMultiSelector: true });
	  $('.js_lazy-selector-attractions').lazySelector({ selector: 'attractions' });
	  $('.js_lazy-selector-venues').lazySelector({ selector: 'venues' });
	});
	
	/**
	 * add lazy selector to api-explorer v1 (made by V.Menshutin)
	 */
	$(document).on("finishInit", function (event, flag) {
	  $('#venueId').lazySelector({ selector: 'venues' });
	  $('#attractionId').lazySelector({ selector: 'attractions' });
	});
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2), __webpack_require__(2)))

/***/ },
/* 98 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(jQuery) {'use strict';
	
	var _stringify = __webpack_require__(99);
	
	var _stringify2 = _interopRequireDefault(_stringify);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * required to include: classification-selector-modal.html
	 *
	 * availiable option :
	 * {
	 *    selector: 'classifications'
	 *    use: 'name', 'id'
	 * }
	 * 
	 * $('.js_lazy-selector-attractions').classificationSelector({selector:'classifications', use:'name'});
	 * $('.js_lazy-selector-venues').classificationSelector({selector:'classifications', use:'id'});
	 */
	
	(function ($) {
	
	  $.fn.classificationSelector = function (options) {
	    var defaults = {},
	        settings = $.extend({}, $.fn.lazySelector.defaults, options),
	        $iconButton = $('<a class="icon" id="get-' + options.selector + '-' + options.use + '" data-toggle="modal" data-target="#js_ls-modal-classification" />');
	
	    var $input = $(this),
	        $modal = $('#js_ls-modal-classification'),
	        $form = $('#js_lazy-sel_form', $modal),
	        $btnGET = $modal.find('#js_classification-modal_btn'),
	        cssValidationClass = 'get-eventId_form-validation',
	        modalContent = $('.modal-content', $modal),
	        $jstree = $('#classification-jstree');
	    var keyword = $form.find('#keyword'),
	        apikey = apiKeyService.checkApiKeyCookie('tk-api-key') || $('#w-tm-api-key').val() || apiKeyService.getApiExploreKey(),
	        selector = options.selector,
	        use = options.use,
	        eventUrl = 'https://app.ticketmaster.com/discovery/v2/' + selector + '.json';
	
	    function initTree(json) {
	      json = setChildren(json['_embedded']['classifications']);
	
	      $jstree.jstree({
	        "core": {
	          'check_callback': true,
	          'data': json
	        },
	        "plugins": ["search"],
	        "search": {
	          "show_only_matches": true,
	          /**
	           * Indicates if all nodes opened to reveal the search result, should be closed when the search is cleared or a new search is performed. Default is `true`.
	           * @name $.jstree.defaults.search.close_opened_onclear
	           * @plugin search
	           */
	          "case_sensitive": false
	        }
	      }).on('select_node.jstree', function (e, data) {
	        data.instance.toggle_node(data.node); //set open on one click
	        var i,
	            j,
	            r = [];
	        for (i = 0, j = data.selected.length; i < j; i++) {
	          r.push({
	            text: data.instance.get_node(data.selected[i]).text,
	            id: data.instance.get_node(data.selected[i]).id
	          });
	        }
	
	        $('button', $jstree).off('click', setIdListener).remove();
	
	        $('<button/>').addClass('btn btn-submit btn-small').text('Use').attr('data-classificationId', use === 'name' ? r[0].text : r[0].id).insertAfter($('#' + r[0].id + ' .jstree-clicked', $jstree)).on('click', setIdListener);
	      });
	    }
	
	    function updateTree(json) {
	      var newJson = json['_embedded'] && json['_embedded']['classifications'] ? setChildren(json['_embedded']['classifications']) : null;
	      $jstree.jstree(true).settings.core.data = newJson;
	      $jstree.jstree(true).refresh();
	
	      if (newJson && newJson.length && newJson[0].children.length === 0) {
	        setTimeout(function () {
	          $('.jstree-icon').hide();
	        }, 100);
	      };
	    }
	
	    /**
	     *
	     * @param data {Array} - recived classifications array
	     * @returns {Array}
	     */
	    function setChildren(data) {
	      var newArrObj = [];
	      data = rename(data);
	
	      //rename parent(genres)
	      data.map(function (item) {
	        newArrObj.push({
	          children: item.segment._embedded && item.segment._embedded.genres ? item.segment._embedded.genres : [],
	          text: item.segment.text || '',
	          id: item.segment.id
	        });
	      });
	      //rename/copy child(subgenres) field
	      newArrObj.map(function (item) {
	        item.children.map(function (item) {
	          if (item._embedded && item._embedded.subgenres) {
	            item['children'] = item._embedded.subgenres;
	            delete item._embedded;
	          }
	        });
	      });
	
	      return newArrObj;
	    }
	
	    /**
	     * Rename fields
	     * @param json
	     */
	    function rename(json) {
	      var opt = {
	        root: { fieldName: ['segment'], val: 'text', to: 'name' },
	        parent: { fieldName: ['genres'], '_embedded': true, val: 'text', to: 'name' },
	        child: { fieldName: ['subgenres'], '_embedded': true, val: 'text', to: 'name' }
	      };
	      var arr = (0, _stringify2.default)(json); //convert array to string
	      arr = JSON.parse(arr);
	
	      function replaceAtoB(arr, opt) {
	        var genresArr = [],
	            subgenresArr = [];
	        for (var i = 0; i < arr.length; i++) {
	          arr[i][opt.root.fieldName][opt.root.val] = arr[i][opt.root.fieldName][opt.root.to];
	          delete arr[i][opt.root.fieldName][opt.root.to];
	
	          if (arr[i][opt.root.fieldName]['_embedded'] && opt.parent.fieldName in arr[i][opt.root.fieldName]['_embedded']) {
	            genresArr = arr[i][opt.root.fieldName]['_embedded'][opt.parent.fieldName];
	          }
	          if (0 < genresArr.length) {
	            for (var ii = 0; ii < genresArr.length; ii++) {
	              genresArr[ii][opt.parent.val] = genresArr[ii][opt.parent.to];
	              delete genresArr[ii][opt.parent.to];
	
	              if (genresArr[ii]['_embedded'] && genresArr[ii]['_embedded'][opt.child.fieldName]) {
	                subgenresArr = genresArr[ii]['_embedded'][opt.child.fieldName];
	              }
	              if (0 < subgenresArr.length) {
	                for (var j = 0; j < subgenresArr.length; j++) {
	                  subgenresArr[j][opt.child.val] = subgenresArr[j][opt.child.to];
	                  if (j > 0) delete subgenresArr[j][opt.child.to]; //skip zero item
	                }
	              }
	            }
	          }
	        }
	      }
	      replaceAtoB(arr, opt);
	      return arr;
	    }
	
	    /**
	     * set data-selector for "GET" button
	     */
	    function changeModalTextListener() {
	      $btnGET.attr('data-selector', selector);
	      submitForm(true);
	    }
	
	    /**
	     * show/hide loader
	     * @param action - string ('on' or 'off')
	     */
	    var loading = function loading(action) {
	      var spinner = $('#spinner-ls', $modal);
	      // add the overlay with loading image to the page
	      if (action == "on") {
	        spinner.show();
	      } else if (action == "off") {
	        spinner.hide();
	      }
	    };
	
	    function resetForm() {
	      $jstree.jstree("destroy").removeAttr('class').removeAttr('role').removeAttr('aria-activedescendant');
	      // Clear highlight
	      $form.removeClass(cssValidationClass);
	    }
	
	    /**
	     * Handler for 'GET' button
	     * @param pageNumero - int. used for pagination
	     * @param eventUrl - url of request
	     * @returns {boolean} - done/fail
	     */
	    function submitForm(isInit) {
	      var url = isInit ? eventUrl + '?apikey=' + apikey : eventUrl + '?apikey=' + apikey + '&keyword=' + keyword.val();
	
	      $.ajax({
	        dataType: 'json',
	        async: true,
	        url: url,
	        data: $form.serialize()
	      }).done(function (result) {
	        if (result) {
	          if (result.page.totalElements < 1) {
	            loading('off');
	            renderResults(null, $jstree); //add message at bottom of list
	            return false;
	          };
	
	          isInit ? initTree(result) : updateTree(result);
	          loading('off');
	          $btnGET.attr('disabled', false);
	        } else {
	          console.log('no result found');
	        }
	      }).fail(function (e, textStatus, errorThrown) {
	        console.log('There was an fail status - ', e.status, errorThrown);
	        loading('off');
	        renderResults('FAIL', $jstree, e);
	        $btnGET.attr('disabled', false);
	      });
	    }
	
	    function hasScrollBar(element) {
	      return element.get(0).scrollHeight > element.parent().innerHeight();
	    }
	
	    var renderResults = function renderResults(data, ulElement, errorMsg) {
	      function showMessage(element, message, /*optional*/clearList) {
	        if (clearList) {
	          $('li', element).remove();
	          $('.error-box').remove();
	        }
	
	        $('<div/>').addClass('error-box text-center ').addClass(data === 'FAIL' ? ' error-fail ' : '').append($('<h3/>').text(message.msg)).append($('<p/>').text(message.explanation)).appendTo(ulElement);
	      }
	
	      $btnGET.attr('disabled', false);
	
	      //show fail msg
	      if (data === 'FAIL') {
	        var msgErr = errorMsg.responseJSON !== null ? errorMsg.responseJSON.errors[0].status : 'unknown',
	            statusText = errorMsg.responseJSON !== null ? errorMsg.responseJSON.errors[0].statusText : errorMsg.statusText || '',
	            explanation = errorMsg.responseJSON !== null ? errorMsg.responseJSON.errors[0].detail : 'unknown';
	
	        showMessage($jstree, {
	          msg: 'Error ' + msgErr + ': ' + statusText,
	          explanation: explanation
	        }, true);
	        return false;
	      }
	
	      //show No results found msg
	      if (data === null || !data._embedded) {
	        showMessage(ulElement, { msg: 'No results found.', explanation: 'Please try to get another keyword.' }, true);
	        modalContent.removeClass('narrow');
	        return false;
	      }
	    };
	
	    function setIdListener(e) {
	      var selectedID = e.target.getAttribute('data-classificationId');
	      $input.val(selectedID).attr('value', selectedID).trigger('change'); //update widget:
	
	      // Close dialog
	      $modal.modal('hide');
	    }
	
	    // EVENTS
	    $btnGET.on('click', function (e) {
	      e.preventDefault();
	      if ($btnGET.attr('data-selector') !== $iconButton.attr('data-selector')) return false; //stop request
	
	      var form = $form.get(0);
	      if (!$btnGET.is(':disabled')) {
	        if (form.checkValidity()) {
	          $btnGET.attr('disabled', true);
	          loading('on'); //show loading-spinner
	          submitForm();
	          //resetForm(); //clear
	        } else {
	          // Highlight errors
	          if (form.reportValidity) form.reportValidity();
	          $form.addClass(cssValidationClass);
	        }
	      }
	    });
	
	    $form.on("keyup", function (e) {
	      var input = $(e.target);
	      if (e.target.tagName === "INPUT") {
	        if (e.keyCode == 13) {
	          input.blur();
	
	          modalContent.removeClass('narrow');
	          if ($btnGET.attr('data-selector') !== $iconButton.attr('data-selector')) return false;
	
	          if ($form.get(0).checkValidity()) {
	            loading('on');
	            submitForm();
	          }
	        }
	      }
	      return false;
	    });
	
	    // Mobile devices. Force 'change' by 'Go' press
	    $form.on("submit", function (e) {
	      e.preventDefault();
	    });
	
	    $modal.on('hidden.bs.modal', function () {
	      resetForm();
	      keyword.val(''); //clear search input
	    });
	
	    return this.each(function (i) {
	      init($(this));
	
	      function init(input) {
	        input.wrap('<div class="lazy-selector-wrapper"></div>');
	        input.after($iconButton);
	        $iconButton.attr('data-selector', selector);
	
	        $('#get-' + options.selector + '-' + options.use).on('click', changeModalTextListener);
	      }
	    });
	  };
	})(jQuery);
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ },
/* 99 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(100), __esModule: true };

/***/ },
/* 100 */
/***/ function(module, exports, __webpack_require__) {

	var core  = __webpack_require__(15)
	  , $JSON = core.JSON || (core.JSON = {stringify: JSON.stringify});
	module.exports = function stringify(it){ // eslint-disable-line no-unused-vars
	  return $JSON.stringify.apply($JSON, arguments);
	};

/***/ },
/* 101 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(jQuery) {"use strict";
	
	var _typeof2 = __webpack_require__(4);
	
	var _typeof3 = _interopRequireDefault(_typeof2);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/*!
	 * Bootstrap v3.3.6 (http://getbootstrap.com)
	 * Copyright 2011-2015 Twitter, Inc.
	 * Licensed under the MIT license
	 */
	if ("undefined" == typeof jQuery) throw new Error("Bootstrap's JavaScript requires jQuery");+function (a) {
	  "use strict";
	  var b = a.fn.jquery.split(" ")[0].split(".");if (b[0] < 2 && b[1] < 9 || 1 == b[0] && 9 == b[1] && b[2] < 1 || b[0] > 2) throw new Error("Bootstrap's JavaScript requires jQuery version 1.9.1 or higher, but lower than version 3");
	}(jQuery), +function (a) {
	  "use strict";
	  function b() {
	    var a = document.createElement("bootstrap"),
	        b = { WebkitTransition: "webkitTransitionEnd", MozTransition: "transitionend", OTransition: "oTransitionEnd otransitionend", transition: "transitionend" };for (var c in b) {
	      if (void 0 !== a.style[c]) return { end: b[c] };
	    }return !1;
	  }a.fn.emulateTransitionEnd = function (b) {
	    var c = !1,
	        d = this;a(this).one("bsTransitionEnd", function () {
	      c = !0;
	    });var e = function e() {
	      c || a(d).trigger(a.support.transition.end);
	    };return setTimeout(e, b), this;
	  }, a(function () {
	    a.support.transition = b(), a.support.transition && (a.event.special.bsTransitionEnd = { bindType: a.support.transition.end, delegateType: a.support.transition.end, handle: function handle(b) {
	        return a(b.target).is(this) ? b.handleObj.handler.apply(this, arguments) : void 0;
	      } });
	  });
	}(jQuery), +function (a) {
	  "use strict";
	  function b(b) {
	    return this.each(function () {
	      var c = a(this),
	          e = c.data("bs.alert");e || c.data("bs.alert", e = new d(this)), "string" == typeof b && e[b].call(c);
	    });
	  }var c = '[data-dismiss="alert"]',
	      d = function d(b) {
	    a(b).on("click", c, this.close);
	  };d.VERSION = "3.3.6", d.TRANSITION_DURATION = 150, d.prototype.close = function (b) {
	    function c() {
	      g.detach().trigger("closed.bs.alert").remove();
	    }var e = a(this),
	        f = e.attr("data-target");f || (f = e.attr("href"), f = f && f.replace(/.*(?=#[^\s]*$)/, ""));var g = a(f);b && b.preventDefault(), g.length || (g = e.closest(".alert")), g.trigger(b = a.Event("close.bs.alert")), b.isDefaultPrevented() || (g.removeClass("in"), a.support.transition && g.hasClass("fade") ? g.one("bsTransitionEnd", c).emulateTransitionEnd(d.TRANSITION_DURATION) : c());
	  };var e = a.fn.alert;a.fn.alert = b, a.fn.alert.Constructor = d, a.fn.alert.noConflict = function () {
	    return a.fn.alert = e, this;
	  }, a(document).on("click.bs.alert.data-api", c, d.prototype.close);
	}(jQuery), +function (a) {
	  "use strict";
	  function b(b) {
	    return this.each(function () {
	      var d = a(this),
	          e = d.data("bs.button"),
	          f = "object" == (typeof b === "undefined" ? "undefined" : (0, _typeof3.default)(b)) && b;e || d.data("bs.button", e = new c(this, f)), "toggle" == b ? e.toggle() : b && e.setState(b);
	    });
	  }var c = function c(b, d) {
	    this.$element = a(b), this.options = a.extend({}, c.DEFAULTS, d), this.isLoading = !1;
	  };c.VERSION = "3.3.6", c.DEFAULTS = { loadingText: "loading..." }, c.prototype.setState = function (b) {
	    var c = "disabled",
	        d = this.$element,
	        e = d.is("input") ? "val" : "html",
	        f = d.data();b += "Text", null == f.resetText && d.data("resetText", d[e]()), setTimeout(a.proxy(function () {
	      d[e](null == f[b] ? this.options[b] : f[b]), "loadingText" == b ? (this.isLoading = !0, d.addClass(c).attr(c, c)) : this.isLoading && (this.isLoading = !1, d.removeClass(c).removeAttr(c));
	    }, this), 0);
	  }, c.prototype.toggle = function () {
	    var a = !0,
	        b = this.$element.closest('[data-toggle="buttons"]');if (b.length) {
	      var c = this.$element.find("input");"radio" == c.prop("type") ? (c.prop("checked") && (a = !1), b.find(".active").removeClass("active"), this.$element.addClass("active")) : "checkbox" == c.prop("type") && (c.prop("checked") !== this.$element.hasClass("active") && (a = !1), this.$element.toggleClass("active")), c.prop("checked", this.$element.hasClass("active")), a && c.trigger("change");
	    } else this.$element.attr("aria-pressed", !this.$element.hasClass("active")), this.$element.toggleClass("active");
	  };var d = a.fn.button;a.fn.button = b, a.fn.button.Constructor = c, a.fn.button.noConflict = function () {
	    return a.fn.button = d, this;
	  }, a(document).on("click.bs.button.data-api", '[data-toggle^="button"]', function (c) {
	    var d = a(c.target);d.hasClass("btn") || (d = d.closest(".btn")), b.call(d, "toggle"), a(c.target).is('input[type="radio"]') || a(c.target).is('input[type="checkbox"]') || c.preventDefault();
	  }).on("focus.bs.button.data-api blur.bs.button.data-api", '[data-toggle^="button"]', function (b) {
	    a(b.target).closest(".btn").toggleClass("focus", /^focus(in)?$/.test(b.type));
	  });
	}(jQuery), +function (a) {
	  "use strict";
	  function b(b) {
	    return this.each(function () {
	      var d = a(this),
	          e = d.data("bs.carousel"),
	          f = a.extend({}, c.DEFAULTS, d.data(), "object" == (typeof b === "undefined" ? "undefined" : (0, _typeof3.default)(b)) && b),
	          g = "string" == typeof b ? b : f.slide;e || d.data("bs.carousel", e = new c(this, f)), "number" == typeof b ? e.to(b) : g ? e[g]() : f.interval && e.pause().cycle();
	    });
	  }var c = function c(b, _c) {
	    this.$element = a(b), this.$indicators = this.$element.find(".carousel-indicators"), this.options = _c, this.paused = null, this.sliding = null, this.interval = null, this.$active = null, this.$items = null, this.options.keyboard && this.$element.on("keydown.bs.carousel", a.proxy(this.keydown, this)), "hover" == this.options.pause && !("ontouchstart" in document.documentElement) && this.$element.on("mouseenter.bs.carousel", a.proxy(this.pause, this)).on("mouseleave.bs.carousel", a.proxy(this.cycle, this));
	  };c.VERSION = "3.3.6", c.TRANSITION_DURATION = 600, c.DEFAULTS = { interval: 5e3, pause: "hover", wrap: !0, keyboard: !0 }, c.prototype.keydown = function (a) {
	    if (!/input|textarea/i.test(a.target.tagName)) {
	      switch (a.which) {case 37:
	          this.prev();break;case 39:
	          this.next();break;default:
	          return;}a.preventDefault();
	    }
	  }, c.prototype.cycle = function (b) {
	    return b || (this.paused = !1), this.interval && clearInterval(this.interval), this.options.interval && !this.paused && (this.interval = setInterval(a.proxy(this.next, this), this.options.interval)), this;
	  }, c.prototype.getItemIndex = function (a) {
	    return this.$items = a.parent().children(".item"), this.$items.index(a || this.$active);
	  }, c.prototype.getItemForDirection = function (a, b) {
	    var c = this.getItemIndex(b),
	        d = "prev" == a && 0 === c || "next" == a && c == this.$items.length - 1;if (d && !this.options.wrap) return b;var e = "prev" == a ? -1 : 1,
	        f = (c + e) % this.$items.length;return this.$items.eq(f);
	  }, c.prototype.to = function (a) {
	    var b = this,
	        c = this.getItemIndex(this.$active = this.$element.find(".item.active"));return a > this.$items.length - 1 || 0 > a ? void 0 : this.sliding ? this.$element.one("slid.bs.carousel", function () {
	      b.to(a);
	    }) : c == a ? this.pause().cycle() : this.slide(a > c ? "next" : "prev", this.$items.eq(a));
	  }, c.prototype.pause = function (b) {
	    return b || (this.paused = !0), this.$element.find(".next, .prev").length && a.support.transition && (this.$element.trigger(a.support.transition.end), this.cycle(!0)), this.interval = clearInterval(this.interval), this;
	  }, c.prototype.next = function () {
	    return this.sliding ? void 0 : this.slide("next");
	  }, c.prototype.prev = function () {
	    return this.sliding ? void 0 : this.slide("prev");
	  }, c.prototype.slide = function (b, d) {
	    var e = this.$element.find(".item.active"),
	        f = d || this.getItemForDirection(b, e),
	        g = this.interval,
	        h = "next" == b ? "left" : "right",
	        i = this;if (f.hasClass("active")) return this.sliding = !1;var j = f[0],
	        k = a.Event("slide.bs.carousel", { relatedTarget: j, direction: h });if (this.$element.trigger(k), !k.isDefaultPrevented()) {
	      if (this.sliding = !0, g && this.pause(), this.$indicators.length) {
	        this.$indicators.find(".active").removeClass("active");var l = a(this.$indicators.children()[this.getItemIndex(f)]);l && l.addClass("active");
	      }var m = a.Event("slid.bs.carousel", { relatedTarget: j, direction: h });return a.support.transition && this.$element.hasClass("slide") ? (f.addClass(b), f[0].offsetWidth, e.addClass(h), f.addClass(h), e.one("bsTransitionEnd", function () {
	        f.removeClass([b, h].join(" ")).addClass("active"), e.removeClass(["active", h].join(" ")), i.sliding = !1, setTimeout(function () {
	          i.$element.trigger(m);
	        }, 0);
	      }).emulateTransitionEnd(c.TRANSITION_DURATION)) : (e.removeClass("active"), f.addClass("active"), this.sliding = !1, this.$element.trigger(m)), g && this.cycle(), this;
	    }
	  };var d = a.fn.carousel;a.fn.carousel = b, a.fn.carousel.Constructor = c, a.fn.carousel.noConflict = function () {
	    return a.fn.carousel = d, this;
	  };var e = function e(c) {
	    var d,
	        e = a(this),
	        f = a(e.attr("data-target") || (d = e.attr("href")) && d.replace(/.*(?=#[^\s]+$)/, ""));if (f.hasClass("carousel")) {
	      var g = a.extend({}, f.data(), e.data()),
	          h = e.attr("data-slide-to");h && (g.interval = !1), b.call(f, g), h && f.data("bs.carousel").to(h), c.preventDefault();
	    }
	  };a(document).on("click.bs.carousel.data-api", "[data-slide]", e).on("click.bs.carousel.data-api", "[data-slide-to]", e), a(window).on("load", function () {
	    a('[data-ride="carousel"]').each(function () {
	      var c = a(this);b.call(c, c.data());
	    });
	  });
	}(jQuery), +function (a) {
	  "use strict";
	  function b(b) {
	    var c,
	        d = b.attr("data-target") || (c = b.attr("href")) && c.replace(/.*(?=#[^\s]+$)/, "");return a(d);
	  }function c(b) {
	    return this.each(function () {
	      var c = a(this),
	          e = c.data("bs.collapse"),
	          f = a.extend({}, d.DEFAULTS, c.data(), "object" == (typeof b === "undefined" ? "undefined" : (0, _typeof3.default)(b)) && b);!e && f.toggle && /show|hide/.test(b) && (f.toggle = !1), e || c.data("bs.collapse", e = new d(this, f)), "string" == typeof b && e[b]();
	    });
	  }var d = function d(b, c) {
	    this.$element = a(b), this.options = a.extend({}, d.DEFAULTS, c), this.$trigger = a('[data-toggle="collapse"][href="#' + b.id + '"],[data-toggle="collapse"][data-target="#' + b.id + '"]'), this.transitioning = null, this.options.parent ? this.$parent = this.getParent() : this.addAriaAndCollapsedClass(this.$element, this.$trigger), this.options.toggle && this.toggle();
	  };d.VERSION = "3.3.6", d.TRANSITION_DURATION = 350, d.DEFAULTS = { toggle: !0 }, d.prototype.dimension = function () {
	    var a = this.$element.hasClass("width");return a ? "width" : "height";
	  }, d.prototype.show = function () {
	    if (!this.transitioning && !this.$element.hasClass("in")) {
	      var b,
	          e = this.$parent && this.$parent.children(".panel").children(".in, .collapsing");if (!(e && e.length && (b = e.data("bs.collapse"), b && b.transitioning))) {
	        var f = a.Event("show.bs.collapse");if (this.$element.trigger(f), !f.isDefaultPrevented()) {
	          e && e.length && (c.call(e, "hide"), b || e.data("bs.collapse", null));var g = this.dimension();this.$element.removeClass("collapse").addClass("collapsing")[g](0).attr("aria-expanded", !0), this.$trigger.removeClass("collapsed").attr("aria-expanded", !0), this.transitioning = 1;var h = function h() {
	            this.$element.removeClass("collapsing").addClass("collapse in")[g](""), this.transitioning = 0, this.$element.trigger("shown.bs.collapse");
	          };if (!a.support.transition) return h.call(this);var i = a.camelCase(["scroll", g].join("-"));this.$element.one("bsTransitionEnd", a.proxy(h, this)).emulateTransitionEnd(d.TRANSITION_DURATION)[g](this.$element[0][i]);
	        }
	      }
	    }
	  }, d.prototype.hide = function () {
	    if (!this.transitioning && this.$element.hasClass("in")) {
	      var b = a.Event("hide.bs.collapse");if (this.$element.trigger(b), !b.isDefaultPrevented()) {
	        var c = this.dimension();this.$element[c](this.$element[c]())[0].offsetHeight, this.$element.addClass("collapsing").removeClass("collapse in").attr("aria-expanded", !1), this.$trigger.addClass("collapsed").attr("aria-expanded", !1), this.transitioning = 1;var e = function e() {
	          this.transitioning = 0, this.$element.removeClass("collapsing").addClass("collapse").trigger("hidden.bs.collapse");
	        };return a.support.transition ? void this.$element[c](0).one("bsTransitionEnd", a.proxy(e, this)).emulateTransitionEnd(d.TRANSITION_DURATION) : e.call(this);
	      }
	    }
	  }, d.prototype.toggle = function () {
	    this[this.$element.hasClass("in") ? "hide" : "show"]();
	  }, d.prototype.getParent = function () {
	    return a(this.options.parent).find('[data-toggle="collapse"][data-parent="' + this.options.parent + '"]').each(a.proxy(function (c, d) {
	      var e = a(d);this.addAriaAndCollapsedClass(b(e), e);
	    }, this)).end();
	  }, d.prototype.addAriaAndCollapsedClass = function (a, b) {
	    var c = a.hasClass("in");a.attr("aria-expanded", c), b.toggleClass("collapsed", !c).attr("aria-expanded", c);
	  };var e = a.fn.collapse;a.fn.collapse = c, a.fn.collapse.Constructor = d, a.fn.collapse.noConflict = function () {
	    return a.fn.collapse = e, this;
	  }, a(document).on("click.bs.collapse.data-api", '[data-toggle="collapse"]', function (d) {
	    var e = a(this);e.attr("data-target") || d.preventDefault();var f = b(e),
	        g = f.data("bs.collapse"),
	        h = g ? "toggle" : e.data();c.call(f, h);
	  });
	}(jQuery), +function (a) {
	  "use strict";
	  function b(b) {
	    var c = b.attr("data-target");c || (c = b.attr("href"), c = c && /#[A-Za-z]/.test(c) && c.replace(/.*(?=#[^\s]*$)/, ""));var d = c && a(c);return d && d.length ? d : b.parent();
	  }function c(c) {
	    c && 3 === c.which || (a(e).remove(), a(f).each(function () {
	      var d = a(this),
	          e = b(d),
	          f = { relatedTarget: this };e.hasClass("open") && (c && "click" == c.type && /input|textarea/i.test(c.target.tagName) && a.contains(e[0], c.target) || (e.trigger(c = a.Event("hide.bs.dropdown", f)), c.isDefaultPrevented() || (d.attr("aria-expanded", "false"), e.removeClass("open").trigger(a.Event("hidden.bs.dropdown", f)))));
	    }));
	  }function d(b) {
	    return this.each(function () {
	      var c = a(this),
	          d = c.data("bs.dropdown");d || c.data("bs.dropdown", d = new g(this)), "string" == typeof b && d[b].call(c);
	    });
	  }var e = ".dropdown-backdrop",
	      f = '[data-toggle="dropdown"]',
	      g = function g(b) {
	    a(b).on("click.bs.dropdown", this.toggle);
	  };g.VERSION = "3.3.6", g.prototype.toggle = function (d) {
	    var e = a(this);if (!e.is(".disabled, :disabled")) {
	      var f = b(e),
	          g = f.hasClass("open");if (c(), !g) {
	        "ontouchstart" in document.documentElement && !f.closest(".navbar-nav").length && a(document.createElement("div")).addClass("dropdown-backdrop").insertAfter(a(this)).on("click", c);var h = { relatedTarget: this };if (f.trigger(d = a.Event("show.bs.dropdown", h)), d.isDefaultPrevented()) return;e.trigger("focus").attr("aria-expanded", "true"), f.toggleClass("open").trigger(a.Event("shown.bs.dropdown", h));
	      }return !1;
	    }
	  }, g.prototype.keydown = function (c) {
	    if (/(38|40|27|32)/.test(c.which) && !/input|textarea/i.test(c.target.tagName)) {
	      var d = a(this);if (c.preventDefault(), c.stopPropagation(), !d.is(".disabled, :disabled")) {
	        var e = b(d),
	            g = e.hasClass("open");if (!g && 27 != c.which || g && 27 == c.which) return 27 == c.which && e.find(f).trigger("focus"), d.trigger("click");var h = " li:not(.disabled):visible a",
	            i = e.find(".dropdown-menu" + h);if (i.length) {
	          var j = i.index(c.target);38 == c.which && j > 0 && j--, 40 == c.which && j < i.length - 1 && j++, ~j || (j = 0), i.eq(j).trigger("focus");
	        }
	      }
	    }
	  };var h = a.fn.dropdown;a.fn.dropdown = d, a.fn.dropdown.Constructor = g, a.fn.dropdown.noConflict = function () {
	    return a.fn.dropdown = h, this;
	  }, a(document).on("click.bs.dropdown.data-api", c).on("click.bs.dropdown.data-api", ".dropdown form", function (a) {
	    a.stopPropagation();
	  }).on("click.bs.dropdown.data-api", f, g.prototype.toggle).on("keydown.bs.dropdown.data-api", f, g.prototype.keydown).on("keydown.bs.dropdown.data-api", ".dropdown-menu", g.prototype.keydown);
	}(jQuery), +function (a) {
	  "use strict";
	  function b(b, d) {
	    return this.each(function () {
	      var e = a(this),
	          f = e.data("bs.modal"),
	          g = a.extend({}, c.DEFAULTS, e.data(), "object" == (typeof b === "undefined" ? "undefined" : (0, _typeof3.default)(b)) && b);f || e.data("bs.modal", f = new c(this, g)), "string" == typeof b ? f[b](d) : g.show && f.show(d);
	    });
	  }var c = function c(b, _c2) {
	    this.options = _c2, this.$body = a(document.body), this.$element = a(b), this.$dialog = this.$element.find(".modal-dialog"), this.$backdrop = null, this.isShown = null, this.originalBodyPad = null, this.scrollbarWidth = 0, this.ignoreBackdropClick = !1, this.options.remote && this.$element.find(".modal-content").load(this.options.remote, a.proxy(function () {
	      this.$element.trigger("loaded.bs.modal");
	    }, this));
	  };c.VERSION = "3.3.6", c.TRANSITION_DURATION = 300, c.BACKDROP_TRANSITION_DURATION = 150, c.DEFAULTS = { backdrop: !0, keyboard: !0, show: !0 }, c.prototype.toggle = function (a) {
	    return this.isShown ? this.hide() : this.show(a);
	  }, c.prototype.show = function (b) {
	    var d = this,
	        e = a.Event("show.bs.modal", { relatedTarget: b });this.$element.trigger(e), this.isShown || e.isDefaultPrevented() || (this.isShown = !0, this.checkScrollbar(), this.setScrollbar(), this.$body.addClass("modal-open"), this.escape(), this.resize(), this.$element.on("click.dismiss.bs.modal", '[data-dismiss="modal"]', a.proxy(this.hide, this)), this.$dialog.on("mousedown.dismiss.bs.modal", function () {
	      d.$element.one("mouseup.dismiss.bs.modal", function (b) {
	        a(b.target).is(d.$element) && (d.ignoreBackdropClick = !0);
	      });
	    }), this.backdrop(function () {
	      var e = a.support.transition && d.$element.hasClass("fade");d.$element.parent().length || d.$element.appendTo(d.$body), d.$element.show().scrollTop(0), d.adjustDialog(), e && d.$element[0].offsetWidth, d.$element.addClass("in"), d.enforceFocus();var f = a.Event("shown.bs.modal", { relatedTarget: b });e ? d.$dialog.one("bsTransitionEnd", function () {
	        d.$element.trigger("focus").trigger(f);
	      }).emulateTransitionEnd(c.TRANSITION_DURATION) : d.$element.trigger("focus").trigger(f);
	    }));
	  }, c.prototype.hide = function (b) {
	    b && b.preventDefault(), b = a.Event("hide.bs.modal"), this.$element.trigger(b), this.isShown && !b.isDefaultPrevented() && (this.isShown = !1, this.escape(), this.resize(), a(document).off("focusin.bs.modal"), this.$element.removeClass("in").off("click.dismiss.bs.modal").off("mouseup.dismiss.bs.modal"), this.$dialog.off("mousedown.dismiss.bs.modal"), a.support.transition && this.$element.hasClass("fade") ? this.$element.one("bsTransitionEnd", a.proxy(this.hideModal, this)).emulateTransitionEnd(c.TRANSITION_DURATION) : this.hideModal());
	  }, c.prototype.enforceFocus = function () {
	    a(document).off("focusin.bs.modal").on("focusin.bs.modal", a.proxy(function (a) {
	      this.$element[0] === a.target || this.$element.has(a.target).length || this.$element.trigger("focus");
	    }, this));
	  }, c.prototype.escape = function () {
	    this.isShown && this.options.keyboard ? this.$element.on("keydown.dismiss.bs.modal", a.proxy(function (a) {
	      27 == a.which && this.hide();
	    }, this)) : this.isShown || this.$element.off("keydown.dismiss.bs.modal");
	  }, c.prototype.resize = function () {
	    this.isShown ? a(window).on("resize.bs.modal", a.proxy(this.handleUpdate, this)) : a(window).off("resize.bs.modal");
	  }, c.prototype.hideModal = function () {
	    var a = this;this.$element.hide(), this.backdrop(function () {
	      a.$body.removeClass("modal-open"), a.resetAdjustments(), a.resetScrollbar(), a.$element.trigger("hidden.bs.modal");
	    });
	  }, c.prototype.removeBackdrop = function () {
	    this.$backdrop && this.$backdrop.remove(), this.$backdrop = null;
	  }, c.prototype.backdrop = function (b) {
	    var d = this,
	        e = this.$element.hasClass("fade") ? "fade" : "";if (this.isShown && this.options.backdrop) {
	      var f = a.support.transition && e;if (this.$backdrop = a(document.createElement("div")).addClass("modal-backdrop " + e).appendTo(this.$body), this.$element.on("click.dismiss.bs.modal", a.proxy(function (a) {
	        return this.ignoreBackdropClick ? void (this.ignoreBackdropClick = !1) : void (a.target === a.currentTarget && ("static" == this.options.backdrop ? this.$element[0].focus() : this.hide()));
	      }, this)), f && this.$backdrop[0].offsetWidth, this.$backdrop.addClass("in"), !b) return;f ? this.$backdrop.one("bsTransitionEnd", b).emulateTransitionEnd(c.BACKDROP_TRANSITION_DURATION) : b();
	    } else if (!this.isShown && this.$backdrop) {
	      this.$backdrop.removeClass("in");var g = function g() {
	        d.removeBackdrop(), b && b();
	      };a.support.transition && this.$element.hasClass("fade") ? this.$backdrop.one("bsTransitionEnd", g).emulateTransitionEnd(c.BACKDROP_TRANSITION_DURATION) : g();
	    } else b && b();
	  }, c.prototype.handleUpdate = function () {
	    this.adjustDialog();
	  }, c.prototype.adjustDialog = function () {
	    var a = this.$element[0].scrollHeight > document.documentElement.clientHeight;this.$element.css({ paddingLeft: !this.bodyIsOverflowing && a ? this.scrollbarWidth : "", paddingRight: this.bodyIsOverflowing && !a ? this.scrollbarWidth : "" });
	  }, c.prototype.resetAdjustments = function () {
	    this.$element.css({ paddingLeft: "", paddingRight: "" });
	  }, c.prototype.checkScrollbar = function () {
	    var a = window.innerWidth;if (!a) {
	      var b = document.documentElement.getBoundingClientRect();a = b.right - Math.abs(b.left);
	    }this.bodyIsOverflowing = document.body.clientWidth < a, this.scrollbarWidth = this.measureScrollbar();
	  }, c.prototype.setScrollbar = function () {
	    var a = parseInt(this.$body.css("padding-right") || 0, 10);this.originalBodyPad = document.body.style.paddingRight || "", this.bodyIsOverflowing && this.$body.css("padding-right", a + this.scrollbarWidth);
	  }, c.prototype.resetScrollbar = function () {
	    this.$body.css("padding-right", this.originalBodyPad);
	  }, c.prototype.measureScrollbar = function () {
	    var a = document.createElement("div");a.className = "modal-scrollbar-measure", this.$body.append(a);var b = a.offsetWidth - a.clientWidth;return this.$body[0].removeChild(a), b;
	  };var d = a.fn.modal;a.fn.modal = b, a.fn.modal.Constructor = c, a.fn.modal.noConflict = function () {
	    return a.fn.modal = d, this;
	  }, a(document).on("click.bs.modal.data-api", '[data-toggle="modal"]', function (c) {
	    var d = a(this),
	        e = d.attr("href"),
	        f = a(d.attr("data-target") || e && e.replace(/.*(?=#[^\s]+$)/, "")),
	        g = f.data("bs.modal") ? "toggle" : a.extend({ remote: !/#/.test(e) && e }, f.data(), d.data());d.is("a") && c.preventDefault(), f.one("show.bs.modal", function (a) {
	      a.isDefaultPrevented() || f.one("hidden.bs.modal", function () {
	        d.is(":visible") && d.trigger("focus");
	      });
	    }), b.call(f, g, this);
	  });
	}(jQuery), +function (a) {
	  "use strict";
	  function b(b) {
	    return this.each(function () {
	      var d = a(this),
	          e = d.data("bs.tooltip"),
	          f = "object" == (typeof b === "undefined" ? "undefined" : (0, _typeof3.default)(b)) && b;(e || !/destroy|hide/.test(b)) && (e || d.data("bs.tooltip", e = new c(this, f)), "string" == typeof b && e[b]());
	    });
	  }var c = function c(a, b) {
	    this.type = null, this.options = null, this.enabled = null, this.timeout = null, this.hoverState = null, this.$element = null, this.inState = null, this.init("tooltip", a, b);
	  };c.VERSION = "3.3.6", c.TRANSITION_DURATION = 150, c.DEFAULTS = { animation: !0, placement: "top", selector: !1, template: '<div class="tooltip" role="tooltip"><div class="tooltip-arrow"></div><div class="tooltip-inner"></div></div>', trigger: "hover focus", title: "", delay: 0, html: !1, container: !1, viewport: { selector: "body", padding: 0 } }, c.prototype.init = function (b, c, d) {
	    if (this.enabled = !0, this.type = b, this.$element = a(c), this.options = this.getOptions(d), this.$viewport = this.options.viewport && a(a.isFunction(this.options.viewport) ? this.options.viewport.call(this, this.$element) : this.options.viewport.selector || this.options.viewport), this.inState = { click: !1, hover: !1, focus: !1 }, this.$element[0] instanceof document.constructor && !this.options.selector) throw new Error("`selector` option must be specified when initializing " + this.type + " on the window.document object!");for (var e = this.options.trigger.split(" "), f = e.length; f--;) {
	      var g = e[f];if ("click" == g) this.$element.on("click." + this.type, this.options.selector, a.proxy(this.toggle, this));else if ("manual" != g) {
	        var h = "hover" == g ? "mouseenter" : "focusin",
	            i = "hover" == g ? "mouseleave" : "focusout";this.$element.on(h + "." + this.type, this.options.selector, a.proxy(this.enter, this)), this.$element.on(i + "." + this.type, this.options.selector, a.proxy(this.leave, this));
	      }
	    }this.options.selector ? this._options = a.extend({}, this.options, { trigger: "manual", selector: "" }) : this.fixTitle();
	  }, c.prototype.getDefaults = function () {
	    return c.DEFAULTS;
	  }, c.prototype.getOptions = function (b) {
	    return b = a.extend({}, this.getDefaults(), this.$element.data(), b), b.delay && "number" == typeof b.delay && (b.delay = { show: b.delay, hide: b.delay }), b;
	  }, c.prototype.getDelegateOptions = function () {
	    var b = {},
	        c = this.getDefaults();return this._options && a.each(this._options, function (a, d) {
	      c[a] != d && (b[a] = d);
	    }), b;
	  }, c.prototype.enter = function (b) {
	    var c = b instanceof this.constructor ? b : a(b.currentTarget).data("bs." + this.type);return c || (c = new this.constructor(b.currentTarget, this.getDelegateOptions()), a(b.currentTarget).data("bs." + this.type, c)), b instanceof a.Event && (c.inState["focusin" == b.type ? "focus" : "hover"] = !0), c.tip().hasClass("in") || "in" == c.hoverState ? void (c.hoverState = "in") : (clearTimeout(c.timeout), c.hoverState = "in", c.options.delay && c.options.delay.show ? void (c.timeout = setTimeout(function () {
	      "in" == c.hoverState && c.show();
	    }, c.options.delay.show)) : c.show());
	  }, c.prototype.isInStateTrue = function () {
	    for (var a in this.inState) {
	      if (this.inState[a]) return !0;
	    }return !1;
	  }, c.prototype.leave = function (b) {
	    var c = b instanceof this.constructor ? b : a(b.currentTarget).data("bs." + this.type);return c || (c = new this.constructor(b.currentTarget, this.getDelegateOptions()), a(b.currentTarget).data("bs." + this.type, c)), b instanceof a.Event && (c.inState["focusout" == b.type ? "focus" : "hover"] = !1), c.isInStateTrue() ? void 0 : (clearTimeout(c.timeout), c.hoverState = "out", c.options.delay && c.options.delay.hide ? void (c.timeout = setTimeout(function () {
	      "out" == c.hoverState && c.hide();
	    }, c.options.delay.hide)) : c.hide());
	  }, c.prototype.show = function () {
	    var b = a.Event("show.bs." + this.type);if (this.hasContent() && this.enabled) {
	      this.$element.trigger(b);var d = a.contains(this.$element[0].ownerDocument.documentElement, this.$element[0]);if (b.isDefaultPrevented() || !d) return;var e = this,
	          f = this.tip(),
	          g = this.getUID(this.type);this.setContent(), f.attr("id", g), this.$element.attr("aria-describedby", g), this.options.animation && f.addClass("fade");var h = "function" == typeof this.options.placement ? this.options.placement.call(this, f[0], this.$element[0]) : this.options.placement,
	          i = /\s?auto?\s?/i,
	          j = i.test(h);j && (h = h.replace(i, "") || "top"), f.detach().css({ top: 0, left: 0, display: "block" }).addClass(h).data("bs." + this.type, this), this.options.container ? f.appendTo(this.options.container) : f.insertAfter(this.$element), this.$element.trigger("inserted.bs." + this.type);var k = this.getPosition(),
	          l = f[0].offsetWidth,
	          m = f[0].offsetHeight;if (j) {
	        var n = h,
	            o = this.getPosition(this.$viewport);h = "bottom" == h && k.bottom + m > o.bottom ? "top" : "top" == h && k.top - m < o.top ? "bottom" : "right" == h && k.right + l > o.width ? "left" : "left" == h && k.left - l < o.left ? "right" : h, f.removeClass(n).addClass(h);
	      }var p = this.getCalculatedOffset(h, k, l, m);this.applyPlacement(p, h);var q = function q() {
	        var a = e.hoverState;e.$element.trigger("shown.bs." + e.type), e.hoverState = null, "out" == a && e.leave(e);
	      };a.support.transition && this.$tip.hasClass("fade") ? f.one("bsTransitionEnd", q).emulateTransitionEnd(c.TRANSITION_DURATION) : q();
	    }
	  }, c.prototype.applyPlacement = function (b, c) {
	    var d = this.tip(),
	        e = d[0].offsetWidth,
	        f = d[0].offsetHeight,
	        g = parseInt(d.css("margin-top"), 10),
	        h = parseInt(d.css("margin-left"), 10);isNaN(g) && (g = 0), isNaN(h) && (h = 0), b.top += g, b.left += h, a.offset.setOffset(d[0], a.extend({ using: function using(a) {
	        d.css({ top: Math.round(a.top), left: Math.round(a.left) });
	      } }, b), 0), d.addClass("in");var i = d[0].offsetWidth,
	        j = d[0].offsetHeight;"top" == c && j != f && (b.top = b.top + f - j);var k = this.getViewportAdjustedDelta(c, b, i, j);k.left ? b.left += k.left : b.top += k.top;var l = /top|bottom/.test(c),
	        m = l ? 2 * k.left - e + i : 2 * k.top - f + j,
	        n = l ? "offsetWidth" : "offsetHeight";d.offset(b), this.replaceArrow(m, d[0][n], l);
	  }, c.prototype.replaceArrow = function (a, b, c) {
	    this.arrow().css(c ? "left" : "top", 50 * (1 - a / b) + "%").css(c ? "top" : "left", "");
	  }, c.prototype.setContent = function () {
	    var a = this.tip(),
	        b = this.getTitle();a.find(".tooltip-inner")[this.options.html ? "html" : "text"](b), a.removeClass("fade in top bottom left right");
	  }, c.prototype.hide = function (b) {
	    function d() {
	      "in" != e.hoverState && f.detach(), e.$element.removeAttr("aria-describedby").trigger("hidden.bs." + e.type), b && b();
	    }var e = this,
	        f = a(this.$tip),
	        g = a.Event("hide.bs." + this.type);return this.$element.trigger(g), g.isDefaultPrevented() ? void 0 : (f.removeClass("in"), a.support.transition && f.hasClass("fade") ? f.one("bsTransitionEnd", d).emulateTransitionEnd(c.TRANSITION_DURATION) : d(), this.hoverState = null, this);
	  }, c.prototype.fixTitle = function () {
	    var a = this.$element;(a.attr("title") || "string" != typeof a.attr("data-original-title")) && a.attr("data-original-title", a.attr("title") || "").attr("title", "");
	  }, c.prototype.hasContent = function () {
	    return this.getTitle();
	  }, c.prototype.getPosition = function (b) {
	    b = b || this.$element;var c = b[0],
	        d = "BODY" == c.tagName,
	        e = c.getBoundingClientRect();null == e.width && (e = a.extend({}, e, { width: e.right - e.left, height: e.bottom - e.top }));var f = d ? { top: 0, left: 0 } : b.offset(),
	        g = { scroll: d ? document.documentElement.scrollTop || document.body.scrollTop : b.scrollTop() },
	        h = d ? { width: a(window).width(), height: a(window).height() } : null;return a.extend({}, e, g, h, f);
	  }, c.prototype.getCalculatedOffset = function (a, b, c, d) {
	    return "bottom" == a ? { top: b.top + b.height, left: b.left + b.width / 2 - c / 2 } : "top" == a ? { top: b.top - d, left: b.left + b.width / 2 - c / 2 } : "left" == a ? { top: b.top + b.height / 2 - d / 2, left: b.left - c } : { top: b.top + b.height / 2 - d / 2, left: b.left + b.width };
	  }, c.prototype.getViewportAdjustedDelta = function (a, b, c, d) {
	    var e = { top: 0, left: 0 };if (!this.$viewport) return e;var f = this.options.viewport && this.options.viewport.padding || 0,
	        g = this.getPosition(this.$viewport);if (/right|left/.test(a)) {
	      var h = b.top - f - g.scroll,
	          i = b.top + f - g.scroll + d;h < g.top ? e.top = g.top - h : i > g.top + g.height && (e.top = g.top + g.height - i);
	    } else {
	      var j = b.left - f,
	          k = b.left + f + c;j < g.left ? e.left = g.left - j : k > g.right && (e.left = g.left + g.width - k);
	    }return e;
	  }, c.prototype.getTitle = function () {
	    var a,
	        b = this.$element,
	        c = this.options;return a = b.attr("data-original-title") || ("function" == typeof c.title ? c.title.call(b[0]) : c.title);
	  }, c.prototype.getUID = function (a) {
	    do {
	      a += ~~(1e6 * Math.random());
	    } while (document.getElementById(a));return a;
	  }, c.prototype.tip = function () {
	    if (!this.$tip && (this.$tip = a(this.options.template), 1 != this.$tip.length)) throw new Error(this.type + " `template` option must consist of exactly 1 top-level element!");return this.$tip;
	  }, c.prototype.arrow = function () {
	    return this.$arrow = this.$arrow || this.tip().find(".tooltip-arrow");
	  }, c.prototype.enable = function () {
	    this.enabled = !0;
	  }, c.prototype.disable = function () {
	    this.enabled = !1;
	  }, c.prototype.toggleEnabled = function () {
	    this.enabled = !this.enabled;
	  }, c.prototype.toggle = function (b) {
	    var c = this;b && (c = a(b.currentTarget).data("bs." + this.type), c || (c = new this.constructor(b.currentTarget, this.getDelegateOptions()), a(b.currentTarget).data("bs." + this.type, c))), b ? (c.inState.click = !c.inState.click, c.isInStateTrue() ? c.enter(c) : c.leave(c)) : c.tip().hasClass("in") ? c.leave(c) : c.enter(c);
	  }, c.prototype.destroy = function () {
	    var a = this;clearTimeout(this.timeout), this.hide(function () {
	      a.$element.off("." + a.type).removeData("bs." + a.type), a.$tip && a.$tip.detach(), a.$tip = null, a.$arrow = null, a.$viewport = null;
	    });
	  };var d = a.fn.tooltip;a.fn.tooltip = b, a.fn.tooltip.Constructor = c, a.fn.tooltip.noConflict = function () {
	    return a.fn.tooltip = d, this;
	  };
	}(jQuery), +function (a) {
	  "use strict";
	  function b(b) {
	    return this.each(function () {
	      var d = a(this),
	          e = d.data("bs.popover"),
	          f = "object" == (typeof b === "undefined" ? "undefined" : (0, _typeof3.default)(b)) && b;(e || !/destroy|hide/.test(b)) && (e || d.data("bs.popover", e = new c(this, f)), "string" == typeof b && e[b]());
	    });
	  }var c = function c(a, b) {
	    this.init("popover", a, b);
	  };if (!a.fn.tooltip) throw new Error("Popover requires tooltip.js");c.VERSION = "3.3.6", c.DEFAULTS = a.extend({}, a.fn.tooltip.Constructor.DEFAULTS, { placement: "right", trigger: "click", content: "", template: '<div class="popover" role="tooltip"><div class="arrow"></div><h3 class="popover-title"></h3><div class="popover-content"></div></div>' }), c.prototype = a.extend({}, a.fn.tooltip.Constructor.prototype), c.prototype.constructor = c, c.prototype.getDefaults = function () {
	    return c.DEFAULTS;
	  }, c.prototype.setContent = function () {
	    var a = this.tip(),
	        b = this.getTitle(),
	        c = this.getContent();a.find(".popover-title")[this.options.html ? "html" : "text"](b), a.find(".popover-content").children().detach().end()[this.options.html ? "string" == typeof c ? "html" : "append" : "text"](c), a.removeClass("fade top bottom left right in"), a.find(".popover-title").html() || a.find(".popover-title").hide();
	  }, c.prototype.hasContent = function () {
	    return this.getTitle() || this.getContent();
	  }, c.prototype.getContent = function () {
	    var a = this.$element,
	        b = this.options;return a.attr("data-content") || ("function" == typeof b.content ? b.content.call(a[0]) : b.content);
	  }, c.prototype.arrow = function () {
	    return this.$arrow = this.$arrow || this.tip().find(".arrow");
	  };var d = a.fn.popover;a.fn.popover = b, a.fn.popover.Constructor = c, a.fn.popover.noConflict = function () {
	    return a.fn.popover = d, this;
	  };
	}(jQuery), +function (a) {
	  "use strict";
	  function b(c, d) {
	    this.$body = a(document.body), this.$scrollElement = a(a(c).is(document.body) ? window : c), this.options = a.extend({}, b.DEFAULTS, d), this.selector = (this.options.target || "") + " .nav li > a", this.offsets = [], this.targets = [], this.activeTarget = null, this.scrollHeight = 0, this.$scrollElement.on("scroll.bs.scrollspy", a.proxy(this.process, this)), this.refresh(), this.process();
	  }function c(c) {
	    return this.each(function () {
	      var d = a(this),
	          e = d.data("bs.scrollspy"),
	          f = "object" == (typeof c === "undefined" ? "undefined" : (0, _typeof3.default)(c)) && c;e || d.data("bs.scrollspy", e = new b(this, f)), "string" == typeof c && e[c]();
	    });
	  }b.VERSION = "3.3.6", b.DEFAULTS = { offset: 10 }, b.prototype.getScrollHeight = function () {
	    return this.$scrollElement[0].scrollHeight || Math.max(this.$body[0].scrollHeight, document.documentElement.scrollHeight);
	  }, b.prototype.refresh = function () {
	    var b = this,
	        c = "offset",
	        d = 0;this.offsets = [], this.targets = [], this.scrollHeight = this.getScrollHeight(), a.isWindow(this.$scrollElement[0]) || (c = "position", d = this.$scrollElement.scrollTop()), this.$body.find(this.selector).map(function () {
	      var b = a(this),
	          e = b.data("target") || b.attr("href"),
	          f = /^#./.test(e) && a(e);return f && f.length && f.is(":visible") && [[f[c]().top + d, e]] || null;
	    }).sort(function (a, b) {
	      return a[0] - b[0];
	    }).each(function () {
	      b.offsets.push(this[0]), b.targets.push(this[1]);
	    });
	  }, b.prototype.process = function () {
	    var a,
	        b = this.$scrollElement.scrollTop() + this.options.offset,
	        c = this.getScrollHeight(),
	        d = this.options.offset + c - this.$scrollElement.height(),
	        e = this.offsets,
	        f = this.targets,
	        g = this.activeTarget;if (this.scrollHeight != c && this.refresh(), b >= d) return g != (a = f[f.length - 1]) && this.activate(a);if (g && b < e[0]) return this.activeTarget = null, this.clear();for (a = e.length; a--;) {
	      g != f[a] && b >= e[a] && (void 0 === e[a + 1] || b < e[a + 1]) && this.activate(f[a]);
	    }
	  }, b.prototype.activate = function (b) {
	    this.activeTarget = b, this.clear();var c = this.selector + '[data-target="' + b + '"],' + this.selector + '[href="' + b + '"]',
	        d = a(c).parents("li").addClass("active");
	    d.parent(".dropdown-menu").length && (d = d.closest("li.dropdown").addClass("active")), d.trigger("activate.bs.scrollspy");
	  }, b.prototype.clear = function () {
	    a(this.selector).parentsUntil(this.options.target, ".active").removeClass("active");
	  };var d = a.fn.scrollspy;a.fn.scrollspy = c, a.fn.scrollspy.Constructor = b, a.fn.scrollspy.noConflict = function () {
	    return a.fn.scrollspy = d, this;
	  }, a(window).on("load.bs.scrollspy.data-api", function () {
	    a('[data-spy="scroll"]').each(function () {
	      var b = a(this);c.call(b, b.data());
	    });
	  });
	}(jQuery), +function (a) {
	  "use strict";
	  function b(b) {
	    return this.each(function () {
	      var d = a(this),
	          e = d.data("bs.tab");e || d.data("bs.tab", e = new c(this)), "string" == typeof b && e[b]();
	    });
	  }var c = function c(b) {
	    this.element = a(b);
	  };c.VERSION = "3.3.6", c.TRANSITION_DURATION = 150, c.prototype.show = function () {
	    var b = this.element,
	        c = b.closest("ul:not(.dropdown-menu)"),
	        d = b.data("target");if (d || (d = b.attr("href"), d = d && d.replace(/.*(?=#[^\s]*$)/, "")), !b.parent("li").hasClass("active")) {
	      var e = c.find(".active:last a"),
	          f = a.Event("hide.bs.tab", { relatedTarget: b[0] }),
	          g = a.Event("show.bs.tab", { relatedTarget: e[0] });if (e.trigger(f), b.trigger(g), !g.isDefaultPrevented() && !f.isDefaultPrevented()) {
	        var h = a(d);this.activate(b.closest("li"), c), this.activate(h, h.parent(), function () {
	          e.trigger({ type: "hidden.bs.tab", relatedTarget: b[0] }), b.trigger({ type: "shown.bs.tab", relatedTarget: e[0] });
	        });
	      }
	    }
	  }, c.prototype.activate = function (b, d, e) {
	    function f() {
	      g.removeClass("active").find("> .dropdown-menu > .active").removeClass("active").end().find('[data-toggle="tab"]').attr("aria-expanded", !1), b.addClass("active").find('[data-toggle="tab"]').attr("aria-expanded", !0), h ? (b[0].offsetWidth, b.addClass("in")) : b.removeClass("fade"), b.parent(".dropdown-menu").length && b.closest("li.dropdown").addClass("active").end().find('[data-toggle="tab"]').attr("aria-expanded", !0), e && e();
	    }var g = d.find("> .active"),
	        h = e && a.support.transition && (g.length && g.hasClass("fade") || !!d.find("> .fade").length);g.length && h ? g.one("bsTransitionEnd", f).emulateTransitionEnd(c.TRANSITION_DURATION) : f(), g.removeClass("in");
	  };var d = a.fn.tab;a.fn.tab = b, a.fn.tab.Constructor = c, a.fn.tab.noConflict = function () {
	    return a.fn.tab = d, this;
	  };var e = function e(c) {
	    c.preventDefault(), b.call(a(this), "show");
	  };a(document).on("click.bs.tab.data-api", '[data-toggle="tab"]', e).on("click.bs.tab.data-api", '[data-toggle="pill"]', e);
	}(jQuery), +function (a) {
	  "use strict";
	  function b(b) {
	    return this.each(function () {
	      var d = a(this),
	          e = d.data("bs.affix"),
	          f = "object" == (typeof b === "undefined" ? "undefined" : (0, _typeof3.default)(b)) && b;e || d.data("bs.affix", e = new c(this, f)), "string" == typeof b && e[b]();
	    });
	  }var c = function c(b, d) {
	    this.options = a.extend({}, c.DEFAULTS, d), this.$target = a(this.options.target).on("scroll.bs.affix.data-api", a.proxy(this.checkPosition, this)).on("click.bs.affix.data-api", a.proxy(this.checkPositionWithEventLoop, this)), this.$element = a(b), this.affixed = null, this.unpin = null, this.pinnedOffset = null, this.checkPosition();
	  };c.VERSION = "3.3.6", c.RESET = "affix affix-top affix-bottom", c.DEFAULTS = { offset: 0, target: window }, c.prototype.getState = function (a, b, c, d) {
	    var e = this.$target.scrollTop(),
	        f = this.$element.offset(),
	        g = this.$target.height();if (null != c && "top" == this.affixed) return c > e ? "top" : !1;if ("bottom" == this.affixed) return null != c ? e + this.unpin <= f.top ? !1 : "bottom" : a - d >= e + g ? !1 : "bottom";var h = null == this.affixed,
	        i = h ? e : f.top,
	        j = h ? g : b;return null != c && c >= e ? "top" : null != d && i + j >= a - d ? "bottom" : !1;
	  }, c.prototype.getPinnedOffset = function () {
	    if (this.pinnedOffset) return this.pinnedOffset;this.$element.removeClass(c.RESET).addClass("affix");var a = this.$target.scrollTop(),
	        b = this.$element.offset();return this.pinnedOffset = b.top - a;
	  }, c.prototype.checkPositionWithEventLoop = function () {
	    setTimeout(a.proxy(this.checkPosition, this), 1);
	  }, c.prototype.checkPosition = function () {
	    if (this.$element.is(":visible")) {
	      var b = this.$element.height(),
	          d = this.options.offset,
	          e = d.top,
	          f = d.bottom,
	          g = Math.max(a(document).height(), a(document.body).height());"object" != (typeof d === "undefined" ? "undefined" : (0, _typeof3.default)(d)) && (f = e = d), "function" == typeof e && (e = d.top(this.$element)), "function" == typeof f && (f = d.bottom(this.$element));var h = this.getState(g, b, e, f);if (this.affixed != h) {
	        null != this.unpin && this.$element.css("top", "");var i = "affix" + (h ? "-" + h : ""),
	            j = a.Event(i + ".bs.affix");if (this.$element.trigger(j), j.isDefaultPrevented()) return;this.affixed = h, this.unpin = "bottom" == h ? this.getPinnedOffset() : null, this.$element.removeClass(c.RESET).addClass(i).trigger(i.replace("affix", "affixed") + ".bs.affix");
	      }"bottom" == h && this.$element.offset({ top: g - b - f });
	    }
	  };var d = a.fn.affix;a.fn.affix = b, a.fn.affix.Constructor = c, a.fn.affix.noConflict = function () {
	    return a.fn.affix = d, this;
	  }, a(window).on("load", function () {
	    a('[data-spy="affix"]').each(function () {
	      var c = a(this),
	          d = c.data();d.offset = d.offset || {}, null != d.offsetBottom && (d.offset.bottom = d.offsetBottom), null != d.offsetTop && (d.offset.top = d.offsetTop), b.call(c, d);
	    });
	  });
	}(jQuery);
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ },
/* 102 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	__webpack_require__(103);
	
	ko.validation.rules.pattern.message = 'Invalid.';
	
	ko.validation.init({
		registerExtenders: true,
		messagesOnModified: true,
		decorateInputElement: true,
		errorMessageClass: 'custom-input__validation-message',
		errorElementClass: 'not-valid',
		insertMessages: false,
		parseInputAttributes: true,
		messageTemplate: null,
		grouping: {
			deep: true,
			live: true,
			observable: true
		}
	}, true);
	
	ko.validation.rules['nullableInt'] = {
		validator: function validator(val, validate) {
			return val === null || val === "" || validate && /^-?\d*$/.test(val.toString());
		},
		message: 'Must be empty or an integer value'
	};
	
	ko.validation.rules['nullableDecimal'] = {
		validator: function validator(val, validate) {
			return val === null || val === "" || validate && /^-?\d*(?:\.\d*)?$/.test(val.toString());
		},
		message: 'Must be empty or a decimal value'
	};
	
	ko.validation.registerExtenders();

/***/ },
/* 103 */
/***/ function(module, exports, __webpack_require__) {

	/*=============================================================================
		Author:			Eric M. Barnard - @ericmbarnard								
		License:		MIT (http://opensource.org/licenses/mit-license.php)		
																					
		Description:	Validation Library for KnockoutJS							
		Version:		2.0.3											
	===============================================================================
	*/
	/*globals require: false, exports: false, define: false, ko: false */
	
	(function (factory) {
		// Module systems magic dance.
	
		if (true) {
			// CommonJS or Node: hard-coded dependency on "knockout"
			factory(__webpack_require__(94), exports);
		} else if (typeof define === "function" && define["amd"]) {
			// AMD anonymous module with hard-coded dependency on "knockout"
			define(["knockout", "exports"], factory);
		} else {
			// <script> tag: use the global `ko` object, attaching a `mapping` property
			factory(ko, ko.validation = {});
		}
	}(function ( ko, exports ) {
	
		if (typeof (ko) === 'undefined') {
			throw new Error('Knockout is required, please ensure it is loaded before loading this validation plug-in');
		}
	
		// create our namespace object
		ko.validation = exports;
	
		var kv = ko.validation,
			koUtils = ko.utils,
			unwrap = koUtils.unwrapObservable,
			forEach = koUtils.arrayForEach,
			extend = koUtils.extend;
	;/*global ko: false*/
	
	var defaults = {
		registerExtenders: true,
		messagesOnModified: true,
		errorsAsTitle: true,            // enables/disables showing of errors as title attribute of the target element.
		errorsAsTitleOnModified: false, // shows the error when hovering the input field (decorateElement must be true)
		messageTemplate: null,
		insertMessages: true,           // automatically inserts validation messages as <span></span>
		parseInputAttributes: false,    // parses the HTML5 validation attribute from a form element and adds that to the object
		writeInputAttributes: false,    // adds HTML5 input validation attributes to form elements that ko observable's are bound to
		decorateInputElement: false,         // false to keep backward compatibility
		decorateElementOnModified: true,// true to keep backward compatibility
		errorClass: null,               // single class for error message and element
		errorElementClass: 'validationElement',  // class to decorate error element
		errorMessageClass: 'validationMessage',  // class to decorate error message
		allowHtmlMessages: false,		// allows HTML in validation messages
		grouping: {
			deep: false,        //by default grouping is shallow
			observable: true,   //and using observables
			live: false		    //react to changes to observableArrays if observable === true
		},
		validate: {
			// throttle: 10
		}
	};
	
	// make a copy  so we can use 'reset' later
	var configuration = extend({}, defaults);
	
	configuration.html5Attributes = ['required', 'pattern', 'min', 'max', 'step'];
	configuration.html5InputTypes = ['email', 'number', 'date'];
	
	configuration.reset = function () {
		extend(configuration, defaults);
	};
	
	kv.configuration = configuration;
	;kv.utils = (function () {
		var seedId = new Date().getTime();
	
		var domData = {}; //hash of data objects that we reference from dom elements
		var domDataKey = '__ko_validation__';
	
		return {
			isArray: function (o) {
				return o.isArray || Object.prototype.toString.call(o) === '[object Array]';
			},
			isObject: function (o) {
				return o !== null && typeof o === 'object';
			},
			isNumber: function(o) {
				return !isNaN(o);	
			},
			isObservableArray: function(instance) {
				return !!instance &&
						typeof instance["remove"] === "function" &&
						typeof instance["removeAll"] === "function" &&
						typeof instance["destroy"] === "function" &&
						typeof instance["destroyAll"] === "function" &&
						typeof instance["indexOf"] === "function" &&
						typeof instance["replace"] === "function";
			},
			values: function (o) {
				var r = [];
				for (var i in o) {
					if (o.hasOwnProperty(i)) {
						r.push(o[i]);
					}
				}
				return r;
			},
			getValue: function (o) {
				return (typeof o === 'function' ? o() : o);
			},
			hasAttribute: function (node, attr) {
				return node.getAttribute(attr) !== null;
			},
			getAttribute: function (element, attr) {
				return element.getAttribute(attr);
			},
			setAttribute: function (element, attr, value) {
				return element.setAttribute(attr, value);
			},
			isValidatable: function (o) {
				return !!(o && o.rules && o.isValid && o.isModified);
			},
			insertAfter: function (node, newNode) {
				node.parentNode.insertBefore(newNode, node.nextSibling);
			},
			newId: function () {
				return seedId += 1;
			},
			getConfigOptions: function (element) {
				var options = kv.utils.contextFor(element);
	
				return options || kv.configuration;
			},
			setDomData: function (node, data) {
				var key = node[domDataKey];
	
				if (!key) {
					node[domDataKey] = key = kv.utils.newId();
				}
	
				domData[key] = data;
			},
			getDomData: function (node) {
				var key = node[domDataKey];
	
				if (!key) {
					return undefined;
				}
	
				return domData[key];
			},
			contextFor: function (node) {
				switch (node.nodeType) {
					case 1:
					case 8:
						var context = kv.utils.getDomData(node);
						if (context) { return context; }
						if (node.parentNode) { return kv.utils.contextFor(node.parentNode); }
						break;
				}
				return undefined;
			},
			isEmptyVal: function (val) {
				if (val === undefined) {
					return true;
				}
				if (val === null) {
					return true;
				}
				if (val === "") {
					return true;
				}
			},
			getOriginalElementTitle: function (element) {
				var savedOriginalTitle = kv.utils.getAttribute(element, 'data-orig-title'),
					currentTitle = element.title,
					hasSavedOriginalTitle = kv.utils.hasAttribute(element, 'data-orig-title');
	
				return hasSavedOriginalTitle ?
					savedOriginalTitle : currentTitle;
			},
			async: function (expr) {
				if (window.setImmediate) { window.setImmediate(expr); }
				else { window.setTimeout(expr, 0); }
			},
			forEach: function (object, callback) {
				if (kv.utils.isArray(object)) {
					return forEach(object, callback);
				}
				for (var prop in object) {
					if (object.hasOwnProperty(prop)) {
						callback(object[prop], prop);
					}
				}
			}
		};
	}());;var api = (function () {
	
		var isInitialized = 0,
			configuration = kv.configuration,
			utils = kv.utils;
	
		function cleanUpSubscriptions(context) {
			forEach(context.subscriptions, function (subscription) {
				subscription.dispose();
			});
			context.subscriptions = [];
		}
	
		function dispose(context) {
			if (context.options.deep) {
				forEach(context.flagged, function (obj) {
					delete obj.__kv_traversed;
				});
				context.flagged.length = 0;
			}
	
			if (!context.options.live) {
				cleanUpSubscriptions(context);
			}
		}
	
		function runTraversal(obj, context) {
			context.validatables = [];
			cleanUpSubscriptions(context);
			traverseGraph(obj, context);
			dispose(context);
		}
	
		function traverseGraph(obj, context, level) {
			var objValues = [],
				val = obj.peek ? obj.peek() : obj;
	
			if (obj.__kv_traversed === true) {
				return;
			}
	
			if (context.options.deep) {
				obj.__kv_traversed = true;
				context.flagged.push(obj);
			}
	
			//default level value depends on deep option.
			level = (level !== undefined ? level : context.options.deep ? 1 : -1);
	
			// if object is observable then add it to the list
			if (ko.isObservable(obj)) {
				// ensure it's validatable but don't extend validatedObservable because it
				// would overwrite isValid property.
				if (!obj.errors && !utils.isValidatable(obj)) {
					obj.extend({ validatable: true });
				}
				context.validatables.push(obj);
	
				if (context.options.live && utils.isObservableArray(obj)) {
					context.subscriptions.push(obj.subscribe(function () {
						context.graphMonitor.valueHasMutated();
					}));
				}
			}
	
			//get list of values either from array or object but ignore non-objects
			// and destroyed objects
			if (val && !val._destroy) {
				if (utils.isArray(val)) {
					objValues = val;
				}
				else if (utils.isObject(val)) {
					objValues = utils.values(val);
				}
			}
	
			//process recursively if it is deep grouping
			if (level !== 0) {
				utils.forEach(objValues, function (observable) {
					//but not falsy things and not HTML Elements
					if (observable && !observable.nodeType && (!ko.isComputed(observable) || observable.rules)) {
						traverseGraph(observable, context, level + 1);
					}
				});
			}
		}
	
		function collectErrors(array) {
			var errors = [];
			forEach(array, function (observable) {
				// Do not collect validatedObservable errors
				if (utils.isValidatable(observable) && !observable.isValid()) {
					// Use peek because we don't want a dependency for 'error' property because it
					// changes before 'isValid' does. (Issue #99)
					errors.push(observable.error.peek());
				}
			});
			return errors;
		}
	
		return {
			//Call this on startup
			//any config can be overridden with the passed in options
			init: function (options, force) {
				//done run this multiple times if we don't really want to
				if (isInitialized > 0 && !force) {
					return;
				}
	
				//because we will be accessing options properties it has to be an object at least
				options = options || {};
				//if specific error classes are not provided then apply generic errorClass
				//it has to be done on option so that options.errorClass can override default
				//errorElementClass and errorMessage class but not those provided in options
				options.errorElementClass = options.errorElementClass || options.errorClass || configuration.errorElementClass;
				options.errorMessageClass = options.errorMessageClass || options.errorClass || configuration.errorMessageClass;
	
				extend(configuration, options);
	
				if (configuration.registerExtenders) {
					kv.registerExtenders();
				}
	
				isInitialized = 1;
			},
	
			// resets the config back to its original state
			reset: kv.configuration.reset,
	
			// recursively walks a viewModel and creates an object that
			// provides validation information for the entire viewModel
			// obj -> the viewModel to walk
			// options -> {
			//	  deep: false, // if true, will walk past the first level of viewModel properties
			//	  observable: false // if true, returns a computed observable indicating if the viewModel is valid
			// }
			group: function group(obj, options) { // array of observables or viewModel
				options = extend(extend({}, configuration.grouping), options);
	
				var context = {
					options: options,
					graphMonitor: ko.observable(),
					flagged: [],
					subscriptions: [],
					validatables: []
				};
	
				var result = null;
	
				//if using observables then traverse structure once and add observables
				if (options.observable) {
					result = ko.computed(function () {
						context.graphMonitor(); //register dependency
						runTraversal(obj, context);
						return collectErrors(context.validatables);
					});
				}
				else { //if not using observables then every call to error() should traverse the structure
					result = function () {
						runTraversal(obj, context);
						return collectErrors(context.validatables);
					};
				}
	
				result.showAllMessages = function (show) { // thanks @heliosPortal
					if (show === undefined) {//default to true
						show = true;
					}
	
					result.forEach(function (observable) {
						if (utils.isValidatable(observable)) {
							observable.isModified(show);
						}
					});
				};
	
				result.isAnyMessageShown = function () {
					var invalidAndModifiedPresent;
	
					invalidAndModifiedPresent = !!result.find(function (observable) {
						return utils.isValidatable(observable) && !observable.isValid() && observable.isModified();
					});
					return invalidAndModifiedPresent;
				};
	
				result.filter = function(predicate) {
					predicate = predicate || function () { return true; };
					// ensure we have latest changes
					result();
	
					return koUtils.arrayFilter(context.validatables, predicate);
				};
	
				result.find = function(predicate) {
					predicate = predicate || function () { return true; };
					// ensure we have latest changes
					result();
	
					return koUtils.arrayFirst(context.validatables, predicate);
				};
	
				result.forEach = function(callback) {
					callback = callback || function () { };
					// ensure we have latest changes
					result();
	
					forEach(context.validatables, callback);
				};
	
				result.map = function(mapping) {
					mapping = mapping || function (item) { return item; };
					// ensure we have latest changes
					result();
	
					return koUtils.arrayMap(context.validatables, mapping);
				};
	
				/**
				 * @private You should not rely on this method being here.
				 * It's a private method and it may change in the future.
				 *
				 * @description Updates the validated object and collects errors from it.
				 */
				result._updateState = function(newValue) {
					if (!utils.isObject(newValue)) {
						throw new Error('An object is required.');
					}
					obj = newValue;
					if (options.observable) {
						context.graphMonitor.valueHasMutated();
					}
					else {
						runTraversal(newValue, context);
						return collectErrors(context.validatables);
					}
				};
				return result;
			},
	
			formatMessage: function (message, params, observable) {
				if (utils.isObject(params) && params.typeAttr) {
					params = params.value;
				}
				if (typeof message === 'function') {
					return message(params, observable);
				}
				var replacements = unwrap(params);
	            if (replacements == null) {
	                replacements = [];
	            }
				if (!utils.isArray(replacements)) {
					replacements = [replacements];
				}
				return message.replace(/{(\d+)}/gi, function(match, index) {
					if (typeof replacements[index] !== 'undefined') {
						return replacements[index];
					}
					return match;
				});
			},
	
			// addRule:
			// This takes in a ko.observable and a Rule Context - which is just a rule name and params to supply to the validator
			// ie: kv.addRule(myObservable, {
			//		  rule: 'required',
			//		  params: true
			//	  });
			//
			addRule: function (observable, rule) {
				observable.extend({ validatable: true });
	
				var hasRule = !!koUtils.arrayFirst(observable.rules(), function(item) {
					return item.rule && item.rule === rule.rule;
				});
	
				if (!hasRule) {
					//push a Rule Context to the observables local array of Rule Contexts
					observable.rules.push(rule);
				}
				return observable;
			},
	
			// addAnonymousRule:
			// Anonymous Rules essentially have all the properties of a Rule, but are only specific for a certain property
			// and developers typically are wanting to add them on the fly or not register a rule with the 'kv.rules' object
			//
			// Example:
			// var test = ko.observable('something').extend{(
			//	  validation: {
			//		  validator: function(val, someOtherVal){
			//			  return true;
			//		  },
			//		  message: "Something must be really wrong!',
			//		  params: true
			//	  }
			//  )};
			addAnonymousRule: function (observable, ruleObj) {
				if (ruleObj['message'] === undefined) {
					ruleObj['message'] = 'Error';
				}
	
				//make sure onlyIf is honoured
				if (ruleObj.onlyIf) {
					ruleObj.condition = ruleObj.onlyIf;
				}
	
				//add the anonymous rule to the observable
				kv.addRule(observable, ruleObj);
			},
	
			addExtender: function (ruleName) {
				ko.extenders[ruleName] = function (observable, params) {
					//params can come in a few flavors
					// 1. Just the params to be passed to the validator
					// 2. An object containing the Message to be used and the Params to pass to the validator
					// 3. A condition when the validation rule to be applied
					//
					// Example:
					// var test = ko.observable(3).extend({
					//	  max: {
					//		  message: 'This special field has a Max of {0}',
					//		  params: 2,
					//		  onlyIf: function() {
					//					  return specialField.IsVisible();
					//				  }
					//	  }
					//  )};
					//
					if (params && (params.message || params.onlyIf)) { //if it has a message or condition object, then its an object literal to use
						return kv.addRule(observable, {
							rule: ruleName,
							message: params.message,
							params: utils.isEmptyVal(params.params) ? true : params.params,
							condition: params.onlyIf
						});
					} else {
						return kv.addRule(observable, {
							rule: ruleName,
							params: params
						});
					}
				};
			},
	
			// loops through all kv.rules and adds them as extenders to
			// ko.extenders
			registerExtenders: function () { // root extenders optional, use 'validation' extender if would cause conflicts
				if (configuration.registerExtenders) {
					for (var ruleName in kv.rules) {
						if (kv.rules.hasOwnProperty(ruleName)) {
							if (!ko.extenders[ruleName]) {
								kv.addExtender(ruleName);
							}
						}
					}
				}
			},
	
			//creates a span next to the @element with the specified error class
			insertValidationMessage: function (element) {
				var span = document.createElement('SPAN');
				span.className = utils.getConfigOptions(element).errorMessageClass;
				utils.insertAfter(element, span);
				return span;
			},
	
			// if html-5 validation attributes have been specified, this parses
			// the attributes on @element
			parseInputValidationAttributes: function (element, valueAccessor) {
				forEach(kv.configuration.html5Attributes, function (attr) {
					if (utils.hasAttribute(element, attr)) {
	
						var params = element.getAttribute(attr) || true;
	
						if (attr === 'min' || attr === 'max')
						{
							// If we're validating based on the min and max attributes, we'll
							// need to know what the 'type' attribute is set to
							var typeAttr = element.getAttribute('type');
							if (typeof typeAttr === "undefined" || !typeAttr)
							{
								// From http://www.w3.org/TR/html-markup/input:
								//   An input element with no type attribute specified represents the
								//   same thing as an input element with its type attribute set to "text".
								typeAttr = "text";
							}
							params = {typeAttr: typeAttr, value: params};
						}
	
						kv.addRule(valueAccessor(), {
							rule: attr,
							params: params
						});
					}
				});
	
				var currentType = element.getAttribute('type');
				forEach(kv.configuration.html5InputTypes, function (type) {
					if (type === currentType) {
						kv.addRule(valueAccessor(), {
							rule: (type === 'date') ? 'dateISO' : type,
							params: true
						});
					}
				});
			},
	
			// writes html5 validation attributes on the element passed in
			writeInputValidationAttributes: function (element, valueAccessor) {
				var observable = valueAccessor();
	
				if (!observable || !observable.rules) {
					return;
				}
	
				var contexts = observable.rules(); // observable array
	
				// loop through the attributes and add the information needed
				forEach(kv.configuration.html5Attributes, function (attr) {
					var ctx = koUtils.arrayFirst(contexts, function (ctx) {
						return ctx.rule && ctx.rule.toLowerCase() === attr.toLowerCase();
					});
	
					if (!ctx) {
						return;
					}
	
					// we have a rule matching a validation attribute at this point
					// so lets add it to the element along with the params
					ko.computed({
						read: function() {
							var params = ko.unwrap(ctx.params);
	
							// we have to do some special things for the pattern validation
							if (ctx.rule === "pattern" && params instanceof RegExp) {
								// we need the pure string representation of the RegExpr without the //gi stuff
								params = params.source;
							}
	
							element.setAttribute(attr, params);
						},
						disposeWhenNodeIsRemoved: element
					});
				});
	
				contexts = null;
			},
	
			//take an existing binding handler and make it cause automatic validations
			makeBindingHandlerValidatable: function (handlerName) {
				var init = ko.bindingHandlers[handlerName].init;
	
				ko.bindingHandlers[handlerName].init = function (element, valueAccessor, allBindingsAccessor, viewModel, bindingContext) {
	
					init(element, valueAccessor, allBindingsAccessor, viewModel, bindingContext);
	
					return ko.bindingHandlers['validationCore'].init(element, valueAccessor, allBindingsAccessor, viewModel, bindingContext);
				};
			},
	
			// visit an objects properties and apply validation rules from a definition
			setRules: function (target, definition) {
				var setRules = function (target, definition) {
					if (!target || !definition) { return; }
	
					for (var prop in definition) {
						if (!definition.hasOwnProperty(prop)) { continue; }
						var ruleDefinitions = definition[prop];
	
						//check the target property exists and has a value
						if (!target[prop]) { continue; }
						var targetValue = target[prop],
							unwrappedTargetValue = unwrap(targetValue),
							rules = {},
							nonRules = {};
	
						for (var rule in ruleDefinitions) {
							if (!ruleDefinitions.hasOwnProperty(rule)) { continue; }
							if (kv.rules[rule]) {
								rules[rule] = ruleDefinitions[rule];
							} else {
								nonRules[rule] = ruleDefinitions[rule];
							}
						}
	
						//apply rules
						if (ko.isObservable(targetValue)) {
							targetValue.extend(rules);
						}
	
						//then apply child rules
						//if it's an array, apply rules to all children
						if (unwrappedTargetValue && utils.isArray(unwrappedTargetValue)) {
							for (var i = 0; i < unwrappedTargetValue.length; i++) {
								setRules(unwrappedTargetValue[i], nonRules);
							}
							//otherwise, just apply to this property
						} else {
							setRules(unwrappedTargetValue, nonRules);
						}
					}
				};
				setRules(target, definition);
			}
		};
	
	}());
	
	// expose api publicly
	extend(ko.validation, api);
	;//Validation Rules:
	// You can view and override messages or rules via:
	// kv.rules[ruleName]
	//
	// To implement a custom Rule, simply use this template:
	// kv.rules['<custom rule name>'] = {
	//      validator: function (val, param) {
	//          <custom logic>
	//          return <true or false>;
	//      },
	//      message: '<custom validation message>' //optionally you can also use a '{0}' to denote a placeholder that will be replaced with your 'param'
	// };
	//
	// Example:
	// kv.rules['mustEqual'] = {
	//      validator: function( val, mustEqualVal ){
	//          return val === mustEqualVal;
	//      },
	//      message: 'This field must equal {0}'
	// };
	//
	kv.rules = {};
	kv.rules['required'] = {
		validator: function (val, required) {
			var testVal;
	
			if (val === undefined || val === null) {
				return !required;
			}
	
			testVal = val;
			if (typeof (val) === 'string') {
				if (String.prototype.trim) {
					testVal = val.trim();
				}
				else {
					testVal = val.replace(/^\s+|\s+$/g, '');
				}
			}
	
			if (!required) {// if they passed: { required: false }, then don't require this
				return true;
			}
	
			return ((testVal + '').length > 0);
		},
		message: 'This field is required.'
	};
	
	function minMaxValidatorFactory(validatorName) {
	    var isMaxValidation = validatorName === "max";
	
	    return function (val, options) {
	        if (kv.utils.isEmptyVal(val)) {
	            return true;
	        }
	
	        var comparisonValue, type;
	        if (options.typeAttr === undefined) {
	            // This validator is being called from javascript rather than
	            // being bound from markup
	            type = "text";
	            comparisonValue = options;
	        } else {
	            type = options.typeAttr;
	            comparisonValue = options.value;
	        }
	
	        // From http://www.w3.org/TR/2012/WD-html5-20121025/common-input-element-attributes.html#attr-input-min,
	        // if the value is parseable to a number, then the minimum should be numeric
	        if (!isNaN(comparisonValue) && !(comparisonValue instanceof Date)) {
	            type = "number";
	        }
	
	        var regex, valMatches, comparisonValueMatches;
	        switch (type.toLowerCase()) {
	            case "week":
	                regex = /^(\d{4})-W(\d{2})$/;
	                valMatches = val.match(regex);
	                if (valMatches === null) {
	                    throw new Error("Invalid value for " + validatorName + " attribute for week input.  Should look like " +
	                        "'2000-W33' http://www.w3.org/TR/html-markup/input.week.html#input.week.attrs.min");
	                }
	                comparisonValueMatches = comparisonValue.match(regex);
	                // If no regex matches were found, validation fails
	                if (!comparisonValueMatches) {
	                    return false;
	                }
	
	                if (isMaxValidation) {
	                    return (valMatches[1] < comparisonValueMatches[1]) || // older year
	                        // same year, older week
	                        ((valMatches[1] === comparisonValueMatches[1]) && (valMatches[2] <= comparisonValueMatches[2]));
	                } else {
	                    return (valMatches[1] > comparisonValueMatches[1]) || // newer year
	                        // same year, newer week
	                        ((valMatches[1] === comparisonValueMatches[1]) && (valMatches[2] >= comparisonValueMatches[2]));
	                }
	                break;
	
	            case "month":
	                regex = /^(\d{4})-(\d{2})$/;
	                valMatches = val.match(regex);
	                if (valMatches === null) {
	                    throw new Error("Invalid value for " + validatorName + " attribute for month input.  Should look like " +
	                        "'2000-03' http://www.w3.org/TR/html-markup/input.month.html#input.month.attrs.min");
	                }
	                comparisonValueMatches = comparisonValue.match(regex);
	                // If no regex matches were found, validation fails
	                if (!comparisonValueMatches) {
	                    return false;
	                }
	
	                if (isMaxValidation) {
	                    return ((valMatches[1] < comparisonValueMatches[1]) || // older year
	                        // same year, older month
	                        ((valMatches[1] === comparisonValueMatches[1]) && (valMatches[2] <= comparisonValueMatches[2])));
	                } else {
	                    return (valMatches[1] > comparisonValueMatches[1]) || // newer year
	                        // same year, newer month
	                        ((valMatches[1] === comparisonValueMatches[1]) && (valMatches[2] >= comparisonValueMatches[2]));
	                }
	                break;
	
	            case "number":
	            case "range":
	                if (isMaxValidation) {
	                    return (!isNaN(val) && parseFloat(val) <= parseFloat(comparisonValue));
	                } else {
	                    return (!isNaN(val) && parseFloat(val) >= parseFloat(comparisonValue));
	                }
	                break;
	
	            default:
	                if (isMaxValidation) {
	                    return val <= comparisonValue;
	                } else {
	                    return val >= comparisonValue;
	                }
	        }
	    };
	}
	
	kv.rules['min'] = {
		validator: minMaxValidatorFactory("min"),
		message: 'Please enter a value greater than or equal to {0}.'
	};
	
	kv.rules['max'] = {
		validator: minMaxValidatorFactory("max"),
		message: 'Please enter a value less than or equal to {0}.'
	};
	
	kv.rules['minLength'] = {
		validator: function (val, minLength) {
			if(kv.utils.isEmptyVal(val)) { return true; }
			var normalizedVal = kv.utils.isNumber(val) ? ('' + val) : val;
			return normalizedVal.length >= minLength;
		},
		message: 'Please enter at least {0} characters.'
	};
	
	kv.rules['maxLength'] = {
		validator: function (val, maxLength) {
			if(kv.utils.isEmptyVal(val)) { return true; }
			var normalizedVal = kv.utils.isNumber(val) ? ('' + val) : val;
			return normalizedVal.length <= maxLength;
		},
		message: 'Please enter no more than {0} characters.'
	};
	
	kv.rules['pattern'] = {
		validator: function (val, regex) {
			return kv.utils.isEmptyVal(val) || val.toString().match(regex) !== null;
		},
		message: 'Please check this value.'
	};
	
	kv.rules['step'] = {
		validator: function (val, step) {
	
			// in order to handle steps of .1 & .01 etc.. Modulus won't work
			// if the value is a decimal, so we have to correct for that
			if (kv.utils.isEmptyVal(val) || step === 'any') { return true; }
			var dif = (val * 100) % (step * 100);
			return Math.abs(dif) < 0.00001 || Math.abs(1 - dif) < 0.00001;
		},
		message: 'The value must increment by {0}.'
	};
	
	kv.rules['email'] = {
		validator: function (val, validate) {
			if (!validate) { return true; }
	
			//I think an empty email address is also a valid entry
			//if one want's to enforce entry it should be done with 'required: true'
			return kv.utils.isEmptyVal(val) || (
				// jquery validate regex - thanks Scott Gonzalez
				validate && /^((([a-z]|\d|[!#\$%&'\*\+\-\/=\?\^_`{\|}~]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])+(\.([a-z]|\d|[!#\$%&'\*\+\-\/=\?\^_`{\|}~]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])+)*)|((\x22)((((\x20|\x09)*(\x0d\x0a))?(\x20|\x09)+)?(([\x01-\x08\x0b\x0c\x0e-\x1f\x7f]|\x21|[\x23-\x5b]|[\x5d-\x7e]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(\\([\x01-\x09\x0b\x0c\x0d-\x7f]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]))))*(((\x20|\x09)*(\x0d\x0a))?(\x20|\x09)+)?(\x22)))@((([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.)+(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))$/i.test(val)
			);
		},
		message: 'Please enter a proper email address.'
	};
	
	kv.rules['date'] = {
		validator: function (value, validate) {
			if (!validate) { return true; }
			return kv.utils.isEmptyVal(value) || (validate && !/Invalid|NaN/.test(new Date(value)));
		},
		message: 'Please enter a proper date.'
	};
	
	kv.rules['dateISO'] = {
		validator: function (value, validate) {
			if (!validate) { return true; }
			return kv.utils.isEmptyVal(value) || (validate && /^\d{4}[-/](?:0?[1-9]|1[012])[-/](?:0?[1-9]|[12][0-9]|3[01])$/.test(value));
		},
		message: 'Please enter a proper date.'
	};
	
	kv.rules['number'] = {
		validator: function (value, validate) {
			if (!validate) { return true; }
			return kv.utils.isEmptyVal(value) || (validate && /^-?(?:\d+|\d{1,3}(?:,\d{3})+)?(?:\.\d+)?$/.test(value));
		},
		message: 'Please enter a number.'
	};
	
	kv.rules['digit'] = {
		validator: function (value, validate) {
			if (!validate) { return true; }
			return kv.utils.isEmptyVal(value) || (validate && /^\d+$/.test(value));
		},
		message: 'Please enter a digit.'
	};
	
	kv.rules['phoneUS'] = {
		validator: function (phoneNumber, validate) {
			if (!validate) { return true; }
			if (kv.utils.isEmptyVal(phoneNumber)) { return true; } // makes it optional, use 'required' rule if it should be required
			if (typeof (phoneNumber) !== 'string') { return false; }
			phoneNumber = phoneNumber.replace(/\s+/g, "");
			return validate && phoneNumber.length > 9 && phoneNumber.match(/^(1-?)?(\([2-9]\d{2}\)|[2-9]\d{2})-?[2-9]\d{2}-?\d{4}$/);
		},
		message: 'Please specify a valid phone number.'
	};
	
	kv.rules['equal'] = {
		validator: function (val, params) {
			var otherValue = params;
			return val === kv.utils.getValue(otherValue);
		},
		message: 'Values must equal.'
	};
	
	kv.rules['notEqual'] = {
		validator: function (val, params) {
			var otherValue = params;
			return val !== kv.utils.getValue(otherValue);
		},
		message: 'Please choose another value.'
	};
	
	//unique in collection
	// options are:
	//    collection: array or function returning (observable) array
	//              in which the value has to be unique
	//    valueAccessor: function that returns value from an object stored in collection
	//              if it is null the value is compared directly
	//    external: set to true when object you are validating is automatically updating collection
	kv.rules['unique'] = {
		validator: function (val, options) {
			var c = kv.utils.getValue(options.collection),
				external = kv.utils.getValue(options.externalValue),
				counter = 0;
	
			if (!val || !c) { return true; }
	
			koUtils.arrayFilter(c, function (item) {
				if (val === (options.valueAccessor ? options.valueAccessor(item) : item)) { counter++; }
			});
			// if value is external even 1 same value in collection means the value is not unique
			return counter < (!!external ? 1 : 2);
		},
		message: 'Please make sure the value is unique.'
	};
	
	
	//now register all of these!
	(function () {
		kv.registerExtenders();
	}());
	;// The core binding handler
	// this allows us to setup any value binding that internally always
	// performs the same functionality
	ko.bindingHandlers['validationCore'] = (function () {
	
		return {
			init: function (element, valueAccessor, allBindingsAccessor, viewModel, bindingContext) {
				var config = kv.utils.getConfigOptions(element);
				var observable = valueAccessor();
	
				// parse html5 input validation attributes, optional feature
				if (config.parseInputAttributes) {
					kv.utils.async(function () { kv.parseInputValidationAttributes(element, valueAccessor); });
				}
	
				// if requested insert message element and apply bindings
				if (config.insertMessages && kv.utils.isValidatable(observable)) {
	
					// insert the <span></span>
					var validationMessageElement = kv.insertValidationMessage(element);
	
					// if we're told to use a template, make sure that gets rendered
					if (config.messageTemplate) {
						ko.renderTemplate(config.messageTemplate, { field: observable }, null, validationMessageElement, 'replaceNode');
					} else {
						ko.applyBindingsToNode(validationMessageElement, { validationMessage: observable });
					}
				}
	
				// write the html5 attributes if indicated by the config
				if (config.writeInputAttributes && kv.utils.isValidatable(observable)) {
	
					kv.writeInputValidationAttributes(element, valueAccessor);
				}
	
				// if requested, add binding to decorate element
				if (config.decorateInputElement && kv.utils.isValidatable(observable)) {
					ko.applyBindingsToNode(element, { validationElement: observable });
				}
			}
		};
	
	}());
	
	// override for KO's default 'value', 'checked', 'textInput' and selectedOptions bindings
	kv.makeBindingHandlerValidatable("value");
	kv.makeBindingHandlerValidatable("checked");
	if (ko.bindingHandlers.textInput) {
		kv.makeBindingHandlerValidatable("textInput");
	}
	kv.makeBindingHandlerValidatable("selectedOptions");
	
	
	ko.bindingHandlers['validationMessage'] = { // individual error message, if modified or post binding
		update: function (element, valueAccessor) {
			var obsv = valueAccessor(),
				config = kv.utils.getConfigOptions(element),
				val = unwrap(obsv),
				msg = null,
				isModified = false,
				isValid = false;
	
			if (obsv === null || typeof obsv === 'undefined') {
				throw new Error('Cannot bind validationMessage to undefined value. data-bind expression: ' +
					element.getAttribute('data-bind'));
			}
	
			isModified = obsv.isModified && obsv.isModified();
			isValid = obsv.isValid && obsv.isValid();
	
			var error = null;
			if (!config.messagesOnModified || isModified) {
				error = isValid ? null : obsv.error;
			}
	
			var isVisible = !config.messagesOnModified || isModified ? !isValid : false;
			var isCurrentlyVisible = element.style.display !== "none";
	
			if (config.allowHtmlMessages) {
				koUtils.setHtml(element, error);
			} else {
				ko.bindingHandlers.text.update(element, function () { return error; });
			}
	
			if (isCurrentlyVisible && !isVisible) {
				element.style.display = 'none';
			} else if (!isCurrentlyVisible && isVisible) {
				element.style.display = '';
			}
		}
	};
	
	ko.bindingHandlers['validationElement'] = {
		update: function (element, valueAccessor, allBindingsAccessor) {
			var obsv = valueAccessor(),
				config = kv.utils.getConfigOptions(element),
				val = unwrap(obsv),
				msg = null,
				isModified = false,
				isValid = false;
	
			if (obsv === null || typeof obsv === 'undefined') {
				throw new Error('Cannot bind validationElement to undefined value. data-bind expression: ' +
					element.getAttribute('data-bind'));
			}
	
			isModified = obsv.isModified && obsv.isModified();
			isValid = obsv.isValid && obsv.isValid();
	
			// create an evaluator function that will return something like:
			// css: { validationElement: true }
			var cssSettingsAccessor = function () {
				var css = {};
	
				var shouldShow = ((!config.decorateElementOnModified || isModified) ? !isValid : false);
	
				// css: { validationElement: false }
				css[config.errorElementClass] = shouldShow;
	
				return css;
			};
	
			//add or remove class on the element;
			ko.bindingHandlers.css.update(element, cssSettingsAccessor, allBindingsAccessor);
			if (!config.errorsAsTitle) { return; }
	
			ko.bindingHandlers.attr.update(element, function () {
				var
					hasModification = !config.errorsAsTitleOnModified || isModified,
					title = kv.utils.getOriginalElementTitle(element);
	
				if (hasModification && !isValid) {
					return { title: obsv.error, 'data-orig-title': title };
				} else if (!hasModification || isValid) {
					return { title: title, 'data-orig-title': null };
				}
			});
		}
	};
	
	// ValidationOptions:
	// This binding handler allows you to override the initial config by setting any of the options for a specific element or context of elements
	//
	// Example:
	// <div data-bind="validationOptions: { insertMessages: true, messageTemplate: 'customTemplate', errorMessageClass: 'mySpecialClass'}">
	//      <input type="text" data-bind="value: someValue"/>
	//      <input type="text" data-bind="value: someValue2"/>
	// </div>
	ko.bindingHandlers['validationOptions'] = (function () {
		return {
			init: function (element, valueAccessor, allBindingsAccessor, viewModel, bindingContext) {
				var options = unwrap(valueAccessor());
				if (options) {
					var newConfig = extend({}, kv.configuration);
					extend(newConfig, options);
	
					//store the validation options on the node so we can retrieve it later
					kv.utils.setDomData(element, newConfig);
				}
			}
		};
	}());
	;// Validation Extender:
	// This is for creating custom validation logic on the fly
	// Example:
	// var test = ko.observable('something').extend{(
	//      validation: {
	//          validator: function(val, someOtherVal){
	//              return true;
	//          },
	//          message: "Something must be really wrong!',
	//          params: true
	//      }
	//  )};
	ko.extenders['validation'] = function (observable, rules) { // allow single rule or array
		forEach(kv.utils.isArray(rules) ? rules : [rules], function (rule) {
			// the 'rule' being passed in here has no name to identify a core Rule,
			// so we add it as an anonymous rule
			// If the developer is wanting to use a core Rule, but use a different message see the 'addExtender' logic for examples
			kv.addAnonymousRule(observable, rule);
		});
		return observable;
	};
	
	//This is the extender that makes a Knockout Observable also 'Validatable'
	//examples include:
	// 1. var test = ko.observable('something').extend({validatable: true});
	// this will ensure that the Observable object is setup properly to respond to rules
	//
	// 2. test.extend({validatable: false});
	// this will remove the validation properties from the Observable object should you need to do that.
	ko.extenders['validatable'] = function (observable, options) {
		if (!kv.utils.isObject(options)) {
			options = { enable: options };
		}
	
		if (!('enable' in options)) {
			options.enable = true;
		}
	
		if (options.enable && !kv.utils.isValidatable(observable)) {
			var config = kv.configuration.validate || {};
			var validationOptions = {
				throttleEvaluation : options.throttle || config.throttle
			};
	
			observable.error = ko.observable(null); // holds the error message, we only need one since we stop processing validators when one is invalid
	
			// observable.rules:
			// ObservableArray of Rule Contexts, where a Rule Context is simply the name of a rule and the params to supply to it
			//
			// Rule Context = { rule: '<rule name>', params: '<passed in params>', message: '<Override of default Message>' }
			observable.rules = ko.observableArray(); //holds the rule Contexts to use as part of validation
	
			//in case async validation is occurring
			observable.isValidating = ko.observable(false);
	
			//the true holder of whether the observable is valid or not
			observable.__valid__ = ko.observable(true);
	
			observable.isModified = ko.observable(false);
	
			// a semi-protected observable
			observable.isValid = ko.computed(observable.__valid__);
	
			//manually set error state
			observable.setError = function (error) {
				var previousError = observable.error.peek();
				var previousIsValid = observable.__valid__.peek();
	
				observable.error(error);
				observable.__valid__(false);
	
				if (previousError !== error && !previousIsValid) {
					// if the observable was not valid before then isValid will not mutate,
					// hence causing any grouping to not display the latest error.
					observable.isValid.notifySubscribers();
				}
			};
	
			//manually clear error state
			observable.clearError = function () {
				observable.error(null);
				observable.__valid__(true);
				return observable;
			};
	
			//subscribe to changes in the observable
			var h_change = observable.subscribe(function () {
				observable.isModified(true);
			});
	
			// we use a computed here to ensure that anytime a dependency changes, the
			// validation logic evaluates
			var h_obsValidationTrigger = ko.computed(extend({
				read: function () {
					var obs = observable(),
						ruleContexts = observable.rules();
	
					kv.validateObservable(observable);
	
					return true;
				}
			}, validationOptions));
	
			extend(h_obsValidationTrigger, validationOptions);
	
			observable._disposeValidation = function () {
				//first dispose of the subscriptions
				observable.isValid.dispose();
				observable.rules.removeAll();
				h_change.dispose();
				h_obsValidationTrigger.dispose();
	
				delete observable['rules'];
				delete observable['error'];
				delete observable['isValid'];
				delete observable['isValidating'];
				delete observable['__valid__'];
				delete observable['isModified'];
	            delete observable['setError'];
	            delete observable['clearError'];
	            delete observable['_disposeValidation'];
			};
		} else if (options.enable === false && observable._disposeValidation) {
			observable._disposeValidation();
		}
		return observable;
	};
	
	function validateSync(observable, rule, ctx) {
		//Execute the validator and see if its valid
		if (!rule.validator(observable(), (ctx.params === undefined ? true : unwrap(ctx.params)))) { // default param is true, eg. required = true
	
			//not valid, so format the error message and stick it in the 'error' variable
			observable.setError(kv.formatMessage(
						ctx.message || rule.message,
						unwrap(ctx.params),
						observable));
			return false;
		} else {
			return true;
		}
	}
	
	function validateAsync(observable, rule, ctx) {
		observable.isValidating(true);
	
		var callBack = function (valObj) {
			var isValid = false,
				msg = '';
	
			if (!observable.__valid__()) {
	
				// since we're returning early, make sure we turn this off
				observable.isValidating(false);
	
				return; //if its already NOT valid, don't add to that
			}
	
			//we were handed back a complex object
			if (valObj['message']) {
				isValid = valObj.isValid;
				msg = valObj.message;
			} else {
				isValid = valObj;
			}
	
			if (!isValid) {
				//not valid, so format the error message and stick it in the 'error' variable
				observable.error(kv.formatMessage(
					msg || ctx.message || rule.message,
					unwrap(ctx.params),
					observable));
				observable.__valid__(isValid);
			}
	
			// tell it that we're done
			observable.isValidating(false);
		};
	
		kv.utils.async(function() {
		    //fire the validator and hand it the callback
	        rule.validator(observable(), ctx.params === undefined ? true : unwrap(ctx.params), callBack);
		});
	}
	
	kv.validateObservable = function (observable) {
		var i = 0,
			rule, // the rule validator to execute
			ctx, // the current Rule Context for the loop
			ruleContexts = observable.rules(), //cache for iterator
			len = ruleContexts.length; //cache for iterator
	
		for (; i < len; i++) {
	
			//get the Rule Context info to give to the core Rule
			ctx = ruleContexts[i];
	
			// checks an 'onlyIf' condition
			if (ctx.condition && !ctx.condition()) {
				continue;
			}
	
			//get the core Rule to use for validation
			rule = ctx.rule ? kv.rules[ctx.rule] : ctx;
	
			if (rule['async'] || ctx['async']) {
				//run async validation
				validateAsync(observable, rule, ctx);
	
			} else {
				//run normal sync validation
				if (!validateSync(observable, rule, ctx)) {
					return false; //break out of the loop
				}
			}
		}
		//finally if we got this far, make the observable valid again!
		observable.clearError();
		return true;
	};
	;
	var _locales = {};
	var _currentLocale;
	
	kv.defineLocale = function(name, values) {
		if (name && values) {
			_locales[name.toLowerCase()] = values;
			return values;
		}
		return null;
	};
	
	kv.locale = function(name) {
		if (name) {
			name = name.toLowerCase();
	
			if (_locales.hasOwnProperty(name)) {
				kv.localize(_locales[name]);
				_currentLocale = name;
			}
			else {
				throw new Error('Localization ' + name + ' has not been loaded.');
			}
		}
		return _currentLocale;
	};
	
	//quick function to override rule messages
	kv.localize = function (msgTranslations) {
		var rules = kv.rules;
	
		//loop the properties in the object and assign the msg to the rule
		for (var ruleName in msgTranslations) {
			if (rules.hasOwnProperty(ruleName)) {
				rules[ruleName].message = msgTranslations[ruleName];
			}
		}
	};
	
	// Populate default locale (this will make en-US.js somewhat redundant)
	(function() {
		var localeData = {};
		var rules = kv.rules;
	
		for (var ruleName in rules) {
			if (rules.hasOwnProperty(ruleName)) {
				localeData[ruleName] = rules[ruleName].message;
			}
		}
		kv.defineLocale('en-us', localeData);
	})();
	
	// No need to invoke locale because the messages are already defined along with the rules for en-US
	_currentLocale = 'en-us';
	;/**
	 * Possible invocations:
	 * 		applyBindingsWithValidation(viewModel)
	 * 		applyBindingsWithValidation(viewModel, options)
	 * 		applyBindingsWithValidation(viewModel, rootNode)
	 *		applyBindingsWithValidation(viewModel, rootNode, options)
	 */
	ko.applyBindingsWithValidation = function (viewModel, rootNode, options) {
		var node = document.body,
			config;
	
		if (rootNode && rootNode.nodeType) {
			node = rootNode;
			config = options;
		}
		else {
			config = rootNode;
		}
	
		kv.init();
	
		if (config) {
			config = extend(extend({}, kv.configuration), config);
			kv.utils.setDomData(node, config);
		}
	
		ko.applyBindings(viewModel, node);
	};
	
	//override the original applyBindings so that we can ensure all new rules and what not are correctly registered
	var origApplyBindings = ko.applyBindings;
	ko.applyBindings = function (viewModel, rootNode) {
	
		kv.init();
	
		origApplyBindings(viewModel, rootNode);
	};
	
	ko.validatedObservable = function (initialValue, options) {
		if (!options && !kv.utils.isObject(initialValue)) {
			return ko.observable(initialValue).extend({ validatable: true });
		}
	
		var obsv = ko.observable(initialValue);
		obsv.errors = kv.group(kv.utils.isObject(initialValue) ? initialValue : {}, options);
		obsv.isValid = ko.observable(obsv.errors().length === 0);
	
		if (ko.isObservable(obsv.errors)) {
			obsv.errors.subscribe(function(errors) {
				obsv.isValid(errors.length === 0);
			});
		}
		else {
			ko.computed(obsv.errors).subscribe(function (errors) {
				obsv.isValid(errors.length === 0);
			});
		}
	
		obsv.subscribe(function(newValue) {
			if (!kv.utils.isObject(newValue)) {
				/*
				 * The validation group works on objects.
				 * Since the new value is a primitive (scalar, null or undefined) we need
				 * to create an empty object to pass along.
				 */
				newValue = {};
			}
			// Force the group to refresh
			obsv.errors._updateState(newValue);
			obsv.isValid(obsv.errors().length === 0);
		});
	
		return obsv;
	};
	;}));


/***/ },
/* 104 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;"use strict";
	
	var _typeof2 = __webpack_require__(4);
	
	var _typeof3 = _interopRequireDefault(_typeof2);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/*
	 _ _      _       _
	 ___| (_) ___| | __  (_)___
	 / __| | |/ __| |/ /  | / __|
	 \__ \ | | (__|   < _ | \__ \
	 |___/_|_|\___|_|\_(_)/ |___/
	 |__/
	
	 Version: 1.5.9
	 Author: Ken Wheeler
	 Website: http://kenwheeler.github.io
	 Docs: http://kenwheeler.github.io/slick
	 Repo: http://github.com/kenwheeler/slick
	 Issues: http://github.com/kenwheeler/slick/issues
	
	 */
	!function (a) {
	  "use strict";
	   true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(2)], __WEBPACK_AMD_DEFINE_FACTORY__ = (a), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : "undefined" != typeof exports ? module.exports = a(require("jquery")) : a(jQuery);
	}(function (a) {
	  "use strict";
	  var b = window.Slick || {};b = function () {
	    function c(c, d) {
	      var f,
	          e = this;e.defaults = { accessibility: !0, adaptiveHeight: !1, appendArrows: a(c), appendDots: a(c), arrows: !0, asNavFor: null, prevArrow: '<button type="button" data-role="none" class="slick-prev" aria-label="Previous" tabindex="0" role="button">Previous</button>', nextArrow: '<button type="button" data-role="none" class="slick-next" aria-label="Next" tabindex="0" role="button">Next</button>', autoplay: !1, autoplaySpeed: 3e3, centerMode: !1, centerPadding: "50px", cssEase: "ease", customPaging: function customPaging(a, b) {
	          return '<button type="button" data-role="none" role="button" aria-required="false" tabindex="0">' + (b + 1) + "</button>";
	        }, dots: !1, dotsClass: "slick-dots", draggable: !0, easing: "linear", edgeFriction: .35, fade: !1, focusOnSelect: !1, infinite: !0, initialSlide: 0, lazyLoad: "ondemand", mobileFirst: !1, pauseOnHover: !0, pauseOnDotsHover: !1, respondTo: "window", responsive: null, rows: 1, rtl: !1, slide: "", slidesPerRow: 1, slidesToShow: 1, slidesToScroll: 1, speed: 500, swipe: !0, swipeToSlide: !1, touchMove: !0, touchThreshold: 5, useCSS: !0, useTransform: !1, variableWidth: !1, vertical: !1, verticalSwiping: !1, waitForAnimate: !0, zIndex: 1e3 }, e.initials = { animating: !1, dragging: !1, autoPlayTimer: null, currentDirection: 0, currentLeft: null, currentSlide: 0, direction: 1, $dots: null, listWidth: null, listHeight: null, loadIndex: 0, $nextArrow: null, $prevArrow: null, slideCount: null, slideWidth: null, $slideTrack: null, $slides: null, sliding: !1, slideOffset: 0, swipeLeft: null, $list: null, touchObject: {}, transformsEnabled: !1, unslicked: !1 }, a.extend(e, e.initials), e.activeBreakpoint = null, e.animType = null, e.animProp = null, e.breakpoints = [], e.breakpointSettings = [], e.cssTransitions = !1, e.hidden = "hidden", e.paused = !1, e.positionProp = null, e.respondTo = null, e.rowCount = 1, e.shouldClick = !0, e.$slider = a(c), e.$slidesCache = null, e.transformType = null, e.transitionType = null, e.visibilityChange = "visibilitychange", e.windowWidth = 0, e.windowTimer = null, f = a(c).data("slick") || {}, e.options = a.extend({}, e.defaults, f, d), e.currentSlide = e.options.initialSlide, e.originalSettings = e.options, "undefined" != typeof document.mozHidden ? (e.hidden = "mozHidden", e.visibilityChange = "mozvisibilitychange") : "undefined" != typeof document.webkitHidden && (e.hidden = "webkitHidden", e.visibilityChange = "webkitvisibilitychange"), e.autoPlay = a.proxy(e.autoPlay, e), e.autoPlayClear = a.proxy(e.autoPlayClear, e), e.changeSlide = a.proxy(e.changeSlide, e), e.clickHandler = a.proxy(e.clickHandler, e), e.selectHandler = a.proxy(e.selectHandler, e), e.setPosition = a.proxy(e.setPosition, e), e.swipeHandler = a.proxy(e.swipeHandler, e), e.dragHandler = a.proxy(e.dragHandler, e), e.keyHandler = a.proxy(e.keyHandler, e), e.autoPlayIterator = a.proxy(e.autoPlayIterator, e), e.instanceUid = b++, e.htmlExpr = /^(?:\s*(<[\w\W]+>)[^>]*)$/, e.registerBreakpoints(), e.init(!0), e.checkResponsive(!0);
	    }var b = 0;return c;
	  }(), b.prototype.addSlide = b.prototype.slickAdd = function (b, c, d) {
	    var e = this;if ("boolean" == typeof c) d = c, c = null;else if (0 > c || c >= e.slideCount) return !1;e.unload(), "number" == typeof c ? 0 === c && 0 === e.$slides.length ? a(b).appendTo(e.$slideTrack) : d ? a(b).insertBefore(e.$slides.eq(c)) : a(b).insertAfter(e.$slides.eq(c)) : d === !0 ? a(b).prependTo(e.$slideTrack) : a(b).appendTo(e.$slideTrack), e.$slides = e.$slideTrack.children(this.options.slide), e.$slideTrack.children(this.options.slide).detach(), e.$slideTrack.append(e.$slides), e.$slides.each(function (b, c) {
	      a(c).attr("data-slick-index", b);
	    }), e.$slidesCache = e.$slides, e.reinit();
	  }, b.prototype.animateHeight = function () {
	    var a = this;if (1 === a.options.slidesToShow && a.options.adaptiveHeight === !0 && a.options.vertical === !1) {
	      var b = a.$slides.eq(a.currentSlide).outerHeight(!0);a.$list.animate({ height: b }, a.options.speed);
	    }
	  }, b.prototype.animateSlide = function (b, c) {
	    var d = {},
	        e = this;e.animateHeight(), e.options.rtl === !0 && e.options.vertical === !1 && (b = -b), e.transformsEnabled === !1 ? e.options.vertical === !1 ? e.$slideTrack.animate({ left: b }, e.options.speed, e.options.easing, c) : e.$slideTrack.animate({ top: b }, e.options.speed, e.options.easing, c) : e.cssTransitions === !1 ? (e.options.rtl === !0 && (e.currentLeft = -e.currentLeft), a({ animStart: e.currentLeft }).animate({ animStart: b }, { duration: e.options.speed, easing: e.options.easing, step: function step(a) {
	        a = Math.ceil(a), e.options.vertical === !1 ? (d[e.animType] = "translate(" + a + "px, 0px)", e.$slideTrack.css(d)) : (d[e.animType] = "translate(0px," + a + "px)", e.$slideTrack.css(d));
	      }, complete: function complete() {
	        c && c.call();
	      } })) : (e.applyTransition(), b = Math.ceil(b), e.options.vertical === !1 ? d[e.animType] = "translate3d(" + b + "px, 0px, 0px)" : d[e.animType] = "translate3d(0px," + b + "px, 0px)", e.$slideTrack.css(d), c && setTimeout(function () {
	      e.disableTransition(), c.call();
	    }, e.options.speed));
	  }, b.prototype.asNavFor = function (b) {
	    var c = this,
	        d = c.options.asNavFor;d && null !== d && (d = a(d).not(c.$slider)), null !== d && "object" == (typeof d === "undefined" ? "undefined" : (0, _typeof3.default)(d)) && d.each(function () {
	      var c = a(this).slick("getSlick");c.unslicked || c.slideHandler(b, !0);
	    });
	  }, b.prototype.applyTransition = function (a) {
	    var b = this,
	        c = {};b.options.fade === !1 ? c[b.transitionType] = b.transformType + " " + b.options.speed + "ms " + b.options.cssEase : c[b.transitionType] = "opacity " + b.options.speed + "ms " + b.options.cssEase, b.options.fade === !1 ? b.$slideTrack.css(c) : b.$slides.eq(a).css(c);
	  }, b.prototype.autoPlay = function () {
	    var a = this;a.autoPlayTimer && clearInterval(a.autoPlayTimer), a.slideCount > a.options.slidesToShow && a.paused !== !0 && (a.autoPlayTimer = setInterval(a.autoPlayIterator, a.options.autoplaySpeed));
	  }, b.prototype.autoPlayClear = function () {
	    var a = this;a.autoPlayTimer && clearInterval(a.autoPlayTimer);
	  }, b.prototype.autoPlayIterator = function () {
	    var a = this;a.options.infinite === !1 ? 1 === a.direction ? (a.currentSlide + 1 === a.slideCount - 1 && (a.direction = 0), a.slideHandler(a.currentSlide + a.options.slidesToScroll)) : (a.currentSlide - 1 === 0 && (a.direction = 1), a.slideHandler(a.currentSlide - a.options.slidesToScroll)) : a.slideHandler(a.currentSlide + a.options.slidesToScroll);
	  }, b.prototype.buildArrows = function () {
	    var b = this;b.options.arrows === !0 && (b.$prevArrow = a(b.options.prevArrow).addClass("slick-arrow"), b.$nextArrow = a(b.options.nextArrow).addClass("slick-arrow"), b.slideCount > b.options.slidesToShow ? (b.$prevArrow.removeClass("slick-hidden").removeAttr("aria-hidden tabindex"), b.$nextArrow.removeClass("slick-hidden").removeAttr("aria-hidden tabindex"), b.htmlExpr.test(b.options.prevArrow) && b.$prevArrow.prependTo(b.options.appendArrows), b.htmlExpr.test(b.options.nextArrow) && b.$nextArrow.appendTo(b.options.appendArrows), b.options.infinite !== !0 && b.$prevArrow.addClass("slick-disabled").attr("aria-disabled", "true")) : b.$prevArrow.add(b.$nextArrow).addClass("slick-hidden").attr({ "aria-disabled": "true", tabindex: "-1" }));
	  }, b.prototype.buildDots = function () {
	    var c,
	        d,
	        b = this;if (b.options.dots === !0 && b.slideCount > b.options.slidesToShow) {
	      for (d = '<ul class="' + b.options.dotsClass + '">', c = 0; c <= b.getDotCount(); c += 1) {
	        d += "<li>" + b.options.customPaging.call(this, b, c) + "</li>";
	      }d += "</ul>", b.$dots = a(d).appendTo(b.options.appendDots), b.$dots.find("li").first().addClass("slick-active").attr("aria-hidden", "false");
	    }
	  }, b.prototype.buildOut = function () {
	    var b = this;b.$slides = b.$slider.children(b.options.slide + ":not(.slick-cloned)").addClass("slick-slide"), b.slideCount = b.$slides.length, b.$slides.each(function (b, c) {
	      a(c).attr("data-slick-index", b).data("originalStyling", a(c).attr("style") || "");
	    }), b.$slider.addClass("slick-slider"), b.$slideTrack = 0 === b.slideCount ? a('<div class="slick-track"/>').appendTo(b.$slider) : b.$slides.wrapAll('<div class="slick-track"/>').parent(), b.$list = b.$slideTrack.wrap('<div aria-live="polite" class="slick-list"/>').parent(), b.$slideTrack.css("opacity", 0), (b.options.centerMode === !0 || b.options.swipeToSlide === !0) && (b.options.slidesToScroll = 1), a("img[data-lazy]", b.$slider).not("[src]").addClass("slick-loading"), b.setupInfinite(), b.buildArrows(), b.buildDots(), b.updateDots(), b.setSlideClasses("number" == typeof b.currentSlide ? b.currentSlide : 0), b.options.draggable === !0 && b.$list.addClass("draggable");
	  }, b.prototype.buildRows = function () {
	    var b,
	        c,
	        d,
	        e,
	        f,
	        g,
	        h,
	        a = this;if (e = document.createDocumentFragment(), g = a.$slider.children(), a.options.rows > 1) {
	      for (h = a.options.slidesPerRow * a.options.rows, f = Math.ceil(g.length / h), b = 0; f > b; b++) {
	        var i = document.createElement("div");for (c = 0; c < a.options.rows; c++) {
	          var j = document.createElement("div");for (d = 0; d < a.options.slidesPerRow; d++) {
	            var k = b * h + (c * a.options.slidesPerRow + d);g.get(k) && j.appendChild(g.get(k));
	          }i.appendChild(j);
	        }e.appendChild(i);
	      }a.$slider.html(e), a.$slider.children().children().children().css({ width: 100 / a.options.slidesPerRow + "%", display: "inline-block" });
	    }
	  }, b.prototype.checkResponsive = function (b, c) {
	    var e,
	        f,
	        g,
	        d = this,
	        h = !1,
	        i = d.$slider.width(),
	        j = window.innerWidth || a(window).width();if ("window" === d.respondTo ? g = j : "slider" === d.respondTo ? g = i : "min" === d.respondTo && (g = Math.min(j, i)), d.options.responsive && d.options.responsive.length && null !== d.options.responsive) {
	      f = null;for (e in d.breakpoints) {
	        d.breakpoints.hasOwnProperty(e) && (d.originalSettings.mobileFirst === !1 ? g < d.breakpoints[e] && (f = d.breakpoints[e]) : g > d.breakpoints[e] && (f = d.breakpoints[e]));
	      }null !== f ? null !== d.activeBreakpoint ? (f !== d.activeBreakpoint || c) && (d.activeBreakpoint = f, "unslick" === d.breakpointSettings[f] ? d.unslick(f) : (d.options = a.extend({}, d.originalSettings, d.breakpointSettings[f]), b === !0 && (d.currentSlide = d.options.initialSlide), d.refresh(b)), h = f) : (d.activeBreakpoint = f, "unslick" === d.breakpointSettings[f] ? d.unslick(f) : (d.options = a.extend({}, d.originalSettings, d.breakpointSettings[f]), b === !0 && (d.currentSlide = d.options.initialSlide), d.refresh(b)), h = f) : null !== d.activeBreakpoint && (d.activeBreakpoint = null, d.options = d.originalSettings, b === !0 && (d.currentSlide = d.options.initialSlide), d.refresh(b), h = f), b || h === !1 || d.$slider.trigger("breakpoint", [d, h]);
	    }
	  }, b.prototype.changeSlide = function (b, c) {
	    var f,
	        g,
	        h,
	        d = this,
	        e = a(b.target);switch (e.is("a") && b.preventDefault(), e.is("li") || (e = e.closest("li")), h = d.slideCount % d.options.slidesToScroll !== 0, f = h ? 0 : (d.slideCount - d.currentSlide) % d.options.slidesToScroll, b.data.message) {case "previous":
	        g = 0 === f ? d.options.slidesToScroll : d.options.slidesToShow - f, d.slideCount > d.options.slidesToShow && d.slideHandler(d.currentSlide - g, !1, c);break;case "next":
	        g = 0 === f ? d.options.slidesToScroll : f, d.slideCount > d.options.slidesToShow && d.slideHandler(d.currentSlide + g, !1, c);break;case "index":
	        var i = 0 === b.data.index ? 0 : b.data.index || e.index() * d.options.slidesToScroll;d.slideHandler(d.checkNavigable(i), !1, c), e.children().trigger("focus");break;default:
	        return;}
	  }, b.prototype.checkNavigable = function (a) {
	    var c,
	        d,
	        b = this;if (c = b.getNavigableIndexes(), d = 0, a > c[c.length - 1]) a = c[c.length - 1];else for (var e in c) {
	      if (a < c[e]) {
	        a = d;break;
	      }d = c[e];
	    }return a;
	  }, b.prototype.cleanUpEvents = function () {
	    var b = this;b.options.dots && null !== b.$dots && (a("li", b.$dots).off("click.slick", b.changeSlide), b.options.pauseOnDotsHover === !0 && b.options.autoplay === !0 && a("li", b.$dots).off("mouseenter.slick", a.proxy(b.setPaused, b, !0)).off("mouseleave.slick", a.proxy(b.setPaused, b, !1))), b.options.arrows === !0 && b.slideCount > b.options.slidesToShow && (b.$prevArrow && b.$prevArrow.off("click.slick", b.changeSlide), b.$nextArrow && b.$nextArrow.off("click.slick", b.changeSlide)), b.$list.off("touchstart.slick mousedown.slick", b.swipeHandler), b.$list.off("touchmove.slick mousemove.slick", b.swipeHandler), b.$list.off("touchend.slick mouseup.slick", b.swipeHandler), b.$list.off("touchcancel.slick mouseleave.slick", b.swipeHandler), b.$list.off("click.slick", b.clickHandler), a(document).off(b.visibilityChange, b.visibility), b.$list.off("mouseenter.slick", a.proxy(b.setPaused, b, !0)), b.$list.off("mouseleave.slick", a.proxy(b.setPaused, b, !1)), b.options.accessibility === !0 && b.$list.off("keydown.slick", b.keyHandler), b.options.focusOnSelect === !0 && a(b.$slideTrack).children().off("click.slick", b.selectHandler), a(window).off("orientationchange.slick.slick-" + b.instanceUid, b.orientationChange), a(window).off("resize.slick.slick-" + b.instanceUid, b.resize), a("[draggable!=true]", b.$slideTrack).off("dragstart", b.preventDefault), a(window).off("load.slick.slick-" + b.instanceUid, b.setPosition), a(document).off("ready.slick.slick-" + b.instanceUid, b.setPosition);
	  }, b.prototype.cleanUpRows = function () {
	    var b,
	        a = this;a.options.rows > 1 && (b = a.$slides.children().children(), b.removeAttr("style"), a.$slider.html(b));
	  }, b.prototype.clickHandler = function (a) {
	    var b = this;b.shouldClick === !1 && (a.stopImmediatePropagation(), a.stopPropagation(), a.preventDefault());
	  }, b.prototype.destroy = function (b) {
	    var c = this;c.autoPlayClear(), c.touchObject = {}, c.cleanUpEvents(), a(".slick-cloned", c.$slider).detach(), c.$dots && c.$dots.remove(), c.$prevArrow && c.$prevArrow.length && (c.$prevArrow.removeClass("slick-disabled slick-arrow slick-hidden").removeAttr("aria-hidden aria-disabled tabindex").css("display", ""), c.htmlExpr.test(c.options.prevArrow) && c.$prevArrow.remove()), c.$nextArrow && c.$nextArrow.length && (c.$nextArrow.removeClass("slick-disabled slick-arrow slick-hidden").removeAttr("aria-hidden aria-disabled tabindex").css("display", ""), c.htmlExpr.test(c.options.nextArrow) && c.$nextArrow.remove()), c.$slides && (c.$slides.removeClass("slick-slide slick-active slick-center slick-visible slick-current").removeAttr("aria-hidden").removeAttr("data-slick-index").each(function () {
	      a(this).attr("style", a(this).data("originalStyling"));
	    }), c.$slideTrack.children(this.options.slide).detach(), c.$slideTrack.detach(), c.$list.detach(), c.$slider.append(c.$slides)), c.cleanUpRows(), c.$slider.removeClass("slick-slider"), c.$slider.removeClass("slick-initialized"), c.unslicked = !0, b || c.$slider.trigger("destroy", [c]);
	  }, b.prototype.disableTransition = function (a) {
	    var b = this,
	        c = {};c[b.transitionType] = "", b.options.fade === !1 ? b.$slideTrack.css(c) : b.$slides.eq(a).css(c);
	  }, b.prototype.fadeSlide = function (a, b) {
	    var c = this;c.cssTransitions === !1 ? (c.$slides.eq(a).css({ zIndex: c.options.zIndex }), c.$slides.eq(a).animate({ opacity: 1 }, c.options.speed, c.options.easing, b)) : (c.applyTransition(a), c.$slides.eq(a).css({ opacity: 1, zIndex: c.options.zIndex }), b && setTimeout(function () {
	      c.disableTransition(a), b.call();
	    }, c.options.speed));
	  }, b.prototype.fadeSlideOut = function (a) {
	    var b = this;b.cssTransitions === !1 ? b.$slides.eq(a).animate({ opacity: 0, zIndex: b.options.zIndex - 2 }, b.options.speed, b.options.easing) : (b.applyTransition(a), b.$slides.eq(a).css({ opacity: 0, zIndex: b.options.zIndex - 2 }));
	  }, b.prototype.filterSlides = b.prototype.slickFilter = function (a) {
	    var b = this;null !== a && (b.$slidesCache = b.$slides, b.unload(), b.$slideTrack.children(this.options.slide).detach(), b.$slidesCache.filter(a).appendTo(b.$slideTrack), b.reinit());
	  }, b.prototype.getCurrent = b.prototype.slickCurrentSlide = function () {
	    var a = this;return a.currentSlide;
	  }, b.prototype.getDotCount = function () {
	    var a = this,
	        b = 0,
	        c = 0,
	        d = 0;if (a.options.infinite === !0) for (; b < a.slideCount;) {
	      ++d, b = c + a.options.slidesToScroll, c += a.options.slidesToScroll <= a.options.slidesToShow ? a.options.slidesToScroll : a.options.slidesToShow;
	    } else if (a.options.centerMode === !0) d = a.slideCount;else for (; b < a.slideCount;) {
	      ++d, b = c + a.options.slidesToScroll, c += a.options.slidesToScroll <= a.options.slidesToShow ? a.options.slidesToScroll : a.options.slidesToShow;
	    }return d - 1;
	  }, b.prototype.getLeft = function (a) {
	    var c,
	        d,
	        f,
	        b = this,
	        e = 0;return b.slideOffset = 0, d = b.$slides.first().outerHeight(!0), b.options.infinite === !0 ? (b.slideCount > b.options.slidesToShow && (b.slideOffset = b.slideWidth * b.options.slidesToShow * -1, e = d * b.options.slidesToShow * -1), b.slideCount % b.options.slidesToScroll !== 0 && a + b.options.slidesToScroll > b.slideCount && b.slideCount > b.options.slidesToShow && (a > b.slideCount ? (b.slideOffset = (b.options.slidesToShow - (a - b.slideCount)) * b.slideWidth * -1, e = (b.options.slidesToShow - (a - b.slideCount)) * d * -1) : (b.slideOffset = b.slideCount % b.options.slidesToScroll * b.slideWidth * -1, e = b.slideCount % b.options.slidesToScroll * d * -1))) : a + b.options.slidesToShow > b.slideCount && (b.slideOffset = (a + b.options.slidesToShow - b.slideCount) * b.slideWidth, e = (a + b.options.slidesToShow - b.slideCount) * d), b.slideCount <= b.options.slidesToShow && (b.slideOffset = 0, e = 0), b.options.centerMode === !0 && b.options.infinite === !0 ? b.slideOffset += b.slideWidth * Math.floor(b.options.slidesToShow / 2) - b.slideWidth : b.options.centerMode === !0 && (b.slideOffset = 0, b.slideOffset += b.slideWidth * Math.floor(b.options.slidesToShow / 2)), c = b.options.vertical === !1 ? a * b.slideWidth * -1 + b.slideOffset : a * d * -1 + e, b.options.variableWidth === !0 && (f = b.slideCount <= b.options.slidesToShow || b.options.infinite === !1 ? b.$slideTrack.children(".slick-slide").eq(a) : b.$slideTrack.children(".slick-slide").eq(a + b.options.slidesToShow), c = b.options.rtl === !0 ? f[0] ? -1 * (b.$slideTrack.width() - f[0].offsetLeft - f.width()) : 0 : f[0] ? -1 * f[0].offsetLeft : 0, b.options.centerMode === !0 && (f = b.slideCount <= b.options.slidesToShow || b.options.infinite === !1 ? b.$slideTrack.children(".slick-slide").eq(a) : b.$slideTrack.children(".slick-slide").eq(a + b.options.slidesToShow + 1), c = b.options.rtl === !0 ? f[0] ? -1 * (b.$slideTrack.width() - f[0].offsetLeft - f.width()) : 0 : f[0] ? -1 * f[0].offsetLeft : 0, c += (b.$list.width() - f.outerWidth()) / 2)), c;
	  }, b.prototype.getOption = b.prototype.slickGetOption = function (a) {
	    var b = this;return b.options[a];
	  }, b.prototype.getNavigableIndexes = function () {
	    var e,
	        a = this,
	        b = 0,
	        c = 0,
	        d = [];for (a.options.infinite === !1 ? e = a.slideCount : (b = -1 * a.options.slidesToScroll, c = -1 * a.options.slidesToScroll, e = 2 * a.slideCount); e > b;) {
	      d.push(b), b = c + a.options.slidesToScroll, c += a.options.slidesToScroll <= a.options.slidesToShow ? a.options.slidesToScroll : a.options.slidesToShow;
	    }return d;
	  }, b.prototype.getSlick = function () {
	    return this;
	  }, b.prototype.getSlideCount = function () {
	    var c,
	        d,
	        e,
	        b = this;return e = b.options.centerMode === !0 ? b.slideWidth * Math.floor(b.options.slidesToShow / 2) : 0, b.options.swipeToSlide === !0 ? (b.$slideTrack.find(".slick-slide").each(function (c, f) {
	      return f.offsetLeft - e + a(f).outerWidth() / 2 > -1 * b.swipeLeft ? (d = f, !1) : void 0;
	    }), c = Math.abs(a(d).attr("data-slick-index") - b.currentSlide) || 1) : b.options.slidesToScroll;
	  }, b.prototype.goTo = b.prototype.slickGoTo = function (a, b) {
	    var c = this;c.changeSlide({ data: { message: "index", index: parseInt(a) } }, b);
	  }, b.prototype.init = function (b) {
	    var c = this;a(c.$slider).hasClass("slick-initialized") || (a(c.$slider).addClass("slick-initialized"), c.buildRows(), c.buildOut(), c.setProps(), c.startLoad(), c.loadSlider(), c.initializeEvents(), c.updateArrows(), c.updateDots()), b && c.$slider.trigger("init", [c]), c.options.accessibility === !0 && c.initADA();
	  }, b.prototype.initArrowEvents = function () {
	    var a = this;a.options.arrows === !0 && a.slideCount > a.options.slidesToShow && (a.$prevArrow.on("click.slick", { message: "previous" }, a.changeSlide), a.$nextArrow.on("click.slick", { message: "next" }, a.changeSlide));
	  }, b.prototype.initDotEvents = function () {
	    var b = this;b.options.dots === !0 && b.slideCount > b.options.slidesToShow && a("li", b.$dots).on("click.slick", { message: "index" }, b.changeSlide), b.options.dots === !0 && b.options.pauseOnDotsHover === !0 && b.options.autoplay === !0 && a("li", b.$dots).on("mouseenter.slick", a.proxy(b.setPaused, b, !0)).on("mouseleave.slick", a.proxy(b.setPaused, b, !1));
	  }, b.prototype.initializeEvents = function () {
	    var b = this;b.initArrowEvents(), b.initDotEvents(), b.$list.on("touchstart.slick mousedown.slick", { action: "start" }, b.swipeHandler), b.$list.on("touchmove.slick mousemove.slick", { action: "move" }, b.swipeHandler), b.$list.on("touchend.slick mouseup.slick", { action: "end" }, b.swipeHandler), b.$list.on("touchcancel.slick mouseleave.slick", { action: "end" }, b.swipeHandler), b.$list.on("click.slick", b.clickHandler), a(document).on(b.visibilityChange, a.proxy(b.visibility, b)), b.$list.on("mouseenter.slick", a.proxy(b.setPaused, b, !0)), b.$list.on("mouseleave.slick", a.proxy(b.setPaused, b, !1)), b.options.accessibility === !0 && b.$list.on("keydown.slick", b.keyHandler), b.options.focusOnSelect === !0 && a(b.$slideTrack).children().on("click.slick", b.selectHandler), a(window).on("orientationchange.slick.slick-" + b.instanceUid, a.proxy(b.orientationChange, b)), a(window).on("resize.slick.slick-" + b.instanceUid, a.proxy(b.resize, b)), a("[draggable!=true]", b.$slideTrack).on("dragstart", b.preventDefault), a(window).on("load.slick.slick-" + b.instanceUid, b.setPosition), a(document).on("ready.slick.slick-" + b.instanceUid, b.setPosition);
	  }, b.prototype.initUI = function () {
	    var a = this;a.options.arrows === !0 && a.slideCount > a.options.slidesToShow && (a.$prevArrow.show(), a.$nextArrow.show()), a.options.dots === !0 && a.slideCount > a.options.slidesToShow && a.$dots.show(), a.options.autoplay === !0 && a.autoPlay();
	  }, b.prototype.keyHandler = function (a) {
	    var b = this;a.target.tagName.match("TEXTAREA|INPUT|SELECT") || (37 === a.keyCode && b.options.accessibility === !0 ? b.changeSlide({ data: { message: "previous" } }) : 39 === a.keyCode && b.options.accessibility === !0 && b.changeSlide({ data: { message: "next" } }));
	  }, b.prototype.lazyLoad = function () {
	    function g(b) {
	      a("img[data-lazy]", b).each(function () {
	        var b = a(this),
	            c = a(this).attr("data-lazy"),
	            d = document.createElement("img");d.onload = function () {
	          b.animate({ opacity: 0 }, 100, function () {
	            b.attr("src", c).animate({ opacity: 1 }, 200, function () {
	              b.removeAttr("data-lazy").removeClass("slick-loading");
	            });
	          });
	        }, d.src = c;
	      });
	    }var c,
	        d,
	        e,
	        f,
	        b = this;b.options.centerMode === !0 ? b.options.infinite === !0 ? (e = b.currentSlide + (b.options.slidesToShow / 2 + 1), f = e + b.options.slidesToShow + 2) : (e = Math.max(0, b.currentSlide - (b.options.slidesToShow / 2 + 1)), f = 2 + (b.options.slidesToShow / 2 + 1) + b.currentSlide) : (e = b.options.infinite ? b.options.slidesToShow + b.currentSlide : b.currentSlide, f = e + b.options.slidesToShow, b.options.fade === !0 && (e > 0 && e--, f <= b.slideCount && f++)), c = b.$slider.find(".slick-slide").slice(e, f), g(c), b.slideCount <= b.options.slidesToShow ? (d = b.$slider.find(".slick-slide"), g(d)) : b.currentSlide >= b.slideCount - b.options.slidesToShow ? (d = b.$slider.find(".slick-cloned").slice(0, b.options.slidesToShow), g(d)) : 0 === b.currentSlide && (d = b.$slider.find(".slick-cloned").slice(-1 * b.options.slidesToShow), g(d));
	  }, b.prototype.loadSlider = function () {
	    var a = this;a.setPosition(), a.$slideTrack.css({ opacity: 1 }), a.$slider.removeClass("slick-loading"), a.initUI(), "progressive" === a.options.lazyLoad && a.progressiveLazyLoad();
	  }, b.prototype.next = b.prototype.slickNext = function () {
	    var a = this;a.changeSlide({ data: { message: "next" } });
	  }, b.prototype.orientationChange = function () {
	    var a = this;a.checkResponsive(), a.setPosition();
	  }, b.prototype.pause = b.prototype.slickPause = function () {
	    var a = this;a.autoPlayClear(), a.paused = !0;
	  }, b.prototype.play = b.prototype.slickPlay = function () {
	    var a = this;a.paused = !1, a.autoPlay();
	  }, b.prototype.postSlide = function (a) {
	    var b = this;b.$slider.trigger("afterChange", [b, a]), b.animating = !1, b.setPosition(), b.swipeLeft = null, b.options.autoplay === !0 && b.paused === !1 && b.autoPlay(), b.options.accessibility === !0 && b.initADA();
	  }, b.prototype.prev = b.prototype.slickPrev = function () {
	    var a = this;a.changeSlide({ data: { message: "previous" } });
	  }, b.prototype.preventDefault = function (a) {
	    a.preventDefault();
	  }, b.prototype.progressiveLazyLoad = function () {
	    var c,
	        d,
	        b = this;c = a("img[data-lazy]", b.$slider).length, c > 0 && (d = a("img[data-lazy]", b.$slider).first(), d.attr("src", null), d.attr("src", d.attr("data-lazy")).removeClass("slick-loading").load(function () {
	      d.removeAttr("data-lazy"), b.progressiveLazyLoad(), b.options.adaptiveHeight === !0 && b.setPosition();
	    }).error(function () {
	      d.removeAttr("data-lazy"), b.progressiveLazyLoad();
	    }));
	  }, b.prototype.refresh = function (b) {
	    var d,
	        e,
	        c = this;e = c.slideCount - c.options.slidesToShow, c.options.infinite || (c.slideCount <= c.options.slidesToShow ? c.currentSlide = 0 : c.currentSlide > e && (c.currentSlide = e)), d = c.currentSlide, c.destroy(!0), a.extend(c, c.initials, { currentSlide: d }), c.init(), b || c.changeSlide({ data: { message: "index", index: d } }, !1);
	  }, b.prototype.registerBreakpoints = function () {
	    var c,
	        d,
	        e,
	        b = this,
	        f = b.options.responsive || null;if ("array" === a.type(f) && f.length) {
	      b.respondTo = b.options.respondTo || "window";for (c in f) {
	        if (e = b.breakpoints.length - 1, d = f[c].breakpoint, f.hasOwnProperty(c)) {
	          for (; e >= 0;) {
	            b.breakpoints[e] && b.breakpoints[e] === d && b.breakpoints.splice(e, 1), e--;
	          }b.breakpoints.push(d), b.breakpointSettings[d] = f[c].settings;
	        }
	      }b.breakpoints.sort(function (a, c) {
	        return b.options.mobileFirst ? a - c : c - a;
	      });
	    }
	  }, b.prototype.reinit = function () {
	    var b = this;b.$slides = b.$slideTrack.children(b.options.slide).addClass("slick-slide"), b.slideCount = b.$slides.length, b.currentSlide >= b.slideCount && 0 !== b.currentSlide && (b.currentSlide = b.currentSlide - b.options.slidesToScroll), b.slideCount <= b.options.slidesToShow && (b.currentSlide = 0), b.registerBreakpoints(), b.setProps(), b.setupInfinite(), b.buildArrows(), b.updateArrows(), b.initArrowEvents(), b.buildDots(), b.updateDots(), b.initDotEvents(), b.checkResponsive(!1, !0), b.options.focusOnSelect === !0 && a(b.$slideTrack).children().on("click.slick", b.selectHandler), b.setSlideClasses(0), b.setPosition(), b.$slider.trigger("reInit", [b]), b.options.autoplay === !0 && b.focusHandler();
	  }, b.prototype.resize = function () {
	    var b = this;a(window).width() !== b.windowWidth && (clearTimeout(b.windowDelay), b.windowDelay = window.setTimeout(function () {
	      b.windowWidth = a(window).width(), b.checkResponsive(), b.unslicked || b.setPosition();
	    }, 50));
	  }, b.prototype.removeSlide = b.prototype.slickRemove = function (a, b, c) {
	    var d = this;return "boolean" == typeof a ? (b = a, a = b === !0 ? 0 : d.slideCount - 1) : a = b === !0 ? --a : a, d.slideCount < 1 || 0 > a || a > d.slideCount - 1 ? !1 : (d.unload(), c === !0 ? d.$slideTrack.children().remove() : d.$slideTrack.children(this.options.slide).eq(a).remove(), d.$slides = d.$slideTrack.children(this.options.slide), d.$slideTrack.children(this.options.slide).detach(), d.$slideTrack.append(d.$slides), d.$slidesCache = d.$slides, void d.reinit());
	  }, b.prototype.setCSS = function (a) {
	    var d,
	        e,
	        b = this,
	        c = {};b.options.rtl === !0 && (a = -a), d = "left" == b.positionProp ? Math.ceil(a) + "px" : "0px", e = "top" == b.positionProp ? Math.ceil(a) + "px" : "0px", c[b.positionProp] = a, b.transformsEnabled === !1 ? b.$slideTrack.css(c) : (c = {}, b.cssTransitions === !1 ? (c[b.animType] = "translate(" + d + ", " + e + ")", b.$slideTrack.css(c)) : (c[b.animType] = "translate3d(" + d + ", " + e + ", 0px)", b.$slideTrack.css(c)));
	  }, b.prototype.setDimensions = function () {
	    var a = this;a.options.vertical === !1 ? a.options.centerMode === !0 && a.$list.css({ padding: "0px " + a.options.centerPadding }) : (a.$list.height(a.$slides.first().outerHeight(!0) * a.options.slidesToShow), a.options.centerMode === !0 && a.$list.css({ padding: a.options.centerPadding + " 0px" })), a.listWidth = a.$list.width(), a.listHeight = a.$list.height(), a.options.vertical === !1 && a.options.variableWidth === !1 ? (a.slideWidth = Math.ceil(a.listWidth / a.options.slidesToShow), a.$slideTrack.width(Math.ceil(a.slideWidth * a.$slideTrack.children(".slick-slide").length))) : a.options.variableWidth === !0 ? a.$slideTrack.width(5e3 * a.slideCount) : (a.slideWidth = Math.ceil(a.listWidth), a.$slideTrack.height(Math.ceil(a.$slides.first().outerHeight(!0) * a.$slideTrack.children(".slick-slide").length)));var b = a.$slides.first().outerWidth(!0) - a.$slides.first().width();a.options.variableWidth === !1 && a.$slideTrack.children(".slick-slide").width(a.slideWidth - b);
	  }, b.prototype.setFade = function () {
	    var c,
	        b = this;b.$slides.each(function (d, e) {
	      c = b.slideWidth * d * -1, b.options.rtl === !0 ? a(e).css({ position: "relative", right: c, top: 0, zIndex: b.options.zIndex - 2, opacity: 0 }) : a(e).css({ position: "relative", left: c, top: 0, zIndex: b.options.zIndex - 2, opacity: 0 });
	    }), b.$slides.eq(b.currentSlide).css({ zIndex: b.options.zIndex - 1, opacity: 1 });
	  }, b.prototype.setHeight = function () {
	    var a = this;if (1 === a.options.slidesToShow && a.options.adaptiveHeight === !0 && a.options.vertical === !1) {
	      var b = a.$slides.eq(a.currentSlide).outerHeight(!0);a.$list.css("height", b);
	    }
	  }, b.prototype.setOption = b.prototype.slickSetOption = function (b, c, d) {
	    var f,
	        g,
	        e = this;if ("responsive" === b && "array" === a.type(c)) for (g in c) {
	      if ("array" !== a.type(e.options.responsive)) e.options.responsive = [c[g]];else {
	        for (f = e.options.responsive.length - 1; f >= 0;) {
	          e.options.responsive[f].breakpoint === c[g].breakpoint && e.options.responsive.splice(f, 1), f--;
	        }e.options.responsive.push(c[g]);
	      }
	    } else e.options[b] = c;d === !0 && (e.unload(), e.reinit());
	  }, b.prototype.setPosition = function () {
	    var a = this;a.setDimensions(), a.setHeight(), a.options.fade === !1 ? a.setCSS(a.getLeft(a.currentSlide)) : a.setFade(), a.$slider.trigger("setPosition", [a]);
	  }, b.prototype.setProps = function () {
	    var a = this,
	        b = document.body.style;a.positionProp = a.options.vertical === !0 ? "top" : "left", "top" === a.positionProp ? a.$slider.addClass("slick-vertical") : a.$slider.removeClass("slick-vertical"), (void 0 !== b.WebkitTransition || void 0 !== b.MozTransition || void 0 !== b.msTransition) && a.options.useCSS === !0 && (a.cssTransitions = !0), a.options.fade && ("number" == typeof a.options.zIndex ? a.options.zIndex < 3 && (a.options.zIndex = 3) : a.options.zIndex = a.defaults.zIndex), void 0 !== b.OTransform && (a.animType = "OTransform", a.transformType = "-o-transform", a.transitionType = "OTransition", void 0 === b.perspectiveProperty && void 0 === b.webkitPerspective && (a.animType = !1)), void 0 !== b.MozTransform && (a.animType = "MozTransform", a.transformType = "-moz-transform", a.transitionType = "MozTransition", void 0 === b.perspectiveProperty && void 0 === b.MozPerspective && (a.animType = !1)), void 0 !== b.webkitTransform && (a.animType = "webkitTransform", a.transformType = "-webkit-transform", a.transitionType = "webkitTransition", void 0 === b.perspectiveProperty && void 0 === b.webkitPerspective && (a.animType = !1)), void 0 !== b.msTransform && (a.animType = "msTransform", a.transformType = "-ms-transform", a.transitionType = "msTransition", void 0 === b.msTransform && (a.animType = !1)), void 0 !== b.transform && a.animType !== !1 && (a.animType = "transform", a.transformType = "transform", a.transitionType = "transition"), a.transformsEnabled = a.options.useTransform && null !== a.animType && a.animType !== !1;
	  }, b.prototype.setSlideClasses = function (a) {
	    var c,
	        d,
	        e,
	        f,
	        b = this;d = b.$slider.find(".slick-slide").removeClass("slick-active slick-center slick-current").attr("aria-hidden", "true"), b.$slides.eq(a).addClass("slick-current"), b.options.centerMode === !0 ? (c = Math.floor(b.options.slidesToShow / 2), b.options.infinite === !0 && (a >= c && a <= b.slideCount - 1 - c ? b.$slides.slice(a - c, a + c + 1).addClass("slick-active").attr("aria-hidden", "false") : (e = b.options.slidesToShow + a, d.slice(e - c + 1, e + c + 2).addClass("slick-active").attr("aria-hidden", "false")), 0 === a ? d.eq(d.length - 1 - b.options.slidesToShow).addClass("slick-center") : a === b.slideCount - 1 && d.eq(b.options.slidesToShow).addClass("slick-center")), b.$slides.eq(a).addClass("slick-center")) : a >= 0 && a <= b.slideCount - b.options.slidesToShow ? b.$slides.slice(a, a + b.options.slidesToShow).addClass("slick-active").attr("aria-hidden", "false") : d.length <= b.options.slidesToShow ? d.addClass("slick-active").attr("aria-hidden", "false") : (f = b.slideCount % b.options.slidesToShow, e = b.options.infinite === !0 ? b.options.slidesToShow + a : a, b.options.slidesToShow == b.options.slidesToScroll && b.slideCount - a < b.options.slidesToShow ? d.slice(e - (b.options.slidesToShow - f), e + f).addClass("slick-active").attr("aria-hidden", "false") : d.slice(e, e + b.options.slidesToShow).addClass("slick-active").attr("aria-hidden", "false")), "ondemand" === b.options.lazyLoad && b.lazyLoad();
	  }, b.prototype.setupInfinite = function () {
	    var c,
	        d,
	        e,
	        b = this;if (b.options.fade === !0 && (b.options.centerMode = !1), b.options.infinite === !0 && b.options.fade === !1 && (d = null, b.slideCount > b.options.slidesToShow)) {
	      for (e = b.options.centerMode === !0 ? b.options.slidesToShow + 1 : b.options.slidesToShow, c = b.slideCount; c > b.slideCount - e; c -= 1) {
	        d = c - 1, a(b.$slides[d]).clone(!0).attr("id", "").attr("data-slick-index", d - b.slideCount).prependTo(b.$slideTrack).addClass("slick-cloned");
	      }for (c = 0; e > c; c += 1) {
	        d = c, a(b.$slides[d]).clone(!0).attr("id", "").attr("data-slick-index", d + b.slideCount).appendTo(b.$slideTrack).addClass("slick-cloned");
	      }b.$slideTrack.find(".slick-cloned").find("[id]").each(function () {
	        a(this).attr("id", "");
	      });
	    }
	  }, b.prototype.setPaused = function (a) {
	    var b = this;b.options.autoplay === !0 && b.options.pauseOnHover === !0 && (b.paused = a, a ? b.autoPlayClear() : b.autoPlay());
	  }, b.prototype.selectHandler = function (b) {
	    var c = this,
	        d = a(b.target).is(".slick-slide") ? a(b.target) : a(b.target).parents(".slick-slide"),
	        e = parseInt(d.attr("data-slick-index"));return e || (e = 0), c.slideCount <= c.options.slidesToShow ? (c.setSlideClasses(e), void c.asNavFor(e)) : void c.slideHandler(e);
	  }, b.prototype.slideHandler = function (a, b, c) {
	    var d,
	        e,
	        f,
	        g,
	        h = null,
	        i = this;return b = b || !1, i.animating === !0 && i.options.waitForAnimate === !0 || i.options.fade === !0 && i.currentSlide === a || i.slideCount <= i.options.slidesToShow ? void 0 : (b === !1 && i.asNavFor(a), d = a, h = i.getLeft(d), g = i.getLeft(i.currentSlide), i.currentLeft = null === i.swipeLeft ? g : i.swipeLeft, i.options.infinite === !1 && i.options.centerMode === !1 && (0 > a || a > i.getDotCount() * i.options.slidesToScroll) ? void (i.options.fade === !1 && (d = i.currentSlide, c !== !0 ? i.animateSlide(g, function () {
	      i.postSlide(d);
	    }) : i.postSlide(d))) : i.options.infinite === !1 && i.options.centerMode === !0 && (0 > a || a > i.slideCount - i.options.slidesToScroll) ? void (i.options.fade === !1 && (d = i.currentSlide, c !== !0 ? i.animateSlide(g, function () {
	      i.postSlide(d);
	    }) : i.postSlide(d))) : (i.options.autoplay === !0 && clearInterval(i.autoPlayTimer), e = 0 > d ? i.slideCount % i.options.slidesToScroll !== 0 ? i.slideCount - i.slideCount % i.options.slidesToScroll : i.slideCount + d : d >= i.slideCount ? i.slideCount % i.options.slidesToScroll !== 0 ? 0 : d - i.slideCount : d, i.animating = !0, i.$slider.trigger("beforeChange", [i, i.currentSlide, e]), f = i.currentSlide, i.currentSlide = e, i.setSlideClasses(i.currentSlide), i.updateDots(), i.updateArrows(), i.options.fade === !0 ? (c !== !0 ? (i.fadeSlideOut(f), i.fadeSlide(e, function () {
	      i.postSlide(e);
	    })) : i.postSlide(e), void i.animateHeight()) : void (c !== !0 ? i.animateSlide(h, function () {
	      i.postSlide(e);
	    }) : i.postSlide(e))));
	  }, b.prototype.startLoad = function () {
	    var a = this;a.options.arrows === !0 && a.slideCount > a.options.slidesToShow && (a.$prevArrow.hide(), a.$nextArrow.hide()), a.options.dots === !0 && a.slideCount > a.options.slidesToShow && a.$dots.hide(), a.$slider.addClass("slick-loading");
	  }, b.prototype.swipeDirection = function () {
	    var a,
	        b,
	        c,
	        d,
	        e = this;return a = e.touchObject.startX - e.touchObject.curX, b = e.touchObject.startY - e.touchObject.curY, c = Math.atan2(b, a), d = Math.round(180 * c / Math.PI), 0 > d && (d = 360 - Math.abs(d)), 45 >= d && d >= 0 ? e.options.rtl === !1 ? "left" : "right" : 360 >= d && d >= 315 ? e.options.rtl === !1 ? "left" : "right" : d >= 135 && 225 >= d ? e.options.rtl === !1 ? "right" : "left" : e.options.verticalSwiping === !0 ? d >= 35 && 135 >= d ? "left" : "right" : "vertical";
	  }, b.prototype.swipeEnd = function (a) {
	    var c,
	        b = this;if (b.dragging = !1, b.shouldClick = b.touchObject.swipeLength > 10 ? !1 : !0, void 0 === b.touchObject.curX) return !1;if (b.touchObject.edgeHit === !0 && b.$slider.trigger("edge", [b, b.swipeDirection()]), b.touchObject.swipeLength >= b.touchObject.minSwipe) switch (b.swipeDirection()) {case "left":
	        c = b.options.swipeToSlide ? b.checkNavigable(b.currentSlide + b.getSlideCount()) : b.currentSlide + b.getSlideCount(), b.slideHandler(c), b.currentDirection = 0, b.touchObject = {}, b.$slider.trigger("swipe", [b, "left"]);break;case "right":
	        c = b.options.swipeToSlide ? b.checkNavigable(b.currentSlide - b.getSlideCount()) : b.currentSlide - b.getSlideCount(), b.slideHandler(c), b.currentDirection = 1, b.touchObject = {}, b.$slider.trigger("swipe", [b, "right"]);} else b.touchObject.startX !== b.touchObject.curX && (b.slideHandler(b.currentSlide), b.touchObject = {});
	  }, b.prototype.swipeHandler = function (a) {
	    var b = this;if (!(b.options.swipe === !1 || "ontouchend" in document && b.options.swipe === !1 || b.options.draggable === !1 && -1 !== a.type.indexOf("mouse"))) switch (b.touchObject.fingerCount = a.originalEvent && void 0 !== a.originalEvent.touches ? a.originalEvent.touches.length : 1, b.touchObject.minSwipe = b.listWidth / b.options.touchThreshold, b.options.verticalSwiping === !0 && (b.touchObject.minSwipe = b.listHeight / b.options.touchThreshold), a.data.action) {case "start":
	        b.swipeStart(a);break;case "move":
	        b.swipeMove(a);break;case "end":
	        b.swipeEnd(a);}
	  }, b.prototype.swipeMove = function (a) {
	    var d,
	        e,
	        f,
	        g,
	        h,
	        b = this;return h = void 0 !== a.originalEvent ? a.originalEvent.touches : null, !b.dragging || h && 1 !== h.length ? !1 : (d = b.getLeft(b.currentSlide), b.touchObject.curX = void 0 !== h ? h[0].pageX : a.clientX, b.touchObject.curY = void 0 !== h ? h[0].pageY : a.clientY, b.touchObject.swipeLength = Math.round(Math.sqrt(Math.pow(b.touchObject.curX - b.touchObject.startX, 2))), b.options.verticalSwiping === !0 && (b.touchObject.swipeLength = Math.round(Math.sqrt(Math.pow(b.touchObject.curY - b.touchObject.startY, 2)))), e = b.swipeDirection(), "vertical" !== e ? (void 0 !== a.originalEvent && b.touchObject.swipeLength > 4 && a.preventDefault(), g = (b.options.rtl === !1 ? 1 : -1) * (b.touchObject.curX > b.touchObject.startX ? 1 : -1), b.options.verticalSwiping === !0 && (g = b.touchObject.curY > b.touchObject.startY ? 1 : -1), f = b.touchObject.swipeLength, b.touchObject.edgeHit = !1, b.options.infinite === !1 && (0 === b.currentSlide && "right" === e || b.currentSlide >= b.getDotCount() && "left" === e) && (f = b.touchObject.swipeLength * b.options.edgeFriction, b.touchObject.edgeHit = !0), b.options.vertical === !1 ? b.swipeLeft = d + f * g : b.swipeLeft = d + f * (b.$list.height() / b.listWidth) * g, b.options.verticalSwiping === !0 && (b.swipeLeft = d + f * g), b.options.fade === !0 || b.options.touchMove === !1 ? !1 : b.animating === !0 ? (b.swipeLeft = null, !1) : void b.setCSS(b.swipeLeft)) : void 0);
	  }, b.prototype.swipeStart = function (a) {
	    var c,
	        b = this;return 1 !== b.touchObject.fingerCount || b.slideCount <= b.options.slidesToShow ? (b.touchObject = {}, !1) : (void 0 !== a.originalEvent && void 0 !== a.originalEvent.touches && (c = a.originalEvent.touches[0]), b.touchObject.startX = b.touchObject.curX = void 0 !== c ? c.pageX : a.clientX, b.touchObject.startY = b.touchObject.curY = void 0 !== c ? c.pageY : a.clientY, void (b.dragging = !0));
	  }, b.prototype.unfilterSlides = b.prototype.slickUnfilter = function () {
	    var a = this;null !== a.$slidesCache && (a.unload(), a.$slideTrack.children(this.options.slide).detach(), a.$slidesCache.appendTo(a.$slideTrack), a.reinit());
	  }, b.prototype.unload = function () {
	    var b = this;a(".slick-cloned", b.$slider).remove(), b.$dots && b.$dots.remove(), b.$prevArrow && b.htmlExpr.test(b.options.prevArrow) && b.$prevArrow.remove(), b.$nextArrow && b.htmlExpr.test(b.options.nextArrow) && b.$nextArrow.remove(), b.$slides.removeClass("slick-slide slick-active slick-visible slick-current").attr("aria-hidden", "true").css("width", "");
	  }, b.prototype.unslick = function (a) {
	    var b = this;b.$slider.trigger("unslick", [b, a]), b.destroy();
	  }, b.prototype.updateArrows = function () {
	    var b,
	        a = this;b = Math.floor(a.options.slidesToShow / 2), a.options.arrows === !0 && a.slideCount > a.options.slidesToShow && !a.options.infinite && (a.$prevArrow.removeClass("slick-disabled").attr("aria-disabled", "false"), a.$nextArrow.removeClass("slick-disabled").attr("aria-disabled", "false"), 0 === a.currentSlide ? (a.$prevArrow.addClass("slick-disabled").attr("aria-disabled", "true"), a.$nextArrow.removeClass("slick-disabled").attr("aria-disabled", "false")) : a.currentSlide >= a.slideCount - a.options.slidesToShow && a.options.centerMode === !1 ? (a.$nextArrow.addClass("slick-disabled").attr("aria-disabled", "true"), a.$prevArrow.removeClass("slick-disabled").attr("aria-disabled", "false")) : a.currentSlide >= a.slideCount - 1 && a.options.centerMode === !0 && (a.$nextArrow.addClass("slick-disabled").attr("aria-disabled", "true"), a.$prevArrow.removeClass("slick-disabled").attr("aria-disabled", "false")));
	  }, b.prototype.updateDots = function () {
	    var a = this;null !== a.$dots && (a.$dots.find("li").removeClass("slick-active").attr("aria-hidden", "true"), a.$dots.find("li").eq(Math.floor(a.currentSlide / a.options.slidesToScroll)).addClass("slick-active").attr("aria-hidden", "false"));
	  }, b.prototype.visibility = function () {
	    var a = this;document[a.hidden] ? (a.paused = !0, a.autoPlayClear()) : a.options.autoplay === !0 && (a.paused = !1, a.autoPlay());
	  }, b.prototype.initADA = function () {
	    var b = this;b.$slides.add(b.$slideTrack.find(".slick-cloned")).attr({ "aria-hidden": "true", tabindex: "-1" }).find("a, input, button, select").attr({ tabindex: "-1" }), b.$slideTrack.attr("role", "listbox"), b.$slides.not(b.$slideTrack.find(".slick-cloned")).each(function (c) {
	      a(this).attr({ role: "option", "aria-describedby": "slick-slide" + b.instanceUid + c });
	    }), null !== b.$dots && b.$dots.attr("role", "tablist").find("li").each(function (c) {
	      a(this).attr({ role: "presentation", "aria-selected": "false", "aria-controls": "navigation" + b.instanceUid + c, id: "slick-slide" + b.instanceUid + c });
	    }).first().attr("aria-selected", "true").end().find("button").attr("role", "button").end().closest("div").attr("role", "toolbar"), b.activateADA();
	  }, b.prototype.activateADA = function () {
	    var a = this;a.$slideTrack.find(".slick-active").attr({ "aria-hidden": "false" }).find("a, input, button, select").attr({ tabindex: "0" });
	  }, b.prototype.focusHandler = function () {
	    var b = this;b.$slider.on("focus.slick blur.slick", "*", function (c) {
	      c.stopImmediatePropagation();var d = a(this);setTimeout(function () {
	        b.isPlay && (d.is(":focus") ? (b.autoPlayClear(), b.paused = !0) : (b.paused = !1, b.autoPlay()));
	      }, 0);
	    });
	  }, a.fn.slick = function () {
	    var f,
	        g,
	        a = this,
	        c = arguments[0],
	        d = Array.prototype.slice.call(arguments, 1),
	        e = a.length;for (f = 0; e > f; f++) {
	      if ("object" == (typeof c === "undefined" ? "undefined" : (0, _typeof3.default)(c)) || "undefined" == typeof c ? a[f].slick = new b(a[f], c) : g = a[f].slick[c].apply(a[f].slick, d), "undefined" != typeof g) return g;
	    }return a;
	  };
	});

/***/ },
/* 105 */
/***/ function(module, exports, __webpack_require__) {

	var require;var require;/* WEBPACK VAR INJECTION */(function(global, jQuery) {"use strict";
	
	var _typeof2 = __webpack_require__(4);
	
	var _typeof3 = _interopRequireDefault(_typeof2);
	
	var _assign = __webpack_require__(106);
	
	var _assign2 = _interopRequireDefault(_assign);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	(function e(t, n, r) {
	  function s(o, u) {
	    if (!n[o]) {
	      if (!t[o]) {
	        var a = typeof require == "function" && require;if (!u && a) return require(o, !0);if (i) return i(o, !0);var f = new Error("Cannot find module '" + o + "'");throw f.code = "MODULE_NOT_FOUND", f;
	      }var l = n[o] = { exports: {} };t[o][0].call(l.exports, function (e) {
	        var n = t[o][1][e];return s(n ? n : e);
	      }, l, l.exports, e, t, n, r);
	    }return n[o].exports;
	  }var i = typeof require == "function" && require;for (var o = 0; o < r.length; o++) {
	    s(r[o]);
	  }return s;
	})({ 1: [function (require, module, exports) {
	    (function (global) {
	
	      var ResizeSensor = require('css-element-queries/src/ResizeSensor');
	      var ResizeSensor = require('css-element-queries/src/ResizeSensor');
	      var Ps = require('perfect-scrollbar');
	      var ko = typeof window !== "undefined" ? window['ko'] : typeof global !== "undefined" ? global['ko'] : null;
	
	      function getOpts(acc) {
	        var opts = ko.unwrap(acc());
	        if (opts.x === undefined) opts.x = true;
	        if (opts.y === undefined) opts.y = true;
	        return opts;
	      }
	
	      function psOpts(opts) {
	        return {
	          suppressScrollX: !opts.x,
	          suppressScrollY: !opts.y
	        };
	      }
	
	      var scrollBinding = {
	        init: function init(element, valAcc, bindings, vm, ctx) {
	          var opts = getOpts(valAcc);
	          Ps.initialize(element, psOpts(opts));
	          var sensor = new ResizeSensor(element, function () {
	            Ps.update(element);
	          });
	          ko.utils.domNodeDisposal.addDisposeCallback(element, function () {
	            sensor.detach();
	            Ps.destroy(element);
	          });
	        },
	        update: function update(element, valAcc, bindings, vm, ctx) {
	          var opts = getOpts(valAcc);
	          if (ctx._firstUpdateComplete) {
	            Ps.destroy(element);
	            ko.bindingHandlers.scroll.init.apply(this, arguments);
	          }
	          (0, _assign2.default)(element.style, {
	            overflowX: opts.x ? 'scroll' : 'hidden',
	            overflowY: opts.y ? 'scroll' : 'hidden'
	          });
	          ctx._firstUpdateComplete = true;
	        }
	      };
	
	      module.exports = ko.bindingHandlers.scroll = scrollBinding;
	    }).call(this, typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
	  }, { "css-element-queries/src/ResizeSensor": 2, "perfect-scrollbar": 3 }], 2: [function (require, module, exports) {
	    /**
	     * Copyright Marc J. Schmidt. See the LICENSE file at the top-level
	     * directory of this distribution and at
	     * https://github.com/marcj/css-element-queries/blob/master/LICENSE.
	     */
	    ;
	    (function () {
	
	      /**
	       * Class for dimension change detection.
	       *
	       * @param {Element|Element[]|Elements|jQuery} element
	       * @param {Function} callback
	       *
	       * @constructor
	       */
	      var ResizeSensor = function ResizeSensor(element, callback) {
	        /**
	         *
	         * @constructor
	         */
	        function EventQueue() {
	          this.q = [];
	          this.add = function (ev) {
	            this.q.push(ev);
	          };
	
	          var i, j;
	          this.call = function () {
	            for (i = 0, j = this.q.length; i < j; i++) {
	              this.q[i].call();
	            }
	          };
	        }
	
	        /**
	         * @param {HTMLElement} element
	         * @param {String}      prop
	         * @returns {String|Number}
	         */
	        function getComputedStyle(element, prop) {
	          if (element.currentStyle) {
	            return element.currentStyle[prop];
	          } else if (window.getComputedStyle) {
	            return window.getComputedStyle(element, null).getPropertyValue(prop);
	          } else {
	            return element.style[prop];
	          }
	        }
	
	        /**
	         *
	         * @param {HTMLElement} element
	         * @param {Function}    resized
	         */
	        function attachResizeEvent(element, resized) {
	          if (!element.resizedAttached) {
	            element.resizedAttached = new EventQueue();
	            element.resizedAttached.add(resized);
	          } else if (element.resizedAttached) {
	            element.resizedAttached.add(resized);
	            return;
	          }
	
	          element.resizeSensor = document.createElement('div');
	          element.resizeSensor.className = 'resize-sensor';
	          var style = 'position: absolute; left: 0; top: 0; right: 0; bottom: 0; overflow: hidden; z-index: -1; visibility: hidden;';
	          var styleChild = 'position: absolute; left: 0; top: 0; transition: 0s;';
	
	          element.resizeSensor.style.cssText = style;
	          element.resizeSensor.innerHTML = '<div class="resize-sensor-expand" style="' + style + '">' + '<div style="' + styleChild + '"></div>' + '</div>' + '<div class="resize-sensor-shrink" style="' + style + '">' + '<div style="' + styleChild + ' width: 200%; height: 200%"></div>' + '</div>';
	          element.appendChild(element.resizeSensor);
	
	          if (!{ fixed: 1, absolute: 1 }[getComputedStyle(element, 'position')]) {
	            element.style.position = 'relative';
	          }
	
	          var expand = element.resizeSensor.childNodes[0];
	          var expandChild = expand.childNodes[0];
	          var shrink = element.resizeSensor.childNodes[1];
	          var shrinkChild = shrink.childNodes[0];
	
	          var lastWidth, lastHeight;
	
	          var reset = function reset() {
	            expandChild.style.width = expand.offsetWidth + 10 + 'px';
	            expandChild.style.height = expand.offsetHeight + 10 + 'px';
	            expand.scrollLeft = expand.scrollWidth;
	            expand.scrollTop = expand.scrollHeight;
	            shrink.scrollLeft = shrink.scrollWidth;
	            shrink.scrollTop = shrink.scrollHeight;
	            lastWidth = element.offsetWidth;
	            lastHeight = element.offsetHeight;
	          };
	
	          reset();
	
	          var changed = function changed() {
	            if (element.resizedAttached) {
	              element.resizedAttached.call();
	            }
	          };
	
	          var addEvent = function addEvent(el, name, cb) {
	            if (el.attachEvent) {
	              el.attachEvent('on' + name, cb);
	            } else {
	              el.addEventListener(name, cb);
	            }
	          };
	
	          var onScroll = function onScroll() {
	            if (element.offsetWidth != lastWidth || element.offsetHeight != lastHeight) {
	              changed();
	            }
	            reset();
	          };
	
	          addEvent(expand, 'scroll', onScroll);
	          addEvent(shrink, 'scroll', onScroll);
	        }
	
	        var elementType = Object.prototype.toString.call(element);
	        var isCollectionTyped = '[object Array]' === elementType || '[object NodeList]' === elementType || '[object HTMLCollection]' === elementType || 'undefined' !== typeof jQuery && element instanceof jQuery //jquery
	        || 'undefined' !== typeof Elements && element instanceof Elements //mootools
	        ;
	
	        if (isCollectionTyped) {
	          var i = 0,
	              j = element.length;
	          for (; i < j; i++) {
	            attachResizeEvent(element[i], callback);
	          }
	        } else {
	          attachResizeEvent(element, callback);
	        }
	
	        this.detach = function () {
	          if (isCollectionTyped) {
	            var i = 0,
	                j = element.length;
	            for (; i < j; i++) {
	              ResizeSensor.detach(element[i]);
	            }
	          } else {
	            ResizeSensor.detach(element);
	          }
	        };
	      };
	
	      ResizeSensor.detach = function (element) {
	        if (element.resizeSensor) {
	          element.removeChild(element.resizeSensor);
	          delete element.resizeSensor;
	          delete element.resizedAttached;
	        }
	      };
	
	      // make available to common module loader
	      if (typeof module !== 'undefined' && typeof module.exports !== 'undefined') {
	        module.exports = ResizeSensor;
	      } else {
	        window.ResizeSensor = ResizeSensor;
	      }
	    })();
	  }, {}], 3: [function (require, module, exports) {
	    'use strict';
	
	    module.exports = require('./src/js/main');
	  }, { "./src/js/main": 9 }], 4: [function (require, module, exports) {
	    'use strict';
	
	    function oldAdd(element, className) {
	      var classes = element.className.split(' ');
	      if (classes.indexOf(className) < 0) {
	        classes.push(className);
	      }
	      element.className = classes.join(' ');
	    }
	
	    function oldRemove(element, className) {
	      var classes = element.className.split(' ');
	      var idx = classes.indexOf(className);
	      if (idx >= 0) {
	        classes.splice(idx, 1);
	      }
	      element.className = classes.join(' ');
	    }
	
	    exports.add = function (element, className) {
	      if (element.classList) {
	        element.classList.add(className);
	      } else {
	        oldAdd(element, className);
	      }
	    };
	
	    exports.remove = function (element, className) {
	      if (element.classList) {
	        element.classList.remove(className);
	      } else {
	        oldRemove(element, className);
	      }
	    };
	
	    exports.list = function (element) {
	      if (element.classList) {
	        return Array.prototype.slice.apply(element.classList);
	      } else {
	        return element.className.split(' ');
	      }
	    };
	  }, {}], 5: [function (require, module, exports) {
	    'use strict';
	
	    var DOM = {};
	
	    DOM.e = function (tagName, className) {
	      var element = document.createElement(tagName);
	      element.className = className;
	      return element;
	    };
	
	    DOM.appendTo = function (child, parent) {
	      parent.appendChild(child);
	      return child;
	    };
	
	    function cssGet(element, styleName) {
	      return window.getComputedStyle(element)[styleName];
	    }
	
	    function cssSet(element, styleName, styleValue) {
	      if (typeof styleValue === 'number') {
	        styleValue = styleValue.toString() + 'px';
	      }
	      element.style[styleName] = styleValue;
	      return element;
	    }
	
	    function cssMultiSet(element, obj) {
	      for (var key in obj) {
	        var val = obj[key];
	        if (typeof val === 'number') {
	          val = val.toString() + 'px';
	        }
	        element.style[key] = val;
	      }
	      return element;
	    }
	
	    DOM.css = function (element, styleNameOrObject, styleValue) {
	      if ((typeof styleNameOrObject === "undefined" ? "undefined" : (0, _typeof3.default)(styleNameOrObject)) === 'object') {
	        // multiple set with object
	        return cssMultiSet(element, styleNameOrObject);
	      } else {
	        if (typeof styleValue === 'undefined') {
	          return cssGet(element, styleNameOrObject);
	        } else {
	          return cssSet(element, styleNameOrObject, styleValue);
	        }
	      }
	    };
	
	    DOM.matches = function (element, query) {
	      if (typeof element.matches !== 'undefined') {
	        return element.matches(query);
	      } else {
	        if (typeof element.matchesSelector !== 'undefined') {
	          return element.matchesSelector(query);
	        } else if (typeof element.webkitMatchesSelector !== 'undefined') {
	          return element.webkitMatchesSelector(query);
	        } else if (typeof element.mozMatchesSelector !== 'undefined') {
	          return element.mozMatchesSelector(query);
	        } else if (typeof element.msMatchesSelector !== 'undefined') {
	          return element.msMatchesSelector(query);
	        }
	      }
	    };
	
	    DOM.remove = function (element) {
	      if (typeof element.remove !== 'undefined') {
	        element.remove();
	      } else {
	        if (element.parentNode) {
	          element.parentNode.removeChild(element);
	        }
	      }
	    };
	
	    DOM.queryChildren = function (element, selector) {
	      return Array.prototype.filter.call(element.childNodes, function (child) {
	        return DOM.matches(child, selector);
	      });
	    };
	
	    module.exports = DOM;
	  }, {}], 6: [function (require, module, exports) {
	    'use strict';
	
	    var EventElement = function EventElement(element) {
	      this.element = element;
	      this.events = {};
	    };
	
	    EventElement.prototype.bind = function (eventName, handler) {
	      if (typeof this.events[eventName] === 'undefined') {
	        this.events[eventName] = [];
	      }
	      this.events[eventName].push(handler);
	      this.element.addEventListener(eventName, handler, false);
	    };
	
	    EventElement.prototype.unbind = function (eventName, handler) {
	      var isHandlerProvided = typeof handler !== 'undefined';
	      this.events[eventName] = this.events[eventName].filter(function (hdlr) {
	        if (isHandlerProvided && hdlr !== handler) {
	          return true;
	        }
	        this.element.removeEventListener(eventName, hdlr, false);
	        return false;
	      }, this);
	    };
	
	    EventElement.prototype.unbindAll = function () {
	      for (var name in this.events) {
	        this.unbind(name);
	      }
	    };
	
	    var EventManager = function EventManager() {
	      this.eventElements = [];
	    };
	
	    EventManager.prototype.eventElement = function (element) {
	      var ee = this.eventElements.filter(function (eventElement) {
	        return eventElement.element === element;
	      })[0];
	      if (typeof ee === 'undefined') {
	        ee = new EventElement(element);
	        this.eventElements.push(ee);
	      }
	      return ee;
	    };
	
	    EventManager.prototype.bind = function (element, eventName, handler) {
	      this.eventElement(element).bind(eventName, handler);
	    };
	
	    EventManager.prototype.unbind = function (element, eventName, handler) {
	      this.eventElement(element).unbind(eventName, handler);
	    };
	
	    EventManager.prototype.unbindAll = function () {
	      for (var i = 0; i < this.eventElements.length; i++) {
	        this.eventElements[i].unbindAll();
	      }
	    };
	
	    EventManager.prototype.once = function (element, eventName, handler) {
	      var ee = this.eventElement(element);
	      var onceHandler = function onceHandler(e) {
	        ee.unbind(eventName, onceHandler);
	        handler(e);
	      };
	      ee.bind(eventName, onceHandler);
	    };
	
	    module.exports = EventManager;
	  }, {}], 7: [function (require, module, exports) {
	    'use strict';
	
	    module.exports = function () {
	      function s4() {
	        return Math.floor((1 + Math.random()) * 0x10000).toString(16).substring(1);
	      }
	      return function () {
	        return s4() + s4() + '-' + s4() + '-' + s4() + '-' + s4() + '-' + s4() + s4() + s4();
	      };
	    }();
	  }, {}], 8: [function (require, module, exports) {
	    'use strict';
	
	    var cls = require('./class');
	    var dom = require('./dom');
	
	    var toInt = exports.toInt = function (x) {
	      return parseInt(x, 10) || 0;
	    };
	
	    var clone = exports.clone = function (obj) {
	      if (obj === null) {
	        return null;
	      } else if (obj.constructor === Array) {
	        return obj.map(clone);
	      } else if ((typeof obj === "undefined" ? "undefined" : (0, _typeof3.default)(obj)) === 'object') {
	        var result = {};
	        for (var key in obj) {
	          result[key] = clone(obj[key]);
	        }
	        return result;
	      } else {
	        return obj;
	      }
	    };
	
	    exports.extend = function (original, source) {
	      var result = clone(original);
	      for (var key in source) {
	        result[key] = clone(source[key]);
	      }
	      return result;
	    };
	
	    exports.isEditable = function (el) {
	      return dom.matches(el, "input,[contenteditable]") || dom.matches(el, "select,[contenteditable]") || dom.matches(el, "textarea,[contenteditable]") || dom.matches(el, "button,[contenteditable]");
	    };
	
	    exports.removePsClasses = function (element) {
	      var clsList = cls.list(element);
	      for (var i = 0; i < clsList.length; i++) {
	        var className = clsList[i];
	        if (className.indexOf('ps-') === 0) {
	          cls.remove(element, className);
	        }
	      }
	    };
	
	    exports.outerWidth = function (element) {
	      return toInt(dom.css(element, 'width')) + toInt(dom.css(element, 'paddingLeft')) + toInt(dom.css(element, 'paddingRight')) + toInt(dom.css(element, 'borderLeftWidth')) + toInt(dom.css(element, 'borderRightWidth'));
	    };
	
	    exports.startScrolling = function (element, axis) {
	      cls.add(element, 'ps-in-scrolling');
	      if (typeof axis !== 'undefined') {
	        cls.add(element, 'ps-' + axis);
	      } else {
	        cls.add(element, 'ps-x');
	        cls.add(element, 'ps-y');
	      }
	    };
	
	    exports.stopScrolling = function (element, axis) {
	      cls.remove(element, 'ps-in-scrolling');
	      if (typeof axis !== 'undefined') {
	        cls.remove(element, 'ps-' + axis);
	      } else {
	        cls.remove(element, 'ps-x');
	        cls.remove(element, 'ps-y');
	      }
	    };
	
	    exports.env = {
	      isWebKit: 'WebkitAppearance' in document.documentElement.style,
	      supportsTouch: 'ontouchstart' in window || window.DocumentTouch && document instanceof window.DocumentTouch,
	      supportsIePointer: window.navigator.msMaxTouchPoints !== null
	    };
	  }, { "./class": 4, "./dom": 5 }], 9: [function (require, module, exports) {
	    'use strict';
	
	    var destroy = require('./plugin/destroy');
	    var initialize = require('./plugin/initialize');
	    var update = require('./plugin/update');
	
	    module.exports = {
	      initialize: initialize,
	      update: update,
	      destroy: destroy
	    };
	  }, { "./plugin/destroy": 11, "./plugin/initialize": 19, "./plugin/update": 23 }], 10: [function (require, module, exports) {
	    'use strict';
	
	    module.exports = {
	      handlers: ['click-rail', 'drag-scrollbar', 'keyboard', 'wheel', 'touch'],
	      maxScrollbarLength: null,
	      minScrollbarLength: null,
	      scrollXMarginOffset: 0,
	      scrollYMarginOffset: 0,
	      stopPropagationOnClick: true,
	      suppressScrollX: false,
	      suppressScrollY: false,
	      swipePropagation: true,
	      useBothWheelAxes: false,
	      wheelPropagation: false,
	      wheelSpeed: 1,
	      theme: 'default'
	    };
	  }, {}], 11: [function (require, module, exports) {
	    'use strict';
	
	    var _ = require('../lib/helper');
	    var dom = require('../lib/dom');
	    var instances = require('./instances');
	
	    module.exports = function (element) {
	      var i = instances.get(element);
	
	      if (!i) {
	        return;
	      }
	
	      i.event.unbindAll();
	      dom.remove(i.scrollbarX);
	      dom.remove(i.scrollbarY);
	      dom.remove(i.scrollbarXRail);
	      dom.remove(i.scrollbarYRail);
	      _.removePsClasses(element);
	
	      instances.remove(element);
	    };
	  }, { "../lib/dom": 5, "../lib/helper": 8, "./instances": 20 }], 12: [function (require, module, exports) {
	    'use strict';
	
	    var _ = require('../../lib/helper');
	    var instances = require('../instances');
	    var updateGeometry = require('../update-geometry');
	    var updateScroll = require('../update-scroll');
	
	    function bindClickRailHandler(element, i) {
	      function pageOffset(el) {
	        return el.getBoundingClientRect();
	      }
	      var stopPropagation = function stopPropagation(e) {
	        e.stopPropagation();
	      };
	
	      if (i.settings.stopPropagationOnClick) {
	        i.event.bind(i.scrollbarY, 'click', stopPropagation);
	      }
	      i.event.bind(i.scrollbarYRail, 'click', function (e) {
	        var halfOfScrollbarLength = _.toInt(i.scrollbarYHeight / 2);
	        var positionTop = i.railYRatio * (e.pageY - window.pageYOffset - pageOffset(i.scrollbarYRail).top - halfOfScrollbarLength);
	        var maxPositionTop = i.railYRatio * (i.railYHeight - i.scrollbarYHeight);
	        var positionRatio = positionTop / maxPositionTop;
	
	        if (positionRatio < 0) {
	          positionRatio = 0;
	        } else if (positionRatio > 1) {
	          positionRatio = 1;
	        }
	
	        updateScroll(element, 'top', (i.contentHeight - i.containerHeight) * positionRatio);
	        updateGeometry(element);
	
	        e.stopPropagation();
	      });
	
	      if (i.settings.stopPropagationOnClick) {
	        i.event.bind(i.scrollbarX, 'click', stopPropagation);
	      }
	      i.event.bind(i.scrollbarXRail, 'click', function (e) {
	        var halfOfScrollbarLength = _.toInt(i.scrollbarXWidth / 2);
	        var positionLeft = i.railXRatio * (e.pageX - window.pageXOffset - pageOffset(i.scrollbarXRail).left - halfOfScrollbarLength);
	        var maxPositionLeft = i.railXRatio * (i.railXWidth - i.scrollbarXWidth);
	        var positionRatio = positionLeft / maxPositionLeft;
	
	        if (positionRatio < 0) {
	          positionRatio = 0;
	        } else if (positionRatio > 1) {
	          positionRatio = 1;
	        }
	
	        updateScroll(element, 'left', (i.contentWidth - i.containerWidth) * positionRatio - i.negativeScrollAdjustment);
	        updateGeometry(element);
	
	        e.stopPropagation();
	      });
	    }
	
	    module.exports = function (element) {
	      var i = instances.get(element);
	      bindClickRailHandler(element, i);
	    };
	  }, { "../../lib/helper": 8, "../instances": 20, "../update-geometry": 21, "../update-scroll": 22 }], 13: [function (require, module, exports) {
	    'use strict';
	
	    var _ = require('../../lib/helper');
	    var dom = require('../../lib/dom');
	    var instances = require('../instances');
	    var updateGeometry = require('../update-geometry');
	    var updateScroll = require('../update-scroll');
	
	    function bindMouseScrollXHandler(element, i) {
	      var currentLeft = null;
	      var currentPageX = null;
	
	      function updateScrollLeft(deltaX) {
	        var newLeft = currentLeft + deltaX * i.railXRatio;
	        var maxLeft = Math.max(0, i.scrollbarXRail.getBoundingClientRect().left) + i.railXRatio * (i.railXWidth - i.scrollbarXWidth);
	
	        if (newLeft < 0) {
	          i.scrollbarXLeft = 0;
	        } else if (newLeft > maxLeft) {
	          i.scrollbarXLeft = maxLeft;
	        } else {
	          i.scrollbarXLeft = newLeft;
	        }
	
	        var scrollLeft = _.toInt(i.scrollbarXLeft * (i.contentWidth - i.containerWidth) / (i.containerWidth - i.railXRatio * i.scrollbarXWidth)) - i.negativeScrollAdjustment;
	        updateScroll(element, 'left', scrollLeft);
	      }
	
	      var mouseMoveHandler = function mouseMoveHandler(e) {
	        updateScrollLeft(e.pageX - currentPageX);
	        updateGeometry(element);
	        e.stopPropagation();
	        e.preventDefault();
	      };
	
	      var mouseUpHandler = function mouseUpHandler() {
	        _.stopScrolling(element, 'x');
	        i.event.unbind(i.ownerDocument, 'mousemove', mouseMoveHandler);
	      };
	
	      i.event.bind(i.scrollbarX, 'mousedown', function (e) {
	        currentPageX = e.pageX;
	        currentLeft = _.toInt(dom.css(i.scrollbarX, 'left')) * i.railXRatio;
	        _.startScrolling(element, 'x');
	
	        i.event.bind(i.ownerDocument, 'mousemove', mouseMoveHandler);
	        i.event.once(i.ownerDocument, 'mouseup', mouseUpHandler);
	
	        e.stopPropagation();
	        e.preventDefault();
	      });
	    }
	
	    function bindMouseScrollYHandler(element, i) {
	      var currentTop = null;
	      var currentPageY = null;
	
	      function updateScrollTop(deltaY) {
	        var newTop = currentTop + deltaY * i.railYRatio;
	        var maxTop = Math.max(0, i.scrollbarYRail.getBoundingClientRect().top) + i.railYRatio * (i.railYHeight - i.scrollbarYHeight);
	
	        if (newTop < 0) {
	          i.scrollbarYTop = 0;
	        } else if (newTop > maxTop) {
	          i.scrollbarYTop = maxTop;
	        } else {
	          i.scrollbarYTop = newTop;
	        }
	
	        var scrollTop = _.toInt(i.scrollbarYTop * (i.contentHeight - i.containerHeight) / (i.containerHeight - i.railYRatio * i.scrollbarYHeight));
	        updateScroll(element, 'top', scrollTop);
	      }
	
	      var mouseMoveHandler = function mouseMoveHandler(e) {
	        updateScrollTop(e.pageY - currentPageY);
	        updateGeometry(element);
	        e.stopPropagation();
	        e.preventDefault();
	      };
	
	      var mouseUpHandler = function mouseUpHandler() {
	        _.stopScrolling(element, 'y');
	        i.event.unbind(i.ownerDocument, 'mousemove', mouseMoveHandler);
	      };
	
	      i.event.bind(i.scrollbarY, 'mousedown', function (e) {
	        currentPageY = e.pageY;
	        currentTop = _.toInt(dom.css(i.scrollbarY, 'top')) * i.railYRatio;
	        _.startScrolling(element, 'y');
	
	        i.event.bind(i.ownerDocument, 'mousemove', mouseMoveHandler);
	        i.event.once(i.ownerDocument, 'mouseup', mouseUpHandler);
	
	        e.stopPropagation();
	        e.preventDefault();
	      });
	    }
	
	    module.exports = function (element) {
	      var i = instances.get(element);
	      bindMouseScrollXHandler(element, i);
	      bindMouseScrollYHandler(element, i);
	    };
	  }, { "../../lib/dom": 5, "../../lib/helper": 8, "../instances": 20, "../update-geometry": 21, "../update-scroll": 22 }], 14: [function (require, module, exports) {
	    'use strict';
	
	    var _ = require('../../lib/helper');
	    var dom = require('../../lib/dom');
	    var instances = require('../instances');
	    var updateGeometry = require('../update-geometry');
	    var updateScroll = require('../update-scroll');
	
	    function bindKeyboardHandler(element, i) {
	      var hovered = false;
	      i.event.bind(element, 'mouseenter', function () {
	        hovered = true;
	      });
	      i.event.bind(element, 'mouseleave', function () {
	        hovered = false;
	      });
	
	      var shouldPrevent = false;
	      function shouldPreventDefault(deltaX, deltaY) {
	        var scrollTop = element.scrollTop;
	        if (deltaX === 0) {
	          if (!i.scrollbarYActive) {
	            return false;
	          }
	          if (scrollTop === 0 && deltaY > 0 || scrollTop >= i.contentHeight - i.containerHeight && deltaY < 0) {
	            return !i.settings.wheelPropagation;
	          }
	        }
	
	        var scrollLeft = element.scrollLeft;
	        if (deltaY === 0) {
	          if (!i.scrollbarXActive) {
	            return false;
	          }
	          if (scrollLeft === 0 && deltaX < 0 || scrollLeft >= i.contentWidth - i.containerWidth && deltaX > 0) {
	            return !i.settings.wheelPropagation;
	          }
	        }
	        return true;
	      }
	
	      i.event.bind(i.ownerDocument, 'keydown', function (e) {
	        if (e.isDefaultPrevented && e.isDefaultPrevented() || e.defaultPrevented) {
	          return;
	        }
	
	        var focused = dom.matches(i.scrollbarX, ':focus') || dom.matches(i.scrollbarY, ':focus');
	
	        if (!hovered && !focused) {
	          return;
	        }
	
	        var activeElement = document.activeElement ? document.activeElement : i.ownerDocument.activeElement;
	        if (activeElement) {
	          if (activeElement.tagName === 'IFRAME') {
	            activeElement = activeElement.contentDocument.activeElement;
	          } else {
	            // go deeper if element is a webcomponent
	            while (activeElement.shadowRoot) {
	              activeElement = activeElement.shadowRoot.activeElement;
	            }
	          }
	          if (_.isEditable(activeElement)) {
	            return;
	          }
	        }
	
	        var deltaX = 0;
	        var deltaY = 0;
	
	        switch (e.which) {
	          case 37:
	            // left
	            deltaX = -30;
	            break;
	          case 38:
	            // up
	            deltaY = 30;
	            break;
	          case 39:
	            // right
	            deltaX = 30;
	            break;
	          case 40:
	            // down
	            deltaY = -30;
	            break;
	          case 33:
	            // page up
	            deltaY = 90;
	            break;
	          case 32:
	            // space bar
	            if (e.shiftKey) {
	              deltaY = 90;
	            } else {
	              deltaY = -90;
	            }
	            break;
	          case 34:
	            // page down
	            deltaY = -90;
	            break;
	          case 35:
	            // end
	            if (e.ctrlKey) {
	              deltaY = -i.contentHeight;
	            } else {
	              deltaY = -i.containerHeight;
	            }
	            break;
	          case 36:
	            // home
	            if (e.ctrlKey) {
	              deltaY = element.scrollTop;
	            } else {
	              deltaY = i.containerHeight;
	            }
	            break;
	          default:
	            return;
	        }
	
	        updateScroll(element, 'top', element.scrollTop - deltaY);
	        updateScroll(element, 'left', element.scrollLeft + deltaX);
	        updateGeometry(element);
	
	        shouldPrevent = shouldPreventDefault(deltaX, deltaY);
	        if (shouldPrevent) {
	          e.preventDefault();
	        }
	      });
	    }
	
	    module.exports = function (element) {
	      var i = instances.get(element);
	      bindKeyboardHandler(element, i);
	    };
	  }, { "../../lib/dom": 5, "../../lib/helper": 8, "../instances": 20, "../update-geometry": 21, "../update-scroll": 22 }], 15: [function (require, module, exports) {
	    'use strict';
	
	    var instances = require('../instances');
	    var updateGeometry = require('../update-geometry');
	    var updateScroll = require('../update-scroll');
	
	    function bindMouseWheelHandler(element, i) {
	      var shouldPrevent = false;
	
	      function shouldPreventDefault(deltaX, deltaY) {
	        var scrollTop = element.scrollTop;
	        if (deltaX === 0) {
	          if (!i.scrollbarYActive) {
	            return false;
	          }
	          if (scrollTop === 0 && deltaY > 0 || scrollTop >= i.contentHeight - i.containerHeight && deltaY < 0) {
	            return !i.settings.wheelPropagation;
	          }
	        }
	
	        var scrollLeft = element.scrollLeft;
	        if (deltaY === 0) {
	          if (!i.scrollbarXActive) {
	            return false;
	          }
	          if (scrollLeft === 0 && deltaX < 0 || scrollLeft >= i.contentWidth - i.containerWidth && deltaX > 0) {
	            return !i.settings.wheelPropagation;
	          }
	        }
	        return true;
	      }
	
	      function getDeltaFromEvent(e) {
	        var deltaX = e.deltaX;
	        var deltaY = -1 * e.deltaY;
	
	        if (typeof deltaX === "undefined" || typeof deltaY === "undefined") {
	          // OS X Safari
	          deltaX = -1 * e.wheelDeltaX / 6;
	          deltaY = e.wheelDeltaY / 6;
	        }
	
	        if (e.deltaMode && e.deltaMode === 1) {
	          // Firefox in deltaMode 1: Line scrolling
	          deltaX *= 10;
	          deltaY *= 10;
	        }
	
	        if (deltaX !== deltaX && deltaY !== deltaY /* NaN checks */) {
	            // IE in some mouse drivers
	            deltaX = 0;
	            deltaY = e.wheelDelta;
	          }
	
	        return [deltaX, deltaY];
	      }
	
	      function shouldBeConsumedByChild(deltaX, deltaY) {
	        var child = element.querySelector('textarea:hover, select[multiple]:hover, .ps-child:hover');
	        if (child) {
	          if (child.tagName !== 'TEXTAREA' && !window.getComputedStyle(child).overflow.match(/(scroll|auto)/)) {
	            return false;
	          }
	
	          var maxScrollTop = child.scrollHeight - child.clientHeight;
	          if (maxScrollTop > 0) {
	            if (!(child.scrollTop === 0 && deltaY > 0) && !(child.scrollTop === maxScrollTop && deltaY < 0)) {
	              return true;
	            }
	          }
	          var maxScrollLeft = child.scrollLeft - child.clientWidth;
	          if (maxScrollLeft > 0) {
	            if (!(child.scrollLeft === 0 && deltaX < 0) && !(child.scrollLeft === maxScrollLeft && deltaX > 0)) {
	              return true;
	            }
	          }
	        }
	        return false;
	      }
	
	      function mousewheelHandler(e) {
	        var delta = getDeltaFromEvent(e);
	
	        var deltaX = delta[0];
	        var deltaY = delta[1];
	
	        if (shouldBeConsumedByChild(deltaX, deltaY)) {
	          return;
	        }
	
	        shouldPrevent = false;
	        if (!i.settings.useBothWheelAxes) {
	          // deltaX will only be used for horizontal scrolling and deltaY will
	          // only be used for vertical scrolling - this is the default
	          updateScroll(element, 'top', element.scrollTop - deltaY * i.settings.wheelSpeed);
	          updateScroll(element, 'left', element.scrollLeft + deltaX * i.settings.wheelSpeed);
	        } else if (i.scrollbarYActive && !i.scrollbarXActive) {
	          // only vertical scrollbar is active and useBothWheelAxes option is
	          // active, so let's scroll vertical bar using both mouse wheel axes
	          if (deltaY) {
	            updateScroll(element, 'top', element.scrollTop - deltaY * i.settings.wheelSpeed);
	          } else {
	            updateScroll(element, 'top', element.scrollTop + deltaX * i.settings.wheelSpeed);
	          }
	          shouldPrevent = true;
	        } else if (i.scrollbarXActive && !i.scrollbarYActive) {
	          // useBothWheelAxes and only horizontal bar is active, so use both
	          // wheel axes for horizontal bar
	          if (deltaX) {
	            updateScroll(element, 'left', element.scrollLeft + deltaX * i.settings.wheelSpeed);
	          } else {
	            updateScroll(element, 'left', element.scrollLeft - deltaY * i.settings.wheelSpeed);
	          }
	          shouldPrevent = true;
	        }
	
	        updateGeometry(element);
	
	        shouldPrevent = shouldPrevent || shouldPreventDefault(deltaX, deltaY);
	        if (shouldPrevent) {
	          e.stopPropagation();
	          e.preventDefault();
	        }
	      }
	
	      if (typeof window.onwheel !== "undefined") {
	        i.event.bind(element, 'wheel', mousewheelHandler);
	      } else if (typeof window.onmousewheel !== "undefined") {
	        i.event.bind(element, 'mousewheel', mousewheelHandler);
	      }
	    }
	
	    module.exports = function (element) {
	      var i = instances.get(element);
	      bindMouseWheelHandler(element, i);
	    };
	  }, { "../instances": 20, "../update-geometry": 21, "../update-scroll": 22 }], 16: [function (require, module, exports) {
	    'use strict';
	
	    var instances = require('../instances');
	    var updateGeometry = require('../update-geometry');
	
	    function bindNativeScrollHandler(element, i) {
	      i.event.bind(element, 'scroll', function () {
	        updateGeometry(element);
	      });
	    }
	
	    module.exports = function (element) {
	      var i = instances.get(element);
	      bindNativeScrollHandler(element, i);
	    };
	  }, { "../instances": 20, "../update-geometry": 21 }], 17: [function (require, module, exports) {
	    'use strict';
	
	    var _ = require('../../lib/helper');
	    var instances = require('../instances');
	    var updateGeometry = require('../update-geometry');
	    var updateScroll = require('../update-scroll');
	
	    function bindSelectionHandler(element, i) {
	      function getRangeNode() {
	        var selection = window.getSelection ? window.getSelection() : document.getSelection ? document.getSelection() : '';
	        if (selection.toString().length === 0) {
	          return null;
	        } else {
	          return selection.getRangeAt(0).commonAncestorContainer;
	        }
	      }
	
	      var scrollingLoop = null;
	      var scrollDiff = { top: 0, left: 0 };
	      function startScrolling() {
	        if (!scrollingLoop) {
	          scrollingLoop = setInterval(function () {
	            if (!instances.get(element)) {
	              clearInterval(scrollingLoop);
	              return;
	            }
	
	            updateScroll(element, 'top', element.scrollTop + scrollDiff.top);
	            updateScroll(element, 'left', element.scrollLeft + scrollDiff.left);
	            updateGeometry(element);
	          }, 50); // every .1 sec
	        }
	      }
	      function stopScrolling() {
	        if (scrollingLoop) {
	          clearInterval(scrollingLoop);
	          scrollingLoop = null;
	        }
	        _.stopScrolling(element);
	      }
	
	      var isSelected = false;
	      i.event.bind(i.ownerDocument, 'selectionchange', function () {
	        if (element.contains(getRangeNode())) {
	          isSelected = true;
	        } else {
	          isSelected = false;
	          stopScrolling();
	        }
	      });
	      i.event.bind(window, 'mouseup', function () {
	        if (isSelected) {
	          isSelected = false;
	          stopScrolling();
	        }
	      });
	
	      i.event.bind(window, 'mousemove', function (e) {
	        if (isSelected) {
	          var mousePosition = { x: e.pageX, y: e.pageY };
	          var containerGeometry = {
	            left: element.offsetLeft,
	            right: element.offsetLeft + element.offsetWidth,
	            top: element.offsetTop,
	            bottom: element.offsetTop + element.offsetHeight
	          };
	
	          if (mousePosition.x < containerGeometry.left + 3) {
	            scrollDiff.left = -5;
	            _.startScrolling(element, 'x');
	          } else if (mousePosition.x > containerGeometry.right - 3) {
	            scrollDiff.left = 5;
	            _.startScrolling(element, 'x');
	          } else {
	            scrollDiff.left = 0;
	          }
	
	          if (mousePosition.y < containerGeometry.top + 3) {
	            if (containerGeometry.top + 3 - mousePosition.y < 5) {
	              scrollDiff.top = -5;
	            } else {
	              scrollDiff.top = -20;
	            }
	            _.startScrolling(element, 'y');
	          } else if (mousePosition.y > containerGeometry.bottom - 3) {
	            if (mousePosition.y - containerGeometry.bottom + 3 < 5) {
	              scrollDiff.top = 5;
	            } else {
	              scrollDiff.top = 20;
	            }
	            _.startScrolling(element, 'y');
	          } else {
	            scrollDiff.top = 0;
	          }
	
	          if (scrollDiff.top === 0 && scrollDiff.left === 0) {
	            stopScrolling();
	          } else {
	            startScrolling();
	          }
	        }
	      });
	    }
	
	    module.exports = function (element) {
	      var i = instances.get(element);
	      bindSelectionHandler(element, i);
	    };
	  }, { "../../lib/helper": 8, "../instances": 20, "../update-geometry": 21, "../update-scroll": 22 }], 18: [function (require, module, exports) {
	    'use strict';
	
	    var _ = require('../../lib/helper');
	    var instances = require('../instances');
	    var updateGeometry = require('../update-geometry');
	    var updateScroll = require('../update-scroll');
	
	    function bindTouchHandler(element, i, supportsTouch, supportsIePointer) {
	      function shouldPreventDefault(deltaX, deltaY) {
	        var scrollTop = element.scrollTop;
	        var scrollLeft = element.scrollLeft;
	        var magnitudeX = Math.abs(deltaX);
	        var magnitudeY = Math.abs(deltaY);
	
	        if (magnitudeY > magnitudeX) {
	          // user is perhaps trying to swipe up/down the page
	
	          if (deltaY < 0 && scrollTop === i.contentHeight - i.containerHeight || deltaY > 0 && scrollTop === 0) {
	            return !i.settings.swipePropagation;
	          }
	        } else if (magnitudeX > magnitudeY) {
	          // user is perhaps trying to swipe left/right across the page
	
	          if (deltaX < 0 && scrollLeft === i.contentWidth - i.containerWidth || deltaX > 0 && scrollLeft === 0) {
	            return !i.settings.swipePropagation;
	          }
	        }
	
	        return true;
	      }
	
	      function applyTouchMove(differenceX, differenceY) {
	        updateScroll(element, 'top', element.scrollTop - differenceY);
	        updateScroll(element, 'left', element.scrollLeft - differenceX);
	
	        updateGeometry(element);
	      }
	
	      var startOffset = {};
	      var startTime = 0;
	      var speed = {};
	      var easingLoop = null;
	      var inGlobalTouch = false;
	      var inLocalTouch = false;
	
	      function globalTouchStart() {
	        inGlobalTouch = true;
	      }
	      function globalTouchEnd() {
	        inGlobalTouch = false;
	      }
	
	      function getTouch(e) {
	        if (e.targetTouches) {
	          return e.targetTouches[0];
	        } else {
	          // Maybe IE pointer
	          return e;
	        }
	      }
	      function shouldHandle(e) {
	        if (e.targetTouches && e.targetTouches.length === 1) {
	          return true;
	        }
	        if (e.pointerType && e.pointerType !== 'mouse' && e.pointerType !== e.MSPOINTER_TYPE_MOUSE) {
	          return true;
	        }
	        return false;
	      }
	      function touchStart(e) {
	        if (shouldHandle(e)) {
	          inLocalTouch = true;
	
	          var touch = getTouch(e);
	
	          startOffset.pageX = touch.pageX;
	          startOffset.pageY = touch.pageY;
	
	          startTime = new Date().getTime();
	
	          if (easingLoop !== null) {
	            clearInterval(easingLoop);
	          }
	
	          e.stopPropagation();
	        }
	      }
	      function touchMove(e) {
	        if (!inLocalTouch && i.settings.swipePropagation) {
	          touchStart(e);
	        }
	        if (!inGlobalTouch && inLocalTouch && shouldHandle(e)) {
	          var touch = getTouch(e);
	
	          var currentOffset = { pageX: touch.pageX, pageY: touch.pageY };
	
	          var differenceX = currentOffset.pageX - startOffset.pageX;
	          var differenceY = currentOffset.pageY - startOffset.pageY;
	
	          applyTouchMove(differenceX, differenceY);
	          startOffset = currentOffset;
	
	          var currentTime = new Date().getTime();
	
	          var timeGap = currentTime - startTime;
	          if (timeGap > 0) {
	            speed.x = differenceX / timeGap;
	            speed.y = differenceY / timeGap;
	            startTime = currentTime;
	          }
	
	          if (shouldPreventDefault(differenceX, differenceY)) {
	            e.stopPropagation();
	            e.preventDefault();
	          }
	        }
	      }
	      function touchEnd() {
	        if (!inGlobalTouch && inLocalTouch) {
	          inLocalTouch = false;
	
	          clearInterval(easingLoop);
	          easingLoop = setInterval(function () {
	            if (!instances.get(element)) {
	              clearInterval(easingLoop);
	              return;
	            }
	
	            if (Math.abs(speed.x) < 0.01 && Math.abs(speed.y) < 0.01) {
	              clearInterval(easingLoop);
	              return;
	            }
	
	            applyTouchMove(speed.x * 30, speed.y * 30);
	
	            speed.x *= 0.8;
	            speed.y *= 0.8;
	          }, 10);
	        }
	      }
	
	      if (supportsTouch) {
	        i.event.bind(window, 'touchstart', globalTouchStart);
	        i.event.bind(window, 'touchend', globalTouchEnd);
	        i.event.bind(element, 'touchstart', touchStart);
	        i.event.bind(element, 'touchmove', touchMove);
	        i.event.bind(element, 'touchend', touchEnd);
	      }
	
	      if (supportsIePointer) {
	        if (window.PointerEvent) {
	          i.event.bind(window, 'pointerdown', globalTouchStart);
	          i.event.bind(window, 'pointerup', globalTouchEnd);
	          i.event.bind(element, 'pointerdown', touchStart);
	          i.event.bind(element, 'pointermove', touchMove);
	          i.event.bind(element, 'pointerup', touchEnd);
	        } else if (window.MSPointerEvent) {
	          i.event.bind(window, 'MSPointerDown', globalTouchStart);
	          i.event.bind(window, 'MSPointerUp', globalTouchEnd);
	          i.event.bind(element, 'MSPointerDown', touchStart);
	          i.event.bind(element, 'MSPointerMove', touchMove);
	          i.event.bind(element, 'MSPointerUp', touchEnd);
	        }
	      }
	    }
	
	    module.exports = function (element) {
	      if (!_.env.supportsTouch && !_.env.supportsIePointer) {
	        return;
	      }
	
	      var i = instances.get(element);
	      bindTouchHandler(element, i, _.env.supportsTouch, _.env.supportsIePointer);
	    };
	  }, { "../../lib/helper": 8, "../instances": 20, "../update-geometry": 21, "../update-scroll": 22 }], 19: [function (require, module, exports) {
	    'use strict';
	
	    var _ = require('../lib/helper');
	    var cls = require('../lib/class');
	    var instances = require('./instances');
	    var updateGeometry = require('./update-geometry');
	
	    // Handlers
	    var handlers = {
	      'click-rail': require('./handler/click-rail'),
	      'drag-scrollbar': require('./handler/drag-scrollbar'),
	      'keyboard': require('./handler/keyboard'),
	      'wheel': require('./handler/mouse-wheel'),
	      'touch': require('./handler/touch'),
	      'selection': require('./handler/selection')
	    };
	    var nativeScrollHandler = require('./handler/native-scroll');
	
	    module.exports = function (element, userSettings) {
	      userSettings = (typeof userSettings === "undefined" ? "undefined" : (0, _typeof3.default)(userSettings)) === 'object' ? userSettings : {};
	
	      cls.add(element, 'ps-container');
	
	      // Create a plugin instance.
	      var i = instances.add(element);
	
	      i.settings = _.extend(i.settings, userSettings);
	      cls.add(element, 'ps-theme-' + i.settings.theme);
	
	      i.settings.handlers.forEach(function (handlerName) {
	        handlers[handlerName](element);
	      });
	
	      nativeScrollHandler(element);
	
	      updateGeometry(element);
	    };
	  }, { "../lib/class": 4, "../lib/helper": 8, "./handler/click-rail": 12, "./handler/drag-scrollbar": 13, "./handler/keyboard": 14, "./handler/mouse-wheel": 15, "./handler/native-scroll": 16, "./handler/selection": 17, "./handler/touch": 18, "./instances": 20, "./update-geometry": 21 }], 20: [function (require, module, exports) {
	    'use strict';
	
	    var _ = require('../lib/helper');
	    var cls = require('../lib/class');
	    var defaultSettings = require('./default-setting');
	    var dom = require('../lib/dom');
	    var EventManager = require('../lib/event-manager');
	    var guid = require('../lib/guid');
	
	    var instances = {};
	
	    function Instance(element) {
	      var i = this;
	
	      i.settings = _.clone(defaultSettings);
	      i.containerWidth = null;
	      i.containerHeight = null;
	      i.contentWidth = null;
	      i.contentHeight = null;
	
	      i.isRtl = dom.css(element, 'direction') === "rtl";
	      i.isNegativeScroll = function () {
	        var originalScrollLeft = element.scrollLeft;
	        var result = null;
	        element.scrollLeft = -1;
	        result = element.scrollLeft < 0;
	        element.scrollLeft = originalScrollLeft;
	        return result;
	      }();
	      i.negativeScrollAdjustment = i.isNegativeScroll ? element.scrollWidth - element.clientWidth : 0;
	      i.event = new EventManager();
	      i.ownerDocument = element.ownerDocument || document;
	
	      function focus() {
	        cls.add(element, 'ps-focus');
	      }
	
	      function blur() {
	        cls.remove(element, 'ps-focus');
	      }
	
	      i.scrollbarXRail = dom.appendTo(dom.e('div', 'ps-scrollbar-x-rail'), element);
	      i.scrollbarX = dom.appendTo(dom.e('div', 'ps-scrollbar-x'), i.scrollbarXRail);
	      i.scrollbarX.setAttribute('tabindex', 0);
	      i.event.bind(i.scrollbarX, 'focus', focus);
	      i.event.bind(i.scrollbarX, 'blur', blur);
	      i.scrollbarXActive = null;
	      i.scrollbarXWidth = null;
	      i.scrollbarXLeft = null;
	      i.scrollbarXBottom = _.toInt(dom.css(i.scrollbarXRail, 'bottom'));
	      i.isScrollbarXUsingBottom = i.scrollbarXBottom === i.scrollbarXBottom; // !isNaN
	      i.scrollbarXTop = i.isScrollbarXUsingBottom ? null : _.toInt(dom.css(i.scrollbarXRail, 'top'));
	      i.railBorderXWidth = _.toInt(dom.css(i.scrollbarXRail, 'borderLeftWidth')) + _.toInt(dom.css(i.scrollbarXRail, 'borderRightWidth'));
	      // Set rail to display:block to calculate margins
	      dom.css(i.scrollbarXRail, 'display', 'block');
	      i.railXMarginWidth = _.toInt(dom.css(i.scrollbarXRail, 'marginLeft')) + _.toInt(dom.css(i.scrollbarXRail, 'marginRight'));
	      dom.css(i.scrollbarXRail, 'display', '');
	      i.railXWidth = null;
	      i.railXRatio = null;
	
	      i.scrollbarYRail = dom.appendTo(dom.e('div', 'ps-scrollbar-y-rail'), element);
	      i.scrollbarY = dom.appendTo(dom.e('div', 'ps-scrollbar-y'), i.scrollbarYRail);
	      i.scrollbarY.setAttribute('tabindex', 0);
	      i.event.bind(i.scrollbarY, 'focus', focus);
	      i.event.bind(i.scrollbarY, 'blur', blur);
	      i.scrollbarYActive = null;
	      i.scrollbarYHeight = null;
	      i.scrollbarYTop = null;
	      i.scrollbarYRight = _.toInt(dom.css(i.scrollbarYRail, 'right'));
	      i.isScrollbarYUsingRight = i.scrollbarYRight === i.scrollbarYRight; // !isNaN
	      i.scrollbarYLeft = i.isScrollbarYUsingRight ? null : _.toInt(dom.css(i.scrollbarYRail, 'left'));
	      i.scrollbarYOuterWidth = i.isRtl ? _.outerWidth(i.scrollbarY) : null;
	      i.railBorderYWidth = _.toInt(dom.css(i.scrollbarYRail, 'borderTopWidth')) + _.toInt(dom.css(i.scrollbarYRail, 'borderBottomWidth'));
	      dom.css(i.scrollbarYRail, 'display', 'block');
	      i.railYMarginHeight = _.toInt(dom.css(i.scrollbarYRail, 'marginTop')) + _.toInt(dom.css(i.scrollbarYRail, 'marginBottom'));
	      dom.css(i.scrollbarYRail, 'display', '');
	      i.railYHeight = null;
	      i.railYRatio = null;
	    }
	
	    function getId(element) {
	      return element.getAttribute('data-ps-id');
	    }
	
	    function setId(element, id) {
	      element.setAttribute('data-ps-id', id);
	    }
	
	    function removeId(element) {
	      element.removeAttribute('data-ps-id');
	    }
	
	    exports.add = function (element) {
	      var newId = guid();
	      setId(element, newId);
	      instances[newId] = new Instance(element);
	      return instances[newId];
	    };
	
	    exports.remove = function (element) {
	      delete instances[getId(element)];
	      removeId(element);
	    };
	
	    exports.get = function (element) {
	      return instances[getId(element)];
	    };
	  }, { "../lib/class": 4, "../lib/dom": 5, "../lib/event-manager": 6, "../lib/guid": 7, "../lib/helper": 8, "./default-setting": 10 }], 21: [function (require, module, exports) {
	    'use strict';
	
	    var _ = require('../lib/helper');
	    var cls = require('../lib/class');
	    var dom = require('../lib/dom');
	    var instances = require('./instances');
	    var updateScroll = require('./update-scroll');
	
	    function getThumbSize(i, thumbSize) {
	      if (i.settings.minScrollbarLength) {
	        thumbSize = Math.max(thumbSize, i.settings.minScrollbarLength);
	      }
	      if (i.settings.maxScrollbarLength) {
	        thumbSize = Math.min(thumbSize, i.settings.maxScrollbarLength);
	      }
	      return thumbSize;
	    }
	
	    function updateCss(element, i) {
	      var xRailOffset = { width: i.railXWidth };
	      if (i.isRtl) {
	        xRailOffset.left = i.negativeScrollAdjustment + element.scrollLeft + i.containerWidth - i.contentWidth;
	      } else {
	        xRailOffset.left = element.scrollLeft;
	      }
	      if (i.isScrollbarXUsingBottom) {
	        xRailOffset.bottom = i.scrollbarXBottom - element.scrollTop;
	      } else {
	        xRailOffset.top = i.scrollbarXTop + element.scrollTop;
	      }
	      dom.css(i.scrollbarXRail, xRailOffset);
	
	      var yRailOffset = { top: element.scrollTop, height: i.railYHeight };
	      if (i.isScrollbarYUsingRight) {
	        if (i.isRtl) {
	          yRailOffset.right = i.contentWidth - (i.negativeScrollAdjustment + element.scrollLeft) - i.scrollbarYRight - i.scrollbarYOuterWidth;
	        } else {
	          yRailOffset.right = i.scrollbarYRight - element.scrollLeft;
	        }
	      } else {
	        if (i.isRtl) {
	          yRailOffset.left = i.negativeScrollAdjustment + element.scrollLeft + i.containerWidth * 2 - i.contentWidth - i.scrollbarYLeft - i.scrollbarYOuterWidth;
	        } else {
	          yRailOffset.left = i.scrollbarYLeft + element.scrollLeft;
	        }
	      }
	      dom.css(i.scrollbarYRail, yRailOffset);
	
	      dom.css(i.scrollbarX, { left: i.scrollbarXLeft, width: i.scrollbarXWidth - i.railBorderXWidth });
	      dom.css(i.scrollbarY, { top: i.scrollbarYTop, height: i.scrollbarYHeight - i.railBorderYWidth });
	    }
	
	    module.exports = function (element) {
	      var i = instances.get(element);
	
	      i.containerWidth = element.clientWidth;
	      i.containerHeight = element.clientHeight;
	      i.contentWidth = element.scrollWidth;
	      i.contentHeight = element.scrollHeight;
	
	      var existingRails;
	      if (!element.contains(i.scrollbarXRail)) {
	        existingRails = dom.queryChildren(element, '.ps-scrollbar-x-rail');
	        if (existingRails.length > 0) {
	          existingRails.forEach(function (rail) {
	            dom.remove(rail);
	          });
	        }
	        dom.appendTo(i.scrollbarXRail, element);
	      }
	      if (!element.contains(i.scrollbarYRail)) {
	        existingRails = dom.queryChildren(element, '.ps-scrollbar-y-rail');
	        if (existingRails.length > 0) {
	          existingRails.forEach(function (rail) {
	            dom.remove(rail);
	          });
	        }
	        dom.appendTo(i.scrollbarYRail, element);
	      }
	
	      if (!i.settings.suppressScrollX && i.containerWidth + i.settings.scrollXMarginOffset < i.contentWidth) {
	        i.scrollbarXActive = true;
	        i.railXWidth = i.containerWidth - i.railXMarginWidth;
	        i.railXRatio = i.containerWidth / i.railXWidth;
	        i.scrollbarXWidth = getThumbSize(i, _.toInt(i.railXWidth * i.containerWidth / i.contentWidth));
	        i.scrollbarXLeft = _.toInt((i.negativeScrollAdjustment + element.scrollLeft) * (i.railXWidth - i.scrollbarXWidth) / (i.contentWidth - i.containerWidth));
	      } else {
	        i.scrollbarXActive = false;
	      }
	
	      if (!i.settings.suppressScrollY && i.containerHeight + i.settings.scrollYMarginOffset < i.contentHeight) {
	        i.scrollbarYActive = true;
	        i.railYHeight = i.containerHeight - i.railYMarginHeight;
	        i.railYRatio = i.containerHeight / i.railYHeight;
	        i.scrollbarYHeight = getThumbSize(i, _.toInt(i.railYHeight * i.containerHeight / i.contentHeight));
	        i.scrollbarYTop = _.toInt(element.scrollTop * (i.railYHeight - i.scrollbarYHeight) / (i.contentHeight - i.containerHeight));
	      } else {
	        i.scrollbarYActive = false;
	      }
	
	      if (i.scrollbarXLeft >= i.railXWidth - i.scrollbarXWidth) {
	        i.scrollbarXLeft = i.railXWidth - i.scrollbarXWidth;
	      }
	      if (i.scrollbarYTop >= i.railYHeight - i.scrollbarYHeight) {
	        i.scrollbarYTop = i.railYHeight - i.scrollbarYHeight;
	      }
	
	      updateCss(element, i);
	
	      if (i.scrollbarXActive) {
	        cls.add(element, 'ps-active-x');
	      } else {
	        cls.remove(element, 'ps-active-x');
	        i.scrollbarXWidth = 0;
	        i.scrollbarXLeft = 0;
	        updateScroll(element, 'left', 0);
	      }
	      if (i.scrollbarYActive) {
	        cls.add(element, 'ps-active-y');
	      } else {
	        cls.remove(element, 'ps-active-y');
	        i.scrollbarYHeight = 0;
	        i.scrollbarYTop = 0;
	        updateScroll(element, 'top', 0);
	      }
	    };
	  }, { "../lib/class": 4, "../lib/dom": 5, "../lib/helper": 8, "./instances": 20, "./update-scroll": 22 }], 22: [function (require, module, exports) {
	    'use strict';
	
	    var instances = require('./instances');
	
	    var upEvent = document.createEvent('Event');
	    var downEvent = document.createEvent('Event');
	    var leftEvent = document.createEvent('Event');
	    var rightEvent = document.createEvent('Event');
	    var yEvent = document.createEvent('Event');
	    var xEvent = document.createEvent('Event');
	    var xStartEvent = document.createEvent('Event');
	    var xEndEvent = document.createEvent('Event');
	    var yStartEvent = document.createEvent('Event');
	    var yEndEvent = document.createEvent('Event');
	    var lastTop;
	    var lastLeft;
	
	    upEvent.initEvent('ps-scroll-up', true, true);
	    downEvent.initEvent('ps-scroll-down', true, true);
	    leftEvent.initEvent('ps-scroll-left', true, true);
	    rightEvent.initEvent('ps-scroll-right', true, true);
	    yEvent.initEvent('ps-scroll-y', true, true);
	    xEvent.initEvent('ps-scroll-x', true, true);
	    xStartEvent.initEvent('ps-x-reach-start', true, true);
	    xEndEvent.initEvent('ps-x-reach-end', true, true);
	    yStartEvent.initEvent('ps-y-reach-start', true, true);
	    yEndEvent.initEvent('ps-y-reach-end', true, true);
	
	    module.exports = function (element, axis, value) {
	      if (typeof element === 'undefined') {
	        throw 'You must provide an element to the update-scroll function';
	      }
	
	      if (typeof axis === 'undefined') {
	        throw 'You must provide an axis to the update-scroll function';
	      }
	
	      if (typeof value === 'undefined') {
	        throw 'You must provide a value to the update-scroll function';
	      }
	
	      if (axis === 'top' && value <= 0) {
	        element.scrollTop = value = 0; // don't allow negative scroll
	        element.dispatchEvent(yStartEvent);
	      }
	
	      if (axis === 'left' && value <= 0) {
	        element.scrollLeft = value = 0; // don't allow negative scroll
	        element.dispatchEvent(xStartEvent);
	      }
	
	      var i = instances.get(element);
	
	      if (axis === 'top' && value >= i.contentHeight - i.containerHeight) {
	        // don't allow scroll past container
	        value = i.contentHeight - i.containerHeight;
	        if (value - element.scrollTop <= 1) {
	          // mitigates rounding errors on non-subpixel scroll values
	          value = element.scrollTop;
	        } else {
	          element.scrollTop = value;
	        }
	        element.dispatchEvent(yEndEvent);
	      }
	
	      if (axis === 'left' && value >= i.contentWidth - i.containerWidth) {
	        // don't allow scroll past container
	        value = i.contentWidth - i.containerWidth;
	        if (value - element.scrollLeft <= 1) {
	          // mitigates rounding errors on non-subpixel scroll values
	          value = element.scrollLeft;
	        } else {
	          element.scrollLeft = value;
	        }
	        element.dispatchEvent(xEndEvent);
	      }
	
	      if (!lastTop) {
	        lastTop = element.scrollTop;
	      }
	
	      if (!lastLeft) {
	        lastLeft = element.scrollLeft;
	      }
	
	      if (axis === 'top' && value < lastTop) {
	        element.dispatchEvent(upEvent);
	      }
	
	      if (axis === 'top' && value > lastTop) {
	        element.dispatchEvent(downEvent);
	      }
	
	      if (axis === 'left' && value < lastLeft) {
	        element.dispatchEvent(leftEvent);
	      }
	
	      if (axis === 'left' && value > lastLeft) {
	        element.dispatchEvent(rightEvent);
	      }
	
	      if (axis === 'top') {
	        element.scrollTop = lastTop = value;
	        element.dispatchEvent(yEvent);
	      }
	
	      if (axis === 'left') {
	        element.scrollLeft = lastLeft = value;
	        element.dispatchEvent(xEvent);
	      }
	    };
	  }, { "./instances": 20 }], 23: [function (require, module, exports) {
	    'use strict';
	
	    var _ = require('../lib/helper');
	    var dom = require('../lib/dom');
	    var instances = require('./instances');
	    var updateGeometry = require('./update-geometry');
	    var updateScroll = require('./update-scroll');
	
	    module.exports = function (element) {
	      var i = instances.get(element);
	
	      if (!i) {
	        return;
	      }
	
	      // Recalcuate negative scrollLeft adjustment
	      i.negativeScrollAdjustment = i.isNegativeScroll ? element.scrollWidth - element.clientWidth : 0;
	
	      // Recalculate rail margins
	      dom.css(i.scrollbarXRail, 'display', 'block');
	      dom.css(i.scrollbarYRail, 'display', 'block');
	      i.railXMarginWidth = _.toInt(dom.css(i.scrollbarXRail, 'marginLeft')) + _.toInt(dom.css(i.scrollbarXRail, 'marginRight'));
	      i.railYMarginHeight = _.toInt(dom.css(i.scrollbarYRail, 'marginTop')) + _.toInt(dom.css(i.scrollbarYRail, 'marginBottom'));
	
	      // Hide scrollbars not to affect scrollWidth and scrollHeight
	      dom.css(i.scrollbarXRail, 'display', 'none');
	      dom.css(i.scrollbarYRail, 'display', 'none');
	
	      updateGeometry(element);
	
	      // Update top/left scroll to trigger events
	      updateScroll(element, 'top', element.scrollTop);
	      updateScroll(element, 'left', element.scrollLeft);
	
	      dom.css(i.scrollbarXRail, 'display', '');
	      dom.css(i.scrollbarYRail, 'display', '');
	    };
	  }, { "../lib/dom": 5, "../lib/helper": 8, "./instances": 20, "./update-geometry": 21, "./update-scroll": 22 }] }, {}, [1]);
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }()), __webpack_require__(2)))

/***/ },
/* 106 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(107), __esModule: true };

/***/ },
/* 107 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(108);
	module.exports = __webpack_require__(15).Object.assign;

/***/ },
/* 108 */
/***/ function(module, exports, __webpack_require__) {

	// 19.1.3.1 Object.assign(target, source)
	var $export = __webpack_require__(13);
	
	$export($export.S + $export.F, 'Object', {assign: __webpack_require__(109)});

/***/ },
/* 109 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// 19.1.2.1 Object.assign(target, source, ...)
	var getKeys  = __webpack_require__(34)
	  , gOPS     = __webpack_require__(63)
	  , pIE      = __webpack_require__(64)
	  , toObject = __webpack_require__(50)
	  , IObject  = __webpack_require__(37)
	  , $assign  = Object.assign;
	
	// should work with symbols and should have deterministic property order (V8 bug)
	module.exports = !$assign || __webpack_require__(24)(function(){
	  var A = {}
	    , B = {}
	    , S = Symbol()
	    , K = 'abcdefghijklmnopqrst';
	  A[S] = 7;
	  K.split('').forEach(function(k){ B[k] = k; });
	  return $assign({}, A)[S] != 7 || Object.keys($assign({}, B)).join('') != K;
	}) ? function assign(target, source){ // eslint-disable-line no-unused-vars
	  var T     = toObject(target)
	    , aLen  = arguments.length
	    , index = 1
	    , getSymbols = gOPS.f
	    , isEnum     = pIE.f;
	  while(aLen > index){
	    var S      = IObject(arguments[index++])
	      , keys   = getSymbols ? getKeys(S).concat(getSymbols(S)) : getKeys(S)
	      , length = keys.length
	      , j      = 0
	      , key;
	    while(length > j)if(isEnum.call(S, key = keys[j++]))T[key] = S[key];
	  } return T;
	} : $assign;

/***/ },
/* 110 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {module.exports = global["Clipboard"] = __webpack_require__(111);
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 111 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;var require;var require;"use strict";
	
	var _setPrototypeOf = __webpack_require__(112);
	
	var _setPrototypeOf2 = _interopRequireDefault(_setPrototypeOf);
	
	var _create = __webpack_require__(116);
	
	var _create2 = _interopRequireDefault(_create);
	
	var _defineProperty = __webpack_require__(88);
	
	var _defineProperty2 = _interopRequireDefault(_defineProperty);
	
	var _typeof2 = __webpack_require__(4);
	
	var _typeof3 = _interopRequireDefault(_typeof2);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/*!
	 * clipboard.js v1.5.5
	 * https://zenorocha.github.io/clipboard.js
	 *
	 * Licensed MIT © Zeno Rocha
	 */
	!function (t) {
	  if ("object" == ( false ? "undefined" : (0, _typeof3.default)(exports)) && "undefined" != typeof module) module.exports = t();else if (true) !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (t), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));else {
	    var e;e = "undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof self ? self : this, e.Clipboard = t();
	  }
	}(function () {
	  var t, e, n;return function t(e, n, r) {
	    function o(a, c) {
	      if (!n[a]) {
	        if (!e[a]) {
	          var s = "function" == typeof require && require;if (!c && s) return require(a, !0);if (i) return i(a, !0);var u = new Error("Cannot find module '" + a + "'");throw u.code = "MODULE_NOT_FOUND", u;
	        }var l = n[a] = { exports: {} };e[a][0].call(l.exports, function (t) {
	          var n = e[a][1][t];return o(n ? n : t);
	        }, l, l.exports, t, e, n, r);
	      }return n[a].exports;
	    }for (var i = "function" == typeof require && require, a = 0; a < r.length; a++) {
	      o(r[a]);
	    }return o;
	  }({ 1: [function (t, e, n) {
	      var r = t("matches-selector");e.exports = function (t, e, n) {
	        for (var o = n ? t : t.parentNode; o && o !== document;) {
	          if (r(o, e)) return o;o = o.parentNode;
	        }
	      };
	    }, { "matches-selector": 2 }], 2: [function (t, e, n) {
	      function r(t, e) {
	        if (i) return i.call(t, e);for (var n = t.parentNode.querySelectorAll(e), r = 0; r < n.length; ++r) {
	          if (n[r] == t) return !0;
	        }return !1;
	      }var o = Element.prototype,
	          i = o.matchesSelector || o.webkitMatchesSelector || o.mozMatchesSelector || o.msMatchesSelector || o.oMatchesSelector;e.exports = r;
	    }, {}], 3: [function (t, e, n) {
	      function r(t, e, n, r) {
	        var i = o.apply(this, arguments);return t.addEventListener(n, i), { destroy: function destroy() {
	            t.removeEventListener(n, i);
	          } };
	      }function o(t, e, n, r) {
	        return function (n) {
	          n.delegateTarget = i(n.target, e, !0), n.delegateTarget && r.call(t, n);
	        };
	      }var i = t("closest");e.exports = r;
	    }, { closest: 1 }], 4: [function (t, e, n) {
	      n.node = function (t) {
	        return void 0 !== t && t instanceof HTMLElement && 1 === t.nodeType;
	      }, n.nodeList = function (t) {
	        var e = Object.prototype.toString.call(t);return void 0 !== t && ("[object NodeList]" === e || "[object HTMLCollection]" === e) && "length" in t && (0 === t.length || n.node(t[0]));
	      }, n.string = function (t) {
	        return "string" == typeof t || t instanceof String;
	      }, n.function = function (t) {
	        var e = Object.prototype.toString.call(t);return "[object Function]" === e;
	      };
	    }, {}], 5: [function (t, e, n) {
	      function r(t, e, n) {
	        if (!t && !e && !n) throw new Error("Missing required arguments");if (!c.string(e)) throw new TypeError("Second argument must be a String");if (!c.function(n)) throw new TypeError("Third argument must be a Function");if (c.node(t)) return o(t, e, n);if (c.nodeList(t)) return i(t, e, n);if (c.string(t)) return a(t, e, n);throw new TypeError("First argument must be a String, HTMLElement, HTMLCollection, or NodeList");
	      }function o(t, e, n) {
	        return t.addEventListener(e, n), { destroy: function destroy() {
	            t.removeEventListener(e, n);
	          } };
	      }function i(t, e, n) {
	        return Array.prototype.forEach.call(t, function (t) {
	          t.addEventListener(e, n);
	        }), { destroy: function destroy() {
	            Array.prototype.forEach.call(t, function (t) {
	              t.removeEventListener(e, n);
	            });
	          } };
	      }function a(t, e, n) {
	        return s(document.body, t, e, n);
	      }var c = t("./is"),
	          s = t("delegate");e.exports = r;
	    }, { "./is": 4, delegate: 3 }], 6: [function (t, e, n) {
	      function r(t) {
	        var e;if ("INPUT" === t.nodeName || "TEXTAREA" === t.nodeName) t.focus(), t.setSelectionRange(0, t.value.length), e = t.value;else {
	          t.hasAttribute("contenteditable") && t.focus();var n = window.getSelection(),
	              r = document.createRange();r.selectNodeContents(t), n.removeAllRanges(), n.addRange(r), e = n.toString();
	        }return e;
	      }e.exports = r;
	    }, {}], 7: [function (t, e, n) {
	      function r() {}r.prototype = { on: function on(t, e, n) {
	          var r = this.e || (this.e = {});return (r[t] || (r[t] = [])).push({ fn: e, ctx: n }), this;
	        }, once: function once(t, e, n) {
	          function r() {
	            o.off(t, r), e.apply(n, arguments);
	          }var o = this;return r._ = e, this.on(t, r, n);
	        }, emit: function emit(t) {
	          var e = [].slice.call(arguments, 1),
	              n = ((this.e || (this.e = {}))[t] || []).slice(),
	              r = 0,
	              o = n.length;for (r; o > r; r++) {
	            n[r].fn.apply(n[r].ctx, e);
	          }return this;
	        }, off: function off(t, e) {
	          var n = this.e || (this.e = {}),
	              r = n[t],
	              o = [];if (r && e) for (var i = 0, a = r.length; a > i; i++) {
	            r[i].fn !== e && r[i].fn._ !== e && o.push(r[i]);
	          }return o.length ? n[t] = o : delete n[t], this;
	        } }, e.exports = r;
	    }, {}], 8: [function (t, e, n) {
	      "use strict";
	      function r(t) {
	        return t && t.__esModule ? t : { "default": t };
	      }function o(t, e) {
	        if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function");
	      }n.__esModule = !0;var i = function () {
	        function t(t, e) {
	          for (var n = 0; n < e.length; n++) {
	            var r = e[n];r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), (0, _defineProperty2.default)(t, r.key, r);
	          }
	        }return function (e, n, r) {
	          return n && t(e.prototype, n), r && t(e, r), e;
	        };
	      }(),
	          a = t("select"),
	          c = r(a),
	          s = function () {
	        function t(e) {
	          o(this, t), this.resolveOptions(e), this.initSelection();
	        }return t.prototype.resolveOptions = function t() {
	          var e = arguments.length <= 0 || void 0 === arguments[0] ? {} : arguments[0];this.action = e.action, this.emitter = e.emitter, this.target = e.target, this.text = e.text, this.trigger = e.trigger, this.selectedText = "";
	        }, t.prototype.initSelection = function t() {
	          if (this.text && this.target) throw new Error('Multiple attributes declared, use either "target" or "text"');if (this.text) this.selectFake();else {
	            if (!this.target) throw new Error('Missing required attributes, use either "target" or "text"');this.selectTarget();
	          }
	        }, t.prototype.selectFake = function t() {
	          var e = this;this.removeFake(), this.fakeHandler = document.body.addEventListener("click", function () {
	            return e.removeFake();
	          }), this.fakeElem = document.createElement("textarea"), this.fakeElem.style.position = "absolute", this.fakeElem.style.left = "-9999px", this.fakeElem.style.top = (window.pageYOffset || document.documentElement.scrollTop) + "px", this.fakeElem.setAttribute("readonly", ""), this.fakeElem.value = this.text, document.body.appendChild(this.fakeElem), this.selectedText = c.default(this.fakeElem), this.copyText();
	        }, t.prototype.removeFake = function t() {
	          this.fakeHandler && (document.body.removeEventListener("click"), this.fakeHandler = null), this.fakeElem && (document.body.removeChild(this.fakeElem), this.fakeElem = null);
	        }, t.prototype.selectTarget = function t() {
	          this.selectedText = c.default(this.target), this.copyText();
	        }, t.prototype.copyText = function t() {
	          var e = void 0;try {
	            e = document.execCommand(this.action);
	          } catch (n) {
	            e = !1;
	          }this.handleResult(e);
	        }, t.prototype.handleResult = function t(e) {
	          e ? this.emitter.emit("success", { action: this.action, text: this.selectedText, trigger: this.trigger, clearSelection: this.clearSelection.bind(this) }) : this.emitter.emit("error", { action: this.action, trigger: this.trigger, clearSelection: this.clearSelection.bind(this) });
	        }, t.prototype.clearSelection = function t() {
	          this.target && this.target.blur(), window.getSelection().removeAllRanges();
	        }, t.prototype.destroy = function t() {
	          this.removeFake();
	        }, i(t, [{ key: "action", set: function t() {
	            var e = arguments.length <= 0 || void 0 === arguments[0] ? "copy" : arguments[0];if (this._action = e, "copy" !== this._action && "cut" !== this._action) throw new Error('Invalid "action" value, use either "copy" or "cut"');
	          }, get: function t() {
	            return this._action;
	          } }, { key: "target", set: function t(e) {
	            if (void 0 !== e) {
	              if (!e || "object" != (typeof e === "undefined" ? "undefined" : (0, _typeof3.default)(e)) || 1 !== e.nodeType) throw new Error('Invalid "target" value, use a valid Element');this._target = e;
	            }
	          }, get: function t() {
	            return this._target;
	          } }]), t;
	      }();n.default = s, e.exports = n.default;
	    }, { select: 6 }], 9: [function (t, e, n) {
	      "use strict";
	      function r(t) {
	        return t && t.__esModule ? t : { "default": t };
	      }function o(t, e) {
	        if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function");
	      }function i(t, e) {
	        if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function, not " + (typeof e === "undefined" ? "undefined" : (0, _typeof3.default)(e)));t.prototype = (0, _create2.default)(e && e.prototype, { constructor: { value: t, enumerable: !1, writable: !0, configurable: !0 } }), e && (_setPrototypeOf2.default ? (0, _setPrototypeOf2.default)(t, e) : t.__proto__ = e);
	      }function a(t, e) {
	        var n = "data-clipboard-" + t;if (e.hasAttribute(n)) return e.getAttribute(n);
	      }n.__esModule = !0;var c = t("./clipboard-action"),
	          s = r(c),
	          u = t("tiny-emitter"),
	          l = r(u),
	          f = t("good-listener"),
	          d = r(f),
	          h = function (t) {
	        function e(n, r) {
	          o(this, e), t.call(this), this.resolveOptions(r), this.listenClick(n);
	        }return i(e, t), e.prototype.resolveOptions = function t() {
	          var e = arguments.length <= 0 || void 0 === arguments[0] ? {} : arguments[0];this.action = "function" == typeof e.action ? e.action : this.defaultAction, this.target = "function" == typeof e.target ? e.target : this.defaultTarget, this.text = "function" == typeof e.text ? e.text : this.defaultText;
	        }, e.prototype.listenClick = function t(e) {
	          var n = this;this.listener = d.default(e, "click", function (t) {
	            return n.onClick(t);
	          });
	        }, e.prototype.onClick = function t(e) {
	          var n = e.delegateTarget || e.currentTarget;this.clipboardAction && (this.clipboardAction = null), this.clipboardAction = new s.default({ action: this.action(n), target: this.target(n), text: this.text(n), trigger: n, emitter: this });
	        }, e.prototype.defaultAction = function t(e) {
	          return a("action", e);
	        }, e.prototype.defaultTarget = function t(e) {
	          var n = a("target", e);return n ? document.querySelector(n) : void 0;
	        }, e.prototype.defaultText = function t(e) {
	          return a("text", e);
	        }, e.prototype.destroy = function t() {
	          this.listener.destroy(), this.clipboardAction && (this.clipboardAction.destroy(), this.clipboardAction = null);
	        }, e;
	      }(l.default);n.default = h, e.exports = n.default;
	    }, { "./clipboard-action": 8, "good-listener": 5, "tiny-emitter": 7 }] }, {}, [9])(9);
	});

/***/ },
/* 112 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(113), __esModule: true };

/***/ },
/* 113 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(114);
	module.exports = __webpack_require__(15).Object.setPrototypeOf;

/***/ },
/* 114 */
/***/ function(module, exports, __webpack_require__) {

	// 19.1.3.19 Object.setPrototypeOf(O, proto)
	var $export = __webpack_require__(13);
	$export($export.S, 'Object', {setPrototypeOf: __webpack_require__(115).set});

/***/ },
/* 115 */
/***/ function(module, exports, __webpack_require__) {

	// Works with __proto__ only. Old v8 can't work with null proto objects.
	/* eslint-disable no-proto */
	var isObject = __webpack_require__(21)
	  , anObject = __webpack_require__(20);
	var check = function(O, proto){
	  anObject(O);
	  if(!isObject(proto) && proto !== null)throw TypeError(proto + ": can't set as prototype!");
	};
	module.exports = {
	  set: Object.setPrototypeOf || ('__proto__' in {} ? // eslint-disable-line
	    function(test, buggy, set){
	      try {
	        set = __webpack_require__(16)(Function.call, __webpack_require__(68).f(Object.prototype, '__proto__').set, 2);
	        set(test, []);
	        buggy = !(test instanceof Array);
	      } catch(e){ buggy = true; }
	      return function setPrototypeOf(O, proto){
	        check(O, proto);
	        if(buggy)O.__proto__ = proto;
	        else set(O, proto);
	        return O;
	      };
	    }({}, false) : undefined),
	  check: check
	};

/***/ },
/* 116 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(117), __esModule: true };

/***/ },
/* 117 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(118);
	var $Object = __webpack_require__(15).Object;
	module.exports = function create(P, D){
	  return $Object.create(P, D);
	};

/***/ },
/* 118 */
/***/ function(module, exports, __webpack_require__) {

	var $export = __webpack_require__(13)
	// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
	$export($export.S, 'Object', {create: __webpack_require__(32)});

/***/ },
/* 119 */
/***/ function(module, exports) {

	"use strict";
	
	/*!
	* Clamp.js 0.5.1
	*
	* Copyright 2011-2013, Joseph Schmitt http://joe.sh
	* Released under the WTFPL license
	* http://sam.zoy.org/wtfpl/
	*/
	(function () {
	  window.$clamp = function (c, d) {
	    function s(a, b) {
	      n.getComputedStyle || (n.getComputedStyle = function (a, b) {
	        this.el = a;this.getPropertyValue = function (b) {
	          var c = /(\-([a-z]){1})/g;"float" == b && (b = "styleFloat");c.test(b) && (b = b.replace(c, function (a, b, c) {
	            return c.toUpperCase();
	          }));return a.currentStyle && a.currentStyle[b] ? a.currentStyle[b] : null;
	        };return this;
	      });return n.getComputedStyle(a, null).getPropertyValue(b);
	    }function t(a) {
	      a = a || c.clientHeight;var b = u(c);return Math.max(Math.floor(a / b), 0);
	    }function x(a) {
	      return u(c) * a;
	    }function u(a) {
	      var b = s(a, "line-height");"normal" == b && (b = 1.2 * parseInt(s(a, "font-size")));return parseInt(b);
	    }function l(a) {
	      if (a.lastChild.children && 0 < a.lastChild.children.length) return l(Array.prototype.slice.call(a.children).pop());if (a.lastChild && a.lastChild.nodeValue && "" != a.lastChild.nodeValue && a.lastChild.nodeValue != b.truncationChar) return a.lastChild;a.lastChild.parentNode.removeChild(a.lastChild);return l(c);
	    }function p(a, d) {
	      if (d) {
	        var e = a.nodeValue.replace(b.truncationChar, "");f || (h = 0 < k.length ? k.shift() : "", f = e.split(h));1 < f.length ? (q = f.pop(), r(a, f.join(h))) : f = null;m && (a.nodeValue = a.nodeValue.replace(b.truncationChar, ""), c.innerHTML = a.nodeValue + " " + m.innerHTML + b.truncationChar);if (f) {
	          if (c.clientHeight <= d) if (0 <= k.length && "" != h) r(a, f.join(h) + h + q), f = null;else return c.innerHTML;
	        } else "" == h && (r(a, ""), a = l(c), k = b.splitOnChars.slice(0), h = k[0], q = f = null);if (b.animate) setTimeout(function () {
	          p(a, d);
	        }, !0 === b.animate ? 10 : b.animate);else return p(a, d);
	      }
	    }function r(a, c) {
	      a.nodeValue = c + b.truncationChar;
	    }d = d || {};
	    var n = window,
	        b = { clamp: d.clamp || 2, useNativeClamp: "undefined" != typeof d.useNativeClamp ? d.useNativeClamp : !0, splitOnChars: d.splitOnChars || [".", "-", "\u2013", "\u2014", " "], animate: d.animate || !1, truncationChar: d.truncationChar || "\u2026", truncationHTML: d.truncationHTML },
	        e = c.style,
	        y = c.innerHTML,
	        z = "undefined" != typeof c.style.webkitLineClamp,
	        g = b.clamp,
	        v = g.indexOf && (-1 < g.indexOf("px") || -1 < g.indexOf("em")),
	        m;b.truncationHTML && (m = document.createElement("span"), m.innerHTML = b.truncationHTML);var k = b.splitOnChars.slice(0),
	        h = k[0],
	        f,
	        q;"auto" == g ? g = t() : v && (g = t(parseInt(g)));var w;z && b.useNativeClamp ? (e.overflow = "hidden", e.textOverflow = "ellipsis", e.webkitBoxOrient = "vertical", e.display = "-webkit-box", e.webkitLineClamp = g, v && (e.height = b.clamp + "px")) : (e = x(g), e <= c.clientHeight && (w = p(l(c), e)));return { original: y, clamped: w };
	  };
	})();

/***/ },
/* 120 */
/***/ function(module, exports, __webpack_require__) {

	// knockout-postbox 0.5.2 | (c) 2015 Ryan Niemeyer |  http://www.opensource.org/licenses/mit-license
	;(function(factory) {
	    //CommonJS
	    if (true) {
	        factory(__webpack_require__(94), exports);
	    //AMD
	    } else if (typeof define === "function" && define.amd) {
	        define(["knockout", "exports"], factory);
	    //normal script tag
	    } else {
	        factory(ko, ko.postbox = {});
	    }
	}(function(ko, exports, undefined) {
	    var disposeTopicSubscription, existingSubscribe,
			subscriptions = {},
			subId = 1;
	
		exports.subscriptions = subscriptions;
	
	    //create a global postbox that supports subscribing/publishing
	    ko.subscribable.call(exports);
	
	    //keep a cache of the latest value and subscribers
	    exports.topicCache = {};
	
	    //allow customization of the function used to serialize values for the topic cache
	    exports.serializer = ko.toJSON;
	
	    //wrap notifySubscribers passing topic first and caching latest value
	    exports.publish = function(topic, value) {
	        if (topic) {
	            //keep the value and a serialized version for comparison
	            exports.topicCache[topic] = {
	                value: value,
	                serialized: exports.serializer(value)
	            };
	            exports.notifySubscribers(value, topic);
	        }
	    };
	
	    //provide a subscribe API for the postbox that takes in the topic as first arg
	    existingSubscribe = exports.subscribe;
	    exports.subscribe = function(topic, action, target, initializeWithLatestValue) {
	        var subscription, current, existingDispose;
	
	        if (topic) {
	            if (typeof target === "boolean") {
	                initializeWithLatestValue = target;
	                target = undefined;
	            }
	
	            subscription = existingSubscribe.call(exports, action, target, topic);
				subscription.subId = ++subId;
				subscriptions[ subId ] = subscription;
	
	            if (initializeWithLatestValue) {
	                current = exports.topicCache[topic];
	
	                if (current !== undefined) {
	                    action.call(target, current.value);
	                }
	            }
	
				existingDispose = subscription.dispose;
				subscription.dispose = function() {
					delete subscriptions[subscription.subId];
					existingDispose.call(subscription);
				};
	
	            return subscription;
	        }
	    };
	
		//clean up all subscriptions and references
		exports.reset = function() {
			var subscription;
	
			for (var id in subscriptions) {
				if (subscriptions.hasOwnProperty(id)) {
					subscription = subscriptions[id];
	
					if (subscription && typeof subscription.dispose === "function") {
						subscription.dispose();
					}
				}
			}
	
			exports.topicCache = {};
		};
	
	    //by default publish when the previous cached value does not equal the new value
	    exports.defaultComparer = function(newValue, cacheItem) {
	        return cacheItem && exports.serializer(newValue) === cacheItem.serialized;
	    };
	
	    //augment observables/computeds with the ability to automatically publish updates on a topic
	    ko.subscribable.fn.publishOn = function(topic, skipInitialOrEqualityComparer, equalityComparer) {
	        var skipInitialPublish, subscription, existingDispose;
	
	        if (topic) {
	            //allow passing the equalityComparer as the second argument
	            if (typeof skipInitialOrEqualityComparer === "function") {
	                equalityComparer = skipInitialOrEqualityComparer;
	            } else {
	                skipInitialPublish = skipInitialOrEqualityComparer;
	            }
	
	            equalityComparer = equalityComparer || exports.defaultComparer;
	
	            //remove any existing subs
	            disposeTopicSubscription.call(this, topic, "publishOn");
	
	            //keep a reference to the subscription, so we can stop publishing
	            subscription = this.subscribe(function(newValue) {
					if (!equalityComparer.call(this, newValue, exports.topicCache[topic])) {
						exports.publish(topic, newValue);
					}
				}, this);
	
				//track the subscription in case of a reset
				subscription.id = ++subId;
				subscriptions[subId] = subscription;
	
				//ensure that we cleanup pointers to subscription on dispose
				existingDispose = subscription.dispose;
				subscription.dispose = function() {
					delete this.postboxSubs[topic].publishOn;
					delete subscriptions[subscription.id];
	
					existingDispose.call(subscription);
				}.bind(this);
	
				this.postboxSubs[topic].publishOn = subscription;
	
	            //do an initial publish
	            if (!skipInitialPublish) {
	                exports.publish(topic, this());
	            }
	        }
	
	        return this;
	    };
	
	    //handle disposing a subscription used to publish or subscribe to a topic
	    disposeTopicSubscription = function(topic, type) {
	        var subs = this.postboxSubs = this.postboxSubs || {};
	        subs[topic] = subs[topic] || {};
	
	        if (subs[topic][type]) {
	            subs[topic][type].dispose();
	        }
	    };
	
	    //discontinue automatically publishing on a topic
	    ko.subscribable.fn.stopPublishingOn = function(topic) {
	        disposeTopicSubscription.call(this, topic, "publishOn");
	
	        return this;
	    };
	
	    //augment observables/computeds to automatically be updated by notifications on a topic
	    ko.subscribable.fn.subscribeTo = function(topic, initializeWithLatestValueOrTransform, transform) {
	        var initializeWithLatestValue, current, callback, subscription, existingDispose,
	            self = this;
	
	        //allow passing the filter as the second argument
	        if (typeof initializeWithLatestValueOrTransform === "function") {
	            transform = initializeWithLatestValueOrTransform;
	        } else {
	            initializeWithLatestValue = initializeWithLatestValueOrTransform;
	        }
	
	        if (topic && ko.isWriteableObservable(this)) {
	            //remove any existing subs
	            disposeTopicSubscription.call(this, topic, "subscribeTo");
	
	            //if specified, apply a filter function in the subscription
	            callback = function(newValue) {
	                self(transform ? transform.call(self, newValue) : newValue);
	            };
	
				////keep a reference to the subscription, so we can unsubscribe, if necessary
				subscription = exports.subscribe(topic, callback);
				this.postboxSubs[topic].subscribeTo = subscription;
	
				//ensure that we cleanup pointers to subscription on dispose
				existingDispose = subscription.dispose;
				subscription.dispose = function() {
					delete this.postboxSubs[topic].subscribeTo;
					existingDispose.call(subscription);
				}.bind(this);
	
	            if (initializeWithLatestValue) {
	                current = exports.topicCache[topic];
	
	                if (current !== undefined) {
	                    callback(current.value);
	                }
	            }
	        }
	
	        return this;
	    };
	
	    //discontinue receiving updates on a topic
	    ko.subscribable.fn.unsubscribeFrom = function(topic) {
	        disposeTopicSubscription.call(this, topic, "subscribeTo");
	
	        return this;
	    };
	
	    // both subscribe and publish on the same topic
	    //   -allows the ability to sync an observable/writeable computed/observableArray between view models
	    //   -subscribeTo should really not use a filter function, as it would likely cause infinite recursion
	    ko.subscribable.fn.syncWith = function(topic, initializeWithLatestValue, skipInitialOrEqualityComparer, equalityComparer) {
	        this.subscribeTo(topic, initializeWithLatestValue).publishOn(topic, skipInitialOrEqualityComparer, equalityComparer);
	
	        return this;
	    };
	
	    ko.postbox = exports;
	}));


/***/ },
/* 121 */
/***/ function(module, exports) {

	"use strict";
	
	//Javasript name: My Date Time Picker
	//Date created: 16-Nov-2003 23:19
	//Creator: TengYong Ng
	//Website: http://www.rainforestnet.com
	//Copyright (c) 2003 TengYong Ng
	//FileName: DateTimePicker_css.js
	//Version: 2.2.4
	// Note: Permission given to use and modify this script in ANY kind of applications if
	//       header lines are left unchanged.
	//Permission is granted to redistribute and modify this javascript under a FreeBSD License.
	//New Css style version added by Yvan Lavoie (Québec, Canada) 29-Jan-2009
	//Formatted for JSLint compatibility by Labsmedia.com (30-Dec-2010)
	
	
	//Global variables
	
	window.winCal = undefined;
	window.dtToday = undefined;
	window.Cal = undefined;
	window.exDateTime = undefined; //Existing Date and Time
	window.selDate = undefined; //selected date. version 1.7
	window.calSpanID = "calBorder"; // span ID
	window.domStyle = null; // span DOM object with style
	window.cnLeft = "0"; //left coordinate of calendar span
	window.cnTop = "0"; //top coordinate of calendar span
	window.xpos = 0; // mouse x position
	window.ypos = 0; // mouse y position
	window.calHeight = 0; // calendar height
	window.CalWidth = "auto"; // calendar width
	window.CellWidth = 36; // width of day cell.
	window.TimeMode = 24; // TimeMode value. 12 or 24
	window.StartYear = parseInt(new Date().getFullYear()); //First Year in drop down year selection
	window.EndYear = 5; // The last year of pickable date. if current year is 2011, the last year that still picker will be 2016 (2011+5)
	window.CalPosOffsetX = -227; //X position offset relative to calendar icon, can be negative value
	window.CalPosOffsetY = -230; //Y position offset relative to calendar icon, can be negative value
	window.showMonthInHead = "display:none;";
	//Configurable parameters start
	window.SpanBorderColor = "#cccccc"; //span border color
	window.SpanBgColor = "#FFFFFF"; //span background color
	window.MonthYearColor = "#cc0033"; //Font Color of Month and Year in Calendar header.
	window.WeekHeadColor = "#b7c9d3"; //var WeekHeadColor="#18861B";//Background Color in Week header.
	window.WeekHeadBackground = "#ffffff"; //var WeekHeadColor="#18861B";//Background Color in Week header.
	window.SundayColor = ""; //var SundayColor="#C0F64F";//Background color of Sunday.
	window.SaturdayColor = ""; //Background color of Saturday.
	window.WeekDayColor = ""; //Background color of weekdays.
	window.FontColor = "blue"; //color of font in Calendar day cell.
	window.TodayColor = 'font-family:"TMSans-Bold",Helvetica,Arial,sans-serif;box-shadow:0 0 2px rgba(0,0,0,1);';
	window.SelDateColor = 'font-family:"TMSans-Bold",Helvetica,Arial,sans-serif;color:#fff;background:#179cdb;';
	window.YrSelColor = "#cc0033"; //color of font of Year selector.
	window.MthSelColor = "#cc0033"; //color of font of Month selector if "MonthSelector" is "arrow".
	window.HoverColor = "#E0FF38"; //color when mouse move over.
	window.DisableColor = "#999966"; //color of disabled cell.
	window.CalBgColor = "#ffffff"; //Background color of Calendar window.
	window.topSelectorBg = "#f1f4f6";
	
	window.WeekChar = 2; //number of character for week day. if 2 then Mo,Tu,We. if 3 then Mon,Tue,Wed.
	window.DateSeparator = "-"; //Date Separator, you can change it to "-" if you want.
	window.ShowLongMonth = true; //Show long month name in Calendar header. example: "January".
	window.ShowMonthYear = true; //Show Month and Year in Calendar header.
	window.ThemeBg = ""; //Background image of Calendar window.
	window.PrecedeZero = true; //Preceding zero [true|false]
	window.MondayFirstDay = false; //true:Use Monday as first day; false:Sunday as first day. [true|false]  //added in version 1.7
	window.UseImageFiles = false; //Use image files with "arrows" and "close" button
	window.imageFilesPath = "images2/";
	//Configurable parameters end
	
	//use the Month and Weekday in your preferred language.
	window.MonthName = ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"];
	window.WeekDayName1 = ["S", "M", "T", "W", "T", "F", "S"];
	window.WeekDayName2 = ["Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday"];
	
	//end Configurable parameters
	
	//end Global variable
	
	// Calendar prototype
	function Calendar(pDate, pCtrl) {
		//Properties
		this.Date = pDate.getDate(); //selected date
		this.Month = pDate.getMonth(); //selected month number
		this.Year = pDate.getFullYear(); //selected year in 4 digits
		this.Hours = pDate.getHours();
	
		if (pDate.getMinutes() < 10) {
			this.Minutes = "0" + pDate.getMinutes();
		} else {
			this.Minutes = pDate.getMinutes();
		}
	
		if (pDate.getSeconds() < 10) {
			this.Seconds = "0" + pDate.getSeconds();
		} else {
			this.Seconds = pDate.getSeconds();
		}
	
		this.MyWindow = winCal;
		this.Ctrl = pCtrl;
		this.Format = "ddMMyyyy";
		this.Separator = DateSeparator;
		this.ShowTime = false;
		this.Scroller = "DROPDOWN";
	
		if (pDate.getHours() < 12) {
			this.AMorPM = "AM";
		} else {
			this.AMorPM = "PM";
		}
	
		this.ShowSeconds = false;
		this.EnableDateMode = "";
	}
	
	Calendar.prototype.GetMonthIndex = function (shortMonthName) {
		for (var i = 0; i < 12; i += 1) {
			if (MonthName[i].substring(0, 3).toUpperCase() === shortMonthName.toUpperCase()) {
				return i;
			}
		}
	};
	
	Calendar.prototype.IncYear = function () {
		if (Cal.Year <= dtToday.getFullYear() + EndYear) Cal.Year += 1;
	};
	
	Calendar.prototype.DecYear = function () {
		if (Cal.Year > StartYear) Cal.Year -= 1;
	};
	
	Calendar.prototype.IncMonth = function () {
		if (Cal.Year <= dtToday.getFullYear() + EndYear) {
			Cal.Month += 1;
			if (Cal.Month >= 12) {
				Cal.Month = 0;
				Cal.IncYear();
			}
		}
	};
	
	Calendar.prototype.DecMonth = function () {
		if (Cal.Year >= StartYear) {
			Cal.Month -= 1;
			if (Cal.Month < 0) {
				Cal.Month = 11;
				Cal.DecYear();
			}
		}
	};
	
	Calendar.prototype.SwitchMth = function (intMth) {
		Cal.Month = parseInt(intMth, 10);
	};
	
	Calendar.prototype.SwitchYear = function (intYear) {
		Cal.Year = parseInt(intYear, 10);
	};
	
	Calendar.prototype.SetHour = function (intHour) {
		var MaxHour,
		    MinHour,
		    HourExp = new RegExp("^\\d\\d"),
		    SingleDigit = new RegExp("^\\d{1}$");
	
		if (TimeMode === 24) {
			MaxHour = 23;
			MinHour = 0;
		} else if (TimeMode === 12) {
			MaxHour = 12;
			MinHour = 1;
		} else {
			alert("TimeMode can only be 12 or 24");
		}
	
		if ((HourExp.test(intHour) || SingleDigit.test(intHour)) && parseInt(intHour, 10) > MaxHour) {
			intHour = MinHour;
		} else if ((HourExp.test(intHour) || SingleDigit.test(intHour)) && parseInt(intHour, 10) < MinHour) {
			intHour = MaxHour;
		}
	
		intHour = parseInt(intHour, 10);
		if (SingleDigit.test(intHour)) {
			intHour = "0" + intHour;
		}
	
		if (HourExp.test(intHour) && parseInt(intHour, 10) <= MaxHour && parseInt(intHour, 10) >= MinHour) {
			if (TimeMode === 12 && Cal.AMorPM === "PM") {
				if (parseInt(intHour, 10) === 12) {
					Cal.Hours = 12;
				} else {
					Cal.Hours = parseInt(intHour, 10) + 12;
				}
			} else if (TimeMode === 12 && Cal.AMorPM === "AM") {
				if (intHour === 12) {
					intHour -= 12;
				}
	
				Cal.Hours = parseInt(intHour, 10);
			} else if (TimeMode === 24) {
				Cal.Hours = parseInt(intHour, 10);
			}
		}
	};
	
	Calendar.prototype.SetMinute = function (intMin) {
		var MaxMin = 59,
		    MinMin = 0,
		    SingleDigit = new RegExp("\\d"),
		    SingleDigit2 = new RegExp("^\\d{1}$"),
		    MinExp = new RegExp("^\\d{2}$"),
		    strMin = 0;
	
		if ((MinExp.test(intMin) || SingleDigit.test(intMin)) && parseInt(intMin, 10) > MaxMin) {
			intMin = MinMin;
		} else if ((MinExp.test(intMin) || SingleDigit.test(intMin)) && parseInt(intMin, 10) < MinMin) {
			intMin = MaxMin;
		}
	
		strMin = intMin + "";
		if (SingleDigit2.test(intMin)) {
			strMin = "0" + strMin;
		}
	
		if ((MinExp.test(intMin) || SingleDigit.test(intMin)) && parseInt(intMin, 10) <= 59 && parseInt(intMin, 10) >= 0) {
			Cal.Minutes = strMin;
		}
	};
	
	Calendar.prototype.SetSecond = function (intSec) {
		var MaxSec = 59,
		    MinSec = 0,
		    SingleDigit = new RegExp("\\d"),
		    SingleDigit2 = new RegExp("^\\d{1}$"),
		    SecExp = new RegExp("^\\d{2}$"),
		    strSec = 0;
	
		if ((SecExp.test(intSec) || SingleDigit.test(intSec)) && parseInt(intSec, 10) > MaxSec) {
			intSec = MinSec;
		} else if ((SecExp.test(intSec) || SingleDigit.test(intSec)) && parseInt(intSec, 10) < MinSec) {
			intSec = MaxSec;
		}
	
		strSec = intSec + "";
		if (SingleDigit2.test(intSec)) {
			strSec = "0" + strSec;
		}
	
		if ((SecExp.test(intSec) || SingleDigit.test(intSec)) && parseInt(intSec, 10) <= 59 && parseInt(intSec, 10) >= 0) {
			Cal.Seconds = strSec;
		}
	};
	
	Calendar.prototype.SetAmPm = function (pvalue) {
		this.AMorPM = pvalue;
		if (pvalue === "PM") {
			this.Hours = parseInt(this.Hours, 10) + 12;
			if (this.Hours === 24) {
				this.Hours = 12;
			}
		} else if (pvalue === "AM") {
			this.Hours -= 12;
		}
	};
	
	Calendar.prototype.getShowHour = function () {
		var finalHour;
	
		if (TimeMode === 12) {
			if (parseInt(this.Hours, 10) === 0) {
				this.AMorPM = "AM";
				finalHour = parseInt(this.Hours, 10) + 12;
			} else if (parseInt(this.Hours, 10) === 12) {
				this.AMorPM = "PM";
				finalHour = 12;
			} else if (this.Hours > 12) {
				this.AMorPM = "PM";
				if (this.Hours - 12 < 10) {
					finalHour = "0" + (parseInt(this.Hours, 10) - 12);
				} else {
					finalHour = parseInt(this.Hours, 10) - 12;
				}
			} else {
				this.AMorPM = "AM";
				if (this.Hours < 10) {
					finalHour = "0" + parseInt(this.Hours, 10);
				} else {
					finalHour = this.Hours;
				}
			}
		} else if (TimeMode === 24) {
			if (this.Hours < 10) {
				finalHour = "0" + parseInt(this.Hours, 10);
			} else {
				finalHour = this.Hours;
			}
		}
	
		return finalHour;
	};
	
	Calendar.prototype.getShowAMorPM = function () {
		return this.AMorPM;
	};
	
	Calendar.prototype.GetMonthName = function (IsLong) {
		var Month = MonthName[this.Month];
		if (IsLong) {
			return Month;
		} else {
			return Month.substr(0, 3);
		}
	};
	
	Calendar.prototype.GetMonDays = function () {
		//Get number of days in a month
	
		var DaysInMonth = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
		if (Cal.IsLeapYear()) {
			DaysInMonth[1] = 29;
		}
	
		return DaysInMonth[this.Month];
	};
	
	Calendar.prototype.IsLeapYear = function () {
		if (this.Year % 4 === 0) {
			if (this.Year % 100 === 0 && this.Year % 400 !== 0) {
				return false;
			} else {
				return true;
			}
		} else {
			return false;
		}
	};
	
	Calendar.prototype.FormatDate = function (pDate) {
		var MonthDigit = this.Month + 1;
		if (PrecedeZero === true) {
			if (pDate < 10 && String(pDate).length === 1) //length checking added in version 2.2
				{
					pDate = "0" + pDate;
				}
			if (MonthDigit < 10) {
				MonthDigit = "0" + MonthDigit;
			}
		}
	
		switch (this.Format.toUpperCase()) {
			case "DDMMYYYY":
				return pDate + DateSeparator + MonthDigit + DateSeparator + this.Year;
			case "DDMMMYYYY":
				return pDate + DateSeparator + this.GetMonthName(false) + DateSeparator + this.Year;
			case "MMDDYYYY":
				return MonthDigit + DateSeparator + pDate + DateSeparator + this.Year;
			case "MMMDDYYYY":
				return this.GetMonthName(false) + DateSeparator + pDate + DateSeparator + this.Year;
			case "YYYYMMDD":
				return this.Year + DateSeparator + MonthDigit + DateSeparator + pDate;
			case "YYMMDD":
				return String(this.Year).substring(2, 4) + DateSeparator + MonthDigit + DateSeparator + pDate;
			case "YYMMMDD":
				return String(this.Year).substring(2, 4) + DateSeparator + this.GetMonthName(false) + DateSeparator + pDate;
			case "YYYYMMMDD":
				return this.Year + DateSeparator + this.GetMonthName(false) + DateSeparator + pDate;
			default:
				return pDate + DateSeparator + (this.Month + 1) + DateSeparator + this.Year;
		}
	};
	
	// end Calendar prototype
	
	function GenCell(pValue, pHighLight, pColor, pClickable) {
		//Generate table cell with value
		var PValue, PCellStr, PClickable, vTimeStr;
	
		if (!pValue) {
			PValue = "";
		} else {
			PValue = pValue;
		}
	
		if (pColor === undefined) pColor = CalBgColor;
	
		if (pClickable !== undefined) {
			PClickable = pClickable;
		} else {
			PClickable = true;
		}
	
		if (Cal.ShowTime) {
			vTimeStr = ' ' + Cal.Hours + ':' + Cal.Minutes;
			if (Cal.ShowSeconds) {
				vTimeStr += ':' + Cal.Seconds;
			}
			if (TimeMode === 12) {
				vTimeStr += ' ' + Cal.AMorPM;
			}
		} else {
			vTimeStr = "";
		}
	
		if (PValue !== "") {
			if (PClickable === true) {
				if (Cal.ShowTime === true) {
					PCellStr = "<td id='c" + PValue + "' class='calTD' style='text-align:center;cursor:pointer;" + pColor + "' onmousedown='selectDate(this," + PValue + ");'>" + PValue + "</td>";
				} else {
					PCellStr = "<td class='calTD' style='text-align:center;cursor:pointer;background-color:" + pColor + "' onmouseover='changeBorder(this, 0);' onmouseout=\"changeBorder(this, 1, '" + pColor + "');\" onClick=\"javascript:callback('" + Cal.Ctrl + "','" + Cal.FormatDate(PValue) + "');\">" + PValue + "</td>";
				}
			} else {
				PCellStr = "<td style='text-align:center;background-color:" + pColor + "' class='calTD'>" + PValue + "</td>";
			}
		} else {
			PCellStr = "<td style='text-align:center;background-color:" + pColor + "' class='calTD'>&nbsp;</td>";
		}
	
		return PCellStr;
	}
	
	function RenderCssCal(bNewCal) {
		if (typeof bNewCal === "undefined" || bNewCal !== true) {
			bNewCal = false;
		}
		var vCalHeader,
		    vCalData,
		    vCalTime = "",
		    vCalClosing = "",
		    winCalData = "",
		    CalDate,
		    i,
		    j,
		    SelectStr,
		    vDayCount = 0,
		    vFirstDay,
		    WeekDayName = [],
		    //Added version 1.7
		strCell,
		    showHour,
		    ShowArrows = false,
		    HourCellWidth = "35px",
		    //cell width with seconds.
	
		SelectAm,
		    SelectPm,
		    funcCalback,
		    headID,
		    e,
		    cssStr,
		    style,
		    cssText,
		    span;
	
		calHeight = 0; // reset the window height on refresh
	
		// Set the default cursor for the calendar
	
		winCalData = "<span style='cursor:auto;'>";
		vCalHeader = "<table style='background-color:" + CalBgColor + ";width:auto;padding:0;border:none;'><tbody>";
	
		//Table for Month & Year Selector
	
		vCalHeader += "<tr><td colspan='7'><table border='0' width='100%' cellpadding='0' cellspacing='0' style='border:none;padding:5px;'><tr>";
		//******************Month and Year selector in dropdown list************************
	
		if (Cal.Scroller === "DROPDOWN") {
			vCalHeader += "<td align='left' style='padding:10px 5px 10px 10px;margin:0;background:" + topSelectorBg + "'>\n";
			vCalHeader += "<select name='MonthSelector' id='MonthSelectorSelect' style='margin-bottom:5px; display: none;' onChange='javascript:Cal.SwitchMth(this.selectedIndex);RenderCssCal();'>";
			for (i = 0; i < 12; i += 1) {
				if (i === Cal.Month) {
					SelectStr = "Selected";
				} else {
					SelectStr = "";
				}
				vCalHeader += "<option " + SelectStr + " value=" + i + ">" + MonthName[i] + "</option>";
			}
			vCalHeader += '</select>';
	
			/* ul month for custom select */
			vCalHeader += '<span class="MonthSelectorTitle">' + MonthName[Cal.Month] + '</span>';
			vCalHeader += '<ul name="MonthSelector" class="MonthSelector" onChange="javascript:Cal.SwitchMth(this.selectedIndex);RenderCssCal();">';
			for (i = 0; i < 12; i += 1) {
				if (i === Cal.Month) {
					SelectStr = "Selected";
				} else {
					SelectStr = "";
				}
				vCalHeader += '<li>' + MonthName[i] + '</li>';
			}
			vCalHeader += "</ul>";
			vCalHeader += "</td>";
			//Year selector
	
			vCalHeader += "<td align='right' style='padding:10px 10px 10px 5px;margin:0;background:" + topSelectorBg + "'>";
			vCalHeader += "<select name='YearSelector' style='display:none; margin-bottom:5px;' size='1' onChange='javascript:Cal.SwitchYear(this.value);RenderCssCal();'>";
			for (i = StartYear; i <= dtToday.getFullYear() + EndYear; i += 1) {
				if (i === Cal.Year) {
					SelectStr = 'selected="selected"';
				} else {
					SelectStr = '';
				}
				vCalHeader += "<option " + SelectStr + " value=" + i + ">" + i + "</option>\n";
			}
			vCalHeader += "</select>";
	
			/* ul year for custom select */
			vCalHeader += '<span class="MonthSelectorTitle Year">' + Cal.Year + '</span>';
			vCalHeader += '<ul name="YearSelector" class="MonthSelector Year" onChange="javascript:Cal.SwitchMth(this.selectedIndex);RenderCssCal();">';
			for (i = StartYear; i <= dtToday.getFullYear() + EndYear; i += 1) {
				if (i === Cal.Year) {
					SelectStr = 'selected="selected"';
				} else {
					SelectStr = '';
				}
				vCalHeader += '<li>' + i + '</li>';
			}
			vCalHeader += "</ul>";
			vCalHeader += "</td>\n";
			calHeight += 30;
		}
	
		//******************End Month and Year selector in dropdown list*********************
	
		//******************Month and Year selector in arrow*********************************
	
		else if (Cal.Scroller === "ARROW") {
				if (UseImageFiles) {
					vCalHeader += "<td><img onmousedown='javascript:Cal.DecYear();RenderCssCal();' src='" + imageFilesPath + "cal_fastreverse.gif' width='13px' height='9' onmouseover='changeBorder(this, 0)' onmouseout='changeBorder(this, 1)' style='border:1px solid white'></td>\n"; //Year scroller (decrease 1 year)
					vCalHeader += "<td><img onmousedown='javascript:Cal.DecMonth();RenderCssCal();' src='" + imageFilesPath + "cal_reverse.gif' width='13px' height='9' onmouseover='changeBorder(this, 0)' onmouseout='changeBorder(this, 1)' style='border:1px solid white'></td>\n"; //Month scroller (decrease 1 month)
					vCalHeader += "<td width='70%' class='calR' style='color:" + YrSelColor + "'>" + Cal.GetMonthName(ShowLongMonth) + " " + Cal.Year + "</td>"; //Month and Year
					vCalHeader += "<td><img onmousedown='javascript:Cal.IncMonth();RenderCssCal();' src='" + imageFilesPath + "cal_forward.gif' width='13px' height='9' onmouseover='changeBorder(this, 0)' onmouseout='changeBorder(this, 1)' style='border:1px solid white'></td>\n"; //Month scroller (increase 1 month)
					vCalHeader += "<td><img onmousedown='javascript:Cal.IncYear();RenderCssCal();' src='" + imageFilesPath + "cal_fastforward.gif' width='13px' height='9' onmouseover='changeBorder(this, 0)' onmouseout='changeBorder(this, 1)' style='border:1px solid white'></td>\n"; //Year scroller (increase 1 year)
					calHeight += 22;
				} else {
					vCalHeader += "<td><span id='dec_year' title='reverse year' onmousedown='javascript:Cal.DecYear();RenderCssCal();' onmouseover='changeBorder(this, 0)' onmouseout='changeBorder(this, 1)' style='border:1px solid white; color:" + YrSelColor + "'>-</span></td>"; //Year scroller (decrease 1 year)
					vCalHeader += "<td><span id='dec_month' title='reverse month' onmousedown='javascript:Cal.DecMonth();RenderCssCal();' onmouseover='changeBorder(this, 0)' onmouseout='changeBorder(this, 1)' style='border:1px solid white'>&lt;</span></td>\n"; //Month scroller (decrease 1 month)
					vCalHeader += "<td width='70%' class='calR' style='color:" + YrSelColor + "'>" + Cal.GetMonthName(ShowLongMonth) + " " + Cal.Year + "</td>\n"; //Month and Year
					vCalHeader += "<td><span id='inc_month' title='forward month' onmousedown='javascript:Cal.IncMonth();RenderCssCal();' onmouseover='changeBorder(this, 0)' onmouseout='changeBorder(this, 1)' style='border:1px solid white'>&gt;</span></td>\n"; //Month scroller (increase 1 month)
					vCalHeader += "<td><span id='inc_year' title='forward year' onmousedown='javascript:Cal.IncYear();RenderCssCal();'  onmouseover='changeBorder(this, 0)' onmouseout='changeBorder(this, 1)' style='border:1px solid white; color:" + YrSelColor + "'>+</span></td>\n"; //Year scroller (increase 1 year)
					calHeight += 22;
				}
			}
	
		vCalHeader += "</tr></table></td></tr>";
	
		//******************End Month and Year selector in arrow******************************
	
		//Calendar header shows Month and Year
		if (ShowMonthYear && Cal.Scroller === "DROPDOWN") {
			vCalHeader += "<tr><td colspan='7' class='calR' style='color:" + MonthYearColor + "'>" + Cal.GetMonthName(ShowLongMonth) + " " + Cal.Year + "</td></tr>";
			calHeight += 19;
		}
	
		//Week day header
	
		vCalHeader += "<tr><td colspan=\"7\"><table style='border-spacing:0;border-collapse:collapse;box-sizing:border-box; margin: 5px 5px 5px 4px;'><tr>";
		if (MondayFirstDay === true) {
			WeekDayName = WeekDayName2;
		} else {
			WeekDayName = WeekDayName1;
		}
		for (i = 0; i < 7; i += 1) {
			vCalHeader += "<td style='background-color:" + WeekHeadBackground + ";width:" + CellWidth + "px;color:" + WeekHeadColor + "' class='calTD'>" + WeekDayName[i].substr(0, WeekChar) + "</td>";
		}
	
		calHeight += 19;
		vCalHeader += "</tr>";
		//Calendar detail
		CalDate = new Date(Cal.Year, Cal.Month);
		CalDate.setDate(1);
	
		vFirstDay = CalDate.getDay();
	
		//Added version 1.7
		if (MondayFirstDay === true) {
			vFirstDay -= 1;
			if (vFirstDay === -1) {
				vFirstDay = 6;
			}
		}
	
		//Added version 1.7
		vCalData = "<tr>";
		calHeight += 19;
		for (i = 0; i < vFirstDay; i += 1) {
			vCalData = vCalData + GenCell();
			vDayCount = vDayCount + 1;
		}
	
		//Added version 1.7
		for (j = 1; j <= Cal.GetMonDays(); j += 1) {
			if (vDayCount % 7 === 0 && j > 1) {
				vCalData = vCalData + "<tr>";
			}
	
			vDayCount = vDayCount + 1;
			//added version 2.1.2
			if (Cal.EnableDateMode === "future" && (j < dtToday.getDate() && Cal.Month === dtToday.getMonth() && Cal.Year === dtToday.getFullYear() || Cal.Month < dtToday.getMonth() && Cal.Year === dtToday.getFullYear() || Cal.Year < dtToday.getFullYear())) {
				strCell = GenCell(j, false, DisableColor, false); //Before today's date is not clickable
			} else if (Cal.EnableDateMode === "past" && (j >= dtToday.getDate() && Cal.Month === dtToday.getMonth() && Cal.Year === dtToday.getFullYear() || Cal.Month > dtToday.getMonth() && Cal.Year === dtToday.getFullYear() || Cal.Year > dtToday.getFullYear())) {
				strCell = GenCell(j, false, DisableColor, false); //After today's date is not clickable
			}
			//if End Year + Current Year = Cal.Year. Disable.
			else if (Cal.Year > dtToday.getFullYear() + EndYear) {
					strCell = GenCell(j, false, DisableColor, false);
				} else if (j === dtToday.getDate() && Cal.Month === dtToday.getMonth() && Cal.Year === dtToday.getFullYear()) {
					strCell = GenCell(j, true, TodayColor); //Highlight today's date
				} else {
					if (j === selDate.getDate() && Cal.Month === selDate.getMonth() && Cal.Year === selDate.getFullYear()) {
						//modified version 1.7
						strCell = GenCell(j, true, SelDateColor);
					} else {
						if (MondayFirstDay === true) {
							if (vDayCount % 7 === 0) {
								strCell = GenCell(j, false, SundayColor);
							} else if ((vDayCount + 1) % 7 === 0) {
								strCell = GenCell(j, false, SaturdayColor);
							} else {
								strCell = GenCell(j, null, WeekDayColor);
							}
						} else {
							if (vDayCount % 7 === 0) {
								strCell = GenCell(j, false, SaturdayColor);
							} else if ((vDayCount + 6) % 7 === 0) {
								strCell = GenCell(j, false, SundayColor);
							} else {
								strCell = GenCell(j, null, WeekDayColor);
							}
						}
					}
				}
	
			vCalData = vCalData + strCell;
	
			if (vDayCount % 7 === 0 && j < Cal.GetMonDays()) {
				vCalData = vCalData + "</tr>";
				calHeight += 19;
			}
		}
	
		// finish the table proper
	
		if (vDayCount % 7 !== 0) {
			while (vDayCount % 7 !== 0) {
				vCalData = vCalData + GenCell();
				vDayCount = vDayCount + 1;
			}
		}
	
		vCalData = vCalData + "</table></td></tr>";
	
		//Time picker
		if (Cal.ShowTime === true) {
			showHour = Cal.getShowHour();
	
			if (Cal.ShowSeconds === false && TimeMode === 24) {
				ShowArrows = true;
				HourCellWidth = "10px";
			}
	
			vCalTime = "<tr><td colspan='7' style=\"text-align:center;\"><table border='0' width='100%' cellpadding='0' cellspacing='0'><tbody><tr><td height='5px' width='" + HourCellWidth + "'>&nbsp;</td>";
	
			if (ShowArrows && UseImageFiles) //this is where the up and down arrow control the hour.
				{
					vCalTime += "<td style='vertical-align:middle;'><table cellspacing='0' cellpadding='0' style='line-height:0pt;width:100%;'><tr><td style='text-align:center;'><img onclick='nextStep(\"Hour\", \"plus\");' onmousedown='startSpin(\"Hour\", \"plus\");' onmouseup='stopSpin();' src='" + imageFilesPath + "cal_plus.gif' width='13px' height='9px' onmouseover='changeBorder(this, 0)' onmouseout='changeBorder(this, 1)' style='border:1px solid white'></td></tr><tr><td style='text-align:center;'><img onclick='nextStep(\"Hour\", \"minus\");' onmousedown='startSpin(\"Hour\", \"minus\");' onmouseup='stopSpin();' src='" + imageFilesPath + "cal_minus.gif' width='13px' height='9px' onmouseover='changeBorder(this, 0)' onmouseout='changeBorder(this, 1)' style='border:1px solid white'></td></tr></table></td>\n";
				}
	
			vCalTime += "<td style='border-top:1px solid #b7c9d3;'><input type='text' name='hour' maxlength=2 size=1 style='width:auto;padding:5px 10px;margin:10px auto;float:right;' value=" + showHour + " onkeyup=\"javascript:Cal.SetHour(this.value)\">";
			vCalTime += "</td><td style='font-weight:bold;text-align:center;padding:0 3px;border-top:1px solid #b7c9d3;'>:</td><td style='border-top:1px solid #b7c9d3;'>";
			vCalTime += "<input type='text' name='minute' maxlength=2 size=1 style='border-top:1px solid #b7c9d3; width:auto;padding:5px 10px;margin:0 auto;float:left;' value=" + Cal.Minutes + " onkeyup=\"javascript:Cal.SetMinute(this.value)\">";
	
			if (Cal.ShowSeconds) {
				vCalTime += "</td><td style='font-weight:bold;border-top:1px solid #b7c9d3;'>:</td><td style='border-top:1px solid #b7c9d3;'>";
				vCalTime += "<input type='text' name='second' maxlength=2 size=1 style='width:auto;padding:5px 10px;margin:0 auto;float:left;' value=" + Cal.Seconds + " onkeyup=\"javascript:Cal.SetSecond(parseInt(this.value,10))\">";
			}
	
			if (TimeMode === 12) {
				SelectAm = Cal.AMorPM === "AM" ? "Selected" : "";
				SelectPm = Cal.AMorPM === "PM" ? "Selected" : "";
	
				vCalTime += "</td><td>";
				vCalTime += "<select name=\"ampm\" onChange=\"javascript:Cal.SetAmPm(this.options[this.selectedIndex].value);\">\n";
				vCalTime += "<option " + SelectAm + " value=\"AM\">AM</option>";
				vCalTime += "<option " + SelectPm + " value=\"PM\">PM<option>";
				vCalTime += "</select>";
			}
	
			if (ShowArrows && UseImageFiles) //this is where the up and down arrow to change the "Minute".
				{
					vCalTime += "</td>\n<td style='vertical-align:middle;'><table cellspacing='0' cellpadding='0' style='line-height:0pt;width:100%'><tr><td style='text-align:center;'><img onclick='nextStep(\"Minute\", \"plus\");' onmousedown='startSpin(\"Minute\", \"plus\");' onmouseup='stopSpin();' src='" + imageFilesPath + "cal_plus.gif' width='13px' height='9px' onmouseover='changeBorder(this, 0)' onmouseout='changeBorder(this, 1)' style='border:1px solid white'></td></tr><tr><td style='text-align:center;'><img onmousedown='startSpin(\"Minute\", \"minus\");' onmouseup='stopSpin();' onclick='nextStep(\"Minute\",\"minus\");' src='" + imageFilesPath + "cal_minus.gif' width='13px' height='9px' onmouseover='changeBorder(this, 0)' onmouseout='changeBorder(this, 1)' style='border:1px solid white'></td></tr></table>";
				}
	
			vCalTime += "</td>\n<td align='right' valign='bottom' width='" + HourCellWidth + "px'></td></tr>";
			vCalTime += "<tr><td height='5px' width='" + HourCellWidth + "'>&nbsp;</td><td colspan='3' style='text-align:center;border-top:1px solid #b7c9d3;'><input onClick='javascript:closewin(\"" + Cal.Ctrl + "\");'  type=\"button\" value=\"OK\">&nbsp;<input onClick='javascript:winclose()' type=\"button\" value=\"Cancel\"></td><td height='5px' width='" + HourCellWidth + "'>&nbsp;</td></tr>";
		} else //if not to show time.
			{
				vCalTime += "\n<tr>\n<td colspan='7' style=\"text-align:right;\">";
				//close button
				if (UseImageFiles) {
					vCalClosing += "<img onmousedown='javascript:closewin(\"" + Cal.Ctrl + "\"); stopSpin();' src='" + imageFilesPath + "cal_close.gif' width='16px' height='14px' onmouseover='changeBorder(this,0)' onmouseout='changeBorder(this, 1)' style='border:1px solid white'></td>";
				} else {
					vCalClosing += "<span id='close_cal' title='close'onmousedown='javascript:closewin(\"" + Cal.Ctrl + "\");stopSpin();' onmouseover='changeBorder(this, 0)'onmouseout='changeBorder(this, 1)' style='border:1px solid white; font-family: Arial;font-size: 10pt;'>x</span></td>";
				}
				vCalClosing += "</tr>";
			}
		vCalClosing += "</tbody></table></td></tr>";
		calHeight += 31;
		vCalClosing += "</tbody></table>\n</span>";
	
		//end time picker
		funcCalback = "function callback(id, datum) {";
		funcCalback += " var CalId = document.getElementById(id);if (datum=== 'undefined') { var d = new Date(); datum = d.getDate() + '/' +(d.getMonth()+1) + '/' + d.getFullYear(); } window.calDatum=datum;CalId.value=datum;";
		funcCalback += " if(Cal.ShowTime){";
		funcCalback += " CalId.value+='T'+Cal.getShowHour()+':'+Cal.Minutes+':00Z';";
		funcCalback += " if (Cal.ShowSeconds)  CalId.value+=':'+Cal.Seconds;";
		funcCalback += " if (TimeMode === 12)  CalId.value+=''+Cal.getShowAMorPM();";
		funcCalback += "}if(CalId.onchange!=undefined) CalId.onchange();CalId.focus();winCal.style.visibility='hidden'; $(CalId).trigger('change')}";
	
		// determines if there is enough space to open the cal above the position where it is called
		if (ypos > calHeight) {
			ypos = ypos - calHeight;
		}
	
		if (!winCal) {
			headID = document.getElementsByTagName("head")[0];
	
			// add javascript function to the span cal
			e = document.createElement("script");
			e.type = "text/javascript";
			e.language = "javascript";
			e.text = funcCalback;
			headID.appendChild(e);
			// add stylesheet to the span cal
	
			cssStr = ".calTD {text-align: center; border:0; width:36px; height:36px; border-radius:50%}\n";
			cssStr += "#calBorder {font-size: 14px; border-radius:0px 0px 4px 4px}\n";
			cssStr += ".calR {text-align: center; font-weight: bold;" + showMonthInHead + "}\n";
			cssStr += "#calBorder table, #calBorder table th, #calBorder table td {margin:0; padding:0; border-spacing:0; border-collapse:collapse; border:0; box-sizing:border-box; -webkit-user-select: none; -moz-user-select: none; -ms-user-select: none; user-select: none;}\n";
			cssStr += "#calBorder input, #calBorder select {height:auto;}\n";
			cssStr += "#calBorder select { -webkit-appearance: menulist; -moz-appearance: menulist;}\n";
			cssStr += "#calBorder table tr:nth-child(even) {background: none;}\n";
			cssStr += '#calBorder input[type="button"], #calBorderinput[type="reset"], #calBorder input[type="submit"] {margin-top: 15px; font-family:"TMSans-Bold",Helvetica,Arial,sans-serif; font-size:12px; width:45%; border:2px solid #b7c9d3; border-radius:4px; text-transform:uppercase; color:#b7c9d3; padding:4px; margin-bottom:12px;}\n';
			cssStr += '#calBorder .MonthSelectorTitle {position: relative; font-family: "TMSans-Bold", Arial, serif; font-size: 14px; color: #b7c9d3; display: block; float: left; margin-left: 5px; padding-right:24px; -webkit-transition: color 0.3s ease-in-out; -o-transition: color 0.3s ease-in-out; transition: color 0.3s ease-in-out; -webkit-user-select: none; -moz-user-select: none; -ms-user-select: none; user-select: none;}\n';
			cssStr += '#calBorder .MonthSelectorTitle:hover {color: #189ddc; cursor: pointer;}\n';
			cssStr += '#calBorder .MonthSelectorTitle:hover:before {opacity:1;}\n';
			cssStr += '#calBorder .MonthSelectorTitle:hover:after {opacity:0;}\n';
			cssStr += '#calBorder .MonthSelectorTitle:hover:after {color: #189ddc; cursor: pointer;}\n';
			cssStr += '#calBorder .MonthSelectorTitle.Year {float: right;}\n';
			cssStr += '#calBorder .MonthSelectorTitle:before, #calBorder .MonthSelectorTitle:after {content: ""; position: absolute; right: 0; top: 50%; width: 15px; height: 10px; margin-top: -5px; background-position: center center; background-repeat: no-repeat; -webkit-transition: opacity 0.2s ease-in-out; -o-transition: opacity 0.2s ease-in-out; transition: opacity 0.2s ease-in-out;}\n';
			cssStr += '#calBorder .MonthSelectorTitle:before {opacity:0; background: url("http://developer.ticketmaster.com/assets/widgets/1.0.0/img/small-shevron-hover.svg") center center no-repeat;\n}';
			cssStr += '#calBorder .MonthSelectorTitle:after {background: url("http://developer.ticketmaster.com/assets/widgets/1.0.0/img/small-shevron.svg") center center no-repeat;}\n';
			cssStr += '#calBorder ul.MonthSelector {display: none; background:#b7c9d2; margin-bottom:5px; font-family: "TMSans-Bold", Arial, serif; font-size: 14px; padding: 10px 15px; margin:0; top:35px; left:0; position: absolute;}\n';
			cssStr += '#calBorder ul.MonthSelector.show {display: block;}\n';
			cssStr += '#calBorder ul.MonthSelector.Year {left:auto; right:0; padding: 10px 34px;}\n';
			cssStr += '#calBorder ul.MonthSelector.Year.show {display: block;}\n';
			cssStr += '#calBorder ul.MonthSelector li { font-family: "TMSans-Bold", Arial, serif; font-size: 14px; margin:0; padding:0; line-height:27px; color: #fff; -webkit-user-select: none; -moz-user-select: none; -ms-user-select: none; user-select: none;}\n';
			cssStr += '#calBorder ul.MonthSelector li:hover {color: #189ddc; cursor: pointer;}\n';
			cssStr += '#calOverlay {width: 100%; height: 100%; position: fixed; top: 0; left: 0; display: none;}\n';
			cssStr += '#calOverlay.show {display: block;}\n';
	
			style = document.createElement("style");
			style.type = "text/css";
			style.rel = "stylesheet";
			if (style.styleSheet) {
				// IE
				style.styleSheet.cssText = cssStr;
			} else {
				// w3c
				cssText = document.createTextNode(cssStr);
				style.appendChild(cssText);
			}
	
			headID.appendChild(style);
			// create the outer frame that allows the cal. to be moved
			span = document.createElement("span");
			span.id = calSpanID;
			span.style.position = "absolute";
			span.style.left = xpos + CalPosOffsetX + 'px';
			span.style.top = ypos - CalPosOffsetY + 'px';
			span.style.width = CalWidth + 'px';
			span.style.border = "solid 1px " + SpanBorderColor;
			span.style.padding = "0";
			span.style.cursor = "move";
			span.style.backgroundColor = SpanBgColor;
			span.style.zIndex = 1;
			var overlay = document.createElement("div");
			overlay.id = "calOverlay";
			overlay.classList.add("show");
			document.body.appendChild(span);
			document.body.appendChild(overlay);
			winCal = document.getElementById(calSpanID);
		} else {
			winCal.style.visibility = "visible";
			winCal.style.Height = calHeight;
	
			// set the position for a new calendar only
			if (bNewCal === true) {
				winCal.style.left = xpos + CalPosOffsetX + 'px';
				winCal.style.top = ypos - CalPosOffsetY + 'px';
			}
		}
	
		winCal.innerHTML = winCalData + vCalHeader + vCalData + vCalTime + vCalClosing;
		return true;
	}
	
	function NewCssCal(pCtrl, pFormat, pScroller, pShowTime, pTimeMode, pShowSeconds, pEnableDateMode) {
		// get current date and time
	
		dtToday = new Date();
		Cal = new Calendar(dtToday);
	
		if (pShowTime !== undefined) {
			if (pShowTime) {
				Cal.ShowTime = true;
			} else {
				Cal.ShowTime = false;
			}
	
			if (pTimeMode) {
				pTimeMode = parseInt(pTimeMode, 10);
			}
			if (pTimeMode === 12 || pTimeMode === 24) {
				TimeMode = pTimeMode;
			} else {
				TimeMode = 24;
			}
	
			if (pShowSeconds !== undefined) {
				if (pShowSeconds) {
					Cal.ShowSeconds = true;
				} else {
					Cal.ShowSeconds = false;
				}
			} else {
				Cal.ShowSeconds = false;
			}
		}
	
		if (pCtrl !== undefined) {
			Cal.Ctrl = pCtrl;
		}
	
		if (pFormat !== undefined && pFormat !== "") {
			Cal.Format = pFormat.toUpperCase();
		} else {
			Cal.Format = "MMDDYYYY";
		}
	
		if (pScroller !== undefined && pScroller !== "") {
			if (pScroller.toUpperCase() === "ARROW") {
				Cal.Scroller = "ARROW";
			} else {
				Cal.Scroller = "DROPDOWN";
			}
		}
	
		if (pEnableDateMode !== undefined && (pEnableDateMode === "future" || pEnableDateMode === "past")) {
			Cal.EnableDateMode = pEnableDateMode;
		}
	
		exDateTime = document.getElementById(pCtrl).value; //Existing Date Time value in textbox.
	
		if (exDateTime) {
			//Parse existing Date String
			var Sp1 = exDateTime.indexOf(DateSeparator, 0),
			    //Index of Date Separator 1
			Sp2 = exDateTime.indexOf(DateSeparator, parseInt(Sp1, 10) + 1),
			    //Index of Date Separator 2
			tSp1,
			    //Index of Time Separator 1
			tSp2,
			    //Index of Time Separator 2
			strMonth,
			    strDate,
			    strYear,
			    intMonth,
			    YearPattern,
			    strHour,
			    strMinute,
			    strSecond,
			    winHeight,
			    offset = parseInt(Cal.Format.toUpperCase().lastIndexOf("M"), 10) - parseInt(Cal.Format.toUpperCase().indexOf("M"), 10) - 1,
			    strAMPM = "";
			//parse month
	
			if (Cal.Format.toUpperCase() === "DDMMYYYY" || Cal.Format.toUpperCase() === "DDMMMYYYY") {
				if (DateSeparator === "") {
					strMonth = exDateTime.substring(2, 4 + offset);
					strDate = exDateTime.substring(0, 2);
					strYear = exDateTime.substring(4 + offset, 8 + offset);
				} else {
					if (exDateTime.indexOf("D*") !== -1) {
						//DTG
						strMonth = exDateTime.substring(8, 11);
						strDate = exDateTime.substring(0, 2);
						strYear = "20" + exDateTime.substring(11, 13); //Hack, nur für Jahreszahlen ab 2000
					} else {
						strMonth = exDateTime.substring(Sp1 + 1, Sp2);
						strDate = exDateTime.substring(0, Sp1);
						strYear = exDateTime.substring(Sp2 + 1, Sp2 + 5);
					}
				}
			} else if (Cal.Format.toUpperCase() === "MMDDYYYY" || Cal.Format.toUpperCase() === "MMMDDYYYY") {
				if (DateSeparator === "") {
					strMonth = exDateTime.substring(0, 2 + offset);
					strDate = exDateTime.substring(2 + offset, 4 + offset);
					strYear = exDateTime.substring(4 + offset, 8 + offset);
				} else {
					strMonth = exDateTime.substring(0, Sp1);
					strDate = exDateTime.substring(Sp1 + 1, Sp2);
					strYear = exDateTime.substring(Sp2 + 1, Sp2 + 5);
				}
			} else if (Cal.Format.toUpperCase() === "YYYYMMDD" || Cal.Format.toUpperCase() === "YYYYMMMDD") {
				if (DateSeparator === "") {
					strMonth = exDateTime.substring(4, 6 + offset);
					strDate = exDateTime.substring(6 + offset, 8 + offset);
					strYear = exDateTime.substring(0, 4);
				} else {
					strMonth = exDateTime.substring(Sp1 + 1, Sp2);
					strDate = exDateTime.substring(Sp2 + 1, Sp2 + 3);
					strYear = exDateTime.substring(0, Sp1);
				}
			} else if (Cal.Format.toUpperCase() === "YYMMDD" || Cal.Format.toUpperCase() === "YYMMMDD") {
				if (DateSeparator === "") {
					strMonth = exDateTime.substring(2, 4 + offset);
					strDate = exDateTime.substring(4 + offset, 6 + offset);
					strYear = exDateTime.substring(0, 2);
				} else {
					strMonth = exDateTime.substring(Sp1 + 1, Sp2);
					strDate = exDateTime.substring(Sp2 + 1, Sp2 + 3);
					strYear = exDateTime.substring(0, Sp1);
				}
			}
	
			if (isNaN(strMonth)) {
				intMonth = Cal.GetMonthIndex(strMonth);
			} else {
				intMonth = parseInt(strMonth, 10) - 1;
			}
			if (parseInt(intMonth, 10) >= 0 && parseInt(intMonth, 10) < 12) {
				Cal.Month = intMonth;
			}
			//end parse month
	
			//parse year
			YearPattern = /^\d{4}$/;
			if (YearPattern.test(strYear)) {
				if (parseInt(strYear, 10) >= StartYear && parseInt(strYear, 10) <= dtToday.getFullYear() + EndYear) Cal.Year = parseInt(strYear, 10);
			}
			//end parse year
	
			//parse Date
			if (parseInt(strDate, 10) <= Cal.GetMonDays() && parseInt(strDate, 10) >= 1) {
				Cal.Date = strDate;
			}
			//end parse Date
	
			//parse time
	
			if (Cal.ShowTime === true) {
				//parse AM or PM
				if (TimeMode === 12) {
					strAMPM = exDateTime.substring(exDateTime.length - 2, exDateTime.length);
					Cal.AMorPM = strAMPM;
				}
	
				tSp1 = exDateTime.indexOf(":", 0);
				tSp2 = exDateTime.indexOf(":", parseInt(tSp1, 10) + 1);
	
				if (tSp1 > 0) {
					strHour = exDateTime.substring(tSp1, tSp1 - 2);
					Cal.SetHour(strHour);
					strMinute = exDateTime.substring(tSp1 + 1, tSp1 + 3);
					Cal.SetMinute(strMinute);
					strSecond = exDateTime.substring(tSp2 + 1, tSp2 + 3);
					Cal.SetSecond(strSecond);
				} else if (exDateTime.indexOf("D*") !== -1) {
					//DTG
					strHour = exDateTime.substring(2, 4);
					Cal.SetHour(strHour);
					strMinute = exDateTime.substring(4, 6);
					Cal.SetMinute(strMinute);
				}
			}
		}
		selDate = new Date(Cal.Year, Cal.Month, Cal.Date); //version 1.7
		RenderCssCal(true);
	}
	
	function closewin(id) {
		if (Cal.ShowTime === true) {
			var MaxYear = dtToday.getFullYear() + EndYear;
			var beforeToday = Cal.Date < dtToday.getDate() && Cal.Month === dtToday.getMonth() && Cal.Year === dtToday.getFullYear() || Cal.Month < dtToday.getMonth() && Cal.Year === dtToday.getFullYear() || Cal.Year < dtToday.getFullYear();
	
			if (Cal.Year <= MaxYear && Cal.Year >= StartYear && Cal.Month === selDate.getMonth() && Cal.Year === selDate.getFullYear()) {
				if (Cal.EnableDateMode === "future") {
					if (beforeToday === false) {
						callback(id, Cal.FormatDate(Cal.Date));
					}
				} else callback(id, Cal.FormatDate(Cal.Date));
			}
		}
		var CalId = document.getElementById(id);
		CalId.focus();
		winCal.style.visibility = 'hidden';
		document.getElementById('calOverlay').classList.remove('show');
		var activeIcons = document.querySelectorAll('.dt-ico');
		var aiCountLenght = activeIcons.length;
		for (var aiCount = 0; aiCount < aiCountLenght; ++aiCount) {
			activeIcons[aiCount].classList.remove('active');
		}
	}
	
	function winclose() {
		winCal.style.visibility = 'hidden';
		document.getElementById('calOverlay').classList.remove('show');
		var activeIcons = document.querySelectorAll('.dt-ico');
		var aiCountLenght = activeIcons.length;
		for (var aiCount = 0; aiCount < aiCountLenght; ++aiCount) {
			activeIcons[aiCount].classList.remove('active');
		}
	}
	
	function changeBorder(element, col, oldBgColor) {
		if (col === 0) {
			element.style.background = HoverColor;
			element.style.borderColor = "black";
			element.style.cursor = "pointer";
		} else {
			if (oldBgColor) {
				element.style.background = oldBgColor;
			} else {
				element.style.background = "white";
			}
			element.style.borderColor = "white";
			element.style.cursor = "auto";
		}
	}
	
	function selectDate(element, date) {
		Cal.Date = date;
		selDate = new Date(Cal.Year, Cal.Month, Cal.Date);
		element.style.background = SelDateColor;
		RenderCssCal();
	}
	
	function findPos(obj) {
		var curleft = 0,
		    curtop = 0;
		if (obj.offsetParent) {
			do {
				curleft += obj.offsetLeft;
				curtop += obj.offsetTop;
			} while (obj = obj.offsetParent);
			return { x: curleft, y: curtop };
		}
		return undefined;
	}
	
	function pickIt(evt) {
		var objectID, dom, de, b;
		// accesses the element that generates the event and retrieves its ID
		if (document.addEventListener) {
			// w3c
			objectID = evt.target.id;
			/*
	   if (objectID.indexOf(calSpanID) !== -1)
	   {
	   dom = document.getElementById(objectID);
	   cnLeft = evt.pageX;
	   cnTop = evt.pageY;
	  		 if (dom.offsetLeft)
	   {
	   cnLeft = (cnLeft - dom.offsetLeft);
	   cnTop = (cnTop - dom.offsetTop);
	   }
	   }
	   */
			// get mouse position on click
			/*
	   xpos = (evt.pageX);
	   ypos = (evt.pageY);
	   */
			if (objectID == '') {
				xpos = findPos(evt.target).x;
				ypos = findPos(evt.target).y;
			}
		} else {
			// IE
			objectID = event.srcElement.id;
			cnLeft = event.offsetX;
			cnTop = event.offsetY;
	
			// get mouse position on click
			de = document.documentElement;
			b = document.body;
	
			xpos = event.clientX + (de.scrollLeft || b.scrollLeft) - (de.clientLeft || 0);
			ypos = event.clientY + (de.scrollTop || b.scrollTop) - (de.clientTop || 0);
		}
	
		// verify if this is a valid element to pick
		if (objectID.indexOf(calSpanID) !== -1) {
			domStyle = document.getElementById(objectID).style;
		}
	
		if (domStyle) {
			domStyle.zIndex = 100;
			return false;
		} else {
			domStyle = null;
			return;
		}
	}
	
	function dragIt(evt) {
		if (domStyle) {
			if (document.addEventListener) {
				//for IE
				domStyle.left = event.clientX - cnLeft + document.body.scrollLeft + 'px';
				domStyle.top = event.clientY - cnTop + document.body.scrollTop + 'px';
			} else {
				//Firefox
				domStyle.left = evt.clientX - cnLeft + document.body.scrollLeft + 'px';
				domStyle.top = evt.clientY - cnTop + document.body.scrollTop + 'px';
			}
		}
	}
	
	// performs a single increment or decrement
	function nextStep(whatSpinner, direction) {
		if (whatSpinner === "Hour") {
			if (direction === "plus") {
				Cal.SetHour(Cal.Hours + 1);
				RenderCssCal();
			} else if (direction === "minus") {
				Cal.SetHour(Cal.Hours - 1);
				RenderCssCal();
			}
		} else if (whatSpinner === "Minute") {
			if (direction === "plus") {
				Cal.SetMinute(parseInt(Cal.Minutes, 10) + 1);
				RenderCssCal();
			} else if (direction === "minus") {
				Cal.SetMinute(parseInt(Cal.Minutes, 10) - 1);
				RenderCssCal();
			}
		}
	}
	
	// starts the time spinner
	function startSpin(whatSpinner, direction) {
		document.thisLoop = setInterval(function () {
			nextStep(whatSpinner, direction);
		}, 125); //125 ms
	}
	
	//stops the time spinner
	function stopSpin() {
		clearInterval(document.thisLoop);
	}
	
	function dropIt() {
		stopSpin();
	
		if (domStyle) {
			domStyle = null;
		}
	}
	
	// Default events configuration
	
	document.onmousedown = pickIt;
	/*
	 document.onmousemove = dragIt;
	 document.onmouseup = dropIt;
	 */
	
	document.addEventListener('click', function (e) {
	
		if (e.target.classList[0] == 'dt-ico') {
			if (e.target.classList[1] !== undefined) {
				e.target.classList.remove('active');
				document.getElementById('calBorder').style.visibility = 'hidden';
				document.getElementById('calOverlay').classList.remove('show');
			} else {
				e.target.classList.add('active');
				document.getElementById('calBorder').style.visibility = 'visible';
				document.getElementById('calOverlay').classList.add('show');
			}
		}
	
		if (e.target.id === 'calOverlay') {
			document.getElementById('calBorder').style.visibility = 'hidden';
			document.getElementById('calOverlay').classList.remove('show');
			var activeIcons = document.querySelectorAll('.dt-ico');
			var aiCountLenght = activeIcons.length;
			for (var aiCount = 0; aiCount < aiCountLenght; ++aiCount) {
				activeIcons[aiCount].classList.remove('active');
			}
		}
	
		if (document.querySelector('#calBorder .MonthSelector') !== null) {
	
			var targetClass = e.target.classList[0];
			if (e.target.classList[1] !== undefined) targetClass = e.target.classList[1];
			if (targetClass === undefined) targetClass = e.target.parentNode.classList[0];
	
			if (targetClass == 'MonthSelectorTitle') {
				if (document.querySelector('#calBorder .MonthSelector').classList.contains("show")) {
					document.querySelector('#calBorder .MonthSelector').classList.remove("show");
				} else {
					document.querySelector('#calBorder .MonthSelector').classList.add("show");
					document.querySelector('#calBorder .MonthSelector.Year').classList.remove("show");
				}
			};
	
			if (targetClass == 'MonthSelector') {
	
				var selectClass = e.target.parentNode.classList[1];
	
				if (e.target.tagName === 'LI' && selectClass === 'show') {
					document.querySelector('#calBorder .MonthSelectorTitle').innerHTML = e.target.innerHTML;
					Cal.SwitchMth([].indexOf.call(e.target.parentNode.children, e ? e.target : e.srcElement));
					RenderCssCal();
				}
				if (e.target.tagName === 'LI' && selectClass === 'Year') {
					document.querySelector('#calBorder .MonthSelectorTitle.Year').innerHTML = e.target.innerHTML;
					Cal.SwitchYear(e.target.innerHTML);
					RenderCssCal();
				}
			};
	
			if (targetClass == 'Year') {
				if (document.querySelector('#calBorder .MonthSelector.Year').classList.contains("show")) {
					document.querySelector('#calBorder .MonthSelector.Year').classList.remove("show");
				} else {
					document.querySelector('#calBorder .MonthSelector.Year').classList.add("show");
					document.querySelector('#calBorder .MonthSelector').classList.remove("show");
				}
			};
		}
	});
	
	try {
		window.NewCssCal = NewCssCal;
		window.Calendar = Calendar;
		window.GenCell = GenCell;
		window.RenderCssCal = RenderCssCal;
		window.NewCssCal = NewCssCal;
		window.closewin = closewin;
		window.winclose = winclose;
		window.changeBorder = changeBorder;
		window.selectDate = selectDate;
		window.findPos = findPos;
		window.pickIt = pickIt;
		window.dragIt = dragIt;
		window.nextStep = nextStep;
		window.startSpin = startSpin;
		window.dropIt = dropIt;
	} catch (err) {
		console.log(err);
	}

/***/ },
/* 122 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	__webpack_require__(123);
	__webpack_require__(124);
	__webpack_require__(125);
	__webpack_require__(126);
	__webpack_require__(127);
	__webpack_require__(128);

/***/ },
/* 123 */
/***/ function(module, exports) {

	"use strict";
	
	/**
	 * blockEllipsis - Clamps (ie. cuts off) an HTML element's content by adding ellipsis to it if the content inside is too long.
	 *
	 * example: <tag data-bind="blockEllipsis: {clamp: 2}"></tag>
	 * link to source: https://github.com/josephschmitt/Clamp.js
	 */
	ko.bindingHandlers.blockEllipsis = {
	  init: function init(element, valueAccessor, allBindings, viewModel, bindingContext) {
	    $clamp(element, valueAccessor());
	  }
	};

/***/ },
/* 124 */
/***/ function(module, exports) {

	"use strict";
	
	module.exports = ko.bindingHandlers.foreachprop = {
	
		transformObject: function transformObject(params) {
			var properties = [];
			var obj,
			    sortFn = params.sortFn;
	
			obj = sortFn ? params.data : params;
			obj = ko.utils.unwrapObservable(obj);
	
			ko.utils.objectForEach(obj, function (key, value) {
				properties.push({
					key: key,
					value: value
				});
			});
	
			if (sortFn) {
				properties.sort(sortFn);
			}
	
			return properties;
		},
		init: function init(element, valueAccessor, allBindingsAccessor, viewModel, bindingContext) {
			var properties = ko.pureComputed(function () {
				var obj = ko.utils.unwrapObservable(valueAccessor());
				return ko.bindingHandlers.foreachprop.transformObject(obj);
			});
			ko.applyBindingsToNode(element, {
				foreach: properties
			}, bindingContext);
			return {
				controlsDescendantBindings: true
			};
		}
	};

/***/ },
/* 125 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function($) {'use strict';
	
	var common = {
		container: 'body',
		trigger: 'hover',
		placement: 'bottom'
	};
	
	ko.bindingHandlers.popover = {
		update: function update(element, valueAccessor) {
			var $element = $(element);
			var params = valueAccessor();
			var config = $.extend({}, common, params, { data: null });
	
			if (params.type === 'popover' && params.data) {
				var data = ko.unwrap(params.data);
				config.title = 'Error ' + data[0] + ': ' + data[1];
				config.content = data[2];
				$element.popover(config);
				if (config.trigger === 'click') {
					var timer;
					$element.on('shown.bs.popover', function () {
						timer = setTimeout(function () {
							$element.trigger('click');
						}, 2000);
					});
					$element.on('hide.bs.popover', function () {
						clearInterval(timer);
					});
				}
			} else {
				config.delay = {
					"show": 1500,
					"hide": 100
				};
				config.title = params.title || config.title;
				$element.tooltip(config);
			}
		}
	};
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ },
/* 126 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function($) {'use strict';
	
	/**
	 * copyToClipboard - A modern approach to copy text to clipboard
	 *
	 * example: <tag data-bind="copyToClipboard: {text: 'some text to copy'}"></tag>
	 *
	 * options:
	 *	text: 'string' - copy|cut text
	 *	-- optional --
	 * 	target: <node|element> - target element
	 * 	action: <string> - type of action 'copy' or 'cut'(cut only for text input field and textarea field)
	 * 	doneClass: <string> - css class for successful action (default is done)
	 * 	errorClass: <string> - css class for error action (default is error)
	 * 	animationTime: <number> (default is 500)
	 *
	 * link to source: https://clipboardjs.com
	 */
	ko.bindingHandlers.copyToClipboard = {
		init: function init(element, valueAccessor, allBindings, viewModel, bindingContext) {
			var $element = $(element);
			var params = valueAccessor();
			var done = params.doneClass || 'done';
			var error = params.errorClass || 'error';
			var animationTime = params.animationTime || 500;
	
			element.clipboard = new Clipboard(element, {
				action: function action(trigger) {
					return params.action || 'copy';
				},
				target: function target(trigger) {
					return params.target;
				},
				text: function text(trigger) {
					return ko.unwrap(params.text);
				}
			});
	
			element.clipboard.on('success', function (e) {
				$element.addClass(done);
				setTimeout(function () {
					return $element.removeClass(done);
				}, animationTime);
				e.clearSelection();
			}).on('error', function (e) {
				$element.addClass(error);
				setTimeout(function () {
					return $element.removeClass(error);
				}, animationTime);
				console.error('copyToClipboard custom binding - Action:', e.action);
				console.error('copyToClipboard custom binding - Trigger:', e.trigger);
			});
	
			ko.utils.domNodeDisposal.addDisposeCallback(element, function () {
				if ($element.clipboard && typeof $element.clipboard.destroy === "function") {
					$element.clipboard && $element.clipboard.destroy();
					delete $element.clipboard;
				}
			});
		}
	};
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ },
/* 127 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function($) {'use strict';
	
	ko.bindingHandlers.lazyLoader = {
		init: function init(element, valueAccessor) {
			var params = valueAccessor();
			var name = params.name.toLowerCase();
			var datesArr = ['startDateTime', 'endDateTime', 'onsaleStartDateTime', 'onsaleEndDateTime'];
			var dateIndex = datesArr.indexOf(params.name);
	
			var selector = name === 'venueid' ? 'venues' : name === 'attractionid' ? 'attractions' : '';
			var type = name === 'classificationid' ? 'id' : name === 'classificationname' ? 'name' : '';
	
			if (dateIndex !== -1) {
				(function () {
					var btn = $('<button class="custom-input__button">&nbsp;</button>');
					var label = datesArr[dateIndex];
					var selector = $(element);
	
					selector.after(btn);
					btn.on("click", function () {
						NewCssCal(label, 'yyyyMMdd', 'dropdown', true, '24');
					});
	
					selector.on('onchange', function () {
						debugger;
						params.val($(this).val());
					});
				})();
			} else if (selector || type) {
				selector ? $(element).lazySelector({ selector: selector }) : $(element).classificationSelector({ selector: 'classifications', use: type });
	
				$(element).on('change', function () {
					params.val($(this).val());
				});
			}
		}
	};
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ },
/* 128 */
/***/ function(module, exports) {

	"use strict";
	
	ko.bindingHandlers.classificationsMap = {
		init: function init(element, valueAccessor, allBindings, viewModel, bindingContext) {
			var params = valueAccessor();
			var _allBindings = allBindings();
			var _bindingContext = bindingContext;
		}
	};

/***/ },
/* 129 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	__webpack_require__(130);
	__webpack_require__(133);
	__webpack_require__(139);
	__webpack_require__(141);
	__webpack_require__(160);

/***/ },
/* 130 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	__webpack_require__(131);
	__webpack_require__(132);

/***/ },
/* 131 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function($) {'use strict';
	
	var _getIterator2 = __webpack_require__(82);
	
	var _getIterator3 = _interopRequireDefault(_getIterator2);
	
	var _classCallCheck2 = __webpack_require__(86);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _createClass2 = __webpack_require__(87);
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * Custom select component
	 */
	
	var CustomSelect = function () {
		function CustomSelect(_ref) {
			var data = _ref.data,
			    selected = _ref.selected,
			    options = _ref.options,
			    focus = _ref.focus,
			    onselect = _ref.onselect,
			    _ref$animationSpeed = _ref.animationSpeed,
			    animationSpeed = _ref$animationSpeed === undefined ? 200 : _ref$animationSpeed,
			    _ref$isReadOnly = _ref.isReadOnly,
			    isReadOnly = _ref$isReadOnly === undefined ? true : _ref$isReadOnly;
			(0, _classCallCheck3.default)(this, CustomSelect);
	
			var rawOptions = ko.unwrap(options);
			var DEFAULT_SELECTED = rawOptions[0].name;
			this.curentSelectData = data;
			this.onFocus = focus;
			this.onselectMethod = onselect;
			this.animationSpeed = animationSpeed;
			this.options = options;
			this.value = ko.unwrap(selected) || DEFAULT_SELECTED;
			this.selectedOption = ko.observable(this.mapForChecked({ rawOptions: rawOptions, name: this.value }));
			this.isExpandeded = ko.observable(false);
			this.isReadOnly = isReadOnly;
			this.setSubscribtions({ selected: selected, DEFAULT_SELECTED: DEFAULT_SELECTED });
	
			// Dirty watcher
			this.fieldWatcher(data);
		}
	
		(0, _createClass3.default)(CustomSelect, [{
			key: 'fieldWatcher',
			value: function fieldWatcher(data) {
				if (data) {
					this.isDirty = data.isDirty = ko.pureComputed(function () {
						return data.value() !== data.default && data.value() !== 'none';
					});
				}
			}
		}, {
			key: 'setSubscribtions',
			value: function setSubscribtions(_ref2) {
				var _this = this;
	
				var selected = _ref2.selected,
				    DEFAULT_SELECTED = _ref2.DEFAULT_SELECTED;
	
				// has preselected option
				if (selected) {
					selected.subscribe(function (value) {
						var selectedOption = _this.mapForChecked({ rawOptions: ko.unwrap(_this.options), name: value || DEFAULT_SELECTED });
	
						return _this.selectedOption(selectedOption);
					});
				}
	
				// on select map for checked
				this.selectedOption.subscribe(function (value) {
					_this.mapForChecked({ rawOptions: ko.unwrap(_this.options), name: value.name });
					_this.onselectMethod(value);
				});
	
				// quantity of options check
				this.isOneOption = ko.pureComputed(function () {
					return ko.unwrap(_this.options).length < 2;
				});
			}
	
			/**
	   * Updates checked option
	   * @param rawOptions {array} options
	   * @param name {string} name of selected option
	   * @returns {object} selected option
	   */
	
		}, {
			key: 'mapForChecked',
			value: function mapForChecked(_ref3) {
				var rawOptions = _ref3.rawOptions,
				    name = _ref3.name;
	
				var selectedOption = void 0;
				var _iteratorNormalCompletion = true;
				var _didIteratorError = false;
				var _iteratorError = undefined;
	
				try {
					for (var _iterator = (0, _getIterator3.default)(rawOptions), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
						var option = _step.value;
	
						option.checked(option.name === name);
						if (option.name === name) {
							selectedOption = option;
						}
					}
				} catch (err) {
					_didIteratorError = true;
					_iteratorError = err;
				} finally {
					try {
						if (!_iteratorNormalCompletion && _iterator.return) {
							_iterator.return();
						}
					} finally {
						if (_didIteratorError) {
							throw _iteratorError;
						}
					}
				}
	
				return selectedOption;
			}
		}, {
			key: 'slideToggle',
			value: function slideToggle(item, event) {
				this.onFocus && this.onFocus(this.curentSelectData);
				this.isExpandeded(!ko.unwrap(this.isExpandeded));
				if (ko.unwrap(this.isOneOption)) {
					return false;
				}
				var el = this.constructor.findElement(event);
				el.wrapper.slideToggle(this.animationSpeed);
				el.layer.toggleClass('hidden');
			}
		}, {
			key: 'onSelect',
			value: function onSelect(item, event) {
				var rawOptions = ko.unwrap(this.options);
				this.mapForChecked({ rawOptions: rawOptions, name: item.name });
				this.selectedOption(item);
				this.slideToggle(item, event);
			}
		}], [{
			key: 'findElement',
			value: function findElement(event) {
				var parent = $(event.currentTarget).parents('.js-custom-select');
				return {
					wrapper: parent.find('.js-custom-select-wrapper'),
					layer: parent.find('.js-custom-select-layer')
				};
			}
		}]);
		return CustomSelect;
	}();
	
	module.exports = ko.components.register('custom-select', {
		viewModel: CustomSelect,
		template: '\n\t<div class="api-exp-custom-select js-custom-select">\n\t\t<div class="api-exp-custom-select-wrapper">\n\t\t\t<select class="api-exp-custom-select__field" name="api-exp-method" data-bind="options: options, optionsText: \'name\', value: selectedOption"></select>\n\t\t\t\t<span class="api-exp-custom-select__placeholder">\n\t\t\t\t<input type="text" data-bind="click: slideToggle, value: selectedOption().name, attr: {disabled: isOneOption, readonly: isReadOnly}">\n\t\t\t\t<button class="btn btn-icon shevron up blue api-exp-custom-select__chevron" data-bind="css: {hidden: isOneOption, down: isExpandeded}" type="button"></button>\n\t\t\t</span>\n\t\t\t<ul data-bind="foreach: options" class="api-exp-custom-select__list js-custom-select-wrapper">\n\t\t\t\t<li data-bind="css: {\'active\': checked}" class="api-exp-custom-select__item">\n\t\t\t\t\t<button class="api-exp-custom-select__item-label"\n\t\t\t\t\t\t\t\t\tdata-bind="click: $component.onSelect.bind($component),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\ttext: name,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcss: {\'active\': checked},\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tattr: {\'data-value\': name}"></button>\n\t\t\t\t\t<a class="api-exp-custom-select__item-link" target="_blank" data-bind="attr: {href: link}, css: {\'hidden\': !link}">&nbsp;</a>\n\t\t\t\t</li>\n\t\t\t</ul>\n\t\t</div>\n\t\t<div data-bind="click: slideToggle" class="api-exp-custom-select-layer js-custom-select-layer hidden"></div>\n\t</div>\n' });
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ },
/* 132 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function($) {'use strict';
	
	var _classCallCheck2 = __webpack_require__(86);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _createClass2 = __webpack_require__(87);
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * Custom select component
	 */
	var self;
	
	var CustomInput = function () {
		function CustomInput(_ref) {
			var onFocusMethod = _ref.onFocusMethod,
			    _ref$data = _ref.data,
			    data = _ref$data === undefined ? { value: '', isDirty: false, required: false } : _ref$data,
			    _ref$cssClass = _ref.cssClass,
			    cssClass = _ref$cssClass === undefined ? '' : _ref$cssClass,
			    validationModel = _ref.validationModel;
			(0, _classCallCheck3.default)(this, CustomInput);
	
			self = this;
			this.data = data;
			this.focusMethod = onFocusMethod;
			this.placeholder = data.placeholder || data.name;
			this.id = data.name;
			this.isVirgin = ko.observable(true);
			// css classes
			this.cssClass = cssClass;
	
			// Dirty watcher
			this.fieldWatcher(data);
	
			// Validation
			this.initValidation(data, validationModel);
		}
	
		(0, _createClass3.default)(CustomInput, [{
			key: 'fieldWatcher',
			value: function fieldWatcher(data) {
				this.isDirty = data.isDirty = ko.pureComputed(function () {
					return !!data.value().toString().trim().length;
				});
			}
		}, {
			key: 'initValidation',
			value: function initValidation(data, validationModel) {
				var obj = { required: data.required };
	
				// validation by type
				switch (data.type) {
					case 'integer':
						obj.nullableInt = data.value;
						break;
				}
	
				this.value = data.value.extend(obj);
				var model = ko.unwrap(validationModel);
				model[data.name] = this.value;
				validationModel(model);
			}
		}, {
			key: 'onFocusMethod',
			value: function onFocusMethod(data) {
				this.focusMethod && this.focusMethod(data);
			}
	
			/**
	   * Enter key handler
	   * @param model
	   * @param event
	   */
	
		}, {
			key: 'onKeyDown',
			value: function onKeyDown(model, event) {
				this.isVirgin(false);
				var btn = $('#api-exp-get-btn');
				if (event.keyCode === 13 && btn.is(':enabled')) {
					btn.trigger('click');
				} else {
					return true;
				}
			}
		}]);
		return CustomInput;
	}();
	
	module.exports = ko.components.register('custom-input', {
		viewModel: CustomInput,
		template: '\n\t\t<div data-bind="css: {[cssClass]: true, dirty: isDirty, virgin: isVirgin}" class="api-exp-custom-input">\n\t\t\t<div data-bind="validationElement: value">\n\t\t\t\t<input data-bind="textInput: value, lazyLoader: {name: placeholder, val: value}, dateTimePicker, event: {focus: onFocusMethod(data), keydown: onKeyDown.bind($component)}, attr: {id: id}"\n\t\t\t\t\t\t\t\ttype="text"\n\t\t\t\t\t\t\t\tclass="custom-input__field form-control">\n\t\t\t\t<span data-bind="text: placeholder, css: {required: data.required}" class="custom-input__placeholder"></span>\n\t\t\t</div>\n\t\t\t<p data-bind="validationMessage: value" class="custom-input__validation-message"></p>\n\t\t</div>\n' });
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ },
/* 133 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	__webpack_require__(134);
	__webpack_require__(135);
	__webpack_require__(136);
	__webpack_require__(137);
	__webpack_require__(138);

/***/ },
/* 134 */
/***/ function(module, exports) {

	'use strict';
	
	var self;
	
	function AboutMethod(params) {
		self = this;
		var method = ko.unwrap(params.selectedMethodData);
		this.documentationLink = ko.observable(method.link);
		this.name = ko.observable(method.name);
		this.description = ko.observable(method.description);
	
		// on model change
		params.selectedMethodData.subscribe(function (val) {
			this.documentationLink(val.link);
			this.name(val.name);
			this.description(val.description);
		}, this);
	
		// methods
		this.togglePopUp = ko.observable(false);
	}
	
	AboutMethod.prototype.onAboutClick = function (model) {
		return model.togglePopUp(!model.togglePopUp());
	};
	
	module.exports = ko.components.register('about-method', {
		viewModel: AboutMethod,
		template: '\n\t\t<section data-bind="css: {active: togglePopUp}" class="api-exp-about">\n\t\t\t<div class="api-exp-about-wrapper">\n\t\t\t\t<button data-bind="click: onAboutClick" class="api-exp-about__button devices-button"></button>\n\t\t\t\t<a data-bind="attr: {href: documentationLink}" href="#" class="api-exp-about__button" target="_blank"></a>\n\t\t\t\t<article class="api-exp-about__content">\n\t\t\t\t\t<h5 data-bind="text: name" class="api-exp-about__title">About API and Method:</h5>\n\t\t\t\t\t<section class="api-exp-about__description">\n\t\t\t\t\t\t<p data-bind="text: description"></p>\n\t\t\t\t\t\t<p>\n\t\t\t\t\t\t\t<a data-bind="attr: {href: documentationLink}" target="_blank" href="#" class="api-exp-about__description-link">Read mode</a>\n\t\t\t\t\t\t</p>\n\t\t\t\t\t</section>\n\t\t\t\t</article>\n\t\t\t\t<div data-bind="click: onAboutClick" class="api-exp-about-layer"></div>\n\t\t\t</div>\n\t\t</section>\n' });

/***/ },
/* 135 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _keys = __webpack_require__(73);
	
	var _keys2 = _interopRequireDefault(_keys);
	
	var _classCallCheck2 = __webpack_require__(86);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var self;
	
	var CategoryMenu = function CategoryMenu(_ref) {
		var _this = this;
	
		var data = _ref.data,
		    selectedCategory = _ref.selectedCategory;
		(0, _classCallCheck3.default)(this, CategoryMenu);
	
		this.selectCategory = function (category) {
			var categoryName = category.name;
			_this.selectedCategory(categoryName);
			checkActive(_this.categories, categoryName);
		};
	
		self = this;
		this.selectedCategory = selectedCategory;
		var initCategory = ko.unwrap(this.selectedCategory);
		this.categories = ko.observableArray((0, _keys2.default)(data).map(function (item, index) {
			var checked = initCategory ? item === initCategory : !index;
			// initial load
			checked && _this.selectedCategory(item);
			return {
				checked: ko.observable(checked),
				name: item,
				link: false
			};
		}));
	
		this.selectedCategory.subscribe(function (categoryName) {
			checkActive(_this.categories, categoryName);
		});
	};
	
	module.exports = ko.components.register('category-menu', {
		viewModel: CategoryMenu,
		template: '\n\t\t<aside class="api-exp-side-menu">\n\t\t\t<ul data-bind="foreach: categories" class="api-exp-side-menu__container nav nav-pills nav-stacked visible-lg-block">\n\t\t\t\t<li data-bind="css: {active: checked}" role="presentation" class="api-exp-side-menu__item">\n\t\t\t\t\t<a data-bind="click: $parent.selectCategory, text: name" href="#" class="api-exp-side-menu__link"></a>\n\t\t\t\t</li>\n\t\t\t</ul>\n\t\t\t<!--select-->\n\t\t\t<div class="api-exp-side-menu__select hidden-lg">\n\t\t\t\t<!-- ko template: { nodes: $componentTemplateNodes, data: $component } --><!-- /ko -->\n\t\t\t</div>\n\t\t</aside>\n' });
	
	function checkActive(koArr, activeElem) {
		if (!koArr && !activeElem) {
			return false;
		}
	
		koArr(koArr().map(function (obj) {
			if (obj.name === activeElem) {
				obj.checked(true);
			} else {
				obj.checked(false);
			}
			return obj;
		}));
	}

/***/ },
/* 136 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function($) {'use strict';
	
	var _classCallCheck2 = __webpack_require__(86);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _createClass2 = __webpack_require__(87);
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	var _class, _temp, _initialiseProps;
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var self;
	
	var MethodsFilter = (_temp = _class = function () {
		function MethodsFilter(_ref) {
			var selectedCategory = _ref.selectedCategory,
			    data = _ref.data,
			    selectedMethodType = _ref.selectedMethodType,
			    selectedMethod = _ref.selectedMethod;
			(0, _classCallCheck3.default)(this, MethodsFilter);
	
			_initialiseProps.call(this);
	
			self = this;
			this.selectedCategory = selectedCategory;
			this.data = data;
			this.selectedMethodType = selectedMethodType;
			this.selectedMethod = selectedMethod;
			this.selectedMethodName = ko.observable('');
			this.methodsViewModel = ko.observableArray([]);
			this.init();
		}
	
		/**
	  * Initialization phase
	  */
	
	
		(0, _createClass3.default)(MethodsFilter, [{
			key: 'filterTransclusion',
	
	
			/**
	   * Filters transclusion dom nodes
	   * @param param {array} $componentTemplateNodes
	   * @param index {number} index of element
	   * @returns {array} dom nodes array for insertion
	   */
			value: function filterTransclusion(param, index) {
				var text = param.find(function (item) {
					return item.nodeName === '#text';
				});
				var el = param.filter(function (item) {
					return item.nodeName !== '#text' && item.nodeName !== '#comment';
				})[index];
				return [text, el, text];
			}
	
			/**
	   * Updates VM for methods select
	   * @param methodType
	   */
	
		}, {
			key: 'onSelectMethod',
	
	
			/**
	   * On select handler for methods select
	   * @param item
	   */
			value: function onSelectMethod(item) {
				self.selectedMethod(item.id);
			}
		}]);
		return MethodsFilter;
	}(), _initialiseProps = function _initialiseProps() {
		var _this = this;
	
		this.init = function () {
			_this.updateMethodsModel(ko.unwrap(_this.selectedMethodType));
	
			//on change
			_this.selectedMethodType.subscribe(function (val) {
				return _this.updateMethodsModel(val);
			});
			_this.selectedMethod.subscribe(function (val) {
				_this.selectedMethodName(_this.data[ko.unwrap(_this.selectedCategory)]['ALL'][val].name);
			});
		};
	
		this.updateMethodsModel = function (methodType) {
			var obj = _this.data[ko.unwrap(_this.selectedCategory)][methodType] || {},
			    arr = [],
			    selectedMethod = ko.unwrap(_this.selectedMethod),
			    count = 0;
	
			for (var i in obj) {
				if (!obj.hasOwnProperty(i)) {
					continue;
				}
				var property = obj[i];
	
				var vmMethod = $.extend({}, {
					id: property.id,
					name: property.name,
					link: property.link,
					checked: ko.observable(selectedMethod ? selectedMethod === property.id : !count)
				});
	
				if (selectedMethod === property.id) {
					_this.selectedMethodName(property.name);
				}
	
				arr.push(vmMethod);
	
				// set global observable
				!selectedMethod && !count && _this.selectedMethod(property.id);
	
				count++;
			}
	
			_this.methodsViewModel(arr);
		};
	}, _temp);
	
	
	module.exports = ko.components.register('methods-filter', {
		viewModel: MethodsFilter,
		template: '\n\t\t<section  class="api-exp-main-filter">\n\t\t\t<section class="api-exp-filter">\n\t\t\t\t<section class="api-exp-methods clearfix">\n\t\t\t\t\t<label class="api-exp-methods__label">Methods</label>\n\t\n\t\t\t\t\t<!--radios-->\n\t\t\t\t\t<!-- ko template: { nodes: filterTransclusion($componentTemplateNodes, 0), data: $component } --><!-- /ko -->\n\t\t\t\t\t\n\t\t\t\t\t<!--select-->\n\t\t\t\t\t<div class="api-exp-methods__select">\n\t\t\t\t\t\t<!-- ko template: { nodes: filterTransclusion($componentTemplateNodes, 1), data: $component }--><!--/ko-->\n\t\t\t\t\t</div>\n\t\t\t\t</section>\n\t\t\t</section>\n\t\t</section>\n' });
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ },
/* 137 */
/***/ function(module, exports) {

	'use strict';
	
	var self;
	
	function RadioFilter(params) {
		self = this;
		var selectedCategory = ko.unwrap(params.selectedCategory);
		var data = params.data;
		this.selectedMethodType = params.selectedMethodType;
		this.RADIO_ID = 'api-exp-';
	
		this.radiosModel = ko.observableArray([]);
		this.updateRadiosModel(data[selectedCategory]);
	
		params.selectedCategory.subscribe(function (val) {
			this.updateRadiosModel(data[val]);
		}, this);
	}
	
	RadioFilter.prototype.updateRadiosModel = function (param) {
		var obj = param || {},
		    arr = [];
	
		for (var i in obj) {
			if (!obj.hasOwnProperty(i)) {
				continue;
			}
			var item = {
				checked: ko.observable(i === 'ALL'),
				name: i
			};
			arr.push(item);
			// initial notify for all subscribers
			i === 'ALL' && this.selectedMethodType.notifySubscribers(i);
		}
	
		arr = arr.sort(compareMethods);
		this.radiosModel(arr);
		return arr;
	};
	
	/**
	 * Onchange handler for Radio buttons
	 * @param item
	 */
	RadioFilter.prototype.onchangeRadios = function (item) {
		var radiosModel = ko.unwrap(self.radiosModel).map(function (obj) {
			if (obj.name === item.name) {
				obj.checked(true);
				self.selectedMethodType(obj.name);
				console.log(ko.unwrap(self.selectedMethodType));
			} else {
				obj.checked(false);
			}
			return obj;
		});
		self.radiosModel(radiosModel);
	};
	
	/**
	 * Uniq id for radio btn
	 * @param name
	 * @returns {string}
	 */
	RadioFilter.prototype.getInputId = function (name) {
		return self.RADIO_ID + name;
	};
	
	/**
	 * Sort function for methods aray
	 * @param f
	 * @param s
	 * @returns {number}
	 */
	function compareMethods(f, s) {
		var a = f.name.toUpperCase();
		var b = s.name.toUpperCase();
	
		if (a === b) {
			return 0;
		}
		if (a === 'ALL' || a === 'GET' && (b === 'POST' || b === 'PUT' || b === 'DELETE') || a === 'POST' && (b === 'PUT' || b === 'DELETE') || a === 'PUT' && b === 'DELETE') {
			return -1;
		}
		return 1;
	}
	
	module.exports = ko.components.register('radio-filter', {
		viewModel: RadioFilter,
		template: '\n\t\t<!--radios-->\n\t\t<section data-bind="foreach: radiosModel" class="api-exp-methods__radio-buttons radio-buttons clearfix">\n\t\t\t<div data-bind="css: {active: checked}" class="api-exp-method">\n\t\t\t\t<input data-bind="attr: { id: $component.getInputId(name), checked: checked }, event: {change: $component.onchangeRadios}"\n\t\t\t\t\t\t\t\tclass="api-exp-content-method__radio"\n\t\t\t\t\t\t\t\ttype="radio"\n\t\t\t\t\t\t\t\tname="api-exp-methods">\n\t\t\t\t<label data-bind="text: name, attr: {for: $component.getInputId(name)}" class="radio-inline api-exp-method__label"></label>\n\t\t\t</div>\n\t\t</section>\n' });

/***/ },
/* 138 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function($) {'use strict';
	
	var _classCallCheck2 = __webpack_require__(86);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _createClass2 = __webpack_require__(87);
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var ParamsFilter = function () {
		function ParamsFilter(_ref) {
			var _this = this;
	
			var selectedMethod = _ref.selectedMethod,
			    selectedParams = _ref.selectedParams,
			    selectedMethodData = _ref.selectedMethodData,
			    _ref$animationSpeed = _ref.animationSpeed,
			    animationSpeed = _ref$animationSpeed === undefined ? 200 : _ref$animationSpeed;
			(0, _classCallCheck3.default)(this, ParamsFilter);
	
			this.updateViewModel = function () {
				var obj = ko.unwrap(_this.selectedMethodData).parameters || {},
				    arr = [];
	
				for (var i in obj) {
					if (!obj.hasOwnProperty(i)) {
						continue;
					}
					var param = obj[i];
					var selectedParam;
	
					// copies all values from model to view-model
					var vmParam = $.extend(true, {}, param);
	
					vmParam.value = ko.observable(vmParam.value || vmParam.select && param.options[0].name || '');
	
					//add observable for selected options
					if (vmParam.select) {
						vmParam.options = selectedParam ? selectedParam.options : ko.observableArray(param.options.map(function (item) {
							return $.extend(true, {}, item, { checked: ko.observable(item.checked) });
						}));
					}
	
					// add calendar btn for current field
					vmParam.hasCalendar = i.search(/(date|time)/gmi) != -1;
	
					// add pop-up btn for current field
					vmParam.hasPopUp = i.search(/(attractionId|venueId)/gmi) != -1;
	
					arr.push(vmParam);
				}
	
				// prepare output for request
				_this.paramsModel(arr);
	
				//set focus for first elem
				_this.paramInFocus(_this.paramsModel()[0]);
				_this.prepareUrlPairs(arr, _this.selectedParams);
				return arr;
			};
	
			this.onFocus = function (item) {
				_this.paramInFocus(item);
			};
	
			this.onParamsClear = function (vm, e) {
				var arr = ko.unwrap(_this.paramsModel);
	
				_this.paramsModel(arr.map(function (param) {
					param.value(param.select && param.default || '');
	
					if (param.select) {
						param.options(ko.unwrap(param.options).map(function (option, index) {
							option.checked(!index);
							return option;
						}));
					}
					return param;
				}));
	
				// prepare output for request
				_this.paramInFocus(_this.paramsModel()[0]);
				_this.prepareUrlPairs(arr, _this.selectedParams);
			};
	
			this.animationSpeed = animationSpeed;
			this.selectedMethod = selectedMethod;
			this.selectedParams = selectedParams;
			this.selectedMethodData = selectedMethodData;
			this.isHidden = ko.observable(true);
			this.paramInFocus = ko.observable({});
			this.paramsModel = ko.observableArray([]);
			this.isDirty = ko.computed(this.checkDirty, this);
			this.init({ selectedMethod: selectedMethod, selectedParams: selectedParams });
		}
	
		/**
	  * Initialization phase
	  */
	
	
		(0, _createClass3.default)(ParamsFilter, [{
			key: 'init',
			value: function init(_ref2) {
				var _this2 = this;
	
				var selectedMethod = _ref2.selectedMethod,
				    selectedParams = _ref2.selectedParams;
	
				this.updateViewModel();
	
				selectedMethod.subscribe(function (val) {
					_this2.updateViewModel(val);
				});
	
				selectedParams.subscribe(function (selected) {
					var paramsModel = ko.unwrap(_this2.paramsModel);
					selected.map(function (param) {
						var matchedParam = paramsModel.find(function (val) {
							return param.name === val.name;
						});
						matchedParam.value(ko.unwrap(param.value));
					});
					_this2.paramsModel(paramsModel);
				}, this, 'paramsSet');
			}
	
			/**
	   * Initial build of Select Model
	   */
	
		}, {
			key: 'checkDirty',
	
	
			/**
	   * Dirty params form observable method
	   * @returns {boolean}
	   */
			value: function checkDirty() {
				this.prepareUrlPairs(ko.unwrap(this.paramsModel), this.selectedParams);
				var dirty = ko.unwrap(this.paramsModel).filter(function (item) {
					return ko.unwrap(item.isDirty) === true;
				});
				return dirty.length > 0;
			}
	
			/**
	   * Slide toggle for params container method
	   * @param viewModel
	   * @param event
	   */
	
		}, {
			key: 'slideToggle',
			value: function slideToggle(viewModel, event) {
				$(event.currentTarget).parents('.js-slide-control').find('.js-slide-wrapper').slideToggle(viewModel.animationSpeed, function () {
					viewModel.isHidden(!viewModel.isHidden());
				});
			}
	
			/**
	   * Maches focused param
	   * @param item
	   */
	
		}, {
			key: 'prepareUrlPairs',
	
	
			/**
	   * Filters params by defined value
	   * @param arr
	   * @param koObs
	   * @returns {boolean}
	   */
			value: function prepareUrlPairs(arr, koObs) {
				if (!arr || !koObs) {
					return false;
				}
	
				return koObs(arr.filter(function (item) {
					return item.value() && item.value() !== 'none' || item.default;
				}));
			}
	
			/**
	   * On select value handler for params select
	   * @param param {object} parameter view-model
	   * @param option {object} option view-model
	   */
	
		}, {
			key: 'onSelectParamValue',
			value: function onSelectParamValue(param, option) {
				param.value(option.name);
			}
	
			/**
	   * Params clear button handler
	   * @param vm {object} view model
	   * @param e {object} event
	   */
	
		}]);
		return ParamsFilter;
	}();
	
	module.exports = ko.components.register('params-filter', {
		viewModel: ParamsFilter,
		template: '\n\t\t<section data-bind="css: {closed: isHidden, dirty: isDirty}" class="api-exp-params js-slide-control">\n\t\t\n\t\t\t<section class="api-exp-params-headline">\n\t\t\t\t<button data-bind="click: slideToggle" class="btn btn-icon toggle-btn" type="button">Parameters</button>\n\t\t\t\t<span class="btn btn-icon shevron up grey" data-bind="css: {down: isHidden}"></span>\n\t\t\t\t<div class="api-exp-params-headline-edit">\n\t\t\t\t\t<button class="btn api-exp-params-headline__btn api-exp-params-headline__btn-copy">&nbsp;</button>\n\t\t\t\t\t<button data-bind="click: onParamsClear" class="btn api-exp-params-headline__btn api-exp-params-headline__btn-clear">&nbsp;</button>\n\t\t\t\t</div>\n\t\t\t</section>\n\t\t\t\n\t\t\t<div class="api-exp-params-wrapper clearfix js-slide-wrapper">\n\t\t\t\t<!--about-->\n\t\t\t\t<section class="api-exp-about visible-lg-block">\n\t\t\t\t\t<div class="api-exp-about-wrapper">\n\t\t\t\t\t\t<span class="api-exp-about__button"></span>\n\t\t\t\t\t\t<article class="api-exp-about__content">\n\t\t\t\t\t\t\t<h5 data-bind="text: paramInFocus().name" class="api-exp-about__title">About API and Method:</h5>\n\t\t\t\t\t\t\t<section class="api-exp-about__description">\n\t\t\t\t\t\t\t\t<p data-bind="html: paramInFocus().doc"></p>\n\t\t\t\t\t\t\t</section>\n\t\t\t\t\t\t</article>\n\t\t\t\t\t</div>\n\t\t\t\t</section>\n\t\t\t\t\n\t\t\t\t<!--params filter-->\n\t\t\t\t<section class="api-exp-params-filter">\n\t\t\t\t\t<section data-bind="foreach: paramsModel" class="api-exp-params-filter-fields">\n\t\t\t\t\t\t<!--select-->\n\t\t\t\t\t\t\t<div class="api-exp-params-filter__field">\n\t\t\t\t\t\t\t\t<!-- ko if: select -->\n\t\t\t\t\t\t\t\t\t<custom-select params="\n\t\t\t\t\t\t\t\t\t\tdata: $data,\n\t\t\t\t\t\t\t\t\t\toptions: options,\n\t\t\t\t\t\t\t\t\t\tonselect: $component.onSelectParamValue.bind($data, $data),\n\t\t\t\t\t\t\t\t\t\tfocus: $component.onFocus,\n\t\t\t\t\t\t\t\t\t\tselected: value">\n\t\t\t\t\t\t\t\t\t</custom-select>\n\t\t\t\t\t\t\t\t<!-- /ko -->\n\t\t\t\t\t\t\t\t<!-- ko ifnot: select -->\n\t\t\t\t\t\t\t\t\t<custom-input params="\n\t\t\t\t\t\t\t\t\t\tonFocusMethod: $component.onFocus,\n\t\t\t\t\t\t\t\t\t\tdata: $data,\n\t\t\t\t\t\t\t\t\t\tcssClass: hasCalendar ? \'calendar\': hasPopUp ? \'popup\': \'\',\n\t\t\t\t\t\t\t\t\t\tvalidationModel: $root.validationModel">\n\t\t\t\t\t\t\t\t\t</custom-input>\n\t\t\t\t\t\t\t\t<!-- /ko -->\n\t\t\t\t\t\t\t</div>\n\t\t\t\t\t</section>\n\t\t\t\t</section><!--params filter-->\n\t\t\t</div>\n\t\t</section><!--parameters-->\n' });
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ },
/* 139 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	__webpack_require__(140);

/***/ },
/* 140 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function($) {'use strict';
	
	var _classCallCheck2 = __webpack_require__(86);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _createClass2 = __webpack_require__(87);
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var ErrorPopUp = function () {
		function ErrorPopUp() {
			var _this = this;
	
			(0, _classCallCheck3.default)(this, ErrorPopUp);
	
			this.status = ko.observable('');
			this.statusText = ko.observable('');
			this.details = ko.observable('');
	
			ko.postbox.subscribe('REQUEST_ERROR', function (errorObj) {
				_this.status(Object.getProp(errorObj, '.responseJSON.errors[0].status') || errorObj.status || 'unknown');
				_this.statusText(Object.getProp(errorObj, '.responseJSON.errors[0].statusText') || errorObj.statusText || '');
				_this.details(Object.getProp(errorObj, '.responseJSON.errors[0].detail') || 'unknown');
				_this.togglePopUp();
			});
		}
	
		(0, _createClass3.default)(ErrorPopUp, [{
			key: 'togglePopUp',
			value: function togglePopUp() {
				$('#error-modal').modal('show');
			}
		}]);
		return ErrorPopUp;
	}();
	
	module.exports = ko.components.register('error-pop-up', {
		viewModel: ErrorPopUp,
		template: '\n\t\t<section id="error-modal" class="modal fade" tabindex="-1" role="dialog">\n\t\t\t<div class="modal-dialog" role="document">\n\t\t\t\t<div class="modal-content error-pop-up">\n\t\t\t\t\t<div class="modal-header">\n\t\t\t\t\t\t<h2 class="error-title">Error <span data-bind="text: status"></span>: <span data-bind="text: statusText"></span></h2>\n\t\t\t\t\t</div>\n\t\t\t\t\t<div class="modal-body">\n\t\t\t\t\t\t<p data-bind="text: details" class="error-details"></p>\n\t\t\t\t\t</div>\n\t\t\t\t\t<div class="modal-footer">\n\t\t\t\t\t\t<button type="button" class="btn btn-primary btn-accept" data-dismiss="modal" aria-label="Close">Ok</button>\n\t\t\t\t\t</div>\n\t\t\t\t</div><!-- /.modal-content -->\n\t\t\t</div><!-- /.modal-dialog -->\n\t\t</section><!-- /.modal -->\n' });
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ },
/* 141 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	__webpack_require__(142);
	__webpack_require__(143);
	__webpack_require__(144);
	__webpack_require__(145);
	__webpack_require__(155);
	__webpack_require__(159);

/***/ },
/* 142 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function($) {'use strict';
	
	var _keys = __webpack_require__(73);
	
	var _keys2 = _interopRequireDefault(_keys);
	
	var _typeof2 = __webpack_require__(4);
	
	var _typeof3 = _interopRequireDefault(_typeof2);
	
	var _classCallCheck2 = __webpack_require__(86);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _createClass2 = __webpack_require__(87);
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var self;
	
	var CardGroup = function () {
		function CardGroup(params) {
			(0, _classCallCheck3.default)(this, CardGroup);
	
			self = this;
			this.config = this.constructor.getConfig(params);
			this.data = this.prepareData({ params: params, config: this.config._CONFIG });
			this.groupIndex = params.groupIndex || 0;
			this.sectionIndex = ko.unwrap(params.sectionIndex);
			this.colorClass = params.colorClass;
			this.getMore = params.getMore;
			this.page = this.constructor.getPagingInfo(params, this.data.page);
			this.collapseId = this.constructor.getCollapseId();
			this._hasEventsPanel = false;
		}
	
		(0, _createClass3.default)(CardGroup, [{
			key: 'sortByConfig',
			value: function sortByConfig(a, b) {
				if (this.config && this.config[a.key] && this.config[b.key] && this.config[a.key]._CONFIG && this.config[b.key]._CONFIG) {
					var i1 = this.config[a.key]._CONFIG.index;
					var i2 = this.config[b.key]._CONFIG.index;
					return i1 - i2;
				}
				return 0;
			}
		}, {
			key: 'checkIfHasEventsList',
			value: function checkIfHasEventsList(key) {
				return self._hasEventsPanel = key === 'events' || self._hasEventsPanel;
			}
	
			/**
	   * Configures and params for each panel group
	   */
	
		}, {
			key: 'prepareData',
	
	
			/**
	   * Data manipulations
	   */
			value: function prepareData(_ref) {
				var _ref$params = _ref.params,
				    params = _ref$params === undefined ? {} : _ref$params,
				    _ref$config = _ref.config,
				    config = _ref$config === undefined ? this.config._CONFIG : _ref$config;
	
				var data = $.extend(true, {}, params.data) || {};
				this.unwrappObjects(data, config);
				this.removeDeprecated(data, config);
				return this.wrappPrimitives({ data: data, _propTitle: params._propTitle });
			}
	
			/**
	   * Gathers all stand alone props in to one object
	   * @param data {object}
	   * @param _propTitle {string}
	   * @returns {object} revised data
	   */
	
		}, {
			key: 'wrappPrimitives',
			value: function wrappPrimitives(_ref2) {
				var data = _ref2.data,
				    _ref2$_propTitle = _ref2._propTitle,
				    _propTitle = _ref2$_propTitle === undefined ? 'object' : _ref2$_propTitle;
	
				var newData = {},
				    val = void 0;
	
				// gathering all primitive props in additional panel
				for (var key in data) {
					if (!data.hasOwnProperty(key)) {
						continue;
					}
					val = data[key];
	
					if ((typeof val === 'undefined' ? 'undefined' : (0, _typeof3.default)(val)) !== 'object') {
						newData[_propTitle] = newData[_propTitle] || {};
						newData[_propTitle][key] = val;
					} else {
						newData[key] = val;
					}
				}
				return newData;
			}
	
			/**
	   * Unwraps objects
	   */
	
		}, {
			key: 'removeDeprecated',
			value: function removeDeprecated(obj) {
				var config = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
	
				var deprecated = config.deprecated || [];
	
				deprecated.map(function (item) {
					if (obj[item]) {
						delete obj[item];
					}
					return item;
				});
	
				return obj;
			}
	
			/**
	   * Removes deprecated objects
	   */
	
		}, {
			key: 'unwrappObjects',
			value: function unwrappObjects(obj) {
				var config = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
	
				var unwrapp = config.unwrapp || [];
	
				unwrapp.map(function (item) {
					var val = obj[item];
					if (val) {
						var arr = (0, _keys2.default)(val);
						for (var i = 0; i < arr.length; i++) {
							var prop = arr[i];
							obj[prop] = val[prop];
						}
						delete obj[item];
					}
					return item;
				});
	
				return obj;
			}
	
			/**
	   * Prepares data for paging
	   */
	
		}], [{
			key: 'getConfig',
			value: function getConfig(_ref3) {
				var _ref3$deepProp = _ref3.deepProp,
				    deepProp = _ref3$deepProp === undefined ? '' : _ref3$deepProp,
				    config = _ref3.config,
				    filter = _ref3.filter,
				    methodId = _ref3.methodId;
	
				self.deepProp = deepProp;
				// main config
				if (!self.deepProp && !config) {
					// panelGroup index - 0
	
					// get full config;
					var rawFilter = ko.unwrap(filter);
	
					// get current method config
					var methodConfig = rawFilter[methodId] || {};
	
					// method config inherits global config
					methodConfig._CONFIG = $.extend(true, {}, rawFilter._GLOBAL_CONFIG, methodConfig._CONFIG);
	
					return methodConfig;
				} else {
					// panelGroup index > 0
					return config || {};
				}
			}
		}, {
			key: 'getPagingInfo',
			value: function getPagingInfo(params, pageObj) {
				var pageParam = void 0,
				    size = void 0;
	
				if (pageObj && (params.pageParam || params.params)) {
					//temporary solution todo: need to be revised and refactored
					size = params.cardSize || pageObj.size;
					pageParam = params.pageParam || params.params.find(function (item) {
						return item.name === 'page';
					});
	
					return {
						category: params.category,
						method: params.method,
						methodId: params.methodId,
						params: params.params,
						pageParam: pageParam && pageParam.value,
						setParams: params.setParams,
						size: size
					};
				}
				return null;
			}
	
			/**
	   * Provides id str for panel 'collapse toggle' logic
	   * @param str
	   * @returns {string}
	   */
	
		}, {
			key: 'getCollapseId',
			value: function getCollapseId() {
				return 'card-panel-body-' + self.sectionIndex + self.groupIndex;
			}
		}]);
		return CardGroup;
	}();
	
	module.exports = ko.components.register('panel-group', {
		viewModel: CardGroup,
		template: '\n\t\t<section data-bind="foreachprop: {data: data, sortFn: sortByConfig.bind($component)}" class="panel-group">\n\t\t\t<!--panel-->\n\t\t\t<panel class="panel-item" data-bind="css: {\'has-events-list\': $component.checkIfHasEventsList(key)}"\n\t\t\t\t\t\t\tparams="$data: $data,\n\t\t\t\t\t\t\t\t\t\t\t$index: $index,\n\t\t\t\t\t\t\t\t\t\t\tpanelGroup: $component,\n\t\t\t\t\t\t\t\t\t\t\tsortByConfig: $component.sortByConfig">\n\t\t\t</panel>\n\t\t</section>\n' });
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ },
/* 143 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function($) {'use strict';
	
	var _classCallCheck2 = __webpack_require__(86);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _createClass2 = __webpack_require__(87);
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var Panel = function () {
		function Panel(_ref) {
			var _ref$$data = _ref.$data,
			    $data = _ref$$data === undefined ? {} : _ref$$data,
			    _ref$panelGroup = _ref.panelGroup,
			    panelGroup = _ref$panelGroup === undefined ? {} : _ref$panelGroup,
			    $index = _ref.$index;
			(0, _classCallCheck3.default)(this, Panel);
	
			this.$data = $data;
			this.key = $data.key;
			this.$index = ko.unwrap($index);
			this.panelGroup = panelGroup;
			this.page = panelGroup.page;
			this.colorClass = panelGroup.colorClass || '';
			this.config = this.constructor.panelConfig({ config: panelGroup.config, key: this.key });
			this.isExpanded = this.constructor.isExpanded(this.config);
			this.collapseId = panelGroup.collapseId + this.$index;
			this.isActive = ko.observable(this.isExpanded);
			this.subjectID = ko.observable('');
		}
	
		(0, _createClass3.default)(Panel, [{
			key: 'setActive',
			value: function setActive(model, event) {
				this.isActive(!this.isActive());
			}
	
			/**
	   * Gets config for each panel
	   * @param config
	   * @param key
	   * @returns {*|{}}
	   */
	
		}], [{
			key: 'panelConfig',
			value: function panelConfig(_ref2) {
				var config = _ref2.config,
				    key = _ref2.key;
	
				var subConfig = config[key] || {};
	
				subConfig._CONFIG = $.extend(true, {}, config._CONFIG, subConfig._CONFIG);
				return subConfig;
			}
	
			/**
	   * Checks for 'expanded' config for each panel
	   * @param config
	   * @returns {boolean}
	   */
	
		}, {
			key: 'isExpanded',
			value: function isExpanded(config) {
				return !(Object.getProp(config, '._CONFIG.collapsed') || false);
			}
		}]);
		return Panel;
	}();
	
	module.exports = ko.components.register('panel', {
		viewModel: Panel,
		template: '\n\t\t<section data-bind="css: {[colorClass]: true, active: isActive}" class="panel panel-primary">\n\t\t\t<!--panel-heading-->\n\t\t\t<panel-heading params="panelGroup: panelGroup, config: config, data: $data, index: $index, page: page, setActive: setActive.bind($component), collapseId: collapseId, colorClass: colorClass, isExpanded: isExpanded, subjectID:subjectID"></panel-heading>\n\t\t\t\n\t\t\t<!--panel-body-->\n\t\t\t<section data-bind="attr: {\'id\': collapseId}, css: {\'in\': isExpanded}" class="panel-collapse collapse">\t\t\t\t\n\t\t\t\t<!-- ko if: (typeof $data.value === \'object\' && !$.isArray($data.value)) -->\n\t\t\t\t\t<object-panel-body params="config: config, data: $data, index: $index, panelGroup: panelGroup, page: page, collapseId: collapseId, subjectID: subjectID"></object-panel-body>\n\t\t\t\t<!-- /ko -->\n\t\t\t\t<!-- ko if: (typeof $data.value === \'object\' && $.isArray($data.value)) -->\n\t\t\t\t\t<array-panel-body params="config: config, data: $data, index: $index, panelGroup: panelGroup"></array-panel-body>\n\t\t\t\t<!-- /ko -->\n\t\t\t</section>\n\t\t</section>\n' });
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ },
/* 144 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function($) {'use strict';
	
	var _classCallCheck2 = __webpack_require__(86);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _createClass2 = __webpack_require__(87);
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * Pagination element
	 * @param params
	 */
	var Pagination = function () {
		function Pagination(_ref) {
			var _ref$page = _ref.page,
			    page = _ref$page === undefined ? {} : _ref$page,
			    totalPages = _ref.totalPages,
			    number = _ref.number;
			(0, _classCallCheck3.default)(this, Pagination);
	
			this.page = page;
			this.totalPages = +totalPages;
			this.number = +number;
			this.first = !!this.number;
			this.last = +number < +totalPages - 1;
			this.requestBtn = $('#api-exp-get-btn');
		}
	
		/**
	  * get next page
	  */
	
	
		(0, _createClass3.default)(Pagination, [{
			key: 'getPrevPage',
			value: function getPrevPage() {
				var page = this.page;
				var val = ko.unwrap(page.pageParam);
				page.pageParam(val > 0 ? val - 1 : 0);
				page.setParams({
					category: page.category,
					method: page.method,
					methodId: page.methodId,
					params: page.params
				});
				this.requestBtn.trigger('click');
			}
	
			/**
	   * get prev page
	   */
	
		}, {
			key: 'getNextPage',
			value: function getNextPage() {
				var page = this.page;
				var val = ko.unwrap(this.number);
				page.pageParam(val < this.totalPages - 1 ? val + 1 : val);
				page.setParams({
					category: page.category,
					method: page.method,
					methodId: page.methodId,
					params: page.params
				});
				this.requestBtn.trigger('click');
			}
		}]);
		return Pagination;
	}();
	
	module.exports = ko.components.register('pagination', {
		viewModel: Pagination,
		template: '<span class="navigation-wrapper">\n\t\t<button data-bind="click: getPrevPage, enable: first" type="button" class="navigation prev"></button>\n\t\t<button data-bind="click: getNextPage, enable: last" type="button" class="navigation next"></button>\n\t</span>'
	});
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ },
/* 145 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _typeof2 = __webpack_require__(4);
	
	var _typeof3 = _interopRequireDefault(_typeof2);
	
	var _keys = __webpack_require__(73);
	
	var _keys2 = _interopRequireDefault(_keys);
	
	var _classCallCheck2 = __webpack_require__(86);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _createClass2 = __webpack_require__(87);
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	var _services = __webpack_require__(146);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var PanelHeading = function () {
		function PanelHeading(_ref) {
			var _ref$config = _ref.config,
			    config = _ref$config === undefined ? {} : _ref$config,
			    _ref$data = _ref.data,
			    data = _ref$data === undefined ? {} : _ref$data,
			    setActive = _ref.setActive,
			    isExpanded = _ref.isExpanded,
			    page = _ref.page,
			    collapseId = _ref.collapseId,
			    colorClass = _ref.colorClass,
			    panelGroup = _ref.panelGroup,
			    subjectID = _ref.subjectID;
			(0, _classCallCheck3.default)(this, PanelHeading);
	
			this.config = config._CONFIG;
			this.setActive = setActive;
			this.isExpanded = isExpanded;
			this._panelName = data.key;
			this.title = this.config && this.config.title || this._panelName;
			this.data = data.value;
			this.collapseId = collapseId;
			this.page = page;
			this.panelGroup = panelGroup;
			this.subjectId = subjectID;
			this.init({ page: page, colorClass: colorClass });
		}
	
		(0, _createClass3.default)(PanelHeading, [{
			key: 'init',
			value: function init(_ref2) {
				var page = _ref2.page,
				    colorClass = _ref2.colorClass;
	
				if (page) {
					this.cardSize = page.size;
				}
				if (this.config.request) {
					this.anotherRequestColor = _services.colorsService.getRandomColor(colorClass);
				}
			}
		}, {
			key: 'followRequest',
			value: function followRequest(value) {
				var _this = this;
	
				var url = Object.getProp(value, '.config.request');
				if (url) {
					(function () {
						var method = {};
						url = url.split(new RegExp('https://app.ticketmaster.com/'))[1];
						PanelHeading.getDeepProp(url, base, method);
						method = method.object;
	
						method.parameters = (0, _keys2.default)(method.parameters).map(function (key) {
							var param = method.parameters[key];
							if (param.name === 'id') {
								param.value = ko.unwrap(_this.subjectId);
							} else if (param.name === 'format') {
								param.value = 'json';
							}
							return param;
						});
	
						_this.anotherRequest = ko.observable({ url: url, method: method, panelGroup: _this.panelGroup, color: _this.anotherRequestColor }).publishOn('ANOTHER_REQUEST');
					})();
				}
			}
		}, {
			key: 'hasAnotherRequest',
			get: function get() {
				return !!this.config.request;
			}
		}], [{
			key: 'getDeepProp',
			value: function getDeepProp(val, obj, result) {
				if ((typeof obj === 'undefined' ? 'undefined' : (0, _typeof3.default)(obj)) !== 'object') return;
	
				for (var prop in obj) {
					if (obj.hasOwnProperty(prop) && (0, _typeof3.default)(obj[prop]) === 'object' && !result.length) {
						if (obj[prop].path === val) {
							result.object = obj[prop];
							break;
						} else {
							PanelHeading.getDeepProp(val, obj[prop], result);
						}
					}
				}
			}
		}]);
		return PanelHeading;
	}();
	
	module.exports = ko.components.register('panel-heading', {
		viewModel: PanelHeading,
		template: '\n\t\t<section class="panel-heading">\n\t\t\t<div class="panel-title">\n\t\t\t\t\n\t\t\t\t<a data-bind="click: setActive, attr: {href: \'#\' + collapseId, \'aria-controls\': collapseId, \'aria-expanded\': isExpanded}" class="btn btn-icon btn-title" type="button" data-toggle="collapse" aria-expanded="false">\n\t\t\t\t\t<span class="btn btn-icon shevron white-shevron-up"></span>\n\t\t\t\t\t<p data-bind="text: title" class="title">Panel title</p>\n\t\t\t\t</a>\n\t\t\t\t\n\t\t\t\t<!-- ko if: _panelName === \'events\'-->\n\t\t\t\t\t<span data-bind="text: cardSize" class="counter"></span>\n\t\t\t\t<!-- /ko-->\n\t\t\t\t\n\t\t\t\t<!-- ko if: _panelName === \'page\'-->\n\t\t\t\t\t<pagination params="number: data.number, totalPages: data.totalPages, page: page"></pagination>\n\t\t\t\t<!-- /ko-->\n\t\t\t\t\n\t\t\t\t<!-- ko if: hasAnotherRequest -->\n\t\t\t\t<section class="follow-request">\n\t\t\t\t\t<span data-bind="css: anotherRequestColor" class="color-indicator"></span>\n\t\t\t\t\t<button data-bind="click: followRequest" class="btn btn-request" type="button">another request</button>\n\t\t\t\t</section>\n\t\t\t\t<!-- /ko-->\n\t\t\t</div>\n\t\t</section>\n' });

/***/ },
/* 146 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
		value: true
	});
	exports.colorsService = exports.jsonHL = exports.config = exports.rest = exports.apiKey = exports.base = undefined;
	
	var _base = __webpack_require__(147);
	
	var _base2 = _interopRequireDefault(_base);
	
	var _apiKey = __webpack_require__(148);
	
	var _apiKey2 = _interopRequireDefault(_apiKey);
	
	var _config = __webpack_require__(149);
	
	var _config2 = _interopRequireDefault(_config);
	
	var _jsonHighlight = __webpack_require__(150);
	
	var _jsonHighlight2 = _interopRequireDefault(_jsonHighlight);
	
	var _colors = __webpack_require__(153);
	
	var _colors2 = _interopRequireDefault(_colors);
	
	var _rest = __webpack_require__(154);
	
	var _rest2 = _interopRequireDefault(_rest);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.base = _base2.default;
	exports.apiKey = _apiKey2.default;
	exports.rest = _rest2.default;
	exports.config = _config2.default;
	exports.jsonHL = _jsonHighlight2.default;
	exports.colorsService = _colors2.default;

/***/ },
/* 147 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function($) {"use strict";
	
	var base = {};
	var CONFIG_URL = '../../apidescription.xml';
	
	var parseData = function parseData(xml) {
		var global = {};
		//get all APIs
		var resourcesEl = $(xml).find("resources").eq(0);
	
		// resource
		$(xml).find("resource").get().map(function (res) {
			var resource = $(res);
			// method --------------------------------
			var methodElem = resource.find("method").eq(0);
	
			var method = {
				id: methodElem.attr("id"), // method id
				name: methodElem.attr("apigee:displayName") || methodElem.attr("id"), // method name
				method: methodElem.attr('name'), // GET or POST
				category: methodElem.find('[primary="true"]').text().trim(), // API name
				path: resource.attr('path'), // method URL
				base: resourcesEl.attr('base'), // method base link
				link: methodElem.find('doc').eq(0).attr('apigee:url'), // link to documentation
				description: methodElem.find('doc').eq(0).text().trim(), //method description
				parameters: {}
			};
	
			// params --------------------------------
			resource.find('param').get().map(function (par) {
				var param = $(par);
				var options = param.find('option');
				var isSelect = !!options.length;
	
				var parameter = {
					name: param.attr('name'),
					doc: param.first('doc').text().trim(),
					style: param.attr('style'),
					required: param.attr('required') === 'true',
					default: param.attr('default') === 'none' && isSelect ? '' : param.attr('default'),
					select: isSelect,
					type: param.attr('type').replace('xsd:', '')
				};
	
				if (isSelect) {
					parameter.options = options.get().map(function (option) {
						return {
							name: $(option).attr('value'),
							checked: $(option).attr('value') === parameter.default || $(option).attr('value') === 'none',
							link: false
						};
					});
				}
	
				method.parameters[parameter.name] = parameter;
			});
	
			/**
	   * Global obj composition
	      */
			// set category obj
			global[method.category] = global[method.category] || {};
	
			// set methods type obj
			global[method.category].ALL = global[method.category].ALL || {};
			global[method.category][method.method] = global[method.category][method.method] || {};
	
			// set method obj
			global[method.category].ALL[method.id] = method;
			global[method.category][method.method][method.id] = method;
		});
	
		return global;
	};
	
	//gets document from WADL configuration file
	var readFromWADL = function readFromWADL() {
		$.ajax({
			url: CONFIG_URL,
			async: false,
			dataType: "text",
			success: function success(response) {
				var xml = $.parseXML(response);
				base = parseData(xml);
			},
	
			error: function error(XMLHttpRequest, textStatus, errorThrown) {
				alert('Data Could Not Be Loaded - ' + textStatus);
			}
		});
	};
	readFromWADL();
	module.exports = base;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ },
/* 148 */
/***/ function(module, exports) {

	'use strict';
	
	var apiKey = apiKeyService.checkApiKeyCookie('tk-api-key') || apiKeyService.getApiExploreKey(); //API Key
	
	module.exports = {
	  placeholder: 'Api key',
	  name: 'apikey',
	  style: 'query',
	  value: ko.observable(apiKey),
	  type: 'string',
	  required: true
	};

/***/ },
/* 149 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function($) {'use strict';
	
	var config = ko.observable();
	
	$.ajax({
		type: 'GET',
		url: ['http://', document.location.hostname, document.location.port && ':' + document.location.port, '/scripts/api-explorer/v2/config.json'].join(''),
		async: true,
		dataType: "json",
		complete: function complete(res, msg) {
			if (msg == 'error') {
				console.error('can\'t load config.json!');
			} else {
				config(res.responseJSON);
			}
		}
	});
	
	module.exports = config;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ },
/* 150 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function($) {'use strict';
	
	var Worker = __webpack_require__(151); // Json-formatter worker
	
	module.exports = function (observable, code) {
		var animTime = 100;
		var worker = new Worker();
	
		worker.onmessage = function (event) {
			observable(event.data);
	
			$(document).on('click touch', '.tm-code-container .expanded', function jsonCodeContainerExpanded(e) {
				e.preventDefault();
				e.stopPropagation();
				var $self = $(this);
				$self.parent().find('>ul').slideUp(animTime, function () {
					$self.addClass('collapsed');
				});
			}).on('click touch', '.tm-code-container .expanded.collapsed', function jsonCodeContainerCollapsed(e) {
				e.preventDefault();
				e.stopPropagation();
				var $self = $(this);
				$self.removeClass('collapsed').parent().find('>ul').slideDown(animTime, function () {
					$self.removeClass('collapsed').removeClass('hidden');
				});
			});
		};
		worker.onerror = function (event) {
			console.error(event);
		};
	
		worker.postMessage(code);
	};
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ },
/* 151 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";module.exports=function(){return __webpack_require__(152)("/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\r\n\t * Code format web-worker\r\n\t * @param event\r\n\t */\r\n\t// var highlightJson()\r\n\tvar highlightJson = __webpack_require__(1);\r\n\t\r\n\tonmessage = function(event) {\r\n\t  var code = event.data;\r\n\t  // importScripts('json-parse.js');\r\n\t  var result = highlightJson(code, {expanded: true});\r\n\t  // var result =JSON.stringify(code);\r\n\t  postMessage(result);\r\n\t};\r\n\n\n/***/ },\n/* 1 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar _stringify = __webpack_require__(2);\n\t\n\tvar _stringify2 = _interopRequireDefault(_stringify);\n\t\n\tvar _typeof2 = __webpack_require__(5);\n\t\n\tvar _typeof3 = _interopRequireDefault(_typeof2);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tvar prefix = 'tm-code';\n\t\n\tvar getExpanderClasses = function getExpanderClasses(expanded) {\n\t\tif (!expanded) {\n\t\t\treturn 'expanded collapsed hidden';\n\t\t}\n\t\treturn 'expanded';\n\t};\n\t\n\tvar encode = function encode(value) {\n\t\treturn ['<span>', value, '</span>'].join('');\n\t};\n\t\n\tvar createElement = function createElement(key, value, type, expanderClasses) {\n\t\tvar klass = 'object',\n\t\t    open = '{',\n\t\t    close = '}';\n\t\n\t\tif (Array.isArray(value)) {\n\t\t\tklass = 'array';\n\t\t\topen = '[';\n\t\t\tclose = ']';\n\t\t}\n\t\n\t\tif (value === null) {\n\t\t\treturn ['<li>', '<span class=\"key\">\"', encode(key), '\": </span>', '<span class=\"null\">\"', encode(value), '\"</span>', '</li>'].join('');\n\t\t}\n\t\n\t\tif (type == 'object') {\n\t\t\treturn ['<li>', '<span class=\"', expanderClasses, '\"></span>', '<span class=\"key\">\"', encode(key), '\": </span> ', '<span class=\"open\">', open, '</span> ', '<ul class=\"', klass, '\">', json2html(value, expanderClasses), '</ul>', '<span class=\"close\">', close, '</span>', '</li>'].join('');\n\t\t}\n\t\n\t\tif (type == 'number' || type == 'boolean') {\n\t\t\treturn ['<li>', '<span class=\"key\">\"', encode(key), '\": </span>', '<span class=\"', type, '\">', encode(value), '</span>', '</li>'].join('');\n\t\t}\n\t\treturn ['<li>', '<span class=\"key\">\"', encode(key), '\": </span>', '<span class=\"', type, '\">\"', encode(value), '\"</span>', '</li>'].join('');\n\t};\n\t\n\tvar json2html = function json2html(json, expanderClasses) {\n\t\tvar html = '';\n\t\tfor (var key in json) {\n\t\t\tif (!json.hasOwnProperty(key)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\n\t\t\thtml = [html, createElement(key, json[key], (0, _typeof3.default)(json[key]), expanderClasses)].join('');\n\t\t}\n\t\treturn html;\n\t};\n\t\n\tvar getJsonViewer = function getJsonViewer(data, options) {\n\t\ttry {\n\t\t\treturn ['<ul class=\"', prefix, '-container\">', json2html([JSON.parse(data)], getExpanderClasses(options.expanded)), '</ul>'].join('');\n\t\t} catch (e) {\n\t\t\treturn ['<div class=\"', prefix, '-error\" >', e.toString(), ' </div>'].join('');\n\t\t}\n\t};\n\t\n\tmodule.exports = function (data, opt) {\n\t\tvar json = '';\n\t\tvar options = opt || { expanded: true };\n\t\tif (typeof data == 'string') {\n\t\t\tjson = data;\n\t\t} else if ((typeof data === 'undefined' ? 'undefined' : (0, _typeof3.default)(data)) == 'object') {\n\t\t\tjson = (0, _stringify2.default)(data);\n\t\t}\n\t\treturn getJsonViewer(json, options);\n\t};\n\n/***/ },\n/* 2 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = { \"default\": __webpack_require__(3), __esModule: true };\n\n/***/ },\n/* 3 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar core  = __webpack_require__(4)\n\t  , $JSON = core.JSON || (core.JSON = {stringify: JSON.stringify});\n\tmodule.exports = function stringify(it){ // eslint-disable-line no-unused-vars\n\t  return $JSON.stringify.apply($JSON, arguments);\n\t};\n\n/***/ },\n/* 4 */\n/***/ function(module, exports) {\n\n\tvar core = module.exports = {version: '2.4.0'};\n\tif(typeof __e == 'number')__e = core; // eslint-disable-line no-undef\n\n/***/ },\n/* 5 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t\n\texports.__esModule = true;\n\t\n\tvar _iterator = __webpack_require__(6);\n\t\n\tvar _iterator2 = _interopRequireDefault(_iterator);\n\t\n\tvar _symbol = __webpack_require__(56);\n\t\n\tvar _symbol2 = _interopRequireDefault(_symbol);\n\t\n\tvar _typeof = typeof _symbol2.default === \"function\" && typeof _iterator2.default === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof _symbol2.default === \"function\" && obj.constructor === _symbol2.default && obj !== _symbol2.default.prototype ? \"symbol\" : typeof obj; };\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\texports.default = typeof _symbol2.default === \"function\" && _typeof(_iterator2.default) === \"symbol\" ? function (obj) {\n\t  return typeof obj === \"undefined\" ? \"undefined\" : _typeof(obj);\n\t} : function (obj) {\n\t  return obj && typeof _symbol2.default === \"function\" && obj.constructor === _symbol2.default && obj !== _symbol2.default.prototype ? \"symbol\" : typeof obj === \"undefined\" ? \"undefined\" : _typeof(obj);\n\t};\n\n/***/ },\n/* 6 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = { \"default\": __webpack_require__(7), __esModule: true };\n\n/***/ },\n/* 7 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t__webpack_require__(8);\n\t__webpack_require__(51);\n\tmodule.exports = __webpack_require__(55).f('iterator');\n\n/***/ },\n/* 8 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\tvar $at  = __webpack_require__(9)(true);\n\t\n\t// 21.1.3.27 String.prototype[@@iterator]()\n\t__webpack_require__(12)(String, 'String', function(iterated){\n\t  this._t = String(iterated); // target\n\t  this._i = 0;                // next index\n\t// 21.1.5.2.1 %StringIteratorPrototype%.next()\n\t}, function(){\n\t  var O     = this._t\n\t    , index = this._i\n\t    , point;\n\t  if(index >= O.length)return {value: undefined, done: true};\n\t  point = $at(O, index);\n\t  this._i += point.length;\n\t  return {value: point, done: false};\n\t});\n\n/***/ },\n/* 9 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar toInteger = __webpack_require__(10)\n\t  , defined   = __webpack_require__(11);\n\t// true  -> String#at\n\t// false -> String#codePointAt\n\tmodule.exports = function(TO_STRING){\n\t  return function(that, pos){\n\t    var s = String(defined(that))\n\t      , i = toInteger(pos)\n\t      , l = s.length\n\t      , a, b;\n\t    if(i < 0 || i >= l)return TO_STRING ? '' : undefined;\n\t    a = s.charCodeAt(i);\n\t    return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff\n\t      ? TO_STRING ? s.charAt(i) : a\n\t      : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;\n\t  };\n\t};\n\n/***/ },\n/* 10 */\n/***/ function(module, exports) {\n\n\t// 7.1.4 ToInteger\n\tvar ceil  = Math.ceil\n\t  , floor = Math.floor;\n\tmodule.exports = function(it){\n\t  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);\n\t};\n\n/***/ },\n/* 11 */\n/***/ function(module, exports) {\n\n\t// 7.2.1 RequireObjectCoercible(argument)\n\tmodule.exports = function(it){\n\t  if(it == undefined)throw TypeError(\"Can't call method on  \" + it);\n\t  return it;\n\t};\n\n/***/ },\n/* 12 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\tvar LIBRARY        = __webpack_require__(13)\n\t  , $export        = __webpack_require__(14)\n\t  , redefine       = __webpack_require__(28)\n\t  , hide           = __webpack_require__(18)\n\t  , has            = __webpack_require__(29)\n\t  , Iterators      = __webpack_require__(30)\n\t  , $iterCreate    = __webpack_require__(31)\n\t  , setToStringTag = __webpack_require__(47)\n\t  , getPrototypeOf = __webpack_require__(49)\n\t  , ITERATOR       = __webpack_require__(48)('iterator')\n\t  , BUGGY          = !([].keys && 'next' in [].keys()) // Safari has buggy iterators w/o `next`\n\t  , FF_ITERATOR    = '@@iterator'\n\t  , KEYS           = 'keys'\n\t  , VALUES         = 'values';\n\t\n\tvar returnThis = function(){ return this; };\n\t\n\tmodule.exports = function(Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED){\n\t  $iterCreate(Constructor, NAME, next);\n\t  var getMethod = function(kind){\n\t    if(!BUGGY && kind in proto)return proto[kind];\n\t    switch(kind){\n\t      case KEYS: return function keys(){ return new Constructor(this, kind); };\n\t      case VALUES: return function values(){ return new Constructor(this, kind); };\n\t    } return function entries(){ return new Constructor(this, kind); };\n\t  };\n\t  var TAG        = NAME + ' Iterator'\n\t    , DEF_VALUES = DEFAULT == VALUES\n\t    , VALUES_BUG = false\n\t    , proto      = Base.prototype\n\t    , $native    = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT]\n\t    , $default   = $native || getMethod(DEFAULT)\n\t    , $entries   = DEFAULT ? !DEF_VALUES ? $default : getMethod('entries') : undefined\n\t    , $anyNative = NAME == 'Array' ? proto.entries || $native : $native\n\t    , methods, key, IteratorPrototype;\n\t  // Fix native\n\t  if($anyNative){\n\t    IteratorPrototype = getPrototypeOf($anyNative.call(new Base));\n\t    if(IteratorPrototype !== Object.prototype){\n\t      // Set @@toStringTag to native iterators\n\t      setToStringTag(IteratorPrototype, TAG, true);\n\t      // fix for some old engines\n\t      if(!LIBRARY && !has(IteratorPrototype, ITERATOR))hide(IteratorPrototype, ITERATOR, returnThis);\n\t    }\n\t  }\n\t  // fix Array#{values, @@iterator}.name in V8 / FF\n\t  if(DEF_VALUES && $native && $native.name !== VALUES){\n\t    VALUES_BUG = true;\n\t    $default = function values(){ return $native.call(this); };\n\t  }\n\t  // Define iterator\n\t  if((!LIBRARY || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])){\n\t    hide(proto, ITERATOR, $default);\n\t  }\n\t  // Plug for library\n\t  Iterators[NAME] = $default;\n\t  Iterators[TAG]  = returnThis;\n\t  if(DEFAULT){\n\t    methods = {\n\t      values:  DEF_VALUES ? $default : getMethod(VALUES),\n\t      keys:    IS_SET     ? $default : getMethod(KEYS),\n\t      entries: $entries\n\t    };\n\t    if(FORCED)for(key in methods){\n\t      if(!(key in proto))redefine(proto, key, methods[key]);\n\t    } else $export($export.P + $export.F * (BUGGY || VALUES_BUG), NAME, methods);\n\t  }\n\t  return methods;\n\t};\n\n/***/ },\n/* 13 */\n/***/ function(module, exports) {\n\n\tmodule.exports = true;\n\n/***/ },\n/* 14 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar global    = __webpack_require__(15)\n\t  , core      = __webpack_require__(4)\n\t  , ctx       = __webpack_require__(16)\n\t  , hide      = __webpack_require__(18)\n\t  , PROTOTYPE = 'prototype';\n\t\n\tvar $export = function(type, name, source){\n\t  var IS_FORCED = type & $export.F\n\t    , IS_GLOBAL = type & $export.G\n\t    , IS_STATIC = type & $export.S\n\t    , IS_PROTO  = type & $export.P\n\t    , IS_BIND   = type & $export.B\n\t    , IS_WRAP   = type & $export.W\n\t    , exports   = IS_GLOBAL ? core : core[name] || (core[name] = {})\n\t    , expProto  = exports[PROTOTYPE]\n\t    , target    = IS_GLOBAL ? global : IS_STATIC ? global[name] : (global[name] || {})[PROTOTYPE]\n\t    , key, own, out;\n\t  if(IS_GLOBAL)source = name;\n\t  for(key in source){\n\t    // contains in native\n\t    own = !IS_FORCED && target && target[key] !== undefined;\n\t    if(own && key in exports)continue;\n\t    // export native or passed\n\t    out = own ? target[key] : source[key];\n\t    // prevent global pollution for namespaces\n\t    exports[key] = IS_GLOBAL && typeof target[key] != 'function' ? source[key]\n\t    // bind timers to global for call from export context\n\t    : IS_BIND && own ? ctx(out, global)\n\t    // wrap global constructors for prevent change them in library\n\t    : IS_WRAP && target[key] == out ? (function(C){\n\t      var F = function(a, b, c){\n\t        if(this instanceof C){\n\t          switch(arguments.length){\n\t            case 0: return new C;\n\t            case 1: return new C(a);\n\t            case 2: return new C(a, b);\n\t          } return new C(a, b, c);\n\t        } return C.apply(this, arguments);\n\t      };\n\t      F[PROTOTYPE] = C[PROTOTYPE];\n\t      return F;\n\t    // make static versions for prototype methods\n\t    })(out) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;\n\t    // export proto methods to core.%CONSTRUCTOR%.methods.%NAME%\n\t    if(IS_PROTO){\n\t      (exports.virtual || (exports.virtual = {}))[key] = out;\n\t      // export proto methods to core.%CONSTRUCTOR%.prototype.%NAME%\n\t      if(type & $export.R && expProto && !expProto[key])hide(expProto, key, out);\n\t    }\n\t  }\n\t};\n\t// type bitmap\n\t$export.F = 1;   // forced\n\t$export.G = 2;   // global\n\t$export.S = 4;   // static\n\t$export.P = 8;   // proto\n\t$export.B = 16;  // bind\n\t$export.W = 32;  // wrap\n\t$export.U = 64;  // safe\n\t$export.R = 128; // real proto method for `library` \n\tmodule.exports = $export;\n\n/***/ },\n/* 15 */\n/***/ function(module, exports) {\n\n\t// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028\n\tvar global = module.exports = typeof window != 'undefined' && window.Math == Math\n\t  ? window : typeof self != 'undefined' && self.Math == Math ? self : Function('return this')();\n\tif(typeof __g == 'number')__g = global; // eslint-disable-line no-undef\n\n/***/ },\n/* 16 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// optional / simple context binding\n\tvar aFunction = __webpack_require__(17);\n\tmodule.exports = function(fn, that, length){\n\t  aFunction(fn);\n\t  if(that === undefined)return fn;\n\t  switch(length){\n\t    case 1: return function(a){\n\t      return fn.call(that, a);\n\t    };\n\t    case 2: return function(a, b){\n\t      return fn.call(that, a, b);\n\t    };\n\t    case 3: return function(a, b, c){\n\t      return fn.call(that, a, b, c);\n\t    };\n\t  }\n\t  return function(/* ...args */){\n\t    return fn.apply(that, arguments);\n\t  };\n\t};\n\n/***/ },\n/* 17 */\n/***/ function(module, exports) {\n\n\tmodule.exports = function(it){\n\t  if(typeof it != 'function')throw TypeError(it + ' is not a function!');\n\t  return it;\n\t};\n\n/***/ },\n/* 18 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar dP         = __webpack_require__(19)\n\t  , createDesc = __webpack_require__(27);\n\tmodule.exports = __webpack_require__(23) ? function(object, key, value){\n\t  return dP.f(object, key, createDesc(1, value));\n\t} : function(object, key, value){\n\t  object[key] = value;\n\t  return object;\n\t};\n\n/***/ },\n/* 19 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar anObject       = __webpack_require__(20)\n\t  , IE8_DOM_DEFINE = __webpack_require__(22)\n\t  , toPrimitive    = __webpack_require__(26)\n\t  , dP             = Object.defineProperty;\n\t\n\texports.f = __webpack_require__(23) ? Object.defineProperty : function defineProperty(O, P, Attributes){\n\t  anObject(O);\n\t  P = toPrimitive(P, true);\n\t  anObject(Attributes);\n\t  if(IE8_DOM_DEFINE)try {\n\t    return dP(O, P, Attributes);\n\t  } catch(e){ /* empty */ }\n\t  if('get' in Attributes || 'set' in Attributes)throw TypeError('Accessors not supported!');\n\t  if('value' in Attributes)O[P] = Attributes.value;\n\t  return O;\n\t};\n\n/***/ },\n/* 20 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar isObject = __webpack_require__(21);\n\tmodule.exports = function(it){\n\t  if(!isObject(it))throw TypeError(it + ' is not an object!');\n\t  return it;\n\t};\n\n/***/ },\n/* 21 */\n/***/ function(module, exports) {\n\n\tmodule.exports = function(it){\n\t  return typeof it === 'object' ? it !== null : typeof it === 'function';\n\t};\n\n/***/ },\n/* 22 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = !__webpack_require__(23) && !__webpack_require__(24)(function(){\r\n\t  return Object.defineProperty(__webpack_require__(25)('div'), 'a', {get: function(){ return 7; }}).a != 7;\r\n\t});\n\n/***/ },\n/* 23 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// Thank's IE8 for his funny defineProperty\n\tmodule.exports = !__webpack_require__(24)(function(){\n\t  return Object.defineProperty({}, 'a', {get: function(){ return 7; }}).a != 7;\n\t});\n\n/***/ },\n/* 24 */\n/***/ function(module, exports) {\n\n\tmodule.exports = function(exec){\n\t  try {\n\t    return !!exec();\n\t  } catch(e){\n\t    return true;\n\t  }\n\t};\n\n/***/ },\n/* 25 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar isObject = __webpack_require__(21)\n\t  , document = __webpack_require__(15).document\n\t  // in old IE typeof document.createElement is 'object'\n\t  , is = isObject(document) && isObject(document.createElement);\n\tmodule.exports = function(it){\n\t  return is ? document.createElement(it) : {};\n\t};\n\n/***/ },\n/* 26 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// 7.1.1 ToPrimitive(input [, PreferredType])\n\tvar isObject = __webpack_require__(21);\n\t// instead of the ES6 spec version, we didn't implement @@toPrimitive case\n\t// and the second argument - flag - preferred type is a string\n\tmodule.exports = function(it, S){\n\t  if(!isObject(it))return it;\n\t  var fn, val;\n\t  if(S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it)))return val;\n\t  if(typeof (fn = it.valueOf) == 'function' && !isObject(val = fn.call(it)))return val;\n\t  if(!S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it)))return val;\n\t  throw TypeError(\"Can't convert object to primitive value\");\n\t};\n\n/***/ },\n/* 27 */\n/***/ function(module, exports) {\n\n\tmodule.exports = function(bitmap, value){\n\t  return {\n\t    enumerable  : !(bitmap & 1),\n\t    configurable: !(bitmap & 2),\n\t    writable    : !(bitmap & 4),\n\t    value       : value\n\t  };\n\t};\n\n/***/ },\n/* 28 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__(18);\n\n/***/ },\n/* 29 */\n/***/ function(module, exports) {\n\n\tvar hasOwnProperty = {}.hasOwnProperty;\n\tmodule.exports = function(it, key){\n\t  return hasOwnProperty.call(it, key);\n\t};\n\n/***/ },\n/* 30 */\n/***/ function(module, exports) {\n\n\tmodule.exports = {};\n\n/***/ },\n/* 31 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\tvar create         = __webpack_require__(32)\n\t  , descriptor     = __webpack_require__(27)\n\t  , setToStringTag = __webpack_require__(47)\n\t  , IteratorPrototype = {};\n\t\n\t// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()\n\t__webpack_require__(18)(IteratorPrototype, __webpack_require__(48)('iterator'), function(){ return this; });\n\t\n\tmodule.exports = function(Constructor, NAME, next){\n\t  Constructor.prototype = create(IteratorPrototype, {next: descriptor(1, next)});\n\t  setToStringTag(Constructor, NAME + ' Iterator');\n\t};\n\n/***/ },\n/* 32 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])\r\n\tvar anObject    = __webpack_require__(20)\r\n\t  , dPs         = __webpack_require__(33)\r\n\t  , enumBugKeys = __webpack_require__(45)\r\n\t  , IE_PROTO    = __webpack_require__(42)('IE_PROTO')\r\n\t  , Empty       = function(){ /* empty */ }\r\n\t  , PROTOTYPE   = 'prototype';\r\n\t\r\n\t// Create object with fake `null` prototype: use iframe Object with cleared prototype\r\n\tvar createDict = function(){\r\n\t  // Thrash, waste and sodomy: IE GC bug\r\n\t  var iframe = __webpack_require__(25)('iframe')\r\n\t    , i      = enumBugKeys.length\r\n\t    , gt     = '>'\r\n\t    , iframeDocument;\r\n\t  iframe.style.display = 'none';\r\n\t  __webpack_require__(46).appendChild(iframe);\r\n\t  iframe.src = 'javascript:'; // eslint-disable-line no-script-url\r\n\t  // createDict = iframe.contentWindow.Object;\r\n\t  // html.removeChild(iframe);\r\n\t  iframeDocument = iframe.contentWindow.document;\r\n\t  iframeDocument.open();\r\n\t  iframeDocument.write('<script>document.F=Object</script' + gt);\r\n\t  iframeDocument.close();\r\n\t  createDict = iframeDocument.F;\r\n\t  while(i--)delete createDict[PROTOTYPE][enumBugKeys[i]];\r\n\t  return createDict();\r\n\t};\r\n\t\r\n\tmodule.exports = Object.create || function create(O, Properties){\r\n\t  var result;\r\n\t  if(O !== null){\r\n\t    Empty[PROTOTYPE] = anObject(O);\r\n\t    result = new Empty;\r\n\t    Empty[PROTOTYPE] = null;\r\n\t    // add \"__proto__\" for Object.getPrototypeOf polyfill\r\n\t    result[IE_PROTO] = O;\r\n\t  } else result = createDict();\r\n\t  return Properties === undefined ? result : dPs(result, Properties);\r\n\t};\n\n/***/ },\n/* 33 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar dP       = __webpack_require__(19)\r\n\t  , anObject = __webpack_require__(20)\r\n\t  , getKeys  = __webpack_require__(34);\r\n\t\r\n\tmodule.exports = __webpack_require__(23) ? Object.defineProperties : function defineProperties(O, Properties){\r\n\t  anObject(O);\r\n\t  var keys   = getKeys(Properties)\r\n\t    , length = keys.length\r\n\t    , i = 0\r\n\t    , P;\r\n\t  while(length > i)dP.f(O, P = keys[i++], Properties[P]);\r\n\t  return O;\r\n\t};\n\n/***/ },\n/* 34 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// 19.1.2.14 / 15.2.3.14 Object.keys(O)\r\n\tvar $keys       = __webpack_require__(35)\r\n\t  , enumBugKeys = __webpack_require__(45);\r\n\t\r\n\tmodule.exports = Object.keys || function keys(O){\r\n\t  return $keys(O, enumBugKeys);\r\n\t};\n\n/***/ },\n/* 35 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar has          = __webpack_require__(29)\r\n\t  , toIObject    = __webpack_require__(36)\r\n\t  , arrayIndexOf = __webpack_require__(39)(false)\r\n\t  , IE_PROTO     = __webpack_require__(42)('IE_PROTO');\r\n\t\r\n\tmodule.exports = function(object, names){\r\n\t  var O      = toIObject(object)\r\n\t    , i      = 0\r\n\t    , result = []\r\n\t    , key;\r\n\t  for(key in O)if(key != IE_PROTO)has(O, key) && result.push(key);\r\n\t  // Don't enum bug & hidden keys\r\n\t  while(names.length > i)if(has(O, key = names[i++])){\r\n\t    ~arrayIndexOf(result, key) || result.push(key);\r\n\t  }\r\n\t  return result;\r\n\t};\n\n/***/ },\n/* 36 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// to indexed object, toObject with fallback for non-array-like ES3 strings\n\tvar IObject = __webpack_require__(37)\n\t  , defined = __webpack_require__(11);\n\tmodule.exports = function(it){\n\t  return IObject(defined(it));\n\t};\n\n/***/ },\n/* 37 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// fallback for non-array-like ES3 and non-enumerable old V8 strings\n\tvar cof = __webpack_require__(38);\n\tmodule.exports = Object('z').propertyIsEnumerable(0) ? Object : function(it){\n\t  return cof(it) == 'String' ? it.split('') : Object(it);\n\t};\n\n/***/ },\n/* 38 */\n/***/ function(module, exports) {\n\n\tvar toString = {}.toString;\n\t\n\tmodule.exports = function(it){\n\t  return toString.call(it).slice(8, -1);\n\t};\n\n/***/ },\n/* 39 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// false -> Array#indexOf\n\t// true  -> Array#includes\n\tvar toIObject = __webpack_require__(36)\n\t  , toLength  = __webpack_require__(40)\n\t  , toIndex   = __webpack_require__(41);\n\tmodule.exports = function(IS_INCLUDES){\n\t  return function($this, el, fromIndex){\n\t    var O      = toIObject($this)\n\t      , length = toLength(O.length)\n\t      , index  = toIndex(fromIndex, length)\n\t      , value;\n\t    // Array#includes uses SameValueZero equality algorithm\n\t    if(IS_INCLUDES && el != el)while(length > index){\n\t      value = O[index++];\n\t      if(value != value)return true;\n\t    // Array#toIndex ignores holes, Array#includes - not\n\t    } else for(;length > index; index++)if(IS_INCLUDES || index in O){\n\t      if(O[index] === el)return IS_INCLUDES || index || 0;\n\t    } return !IS_INCLUDES && -1;\n\t  };\n\t};\n\n/***/ },\n/* 40 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// 7.1.15 ToLength\n\tvar toInteger = __webpack_require__(10)\n\t  , min       = Math.min;\n\tmodule.exports = function(it){\n\t  return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991\n\t};\n\n/***/ },\n/* 41 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar toInteger = __webpack_require__(10)\n\t  , max       = Math.max\n\t  , min       = Math.min;\n\tmodule.exports = function(index, length){\n\t  index = toInteger(index);\n\t  return index < 0 ? max(index + length, 0) : min(index, length);\n\t};\n\n/***/ },\n/* 42 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar shared = __webpack_require__(43)('keys')\r\n\t  , uid    = __webpack_require__(44);\r\n\tmodule.exports = function(key){\r\n\t  return shared[key] || (shared[key] = uid(key));\r\n\t};\n\n/***/ },\n/* 43 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar global = __webpack_require__(15)\n\t  , SHARED = '__core-js_shared__'\n\t  , store  = global[SHARED] || (global[SHARED] = {});\n\tmodule.exports = function(key){\n\t  return store[key] || (store[key] = {});\n\t};\n\n/***/ },\n/* 44 */\n/***/ function(module, exports) {\n\n\tvar id = 0\n\t  , px = Math.random();\n\tmodule.exports = function(key){\n\t  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));\n\t};\n\n/***/ },\n/* 45 */\n/***/ function(module, exports) {\n\n\t// IE 8- don't enum bug keys\r\n\tmodule.exports = (\r\n\t  'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'\r\n\t).split(',');\n\n/***/ },\n/* 46 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__(15).document && document.documentElement;\n\n/***/ },\n/* 47 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar def = __webpack_require__(19).f\n\t  , has = __webpack_require__(29)\n\t  , TAG = __webpack_require__(48)('toStringTag');\n\t\n\tmodule.exports = function(it, tag, stat){\n\t  if(it && !has(it = stat ? it : it.prototype, TAG))def(it, TAG, {configurable: true, value: tag});\n\t};\n\n/***/ },\n/* 48 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar store      = __webpack_require__(43)('wks')\n\t  , uid        = __webpack_require__(44)\n\t  , Symbol     = __webpack_require__(15).Symbol\n\t  , USE_SYMBOL = typeof Symbol == 'function';\n\t\n\tvar $exports = module.exports = function(name){\n\t  return store[name] || (store[name] =\n\t    USE_SYMBOL && Symbol[name] || (USE_SYMBOL ? Symbol : uid)('Symbol.' + name));\n\t};\n\t\n\t$exports.store = store;\n\n/***/ },\n/* 49 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// 19.1.2.9 / 15.2.3.2 Object.getPrototypeOf(O)\r\n\tvar has         = __webpack_require__(29)\r\n\t  , toObject    = __webpack_require__(50)\r\n\t  , IE_PROTO    = __webpack_require__(42)('IE_PROTO')\r\n\t  , ObjectProto = Object.prototype;\r\n\t\r\n\tmodule.exports = Object.getPrototypeOf || function(O){\r\n\t  O = toObject(O);\r\n\t  if(has(O, IE_PROTO))return O[IE_PROTO];\r\n\t  if(typeof O.constructor == 'function' && O instanceof O.constructor){\r\n\t    return O.constructor.prototype;\r\n\t  } return O instanceof Object ? ObjectProto : null;\r\n\t};\n\n/***/ },\n/* 50 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// 7.1.13 ToObject(argument)\n\tvar defined = __webpack_require__(11);\n\tmodule.exports = function(it){\n\t  return Object(defined(it));\n\t};\n\n/***/ },\n/* 51 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t__webpack_require__(52);\n\tvar global        = __webpack_require__(15)\n\t  , hide          = __webpack_require__(18)\n\t  , Iterators     = __webpack_require__(30)\n\t  , TO_STRING_TAG = __webpack_require__(48)('toStringTag');\n\t\n\tfor(var collections = ['NodeList', 'DOMTokenList', 'MediaList', 'StyleSheetList', 'CSSRuleList'], i = 0; i < 5; i++){\n\t  var NAME       = collections[i]\n\t    , Collection = global[NAME]\n\t    , proto      = Collection && Collection.prototype;\n\t  if(proto && !proto[TO_STRING_TAG])hide(proto, TO_STRING_TAG, NAME);\n\t  Iterators[NAME] = Iterators.Array;\n\t}\n\n/***/ },\n/* 52 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\tvar addToUnscopables = __webpack_require__(53)\n\t  , step             = __webpack_require__(54)\n\t  , Iterators        = __webpack_require__(30)\n\t  , toIObject        = __webpack_require__(36);\n\t\n\t// 22.1.3.4 Array.prototype.entries()\n\t// 22.1.3.13 Array.prototype.keys()\n\t// 22.1.3.29 Array.prototype.values()\n\t// 22.1.3.30 Array.prototype[@@iterator]()\n\tmodule.exports = __webpack_require__(12)(Array, 'Array', function(iterated, kind){\n\t  this._t = toIObject(iterated); // target\n\t  this._i = 0;                   // next index\n\t  this._k = kind;                // kind\n\t// 22.1.5.2.1 %ArrayIteratorPrototype%.next()\n\t}, function(){\n\t  var O     = this._t\n\t    , kind  = this._k\n\t    , index = this._i++;\n\t  if(!O || index >= O.length){\n\t    this._t = undefined;\n\t    return step(1);\n\t  }\n\t  if(kind == 'keys'  )return step(0, index);\n\t  if(kind == 'values')return step(0, O[index]);\n\t  return step(0, [index, O[index]]);\n\t}, 'values');\n\t\n\t// argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7)\n\tIterators.Arguments = Iterators.Array;\n\t\n\taddToUnscopables('keys');\n\taddToUnscopables('values');\n\taddToUnscopables('entries');\n\n/***/ },\n/* 53 */\n/***/ function(module, exports) {\n\n\tmodule.exports = function(){ /* empty */ };\n\n/***/ },\n/* 54 */\n/***/ function(module, exports) {\n\n\tmodule.exports = function(done, value){\n\t  return {value: value, done: !!done};\n\t};\n\n/***/ },\n/* 55 */\n/***/ function(module, exports, __webpack_require__) {\n\n\texports.f = __webpack_require__(48);\n\n/***/ },\n/* 56 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = { \"default\": __webpack_require__(57), __esModule: true };\n\n/***/ },\n/* 57 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t__webpack_require__(58);\n\t__webpack_require__(69);\n\t__webpack_require__(70);\n\t__webpack_require__(71);\n\tmodule.exports = __webpack_require__(4).Symbol;\n\n/***/ },\n/* 58 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t// ECMAScript 6 symbols shim\n\tvar global         = __webpack_require__(15)\n\t  , has            = __webpack_require__(29)\n\t  , DESCRIPTORS    = __webpack_require__(23)\n\t  , $export        = __webpack_require__(14)\n\t  , redefine       = __webpack_require__(28)\n\t  , META           = __webpack_require__(59).KEY\n\t  , $fails         = __webpack_require__(24)\n\t  , shared         = __webpack_require__(43)\n\t  , setToStringTag = __webpack_require__(47)\n\t  , uid            = __webpack_require__(44)\n\t  , wks            = __webpack_require__(48)\n\t  , wksExt         = __webpack_require__(55)\n\t  , wksDefine      = __webpack_require__(60)\n\t  , keyOf          = __webpack_require__(61)\n\t  , enumKeys       = __webpack_require__(62)\n\t  , isArray        = __webpack_require__(65)\n\t  , anObject       = __webpack_require__(20)\n\t  , toIObject      = __webpack_require__(36)\n\t  , toPrimitive    = __webpack_require__(26)\n\t  , createDesc     = __webpack_require__(27)\n\t  , _create        = __webpack_require__(32)\n\t  , gOPNExt        = __webpack_require__(66)\n\t  , $GOPD          = __webpack_require__(68)\n\t  , $DP            = __webpack_require__(19)\n\t  , $keys          = __webpack_require__(34)\n\t  , gOPD           = $GOPD.f\n\t  , dP             = $DP.f\n\t  , gOPN           = gOPNExt.f\n\t  , $Symbol        = global.Symbol\n\t  , $JSON          = global.JSON\n\t  , _stringify     = $JSON && $JSON.stringify\n\t  , PROTOTYPE      = 'prototype'\n\t  , HIDDEN         = wks('_hidden')\n\t  , TO_PRIMITIVE   = wks('toPrimitive')\n\t  , isEnum         = {}.propertyIsEnumerable\n\t  , SymbolRegistry = shared('symbol-registry')\n\t  , AllSymbols     = shared('symbols')\n\t  , OPSymbols      = shared('op-symbols')\n\t  , ObjectProto    = Object[PROTOTYPE]\n\t  , USE_NATIVE     = typeof $Symbol == 'function'\n\t  , QObject        = global.QObject;\n\t// Don't use setters in Qt Script, https://github.com/zloirock/core-js/issues/173\n\tvar setter = !QObject || !QObject[PROTOTYPE] || !QObject[PROTOTYPE].findChild;\n\t\n\t// fallback for old Android, https://code.google.com/p/v8/issues/detail?id=687\n\tvar setSymbolDesc = DESCRIPTORS && $fails(function(){\n\t  return _create(dP({}, 'a', {\n\t    get: function(){ return dP(this, 'a', {value: 7}).a; }\n\t  })).a != 7;\n\t}) ? function(it, key, D){\n\t  var protoDesc = gOPD(ObjectProto, key);\n\t  if(protoDesc)delete ObjectProto[key];\n\t  dP(it, key, D);\n\t  if(protoDesc && it !== ObjectProto)dP(ObjectProto, key, protoDesc);\n\t} : dP;\n\t\n\tvar wrap = function(tag){\n\t  var sym = AllSymbols[tag] = _create($Symbol[PROTOTYPE]);\n\t  sym._k = tag;\n\t  return sym;\n\t};\n\t\n\tvar isSymbol = USE_NATIVE && typeof $Symbol.iterator == 'symbol' ? function(it){\n\t  return typeof it == 'symbol';\n\t} : function(it){\n\t  return it instanceof $Symbol;\n\t};\n\t\n\tvar $defineProperty = function defineProperty(it, key, D){\n\t  if(it === ObjectProto)$defineProperty(OPSymbols, key, D);\n\t  anObject(it);\n\t  key = toPrimitive(key, true);\n\t  anObject(D);\n\t  if(has(AllSymbols, key)){\n\t    if(!D.enumerable){\n\t      if(!has(it, HIDDEN))dP(it, HIDDEN, createDesc(1, {}));\n\t      it[HIDDEN][key] = true;\n\t    } else {\n\t      if(has(it, HIDDEN) && it[HIDDEN][key])it[HIDDEN][key] = false;\n\t      D = _create(D, {enumerable: createDesc(0, false)});\n\t    } return setSymbolDesc(it, key, D);\n\t  } return dP(it, key, D);\n\t};\n\tvar $defineProperties = function defineProperties(it, P){\n\t  anObject(it);\n\t  var keys = enumKeys(P = toIObject(P))\n\t    , i    = 0\n\t    , l = keys.length\n\t    , key;\n\t  while(l > i)$defineProperty(it, key = keys[i++], P[key]);\n\t  return it;\n\t};\n\tvar $create = function create(it, P){\n\t  return P === undefined ? _create(it) : $defineProperties(_create(it), P);\n\t};\n\tvar $propertyIsEnumerable = function propertyIsEnumerable(key){\n\t  var E = isEnum.call(this, key = toPrimitive(key, true));\n\t  if(this === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key))return false;\n\t  return E || !has(this, key) || !has(AllSymbols, key) || has(this, HIDDEN) && this[HIDDEN][key] ? E : true;\n\t};\n\tvar $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(it, key){\n\t  it  = toIObject(it);\n\t  key = toPrimitive(key, true);\n\t  if(it === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key))return;\n\t  var D = gOPD(it, key);\n\t  if(D && has(AllSymbols, key) && !(has(it, HIDDEN) && it[HIDDEN][key]))D.enumerable = true;\n\t  return D;\n\t};\n\tvar $getOwnPropertyNames = function getOwnPropertyNames(it){\n\t  var names  = gOPN(toIObject(it))\n\t    , result = []\n\t    , i      = 0\n\t    , key;\n\t  while(names.length > i){\n\t    if(!has(AllSymbols, key = names[i++]) && key != HIDDEN && key != META)result.push(key);\n\t  } return result;\n\t};\n\tvar $getOwnPropertySymbols = function getOwnPropertySymbols(it){\n\t  var IS_OP  = it === ObjectProto\n\t    , names  = gOPN(IS_OP ? OPSymbols : toIObject(it))\n\t    , result = []\n\t    , i      = 0\n\t    , key;\n\t  while(names.length > i){\n\t    if(has(AllSymbols, key = names[i++]) && (IS_OP ? has(ObjectProto, key) : true))result.push(AllSymbols[key]);\n\t  } return result;\n\t};\n\t\n\t// 19.4.1.1 Symbol([description])\n\tif(!USE_NATIVE){\n\t  $Symbol = function Symbol(){\n\t    if(this instanceof $Symbol)throw TypeError('Symbol is not a constructor!');\n\t    var tag = uid(arguments.length > 0 ? arguments[0] : undefined);\n\t    var $set = function(value){\n\t      if(this === ObjectProto)$set.call(OPSymbols, value);\n\t      if(has(this, HIDDEN) && has(this[HIDDEN], tag))this[HIDDEN][tag] = false;\n\t      setSymbolDesc(this, tag, createDesc(1, value));\n\t    };\n\t    if(DESCRIPTORS && setter)setSymbolDesc(ObjectProto, tag, {configurable: true, set: $set});\n\t    return wrap(tag);\n\t  };\n\t  redefine($Symbol[PROTOTYPE], 'toString', function toString(){\n\t    return this._k;\n\t  });\n\t\n\t  $GOPD.f = $getOwnPropertyDescriptor;\n\t  $DP.f   = $defineProperty;\n\t  __webpack_require__(67).f = gOPNExt.f = $getOwnPropertyNames;\n\t  __webpack_require__(64).f  = $propertyIsEnumerable;\n\t  __webpack_require__(63).f = $getOwnPropertySymbols;\n\t\n\t  if(DESCRIPTORS && !__webpack_require__(13)){\n\t    redefine(ObjectProto, 'propertyIsEnumerable', $propertyIsEnumerable, true);\n\t  }\n\t\n\t  wksExt.f = function(name){\n\t    return wrap(wks(name));\n\t  }\n\t}\n\t\n\t$export($export.G + $export.W + $export.F * !USE_NATIVE, {Symbol: $Symbol});\n\t\n\tfor(var symbols = (\n\t  // 19.4.2.2, 19.4.2.3, 19.4.2.4, 19.4.2.6, 19.4.2.8, 19.4.2.9, 19.4.2.10, 19.4.2.11, 19.4.2.12, 19.4.2.13, 19.4.2.14\n\t  'hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables'\n\t).split(','), i = 0; symbols.length > i; )wks(symbols[i++]);\n\t\n\tfor(var symbols = $keys(wks.store), i = 0; symbols.length > i; )wksDefine(symbols[i++]);\n\t\n\t$export($export.S + $export.F * !USE_NATIVE, 'Symbol', {\n\t  // 19.4.2.1 Symbol.for(key)\n\t  'for': function(key){\n\t    return has(SymbolRegistry, key += '')\n\t      ? SymbolRegistry[key]\n\t      : SymbolRegistry[key] = $Symbol(key);\n\t  },\n\t  // 19.4.2.5 Symbol.keyFor(sym)\n\t  keyFor: function keyFor(key){\n\t    if(isSymbol(key))return keyOf(SymbolRegistry, key);\n\t    throw TypeError(key + ' is not a symbol!');\n\t  },\n\t  useSetter: function(){ setter = true; },\n\t  useSimple: function(){ setter = false; }\n\t});\n\t\n\t$export($export.S + $export.F * !USE_NATIVE, 'Object', {\n\t  // 19.1.2.2 Object.create(O [, Properties])\n\t  create: $create,\n\t  // 19.1.2.4 Object.defineProperty(O, P, Attributes)\n\t  defineProperty: $defineProperty,\n\t  // 19.1.2.3 Object.defineProperties(O, Properties)\n\t  defineProperties: $defineProperties,\n\t  // 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)\n\t  getOwnPropertyDescriptor: $getOwnPropertyDescriptor,\n\t  // 19.1.2.7 Object.getOwnPropertyNames(O)\n\t  getOwnPropertyNames: $getOwnPropertyNames,\n\t  // 19.1.2.8 Object.getOwnPropertySymbols(O)\n\t  getOwnPropertySymbols: $getOwnPropertySymbols\n\t});\n\t\n\t// 24.3.2 JSON.stringify(value [, replacer [, space]])\n\t$JSON && $export($export.S + $export.F * (!USE_NATIVE || $fails(function(){\n\t  var S = $Symbol();\n\t  // MS Edge converts symbol values to JSON as {}\n\t  // WebKit converts symbol values to JSON as null\n\t  // V8 throws on boxed symbols\n\t  return _stringify([S]) != '[null]' || _stringify({a: S}) != '{}' || _stringify(Object(S)) != '{}';\n\t})), 'JSON', {\n\t  stringify: function stringify(it){\n\t    if(it === undefined || isSymbol(it))return; // IE8 returns string on undefined\n\t    var args = [it]\n\t      , i    = 1\n\t      , replacer, $replacer;\n\t    while(arguments.length > i)args.push(arguments[i++]);\n\t    replacer = args[1];\n\t    if(typeof replacer == 'function')$replacer = replacer;\n\t    if($replacer || !isArray(replacer))replacer = function(key, value){\n\t      if($replacer)value = $replacer.call(this, key, value);\n\t      if(!isSymbol(value))return value;\n\t    };\n\t    args[1] = replacer;\n\t    return _stringify.apply($JSON, args);\n\t  }\n\t});\n\t\n\t// 19.4.3.4 Symbol.prototype[@@toPrimitive](hint)\n\t$Symbol[PROTOTYPE][TO_PRIMITIVE] || __webpack_require__(18)($Symbol[PROTOTYPE], TO_PRIMITIVE, $Symbol[PROTOTYPE].valueOf);\n\t// 19.4.3.5 Symbol.prototype[@@toStringTag]\n\tsetToStringTag($Symbol, 'Symbol');\n\t// 20.2.1.9 Math[@@toStringTag]\n\tsetToStringTag(Math, 'Math', true);\n\t// 24.3.3 JSON[@@toStringTag]\n\tsetToStringTag(global.JSON, 'JSON', true);\n\n/***/ },\n/* 59 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar META     = __webpack_require__(44)('meta')\n\t  , isObject = __webpack_require__(21)\n\t  , has      = __webpack_require__(29)\n\t  , setDesc  = __webpack_require__(19).f\n\t  , id       = 0;\n\tvar isExtensible = Object.isExtensible || function(){\n\t  return true;\n\t};\n\tvar FREEZE = !__webpack_require__(24)(function(){\n\t  return isExtensible(Object.preventExtensions({}));\n\t});\n\tvar setMeta = function(it){\n\t  setDesc(it, META, {value: {\n\t    i: 'O' + ++id, // object ID\n\t    w: {}          // weak collections IDs\n\t  }});\n\t};\n\tvar fastKey = function(it, create){\n\t  // return primitive with prefix\n\t  if(!isObject(it))return typeof it == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;\n\t  if(!has(it, META)){\n\t    // can't set metadata to uncaught frozen object\n\t    if(!isExtensible(it))return 'F';\n\t    // not necessary to add metadata\n\t    if(!create)return 'E';\n\t    // add missing metadata\n\t    setMeta(it);\n\t  // return object ID\n\t  } return it[META].i;\n\t};\n\tvar getWeak = function(it, create){\n\t  if(!has(it, META)){\n\t    // can't set metadata to uncaught frozen object\n\t    if(!isExtensible(it))return true;\n\t    // not necessary to add metadata\n\t    if(!create)return false;\n\t    // add missing metadata\n\t    setMeta(it);\n\t  // return hash weak collections IDs\n\t  } return it[META].w;\n\t};\n\t// add metadata on freeze-family methods calling\n\tvar onFreeze = function(it){\n\t  if(FREEZE && meta.NEED && isExtensible(it) && !has(it, META))setMeta(it);\n\t  return it;\n\t};\n\tvar meta = module.exports = {\n\t  KEY:      META,\n\t  NEED:     false,\n\t  fastKey:  fastKey,\n\t  getWeak:  getWeak,\n\t  onFreeze: onFreeze\n\t};\n\n/***/ },\n/* 60 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar global         = __webpack_require__(15)\r\n\t  , core           = __webpack_require__(4)\r\n\t  , LIBRARY        = __webpack_require__(13)\r\n\t  , wksExt         = __webpack_require__(55)\r\n\t  , defineProperty = __webpack_require__(19).f;\r\n\tmodule.exports = function(name){\r\n\t  var $Symbol = core.Symbol || (core.Symbol = LIBRARY ? {} : global.Symbol || {});\r\n\t  if(name.charAt(0) != '_' && !(name in $Symbol))defineProperty($Symbol, name, {value: wksExt.f(name)});\r\n\t};\n\n/***/ },\n/* 61 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar getKeys   = __webpack_require__(34)\n\t  , toIObject = __webpack_require__(36);\n\tmodule.exports = function(object, el){\n\t  var O      = toIObject(object)\n\t    , keys   = getKeys(O)\n\t    , length = keys.length\n\t    , index  = 0\n\t    , key;\n\t  while(length > index)if(O[key = keys[index++]] === el)return key;\n\t};\n\n/***/ },\n/* 62 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// all enumerable object keys, includes symbols\n\tvar getKeys = __webpack_require__(34)\n\t  , gOPS    = __webpack_require__(63)\n\t  , pIE     = __webpack_require__(64);\n\tmodule.exports = function(it){\n\t  var result     = getKeys(it)\n\t    , getSymbols = gOPS.f;\n\t  if(getSymbols){\n\t    var symbols = getSymbols(it)\n\t      , isEnum  = pIE.f\n\t      , i       = 0\n\t      , key;\n\t    while(symbols.length > i)if(isEnum.call(it, key = symbols[i++]))result.push(key);\n\t  } return result;\n\t};\n\n/***/ },\n/* 63 */\n/***/ function(module, exports) {\n\n\texports.f = Object.getOwnPropertySymbols;\n\n/***/ },\n/* 64 */\n/***/ function(module, exports) {\n\n\texports.f = {}.propertyIsEnumerable;\n\n/***/ },\n/* 65 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// 7.2.2 IsArray(argument)\n\tvar cof = __webpack_require__(38);\n\tmodule.exports = Array.isArray || function isArray(arg){\n\t  return cof(arg) == 'Array';\n\t};\n\n/***/ },\n/* 66 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window\n\tvar toIObject = __webpack_require__(36)\n\t  , gOPN      = __webpack_require__(67).f\n\t  , toString  = {}.toString;\n\t\n\tvar windowNames = typeof window == 'object' && window && Object.getOwnPropertyNames\n\t  ? Object.getOwnPropertyNames(window) : [];\n\t\n\tvar getWindowNames = function(it){\n\t  try {\n\t    return gOPN(it);\n\t  } catch(e){\n\t    return windowNames.slice();\n\t  }\n\t};\n\t\n\tmodule.exports.f = function getOwnPropertyNames(it){\n\t  return windowNames && toString.call(it) == '[object Window]' ? getWindowNames(it) : gOPN(toIObject(it));\n\t};\n\n\n/***/ },\n/* 67 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// 19.1.2.7 / 15.2.3.4 Object.getOwnPropertyNames(O)\r\n\tvar $keys      = __webpack_require__(35)\r\n\t  , hiddenKeys = __webpack_require__(45).concat('length', 'prototype');\r\n\t\r\n\texports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O){\r\n\t  return $keys(O, hiddenKeys);\r\n\t};\n\n/***/ },\n/* 68 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar pIE            = __webpack_require__(64)\r\n\t  , createDesc     = __webpack_require__(27)\r\n\t  , toIObject      = __webpack_require__(36)\r\n\t  , toPrimitive    = __webpack_require__(26)\r\n\t  , has            = __webpack_require__(29)\r\n\t  , IE8_DOM_DEFINE = __webpack_require__(22)\r\n\t  , gOPD           = Object.getOwnPropertyDescriptor;\r\n\t\r\n\texports.f = __webpack_require__(23) ? gOPD : function getOwnPropertyDescriptor(O, P){\r\n\t  O = toIObject(O);\r\n\t  P = toPrimitive(P, true);\r\n\t  if(IE8_DOM_DEFINE)try {\r\n\t    return gOPD(O, P);\r\n\t  } catch(e){ /* empty */ }\r\n\t  if(has(O, P))return createDesc(!pIE.f.call(O, P), O[P]);\r\n\t};\n\n/***/ },\n/* 69 */\n/***/ function(module, exports) {\n\n\n\n/***/ },\n/* 70 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t__webpack_require__(60)('asyncIterator');\n\n/***/ },\n/* 71 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t__webpack_require__(60)('observable');\n\n/***/ }\n/******/ ]);\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAgOWU3ZDkxYjM3MDRjN2Y3MWMzYTIiLCJ3ZWJwYWNrOi8vLy4vc2NyaXB0cy9hcGktZXhwbG9yZXIvdjIvc3JjL3NlcnZpY2VzL2pzb24taGlnaGxpZ2h0L2hpZ2hsaWdodEpzb24ud29ya2VyLmpzIiwid2VicGFjazovLy8uL3NjcmlwdHMvYXBpLWV4cGxvcmVyL3YyL3NyYy9zZXJ2aWNlcy9qc29uLWhpZ2hsaWdodC9qc29uLXBhcnNlLmpzIiwid2VicGFjazovLy8uL34vYmFiZWwtcnVudGltZS9jb3JlLWpzL2pzb24vc3RyaW5naWZ5LmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L2ZuL2pzb24vc3RyaW5naWZ5LmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2NvcmUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9iYWJlbC1ydW50aW1lL2hlbHBlcnMvdHlwZW9mLmpzIiwid2VicGFjazovLy8uL34vYmFiZWwtcnVudGltZS9jb3JlLWpzL3N5bWJvbC9pdGVyYXRvci5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9mbi9zeW1ib2wvaXRlcmF0b3IuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczYuc3RyaW5nLml0ZXJhdG9yLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3N0cmluZy1hdC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL190by1pbnRlZ2VyLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2RlZmluZWQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faXRlci1kZWZpbmUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fbGlicmFyeS5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19leHBvcnQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZ2xvYmFsLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2N0eC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19hLWZ1bmN0aW9uLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2hpZGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LWRwLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2FuLW9iamVjdC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19pcy1vYmplY3QuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faWU4LWRvbS1kZWZpbmUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZGVzY3JpcHRvcnMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZmFpbHMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZG9tLWNyZWF0ZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL190by1wcmltaXRpdmUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fcHJvcGVydHktZGVzYy5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19yZWRlZmluZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19oYXMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faXRlcmF0b3JzLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2l0ZXItY3JlYXRlLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1jcmVhdGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LWRwcy5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3Qta2V5cy5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3Qta2V5cy1pbnRlcm5hbC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL190by1pb2JqZWN0LmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2lvYmplY3QuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fY29mLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2FycmF5LWluY2x1ZGVzLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3RvLWxlbmd0aC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL190by1pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19zaGFyZWQta2V5LmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3NoYXJlZC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL191aWQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZW51bS1idWcta2V5cy5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19odG1sLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3NldC10by1zdHJpbmctdGFnLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3drcy5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3QtZ3BvLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3RvLW9iamVjdC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL3dlYi5kb20uaXRlcmFibGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczYuYXJyYXkuaXRlcmF0b3IuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fYWRkLXRvLXVuc2NvcGFibGVzLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2l0ZXItc3RlcC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL193a3MtZXh0LmpzIiwid2VicGFjazovLy8uL34vYmFiZWwtcnVudGltZS9jb3JlLWpzL3N5bWJvbC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9mbi9zeW1ib2wvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczYuc3ltYm9sLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX21ldGEuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fd2tzLWRlZmluZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19rZXlvZi5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19lbnVtLWtleXMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LWdvcHMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LXBpZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19pcy1hcnJheS5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3QtZ29wbi1leHQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LWdvcG4uanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LWdvcGQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczcuc3ltYm9sLmFzeW5jLWl0ZXJhdG9yLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM3LnN5bWJvbC5vYnNlcnZhYmxlLmpzIl0sIm5hbWVzIjpbInByZWZpeCIsImdldEV4cGFuZGVyQ2xhc3NlcyIsImV4cGFuZGVkIiwiZW5jb2RlIiwidmFsdWUiLCJqb2luIiwiY3JlYXRlRWxlbWVudCIsImtleSIsInR5cGUiLCJleHBhbmRlckNsYXNzZXMiLCJrbGFzcyIsIm9wZW4iLCJjbG9zZSIsIkFycmF5IiwiaXNBcnJheSIsImpzb24yaHRtbCIsImpzb24iLCJodG1sIiwiaGFzT3duUHJvcGVydHkiLCJnZXRKc29uVmlld2VyIiwiZGF0YSIsIm9wdGlvbnMiLCJKU09OIiwicGFyc2UiLCJlIiwidG9TdHJpbmciLCJtb2R1bGUiLCJleHBvcnRzIiwib3B0Il0sIm1hcHBpbmdzIjoiO0FBQUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsdUJBQWU7QUFDZjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEc7Ozs7OztBQ3BEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMEQsc0JBQXNCO0FBQ2hGLGlGQUFnRixzQkFBc0I7QUFDdEcsRzs7Ozs7O0FDUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRzs7Ozs7O0FDVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0gsRzs7Ozs7O0FDZEEsMEM7Ozs7OztBQ0FBLGVBQWMsc0I7Ozs7OztBQ0FkO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRzs7Ozs7O0FDSkE7QUFDQTtBQUNBO0FBQ0EsbUJBQWtCOztBQUVsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7Ozs7O0FDbEJBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRzs7Ozs7O0FDTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUcsVUFBVTtBQUNiO0FBQ0EsRzs7Ozs7Ozs7Ozs7O0FDZkEsMEM7Ozs7OztBQ0FBLHVDIiwiZmlsZSI6ImhpZ2hsaWdodEpzb24ud29ya2VyLmpzIiwic291cmNlc0NvbnRlbnQiOlsiIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuIFx0dmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcblxuIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbiBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblxuIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbiBcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pXG4gXHRcdFx0cmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XG5cbiBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbiBcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xuIFx0XHRcdGV4cG9ydHM6IHt9LFxuIFx0XHRcdGlkOiBtb2R1bGVJZCxcbiBcdFx0XHRsb2FkZWQ6IGZhbHNlXG4gXHRcdH07XG5cbiBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4gXHRcdG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXG4gXHRcdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcbiBcdFx0bW9kdWxlLmxvYWRlZCA9IHRydWU7XG5cbiBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbiBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuIFx0fVxuXG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcblxuIFx0Ly8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cbiBcdF9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiXCI7XG5cbiBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuIFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oMCk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gd2VicGFjay9ib290c3RyYXAgOWU3ZDkxYjM3MDRjN2Y3MWMzYTIiLCIvKipcclxuICogQ29kZSBmb3JtYXQgd2ViLXdvcmtlclxyXG4gKiBAcGFyYW0gZXZlbnRcclxuICovXHJcbi8vIHZhciBoaWdobGlnaHRKc29uKClcclxudmFyIGhpZ2hsaWdodEpzb24gPSByZXF1aXJlKCcuL2pzb24tcGFyc2UnKTtcclxuXHJcbm9ubWVzc2FnZSA9IGZ1bmN0aW9uKGV2ZW50KSB7XHJcbiAgdmFyIGNvZGUgPSBldmVudC5kYXRhO1xyXG4gIC8vIGltcG9ydFNjcmlwdHMoJ2pzb24tcGFyc2UuanMnKTtcclxuICB2YXIgcmVzdWx0ID0gaGlnaGxpZ2h0SnNvbihjb2RlLCB7ZXhwYW5kZWQ6IHRydWV9KTtcclxuICAvLyB2YXIgcmVzdWx0ID1KU09OLnN0cmluZ2lmeShjb2RlKTtcclxuICBwb3N0TWVzc2FnZShyZXN1bHQpO1xyXG59O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NjcmlwdHMvYXBpLWV4cGxvcmVyL3YyL3NyYy9zZXJ2aWNlcy9qc29uLWhpZ2hsaWdodC9oaWdobGlnaHRKc29uLndvcmtlci5qc1xuLy8gbW9kdWxlIGlkID0gMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgcHJlZml4ID0gJ3RtLWNvZGUnO1xyXG5cclxudmFyIGdldEV4cGFuZGVyQ2xhc3NlcyA9IGZ1bmN0aW9uIChleHBhbmRlZCkge1xyXG5cdGlmICghZXhwYW5kZWQpIHtcclxuXHRcdHJldHVybiAnZXhwYW5kZWQgY29sbGFwc2VkIGhpZGRlbic7XHJcblx0fVxyXG5cdHJldHVybiAnZXhwYW5kZWQnO1xyXG59O1xyXG5cclxudmFyIGVuY29kZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xyXG5cdHJldHVybiBbJzxzcGFuPicsIHZhbHVlLCAnPC9zcGFuPiddLmpvaW4oJycpO1xyXG59O1xyXG5cclxudmFyIGNyZWF0ZUVsZW1lbnQgPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSwgdHlwZSwgZXhwYW5kZXJDbGFzc2VzKSB7XHJcblx0dmFyIGtsYXNzID0gJ29iamVjdCcsXHJcblx0XHRvcGVuID0gJ3snLFxyXG5cdFx0Y2xvc2UgPSAnfSc7XHJcblxyXG5cdGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xyXG5cdFx0a2xhc3MgPSAnYXJyYXknO1xyXG5cdFx0b3BlbiA9ICdbJztcclxuXHRcdGNsb3NlID0gJ10nO1xyXG5cdH1cclxuXHJcblx0aWYgKHZhbHVlID09PSBudWxsKSB7XHJcblx0XHRyZXR1cm4gW1xyXG5cdFx0XHQnPGxpPicsXHJcblx0XHRcdFx0JzxzcGFuIGNsYXNzPVwia2V5XCI+XCInLCBlbmNvZGUoa2V5KSwgJ1wiOiA8L3NwYW4+JyxcclxuXHRcdFx0XHQnPHNwYW4gY2xhc3M9XCJudWxsXCI+XCInLCBlbmNvZGUodmFsdWUpLCAnXCI8L3NwYW4+JyxcclxuXHRcdFx0JzwvbGk+J1xyXG5cdFx0XS5qb2luKCcnKTtcclxuXHR9XHJcblxyXG5cdGlmICh0eXBlID09ICdvYmplY3QnKSB7XHJcblx0XHRyZXR1cm4gW1xyXG5cdFx0XHQnPGxpPicsXHJcblx0XHRcdFx0JzxzcGFuIGNsYXNzPVwiJywgZXhwYW5kZXJDbGFzc2VzLCAnXCI+PC9zcGFuPicsXHJcblx0XHRcdFx0JzxzcGFuIGNsYXNzPVwia2V5XCI+XCInLCBlbmNvZGUoa2V5KSwgJ1wiOiA8L3NwYW4+ICcsXHJcblx0XHRcdFx0JzxzcGFuIGNsYXNzPVwib3BlblwiPicsIG9wZW4sICc8L3NwYW4+ICcsXHJcblx0XHRcdFx0Jzx1bCBjbGFzcz1cIicsIGtsYXNzLCAnXCI+JyxcclxuXHRcdFx0XHRcdGpzb24yaHRtbCh2YWx1ZSwgZXhwYW5kZXJDbGFzc2VzKSxcclxuXHRcdFx0XHQnPC91bD4nLFxyXG5cdFx0XHRcdCc8c3BhbiBjbGFzcz1cImNsb3NlXCI+JywgY2xvc2UsICc8L3NwYW4+JyxcclxuXHRcdFx0JzwvbGk+J1xyXG5cdFx0XS5qb2luKCcnKTtcclxuXHR9XHJcblxyXG5cdGlmICh0eXBlID09ICdudW1iZXInIHx8IHR5cGUgPT0gJ2Jvb2xlYW4nKSB7XHJcblx0XHRyZXR1cm4gW1xyXG5cdFx0XHQnPGxpPicsXHJcblx0XHRcdFx0JzxzcGFuIGNsYXNzPVwia2V5XCI+XCInLCBlbmNvZGUoa2V5KSwgJ1wiOiA8L3NwYW4+JyxcclxuXHRcdFx0XHQnPHNwYW4gY2xhc3M9XCInLCB0eXBlLCAnXCI+JywgZW5jb2RlKHZhbHVlKSwgJzwvc3Bhbj4nLFxyXG5cdFx0XHQnPC9saT4nXHJcblx0XHRdLmpvaW4oJycpO1xyXG5cdH1cclxuXHRyZXR1cm4gW1xyXG5cdFx0JzxsaT4nLFxyXG5cdFx0XHQnPHNwYW4gY2xhc3M9XCJrZXlcIj5cIicsIGVuY29kZShrZXkpLCAnXCI6IDwvc3Bhbj4nLFxyXG5cdFx0XHQnPHNwYW4gY2xhc3M9XCInLCB0eXBlLCAnXCI+XCInLCBlbmNvZGUodmFsdWUpLCAnXCI8L3NwYW4+JyxcclxuXHRcdCc8L2xpPidcclxuXHRdLmpvaW4oJycpO1xyXG59O1xyXG5cclxudmFyIGpzb24yaHRtbCA9IGZ1bmN0aW9uIChqc29uLCBleHBhbmRlckNsYXNzZXMpIHtcclxuXHR2YXIgaHRtbCA9ICcnO1xyXG5cdGZvciAodmFyIGtleSBpbiBqc29uKSB7XHJcblx0XHRpZiAoIWpzb24uaGFzT3duUHJvcGVydHkoa2V5KSkge1xyXG5cdFx0XHRjb250aW51ZTtcclxuXHRcdH1cclxuXHJcblx0XHRodG1sID0gW2h0bWwsIGNyZWF0ZUVsZW1lbnQoa2V5LCBqc29uW2tleV0sIHR5cGVvZiBqc29uW2tleV0sIGV4cGFuZGVyQ2xhc3NlcyldLmpvaW4oJycpO1xyXG5cdH1cclxuXHRyZXR1cm4gaHRtbDtcclxufTtcclxuXHJcbnZhciBnZXRKc29uVmlld2VyID0gZnVuY3Rpb24gKGRhdGEsIG9wdGlvbnMpIHtcclxuXHR0cnkge1xyXG5cdFx0cmV0dXJuIFtcclxuXHRcdFx0Jzx1bCBjbGFzcz1cIicsIHByZWZpeCwgJy1jb250YWluZXJcIj4nLFxyXG5cdFx0XHRcdGpzb24yaHRtbChbSlNPTi5wYXJzZShkYXRhKV0sIGdldEV4cGFuZGVyQ2xhc3NlcyhvcHRpb25zLmV4cGFuZGVkKSksXHJcblx0XHRcdCc8L3VsPidcclxuXHRcdF0uam9pbignJyk7XHJcblx0fSBjYXRjaCAoZSkge1xyXG5cdFx0cmV0dXJuIFtcclxuXHRcdFx0JzxkaXYgY2xhc3M9XCInLCBwcmVmaXgsICctZXJyb3JcIiA+JywgZS50b1N0cmluZygpLCAnIDwvZGl2PidcclxuXHRcdF0uam9pbignJyk7XHJcblx0fVxyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihkYXRhLCBvcHQpIHtcclxuXHR2YXIganNvbiA9ICcnO1xyXG5cdHZhciBvcHRpb25zID0gb3B0IHx8IHtleHBhbmRlZDogdHJ1ZX07XHJcblx0aWYgKHR5cGVvZiBkYXRhID09ICdzdHJpbmcnKSB7XHJcblx0XHRqc29uID0gZGF0YTtcclxuXHR9IGVsc2UgaWYgKHR5cGVvZiBkYXRhID09ICdvYmplY3QnKSB7XHJcblx0XHRqc29uID0gSlNPTi5zdHJpbmdpZnkoZGF0YSlcclxuXHR9XHJcblx0cmV0dXJuIGdldEpzb25WaWV3ZXIoanNvbiwgb3B0aW9ucyk7XHJcbn07XHJcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NjcmlwdHMvYXBpLWV4cGxvcmVyL3YyL3NyYy9zZXJ2aWNlcy9qc29uLWhpZ2hsaWdodC9qc29uLXBhcnNlLmpzIiwibW9kdWxlLmV4cG9ydHMgPSB7IFwiZGVmYXVsdFwiOiByZXF1aXJlKFwiY29yZS1qcy9saWJyYXJ5L2ZuL2pzb24vc3RyaW5naWZ5XCIpLCBfX2VzTW9kdWxlOiB0cnVlIH07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9qc29uL3N0cmluZ2lmeS5qc1xuLy8gbW9kdWxlIGlkID0gMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgY29yZSAgPSByZXF1aXJlKCcuLi8uLi9tb2R1bGVzL19jb3JlJylcbiAgLCAkSlNPTiA9IGNvcmUuSlNPTiB8fCAoY29yZS5KU09OID0ge3N0cmluZ2lmeTogSlNPTi5zdHJpbmdpZnl9KTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gc3RyaW5naWZ5KGl0KXsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuICByZXR1cm4gJEpTT04uc3RyaW5naWZ5LmFwcGx5KCRKU09OLCBhcmd1bWVudHMpO1xufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9saWJyYXJ5L2ZuL2pzb24vc3RyaW5naWZ5LmpzXG4vLyBtb2R1bGUgaWQgPSAzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBjb3JlID0gbW9kdWxlLmV4cG9ydHMgPSB7dmVyc2lvbjogJzIuNC4wJ307XG5pZih0eXBlb2YgX19lID09ICdudW1iZXInKV9fZSA9IGNvcmU7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWZcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2NvcmUuanNcbi8vIG1vZHVsZSBpZCA9IDRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfaXRlcmF0b3IgPSByZXF1aXJlKFwiLi4vY29yZS1qcy9zeW1ib2wvaXRlcmF0b3JcIik7XG5cbnZhciBfaXRlcmF0b3IyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaXRlcmF0b3IpO1xuXG52YXIgX3N5bWJvbCA9IHJlcXVpcmUoXCIuLi9jb3JlLWpzL3N5bWJvbFwiKTtcblxudmFyIF9zeW1ib2wyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfc3ltYm9sKTtcblxudmFyIF90eXBlb2YgPSB0eXBlb2YgX3N5bWJvbDIuZGVmYXVsdCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBfaXRlcmF0b3IyLmRlZmF1bHQgPT09IFwic3ltYm9sXCIgPyBmdW5jdGlvbiAob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9IDogZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBfc3ltYm9sMi5kZWZhdWx0ID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBfc3ltYm9sMi5kZWZhdWx0ICYmIG9iaiAhPT0gX3N5bWJvbDIuZGVmYXVsdC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZXhwb3J0cy5kZWZhdWx0ID0gdHlwZW9mIF9zeW1ib2wyLmRlZmF1bHQgPT09IFwiZnVuY3Rpb25cIiAmJiBfdHlwZW9mKF9pdGVyYXRvcjIuZGVmYXVsdCkgPT09IFwic3ltYm9sXCIgPyBmdW5jdGlvbiAob2JqKSB7XG4gIHJldHVybiB0eXBlb2Ygb2JqID09PSBcInVuZGVmaW5lZFwiID8gXCJ1bmRlZmluZWRcIiA6IF90eXBlb2Yob2JqKTtcbn0gOiBmdW5jdGlvbiAob2JqKSB7XG4gIHJldHVybiBvYmogJiYgdHlwZW9mIF9zeW1ib2wyLmRlZmF1bHQgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IF9zeW1ib2wyLmRlZmF1bHQgJiYgb2JqICE9PSBfc3ltYm9sMi5kZWZhdWx0LnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqID09PSBcInVuZGVmaW5lZFwiID8gXCJ1bmRlZmluZWRcIiA6IF90eXBlb2Yob2JqKTtcbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2JhYmVsLXJ1bnRpbWUvaGVscGVycy90eXBlb2YuanNcbi8vIG1vZHVsZSBpZCA9IDVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSB7IFwiZGVmYXVsdFwiOiByZXF1aXJlKFwiY29yZS1qcy9saWJyYXJ5L2ZuL3N5bWJvbC9pdGVyYXRvclwiKSwgX19lc01vZHVsZTogdHJ1ZSB9O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9iYWJlbC1ydW50aW1lL2NvcmUtanMvc3ltYm9sL2l0ZXJhdG9yLmpzXG4vLyBtb2R1bGUgaWQgPSA2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInJlcXVpcmUoJy4uLy4uL21vZHVsZXMvZXM2LnN0cmluZy5pdGVyYXRvcicpO1xucmVxdWlyZSgnLi4vLi4vbW9kdWxlcy93ZWIuZG9tLml0ZXJhYmxlJyk7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4uLy4uL21vZHVsZXMvX3drcy1leHQnKS5mKCdpdGVyYXRvcicpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL2xpYnJhcnkvZm4vc3ltYm9sL2l0ZXJhdG9yLmpzXG4vLyBtb2R1bGUgaWQgPSA3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcbnZhciAkYXQgID0gcmVxdWlyZSgnLi9fc3RyaW5nLWF0JykodHJ1ZSk7XG5cbi8vIDIxLjEuMy4yNyBTdHJpbmcucHJvdG90eXBlW0BAaXRlcmF0b3JdKClcbnJlcXVpcmUoJy4vX2l0ZXItZGVmaW5lJykoU3RyaW5nLCAnU3RyaW5nJywgZnVuY3Rpb24oaXRlcmF0ZWQpe1xuICB0aGlzLl90ID0gU3RyaW5nKGl0ZXJhdGVkKTsgLy8gdGFyZ2V0XG4gIHRoaXMuX2kgPSAwOyAgICAgICAgICAgICAgICAvLyBuZXh0IGluZGV4XG4vLyAyMS4xLjUuMi4xICVTdHJpbmdJdGVyYXRvclByb3RvdHlwZSUubmV4dCgpXG59LCBmdW5jdGlvbigpe1xuICB2YXIgTyAgICAgPSB0aGlzLl90XG4gICAgLCBpbmRleCA9IHRoaXMuX2lcbiAgICAsIHBvaW50O1xuICBpZihpbmRleCA+PSBPLmxlbmd0aClyZXR1cm4ge3ZhbHVlOiB1bmRlZmluZWQsIGRvbmU6IHRydWV9O1xuICBwb2ludCA9ICRhdChPLCBpbmRleCk7XG4gIHRoaXMuX2kgKz0gcG9pbnQubGVuZ3RoO1xuICByZXR1cm4ge3ZhbHVlOiBwb2ludCwgZG9uZTogZmFsc2V9O1xufSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNi5zdHJpbmcuaXRlcmF0b3IuanNcbi8vIG1vZHVsZSBpZCA9IDhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIHRvSW50ZWdlciA9IHJlcXVpcmUoJy4vX3RvLWludGVnZXInKVxuICAsIGRlZmluZWQgICA9IHJlcXVpcmUoJy4vX2RlZmluZWQnKTtcbi8vIHRydWUgIC0+IFN0cmluZyNhdFxuLy8gZmFsc2UgLT4gU3RyaW5nI2NvZGVQb2ludEF0XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKFRPX1NUUklORyl7XG4gIHJldHVybiBmdW5jdGlvbih0aGF0LCBwb3Mpe1xuICAgIHZhciBzID0gU3RyaW5nKGRlZmluZWQodGhhdCkpXG4gICAgICAsIGkgPSB0b0ludGVnZXIocG9zKVxuICAgICAgLCBsID0gcy5sZW5ndGhcbiAgICAgICwgYSwgYjtcbiAgICBpZihpIDwgMCB8fCBpID49IGwpcmV0dXJuIFRPX1NUUklORyA/ICcnIDogdW5kZWZpbmVkO1xuICAgIGEgPSBzLmNoYXJDb2RlQXQoaSk7XG4gICAgcmV0dXJuIGEgPCAweGQ4MDAgfHwgYSA+IDB4ZGJmZiB8fCBpICsgMSA9PT0gbCB8fCAoYiA9IHMuY2hhckNvZGVBdChpICsgMSkpIDwgMHhkYzAwIHx8IGIgPiAweGRmZmZcbiAgICAgID8gVE9fU1RSSU5HID8gcy5jaGFyQXQoaSkgOiBhXG4gICAgICA6IFRPX1NUUklORyA/IHMuc2xpY2UoaSwgaSArIDIpIDogKGEgLSAweGQ4MDAgPDwgMTApICsgKGIgLSAweGRjMDApICsgMHgxMDAwMDtcbiAgfTtcbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19zdHJpbmctYXQuanNcbi8vIG1vZHVsZSBpZCA9IDlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gNy4xLjQgVG9JbnRlZ2VyXG52YXIgY2VpbCAgPSBNYXRoLmNlaWxcbiAgLCBmbG9vciA9IE1hdGguZmxvb3I7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KXtcbiAgcmV0dXJuIGlzTmFOKGl0ID0gK2l0KSA/IDAgOiAoaXQgPiAwID8gZmxvb3IgOiBjZWlsKShpdCk7XG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fdG8taW50ZWdlci5qc1xuLy8gbW9kdWxlIGlkID0gMTBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gNy4yLjEgUmVxdWlyZU9iamVjdENvZXJjaWJsZShhcmd1bWVudClcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQpe1xuICBpZihpdCA9PSB1bmRlZmluZWQpdGhyb3cgVHlwZUVycm9yKFwiQ2FuJ3QgY2FsbCBtZXRob2Qgb24gIFwiICsgaXQpO1xuICByZXR1cm4gaXQ7XG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZGVmaW5lZC5qc1xuLy8gbW9kdWxlIGlkID0gMTFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xudmFyIExJQlJBUlkgICAgICAgID0gcmVxdWlyZSgnLi9fbGlicmFyeScpXG4gICwgJGV4cG9ydCAgICAgICAgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsIHJlZGVmaW5lICAgICAgID0gcmVxdWlyZSgnLi9fcmVkZWZpbmUnKVxuICAsIGhpZGUgICAgICAgICAgID0gcmVxdWlyZSgnLi9faGlkZScpXG4gICwgaGFzICAgICAgICAgICAgPSByZXF1aXJlKCcuL19oYXMnKVxuICAsIEl0ZXJhdG9ycyAgICAgID0gcmVxdWlyZSgnLi9faXRlcmF0b3JzJylcbiAgLCAkaXRlckNyZWF0ZSAgICA9IHJlcXVpcmUoJy4vX2l0ZXItY3JlYXRlJylcbiAgLCBzZXRUb1N0cmluZ1RhZyA9IHJlcXVpcmUoJy4vX3NldC10by1zdHJpbmctdGFnJylcbiAgLCBnZXRQcm90b3R5cGVPZiA9IHJlcXVpcmUoJy4vX29iamVjdC1ncG8nKVxuICAsIElURVJBVE9SICAgICAgID0gcmVxdWlyZSgnLi9fd2tzJykoJ2l0ZXJhdG9yJylcbiAgLCBCVUdHWSAgICAgICAgICA9ICEoW10ua2V5cyAmJiAnbmV4dCcgaW4gW10ua2V5cygpKSAvLyBTYWZhcmkgaGFzIGJ1Z2d5IGl0ZXJhdG9ycyB3L28gYG5leHRgXG4gICwgRkZfSVRFUkFUT1IgICAgPSAnQEBpdGVyYXRvcidcbiAgLCBLRVlTICAgICAgICAgICA9ICdrZXlzJ1xuICAsIFZBTFVFUyAgICAgICAgID0gJ3ZhbHVlcyc7XG5cbnZhciByZXR1cm5UaGlzID0gZnVuY3Rpb24oKXsgcmV0dXJuIHRoaXM7IH07XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oQmFzZSwgTkFNRSwgQ29uc3RydWN0b3IsIG5leHQsIERFRkFVTFQsIElTX1NFVCwgRk9SQ0VEKXtcbiAgJGl0ZXJDcmVhdGUoQ29uc3RydWN0b3IsIE5BTUUsIG5leHQpO1xuICB2YXIgZ2V0TWV0aG9kID0gZnVuY3Rpb24oa2luZCl7XG4gICAgaWYoIUJVR0dZICYmIGtpbmQgaW4gcHJvdG8pcmV0dXJuIHByb3RvW2tpbmRdO1xuICAgIHN3aXRjaChraW5kKXtcbiAgICAgIGNhc2UgS0VZUzogcmV0dXJuIGZ1bmN0aW9uIGtleXMoKXsgcmV0dXJuIG5ldyBDb25zdHJ1Y3Rvcih0aGlzLCBraW5kKTsgfTtcbiAgICAgIGNhc2UgVkFMVUVTOiByZXR1cm4gZnVuY3Rpb24gdmFsdWVzKCl7IHJldHVybiBuZXcgQ29uc3RydWN0b3IodGhpcywga2luZCk7IH07XG4gICAgfSByZXR1cm4gZnVuY3Rpb24gZW50cmllcygpeyByZXR1cm4gbmV3IENvbnN0cnVjdG9yKHRoaXMsIGtpbmQpOyB9O1xuICB9O1xuICB2YXIgVEFHICAgICAgICA9IE5BTUUgKyAnIEl0ZXJhdG9yJ1xuICAgICwgREVGX1ZBTFVFUyA9IERFRkFVTFQgPT0gVkFMVUVTXG4gICAgLCBWQUxVRVNfQlVHID0gZmFsc2VcbiAgICAsIHByb3RvICAgICAgPSBCYXNlLnByb3RvdHlwZVxuICAgICwgJG5hdGl2ZSAgICA9IHByb3RvW0lURVJBVE9SXSB8fCBwcm90b1tGRl9JVEVSQVRPUl0gfHwgREVGQVVMVCAmJiBwcm90b1tERUZBVUxUXVxuICAgICwgJGRlZmF1bHQgICA9ICRuYXRpdmUgfHwgZ2V0TWV0aG9kKERFRkFVTFQpXG4gICAgLCAkZW50cmllcyAgID0gREVGQVVMVCA/ICFERUZfVkFMVUVTID8gJGRlZmF1bHQgOiBnZXRNZXRob2QoJ2VudHJpZXMnKSA6IHVuZGVmaW5lZFxuICAgICwgJGFueU5hdGl2ZSA9IE5BTUUgPT0gJ0FycmF5JyA/IHByb3RvLmVudHJpZXMgfHwgJG5hdGl2ZSA6ICRuYXRpdmVcbiAgICAsIG1ldGhvZHMsIGtleSwgSXRlcmF0b3JQcm90b3R5cGU7XG4gIC8vIEZpeCBuYXRpdmVcbiAgaWYoJGFueU5hdGl2ZSl7XG4gICAgSXRlcmF0b3JQcm90b3R5cGUgPSBnZXRQcm90b3R5cGVPZigkYW55TmF0aXZlLmNhbGwobmV3IEJhc2UpKTtcbiAgICBpZihJdGVyYXRvclByb3RvdHlwZSAhPT0gT2JqZWN0LnByb3RvdHlwZSl7XG4gICAgICAvLyBTZXQgQEB0b1N0cmluZ1RhZyB0byBuYXRpdmUgaXRlcmF0b3JzXG4gICAgICBzZXRUb1N0cmluZ1RhZyhJdGVyYXRvclByb3RvdHlwZSwgVEFHLCB0cnVlKTtcbiAgICAgIC8vIGZpeCBmb3Igc29tZSBvbGQgZW5naW5lc1xuICAgICAgaWYoIUxJQlJBUlkgJiYgIWhhcyhJdGVyYXRvclByb3RvdHlwZSwgSVRFUkFUT1IpKWhpZGUoSXRlcmF0b3JQcm90b3R5cGUsIElURVJBVE9SLCByZXR1cm5UaGlzKTtcbiAgICB9XG4gIH1cbiAgLy8gZml4IEFycmF5I3t2YWx1ZXMsIEBAaXRlcmF0b3J9Lm5hbWUgaW4gVjggLyBGRlxuICBpZihERUZfVkFMVUVTICYmICRuYXRpdmUgJiYgJG5hdGl2ZS5uYW1lICE9PSBWQUxVRVMpe1xuICAgIFZBTFVFU19CVUcgPSB0cnVlO1xuICAgICRkZWZhdWx0ID0gZnVuY3Rpb24gdmFsdWVzKCl7IHJldHVybiAkbmF0aXZlLmNhbGwodGhpcyk7IH07XG4gIH1cbiAgLy8gRGVmaW5lIGl0ZXJhdG9yXG4gIGlmKCghTElCUkFSWSB8fCBGT1JDRUQpICYmIChCVUdHWSB8fCBWQUxVRVNfQlVHIHx8ICFwcm90b1tJVEVSQVRPUl0pKXtcbiAgICBoaWRlKHByb3RvLCBJVEVSQVRPUiwgJGRlZmF1bHQpO1xuICB9XG4gIC8vIFBsdWcgZm9yIGxpYnJhcnlcbiAgSXRlcmF0b3JzW05BTUVdID0gJGRlZmF1bHQ7XG4gIEl0ZXJhdG9yc1tUQUddICA9IHJldHVyblRoaXM7XG4gIGlmKERFRkFVTFQpe1xuICAgIG1ldGhvZHMgPSB7XG4gICAgICB2YWx1ZXM6ICBERUZfVkFMVUVTID8gJGRlZmF1bHQgOiBnZXRNZXRob2QoVkFMVUVTKSxcbiAgICAgIGtleXM6ICAgIElTX1NFVCAgICAgPyAkZGVmYXVsdCA6IGdldE1ldGhvZChLRVlTKSxcbiAgICAgIGVudHJpZXM6ICRlbnRyaWVzXG4gICAgfTtcbiAgICBpZihGT1JDRUQpZm9yKGtleSBpbiBtZXRob2RzKXtcbiAgICAgIGlmKCEoa2V5IGluIHByb3RvKSlyZWRlZmluZShwcm90bywga2V5LCBtZXRob2RzW2tleV0pO1xuICAgIH0gZWxzZSAkZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqIChCVUdHWSB8fCBWQUxVRVNfQlVHKSwgTkFNRSwgbWV0aG9kcyk7XG4gIH1cbiAgcmV0dXJuIG1ldGhvZHM7XG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faXRlci1kZWZpbmUuanNcbi8vIG1vZHVsZSBpZCA9IDEyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gdHJ1ZTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2xpYnJhcnkuanNcbi8vIG1vZHVsZSBpZCA9IDEzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBnbG9iYWwgICAgPSByZXF1aXJlKCcuL19nbG9iYWwnKVxuICAsIGNvcmUgICAgICA9IHJlcXVpcmUoJy4vX2NvcmUnKVxuICAsIGN0eCAgICAgICA9IHJlcXVpcmUoJy4vX2N0eCcpXG4gICwgaGlkZSAgICAgID0gcmVxdWlyZSgnLi9faGlkZScpXG4gICwgUFJPVE9UWVBFID0gJ3Byb3RvdHlwZSc7XG5cbnZhciAkZXhwb3J0ID0gZnVuY3Rpb24odHlwZSwgbmFtZSwgc291cmNlKXtcbiAgdmFyIElTX0ZPUkNFRCA9IHR5cGUgJiAkZXhwb3J0LkZcbiAgICAsIElTX0dMT0JBTCA9IHR5cGUgJiAkZXhwb3J0LkdcbiAgICAsIElTX1NUQVRJQyA9IHR5cGUgJiAkZXhwb3J0LlNcbiAgICAsIElTX1BST1RPICA9IHR5cGUgJiAkZXhwb3J0LlBcbiAgICAsIElTX0JJTkQgICA9IHR5cGUgJiAkZXhwb3J0LkJcbiAgICAsIElTX1dSQVAgICA9IHR5cGUgJiAkZXhwb3J0LldcbiAgICAsIGV4cG9ydHMgICA9IElTX0dMT0JBTCA/IGNvcmUgOiBjb3JlW25hbWVdIHx8IChjb3JlW25hbWVdID0ge30pXG4gICAgLCBleHBQcm90byAgPSBleHBvcnRzW1BST1RPVFlQRV1cbiAgICAsIHRhcmdldCAgICA9IElTX0dMT0JBTCA/IGdsb2JhbCA6IElTX1NUQVRJQyA/IGdsb2JhbFtuYW1lXSA6IChnbG9iYWxbbmFtZV0gfHwge30pW1BST1RPVFlQRV1cbiAgICAsIGtleSwgb3duLCBvdXQ7XG4gIGlmKElTX0dMT0JBTClzb3VyY2UgPSBuYW1lO1xuICBmb3Ioa2V5IGluIHNvdXJjZSl7XG4gICAgLy8gY29udGFpbnMgaW4gbmF0aXZlXG4gICAgb3duID0gIUlTX0ZPUkNFRCAmJiB0YXJnZXQgJiYgdGFyZ2V0W2tleV0gIT09IHVuZGVmaW5lZDtcbiAgICBpZihvd24gJiYga2V5IGluIGV4cG9ydHMpY29udGludWU7XG4gICAgLy8gZXhwb3J0IG5hdGl2ZSBvciBwYXNzZWRcbiAgICBvdXQgPSBvd24gPyB0YXJnZXRba2V5XSA6IHNvdXJjZVtrZXldO1xuICAgIC8vIHByZXZlbnQgZ2xvYmFsIHBvbGx1dGlvbiBmb3IgbmFtZXNwYWNlc1xuICAgIGV4cG9ydHNba2V5XSA9IElTX0dMT0JBTCAmJiB0eXBlb2YgdGFyZ2V0W2tleV0gIT0gJ2Z1bmN0aW9uJyA/IHNvdXJjZVtrZXldXG4gICAgLy8gYmluZCB0aW1lcnMgdG8gZ2xvYmFsIGZvciBjYWxsIGZyb20gZXhwb3J0IGNvbnRleHRcbiAgICA6IElTX0JJTkQgJiYgb3duID8gY3R4KG91dCwgZ2xvYmFsKVxuICAgIC8vIHdyYXAgZ2xvYmFsIGNvbnN0cnVjdG9ycyBmb3IgcHJldmVudCBjaGFuZ2UgdGhlbSBpbiBsaWJyYXJ5XG4gICAgOiBJU19XUkFQICYmIHRhcmdldFtrZXldID09IG91dCA/IChmdW5jdGlvbihDKXtcbiAgICAgIHZhciBGID0gZnVuY3Rpb24oYSwgYiwgYyl7XG4gICAgICAgIGlmKHRoaXMgaW5zdGFuY2VvZiBDKXtcbiAgICAgICAgICBzd2l0Y2goYXJndW1lbnRzLmxlbmd0aCl7XG4gICAgICAgICAgICBjYXNlIDA6IHJldHVybiBuZXcgQztcbiAgICAgICAgICAgIGNhc2UgMTogcmV0dXJuIG5ldyBDKGEpO1xuICAgICAgICAgICAgY2FzZSAyOiByZXR1cm4gbmV3IEMoYSwgYik7XG4gICAgICAgICAgfSByZXR1cm4gbmV3IEMoYSwgYiwgYyk7XG4gICAgICAgIH0gcmV0dXJuIEMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH07XG4gICAgICBGW1BST1RPVFlQRV0gPSBDW1BST1RPVFlQRV07XG4gICAgICByZXR1cm4gRjtcbiAgICAvLyBtYWtlIHN0YXRpYyB2ZXJzaW9ucyBmb3IgcHJvdG90eXBlIG1ldGhvZHNcbiAgICB9KShvdXQpIDogSVNfUFJPVE8gJiYgdHlwZW9mIG91dCA9PSAnZnVuY3Rpb24nID8gY3R4KEZ1bmN0aW9uLmNhbGwsIG91dCkgOiBvdXQ7XG4gICAgLy8gZXhwb3J0IHByb3RvIG1ldGhvZHMgdG8gY29yZS4lQ09OU1RSVUNUT1IlLm1ldGhvZHMuJU5BTUUlXG4gICAgaWYoSVNfUFJPVE8pe1xuICAgICAgKGV4cG9ydHMudmlydHVhbCB8fCAoZXhwb3J0cy52aXJ0dWFsID0ge30pKVtrZXldID0gb3V0O1xuICAgICAgLy8gZXhwb3J0IHByb3RvIG1ldGhvZHMgdG8gY29yZS4lQ09OU1RSVUNUT1IlLnByb3RvdHlwZS4lTkFNRSVcbiAgICAgIGlmKHR5cGUgJiAkZXhwb3J0LlIgJiYgZXhwUHJvdG8gJiYgIWV4cFByb3RvW2tleV0paGlkZShleHBQcm90bywga2V5LCBvdXQpO1xuICAgIH1cbiAgfVxufTtcbi8vIHR5cGUgYml0bWFwXG4kZXhwb3J0LkYgPSAxOyAgIC8vIGZvcmNlZFxuJGV4cG9ydC5HID0gMjsgICAvLyBnbG9iYWxcbiRleHBvcnQuUyA9IDQ7ICAgLy8gc3RhdGljXG4kZXhwb3J0LlAgPSA4OyAgIC8vIHByb3RvXG4kZXhwb3J0LkIgPSAxNjsgIC8vIGJpbmRcbiRleHBvcnQuVyA9IDMyOyAgLy8gd3JhcFxuJGV4cG9ydC5VID0gNjQ7ICAvLyBzYWZlXG4kZXhwb3J0LlIgPSAxMjg7IC8vIHJlYWwgcHJvdG8gbWV0aG9kIGZvciBgbGlicmFyeWAgXG5tb2R1bGUuZXhwb3J0cyA9ICRleHBvcnQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19leHBvcnQuanNcbi8vIG1vZHVsZSBpZCA9IDE0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIGh0dHBzOi8vZ2l0aHViLmNvbS96bG9pcm9jay9jb3JlLWpzL2lzc3Vlcy84NiNpc3N1ZWNvbW1lbnQtMTE1NzU5MDI4XG52YXIgZ2xvYmFsID0gbW9kdWxlLmV4cG9ydHMgPSB0eXBlb2Ygd2luZG93ICE9ICd1bmRlZmluZWQnICYmIHdpbmRvdy5NYXRoID09IE1hdGhcbiAgPyB3aW5kb3cgOiB0eXBlb2Ygc2VsZiAhPSAndW5kZWZpbmVkJyAmJiBzZWxmLk1hdGggPT0gTWF0aCA/IHNlbGYgOiBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpO1xuaWYodHlwZW9mIF9fZyA9PSAnbnVtYmVyJylfX2cgPSBnbG9iYWw7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWZcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2dsb2JhbC5qc1xuLy8gbW9kdWxlIGlkID0gMTVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gb3B0aW9uYWwgLyBzaW1wbGUgY29udGV4dCBiaW5kaW5nXG52YXIgYUZ1bmN0aW9uID0gcmVxdWlyZSgnLi9fYS1mdW5jdGlvbicpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihmbiwgdGhhdCwgbGVuZ3RoKXtcbiAgYUZ1bmN0aW9uKGZuKTtcbiAgaWYodGhhdCA9PT0gdW5kZWZpbmVkKXJldHVybiBmbjtcbiAgc3dpdGNoKGxlbmd0aCl7XG4gICAgY2FzZSAxOiByZXR1cm4gZnVuY3Rpb24oYSl7XG4gICAgICByZXR1cm4gZm4uY2FsbCh0aGF0LCBhKTtcbiAgICB9O1xuICAgIGNhc2UgMjogcmV0dXJuIGZ1bmN0aW9uKGEsIGIpe1xuICAgICAgcmV0dXJuIGZuLmNhbGwodGhhdCwgYSwgYik7XG4gICAgfTtcbiAgICBjYXNlIDM6IHJldHVybiBmdW5jdGlvbihhLCBiLCBjKXtcbiAgICAgIHJldHVybiBmbi5jYWxsKHRoYXQsIGEsIGIsIGMpO1xuICAgIH07XG4gIH1cbiAgcmV0dXJuIGZ1bmN0aW9uKC8qIC4uLmFyZ3MgKi8pe1xuICAgIHJldHVybiBmbi5hcHBseSh0aGF0LCBhcmd1bWVudHMpO1xuICB9O1xufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2N0eC5qc1xuLy8gbW9kdWxlIGlkID0gMTZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCl7XG4gIGlmKHR5cGVvZiBpdCAhPSAnZnVuY3Rpb24nKXRocm93IFR5cGVFcnJvcihpdCArICcgaXMgbm90IGEgZnVuY3Rpb24hJyk7XG4gIHJldHVybiBpdDtcbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19hLWZ1bmN0aW9uLmpzXG4vLyBtb2R1bGUgaWQgPSAxN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgZFAgICAgICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpXG4gICwgY3JlYXRlRGVzYyA9IHJlcXVpcmUoJy4vX3Byb3BlcnR5LWRlc2MnKTtcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSA/IGZ1bmN0aW9uKG9iamVjdCwga2V5LCB2YWx1ZSl7XG4gIHJldHVybiBkUC5mKG9iamVjdCwga2V5LCBjcmVhdGVEZXNjKDEsIHZhbHVlKSk7XG59IDogZnVuY3Rpb24ob2JqZWN0LCBrZXksIHZhbHVlKXtcbiAgb2JqZWN0W2tleV0gPSB2YWx1ZTtcbiAgcmV0dXJuIG9iamVjdDtcbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19oaWRlLmpzXG4vLyBtb2R1bGUgaWQgPSAxOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgYW5PYmplY3QgICAgICAgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKVxuICAsIElFOF9ET01fREVGSU5FID0gcmVxdWlyZSgnLi9faWU4LWRvbS1kZWZpbmUnKVxuICAsIHRvUHJpbWl0aXZlICAgID0gcmVxdWlyZSgnLi9fdG8tcHJpbWl0aXZlJylcbiAgLCBkUCAgICAgICAgICAgICA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcblxuZXhwb3J0cy5mID0gcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSA6IGZ1bmN0aW9uIGRlZmluZVByb3BlcnR5KE8sIFAsIEF0dHJpYnV0ZXMpe1xuICBhbk9iamVjdChPKTtcbiAgUCA9IHRvUHJpbWl0aXZlKFAsIHRydWUpO1xuICBhbk9iamVjdChBdHRyaWJ1dGVzKTtcbiAgaWYoSUU4X0RPTV9ERUZJTkUpdHJ5IHtcbiAgICByZXR1cm4gZFAoTywgUCwgQXR0cmlidXRlcyk7XG4gIH0gY2F0Y2goZSl7IC8qIGVtcHR5ICovIH1cbiAgaWYoJ2dldCcgaW4gQXR0cmlidXRlcyB8fCAnc2V0JyBpbiBBdHRyaWJ1dGVzKXRocm93IFR5cGVFcnJvcignQWNjZXNzb3JzIG5vdCBzdXBwb3J0ZWQhJyk7XG4gIGlmKCd2YWx1ZScgaW4gQXR0cmlidXRlcylPW1BdID0gQXR0cmlidXRlcy52YWx1ZTtcbiAgcmV0dXJuIE87XG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LWRwLmpzXG4vLyBtb2R1bGUgaWQgPSAxOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQpe1xuICBpZighaXNPYmplY3QoaXQpKXRocm93IFR5cGVFcnJvcihpdCArICcgaXMgbm90IGFuIG9iamVjdCEnKTtcbiAgcmV0dXJuIGl0O1xufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2FuLW9iamVjdC5qc1xuLy8gbW9kdWxlIGlkID0gMjBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCl7XG4gIHJldHVybiB0eXBlb2YgaXQgPT09ICdvYmplY3QnID8gaXQgIT09IG51bGwgOiB0eXBlb2YgaXQgPT09ICdmdW5jdGlvbic7XG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faXMtb2JqZWN0LmpzXG4vLyBtb2R1bGUgaWQgPSAyMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9ICFyZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpICYmICFyZXF1aXJlKCcuL19mYWlscycpKGZ1bmN0aW9uKCl7XHJcbiAgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShyZXF1aXJlKCcuL19kb20tY3JlYXRlJykoJ2RpdicpLCAnYScsIHtnZXQ6IGZ1bmN0aW9uKCl7IHJldHVybiA3OyB9fSkuYSAhPSA3O1xyXG59KTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2llOC1kb20tZGVmaW5lLmpzXG4vLyBtb2R1bGUgaWQgPSAyMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyBUaGFuaydzIElFOCBmb3IgaGlzIGZ1bm55IGRlZmluZVByb3BlcnR5XG5tb2R1bGUuZXhwb3J0cyA9ICFyZXF1aXJlKCcuL19mYWlscycpKGZ1bmN0aW9uKCl7XG4gIHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkoe30sICdhJywge2dldDogZnVuY3Rpb24oKXsgcmV0dXJuIDc7IH19KS5hICE9IDc7XG59KTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2Rlc2NyaXB0b3JzLmpzXG4vLyBtb2R1bGUgaWQgPSAyM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGV4ZWMpe1xuICB0cnkge1xuICAgIHJldHVybiAhIWV4ZWMoKTtcbiAgfSBjYXRjaChlKXtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2ZhaWxzLmpzXG4vLyBtb2R1bGUgaWQgPSAyNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKVxuICAsIGRvY3VtZW50ID0gcmVxdWlyZSgnLi9fZ2xvYmFsJykuZG9jdW1lbnRcbiAgLy8gaW4gb2xkIElFIHR5cGVvZiBkb2N1bWVudC5jcmVhdGVFbGVtZW50IGlzICdvYmplY3QnXG4gICwgaXMgPSBpc09iamVjdChkb2N1bWVudCkgJiYgaXNPYmplY3QoZG9jdW1lbnQuY3JlYXRlRWxlbWVudCk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KXtcbiAgcmV0dXJuIGlzID8gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChpdCkgOiB7fTtcbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19kb20tY3JlYXRlLmpzXG4vLyBtb2R1bGUgaWQgPSAyNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyA3LjEuMSBUb1ByaW1pdGl2ZShpbnB1dCBbLCBQcmVmZXJyZWRUeXBlXSlcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xuLy8gaW5zdGVhZCBvZiB0aGUgRVM2IHNwZWMgdmVyc2lvbiwgd2UgZGlkbid0IGltcGxlbWVudCBAQHRvUHJpbWl0aXZlIGNhc2Vcbi8vIGFuZCB0aGUgc2Vjb25kIGFyZ3VtZW50IC0gZmxhZyAtIHByZWZlcnJlZCB0eXBlIGlzIGEgc3RyaW5nXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0LCBTKXtcbiAgaWYoIWlzT2JqZWN0KGl0KSlyZXR1cm4gaXQ7XG4gIHZhciBmbiwgdmFsO1xuICBpZihTICYmIHR5cGVvZiAoZm4gPSBpdC50b1N0cmluZykgPT0gJ2Z1bmN0aW9uJyAmJiAhaXNPYmplY3QodmFsID0gZm4uY2FsbChpdCkpKXJldHVybiB2YWw7XG4gIGlmKHR5cGVvZiAoZm4gPSBpdC52YWx1ZU9mKSA9PSAnZnVuY3Rpb24nICYmICFpc09iamVjdCh2YWwgPSBmbi5jYWxsKGl0KSkpcmV0dXJuIHZhbDtcbiAgaWYoIVMgJiYgdHlwZW9mIChmbiA9IGl0LnRvU3RyaW5nKSA9PSAnZnVuY3Rpb24nICYmICFpc09iamVjdCh2YWwgPSBmbi5jYWxsKGl0KSkpcmV0dXJuIHZhbDtcbiAgdGhyb3cgVHlwZUVycm9yKFwiQ2FuJ3QgY29udmVydCBvYmplY3QgdG8gcHJpbWl0aXZlIHZhbHVlXCIpO1xufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3RvLXByaW1pdGl2ZS5qc1xuLy8gbW9kdWxlIGlkID0gMjZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihiaXRtYXAsIHZhbHVlKXtcbiAgcmV0dXJuIHtcbiAgICBlbnVtZXJhYmxlICA6ICEoYml0bWFwICYgMSksXG4gICAgY29uZmlndXJhYmxlOiAhKGJpdG1hcCAmIDIpLFxuICAgIHdyaXRhYmxlICAgIDogIShiaXRtYXAgJiA0KSxcbiAgICB2YWx1ZSAgICAgICA6IHZhbHVlXG4gIH07XG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fcHJvcGVydHktZGVzYy5qc1xuLy8gbW9kdWxlIGlkID0gMjdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL19oaWRlJyk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19yZWRlZmluZS5qc1xuLy8gbW9kdWxlIGlkID0gMjhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGhhc093blByb3BlcnR5ID0ge30uaGFzT3duUHJvcGVydHk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0LCBrZXkpe1xuICByZXR1cm4gaGFzT3duUHJvcGVydHkuY2FsbChpdCwga2V5KTtcbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19oYXMuanNcbi8vIG1vZHVsZSBpZCA9IDI5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0ge307XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19pdGVyYXRvcnMuanNcbi8vIG1vZHVsZSBpZCA9IDMwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcbnZhciBjcmVhdGUgICAgICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1jcmVhdGUnKVxuICAsIGRlc2NyaXB0b3IgICAgID0gcmVxdWlyZSgnLi9fcHJvcGVydHktZGVzYycpXG4gICwgc2V0VG9TdHJpbmdUYWcgPSByZXF1aXJlKCcuL19zZXQtdG8tc3RyaW5nLXRhZycpXG4gICwgSXRlcmF0b3JQcm90b3R5cGUgPSB7fTtcblxuLy8gMjUuMS4yLjEuMSAlSXRlcmF0b3JQcm90b3R5cGUlW0BAaXRlcmF0b3JdKClcbnJlcXVpcmUoJy4vX2hpZGUnKShJdGVyYXRvclByb3RvdHlwZSwgcmVxdWlyZSgnLi9fd2tzJykoJ2l0ZXJhdG9yJyksIGZ1bmN0aW9uKCl7IHJldHVybiB0aGlzOyB9KTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihDb25zdHJ1Y3RvciwgTkFNRSwgbmV4dCl7XG4gIENvbnN0cnVjdG9yLnByb3RvdHlwZSA9IGNyZWF0ZShJdGVyYXRvclByb3RvdHlwZSwge25leHQ6IGRlc2NyaXB0b3IoMSwgbmV4dCl9KTtcbiAgc2V0VG9TdHJpbmdUYWcoQ29uc3RydWN0b3IsIE5BTUUgKyAnIEl0ZXJhdG9yJyk7XG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faXRlci1jcmVhdGUuanNcbi8vIG1vZHVsZSBpZCA9IDMxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIDE5LjEuMi4yIC8gMTUuMi4zLjUgT2JqZWN0LmNyZWF0ZShPIFssIFByb3BlcnRpZXNdKVxyXG52YXIgYW5PYmplY3QgICAgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKVxyXG4gICwgZFBzICAgICAgICAgPSByZXF1aXJlKCcuL19vYmplY3QtZHBzJylcclxuICAsIGVudW1CdWdLZXlzID0gcmVxdWlyZSgnLi9fZW51bS1idWcta2V5cycpXHJcbiAgLCBJRV9QUk9UTyAgICA9IHJlcXVpcmUoJy4vX3NoYXJlZC1rZXknKSgnSUVfUFJPVE8nKVxyXG4gICwgRW1wdHkgICAgICAgPSBmdW5jdGlvbigpeyAvKiBlbXB0eSAqLyB9XHJcbiAgLCBQUk9UT1RZUEUgICA9ICdwcm90b3R5cGUnO1xyXG5cclxuLy8gQ3JlYXRlIG9iamVjdCB3aXRoIGZha2UgYG51bGxgIHByb3RvdHlwZTogdXNlIGlmcmFtZSBPYmplY3Qgd2l0aCBjbGVhcmVkIHByb3RvdHlwZVxyXG52YXIgY3JlYXRlRGljdCA9IGZ1bmN0aW9uKCl7XHJcbiAgLy8gVGhyYXNoLCB3YXN0ZSBhbmQgc29kb215OiBJRSBHQyBidWdcclxuICB2YXIgaWZyYW1lID0gcmVxdWlyZSgnLi9fZG9tLWNyZWF0ZScpKCdpZnJhbWUnKVxyXG4gICAgLCBpICAgICAgPSBlbnVtQnVnS2V5cy5sZW5ndGhcclxuICAgICwgZ3QgICAgID0gJz4nXHJcbiAgICAsIGlmcmFtZURvY3VtZW50O1xyXG4gIGlmcmFtZS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xyXG4gIHJlcXVpcmUoJy4vX2h0bWwnKS5hcHBlbmRDaGlsZChpZnJhbWUpO1xyXG4gIGlmcmFtZS5zcmMgPSAnamF2YXNjcmlwdDonOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXNjcmlwdC11cmxcclxuICAvLyBjcmVhdGVEaWN0ID0gaWZyYW1lLmNvbnRlbnRXaW5kb3cuT2JqZWN0O1xyXG4gIC8vIGh0bWwucmVtb3ZlQ2hpbGQoaWZyYW1lKTtcclxuICBpZnJhbWVEb2N1bWVudCA9IGlmcmFtZS5jb250ZW50V2luZG93LmRvY3VtZW50O1xyXG4gIGlmcmFtZURvY3VtZW50Lm9wZW4oKTtcclxuICBpZnJhbWVEb2N1bWVudC53cml0ZSgnPHNjcmlwdD5kb2N1bWVudC5GPU9iamVjdDwvc2NyaXB0JyArIGd0KTtcclxuICBpZnJhbWVEb2N1bWVudC5jbG9zZSgpO1xyXG4gIGNyZWF0ZURpY3QgPSBpZnJhbWVEb2N1bWVudC5GO1xyXG4gIHdoaWxlKGktLSlkZWxldGUgY3JlYXRlRGljdFtQUk9UT1RZUEVdW2VudW1CdWdLZXlzW2ldXTtcclxuICByZXR1cm4gY3JlYXRlRGljdCgpO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBPYmplY3QuY3JlYXRlIHx8IGZ1bmN0aW9uIGNyZWF0ZShPLCBQcm9wZXJ0aWVzKXtcclxuICB2YXIgcmVzdWx0O1xyXG4gIGlmKE8gIT09IG51bGwpe1xyXG4gICAgRW1wdHlbUFJPVE9UWVBFXSA9IGFuT2JqZWN0KE8pO1xyXG4gICAgcmVzdWx0ID0gbmV3IEVtcHR5O1xyXG4gICAgRW1wdHlbUFJPVE9UWVBFXSA9IG51bGw7XHJcbiAgICAvLyBhZGQgXCJfX3Byb3RvX19cIiBmb3IgT2JqZWN0LmdldFByb3RvdHlwZU9mIHBvbHlmaWxsXHJcbiAgICByZXN1bHRbSUVfUFJPVE9dID0gTztcclxuICB9IGVsc2UgcmVzdWx0ID0gY3JlYXRlRGljdCgpO1xyXG4gIHJldHVybiBQcm9wZXJ0aWVzID09PSB1bmRlZmluZWQgPyByZXN1bHQgOiBkUHMocmVzdWx0LCBQcm9wZXJ0aWVzKTtcclxufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1jcmVhdGUuanNcbi8vIG1vZHVsZSBpZCA9IDMyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBkUCAgICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpXHJcbiAgLCBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpXHJcbiAgLCBnZXRLZXlzICA9IHJlcXVpcmUoJy4vX29iamVjdC1rZXlzJyk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJykgPyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyA6IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXMoTywgUHJvcGVydGllcyl7XHJcbiAgYW5PYmplY3QoTyk7XHJcbiAgdmFyIGtleXMgICA9IGdldEtleXMoUHJvcGVydGllcylcclxuICAgICwgbGVuZ3RoID0ga2V5cy5sZW5ndGhcclxuICAgICwgaSA9IDBcclxuICAgICwgUDtcclxuICB3aGlsZShsZW5ndGggPiBpKWRQLmYoTywgUCA9IGtleXNbaSsrXSwgUHJvcGVydGllc1tQXSk7XHJcbiAgcmV0dXJuIE87XHJcbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3QtZHBzLmpzXG4vLyBtb2R1bGUgaWQgPSAzM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyAxOS4xLjIuMTQgLyAxNS4yLjMuMTQgT2JqZWN0LmtleXMoTylcclxudmFyICRrZXlzICAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWtleXMtaW50ZXJuYWwnKVxyXG4gICwgZW51bUJ1Z0tleXMgPSByZXF1aXJlKCcuL19lbnVtLWJ1Zy1rZXlzJyk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IE9iamVjdC5rZXlzIHx8IGZ1bmN0aW9uIGtleXMoTyl7XHJcbiAgcmV0dXJuICRrZXlzKE8sIGVudW1CdWdLZXlzKTtcclxufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1rZXlzLmpzXG4vLyBtb2R1bGUgaWQgPSAzNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgaGFzICAgICAgICAgID0gcmVxdWlyZSgnLi9faGFzJylcclxuICAsIHRvSU9iamVjdCAgICA9IHJlcXVpcmUoJy4vX3RvLWlvYmplY3QnKVxyXG4gICwgYXJyYXlJbmRleE9mID0gcmVxdWlyZSgnLi9fYXJyYXktaW5jbHVkZXMnKShmYWxzZSlcclxuICAsIElFX1BST1RPICAgICA9IHJlcXVpcmUoJy4vX3NoYXJlZC1rZXknKSgnSUVfUFJPVE8nKTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24ob2JqZWN0LCBuYW1lcyl7XHJcbiAgdmFyIE8gICAgICA9IHRvSU9iamVjdChvYmplY3QpXHJcbiAgICAsIGkgICAgICA9IDBcclxuICAgICwgcmVzdWx0ID0gW11cclxuICAgICwga2V5O1xyXG4gIGZvcihrZXkgaW4gTylpZihrZXkgIT0gSUVfUFJPVE8paGFzKE8sIGtleSkgJiYgcmVzdWx0LnB1c2goa2V5KTtcclxuICAvLyBEb24ndCBlbnVtIGJ1ZyAmIGhpZGRlbiBrZXlzXHJcbiAgd2hpbGUobmFtZXMubGVuZ3RoID4gaSlpZihoYXMoTywga2V5ID0gbmFtZXNbaSsrXSkpe1xyXG4gICAgfmFycmF5SW5kZXhPZihyZXN1bHQsIGtleSkgfHwgcmVzdWx0LnB1c2goa2V5KTtcclxuICB9XHJcbiAgcmV0dXJuIHJlc3VsdDtcclxufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1rZXlzLWludGVybmFsLmpzXG4vLyBtb2R1bGUgaWQgPSAzNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyB0byBpbmRleGVkIG9iamVjdCwgdG9PYmplY3Qgd2l0aCBmYWxsYmFjayBmb3Igbm9uLWFycmF5LWxpa2UgRVMzIHN0cmluZ3NcbnZhciBJT2JqZWN0ID0gcmVxdWlyZSgnLi9faW9iamVjdCcpXG4gICwgZGVmaW5lZCA9IHJlcXVpcmUoJy4vX2RlZmluZWQnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQpe1xuICByZXR1cm4gSU9iamVjdChkZWZpbmVkKGl0KSk7XG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fdG8taW9iamVjdC5qc1xuLy8gbW9kdWxlIGlkID0gMzZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gZmFsbGJhY2sgZm9yIG5vbi1hcnJheS1saWtlIEVTMyBhbmQgbm9uLWVudW1lcmFibGUgb2xkIFY4IHN0cmluZ3NcbnZhciBjb2YgPSByZXF1aXJlKCcuL19jb2YnKTtcbm1vZHVsZS5leHBvcnRzID0gT2JqZWN0KCd6JykucHJvcGVydHlJc0VudW1lcmFibGUoMCkgPyBPYmplY3QgOiBmdW5jdGlvbihpdCl7XG4gIHJldHVybiBjb2YoaXQpID09ICdTdHJpbmcnID8gaXQuc3BsaXQoJycpIDogT2JqZWN0KGl0KTtcbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19pb2JqZWN0LmpzXG4vLyBtb2R1bGUgaWQgPSAzN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgdG9TdHJpbmcgPSB7fS50b1N0cmluZztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCl7XG4gIHJldHVybiB0b1N0cmluZy5jYWxsKGl0KS5zbGljZSg4LCAtMSk7XG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fY29mLmpzXG4vLyBtb2R1bGUgaWQgPSAzOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyBmYWxzZSAtPiBBcnJheSNpbmRleE9mXG4vLyB0cnVlICAtPiBBcnJheSNpbmNsdWRlc1xudmFyIHRvSU9iamVjdCA9IHJlcXVpcmUoJy4vX3RvLWlvYmplY3QnKVxuICAsIHRvTGVuZ3RoICA9IHJlcXVpcmUoJy4vX3RvLWxlbmd0aCcpXG4gICwgdG9JbmRleCAgID0gcmVxdWlyZSgnLi9fdG8taW5kZXgnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oSVNfSU5DTFVERVMpe1xuICByZXR1cm4gZnVuY3Rpb24oJHRoaXMsIGVsLCBmcm9tSW5kZXgpe1xuICAgIHZhciBPICAgICAgPSB0b0lPYmplY3QoJHRoaXMpXG4gICAgICAsIGxlbmd0aCA9IHRvTGVuZ3RoKE8ubGVuZ3RoKVxuICAgICAgLCBpbmRleCAgPSB0b0luZGV4KGZyb21JbmRleCwgbGVuZ3RoKVxuICAgICAgLCB2YWx1ZTtcbiAgICAvLyBBcnJheSNpbmNsdWRlcyB1c2VzIFNhbWVWYWx1ZVplcm8gZXF1YWxpdHkgYWxnb3JpdGhtXG4gICAgaWYoSVNfSU5DTFVERVMgJiYgZWwgIT0gZWwpd2hpbGUobGVuZ3RoID4gaW5kZXgpe1xuICAgICAgdmFsdWUgPSBPW2luZGV4KytdO1xuICAgICAgaWYodmFsdWUgIT0gdmFsdWUpcmV0dXJuIHRydWU7XG4gICAgLy8gQXJyYXkjdG9JbmRleCBpZ25vcmVzIGhvbGVzLCBBcnJheSNpbmNsdWRlcyAtIG5vdFxuICAgIH0gZWxzZSBmb3IoO2xlbmd0aCA+IGluZGV4OyBpbmRleCsrKWlmKElTX0lOQ0xVREVTIHx8IGluZGV4IGluIE8pe1xuICAgICAgaWYoT1tpbmRleF0gPT09IGVsKXJldHVybiBJU19JTkNMVURFUyB8fCBpbmRleCB8fCAwO1xuICAgIH0gcmV0dXJuICFJU19JTkNMVURFUyAmJiAtMTtcbiAgfTtcbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19hcnJheS1pbmNsdWRlcy5qc1xuLy8gbW9kdWxlIGlkID0gMzlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gNy4xLjE1IFRvTGVuZ3RoXG52YXIgdG9JbnRlZ2VyID0gcmVxdWlyZSgnLi9fdG8taW50ZWdlcicpXG4gICwgbWluICAgICAgID0gTWF0aC5taW47XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KXtcbiAgcmV0dXJuIGl0ID4gMCA/IG1pbih0b0ludGVnZXIoaXQpLCAweDFmZmZmZmZmZmZmZmZmKSA6IDA7IC8vIHBvdygyLCA1MykgLSAxID09IDkwMDcxOTkyNTQ3NDA5OTFcbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL190by1sZW5ndGguanNcbi8vIG1vZHVsZSBpZCA9IDQwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciB0b0ludGVnZXIgPSByZXF1aXJlKCcuL190by1pbnRlZ2VyJylcbiAgLCBtYXggICAgICAgPSBNYXRoLm1heFxuICAsIG1pbiAgICAgICA9IE1hdGgubWluO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpbmRleCwgbGVuZ3RoKXtcbiAgaW5kZXggPSB0b0ludGVnZXIoaW5kZXgpO1xuICByZXR1cm4gaW5kZXggPCAwID8gbWF4KGluZGV4ICsgbGVuZ3RoLCAwKSA6IG1pbihpbmRleCwgbGVuZ3RoKTtcbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL190by1pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gNDFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIHNoYXJlZCA9IHJlcXVpcmUoJy4vX3NoYXJlZCcpKCdrZXlzJylcclxuICAsIHVpZCAgICA9IHJlcXVpcmUoJy4vX3VpZCcpO1xyXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGtleSl7XHJcbiAgcmV0dXJuIHNoYXJlZFtrZXldIHx8IChzaGFyZWRba2V5XSA9IHVpZChrZXkpKTtcclxufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3NoYXJlZC1rZXkuanNcbi8vIG1vZHVsZSBpZCA9IDQyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBnbG9iYWwgPSByZXF1aXJlKCcuL19nbG9iYWwnKVxuICAsIFNIQVJFRCA9ICdfX2NvcmUtanNfc2hhcmVkX18nXG4gICwgc3RvcmUgID0gZ2xvYmFsW1NIQVJFRF0gfHwgKGdsb2JhbFtTSEFSRURdID0ge30pO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihrZXkpe1xuICByZXR1cm4gc3RvcmVba2V5XSB8fCAoc3RvcmVba2V5XSA9IHt9KTtcbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19zaGFyZWQuanNcbi8vIG1vZHVsZSBpZCA9IDQzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBpZCA9IDBcbiAgLCBweCA9IE1hdGgucmFuZG9tKCk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGtleSl7XG4gIHJldHVybiAnU3ltYm9sKCcuY29uY2F0KGtleSA9PT0gdW5kZWZpbmVkID8gJycgOiBrZXksICcpXycsICgrK2lkICsgcHgpLnRvU3RyaW5nKDM2KSk7XG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fdWlkLmpzXG4vLyBtb2R1bGUgaWQgPSA0NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyBJRSA4LSBkb24ndCBlbnVtIGJ1ZyBrZXlzXHJcbm1vZHVsZS5leHBvcnRzID0gKFxyXG4gICdjb25zdHJ1Y3RvcixoYXNPd25Qcm9wZXJ0eSxpc1Byb3RvdHlwZU9mLHByb3BlcnR5SXNFbnVtZXJhYmxlLHRvTG9jYWxlU3RyaW5nLHRvU3RyaW5nLHZhbHVlT2YnXHJcbikuc3BsaXQoJywnKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2VudW0tYnVnLWtleXMuanNcbi8vIG1vZHVsZSBpZCA9IDQ1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9fZ2xvYmFsJykuZG9jdW1lbnQgJiYgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faHRtbC5qc1xuLy8gbW9kdWxlIGlkID0gNDZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGRlZiA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpLmZcbiAgLCBoYXMgPSByZXF1aXJlKCcuL19oYXMnKVxuICAsIFRBRyA9IHJlcXVpcmUoJy4vX3drcycpKCd0b1N0cmluZ1RhZycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0LCB0YWcsIHN0YXQpe1xuICBpZihpdCAmJiAhaGFzKGl0ID0gc3RhdCA/IGl0IDogaXQucHJvdG90eXBlLCBUQUcpKWRlZihpdCwgVEFHLCB7Y29uZmlndXJhYmxlOiB0cnVlLCB2YWx1ZTogdGFnfSk7XG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fc2V0LXRvLXN0cmluZy10YWcuanNcbi8vIG1vZHVsZSBpZCA9IDQ3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBzdG9yZSAgICAgID0gcmVxdWlyZSgnLi9fc2hhcmVkJykoJ3drcycpXG4gICwgdWlkICAgICAgICA9IHJlcXVpcmUoJy4vX3VpZCcpXG4gICwgU3ltYm9sICAgICA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpLlN5bWJvbFxuICAsIFVTRV9TWU1CT0wgPSB0eXBlb2YgU3ltYm9sID09ICdmdW5jdGlvbic7XG5cbnZhciAkZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24obmFtZSl7XG4gIHJldHVybiBzdG9yZVtuYW1lXSB8fCAoc3RvcmVbbmFtZV0gPVxuICAgIFVTRV9TWU1CT0wgJiYgU3ltYm9sW25hbWVdIHx8IChVU0VfU1lNQk9MID8gU3ltYm9sIDogdWlkKSgnU3ltYm9sLicgKyBuYW1lKSk7XG59O1xuXG4kZXhwb3J0cy5zdG9yZSA9IHN0b3JlO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fd2tzLmpzXG4vLyBtb2R1bGUgaWQgPSA0OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyAxOS4xLjIuOSAvIDE1LjIuMy4yIE9iamVjdC5nZXRQcm90b3R5cGVPZihPKVxyXG52YXIgaGFzICAgICAgICAgPSByZXF1aXJlKCcuL19oYXMnKVxyXG4gICwgdG9PYmplY3QgICAgPSByZXF1aXJlKCcuL190by1vYmplY3QnKVxyXG4gICwgSUVfUFJPVE8gICAgPSByZXF1aXJlKCcuL19zaGFyZWQta2V5JykoJ0lFX1BST1RPJylcclxuICAsIE9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gT2JqZWN0LmdldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uKE8pe1xyXG4gIE8gPSB0b09iamVjdChPKTtcclxuICBpZihoYXMoTywgSUVfUFJPVE8pKXJldHVybiBPW0lFX1BST1RPXTtcclxuICBpZih0eXBlb2YgTy5jb25zdHJ1Y3RvciA9PSAnZnVuY3Rpb24nICYmIE8gaW5zdGFuY2VvZiBPLmNvbnN0cnVjdG9yKXtcclxuICAgIHJldHVybiBPLmNvbnN0cnVjdG9yLnByb3RvdHlwZTtcclxuICB9IHJldHVybiBPIGluc3RhbmNlb2YgT2JqZWN0ID8gT2JqZWN0UHJvdG8gOiBudWxsO1xyXG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LWdwby5qc1xuLy8gbW9kdWxlIGlkID0gNDlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gNy4xLjEzIFRvT2JqZWN0KGFyZ3VtZW50KVxudmFyIGRlZmluZWQgPSByZXF1aXJlKCcuL19kZWZpbmVkJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KXtcbiAgcmV0dXJuIE9iamVjdChkZWZpbmVkKGl0KSk7XG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fdG8tb2JqZWN0LmpzXG4vLyBtb2R1bGUgaWQgPSA1MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJyZXF1aXJlKCcuL2VzNi5hcnJheS5pdGVyYXRvcicpO1xudmFyIGdsb2JhbCAgICAgICAgPSByZXF1aXJlKCcuL19nbG9iYWwnKVxuICAsIGhpZGUgICAgICAgICAgPSByZXF1aXJlKCcuL19oaWRlJylcbiAgLCBJdGVyYXRvcnMgICAgID0gcmVxdWlyZSgnLi9faXRlcmF0b3JzJylcbiAgLCBUT19TVFJJTkdfVEFHID0gcmVxdWlyZSgnLi9fd2tzJykoJ3RvU3RyaW5nVGFnJyk7XG5cbmZvcih2YXIgY29sbGVjdGlvbnMgPSBbJ05vZGVMaXN0JywgJ0RPTVRva2VuTGlzdCcsICdNZWRpYUxpc3QnLCAnU3R5bGVTaGVldExpc3QnLCAnQ1NTUnVsZUxpc3QnXSwgaSA9IDA7IGkgPCA1OyBpKyspe1xuICB2YXIgTkFNRSAgICAgICA9IGNvbGxlY3Rpb25zW2ldXG4gICAgLCBDb2xsZWN0aW9uID0gZ2xvYmFsW05BTUVdXG4gICAgLCBwcm90byAgICAgID0gQ29sbGVjdGlvbiAmJiBDb2xsZWN0aW9uLnByb3RvdHlwZTtcbiAgaWYocHJvdG8gJiYgIXByb3RvW1RPX1NUUklOR19UQUddKWhpZGUocHJvdG8sIFRPX1NUUklOR19UQUcsIE5BTUUpO1xuICBJdGVyYXRvcnNbTkFNRV0gPSBJdGVyYXRvcnMuQXJyYXk7XG59XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL3dlYi5kb20uaXRlcmFibGUuanNcbi8vIG1vZHVsZSBpZCA9IDUxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcbnZhciBhZGRUb1Vuc2NvcGFibGVzID0gcmVxdWlyZSgnLi9fYWRkLXRvLXVuc2NvcGFibGVzJylcbiAgLCBzdGVwICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9faXRlci1zdGVwJylcbiAgLCBJdGVyYXRvcnMgICAgICAgID0gcmVxdWlyZSgnLi9faXRlcmF0b3JzJylcbiAgLCB0b0lPYmplY3QgICAgICAgID0gcmVxdWlyZSgnLi9fdG8taW9iamVjdCcpO1xuXG4vLyAyMi4xLjMuNCBBcnJheS5wcm90b3R5cGUuZW50cmllcygpXG4vLyAyMi4xLjMuMTMgQXJyYXkucHJvdG90eXBlLmtleXMoKVxuLy8gMjIuMS4zLjI5IEFycmF5LnByb3RvdHlwZS52YWx1ZXMoKVxuLy8gMjIuMS4zLjMwIEFycmF5LnByb3RvdHlwZVtAQGl0ZXJhdG9yXSgpXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vX2l0ZXItZGVmaW5lJykoQXJyYXksICdBcnJheScsIGZ1bmN0aW9uKGl0ZXJhdGVkLCBraW5kKXtcbiAgdGhpcy5fdCA9IHRvSU9iamVjdChpdGVyYXRlZCk7IC8vIHRhcmdldFxuICB0aGlzLl9pID0gMDsgICAgICAgICAgICAgICAgICAgLy8gbmV4dCBpbmRleFxuICB0aGlzLl9rID0ga2luZDsgICAgICAgICAgICAgICAgLy8ga2luZFxuLy8gMjIuMS41LjIuMSAlQXJyYXlJdGVyYXRvclByb3RvdHlwZSUubmV4dCgpXG59LCBmdW5jdGlvbigpe1xuICB2YXIgTyAgICAgPSB0aGlzLl90XG4gICAgLCBraW5kICA9IHRoaXMuX2tcbiAgICAsIGluZGV4ID0gdGhpcy5faSsrO1xuICBpZighTyB8fCBpbmRleCA+PSBPLmxlbmd0aCl7XG4gICAgdGhpcy5fdCA9IHVuZGVmaW5lZDtcbiAgICByZXR1cm4gc3RlcCgxKTtcbiAgfVxuICBpZihraW5kID09ICdrZXlzJyAgKXJldHVybiBzdGVwKDAsIGluZGV4KTtcbiAgaWYoa2luZCA9PSAndmFsdWVzJylyZXR1cm4gc3RlcCgwLCBPW2luZGV4XSk7XG4gIHJldHVybiBzdGVwKDAsIFtpbmRleCwgT1tpbmRleF1dKTtcbn0sICd2YWx1ZXMnKTtcblxuLy8gYXJndW1lbnRzTGlzdFtAQGl0ZXJhdG9yXSBpcyAlQXJyYXlQcm90b192YWx1ZXMlICg5LjQuNC42LCA5LjQuNC43KVxuSXRlcmF0b3JzLkFyZ3VtZW50cyA9IEl0ZXJhdG9ycy5BcnJheTtcblxuYWRkVG9VbnNjb3BhYmxlcygna2V5cycpO1xuYWRkVG9VbnNjb3BhYmxlcygndmFsdWVzJyk7XG5hZGRUb1Vuc2NvcGFibGVzKCdlbnRyaWVzJyk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNi5hcnJheS5pdGVyYXRvci5qc1xuLy8gbW9kdWxlIGlkID0gNTJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbigpeyAvKiBlbXB0eSAqLyB9O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fYWRkLXRvLXVuc2NvcGFibGVzLmpzXG4vLyBtb2R1bGUgaWQgPSA1M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGRvbmUsIHZhbHVlKXtcbiAgcmV0dXJuIHt2YWx1ZTogdmFsdWUsIGRvbmU6ICEhZG9uZX07XG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faXRlci1zdGVwLmpzXG4vLyBtb2R1bGUgaWQgPSA1NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJleHBvcnRzLmYgPSByZXF1aXJlKCcuL193a3MnKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3drcy1leHQuanNcbi8vIG1vZHVsZSBpZCA9IDU1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0geyBcImRlZmF1bHRcIjogcmVxdWlyZShcImNvcmUtanMvbGlicmFyeS9mbi9zeW1ib2xcIiksIF9fZXNNb2R1bGU6IHRydWUgfTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vYmFiZWwtcnVudGltZS9jb3JlLWpzL3N5bWJvbC5qc1xuLy8gbW9kdWxlIGlkID0gNTZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwicmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9lczYuc3ltYm9sJyk7XG5yZXF1aXJlKCcuLi8uLi9tb2R1bGVzL2VzNi5vYmplY3QudG8tc3RyaW5nJyk7XG5yZXF1aXJlKCcuLi8uLi9tb2R1bGVzL2VzNy5zeW1ib2wuYXN5bmMtaXRlcmF0b3InKTtcbnJlcXVpcmUoJy4uLy4uL21vZHVsZXMvZXM3LnN5bWJvbC5vYnNlcnZhYmxlJyk7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4uLy4uL21vZHVsZXMvX2NvcmUnKS5TeW1ib2w7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbGlicmFyeS9mbi9zeW1ib2wvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDU3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0Jztcbi8vIEVDTUFTY3JpcHQgNiBzeW1ib2xzIHNoaW1cbnZhciBnbG9iYWwgICAgICAgICA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpXG4gICwgaGFzICAgICAgICAgICAgPSByZXF1aXJlKCcuL19oYXMnKVxuICAsIERFU0NSSVBUT1JTICAgID0gcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKVxuICAsICRleHBvcnQgICAgICAgID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCByZWRlZmluZSAgICAgICA9IHJlcXVpcmUoJy4vX3JlZGVmaW5lJylcbiAgLCBNRVRBICAgICAgICAgICA9IHJlcXVpcmUoJy4vX21ldGEnKS5LRVlcbiAgLCAkZmFpbHMgICAgICAgICA9IHJlcXVpcmUoJy4vX2ZhaWxzJylcbiAgLCBzaGFyZWQgICAgICAgICA9IHJlcXVpcmUoJy4vX3NoYXJlZCcpXG4gICwgc2V0VG9TdHJpbmdUYWcgPSByZXF1aXJlKCcuL19zZXQtdG8tc3RyaW5nLXRhZycpXG4gICwgdWlkICAgICAgICAgICAgPSByZXF1aXJlKCcuL191aWQnKVxuICAsIHdrcyAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fd2tzJylcbiAgLCB3a3NFeHQgICAgICAgICA9IHJlcXVpcmUoJy4vX3drcy1leHQnKVxuICAsIHdrc0RlZmluZSAgICAgID0gcmVxdWlyZSgnLi9fd2tzLWRlZmluZScpXG4gICwga2V5T2YgICAgICAgICAgPSByZXF1aXJlKCcuL19rZXlvZicpXG4gICwgZW51bUtleXMgICAgICAgPSByZXF1aXJlKCcuL19lbnVtLWtleXMnKVxuICAsIGlzQXJyYXkgICAgICAgID0gcmVxdWlyZSgnLi9faXMtYXJyYXknKVxuICAsIGFuT2JqZWN0ICAgICAgID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0JylcbiAgLCB0b0lPYmplY3QgICAgICA9IHJlcXVpcmUoJy4vX3RvLWlvYmplY3QnKVxuICAsIHRvUHJpbWl0aXZlICAgID0gcmVxdWlyZSgnLi9fdG8tcHJpbWl0aXZlJylcbiAgLCBjcmVhdGVEZXNjICAgICA9IHJlcXVpcmUoJy4vX3Byb3BlcnR5LWRlc2MnKVxuICAsIF9jcmVhdGUgICAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWNyZWF0ZScpXG4gICwgZ09QTkV4dCAgICAgICAgPSByZXF1aXJlKCcuL19vYmplY3QtZ29wbi1leHQnKVxuICAsICRHT1BEICAgICAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcGQnKVxuICAsICREUCAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJylcbiAgLCAka2V5cyAgICAgICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1rZXlzJylcbiAgLCBnT1BEICAgICAgICAgICA9ICRHT1BELmZcbiAgLCBkUCAgICAgICAgICAgICA9ICREUC5mXG4gICwgZ09QTiAgICAgICAgICAgPSBnT1BORXh0LmZcbiAgLCAkU3ltYm9sICAgICAgICA9IGdsb2JhbC5TeW1ib2xcbiAgLCAkSlNPTiAgICAgICAgICA9IGdsb2JhbC5KU09OXG4gICwgX3N0cmluZ2lmeSAgICAgPSAkSlNPTiAmJiAkSlNPTi5zdHJpbmdpZnlcbiAgLCBQUk9UT1RZUEUgICAgICA9ICdwcm90b3R5cGUnXG4gICwgSElEREVOICAgICAgICAgPSB3a3MoJ19oaWRkZW4nKVxuICAsIFRPX1BSSU1JVElWRSAgID0gd2tzKCd0b1ByaW1pdGl2ZScpXG4gICwgaXNFbnVtICAgICAgICAgPSB7fS5wcm9wZXJ0eUlzRW51bWVyYWJsZVxuICAsIFN5bWJvbFJlZ2lzdHJ5ID0gc2hhcmVkKCdzeW1ib2wtcmVnaXN0cnknKVxuICAsIEFsbFN5bWJvbHMgICAgID0gc2hhcmVkKCdzeW1ib2xzJylcbiAgLCBPUFN5bWJvbHMgICAgICA9IHNoYXJlZCgnb3Atc3ltYm9scycpXG4gICwgT2JqZWN0UHJvdG8gICAgPSBPYmplY3RbUFJPVE9UWVBFXVxuICAsIFVTRV9OQVRJVkUgICAgID0gdHlwZW9mICRTeW1ib2wgPT0gJ2Z1bmN0aW9uJ1xuICAsIFFPYmplY3QgICAgICAgID0gZ2xvYmFsLlFPYmplY3Q7XG4vLyBEb24ndCB1c2Ugc2V0dGVycyBpbiBRdCBTY3JpcHQsIGh0dHBzOi8vZ2l0aHViLmNvbS96bG9pcm9jay9jb3JlLWpzL2lzc3Vlcy8xNzNcbnZhciBzZXR0ZXIgPSAhUU9iamVjdCB8fCAhUU9iamVjdFtQUk9UT1RZUEVdIHx8ICFRT2JqZWN0W1BST1RPVFlQRV0uZmluZENoaWxkO1xuXG4vLyBmYWxsYmFjayBmb3Igb2xkIEFuZHJvaWQsIGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvdjgvaXNzdWVzL2RldGFpbD9pZD02ODdcbnZhciBzZXRTeW1ib2xEZXNjID0gREVTQ1JJUFRPUlMgJiYgJGZhaWxzKGZ1bmN0aW9uKCl7XG4gIHJldHVybiBfY3JlYXRlKGRQKHt9LCAnYScsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uKCl7IHJldHVybiBkUCh0aGlzLCAnYScsIHt2YWx1ZTogN30pLmE7IH1cbiAgfSkpLmEgIT0gNztcbn0pID8gZnVuY3Rpb24oaXQsIGtleSwgRCl7XG4gIHZhciBwcm90b0Rlc2MgPSBnT1BEKE9iamVjdFByb3RvLCBrZXkpO1xuICBpZihwcm90b0Rlc2MpZGVsZXRlIE9iamVjdFByb3RvW2tleV07XG4gIGRQKGl0LCBrZXksIEQpO1xuICBpZihwcm90b0Rlc2MgJiYgaXQgIT09IE9iamVjdFByb3RvKWRQKE9iamVjdFByb3RvLCBrZXksIHByb3RvRGVzYyk7XG59IDogZFA7XG5cbnZhciB3cmFwID0gZnVuY3Rpb24odGFnKXtcbiAgdmFyIHN5bSA9IEFsbFN5bWJvbHNbdGFnXSA9IF9jcmVhdGUoJFN5bWJvbFtQUk9UT1RZUEVdKTtcbiAgc3ltLl9rID0gdGFnO1xuICByZXR1cm4gc3ltO1xufTtcblxudmFyIGlzU3ltYm9sID0gVVNFX05BVElWRSAmJiB0eXBlb2YgJFN5bWJvbC5pdGVyYXRvciA9PSAnc3ltYm9sJyA/IGZ1bmN0aW9uKGl0KXtcbiAgcmV0dXJuIHR5cGVvZiBpdCA9PSAnc3ltYm9sJztcbn0gOiBmdW5jdGlvbihpdCl7XG4gIHJldHVybiBpdCBpbnN0YW5jZW9mICRTeW1ib2w7XG59O1xuXG52YXIgJGRlZmluZVByb3BlcnR5ID0gZnVuY3Rpb24gZGVmaW5lUHJvcGVydHkoaXQsIGtleSwgRCl7XG4gIGlmKGl0ID09PSBPYmplY3RQcm90bykkZGVmaW5lUHJvcGVydHkoT1BTeW1ib2xzLCBrZXksIEQpO1xuICBhbk9iamVjdChpdCk7XG4gIGtleSA9IHRvUHJpbWl0aXZlKGtleSwgdHJ1ZSk7XG4gIGFuT2JqZWN0KEQpO1xuICBpZihoYXMoQWxsU3ltYm9scywga2V5KSl7XG4gICAgaWYoIUQuZW51bWVyYWJsZSl7XG4gICAgICBpZighaGFzKGl0LCBISURERU4pKWRQKGl0LCBISURERU4sIGNyZWF0ZURlc2MoMSwge30pKTtcbiAgICAgIGl0W0hJRERFTl1ba2V5XSA9IHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmKGhhcyhpdCwgSElEREVOKSAmJiBpdFtISURERU5dW2tleV0paXRbSElEREVOXVtrZXldID0gZmFsc2U7XG4gICAgICBEID0gX2NyZWF0ZShELCB7ZW51bWVyYWJsZTogY3JlYXRlRGVzYygwLCBmYWxzZSl9KTtcbiAgICB9IHJldHVybiBzZXRTeW1ib2xEZXNjKGl0LCBrZXksIEQpO1xuICB9IHJldHVybiBkUChpdCwga2V5LCBEKTtcbn07XG52YXIgJGRlZmluZVByb3BlcnRpZXMgPSBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKGl0LCBQKXtcbiAgYW5PYmplY3QoaXQpO1xuICB2YXIga2V5cyA9IGVudW1LZXlzKFAgPSB0b0lPYmplY3QoUCkpXG4gICAgLCBpICAgID0gMFxuICAgICwgbCA9IGtleXMubGVuZ3RoXG4gICAgLCBrZXk7XG4gIHdoaWxlKGwgPiBpKSRkZWZpbmVQcm9wZXJ0eShpdCwga2V5ID0ga2V5c1tpKytdLCBQW2tleV0pO1xuICByZXR1cm4gaXQ7XG59O1xudmFyICRjcmVhdGUgPSBmdW5jdGlvbiBjcmVhdGUoaXQsIFApe1xuICByZXR1cm4gUCA9PT0gdW5kZWZpbmVkID8gX2NyZWF0ZShpdCkgOiAkZGVmaW5lUHJvcGVydGllcyhfY3JlYXRlKGl0KSwgUCk7XG59O1xudmFyICRwcm9wZXJ0eUlzRW51bWVyYWJsZSA9IGZ1bmN0aW9uIHByb3BlcnR5SXNFbnVtZXJhYmxlKGtleSl7XG4gIHZhciBFID0gaXNFbnVtLmNhbGwodGhpcywga2V5ID0gdG9QcmltaXRpdmUoa2V5LCB0cnVlKSk7XG4gIGlmKHRoaXMgPT09IE9iamVjdFByb3RvICYmIGhhcyhBbGxTeW1ib2xzLCBrZXkpICYmICFoYXMoT1BTeW1ib2xzLCBrZXkpKXJldHVybiBmYWxzZTtcbiAgcmV0dXJuIEUgfHwgIWhhcyh0aGlzLCBrZXkpIHx8ICFoYXMoQWxsU3ltYm9scywga2V5KSB8fCBoYXModGhpcywgSElEREVOKSAmJiB0aGlzW0hJRERFTl1ba2V5XSA/IEUgOiB0cnVlO1xufTtcbnZhciAkZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID0gZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGl0LCBrZXkpe1xuICBpdCAgPSB0b0lPYmplY3QoaXQpO1xuICBrZXkgPSB0b1ByaW1pdGl2ZShrZXksIHRydWUpO1xuICBpZihpdCA9PT0gT2JqZWN0UHJvdG8gJiYgaGFzKEFsbFN5bWJvbHMsIGtleSkgJiYgIWhhcyhPUFN5bWJvbHMsIGtleSkpcmV0dXJuO1xuICB2YXIgRCA9IGdPUEQoaXQsIGtleSk7XG4gIGlmKEQgJiYgaGFzKEFsbFN5bWJvbHMsIGtleSkgJiYgIShoYXMoaXQsIEhJRERFTikgJiYgaXRbSElEREVOXVtrZXldKSlELmVudW1lcmFibGUgPSB0cnVlO1xuICByZXR1cm4gRDtcbn07XG52YXIgJGdldE93blByb3BlcnR5TmFtZXMgPSBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eU5hbWVzKGl0KXtcbiAgdmFyIG5hbWVzICA9IGdPUE4odG9JT2JqZWN0KGl0KSlcbiAgICAsIHJlc3VsdCA9IFtdXG4gICAgLCBpICAgICAgPSAwXG4gICAgLCBrZXk7XG4gIHdoaWxlKG5hbWVzLmxlbmd0aCA+IGkpe1xuICAgIGlmKCFoYXMoQWxsU3ltYm9scywga2V5ID0gbmFtZXNbaSsrXSkgJiYga2V5ICE9IEhJRERFTiAmJiBrZXkgIT0gTUVUQSlyZXN1bHQucHVzaChrZXkpO1xuICB9IHJldHVybiByZXN1bHQ7XG59O1xudmFyICRnZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPSBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eVN5bWJvbHMoaXQpe1xuICB2YXIgSVNfT1AgID0gaXQgPT09IE9iamVjdFByb3RvXG4gICAgLCBuYW1lcyAgPSBnT1BOKElTX09QID8gT1BTeW1ib2xzIDogdG9JT2JqZWN0KGl0KSlcbiAgICAsIHJlc3VsdCA9IFtdXG4gICAgLCBpICAgICAgPSAwXG4gICAgLCBrZXk7XG4gIHdoaWxlKG5hbWVzLmxlbmd0aCA+IGkpe1xuICAgIGlmKGhhcyhBbGxTeW1ib2xzLCBrZXkgPSBuYW1lc1tpKytdKSAmJiAoSVNfT1AgPyBoYXMoT2JqZWN0UHJvdG8sIGtleSkgOiB0cnVlKSlyZXN1bHQucHVzaChBbGxTeW1ib2xzW2tleV0pO1xuICB9IHJldHVybiByZXN1bHQ7XG59O1xuXG4vLyAxOS40LjEuMSBTeW1ib2woW2Rlc2NyaXB0aW9uXSlcbmlmKCFVU0VfTkFUSVZFKXtcbiAgJFN5bWJvbCA9IGZ1bmN0aW9uIFN5bWJvbCgpe1xuICAgIGlmKHRoaXMgaW5zdGFuY2VvZiAkU3ltYm9sKXRocm93IFR5cGVFcnJvcignU3ltYm9sIGlzIG5vdCBhIGNvbnN0cnVjdG9yIScpO1xuICAgIHZhciB0YWcgPSB1aWQoYXJndW1lbnRzLmxlbmd0aCA+IDAgPyBhcmd1bWVudHNbMF0gOiB1bmRlZmluZWQpO1xuICAgIHZhciAkc2V0ID0gZnVuY3Rpb24odmFsdWUpe1xuICAgICAgaWYodGhpcyA9PT0gT2JqZWN0UHJvdG8pJHNldC5jYWxsKE9QU3ltYm9scywgdmFsdWUpO1xuICAgICAgaWYoaGFzKHRoaXMsIEhJRERFTikgJiYgaGFzKHRoaXNbSElEREVOXSwgdGFnKSl0aGlzW0hJRERFTl1bdGFnXSA9IGZhbHNlO1xuICAgICAgc2V0U3ltYm9sRGVzYyh0aGlzLCB0YWcsIGNyZWF0ZURlc2MoMSwgdmFsdWUpKTtcbiAgICB9O1xuICAgIGlmKERFU0NSSVBUT1JTICYmIHNldHRlcilzZXRTeW1ib2xEZXNjKE9iamVjdFByb3RvLCB0YWcsIHtjb25maWd1cmFibGU6IHRydWUsIHNldDogJHNldH0pO1xuICAgIHJldHVybiB3cmFwKHRhZyk7XG4gIH07XG4gIHJlZGVmaW5lKCRTeW1ib2xbUFJPVE9UWVBFXSwgJ3RvU3RyaW5nJywgZnVuY3Rpb24gdG9TdHJpbmcoKXtcbiAgICByZXR1cm4gdGhpcy5faztcbiAgfSk7XG5cbiAgJEdPUEQuZiA9ICRnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG4gICREUC5mICAgPSAkZGVmaW5lUHJvcGVydHk7XG4gIHJlcXVpcmUoJy4vX29iamVjdC1nb3BuJykuZiA9IGdPUE5FeHQuZiA9ICRnZXRPd25Qcm9wZXJ0eU5hbWVzO1xuICByZXF1aXJlKCcuL19vYmplY3QtcGllJykuZiAgPSAkcHJvcGVydHlJc0VudW1lcmFibGU7XG4gIHJlcXVpcmUoJy4vX29iamVjdC1nb3BzJykuZiA9ICRnZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XG5cbiAgaWYoREVTQ1JJUFRPUlMgJiYgIXJlcXVpcmUoJy4vX2xpYnJhcnknKSl7XG4gICAgcmVkZWZpbmUoT2JqZWN0UHJvdG8sICdwcm9wZXJ0eUlzRW51bWVyYWJsZScsICRwcm9wZXJ0eUlzRW51bWVyYWJsZSwgdHJ1ZSk7XG4gIH1cblxuICB3a3NFeHQuZiA9IGZ1bmN0aW9uKG5hbWUpe1xuICAgIHJldHVybiB3cmFwKHdrcyhuYW1lKSk7XG4gIH1cbn1cblxuJGV4cG9ydCgkZXhwb3J0LkcgKyAkZXhwb3J0LlcgKyAkZXhwb3J0LkYgKiAhVVNFX05BVElWRSwge1N5bWJvbDogJFN5bWJvbH0pO1xuXG5mb3IodmFyIHN5bWJvbHMgPSAoXG4gIC8vIDE5LjQuMi4yLCAxOS40LjIuMywgMTkuNC4yLjQsIDE5LjQuMi42LCAxOS40LjIuOCwgMTkuNC4yLjksIDE5LjQuMi4xMCwgMTkuNC4yLjExLCAxOS40LjIuMTIsIDE5LjQuMi4xMywgMTkuNC4yLjE0XG4gICdoYXNJbnN0YW5jZSxpc0NvbmNhdFNwcmVhZGFibGUsaXRlcmF0b3IsbWF0Y2gscmVwbGFjZSxzZWFyY2gsc3BlY2llcyxzcGxpdCx0b1ByaW1pdGl2ZSx0b1N0cmluZ1RhZyx1bnNjb3BhYmxlcydcbikuc3BsaXQoJywnKSwgaSA9IDA7IHN5bWJvbHMubGVuZ3RoID4gaTsgKXdrcyhzeW1ib2xzW2krK10pO1xuXG5mb3IodmFyIHN5bWJvbHMgPSAka2V5cyh3a3Muc3RvcmUpLCBpID0gMDsgc3ltYm9scy5sZW5ndGggPiBpOyApd2tzRGVmaW5lKHN5bWJvbHNbaSsrXSk7XG5cbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogIVVTRV9OQVRJVkUsICdTeW1ib2wnLCB7XG4gIC8vIDE5LjQuMi4xIFN5bWJvbC5mb3Ioa2V5KVxuICAnZm9yJzogZnVuY3Rpb24oa2V5KXtcbiAgICByZXR1cm4gaGFzKFN5bWJvbFJlZ2lzdHJ5LCBrZXkgKz0gJycpXG4gICAgICA/IFN5bWJvbFJlZ2lzdHJ5W2tleV1cbiAgICAgIDogU3ltYm9sUmVnaXN0cnlba2V5XSA9ICRTeW1ib2woa2V5KTtcbiAgfSxcbiAgLy8gMTkuNC4yLjUgU3ltYm9sLmtleUZvcihzeW0pXG4gIGtleUZvcjogZnVuY3Rpb24ga2V5Rm9yKGtleSl7XG4gICAgaWYoaXNTeW1ib2woa2V5KSlyZXR1cm4ga2V5T2YoU3ltYm9sUmVnaXN0cnksIGtleSk7XG4gICAgdGhyb3cgVHlwZUVycm9yKGtleSArICcgaXMgbm90IGEgc3ltYm9sIScpO1xuICB9LFxuICB1c2VTZXR0ZXI6IGZ1bmN0aW9uKCl7IHNldHRlciA9IHRydWU7IH0sXG4gIHVzZVNpbXBsZTogZnVuY3Rpb24oKXsgc2V0dGVyID0gZmFsc2U7IH1cbn0pO1xuXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqICFVU0VfTkFUSVZFLCAnT2JqZWN0Jywge1xuICAvLyAxOS4xLjIuMiBPYmplY3QuY3JlYXRlKE8gWywgUHJvcGVydGllc10pXG4gIGNyZWF0ZTogJGNyZWF0ZSxcbiAgLy8gMTkuMS4yLjQgT2JqZWN0LmRlZmluZVByb3BlcnR5KE8sIFAsIEF0dHJpYnV0ZXMpXG4gIGRlZmluZVByb3BlcnR5OiAkZGVmaW5lUHJvcGVydHksXG4gIC8vIDE5LjEuMi4zIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKE8sIFByb3BlcnRpZXMpXG4gIGRlZmluZVByb3BlcnRpZXM6ICRkZWZpbmVQcm9wZXJ0aWVzLFxuICAvLyAxOS4xLjIuNiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKE8sIFApXG4gIGdldE93blByb3BlcnR5RGVzY3JpcHRvcjogJGdldE93blByb3BlcnR5RGVzY3JpcHRvcixcbiAgLy8gMTkuMS4yLjcgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoTylcbiAgZ2V0T3duUHJvcGVydHlOYW1lczogJGdldE93blByb3BlcnR5TmFtZXMsXG4gIC8vIDE5LjEuMi44IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoTylcbiAgZ2V0T3duUHJvcGVydHlTeW1ib2xzOiAkZ2V0T3duUHJvcGVydHlTeW1ib2xzXG59KTtcblxuLy8gMjQuMy4yIEpTT04uc3RyaW5naWZ5KHZhbHVlIFssIHJlcGxhY2VyIFssIHNwYWNlXV0pXG4kSlNPTiAmJiAkZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqICghVVNFX05BVElWRSB8fCAkZmFpbHMoZnVuY3Rpb24oKXtcbiAgdmFyIFMgPSAkU3ltYm9sKCk7XG4gIC8vIE1TIEVkZ2UgY29udmVydHMgc3ltYm9sIHZhbHVlcyB0byBKU09OIGFzIHt9XG4gIC8vIFdlYktpdCBjb252ZXJ0cyBzeW1ib2wgdmFsdWVzIHRvIEpTT04gYXMgbnVsbFxuICAvLyBWOCB0aHJvd3Mgb24gYm94ZWQgc3ltYm9sc1xuICByZXR1cm4gX3N0cmluZ2lmeShbU10pICE9ICdbbnVsbF0nIHx8IF9zdHJpbmdpZnkoe2E6IFN9KSAhPSAne30nIHx8IF9zdHJpbmdpZnkoT2JqZWN0KFMpKSAhPSAne30nO1xufSkpLCAnSlNPTicsIHtcbiAgc3RyaW5naWZ5OiBmdW5jdGlvbiBzdHJpbmdpZnkoaXQpe1xuICAgIGlmKGl0ID09PSB1bmRlZmluZWQgfHwgaXNTeW1ib2woaXQpKXJldHVybjsgLy8gSUU4IHJldHVybnMgc3RyaW5nIG9uIHVuZGVmaW5lZFxuICAgIHZhciBhcmdzID0gW2l0XVxuICAgICAgLCBpICAgID0gMVxuICAgICAgLCByZXBsYWNlciwgJHJlcGxhY2VyO1xuICAgIHdoaWxlKGFyZ3VtZW50cy5sZW5ndGggPiBpKWFyZ3MucHVzaChhcmd1bWVudHNbaSsrXSk7XG4gICAgcmVwbGFjZXIgPSBhcmdzWzFdO1xuICAgIGlmKHR5cGVvZiByZXBsYWNlciA9PSAnZnVuY3Rpb24nKSRyZXBsYWNlciA9IHJlcGxhY2VyO1xuICAgIGlmKCRyZXBsYWNlciB8fCAhaXNBcnJheShyZXBsYWNlcikpcmVwbGFjZXIgPSBmdW5jdGlvbihrZXksIHZhbHVlKXtcbiAgICAgIGlmKCRyZXBsYWNlcil2YWx1ZSA9ICRyZXBsYWNlci5jYWxsKHRoaXMsIGtleSwgdmFsdWUpO1xuICAgICAgaWYoIWlzU3ltYm9sKHZhbHVlKSlyZXR1cm4gdmFsdWU7XG4gICAgfTtcbiAgICBhcmdzWzFdID0gcmVwbGFjZXI7XG4gICAgcmV0dXJuIF9zdHJpbmdpZnkuYXBwbHkoJEpTT04sIGFyZ3MpO1xuICB9XG59KTtcblxuLy8gMTkuNC4zLjQgU3ltYm9sLnByb3RvdHlwZVtAQHRvUHJpbWl0aXZlXShoaW50KVxuJFN5bWJvbFtQUk9UT1RZUEVdW1RPX1BSSU1JVElWRV0gfHwgcmVxdWlyZSgnLi9faGlkZScpKCRTeW1ib2xbUFJPVE9UWVBFXSwgVE9fUFJJTUlUSVZFLCAkU3ltYm9sW1BST1RPVFlQRV0udmFsdWVPZik7XG4vLyAxOS40LjMuNSBTeW1ib2wucHJvdG90eXBlW0BAdG9TdHJpbmdUYWddXG5zZXRUb1N0cmluZ1RhZygkU3ltYm9sLCAnU3ltYm9sJyk7XG4vLyAyMC4yLjEuOSBNYXRoW0BAdG9TdHJpbmdUYWddXG5zZXRUb1N0cmluZ1RhZyhNYXRoLCAnTWF0aCcsIHRydWUpO1xuLy8gMjQuMy4zIEpTT05bQEB0b1N0cmluZ1RhZ11cbnNldFRvU3RyaW5nVGFnKGdsb2JhbC5KU09OLCAnSlNPTicsIHRydWUpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczYuc3ltYm9sLmpzXG4vLyBtb2R1bGUgaWQgPSA1OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgTUVUQSAgICAgPSByZXF1aXJlKCcuL191aWQnKSgnbWV0YScpXG4gICwgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKVxuICAsIGhhcyAgICAgID0gcmVxdWlyZSgnLi9faGFzJylcbiAgLCBzZXREZXNjICA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpLmZcbiAgLCBpZCAgICAgICA9IDA7XG52YXIgaXNFeHRlbnNpYmxlID0gT2JqZWN0LmlzRXh0ZW5zaWJsZSB8fCBmdW5jdGlvbigpe1xuICByZXR1cm4gdHJ1ZTtcbn07XG52YXIgRlJFRVpFID0gIXJlcXVpcmUoJy4vX2ZhaWxzJykoZnVuY3Rpb24oKXtcbiAgcmV0dXJuIGlzRXh0ZW5zaWJsZShPYmplY3QucHJldmVudEV4dGVuc2lvbnMoe30pKTtcbn0pO1xudmFyIHNldE1ldGEgPSBmdW5jdGlvbihpdCl7XG4gIHNldERlc2MoaXQsIE1FVEEsIHt2YWx1ZToge1xuICAgIGk6ICdPJyArICsraWQsIC8vIG9iamVjdCBJRFxuICAgIHc6IHt9ICAgICAgICAgIC8vIHdlYWsgY29sbGVjdGlvbnMgSURzXG4gIH19KTtcbn07XG52YXIgZmFzdEtleSA9IGZ1bmN0aW9uKGl0LCBjcmVhdGUpe1xuICAvLyByZXR1cm4gcHJpbWl0aXZlIHdpdGggcHJlZml4XG4gIGlmKCFpc09iamVjdChpdCkpcmV0dXJuIHR5cGVvZiBpdCA9PSAnc3ltYm9sJyA/IGl0IDogKHR5cGVvZiBpdCA9PSAnc3RyaW5nJyA/ICdTJyA6ICdQJykgKyBpdDtcbiAgaWYoIWhhcyhpdCwgTUVUQSkpe1xuICAgIC8vIGNhbid0IHNldCBtZXRhZGF0YSB0byB1bmNhdWdodCBmcm96ZW4gb2JqZWN0XG4gICAgaWYoIWlzRXh0ZW5zaWJsZShpdCkpcmV0dXJuICdGJztcbiAgICAvLyBub3QgbmVjZXNzYXJ5IHRvIGFkZCBtZXRhZGF0YVxuICAgIGlmKCFjcmVhdGUpcmV0dXJuICdFJztcbiAgICAvLyBhZGQgbWlzc2luZyBtZXRhZGF0YVxuICAgIHNldE1ldGEoaXQpO1xuICAvLyByZXR1cm4gb2JqZWN0IElEXG4gIH0gcmV0dXJuIGl0W01FVEFdLmk7XG59O1xudmFyIGdldFdlYWsgPSBmdW5jdGlvbihpdCwgY3JlYXRlKXtcbiAgaWYoIWhhcyhpdCwgTUVUQSkpe1xuICAgIC8vIGNhbid0IHNldCBtZXRhZGF0YSB0byB1bmNhdWdodCBmcm96ZW4gb2JqZWN0XG4gICAgaWYoIWlzRXh0ZW5zaWJsZShpdCkpcmV0dXJuIHRydWU7XG4gICAgLy8gbm90IG5lY2Vzc2FyeSB0byBhZGQgbWV0YWRhdGFcbiAgICBpZighY3JlYXRlKXJldHVybiBmYWxzZTtcbiAgICAvLyBhZGQgbWlzc2luZyBtZXRhZGF0YVxuICAgIHNldE1ldGEoaXQpO1xuICAvLyByZXR1cm4gaGFzaCB3ZWFrIGNvbGxlY3Rpb25zIElEc1xuICB9IHJldHVybiBpdFtNRVRBXS53O1xufTtcbi8vIGFkZCBtZXRhZGF0YSBvbiBmcmVlemUtZmFtaWx5IG1ldGhvZHMgY2FsbGluZ1xudmFyIG9uRnJlZXplID0gZnVuY3Rpb24oaXQpe1xuICBpZihGUkVFWkUgJiYgbWV0YS5ORUVEICYmIGlzRXh0ZW5zaWJsZShpdCkgJiYgIWhhcyhpdCwgTUVUQSkpc2V0TWV0YShpdCk7XG4gIHJldHVybiBpdDtcbn07XG52YXIgbWV0YSA9IG1vZHVsZS5leHBvcnRzID0ge1xuICBLRVk6ICAgICAgTUVUQSxcbiAgTkVFRDogICAgIGZhbHNlLFxuICBmYXN0S2V5OiAgZmFzdEtleSxcbiAgZ2V0V2VhazogIGdldFdlYWssXG4gIG9uRnJlZXplOiBvbkZyZWV6ZVxufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX21ldGEuanNcbi8vIG1vZHVsZSBpZCA9IDU5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBnbG9iYWwgICAgICAgICA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpXHJcbiAgLCBjb3JlICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2NvcmUnKVxyXG4gICwgTElCUkFSWSAgICAgICAgPSByZXF1aXJlKCcuL19saWJyYXJ5JylcclxuICAsIHdrc0V4dCAgICAgICAgID0gcmVxdWlyZSgnLi9fd2tzLWV4dCcpXHJcbiAgLCBkZWZpbmVQcm9wZXJ0eSA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpLmY7XHJcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24obmFtZSl7XHJcbiAgdmFyICRTeW1ib2wgPSBjb3JlLlN5bWJvbCB8fCAoY29yZS5TeW1ib2wgPSBMSUJSQVJZID8ge30gOiBnbG9iYWwuU3ltYm9sIHx8IHt9KTtcclxuICBpZihuYW1lLmNoYXJBdCgwKSAhPSAnXycgJiYgIShuYW1lIGluICRTeW1ib2wpKWRlZmluZVByb3BlcnR5KCRTeW1ib2wsIG5hbWUsIHt2YWx1ZTogd2tzRXh0LmYobmFtZSl9KTtcclxufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3drcy1kZWZpbmUuanNcbi8vIG1vZHVsZSBpZCA9IDYwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBnZXRLZXlzICAgPSByZXF1aXJlKCcuL19vYmplY3Qta2V5cycpXG4gICwgdG9JT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8taW9iamVjdCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihvYmplY3QsIGVsKXtcbiAgdmFyIE8gICAgICA9IHRvSU9iamVjdChvYmplY3QpXG4gICAgLCBrZXlzICAgPSBnZXRLZXlzKE8pXG4gICAgLCBsZW5ndGggPSBrZXlzLmxlbmd0aFxuICAgICwgaW5kZXggID0gMFxuICAgICwga2V5O1xuICB3aGlsZShsZW5ndGggPiBpbmRleClpZihPW2tleSA9IGtleXNbaW5kZXgrK11dID09PSBlbClyZXR1cm4ga2V5O1xufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2tleW9mLmpzXG4vLyBtb2R1bGUgaWQgPSA2MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyBhbGwgZW51bWVyYWJsZSBvYmplY3Qga2V5cywgaW5jbHVkZXMgc3ltYm9sc1xudmFyIGdldEtleXMgPSByZXF1aXJlKCcuL19vYmplY3Qta2V5cycpXG4gICwgZ09QUyAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BzJylcbiAgLCBwSUUgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LXBpZScpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCl7XG4gIHZhciByZXN1bHQgICAgID0gZ2V0S2V5cyhpdClcbiAgICAsIGdldFN5bWJvbHMgPSBnT1BTLmY7XG4gIGlmKGdldFN5bWJvbHMpe1xuICAgIHZhciBzeW1ib2xzID0gZ2V0U3ltYm9scyhpdClcbiAgICAgICwgaXNFbnVtICA9IHBJRS5mXG4gICAgICAsIGkgICAgICAgPSAwXG4gICAgICAsIGtleTtcbiAgICB3aGlsZShzeW1ib2xzLmxlbmd0aCA+IGkpaWYoaXNFbnVtLmNhbGwoaXQsIGtleSA9IHN5bWJvbHNbaSsrXSkpcmVzdWx0LnB1c2goa2V5KTtcbiAgfSByZXR1cm4gcmVzdWx0O1xufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2VudW0ta2V5cy5qc1xuLy8gbW9kdWxlIGlkID0gNjJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiZXhwb3J0cy5mID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scztcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1nb3BzLmpzXG4vLyBtb2R1bGUgaWQgPSA2M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJleHBvcnRzLmYgPSB7fS5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1waWUuanNcbi8vIG1vZHVsZSBpZCA9IDY0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIDcuMi4yIElzQXJyYXkoYXJndW1lbnQpXG52YXIgY29mID0gcmVxdWlyZSgnLi9fY29mJyk7XG5tb2R1bGUuZXhwb3J0cyA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gaXNBcnJheShhcmcpe1xuICByZXR1cm4gY29mKGFyZykgPT0gJ0FycmF5Jztcbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19pcy1hcnJheS5qc1xuLy8gbW9kdWxlIGlkID0gNjVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gZmFsbGJhY2sgZm9yIElFMTEgYnVnZ3kgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMgd2l0aCBpZnJhbWUgYW5kIHdpbmRvd1xudmFyIHRvSU9iamVjdCA9IHJlcXVpcmUoJy4vX3RvLWlvYmplY3QnKVxuICAsIGdPUE4gICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BuJykuZlxuICAsIHRvU3RyaW5nICA9IHt9LnRvU3RyaW5nO1xuXG52YXIgd2luZG93TmFtZXMgPSB0eXBlb2Ygd2luZG93ID09ICdvYmplY3QnICYmIHdpbmRvdyAmJiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lc1xuICA/IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHdpbmRvdykgOiBbXTtcblxudmFyIGdldFdpbmRvd05hbWVzID0gZnVuY3Rpb24oaXQpe1xuICB0cnkge1xuICAgIHJldHVybiBnT1BOKGl0KTtcbiAgfSBjYXRjaChlKXtcbiAgICByZXR1cm4gd2luZG93TmFtZXMuc2xpY2UoKTtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMuZiA9IGZ1bmN0aW9uIGdldE93blByb3BlcnR5TmFtZXMoaXQpe1xuICByZXR1cm4gd2luZG93TmFtZXMgJiYgdG9TdHJpbmcuY2FsbChpdCkgPT0gJ1tvYmplY3QgV2luZG93XScgPyBnZXRXaW5kb3dOYW1lcyhpdCkgOiBnT1BOKHRvSU9iamVjdChpdCkpO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LWdvcG4tZXh0LmpzXG4vLyBtb2R1bGUgaWQgPSA2NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyAxOS4xLjIuNyAvIDE1LjIuMy40IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKE8pXHJcbnZhciAka2V5cyAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWtleXMtaW50ZXJuYWwnKVxyXG4gICwgaGlkZGVuS2V5cyA9IHJlcXVpcmUoJy4vX2VudW0tYnVnLWtleXMnKS5jb25jYXQoJ2xlbmd0aCcsICdwcm90b3R5cGUnKTtcclxuXHJcbmV4cG9ydHMuZiA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzIHx8IGZ1bmN0aW9uIGdldE93blByb3BlcnR5TmFtZXMoTyl7XHJcbiAgcmV0dXJuICRrZXlzKE8sIGhpZGRlbktleXMpO1xyXG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LWdvcG4uanNcbi8vIG1vZHVsZSBpZCA9IDY3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBwSUUgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1waWUnKVxyXG4gICwgY3JlYXRlRGVzYyAgICAgPSByZXF1aXJlKCcuL19wcm9wZXJ0eS1kZXNjJylcclxuICAsIHRvSU9iamVjdCAgICAgID0gcmVxdWlyZSgnLi9fdG8taW9iamVjdCcpXHJcbiAgLCB0b1ByaW1pdGl2ZSAgICA9IHJlcXVpcmUoJy4vX3RvLXByaW1pdGl2ZScpXHJcbiAgLCBoYXMgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2hhcycpXHJcbiAgLCBJRThfRE9NX0RFRklORSA9IHJlcXVpcmUoJy4vX2llOC1kb20tZGVmaW5lJylcclxuICAsIGdPUEQgICAgICAgICAgID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcclxuXHJcbmV4cG9ydHMuZiA9IHJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJykgPyBnT1BEIDogZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKE8sIFApe1xyXG4gIE8gPSB0b0lPYmplY3QoTyk7XHJcbiAgUCA9IHRvUHJpbWl0aXZlKFAsIHRydWUpO1xyXG4gIGlmKElFOF9ET01fREVGSU5FKXRyeSB7XHJcbiAgICByZXR1cm4gZ09QRChPLCBQKTtcclxuICB9IGNhdGNoKGUpeyAvKiBlbXB0eSAqLyB9XHJcbiAgaWYoaGFzKE8sIFApKXJldHVybiBjcmVhdGVEZXNjKCFwSUUuZi5jYWxsKE8sIFApLCBPW1BdKTtcclxufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1nb3BkLmpzXG4vLyBtb2R1bGUgaWQgPSA2OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJyZXF1aXJlKCcuL193a3MtZGVmaW5lJykoJ2FzeW5jSXRlcmF0b3InKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM3LnN5bWJvbC5hc3luYy1pdGVyYXRvci5qc1xuLy8gbW9kdWxlIGlkID0gNzBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwicmVxdWlyZSgnLi9fd2tzLWRlZmluZScpKCdvYnNlcnZhYmxlJyk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNy5zeW1ib2wub2JzZXJ2YWJsZS5qc1xuLy8gbW9kdWxlIGlkID0gNzFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==",__webpack_require__.p+"highlightJson.worker.js");};

/***/ },
/* 152 */
/***/ function(module, exports) {

	// http://stackoverflow.com/questions/10343913/how-to-create-a-web-worker-from-a-string
	
	var URL = window.URL || window.webkitURL;
	module.exports = function(content, url) {
		try {
			try {
				var blob;
				try { // BlobBuilder = Deprecated, but widely implemented
					var BlobBuilder = window.BlobBuilder || window.WebKitBlobBuilder || window.MozBlobBuilder || window.MSBlobBuilder;
					blob = new BlobBuilder();
					blob.append(content);
					blob = blob.getBlob();
				} catch(e) { // The proposed API
					blob = new Blob([content]);
				}
				return new Worker(URL.createObjectURL(blob));
			} catch(e) {
				return new Worker('data:application/javascript,' + encodeURIComponent(content));
			}
		} catch(e) {
			return new Worker(url);
		}
	}

/***/ },
/* 153 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _classCallCheck2 = __webpack_require__(86);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _createClass2 = __webpack_require__(87);
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	var _symbol = __webpack_require__(56);
	
	var _symbol2 = _interopRequireDefault(_symbol);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * Colors service (singleton)
	 */
	
	var num = (0, _symbol2.default)('NUM');
	var prefix = (0, _symbol2.default)('PREFIX');
	var instance = null;
	
	var ColorsService = function () {
		function ColorsService() {
			var NUM = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 12;
			var PREFIX = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'color-';
			(0, _classCallCheck3.default)(this, ColorsService);
	
			if (!instance) {
				instance = this;
			}
	
			this[num] = NUM;
			this[prefix] = PREFIX;
			this.colors = this.getColors();
	
			return instance;
		}
	
		/**
	  * Gets random color css class
	  * @param color {string} existing css class to prevent mach
	  * @returns {string} css class name
	  */
	
	
		(0, _createClass3.default)(ColorsService, [{
			key: 'getRandomColor',
			value: function getRandomColor(color) {
				var randomNumber = void 0;
				var PREFIX = this[prefix];
				do {
					randomNumber = this.constructor.getRandomInt(1, this.colors.length);
				} while (PREFIX + randomNumber === color);
	
				return PREFIX + randomNumber;
			}
	
			/**
	   * Builds array of colors css classes
	   * @returns {Array} array of strings
	   */
	
		}, {
			key: 'getColors',
			value: function getColors() {
				var colors = new Array(this[num]);
				for (var i = 0; i < colors.length; i++) {
					colors[i] = this[prefix] + (i + 1);
				}
				return colors;
			}
	
			/**
	   * Returns a random integer between min (inclusive) and max (inclusive)
	   * Using Math.round() will give you a non-uniform distribution!
	   */
	
		}], [{
			key: 'getRandomInt',
			value: function getRandomInt(min, max) {
				return Math.floor(Math.random() * (max - min + 1)) + min;
			}
		}]);
		return ColorsService;
	}();
	
	module.exports = new ColorsService();

/***/ },
/* 154 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function($, global) {'use strict';
	
	var _typeof2 = __webpack_require__(4);
	
	var _typeof3 = _interopRequireDefault(_typeof2);
	
	var _keys = __webpack_require__(73);
	
	var _keys2 = _interopRequireDefault(_keys);
	
	var _slicedToArray2 = __webpack_require__(77);
	
	var _slicedToArray3 = _interopRequireDefault(_slicedToArray2);
	
	var _classCallCheck2 = __webpack_require__(86);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _createClass2 = __webpack_require__(87);
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	var _base = __webpack_require__(147);
	
	var _base2 = _interopRequireDefault(_base);
	
	var _apiKey = __webpack_require__(148);
	
	var _apiKey2 = _interopRequireDefault(_apiKey);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * Rest service
	 * Gets data from server
	 */
	var instance = void 0;
	
	var RestService = function () {
		function RestService() {
			var _this = this;
	
			(0, _classCallCheck3.default)(this, RestService);
	
			this.callback = function (res, msg) {
				var category = ko.unwrap(_this.selectedCategory);
				var type = ko.unwrap(_this.selectedMethodType);
				var methodId = ko.unwrap(_this.selectedMethod);
				var params = ko.unwrap(_this.selectedParams);
	
				var resObj = {
					category: category,
					method: type,
					methodId: methodId,
					params: params.map(function (obj) {
						return $.extend(true, {}, {
							name: obj.name,
							value: ko.observable(ko.unwrap(obj.value)),
							options: obj.options
						});
					}),
					req: _this.req,
					index: _this.requests().length
				};
	
				if (msg == 'error') {
					// notifying error modal
					_this.error = ko.observable(res).publishOn('REQUEST_ERROR');
					// error popover of request
					resObj.error = res;
				} else {
					_this.error && delete _this.error;
					global.lastResponse = resObj.response = res.responseJSON;
				}
	
				// exporting data using observable
				_this.requests.unshift(resObj);
			};
	
			this.parseUrl = function (url) {
				var location = url ? '?' + url.split('?')[1] : window.location.search;
	
				if (location) {
					var querys;
					var obj;
	
					var _ret = function () {
						querys = location.replace(/^\?/g, '').split('&');
						obj = {
							apiCategory: '',
							methodId: '',
							parameters: []
						};
	
	
						var globalQueryObj = window.location.query = {};
						querys.map(function (query) {
							var _decodeURI$split = decodeURI(query).split('='),
							    _decodeURI$split2 = (0, _slicedToArray3.default)(_decodeURI$split, 2),
							    key = _decodeURI$split2[0],
							    val = _decodeURI$split2[1];
	
							if ((0, _keys2.default)(obj).indexOf(key) !== -1) {
								try {
									obj[key] = globalQueryObj[key] = JSON.parse(val);
								} catch (exception_var) {
									obj[key] = globalQueryObj[key] = val;
								}
							} else {
								try {
									globalQueryObj[key] = JSON.parse(val);
								} catch (exception_var) {
									globalQueryObj[key] = val;
								}
	
								obj.parameters.push({
									name: key,
									value: globalQueryObj[key]
								});
							}
						});
	
						var methodData = _this.getMethodData(obj);
						var parameters = methodData.parameters;
	
						obj.parameters = obj.parameters.map(function (obj) {
							return $.extend(true, {}, parameters[obj.name], obj);
						});
						return {
							v: obj
						};
					}();
	
					if ((typeof _ret === 'undefined' ? 'undefined' : (0, _typeof3.default)(_ret)) === "object") return _ret.v;
				}
				return {};
			};
	
			if (!instance) {
				instance = this;
			}
			this.base = _base2.default;
			this.apiKey = _apiKey2.default;
			this.selectedCategory = ko.observable('').subscribeTo('SELECTED_CATEGORY');
			this.selectedMethodType = ko.observable('').subscribeTo('SELECTED_METHOD_TYPE');
			this.selectedMethod = ko.observable('').subscribeTo('SELECTED_METHOD');
			this.selectedParams = ko.observableArray([]).subscribeTo('SELECTED_PARAMS');
			this.requests = ko.observableArray([]).syncWith('REQUESTS_ARR');
			this.anotherResponse = ko.observable().publishOn('ANOTHER_RESPONSE');
			this.init();
			return instance;
		}
	
		(0, _createClass3.default)(RestService, [{
			key: 'init',
			value: function init() {
				var _this2 = this;
	
				ko.postbox.subscribe('SELECTED_METHOD', function (newValue) {
					_this2.selectedMethodData = _this2.getMethodData();
				});
	
				ko.postbox.subscribe('ANOTHER_REQUEST', function (_ref) {
					var method = _ref.method,
					    panelGroup = _ref.panelGroup,
					    color = _ref.color;
	
					_this2.anotherRequest = true;
					var url = _this2.prepareUrl(method.base, method.path, method.parameters);
	
					_this2.ajaxService({ url: url, type: method.method, callback: function callback(res, msg) {
							var category = method.category;
							var type = method.method;
							var methodId = method.id;
							var params = method.parameters;
	
							var resObj = {
								category: category,
								method: type,
								methodId: methodId,
								params: params.map(function (obj) {
									return $.extend(true, {}, {
										name: obj.name,
										value: ko.observable(ko.unwrap(obj.value)),
										options: obj.options
									});
								}),
								req: _this2.req,
								index: _this2.requests().length
							};
	
							if (msg == 'error') {
								// notifying error modal
								_this2.error = ko.observable(res).publishOn('REQUEST_ERROR');
							} else {
								_this2.error && delete _this2.error;
								resObj.response = res.responseJSON;
							}
	
							// exporting data using observable
							_this2.anotherResponse({ data: resObj, panelGroup: panelGroup, color: color });
						} });
				});
			}
		}, {
			key: 'sendRequest',
			value: function sendRequest() {
				var type = ko.unwrap(this.selectedMethodType);
				this.req = this.prepareUrl();
				this.ajaxService({ url: this.req, type: type, callback: this.callback });
			}
	
			/**
	   * Filters and prepares params pairs
	   * @returns {boolean}
	   */
	
		}, {
			key: 'prepareUrl',
			value: function prepareUrl(_domain, _path, _selectedParams) {
				var replacement = void 0,
				    url = void 0,
				    params = void 0,
				    selectedParams = ko.unwrap(_selectedParams || this.selectedParams);
	
				var domain = _domain || this.selectedMethodData.base;
				var path = _path || this.selectedMethodData.path;
	
				params = selectedParams.filter(function (item) {
					return item.style === 'query';
				});
	
				// arr of template marks
				replacement = path.match(/([^{]*?)\w(?=\})/gmi);
	
				// arr of template params
				var templatesArr = selectedParams.filter(function (item) {
					return item.style === 'template';
				});
	
				// replacement
				replacement.forEach(function (val) {
					var param = templatesArr.find(function (item) {
						return item.name === val;
					});
					path = path.replace('{' + param.name + '}', ko.unwrap(param.value) || param.default);
				});
	
				// adds apiKey param
				if (!params[0] || params[0].name !== 'apikey') {
					params.unshift(this.apiKey);
				}
	
				// prepares params part of url
				params = params.map(function (item) {
					return [item.name, ko.unwrap(item.value) || item.default].join('=');
				}).join('&');
	
				url = [domain, '/', path, '?', params].join('');
	
				return encodeURI(url);
			}
	
			/**
	   * Ajax Service
	   */
	
		}, {
			key: 'ajaxService',
			value: function ajaxService(_ref2) {
				var url = _ref2.url,
				    _ref2$type = _ref2.type,
				    type = _ref2$type === undefined ? 'GET' : _ref2$type,
				    _ref2$async = _ref2.async,
				    async = _ref2$async === undefined ? true : _ref2$async,
				    _ref2$dataType = _ref2.dataType,
				    dataType = _ref2$dataType === undefined ? 'json' : _ref2$dataType,
				    callback = _ref2.callback;
	
				$.ajax({
					type: type === 'ALL' ? 'GET' : type,
					url: url,
					async: async,
					dataType: dataType,
					complete: callback
				});
			}
		}, {
			key: 'getMethodData',
			value: function getMethodData() {
				var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
	
				var category = ko.unwrap(params.apiCategory || this.selectedCategory);
				var methodType = ko.unwrap(params.type || this.selectedMethodType || 'ALL');
				var method = ko.unwrap(params.methodId || this.selectedMethod);
				return this.base[category] && this.base[category][methodType] && this.base[category][methodType][method] || {};
			}
		}]);
		return RestService;
	}();
	
	module.exports = new RestService();
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2), (function() { return this; }())))

/***/ },
/* 155 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function($) {'use strict';
	
	var _isNan = __webpack_require__(156);
	
	var _isNan2 = _interopRequireDefault(_isNan);
	
	var _typeof2 = __webpack_require__(4);
	
	var _typeof3 = _interopRequireDefault(_typeof2);
	
	var _classCallCheck2 = __webpack_require__(86);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _createClass2 = __webpack_require__(87);
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	var _class, _temp, _initialiseProps;
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var self;
	
	var ObjectPanelBody = (_temp = _class = function () {
		function ObjectPanelBody(_ref) {
			var _ref$data = _ref.data,
			    data = _ref$data === undefined ? {} : _ref$data,
			    config = _ref.config,
			    _ref$index = _ref.index,
			    index = _ref$index === undefined ? this.cardIndex : _ref$index,
			    _ref$panelGroup = _ref.panelGroup,
			    panelGroup = _ref$panelGroup === undefined ? {} : _ref$panelGroup,
			    page = _ref.page,
			    collapseId = _ref.collapseId,
			    subjectID = _ref.subjectID;
			(0, _classCallCheck3.default)(this, ObjectPanelBody);
	
			_initialiseProps.call(this);
	
			self = this;
			this.data = this.data || ko.observable(data.value);
			this.config = config;
			this._panelName = data.key;
			this.cardIndex = ko.unwrap(index);
			this.panelGroup = panelGroup;
			this.getMore = panelGroup.getMore;
			this.page = page;
			this.collapseId = collapseId;
			this._allInside = !!Object.getProp(ko.unwrap(config), '._CONFIG.allInside');
			this.sortByConfig = panelGroup.sortByConfig;
			this.subjectID = subjectID;
			this.sendId(this.data);
		}
	
		(0, _createClass3.default)(ObjectPanelBody, [{
			key: 'sendId',
			value: function sendId(data) {
				var id = ko.unwrap(data).id;
				if (id) {
					this.subjectID(id);
				}
			}
		}, {
			key: 'canBeCopied',
			value: function canBeCopied() {
				return !!Object.getProp(self.config, '._CONFIG.copyBtn.' + this.key) && (0, _typeof3.default)(this.value) !== 'object';
			}
		}, {
			key: 'setActive',
			value: function setActive(key, value, model, e) {
				$(e.currentTarget).parents('.slick-slide').find('.item.object').removeClass('active');
				$(e.currentTarget).parent('.item').addClass('active');
				this.getMore.call(null, { panel: this, id: key, data: value });
			}
		}]);
		return ObjectPanelBody;
	}(), _initialiseProps = function _initialiseProps() {
		var _this = this;
	
		this.onEnterKeyDown = function (model, event) {
			if (event.keyCode === 13) {
				var page = _this.page;
				var value = +event.currentTarget.value;
				value = (0, _isNan2.default)(value) ? 0 : value;
				var pageNumber = ~~value < 0 ? 0 : ~~value;
				page.pageParam(pageNumber < ko.unwrap(_this.data).totalPages ? pageNumber : ko.unwrap(_this.data).totalPages - 1);
				page.setParams({
					category: page.category,
					method: page.method,
					methodId: page.methodId,
					params: page.params
				});
				$('#api-exp-get-btn').trigger('click');
			} else {
				return true;
			}
		};
	}, _temp);
	
	
	module.exports = ko.components.register('object-panel-body', {
		viewModel: ObjectPanelBody,
		template: '\n\t\t<section data-bind="css: {\'all-inside\': $component._allInside}" class="panel-body object-panel-body">\n\t\t\t<!-- ko if: $component._panelName === \'object\' && !!Object.getProp(ko.unwrap(data), \'.ratio\')-->\n\t\t\t\t<img data-bind="attr: {src: ko.utils.unwrapObservable(data).url, alt: \'image-\' + ko.utils.unwrapObservable(data).ratio}" alt="img" class="img img-thumbnail">\n\t\t\t<!-- /ko -->\n\t\t\t\n\t\t\t<ul data-bind="foreachprop: {data: data, sortFn: $component.sortByConfig.bind($component)}" class="list object-list">\n\t\t\t\t<li data-bind="css: {\'object\': typeof value === \'object\', \'primitive\': typeof value !== \'object\'}" class="clearfix pading item">\n\t\t\t\t\n\t\t\t\t\t<!-- ko ifnot: typeof value === \'object\' && $component._allInside -->\n\t\t\t\t\t<span data-bind="text: typeof value === \'object\' ? key: key + \':\'" class="key"></span>\n\t\t\t\t\t<!-- /ko -->\n\t\t\t\t\t\n\t\t\t\t\t<!-- ko ifnot: typeof value === \'object\' || $component._panelName === \'page\' && key === \'number\' -->\n\t\t\t\t\t\t<span data-bind="text: value" class="value"></span>\n\t\t\t\t\t<!-- /ko -->\n\t\t\t\t\t\n\t\t\t\t\t<!-- ko if: $component._panelName === \'page\' && key === \'number\'-->\n\t\t\t\t\t\t<div class="form-inline">\n\t\t\t\t\t\t\t<input id="pagination-input" data-bind="event: {keydown: $component.onEnterKeyDown.bind($component)}, attr: {placeholder: value}" type="text" pattern="[0-9]+" class="form-control">\n\t\t\t\t\t\t</div>\n\t\t\t\t\t<!-- /ko -->\n\t\t\t\t\t\n\t\t\t\t\t<!-- ko if: $component.canBeCopied.call($data, \'#prop-value-\' + key + $index()) -->\n\t\t\t\t\t\t<!-- copy property btn -->\n\t\t\t\t\t\t<button data-bind="copyToClipboard: {text: value.toString()}, attr: {id: \'prop-value-\' + key + $index()}, popover: {type: \'tooltip\', title: \'Copy value\'}" type="button" class="btn btn-icon btn-copy"></button>\n\t\t\t\t\t<!-- /ko -->\n\t\t\t\t\t\n\t\t\t\t\t<!-- ko if: typeof value === \'object\' && $component._allInside -->\n\t\t\t\t\t\t<panel params="$data: $data, $index: $index, panelGroup: $component"></panel>\n\t\t\t\t\t<!-- /ko -->\n\t\t\t\t\t<!-- ko if: typeof value === \'object\' && !$component._allInside -->\n\t\t\t\t\t\t<button data-bind="click: $component.setActive.bind($component, key, value)" type="button" class="btn btn-icon blue-shevron-right pull-right"></button>\n\t\t\t\t\t<!-- /ko -->\n\t\t\t\t</li>\n\t\t\t</ul>\n\t\t</section>\n' });
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ },
/* 156 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(157), __esModule: true };

/***/ },
/* 157 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(158);
	module.exports = __webpack_require__(15).Number.isNaN;

/***/ },
/* 158 */
/***/ function(module, exports, __webpack_require__) {

	// 20.1.2.4 Number.isNaN(number)
	var $export = __webpack_require__(13);
	
	$export($export.S, 'Number', {
	  isNaN: function isNaN(number){
	    return number != number;
	  }
	});

/***/ },
/* 159 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function($) {'use strict';
	
	var _classCallCheck2 = __webpack_require__(86);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _createClass2 = __webpack_require__(87);
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var self;
	
	var ArrayPanelBody = function () {
		function ArrayPanelBody(params) {
			(0, _classCallCheck3.default)(this, ArrayPanelBody);
	
			self = this;
			this.data = params.data.value;
			this.config = params.config;
			this._panelName = params.data.key;
			this.cardIndex = this.cardIndex || ko.utils.unwrapObservable(params.index);
			this.panelGroup = params.panelGroup;
			this.getMore = this.panelGroup.getMore;
		}
	
		(0, _createClass3.default)(ArrayPanelBody, [{
			key: 'getStartData',
			value: function getStartData($data) {
				return Object.getProp($data, 'dates.start.localDate') || '';
			}
		}, {
			key: 'getVenueName',
			value: function getVenueName($data) {
				return Object.getProp($data, '_embedded.venues[0].name') || '';
			}
		}, {
			key: 'setActive',
			value: function setActive($index, model, e) {
				$(e.currentTarget).parents('.slick-slide').find('.item.object').removeClass('active');
				$(e.currentTarget).parent('.item').addClass('active');
				this.getMore.call(null, { panel: this, id: $index, data: model });
			}
		}]);
		return ArrayPanelBody;
	}();
	
	module.exports = ko.components.register('array-panel-body', {
		viewModel: ArrayPanelBody,
		template: '\n\t\t<section class="panel-body array-panel-body">\n\t\t\t<ul data-bind="foreach: data, css: {\'events\': $component._panelName === \'events\'}" class="list list-group">\n\t\t\t\t<li data-bind="css: {\'object\': typeof $data === \'object\'}" class="list-group-item item">\n\t\t\t\t\n\t\t\t\t\t<!-- ko if: $component._panelName === \'images\' -->\n\t\t\t\t\t\t<img data-bind="attr: {src: url, alt: \'image-\' + ratio}" alt="img" class="img">\n\t\t\t\t\t\t<div class="img-info">\n\t\t\t\t\t\t\t<span class="img-ratio">Ratio: <i data-bind="text: ratio"></i></span>\n\t\t\t\t\t\t\t<span class="img-size">(<i data-bind="text: height"></i> x <i data-bind="text: width"></i>)</span>\n\t\t\t\t\t\t</div>\n\t\t\t\t\t<!-- /ko -->\n\t\t\t\t\t\n\t\t\t\t\t<!-- ko ifnot: $component._panelName === \'images\' -->\n\t\t\t\t\t\t<div class="vertical-align-center">\n\t\t\t\t\t\t\t<div class="name-wrapper">\n\t\t\t\t\t\t\t\t<span data-bind="text: name || \'#\' + $index(), blockEllipsis: {clamp: 2}" class="name"></span>\n\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\n\t\t\t\t\t\t<!-- ko if: $component._panelName === \'events\' -->\n\t\t\t\t\t\t\t<div class="additional-info">\n\t\t\t\t\t\t\t\t<p data-bind="text: $component.getStartData($data)" class="date">event date</p>\n\t\t\t\t\t\t\t\t<!-- ko if: $component.getVenueName($data)-->\n\t\t\t\t\t\t\t\t\t<p data-bind="text: $component.getVenueName($data)" class="venue truncate">event venue</p>\n\t\t\t\t\t\t\t\t<!--/ko-->\n\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t<!-- /ko -->\n\t\t\t\t\t\t\n\t\t\t\t\t<!-- /ko -->\n\t\t\t\t\t\n\t\t\t\t\t<!-- ko if: typeof $data === \'object\' -->\n\t\t\t\t\t\t<button data-bind="click: $component.setActive.bind($component, $index())" type="button" class="btn btn-icon blue-shevron-right pull-right"></button>\n\t\t\t\t\t<!-- /ko -->\n\t\t\t\t\t\n\t\t\t\t</li>\n\t\t\t</ul>\n\t\t</section>\n' });
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ },
/* 160 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	__webpack_require__(161);
	__webpack_require__(163);
	__webpack_require__(164);

/***/ },
/* 161 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function($) {'use strict';
	
	var _classCallCheck2 = __webpack_require__(86);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _createClass2 = __webpack_require__(87);
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	var _services = __webpack_require__(146);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var slider = __webpack_require__(162);
	
	var RequestListComponent = function () {
		function RequestListComponent(_ref) {
			var selectedParams = _ref.selectedParams,
			    sharePath = _ref.sharePath,
			    setParams = _ref.setParams;
			(0, _classCallCheck3.default)(this, RequestListComponent);
	
			this.url = selectedParams;
			this.sharePath = sharePath;
			this.requests = ko.observableArray([]).syncWith('REQUESTS_ARR');
			this.setParams = setParams;
			this.colors = _services.colorsService.colors;
			this.viewModel = ko.observableArray([]);
			this.clearBtnIsVisible = ko.computed(this._isVisible, this);
			this.requests.subscribe(this.updateModel, this);
		}
	
		/**
	  * Update Viewmodel of request list
	  * @param arr
	  */
	
	
		(0, _createClass3.default)(RequestListComponent, [{
			key: 'updateModel',
			value: function updateModel(arr) {
				var _this = this;
	
				var newModel = ko.unwrap(this.requests).map(function (obj) {
					var newObj = {
						color: _this.colors[obj.index % _this.colors.length],
						active: ko.observable(false),
						isActiveMoreMenu: ko.observable(false),
						copiedForShare: ko.observable(false),
						paramsAreSeted: ko.observable(false),
						copiedUrl: ko.observable(false),
						resHTML: ko.observable('')
					};
	
					// error popover
					if (obj.error) {
						var errorObj = obj.error;
						newObj.error = ko.observable([Object.getProp(errorObj, '.responseJSON.errors[0].status') || errorObj.status + '', Object.getProp(errorObj, '.responseJSON.errors[0].statusText') || '', Object.getProp(errorObj, '.responseJSON.errors[0].detail') || 'unknown', Object.getProp(errorObj, '.responseJSON') || {}]);
					}
	
					return $.extend({}, obj, newObj);
				});
				slider.remove(this.viewModel().length);
				this.viewModel(newModel);
				setTimeout(function () {
					slider.set(_this.viewModel().length);
					$('#show-details-0').trigger('click');
				}, 10);
			}
	
			/**
	   * Visibility flag for Clear btn
	   * @returns {boolean}
	   * @private
	   */
	
		}, {
			key: '_isVisible',
			value: function _isVisible() {
				return ko.utils.unwrapObservable(this.requests).length > 0;
			}
	
			/**
	   * Clear requeststs list handler
	   * @param vm
	   * @param event
	   */
	
		}, {
			key: 'onClearRequests',
			value: function onClearRequests(vm, event) {
				this.requests([]);
			}
		}]);
		return RequestListComponent;
	}();
	
	module.exports = ko.components.register('request-list', {
		viewModel: RequestListComponent,
		template: '\n\t<section class="clearfix">\n\t\t<!--ko if: clearBtnIsVisible-->\n\t\t\t<!--headline-->\n\t\t\t<section class="row-container api-exp-request-list-headline">\n\t\t\t\t<h4 class="title">Request list</h4>\n\t\t\t\t<div class="headline-edit">\n\t\t\t\t\t<button data-bind="click: onClearRequests, popover: {type: \'tooltip\', title: \'Clear requests history\'}" class="btn btn-icon btn-clear" type="button"></button>\n\t\t\t\t</div>\n\t\t\t</section>\n\n\t\t\t<!--requests-->\n\t\t\t<section>\n\t\t\t\t<ul data-bind="foreach: viewModel" class="panel-group api-exp-request-list" id="response" role="tablist" aria-multiselectable="true">\n\t\t\t\t\t<li data-bind="css: {active: active}" class="panel panel-default api-exp-request-list-item clearfix">\n\t\t\t\t\t\t<request-component params="data: $data, index: $index, sharePath: $root.sharePath, setParams: $root.setParams"></request-component>\n\t\t\t\t\t\t<response-component params="data: $data, index: $index, config: $root.config, setParams: $component.setParams"></response-component>\n\t\t\t\t\t</li>\n\t\t\t\t</ul>\n\t\t\t</section>\n\t\t<!-- /ko -->\n\t</section>\n' });
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ },
/* 162 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function($) {"use strict";
	
	var config = {
		dots: false,
		infinite: false,
		speed: 300,
		slidesToShow: 3,
		slidesToScroll: 1,
		autoplay: false,
		focusOnSelect: true,
		responsive: [{
			breakpoint: 1200,
			settings: {
				dots: true,
				slidesToShow: 2,
				slidesToScroll: 1
			}
		}, {
			breakpoint: 800,
			settings: {
				dots: true,
				slidesToShow: 1,
				slidesToScroll: 1
			}
		}]
	};
	
	function slick(times) {
		"use strict";
	
		var selector = '#slider-';
	
		for (var i = 0; i < times; i++) {
			var slider = $(selector + i);
			if (slider.length) {
				slider.slick(config);
			}
		}
	}
	
	function unslick(times) {
		"use strict";
	
		for (var i = 0; i < times; i++) {
			var slider = $('#slider-' + i);
			slider.length && slider.slick('unslick');
		}
		console.info('cleared');
	}
	
	module.exports = {
		set: slick,
		remove: unslick
	};
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ },
/* 163 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function($) {'use strict';
	
	var _stringify = __webpack_require__(99);
	
	var _stringify2 = _interopRequireDefault(_stringify);
	
	var _classCallCheck2 = __webpack_require__(86);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _createClass2 = __webpack_require__(87);
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	var _services = __webpack_require__(146);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var RequestComponent = function () {
		function RequestComponent(_ref) {
			var data = _ref.data,
			    index = _ref.index,
			    sharePath = _ref.sharePath,
			    setParams = _ref.setParams;
			(0, _classCallCheck3.default)(this, RequestComponent);
	
			var $index = ko.unwrap(index);
			this.data = data;
			this.response = data.response;
			this.hasResponse = !!data.response;
			this.req = data.req;
			this.jsonHL = _services.jsonHL;
			this.color = data.color;
			this.active = data.active;
			this.isActiveMoreMenu = data.isActiveMoreMenu;
			this.copiedForShare = data.copiedForShare;
			this.paramsAreSeted = data.paramsAreSeted;
			this.copiedUrl = data.copiedUrl;
			this.resHTML = data.resHTML;
			this.sharePath = sharePath;
			this.rootsetParams = setParams;
			this.ids = {
				wrapper: 'heading-' + $index,
				details: {
					id: 'show-details-' + $index,
					target: '#collapse-' + $index,
					controls: 'collapse-' + $index
				}
			};
		}
	
		(0, _createClass3.default)(RequestComponent, [{
			key: 'setParams',
			value: function setParams() {
				var _this = this;
	
				this.paramsAreSeted(true);
				setTimeout(function () {
					_this.paramsAreSeted(false);
				}, 200);
				this.rootsetParams(this.data);
			}
		}, {
			key: 'getMoreMenu',
			value: function getMoreMenu() {
				this.isActiveMoreMenu(!ko.unwrap(this.isActiveMoreMenu));
			}
	
			/**
	   * Details toggle handler
	   * @param model
	   * @param event
	   */
	
		}, {
			key: 'getDetails',
			value: function getDetails(model, event) {
				if (!ko.unwrap(this.resHTML).length) {
					this.jsonHL(this.resHTML, this.response);
				}
	
				var slider = $(event.currentTarget).parents('.panel').find('.slick-slider');
	
				if (!slider.find('.slick-track').width()) {
					setTimeout(function () {
						slider.slick('setPosition');
					}, 0);
				}
				this.active(!this.active());
			}
	
			/**
	   * Get raw response data
	   * @param model {object}
	   * @returns {string}
	   */
	
		}, {
			key: 'getRawData',
			value: function getRawData() {
				var model = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
	
				var content = model.response || ko.unwrap(model.data.error)[3] || {};
				var rawWindow = window.open("data:text/json," + encodeURI((0, _stringify2.default)(content, null, 2)), '_blank');
				rawWindow.focus();
			}
		}, {
			key: 'setParamsPopover',
			get: function get() {
				return {
					type: 'tooltip',
					title: 'Repeat settings of this request'
				};
			}
		}, {
			key: 'sharePathPopover',
			get: function get() {
				return {
					type: 'tooltip',
					title: 'Copy request share link'
				};
			}
		}, {
			key: 'copyUrlPopover',
			get: function get() {
				return {
					type: 'tooltip',
					title: 'Copy request URL'
				};
			}
		}, {
			key: 'getRawDataPopover',
			get: function get() {
				return {
					type: 'tooltip',
					title: 'Show raw response data'
				};
			}
		}]);
		return RequestComponent;
	}();
	
	module.exports = ko.components.register('request-component', {
		viewModel: RequestComponent,
		template: '\n\t\t<section class="row-container request" data-bind="attr: {id: ids.wrapper}" role="tab">\n\t\t\t<div class="edit-controls" data-bind="css: {\'visible white\': isActiveMoreMenu}">\n\t\t\t\t<button data-bind="click: setParams, css: {done: paramsAreSeted}, popover: setParamsPopover" class="btn btn-icon btn-preset" type="button"></button>\n\t\t\t\t<button data-bind="copyToClipboard: {text: sharePath}, popover: sharePathPopover" class="btn btn-icon btn-share" type="button"></button>\n\t\t\t\t<button data-bind="copyToClipboard: {text: req}, popover: copyUrlPopover" class="btn btn-icon btn-copy" type="button"></button>\n\t\t\t\t<button data-bind="click: getRawData, popover: getRawDataPopover" class="btn btn-icon btn-raw" type="button"></button>\n\t\t\t</div>\n\t\t\t<button data-bind="click: getMoreMenu, css: {active: isActiveMoreMenu}" class="btn btn-icon btn-more"></button>\n\t\t\t<div class="panel-title">\n\t\t\t\t<!-- ko if: hasResponse -->\n\t\t\t\t\t<button data-bind="click: getDetails, attr: {id: ids.details.id, \'data-target\': ids.details.target, \'aria-controls\': ids.details.controls}" type="button" class="btn btn-icon shevron up blue view-control" data-toggle="collapse" data-parent="#response" aria-expanded="false"></button>\n\t\t\t\t<!-- /ko -->\n\t\t\t\t<!-- ko ifnot: hasResponse -->\n\t\t\t\t\t<button data-bind="popover: {type: \'popover\', trigger: \'click\', data: data.error}" class="btn btn-icon btn-alert view-control"></button>\n\t\t\t\t<!-- /ko -->\n\t\t\t</div>\n\t\t\t<span data-bind="css: color" class="color-indicator view-control"></span>\n\t\t\t<p data-bind="text: req, blockEllipsis: {clamp: 2}" class="item_text"></p>\n\t\t</section>\n' });
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ },
/* 164 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function($) {'use strict';
	
	var _classCallCheck2 = __webpack_require__(86);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _createClass2 = __webpack_require__(87);
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	var _class, _temp, _initialiseProps;
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var ResponseComponent = (_temp = _class = function () {
		function ResponseComponent(_ref) {
			var _this = this;
	
			var data = _ref.data,
			    index = _ref.index,
			    config = _ref.config,
			    setParams = _ref.setParams,
			    getRandomColor = _ref.getRandomColor;
			(0, _classCallCheck3.default)(this, ResponseComponent);
	
			_initialiseProps.call(this);
	
			this.index = ko.unwrap(index);
			this.data = data;
			this.hasResponse = !!data.response;
			this.resHTML = data.resHTML;
			this.color = data.color;
			this.config = config;
			this.setParams = setParams;
			this.response = data.response;
			this.req = data.req;
	
			this.breadcrubsArr = [];
			this.breadcrumbs = ko.observable('');
	
			this.attrs = {
				wrapper: {
					id: 'collapse-' + this.index,
					'aria-labelledby': 'heading-' + this.index
				},
				tabs: {
					json: {
						href: '#json-' + this.index,
						'aria-controls': 'json-' + this.index
					},
					blocks: {
						href: '#slider-' + this.index,
						'aria-controls': 'blocks-' + this.index
					}
				},
				view: {
					json: {
						id: 'json-' + this.index
					},
					blocks: {
						id: 'slider-' + this.index
					}
				}
			};
	
			ko.postbox.subscribe('ANOTHER_RESPONSE', function (_ref2) {
				var data = _ref2.data,
				    panelGroup = _ref2.panelGroup,
				    color = _ref2.color;
	
				var response = panelGroup.prepareData({ params: { data: data.response } });
				_this.getMore({
					id: panelGroup.groupIndex,
					data: response,
					pGroup: panelGroup,
					color: color
				});
			});
		}
	
		/**
	  * get details
	  */
	
	
		(0, _createClass3.default)(ResponseComponent, [{
			key: 'buildBreadcrumbs',
			value: function buildBreadcrumbs(_ref3) {
				var index = _ref3.index,
				    parent = _ref3.parent,
				    current = _ref3.current;
	
				var str = index ? '/' : '';
	
				if (typeof current === 'number') {
					str += parent + '[' + current + ']';
				} else {
					str += parent + '/' + current;
				}
				this.breadcrubsArr[index] = str;
				this.breadcrubsArr.length = index + 1;
	
				this.breadcrumbs(this.breadcrubsArr.join(''));
			}
		}]);
		return ResponseComponent;
	}(), _initialiseProps = function _initialiseProps() {
		var _this2 = this;
	
		this.getMore = function (_ref4) {
			var _ref4$panel = _ref4.panel,
			    panel = _ref4$panel === undefined ? {} : _ref4$panel,
			    id = _ref4.id,
			    data = _ref4.data,
			    pGroup = _ref4.pGroup,
			    color = _ref4.color;
	
			var panelGroup = pGroup || panel.panelGroup;
			var currentSlider = $('#slider-' + panelGroup.sectionIndex);
			var component = $('<section data-bind="component: {name: \'panel-group\', params: params}"></section>');
			var curslick = currentSlider.slick('getSlick');
	
			// extending additional data (copy)
			var params = $.extend({}, panelGroup, {
				data: data,
				groupIndex: panelGroup.groupIndex + 1,
				_propTitle: typeof id === 'string' && id || 'object',
				config: panel.config,
				colorClass: color
			});
	
			// apply component data bindings
			ko.applyBindings({
				params: params
			}, component[0]);
	
			// build breadcrubs
			_this2.buildBreadcrumbs({ index: panelGroup.groupIndex, parent: panel._panelName, current: id });
	
			// add slide with selected data
			currentSlider.slick('slickAdd', component);
			// remove outstanding slides
			for (var i = curslick.slideCount - 2; i > panelGroup.groupIndex; i--) {
				currentSlider.slick('slickRemove', i, false);
			}
			// move to next slide
			setTimeout(function () {
				currentSlider.slick('slickNext');
			}, 310);
		};
	}, _temp);
	
	
	module.exports = ko.components.register('response-component', {
		viewModel: ResponseComponent,
		template: '\n\t\t<!-- ko if: hasResponse -->\n\t\t<section class="response collapse" data-bind="attr: attrs.wrapper" role="tabpanel">\n\t\t\t\t<div class="row-container">\n\t\t\t\t\n\t\t\t\t\t<!-- Nav tabs -->\n\t\t\t\t\t<ul class="nav nav-tabs tabs-controlls" role="tablist">\n\t\t\t\t\t\t<li role="presentation" class="tab">\n\t\t\t\t\t\t\t<a data-bind="attr: attrs.tabs.json" class="tab-btn" href="#json" aria-controls="json" role="tab" data-toggle="tab">Json</a>\n\t\t\t\t\t\t</li>\n\t\t\t\t\t\t<li role="presentation" class="tab active">\n\t\t\t\t\t\t\t<a data-bind="attr: attrs.tabs.blocks" class="tab-btn" href="#blocks" aria-controls="blocks" role="tab" data-toggle="tab">Blocks</a>\n\t\t\t\t\t\t</li>\n\t\t\t\t\t</ul>\n\t\t\t\t\t\n\t\t\t\t\t<ul class="nav nav-tabs info">\n\t\t\t\t\t\t<li class="tab">\n\t\t\t\t\t\t\t<div class="tab-label">\n\t\t\t\t\t\t\t\t<span data-bind="visible: breadcrumbs">Structure:</span>\n\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t</li>\n\t\t\t\t\t\t<li class="tab">\n\t\t\t\t\t\t\t<span data-bind="text: breadcrumbs" class="tab-label breadcrumbs truncate"></span>\n\t\t\t\t\t\t</li>\n\t\t\t\t\t</ul>\n\n\t\t\t\t\t<!-- Tab panes -->\n\t\t\t\t\t<div class="row">\n\t\t\t\t\t\t<div class="tab-content col-xs-12">\n\t\t\t\t\t\t\t<!-- json -->\n\t\t\t\t\t\t\t<div data-bind="scroll: {x: false, y: true}, attr: attrs.view.json" role="tabpanel" class="tab-pane prety-json" id="json">\n\t\t\t\t\t\t\t\t<p data-bind="html: resHTML"></p>\n\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t<!-- blocks -->\n\t\t\t\t\t\t\t<div data-bind="attr: attrs.view.blocks" role="tabpanel" class="tab-pane blocks active" id="blocks">\n\t\t\t\t\t\t\t\t<panel-group params="\n\t\t\t\t\t\t\t\t\tcategory: data.category,\n\t\t\t\t\t\t\t\t\tmethod: data.method,\n\t\t\t\t\t\t\t\t\tmethodId: data.methodId,\n\t\t\t\t\t\t\t\t\tparams: data.params,\n\t\t\t\t\t\t\t\t\tdata: data.response,\n\t\t\t\t\t\t\t\t\tcolorClass: data.color,\n\t\t\t\t\t\t\t\t\tsectionIndex: index,\n\t\t\t\t\t\t\t\t\tfilter: config,\n\t\t\t\t\t\t\t\t\tsetParams: setParams,\n\t\t\t\t\t\t\t\t\tgetMore: getMore\n\t\t\t\t\t\t\t\t\t">\n\t\t\t\t\t\t\t\t</panel-group>\n\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t</div>\n\t\t\t\t\t</div>\n\t\t\t\t</div>\n\t\t</section>\n\t\t<!-- /ko -->\t\n' });
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ }
/******/ ]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAgMWQxZGZlMmVhNTk1NTZlY2ZjNDAiLCJ3ZWJwYWNrOi8vLy4vc2NyaXB0cy9hcGktZXhwbG9yZXIvdjIvc3JjL21haW4uZXM2LmpzIiwid2VicGFjazovLy8uL3NjcmlwdHMvdmVuZG9ycy9qcXVlcnktMS4xMS4zLm1pbi5qcyIsIndlYnBhY2s6Ly8vKHdlYnBhY2spL2J1aWxkaW4vbW9kdWxlLmpzIiwid2VicGFjazovLy8uL34vYmFiZWwtcnVudGltZS9oZWxwZXJzL3R5cGVvZi5qcyIsIndlYnBhY2s6Ly8vLi9+L2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9zeW1ib2wvaXRlcmF0b3IuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvZm4vc3ltYm9sL2l0ZXJhdG9yLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM2LnN0cmluZy5pdGVyYXRvci5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19zdHJpbmctYXQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fdG8taW50ZWdlci5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19kZWZpbmVkLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2l0ZXItZGVmaW5lLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2xpYnJhcnkuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZXhwb3J0LmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2dsb2JhbC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19jb3JlLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2N0eC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19hLWZ1bmN0aW9uLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2hpZGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LWRwLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2FuLW9iamVjdC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19pcy1vYmplY3QuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faWU4LWRvbS1kZWZpbmUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZGVzY3JpcHRvcnMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZmFpbHMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZG9tLWNyZWF0ZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL190by1wcmltaXRpdmUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fcHJvcGVydHktZGVzYy5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19yZWRlZmluZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19oYXMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faXRlcmF0b3JzLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2l0ZXItY3JlYXRlLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1jcmVhdGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LWRwcy5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3Qta2V5cy5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3Qta2V5cy1pbnRlcm5hbC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL190by1pb2JqZWN0LmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2lvYmplY3QuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fY29mLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2FycmF5LWluY2x1ZGVzLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3RvLWxlbmd0aC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL190by1pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19zaGFyZWQta2V5LmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3NoYXJlZC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL191aWQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZW51bS1idWcta2V5cy5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19odG1sLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3NldC10by1zdHJpbmctdGFnLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3drcy5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3QtZ3BvLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3RvLW9iamVjdC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL3dlYi5kb20uaXRlcmFibGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczYuYXJyYXkuaXRlcmF0b3IuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fYWRkLXRvLXVuc2NvcGFibGVzLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2l0ZXItc3RlcC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL193a3MtZXh0LmpzIiwid2VicGFjazovLy8uL34vYmFiZWwtcnVudGltZS9jb3JlLWpzL3N5bWJvbC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9mbi9zeW1ib2wvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczYuc3ltYm9sLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX21ldGEuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fd2tzLWRlZmluZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19rZXlvZi5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19lbnVtLWtleXMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LWdvcHMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LXBpZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19pcy1hcnJheS5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3QtZ29wbi1leHQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LWdvcG4uanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LWdvcGQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczcuc3ltYm9sLmFzeW5jLWl0ZXJhdG9yLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM3LnN5bWJvbC5vYnNlcnZhYmxlLmpzIiwid2VicGFjazovLy8od2VicGFjaykvYnVpbGRpbi9hbWQtb3B0aW9ucy5qcyIsIndlYnBhY2s6Ly8vLi9+L2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9vYmplY3Qva2V5cy5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9mbi9vYmplY3Qva2V5cy5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNi5vYmplY3Qua2V5cy5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3Qtc2FwLmpzIiwid2VicGFjazovLy8uL34vYmFiZWwtcnVudGltZS9oZWxwZXJzL3NsaWNlZFRvQXJyYXkuanMiLCJ3ZWJwYWNrOi8vLy4vfi9iYWJlbC1ydW50aW1lL2NvcmUtanMvaXMtaXRlcmFibGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvZm4vaXMtaXRlcmFibGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9jb3JlLmlzLWl0ZXJhYmxlLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2NsYXNzb2YuanMiLCJ3ZWJwYWNrOi8vLy4vfi9iYWJlbC1ydW50aW1lL2NvcmUtanMvZ2V0LWl0ZXJhdG9yLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L2ZuL2dldC1pdGVyYXRvci5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2NvcmUuZ2V0LWl0ZXJhdG9yLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvY29yZS5nZXQtaXRlcmF0b3ItbWV0aG9kLmpzIiwid2VicGFjazovLy8uL34vYmFiZWwtcnVudGltZS9oZWxwZXJzL2NsYXNzQ2FsbENoZWNrLmpzIiwid2VicGFjazovLy8uL34vYmFiZWwtcnVudGltZS9oZWxwZXJzL2NyZWF0ZUNsYXNzLmpzIiwid2VicGFjazovLy8uL34vYmFiZWwtcnVudGltZS9jb3JlLWpzL29iamVjdC9kZWZpbmUtcHJvcGVydHkuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvZm4vb2JqZWN0L2RlZmluZS1wcm9wZXJ0eS5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNi5vYmplY3QuZGVmaW5lLXByb3BlcnR5LmpzIiwid2VicGFjazovLy8uL3NjcmlwdHMvYXBpLWV4cGxvcmVyL3YyL3NyYy9tb2R1bGVzL2luZGV4LmpzIiwid2VicGFjazovLy8uL3NjcmlwdHMvdmVuZG9ycy9qcXVlcnktbWlncmF0ZS0xLjMuMC5taW4uanMiLCJ3ZWJwYWNrOi8vLy4vfi9rbm9ja291dC9idWlsZC9vdXRwdXQva25vY2tvdXQtbGF0ZXN0LmRlYnVnLmpzPzYwODMiLCJ3ZWJwYWNrOi8vLy4vfi9rbm9ja291dC9idWlsZC9vdXRwdXQva25vY2tvdXQtbGF0ZXN0LmRlYnVnLmpzIiwid2VicGFjazovLy8od2VicGFjaykvYnVpbGRpbi9hbWQtZGVmaW5lLmpzIiwid2VicGFjazovLy8uL34vanN0cmVlL2Rpc3QvanN0cmVlLmpzIiwid2VicGFjazovLy8uL3NjcmlwdHMvY29tcG9uZW50cy9sYXp5LXNlbGVjdG9yLmpzIiwid2VicGFjazovLy8uL3NjcmlwdHMvY29tcG9uZW50cy9jbGFzc2lmaWNhdGlvbi1zZWxlY3Rvci5qcyIsIndlYnBhY2s6Ly8vLi9+L2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9qc29uL3N0cmluZ2lmeS5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9mbi9qc29uL3N0cmluZ2lmeS5qcyIsIndlYnBhY2s6Ly8vLi9zY3JpcHRzL3ZlbmRvcnMvYm9vdHN0cmFwLm1pbi5qcyIsIndlYnBhY2s6Ly8vLi9zY3JpcHRzL2FwaS1leHBsb3Jlci92Mi9zcmMvbW9kdWxlcy92YWxpZGF0aW9uLmpzIiwid2VicGFjazovLy8uL34va25vY2tvdXQudmFsaWRhdGlvbi9kaXN0L2tub2Nrb3V0LnZhbGlkYXRpb24uanMiLCJ3ZWJwYWNrOi8vLy4vc2NyaXB0cy92ZW5kb3JzL3NsaWNrLm1pbi5qcyIsIndlYnBhY2s6Ly8vLi9zY3JpcHRzL3ZlbmRvcnMva25vY2tvdXQtc2Nyb2xsYmFyLmpzIiwid2VicGFjazovLy8uL34vYmFiZWwtcnVudGltZS9jb3JlLWpzL29iamVjdC9hc3NpZ24uanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvZm4vb2JqZWN0L2Fzc2lnbi5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNi5vYmplY3QuYXNzaWduLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1hc3NpZ24uanMiLCJ3ZWJwYWNrOi8vLy4vc2NyaXB0cy92ZW5kb3JzL2NsaXBib2FyZC5qcz81ZGQ2Iiwid2VicGFjazovLy8uL3NjcmlwdHMvdmVuZG9ycy9jbGlwYm9hcmQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9iYWJlbC1ydW50aW1lL2NvcmUtanMvb2JqZWN0L3NldC1wcm90b3R5cGUtb2YuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvZm4vb2JqZWN0L3NldC1wcm90b3R5cGUtb2YuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczYub2JqZWN0LnNldC1wcm90b3R5cGUtb2YuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fc2V0LXByb3RvLmpzIiwid2VicGFjazovLy8uL34vYmFiZWwtcnVudGltZS9jb3JlLWpzL29iamVjdC9jcmVhdGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvZm4vb2JqZWN0L2NyZWF0ZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNi5vYmplY3QuY3JlYXRlLmpzIiwid2VicGFjazovLy8uL3NjcmlwdHMvdmVuZG9ycy9jbGFtcC5taW4uanMiLCJ3ZWJwYWNrOi8vLy4vfi9rbm9ja291dC1wb3N0Ym94L2J1aWxkL2tub2Nrb3V0LXBvc3Rib3guanMiLCJ3ZWJwYWNrOi8vLy4vc2NyaXB0cy92ZW5kb3JzL2RhdGV0aW1lcGlja2VyLmpzIiwid2VicGFjazovLy8uL3NjcmlwdHMvYXBpLWV4cGxvcmVyL3YyL3NyYy9jdXN0b21CaW5kaW5ncy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9zY3JpcHRzL2FwaS1leHBsb3Jlci92Mi9zcmMvY3VzdG9tQmluZGluZ3MvYmxvY2tFbGxpcHNpcy5iaW5kaW5nLmpzIiwid2VicGFjazovLy8uL3NjcmlwdHMvYXBpLWV4cGxvcmVyL3YyL3NyYy9jdXN0b21CaW5kaW5ncy9mb3JlYWNoUHJvcC5iaW5kaW5nLmpzIiwid2VicGFjazovLy8uL3NjcmlwdHMvYXBpLWV4cGxvcmVyL3YyL3NyYy9jdXN0b21CaW5kaW5ncy9wb3BvdmVyLmJpbmRpbmcuanMiLCJ3ZWJwYWNrOi8vLy4vc2NyaXB0cy9hcGktZXhwbG9yZXIvdjIvc3JjL2N1c3RvbUJpbmRpbmdzL2NvcHlDbGlwYm9hcmQuYmluZGluZy5qcyIsIndlYnBhY2s6Ly8vLi9zY3JpcHRzL2FwaS1leHBsb3Jlci92Mi9zcmMvY3VzdG9tQmluZGluZ3MvbGF6eUxvYWRlci5iaW5kaW5nLmpzIiwid2VicGFjazovLy8uL3NjcmlwdHMvYXBpLWV4cGxvcmVyL3YyL3NyYy9jdXN0b21CaW5kaW5ncy9jbGFzc2lmaWNhdGlvbnNNYXAuYmluZGluZy5qcyIsIndlYnBhY2s6Ly8vLi9zY3JpcHRzL2FwaS1leHBsb3Jlci92Mi9zcmMvY29tcG9uZW50cy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9zY3JpcHRzL2FwaS1leHBsb3Jlci92Mi9zcmMvY29tcG9uZW50cy9jb21tb24vaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vc2NyaXB0cy9hcGktZXhwbG9yZXIvdjIvc3JjL2NvbXBvbmVudHMvY29tbW9uL2N1c3RvbVNlbGVjdC5jb21wb25lbnQuanMiLCJ3ZWJwYWNrOi8vLy4vc2NyaXB0cy9hcGktZXhwbG9yZXIvdjIvc3JjL2NvbXBvbmVudHMvY29tbW9uL2N1c3RvbUlucHV0LmNvbXBvbmVudC5qcyIsIndlYnBhY2s6Ly8vLi9zY3JpcHRzL2FwaS1leHBsb3Jlci92Mi9zcmMvY29tcG9uZW50cy9maWx0ZXIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vc2NyaXB0cy9hcGktZXhwbG9yZXIvdjIvc3JjL2NvbXBvbmVudHMvZmlsdGVyL2Fib3V0TWV0aG9kLmNvbXBvbmVudC5qcyIsIndlYnBhY2s6Ly8vLi9zY3JpcHRzL2FwaS1leHBsb3Jlci92Mi9zcmMvY29tcG9uZW50cy9maWx0ZXIvY2F0ZWdvcnlNZW51LmNvbXBvbmVudC5qcyIsIndlYnBhY2s6Ly8vLi9zY3JpcHRzL2FwaS1leHBsb3Jlci92Mi9zcmMvY29tcG9uZW50cy9maWx0ZXIvbWV0aG9kc0ZpbHRlci5jb21wb25lbnQuanMiLCJ3ZWJwYWNrOi8vLy4vc2NyaXB0cy9hcGktZXhwbG9yZXIvdjIvc3JjL2NvbXBvbmVudHMvZmlsdGVyL3JhZGlvRmlsdGVyLmNvbXBvbmVudC5qcyIsIndlYnBhY2s6Ly8vLi9zY3JpcHRzL2FwaS1leHBsb3Jlci92Mi9zcmMvY29tcG9uZW50cy9maWx0ZXIvcGFyYW1zRmlsdGVyLmNvbXBvbmVudC5qcyIsIndlYnBhY2s6Ly8vLi9zY3JpcHRzL2FwaS1leHBsb3Jlci92Mi9zcmMvY29tcG9uZW50cy9wb3B1cHMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vc2NyaXB0cy9hcGktZXhwbG9yZXIvdjIvc3JjL2NvbXBvbmVudHMvcG9wdXBzL2Vycm9yLmNvbXBvbmVudC5qcyIsIndlYnBhY2s6Ly8vLi9zY3JpcHRzL2FwaS1leHBsb3Jlci92Mi9zcmMvY29tcG9uZW50cy9wYW5lbHMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vc2NyaXB0cy9hcGktZXhwbG9yZXIvdjIvc3JjL2NvbXBvbmVudHMvcGFuZWxzL3BhbmVsR3JvdXAuY29tcG9uZW50LmpzIiwid2VicGFjazovLy8uL3NjcmlwdHMvYXBpLWV4cGxvcmVyL3YyL3NyYy9jb21wb25lbnRzL3BhbmVscy9wYW5lbC5jb21wb25lbnQuanMiLCJ3ZWJwYWNrOi8vLy4vc2NyaXB0cy9hcGktZXhwbG9yZXIvdjIvc3JjL2NvbXBvbmVudHMvcGFuZWxzL3BhZ2luYXRpb24uY29tcG9uZW50LmpzIiwid2VicGFjazovLy8uL3NjcmlwdHMvYXBpLWV4cGxvcmVyL3YyL3NyYy9jb21wb25lbnRzL3BhbmVscy9wYW5lbEhlYWRpbmcuY29tcG9uZW50LmpzIiwid2VicGFjazovLy8uL3NjcmlwdHMvYXBpLWV4cGxvcmVyL3YyL3NyYy9zZXJ2aWNlcy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9zY3JpcHRzL2FwaS1leHBsb3Jlci92Mi9zcmMvc2VydmljZXMvYmFzZS5zZXJ2aWNlLmpzIiwid2VicGFjazovLy8uL3NjcmlwdHMvYXBpLWV4cGxvcmVyL3YyL3NyYy9zZXJ2aWNlcy9hcGlLZXkuc2VydmljZS5qcyIsIndlYnBhY2s6Ly8vLi9zY3JpcHRzL2FwaS1leHBsb3Jlci92Mi9zcmMvc2VydmljZXMvY29uZmlnLnNlcnZpY2UuanMiLCJ3ZWJwYWNrOi8vLy4vc2NyaXB0cy9hcGktZXhwbG9yZXIvdjIvc3JjL3NlcnZpY2VzL2pzb24taGlnaGxpZ2h0L2luZGV4LmpzIiwid2VicGFjazovLy8uL3NjcmlwdHMvYXBpLWV4cGxvcmVyL3YyL3NyYy9zZXJ2aWNlcy9qc29uLWhpZ2hsaWdodC9oaWdobGlnaHRKc29uLndvcmtlci5qcyIsIndlYnBhY2s6Ly8vLi9+L3dvcmtlci1sb2FkZXIvY3JlYXRlSW5saW5lV29ya2VyLmpzIiwid2VicGFjazovLy8uL3NjcmlwdHMvYXBpLWV4cGxvcmVyL3YyL3NyYy9zZXJ2aWNlcy9jb2xvcnMuc2VydmljZS5qcyIsIndlYnBhY2s6Ly8vLi9zY3JpcHRzL2FwaS1leHBsb3Jlci92Mi9zcmMvc2VydmljZXMvcmVzdC5zZXJ2aWNlLmpzIiwid2VicGFjazovLy8uL3NjcmlwdHMvYXBpLWV4cGxvcmVyL3YyL3NyYy9jb21wb25lbnRzL3BhbmVscy9vYmplY3RQYW5lbEJvZHkuY29tcG9uZW50LmpzIiwid2VicGFjazovLy8uL34vYmFiZWwtcnVudGltZS9jb3JlLWpzL251bWJlci9pcy1uYW4uanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvZm4vbnVtYmVyL2lzLW5hbi5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNi5udW1iZXIuaXMtbmFuLmpzIiwid2VicGFjazovLy8uL3NjcmlwdHMvYXBpLWV4cGxvcmVyL3YyL3NyYy9jb21wb25lbnRzL3BhbmVscy9hcnJheVBhbmVsQm9keS5jb21wb25lbnQuanMiLCJ3ZWJwYWNrOi8vLy4vc2NyaXB0cy9hcGktZXhwbG9yZXIvdjIvc3JjL2NvbXBvbmVudHMvcmVxdWVzdC9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9zY3JpcHRzL2FwaS1leHBsb3Jlci92Mi9zcmMvY29tcG9uZW50cy9yZXF1ZXN0L3JlcXVlc3RMaXN0LmNvbXBvbmVudC5qcyIsIndlYnBhY2s6Ly8vLi9zY3JpcHRzL2FwaS1leHBsb3Jlci92Mi9zcmMvbW9kdWxlcy9zbGlkZXIuanMiLCJ3ZWJwYWNrOi8vLy4vc2NyaXB0cy9hcGktZXhwbG9yZXIvdjIvc3JjL2NvbXBvbmVudHMvcmVxdWVzdC9yZXF1ZXN0LmNvbXBvbmVudC5qcyIsIndlYnBhY2s6Ly8vLi9zY3JpcHRzL2FwaS1leHBsb3Jlci92Mi9zcmMvY29tcG9uZW50cy9yZXF1ZXN0L3Jlc3BvbnNlLmNvbXBvbmVudC5qcyJdLCJuYW1lcyI6WyJtb2R1bGVzIiwiY3VzdG9tQmluZGluZ3MiLCJjb21wb25lbnRzIiwic2VydmljZXMiLCJPYmplY3QiLCJnZXRQcm9wIiwibyIsInMiLCJyZXBsYWNlIiwiYSIsInNwbGl0IiwiaSIsIm4iLCJsZW5ndGgiLCJrIiwiQXBwVmlld01vZGVsIiwiYmFzZSIsImFwaUtleSIsImNvbmZpZyIsInJlc3QiLCJzZXRQYXJhbXMiLCJjYXRlZ29yeSIsIm1ldGhvZCIsIm1ldGhvZElkIiwicGFyYW1zIiwic2VsZWN0ZWRDYXRlZ29yeSIsInNlbGVjdGVkTWV0aG9kVHlwZSIsInNlbGVjdGVkTWV0aG9kIiwic2VsZWN0ZWRQYXJhbXMiLCJub3RpZnlTdWJzY3JpYmVycyIsInJlc3RTZXJ2aWNlIiwicGFyc2VkVXJsIiwicGFyc2VVcmwiLCJrbyIsIm9ic2VydmFibGUiLCJhcGlDYXRlZ29yeSIsInN5bmNXaXRoIiwib2JzZXJ2YWJsZUFycmF5Iiwic2VsZWN0ZWRNZXRob2REYXRhIiwiZ2V0TWV0aG9kRGF0YSIsImluaXRWYWxpZGF0aW9uIiwic2VuZEJ1dHRvblRleHQiLCJwdXJlQ29tcHV0ZWQiLCJ1bndyYXAiLCJzaGFyZVBhdGgiLCJmb3JtRGVlcExpbmtpbmdVcmwiLCJzdWJzY3JpYmUiLCJ2YWxpZGF0aW9uTW9kZWwiLCIkIiwiZXh0ZW5kIiwiYXBpS2V5VmFsaWRhdGlvbk1vZGVsIiwidmFsIiwic2VuZEJ0blZhbGlkYXRpb25UZXh0IiwiZm9ybUlzVmFsaWQiLCJjb21wdXRlZCIsInZhbGlkYXRlZE9ic2VydmFibGUiLCJ2YWxpZGF0aW9uRmxhZyIsImlzVmFsaWQiLCJ2YWxpZGF0aW9uVGV4dCIsIm1vZGVsIiwic2VuZFJlcXVlc3QiLCJlcnJvcnMiLCJzaG93QWxsTWVzc2FnZXMiLCJsb2NhdGlvbiIsIndpbmRvdyIsInF1ZXJ5cyIsImVuY29kZVVSSSIsIm1hcCIsInZhbHVlIiwicGFyYW0iLCJkZWZhdWx0VmFsdWUiLCJkZWZhdWx0IiwicHVzaCIsIm5hbWUiLCJvcmlnaW4iLCJwYXRobmFtZSIsImpvaW4iLCJ0eXBlIiwibWV0aG9kVHlwZSIsInNlYXJjaCIsIm9iaiIsInBhcmFtZXRlcnMiLCJnbG9iYWxRdWVyeU9iaiIsInF1ZXJ5IiwiZGVjb2RlVVJJIiwia2V5IiwiaW5kZXhPZiIsIkpTT04iLCJwYXJzZSIsImV4Y2VwdGlvbl92YXIiLCJtZXRob2REYXRhIiwiYXBwbHlCaW5kaW5ncyIsIm1vZHVsZSIsImV4cG9ydHMiLCJiIiwiZG9jdW1lbnQiLCJFcnJvciIsImMiLCJkIiwic2xpY2UiLCJlIiwiY29uY2F0IiwiZiIsImciLCJoIiwidG9TdHJpbmciLCJqIiwiaGFzT3duUHJvcGVydHkiLCJsIiwibSIsImZuIiwiaW5pdCIsInAiLCJxIiwidG9VcHBlckNhc2UiLCJwcm90b3R5cGUiLCJqcXVlcnkiLCJjb25zdHJ1Y3RvciIsInNlbGVjdG9yIiwidG9BcnJheSIsImNhbGwiLCJnZXQiLCJwdXNoU3RhY2siLCJtZXJnZSIsInByZXZPYmplY3QiLCJjb250ZXh0IiwiZWFjaCIsImFwcGx5IiwiYXJndW1lbnRzIiwiZmlyc3QiLCJlcSIsImxhc3QiLCJlbmQiLCJzb3J0Iiwic3BsaWNlIiwiaXNGdW5jdGlvbiIsImlzUGxhaW5PYmplY3QiLCJpc0FycmF5IiwiZXhwYW5kbyIsIk1hdGgiLCJyYW5kb20iLCJpc1JlYWR5IiwiZXJyb3IiLCJub29wIiwiQXJyYXkiLCJpc1dpbmRvdyIsImlzTnVtZXJpYyIsInBhcnNlRmxvYXQiLCJpc0VtcHR5T2JqZWN0Iiwibm9kZVR5cGUiLCJvd25MYXN0IiwiZ2xvYmFsRXZhbCIsInRyaW0iLCJleGVjU2NyaXB0IiwiZXZhbCIsImNhbWVsQ2FzZSIsIm5vZGVOYW1lIiwidG9Mb3dlckNhc2UiLCJyIiwibWFrZUFycmF5IiwiaW5BcnJheSIsIm1heCIsImdyZXAiLCJndWlkIiwicHJveHkiLCJub3ciLCJEYXRlIiwic3VwcG9ydCIsInQiLCJ1IiwidiIsInciLCJ4IiwieSIsImhhIiwieiIsIkEiLCJCIiwiQyIsIkQiLCJFIiwiRiIsInBvcCIsIkciLCJIIiwiSSIsIkoiLCJLIiwiTCIsIk0iLCJOIiwiTyIsIlAiLCJRIiwiUmVnRXhwIiwiUiIsIlMiLCJUIiwiVSIsIlYiLCJXIiwiWCIsIklEIiwiQ0xBU1MiLCJUQUciLCJBVFRSIiwiUFNFVURPIiwiQ0hJTEQiLCJib29sIiwibmVlZHNDb250ZXh0IiwiWSIsIloiLCJfIiwiYWEiLCJiYSIsImNhIiwiZGEiLCJTdHJpbmciLCJmcm9tQ2hhckNvZGUiLCJlYSIsImNoaWxkTm9kZXMiLCJmYSIsImdhIiwib3duZXJEb2N1bWVudCIsImV4ZWMiLCJnZXRFbGVtZW50QnlJZCIsInBhcmVudE5vZGUiLCJpZCIsImdldEVsZW1lbnRzQnlUYWdOYW1lIiwiZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSIsInFzYSIsInRlc3QiLCJnZXRBdHRyaWJ1dGUiLCJzZXRBdHRyaWJ1dGUiLCJyYSIsInBhIiwicXVlcnlTZWxlY3RvckFsbCIsInJlbW92ZUF0dHJpYnV0ZSIsImNhY2hlTGVuZ3RoIiwic2hpZnQiLCJpYSIsImphIiwiY3JlYXRlRWxlbWVudCIsInJlbW92ZUNoaWxkIiwia2EiLCJhdHRySGFuZGxlIiwibGEiLCJzb3VyY2VJbmRleCIsIm5leHRTaWJsaW5nIiwibWEiLCJuYSIsIm9hIiwiaXNYTUwiLCJkb2N1bWVudEVsZW1lbnQiLCJzZXREb2N1bWVudCIsImRlZmF1bHRWaWV3IiwidG9wIiwiYWRkRXZlbnRMaXN0ZW5lciIsImF0dGFjaEV2ZW50IiwiYXR0cmlidXRlcyIsImNsYXNzTmFtZSIsImFwcGVuZENoaWxkIiwiY3JlYXRlQ29tbWVudCIsImdldEJ5SWQiLCJnZXRFbGVtZW50c0J5TmFtZSIsImZpbmQiLCJmaWx0ZXIiLCJnZXRBdHRyaWJ1dGVOb2RlIiwiaW5uZXJIVE1MIiwibWF0Y2hlc1NlbGVjdG9yIiwibWF0Y2hlcyIsIndlYmtpdE1hdGNoZXNTZWxlY3RvciIsIm1vek1hdGNoZXNTZWxlY3RvciIsIm9NYXRjaGVzU2VsZWN0b3IiLCJtc01hdGNoZXNTZWxlY3RvciIsImRpc2Nvbm5lY3RlZE1hdGNoIiwiY29tcGFyZURvY3VtZW50UG9zaXRpb24iLCJjb250YWlucyIsInNvcnREZXRhY2hlZCIsInVuc2hpZnQiLCJhdHRyIiwic3BlY2lmaWVkIiwidW5pcXVlU29ydCIsImRldGVjdER1cGxpY2F0ZXMiLCJzb3J0U3RhYmxlIiwiZ2V0VGV4dCIsInRleHRDb250ZW50IiwiZmlyc3RDaGlsZCIsIm5vZGVWYWx1ZSIsInNlbGVjdG9ycyIsImNyZWF0ZVBzZXVkbyIsIm1hdGNoIiwicmVsYXRpdmUiLCJkaXIiLCJwcmVGaWx0ZXIiLCJsYXN0Q2hpbGQiLCJwc2V1ZG9zIiwic2V0RmlsdGVycyIsIm5vdCIsImhhcyIsImlubmVyVGV4dCIsImxhbmciLCJ0YXJnZXQiLCJoYXNoIiwicm9vdCIsImZvY3VzIiwiYWN0aXZlRWxlbWVudCIsImhhc0ZvY3VzIiwiaHJlZiIsInRhYkluZGV4IiwiZW5hYmxlZCIsImRpc2FibGVkIiwiY2hlY2tlZCIsInNlbGVjdGVkIiwic2VsZWN0ZWRJbmRleCIsImVtcHR5IiwicGFyZW50IiwiaGVhZGVyIiwiaW5wdXQiLCJidXR0b24iLCJ0ZXh0IiwiZXZlbiIsIm9kZCIsImx0IiwiZ3QiLCJudGgiLCJyYWRpbyIsImNoZWNrYm94IiwiZmlsZSIsInBhc3N3b3JkIiwiaW1hZ2UiLCJzdWJtaXQiLCJyZXNldCIsInFhIiwiZmlsdGVycyIsInRva2VuaXplIiwic2EiLCJ0YSIsInVhIiwidmEiLCJ3YSIsInhhIiwieWEiLCJjb21waWxlIiwic2VsZWN0IiwiZXhwciIsInVuaXF1ZSIsImlzWE1MRG9jIiwiaXMiLCJjaGFyQXQiLCJwYXJzZUhUTUwiLCJyZWFkeSIsImNoaWxkcmVuIiwiY29udGVudHMiLCJuZXh0IiwicHJldiIsInNpYmxpbmciLCJjbG9zZXN0IiwiaW5kZXgiLCJwcmV2QWxsIiwiYWRkIiwiYWRkQmFjayIsInBhcmVudHMiLCJwYXJlbnRzVW50aWwiLCJuZXh0QWxsIiwibmV4dFVudGlsIiwicHJldlVudGlsIiwic2libGluZ3MiLCJjb250ZW50RG9jdW1lbnQiLCJjb250ZW50V2luZG93IiwicmV2ZXJzZSIsIkNhbGxiYWNrcyIsIm9uY2UiLCJtZW1vcnkiLCJzdG9wT25GYWxzZSIsImRpc2FibGUiLCJyZW1vdmUiLCJsb2NrIiwibG9ja2VkIiwiZmlyZVdpdGgiLCJmaXJlIiwiZmlyZWQiLCJEZWZlcnJlZCIsInN0YXRlIiwiYWx3YXlzIiwiZG9uZSIsImZhaWwiLCJ0aGVuIiwicHJvbWlzZSIsInJlc29sdmUiLCJyZWplY3QiLCJwcm9ncmVzcyIsIm5vdGlmeSIsInBpcGUiLCJ3aGVuIiwibm90aWZ5V2l0aCIsInJlc29sdmVXaXRoIiwicmVhZHlXYWl0IiwiaG9sZFJlYWR5IiwiYm9keSIsInNldFRpbWVvdXQiLCJ0cmlnZ2VySGFuZGxlciIsIm9mZiIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJkZXRhY2hFdmVudCIsImV2ZW50IiwicmVhZHlTdGF0ZSIsImZyYW1lRWxlbWVudCIsImRvU2Nyb2xsIiwiaW5saW5lQmxvY2tOZWVkc0xheW91dCIsInN0eWxlIiwiY3NzVGV4dCIsInpvb20iLCJvZmZzZXRXaWR0aCIsImRlbGV0ZUV4cGFuZG8iLCJhY2NlcHREYXRhIiwibm9EYXRhIiwicGFyc2VKU09OIiwiZGF0YSIsImNhY2hlIiwidG9KU09OIiwiY2xlYW5EYXRhIiwiaGFzRGF0YSIsInJlbW92ZURhdGEiLCJfZGF0YSIsIl9yZW1vdmVEYXRhIiwicXVldWUiLCJkZXF1ZXVlIiwiX3F1ZXVlSG9va3MiLCJzdG9wIiwiY2xlYXJRdWV1ZSIsInNvdXJjZSIsImNzcyIsImFjY2VzcyIsImNyZWF0ZURvY3VtZW50RnJhZ21lbnQiLCJsZWFkaW5nV2hpdGVzcGFjZSIsInRib2R5IiwiaHRtbFNlcmlhbGl6ZSIsImh0bWw1Q2xvbmUiLCJjbG9uZU5vZGUiLCJvdXRlckhUTUwiLCJhcHBlbmRDaGVja2VkIiwibm9DbG9uZUNoZWNrZWQiLCJjaGVja0Nsb25lIiwibm9DbG9uZUV2ZW50IiwiY2xpY2siLCJjaGFuZ2UiLCJmb2N1c2luIiwiZ2xvYmFsIiwiaGFuZGxlciIsImV2ZW50cyIsImhhbmRsZSIsInRyaWdnZXJlZCIsImRpc3BhdGNoIiwiZWxlbSIsInNwZWNpYWwiLCJkZWxlZ2F0ZVR5cGUiLCJiaW5kVHlwZSIsIm9yaWdUeXBlIiwibmFtZXNwYWNlIiwiZGVsZWdhdGVDb3VudCIsInNldHVwIiwidGVhcmRvd24iLCJyZW1vdmVFdmVudCIsInRyaWdnZXIiLCJFdmVudCIsImlzVHJpZ2dlciIsIm5hbWVzcGFjZV9yZSIsInJlc3VsdCIsIm5vQnViYmxlIiwicGFyZW50V2luZG93IiwiaXNQcm9wYWdhdGlvblN0b3BwZWQiLCJwcmV2ZW50RGVmYXVsdCIsImlzRGVmYXVsdFByZXZlbnRlZCIsIl9kZWZhdWx0IiwiZml4IiwiZGVsZWdhdGVUYXJnZXQiLCJwcmVEaXNwYXRjaCIsImhhbmRsZXJzIiwiY3VycmVudFRhcmdldCIsImlzSW1tZWRpYXRlUHJvcGFnYXRpb25TdG9wcGVkIiwiaGFuZGxlT2JqIiwic3RvcFByb3BhZ2F0aW9uIiwicG9zdERpc3BhdGNoIiwiZml4SG9va3MiLCJtb3VzZUhvb2tzIiwia2V5SG9va3MiLCJwcm9wcyIsInNyY0VsZW1lbnQiLCJtZXRhS2V5Iiwid2hpY2giLCJjaGFyQ29kZSIsImtleUNvZGUiLCJmcm9tRWxlbWVudCIsInBhZ2VYIiwiY2xpZW50WCIsInNjcm9sbExlZnQiLCJjbGllbnRMZWZ0IiwicGFnZVkiLCJjbGllbnRZIiwic2Nyb2xsVG9wIiwiY2xpZW50VG9wIiwicmVsYXRlZFRhcmdldCIsInRvRWxlbWVudCIsImxvYWQiLCJibHVyIiwiYmVmb3JldW5sb2FkIiwib3JpZ2luYWxFdmVudCIsInJldHVyblZhbHVlIiwic2ltdWxhdGUiLCJpc1NpbXVsYXRlZCIsImRlZmF1bHRQcmV2ZW50ZWQiLCJ0aW1lU3RhbXAiLCJjYW5jZWxCdWJibGUiLCJzdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24iLCJtb3VzZWVudGVyIiwibW91c2VsZWF2ZSIsInBvaW50ZXJlbnRlciIsInBvaW50ZXJsZWF2ZSIsInN1Ym1pdEJ1YmJsZXMiLCJmb3JtIiwiX3N1Ym1pdF9idWJibGUiLCJjaGFuZ2VCdWJibGVzIiwicHJvcGVydHlOYW1lIiwiX2p1c3RfY2hhbmdlZCIsImZvY3VzaW5CdWJibGVzIiwib24iLCJvbmUiLCJvcHRpb24iLCJsZWdlbmQiLCJhcmVhIiwidGhlYWQiLCJ0ciIsImNvbCIsInRkIiwib3B0Z3JvdXAiLCJ0Zm9vdCIsImNvbGdyb3VwIiwiY2FwdGlvbiIsInRoIiwiZGVmYXVsdENoZWNrZWQiLCJ6YSIsIkFhIiwiQmEiLCJkZWZhdWx0U2VsZWN0ZWQiLCJjbG9uZSIsImJ1aWxkRnJhZ21lbnQiLCJjcmVhdGVUZXh0Tm9kZSIsImFwcGVuZCIsImRvbU1hbmlwIiwicHJlcGVuZCIsImluc2VydEJlZm9yZSIsImJlZm9yZSIsImFmdGVyIiwib3B0aW9ucyIsImh0bWwiLCJyZXBsYWNlV2l0aCIsInJlcGxhY2VDaGlsZCIsImRldGFjaCIsInNyYyIsIl9ldmFsVXJsIiwiYXBwZW5kVG8iLCJwcmVwZW5kVG8iLCJpbnNlcnRBZnRlciIsInJlcGxhY2VBbGwiLCJDYSIsIkRhIiwiRWEiLCJnZXREZWZhdWx0Q29tcHV0ZWRTdHlsZSIsImRpc3BsYXkiLCJGYSIsIndyaXRlIiwiY2xvc2UiLCJzaHJpbmtXcmFwQmxvY2tzIiwid2lkdGgiLCJHYSIsIkhhIiwiSWEiLCJKYSIsIkthIiwiZ2V0Q29tcHV0ZWRTdHlsZSIsIm9wZW5lciIsImdldFByb3BlcnR5VmFsdWUiLCJtaW5XaWR0aCIsIm1heFdpZHRoIiwiY3VycmVudFN0eWxlIiwibGVmdCIsInJ1bnRpbWVTdHlsZSIsInBpeGVsTGVmdCIsIkxhIiwibWFyZ2luUmlnaHQiLCJvZmZzZXRIZWlnaHQiLCJvcGFjaXR5IiwiY3NzRmxvYXQiLCJiYWNrZ3JvdW5kQ2xpcCIsImNsZWFyQ2xvbmVTdHlsZSIsImJveFNpemluZyIsIk1vekJveFNpemluZyIsIldlYmtpdEJveFNpemluZyIsInJlbGlhYmxlSGlkZGVuT2Zmc2V0cyIsImJveFNpemluZ1JlbGlhYmxlIiwicGl4ZWxQb3NpdGlvbiIsInJlbGlhYmxlTWFyZ2luUmlnaHQiLCJzd2FwIiwiTWEiLCJOYSIsIk9hIiwiUGEiLCJRYSIsIlJhIiwicG9zaXRpb24iLCJ2aXNpYmlsaXR5IiwiU2EiLCJsZXR0ZXJTcGFjaW5nIiwiZm9udFdlaWdodCIsIlRhIiwiVWEiLCJWYSIsIldhIiwiWGEiLCJZYSIsImNzc0hvb2tzIiwiY3NzTnVtYmVyIiwiY29sdW1uQ291bnQiLCJmaWxsT3BhY2l0eSIsImZsZXhHcm93IiwiZmxleFNocmluayIsImxpbmVIZWlnaHQiLCJvcmRlciIsIm9ycGhhbnMiLCJ3aWRvd3MiLCJ6SW5kZXgiLCJjc3NQcm9wcyIsInNldCIsIiQxIiwibWFyZ2luIiwicGFkZGluZyIsImJvcmRlciIsImV4cGFuZCIsInNob3ciLCJoaWRlIiwidG9nZ2xlIiwiWmEiLCJUd2VlbiIsInByb3AiLCJlYXNpbmciLCJzdGFydCIsImN1ciIsInVuaXQiLCJwcm9wSG9va3MiLCJydW4iLCJkdXJhdGlvbiIsInBvcyIsInN0ZXAiLCJmeCIsImxpbmVhciIsInN3aW5nIiwiY29zIiwiUEkiLCIkYSIsIl9hIiwiYWIiLCJiYiIsImNiIiwiZGIiLCJpYiIsImViIiwiY3JlYXRlVHdlZW4iLCJmYiIsImdiIiwiaGVpZ2h0IiwiaGIiLCJ1bnF1ZXVlZCIsIm92ZXJmbG93Iiwib3ZlcmZsb3dYIiwib3ZlcmZsb3dZIiwiaGlkZGVuIiwiamIiLCJrYiIsInN0YXJ0VGltZSIsInR3ZWVucyIsIm9wdHMiLCJzcGVjaWFsRWFzaW5nIiwib3JpZ2luYWxQcm9wZXJ0aWVzIiwib3JpZ2luYWxPcHRpb25zIiwicmVqZWN0V2l0aCIsInRpbWVyIiwiYW5pbSIsImNvbXBsZXRlIiwiQW5pbWF0aW9uIiwidHdlZW5lciIsInByZWZpbHRlciIsInNwZWVkIiwic3BlZWRzIiwib2xkIiwiZmFkZVRvIiwiYW5pbWF0ZSIsImZpbmlzaCIsInRpbWVycyIsInNsaWRlRG93biIsInNsaWRlVXAiLCJzbGlkZVRvZ2dsZSIsImZhZGVJbiIsImZhZGVPdXQiLCJmYWRlVG9nZ2xlIiwidGljayIsImludGVydmFsIiwic2V0SW50ZXJ2YWwiLCJjbGVhckludGVydmFsIiwic2xvdyIsImZhc3QiLCJkZWxheSIsImNsZWFyVGltZW91dCIsImdldFNldEF0dHJpYnV0ZSIsImhyZWZOb3JtYWxpemVkIiwiY2hlY2tPbiIsIm9wdFNlbGVjdGVkIiwiZW5jdHlwZSIsIm9wdERpc2FibGVkIiwicmFkaW9WYWx1ZSIsImxiIiwidmFsSG9va3MiLCJzY3JvbGxIZWlnaHQiLCJtYiIsIm5iIiwib2IiLCJwYiIsInFiIiwicmIiLCJyZW1vdmVBdHRyIiwiYXR0ckhvb2tzIiwicHJvcEZpeCIsInNldEF0dHJpYnV0ZU5vZGUiLCJjcmVhdGVBdHRyaWJ1dGUiLCJjb29yZHMiLCJjb250ZW50ZWRpdGFibGUiLCJzYiIsInRiIiwicmVtb3ZlUHJvcCIsInBhcnNlSW50IiwidWIiLCJhZGRDbGFzcyIsInJlbW92ZUNsYXNzIiwidG9nZ2xlQ2xhc3MiLCJoYXNDbGFzcyIsImhvdmVyIiwiYmluZCIsInVuYmluZCIsImRlbGVnYXRlIiwidW5kZWxlZ2F0ZSIsInZiIiwid2IiLCJ4YiIsIkZ1bmN0aW9uIiwicGFyc2VYTUwiLCJET01QYXJzZXIiLCJwYXJzZUZyb21TdHJpbmciLCJBY3RpdmVYT2JqZWN0IiwiYXN5bmMiLCJsb2FkWE1MIiwieWIiLCJ6YiIsIkFiIiwiQmIiLCJDYiIsIkRiIiwiRWIiLCJGYiIsIkdiIiwiSGIiLCJJYiIsIkpiIiwiS2IiLCJMYiIsIk1iIiwiZGF0YVR5cGVzIiwiTmIiLCJhamF4U2V0dGluZ3MiLCJmbGF0T3B0aW9ucyIsIk9iIiwibWltZVR5cGUiLCJnZXRSZXNwb25zZUhlYWRlciIsImNvbnZlcnRlcnMiLCJQYiIsInJlc3BvbnNlRmllbGRzIiwiZGF0YUZpbHRlciIsImRhdGFUeXBlIiwiYWN0aXZlIiwibGFzdE1vZGlmaWVkIiwiZXRhZyIsInVybCIsImlzTG9jYWwiLCJwcm9jZXNzRGF0YSIsImNvbnRlbnRUeXBlIiwiYWNjZXB0cyIsInhtbCIsImpzb24iLCJhamF4U2V0dXAiLCJhamF4UHJlZmlsdGVyIiwiYWpheFRyYW5zcG9ydCIsImFqYXgiLCJzdGF0dXNDb2RlIiwiZ2V0QWxsUmVzcG9uc2VIZWFkZXJzIiwic2V0UmVxdWVzdEhlYWRlciIsIm92ZXJyaWRlTWltZVR5cGUiLCJzdGF0dXMiLCJhYm9ydCIsInN1Y2Nlc3MiLCJjcm9zc0RvbWFpbiIsInRyYWRpdGlvbmFsIiwiaGFzQ29udGVudCIsImlmTW9kaWZpZWQiLCJoZWFkZXJzIiwiYmVmb3JlU2VuZCIsInRpbWVvdXQiLCJzZW5kIiwic3RhdHVzVGV4dCIsImdldEpTT04iLCJnZXRTY3JpcHQiLCJ3cmFwQWxsIiwid3JhcElubmVyIiwid3JhcCIsInZpc2libGUiLCJRYiIsIlJiIiwiU2IiLCJUYiIsIlViIiwiVmIiLCJlbmNvZGVVUklDb21wb25lbnQiLCJzZXJpYWxpemUiLCJzZXJpYWxpemVBcnJheSIsInhociIsIlpiIiwiJGIiLCJXYiIsIlhiIiwiWWIiLCJjb3JzIiwib3BlbiIsInVzZXJuYW1lIiwieGhyRmllbGRzIiwib25yZWFkeXN0YXRlY2hhbmdlIiwicmVzcG9uc2VUZXh0IiwiWE1MSHR0cFJlcXVlc3QiLCJzY3JpcHQiLCJoZWFkIiwic2NyaXB0Q2hhcnNldCIsImNoYXJzZXQiLCJvbmxvYWQiLCJfYiIsImFjIiwianNvbnAiLCJqc29ucENhbGxiYWNrIiwiYmMiLCJhbmltYXRlZCIsImNjIiwiZGMiLCJvZmZzZXQiLCJzZXRPZmZzZXQiLCJ1c2luZyIsImdldEJvdW5kaW5nQ2xpZW50UmVjdCIsInBhZ2VZT2Zmc2V0IiwicGFnZVhPZmZzZXQiLCJvZmZzZXRQYXJlbnQiLCJzY3JvbGxUbyIsIkhlaWdodCIsIldpZHRoIiwiY29udGVudCIsInNpemUiLCJhbmRTZWxmIiwiZWMiLCJqUXVlcnkiLCJmYyIsIm5vQ29uZmxpY3QiLCJyZXF1aXJlIiwibWlncmF0ZU11dGUiLCJjb25zb2xlIiwibWlncmF0ZVdhcm5pbmdzIiwid2FybiIsIm1pZ3JhdGVUcmFjZSIsInRyYWNlIiwiY29uZmlndXJhYmxlIiwiZW51bWVyYWJsZSIsIl9kZWZpbmVQcm9wZXJ0eUJyb2tlbiIsIm1pZ3JhdGVWZXJzaW9uIiwibG9nIiwibWlncmF0ZVJlc2V0IiwiY29tcGF0TW9kZSIsImF0dHJGbiIsInVhTWF0Y2giLCJicm93c2VyIiwidmVyc2lvbiIsIm5hdmlnYXRvciIsInVzZXJBZ2VudCIsImNocm9tZSIsIndlYmtpdCIsInNhZmFyaSIsImJveE1vZGVsIiwic3ViIiwic3VwZXJjbGFzcyIsImNsZWFuIiwibGl2ZSIsImRpZSIsImlzUmVzb2x2ZWQiLCJpc1JlamVjdGVkIiwidGFnc0lkcyIsImluaXRpYWxWYWwiLCJmb3JFYWNoIiwiZWwiLCJsYXp5U2VsZWN0b3IiLCJkZWZhdWx0cyIsInNldHRpbmdzIiwiJGljb25CdXR0b24iLCJzdGF0ZUNvbmYiLCJwYWdlSW5jcmVtZW50IiwibG9hZGluZ0ZsYWciLCJzZXRTaW5nbGVWYWwiLCIkaW5wdXQiLCIkbW9kYWwiLCIkZm9ybSIsIiR1bCIsIiRsaUZvb3RlciIsIiRociIsIiRidG5HRVQiLCJidG5DbG9zZU1hcCIsImNzc1ZhbGlkYXRpb25DbGFzcyIsIm1vZGFsQ29udGVudCIsIiRtc1NlbGVjdGlvbiIsIiRtc0xpc3QiLCIkbXNCdG5Vc2UiLCJrZXl3b3JkIiwiZGVmYXVsdEFwaUtleSIsImFwaUtleVNlcnZpY2UiLCJnZXRBcGlFeHBsb3JlS2V5IiwiYXBpa2V5IiwiY2hlY2tBcGlLZXlDb29raWUiLCJldmVudFVybCIsImZvcm1hdERhdGUiLCJkYXRlIiwiZGF5IiwiTU9OVEhfTkFNRVMiLCJEQVlfTkFNRVMiLCJkYXlBcnJheSIsImdldERheSIsInRpbWUiLCJ0aW1lQXJyYXkiLCJnZXROb3JtYWxpemVkRGF0ZVZhbHVlIiwibWFwUG9wVXBMaXN0ZW5lciIsImxhdCIsImxuZyIsImFkZHJlc3MiLCJpbml0TWFwIiwiZ29vZ2xlIiwibWFwcyIsIm1hcmtlcnMiLCJtb2RhbCIsIm1hcENlbnRlciIsIkxhdExuZyIsIk1hcCIsImNlbnRlciIsIm1hcFR5cGVDb250cm9sIiwic2NhbGVDb250cm9sIiwiZnVsbHNjcmVlbkNvbnRyb2wiLCJzdHJlZXRWaWV3Q29udHJvbCIsInJvdGF0ZUNvbnRyb2wiLCJjbGVhck1hcmtlcnMiLCJwYW5UbyIsInNldENlbnRlciIsImFkZE1hcmtlciIsIm1hcmtlciIsIk1hcmtlciIsImljb24iLCJNYXJrZXJJbWFnZSIsIlNpemUiLCJzZXRNYXAiLCJjbG9zZU1hcExpc3RlbmVyIiwidG9nZ2xlVGFncyIsImluZFRvUmVtb3ZlIiwiaW5wdXRWYWxBcnJheSIsImxpc3RJdGVtIiwiaW5jbHVkZXMiLCJ0b2dnbGVNc1NlbGVjdGlvbkJveCIsImNoYW5nZU1vZGFsVGV4dExpc3RlbmVyIiwiaGlkZU11bHRpU2VsZWN0b3IiLCJsb2FkaW5nIiwiYWN0aW9uIiwic3Bpbm5lciIsInJlc2V0Rm9ybSIsImxpc3RJdGVtcyIsImFkZE1zQnV0dG9uTGlzdGVuZXIiLCJtYXBMaXN0ZW5lciIsInN1Ym1pdEZvcm0iLCJwYWdlTnVtZXJvIiwiaXNOYU4iLCJyZW5kZXJSZXN1bHRzIiwicGFnZSIsInRvdGFsUGFnZXMiLCJ0b3RhbEVsZW1lbnRzIiwiZ2V0SW1hZ2VGb3JFdmVudCIsImltYWdlcyIsInJlbmRlckxpc3RFdmVudHMiLCJpdGVtcyIsIml0ZW0iLCJsaSIsImxlZnRDb2wiLCJzcGFuSW1nIiwiaW1nIiwiJHdyYXBDb2wiLCJ0aXRsZSIsImN1cnJlbnRFdmVudCIsImRhdGVzIiwibG9jYWxEYXRlIiwibG9jYWxUaW1lIiwiZGF0ZVRpbWUiLCJldmVudFRpbWUiLCJfZW1iZWRkZWQiLCJ2ZW51ZXMiLCJ2ZW51ZSIsImFkZHJlc3NOYW1lIiwiYWRkcmVzc2xpbmUxIiwibGluZTEiLCJhZGRyZXNzbGluZTIiLCJsaW5lMiIsImJ1dHRvblNldElkIiwiYWRkVG9FbCIsImJ1dHRvblNldElkV3JhcHBlciIsImFkZE1zQnV0dG9uIiwicmVuZGVyTGlzdFZlbnVlcyIsImNvbnRyeVN0YXRlTmFtZSIsImNvdW50cnkiLCJjaXR5TmFtZSIsImNpdHkiLCJsYXRpdHVkZSIsImxvbmdpdHVkZSIsImJ1dHRvbk1hcCIsInJlbmRlckxpc3RBdHRyYWN0aW9ucyIsImNsYXNzaWZpY2F0aW9ucyIsIl9nZW5yZSIsIl9zdWJnZW5yZSIsIl9zZWdtZW50Iiwic2VnbWVudCIsImdlbnJlIiwic3ViR2VucmUiLCJzZWdtZW50VGV4dCIsImhhc1Njcm9sbEJhciIsImVsZW1lbnQiLCJ3cmFwcGVyIiwiaW5uZXJIZWlnaHQiLCJ1bEVsZW1lbnQiLCJzaG93TWVzc2FnZSIsIm1lc3NhZ2UiLCJjbGVhckxpc3QiLCJhdHRyYWN0aW9ucyIsInNldElkTGlzdGVuZXIiLCJzY3JlZW5XaWR0aCIsImNsaWVudFdpZHRoIiwiaW5uZXJXaWR0aCIsImlzTW9iaWxlIiwic3Vic3RyIiwiYnV0dG9uQWRkSWRUb0xpc3QiLCJzZWxlY3RlZElEIiwic2V0SWRzTGlzdGVuZXIiLCJjbGVhckJ5QXJyVmFsIiwibWFwQW55IiwiYXJyYXkiLCJkZWxJZExpc3RlbmVyIiwibWUiLCJ0YWdJRCIsImlzVW5pcXVlIiwibGlzdCIsInVuaXF1ZVVwY29taW5nIiwiY3VycmVudExpc3QiLCJjaGVja1ZhbGlkaXR5IiwicmVwb3J0VmFsaWRpdHkiLCJlbG0iLCJ0YWdOYW1lIiwic2VsZWN0b3JCdG4iLCJ0YWdzQXJyIiwiZmxhZyIsImNsYXNzaWZpY2F0aW9uU2VsZWN0b3IiLCJ1c2UiLCIkanN0cmVlIiwiaW5pdFRyZWUiLCJzZXRDaGlsZHJlbiIsImpzdHJlZSIsImluc3RhbmNlIiwidG9nZ2xlX25vZGUiLCJub2RlIiwiZ2V0X25vZGUiLCJ1cGRhdGVUcmVlIiwibmV3SnNvbiIsImNvcmUiLCJyZWZyZXNoIiwibmV3QXJyT2JqIiwicmVuYW1lIiwiZ2VucmVzIiwic3ViZ2VucmVzIiwib3B0IiwiZmllbGROYW1lIiwidG8iLCJjaGlsZCIsImFyciIsInJlcGxhY2VBdG9CIiwiZ2VucmVzQXJyIiwic3ViZ2VucmVzQXJyIiwiaWkiLCJpc0luaXQiLCJ0ZXh0U3RhdHVzIiwiZXJyb3JUaHJvd24iLCJlcnJvck1zZyIsIm1zZyIsImV4cGxhbmF0aW9uIiwibXNnRXJyIiwicmVzcG9uc2VKU09OIiwiZGV0YWlsIiwiV2Via2l0VHJhbnNpdGlvbiIsIk1velRyYW5zaXRpb24iLCJPVHJhbnNpdGlvbiIsInRyYW5zaXRpb24iLCJlbXVsYXRlVHJhbnNpdGlvbkVuZCIsImJzVHJhbnNpdGlvbkVuZCIsIlZFUlNJT04iLCJUUkFOU0lUSU9OX0RVUkFUSU9OIiwiYWxlcnQiLCJDb25zdHJ1Y3RvciIsInNldFN0YXRlIiwiJGVsZW1lbnQiLCJERUZBVUxUUyIsImlzTG9hZGluZyIsImxvYWRpbmdUZXh0IiwicmVzZXRUZXh0Iiwic2xpZGUiLCJwYXVzZSIsImN5Y2xlIiwiJGluZGljYXRvcnMiLCJwYXVzZWQiLCJzbGlkaW5nIiwiJGFjdGl2ZSIsIiRpdGVtcyIsImtleWJvYXJkIiwia2V5ZG93biIsImdldEl0ZW1JbmRleCIsImdldEl0ZW1Gb3JEaXJlY3Rpb24iLCJkaXJlY3Rpb24iLCJjYXJvdXNlbCIsIiR0cmlnZ2VyIiwidHJhbnNpdGlvbmluZyIsIiRwYXJlbnQiLCJnZXRQYXJlbnQiLCJhZGRBcmlhQW5kQ29sbGFwc2VkQ2xhc3MiLCJkaW1lbnNpb24iLCJjb2xsYXBzZSIsImRyb3Bkb3duIiwiJGJvZHkiLCIkZGlhbG9nIiwiJGJhY2tkcm9wIiwiaXNTaG93biIsIm9yaWdpbmFsQm9keVBhZCIsInNjcm9sbGJhcldpZHRoIiwiaWdub3JlQmFja2Ryb3BDbGljayIsInJlbW90ZSIsIkJBQ0tEUk9QX1RSQU5TSVRJT05fRFVSQVRJT04iLCJiYWNrZHJvcCIsImNoZWNrU2Nyb2xsYmFyIiwic2V0U2Nyb2xsYmFyIiwiZXNjYXBlIiwicmVzaXplIiwiYWRqdXN0RGlhbG9nIiwiZW5mb3JjZUZvY3VzIiwiaGlkZU1vZGFsIiwiaGFuZGxlVXBkYXRlIiwicmVzZXRBZGp1c3RtZW50cyIsInJlc2V0U2Nyb2xsYmFyIiwicmVtb3ZlQmFja2Ryb3AiLCJjbGllbnRIZWlnaHQiLCJwYWRkaW5nTGVmdCIsImJvZHlJc092ZXJmbG93aW5nIiwicGFkZGluZ1JpZ2h0IiwicmlnaHQiLCJhYnMiLCJtZWFzdXJlU2Nyb2xsYmFyIiwiaG92ZXJTdGF0ZSIsImluU3RhdGUiLCJhbmltYXRpb24iLCJwbGFjZW1lbnQiLCJ0ZW1wbGF0ZSIsImNvbnRhaW5lciIsInZpZXdwb3J0IiwiZ2V0T3B0aW9ucyIsIiR2aWV3cG9ydCIsImVudGVyIiwibGVhdmUiLCJfb3B0aW9ucyIsImZpeFRpdGxlIiwiZ2V0RGVmYXVsdHMiLCJnZXREZWxlZ2F0ZU9wdGlvbnMiLCJ0aXAiLCJpc0luU3RhdGVUcnVlIiwiZ2V0VUlEIiwic2V0Q29udGVudCIsImdldFBvc2l0aW9uIiwiYm90dG9tIiwiZ2V0Q2FsY3VsYXRlZE9mZnNldCIsImFwcGx5UGxhY2VtZW50IiwiJHRpcCIsInJvdW5kIiwiZ2V0Vmlld3BvcnRBZGp1c3RlZERlbHRhIiwicmVwbGFjZUFycm93IiwiYXJyb3ciLCJnZXRUaXRsZSIsInNjcm9sbCIsIiRhcnJvdyIsImVuYWJsZSIsInRvZ2dsZUVuYWJsZWQiLCJkZXN0cm95IiwidG9vbHRpcCIsImdldENvbnRlbnQiLCJwb3BvdmVyIiwiJHNjcm9sbEVsZW1lbnQiLCJvZmZzZXRzIiwidGFyZ2V0cyIsImFjdGl2ZVRhcmdldCIsInByb2Nlc3MiLCJnZXRTY3JvbGxIZWlnaHQiLCJhY3RpdmF0ZSIsImNsZWFyIiwic2Nyb2xsc3B5IiwidGFiIiwiJHRhcmdldCIsImNoZWNrUG9zaXRpb24iLCJjaGVja1Bvc2l0aW9uV2l0aEV2ZW50TG9vcCIsImFmZml4ZWQiLCJ1bnBpbiIsInBpbm5lZE9mZnNldCIsIlJFU0VUIiwiZ2V0U3RhdGUiLCJnZXRQaW5uZWRPZmZzZXQiLCJhZmZpeCIsIm9mZnNldEJvdHRvbSIsIm9mZnNldFRvcCIsInZhbGlkYXRpb24iLCJydWxlcyIsInBhdHRlcm4iLCJyZWdpc3RlckV4dGVuZGVycyIsIm1lc3NhZ2VzT25Nb2RpZmllZCIsImRlY29yYXRlSW5wdXRFbGVtZW50IiwiZXJyb3JNZXNzYWdlQ2xhc3MiLCJlcnJvckVsZW1lbnRDbGFzcyIsImluc2VydE1lc3NhZ2VzIiwicGFyc2VJbnB1dEF0dHJpYnV0ZXMiLCJtZXNzYWdlVGVtcGxhdGUiLCJncm91cGluZyIsImRlZXAiLCJ2YWxpZGF0b3IiLCJ2YWxpZGF0ZSIsIlNsaWNrIiwiYWNjZXNzaWJpbGl0eSIsImFkYXB0aXZlSGVpZ2h0IiwiYXBwZW5kQXJyb3dzIiwiYXBwZW5kRG90cyIsImFycm93cyIsImFzTmF2Rm9yIiwicHJldkFycm93IiwibmV4dEFycm93IiwiYXV0b3BsYXkiLCJhdXRvcGxheVNwZWVkIiwiY2VudGVyTW9kZSIsImNlbnRlclBhZGRpbmciLCJjc3NFYXNlIiwiY3VzdG9tUGFnaW5nIiwiZG90cyIsImRvdHNDbGFzcyIsImRyYWdnYWJsZSIsImVkZ2VGcmljdGlvbiIsImZhZGUiLCJmb2N1c09uU2VsZWN0IiwiaW5maW5pdGUiLCJpbml0aWFsU2xpZGUiLCJsYXp5TG9hZCIsIm1vYmlsZUZpcnN0IiwicGF1c2VPbkhvdmVyIiwicGF1c2VPbkRvdHNIb3ZlciIsInJlc3BvbmRUbyIsInJlc3BvbnNpdmUiLCJyb3dzIiwicnRsIiwic2xpZGVzUGVyUm93Iiwic2xpZGVzVG9TaG93Iiwic2xpZGVzVG9TY3JvbGwiLCJzd2lwZSIsInN3aXBlVG9TbGlkZSIsInRvdWNoTW92ZSIsInRvdWNoVGhyZXNob2xkIiwidXNlQ1NTIiwidXNlVHJhbnNmb3JtIiwidmFyaWFibGVXaWR0aCIsInZlcnRpY2FsIiwidmVydGljYWxTd2lwaW5nIiwid2FpdEZvckFuaW1hdGUiLCJpbml0aWFscyIsImFuaW1hdGluZyIsImRyYWdnaW5nIiwiYXV0b1BsYXlUaW1lciIsImN1cnJlbnREaXJlY3Rpb24iLCJjdXJyZW50TGVmdCIsImN1cnJlbnRTbGlkZSIsIiRkb3RzIiwibGlzdFdpZHRoIiwibGlzdEhlaWdodCIsImxvYWRJbmRleCIsIiRuZXh0QXJyb3ciLCIkcHJldkFycm93Iiwic2xpZGVDb3VudCIsInNsaWRlV2lkdGgiLCIkc2xpZGVUcmFjayIsIiRzbGlkZXMiLCJzbGlkZU9mZnNldCIsInN3aXBlTGVmdCIsIiRsaXN0IiwidG91Y2hPYmplY3QiLCJ0cmFuc2Zvcm1zRW5hYmxlZCIsInVuc2xpY2tlZCIsImFjdGl2ZUJyZWFrcG9pbnQiLCJhbmltVHlwZSIsImFuaW1Qcm9wIiwiYnJlYWtwb2ludHMiLCJicmVha3BvaW50U2V0dGluZ3MiLCJjc3NUcmFuc2l0aW9ucyIsInBvc2l0aW9uUHJvcCIsInJvd0NvdW50Iiwic2hvdWxkQ2xpY2siLCIkc2xpZGVyIiwiJHNsaWRlc0NhY2hlIiwidHJhbnNmb3JtVHlwZSIsInRyYW5zaXRpb25UeXBlIiwidmlzaWJpbGl0eUNoYW5nZSIsIndpbmRvd1dpZHRoIiwid2luZG93VGltZXIiLCJvcmlnaW5hbFNldHRpbmdzIiwibW96SGlkZGVuIiwid2Via2l0SGlkZGVuIiwiYXV0b1BsYXkiLCJhdXRvUGxheUNsZWFyIiwiY2hhbmdlU2xpZGUiLCJjbGlja0hhbmRsZXIiLCJzZWxlY3RIYW5kbGVyIiwic2V0UG9zaXRpb24iLCJzd2lwZUhhbmRsZXIiLCJkcmFnSGFuZGxlciIsImtleUhhbmRsZXIiLCJhdXRvUGxheUl0ZXJhdG9yIiwiaW5zdGFuY2VVaWQiLCJodG1sRXhwciIsInJlZ2lzdGVyQnJlYWtwb2ludHMiLCJjaGVja1Jlc3BvbnNpdmUiLCJhZGRTbGlkZSIsInNsaWNrQWRkIiwidW5sb2FkIiwicmVpbml0IiwiYW5pbWF0ZUhlaWdodCIsIm91dGVySGVpZ2h0IiwiYW5pbWF0ZVNsaWRlIiwiYW5pbVN0YXJ0IiwiY2VpbCIsImFwcGx5VHJhbnNpdGlvbiIsImRpc2FibGVUcmFuc2l0aW9uIiwic2xpY2siLCJzbGlkZUhhbmRsZXIiLCJidWlsZEFycm93cyIsInRhYmluZGV4IiwiYnVpbGREb3RzIiwiZ2V0RG90Q291bnQiLCJidWlsZE91dCIsInNldHVwSW5maW5pdGUiLCJ1cGRhdGVEb3RzIiwic2V0U2xpZGVDbGFzc2VzIiwiYnVpbGRSb3dzIiwibWluIiwidW5zbGljayIsImNoZWNrTmF2aWdhYmxlIiwiZ2V0TmF2aWdhYmxlSW5kZXhlcyIsImNsZWFuVXBFdmVudHMiLCJzZXRQYXVzZWQiLCJvcmllbnRhdGlvbkNoYW5nZSIsImNsZWFuVXBSb3dzIiwiZmFkZVNsaWRlIiwiZmFkZVNsaWRlT3V0IiwiZmlsdGVyU2xpZGVzIiwic2xpY2tGaWx0ZXIiLCJnZXRDdXJyZW50Iiwic2xpY2tDdXJyZW50U2xpZGUiLCJnZXRMZWZ0IiwiZmxvb3IiLCJvZmZzZXRMZWZ0Iiwib3V0ZXJXaWR0aCIsImdldE9wdGlvbiIsInNsaWNrR2V0T3B0aW9uIiwiZ2V0U2xpY2siLCJnZXRTbGlkZUNvdW50IiwiZ29UbyIsInNsaWNrR29UbyIsInNldFByb3BzIiwic3RhcnRMb2FkIiwibG9hZFNsaWRlciIsImluaXRpYWxpemVFdmVudHMiLCJ1cGRhdGVBcnJvd3MiLCJpbml0QURBIiwiaW5pdEFycm93RXZlbnRzIiwiaW5pdERvdEV2ZW50cyIsImluaXRVSSIsInByb2dyZXNzaXZlTGF6eUxvYWQiLCJzbGlja05leHQiLCJzbGlja1BhdXNlIiwicGxheSIsInNsaWNrUGxheSIsInBvc3RTbGlkZSIsInNsaWNrUHJldiIsImJyZWFrcG9pbnQiLCJmb2N1c0hhbmRsZXIiLCJ3aW5kb3dEZWxheSIsInJlbW92ZVNsaWRlIiwic2xpY2tSZW1vdmUiLCJzZXRDU1MiLCJzZXREaW1lbnNpb25zIiwic2V0RmFkZSIsInNldEhlaWdodCIsInNldE9wdGlvbiIsInNsaWNrU2V0T3B0aW9uIiwibXNUcmFuc2l0aW9uIiwiT1RyYW5zZm9ybSIsInBlcnNwZWN0aXZlUHJvcGVydHkiLCJ3ZWJraXRQZXJzcGVjdGl2ZSIsIk1velRyYW5zZm9ybSIsIk1velBlcnNwZWN0aXZlIiwid2Via2l0VHJhbnNmb3JtIiwibXNUcmFuc2Zvcm0iLCJ0cmFuc2Zvcm0iLCJzd2lwZURpcmVjdGlvbiIsInN0YXJ0WCIsImN1clgiLCJzdGFydFkiLCJjdXJZIiwiYXRhbjIiLCJzd2lwZUVuZCIsInN3aXBlTGVuZ3RoIiwiZWRnZUhpdCIsIm1pblN3aXBlIiwiZmluZ2VyQ291bnQiLCJ0b3VjaGVzIiwic3dpcGVTdGFydCIsInN3aXBlTW92ZSIsInNxcnQiLCJwb3ciLCJ1bmZpbHRlclNsaWRlcyIsInNsaWNrVW5maWx0ZXIiLCJyb2xlIiwiYWN0aXZhdGVBREEiLCJpc1BsYXkiLCJjb2RlIiwiUmVzaXplU2Vuc29yIiwiUHMiLCJnZXRPcHRzIiwiYWNjIiwidW5kZWZpbmVkIiwicHNPcHRzIiwic3VwcHJlc3NTY3JvbGxYIiwic3VwcHJlc3NTY3JvbGxZIiwic2Nyb2xsQmluZGluZyIsInZhbEFjYyIsImJpbmRpbmdzIiwidm0iLCJjdHgiLCJpbml0aWFsaXplIiwic2Vuc29yIiwidXBkYXRlIiwidXRpbHMiLCJkb21Ob2RlRGlzcG9zYWwiLCJhZGREaXNwb3NlQ2FsbGJhY2siLCJfZmlyc3RVcGRhdGVDb21wbGV0ZSIsImJpbmRpbmdIYW5kbGVycyIsInNlbGYiLCJjYWxsYmFjayIsIkV2ZW50UXVldWUiLCJldiIsImF0dGFjaFJlc2l6ZUV2ZW50IiwicmVzaXplZCIsInJlc2l6ZWRBdHRhY2hlZCIsInJlc2l6ZVNlbnNvciIsInN0eWxlQ2hpbGQiLCJmaXhlZCIsImFic29sdXRlIiwiZXhwYW5kQ2hpbGQiLCJzaHJpbmsiLCJzaHJpbmtDaGlsZCIsImxhc3RXaWR0aCIsImxhc3RIZWlnaHQiLCJzY3JvbGxXaWR0aCIsImNoYW5nZWQiLCJhZGRFdmVudCIsIm9uU2Nyb2xsIiwiZWxlbWVudFR5cGUiLCJpc0NvbGxlY3Rpb25UeXBlZCIsIkVsZW1lbnRzIiwib2xkQWRkIiwiY2xhc3NlcyIsIm9sZFJlbW92ZSIsImlkeCIsImNsYXNzTGlzdCIsIkRPTSIsImNzc0dldCIsInN0eWxlTmFtZSIsImNzc1NldCIsInN0eWxlVmFsdWUiLCJjc3NNdWx0aVNldCIsInN0eWxlTmFtZU9yT2JqZWN0IiwicXVlcnlDaGlsZHJlbiIsIkV2ZW50RWxlbWVudCIsImV2ZW50TmFtZSIsImlzSGFuZGxlclByb3ZpZGVkIiwiaGRsciIsInVuYmluZEFsbCIsIkV2ZW50TWFuYWdlciIsImV2ZW50RWxlbWVudHMiLCJldmVudEVsZW1lbnQiLCJlZSIsIm9uY2VIYW5kbGVyIiwiczQiLCJzdWJzdHJpbmciLCJjbHMiLCJkb20iLCJ0b0ludCIsIm9yaWdpbmFsIiwiaXNFZGl0YWJsZSIsInJlbW92ZVBzQ2xhc3NlcyIsImNsc0xpc3QiLCJzdGFydFNjcm9sbGluZyIsImF4aXMiLCJzdG9wU2Nyb2xsaW5nIiwiZW52IiwiaXNXZWJLaXQiLCJzdXBwb3J0c1RvdWNoIiwiRG9jdW1lbnRUb3VjaCIsInN1cHBvcnRzSWVQb2ludGVyIiwibXNNYXhUb3VjaFBvaW50cyIsIm1heFNjcm9sbGJhckxlbmd0aCIsIm1pblNjcm9sbGJhckxlbmd0aCIsInNjcm9sbFhNYXJnaW5PZmZzZXQiLCJzY3JvbGxZTWFyZ2luT2Zmc2V0Iiwic3RvcFByb3BhZ2F0aW9uT25DbGljayIsInN3aXBlUHJvcGFnYXRpb24iLCJ1c2VCb3RoV2hlZWxBeGVzIiwid2hlZWxQcm9wYWdhdGlvbiIsIndoZWVsU3BlZWQiLCJ0aGVtZSIsImluc3RhbmNlcyIsInNjcm9sbGJhclgiLCJzY3JvbGxiYXJZIiwic2Nyb2xsYmFyWFJhaWwiLCJzY3JvbGxiYXJZUmFpbCIsInVwZGF0ZUdlb21ldHJ5IiwidXBkYXRlU2Nyb2xsIiwiYmluZENsaWNrUmFpbEhhbmRsZXIiLCJwYWdlT2Zmc2V0IiwiaGFsZk9mU2Nyb2xsYmFyTGVuZ3RoIiwic2Nyb2xsYmFyWUhlaWdodCIsInBvc2l0aW9uVG9wIiwicmFpbFlSYXRpbyIsIm1heFBvc2l0aW9uVG9wIiwicmFpbFlIZWlnaHQiLCJwb3NpdGlvblJhdGlvIiwiY29udGVudEhlaWdodCIsImNvbnRhaW5lckhlaWdodCIsInNjcm9sbGJhclhXaWR0aCIsInBvc2l0aW9uTGVmdCIsInJhaWxYUmF0aW8iLCJtYXhQb3NpdGlvbkxlZnQiLCJyYWlsWFdpZHRoIiwiY29udGVudFdpZHRoIiwiY29udGFpbmVyV2lkdGgiLCJuZWdhdGl2ZVNjcm9sbEFkanVzdG1lbnQiLCJiaW5kTW91c2VTY3JvbGxYSGFuZGxlciIsImN1cnJlbnRQYWdlWCIsInVwZGF0ZVNjcm9sbExlZnQiLCJkZWx0YVgiLCJuZXdMZWZ0IiwibWF4TGVmdCIsInNjcm9sbGJhclhMZWZ0IiwibW91c2VNb3ZlSGFuZGxlciIsIm1vdXNlVXBIYW5kbGVyIiwiYmluZE1vdXNlU2Nyb2xsWUhhbmRsZXIiLCJjdXJyZW50VG9wIiwiY3VycmVudFBhZ2VZIiwidXBkYXRlU2Nyb2xsVG9wIiwiZGVsdGFZIiwibmV3VG9wIiwibWF4VG9wIiwic2Nyb2xsYmFyWVRvcCIsImJpbmRLZXlib2FyZEhhbmRsZXIiLCJob3ZlcmVkIiwic2hvdWxkUHJldmVudCIsInNob3VsZFByZXZlbnREZWZhdWx0Iiwic2Nyb2xsYmFyWUFjdGl2ZSIsInNjcm9sbGJhclhBY3RpdmUiLCJmb2N1c2VkIiwic2hhZG93Um9vdCIsInNoaWZ0S2V5IiwiY3RybEtleSIsImJpbmRNb3VzZVdoZWVsSGFuZGxlciIsImdldERlbHRhRnJvbUV2ZW50Iiwid2hlZWxEZWx0YVgiLCJ3aGVlbERlbHRhWSIsImRlbHRhTW9kZSIsIndoZWVsRGVsdGEiLCJzaG91bGRCZUNvbnN1bWVkQnlDaGlsZCIsInF1ZXJ5U2VsZWN0b3IiLCJtYXhTY3JvbGxUb3AiLCJtYXhTY3JvbGxMZWZ0IiwibW91c2V3aGVlbEhhbmRsZXIiLCJkZWx0YSIsIm9ud2hlZWwiLCJvbm1vdXNld2hlZWwiLCJiaW5kTmF0aXZlU2Nyb2xsSGFuZGxlciIsImJpbmRTZWxlY3Rpb25IYW5kbGVyIiwiZ2V0UmFuZ2VOb2RlIiwic2VsZWN0aW9uIiwiZ2V0U2VsZWN0aW9uIiwiZ2V0UmFuZ2VBdCIsImNvbW1vbkFuY2VzdG9yQ29udGFpbmVyIiwic2Nyb2xsaW5nTG9vcCIsInNjcm9sbERpZmYiLCJpc1NlbGVjdGVkIiwibW91c2VQb3NpdGlvbiIsImNvbnRhaW5lckdlb21ldHJ5IiwiYmluZFRvdWNoSGFuZGxlciIsIm1hZ25pdHVkZVgiLCJtYWduaXR1ZGVZIiwiYXBwbHlUb3VjaE1vdmUiLCJkaWZmZXJlbmNlWCIsImRpZmZlcmVuY2VZIiwic3RhcnRPZmZzZXQiLCJlYXNpbmdMb29wIiwiaW5HbG9iYWxUb3VjaCIsImluTG9jYWxUb3VjaCIsImdsb2JhbFRvdWNoU3RhcnQiLCJnbG9iYWxUb3VjaEVuZCIsImdldFRvdWNoIiwidGFyZ2V0VG91Y2hlcyIsInNob3VsZEhhbmRsZSIsInBvaW50ZXJUeXBlIiwiTVNQT0lOVEVSX1RZUEVfTU9VU0UiLCJ0b3VjaFN0YXJ0IiwidG91Y2giLCJnZXRUaW1lIiwiY3VycmVudE9mZnNldCIsImN1cnJlbnRUaW1lIiwidGltZUdhcCIsInRvdWNoRW5kIiwiUG9pbnRlckV2ZW50IiwiTVNQb2ludGVyRXZlbnQiLCJuYXRpdmVTY3JvbGxIYW5kbGVyIiwidXNlclNldHRpbmdzIiwiaGFuZGxlck5hbWUiLCJkZWZhdWx0U2V0dGluZ3MiLCJJbnN0YW5jZSIsImlzUnRsIiwiaXNOZWdhdGl2ZVNjcm9sbCIsIm9yaWdpbmFsU2Nyb2xsTGVmdCIsInNjcm9sbGJhclhCb3R0b20iLCJpc1Njcm9sbGJhclhVc2luZ0JvdHRvbSIsInNjcm9sbGJhclhUb3AiLCJyYWlsQm9yZGVyWFdpZHRoIiwicmFpbFhNYXJnaW5XaWR0aCIsInNjcm9sbGJhcllSaWdodCIsImlzU2Nyb2xsYmFyWVVzaW5nUmlnaHQiLCJzY3JvbGxiYXJZTGVmdCIsInNjcm9sbGJhcllPdXRlcldpZHRoIiwicmFpbEJvcmRlcllXaWR0aCIsInJhaWxZTWFyZ2luSGVpZ2h0IiwiZ2V0SWQiLCJzZXRJZCIsInJlbW92ZUlkIiwibmV3SWQiLCJnZXRUaHVtYlNpemUiLCJ0aHVtYlNpemUiLCJ1cGRhdGVDc3MiLCJ4UmFpbE9mZnNldCIsInlSYWlsT2Zmc2V0IiwiZXhpc3RpbmdSYWlscyIsInJhaWwiLCJ1cEV2ZW50IiwiY3JlYXRlRXZlbnQiLCJkb3duRXZlbnQiLCJsZWZ0RXZlbnQiLCJyaWdodEV2ZW50IiwieUV2ZW50IiwieEV2ZW50IiwieFN0YXJ0RXZlbnQiLCJ4RW5kRXZlbnQiLCJ5U3RhcnRFdmVudCIsInlFbmRFdmVudCIsImxhc3RUb3AiLCJsYXN0TGVmdCIsImluaXRFdmVudCIsImRpc3BhdGNoRXZlbnQiLCJDbGlwYm9hcmQiLCJFbGVtZW50IiwiSFRNTEVsZW1lbnQiLCJub2RlTGlzdCIsInN0cmluZyIsImZ1bmN0aW9uIiwiVHlwZUVycm9yIiwic2V0U2VsZWN0aW9uUmFuZ2UiLCJoYXNBdHRyaWJ1dGUiLCJjcmVhdGVSYW5nZSIsInNlbGVjdE5vZGVDb250ZW50cyIsInJlbW92ZUFsbFJhbmdlcyIsImFkZFJhbmdlIiwiZW1pdCIsIl9fZXNNb2R1bGUiLCJ3cml0YWJsZSIsInJlc29sdmVPcHRpb25zIiwiaW5pdFNlbGVjdGlvbiIsImVtaXR0ZXIiLCJzZWxlY3RlZFRleHQiLCJzZWxlY3RGYWtlIiwic2VsZWN0VGFyZ2V0IiwicmVtb3ZlRmFrZSIsImZha2VIYW5kbGVyIiwiZmFrZUVsZW0iLCJjb3B5VGV4dCIsImV4ZWNDb21tYW5kIiwiaGFuZGxlUmVzdWx0IiwiY2xlYXJTZWxlY3Rpb24iLCJfYWN0aW9uIiwiX3RhcmdldCIsIl9fcHJvdG9fXyIsImxpc3RlbkNsaWNrIiwiZGVmYXVsdEFjdGlvbiIsImRlZmF1bHRUYXJnZXQiLCJkZWZhdWx0VGV4dCIsImxpc3RlbmVyIiwib25DbGljayIsImNsaXBib2FyZEFjdGlvbiIsIiRjbGFtcCIsInRydW5jYXRpb25DaGFyIiwic3BsaXRPbkNoYXJzIiwiY2xhbXAiLCJ1c2VOYXRpdmVDbGFtcCIsInRydW5jYXRpb25IVE1MIiwid2Via2l0TGluZUNsYW1wIiwidGV4dE92ZXJmbG93Iiwid2Via2l0Qm94T3JpZW50IiwiY2xhbXBlZCIsIndpbkNhbCIsImR0VG9kYXkiLCJDYWwiLCJleERhdGVUaW1lIiwic2VsRGF0ZSIsImNhbFNwYW5JRCIsImRvbVN0eWxlIiwiY25MZWZ0IiwiY25Ub3AiLCJ4cG9zIiwieXBvcyIsImNhbEhlaWdodCIsIkNhbFdpZHRoIiwiQ2VsbFdpZHRoIiwiVGltZU1vZGUiLCJTdGFydFllYXIiLCJnZXRGdWxsWWVhciIsIkVuZFllYXIiLCJDYWxQb3NPZmZzZXRYIiwiQ2FsUG9zT2Zmc2V0WSIsInNob3dNb250aEluSGVhZCIsIlNwYW5Cb3JkZXJDb2xvciIsIlNwYW5CZ0NvbG9yIiwiTW9udGhZZWFyQ29sb3IiLCJXZWVrSGVhZENvbG9yIiwiV2Vla0hlYWRCYWNrZ3JvdW5kIiwiU3VuZGF5Q29sb3IiLCJTYXR1cmRheUNvbG9yIiwiV2Vla0RheUNvbG9yIiwiRm9udENvbG9yIiwiVG9kYXlDb2xvciIsIlNlbERhdGVDb2xvciIsIllyU2VsQ29sb3IiLCJNdGhTZWxDb2xvciIsIkhvdmVyQ29sb3IiLCJEaXNhYmxlQ29sb3IiLCJDYWxCZ0NvbG9yIiwidG9wU2VsZWN0b3JCZyIsIldlZWtDaGFyIiwiRGF0ZVNlcGFyYXRvciIsIlNob3dMb25nTW9udGgiLCJTaG93TW9udGhZZWFyIiwiVGhlbWVCZyIsIlByZWNlZGVaZXJvIiwiTW9uZGF5Rmlyc3REYXkiLCJVc2VJbWFnZUZpbGVzIiwiaW1hZ2VGaWxlc1BhdGgiLCJNb250aE5hbWUiLCJXZWVrRGF5TmFtZTEiLCJXZWVrRGF5TmFtZTIiLCJDYWxlbmRhciIsInBEYXRlIiwicEN0cmwiLCJnZXREYXRlIiwiTW9udGgiLCJnZXRNb250aCIsIlllYXIiLCJIb3VycyIsImdldEhvdXJzIiwiZ2V0TWludXRlcyIsIk1pbnV0ZXMiLCJnZXRTZWNvbmRzIiwiU2Vjb25kcyIsIk15V2luZG93IiwiQ3RybCIsIkZvcm1hdCIsIlNlcGFyYXRvciIsIlNob3dUaW1lIiwiU2Nyb2xsZXIiLCJBTW9yUE0iLCJTaG93U2Vjb25kcyIsIkVuYWJsZURhdGVNb2RlIiwiR2V0TW9udGhJbmRleCIsInNob3J0TW9udGhOYW1lIiwiSW5jWWVhciIsIkRlY1llYXIiLCJJbmNNb250aCIsIkRlY01vbnRoIiwiU3dpdGNoTXRoIiwiaW50TXRoIiwiU3dpdGNoWWVhciIsImludFllYXIiLCJTZXRIb3VyIiwiaW50SG91ciIsIk1heEhvdXIiLCJNaW5Ib3VyIiwiSG91ckV4cCIsIlNpbmdsZURpZ2l0IiwiU2V0TWludXRlIiwiaW50TWluIiwiTWF4TWluIiwiTWluTWluIiwiU2luZ2xlRGlnaXQyIiwiTWluRXhwIiwic3RyTWluIiwiU2V0U2Vjb25kIiwiaW50U2VjIiwiTWF4U2VjIiwiTWluU2VjIiwiU2VjRXhwIiwic3RyU2VjIiwiU2V0QW1QbSIsInB2YWx1ZSIsImdldFNob3dIb3VyIiwiZmluYWxIb3VyIiwiZ2V0U2hvd0FNb3JQTSIsIkdldE1vbnRoTmFtZSIsIklzTG9uZyIsIkdldE1vbkRheXMiLCJEYXlzSW5Nb250aCIsIklzTGVhcFllYXIiLCJGb3JtYXREYXRlIiwiTW9udGhEaWdpdCIsIkdlbkNlbGwiLCJwVmFsdWUiLCJwSGlnaExpZ2h0IiwicENvbG9yIiwicENsaWNrYWJsZSIsIlBWYWx1ZSIsIlBDZWxsU3RyIiwiUENsaWNrYWJsZSIsInZUaW1lU3RyIiwiUmVuZGVyQ3NzQ2FsIiwiYk5ld0NhbCIsInZDYWxIZWFkZXIiLCJ2Q2FsRGF0YSIsInZDYWxUaW1lIiwidkNhbENsb3NpbmciLCJ3aW5DYWxEYXRhIiwiQ2FsRGF0ZSIsIlNlbGVjdFN0ciIsInZEYXlDb3VudCIsInZGaXJzdERheSIsIldlZWtEYXlOYW1lIiwic3RyQ2VsbCIsInNob3dIb3VyIiwiU2hvd0Fycm93cyIsIkhvdXJDZWxsV2lkdGgiLCJTZWxlY3RBbSIsIlNlbGVjdFBtIiwiZnVuY0NhbGJhY2siLCJoZWFkSUQiLCJjc3NTdHIiLCJzcGFuIiwic2V0RGF0ZSIsImxhbmd1YWdlIiwicmVsIiwic3R5bGVTaGVldCIsImN1cnNvciIsImJhY2tncm91bmRDb2xvciIsIm92ZXJsYXkiLCJOZXdDc3NDYWwiLCJwRm9ybWF0IiwicFNjcm9sbGVyIiwicFNob3dUaW1lIiwicFRpbWVNb2RlIiwicFNob3dTZWNvbmRzIiwicEVuYWJsZURhdGVNb2RlIiwiU3AxIiwiU3AyIiwidFNwMSIsInRTcDIiLCJzdHJNb250aCIsInN0ckRhdGUiLCJzdHJZZWFyIiwiaW50TW9udGgiLCJZZWFyUGF0dGVybiIsInN0ckhvdXIiLCJzdHJNaW51dGUiLCJzdHJTZWNvbmQiLCJ3aW5IZWlnaHQiLCJsYXN0SW5kZXhPZiIsInN0ckFNUE0iLCJjbG9zZXdpbiIsIk1heFllYXIiLCJiZWZvcmVUb2RheSIsIkNhbElkIiwiYWN0aXZlSWNvbnMiLCJhaUNvdW50TGVuZ2h0IiwiYWlDb3VudCIsIndpbmNsb3NlIiwiY2hhbmdlQm9yZGVyIiwib2xkQmdDb2xvciIsImJhY2tncm91bmQiLCJib3JkZXJDb2xvciIsInNlbGVjdERhdGUiLCJmaW5kUG9zIiwiY3VybGVmdCIsImN1cnRvcCIsInBpY2tJdCIsImV2dCIsIm9iamVjdElEIiwiZGUiLCJvZmZzZXRYIiwib2Zmc2V0WSIsImRyYWdJdCIsIm5leHRTdGVwIiwid2hhdFNwaW5uZXIiLCJzdGFydFNwaW4iLCJ0aGlzTG9vcCIsInN0b3BTcGluIiwiZHJvcEl0Iiwib25tb3VzZWRvd24iLCJ0YXJnZXRDbGFzcyIsInNlbGVjdENsYXNzIiwiZXJyIiwiYmxvY2tFbGxpcHNpcyIsInZhbHVlQWNjZXNzb3IiLCJhbGxCaW5kaW5ncyIsInZpZXdNb2RlbCIsImJpbmRpbmdDb250ZXh0IiwiZm9yZWFjaHByb3AiLCJ0cmFuc2Zvcm1PYmplY3QiLCJwcm9wZXJ0aWVzIiwic29ydEZuIiwidW53cmFwT2JzZXJ2YWJsZSIsIm9iamVjdEZvckVhY2giLCJhbGxCaW5kaW5nc0FjY2Vzc29yIiwiYXBwbHlCaW5kaW5nc1RvTm9kZSIsImZvcmVhY2giLCJjb250cm9sc0Rlc2NlbmRhbnRCaW5kaW5ncyIsImNvbW1vbiIsImNvcHlUb0NsaXBib2FyZCIsImRvbmVDbGFzcyIsImVycm9yQ2xhc3MiLCJhbmltYXRpb25UaW1lIiwiY2xpcGJvYXJkIiwibGF6eUxvYWRlciIsImRhdGVzQXJyIiwiZGF0ZUluZGV4IiwiYnRuIiwibGFiZWwiLCJjbGFzc2lmaWNhdGlvbnNNYXAiLCJfYWxsQmluZGluZ3MiLCJfYmluZGluZ0NvbnRleHQiLCJDdXN0b21TZWxlY3QiLCJvbnNlbGVjdCIsImFuaW1hdGlvblNwZWVkIiwiaXNSZWFkT25seSIsInJhd09wdGlvbnMiLCJERUZBVUxUX1NFTEVDVEVEIiwiY3VyZW50U2VsZWN0RGF0YSIsIm9uRm9jdXMiLCJvbnNlbGVjdE1ldGhvZCIsInNlbGVjdGVkT3B0aW9uIiwibWFwRm9yQ2hlY2tlZCIsImlzRXhwYW5kZWRlZCIsInNldFN1YnNjcmlidGlvbnMiLCJmaWVsZFdhdGNoZXIiLCJpc0RpcnR5IiwiaXNPbmVPcHRpb24iLCJmaW5kRWxlbWVudCIsImxheWVyIiwicmVnaXN0ZXIiLCJDdXN0b21JbnB1dCIsIm9uRm9jdXNNZXRob2QiLCJyZXF1aXJlZCIsImNzc0NsYXNzIiwiZm9jdXNNZXRob2QiLCJwbGFjZWhvbGRlciIsImlzVmlyZ2luIiwibnVsbGFibGVJbnQiLCJBYm91dE1ldGhvZCIsImRvY3VtZW50YXRpb25MaW5rIiwibGluayIsImRlc2NyaXB0aW9uIiwidG9nZ2xlUG9wVXAiLCJvbkFib3V0Q2xpY2siLCJDYXRlZ29yeU1lbnUiLCJzZWxlY3RDYXRlZ29yeSIsImNhdGVnb3J5TmFtZSIsImNoZWNrQWN0aXZlIiwiY2F0ZWdvcmllcyIsImluaXRDYXRlZ29yeSIsImtvQXJyIiwiYWN0aXZlRWxlbSIsIk1ldGhvZHNGaWx0ZXIiLCJzZWxlY3RlZE1ldGhvZE5hbWUiLCJtZXRob2RzVmlld01vZGVsIiwidXBkYXRlTWV0aG9kc01vZGVsIiwiY291bnQiLCJwcm9wZXJ0eSIsInZtTWV0aG9kIiwiUmFkaW9GaWx0ZXIiLCJSQURJT19JRCIsInJhZGlvc01vZGVsIiwidXBkYXRlUmFkaW9zTW9kZWwiLCJjb21wYXJlTWV0aG9kcyIsIm9uY2hhbmdlUmFkaW9zIiwiZ2V0SW5wdXRJZCIsIlBhcmFtc0ZpbHRlciIsInVwZGF0ZVZpZXdNb2RlbCIsInNlbGVjdGVkUGFyYW0iLCJ2bVBhcmFtIiwiaGFzQ2FsZW5kYXIiLCJoYXNQb3BVcCIsInBhcmFtc01vZGVsIiwicGFyYW1JbkZvY3VzIiwicHJlcGFyZVVybFBhaXJzIiwib25QYXJhbXNDbGVhciIsImlzSGlkZGVuIiwiY2hlY2tEaXJ0eSIsIm1hdGNoZWRQYXJhbSIsImRpcnR5Iiwia29PYnMiLCJFcnJvclBvcFVwIiwiZGV0YWlscyIsInBvc3Rib3giLCJlcnJvck9iaiIsIkNhcmRHcm91cCIsImdldENvbmZpZyIsInByZXBhcmVEYXRhIiwiX0NPTkZJRyIsImdyb3VwSW5kZXgiLCJzZWN0aW9uSW5kZXgiLCJjb2xvckNsYXNzIiwiZ2V0TW9yZSIsImdldFBhZ2luZ0luZm8iLCJjb2xsYXBzZUlkIiwiZ2V0Q29sbGFwc2VJZCIsIl9oYXNFdmVudHNQYW5lbCIsImkxIiwiaTIiLCJ1bndyYXBwT2JqZWN0cyIsInJlbW92ZURlcHJlY2F0ZWQiLCJ3cmFwcFByaW1pdGl2ZXMiLCJfcHJvcFRpdGxlIiwibmV3RGF0YSIsImRlcHJlY2F0ZWQiLCJ1bndyYXBwIiwiZGVlcFByb3AiLCJyYXdGaWx0ZXIiLCJtZXRob2RDb25maWciLCJfR0xPQkFMX0NPTkZJRyIsInBhZ2VPYmoiLCJwYWdlUGFyYW0iLCJjYXJkU2l6ZSIsIlBhbmVsIiwiJGRhdGEiLCJwYW5lbEdyb3VwIiwiJGluZGV4IiwicGFuZWxDb25maWciLCJpc0V4cGFuZGVkIiwiaXNBY3RpdmUiLCJzdWJqZWN0SUQiLCJzdWJDb25maWciLCJQYWdpbmF0aW9uIiwibnVtYmVyIiwicmVxdWVzdEJ0biIsIlBhbmVsSGVhZGluZyIsInNldEFjdGl2ZSIsIl9wYW5lbE5hbWUiLCJzdWJqZWN0SWQiLCJyZXF1ZXN0IiwiYW5vdGhlclJlcXVlc3RDb2xvciIsImdldFJhbmRvbUNvbG9yIiwiZ2V0RGVlcFByb3AiLCJvYmplY3QiLCJhbm90aGVyUmVxdWVzdCIsImNvbG9yIiwicHVibGlzaE9uIiwicGF0aCIsImpzb25ITCIsImNvbG9yc1NlcnZpY2UiLCJDT05GSUdfVVJMIiwicGFyc2VEYXRhIiwicmVzb3VyY2VzRWwiLCJyZXMiLCJyZXNvdXJjZSIsIm1ldGhvZEVsZW0iLCJwYXIiLCJpc1NlbGVjdCIsInBhcmFtZXRlciIsImRvYyIsIkFMTCIsInJlYWRGcm9tV0FETCIsInJlc3BvbnNlIiwiaG9zdG5hbWUiLCJwb3J0IiwiV29ya2VyIiwiYW5pbVRpbWUiLCJ3b3JrZXIiLCJvbm1lc3NhZ2UiLCJqc29uQ29kZUNvbnRhaW5lckV4cGFuZGVkIiwiJHNlbGYiLCJqc29uQ29kZUNvbnRhaW5lckNvbGxhcHNlZCIsIm9uZXJyb3IiLCJwb3N0TWVzc2FnZSIsIl9fd2VicGFja19wdWJsaWNfcGF0aF9fIiwibnVtIiwicHJlZml4IiwiQ29sb3JzU2VydmljZSIsIk5VTSIsIlBSRUZJWCIsImNvbG9ycyIsImdldENvbG9ycyIsInJhbmRvbU51bWJlciIsImdldFJhbmRvbUludCIsIlJlc3RTZXJ2aWNlIiwicmVzT2JqIiwicmVxIiwicmVxdWVzdHMiLCJsYXN0UmVzcG9uc2UiLCJzdWJzY3JpYmVUbyIsImFub3RoZXJSZXNwb25zZSIsInByZXBhcmVVcmwiLCJhamF4U2VydmljZSIsIl9kb21haW4iLCJfcGF0aCIsIl9zZWxlY3RlZFBhcmFtcyIsInJlcGxhY2VtZW50IiwiZG9tYWluIiwidGVtcGxhdGVzQXJyIiwiT2JqZWN0UGFuZWxCb2R5IiwiY2FyZEluZGV4IiwiX2FsbEluc2lkZSIsInNvcnRCeUNvbmZpZyIsInNlbmRJZCIsInBhbmVsIiwib25FbnRlcktleURvd24iLCJwYWdlTnVtYmVyIiwiQXJyYXlQYW5lbEJvZHkiLCJzbGlkZXIiLCJSZXF1ZXN0TGlzdENvbXBvbmVudCIsImNsZWFyQnRuSXNWaXNpYmxlIiwiX2lzVmlzaWJsZSIsInVwZGF0ZU1vZGVsIiwibmV3TW9kZWwiLCJuZXdPYmoiLCJpc0FjdGl2ZU1vcmVNZW51IiwiY29waWVkRm9yU2hhcmUiLCJwYXJhbXNBcmVTZXRlZCIsImNvcGllZFVybCIsInJlc0hUTUwiLCJ0aW1lcyIsImluZm8iLCJSZXF1ZXN0Q29tcG9uZW50IiwiaGFzUmVzcG9uc2UiLCJyb290c2V0UGFyYW1zIiwiaWRzIiwiY29udHJvbHMiLCJyYXdXaW5kb3ciLCJSZXNwb25zZUNvbXBvbmVudCIsImJyZWFkY3J1YnNBcnIiLCJicmVhZGNydW1icyIsImF0dHJzIiwidGFicyIsImJsb2NrcyIsInZpZXciLCJwR3JvdXAiLCJjdXJyZW50Iiwic3RyIiwiY3VycmVudFNsaWRlciIsImNvbXBvbmVudCIsImN1cnNsaWNrIiwiYnVpbGRCcmVhZGNydW1icyJdLCJtYXBwaW5ncyI6Ijs7QUFBQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx1QkFBZTtBQUNmO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUMvQkE7O0tBQVlBLE87O0FBQ1o7O0tBQVlDLGM7O0FBQ1o7O0tBQVlDLFU7O0FBQ1o7O0tBQVlDLFE7Ozs7OztBQUVaOzs7O0FBWkE7Ozs7OztBQU1BO0FBVUFDLFFBQU9DLE9BQVAsR0FBaUIsVUFBU0MsQ0FBVCxFQUFZQyxDQUFaLEVBQWU7QUFDL0IsTUFBSSxDQUFDLFFBQU9ELENBQVAsdURBQU9BLENBQVAsT0FBYSxRQUFiLElBQXlCQSxLQUFLLElBQS9CLEtBQXdDLENBQUNDLENBQTdDLEVBQWdEO0FBQUM7QUFBUTtBQUN6REEsTUFBSUEsRUFBRUMsT0FBRixDQUFVLFlBQVYsRUFBd0IsS0FBeEIsQ0FBSixDQUYrQixDQUVLO0FBQ3BDRCxNQUFJQSxFQUFFQyxPQUFGLENBQVUsS0FBVixFQUFpQixFQUFqQixDQUFKLENBSCtCLENBR0s7QUFDcEMs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Q0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQSxxRUFBb0U7QUFDcEU7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2IsVUFBUzs7QUFFVDtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYixVQUFTOztBQUVUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7QUFDQSw0REFBMkQscUNBQXFDLEVBQUU7QUFDbEc7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFpQjtBQUNqQixjQUFhO0FBQ2I7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBLGNBQWE7QUFDYjtBQUNBLGNBQWE7QUFDYjtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0EsVUFBUzs7QUFFVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUEyQjtBQUMzQjtBQUNB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O0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1QsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx1QkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUErQztBQUMvQyx1RkFBc0YscUJBQXFCO0FBQzNHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2IsOENBQTZDO0FBQzdDO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztB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Q0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx5Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFtQyxvQkFBb0I7QUFDdkQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBMkQsa0JBQWtCO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBO0FBQ0EseUJBQXdCO0FBQ3hCLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlDQUFnQyw0QkFBNEI7QUFDNUQ7QUFDQSxNQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQStDO0FBQy9DO0FBQ0EsVUFBUztBQUNUO0FBQ0EsNEZBQTJGLHdCQUF3QjtBQUNuSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYixVQUFTO0FBQ1Q7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGdEQUErQzs7QUFFL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWlCO0FBQ2pCO0FB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Q0EsVUFBUzs7QUFFVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0EsVUFBUztBQUNULE1BQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxtREFBa0Q7QUFDbEQ7QUFDQTtBQUNBLGNBQWE7QUFDYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvRUFBbUU7QUFDbkU7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBaUIsbUVBQW1FO0FBQ3BGO0FBQ0EsbURBQWtEO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBZ0I7QUFDaEIsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0VBQWlFLGlCQUFpQjtBQUNsRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBaUI7QUFDakI7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBb0IscUNBQXFDO0FBQ3pELDBCQUF5QixxQkFBcUI7QUFDOUM7QUFDQTtBQUNBO0FBQ0EsT0FBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTTtBQUNOO0FBQ0E7QUFDQSxPQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBb0MsdUNBQXVDO0FBQzNFO0FBQ0EsUUFBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBZ0MsT0FBTztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBbUMsT0FBTztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW1DLE9BQU87QUFDMUM7QUFDQSx1REFBc0QsT0FBTztBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNENBQTJDLE9BQU87QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFrQyxPQUFPO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBLDRDQUEyQyxPQUFPO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QTtBQUNBO0FBQ0E7QUFDQSxPQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFvRCxhQUFhO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0RUFBMkU7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBOEI7QUFDOUIsZ0NBQStCLHFCQUFxQixFQUFFO0FBQ3RELFFBQU87QUFDUDtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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SUFBRzs7QUFFSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDhGQUE2Rjs7QUFFN0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTtBQUNGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLFdBQVU7QUFDVjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTRCOztBQUU1QixRQUFPLFNBQVM7O0FBRWhCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsSUFBRztBQUNIO0FBQ0E7QUFDQSxrQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDOztBQUVEO0FBQ0E7QUFDQSxFQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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RUFBc0N0eEMsSUFBSWtpRSxXQUFXMUIsVUFBckQsRUFBaUV4Z0UsR0FBakUsRUFBc0U7QUFDckVtcEUsa0JBQWN2MEIsS0FBZCxDQUFvQixhQUFwQixFQUFtQzUwQyxDQUFuQyxFQUFzQyxLQUF0QztBQUNBO0FBQ0Q7QUFDQXFZLGNBQVcsWUFBTTtBQUNoQjh3RCxrQkFBY3YwQixLQUFkLENBQW9CLFdBQXBCO0FBQ0EsSUFGRCxFQUVHLEdBRkg7QUFHQSxHOzs7O0FBaUJGM3ZDLFFBQU9DLE9BQVAsR0FBaUI1RCxHQUFHL0IsVUFBSCxDQUFjcTlELFFBQWQsQ0FBdUIsb0JBQXZCLEVBQTZDO0FBQzdENUMsYUFBV3lPLGlCQURrRDtBQUU3RGwvQiw4ckVBRjZELEVBQTdDLENBQWpCLEMiLCJmaWxlIjoic2NyaXB0LmpzIiwic291cmNlc0NvbnRlbnQiOlsiIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuIFx0dmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcblxuIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbiBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblxuIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbiBcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pXG4gXHRcdFx0cmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XG5cbiBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbiBcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xuIFx0XHRcdGV4cG9ydHM6IHt9LFxuIFx0XHRcdGlkOiBtb2R1bGVJZCxcbiBcdFx0XHRsb2FkZWQ6IGZhbHNlXG4gXHRcdH07XG5cbiBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4gXHRcdG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXG4gXHRcdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcbiBcdFx0bW9kdWxlLmxvYWRlZCA9IHRydWU7XG5cbiBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbiBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuIFx0fVxuXG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcblxuIFx0Ly8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cbiBcdF9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiXCI7XG5cbiBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuIFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oMCk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gd2VicGFjay9ib290c3RyYXAgMWQxZGZlMmVhNTk1NTZlY2ZjNDAiLCIvKipcclxuICogTWFpbiBmaWxlIGZvciBBcGkgRXhwbHJlciB2Mi4wXHJcbiAqIEZvciBkZXZlbG9wbWVudCBwbGVhc2UgdXNlIFdlYnBhY2sgdG8gYnVuZGxlIGFsbCBtb2R1bGVzXHJcbiAqIEl0IGNhbiBiZSBtYWRlIHVzaW5nIG5wbSBzY3JpcHRzIGNtZCAtICd3ZWJwYWNrJ1xyXG4gKi9cclxuXHJcbi8vIGN1c3RvbSBiaW5kaW5nc1xyXG5pbXBvcnQgKiBhcyBtb2R1bGVzIGZyb20gJy4vbW9kdWxlcyc7XHJcbmltcG9ydCAqIGFzIGN1c3RvbUJpbmRpbmdzIGZyb20gJy4vY3VzdG9tQmluZGluZ3MnO1xyXG5pbXBvcnQgKiBhcyBjb21wb25lbnRzIGZyb20gJy4vY29tcG9uZW50cyc7XHJcbmltcG9ydCAqIGFzIHNlcnZpY2VzIGZyb20gJy4vc2VydmljZXMnO1xyXG5cclxuLyoqXHJcbiAqIEdldHMgZGVlcCBwcm9wXHJcbiAqIEByZXR1cm5zIHsqW119XHJcbiAqL1xyXG5PYmplY3QuZ2V0UHJvcCA9IGZ1bmN0aW9uKG8sIHMpIHtcclxuXHRpZiAoKHR5cGVvZiBvICE9PSAnb2JqZWN0JyB8fCBvID09IG51bGwpICYmICFzKSB7cmV0dXJuO31cclxuXHRzID0gcy5yZXBsYWNlKC9cXFsoXFx3KylcXF0vZywgJy4kMScpOyAvLyBjb252ZXJ0IGluZGV4ZXMgdG8gcHJvcGVydGllc1xyXG5cdHMgPSBzLnJlcGxhY2UoL15cXC4vLCAnJyk7ICAgICAgICAgICAvLyBzdHJpcCBhIGxlYWRpbmcgZG90XHJcblx0dmFyIGEgPSBzLnNwbGl0KCcuJyk7XHJcblx0Zm9yICh2YXIgaSA9IDAsIG4gPSBhLmxlbmd0aDsgaSA8IG47ICsraSkge1xyXG5cdFx0dmFyIGsgPSBhW2ldO1xyXG5cdFx0aWYgKG8gJiYgayBpbiBvKSB7XHJcblx0XHRcdG8gPSBvW2tdO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cdH1cclxuXHRyZXR1cm4gbztcclxufTtcclxuXHJcbmNsYXNzIEFwcFZpZXdNb2RlbCB7XHJcblx0Y29uc3RydWN0b3Ioe2Jhc2UgPSB7fSwgYXBpS2V5LCBjb25maWcsIHJlc3R9KSB7XHJcblx0XHR0aGlzLmJhc2UgPSBiYXNlO1xyXG5cdFx0dGhpcy5hcGlLZXkgPSBhcGlLZXk7XHJcblx0XHR0aGlzLmNvbmZpZyA9IGNvbmZpZztcclxuXHRcdHRoaXMucmVzdFNlcnZpY2UgPSByZXN0O1xyXG5cclxuXHRcdGxldCBwYXJzZWRVcmwgPSB0aGlzLnBhcnNlVXJsKCk7XHJcblx0XHQvLyBvYnNlcnZhYmxlc1xyXG5cdFx0dGhpcy5zZWxlY3RlZENhdGVnb3J5ID0ga28ub2JzZXJ2YWJsZShwYXJzZWRVcmwuYXBpQ2F0ZWdvcnkgfHwgJycpLnN5bmNXaXRoKCdTRUxFQ1RFRF9DQVRFR09SWScpO1xyXG5cdFx0dGhpcy5zZWxlY3RlZE1ldGhvZFR5cGUgPSBrby5vYnNlcnZhYmxlKCdBTEwnKS5zeW5jV2l0aCgnU0VMRUNURURfTUVUSE9EX1RZUEUnKTtcclxuXHRcdHRoaXMuc2VsZWN0ZWRNZXRob2QgPSBrby5vYnNlcnZhYmxlKHBhcnNlZFVybC5tZXRob2RJZCB8fCAnJykuc3luY1dpdGgoJ1NFTEVDVEVEX01FVEhPRCcpO1xyXG5cdFx0dGhpcy5zZWxlY3RlZFBhcmFtcyA9IGtvLm9ic2VydmFibGVBcnJheShbXSkuc3luY1dpdGgoJ1NFTEVDVEVEX1BBUkFNUycpO1xyXG5cdFx0dGhpcy5zZWxlY3RlZE1ldGhvZERhdGEgPSBrby5vYnNlcnZhYmxlKHRoaXMuZ2V0TWV0aG9kRGF0YSh7fSkpO1xyXG5cclxuXHRcdHRoaXMuaW5pdFZhbGlkYXRpb24oKTtcclxuXHJcblx0XHQvLyBjb21wdXRlZFxyXG5cdFx0dGhpcy5zZW5kQnV0dG9uVGV4dCA9IGtvLnB1cmVDb21wdXRlZCgoKSA9PiBrby51bndyYXAodGhpcy5zZWxlY3RlZE1ldGhvZERhdGEpLm1ldGhvZCk7XHJcblxyXG5cdFx0dGhpcy5zaGFyZVBhdGggPSBrby5wdXJlQ29tcHV0ZWQoKCkgPT4gdGhpcy5mb3JtRGVlcExpbmtpbmdVcmwoKSk7XHJcblxyXG5cdFx0dGhpcy5zZWxlY3RlZE1ldGhvZC5zdWJzY3JpYmUodmFsID0+IHtcclxuXHRcdFx0dGhpcy52YWxpZGF0aW9uTW9kZWwoJC5leHRlbmQoe30sIGtvLnVud3JhcCh0aGlzLmFwaUtleVZhbGlkYXRpb25Nb2RlbCkpKTtcclxuXHRcdFx0dGhpcy5zZWxlY3RlZE1ldGhvZERhdGEodGhpcy5nZXRNZXRob2REYXRhKHttZXRob2RJZDogdmFsfSkpO1xyXG5cdFx0fSk7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBWYWxpZGF0aW9uIHdhdGNoZXJzIGFuZCBsb2dpY1xyXG5cdCAqL1xyXG5cdGluaXRWYWxpZGF0aW9uKCkge1xyXG5cdFx0dGhpcy5hcGlLZXlWYWxpZGF0aW9uTW9kZWwgPSBrby5vYnNlcnZhYmxlKHt9KTtcclxuXHRcdHRoaXMudmFsaWRhdGlvbk1vZGVsID0ga28ub2JzZXJ2YWJsZSh7fSk7XHJcblxyXG5cdFx0dGhpcy5zZW5kQnRuVmFsaWRhdGlvblRleHQgPSBrby5vYnNlcnZhYmxlKCcnKTtcclxuXHRcdHRoaXMuZm9ybUlzVmFsaWQgPSBrby5vYnNlcnZhYmxlKHRydWUpO1xyXG5cdFx0a28uY29tcHV0ZWQoKCkgPT4ge1xyXG5cdFx0XHRsZXQgdmFsaWRhdGlvbk1vZGVsID0ga28udmFsaWRhdGVkT2JzZXJ2YWJsZSgkLmV4dGVuZCh7fSwga28udW53cmFwKHRoaXMudmFsaWRhdGlvbk1vZGVsKSwga28udW53cmFwKHRoaXMuYXBpS2V5VmFsaWRhdGlvbk1vZGVsKSkpO1xyXG5cdFx0XHRsZXQgdmFsaWRhdGlvbkZsYWcgPSB2YWxpZGF0aW9uTW9kZWwuaXNWYWxpZCgpIHx8ICEkKCcuY3VzdG9tLWlucHV0X19maWVsZC5ub3QtdmFsaWQnKS5sZW5ndGg7XHJcblx0XHRcdHRoaXMuc2VuZEJ0blZhbGlkYXRpb25UZXh0KHZhbGlkYXRpb25GbGFnID8gJyc6IHRoaXMudmFsaWRhdGlvblRleHQpO1xyXG5cdFx0XHR0aGlzLmZvcm1Jc1ZhbGlkKHZhbGlkYXRpb25GbGFnKTtcclxuXHRcdH0pO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogU2VuZCByZXF1ZXN0IG1ldGhvZFxyXG5cdCAqL1xyXG5cdG9uQ2xpY2tTZW5kQnRuKCkge1xyXG5cdFx0bGV0IG1vZGVsID0ga28udmFsaWRhdGVkT2JzZXJ2YWJsZSgkLmV4dGVuZCh7fSwga28udW53cmFwKHRoaXMudmFsaWRhdGlvbk1vZGVsKSwga28udW53cmFwKHRoaXMuYXBpS2V5VmFsaWRhdGlvbk1vZGVsKSkpO1xyXG5cclxuXHRcdGlmIChtb2RlbC5pc1ZhbGlkKCkpIHtcclxuXHRcdFx0dGhpcy5yZXN0U2VydmljZS5zZW5kUmVxdWVzdCgpO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0dGhpcy5mb3JtSXNWYWxpZChmYWxzZSk7XHJcblx0XHRcdHRoaXMuc2VuZEJ0blZhbGlkYXRpb25UZXh0KHRoaXMudmFsaWRhdGlvblRleHQpO1xyXG5cdFx0XHRtb2RlbC5lcnJvcnMuc2hvd0FsbE1lc3NhZ2VzKCk7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHRmb3JtRGVlcExpbmtpbmdVcmwoKSB7XHJcblx0XHRsZXQgbG9jYXRpb24gPSB3aW5kb3cubG9jYXRpb247XHJcblx0XHRsZXQgY2F0ZWdvcnkgPSBrby51bndyYXAodGhpcy5zZWxlY3RlZENhdGVnb3J5KTtcclxuXHRcdGxldCBtZXRob2QgPSBrby51bndyYXAodGhpcy5zZWxlY3RlZE1ldGhvZCk7XHJcblx0XHRsZXQgcGFyYW1zID0ga28udW53cmFwKHRoaXMuc2VsZWN0ZWRQYXJhbXMpO1xyXG5cclxuXHRcdGxldCBxdWVyeXMgPSBbXHJcblx0XHRcdGBhcGlDYXRlZ29yeT0ke2VuY29kZVVSSShjYXRlZ29yeSl9YCxcclxuXHRcdFx0YG1ldGhvZElkPSR7ZW5jb2RlVVJJKG1ldGhvZCl9YFxyXG5cdFx0XTtcclxuXHJcblx0XHRwYXJhbXMubWFwKHBhcmFtID0+IHtcclxuXHRcdFx0bGV0IHZhbHVlID0ga28udW53cmFwKHBhcmFtLnZhbHVlKTtcclxuXHRcdFx0bGV0IGRlZmF1bHRWYWx1ZSA9IGtvLnVud3JhcChwYXJhbS5kZWZhdWx0KTtcclxuXHRcdFx0cXVlcnlzLnB1c2goYCR7cGFyYW0ubmFtZX09JHt2YWx1ZSAhPT0gJycgPyB2YWx1ZSA6IGRlZmF1bHRWYWx1ZX1gKTsgLy90b2RvOiByZW1vdmUgZGVmYXVsdCBmcm9tIGhlcmUgd2hlbiBzZXQgdXAgaXQgaW4gc291cmNlIGxpa2UgdmFsdWUgYnkgZGVmYXVsdFxyXG5cdFx0XHRyZXR1cm4gcGFyYW07XHJcblx0XHR9KTtcclxuXHJcblx0XHRyZXR1cm4gYCR7bG9jYXRpb24ub3JpZ2lufSR7bG9jYXRpb24ucGF0aG5hbWUucmVwbGFjZSgvXFwvJC9nbWksICcnKX0/JHtxdWVyeXMuam9pbignJicpfWBcclxuXHR9XHJcblxyXG5cdC8vcmVzdCBzZXJ2aWNlXHJcblx0Z2V0TWV0aG9kRGF0YSh7YXBpQ2F0ZWdvcnksIHR5cGUsIG1ldGhvZElkfSkge1xyXG5cdFx0bGV0IGNhdGVnb3J5ID0ga28udW53cmFwKGFwaUNhdGVnb3J5IHx8IHRoaXMuc2VsZWN0ZWRDYXRlZ29yeSk7XHJcblx0XHRsZXQgbWV0aG9kVHlwZSA9IGtvLnVud3JhcCh0eXBlIHx8IHRoaXMuc2VsZWN0ZWRNZXRob2RUeXBlIHx8ICdBTEwnKTtcclxuXHRcdGxldCBtZXRob2QgPSBrby51bndyYXAobWV0aG9kSWQgfHwgdGhpcy5zZWxlY3RlZE1ldGhvZCk7XHJcblx0XHRyZXR1cm4gdGhpcy5iYXNlW2NhdGVnb3J5XSAmJiB0aGlzLmJhc2VbY2F0ZWdvcnldW21ldGhvZFR5cGVdICYmIHRoaXMuYmFzZVtjYXRlZ29yeV1bbWV0aG9kVHlwZV1bbWV0aG9kXSB8fCB7fTtcclxuXHR9XHJcblxyXG5cdC8vKioqKioqKioqKlxyXG5cdHBhcnNlVXJsKCkge1xyXG5cdFx0bGV0IGxvY2F0aW9uID0gd2luZG93LmxvY2F0aW9uLnNlYXJjaDtcclxuXHJcblx0XHRpZiAobG9jYXRpb24pIHtcclxuXHRcdFx0dmFyIHF1ZXJ5cyA9IGxvY2F0aW9uLnJlcGxhY2UoL15cXD8vZywgJycpLnNwbGl0KCcmJyk7XHJcblx0XHRcdHZhciBvYmogPSB7XHJcblx0XHRcdFx0YXBpQ2F0ZWdvcnk6ICcnLFxyXG5cdFx0XHRcdG1ldGhvZElkOiAnJyxcclxuXHRcdFx0XHRwYXJhbWV0ZXJzOiBbXVxyXG5cdFx0XHR9O1xyXG5cclxuXHRcdFx0bGV0IGdsb2JhbFF1ZXJ5T2JqID0gd2luZG93LmxvY2F0aW9uLnF1ZXJ5ID0ge307XHJcblx0XHRcdHF1ZXJ5cy5tYXAocXVlcnkgPT4ge1xyXG5cdFx0XHRcdGxldCBba2V5LCB2YWxdID0gZGVjb2RlVVJJKHF1ZXJ5KS5zcGxpdCgnPScpO1xyXG5cclxuXHRcdFx0XHRpZiAoT2JqZWN0LmtleXMob2JqKS5pbmRleE9mKGtleSkgIT09IC0xKSB7XHJcblx0XHRcdFx0XHR0cnkge1xyXG5cdFx0XHRcdFx0XHRvYmpba2V5XSA9IGdsb2JhbFF1ZXJ5T2JqW2tleV0gPSBKU09OLnBhcnNlKHZhbCk7XHJcblx0XHRcdFx0XHR9IGNhdGNoIChleGNlcHRpb25fdmFyKSB7XHJcblx0XHRcdFx0XHRcdG9ialtrZXldID0gZ2xvYmFsUXVlcnlPYmpba2V5XSA9IHZhbDtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0dHJ5IHtcclxuXHRcdFx0XHRcdFx0Z2xvYmFsUXVlcnlPYmpba2V5XSA9IEpTT04ucGFyc2UodmFsKTtcclxuXHRcdFx0XHRcdH0gY2F0Y2ggKGV4Y2VwdGlvbl92YXIpIHtcclxuXHRcdFx0XHRcdFx0Z2xvYmFsUXVlcnlPYmpba2V5XSA9IHZhbDtcclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRvYmoucGFyYW1ldGVycy5wdXNoKHtcclxuXHRcdFx0XHRcdFx0bmFtZToga2V5LFxyXG5cdFx0XHRcdFx0XHR2YWx1ZTogZ2xvYmFsUXVlcnlPYmpba2V5XVxyXG5cdFx0XHRcdFx0fSlcclxuXHRcdFx0XHR9XHJcblx0XHRcdH0pO1xyXG5cclxuXHRcdFx0bGV0IG1ldGhvZERhdGEgPSB0aGlzLmdldE1ldGhvZERhdGEob2JqKTtcclxuXHRcdFx0bGV0IHBhcmFtZXRlcnMgPSBtZXRob2REYXRhLnBhcmFtZXRlcnM7XHJcblxyXG5cdFx0XHRvYmoucGFyYW1ldGVycy5tYXAob2JqID0+IHtcclxuXHRcdFx0XHRwYXJhbWV0ZXJzW29iai5uYW1lXS52YWx1ZSA9IG9iai52YWx1ZTtcclxuXHRcdFx0XHRyZXR1cm4gb2JqO1xyXG5cdFx0XHR9KTtcclxuXHRcdFx0b2JqLnBhcmFtZXRlcnMgPSBwYXJhbWV0ZXJzO1xyXG5cdFx0XHRyZXR1cm4gb2JqO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHt9O1xyXG5cdH07XHJcblx0Ly8qKioqKioqKioqXHJcblx0c2V0UGFyYW1zID0gKHtjYXRlZ29yeSwgbWV0aG9kID0gJ0FMTCcsIG1ldGhvZElkLCBwYXJhbXN9KSA9PiB7XHJcblx0XHR0aGlzLnNlbGVjdGVkQ2F0ZWdvcnkoY2F0ZWdvcnkpO1xyXG5cdFx0dGhpcy5zZWxlY3RlZE1ldGhvZFR5cGUobWV0aG9kKTtcclxuXHRcdHRoaXMuc2VsZWN0ZWRNZXRob2QobWV0aG9kSWQpO1xyXG5cdFx0dGhpcy5zZWxlY3RlZFBhcmFtcy5ub3RpZnlTdWJzY3JpYmVycyhwYXJhbXMsICdwYXJhbXNTZXQnKTtcclxuXHR9XHJcblxyXG5cdGdldCB2YWxpZGF0aW9uVGV4dCgpIHtcclxuXHRcdHJldHVybiAnUGxlYXNlIHNvbHZlIGZvcm0gdmFsaWRhdGlvbiBpc3N1ZXMnO1xyXG5cdH1cclxufVxyXG5cclxuLyoqXHJcbiAqIEFjdGl2YXRlcyBrbm9ja291dC5qc1xyXG4gKi9cclxua28uYXBwbHlCaW5kaW5ncyhuZXcgQXBwVmlld01vZGVsKHNlcnZpY2VzKSk7XHJcblxyXG4vKipcclxuICogZXhwb3J0cyBnbG9iYWwgdmFyaWFibGVcclxuICovXHJcbm1vZHVsZS5leHBvcnRzID0gc2VydmljZXMuYmFzZTtcclxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc2NyaXB0cy9hcGktZXhwbG9yZXIvdjIvc3JjL21haW4uZXM2LmpzIiwiLyohIGpRdWVyeSB2MS4xMS4zIHwgKGMpIDIwMDUsIDIwMTUgalF1ZXJ5IEZvdW5kYXRpb24sIEluYy4gfCBqcXVlcnkub3JnL2xpY2Vuc2UgKi9cclxuIWZ1bmN0aW9uKGEsYil7XCJvYmplY3RcIj09dHlwZW9mIG1vZHVsZSYmXCJvYmplY3RcIj09dHlwZW9mIG1vZHVsZS5leHBvcnRzP21vZHVsZS5leHBvcnRzPWEuZG9jdW1lbnQ/YihhLCEwKTpmdW5jdGlvbihhKXtpZighYS5kb2N1bWVudCl0aHJvdyBuZXcgRXJyb3IoXCJqUXVlcnkgcmVxdWlyZXMgYSB3aW5kb3cgd2l0aCBhIGRvY3VtZW50XCIpO3JldHVybiBiKGEpfTpiKGEpfShcInVuZGVmaW5lZFwiIT10eXBlb2Ygd2luZG93P3dpbmRvdzp0aGlzLGZ1bmN0aW9uKGEsYil7dmFyIGM9W10sZD1jLnNsaWNlLGU9Yy5jb25jYXQsZj1jLnB1c2gsZz1jLmluZGV4T2YsaD17fSxpPWgudG9TdHJpbmcsaj1oLmhhc093blByb3BlcnR5LGs9e30sbD1cIjEuMTEuM1wiLG09ZnVuY3Rpb24oYSxiKXtyZXR1cm4gbmV3IG0uZm4uaW5pdChhLGIpfSxuPS9eW1xcc1xcdUZFRkZcXHhBMF0rfFtcXHNcXHVGRUZGXFx4QTBdKyQvZyxvPS9eLW1zLS8scD0vLShbXFxkYS16XSkvZ2kscT1mdW5jdGlvbihhLGIpe3JldHVybiBiLnRvVXBwZXJDYXNlKCl9O20uZm49bS5wcm90b3R5cGU9e2pxdWVyeTpsLGNvbnN0cnVjdG9yOm0sc2VsZWN0b3I6XCJcIixsZW5ndGg6MCx0b0FycmF5OmZ1bmN0aW9uKCl7cmV0dXJuIGQuY2FsbCh0aGlzKX0sZ2V0OmZ1bmN0aW9uKGEpe3JldHVybiBudWxsIT1hPzA+YT90aGlzW2ErdGhpcy5sZW5ndGhdOnRoaXNbYV06ZC5jYWxsKHRoaXMpfSxwdXNoU3RhY2s6ZnVuY3Rpb24oYSl7dmFyIGI9bS5tZXJnZSh0aGlzLmNvbnN0cnVjdG9yKCksYSk7cmV0dXJuIGIucHJldk9iamVjdD10aGlzLGIuY29udGV4dD10aGlzLmNvbnRleHQsYn0sZWFjaDpmdW5jdGlvbihhLGIpe3JldHVybiBtLmVhY2godGhpcyxhLGIpfSxtYXA6ZnVuY3Rpb24oYSl7cmV0dXJuIHRoaXMucHVzaFN0YWNrKG0ubWFwKHRoaXMsZnVuY3Rpb24oYixjKXtyZXR1cm4gYS5jYWxsKGIsYyxiKX0pKX0sc2xpY2U6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5wdXNoU3RhY2soZC5hcHBseSh0aGlzLGFyZ3VtZW50cykpfSxmaXJzdDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmVxKDApfSxsYXN0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZXEoLTEpfSxlcTpmdW5jdGlvbihhKXt2YXIgYj10aGlzLmxlbmd0aCxjPSthKygwPmE/YjowKTtyZXR1cm4gdGhpcy5wdXNoU3RhY2soYz49MCYmYj5jP1t0aGlzW2NdXTpbXSl9LGVuZDpmdW5jdGlvbigpe3JldHVybiB0aGlzLnByZXZPYmplY3R8fHRoaXMuY29uc3RydWN0b3IobnVsbCl9LHB1c2g6Zixzb3J0OmMuc29ydCxzcGxpY2U6Yy5zcGxpY2V9LG0uZXh0ZW5kPW0uZm4uZXh0ZW5kPWZ1bmN0aW9uKCl7dmFyIGEsYixjLGQsZSxmLGc9YXJndW1lbnRzWzBdfHx7fSxoPTEsaT1hcmd1bWVudHMubGVuZ3RoLGo9ITE7Zm9yKFwiYm9vbGVhblwiPT10eXBlb2YgZyYmKGo9ZyxnPWFyZ3VtZW50c1toXXx8e30saCsrKSxcIm9iamVjdFwiPT10eXBlb2YgZ3x8bS5pc0Z1bmN0aW9uKGcpfHwoZz17fSksaD09PWkmJihnPXRoaXMsaC0tKTtpPmg7aCsrKWlmKG51bGwhPShlPWFyZ3VtZW50c1toXSkpZm9yKGQgaW4gZSlhPWdbZF0sYz1lW2RdLGchPT1jJiYoaiYmYyYmKG0uaXNQbGFpbk9iamVjdChjKXx8KGI9bS5pc0FycmF5KGMpKSk/KGI/KGI9ITEsZj1hJiZtLmlzQXJyYXkoYSk/YTpbXSk6Zj1hJiZtLmlzUGxhaW5PYmplY3QoYSk/YTp7fSxnW2RdPW0uZXh0ZW5kKGosZixjKSk6dm9pZCAwIT09YyYmKGdbZF09YykpO3JldHVybiBnfSxtLmV4dGVuZCh7ZXhwYW5kbzpcImpRdWVyeVwiKyhsK01hdGgucmFuZG9tKCkpLnJlcGxhY2UoL1xcRC9nLFwiXCIpLGlzUmVhZHk6ITAsZXJyb3I6ZnVuY3Rpb24oYSl7dGhyb3cgbmV3IEVycm9yKGEpfSxub29wOmZ1bmN0aW9uKCl7fSxpc0Z1bmN0aW9uOmZ1bmN0aW9uKGEpe3JldHVyblwiZnVuY3Rpb25cIj09PW0udHlwZShhKX0saXNBcnJheTpBcnJheS5pc0FycmF5fHxmdW5jdGlvbihhKXtyZXR1cm5cImFycmF5XCI9PT1tLnR5cGUoYSl9LGlzV2luZG93OmZ1bmN0aW9uKGEpe3JldHVybiBudWxsIT1hJiZhPT1hLndpbmRvd30saXNOdW1lcmljOmZ1bmN0aW9uKGEpe3JldHVybiFtLmlzQXJyYXkoYSkmJmEtcGFyc2VGbG9hdChhKSsxPj0wfSxpc0VtcHR5T2JqZWN0OmZ1bmN0aW9uKGEpe3ZhciBiO2ZvcihiIGluIGEpcmV0dXJuITE7cmV0dXJuITB9LGlzUGxhaW5PYmplY3Q6ZnVuY3Rpb24oYSl7dmFyIGI7aWYoIWF8fFwib2JqZWN0XCIhPT1tLnR5cGUoYSl8fGEubm9kZVR5cGV8fG0uaXNXaW5kb3coYSkpcmV0dXJuITE7dHJ5e2lmKGEuY29uc3RydWN0b3ImJiFqLmNhbGwoYSxcImNvbnN0cnVjdG9yXCIpJiYhai5jYWxsKGEuY29uc3RydWN0b3IucHJvdG90eXBlLFwiaXNQcm90b3R5cGVPZlwiKSlyZXR1cm4hMX1jYXRjaChjKXtyZXR1cm4hMX1pZihrLm93bkxhc3QpZm9yKGIgaW4gYSlyZXR1cm4gai5jYWxsKGEsYik7Zm9yKGIgaW4gYSk7cmV0dXJuIHZvaWQgMD09PWJ8fGouY2FsbChhLGIpfSx0eXBlOmZ1bmN0aW9uKGEpe3JldHVybiBudWxsPT1hP2ErXCJcIjpcIm9iamVjdFwiPT10eXBlb2YgYXx8XCJmdW5jdGlvblwiPT10eXBlb2YgYT9oW2kuY2FsbChhKV18fFwib2JqZWN0XCI6dHlwZW9mIGF9LGdsb2JhbEV2YWw6ZnVuY3Rpb24oYil7YiYmbS50cmltKGIpJiYoYS5leGVjU2NyaXB0fHxmdW5jdGlvbihiKXthLmV2YWwuY2FsbChhLGIpfSkoYil9LGNhbWVsQ2FzZTpmdW5jdGlvbihhKXtyZXR1cm4gYS5yZXBsYWNlKG8sXCJtcy1cIikucmVwbGFjZShwLHEpfSxub2RlTmFtZTpmdW5jdGlvbihhLGIpe3JldHVybiBhLm5vZGVOYW1lJiZhLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk9PT1iLnRvTG93ZXJDYXNlKCl9LGVhY2g6ZnVuY3Rpb24oYSxiLGMpe3ZhciBkLGU9MCxmPWEubGVuZ3RoLGc9cihhKTtpZihjKXtpZihnKXtmb3IoO2Y+ZTtlKyspaWYoZD1iLmFwcGx5KGFbZV0sYyksZD09PSExKWJyZWFrfWVsc2UgZm9yKGUgaW4gYSlpZihkPWIuYXBwbHkoYVtlXSxjKSxkPT09ITEpYnJlYWt9ZWxzZSBpZihnKXtmb3IoO2Y+ZTtlKyspaWYoZD1iLmNhbGwoYVtlXSxlLGFbZV0pLGQ9PT0hMSlicmVha31lbHNlIGZvcihlIGluIGEpaWYoZD1iLmNhbGwoYVtlXSxlLGFbZV0pLGQ9PT0hMSlicmVhaztyZXR1cm4gYX0sdHJpbTpmdW5jdGlvbihhKXtyZXR1cm4gbnVsbD09YT9cIlwiOihhK1wiXCIpLnJlcGxhY2UobixcIlwiKX0sbWFrZUFycmF5OmZ1bmN0aW9uKGEsYil7dmFyIGM9Ynx8W107cmV0dXJuIG51bGwhPWEmJihyKE9iamVjdChhKSk/bS5tZXJnZShjLFwic3RyaW5nXCI9PXR5cGVvZiBhP1thXTphKTpmLmNhbGwoYyxhKSksY30saW5BcnJheTpmdW5jdGlvbihhLGIsYyl7dmFyIGQ7aWYoYil7aWYoZylyZXR1cm4gZy5jYWxsKGIsYSxjKTtmb3IoZD1iLmxlbmd0aCxjPWM/MD5jP01hdGgubWF4KDAsZCtjKTpjOjA7ZD5jO2MrKylpZihjIGluIGImJmJbY109PT1hKXJldHVybiBjfXJldHVybi0xfSxtZXJnZTpmdW5jdGlvbihhLGIpe3ZhciBjPStiLmxlbmd0aCxkPTAsZT1hLmxlbmd0aDt3aGlsZShjPmQpYVtlKytdPWJbZCsrXTtpZihjIT09Yyl3aGlsZSh2b2lkIDAhPT1iW2RdKWFbZSsrXT1iW2QrK107cmV0dXJuIGEubGVuZ3RoPWUsYX0sZ3JlcDpmdW5jdGlvbihhLGIsYyl7Zm9yKHZhciBkLGU9W10sZj0wLGc9YS5sZW5ndGgsaD0hYztnPmY7ZisrKWQ9IWIoYVtmXSxmKSxkIT09aCYmZS5wdXNoKGFbZl0pO3JldHVybiBlfSxtYXA6ZnVuY3Rpb24oYSxiLGMpe3ZhciBkLGY9MCxnPWEubGVuZ3RoLGg9cihhKSxpPVtdO2lmKGgpZm9yKDtnPmY7ZisrKWQ9YihhW2ZdLGYsYyksbnVsbCE9ZCYmaS5wdXNoKGQpO2Vsc2UgZm9yKGYgaW4gYSlkPWIoYVtmXSxmLGMpLG51bGwhPWQmJmkucHVzaChkKTtyZXR1cm4gZS5hcHBseShbXSxpKX0sZ3VpZDoxLHByb3h5OmZ1bmN0aW9uKGEsYil7dmFyIGMsZSxmO3JldHVyblwic3RyaW5nXCI9PXR5cGVvZiBiJiYoZj1hW2JdLGI9YSxhPWYpLG0uaXNGdW5jdGlvbihhKT8oYz1kLmNhbGwoYXJndW1lbnRzLDIpLGU9ZnVuY3Rpb24oKXtyZXR1cm4gYS5hcHBseShifHx0aGlzLGMuY29uY2F0KGQuY2FsbChhcmd1bWVudHMpKSl9LGUuZ3VpZD1hLmd1aWQ9YS5ndWlkfHxtLmd1aWQrKyxlKTp2b2lkIDB9LG5vdzpmdW5jdGlvbigpe3JldHVybituZXcgRGF0ZX0sc3VwcG9ydDprfSksbS5lYWNoKFwiQm9vbGVhbiBOdW1iZXIgU3RyaW5nIEZ1bmN0aW9uIEFycmF5IERhdGUgUmVnRXhwIE9iamVjdCBFcnJvclwiLnNwbGl0KFwiIFwiKSxmdW5jdGlvbihhLGIpe2hbXCJbb2JqZWN0IFwiK2IrXCJdXCJdPWIudG9Mb3dlckNhc2UoKX0pO2Z1bmN0aW9uIHIoYSl7dmFyIGI9XCJsZW5ndGhcImluIGEmJmEubGVuZ3RoLGM9bS50eXBlKGEpO3JldHVyblwiZnVuY3Rpb25cIj09PWN8fG0uaXNXaW5kb3coYSk/ITE6MT09PWEubm9kZVR5cGUmJmI/ITA6XCJhcnJheVwiPT09Y3x8MD09PWJ8fFwibnVtYmVyXCI9PXR5cGVvZiBiJiZiPjAmJmItMSBpbiBhfXZhciBzPWZ1bmN0aW9uKGEpe3ZhciBiLGMsZCxlLGYsZyxoLGksaixrLGwsbSxuLG8scCxxLHIscyx0LHU9XCJzaXp6bGVcIisxKm5ldyBEYXRlLHY9YS5kb2N1bWVudCx3PTAseD0wLHk9aGEoKSx6PWhhKCksQT1oYSgpLEI9ZnVuY3Rpb24oYSxiKXtyZXR1cm4gYT09PWImJihsPSEwKSwwfSxDPTE8PDMxLEQ9e30uaGFzT3duUHJvcGVydHksRT1bXSxGPUUucG9wLEc9RS5wdXNoLEg9RS5wdXNoLEk9RS5zbGljZSxKPWZ1bmN0aW9uKGEsYil7Zm9yKHZhciBjPTAsZD1hLmxlbmd0aDtkPmM7YysrKWlmKGFbY109PT1iKXJldHVybiBjO3JldHVybi0xfSxLPVwiY2hlY2tlZHxzZWxlY3RlZHxhc3luY3xhdXRvZm9jdXN8YXV0b3BsYXl8Y29udHJvbHN8ZGVmZXJ8ZGlzYWJsZWR8aGlkZGVufGlzbWFwfGxvb3B8bXVsdGlwbGV8b3BlbnxyZWFkb25seXxyZXF1aXJlZHxzY29wZWRcIixMPVwiW1xcXFx4MjBcXFxcdFxcXFxyXFxcXG5cXFxcZl1cIixNPVwiKD86XFxcXFxcXFwufFtcXFxcdy1dfFteXFxcXHgwMC1cXFxceGEwXSkrXCIsTj1NLnJlcGxhY2UoXCJ3XCIsXCJ3I1wiKSxPPVwiXFxcXFtcIitMK1wiKihcIitNK1wiKSg/OlwiK0wrXCIqKFsqXiR8IX5dPz0pXCIrTCtcIiooPzonKCg/OlxcXFxcXFxcLnxbXlxcXFxcXFxcJ10pKiknfFxcXCIoKD86XFxcXFxcXFwufFteXFxcXFxcXFxcXFwiXSkqKVxcXCJ8KFwiK04rXCIpKXwpXCIrTCtcIipcXFxcXVwiLFA9XCI6KFwiK00rXCIpKD86XFxcXCgoKCcoKD86XFxcXFxcXFwufFteXFxcXFxcXFwnXSkqKSd8XFxcIigoPzpcXFxcXFxcXC58W15cXFxcXFxcXFxcXCJdKSopXFxcIil8KCg/OlxcXFxcXFxcLnxbXlxcXFxcXFxcKClbXFxcXF1dfFwiK08rXCIpKil8LiopXFxcXCl8KVwiLFE9bmV3IFJlZ0V4cChMK1wiK1wiLFwiZ1wiKSxSPW5ldyBSZWdFeHAoXCJeXCIrTCtcIit8KCg/Ol58W15cXFxcXFxcXF0pKD86XFxcXFxcXFwuKSopXCIrTCtcIiskXCIsXCJnXCIpLFM9bmV3IFJlZ0V4cChcIl5cIitMK1wiKixcIitMK1wiKlwiKSxUPW5ldyBSZWdFeHAoXCJeXCIrTCtcIiooWz4rfl18XCIrTCtcIilcIitMK1wiKlwiKSxVPW5ldyBSZWdFeHAoXCI9XCIrTCtcIiooW15cXFxcXSdcXFwiXSo/KVwiK0wrXCIqXFxcXF1cIixcImdcIiksVj1uZXcgUmVnRXhwKFApLFc9bmV3IFJlZ0V4cChcIl5cIitOK1wiJFwiKSxYPXtJRDpuZXcgUmVnRXhwKFwiXiMoXCIrTStcIilcIiksQ0xBU1M6bmV3IFJlZ0V4cChcIl5cXFxcLihcIitNK1wiKVwiKSxUQUc6bmV3IFJlZ0V4cChcIl4oXCIrTS5yZXBsYWNlKFwid1wiLFwidypcIikrXCIpXCIpLEFUVFI6bmV3IFJlZ0V4cChcIl5cIitPKSxQU0VVRE86bmV3IFJlZ0V4cChcIl5cIitQKSxDSElMRDpuZXcgUmVnRXhwKFwiXjoob25seXxmaXJzdHxsYXN0fG50aHxudGgtbGFzdCktKGNoaWxkfG9mLXR5cGUpKD86XFxcXChcIitMK1wiKihldmVufG9kZHwoKFsrLV18KShcXFxcZCopbnwpXCIrTCtcIiooPzooWystXXwpXCIrTCtcIiooXFxcXGQrKXwpKVwiK0wrXCIqXFxcXCl8KVwiLFwiaVwiKSxib29sOm5ldyBSZWdFeHAoXCJeKD86XCIrSytcIikkXCIsXCJpXCIpLG5lZWRzQ29udGV4dDpuZXcgUmVnRXhwKFwiXlwiK0wrXCIqWz4rfl18OihldmVufG9kZHxlcXxndHxsdHxudGh8Zmlyc3R8bGFzdCkoPzpcXFxcKFwiK0wrXCIqKCg/Oi1cXFxcZCk/XFxcXGQqKVwiK0wrXCIqXFxcXCl8KSg/PVteLV18JClcIixcImlcIil9LFk9L14oPzppbnB1dHxzZWxlY3R8dGV4dGFyZWF8YnV0dG9uKSQvaSxaPS9eaFxcZCQvaSwkPS9eW157XStcXHtcXHMqXFxbbmF0aXZlIFxcdy8sXz0vXig/OiMoW1xcdy1dKyl8KFxcdyspfFxcLihbXFx3LV0rKSkkLyxhYT0vWyt+XS8sYmE9Lyd8XFxcXC9nLGNhPW5ldyBSZWdFeHAoXCJcXFxcXFxcXChbXFxcXGRhLWZdezEsNn1cIitMK1wiP3woXCIrTCtcIil8LilcIixcImlnXCIpLGRhPWZ1bmN0aW9uKGEsYixjKXt2YXIgZD1cIjB4XCIrYi02NTUzNjtyZXR1cm4gZCE9PWR8fGM/YjowPmQ/U3RyaW5nLmZyb21DaGFyQ29kZShkKzY1NTM2KTpTdHJpbmcuZnJvbUNoYXJDb2RlKGQ+PjEwfDU1Mjk2LDEwMjMmZHw1NjMyMCl9LGVhPWZ1bmN0aW9uKCl7bSgpfTt0cnl7SC5hcHBseShFPUkuY2FsbCh2LmNoaWxkTm9kZXMpLHYuY2hpbGROb2RlcyksRVt2LmNoaWxkTm9kZXMubGVuZ3RoXS5ub2RlVHlwZX1jYXRjaChmYSl7SD17YXBwbHk6RS5sZW5ndGg/ZnVuY3Rpb24oYSxiKXtHLmFwcGx5KGEsSS5jYWxsKGIpKX06ZnVuY3Rpb24oYSxiKXt2YXIgYz1hLmxlbmd0aCxkPTA7d2hpbGUoYVtjKytdPWJbZCsrXSk7YS5sZW5ndGg9Yy0xfX19ZnVuY3Rpb24gZ2EoYSxiLGQsZSl7dmFyIGYsaCxqLGssbCxvLHIscyx3LHg7aWYoKGI/Yi5vd25lckRvY3VtZW50fHxiOnYpIT09biYmbShiKSxiPWJ8fG4sZD1kfHxbXSxrPWIubm9kZVR5cGUsXCJzdHJpbmdcIiE9dHlwZW9mIGF8fCFhfHwxIT09ayYmOSE9PWsmJjExIT09aylyZXR1cm4gZDtpZighZSYmcCl7aWYoMTEhPT1rJiYoZj1fLmV4ZWMoYSkpKWlmKGo9ZlsxXSl7aWYoOT09PWspe2lmKGg9Yi5nZXRFbGVtZW50QnlJZChqKSwhaHx8IWgucGFyZW50Tm9kZSlyZXR1cm4gZDtpZihoLmlkPT09ailyZXR1cm4gZC5wdXNoKGgpLGR9ZWxzZSBpZihiLm93bmVyRG9jdW1lbnQmJihoPWIub3duZXJEb2N1bWVudC5nZXRFbGVtZW50QnlJZChqKSkmJnQoYixoKSYmaC5pZD09PWopcmV0dXJuIGQucHVzaChoKSxkfWVsc2V7aWYoZlsyXSlyZXR1cm4gSC5hcHBseShkLGIuZ2V0RWxlbWVudHNCeVRhZ05hbWUoYSkpLGQ7aWYoKGo9ZlszXSkmJmMuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSlyZXR1cm4gSC5hcHBseShkLGIuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZShqKSksZH1pZihjLnFzYSYmKCFxfHwhcS50ZXN0KGEpKSl7aWYocz1yPXUsdz1iLHg9MSE9PWsmJmEsMT09PWsmJlwib2JqZWN0XCIhPT1iLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkpe289ZyhhKSwocj1iLmdldEF0dHJpYnV0ZShcImlkXCIpKT9zPXIucmVwbGFjZShiYSxcIlxcXFwkJlwiKTpiLnNldEF0dHJpYnV0ZShcImlkXCIscykscz1cIltpZD0nXCIrcytcIiddIFwiLGw9by5sZW5ndGg7d2hpbGUobC0tKW9bbF09cytyYShvW2xdKTt3PWFhLnRlc3QoYSkmJnBhKGIucGFyZW50Tm9kZSl8fGIseD1vLmpvaW4oXCIsXCIpfWlmKHgpdHJ5e3JldHVybiBILmFwcGx5KGQsdy5xdWVyeVNlbGVjdG9yQWxsKHgpKSxkfWNhdGNoKHkpe31maW5hbGx5e3J8fGIucmVtb3ZlQXR0cmlidXRlKFwiaWRcIil9fX1yZXR1cm4gaShhLnJlcGxhY2UoUixcIiQxXCIpLGIsZCxlKX1mdW5jdGlvbiBoYSgpe3ZhciBhPVtdO2Z1bmN0aW9uIGIoYyxlKXtyZXR1cm4gYS5wdXNoKGMrXCIgXCIpPmQuY2FjaGVMZW5ndGgmJmRlbGV0ZSBiW2Euc2hpZnQoKV0sYltjK1wiIFwiXT1lfXJldHVybiBifWZ1bmN0aW9uIGlhKGEpe3JldHVybiBhW3VdPSEwLGF9ZnVuY3Rpb24gamEoYSl7dmFyIGI9bi5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO3RyeXtyZXR1cm4hIWEoYil9Y2F0Y2goYyl7cmV0dXJuITF9ZmluYWxseXtiLnBhcmVudE5vZGUmJmIucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChiKSxiPW51bGx9fWZ1bmN0aW9uIGthKGEsYil7dmFyIGM9YS5zcGxpdChcInxcIiksZT1hLmxlbmd0aDt3aGlsZShlLS0pZC5hdHRySGFuZGxlW2NbZV1dPWJ9ZnVuY3Rpb24gbGEoYSxiKXt2YXIgYz1iJiZhLGQ9YyYmMT09PWEubm9kZVR5cGUmJjE9PT1iLm5vZGVUeXBlJiYofmIuc291cmNlSW5kZXh8fEMpLSh+YS5zb3VyY2VJbmRleHx8Qyk7aWYoZClyZXR1cm4gZDtpZihjKXdoaWxlKGM9Yy5uZXh0U2libGluZylpZihjPT09YilyZXR1cm4tMTtyZXR1cm4gYT8xOi0xfWZ1bmN0aW9uIG1hKGEpe3JldHVybiBmdW5jdGlvbihiKXt2YXIgYz1iLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7cmV0dXJuXCJpbnB1dFwiPT09YyYmYi50eXBlPT09YX19ZnVuY3Rpb24gbmEoYSl7cmV0dXJuIGZ1bmN0aW9uKGIpe3ZhciBjPWIubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtyZXR1cm4oXCJpbnB1dFwiPT09Y3x8XCJidXR0b25cIj09PWMpJiZiLnR5cGU9PT1hfX1mdW5jdGlvbiBvYShhKXtyZXR1cm4gaWEoZnVuY3Rpb24oYil7cmV0dXJuIGI9K2IsaWEoZnVuY3Rpb24oYyxkKXt2YXIgZSxmPWEoW10sYy5sZW5ndGgsYiksZz1mLmxlbmd0aDt3aGlsZShnLS0pY1tlPWZbZ11dJiYoY1tlXT0hKGRbZV09Y1tlXSkpfSl9KX1mdW5jdGlvbiBwYShhKXtyZXR1cm4gYSYmXCJ1bmRlZmluZWRcIiE9dHlwZW9mIGEuZ2V0RWxlbWVudHNCeVRhZ05hbWUmJmF9Yz1nYS5zdXBwb3J0PXt9LGY9Z2EuaXNYTUw9ZnVuY3Rpb24oYSl7dmFyIGI9YSYmKGEub3duZXJEb2N1bWVudHx8YSkuZG9jdW1lbnRFbGVtZW50O3JldHVybiBiP1wiSFRNTFwiIT09Yi5ub2RlTmFtZTohMX0sbT1nYS5zZXREb2N1bWVudD1mdW5jdGlvbihhKXt2YXIgYixlLGc9YT9hLm93bmVyRG9jdW1lbnR8fGE6djtyZXR1cm4gZyE9PW4mJjk9PT1nLm5vZGVUeXBlJiZnLmRvY3VtZW50RWxlbWVudD8obj1nLG89Zy5kb2N1bWVudEVsZW1lbnQsZT1nLmRlZmF1bHRWaWV3LGUmJmUhPT1lLnRvcCYmKGUuYWRkRXZlbnRMaXN0ZW5lcj9lLmFkZEV2ZW50TGlzdGVuZXIoXCJ1bmxvYWRcIixlYSwhMSk6ZS5hdHRhY2hFdmVudCYmZS5hdHRhY2hFdmVudChcIm9udW5sb2FkXCIsZWEpKSxwPSFmKGcpLGMuYXR0cmlidXRlcz1qYShmdW5jdGlvbihhKXtyZXR1cm4gYS5jbGFzc05hbWU9XCJpXCIsIWEuZ2V0QXR0cmlidXRlKFwiY2xhc3NOYW1lXCIpfSksYy5nZXRFbGVtZW50c0J5VGFnTmFtZT1qYShmdW5jdGlvbihhKXtyZXR1cm4gYS5hcHBlbmRDaGlsZChnLmNyZWF0ZUNvbW1lbnQoXCJcIikpLCFhLmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiKlwiKS5sZW5ndGh9KSxjLmdldEVsZW1lbnRzQnlDbGFzc05hbWU9JC50ZXN0KGcuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSksYy5nZXRCeUlkPWphKGZ1bmN0aW9uKGEpe3JldHVybiBvLmFwcGVuZENoaWxkKGEpLmlkPXUsIWcuZ2V0RWxlbWVudHNCeU5hbWV8fCFnLmdldEVsZW1lbnRzQnlOYW1lKHUpLmxlbmd0aH0pLGMuZ2V0QnlJZD8oZC5maW5kLklEPWZ1bmN0aW9uKGEsYil7aWYoXCJ1bmRlZmluZWRcIiE9dHlwZW9mIGIuZ2V0RWxlbWVudEJ5SWQmJnApe3ZhciBjPWIuZ2V0RWxlbWVudEJ5SWQoYSk7cmV0dXJuIGMmJmMucGFyZW50Tm9kZT9bY106W119fSxkLmZpbHRlci5JRD1mdW5jdGlvbihhKXt2YXIgYj1hLnJlcGxhY2UoY2EsZGEpO3JldHVybiBmdW5jdGlvbihhKXtyZXR1cm4gYS5nZXRBdHRyaWJ1dGUoXCJpZFwiKT09PWJ9fSk6KGRlbGV0ZSBkLmZpbmQuSUQsZC5maWx0ZXIuSUQ9ZnVuY3Rpb24oYSl7dmFyIGI9YS5yZXBsYWNlKGNhLGRhKTtyZXR1cm4gZnVuY3Rpb24oYSl7dmFyIGM9XCJ1bmRlZmluZWRcIiE9dHlwZW9mIGEuZ2V0QXR0cmlidXRlTm9kZSYmYS5nZXRBdHRyaWJ1dGVOb2RlKFwiaWRcIik7cmV0dXJuIGMmJmMudmFsdWU9PT1ifX0pLGQuZmluZC5UQUc9Yy5nZXRFbGVtZW50c0J5VGFnTmFtZT9mdW5jdGlvbihhLGIpe3JldHVyblwidW5kZWZpbmVkXCIhPXR5cGVvZiBiLmdldEVsZW1lbnRzQnlUYWdOYW1lP2IuZ2V0RWxlbWVudHNCeVRhZ05hbWUoYSk6Yy5xc2E/Yi5xdWVyeVNlbGVjdG9yQWxsKGEpOnZvaWQgMH06ZnVuY3Rpb24oYSxiKXt2YXIgYyxkPVtdLGU9MCxmPWIuZ2V0RWxlbWVudHNCeVRhZ05hbWUoYSk7aWYoXCIqXCI9PT1hKXt3aGlsZShjPWZbZSsrXSkxPT09Yy5ub2RlVHlwZSYmZC5wdXNoKGMpO3JldHVybiBkfXJldHVybiBmfSxkLmZpbmQuQ0xBU1M9Yy5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lJiZmdW5jdGlvbihhLGIpe3JldHVybiBwP2IuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZShhKTp2b2lkIDB9LHI9W10scT1bXSwoYy5xc2E9JC50ZXN0KGcucXVlcnlTZWxlY3RvckFsbCkpJiYoamEoZnVuY3Rpb24oYSl7by5hcHBlbmRDaGlsZChhKS5pbm5lckhUTUw9XCI8YSBpZD0nXCIrdStcIic+PC9hPjxzZWxlY3QgaWQ9J1wiK3UrXCItXFxmXScgbXNhbGxvd2NhcHR1cmU9Jyc+PG9wdGlvbiBzZWxlY3RlZD0nJz48L29wdGlvbj48L3NlbGVjdD5cIixhLnF1ZXJ5U2VsZWN0b3JBbGwoXCJbbXNhbGxvd2NhcHR1cmVePScnXVwiKS5sZW5ndGgmJnEucHVzaChcIlsqXiRdPVwiK0wrXCIqKD86Jyd8XFxcIlxcXCIpXCIpLGEucXVlcnlTZWxlY3RvckFsbChcIltzZWxlY3RlZF1cIikubGVuZ3RofHxxLnB1c2goXCJcXFxcW1wiK0wrXCIqKD86dmFsdWV8XCIrSytcIilcIiksYS5xdWVyeVNlbGVjdG9yQWxsKFwiW2lkfj1cIit1K1wiLV1cIikubGVuZ3RofHxxLnB1c2goXCJ+PVwiKSxhLnF1ZXJ5U2VsZWN0b3JBbGwoXCI6Y2hlY2tlZFwiKS5sZW5ndGh8fHEucHVzaChcIjpjaGVja2VkXCIpLGEucXVlcnlTZWxlY3RvckFsbChcImEjXCIrdStcIisqXCIpLmxlbmd0aHx8cS5wdXNoKFwiLiMuK1srfl1cIil9KSxqYShmdW5jdGlvbihhKXt2YXIgYj1nLmNyZWF0ZUVsZW1lbnQoXCJpbnB1dFwiKTtiLnNldEF0dHJpYnV0ZShcInR5cGVcIixcImhpZGRlblwiKSxhLmFwcGVuZENoaWxkKGIpLnNldEF0dHJpYnV0ZShcIm5hbWVcIixcIkRcIiksYS5xdWVyeVNlbGVjdG9yQWxsKFwiW25hbWU9ZF1cIikubGVuZ3RoJiZxLnB1c2goXCJuYW1lXCIrTCtcIipbKl4kfCF+XT89XCIpLGEucXVlcnlTZWxlY3RvckFsbChcIjplbmFibGVkXCIpLmxlbmd0aHx8cS5wdXNoKFwiOmVuYWJsZWRcIixcIjpkaXNhYmxlZFwiKSxhLnF1ZXJ5U2VsZWN0b3JBbGwoXCIqLDp4XCIpLHEucHVzaChcIiwuKjpcIil9KSksKGMubWF0Y2hlc1NlbGVjdG9yPSQudGVzdChzPW8ubWF0Y2hlc3x8by53ZWJraXRNYXRjaGVzU2VsZWN0b3J8fG8ubW96TWF0Y2hlc1NlbGVjdG9yfHxvLm9NYXRjaGVzU2VsZWN0b3J8fG8ubXNNYXRjaGVzU2VsZWN0b3IpKSYmamEoZnVuY3Rpb24oYSl7Yy5kaXNjb25uZWN0ZWRNYXRjaD1zLmNhbGwoYSxcImRpdlwiKSxzLmNhbGwoYSxcIltzIT0nJ106eFwiKSxyLnB1c2goXCIhPVwiLFApfSkscT1xLmxlbmd0aCYmbmV3IFJlZ0V4cChxLmpvaW4oXCJ8XCIpKSxyPXIubGVuZ3RoJiZuZXcgUmVnRXhwKHIuam9pbihcInxcIikpLGI9JC50ZXN0KG8uY29tcGFyZURvY3VtZW50UG9zaXRpb24pLHQ9Ynx8JC50ZXN0KG8uY29udGFpbnMpP2Z1bmN0aW9uKGEsYil7dmFyIGM9OT09PWEubm9kZVR5cGU/YS5kb2N1bWVudEVsZW1lbnQ6YSxkPWImJmIucGFyZW50Tm9kZTtyZXR1cm4gYT09PWR8fCEoIWR8fDEhPT1kLm5vZGVUeXBlfHwhKGMuY29udGFpbnM/Yy5jb250YWlucyhkKTphLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uJiYxNiZhLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKGQpKSl9OmZ1bmN0aW9uKGEsYil7aWYoYil3aGlsZShiPWIucGFyZW50Tm9kZSlpZihiPT09YSlyZXR1cm4hMDtyZXR1cm4hMX0sQj1iP2Z1bmN0aW9uKGEsYil7aWYoYT09PWIpcmV0dXJuIGw9ITAsMDt2YXIgZD0hYS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbi0hYi5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbjtyZXR1cm4gZD9kOihkPShhLm93bmVyRG9jdW1lbnR8fGEpPT09KGIub3duZXJEb2N1bWVudHx8Yik/YS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbihiKToxLDEmZHx8IWMuc29ydERldGFjaGVkJiZiLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKGEpPT09ZD9hPT09Z3x8YS5vd25lckRvY3VtZW50PT09diYmdCh2LGEpPy0xOmI9PT1nfHxiLm93bmVyRG9jdW1lbnQ9PT12JiZ0KHYsYik/MTprP0ooayxhKS1KKGssYik6MDo0JmQ/LTE6MSl9OmZ1bmN0aW9uKGEsYil7aWYoYT09PWIpcmV0dXJuIGw9ITAsMDt2YXIgYyxkPTAsZT1hLnBhcmVudE5vZGUsZj1iLnBhcmVudE5vZGUsaD1bYV0saT1bYl07aWYoIWV8fCFmKXJldHVybiBhPT09Zz8tMTpiPT09Zz8xOmU/LTE6Zj8xOms/SihrLGEpLUooayxiKTowO2lmKGU9PT1mKXJldHVybiBsYShhLGIpO2M9YTt3aGlsZShjPWMucGFyZW50Tm9kZSloLnVuc2hpZnQoYyk7Yz1iO3doaWxlKGM9Yy5wYXJlbnROb2RlKWkudW5zaGlmdChjKTt3aGlsZShoW2RdPT09aVtkXSlkKys7cmV0dXJuIGQ/bGEoaFtkXSxpW2RdKTpoW2RdPT09dj8tMTppW2RdPT09dj8xOjB9LGcpOm59LGdhLm1hdGNoZXM9ZnVuY3Rpb24oYSxiKXtyZXR1cm4gZ2EoYSxudWxsLG51bGwsYil9LGdhLm1hdGNoZXNTZWxlY3Rvcj1mdW5jdGlvbihhLGIpe2lmKChhLm93bmVyRG9jdW1lbnR8fGEpIT09biYmbShhKSxiPWIucmVwbGFjZShVLFwiPSckMSddXCIpLCEoIWMubWF0Y2hlc1NlbGVjdG9yfHwhcHx8ciYmci50ZXN0KGIpfHxxJiZxLnRlc3QoYikpKXRyeXt2YXIgZD1zLmNhbGwoYSxiKTtpZihkfHxjLmRpc2Nvbm5lY3RlZE1hdGNofHxhLmRvY3VtZW50JiYxMSE9PWEuZG9jdW1lbnQubm9kZVR5cGUpcmV0dXJuIGR9Y2F0Y2goZSl7fXJldHVybiBnYShiLG4sbnVsbCxbYV0pLmxlbmd0aD4wfSxnYS5jb250YWlucz1mdW5jdGlvbihhLGIpe3JldHVybihhLm93bmVyRG9jdW1lbnR8fGEpIT09biYmbShhKSx0KGEsYil9LGdhLmF0dHI9ZnVuY3Rpb24oYSxiKXsoYS5vd25lckRvY3VtZW50fHxhKSE9PW4mJm0oYSk7dmFyIGU9ZC5hdHRySGFuZGxlW2IudG9Mb3dlckNhc2UoKV0sZj1lJiZELmNhbGwoZC5hdHRySGFuZGxlLGIudG9Mb3dlckNhc2UoKSk/ZShhLGIsIXApOnZvaWQgMDtyZXR1cm4gdm9pZCAwIT09Zj9mOmMuYXR0cmlidXRlc3x8IXA/YS5nZXRBdHRyaWJ1dGUoYik6KGY9YS5nZXRBdHRyaWJ1dGVOb2RlKGIpKSYmZi5zcGVjaWZpZWQ/Zi52YWx1ZTpudWxsfSxnYS5lcnJvcj1mdW5jdGlvbihhKXt0aHJvdyBuZXcgRXJyb3IoXCJTeW50YXggZXJyb3IsIHVucmVjb2duaXplZCBleHByZXNzaW9uOiBcIithKX0sZ2EudW5pcXVlU29ydD1mdW5jdGlvbihhKXt2YXIgYixkPVtdLGU9MCxmPTA7aWYobD0hYy5kZXRlY3REdXBsaWNhdGVzLGs9IWMuc29ydFN0YWJsZSYmYS5zbGljZSgwKSxhLnNvcnQoQiksbCl7d2hpbGUoYj1hW2YrK10pYj09PWFbZl0mJihlPWQucHVzaChmKSk7d2hpbGUoZS0tKWEuc3BsaWNlKGRbZV0sMSl9cmV0dXJuIGs9bnVsbCxhfSxlPWdhLmdldFRleHQ9ZnVuY3Rpb24oYSl7dmFyIGIsYz1cIlwiLGQ9MCxmPWEubm9kZVR5cGU7aWYoZil7aWYoMT09PWZ8fDk9PT1mfHwxMT09PWYpe2lmKFwic3RyaW5nXCI9PXR5cGVvZiBhLnRleHRDb250ZW50KXJldHVybiBhLnRleHRDb250ZW50O2ZvcihhPWEuZmlyc3RDaGlsZDthO2E9YS5uZXh0U2libGluZyljKz1lKGEpfWVsc2UgaWYoMz09PWZ8fDQ9PT1mKXJldHVybiBhLm5vZGVWYWx1ZX1lbHNlIHdoaWxlKGI9YVtkKytdKWMrPWUoYik7cmV0dXJuIGN9LGQ9Z2Euc2VsZWN0b3JzPXtjYWNoZUxlbmd0aDo1MCxjcmVhdGVQc2V1ZG86aWEsbWF0Y2g6WCxhdHRySGFuZGxlOnt9LGZpbmQ6e30scmVsYXRpdmU6e1wiPlwiOntkaXI6XCJwYXJlbnROb2RlXCIsZmlyc3Q6ITB9LFwiIFwiOntkaXI6XCJwYXJlbnROb2RlXCJ9LFwiK1wiOntkaXI6XCJwcmV2aW91c1NpYmxpbmdcIixmaXJzdDohMH0sXCJ+XCI6e2RpcjpcInByZXZpb3VzU2libGluZ1wifX0scHJlRmlsdGVyOntBVFRSOmZ1bmN0aW9uKGEpe3JldHVybiBhWzFdPWFbMV0ucmVwbGFjZShjYSxkYSksYVszXT0oYVszXXx8YVs0XXx8YVs1XXx8XCJcIikucmVwbGFjZShjYSxkYSksXCJ+PVwiPT09YVsyXSYmKGFbM109XCIgXCIrYVszXStcIiBcIiksYS5zbGljZSgwLDQpfSxDSElMRDpmdW5jdGlvbihhKXtyZXR1cm4gYVsxXT1hWzFdLnRvTG93ZXJDYXNlKCksXCJudGhcIj09PWFbMV0uc2xpY2UoMCwzKT8oYVszXXx8Z2EuZXJyb3IoYVswXSksYVs0XT0rKGFbNF0/YVs1XSsoYVs2XXx8MSk6MiooXCJldmVuXCI9PT1hWzNdfHxcIm9kZFwiPT09YVszXSkpLGFbNV09KyhhWzddK2FbOF18fFwib2RkXCI9PT1hWzNdKSk6YVszXSYmZ2EuZXJyb3IoYVswXSksYX0sUFNFVURPOmZ1bmN0aW9uKGEpe3ZhciBiLGM9IWFbNl0mJmFbMl07cmV0dXJuIFguQ0hJTEQudGVzdChhWzBdKT9udWxsOihhWzNdP2FbMl09YVs0XXx8YVs1XXx8XCJcIjpjJiZWLnRlc3QoYykmJihiPWcoYywhMCkpJiYoYj1jLmluZGV4T2YoXCIpXCIsYy5sZW5ndGgtYiktYy5sZW5ndGgpJiYoYVswXT1hWzBdLnNsaWNlKDAsYiksYVsyXT1jLnNsaWNlKDAsYikpLGEuc2xpY2UoMCwzKSl9fSxmaWx0ZXI6e1RBRzpmdW5jdGlvbihhKXt2YXIgYj1hLnJlcGxhY2UoY2EsZGEpLnRvTG93ZXJDYXNlKCk7cmV0dXJuXCIqXCI9PT1hP2Z1bmN0aW9uKCl7cmV0dXJuITB9OmZ1bmN0aW9uKGEpe3JldHVybiBhLm5vZGVOYW1lJiZhLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk9PT1ifX0sQ0xBU1M6ZnVuY3Rpb24oYSl7dmFyIGI9eVthK1wiIFwiXTtyZXR1cm4gYnx8KGI9bmV3IFJlZ0V4cChcIihefFwiK0wrXCIpXCIrYStcIihcIitMK1wifCQpXCIpKSYmeShhLGZ1bmN0aW9uKGEpe3JldHVybiBiLnRlc3QoXCJzdHJpbmdcIj09dHlwZW9mIGEuY2xhc3NOYW1lJiZhLmNsYXNzTmFtZXx8XCJ1bmRlZmluZWRcIiE9dHlwZW9mIGEuZ2V0QXR0cmlidXRlJiZhLmdldEF0dHJpYnV0ZShcImNsYXNzXCIpfHxcIlwiKX0pfSxBVFRSOmZ1bmN0aW9uKGEsYixjKXtyZXR1cm4gZnVuY3Rpb24oZCl7dmFyIGU9Z2EuYXR0cihkLGEpO3JldHVybiBudWxsPT1lP1wiIT1cIj09PWI6Yj8oZSs9XCJcIixcIj1cIj09PWI/ZT09PWM6XCIhPVwiPT09Yj9lIT09YzpcIl49XCI9PT1iP2MmJjA9PT1lLmluZGV4T2YoYyk6XCIqPVwiPT09Yj9jJiZlLmluZGV4T2YoYyk+LTE6XCIkPVwiPT09Yj9jJiZlLnNsaWNlKC1jLmxlbmd0aCk9PT1jOlwifj1cIj09PWI/KFwiIFwiK2UucmVwbGFjZShRLFwiIFwiKStcIiBcIikuaW5kZXhPZihjKT4tMTpcInw9XCI9PT1iP2U9PT1jfHxlLnNsaWNlKDAsYy5sZW5ndGgrMSk9PT1jK1wiLVwiOiExKTohMH19LENISUxEOmZ1bmN0aW9uKGEsYixjLGQsZSl7dmFyIGY9XCJudGhcIiE9PWEuc2xpY2UoMCwzKSxnPVwibGFzdFwiIT09YS5zbGljZSgtNCksaD1cIm9mLXR5cGVcIj09PWI7cmV0dXJuIDE9PT1kJiYwPT09ZT9mdW5jdGlvbihhKXtyZXR1cm4hIWEucGFyZW50Tm9kZX06ZnVuY3Rpb24oYixjLGkpe3ZhciBqLGssbCxtLG4sbyxwPWYhPT1nP1wibmV4dFNpYmxpbmdcIjpcInByZXZpb3VzU2libGluZ1wiLHE9Yi5wYXJlbnROb2RlLHI9aCYmYi5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpLHM9IWkmJiFoO2lmKHEpe2lmKGYpe3doaWxlKHApe2w9Yjt3aGlsZShsPWxbcF0paWYoaD9sLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk9PT1yOjE9PT1sLm5vZGVUeXBlKXJldHVybiExO289cD1cIm9ubHlcIj09PWEmJiFvJiZcIm5leHRTaWJsaW5nXCJ9cmV0dXJuITB9aWYobz1bZz9xLmZpcnN0Q2hpbGQ6cS5sYXN0Q2hpbGRdLGcmJnMpe2s9cVt1XXx8KHFbdV09e30pLGo9a1thXXx8W10sbj1qWzBdPT09dyYmalsxXSxtPWpbMF09PT13JiZqWzJdLGw9biYmcS5jaGlsZE5vZGVzW25dO3doaWxlKGw9KytuJiZsJiZsW3BdfHwobT1uPTApfHxvLnBvcCgpKWlmKDE9PT1sLm5vZGVUeXBlJiYrK20mJmw9PT1iKXtrW2FdPVt3LG4sbV07YnJlYWt9fWVsc2UgaWYocyYmKGo9KGJbdV18fChiW3VdPXt9KSlbYV0pJiZqWzBdPT09dyltPWpbMV07ZWxzZSB3aGlsZShsPSsrbiYmbCYmbFtwXXx8KG09bj0wKXx8by5wb3AoKSlpZigoaD9sLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk9PT1yOjE9PT1sLm5vZGVUeXBlKSYmKyttJiYocyYmKChsW3VdfHwobFt1XT17fSkpW2FdPVt3LG1dKSxsPT09YikpYnJlYWs7cmV0dXJuIG0tPWUsbT09PWR8fG0lZD09PTAmJm0vZD49MH19fSxQU0VVRE86ZnVuY3Rpb24oYSxiKXt2YXIgYyxlPWQucHNldWRvc1thXXx8ZC5zZXRGaWx0ZXJzW2EudG9Mb3dlckNhc2UoKV18fGdhLmVycm9yKFwidW5zdXBwb3J0ZWQgcHNldWRvOiBcIithKTtyZXR1cm4gZVt1XT9lKGIpOmUubGVuZ3RoPjE/KGM9W2EsYSxcIlwiLGJdLGQuc2V0RmlsdGVycy5oYXNPd25Qcm9wZXJ0eShhLnRvTG93ZXJDYXNlKCkpP2lhKGZ1bmN0aW9uKGEsYyl7dmFyIGQsZj1lKGEsYiksZz1mLmxlbmd0aDt3aGlsZShnLS0pZD1KKGEsZltnXSksYVtkXT0hKGNbZF09ZltnXSl9KTpmdW5jdGlvbihhKXtyZXR1cm4gZShhLDAsYyl9KTplfX0scHNldWRvczp7bm90OmlhKGZ1bmN0aW9uKGEpe3ZhciBiPVtdLGM9W10sZD1oKGEucmVwbGFjZShSLFwiJDFcIikpO3JldHVybiBkW3VdP2lhKGZ1bmN0aW9uKGEsYixjLGUpe3ZhciBmLGc9ZChhLG51bGwsZSxbXSksaD1hLmxlbmd0aDt3aGlsZShoLS0pKGY9Z1toXSkmJihhW2hdPSEoYltoXT1mKSl9KTpmdW5jdGlvbihhLGUsZil7cmV0dXJuIGJbMF09YSxkKGIsbnVsbCxmLGMpLGJbMF09bnVsbCwhYy5wb3AoKX19KSxoYXM6aWEoZnVuY3Rpb24oYSl7cmV0dXJuIGZ1bmN0aW9uKGIpe3JldHVybiBnYShhLGIpLmxlbmd0aD4wfX0pLGNvbnRhaW5zOmlhKGZ1bmN0aW9uKGEpe3JldHVybiBhPWEucmVwbGFjZShjYSxkYSksZnVuY3Rpb24oYil7cmV0dXJuKGIudGV4dENvbnRlbnR8fGIuaW5uZXJUZXh0fHxlKGIpKS5pbmRleE9mKGEpPi0xfX0pLGxhbmc6aWEoZnVuY3Rpb24oYSl7cmV0dXJuIFcudGVzdChhfHxcIlwiKXx8Z2EuZXJyb3IoXCJ1bnN1cHBvcnRlZCBsYW5nOiBcIithKSxhPWEucmVwbGFjZShjYSxkYSkudG9Mb3dlckNhc2UoKSxmdW5jdGlvbihiKXt2YXIgYztkbyBpZihjPXA/Yi5sYW5nOmIuZ2V0QXR0cmlidXRlKFwieG1sOmxhbmdcIil8fGIuZ2V0QXR0cmlidXRlKFwibGFuZ1wiKSlyZXR1cm4gYz1jLnRvTG93ZXJDYXNlKCksYz09PWF8fDA9PT1jLmluZGV4T2YoYStcIi1cIik7d2hpbGUoKGI9Yi5wYXJlbnROb2RlKSYmMT09PWIubm9kZVR5cGUpO3JldHVybiExfX0pLHRhcmdldDpmdW5jdGlvbihiKXt2YXIgYz1hLmxvY2F0aW9uJiZhLmxvY2F0aW9uLmhhc2g7cmV0dXJuIGMmJmMuc2xpY2UoMSk9PT1iLmlkfSxyb290OmZ1bmN0aW9uKGEpe3JldHVybiBhPT09b30sZm9jdXM6ZnVuY3Rpb24oYSl7cmV0dXJuIGE9PT1uLmFjdGl2ZUVsZW1lbnQmJighbi5oYXNGb2N1c3x8bi5oYXNGb2N1cygpKSYmISEoYS50eXBlfHxhLmhyZWZ8fH5hLnRhYkluZGV4KX0sZW5hYmxlZDpmdW5jdGlvbihhKXtyZXR1cm4gYS5kaXNhYmxlZD09PSExfSxkaXNhYmxlZDpmdW5jdGlvbihhKXtyZXR1cm4gYS5kaXNhYmxlZD09PSEwfSxjaGVja2VkOmZ1bmN0aW9uKGEpe3ZhciBiPWEubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtyZXR1cm5cImlucHV0XCI9PT1iJiYhIWEuY2hlY2tlZHx8XCJvcHRpb25cIj09PWImJiEhYS5zZWxlY3RlZH0sc2VsZWN0ZWQ6ZnVuY3Rpb24oYSl7cmV0dXJuIGEucGFyZW50Tm9kZSYmYS5wYXJlbnROb2RlLnNlbGVjdGVkSW5kZXgsYS5zZWxlY3RlZD09PSEwfSxlbXB0eTpmdW5jdGlvbihhKXtmb3IoYT1hLmZpcnN0Q2hpbGQ7YTthPWEubmV4dFNpYmxpbmcpaWYoYS5ub2RlVHlwZTw2KXJldHVybiExO3JldHVybiEwfSxwYXJlbnQ6ZnVuY3Rpb24oYSl7cmV0dXJuIWQucHNldWRvcy5lbXB0eShhKX0saGVhZGVyOmZ1bmN0aW9uKGEpe3JldHVybiBaLnRlc3QoYS5ub2RlTmFtZSl9LGlucHV0OmZ1bmN0aW9uKGEpe3JldHVybiBZLnRlc3QoYS5ub2RlTmFtZSl9LGJ1dHRvbjpmdW5jdGlvbihhKXt2YXIgYj1hLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7cmV0dXJuXCJpbnB1dFwiPT09YiYmXCJidXR0b25cIj09PWEudHlwZXx8XCJidXR0b25cIj09PWJ9LHRleHQ6ZnVuY3Rpb24oYSl7dmFyIGI7cmV0dXJuXCJpbnB1dFwiPT09YS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpJiZcInRleHRcIj09PWEudHlwZSYmKG51bGw9PShiPWEuZ2V0QXR0cmlidXRlKFwidHlwZVwiKSl8fFwidGV4dFwiPT09Yi50b0xvd2VyQ2FzZSgpKX0sZmlyc3Q6b2EoZnVuY3Rpb24oKXtyZXR1cm5bMF19KSxsYXN0Om9hKGZ1bmN0aW9uKGEsYil7cmV0dXJuW2ItMV19KSxlcTpvYShmdW5jdGlvbihhLGIsYyl7cmV0dXJuWzA+Yz9jK2I6Y119KSxldmVuOm9hKGZ1bmN0aW9uKGEsYil7Zm9yKHZhciBjPTA7Yj5jO2MrPTIpYS5wdXNoKGMpO3JldHVybiBhfSksb2RkOm9hKGZ1bmN0aW9uKGEsYil7Zm9yKHZhciBjPTE7Yj5jO2MrPTIpYS5wdXNoKGMpO3JldHVybiBhfSksbHQ6b2EoZnVuY3Rpb24oYSxiLGMpe2Zvcih2YXIgZD0wPmM/YytiOmM7LS1kPj0wOylhLnB1c2goZCk7cmV0dXJuIGF9KSxndDpvYShmdW5jdGlvbihhLGIsYyl7Zm9yKHZhciBkPTA+Yz9jK2I6YzsrK2Q8YjspYS5wdXNoKGQpO3JldHVybiBhfSl9fSxkLnBzZXVkb3MubnRoPWQucHNldWRvcy5lcTtmb3IoYiBpbntyYWRpbzohMCxjaGVja2JveDohMCxmaWxlOiEwLHBhc3N3b3JkOiEwLGltYWdlOiEwfSlkLnBzZXVkb3NbYl09bWEoYik7Zm9yKGIgaW57c3VibWl0OiEwLHJlc2V0OiEwfSlkLnBzZXVkb3NbYl09bmEoYik7ZnVuY3Rpb24gcWEoKXt9cWEucHJvdG90eXBlPWQuZmlsdGVycz1kLnBzZXVkb3MsZC5zZXRGaWx0ZXJzPW5ldyBxYSxnPWdhLnRva2VuaXplPWZ1bmN0aW9uKGEsYil7dmFyIGMsZSxmLGcsaCxpLGosaz16W2ErXCIgXCJdO2lmKGspcmV0dXJuIGI/MDprLnNsaWNlKDApO2g9YSxpPVtdLGo9ZC5wcmVGaWx0ZXI7d2hpbGUoaCl7KCFjfHwoZT1TLmV4ZWMoaCkpKSYmKGUmJihoPWguc2xpY2UoZVswXS5sZW5ndGgpfHxoKSxpLnB1c2goZj1bXSkpLGM9ITEsKGU9VC5leGVjKGgpKSYmKGM9ZS5zaGlmdCgpLGYucHVzaCh7dmFsdWU6Yyx0eXBlOmVbMF0ucmVwbGFjZShSLFwiIFwiKX0pLGg9aC5zbGljZShjLmxlbmd0aCkpO2ZvcihnIGluIGQuZmlsdGVyKSEoZT1YW2ddLmV4ZWMoaCkpfHxqW2ddJiYhKGU9altnXShlKSl8fChjPWUuc2hpZnQoKSxmLnB1c2goe3ZhbHVlOmMsdHlwZTpnLG1hdGNoZXM6ZX0pLGg9aC5zbGljZShjLmxlbmd0aCkpO2lmKCFjKWJyZWFrfXJldHVybiBiP2gubGVuZ3RoOmg/Z2EuZXJyb3IoYSk6eihhLGkpLnNsaWNlKDApfTtmdW5jdGlvbiByYShhKXtmb3IodmFyIGI9MCxjPWEubGVuZ3RoLGQ9XCJcIjtjPmI7YisrKWQrPWFbYl0udmFsdWU7cmV0dXJuIGR9ZnVuY3Rpb24gc2EoYSxiLGMpe3ZhciBkPWIuZGlyLGU9YyYmXCJwYXJlbnROb2RlXCI9PT1kLGY9eCsrO3JldHVybiBiLmZpcnN0P2Z1bmN0aW9uKGIsYyxmKXt3aGlsZShiPWJbZF0paWYoMT09PWIubm9kZVR5cGV8fGUpcmV0dXJuIGEoYixjLGYpfTpmdW5jdGlvbihiLGMsZyl7dmFyIGgsaSxqPVt3LGZdO2lmKGcpe3doaWxlKGI9YltkXSlpZigoMT09PWIubm9kZVR5cGV8fGUpJiZhKGIsYyxnKSlyZXR1cm4hMH1lbHNlIHdoaWxlKGI9YltkXSlpZigxPT09Yi5ub2RlVHlwZXx8ZSl7aWYoaT1iW3VdfHwoYlt1XT17fSksKGg9aVtkXSkmJmhbMF09PT13JiZoWzFdPT09ZilyZXR1cm4galsyXT1oWzJdO2lmKGlbZF09aixqWzJdPWEoYixjLGcpKXJldHVybiEwfX19ZnVuY3Rpb24gdGEoYSl7cmV0dXJuIGEubGVuZ3RoPjE/ZnVuY3Rpb24oYixjLGQpe3ZhciBlPWEubGVuZ3RoO3doaWxlKGUtLSlpZighYVtlXShiLGMsZCkpcmV0dXJuITE7cmV0dXJuITB9OmFbMF19ZnVuY3Rpb24gdWEoYSxiLGMpe2Zvcih2YXIgZD0wLGU9Yi5sZW5ndGg7ZT5kO2QrKylnYShhLGJbZF0sYyk7cmV0dXJuIGN9ZnVuY3Rpb24gdmEoYSxiLGMsZCxlKXtmb3IodmFyIGYsZz1bXSxoPTAsaT1hLmxlbmd0aCxqPW51bGwhPWI7aT5oO2grKykoZj1hW2hdKSYmKCFjfHxjKGYsZCxlKSkmJihnLnB1c2goZiksaiYmYi5wdXNoKGgpKTtyZXR1cm4gZ31mdW5jdGlvbiB3YShhLGIsYyxkLGUsZil7cmV0dXJuIGQmJiFkW3VdJiYoZD13YShkKSksZSYmIWVbdV0mJihlPXdhKGUsZikpLGlhKGZ1bmN0aW9uKGYsZyxoLGkpe3ZhciBqLGssbCxtPVtdLG49W10sbz1nLmxlbmd0aCxwPWZ8fHVhKGJ8fFwiKlwiLGgubm9kZVR5cGU/W2hdOmgsW10pLHE9IWF8fCFmJiZiP3A6dmEocCxtLGEsaCxpKSxyPWM/ZXx8KGY/YTpvfHxkKT9bXTpnOnE7aWYoYyYmYyhxLHIsaCxpKSxkKXtqPXZhKHIsbiksZChqLFtdLGgsaSksaz1qLmxlbmd0aDt3aGlsZShrLS0pKGw9altrXSkmJihyW25ba11dPSEocVtuW2tdXT1sKSl9aWYoZil7aWYoZXx8YSl7aWYoZSl7aj1bXSxrPXIubGVuZ3RoO3doaWxlKGstLSkobD1yW2tdKSYmai5wdXNoKHFba109bCk7ZShudWxsLHI9W10saixpKX1rPXIubGVuZ3RoO3doaWxlKGstLSkobD1yW2tdKSYmKGo9ZT9KKGYsbCk6bVtrXSk+LTEmJihmW2pdPSEoZ1tqXT1sKSl9fWVsc2Ugcj12YShyPT09Zz9yLnNwbGljZShvLHIubGVuZ3RoKTpyKSxlP2UobnVsbCxnLHIsaSk6SC5hcHBseShnLHIpfSl9ZnVuY3Rpb24geGEoYSl7Zm9yKHZhciBiLGMsZSxmPWEubGVuZ3RoLGc9ZC5yZWxhdGl2ZVthWzBdLnR5cGVdLGg9Z3x8ZC5yZWxhdGl2ZVtcIiBcIl0saT1nPzE6MCxrPXNhKGZ1bmN0aW9uKGEpe3JldHVybiBhPT09Yn0saCwhMCksbD1zYShmdW5jdGlvbihhKXtyZXR1cm4gSihiLGEpPi0xfSxoLCEwKSxtPVtmdW5jdGlvbihhLGMsZCl7dmFyIGU9IWcmJihkfHxjIT09ail8fCgoYj1jKS5ub2RlVHlwZT9rKGEsYyxkKTpsKGEsYyxkKSk7cmV0dXJuIGI9bnVsbCxlfV07Zj5pO2krKylpZihjPWQucmVsYXRpdmVbYVtpXS50eXBlXSltPVtzYSh0YShtKSxjKV07ZWxzZXtpZihjPWQuZmlsdGVyW2FbaV0udHlwZV0uYXBwbHkobnVsbCxhW2ldLm1hdGNoZXMpLGNbdV0pe2ZvcihlPSsraTtmPmU7ZSsrKWlmKGQucmVsYXRpdmVbYVtlXS50eXBlXSlicmVhaztyZXR1cm4gd2EoaT4xJiZ0YShtKSxpPjEmJnJhKGEuc2xpY2UoMCxpLTEpLmNvbmNhdCh7dmFsdWU6XCIgXCI9PT1hW2ktMl0udHlwZT9cIipcIjpcIlwifSkpLnJlcGxhY2UoUixcIiQxXCIpLGMsZT5pJiZ4YShhLnNsaWNlKGksZSkpLGY+ZSYmeGEoYT1hLnNsaWNlKGUpKSxmPmUmJnJhKGEpKX1tLnB1c2goYyl9cmV0dXJuIHRhKG0pfWZ1bmN0aW9uIHlhKGEsYil7dmFyIGM9Yi5sZW5ndGg+MCxlPWEubGVuZ3RoPjAsZj1mdW5jdGlvbihmLGcsaCxpLGspe3ZhciBsLG0sbyxwPTAscT1cIjBcIixyPWYmJltdLHM9W10sdD1qLHU9Znx8ZSYmZC5maW5kLlRBRyhcIipcIixrKSx2PXcrPW51bGw9PXQ/MTpNYXRoLnJhbmRvbSgpfHwuMSx4PXUubGVuZ3RoO2ZvcihrJiYoaj1nIT09biYmZyk7cSE9PXgmJm51bGwhPShsPXVbcV0pO3ErKyl7aWYoZSYmbCl7bT0wO3doaWxlKG89YVttKytdKWlmKG8obCxnLGgpKXtpLnB1c2gobCk7YnJlYWt9ayYmKHc9dil9YyYmKChsPSFvJiZsKSYmcC0tLGYmJnIucHVzaChsKSl9aWYocCs9cSxjJiZxIT09cCl7bT0wO3doaWxlKG89YlttKytdKW8ocixzLGcsaCk7aWYoZil7aWYocD4wKXdoaWxlKHEtLSlyW3FdfHxzW3FdfHwoc1txXT1GLmNhbGwoaSkpO3M9dmEocyl9SC5hcHBseShpLHMpLGsmJiFmJiZzLmxlbmd0aD4wJiZwK2IubGVuZ3RoPjEmJmdhLnVuaXF1ZVNvcnQoaSl9cmV0dXJuIGsmJih3PXYsaj10KSxyfTtyZXR1cm4gYz9pYShmKTpmfXJldHVybiBoPWdhLmNvbXBpbGU9ZnVuY3Rpb24oYSxiKXt2YXIgYyxkPVtdLGU9W10sZj1BW2ErXCIgXCJdO2lmKCFmKXtifHwoYj1nKGEpKSxjPWIubGVuZ3RoO3doaWxlKGMtLSlmPXhhKGJbY10pLGZbdV0/ZC5wdXNoKGYpOmUucHVzaChmKTtmPUEoYSx5YShlLGQpKSxmLnNlbGVjdG9yPWF9cmV0dXJuIGZ9LGk9Z2Euc2VsZWN0PWZ1bmN0aW9uKGEsYixlLGYpe3ZhciBpLGosayxsLG0sbj1cImZ1bmN0aW9uXCI9PXR5cGVvZiBhJiZhLG89IWYmJmcoYT1uLnNlbGVjdG9yfHxhKTtpZihlPWV8fFtdLDE9PT1vLmxlbmd0aCl7aWYoaj1vWzBdPW9bMF0uc2xpY2UoMCksai5sZW5ndGg+MiYmXCJJRFwiPT09KGs9alswXSkudHlwZSYmYy5nZXRCeUlkJiY5PT09Yi5ub2RlVHlwZSYmcCYmZC5yZWxhdGl2ZVtqWzFdLnR5cGVdKXtpZihiPShkLmZpbmQuSUQoay5tYXRjaGVzWzBdLnJlcGxhY2UoY2EsZGEpLGIpfHxbXSlbMF0sIWIpcmV0dXJuIGU7biYmKGI9Yi5wYXJlbnROb2RlKSxhPWEuc2xpY2Uoai5zaGlmdCgpLnZhbHVlLmxlbmd0aCl9aT1YLm5lZWRzQ29udGV4dC50ZXN0KGEpPzA6ai5sZW5ndGg7d2hpbGUoaS0tKXtpZihrPWpbaV0sZC5yZWxhdGl2ZVtsPWsudHlwZV0pYnJlYWs7aWYoKG09ZC5maW5kW2xdKSYmKGY9bShrLm1hdGNoZXNbMF0ucmVwbGFjZShjYSxkYSksYWEudGVzdChqWzBdLnR5cGUpJiZwYShiLnBhcmVudE5vZGUpfHxiKSkpe2lmKGouc3BsaWNlKGksMSksYT1mLmxlbmd0aCYmcmEoaiksIWEpcmV0dXJuIEguYXBwbHkoZSxmKSxlO2JyZWFrfX19cmV0dXJuKG58fGgoYSxvKSkoZixiLCFwLGUsYWEudGVzdChhKSYmcGEoYi5wYXJlbnROb2RlKXx8YiksZX0sYy5zb3J0U3RhYmxlPXUuc3BsaXQoXCJcIikuc29ydChCKS5qb2luKFwiXCIpPT09dSxjLmRldGVjdER1cGxpY2F0ZXM9ISFsLG0oKSxjLnNvcnREZXRhY2hlZD1qYShmdW5jdGlvbihhKXtyZXR1cm4gMSZhLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKG4uY3JlYXRlRWxlbWVudChcImRpdlwiKSl9KSxqYShmdW5jdGlvbihhKXtyZXR1cm4gYS5pbm5lckhUTUw9XCI8YSBocmVmPScjJz48L2E+XCIsXCIjXCI9PT1hLmZpcnN0Q2hpbGQuZ2V0QXR0cmlidXRlKFwiaHJlZlwiKX0pfHxrYShcInR5cGV8aHJlZnxoZWlnaHR8d2lkdGhcIixmdW5jdGlvbihhLGIsYyl7cmV0dXJuIGM/dm9pZCAwOmEuZ2V0QXR0cmlidXRlKGIsXCJ0eXBlXCI9PT1iLnRvTG93ZXJDYXNlKCk/MToyKX0pLGMuYXR0cmlidXRlcyYmamEoZnVuY3Rpb24oYSl7cmV0dXJuIGEuaW5uZXJIVE1MPVwiPGlucHV0Lz5cIixhLmZpcnN0Q2hpbGQuc2V0QXR0cmlidXRlKFwidmFsdWVcIixcIlwiKSxcIlwiPT09YS5maXJzdENoaWxkLmdldEF0dHJpYnV0ZShcInZhbHVlXCIpfSl8fGthKFwidmFsdWVcIixmdW5jdGlvbihhLGIsYyl7cmV0dXJuIGN8fFwiaW5wdXRcIiE9PWEubm9kZU5hbWUudG9Mb3dlckNhc2UoKT92b2lkIDA6YS5kZWZhdWx0VmFsdWV9KSxqYShmdW5jdGlvbihhKXtyZXR1cm4gbnVsbD09YS5nZXRBdHRyaWJ1dGUoXCJkaXNhYmxlZFwiKX0pfHxrYShLLGZ1bmN0aW9uKGEsYixjKXt2YXIgZDtyZXR1cm4gYz92b2lkIDA6YVtiXT09PSEwP2IudG9Mb3dlckNhc2UoKTooZD1hLmdldEF0dHJpYnV0ZU5vZGUoYikpJiZkLnNwZWNpZmllZD9kLnZhbHVlOm51bGx9KSxnYX0oYSk7bS5maW5kPXMsbS5leHByPXMuc2VsZWN0b3JzLG0uZXhwcltcIjpcIl09bS5leHByLnBzZXVkb3MsbS51bmlxdWU9cy51bmlxdWVTb3J0LG0udGV4dD1zLmdldFRleHQsbS5pc1hNTERvYz1zLmlzWE1MLG0uY29udGFpbnM9cy5jb250YWluczt2YXIgdD1tLmV4cHIubWF0Y2gubmVlZHNDb250ZXh0LHU9L148KFxcdyspXFxzKlxcLz8+KD86PFxcL1xcMT58KSQvLHY9L14uW146I1xcW1xcLixdKiQvO2Z1bmN0aW9uIHcoYSxiLGMpe2lmKG0uaXNGdW5jdGlvbihiKSlyZXR1cm4gbS5ncmVwKGEsZnVuY3Rpb24oYSxkKXtyZXR1cm4hIWIuY2FsbChhLGQsYSkhPT1jfSk7aWYoYi5ub2RlVHlwZSlyZXR1cm4gbS5ncmVwKGEsZnVuY3Rpb24oYSl7cmV0dXJuIGE9PT1iIT09Y30pO2lmKFwic3RyaW5nXCI9PXR5cGVvZiBiKXtpZih2LnRlc3QoYikpcmV0dXJuIG0uZmlsdGVyKGIsYSxjKTtiPW0uZmlsdGVyKGIsYSl9cmV0dXJuIG0uZ3JlcChhLGZ1bmN0aW9uKGEpe3JldHVybiBtLmluQXJyYXkoYSxiKT49MCE9PWN9KX1tLmZpbHRlcj1mdW5jdGlvbihhLGIsYyl7dmFyIGQ9YlswXTtyZXR1cm4gYyYmKGE9XCI6bm90KFwiK2ErXCIpXCIpLDE9PT1iLmxlbmd0aCYmMT09PWQubm9kZVR5cGU/bS5maW5kLm1hdGNoZXNTZWxlY3RvcihkLGEpP1tkXTpbXTptLmZpbmQubWF0Y2hlcyhhLG0uZ3JlcChiLGZ1bmN0aW9uKGEpe3JldHVybiAxPT09YS5ub2RlVHlwZX0pKX0sbS5mbi5leHRlbmQoe2ZpbmQ6ZnVuY3Rpb24oYSl7dmFyIGIsYz1bXSxkPXRoaXMsZT1kLmxlbmd0aDtpZihcInN0cmluZ1wiIT10eXBlb2YgYSlyZXR1cm4gdGhpcy5wdXNoU3RhY2sobShhKS5maWx0ZXIoZnVuY3Rpb24oKXtmb3IoYj0wO2U+YjtiKyspaWYobS5jb250YWlucyhkW2JdLHRoaXMpKXJldHVybiEwfSkpO2ZvcihiPTA7ZT5iO2IrKyltLmZpbmQoYSxkW2JdLGMpO3JldHVybiBjPXRoaXMucHVzaFN0YWNrKGU+MT9tLnVuaXF1ZShjKTpjKSxjLnNlbGVjdG9yPXRoaXMuc2VsZWN0b3I/dGhpcy5zZWxlY3RvcitcIiBcIithOmEsY30sZmlsdGVyOmZ1bmN0aW9uKGEpe3JldHVybiB0aGlzLnB1c2hTdGFjayh3KHRoaXMsYXx8W10sITEpKX0sbm90OmZ1bmN0aW9uKGEpe3JldHVybiB0aGlzLnB1c2hTdGFjayh3KHRoaXMsYXx8W10sITApKX0saXM6ZnVuY3Rpb24oYSl7cmV0dXJuISF3KHRoaXMsXCJzdHJpbmdcIj09dHlwZW9mIGEmJnQudGVzdChhKT9tKGEpOmF8fFtdLCExKS5sZW5ndGh9fSk7dmFyIHgseT1hLmRvY3VtZW50LHo9L14oPzpcXHMqKDxbXFx3XFxXXSs+KVtePl0qfCMoW1xcdy1dKikpJC8sQT1tLmZuLmluaXQ9ZnVuY3Rpb24oYSxiKXt2YXIgYyxkO2lmKCFhKXJldHVybiB0aGlzO2lmKFwic3RyaW5nXCI9PXR5cGVvZiBhKXtpZihjPVwiPFwiPT09YS5jaGFyQXQoMCkmJlwiPlwiPT09YS5jaGFyQXQoYS5sZW5ndGgtMSkmJmEubGVuZ3RoPj0zP1tudWxsLGEsbnVsbF06ei5leGVjKGEpLCFjfHwhY1sxXSYmYilyZXR1cm4hYnx8Yi5qcXVlcnk/KGJ8fHgpLmZpbmQoYSk6dGhpcy5jb25zdHJ1Y3RvcihiKS5maW5kKGEpO2lmKGNbMV0pe2lmKGI9YiBpbnN0YW5jZW9mIG0/YlswXTpiLG0ubWVyZ2UodGhpcyxtLnBhcnNlSFRNTChjWzFdLGImJmIubm9kZVR5cGU/Yi5vd25lckRvY3VtZW50fHxiOnksITApKSx1LnRlc3QoY1sxXSkmJm0uaXNQbGFpbk9iamVjdChiKSlmb3IoYyBpbiBiKW0uaXNGdW5jdGlvbih0aGlzW2NdKT90aGlzW2NdKGJbY10pOnRoaXMuYXR0cihjLGJbY10pO3JldHVybiB0aGlzfWlmKGQ9eS5nZXRFbGVtZW50QnlJZChjWzJdKSxkJiZkLnBhcmVudE5vZGUpe2lmKGQuaWQhPT1jWzJdKXJldHVybiB4LmZpbmQoYSk7dGhpcy5sZW5ndGg9MSx0aGlzWzBdPWR9cmV0dXJuIHRoaXMuY29udGV4dD15LHRoaXMuc2VsZWN0b3I9YSx0aGlzfXJldHVybiBhLm5vZGVUeXBlPyh0aGlzLmNvbnRleHQ9dGhpc1swXT1hLHRoaXMubGVuZ3RoPTEsdGhpcyk6bS5pc0Z1bmN0aW9uKGEpP1widW5kZWZpbmVkXCIhPXR5cGVvZiB4LnJlYWR5P3gucmVhZHkoYSk6YShtKToodm9pZCAwIT09YS5zZWxlY3RvciYmKHRoaXMuc2VsZWN0b3I9YS5zZWxlY3Rvcix0aGlzLmNvbnRleHQ9YS5jb250ZXh0KSxtLm1ha2VBcnJheShhLHRoaXMpKX07QS5wcm90b3R5cGU9bS5mbix4PW0oeSk7dmFyIEI9L14oPzpwYXJlbnRzfHByZXYoPzpVbnRpbHxBbGwpKS8sQz17Y2hpbGRyZW46ITAsY29udGVudHM6ITAsbmV4dDohMCxwcmV2OiEwfTttLmV4dGVuZCh7ZGlyOmZ1bmN0aW9uKGEsYixjKXt2YXIgZD1bXSxlPWFbYl07d2hpbGUoZSYmOSE9PWUubm9kZVR5cGUmJih2b2lkIDA9PT1jfHwxIT09ZS5ub2RlVHlwZXx8IW0oZSkuaXMoYykpKTE9PT1lLm5vZGVUeXBlJiZkLnB1c2goZSksZT1lW2JdO3JldHVybiBkfSxzaWJsaW5nOmZ1bmN0aW9uKGEsYil7Zm9yKHZhciBjPVtdO2E7YT1hLm5leHRTaWJsaW5nKTE9PT1hLm5vZGVUeXBlJiZhIT09YiYmYy5wdXNoKGEpO3JldHVybiBjfX0pLG0uZm4uZXh0ZW5kKHtoYXM6ZnVuY3Rpb24oYSl7dmFyIGIsYz1tKGEsdGhpcyksZD1jLmxlbmd0aDtyZXR1cm4gdGhpcy5maWx0ZXIoZnVuY3Rpb24oKXtmb3IoYj0wO2Q+YjtiKyspaWYobS5jb250YWlucyh0aGlzLGNbYl0pKXJldHVybiEwfSl9LGNsb3Nlc3Q6ZnVuY3Rpb24oYSxiKXtmb3IodmFyIGMsZD0wLGU9dGhpcy5sZW5ndGgsZj1bXSxnPXQudGVzdChhKXx8XCJzdHJpbmdcIiE9dHlwZW9mIGE/bShhLGJ8fHRoaXMuY29udGV4dCk6MDtlPmQ7ZCsrKWZvcihjPXRoaXNbZF07YyYmYyE9PWI7Yz1jLnBhcmVudE5vZGUpaWYoYy5ub2RlVHlwZTwxMSYmKGc/Zy5pbmRleChjKT4tMToxPT09Yy5ub2RlVHlwZSYmbS5maW5kLm1hdGNoZXNTZWxlY3RvcihjLGEpKSl7Zi5wdXNoKGMpO2JyZWFrfXJldHVybiB0aGlzLnB1c2hTdGFjayhmLmxlbmd0aD4xP20udW5pcXVlKGYpOmYpfSxpbmRleDpmdW5jdGlvbihhKXtyZXR1cm4gYT9cInN0cmluZ1wiPT10eXBlb2YgYT9tLmluQXJyYXkodGhpc1swXSxtKGEpKTptLmluQXJyYXkoYS5qcXVlcnk/YVswXTphLHRoaXMpOnRoaXNbMF0mJnRoaXNbMF0ucGFyZW50Tm9kZT90aGlzLmZpcnN0KCkucHJldkFsbCgpLmxlbmd0aDotMX0sYWRkOmZ1bmN0aW9uKGEsYil7cmV0dXJuIHRoaXMucHVzaFN0YWNrKG0udW5pcXVlKG0ubWVyZ2UodGhpcy5nZXQoKSxtKGEsYikpKSl9LGFkZEJhY2s6ZnVuY3Rpb24oYSl7cmV0dXJuIHRoaXMuYWRkKG51bGw9PWE/dGhpcy5wcmV2T2JqZWN0OnRoaXMucHJldk9iamVjdC5maWx0ZXIoYSkpfX0pO2Z1bmN0aW9uIEQoYSxiKXtkbyBhPWFbYl07d2hpbGUoYSYmMSE9PWEubm9kZVR5cGUpO3JldHVybiBhfW0uZWFjaCh7cGFyZW50OmZ1bmN0aW9uKGEpe3ZhciBiPWEucGFyZW50Tm9kZTtyZXR1cm4gYiYmMTEhPT1iLm5vZGVUeXBlP2I6bnVsbH0scGFyZW50czpmdW5jdGlvbihhKXtyZXR1cm4gbS5kaXIoYSxcInBhcmVudE5vZGVcIil9LHBhcmVudHNVbnRpbDpmdW5jdGlvbihhLGIsYyl7cmV0dXJuIG0uZGlyKGEsXCJwYXJlbnROb2RlXCIsYyl9LG5leHQ6ZnVuY3Rpb24oYSl7cmV0dXJuIEQoYSxcIm5leHRTaWJsaW5nXCIpfSxwcmV2OmZ1bmN0aW9uKGEpe3JldHVybiBEKGEsXCJwcmV2aW91c1NpYmxpbmdcIil9LG5leHRBbGw6ZnVuY3Rpb24oYSl7cmV0dXJuIG0uZGlyKGEsXCJuZXh0U2libGluZ1wiKX0scHJldkFsbDpmdW5jdGlvbihhKXtyZXR1cm4gbS5kaXIoYSxcInByZXZpb3VzU2libGluZ1wiKX0sbmV4dFVudGlsOmZ1bmN0aW9uKGEsYixjKXtyZXR1cm4gbS5kaXIoYSxcIm5leHRTaWJsaW5nXCIsYyl9LHByZXZVbnRpbDpmdW5jdGlvbihhLGIsYyl7cmV0dXJuIG0uZGlyKGEsXCJwcmV2aW91c1NpYmxpbmdcIixjKX0sc2libGluZ3M6ZnVuY3Rpb24oYSl7cmV0dXJuIG0uc2libGluZygoYS5wYXJlbnROb2RlfHx7fSkuZmlyc3RDaGlsZCxhKX0sY2hpbGRyZW46ZnVuY3Rpb24oYSl7cmV0dXJuIG0uc2libGluZyhhLmZpcnN0Q2hpbGQpfSxjb250ZW50czpmdW5jdGlvbihhKXtyZXR1cm4gbS5ub2RlTmFtZShhLFwiaWZyYW1lXCIpP2EuY29udGVudERvY3VtZW50fHxhLmNvbnRlbnRXaW5kb3cuZG9jdW1lbnQ6bS5tZXJnZShbXSxhLmNoaWxkTm9kZXMpfX0sZnVuY3Rpb24oYSxiKXttLmZuW2FdPWZ1bmN0aW9uKGMsZCl7dmFyIGU9bS5tYXAodGhpcyxiLGMpO3JldHVyblwiVW50aWxcIiE9PWEuc2xpY2UoLTUpJiYoZD1jKSxkJiZcInN0cmluZ1wiPT10eXBlb2YgZCYmKGU9bS5maWx0ZXIoZCxlKSksdGhpcy5sZW5ndGg+MSYmKENbYV18fChlPW0udW5pcXVlKGUpKSxCLnRlc3QoYSkmJihlPWUucmV2ZXJzZSgpKSksdGhpcy5wdXNoU3RhY2soZSl9fSk7dmFyIEU9L1xcUysvZyxGPXt9O2Z1bmN0aW9uIEcoYSl7dmFyIGI9RlthXT17fTtyZXR1cm4gbS5lYWNoKGEubWF0Y2goRSl8fFtdLGZ1bmN0aW9uKGEsYyl7YltjXT0hMH0pLGJ9bS5DYWxsYmFja3M9ZnVuY3Rpb24oYSl7YT1cInN0cmluZ1wiPT10eXBlb2YgYT9GW2FdfHxHKGEpOm0uZXh0ZW5kKHt9LGEpO3ZhciBiLGMsZCxlLGYsZyxoPVtdLGk9IWEub25jZSYmW10saj1mdW5jdGlvbihsKXtmb3IoYz1hLm1lbW9yeSYmbCxkPSEwLGY9Z3x8MCxnPTAsZT1oLmxlbmd0aCxiPSEwO2gmJmU+ZjtmKyspaWYoaFtmXS5hcHBseShsWzBdLGxbMV0pPT09ITEmJmEuc3RvcE9uRmFsc2Upe2M9ITE7YnJlYWt9Yj0hMSxoJiYoaT9pLmxlbmd0aCYmaihpLnNoaWZ0KCkpOmM/aD1bXTprLmRpc2FibGUoKSl9LGs9e2FkZDpmdW5jdGlvbigpe2lmKGgpe3ZhciBkPWgubGVuZ3RoOyFmdW5jdGlvbiBmKGIpe20uZWFjaChiLGZ1bmN0aW9uKGIsYyl7dmFyIGQ9bS50eXBlKGMpO1wiZnVuY3Rpb25cIj09PWQ/YS51bmlxdWUmJmsuaGFzKGMpfHxoLnB1c2goYyk6YyYmYy5sZW5ndGgmJlwic3RyaW5nXCIhPT1kJiZmKGMpfSl9KGFyZ3VtZW50cyksYj9lPWgubGVuZ3RoOmMmJihnPWQsaihjKSl9cmV0dXJuIHRoaXN9LHJlbW92ZTpmdW5jdGlvbigpe3JldHVybiBoJiZtLmVhY2goYXJndW1lbnRzLGZ1bmN0aW9uKGEsYyl7dmFyIGQ7d2hpbGUoKGQ9bS5pbkFycmF5KGMsaCxkKSk+LTEpaC5zcGxpY2UoZCwxKSxiJiYoZT49ZCYmZS0tLGY+PWQmJmYtLSl9KSx0aGlzfSxoYXM6ZnVuY3Rpb24oYSl7cmV0dXJuIGE/bS5pbkFycmF5KGEsaCk+LTE6ISghaHx8IWgubGVuZ3RoKX0sZW1wdHk6ZnVuY3Rpb24oKXtyZXR1cm4gaD1bXSxlPTAsdGhpc30sZGlzYWJsZTpmdW5jdGlvbigpe3JldHVybiBoPWk9Yz12b2lkIDAsdGhpc30sZGlzYWJsZWQ6ZnVuY3Rpb24oKXtyZXR1cm4haH0sbG9jazpmdW5jdGlvbigpe3JldHVybiBpPXZvaWQgMCxjfHxrLmRpc2FibGUoKSx0aGlzfSxsb2NrZWQ6ZnVuY3Rpb24oKXtyZXR1cm4haX0sZmlyZVdpdGg6ZnVuY3Rpb24oYSxjKXtyZXR1cm4haHx8ZCYmIWl8fChjPWN8fFtdLGM9W2EsYy5zbGljZT9jLnNsaWNlKCk6Y10sYj9pLnB1c2goYyk6aihjKSksdGhpc30sZmlyZTpmdW5jdGlvbigpe3JldHVybiBrLmZpcmVXaXRoKHRoaXMsYXJndW1lbnRzKSx0aGlzfSxmaXJlZDpmdW5jdGlvbigpe3JldHVybiEhZH19O3JldHVybiBrfSxtLmV4dGVuZCh7RGVmZXJyZWQ6ZnVuY3Rpb24oYSl7dmFyIGI9W1tcInJlc29sdmVcIixcImRvbmVcIixtLkNhbGxiYWNrcyhcIm9uY2UgbWVtb3J5XCIpLFwicmVzb2x2ZWRcIl0sW1wicmVqZWN0XCIsXCJmYWlsXCIsbS5DYWxsYmFja3MoXCJvbmNlIG1lbW9yeVwiKSxcInJlamVjdGVkXCJdLFtcIm5vdGlmeVwiLFwicHJvZ3Jlc3NcIixtLkNhbGxiYWNrcyhcIm1lbW9yeVwiKV1dLGM9XCJwZW5kaW5nXCIsZD17c3RhdGU6ZnVuY3Rpb24oKXtyZXR1cm4gY30sYWx3YXlzOmZ1bmN0aW9uKCl7cmV0dXJuIGUuZG9uZShhcmd1bWVudHMpLmZhaWwoYXJndW1lbnRzKSx0aGlzfSx0aGVuOmZ1bmN0aW9uKCl7dmFyIGE9YXJndW1lbnRzO3JldHVybiBtLkRlZmVycmVkKGZ1bmN0aW9uKGMpe20uZWFjaChiLGZ1bmN0aW9uKGIsZil7dmFyIGc9bS5pc0Z1bmN0aW9uKGFbYl0pJiZhW2JdO2VbZlsxXV0oZnVuY3Rpb24oKXt2YXIgYT1nJiZnLmFwcGx5KHRoaXMsYXJndW1lbnRzKTthJiZtLmlzRnVuY3Rpb24oYS5wcm9taXNlKT9hLnByb21pc2UoKS5kb25lKGMucmVzb2x2ZSkuZmFpbChjLnJlamVjdCkucHJvZ3Jlc3MoYy5ub3RpZnkpOmNbZlswXStcIldpdGhcIl0odGhpcz09PWQ/Yy5wcm9taXNlKCk6dGhpcyxnP1thXTphcmd1bWVudHMpfSl9KSxhPW51bGx9KS5wcm9taXNlKCl9LHByb21pc2U6ZnVuY3Rpb24oYSl7cmV0dXJuIG51bGwhPWE/bS5leHRlbmQoYSxkKTpkfX0sZT17fTtyZXR1cm4gZC5waXBlPWQudGhlbixtLmVhY2goYixmdW5jdGlvbihhLGYpe3ZhciBnPWZbMl0saD1mWzNdO2RbZlsxXV09Zy5hZGQsaCYmZy5hZGQoZnVuY3Rpb24oKXtjPWh9LGJbMV5hXVsyXS5kaXNhYmxlLGJbMl1bMl0ubG9jayksZVtmWzBdXT1mdW5jdGlvbigpe3JldHVybiBlW2ZbMF0rXCJXaXRoXCJdKHRoaXM9PT1lP2Q6dGhpcyxhcmd1bWVudHMpLHRoaXN9LGVbZlswXStcIldpdGhcIl09Zy5maXJlV2l0aH0pLGQucHJvbWlzZShlKSxhJiZhLmNhbGwoZSxlKSxlfSx3aGVuOmZ1bmN0aW9uKGEpe3ZhciBiPTAsYz1kLmNhbGwoYXJndW1lbnRzKSxlPWMubGVuZ3RoLGY9MSE9PWV8fGEmJm0uaXNGdW5jdGlvbihhLnByb21pc2UpP2U6MCxnPTE9PT1mP2E6bS5EZWZlcnJlZCgpLGg9ZnVuY3Rpb24oYSxiLGMpe3JldHVybiBmdW5jdGlvbihlKXtiW2FdPXRoaXMsY1thXT1hcmd1bWVudHMubGVuZ3RoPjE/ZC5jYWxsKGFyZ3VtZW50cyk6ZSxjPT09aT9nLm5vdGlmeVdpdGgoYixjKTotLWZ8fGcucmVzb2x2ZVdpdGgoYixjKX19LGksaixrO2lmKGU+MSlmb3IoaT1uZXcgQXJyYXkoZSksaj1uZXcgQXJyYXkoZSksaz1uZXcgQXJyYXkoZSk7ZT5iO2IrKyljW2JdJiZtLmlzRnVuY3Rpb24oY1tiXS5wcm9taXNlKT9jW2JdLnByb21pc2UoKS5kb25lKGgoYixrLGMpKS5mYWlsKGcucmVqZWN0KS5wcm9ncmVzcyhoKGIsaixpKSk6LS1mO3JldHVybiBmfHxnLnJlc29sdmVXaXRoKGssYyksZy5wcm9taXNlKCl9fSk7dmFyIEg7bS5mbi5yZWFkeT1mdW5jdGlvbihhKXtyZXR1cm4gbS5yZWFkeS5wcm9taXNlKCkuZG9uZShhKSx0aGlzfSxtLmV4dGVuZCh7aXNSZWFkeTohMSxyZWFkeVdhaXQ6MSxob2xkUmVhZHk6ZnVuY3Rpb24oYSl7YT9tLnJlYWR5V2FpdCsrOm0ucmVhZHkoITApfSxyZWFkeTpmdW5jdGlvbihhKXtpZihhPT09ITA/IS0tbS5yZWFkeVdhaXQ6IW0uaXNSZWFkeSl7aWYoIXkuYm9keSlyZXR1cm4gc2V0VGltZW91dChtLnJlYWR5KTttLmlzUmVhZHk9ITAsYSE9PSEwJiYtLW0ucmVhZHlXYWl0PjB8fChILnJlc29sdmVXaXRoKHksW21dKSxtLmZuLnRyaWdnZXJIYW5kbGVyJiYobSh5KS50cmlnZ2VySGFuZGxlcihcInJlYWR5XCIpLG0oeSkub2ZmKFwicmVhZHlcIikpKX19fSk7ZnVuY3Rpb24gSSgpe3kuYWRkRXZlbnRMaXN0ZW5lcj8oeS5yZW1vdmVFdmVudExpc3RlbmVyKFwiRE9NQ29udGVudExvYWRlZFwiLEosITEpLGEucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImxvYWRcIixKLCExKSk6KHkuZGV0YWNoRXZlbnQoXCJvbnJlYWR5c3RhdGVjaGFuZ2VcIixKKSxhLmRldGFjaEV2ZW50KFwib25sb2FkXCIsSikpfWZ1bmN0aW9uIEooKXsoeS5hZGRFdmVudExpc3RlbmVyfHxcImxvYWRcIj09PWV2ZW50LnR5cGV8fFwiY29tcGxldGVcIj09PXkucmVhZHlTdGF0ZSkmJihJKCksbS5yZWFkeSgpKX1tLnJlYWR5LnByb21pc2U9ZnVuY3Rpb24oYil7aWYoIUgpaWYoSD1tLkRlZmVycmVkKCksXCJjb21wbGV0ZVwiPT09eS5yZWFkeVN0YXRlKXNldFRpbWVvdXQobS5yZWFkeSk7ZWxzZSBpZih5LmFkZEV2ZW50TGlzdGVuZXIpeS5hZGRFdmVudExpc3RlbmVyKFwiRE9NQ29udGVudExvYWRlZFwiLEosITEpLGEuYWRkRXZlbnRMaXN0ZW5lcihcImxvYWRcIixKLCExKTtlbHNle3kuYXR0YWNoRXZlbnQoXCJvbnJlYWR5c3RhdGVjaGFuZ2VcIixKKSxhLmF0dGFjaEV2ZW50KFwib25sb2FkXCIsSik7dmFyIGM9ITE7dHJ5e2M9bnVsbD09YS5mcmFtZUVsZW1lbnQmJnkuZG9jdW1lbnRFbGVtZW50fWNhdGNoKGQpe31jJiZjLmRvU2Nyb2xsJiYhZnVuY3Rpb24gZSgpe2lmKCFtLmlzUmVhZHkpe3RyeXtjLmRvU2Nyb2xsKFwibGVmdFwiKX1jYXRjaChhKXtyZXR1cm4gc2V0VGltZW91dChlLDUwKX1JKCksbS5yZWFkeSgpfX0oKX1yZXR1cm4gSC5wcm9taXNlKGIpfTt2YXIgSz1cInVuZGVmaW5lZFwiLEw7Zm9yKEwgaW4gbShrKSlicmVhaztrLm93bkxhc3Q9XCIwXCIhPT1MLGsuaW5saW5lQmxvY2tOZWVkc0xheW91dD0hMSxtKGZ1bmN0aW9uKCl7dmFyIGEsYixjLGQ7Yz15LmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiYm9keVwiKVswXSxjJiZjLnN0eWxlJiYoYj15LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiksZD15LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiksZC5zdHlsZS5jc3NUZXh0PVwicG9zaXRpb246YWJzb2x1dGU7Ym9yZGVyOjA7d2lkdGg6MDtoZWlnaHQ6MDt0b3A6MDtsZWZ0Oi05OTk5cHhcIixjLmFwcGVuZENoaWxkKGQpLmFwcGVuZENoaWxkKGIpLHR5cGVvZiBiLnN0eWxlLnpvb20hPT1LJiYoYi5zdHlsZS5jc3NUZXh0PVwiZGlzcGxheTppbmxpbmU7bWFyZ2luOjA7Ym9yZGVyOjA7cGFkZGluZzoxcHg7d2lkdGg6MXB4O3pvb206MVwiLGsuaW5saW5lQmxvY2tOZWVkc0xheW91dD1hPTM9PT1iLm9mZnNldFdpZHRoLGEmJihjLnN0eWxlLnpvb209MSkpLGMucmVtb3ZlQ2hpbGQoZCkpfSksZnVuY3Rpb24oKXt2YXIgYT15LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7aWYobnVsbD09ay5kZWxldGVFeHBhbmRvKXtrLmRlbGV0ZUV4cGFuZG89ITA7dHJ5e2RlbGV0ZSBhLnRlc3R9Y2F0Y2goYil7ay5kZWxldGVFeHBhbmRvPSExfX1hPW51bGx9KCksbS5hY2NlcHREYXRhPWZ1bmN0aW9uKGEpe3ZhciBiPW0ubm9EYXRhWyhhLm5vZGVOYW1lK1wiIFwiKS50b0xvd2VyQ2FzZSgpXSxjPSthLm5vZGVUeXBlfHwxO3JldHVybiAxIT09YyYmOSE9PWM/ITE6IWJ8fGIhPT0hMCYmYS5nZXRBdHRyaWJ1dGUoXCJjbGFzc2lkXCIpPT09Yn07dmFyIE09L14oPzpcXHtbXFx3XFxXXSpcXH18XFxbW1xcd1xcV10qXFxdKSQvLE49LyhbQS1aXSkvZztmdW5jdGlvbiBPKGEsYixjKXtpZih2b2lkIDA9PT1jJiYxPT09YS5ub2RlVHlwZSl7dmFyIGQ9XCJkYXRhLVwiK2IucmVwbGFjZShOLFwiLSQxXCIpLnRvTG93ZXJDYXNlKCk7aWYoYz1hLmdldEF0dHJpYnV0ZShkKSxcInN0cmluZ1wiPT10eXBlb2YgYyl7dHJ5e2M9XCJ0cnVlXCI9PT1jPyEwOlwiZmFsc2VcIj09PWM/ITE6XCJudWxsXCI9PT1jP251bGw6K2MrXCJcIj09PWM/K2M6TS50ZXN0KGMpP20ucGFyc2VKU09OKGMpOmN9Y2F0Y2goZSl7fW0uZGF0YShhLGIsYyl9ZWxzZSBjPXZvaWQgMH1yZXR1cm4gY31mdW5jdGlvbiBQKGEpe3ZhciBiO2ZvcihiIGluIGEpaWYoKFwiZGF0YVwiIT09Ynx8IW0uaXNFbXB0eU9iamVjdChhW2JdKSkmJlwidG9KU09OXCIhPT1iKXJldHVybiExO1xyXG5cclxucmV0dXJuITB9ZnVuY3Rpb24gUShhLGIsZCxlKXtpZihtLmFjY2VwdERhdGEoYSkpe3ZhciBmLGcsaD1tLmV4cGFuZG8saT1hLm5vZGVUeXBlLGo9aT9tLmNhY2hlOmEsaz1pP2FbaF06YVtoXSYmaDtpZihrJiZqW2tdJiYoZXx8altrXS5kYXRhKXx8dm9pZCAwIT09ZHx8XCJzdHJpbmdcIiE9dHlwZW9mIGIpcmV0dXJuIGt8fChrPWk/YVtoXT1jLnBvcCgpfHxtLmd1aWQrKzpoKSxqW2tdfHwoaltrXT1pP3t9Ont0b0pTT046bS5ub29wfSksKFwib2JqZWN0XCI9PXR5cGVvZiBifHxcImZ1bmN0aW9uXCI9PXR5cGVvZiBiKSYmKGU/altrXT1tLmV4dGVuZChqW2tdLGIpOmpba10uZGF0YT1tLmV4dGVuZChqW2tdLmRhdGEsYikpLGc9altrXSxlfHwoZy5kYXRhfHwoZy5kYXRhPXt9KSxnPWcuZGF0YSksdm9pZCAwIT09ZCYmKGdbbS5jYW1lbENhc2UoYildPWQpLFwic3RyaW5nXCI9PXR5cGVvZiBiPyhmPWdbYl0sbnVsbD09ZiYmKGY9Z1ttLmNhbWVsQ2FzZShiKV0pKTpmPWcsZn19ZnVuY3Rpb24gUihhLGIsYyl7aWYobS5hY2NlcHREYXRhKGEpKXt2YXIgZCxlLGY9YS5ub2RlVHlwZSxnPWY/bS5jYWNoZTphLGg9Zj9hW20uZXhwYW5kb106bS5leHBhbmRvO2lmKGdbaF0pe2lmKGImJihkPWM/Z1toXTpnW2hdLmRhdGEpKXttLmlzQXJyYXkoYik/Yj1iLmNvbmNhdChtLm1hcChiLG0uY2FtZWxDYXNlKSk6YiBpbiBkP2I9W2JdOihiPW0uY2FtZWxDYXNlKGIpLGI9YiBpbiBkP1tiXTpiLnNwbGl0KFwiIFwiKSksZT1iLmxlbmd0aDt3aGlsZShlLS0pZGVsZXRlIGRbYltlXV07aWYoYz8hUChkKTohbS5pc0VtcHR5T2JqZWN0KGQpKXJldHVybn0oY3x8KGRlbGV0ZSBnW2hdLmRhdGEsUChnW2hdKSkpJiYoZj9tLmNsZWFuRGF0YShbYV0sITApOmsuZGVsZXRlRXhwYW5kb3x8ZyE9Zy53aW5kb3c/ZGVsZXRlIGdbaF06Z1toXT1udWxsKX19fW0uZXh0ZW5kKHtjYWNoZTp7fSxub0RhdGE6e1wiYXBwbGV0IFwiOiEwLFwiZW1iZWQgXCI6ITAsXCJvYmplY3QgXCI6XCJjbHNpZDpEMjdDREI2RS1BRTZELTExY2YtOTZCOC00NDQ1NTM1NDAwMDBcIn0saGFzRGF0YTpmdW5jdGlvbihhKXtyZXR1cm4gYT1hLm5vZGVUeXBlP20uY2FjaGVbYVttLmV4cGFuZG9dXTphW20uZXhwYW5kb10sISFhJiYhUChhKX0sZGF0YTpmdW5jdGlvbihhLGIsYyl7cmV0dXJuIFEoYSxiLGMpfSxyZW1vdmVEYXRhOmZ1bmN0aW9uKGEsYil7cmV0dXJuIFIoYSxiKX0sX2RhdGE6ZnVuY3Rpb24oYSxiLGMpe3JldHVybiBRKGEsYixjLCEwKX0sX3JlbW92ZURhdGE6ZnVuY3Rpb24oYSxiKXtyZXR1cm4gUihhLGIsITApfX0pLG0uZm4uZXh0ZW5kKHtkYXRhOmZ1bmN0aW9uKGEsYil7dmFyIGMsZCxlLGY9dGhpc1swXSxnPWYmJmYuYXR0cmlidXRlcztpZih2b2lkIDA9PT1hKXtpZih0aGlzLmxlbmd0aCYmKGU9bS5kYXRhKGYpLDE9PT1mLm5vZGVUeXBlJiYhbS5fZGF0YShmLFwicGFyc2VkQXR0cnNcIikpKXtjPWcubGVuZ3RoO3doaWxlKGMtLSlnW2NdJiYoZD1nW2NdLm5hbWUsMD09PWQuaW5kZXhPZihcImRhdGEtXCIpJiYoZD1tLmNhbWVsQ2FzZShkLnNsaWNlKDUpKSxPKGYsZCxlW2RdKSkpO20uX2RhdGEoZixcInBhcnNlZEF0dHJzXCIsITApfXJldHVybiBlfXJldHVyblwib2JqZWN0XCI9PXR5cGVvZiBhP3RoaXMuZWFjaChmdW5jdGlvbigpe20uZGF0YSh0aGlzLGEpfSk6YXJndW1lbnRzLmxlbmd0aD4xP3RoaXMuZWFjaChmdW5jdGlvbigpe20uZGF0YSh0aGlzLGEsYil9KTpmP08oZixhLG0uZGF0YShmLGEpKTp2b2lkIDB9LHJlbW92ZURhdGE6ZnVuY3Rpb24oYSl7cmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpe20ucmVtb3ZlRGF0YSh0aGlzLGEpfSl9fSksbS5leHRlbmQoe3F1ZXVlOmZ1bmN0aW9uKGEsYixjKXt2YXIgZDtyZXR1cm4gYT8oYj0oYnx8XCJmeFwiKStcInF1ZXVlXCIsZD1tLl9kYXRhKGEsYiksYyYmKCFkfHxtLmlzQXJyYXkoYyk/ZD1tLl9kYXRhKGEsYixtLm1ha2VBcnJheShjKSk6ZC5wdXNoKGMpKSxkfHxbXSk6dm9pZCAwfSxkZXF1ZXVlOmZ1bmN0aW9uKGEsYil7Yj1ifHxcImZ4XCI7dmFyIGM9bS5xdWV1ZShhLGIpLGQ9Yy5sZW5ndGgsZT1jLnNoaWZ0KCksZj1tLl9xdWV1ZUhvb2tzKGEsYiksZz1mdW5jdGlvbigpe20uZGVxdWV1ZShhLGIpfTtcImlucHJvZ3Jlc3NcIj09PWUmJihlPWMuc2hpZnQoKSxkLS0pLGUmJihcImZ4XCI9PT1iJiZjLnVuc2hpZnQoXCJpbnByb2dyZXNzXCIpLGRlbGV0ZSBmLnN0b3AsZS5jYWxsKGEsZyxmKSksIWQmJmYmJmYuZW1wdHkuZmlyZSgpfSxfcXVldWVIb29rczpmdW5jdGlvbihhLGIpe3ZhciBjPWIrXCJxdWV1ZUhvb2tzXCI7cmV0dXJuIG0uX2RhdGEoYSxjKXx8bS5fZGF0YShhLGMse2VtcHR5Om0uQ2FsbGJhY2tzKFwib25jZSBtZW1vcnlcIikuYWRkKGZ1bmN0aW9uKCl7bS5fcmVtb3ZlRGF0YShhLGIrXCJxdWV1ZVwiKSxtLl9yZW1vdmVEYXRhKGEsYyl9KX0pfX0pLG0uZm4uZXh0ZW5kKHtxdWV1ZTpmdW5jdGlvbihhLGIpe3ZhciBjPTI7cmV0dXJuXCJzdHJpbmdcIiE9dHlwZW9mIGEmJihiPWEsYT1cImZ4XCIsYy0tKSxhcmd1bWVudHMubGVuZ3RoPGM/bS5xdWV1ZSh0aGlzWzBdLGEpOnZvaWQgMD09PWI/dGhpczp0aGlzLmVhY2goZnVuY3Rpb24oKXt2YXIgYz1tLnF1ZXVlKHRoaXMsYSxiKTttLl9xdWV1ZUhvb2tzKHRoaXMsYSksXCJmeFwiPT09YSYmXCJpbnByb2dyZXNzXCIhPT1jWzBdJiZtLmRlcXVldWUodGhpcyxhKX0pfSxkZXF1ZXVlOmZ1bmN0aW9uKGEpe3JldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKXttLmRlcXVldWUodGhpcyxhKX0pfSxjbGVhclF1ZXVlOmZ1bmN0aW9uKGEpe3JldHVybiB0aGlzLnF1ZXVlKGF8fFwiZnhcIixbXSl9LHByb21pc2U6ZnVuY3Rpb24oYSxiKXt2YXIgYyxkPTEsZT1tLkRlZmVycmVkKCksZj10aGlzLGc9dGhpcy5sZW5ndGgsaD1mdW5jdGlvbigpey0tZHx8ZS5yZXNvbHZlV2l0aChmLFtmXSl9O1wic3RyaW5nXCIhPXR5cGVvZiBhJiYoYj1hLGE9dm9pZCAwKSxhPWF8fFwiZnhcIjt3aGlsZShnLS0pYz1tLl9kYXRhKGZbZ10sYStcInF1ZXVlSG9va3NcIiksYyYmYy5lbXB0eSYmKGQrKyxjLmVtcHR5LmFkZChoKSk7cmV0dXJuIGgoKSxlLnByb21pc2UoYil9fSk7dmFyIFM9L1srLV0/KD86XFxkKlxcLnwpXFxkKyg/OltlRV1bKy1dP1xcZCt8KS8uc291cmNlLFQ9W1wiVG9wXCIsXCJSaWdodFwiLFwiQm90dG9tXCIsXCJMZWZ0XCJdLFU9ZnVuY3Rpb24oYSxiKXtyZXR1cm4gYT1ifHxhLFwibm9uZVwiPT09bS5jc3MoYSxcImRpc3BsYXlcIil8fCFtLmNvbnRhaW5zKGEub3duZXJEb2N1bWVudCxhKX0sVj1tLmFjY2Vzcz1mdW5jdGlvbihhLGIsYyxkLGUsZixnKXt2YXIgaD0wLGk9YS5sZW5ndGgsaj1udWxsPT1jO2lmKFwib2JqZWN0XCI9PT1tLnR5cGUoYykpe2U9ITA7Zm9yKGggaW4gYyltLmFjY2VzcyhhLGIsaCxjW2hdLCEwLGYsZyl9ZWxzZSBpZih2b2lkIDAhPT1kJiYoZT0hMCxtLmlzRnVuY3Rpb24oZCl8fChnPSEwKSxqJiYoZz8oYi5jYWxsKGEsZCksYj1udWxsKTooaj1iLGI9ZnVuY3Rpb24oYSxiLGMpe3JldHVybiBqLmNhbGwobShhKSxjKX0pKSxiKSlmb3IoO2k+aDtoKyspYihhW2hdLGMsZz9kOmQuY2FsbChhW2hdLGgsYihhW2hdLGMpKSk7cmV0dXJuIGU/YTpqP2IuY2FsbChhKTppP2IoYVswXSxjKTpmfSxXPS9eKD86Y2hlY2tib3h8cmFkaW8pJC9pOyFmdW5jdGlvbigpe3ZhciBhPXkuY3JlYXRlRWxlbWVudChcImlucHV0XCIpLGI9eS5jcmVhdGVFbGVtZW50KFwiZGl2XCIpLGM9eS5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7aWYoYi5pbm5lckhUTUw9XCIgIDxsaW5rLz48dGFibGU+PC90YWJsZT48YSBocmVmPScvYSc+YTwvYT48aW5wdXQgdHlwZT0nY2hlY2tib3gnLz5cIixrLmxlYWRpbmdXaGl0ZXNwYWNlPTM9PT1iLmZpcnN0Q2hpbGQubm9kZVR5cGUsay50Ym9keT0hYi5nZXRFbGVtZW50c0J5VGFnTmFtZShcInRib2R5XCIpLmxlbmd0aCxrLmh0bWxTZXJpYWxpemU9ISFiLmdldEVsZW1lbnRzQnlUYWdOYW1lKFwibGlua1wiKS5sZW5ndGgsay5odG1sNUNsb25lPVwiPDpuYXY+PC86bmF2PlwiIT09eS5jcmVhdGVFbGVtZW50KFwibmF2XCIpLmNsb25lTm9kZSghMCkub3V0ZXJIVE1MLGEudHlwZT1cImNoZWNrYm94XCIsYS5jaGVja2VkPSEwLGMuYXBwZW5kQ2hpbGQoYSksay5hcHBlbmRDaGVja2VkPWEuY2hlY2tlZCxiLmlubmVySFRNTD1cIjx0ZXh0YXJlYT54PC90ZXh0YXJlYT5cIixrLm5vQ2xvbmVDaGVja2VkPSEhYi5jbG9uZU5vZGUoITApLmxhc3RDaGlsZC5kZWZhdWx0VmFsdWUsYy5hcHBlbmRDaGlsZChiKSxiLmlubmVySFRNTD1cIjxpbnB1dCB0eXBlPSdyYWRpbycgY2hlY2tlZD0nY2hlY2tlZCcgbmFtZT0ndCcvPlwiLGsuY2hlY2tDbG9uZT1iLmNsb25lTm9kZSghMCkuY2xvbmVOb2RlKCEwKS5sYXN0Q2hpbGQuY2hlY2tlZCxrLm5vQ2xvbmVFdmVudD0hMCxiLmF0dGFjaEV2ZW50JiYoYi5hdHRhY2hFdmVudChcIm9uY2xpY2tcIixmdW5jdGlvbigpe2subm9DbG9uZUV2ZW50PSExfSksYi5jbG9uZU5vZGUoITApLmNsaWNrKCkpLG51bGw9PWsuZGVsZXRlRXhwYW5kbyl7ay5kZWxldGVFeHBhbmRvPSEwO3RyeXtkZWxldGUgYi50ZXN0fWNhdGNoKGQpe2suZGVsZXRlRXhwYW5kbz0hMX19fSgpLGZ1bmN0aW9uKCl7dmFyIGIsYyxkPXkuY3JlYXRlRWxlbWVudChcImRpdlwiKTtmb3IoYiBpbntzdWJtaXQ6ITAsY2hhbmdlOiEwLGZvY3VzaW46ITB9KWM9XCJvblwiK2IsKGtbYitcIkJ1YmJsZXNcIl09YyBpbiBhKXx8KGQuc2V0QXR0cmlidXRlKGMsXCJ0XCIpLGtbYitcIkJ1YmJsZXNcIl09ZC5hdHRyaWJ1dGVzW2NdLmV4cGFuZG89PT0hMSk7ZD1udWxsfSgpO3ZhciBYPS9eKD86aW5wdXR8c2VsZWN0fHRleHRhcmVhKSQvaSxZPS9ea2V5LyxaPS9eKD86bW91c2V8cG9pbnRlcnxjb250ZXh0bWVudSl8Y2xpY2svLCQ9L14oPzpmb2N1c2luZm9jdXN8Zm9jdXNvdXRibHVyKSQvLF89L14oW14uXSopKD86XFwuKC4rKXwpJC87ZnVuY3Rpb24gYWEoKXtyZXR1cm4hMH1mdW5jdGlvbiBiYSgpe3JldHVybiExfWZ1bmN0aW9uIGNhKCl7dHJ5e3JldHVybiB5LmFjdGl2ZUVsZW1lbnR9Y2F0Y2goYSl7fX1tLmV2ZW50PXtnbG9iYWw6e30sYWRkOmZ1bmN0aW9uKGEsYixjLGQsZSl7dmFyIGYsZyxoLGksaixrLGwsbixvLHAscSxyPW0uX2RhdGEoYSk7aWYocil7Yy5oYW5kbGVyJiYoaT1jLGM9aS5oYW5kbGVyLGU9aS5zZWxlY3RvciksYy5ndWlkfHwoYy5ndWlkPW0uZ3VpZCsrKSwoZz1yLmV2ZW50cyl8fChnPXIuZXZlbnRzPXt9KSwoaz1yLmhhbmRsZSl8fChrPXIuaGFuZGxlPWZ1bmN0aW9uKGEpe3JldHVybiB0eXBlb2YgbT09PUt8fGEmJm0uZXZlbnQudHJpZ2dlcmVkPT09YS50eXBlP3ZvaWQgMDptLmV2ZW50LmRpc3BhdGNoLmFwcGx5KGsuZWxlbSxhcmd1bWVudHMpfSxrLmVsZW09YSksYj0oYnx8XCJcIikubWF0Y2goRSl8fFtcIlwiXSxoPWIubGVuZ3RoO3doaWxlKGgtLSlmPV8uZXhlYyhiW2hdKXx8W10sbz1xPWZbMV0scD0oZlsyXXx8XCJcIikuc3BsaXQoXCIuXCIpLnNvcnQoKSxvJiYoaj1tLmV2ZW50LnNwZWNpYWxbb118fHt9LG89KGU/ai5kZWxlZ2F0ZVR5cGU6ai5iaW5kVHlwZSl8fG8saj1tLmV2ZW50LnNwZWNpYWxbb118fHt9LGw9bS5leHRlbmQoe3R5cGU6byxvcmlnVHlwZTpxLGRhdGE6ZCxoYW5kbGVyOmMsZ3VpZDpjLmd1aWQsc2VsZWN0b3I6ZSxuZWVkc0NvbnRleHQ6ZSYmbS5leHByLm1hdGNoLm5lZWRzQ29udGV4dC50ZXN0KGUpLG5hbWVzcGFjZTpwLmpvaW4oXCIuXCIpfSxpKSwobj1nW29dKXx8KG49Z1tvXT1bXSxuLmRlbGVnYXRlQ291bnQ9MCxqLnNldHVwJiZqLnNldHVwLmNhbGwoYSxkLHAsaykhPT0hMXx8KGEuYWRkRXZlbnRMaXN0ZW5lcj9hLmFkZEV2ZW50TGlzdGVuZXIobyxrLCExKTphLmF0dGFjaEV2ZW50JiZhLmF0dGFjaEV2ZW50KFwib25cIitvLGspKSksai5hZGQmJihqLmFkZC5jYWxsKGEsbCksbC5oYW5kbGVyLmd1aWR8fChsLmhhbmRsZXIuZ3VpZD1jLmd1aWQpKSxlP24uc3BsaWNlKG4uZGVsZWdhdGVDb3VudCsrLDAsbCk6bi5wdXNoKGwpLG0uZXZlbnQuZ2xvYmFsW29dPSEwKTthPW51bGx9fSxyZW1vdmU6ZnVuY3Rpb24oYSxiLGMsZCxlKXt2YXIgZixnLGgsaSxqLGssbCxuLG8scCxxLHI9bS5oYXNEYXRhKGEpJiZtLl9kYXRhKGEpO2lmKHImJihrPXIuZXZlbnRzKSl7Yj0oYnx8XCJcIikubWF0Y2goRSl8fFtcIlwiXSxqPWIubGVuZ3RoO3doaWxlKGotLSlpZihoPV8uZXhlYyhiW2pdKXx8W10sbz1xPWhbMV0scD0oaFsyXXx8XCJcIikuc3BsaXQoXCIuXCIpLnNvcnQoKSxvKXtsPW0uZXZlbnQuc3BlY2lhbFtvXXx8e30sbz0oZD9sLmRlbGVnYXRlVHlwZTpsLmJpbmRUeXBlKXx8byxuPWtbb118fFtdLGg9aFsyXSYmbmV3IFJlZ0V4cChcIihefFxcXFwuKVwiK3Auam9pbihcIlxcXFwuKD86LipcXFxcLnwpXCIpK1wiKFxcXFwufCQpXCIpLGk9Zj1uLmxlbmd0aDt3aGlsZShmLS0pZz1uW2ZdLCFlJiZxIT09Zy5vcmlnVHlwZXx8YyYmYy5ndWlkIT09Zy5ndWlkfHxoJiYhaC50ZXN0KGcubmFtZXNwYWNlKXx8ZCYmZCE9PWcuc2VsZWN0b3ImJihcIioqXCIhPT1kfHwhZy5zZWxlY3Rvcil8fChuLnNwbGljZShmLDEpLGcuc2VsZWN0b3ImJm4uZGVsZWdhdGVDb3VudC0tLGwucmVtb3ZlJiZsLnJlbW92ZS5jYWxsKGEsZykpO2kmJiFuLmxlbmd0aCYmKGwudGVhcmRvd24mJmwudGVhcmRvd24uY2FsbChhLHAsci5oYW5kbGUpIT09ITF8fG0ucmVtb3ZlRXZlbnQoYSxvLHIuaGFuZGxlKSxkZWxldGUga1tvXSl9ZWxzZSBmb3IobyBpbiBrKW0uZXZlbnQucmVtb3ZlKGEsbytiW2pdLGMsZCwhMCk7bS5pc0VtcHR5T2JqZWN0KGspJiYoZGVsZXRlIHIuaGFuZGxlLG0uX3JlbW92ZURhdGEoYSxcImV2ZW50c1wiKSl9fSx0cmlnZ2VyOmZ1bmN0aW9uKGIsYyxkLGUpe3ZhciBmLGcsaCxpLGssbCxuLG89W2R8fHldLHA9ai5jYWxsKGIsXCJ0eXBlXCIpP2IudHlwZTpiLHE9ai5jYWxsKGIsXCJuYW1lc3BhY2VcIik/Yi5uYW1lc3BhY2Uuc3BsaXQoXCIuXCIpOltdO2lmKGg9bD1kPWR8fHksMyE9PWQubm9kZVR5cGUmJjghPT1kLm5vZGVUeXBlJiYhJC50ZXN0KHArbS5ldmVudC50cmlnZ2VyZWQpJiYocC5pbmRleE9mKFwiLlwiKT49MCYmKHE9cC5zcGxpdChcIi5cIikscD1xLnNoaWZ0KCkscS5zb3J0KCkpLGc9cC5pbmRleE9mKFwiOlwiKTwwJiZcIm9uXCIrcCxiPWJbbS5leHBhbmRvXT9iOm5ldyBtLkV2ZW50KHAsXCJvYmplY3RcIj09dHlwZW9mIGImJmIpLGIuaXNUcmlnZ2VyPWU/MjozLGIubmFtZXNwYWNlPXEuam9pbihcIi5cIiksYi5uYW1lc3BhY2VfcmU9Yi5uYW1lc3BhY2U/bmV3IFJlZ0V4cChcIihefFxcXFwuKVwiK3Euam9pbihcIlxcXFwuKD86LipcXFxcLnwpXCIpK1wiKFxcXFwufCQpXCIpOm51bGwsYi5yZXN1bHQ9dm9pZCAwLGIudGFyZ2V0fHwoYi50YXJnZXQ9ZCksYz1udWxsPT1jP1tiXTptLm1ha2VBcnJheShjLFtiXSksaz1tLmV2ZW50LnNwZWNpYWxbcF18fHt9LGV8fCFrLnRyaWdnZXJ8fGsudHJpZ2dlci5hcHBseShkLGMpIT09ITEpKXtpZighZSYmIWsubm9CdWJibGUmJiFtLmlzV2luZG93KGQpKXtmb3IoaT1rLmRlbGVnYXRlVHlwZXx8cCwkLnRlc3QoaStwKXx8KGg9aC5wYXJlbnROb2RlKTtoO2g9aC5wYXJlbnROb2RlKW8ucHVzaChoKSxsPWg7bD09PShkLm93bmVyRG9jdW1lbnR8fHkpJiZvLnB1c2gobC5kZWZhdWx0Vmlld3x8bC5wYXJlbnRXaW5kb3d8fGEpfW49MDt3aGlsZSgoaD1vW24rK10pJiYhYi5pc1Byb3BhZ2F0aW9uU3RvcHBlZCgpKWIudHlwZT1uPjE/aTprLmJpbmRUeXBlfHxwLGY9KG0uX2RhdGEoaCxcImV2ZW50c1wiKXx8e30pW2IudHlwZV0mJm0uX2RhdGEoaCxcImhhbmRsZVwiKSxmJiZmLmFwcGx5KGgsYyksZj1nJiZoW2ddLGYmJmYuYXBwbHkmJm0uYWNjZXB0RGF0YShoKSYmKGIucmVzdWx0PWYuYXBwbHkoaCxjKSxiLnJlc3VsdD09PSExJiZiLnByZXZlbnREZWZhdWx0KCkpO2lmKGIudHlwZT1wLCFlJiYhYi5pc0RlZmF1bHRQcmV2ZW50ZWQoKSYmKCFrLl9kZWZhdWx0fHxrLl9kZWZhdWx0LmFwcGx5KG8ucG9wKCksYyk9PT0hMSkmJm0uYWNjZXB0RGF0YShkKSYmZyYmZFtwXSYmIW0uaXNXaW5kb3coZCkpe2w9ZFtnXSxsJiYoZFtnXT1udWxsKSxtLmV2ZW50LnRyaWdnZXJlZD1wO3RyeXtkW3BdKCl9Y2F0Y2gocil7fW0uZXZlbnQudHJpZ2dlcmVkPXZvaWQgMCxsJiYoZFtnXT1sKX1yZXR1cm4gYi5yZXN1bHR9fSxkaXNwYXRjaDpmdW5jdGlvbihhKXthPW0uZXZlbnQuZml4KGEpO3ZhciBiLGMsZSxmLGcsaD1bXSxpPWQuY2FsbChhcmd1bWVudHMpLGo9KG0uX2RhdGEodGhpcyxcImV2ZW50c1wiKXx8e30pW2EudHlwZV18fFtdLGs9bS5ldmVudC5zcGVjaWFsW2EudHlwZV18fHt9O2lmKGlbMF09YSxhLmRlbGVnYXRlVGFyZ2V0PXRoaXMsIWsucHJlRGlzcGF0Y2h8fGsucHJlRGlzcGF0Y2guY2FsbCh0aGlzLGEpIT09ITEpe2g9bS5ldmVudC5oYW5kbGVycy5jYWxsKHRoaXMsYSxqKSxiPTA7d2hpbGUoKGY9aFtiKytdKSYmIWEuaXNQcm9wYWdhdGlvblN0b3BwZWQoKSl7YS5jdXJyZW50VGFyZ2V0PWYuZWxlbSxnPTA7d2hpbGUoKGU9Zi5oYW5kbGVyc1tnKytdKSYmIWEuaXNJbW1lZGlhdGVQcm9wYWdhdGlvblN0b3BwZWQoKSkoIWEubmFtZXNwYWNlX3JlfHxhLm5hbWVzcGFjZV9yZS50ZXN0KGUubmFtZXNwYWNlKSkmJihhLmhhbmRsZU9iaj1lLGEuZGF0YT1lLmRhdGEsYz0oKG0uZXZlbnQuc3BlY2lhbFtlLm9yaWdUeXBlXXx8e30pLmhhbmRsZXx8ZS5oYW5kbGVyKS5hcHBseShmLmVsZW0saSksdm9pZCAwIT09YyYmKGEucmVzdWx0PWMpPT09ITEmJihhLnByZXZlbnREZWZhdWx0KCksYS5zdG9wUHJvcGFnYXRpb24oKSkpfXJldHVybiBrLnBvc3REaXNwYXRjaCYmay5wb3N0RGlzcGF0Y2guY2FsbCh0aGlzLGEpLGEucmVzdWx0fX0saGFuZGxlcnM6ZnVuY3Rpb24oYSxiKXt2YXIgYyxkLGUsZixnPVtdLGg9Yi5kZWxlZ2F0ZUNvdW50LGk9YS50YXJnZXQ7aWYoaCYmaS5ub2RlVHlwZSYmKCFhLmJ1dHRvbnx8XCJjbGlja1wiIT09YS50eXBlKSlmb3IoO2khPXRoaXM7aT1pLnBhcmVudE5vZGV8fHRoaXMpaWYoMT09PWkubm9kZVR5cGUmJihpLmRpc2FibGVkIT09ITB8fFwiY2xpY2tcIiE9PWEudHlwZSkpe2ZvcihlPVtdLGY9MDtoPmY7ZisrKWQ9YltmXSxjPWQuc2VsZWN0b3IrXCIgXCIsdm9pZCAwPT09ZVtjXSYmKGVbY109ZC5uZWVkc0NvbnRleHQ/bShjLHRoaXMpLmluZGV4KGkpPj0wOm0uZmluZChjLHRoaXMsbnVsbCxbaV0pLmxlbmd0aCksZVtjXSYmZS5wdXNoKGQpO2UubGVuZ3RoJiZnLnB1c2goe2VsZW06aSxoYW5kbGVyczplfSl9cmV0dXJuIGg8Yi5sZW5ndGgmJmcucHVzaCh7ZWxlbTp0aGlzLGhhbmRsZXJzOmIuc2xpY2UoaCl9KSxnfSxmaXg6ZnVuY3Rpb24oYSl7aWYoYVttLmV4cGFuZG9dKXJldHVybiBhO3ZhciBiLGMsZCxlPWEudHlwZSxmPWEsZz10aGlzLmZpeEhvb2tzW2VdO2d8fCh0aGlzLmZpeEhvb2tzW2VdPWc9Wi50ZXN0KGUpP3RoaXMubW91c2VIb29rczpZLnRlc3QoZSk/dGhpcy5rZXlIb29rczp7fSksZD1nLnByb3BzP3RoaXMucHJvcHMuY29uY2F0KGcucHJvcHMpOnRoaXMucHJvcHMsYT1uZXcgbS5FdmVudChmKSxiPWQubGVuZ3RoO3doaWxlKGItLSljPWRbYl0sYVtjXT1mW2NdO3JldHVybiBhLnRhcmdldHx8KGEudGFyZ2V0PWYuc3JjRWxlbWVudHx8eSksMz09PWEudGFyZ2V0Lm5vZGVUeXBlJiYoYS50YXJnZXQ9YS50YXJnZXQucGFyZW50Tm9kZSksYS5tZXRhS2V5PSEhYS5tZXRhS2V5LGcuZmlsdGVyP2cuZmlsdGVyKGEsZik6YX0scHJvcHM6XCJhbHRLZXkgYnViYmxlcyBjYW5jZWxhYmxlIGN0cmxLZXkgY3VycmVudFRhcmdldCBldmVudFBoYXNlIG1ldGFLZXkgcmVsYXRlZFRhcmdldCBzaGlmdEtleSB0YXJnZXQgdGltZVN0YW1wIHZpZXcgd2hpY2hcIi5zcGxpdChcIiBcIiksZml4SG9va3M6e30sa2V5SG9va3M6e3Byb3BzOlwiY2hhciBjaGFyQ29kZSBrZXkga2V5Q29kZVwiLnNwbGl0KFwiIFwiKSxmaWx0ZXI6ZnVuY3Rpb24oYSxiKXtyZXR1cm4gbnVsbD09YS53aGljaCYmKGEud2hpY2g9bnVsbCE9Yi5jaGFyQ29kZT9iLmNoYXJDb2RlOmIua2V5Q29kZSksYX19LG1vdXNlSG9va3M6e3Byb3BzOlwiYnV0dG9uIGJ1dHRvbnMgY2xpZW50WCBjbGllbnRZIGZyb21FbGVtZW50IG9mZnNldFggb2Zmc2V0WSBwYWdlWCBwYWdlWSBzY3JlZW5YIHNjcmVlblkgdG9FbGVtZW50XCIuc3BsaXQoXCIgXCIpLGZpbHRlcjpmdW5jdGlvbihhLGIpe3ZhciBjLGQsZSxmPWIuYnV0dG9uLGc9Yi5mcm9tRWxlbWVudDtyZXR1cm4gbnVsbD09YS5wYWdlWCYmbnVsbCE9Yi5jbGllbnRYJiYoZD1hLnRhcmdldC5vd25lckRvY3VtZW50fHx5LGU9ZC5kb2N1bWVudEVsZW1lbnQsYz1kLmJvZHksYS5wYWdlWD1iLmNsaWVudFgrKGUmJmUuc2Nyb2xsTGVmdHx8YyYmYy5zY3JvbGxMZWZ0fHwwKS0oZSYmZS5jbGllbnRMZWZ0fHxjJiZjLmNsaWVudExlZnR8fDApLGEucGFnZVk9Yi5jbGllbnRZKyhlJiZlLnNjcm9sbFRvcHx8YyYmYy5zY3JvbGxUb3B8fDApLShlJiZlLmNsaWVudFRvcHx8YyYmYy5jbGllbnRUb3B8fDApKSwhYS5yZWxhdGVkVGFyZ2V0JiZnJiYoYS5yZWxhdGVkVGFyZ2V0PWc9PT1hLnRhcmdldD9iLnRvRWxlbWVudDpnKSxhLndoaWNofHx2b2lkIDA9PT1mfHwoYS53aGljaD0xJmY/MToyJmY/Mzo0JmY/MjowKSxhfX0sc3BlY2lhbDp7bG9hZDp7bm9CdWJibGU6ITB9LGZvY3VzOnt0cmlnZ2VyOmZ1bmN0aW9uKCl7aWYodGhpcyE9PWNhKCkmJnRoaXMuZm9jdXMpdHJ5e3JldHVybiB0aGlzLmZvY3VzKCksITF9Y2F0Y2goYSl7fX0sZGVsZWdhdGVUeXBlOlwiZm9jdXNpblwifSxibHVyOnt0cmlnZ2VyOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXM9PT1jYSgpJiZ0aGlzLmJsdXI/KHRoaXMuYmx1cigpLCExKTp2b2lkIDB9LGRlbGVnYXRlVHlwZTpcImZvY3Vzb3V0XCJ9LGNsaWNrOnt0cmlnZ2VyOmZ1bmN0aW9uKCl7cmV0dXJuIG0ubm9kZU5hbWUodGhpcyxcImlucHV0XCIpJiZcImNoZWNrYm94XCI9PT10aGlzLnR5cGUmJnRoaXMuY2xpY2s/KHRoaXMuY2xpY2soKSwhMSk6dm9pZCAwfSxfZGVmYXVsdDpmdW5jdGlvbihhKXtyZXR1cm4gbS5ub2RlTmFtZShhLnRhcmdldCxcImFcIil9fSxiZWZvcmV1bmxvYWQ6e3Bvc3REaXNwYXRjaDpmdW5jdGlvbihhKXt2b2lkIDAhPT1hLnJlc3VsdCYmYS5vcmlnaW5hbEV2ZW50JiYoYS5vcmlnaW5hbEV2ZW50LnJldHVyblZhbHVlPWEucmVzdWx0KX19fSxzaW11bGF0ZTpmdW5jdGlvbihhLGIsYyxkKXt2YXIgZT1tLmV4dGVuZChuZXcgbS5FdmVudCxjLHt0eXBlOmEsaXNTaW11bGF0ZWQ6ITAsb3JpZ2luYWxFdmVudDp7fX0pO2Q/bS5ldmVudC50cmlnZ2VyKGUsbnVsbCxiKTptLmV2ZW50LmRpc3BhdGNoLmNhbGwoYixlKSxlLmlzRGVmYXVsdFByZXZlbnRlZCgpJiZjLnByZXZlbnREZWZhdWx0KCl9fSxtLnJlbW92ZUV2ZW50PXkucmVtb3ZlRXZlbnRMaXN0ZW5lcj9mdW5jdGlvbihhLGIsYyl7YS5yZW1vdmVFdmVudExpc3RlbmVyJiZhLnJlbW92ZUV2ZW50TGlzdGVuZXIoYixjLCExKX06ZnVuY3Rpb24oYSxiLGMpe3ZhciBkPVwib25cIitiO2EuZGV0YWNoRXZlbnQmJih0eXBlb2YgYVtkXT09PUsmJihhW2RdPW51bGwpLGEuZGV0YWNoRXZlbnQoZCxjKSl9LG0uRXZlbnQ9ZnVuY3Rpb24oYSxiKXtyZXR1cm4gdGhpcyBpbnN0YW5jZW9mIG0uRXZlbnQ/KGEmJmEudHlwZT8odGhpcy5vcmlnaW5hbEV2ZW50PWEsdGhpcy50eXBlPWEudHlwZSx0aGlzLmlzRGVmYXVsdFByZXZlbnRlZD1hLmRlZmF1bHRQcmV2ZW50ZWR8fHZvaWQgMD09PWEuZGVmYXVsdFByZXZlbnRlZCYmYS5yZXR1cm5WYWx1ZT09PSExP2FhOmJhKTp0aGlzLnR5cGU9YSxiJiZtLmV4dGVuZCh0aGlzLGIpLHRoaXMudGltZVN0YW1wPWEmJmEudGltZVN0YW1wfHxtLm5vdygpLHZvaWQodGhpc1ttLmV4cGFuZG9dPSEwKSk6bmV3IG0uRXZlbnQoYSxiKX0sbS5FdmVudC5wcm90b3R5cGU9e2lzRGVmYXVsdFByZXZlbnRlZDpiYSxpc1Byb3BhZ2F0aW9uU3RvcHBlZDpiYSxpc0ltbWVkaWF0ZVByb3BhZ2F0aW9uU3RvcHBlZDpiYSxwcmV2ZW50RGVmYXVsdDpmdW5jdGlvbigpe3ZhciBhPXRoaXMub3JpZ2luYWxFdmVudDt0aGlzLmlzRGVmYXVsdFByZXZlbnRlZD1hYSxhJiYoYS5wcmV2ZW50RGVmYXVsdD9hLnByZXZlbnREZWZhdWx0KCk6YS5yZXR1cm5WYWx1ZT0hMSl9LHN0b3BQcm9wYWdhdGlvbjpmdW5jdGlvbigpe3ZhciBhPXRoaXMub3JpZ2luYWxFdmVudDt0aGlzLmlzUHJvcGFnYXRpb25TdG9wcGVkPWFhLGEmJihhLnN0b3BQcm9wYWdhdGlvbiYmYS5zdG9wUHJvcGFnYXRpb24oKSxhLmNhbmNlbEJ1YmJsZT0hMCl9LHN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbjpmdW5jdGlvbigpe3ZhciBhPXRoaXMub3JpZ2luYWxFdmVudDt0aGlzLmlzSW1tZWRpYXRlUHJvcGFnYXRpb25TdG9wcGVkPWFhLGEmJmEuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uJiZhLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpLHRoaXMuc3RvcFByb3BhZ2F0aW9uKCl9fSxtLmVhY2goe21vdXNlZW50ZXI6XCJtb3VzZW92ZXJcIixtb3VzZWxlYXZlOlwibW91c2VvdXRcIixwb2ludGVyZW50ZXI6XCJwb2ludGVyb3ZlclwiLHBvaW50ZXJsZWF2ZTpcInBvaW50ZXJvdXRcIn0sZnVuY3Rpb24oYSxiKXttLmV2ZW50LnNwZWNpYWxbYV09e2RlbGVnYXRlVHlwZTpiLGJpbmRUeXBlOmIsaGFuZGxlOmZ1bmN0aW9uKGEpe3ZhciBjLGQ9dGhpcyxlPWEucmVsYXRlZFRhcmdldCxmPWEuaGFuZGxlT2JqO3JldHVybighZXx8ZSE9PWQmJiFtLmNvbnRhaW5zKGQsZSkpJiYoYS50eXBlPWYub3JpZ1R5cGUsYz1mLmhhbmRsZXIuYXBwbHkodGhpcyxhcmd1bWVudHMpLGEudHlwZT1iKSxjfX19KSxrLnN1Ym1pdEJ1YmJsZXN8fChtLmV2ZW50LnNwZWNpYWwuc3VibWl0PXtzZXR1cDpmdW5jdGlvbigpe3JldHVybiBtLm5vZGVOYW1lKHRoaXMsXCJmb3JtXCIpPyExOnZvaWQgbS5ldmVudC5hZGQodGhpcyxcImNsaWNrLl9zdWJtaXQga2V5cHJlc3MuX3N1Ym1pdFwiLGZ1bmN0aW9uKGEpe3ZhciBiPWEudGFyZ2V0LGM9bS5ub2RlTmFtZShiLFwiaW5wdXRcIil8fG0ubm9kZU5hbWUoYixcImJ1dHRvblwiKT9iLmZvcm06dm9pZCAwO2MmJiFtLl9kYXRhKGMsXCJzdWJtaXRCdWJibGVzXCIpJiYobS5ldmVudC5hZGQoYyxcInN1Ym1pdC5fc3VibWl0XCIsZnVuY3Rpb24oYSl7YS5fc3VibWl0X2J1YmJsZT0hMH0pLG0uX2RhdGEoYyxcInN1Ym1pdEJ1YmJsZXNcIiwhMCkpfSl9LHBvc3REaXNwYXRjaDpmdW5jdGlvbihhKXthLl9zdWJtaXRfYnViYmxlJiYoZGVsZXRlIGEuX3N1Ym1pdF9idWJibGUsdGhpcy5wYXJlbnROb2RlJiYhYS5pc1RyaWdnZXImJm0uZXZlbnQuc2ltdWxhdGUoXCJzdWJtaXRcIix0aGlzLnBhcmVudE5vZGUsYSwhMCkpfSx0ZWFyZG93bjpmdW5jdGlvbigpe3JldHVybiBtLm5vZGVOYW1lKHRoaXMsXCJmb3JtXCIpPyExOnZvaWQgbS5ldmVudC5yZW1vdmUodGhpcyxcIi5fc3VibWl0XCIpfX0pLGsuY2hhbmdlQnViYmxlc3x8KG0uZXZlbnQuc3BlY2lhbC5jaGFuZ2U9e3NldHVwOmZ1bmN0aW9uKCl7cmV0dXJuIFgudGVzdCh0aGlzLm5vZGVOYW1lKT8oKFwiY2hlY2tib3hcIj09PXRoaXMudHlwZXx8XCJyYWRpb1wiPT09dGhpcy50eXBlKSYmKG0uZXZlbnQuYWRkKHRoaXMsXCJwcm9wZXJ0eWNoYW5nZS5fY2hhbmdlXCIsZnVuY3Rpb24oYSl7XCJjaGVja2VkXCI9PT1hLm9yaWdpbmFsRXZlbnQucHJvcGVydHlOYW1lJiYodGhpcy5fanVzdF9jaGFuZ2VkPSEwKX0pLG0uZXZlbnQuYWRkKHRoaXMsXCJjbGljay5fY2hhbmdlXCIsZnVuY3Rpb24oYSl7dGhpcy5fanVzdF9jaGFuZ2VkJiYhYS5pc1RyaWdnZXImJih0aGlzLl9qdXN0X2NoYW5nZWQ9ITEpLG0uZXZlbnQuc2ltdWxhdGUoXCJjaGFuZ2VcIix0aGlzLGEsITApfSkpLCExKTp2b2lkIG0uZXZlbnQuYWRkKHRoaXMsXCJiZWZvcmVhY3RpdmF0ZS5fY2hhbmdlXCIsZnVuY3Rpb24oYSl7dmFyIGI9YS50YXJnZXQ7WC50ZXN0KGIubm9kZU5hbWUpJiYhbS5fZGF0YShiLFwiY2hhbmdlQnViYmxlc1wiKSYmKG0uZXZlbnQuYWRkKGIsXCJjaGFuZ2UuX2NoYW5nZVwiLGZ1bmN0aW9uKGEpeyF0aGlzLnBhcmVudE5vZGV8fGEuaXNTaW11bGF0ZWR8fGEuaXNUcmlnZ2VyfHxtLmV2ZW50LnNpbXVsYXRlKFwiY2hhbmdlXCIsdGhpcy5wYXJlbnROb2RlLGEsITApfSksbS5fZGF0YShiLFwiY2hhbmdlQnViYmxlc1wiLCEwKSl9KX0saGFuZGxlOmZ1bmN0aW9uKGEpe3ZhciBiPWEudGFyZ2V0O3JldHVybiB0aGlzIT09Ynx8YS5pc1NpbXVsYXRlZHx8YS5pc1RyaWdnZXJ8fFwicmFkaW9cIiE9PWIudHlwZSYmXCJjaGVja2JveFwiIT09Yi50eXBlP2EuaGFuZGxlT2JqLmhhbmRsZXIuYXBwbHkodGhpcyxhcmd1bWVudHMpOnZvaWQgMH0sdGVhcmRvd246ZnVuY3Rpb24oKXtyZXR1cm4gbS5ldmVudC5yZW1vdmUodGhpcyxcIi5fY2hhbmdlXCIpLCFYLnRlc3QodGhpcy5ub2RlTmFtZSl9fSksay5mb2N1c2luQnViYmxlc3x8bS5lYWNoKHtmb2N1czpcImZvY3VzaW5cIixibHVyOlwiZm9jdXNvdXRcIn0sZnVuY3Rpb24oYSxiKXt2YXIgYz1mdW5jdGlvbihhKXttLmV2ZW50LnNpbXVsYXRlKGIsYS50YXJnZXQsbS5ldmVudC5maXgoYSksITApfTttLmV2ZW50LnNwZWNpYWxbYl09e3NldHVwOmZ1bmN0aW9uKCl7dmFyIGQ9dGhpcy5vd25lckRvY3VtZW50fHx0aGlzLGU9bS5fZGF0YShkLGIpO2V8fGQuYWRkRXZlbnRMaXN0ZW5lcihhLGMsITApLG0uX2RhdGEoZCxiLChlfHwwKSsxKX0sdGVhcmRvd246ZnVuY3Rpb24oKXt2YXIgZD10aGlzLm93bmVyRG9jdW1lbnR8fHRoaXMsZT1tLl9kYXRhKGQsYiktMTtlP20uX2RhdGEoZCxiLGUpOihkLnJlbW92ZUV2ZW50TGlzdGVuZXIoYSxjLCEwKSxtLl9yZW1vdmVEYXRhKGQsYikpfX19KSxtLmZuLmV4dGVuZCh7b246ZnVuY3Rpb24oYSxiLGMsZCxlKXt2YXIgZixnO2lmKFwib2JqZWN0XCI9PXR5cGVvZiBhKXtcInN0cmluZ1wiIT10eXBlb2YgYiYmKGM9Y3x8YixiPXZvaWQgMCk7Zm9yKGYgaW4gYSl0aGlzLm9uKGYsYixjLGFbZl0sZSk7cmV0dXJuIHRoaXN9aWYobnVsbD09YyYmbnVsbD09ZD8oZD1iLGM9Yj12b2lkIDApOm51bGw9PWQmJihcInN0cmluZ1wiPT10eXBlb2YgYj8oZD1jLGM9dm9pZCAwKTooZD1jLGM9YixiPXZvaWQgMCkpLGQ9PT0hMSlkPWJhO2Vsc2UgaWYoIWQpcmV0dXJuIHRoaXM7cmV0dXJuIDE9PT1lJiYoZz1kLGQ9ZnVuY3Rpb24oYSl7cmV0dXJuIG0oKS5vZmYoYSksZy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9LGQuZ3VpZD1nLmd1aWR8fChnLmd1aWQ9bS5ndWlkKyspKSx0aGlzLmVhY2goZnVuY3Rpb24oKXttLmV2ZW50LmFkZCh0aGlzLGEsZCxjLGIpfSl9LG9uZTpmdW5jdGlvbihhLGIsYyxkKXtyZXR1cm4gdGhpcy5vbihhLGIsYyxkLDEpfSxvZmY6ZnVuY3Rpb24oYSxiLGMpe3ZhciBkLGU7aWYoYSYmYS5wcmV2ZW50RGVmYXVsdCYmYS5oYW5kbGVPYmopcmV0dXJuIGQ9YS5oYW5kbGVPYmosbShhLmRlbGVnYXRlVGFyZ2V0KS5vZmYoZC5uYW1lc3BhY2U/ZC5vcmlnVHlwZStcIi5cIitkLm5hbWVzcGFjZTpkLm9yaWdUeXBlLGQuc2VsZWN0b3IsZC5oYW5kbGVyKSx0aGlzO2lmKFwib2JqZWN0XCI9PXR5cGVvZiBhKXtmb3IoZSBpbiBhKXRoaXMub2ZmKGUsYixhW2VdKTtyZXR1cm4gdGhpc31yZXR1cm4oYj09PSExfHxcImZ1bmN0aW9uXCI9PXR5cGVvZiBiKSYmKGM9YixiPXZvaWQgMCksYz09PSExJiYoYz1iYSksdGhpcy5lYWNoKGZ1bmN0aW9uKCl7bS5ldmVudC5yZW1vdmUodGhpcyxhLGMsYil9KX0sdHJpZ2dlcjpmdW5jdGlvbihhLGIpe3JldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKXttLmV2ZW50LnRyaWdnZXIoYSxiLHRoaXMpfSl9LHRyaWdnZXJIYW5kbGVyOmZ1bmN0aW9uKGEsYil7dmFyIGM9dGhpc1swXTtyZXR1cm4gYz9tLmV2ZW50LnRyaWdnZXIoYSxiLGMsITApOnZvaWQgMH19KTtmdW5jdGlvbiBkYShhKXt2YXIgYj1lYS5zcGxpdChcInxcIiksYz1hLmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtpZihjLmNyZWF0ZUVsZW1lbnQpd2hpbGUoYi5sZW5ndGgpYy5jcmVhdGVFbGVtZW50KGIucG9wKCkpO3JldHVybiBjfXZhciBlYT1cImFiYnJ8YXJ0aWNsZXxhc2lkZXxhdWRpb3xiZGl8Y2FudmFzfGRhdGF8ZGF0YWxpc3R8ZGV0YWlsc3xmaWdjYXB0aW9ufGZpZ3VyZXxmb290ZXJ8aGVhZGVyfGhncm91cHxtYXJrfG1ldGVyfG5hdnxvdXRwdXR8cHJvZ3Jlc3N8c2VjdGlvbnxzdW1tYXJ5fHRpbWV8dmlkZW9cIixmYT0vIGpRdWVyeVxcZCs9XCIoPzpudWxsfFxcZCspXCIvZyxnYT1uZXcgUmVnRXhwKFwiPCg/OlwiK2VhK1wiKVtcXFxccy8+XVwiLFwiaVwiKSxoYT0vXlxccysvLGlhPS88KD8hYXJlYXxicnxjb2x8ZW1iZWR8aHJ8aW1nfGlucHV0fGxpbmt8bWV0YXxwYXJhbSkoKFtcXHc6XSspW14+XSopXFwvPi9naSxqYT0vPChbXFx3Ol0rKS8sa2E9Lzx0Ym9keS9pLGxhPS88fCYjP1xcdys7LyxtYT0vPCg/OnNjcmlwdHxzdHlsZXxsaW5rKS9pLG5hPS9jaGVja2VkXFxzKig/OltePV18PVxccyouY2hlY2tlZC4pL2ksb2E9L14kfFxcLyg/OmphdmF8ZWNtYSlzY3JpcHQvaSxwYT0vXnRydWVcXC8oLiopLyxxYT0vXlxccyo8ISg/OlxcW0NEQVRBXFxbfC0tKXwoPzpcXF1cXF18LS0pPlxccyokL2cscmE9e29wdGlvbjpbMSxcIjxzZWxlY3QgbXVsdGlwbGU9J211bHRpcGxlJz5cIixcIjwvc2VsZWN0PlwiXSxsZWdlbmQ6WzEsXCI8ZmllbGRzZXQ+XCIsXCI8L2ZpZWxkc2V0PlwiXSxhcmVhOlsxLFwiPG1hcD5cIixcIjwvbWFwPlwiXSxwYXJhbTpbMSxcIjxvYmplY3Q+XCIsXCI8L29iamVjdD5cIl0sdGhlYWQ6WzEsXCI8dGFibGU+XCIsXCI8L3RhYmxlPlwiXSx0cjpbMixcIjx0YWJsZT48dGJvZHk+XCIsXCI8L3Rib2R5PjwvdGFibGU+XCJdLGNvbDpbMixcIjx0YWJsZT48dGJvZHk+PC90Ym9keT48Y29sZ3JvdXA+XCIsXCI8L2NvbGdyb3VwPjwvdGFibGU+XCJdLHRkOlszLFwiPHRhYmxlPjx0Ym9keT48dHI+XCIsXCI8L3RyPjwvdGJvZHk+PC90YWJsZT5cIl0sX2RlZmF1bHQ6ay5odG1sU2VyaWFsaXplP1swLFwiXCIsXCJcIl06WzEsXCJYPGRpdj5cIixcIjwvZGl2PlwiXX0sc2E9ZGEoeSksdGE9c2EuYXBwZW5kQ2hpbGQoeS5jcmVhdGVFbGVtZW50KFwiZGl2XCIpKTtyYS5vcHRncm91cD1yYS5vcHRpb24scmEudGJvZHk9cmEudGZvb3Q9cmEuY29sZ3JvdXA9cmEuY2FwdGlvbj1yYS50aGVhZCxyYS50aD1yYS50ZDtmdW5jdGlvbiB1YShhLGIpe3ZhciBjLGQsZT0wLGY9dHlwZW9mIGEuZ2V0RWxlbWVudHNCeVRhZ05hbWUhPT1LP2EuZ2V0RWxlbWVudHNCeVRhZ05hbWUoYnx8XCIqXCIpOnR5cGVvZiBhLnF1ZXJ5U2VsZWN0b3JBbGwhPT1LP2EucXVlcnlTZWxlY3RvckFsbChifHxcIipcIik6dm9pZCAwO2lmKCFmKWZvcihmPVtdLGM9YS5jaGlsZE5vZGVzfHxhO251bGwhPShkPWNbZV0pO2UrKykhYnx8bS5ub2RlTmFtZShkLGIpP2YucHVzaChkKTptLm1lcmdlKGYsdWEoZCxiKSk7cmV0dXJuIHZvaWQgMD09PWJ8fGImJm0ubm9kZU5hbWUoYSxiKT9tLm1lcmdlKFthXSxmKTpmfWZ1bmN0aW9uIHZhKGEpe1cudGVzdChhLnR5cGUpJiYoYS5kZWZhdWx0Q2hlY2tlZD1hLmNoZWNrZWQpfWZ1bmN0aW9uIHdhKGEsYil7cmV0dXJuIG0ubm9kZU5hbWUoYSxcInRhYmxlXCIpJiZtLm5vZGVOYW1lKDExIT09Yi5ub2RlVHlwZT9iOmIuZmlyc3RDaGlsZCxcInRyXCIpP2EuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJ0Ym9keVwiKVswXXx8YS5hcHBlbmRDaGlsZChhLm93bmVyRG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInRib2R5XCIpKTphfWZ1bmN0aW9uIHhhKGEpe3JldHVybiBhLnR5cGU9KG51bGwhPT1tLmZpbmQuYXR0cihhLFwidHlwZVwiKSkrXCIvXCIrYS50eXBlLGF9ZnVuY3Rpb24geWEoYSl7dmFyIGI9cGEuZXhlYyhhLnR5cGUpO3JldHVybiBiP2EudHlwZT1iWzFdOmEucmVtb3ZlQXR0cmlidXRlKFwidHlwZVwiKSxhfWZ1bmN0aW9uIHphKGEsYil7Zm9yKHZhciBjLGQ9MDtudWxsIT0oYz1hW2RdKTtkKyspbS5fZGF0YShjLFwiZ2xvYmFsRXZhbFwiLCFifHxtLl9kYXRhKGJbZF0sXCJnbG9iYWxFdmFsXCIpKX1mdW5jdGlvbiBBYShhLGIpe2lmKDE9PT1iLm5vZGVUeXBlJiZtLmhhc0RhdGEoYSkpe3ZhciBjLGQsZSxmPW0uX2RhdGEoYSksZz1tLl9kYXRhKGIsZiksaD1mLmV2ZW50cztpZihoKXtkZWxldGUgZy5oYW5kbGUsZy5ldmVudHM9e307Zm9yKGMgaW4gaClmb3IoZD0wLGU9aFtjXS5sZW5ndGg7ZT5kO2QrKyltLmV2ZW50LmFkZChiLGMsaFtjXVtkXSl9Zy5kYXRhJiYoZy5kYXRhPW0uZXh0ZW5kKHt9LGcuZGF0YSkpfX1mdW5jdGlvbiBCYShhLGIpe3ZhciBjLGQsZTtpZigxPT09Yi5ub2RlVHlwZSl7aWYoYz1iLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCksIWsubm9DbG9uZUV2ZW50JiZiW20uZXhwYW5kb10pe2U9bS5fZGF0YShiKTtmb3IoZCBpbiBlLmV2ZW50cyltLnJlbW92ZUV2ZW50KGIsZCxlLmhhbmRsZSk7Yi5yZW1vdmVBdHRyaWJ1dGUobS5leHBhbmRvKX1cInNjcmlwdFwiPT09YyYmYi50ZXh0IT09YS50ZXh0Pyh4YShiKS50ZXh0PWEudGV4dCx5YShiKSk6XCJvYmplY3RcIj09PWM/KGIucGFyZW50Tm9kZSYmKGIub3V0ZXJIVE1MPWEub3V0ZXJIVE1MKSxrLmh0bWw1Q2xvbmUmJmEuaW5uZXJIVE1MJiYhbS50cmltKGIuaW5uZXJIVE1MKSYmKGIuaW5uZXJIVE1MPWEuaW5uZXJIVE1MKSk6XCJpbnB1dFwiPT09YyYmVy50ZXN0KGEudHlwZSk/KGIuZGVmYXVsdENoZWNrZWQ9Yi5jaGVja2VkPWEuY2hlY2tlZCxiLnZhbHVlIT09YS52YWx1ZSYmKGIudmFsdWU9YS52YWx1ZSkpOlwib3B0aW9uXCI9PT1jP2IuZGVmYXVsdFNlbGVjdGVkPWIuc2VsZWN0ZWQ9YS5kZWZhdWx0U2VsZWN0ZWQ6KFwiaW5wdXRcIj09PWN8fFwidGV4dGFyZWFcIj09PWMpJiYoYi5kZWZhdWx0VmFsdWU9YS5kZWZhdWx0VmFsdWUpfX1tLmV4dGVuZCh7Y2xvbmU6ZnVuY3Rpb24oYSxiLGMpe3ZhciBkLGUsZixnLGgsaT1tLmNvbnRhaW5zKGEub3duZXJEb2N1bWVudCxhKTtpZihrLmh0bWw1Q2xvbmV8fG0uaXNYTUxEb2MoYSl8fCFnYS50ZXN0KFwiPFwiK2Eubm9kZU5hbWUrXCI+XCIpP2Y9YS5jbG9uZU5vZGUoITApOih0YS5pbm5lckhUTUw9YS5vdXRlckhUTUwsdGEucmVtb3ZlQ2hpbGQoZj10YS5maXJzdENoaWxkKSksIShrLm5vQ2xvbmVFdmVudCYmay5ub0Nsb25lQ2hlY2tlZHx8MSE9PWEubm9kZVR5cGUmJjExIT09YS5ub2RlVHlwZXx8bS5pc1hNTERvYyhhKSkpZm9yKGQ9dWEoZiksaD11YShhKSxnPTA7bnVsbCE9KGU9aFtnXSk7KytnKWRbZ10mJkJhKGUsZFtnXSk7aWYoYilpZihjKWZvcihoPWh8fHVhKGEpLGQ9ZHx8dWEoZiksZz0wO251bGwhPShlPWhbZ10pO2crKylBYShlLGRbZ10pO2Vsc2UgQWEoYSxmKTtyZXR1cm4gZD11YShmLFwic2NyaXB0XCIpLGQubGVuZ3RoPjAmJnphKGQsIWkmJnVhKGEsXCJzY3JpcHRcIikpLGQ9aD1lPW51bGwsZn0sYnVpbGRGcmFnbWVudDpmdW5jdGlvbihhLGIsYyxkKXtmb3IodmFyIGUsZixnLGgsaSxqLGwsbj1hLmxlbmd0aCxvPWRhKGIpLHA9W10scT0wO24+cTtxKyspaWYoZj1hW3FdLGZ8fDA9PT1mKWlmKFwib2JqZWN0XCI9PT1tLnR5cGUoZikpbS5tZXJnZShwLGYubm9kZVR5cGU/W2ZdOmYpO2Vsc2UgaWYobGEudGVzdChmKSl7aD1ofHxvLmFwcGVuZENoaWxkKGIuY3JlYXRlRWxlbWVudChcImRpdlwiKSksaT0oamEuZXhlYyhmKXx8W1wiXCIsXCJcIl0pWzFdLnRvTG93ZXJDYXNlKCksbD1yYVtpXXx8cmEuX2RlZmF1bHQsaC5pbm5lckhUTUw9bFsxXStmLnJlcGxhY2UoaWEsXCI8JDE+PC8kMj5cIikrbFsyXSxlPWxbMF07d2hpbGUoZS0tKWg9aC5sYXN0Q2hpbGQ7aWYoIWsubGVhZGluZ1doaXRlc3BhY2UmJmhhLnRlc3QoZikmJnAucHVzaChiLmNyZWF0ZVRleHROb2RlKGhhLmV4ZWMoZilbMF0pKSwhay50Ym9keSl7Zj1cInRhYmxlXCIhPT1pfHxrYS50ZXN0KGYpP1wiPHRhYmxlPlwiIT09bFsxXXx8a2EudGVzdChmKT8wOmg6aC5maXJzdENoaWxkLGU9ZiYmZi5jaGlsZE5vZGVzLmxlbmd0aDt3aGlsZShlLS0pbS5ub2RlTmFtZShqPWYuY2hpbGROb2Rlc1tlXSxcInRib2R5XCIpJiYhai5jaGlsZE5vZGVzLmxlbmd0aCYmZi5yZW1vdmVDaGlsZChqKX1tLm1lcmdlKHAsaC5jaGlsZE5vZGVzKSxoLnRleHRDb250ZW50PVwiXCI7d2hpbGUoaC5maXJzdENoaWxkKWgucmVtb3ZlQ2hpbGQoaC5maXJzdENoaWxkKTtoPW8ubGFzdENoaWxkfWVsc2UgcC5wdXNoKGIuY3JlYXRlVGV4dE5vZGUoZikpO2gmJm8ucmVtb3ZlQ2hpbGQoaCksay5hcHBlbmRDaGVja2VkfHxtLmdyZXAodWEocCxcImlucHV0XCIpLHZhKSxxPTA7d2hpbGUoZj1wW3ErK10paWYoKCFkfHwtMT09PW0uaW5BcnJheShmLGQpKSYmKGc9bS5jb250YWlucyhmLm93bmVyRG9jdW1lbnQsZiksaD11YShvLmFwcGVuZENoaWxkKGYpLFwic2NyaXB0XCIpLGcmJnphKGgpLGMpKXtlPTA7d2hpbGUoZj1oW2UrK10pb2EudGVzdChmLnR5cGV8fFwiXCIpJiZjLnB1c2goZil9cmV0dXJuIGg9bnVsbCxvfSxjbGVhbkRhdGE6ZnVuY3Rpb24oYSxiKXtmb3IodmFyIGQsZSxmLGcsaD0wLGk9bS5leHBhbmRvLGo9bS5jYWNoZSxsPWsuZGVsZXRlRXhwYW5kbyxuPW0uZXZlbnQuc3BlY2lhbDtudWxsIT0oZD1hW2hdKTtoKyspaWYoKGJ8fG0uYWNjZXB0RGF0YShkKSkmJihmPWRbaV0sZz1mJiZqW2ZdKSl7aWYoZy5ldmVudHMpZm9yKGUgaW4gZy5ldmVudHMpbltlXT9tLmV2ZW50LnJlbW92ZShkLGUpOm0ucmVtb3ZlRXZlbnQoZCxlLGcuaGFuZGxlKTtqW2ZdJiYoZGVsZXRlIGpbZl0sbD9kZWxldGUgZFtpXTp0eXBlb2YgZC5yZW1vdmVBdHRyaWJ1dGUhPT1LP2QucmVtb3ZlQXR0cmlidXRlKGkpOmRbaV09bnVsbCxjLnB1c2goZikpfX19KSxtLmZuLmV4dGVuZCh7dGV4dDpmdW5jdGlvbihhKXtyZXR1cm4gVih0aGlzLGZ1bmN0aW9uKGEpe3JldHVybiB2b2lkIDA9PT1hP20udGV4dCh0aGlzKTp0aGlzLmVtcHR5KCkuYXBwZW5kKCh0aGlzWzBdJiZ0aGlzWzBdLm93bmVyRG9jdW1lbnR8fHkpLmNyZWF0ZVRleHROb2RlKGEpKX0sbnVsbCxhLGFyZ3VtZW50cy5sZW5ndGgpfSxhcHBlbmQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5kb21NYW5pcChhcmd1bWVudHMsZnVuY3Rpb24oYSl7aWYoMT09PXRoaXMubm9kZVR5cGV8fDExPT09dGhpcy5ub2RlVHlwZXx8OT09PXRoaXMubm9kZVR5cGUpe3ZhciBiPXdhKHRoaXMsYSk7Yi5hcHBlbmRDaGlsZChhKX19KX0scHJlcGVuZDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmRvbU1hbmlwKGFyZ3VtZW50cyxmdW5jdGlvbihhKXtpZigxPT09dGhpcy5ub2RlVHlwZXx8MTE9PT10aGlzLm5vZGVUeXBlfHw5PT09dGhpcy5ub2RlVHlwZSl7dmFyIGI9d2EodGhpcyxhKTtiLmluc2VydEJlZm9yZShhLGIuZmlyc3RDaGlsZCl9fSl9LGJlZm9yZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLmRvbU1hbmlwKGFyZ3VtZW50cyxmdW5jdGlvbihhKXt0aGlzLnBhcmVudE5vZGUmJnRoaXMucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoYSx0aGlzKX0pfSxhZnRlcjpmdW5jdGlvbigpe3JldHVybiB0aGlzLmRvbU1hbmlwKGFyZ3VtZW50cyxmdW5jdGlvbihhKXt0aGlzLnBhcmVudE5vZGUmJnRoaXMucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoYSx0aGlzLm5leHRTaWJsaW5nKX0pfSxyZW1vdmU6ZnVuY3Rpb24oYSxiKXtmb3IodmFyIGMsZD1hP20uZmlsdGVyKGEsdGhpcyk6dGhpcyxlPTA7bnVsbCE9KGM9ZFtlXSk7ZSsrKWJ8fDEhPT1jLm5vZGVUeXBlfHxtLmNsZWFuRGF0YSh1YShjKSksYy5wYXJlbnROb2RlJiYoYiYmbS5jb250YWlucyhjLm93bmVyRG9jdW1lbnQsYykmJnphKHVhKGMsXCJzY3JpcHRcIikpLGMucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChjKSk7cmV0dXJuIHRoaXN9LGVtcHR5OmZ1bmN0aW9uKCl7Zm9yKHZhciBhLGI9MDtudWxsIT0oYT10aGlzW2JdKTtiKyspezE9PT1hLm5vZGVUeXBlJiZtLmNsZWFuRGF0YSh1YShhLCExKSk7d2hpbGUoYS5maXJzdENoaWxkKWEucmVtb3ZlQ2hpbGQoYS5maXJzdENoaWxkKTthLm9wdGlvbnMmJm0ubm9kZU5hbWUoYSxcInNlbGVjdFwiKSYmKGEub3B0aW9ucy5sZW5ndGg9MCl9cmV0dXJuIHRoaXN9LGNsb25lOmZ1bmN0aW9uKGEsYil7cmV0dXJuIGE9bnVsbD09YT8hMTphLGI9bnVsbD09Yj9hOmIsdGhpcy5tYXAoZnVuY3Rpb24oKXtyZXR1cm4gbS5jbG9uZSh0aGlzLGEsYil9KX0saHRtbDpmdW5jdGlvbihhKXtyZXR1cm4gVih0aGlzLGZ1bmN0aW9uKGEpe3ZhciBiPXRoaXNbMF18fHt9LGM9MCxkPXRoaXMubGVuZ3RoO2lmKHZvaWQgMD09PWEpcmV0dXJuIDE9PT1iLm5vZGVUeXBlP2IuaW5uZXJIVE1MLnJlcGxhY2UoZmEsXCJcIik6dm9pZCAwO2lmKCEoXCJzdHJpbmdcIiE9dHlwZW9mIGF8fG1hLnRlc3QoYSl8fCFrLmh0bWxTZXJpYWxpemUmJmdhLnRlc3QoYSl8fCFrLmxlYWRpbmdXaGl0ZXNwYWNlJiZoYS50ZXN0KGEpfHxyYVsoamEuZXhlYyhhKXx8W1wiXCIsXCJcIl0pWzFdLnRvTG93ZXJDYXNlKCldKSl7YT1hLnJlcGxhY2UoaWEsXCI8JDE+PC8kMj5cIik7dHJ5e2Zvcig7ZD5jO2MrKyliPXRoaXNbY118fHt9LDE9PT1iLm5vZGVUeXBlJiYobS5jbGVhbkRhdGEodWEoYiwhMSkpLGIuaW5uZXJIVE1MPWEpO2I9MH1jYXRjaChlKXt9fWImJnRoaXMuZW1wdHkoKS5hcHBlbmQoYSl9LG51bGwsYSxhcmd1bWVudHMubGVuZ3RoKX0scmVwbGFjZVdpdGg6ZnVuY3Rpb24oKXt2YXIgYT1hcmd1bWVudHNbMF07cmV0dXJuIHRoaXMuZG9tTWFuaXAoYXJndW1lbnRzLGZ1bmN0aW9uKGIpe2E9dGhpcy5wYXJlbnROb2RlLG0uY2xlYW5EYXRhKHVhKHRoaXMpKSxhJiZhLnJlcGxhY2VDaGlsZChiLHRoaXMpfSksYSYmKGEubGVuZ3RofHxhLm5vZGVUeXBlKT90aGlzOnRoaXMucmVtb3ZlKCl9LGRldGFjaDpmdW5jdGlvbihhKXtyZXR1cm4gdGhpcy5yZW1vdmUoYSwhMCl9LGRvbU1hbmlwOmZ1bmN0aW9uKGEsYil7YT1lLmFwcGx5KFtdLGEpO3ZhciBjLGQsZixnLGgsaSxqPTAsbD10aGlzLmxlbmd0aCxuPXRoaXMsbz1sLTEscD1hWzBdLHE9bS5pc0Z1bmN0aW9uKHApO2lmKHF8fGw+MSYmXCJzdHJpbmdcIj09dHlwZW9mIHAmJiFrLmNoZWNrQ2xvbmUmJm5hLnRlc3QocCkpcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbihjKXt2YXIgZD1uLmVxKGMpO3EmJihhWzBdPXAuY2FsbCh0aGlzLGMsZC5odG1sKCkpKSxkLmRvbU1hbmlwKGEsYil9KTtpZihsJiYoaT1tLmJ1aWxkRnJhZ21lbnQoYSx0aGlzWzBdLm93bmVyRG9jdW1lbnQsITEsdGhpcyksYz1pLmZpcnN0Q2hpbGQsMT09PWkuY2hpbGROb2Rlcy5sZW5ndGgmJihpPWMpLGMpKXtmb3IoZz1tLm1hcCh1YShpLFwic2NyaXB0XCIpLHhhKSxmPWcubGVuZ3RoO2w+ajtqKyspZD1pLGohPT1vJiYoZD1tLmNsb25lKGQsITAsITApLGYmJm0ubWVyZ2UoZyx1YShkLFwic2NyaXB0XCIpKSksYi5jYWxsKHRoaXNbal0sZCxqKTtpZihmKWZvcihoPWdbZy5sZW5ndGgtMV0ub3duZXJEb2N1bWVudCxtLm1hcChnLHlhKSxqPTA7Zj5qO2orKylkPWdbal0sb2EudGVzdChkLnR5cGV8fFwiXCIpJiYhbS5fZGF0YShkLFwiZ2xvYmFsRXZhbFwiKSYmbS5jb250YWlucyhoLGQpJiYoZC5zcmM/bS5fZXZhbFVybCYmbS5fZXZhbFVybChkLnNyYyk6bS5nbG9iYWxFdmFsKChkLnRleHR8fGQudGV4dENvbnRlbnR8fGQuaW5uZXJIVE1MfHxcIlwiKS5yZXBsYWNlKHFhLFwiXCIpKSk7aT1jPW51bGx9cmV0dXJuIHRoaXN9fSksbS5lYWNoKHthcHBlbmRUbzpcImFwcGVuZFwiLHByZXBlbmRUbzpcInByZXBlbmRcIixpbnNlcnRCZWZvcmU6XCJiZWZvcmVcIixpbnNlcnRBZnRlcjpcImFmdGVyXCIscmVwbGFjZUFsbDpcInJlcGxhY2VXaXRoXCJ9LGZ1bmN0aW9uKGEsYil7bS5mblthXT1mdW5jdGlvbihhKXtmb3IodmFyIGMsZD0wLGU9W10sZz1tKGEpLGg9Zy5sZW5ndGgtMTtoPj1kO2QrKyljPWQ9PT1oP3RoaXM6dGhpcy5jbG9uZSghMCksbShnW2RdKVtiXShjKSxmLmFwcGx5KGUsYy5nZXQoKSk7cmV0dXJuIHRoaXMucHVzaFN0YWNrKGUpfX0pO3ZhciBDYSxEYT17fTtmdW5jdGlvbiBFYShiLGMpe3ZhciBkLGU9bShjLmNyZWF0ZUVsZW1lbnQoYikpLmFwcGVuZFRvKGMuYm9keSksZj1hLmdldERlZmF1bHRDb21wdXRlZFN0eWxlJiYoZD1hLmdldERlZmF1bHRDb21wdXRlZFN0eWxlKGVbMF0pKT9kLmRpc3BsYXk6bS5jc3MoZVswXSxcImRpc3BsYXlcIik7cmV0dXJuIGUuZGV0YWNoKCksZn1mdW5jdGlvbiBGYShhKXt2YXIgYj15LGM9RGFbYV07cmV0dXJuIGN8fChjPUVhKGEsYiksXCJub25lXCIhPT1jJiZjfHwoQ2E9KENhfHxtKFwiPGlmcmFtZSBmcmFtZWJvcmRlcj0nMCcgd2lkdGg9JzAnIGhlaWdodD0nMCcvPlwiKSkuYXBwZW5kVG8oYi5kb2N1bWVudEVsZW1lbnQpLGI9KENhWzBdLmNvbnRlbnRXaW5kb3d8fENhWzBdLmNvbnRlbnREb2N1bWVudCkuZG9jdW1lbnQsYi53cml0ZSgpLGIuY2xvc2UoKSxjPUVhKGEsYiksQ2EuZGV0YWNoKCkpLERhW2FdPWMpLGN9IWZ1bmN0aW9uKCl7dmFyIGE7ay5zaHJpbmtXcmFwQmxvY2tzPWZ1bmN0aW9uKCl7aWYobnVsbCE9YSlyZXR1cm4gYTthPSExO3ZhciBiLGMsZDtyZXR1cm4gYz15LmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiYm9keVwiKVswXSxjJiZjLnN0eWxlPyhiPXkuY3JlYXRlRWxlbWVudChcImRpdlwiKSxkPXkuY3JlYXRlRWxlbWVudChcImRpdlwiKSxkLnN0eWxlLmNzc1RleHQ9XCJwb3NpdGlvbjphYnNvbHV0ZTtib3JkZXI6MDt3aWR0aDowO2hlaWdodDowO3RvcDowO2xlZnQ6LTk5OTlweFwiLGMuYXBwZW5kQ2hpbGQoZCkuYXBwZW5kQ2hpbGQoYiksdHlwZW9mIGIuc3R5bGUuem9vbSE9PUsmJihiLnN0eWxlLmNzc1RleHQ9XCItd2Via2l0LWJveC1zaXppbmc6Y29udGVudC1ib3g7LW1vei1ib3gtc2l6aW5nOmNvbnRlbnQtYm94O2JveC1zaXppbmc6Y29udGVudC1ib3g7ZGlzcGxheTpibG9jazttYXJnaW46MDtib3JkZXI6MDtwYWRkaW5nOjFweDt3aWR0aDoxcHg7em9vbToxXCIsYi5hcHBlbmRDaGlsZCh5LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIikpLnN0eWxlLndpZHRoPVwiNXB4XCIsYT0zIT09Yi5vZmZzZXRXaWR0aCksYy5yZW1vdmVDaGlsZChkKSxhKTp2b2lkIDB9fSgpO3ZhciBHYT0vXm1hcmdpbi8sSGE9bmV3IFJlZ0V4cChcIl4oXCIrUytcIikoPyFweClbYS16JV0rJFwiLFwiaVwiKSxJYSxKYSxLYT0vXih0b3B8cmlnaHR8Ym90dG9tfGxlZnQpJC87YS5nZXRDb21wdXRlZFN0eWxlPyhJYT1mdW5jdGlvbihiKXtyZXR1cm4gYi5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3Lm9wZW5lcj9iLm93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXcuZ2V0Q29tcHV0ZWRTdHlsZShiLG51bGwpOmEuZ2V0Q29tcHV0ZWRTdHlsZShiLG51bGwpfSxKYT1mdW5jdGlvbihhLGIsYyl7dmFyIGQsZSxmLGcsaD1hLnN0eWxlO3JldHVybiBjPWN8fElhKGEpLGc9Yz9jLmdldFByb3BlcnR5VmFsdWUoYil8fGNbYl06dm9pZCAwLGMmJihcIlwiIT09Z3x8bS5jb250YWlucyhhLm93bmVyRG9jdW1lbnQsYSl8fChnPW0uc3R5bGUoYSxiKSksSGEudGVzdChnKSYmR2EudGVzdChiKSYmKGQ9aC53aWR0aCxlPWgubWluV2lkdGgsZj1oLm1heFdpZHRoLGgubWluV2lkdGg9aC5tYXhXaWR0aD1oLndpZHRoPWcsZz1jLndpZHRoLGgud2lkdGg9ZCxoLm1pbldpZHRoPWUsaC5tYXhXaWR0aD1mKSksdm9pZCAwPT09Zz9nOmcrXCJcIn0pOnkuZG9jdW1lbnRFbGVtZW50LmN1cnJlbnRTdHlsZSYmKElhPWZ1bmN0aW9uKGEpe3JldHVybiBhLmN1cnJlbnRTdHlsZX0sSmE9ZnVuY3Rpb24oYSxiLGMpe3ZhciBkLGUsZixnLGg9YS5zdHlsZTtyZXR1cm4gYz1jfHxJYShhKSxnPWM/Y1tiXTp2b2lkIDAsbnVsbD09ZyYmaCYmaFtiXSYmKGc9aFtiXSksSGEudGVzdChnKSYmIUthLnRlc3QoYikmJihkPWgubGVmdCxlPWEucnVudGltZVN0eWxlLGY9ZSYmZS5sZWZ0LGYmJihlLmxlZnQ9YS5jdXJyZW50U3R5bGUubGVmdCksaC5sZWZ0PVwiZm9udFNpemVcIj09PWI/XCIxZW1cIjpnLGc9aC5waXhlbExlZnQrXCJweFwiLGgubGVmdD1kLGYmJihlLmxlZnQ9ZikpLHZvaWQgMD09PWc/ZzpnK1wiXCJ8fFwiYXV0b1wifSk7ZnVuY3Rpb24gTGEoYSxiKXtyZXR1cm57Z2V0OmZ1bmN0aW9uKCl7dmFyIGM9YSgpO2lmKG51bGwhPWMpcmV0dXJuIGM/dm9pZCBkZWxldGUgdGhpcy5nZXQ6KHRoaXMuZ2V0PWIpLmFwcGx5KHRoaXMsYXJndW1lbnRzKX19fSFmdW5jdGlvbigpe3ZhciBiLGMsZCxlLGYsZyxoO2lmKGI9eS5jcmVhdGVFbGVtZW50KFwiZGl2XCIpLGIuaW5uZXJIVE1MPVwiICA8bGluay8+PHRhYmxlPjwvdGFibGU+PGEgaHJlZj0nL2EnPmE8L2E+PGlucHV0IHR5cGU9J2NoZWNrYm94Jy8+XCIsZD1iLmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiYVwiKVswXSxjPWQmJmQuc3R5bGUpe2MuY3NzVGV4dD1cImZsb2F0OmxlZnQ7b3BhY2l0eTouNVwiLGsub3BhY2l0eT1cIjAuNVwiPT09Yy5vcGFjaXR5LGsuY3NzRmxvYXQ9ISFjLmNzc0Zsb2F0LGIuc3R5bGUuYmFja2dyb3VuZENsaXA9XCJjb250ZW50LWJveFwiLGIuY2xvbmVOb2RlKCEwKS5zdHlsZS5iYWNrZ3JvdW5kQ2xpcD1cIlwiLGsuY2xlYXJDbG9uZVN0eWxlPVwiY29udGVudC1ib3hcIj09PWIuc3R5bGUuYmFja2dyb3VuZENsaXAsay5ib3hTaXppbmc9XCJcIj09PWMuYm94U2l6aW5nfHxcIlwiPT09Yy5Nb3pCb3hTaXppbmd8fFwiXCI9PT1jLldlYmtpdEJveFNpemluZyxtLmV4dGVuZChrLHtyZWxpYWJsZUhpZGRlbk9mZnNldHM6ZnVuY3Rpb24oKXtyZXR1cm4gbnVsbD09ZyYmaSgpLGd9LGJveFNpemluZ1JlbGlhYmxlOmZ1bmN0aW9uKCl7cmV0dXJuIG51bGw9PWYmJmkoKSxmfSxwaXhlbFBvc2l0aW9uOmZ1bmN0aW9uKCl7cmV0dXJuIG51bGw9PWUmJmkoKSxlfSxyZWxpYWJsZU1hcmdpblJpZ2h0OmZ1bmN0aW9uKCl7cmV0dXJuIG51bGw9PWgmJmkoKSxofX0pO2Z1bmN0aW9uIGkoKXt2YXIgYixjLGQsaTtjPXkuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJib2R5XCIpWzBdLGMmJmMuc3R5bGUmJihiPXkuY3JlYXRlRWxlbWVudChcImRpdlwiKSxkPXkuY3JlYXRlRWxlbWVudChcImRpdlwiKSxkLnN0eWxlLmNzc1RleHQ9XCJwb3NpdGlvbjphYnNvbHV0ZTtib3JkZXI6MDt3aWR0aDowO2hlaWdodDowO3RvcDowO2xlZnQ6LTk5OTlweFwiLGMuYXBwZW5kQ2hpbGQoZCkuYXBwZW5kQ2hpbGQoYiksYi5zdHlsZS5jc3NUZXh0PVwiLXdlYmtpdC1ib3gtc2l6aW5nOmJvcmRlci1ib3g7LW1vei1ib3gtc2l6aW5nOmJvcmRlci1ib3g7Ym94LXNpemluZzpib3JkZXItYm94O2Rpc3BsYXk6YmxvY2s7bWFyZ2luLXRvcDoxJTt0b3A6MSU7Ym9yZGVyOjFweDtwYWRkaW5nOjFweDt3aWR0aDo0cHg7cG9zaXRpb246YWJzb2x1dGVcIixlPWY9ITEsaD0hMCxhLmdldENvbXB1dGVkU3R5bGUmJihlPVwiMSVcIiE9PShhLmdldENvbXB1dGVkU3R5bGUoYixudWxsKXx8e30pLnRvcCxmPVwiNHB4XCI9PT0oYS5nZXRDb21wdXRlZFN0eWxlKGIsbnVsbCl8fHt3aWR0aDpcIjRweFwifSkud2lkdGgsaT1iLmFwcGVuZENoaWxkKHkuY3JlYXRlRWxlbWVudChcImRpdlwiKSksaS5zdHlsZS5jc3NUZXh0PWIuc3R5bGUuY3NzVGV4dD1cIi13ZWJraXQtYm94LXNpemluZzpjb250ZW50LWJveDstbW96LWJveC1zaXppbmc6Y29udGVudC1ib3g7Ym94LXNpemluZzpjb250ZW50LWJveDtkaXNwbGF5OmJsb2NrO21hcmdpbjowO2JvcmRlcjowO3BhZGRpbmc6MFwiLGkuc3R5bGUubWFyZ2luUmlnaHQ9aS5zdHlsZS53aWR0aD1cIjBcIixiLnN0eWxlLndpZHRoPVwiMXB4XCIsaD0hcGFyc2VGbG9hdCgoYS5nZXRDb21wdXRlZFN0eWxlKGksbnVsbCl8fHt9KS5tYXJnaW5SaWdodCksYi5yZW1vdmVDaGlsZChpKSksYi5pbm5lckhUTUw9XCI8dGFibGU+PHRyPjx0ZD48L3RkPjx0ZD50PC90ZD48L3RyPjwvdGFibGU+XCIsaT1iLmdldEVsZW1lbnRzQnlUYWdOYW1lKFwidGRcIiksaVswXS5zdHlsZS5jc3NUZXh0PVwibWFyZ2luOjA7Ym9yZGVyOjA7cGFkZGluZzowO2Rpc3BsYXk6bm9uZVwiLGc9MD09PWlbMF0ub2Zmc2V0SGVpZ2h0LGcmJihpWzBdLnN0eWxlLmRpc3BsYXk9XCJcIixpWzFdLnN0eWxlLmRpc3BsYXk9XCJub25lXCIsZz0wPT09aVswXS5vZmZzZXRIZWlnaHQpLGMucmVtb3ZlQ2hpbGQoZCkpfX19KCksbS5zd2FwPWZ1bmN0aW9uKGEsYixjLGQpe3ZhciBlLGYsZz17fTtmb3IoZiBpbiBiKWdbZl09YS5zdHlsZVtmXSxhLnN0eWxlW2ZdPWJbZl07ZT1jLmFwcGx5KGEsZHx8W10pO2ZvcihmIGluIGIpYS5zdHlsZVtmXT1nW2ZdO3JldHVybiBlfTt2YXIgTWE9L2FscGhhXFwoW14pXSpcXCkvaSxOYT0vb3BhY2l0eVxccyo9XFxzKihbXildKikvLE9hPS9eKG5vbmV8dGFibGUoPyEtY1tlYV0pLispLyxQYT1uZXcgUmVnRXhwKFwiXihcIitTK1wiKSguKikkXCIsXCJpXCIpLFFhPW5ldyBSZWdFeHAoXCJeKFsrLV0pPShcIitTK1wiKVwiLFwiaVwiKSxSYT17cG9zaXRpb246XCJhYnNvbHV0ZVwiLHZpc2liaWxpdHk6XCJoaWRkZW5cIixkaXNwbGF5OlwiYmxvY2tcIn0sU2E9e2xldHRlclNwYWNpbmc6XCIwXCIsZm9udFdlaWdodDpcIjQwMFwifSxUYT1bXCJXZWJraXRcIixcIk9cIixcIk1velwiLFwibXNcIl07ZnVuY3Rpb24gVWEoYSxiKXtpZihiIGluIGEpcmV0dXJuIGI7dmFyIGM9Yi5jaGFyQXQoMCkudG9VcHBlckNhc2UoKStiLnNsaWNlKDEpLGQ9YixlPVRhLmxlbmd0aDt3aGlsZShlLS0paWYoYj1UYVtlXStjLGIgaW4gYSlyZXR1cm4gYjtyZXR1cm4gZH1mdW5jdGlvbiBWYShhLGIpe2Zvcih2YXIgYyxkLGUsZj1bXSxnPTAsaD1hLmxlbmd0aDtoPmc7ZysrKWQ9YVtnXSxkLnN0eWxlJiYoZltnXT1tLl9kYXRhKGQsXCJvbGRkaXNwbGF5XCIpLGM9ZC5zdHlsZS5kaXNwbGF5LGI/KGZbZ118fFwibm9uZVwiIT09Y3x8KGQuc3R5bGUuZGlzcGxheT1cIlwiKSxcIlwiPT09ZC5zdHlsZS5kaXNwbGF5JiZVKGQpJiYoZltnXT1tLl9kYXRhKGQsXCJvbGRkaXNwbGF5XCIsRmEoZC5ub2RlTmFtZSkpKSk6KGU9VShkKSwoYyYmXCJub25lXCIhPT1jfHwhZSkmJm0uX2RhdGEoZCxcIm9sZGRpc3BsYXlcIixlP2M6bS5jc3MoZCxcImRpc3BsYXlcIikpKSk7Zm9yKGc9MDtoPmc7ZysrKWQ9YVtnXSxkLnN0eWxlJiYoYiYmXCJub25lXCIhPT1kLnN0eWxlLmRpc3BsYXkmJlwiXCIhPT1kLnN0eWxlLmRpc3BsYXl8fChkLnN0eWxlLmRpc3BsYXk9Yj9mW2ddfHxcIlwiOlwibm9uZVwiKSk7cmV0dXJuIGF9ZnVuY3Rpb24gV2EoYSxiLGMpe3ZhciBkPVBhLmV4ZWMoYik7cmV0dXJuIGQ/TWF0aC5tYXgoMCxkWzFdLShjfHwwKSkrKGRbMl18fFwicHhcIik6Yn1mdW5jdGlvbiBYYShhLGIsYyxkLGUpe2Zvcih2YXIgZj1jPT09KGQ/XCJib3JkZXJcIjpcImNvbnRlbnRcIik/NDpcIndpZHRoXCI9PT1iPzE6MCxnPTA7ND5mO2YrPTIpXCJtYXJnaW5cIj09PWMmJihnKz1tLmNzcyhhLGMrVFtmXSwhMCxlKSksZD8oXCJjb250ZW50XCI9PT1jJiYoZy09bS5jc3MoYSxcInBhZGRpbmdcIitUW2ZdLCEwLGUpKSxcIm1hcmdpblwiIT09YyYmKGctPW0uY3NzKGEsXCJib3JkZXJcIitUW2ZdK1wiV2lkdGhcIiwhMCxlKSkpOihnKz1tLmNzcyhhLFwicGFkZGluZ1wiK1RbZl0sITAsZSksXCJwYWRkaW5nXCIhPT1jJiYoZys9bS5jc3MoYSxcImJvcmRlclwiK1RbZl0rXCJXaWR0aFwiLCEwLGUpKSk7cmV0dXJuIGd9ZnVuY3Rpb24gWWEoYSxiLGMpe3ZhciBkPSEwLGU9XCJ3aWR0aFwiPT09Yj9hLm9mZnNldFdpZHRoOmEub2Zmc2V0SGVpZ2h0LGY9SWEoYSksZz1rLmJveFNpemluZyYmXCJib3JkZXItYm94XCI9PT1tLmNzcyhhLFwiYm94U2l6aW5nXCIsITEsZik7aWYoMD49ZXx8bnVsbD09ZSl7aWYoZT1KYShhLGIsZiksKDA+ZXx8bnVsbD09ZSkmJihlPWEuc3R5bGVbYl0pLEhhLnRlc3QoZSkpcmV0dXJuIGU7ZD1nJiYoay5ib3hTaXppbmdSZWxpYWJsZSgpfHxlPT09YS5zdHlsZVtiXSksZT1wYXJzZUZsb2F0KGUpfHwwfXJldHVybiBlK1hhKGEsYixjfHwoZz9cImJvcmRlclwiOlwiY29udGVudFwiKSxkLGYpK1wicHhcIn1tLmV4dGVuZCh7Y3NzSG9va3M6e29wYWNpdHk6e2dldDpmdW5jdGlvbihhLGIpe2lmKGIpe3ZhciBjPUphKGEsXCJvcGFjaXR5XCIpO3JldHVyblwiXCI9PT1jP1wiMVwiOmN9fX19LGNzc051bWJlcjp7Y29sdW1uQ291bnQ6ITAsZmlsbE9wYWNpdHk6ITAsZmxleEdyb3c6ITAsZmxleFNocmluazohMCxmb250V2VpZ2h0OiEwLGxpbmVIZWlnaHQ6ITAsb3BhY2l0eTohMCxvcmRlcjohMCxvcnBoYW5zOiEwLHdpZG93czohMCx6SW5kZXg6ITAsem9vbTohMH0sY3NzUHJvcHM6e1wiZmxvYXRcIjprLmNzc0Zsb2F0P1wiY3NzRmxvYXRcIjpcInN0eWxlRmxvYXRcIn0sc3R5bGU6ZnVuY3Rpb24oYSxiLGMsZCl7aWYoYSYmMyE9PWEubm9kZVR5cGUmJjghPT1hLm5vZGVUeXBlJiZhLnN0eWxlKXt2YXIgZSxmLGcsaD1tLmNhbWVsQ2FzZShiKSxpPWEuc3R5bGU7aWYoYj1tLmNzc1Byb3BzW2hdfHwobS5jc3NQcm9wc1toXT1VYShpLGgpKSxnPW0uY3NzSG9va3NbYl18fG0uY3NzSG9va3NbaF0sdm9pZCAwPT09YylyZXR1cm4gZyYmXCJnZXRcImluIGcmJnZvaWQgMCE9PShlPWcuZ2V0KGEsITEsZCkpP2U6aVtiXTtpZihmPXR5cGVvZiBjLFwic3RyaW5nXCI9PT1mJiYoZT1RYS5leGVjKGMpKSYmKGM9KGVbMV0rMSkqZVsyXStwYXJzZUZsb2F0KG0uY3NzKGEsYikpLGY9XCJudW1iZXJcIiksbnVsbCE9YyYmYz09PWMmJihcIm51bWJlclwiIT09Znx8bS5jc3NOdW1iZXJbaF18fChjKz1cInB4XCIpLGsuY2xlYXJDbG9uZVN0eWxlfHxcIlwiIT09Y3x8MCE9PWIuaW5kZXhPZihcImJhY2tncm91bmRcIil8fChpW2JdPVwiaW5oZXJpdFwiKSwhKGcmJlwic2V0XCJpbiBnJiZ2b2lkIDA9PT0oYz1nLnNldChhLGMsZCkpKSkpdHJ5e2lbYl09Y31jYXRjaChqKXt9fX0sY3NzOmZ1bmN0aW9uKGEsYixjLGQpe3ZhciBlLGYsZyxoPW0uY2FtZWxDYXNlKGIpO3JldHVybiBiPW0uY3NzUHJvcHNbaF18fChtLmNzc1Byb3BzW2hdPVVhKGEuc3R5bGUsaCkpLGc9bS5jc3NIb29rc1tiXXx8bS5jc3NIb29rc1toXSxnJiZcImdldFwiaW4gZyYmKGY9Zy5nZXQoYSwhMCxjKSksdm9pZCAwPT09ZiYmKGY9SmEoYSxiLGQpKSxcIm5vcm1hbFwiPT09ZiYmYiBpbiBTYSYmKGY9U2FbYl0pLFwiXCI9PT1jfHxjPyhlPXBhcnNlRmxvYXQoZiksYz09PSEwfHxtLmlzTnVtZXJpYyhlKT9lfHwwOmYpOmZ9fSksbS5lYWNoKFtcImhlaWdodFwiLFwid2lkdGhcIl0sZnVuY3Rpb24oYSxiKXttLmNzc0hvb2tzW2JdPXtnZXQ6ZnVuY3Rpb24oYSxjLGQpe3JldHVybiBjP09hLnRlc3QobS5jc3MoYSxcImRpc3BsYXlcIikpJiYwPT09YS5vZmZzZXRXaWR0aD9tLnN3YXAoYSxSYSxmdW5jdGlvbigpe3JldHVybiBZYShhLGIsZCl9KTpZYShhLGIsZCk6dm9pZCAwfSxzZXQ6ZnVuY3Rpb24oYSxjLGQpe3ZhciBlPWQmJklhKGEpO3JldHVybiBXYShhLGMsZD9YYShhLGIsZCxrLmJveFNpemluZyYmXCJib3JkZXItYm94XCI9PT1tLmNzcyhhLFwiYm94U2l6aW5nXCIsITEsZSksZSk6MCl9fX0pLGsub3BhY2l0eXx8KG0uY3NzSG9va3Mub3BhY2l0eT17Z2V0OmZ1bmN0aW9uKGEsYil7cmV0dXJuIE5hLnRlc3QoKGImJmEuY3VycmVudFN0eWxlP2EuY3VycmVudFN0eWxlLmZpbHRlcjphLnN0eWxlLmZpbHRlcil8fFwiXCIpPy4wMSpwYXJzZUZsb2F0KFJlZ0V4cC4kMSkrXCJcIjpiP1wiMVwiOlwiXCJ9LHNldDpmdW5jdGlvbihhLGIpe3ZhciBjPWEuc3R5bGUsZD1hLmN1cnJlbnRTdHlsZSxlPW0uaXNOdW1lcmljKGIpP1wiYWxwaGEob3BhY2l0eT1cIisxMDAqYitcIilcIjpcIlwiLGY9ZCYmZC5maWx0ZXJ8fGMuZmlsdGVyfHxcIlwiO2Muem9vbT0xLChiPj0xfHxcIlwiPT09YikmJlwiXCI9PT1tLnRyaW0oZi5yZXBsYWNlKE1hLFwiXCIpKSYmYy5yZW1vdmVBdHRyaWJ1dGUmJihjLnJlbW92ZUF0dHJpYnV0ZShcImZpbHRlclwiKSxcIlwiPT09Ynx8ZCYmIWQuZmlsdGVyKXx8KGMuZmlsdGVyPU1hLnRlc3QoZik/Zi5yZXBsYWNlKE1hLGUpOmYrXCIgXCIrZSl9fSksbS5jc3NIb29rcy5tYXJnaW5SaWdodD1MYShrLnJlbGlhYmxlTWFyZ2luUmlnaHQsZnVuY3Rpb24oYSxiKXtyZXR1cm4gYj9tLnN3YXAoYSx7ZGlzcGxheTpcImlubGluZS1ibG9ja1wifSxKYSxbYSxcIm1hcmdpblJpZ2h0XCJdKTp2b2lkIDB9KSxtLmVhY2goe21hcmdpbjpcIlwiLHBhZGRpbmc6XCJcIixib3JkZXI6XCJXaWR0aFwifSxmdW5jdGlvbihhLGIpe20uY3NzSG9va3NbYStiXT17ZXhwYW5kOmZ1bmN0aW9uKGMpe2Zvcih2YXIgZD0wLGU9e30sZj1cInN0cmluZ1wiPT10eXBlb2YgYz9jLnNwbGl0KFwiIFwiKTpbY107ND5kO2QrKyllW2ErVFtkXStiXT1mW2RdfHxmW2QtMl18fGZbMF07cmV0dXJuIGV9fSxHYS50ZXN0KGEpfHwobS5jc3NIb29rc1thK2JdLnNldD1XYSl9KSxtLmZuLmV4dGVuZCh7Y3NzOmZ1bmN0aW9uKGEsYil7cmV0dXJuIFYodGhpcyxmdW5jdGlvbihhLGIsYyl7dmFyIGQsZSxmPXt9LGc9MDtpZihtLmlzQXJyYXkoYikpe2ZvcihkPUlhKGEpLGU9Yi5sZW5ndGg7ZT5nO2crKylmW2JbZ11dPW0uY3NzKGEsYltnXSwhMSxkKTtyZXR1cm4gZn1yZXR1cm4gdm9pZCAwIT09Yz9tLnN0eWxlKGEsYixjKTptLmNzcyhhLGIpfSxhLGIsYXJndW1lbnRzLmxlbmd0aD4xKX0sc2hvdzpmdW5jdGlvbigpe3JldHVybiBWYSh0aGlzLCEwKX0saGlkZTpmdW5jdGlvbigpe3JldHVybiBWYSh0aGlzKX0sdG9nZ2xlOmZ1bmN0aW9uKGEpe3JldHVyblwiYm9vbGVhblwiPT10eXBlb2YgYT9hP3RoaXMuc2hvdygpOnRoaXMuaGlkZSgpOnRoaXMuZWFjaChmdW5jdGlvbigpe1UodGhpcyk/bSh0aGlzKS5zaG93KCk6bSh0aGlzKS5oaWRlKCl9KX19KTtmdW5jdGlvbiBaYShhLGIsYyxkLGUpe1xyXG5yZXR1cm4gbmV3IFphLnByb3RvdHlwZS5pbml0KGEsYixjLGQsZSl9bS5Ud2Vlbj1aYSxaYS5wcm90b3R5cGU9e2NvbnN0cnVjdG9yOlphLGluaXQ6ZnVuY3Rpb24oYSxiLGMsZCxlLGYpe3RoaXMuZWxlbT1hLHRoaXMucHJvcD1jLHRoaXMuZWFzaW5nPWV8fFwic3dpbmdcIix0aGlzLm9wdGlvbnM9Yix0aGlzLnN0YXJ0PXRoaXMubm93PXRoaXMuY3VyKCksdGhpcy5lbmQ9ZCx0aGlzLnVuaXQ9Znx8KG0uY3NzTnVtYmVyW2NdP1wiXCI6XCJweFwiKX0sY3VyOmZ1bmN0aW9uKCl7dmFyIGE9WmEucHJvcEhvb2tzW3RoaXMucHJvcF07cmV0dXJuIGEmJmEuZ2V0P2EuZ2V0KHRoaXMpOlphLnByb3BIb29rcy5fZGVmYXVsdC5nZXQodGhpcyl9LHJ1bjpmdW5jdGlvbihhKXt2YXIgYixjPVphLnByb3BIb29rc1t0aGlzLnByb3BdO3JldHVybiB0aGlzLm9wdGlvbnMuZHVyYXRpb24/dGhpcy5wb3M9Yj1tLmVhc2luZ1t0aGlzLmVhc2luZ10oYSx0aGlzLm9wdGlvbnMuZHVyYXRpb24qYSwwLDEsdGhpcy5vcHRpb25zLmR1cmF0aW9uKTp0aGlzLnBvcz1iPWEsdGhpcy5ub3c9KHRoaXMuZW5kLXRoaXMuc3RhcnQpKmIrdGhpcy5zdGFydCx0aGlzLm9wdGlvbnMuc3RlcCYmdGhpcy5vcHRpb25zLnN0ZXAuY2FsbCh0aGlzLmVsZW0sdGhpcy5ub3csdGhpcyksYyYmYy5zZXQ/Yy5zZXQodGhpcyk6WmEucHJvcEhvb2tzLl9kZWZhdWx0LnNldCh0aGlzKSx0aGlzfX0sWmEucHJvdG90eXBlLmluaXQucHJvdG90eXBlPVphLnByb3RvdHlwZSxaYS5wcm9wSG9va3M9e19kZWZhdWx0OntnZXQ6ZnVuY3Rpb24oYSl7dmFyIGI7cmV0dXJuIG51bGw9PWEuZWxlbVthLnByb3BdfHxhLmVsZW0uc3R5bGUmJm51bGwhPWEuZWxlbS5zdHlsZVthLnByb3BdPyhiPW0uY3NzKGEuZWxlbSxhLnByb3AsXCJcIiksYiYmXCJhdXRvXCIhPT1iP2I6MCk6YS5lbGVtW2EucHJvcF19LHNldDpmdW5jdGlvbihhKXttLmZ4LnN0ZXBbYS5wcm9wXT9tLmZ4LnN0ZXBbYS5wcm9wXShhKTphLmVsZW0uc3R5bGUmJihudWxsIT1hLmVsZW0uc3R5bGVbbS5jc3NQcm9wc1thLnByb3BdXXx8bS5jc3NIb29rc1thLnByb3BdKT9tLnN0eWxlKGEuZWxlbSxhLnByb3AsYS5ub3crYS51bml0KTphLmVsZW1bYS5wcm9wXT1hLm5vd319fSxaYS5wcm9wSG9va3Muc2Nyb2xsVG9wPVphLnByb3BIb29rcy5zY3JvbGxMZWZ0PXtzZXQ6ZnVuY3Rpb24oYSl7YS5lbGVtLm5vZGVUeXBlJiZhLmVsZW0ucGFyZW50Tm9kZSYmKGEuZWxlbVthLnByb3BdPWEubm93KX19LG0uZWFzaW5nPXtsaW5lYXI6ZnVuY3Rpb24oYSl7cmV0dXJuIGF9LHN3aW5nOmZ1bmN0aW9uKGEpe3JldHVybi41LU1hdGguY29zKGEqTWF0aC5QSSkvMn19LG0uZng9WmEucHJvdG90eXBlLmluaXQsbS5meC5zdGVwPXt9O3ZhciAkYSxfYSxhYj0vXig/OnRvZ2dsZXxzaG93fGhpZGUpJC8sYmI9bmV3IFJlZ0V4cChcIl4oPzooWystXSk9fCkoXCIrUytcIikoW2EteiVdKikkXCIsXCJpXCIpLGNiPS9xdWV1ZUhvb2tzJC8sZGI9W2liXSxlYj17XCIqXCI6W2Z1bmN0aW9uKGEsYil7dmFyIGM9dGhpcy5jcmVhdGVUd2VlbihhLGIpLGQ9Yy5jdXIoKSxlPWJiLmV4ZWMoYiksZj1lJiZlWzNdfHwobS5jc3NOdW1iZXJbYV0/XCJcIjpcInB4XCIpLGc9KG0uY3NzTnVtYmVyW2FdfHxcInB4XCIhPT1mJiYrZCkmJmJiLmV4ZWMobS5jc3MoYy5lbGVtLGEpKSxoPTEsaT0yMDtpZihnJiZnWzNdIT09Zil7Zj1mfHxnWzNdLGU9ZXx8W10sZz0rZHx8MTtkbyBoPWh8fFwiLjVcIixnLz1oLG0uc3R5bGUoYy5lbGVtLGEsZytmKTt3aGlsZShoIT09KGg9Yy5jdXIoKS9kKSYmMSE9PWgmJi0taSl9cmV0dXJuIGUmJihnPWMuc3RhcnQ9K2d8fCtkfHwwLGMudW5pdD1mLGMuZW5kPWVbMV0/ZysoZVsxXSsxKSplWzJdOitlWzJdKSxjfV19O2Z1bmN0aW9uIGZiKCl7cmV0dXJuIHNldFRpbWVvdXQoZnVuY3Rpb24oKXskYT12b2lkIDB9KSwkYT1tLm5vdygpfWZ1bmN0aW9uIGdiKGEsYil7dmFyIGMsZD17aGVpZ2h0OmF9LGU9MDtmb3IoYj1iPzE6MDs0PmU7ZSs9Mi1iKWM9VFtlXSxkW1wibWFyZ2luXCIrY109ZFtcInBhZGRpbmdcIitjXT1hO3JldHVybiBiJiYoZC5vcGFjaXR5PWQud2lkdGg9YSksZH1mdW5jdGlvbiBoYihhLGIsYyl7Zm9yKHZhciBkLGU9KGViW2JdfHxbXSkuY29uY2F0KGViW1wiKlwiXSksZj0wLGc9ZS5sZW5ndGg7Zz5mO2YrKylpZihkPWVbZl0uY2FsbChjLGIsYSkpcmV0dXJuIGR9ZnVuY3Rpb24gaWIoYSxiLGMpe3ZhciBkLGUsZixnLGgsaSxqLGwsbj10aGlzLG89e30scD1hLnN0eWxlLHE9YS5ub2RlVHlwZSYmVShhKSxyPW0uX2RhdGEoYSxcImZ4c2hvd1wiKTtjLnF1ZXVlfHwoaD1tLl9xdWV1ZUhvb2tzKGEsXCJmeFwiKSxudWxsPT1oLnVucXVldWVkJiYoaC51bnF1ZXVlZD0wLGk9aC5lbXB0eS5maXJlLGguZW1wdHkuZmlyZT1mdW5jdGlvbigpe2gudW5xdWV1ZWR8fGkoKX0pLGgudW5xdWV1ZWQrKyxuLmFsd2F5cyhmdW5jdGlvbigpe24uYWx3YXlzKGZ1bmN0aW9uKCl7aC51bnF1ZXVlZC0tLG0ucXVldWUoYSxcImZ4XCIpLmxlbmd0aHx8aC5lbXB0eS5maXJlKCl9KX0pKSwxPT09YS5ub2RlVHlwZSYmKFwiaGVpZ2h0XCJpbiBifHxcIndpZHRoXCJpbiBiKSYmKGMub3ZlcmZsb3c9W3Aub3ZlcmZsb3cscC5vdmVyZmxvd1gscC5vdmVyZmxvd1ldLGo9bS5jc3MoYSxcImRpc3BsYXlcIiksbD1cIm5vbmVcIj09PWo/bS5fZGF0YShhLFwib2xkZGlzcGxheVwiKXx8RmEoYS5ub2RlTmFtZSk6aixcImlubGluZVwiPT09bCYmXCJub25lXCI9PT1tLmNzcyhhLFwiZmxvYXRcIikmJihrLmlubGluZUJsb2NrTmVlZHNMYXlvdXQmJlwiaW5saW5lXCIhPT1GYShhLm5vZGVOYW1lKT9wLnpvb209MTpwLmRpc3BsYXk9XCJpbmxpbmUtYmxvY2tcIikpLGMub3ZlcmZsb3cmJihwLm92ZXJmbG93PVwiaGlkZGVuXCIsay5zaHJpbmtXcmFwQmxvY2tzKCl8fG4uYWx3YXlzKGZ1bmN0aW9uKCl7cC5vdmVyZmxvdz1jLm92ZXJmbG93WzBdLHAub3ZlcmZsb3dYPWMub3ZlcmZsb3dbMV0scC5vdmVyZmxvd1k9Yy5vdmVyZmxvd1syXX0pKTtmb3IoZCBpbiBiKWlmKGU9YltkXSxhYi5leGVjKGUpKXtpZihkZWxldGUgYltkXSxmPWZ8fFwidG9nZ2xlXCI9PT1lLGU9PT0ocT9cImhpZGVcIjpcInNob3dcIikpe2lmKFwic2hvd1wiIT09ZXx8IXJ8fHZvaWQgMD09PXJbZF0pY29udGludWU7cT0hMH1vW2RdPXImJnJbZF18fG0uc3R5bGUoYSxkKX1lbHNlIGo9dm9pZCAwO2lmKG0uaXNFbXB0eU9iamVjdChvKSlcImlubGluZVwiPT09KFwibm9uZVwiPT09aj9GYShhLm5vZGVOYW1lKTpqKSYmKHAuZGlzcGxheT1qKTtlbHNle3I/XCJoaWRkZW5cImluIHImJihxPXIuaGlkZGVuKTpyPW0uX2RhdGEoYSxcImZ4c2hvd1wiLHt9KSxmJiYoci5oaWRkZW49IXEpLHE/bShhKS5zaG93KCk6bi5kb25lKGZ1bmN0aW9uKCl7bShhKS5oaWRlKCl9KSxuLmRvbmUoZnVuY3Rpb24oKXt2YXIgYjttLl9yZW1vdmVEYXRhKGEsXCJmeHNob3dcIik7Zm9yKGIgaW4gbyltLnN0eWxlKGEsYixvW2JdKX0pO2ZvcihkIGluIG8pZz1oYihxP3JbZF06MCxkLG4pLGQgaW4gcnx8KHJbZF09Zy5zdGFydCxxJiYoZy5lbmQ9Zy5zdGFydCxnLnN0YXJ0PVwid2lkdGhcIj09PWR8fFwiaGVpZ2h0XCI9PT1kPzE6MCkpfX1mdW5jdGlvbiBqYihhLGIpe3ZhciBjLGQsZSxmLGc7Zm9yKGMgaW4gYSlpZihkPW0uY2FtZWxDYXNlKGMpLGU9YltkXSxmPWFbY10sbS5pc0FycmF5KGYpJiYoZT1mWzFdLGY9YVtjXT1mWzBdKSxjIT09ZCYmKGFbZF09ZixkZWxldGUgYVtjXSksZz1tLmNzc0hvb2tzW2RdLGcmJlwiZXhwYW5kXCJpbiBnKXtmPWcuZXhwYW5kKGYpLGRlbGV0ZSBhW2RdO2ZvcihjIGluIGYpYyBpbiBhfHwoYVtjXT1mW2NdLGJbY109ZSl9ZWxzZSBiW2RdPWV9ZnVuY3Rpb24ga2IoYSxiLGMpe3ZhciBkLGUsZj0wLGc9ZGIubGVuZ3RoLGg9bS5EZWZlcnJlZCgpLmFsd2F5cyhmdW5jdGlvbigpe2RlbGV0ZSBpLmVsZW19KSxpPWZ1bmN0aW9uKCl7aWYoZSlyZXR1cm4hMTtmb3IodmFyIGI9JGF8fGZiKCksYz1NYXRoLm1heCgwLGouc3RhcnRUaW1lK2ouZHVyYXRpb24tYiksZD1jL2ouZHVyYXRpb258fDAsZj0xLWQsZz0wLGk9ai50d2VlbnMubGVuZ3RoO2k+ZztnKyspai50d2VlbnNbZ10ucnVuKGYpO3JldHVybiBoLm5vdGlmeVdpdGgoYSxbaixmLGNdKSwxPmYmJmk/YzooaC5yZXNvbHZlV2l0aChhLFtqXSksITEpfSxqPWgucHJvbWlzZSh7ZWxlbTphLHByb3BzOm0uZXh0ZW5kKHt9LGIpLG9wdHM6bS5leHRlbmQoITAse3NwZWNpYWxFYXNpbmc6e319LGMpLG9yaWdpbmFsUHJvcGVydGllczpiLG9yaWdpbmFsT3B0aW9uczpjLHN0YXJ0VGltZTokYXx8ZmIoKSxkdXJhdGlvbjpjLmR1cmF0aW9uLHR3ZWVuczpbXSxjcmVhdGVUd2VlbjpmdW5jdGlvbihiLGMpe3ZhciBkPW0uVHdlZW4oYSxqLm9wdHMsYixjLGoub3B0cy5zcGVjaWFsRWFzaW5nW2JdfHxqLm9wdHMuZWFzaW5nKTtyZXR1cm4gai50d2VlbnMucHVzaChkKSxkfSxzdG9wOmZ1bmN0aW9uKGIpe3ZhciBjPTAsZD1iP2oudHdlZW5zLmxlbmd0aDowO2lmKGUpcmV0dXJuIHRoaXM7Zm9yKGU9ITA7ZD5jO2MrKylqLnR3ZWVuc1tjXS5ydW4oMSk7cmV0dXJuIGI/aC5yZXNvbHZlV2l0aChhLFtqLGJdKTpoLnJlamVjdFdpdGgoYSxbaixiXSksdGhpc319KSxrPWoucHJvcHM7Zm9yKGpiKGssai5vcHRzLnNwZWNpYWxFYXNpbmcpO2c+ZjtmKyspaWYoZD1kYltmXS5jYWxsKGosYSxrLGoub3B0cykpcmV0dXJuIGQ7cmV0dXJuIG0ubWFwKGssaGIsaiksbS5pc0Z1bmN0aW9uKGoub3B0cy5zdGFydCkmJmoub3B0cy5zdGFydC5jYWxsKGEsaiksbS5meC50aW1lcihtLmV4dGVuZChpLHtlbGVtOmEsYW5pbTpqLHF1ZXVlOmoub3B0cy5xdWV1ZX0pKSxqLnByb2dyZXNzKGoub3B0cy5wcm9ncmVzcykuZG9uZShqLm9wdHMuZG9uZSxqLm9wdHMuY29tcGxldGUpLmZhaWwoai5vcHRzLmZhaWwpLmFsd2F5cyhqLm9wdHMuYWx3YXlzKX1tLkFuaW1hdGlvbj1tLmV4dGVuZChrYix7dHdlZW5lcjpmdW5jdGlvbihhLGIpe20uaXNGdW5jdGlvbihhKT8oYj1hLGE9W1wiKlwiXSk6YT1hLnNwbGl0KFwiIFwiKTtmb3IodmFyIGMsZD0wLGU9YS5sZW5ndGg7ZT5kO2QrKyljPWFbZF0sZWJbY109ZWJbY118fFtdLGViW2NdLnVuc2hpZnQoYil9LHByZWZpbHRlcjpmdW5jdGlvbihhLGIpe2I/ZGIudW5zaGlmdChhKTpkYi5wdXNoKGEpfX0pLG0uc3BlZWQ9ZnVuY3Rpb24oYSxiLGMpe3ZhciBkPWEmJlwib2JqZWN0XCI9PXR5cGVvZiBhP20uZXh0ZW5kKHt9LGEpOntjb21wbGV0ZTpjfHwhYyYmYnx8bS5pc0Z1bmN0aW9uKGEpJiZhLGR1cmF0aW9uOmEsZWFzaW5nOmMmJmJ8fGImJiFtLmlzRnVuY3Rpb24oYikmJmJ9O3JldHVybiBkLmR1cmF0aW9uPW0uZngub2ZmPzA6XCJudW1iZXJcIj09dHlwZW9mIGQuZHVyYXRpb24/ZC5kdXJhdGlvbjpkLmR1cmF0aW9uIGluIG0uZnguc3BlZWRzP20uZnguc3BlZWRzW2QuZHVyYXRpb25dOm0uZnguc3BlZWRzLl9kZWZhdWx0LChudWxsPT1kLnF1ZXVlfHxkLnF1ZXVlPT09ITApJiYoZC5xdWV1ZT1cImZ4XCIpLGQub2xkPWQuY29tcGxldGUsZC5jb21wbGV0ZT1mdW5jdGlvbigpe20uaXNGdW5jdGlvbihkLm9sZCkmJmQub2xkLmNhbGwodGhpcyksZC5xdWV1ZSYmbS5kZXF1ZXVlKHRoaXMsZC5xdWV1ZSl9LGR9LG0uZm4uZXh0ZW5kKHtmYWRlVG86ZnVuY3Rpb24oYSxiLGMsZCl7cmV0dXJuIHRoaXMuZmlsdGVyKFUpLmNzcyhcIm9wYWNpdHlcIiwwKS5zaG93KCkuZW5kKCkuYW5pbWF0ZSh7b3BhY2l0eTpifSxhLGMsZCl9LGFuaW1hdGU6ZnVuY3Rpb24oYSxiLGMsZCl7dmFyIGU9bS5pc0VtcHR5T2JqZWN0KGEpLGY9bS5zcGVlZChiLGMsZCksZz1mdW5jdGlvbigpe3ZhciBiPWtiKHRoaXMsbS5leHRlbmQoe30sYSksZik7KGV8fG0uX2RhdGEodGhpcyxcImZpbmlzaFwiKSkmJmIuc3RvcCghMCl9O3JldHVybiBnLmZpbmlzaD1nLGV8fGYucXVldWU9PT0hMT90aGlzLmVhY2goZyk6dGhpcy5xdWV1ZShmLnF1ZXVlLGcpfSxzdG9wOmZ1bmN0aW9uKGEsYixjKXt2YXIgZD1mdW5jdGlvbihhKXt2YXIgYj1hLnN0b3A7ZGVsZXRlIGEuc3RvcCxiKGMpfTtyZXR1cm5cInN0cmluZ1wiIT10eXBlb2YgYSYmKGM9YixiPWEsYT12b2lkIDApLGImJmEhPT0hMSYmdGhpcy5xdWV1ZShhfHxcImZ4XCIsW10pLHRoaXMuZWFjaChmdW5jdGlvbigpe3ZhciBiPSEwLGU9bnVsbCE9YSYmYStcInF1ZXVlSG9va3NcIixmPW0udGltZXJzLGc9bS5fZGF0YSh0aGlzKTtpZihlKWdbZV0mJmdbZV0uc3RvcCYmZChnW2VdKTtlbHNlIGZvcihlIGluIGcpZ1tlXSYmZ1tlXS5zdG9wJiZjYi50ZXN0KGUpJiZkKGdbZV0pO2ZvcihlPWYubGVuZ3RoO2UtLTspZltlXS5lbGVtIT09dGhpc3x8bnVsbCE9YSYmZltlXS5xdWV1ZSE9PWF8fChmW2VdLmFuaW0uc3RvcChjKSxiPSExLGYuc3BsaWNlKGUsMSkpOyhifHwhYykmJm0uZGVxdWV1ZSh0aGlzLGEpfSl9LGZpbmlzaDpmdW5jdGlvbihhKXtyZXR1cm4gYSE9PSExJiYoYT1hfHxcImZ4XCIpLHRoaXMuZWFjaChmdW5jdGlvbigpe3ZhciBiLGM9bS5fZGF0YSh0aGlzKSxkPWNbYStcInF1ZXVlXCJdLGU9Y1thK1wicXVldWVIb29rc1wiXSxmPW0udGltZXJzLGc9ZD9kLmxlbmd0aDowO2ZvcihjLmZpbmlzaD0hMCxtLnF1ZXVlKHRoaXMsYSxbXSksZSYmZS5zdG9wJiZlLnN0b3AuY2FsbCh0aGlzLCEwKSxiPWYubGVuZ3RoO2ItLTspZltiXS5lbGVtPT09dGhpcyYmZltiXS5xdWV1ZT09PWEmJihmW2JdLmFuaW0uc3RvcCghMCksZi5zcGxpY2UoYiwxKSk7Zm9yKGI9MDtnPmI7YisrKWRbYl0mJmRbYl0uZmluaXNoJiZkW2JdLmZpbmlzaC5jYWxsKHRoaXMpO2RlbGV0ZSBjLmZpbmlzaH0pfX0pLG0uZWFjaChbXCJ0b2dnbGVcIixcInNob3dcIixcImhpZGVcIl0sZnVuY3Rpb24oYSxiKXt2YXIgYz1tLmZuW2JdO20uZm5bYl09ZnVuY3Rpb24oYSxkLGUpe3JldHVybiBudWxsPT1hfHxcImJvb2xlYW5cIj09dHlwZW9mIGE/Yy5hcHBseSh0aGlzLGFyZ3VtZW50cyk6dGhpcy5hbmltYXRlKGdiKGIsITApLGEsZCxlKX19KSxtLmVhY2goe3NsaWRlRG93bjpnYihcInNob3dcIiksc2xpZGVVcDpnYihcImhpZGVcIiksc2xpZGVUb2dnbGU6Z2IoXCJ0b2dnbGVcIiksZmFkZUluOntvcGFjaXR5Olwic2hvd1wifSxmYWRlT3V0OntvcGFjaXR5OlwiaGlkZVwifSxmYWRlVG9nZ2xlOntvcGFjaXR5OlwidG9nZ2xlXCJ9fSxmdW5jdGlvbihhLGIpe20uZm5bYV09ZnVuY3Rpb24oYSxjLGQpe3JldHVybiB0aGlzLmFuaW1hdGUoYixhLGMsZCl9fSksbS50aW1lcnM9W10sbS5meC50aWNrPWZ1bmN0aW9uKCl7dmFyIGEsYj1tLnRpbWVycyxjPTA7Zm9yKCRhPW0ubm93KCk7YzxiLmxlbmd0aDtjKyspYT1iW2NdLGEoKXx8YltjXSE9PWF8fGIuc3BsaWNlKGMtLSwxKTtiLmxlbmd0aHx8bS5meC5zdG9wKCksJGE9dm9pZCAwfSxtLmZ4LnRpbWVyPWZ1bmN0aW9uKGEpe20udGltZXJzLnB1c2goYSksYSgpP20uZnguc3RhcnQoKTptLnRpbWVycy5wb3AoKX0sbS5meC5pbnRlcnZhbD0xMyxtLmZ4LnN0YXJ0PWZ1bmN0aW9uKCl7X2F8fChfYT1zZXRJbnRlcnZhbChtLmZ4LnRpY2ssbS5meC5pbnRlcnZhbCkpfSxtLmZ4LnN0b3A9ZnVuY3Rpb24oKXtjbGVhckludGVydmFsKF9hKSxfYT1udWxsfSxtLmZ4LnNwZWVkcz17c2xvdzo2MDAsZmFzdDoyMDAsX2RlZmF1bHQ6NDAwfSxtLmZuLmRlbGF5PWZ1bmN0aW9uKGEsYil7cmV0dXJuIGE9bS5meD9tLmZ4LnNwZWVkc1thXXx8YTphLGI9Ynx8XCJmeFwiLHRoaXMucXVldWUoYixmdW5jdGlvbihiLGMpe3ZhciBkPXNldFRpbWVvdXQoYixhKTtjLnN0b3A9ZnVuY3Rpb24oKXtjbGVhclRpbWVvdXQoZCl9fSl9LGZ1bmN0aW9uKCl7dmFyIGEsYixjLGQsZTtiPXkuY3JlYXRlRWxlbWVudChcImRpdlwiKSxiLnNldEF0dHJpYnV0ZShcImNsYXNzTmFtZVwiLFwidFwiKSxiLmlubmVySFRNTD1cIiAgPGxpbmsvPjx0YWJsZT48L3RhYmxlPjxhIGhyZWY9Jy9hJz5hPC9hPjxpbnB1dCB0eXBlPSdjaGVja2JveCcvPlwiLGQ9Yi5nZXRFbGVtZW50c0J5VGFnTmFtZShcImFcIilbMF0sYz15LmNyZWF0ZUVsZW1lbnQoXCJzZWxlY3RcIiksZT1jLmFwcGVuZENoaWxkKHkuY3JlYXRlRWxlbWVudChcIm9wdGlvblwiKSksYT1iLmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiaW5wdXRcIilbMF0sZC5zdHlsZS5jc3NUZXh0PVwidG9wOjFweFwiLGsuZ2V0U2V0QXR0cmlidXRlPVwidFwiIT09Yi5jbGFzc05hbWUsay5zdHlsZT0vdG9wLy50ZXN0KGQuZ2V0QXR0cmlidXRlKFwic3R5bGVcIikpLGsuaHJlZk5vcm1hbGl6ZWQ9XCIvYVwiPT09ZC5nZXRBdHRyaWJ1dGUoXCJocmVmXCIpLGsuY2hlY2tPbj0hIWEudmFsdWUsay5vcHRTZWxlY3RlZD1lLnNlbGVjdGVkLGsuZW5jdHlwZT0hIXkuY3JlYXRlRWxlbWVudChcImZvcm1cIikuZW5jdHlwZSxjLmRpc2FibGVkPSEwLGsub3B0RGlzYWJsZWQ9IWUuZGlzYWJsZWQsYT15LmNyZWF0ZUVsZW1lbnQoXCJpbnB1dFwiKSxhLnNldEF0dHJpYnV0ZShcInZhbHVlXCIsXCJcIiksay5pbnB1dD1cIlwiPT09YS5nZXRBdHRyaWJ1dGUoXCJ2YWx1ZVwiKSxhLnZhbHVlPVwidFwiLGEuc2V0QXR0cmlidXRlKFwidHlwZVwiLFwicmFkaW9cIiksay5yYWRpb1ZhbHVlPVwidFwiPT09YS52YWx1ZX0oKTt2YXIgbGI9L1xcci9nO20uZm4uZXh0ZW5kKHt2YWw6ZnVuY3Rpb24oYSl7dmFyIGIsYyxkLGU9dGhpc1swXTt7aWYoYXJndW1lbnRzLmxlbmd0aClyZXR1cm4gZD1tLmlzRnVuY3Rpb24oYSksdGhpcy5lYWNoKGZ1bmN0aW9uKGMpe3ZhciBlOzE9PT10aGlzLm5vZGVUeXBlJiYoZT1kP2EuY2FsbCh0aGlzLGMsbSh0aGlzKS52YWwoKSk6YSxudWxsPT1lP2U9XCJcIjpcIm51bWJlclwiPT10eXBlb2YgZT9lKz1cIlwiOm0uaXNBcnJheShlKSYmKGU9bS5tYXAoZSxmdW5jdGlvbihhKXtyZXR1cm4gbnVsbD09YT9cIlwiOmErXCJcIn0pKSxiPW0udmFsSG9va3NbdGhpcy50eXBlXXx8bS52YWxIb29rc1t0aGlzLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCldLGImJlwic2V0XCJpbiBiJiZ2b2lkIDAhPT1iLnNldCh0aGlzLGUsXCJ2YWx1ZVwiKXx8KHRoaXMudmFsdWU9ZSkpfSk7aWYoZSlyZXR1cm4gYj1tLnZhbEhvb2tzW2UudHlwZV18fG0udmFsSG9va3NbZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpXSxiJiZcImdldFwiaW4gYiYmdm9pZCAwIT09KGM9Yi5nZXQoZSxcInZhbHVlXCIpKT9jOihjPWUudmFsdWUsXCJzdHJpbmdcIj09dHlwZW9mIGM/Yy5yZXBsYWNlKGxiLFwiXCIpOm51bGw9PWM/XCJcIjpjKX19fSksbS5leHRlbmQoe3ZhbEhvb2tzOntvcHRpb246e2dldDpmdW5jdGlvbihhKXt2YXIgYj1tLmZpbmQuYXR0cihhLFwidmFsdWVcIik7cmV0dXJuIG51bGwhPWI/YjptLnRyaW0obS50ZXh0KGEpKX19LHNlbGVjdDp7Z2V0OmZ1bmN0aW9uKGEpe2Zvcih2YXIgYixjLGQ9YS5vcHRpb25zLGU9YS5zZWxlY3RlZEluZGV4LGY9XCJzZWxlY3Qtb25lXCI9PT1hLnR5cGV8fDA+ZSxnPWY/bnVsbDpbXSxoPWY/ZSsxOmQubGVuZ3RoLGk9MD5lP2g6Zj9lOjA7aD5pO2krKylpZihjPWRbaV0sISghYy5zZWxlY3RlZCYmaSE9PWV8fChrLm9wdERpc2FibGVkP2MuZGlzYWJsZWQ6bnVsbCE9PWMuZ2V0QXR0cmlidXRlKFwiZGlzYWJsZWRcIikpfHxjLnBhcmVudE5vZGUuZGlzYWJsZWQmJm0ubm9kZU5hbWUoYy5wYXJlbnROb2RlLFwib3B0Z3JvdXBcIikpKXtpZihiPW0oYykudmFsKCksZilyZXR1cm4gYjtnLnB1c2goYil9cmV0dXJuIGd9LHNldDpmdW5jdGlvbihhLGIpe3ZhciBjLGQsZT1hLm9wdGlvbnMsZj1tLm1ha2VBcnJheShiKSxnPWUubGVuZ3RoO3doaWxlKGctLSlpZihkPWVbZ10sbS5pbkFycmF5KG0udmFsSG9va3Mub3B0aW9uLmdldChkKSxmKT49MCl0cnl7ZC5zZWxlY3RlZD1jPSEwfWNhdGNoKGgpe2Quc2Nyb2xsSGVpZ2h0fWVsc2UgZC5zZWxlY3RlZD0hMTtyZXR1cm4gY3x8KGEuc2VsZWN0ZWRJbmRleD0tMSksZX19fX0pLG0uZWFjaChbXCJyYWRpb1wiLFwiY2hlY2tib3hcIl0sZnVuY3Rpb24oKXttLnZhbEhvb2tzW3RoaXNdPXtzZXQ6ZnVuY3Rpb24oYSxiKXtyZXR1cm4gbS5pc0FycmF5KGIpP2EuY2hlY2tlZD1tLmluQXJyYXkobShhKS52YWwoKSxiKT49MDp2b2lkIDB9fSxrLmNoZWNrT258fChtLnZhbEhvb2tzW3RoaXNdLmdldD1mdW5jdGlvbihhKXtyZXR1cm4gbnVsbD09PWEuZ2V0QXR0cmlidXRlKFwidmFsdWVcIik/XCJvblwiOmEudmFsdWV9KX0pO3ZhciBtYixuYixvYj1tLmV4cHIuYXR0ckhhbmRsZSxwYj0vXig/OmNoZWNrZWR8c2VsZWN0ZWQpJC9pLHFiPWsuZ2V0U2V0QXR0cmlidXRlLHJiPWsuaW5wdXQ7bS5mbi5leHRlbmQoe2F0dHI6ZnVuY3Rpb24oYSxiKXtyZXR1cm4gVih0aGlzLG0uYXR0cixhLGIsYXJndW1lbnRzLmxlbmd0aD4xKX0scmVtb3ZlQXR0cjpmdW5jdGlvbihhKXtyZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCl7bS5yZW1vdmVBdHRyKHRoaXMsYSl9KX19KSxtLmV4dGVuZCh7YXR0cjpmdW5jdGlvbihhLGIsYyl7dmFyIGQsZSxmPWEubm9kZVR5cGU7aWYoYSYmMyE9PWYmJjghPT1mJiYyIT09ZilyZXR1cm4gdHlwZW9mIGEuZ2V0QXR0cmlidXRlPT09Sz9tLnByb3AoYSxiLGMpOigxPT09ZiYmbS5pc1hNTERvYyhhKXx8KGI9Yi50b0xvd2VyQ2FzZSgpLGQ9bS5hdHRySG9va3NbYl18fChtLmV4cHIubWF0Y2guYm9vbC50ZXN0KGIpP25iOm1iKSksdm9pZCAwPT09Yz9kJiZcImdldFwiaW4gZCYmbnVsbCE9PShlPWQuZ2V0KGEsYikpP2U6KGU9bS5maW5kLmF0dHIoYSxiKSxudWxsPT1lP3ZvaWQgMDplKTpudWxsIT09Yz9kJiZcInNldFwiaW4gZCYmdm9pZCAwIT09KGU9ZC5zZXQoYSxjLGIpKT9lOihhLnNldEF0dHJpYnV0ZShiLGMrXCJcIiksYyk6dm9pZCBtLnJlbW92ZUF0dHIoYSxiKSl9LHJlbW92ZUF0dHI6ZnVuY3Rpb24oYSxiKXt2YXIgYyxkLGU9MCxmPWImJmIubWF0Y2goRSk7aWYoZiYmMT09PWEubm9kZVR5cGUpd2hpbGUoYz1mW2UrK10pZD1tLnByb3BGaXhbY118fGMsbS5leHByLm1hdGNoLmJvb2wudGVzdChjKT9yYiYmcWJ8fCFwYi50ZXN0KGMpP2FbZF09ITE6YVttLmNhbWVsQ2FzZShcImRlZmF1bHQtXCIrYyldPWFbZF09ITE6bS5hdHRyKGEsYyxcIlwiKSxhLnJlbW92ZUF0dHJpYnV0ZShxYj9jOmQpfSxhdHRySG9va3M6e3R5cGU6e3NldDpmdW5jdGlvbihhLGIpe2lmKCFrLnJhZGlvVmFsdWUmJlwicmFkaW9cIj09PWImJm0ubm9kZU5hbWUoYSxcImlucHV0XCIpKXt2YXIgYz1hLnZhbHVlO3JldHVybiBhLnNldEF0dHJpYnV0ZShcInR5cGVcIixiKSxjJiYoYS52YWx1ZT1jKSxifX19fX0pLG5iPXtzZXQ6ZnVuY3Rpb24oYSxiLGMpe3JldHVybiBiPT09ITE/bS5yZW1vdmVBdHRyKGEsYyk6cmImJnFifHwhcGIudGVzdChjKT9hLnNldEF0dHJpYnV0ZSghcWImJm0ucHJvcEZpeFtjXXx8YyxjKTphW20uY2FtZWxDYXNlKFwiZGVmYXVsdC1cIitjKV09YVtjXT0hMCxjfX0sbS5lYWNoKG0uZXhwci5tYXRjaC5ib29sLnNvdXJjZS5tYXRjaCgvXFx3Ky9nKSxmdW5jdGlvbihhLGIpe3ZhciBjPW9iW2JdfHxtLmZpbmQuYXR0cjtvYltiXT1yYiYmcWJ8fCFwYi50ZXN0KGIpP2Z1bmN0aW9uKGEsYixkKXt2YXIgZSxmO3JldHVybiBkfHwoZj1vYltiXSxvYltiXT1lLGU9bnVsbCE9YyhhLGIsZCk/Yi50b0xvd2VyQ2FzZSgpOm51bGwsb2JbYl09ZiksZX06ZnVuY3Rpb24oYSxiLGMpe3JldHVybiBjP3ZvaWQgMDphW20uY2FtZWxDYXNlKFwiZGVmYXVsdC1cIitiKV0/Yi50b0xvd2VyQ2FzZSgpOm51bGx9fSkscmImJnFifHwobS5hdHRySG9va3MudmFsdWU9e3NldDpmdW5jdGlvbihhLGIsYyl7cmV0dXJuIG0ubm9kZU5hbWUoYSxcImlucHV0XCIpP3ZvaWQoYS5kZWZhdWx0VmFsdWU9Yik6bWImJm1iLnNldChhLGIsYyl9fSkscWJ8fChtYj17c2V0OmZ1bmN0aW9uKGEsYixjKXt2YXIgZD1hLmdldEF0dHJpYnV0ZU5vZGUoYyk7cmV0dXJuIGR8fGEuc2V0QXR0cmlidXRlTm9kZShkPWEub3duZXJEb2N1bWVudC5jcmVhdGVBdHRyaWJ1dGUoYykpLGQudmFsdWU9Yis9XCJcIixcInZhbHVlXCI9PT1jfHxiPT09YS5nZXRBdHRyaWJ1dGUoYyk/Yjp2b2lkIDB9fSxvYi5pZD1vYi5uYW1lPW9iLmNvb3Jkcz1mdW5jdGlvbihhLGIsYyl7dmFyIGQ7cmV0dXJuIGM/dm9pZCAwOihkPWEuZ2V0QXR0cmlidXRlTm9kZShiKSkmJlwiXCIhPT1kLnZhbHVlP2QudmFsdWU6bnVsbH0sbS52YWxIb29rcy5idXR0b249e2dldDpmdW5jdGlvbihhLGIpe3ZhciBjPWEuZ2V0QXR0cmlidXRlTm9kZShiKTtyZXR1cm4gYyYmYy5zcGVjaWZpZWQ/Yy52YWx1ZTp2b2lkIDB9LHNldDptYi5zZXR9LG0uYXR0ckhvb2tzLmNvbnRlbnRlZGl0YWJsZT17c2V0OmZ1bmN0aW9uKGEsYixjKXttYi5zZXQoYSxcIlwiPT09Yj8hMTpiLGMpfX0sbS5lYWNoKFtcIndpZHRoXCIsXCJoZWlnaHRcIl0sZnVuY3Rpb24oYSxiKXttLmF0dHJIb29rc1tiXT17c2V0OmZ1bmN0aW9uKGEsYyl7cmV0dXJuXCJcIj09PWM/KGEuc2V0QXR0cmlidXRlKGIsXCJhdXRvXCIpLGMpOnZvaWQgMH19fSkpLGsuc3R5bGV8fChtLmF0dHJIb29rcy5zdHlsZT17Z2V0OmZ1bmN0aW9uKGEpe3JldHVybiBhLnN0eWxlLmNzc1RleHR8fHZvaWQgMH0sc2V0OmZ1bmN0aW9uKGEsYil7cmV0dXJuIGEuc3R5bGUuY3NzVGV4dD1iK1wiXCJ9fSk7dmFyIHNiPS9eKD86aW5wdXR8c2VsZWN0fHRleHRhcmVhfGJ1dHRvbnxvYmplY3QpJC9pLHRiPS9eKD86YXxhcmVhKSQvaTttLmZuLmV4dGVuZCh7cHJvcDpmdW5jdGlvbihhLGIpe3JldHVybiBWKHRoaXMsbS5wcm9wLGEsYixhcmd1bWVudHMubGVuZ3RoPjEpfSxyZW1vdmVQcm9wOmZ1bmN0aW9uKGEpe3JldHVybiBhPW0ucHJvcEZpeFthXXx8YSx0aGlzLmVhY2goZnVuY3Rpb24oKXt0cnl7dGhpc1thXT12b2lkIDAsZGVsZXRlIHRoaXNbYV19Y2F0Y2goYil7fX0pfX0pLG0uZXh0ZW5kKHtwcm9wRml4OntcImZvclwiOlwiaHRtbEZvclwiLFwiY2xhc3NcIjpcImNsYXNzTmFtZVwifSxwcm9wOmZ1bmN0aW9uKGEsYixjKXt2YXIgZCxlLGYsZz1hLm5vZGVUeXBlO2lmKGEmJjMhPT1nJiY4IT09ZyYmMiE9PWcpcmV0dXJuIGY9MSE9PWd8fCFtLmlzWE1MRG9jKGEpLGYmJihiPW0ucHJvcEZpeFtiXXx8YixlPW0ucHJvcEhvb2tzW2JdKSx2b2lkIDAhPT1jP2UmJlwic2V0XCJpbiBlJiZ2b2lkIDAhPT0oZD1lLnNldChhLGMsYikpP2Q6YVtiXT1jOmUmJlwiZ2V0XCJpbiBlJiZudWxsIT09KGQ9ZS5nZXQoYSxiKSk/ZDphW2JdfSxwcm9wSG9va3M6e3RhYkluZGV4OntnZXQ6ZnVuY3Rpb24oYSl7dmFyIGI9bS5maW5kLmF0dHIoYSxcInRhYmluZGV4XCIpO3JldHVybiBiP3BhcnNlSW50KGIsMTApOnNiLnRlc3QoYS5ub2RlTmFtZSl8fHRiLnRlc3QoYS5ub2RlTmFtZSkmJmEuaHJlZj8wOi0xfX19fSksay5ocmVmTm9ybWFsaXplZHx8bS5lYWNoKFtcImhyZWZcIixcInNyY1wiXSxmdW5jdGlvbihhLGIpe20ucHJvcEhvb2tzW2JdPXtnZXQ6ZnVuY3Rpb24oYSl7cmV0dXJuIGEuZ2V0QXR0cmlidXRlKGIsNCl9fX0pLGsub3B0U2VsZWN0ZWR8fChtLnByb3BIb29rcy5zZWxlY3RlZD17Z2V0OmZ1bmN0aW9uKGEpe3ZhciBiPWEucGFyZW50Tm9kZTtyZXR1cm4gYiYmKGIuc2VsZWN0ZWRJbmRleCxiLnBhcmVudE5vZGUmJmIucGFyZW50Tm9kZS5zZWxlY3RlZEluZGV4KSxudWxsfX0pLG0uZWFjaChbXCJ0YWJJbmRleFwiLFwicmVhZE9ubHlcIixcIm1heExlbmd0aFwiLFwiY2VsbFNwYWNpbmdcIixcImNlbGxQYWRkaW5nXCIsXCJyb3dTcGFuXCIsXCJjb2xTcGFuXCIsXCJ1c2VNYXBcIixcImZyYW1lQm9yZGVyXCIsXCJjb250ZW50RWRpdGFibGVcIl0sZnVuY3Rpb24oKXttLnByb3BGaXhbdGhpcy50b0xvd2VyQ2FzZSgpXT10aGlzfSksay5lbmN0eXBlfHwobS5wcm9wRml4LmVuY3R5cGU9XCJlbmNvZGluZ1wiKTt2YXIgdWI9L1tcXHRcXHJcXG5cXGZdL2c7bS5mbi5leHRlbmQoe2FkZENsYXNzOmZ1bmN0aW9uKGEpe3ZhciBiLGMsZCxlLGYsZyxoPTAsaT10aGlzLmxlbmd0aCxqPVwic3RyaW5nXCI9PXR5cGVvZiBhJiZhO2lmKG0uaXNGdW5jdGlvbihhKSlyZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKGIpe20odGhpcykuYWRkQ2xhc3MoYS5jYWxsKHRoaXMsYix0aGlzLmNsYXNzTmFtZSkpfSk7aWYoailmb3IoYj0oYXx8XCJcIikubWF0Y2goRSl8fFtdO2k+aDtoKyspaWYoYz10aGlzW2hdLGQ9MT09PWMubm9kZVR5cGUmJihjLmNsYXNzTmFtZT8oXCIgXCIrYy5jbGFzc05hbWUrXCIgXCIpLnJlcGxhY2UodWIsXCIgXCIpOlwiIFwiKSl7Zj0wO3doaWxlKGU9YltmKytdKWQuaW5kZXhPZihcIiBcIitlK1wiIFwiKTwwJiYoZCs9ZStcIiBcIik7Zz1tLnRyaW0oZCksYy5jbGFzc05hbWUhPT1nJiYoYy5jbGFzc05hbWU9Zyl9cmV0dXJuIHRoaXN9LHJlbW92ZUNsYXNzOmZ1bmN0aW9uKGEpe3ZhciBiLGMsZCxlLGYsZyxoPTAsaT10aGlzLmxlbmd0aCxqPTA9PT1hcmd1bWVudHMubGVuZ3RofHxcInN0cmluZ1wiPT10eXBlb2YgYSYmYTtpZihtLmlzRnVuY3Rpb24oYSkpcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbihiKXttKHRoaXMpLnJlbW92ZUNsYXNzKGEuY2FsbCh0aGlzLGIsdGhpcy5jbGFzc05hbWUpKX0pO2lmKGopZm9yKGI9KGF8fFwiXCIpLm1hdGNoKEUpfHxbXTtpPmg7aCsrKWlmKGM9dGhpc1toXSxkPTE9PT1jLm5vZGVUeXBlJiYoYy5jbGFzc05hbWU/KFwiIFwiK2MuY2xhc3NOYW1lK1wiIFwiKS5yZXBsYWNlKHViLFwiIFwiKTpcIlwiKSl7Zj0wO3doaWxlKGU9YltmKytdKXdoaWxlKGQuaW5kZXhPZihcIiBcIitlK1wiIFwiKT49MClkPWQucmVwbGFjZShcIiBcIitlK1wiIFwiLFwiIFwiKTtnPWE/bS50cmltKGQpOlwiXCIsYy5jbGFzc05hbWUhPT1nJiYoYy5jbGFzc05hbWU9Zyl9cmV0dXJuIHRoaXN9LHRvZ2dsZUNsYXNzOmZ1bmN0aW9uKGEsYil7dmFyIGM9dHlwZW9mIGE7cmV0dXJuXCJib29sZWFuXCI9PXR5cGVvZiBiJiZcInN0cmluZ1wiPT09Yz9iP3RoaXMuYWRkQ2xhc3MoYSk6dGhpcy5yZW1vdmVDbGFzcyhhKTp0aGlzLmVhY2gobS5pc0Z1bmN0aW9uKGEpP2Z1bmN0aW9uKGMpe20odGhpcykudG9nZ2xlQ2xhc3MoYS5jYWxsKHRoaXMsYyx0aGlzLmNsYXNzTmFtZSxiKSxiKX06ZnVuY3Rpb24oKXtpZihcInN0cmluZ1wiPT09Yyl7dmFyIGIsZD0wLGU9bSh0aGlzKSxmPWEubWF0Y2goRSl8fFtdO3doaWxlKGI9ZltkKytdKWUuaGFzQ2xhc3MoYik/ZS5yZW1vdmVDbGFzcyhiKTplLmFkZENsYXNzKGIpfWVsc2UoYz09PUt8fFwiYm9vbGVhblwiPT09YykmJih0aGlzLmNsYXNzTmFtZSYmbS5fZGF0YSh0aGlzLFwiX19jbGFzc05hbWVfX1wiLHRoaXMuY2xhc3NOYW1lKSx0aGlzLmNsYXNzTmFtZT10aGlzLmNsYXNzTmFtZXx8YT09PSExP1wiXCI6bS5fZGF0YSh0aGlzLFwiX19jbGFzc05hbWVfX1wiKXx8XCJcIil9KX0saGFzQ2xhc3M6ZnVuY3Rpb24oYSl7Zm9yKHZhciBiPVwiIFwiK2ErXCIgXCIsYz0wLGQ9dGhpcy5sZW5ndGg7ZD5jO2MrKylpZigxPT09dGhpc1tjXS5ub2RlVHlwZSYmKFwiIFwiK3RoaXNbY10uY2xhc3NOYW1lK1wiIFwiKS5yZXBsYWNlKHViLFwiIFwiKS5pbmRleE9mKGIpPj0wKXJldHVybiEwO3JldHVybiExfX0pLG0uZWFjaChcImJsdXIgZm9jdXMgZm9jdXNpbiBmb2N1c291dCBsb2FkIHJlc2l6ZSBzY3JvbGwgdW5sb2FkIGNsaWNrIGRibGNsaWNrIG1vdXNlZG93biBtb3VzZXVwIG1vdXNlbW92ZSBtb3VzZW92ZXIgbW91c2VvdXQgbW91c2VlbnRlciBtb3VzZWxlYXZlIGNoYW5nZSBzZWxlY3Qgc3VibWl0IGtleWRvd24ga2V5cHJlc3Mga2V5dXAgZXJyb3IgY29udGV4dG1lbnVcIi5zcGxpdChcIiBcIiksZnVuY3Rpb24oYSxiKXttLmZuW2JdPWZ1bmN0aW9uKGEsYyl7cmV0dXJuIGFyZ3VtZW50cy5sZW5ndGg+MD90aGlzLm9uKGIsbnVsbCxhLGMpOnRoaXMudHJpZ2dlcihiKX19KSxtLmZuLmV4dGVuZCh7aG92ZXI6ZnVuY3Rpb24oYSxiKXtyZXR1cm4gdGhpcy5tb3VzZWVudGVyKGEpLm1vdXNlbGVhdmUoYnx8YSl9LGJpbmQ6ZnVuY3Rpb24oYSxiLGMpe3JldHVybiB0aGlzLm9uKGEsbnVsbCxiLGMpfSx1bmJpbmQ6ZnVuY3Rpb24oYSxiKXtyZXR1cm4gdGhpcy5vZmYoYSxudWxsLGIpfSxkZWxlZ2F0ZTpmdW5jdGlvbihhLGIsYyxkKXtyZXR1cm4gdGhpcy5vbihiLGEsYyxkKX0sdW5kZWxlZ2F0ZTpmdW5jdGlvbihhLGIsYyl7cmV0dXJuIDE9PT1hcmd1bWVudHMubGVuZ3RoP3RoaXMub2ZmKGEsXCIqKlwiKTp0aGlzLm9mZihiLGF8fFwiKipcIixjKX19KTt2YXIgdmI9bS5ub3coKSx3Yj0vXFw/Lyx4Yj0vKCwpfChcXFt8eyl8KH18XSl8XCIoPzpbXlwiXFxcXFxcclxcbl18XFxcXFtcIlxcXFxcXC9iZm5ydF18XFxcXHVbXFxkYS1mQS1GXXs0fSkqXCJcXHMqOj98dHJ1ZXxmYWxzZXxudWxsfC0/KD8hMFxcZClcXGQrKD86XFwuXFxkK3wpKD86W2VFXVsrLV0/XFxkK3wpL2c7bS5wYXJzZUpTT049ZnVuY3Rpb24oYil7aWYoYS5KU09OJiZhLkpTT04ucGFyc2UpcmV0dXJuIGEuSlNPTi5wYXJzZShiK1wiXCIpO3ZhciBjLGQ9bnVsbCxlPW0udHJpbShiK1wiXCIpO3JldHVybiBlJiYhbS50cmltKGUucmVwbGFjZSh4YixmdW5jdGlvbihhLGIsZSxmKXtyZXR1cm4gYyYmYiYmKGQ9MCksMD09PWQ/YTooYz1lfHxiLGQrPSFmLSFlLFwiXCIpfSkpP0Z1bmN0aW9uKFwicmV0dXJuIFwiK2UpKCk6bS5lcnJvcihcIkludmFsaWQgSlNPTjogXCIrYil9LG0ucGFyc2VYTUw9ZnVuY3Rpb24oYil7dmFyIGMsZDtpZighYnx8XCJzdHJpbmdcIiE9dHlwZW9mIGIpcmV0dXJuIG51bGw7dHJ5e2EuRE9NUGFyc2VyPyhkPW5ldyBET01QYXJzZXIsYz1kLnBhcnNlRnJvbVN0cmluZyhiLFwidGV4dC94bWxcIikpOihjPW5ldyBBY3RpdmVYT2JqZWN0KFwiTWljcm9zb2Z0LlhNTERPTVwiKSxjLmFzeW5jPVwiZmFsc2VcIixjLmxvYWRYTUwoYikpfWNhdGNoKGUpe2M9dm9pZCAwfXJldHVybiBjJiZjLmRvY3VtZW50RWxlbWVudCYmIWMuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJwYXJzZXJlcnJvclwiKS5sZW5ndGh8fG0uZXJyb3IoXCJJbnZhbGlkIFhNTDogXCIrYiksY307dmFyIHliLHpiLEFiPS8jLiokLyxCYj0vKFs/Jl0pXz1bXiZdKi8sQ2I9L14oLio/KTpbIFxcdF0qKFteXFxyXFxuXSopXFxyPyQvZ20sRGI9L14oPzphYm91dHxhcHB8YXBwLXN0b3JhZ2V8ListZXh0ZW5zaW9ufGZpbGV8cmVzfHdpZGdldCk6JC8sRWI9L14oPzpHRVR8SEVBRCkkLyxGYj0vXlxcL1xcLy8sR2I9L14oW1xcdy4rLV0rOikoPzpcXC9cXC8oPzpbXlxcLz8jXSpAfCkoW15cXC8/IzpdKikoPzo6KFxcZCspfCl8KS8sSGI9e30sSWI9e30sSmI9XCIqL1wiLmNvbmNhdChcIipcIik7dHJ5e3piPWxvY2F0aW9uLmhyZWZ9Y2F0Y2goS2Ipe3piPXkuY3JlYXRlRWxlbWVudChcImFcIiksemIuaHJlZj1cIlwiLHpiPXpiLmhyZWZ9eWI9R2IuZXhlYyh6Yi50b0xvd2VyQ2FzZSgpKXx8W107ZnVuY3Rpb24gTGIoYSl7cmV0dXJuIGZ1bmN0aW9uKGIsYyl7XCJzdHJpbmdcIiE9dHlwZW9mIGImJihjPWIsYj1cIipcIik7dmFyIGQsZT0wLGY9Yi50b0xvd2VyQ2FzZSgpLm1hdGNoKEUpfHxbXTtpZihtLmlzRnVuY3Rpb24oYykpd2hpbGUoZD1mW2UrK10pXCIrXCI9PT1kLmNoYXJBdCgwKT8oZD1kLnNsaWNlKDEpfHxcIipcIiwoYVtkXT1hW2RdfHxbXSkudW5zaGlmdChjKSk6KGFbZF09YVtkXXx8W10pLnB1c2goYyl9fWZ1bmN0aW9uIE1iKGEsYixjLGQpe3ZhciBlPXt9LGY9YT09PUliO2Z1bmN0aW9uIGcoaCl7dmFyIGk7cmV0dXJuIGVbaF09ITAsbS5lYWNoKGFbaF18fFtdLGZ1bmN0aW9uKGEsaCl7dmFyIGo9aChiLGMsZCk7cmV0dXJuXCJzdHJpbmdcIiE9dHlwZW9mIGp8fGZ8fGVbal0/Zj8hKGk9aik6dm9pZCAwOihiLmRhdGFUeXBlcy51bnNoaWZ0KGopLGcoaiksITEpfSksaX1yZXR1cm4gZyhiLmRhdGFUeXBlc1swXSl8fCFlW1wiKlwiXSYmZyhcIipcIil9ZnVuY3Rpb24gTmIoYSxiKXt2YXIgYyxkLGU9bS5hamF4U2V0dGluZ3MuZmxhdE9wdGlvbnN8fHt9O2ZvcihkIGluIGIpdm9pZCAwIT09YltkXSYmKChlW2RdP2E6Y3x8KGM9e30pKVtkXT1iW2RdKTtyZXR1cm4gYyYmbS5leHRlbmQoITAsYSxjKSxhfWZ1bmN0aW9uIE9iKGEsYixjKXt2YXIgZCxlLGYsZyxoPWEuY29udGVudHMsaT1hLmRhdGFUeXBlczt3aGlsZShcIipcIj09PWlbMF0paS5zaGlmdCgpLHZvaWQgMD09PWUmJihlPWEubWltZVR5cGV8fGIuZ2V0UmVzcG9uc2VIZWFkZXIoXCJDb250ZW50LVR5cGVcIikpO2lmKGUpZm9yKGcgaW4gaClpZihoW2ddJiZoW2ddLnRlc3QoZSkpe2kudW5zaGlmdChnKTticmVha31pZihpWzBdaW4gYylmPWlbMF07ZWxzZXtmb3IoZyBpbiBjKXtpZighaVswXXx8YS5jb252ZXJ0ZXJzW2crXCIgXCIraVswXV0pe2Y9ZzticmVha31kfHwoZD1nKX1mPWZ8fGR9cmV0dXJuIGY/KGYhPT1pWzBdJiZpLnVuc2hpZnQoZiksY1tmXSk6dm9pZCAwfWZ1bmN0aW9uIFBiKGEsYixjLGQpe3ZhciBlLGYsZyxoLGksaj17fSxrPWEuZGF0YVR5cGVzLnNsaWNlKCk7aWYoa1sxXSlmb3IoZyBpbiBhLmNvbnZlcnRlcnMpaltnLnRvTG93ZXJDYXNlKCldPWEuY29udmVydGVyc1tnXTtmPWsuc2hpZnQoKTt3aGlsZShmKWlmKGEucmVzcG9uc2VGaWVsZHNbZl0mJihjW2EucmVzcG9uc2VGaWVsZHNbZl1dPWIpLCFpJiZkJiZhLmRhdGFGaWx0ZXImJihiPWEuZGF0YUZpbHRlcihiLGEuZGF0YVR5cGUpKSxpPWYsZj1rLnNoaWZ0KCkpaWYoXCIqXCI9PT1mKWY9aTtlbHNlIGlmKFwiKlwiIT09aSYmaSE9PWYpe2lmKGc9altpK1wiIFwiK2ZdfHxqW1wiKiBcIitmXSwhZylmb3IoZSBpbiBqKWlmKGg9ZS5zcGxpdChcIiBcIiksaFsxXT09PWYmJihnPWpbaStcIiBcIitoWzBdXXx8altcIiogXCIraFswXV0pKXtnPT09ITA/Zz1qW2VdOmpbZV0hPT0hMCYmKGY9aFswXSxrLnVuc2hpZnQoaFsxXSkpO2JyZWFrfWlmKGchPT0hMClpZihnJiZhW1widGhyb3dzXCJdKWI9ZyhiKTtlbHNlIHRyeXtiPWcoYil9Y2F0Y2gobCl7cmV0dXJue3N0YXRlOlwicGFyc2VyZXJyb3JcIixlcnJvcjpnP2w6XCJObyBjb252ZXJzaW9uIGZyb20gXCIraStcIiB0byBcIitmfX19cmV0dXJue3N0YXRlOlwic3VjY2Vzc1wiLGRhdGE6Yn19bS5leHRlbmQoe2FjdGl2ZTowLGxhc3RNb2RpZmllZDp7fSxldGFnOnt9LGFqYXhTZXR0aW5nczp7dXJsOnpiLHR5cGU6XCJHRVRcIixpc0xvY2FsOkRiLnRlc3QoeWJbMV0pLGdsb2JhbDohMCxwcm9jZXNzRGF0YTohMCxhc3luYzohMCxjb250ZW50VHlwZTpcImFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZDsgY2hhcnNldD1VVEYtOFwiLGFjY2VwdHM6e1wiKlwiOkpiLHRleHQ6XCJ0ZXh0L3BsYWluXCIsaHRtbDpcInRleHQvaHRtbFwiLHhtbDpcImFwcGxpY2F0aW9uL3htbCwgdGV4dC94bWxcIixqc29uOlwiYXBwbGljYXRpb24vanNvbiwgdGV4dC9qYXZhc2NyaXB0XCJ9LGNvbnRlbnRzOnt4bWw6L3htbC8saHRtbDovaHRtbC8sanNvbjovanNvbi99LHJlc3BvbnNlRmllbGRzOnt4bWw6XCJyZXNwb25zZVhNTFwiLHRleHQ6XCJyZXNwb25zZVRleHRcIixqc29uOlwicmVzcG9uc2VKU09OXCJ9LGNvbnZlcnRlcnM6e1wiKiB0ZXh0XCI6U3RyaW5nLFwidGV4dCBodG1sXCI6ITAsXCJ0ZXh0IGpzb25cIjptLnBhcnNlSlNPTixcInRleHQgeG1sXCI6bS5wYXJzZVhNTH0sZmxhdE9wdGlvbnM6e3VybDohMCxjb250ZXh0OiEwfX0sYWpheFNldHVwOmZ1bmN0aW9uKGEsYil7cmV0dXJuIGI/TmIoTmIoYSxtLmFqYXhTZXR0aW5ncyksYik6TmIobS5hamF4U2V0dGluZ3MsYSl9LGFqYXhQcmVmaWx0ZXI6TGIoSGIpLGFqYXhUcmFuc3BvcnQ6TGIoSWIpLGFqYXg6ZnVuY3Rpb24oYSxiKXtcIm9iamVjdFwiPT10eXBlb2YgYSYmKGI9YSxhPXZvaWQgMCksYj1ifHx7fTt2YXIgYyxkLGUsZixnLGgsaSxqLGs9bS5hamF4U2V0dXAoe30sYiksbD1rLmNvbnRleHR8fGssbj1rLmNvbnRleHQmJihsLm5vZGVUeXBlfHxsLmpxdWVyeSk/bShsKTptLmV2ZW50LG89bS5EZWZlcnJlZCgpLHA9bS5DYWxsYmFja3MoXCJvbmNlIG1lbW9yeVwiKSxxPWsuc3RhdHVzQ29kZXx8e30scj17fSxzPXt9LHQ9MCx1PVwiY2FuY2VsZWRcIix2PXtyZWFkeVN0YXRlOjAsZ2V0UmVzcG9uc2VIZWFkZXI6ZnVuY3Rpb24oYSl7dmFyIGI7aWYoMj09PXQpe2lmKCFqKXtqPXt9O3doaWxlKGI9Q2IuZXhlYyhmKSlqW2JbMV0udG9Mb3dlckNhc2UoKV09YlsyXX1iPWpbYS50b0xvd2VyQ2FzZSgpXX1yZXR1cm4gbnVsbD09Yj9udWxsOmJ9LGdldEFsbFJlc3BvbnNlSGVhZGVyczpmdW5jdGlvbigpe3JldHVybiAyPT09dD9mOm51bGx9LHNldFJlcXVlc3RIZWFkZXI6ZnVuY3Rpb24oYSxiKXt2YXIgYz1hLnRvTG93ZXJDYXNlKCk7cmV0dXJuIHR8fChhPXNbY109c1tjXXx8YSxyW2FdPWIpLHRoaXN9LG92ZXJyaWRlTWltZVR5cGU6ZnVuY3Rpb24oYSl7cmV0dXJuIHR8fChrLm1pbWVUeXBlPWEpLHRoaXN9LHN0YXR1c0NvZGU6ZnVuY3Rpb24oYSl7dmFyIGI7aWYoYSlpZigyPnQpZm9yKGIgaW4gYSlxW2JdPVtxW2JdLGFbYl1dO2Vsc2Ugdi5hbHdheXMoYVt2LnN0YXR1c10pO3JldHVybiB0aGlzfSxhYm9ydDpmdW5jdGlvbihhKXt2YXIgYj1hfHx1O3JldHVybiBpJiZpLmFib3J0KGIpLHgoMCxiKSx0aGlzfX07aWYoby5wcm9taXNlKHYpLmNvbXBsZXRlPXAuYWRkLHYuc3VjY2Vzcz12LmRvbmUsdi5lcnJvcj12LmZhaWwsay51cmw9KChhfHxrLnVybHx8emIpK1wiXCIpLnJlcGxhY2UoQWIsXCJcIikucmVwbGFjZShGYix5YlsxXStcIi8vXCIpLGsudHlwZT1iLm1ldGhvZHx8Yi50eXBlfHxrLm1ldGhvZHx8ay50eXBlLGsuZGF0YVR5cGVzPW0udHJpbShrLmRhdGFUeXBlfHxcIipcIikudG9Mb3dlckNhc2UoKS5tYXRjaChFKXx8W1wiXCJdLG51bGw9PWsuY3Jvc3NEb21haW4mJihjPUdiLmV4ZWMoay51cmwudG9Mb3dlckNhc2UoKSksay5jcm9zc0RvbWFpbj0hKCFjfHxjWzFdPT09eWJbMV0mJmNbMl09PT15YlsyXSYmKGNbM118fChcImh0dHA6XCI9PT1jWzFdP1wiODBcIjpcIjQ0M1wiKSk9PT0oeWJbM118fChcImh0dHA6XCI9PT15YlsxXT9cIjgwXCI6XCI0NDNcIikpKSksay5kYXRhJiZrLnByb2Nlc3NEYXRhJiZcInN0cmluZ1wiIT10eXBlb2Ygay5kYXRhJiYoay5kYXRhPW0ucGFyYW0oay5kYXRhLGsudHJhZGl0aW9uYWwpKSxNYihIYixrLGIsdiksMj09PXQpcmV0dXJuIHY7aD1tLmV2ZW50JiZrLmdsb2JhbCxoJiYwPT09bS5hY3RpdmUrKyYmbS5ldmVudC50cmlnZ2VyKFwiYWpheFN0YXJ0XCIpLGsudHlwZT1rLnR5cGUudG9VcHBlckNhc2UoKSxrLmhhc0NvbnRlbnQ9IUViLnRlc3Qoay50eXBlKSxlPWsudXJsLGsuaGFzQ29udGVudHx8KGsuZGF0YSYmKGU9ay51cmwrPSh3Yi50ZXN0KGUpP1wiJlwiOlwiP1wiKStrLmRhdGEsZGVsZXRlIGsuZGF0YSksay5jYWNoZT09PSExJiYoay51cmw9QmIudGVzdChlKT9lLnJlcGxhY2UoQmIsXCIkMV89XCIrdmIrKyk6ZSsod2IudGVzdChlKT9cIiZcIjpcIj9cIikrXCJfPVwiK3ZiKyspKSxrLmlmTW9kaWZpZWQmJihtLmxhc3RNb2RpZmllZFtlXSYmdi5zZXRSZXF1ZXN0SGVhZGVyKFwiSWYtTW9kaWZpZWQtU2luY2VcIixtLmxhc3RNb2RpZmllZFtlXSksbS5ldGFnW2VdJiZ2LnNldFJlcXVlc3RIZWFkZXIoXCJJZi1Ob25lLU1hdGNoXCIsbS5ldGFnW2VdKSksKGsuZGF0YSYmay5oYXNDb250ZW50JiZrLmNvbnRlbnRUeXBlIT09ITF8fGIuY29udGVudFR5cGUpJiZ2LnNldFJlcXVlc3RIZWFkZXIoXCJDb250ZW50LVR5cGVcIixrLmNvbnRlbnRUeXBlKSx2LnNldFJlcXVlc3RIZWFkZXIoXCJBY2NlcHRcIixrLmRhdGFUeXBlc1swXSYmay5hY2NlcHRzW2suZGF0YVR5cGVzWzBdXT9rLmFjY2VwdHNbay5kYXRhVHlwZXNbMF1dKyhcIipcIiE9PWsuZGF0YVR5cGVzWzBdP1wiLCBcIitKYitcIjsgcT0wLjAxXCI6XCJcIik6ay5hY2NlcHRzW1wiKlwiXSk7Zm9yKGQgaW4gay5oZWFkZXJzKXYuc2V0UmVxdWVzdEhlYWRlcihkLGsuaGVhZGVyc1tkXSk7aWYoay5iZWZvcmVTZW5kJiYoay5iZWZvcmVTZW5kLmNhbGwobCx2LGspPT09ITF8fDI9PT10KSlyZXR1cm4gdi5hYm9ydCgpO3U9XCJhYm9ydFwiO2ZvcihkIGlue3N1Y2Nlc3M6MSxlcnJvcjoxLGNvbXBsZXRlOjF9KXZbZF0oa1tkXSk7aWYoaT1NYihJYixrLGIsdikpe3YucmVhZHlTdGF0ZT0xLGgmJm4udHJpZ2dlcihcImFqYXhTZW5kXCIsW3Ysa10pLGsuYXN5bmMmJmsudGltZW91dD4wJiYoZz1zZXRUaW1lb3V0KGZ1bmN0aW9uKCl7di5hYm9ydChcInRpbWVvdXRcIil9LGsudGltZW91dCkpO3RyeXt0PTEsaS5zZW5kKHIseCl9Y2F0Y2godyl7aWYoISgyPnQpKXRocm93IHc7eCgtMSx3KX19ZWxzZSB4KC0xLFwiTm8gVHJhbnNwb3J0XCIpO2Z1bmN0aW9uIHgoYSxiLGMsZCl7dmFyIGoscixzLHUsdyx4PWI7MiE9PXQmJih0PTIsZyYmY2xlYXJUaW1lb3V0KGcpLGk9dm9pZCAwLGY9ZHx8XCJcIix2LnJlYWR5U3RhdGU9YT4wPzQ6MCxqPWE+PTIwMCYmMzAwPmF8fDMwND09PWEsYyYmKHU9T2Ioayx2LGMpKSx1PVBiKGssdSx2LGopLGo/KGsuaWZNb2RpZmllZCYmKHc9di5nZXRSZXNwb25zZUhlYWRlcihcIkxhc3QtTW9kaWZpZWRcIiksdyYmKG0ubGFzdE1vZGlmaWVkW2VdPXcpLHc9di5nZXRSZXNwb25zZUhlYWRlcihcImV0YWdcIiksdyYmKG0uZXRhZ1tlXT13KSksMjA0PT09YXx8XCJIRUFEXCI9PT1rLnR5cGU/eD1cIm5vY29udGVudFwiOjMwND09PWE/eD1cIm5vdG1vZGlmaWVkXCI6KHg9dS5zdGF0ZSxyPXUuZGF0YSxzPXUuZXJyb3Isaj0hcykpOihzPXgsKGF8fCF4KSYmKHg9XCJlcnJvclwiLDA+YSYmKGE9MCkpKSx2LnN0YXR1cz1hLHYuc3RhdHVzVGV4dD0oYnx8eCkrXCJcIixqP28ucmVzb2x2ZVdpdGgobCxbcix4LHZdKTpvLnJlamVjdFdpdGgobCxbdix4LHNdKSx2LnN0YXR1c0NvZGUocSkscT12b2lkIDAsaCYmbi50cmlnZ2VyKGo/XCJhamF4U3VjY2Vzc1wiOlwiYWpheEVycm9yXCIsW3YsayxqP3I6c10pLHAuZmlyZVdpdGgobCxbdix4XSksaCYmKG4udHJpZ2dlcihcImFqYXhDb21wbGV0ZVwiLFt2LGtdKSwtLW0uYWN0aXZlfHxtLmV2ZW50LnRyaWdnZXIoXCJhamF4U3RvcFwiKSkpfXJldHVybiB2fSxnZXRKU09OOmZ1bmN0aW9uKGEsYixjKXtyZXR1cm4gbS5nZXQoYSxiLGMsXCJqc29uXCIpfSxnZXRTY3JpcHQ6ZnVuY3Rpb24oYSxiKXtyZXR1cm4gbS5nZXQoYSx2b2lkIDAsYixcInNjcmlwdFwiKX19KSxtLmVhY2goW1wiZ2V0XCIsXCJwb3N0XCJdLGZ1bmN0aW9uKGEsYil7bVtiXT1mdW5jdGlvbihhLGMsZCxlKXtyZXR1cm4gbS5pc0Z1bmN0aW9uKGMpJiYoZT1lfHxkLGQ9YyxjPXZvaWQgMCksbS5hamF4KHt1cmw6YSx0eXBlOmIsZGF0YVR5cGU6ZSxkYXRhOmMsc3VjY2VzczpkfSl9fSksbS5fZXZhbFVybD1mdW5jdGlvbihhKXtyZXR1cm4gbS5hamF4KHt1cmw6YSx0eXBlOlwiR0VUXCIsZGF0YVR5cGU6XCJzY3JpcHRcIixhc3luYzohMSxnbG9iYWw6ITEsXCJ0aHJvd3NcIjohMH0pfSxtLmZuLmV4dGVuZCh7d3JhcEFsbDpmdW5jdGlvbihhKXtpZihtLmlzRnVuY3Rpb24oYSkpcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbihiKXttKHRoaXMpLndyYXBBbGwoYS5jYWxsKHRoaXMsYikpfSk7aWYodGhpc1swXSl7dmFyIGI9bShhLHRoaXNbMF0ub3duZXJEb2N1bWVudCkuZXEoMCkuY2xvbmUoITApO3RoaXNbMF0ucGFyZW50Tm9kZSYmYi5pbnNlcnRCZWZvcmUodGhpc1swXSksYi5tYXAoZnVuY3Rpb24oKXt2YXIgYT10aGlzO3doaWxlKGEuZmlyc3RDaGlsZCYmMT09PWEuZmlyc3RDaGlsZC5ub2RlVHlwZSlhPWEuZmlyc3RDaGlsZDtyZXR1cm4gYX0pLmFwcGVuZCh0aGlzKX1yZXR1cm4gdGhpc30sd3JhcElubmVyOmZ1bmN0aW9uKGEpe3JldHVybiB0aGlzLmVhY2gobS5pc0Z1bmN0aW9uKGEpP2Z1bmN0aW9uKGIpe20odGhpcykud3JhcElubmVyKGEuY2FsbCh0aGlzLGIpKX06ZnVuY3Rpb24oKXt2YXIgYj1tKHRoaXMpLGM9Yi5jb250ZW50cygpO2MubGVuZ3RoP2Mud3JhcEFsbChhKTpiLmFwcGVuZChhKX0pfSx3cmFwOmZ1bmN0aW9uKGEpe3ZhciBiPW0uaXNGdW5jdGlvbihhKTtyZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKGMpe20odGhpcykud3JhcEFsbChiP2EuY2FsbCh0aGlzLGMpOmEpfSl9LHVud3JhcDpmdW5jdGlvbigpe3JldHVybiB0aGlzLnBhcmVudCgpLmVhY2goZnVuY3Rpb24oKXttLm5vZGVOYW1lKHRoaXMsXCJib2R5XCIpfHxtKHRoaXMpLnJlcGxhY2VXaXRoKHRoaXMuY2hpbGROb2Rlcyl9KS5lbmQoKX19KSxtLmV4cHIuZmlsdGVycy5oaWRkZW49ZnVuY3Rpb24oYSl7cmV0dXJuIGEub2Zmc2V0V2lkdGg8PTAmJmEub2Zmc2V0SGVpZ2h0PD0wfHwhay5yZWxpYWJsZUhpZGRlbk9mZnNldHMoKSYmXCJub25lXCI9PT0oYS5zdHlsZSYmYS5zdHlsZS5kaXNwbGF5fHxtLmNzcyhhLFwiZGlzcGxheVwiKSl9LG0uZXhwci5maWx0ZXJzLnZpc2libGU9ZnVuY3Rpb24oYSl7cmV0dXJuIW0uZXhwci5maWx0ZXJzLmhpZGRlbihhKX07dmFyIFFiPS8lMjAvZyxSYj0vXFxbXFxdJC8sU2I9L1xccj9cXG4vZyxUYj0vXig/OnN1Ym1pdHxidXR0b258aW1hZ2V8cmVzZXR8ZmlsZSkkL2ksVWI9L14oPzppbnB1dHxzZWxlY3R8dGV4dGFyZWF8a2V5Z2VuKS9pO2Z1bmN0aW9uIFZiKGEsYixjLGQpe3ZhciBlO2lmKG0uaXNBcnJheShiKSltLmVhY2goYixmdW5jdGlvbihiLGUpe2N8fFJiLnRlc3QoYSk/ZChhLGUpOlZiKGErXCJbXCIrKFwib2JqZWN0XCI9PXR5cGVvZiBlP2I6XCJcIikrXCJdXCIsZSxjLGQpfSk7ZWxzZSBpZihjfHxcIm9iamVjdFwiIT09bS50eXBlKGIpKWQoYSxiKTtlbHNlIGZvcihlIGluIGIpVmIoYStcIltcIitlK1wiXVwiLGJbZV0sYyxkKX1tLnBhcmFtPWZ1bmN0aW9uKGEsYil7dmFyIGMsZD1bXSxlPWZ1bmN0aW9uKGEsYil7Yj1tLmlzRnVuY3Rpb24oYik/YigpOm51bGw9PWI/XCJcIjpiLGRbZC5sZW5ndGhdPWVuY29kZVVSSUNvbXBvbmVudChhKStcIj1cIitlbmNvZGVVUklDb21wb25lbnQoYil9O2lmKHZvaWQgMD09PWImJihiPW0uYWpheFNldHRpbmdzJiZtLmFqYXhTZXR0aW5ncy50cmFkaXRpb25hbCksbS5pc0FycmF5KGEpfHxhLmpxdWVyeSYmIW0uaXNQbGFpbk9iamVjdChhKSltLmVhY2goYSxmdW5jdGlvbigpe2UodGhpcy5uYW1lLHRoaXMudmFsdWUpfSk7ZWxzZSBmb3IoYyBpbiBhKVZiKGMsYVtjXSxiLGUpO3JldHVybiBkLmpvaW4oXCImXCIpLnJlcGxhY2UoUWIsXCIrXCIpfSxtLmZuLmV4dGVuZCh7c2VyaWFsaXplOmZ1bmN0aW9uKCl7cmV0dXJuIG0ucGFyYW0odGhpcy5zZXJpYWxpemVBcnJheSgpKX0sc2VyaWFsaXplQXJyYXk6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5tYXAoZnVuY3Rpb24oKXt2YXIgYT1tLnByb3AodGhpcyxcImVsZW1lbnRzXCIpO3JldHVybiBhP20ubWFrZUFycmF5KGEpOnRoaXN9KS5maWx0ZXIoZnVuY3Rpb24oKXt2YXIgYT10aGlzLnR5cGU7cmV0dXJuIHRoaXMubmFtZSYmIW0odGhpcykuaXMoXCI6ZGlzYWJsZWRcIikmJlViLnRlc3QodGhpcy5ub2RlTmFtZSkmJiFUYi50ZXN0KGEpJiYodGhpcy5jaGVja2VkfHwhVy50ZXN0KGEpKX0pLm1hcChmdW5jdGlvbihhLGIpe3ZhciBjPW0odGhpcykudmFsKCk7cmV0dXJuIG51bGw9PWM/bnVsbDptLmlzQXJyYXkoYyk/bS5tYXAoYyxmdW5jdGlvbihhKXtyZXR1cm57bmFtZTpiLm5hbWUsdmFsdWU6YS5yZXBsYWNlKFNiLFwiXFxyXFxuXCIpfX0pOntuYW1lOmIubmFtZSx2YWx1ZTpjLnJlcGxhY2UoU2IsXCJcXHJcXG5cIil9fSkuZ2V0KCl9fSksbS5hamF4U2V0dGluZ3MueGhyPXZvaWQgMCE9PWEuQWN0aXZlWE9iamVjdD9mdW5jdGlvbigpe3JldHVybiF0aGlzLmlzTG9jYWwmJi9eKGdldHxwb3N0fGhlYWR8cHV0fGRlbGV0ZXxvcHRpb25zKSQvaS50ZXN0KHRoaXMudHlwZSkmJlpiKCl8fCRiKCl9OlpiO3ZhciBXYj0wLFhiPXt9LFliPW0uYWpheFNldHRpbmdzLnhocigpO2EuYXR0YWNoRXZlbnQmJmEuYXR0YWNoRXZlbnQoXCJvbnVubG9hZFwiLGZ1bmN0aW9uKCl7Zm9yKHZhciBhIGluIFhiKVhiW2FdKHZvaWQgMCwhMCl9KSxrLmNvcnM9ISFZYiYmXCJ3aXRoQ3JlZGVudGlhbHNcImluIFliLFliPWsuYWpheD0hIVliLFliJiZtLmFqYXhUcmFuc3BvcnQoZnVuY3Rpb24oYSl7aWYoIWEuY3Jvc3NEb21haW58fGsuY29ycyl7dmFyIGI7cmV0dXJue3NlbmQ6ZnVuY3Rpb24oYyxkKXt2YXIgZSxmPWEueGhyKCksZz0rK1diO2lmKGYub3BlbihhLnR5cGUsYS51cmwsYS5hc3luYyxhLnVzZXJuYW1lLGEucGFzc3dvcmQpLGEueGhyRmllbGRzKWZvcihlIGluIGEueGhyRmllbGRzKWZbZV09YS54aHJGaWVsZHNbZV07YS5taW1lVHlwZSYmZi5vdmVycmlkZU1pbWVUeXBlJiZmLm92ZXJyaWRlTWltZVR5cGUoYS5taW1lVHlwZSksYS5jcm9zc0RvbWFpbnx8Y1tcIlgtUmVxdWVzdGVkLVdpdGhcIl18fChjW1wiWC1SZXF1ZXN0ZWQtV2l0aFwiXT1cIlhNTEh0dHBSZXF1ZXN0XCIpO2ZvcihlIGluIGMpdm9pZCAwIT09Y1tlXSYmZi5zZXRSZXF1ZXN0SGVhZGVyKGUsY1tlXStcIlwiKTtmLnNlbmQoYS5oYXNDb250ZW50JiZhLmRhdGF8fG51bGwpLGI9ZnVuY3Rpb24oYyxlKXt2YXIgaCxpLGo7aWYoYiYmKGV8fDQ9PT1mLnJlYWR5U3RhdGUpKWlmKGRlbGV0ZSBYYltnXSxiPXZvaWQgMCxmLm9ucmVhZHlzdGF0ZWNoYW5nZT1tLm5vb3AsZSk0IT09Zi5yZWFkeVN0YXRlJiZmLmFib3J0KCk7ZWxzZXtqPXt9LGg9Zi5zdGF0dXMsXCJzdHJpbmdcIj09dHlwZW9mIGYucmVzcG9uc2VUZXh0JiYoai50ZXh0PWYucmVzcG9uc2VUZXh0KTt0cnl7aT1mLnN0YXR1c1RleHR9Y2F0Y2goayl7aT1cIlwifWh8fCFhLmlzTG9jYWx8fGEuY3Jvc3NEb21haW4/MTIyMz09PWgmJihoPTIwNCk6aD1qLnRleHQ/MjAwOjQwNH1qJiZkKGgsaSxqLGYuZ2V0QWxsUmVzcG9uc2VIZWFkZXJzKCkpfSxhLmFzeW5jPzQ9PT1mLnJlYWR5U3RhdGU/c2V0VGltZW91dChiKTpmLm9ucmVhZHlzdGF0ZWNoYW5nZT1YYltnXT1iOmIoKX0sYWJvcnQ6ZnVuY3Rpb24oKXtiJiZiKHZvaWQgMCwhMCl9fX19KTtmdW5jdGlvbiBaYigpe3RyeXtyZXR1cm4gbmV3IGEuWE1MSHR0cFJlcXVlc3R9Y2F0Y2goYil7fX1mdW5jdGlvbiAkYigpe3RyeXtyZXR1cm4gbmV3IGEuQWN0aXZlWE9iamVjdChcIk1pY3Jvc29mdC5YTUxIVFRQXCIpfWNhdGNoKGIpe319bS5hamF4U2V0dXAoe2FjY2VwdHM6e3NjcmlwdDpcInRleHQvamF2YXNjcmlwdCwgYXBwbGljYXRpb24vamF2YXNjcmlwdCwgYXBwbGljYXRpb24vZWNtYXNjcmlwdCwgYXBwbGljYXRpb24veC1lY21hc2NyaXB0XCJ9LGNvbnRlbnRzOntzY3JpcHQ6Lyg/OmphdmF8ZWNtYSlzY3JpcHQvfSxjb252ZXJ0ZXJzOntcInRleHQgc2NyaXB0XCI6ZnVuY3Rpb24oYSl7cmV0dXJuIG0uZ2xvYmFsRXZhbChhKSxhfX19KSxtLmFqYXhQcmVmaWx0ZXIoXCJzY3JpcHRcIixmdW5jdGlvbihhKXt2b2lkIDA9PT1hLmNhY2hlJiYoYS5jYWNoZT0hMSksYS5jcm9zc0RvbWFpbiYmKGEudHlwZT1cIkdFVFwiLGEuZ2xvYmFsPSExKX0pLG0uYWpheFRyYW5zcG9ydChcInNjcmlwdFwiLGZ1bmN0aW9uKGEpe2lmKGEuY3Jvc3NEb21haW4pe3ZhciBiLGM9eS5oZWFkfHxtKFwiaGVhZFwiKVswXXx8eS5kb2N1bWVudEVsZW1lbnQ7cmV0dXJue3NlbmQ6ZnVuY3Rpb24oZCxlKXtiPXkuY3JlYXRlRWxlbWVudChcInNjcmlwdFwiKSxiLmFzeW5jPSEwLGEuc2NyaXB0Q2hhcnNldCYmKGIuY2hhcnNldD1hLnNjcmlwdENoYXJzZXQpLGIuc3JjPWEudXJsLGIub25sb2FkPWIub25yZWFkeXN0YXRlY2hhbmdlPWZ1bmN0aW9uKGEsYyl7KGN8fCFiLnJlYWR5U3RhdGV8fC9sb2FkZWR8Y29tcGxldGUvLnRlc3QoYi5yZWFkeVN0YXRlKSkmJihiLm9ubG9hZD1iLm9ucmVhZHlzdGF0ZWNoYW5nZT1udWxsLGIucGFyZW50Tm9kZSYmYi5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGIpLGI9bnVsbCxjfHxlKDIwMCxcInN1Y2Nlc3NcIikpfSxjLmluc2VydEJlZm9yZShiLGMuZmlyc3RDaGlsZCl9LGFib3J0OmZ1bmN0aW9uKCl7YiYmYi5vbmxvYWQodm9pZCAwLCEwKX19fX0pO3ZhciBfYj1bXSxhYz0vKD0pXFw/KD89JnwkKXxcXD9cXD8vO20uYWpheFNldHVwKHtqc29ucDpcImNhbGxiYWNrXCIsanNvbnBDYWxsYmFjazpmdW5jdGlvbigpe3ZhciBhPV9iLnBvcCgpfHxtLmV4cGFuZG8rXCJfXCIrdmIrKztyZXR1cm4gdGhpc1thXT0hMCxhfX0pLG0uYWpheFByZWZpbHRlcihcImpzb24ganNvbnBcIixmdW5jdGlvbihiLGMsZCl7dmFyIGUsZixnLGg9Yi5qc29ucCE9PSExJiYoYWMudGVzdChiLnVybCk/XCJ1cmxcIjpcInN0cmluZ1wiPT10eXBlb2YgYi5kYXRhJiYhKGIuY29udGVudFR5cGV8fFwiXCIpLmluZGV4T2YoXCJhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWRcIikmJmFjLnRlc3QoYi5kYXRhKSYmXCJkYXRhXCIpO3JldHVybiBofHxcImpzb25wXCI9PT1iLmRhdGFUeXBlc1swXT8oZT1iLmpzb25wQ2FsbGJhY2s9bS5pc0Z1bmN0aW9uKGIuanNvbnBDYWxsYmFjayk/Yi5qc29ucENhbGxiYWNrKCk6Yi5qc29ucENhbGxiYWNrLGg/YltoXT1iW2hdLnJlcGxhY2UoYWMsXCIkMVwiK2UpOmIuanNvbnAhPT0hMSYmKGIudXJsKz0od2IudGVzdChiLnVybCk/XCImXCI6XCI/XCIpK2IuanNvbnArXCI9XCIrZSksYi5jb252ZXJ0ZXJzW1wic2NyaXB0IGpzb25cIl09ZnVuY3Rpb24oKXtyZXR1cm4gZ3x8bS5lcnJvcihlK1wiIHdhcyBub3QgY2FsbGVkXCIpLGdbMF19LGIuZGF0YVR5cGVzWzBdPVwianNvblwiLGY9YVtlXSxhW2VdPWZ1bmN0aW9uKCl7Zz1hcmd1bWVudHN9LGQuYWx3YXlzKGZ1bmN0aW9uKCl7YVtlXT1mLGJbZV0mJihiLmpzb25wQ2FsbGJhY2s9Yy5qc29ucENhbGxiYWNrLF9iLnB1c2goZSkpLGcmJm0uaXNGdW5jdGlvbihmKSYmZihnWzBdKSxnPWY9dm9pZCAwfSksXCJzY3JpcHRcIik6dm9pZCAwfSksbS5wYXJzZUhUTUw9ZnVuY3Rpb24oYSxiLGMpe2lmKCFhfHxcInN0cmluZ1wiIT10eXBlb2YgYSlyZXR1cm4gbnVsbDtcImJvb2xlYW5cIj09dHlwZW9mIGImJihjPWIsYj0hMSksYj1ifHx5O3ZhciBkPXUuZXhlYyhhKSxlPSFjJiZbXTtyZXR1cm4gZD9bYi5jcmVhdGVFbGVtZW50KGRbMV0pXTooZD1tLmJ1aWxkRnJhZ21lbnQoW2FdLGIsZSksZSYmZS5sZW5ndGgmJm0oZSkucmVtb3ZlKCksbS5tZXJnZShbXSxkLmNoaWxkTm9kZXMpKX07dmFyIGJjPW0uZm4ubG9hZDttLmZuLmxvYWQ9ZnVuY3Rpb24oYSxiLGMpe2lmKFwic3RyaW5nXCIhPXR5cGVvZiBhJiZiYylyZXR1cm4gYmMuYXBwbHkodGhpcyxhcmd1bWVudHMpO3ZhciBkLGUsZixnPXRoaXMsaD1hLmluZGV4T2YoXCIgXCIpO3JldHVybiBoPj0wJiYoZD1tLnRyaW0oYS5zbGljZShoLGEubGVuZ3RoKSksYT1hLnNsaWNlKDAsaCkpLG0uaXNGdW5jdGlvbihiKT8oYz1iLGI9dm9pZCAwKTpiJiZcIm9iamVjdFwiPT10eXBlb2YgYiYmKGY9XCJQT1NUXCIpLGcubGVuZ3RoPjAmJm0uYWpheCh7dXJsOmEsdHlwZTpmLGRhdGFUeXBlOlwiaHRtbFwiLGRhdGE6Yn0pLmRvbmUoZnVuY3Rpb24oYSl7ZT1hcmd1bWVudHMsZy5odG1sKGQ/bShcIjxkaXY+XCIpLmFwcGVuZChtLnBhcnNlSFRNTChhKSkuZmluZChkKTphKX0pLmNvbXBsZXRlKGMmJmZ1bmN0aW9uKGEsYil7Zy5lYWNoKGMsZXx8W2EucmVzcG9uc2VUZXh0LGIsYV0pfSksdGhpc30sbS5lYWNoKFtcImFqYXhTdGFydFwiLFwiYWpheFN0b3BcIixcImFqYXhDb21wbGV0ZVwiLFwiYWpheEVycm9yXCIsXCJhamF4U3VjY2Vzc1wiLFwiYWpheFNlbmRcIl0sZnVuY3Rpb24oYSxiKXttLmZuW2JdPWZ1bmN0aW9uKGEpe3JldHVybiB0aGlzLm9uKGIsYSl9fSksbS5leHByLmZpbHRlcnMuYW5pbWF0ZWQ9ZnVuY3Rpb24oYSl7cmV0dXJuIG0uZ3JlcChtLnRpbWVycyxmdW5jdGlvbihiKXtyZXR1cm4gYT09PWIuZWxlbX0pLmxlbmd0aH07dmFyIGNjPWEuZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O2Z1bmN0aW9uIGRjKGEpe3JldHVybiBtLmlzV2luZG93KGEpP2E6OT09PWEubm9kZVR5cGU/YS5kZWZhdWx0Vmlld3x8YS5wYXJlbnRXaW5kb3c6ITF9bS5vZmZzZXQ9e3NldE9mZnNldDpmdW5jdGlvbihhLGIsYyl7dmFyIGQsZSxmLGcsaCxpLGosaz1tLmNzcyhhLFwicG9zaXRpb25cIiksbD1tKGEpLG49e307XCJzdGF0aWNcIj09PWsmJihhLnN0eWxlLnBvc2l0aW9uPVwicmVsYXRpdmVcIiksaD1sLm9mZnNldCgpLGY9bS5jc3MoYSxcInRvcFwiKSxpPW0uY3NzKGEsXCJsZWZ0XCIpLGo9KFwiYWJzb2x1dGVcIj09PWt8fFwiZml4ZWRcIj09PWspJiZtLmluQXJyYXkoXCJhdXRvXCIsW2YsaV0pPi0xLGo/KGQ9bC5wb3NpdGlvbigpLGc9ZC50b3AsZT1kLmxlZnQpOihnPXBhcnNlRmxvYXQoZil8fDAsZT1wYXJzZUZsb2F0KGkpfHwwKSxtLmlzRnVuY3Rpb24oYikmJihiPWIuY2FsbChhLGMsaCkpLG51bGwhPWIudG9wJiYobi50b3A9Yi50b3AtaC50b3ArZyksbnVsbCE9Yi5sZWZ0JiYobi5sZWZ0PWIubGVmdC1oLmxlZnQrZSksXCJ1c2luZ1wiaW4gYj9iLnVzaW5nLmNhbGwoYSxuKTpsLmNzcyhuKX19LG0uZm4uZXh0ZW5kKHtvZmZzZXQ6ZnVuY3Rpb24oYSl7aWYoYXJndW1lbnRzLmxlbmd0aClyZXR1cm4gdm9pZCAwPT09YT90aGlzOnRoaXMuZWFjaChmdW5jdGlvbihiKXttLm9mZnNldC5zZXRPZmZzZXQodGhpcyxhLGIpfSk7dmFyIGIsYyxkPXt0b3A6MCxsZWZ0OjB9LGU9dGhpc1swXSxmPWUmJmUub3duZXJEb2N1bWVudDtpZihmKXJldHVybiBiPWYuZG9jdW1lbnRFbGVtZW50LG0uY29udGFpbnMoYixlKT8odHlwZW9mIGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0IT09SyYmKGQ9ZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSksYz1kYyhmKSx7dG9wOmQudG9wKyhjLnBhZ2VZT2Zmc2V0fHxiLnNjcm9sbFRvcCktKGIuY2xpZW50VG9wfHwwKSxsZWZ0OmQubGVmdCsoYy5wYWdlWE9mZnNldHx8Yi5zY3JvbGxMZWZ0KS0oYi5jbGllbnRMZWZ0fHwwKX0pOmR9LHBvc2l0aW9uOmZ1bmN0aW9uKCl7aWYodGhpc1swXSl7dmFyIGEsYixjPXt0b3A6MCxsZWZ0OjB9LGQ9dGhpc1swXTtyZXR1cm5cImZpeGVkXCI9PT1tLmNzcyhkLFwicG9zaXRpb25cIik/Yj1kLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpOihhPXRoaXMub2Zmc2V0UGFyZW50KCksYj10aGlzLm9mZnNldCgpLG0ubm9kZU5hbWUoYVswXSxcImh0bWxcIil8fChjPWEub2Zmc2V0KCkpLGMudG9wKz1tLmNzcyhhWzBdLFwiYm9yZGVyVG9wV2lkdGhcIiwhMCksYy5sZWZ0Kz1tLmNzcyhhWzBdLFwiYm9yZGVyTGVmdFdpZHRoXCIsITApKSx7dG9wOmIudG9wLWMudG9wLW0uY3NzKGQsXCJtYXJnaW5Ub3BcIiwhMCksbGVmdDpiLmxlZnQtYy5sZWZ0LW0uY3NzKGQsXCJtYXJnaW5MZWZ0XCIsITApfX19LG9mZnNldFBhcmVudDpmdW5jdGlvbigpe3JldHVybiB0aGlzLm1hcChmdW5jdGlvbigpe3ZhciBhPXRoaXMub2Zmc2V0UGFyZW50fHxjYzt3aGlsZShhJiYhbS5ub2RlTmFtZShhLFwiaHRtbFwiKSYmXCJzdGF0aWNcIj09PW0uY3NzKGEsXCJwb3NpdGlvblwiKSlhPWEub2Zmc2V0UGFyZW50O3JldHVybiBhfHxjY30pfX0pLG0uZWFjaCh7c2Nyb2xsTGVmdDpcInBhZ2VYT2Zmc2V0XCIsc2Nyb2xsVG9wOlwicGFnZVlPZmZzZXRcIn0sZnVuY3Rpb24oYSxiKXt2YXIgYz0vWS8udGVzdChiKTttLmZuW2FdPWZ1bmN0aW9uKGQpe3JldHVybiBWKHRoaXMsZnVuY3Rpb24oYSxkLGUpe3ZhciBmPWRjKGEpO3JldHVybiB2b2lkIDA9PT1lP2Y/YiBpbiBmP2ZbYl06Zi5kb2N1bWVudC5kb2N1bWVudEVsZW1lbnRbZF06YVtkXTp2b2lkKGY/Zi5zY3JvbGxUbyhjP20oZikuc2Nyb2xsTGVmdCgpOmUsYz9lOm0oZikuc2Nyb2xsVG9wKCkpOmFbZF09ZSl9LGEsZCxhcmd1bWVudHMubGVuZ3RoLG51bGwpfX0pLG0uZWFjaChbXCJ0b3BcIixcImxlZnRcIl0sZnVuY3Rpb24oYSxiKXttLmNzc0hvb2tzW2JdPUxhKGsucGl4ZWxQb3NpdGlvbixmdW5jdGlvbihhLGMpe3JldHVybiBjPyhjPUphKGEsYiksSGEudGVzdChjKT9tKGEpLnBvc2l0aW9uKClbYl0rXCJweFwiOmMpOnZvaWQgMH0pfSksbS5lYWNoKHtIZWlnaHQ6XCJoZWlnaHRcIixXaWR0aDpcIndpZHRoXCJ9LGZ1bmN0aW9uKGEsYil7bS5lYWNoKHtwYWRkaW5nOlwiaW5uZXJcIithLGNvbnRlbnQ6YixcIlwiOlwib3V0ZXJcIithfSxmdW5jdGlvbihjLGQpe20uZm5bZF09ZnVuY3Rpb24oZCxlKXt2YXIgZj1hcmd1bWVudHMubGVuZ3RoJiYoY3x8XCJib29sZWFuXCIhPXR5cGVvZiBkKSxnPWN8fChkPT09ITB8fGU9PT0hMD9cIm1hcmdpblwiOlwiYm9yZGVyXCIpO3JldHVybiBWKHRoaXMsZnVuY3Rpb24oYixjLGQpe3ZhciBlO3JldHVybiBtLmlzV2luZG93KGIpP2IuZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50W1wiY2xpZW50XCIrYV06OT09PWIubm9kZVR5cGU/KGU9Yi5kb2N1bWVudEVsZW1lbnQsTWF0aC5tYXgoYi5ib2R5W1wic2Nyb2xsXCIrYV0sZVtcInNjcm9sbFwiK2FdLGIuYm9keVtcIm9mZnNldFwiK2FdLGVbXCJvZmZzZXRcIithXSxlW1wiY2xpZW50XCIrYV0pKTp2b2lkIDA9PT1kP20uY3NzKGIsYyxnKTptLnN0eWxlKGIsYyxkLGcpfSxiLGY/ZDp2b2lkIDAsZixudWxsKX19KX0pLG0uZm4uc2l6ZT1mdW5jdGlvbigpe3JldHVybiB0aGlzLmxlbmd0aH0sbS5mbi5hbmRTZWxmPW0uZm4uYWRkQmFjayxcImZ1bmN0aW9uXCI9PXR5cGVvZiBkZWZpbmUmJmRlZmluZS5hbWQmJmRlZmluZShcImpxdWVyeVwiLFtdLGZ1bmN0aW9uKCl7cmV0dXJuIG19KTt2YXIgZWM9YS5qUXVlcnksZmM9YS4kO3JldHVybiBtLm5vQ29uZmxpY3Q9ZnVuY3Rpb24oYil7cmV0dXJuIGEuJD09PW0mJihhLiQ9ZmMpLGImJmEualF1ZXJ5PT09bSYmKGEualF1ZXJ5PWVjKSxtfSx0eXBlb2YgYj09PUsmJihhLmpRdWVyeT1hLiQ9bSksbX0pO1xyXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zY3JpcHRzL3ZlbmRvcnMvanF1ZXJ5LTEuMTEuMy5taW4uanMiLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuXHRpZighbW9kdWxlLndlYnBhY2tQb2x5ZmlsbCkge1xuXHRcdG1vZHVsZS5kZXByZWNhdGUgPSBmdW5jdGlvbigpIHt9O1xuXHRcdG1vZHVsZS5wYXRocyA9IFtdO1xuXHRcdC8vIG1vZHVsZS5wYXJlbnQgPSB1bmRlZmluZWQgYnkgZGVmYXVsdFxuXHRcdG1vZHVsZS5jaGlsZHJlbiA9IFtdO1xuXHRcdG1vZHVsZS53ZWJwYWNrUG9seWZpbGwgPSAxO1xuXHR9XG5cdHJldHVybiBtb2R1bGU7XG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAod2VicGFjaykvYnVpbGRpbi9tb2R1bGUuanNcbi8vIG1vZHVsZSBpZCA9IDNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfaXRlcmF0b3IgPSByZXF1aXJlKFwiLi4vY29yZS1qcy9zeW1ib2wvaXRlcmF0b3JcIik7XG5cbnZhciBfaXRlcmF0b3IyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaXRlcmF0b3IpO1xuXG52YXIgX3N5bWJvbCA9IHJlcXVpcmUoXCIuLi9jb3JlLWpzL3N5bWJvbFwiKTtcblxudmFyIF9zeW1ib2wyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfc3ltYm9sKTtcblxudmFyIF90eXBlb2YgPSB0eXBlb2YgX3N5bWJvbDIuZGVmYXVsdCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBfaXRlcmF0b3IyLmRlZmF1bHQgPT09IFwic3ltYm9sXCIgPyBmdW5jdGlvbiAob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9IDogZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBfc3ltYm9sMi5kZWZhdWx0ID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBfc3ltYm9sMi5kZWZhdWx0ICYmIG9iaiAhPT0gX3N5bWJvbDIuZGVmYXVsdC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZXhwb3J0cy5kZWZhdWx0ID0gdHlwZW9mIF9zeW1ib2wyLmRlZmF1bHQgPT09IFwiZnVuY3Rpb25cIiAmJiBfdHlwZW9mKF9pdGVyYXRvcjIuZGVmYXVsdCkgPT09IFwic3ltYm9sXCIgPyBmdW5jdGlvbiAob2JqKSB7XG4gIHJldHVybiB0eXBlb2Ygb2JqID09PSBcInVuZGVmaW5lZFwiID8gXCJ1bmRlZmluZWRcIiA6IF90eXBlb2Yob2JqKTtcbn0gOiBmdW5jdGlvbiAob2JqKSB7XG4gIHJldHVybiBvYmogJiYgdHlwZW9mIF9zeW1ib2wyLmRlZmF1bHQgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IF9zeW1ib2wyLmRlZmF1bHQgJiYgb2JqICE9PSBfc3ltYm9sMi5kZWZhdWx0LnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqID09PSBcInVuZGVmaW5lZFwiID8gXCJ1bmRlZmluZWRcIiA6IF90eXBlb2Yob2JqKTtcbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2JhYmVsLXJ1bnRpbWUvaGVscGVycy90eXBlb2YuanNcbi8vIG1vZHVsZSBpZCA9IDRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSB7IFwiZGVmYXVsdFwiOiByZXF1aXJlKFwiY29yZS1qcy9saWJyYXJ5L2ZuL3N5bWJvbC9pdGVyYXRvclwiKSwgX19lc01vZHVsZTogdHJ1ZSB9O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9iYWJlbC1ydW50aW1lL2NvcmUtanMvc3ltYm9sL2l0ZXJhdG9yLmpzXG4vLyBtb2R1bGUgaWQgPSA1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInJlcXVpcmUoJy4uLy4uL21vZHVsZXMvZXM2LnN0cmluZy5pdGVyYXRvcicpO1xucmVxdWlyZSgnLi4vLi4vbW9kdWxlcy93ZWIuZG9tLml0ZXJhYmxlJyk7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4uLy4uL21vZHVsZXMvX3drcy1leHQnKS5mKCdpdGVyYXRvcicpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL2xpYnJhcnkvZm4vc3ltYm9sL2l0ZXJhdG9yLmpzXG4vLyBtb2R1bGUgaWQgPSA2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcbnZhciAkYXQgID0gcmVxdWlyZSgnLi9fc3RyaW5nLWF0JykodHJ1ZSk7XG5cbi8vIDIxLjEuMy4yNyBTdHJpbmcucHJvdG90eXBlW0BAaXRlcmF0b3JdKClcbnJlcXVpcmUoJy4vX2l0ZXItZGVmaW5lJykoU3RyaW5nLCAnU3RyaW5nJywgZnVuY3Rpb24oaXRlcmF0ZWQpe1xuICB0aGlzLl90ID0gU3RyaW5nKGl0ZXJhdGVkKTsgLy8gdGFyZ2V0XG4gIHRoaXMuX2kgPSAwOyAgICAgICAgICAgICAgICAvLyBuZXh0IGluZGV4XG4vLyAyMS4xLjUuMi4xICVTdHJpbmdJdGVyYXRvclByb3RvdHlwZSUubmV4dCgpXG59LCBmdW5jdGlvbigpe1xuICB2YXIgTyAgICAgPSB0aGlzLl90XG4gICAgLCBpbmRleCA9IHRoaXMuX2lcbiAgICAsIHBvaW50O1xuICBpZihpbmRleCA+PSBPLmxlbmd0aClyZXR1cm4ge3ZhbHVlOiB1bmRlZmluZWQsIGRvbmU6IHRydWV9O1xuICBwb2ludCA9ICRhdChPLCBpbmRleCk7XG4gIHRoaXMuX2kgKz0gcG9pbnQubGVuZ3RoO1xuICByZXR1cm4ge3ZhbHVlOiBwb2ludCwgZG9uZTogZmFsc2V9O1xufSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNi5zdHJpbmcuaXRlcmF0b3IuanNcbi8vIG1vZHVsZSBpZCA9IDdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIHRvSW50ZWdlciA9IHJlcXVpcmUoJy4vX3RvLWludGVnZXInKVxuICAsIGRlZmluZWQgICA9IHJlcXVpcmUoJy4vX2RlZmluZWQnKTtcbi8vIHRydWUgIC0+IFN0cmluZyNhdFxuLy8gZmFsc2UgLT4gU3RyaW5nI2NvZGVQb2ludEF0XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKFRPX1NUUklORyl7XG4gIHJldHVybiBmdW5jdGlvbih0aGF0LCBwb3Mpe1xuICAgIHZhciBzID0gU3RyaW5nKGRlZmluZWQodGhhdCkpXG4gICAgICAsIGkgPSB0b0ludGVnZXIocG9zKVxuICAgICAgLCBsID0gcy5sZW5ndGhcbiAgICAgICwgYSwgYjtcbiAgICBpZihpIDwgMCB8fCBpID49IGwpcmV0dXJuIFRPX1NUUklORyA/ICcnIDogdW5kZWZpbmVkO1xuICAgIGEgPSBzLmNoYXJDb2RlQXQoaSk7XG4gICAgcmV0dXJuIGEgPCAweGQ4MDAgfHwgYSA+IDB4ZGJmZiB8fCBpICsgMSA9PT0gbCB8fCAoYiA9IHMuY2hhckNvZGVBdChpICsgMSkpIDwgMHhkYzAwIHx8IGIgPiAweGRmZmZcbiAgICAgID8gVE9fU1RSSU5HID8gcy5jaGFyQXQoaSkgOiBhXG4gICAgICA6IFRPX1NUUklORyA/IHMuc2xpY2UoaSwgaSArIDIpIDogKGEgLSAweGQ4MDAgPDwgMTApICsgKGIgLSAweGRjMDApICsgMHgxMDAwMDtcbiAgfTtcbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19zdHJpbmctYXQuanNcbi8vIG1vZHVsZSBpZCA9IDhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gNy4xLjQgVG9JbnRlZ2VyXG52YXIgY2VpbCAgPSBNYXRoLmNlaWxcbiAgLCBmbG9vciA9IE1hdGguZmxvb3I7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KXtcbiAgcmV0dXJuIGlzTmFOKGl0ID0gK2l0KSA/IDAgOiAoaXQgPiAwID8gZmxvb3IgOiBjZWlsKShpdCk7XG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fdG8taW50ZWdlci5qc1xuLy8gbW9kdWxlIGlkID0gOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyA3LjIuMSBSZXF1aXJlT2JqZWN0Q29lcmNpYmxlKGFyZ3VtZW50KVxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCl7XG4gIGlmKGl0ID09IHVuZGVmaW5lZCl0aHJvdyBUeXBlRXJyb3IoXCJDYW4ndCBjYWxsIG1ldGhvZCBvbiAgXCIgKyBpdCk7XG4gIHJldHVybiBpdDtcbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19kZWZpbmVkLmpzXG4vLyBtb2R1bGUgaWQgPSAxMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG52YXIgTElCUkFSWSAgICAgICAgPSByZXF1aXJlKCcuL19saWJyYXJ5JylcbiAgLCAkZXhwb3J0ICAgICAgICA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgcmVkZWZpbmUgICAgICAgPSByZXF1aXJlKCcuL19yZWRlZmluZScpXG4gICwgaGlkZSAgICAgICAgICAgPSByZXF1aXJlKCcuL19oaWRlJylcbiAgLCBoYXMgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2hhcycpXG4gICwgSXRlcmF0b3JzICAgICAgPSByZXF1aXJlKCcuL19pdGVyYXRvcnMnKVxuICAsICRpdGVyQ3JlYXRlICAgID0gcmVxdWlyZSgnLi9faXRlci1jcmVhdGUnKVxuICAsIHNldFRvU3RyaW5nVGFnID0gcmVxdWlyZSgnLi9fc2V0LXRvLXN0cmluZy10YWcnKVxuICAsIGdldFByb3RvdHlwZU9mID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdwbycpXG4gICwgSVRFUkFUT1IgICAgICAgPSByZXF1aXJlKCcuL193a3MnKSgnaXRlcmF0b3InKVxuICAsIEJVR0dZICAgICAgICAgID0gIShbXS5rZXlzICYmICduZXh0JyBpbiBbXS5rZXlzKCkpIC8vIFNhZmFyaSBoYXMgYnVnZ3kgaXRlcmF0b3JzIHcvbyBgbmV4dGBcbiAgLCBGRl9JVEVSQVRPUiAgICA9ICdAQGl0ZXJhdG9yJ1xuICAsIEtFWVMgICAgICAgICAgID0gJ2tleXMnXG4gICwgVkFMVUVTICAgICAgICAgPSAndmFsdWVzJztcblxudmFyIHJldHVyblRoaXMgPSBmdW5jdGlvbigpeyByZXR1cm4gdGhpczsgfTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihCYXNlLCBOQU1FLCBDb25zdHJ1Y3RvciwgbmV4dCwgREVGQVVMVCwgSVNfU0VULCBGT1JDRUQpe1xuICAkaXRlckNyZWF0ZShDb25zdHJ1Y3RvciwgTkFNRSwgbmV4dCk7XG4gIHZhciBnZXRNZXRob2QgPSBmdW5jdGlvbihraW5kKXtcbiAgICBpZighQlVHR1kgJiYga2luZCBpbiBwcm90bylyZXR1cm4gcHJvdG9ba2luZF07XG4gICAgc3dpdGNoKGtpbmQpe1xuICAgICAgY2FzZSBLRVlTOiByZXR1cm4gZnVuY3Rpb24ga2V5cygpeyByZXR1cm4gbmV3IENvbnN0cnVjdG9yKHRoaXMsIGtpbmQpOyB9O1xuICAgICAgY2FzZSBWQUxVRVM6IHJldHVybiBmdW5jdGlvbiB2YWx1ZXMoKXsgcmV0dXJuIG5ldyBDb25zdHJ1Y3Rvcih0aGlzLCBraW5kKTsgfTtcbiAgICB9IHJldHVybiBmdW5jdGlvbiBlbnRyaWVzKCl7IHJldHVybiBuZXcgQ29uc3RydWN0b3IodGhpcywga2luZCk7IH07XG4gIH07XG4gIHZhciBUQUcgICAgICAgID0gTkFNRSArICcgSXRlcmF0b3InXG4gICAgLCBERUZfVkFMVUVTID0gREVGQVVMVCA9PSBWQUxVRVNcbiAgICAsIFZBTFVFU19CVUcgPSBmYWxzZVxuICAgICwgcHJvdG8gICAgICA9IEJhc2UucHJvdG90eXBlXG4gICAgLCAkbmF0aXZlICAgID0gcHJvdG9bSVRFUkFUT1JdIHx8IHByb3RvW0ZGX0lURVJBVE9SXSB8fCBERUZBVUxUICYmIHByb3RvW0RFRkFVTFRdXG4gICAgLCAkZGVmYXVsdCAgID0gJG5hdGl2ZSB8fCBnZXRNZXRob2QoREVGQVVMVClcbiAgICAsICRlbnRyaWVzICAgPSBERUZBVUxUID8gIURFRl9WQUxVRVMgPyAkZGVmYXVsdCA6IGdldE1ldGhvZCgnZW50cmllcycpIDogdW5kZWZpbmVkXG4gICAgLCAkYW55TmF0aXZlID0gTkFNRSA9PSAnQXJyYXknID8gcHJvdG8uZW50cmllcyB8fCAkbmF0aXZlIDogJG5hdGl2ZVxuICAgICwgbWV0aG9kcywga2V5LCBJdGVyYXRvclByb3RvdHlwZTtcbiAgLy8gRml4IG5hdGl2ZVxuICBpZigkYW55TmF0aXZlKXtcbiAgICBJdGVyYXRvclByb3RvdHlwZSA9IGdldFByb3RvdHlwZU9mKCRhbnlOYXRpdmUuY2FsbChuZXcgQmFzZSkpO1xuICAgIGlmKEl0ZXJhdG9yUHJvdG90eXBlICE9PSBPYmplY3QucHJvdG90eXBlKXtcbiAgICAgIC8vIFNldCBAQHRvU3RyaW5nVGFnIHRvIG5hdGl2ZSBpdGVyYXRvcnNcbiAgICAgIHNldFRvU3RyaW5nVGFnKEl0ZXJhdG9yUHJvdG90eXBlLCBUQUcsIHRydWUpO1xuICAgICAgLy8gZml4IGZvciBzb21lIG9sZCBlbmdpbmVzXG4gICAgICBpZighTElCUkFSWSAmJiAhaGFzKEl0ZXJhdG9yUHJvdG90eXBlLCBJVEVSQVRPUikpaGlkZShJdGVyYXRvclByb3RvdHlwZSwgSVRFUkFUT1IsIHJldHVyblRoaXMpO1xuICAgIH1cbiAgfVxuICAvLyBmaXggQXJyYXkje3ZhbHVlcywgQEBpdGVyYXRvcn0ubmFtZSBpbiBWOCAvIEZGXG4gIGlmKERFRl9WQUxVRVMgJiYgJG5hdGl2ZSAmJiAkbmF0aXZlLm5hbWUgIT09IFZBTFVFUyl7XG4gICAgVkFMVUVTX0JVRyA9IHRydWU7XG4gICAgJGRlZmF1bHQgPSBmdW5jdGlvbiB2YWx1ZXMoKXsgcmV0dXJuICRuYXRpdmUuY2FsbCh0aGlzKTsgfTtcbiAgfVxuICAvLyBEZWZpbmUgaXRlcmF0b3JcbiAgaWYoKCFMSUJSQVJZIHx8IEZPUkNFRCkgJiYgKEJVR0dZIHx8IFZBTFVFU19CVUcgfHwgIXByb3RvW0lURVJBVE9SXSkpe1xuICAgIGhpZGUocHJvdG8sIElURVJBVE9SLCAkZGVmYXVsdCk7XG4gIH1cbiAgLy8gUGx1ZyBmb3IgbGlicmFyeVxuICBJdGVyYXRvcnNbTkFNRV0gPSAkZGVmYXVsdDtcbiAgSXRlcmF0b3JzW1RBR10gID0gcmV0dXJuVGhpcztcbiAgaWYoREVGQVVMVCl7XG4gICAgbWV0aG9kcyA9IHtcbiAgICAgIHZhbHVlczogIERFRl9WQUxVRVMgPyAkZGVmYXVsdCA6IGdldE1ldGhvZChWQUxVRVMpLFxuICAgICAga2V5czogICAgSVNfU0VUICAgICA/ICRkZWZhdWx0IDogZ2V0TWV0aG9kKEtFWVMpLFxuICAgICAgZW50cmllczogJGVudHJpZXNcbiAgICB9O1xuICAgIGlmKEZPUkNFRClmb3Ioa2V5IGluIG1ldGhvZHMpe1xuICAgICAgaWYoIShrZXkgaW4gcHJvdG8pKXJlZGVmaW5lKHByb3RvLCBrZXksIG1ldGhvZHNba2V5XSk7XG4gICAgfSBlbHNlICRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogKEJVR0dZIHx8IFZBTFVFU19CVUcpLCBOQU1FLCBtZXRob2RzKTtcbiAgfVxuICByZXR1cm4gbWV0aG9kcztcbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19pdGVyLWRlZmluZS5qc1xuLy8gbW9kdWxlIGlkID0gMTFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSB0cnVlO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fbGlicmFyeS5qc1xuLy8gbW9kdWxlIGlkID0gMTJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGdsb2JhbCAgICA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpXG4gICwgY29yZSAgICAgID0gcmVxdWlyZSgnLi9fY29yZScpXG4gICwgY3R4ICAgICAgID0gcmVxdWlyZSgnLi9fY3R4JylcbiAgLCBoaWRlICAgICAgPSByZXF1aXJlKCcuL19oaWRlJylcbiAgLCBQUk9UT1RZUEUgPSAncHJvdG90eXBlJztcblxudmFyICRleHBvcnQgPSBmdW5jdGlvbih0eXBlLCBuYW1lLCBzb3VyY2Upe1xuICB2YXIgSVNfRk9SQ0VEID0gdHlwZSAmICRleHBvcnQuRlxuICAgICwgSVNfR0xPQkFMID0gdHlwZSAmICRleHBvcnQuR1xuICAgICwgSVNfU1RBVElDID0gdHlwZSAmICRleHBvcnQuU1xuICAgICwgSVNfUFJPVE8gID0gdHlwZSAmICRleHBvcnQuUFxuICAgICwgSVNfQklORCAgID0gdHlwZSAmICRleHBvcnQuQlxuICAgICwgSVNfV1JBUCAgID0gdHlwZSAmICRleHBvcnQuV1xuICAgICwgZXhwb3J0cyAgID0gSVNfR0xPQkFMID8gY29yZSA6IGNvcmVbbmFtZV0gfHwgKGNvcmVbbmFtZV0gPSB7fSlcbiAgICAsIGV4cFByb3RvICA9IGV4cG9ydHNbUFJPVE9UWVBFXVxuICAgICwgdGFyZ2V0ICAgID0gSVNfR0xPQkFMID8gZ2xvYmFsIDogSVNfU1RBVElDID8gZ2xvYmFsW25hbWVdIDogKGdsb2JhbFtuYW1lXSB8fCB7fSlbUFJPVE9UWVBFXVxuICAgICwga2V5LCBvd24sIG91dDtcbiAgaWYoSVNfR0xPQkFMKXNvdXJjZSA9IG5hbWU7XG4gIGZvcihrZXkgaW4gc291cmNlKXtcbiAgICAvLyBjb250YWlucyBpbiBuYXRpdmVcbiAgICBvd24gPSAhSVNfRk9SQ0VEICYmIHRhcmdldCAmJiB0YXJnZXRba2V5XSAhPT0gdW5kZWZpbmVkO1xuICAgIGlmKG93biAmJiBrZXkgaW4gZXhwb3J0cyljb250aW51ZTtcbiAgICAvLyBleHBvcnQgbmF0aXZlIG9yIHBhc3NlZFxuICAgIG91dCA9IG93biA/IHRhcmdldFtrZXldIDogc291cmNlW2tleV07XG4gICAgLy8gcHJldmVudCBnbG9iYWwgcG9sbHV0aW9uIGZvciBuYW1lc3BhY2VzXG4gICAgZXhwb3J0c1trZXldID0gSVNfR0xPQkFMICYmIHR5cGVvZiB0YXJnZXRba2V5XSAhPSAnZnVuY3Rpb24nID8gc291cmNlW2tleV1cbiAgICAvLyBiaW5kIHRpbWVycyB0byBnbG9iYWwgZm9yIGNhbGwgZnJvbSBleHBvcnQgY29udGV4dFxuICAgIDogSVNfQklORCAmJiBvd24gPyBjdHgob3V0LCBnbG9iYWwpXG4gICAgLy8gd3JhcCBnbG9iYWwgY29uc3RydWN0b3JzIGZvciBwcmV2ZW50IGNoYW5nZSB0aGVtIGluIGxpYnJhcnlcbiAgICA6IElTX1dSQVAgJiYgdGFyZ2V0W2tleV0gPT0gb3V0ID8gKGZ1bmN0aW9uKEMpe1xuICAgICAgdmFyIEYgPSBmdW5jdGlvbihhLCBiLCBjKXtcbiAgICAgICAgaWYodGhpcyBpbnN0YW5jZW9mIEMpe1xuICAgICAgICAgIHN3aXRjaChhcmd1bWVudHMubGVuZ3RoKXtcbiAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIG5ldyBDO1xuICAgICAgICAgICAgY2FzZSAxOiByZXR1cm4gbmV3IEMoYSk7XG4gICAgICAgICAgICBjYXNlIDI6IHJldHVybiBuZXcgQyhhLCBiKTtcbiAgICAgICAgICB9IHJldHVybiBuZXcgQyhhLCBiLCBjKTtcbiAgICAgICAgfSByZXR1cm4gQy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfTtcbiAgICAgIEZbUFJPVE9UWVBFXSA9IENbUFJPVE9UWVBFXTtcbiAgICAgIHJldHVybiBGO1xuICAgIC8vIG1ha2Ugc3RhdGljIHZlcnNpb25zIGZvciBwcm90b3R5cGUgbWV0aG9kc1xuICAgIH0pKG91dCkgOiBJU19QUk9UTyAmJiB0eXBlb2Ygb3V0ID09ICdmdW5jdGlvbicgPyBjdHgoRnVuY3Rpb24uY2FsbCwgb3V0KSA6IG91dDtcbiAgICAvLyBleHBvcnQgcHJvdG8gbWV0aG9kcyB0byBjb3JlLiVDT05TVFJVQ1RPUiUubWV0aG9kcy4lTkFNRSVcbiAgICBpZihJU19QUk9UTyl7XG4gICAgICAoZXhwb3J0cy52aXJ0dWFsIHx8IChleHBvcnRzLnZpcnR1YWwgPSB7fSkpW2tleV0gPSBvdXQ7XG4gICAgICAvLyBleHBvcnQgcHJvdG8gbWV0aG9kcyB0byBjb3JlLiVDT05TVFJVQ1RPUiUucHJvdG90eXBlLiVOQU1FJVxuICAgICAgaWYodHlwZSAmICRleHBvcnQuUiAmJiBleHBQcm90byAmJiAhZXhwUHJvdG9ba2V5XSloaWRlKGV4cFByb3RvLCBrZXksIG91dCk7XG4gICAgfVxuICB9XG59O1xuLy8gdHlwZSBiaXRtYXBcbiRleHBvcnQuRiA9IDE7ICAgLy8gZm9yY2VkXG4kZXhwb3J0LkcgPSAyOyAgIC8vIGdsb2JhbFxuJGV4cG9ydC5TID0gNDsgICAvLyBzdGF0aWNcbiRleHBvcnQuUCA9IDg7ICAgLy8gcHJvdG9cbiRleHBvcnQuQiA9IDE2OyAgLy8gYmluZFxuJGV4cG9ydC5XID0gMzI7ICAvLyB3cmFwXG4kZXhwb3J0LlUgPSA2NDsgIC8vIHNhZmVcbiRleHBvcnQuUiA9IDEyODsgLy8gcmVhbCBwcm90byBtZXRob2QgZm9yIGBsaWJyYXJ5YCBcbm1vZHVsZS5leHBvcnRzID0gJGV4cG9ydDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2V4cG9ydC5qc1xuLy8gbW9kdWxlIGlkID0gMTNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gaHR0cHM6Ly9naXRodWIuY29tL3psb2lyb2NrL2NvcmUtanMvaXNzdWVzLzg2I2lzc3VlY29tbWVudC0xMTU3NTkwMjhcbnZhciBnbG9iYWwgPSBtb2R1bGUuZXhwb3J0cyA9IHR5cGVvZiB3aW5kb3cgIT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93Lk1hdGggPT0gTWF0aFxuICA/IHdpbmRvdyA6IHR5cGVvZiBzZWxmICE9ICd1bmRlZmluZWQnICYmIHNlbGYuTWF0aCA9PSBNYXRoID8gc2VsZiA6IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XG5pZih0eXBlb2YgX19nID09ICdudW1iZXInKV9fZyA9IGdsb2JhbDsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZlxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZ2xvYmFsLmpzXG4vLyBtb2R1bGUgaWQgPSAxNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgY29yZSA9IG1vZHVsZS5leHBvcnRzID0ge3ZlcnNpb246ICcyLjQuMCd9O1xuaWYodHlwZW9mIF9fZSA9PSAnbnVtYmVyJylfX2UgPSBjb3JlOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVuZGVmXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19jb3JlLmpzXG4vLyBtb2R1bGUgaWQgPSAxNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyBvcHRpb25hbCAvIHNpbXBsZSBjb250ZXh0IGJpbmRpbmdcbnZhciBhRnVuY3Rpb24gPSByZXF1aXJlKCcuL19hLWZ1bmN0aW9uJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGZuLCB0aGF0LCBsZW5ndGgpe1xuICBhRnVuY3Rpb24oZm4pO1xuICBpZih0aGF0ID09PSB1bmRlZmluZWQpcmV0dXJuIGZuO1xuICBzd2l0Y2gobGVuZ3RoKXtcbiAgICBjYXNlIDE6IHJldHVybiBmdW5jdGlvbihhKXtcbiAgICAgIHJldHVybiBmbi5jYWxsKHRoYXQsIGEpO1xuICAgIH07XG4gICAgY2FzZSAyOiByZXR1cm4gZnVuY3Rpb24oYSwgYil7XG4gICAgICByZXR1cm4gZm4uY2FsbCh0aGF0LCBhLCBiKTtcbiAgICB9O1xuICAgIGNhc2UgMzogcmV0dXJuIGZ1bmN0aW9uKGEsIGIsIGMpe1xuICAgICAgcmV0dXJuIGZuLmNhbGwodGhhdCwgYSwgYiwgYyk7XG4gICAgfTtcbiAgfVxuICByZXR1cm4gZnVuY3Rpb24oLyogLi4uYXJncyAqLyl7XG4gICAgcmV0dXJuIGZuLmFwcGx5KHRoYXQsIGFyZ3VtZW50cyk7XG4gIH07XG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fY3R4LmpzXG4vLyBtb2R1bGUgaWQgPSAxNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KXtcbiAgaWYodHlwZW9mIGl0ICE9ICdmdW5jdGlvbicpdGhyb3cgVHlwZUVycm9yKGl0ICsgJyBpcyBub3QgYSBmdW5jdGlvbiEnKTtcbiAgcmV0dXJuIGl0O1xufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2EtZnVuY3Rpb24uanNcbi8vIG1vZHVsZSBpZCA9IDE3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBkUCAgICAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJylcbiAgLCBjcmVhdGVEZXNjID0gcmVxdWlyZSgnLi9fcHJvcGVydHktZGVzYycpO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpID8gZnVuY3Rpb24ob2JqZWN0LCBrZXksIHZhbHVlKXtcbiAgcmV0dXJuIGRQLmYob2JqZWN0LCBrZXksIGNyZWF0ZURlc2MoMSwgdmFsdWUpKTtcbn0gOiBmdW5jdGlvbihvYmplY3QsIGtleSwgdmFsdWUpe1xuICBvYmplY3Rba2V5XSA9IHZhbHVlO1xuICByZXR1cm4gb2JqZWN0O1xufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2hpZGUuanNcbi8vIG1vZHVsZSBpZCA9IDE4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBhbk9iamVjdCAgICAgICA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpXG4gICwgSUU4X0RPTV9ERUZJTkUgPSByZXF1aXJlKCcuL19pZTgtZG9tLWRlZmluZScpXG4gICwgdG9QcmltaXRpdmUgICAgPSByZXF1aXJlKCcuL190by1wcmltaXRpdmUnKVxuICAsIGRQICAgICAgICAgICAgID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xuXG5leHBvcnRzLmYgPSByZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpID8gT2JqZWN0LmRlZmluZVByb3BlcnR5IDogZnVuY3Rpb24gZGVmaW5lUHJvcGVydHkoTywgUCwgQXR0cmlidXRlcyl7XG4gIGFuT2JqZWN0KE8pO1xuICBQID0gdG9QcmltaXRpdmUoUCwgdHJ1ZSk7XG4gIGFuT2JqZWN0KEF0dHJpYnV0ZXMpO1xuICBpZihJRThfRE9NX0RFRklORSl0cnkge1xuICAgIHJldHVybiBkUChPLCBQLCBBdHRyaWJ1dGVzKTtcbiAgfSBjYXRjaChlKXsgLyogZW1wdHkgKi8gfVxuICBpZignZ2V0JyBpbiBBdHRyaWJ1dGVzIHx8ICdzZXQnIGluIEF0dHJpYnV0ZXMpdGhyb3cgVHlwZUVycm9yKCdBY2Nlc3NvcnMgbm90IHN1cHBvcnRlZCEnKTtcbiAgaWYoJ3ZhbHVlJyBpbiBBdHRyaWJ1dGVzKU9bUF0gPSBBdHRyaWJ1dGVzLnZhbHVlO1xuICByZXR1cm4gTztcbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3QtZHAuanNcbi8vIG1vZHVsZSBpZCA9IDE5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCl7XG4gIGlmKCFpc09iamVjdChpdCkpdGhyb3cgVHlwZUVycm9yKGl0ICsgJyBpcyBub3QgYW4gb2JqZWN0IScpO1xuICByZXR1cm4gaXQ7XG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fYW4tb2JqZWN0LmpzXG4vLyBtb2R1bGUgaWQgPSAyMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KXtcbiAgcmV0dXJuIHR5cGVvZiBpdCA9PT0gJ29iamVjdCcgPyBpdCAhPT0gbnVsbCA6IHR5cGVvZiBpdCA9PT0gJ2Z1bmN0aW9uJztcbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19pcy1vYmplY3QuanNcbi8vIG1vZHVsZSBpZCA9IDIxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gIXJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJykgJiYgIXJlcXVpcmUoJy4vX2ZhaWxzJykoZnVuY3Rpb24oKXtcclxuICByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KHJlcXVpcmUoJy4vX2RvbS1jcmVhdGUnKSgnZGl2JyksICdhJywge2dldDogZnVuY3Rpb24oKXsgcmV0dXJuIDc7IH19KS5hICE9IDc7XHJcbn0pO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faWU4LWRvbS1kZWZpbmUuanNcbi8vIG1vZHVsZSBpZCA9IDIyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIFRoYW5rJ3MgSUU4IGZvciBoaXMgZnVubnkgZGVmaW5lUHJvcGVydHlcbm1vZHVsZS5leHBvcnRzID0gIXJlcXVpcmUoJy4vX2ZhaWxzJykoZnVuY3Rpb24oKXtcbiAgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh7fSwgJ2EnLCB7Z2V0OiBmdW5jdGlvbigpeyByZXR1cm4gNzsgfX0pLmEgIT0gNztcbn0pO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZGVzY3JpcHRvcnMuanNcbi8vIG1vZHVsZSBpZCA9IDIzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oZXhlYyl7XG4gIHRyeSB7XG4gICAgcmV0dXJuICEhZXhlYygpO1xuICB9IGNhdGNoKGUpe1xuICAgIHJldHVybiB0cnVlO1xuICB9XG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZmFpbHMuanNcbi8vIG1vZHVsZSBpZCA9IDI0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpXG4gICwgZG9jdW1lbnQgPSByZXF1aXJlKCcuL19nbG9iYWwnKS5kb2N1bWVudFxuICAvLyBpbiBvbGQgSUUgdHlwZW9mIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQgaXMgJ29iamVjdCdcbiAgLCBpcyA9IGlzT2JqZWN0KGRvY3VtZW50KSAmJiBpc09iamVjdChkb2N1bWVudC5jcmVhdGVFbGVtZW50KTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQpe1xuICByZXR1cm4gaXMgPyBkb2N1bWVudC5jcmVhdGVFbGVtZW50KGl0KSA6IHt9O1xufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2RvbS1jcmVhdGUuanNcbi8vIG1vZHVsZSBpZCA9IDI1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIDcuMS4xIFRvUHJpbWl0aXZlKGlucHV0IFssIFByZWZlcnJlZFR5cGVdKVxudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG4vLyBpbnN0ZWFkIG9mIHRoZSBFUzYgc3BlYyB2ZXJzaW9uLCB3ZSBkaWRuJ3QgaW1wbGVtZW50IEBAdG9QcmltaXRpdmUgY2FzZVxuLy8gYW5kIHRoZSBzZWNvbmQgYXJndW1lbnQgLSBmbGFnIC0gcHJlZmVycmVkIHR5cGUgaXMgYSBzdHJpbmdcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQsIFMpe1xuICBpZighaXNPYmplY3QoaXQpKXJldHVybiBpdDtcbiAgdmFyIGZuLCB2YWw7XG4gIGlmKFMgJiYgdHlwZW9mIChmbiA9IGl0LnRvU3RyaW5nKSA9PSAnZnVuY3Rpb24nICYmICFpc09iamVjdCh2YWwgPSBmbi5jYWxsKGl0KSkpcmV0dXJuIHZhbDtcbiAgaWYodHlwZW9mIChmbiA9IGl0LnZhbHVlT2YpID09ICdmdW5jdGlvbicgJiYgIWlzT2JqZWN0KHZhbCA9IGZuLmNhbGwoaXQpKSlyZXR1cm4gdmFsO1xuICBpZighUyAmJiB0eXBlb2YgKGZuID0gaXQudG9TdHJpbmcpID09ICdmdW5jdGlvbicgJiYgIWlzT2JqZWN0KHZhbCA9IGZuLmNhbGwoaXQpKSlyZXR1cm4gdmFsO1xuICB0aHJvdyBUeXBlRXJyb3IoXCJDYW4ndCBjb252ZXJ0IG9iamVjdCB0byBwcmltaXRpdmUgdmFsdWVcIik7XG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fdG8tcHJpbWl0aXZlLmpzXG4vLyBtb2R1bGUgaWQgPSAyNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGJpdG1hcCwgdmFsdWUpe1xuICByZXR1cm4ge1xuICAgIGVudW1lcmFibGUgIDogIShiaXRtYXAgJiAxKSxcbiAgICBjb25maWd1cmFibGU6ICEoYml0bWFwICYgMiksXG4gICAgd3JpdGFibGUgICAgOiAhKGJpdG1hcCAmIDQpLFxuICAgIHZhbHVlICAgICAgIDogdmFsdWVcbiAgfTtcbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19wcm9wZXJ0eS1kZXNjLmpzXG4vLyBtb2R1bGUgaWQgPSAyN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vX2hpZGUnKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3JlZGVmaW5lLmpzXG4vLyBtb2R1bGUgaWQgPSAyOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgaGFzT3duUHJvcGVydHkgPSB7fS5oYXNPd25Qcm9wZXJ0eTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQsIGtleSl7XG4gIHJldHVybiBoYXNPd25Qcm9wZXJ0eS5jYWxsKGl0LCBrZXkpO1xufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2hhcy5qc1xuLy8gbW9kdWxlIGlkID0gMjlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSB7fTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2l0ZXJhdG9ycy5qc1xuLy8gbW9kdWxlIGlkID0gMzBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGNyZWF0ZSAgICAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWNyZWF0ZScpXG4gICwgZGVzY3JpcHRvciAgICAgPSByZXF1aXJlKCcuL19wcm9wZXJ0eS1kZXNjJylcbiAgLCBzZXRUb1N0cmluZ1RhZyA9IHJlcXVpcmUoJy4vX3NldC10by1zdHJpbmctdGFnJylcbiAgLCBJdGVyYXRvclByb3RvdHlwZSA9IHt9O1xuXG4vLyAyNS4xLjIuMS4xICVJdGVyYXRvclByb3RvdHlwZSVbQEBpdGVyYXRvcl0oKVxucmVxdWlyZSgnLi9faGlkZScpKEl0ZXJhdG9yUHJvdG90eXBlLCByZXF1aXJlKCcuL193a3MnKSgnaXRlcmF0b3InKSwgZnVuY3Rpb24oKXsgcmV0dXJuIHRoaXM7IH0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKENvbnN0cnVjdG9yLCBOQU1FLCBuZXh0KXtcbiAgQ29uc3RydWN0b3IucHJvdG90eXBlID0gY3JlYXRlKEl0ZXJhdG9yUHJvdG90eXBlLCB7bmV4dDogZGVzY3JpcHRvcigxLCBuZXh0KX0pO1xuICBzZXRUb1N0cmluZ1RhZyhDb25zdHJ1Y3RvciwgTkFNRSArICcgSXRlcmF0b3InKTtcbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19pdGVyLWNyZWF0ZS5qc1xuLy8gbW9kdWxlIGlkID0gMzFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gMTkuMS4yLjIgLyAxNS4yLjMuNSBPYmplY3QuY3JlYXRlKE8gWywgUHJvcGVydGllc10pXHJcbnZhciBhbk9iamVjdCAgICA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpXHJcbiAgLCBkUHMgICAgICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1kcHMnKVxyXG4gICwgZW51bUJ1Z0tleXMgPSByZXF1aXJlKCcuL19lbnVtLWJ1Zy1rZXlzJylcclxuICAsIElFX1BST1RPICAgID0gcmVxdWlyZSgnLi9fc2hhcmVkLWtleScpKCdJRV9QUk9UTycpXHJcbiAgLCBFbXB0eSAgICAgICA9IGZ1bmN0aW9uKCl7IC8qIGVtcHR5ICovIH1cclxuICAsIFBST1RPVFlQRSAgID0gJ3Byb3RvdHlwZSc7XHJcblxyXG4vLyBDcmVhdGUgb2JqZWN0IHdpdGggZmFrZSBgbnVsbGAgcHJvdG90eXBlOiB1c2UgaWZyYW1lIE9iamVjdCB3aXRoIGNsZWFyZWQgcHJvdG90eXBlXHJcbnZhciBjcmVhdGVEaWN0ID0gZnVuY3Rpb24oKXtcclxuICAvLyBUaHJhc2gsIHdhc3RlIGFuZCBzb2RvbXk6IElFIEdDIGJ1Z1xyXG4gIHZhciBpZnJhbWUgPSByZXF1aXJlKCcuL19kb20tY3JlYXRlJykoJ2lmcmFtZScpXHJcbiAgICAsIGkgICAgICA9IGVudW1CdWdLZXlzLmxlbmd0aFxyXG4gICAgLCBndCAgICAgPSAnPidcclxuICAgICwgaWZyYW1lRG9jdW1lbnQ7XHJcbiAgaWZyYW1lLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XHJcbiAgcmVxdWlyZSgnLi9faHRtbCcpLmFwcGVuZENoaWxkKGlmcmFtZSk7XHJcbiAgaWZyYW1lLnNyYyA9ICdqYXZhc2NyaXB0Oic7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tc2NyaXB0LXVybFxyXG4gIC8vIGNyZWF0ZURpY3QgPSBpZnJhbWUuY29udGVudFdpbmRvdy5PYmplY3Q7XHJcbiAgLy8gaHRtbC5yZW1vdmVDaGlsZChpZnJhbWUpO1xyXG4gIGlmcmFtZURvY3VtZW50ID0gaWZyYW1lLmNvbnRlbnRXaW5kb3cuZG9jdW1lbnQ7XHJcbiAgaWZyYW1lRG9jdW1lbnQub3BlbigpO1xyXG4gIGlmcmFtZURvY3VtZW50LndyaXRlKCc8c2NyaXB0PmRvY3VtZW50LkY9T2JqZWN0PC9zY3JpcHQnICsgZ3QpO1xyXG4gIGlmcmFtZURvY3VtZW50LmNsb3NlKCk7XHJcbiAgY3JlYXRlRGljdCA9IGlmcmFtZURvY3VtZW50LkY7XHJcbiAgd2hpbGUoaS0tKWRlbGV0ZSBjcmVhdGVEaWN0W1BST1RPVFlQRV1bZW51bUJ1Z0tleXNbaV1dO1xyXG4gIHJldHVybiBjcmVhdGVEaWN0KCk7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IE9iamVjdC5jcmVhdGUgfHwgZnVuY3Rpb24gY3JlYXRlKE8sIFByb3BlcnRpZXMpe1xyXG4gIHZhciByZXN1bHQ7XHJcbiAgaWYoTyAhPT0gbnVsbCl7XHJcbiAgICBFbXB0eVtQUk9UT1RZUEVdID0gYW5PYmplY3QoTyk7XHJcbiAgICByZXN1bHQgPSBuZXcgRW1wdHk7XHJcbiAgICBFbXB0eVtQUk9UT1RZUEVdID0gbnVsbDtcclxuICAgIC8vIGFkZCBcIl9fcHJvdG9fX1wiIGZvciBPYmplY3QuZ2V0UHJvdG90eXBlT2YgcG9seWZpbGxcclxuICAgIHJlc3VsdFtJRV9QUk9UT10gPSBPO1xyXG4gIH0gZWxzZSByZXN1bHQgPSBjcmVhdGVEaWN0KCk7XHJcbiAgcmV0dXJuIFByb3BlcnRpZXMgPT09IHVuZGVmaW5lZCA/IHJlc3VsdCA6IGRQcyhyZXN1bHQsIFByb3BlcnRpZXMpO1xyXG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LWNyZWF0ZS5qc1xuLy8gbW9kdWxlIGlkID0gMzJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGRQICAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJylcclxuICAsIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0JylcclxuICAsIGdldEtleXMgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWtleXMnKTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzIDogZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyhPLCBQcm9wZXJ0aWVzKXtcclxuICBhbk9iamVjdChPKTtcclxuICB2YXIga2V5cyAgID0gZ2V0S2V5cyhQcm9wZXJ0aWVzKVxyXG4gICAgLCBsZW5ndGggPSBrZXlzLmxlbmd0aFxyXG4gICAgLCBpID0gMFxyXG4gICAgLCBQO1xyXG4gIHdoaWxlKGxlbmd0aCA+IGkpZFAuZihPLCBQID0ga2V5c1tpKytdLCBQcm9wZXJ0aWVzW1BdKTtcclxuICByZXR1cm4gTztcclxufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1kcHMuanNcbi8vIG1vZHVsZSBpZCA9IDMzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIDE5LjEuMi4xNCAvIDE1LjIuMy4xNCBPYmplY3Qua2V5cyhPKVxyXG52YXIgJGtleXMgICAgICAgPSByZXF1aXJlKCcuL19vYmplY3Qta2V5cy1pbnRlcm5hbCcpXHJcbiAgLCBlbnVtQnVnS2V5cyA9IHJlcXVpcmUoJy4vX2VudW0tYnVnLWtleXMnKTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gT2JqZWN0LmtleXMgfHwgZnVuY3Rpb24ga2V5cyhPKXtcclxuICByZXR1cm4gJGtleXMoTywgZW51bUJ1Z0tleXMpO1xyXG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LWtleXMuanNcbi8vIG1vZHVsZSBpZCA9IDM0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBoYXMgICAgICAgICAgPSByZXF1aXJlKCcuL19oYXMnKVxyXG4gICwgdG9JT2JqZWN0ICAgID0gcmVxdWlyZSgnLi9fdG8taW9iamVjdCcpXHJcbiAgLCBhcnJheUluZGV4T2YgPSByZXF1aXJlKCcuL19hcnJheS1pbmNsdWRlcycpKGZhbHNlKVxyXG4gICwgSUVfUFJPVE8gICAgID0gcmVxdWlyZSgnLi9fc2hhcmVkLWtleScpKCdJRV9QUk9UTycpO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihvYmplY3QsIG5hbWVzKXtcclxuICB2YXIgTyAgICAgID0gdG9JT2JqZWN0KG9iamVjdClcclxuICAgICwgaSAgICAgID0gMFxyXG4gICAgLCByZXN1bHQgPSBbXVxyXG4gICAgLCBrZXk7XHJcbiAgZm9yKGtleSBpbiBPKWlmKGtleSAhPSBJRV9QUk9UTyloYXMoTywga2V5KSAmJiByZXN1bHQucHVzaChrZXkpO1xyXG4gIC8vIERvbid0IGVudW0gYnVnICYgaGlkZGVuIGtleXNcclxuICB3aGlsZShuYW1lcy5sZW5ndGggPiBpKWlmKGhhcyhPLCBrZXkgPSBuYW1lc1tpKytdKSl7XHJcbiAgICB+YXJyYXlJbmRleE9mKHJlc3VsdCwga2V5KSB8fCByZXN1bHQucHVzaChrZXkpO1xyXG4gIH1cclxuICByZXR1cm4gcmVzdWx0O1xyXG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LWtleXMtaW50ZXJuYWwuanNcbi8vIG1vZHVsZSBpZCA9IDM1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIHRvIGluZGV4ZWQgb2JqZWN0LCB0b09iamVjdCB3aXRoIGZhbGxiYWNrIGZvciBub24tYXJyYXktbGlrZSBFUzMgc3RyaW5nc1xudmFyIElPYmplY3QgPSByZXF1aXJlKCcuL19pb2JqZWN0JylcbiAgLCBkZWZpbmVkID0gcmVxdWlyZSgnLi9fZGVmaW5lZCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCl7XG4gIHJldHVybiBJT2JqZWN0KGRlZmluZWQoaXQpKTtcbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL190by1pb2JqZWN0LmpzXG4vLyBtb2R1bGUgaWQgPSAzNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyBmYWxsYmFjayBmb3Igbm9uLWFycmF5LWxpa2UgRVMzIGFuZCBub24tZW51bWVyYWJsZSBvbGQgVjggc3RyaW5nc1xudmFyIGNvZiA9IHJlcXVpcmUoJy4vX2NvZicpO1xubW9kdWxlLmV4cG9ydHMgPSBPYmplY3QoJ3onKS5wcm9wZXJ0eUlzRW51bWVyYWJsZSgwKSA/IE9iamVjdCA6IGZ1bmN0aW9uKGl0KXtcbiAgcmV0dXJuIGNvZihpdCkgPT0gJ1N0cmluZycgPyBpdC5zcGxpdCgnJykgOiBPYmplY3QoaXQpO1xufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2lvYmplY3QuanNcbi8vIG1vZHVsZSBpZCA9IDM3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciB0b1N0cmluZyA9IHt9LnRvU3RyaW5nO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KXtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwoaXQpLnNsaWNlKDgsIC0xKTtcbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19jb2YuanNcbi8vIG1vZHVsZSBpZCA9IDM4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIGZhbHNlIC0+IEFycmF5I2luZGV4T2Zcbi8vIHRydWUgIC0+IEFycmF5I2luY2x1ZGVzXG52YXIgdG9JT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8taW9iamVjdCcpXG4gICwgdG9MZW5ndGggID0gcmVxdWlyZSgnLi9fdG8tbGVuZ3RoJylcbiAgLCB0b0luZGV4ICAgPSByZXF1aXJlKCcuL190by1pbmRleCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihJU19JTkNMVURFUyl7XG4gIHJldHVybiBmdW5jdGlvbigkdGhpcywgZWwsIGZyb21JbmRleCl7XG4gICAgdmFyIE8gICAgICA9IHRvSU9iamVjdCgkdGhpcylcbiAgICAgICwgbGVuZ3RoID0gdG9MZW5ndGgoTy5sZW5ndGgpXG4gICAgICAsIGluZGV4ICA9IHRvSW5kZXgoZnJvbUluZGV4LCBsZW5ndGgpXG4gICAgICAsIHZhbHVlO1xuICAgIC8vIEFycmF5I2luY2x1ZGVzIHVzZXMgU2FtZVZhbHVlWmVybyBlcXVhbGl0eSBhbGdvcml0aG1cbiAgICBpZihJU19JTkNMVURFUyAmJiBlbCAhPSBlbCl3aGlsZShsZW5ndGggPiBpbmRleCl7XG4gICAgICB2YWx1ZSA9IE9baW5kZXgrK107XG4gICAgICBpZih2YWx1ZSAhPSB2YWx1ZSlyZXR1cm4gdHJ1ZTtcbiAgICAvLyBBcnJheSN0b0luZGV4IGlnbm9yZXMgaG9sZXMsIEFycmF5I2luY2x1ZGVzIC0gbm90XG4gICAgfSBlbHNlIGZvcig7bGVuZ3RoID4gaW5kZXg7IGluZGV4KyspaWYoSVNfSU5DTFVERVMgfHwgaW5kZXggaW4gTyl7XG4gICAgICBpZihPW2luZGV4XSA9PT0gZWwpcmV0dXJuIElTX0lOQ0xVREVTIHx8IGluZGV4IHx8IDA7XG4gICAgfSByZXR1cm4gIUlTX0lOQ0xVREVTICYmIC0xO1xuICB9O1xufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2FycmF5LWluY2x1ZGVzLmpzXG4vLyBtb2R1bGUgaWQgPSAzOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyA3LjEuMTUgVG9MZW5ndGhcbnZhciB0b0ludGVnZXIgPSByZXF1aXJlKCcuL190by1pbnRlZ2VyJylcbiAgLCBtaW4gICAgICAgPSBNYXRoLm1pbjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQpe1xuICByZXR1cm4gaXQgPiAwID8gbWluKHRvSW50ZWdlcihpdCksIDB4MWZmZmZmZmZmZmZmZmYpIDogMDsgLy8gcG93KDIsIDUzKSAtIDEgPT0gOTAwNzE5OTI1NDc0MDk5MVxufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3RvLWxlbmd0aC5qc1xuLy8gbW9kdWxlIGlkID0gNDBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIHRvSW50ZWdlciA9IHJlcXVpcmUoJy4vX3RvLWludGVnZXInKVxuICAsIG1heCAgICAgICA9IE1hdGgubWF4XG4gICwgbWluICAgICAgID0gTWF0aC5taW47XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGluZGV4LCBsZW5ndGgpe1xuICBpbmRleCA9IHRvSW50ZWdlcihpbmRleCk7XG4gIHJldHVybiBpbmRleCA8IDAgPyBtYXgoaW5kZXggKyBsZW5ndGgsIDApIDogbWluKGluZGV4LCBsZW5ndGgpO1xufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3RvLWluZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSA0MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgc2hhcmVkID0gcmVxdWlyZSgnLi9fc2hhcmVkJykoJ2tleXMnKVxyXG4gICwgdWlkICAgID0gcmVxdWlyZSgnLi9fdWlkJyk7XHJcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oa2V5KXtcclxuICByZXR1cm4gc2hhcmVkW2tleV0gfHwgKHNoYXJlZFtrZXldID0gdWlkKGtleSkpO1xyXG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fc2hhcmVkLWtleS5qc1xuLy8gbW9kdWxlIGlkID0gNDJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpXG4gICwgU0hBUkVEID0gJ19fY29yZS1qc19zaGFyZWRfXydcbiAgLCBzdG9yZSAgPSBnbG9iYWxbU0hBUkVEXSB8fCAoZ2xvYmFsW1NIQVJFRF0gPSB7fSk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGtleSl7XG4gIHJldHVybiBzdG9yZVtrZXldIHx8IChzdG9yZVtrZXldID0ge30pO1xufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3NoYXJlZC5qc1xuLy8gbW9kdWxlIGlkID0gNDNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGlkID0gMFxuICAsIHB4ID0gTWF0aC5yYW5kb20oKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oa2V5KXtcbiAgcmV0dXJuICdTeW1ib2woJy5jb25jYXQoa2V5ID09PSB1bmRlZmluZWQgPyAnJyA6IGtleSwgJylfJywgKCsraWQgKyBweCkudG9TdHJpbmcoMzYpKTtcbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL191aWQuanNcbi8vIG1vZHVsZSBpZCA9IDQ0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIElFIDgtIGRvbid0IGVudW0gYnVnIGtleXNcclxubW9kdWxlLmV4cG9ydHMgPSAoXHJcbiAgJ2NvbnN0cnVjdG9yLGhhc093blByb3BlcnR5LGlzUHJvdG90eXBlT2YscHJvcGVydHlJc0VudW1lcmFibGUsdG9Mb2NhbGVTdHJpbmcsdG9TdHJpbmcsdmFsdWVPZidcclxuKS5zcGxpdCgnLCcpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZW51bS1idWcta2V5cy5qc1xuLy8gbW9kdWxlIGlkID0gNDVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL19nbG9iYWwnKS5kb2N1bWVudCAmJiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19odG1sLmpzXG4vLyBtb2R1bGUgaWQgPSA0NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgZGVmID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJykuZlxuICAsIGhhcyA9IHJlcXVpcmUoJy4vX2hhcycpXG4gICwgVEFHID0gcmVxdWlyZSgnLi9fd2tzJykoJ3RvU3RyaW5nVGFnJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQsIHRhZywgc3RhdCl7XG4gIGlmKGl0ICYmICFoYXMoaXQgPSBzdGF0ID8gaXQgOiBpdC5wcm90b3R5cGUsIFRBRykpZGVmKGl0LCBUQUcsIHtjb25maWd1cmFibGU6IHRydWUsIHZhbHVlOiB0YWd9KTtcbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19zZXQtdG8tc3RyaW5nLXRhZy5qc1xuLy8gbW9kdWxlIGlkID0gNDdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIHN0b3JlICAgICAgPSByZXF1aXJlKCcuL19zaGFyZWQnKSgnd2tzJylcbiAgLCB1aWQgICAgICAgID0gcmVxdWlyZSgnLi9fdWlkJylcbiAgLCBTeW1ib2wgICAgID0gcmVxdWlyZSgnLi9fZ2xvYmFsJykuU3ltYm9sXG4gICwgVVNFX1NZTUJPTCA9IHR5cGVvZiBTeW1ib2wgPT0gJ2Z1bmN0aW9uJztcblxudmFyICRleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihuYW1lKXtcbiAgcmV0dXJuIHN0b3JlW25hbWVdIHx8IChzdG9yZVtuYW1lXSA9XG4gICAgVVNFX1NZTUJPTCAmJiBTeW1ib2xbbmFtZV0gfHwgKFVTRV9TWU1CT0wgPyBTeW1ib2wgOiB1aWQpKCdTeW1ib2wuJyArIG5hbWUpKTtcbn07XG5cbiRleHBvcnRzLnN0b3JlID0gc3RvcmU7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL193a3MuanNcbi8vIG1vZHVsZSBpZCA9IDQ4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIDE5LjEuMi45IC8gMTUuMi4zLjIgT2JqZWN0LmdldFByb3RvdHlwZU9mKE8pXHJcbnZhciBoYXMgICAgICAgICA9IHJlcXVpcmUoJy4vX2hhcycpXHJcbiAgLCB0b09iamVjdCAgICA9IHJlcXVpcmUoJy4vX3RvLW9iamVjdCcpXHJcbiAgLCBJRV9QUk9UTyAgICA9IHJlcXVpcmUoJy4vX3NoYXJlZC1rZXknKSgnSUVfUFJPVE8nKVxyXG4gICwgT2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YgfHwgZnVuY3Rpb24oTyl7XHJcbiAgTyA9IHRvT2JqZWN0KE8pO1xyXG4gIGlmKGhhcyhPLCBJRV9QUk9UTykpcmV0dXJuIE9bSUVfUFJPVE9dO1xyXG4gIGlmKHR5cGVvZiBPLmNvbnN0cnVjdG9yID09ICdmdW5jdGlvbicgJiYgTyBpbnN0YW5jZW9mIE8uY29uc3RydWN0b3Ipe1xyXG4gICAgcmV0dXJuIE8uY29uc3RydWN0b3IucHJvdG90eXBlO1xyXG4gIH0gcmV0dXJuIE8gaW5zdGFuY2VvZiBPYmplY3QgPyBPYmplY3RQcm90byA6IG51bGw7XHJcbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3QtZ3BvLmpzXG4vLyBtb2R1bGUgaWQgPSA0OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyA3LjEuMTMgVG9PYmplY3QoYXJndW1lbnQpXG52YXIgZGVmaW5lZCA9IHJlcXVpcmUoJy4vX2RlZmluZWQnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQpe1xuICByZXR1cm4gT2JqZWN0KGRlZmluZWQoaXQpKTtcbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL190by1vYmplY3QuanNcbi8vIG1vZHVsZSBpZCA9IDUwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInJlcXVpcmUoJy4vZXM2LmFycmF5Lml0ZXJhdG9yJyk7XG52YXIgZ2xvYmFsICAgICAgICA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpXG4gICwgaGlkZSAgICAgICAgICA9IHJlcXVpcmUoJy4vX2hpZGUnKVxuICAsIEl0ZXJhdG9ycyAgICAgPSByZXF1aXJlKCcuL19pdGVyYXRvcnMnKVxuICAsIFRPX1NUUklOR19UQUcgPSByZXF1aXJlKCcuL193a3MnKSgndG9TdHJpbmdUYWcnKTtcblxuZm9yKHZhciBjb2xsZWN0aW9ucyA9IFsnTm9kZUxpc3QnLCAnRE9NVG9rZW5MaXN0JywgJ01lZGlhTGlzdCcsICdTdHlsZVNoZWV0TGlzdCcsICdDU1NSdWxlTGlzdCddLCBpID0gMDsgaSA8IDU7IGkrKyl7XG4gIHZhciBOQU1FICAgICAgID0gY29sbGVjdGlvbnNbaV1cbiAgICAsIENvbGxlY3Rpb24gPSBnbG9iYWxbTkFNRV1cbiAgICAsIHByb3RvICAgICAgPSBDb2xsZWN0aW9uICYmIENvbGxlY3Rpb24ucHJvdG90eXBlO1xuICBpZihwcm90byAmJiAhcHJvdG9bVE9fU1RSSU5HX1RBR10paGlkZShwcm90bywgVE9fU1RSSU5HX1RBRywgTkFNRSk7XG4gIEl0ZXJhdG9yc1tOQU1FXSA9IEl0ZXJhdG9ycy5BcnJheTtcbn1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvd2ViLmRvbS5pdGVyYWJsZS5qc1xuLy8gbW9kdWxlIGlkID0gNTFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGFkZFRvVW5zY29wYWJsZXMgPSByZXF1aXJlKCcuL19hZGQtdG8tdW5zY29wYWJsZXMnKVxuICAsIHN0ZXAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19pdGVyLXN0ZXAnKVxuICAsIEl0ZXJhdG9ycyAgICAgICAgPSByZXF1aXJlKCcuL19pdGVyYXRvcnMnKVxuICAsIHRvSU9iamVjdCAgICAgICAgPSByZXF1aXJlKCcuL190by1pb2JqZWN0Jyk7XG5cbi8vIDIyLjEuMy40IEFycmF5LnByb3RvdHlwZS5lbnRyaWVzKClcbi8vIDIyLjEuMy4xMyBBcnJheS5wcm90b3R5cGUua2V5cygpXG4vLyAyMi4xLjMuMjkgQXJyYXkucHJvdG90eXBlLnZhbHVlcygpXG4vLyAyMi4xLjMuMzAgQXJyYXkucHJvdG90eXBlW0BAaXRlcmF0b3JdKClcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9faXRlci1kZWZpbmUnKShBcnJheSwgJ0FycmF5JywgZnVuY3Rpb24oaXRlcmF0ZWQsIGtpbmQpe1xuICB0aGlzLl90ID0gdG9JT2JqZWN0KGl0ZXJhdGVkKTsgLy8gdGFyZ2V0XG4gIHRoaXMuX2kgPSAwOyAgICAgICAgICAgICAgICAgICAvLyBuZXh0IGluZGV4XG4gIHRoaXMuX2sgPSBraW5kOyAgICAgICAgICAgICAgICAvLyBraW5kXG4vLyAyMi4xLjUuMi4xICVBcnJheUl0ZXJhdG9yUHJvdG90eXBlJS5uZXh0KClcbn0sIGZ1bmN0aW9uKCl7XG4gIHZhciBPICAgICA9IHRoaXMuX3RcbiAgICAsIGtpbmQgID0gdGhpcy5fa1xuICAgICwgaW5kZXggPSB0aGlzLl9pKys7XG4gIGlmKCFPIHx8IGluZGV4ID49IE8ubGVuZ3RoKXtcbiAgICB0aGlzLl90ID0gdW5kZWZpbmVkO1xuICAgIHJldHVybiBzdGVwKDEpO1xuICB9XG4gIGlmKGtpbmQgPT0gJ2tleXMnICApcmV0dXJuIHN0ZXAoMCwgaW5kZXgpO1xuICBpZihraW5kID09ICd2YWx1ZXMnKXJldHVybiBzdGVwKDAsIE9baW5kZXhdKTtcbiAgcmV0dXJuIHN0ZXAoMCwgW2luZGV4LCBPW2luZGV4XV0pO1xufSwgJ3ZhbHVlcycpO1xuXG4vLyBhcmd1bWVudHNMaXN0W0BAaXRlcmF0b3JdIGlzICVBcnJheVByb3RvX3ZhbHVlcyUgKDkuNC40LjYsIDkuNC40LjcpXG5JdGVyYXRvcnMuQXJndW1lbnRzID0gSXRlcmF0b3JzLkFycmF5O1xuXG5hZGRUb1Vuc2NvcGFibGVzKCdrZXlzJyk7XG5hZGRUb1Vuc2NvcGFibGVzKCd2YWx1ZXMnKTtcbmFkZFRvVW5zY29wYWJsZXMoJ2VudHJpZXMnKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM2LmFycmF5Lml0ZXJhdG9yLmpzXG4vLyBtb2R1bGUgaWQgPSA1MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKCl7IC8qIGVtcHR5ICovIH07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19hZGQtdG8tdW5zY29wYWJsZXMuanNcbi8vIG1vZHVsZSBpZCA9IDUzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oZG9uZSwgdmFsdWUpe1xuICByZXR1cm4ge3ZhbHVlOiB2YWx1ZSwgZG9uZTogISFkb25lfTtcbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19pdGVyLXN0ZXAuanNcbi8vIG1vZHVsZSBpZCA9IDU0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImV4cG9ydHMuZiA9IHJlcXVpcmUoJy4vX3drcycpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fd2tzLWV4dC5qc1xuLy8gbW9kdWxlIGlkID0gNTVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSB7IFwiZGVmYXVsdFwiOiByZXF1aXJlKFwiY29yZS1qcy9saWJyYXJ5L2ZuL3N5bWJvbFwiKSwgX19lc01vZHVsZTogdHJ1ZSB9O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9iYWJlbC1ydW50aW1lL2NvcmUtanMvc3ltYm9sLmpzXG4vLyBtb2R1bGUgaWQgPSA1NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJyZXF1aXJlKCcuLi8uLi9tb2R1bGVzL2VzNi5zeW1ib2wnKTtcbnJlcXVpcmUoJy4uLy4uL21vZHVsZXMvZXM2Lm9iamVjdC50by1zdHJpbmcnKTtcbnJlcXVpcmUoJy4uLy4uL21vZHVsZXMvZXM3LnN5bWJvbC5hc3luYy1pdGVyYXRvcicpO1xucmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9lczcuc3ltYm9sLm9ic2VydmFibGUnKTtcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9fY29yZScpLlN5bWJvbDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9saWJyYXJ5L2ZuL3N5bWJvbC9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gNTdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuLy8gRUNNQVNjcmlwdCA2IHN5bWJvbHMgc2hpbVxudmFyIGdsb2JhbCAgICAgICAgID0gcmVxdWlyZSgnLi9fZ2xvYmFsJylcbiAgLCBoYXMgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2hhcycpXG4gICwgREVTQ1JJUFRPUlMgICAgPSByZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpXG4gICwgJGV4cG9ydCAgICAgICAgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsIHJlZGVmaW5lICAgICAgID0gcmVxdWlyZSgnLi9fcmVkZWZpbmUnKVxuICAsIE1FVEEgICAgICAgICAgID0gcmVxdWlyZSgnLi9fbWV0YScpLktFWVxuICAsICRmYWlscyAgICAgICAgID0gcmVxdWlyZSgnLi9fZmFpbHMnKVxuICAsIHNoYXJlZCAgICAgICAgID0gcmVxdWlyZSgnLi9fc2hhcmVkJylcbiAgLCBzZXRUb1N0cmluZ1RhZyA9IHJlcXVpcmUoJy4vX3NldC10by1zdHJpbmctdGFnJylcbiAgLCB1aWQgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX3VpZCcpXG4gICwgd2tzICAgICAgICAgICAgPSByZXF1aXJlKCcuL193a3MnKVxuICAsIHdrc0V4dCAgICAgICAgID0gcmVxdWlyZSgnLi9fd2tzLWV4dCcpXG4gICwgd2tzRGVmaW5lICAgICAgPSByZXF1aXJlKCcuL193a3MtZGVmaW5lJylcbiAgLCBrZXlPZiAgICAgICAgICA9IHJlcXVpcmUoJy4vX2tleW9mJylcbiAgLCBlbnVtS2V5cyAgICAgICA9IHJlcXVpcmUoJy4vX2VudW0ta2V5cycpXG4gICwgaXNBcnJheSAgICAgICAgPSByZXF1aXJlKCcuL19pcy1hcnJheScpXG4gICwgYW5PYmplY3QgICAgICAgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKVxuICAsIHRvSU9iamVjdCAgICAgID0gcmVxdWlyZSgnLi9fdG8taW9iamVjdCcpXG4gICwgdG9QcmltaXRpdmUgICAgPSByZXF1aXJlKCcuL190by1wcmltaXRpdmUnKVxuICAsIGNyZWF0ZURlc2MgICAgID0gcmVxdWlyZSgnLi9fcHJvcGVydHktZGVzYycpXG4gICwgX2NyZWF0ZSAgICAgICAgPSByZXF1aXJlKCcuL19vYmplY3QtY3JlYXRlJylcbiAgLCBnT1BORXh0ICAgICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BuLWV4dCcpXG4gICwgJEdPUEQgICAgICAgICAgPSByZXF1aXJlKCcuL19vYmplY3QtZ29wZCcpXG4gICwgJERQICAgICAgICAgICAgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKVxuICAsICRrZXlzICAgICAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWtleXMnKVxuICAsIGdPUEQgICAgICAgICAgID0gJEdPUEQuZlxuICAsIGRQICAgICAgICAgICAgID0gJERQLmZcbiAgLCBnT1BOICAgICAgICAgICA9IGdPUE5FeHQuZlxuICAsICRTeW1ib2wgICAgICAgID0gZ2xvYmFsLlN5bWJvbFxuICAsICRKU09OICAgICAgICAgID0gZ2xvYmFsLkpTT05cbiAgLCBfc3RyaW5naWZ5ICAgICA9ICRKU09OICYmICRKU09OLnN0cmluZ2lmeVxuICAsIFBST1RPVFlQRSAgICAgID0gJ3Byb3RvdHlwZSdcbiAgLCBISURERU4gICAgICAgICA9IHdrcygnX2hpZGRlbicpXG4gICwgVE9fUFJJTUlUSVZFICAgPSB3a3MoJ3RvUHJpbWl0aXZlJylcbiAgLCBpc0VudW0gICAgICAgICA9IHt9LnByb3BlcnR5SXNFbnVtZXJhYmxlXG4gICwgU3ltYm9sUmVnaXN0cnkgPSBzaGFyZWQoJ3N5bWJvbC1yZWdpc3RyeScpXG4gICwgQWxsU3ltYm9scyAgICAgPSBzaGFyZWQoJ3N5bWJvbHMnKVxuICAsIE9QU3ltYm9scyAgICAgID0gc2hhcmVkKCdvcC1zeW1ib2xzJylcbiAgLCBPYmplY3RQcm90byAgICA9IE9iamVjdFtQUk9UT1RZUEVdXG4gICwgVVNFX05BVElWRSAgICAgPSB0eXBlb2YgJFN5bWJvbCA9PSAnZnVuY3Rpb24nXG4gICwgUU9iamVjdCAgICAgICAgPSBnbG9iYWwuUU9iamVjdDtcbi8vIERvbid0IHVzZSBzZXR0ZXJzIGluIFF0IFNjcmlwdCwgaHR0cHM6Ly9naXRodWIuY29tL3psb2lyb2NrL2NvcmUtanMvaXNzdWVzLzE3M1xudmFyIHNldHRlciA9ICFRT2JqZWN0IHx8ICFRT2JqZWN0W1BST1RPVFlQRV0gfHwgIVFPYmplY3RbUFJPVE9UWVBFXS5maW5kQ2hpbGQ7XG5cbi8vIGZhbGxiYWNrIGZvciBvbGQgQW5kcm9pZCwgaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTY4N1xudmFyIHNldFN5bWJvbERlc2MgPSBERVNDUklQVE9SUyAmJiAkZmFpbHMoZnVuY3Rpb24oKXtcbiAgcmV0dXJuIF9jcmVhdGUoZFAoe30sICdhJywge1xuICAgIGdldDogZnVuY3Rpb24oKXsgcmV0dXJuIGRQKHRoaXMsICdhJywge3ZhbHVlOiA3fSkuYTsgfVxuICB9KSkuYSAhPSA3O1xufSkgPyBmdW5jdGlvbihpdCwga2V5LCBEKXtcbiAgdmFyIHByb3RvRGVzYyA9IGdPUEQoT2JqZWN0UHJvdG8sIGtleSk7XG4gIGlmKHByb3RvRGVzYylkZWxldGUgT2JqZWN0UHJvdG9ba2V5XTtcbiAgZFAoaXQsIGtleSwgRCk7XG4gIGlmKHByb3RvRGVzYyAmJiBpdCAhPT0gT2JqZWN0UHJvdG8pZFAoT2JqZWN0UHJvdG8sIGtleSwgcHJvdG9EZXNjKTtcbn0gOiBkUDtcblxudmFyIHdyYXAgPSBmdW5jdGlvbih0YWcpe1xuICB2YXIgc3ltID0gQWxsU3ltYm9sc1t0YWddID0gX2NyZWF0ZSgkU3ltYm9sW1BST1RPVFlQRV0pO1xuICBzeW0uX2sgPSB0YWc7XG4gIHJldHVybiBzeW07XG59O1xuXG52YXIgaXNTeW1ib2wgPSBVU0VfTkFUSVZFICYmIHR5cGVvZiAkU3ltYm9sLml0ZXJhdG9yID09ICdzeW1ib2wnID8gZnVuY3Rpb24oaXQpe1xuICByZXR1cm4gdHlwZW9mIGl0ID09ICdzeW1ib2wnO1xufSA6IGZ1bmN0aW9uKGl0KXtcbiAgcmV0dXJuIGl0IGluc3RhbmNlb2YgJFN5bWJvbDtcbn07XG5cbnZhciAkZGVmaW5lUHJvcGVydHkgPSBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0eShpdCwga2V5LCBEKXtcbiAgaWYoaXQgPT09IE9iamVjdFByb3RvKSRkZWZpbmVQcm9wZXJ0eShPUFN5bWJvbHMsIGtleSwgRCk7XG4gIGFuT2JqZWN0KGl0KTtcbiAga2V5ID0gdG9QcmltaXRpdmUoa2V5LCB0cnVlKTtcbiAgYW5PYmplY3QoRCk7XG4gIGlmKGhhcyhBbGxTeW1ib2xzLCBrZXkpKXtcbiAgICBpZighRC5lbnVtZXJhYmxlKXtcbiAgICAgIGlmKCFoYXMoaXQsIEhJRERFTikpZFAoaXQsIEhJRERFTiwgY3JlYXRlRGVzYygxLCB7fSkpO1xuICAgICAgaXRbSElEREVOXVtrZXldID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYoaGFzKGl0LCBISURERU4pICYmIGl0W0hJRERFTl1ba2V5XSlpdFtISURERU5dW2tleV0gPSBmYWxzZTtcbiAgICAgIEQgPSBfY3JlYXRlKEQsIHtlbnVtZXJhYmxlOiBjcmVhdGVEZXNjKDAsIGZhbHNlKX0pO1xuICAgIH0gcmV0dXJuIHNldFN5bWJvbERlc2MoaXQsIGtleSwgRCk7XG4gIH0gcmV0dXJuIGRQKGl0LCBrZXksIEQpO1xufTtcbnZhciAkZGVmaW5lUHJvcGVydGllcyA9IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXMoaXQsIFApe1xuICBhbk9iamVjdChpdCk7XG4gIHZhciBrZXlzID0gZW51bUtleXMoUCA9IHRvSU9iamVjdChQKSlcbiAgICAsIGkgICAgPSAwXG4gICAgLCBsID0ga2V5cy5sZW5ndGhcbiAgICAsIGtleTtcbiAgd2hpbGUobCA+IGkpJGRlZmluZVByb3BlcnR5KGl0LCBrZXkgPSBrZXlzW2krK10sIFBba2V5XSk7XG4gIHJldHVybiBpdDtcbn07XG52YXIgJGNyZWF0ZSA9IGZ1bmN0aW9uIGNyZWF0ZShpdCwgUCl7XG4gIHJldHVybiBQID09PSB1bmRlZmluZWQgPyBfY3JlYXRlKGl0KSA6ICRkZWZpbmVQcm9wZXJ0aWVzKF9jcmVhdGUoaXQpLCBQKTtcbn07XG52YXIgJHByb3BlcnR5SXNFbnVtZXJhYmxlID0gZnVuY3Rpb24gcHJvcGVydHlJc0VudW1lcmFibGUoa2V5KXtcbiAgdmFyIEUgPSBpc0VudW0uY2FsbCh0aGlzLCBrZXkgPSB0b1ByaW1pdGl2ZShrZXksIHRydWUpKTtcbiAgaWYodGhpcyA9PT0gT2JqZWN0UHJvdG8gJiYgaGFzKEFsbFN5bWJvbHMsIGtleSkgJiYgIWhhcyhPUFN5bWJvbHMsIGtleSkpcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gRSB8fCAhaGFzKHRoaXMsIGtleSkgfHwgIWhhcyhBbGxTeW1ib2xzLCBrZXkpIHx8IGhhcyh0aGlzLCBISURERU4pICYmIHRoaXNbSElEREVOXVtrZXldID8gRSA6IHRydWU7XG59O1xudmFyICRnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPSBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoaXQsIGtleSl7XG4gIGl0ICA9IHRvSU9iamVjdChpdCk7XG4gIGtleSA9IHRvUHJpbWl0aXZlKGtleSwgdHJ1ZSk7XG4gIGlmKGl0ID09PSBPYmplY3RQcm90byAmJiBoYXMoQWxsU3ltYm9scywga2V5KSAmJiAhaGFzKE9QU3ltYm9scywga2V5KSlyZXR1cm47XG4gIHZhciBEID0gZ09QRChpdCwga2V5KTtcbiAgaWYoRCAmJiBoYXMoQWxsU3ltYm9scywga2V5KSAmJiAhKGhhcyhpdCwgSElEREVOKSAmJiBpdFtISURERU5dW2tleV0pKUQuZW51bWVyYWJsZSA9IHRydWU7XG4gIHJldHVybiBEO1xufTtcbnZhciAkZ2V0T3duUHJvcGVydHlOYW1lcyA9IGZ1bmN0aW9uIGdldE93blByb3BlcnR5TmFtZXMoaXQpe1xuICB2YXIgbmFtZXMgID0gZ09QTih0b0lPYmplY3QoaXQpKVxuICAgICwgcmVzdWx0ID0gW11cbiAgICAsIGkgICAgICA9IDBcbiAgICAsIGtleTtcbiAgd2hpbGUobmFtZXMubGVuZ3RoID4gaSl7XG4gICAgaWYoIWhhcyhBbGxTeW1ib2xzLCBrZXkgPSBuYW1lc1tpKytdKSAmJiBrZXkgIT0gSElEREVOICYmIGtleSAhPSBNRVRBKXJlc3VsdC5wdXNoKGtleSk7XG4gIH0gcmV0dXJuIHJlc3VsdDtcbn07XG52YXIgJGdldE93blByb3BlcnR5U3ltYm9scyA9IGZ1bmN0aW9uIGdldE93blByb3BlcnR5U3ltYm9scyhpdCl7XG4gIHZhciBJU19PUCAgPSBpdCA9PT0gT2JqZWN0UHJvdG9cbiAgICAsIG5hbWVzICA9IGdPUE4oSVNfT1AgPyBPUFN5bWJvbHMgOiB0b0lPYmplY3QoaXQpKVxuICAgICwgcmVzdWx0ID0gW11cbiAgICAsIGkgICAgICA9IDBcbiAgICAsIGtleTtcbiAgd2hpbGUobmFtZXMubGVuZ3RoID4gaSl7XG4gICAgaWYoaGFzKEFsbFN5bWJvbHMsIGtleSA9IG5hbWVzW2krK10pICYmIChJU19PUCA/IGhhcyhPYmplY3RQcm90bywga2V5KSA6IHRydWUpKXJlc3VsdC5wdXNoKEFsbFN5bWJvbHNba2V5XSk7XG4gIH0gcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8vIDE5LjQuMS4xIFN5bWJvbChbZGVzY3JpcHRpb25dKVxuaWYoIVVTRV9OQVRJVkUpe1xuICAkU3ltYm9sID0gZnVuY3Rpb24gU3ltYm9sKCl7XG4gICAgaWYodGhpcyBpbnN0YW5jZW9mICRTeW1ib2wpdGhyb3cgVHlwZUVycm9yKCdTeW1ib2wgaXMgbm90IGEgY29uc3RydWN0b3IhJyk7XG4gICAgdmFyIHRhZyA9IHVpZChhcmd1bWVudHMubGVuZ3RoID4gMCA/IGFyZ3VtZW50c1swXSA6IHVuZGVmaW5lZCk7XG4gICAgdmFyICRzZXQgPSBmdW5jdGlvbih2YWx1ZSl7XG4gICAgICBpZih0aGlzID09PSBPYmplY3RQcm90bykkc2V0LmNhbGwoT1BTeW1ib2xzLCB2YWx1ZSk7XG4gICAgICBpZihoYXModGhpcywgSElEREVOKSAmJiBoYXModGhpc1tISURERU5dLCB0YWcpKXRoaXNbSElEREVOXVt0YWddID0gZmFsc2U7XG4gICAgICBzZXRTeW1ib2xEZXNjKHRoaXMsIHRhZywgY3JlYXRlRGVzYygxLCB2YWx1ZSkpO1xuICAgIH07XG4gICAgaWYoREVTQ1JJUFRPUlMgJiYgc2V0dGVyKXNldFN5bWJvbERlc2MoT2JqZWN0UHJvdG8sIHRhZywge2NvbmZpZ3VyYWJsZTogdHJ1ZSwgc2V0OiAkc2V0fSk7XG4gICAgcmV0dXJuIHdyYXAodGFnKTtcbiAgfTtcbiAgcmVkZWZpbmUoJFN5bWJvbFtQUk9UT1RZUEVdLCAndG9TdHJpbmcnLCBmdW5jdGlvbiB0b1N0cmluZygpe1xuICAgIHJldHVybiB0aGlzLl9rO1xuICB9KTtcblxuICAkR09QRC5mID0gJGdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcbiAgJERQLmYgICA9ICRkZWZpbmVQcm9wZXJ0eTtcbiAgcmVxdWlyZSgnLi9fb2JqZWN0LWdvcG4nKS5mID0gZ09QTkV4dC5mID0gJGdldE93blByb3BlcnR5TmFtZXM7XG4gIHJlcXVpcmUoJy4vX29iamVjdC1waWUnKS5mICA9ICRwcm9wZXJ0eUlzRW51bWVyYWJsZTtcbiAgcmVxdWlyZSgnLi9fb2JqZWN0LWdvcHMnKS5mID0gJGdldE93blByb3BlcnR5U3ltYm9scztcblxuICBpZihERVNDUklQVE9SUyAmJiAhcmVxdWlyZSgnLi9fbGlicmFyeScpKXtcbiAgICByZWRlZmluZShPYmplY3RQcm90bywgJ3Byb3BlcnR5SXNFbnVtZXJhYmxlJywgJHByb3BlcnR5SXNFbnVtZXJhYmxlLCB0cnVlKTtcbiAgfVxuXG4gIHdrc0V4dC5mID0gZnVuY3Rpb24obmFtZSl7XG4gICAgcmV0dXJuIHdyYXAod2tzKG5hbWUpKTtcbiAgfVxufVxuXG4kZXhwb3J0KCRleHBvcnQuRyArICRleHBvcnQuVyArICRleHBvcnQuRiAqICFVU0VfTkFUSVZFLCB7U3ltYm9sOiAkU3ltYm9sfSk7XG5cbmZvcih2YXIgc3ltYm9scyA9IChcbiAgLy8gMTkuNC4yLjIsIDE5LjQuMi4zLCAxOS40LjIuNCwgMTkuNC4yLjYsIDE5LjQuMi44LCAxOS40LjIuOSwgMTkuNC4yLjEwLCAxOS40LjIuMTEsIDE5LjQuMi4xMiwgMTkuNC4yLjEzLCAxOS40LjIuMTRcbiAgJ2hhc0luc3RhbmNlLGlzQ29uY2F0U3ByZWFkYWJsZSxpdGVyYXRvcixtYXRjaCxyZXBsYWNlLHNlYXJjaCxzcGVjaWVzLHNwbGl0LHRvUHJpbWl0aXZlLHRvU3RyaW5nVGFnLHVuc2NvcGFibGVzJ1xuKS5zcGxpdCgnLCcpLCBpID0gMDsgc3ltYm9scy5sZW5ndGggPiBpOyApd2tzKHN5bWJvbHNbaSsrXSk7XG5cbmZvcih2YXIgc3ltYm9scyA9ICRrZXlzKHdrcy5zdG9yZSksIGkgPSAwOyBzeW1ib2xzLmxlbmd0aCA+IGk7ICl3a3NEZWZpbmUoc3ltYm9sc1tpKytdKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAhVVNFX05BVElWRSwgJ1N5bWJvbCcsIHtcbiAgLy8gMTkuNC4yLjEgU3ltYm9sLmZvcihrZXkpXG4gICdmb3InOiBmdW5jdGlvbihrZXkpe1xuICAgIHJldHVybiBoYXMoU3ltYm9sUmVnaXN0cnksIGtleSArPSAnJylcbiAgICAgID8gU3ltYm9sUmVnaXN0cnlba2V5XVxuICAgICAgOiBTeW1ib2xSZWdpc3RyeVtrZXldID0gJFN5bWJvbChrZXkpO1xuICB9LFxuICAvLyAxOS40LjIuNSBTeW1ib2wua2V5Rm9yKHN5bSlcbiAga2V5Rm9yOiBmdW5jdGlvbiBrZXlGb3Ioa2V5KXtcbiAgICBpZihpc1N5bWJvbChrZXkpKXJldHVybiBrZXlPZihTeW1ib2xSZWdpc3RyeSwga2V5KTtcbiAgICB0aHJvdyBUeXBlRXJyb3Ioa2V5ICsgJyBpcyBub3QgYSBzeW1ib2whJyk7XG4gIH0sXG4gIHVzZVNldHRlcjogZnVuY3Rpb24oKXsgc2V0dGVyID0gdHJ1ZTsgfSxcbiAgdXNlU2ltcGxlOiBmdW5jdGlvbigpeyBzZXR0ZXIgPSBmYWxzZTsgfVxufSk7XG5cbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogIVVTRV9OQVRJVkUsICdPYmplY3QnLCB7XG4gIC8vIDE5LjEuMi4yIE9iamVjdC5jcmVhdGUoTyBbLCBQcm9wZXJ0aWVzXSlcbiAgY3JlYXRlOiAkY3JlYXRlLFxuICAvLyAxOS4xLjIuNCBPYmplY3QuZGVmaW5lUHJvcGVydHkoTywgUCwgQXR0cmlidXRlcylcbiAgZGVmaW5lUHJvcGVydHk6ICRkZWZpbmVQcm9wZXJ0eSxcbiAgLy8gMTkuMS4yLjMgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoTywgUHJvcGVydGllcylcbiAgZGVmaW5lUHJvcGVydGllczogJGRlZmluZVByb3BlcnRpZXMsXG4gIC8vIDE5LjEuMi42IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoTywgUClcbiAgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yOiAkZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yLFxuICAvLyAxOS4xLjIuNyBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhPKVxuICBnZXRPd25Qcm9wZXJ0eU5hbWVzOiAkZ2V0T3duUHJvcGVydHlOYW1lcyxcbiAgLy8gMTkuMS4yLjggT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhPKVxuICBnZXRPd25Qcm9wZXJ0eVN5bWJvbHM6ICRnZXRPd25Qcm9wZXJ0eVN5bWJvbHNcbn0pO1xuXG4vLyAyNC4zLjIgSlNPTi5zdHJpbmdpZnkodmFsdWUgWywgcmVwbGFjZXIgWywgc3BhY2VdXSlcbiRKU09OICYmICRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogKCFVU0VfTkFUSVZFIHx8ICRmYWlscyhmdW5jdGlvbigpe1xuICB2YXIgUyA9ICRTeW1ib2woKTtcbiAgLy8gTVMgRWRnZSBjb252ZXJ0cyBzeW1ib2wgdmFsdWVzIHRvIEpTT04gYXMge31cbiAgLy8gV2ViS2l0IGNvbnZlcnRzIHN5bWJvbCB2YWx1ZXMgdG8gSlNPTiBhcyBudWxsXG4gIC8vIFY4IHRocm93cyBvbiBib3hlZCBzeW1ib2xzXG4gIHJldHVybiBfc3RyaW5naWZ5KFtTXSkgIT0gJ1tudWxsXScgfHwgX3N0cmluZ2lmeSh7YTogU30pICE9ICd7fScgfHwgX3N0cmluZ2lmeShPYmplY3QoUykpICE9ICd7fSc7XG59KSksICdKU09OJywge1xuICBzdHJpbmdpZnk6IGZ1bmN0aW9uIHN0cmluZ2lmeShpdCl7XG4gICAgaWYoaXQgPT09IHVuZGVmaW5lZCB8fCBpc1N5bWJvbChpdCkpcmV0dXJuOyAvLyBJRTggcmV0dXJucyBzdHJpbmcgb24gdW5kZWZpbmVkXG4gICAgdmFyIGFyZ3MgPSBbaXRdXG4gICAgICAsIGkgICAgPSAxXG4gICAgICAsIHJlcGxhY2VyLCAkcmVwbGFjZXI7XG4gICAgd2hpbGUoYXJndW1lbnRzLmxlbmd0aCA+IGkpYXJncy5wdXNoKGFyZ3VtZW50c1tpKytdKTtcbiAgICByZXBsYWNlciA9IGFyZ3NbMV07XG4gICAgaWYodHlwZW9mIHJlcGxhY2VyID09ICdmdW5jdGlvbicpJHJlcGxhY2VyID0gcmVwbGFjZXI7XG4gICAgaWYoJHJlcGxhY2VyIHx8ICFpc0FycmF5KHJlcGxhY2VyKSlyZXBsYWNlciA9IGZ1bmN0aW9uKGtleSwgdmFsdWUpe1xuICAgICAgaWYoJHJlcGxhY2VyKXZhbHVlID0gJHJlcGxhY2VyLmNhbGwodGhpcywga2V5LCB2YWx1ZSk7XG4gICAgICBpZighaXNTeW1ib2wodmFsdWUpKXJldHVybiB2YWx1ZTtcbiAgICB9O1xuICAgIGFyZ3NbMV0gPSByZXBsYWNlcjtcbiAgICByZXR1cm4gX3N0cmluZ2lmeS5hcHBseSgkSlNPTiwgYXJncyk7XG4gIH1cbn0pO1xuXG4vLyAxOS40LjMuNCBTeW1ib2wucHJvdG90eXBlW0BAdG9QcmltaXRpdmVdKGhpbnQpXG4kU3ltYm9sW1BST1RPVFlQRV1bVE9fUFJJTUlUSVZFXSB8fCByZXF1aXJlKCcuL19oaWRlJykoJFN5bWJvbFtQUk9UT1RZUEVdLCBUT19QUklNSVRJVkUsICRTeW1ib2xbUFJPVE9UWVBFXS52YWx1ZU9mKTtcbi8vIDE5LjQuMy41IFN5bWJvbC5wcm90b3R5cGVbQEB0b1N0cmluZ1RhZ11cbnNldFRvU3RyaW5nVGFnKCRTeW1ib2wsICdTeW1ib2wnKTtcbi8vIDIwLjIuMS45IE1hdGhbQEB0b1N0cmluZ1RhZ11cbnNldFRvU3RyaW5nVGFnKE1hdGgsICdNYXRoJywgdHJ1ZSk7XG4vLyAyNC4zLjMgSlNPTltAQHRvU3RyaW5nVGFnXVxuc2V0VG9TdHJpbmdUYWcoZ2xvYmFsLkpTT04sICdKU09OJywgdHJ1ZSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNi5zeW1ib2wuanNcbi8vIG1vZHVsZSBpZCA9IDU4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBNRVRBICAgICA9IHJlcXVpcmUoJy4vX3VpZCcpKCdtZXRhJylcbiAgLCBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpXG4gICwgaGFzICAgICAgPSByZXF1aXJlKCcuL19oYXMnKVxuICAsIHNldERlc2MgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJykuZlxuICAsIGlkICAgICAgID0gMDtcbnZhciBpc0V4dGVuc2libGUgPSBPYmplY3QuaXNFeHRlbnNpYmxlIHx8IGZ1bmN0aW9uKCl7XG4gIHJldHVybiB0cnVlO1xufTtcbnZhciBGUkVFWkUgPSAhcmVxdWlyZSgnLi9fZmFpbHMnKShmdW5jdGlvbigpe1xuICByZXR1cm4gaXNFeHRlbnNpYmxlKE9iamVjdC5wcmV2ZW50RXh0ZW5zaW9ucyh7fSkpO1xufSk7XG52YXIgc2V0TWV0YSA9IGZ1bmN0aW9uKGl0KXtcbiAgc2V0RGVzYyhpdCwgTUVUQSwge3ZhbHVlOiB7XG4gICAgaTogJ08nICsgKytpZCwgLy8gb2JqZWN0IElEXG4gICAgdzoge30gICAgICAgICAgLy8gd2VhayBjb2xsZWN0aW9ucyBJRHNcbiAgfX0pO1xufTtcbnZhciBmYXN0S2V5ID0gZnVuY3Rpb24oaXQsIGNyZWF0ZSl7XG4gIC8vIHJldHVybiBwcmltaXRpdmUgd2l0aCBwcmVmaXhcbiAgaWYoIWlzT2JqZWN0KGl0KSlyZXR1cm4gdHlwZW9mIGl0ID09ICdzeW1ib2wnID8gaXQgOiAodHlwZW9mIGl0ID09ICdzdHJpbmcnID8gJ1MnIDogJ1AnKSArIGl0O1xuICBpZighaGFzKGl0LCBNRVRBKSl7XG4gICAgLy8gY2FuJ3Qgc2V0IG1ldGFkYXRhIHRvIHVuY2F1Z2h0IGZyb3plbiBvYmplY3RcbiAgICBpZighaXNFeHRlbnNpYmxlKGl0KSlyZXR1cm4gJ0YnO1xuICAgIC8vIG5vdCBuZWNlc3NhcnkgdG8gYWRkIG1ldGFkYXRhXG4gICAgaWYoIWNyZWF0ZSlyZXR1cm4gJ0UnO1xuICAgIC8vIGFkZCBtaXNzaW5nIG1ldGFkYXRhXG4gICAgc2V0TWV0YShpdCk7XG4gIC8vIHJldHVybiBvYmplY3QgSURcbiAgfSByZXR1cm4gaXRbTUVUQV0uaTtcbn07XG52YXIgZ2V0V2VhayA9IGZ1bmN0aW9uKGl0LCBjcmVhdGUpe1xuICBpZighaGFzKGl0LCBNRVRBKSl7XG4gICAgLy8gY2FuJ3Qgc2V0IG1ldGFkYXRhIHRvIHVuY2F1Z2h0IGZyb3plbiBvYmplY3RcbiAgICBpZighaXNFeHRlbnNpYmxlKGl0KSlyZXR1cm4gdHJ1ZTtcbiAgICAvLyBub3QgbmVjZXNzYXJ5IHRvIGFkZCBtZXRhZGF0YVxuICAgIGlmKCFjcmVhdGUpcmV0dXJuIGZhbHNlO1xuICAgIC8vIGFkZCBtaXNzaW5nIG1ldGFkYXRhXG4gICAgc2V0TWV0YShpdCk7XG4gIC8vIHJldHVybiBoYXNoIHdlYWsgY29sbGVjdGlvbnMgSURzXG4gIH0gcmV0dXJuIGl0W01FVEFdLnc7XG59O1xuLy8gYWRkIG1ldGFkYXRhIG9uIGZyZWV6ZS1mYW1pbHkgbWV0aG9kcyBjYWxsaW5nXG52YXIgb25GcmVlemUgPSBmdW5jdGlvbihpdCl7XG4gIGlmKEZSRUVaRSAmJiBtZXRhLk5FRUQgJiYgaXNFeHRlbnNpYmxlKGl0KSAmJiAhaGFzKGl0LCBNRVRBKSlzZXRNZXRhKGl0KTtcbiAgcmV0dXJuIGl0O1xufTtcbnZhciBtZXRhID0gbW9kdWxlLmV4cG9ydHMgPSB7XG4gIEtFWTogICAgICBNRVRBLFxuICBORUVEOiAgICAgZmFsc2UsXG4gIGZhc3RLZXk6ICBmYXN0S2V5LFxuICBnZXRXZWFrOiAgZ2V0V2VhayxcbiAgb25GcmVlemU6IG9uRnJlZXplXG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fbWV0YS5qc1xuLy8gbW9kdWxlIGlkID0gNTlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGdsb2JhbCAgICAgICAgID0gcmVxdWlyZSgnLi9fZ2xvYmFsJylcclxuICAsIGNvcmUgICAgICAgICAgID0gcmVxdWlyZSgnLi9fY29yZScpXHJcbiAgLCBMSUJSQVJZICAgICAgICA9IHJlcXVpcmUoJy4vX2xpYnJhcnknKVxyXG4gICwgd2tzRXh0ICAgICAgICAgPSByZXF1aXJlKCcuL193a3MtZXh0JylcclxuICAsIGRlZmluZVByb3BlcnR5ID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJykuZjtcclxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihuYW1lKXtcclxuICB2YXIgJFN5bWJvbCA9IGNvcmUuU3ltYm9sIHx8IChjb3JlLlN5bWJvbCA9IExJQlJBUlkgPyB7fSA6IGdsb2JhbC5TeW1ib2wgfHwge30pO1xyXG4gIGlmKG5hbWUuY2hhckF0KDApICE9ICdfJyAmJiAhKG5hbWUgaW4gJFN5bWJvbCkpZGVmaW5lUHJvcGVydHkoJFN5bWJvbCwgbmFtZSwge3ZhbHVlOiB3a3NFeHQuZihuYW1lKX0pO1xyXG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fd2tzLWRlZmluZS5qc1xuLy8gbW9kdWxlIGlkID0gNjBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGdldEtleXMgICA9IHJlcXVpcmUoJy4vX29iamVjdC1rZXlzJylcbiAgLCB0b0lPYmplY3QgPSByZXF1aXJlKCcuL190by1pb2JqZWN0Jyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG9iamVjdCwgZWwpe1xuICB2YXIgTyAgICAgID0gdG9JT2JqZWN0KG9iamVjdClcbiAgICAsIGtleXMgICA9IGdldEtleXMoTylcbiAgICAsIGxlbmd0aCA9IGtleXMubGVuZ3RoXG4gICAgLCBpbmRleCAgPSAwXG4gICAgLCBrZXk7XG4gIHdoaWxlKGxlbmd0aCA+IGluZGV4KWlmKE9ba2V5ID0ga2V5c1tpbmRleCsrXV0gPT09IGVsKXJldHVybiBrZXk7XG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fa2V5b2YuanNcbi8vIG1vZHVsZSBpZCA9IDYxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIGFsbCBlbnVtZXJhYmxlIG9iamVjdCBrZXlzLCBpbmNsdWRlcyBzeW1ib2xzXG52YXIgZ2V0S2V5cyA9IHJlcXVpcmUoJy4vX29iamVjdC1rZXlzJylcbiAgLCBnT1BTICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcHMnKVxuICAsIHBJRSAgICAgPSByZXF1aXJlKCcuL19vYmplY3QtcGllJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KXtcbiAgdmFyIHJlc3VsdCAgICAgPSBnZXRLZXlzKGl0KVxuICAgICwgZ2V0U3ltYm9scyA9IGdPUFMuZjtcbiAgaWYoZ2V0U3ltYm9scyl7XG4gICAgdmFyIHN5bWJvbHMgPSBnZXRTeW1ib2xzKGl0KVxuICAgICAgLCBpc0VudW0gID0gcElFLmZcbiAgICAgICwgaSAgICAgICA9IDBcbiAgICAgICwga2V5O1xuICAgIHdoaWxlKHN5bWJvbHMubGVuZ3RoID4gaSlpZihpc0VudW0uY2FsbChpdCwga2V5ID0gc3ltYm9sc1tpKytdKSlyZXN1bHQucHVzaChrZXkpO1xuICB9IHJldHVybiByZXN1bHQ7XG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZW51bS1rZXlzLmpzXG4vLyBtb2R1bGUgaWQgPSA2MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJleHBvcnRzLmYgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LWdvcHMuanNcbi8vIG1vZHVsZSBpZCA9IDYzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImV4cG9ydHMuZiA9IHt9LnByb3BlcnR5SXNFbnVtZXJhYmxlO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LXBpZS5qc1xuLy8gbW9kdWxlIGlkID0gNjRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gNy4yLjIgSXNBcnJheShhcmd1bWVudClcbnZhciBjb2YgPSByZXF1aXJlKCcuL19jb2YnKTtcbm1vZHVsZS5leHBvcnRzID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiBpc0FycmF5KGFyZyl7XG4gIHJldHVybiBjb2YoYXJnKSA9PSAnQXJyYXknO1xufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2lzLWFycmF5LmpzXG4vLyBtb2R1bGUgaWQgPSA2NVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyBmYWxsYmFjayBmb3IgSUUxMSBidWdneSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyB3aXRoIGlmcmFtZSBhbmQgd2luZG93XG52YXIgdG9JT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8taW9iamVjdCcpXG4gICwgZ09QTiAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcG4nKS5mXG4gICwgdG9TdHJpbmcgID0ge30udG9TdHJpbmc7XG5cbnZhciB3aW5kb3dOYW1lcyA9IHR5cGVvZiB3aW5kb3cgPT0gJ29iamVjdCcgJiYgd2luZG93ICYmIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzXG4gID8gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMod2luZG93KSA6IFtdO1xuXG52YXIgZ2V0V2luZG93TmFtZXMgPSBmdW5jdGlvbihpdCl7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGdPUE4oaXQpO1xuICB9IGNhdGNoKGUpe1xuICAgIHJldHVybiB3aW5kb3dOYW1lcy5zbGljZSgpO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cy5mID0gZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlOYW1lcyhpdCl7XG4gIHJldHVybiB3aW5kb3dOYW1lcyAmJiB0b1N0cmluZy5jYWxsKGl0KSA9PSAnW29iamVjdCBXaW5kb3ddJyA/IGdldFdpbmRvd05hbWVzKGl0KSA6IGdPUE4odG9JT2JqZWN0KGl0KSk7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3QtZ29wbi1leHQuanNcbi8vIG1vZHVsZSBpZCA9IDY2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIDE5LjEuMi43IC8gMTUuMi4zLjQgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoTylcclxudmFyICRrZXlzICAgICAgPSByZXF1aXJlKCcuL19vYmplY3Qta2V5cy1pbnRlcm5hbCcpXHJcbiAgLCBoaWRkZW5LZXlzID0gcmVxdWlyZSgnLi9fZW51bS1idWcta2V5cycpLmNvbmNhdCgnbGVuZ3RoJywgJ3Byb3RvdHlwZScpO1xyXG5cclxuZXhwb3J0cy5mID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMgfHwgZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlOYW1lcyhPKXtcclxuICByZXR1cm4gJGtleXMoTywgaGlkZGVuS2V5cyk7XHJcbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3QtZ29wbi5qc1xuLy8gbW9kdWxlIGlkID0gNjdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIHBJRSAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LXBpZScpXHJcbiAgLCBjcmVhdGVEZXNjICAgICA9IHJlcXVpcmUoJy4vX3Byb3BlcnR5LWRlc2MnKVxyXG4gICwgdG9JT2JqZWN0ICAgICAgPSByZXF1aXJlKCcuL190by1pb2JqZWN0JylcclxuICAsIHRvUHJpbWl0aXZlICAgID0gcmVxdWlyZSgnLi9fdG8tcHJpbWl0aXZlJylcclxuICAsIGhhcyAgICAgICAgICAgID0gcmVxdWlyZSgnLi9faGFzJylcclxuICAsIElFOF9ET01fREVGSU5FID0gcmVxdWlyZSgnLi9faWU4LWRvbS1kZWZpbmUnKVxyXG4gICwgZ09QRCAgICAgICAgICAgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xyXG5cclxuZXhwb3J0cy5mID0gcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSA/IGdPUEQgOiBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoTywgUCl7XHJcbiAgTyA9IHRvSU9iamVjdChPKTtcclxuICBQID0gdG9QcmltaXRpdmUoUCwgdHJ1ZSk7XHJcbiAgaWYoSUU4X0RPTV9ERUZJTkUpdHJ5IHtcclxuICAgIHJldHVybiBnT1BEKE8sIFApO1xyXG4gIH0gY2F0Y2goZSl7IC8qIGVtcHR5ICovIH1cclxuICBpZihoYXMoTywgUCkpcmV0dXJuIGNyZWF0ZURlc2MoIXBJRS5mLmNhbGwoTywgUCksIE9bUF0pO1xyXG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LWdvcGQuanNcbi8vIG1vZHVsZSBpZCA9IDY4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInJlcXVpcmUoJy4vX3drcy1kZWZpbmUnKSgnYXN5bmNJdGVyYXRvcicpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczcuc3ltYm9sLmFzeW5jLWl0ZXJhdG9yLmpzXG4vLyBtb2R1bGUgaWQgPSA3MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJyZXF1aXJlKCcuL193a3MtZGVmaW5lJykoJ29ic2VydmFibGUnKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM3LnN5bWJvbC5vYnNlcnZhYmxlLmpzXG4vLyBtb2R1bGUgaWQgPSA3MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IF9fd2VicGFja19hbWRfb3B0aW9uc19fO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gKHdlYnBhY2spL2J1aWxkaW4vYW1kLW9wdGlvbnMuanNcbi8vIG1vZHVsZSBpZCA9IDcyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0geyBcImRlZmF1bHRcIjogcmVxdWlyZShcImNvcmUtanMvbGlicmFyeS9mbi9vYmplY3Qva2V5c1wiKSwgX19lc01vZHVsZTogdHJ1ZSB9O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9iYWJlbC1ydW50aW1lL2NvcmUtanMvb2JqZWN0L2tleXMuanNcbi8vIG1vZHVsZSBpZCA9IDczXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInJlcXVpcmUoJy4uLy4uL21vZHVsZXMvZXM2Lm9iamVjdC5rZXlzJyk7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4uLy4uL21vZHVsZXMvX2NvcmUnKS5PYmplY3Qua2V5cztcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9saWJyYXJ5L2ZuL29iamVjdC9rZXlzLmpzXG4vLyBtb2R1bGUgaWQgPSA3NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyAxOS4xLjIuMTQgT2JqZWN0LmtleXMoTylcbnZhciB0b09iamVjdCA9IHJlcXVpcmUoJy4vX3RvLW9iamVjdCcpXG4gICwgJGtleXMgICAgPSByZXF1aXJlKCcuL19vYmplY3Qta2V5cycpO1xuXG5yZXF1aXJlKCcuL19vYmplY3Qtc2FwJykoJ2tleXMnLCBmdW5jdGlvbigpe1xuICByZXR1cm4gZnVuY3Rpb24ga2V5cyhpdCl7XG4gICAgcmV0dXJuICRrZXlzKHRvT2JqZWN0KGl0KSk7XG4gIH07XG59KTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM2Lm9iamVjdC5rZXlzLmpzXG4vLyBtb2R1bGUgaWQgPSA3NVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyBtb3N0IE9iamVjdCBtZXRob2RzIGJ5IEVTNiBzaG91bGQgYWNjZXB0IHByaW1pdGl2ZXNcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCBjb3JlICAgID0gcmVxdWlyZSgnLi9fY29yZScpXG4gICwgZmFpbHMgICA9IHJlcXVpcmUoJy4vX2ZhaWxzJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKEtFWSwgZXhlYyl7XG4gIHZhciBmbiAgPSAoY29yZS5PYmplY3QgfHwge30pW0tFWV0gfHwgT2JqZWN0W0tFWV1cbiAgICAsIGV4cCA9IHt9O1xuICBleHBbS0VZXSA9IGV4ZWMoZm4pO1xuICAkZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqIGZhaWxzKGZ1bmN0aW9uKCl7IGZuKDEpOyB9KSwgJ09iamVjdCcsIGV4cCk7XG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LXNhcC5qc1xuLy8gbW9kdWxlIGlkID0gNzZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfaXNJdGVyYWJsZTIgPSByZXF1aXJlKFwiLi4vY29yZS1qcy9pcy1pdGVyYWJsZVwiKTtcblxudmFyIF9pc0l0ZXJhYmxlMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2lzSXRlcmFibGUyKTtcblxudmFyIF9nZXRJdGVyYXRvcjIgPSByZXF1aXJlKFwiLi4vY29yZS1qcy9nZXQtaXRlcmF0b3JcIik7XG5cbnZhciBfZ2V0SXRlcmF0b3IzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZ2V0SXRlcmF0b3IyKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZXhwb3J0cy5kZWZhdWx0ID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBzbGljZUl0ZXJhdG9yKGFyciwgaSkge1xuICAgIHZhciBfYXJyID0gW107XG4gICAgdmFyIF9uID0gdHJ1ZTtcbiAgICB2YXIgX2QgPSBmYWxzZTtcbiAgICB2YXIgX2UgPSB1bmRlZmluZWQ7XG5cbiAgICB0cnkge1xuICAgICAgZm9yICh2YXIgX2kgPSAoMCwgX2dldEl0ZXJhdG9yMy5kZWZhdWx0KShhcnIpLCBfczsgIShfbiA9IChfcyA9IF9pLm5leHQoKSkuZG9uZSk7IF9uID0gdHJ1ZSkge1xuICAgICAgICBfYXJyLnB1c2goX3MudmFsdWUpO1xuXG4gICAgICAgIGlmIChpICYmIF9hcnIubGVuZ3RoID09PSBpKSBicmVhaztcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIF9kID0gdHJ1ZTtcbiAgICAgIF9lID0gZXJyO1xuICAgIH0gZmluYWxseSB7XG4gICAgICB0cnkge1xuICAgICAgICBpZiAoIV9uICYmIF9pW1wicmV0dXJuXCJdKSBfaVtcInJldHVyblwiXSgpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgaWYgKF9kKSB0aHJvdyBfZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gX2FycjtcbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbiAoYXJyLCBpKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkge1xuICAgICAgcmV0dXJuIGFycjtcbiAgICB9IGVsc2UgaWYgKCgwLCBfaXNJdGVyYWJsZTMuZGVmYXVsdCkoT2JqZWN0KGFycikpKSB7XG4gICAgICByZXR1cm4gc2xpY2VJdGVyYXRvcihhcnIsIGkpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGRlc3RydWN0dXJlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZVwiKTtcbiAgICB9XG4gIH07XG59KCk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2JhYmVsLXJ1bnRpbWUvaGVscGVycy9zbGljZWRUb0FycmF5LmpzXG4vLyBtb2R1bGUgaWQgPSA3N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IHsgXCJkZWZhdWx0XCI6IHJlcXVpcmUoXCJjb3JlLWpzL2xpYnJhcnkvZm4vaXMtaXRlcmFibGVcIiksIF9fZXNNb2R1bGU6IHRydWUgfTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vYmFiZWwtcnVudGltZS9jb3JlLWpzL2lzLWl0ZXJhYmxlLmpzXG4vLyBtb2R1bGUgaWQgPSA3OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJyZXF1aXJlKCcuLi9tb2R1bGVzL3dlYi5kb20uaXRlcmFibGUnKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvZXM2LnN0cmluZy5pdGVyYXRvcicpO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLi9tb2R1bGVzL2NvcmUuaXMtaXRlcmFibGUnKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9saWJyYXJ5L2ZuL2lzLWl0ZXJhYmxlLmpzXG4vLyBtb2R1bGUgaWQgPSA3OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgY2xhc3NvZiAgID0gcmVxdWlyZSgnLi9fY2xhc3NvZicpXG4gICwgSVRFUkFUT1IgID0gcmVxdWlyZSgnLi9fd2tzJykoJ2l0ZXJhdG9yJylcbiAgLCBJdGVyYXRvcnMgPSByZXF1aXJlKCcuL19pdGVyYXRvcnMnKTtcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9fY29yZScpLmlzSXRlcmFibGUgPSBmdW5jdGlvbihpdCl7XG4gIHZhciBPID0gT2JqZWN0KGl0KTtcbiAgcmV0dXJuIE9bSVRFUkFUT1JdICE9PSB1bmRlZmluZWRcbiAgICB8fCAnQEBpdGVyYXRvcicgaW4gT1xuICAgIHx8IEl0ZXJhdG9ycy5oYXNPd25Qcm9wZXJ0eShjbGFzc29mKE8pKTtcbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2NvcmUuaXMtaXRlcmFibGUuanNcbi8vIG1vZHVsZSBpZCA9IDgwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIGdldHRpbmcgdGFnIGZyb20gMTkuMS4zLjYgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZygpXG52YXIgY29mID0gcmVxdWlyZSgnLi9fY29mJylcbiAgLCBUQUcgPSByZXF1aXJlKCcuL193a3MnKSgndG9TdHJpbmdUYWcnKVxuICAvLyBFUzMgd3JvbmcgaGVyZVxuICAsIEFSRyA9IGNvZihmdW5jdGlvbigpeyByZXR1cm4gYXJndW1lbnRzOyB9KCkpID09ICdBcmd1bWVudHMnO1xuXG4vLyBmYWxsYmFjayBmb3IgSUUxMSBTY3JpcHQgQWNjZXNzIERlbmllZCBlcnJvclxudmFyIHRyeUdldCA9IGZ1bmN0aW9uKGl0LCBrZXkpe1xuICB0cnkge1xuICAgIHJldHVybiBpdFtrZXldO1xuICB9IGNhdGNoKGUpeyAvKiBlbXB0eSAqLyB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KXtcbiAgdmFyIE8sIFQsIEI7XG4gIHJldHVybiBpdCA9PT0gdW5kZWZpbmVkID8gJ1VuZGVmaW5lZCcgOiBpdCA9PT0gbnVsbCA/ICdOdWxsJ1xuICAgIC8vIEBAdG9TdHJpbmdUYWcgY2FzZVxuICAgIDogdHlwZW9mIChUID0gdHJ5R2V0KE8gPSBPYmplY3QoaXQpLCBUQUcpKSA9PSAnc3RyaW5nJyA/IFRcbiAgICAvLyBidWlsdGluVGFnIGNhc2VcbiAgICA6IEFSRyA/IGNvZihPKVxuICAgIC8vIEVTMyBhcmd1bWVudHMgZmFsbGJhY2tcbiAgICA6IChCID0gY29mKE8pKSA9PSAnT2JqZWN0JyAmJiB0eXBlb2YgTy5jYWxsZWUgPT0gJ2Z1bmN0aW9uJyA/ICdBcmd1bWVudHMnIDogQjtcbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19jbGFzc29mLmpzXG4vLyBtb2R1bGUgaWQgPSA4MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IHsgXCJkZWZhdWx0XCI6IHJlcXVpcmUoXCJjb3JlLWpzL2xpYnJhcnkvZm4vZ2V0LWl0ZXJhdG9yXCIpLCBfX2VzTW9kdWxlOiB0cnVlIH07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9nZXQtaXRlcmF0b3IuanNcbi8vIG1vZHVsZSBpZCA9IDgyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInJlcXVpcmUoJy4uL21vZHVsZXMvd2ViLmRvbS5pdGVyYWJsZScpO1xucmVxdWlyZSgnLi4vbW9kdWxlcy9lczYuc3RyaW5nLml0ZXJhdG9yJyk7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4uL21vZHVsZXMvY29yZS5nZXQtaXRlcmF0b3InKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9saWJyYXJ5L2ZuL2dldC1pdGVyYXRvci5qc1xuLy8gbW9kdWxlIGlkID0gODNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0JylcbiAgLCBnZXQgICAgICA9IHJlcXVpcmUoJy4vY29yZS5nZXQtaXRlcmF0b3ItbWV0aG9kJyk7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vX2NvcmUnKS5nZXRJdGVyYXRvciA9IGZ1bmN0aW9uKGl0KXtcbiAgdmFyIGl0ZXJGbiA9IGdldChpdCk7XG4gIGlmKHR5cGVvZiBpdGVyRm4gIT0gJ2Z1bmN0aW9uJyl0aHJvdyBUeXBlRXJyb3IoaXQgKyAnIGlzIG5vdCBpdGVyYWJsZSEnKTtcbiAgcmV0dXJuIGFuT2JqZWN0KGl0ZXJGbi5jYWxsKGl0KSk7XG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9jb3JlLmdldC1pdGVyYXRvci5qc1xuLy8gbW9kdWxlIGlkID0gODRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGNsYXNzb2YgICA9IHJlcXVpcmUoJy4vX2NsYXNzb2YnKVxuICAsIElURVJBVE9SICA9IHJlcXVpcmUoJy4vX3drcycpKCdpdGVyYXRvcicpXG4gICwgSXRlcmF0b3JzID0gcmVxdWlyZSgnLi9faXRlcmF0b3JzJyk7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vX2NvcmUnKS5nZXRJdGVyYXRvck1ldGhvZCA9IGZ1bmN0aW9uKGl0KXtcbiAgaWYoaXQgIT0gdW5kZWZpbmVkKXJldHVybiBpdFtJVEVSQVRPUl1cbiAgICB8fCBpdFsnQEBpdGVyYXRvciddXG4gICAgfHwgSXRlcmF0b3JzW2NsYXNzb2YoaXQpXTtcbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2NvcmUuZ2V0LWl0ZXJhdG9yLW1ldGhvZC5qc1xuLy8gbW9kdWxlIGlkID0gODVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IGZ1bmN0aW9uIChpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHtcbiAgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpO1xuICB9XG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9iYWJlbC1ydW50aW1lL2hlbHBlcnMvY2xhc3NDYWxsQ2hlY2suanNcbi8vIG1vZHVsZSBpZCA9IDg2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlwidXNlIHN0cmljdFwiO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX2RlZmluZVByb3BlcnR5ID0gcmVxdWlyZShcIi4uL2NvcmUtanMvb2JqZWN0L2RlZmluZS1wcm9wZXJ0eVwiKTtcblxudmFyIF9kZWZpbmVQcm9wZXJ0eTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9kZWZpbmVQcm9wZXJ0eSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmV4cG9ydHMuZGVmYXVsdCA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTtcbiAgICAgIGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTtcbiAgICAgIGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTtcbiAgICAgIGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7XG4gICAgICAoMCwgX2RlZmluZVByb3BlcnR5Mi5kZWZhdWx0KSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykge1xuICAgIGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7XG4gICAgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7XG4gICAgcmV0dXJuIENvbnN0cnVjdG9yO1xuICB9O1xufSgpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9iYWJlbC1ydW50aW1lL2hlbHBlcnMvY3JlYXRlQ2xhc3MuanNcbi8vIG1vZHVsZSBpZCA9IDg3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0geyBcImRlZmF1bHRcIjogcmVxdWlyZShcImNvcmUtanMvbGlicmFyeS9mbi9vYmplY3QvZGVmaW5lLXByb3BlcnR5XCIpLCBfX2VzTW9kdWxlOiB0cnVlIH07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9vYmplY3QvZGVmaW5lLXByb3BlcnR5LmpzXG4vLyBtb2R1bGUgaWQgPSA4OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJyZXF1aXJlKCcuLi8uLi9tb2R1bGVzL2VzNi5vYmplY3QuZGVmaW5lLXByb3BlcnR5Jyk7XG52YXIgJE9iamVjdCA9IHJlcXVpcmUoJy4uLy4uL21vZHVsZXMvX2NvcmUnKS5PYmplY3Q7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGRlZmluZVByb3BlcnR5KGl0LCBrZXksIGRlc2Mpe1xuICByZXR1cm4gJE9iamVjdC5kZWZpbmVQcm9wZXJ0eShpdCwga2V5LCBkZXNjKTtcbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbGlicmFyeS9mbi9vYmplY3QvZGVmaW5lLXByb3BlcnR5LmpzXG4vLyBtb2R1bGUgaWQgPSA4OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xyXG4vLyAxOS4xLjIuNCAvIDE1LjIuMy42IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShPLCBQLCBBdHRyaWJ1dGVzKVxyXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqICFyZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpLCAnT2JqZWN0Jywge2RlZmluZVByb3BlcnR5OiByZXF1aXJlKCcuL19vYmplY3QtZHAnKS5mfSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNi5vYmplY3QuZGVmaW5lLXByb3BlcnR5LmpzXG4vLyBtb2R1bGUgaWQgPSA5MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJyZXF1aXJlKCdqcXVlcnktbWlncmF0ZS0xLjMuMC5taW4nKTtcclxucmVxdWlyZSgnZXhwb3NlP2tvIWtub2Nrb3V0Jyk7XHJcbnJlcXVpcmUoJ2pzdHJlZScpO1xyXG5yZXF1aXJlKCdsYXp5LXNlbGVjdG9yJyk7XHJcbnJlcXVpcmUoJ2NsYXNzaWZpY2F0aW9uLXNlbGVjdG9yJyk7XHJcbnJlcXVpcmUoJ2Jvb3RzdHJhcC5taW4nKTtcclxucmVxdWlyZSgnLi92YWxpZGF0aW9uJyk7XHJcbnJlcXVpcmUoJ3NsaWNrLm1pbicpO1xyXG5yZXF1aXJlKCdrbm9ja291dC1zY3JvbGxiYXInKTtcclxucmVxdWlyZSgnZXhwb3NlP0NsaXBib2FyZCFjbGlwYm9hcmQnKTtcclxucmVxdWlyZSgnY2xhbXAubWluJyk7XHJcbnJlcXVpcmUoJ2tub2Nrb3V0LXBvc3Rib3gnKTtcclxucmVxdWlyZSgnZGF0ZXRpbWVwaWNrZXInKTtcclxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc2NyaXB0cy9hcGktZXhwbG9yZXIvdjIvc3JjL21vZHVsZXMvaW5kZXguanMiLCIvKiEgalF1ZXJ5IE1pZ3JhdGUgdjEuMy4wIHwgKGMpIGpRdWVyeSBGb3VuZGF0aW9uIGFuZCBvdGhlciBjb250cmlidXRvcnMgfCBqcXVlcnkub3JnL2xpY2Vuc2UgKi9cclxuXCJ1bmRlZmluZWRcIj09dHlwZW9mIGpRdWVyeS5taWdyYXRlTXV0ZSYmKGpRdWVyeS5taWdyYXRlTXV0ZT0hMCksZnVuY3Rpb24oYSxiLGMpe2Z1bmN0aW9uIGQoYyl7dmFyIGQ9Yi5jb25zb2xlO2ZbY118fChmW2NdPSEwLGEubWlncmF0ZVdhcm5pbmdzLnB1c2goYyksZCYmZC53YXJuJiYhYS5taWdyYXRlTXV0ZSYmKGQud2FybihcIkpRTUlHUkFURTogXCIrYyksYS5taWdyYXRlVHJhY2UmJmQudHJhY2UmJmQudHJhY2UoKSkpfWZ1bmN0aW9uIGUoYixjLGUsZil7aWYoT2JqZWN0LmRlZmluZVByb3BlcnR5KXRyeXtyZXR1cm4gdm9pZCBPYmplY3QuZGVmaW5lUHJvcGVydHkoYixjLHtjb25maWd1cmFibGU6ITAsZW51bWVyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gZChmKSxlfSxzZXQ6ZnVuY3Rpb24oYSl7ZChmKSxlPWF9fSl9Y2F0Y2goZyl7fWEuX2RlZmluZVByb3BlcnR5QnJva2VuPSEwLGJbY109ZX1hLm1pZ3JhdGVWZXJzaW9uPVwiMS4zLjBcIjt2YXIgZj17fTthLm1pZ3JhdGVXYXJuaW5ncz1bXSwhYS5taWdyYXRlTXV0ZSYmYi5jb25zb2xlJiZiLmNvbnNvbGUubG9nJiZiLmNvbnNvbGUubG9nKFwiSlFNSUdSQVRFOiBMb2dnaW5nIGlzIGFjdGl2ZVwiKSxhLm1pZ3JhdGVUcmFjZT09PWMmJihhLm1pZ3JhdGVUcmFjZT0hMCksYS5taWdyYXRlUmVzZXQ9ZnVuY3Rpb24oKXtmPXt9LGEubWlncmF0ZVdhcm5pbmdzLmxlbmd0aD0wfSxcIkJhY2tDb21wYXRcIj09PWRvY3VtZW50LmNvbXBhdE1vZGUmJmQoXCJqUXVlcnkgaXMgbm90IGNvbXBhdGlibGUgd2l0aCBRdWlya3MgTW9kZVwiKTt2YXIgZz1hKFwiPGlucHV0Lz5cIix7c2l6ZToxfSkuYXR0cihcInNpemVcIikmJmEuYXR0ckZuLGg9YS5hdHRyLGk9YS5hdHRySG9va3MudmFsdWUmJmEuYXR0ckhvb2tzLnZhbHVlLmdldHx8ZnVuY3Rpb24oKXtyZXR1cm4gbnVsbH0saj1hLmF0dHJIb29rcy52YWx1ZSYmYS5hdHRySG9va3MudmFsdWUuc2V0fHxmdW5jdGlvbigpe3JldHVybiBjfSxrPS9eKD86aW5wdXR8YnV0dG9uKSQvaSxsPS9eWzIzOF0kLyxtPS9eKD86YXV0b2ZvY3VzfGF1dG9wbGF5fGFzeW5jfGNoZWNrZWR8Y29udHJvbHN8ZGVmZXJ8ZGlzYWJsZWR8aGlkZGVufGxvb3B8bXVsdGlwbGV8b3BlbnxyZWFkb25seXxyZXF1aXJlZHxzY29wZWR8c2VsZWN0ZWQpJC9pLG49L14oPzpjaGVja2VkfHNlbGVjdGVkKSQvaTtlKGEsXCJhdHRyRm5cIixnfHx7fSxcImpRdWVyeS5hdHRyRm4gaXMgZGVwcmVjYXRlZFwiKSxhLmF0dHI9ZnVuY3Rpb24oYixlLGYsaSl7dmFyIGo9ZS50b0xvd2VyQ2FzZSgpLG89YiYmYi5ub2RlVHlwZTtyZXR1cm4gaSYmKGgubGVuZ3RoPDQmJmQoXCJqUXVlcnkuZm4uYXR0ciggcHJvcHMsIHBhc3MgKSBpcyBkZXByZWNhdGVkXCIpLGImJiFsLnRlc3QobykmJihnP2UgaW4gZzphLmlzRnVuY3Rpb24oYS5mbltlXSkpKT9hKGIpW2VdKGYpOihcInR5cGVcIj09PWUmJmYhPT1jJiZrLnRlc3QoYi5ub2RlTmFtZSkmJmIucGFyZW50Tm9kZSYmZChcIkNhbid0IGNoYW5nZSB0aGUgJ3R5cGUnIG9mIGFuIGlucHV0IG9yIGJ1dHRvbiBpbiBJRSA2LzcvOFwiKSwhYS5hdHRySG9va3Nbal0mJm0udGVzdChqKSYmKGEuYXR0ckhvb2tzW2pdPXtnZXQ6ZnVuY3Rpb24oYixkKXt2YXIgZSxmPWEucHJvcChiLGQpO3JldHVybiBmPT09ITB8fFwiYm9vbGVhblwiIT10eXBlb2YgZiYmKGU9Yi5nZXRBdHRyaWJ1dGVOb2RlKGQpKSYmZS5ub2RlVmFsdWUhPT0hMT9kLnRvTG93ZXJDYXNlKCk6Y30sc2V0OmZ1bmN0aW9uKGIsYyxkKXt2YXIgZTtyZXR1cm4gYz09PSExP2EucmVtb3ZlQXR0cihiLGQpOihlPWEucHJvcEZpeFtkXXx8ZCxlIGluIGImJihiW2VdPSEwKSxiLnNldEF0dHJpYnV0ZShkLGQudG9Mb3dlckNhc2UoKSkpLGR9fSxuLnRlc3QoaikmJmQoXCJqUXVlcnkuZm4uYXR0cignXCIraitcIicpIG1pZ2h0IHVzZSBwcm9wZXJ0eSBpbnN0ZWFkIG9mIGF0dHJpYnV0ZVwiKSksaC5jYWxsKGEsYixlLGYpKX0sYS5hdHRySG9va3MudmFsdWU9e2dldDpmdW5jdGlvbihhLGIpe3ZhciBjPShhLm5vZGVOYW1lfHxcIlwiKS50b0xvd2VyQ2FzZSgpO3JldHVyblwiYnV0dG9uXCI9PT1jP2kuYXBwbHkodGhpcyxhcmd1bWVudHMpOihcImlucHV0XCIhPT1jJiZcIm9wdGlvblwiIT09YyYmZChcImpRdWVyeS5mbi5hdHRyKCd2YWx1ZScpIG5vIGxvbmdlciBnZXRzIHByb3BlcnRpZXNcIiksYiBpbiBhP2EudmFsdWU6bnVsbCl9LHNldDpmdW5jdGlvbihhLGIpe3ZhciBjPShhLm5vZGVOYW1lfHxcIlwiKS50b0xvd2VyQ2FzZSgpO3JldHVyblwiYnV0dG9uXCI9PT1jP2ouYXBwbHkodGhpcyxhcmd1bWVudHMpOihcImlucHV0XCIhPT1jJiZcIm9wdGlvblwiIT09YyYmZChcImpRdWVyeS5mbi5hdHRyKCd2YWx1ZScsIHZhbCkgbm8gbG9uZ2VyIHNldHMgcHJvcGVydGllc1wiKSx2b2lkKGEudmFsdWU9YikpfX07dmFyIG8scCxxPWEuZm4uaW5pdCxyPWEucGFyc2VKU09OLHM9L15cXHMqPC8sdD0vXihbXjxdKikoPFtcXHdcXFddKz4pKFtePl0qKSQvO2EuZm4uaW5pdD1mdW5jdGlvbihiLGUsZil7dmFyIGcsaDtyZXR1cm4gYiYmXCJzdHJpbmdcIj09dHlwZW9mIGImJiFhLmlzUGxhaW5PYmplY3QoZSkmJihnPXQuZXhlYyhhLnRyaW0oYikpKSYmZ1swXSYmKHMudGVzdChiKXx8ZChcIiQoaHRtbCkgSFRNTCBzdHJpbmdzIG11c3Qgc3RhcnQgd2l0aCAnPCcgY2hhcmFjdGVyXCIpLGdbM10mJmQoXCIkKGh0bWwpIEhUTUwgdGV4dCBhZnRlciBsYXN0IHRhZyBpcyBpZ25vcmVkXCIpLFwiI1wiPT09Z1swXS5jaGFyQXQoMCkmJihkKFwiSFRNTCBzdHJpbmcgY2Fubm90IHN0YXJ0IHdpdGggYSAnIycgY2hhcmFjdGVyXCIpLGEuZXJyb3IoXCJKUU1JR1JBVEU6IEludmFsaWQgc2VsZWN0b3Igc3RyaW5nIChYU1MpXCIpKSxlJiZlLmNvbnRleHQmJihlPWUuY29udGV4dCksYS5wYXJzZUhUTUwpP3EuY2FsbCh0aGlzLGEucGFyc2VIVE1MKGdbMl0sZSYmZS5vd25lckRvY3VtZW50fHxlfHxkb2N1bWVudCwhMCksZSxmKTooXCIjXCI9PT1iJiYoZChcImpRdWVyeSggJyMnICkgaXMgbm90IGEgdmFsaWQgc2VsZWN0b3JcIiksYj1bXSksaD1xLmFwcGx5KHRoaXMsYXJndW1lbnRzKSxiJiZiLnNlbGVjdG9yIT09Yz8oaC5zZWxlY3Rvcj1iLnNlbGVjdG9yLGguY29udGV4dD1iLmNvbnRleHQpOihoLnNlbGVjdG9yPVwic3RyaW5nXCI9PXR5cGVvZiBiP2I6XCJcIixiJiYoaC5jb250ZXh0PWIubm9kZVR5cGU/YjplfHxkb2N1bWVudCkpLGgpfSxhLmZuLmluaXQucHJvdG90eXBlPWEuZm4sYS5wYXJzZUpTT049ZnVuY3Rpb24oYSl7cmV0dXJuIGE/ci5hcHBseSh0aGlzLGFyZ3VtZW50cyk6KGQoXCJqUXVlcnkucGFyc2VKU09OIHJlcXVpcmVzIGEgdmFsaWQgSlNPTiBzdHJpbmdcIiksbnVsbCl9LGEudWFNYXRjaD1mdW5jdGlvbihhKXthPWEudG9Mb3dlckNhc2UoKTt2YXIgYj0vKGNocm9tZSlbIFxcL10oW1xcdy5dKykvLmV4ZWMoYSl8fC8od2Via2l0KVsgXFwvXShbXFx3Ll0rKS8uZXhlYyhhKXx8LyhvcGVyYSkoPzouKnZlcnNpb258KVsgXFwvXShbXFx3Ll0rKS8uZXhlYyhhKXx8Lyhtc2llKSAoW1xcdy5dKykvLmV4ZWMoYSl8fGEuaW5kZXhPZihcImNvbXBhdGlibGVcIik8MCYmLyhtb3ppbGxhKSg/Oi4qPyBydjooW1xcdy5dKyl8KS8uZXhlYyhhKXx8W107cmV0dXJue2Jyb3dzZXI6YlsxXXx8XCJcIix2ZXJzaW9uOmJbMl18fFwiMFwifX0sYS5icm93c2VyfHwobz1hLnVhTWF0Y2gobmF2aWdhdG9yLnVzZXJBZ2VudCkscD17fSxvLmJyb3dzZXImJihwW28uYnJvd3Nlcl09ITAscC52ZXJzaW9uPW8udmVyc2lvbikscC5jaHJvbWU/cC53ZWJraXQ9ITA6cC53ZWJraXQmJihwLnNhZmFyaT0hMCksYS5icm93c2VyPXApLGUoYSxcImJyb3dzZXJcIixhLmJyb3dzZXIsXCJqUXVlcnkuYnJvd3NlciBpcyBkZXByZWNhdGVkXCIpLGEuYm94TW9kZWw9YS5zdXBwb3J0LmJveE1vZGVsPVwiQ1NTMUNvbXBhdFwiPT09ZG9jdW1lbnQuY29tcGF0TW9kZSxlKGEsXCJib3hNb2RlbFwiLGEuYm94TW9kZWwsXCJqUXVlcnkuYm94TW9kZWwgaXMgZGVwcmVjYXRlZFwiKSxlKGEuc3VwcG9ydCxcImJveE1vZGVsXCIsYS5zdXBwb3J0LmJveE1vZGVsLFwialF1ZXJ5LnN1cHBvcnQuYm94TW9kZWwgaXMgZGVwcmVjYXRlZFwiKSxhLnN1Yj1mdW5jdGlvbigpe2Z1bmN0aW9uIGIoYSxjKXtyZXR1cm4gbmV3IGIuZm4uaW5pdChhLGMpfWEuZXh0ZW5kKCEwLGIsdGhpcyksYi5zdXBlcmNsYXNzPXRoaXMsYi5mbj1iLnByb3RvdHlwZT10aGlzKCksYi5mbi5jb25zdHJ1Y3Rvcj1iLGIuc3ViPXRoaXMuc3ViLGIuZm4uaW5pdD1mdW5jdGlvbihkLGUpe3ZhciBmPWEuZm4uaW5pdC5jYWxsKHRoaXMsZCxlLGMpO3JldHVybiBmIGluc3RhbmNlb2YgYj9mOmIoZil9LGIuZm4uaW5pdC5wcm90b3R5cGU9Yi5mbjt2YXIgYz1iKGRvY3VtZW50KTtyZXR1cm4gZChcImpRdWVyeS5zdWIoKSBpcyBkZXByZWNhdGVkXCIpLGJ9LGEuZm4uc2l6ZT1mdW5jdGlvbigpe3JldHVybiBkKFwialF1ZXJ5LmZuLnNpemUoKSBpcyBkZXByZWNhdGVkOyB1c2UgdGhlIC5sZW5ndGggcHJvcGVydHlcIiksdGhpcy5sZW5ndGh9O3ZhciB1PSExO2Euc3dhcCYmYS5lYWNoKFtcImhlaWdodFwiLFwid2lkdGhcIixcInJlbGlhYmxlTWFyZ2luUmlnaHRcIl0sZnVuY3Rpb24oYixjKXt2YXIgZD1hLmNzc0hvb2tzW2NdJiZhLmNzc0hvb2tzW2NdLmdldDtkJiYoYS5jc3NIb29rc1tjXS5nZXQ9ZnVuY3Rpb24oKXt2YXIgYTtyZXR1cm4gdT0hMCxhPWQuYXBwbHkodGhpcyxhcmd1bWVudHMpLHU9ITEsYX0pfSksYS5zd2FwPWZ1bmN0aW9uKGEsYixjLGUpe3ZhciBmLGcsaD17fTt1fHxkKFwialF1ZXJ5LnN3YXAoKSBpcyB1bmRvY3VtZW50ZWQgYW5kIGRlcHJlY2F0ZWRcIik7Zm9yKGcgaW4gYiloW2ddPWEuc3R5bGVbZ10sYS5zdHlsZVtnXT1iW2ddO2Y9Yy5hcHBseShhLGV8fFtdKTtmb3IoZyBpbiBiKWEuc3R5bGVbZ109aFtnXTtyZXR1cm4gZn0sYS5hamF4U2V0dXAoe2NvbnZlcnRlcnM6e1widGV4dCBqc29uXCI6YS5wYXJzZUpTT059fSk7dmFyIHY9YS5mbi5kYXRhO2EuZm4uZGF0YT1mdW5jdGlvbihiKXt2YXIgZSxmLGc9dGhpc1swXTtyZXR1cm4hZ3x8XCJldmVudHNcIiE9PWJ8fDEhPT1hcmd1bWVudHMubGVuZ3RofHwoZT1hLmRhdGEoZyxiKSxmPWEuX2RhdGEoZyxiKSxlIT09YyYmZSE9PWZ8fGY9PT1jKT92LmFwcGx5KHRoaXMsYXJndW1lbnRzKTooZChcIlVzZSBvZiBqUXVlcnkuZm4uZGF0YSgnZXZlbnRzJykgaXMgZGVwcmVjYXRlZFwiKSxmKX07dmFyIHc9L1xcLyhqYXZhfGVjbWEpc2NyaXB0L2k7YS5jbGVhbnx8KGEuY2xlYW49ZnVuY3Rpb24oYixjLGUsZil7Yz1jfHxkb2N1bWVudCxjPSFjLm5vZGVUeXBlJiZjWzBdfHxjLGM9Yy5vd25lckRvY3VtZW50fHxjLGQoXCJqUXVlcnkuY2xlYW4oKSBpcyBkZXByZWNhdGVkXCIpO3ZhciBnLGgsaSxqLGs9W107aWYoYS5tZXJnZShrLGEuYnVpbGRGcmFnbWVudChiLGMpLmNoaWxkTm9kZXMpLGUpZm9yKGk9ZnVuY3Rpb24oYSl7cmV0dXJuIWEudHlwZXx8dy50ZXN0KGEudHlwZSk/Zj9mLnB1c2goYS5wYXJlbnROb2RlP2EucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChhKTphKTplLmFwcGVuZENoaWxkKGEpOnZvaWQgMH0sZz0wO251bGwhPShoPWtbZ10pO2crKylhLm5vZGVOYW1lKGgsXCJzY3JpcHRcIikmJmkoaCl8fChlLmFwcGVuZENoaWxkKGgpLFwidW5kZWZpbmVkXCIhPXR5cGVvZiBoLmdldEVsZW1lbnRzQnlUYWdOYW1lJiYoaj1hLmdyZXAoYS5tZXJnZShbXSxoLmdldEVsZW1lbnRzQnlUYWdOYW1lKFwic2NyaXB0XCIpKSxpKSxrLnNwbGljZS5hcHBseShrLFtnKzEsMF0uY29uY2F0KGopKSxnKz1qLmxlbmd0aCkpO3JldHVybiBrfSk7dmFyIHg9YS5ldmVudC5hZGQseT1hLmV2ZW50LnJlbW92ZSx6PWEuZXZlbnQudHJpZ2dlcixBPWEuZm4udG9nZ2xlLEI9YS5mbi5saXZlLEM9YS5mbi5kaWUsRD1hLmZuLmxvYWQsRT1cImFqYXhTdGFydHxhamF4U3RvcHxhamF4U2VuZHxhamF4Q29tcGxldGV8YWpheEVycm9yfGFqYXhTdWNjZXNzXCIsRj1uZXcgUmVnRXhwKFwiXFxcXGIoPzpcIitFK1wiKVxcXFxiXCIpLEc9Lyg/Ol58XFxzKWhvdmVyKFxcLlxcUyt8KVxcYi8sSD1mdW5jdGlvbihiKXtyZXR1cm5cInN0cmluZ1wiIT10eXBlb2YgYnx8YS5ldmVudC5zcGVjaWFsLmhvdmVyP2I6KEcudGVzdChiKSYmZChcIidob3ZlcicgcHNldWRvLWV2ZW50IGlzIGRlcHJlY2F0ZWQsIHVzZSAnbW91c2VlbnRlciBtb3VzZWxlYXZlJ1wiKSxiJiZiLnJlcGxhY2UoRyxcIm1vdXNlZW50ZXIkMSBtb3VzZWxlYXZlJDFcIikpfTthLmV2ZW50LnByb3BzJiZcImF0dHJDaGFuZ2VcIiE9PWEuZXZlbnQucHJvcHNbMF0mJmEuZXZlbnQucHJvcHMudW5zaGlmdChcImF0dHJDaGFuZ2VcIixcImF0dHJOYW1lXCIsXCJyZWxhdGVkTm9kZVwiLFwic3JjRWxlbWVudFwiKSxhLmV2ZW50LmRpc3BhdGNoJiZlKGEuZXZlbnQsXCJoYW5kbGVcIixhLmV2ZW50LmRpc3BhdGNoLFwialF1ZXJ5LmV2ZW50LmhhbmRsZSBpcyB1bmRvY3VtZW50ZWQgYW5kIGRlcHJlY2F0ZWRcIiksYS5ldmVudC5hZGQ9ZnVuY3Rpb24oYSxiLGMsZSxmKXthIT09ZG9jdW1lbnQmJkYudGVzdChiKSYmZChcIkFKQVggZXZlbnRzIHNob3VsZCBiZSBhdHRhY2hlZCB0byBkb2N1bWVudDogXCIrYikseC5jYWxsKHRoaXMsYSxIKGJ8fFwiXCIpLGMsZSxmKX0sYS5ldmVudC5yZW1vdmU9ZnVuY3Rpb24oYSxiLGMsZCxlKXt5LmNhbGwodGhpcyxhLEgoYil8fFwiXCIsYyxkLGUpfSxhLmVhY2goW1wibG9hZFwiLFwidW5sb2FkXCIsXCJlcnJvclwiXSxmdW5jdGlvbihiLGMpe2EuZm5bY109ZnVuY3Rpb24oKXt2YXIgYT1BcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsMCk7cmV0dXJuIGQoXCJqUXVlcnkuZm4uXCIrYytcIigpIGlzIGRlcHJlY2F0ZWRcIiksXCJsb2FkXCI9PT1jJiZcInN0cmluZ1wiPT10eXBlb2YgYXJndW1lbnRzWzBdP0QuYXBwbHkodGhpcyxhcmd1bWVudHMpOihhLnNwbGljZSgwLDAsYyksYXJndW1lbnRzLmxlbmd0aD90aGlzLmJpbmQuYXBwbHkodGhpcyxhKToodGhpcy50cmlnZ2VySGFuZGxlci5hcHBseSh0aGlzLGEpLHRoaXMpKX19KSxhLmZuLnRvZ2dsZT1mdW5jdGlvbihiLGMpe2lmKCFhLmlzRnVuY3Rpb24oYil8fCFhLmlzRnVuY3Rpb24oYykpcmV0dXJuIEEuYXBwbHkodGhpcyxhcmd1bWVudHMpO2QoXCJqUXVlcnkuZm4udG9nZ2xlKGhhbmRsZXIsIGhhbmRsZXIuLi4pIGlzIGRlcHJlY2F0ZWRcIik7dmFyIGU9YXJndW1lbnRzLGY9Yi5ndWlkfHxhLmd1aWQrKyxnPTAsaD1mdW5jdGlvbihjKXt2YXIgZD0oYS5fZGF0YSh0aGlzLFwibGFzdFRvZ2dsZVwiK2IuZ3VpZCl8fDApJWc7cmV0dXJuIGEuX2RhdGEodGhpcyxcImxhc3RUb2dnbGVcIitiLmd1aWQsZCsxKSxjLnByZXZlbnREZWZhdWx0KCksZVtkXS5hcHBseSh0aGlzLGFyZ3VtZW50cyl8fCExfTtmb3IoaC5ndWlkPWY7ZzxlLmxlbmd0aDspZVtnKytdLmd1aWQ9ZjtyZXR1cm4gdGhpcy5jbGljayhoKX0sYS5mbi5saXZlPWZ1bmN0aW9uKGIsYyxlKXtyZXR1cm4gZChcImpRdWVyeS5mbi5saXZlKCkgaXMgZGVwcmVjYXRlZFwiKSxCP0IuYXBwbHkodGhpcyxhcmd1bWVudHMpOihhKHRoaXMuY29udGV4dCkub24oYix0aGlzLnNlbGVjdG9yLGMsZSksdGhpcyl9LGEuZm4uZGllPWZ1bmN0aW9uKGIsYyl7cmV0dXJuIGQoXCJqUXVlcnkuZm4uZGllKCkgaXMgZGVwcmVjYXRlZFwiKSxDP0MuYXBwbHkodGhpcyxhcmd1bWVudHMpOihhKHRoaXMuY29udGV4dCkub2ZmKGIsdGhpcy5zZWxlY3Rvcnx8XCIqKlwiLGMpLHRoaXMpfSxhLmV2ZW50LnRyaWdnZXI9ZnVuY3Rpb24oYSxiLGMsZSl7cmV0dXJuIGN8fEYudGVzdChhKXx8ZChcIkdsb2JhbCBldmVudHMgYXJlIHVuZG9jdW1lbnRlZCBhbmQgZGVwcmVjYXRlZFwiKSx6LmNhbGwodGhpcyxhLGIsY3x8ZG9jdW1lbnQsZSl9LGEuZWFjaChFLnNwbGl0KFwifFwiKSxmdW5jdGlvbihiLGMpe2EuZXZlbnQuc3BlY2lhbFtjXT17c2V0dXA6ZnVuY3Rpb24oKXt2YXIgYj10aGlzO3JldHVybiBiIT09ZG9jdW1lbnQmJihhLmV2ZW50LmFkZChkb2N1bWVudCxjK1wiLlwiK2EuZ3VpZCxmdW5jdGlvbigpe2EuZXZlbnQudHJpZ2dlcihjLEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywxKSxiLCEwKX0pLGEuX2RhdGEodGhpcyxjLGEuZ3VpZCsrKSksITF9LHRlYXJkb3duOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMhPT1kb2N1bWVudCYmYS5ldmVudC5yZW1vdmUoZG9jdW1lbnQsYytcIi5cIithLl9kYXRhKHRoaXMsYykpLCExfX19KSxhLmV2ZW50LnNwZWNpYWwucmVhZHk9e3NldHVwOmZ1bmN0aW9uKCl7ZChcIidyZWFkeScgZXZlbnQgaXMgZGVwcmVjYXRlZFwiKX19O3ZhciBJPWEuZm4uYW5kU2VsZnx8YS5mbi5hZGRCYWNrLEo9YS5mbi5maW5kO2lmKGEuZm4uYW5kU2VsZj1mdW5jdGlvbigpe3JldHVybiBkKFwialF1ZXJ5LmZuLmFuZFNlbGYoKSByZXBsYWNlZCBieSBqUXVlcnkuZm4uYWRkQmFjaygpXCIpLEkuYXBwbHkodGhpcyxhcmd1bWVudHMpfSxhLmZuLmZpbmQ9ZnVuY3Rpb24oYSl7dmFyIGI9Si5hcHBseSh0aGlzLGFyZ3VtZW50cyk7cmV0dXJuIGIuY29udGV4dD10aGlzLmNvbnRleHQsYi5zZWxlY3Rvcj10aGlzLnNlbGVjdG9yP3RoaXMuc2VsZWN0b3IrXCIgXCIrYTphLGJ9LGEuQ2FsbGJhY2tzKXt2YXIgSz1hLkRlZmVycmVkLEw9W1tcInJlc29sdmVcIixcImRvbmVcIixhLkNhbGxiYWNrcyhcIm9uY2UgbWVtb3J5XCIpLGEuQ2FsbGJhY2tzKFwib25jZSBtZW1vcnlcIiksXCJyZXNvbHZlZFwiXSxbXCJyZWplY3RcIixcImZhaWxcIixhLkNhbGxiYWNrcyhcIm9uY2UgbWVtb3J5XCIpLGEuQ2FsbGJhY2tzKFwib25jZSBtZW1vcnlcIiksXCJyZWplY3RlZFwiXSxbXCJub3RpZnlcIixcInByb2dyZXNzXCIsYS5DYWxsYmFja3MoXCJtZW1vcnlcIiksYS5DYWxsYmFja3MoXCJtZW1vcnlcIildXTthLkRlZmVycmVkPWZ1bmN0aW9uKGIpe3ZhciBjPUsoKSxlPWMucHJvbWlzZSgpO3JldHVybiBjLnBpcGU9ZS5waXBlPWZ1bmN0aW9uKCl7dmFyIGI9YXJndW1lbnRzO3JldHVybiBkKFwiZGVmZXJyZWQucGlwZSgpIGlzIGRlcHJlY2F0ZWRcIiksYS5EZWZlcnJlZChmdW5jdGlvbihkKXthLmVhY2goTCxmdW5jdGlvbihmLGcpe3ZhciBoPWEuaXNGdW5jdGlvbihiW2ZdKSYmYltmXTtjW2dbMV1dKGZ1bmN0aW9uKCl7dmFyIGI9aCYmaC5hcHBseSh0aGlzLGFyZ3VtZW50cyk7YiYmYS5pc0Z1bmN0aW9uKGIucHJvbWlzZSk/Yi5wcm9taXNlKCkuZG9uZShkLnJlc29sdmUpLmZhaWwoZC5yZWplY3QpLnByb2dyZXNzKGQubm90aWZ5KTpkW2dbMF0rXCJXaXRoXCJdKHRoaXM9PT1lP2QucHJvbWlzZSgpOnRoaXMsaD9bYl06YXJndW1lbnRzKX0pfSksYj1udWxsfSkucHJvbWlzZSgpfSxjLmlzUmVzb2x2ZWQ9ZnVuY3Rpb24oKXtyZXR1cm4gZChcImRlZmVycmVkLmlzUmVzb2x2ZWQgaXMgZGVwcmVjYXRlZFwiKSxcInJlc29sdmVkXCI9PT1jLnN0YXRlKCl9LGMuaXNSZWplY3RlZD1mdW5jdGlvbigpe3JldHVybiBkKFwiZGVmZXJyZWQuaXNSZWplY3RlZCBpcyBkZXByZWNhdGVkXCIpLFwicmVqZWN0ZWRcIj09PWMuc3RhdGUoKX0sYiYmYi5jYWxsKGMsYyksY319fShqUXVlcnksd2luZG93KTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zY3JpcHRzL3ZlbmRvcnMvanF1ZXJ5LW1pZ3JhdGUtMS4zLjAubWluLmpzIiwibW9kdWxlLmV4cG9ydHMgPSBnbG9iYWxbXCJrb1wiXSA9IHJlcXVpcmUoXCItIUQ6XFxcXHRpY2tldG1hc3Rlci1hcGktc3RhZ2luZy5naXRodWIuaW9cXFxcbm9kZV9tb2R1bGVzXFxcXGtub2Nrb3V0XFxcXGJ1aWxkXFxcXG91dHB1dFxcXFxrbm9ja291dC1sYXRlc3QuZGVidWcuanNcIik7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2V4cG9zZS1sb2FkZXI/a28hLi9+L2tub2Nrb3V0L2J1aWxkL291dHB1dC9rbm9ja291dC1sYXRlc3QuZGVidWcuanNcbi8vIG1vZHVsZSBpZCA9IDkzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qIVxuICogS25vY2tvdXQgSmF2YVNjcmlwdCBsaWJyYXJ5IHYzLjQuMVxuICogKGMpIFRoZSBLbm9ja291dC5qcyB0ZWFtIC0gaHR0cDovL2tub2Nrb3V0anMuY29tL1xuICogTGljZW5zZTogTUlUIChodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocClcbiAqL1xuXG4oZnVuY3Rpb24oKXtcbnZhciBERUJVRz10cnVlO1xuKGZ1bmN0aW9uKHVuZGVmaW5lZCl7XG4gICAgLy8gKDAsIGV2YWwpKCd0aGlzJykgaXMgYSByb2J1c3Qgd2F5IG9mIGdldHRpbmcgYSByZWZlcmVuY2UgdG8gdGhlIGdsb2JhbCBvYmplY3RcbiAgICAvLyBGb3IgZGV0YWlscywgc2VlIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMTQxMTk5ODgvcmV0dXJuLXRoaXMtMC1ldmFsdGhpcy8xNDEyMDAyMyMxNDEyMDAyM1xuICAgIHZhciB3aW5kb3cgPSB0aGlzIHx8ICgwLCBldmFsKSgndGhpcycpLFxuICAgICAgICBkb2N1bWVudCA9IHdpbmRvd1snZG9jdW1lbnQnXSxcbiAgICAgICAgbmF2aWdhdG9yID0gd2luZG93WyduYXZpZ2F0b3InXSxcbiAgICAgICAgalF1ZXJ5SW5zdGFuY2UgPSB3aW5kb3dbXCJqUXVlcnlcIl0sXG4gICAgICAgIEpTT04gPSB3aW5kb3dbXCJKU09OXCJdO1xuKGZ1bmN0aW9uKGZhY3RvcnkpIHtcbiAgICAvLyBTdXBwb3J0IHRocmVlIG1vZHVsZSBsb2FkaW5nIHNjZW5hcmlvc1xuICAgIGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZVsnYW1kJ10pIHtcbiAgICAgICAgLy8gWzFdIEFNRCBhbm9ueW1vdXMgbW9kdWxlXG4gICAgICAgIGRlZmluZShbJ2V4cG9ydHMnLCAncmVxdWlyZSddLCBmYWN0b3J5KTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0Jykge1xuICAgICAgICAvLyBbMl0gQ29tbW9uSlMvTm9kZS5qc1xuICAgICAgICBmYWN0b3J5KG1vZHVsZVsnZXhwb3J0cyddIHx8IGV4cG9ydHMpOyAgLy8gbW9kdWxlLmV4cG9ydHMgaXMgZm9yIE5vZGUuanNcbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBbM10gTm8gbW9kdWxlIGxvYWRlciAocGxhaW4gPHNjcmlwdD4gdGFnKSAtIHB1dCBkaXJlY3RseSBpbiBnbG9iYWwgbmFtZXNwYWNlXG4gICAgICAgIGZhY3Rvcnkod2luZG93WydrbyddID0ge30pO1xuICAgIH1cbn0oZnVuY3Rpb24oa29FeHBvcnRzLCBhbWRSZXF1aXJlKXtcbi8vIEludGVybmFsbHksIGFsbCBLTyBvYmplY3RzIGFyZSBhdHRhY2hlZCB0byBrb0V4cG9ydHMgKGV2ZW4gdGhlIG5vbi1leHBvcnRlZCBvbmVzIHdob3NlIG5hbWVzIHdpbGwgYmUgbWluaWZpZWQgYnkgdGhlIGNsb3N1cmUgY29tcGlsZXIpLlxuLy8gSW4gdGhlIGZ1dHVyZSwgdGhlIGZvbGxvd2luZyBcImtvXCIgdmFyaWFibGUgbWF5IGJlIG1hZGUgZGlzdGluY3QgZnJvbSBcImtvRXhwb3J0c1wiIHNvIHRoYXQgcHJpdmF0ZSBvYmplY3RzIGFyZSBub3QgZXh0ZXJuYWxseSByZWFjaGFibGUuXG52YXIga28gPSB0eXBlb2Yga29FeHBvcnRzICE9PSAndW5kZWZpbmVkJyA/IGtvRXhwb3J0cyA6IHt9O1xuLy8gR29vZ2xlIENsb3N1cmUgQ29tcGlsZXIgaGVscGVycyAodXNlZCBvbmx5IHRvIG1ha2UgdGhlIG1pbmlmaWVkIGZpbGUgc21hbGxlcilcbmtvLmV4cG9ydFN5bWJvbCA9IGZ1bmN0aW9uKGtvUGF0aCwgb2JqZWN0KSB7XG4gICAgdmFyIHRva2VucyA9IGtvUGF0aC5zcGxpdChcIi5cIik7XG5cbiAgICAvLyBJbiB0aGUgZnV0dXJlLCBcImtvXCIgbWF5IGJlY29tZSBkaXN0aW5jdCBmcm9tIFwia29FeHBvcnRzXCIgKHNvIHRoYXQgbm9uLWV4cG9ydGVkIG9iamVjdHMgYXJlIG5vdCByZWFjaGFibGUpXG4gICAgLy8gQXQgdGhhdCBwb2ludCwgXCJ0YXJnZXRcIiB3b3VsZCBiZSBzZXQgdG86ICh0eXBlb2Yga29FeHBvcnRzICE9PSBcInVuZGVmaW5lZFwiID8ga29FeHBvcnRzIDoga28pXG4gICAgdmFyIHRhcmdldCA9IGtvO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0b2tlbnMubGVuZ3RoIC0gMTsgaSsrKVxuICAgICAgICB0YXJnZXQgPSB0YXJnZXRbdG9rZW5zW2ldXTtcbiAgICB0YXJnZXRbdG9rZW5zW3Rva2Vucy5sZW5ndGggLSAxXV0gPSBvYmplY3Q7XG59O1xua28uZXhwb3J0UHJvcGVydHkgPSBmdW5jdGlvbihvd25lciwgcHVibGljTmFtZSwgb2JqZWN0KSB7XG4gICAgb3duZXJbcHVibGljTmFtZV0gPSBvYmplY3Q7XG59O1xua28udmVyc2lvbiA9IFwiMy40LjFcIjtcblxua28uZXhwb3J0U3ltYm9sKCd2ZXJzaW9uJywga28udmVyc2lvbik7XG4vLyBGb3IgYW55IG9wdGlvbnMgdGhhdCBtYXkgYWZmZWN0IHZhcmlvdXMgYXJlYXMgb2YgS25vY2tvdXQgYW5kIGFyZW4ndCBkaXJlY3RseSBhc3NvY2lhdGVkIHdpdGggZGF0YSBiaW5kaW5nLlxua28ub3B0aW9ucyA9IHtcbiAgICAnZGVmZXJVcGRhdGVzJzogZmFsc2UsXG4gICAgJ3VzZU9ubHlOYXRpdmVFdmVudHMnOiBmYWxzZVxufTtcblxuLy9rby5leHBvcnRTeW1ib2woJ29wdGlvbnMnLCBrby5vcHRpb25zKTsgICAvLyAnb3B0aW9ucycgaXNuJ3QgbWluaWZpZWRcbmtvLnV0aWxzID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBvYmplY3RGb3JFYWNoKG9iaiwgYWN0aW9uKSB7XG4gICAgICAgIGZvciAodmFyIHByb3AgaW4gb2JqKSB7XG4gICAgICAgICAgICBpZiAob2JqLmhhc093blByb3BlcnR5KHByb3ApKSB7XG4gICAgICAgICAgICAgICAgYWN0aW9uKHByb3AsIG9ialtwcm9wXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBleHRlbmQodGFyZ2V0LCBzb3VyY2UpIHtcbiAgICAgICAgaWYgKHNvdXJjZSkge1xuICAgICAgICAgICAgZm9yKHZhciBwcm9wIGluIHNvdXJjZSkge1xuICAgICAgICAgICAgICAgIGlmKHNvdXJjZS5oYXNPd25Qcm9wZXJ0eShwcm9wKSkge1xuICAgICAgICAgICAgICAgICAgICB0YXJnZXRbcHJvcF0gPSBzb3VyY2VbcHJvcF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2V0UHJvdG90eXBlT2Yob2JqLCBwcm90bykge1xuICAgICAgICBvYmouX19wcm90b19fID0gcHJvdG87XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuXG4gICAgdmFyIGNhblNldFByb3RvdHlwZSA9ICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5KTtcbiAgICB2YXIgY2FuVXNlU3ltYm9scyA9ICFERUJVRyAmJiB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nO1xuXG4gICAgLy8gUmVwcmVzZW50IHRoZSBrbm93biBldmVudCB0eXBlcyBpbiBhIGNvbXBhY3Qgd2F5LCB0aGVuIGF0IHJ1bnRpbWUgdHJhbnNmb3JtIGl0IGludG8gYSBoYXNoIHdpdGggZXZlbnQgbmFtZSBhcyBrZXkgKGZvciBmYXN0IGxvb2t1cClcbiAgICB2YXIga25vd25FdmVudHMgPSB7fSwga25vd25FdmVudFR5cGVzQnlFdmVudE5hbWUgPSB7fTtcbiAgICB2YXIga2V5RXZlbnRUeXBlTmFtZSA9IChuYXZpZ2F0b3IgJiYgL0ZpcmVmb3hcXC8yL2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KSkgPyAnS2V5Ym9hcmRFdmVudCcgOiAnVUlFdmVudHMnO1xuICAgIGtub3duRXZlbnRzW2tleUV2ZW50VHlwZU5hbWVdID0gWydrZXl1cCcsICdrZXlkb3duJywgJ2tleXByZXNzJ107XG4gICAga25vd25FdmVudHNbJ01vdXNlRXZlbnRzJ10gPSBbJ2NsaWNrJywgJ2RibGNsaWNrJywgJ21vdXNlZG93bicsICdtb3VzZXVwJywgJ21vdXNlbW92ZScsICdtb3VzZW92ZXInLCAnbW91c2VvdXQnLCAnbW91c2VlbnRlcicsICdtb3VzZWxlYXZlJ107XG4gICAgb2JqZWN0Rm9yRWFjaChrbm93bkV2ZW50cywgZnVuY3Rpb24oZXZlbnRUeXBlLCBrbm93bkV2ZW50c0ZvclR5cGUpIHtcbiAgICAgICAgaWYgKGtub3duRXZlbnRzRm9yVHlwZS5sZW5ndGgpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBqID0ga25vd25FdmVudHNGb3JUeXBlLmxlbmd0aDsgaSA8IGo7IGkrKylcbiAgICAgICAgICAgICAgICBrbm93bkV2ZW50VHlwZXNCeUV2ZW50TmFtZVtrbm93bkV2ZW50c0ZvclR5cGVbaV1dID0gZXZlbnRUeXBlO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgdmFyIGV2ZW50c1RoYXRNdXN0QmVSZWdpc3RlcmVkVXNpbmdBdHRhY2hFdmVudCA9IHsgJ3Byb3BlcnR5Y2hhbmdlJzogdHJ1ZSB9OyAvLyBXb3JrYXJvdW5kIGZvciBhbiBJRTkgaXNzdWUgLSBodHRwczovL2dpdGh1Yi5jb20vU3RldmVTYW5kZXJzb24va25vY2tvdXQvaXNzdWVzLzQwNlxuXG4gICAgLy8gRGV0ZWN0IElFIHZlcnNpb25zIGZvciBidWcgd29ya2Fyb3VuZHMgKHVzZXMgSUUgY29uZGl0aW9uYWxzLCBub3QgVUEgc3RyaW5nLCBmb3Igcm9idXN0bmVzcylcbiAgICAvLyBOb3RlIHRoYXQsIHNpbmNlIElFIDEwIGRvZXMgbm90IHN1cHBvcnQgY29uZGl0aW9uYWwgY29tbWVudHMsIHRoZSBmb2xsb3dpbmcgbG9naWMgb25seSBkZXRlY3RzIElFIDwgMTAuXG4gICAgLy8gQ3VycmVudGx5IHRoaXMgaXMgYnkgZGVzaWduLCBzaW5jZSBJRSAxMCsgYmVoYXZlcyBjb3JyZWN0bHkgd2hlbiB0cmVhdGVkIGFzIGEgc3RhbmRhcmQgYnJvd3Nlci5cbiAgICAvLyBJZiB0aGVyZSBpcyBhIGZ1dHVyZSBuZWVkIHRvIGRldGVjdCBzcGVjaWZpYyB2ZXJzaW9ucyBvZiBJRTEwKywgd2Ugd2lsbCBhbWVuZCB0aGlzLlxuICAgIHZhciBpZVZlcnNpb24gPSBkb2N1bWVudCAmJiAoZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciB2ZXJzaW9uID0gMywgZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JyksIGlFbGVtcyA9IGRpdi5nZXRFbGVtZW50c0J5VGFnTmFtZSgnaScpO1xuXG4gICAgICAgIC8vIEtlZXAgY29uc3RydWN0aW5nIGNvbmRpdGlvbmFsIEhUTUwgYmxvY2tzIHVudGlsIHdlIGhpdCBvbmUgdGhhdCByZXNvbHZlcyB0byBhbiBlbXB0eSBmcmFnbWVudFxuICAgICAgICB3aGlsZSAoXG4gICAgICAgICAgICBkaXYuaW5uZXJIVE1MID0gJzwhLS1baWYgZ3QgSUUgJyArICgrK3ZlcnNpb24pICsgJ10+PGk+PC9pPjwhW2VuZGlmXS0tPicsXG4gICAgICAgICAgICBpRWxlbXNbMF1cbiAgICAgICAgKSB7fVxuICAgICAgICByZXR1cm4gdmVyc2lvbiA+IDQgPyB2ZXJzaW9uIDogdW5kZWZpbmVkO1xuICAgIH0oKSk7XG4gICAgdmFyIGlzSWU2ID0gaWVWZXJzaW9uID09PSA2LFxuICAgICAgICBpc0llNyA9IGllVmVyc2lvbiA9PT0gNztcblxuICAgIGZ1bmN0aW9uIGlzQ2xpY2tPbkNoZWNrYWJsZUVsZW1lbnQoZWxlbWVudCwgZXZlbnRUeXBlKSB7XG4gICAgICAgIGlmICgoa28udXRpbHMudGFnTmFtZUxvd2VyKGVsZW1lbnQpICE9PSBcImlucHV0XCIpIHx8ICFlbGVtZW50LnR5cGUpIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKGV2ZW50VHlwZS50b0xvd2VyQ2FzZSgpICE9IFwiY2xpY2tcIikgcmV0dXJuIGZhbHNlO1xuICAgICAgICB2YXIgaW5wdXRUeXBlID0gZWxlbWVudC50eXBlO1xuICAgICAgICByZXR1cm4gKGlucHV0VHlwZSA9PSBcImNoZWNrYm94XCIpIHx8IChpbnB1dFR5cGUgPT0gXCJyYWRpb1wiKTtcbiAgICB9XG5cbiAgICAvLyBGb3IgZGV0YWlscyBvbiB0aGUgcGF0dGVybiBmb3IgY2hhbmdpbmcgbm9kZSBjbGFzc2VzXG4gICAgLy8gc2VlOiBodHRwczovL2dpdGh1Yi5jb20va25vY2tvdXQva25vY2tvdXQvaXNzdWVzLzE1OTdcbiAgICB2YXIgY3NzQ2xhc3NOYW1lUmVnZXggPSAvXFxTKy9nO1xuXG4gICAgZnVuY3Rpb24gdG9nZ2xlRG9tTm9kZUNzc0NsYXNzKG5vZGUsIGNsYXNzTmFtZXMsIHNob3VsZEhhdmVDbGFzcykge1xuICAgICAgICB2YXIgYWRkT3JSZW1vdmVGbjtcbiAgICAgICAgaWYgKGNsYXNzTmFtZXMpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygbm9kZS5jbGFzc0xpc3QgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgYWRkT3JSZW1vdmVGbiA9IG5vZGUuY2xhc3NMaXN0W3Nob3VsZEhhdmVDbGFzcyA/ICdhZGQnIDogJ3JlbW92ZSddO1xuICAgICAgICAgICAgICAgIGtvLnV0aWxzLmFycmF5Rm9yRWFjaChjbGFzc05hbWVzLm1hdGNoKGNzc0NsYXNzTmFtZVJlZ2V4KSwgZnVuY3Rpb24oY2xhc3NOYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIGFkZE9yUmVtb3ZlRm4uY2FsbChub2RlLmNsYXNzTGlzdCwgY2xhc3NOYW1lKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIG5vZGUuY2xhc3NOYW1lWydiYXNlVmFsJ10gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgLy8gU1ZHIHRhZyAuY2xhc3NOYW1lcyBpcyBhbiBTVkdBbmltYXRlZFN0cmluZyBpbnN0YW5jZVxuICAgICAgICAgICAgICAgIHRvZ2dsZU9iamVjdENsYXNzUHJvcGVydHlTdHJpbmcobm9kZS5jbGFzc05hbWUsICdiYXNlVmFsJywgY2xhc3NOYW1lcywgc2hvdWxkSGF2ZUNsYXNzKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gbm9kZS5jbGFzc05hbWUgb3VnaHQgdG8gYmUgYSBzdHJpbmcuXG4gICAgICAgICAgICAgICAgdG9nZ2xlT2JqZWN0Q2xhc3NQcm9wZXJ0eVN0cmluZyhub2RlLCAnY2xhc3NOYW1lJywgY2xhc3NOYW1lcywgc2hvdWxkSGF2ZUNsYXNzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRvZ2dsZU9iamVjdENsYXNzUHJvcGVydHlTdHJpbmcob2JqLCBwcm9wLCBjbGFzc05hbWVzLCBzaG91bGRIYXZlQ2xhc3MpIHtcbiAgICAgICAgLy8gb2JqL3Byb3AgaXMgZWl0aGVyIGEgbm9kZS8nY2xhc3NOYW1lJyBvciBhIFNWR0FuaW1hdGVkU3RyaW5nLydiYXNlVmFsJy5cbiAgICAgICAgdmFyIGN1cnJlbnRDbGFzc05hbWVzID0gb2JqW3Byb3BdLm1hdGNoKGNzc0NsYXNzTmFtZVJlZ2V4KSB8fCBbXTtcbiAgICAgICAga28udXRpbHMuYXJyYXlGb3JFYWNoKGNsYXNzTmFtZXMubWF0Y2goY3NzQ2xhc3NOYW1lUmVnZXgpLCBmdW5jdGlvbihjbGFzc05hbWUpIHtcbiAgICAgICAgICAgIGtvLnV0aWxzLmFkZE9yUmVtb3ZlSXRlbShjdXJyZW50Q2xhc3NOYW1lcywgY2xhc3NOYW1lLCBzaG91bGRIYXZlQ2xhc3MpO1xuICAgICAgICB9KTtcbiAgICAgICAgb2JqW3Byb3BdID0gY3VycmVudENsYXNzTmFtZXMuam9pbihcIiBcIik7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgZmllbGRzSW5jbHVkZWRXaXRoSnNvblBvc3Q6IFsnYXV0aGVudGljaXR5X3Rva2VuJywgL15fX1JlcXVlc3RWZXJpZmljYXRpb25Ub2tlbihfLiopPyQvXSxcblxuICAgICAgICBhcnJheUZvckVhY2g6IGZ1bmN0aW9uIChhcnJheSwgYWN0aW9uKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgaiA9IGFycmF5Lmxlbmd0aDsgaSA8IGo7IGkrKylcbiAgICAgICAgICAgICAgICBhY3Rpb24oYXJyYXlbaV0sIGkpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGFycmF5SW5kZXhPZjogZnVuY3Rpb24gKGFycmF5LCBpdGVtKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIEFycmF5LnByb3RvdHlwZS5pbmRleE9mID09IFwiZnVuY3Rpb25cIilcbiAgICAgICAgICAgICAgICByZXR1cm4gQXJyYXkucHJvdG90eXBlLmluZGV4T2YuY2FsbChhcnJheSwgaXRlbSk7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgaiA9IGFycmF5Lmxlbmd0aDsgaSA8IGo7IGkrKylcbiAgICAgICAgICAgICAgICBpZiAoYXJyYXlbaV0gPT09IGl0ZW0pXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9LFxuXG4gICAgICAgIGFycmF5Rmlyc3Q6IGZ1bmN0aW9uIChhcnJheSwgcHJlZGljYXRlLCBwcmVkaWNhdGVPd25lcikge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGogPSBhcnJheS5sZW5ndGg7IGkgPCBqOyBpKyspXG4gICAgICAgICAgICAgICAgaWYgKHByZWRpY2F0ZS5jYWxsKHByZWRpY2F0ZU93bmVyLCBhcnJheVtpXSwgaSkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhcnJheVtpXTtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9LFxuXG4gICAgICAgIGFycmF5UmVtb3ZlSXRlbTogZnVuY3Rpb24gKGFycmF5LCBpdGVtVG9SZW1vdmUpIHtcbiAgICAgICAgICAgIHZhciBpbmRleCA9IGtvLnV0aWxzLmFycmF5SW5kZXhPZihhcnJheSwgaXRlbVRvUmVtb3ZlKTtcbiAgICAgICAgICAgIGlmIChpbmRleCA+IDApIHtcbiAgICAgICAgICAgICAgICBhcnJheS5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaW5kZXggPT09IDApIHtcbiAgICAgICAgICAgICAgICBhcnJheS5zaGlmdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIGFycmF5R2V0RGlzdGluY3RWYWx1ZXM6IGZ1bmN0aW9uIChhcnJheSkge1xuICAgICAgICAgICAgYXJyYXkgPSBhcnJheSB8fCBbXTtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBqID0gYXJyYXkubGVuZ3RoOyBpIDwgajsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGtvLnV0aWxzLmFycmF5SW5kZXhPZihyZXN1bHQsIGFycmF5W2ldKSA8IDApXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGFycmF5W2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH0sXG5cbiAgICAgICAgYXJyYXlNYXA6IGZ1bmN0aW9uIChhcnJheSwgbWFwcGluZykge1xuICAgICAgICAgICAgYXJyYXkgPSBhcnJheSB8fCBbXTtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBqID0gYXJyYXkubGVuZ3RoOyBpIDwgajsgaSsrKVxuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKG1hcHBpbmcoYXJyYXlbaV0sIGkpKTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH0sXG5cbiAgICAgICAgYXJyYXlGaWx0ZXI6IGZ1bmN0aW9uIChhcnJheSwgcHJlZGljYXRlKSB7XG4gICAgICAgICAgICBhcnJheSA9IGFycmF5IHx8IFtdO1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGogPSBhcnJheS5sZW5ndGg7IGkgPCBqOyBpKyspXG4gICAgICAgICAgICAgICAgaWYgKHByZWRpY2F0ZShhcnJheVtpXSwgaSkpXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGFycmF5W2ldKTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH0sXG5cbiAgICAgICAgYXJyYXlQdXNoQWxsOiBmdW5jdGlvbiAoYXJyYXksIHZhbHVlc1RvUHVzaCkge1xuICAgICAgICAgICAgaWYgKHZhbHVlc1RvUHVzaCBpbnN0YW5jZW9mIEFycmF5KVxuICAgICAgICAgICAgICAgIGFycmF5LnB1c2guYXBwbHkoYXJyYXksIHZhbHVlc1RvUHVzaCk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGogPSB2YWx1ZXNUb1B1c2gubGVuZ3RoOyBpIDwgajsgaSsrKVxuICAgICAgICAgICAgICAgICAgICBhcnJheS5wdXNoKHZhbHVlc1RvUHVzaFtpXSk7XG4gICAgICAgICAgICByZXR1cm4gYXJyYXk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgYWRkT3JSZW1vdmVJdGVtOiBmdW5jdGlvbihhcnJheSwgdmFsdWUsIGluY2x1ZGVkKSB7XG4gICAgICAgICAgICB2YXIgZXhpc3RpbmdFbnRyeUluZGV4ID0ga28udXRpbHMuYXJyYXlJbmRleE9mKGtvLnV0aWxzLnBlZWtPYnNlcnZhYmxlKGFycmF5KSwgdmFsdWUpO1xuICAgICAgICAgICAgaWYgKGV4aXN0aW5nRW50cnlJbmRleCA8IDApIHtcbiAgICAgICAgICAgICAgICBpZiAoaW5jbHVkZWQpXG4gICAgICAgICAgICAgICAgICAgIGFycmF5LnB1c2godmFsdWUpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoIWluY2x1ZGVkKVxuICAgICAgICAgICAgICAgICAgICBhcnJheS5zcGxpY2UoZXhpc3RpbmdFbnRyeUluZGV4LCAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBjYW5TZXRQcm90b3R5cGU6IGNhblNldFByb3RvdHlwZSxcblxuICAgICAgICBleHRlbmQ6IGV4dGVuZCxcblxuICAgICAgICBzZXRQcm90b3R5cGVPZjogc2V0UHJvdG90eXBlT2YsXG5cbiAgICAgICAgc2V0UHJvdG90eXBlT2ZPckV4dGVuZDogY2FuU2V0UHJvdG90eXBlID8gc2V0UHJvdG90eXBlT2YgOiBleHRlbmQsXG5cbiAgICAgICAgb2JqZWN0Rm9yRWFjaDogb2JqZWN0Rm9yRWFjaCxcblxuICAgICAgICBvYmplY3RNYXA6IGZ1bmN0aW9uKHNvdXJjZSwgbWFwcGluZykge1xuICAgICAgICAgICAgaWYgKCFzb3VyY2UpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHNvdXJjZTtcbiAgICAgICAgICAgIHZhciB0YXJnZXQgPSB7fTtcbiAgICAgICAgICAgIGZvciAodmFyIHByb3AgaW4gc291cmNlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNvdXJjZS5oYXNPd25Qcm9wZXJ0eShwcm9wKSkge1xuICAgICAgICAgICAgICAgICAgICB0YXJnZXRbcHJvcF0gPSBtYXBwaW5nKHNvdXJjZVtwcm9wXSwgcHJvcCwgc291cmNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGFyZ2V0O1xuICAgICAgICB9LFxuXG4gICAgICAgIGVtcHR5RG9tTm9kZTogZnVuY3Rpb24gKGRvbU5vZGUpIHtcbiAgICAgICAgICAgIHdoaWxlIChkb21Ob2RlLmZpcnN0Q2hpbGQpIHtcbiAgICAgICAgICAgICAgICBrby5yZW1vdmVOb2RlKGRvbU5vZGUuZmlyc3RDaGlsZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgbW92ZUNsZWFuZWROb2Rlc1RvQ29udGFpbmVyRWxlbWVudDogZnVuY3Rpb24obm9kZXMpIHtcbiAgICAgICAgICAgIC8vIEVuc3VyZSBpdCdzIGEgcmVhbCBhcnJheSwgYXMgd2UncmUgYWJvdXQgdG8gcmVwYXJlbnQgdGhlIG5vZGVzIGFuZFxuICAgICAgICAgICAgLy8gd2UgZG9uJ3Qgd2FudCB0aGUgdW5kZXJseWluZyBjb2xsZWN0aW9uIHRvIGNoYW5nZSB3aGlsZSB3ZSdyZSBkb2luZyB0aGF0LlxuICAgICAgICAgICAgdmFyIG5vZGVzQXJyYXkgPSBrby51dGlscy5tYWtlQXJyYXkobm9kZXMpO1xuICAgICAgICAgICAgdmFyIHRlbXBsYXRlRG9jdW1lbnQgPSAobm9kZXNBcnJheVswXSAmJiBub2Rlc0FycmF5WzBdLm93bmVyRG9jdW1lbnQpIHx8IGRvY3VtZW50O1xuXG4gICAgICAgICAgICB2YXIgY29udGFpbmVyID0gdGVtcGxhdGVEb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBqID0gbm9kZXNBcnJheS5sZW5ndGg7IGkgPCBqOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQoa28uY2xlYW5Ob2RlKG5vZGVzQXJyYXlbaV0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBjb250YWluZXI7XG4gICAgICAgIH0sXG5cbiAgICAgICAgY2xvbmVOb2RlczogZnVuY3Rpb24gKG5vZGVzQXJyYXksIHNob3VsZENsZWFuTm9kZXMpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBqID0gbm9kZXNBcnJheS5sZW5ndGgsIG5ld05vZGVzQXJyYXkgPSBbXTsgaSA8IGo7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBjbG9uZWROb2RlID0gbm9kZXNBcnJheVtpXS5jbG9uZU5vZGUodHJ1ZSk7XG4gICAgICAgICAgICAgICAgbmV3Tm9kZXNBcnJheS5wdXNoKHNob3VsZENsZWFuTm9kZXMgPyBrby5jbGVhbk5vZGUoY2xvbmVkTm9kZSkgOiBjbG9uZWROb2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuZXdOb2Rlc0FycmF5O1xuICAgICAgICB9LFxuXG4gICAgICAgIHNldERvbU5vZGVDaGlsZHJlbjogZnVuY3Rpb24gKGRvbU5vZGUsIGNoaWxkTm9kZXMpIHtcbiAgICAgICAgICAgIGtvLnV0aWxzLmVtcHR5RG9tTm9kZShkb21Ob2RlKTtcbiAgICAgICAgICAgIGlmIChjaGlsZE5vZGVzKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGogPSBjaGlsZE5vZGVzLmxlbmd0aDsgaSA8IGo7IGkrKylcbiAgICAgICAgICAgICAgICAgICAgZG9tTm9kZS5hcHBlbmRDaGlsZChjaGlsZE5vZGVzW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICByZXBsYWNlRG9tTm9kZXM6IGZ1bmN0aW9uIChub2RlVG9SZXBsYWNlT3JOb2RlQXJyYXksIG5ld05vZGVzQXJyYXkpIHtcbiAgICAgICAgICAgIHZhciBub2Rlc1RvUmVwbGFjZUFycmF5ID0gbm9kZVRvUmVwbGFjZU9yTm9kZUFycmF5Lm5vZGVUeXBlID8gW25vZGVUb1JlcGxhY2VPck5vZGVBcnJheV0gOiBub2RlVG9SZXBsYWNlT3JOb2RlQXJyYXk7XG4gICAgICAgICAgICBpZiAobm9kZXNUb1JlcGxhY2VBcnJheS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgdmFyIGluc2VydGlvblBvaW50ID0gbm9kZXNUb1JlcGxhY2VBcnJheVswXTtcbiAgICAgICAgICAgICAgICB2YXIgcGFyZW50ID0gaW5zZXJ0aW9uUG9pbnQucGFyZW50Tm9kZTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgaiA9IG5ld05vZGVzQXJyYXkubGVuZ3RoOyBpIDwgajsgaSsrKVxuICAgICAgICAgICAgICAgICAgICBwYXJlbnQuaW5zZXJ0QmVmb3JlKG5ld05vZGVzQXJyYXlbaV0sIGluc2VydGlvblBvaW50KTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgaiA9IG5vZGVzVG9SZXBsYWNlQXJyYXkubGVuZ3RoOyBpIDwgajsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGtvLnJlbW92ZU5vZGUobm9kZXNUb1JlcGxhY2VBcnJheVtpXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIGZpeFVwQ29udGludW91c05vZGVBcnJheTogZnVuY3Rpb24oY29udGludW91c05vZGVBcnJheSwgcGFyZW50Tm9kZSkge1xuICAgICAgICAgICAgLy8gQmVmb3JlIGFjdGluZyBvbiBhIHNldCBvZiBub2RlcyB0aGF0IHdlcmUgcHJldmlvdXNseSBvdXRwdXR0ZWQgYnkgYSB0ZW1wbGF0ZSBmdW5jdGlvbiwgd2UgaGF2ZSB0byByZWNvbmNpbGVcbiAgICAgICAgICAgIC8vIHRoZW0gYWdhaW5zdCB3aGF0IGlzIGluIHRoZSBET00gcmlnaHQgbm93LiBJdCBtYXkgYmUgdGhhdCBzb21lIG9mIHRoZSBub2RlcyBoYXZlIGFscmVhZHkgYmVlbiByZW1vdmVkLCBvciB0aGF0XG4gICAgICAgICAgICAvLyBuZXcgbm9kZXMgbWlnaHQgaGF2ZSBiZWVuIGluc2VydGVkIGluIHRoZSBtaWRkbGUsIGZvciBleGFtcGxlIGJ5IGEgYmluZGluZy4gQWxzbywgdGhlcmUgbWF5IHByZXZpb3VzbHkgaGF2ZSBiZWVuXG4gICAgICAgICAgICAvLyBsZWFkaW5nIGNvbW1lbnQgbm9kZXMgKGNyZWF0ZWQgYnkgcmV3cml0dGVuIHN0cmluZy1iYXNlZCB0ZW1wbGF0ZXMpIHRoYXQgaGF2ZSBzaW5jZSBiZWVuIHJlbW92ZWQgZHVyaW5nIGJpbmRpbmcuXG4gICAgICAgICAgICAvLyBTbywgdGhpcyBmdW5jdGlvbiB0cmFuc2xhdGVzIHRoZSBvbGQgXCJtYXBcIiBvdXRwdXQgYXJyYXkgaW50byBpdHMgYmVzdCBndWVzcyBvZiB0aGUgc2V0IG9mIGN1cnJlbnQgRE9NIG5vZGVzLlxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vIFJ1bGVzOlxuICAgICAgICAgICAgLy8gICBbQV0gQW55IGxlYWRpbmcgbm9kZXMgdGhhdCBoYXZlIGJlZW4gcmVtb3ZlZCBzaG91bGQgYmUgaWdub3JlZFxuICAgICAgICAgICAgLy8gICAgICAgVGhlc2UgbW9zdCBsaWtlbHkgY29ycmVzcG9uZCB0byBtZW1vaXphdGlvbiBub2RlcyB0aGF0IHdlcmUgYWxyZWFkeSByZW1vdmVkIGR1cmluZyBiaW5kaW5nXG4gICAgICAgICAgICAvLyAgICAgICBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2tub2Nrb3V0L2tub2Nrb3V0L3B1bGwvNDQwXG4gICAgICAgICAgICAvLyAgIFtCXSBBbnkgdHJhaWxpbmcgbm9kZXMgdGhhdCBoYXZlIGJlZW4gcmVtb3ZlIHNob3VsZCBiZSBpZ25vcmVkXG4gICAgICAgICAgICAvLyAgICAgICBUaGlzIHByZXZlbnRzIHRoZSBjb2RlIGhlcmUgZnJvbSBhZGRpbmcgdW5yZWxhdGVkIG5vZGVzIHRvIHRoZSBhcnJheSB3aGlsZSBwcm9jZXNzaW5nIHJ1bGUgW0NdXG4gICAgICAgICAgICAvLyAgICAgICBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2tub2Nrb3V0L2tub2Nrb3V0L3B1bGwvMTkwM1xuICAgICAgICAgICAgLy8gICBbQ10gV2Ugd2FudCB0byBvdXRwdXQgYSBjb250aW51b3VzIHNlcmllcyBvZiBub2Rlcy4gU28sIGlnbm9yZSBhbnkgbm9kZXMgdGhhdCBoYXZlIGFscmVhZHkgYmVlbiByZW1vdmVkLFxuICAgICAgICAgICAgLy8gICAgICAgYW5kIGluY2x1ZGUgYW55IG5vZGVzIHRoYXQgaGF2ZSBiZWVuIGluc2VydGVkIGFtb25nIHRoZSBwcmV2aW91cyBjb2xsZWN0aW9uXG5cbiAgICAgICAgICAgIGlmIChjb250aW51b3VzTm9kZUFycmF5Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIC8vIFRoZSBwYXJlbnQgbm9kZSBjYW4gYmUgYSB2aXJ0dWFsIGVsZW1lbnQ7IHNvIGdldCB0aGUgcmVhbCBwYXJlbnQgbm9kZVxuICAgICAgICAgICAgICAgIHBhcmVudE5vZGUgPSAocGFyZW50Tm9kZS5ub2RlVHlwZSA9PT0gOCAmJiBwYXJlbnROb2RlLnBhcmVudE5vZGUpIHx8IHBhcmVudE5vZGU7XG5cbiAgICAgICAgICAgICAgICAvLyBSdWxlIFtBXVxuICAgICAgICAgICAgICAgIHdoaWxlIChjb250aW51b3VzTm9kZUFycmF5Lmxlbmd0aCAmJiBjb250aW51b3VzTm9kZUFycmF5WzBdLnBhcmVudE5vZGUgIT09IHBhcmVudE5vZGUpXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVvdXNOb2RlQXJyYXkuc3BsaWNlKDAsIDEpO1xuXG4gICAgICAgICAgICAgICAgLy8gUnVsZSBbQl1cbiAgICAgICAgICAgICAgICB3aGlsZSAoY29udGludW91c05vZGVBcnJheS5sZW5ndGggPiAxICYmIGNvbnRpbnVvdXNOb2RlQXJyYXlbY29udGludW91c05vZGVBcnJheS5sZW5ndGggLSAxXS5wYXJlbnROb2RlICE9PSBwYXJlbnROb2RlKVxuICAgICAgICAgICAgICAgICAgICBjb250aW51b3VzTm9kZUFycmF5Lmxlbmd0aC0tO1xuXG4gICAgICAgICAgICAgICAgLy8gUnVsZSBbQ11cbiAgICAgICAgICAgICAgICBpZiAoY29udGludW91c05vZGVBcnJheS5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjdXJyZW50ID0gY29udGludW91c05vZGVBcnJheVswXSwgbGFzdCA9IGNvbnRpbnVvdXNOb2RlQXJyYXlbY29udGludW91c05vZGVBcnJheS5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgICAgICAgICAgLy8gUmVwbGFjZSB3aXRoIHRoZSBhY3R1YWwgbmV3IGNvbnRpbnVvdXMgbm9kZSBzZXRcbiAgICAgICAgICAgICAgICAgICAgY29udGludW91c05vZGVBcnJheS5sZW5ndGggPSAwO1xuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoY3VycmVudCAhPT0gbGFzdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludW91c05vZGVBcnJheS5wdXNoKGN1cnJlbnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudCA9IGN1cnJlbnQubmV4dFNpYmxpbmc7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29udGludW91c05vZGVBcnJheS5wdXNoKGxhc3QpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBjb250aW51b3VzTm9kZUFycmF5O1xuICAgICAgICB9LFxuXG4gICAgICAgIHNldE9wdGlvbk5vZGVTZWxlY3Rpb25TdGF0ZTogZnVuY3Rpb24gKG9wdGlvbk5vZGUsIGlzU2VsZWN0ZWQpIHtcbiAgICAgICAgICAgIC8vIElFNiBzb21ldGltZXMgdGhyb3dzIFwidW5rbm93biBlcnJvclwiIGlmIHlvdSB0cnkgdG8gd3JpdGUgdG8gLnNlbGVjdGVkIGRpcmVjdGx5LCB3aGVyZWFzIEZpcmVmb3ggc3RydWdnbGVzIHdpdGggc2V0QXR0cmlidXRlLiBQaWNrIG9uZSBiYXNlZCBvbiBicm93c2VyLlxuICAgICAgICAgICAgaWYgKGllVmVyc2lvbiA8IDcpXG4gICAgICAgICAgICAgICAgb3B0aW9uTm9kZS5zZXRBdHRyaWJ1dGUoXCJzZWxlY3RlZFwiLCBpc1NlbGVjdGVkKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBvcHRpb25Ob2RlLnNlbGVjdGVkID0gaXNTZWxlY3RlZDtcbiAgICAgICAgfSxcblxuICAgICAgICBzdHJpbmdUcmltOiBmdW5jdGlvbiAoc3RyaW5nKSB7XG4gICAgICAgICAgICByZXR1cm4gc3RyaW5nID09PSBudWxsIHx8IHN0cmluZyA9PT0gdW5kZWZpbmVkID8gJycgOlxuICAgICAgICAgICAgICAgIHN0cmluZy50cmltID9cbiAgICAgICAgICAgICAgICAgICAgc3RyaW5nLnRyaW0oKSA6XG4gICAgICAgICAgICAgICAgICAgIHN0cmluZy50b1N0cmluZygpLnJlcGxhY2UoL15bXFxzXFx4YTBdK3xbXFxzXFx4YTBdKyQvZywgJycpO1xuICAgICAgICB9LFxuXG4gICAgICAgIHN0cmluZ1N0YXJ0c1dpdGg6IGZ1bmN0aW9uIChzdHJpbmcsIHN0YXJ0c1dpdGgpIHtcbiAgICAgICAgICAgIHN0cmluZyA9IHN0cmluZyB8fCBcIlwiO1xuICAgICAgICAgICAgaWYgKHN0YXJ0c1dpdGgubGVuZ3RoID4gc3RyaW5nLmxlbmd0aClcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICByZXR1cm4gc3RyaW5nLnN1YnN0cmluZygwLCBzdGFydHNXaXRoLmxlbmd0aCkgPT09IHN0YXJ0c1dpdGg7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZG9tTm9kZUlzQ29udGFpbmVkQnk6IGZ1bmN0aW9uIChub2RlLCBjb250YWluZWRCeU5vZGUpIHtcbiAgICAgICAgICAgIGlmIChub2RlID09PSBjb250YWluZWRCeU5vZGUpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICBpZiAobm9kZS5ub2RlVHlwZSA9PT0gMTEpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlOyAvLyBGaXhlcyBpc3N1ZSAjMTE2MiAtIGNhbid0IHVzZSBub2RlLmNvbnRhaW5zIGZvciBkb2N1bWVudCBmcmFnbWVudHMgb24gSUU4XG4gICAgICAgICAgICBpZiAoY29udGFpbmVkQnlOb2RlLmNvbnRhaW5zKVxuICAgICAgICAgICAgICAgIHJldHVybiBjb250YWluZWRCeU5vZGUuY29udGFpbnMobm9kZS5ub2RlVHlwZSA9PT0gMyA/IG5vZGUucGFyZW50Tm9kZSA6IG5vZGUpO1xuICAgICAgICAgICAgaWYgKGNvbnRhaW5lZEJ5Tm9kZS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbilcbiAgICAgICAgICAgICAgICByZXR1cm4gKGNvbnRhaW5lZEJ5Tm9kZS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbihub2RlKSAmIDE2KSA9PSAxNjtcbiAgICAgICAgICAgIHdoaWxlIChub2RlICYmIG5vZGUgIT0gY29udGFpbmVkQnlOb2RlKSB7XG4gICAgICAgICAgICAgICAgbm9kZSA9IG5vZGUucGFyZW50Tm9kZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAhIW5vZGU7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZG9tTm9kZUlzQXR0YWNoZWRUb0RvY3VtZW50OiBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgICAgcmV0dXJuIGtvLnV0aWxzLmRvbU5vZGVJc0NvbnRhaW5lZEJ5KG5vZGUsIG5vZGUub3duZXJEb2N1bWVudC5kb2N1bWVudEVsZW1lbnQpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGFueURvbU5vZGVJc0F0dGFjaGVkVG9Eb2N1bWVudDogZnVuY3Rpb24obm9kZXMpIHtcbiAgICAgICAgICAgIHJldHVybiAhIWtvLnV0aWxzLmFycmF5Rmlyc3Qobm9kZXMsIGtvLnV0aWxzLmRvbU5vZGVJc0F0dGFjaGVkVG9Eb2N1bWVudCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgdGFnTmFtZUxvd2VyOiBmdW5jdGlvbihlbGVtZW50KSB7XG4gICAgICAgICAgICAvLyBGb3IgSFRNTCBlbGVtZW50cywgdGFnTmFtZSB3aWxsIGFsd2F5cyBiZSB1cHBlciBjYXNlOyBmb3IgWEhUTUwgZWxlbWVudHMsIGl0J2xsIGJlIGxvd2VyIGNhc2UuXG4gICAgICAgICAgICAvLyBQb3NzaWJsZSBmdXR1cmUgb3B0aW1pemF0aW9uOiBJZiB3ZSBrbm93IGl0J3MgYW4gZWxlbWVudCBmcm9tIGFuIFhIVE1MIGRvY3VtZW50IChub3QgSFRNTCksXG4gICAgICAgICAgICAvLyB3ZSBkb24ndCBuZWVkIHRvIGRvIHRoZSAudG9Mb3dlckNhc2UoKSBhcyBpdCB3aWxsIGFsd2F5cyBiZSBsb3dlciBjYXNlIGFueXdheS5cbiAgICAgICAgICAgIHJldHVybiBlbGVtZW50ICYmIGVsZW1lbnQudGFnTmFtZSAmJiBlbGVtZW50LnRhZ05hbWUudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgfSxcblxuICAgICAgICBjYXRjaEZ1bmN0aW9uRXJyb3JzOiBmdW5jdGlvbiAoZGVsZWdhdGUpIHtcbiAgICAgICAgICAgIHJldHVybiBrb1snb25FcnJvciddID8gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkZWxlZ2F0ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAga29bJ29uRXJyb3InXSAmJiBrb1snb25FcnJvciddKGUpO1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gOiBkZWxlZ2F0ZTtcbiAgICAgICAgfSxcblxuICAgICAgICBzZXRUaW1lb3V0OiBmdW5jdGlvbiAoaGFuZGxlciwgdGltZW91dCkge1xuICAgICAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoa28udXRpbHMuY2F0Y2hGdW5jdGlvbkVycm9ycyhoYW5kbGVyKSwgdGltZW91dCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZGVmZXJFcnJvcjogZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBrb1snb25FcnJvciddICYmIGtvWydvbkVycm9yJ10oZXJyb3IpO1xuICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgfSwgMCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgcmVnaXN0ZXJFdmVudEhhbmRsZXI6IGZ1bmN0aW9uIChlbGVtZW50LCBldmVudFR5cGUsIGhhbmRsZXIpIHtcbiAgICAgICAgICAgIHZhciB3cmFwcGVkSGFuZGxlciA9IGtvLnV0aWxzLmNhdGNoRnVuY3Rpb25FcnJvcnMoaGFuZGxlcik7XG5cbiAgICAgICAgICAgIHZhciBtdXN0VXNlQXR0YWNoRXZlbnQgPSBpZVZlcnNpb24gJiYgZXZlbnRzVGhhdE11c3RCZVJlZ2lzdGVyZWRVc2luZ0F0dGFjaEV2ZW50W2V2ZW50VHlwZV07XG4gICAgICAgICAgICBpZiAoIWtvLm9wdGlvbnNbJ3VzZU9ubHlOYXRpdmVFdmVudHMnXSAmJiAhbXVzdFVzZUF0dGFjaEV2ZW50ICYmIGpRdWVyeUluc3RhbmNlKSB7XG4gICAgICAgICAgICAgICAgalF1ZXJ5SW5zdGFuY2UoZWxlbWVudClbJ2JpbmQnXShldmVudFR5cGUsIHdyYXBwZWRIYW5kbGVyKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIW11c3RVc2VBdHRhY2hFdmVudCAmJiB0eXBlb2YgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyID09IFwiZnVuY3Rpb25cIilcbiAgICAgICAgICAgICAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoZXZlbnRUeXBlLCB3cmFwcGVkSGFuZGxlciwgZmFsc2UpO1xuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIGVsZW1lbnQuYXR0YWNoRXZlbnQgIT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgICAgIHZhciBhdHRhY2hFdmVudEhhbmRsZXIgPSBmdW5jdGlvbiAoZXZlbnQpIHsgd3JhcHBlZEhhbmRsZXIuY2FsbChlbGVtZW50LCBldmVudCk7IH0sXG4gICAgICAgICAgICAgICAgICAgIGF0dGFjaEV2ZW50TmFtZSA9IFwib25cIiArIGV2ZW50VHlwZTtcbiAgICAgICAgICAgICAgICBlbGVtZW50LmF0dGFjaEV2ZW50KGF0dGFjaEV2ZW50TmFtZSwgYXR0YWNoRXZlbnRIYW5kbGVyKTtcblxuICAgICAgICAgICAgICAgIC8vIElFIGRvZXMgbm90IGRpc3Bvc2UgYXR0YWNoRXZlbnQgaGFuZGxlcnMgYXV0b21hdGljYWxseSAodW5saWtlIHdpdGggYWRkRXZlbnRMaXN0ZW5lcilcbiAgICAgICAgICAgICAgICAvLyBzbyB0byBhdm9pZCBsZWFrcywgd2UgaGF2ZSB0byByZW1vdmUgdGhlbSBtYW51YWxseS4gU2VlIGJ1ZyAjODU2XG4gICAgICAgICAgICAgICAga28udXRpbHMuZG9tTm9kZURpc3Bvc2FsLmFkZERpc3Bvc2VDYWxsYmFjayhlbGVtZW50LCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5kZXRhY2hFdmVudChhdHRhY2hFdmVudE5hbWUsIGF0dGFjaEV2ZW50SGFuZGxlcik7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2VcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJCcm93c2VyIGRvZXNuJ3Qgc3VwcG9ydCBhZGRFdmVudExpc3RlbmVyIG9yIGF0dGFjaEV2ZW50XCIpO1xuICAgICAgICB9LFxuXG4gICAgICAgIHRyaWdnZXJFdmVudDogZnVuY3Rpb24gKGVsZW1lbnQsIGV2ZW50VHlwZSkge1xuICAgICAgICAgICAgaWYgKCEoZWxlbWVudCAmJiBlbGVtZW50Lm5vZGVUeXBlKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJlbGVtZW50IG11c3QgYmUgYSBET00gbm9kZSB3aGVuIGNhbGxpbmcgdHJpZ2dlckV2ZW50XCIpO1xuXG4gICAgICAgICAgICAvLyBGb3IgY2xpY2sgZXZlbnRzIG9uIGNoZWNrYm94ZXMgYW5kIHJhZGlvIGJ1dHRvbnMsIGpRdWVyeSB0b2dnbGVzIHRoZSBlbGVtZW50IGNoZWNrZWQgc3RhdGUgKmFmdGVyKiB0aGVcbiAgICAgICAgICAgIC8vIGV2ZW50IGhhbmRsZXIgcnVucyBpbnN0ZWFkIG9mICpiZWZvcmUqLiAoVGhpcyB3YXMgZml4ZWQgaW4gMS45IGZvciBjaGVja2JveGVzIGJ1dCBub3QgZm9yIHJhZGlvIGJ1dHRvbnMuKVxuICAgICAgICAgICAgLy8gSUUgZG9lc24ndCBjaGFuZ2UgdGhlIGNoZWNrZWQgc3RhdGUgd2hlbiB5b3UgdHJpZ2dlciB0aGUgY2xpY2sgZXZlbnQgdXNpbmcgXCJmaXJlRXZlbnRcIi5cbiAgICAgICAgICAgIC8vIEluIGJvdGggY2FzZXMsIHdlJ2xsIHVzZSB0aGUgY2xpY2sgbWV0aG9kIGluc3RlYWQuXG4gICAgICAgICAgICB2YXIgdXNlQ2xpY2tXb3JrYXJvdW5kID0gaXNDbGlja09uQ2hlY2thYmxlRWxlbWVudChlbGVtZW50LCBldmVudFR5cGUpO1xuXG4gICAgICAgICAgICBpZiAoIWtvLm9wdGlvbnNbJ3VzZU9ubHlOYXRpdmVFdmVudHMnXSAmJiBqUXVlcnlJbnN0YW5jZSAmJiAhdXNlQ2xpY2tXb3JrYXJvdW5kKSB7XG4gICAgICAgICAgICAgICAgalF1ZXJ5SW5zdGFuY2UoZWxlbWVudClbJ3RyaWdnZXInXShldmVudFR5cGUpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgZG9jdW1lbnQuY3JlYXRlRXZlbnQgPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBlbGVtZW50LmRpc3BhdGNoRXZlbnQgPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBldmVudENhdGVnb3J5ID0ga25vd25FdmVudFR5cGVzQnlFdmVudE5hbWVbZXZlbnRUeXBlXSB8fCBcIkhUTUxFdmVudHNcIjtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGV2ZW50ID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoZXZlbnRDYXRlZ29yeSk7XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50LmluaXRFdmVudChldmVudFR5cGUsIHRydWUsIHRydWUsIHdpbmRvdywgMCwgMCwgMCwgMCwgMCwgZmFsc2UsIGZhbHNlLCBmYWxzZSwgZmFsc2UsIDAsIGVsZW1lbnQpO1xuICAgICAgICAgICAgICAgICAgICBlbGVtZW50LmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoZSBzdXBwbGllZCBlbGVtZW50IGRvZXNuJ3Qgc3VwcG9ydCBkaXNwYXRjaEV2ZW50XCIpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh1c2VDbGlja1dvcmthcm91bmQgJiYgZWxlbWVudC5jbGljaykge1xuICAgICAgICAgICAgICAgIGVsZW1lbnQuY2xpY2soKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGVsZW1lbnQuZmlyZUV2ZW50ICE9IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgICAgICBlbGVtZW50LmZpcmVFdmVudChcIm9uXCIgKyBldmVudFR5cGUpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJCcm93c2VyIGRvZXNuJ3Qgc3VwcG9ydCB0cmlnZ2VyaW5nIGV2ZW50c1wiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICB1bndyYXBPYnNlcnZhYmxlOiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiBrby5pc09ic2VydmFibGUodmFsdWUpID8gdmFsdWUoKSA6IHZhbHVlO1xuICAgICAgICB9LFxuXG4gICAgICAgIHBlZWtPYnNlcnZhYmxlOiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiBrby5pc09ic2VydmFibGUodmFsdWUpID8gdmFsdWUucGVlaygpIDogdmFsdWU7XG4gICAgICAgIH0sXG5cbiAgICAgICAgdG9nZ2xlRG9tTm9kZUNzc0NsYXNzOiB0b2dnbGVEb21Ob2RlQ3NzQ2xhc3MsXG5cbiAgICAgICAgc2V0VGV4dENvbnRlbnQ6IGZ1bmN0aW9uKGVsZW1lbnQsIHRleHRDb250ZW50KSB7XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBrby51dGlscy51bndyYXBPYnNlcnZhYmxlKHRleHRDb250ZW50KTtcbiAgICAgICAgICAgIGlmICgodmFsdWUgPT09IG51bGwpIHx8ICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSlcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IFwiXCI7XG5cbiAgICAgICAgICAgIC8vIFdlIG5lZWQgdGhlcmUgdG8gYmUgZXhhY3RseSBvbmUgY2hpbGQ6IGEgdGV4dCBub2RlLlxuICAgICAgICAgICAgLy8gSWYgdGhlcmUgYXJlIG5vIGNoaWxkcmVuLCBtb3JlIHRoYW4gb25lLCBvciBpZiBpdCdzIG5vdCBhIHRleHQgbm9kZSxcbiAgICAgICAgICAgIC8vIHdlJ2xsIGNsZWFyIGV2ZXJ5dGhpbmcgYW5kIGNyZWF0ZSBhIHNpbmdsZSB0ZXh0IG5vZGUuXG4gICAgICAgICAgICB2YXIgaW5uZXJUZXh0Tm9kZSA9IGtvLnZpcnR1YWxFbGVtZW50cy5maXJzdENoaWxkKGVsZW1lbnQpO1xuICAgICAgICAgICAgaWYgKCFpbm5lclRleHROb2RlIHx8IGlubmVyVGV4dE5vZGUubm9kZVR5cGUgIT0gMyB8fCBrby52aXJ0dWFsRWxlbWVudHMubmV4dFNpYmxpbmcoaW5uZXJUZXh0Tm9kZSkpIHtcbiAgICAgICAgICAgICAgICBrby52aXJ0dWFsRWxlbWVudHMuc2V0RG9tTm9kZUNoaWxkcmVuKGVsZW1lbnQsIFtlbGVtZW50Lm93bmVyRG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUodmFsdWUpXSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlubmVyVGV4dE5vZGUuZGF0YSA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBrby51dGlscy5mb3JjZVJlZnJlc2goZWxlbWVudCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgc2V0RWxlbWVudE5hbWU6IGZ1bmN0aW9uKGVsZW1lbnQsIG5hbWUpIHtcbiAgICAgICAgICAgIGVsZW1lbnQubmFtZSA9IG5hbWU7XG5cbiAgICAgICAgICAgIC8vIFdvcmthcm91bmQgSUUgNi83IGlzc3VlXG4gICAgICAgICAgICAvLyAtIGh0dHBzOi8vZ2l0aHViLmNvbS9TdGV2ZVNhbmRlcnNvbi9rbm9ja291dC9pc3N1ZXMvMTk3XG4gICAgICAgICAgICAvLyAtIGh0dHA6Ly93d3cubWF0dHM0MTEuY29tL3Bvc3Qvc2V0dGluZ190aGVfbmFtZV9hdHRyaWJ1dGVfaW5faWVfZG9tL1xuICAgICAgICAgICAgaWYgKGllVmVyc2lvbiA8PSA3KSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5tZXJnZUF0dHJpYnV0ZXMoZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcIjxpbnB1dCBuYW1lPSdcIiArIGVsZW1lbnQubmFtZSArIFwiJy8+XCIpLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoKGUpIHt9IC8vIEZvciBJRTkgd2l0aCBkb2MgbW9kZSBcIklFOSBTdGFuZGFyZHNcIiBhbmQgYnJvd3NlciBtb2RlIFwiSUU5IENvbXBhdGliaWxpdHkgVmlld1wiXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgZm9yY2VSZWZyZXNoOiBmdW5jdGlvbihub2RlKSB7XG4gICAgICAgICAgICAvLyBXb3JrYXJvdW5kIGZvciBhbiBJRTkgcmVuZGVyaW5nIGJ1ZyAtIGh0dHBzOi8vZ2l0aHViLmNvbS9TdGV2ZVNhbmRlcnNvbi9rbm9ja291dC9pc3N1ZXMvMjA5XG4gICAgICAgICAgICBpZiAoaWVWZXJzaW9uID49IDkpIHtcbiAgICAgICAgICAgICAgICAvLyBGb3IgdGV4dCBub2RlcyBhbmQgY29tbWVudCBub2RlcyAobW9zdCBsaWtlbHkgdmlydHVhbCBlbGVtZW50cyksIHdlIHdpbGwgaGF2ZSB0byByZWZyZXNoIHRoZSBjb250YWluZXJcbiAgICAgICAgICAgICAgICB2YXIgZWxlbSA9IG5vZGUubm9kZVR5cGUgPT0gMSA/IG5vZGUgOiBub2RlLnBhcmVudE5vZGU7XG4gICAgICAgICAgICAgICAgaWYgKGVsZW0uc3R5bGUpXG4gICAgICAgICAgICAgICAgICAgIGVsZW0uc3R5bGUuem9vbSA9IGVsZW0uc3R5bGUuem9vbTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBlbnN1cmVTZWxlY3RFbGVtZW50SXNSZW5kZXJlZENvcnJlY3RseTogZnVuY3Rpb24oc2VsZWN0RWxlbWVudCkge1xuICAgICAgICAgICAgLy8gV29ya2Fyb3VuZCBmb3IgSUU5IHJlbmRlcmluZyBidWcgLSBpdCBkb2Vzbid0IHJlbGlhYmx5IGRpc3BsYXkgYWxsIHRoZSB0ZXh0IGluIGR5bmFtaWNhbGx5LWFkZGVkIHNlbGVjdCBib3hlcyB1bmxlc3MgeW91IGZvcmNlIGl0IHRvIHJlLXJlbmRlciBieSB1cGRhdGluZyB0aGUgd2lkdGguXG4gICAgICAgICAgICAvLyAoU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9TdGV2ZVNhbmRlcnNvbi9rbm9ja291dC9pc3N1ZXMvMzEyLCBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzU5MDg0OTQvc2VsZWN0LW9ubHktc2hvd3MtZmlyc3QtY2hhci1vZi1zZWxlY3RlZC1vcHRpb24pXG4gICAgICAgICAgICAvLyBBbHNvIGZpeGVzIElFNyBhbmQgSUU4IGJ1ZyB0aGF0IGNhdXNlcyBzZWxlY3RzIHRvIGJlIHplcm8gd2lkdGggaWYgZW5jbG9zZWQgYnkgJ2lmJyBvciAnd2l0aCcuIChTZWUgaXNzdWUgIzgzOSlcbiAgICAgICAgICAgIGlmIChpZVZlcnNpb24pIHtcbiAgICAgICAgICAgICAgICB2YXIgb3JpZ2luYWxXaWR0aCA9IHNlbGVjdEVsZW1lbnQuc3R5bGUud2lkdGg7XG4gICAgICAgICAgICAgICAgc2VsZWN0RWxlbWVudC5zdHlsZS53aWR0aCA9IDA7XG4gICAgICAgICAgICAgICAgc2VsZWN0RWxlbWVudC5zdHlsZS53aWR0aCA9IG9yaWdpbmFsV2lkdGg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgcmFuZ2U6IGZ1bmN0aW9uIChtaW4sIG1heCkge1xuICAgICAgICAgICAgbWluID0ga28udXRpbHMudW53cmFwT2JzZXJ2YWJsZShtaW4pO1xuICAgICAgICAgICAgbWF4ID0ga28udXRpbHMudW53cmFwT2JzZXJ2YWJsZShtYXgpO1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IG1pbjsgaSA8PSBtYXg7IGkrKylcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChpKTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH0sXG5cbiAgICAgICAgbWFrZUFycmF5OiBmdW5jdGlvbihhcnJheUxpa2VPYmplY3QpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBqID0gYXJyYXlMaWtlT2JqZWN0Lmxlbmd0aDsgaSA8IGo7IGkrKykge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGFycmF5TGlrZU9iamVjdFtpXSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfSxcblxuICAgICAgICBjcmVhdGVTeW1ib2xPclN0cmluZzogZnVuY3Rpb24oaWRlbnRpZmllcikge1xuICAgICAgICAgICAgcmV0dXJuIGNhblVzZVN5bWJvbHMgPyBTeW1ib2woaWRlbnRpZmllcikgOiBpZGVudGlmaWVyO1xuICAgICAgICB9LFxuXG4gICAgICAgIGlzSWU2IDogaXNJZTYsXG4gICAgICAgIGlzSWU3IDogaXNJZTcsXG4gICAgICAgIGllVmVyc2lvbiA6IGllVmVyc2lvbixcblxuICAgICAgICBnZXRGb3JtRmllbGRzOiBmdW5jdGlvbihmb3JtLCBmaWVsZE5hbWUpIHtcbiAgICAgICAgICAgIHZhciBmaWVsZHMgPSBrby51dGlscy5tYWtlQXJyYXkoZm9ybS5nZXRFbGVtZW50c0J5VGFnTmFtZShcImlucHV0XCIpKS5jb25jYXQoa28udXRpbHMubWFrZUFycmF5KGZvcm0uZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJ0ZXh0YXJlYVwiKSkpO1xuICAgICAgICAgICAgdmFyIGlzTWF0Y2hpbmdGaWVsZCA9ICh0eXBlb2YgZmllbGROYW1lID09ICdzdHJpbmcnKVxuICAgICAgICAgICAgICAgID8gZnVuY3Rpb24oZmllbGQpIHsgcmV0dXJuIGZpZWxkLm5hbWUgPT09IGZpZWxkTmFtZSB9XG4gICAgICAgICAgICAgICAgOiBmdW5jdGlvbihmaWVsZCkgeyByZXR1cm4gZmllbGROYW1lLnRlc3QoZmllbGQubmFtZSkgfTsgLy8gVHJlYXQgZmllbGROYW1lIGFzIHJlZ2V4IG9yIG9iamVjdCBjb250YWluaW5nIHByZWRpY2F0ZVxuICAgICAgICAgICAgdmFyIG1hdGNoZXMgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSBmaWVsZHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNNYXRjaGluZ0ZpZWxkKGZpZWxkc1tpXSkpXG4gICAgICAgICAgICAgICAgICAgIG1hdGNoZXMucHVzaChmaWVsZHNbaV0pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiBtYXRjaGVzO1xuICAgICAgICB9LFxuXG4gICAgICAgIHBhcnNlSnNvbjogZnVuY3Rpb24gKGpzb25TdHJpbmcpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YganNvblN0cmluZyA9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAganNvblN0cmluZyA9IGtvLnV0aWxzLnN0cmluZ1RyaW0oanNvblN0cmluZyk7XG4gICAgICAgICAgICAgICAgaWYgKGpzb25TdHJpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKEpTT04gJiYgSlNPTi5wYXJzZSkgLy8gVXNlIG5hdGl2ZSBwYXJzaW5nIHdoZXJlIGF2YWlsYWJsZVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEpTT04ucGFyc2UoanNvblN0cmluZyk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAobmV3IEZ1bmN0aW9uKFwicmV0dXJuIFwiICsganNvblN0cmluZykpKCk7IC8vIEZhbGxiYWNrIG9uIGxlc3Mgc2FmZSBwYXJzaW5nIGZvciBvbGRlciBicm93c2Vyc1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9LFxuXG4gICAgICAgIHN0cmluZ2lmeUpzb246IGZ1bmN0aW9uIChkYXRhLCByZXBsYWNlciwgc3BhY2UpIHsgICAvLyByZXBsYWNlciBhbmQgc3BhY2UgYXJlIG9wdGlvbmFsXG4gICAgICAgICAgICBpZiAoIUpTT04gfHwgIUpTT04uc3RyaW5naWZ5KVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIEpTT04uc3RyaW5naWZ5KCkuIFNvbWUgYnJvd3NlcnMgKGUuZy4sIElFIDwgOCkgZG9uJ3Qgc3VwcG9ydCBpdCBuYXRpdmVseSwgYnV0IHlvdSBjYW4gb3ZlcmNvbWUgdGhpcyBieSBhZGRpbmcgYSBzY3JpcHQgcmVmZXJlbmNlIHRvIGpzb24yLmpzLCBkb3dubG9hZGFibGUgZnJvbSBodHRwOi8vd3d3Lmpzb24ub3JnL2pzb24yLmpzXCIpO1xuICAgICAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGtvLnV0aWxzLnVud3JhcE9ic2VydmFibGUoZGF0YSksIHJlcGxhY2VyLCBzcGFjZSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgcG9zdEpzb246IGZ1bmN0aW9uICh1cmxPckZvcm0sIGRhdGEsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgICAgICAgICAgdmFyIHBhcmFtcyA9IG9wdGlvbnNbJ3BhcmFtcyddIHx8IHt9O1xuICAgICAgICAgICAgdmFyIGluY2x1ZGVGaWVsZHMgPSBvcHRpb25zWydpbmNsdWRlRmllbGRzJ10gfHwgdGhpcy5maWVsZHNJbmNsdWRlZFdpdGhKc29uUG9zdDtcbiAgICAgICAgICAgIHZhciB1cmwgPSB1cmxPckZvcm07XG5cbiAgICAgICAgICAgIC8vIElmIHdlIHdlcmUgZ2l2ZW4gYSBmb3JtLCB1c2UgaXRzICdhY3Rpb24nIFVSTCBhbmQgcGljayBvdXQgYW55IHJlcXVlc3RlZCBmaWVsZCB2YWx1ZXNcbiAgICAgICAgICAgIGlmKCh0eXBlb2YgdXJsT3JGb3JtID09ICdvYmplY3QnKSAmJiAoa28udXRpbHMudGFnTmFtZUxvd2VyKHVybE9yRm9ybSkgPT09IFwiZm9ybVwiKSkge1xuICAgICAgICAgICAgICAgIHZhciBvcmlnaW5hbEZvcm0gPSB1cmxPckZvcm07XG4gICAgICAgICAgICAgICAgdXJsID0gb3JpZ2luYWxGb3JtLmFjdGlvbjtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gaW5jbHVkZUZpZWxkcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZmllbGRzID0ga28udXRpbHMuZ2V0Rm9ybUZpZWxkcyhvcmlnaW5hbEZvcm0sIGluY2x1ZGVGaWVsZHNbaV0pO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gZmllbGRzLmxlbmd0aCAtIDE7IGogPj0gMDsgai0tKVxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1zW2ZpZWxkc1tqXS5uYW1lXSA9IGZpZWxkc1tqXS52YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGRhdGEgPSBrby51dGlscy51bndyYXBPYnNlcnZhYmxlKGRhdGEpO1xuICAgICAgICAgICAgdmFyIGZvcm0gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZm9ybVwiKTtcbiAgICAgICAgICAgIGZvcm0uc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiO1xuICAgICAgICAgICAgZm9ybS5hY3Rpb24gPSB1cmw7XG4gICAgICAgICAgICBmb3JtLm1ldGhvZCA9IFwicG9zdFwiO1xuICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIGRhdGEpIHtcbiAgICAgICAgICAgICAgICAvLyBTaW5jZSAnZGF0YScgdGhpcyBpcyBhIG1vZGVsIG9iamVjdCwgd2UgaW5jbHVkZSBhbGwgcHJvcGVydGllcyBpbmNsdWRpbmcgdGhvc2UgaW5oZXJpdGVkIGZyb20gaXRzIHByb3RvdHlwZVxuICAgICAgICAgICAgICAgIHZhciBpbnB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpbnB1dFwiKTtcbiAgICAgICAgICAgICAgICBpbnB1dC50eXBlID0gXCJoaWRkZW5cIjtcbiAgICAgICAgICAgICAgICBpbnB1dC5uYW1lID0ga2V5O1xuICAgICAgICAgICAgICAgIGlucHV0LnZhbHVlID0ga28udXRpbHMuc3RyaW5naWZ5SnNvbihrby51dGlscy51bndyYXBPYnNlcnZhYmxlKGRhdGFba2V5XSkpO1xuICAgICAgICAgICAgICAgIGZvcm0uYXBwZW5kQ2hpbGQoaW5wdXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb2JqZWN0Rm9yRWFjaChwYXJhbXMsIGZ1bmN0aW9uKGtleSwgdmFsdWUpIHtcbiAgICAgICAgICAgICAgICB2YXIgaW5wdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaW5wdXRcIik7XG4gICAgICAgICAgICAgICAgaW5wdXQudHlwZSA9IFwiaGlkZGVuXCI7XG4gICAgICAgICAgICAgICAgaW5wdXQubmFtZSA9IGtleTtcbiAgICAgICAgICAgICAgICBpbnB1dC52YWx1ZSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIGZvcm0uYXBwZW5kQ2hpbGQoaW5wdXQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGZvcm0pO1xuICAgICAgICAgICAgb3B0aW9uc1snc3VibWl0dGVyJ10gPyBvcHRpb25zWydzdWJtaXR0ZXInXShmb3JtKSA6IGZvcm0uc3VibWl0KCk7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHsgZm9ybS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGZvcm0pOyB9LCAwKTtcbiAgICAgICAgfVxuICAgIH1cbn0oKSk7XG5cbmtvLmV4cG9ydFN5bWJvbCgndXRpbHMnLCBrby51dGlscyk7XG5rby5leHBvcnRTeW1ib2woJ3V0aWxzLmFycmF5Rm9yRWFjaCcsIGtvLnV0aWxzLmFycmF5Rm9yRWFjaCk7XG5rby5leHBvcnRTeW1ib2woJ3V0aWxzLmFycmF5Rmlyc3QnLCBrby51dGlscy5hcnJheUZpcnN0KTtcbmtvLmV4cG9ydFN5bWJvbCgndXRpbHMuYXJyYXlGaWx0ZXInLCBrby51dGlscy5hcnJheUZpbHRlcik7XG5rby5leHBvcnRTeW1ib2woJ3V0aWxzLmFycmF5R2V0RGlzdGluY3RWYWx1ZXMnLCBrby51dGlscy5hcnJheUdldERpc3RpbmN0VmFsdWVzKTtcbmtvLmV4cG9ydFN5bWJvbCgndXRpbHMuYXJyYXlJbmRleE9mJywga28udXRpbHMuYXJyYXlJbmRleE9mKTtcbmtvLmV4cG9ydFN5bWJvbCgndXRpbHMuYXJyYXlNYXAnLCBrby51dGlscy5hcnJheU1hcCk7XG5rby5leHBvcnRTeW1ib2woJ3V0aWxzLmFycmF5UHVzaEFsbCcsIGtvLnV0aWxzLmFycmF5UHVzaEFsbCk7XG5rby5leHBvcnRTeW1ib2woJ3V0aWxzLmFycmF5UmVtb3ZlSXRlbScsIGtvLnV0aWxzLmFycmF5UmVtb3ZlSXRlbSk7XG5rby5leHBvcnRTeW1ib2woJ3V0aWxzLmV4dGVuZCcsIGtvLnV0aWxzLmV4dGVuZCk7XG5rby5leHBvcnRTeW1ib2woJ3V0aWxzLmZpZWxkc0luY2x1ZGVkV2l0aEpzb25Qb3N0Jywga28udXRpbHMuZmllbGRzSW5jbHVkZWRXaXRoSnNvblBvc3QpO1xua28uZXhwb3J0U3ltYm9sKCd1dGlscy5nZXRGb3JtRmllbGRzJywga28udXRpbHMuZ2V0Rm9ybUZpZWxkcyk7XG5rby5leHBvcnRTeW1ib2woJ3V0aWxzLnBlZWtPYnNlcnZhYmxlJywga28udXRpbHMucGVla09ic2VydmFibGUpO1xua28uZXhwb3J0U3ltYm9sKCd1dGlscy5wb3N0SnNvbicsIGtvLnV0aWxzLnBvc3RKc29uKTtcbmtvLmV4cG9ydFN5bWJvbCgndXRpbHMucGFyc2VKc29uJywga28udXRpbHMucGFyc2VKc29uKTtcbmtvLmV4cG9ydFN5bWJvbCgndXRpbHMucmVnaXN0ZXJFdmVudEhhbmRsZXInLCBrby51dGlscy5yZWdpc3RlckV2ZW50SGFuZGxlcik7XG5rby5leHBvcnRTeW1ib2woJ3V0aWxzLnN0cmluZ2lmeUpzb24nLCBrby51dGlscy5zdHJpbmdpZnlKc29uKTtcbmtvLmV4cG9ydFN5bWJvbCgndXRpbHMucmFuZ2UnLCBrby51dGlscy5yYW5nZSk7XG5rby5leHBvcnRTeW1ib2woJ3V0aWxzLnRvZ2dsZURvbU5vZGVDc3NDbGFzcycsIGtvLnV0aWxzLnRvZ2dsZURvbU5vZGVDc3NDbGFzcyk7XG5rby5leHBvcnRTeW1ib2woJ3V0aWxzLnRyaWdnZXJFdmVudCcsIGtvLnV0aWxzLnRyaWdnZXJFdmVudCk7XG5rby5leHBvcnRTeW1ib2woJ3V0aWxzLnVud3JhcE9ic2VydmFibGUnLCBrby51dGlscy51bndyYXBPYnNlcnZhYmxlKTtcbmtvLmV4cG9ydFN5bWJvbCgndXRpbHMub2JqZWN0Rm9yRWFjaCcsIGtvLnV0aWxzLm9iamVjdEZvckVhY2gpO1xua28uZXhwb3J0U3ltYm9sKCd1dGlscy5hZGRPclJlbW92ZUl0ZW0nLCBrby51dGlscy5hZGRPclJlbW92ZUl0ZW0pO1xua28uZXhwb3J0U3ltYm9sKCd1dGlscy5zZXRUZXh0Q29udGVudCcsIGtvLnV0aWxzLnNldFRleHRDb250ZW50KTtcbmtvLmV4cG9ydFN5bWJvbCgndW53cmFwJywga28udXRpbHMudW53cmFwT2JzZXJ2YWJsZSk7IC8vIENvbnZlbmllbnQgc2hvcnRoYW5kLCBiZWNhdXNlIHRoaXMgaXMgdXNlZCBzbyBjb21tb25seVxuXG5pZiAoIUZ1bmN0aW9uLnByb3RvdHlwZVsnYmluZCddKSB7XG4gICAgLy8gRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQgaXMgYSBzdGFuZGFyZCBwYXJ0IG9mIEVDTUFTY3JpcHQgNXRoIEVkaXRpb24gKERlY2VtYmVyIDIwMDksIGh0dHA6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9wdWJsaWNhdGlvbnMvZmlsZXMvRUNNQS1TVC9FQ01BLTI2Mi5wZGYpXG4gICAgLy8gSW4gY2FzZSB0aGUgYnJvd3NlciBkb2Vzbid0IGltcGxlbWVudCBpdCBuYXRpdmVseSwgcHJvdmlkZSBhIEphdmFTY3JpcHQgaW1wbGVtZW50YXRpb24uIFRoaXMgaW1wbGVtZW50YXRpb24gaXMgYmFzZWQgb24gdGhlIG9uZSBpbiBwcm90b3R5cGUuanNcbiAgICBGdW5jdGlvbi5wcm90b3R5cGVbJ2JpbmQnXSA9IGZ1bmN0aW9uIChvYmplY3QpIHtcbiAgICAgICAgdmFyIG9yaWdpbmFsRnVuY3Rpb24gPSB0aGlzO1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gb3JpZ2luYWxGdW5jdGlvbi5hcHBseShvYmplY3QsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIHBhcnRpYWxBcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGFyZ3MgPSBwYXJ0aWFsQXJncy5zbGljZSgwKTtcbiAgICAgICAgICAgICAgICBhcmdzLnB1c2guYXBwbHkoYXJncywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gb3JpZ2luYWxGdW5jdGlvbi5hcHBseShvYmplY3QsIGFyZ3MpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH07XG59XG5cbmtvLnV0aWxzLmRvbURhdGEgPSBuZXcgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgdW5pcXVlSWQgPSAwO1xuICAgIHZhciBkYXRhU3RvcmVLZXlFeHBhbmRvUHJvcGVydHlOYW1lID0gXCJfX2tvX19cIiArIChuZXcgRGF0ZSkuZ2V0VGltZSgpO1xuICAgIHZhciBkYXRhU3RvcmUgPSB7fTtcblxuICAgIGZ1bmN0aW9uIGdldEFsbChub2RlLCBjcmVhdGVJZk5vdEZvdW5kKSB7XG4gICAgICAgIHZhciBkYXRhU3RvcmVLZXkgPSBub2RlW2RhdGFTdG9yZUtleUV4cGFuZG9Qcm9wZXJ0eU5hbWVdO1xuICAgICAgICB2YXIgaGFzRXhpc3RpbmdEYXRhU3RvcmUgPSBkYXRhU3RvcmVLZXkgJiYgKGRhdGFTdG9yZUtleSAhPT0gXCJudWxsXCIpICYmIGRhdGFTdG9yZVtkYXRhU3RvcmVLZXldO1xuICAgICAgICBpZiAoIWhhc0V4aXN0aW5nRGF0YVN0b3JlKSB7XG4gICAgICAgICAgICBpZiAoIWNyZWF0ZUlmTm90Rm91bmQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGRhdGFTdG9yZUtleSA9IG5vZGVbZGF0YVN0b3JlS2V5RXhwYW5kb1Byb3BlcnR5TmFtZV0gPSBcImtvXCIgKyB1bmlxdWVJZCsrO1xuICAgICAgICAgICAgZGF0YVN0b3JlW2RhdGFTdG9yZUtleV0gPSB7fTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGF0YVN0b3JlW2RhdGFTdG9yZUtleV07XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAobm9kZSwga2V5KSB7XG4gICAgICAgICAgICB2YXIgYWxsRGF0YUZvck5vZGUgPSBnZXRBbGwobm9kZSwgZmFsc2UpO1xuICAgICAgICAgICAgcmV0dXJuIGFsbERhdGFGb3JOb2RlID09PSB1bmRlZmluZWQgPyB1bmRlZmluZWQgOiBhbGxEYXRhRm9yTm9kZVtrZXldO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uIChub2RlLCBrZXksIHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSB3ZSBkb24ndCBhY3R1YWxseSBjcmVhdGUgYSBuZXcgZG9tRGF0YSBrZXkgaWYgd2UgYXJlIGFjdHVhbGx5IGRlbGV0aW5nIGEgdmFsdWVcbiAgICAgICAgICAgICAgICBpZiAoZ2V0QWxsKG5vZGUsIGZhbHNlKSA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgYWxsRGF0YUZvck5vZGUgPSBnZXRBbGwobm9kZSwgdHJ1ZSk7XG4gICAgICAgICAgICBhbGxEYXRhRm9yTm9kZVtrZXldID0gdmFsdWU7XG4gICAgICAgIH0sXG4gICAgICAgIGNsZWFyOiBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgICAgdmFyIGRhdGFTdG9yZUtleSA9IG5vZGVbZGF0YVN0b3JlS2V5RXhwYW5kb1Byb3BlcnR5TmFtZV07XG4gICAgICAgICAgICBpZiAoZGF0YVN0b3JlS2V5KSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIGRhdGFTdG9yZVtkYXRhU3RvcmVLZXldO1xuICAgICAgICAgICAgICAgIG5vZGVbZGF0YVN0b3JlS2V5RXhwYW5kb1Byb3BlcnR5TmFtZV0gPSBudWxsO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlOyAvLyBFeHBvc2luZyBcImRpZCBjbGVhblwiIGZsYWcgcHVyZWx5IHNvIHNwZWNzIGNhbiBpbmZlciB3aGV0aGVyIHRoaW5ncyBoYXZlIGJlZW4gY2xlYW5lZCB1cCBhcyBpbnRlbmRlZFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9LFxuXG4gICAgICAgIG5leHRLZXk6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiAodW5pcXVlSWQrKykgKyBkYXRhU3RvcmVLZXlFeHBhbmRvUHJvcGVydHlOYW1lO1xuICAgICAgICB9XG4gICAgfTtcbn0pKCk7XG5cbmtvLmV4cG9ydFN5bWJvbCgndXRpbHMuZG9tRGF0YScsIGtvLnV0aWxzLmRvbURhdGEpO1xua28uZXhwb3J0U3ltYm9sKCd1dGlscy5kb21EYXRhLmNsZWFyJywga28udXRpbHMuZG9tRGF0YS5jbGVhcik7IC8vIEV4cG9ydGluZyBvbmx5IHNvIHNwZWNzIGNhbiBjbGVhciB1cCBhZnRlciB0aGVtc2VsdmVzIGZ1bGx5XG5cbmtvLnV0aWxzLmRvbU5vZGVEaXNwb3NhbCA9IG5ldyAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBkb21EYXRhS2V5ID0ga28udXRpbHMuZG9tRGF0YS5uZXh0S2V5KCk7XG4gICAgdmFyIGNsZWFuYWJsZU5vZGVUeXBlcyA9IHsgMTogdHJ1ZSwgODogdHJ1ZSwgOTogdHJ1ZSB9OyAgICAgICAvLyBFbGVtZW50LCBDb21tZW50LCBEb2N1bWVudFxuICAgIHZhciBjbGVhbmFibGVOb2RlVHlwZXNXaXRoRGVzY2VuZGFudHMgPSB7IDE6IHRydWUsIDk6IHRydWUgfTsgLy8gRWxlbWVudCwgRG9jdW1lbnRcblxuICAgIGZ1bmN0aW9uIGdldERpc3Bvc2VDYWxsYmFja3NDb2xsZWN0aW9uKG5vZGUsIGNyZWF0ZUlmTm90Rm91bmQpIHtcbiAgICAgICAgdmFyIGFsbERpc3Bvc2VDYWxsYmFja3MgPSBrby51dGlscy5kb21EYXRhLmdldChub2RlLCBkb21EYXRhS2V5KTtcbiAgICAgICAgaWYgKChhbGxEaXNwb3NlQ2FsbGJhY2tzID09PSB1bmRlZmluZWQpICYmIGNyZWF0ZUlmTm90Rm91bmQpIHtcbiAgICAgICAgICAgIGFsbERpc3Bvc2VDYWxsYmFja3MgPSBbXTtcbiAgICAgICAgICAgIGtvLnV0aWxzLmRvbURhdGEuc2V0KG5vZGUsIGRvbURhdGFLZXksIGFsbERpc3Bvc2VDYWxsYmFja3MpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhbGxEaXNwb3NlQ2FsbGJhY2tzO1xuICAgIH1cbiAgICBmdW5jdGlvbiBkZXN0cm95Q2FsbGJhY2tzQ29sbGVjdGlvbihub2RlKSB7XG4gICAgICAgIGtvLnV0aWxzLmRvbURhdGEuc2V0KG5vZGUsIGRvbURhdGFLZXksIHVuZGVmaW5lZCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2xlYW5TaW5nbGVOb2RlKG5vZGUpIHtcbiAgICAgICAgLy8gUnVuIGFsbCB0aGUgZGlzcG9zZSBjYWxsYmFja3NcbiAgICAgICAgdmFyIGNhbGxiYWNrcyA9IGdldERpc3Bvc2VDYWxsYmFja3NDb2xsZWN0aW9uKG5vZGUsIGZhbHNlKTtcbiAgICAgICAgaWYgKGNhbGxiYWNrcykge1xuICAgICAgICAgICAgY2FsbGJhY2tzID0gY2FsbGJhY2tzLnNsaWNlKDApOyAvLyBDbG9uZSwgYXMgdGhlIGFycmF5IG1heSBiZSBtb2RpZmllZCBkdXJpbmcgaXRlcmF0aW9uICh0eXBpY2FsbHksIGNhbGxiYWNrcyB3aWxsIHJlbW92ZSB0aGVtc2VsdmVzKVxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjYWxsYmFja3MubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICAgICAgY2FsbGJhY2tzW2ldKG5vZGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRXJhc2UgdGhlIERPTSBkYXRhXG4gICAgICAgIGtvLnV0aWxzLmRvbURhdGEuY2xlYXIobm9kZSk7XG5cbiAgICAgICAgLy8gUGVyZm9ybSBjbGVhbnVwIG5lZWRlZCBieSBleHRlcm5hbCBsaWJyYXJpZXMgKGN1cnJlbnRseSBvbmx5IGpRdWVyeSwgYnV0IGNhbiBiZSBleHRlbmRlZClcbiAgICAgICAga28udXRpbHMuZG9tTm9kZURpc3Bvc2FsW1wiY2xlYW5FeHRlcm5hbERhdGFcIl0obm9kZSk7XG5cbiAgICAgICAgLy8gQ2xlYXIgYW55IGltbWVkaWF0ZS1jaGlsZCBjb21tZW50IG5vZGVzLCBhcyB0aGVzZSB3b3VsZG4ndCBoYXZlIGJlZW4gZm91bmQgYnlcbiAgICAgICAgLy8gbm9kZS5nZXRFbGVtZW50c0J5VGFnTmFtZShcIipcIikgaW4gY2xlYW5Ob2RlKCkgKGNvbW1lbnQgbm9kZXMgYXJlbid0IGVsZW1lbnRzKVxuICAgICAgICBpZiAoY2xlYW5hYmxlTm9kZVR5cGVzV2l0aERlc2NlbmRhbnRzW25vZGUubm9kZVR5cGVdKVxuICAgICAgICAgICAgY2xlYW5JbW1lZGlhdGVDb21tZW50VHlwZUNoaWxkcmVuKG5vZGUpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNsZWFuSW1tZWRpYXRlQ29tbWVudFR5cGVDaGlsZHJlbihub2RlV2l0aENoaWxkcmVuKSB7XG4gICAgICAgIHZhciBjaGlsZCwgbmV4dENoaWxkID0gbm9kZVdpdGhDaGlsZHJlbi5maXJzdENoaWxkO1xuICAgICAgICB3aGlsZSAoY2hpbGQgPSBuZXh0Q2hpbGQpIHtcbiAgICAgICAgICAgIG5leHRDaGlsZCA9IGNoaWxkLm5leHRTaWJsaW5nO1xuICAgICAgICAgICAgaWYgKGNoaWxkLm5vZGVUeXBlID09PSA4KVxuICAgICAgICAgICAgICAgIGNsZWFuU2luZ2xlTm9kZShjaGlsZCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgICBhZGREaXNwb3NlQ2FsbGJhY2sgOiBmdW5jdGlvbihub2RlLCBjYWxsYmFjaykge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayAhPSBcImZ1bmN0aW9uXCIpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2FsbGJhY2sgbXVzdCBiZSBhIGZ1bmN0aW9uXCIpO1xuICAgICAgICAgICAgZ2V0RGlzcG9zZUNhbGxiYWNrc0NvbGxlY3Rpb24obm9kZSwgdHJ1ZSkucHVzaChjYWxsYmFjayk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgcmVtb3ZlRGlzcG9zZUNhbGxiYWNrIDogZnVuY3Rpb24obm9kZSwgY2FsbGJhY2spIHtcbiAgICAgICAgICAgIHZhciBjYWxsYmFja3NDb2xsZWN0aW9uID0gZ2V0RGlzcG9zZUNhbGxiYWNrc0NvbGxlY3Rpb24obm9kZSwgZmFsc2UpO1xuICAgICAgICAgICAgaWYgKGNhbGxiYWNrc0NvbGxlY3Rpb24pIHtcbiAgICAgICAgICAgICAgICBrby51dGlscy5hcnJheVJlbW92ZUl0ZW0oY2FsbGJhY2tzQ29sbGVjdGlvbiwgY2FsbGJhY2spO1xuICAgICAgICAgICAgICAgIGlmIChjYWxsYmFja3NDb2xsZWN0aW9uLmxlbmd0aCA9PSAwKVxuICAgICAgICAgICAgICAgICAgICBkZXN0cm95Q2FsbGJhY2tzQ29sbGVjdGlvbihub2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBjbGVhbk5vZGUgOiBmdW5jdGlvbihub2RlKSB7XG4gICAgICAgICAgICAvLyBGaXJzdCBjbGVhbiB0aGlzIG5vZGUsIHdoZXJlIGFwcGxpY2FibGVcbiAgICAgICAgICAgIGlmIChjbGVhbmFibGVOb2RlVHlwZXNbbm9kZS5ub2RlVHlwZV0pIHtcbiAgICAgICAgICAgICAgICBjbGVhblNpbmdsZU5vZGUobm9kZSk7XG5cbiAgICAgICAgICAgICAgICAvLyAuLi4gdGhlbiBpdHMgZGVzY2VuZGFudHMsIHdoZXJlIGFwcGxpY2FibGVcbiAgICAgICAgICAgICAgICBpZiAoY2xlYW5hYmxlTm9kZVR5cGVzV2l0aERlc2NlbmRhbnRzW25vZGUubm9kZVR5cGVdKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIENsb25lIHRoZSBkZXNjZW5kYW50cyBsaXN0IGluIGNhc2UgaXQgY2hhbmdlcyBkdXJpbmcgaXRlcmF0aW9uXG4gICAgICAgICAgICAgICAgICAgIHZhciBkZXNjZW5kYW50cyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICBrby51dGlscy5hcnJheVB1c2hBbGwoZGVzY2VuZGFudHMsIG5vZGUuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCIqXCIpKTtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGogPSBkZXNjZW5kYW50cy5sZW5ndGg7IGkgPCBqOyBpKyspXG4gICAgICAgICAgICAgICAgICAgICAgICBjbGVhblNpbmdsZU5vZGUoZGVzY2VuZGFudHNbaV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBub2RlO1xuICAgICAgICB9LFxuXG4gICAgICAgIHJlbW92ZU5vZGUgOiBmdW5jdGlvbihub2RlKSB7XG4gICAgICAgICAgICBrby5jbGVhbk5vZGUobm9kZSk7XG4gICAgICAgICAgICBpZiAobm9kZS5wYXJlbnROb2RlKVxuICAgICAgICAgICAgICAgIG5vZGUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChub2RlKTtcbiAgICAgICAgfSxcblxuICAgICAgICBcImNsZWFuRXh0ZXJuYWxEYXRhXCIgOiBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgICAgLy8gU3BlY2lhbCBzdXBwb3J0IGZvciBqUXVlcnkgaGVyZSBiZWNhdXNlIGl0J3Mgc28gY29tbW9ubHkgdXNlZC5cbiAgICAgICAgICAgIC8vIE1hbnkgalF1ZXJ5IHBsdWdpbnMgKGluY2x1ZGluZyBqcXVlcnkudG1wbCkgc3RvcmUgZGF0YSB1c2luZyBqUXVlcnkncyBlcXVpdmFsZW50IG9mIGRvbURhdGFcbiAgICAgICAgICAgIC8vIHNvIG5vdGlmeSBpdCB0byB0ZWFyIGRvd24gYW55IHJlc291cmNlcyBhc3NvY2lhdGVkIHdpdGggdGhlIG5vZGUgJiBkZXNjZW5kYW50cyBoZXJlLlxuICAgICAgICAgICAgaWYgKGpRdWVyeUluc3RhbmNlICYmICh0eXBlb2YgalF1ZXJ5SW5zdGFuY2VbJ2NsZWFuRGF0YSddID09IFwiZnVuY3Rpb25cIikpXG4gICAgICAgICAgICAgICAgalF1ZXJ5SW5zdGFuY2VbJ2NsZWFuRGF0YSddKFtub2RlXSk7XG4gICAgICAgIH1cbiAgICB9O1xufSkoKTtcbmtvLmNsZWFuTm9kZSA9IGtvLnV0aWxzLmRvbU5vZGVEaXNwb3NhbC5jbGVhbk5vZGU7IC8vIFNob3J0aGFuZCBuYW1lIGZvciBjb252ZW5pZW5jZVxua28ucmVtb3ZlTm9kZSA9IGtvLnV0aWxzLmRvbU5vZGVEaXNwb3NhbC5yZW1vdmVOb2RlOyAvLyBTaG9ydGhhbmQgbmFtZSBmb3IgY29udmVuaWVuY2VcbmtvLmV4cG9ydFN5bWJvbCgnY2xlYW5Ob2RlJywga28uY2xlYW5Ob2RlKTtcbmtvLmV4cG9ydFN5bWJvbCgncmVtb3ZlTm9kZScsIGtvLnJlbW92ZU5vZGUpO1xua28uZXhwb3J0U3ltYm9sKCd1dGlscy5kb21Ob2RlRGlzcG9zYWwnLCBrby51dGlscy5kb21Ob2RlRGlzcG9zYWwpO1xua28uZXhwb3J0U3ltYm9sKCd1dGlscy5kb21Ob2RlRGlzcG9zYWwuYWRkRGlzcG9zZUNhbGxiYWNrJywga28udXRpbHMuZG9tTm9kZURpc3Bvc2FsLmFkZERpc3Bvc2VDYWxsYmFjayk7XG5rby5leHBvcnRTeW1ib2woJ3V0aWxzLmRvbU5vZGVEaXNwb3NhbC5yZW1vdmVEaXNwb3NlQ2FsbGJhY2snLCBrby51dGlscy5kb21Ob2RlRGlzcG9zYWwucmVtb3ZlRGlzcG9zZUNhbGxiYWNrKTtcbihmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG5vbmUgPSBbMCwgXCJcIiwgXCJcIl0sXG4gICAgICAgIHRhYmxlID0gWzEsIFwiPHRhYmxlPlwiLCBcIjwvdGFibGU+XCJdLFxuICAgICAgICB0Ym9keSA9IFsyLCBcIjx0YWJsZT48dGJvZHk+XCIsIFwiPC90Ym9keT48L3RhYmxlPlwiXSxcbiAgICAgICAgdHIgPSBbMywgXCI8dGFibGU+PHRib2R5Pjx0cj5cIiwgXCI8L3RyPjwvdGJvZHk+PC90YWJsZT5cIl0sXG4gICAgICAgIHNlbGVjdCA9IFsxLCBcIjxzZWxlY3QgbXVsdGlwbGU9J211bHRpcGxlJz5cIiwgXCI8L3NlbGVjdD5cIl0sXG4gICAgICAgIGxvb2t1cCA9IHtcbiAgICAgICAgICAgICd0aGVhZCc6IHRhYmxlLFxuICAgICAgICAgICAgJ3Rib2R5JzogdGFibGUsXG4gICAgICAgICAgICAndGZvb3QnOiB0YWJsZSxcbiAgICAgICAgICAgICd0cic6IHRib2R5LFxuICAgICAgICAgICAgJ3RkJzogdHIsXG4gICAgICAgICAgICAndGgnOiB0cixcbiAgICAgICAgICAgICdvcHRpb24nOiBzZWxlY3QsXG4gICAgICAgICAgICAnb3B0Z3JvdXAnOiBzZWxlY3RcbiAgICAgICAgfSxcblxuICAgICAgICAvLyBUaGlzIGlzIG5lZWRlZCBmb3Igb2xkIElFIGlmIHlvdSdyZSAqbm90KiB1c2luZyBlaXRoZXIgalF1ZXJ5IG9yIGlubmVyU2hpdi4gRG9lc24ndCBhZmZlY3Qgb3RoZXIgY2FzZXMuXG4gICAgICAgIG1heVJlcXVpcmVDcmVhdGVFbGVtZW50SGFjayA9IGtvLnV0aWxzLmllVmVyc2lvbiA8PSA4O1xuXG4gICAgZnVuY3Rpb24gZ2V0V3JhcCh0YWdzKSB7XG4gICAgICAgIHZhciBtID0gdGFncy5tYXRjaCgvXjwoW2Etel0rKVsgPl0vKTtcbiAgICAgICAgcmV0dXJuIChtICYmIGxvb2t1cFttWzFdXSkgfHwgbm9uZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzaW1wbGVIdG1sUGFyc2UoaHRtbCwgZG9jdW1lbnRDb250ZXh0KSB7XG4gICAgICAgIGRvY3VtZW50Q29udGV4dCB8fCAoZG9jdW1lbnRDb250ZXh0ID0gZG9jdW1lbnQpO1xuICAgICAgICB2YXIgd2luZG93Q29udGV4dCA9IGRvY3VtZW50Q29udGV4dFsncGFyZW50V2luZG93J10gfHwgZG9jdW1lbnRDb250ZXh0WydkZWZhdWx0VmlldyddIHx8IHdpbmRvdztcblxuICAgICAgICAvLyBCYXNlZCBvbiBqUXVlcnkncyBcImNsZWFuXCIgZnVuY3Rpb24sIGJ1dCBvbmx5IGFjY291bnRpbmcgZm9yIHRhYmxlLXJlbGF0ZWQgZWxlbWVudHMuXG4gICAgICAgIC8vIElmIHlvdSBoYXZlIHJlZmVyZW5jZWQgalF1ZXJ5LCB0aGlzIHdvbid0IGJlIHVzZWQgYW55d2F5IC0gS08gd2lsbCB1c2UgalF1ZXJ5J3MgXCJjbGVhblwiIGZ1bmN0aW9uIGRpcmVjdGx5XG5cbiAgICAgICAgLy8gTm90ZSB0aGF0IHRoZXJlJ3Mgc3RpbGwgYW4gaXNzdWUgaW4gSUUgPCA5IHdoZXJlYnkgaXQgd2lsbCBkaXNjYXJkIGNvbW1lbnQgbm9kZXMgdGhhdCBhcmUgdGhlIGZpcnN0IGNoaWxkIG9mXG4gICAgICAgIC8vIGEgZGVzY2VuZGFudCBub2RlLiBGb3IgZXhhbXBsZTogXCI8ZGl2PjwhLS0gbXljb21tZW50IC0tPmFiYzwvZGl2PlwiIHdpbGwgZ2V0IHBhcnNlZCBhcyBcIjxkaXY+YWJjPC9kaXY+XCJcbiAgICAgICAgLy8gVGhpcyB3b24ndCBhZmZlY3QgYW55b25lIHdobyBoYXMgcmVmZXJlbmNlZCBqUXVlcnksIGFuZCB0aGVyZSdzIGFsd2F5cyB0aGUgd29ya2Fyb3VuZCBvZiBpbnNlcnRpbmcgYSBkdW1teSBub2RlXG4gICAgICAgIC8vIChwb3NzaWJseSBhIHRleHQgbm9kZSkgaW4gZnJvbnQgb2YgdGhlIGNvbW1lbnQuIFNvLCBLTyBkb2VzIG5vdCBhdHRlbXB0IHRvIHdvcmthcm91bmQgdGhpcyBJRSBpc3N1ZSBhdXRvbWF0aWNhbGx5IGF0IHByZXNlbnQuXG5cbiAgICAgICAgLy8gVHJpbSB3aGl0ZXNwYWNlLCBvdGhlcndpc2UgaW5kZXhPZiB3b24ndCB3b3JrIGFzIGV4cGVjdGVkXG4gICAgICAgIHZhciB0YWdzID0ga28udXRpbHMuc3RyaW5nVHJpbShodG1sKS50b0xvd2VyQ2FzZSgpLCBkaXYgPSBkb2N1bWVudENvbnRleHQuY3JlYXRlRWxlbWVudChcImRpdlwiKSxcbiAgICAgICAgICAgIHdyYXAgPSBnZXRXcmFwKHRhZ3MpLFxuICAgICAgICAgICAgZGVwdGggPSB3cmFwWzBdO1xuXG4gICAgICAgIC8vIEdvIHRvIGh0bWwgYW5kIGJhY2ssIHRoZW4gcGVlbCBvZmYgZXh0cmEgd3JhcHBlcnNcbiAgICAgICAgLy8gTm90ZSB0aGF0IHdlIGFsd2F5cyBwcmVmaXggd2l0aCBzb21lIGR1bW15IHRleHQsIGJlY2F1c2Ugb3RoZXJ3aXNlLCBJRTw5IHdpbGwgc3RyaXAgb3V0IGxlYWRpbmcgY29tbWVudCBub2RlcyBpbiBkZXNjZW5kYW50cy4gVG90YWwgbWFkbmVzcy5cbiAgICAgICAgdmFyIG1hcmt1cCA9IFwiaWdub3JlZDxkaXY+XCIgKyB3cmFwWzFdICsgaHRtbCArIHdyYXBbMl0gKyBcIjwvZGl2PlwiO1xuICAgICAgICBpZiAodHlwZW9mIHdpbmRvd0NvbnRleHRbJ2lubmVyU2hpdiddID09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgLy8gTm90ZSB0aGF0IGlubmVyU2hpdiBpcyBkZXByZWNhdGVkIGluIGZhdm91ciBvZiBodG1sNXNoaXYuIFdlIHNob3VsZCBjb25zaWRlciBhZGRpbmdcbiAgICAgICAgICAgIC8vIHN1cHBvcnQgZm9yIGh0bWw1c2hpdiAoZXhjZXB0IGlmIG5vIGV4cGxpY2l0IHN1cHBvcnQgaXMgbmVlZGVkLCBlLmcuLCBpZiBodG1sNXNoaXZcbiAgICAgICAgICAgIC8vIHNvbWVob3cgc2hpbXMgdGhlIG5hdGl2ZSBBUElzIHNvIGl0IGp1c3Qgd29ya3MgYW55d2F5KVxuICAgICAgICAgICAgZGl2LmFwcGVuZENoaWxkKHdpbmRvd0NvbnRleHRbJ2lubmVyU2hpdiddKG1hcmt1cCkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKG1heVJlcXVpcmVDcmVhdGVFbGVtZW50SGFjaykge1xuICAgICAgICAgICAgICAgIC8vIFRoZSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdteS1lbGVtZW50JykgdHJpY2sgdG8gZW5hYmxlIGN1c3RvbSBlbGVtZW50cyBpbiBJRTYtOFxuICAgICAgICAgICAgICAgIC8vIG9ubHkgd29ya3MgaWYgd2UgYXNzaWduIGlubmVySFRNTCBvbiBhbiBlbGVtZW50IGFzc29jaWF0ZWQgd2l0aCB0aGF0IGRvY3VtZW50LlxuICAgICAgICAgICAgICAgIGRvY3VtZW50Q29udGV4dC5hcHBlbmRDaGlsZChkaXYpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBkaXYuaW5uZXJIVE1MID0gbWFya3VwO1xuXG4gICAgICAgICAgICBpZiAobWF5UmVxdWlyZUNyZWF0ZUVsZW1lbnRIYWNrKSB7XG4gICAgICAgICAgICAgICAgZGl2LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZGl2KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIE1vdmUgdG8gdGhlIHJpZ2h0IGRlcHRoXG4gICAgICAgIHdoaWxlIChkZXB0aC0tKVxuICAgICAgICAgICAgZGl2ID0gZGl2Lmxhc3RDaGlsZDtcblxuICAgICAgICByZXR1cm4ga28udXRpbHMubWFrZUFycmF5KGRpdi5sYXN0Q2hpbGQuY2hpbGROb2Rlcyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24galF1ZXJ5SHRtbFBhcnNlKGh0bWwsIGRvY3VtZW50Q29udGV4dCkge1xuICAgICAgICAvLyBqUXVlcnkncyBcInBhcnNlSFRNTFwiIGZ1bmN0aW9uIHdhcyBpbnRyb2R1Y2VkIGluIGpRdWVyeSAxLjguMCBhbmQgaXMgYSBkb2N1bWVudGVkIHB1YmxpYyBBUEkuXG4gICAgICAgIGlmIChqUXVlcnlJbnN0YW5jZVsncGFyc2VIVE1MJ10pIHtcbiAgICAgICAgICAgIHJldHVybiBqUXVlcnlJbnN0YW5jZVsncGFyc2VIVE1MJ10oaHRtbCwgZG9jdW1lbnRDb250ZXh0KSB8fCBbXTsgLy8gRW5zdXJlIHdlIGFsd2F5cyByZXR1cm4gYW4gYXJyYXkgYW5kIG5ldmVyIG51bGxcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIEZvciBqUXVlcnkgPCAxLjguMCwgd2UgZmFsbCBiYWNrIG9uIHRoZSB1bmRvY3VtZW50ZWQgaW50ZXJuYWwgXCJjbGVhblwiIGZ1bmN0aW9uLlxuICAgICAgICAgICAgdmFyIGVsZW1zID0galF1ZXJ5SW5zdGFuY2VbJ2NsZWFuJ10oW2h0bWxdLCBkb2N1bWVudENvbnRleHQpO1xuXG4gICAgICAgICAgICAvLyBBcyBvZiBqUXVlcnkgMS43LjEsIGpRdWVyeSBwYXJzZXMgdGhlIEhUTUwgYnkgYXBwZW5kaW5nIGl0IHRvIHNvbWUgZHVtbXkgcGFyZW50IG5vZGVzIGhlbGQgaW4gYW4gaW4tbWVtb3J5IGRvY3VtZW50IGZyYWdtZW50LlxuICAgICAgICAgICAgLy8gVW5mb3J0dW5hdGVseSwgaXQgbmV2ZXIgY2xlYXJzIHRoZSBkdW1teSBwYXJlbnQgbm9kZXMgZnJvbSB0aGUgZG9jdW1lbnQgZnJhZ21lbnQsIHNvIGl0IGxlYWtzIG1lbW9yeSBvdmVyIHRpbWUuXG4gICAgICAgICAgICAvLyBGaXggdGhpcyBieSBmaW5kaW5nIHRoZSB0b3AtbW9zdCBkdW1teSBwYXJlbnQgZWxlbWVudCwgYW5kIGRldGFjaGluZyBpdCBmcm9tIGl0cyBvd25lciBmcmFnbWVudC5cbiAgICAgICAgICAgIGlmIChlbGVtcyAmJiBlbGVtc1swXSkge1xuICAgICAgICAgICAgICAgIC8vIEZpbmQgdGhlIHRvcC1tb3N0IHBhcmVudCBlbGVtZW50IHRoYXQncyBhIGRpcmVjdCBjaGlsZCBvZiBhIGRvY3VtZW50IGZyYWdtZW50XG4gICAgICAgICAgICAgICAgdmFyIGVsZW0gPSBlbGVtc1swXTtcbiAgICAgICAgICAgICAgICB3aGlsZSAoZWxlbS5wYXJlbnROb2RlICYmIGVsZW0ucGFyZW50Tm9kZS5ub2RlVHlwZSAhPT0gMTEgLyogaS5lLiwgRG9jdW1lbnRGcmFnbWVudCAqLylcbiAgICAgICAgICAgICAgICAgICAgZWxlbSA9IGVsZW0ucGFyZW50Tm9kZTtcbiAgICAgICAgICAgICAgICAvLyAuLi4gdGhlbiBkZXRhY2ggaXRcbiAgICAgICAgICAgICAgICBpZiAoZWxlbS5wYXJlbnROb2RlKVxuICAgICAgICAgICAgICAgICAgICBlbGVtLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZWxlbSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBlbGVtcztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGtvLnV0aWxzLnBhcnNlSHRtbEZyYWdtZW50ID0gZnVuY3Rpb24oaHRtbCwgZG9jdW1lbnRDb250ZXh0KSB7XG4gICAgICAgIHJldHVybiBqUXVlcnlJbnN0YW5jZSA/XG4gICAgICAgICAgICBqUXVlcnlIdG1sUGFyc2UoaHRtbCwgZG9jdW1lbnRDb250ZXh0KSA6ICAgLy8gQXMgYmVsb3csIGJlbmVmaXQgZnJvbSBqUXVlcnkncyBvcHRpbWlzYXRpb25zIHdoZXJlIHBvc3NpYmxlXG4gICAgICAgICAgICBzaW1wbGVIdG1sUGFyc2UoaHRtbCwgZG9jdW1lbnRDb250ZXh0KTsgIC8vIC4uLiBvdGhlcndpc2UsIHRoaXMgc2ltcGxlIGxvZ2ljIHdpbGwgZG8gaW4gbW9zdCBjb21tb24gY2FzZXMuXG4gICAgfTtcblxuICAgIGtvLnV0aWxzLnNldEh0bWwgPSBmdW5jdGlvbihub2RlLCBodG1sKSB7XG4gICAgICAgIGtvLnV0aWxzLmVtcHR5RG9tTm9kZShub2RlKTtcblxuICAgICAgICAvLyBUaGVyZSdzIG5vIGxlZ2l0aW1hdGUgcmVhc29uIHRvIGRpc3BsYXkgYSBzdHJpbmdpZmllZCBvYnNlcnZhYmxlIHdpdGhvdXQgdW53cmFwcGluZyBpdCwgc28gd2UnbGwgdW53cmFwIGl0XG4gICAgICAgIGh0bWwgPSBrby51dGlscy51bndyYXBPYnNlcnZhYmxlKGh0bWwpO1xuXG4gICAgICAgIGlmICgoaHRtbCAhPT0gbnVsbCkgJiYgKGh0bWwgIT09IHVuZGVmaW5lZCkpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgaHRtbCAhPSAnc3RyaW5nJylcbiAgICAgICAgICAgICAgICBodG1sID0gaHRtbC50b1N0cmluZygpO1xuXG4gICAgICAgICAgICAvLyBqUXVlcnkgY29udGFpbnMgYSBsb3Qgb2Ygc29waGlzdGljYXRlZCBjb2RlIHRvIHBhcnNlIGFyYml0cmFyeSBIVE1MIGZyYWdtZW50cyxcbiAgICAgICAgICAgIC8vIGZvciBleGFtcGxlIDx0cj4gZWxlbWVudHMgd2hpY2ggYXJlIG5vdCBub3JtYWxseSBhbGxvd2VkIHRvIGV4aXN0IG9uIHRoZWlyIG93bi5cbiAgICAgICAgICAgIC8vIElmIHlvdSd2ZSByZWZlcmVuY2VkIGpRdWVyeSB3ZSdsbCB1c2UgdGhhdCByYXRoZXIgdGhhbiBkdXBsaWNhdGluZyBpdHMgY29kZS5cbiAgICAgICAgICAgIGlmIChqUXVlcnlJbnN0YW5jZSkge1xuICAgICAgICAgICAgICAgIGpRdWVyeUluc3RhbmNlKG5vZGUpWydodG1sJ10oaHRtbCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIC4uLiBvdGhlcndpc2UsIHVzZSBLTydzIG93biBwYXJzaW5nIGxvZ2ljLlxuICAgICAgICAgICAgICAgIHZhciBwYXJzZWROb2RlcyA9IGtvLnV0aWxzLnBhcnNlSHRtbEZyYWdtZW50KGh0bWwsIG5vZGUub3duZXJEb2N1bWVudCk7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXJzZWROb2Rlcy5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5hcHBlbmRDaGlsZChwYXJzZWROb2Rlc1tpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xufSkoKTtcblxua28uZXhwb3J0U3ltYm9sKCd1dGlscy5wYXJzZUh0bWxGcmFnbWVudCcsIGtvLnV0aWxzLnBhcnNlSHRtbEZyYWdtZW50KTtcbmtvLmV4cG9ydFN5bWJvbCgndXRpbHMuc2V0SHRtbCcsIGtvLnV0aWxzLnNldEh0bWwpO1xuXG5rby5tZW1vaXphdGlvbiA9IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG1lbW9zID0ge307XG5cbiAgICBmdW5jdGlvbiByYW5kb21NYXg4SGV4Q2hhcnMoKSB7XG4gICAgICAgIHJldHVybiAoKCgxICsgTWF0aC5yYW5kb20oKSkgKiAweDEwMDAwMDAwMCkgfCAwKS50b1N0cmluZygxNikuc3Vic3RyaW5nKDEpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBnZW5lcmF0ZVJhbmRvbUlkKCkge1xuICAgICAgICByZXR1cm4gcmFuZG9tTWF4OEhleENoYXJzKCkgKyByYW5kb21NYXg4SGV4Q2hhcnMoKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZmluZE1lbW9Ob2Rlcyhyb290Tm9kZSwgYXBwZW5kVG9BcnJheSkge1xuICAgICAgICBpZiAoIXJvb3ROb2RlKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBpZiAocm9vdE5vZGUubm9kZVR5cGUgPT0gOCkge1xuICAgICAgICAgICAgdmFyIG1lbW9JZCA9IGtvLm1lbW9pemF0aW9uLnBhcnNlTWVtb1RleHQocm9vdE5vZGUubm9kZVZhbHVlKTtcbiAgICAgICAgICAgIGlmIChtZW1vSWQgIT0gbnVsbClcbiAgICAgICAgICAgICAgICBhcHBlbmRUb0FycmF5LnB1c2goeyBkb21Ob2RlOiByb290Tm9kZSwgbWVtb0lkOiBtZW1vSWQgfSk7XG4gICAgICAgIH0gZWxzZSBpZiAocm9vdE5vZGUubm9kZVR5cGUgPT0gMSkge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGNoaWxkTm9kZXMgPSByb290Tm9kZS5jaGlsZE5vZGVzLCBqID0gY2hpbGROb2Rlcy5sZW5ndGg7IGkgPCBqOyBpKyspXG4gICAgICAgICAgICAgICAgZmluZE1lbW9Ob2RlcyhjaGlsZE5vZGVzW2ldLCBhcHBlbmRUb0FycmF5KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICAgIG1lbW9pemU6IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayAhPSBcImZ1bmN0aW9uXCIpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiWW91IGNhbiBvbmx5IHBhc3MgYSBmdW5jdGlvbiB0byBrby5tZW1vaXphdGlvbi5tZW1vaXplKClcIik7XG4gICAgICAgICAgICB2YXIgbWVtb0lkID0gZ2VuZXJhdGVSYW5kb21JZCgpO1xuICAgICAgICAgICAgbWVtb3NbbWVtb0lkXSA9IGNhbGxiYWNrO1xuICAgICAgICAgICAgcmV0dXJuIFwiPCEtLVtrb19tZW1vOlwiICsgbWVtb0lkICsgXCJdLS0+XCI7XG4gICAgICAgIH0sXG5cbiAgICAgICAgdW5tZW1vaXplOiBmdW5jdGlvbiAobWVtb0lkLCBjYWxsYmFja1BhcmFtcykge1xuICAgICAgICAgICAgdmFyIGNhbGxiYWNrID0gbWVtb3NbbWVtb0lkXTtcbiAgICAgICAgICAgIGlmIChjYWxsYmFjayA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvdWxkbid0IGZpbmQgYW55IG1lbW8gd2l0aCBJRCBcIiArIG1lbW9JZCArIFwiLiBQZXJoYXBzIGl0J3MgYWxyZWFkeSBiZWVuIHVubWVtb2l6ZWQuXCIpO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjay5hcHBseShudWxsLCBjYWxsYmFja1BhcmFtcyB8fCBbXSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmaW5hbGx5IHsgZGVsZXRlIG1lbW9zW21lbW9JZF07IH1cbiAgICAgICAgfSxcblxuICAgICAgICB1bm1lbW9pemVEb21Ob2RlQW5kRGVzY2VuZGFudHM6IGZ1bmN0aW9uIChkb21Ob2RlLCBleHRyYUNhbGxiYWNrUGFyYW1zQXJyYXkpIHtcbiAgICAgICAgICAgIHZhciBtZW1vcyA9IFtdO1xuICAgICAgICAgICAgZmluZE1lbW9Ob2Rlcyhkb21Ob2RlLCBtZW1vcyk7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgaiA9IG1lbW9zLmxlbmd0aDsgaSA8IGo7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBub2RlID0gbWVtb3NbaV0uZG9tTm9kZTtcbiAgICAgICAgICAgICAgICB2YXIgY29tYmluZWRQYXJhbXMgPSBbbm9kZV07XG4gICAgICAgICAgICAgICAgaWYgKGV4dHJhQ2FsbGJhY2tQYXJhbXNBcnJheSlcbiAgICAgICAgICAgICAgICAgICAga28udXRpbHMuYXJyYXlQdXNoQWxsKGNvbWJpbmVkUGFyYW1zLCBleHRyYUNhbGxiYWNrUGFyYW1zQXJyYXkpO1xuICAgICAgICAgICAgICAgIGtvLm1lbW9pemF0aW9uLnVubWVtb2l6ZShtZW1vc1tpXS5tZW1vSWQsIGNvbWJpbmVkUGFyYW1zKTtcbiAgICAgICAgICAgICAgICBub2RlLm5vZGVWYWx1ZSA9IFwiXCI7IC8vIE5ldXRlciB0aGlzIG5vZGUgc28gd2UgZG9uJ3QgdHJ5IHRvIHVubWVtb2l6ZSBpdCBhZ2FpblxuICAgICAgICAgICAgICAgIGlmIChub2RlLnBhcmVudE5vZGUpXG4gICAgICAgICAgICAgICAgICAgIG5vZGUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChub2RlKTsgLy8gSWYgcG9zc2libGUsIGVyYXNlIGl0IHRvdGFsbHkgKG5vdCBhbHdheXMgcG9zc2libGUgLSBzb21lb25lIGVsc2UgbWlnaHQganVzdCBob2xkIGEgcmVmZXJlbmNlIHRvIGl0IHRoZW4gY2FsbCB1bm1lbW9pemVEb21Ob2RlQW5kRGVzY2VuZGFudHMgYWdhaW4pXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgcGFyc2VNZW1vVGV4dDogZnVuY3Rpb24gKG1lbW9UZXh0KSB7XG4gICAgICAgICAgICB2YXIgbWF0Y2ggPSBtZW1vVGV4dC5tYXRjaCgvXlxcW2tvX21lbW9cXDooLio/KVxcXSQvKTtcbiAgICAgICAgICAgIHJldHVybiBtYXRjaCA/IG1hdGNoWzFdIDogbnVsbDtcbiAgICAgICAgfVxuICAgIH07XG59KSgpO1xuXG5rby5leHBvcnRTeW1ib2woJ21lbW9pemF0aW9uJywga28ubWVtb2l6YXRpb24pO1xua28uZXhwb3J0U3ltYm9sKCdtZW1vaXphdGlvbi5tZW1vaXplJywga28ubWVtb2l6YXRpb24ubWVtb2l6ZSk7XG5rby5leHBvcnRTeW1ib2woJ21lbW9pemF0aW9uLnVubWVtb2l6ZScsIGtvLm1lbW9pemF0aW9uLnVubWVtb2l6ZSk7XG5rby5leHBvcnRTeW1ib2woJ21lbW9pemF0aW9uLnBhcnNlTWVtb1RleHQnLCBrby5tZW1vaXphdGlvbi5wYXJzZU1lbW9UZXh0KTtcbmtvLmV4cG9ydFN5bWJvbCgnbWVtb2l6YXRpb24udW5tZW1vaXplRG9tTm9kZUFuZERlc2NlbmRhbnRzJywga28ubWVtb2l6YXRpb24udW5tZW1vaXplRG9tTm9kZUFuZERlc2NlbmRhbnRzKTtcbmtvLnRhc2tzID0gKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgc2NoZWR1bGVyLFxuICAgICAgICB0YXNrUXVldWUgPSBbXSxcbiAgICAgICAgdGFza1F1ZXVlTGVuZ3RoID0gMCxcbiAgICAgICAgbmV4dEhhbmRsZSA9IDEsXG4gICAgICAgIG5leHRJbmRleFRvUHJvY2VzcyA9IDA7XG5cbiAgICBpZiAod2luZG93WydNdXRhdGlvbk9ic2VydmVyJ10pIHtcbiAgICAgICAgLy8gQ2hyb21lIDI3KywgRmlyZWZveCAxNCssIElFIDExKywgT3BlcmEgMTUrLCBTYWZhcmkgNi4xK1xuICAgICAgICAvLyBGcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9wZXRrYWFudG9ub3YvYmx1ZWJpcmQgKiBDb3B5cmlnaHQgKGMpIDIwMTQgUGV0a2EgQW50b25vdiAqIExpY2Vuc2U6IE1JVFxuICAgICAgICBzY2hlZHVsZXIgPSAoZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICB2YXIgZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgICAgIG5ldyBNdXRhdGlvbk9ic2VydmVyKGNhbGxiYWNrKS5vYnNlcnZlKGRpdiwge2F0dHJpYnV0ZXM6IHRydWV9KTtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7IGRpdi5jbGFzc0xpc3QudG9nZ2xlKFwiZm9vXCIpOyB9O1xuICAgICAgICB9KShzY2hlZHVsZWRQcm9jZXNzKTtcbiAgICB9IGVsc2UgaWYgKGRvY3VtZW50ICYmIFwib25yZWFkeXN0YXRlY2hhbmdlXCIgaW4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNjcmlwdFwiKSkge1xuICAgICAgICAvLyBJRSA2LTEwXG4gICAgICAgIC8vIEZyb20gaHR0cHM6Ly9naXRodWIuY29tL1l1enVKUy9zZXRJbW1lZGlhdGUgKiBDb3B5cmlnaHQgKGMpIDIwMTIgQmFybmVzYW5kbm9ibGUuY29tLCBsbGMsIERvbmF2b24gV2VzdCwgYW5kIERvbWVuaWMgRGVuaWNvbGEgKiBMaWNlbnNlOiBNSVRcbiAgICAgICAgc2NoZWR1bGVyID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICB2YXIgc2NyaXB0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNjcmlwdFwiKTtcbiAgICAgICAgICAgIHNjcmlwdC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgc2NyaXB0Lm9ucmVhZHlzdGF0ZWNoYW5nZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnJlbW92ZUNoaWxkKHNjcmlwdCk7XG4gICAgICAgICAgICAgICAgc2NyaXB0ID0gbnVsbDtcbiAgICAgICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5hcHBlbmRDaGlsZChzY3JpcHQpO1xuICAgICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHNjaGVkdWxlciA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgICAgICAgICAgc2V0VGltZW91dChjYWxsYmFjaywgMCk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcHJvY2Vzc1Rhc2tzKCkge1xuICAgICAgICBpZiAodGFza1F1ZXVlTGVuZ3RoKSB7XG4gICAgICAgICAgICAvLyBFYWNoIG1hcmsgcmVwcmVzZW50cyB0aGUgZW5kIG9mIGEgbG9naWNhbCBncm91cCBvZiB0YXNrcyBhbmQgdGhlIG51bWJlciBvZiB0aGVzZSBncm91cHMgaXNcbiAgICAgICAgICAgIC8vIGxpbWl0ZWQgdG8gcHJldmVudCB1bmNoZWNrZWQgcmVjdXJzaW9uLlxuICAgICAgICAgICAgdmFyIG1hcmsgPSB0YXNrUXVldWVMZW5ndGgsIGNvdW50TWFya3MgPSAwO1xuXG4gICAgICAgICAgICAvLyBuZXh0SW5kZXhUb1Byb2Nlc3Mga2VlcHMgdHJhY2sgb2Ygd2hlcmUgd2UgYXJlIGluIHRoZSBxdWV1ZTsgcHJvY2Vzc1Rhc2tzIGNhbiBiZSBjYWxsZWQgcmVjdXJzaXZlbHkgd2l0aG91dCBpc3N1ZVxuICAgICAgICAgICAgZm9yICh2YXIgdGFzazsgbmV4dEluZGV4VG9Qcm9jZXNzIDwgdGFza1F1ZXVlTGVuZ3RoOyApIHtcbiAgICAgICAgICAgICAgICBpZiAodGFzayA9IHRhc2tRdWV1ZVtuZXh0SW5kZXhUb1Byb2Nlc3MrK10pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5leHRJbmRleFRvUHJvY2VzcyA+IG1hcmspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgrK2NvdW50TWFya3MgPj0gNTAwMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5leHRJbmRleFRvUHJvY2VzcyA9IHRhc2tRdWV1ZUxlbmd0aDsgICAvLyBza2lwIGFsbCB0YXNrcyByZW1haW5pbmcgaW4gdGhlIHF1ZXVlIHNpbmNlIGFueSBvZiB0aGVtIGNvdWxkIGJlIGNhdXNpbmcgdGhlIHJlY3Vyc2lvblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtvLnV0aWxzLmRlZmVyRXJyb3IoRXJyb3IoXCInVG9vIG11Y2ggcmVjdXJzaW9uJyBhZnRlciBwcm9jZXNzaW5nIFwiICsgY291bnRNYXJrcyArIFwiIHRhc2sgZ3JvdXBzLlwiKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXJrID0gdGFza1F1ZXVlTGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0YXNrKCk7XG4gICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBrby51dGlscy5kZWZlckVycm9yKGV4KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNjaGVkdWxlZFByb2Nlc3MoKSB7XG4gICAgICAgIHByb2Nlc3NUYXNrcygpO1xuXG4gICAgICAgIC8vIFJlc2V0IHRoZSBxdWV1ZVxuICAgICAgICBuZXh0SW5kZXhUb1Byb2Nlc3MgPSB0YXNrUXVldWVMZW5ndGggPSB0YXNrUXVldWUubGVuZ3RoID0gMDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzY2hlZHVsZVRhc2tQcm9jZXNzaW5nKCkge1xuICAgICAgICBrby50YXNrc1snc2NoZWR1bGVyJ10oc2NoZWR1bGVkUHJvY2Vzcyk7XG4gICAgfVxuXG4gICAgdmFyIHRhc2tzID0ge1xuICAgICAgICAnc2NoZWR1bGVyJzogc2NoZWR1bGVyLCAgICAgLy8gQWxsb3cgb3ZlcnJpZGluZyB0aGUgc2NoZWR1bGVyXG5cbiAgICAgICAgc2NoZWR1bGU6IGZ1bmN0aW9uIChmdW5jKSB7XG4gICAgICAgICAgICBpZiAoIXRhc2tRdWV1ZUxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHNjaGVkdWxlVGFza1Byb2Nlc3NpbmcoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGFza1F1ZXVlW3Rhc2tRdWV1ZUxlbmd0aCsrXSA9IGZ1bmM7XG4gICAgICAgICAgICByZXR1cm4gbmV4dEhhbmRsZSsrO1xuICAgICAgICB9LFxuXG4gICAgICAgIGNhbmNlbDogZnVuY3Rpb24gKGhhbmRsZSkge1xuICAgICAgICAgICAgdmFyIGluZGV4ID0gaGFuZGxlIC0gKG5leHRIYW5kbGUgLSB0YXNrUXVldWVMZW5ndGgpO1xuICAgICAgICAgICAgaWYgKGluZGV4ID49IG5leHRJbmRleFRvUHJvY2VzcyAmJiBpbmRleCA8IHRhc2tRdWV1ZUxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHRhc2tRdWV1ZVtpbmRleF0gPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8vIEZvciB0ZXN0aW5nIG9ubHk6IHJlc2V0IHRoZSBxdWV1ZSBhbmQgcmV0dXJuIHRoZSBwcmV2aW91cyBxdWV1ZSBsZW5ndGhcbiAgICAgICAgJ3Jlc2V0Rm9yVGVzdGluZyc6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBsZW5ndGggPSB0YXNrUXVldWVMZW5ndGggLSBuZXh0SW5kZXhUb1Byb2Nlc3M7XG4gICAgICAgICAgICBuZXh0SW5kZXhUb1Byb2Nlc3MgPSB0YXNrUXVldWVMZW5ndGggPSB0YXNrUXVldWUubGVuZ3RoID0gMDtcbiAgICAgICAgICAgIHJldHVybiBsZW5ndGg7XG4gICAgICAgIH0sXG5cbiAgICAgICAgcnVuRWFybHk6IHByb2Nlc3NUYXNrc1xuICAgIH07XG5cbiAgICByZXR1cm4gdGFza3M7XG59KSgpO1xuXG5rby5leHBvcnRTeW1ib2woJ3Rhc2tzJywga28udGFza3MpO1xua28uZXhwb3J0U3ltYm9sKCd0YXNrcy5zY2hlZHVsZScsIGtvLnRhc2tzLnNjaGVkdWxlKTtcbi8va28uZXhwb3J0U3ltYm9sKCd0YXNrcy5jYW5jZWwnLCBrby50YXNrcy5jYW5jZWwpOyAgXCJjYW5jZWxcIiBpc24ndCBtaW5pZmllZFxua28uZXhwb3J0U3ltYm9sKCd0YXNrcy5ydW5FYXJseScsIGtvLnRhc2tzLnJ1bkVhcmx5KTtcbmtvLmV4dGVuZGVycyA9IHtcbiAgICAndGhyb3R0bGUnOiBmdW5jdGlvbih0YXJnZXQsIHRpbWVvdXQpIHtcbiAgICAgICAgLy8gVGhyb3R0bGluZyBtZWFucyB0d28gdGhpbmdzOlxuXG4gICAgICAgIC8vICgxKSBGb3IgZGVwZW5kZW50IG9ic2VydmFibGVzLCB3ZSB0aHJvdHRsZSAqZXZhbHVhdGlvbnMqIHNvIHRoYXQsIG5vIG1hdHRlciBob3cgZmFzdCBpdHMgZGVwZW5kZW5jaWVzXG4gICAgICAgIC8vICAgICBub3RpZnkgdXBkYXRlcywgdGhlIHRhcmdldCBkb2Vzbid0IHJlLWV2YWx1YXRlIChhbmQgaGVuY2UgZG9lc24ndCBub3RpZnkpIGZhc3RlciB0aGFuIGEgY2VydGFpbiByYXRlXG4gICAgICAgIHRhcmdldFsndGhyb3R0bGVFdmFsdWF0aW9uJ10gPSB0aW1lb3V0O1xuXG4gICAgICAgIC8vICgyKSBGb3Igd3JpdGFibGUgdGFyZ2V0cyAob2JzZXJ2YWJsZXMsIG9yIHdyaXRhYmxlIGRlcGVuZGVudCBvYnNlcnZhYmxlcyksIHdlIHRocm90dGxlICp3cml0ZXMqXG4gICAgICAgIC8vICAgICBzbyB0aGUgdGFyZ2V0IGNhbm5vdCBjaGFuZ2UgdmFsdWUgc3luY2hyb25vdXNseSBvciBmYXN0ZXIgdGhhbiBhIGNlcnRhaW4gcmF0ZVxuICAgICAgICB2YXIgd3JpdGVUaW1lb3V0SW5zdGFuY2UgPSBudWxsO1xuICAgICAgICByZXR1cm4ga28uZGVwZW5kZW50T2JzZXJ2YWJsZSh7XG4gICAgICAgICAgICAncmVhZCc6IHRhcmdldCxcbiAgICAgICAgICAgICd3cml0ZSc6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHdyaXRlVGltZW91dEluc3RhbmNlKTtcbiAgICAgICAgICAgICAgICB3cml0ZVRpbWVvdXRJbnN0YW5jZSA9IGtvLnV0aWxzLnNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHRhcmdldCh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfSwgdGltZW91dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAncmF0ZUxpbWl0JzogZnVuY3Rpb24odGFyZ2V0LCBvcHRpb25zKSB7XG4gICAgICAgIHZhciB0aW1lb3V0LCBtZXRob2QsIGxpbWl0RnVuY3Rpb247XG5cbiAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zID09ICdudW1iZXInKSB7XG4gICAgICAgICAgICB0aW1lb3V0ID0gb3B0aW9ucztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRpbWVvdXQgPSBvcHRpb25zWyd0aW1lb3V0J107XG4gICAgICAgICAgICBtZXRob2QgPSBvcHRpb25zWydtZXRob2QnXTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHJhdGVMaW1pdCBzdXBlcnNlZGVzIGRlZmVycmVkIHVwZGF0ZXNcbiAgICAgICAgdGFyZ2V0Ll9kZWZlclVwZGF0ZXMgPSBmYWxzZTtcblxuICAgICAgICBsaW1pdEZ1bmN0aW9uID0gbWV0aG9kID09ICdub3RpZnlXaGVuQ2hhbmdlc1N0b3AnID8gIGRlYm91bmNlIDogdGhyb3R0bGU7XG4gICAgICAgIHRhcmdldC5saW1pdChmdW5jdGlvbihjYWxsYmFjaykge1xuICAgICAgICAgICAgcmV0dXJuIGxpbWl0RnVuY3Rpb24oY2FsbGJhY2ssIHRpbWVvdXQpO1xuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgJ2RlZmVycmVkJzogZnVuY3Rpb24odGFyZ2V0LCBvcHRpb25zKSB7XG4gICAgICAgIGlmIChvcHRpb25zICE9PSB0cnVlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBcXCdkZWZlcnJlZFxcJyBleHRlbmRlciBvbmx5IGFjY2VwdHMgdGhlIHZhbHVlIFxcJ3RydWVcXCcsIGJlY2F1c2UgaXQgaXMgbm90IHN1cHBvcnRlZCB0byB0dXJuIGRlZmVycmFsIG9mZiBvbmNlIGVuYWJsZWQuJylcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdGFyZ2V0Ll9kZWZlclVwZGF0ZXMpIHtcbiAgICAgICAgICAgIHRhcmdldC5fZGVmZXJVcGRhdGVzID0gdHJ1ZTtcbiAgICAgICAgICAgIHRhcmdldC5saW1pdChmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICB2YXIgaGFuZGxlO1xuICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIGtvLnRhc2tzLmNhbmNlbChoYW5kbGUpO1xuICAgICAgICAgICAgICAgICAgICBoYW5kbGUgPSBrby50YXNrcy5zY2hlZHVsZShjYWxsYmFjayk7XG4gICAgICAgICAgICAgICAgICAgIHRhcmdldFsnbm90aWZ5U3Vic2NyaWJlcnMnXSh1bmRlZmluZWQsICdkaXJ0eScpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAnbm90aWZ5JzogZnVuY3Rpb24odGFyZ2V0LCBub3RpZnlXaGVuKSB7XG4gICAgICAgIHRhcmdldFtcImVxdWFsaXR5Q29tcGFyZXJcIl0gPSBub3RpZnlXaGVuID09IFwiYWx3YXlzXCIgP1xuICAgICAgICAgICAgbnVsbCA6ICAvLyBudWxsIGVxdWFsaXR5Q29tcGFyZXIgbWVhbnMgdG8gYWx3YXlzIG5vdGlmeVxuICAgICAgICAgICAgdmFsdWVzQXJlUHJpbWl0aXZlQW5kRXF1YWw7XG4gICAgfVxufTtcblxudmFyIHByaW1pdGl2ZVR5cGVzID0geyAndW5kZWZpbmVkJzoxLCAnYm9vbGVhbic6MSwgJ251bWJlcic6MSwgJ3N0cmluZyc6MSB9O1xuZnVuY3Rpb24gdmFsdWVzQXJlUHJpbWl0aXZlQW5kRXF1YWwoYSwgYikge1xuICAgIHZhciBvbGRWYWx1ZUlzUHJpbWl0aXZlID0gKGEgPT09IG51bGwpIHx8ICh0eXBlb2YoYSkgaW4gcHJpbWl0aXZlVHlwZXMpO1xuICAgIHJldHVybiBvbGRWYWx1ZUlzUHJpbWl0aXZlID8gKGEgPT09IGIpIDogZmFsc2U7XG59XG5cbmZ1bmN0aW9uIHRocm90dGxlKGNhbGxiYWNrLCB0aW1lb3V0KSB7XG4gICAgdmFyIHRpbWVvdXRJbnN0YW5jZTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIXRpbWVvdXRJbnN0YW5jZSkge1xuICAgICAgICAgICAgdGltZW91dEluc3RhbmNlID0ga28udXRpbHMuc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdGltZW91dEluc3RhbmNlID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgICB9LCB0aW1lb3V0KTtcbiAgICAgICAgfVxuICAgIH07XG59XG5cbmZ1bmN0aW9uIGRlYm91bmNlKGNhbGxiYWNrLCB0aW1lb3V0KSB7XG4gICAgdmFyIHRpbWVvdXRJbnN0YW5jZTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dEluc3RhbmNlKTtcbiAgICAgICAgdGltZW91dEluc3RhbmNlID0ga28udXRpbHMuc2V0VGltZW91dChjYWxsYmFjaywgdGltZW91dCk7XG4gICAgfTtcbn1cblxuZnVuY3Rpb24gYXBwbHlFeHRlbmRlcnMocmVxdWVzdGVkRXh0ZW5kZXJzKSB7XG4gICAgdmFyIHRhcmdldCA9IHRoaXM7XG4gICAgaWYgKHJlcXVlc3RlZEV4dGVuZGVycykge1xuICAgICAgICBrby51dGlscy5vYmplY3RGb3JFYWNoKHJlcXVlc3RlZEV4dGVuZGVycywgZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1xuICAgICAgICAgICAgdmFyIGV4dGVuZGVySGFuZGxlciA9IGtvLmV4dGVuZGVyc1trZXldO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBleHRlbmRlckhhbmRsZXIgPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIHRhcmdldCA9IGV4dGVuZGVySGFuZGxlcih0YXJnZXQsIHZhbHVlKSB8fCB0YXJnZXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gdGFyZ2V0O1xufVxuXG5rby5leHBvcnRTeW1ib2woJ2V4dGVuZGVycycsIGtvLmV4dGVuZGVycyk7XG5cbmtvLnN1YnNjcmlwdGlvbiA9IGZ1bmN0aW9uICh0YXJnZXQsIGNhbGxiYWNrLCBkaXNwb3NlQ2FsbGJhY2spIHtcbiAgICB0aGlzLl90YXJnZXQgPSB0YXJnZXQ7XG4gICAgdGhpcy5jYWxsYmFjayA9IGNhbGxiYWNrO1xuICAgIHRoaXMuZGlzcG9zZUNhbGxiYWNrID0gZGlzcG9zZUNhbGxiYWNrO1xuICAgIHRoaXMuaXNEaXNwb3NlZCA9IGZhbHNlO1xuICAgIGtvLmV4cG9ydFByb3BlcnR5KHRoaXMsICdkaXNwb3NlJywgdGhpcy5kaXNwb3NlKTtcbn07XG5rby5zdWJzY3JpcHRpb24ucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5pc0Rpc3Bvc2VkID0gdHJ1ZTtcbiAgICB0aGlzLmRpc3Bvc2VDYWxsYmFjaygpO1xufTtcblxua28uc3Vic2NyaWJhYmxlID0gZnVuY3Rpb24gKCkge1xuICAgIGtvLnV0aWxzLnNldFByb3RvdHlwZU9mT3JFeHRlbmQodGhpcywga29fc3Vic2NyaWJhYmxlX2ZuKTtcbiAgICBrb19zdWJzY3JpYmFibGVfZm4uaW5pdCh0aGlzKTtcbn1cblxudmFyIGRlZmF1bHRFdmVudCA9IFwiY2hhbmdlXCI7XG5cbi8vIE1vdmVkIG91dCBvZiBcImxpbWl0XCIgdG8gYXZvaWQgdGhlIGV4dHJhIGNsb3N1cmVcbmZ1bmN0aW9uIGxpbWl0Tm90aWZ5U3Vic2NyaWJlcnModmFsdWUsIGV2ZW50KSB7XG4gICAgaWYgKCFldmVudCB8fCBldmVudCA9PT0gZGVmYXVsdEV2ZW50KSB7XG4gICAgICAgIHRoaXMuX2xpbWl0Q2hhbmdlKHZhbHVlKTtcbiAgICB9IGVsc2UgaWYgKGV2ZW50ID09PSAnYmVmb3JlQ2hhbmdlJykge1xuICAgICAgICB0aGlzLl9saW1pdEJlZm9yZUNoYW5nZSh2YWx1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fb3JpZ05vdGlmeVN1YnNjcmliZXJzKHZhbHVlLCBldmVudCk7XG4gICAgfVxufVxuXG52YXIga29fc3Vic2NyaWJhYmxlX2ZuID0ge1xuICAgIGluaXQ6IGZ1bmN0aW9uKGluc3RhbmNlKSB7XG4gICAgICAgIGluc3RhbmNlLl9zdWJzY3JpcHRpb25zID0ge307XG4gICAgICAgIGluc3RhbmNlLl92ZXJzaW9uTnVtYmVyID0gMTtcbiAgICB9LFxuXG4gICAgc3Vic2NyaWJlOiBmdW5jdGlvbiAoY2FsbGJhY2ssIGNhbGxiYWNrVGFyZ2V0LCBldmVudCkge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAgICAgZXZlbnQgPSBldmVudCB8fCBkZWZhdWx0RXZlbnQ7XG4gICAgICAgIHZhciBib3VuZENhbGxiYWNrID0gY2FsbGJhY2tUYXJnZXQgPyBjYWxsYmFjay5iaW5kKGNhbGxiYWNrVGFyZ2V0KSA6IGNhbGxiYWNrO1xuXG4gICAgICAgIHZhciBzdWJzY3JpcHRpb24gPSBuZXcga28uc3Vic2NyaXB0aW9uKHNlbGYsIGJvdW5kQ2FsbGJhY2ssIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGtvLnV0aWxzLmFycmF5UmVtb3ZlSXRlbShzZWxmLl9zdWJzY3JpcHRpb25zW2V2ZW50XSwgc3Vic2NyaXB0aW9uKTtcbiAgICAgICAgICAgIGlmIChzZWxmLmFmdGVyU3Vic2NyaXB0aW9uUmVtb3ZlKVxuICAgICAgICAgICAgICAgIHNlbGYuYWZ0ZXJTdWJzY3JpcHRpb25SZW1vdmUoZXZlbnQpO1xuICAgICAgICB9KTtcblxuICAgICAgICBpZiAoc2VsZi5iZWZvcmVTdWJzY3JpcHRpb25BZGQpXG4gICAgICAgICAgICBzZWxmLmJlZm9yZVN1YnNjcmlwdGlvbkFkZChldmVudCk7XG5cbiAgICAgICAgaWYgKCFzZWxmLl9zdWJzY3JpcHRpb25zW2V2ZW50XSlcbiAgICAgICAgICAgIHNlbGYuX3N1YnNjcmlwdGlvbnNbZXZlbnRdID0gW107XG4gICAgICAgIHNlbGYuX3N1YnNjcmlwdGlvbnNbZXZlbnRdLnB1c2goc3Vic2NyaXB0aW9uKTtcblxuICAgICAgICByZXR1cm4gc3Vic2NyaXB0aW9uO1xuICAgIH0sXG5cbiAgICBcIm5vdGlmeVN1YnNjcmliZXJzXCI6IGZ1bmN0aW9uICh2YWx1ZVRvTm90aWZ5LCBldmVudCkge1xuICAgICAgICBldmVudCA9IGV2ZW50IHx8IGRlZmF1bHRFdmVudDtcbiAgICAgICAgaWYgKGV2ZW50ID09PSBkZWZhdWx0RXZlbnQpIHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlVmVyc2lvbigpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmhhc1N1YnNjcmlwdGlvbnNGb3JFdmVudChldmVudCkpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAga28uZGVwZW5kZW5jeURldGVjdGlvbi5iZWdpbigpOyAvLyBCZWdpbiBzdXBwcmVzc2luZyBkZXBlbmRlbmN5IGRldGVjdGlvbiAoYnkgc2V0dGluZyB0aGUgdG9wIGZyYW1lIHRvIHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBhID0gdGhpcy5fc3Vic2NyaXB0aW9uc1tldmVudF0uc2xpY2UoMCksIGkgPSAwLCBzdWJzY3JpcHRpb247IHN1YnNjcmlwdGlvbiA9IGFbaV07ICsraSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBJbiBjYXNlIGEgc3Vic2NyaXB0aW9uIHdhcyBkaXNwb3NlZCBkdXJpbmcgdGhlIGFycmF5Rm9yRWFjaCBjeWNsZSwgY2hlY2tcbiAgICAgICAgICAgICAgICAgICAgLy8gZm9yIGlzRGlzcG9zZWQgb24gZWFjaCBzdWJzY3JpcHRpb24gYmVmb3JlIGludm9raW5nIGl0cyBjYWxsYmFja1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXN1YnNjcmlwdGlvbi5pc0Rpc3Bvc2VkKVxuICAgICAgICAgICAgICAgICAgICAgICAgc3Vic2NyaXB0aW9uLmNhbGxiYWNrKHZhbHVlVG9Ob3RpZnkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgICAga28uZGVwZW5kZW5jeURldGVjdGlvbi5lbmQoKTsgLy8gRW5kIHN1cHByZXNzaW5nIGRlcGVuZGVuY3kgZGV0ZWN0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgZ2V0VmVyc2lvbjogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdmVyc2lvbk51bWJlcjtcbiAgICB9LFxuXG4gICAgaGFzQ2hhbmdlZDogZnVuY3Rpb24gKHZlcnNpb25Ub0NoZWNrKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldFZlcnNpb24oKSAhPT0gdmVyc2lvblRvQ2hlY2s7XG4gICAgfSxcblxuICAgIHVwZGF0ZVZlcnNpb246IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgKyt0aGlzLl92ZXJzaW9uTnVtYmVyO1xuICAgIH0sXG5cbiAgICBsaW1pdDogZnVuY3Rpb24obGltaXRGdW5jdGlvbikge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXMsIHNlbGZJc09ic2VydmFibGUgPSBrby5pc09ic2VydmFibGUoc2VsZiksXG4gICAgICAgICAgICBpZ25vcmVCZWZvcmVDaGFuZ2UsIHByZXZpb3VzVmFsdWUsIHBlbmRpbmdWYWx1ZSwgYmVmb3JlQ2hhbmdlID0gJ2JlZm9yZUNoYW5nZSc7XG5cbiAgICAgICAgaWYgKCFzZWxmLl9vcmlnTm90aWZ5U3Vic2NyaWJlcnMpIHtcbiAgICAgICAgICAgIHNlbGYuX29yaWdOb3RpZnlTdWJzY3JpYmVycyA9IHNlbGZbXCJub3RpZnlTdWJzY3JpYmVyc1wiXTtcbiAgICAgICAgICAgIHNlbGZbXCJub3RpZnlTdWJzY3JpYmVyc1wiXSA9IGxpbWl0Tm90aWZ5U3Vic2NyaWJlcnM7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZmluaXNoID0gbGltaXRGdW5jdGlvbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHNlbGYuX25vdGlmaWNhdGlvbklzUGVuZGluZyA9IGZhbHNlO1xuXG4gICAgICAgICAgICAvLyBJZiBhbiBvYnNlcnZhYmxlIHByb3ZpZGVkIGEgcmVmZXJlbmNlIHRvIGl0c2VsZiwgYWNjZXNzIGl0IHRvIGdldCB0aGUgbGF0ZXN0IHZhbHVlLlxuICAgICAgICAgICAgLy8gVGhpcyBhbGxvd3MgY29tcHV0ZWQgb2JzZXJ2YWJsZXMgdG8gZGVsYXkgY2FsY3VsYXRpbmcgdGhlaXIgdmFsdWUgdW50aWwgbmVlZGVkLlxuICAgICAgICAgICAgaWYgKHNlbGZJc09ic2VydmFibGUgJiYgcGVuZGluZ1ZhbHVlID09PSBzZWxmKSB7XG4gICAgICAgICAgICAgICAgcGVuZGluZ1ZhbHVlID0gc2VsZigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWdub3JlQmVmb3JlQ2hhbmdlID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAoc2VsZi5pc0RpZmZlcmVudChwcmV2aW91c1ZhbHVlLCBwZW5kaW5nVmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5fb3JpZ05vdGlmeVN1YnNjcmliZXJzKHByZXZpb3VzVmFsdWUgPSBwZW5kaW5nVmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBzZWxmLl9saW1pdENoYW5nZSA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICBzZWxmLl9ub3RpZmljYXRpb25Jc1BlbmRpbmcgPSBpZ25vcmVCZWZvcmVDaGFuZ2UgPSB0cnVlO1xuICAgICAgICAgICAgcGVuZGluZ1ZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgICBmaW5pc2goKTtcbiAgICAgICAgfTtcbiAgICAgICAgc2VsZi5fbGltaXRCZWZvcmVDaGFuZ2UgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKCFpZ25vcmVCZWZvcmVDaGFuZ2UpIHtcbiAgICAgICAgICAgICAgICBwcmV2aW91c1ZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgc2VsZi5fb3JpZ05vdGlmeVN1YnNjcmliZXJzKHZhbHVlLCBiZWZvcmVDaGFuZ2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH0sXG5cbiAgICBoYXNTdWJzY3JpcHRpb25zRm9yRXZlbnQ6IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zdWJzY3JpcHRpb25zW2V2ZW50XSAmJiB0aGlzLl9zdWJzY3JpcHRpb25zW2V2ZW50XS5sZW5ndGg7XG4gICAgfSxcblxuICAgIGdldFN1YnNjcmlwdGlvbnNDb3VudDogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIGlmIChldmVudCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3N1YnNjcmlwdGlvbnNbZXZlbnRdICYmIHRoaXMuX3N1YnNjcmlwdGlvbnNbZXZlbnRdLmxlbmd0aCB8fCAwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIHRvdGFsID0gMDtcbiAgICAgICAgICAgIGtvLnV0aWxzLm9iamVjdEZvckVhY2godGhpcy5fc3Vic2NyaXB0aW9ucywgZnVuY3Rpb24oZXZlbnROYW1lLCBzdWJzY3JpcHRpb25zKSB7XG4gICAgICAgICAgICAgICAgaWYgKGV2ZW50TmFtZSAhPT0gJ2RpcnR5JylcbiAgICAgICAgICAgICAgICAgICAgdG90YWwgKz0gc3Vic2NyaXB0aW9ucy5sZW5ndGg7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiB0b3RhbDtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBpc0RpZmZlcmVudDogZnVuY3Rpb24ob2xkVmFsdWUsIG5ld1ZhbHVlKSB7XG4gICAgICAgIHJldHVybiAhdGhpc1snZXF1YWxpdHlDb21wYXJlciddIHx8ICF0aGlzWydlcXVhbGl0eUNvbXBhcmVyJ10ob2xkVmFsdWUsIG5ld1ZhbHVlKTtcbiAgICB9LFxuXG4gICAgZXh0ZW5kOiBhcHBseUV4dGVuZGVyc1xufTtcblxua28uZXhwb3J0UHJvcGVydHkoa29fc3Vic2NyaWJhYmxlX2ZuLCAnc3Vic2NyaWJlJywga29fc3Vic2NyaWJhYmxlX2ZuLnN1YnNjcmliZSk7XG5rby5leHBvcnRQcm9wZXJ0eShrb19zdWJzY3JpYmFibGVfZm4sICdleHRlbmQnLCBrb19zdWJzY3JpYmFibGVfZm4uZXh0ZW5kKTtcbmtvLmV4cG9ydFByb3BlcnR5KGtvX3N1YnNjcmliYWJsZV9mbiwgJ2dldFN1YnNjcmlwdGlvbnNDb3VudCcsIGtvX3N1YnNjcmliYWJsZV9mbi5nZXRTdWJzY3JpcHRpb25zQ291bnQpO1xuXG4vLyBGb3IgYnJvd3NlcnMgdGhhdCBzdXBwb3J0IHByb3RvIGFzc2lnbm1lbnQsIHdlIG92ZXJ3cml0ZSB0aGUgcHJvdG90eXBlIG9mIGVhY2hcbi8vIG9ic2VydmFibGUgaW5zdGFuY2UuIFNpbmNlIG9ic2VydmFibGVzIGFyZSBmdW5jdGlvbnMsIHdlIG5lZWQgRnVuY3Rpb24ucHJvdG90eXBlXG4vLyB0byBzdGlsbCBiZSBpbiB0aGUgcHJvdG90eXBlIGNoYWluLlxuaWYgKGtvLnV0aWxzLmNhblNldFByb3RvdHlwZSkge1xuICAgIGtvLnV0aWxzLnNldFByb3RvdHlwZU9mKGtvX3N1YnNjcmliYWJsZV9mbiwgRnVuY3Rpb24ucHJvdG90eXBlKTtcbn1cblxua28uc3Vic2NyaWJhYmxlWydmbiddID0ga29fc3Vic2NyaWJhYmxlX2ZuO1xuXG5cbmtvLmlzU3Vic2NyaWJhYmxlID0gZnVuY3Rpb24gKGluc3RhbmNlKSB7XG4gICAgcmV0dXJuIGluc3RhbmNlICE9IG51bGwgJiYgdHlwZW9mIGluc3RhbmNlLnN1YnNjcmliZSA9PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIGluc3RhbmNlW1wibm90aWZ5U3Vic2NyaWJlcnNcIl0gPT0gXCJmdW5jdGlvblwiO1xufTtcblxua28uZXhwb3J0U3ltYm9sKCdzdWJzY3JpYmFibGUnLCBrby5zdWJzY3JpYmFibGUpO1xua28uZXhwb3J0U3ltYm9sKCdpc1N1YnNjcmliYWJsZScsIGtvLmlzU3Vic2NyaWJhYmxlKTtcblxua28uY29tcHV0ZWRDb250ZXh0ID0ga28uZGVwZW5kZW5jeURldGVjdGlvbiA9IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG91dGVyRnJhbWVzID0gW10sXG4gICAgICAgIGN1cnJlbnRGcmFtZSxcbiAgICAgICAgbGFzdElkID0gMDtcblxuICAgIC8vIFJldHVybiBhIHVuaXF1ZSBJRCB0aGF0IGNhbiBiZSBhc3NpZ25lZCB0byBhbiBvYnNlcnZhYmxlIGZvciBkZXBlbmRlbmN5IHRyYWNraW5nLlxuICAgIC8vIFRoZW9yZXRpY2FsbHksIHlvdSBjb3VsZCBldmVudHVhbGx5IG92ZXJmbG93IHRoZSBudW1iZXIgc3RvcmFnZSBzaXplLCByZXN1bHRpbmdcbiAgICAvLyBpbiBkdXBsaWNhdGUgSURzLiBCdXQgaW4gSmF2YVNjcmlwdCwgdGhlIGxhcmdlc3QgZXhhY3QgaW50ZWdyYWwgdmFsdWUgaXMgMl41M1xuICAgIC8vIG9yIDksMDA3LDE5OSwyNTQsNzQwLDk5Mi4gSWYgeW91IGNyZWF0ZWQgMSwwMDAsMDAwIElEcyBwZXIgc2Vjb25kLCBpdCB3b3VsZFxuICAgIC8vIHRha2Ugb3ZlciAyODUgeWVhcnMgdG8gcmVhY2ggdGhhdCBudW1iZXIuXG4gICAgLy8gUmVmZXJlbmNlIGh0dHA6Ly9ibG9nLnZqZXV4LmNvbS8yMDEwL2phdmFzY3JpcHQvamF2YXNjcmlwdC1tYXhfaW50LW51bWJlci1saW1pdHMuaHRtbFxuICAgIGZ1bmN0aW9uIGdldElkKCkge1xuICAgICAgICByZXR1cm4gKytsYXN0SWQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYmVnaW4ob3B0aW9ucykge1xuICAgICAgICBvdXRlckZyYW1lcy5wdXNoKGN1cnJlbnRGcmFtZSk7XG4gICAgICAgIGN1cnJlbnRGcmFtZSA9IG9wdGlvbnM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZW5kKCkge1xuICAgICAgICBjdXJyZW50RnJhbWUgPSBvdXRlckZyYW1lcy5wb3AoKTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgICBiZWdpbjogYmVnaW4sXG5cbiAgICAgICAgZW5kOiBlbmQsXG5cbiAgICAgICAgcmVnaXN0ZXJEZXBlbmRlbmN5OiBmdW5jdGlvbiAoc3Vic2NyaWJhYmxlKSB7XG4gICAgICAgICAgICBpZiAoY3VycmVudEZyYW1lKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFrby5pc1N1YnNjcmliYWJsZShzdWJzY3JpYmFibGUpKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJPbmx5IHN1YnNjcmliYWJsZSB0aGluZ3MgY2FuIGFjdCBhcyBkZXBlbmRlbmNpZXNcIik7XG4gICAgICAgICAgICAgICAgY3VycmVudEZyYW1lLmNhbGxiYWNrLmNhbGwoY3VycmVudEZyYW1lLmNhbGxiYWNrVGFyZ2V0LCBzdWJzY3JpYmFibGUsIHN1YnNjcmliYWJsZS5faWQgfHwgKHN1YnNjcmliYWJsZS5faWQgPSBnZXRJZCgpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgaWdub3JlOiBmdW5jdGlvbiAoY2FsbGJhY2ssIGNhbGxiYWNrVGFyZ2V0LCBjYWxsYmFja0FyZ3MpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgYmVnaW4oKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2suYXBwbHkoY2FsbGJhY2tUYXJnZXQsIGNhbGxiYWNrQXJncyB8fCBbXSk7XG4gICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICAgIGVuZCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIGdldERlcGVuZGVuY2llc0NvdW50OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoY3VycmVudEZyYW1lKVxuICAgICAgICAgICAgICAgIHJldHVybiBjdXJyZW50RnJhbWUuY29tcHV0ZWQuZ2V0RGVwZW5kZW5jaWVzQ291bnQoKTtcbiAgICAgICAgfSxcblxuICAgICAgICBpc0luaXRpYWw6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRGcmFtZSlcbiAgICAgICAgICAgICAgICByZXR1cm4gY3VycmVudEZyYW1lLmlzSW5pdGlhbDtcbiAgICAgICAgfVxuICAgIH07XG59KSgpO1xuXG5rby5leHBvcnRTeW1ib2woJ2NvbXB1dGVkQ29udGV4dCcsIGtvLmNvbXB1dGVkQ29udGV4dCk7XG5rby5leHBvcnRTeW1ib2woJ2NvbXB1dGVkQ29udGV4dC5nZXREZXBlbmRlbmNpZXNDb3VudCcsIGtvLmNvbXB1dGVkQ29udGV4dC5nZXREZXBlbmRlbmNpZXNDb3VudCk7XG5rby5leHBvcnRTeW1ib2woJ2NvbXB1dGVkQ29udGV4dC5pc0luaXRpYWwnLCBrby5jb21wdXRlZENvbnRleHQuaXNJbml0aWFsKTtcblxua28uZXhwb3J0U3ltYm9sKCdpZ25vcmVEZXBlbmRlbmNpZXMnLCBrby5pZ25vcmVEZXBlbmRlbmNpZXMgPSBrby5kZXBlbmRlbmN5RGV0ZWN0aW9uLmlnbm9yZSk7XG52YXIgb2JzZXJ2YWJsZUxhdGVzdFZhbHVlID0ga28udXRpbHMuY3JlYXRlU3ltYm9sT3JTdHJpbmcoJ19sYXRlc3RWYWx1ZScpO1xuXG5rby5vYnNlcnZhYmxlID0gZnVuY3Rpb24gKGluaXRpYWxWYWx1ZSkge1xuICAgIGZ1bmN0aW9uIG9ic2VydmFibGUoKSB7XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgLy8gV3JpdGVcblxuICAgICAgICAgICAgLy8gSWdub3JlIHdyaXRlcyBpZiB0aGUgdmFsdWUgaGFzbid0IGNoYW5nZWRcbiAgICAgICAgICAgIGlmIChvYnNlcnZhYmxlLmlzRGlmZmVyZW50KG9ic2VydmFibGVbb2JzZXJ2YWJsZUxhdGVzdFZhbHVlXSwgYXJndW1lbnRzWzBdKSkge1xuICAgICAgICAgICAgICAgIG9ic2VydmFibGUudmFsdWVXaWxsTXV0YXRlKCk7XG4gICAgICAgICAgICAgICAgb2JzZXJ2YWJsZVtvYnNlcnZhYmxlTGF0ZXN0VmFsdWVdID0gYXJndW1lbnRzWzBdO1xuICAgICAgICAgICAgICAgIG9ic2VydmFibGUudmFsdWVIYXNNdXRhdGVkKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpczsgLy8gUGVybWl0cyBjaGFpbmVkIGFzc2lnbm1lbnRzXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBSZWFkXG4gICAgICAgICAgICBrby5kZXBlbmRlbmN5RGV0ZWN0aW9uLnJlZ2lzdGVyRGVwZW5kZW5jeShvYnNlcnZhYmxlKTsgLy8gVGhlIGNhbGxlciBvbmx5IG5lZWRzIHRvIGJlIG5vdGlmaWVkIG9mIGNoYW5nZXMgaWYgdGhleSBkaWQgYSBcInJlYWRcIiBvcGVyYXRpb25cbiAgICAgICAgICAgIHJldHVybiBvYnNlcnZhYmxlW29ic2VydmFibGVMYXRlc3RWYWx1ZV07XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBvYnNlcnZhYmxlW29ic2VydmFibGVMYXRlc3RWYWx1ZV0gPSBpbml0aWFsVmFsdWU7XG5cbiAgICAvLyBJbmhlcml0IGZyb20gJ3N1YnNjcmliYWJsZSdcbiAgICBpZiAoIWtvLnV0aWxzLmNhblNldFByb3RvdHlwZSkge1xuICAgICAgICAvLyAnc3Vic2NyaWJhYmxlJyB3b24ndCBiZSBvbiB0aGUgcHJvdG90eXBlIGNoYWluIHVubGVzcyB3ZSBwdXQgaXQgdGhlcmUgZGlyZWN0bHlcbiAgICAgICAga28udXRpbHMuZXh0ZW5kKG9ic2VydmFibGUsIGtvLnN1YnNjcmliYWJsZVsnZm4nXSk7XG4gICAgfVxuICAgIGtvLnN1YnNjcmliYWJsZVsnZm4nXS5pbml0KG9ic2VydmFibGUpO1xuXG4gICAgLy8gSW5oZXJpdCBmcm9tICdvYnNlcnZhYmxlJ1xuICAgIGtvLnV0aWxzLnNldFByb3RvdHlwZU9mT3JFeHRlbmQob2JzZXJ2YWJsZSwgb2JzZXJ2YWJsZUZuKTtcblxuICAgIGlmIChrby5vcHRpb25zWydkZWZlclVwZGF0ZXMnXSkge1xuICAgICAgICBrby5leHRlbmRlcnNbJ2RlZmVycmVkJ10ob2JzZXJ2YWJsZSwgdHJ1ZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG9ic2VydmFibGU7XG59XG5cbi8vIERlZmluZSBwcm90b3R5cGUgZm9yIG9ic2VydmFibGVzXG52YXIgb2JzZXJ2YWJsZUZuID0ge1xuICAgICdlcXVhbGl0eUNvbXBhcmVyJzogdmFsdWVzQXJlUHJpbWl0aXZlQW5kRXF1YWwsXG4gICAgcGVlazogZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzW29ic2VydmFibGVMYXRlc3RWYWx1ZV07IH0sXG4gICAgdmFsdWVIYXNNdXRhdGVkOiBmdW5jdGlvbiAoKSB7IHRoaXNbJ25vdGlmeVN1YnNjcmliZXJzJ10odGhpc1tvYnNlcnZhYmxlTGF0ZXN0VmFsdWVdKTsgfSxcbiAgICB2YWx1ZVdpbGxNdXRhdGU6IGZ1bmN0aW9uICgpIHsgdGhpc1snbm90aWZ5U3Vic2NyaWJlcnMnXSh0aGlzW29ic2VydmFibGVMYXRlc3RWYWx1ZV0sICdiZWZvcmVDaGFuZ2UnKTsgfVxufTtcblxuLy8gTm90ZSB0aGF0IGZvciBicm93c2VycyB0aGF0IGRvbid0IHN1cHBvcnQgcHJvdG8gYXNzaWdubWVudCwgdGhlXG4vLyBpbmhlcml0YW5jZSBjaGFpbiBpcyBjcmVhdGVkIG1hbnVhbGx5IGluIHRoZSBrby5vYnNlcnZhYmxlIGNvbnN0cnVjdG9yXG5pZiAoa28udXRpbHMuY2FuU2V0UHJvdG90eXBlKSB7XG4gICAga28udXRpbHMuc2V0UHJvdG90eXBlT2Yob2JzZXJ2YWJsZUZuLCBrby5zdWJzY3JpYmFibGVbJ2ZuJ10pO1xufVxuXG52YXIgcHJvdG9Qcm9wZXJ0eSA9IGtvLm9ic2VydmFibGUucHJvdG9Qcm9wZXJ0eSA9ICdfX2tvX3Byb3RvX18nO1xub2JzZXJ2YWJsZUZuW3Byb3RvUHJvcGVydHldID0ga28ub2JzZXJ2YWJsZTtcblxua28uaGFzUHJvdG90eXBlID0gZnVuY3Rpb24oaW5zdGFuY2UsIHByb3RvdHlwZSkge1xuICAgIGlmICgoaW5zdGFuY2UgPT09IG51bGwpIHx8IChpbnN0YW5jZSA9PT0gdW5kZWZpbmVkKSB8fCAoaW5zdGFuY2VbcHJvdG9Qcm9wZXJ0eV0gPT09IHVuZGVmaW5lZCkpIHJldHVybiBmYWxzZTtcbiAgICBpZiAoaW5zdGFuY2VbcHJvdG9Qcm9wZXJ0eV0gPT09IHByb3RvdHlwZSkgcmV0dXJuIHRydWU7XG4gICAgcmV0dXJuIGtvLmhhc1Byb3RvdHlwZShpbnN0YW5jZVtwcm90b1Byb3BlcnR5XSwgcHJvdG90eXBlKTsgLy8gV2FsayB0aGUgcHJvdG90eXBlIGNoYWluXG59O1xuXG5rby5pc09ic2VydmFibGUgPSBmdW5jdGlvbiAoaW5zdGFuY2UpIHtcbiAgICByZXR1cm4ga28uaGFzUHJvdG90eXBlKGluc3RhbmNlLCBrby5vYnNlcnZhYmxlKTtcbn1cbmtvLmlzV3JpdGVhYmxlT2JzZXJ2YWJsZSA9IGZ1bmN0aW9uIChpbnN0YW5jZSkge1xuICAgIC8vIE9ic2VydmFibGVcbiAgICBpZiAoKHR5cGVvZiBpbnN0YW5jZSA9PSAnZnVuY3Rpb24nKSAmJiBpbnN0YW5jZVtwcm90b1Byb3BlcnR5XSA9PT0ga28ub2JzZXJ2YWJsZSlcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgLy8gV3JpdGVhYmxlIGRlcGVuZGVudCBvYnNlcnZhYmxlXG4gICAgaWYgKCh0eXBlb2YgaW5zdGFuY2UgPT0gJ2Z1bmN0aW9uJykgJiYgKGluc3RhbmNlW3Byb3RvUHJvcGVydHldID09PSBrby5kZXBlbmRlbnRPYnNlcnZhYmxlKSAmJiAoaW5zdGFuY2UuaGFzV3JpdGVGdW5jdGlvbikpXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIC8vIEFueXRoaW5nIGVsc2VcbiAgICByZXR1cm4gZmFsc2U7XG59XG5cbmtvLmV4cG9ydFN5bWJvbCgnb2JzZXJ2YWJsZScsIGtvLm9ic2VydmFibGUpO1xua28uZXhwb3J0U3ltYm9sKCdpc09ic2VydmFibGUnLCBrby5pc09ic2VydmFibGUpO1xua28uZXhwb3J0U3ltYm9sKCdpc1dyaXRlYWJsZU9ic2VydmFibGUnLCBrby5pc1dyaXRlYWJsZU9ic2VydmFibGUpO1xua28uZXhwb3J0U3ltYm9sKCdpc1dyaXRhYmxlT2JzZXJ2YWJsZScsIGtvLmlzV3JpdGVhYmxlT2JzZXJ2YWJsZSk7XG5rby5leHBvcnRTeW1ib2woJ29ic2VydmFibGUuZm4nLCBvYnNlcnZhYmxlRm4pO1xua28uZXhwb3J0UHJvcGVydHkob2JzZXJ2YWJsZUZuLCAncGVlaycsIG9ic2VydmFibGVGbi5wZWVrKTtcbmtvLmV4cG9ydFByb3BlcnR5KG9ic2VydmFibGVGbiwgJ3ZhbHVlSGFzTXV0YXRlZCcsIG9ic2VydmFibGVGbi52YWx1ZUhhc011dGF0ZWQpO1xua28uZXhwb3J0UHJvcGVydHkob2JzZXJ2YWJsZUZuLCAndmFsdWVXaWxsTXV0YXRlJywgb2JzZXJ2YWJsZUZuLnZhbHVlV2lsbE11dGF0ZSk7XG5rby5vYnNlcnZhYmxlQXJyYXkgPSBmdW5jdGlvbiAoaW5pdGlhbFZhbHVlcykge1xuICAgIGluaXRpYWxWYWx1ZXMgPSBpbml0aWFsVmFsdWVzIHx8IFtdO1xuXG4gICAgaWYgKHR5cGVvZiBpbml0aWFsVmFsdWVzICE9ICdvYmplY3QnIHx8ICEoJ2xlbmd0aCcgaW4gaW5pdGlhbFZhbHVlcykpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoZSBhcmd1bWVudCBwYXNzZWQgd2hlbiBpbml0aWFsaXppbmcgYW4gb2JzZXJ2YWJsZSBhcnJheSBtdXN0IGJlIGFuIGFycmF5LCBvciBudWxsLCBvciB1bmRlZmluZWQuXCIpO1xuXG4gICAgdmFyIHJlc3VsdCA9IGtvLm9ic2VydmFibGUoaW5pdGlhbFZhbHVlcyk7XG4gICAga28udXRpbHMuc2V0UHJvdG90eXBlT2ZPckV4dGVuZChyZXN1bHQsIGtvLm9ic2VydmFibGVBcnJheVsnZm4nXSk7XG4gICAgcmV0dXJuIHJlc3VsdC5leHRlbmQoeyd0cmFja0FycmF5Q2hhbmdlcyc6dHJ1ZX0pO1xufTtcblxua28ub2JzZXJ2YWJsZUFycmF5WydmbiddID0ge1xuICAgICdyZW1vdmUnOiBmdW5jdGlvbiAodmFsdWVPclByZWRpY2F0ZSkge1xuICAgICAgICB2YXIgdW5kZXJseWluZ0FycmF5ID0gdGhpcy5wZWVrKCk7XG4gICAgICAgIHZhciByZW1vdmVkVmFsdWVzID0gW107XG4gICAgICAgIHZhciBwcmVkaWNhdGUgPSB0eXBlb2YgdmFsdWVPclByZWRpY2F0ZSA9PSBcImZ1bmN0aW9uXCIgJiYgIWtvLmlzT2JzZXJ2YWJsZSh2YWx1ZU9yUHJlZGljYXRlKSA/IHZhbHVlT3JQcmVkaWNhdGUgOiBmdW5jdGlvbiAodmFsdWUpIHsgcmV0dXJuIHZhbHVlID09PSB2YWx1ZU9yUHJlZGljYXRlOyB9O1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHVuZGVybHlpbmdBcnJheS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gdW5kZXJseWluZ0FycmF5W2ldO1xuICAgICAgICAgICAgaWYgKHByZWRpY2F0ZSh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICBpZiAocmVtb3ZlZFZhbHVlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy52YWx1ZVdpbGxNdXRhdGUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVtb3ZlZFZhbHVlcy5wdXNoKHZhbHVlKTtcbiAgICAgICAgICAgICAgICB1bmRlcmx5aW5nQXJyYXkuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgICAgIGktLTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAocmVtb3ZlZFZhbHVlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMudmFsdWVIYXNNdXRhdGVkKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlbW92ZWRWYWx1ZXM7XG4gICAgfSxcblxuICAgICdyZW1vdmVBbGwnOiBmdW5jdGlvbiAoYXJyYXlPZlZhbHVlcykge1xuICAgICAgICAvLyBJZiB5b3UgcGFzc2VkIHplcm8gYXJncywgd2UgcmVtb3ZlIGV2ZXJ5dGhpbmdcbiAgICAgICAgaWYgKGFycmF5T2ZWYWx1ZXMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdmFyIHVuZGVybHlpbmdBcnJheSA9IHRoaXMucGVlaygpO1xuICAgICAgICAgICAgdmFyIGFsbFZhbHVlcyA9IHVuZGVybHlpbmdBcnJheS5zbGljZSgwKTtcbiAgICAgICAgICAgIHRoaXMudmFsdWVXaWxsTXV0YXRlKCk7XG4gICAgICAgICAgICB1bmRlcmx5aW5nQXJyYXkuc3BsaWNlKDAsIHVuZGVybHlpbmdBcnJheS5sZW5ndGgpO1xuICAgICAgICAgICAgdGhpcy52YWx1ZUhhc011dGF0ZWQoKTtcbiAgICAgICAgICAgIHJldHVybiBhbGxWYWx1ZXM7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgeW91IHBhc3NlZCBhbiBhcmcsIHdlIGludGVycHJldCBpdCBhcyBhbiBhcnJheSBvZiBlbnRyaWVzIHRvIHJlbW92ZVxuICAgICAgICBpZiAoIWFycmF5T2ZWYWx1ZXMpXG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIHJldHVybiB0aGlzWydyZW1vdmUnXShmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiBrby51dGlscy5hcnJheUluZGV4T2YoYXJyYXlPZlZhbHVlcywgdmFsdWUpID49IDA7XG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAnZGVzdHJveSc6IGZ1bmN0aW9uICh2YWx1ZU9yUHJlZGljYXRlKSB7XG4gICAgICAgIHZhciB1bmRlcmx5aW5nQXJyYXkgPSB0aGlzLnBlZWsoKTtcbiAgICAgICAgdmFyIHByZWRpY2F0ZSA9IHR5cGVvZiB2YWx1ZU9yUHJlZGljYXRlID09IFwiZnVuY3Rpb25cIiAmJiAha28uaXNPYnNlcnZhYmxlKHZhbHVlT3JQcmVkaWNhdGUpID8gdmFsdWVPclByZWRpY2F0ZSA6IGZ1bmN0aW9uICh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgPT09IHZhbHVlT3JQcmVkaWNhdGU7IH07XG4gICAgICAgIHRoaXMudmFsdWVXaWxsTXV0YXRlKCk7XG4gICAgICAgIGZvciAodmFyIGkgPSB1bmRlcmx5aW5nQXJyYXkubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IHVuZGVybHlpbmdBcnJheVtpXTtcbiAgICAgICAgICAgIGlmIChwcmVkaWNhdGUodmFsdWUpKVxuICAgICAgICAgICAgICAgIHVuZGVybHlpbmdBcnJheVtpXVtcIl9kZXN0cm95XCJdID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnZhbHVlSGFzTXV0YXRlZCgpO1xuICAgIH0sXG5cbiAgICAnZGVzdHJveUFsbCc6IGZ1bmN0aW9uIChhcnJheU9mVmFsdWVzKSB7XG4gICAgICAgIC8vIElmIHlvdSBwYXNzZWQgemVybyBhcmdzLCB3ZSBkZXN0cm95IGV2ZXJ5dGhpbmdcbiAgICAgICAgaWYgKGFycmF5T2ZWYWx1ZXMgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHJldHVybiB0aGlzWydkZXN0cm95J10oZnVuY3Rpb24oKSB7IHJldHVybiB0cnVlIH0pO1xuXG4gICAgICAgIC8vIElmIHlvdSBwYXNzZWQgYW4gYXJnLCB3ZSBpbnRlcnByZXQgaXQgYXMgYW4gYXJyYXkgb2YgZW50cmllcyB0byBkZXN0cm95XG4gICAgICAgIGlmICghYXJyYXlPZlZhbHVlcylcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgcmV0dXJuIHRoaXNbJ2Rlc3Ryb3knXShmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiBrby51dGlscy5hcnJheUluZGV4T2YoYXJyYXlPZlZhbHVlcywgdmFsdWUpID49IDA7XG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAnaW5kZXhPZic6IGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgIHZhciB1bmRlcmx5aW5nQXJyYXkgPSB0aGlzKCk7XG4gICAgICAgIHJldHVybiBrby51dGlscy5hcnJheUluZGV4T2YodW5kZXJseWluZ0FycmF5LCBpdGVtKTtcbiAgICB9LFxuXG4gICAgJ3JlcGxhY2UnOiBmdW5jdGlvbihvbGRJdGVtLCBuZXdJdGVtKSB7XG4gICAgICAgIHZhciBpbmRleCA9IHRoaXNbJ2luZGV4T2YnXShvbGRJdGVtKTtcbiAgICAgICAgaWYgKGluZGV4ID49IDApIHtcbiAgICAgICAgICAgIHRoaXMudmFsdWVXaWxsTXV0YXRlKCk7XG4gICAgICAgICAgICB0aGlzLnBlZWsoKVtpbmRleF0gPSBuZXdJdGVtO1xuICAgICAgICAgICAgdGhpcy52YWx1ZUhhc011dGF0ZWQoKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbi8vIE5vdGUgdGhhdCBmb3IgYnJvd3NlcnMgdGhhdCBkb24ndCBzdXBwb3J0IHByb3RvIGFzc2lnbm1lbnQsIHRoZVxuLy8gaW5oZXJpdGFuY2UgY2hhaW4gaXMgY3JlYXRlZCBtYW51YWxseSBpbiB0aGUga28ub2JzZXJ2YWJsZUFycmF5IGNvbnN0cnVjdG9yXG5pZiAoa28udXRpbHMuY2FuU2V0UHJvdG90eXBlKSB7XG4gICAga28udXRpbHMuc2V0UHJvdG90eXBlT2Yoa28ub2JzZXJ2YWJsZUFycmF5WydmbiddLCBrby5vYnNlcnZhYmxlWydmbiddKTtcbn1cblxuLy8gUG9wdWxhdGUga28ub2JzZXJ2YWJsZUFycmF5LmZuIHdpdGggcmVhZC93cml0ZSBmdW5jdGlvbnMgZnJvbSBuYXRpdmUgYXJyYXlzXG4vLyBJbXBvcnRhbnQ6IERvIG5vdCBhZGQgYW55IGFkZGl0aW9uYWwgZnVuY3Rpb25zIGhlcmUgdGhhdCBtYXkgcmVhc29uYWJseSBiZSB1c2VkIHRvICpyZWFkKiBkYXRhIGZyb20gdGhlIGFycmF5XG4vLyBiZWNhdXNlIHdlJ2xsIGV2YWwgdGhlbSB3aXRob3V0IGNhdXNpbmcgc3Vic2NyaXB0aW9ucywgc28ga28uY29tcHV0ZWQgb3V0cHV0IGNvdWxkIGVuZCB1cCBnZXR0aW5nIHN0YWxlXG5rby51dGlscy5hcnJheUZvckVhY2goW1wicG9wXCIsIFwicHVzaFwiLCBcInJldmVyc2VcIiwgXCJzaGlmdFwiLCBcInNvcnRcIiwgXCJzcGxpY2VcIiwgXCJ1bnNoaWZ0XCJdLCBmdW5jdGlvbiAobWV0aG9kTmFtZSkge1xuICAgIGtvLm9ic2VydmFibGVBcnJheVsnZm4nXVttZXRob2ROYW1lXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gVXNlIFwicGVla1wiIHRvIGF2b2lkIGNyZWF0aW5nIGEgc3Vic2NyaXB0aW9uIGluIGFueSBjb21wdXRlZCB0aGF0IHdlJ3JlIGV4ZWN1dGluZyBpbiB0aGUgY29udGV4dCBvZlxuICAgICAgICAvLyAoZm9yIGNvbnNpc3RlbmN5IHdpdGggbXV0YXRpbmcgcmVndWxhciBvYnNlcnZhYmxlcylcbiAgICAgICAgdmFyIHVuZGVybHlpbmdBcnJheSA9IHRoaXMucGVlaygpO1xuICAgICAgICB0aGlzLnZhbHVlV2lsbE11dGF0ZSgpO1xuICAgICAgICB0aGlzLmNhY2hlRGlmZkZvcktub3duT3BlcmF0aW9uKHVuZGVybHlpbmdBcnJheSwgbWV0aG9kTmFtZSwgYXJndW1lbnRzKTtcbiAgICAgICAgdmFyIG1ldGhvZENhbGxSZXN1bHQgPSB1bmRlcmx5aW5nQXJyYXlbbWV0aG9kTmFtZV0uYXBwbHkodW5kZXJseWluZ0FycmF5LCBhcmd1bWVudHMpO1xuICAgICAgICB0aGlzLnZhbHVlSGFzTXV0YXRlZCgpO1xuICAgICAgICAvLyBUaGUgbmF0aXZlIHNvcnQgYW5kIHJldmVyc2UgbWV0aG9kcyByZXR1cm4gYSByZWZlcmVuY2UgdG8gdGhlIGFycmF5LCBidXQgaXQgbWFrZXMgbW9yZSBzZW5zZSB0byByZXR1cm4gdGhlIG9ic2VydmFibGUgYXJyYXkgaW5zdGVhZC5cbiAgICAgICAgcmV0dXJuIG1ldGhvZENhbGxSZXN1bHQgPT09IHVuZGVybHlpbmdBcnJheSA/IHRoaXMgOiBtZXRob2RDYWxsUmVzdWx0O1xuICAgIH07XG59KTtcblxuLy8gUG9wdWxhdGUga28ub2JzZXJ2YWJsZUFycmF5LmZuIHdpdGggcmVhZC1vbmx5IGZ1bmN0aW9ucyBmcm9tIG5hdGl2ZSBhcnJheXNcbmtvLnV0aWxzLmFycmF5Rm9yRWFjaChbXCJzbGljZVwiXSwgZnVuY3Rpb24gKG1ldGhvZE5hbWUpIHtcbiAgICBrby5vYnNlcnZhYmxlQXJyYXlbJ2ZuJ11bbWV0aG9kTmFtZV0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB1bmRlcmx5aW5nQXJyYXkgPSB0aGlzKCk7XG4gICAgICAgIHJldHVybiB1bmRlcmx5aW5nQXJyYXlbbWV0aG9kTmFtZV0uYXBwbHkodW5kZXJseWluZ0FycmF5LCBhcmd1bWVudHMpO1xuICAgIH07XG59KTtcblxua28uZXhwb3J0U3ltYm9sKCdvYnNlcnZhYmxlQXJyYXknLCBrby5vYnNlcnZhYmxlQXJyYXkpO1xudmFyIGFycmF5Q2hhbmdlRXZlbnROYW1lID0gJ2FycmF5Q2hhbmdlJztcbmtvLmV4dGVuZGVyc1sndHJhY2tBcnJheUNoYW5nZXMnXSA9IGZ1bmN0aW9uKHRhcmdldCwgb3B0aW9ucykge1xuICAgIC8vIFVzZSB0aGUgcHJvdmlkZWQgb3B0aW9ucy0tZWFjaCBjYWxsIHRvIHRyYWNrQXJyYXlDaGFuZ2VzIG92ZXJ3cml0ZXMgdGhlIHByZXZpb3VzbHkgc2V0IG9wdGlvbnNcbiAgICB0YXJnZXQuY29tcGFyZUFycmF5T3B0aW9ucyA9IHt9O1xuICAgIGlmIChvcHRpb25zICYmIHR5cGVvZiBvcHRpb25zID09IFwib2JqZWN0XCIpIHtcbiAgICAgICAga28udXRpbHMuZXh0ZW5kKHRhcmdldC5jb21wYXJlQXJyYXlPcHRpb25zLCBvcHRpb25zKTtcbiAgICB9XG4gICAgdGFyZ2V0LmNvbXBhcmVBcnJheU9wdGlvbnNbJ3NwYXJzZSddID0gdHJ1ZTtcblxuICAgIC8vIE9ubHkgbW9kaWZ5IHRoZSB0YXJnZXQgb2JzZXJ2YWJsZSBvbmNlXG4gICAgaWYgKHRhcmdldC5jYWNoZURpZmZGb3JLbm93bk9wZXJhdGlvbikge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciB0cmFja2luZ0NoYW5nZXMgPSBmYWxzZSxcbiAgICAgICAgY2FjaGVkRGlmZiA9IG51bGwsXG4gICAgICAgIGFycmF5Q2hhbmdlU3Vic2NyaXB0aW9uLFxuICAgICAgICBwZW5kaW5nTm90aWZpY2F0aW9ucyA9IDAsXG4gICAgICAgIHVuZGVybHlpbmdOb3RpZnlTdWJzY3JpYmVyc0Z1bmN0aW9uLFxuICAgICAgICB1bmRlcmx5aW5nQmVmb3JlU3Vic2NyaXB0aW9uQWRkRnVuY3Rpb24gPSB0YXJnZXQuYmVmb3JlU3Vic2NyaXB0aW9uQWRkLFxuICAgICAgICB1bmRlcmx5aW5nQWZ0ZXJTdWJzY3JpcHRpb25SZW1vdmVGdW5jdGlvbiA9IHRhcmdldC5hZnRlclN1YnNjcmlwdGlvblJlbW92ZTtcblxuICAgIC8vIFdhdGNoIFwic3Vic2NyaWJlXCIgY2FsbHMsIGFuZCBmb3IgYXJyYXkgY2hhbmdlIGV2ZW50cywgZW5zdXJlIGNoYW5nZSB0cmFja2luZyBpcyBlbmFibGVkXG4gICAgdGFyZ2V0LmJlZm9yZVN1YnNjcmlwdGlvbkFkZCA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICBpZiAodW5kZXJseWluZ0JlZm9yZVN1YnNjcmlwdGlvbkFkZEZ1bmN0aW9uKVxuICAgICAgICAgICAgdW5kZXJseWluZ0JlZm9yZVN1YnNjcmlwdGlvbkFkZEZ1bmN0aW9uLmNhbGwodGFyZ2V0LCBldmVudCk7XG4gICAgICAgIGlmIChldmVudCA9PT0gYXJyYXlDaGFuZ2VFdmVudE5hbWUpIHtcbiAgICAgICAgICAgIHRyYWNrQ2hhbmdlcygpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvLyBXYXRjaCBcImRpc3Bvc2VcIiBjYWxscywgYW5kIGZvciBhcnJheSBjaGFuZ2UgZXZlbnRzLCBlbnN1cmUgY2hhbmdlIHRyYWNraW5nIGlzIGRpc2FibGVkIHdoZW4gYWxsIGFyZSBkaXNwb3NlZFxuICAgIHRhcmdldC5hZnRlclN1YnNjcmlwdGlvblJlbW92ZSA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICBpZiAodW5kZXJseWluZ0FmdGVyU3Vic2NyaXB0aW9uUmVtb3ZlRnVuY3Rpb24pXG4gICAgICAgICAgICB1bmRlcmx5aW5nQWZ0ZXJTdWJzY3JpcHRpb25SZW1vdmVGdW5jdGlvbi5jYWxsKHRhcmdldCwgZXZlbnQpO1xuICAgICAgICBpZiAoZXZlbnQgPT09IGFycmF5Q2hhbmdlRXZlbnROYW1lICYmICF0YXJnZXQuaGFzU3Vic2NyaXB0aW9uc0ZvckV2ZW50KGFycmF5Q2hhbmdlRXZlbnROYW1lKSkge1xuICAgICAgICAgICAgaWYgKHVuZGVybHlpbmdOb3RpZnlTdWJzY3JpYmVyc0Z1bmN0aW9uKSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0Wydub3RpZnlTdWJzY3JpYmVycyddID0gdW5kZXJseWluZ05vdGlmeVN1YnNjcmliZXJzRnVuY3Rpb247XG4gICAgICAgICAgICAgICAgdW5kZXJseWluZ05vdGlmeVN1YnNjcmliZXJzRnVuY3Rpb24gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhcnJheUNoYW5nZVN1YnNjcmlwdGlvbi5kaXNwb3NlKCk7XG4gICAgICAgICAgICB0cmFja2luZ0NoYW5nZXMgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBmdW5jdGlvbiB0cmFja0NoYW5nZXMoKSB7XG4gICAgICAgIC8vIENhbGxpbmcgJ3RyYWNrQ2hhbmdlcycgbXVsdGlwbGUgdGltZXMgaXMgdGhlIHNhbWUgYXMgY2FsbGluZyBpdCBvbmNlXG4gICAgICAgIGlmICh0cmFja2luZ0NoYW5nZXMpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRyYWNraW5nQ2hhbmdlcyA9IHRydWU7XG5cbiAgICAgICAgLy8gSW50ZXJjZXB0IFwibm90aWZ5U3Vic2NyaWJlcnNcIiB0byB0cmFjayBob3cgbWFueSB0aW1lcyBpdCB3YXMgY2FsbGVkLlxuICAgICAgICB1bmRlcmx5aW5nTm90aWZ5U3Vic2NyaWJlcnNGdW5jdGlvbiA9IHRhcmdldFsnbm90aWZ5U3Vic2NyaWJlcnMnXTtcbiAgICAgICAgdGFyZ2V0Wydub3RpZnlTdWJzY3JpYmVycyddID0gZnVuY3Rpb24odmFsdWVUb05vdGlmeSwgZXZlbnQpIHtcbiAgICAgICAgICAgIGlmICghZXZlbnQgfHwgZXZlbnQgPT09IGRlZmF1bHRFdmVudCkge1xuICAgICAgICAgICAgICAgICsrcGVuZGluZ05vdGlmaWNhdGlvbnM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdW5kZXJseWluZ05vdGlmeVN1YnNjcmliZXJzRnVuY3Rpb24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBFYWNoIHRpbWUgdGhlIGFycmF5IGNoYW5nZXMgdmFsdWUsIGNhcHR1cmUgYSBjbG9uZSBzbyB0aGF0IG9uIHRoZSBuZXh0XG4gICAgICAgIC8vIGNoYW5nZSBpdCdzIHBvc3NpYmxlIHRvIHByb2R1Y2UgYSBkaWZmXG4gICAgICAgIHZhciBwcmV2aW91c0NvbnRlbnRzID0gW10uY29uY2F0KHRhcmdldC5wZWVrKCkgfHwgW10pO1xuICAgICAgICBjYWNoZWREaWZmID0gbnVsbDtcbiAgICAgICAgYXJyYXlDaGFuZ2VTdWJzY3JpcHRpb24gPSB0YXJnZXQuc3Vic2NyaWJlKGZ1bmN0aW9uKGN1cnJlbnRDb250ZW50cykge1xuICAgICAgICAgICAgLy8gTWFrZSBhIGNvcHkgb2YgdGhlIGN1cnJlbnQgY29udGVudHMgYW5kIGVuc3VyZSBpdCdzIGFuIGFycmF5XG4gICAgICAgICAgICBjdXJyZW50Q29udGVudHMgPSBbXS5jb25jYXQoY3VycmVudENvbnRlbnRzIHx8IFtdKTtcblxuICAgICAgICAgICAgLy8gQ29tcHV0ZSB0aGUgZGlmZiBhbmQgaXNzdWUgbm90aWZpY2F0aW9ucywgYnV0IG9ubHkgaWYgc29tZW9uZSBpcyBsaXN0ZW5pbmdcbiAgICAgICAgICAgIGlmICh0YXJnZXQuaGFzU3Vic2NyaXB0aW9uc0ZvckV2ZW50KGFycmF5Q2hhbmdlRXZlbnROYW1lKSkge1xuICAgICAgICAgICAgICAgIHZhciBjaGFuZ2VzID0gZ2V0Q2hhbmdlcyhwcmV2aW91c0NvbnRlbnRzLCBjdXJyZW50Q29udGVudHMpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBFbGltaW5hdGUgcmVmZXJlbmNlcyB0byB0aGUgb2xkLCByZW1vdmVkIGl0ZW1zLCBzbyB0aGV5IGNhbiBiZSBHQ2VkXG4gICAgICAgICAgICBwcmV2aW91c0NvbnRlbnRzID0gY3VycmVudENvbnRlbnRzO1xuICAgICAgICAgICAgY2FjaGVkRGlmZiA9IG51bGw7XG4gICAgICAgICAgICBwZW5kaW5nTm90aWZpY2F0aW9ucyA9IDA7XG5cbiAgICAgICAgICAgIGlmIChjaGFuZ2VzICYmIGNoYW5nZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0Wydub3RpZnlTdWJzY3JpYmVycyddKGNoYW5nZXMsIGFycmF5Q2hhbmdlRXZlbnROYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0Q2hhbmdlcyhwcmV2aW91c0NvbnRlbnRzLCBjdXJyZW50Q29udGVudHMpIHtcbiAgICAgICAgLy8gV2UgdHJ5IHRvIHJlLXVzZSBjYWNoZWQgZGlmZnMuXG4gICAgICAgIC8vIFRoZSBzY2VuYXJpb3Mgd2hlcmUgcGVuZGluZ05vdGlmaWNhdGlvbnMgPiAxIGFyZSB3aGVuIHVzaW5nIHJhdGUtbGltaXRpbmcgb3IgdGhlIERlZmVycmVkIFVwZGF0ZXNcbiAgICAgICAgLy8gcGx1Z2luLCB3aGljaCB3aXRob3V0IHRoaXMgY2hlY2sgd291bGQgbm90IGJlIGNvbXBhdGlibGUgd2l0aCBhcnJheUNoYW5nZSBub3RpZmljYXRpb25zLiBOb3JtYWxseSxcbiAgICAgICAgLy8gbm90aWZpY2F0aW9ucyBhcmUgaXNzdWVkIGltbWVkaWF0ZWx5IHNvIHdlIHdvdWxkbid0IGJlIHF1ZXVlaW5nIHVwIG1vcmUgdGhhbiBvbmUuXG4gICAgICAgIGlmICghY2FjaGVkRGlmZiB8fCBwZW5kaW5nTm90aWZpY2F0aW9ucyA+IDEpIHtcbiAgICAgICAgICAgIGNhY2hlZERpZmYgPSBrby51dGlscy5jb21wYXJlQXJyYXlzKHByZXZpb3VzQ29udGVudHMsIGN1cnJlbnRDb250ZW50cywgdGFyZ2V0LmNvbXBhcmVBcnJheU9wdGlvbnMpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNhY2hlZERpZmY7XG4gICAgfVxuXG4gICAgdGFyZ2V0LmNhY2hlRGlmZkZvcktub3duT3BlcmF0aW9uID0gZnVuY3Rpb24ocmF3QXJyYXksIG9wZXJhdGlvbk5hbWUsIGFyZ3MpIHtcbiAgICAgICAgLy8gT25seSBydW4gaWYgd2UncmUgY3VycmVudGx5IHRyYWNraW5nIGNoYW5nZXMgZm9yIHRoaXMgb2JzZXJ2YWJsZSBhcnJheVxuICAgICAgICAvLyBhbmQgdGhlcmUgYXJlbid0IGFueSBwZW5kaW5nIGRlZmVycmVkIG5vdGlmaWNhdGlvbnMuXG4gICAgICAgIGlmICghdHJhY2tpbmdDaGFuZ2VzIHx8IHBlbmRpbmdOb3RpZmljYXRpb25zKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGRpZmYgPSBbXSxcbiAgICAgICAgICAgIGFycmF5TGVuZ3RoID0gcmF3QXJyYXkubGVuZ3RoLFxuICAgICAgICAgICAgYXJnc0xlbmd0aCA9IGFyZ3MubGVuZ3RoLFxuICAgICAgICAgICAgb2Zmc2V0ID0gMDtcblxuICAgICAgICBmdW5jdGlvbiBwdXNoRGlmZihzdGF0dXMsIHZhbHVlLCBpbmRleCkge1xuICAgICAgICAgICAgcmV0dXJuIGRpZmZbZGlmZi5sZW5ndGhdID0geyAnc3RhdHVzJzogc3RhdHVzLCAndmFsdWUnOiB2YWx1ZSwgJ2luZGV4JzogaW5kZXggfTtcbiAgICAgICAgfVxuICAgICAgICBzd2l0Y2ggKG9wZXJhdGlvbk5hbWUpIHtcbiAgICAgICAgICAgIGNhc2UgJ3B1c2gnOlxuICAgICAgICAgICAgICAgIG9mZnNldCA9IGFycmF5TGVuZ3RoO1xuICAgICAgICAgICAgY2FzZSAndW5zaGlmdCc6XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IGFyZ3NMZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgICAgICAgICAgICAgcHVzaERpZmYoJ2FkZGVkJywgYXJnc1tpbmRleF0sIG9mZnNldCArIGluZGV4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgJ3BvcCc6XG4gICAgICAgICAgICAgICAgb2Zmc2V0ID0gYXJyYXlMZW5ndGggLSAxO1xuICAgICAgICAgICAgY2FzZSAnc2hpZnQnOlxuICAgICAgICAgICAgICAgIGlmIChhcnJheUxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBwdXNoRGlmZignZGVsZXRlZCcsIHJhd0FycmF5W29mZnNldF0sIG9mZnNldCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlICdzcGxpY2UnOlxuICAgICAgICAgICAgICAgIC8vIE5lZ2F0aXZlIHN0YXJ0IGluZGV4IG1lYW5zICdmcm9tIGVuZCBvZiBhcnJheScuIEFmdGVyIHRoYXQgd2UgY2xhbXAgdG8gWzAuLi5hcnJheUxlbmd0aF0uXG4gICAgICAgICAgICAgICAgLy8gU2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0FycmF5L3NwbGljZVxuICAgICAgICAgICAgICAgIHZhciBzdGFydEluZGV4ID0gTWF0aC5taW4oTWF0aC5tYXgoMCwgYXJnc1swXSA8IDAgPyBhcnJheUxlbmd0aCArIGFyZ3NbMF0gOiBhcmdzWzBdKSwgYXJyYXlMZW5ndGgpLFxuICAgICAgICAgICAgICAgICAgICBlbmREZWxldGVJbmRleCA9IGFyZ3NMZW5ndGggPT09IDEgPyBhcnJheUxlbmd0aCA6IE1hdGgubWluKHN0YXJ0SW5kZXggKyAoYXJnc1sxXSB8fCAwKSwgYXJyYXlMZW5ndGgpLFxuICAgICAgICAgICAgICAgICAgICBlbmRBZGRJbmRleCA9IHN0YXJ0SW5kZXggKyBhcmdzTGVuZ3RoIC0gMixcbiAgICAgICAgICAgICAgICAgICAgZW5kSW5kZXggPSBNYXRoLm1heChlbmREZWxldGVJbmRleCwgZW5kQWRkSW5kZXgpLFxuICAgICAgICAgICAgICAgICAgICBhZGRpdGlvbnMgPSBbXSwgZGVsZXRpb25zID0gW107XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaW5kZXggPSBzdGFydEluZGV4LCBhcmdzSW5kZXggPSAyOyBpbmRleCA8IGVuZEluZGV4OyArK2luZGV4LCArK2FyZ3NJbmRleCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaW5kZXggPCBlbmREZWxldGVJbmRleClcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0aW9ucy5wdXNoKHB1c2hEaWZmKCdkZWxldGVkJywgcmF3QXJyYXlbaW5kZXhdLCBpbmRleCkpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaW5kZXggPCBlbmRBZGRJbmRleClcbiAgICAgICAgICAgICAgICAgICAgICAgIGFkZGl0aW9ucy5wdXNoKHB1c2hEaWZmKCdhZGRlZCcsIGFyZ3NbYXJnc0luZGV4XSwgaW5kZXgpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAga28udXRpbHMuZmluZE1vdmVzSW5BcnJheUNvbXBhcmlzb24oZGVsZXRpb25zLCBhZGRpdGlvbnMpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjYWNoZWREaWZmID0gZGlmZjtcbiAgICB9O1xufTtcbnZhciBjb21wdXRlZFN0YXRlID0ga28udXRpbHMuY3JlYXRlU3ltYm9sT3JTdHJpbmcoJ19zdGF0ZScpO1xuXG5rby5jb21wdXRlZCA9IGtvLmRlcGVuZGVudE9ic2VydmFibGUgPSBmdW5jdGlvbiAoZXZhbHVhdG9yRnVuY3Rpb25Pck9wdGlvbnMsIGV2YWx1YXRvckZ1bmN0aW9uVGFyZ2V0LCBvcHRpb25zKSB7XG4gICAgaWYgKHR5cGVvZiBldmFsdWF0b3JGdW5jdGlvbk9yT3B0aW9ucyA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAvLyBTaW5nbGUtcGFyYW1ldGVyIHN5bnRheCAtIGV2ZXJ5dGhpbmcgaXMgb24gdGhpcyBcIm9wdGlvbnNcIiBwYXJhbVxuICAgICAgICBvcHRpb25zID0gZXZhbHVhdG9yRnVuY3Rpb25Pck9wdGlvbnM7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gTXVsdGktcGFyYW1ldGVyIHN5bnRheCAtIGNvbnN0cnVjdCB0aGUgb3B0aW9ucyBhY2NvcmRpbmcgdG8gdGhlIHBhcmFtcyBwYXNzZWRcbiAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgICAgIGlmIChldmFsdWF0b3JGdW5jdGlvbk9yT3B0aW9ucykge1xuICAgICAgICAgICAgb3B0aW9uc1tcInJlYWRcIl0gPSBldmFsdWF0b3JGdW5jdGlvbk9yT3B0aW9ucztcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAodHlwZW9mIG9wdGlvbnNbXCJyZWFkXCJdICE9IFwiZnVuY3Rpb25cIilcbiAgICAgICAgdGhyb3cgRXJyb3IoXCJQYXNzIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRoZSB2YWx1ZSBvZiB0aGUga28uY29tcHV0ZWRcIik7XG5cbiAgICB2YXIgd3JpdGVGdW5jdGlvbiA9IG9wdGlvbnNbXCJ3cml0ZVwiXTtcbiAgICB2YXIgc3RhdGUgPSB7XG4gICAgICAgIGxhdGVzdFZhbHVlOiB1bmRlZmluZWQsXG4gICAgICAgIGlzU3RhbGU6IHRydWUsXG4gICAgICAgIGlzQmVpbmdFdmFsdWF0ZWQ6IGZhbHNlLFxuICAgICAgICBzdXBwcmVzc0Rpc3Bvc2FsVW50aWxEaXNwb3NlV2hlblJldHVybnNGYWxzZTogZmFsc2UsXG4gICAgICAgIGlzRGlzcG9zZWQ6IGZhbHNlLFxuICAgICAgICBwdXJlOiBmYWxzZSxcbiAgICAgICAgaXNTbGVlcGluZzogZmFsc2UsXG4gICAgICAgIHJlYWRGdW5jdGlvbjogb3B0aW9uc1tcInJlYWRcIl0sXG4gICAgICAgIGV2YWx1YXRvckZ1bmN0aW9uVGFyZ2V0OiBldmFsdWF0b3JGdW5jdGlvblRhcmdldCB8fCBvcHRpb25zW1wib3duZXJcIl0sXG4gICAgICAgIGRpc3Bvc2VXaGVuTm9kZUlzUmVtb3ZlZDogb3B0aW9uc1tcImRpc3Bvc2VXaGVuTm9kZUlzUmVtb3ZlZFwiXSB8fCBvcHRpb25zLmRpc3Bvc2VXaGVuTm9kZUlzUmVtb3ZlZCB8fCBudWxsLFxuICAgICAgICBkaXNwb3NlV2hlbjogb3B0aW9uc1tcImRpc3Bvc2VXaGVuXCJdIHx8IG9wdGlvbnMuZGlzcG9zZVdoZW4sXG4gICAgICAgIGRvbU5vZGVEaXNwb3NhbENhbGxiYWNrOiBudWxsLFxuICAgICAgICBkZXBlbmRlbmN5VHJhY2tpbmc6IHt9LFxuICAgICAgICBkZXBlbmRlbmNpZXNDb3VudDogMCxcbiAgICAgICAgZXZhbHVhdGlvblRpbWVvdXRJbnN0YW5jZTogbnVsbFxuICAgIH07XG5cbiAgICBmdW5jdGlvbiBjb21wdXRlZE9ic2VydmFibGUoKSB7XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB3cml0ZUZ1bmN0aW9uID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICAvLyBXcml0aW5nIGEgdmFsdWVcbiAgICAgICAgICAgICAgICB3cml0ZUZ1bmN0aW9uLmFwcGx5KHN0YXRlLmV2YWx1YXRvckZ1bmN0aW9uVGFyZ2V0LCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3Qgd3JpdGUgYSB2YWx1ZSB0byBhIGtvLmNvbXB1dGVkIHVubGVzcyB5b3Ugc3BlY2lmeSBhICd3cml0ZScgb3B0aW9uLiBJZiB5b3Ugd2lzaCB0byByZWFkIHRoZSBjdXJyZW50IHZhbHVlLCBkb24ndCBwYXNzIGFueSBwYXJhbWV0ZXJzLlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzOyAvLyBQZXJtaXRzIGNoYWluZWQgYXNzaWdubWVudHNcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIFJlYWRpbmcgdGhlIHZhbHVlXG4gICAgICAgICAgICBrby5kZXBlbmRlbmN5RGV0ZWN0aW9uLnJlZ2lzdGVyRGVwZW5kZW5jeShjb21wdXRlZE9ic2VydmFibGUpO1xuICAgICAgICAgICAgaWYgKHN0YXRlLmlzU3RhbGUgfHwgKHN0YXRlLmlzU2xlZXBpbmcgJiYgY29tcHV0ZWRPYnNlcnZhYmxlLmhhdmVEZXBlbmRlbmNpZXNDaGFuZ2VkKCkpKSB7XG4gICAgICAgICAgICAgICAgY29tcHV0ZWRPYnNlcnZhYmxlLmV2YWx1YXRlSW1tZWRpYXRlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gc3RhdGUubGF0ZXN0VmFsdWU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBjb21wdXRlZE9ic2VydmFibGVbY29tcHV0ZWRTdGF0ZV0gPSBzdGF0ZTtcbiAgICBjb21wdXRlZE9ic2VydmFibGUuaGFzV3JpdGVGdW5jdGlvbiA9IHR5cGVvZiB3cml0ZUZ1bmN0aW9uID09PSBcImZ1bmN0aW9uXCI7XG5cbiAgICAvLyBJbmhlcml0IGZyb20gJ3N1YnNjcmliYWJsZSdcbiAgICBpZiAoIWtvLnV0aWxzLmNhblNldFByb3RvdHlwZSkge1xuICAgICAgICAvLyAnc3Vic2NyaWJhYmxlJyB3b24ndCBiZSBvbiB0aGUgcHJvdG90eXBlIGNoYWluIHVubGVzcyB3ZSBwdXQgaXQgdGhlcmUgZGlyZWN0bHlcbiAgICAgICAga28udXRpbHMuZXh0ZW5kKGNvbXB1dGVkT2JzZXJ2YWJsZSwga28uc3Vic2NyaWJhYmxlWydmbiddKTtcbiAgICB9XG4gICAga28uc3Vic2NyaWJhYmxlWydmbiddLmluaXQoY29tcHV0ZWRPYnNlcnZhYmxlKTtcblxuICAgIC8vIEluaGVyaXQgZnJvbSAnY29tcHV0ZWQnXG4gICAga28udXRpbHMuc2V0UHJvdG90eXBlT2ZPckV4dGVuZChjb21wdXRlZE9ic2VydmFibGUsIGNvbXB1dGVkRm4pO1xuXG4gICAgaWYgKG9wdGlvbnNbJ3B1cmUnXSkge1xuICAgICAgICBzdGF0ZS5wdXJlID0gdHJ1ZTtcbiAgICAgICAgc3RhdGUuaXNTbGVlcGluZyA9IHRydWU7ICAgICAvLyBTdGFydHMgb2ZmIHNsZWVwaW5nOyB3aWxsIGF3YWtlIG9uIHRoZSBmaXJzdCBzdWJzY3JpcHRpb25cbiAgICAgICAga28udXRpbHMuZXh0ZW5kKGNvbXB1dGVkT2JzZXJ2YWJsZSwgcHVyZUNvbXB1dGVkT3ZlcnJpZGVzKTtcbiAgICB9IGVsc2UgaWYgKG9wdGlvbnNbJ2RlZmVyRXZhbHVhdGlvbiddKSB7XG4gICAgICAgIGtvLnV0aWxzLmV4dGVuZChjb21wdXRlZE9ic2VydmFibGUsIGRlZmVyRXZhbHVhdGlvbk92ZXJyaWRlcyk7XG4gICAgfVxuXG4gICAgaWYgKGtvLm9wdGlvbnNbJ2RlZmVyVXBkYXRlcyddKSB7XG4gICAgICAgIGtvLmV4dGVuZGVyc1snZGVmZXJyZWQnXShjb21wdXRlZE9ic2VydmFibGUsIHRydWUpO1xuICAgIH1cblxuICAgIGlmIChERUJVRykge1xuICAgICAgICAvLyAjMTczMSAtIEFpZCBkZWJ1Z2dpbmcgYnkgZXhwb3NpbmcgdGhlIGNvbXB1dGVkJ3Mgb3B0aW9uc1xuICAgICAgICBjb21wdXRlZE9ic2VydmFibGVbXCJfb3B0aW9uc1wiXSA9IG9wdGlvbnM7XG4gICAgfVxuXG4gICAgaWYgKHN0YXRlLmRpc3Bvc2VXaGVuTm9kZUlzUmVtb3ZlZCkge1xuICAgICAgICAvLyBTaW5jZSB0aGlzIGNvbXB1dGVkIGlzIGFzc29jaWF0ZWQgd2l0aCBhIERPTSBub2RlLCBhbmQgd2UgZG9uJ3Qgd2FudCB0byBkaXNwb3NlIHRoZSBjb21wdXRlZFxuICAgICAgICAvLyB1bnRpbCB0aGUgRE9NIG5vZGUgaXMgKnJlbW92ZWQqIGZyb20gdGhlIGRvY3VtZW50IChhcyBvcHBvc2VkIHRvIG5ldmVyIGhhdmluZyBiZWVuIGluIHRoZSBkb2N1bWVudCksXG4gICAgICAgIC8vIHdlJ2xsIHByZXZlbnQgZGlzcG9zYWwgdW50aWwgXCJkaXNwb3NlV2hlblwiIGZpcnN0IHJldHVybnMgZmFsc2UuXG4gICAgICAgIHN0YXRlLnN1cHByZXNzRGlzcG9zYWxVbnRpbERpc3Bvc2VXaGVuUmV0dXJuc0ZhbHNlID0gdHJ1ZTtcblxuICAgICAgICAvLyBkaXNwb3NlV2hlbk5vZGVJc1JlbW92ZWQ6IHRydWUgY2FuIGJlIHVzZWQgdG8gb3B0IGludG8gdGhlIFwib25seSBkaXNwb3NlIGFmdGVyIGZpcnN0IGZhbHNlIHJlc3VsdFwiXG4gICAgICAgIC8vIGJlaGF2aW91ciBldmVuIGlmIHRoZXJlJ3Mgbm8gc3BlY2lmaWMgbm9kZSB0byB3YXRjaC4gSW4gdGhhdCBjYXNlLCBjbGVhciB0aGUgb3B0aW9uIHNvIHdlIGRvbid0IHRyeVxuICAgICAgICAvLyB0byB3YXRjaCBmb3IgYSBub24tbm9kZSdzIGRpc3Bvc2FsLiBUaGlzIHRlY2huaXF1ZSBpcyBpbnRlbmRlZCBmb3IgS08ncyBpbnRlcm5hbCB1c2Ugb25seSBhbmQgc2hvdWxkbid0XG4gICAgICAgIC8vIGJlIGRvY3VtZW50ZWQgb3IgdXNlZCBieSBhcHBsaWNhdGlvbiBjb2RlLCBhcyBpdCdzIGxpa2VseSB0byBjaGFuZ2UgaW4gYSBmdXR1cmUgdmVyc2lvbiBvZiBLTy5cbiAgICAgICAgaWYgKCFzdGF0ZS5kaXNwb3NlV2hlbk5vZGVJc1JlbW92ZWQubm9kZVR5cGUpIHtcbiAgICAgICAgICAgIHN0YXRlLmRpc3Bvc2VXaGVuTm9kZUlzUmVtb3ZlZCA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBFdmFsdWF0ZSwgdW5sZXNzIHNsZWVwaW5nIG9yIGRlZmVyRXZhbHVhdGlvbiBpcyB0cnVlXG4gICAgaWYgKCFzdGF0ZS5pc1NsZWVwaW5nICYmICFvcHRpb25zWydkZWZlckV2YWx1YXRpb24nXSkge1xuICAgICAgICBjb21wdXRlZE9ic2VydmFibGUuZXZhbHVhdGVJbW1lZGlhdGUoKTtcbiAgICB9XG5cbiAgICAvLyBBdHRhY2ggYSBET00gbm9kZSBkaXNwb3NhbCBjYWxsYmFjayBzbyB0aGF0IHRoZSBjb21wdXRlZCB3aWxsIGJlIHByb2FjdGl2ZWx5IGRpc3Bvc2VkIGFzIHNvb24gYXMgdGhlIG5vZGUgaXNcbiAgICAvLyByZW1vdmVkIHVzaW5nIGtvLnJlbW92ZU5vZGUuIEJ1dCBza2lwIGlmIGlzQWN0aXZlIGlzIGZhbHNlICh0aGVyZSB3aWxsIG5ldmVyIGJlIGFueSBkZXBlbmRlbmNpZXMgdG8gZGlzcG9zZSkuXG4gICAgaWYgKHN0YXRlLmRpc3Bvc2VXaGVuTm9kZUlzUmVtb3ZlZCAmJiBjb21wdXRlZE9ic2VydmFibGUuaXNBY3RpdmUoKSkge1xuICAgICAgICBrby51dGlscy5kb21Ob2RlRGlzcG9zYWwuYWRkRGlzcG9zZUNhbGxiYWNrKHN0YXRlLmRpc3Bvc2VXaGVuTm9kZUlzUmVtb3ZlZCwgc3RhdGUuZG9tTm9kZURpc3Bvc2FsQ2FsbGJhY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBjb21wdXRlZE9ic2VydmFibGUuZGlzcG9zZSgpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gY29tcHV0ZWRPYnNlcnZhYmxlO1xufTtcblxuLy8gVXRpbGl0eSBmdW5jdGlvbiB0aGF0IGRpc3Bvc2VzIGEgZ2l2ZW4gZGVwZW5kZW5jeVRyYWNraW5nIGVudHJ5XG5mdW5jdGlvbiBjb21wdXRlZERpc3Bvc2VEZXBlbmRlbmN5Q2FsbGJhY2soaWQsIGVudHJ5VG9EaXNwb3NlKSB7XG4gICAgaWYgKGVudHJ5VG9EaXNwb3NlICE9PSBudWxsICYmIGVudHJ5VG9EaXNwb3NlLmRpc3Bvc2UpIHtcbiAgICAgICAgZW50cnlUb0Rpc3Bvc2UuZGlzcG9zZSgpO1xuICAgIH1cbn1cblxuLy8gVGhpcyBmdW5jdGlvbiBnZXRzIGNhbGxlZCBlYWNoIHRpbWUgYSBkZXBlbmRlbmN5IGlzIGRldGVjdGVkIHdoaWxlIGV2YWx1YXRpbmcgYSBjb21wdXRlZC5cbi8vIEl0J3MgZmFjdG9yZWQgb3V0IGFzIGEgc2hhcmVkIGZ1bmN0aW9uIHRvIGF2b2lkIGNyZWF0aW5nIHVubmVjZXNzYXJ5IGZ1bmN0aW9uIGluc3RhbmNlcyBkdXJpbmcgZXZhbHVhdGlvbi5cbmZ1bmN0aW9uIGNvbXB1dGVkQmVnaW5EZXBlbmRlbmN5RGV0ZWN0aW9uQ2FsbGJhY2soc3Vic2NyaWJhYmxlLCBpZCkge1xuICAgIHZhciBjb21wdXRlZE9ic2VydmFibGUgPSB0aGlzLmNvbXB1dGVkT2JzZXJ2YWJsZSxcbiAgICAgICAgc3RhdGUgPSBjb21wdXRlZE9ic2VydmFibGVbY29tcHV0ZWRTdGF0ZV07XG4gICAgaWYgKCFzdGF0ZS5pc0Rpc3Bvc2VkKSB7XG4gICAgICAgIGlmICh0aGlzLmRpc3Bvc2FsQ291bnQgJiYgdGhpcy5kaXNwb3NhbENhbmRpZGF0ZXNbaWRdKSB7XG4gICAgICAgICAgICAvLyBEb24ndCB3YW50IHRvIGRpc3Bvc2UgdGhpcyBzdWJzY3JpcHRpb24sIGFzIGl0J3Mgc3RpbGwgYmVpbmcgdXNlZFxuICAgICAgICAgICAgY29tcHV0ZWRPYnNlcnZhYmxlLmFkZERlcGVuZGVuY3lUcmFja2luZyhpZCwgc3Vic2NyaWJhYmxlLCB0aGlzLmRpc3Bvc2FsQ2FuZGlkYXRlc1tpZF0pO1xuICAgICAgICAgICAgdGhpcy5kaXNwb3NhbENhbmRpZGF0ZXNbaWRdID0gbnVsbDsgLy8gTm8gbmVlZCB0byBhY3R1YWxseSBkZWxldGUgdGhlIHByb3BlcnR5IC0gZGlzcG9zYWxDYW5kaWRhdGVzIGlzIGEgdHJhbnNpZW50IG9iamVjdCBhbnl3YXlcbiAgICAgICAgICAgIC0tdGhpcy5kaXNwb3NhbENvdW50O1xuICAgICAgICB9IGVsc2UgaWYgKCFzdGF0ZS5kZXBlbmRlbmN5VHJhY2tpbmdbaWRdKSB7XG4gICAgICAgICAgICAvLyBCcmFuZCBuZXcgc3Vic2NyaXB0aW9uIC0gYWRkIGl0XG4gICAgICAgICAgICBjb21wdXRlZE9ic2VydmFibGUuYWRkRGVwZW5kZW5jeVRyYWNraW5nKGlkLCBzdWJzY3JpYmFibGUsIHN0YXRlLmlzU2xlZXBpbmcgPyB7IF90YXJnZXQ6IHN1YnNjcmliYWJsZSB9IDogY29tcHV0ZWRPYnNlcnZhYmxlLnN1YnNjcmliZVRvRGVwZW5kZW5jeShzdWJzY3JpYmFibGUpKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxudmFyIGNvbXB1dGVkRm4gPSB7XG4gICAgXCJlcXVhbGl0eUNvbXBhcmVyXCI6IHZhbHVlc0FyZVByaW1pdGl2ZUFuZEVxdWFsLFxuICAgIGdldERlcGVuZGVuY2llc0NvdW50OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzW2NvbXB1dGVkU3RhdGVdLmRlcGVuZGVuY2llc0NvdW50O1xuICAgIH0sXG4gICAgYWRkRGVwZW5kZW5jeVRyYWNraW5nOiBmdW5jdGlvbiAoaWQsIHRhcmdldCwgdHJhY2tpbmdPYmopIHtcbiAgICAgICAgaWYgKHRoaXNbY29tcHV0ZWRTdGF0ZV0ucHVyZSAmJiB0YXJnZXQgPT09IHRoaXMpIHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKFwiQSAncHVyZScgY29tcHV0ZWQgbXVzdCBub3QgYmUgY2FsbGVkIHJlY3Vyc2l2ZWx5XCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpc1tjb21wdXRlZFN0YXRlXS5kZXBlbmRlbmN5VHJhY2tpbmdbaWRdID0gdHJhY2tpbmdPYmo7XG4gICAgICAgIHRyYWNraW5nT2JqLl9vcmRlciA9IHRoaXNbY29tcHV0ZWRTdGF0ZV0uZGVwZW5kZW5jaWVzQ291bnQrKztcbiAgICAgICAgdHJhY2tpbmdPYmouX3ZlcnNpb24gPSB0YXJnZXQuZ2V0VmVyc2lvbigpO1xuICAgIH0sXG4gICAgaGF2ZURlcGVuZGVuY2llc0NoYW5nZWQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGlkLCBkZXBlbmRlbmN5LCBkZXBlbmRlbmN5VHJhY2tpbmcgPSB0aGlzW2NvbXB1dGVkU3RhdGVdLmRlcGVuZGVuY3lUcmFja2luZztcbiAgICAgICAgZm9yIChpZCBpbiBkZXBlbmRlbmN5VHJhY2tpbmcpIHtcbiAgICAgICAgICAgIGlmIChkZXBlbmRlbmN5VHJhY2tpbmcuaGFzT3duUHJvcGVydHkoaWQpKSB7XG4gICAgICAgICAgICAgICAgZGVwZW5kZW5jeSA9IGRlcGVuZGVuY3lUcmFja2luZ1tpZF07XG4gICAgICAgICAgICAgICAgaWYgKGRlcGVuZGVuY3kuX3RhcmdldC5oYXNDaGFuZ2VkKGRlcGVuZGVuY3kuX3ZlcnNpb24pKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG4gICAgbWFya0RpcnR5OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIFByb2Nlc3MgXCJkaXJ0eVwiIGV2ZW50cyBpZiB3ZSBjYW4gaGFuZGxlIGRlbGF5ZWQgbm90aWZpY2F0aW9uc1xuICAgICAgICBpZiAodGhpcy5fZXZhbERlbGF5ZWQgJiYgIXRoaXNbY29tcHV0ZWRTdGF0ZV0uaXNCZWluZ0V2YWx1YXRlZCkge1xuICAgICAgICAgICAgdGhpcy5fZXZhbERlbGF5ZWQoKTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgaXNBY3RpdmU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXNbY29tcHV0ZWRTdGF0ZV0uaXNTdGFsZSB8fCB0aGlzW2NvbXB1dGVkU3RhdGVdLmRlcGVuZGVuY2llc0NvdW50ID4gMDtcbiAgICB9LFxuICAgIHJlc3BvbmRUb0NoYW5nZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBJZ25vcmUgXCJjaGFuZ2VcIiBldmVudHMgaWYgd2UndmUgYWxyZWFkeSBzY2hlZHVsZWQgYSBkZWxheWVkIG5vdGlmaWNhdGlvblxuICAgICAgICBpZiAoIXRoaXMuX25vdGlmaWNhdGlvbklzUGVuZGluZykge1xuICAgICAgICAgICAgdGhpcy5ldmFsdWF0ZVBvc3NpYmx5QXN5bmMoKTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgc3Vic2NyaWJlVG9EZXBlbmRlbmN5OiBmdW5jdGlvbiAodGFyZ2V0KSB7XG4gICAgICAgIGlmICh0YXJnZXQuX2RlZmVyVXBkYXRlcyAmJiAhdGhpc1tjb21wdXRlZFN0YXRlXS5kaXNwb3NlV2hlbk5vZGVJc1JlbW92ZWQpIHtcbiAgICAgICAgICAgIHZhciBkaXJ0eVN1YiA9IHRhcmdldC5zdWJzY3JpYmUodGhpcy5tYXJrRGlydHksIHRoaXMsICdkaXJ0eScpLFxuICAgICAgICAgICAgICAgIGNoYW5nZVN1YiA9IHRhcmdldC5zdWJzY3JpYmUodGhpcy5yZXNwb25kVG9DaGFuZ2UsIHRoaXMpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBfdGFyZ2V0OiB0YXJnZXQsXG4gICAgICAgICAgICAgICAgZGlzcG9zZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBkaXJ0eVN1Yi5kaXNwb3NlKCk7XG4gICAgICAgICAgICAgICAgICAgIGNoYW5nZVN1Yi5kaXNwb3NlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0YXJnZXQuc3Vic2NyaWJlKHRoaXMuZXZhbHVhdGVQb3NzaWJseUFzeW5jLCB0aGlzKTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgZXZhbHVhdGVQb3NzaWJseUFzeW5jOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBjb21wdXRlZE9ic2VydmFibGUgPSB0aGlzLFxuICAgICAgICAgICAgdGhyb3R0bGVFdmFsdWF0aW9uVGltZW91dCA9IGNvbXB1dGVkT2JzZXJ2YWJsZVsndGhyb3R0bGVFdmFsdWF0aW9uJ107XG4gICAgICAgIGlmICh0aHJvdHRsZUV2YWx1YXRpb25UaW1lb3V0ICYmIHRocm90dGxlRXZhbHVhdGlvblRpbWVvdXQgPj0gMCkge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXNbY29tcHV0ZWRTdGF0ZV0uZXZhbHVhdGlvblRpbWVvdXRJbnN0YW5jZSk7XG4gICAgICAgICAgICB0aGlzW2NvbXB1dGVkU3RhdGVdLmV2YWx1YXRpb25UaW1lb3V0SW5zdGFuY2UgPSBrby51dGlscy5zZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBjb21wdXRlZE9ic2VydmFibGUuZXZhbHVhdGVJbW1lZGlhdGUodHJ1ZSAvKm5vdGlmeUNoYW5nZSovKTtcbiAgICAgICAgICAgIH0sIHRocm90dGxlRXZhbHVhdGlvblRpbWVvdXQpO1xuICAgICAgICB9IGVsc2UgaWYgKGNvbXB1dGVkT2JzZXJ2YWJsZS5fZXZhbERlbGF5ZWQpIHtcbiAgICAgICAgICAgIGNvbXB1dGVkT2JzZXJ2YWJsZS5fZXZhbERlbGF5ZWQoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbXB1dGVkT2JzZXJ2YWJsZS5ldmFsdWF0ZUltbWVkaWF0ZSh0cnVlIC8qbm90aWZ5Q2hhbmdlKi8pO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBldmFsdWF0ZUltbWVkaWF0ZTogZnVuY3Rpb24gKG5vdGlmeUNoYW5nZSkge1xuICAgICAgICB2YXIgY29tcHV0ZWRPYnNlcnZhYmxlID0gdGhpcyxcbiAgICAgICAgICAgIHN0YXRlID0gY29tcHV0ZWRPYnNlcnZhYmxlW2NvbXB1dGVkU3RhdGVdLFxuICAgICAgICAgICAgZGlzcG9zZVdoZW4gPSBzdGF0ZS5kaXNwb3NlV2hlbixcbiAgICAgICAgICAgIGNoYW5nZWQgPSBmYWxzZTtcblxuICAgICAgICBpZiAoc3RhdGUuaXNCZWluZ0V2YWx1YXRlZCkge1xuICAgICAgICAgICAgLy8gSWYgdGhlIGV2YWx1YXRpb24gb2YgYSBrby5jb21wdXRlZCBjYXVzZXMgc2lkZSBlZmZlY3RzLCBpdCdzIHBvc3NpYmxlIHRoYXQgaXQgd2lsbCB0cmlnZ2VyIGl0cyBvd24gcmUtZXZhbHVhdGlvbi5cbiAgICAgICAgICAgIC8vIFRoaXMgaXMgbm90IGRlc2lyYWJsZSAoaXQncyBoYXJkIGZvciBhIGRldmVsb3BlciB0byByZWFsaXNlIGEgY2hhaW4gb2YgZGVwZW5kZW5jaWVzIG1pZ2h0IGNhdXNlIHRoaXMsIGFuZCB0aGV5IGFsbW9zdFxuICAgICAgICAgICAgLy8gY2VydGFpbmx5IGRpZG4ndCBpbnRlbmQgaW5maW5pdGUgcmUtZXZhbHVhdGlvbnMpLiBTbywgZm9yIHByZWRpY3RhYmlsaXR5LCB3ZSBzaW1wbHkgcHJldmVudCBrby5jb21wdXRlZHMgZnJvbSBjYXVzaW5nXG4gICAgICAgICAgICAvLyB0aGVpciBvd24gcmUtZXZhbHVhdGlvbi4gRnVydGhlciBkaXNjdXNzaW9uIGF0IGh0dHBzOi8vZ2l0aHViLmNvbS9TdGV2ZVNhbmRlcnNvbi9rbm9ja291dC9wdWxsLzM4N1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRG8gbm90IGV2YWx1YXRlIChhbmQgcG9zc2libHkgY2FwdHVyZSBuZXcgZGVwZW5kZW5jaWVzKSBpZiBkaXNwb3NlZFxuICAgICAgICBpZiAoc3RhdGUuaXNEaXNwb3NlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHN0YXRlLmRpc3Bvc2VXaGVuTm9kZUlzUmVtb3ZlZCAmJiAha28udXRpbHMuZG9tTm9kZUlzQXR0YWNoZWRUb0RvY3VtZW50KHN0YXRlLmRpc3Bvc2VXaGVuTm9kZUlzUmVtb3ZlZCkgfHwgZGlzcG9zZVdoZW4gJiYgZGlzcG9zZVdoZW4oKSkge1xuICAgICAgICAgICAgLy8gU2VlIGNvbW1lbnQgYWJvdmUgYWJvdXQgc3VwcHJlc3NEaXNwb3NhbFVudGlsRGlzcG9zZVdoZW5SZXR1cm5zRmFsc2VcbiAgICAgICAgICAgIGlmICghc3RhdGUuc3VwcHJlc3NEaXNwb3NhbFVudGlsRGlzcG9zZVdoZW5SZXR1cm5zRmFsc2UpIHtcbiAgICAgICAgICAgICAgICBjb21wdXRlZE9ic2VydmFibGUuZGlzcG9zZSgpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIEl0IGp1c3QgZGlkIHJldHVybiBmYWxzZSwgc28gd2UgY2FuIHN0b3Agc3VwcHJlc3Npbmcgbm93XG4gICAgICAgICAgICBzdGF0ZS5zdXBwcmVzc0Rpc3Bvc2FsVW50aWxEaXNwb3NlV2hlblJldHVybnNGYWxzZSA9IGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgc3RhdGUuaXNCZWluZ0V2YWx1YXRlZCA9IHRydWU7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjaGFuZ2VkID0gdGhpcy5ldmFsdWF0ZUltbWVkaWF0ZV9DYWxsUmVhZFdpdGhEZXBlbmRlbmN5RGV0ZWN0aW9uKG5vdGlmeUNoYW5nZSk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICBzdGF0ZS5pc0JlaW5nRXZhbHVhdGVkID0gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXN0YXRlLmRlcGVuZGVuY2llc0NvdW50KSB7XG4gICAgICAgICAgICBjb21wdXRlZE9ic2VydmFibGUuZGlzcG9zZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNoYW5nZWQ7XG4gICAgfSxcbiAgICBldmFsdWF0ZUltbWVkaWF0ZV9DYWxsUmVhZFdpdGhEZXBlbmRlbmN5RGV0ZWN0aW9uOiBmdW5jdGlvbiAobm90aWZ5Q2hhbmdlKSB7XG4gICAgICAgIC8vIFRoaXMgZnVuY3Rpb24gaXMgcmVhbGx5IGp1c3QgcGFydCBvZiB0aGUgZXZhbHVhdGVJbW1lZGlhdGUgbG9naWMuIFlvdSB3b3VsZCBuZXZlciBjYWxsIGl0IGZyb20gYW55d2hlcmUgZWxzZS5cbiAgICAgICAgLy8gRmFjdG9yaW5nIGl0IG91dCBpbnRvIGEgc2VwYXJhdGUgZnVuY3Rpb24gbWVhbnMgaXQgY2FuIGJlIGluZGVwZW5kZW50IG9mIHRoZSB0cnkvY2F0Y2ggYmxvY2sgaW4gZXZhbHVhdGVJbW1lZGlhdGUsXG4gICAgICAgIC8vIHdoaWNoIGNvbnRyaWJ1dGVzIHRvIHNhdmluZyBhYm91dCA0MCUgb2ZmIHRoZSBDUFUgb3ZlcmhlYWQgb2YgY29tcHV0ZWQgZXZhbHVhdGlvbiAob24gVjggYXQgbGVhc3QpLlxuXG4gICAgICAgIHZhciBjb21wdXRlZE9ic2VydmFibGUgPSB0aGlzLFxuICAgICAgICAgICAgc3RhdGUgPSBjb21wdXRlZE9ic2VydmFibGVbY29tcHV0ZWRTdGF0ZV0sXG4gICAgICAgICAgICBjaGFuZ2VkID0gZmFsc2U7XG5cbiAgICAgICAgLy8gSW5pdGlhbGx5LCB3ZSBhc3N1bWUgdGhhdCBub25lIG9mIHRoZSBzdWJzY3JpcHRpb25zIGFyZSBzdGlsbCBiZWluZyB1c2VkIChpLmUuLCBhbGwgYXJlIGNhbmRpZGF0ZXMgZm9yIGRpc3Bvc2FsKS5cbiAgICAgICAgLy8gVGhlbiwgZHVyaW5nIGV2YWx1YXRpb24sIHdlIGNyb3NzIG9mZiBhbnkgdGhhdCBhcmUgaW4gZmFjdCBzdGlsbCBiZWluZyB1c2VkLlxuICAgICAgICB2YXIgaXNJbml0aWFsID0gc3RhdGUucHVyZSA/IHVuZGVmaW5lZCA6ICFzdGF0ZS5kZXBlbmRlbmNpZXNDb3VudCwgICAvLyBJZiB3ZSdyZSBldmFsdWF0aW5nIHdoZW4gdGhlcmUgYXJlIG5vIHByZXZpb3VzIGRlcGVuZGVuY2llcywgaXQgbXVzdCBiZSB0aGUgZmlyc3QgdGltZVxuICAgICAgICAgICAgZGVwZW5kZW5jeURldGVjdGlvbkNvbnRleHQgPSB7XG4gICAgICAgICAgICAgICAgY29tcHV0ZWRPYnNlcnZhYmxlOiBjb21wdXRlZE9ic2VydmFibGUsXG4gICAgICAgICAgICAgICAgZGlzcG9zYWxDYW5kaWRhdGVzOiBzdGF0ZS5kZXBlbmRlbmN5VHJhY2tpbmcsXG4gICAgICAgICAgICAgICAgZGlzcG9zYWxDb3VudDogc3RhdGUuZGVwZW5kZW5jaWVzQ291bnRcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAga28uZGVwZW5kZW5jeURldGVjdGlvbi5iZWdpbih7XG4gICAgICAgICAgICBjYWxsYmFja1RhcmdldDogZGVwZW5kZW5jeURldGVjdGlvbkNvbnRleHQsXG4gICAgICAgICAgICBjYWxsYmFjazogY29tcHV0ZWRCZWdpbkRlcGVuZGVuY3lEZXRlY3Rpb25DYWxsYmFjayxcbiAgICAgICAgICAgIGNvbXB1dGVkOiBjb21wdXRlZE9ic2VydmFibGUsXG4gICAgICAgICAgICBpc0luaXRpYWw6IGlzSW5pdGlhbFxuICAgICAgICB9KTtcblxuICAgICAgICBzdGF0ZS5kZXBlbmRlbmN5VHJhY2tpbmcgPSB7fTtcbiAgICAgICAgc3RhdGUuZGVwZW5kZW5jaWVzQ291bnQgPSAwO1xuXG4gICAgICAgIHZhciBuZXdWYWx1ZSA9IHRoaXMuZXZhbHVhdGVJbW1lZGlhdGVfQ2FsbFJlYWRUaGVuRW5kRGVwZW5kZW5jeURldGVjdGlvbihzdGF0ZSwgZGVwZW5kZW5jeURldGVjdGlvbkNvbnRleHQpO1xuXG4gICAgICAgIGlmIChjb21wdXRlZE9ic2VydmFibGUuaXNEaWZmZXJlbnQoc3RhdGUubGF0ZXN0VmFsdWUsIG5ld1ZhbHVlKSkge1xuICAgICAgICAgICAgaWYgKCFzdGF0ZS5pc1NsZWVwaW5nKSB7XG4gICAgICAgICAgICAgICAgY29tcHV0ZWRPYnNlcnZhYmxlW1wibm90aWZ5U3Vic2NyaWJlcnNcIl0oc3RhdGUubGF0ZXN0VmFsdWUsIFwiYmVmb3JlQ2hhbmdlXCIpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzdGF0ZS5sYXRlc3RWYWx1ZSA9IG5ld1ZhbHVlO1xuICAgICAgICAgICAgaWYgKERFQlVHKSBjb21wdXRlZE9ic2VydmFibGUuX2xhdGVzdFZhbHVlID0gbmV3VmFsdWU7XG5cbiAgICAgICAgICAgIGlmIChzdGF0ZS5pc1NsZWVwaW5nKSB7XG4gICAgICAgICAgICAgICAgY29tcHV0ZWRPYnNlcnZhYmxlLnVwZGF0ZVZlcnNpb24oKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobm90aWZ5Q2hhbmdlKSB7XG4gICAgICAgICAgICAgICAgY29tcHV0ZWRPYnNlcnZhYmxlW1wibm90aWZ5U3Vic2NyaWJlcnNcIl0oc3RhdGUubGF0ZXN0VmFsdWUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc0luaXRpYWwpIHtcbiAgICAgICAgICAgIGNvbXB1dGVkT2JzZXJ2YWJsZVtcIm5vdGlmeVN1YnNjcmliZXJzXCJdKHN0YXRlLmxhdGVzdFZhbHVlLCBcImF3YWtlXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNoYW5nZWQ7XG4gICAgfSxcbiAgICBldmFsdWF0ZUltbWVkaWF0ZV9DYWxsUmVhZFRoZW5FbmREZXBlbmRlbmN5RGV0ZWN0aW9uOiBmdW5jdGlvbiAoc3RhdGUsIGRlcGVuZGVuY3lEZXRlY3Rpb25Db250ZXh0KSB7XG4gICAgICAgIC8vIFRoaXMgZnVuY3Rpb24gaXMgcmVhbGx5IHBhcnQgb2YgdGhlIGV2YWx1YXRlSW1tZWRpYXRlX0NhbGxSZWFkV2l0aERlcGVuZGVuY3lEZXRlY3Rpb24gbG9naWMuXG4gICAgICAgIC8vIFlvdSdkIG5ldmVyIGNhbGwgaXQgZnJvbSBhbnl3aGVyZSBlbHNlLiBGYWN0b3JpbmcgaXQgb3V0IG1lYW5zIHRoYXQgZXZhbHVhdGVJbW1lZGlhdGVfQ2FsbFJlYWRXaXRoRGVwZW5kZW5jeURldGVjdGlvblxuICAgICAgICAvLyBjYW4gYmUgaW5kZXBlbmRlbnQgb2YgdHJ5L2ZpbmFsbHkgYmxvY2tzLCB3aGljaCBjb250cmlidXRlcyB0byBzYXZpbmcgYWJvdXQgNDAlIG9mZiB0aGUgQ1BVXG4gICAgICAgIC8vIG92ZXJoZWFkIG9mIGNvbXB1dGVkIGV2YWx1YXRpb24gKG9uIFY4IGF0IGxlYXN0KS5cblxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdmFyIHJlYWRGdW5jdGlvbiA9IHN0YXRlLnJlYWRGdW5jdGlvbjtcbiAgICAgICAgICAgIHJldHVybiBzdGF0ZS5ldmFsdWF0b3JGdW5jdGlvblRhcmdldCA/IHJlYWRGdW5jdGlvbi5jYWxsKHN0YXRlLmV2YWx1YXRvckZ1bmN0aW9uVGFyZ2V0KSA6IHJlYWRGdW5jdGlvbigpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAga28uZGVwZW5kZW5jeURldGVjdGlvbi5lbmQoKTtcblxuICAgICAgICAgICAgLy8gRm9yIGVhY2ggc3Vic2NyaXB0aW9uIG5vIGxvbmdlciBiZWluZyB1c2VkLCByZW1vdmUgaXQgZnJvbSB0aGUgYWN0aXZlIHN1YnNjcmlwdGlvbnMgbGlzdCBhbmQgZGlzcG9zZSBpdFxuICAgICAgICAgICAgaWYgKGRlcGVuZGVuY3lEZXRlY3Rpb25Db250ZXh0LmRpc3Bvc2FsQ291bnQgJiYgIXN0YXRlLmlzU2xlZXBpbmcpIHtcbiAgICAgICAgICAgICAgICBrby51dGlscy5vYmplY3RGb3JFYWNoKGRlcGVuZGVuY3lEZXRlY3Rpb25Db250ZXh0LmRpc3Bvc2FsQ2FuZGlkYXRlcywgY29tcHV0ZWREaXNwb3NlRGVwZW5kZW5jeUNhbGxiYWNrKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgc3RhdGUuaXNTdGFsZSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBwZWVrOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIFBlZWsgd29uJ3QgcmUtZXZhbHVhdGUsIGV4Y2VwdCB3aGlsZSB0aGUgY29tcHV0ZWQgaXMgc2xlZXBpbmcgb3IgdG8gZ2V0IHRoZSBpbml0aWFsIHZhbHVlIHdoZW4gXCJkZWZlckV2YWx1YXRpb25cIiBpcyBzZXQuXG4gICAgICAgIHZhciBzdGF0ZSA9IHRoaXNbY29tcHV0ZWRTdGF0ZV07XG4gICAgICAgIGlmICgoc3RhdGUuaXNTdGFsZSAmJiAhc3RhdGUuZGVwZW5kZW5jaWVzQ291bnQpIHx8IChzdGF0ZS5pc1NsZWVwaW5nICYmIHRoaXMuaGF2ZURlcGVuZGVuY2llc0NoYW5nZWQoKSkpIHtcbiAgICAgICAgICAgIHRoaXMuZXZhbHVhdGVJbW1lZGlhdGUoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3RhdGUubGF0ZXN0VmFsdWU7XG4gICAgfSxcbiAgICBsaW1pdDogZnVuY3Rpb24gKGxpbWl0RnVuY3Rpb24pIHtcbiAgICAgICAgLy8gT3ZlcnJpZGUgdGhlIGxpbWl0IGZ1bmN0aW9uIHdpdGggb25lIHRoYXQgZGVsYXlzIGV2YWx1YXRpb24gYXMgd2VsbFxuICAgICAgICBrby5zdWJzY3JpYmFibGVbJ2ZuJ10ubGltaXQuY2FsbCh0aGlzLCBsaW1pdEZ1bmN0aW9uKTtcbiAgICAgICAgdGhpcy5fZXZhbERlbGF5ZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLl9saW1pdEJlZm9yZUNoYW5nZSh0aGlzW2NvbXB1dGVkU3RhdGVdLmxhdGVzdFZhbHVlKTtcblxuICAgICAgICAgICAgdGhpc1tjb21wdXRlZFN0YXRlXS5pc1N0YWxlID0gdHJ1ZTsgLy8gTWFyayBhcyBkaXJ0eVxuXG4gICAgICAgICAgICAvLyBQYXNzIHRoZSBvYnNlcnZhYmxlIHRvIHRoZSBcImxpbWl0XCIgY29kZSwgd2hpY2ggd2lsbCBhY2Nlc3MgaXQgd2hlblxuICAgICAgICAgICAgLy8gaXQncyB0aW1lIHRvIGRvIHRoZSBub3RpZmljYXRpb24uXG4gICAgICAgICAgICB0aGlzLl9saW1pdENoYW5nZSh0aGlzKTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgZGlzcG9zZTogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgc3RhdGUgPSB0aGlzW2NvbXB1dGVkU3RhdGVdO1xuICAgICAgICBpZiAoIXN0YXRlLmlzU2xlZXBpbmcgJiYgc3RhdGUuZGVwZW5kZW5jeVRyYWNraW5nKSB7XG4gICAgICAgICAgICBrby51dGlscy5vYmplY3RGb3JFYWNoKHN0YXRlLmRlcGVuZGVuY3lUcmFja2luZywgZnVuY3Rpb24gKGlkLCBkZXBlbmRlbmN5KSB7XG4gICAgICAgICAgICAgICAgaWYgKGRlcGVuZGVuY3kuZGlzcG9zZSlcbiAgICAgICAgICAgICAgICAgICAgZGVwZW5kZW5jeS5kaXNwb3NlKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhdGUuZGlzcG9zZVdoZW5Ob2RlSXNSZW1vdmVkICYmIHN0YXRlLmRvbU5vZGVEaXNwb3NhbENhbGxiYWNrKSB7XG4gICAgICAgICAgICBrby51dGlscy5kb21Ob2RlRGlzcG9zYWwucmVtb3ZlRGlzcG9zZUNhbGxiYWNrKHN0YXRlLmRpc3Bvc2VXaGVuTm9kZUlzUmVtb3ZlZCwgc3RhdGUuZG9tTm9kZURpc3Bvc2FsQ2FsbGJhY2spO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRlLmRlcGVuZGVuY3lUcmFja2luZyA9IG51bGw7XG4gICAgICAgIHN0YXRlLmRlcGVuZGVuY2llc0NvdW50ID0gMDtcbiAgICAgICAgc3RhdGUuaXNEaXNwb3NlZCA9IHRydWU7XG4gICAgICAgIHN0YXRlLmlzU3RhbGUgPSBmYWxzZTtcbiAgICAgICAgc3RhdGUuaXNTbGVlcGluZyA9IGZhbHNlO1xuICAgICAgICBzdGF0ZS5kaXNwb3NlV2hlbk5vZGVJc1JlbW92ZWQgPSBudWxsO1xuICAgIH1cbn07XG5cbnZhciBwdXJlQ29tcHV0ZWRPdmVycmlkZXMgPSB7XG4gICAgYmVmb3JlU3Vic2NyaXB0aW9uQWRkOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgLy8gSWYgYXNsZWVwLCB3YWtlIHVwIHRoZSBjb21wdXRlZCBieSBzdWJzY3JpYmluZyB0byBhbnkgZGVwZW5kZW5jaWVzLlxuICAgICAgICB2YXIgY29tcHV0ZWRPYnNlcnZhYmxlID0gdGhpcyxcbiAgICAgICAgICAgIHN0YXRlID0gY29tcHV0ZWRPYnNlcnZhYmxlW2NvbXB1dGVkU3RhdGVdO1xuICAgICAgICBpZiAoIXN0YXRlLmlzRGlzcG9zZWQgJiYgc3RhdGUuaXNTbGVlcGluZyAmJiBldmVudCA9PSAnY2hhbmdlJykge1xuICAgICAgICAgICAgc3RhdGUuaXNTbGVlcGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKHN0YXRlLmlzU3RhbGUgfHwgY29tcHV0ZWRPYnNlcnZhYmxlLmhhdmVEZXBlbmRlbmNpZXNDaGFuZ2VkKCkpIHtcbiAgICAgICAgICAgICAgICBzdGF0ZS5kZXBlbmRlbmN5VHJhY2tpbmcgPSBudWxsO1xuICAgICAgICAgICAgICAgIHN0YXRlLmRlcGVuZGVuY2llc0NvdW50ID0gMDtcbiAgICAgICAgICAgICAgICBzdGF0ZS5pc1N0YWxlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBpZiAoY29tcHV0ZWRPYnNlcnZhYmxlLmV2YWx1YXRlSW1tZWRpYXRlKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29tcHV0ZWRPYnNlcnZhYmxlLnVwZGF0ZVZlcnNpb24oKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIEZpcnN0IHB1dCB0aGUgZGVwZW5kZW5jaWVzIGluIG9yZGVyXG4gICAgICAgICAgICAgICAgdmFyIGRlcGVuZGVjaWVzT3JkZXIgPSBbXTtcbiAgICAgICAgICAgICAgICBrby51dGlscy5vYmplY3RGb3JFYWNoKHN0YXRlLmRlcGVuZGVuY3lUcmFja2luZywgZnVuY3Rpb24gKGlkLCBkZXBlbmRlbmN5KSB7XG4gICAgICAgICAgICAgICAgICAgIGRlcGVuZGVjaWVzT3JkZXJbZGVwZW5kZW5jeS5fb3JkZXJdID0gaWQ7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgLy8gTmV4dCwgc3Vic2NyaWJlIHRvIGVhY2ggb25lXG4gICAgICAgICAgICAgICAga28udXRpbHMuYXJyYXlGb3JFYWNoKGRlcGVuZGVjaWVzT3JkZXIsIGZ1bmN0aW9uIChpZCwgb3JkZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRlcGVuZGVuY3kgPSBzdGF0ZS5kZXBlbmRlbmN5VHJhY2tpbmdbaWRdLFxuICAgICAgICAgICAgICAgICAgICAgICAgc3Vic2NyaXB0aW9uID0gY29tcHV0ZWRPYnNlcnZhYmxlLnN1YnNjcmliZVRvRGVwZW5kZW5jeShkZXBlbmRlbmN5Ll90YXJnZXQpO1xuICAgICAgICAgICAgICAgICAgICBzdWJzY3JpcHRpb24uX29yZGVyID0gb3JkZXI7XG4gICAgICAgICAgICAgICAgICAgIHN1YnNjcmlwdGlvbi5fdmVyc2lvbiA9IGRlcGVuZGVuY3kuX3ZlcnNpb247XG4gICAgICAgICAgICAgICAgICAgIHN0YXRlLmRlcGVuZGVuY3lUcmFja2luZ1tpZF0gPSBzdWJzY3JpcHRpb247XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXN0YXRlLmlzRGlzcG9zZWQpIHsgICAgIC8vIHRlc3Qgc2luY2UgZXZhbHVhdGluZyBjb3VsZCB0cmlnZ2VyIGRpc3Bvc2FsXG4gICAgICAgICAgICAgICAgY29tcHV0ZWRPYnNlcnZhYmxlW1wibm90aWZ5U3Vic2NyaWJlcnNcIl0oc3RhdGUubGF0ZXN0VmFsdWUsIFwiYXdha2VcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuICAgIGFmdGVyU3Vic2NyaXB0aW9uUmVtb3ZlOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgdmFyIHN0YXRlID0gdGhpc1tjb21wdXRlZFN0YXRlXTtcbiAgICAgICAgaWYgKCFzdGF0ZS5pc0Rpc3Bvc2VkICYmIGV2ZW50ID09ICdjaGFuZ2UnICYmICF0aGlzLmhhc1N1YnNjcmlwdGlvbnNGb3JFdmVudCgnY2hhbmdlJykpIHtcbiAgICAgICAgICAgIGtvLnV0aWxzLm9iamVjdEZvckVhY2goc3RhdGUuZGVwZW5kZW5jeVRyYWNraW5nLCBmdW5jdGlvbiAoaWQsIGRlcGVuZGVuY3kpIHtcbiAgICAgICAgICAgICAgICBpZiAoZGVwZW5kZW5jeS5kaXNwb3NlKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXRlLmRlcGVuZGVuY3lUcmFja2luZ1tpZF0gPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGFyZ2V0OiBkZXBlbmRlbmN5Ll90YXJnZXQsXG4gICAgICAgICAgICAgICAgICAgICAgICBfb3JkZXI6IGRlcGVuZGVuY3kuX29yZGVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgX3ZlcnNpb246IGRlcGVuZGVuY3kuX3ZlcnNpb25cbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgZGVwZW5kZW5jeS5kaXNwb3NlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBzdGF0ZS5pc1NsZWVwaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXNbXCJub3RpZnlTdWJzY3JpYmVyc1wiXSh1bmRlZmluZWQsIFwiYXNsZWVwXCIpO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBnZXRWZXJzaW9uOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIEJlY2F1c2UgYSBwdXJlIGNvbXB1dGVkIGlzIG5vdCBhdXRvbWF0aWNhbGx5IHVwZGF0ZWQgd2hpbGUgaXQgaXMgc2xlZXBpbmcsIHdlIGNhbid0XG4gICAgICAgIC8vIHNpbXBseSByZXR1cm4gdGhlIHZlcnNpb24gbnVtYmVyLiBJbnN0ZWFkLCB3ZSBjaGVjayBpZiBhbnkgb2YgdGhlIGRlcGVuZGVuY2llcyBoYXZlXG4gICAgICAgIC8vIGNoYW5nZWQgYW5kIGNvbmRpdGlvbmFsbHkgcmUtZXZhbHVhdGUgdGhlIGNvbXB1dGVkIG9ic2VydmFibGUuXG4gICAgICAgIHZhciBzdGF0ZSA9IHRoaXNbY29tcHV0ZWRTdGF0ZV07XG4gICAgICAgIGlmIChzdGF0ZS5pc1NsZWVwaW5nICYmIChzdGF0ZS5pc1N0YWxlIHx8IHRoaXMuaGF2ZURlcGVuZGVuY2llc0NoYW5nZWQoKSkpIHtcbiAgICAgICAgICAgIHRoaXMuZXZhbHVhdGVJbW1lZGlhdGUoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ga28uc3Vic2NyaWJhYmxlWydmbiddLmdldFZlcnNpb24uY2FsbCh0aGlzKTtcbiAgICB9XG59O1xuXG52YXIgZGVmZXJFdmFsdWF0aW9uT3ZlcnJpZGVzID0ge1xuICAgIGJlZm9yZVN1YnNjcmlwdGlvbkFkZDogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIC8vIFRoaXMgd2lsbCBmb3JjZSBhIGNvbXB1dGVkIHdpdGggZGVmZXJFdmFsdWF0aW9uIHRvIGV2YWx1YXRlIHdoZW4gdGhlIGZpcnN0IHN1YnNjcmlwdGlvbiBpcyByZWdpc3RlcmVkLlxuICAgICAgICBpZiAoZXZlbnQgPT0gJ2NoYW5nZScgfHwgZXZlbnQgPT0gJ2JlZm9yZUNoYW5nZScpIHtcbiAgICAgICAgICAgIHRoaXMucGVlaygpO1xuICAgICAgICB9XG4gICAgfVxufTtcblxuLy8gTm90ZSB0aGF0IGZvciBicm93c2VycyB0aGF0IGRvbid0IHN1cHBvcnQgcHJvdG8gYXNzaWdubWVudCwgdGhlXG4vLyBpbmhlcml0YW5jZSBjaGFpbiBpcyBjcmVhdGVkIG1hbnVhbGx5IGluIHRoZSBrby5jb21wdXRlZCBjb25zdHJ1Y3RvclxuaWYgKGtvLnV0aWxzLmNhblNldFByb3RvdHlwZSkge1xuICAgIGtvLnV0aWxzLnNldFByb3RvdHlwZU9mKGNvbXB1dGVkRm4sIGtvLnN1YnNjcmliYWJsZVsnZm4nXSk7XG59XG5cbi8vIFNldCB0aGUgcHJvdG8gY2hhaW4gdmFsdWVzIGZvciBrby5oYXNQcm90b3R5cGVcbnZhciBwcm90b1Byb3AgPSBrby5vYnNlcnZhYmxlLnByb3RvUHJvcGVydHk7IC8vID09IFwiX19rb19wcm90b19fXCJcbmtvLmNvbXB1dGVkW3Byb3RvUHJvcF0gPSBrby5vYnNlcnZhYmxlO1xuY29tcHV0ZWRGbltwcm90b1Byb3BdID0ga28uY29tcHV0ZWQ7XG5cbmtvLmlzQ29tcHV0ZWQgPSBmdW5jdGlvbiAoaW5zdGFuY2UpIHtcbiAgICByZXR1cm4ga28uaGFzUHJvdG90eXBlKGluc3RhbmNlLCBrby5jb21wdXRlZCk7XG59O1xuXG5rby5pc1B1cmVDb21wdXRlZCA9IGZ1bmN0aW9uIChpbnN0YW5jZSkge1xuICAgIHJldHVybiBrby5oYXNQcm90b3R5cGUoaW5zdGFuY2UsIGtvLmNvbXB1dGVkKVxuICAgICAgICAmJiBpbnN0YW5jZVtjb21wdXRlZFN0YXRlXSAmJiBpbnN0YW5jZVtjb21wdXRlZFN0YXRlXS5wdXJlO1xufTtcblxua28uZXhwb3J0U3ltYm9sKCdjb21wdXRlZCcsIGtvLmNvbXB1dGVkKTtcbmtvLmV4cG9ydFN5bWJvbCgnZGVwZW5kZW50T2JzZXJ2YWJsZScsIGtvLmNvbXB1dGVkKTsgICAgLy8gZXhwb3J0IGtvLmRlcGVuZGVudE9ic2VydmFibGUgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5ICgxLngpXG5rby5leHBvcnRTeW1ib2woJ2lzQ29tcHV0ZWQnLCBrby5pc0NvbXB1dGVkKTtcbmtvLmV4cG9ydFN5bWJvbCgnaXNQdXJlQ29tcHV0ZWQnLCBrby5pc1B1cmVDb21wdXRlZCk7XG5rby5leHBvcnRTeW1ib2woJ2NvbXB1dGVkLmZuJywgY29tcHV0ZWRGbik7XG5rby5leHBvcnRQcm9wZXJ0eShjb21wdXRlZEZuLCAncGVlaycsIGNvbXB1dGVkRm4ucGVlayk7XG5rby5leHBvcnRQcm9wZXJ0eShjb21wdXRlZEZuLCAnZGlzcG9zZScsIGNvbXB1dGVkRm4uZGlzcG9zZSk7XG5rby5leHBvcnRQcm9wZXJ0eShjb21wdXRlZEZuLCAnaXNBY3RpdmUnLCBjb21wdXRlZEZuLmlzQWN0aXZlKTtcbmtvLmV4cG9ydFByb3BlcnR5KGNvbXB1dGVkRm4sICdnZXREZXBlbmRlbmNpZXNDb3VudCcsIGNvbXB1dGVkRm4uZ2V0RGVwZW5kZW5jaWVzQ291bnQpO1xuXG5rby5wdXJlQ29tcHV0ZWQgPSBmdW5jdGlvbiAoZXZhbHVhdG9yRnVuY3Rpb25Pck9wdGlvbnMsIGV2YWx1YXRvckZ1bmN0aW9uVGFyZ2V0KSB7XG4gICAgaWYgKHR5cGVvZiBldmFsdWF0b3JGdW5jdGlvbk9yT3B0aW9ucyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4ga28uY29tcHV0ZWQoZXZhbHVhdG9yRnVuY3Rpb25Pck9wdGlvbnMsIGV2YWx1YXRvckZ1bmN0aW9uVGFyZ2V0LCB7J3B1cmUnOnRydWV9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBldmFsdWF0b3JGdW5jdGlvbk9yT3B0aW9ucyA9IGtvLnV0aWxzLmV4dGVuZCh7fSwgZXZhbHVhdG9yRnVuY3Rpb25Pck9wdGlvbnMpOyAgIC8vIG1ha2UgYSBjb3B5IG9mIHRoZSBwYXJhbWV0ZXIgb2JqZWN0XG4gICAgICAgIGV2YWx1YXRvckZ1bmN0aW9uT3JPcHRpb25zWydwdXJlJ10gPSB0cnVlO1xuICAgICAgICByZXR1cm4ga28uY29tcHV0ZWQoZXZhbHVhdG9yRnVuY3Rpb25Pck9wdGlvbnMsIGV2YWx1YXRvckZ1bmN0aW9uVGFyZ2V0KTtcbiAgICB9XG59XG5rby5leHBvcnRTeW1ib2woJ3B1cmVDb21wdXRlZCcsIGtvLnB1cmVDb21wdXRlZCk7XG5cbihmdW5jdGlvbigpIHtcbiAgICB2YXIgbWF4TmVzdGVkT2JzZXJ2YWJsZURlcHRoID0gMTA7IC8vIEVzY2FwZSB0aGUgKHVubGlrZWx5KSBwYXRoYWxvZ2ljYWwgY2FzZSB3aGVyZSBhbiBvYnNlcnZhYmxlJ3MgY3VycmVudCB2YWx1ZSBpcyBpdHNlbGYgKG9yIHNpbWlsYXIgcmVmZXJlbmNlIGN5Y2xlKVxuXG4gICAga28udG9KUyA9IGZ1bmN0aW9uKHJvb3RPYmplY3QpIHtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT0gMClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIldoZW4gY2FsbGluZyBrby50b0pTLCBwYXNzIHRoZSBvYmplY3QgeW91IHdhbnQgdG8gY29udmVydC5cIik7XG5cbiAgICAgICAgLy8gV2UganVzdCB1bndyYXAgZXZlcnl0aGluZyBhdCBldmVyeSBsZXZlbCBpbiB0aGUgb2JqZWN0IGdyYXBoXG4gICAgICAgIHJldHVybiBtYXBKc09iamVjdEdyYXBoKHJvb3RPYmplY3QsIGZ1bmN0aW9uKHZhbHVlVG9NYXApIHtcbiAgICAgICAgICAgIC8vIExvb3AgYmVjYXVzZSBhbiBvYnNlcnZhYmxlJ3MgdmFsdWUgbWlnaHQgaW4gdHVybiBiZSBhbm90aGVyIG9ic2VydmFibGUgd3JhcHBlclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGtvLmlzT2JzZXJ2YWJsZSh2YWx1ZVRvTWFwKSAmJiAoaSA8IG1heE5lc3RlZE9ic2VydmFibGVEZXB0aCk7IGkrKylcbiAgICAgICAgICAgICAgICB2YWx1ZVRvTWFwID0gdmFsdWVUb01hcCgpO1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlVG9NYXA7XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICBrby50b0pTT04gPSBmdW5jdGlvbihyb290T2JqZWN0LCByZXBsYWNlciwgc3BhY2UpIHsgICAgIC8vIHJlcGxhY2VyIGFuZCBzcGFjZSBhcmUgb3B0aW9uYWxcbiAgICAgICAgdmFyIHBsYWluSmF2YVNjcmlwdE9iamVjdCA9IGtvLnRvSlMocm9vdE9iamVjdCk7XG4gICAgICAgIHJldHVybiBrby51dGlscy5zdHJpbmdpZnlKc29uKHBsYWluSmF2YVNjcmlwdE9iamVjdCwgcmVwbGFjZXIsIHNwYWNlKTtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gbWFwSnNPYmplY3RHcmFwaChyb290T2JqZWN0LCBtYXBJbnB1dENhbGxiYWNrLCB2aXNpdGVkT2JqZWN0cykge1xuICAgICAgICB2aXNpdGVkT2JqZWN0cyA9IHZpc2l0ZWRPYmplY3RzIHx8IG5ldyBvYmplY3RMb29rdXAoKTtcblxuICAgICAgICByb290T2JqZWN0ID0gbWFwSW5wdXRDYWxsYmFjayhyb290T2JqZWN0KTtcbiAgICAgICAgdmFyIGNhbkhhdmVQcm9wZXJ0aWVzID0gKHR5cGVvZiByb290T2JqZWN0ID09IFwib2JqZWN0XCIpICYmIChyb290T2JqZWN0ICE9PSBudWxsKSAmJiAocm9vdE9iamVjdCAhPT0gdW5kZWZpbmVkKSAmJiAoIShyb290T2JqZWN0IGluc3RhbmNlb2YgUmVnRXhwKSkgJiYgKCEocm9vdE9iamVjdCBpbnN0YW5jZW9mIERhdGUpKSAmJiAoIShyb290T2JqZWN0IGluc3RhbmNlb2YgU3RyaW5nKSkgJiYgKCEocm9vdE9iamVjdCBpbnN0YW5jZW9mIE51bWJlcikpICYmICghKHJvb3RPYmplY3QgaW5zdGFuY2VvZiBCb29sZWFuKSk7XG4gICAgICAgIGlmICghY2FuSGF2ZVByb3BlcnRpZXMpXG4gICAgICAgICAgICByZXR1cm4gcm9vdE9iamVjdDtcblxuICAgICAgICB2YXIgb3V0cHV0UHJvcGVydGllcyA9IHJvb3RPYmplY3QgaW5zdGFuY2VvZiBBcnJheSA/IFtdIDoge307XG4gICAgICAgIHZpc2l0ZWRPYmplY3RzLnNhdmUocm9vdE9iamVjdCwgb3V0cHV0UHJvcGVydGllcyk7XG5cbiAgICAgICAgdmlzaXRQcm9wZXJ0aWVzT3JBcnJheUVudHJpZXMocm9vdE9iamVjdCwgZnVuY3Rpb24oaW5kZXhlcikge1xuICAgICAgICAgICAgdmFyIHByb3BlcnR5VmFsdWUgPSBtYXBJbnB1dENhbGxiYWNrKHJvb3RPYmplY3RbaW5kZXhlcl0pO1xuXG4gICAgICAgICAgICBzd2l0Y2ggKHR5cGVvZiBwcm9wZXJ0eVZhbHVlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBcImJvb2xlYW5cIjpcbiAgICAgICAgICAgICAgICBjYXNlIFwibnVtYmVyXCI6XG4gICAgICAgICAgICAgICAgY2FzZSBcInN0cmluZ1wiOlxuICAgICAgICAgICAgICAgIGNhc2UgXCJmdW5jdGlvblwiOlxuICAgICAgICAgICAgICAgICAgICBvdXRwdXRQcm9wZXJ0aWVzW2luZGV4ZXJdID0gcHJvcGVydHlWYWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcIm9iamVjdFwiOlxuICAgICAgICAgICAgICAgIGNhc2UgXCJ1bmRlZmluZWRcIjpcbiAgICAgICAgICAgICAgICAgICAgdmFyIHByZXZpb3VzbHlNYXBwZWRWYWx1ZSA9IHZpc2l0ZWRPYmplY3RzLmdldChwcm9wZXJ0eVZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0UHJvcGVydGllc1tpbmRleGVyXSA9IChwcmV2aW91c2x5TWFwcGVkVmFsdWUgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICAgICAgICAgID8gcHJldmlvdXNseU1hcHBlZFZhbHVlXG4gICAgICAgICAgICAgICAgICAgICAgICA6IG1hcEpzT2JqZWN0R3JhcGgocHJvcGVydHlWYWx1ZSwgbWFwSW5wdXRDYWxsYmFjaywgdmlzaXRlZE9iamVjdHMpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIG91dHB1dFByb3BlcnRpZXM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdmlzaXRQcm9wZXJ0aWVzT3JBcnJheUVudHJpZXMocm9vdE9iamVjdCwgdmlzaXRvckNhbGxiYWNrKSB7XG4gICAgICAgIGlmIChyb290T2JqZWN0IGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcm9vdE9iamVjdC5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgICAgICB2aXNpdG9yQ2FsbGJhY2soaSk7XG5cbiAgICAgICAgICAgIC8vIEZvciBhcnJheXMsIGFsc28gcmVzcGVjdCB0b0pTT04gcHJvcGVydHkgZm9yIGN1c3RvbSBtYXBwaW5ncyAoZml4ZXMgIzI3OClcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygcm9vdE9iamVjdFsndG9KU09OJ10gPT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgICAgICAgICB2aXNpdG9yQ2FsbGJhY2soJ3RvSlNPTicpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZm9yICh2YXIgcHJvcGVydHlOYW1lIGluIHJvb3RPYmplY3QpIHtcbiAgICAgICAgICAgICAgICB2aXNpdG9yQ2FsbGJhY2socHJvcGVydHlOYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBmdW5jdGlvbiBvYmplY3RMb29rdXAoKSB7XG4gICAgICAgIHRoaXMua2V5cyA9IFtdO1xuICAgICAgICB0aGlzLnZhbHVlcyA9IFtdO1xuICAgIH07XG5cbiAgICBvYmplY3RMb29rdXAucHJvdG90eXBlID0ge1xuICAgICAgICBjb25zdHJ1Y3Rvcjogb2JqZWN0TG9va3VwLFxuICAgICAgICBzYXZlOiBmdW5jdGlvbihrZXksIHZhbHVlKSB7XG4gICAgICAgICAgICB2YXIgZXhpc3RpbmdJbmRleCA9IGtvLnV0aWxzLmFycmF5SW5kZXhPZih0aGlzLmtleXMsIGtleSk7XG4gICAgICAgICAgICBpZiAoZXhpc3RpbmdJbmRleCA+PSAwKVxuICAgICAgICAgICAgICAgIHRoaXMudmFsdWVzW2V4aXN0aW5nSW5kZXhdID0gdmFsdWU7XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmtleXMucHVzaChrZXkpO1xuICAgICAgICAgICAgICAgIHRoaXMudmFsdWVzLnB1c2godmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBnZXQ6IGZ1bmN0aW9uKGtleSkge1xuICAgICAgICAgICAgdmFyIGV4aXN0aW5nSW5kZXggPSBrby51dGlscy5hcnJheUluZGV4T2YodGhpcy5rZXlzLCBrZXkpO1xuICAgICAgICAgICAgcmV0dXJuIChleGlzdGluZ0luZGV4ID49IDApID8gdGhpcy52YWx1ZXNbZXhpc3RpbmdJbmRleF0gOiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICB9O1xufSkoKTtcblxua28uZXhwb3J0U3ltYm9sKCd0b0pTJywga28udG9KUyk7XG5rby5leHBvcnRTeW1ib2woJ3RvSlNPTicsIGtvLnRvSlNPTik7XG4oZnVuY3Rpb24gKCkge1xuICAgIHZhciBoYXNEb21EYXRhRXhwYW5kb1Byb3BlcnR5ID0gJ19fa29fX2hhc0RvbURhdGFPcHRpb25WYWx1ZV9fJztcblxuICAgIC8vIE5vcm1hbGx5LCBTRUxFQ1QgZWxlbWVudHMgYW5kIHRoZWlyIE9QVElPTnMgY2FuIG9ubHkgdGFrZSB2YWx1ZSBvZiB0eXBlICdzdHJpbmcnIChiZWNhdXNlIHRoZSB2YWx1ZXNcbiAgICAvLyBhcmUgc3RvcmVkIG9uIERPTSBhdHRyaWJ1dGVzKS4ga28uc2VsZWN0RXh0ZW5zaW9ucyBwcm92aWRlcyBhIHdheSBmb3IgU0VMRUNUcy9PUFRJT05zIHRvIGhhdmUgdmFsdWVzXG4gICAgLy8gdGhhdCBhcmUgYXJiaXRyYXJ5IG9iamVjdHMuIFRoaXMgaXMgdmVyeSBjb252ZW5pZW50IHdoZW4gaW1wbGVtZW50aW5nIHRoaW5ncyBsaWtlIGNhc2NhZGluZyBkcm9wZG93bnMuXG4gICAga28uc2VsZWN0RXh0ZW5zaW9ucyA9IHtcbiAgICAgICAgcmVhZFZhbHVlIDogZnVuY3Rpb24oZWxlbWVudCkge1xuICAgICAgICAgICAgc3dpdGNoIChrby51dGlscy50YWdOYW1lTG93ZXIoZWxlbWVudCkpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdvcHRpb24nOlxuICAgICAgICAgICAgICAgICAgICBpZiAoZWxlbWVudFtoYXNEb21EYXRhRXhwYW5kb1Byb3BlcnR5XSA9PT0gdHJ1ZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBrby51dGlscy5kb21EYXRhLmdldChlbGVtZW50LCBrby5iaW5kaW5nSGFuZGxlcnMub3B0aW9ucy5vcHRpb25WYWx1ZURvbURhdGFLZXkpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4ga28udXRpbHMuaWVWZXJzaW9uIDw9IDdcbiAgICAgICAgICAgICAgICAgICAgICAgID8gKGVsZW1lbnQuZ2V0QXR0cmlidXRlTm9kZSgndmFsdWUnKSAmJiBlbGVtZW50LmdldEF0dHJpYnV0ZU5vZGUoJ3ZhbHVlJykuc3BlY2lmaWVkID8gZWxlbWVudC52YWx1ZSA6IGVsZW1lbnQudGV4dClcbiAgICAgICAgICAgICAgICAgICAgICAgIDogZWxlbWVudC52YWx1ZTtcbiAgICAgICAgICAgICAgICBjYXNlICdzZWxlY3QnOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZWxlbWVudC5zZWxlY3RlZEluZGV4ID49IDAgPyBrby5zZWxlY3RFeHRlbnNpb25zLnJlYWRWYWx1ZShlbGVtZW50Lm9wdGlvbnNbZWxlbWVudC5zZWxlY3RlZEluZGV4XSkgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVsZW1lbnQudmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgd3JpdGVWYWx1ZTogZnVuY3Rpb24oZWxlbWVudCwgdmFsdWUsIGFsbG93VW5zZXQpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoa28udXRpbHMudGFnTmFtZUxvd2VyKGVsZW1lbnQpKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnb3B0aW9uJzpcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoKHR5cGVvZiB2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcInN0cmluZ1wiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtvLnV0aWxzLmRvbURhdGEuc2V0KGVsZW1lbnQsIGtvLmJpbmRpbmdIYW5kbGVycy5vcHRpb25zLm9wdGlvblZhbHVlRG9tRGF0YUtleSwgdW5kZWZpbmVkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaGFzRG9tRGF0YUV4cGFuZG9Qcm9wZXJ0eSBpbiBlbGVtZW50KSB7IC8vIElFIDw9IDggdGhyb3dzIGVycm9ycyBpZiB5b3UgZGVsZXRlIG5vbi1leGlzdGVudCBwcm9wZXJ0aWVzIGZyb20gYSBET00gbm9kZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgZWxlbWVudFtoYXNEb21EYXRhRXhwYW5kb1Byb3BlcnR5XTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudC52YWx1ZSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTdG9yZSBhcmJpdHJhcnkgb2JqZWN0IHVzaW5nIERvbURhdGFcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBrby51dGlscy5kb21EYXRhLnNldChlbGVtZW50LCBrby5iaW5kaW5nSGFuZGxlcnMub3B0aW9ucy5vcHRpb25WYWx1ZURvbURhdGFLZXksIHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50W2hhc0RvbURhdGFFeHBhbmRvUHJvcGVydHldID0gdHJ1ZTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNwZWNpYWwgdHJlYXRtZW50IG9mIG51bWJlcnMgaXMganVzdCBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eS4gS08gMS4yLjEgd3JvdGUgbnVtZXJpY2FsIHZhbHVlcyB0byBlbGVtZW50LnZhbHVlLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnQudmFsdWUgPSB0eXBlb2YgdmFsdWUgPT09IFwibnVtYmVyXCIgPyB2YWx1ZSA6IFwiXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnc2VsZWN0JzpcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlID09PSBcIlwiIHx8IHZhbHVlID09PSBudWxsKSAgICAgICAvLyBBIGJsYW5rIHN0cmluZyBvciBudWxsIHZhbHVlIHdpbGwgc2VsZWN0IHRoZSBjYXB0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNlbGVjdGlvbiA9IC0xO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbiA9IGVsZW1lbnQub3B0aW9ucy5sZW5ndGgsIG9wdGlvblZhbHVlOyBpIDwgbjsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25WYWx1ZSA9IGtvLnNlbGVjdEV4dGVuc2lvbnMucmVhZFZhbHVlKGVsZW1lbnQub3B0aW9uc1tpXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJbmNsdWRlIHNwZWNpYWwgY2hlY2sgdG8gaGFuZGxlIHNlbGVjdGluZyBhIGNhcHRpb24gd2l0aCBhIGJsYW5rIHN0cmluZyB2YWx1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvblZhbHVlID09IHZhbHVlIHx8IChvcHRpb25WYWx1ZSA9PSBcIlwiICYmIHZhbHVlID09PSB1bmRlZmluZWQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0aW9uID0gaTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoYWxsb3dVbnNldCB8fCBzZWxlY3Rpb24gPj0gMCB8fCAodmFsdWUgPT09IHVuZGVmaW5lZCAmJiBlbGVtZW50LnNpemUgPiAxKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5zZWxlY3RlZEluZGV4ID0gc2VsZWN0aW9uO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGlmICgodmFsdWUgPT09IG51bGwpIHx8ICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gXCJcIjtcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudC52YWx1ZSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG59KSgpO1xuXG5rby5leHBvcnRTeW1ib2woJ3NlbGVjdEV4dGVuc2lvbnMnLCBrby5zZWxlY3RFeHRlbnNpb25zKTtcbmtvLmV4cG9ydFN5bWJvbCgnc2VsZWN0RXh0ZW5zaW9ucy5yZWFkVmFsdWUnLCBrby5zZWxlY3RFeHRlbnNpb25zLnJlYWRWYWx1ZSk7XG5rby5leHBvcnRTeW1ib2woJ3NlbGVjdEV4dGVuc2lvbnMud3JpdGVWYWx1ZScsIGtvLnNlbGVjdEV4dGVuc2lvbnMud3JpdGVWYWx1ZSk7XG5rby5leHByZXNzaW9uUmV3cml0aW5nID0gKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgamF2YVNjcmlwdFJlc2VydmVkV29yZHMgPSBbXCJ0cnVlXCIsIFwiZmFsc2VcIiwgXCJudWxsXCIsIFwidW5kZWZpbmVkXCJdO1xuXG4gICAgLy8gTWF0Y2hlcyBzb21ldGhpbmcgdGhhdCBjYW4gYmUgYXNzaWduZWQgdG8tLWVpdGhlciBhbiBpc29sYXRlZCBpZGVudGlmaWVyIG9yIHNvbWV0aGluZyBlbmRpbmcgd2l0aCBhIHByb3BlcnR5IGFjY2Vzc29yXG4gICAgLy8gVGhpcyBpcyBkZXNpZ25lZCB0byBiZSBzaW1wbGUgYW5kIGF2b2lkIGZhbHNlIG5lZ2F0aXZlcywgYnV0IGNvdWxkIHByb2R1Y2UgZmFsc2UgcG9zaXRpdmVzIChlLmcuLCBhK2IuYykuXG4gICAgLy8gVGhpcyBhbHNvIHdpbGwgbm90IHByb3Blcmx5IGhhbmRsZSBuZXN0ZWQgYnJhY2tldHMgKGUuZy4sIG9iajFbb2JqMlsncHJvcCddXTsgc2VlICM5MTEpLlxuICAgIHZhciBqYXZhU2NyaXB0QXNzaWdubWVudFRhcmdldCA9IC9eKD86WyRfYS16XVskXFx3XSp8KC4rKShcXC5cXHMqWyRfYS16XVskXFx3XSp8XFxbLitcXF0pKSQvaTtcblxuICAgIGZ1bmN0aW9uIGdldFdyaXRlYWJsZVZhbHVlKGV4cHJlc3Npb24pIHtcbiAgICAgICAgaWYgKGtvLnV0aWxzLmFycmF5SW5kZXhPZihqYXZhU2NyaXB0UmVzZXJ2ZWRXb3JkcywgZXhwcmVzc2lvbikgPj0gMClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgdmFyIG1hdGNoID0gZXhwcmVzc2lvbi5tYXRjaChqYXZhU2NyaXB0QXNzaWdubWVudFRhcmdldCk7XG4gICAgICAgIHJldHVybiBtYXRjaCA9PT0gbnVsbCA/IGZhbHNlIDogbWF0Y2hbMV0gPyAoJ09iamVjdCgnICsgbWF0Y2hbMV0gKyAnKScgKyBtYXRjaFsyXSkgOiBleHByZXNzaW9uO1xuICAgIH1cblxuICAgIC8vIFRoZSBmb2xsb3dpbmcgcmVndWxhciBleHByZXNzaW9ucyB3aWxsIGJlIHVzZWQgdG8gc3BsaXQgYW4gb2JqZWN0LWxpdGVyYWwgc3RyaW5nIGludG8gdG9rZW5zXG5cbiAgICAgICAgLy8gVGhlc2UgdHdvIG1hdGNoIHN0cmluZ3MsIGVpdGhlciB3aXRoIGRvdWJsZSBxdW90ZXMgb3Igc2luZ2xlIHF1b3Rlc1xuICAgIHZhciBzdHJpbmdEb3VibGUgPSAnXCIoPzpbXlwiXFxcXFxcXFxdfFxcXFxcXFxcLikqXCInLFxuICAgICAgICBzdHJpbmdTaW5nbGUgPSBcIicoPzpbXidcXFxcXFxcXF18XFxcXFxcXFwuKSonXCIsXG4gICAgICAgIC8vIE1hdGNoZXMgYSByZWd1bGFyIGV4cHJlc3Npb24gKHRleHQgZW5jbG9zZWQgYnkgc2xhc2hlcyksIGJ1dCB3aWxsIGFsc28gbWF0Y2ggc2V0cyBvZiBkaXZpc2lvbnNcbiAgICAgICAgLy8gYXMgYSByZWd1bGFyIGV4cHJlc3Npb24gKHRoaXMgaXMgaGFuZGxlZCBieSB0aGUgcGFyc2luZyBsb29wIGJlbG93KS5cbiAgICAgICAgc3RyaW5nUmVnZXhwID0gJy8oPzpbXi9cXFxcXFxcXF18XFxcXFxcXFwuKSovXFx3KicsXG4gICAgICAgIC8vIFRoZXNlIGNoYXJhY3RlcnMgaGF2ZSBzcGVjaWFsIG1lYW5pbmcgdG8gdGhlIHBhcnNlciBhbmQgbXVzdCBub3QgYXBwZWFyIGluIHRoZSBtaWRkbGUgb2YgYVxuICAgICAgICAvLyB0b2tlbiwgZXhjZXB0IGFzIHBhcnQgb2YgYSBzdHJpbmcuXG4gICAgICAgIHNwZWNpYWxzID0gJyxcIlxcJ3t9KCkvOltcXFxcXScsXG4gICAgICAgIC8vIE1hdGNoIHRleHQgKGF0IGxlYXN0IHR3byBjaGFyYWN0ZXJzKSB0aGF0IGRvZXMgbm90IGNvbnRhaW4gYW55IG9mIHRoZSBhYm92ZSBzcGVjaWFsIGNoYXJhY3RlcnMsXG4gICAgICAgIC8vIGFsdGhvdWdoIHNvbWUgb2YgdGhlIHNwZWNpYWwgY2hhcmFjdGVycyBhcmUgYWxsb3dlZCB0byBzdGFydCBpdCAoYWxsIGJ1dCB0aGUgY29sb24gYW5kIGNvbW1hKS5cbiAgICAgICAgLy8gVGhlIHRleHQgY2FuIGNvbnRhaW4gc3BhY2VzLCBidXQgbGVhZGluZyBvciB0cmFpbGluZyBzcGFjZXMgYXJlIHNraXBwZWQuXG4gICAgICAgIGV2ZXJ5VGhpbmdFbHNlID0gJ1teXFxcXHM6LC9dW14nICsgc3BlY2lhbHMgKyAnXSpbXlxcXFxzJyArIHNwZWNpYWxzICsgJ10nLFxuICAgICAgICAvLyBNYXRjaCBhbnkgbm9uLXNwYWNlIGNoYXJhY3RlciBub3QgbWF0Y2hlZCBhbHJlYWR5LiBUaGlzIHdpbGwgbWF0Y2ggY29sb25zIGFuZCBjb21tYXMsIHNpbmNlIHRoZXkncmVcbiAgICAgICAgLy8gbm90IG1hdGNoZWQgYnkgXCJldmVyeVRoaW5nRWxzZVwiLCBidXQgd2lsbCBhbHNvIG1hdGNoIGFueSBvdGhlciBzaW5nbGUgY2hhcmFjdGVyIHRoYXQgd2Fzbid0IGFscmVhZHlcbiAgICAgICAgLy8gbWF0Y2hlZCAoZm9yIGV4YW1wbGU6IGluIFwiYTogMSwgYjogMlwiLCBlYWNoIG9mIHRoZSBub24tc3BhY2UgY2hhcmFjdGVycyB3aWxsIGJlIG1hdGNoZWQgYnkgb25lTm90U3BhY2UpLlxuICAgICAgICBvbmVOb3RTcGFjZSA9ICdbXlxcXFxzXScsXG5cbiAgICAgICAgLy8gQ3JlYXRlIHRoZSBhY3R1YWwgcmVndWxhciBleHByZXNzaW9uIGJ5IG9yLWluZyB0aGUgYWJvdmUgc3RyaW5ncy4gVGhlIG9yZGVyIGlzIGltcG9ydGFudC5cbiAgICAgICAgYmluZGluZ1Rva2VuID0gUmVnRXhwKHN0cmluZ0RvdWJsZSArICd8JyArIHN0cmluZ1NpbmdsZSArICd8JyArIHN0cmluZ1JlZ2V4cCArICd8JyArIGV2ZXJ5VGhpbmdFbHNlICsgJ3wnICsgb25lTm90U3BhY2UsICdnJyksXG5cbiAgICAgICAgLy8gTWF0Y2ggZW5kIG9mIHByZXZpb3VzIHRva2VuIHRvIGRldGVybWluZSB3aGV0aGVyIGEgc2xhc2ggaXMgYSBkaXZpc2lvbiBvciByZWdleC5cbiAgICAgICAgZGl2aXNpb25Mb29rQmVoaW5kID0gL1tcXF0pXCInQS1aYS16MC05XyRdKyQvLFxuICAgICAgICBrZXl3b3JkUmVnZXhMb29rQmVoaW5kID0geydpbic6MSwncmV0dXJuJzoxLCd0eXBlb2YnOjF9O1xuXG4gICAgZnVuY3Rpb24gcGFyc2VPYmplY3RMaXRlcmFsKG9iamVjdExpdGVyYWxTdHJpbmcpIHtcbiAgICAgICAgLy8gVHJpbSBsZWFkaW5nIGFuZCB0cmFpbGluZyBzcGFjZXMgZnJvbSB0aGUgc3RyaW5nXG4gICAgICAgIHZhciBzdHIgPSBrby51dGlscy5zdHJpbmdUcmltKG9iamVjdExpdGVyYWxTdHJpbmcpO1xuXG4gICAgICAgIC8vIFRyaW0gYnJhY2VzICd7JyBzdXJyb3VuZGluZyB0aGUgd2hvbGUgb2JqZWN0IGxpdGVyYWxcbiAgICAgICAgaWYgKHN0ci5jaGFyQ29kZUF0KDApID09PSAxMjMpIHN0ciA9IHN0ci5zbGljZSgxLCAtMSk7XG5cbiAgICAgICAgLy8gU3BsaXQgaW50byB0b2tlbnNcbiAgICAgICAgdmFyIHJlc3VsdCA9IFtdLCB0b2tzID0gc3RyLm1hdGNoKGJpbmRpbmdUb2tlbiksIGtleSwgdmFsdWVzID0gW10sIGRlcHRoID0gMDtcblxuICAgICAgICBpZiAodG9rcykge1xuICAgICAgICAgICAgLy8gQXBwZW5kIGEgY29tbWEgc28gdGhhdCB3ZSBkb24ndCBuZWVkIGEgc2VwYXJhdGUgY29kZSBibG9jayB0byBkZWFsIHdpdGggdGhlIGxhc3QgaXRlbVxuICAgICAgICAgICAgdG9rcy5wdXNoKCcsJyk7XG5cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCB0b2s7IHRvayA9IHRva3NbaV07ICsraSkge1xuICAgICAgICAgICAgICAgIHZhciBjID0gdG9rLmNoYXJDb2RlQXQoMCk7XG4gICAgICAgICAgICAgICAgLy8gQSBjb21tYSBzaWduYWxzIHRoZSBlbmQgb2YgYSBrZXkvdmFsdWUgcGFpciBpZiBkZXB0aCBpcyB6ZXJvXG4gICAgICAgICAgICAgICAgaWYgKGMgPT09IDQ0KSB7IC8vIFwiLFwiXG4gICAgICAgICAgICAgICAgICAgIGlmIChkZXB0aCA8PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaCgoa2V5ICYmIHZhbHVlcy5sZW5ndGgpID8ge2tleToga2V5LCB2YWx1ZTogdmFsdWVzLmpvaW4oJycpfSA6IHsndW5rbm93bic6IGtleSB8fCB2YWx1ZXMuam9pbignJyl9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleSA9IGRlcHRoID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlcyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBTaW1wbHkgc2tpcCB0aGUgY29sb24gdGhhdCBzZXBhcmF0ZXMgdGhlIG5hbWUgYW5kIHZhbHVlXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjID09PSA1OCkgeyAvLyBcIjpcIlxuICAgICAgICAgICAgICAgICAgICBpZiAoIWRlcHRoICYmICFrZXkgJiYgdmFsdWVzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAga2V5ID0gdmFsdWVzLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBBIHNldCBvZiBzbGFzaGVzIGlzIGluaXRpYWxseSBtYXRjaGVkIGFzIGEgcmVndWxhciBleHByZXNzaW9uLCBidXQgY291bGQgYmUgZGl2aXNpb25cbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGMgPT09IDQ3ICYmIGkgJiYgdG9rLmxlbmd0aCA+IDEpIHsgIC8vIFwiL1wiXG4gICAgICAgICAgICAgICAgICAgIC8vIExvb2sgYXQgdGhlIGVuZCBvZiB0aGUgcHJldmlvdXMgdG9rZW4gdG8gZGV0ZXJtaW5lIGlmIHRoZSBzbGFzaCBpcyBhY3R1YWxseSBkaXZpc2lvblxuICAgICAgICAgICAgICAgICAgICB2YXIgbWF0Y2ggPSB0b2tzW2ktMV0ubWF0Y2goZGl2aXNpb25Mb29rQmVoaW5kKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1hdGNoICYmICFrZXl3b3JkUmVnZXhMb29rQmVoaW5kW21hdGNoWzBdXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhlIHNsYXNoIGlzIGFjdHVhbGx5IGEgZGl2aXNpb24gcHVuY3R1YXRvcjsgcmUtcGFyc2UgdGhlIHJlbWFpbmRlciBvZiB0aGUgc3RyaW5nIChub3QgaW5jbHVkaW5nIHRoZSBzbGFzaClcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0ciA9IHN0ci5zdWJzdHIoc3RyLmluZGV4T2YodG9rKSArIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdG9rcyA9IHN0ci5tYXRjaChiaW5kaW5nVG9rZW4pO1xuICAgICAgICAgICAgICAgICAgICAgICAgdG9rcy5wdXNoKCcsJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpID0gLTE7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBDb250aW51ZSB3aXRoIGp1c3QgdGhlIHNsYXNoXG4gICAgICAgICAgICAgICAgICAgICAgICB0b2sgPSAnLyc7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBJbmNyZW1lbnQgZGVwdGggZm9yIHBhcmVudGhlc2VzLCBicmFjZXMsIGFuZCBicmFja2V0cyBzbyB0aGF0IGludGVyaW9yIGNvbW1hcyBhcmUgaWdub3JlZFxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoYyA9PT0gNDAgfHwgYyA9PT0gMTIzIHx8IGMgPT09IDkxKSB7IC8vICcoJywgJ3snLCAnWydcbiAgICAgICAgICAgICAgICAgICAgKytkZXB0aDtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGMgPT09IDQxIHx8IGMgPT09IDEyNSB8fCBjID09PSA5MykgeyAvLyAnKScsICd9JywgJ10nXG4gICAgICAgICAgICAgICAgICAgIC0tZGVwdGg7XG4gICAgICAgICAgICAgICAgLy8gVGhlIGtleSB3aWxsIGJlIHRoZSBmaXJzdCB0b2tlbjsgaWYgaXQncyBhIHN0cmluZywgdHJpbSB0aGUgcXVvdGVzXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICgha2V5ICYmICF2YWx1ZXMubGVuZ3RoICYmIChjID09PSAzNCB8fCBjID09PSAzOSkpIHsgLy8gJ1wiJywgXCInXCJcbiAgICAgICAgICAgICAgICAgICAgdG9rID0gdG9rLnNsaWNlKDEsIC0xKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFsdWVzLnB1c2godG9rKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8vIFR3by13YXkgYmluZGluZ3MgaW5jbHVkZSBhIHdyaXRlIGZ1bmN0aW9uIHRoYXQgYWxsb3cgdGhlIGhhbmRsZXIgdG8gdXBkYXRlIHRoZSB2YWx1ZSBldmVuIGlmIGl0J3Mgbm90IGFuIG9ic2VydmFibGUuXG4gICAgdmFyIHR3b1dheUJpbmRpbmdzID0ge307XG5cbiAgICBmdW5jdGlvbiBwcmVQcm9jZXNzQmluZGluZ3MoYmluZGluZ3NTdHJpbmdPcktleVZhbHVlQXJyYXksIGJpbmRpbmdPcHRpb25zKSB7XG4gICAgICAgIGJpbmRpbmdPcHRpb25zID0gYmluZGluZ09wdGlvbnMgfHwge307XG5cbiAgICAgICAgZnVuY3Rpb24gcHJvY2Vzc0tleVZhbHVlKGtleSwgdmFsKSB7XG4gICAgICAgICAgICB2YXIgd3JpdGFibGVWYWw7XG4gICAgICAgICAgICBmdW5jdGlvbiBjYWxsUHJlcHJvY2Vzc0hvb2sob2JqKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIChvYmogJiYgb2JqWydwcmVwcm9jZXNzJ10pID8gKHZhbCA9IG9ialsncHJlcHJvY2VzcyddKHZhbCwga2V5LCBwcm9jZXNzS2V5VmFsdWUpKSA6IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWJpbmRpbmdQYXJhbXMpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWNhbGxQcmVwcm9jZXNzSG9vayhrb1snZ2V0QmluZGluZ0hhbmRsZXInXShrZXkpKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuXG4gICAgICAgICAgICAgICAgaWYgKHR3b1dheUJpbmRpbmdzW2tleV0gJiYgKHdyaXRhYmxlVmFsID0gZ2V0V3JpdGVhYmxlVmFsdWUodmFsKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gRm9yIHR3by13YXkgYmluZGluZ3MsIHByb3ZpZGUgYSB3cml0ZSBtZXRob2QgaW4gY2FzZSB0aGUgdmFsdWVcbiAgICAgICAgICAgICAgICAgICAgLy8gaXNuJ3QgYSB3cml0YWJsZSBvYnNlcnZhYmxlLlxuICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0eUFjY2Vzc29yUmVzdWx0U3RyaW5ncy5wdXNoKFwiJ1wiICsga2V5ICsgXCInOmZ1bmN0aW9uKF96KXtcIiArIHdyaXRhYmxlVmFsICsgXCI9X3p9XCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFZhbHVlcyBhcmUgd3JhcHBlZCBpbiBhIGZ1bmN0aW9uIHNvIHRoYXQgZWFjaCB2YWx1ZSBjYW4gYmUgYWNjZXNzZWQgaW5kZXBlbmRlbnRseVxuICAgICAgICAgICAgaWYgKG1ha2VWYWx1ZUFjY2Vzc29ycykge1xuICAgICAgICAgICAgICAgIHZhbCA9ICdmdW5jdGlvbigpe3JldHVybiAnICsgdmFsICsgJyB9JztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdFN0cmluZ3MucHVzaChcIidcIiArIGtleSArIFwiJzpcIiArIHZhbCk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcmVzdWx0U3RyaW5ncyA9IFtdLFxuICAgICAgICAgICAgcHJvcGVydHlBY2Nlc3NvclJlc3VsdFN0cmluZ3MgPSBbXSxcbiAgICAgICAgICAgIG1ha2VWYWx1ZUFjY2Vzc29ycyA9IGJpbmRpbmdPcHRpb25zWyd2YWx1ZUFjY2Vzc29ycyddLFxuICAgICAgICAgICAgYmluZGluZ1BhcmFtcyA9IGJpbmRpbmdPcHRpb25zWydiaW5kaW5nUGFyYW1zJ10sXG4gICAgICAgICAgICBrZXlWYWx1ZUFycmF5ID0gdHlwZW9mIGJpbmRpbmdzU3RyaW5nT3JLZXlWYWx1ZUFycmF5ID09PSBcInN0cmluZ1wiID9cbiAgICAgICAgICAgICAgICBwYXJzZU9iamVjdExpdGVyYWwoYmluZGluZ3NTdHJpbmdPcktleVZhbHVlQXJyYXkpIDogYmluZGluZ3NTdHJpbmdPcktleVZhbHVlQXJyYXk7XG5cbiAgICAgICAga28udXRpbHMuYXJyYXlGb3JFYWNoKGtleVZhbHVlQXJyYXksIGZ1bmN0aW9uKGtleVZhbHVlKSB7XG4gICAgICAgICAgICBwcm9jZXNzS2V5VmFsdWUoa2V5VmFsdWUua2V5IHx8IGtleVZhbHVlWyd1bmtub3duJ10sIGtleVZhbHVlLnZhbHVlKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKHByb3BlcnR5QWNjZXNzb3JSZXN1bHRTdHJpbmdzLmxlbmd0aClcbiAgICAgICAgICAgIHByb2Nlc3NLZXlWYWx1ZSgnX2tvX3Byb3BlcnR5X3dyaXRlcnMnLCBcIntcIiArIHByb3BlcnR5QWNjZXNzb3JSZXN1bHRTdHJpbmdzLmpvaW4oXCIsXCIpICsgXCIgfVwiKTtcblxuICAgICAgICByZXR1cm4gcmVzdWx0U3RyaW5ncy5qb2luKFwiLFwiKTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgICBiaW5kaW5nUmV3cml0ZVZhbGlkYXRvcnM6IFtdLFxuXG4gICAgICAgIHR3b1dheUJpbmRpbmdzOiB0d29XYXlCaW5kaW5ncyxcblxuICAgICAgICBwYXJzZU9iamVjdExpdGVyYWw6IHBhcnNlT2JqZWN0TGl0ZXJhbCxcblxuICAgICAgICBwcmVQcm9jZXNzQmluZGluZ3M6IHByZVByb2Nlc3NCaW5kaW5ncyxcblxuICAgICAgICBrZXlWYWx1ZUFycmF5Q29udGFpbnNLZXk6IGZ1bmN0aW9uKGtleVZhbHVlQXJyYXksIGtleSkge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlWYWx1ZUFycmF5Lmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgICAgIGlmIChrZXlWYWx1ZUFycmF5W2ldWydrZXknXSA9PSBrZXkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8vIEludGVybmFsLCBwcml2YXRlIEtPIHV0aWxpdHkgZm9yIHVwZGF0aW5nIG1vZGVsIHByb3BlcnRpZXMgZnJvbSB3aXRoaW4gYmluZGluZ3NcbiAgICAgICAgLy8gcHJvcGVydHk6ICAgICAgICAgICAgSWYgdGhlIHByb3BlcnR5IGJlaW5nIHVwZGF0ZWQgaXMgKG9yIG1pZ2h0IGJlKSBhbiBvYnNlcnZhYmxlLCBwYXNzIGl0IGhlcmVcbiAgICAgICAgLy8gICAgICAgICAgICAgICAgICAgICAgSWYgaXQgdHVybnMgb3V0IHRvIGJlIGEgd3JpdGFibGUgb2JzZXJ2YWJsZSwgaXQgd2lsbCBiZSB3cml0dGVuIHRvIGRpcmVjdGx5XG4gICAgICAgIC8vIGFsbEJpbmRpbmdzOiAgICAgICAgIEFuIG9iamVjdCB3aXRoIGEgZ2V0IG1ldGhvZCB0byByZXRyaWV2ZSBiaW5kaW5ncyBpbiB0aGUgY3VycmVudCBleGVjdXRpb24gY29udGV4dC5cbiAgICAgICAgLy8gICAgICAgICAgICAgICAgICAgICAgVGhpcyB3aWxsIGJlIHNlYXJjaGVkIGZvciBhICdfa29fcHJvcGVydHlfd3JpdGVycycgcHJvcGVydHkgaW4gY2FzZSB5b3UncmUgd3JpdGluZyB0byBhIG5vbi1vYnNlcnZhYmxlXG4gICAgICAgIC8vIGtleTogICAgICAgICAgICAgICAgIFRoZSBrZXkgaWRlbnRpZnlpbmcgdGhlIHByb3BlcnR5IHRvIGJlIHdyaXR0ZW4uIEV4YW1wbGU6IGZvciB7IGhhc0ZvY3VzOiBteVZhbHVlIH0sIHdyaXRlIHRvICdteVZhbHVlJyBieSBzcGVjaWZ5aW5nIHRoZSBrZXkgJ2hhc0ZvY3VzJ1xuICAgICAgICAvLyB2YWx1ZTogICAgICAgICAgICAgICBUaGUgdmFsdWUgdG8gYmUgd3JpdHRlblxuICAgICAgICAvLyBjaGVja0lmRGlmZmVyZW50OiAgICBJZiB0cnVlLCBhbmQgaWYgdGhlIHByb3BlcnR5IGJlaW5nIHdyaXR0ZW4gaXMgYSB3cml0YWJsZSBvYnNlcnZhYmxlLCB0aGUgdmFsdWUgd2lsbCBvbmx5IGJlIHdyaXR0ZW4gaWZcbiAgICAgICAgLy8gICAgICAgICAgICAgICAgICAgICAgaXQgaXMgIT09IGV4aXN0aW5nIHZhbHVlIG9uIHRoYXQgd3JpdGFibGUgb2JzZXJ2YWJsZVxuICAgICAgICB3cml0ZVZhbHVlVG9Qcm9wZXJ0eTogZnVuY3Rpb24ocHJvcGVydHksIGFsbEJpbmRpbmdzLCBrZXksIHZhbHVlLCBjaGVja0lmRGlmZmVyZW50KSB7XG4gICAgICAgICAgICBpZiAoIXByb3BlcnR5IHx8ICFrby5pc09ic2VydmFibGUocHJvcGVydHkpKSB7XG4gICAgICAgICAgICAgICAgdmFyIHByb3BXcml0ZXJzID0gYWxsQmluZGluZ3MuZ2V0KCdfa29fcHJvcGVydHlfd3JpdGVycycpO1xuICAgICAgICAgICAgICAgIGlmIChwcm9wV3JpdGVycyAmJiBwcm9wV3JpdGVyc1trZXldKVxuICAgICAgICAgICAgICAgICAgICBwcm9wV3JpdGVyc1trZXldKHZhbHVlKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoa28uaXNXcml0ZWFibGVPYnNlcnZhYmxlKHByb3BlcnR5KSAmJiAoIWNoZWNrSWZEaWZmZXJlbnQgfHwgcHJvcGVydHkucGVlaygpICE9PSB2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICBwcm9wZXJ0eSh2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xufSkoKTtcblxua28uZXhwb3J0U3ltYm9sKCdleHByZXNzaW9uUmV3cml0aW5nJywga28uZXhwcmVzc2lvblJld3JpdGluZyk7XG5rby5leHBvcnRTeW1ib2woJ2V4cHJlc3Npb25SZXdyaXRpbmcuYmluZGluZ1Jld3JpdGVWYWxpZGF0b3JzJywga28uZXhwcmVzc2lvblJld3JpdGluZy5iaW5kaW5nUmV3cml0ZVZhbGlkYXRvcnMpO1xua28uZXhwb3J0U3ltYm9sKCdleHByZXNzaW9uUmV3cml0aW5nLnBhcnNlT2JqZWN0TGl0ZXJhbCcsIGtvLmV4cHJlc3Npb25SZXdyaXRpbmcucGFyc2VPYmplY3RMaXRlcmFsKTtcbmtvLmV4cG9ydFN5bWJvbCgnZXhwcmVzc2lvblJld3JpdGluZy5wcmVQcm9jZXNzQmluZGluZ3MnLCBrby5leHByZXNzaW9uUmV3cml0aW5nLnByZVByb2Nlc3NCaW5kaW5ncyk7XG5cbi8vIE1ha2luZyBiaW5kaW5ncyBleHBsaWNpdGx5IGRlY2xhcmUgdGhlbXNlbHZlcyBhcyBcInR3byB3YXlcIiBpc24ndCBpZGVhbCBpbiB0aGUgbG9uZyB0ZXJtIChpdCB3b3VsZCBiZSBiZXR0ZXIgaWZcbi8vIGFsbCBiaW5kaW5ncyBjb3VsZCB1c2UgYW4gb2ZmaWNpYWwgJ3Byb3BlcnR5IHdyaXRlcicgQVBJIHdpdGhvdXQgbmVlZGluZyB0byBkZWNsYXJlIHRoYXQgdGhleSBtaWdodCkuIEhvd2V2ZXIsXG4vLyBzaW5jZSB0aGlzIGlzIG5vdCwgYW5kIGhhcyBuZXZlciBiZWVuLCBhIHB1YmxpYyBBUEkgKF9rb19wcm9wZXJ0eV93cml0ZXJzIHdhcyBuZXZlciBkb2N1bWVudGVkKSwgaXQncyBhY2NlcHRhYmxlXG4vLyBhcyBhbiBpbnRlcm5hbCBpbXBsZW1lbnRhdGlvbiBkZXRhaWwgaW4gdGhlIHNob3J0IHRlcm0uXG4vLyBGb3IgdGhvc2UgZGV2ZWxvcGVycyB3aG8gcmVseSBvbiBfa29fcHJvcGVydHlfd3JpdGVycyBpbiB0aGVpciBjdXN0b20gYmluZGluZ3MsIHdlIGV4cG9zZSBfdHdvV2F5QmluZGluZ3MgYXMgYW5cbi8vIHVuZG9jdW1lbnRlZCBmZWF0dXJlIHRoYXQgbWFrZXMgaXQgcmVsYXRpdmVseSBlYXN5IHRvIHVwZ3JhZGUgdG8gS08gMy4wLiBIb3dldmVyLCB0aGlzIGlzIHN0aWxsIG5vdCBhbiBvZmZpY2lhbFxuLy8gcHVibGljIEFQSSwgYW5kIHdlIHJlc2VydmUgdGhlIHJpZ2h0IHRvIHJlbW92ZSBpdCBhdCBhbnkgdGltZSBpZiB3ZSBjcmVhdGUgYSByZWFsIHB1YmxpYyBwcm9wZXJ0eSB3cml0ZXJzIEFQSS5cbmtvLmV4cG9ydFN5bWJvbCgnZXhwcmVzc2lvblJld3JpdGluZy5fdHdvV2F5QmluZGluZ3MnLCBrby5leHByZXNzaW9uUmV3cml0aW5nLnR3b1dheUJpbmRpbmdzKTtcblxuLy8gRm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHksIGRlZmluZSB0aGUgZm9sbG93aW5nIGFsaWFzZXMuIChQcmV2aW91c2x5LCB0aGVzZSBmdW5jdGlvbiBuYW1lcyB3ZXJlIG1pc2xlYWRpbmcgYmVjYXVzZVxuLy8gdGhleSByZWZlcnJlZCB0byBKU09OIHNwZWNpZmljYWxseSwgZXZlbiB0aG91Z2ggdGhleSBhY3R1YWxseSB3b3JrIHdpdGggYXJiaXRyYXJ5IEphdmFTY3JpcHQgb2JqZWN0IGxpdGVyYWwgZXhwcmVzc2lvbnMuKVxua28uZXhwb3J0U3ltYm9sKCdqc29uRXhwcmVzc2lvblJld3JpdGluZycsIGtvLmV4cHJlc3Npb25SZXdyaXRpbmcpO1xua28uZXhwb3J0U3ltYm9sKCdqc29uRXhwcmVzc2lvblJld3JpdGluZy5pbnNlcnRQcm9wZXJ0eUFjY2Vzc29yc0ludG9Kc29uJywga28uZXhwcmVzc2lvblJld3JpdGluZy5wcmVQcm9jZXNzQmluZGluZ3MpO1xuKGZ1bmN0aW9uKCkge1xuICAgIC8vIFwiVmlydHVhbCBlbGVtZW50c1wiIGlzIGFuIGFic3RyYWN0aW9uIG9uIHRvcCBvZiB0aGUgdXN1YWwgRE9NIEFQSSB3aGljaCB1bmRlcnN0YW5kcyB0aGUgbm90aW9uIHRoYXQgY29tbWVudCBub2Rlc1xuICAgIC8vIG1heSBiZSB1c2VkIHRvIHJlcHJlc2VudCBoaWVyYXJjaHkgKGluIGFkZGl0aW9uIHRvIHRoZSBET00ncyBuYXR1cmFsIGhpZXJhcmNoeSkuXG4gICAgLy8gSWYgeW91IGNhbGwgdGhlIERPTS1tYW5pcHVsYXRpbmcgZnVuY3Rpb25zIG9uIGtvLnZpcnR1YWxFbGVtZW50cywgeW91IHdpbGwgYmUgYWJsZSB0byByZWFkIGFuZCB3cml0ZSB0aGUgc3RhdGVcbiAgICAvLyBvZiB0aGF0IHZpcnR1YWwgaGllcmFyY2h5XG4gICAgLy9cbiAgICAvLyBUaGUgcG9pbnQgb2YgYWxsIHRoaXMgaXMgdG8gc3VwcG9ydCBjb250YWluZXJsZXNzIHRlbXBsYXRlcyAoZS5nLiwgPCEtLSBrbyBmb3JlYWNoOnNvbWVDb2xsZWN0aW9uIC0tPmJsYWg8IS0tIC9rbyAtLT4pXG4gICAgLy8gd2l0aG91dCBoYXZpbmcgdG8gc2NhdHRlciBzcGVjaWFsIGNhc2VzIGFsbCBvdmVyIHRoZSBiaW5kaW5nIGFuZCB0ZW1wbGF0aW5nIGNvZGUuXG5cbiAgICAvLyBJRSA5IGNhbm5vdCByZWxpYWJseSByZWFkIHRoZSBcIm5vZGVWYWx1ZVwiIHByb3BlcnR5IG9mIGEgY29tbWVudCBub2RlIChzZWUgaHR0cHM6Ly9naXRodWIuY29tL1N0ZXZlU2FuZGVyc29uL2tub2Nrb3V0L2lzc3Vlcy8xODYpXG4gICAgLy8gYnV0IGl0IGRvZXMgZ2l2ZSB0aGVtIGEgbm9uc3RhbmRhcmQgYWx0ZXJuYXRpdmUgcHJvcGVydHkgY2FsbGVkIFwidGV4dFwiIHRoYXQgaXQgY2FuIHJlYWQgcmVsaWFibHkuIE90aGVyIGJyb3dzZXJzIGRvbid0IGhhdmUgdGhhdCBwcm9wZXJ0eS5cbiAgICAvLyBTbywgdXNlIG5vZGUudGV4dCB3aGVyZSBhdmFpbGFibGUsIGFuZCBub2RlLm5vZGVWYWx1ZSBlbHNld2hlcmVcbiAgICB2YXIgY29tbWVudE5vZGVzSGF2ZVRleHRQcm9wZXJ0eSA9IGRvY3VtZW50ICYmIGRvY3VtZW50LmNyZWF0ZUNvbW1lbnQoXCJ0ZXN0XCIpLnRleHQgPT09IFwiPCEtLXRlc3QtLT5cIjtcblxuICAgIHZhciBzdGFydENvbW1lbnRSZWdleCA9IGNvbW1lbnROb2Rlc0hhdmVUZXh0UHJvcGVydHkgPyAvXjwhLS1cXHMqa28oPzpcXHMrKFtcXHNcXFNdKykpP1xccyotLT4kLyA6IC9eXFxzKmtvKD86XFxzKyhbXFxzXFxTXSspKT9cXHMqJC87XG4gICAgdmFyIGVuZENvbW1lbnRSZWdleCA9ICAgY29tbWVudE5vZGVzSGF2ZVRleHRQcm9wZXJ0eSA/IC9ePCEtLVxccypcXC9rb1xccyotLT4kLyA6IC9eXFxzKlxcL2tvXFxzKiQvO1xuICAgIHZhciBodG1sVGFnc1dpdGhPcHRpb25hbGx5Q2xvc2luZ0NoaWxkcmVuID0geyAndWwnOiB0cnVlLCAnb2wnOiB0cnVlIH07XG5cbiAgICBmdW5jdGlvbiBpc1N0YXJ0Q29tbWVudChub2RlKSB7XG4gICAgICAgIHJldHVybiAobm9kZS5ub2RlVHlwZSA9PSA4KSAmJiBzdGFydENvbW1lbnRSZWdleC50ZXN0KGNvbW1lbnROb2Rlc0hhdmVUZXh0UHJvcGVydHkgPyBub2RlLnRleHQgOiBub2RlLm5vZGVWYWx1ZSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNFbmRDb21tZW50KG5vZGUpIHtcbiAgICAgICAgcmV0dXJuIChub2RlLm5vZGVUeXBlID09IDgpICYmIGVuZENvbW1lbnRSZWdleC50ZXN0KGNvbW1lbnROb2Rlc0hhdmVUZXh0UHJvcGVydHkgPyBub2RlLnRleHQgOiBub2RlLm5vZGVWYWx1ZSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0VmlydHVhbENoaWxkcmVuKHN0YXJ0Q29tbWVudCwgYWxsb3dVbmJhbGFuY2VkKSB7XG4gICAgICAgIHZhciBjdXJyZW50Tm9kZSA9IHN0YXJ0Q29tbWVudDtcbiAgICAgICAgdmFyIGRlcHRoID0gMTtcbiAgICAgICAgdmFyIGNoaWxkcmVuID0gW107XG4gICAgICAgIHdoaWxlIChjdXJyZW50Tm9kZSA9IGN1cnJlbnROb2RlLm5leHRTaWJsaW5nKSB7XG4gICAgICAgICAgICBpZiAoaXNFbmRDb21tZW50KGN1cnJlbnROb2RlKSkge1xuICAgICAgICAgICAgICAgIGRlcHRoLS07XG4gICAgICAgICAgICAgICAgaWYgKGRlcHRoID09PSAwKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2hpbGRyZW47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNoaWxkcmVuLnB1c2goY3VycmVudE5vZGUpO1xuXG4gICAgICAgICAgICBpZiAoaXNTdGFydENvbW1lbnQoY3VycmVudE5vZGUpKVxuICAgICAgICAgICAgICAgIGRlcHRoKys7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFhbGxvd1VuYmFsYW5jZWQpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBjbG9zaW5nIGNvbW1lbnQgdGFnIHRvIG1hdGNoOiBcIiArIHN0YXJ0Q29tbWVudC5ub2RlVmFsdWUpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRNYXRjaGluZ0VuZENvbW1lbnQoc3RhcnRDb21tZW50LCBhbGxvd1VuYmFsYW5jZWQpIHtcbiAgICAgICAgdmFyIGFsbFZpcnR1YWxDaGlsZHJlbiA9IGdldFZpcnR1YWxDaGlsZHJlbihzdGFydENvbW1lbnQsIGFsbG93VW5iYWxhbmNlZCk7XG4gICAgICAgIGlmIChhbGxWaXJ0dWFsQ2hpbGRyZW4pIHtcbiAgICAgICAgICAgIGlmIChhbGxWaXJ0dWFsQ2hpbGRyZW4ubGVuZ3RoID4gMClcbiAgICAgICAgICAgICAgICByZXR1cm4gYWxsVmlydHVhbENoaWxkcmVuW2FsbFZpcnR1YWxDaGlsZHJlbi5sZW5ndGggLSAxXS5uZXh0U2libGluZztcbiAgICAgICAgICAgIHJldHVybiBzdGFydENvbW1lbnQubmV4dFNpYmxpbmc7XG4gICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7IC8vIE11c3QgaGF2ZSBubyBtYXRjaGluZyBlbmQgY29tbWVudCwgYW5kIGFsbG93VW5iYWxhbmNlZCBpcyB0cnVlXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0VW5iYWxhbmNlZENoaWxkVGFncyhub2RlKSB7XG4gICAgICAgIC8vIGUuZy4sIGZyb20gPGRpdj5PSzwvZGl2PjwhLS0ga28gYmxhaCAtLT48c3Bhbj5Bbm90aGVyPC9zcGFuPiwgcmV0dXJuczogPCEtLSBrbyBibGFoIC0tPjxzcGFuPkFub3RoZXI8L3NwYW4+XG4gICAgICAgIC8vICAgICAgIGZyb20gPGRpdj5PSzwvZGl2PjwhLS0gL2tvIC0tPjwhLS0gL2tvIC0tPiwgICAgICAgICAgICAgcmV0dXJuczogPCEtLSAva28gLS0+PCEtLSAva28gLS0+XG4gICAgICAgIHZhciBjaGlsZE5vZGUgPSBub2RlLmZpcnN0Q2hpbGQsIGNhcHR1cmVSZW1haW5pbmcgPSBudWxsO1xuICAgICAgICBpZiAoY2hpbGROb2RlKSB7XG4gICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgaWYgKGNhcHR1cmVSZW1haW5pbmcpICAgICAgICAgICAgICAgICAgIC8vIFdlIGFscmVhZHkgaGl0IGFuIHVuYmFsYW5jZWQgbm9kZSBhbmQgYXJlIG5vdyBqdXN0IHNjb29waW5nIHVwIGFsbCBzdWJzZXF1ZW50IG5vZGVzXG4gICAgICAgICAgICAgICAgICAgIGNhcHR1cmVSZW1haW5pbmcucHVzaChjaGlsZE5vZGUpO1xuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGlzU3RhcnRDb21tZW50KGNoaWxkTm9kZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG1hdGNoaW5nRW5kQ29tbWVudCA9IGdldE1hdGNoaW5nRW5kQ29tbWVudChjaGlsZE5vZGUsIC8qIGFsbG93VW5iYWxhbmNlZDogKi8gdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtYXRjaGluZ0VuZENvbW1lbnQpICAgICAgICAgICAgIC8vIEl0J3MgYSBiYWxhbmNlZCB0YWcsIHNvIHNraXAgaW1tZWRpYXRlbHkgdG8gdGhlIGVuZCBvZiB0aGlzIHZpcnR1YWwgc2V0XG4gICAgICAgICAgICAgICAgICAgICAgICBjaGlsZE5vZGUgPSBtYXRjaGluZ0VuZENvbW1lbnQ7XG4gICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhcHR1cmVSZW1haW5pbmcgPSBbY2hpbGROb2RlXTsgLy8gSXQncyB1bmJhbGFuY2VkLCBzbyBzdGFydCBjYXB0dXJpbmcgZnJvbSB0aGlzIHBvaW50XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChpc0VuZENvbW1lbnQoY2hpbGROb2RlKSkge1xuICAgICAgICAgICAgICAgICAgICBjYXB0dXJlUmVtYWluaW5nID0gW2NoaWxkTm9kZV07ICAgICAvLyBJdCdzIHVuYmFsYW5jZWQgKGlmIGl0IHdhc24ndCwgd2UnZCBoYXZlIHNraXBwZWQgb3ZlciBpdCBhbHJlYWR5KSwgc28gc3RhcnQgY2FwdHVyaW5nXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSB3aGlsZSAoY2hpbGROb2RlID0gY2hpbGROb2RlLm5leHRTaWJsaW5nKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2FwdHVyZVJlbWFpbmluZztcbiAgICB9XG5cbiAgICBrby52aXJ0dWFsRWxlbWVudHMgPSB7XG4gICAgICAgIGFsbG93ZWRCaW5kaW5nczoge30sXG5cbiAgICAgICAgY2hpbGROb2RlczogZnVuY3Rpb24obm9kZSkge1xuICAgICAgICAgICAgcmV0dXJuIGlzU3RhcnRDb21tZW50KG5vZGUpID8gZ2V0VmlydHVhbENoaWxkcmVuKG5vZGUpIDogbm9kZS5jaGlsZE5vZGVzO1xuICAgICAgICB9LFxuXG4gICAgICAgIGVtcHR5Tm9kZTogZnVuY3Rpb24obm9kZSkge1xuICAgICAgICAgICAgaWYgKCFpc1N0YXJ0Q29tbWVudChub2RlKSlcbiAgICAgICAgICAgICAgICBrby51dGlscy5lbXB0eURvbU5vZGUobm9kZSk7XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgdmlydHVhbENoaWxkcmVuID0ga28udmlydHVhbEVsZW1lbnRzLmNoaWxkTm9kZXMobm9kZSk7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGogPSB2aXJ0dWFsQ2hpbGRyZW4ubGVuZ3RoOyBpIDwgajsgaSsrKVxuICAgICAgICAgICAgICAgICAgICBrby5yZW1vdmVOb2RlKHZpcnR1YWxDaGlsZHJlbltpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgc2V0RG9tTm9kZUNoaWxkcmVuOiBmdW5jdGlvbihub2RlLCBjaGlsZE5vZGVzKSB7XG4gICAgICAgICAgICBpZiAoIWlzU3RhcnRDb21tZW50KG5vZGUpKVxuICAgICAgICAgICAgICAgIGtvLnV0aWxzLnNldERvbU5vZGVDaGlsZHJlbihub2RlLCBjaGlsZE5vZGVzKTtcbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGtvLnZpcnR1YWxFbGVtZW50cy5lbXB0eU5vZGUobm9kZSk7XG4gICAgICAgICAgICAgICAgdmFyIGVuZENvbW1lbnROb2RlID0gbm9kZS5uZXh0U2libGluZzsgLy8gTXVzdCBiZSB0aGUgbmV4dCBzaWJsaW5nLCBhcyB3ZSBqdXN0IGVtcHRpZWQgdGhlIGNoaWxkcmVuXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGogPSBjaGlsZE5vZGVzLmxlbmd0aDsgaSA8IGo7IGkrKylcbiAgICAgICAgICAgICAgICAgICAgZW5kQ29tbWVudE5vZGUucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoY2hpbGROb2Rlc1tpXSwgZW5kQ29tbWVudE5vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIHByZXBlbmQ6IGZ1bmN0aW9uKGNvbnRhaW5lck5vZGUsIG5vZGVUb1ByZXBlbmQpIHtcbiAgICAgICAgICAgIGlmICghaXNTdGFydENvbW1lbnQoY29udGFpbmVyTm9kZSkpIHtcbiAgICAgICAgICAgICAgICBpZiAoY29udGFpbmVyTm9kZS5maXJzdENoaWxkKVxuICAgICAgICAgICAgICAgICAgICBjb250YWluZXJOb2RlLmluc2VydEJlZm9yZShub2RlVG9QcmVwZW5kLCBjb250YWluZXJOb2RlLmZpcnN0Q2hpbGQpO1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgY29udGFpbmVyTm9kZS5hcHBlbmRDaGlsZChub2RlVG9QcmVwZW5kKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gU3RhcnQgY29tbWVudHMgbXVzdCBhbHdheXMgaGF2ZSBhIHBhcmVudCBhbmQgYXQgbGVhc3Qgb25lIGZvbGxvd2luZyBzaWJsaW5nICh0aGUgZW5kIGNvbW1lbnQpXG4gICAgICAgICAgICAgICAgY29udGFpbmVyTm9kZS5wYXJlbnROb2RlLmluc2VydEJlZm9yZShub2RlVG9QcmVwZW5kLCBjb250YWluZXJOb2RlLm5leHRTaWJsaW5nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBpbnNlcnRBZnRlcjogZnVuY3Rpb24oY29udGFpbmVyTm9kZSwgbm9kZVRvSW5zZXJ0LCBpbnNlcnRBZnRlck5vZGUpIHtcbiAgICAgICAgICAgIGlmICghaW5zZXJ0QWZ0ZXJOb2RlKSB7XG4gICAgICAgICAgICAgICAga28udmlydHVhbEVsZW1lbnRzLnByZXBlbmQoY29udGFpbmVyTm9kZSwgbm9kZVRvSW5zZXJ0KTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIWlzU3RhcnRDb21tZW50KGNvbnRhaW5lck5vZGUpKSB7XG4gICAgICAgICAgICAgICAgLy8gSW5zZXJ0IGFmdGVyIGluc2VydGlvbiBwb2ludFxuICAgICAgICAgICAgICAgIGlmIChpbnNlcnRBZnRlck5vZGUubmV4dFNpYmxpbmcpXG4gICAgICAgICAgICAgICAgICAgIGNvbnRhaW5lck5vZGUuaW5zZXJ0QmVmb3JlKG5vZGVUb0luc2VydCwgaW5zZXJ0QWZ0ZXJOb2RlLm5leHRTaWJsaW5nKTtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIGNvbnRhaW5lck5vZGUuYXBwZW5kQ2hpbGQobm9kZVRvSW5zZXJ0KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gQ2hpbGRyZW4gb2Ygc3RhcnQgY29tbWVudHMgbXVzdCBhbHdheXMgaGF2ZSBhIHBhcmVudCBhbmQgYXQgbGVhc3Qgb25lIGZvbGxvd2luZyBzaWJsaW5nICh0aGUgZW5kIGNvbW1lbnQpXG4gICAgICAgICAgICAgICAgY29udGFpbmVyTm9kZS5wYXJlbnROb2RlLmluc2VydEJlZm9yZShub2RlVG9JbnNlcnQsIGluc2VydEFmdGVyTm9kZS5uZXh0U2libGluZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgZmlyc3RDaGlsZDogZnVuY3Rpb24obm9kZSkge1xuICAgICAgICAgICAgaWYgKCFpc1N0YXJ0Q29tbWVudChub2RlKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gbm9kZS5maXJzdENoaWxkO1xuICAgICAgICAgICAgaWYgKCFub2RlLm5leHRTaWJsaW5nIHx8IGlzRW5kQ29tbWVudChub2RlLm5leHRTaWJsaW5nKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIHJldHVybiBub2RlLm5leHRTaWJsaW5nO1xuICAgICAgICB9LFxuXG4gICAgICAgIG5leHRTaWJsaW5nOiBmdW5jdGlvbihub2RlKSB7XG4gICAgICAgICAgICBpZiAoaXNTdGFydENvbW1lbnQobm9kZSkpXG4gICAgICAgICAgICAgICAgbm9kZSA9IGdldE1hdGNoaW5nRW5kQ29tbWVudChub2RlKTtcbiAgICAgICAgICAgIGlmIChub2RlLm5leHRTaWJsaW5nICYmIGlzRW5kQ29tbWVudChub2RlLm5leHRTaWJsaW5nKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIHJldHVybiBub2RlLm5leHRTaWJsaW5nO1xuICAgICAgICB9LFxuXG4gICAgICAgIGhhc0JpbmRpbmdWYWx1ZTogaXNTdGFydENvbW1lbnQsXG5cbiAgICAgICAgdmlydHVhbE5vZGVCaW5kaW5nVmFsdWU6IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgICAgICAgIHZhciByZWdleE1hdGNoID0gKGNvbW1lbnROb2Rlc0hhdmVUZXh0UHJvcGVydHkgPyBub2RlLnRleHQgOiBub2RlLm5vZGVWYWx1ZSkubWF0Y2goc3RhcnRDb21tZW50UmVnZXgpO1xuICAgICAgICAgICAgcmV0dXJuIHJlZ2V4TWF0Y2ggPyByZWdleE1hdGNoWzFdIDogbnVsbDtcbiAgICAgICAgfSxcblxuICAgICAgICBub3JtYWxpc2VWaXJ0dWFsRWxlbWVudERvbVN0cnVjdHVyZTogZnVuY3Rpb24oZWxlbWVudFZlcmlmaWVkKSB7XG4gICAgICAgICAgICAvLyBXb3JrYXJvdW5kIGZvciBodHRwczovL2dpdGh1Yi5jb20vU3RldmVTYW5kZXJzb24va25vY2tvdXQvaXNzdWVzLzE1NVxuICAgICAgICAgICAgLy8gKElFIDw9IDggb3IgSUUgOSBxdWlya3MgbW9kZSBwYXJzZXMgeW91ciBIVE1MIHdlaXJkbHksIHRyZWF0aW5nIGNsb3NpbmcgPC9saT4gdGFncyBhcyBpZiB0aGV5IGRvbid0IGV4aXN0LCB0aGVyZWJ5IG1vdmluZyBjb21tZW50IG5vZGVzXG4gICAgICAgICAgICAvLyB0aGF0IGFyZSBkaXJlY3QgZGVzY2VuZGFudHMgb2YgPHVsPiBpbnRvIHRoZSBwcmVjZWRpbmcgPGxpPilcbiAgICAgICAgICAgIGlmICghaHRtbFRhZ3NXaXRoT3B0aW9uYWxseUNsb3NpbmdDaGlsZHJlbltrby51dGlscy50YWdOYW1lTG93ZXIoZWxlbWVudFZlcmlmaWVkKV0pXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuXG4gICAgICAgICAgICAvLyBTY2FuIGltbWVkaWF0ZSBjaGlsZHJlbiB0byBzZWUgaWYgdGhleSBjb250YWluIHVuYmFsYW5jZWQgY29tbWVudCB0YWdzLiBJZiB0aGV5IGRvLCB0aG9zZSBjb21tZW50IHRhZ3NcbiAgICAgICAgICAgIC8vIG11c3QgYmUgaW50ZW5kZWQgdG8gYXBwZWFyICphZnRlciogdGhhdCBjaGlsZCwgc28gbW92ZSB0aGVtIHRoZXJlLlxuICAgICAgICAgICAgdmFyIGNoaWxkTm9kZSA9IGVsZW1lbnRWZXJpZmllZC5maXJzdENoaWxkO1xuICAgICAgICAgICAgaWYgKGNoaWxkTm9kZSkge1xuICAgICAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNoaWxkTm9kZS5ub2RlVHlwZSA9PT0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHVuYmFsYW5jZWRUYWdzID0gZ2V0VW5iYWxhbmNlZENoaWxkVGFncyhjaGlsZE5vZGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHVuYmFsYW5jZWRUYWdzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRml4IHVwIHRoZSBET00gYnkgbW92aW5nIHRoZSB1bmJhbGFuY2VkIHRhZ3MgdG8gd2hlcmUgdGhleSBtb3N0IGxpa2VseSB3ZXJlIGludGVuZGVkIHRvIGJlIHBsYWNlZCAtICphZnRlciogdGhlIGNoaWxkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5vZGVUb0luc2VydEJlZm9yZSA9IGNoaWxkTm9kZS5uZXh0U2libGluZztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHVuYmFsYW5jZWRUYWdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChub2RlVG9JbnNlcnRCZWZvcmUpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50VmVyaWZpZWQuaW5zZXJ0QmVmb3JlKHVuYmFsYW5jZWRUYWdzW2ldLCBub2RlVG9JbnNlcnRCZWZvcmUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50VmVyaWZpZWQuYXBwZW5kQ2hpbGQodW5iYWxhbmNlZFRhZ3NbaV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gd2hpbGUgKGNoaWxkTm9kZSA9IGNoaWxkTm9kZS5uZXh0U2libGluZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xufSkoKTtcbmtvLmV4cG9ydFN5bWJvbCgndmlydHVhbEVsZW1lbnRzJywga28udmlydHVhbEVsZW1lbnRzKTtcbmtvLmV4cG9ydFN5bWJvbCgndmlydHVhbEVsZW1lbnRzLmFsbG93ZWRCaW5kaW5ncycsIGtvLnZpcnR1YWxFbGVtZW50cy5hbGxvd2VkQmluZGluZ3MpO1xua28uZXhwb3J0U3ltYm9sKCd2aXJ0dWFsRWxlbWVudHMuZW1wdHlOb2RlJywga28udmlydHVhbEVsZW1lbnRzLmVtcHR5Tm9kZSk7XG4vL2tvLmV4cG9ydFN5bWJvbCgndmlydHVhbEVsZW1lbnRzLmZpcnN0Q2hpbGQnLCBrby52aXJ0dWFsRWxlbWVudHMuZmlyc3RDaGlsZCk7ICAgICAvLyBmaXJzdENoaWxkIGlzIG5vdCBtaW5pZmllZFxua28uZXhwb3J0U3ltYm9sKCd2aXJ0dWFsRWxlbWVudHMuaW5zZXJ0QWZ0ZXInLCBrby52aXJ0dWFsRWxlbWVudHMuaW5zZXJ0QWZ0ZXIpO1xuLy9rby5leHBvcnRTeW1ib2woJ3ZpcnR1YWxFbGVtZW50cy5uZXh0U2libGluZycsIGtvLnZpcnR1YWxFbGVtZW50cy5uZXh0U2libGluZyk7ICAgLy8gbmV4dFNpYmxpbmcgaXMgbm90IG1pbmlmaWVkXG5rby5leHBvcnRTeW1ib2woJ3ZpcnR1YWxFbGVtZW50cy5wcmVwZW5kJywga28udmlydHVhbEVsZW1lbnRzLnByZXBlbmQpO1xua28uZXhwb3J0U3ltYm9sKCd2aXJ0dWFsRWxlbWVudHMuc2V0RG9tTm9kZUNoaWxkcmVuJywga28udmlydHVhbEVsZW1lbnRzLnNldERvbU5vZGVDaGlsZHJlbik7XG4oZnVuY3Rpb24oKSB7XG4gICAgdmFyIGRlZmF1bHRCaW5kaW5nQXR0cmlidXRlTmFtZSA9IFwiZGF0YS1iaW5kXCI7XG5cbiAgICBrby5iaW5kaW5nUHJvdmlkZXIgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5iaW5kaW5nQ2FjaGUgPSB7fTtcbiAgICB9O1xuXG4gICAga28udXRpbHMuZXh0ZW5kKGtvLmJpbmRpbmdQcm92aWRlci5wcm90b3R5cGUsIHtcbiAgICAgICAgJ25vZGVIYXNCaW5kaW5ncyc6IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgICAgICAgIHN3aXRjaCAobm9kZS5ub2RlVHlwZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgMTogLy8gRWxlbWVudFxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbm9kZS5nZXRBdHRyaWJ1dGUoZGVmYXVsdEJpbmRpbmdBdHRyaWJ1dGVOYW1lKSAhPSBudWxsXG4gICAgICAgICAgICAgICAgICAgICAgICB8fCBrby5jb21wb25lbnRzWydnZXRDb21wb25lbnROYW1lRm9yTm9kZSddKG5vZGUpO1xuICAgICAgICAgICAgICAgIGNhc2UgODogLy8gQ29tbWVudCBub2RlXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBrby52aXJ0dWFsRWxlbWVudHMuaGFzQmluZGluZ1ZhbHVlKG5vZGUpO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6IHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAnZ2V0QmluZGluZ3MnOiBmdW5jdGlvbihub2RlLCBiaW5kaW5nQ29udGV4dCkge1xuICAgICAgICAgICAgdmFyIGJpbmRpbmdzU3RyaW5nID0gdGhpc1snZ2V0QmluZGluZ3NTdHJpbmcnXShub2RlLCBiaW5kaW5nQ29udGV4dCksXG4gICAgICAgICAgICAgICAgcGFyc2VkQmluZGluZ3MgPSBiaW5kaW5nc1N0cmluZyA/IHRoaXNbJ3BhcnNlQmluZGluZ3NTdHJpbmcnXShiaW5kaW5nc1N0cmluZywgYmluZGluZ0NvbnRleHQsIG5vZGUpIDogbnVsbDtcbiAgICAgICAgICAgIHJldHVybiBrby5jb21wb25lbnRzLmFkZEJpbmRpbmdzRm9yQ3VzdG9tRWxlbWVudChwYXJzZWRCaW5kaW5ncywgbm9kZSwgYmluZGluZ0NvbnRleHQsIC8qIHZhbHVlQWNjZXNzb3JzICovIGZhbHNlKTtcbiAgICAgICAgfSxcblxuICAgICAgICAnZ2V0QmluZGluZ0FjY2Vzc29ycyc6IGZ1bmN0aW9uKG5vZGUsIGJpbmRpbmdDb250ZXh0KSB7XG4gICAgICAgICAgICB2YXIgYmluZGluZ3NTdHJpbmcgPSB0aGlzWydnZXRCaW5kaW5nc1N0cmluZyddKG5vZGUsIGJpbmRpbmdDb250ZXh0KSxcbiAgICAgICAgICAgICAgICBwYXJzZWRCaW5kaW5ncyA9IGJpbmRpbmdzU3RyaW5nID8gdGhpc1sncGFyc2VCaW5kaW5nc1N0cmluZyddKGJpbmRpbmdzU3RyaW5nLCBiaW5kaW5nQ29udGV4dCwgbm9kZSwgeyAndmFsdWVBY2Nlc3NvcnMnOiB0cnVlIH0pIDogbnVsbDtcbiAgICAgICAgICAgIHJldHVybiBrby5jb21wb25lbnRzLmFkZEJpbmRpbmdzRm9yQ3VzdG9tRWxlbWVudChwYXJzZWRCaW5kaW5ncywgbm9kZSwgYmluZGluZ0NvbnRleHQsIC8qIHZhbHVlQWNjZXNzb3JzICovIHRydWUpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8vIFRoZSBmb2xsb3dpbmcgZnVuY3Rpb24gaXMgb25seSB1c2VkIGludGVybmFsbHkgYnkgdGhpcyBkZWZhdWx0IHByb3ZpZGVyLlxuICAgICAgICAvLyBJdCdzIG5vdCBwYXJ0IG9mIHRoZSBpbnRlcmZhY2UgZGVmaW5pdGlvbiBmb3IgYSBnZW5lcmFsIGJpbmRpbmcgcHJvdmlkZXIuXG4gICAgICAgICdnZXRCaW5kaW5nc1N0cmluZyc6IGZ1bmN0aW9uKG5vZGUsIGJpbmRpbmdDb250ZXh0KSB7XG4gICAgICAgICAgICBzd2l0Y2ggKG5vZGUubm9kZVR5cGUpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDE6IHJldHVybiBub2RlLmdldEF0dHJpYnV0ZShkZWZhdWx0QmluZGluZ0F0dHJpYnV0ZU5hbWUpOyAgIC8vIEVsZW1lbnRcbiAgICAgICAgICAgICAgICBjYXNlIDg6IHJldHVybiBrby52aXJ0dWFsRWxlbWVudHMudmlydHVhbE5vZGVCaW5kaW5nVmFsdWUobm9kZSk7IC8vIENvbW1lbnQgbm9kZVxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6IHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8vIFRoZSBmb2xsb3dpbmcgZnVuY3Rpb24gaXMgb25seSB1c2VkIGludGVybmFsbHkgYnkgdGhpcyBkZWZhdWx0IHByb3ZpZGVyLlxuICAgICAgICAvLyBJdCdzIG5vdCBwYXJ0IG9mIHRoZSBpbnRlcmZhY2UgZGVmaW5pdGlvbiBmb3IgYSBnZW5lcmFsIGJpbmRpbmcgcHJvdmlkZXIuXG4gICAgICAgICdwYXJzZUJpbmRpbmdzU3RyaW5nJzogZnVuY3Rpb24oYmluZGluZ3NTdHJpbmcsIGJpbmRpbmdDb250ZXh0LCBub2RlLCBvcHRpb25zKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHZhciBiaW5kaW5nRnVuY3Rpb24gPSBjcmVhdGVCaW5kaW5nc1N0cmluZ0V2YWx1YXRvclZpYUNhY2hlKGJpbmRpbmdzU3RyaW5nLCB0aGlzLmJpbmRpbmdDYWNoZSwgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGJpbmRpbmdGdW5jdGlvbihiaW5kaW5nQ29udGV4dCwgbm9kZSk7XG4gICAgICAgICAgICB9IGNhdGNoIChleCkge1xuICAgICAgICAgICAgICAgIGV4Lm1lc3NhZ2UgPSBcIlVuYWJsZSB0byBwYXJzZSBiaW5kaW5ncy5cXG5CaW5kaW5ncyB2YWx1ZTogXCIgKyBiaW5kaW5nc1N0cmluZyArIFwiXFxuTWVzc2FnZTogXCIgKyBleC5tZXNzYWdlO1xuICAgICAgICAgICAgICAgIHRocm93IGV4O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICBrby5iaW5kaW5nUHJvdmlkZXJbJ2luc3RhbmNlJ10gPSBuZXcga28uYmluZGluZ1Byb3ZpZGVyKCk7XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVCaW5kaW5nc1N0cmluZ0V2YWx1YXRvclZpYUNhY2hlKGJpbmRpbmdzU3RyaW5nLCBjYWNoZSwgb3B0aW9ucykge1xuICAgICAgICB2YXIgY2FjaGVLZXkgPSBiaW5kaW5nc1N0cmluZyArIChvcHRpb25zICYmIG9wdGlvbnNbJ3ZhbHVlQWNjZXNzb3JzJ10gfHwgJycpO1xuICAgICAgICByZXR1cm4gY2FjaGVbY2FjaGVLZXldXG4gICAgICAgICAgICB8fCAoY2FjaGVbY2FjaGVLZXldID0gY3JlYXRlQmluZGluZ3NTdHJpbmdFdmFsdWF0b3IoYmluZGluZ3NTdHJpbmcsIG9wdGlvbnMpKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVCaW5kaW5nc1N0cmluZ0V2YWx1YXRvcihiaW5kaW5nc1N0cmluZywgb3B0aW9ucykge1xuICAgICAgICAvLyBCdWlsZCB0aGUgc291cmNlIGZvciBhIGZ1bmN0aW9uIHRoYXQgZXZhbHVhdGVzIFwiZXhwcmVzc2lvblwiXG4gICAgICAgIC8vIEZvciBlYWNoIHNjb3BlIHZhcmlhYmxlLCBhZGQgYW4gZXh0cmEgbGV2ZWwgb2YgXCJ3aXRoXCIgbmVzdGluZ1xuICAgICAgICAvLyBFeGFtcGxlIHJlc3VsdDogd2l0aChzYzEpIHsgd2l0aChzYzApIHsgcmV0dXJuIChleHByZXNzaW9uKSB9IH1cbiAgICAgICAgdmFyIHJld3JpdHRlbkJpbmRpbmdzID0ga28uZXhwcmVzc2lvblJld3JpdGluZy5wcmVQcm9jZXNzQmluZGluZ3MoYmluZGluZ3NTdHJpbmcsIG9wdGlvbnMpLFxuICAgICAgICAgICAgZnVuY3Rpb25Cb2R5ID0gXCJ3aXRoKCRjb250ZXh0KXt3aXRoKCRkYXRhfHx7fSl7cmV0dXJue1wiICsgcmV3cml0dGVuQmluZGluZ3MgKyBcIn19fVwiO1xuICAgICAgICByZXR1cm4gbmV3IEZ1bmN0aW9uKFwiJGNvbnRleHRcIiwgXCIkZWxlbWVudFwiLCBmdW5jdGlvbkJvZHkpO1xuICAgIH1cbn0pKCk7XG5cbmtvLmV4cG9ydFN5bWJvbCgnYmluZGluZ1Byb3ZpZGVyJywga28uYmluZGluZ1Byb3ZpZGVyKTtcbihmdW5jdGlvbiAoKSB7XG4gICAga28uYmluZGluZ0hhbmRsZXJzID0ge307XG5cbiAgICAvLyBUaGUgZm9sbG93aW5nIGVsZW1lbnQgdHlwZXMgd2lsbCBub3QgYmUgcmVjdXJzZWQgaW50byBkdXJpbmcgYmluZGluZy5cbiAgICB2YXIgYmluZGluZ0RvZXNOb3RSZWN1cnNlSW50b0VsZW1lbnRUeXBlcyA9IHtcbiAgICAgICAgLy8gRG9uJ3Qgd2FudCBiaW5kaW5ncyB0aGF0IG9wZXJhdGUgb24gdGV4dCBub2RlcyB0byBtdXRhdGUgPHNjcmlwdD4gYW5kIDx0ZXh0YXJlYT4gY29udGVudHMsXG4gICAgICAgIC8vIGJlY2F1c2UgaXQncyB1bmV4cGVjdGVkIGFuZCBhIHBvdGVudGlhbCBYU1MgaXNzdWUuXG4gICAgICAgIC8vIEFsc28gYmluZGluZ3Mgc2hvdWxkIG5vdCBvcGVyYXRlIG9uIDx0ZW1wbGF0ZT4gZWxlbWVudHMgc2luY2UgdGhpcyBicmVha3MgaW4gSW50ZXJuZXQgRXhwbG9yZXJcbiAgICAgICAgLy8gYW5kIGJlY2F1c2Ugc3VjaCBlbGVtZW50cycgY29udGVudHMgYXJlIGFsd2F5cyBpbnRlbmRlZCB0byBiZSBib3VuZCBpbiBhIGRpZmZlcmVudCBjb250ZXh0XG4gICAgICAgIC8vIGZyb20gd2hlcmUgdGhleSBhcHBlYXIgaW4gdGhlIGRvY3VtZW50LlxuICAgICAgICAnc2NyaXB0JzogdHJ1ZSxcbiAgICAgICAgJ3RleHRhcmVhJzogdHJ1ZSxcbiAgICAgICAgJ3RlbXBsYXRlJzogdHJ1ZVxuICAgIH07XG5cbiAgICAvLyBVc2UgYW4gb3ZlcnJpZGFibGUgbWV0aG9kIGZvciByZXRyaWV2aW5nIGJpbmRpbmcgaGFuZGxlcnMgc28gdGhhdCBhIHBsdWdpbnMgbWF5IHN1cHBvcnQgZHluYW1pY2FsbHkgY3JlYXRlZCBoYW5kbGVyc1xuICAgIGtvWydnZXRCaW5kaW5nSGFuZGxlciddID0gZnVuY3Rpb24oYmluZGluZ0tleSkge1xuICAgICAgICByZXR1cm4ga28uYmluZGluZ0hhbmRsZXJzW2JpbmRpbmdLZXldO1xuICAgIH07XG5cbiAgICAvLyBUaGUga28uYmluZGluZ0NvbnRleHQgY29uc3RydWN0b3IgaXMgb25seSBjYWxsZWQgZGlyZWN0bHkgdG8gY3JlYXRlIHRoZSByb290IGNvbnRleHQuIEZvciBjaGlsZFxuICAgIC8vIGNvbnRleHRzLCB1c2UgYmluZGluZ0NvbnRleHQuY3JlYXRlQ2hpbGRDb250ZXh0IG9yIGJpbmRpbmdDb250ZXh0LmV4dGVuZC5cbiAgICBrby5iaW5kaW5nQ29udGV4dCA9IGZ1bmN0aW9uKGRhdGFJdGVtT3JBY2Nlc3NvciwgcGFyZW50Q29udGV4dCwgZGF0YUl0ZW1BbGlhcywgZXh0ZW5kQ2FsbGJhY2ssIG9wdGlvbnMpIHtcblxuICAgICAgICAvLyBUaGUgYmluZGluZyBjb250ZXh0IG9iamVjdCBpbmNsdWRlcyBzdGF0aWMgcHJvcGVydGllcyBmb3IgdGhlIGN1cnJlbnQsIHBhcmVudCwgYW5kIHJvb3QgdmlldyBtb2RlbHMuXG4gICAgICAgIC8vIElmIGEgdmlldyBtb2RlbCBpcyBhY3R1YWxseSBzdG9yZWQgaW4gYW4gb2JzZXJ2YWJsZSwgdGhlIGNvcnJlc3BvbmRpbmcgYmluZGluZyBjb250ZXh0IG9iamVjdCwgYW5kXG4gICAgICAgIC8vIGFueSBjaGlsZCBjb250ZXh0cywgbXVzdCBiZSB1cGRhdGVkIHdoZW4gdGhlIHZpZXcgbW9kZWwgaXMgY2hhbmdlZC5cbiAgICAgICAgZnVuY3Rpb24gdXBkYXRlQ29udGV4dCgpIHtcbiAgICAgICAgICAgIC8vIE1vc3Qgb2YgdGhlIHRpbWUsIHRoZSBjb250ZXh0IHdpbGwgZGlyZWN0bHkgZ2V0IGEgdmlldyBtb2RlbCBvYmplY3QsIGJ1dCBpZiBhIGZ1bmN0aW9uIGlzIGdpdmVuLFxuICAgICAgICAgICAgLy8gd2UgY2FsbCB0aGUgZnVuY3Rpb24gdG8gcmV0cmlldmUgdGhlIHZpZXcgbW9kZWwuIElmIHRoZSBmdW5jdGlvbiBhY2Nlc3NlcyBhbnkgb2JzZXJ2YWJsZXMgb3IgcmV0dXJuc1xuICAgICAgICAgICAgLy8gYW4gb2JzZXJ2YWJsZSwgdGhlIGRlcGVuZGVuY3kgaXMgdHJhY2tlZCwgYW5kIHRob3NlIG9ic2VydmFibGVzIGNhbiBsYXRlciBjYXVzZSB0aGUgYmluZGluZ1xuICAgICAgICAgICAgLy8gY29udGV4dCB0byBiZSB1cGRhdGVkLlxuICAgICAgICAgICAgdmFyIGRhdGFJdGVtT3JPYnNlcnZhYmxlID0gaXNGdW5jID8gZGF0YUl0ZW1PckFjY2Vzc29yKCkgOiBkYXRhSXRlbU9yQWNjZXNzb3IsXG4gICAgICAgICAgICAgICAgZGF0YUl0ZW0gPSBrby51dGlscy51bndyYXBPYnNlcnZhYmxlKGRhdGFJdGVtT3JPYnNlcnZhYmxlKTtcblxuICAgICAgICAgICAgaWYgKHBhcmVudENvbnRleHQpIHtcbiAgICAgICAgICAgICAgICAvLyBXaGVuIGEgXCJwYXJlbnRcIiBjb250ZXh0IGlzIGdpdmVuLCByZWdpc3RlciBhIGRlcGVuZGVuY3kgb24gdGhlIHBhcmVudCBjb250ZXh0LiBUaHVzIHdoZW5ldmVyIHRoZVxuICAgICAgICAgICAgICAgIC8vIHBhcmVudCBjb250ZXh0IGlzIHVwZGF0ZWQsIHRoaXMgY29udGV4dCB3aWxsIGFsc28gYmUgdXBkYXRlZC5cbiAgICAgICAgICAgICAgICBpZiAocGFyZW50Q29udGV4dC5fc3Vic2NyaWJhYmxlKVxuICAgICAgICAgICAgICAgICAgICBwYXJlbnRDb250ZXh0Ll9zdWJzY3JpYmFibGUoKTtcblxuICAgICAgICAgICAgICAgIC8vIENvcHkgJHJvb3QgYW5kIGFueSBjdXN0b20gcHJvcGVydGllcyBmcm9tIHRoZSBwYXJlbnQgY29udGV4dFxuICAgICAgICAgICAgICAgIGtvLnV0aWxzLmV4dGVuZChzZWxmLCBwYXJlbnRDb250ZXh0KTtcblxuICAgICAgICAgICAgICAgIC8vIEJlY2F1c2UgdGhlIGFib3ZlIGNvcHkgb3ZlcndyaXRlcyBvdXIgb3duIHByb3BlcnRpZXMsIHdlIG5lZWQgdG8gcmVzZXQgdGhlbS5cbiAgICAgICAgICAgICAgICBzZWxmLl9zdWJzY3JpYmFibGUgPSBzdWJzY3JpYmFibGU7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHNlbGZbJyRwYXJlbnRzJ10gPSBbXTtcbiAgICAgICAgICAgICAgICBzZWxmWyckcm9vdCddID0gZGF0YUl0ZW07XG5cbiAgICAgICAgICAgICAgICAvLyBFeHBvcnQgJ2tvJyBpbiB0aGUgYmluZGluZyBjb250ZXh0IHNvIGl0IHdpbGwgYmUgYXZhaWxhYmxlIGluIGJpbmRpbmdzIGFuZCB0ZW1wbGF0ZXNcbiAgICAgICAgICAgICAgICAvLyBldmVuIGlmICdrbycgaXNuJ3QgZXhwb3J0ZWQgYXMgYSBnbG9iYWwsIHN1Y2ggYXMgd2hlbiB1c2luZyBhbiBBTUQgbG9hZGVyLlxuICAgICAgICAgICAgICAgIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vU3RldmVTYW5kZXJzb24va25vY2tvdXQvaXNzdWVzLzQ5MFxuICAgICAgICAgICAgICAgIHNlbGZbJ2tvJ10gPSBrbztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNlbGZbJyRyYXdEYXRhJ10gPSBkYXRhSXRlbU9yT2JzZXJ2YWJsZTtcbiAgICAgICAgICAgIHNlbGZbJyRkYXRhJ10gPSBkYXRhSXRlbTtcbiAgICAgICAgICAgIGlmIChkYXRhSXRlbUFsaWFzKVxuICAgICAgICAgICAgICAgIHNlbGZbZGF0YUl0ZW1BbGlhc10gPSBkYXRhSXRlbTtcblxuICAgICAgICAgICAgLy8gVGhlIGV4dGVuZENhbGxiYWNrIGZ1bmN0aW9uIGlzIHByb3ZpZGVkIHdoZW4gY3JlYXRpbmcgYSBjaGlsZCBjb250ZXh0IG9yIGV4dGVuZGluZyBhIGNvbnRleHQuXG4gICAgICAgICAgICAvLyBJdCBoYW5kbGVzIHRoZSBzcGVjaWZpYyBhY3Rpb25zIG5lZWRlZCB0byBmaW5pc2ggc2V0dGluZyB1cCB0aGUgYmluZGluZyBjb250ZXh0LiBBY3Rpb25zIGluIHRoaXNcbiAgICAgICAgICAgIC8vIGZ1bmN0aW9uIGNvdWxkIGFsc28gYWRkIGRlcGVuZGVuY2llcyB0byB0aGlzIGJpbmRpbmcgY29udGV4dC5cbiAgICAgICAgICAgIGlmIChleHRlbmRDYWxsYmFjaylcbiAgICAgICAgICAgICAgICBleHRlbmRDYWxsYmFjayhzZWxmLCBwYXJlbnRDb250ZXh0LCBkYXRhSXRlbSk7XG5cbiAgICAgICAgICAgIHJldHVybiBzZWxmWyckZGF0YSddO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGRpc3Bvc2VXaGVuKCkge1xuICAgICAgICAgICAgcmV0dXJuIG5vZGVzICYmICFrby51dGlscy5hbnlEb21Ob2RlSXNBdHRhY2hlZFRvRG9jdW1lbnQobm9kZXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzLFxuICAgICAgICAgICAgaXNGdW5jID0gdHlwZW9mKGRhdGFJdGVtT3JBY2Nlc3NvcikgPT0gXCJmdW5jdGlvblwiICYmICFrby5pc09ic2VydmFibGUoZGF0YUl0ZW1PckFjY2Vzc29yKSxcbiAgICAgICAgICAgIG5vZGVzLFxuICAgICAgICAgICAgc3Vic2NyaWJhYmxlO1xuXG4gICAgICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnNbJ2V4cG9ydERlcGVuZGVuY2llcyddKSB7XG4gICAgICAgICAgICAvLyBUaGUgXCJleHBvcnREZXBlbmRlbmNpZXNcIiBvcHRpb24gbWVhbnMgdGhhdCB0aGUgY2FsbGluZyBjb2RlIHdpbGwgdHJhY2sgYW55IGRlcGVuZGVuY2llcyBhbmQgcmUtY3JlYXRlXG4gICAgICAgICAgICAvLyB0aGUgYmluZGluZyBjb250ZXh0IHdoZW4gdGhleSBjaGFuZ2UuXG4gICAgICAgICAgICB1cGRhdGVDb250ZXh0KCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzdWJzY3JpYmFibGUgPSBrby5kZXBlbmRlbnRPYnNlcnZhYmxlKHVwZGF0ZUNvbnRleHQsIG51bGwsIHsgZGlzcG9zZVdoZW46IGRpc3Bvc2VXaGVuLCBkaXNwb3NlV2hlbk5vZGVJc1JlbW92ZWQ6IHRydWUgfSk7XG5cbiAgICAgICAgICAgIC8vIEF0IHRoaXMgcG9pbnQsIHRoZSBiaW5kaW5nIGNvbnRleHQgaGFzIGJlZW4gaW5pdGlhbGl6ZWQsIGFuZCB0aGUgXCJzdWJzY3JpYmFibGVcIiBjb21wdXRlZCBvYnNlcnZhYmxlIGlzXG4gICAgICAgICAgICAvLyBzdWJzY3JpYmVkIHRvIGFueSBvYnNlcnZhYmxlcyB0aGF0IHdlcmUgYWNjZXNzZWQgaW4gdGhlIHByb2Nlc3MuIElmIHRoZXJlIGlzIG5vdGhpbmcgdG8gdHJhY2ssIHRoZVxuICAgICAgICAgICAgLy8gY29tcHV0ZWQgd2lsbCBiZSBpbmFjdGl2ZSwgYW5kIHdlIGNhbiBzYWZlbHkgdGhyb3cgaXQgYXdheS4gSWYgaXQncyBhY3RpdmUsIHRoZSBjb21wdXRlZCBpcyBzdG9yZWQgaW5cbiAgICAgICAgICAgIC8vIHRoZSBjb250ZXh0IG9iamVjdC5cbiAgICAgICAgICAgIGlmIChzdWJzY3JpYmFibGUuaXNBY3RpdmUoKSkge1xuICAgICAgICAgICAgICAgIHNlbGYuX3N1YnNjcmliYWJsZSA9IHN1YnNjcmliYWJsZTtcblxuICAgICAgICAgICAgICAgIC8vIEFsd2F5cyBub3RpZnkgYmVjYXVzZSBldmVuIGlmIHRoZSBtb2RlbCAoJGRhdGEpIGhhc24ndCBjaGFuZ2VkLCBvdGhlciBjb250ZXh0IHByb3BlcnRpZXMgbWlnaHQgaGF2ZSBjaGFuZ2VkXG4gICAgICAgICAgICAgICAgc3Vic2NyaWJhYmxlWydlcXVhbGl0eUNvbXBhcmVyJ10gPSBudWxsO1xuXG4gICAgICAgICAgICAgICAgLy8gV2UgbmVlZCB0byBiZSBhYmxlIHRvIGRpc3Bvc2Ugb2YgdGhpcyBjb21wdXRlZCBvYnNlcnZhYmxlIHdoZW4gaXQncyBubyBsb25nZXIgbmVlZGVkLiBUaGlzIHdvdWxkIGJlXG4gICAgICAgICAgICAgICAgLy8gZWFzeSBpZiB3ZSBoYWQgYSBzaW5nbGUgbm9kZSB0byB3YXRjaCwgYnV0IGJpbmRpbmcgY29udGV4dHMgY2FuIGJlIHVzZWQgYnkgbWFueSBkaWZmZXJlbnQgbm9kZXMsIGFuZFxuICAgICAgICAgICAgICAgIC8vIHdlIGNhbm5vdCBhc3N1bWUgdGhhdCB0aG9zZSBub2RlcyBoYXZlIGFueSByZWxhdGlvbiB0byBlYWNoIG90aGVyLiBTbyBpbnN0ZWFkIHdlIHRyYWNrIGFueSBub2RlIHRoYXRcbiAgICAgICAgICAgICAgICAvLyB0aGUgY29udGV4dCBpcyBhdHRhY2hlZCB0bywgYW5kIGRpc3Bvc2UgdGhlIGNvbXB1dGVkIHdoZW4gYWxsIG9mIHRob3NlIG5vZGVzIGhhdmUgYmVlbiBjbGVhbmVkLlxuXG4gICAgICAgICAgICAgICAgLy8gQWRkIHByb3BlcnRpZXMgdG8gKnN1YnNjcmliYWJsZSogaW5zdGVhZCBvZiAqc2VsZiogYmVjYXVzZSBhbnkgcHJvcGVydGllcyBhZGRlZCB0byAqc2VsZiogbWF5IGJlIG92ZXJ3cml0dGVuIG9uIHVwZGF0ZXNcbiAgICAgICAgICAgICAgICBub2RlcyA9IFtdO1xuICAgICAgICAgICAgICAgIHN1YnNjcmliYWJsZS5fYWRkTm9kZSA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZXMucHVzaChub2RlKTtcbiAgICAgICAgICAgICAgICAgICAga28udXRpbHMuZG9tTm9kZURpc3Bvc2FsLmFkZERpc3Bvc2VDYWxsYmFjayhub2RlLCBmdW5jdGlvbihub2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBrby51dGlscy5hcnJheVJlbW92ZUl0ZW0obm9kZXMsIG5vZGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFub2Rlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdWJzY3JpYmFibGUuZGlzcG9zZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuX3N1YnNjcmliYWJsZSA9IHN1YnNjcmliYWJsZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIEV4dGVuZCB0aGUgYmluZGluZyBjb250ZXh0IGhpZXJhcmNoeSB3aXRoIGEgbmV3IHZpZXcgbW9kZWwgb2JqZWN0LiBJZiB0aGUgcGFyZW50IGNvbnRleHQgaXMgd2F0Y2hpbmdcbiAgICAvLyBhbnkgb2JzZXJ2YWJsZXMsIHRoZSBuZXcgY2hpbGQgY29udGV4dCB3aWxsIGF1dG9tYXRpY2FsbHkgZ2V0IGEgZGVwZW5kZW5jeSBvbiB0aGUgcGFyZW50IGNvbnRleHQuXG4gICAgLy8gQnV0IHRoaXMgZG9lcyBub3QgbWVhbiB0aGF0IHRoZSAkZGF0YSB2YWx1ZSBvZiB0aGUgY2hpbGQgY29udGV4dCB3aWxsIGFsc28gZ2V0IHVwZGF0ZWQuIElmIHRoZSBjaGlsZFxuICAgIC8vIHZpZXcgbW9kZWwgYWxzbyBkZXBlbmRzIG9uIHRoZSBwYXJlbnQgdmlldyBtb2RlbCwgeW91IG11c3QgcHJvdmlkZSBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0aGUgY29ycmVjdFxuICAgIC8vIHZpZXcgbW9kZWwgb24gZWFjaCB1cGRhdGUuXG4gICAga28uYmluZGluZ0NvbnRleHQucHJvdG90eXBlWydjcmVhdGVDaGlsZENvbnRleHQnXSA9IGZ1bmN0aW9uIChkYXRhSXRlbU9yQWNjZXNzb3IsIGRhdGFJdGVtQWxpYXMsIGV4dGVuZENhbGxiYWNrLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBuZXcga28uYmluZGluZ0NvbnRleHQoZGF0YUl0ZW1PckFjY2Vzc29yLCB0aGlzLCBkYXRhSXRlbUFsaWFzLCBmdW5jdGlvbihzZWxmLCBwYXJlbnRDb250ZXh0KSB7XG4gICAgICAgICAgICAvLyBFeHRlbmQgdGhlIGNvbnRleHQgaGllcmFyY2h5IGJ5IHNldHRpbmcgdGhlIGFwcHJvcHJpYXRlIHBvaW50ZXJzXG4gICAgICAgICAgICBzZWxmWyckcGFyZW50Q29udGV4dCddID0gcGFyZW50Q29udGV4dDtcbiAgICAgICAgICAgIHNlbGZbJyRwYXJlbnQnXSA9IHBhcmVudENvbnRleHRbJyRkYXRhJ107XG4gICAgICAgICAgICBzZWxmWyckcGFyZW50cyddID0gKHBhcmVudENvbnRleHRbJyRwYXJlbnRzJ10gfHwgW10pLnNsaWNlKDApO1xuICAgICAgICAgICAgc2VsZlsnJHBhcmVudHMnXS51bnNoaWZ0KHNlbGZbJyRwYXJlbnQnXSk7XG4gICAgICAgICAgICBpZiAoZXh0ZW5kQ2FsbGJhY2spXG4gICAgICAgICAgICAgICAgZXh0ZW5kQ2FsbGJhY2soc2VsZik7XG4gICAgICAgIH0sIG9wdGlvbnMpO1xuICAgIH07XG5cbiAgICAvLyBFeHRlbmQgdGhlIGJpbmRpbmcgY29udGV4dCB3aXRoIG5ldyBjdXN0b20gcHJvcGVydGllcy4gVGhpcyBkb2Vzbid0IGNoYW5nZSB0aGUgY29udGV4dCBoaWVyYXJjaHkuXG4gICAgLy8gU2ltaWxhcmx5IHRvIFwiY2hpbGRcIiBjb250ZXh0cywgcHJvdmlkZSBhIGZ1bmN0aW9uIGhlcmUgdG8gbWFrZSBzdXJlIHRoYXQgdGhlIGNvcnJlY3QgdmFsdWVzIGFyZSBzZXRcbiAgICAvLyB3aGVuIGFuIG9ic2VydmFibGUgdmlldyBtb2RlbCBpcyB1cGRhdGVkLlxuICAgIGtvLmJpbmRpbmdDb250ZXh0LnByb3RvdHlwZVsnZXh0ZW5kJ10gPSBmdW5jdGlvbihwcm9wZXJ0aWVzKSB7XG4gICAgICAgIC8vIElmIHRoZSBwYXJlbnQgY29udGV4dCByZWZlcmVuY2VzIGFuIG9ic2VydmFibGUgdmlldyBtb2RlbCwgXCJfc3Vic2NyaWJhYmxlXCIgd2lsbCBhbHdheXMgYmUgdGhlXG4gICAgICAgIC8vIGxhdGVzdCB2aWV3IG1vZGVsIG9iamVjdC4gSWYgbm90LCBcIl9zdWJzY3JpYmFibGVcIiBpc24ndCBzZXQsIGFuZCB3ZSBjYW4gdXNlIHRoZSBzdGF0aWMgXCIkZGF0YVwiIHZhbHVlLlxuICAgICAgICByZXR1cm4gbmV3IGtvLmJpbmRpbmdDb250ZXh0KHRoaXMuX3N1YnNjcmliYWJsZSB8fCB0aGlzWyckZGF0YSddLCB0aGlzLCBudWxsLCBmdW5jdGlvbihzZWxmLCBwYXJlbnRDb250ZXh0KSB7XG4gICAgICAgICAgICAvLyBUaGlzIFwiY2hpbGRcIiBjb250ZXh0IGRvZXNuJ3QgZGlyZWN0bHkgdHJhY2sgYSBwYXJlbnQgb2JzZXJ2YWJsZSB2aWV3IG1vZGVsLFxuICAgICAgICAgICAgLy8gc28gd2UgbmVlZCB0byBtYW51YWxseSBzZXQgdGhlICRyYXdEYXRhIHZhbHVlIHRvIG1hdGNoIHRoZSBwYXJlbnQuXG4gICAgICAgICAgICBzZWxmWyckcmF3RGF0YSddID0gcGFyZW50Q29udGV4dFsnJHJhd0RhdGEnXTtcbiAgICAgICAgICAgIGtvLnV0aWxzLmV4dGVuZChzZWxmLCB0eXBlb2YocHJvcGVydGllcykgPT0gXCJmdW5jdGlvblwiID8gcHJvcGVydGllcygpIDogcHJvcGVydGllcyk7XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICBrby5iaW5kaW5nQ29udGV4dC5wcm90b3R5cGUuY3JlYXRlU3RhdGljQ2hpbGRDb250ZXh0ID0gZnVuY3Rpb24gKGRhdGFJdGVtT3JBY2Nlc3NvciwgZGF0YUl0ZW1BbGlhcykge1xuICAgICAgICByZXR1cm4gdGhpc1snY3JlYXRlQ2hpbGRDb250ZXh0J10oZGF0YUl0ZW1PckFjY2Vzc29yLCBkYXRhSXRlbUFsaWFzLCBudWxsLCB7IFwiZXhwb3J0RGVwZW5kZW5jaWVzXCI6IHRydWUgfSk7XG4gICAgfTtcblxuICAgIC8vIFJldHVybnMgdGhlIHZhbHVlQWNjZXNvciBmdW5jdGlvbiBmb3IgYSBiaW5kaW5nIHZhbHVlXG4gICAgZnVuY3Rpb24gbWFrZVZhbHVlQWNjZXNzb3IodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8vIFJldHVybnMgdGhlIHZhbHVlIG9mIGEgdmFsdWVBY2Nlc3NvciBmdW5jdGlvblxuICAgIGZ1bmN0aW9uIGV2YWx1YXRlVmFsdWVBY2Nlc3Nvcih2YWx1ZUFjY2Vzc29yKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZUFjY2Vzc29yKCk7XG4gICAgfVxuXG4gICAgLy8gR2l2ZW4gYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgYmluZGluZ3MsIGNyZWF0ZSBhbmQgcmV0dXJuIGEgbmV3IG9iamVjdCB0aGF0IGNvbnRhaW5zXG4gICAgLy8gYmluZGluZyB2YWx1ZS1hY2Nlc3NvcnMgZnVuY3Rpb25zLiBFYWNoIGFjY2Vzc29yIGZ1bmN0aW9uIGNhbGxzIHRoZSBvcmlnaW5hbCBmdW5jdGlvblxuICAgIC8vIHNvIHRoYXQgaXQgYWx3YXlzIGdldHMgdGhlIGxhdGVzdCB2YWx1ZSBhbmQgYWxsIGRlcGVuZGVuY2llcyBhcmUgY2FwdHVyZWQuIFRoaXMgaXMgdXNlZFxuICAgIC8vIGJ5IGtvLmFwcGx5QmluZGluZ3NUb05vZGUgYW5kIGdldEJpbmRpbmdzQW5kTWFrZUFjY2Vzc29ycy5cbiAgICBmdW5jdGlvbiBtYWtlQWNjZXNzb3JzRnJvbUZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gICAgICAgIHJldHVybiBrby51dGlscy5vYmplY3RNYXAoa28uZGVwZW5kZW5jeURldGVjdGlvbi5pZ25vcmUoY2FsbGJhY2spLCBmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKClba2V5XTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIEdpdmVuIGEgYmluZGluZ3MgZnVuY3Rpb24gb3Igb2JqZWN0LCBjcmVhdGUgYW5kIHJldHVybiBhIG5ldyBvYmplY3QgdGhhdCBjb250YWluc1xuICAgIC8vIGJpbmRpbmcgdmFsdWUtYWNjZXNzb3JzIGZ1bmN0aW9ucy4gVGhpcyBpcyB1c2VkIGJ5IGtvLmFwcGx5QmluZGluZ3NUb05vZGUuXG4gICAgZnVuY3Rpb24gbWFrZUJpbmRpbmdBY2Nlc3NvcnMoYmluZGluZ3MsIGNvbnRleHQsIG5vZGUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBiaW5kaW5ncyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgcmV0dXJuIG1ha2VBY2Nlc3NvcnNGcm9tRnVuY3Rpb24oYmluZGluZ3MuYmluZChudWxsLCBjb250ZXh0LCBub2RlKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4ga28udXRpbHMub2JqZWN0TWFwKGJpbmRpbmdzLCBtYWtlVmFsdWVBY2Nlc3Nvcik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBUaGlzIGZ1bmN0aW9uIGlzIHVzZWQgaWYgdGhlIGJpbmRpbmcgcHJvdmlkZXIgZG9lc24ndCBpbmNsdWRlIGEgZ2V0QmluZGluZ0FjY2Vzc29ycyBmdW5jdGlvbi5cbiAgICAvLyBJdCBtdXN0IGJlIGNhbGxlZCB3aXRoICd0aGlzJyBzZXQgdG8gdGhlIHByb3ZpZGVyIGluc3RhbmNlLlxuICAgIGZ1bmN0aW9uIGdldEJpbmRpbmdzQW5kTWFrZUFjY2Vzc29ycyhub2RlLCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiBtYWtlQWNjZXNzb3JzRnJvbUZ1bmN0aW9uKHRoaXNbJ2dldEJpbmRpbmdzJ10uYmluZCh0aGlzLCBub2RlLCBjb250ZXh0KSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdmFsaWRhdGVUaGF0QmluZGluZ0lzQWxsb3dlZEZvclZpcnR1YWxFbGVtZW50cyhiaW5kaW5nTmFtZSkge1xuICAgICAgICB2YXIgdmFsaWRhdG9yID0ga28udmlydHVhbEVsZW1lbnRzLmFsbG93ZWRCaW5kaW5nc1tiaW5kaW5nTmFtZV07XG4gICAgICAgIGlmICghdmFsaWRhdG9yKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlIGJpbmRpbmcgJ1wiICsgYmluZGluZ05hbWUgKyBcIicgY2Fubm90IGJlIHVzZWQgd2l0aCB2aXJ0dWFsIGVsZW1lbnRzXCIpXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYXBwbHlCaW5kaW5nc1RvRGVzY2VuZGFudHNJbnRlcm5hbCAoYmluZGluZ0NvbnRleHQsIGVsZW1lbnRPclZpcnR1YWxFbGVtZW50LCBiaW5kaW5nQ29udGV4dHNNYXlEaWZmZXJGcm9tRG9tUGFyZW50RWxlbWVudCkge1xuICAgICAgICB2YXIgY3VycmVudENoaWxkLFxuICAgICAgICAgICAgbmV4dEluUXVldWUgPSBrby52aXJ0dWFsRWxlbWVudHMuZmlyc3RDaGlsZChlbGVtZW50T3JWaXJ0dWFsRWxlbWVudCksXG4gICAgICAgICAgICBwcm92aWRlciA9IGtvLmJpbmRpbmdQcm92aWRlclsnaW5zdGFuY2UnXSxcbiAgICAgICAgICAgIHByZXByb2Nlc3NOb2RlID0gcHJvdmlkZXJbJ3ByZXByb2Nlc3NOb2RlJ107XG5cbiAgICAgICAgLy8gUHJlcHJvY2Vzc2luZyBhbGxvd3MgYSBiaW5kaW5nIHByb3ZpZGVyIHRvIG11dGF0ZSBhIG5vZGUgYmVmb3JlIGJpbmRpbmdzIGFyZSBhcHBsaWVkIHRvIGl0LiBGb3IgZXhhbXBsZSBpdCdzXG4gICAgICAgIC8vIHBvc3NpYmxlIHRvIGluc2VydCBuZXcgc2libGluZ3MgYWZ0ZXIgaXQsIGFuZC9vciByZXBsYWNlIHRoZSBub2RlIHdpdGggYSBkaWZmZXJlbnQgb25lLiBUaGlzIGNhbiBiZSB1c2VkIHRvXG4gICAgICAgIC8vIGltcGxlbWVudCBjdXN0b20gYmluZGluZyBzeW50YXhlcywgc3VjaCBhcyB7eyB2YWx1ZSB9fSBmb3Igc3RyaW5nIGludGVycG9sYXRpb24sIG9yIGN1c3RvbSBlbGVtZW50IHR5cGVzIHRoYXRcbiAgICAgICAgLy8gdHJpZ2dlciBpbnNlcnRpb24gb2YgPHRlbXBsYXRlPiBjb250ZW50cyBhdCB0aGF0IHBvaW50IGluIHRoZSBkb2N1bWVudC5cbiAgICAgICAgaWYgKHByZXByb2Nlc3NOb2RlKSB7XG4gICAgICAgICAgICB3aGlsZSAoY3VycmVudENoaWxkID0gbmV4dEluUXVldWUpIHtcbiAgICAgICAgICAgICAgICBuZXh0SW5RdWV1ZSA9IGtvLnZpcnR1YWxFbGVtZW50cy5uZXh0U2libGluZyhjdXJyZW50Q2hpbGQpO1xuICAgICAgICAgICAgICAgIHByZXByb2Nlc3NOb2RlLmNhbGwocHJvdmlkZXIsIGN1cnJlbnRDaGlsZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBSZXNldCBuZXh0SW5RdWV1ZSBmb3IgdGhlIG5leHQgbG9vcFxuICAgICAgICAgICAgbmV4dEluUXVldWUgPSBrby52aXJ0dWFsRWxlbWVudHMuZmlyc3RDaGlsZChlbGVtZW50T3JWaXJ0dWFsRWxlbWVudCk7XG4gICAgICAgIH1cblxuICAgICAgICB3aGlsZSAoY3VycmVudENoaWxkID0gbmV4dEluUXVldWUpIHtcbiAgICAgICAgICAgIC8vIEtlZXAgYSByZWNvcmQgb2YgdGhlIG5leHQgY2hpbGQgKmJlZm9yZSogYXBwbHlpbmcgYmluZGluZ3MsIGluIGNhc2UgdGhlIGJpbmRpbmcgcmVtb3ZlcyB0aGUgY3VycmVudCBjaGlsZCBmcm9tIGl0cyBwb3NpdGlvblxuICAgICAgICAgICAgbmV4dEluUXVldWUgPSBrby52aXJ0dWFsRWxlbWVudHMubmV4dFNpYmxpbmcoY3VycmVudENoaWxkKTtcbiAgICAgICAgICAgIGFwcGx5QmluZGluZ3NUb05vZGVBbmREZXNjZW5kYW50c0ludGVybmFsKGJpbmRpbmdDb250ZXh0LCBjdXJyZW50Q2hpbGQsIGJpbmRpbmdDb250ZXh0c01heURpZmZlckZyb21Eb21QYXJlbnRFbGVtZW50KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFwcGx5QmluZGluZ3NUb05vZGVBbmREZXNjZW5kYW50c0ludGVybmFsIChiaW5kaW5nQ29udGV4dCwgbm9kZVZlcmlmaWVkLCBiaW5kaW5nQ29udGV4dE1heURpZmZlckZyb21Eb21QYXJlbnRFbGVtZW50KSB7XG4gICAgICAgIHZhciBzaG91bGRCaW5kRGVzY2VuZGFudHMgPSB0cnVlO1xuXG4gICAgICAgIC8vIFBlcmYgb3B0aW1pc2F0aW9uOiBBcHBseSBiaW5kaW5ncyBvbmx5IGlmLi4uXG4gICAgICAgIC8vICgxKSBXZSBuZWVkIHRvIHN0b3JlIHRoZSBiaW5kaW5nIGNvbnRleHQgb24gdGhpcyBub2RlIChiZWNhdXNlIGl0IG1heSBkaWZmZXIgZnJvbSB0aGUgRE9NIHBhcmVudCBub2RlJ3MgYmluZGluZyBjb250ZXh0KVxuICAgICAgICAvLyAgICAgTm90ZSB0aGF0IHdlIGNhbid0IHN0b3JlIGJpbmRpbmcgY29udGV4dHMgb24gbm9uLWVsZW1lbnRzIChlLmcuLCB0ZXh0IG5vZGVzKSwgYXMgSUUgZG9lc24ndCBhbGxvdyBleHBhbmRvIHByb3BlcnRpZXMgZm9yIHRob3NlXG4gICAgICAgIC8vICgyKSBJdCBtaWdodCBoYXZlIGJpbmRpbmdzIChlLmcuLCBpdCBoYXMgYSBkYXRhLWJpbmQgYXR0cmlidXRlLCBvciBpdCdzIGEgbWFya2VyIGZvciBhIGNvbnRhaW5lcmxlc3MgdGVtcGxhdGUpXG4gICAgICAgIHZhciBpc0VsZW1lbnQgPSAobm9kZVZlcmlmaWVkLm5vZGVUeXBlID09PSAxKTtcbiAgICAgICAgaWYgKGlzRWxlbWVudCkgLy8gV29ya2Fyb3VuZCBJRSA8PSA4IEhUTUwgcGFyc2luZyB3ZWlyZG5lc3NcbiAgICAgICAgICAgIGtvLnZpcnR1YWxFbGVtZW50cy5ub3JtYWxpc2VWaXJ0dWFsRWxlbWVudERvbVN0cnVjdHVyZShub2RlVmVyaWZpZWQpO1xuXG4gICAgICAgIHZhciBzaG91bGRBcHBseUJpbmRpbmdzID0gKGlzRWxlbWVudCAmJiBiaW5kaW5nQ29udGV4dE1heURpZmZlckZyb21Eb21QYXJlbnRFbGVtZW50KSAgICAgICAgICAgICAvLyBDYXNlICgxKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHx8IGtvLmJpbmRpbmdQcm92aWRlclsnaW5zdGFuY2UnXVsnbm9kZUhhc0JpbmRpbmdzJ10obm9kZVZlcmlmaWVkKTsgICAgICAgLy8gQ2FzZSAoMilcbiAgICAgICAgaWYgKHNob3VsZEFwcGx5QmluZGluZ3MpXG4gICAgICAgICAgICBzaG91bGRCaW5kRGVzY2VuZGFudHMgPSBhcHBseUJpbmRpbmdzVG9Ob2RlSW50ZXJuYWwobm9kZVZlcmlmaWVkLCBudWxsLCBiaW5kaW5nQ29udGV4dCwgYmluZGluZ0NvbnRleHRNYXlEaWZmZXJGcm9tRG9tUGFyZW50RWxlbWVudClbJ3Nob3VsZEJpbmREZXNjZW5kYW50cyddO1xuXG4gICAgICAgIGlmIChzaG91bGRCaW5kRGVzY2VuZGFudHMgJiYgIWJpbmRpbmdEb2VzTm90UmVjdXJzZUludG9FbGVtZW50VHlwZXNba28udXRpbHMudGFnTmFtZUxvd2VyKG5vZGVWZXJpZmllZCldKSB7XG4gICAgICAgICAgICAvLyBXZSdyZSByZWN1cnNpbmcgYXV0b21hdGljYWxseSBpbnRvIChyZWFsIG9yIHZpcnR1YWwpIGNoaWxkIG5vZGVzIHdpdGhvdXQgY2hhbmdpbmcgYmluZGluZyBjb250ZXh0cy4gU28sXG4gICAgICAgICAgICAvLyAgKiBGb3IgY2hpbGRyZW4gb2YgYSAqcmVhbCogZWxlbWVudCwgdGhlIGJpbmRpbmcgY29udGV4dCBpcyBjZXJ0YWlubHkgdGhlIHNhbWUgYXMgb24gdGhlaXIgRE9NIC5wYXJlbnROb2RlLFxuICAgICAgICAgICAgLy8gICAgaGVuY2UgYmluZGluZ0NvbnRleHRzTWF5RGlmZmVyRnJvbURvbVBhcmVudEVsZW1lbnQgaXMgZmFsc2VcbiAgICAgICAgICAgIC8vICAqIEZvciBjaGlsZHJlbiBvZiBhICp2aXJ0dWFsKiBlbGVtZW50LCB3ZSBjYW4ndCBiZSBzdXJlLiBFdmFsdWF0aW5nIC5wYXJlbnROb2RlIG9uIHRob3NlIGNoaWxkcmVuIG1heVxuICAgICAgICAgICAgLy8gICAgc2tpcCBvdmVyIGFueSBudW1iZXIgb2YgaW50ZXJtZWRpYXRlIHZpcnR1YWwgZWxlbWVudHMsIGFueSBvZiB3aGljaCBtaWdodCBkZWZpbmUgYSBjdXN0b20gYmluZGluZyBjb250ZXh0LFxuICAgICAgICAgICAgLy8gICAgaGVuY2UgYmluZGluZ0NvbnRleHRzTWF5RGlmZmVyRnJvbURvbVBhcmVudEVsZW1lbnQgaXMgdHJ1ZVxuICAgICAgICAgICAgYXBwbHlCaW5kaW5nc1RvRGVzY2VuZGFudHNJbnRlcm5hbChiaW5kaW5nQ29udGV4dCwgbm9kZVZlcmlmaWVkLCAvKiBiaW5kaW5nQ29udGV4dHNNYXlEaWZmZXJGcm9tRG9tUGFyZW50RWxlbWVudDogKi8gIWlzRWxlbWVudCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgYm91bmRFbGVtZW50RG9tRGF0YUtleSA9IGtvLnV0aWxzLmRvbURhdGEubmV4dEtleSgpO1xuXG5cbiAgICBmdW5jdGlvbiB0b3BvbG9naWNhbFNvcnRCaW5kaW5ncyhiaW5kaW5ncykge1xuICAgICAgICAvLyBEZXB0aC1maXJzdCBzb3J0XG4gICAgICAgIHZhciByZXN1bHQgPSBbXSwgICAgICAgICAgICAgICAgLy8gVGhlIGxpc3Qgb2Yga2V5L2hhbmRsZXIgcGFpcnMgdGhhdCB3ZSB3aWxsIHJldHVyblxuICAgICAgICAgICAgYmluZGluZ3NDb25zaWRlcmVkID0ge30sICAgIC8vIEEgdGVtcG9yYXJ5IHJlY29yZCBvZiB3aGljaCBiaW5kaW5ncyBhcmUgYWxyZWFkeSBpbiAncmVzdWx0J1xuICAgICAgICAgICAgY3ljbGljRGVwZW5kZW5jeVN0YWNrID0gW107IC8vIEtlZXBzIHRyYWNrIG9mIGEgZGVwdGgtc2VhcmNoIHNvIHRoYXQsIGlmIHRoZXJlJ3MgYSBjeWNsZSwgd2Uga25vdyB3aGljaCBiaW5kaW5ncyBjYXVzZWQgaXRcbiAgICAgICAga28udXRpbHMub2JqZWN0Rm9yRWFjaChiaW5kaW5ncywgZnVuY3Rpb24gcHVzaEJpbmRpbmcoYmluZGluZ0tleSkge1xuICAgICAgICAgICAgaWYgKCFiaW5kaW5nc0NvbnNpZGVyZWRbYmluZGluZ0tleV0pIHtcbiAgICAgICAgICAgICAgICB2YXIgYmluZGluZyA9IGtvWydnZXRCaW5kaW5nSGFuZGxlciddKGJpbmRpbmdLZXkpO1xuICAgICAgICAgICAgICAgIGlmIChiaW5kaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEZpcnN0IGFkZCBkZXBlbmRlbmNpZXMgKGlmIGFueSkgb2YgdGhlIGN1cnJlbnQgYmluZGluZ1xuICAgICAgICAgICAgICAgICAgICBpZiAoYmluZGluZ1snYWZ0ZXInXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY3ljbGljRGVwZW5kZW5jeVN0YWNrLnB1c2goYmluZGluZ0tleSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBrby51dGlscy5hcnJheUZvckVhY2goYmluZGluZ1snYWZ0ZXInXSwgZnVuY3Rpb24oYmluZGluZ0RlcGVuZGVuY3lLZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYmluZGluZ3NbYmluZGluZ0RlcGVuZGVuY3lLZXldKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChrby51dGlscy5hcnJheUluZGV4T2YoY3ljbGljRGVwZW5kZW5jeVN0YWNrLCBiaW5kaW5nRGVwZW5kZW5jeUtleSkgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcIkNhbm5vdCBjb21iaW5lIHRoZSBmb2xsb3dpbmcgYmluZGluZ3MsIGJlY2F1c2UgdGhleSBoYXZlIGEgY3ljbGljIGRlcGVuZGVuY3k6IFwiICsgY3ljbGljRGVwZW5kZW5jeVN0YWNrLmpvaW4oXCIsIFwiKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwdXNoQmluZGluZyhiaW5kaW5nRGVwZW5kZW5jeUtleSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN5Y2xpY0RlcGVuZGVuY3lTdGFjay5sZW5ndGgtLTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBOZXh0IGFkZCB0aGUgY3VycmVudCBiaW5kaW5nXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHsga2V5OiBiaW5kaW5nS2V5LCBoYW5kbGVyOiBiaW5kaW5nIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBiaW5kaW5nc0NvbnNpZGVyZWRbYmluZGluZ0tleV0gPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFwcGx5QmluZGluZ3NUb05vZGVJbnRlcm5hbChub2RlLCBzb3VyY2VCaW5kaW5ncywgYmluZGluZ0NvbnRleHQsIGJpbmRpbmdDb250ZXh0TWF5RGlmZmVyRnJvbURvbVBhcmVudEVsZW1lbnQpIHtcbiAgICAgICAgLy8gUHJldmVudCBtdWx0aXBsZSBhcHBseUJpbmRpbmdzIGNhbGxzIGZvciB0aGUgc2FtZSBub2RlLCBleGNlcHQgd2hlbiBhIGJpbmRpbmcgdmFsdWUgaXMgc3BlY2lmaWVkXG4gICAgICAgIHZhciBhbHJlYWR5Qm91bmQgPSBrby51dGlscy5kb21EYXRhLmdldChub2RlLCBib3VuZEVsZW1lbnREb21EYXRhS2V5KTtcbiAgICAgICAgaWYgKCFzb3VyY2VCaW5kaW5ncykge1xuICAgICAgICAgICAgaWYgKGFscmVhZHlCb3VuZCkge1xuICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiWW91IGNhbm5vdCBhcHBseSBiaW5kaW5ncyBtdWx0aXBsZSB0aW1lcyB0byB0aGUgc2FtZSBlbGVtZW50LlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGtvLnV0aWxzLmRvbURhdGEuc2V0KG5vZGUsIGJvdW5kRWxlbWVudERvbURhdGFLZXksIHRydWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gT3B0aW1pemF0aW9uOiBEb24ndCBzdG9yZSB0aGUgYmluZGluZyBjb250ZXh0IG9uIHRoaXMgbm9kZSBpZiBpdCdzIGRlZmluaXRlbHkgdGhlIHNhbWUgYXMgb24gbm9kZS5wYXJlbnROb2RlLCBiZWNhdXNlXG4gICAgICAgIC8vIHdlIGNhbiBlYXNpbHkgcmVjb3ZlciBpdCBqdXN0IGJ5IHNjYW5uaW5nIHVwIHRoZSBub2RlJ3MgYW5jZXN0b3JzIGluIHRoZSBET01cbiAgICAgICAgLy8gKG5vdGU6IGhlcmUsIHBhcmVudCBub2RlIG1lYW5zIFwicmVhbCBET00gcGFyZW50XCIgbm90IFwidmlydHVhbCBwYXJlbnRcIiwgYXMgdGhlcmUncyBubyBPKDEpIHdheSB0byBmaW5kIHRoZSB2aXJ0dWFsIHBhcmVudClcbiAgICAgICAgaWYgKCFhbHJlYWR5Qm91bmQgJiYgYmluZGluZ0NvbnRleHRNYXlEaWZmZXJGcm9tRG9tUGFyZW50RWxlbWVudClcbiAgICAgICAgICAgIGtvLnN0b3JlZEJpbmRpbmdDb250ZXh0Rm9yTm9kZShub2RlLCBiaW5kaW5nQ29udGV4dCk7XG5cbiAgICAgICAgLy8gVXNlIGJpbmRpbmdzIGlmIGdpdmVuLCBvdGhlcndpc2UgZmFsbCBiYWNrIG9uIGFza2luZyB0aGUgYmluZGluZ3MgcHJvdmlkZXIgdG8gZ2l2ZSB1cyBzb21lIGJpbmRpbmdzXG4gICAgICAgIHZhciBiaW5kaW5ncztcbiAgICAgICAgaWYgKHNvdXJjZUJpbmRpbmdzICYmIHR5cGVvZiBzb3VyY2VCaW5kaW5ncyAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgYmluZGluZ3MgPSBzb3VyY2VCaW5kaW5ncztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBwcm92aWRlciA9IGtvLmJpbmRpbmdQcm92aWRlclsnaW5zdGFuY2UnXSxcbiAgICAgICAgICAgICAgICBnZXRCaW5kaW5ncyA9IHByb3ZpZGVyWydnZXRCaW5kaW5nQWNjZXNzb3JzJ10gfHwgZ2V0QmluZGluZ3NBbmRNYWtlQWNjZXNzb3JzO1xuXG4gICAgICAgICAgICAvLyBHZXQgdGhlIGJpbmRpbmcgZnJvbSB0aGUgcHJvdmlkZXIgd2l0aGluIGEgY29tcHV0ZWQgb2JzZXJ2YWJsZSBzbyB0aGF0IHdlIGNhbiB1cGRhdGUgdGhlIGJpbmRpbmdzIHdoZW5ldmVyXG4gICAgICAgICAgICAvLyB0aGUgYmluZGluZyBjb250ZXh0IGlzIHVwZGF0ZWQgb3IgaWYgdGhlIGJpbmRpbmcgcHJvdmlkZXIgYWNjZXNzZXMgb2JzZXJ2YWJsZXMuXG4gICAgICAgICAgICB2YXIgYmluZGluZ3NVcGRhdGVyID0ga28uZGVwZW5kZW50T2JzZXJ2YWJsZShcbiAgICAgICAgICAgICAgICBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgYmluZGluZ3MgPSBzb3VyY2VCaW5kaW5ncyA/IHNvdXJjZUJpbmRpbmdzKGJpbmRpbmdDb250ZXh0LCBub2RlKSA6IGdldEJpbmRpbmdzLmNhbGwocHJvdmlkZXIsIG5vZGUsIGJpbmRpbmdDb250ZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgLy8gUmVnaXN0ZXIgYSBkZXBlbmRlbmN5IG9uIHRoZSBiaW5kaW5nIGNvbnRleHQgdG8gc3VwcG9ydCBvYnNlcnZhYmxlIHZpZXcgbW9kZWxzLlxuICAgICAgICAgICAgICAgICAgICBpZiAoYmluZGluZ3MgJiYgYmluZGluZ0NvbnRleHQuX3N1YnNjcmliYWJsZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGJpbmRpbmdDb250ZXh0Ll9zdWJzY3JpYmFibGUoKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGJpbmRpbmdzO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgbnVsbCwgeyBkaXNwb3NlV2hlbk5vZGVJc1JlbW92ZWQ6IG5vZGUgfVxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgaWYgKCFiaW5kaW5ncyB8fCAhYmluZGluZ3NVcGRhdGVyLmlzQWN0aXZlKCkpXG4gICAgICAgICAgICAgICAgYmluZGluZ3NVcGRhdGVyID0gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBiaW5kaW5nSGFuZGxlclRoYXRDb250cm9sc0Rlc2NlbmRhbnRCaW5kaW5ncztcbiAgICAgICAgaWYgKGJpbmRpbmdzKSB7XG4gICAgICAgICAgICAvLyBSZXR1cm4gdGhlIHZhbHVlIGFjY2Vzc29yIGZvciBhIGdpdmVuIGJpbmRpbmcuIFdoZW4gYmluZGluZ3MgYXJlIHN0YXRpYyAod29uJ3QgYmUgdXBkYXRlZCBiZWNhdXNlIG9mIGEgYmluZGluZ1xuICAgICAgICAgICAgLy8gY29udGV4dCB1cGRhdGUpLCBqdXN0IHJldHVybiB0aGUgdmFsdWUgYWNjZXNzb3IgZnJvbSB0aGUgYmluZGluZy4gT3RoZXJ3aXNlLCByZXR1cm4gYSBmdW5jdGlvbiB0aGF0IGFsd2F5cyBnZXRzXG4gICAgICAgICAgICAvLyB0aGUgbGF0ZXN0IGJpbmRpbmcgdmFsdWUgYW5kIHJlZ2lzdGVycyBhIGRlcGVuZGVuY3kgb24gdGhlIGJpbmRpbmcgdXBkYXRlci5cbiAgICAgICAgICAgIHZhciBnZXRWYWx1ZUFjY2Vzc29yID0gYmluZGluZ3NVcGRhdGVyXG4gICAgICAgICAgICAgICAgPyBmdW5jdGlvbihiaW5kaW5nS2V5KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBldmFsdWF0ZVZhbHVlQWNjZXNzb3IoYmluZGluZ3NVcGRhdGVyKClbYmluZGluZ0tleV0pO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH0gOiBmdW5jdGlvbihiaW5kaW5nS2V5KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBiaW5kaW5nc1tiaW5kaW5nS2V5XTtcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAvLyBVc2Ugb2YgYWxsQmluZGluZ3MgYXMgYSBmdW5jdGlvbiBpcyBtYWludGFpbmVkIGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eSwgYnV0IGl0cyB1c2UgaXMgZGVwcmVjYXRlZFxuICAgICAgICAgICAgZnVuY3Rpb24gYWxsQmluZGluZ3MoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGtvLnV0aWxzLm9iamVjdE1hcChiaW5kaW5nc1VwZGF0ZXIgPyBiaW5kaW5nc1VwZGF0ZXIoKSA6IGJpbmRpbmdzLCBldmFsdWF0ZVZhbHVlQWNjZXNzb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gVGhlIGZvbGxvd2luZyBpcyB0aGUgMy54IGFsbEJpbmRpbmdzIEFQSVxuICAgICAgICAgICAgYWxsQmluZGluZ3NbJ2dldCddID0gZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGJpbmRpbmdzW2tleV0gJiYgZXZhbHVhdGVWYWx1ZUFjY2Vzc29yKGdldFZhbHVlQWNjZXNzb3Ioa2V5KSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgYWxsQmluZGluZ3NbJ2hhcyddID0gZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGtleSBpbiBiaW5kaW5ncztcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIC8vIEZpcnN0IHB1dCB0aGUgYmluZGluZ3MgaW50byB0aGUgcmlnaHQgb3JkZXJcbiAgICAgICAgICAgIHZhciBvcmRlcmVkQmluZGluZ3MgPSB0b3BvbG9naWNhbFNvcnRCaW5kaW5ncyhiaW5kaW5ncyk7XG5cbiAgICAgICAgICAgIC8vIEdvIHRocm91Z2ggdGhlIHNvcnRlZCBiaW5kaW5ncywgY2FsbGluZyBpbml0IGFuZCB1cGRhdGUgZm9yIGVhY2hcbiAgICAgICAgICAgIGtvLnV0aWxzLmFycmF5Rm9yRWFjaChvcmRlcmVkQmluZGluZ3MsIGZ1bmN0aW9uKGJpbmRpbmdLZXlBbmRIYW5kbGVyKSB7XG4gICAgICAgICAgICAgICAgLy8gTm90ZSB0aGF0IHRvcG9sb2dpY2FsU29ydEJpbmRpbmdzIGhhcyBhbHJlYWR5IGZpbHRlcmVkIG91dCBhbnkgbm9uZXhpc3RlbnQgYmluZGluZyBoYW5kbGVycyxcbiAgICAgICAgICAgICAgICAvLyBzbyBiaW5kaW5nS2V5QW5kSGFuZGxlci5oYW5kbGVyIHdpbGwgYWx3YXlzIGJlIG5vbm51bGwuXG4gICAgICAgICAgICAgICAgdmFyIGhhbmRsZXJJbml0Rm4gPSBiaW5kaW5nS2V5QW5kSGFuZGxlci5oYW5kbGVyW1wiaW5pdFwiXSxcbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlclVwZGF0ZUZuID0gYmluZGluZ0tleUFuZEhhbmRsZXIuaGFuZGxlcltcInVwZGF0ZVwiXSxcbiAgICAgICAgICAgICAgICAgICAgYmluZGluZ0tleSA9IGJpbmRpbmdLZXlBbmRIYW5kbGVyLmtleTtcblxuICAgICAgICAgICAgICAgIGlmIChub2RlLm5vZGVUeXBlID09PSA4KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbGlkYXRlVGhhdEJpbmRpbmdJc0FsbG93ZWRGb3JWaXJ0dWFsRWxlbWVudHMoYmluZGluZ0tleSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgLy8gUnVuIGluaXQsIGlnbm9yaW5nIGFueSBkZXBlbmRlbmNpZXNcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBoYW5kbGVySW5pdEZuID09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgICAgICAgICAga28uZGVwZW5kZW5jeURldGVjdGlvbi5pZ25vcmUoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGluaXRSZXN1bHQgPSBoYW5kbGVySW5pdEZuKG5vZGUsIGdldFZhbHVlQWNjZXNzb3IoYmluZGluZ0tleSksIGFsbEJpbmRpbmdzLCBiaW5kaW5nQ29udGV4dFsnJGRhdGEnXSwgYmluZGluZ0NvbnRleHQpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhpcyBiaW5kaW5nIGhhbmRsZXIgY2xhaW1zIHRvIGNvbnRyb2wgZGVzY2VuZGFudCBiaW5kaW5ncywgbWFrZSBhIG5vdGUgb2YgdGhpc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbml0UmVzdWx0ICYmIGluaXRSZXN1bHRbJ2NvbnRyb2xzRGVzY2VuZGFudEJpbmRpbmdzJ10pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGJpbmRpbmdIYW5kbGVyVGhhdENvbnRyb2xzRGVzY2VuZGFudEJpbmRpbmdzICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNdWx0aXBsZSBiaW5kaW5ncyAoXCIgKyBiaW5kaW5nSGFuZGxlclRoYXRDb250cm9sc0Rlc2NlbmRhbnRCaW5kaW5ncyArIFwiIGFuZCBcIiArIGJpbmRpbmdLZXkgKyBcIikgYXJlIHRyeWluZyB0byBjb250cm9sIGRlc2NlbmRhbnQgYmluZGluZ3Mgb2YgdGhlIHNhbWUgZWxlbWVudC4gWW91IGNhbm5vdCB1c2UgdGhlc2UgYmluZGluZ3MgdG9nZXRoZXIgb24gdGhlIHNhbWUgZWxlbWVudC5cIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJpbmRpbmdIYW5kbGVyVGhhdENvbnRyb2xzRGVzY2VuZGFudEJpbmRpbmdzID0gYmluZGluZ0tleTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIFJ1biB1cGRhdGUgaW4gaXRzIG93biBjb21wdXRlZCB3cmFwcGVyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgaGFuZGxlclVwZGF0ZUZuID09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgICAgICAgICAga28uZGVwZW5kZW50T2JzZXJ2YWJsZShcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGFuZGxlclVwZGF0ZUZuKG5vZGUsIGdldFZhbHVlQWNjZXNzb3IoYmluZGluZ0tleSksIGFsbEJpbmRpbmdzLCBiaW5kaW5nQ29udGV4dFsnJGRhdGEnXSwgYmluZGluZ0NvbnRleHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7IGRpc3Bvc2VXaGVuTm9kZUlzUmVtb3ZlZDogbm9kZSB9XG4gICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgZXgubWVzc2FnZSA9IFwiVW5hYmxlIHRvIHByb2Nlc3MgYmluZGluZyBcXFwiXCIgKyBiaW5kaW5nS2V5ICsgXCI6IFwiICsgYmluZGluZ3NbYmluZGluZ0tleV0gKyBcIlxcXCJcXG5NZXNzYWdlOiBcIiArIGV4Lm1lc3NhZ2U7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGV4O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICdzaG91bGRCaW5kRGVzY2VuZGFudHMnOiBiaW5kaW5nSGFuZGxlclRoYXRDb250cm9sc0Rlc2NlbmRhbnRCaW5kaW5ncyA9PT0gdW5kZWZpbmVkXG4gICAgICAgIH07XG4gICAgfTtcblxuICAgIHZhciBzdG9yZWRCaW5kaW5nQ29udGV4dERvbURhdGFLZXkgPSBrby51dGlscy5kb21EYXRhLm5leHRLZXkoKTtcbiAgICBrby5zdG9yZWRCaW5kaW5nQ29udGV4dEZvck5vZGUgPSBmdW5jdGlvbiAobm9kZSwgYmluZGluZ0NvbnRleHQpIHtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT0gMikge1xuICAgICAgICAgICAga28udXRpbHMuZG9tRGF0YS5zZXQobm9kZSwgc3RvcmVkQmluZGluZ0NvbnRleHREb21EYXRhS2V5LCBiaW5kaW5nQ29udGV4dCk7XG4gICAgICAgICAgICBpZiAoYmluZGluZ0NvbnRleHQuX3N1YnNjcmliYWJsZSlcbiAgICAgICAgICAgICAgICBiaW5kaW5nQ29udGV4dC5fc3Vic2NyaWJhYmxlLl9hZGROb2RlKG5vZGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGtvLnV0aWxzLmRvbURhdGEuZ2V0KG5vZGUsIHN0b3JlZEJpbmRpbmdDb250ZXh0RG9tRGF0YUtleSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRCaW5kaW5nQ29udGV4dCh2aWV3TW9kZWxPckJpbmRpbmdDb250ZXh0KSB7XG4gICAgICAgIHJldHVybiB2aWV3TW9kZWxPckJpbmRpbmdDb250ZXh0ICYmICh2aWV3TW9kZWxPckJpbmRpbmdDb250ZXh0IGluc3RhbmNlb2Yga28uYmluZGluZ0NvbnRleHQpXG4gICAgICAgICAgICA/IHZpZXdNb2RlbE9yQmluZGluZ0NvbnRleHRcbiAgICAgICAgICAgIDogbmV3IGtvLmJpbmRpbmdDb250ZXh0KHZpZXdNb2RlbE9yQmluZGluZ0NvbnRleHQpO1xuICAgIH1cblxuICAgIGtvLmFwcGx5QmluZGluZ0FjY2Vzc29yc1RvTm9kZSA9IGZ1bmN0aW9uIChub2RlLCBiaW5kaW5ncywgdmlld01vZGVsT3JCaW5kaW5nQ29udGV4dCkge1xuICAgICAgICBpZiAobm9kZS5ub2RlVHlwZSA9PT0gMSkgLy8gSWYgaXQncyBhbiBlbGVtZW50LCB3b3JrYXJvdW5kIElFIDw9IDggSFRNTCBwYXJzaW5nIHdlaXJkbmVzc1xuICAgICAgICAgICAga28udmlydHVhbEVsZW1lbnRzLm5vcm1hbGlzZVZpcnR1YWxFbGVtZW50RG9tU3RydWN0dXJlKG5vZGUpO1xuICAgICAgICByZXR1cm4gYXBwbHlCaW5kaW5nc1RvTm9kZUludGVybmFsKG5vZGUsIGJpbmRpbmdzLCBnZXRCaW5kaW5nQ29udGV4dCh2aWV3TW9kZWxPckJpbmRpbmdDb250ZXh0KSwgdHJ1ZSk7XG4gICAgfTtcblxuICAgIGtvLmFwcGx5QmluZGluZ3NUb05vZGUgPSBmdW5jdGlvbiAobm9kZSwgYmluZGluZ3MsIHZpZXdNb2RlbE9yQmluZGluZ0NvbnRleHQpIHtcbiAgICAgICAgdmFyIGNvbnRleHQgPSBnZXRCaW5kaW5nQ29udGV4dCh2aWV3TW9kZWxPckJpbmRpbmdDb250ZXh0KTtcbiAgICAgICAgcmV0dXJuIGtvLmFwcGx5QmluZGluZ0FjY2Vzc29yc1RvTm9kZShub2RlLCBtYWtlQmluZGluZ0FjY2Vzc29ycyhiaW5kaW5ncywgY29udGV4dCwgbm9kZSksIGNvbnRleHQpO1xuICAgIH07XG5cbiAgICBrby5hcHBseUJpbmRpbmdzVG9EZXNjZW5kYW50cyA9IGZ1bmN0aW9uKHZpZXdNb2RlbE9yQmluZGluZ0NvbnRleHQsIHJvb3ROb2RlKSB7XG4gICAgICAgIGlmIChyb290Tm9kZS5ub2RlVHlwZSA9PT0gMSB8fCByb290Tm9kZS5ub2RlVHlwZSA9PT0gOClcbiAgICAgICAgICAgIGFwcGx5QmluZGluZ3NUb0Rlc2NlbmRhbnRzSW50ZXJuYWwoZ2V0QmluZGluZ0NvbnRleHQodmlld01vZGVsT3JCaW5kaW5nQ29udGV4dCksIHJvb3ROb2RlLCB0cnVlKTtcbiAgICB9O1xuXG4gICAga28uYXBwbHlCaW5kaW5ncyA9IGZ1bmN0aW9uICh2aWV3TW9kZWxPckJpbmRpbmdDb250ZXh0LCByb290Tm9kZSkge1xuICAgICAgICAvLyBJZiBqUXVlcnkgaXMgbG9hZGVkIGFmdGVyIEtub2Nrb3V0LCB3ZSB3b24ndCBpbml0aWFsbHkgaGF2ZSBhY2Nlc3MgdG8gaXQuIFNvIHNhdmUgaXQgaGVyZS5cbiAgICAgICAgaWYgKCFqUXVlcnlJbnN0YW5jZSAmJiB3aW5kb3dbJ2pRdWVyeSddKSB7XG4gICAgICAgICAgICBqUXVlcnlJbnN0YW5jZSA9IHdpbmRvd1snalF1ZXJ5J107XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocm9vdE5vZGUgJiYgKHJvb3ROb2RlLm5vZGVUeXBlICE9PSAxKSAmJiAocm9vdE5vZGUubm9kZVR5cGUgIT09IDgpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwia28uYXBwbHlCaW5kaW5nczogZmlyc3QgcGFyYW1ldGVyIHNob3VsZCBiZSB5b3VyIHZpZXcgbW9kZWw7IHNlY29uZCBwYXJhbWV0ZXIgc2hvdWxkIGJlIGEgRE9NIG5vZGVcIik7XG4gICAgICAgIHJvb3ROb2RlID0gcm9vdE5vZGUgfHwgd2luZG93LmRvY3VtZW50LmJvZHk7IC8vIE1ha2UgXCJyb290Tm9kZVwiIHBhcmFtZXRlciBvcHRpb25hbFxuXG4gICAgICAgIGFwcGx5QmluZGluZ3NUb05vZGVBbmREZXNjZW5kYW50c0ludGVybmFsKGdldEJpbmRpbmdDb250ZXh0KHZpZXdNb2RlbE9yQmluZGluZ0NvbnRleHQpLCByb290Tm9kZSwgdHJ1ZSk7XG4gICAgfTtcblxuICAgIC8vIFJldHJpZXZpbmcgYmluZGluZyBjb250ZXh0IGZyb20gYXJiaXRyYXJ5IG5vZGVzXG4gICAga28uY29udGV4dEZvciA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgICAgLy8gV2UgY2FuIG9ubHkgZG8gc29tZXRoaW5nIG1lYW5pbmdmdWwgZm9yIGVsZW1lbnRzIGFuZCBjb21tZW50IG5vZGVzIChpbiBwYXJ0aWN1bGFyLCBub3QgdGV4dCBub2RlcywgYXMgSUUgY2FuJ3Qgc3RvcmUgZG9tZGF0YSBmb3IgdGhlbSlcbiAgICAgICAgc3dpdGNoIChub2RlLm5vZGVUeXBlKSB7XG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICAgICAgdmFyIGNvbnRleHQgPSBrby5zdG9yZWRCaW5kaW5nQ29udGV4dEZvck5vZGUobm9kZSk7XG4gICAgICAgICAgICAgICAgaWYgKGNvbnRleHQpIHJldHVybiBjb250ZXh0O1xuICAgICAgICAgICAgICAgIGlmIChub2RlLnBhcmVudE5vZGUpIHJldHVybiBrby5jb250ZXh0Rm9yKG5vZGUucGFyZW50Tm9kZSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9O1xuICAgIGtvLmRhdGFGb3IgPSBmdW5jdGlvbihub2RlKSB7XG4gICAgICAgIHZhciBjb250ZXh0ID0ga28uY29udGV4dEZvcihub2RlKTtcbiAgICAgICAgcmV0dXJuIGNvbnRleHQgPyBjb250ZXh0WyckZGF0YSddIDogdW5kZWZpbmVkO1xuICAgIH07XG5cbiAgICBrby5leHBvcnRTeW1ib2woJ2JpbmRpbmdIYW5kbGVycycsIGtvLmJpbmRpbmdIYW5kbGVycyk7XG4gICAga28uZXhwb3J0U3ltYm9sKCdhcHBseUJpbmRpbmdzJywga28uYXBwbHlCaW5kaW5ncyk7XG4gICAga28uZXhwb3J0U3ltYm9sKCdhcHBseUJpbmRpbmdzVG9EZXNjZW5kYW50cycsIGtvLmFwcGx5QmluZGluZ3NUb0Rlc2NlbmRhbnRzKTtcbiAgICBrby5leHBvcnRTeW1ib2woJ2FwcGx5QmluZGluZ0FjY2Vzc29yc1RvTm9kZScsIGtvLmFwcGx5QmluZGluZ0FjY2Vzc29yc1RvTm9kZSk7XG4gICAga28uZXhwb3J0U3ltYm9sKCdhcHBseUJpbmRpbmdzVG9Ob2RlJywga28uYXBwbHlCaW5kaW5nc1RvTm9kZSk7XG4gICAga28uZXhwb3J0U3ltYm9sKCdjb250ZXh0Rm9yJywga28uY29udGV4dEZvcik7XG4gICAga28uZXhwb3J0U3ltYm9sKCdkYXRhRm9yJywga28uZGF0YUZvcik7XG59KSgpO1xuKGZ1bmN0aW9uKHVuZGVmaW5lZCkge1xuICAgIHZhciBsb2FkaW5nU3Vic2NyaWJhYmxlc0NhY2hlID0ge30sIC8vIFRyYWNrcyBjb21wb25lbnQgbG9hZHMgdGhhdCBhcmUgY3VycmVudGx5IGluIGZsaWdodFxuICAgICAgICBsb2FkZWREZWZpbml0aW9uc0NhY2hlID0ge307ICAgIC8vIFRyYWNrcyBjb21wb25lbnQgbG9hZHMgdGhhdCBoYXZlIGFscmVhZHkgY29tcGxldGVkXG5cbiAgICBrby5jb21wb25lbnRzID0ge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uKGNvbXBvbmVudE5hbWUsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICB2YXIgY2FjaGVkRGVmaW5pdGlvbiA9IGdldE9iamVjdE93blByb3BlcnR5KGxvYWRlZERlZmluaXRpb25zQ2FjaGUsIGNvbXBvbmVudE5hbWUpO1xuICAgICAgICAgICAgaWYgKGNhY2hlZERlZmluaXRpb24pIHtcbiAgICAgICAgICAgICAgICAvLyBJdCdzIGFscmVhZHkgbG9hZGVkIGFuZCBjYWNoZWQuIFJldXNlIHRoZSBzYW1lIGRlZmluaXRpb24gb2JqZWN0LlxuICAgICAgICAgICAgICAgIC8vIE5vdGUgdGhhdCBmb3IgQVBJIGNvbnNpc3RlbmN5LCBldmVuIGNhY2hlIGhpdHMgY29tcGxldGUgYXN5bmNocm9ub3VzbHkgYnkgZGVmYXVsdC5cbiAgICAgICAgICAgICAgICAvLyBZb3UgY2FuIGJ5cGFzcyB0aGlzIGJ5IHB1dHRpbmcgc3luY2hyb25vdXM6dHJ1ZSBvbiB5b3VyIGNvbXBvbmVudCBjb25maWcuXG4gICAgICAgICAgICAgICAgaWYgKGNhY2hlZERlZmluaXRpb24uaXNTeW5jaHJvbm91c0NvbXBvbmVudCkge1xuICAgICAgICAgICAgICAgICAgICBrby5kZXBlbmRlbmN5RGV0ZWN0aW9uLmlnbm9yZShmdW5jdGlvbigpIHsgLy8gU2VlIGNvbW1lbnQgaW4gbG9hZGVyUmVnaXN0cnlCZWhhdmlvcnMuanMgZm9yIHJlYXNvbmluZ1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soY2FjaGVkRGVmaW5pdGlvbi5kZWZpbml0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAga28udGFza3Muc2NoZWR1bGUoZnVuY3Rpb24oKSB7IGNhbGxiYWNrKGNhY2hlZERlZmluaXRpb24uZGVmaW5pdGlvbik7IH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gSm9pbiB0aGUgbG9hZGluZyBwcm9jZXNzIHRoYXQgaXMgYWxyZWFkeSB1bmRlcndheSwgb3Igc3RhcnQgYSBuZXcgb25lLlxuICAgICAgICAgICAgICAgIGxvYWRDb21wb25lbnRBbmROb3RpZnkoY29tcG9uZW50TmFtZSwgY2FsbGJhY2spO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIGNsZWFyQ2FjaGVkRGVmaW5pdGlvbjogZnVuY3Rpb24oY29tcG9uZW50TmFtZSkge1xuICAgICAgICAgICAgZGVsZXRlIGxvYWRlZERlZmluaXRpb25zQ2FjaGVbY29tcG9uZW50TmFtZV07XG4gICAgICAgIH0sXG5cbiAgICAgICAgX2dldEZpcnN0UmVzdWx0RnJvbUxvYWRlcnM6IGdldEZpcnN0UmVzdWx0RnJvbUxvYWRlcnNcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gZ2V0T2JqZWN0T3duUHJvcGVydHkob2JqLCBwcm9wTmFtZSkge1xuICAgICAgICByZXR1cm4gb2JqLmhhc093blByb3BlcnR5KHByb3BOYW1lKSA/IG9ialtwcm9wTmFtZV0gOiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbG9hZENvbXBvbmVudEFuZE5vdGlmeShjb21wb25lbnROYW1lLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgc3Vic2NyaWJhYmxlID0gZ2V0T2JqZWN0T3duUHJvcGVydHkobG9hZGluZ1N1YnNjcmliYWJsZXNDYWNoZSwgY29tcG9uZW50TmFtZSksXG4gICAgICAgICAgICBjb21wbGV0ZWRBc3luYztcbiAgICAgICAgaWYgKCFzdWJzY3JpYmFibGUpIHtcbiAgICAgICAgICAgIC8vIEl0J3Mgbm90IHN0YXJ0ZWQgbG9hZGluZyB5ZXQuIFN0YXJ0IGxvYWRpbmcsIGFuZCB3aGVuIGl0J3MgZG9uZSwgbW92ZSBpdCB0byBsb2FkZWREZWZpbml0aW9uc0NhY2hlLlxuICAgICAgICAgICAgc3Vic2NyaWJhYmxlID0gbG9hZGluZ1N1YnNjcmliYWJsZXNDYWNoZVtjb21wb25lbnROYW1lXSA9IG5ldyBrby5zdWJzY3JpYmFibGUoKTtcbiAgICAgICAgICAgIHN1YnNjcmliYWJsZS5zdWJzY3JpYmUoY2FsbGJhY2spO1xuXG4gICAgICAgICAgICBiZWdpbkxvYWRpbmdDb21wb25lbnQoY29tcG9uZW50TmFtZSwgZnVuY3Rpb24oZGVmaW5pdGlvbiwgY29uZmlnKSB7XG4gICAgICAgICAgICAgICAgdmFyIGlzU3luY2hyb25vdXNDb21wb25lbnQgPSAhIShjb25maWcgJiYgY29uZmlnWydzeW5jaHJvbm91cyddKTtcbiAgICAgICAgICAgICAgICBsb2FkZWREZWZpbml0aW9uc0NhY2hlW2NvbXBvbmVudE5hbWVdID0geyBkZWZpbml0aW9uOiBkZWZpbml0aW9uLCBpc1N5bmNocm9ub3VzQ29tcG9uZW50OiBpc1N5bmNocm9ub3VzQ29tcG9uZW50IH07XG4gICAgICAgICAgICAgICAgZGVsZXRlIGxvYWRpbmdTdWJzY3JpYmFibGVzQ2FjaGVbY29tcG9uZW50TmFtZV07XG5cbiAgICAgICAgICAgICAgICAvLyBGb3IgQVBJIGNvbnNpc3RlbmN5LCBhbGwgbG9hZHMgY29tcGxldGUgYXN5bmNocm9ub3VzbHkuIEhvd2V2ZXIgd2Ugd2FudCB0byBhdm9pZFxuICAgICAgICAgICAgICAgIC8vIGFkZGluZyBhbiBleHRyYSB0YXNrIHNjaGVkdWxlIGlmIGl0J3MgdW5uZWNlc3NhcnkgKGkuZS4sIHRoZSBjb21wbGV0aW9uIGlzIGFscmVhZHlcbiAgICAgICAgICAgICAgICAvLyBhc3luYykuXG4gICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAvLyBZb3UgY2FuIGJ5cGFzcyB0aGUgJ2Fsd2F5cyBhc3luY2hyb25vdXMnIGZlYXR1cmUgYnkgcHV0dGluZyB0aGUgc3luY2hyb25vdXM6dHJ1ZVxuICAgICAgICAgICAgICAgIC8vIGZsYWcgb24geW91ciBjb21wb25lbnQgY29uZmlndXJhdGlvbiB3aGVuIHlvdSByZWdpc3RlciBpdC5cbiAgICAgICAgICAgICAgICBpZiAoY29tcGxldGVkQXN5bmMgfHwgaXNTeW5jaHJvbm91c0NvbXBvbmVudCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBOb3RlIHRoYXQgbm90aWZ5U3Vic2NyaWJlcnMgaWdub3JlcyBhbnkgZGVwZW5kZW5jaWVzIHJlYWQgd2l0aGluIHRoZSBjYWxsYmFjay5cbiAgICAgICAgICAgICAgICAgICAgLy8gU2VlIGNvbW1lbnQgaW4gbG9hZGVyUmVnaXN0cnlCZWhhdmlvcnMuanMgZm9yIHJlYXNvbmluZ1xuICAgICAgICAgICAgICAgICAgICBzdWJzY3JpYmFibGVbJ25vdGlmeVN1YnNjcmliZXJzJ10oZGVmaW5pdGlvbik7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAga28udGFza3Muc2NoZWR1bGUoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdWJzY3JpYmFibGVbJ25vdGlmeVN1YnNjcmliZXJzJ10oZGVmaW5pdGlvbik7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29tcGxldGVkQXN5bmMgPSB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc3Vic2NyaWJhYmxlLnN1YnNjcmliZShjYWxsYmFjayk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBiZWdpbkxvYWRpbmdDb21wb25lbnQoY29tcG9uZW50TmFtZSwgY2FsbGJhY2spIHtcbiAgICAgICAgZ2V0Rmlyc3RSZXN1bHRGcm9tTG9hZGVycygnZ2V0Q29uZmlnJywgW2NvbXBvbmVudE5hbWVdLCBmdW5jdGlvbihjb25maWcpIHtcbiAgICAgICAgICAgIGlmIChjb25maWcpIHtcbiAgICAgICAgICAgICAgICAvLyBXZSBoYXZlIGEgY29uZmlnLCBzbyBub3cgbG9hZCBpdHMgZGVmaW5pdGlvblxuICAgICAgICAgICAgICAgIGdldEZpcnN0UmVzdWx0RnJvbUxvYWRlcnMoJ2xvYWRDb21wb25lbnQnLCBbY29tcG9uZW50TmFtZSwgY29uZmlnXSwgZnVuY3Rpb24oZGVmaW5pdGlvbikge1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhkZWZpbml0aW9uLCBjb25maWcpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBUaGUgY29tcG9uZW50IGhhcyBubyBjb25maWcgLSBpdCdzIHVua25vd24gdG8gYWxsIHRoZSBsb2FkZXJzLlxuICAgICAgICAgICAgICAgIC8vIE5vdGUgdGhhdCB0aGlzIGlzIG5vdCBhbiBlcnJvciAoZS5nLiwgYSBtb2R1bGUgbG9hZGluZyBlcnJvcikgLSB0aGF0IHdvdWxkIGFib3J0IHRoZVxuICAgICAgICAgICAgICAgIC8vIHByb2Nlc3MgYW5kIHRoaXMgY2FsbGJhY2sgd291bGQgbm90IHJ1bi4gRm9yIHRoaXMgY2FsbGJhY2sgdG8gcnVuLCBhbGwgbG9hZGVycyBtdXN0XG4gICAgICAgICAgICAgICAgLy8gaGF2ZSBjb25maXJtZWQgdGhleSBkb24ndCBrbm93IGFib3V0IHRoaXMgY29tcG9uZW50LlxuICAgICAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIG51bGwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRGaXJzdFJlc3VsdEZyb21Mb2FkZXJzKG1ldGhvZE5hbWUsIGFyZ3NFeGNlcHRDYWxsYmFjaywgY2FsbGJhY2ssIGNhbmRpZGF0ZUxvYWRlcnMpIHtcbiAgICAgICAgLy8gT24gdGhlIGZpcnN0IGNhbGwgaW4gdGhlIHN0YWNrLCBzdGFydCB3aXRoIHRoZSBmdWxsIHNldCBvZiBsb2FkZXJzXG4gICAgICAgIGlmICghY2FuZGlkYXRlTG9hZGVycykge1xuICAgICAgICAgICAgY2FuZGlkYXRlTG9hZGVycyA9IGtvLmNvbXBvbmVudHNbJ2xvYWRlcnMnXS5zbGljZSgwKTsgLy8gVXNlIGEgY29weSwgYmVjYXVzZSB3ZSdsbCBiZSBtdXRhdGluZyB0aGlzIGFycmF5XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUcnkgdGhlIG5leHQgY2FuZGlkYXRlXG4gICAgICAgIHZhciBjdXJyZW50Q2FuZGlkYXRlTG9hZGVyID0gY2FuZGlkYXRlTG9hZGVycy5zaGlmdCgpO1xuICAgICAgICBpZiAoY3VycmVudENhbmRpZGF0ZUxvYWRlcikge1xuICAgICAgICAgICAgdmFyIG1ldGhvZEluc3RhbmNlID0gY3VycmVudENhbmRpZGF0ZUxvYWRlclttZXRob2ROYW1lXTtcbiAgICAgICAgICAgIGlmIChtZXRob2RJbnN0YW5jZSkge1xuICAgICAgICAgICAgICAgIHZhciB3YXNBYm9ydGVkID0gZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIHN5bmNocm9ub3VzUmV0dXJuVmFsdWUgPSBtZXRob2RJbnN0YW5jZS5hcHBseShjdXJyZW50Q2FuZGlkYXRlTG9hZGVyLCBhcmdzRXhjZXB0Q2FsbGJhY2suY29uY2F0KGZ1bmN0aW9uKHJlc3VsdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHdhc0Fib3J0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhudWxsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAocmVzdWx0ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhpcyBjYW5kaWRhdGUgcmV0dXJuZWQgYSB2YWx1ZS4gVXNlIGl0LlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRyeSB0aGUgbmV4dCBjYW5kaWRhdGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZXRGaXJzdFJlc3VsdEZyb21Mb2FkZXJzKG1ldGhvZE5hbWUsIGFyZ3NFeGNlcHRDYWxsYmFjaywgY2FsbGJhY2ssIGNhbmRpZGF0ZUxvYWRlcnMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KSk7XG5cbiAgICAgICAgICAgICAgICAvLyBDdXJyZW50bHksIGxvYWRlcnMgbWF5IG5vdCByZXR1cm4gYW55dGhpbmcgc3luY2hyb25vdXNseS4gVGhpcyBsZWF2ZXMgb3BlbiB0aGUgcG9zc2liaWxpdHlcbiAgICAgICAgICAgICAgICAvLyB0aGF0IHdlJ2xsIGV4dGVuZCB0aGUgQVBJIHRvIHN1cHBvcnQgc3luY2hyb25vdXMgcmV0dXJuIHZhbHVlcyBpbiB0aGUgZnV0dXJlLiBJdCB3b24ndCBiZVxuICAgICAgICAgICAgICAgIC8vIGEgYnJlYWtpbmcgY2hhbmdlLCBiZWNhdXNlIGN1cnJlbnRseSBubyBsb2FkZXIgaXMgYWxsb3dlZCB0byByZXR1cm4gYW55dGhpbmcgZXhjZXB0IHVuZGVmaW5lZC5cbiAgICAgICAgICAgICAgICBpZiAoc3luY2hyb25vdXNSZXR1cm5WYWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHdhc0Fib3J0ZWQgPSB0cnVlO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIE1ldGhvZCB0byBzdXBwcmVzcyBleGNlcHRpb25zIHdpbGwgcmVtYWluIHVuZG9jdW1lbnRlZC4gVGhpcyBpcyBvbmx5IHRvIGtlZXBcbiAgICAgICAgICAgICAgICAgICAgLy8gS08ncyBzcGVjcyBydW5uaW5nIHRpZGlseSwgc2luY2Ugd2UgY2FuIG9ic2VydmUgdGhlIGxvYWRpbmcgZ290IGFib3J0ZWQgd2l0aG91dFxuICAgICAgICAgICAgICAgICAgICAvLyBoYXZpbmcgZXhjZXB0aW9ucyBjbHV0dGVyaW5nIHVwIHRoZSBjb25zb2xlIHRvby5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFjdXJyZW50Q2FuZGlkYXRlTG9hZGVyWydzdXBwcmVzc0xvYWRlckV4Y2VwdGlvbnMnXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDb21wb25lbnQgbG9hZGVycyBtdXN0IHN1cHBseSB2YWx1ZXMgYnkgaW52b2tpbmcgdGhlIGNhbGxiYWNrLCBub3QgYnkgcmV0dXJuaW5nIHZhbHVlcyBzeW5jaHJvbm91c2x5LicpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBUaGlzIGNhbmRpZGF0ZSBkb2Vzbid0IGhhdmUgdGhlIHJlbGV2YW50IGhhbmRsZXIuIFN5bmNocm9ub3VzbHkgbW92ZSBvbiB0byB0aGUgbmV4dCBvbmUuXG4gICAgICAgICAgICAgICAgZ2V0Rmlyc3RSZXN1bHRGcm9tTG9hZGVycyhtZXRob2ROYW1lLCBhcmdzRXhjZXB0Q2FsbGJhY2ssIGNhbGxiYWNrLCBjYW5kaWRhdGVMb2FkZXJzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIE5vIGNhbmRpZGF0ZXMgcmV0dXJuZWQgYSB2YWx1ZVxuICAgICAgICAgICAgY2FsbGJhY2sobnVsbCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBSZWZlcmVuY2UgdGhlIGxvYWRlcnMgdmlhIHN0cmluZyBuYW1lIHNvIGl0J3MgcG9zc2libGUgZm9yIGRldmVsb3BlcnNcbiAgICAvLyB0byByZXBsYWNlIHRoZSB3aG9sZSBhcnJheSBieSBhc3NpZ25pbmcgdG8ga28uY29tcG9uZW50cy5sb2FkZXJzXG4gICAga28uY29tcG9uZW50c1snbG9hZGVycyddID0gW107XG5cbiAgICBrby5leHBvcnRTeW1ib2woJ2NvbXBvbmVudHMnLCBrby5jb21wb25lbnRzKTtcbiAgICBrby5leHBvcnRTeW1ib2woJ2NvbXBvbmVudHMuZ2V0Jywga28uY29tcG9uZW50cy5nZXQpO1xuICAgIGtvLmV4cG9ydFN5bWJvbCgnY29tcG9uZW50cy5jbGVhckNhY2hlZERlZmluaXRpb24nLCBrby5jb21wb25lbnRzLmNsZWFyQ2FjaGVkRGVmaW5pdGlvbik7XG59KSgpO1xuKGZ1bmN0aW9uKHVuZGVmaW5lZCkge1xuXG4gICAgLy8gVGhlIGRlZmF1bHQgbG9hZGVyIGlzIHJlc3BvbnNpYmxlIGZvciB0d28gdGhpbmdzOlxuICAgIC8vIDEuIE1haW50YWluaW5nIHRoZSBkZWZhdWx0IGluLW1lbW9yeSByZWdpc3RyeSBvZiBjb21wb25lbnQgY29uZmlndXJhdGlvbiBvYmplY3RzXG4gICAgLy8gICAgKGkuZS4sIHRoZSB0aGluZyB5b3UncmUgd3JpdGluZyB0byB3aGVuIHlvdSBjYWxsIGtvLmNvbXBvbmVudHMucmVnaXN0ZXIoc29tZU5hbWUsIC4uLikpXG4gICAgLy8gMi4gQW5zd2VyaW5nIHJlcXVlc3RzIGZvciBjb21wb25lbnRzIGJ5IGZldGNoaW5nIGNvbmZpZ3VyYXRpb24gb2JqZWN0c1xuICAgIC8vICAgIGZyb20gdGhhdCBkZWZhdWx0IGluLW1lbW9yeSByZWdpc3RyeSBhbmQgcmVzb2x2aW5nIHRoZW0gaW50byBzdGFuZGFyZFxuICAgIC8vICAgIGNvbXBvbmVudCBkZWZpbml0aW9uIG9iamVjdHMgKG9mIHRoZSBmb3JtIHsgY3JlYXRlVmlld01vZGVsOiAuLi4sIHRlbXBsYXRlOiAuLi4gfSlcbiAgICAvLyBDdXN0b20gbG9hZGVycyBtYXkgb3ZlcnJpZGUgZWl0aGVyIG9mIHRoZXNlIGZhY2lsaXRpZXMsIGkuZS4sXG4gICAgLy8gMS4gVG8gc3VwcGx5IGNvbmZpZ3VyYXRpb24gb2JqZWN0cyBmcm9tIHNvbWUgb3RoZXIgc291cmNlIChlLmcuLCBjb252ZW50aW9ucylcbiAgICAvLyAyLiBPciwgdG8gcmVzb2x2ZSBjb25maWd1cmF0aW9uIG9iamVjdHMgYnkgbG9hZGluZyB2aWV3bW9kZWxzL3RlbXBsYXRlcyB2aWEgYXJiaXRyYXJ5IGxvZ2ljLlxuXG4gICAgdmFyIGRlZmF1bHRDb25maWdSZWdpc3RyeSA9IHt9O1xuXG4gICAga28uY29tcG9uZW50cy5yZWdpc3RlciA9IGZ1bmN0aW9uKGNvbXBvbmVudE5hbWUsIGNvbmZpZykge1xuICAgICAgICBpZiAoIWNvbmZpZykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGNvbmZpZ3VyYXRpb24gZm9yICcgKyBjb21wb25lbnROYW1lKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChrby5jb21wb25lbnRzLmlzUmVnaXN0ZXJlZChjb21wb25lbnROYW1lKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDb21wb25lbnQgJyArIGNvbXBvbmVudE5hbWUgKyAnIGlzIGFscmVhZHkgcmVnaXN0ZXJlZCcpO1xuICAgICAgICB9XG5cbiAgICAgICAgZGVmYXVsdENvbmZpZ1JlZ2lzdHJ5W2NvbXBvbmVudE5hbWVdID0gY29uZmlnO1xuICAgIH07XG5cbiAgICBrby5jb21wb25lbnRzLmlzUmVnaXN0ZXJlZCA9IGZ1bmN0aW9uKGNvbXBvbmVudE5hbWUpIHtcbiAgICAgICAgcmV0dXJuIGRlZmF1bHRDb25maWdSZWdpc3RyeS5oYXNPd25Qcm9wZXJ0eShjb21wb25lbnROYW1lKTtcbiAgICB9O1xuXG4gICAga28uY29tcG9uZW50cy51bnJlZ2lzdGVyID0gZnVuY3Rpb24oY29tcG9uZW50TmFtZSkge1xuICAgICAgICBkZWxldGUgZGVmYXVsdENvbmZpZ1JlZ2lzdHJ5W2NvbXBvbmVudE5hbWVdO1xuICAgICAgICBrby5jb21wb25lbnRzLmNsZWFyQ2FjaGVkRGVmaW5pdGlvbihjb21wb25lbnROYW1lKTtcbiAgICB9O1xuXG4gICAga28uY29tcG9uZW50cy5kZWZhdWx0TG9hZGVyID0ge1xuICAgICAgICAnZ2V0Q29uZmlnJzogZnVuY3Rpb24oY29tcG9uZW50TmFtZSwgY2FsbGJhY2spIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBkZWZhdWx0Q29uZmlnUmVnaXN0cnkuaGFzT3duUHJvcGVydHkoY29tcG9uZW50TmFtZSlcbiAgICAgICAgICAgICAgICA/IGRlZmF1bHRDb25maWdSZWdpc3RyeVtjb21wb25lbnROYW1lXVxuICAgICAgICAgICAgICAgIDogbnVsbDtcbiAgICAgICAgICAgIGNhbGxiYWNrKHJlc3VsdCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgJ2xvYWRDb21wb25lbnQnOiBmdW5jdGlvbihjb21wb25lbnROYW1lLCBjb25maWcsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICB2YXIgZXJyb3JDYWxsYmFjayA9IG1ha2VFcnJvckNhbGxiYWNrKGNvbXBvbmVudE5hbWUpO1xuICAgICAgICAgICAgcG9zc2libHlHZXRDb25maWdGcm9tQW1kKGVycm9yQ2FsbGJhY2ssIGNvbmZpZywgZnVuY3Rpb24obG9hZGVkQ29uZmlnKSB7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZUNvbmZpZyhjb21wb25lbnROYW1lLCBlcnJvckNhbGxiYWNrLCBsb2FkZWRDb25maWcsIGNhbGxiYWNrKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuXG4gICAgICAgICdsb2FkVGVtcGxhdGUnOiBmdW5jdGlvbihjb21wb25lbnROYW1lLCB0ZW1wbGF0ZUNvbmZpZywgY2FsbGJhY2spIHtcbiAgICAgICAgICAgIHJlc29sdmVUZW1wbGF0ZShtYWtlRXJyb3JDYWxsYmFjayhjb21wb25lbnROYW1lKSwgdGVtcGxhdGVDb25maWcsIGNhbGxiYWNrKTtcbiAgICAgICAgfSxcblxuICAgICAgICAnbG9hZFZpZXdNb2RlbCc6IGZ1bmN0aW9uKGNvbXBvbmVudE5hbWUsIHZpZXdNb2RlbENvbmZpZywgY2FsbGJhY2spIHtcbiAgICAgICAgICAgIHJlc29sdmVWaWV3TW9kZWwobWFrZUVycm9yQ2FsbGJhY2soY29tcG9uZW50TmFtZSksIHZpZXdNb2RlbENvbmZpZywgY2FsbGJhY2spO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHZhciBjcmVhdGVWaWV3TW9kZWxLZXkgPSAnY3JlYXRlVmlld01vZGVsJztcblxuICAgIC8vIFRha2VzIGEgY29uZmlnIG9iamVjdCBvZiB0aGUgZm9ybSB7IHRlbXBsYXRlOiAuLi4sIHZpZXdNb2RlbDogLi4uIH0sIGFuZCBhc3luY2hyb25vdXNseSBjb252ZXJ0IGl0XG4gICAgLy8gaW50byB0aGUgc3RhbmRhcmQgY29tcG9uZW50IGRlZmluaXRpb24gZm9ybWF0OlxuICAgIC8vICAgIHsgdGVtcGxhdGU6IDxBcnJheU9mRG9tTm9kZXM+LCBjcmVhdGVWaWV3TW9kZWw6IGZ1bmN0aW9uKHBhcmFtcywgY29tcG9uZW50SW5mbykgeyAuLi4gfSB9LlxuICAgIC8vIFNpbmNlIGJvdGggdGVtcGxhdGUgYW5kIHZpZXdNb2RlbCBtYXkgbmVlZCB0byBiZSByZXNvbHZlZCBhc3luY2hyb25vdXNseSwgYm90aCB0YXNrcyBhcmUgcGVyZm9ybWVkXG4gICAgLy8gaW4gcGFyYWxsZWwsIGFuZCB0aGUgcmVzdWx0cyBqb2luZWQgd2hlbiBib3RoIGFyZSByZWFkeS4gV2UgZG9uJ3QgZGVwZW5kIG9uIGFueSBwcm9taXNlcyBpbmZyYXN0cnVjdHVyZSxcbiAgICAvLyBzbyB0aGlzIGlzIGltcGxlbWVudGVkIG1hbnVhbGx5IGJlbG93LlxuICAgIGZ1bmN0aW9uIHJlc29sdmVDb25maWcoY29tcG9uZW50TmFtZSwgZXJyb3JDYWxsYmFjaywgY29uZmlnLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgcmVzdWx0ID0ge30sXG4gICAgICAgICAgICBtYWtlQ2FsbEJhY2tXaGVuWmVybyA9IDIsXG4gICAgICAgICAgICB0cnlJc3N1ZUNhbGxiYWNrID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgaWYgKC0tbWFrZUNhbGxCYWNrV2hlblplcm8gPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2socmVzdWx0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdGVtcGxhdGVDb25maWcgPSBjb25maWdbJ3RlbXBsYXRlJ10sXG4gICAgICAgICAgICB2aWV3TW9kZWxDb25maWcgPSBjb25maWdbJ3ZpZXdNb2RlbCddO1xuXG4gICAgICAgIGlmICh0ZW1wbGF0ZUNvbmZpZykge1xuICAgICAgICAgICAgcG9zc2libHlHZXRDb25maWdGcm9tQW1kKGVycm9yQ2FsbGJhY2ssIHRlbXBsYXRlQ29uZmlnLCBmdW5jdGlvbihsb2FkZWRDb25maWcpIHtcbiAgICAgICAgICAgICAgICBrby5jb21wb25lbnRzLl9nZXRGaXJzdFJlc3VsdEZyb21Mb2FkZXJzKCdsb2FkVGVtcGxhdGUnLCBbY29tcG9uZW50TmFtZSwgbG9hZGVkQ29uZmlnXSwgZnVuY3Rpb24ocmVzb2x2ZWRUZW1wbGF0ZSkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHRbJ3RlbXBsYXRlJ10gPSByZXNvbHZlZFRlbXBsYXRlO1xuICAgICAgICAgICAgICAgICAgICB0cnlJc3N1ZUNhbGxiYWNrKCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRyeUlzc3VlQ2FsbGJhY2soKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh2aWV3TW9kZWxDb25maWcpIHtcbiAgICAgICAgICAgIHBvc3NpYmx5R2V0Q29uZmlnRnJvbUFtZChlcnJvckNhbGxiYWNrLCB2aWV3TW9kZWxDb25maWcsIGZ1bmN0aW9uKGxvYWRlZENvbmZpZykge1xuICAgICAgICAgICAgICAgIGtvLmNvbXBvbmVudHMuX2dldEZpcnN0UmVzdWx0RnJvbUxvYWRlcnMoJ2xvYWRWaWV3TW9kZWwnLCBbY29tcG9uZW50TmFtZSwgbG9hZGVkQ29uZmlnXSwgZnVuY3Rpb24ocmVzb2x2ZWRWaWV3TW9kZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0W2NyZWF0ZVZpZXdNb2RlbEtleV0gPSByZXNvbHZlZFZpZXdNb2RlbDtcbiAgICAgICAgICAgICAgICAgICAgdHJ5SXNzdWVDYWxsYmFjaygpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0cnlJc3N1ZUNhbGxiYWNrKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZXNvbHZlVGVtcGxhdGUoZXJyb3JDYWxsYmFjaywgdGVtcGxhdGVDb25maWcsIGNhbGxiYWNrKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdGVtcGxhdGVDb25maWcgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAvLyBNYXJrdXAgLSBwYXJzZSBpdFxuICAgICAgICAgICAgY2FsbGJhY2soa28udXRpbHMucGFyc2VIdG1sRnJhZ21lbnQodGVtcGxhdGVDb25maWcpKTtcbiAgICAgICAgfSBlbHNlIGlmICh0ZW1wbGF0ZUNvbmZpZyBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgICAgICAvLyBBc3N1bWUgYWxyZWFkeSBhbiBhcnJheSBvZiBET00gbm9kZXMgLSBwYXNzIHRocm91Z2ggdW5jaGFuZ2VkXG4gICAgICAgICAgICBjYWxsYmFjayh0ZW1wbGF0ZUNvbmZpZyk7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNEb2N1bWVudEZyYWdtZW50KHRlbXBsYXRlQ29uZmlnKSkge1xuICAgICAgICAgICAgLy8gRG9jdW1lbnQgZnJhZ21lbnQgLSB1c2UgaXRzIGNoaWxkIG5vZGVzXG4gICAgICAgICAgICBjYWxsYmFjayhrby51dGlscy5tYWtlQXJyYXkodGVtcGxhdGVDb25maWcuY2hpbGROb2RlcykpO1xuICAgICAgICB9IGVsc2UgaWYgKHRlbXBsYXRlQ29uZmlnWydlbGVtZW50J10pIHtcbiAgICAgICAgICAgIHZhciBlbGVtZW50ID0gdGVtcGxhdGVDb25maWdbJ2VsZW1lbnQnXTtcbiAgICAgICAgICAgIGlmIChpc0RvbUVsZW1lbnQoZWxlbWVudCkpIHtcbiAgICAgICAgICAgICAgICAvLyBFbGVtZW50IGluc3RhbmNlIC0gY29weSBpdHMgY2hpbGQgbm9kZXNcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhjbG9uZU5vZGVzRnJvbVRlbXBsYXRlU291cmNlRWxlbWVudChlbGVtZW50KSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBlbGVtZW50ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIC8vIEVsZW1lbnQgSUQgLSBmaW5kIGl0LCB0aGVuIGNvcHkgaXRzIGNoaWxkIG5vZGVzXG4gICAgICAgICAgICAgICAgdmFyIGVsZW1JbnN0YW5jZSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGVsZW1lbnQpO1xuICAgICAgICAgICAgICAgIGlmIChlbGVtSW5zdGFuY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soY2xvbmVOb2Rlc0Zyb21UZW1wbGF0ZVNvdXJjZUVsZW1lbnQoZWxlbUluc3RhbmNlKSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3JDYWxsYmFjaygnQ2Fubm90IGZpbmQgZWxlbWVudCB3aXRoIElEICcgKyBlbGVtZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGVycm9yQ2FsbGJhY2soJ1Vua25vd24gZWxlbWVudCB0eXBlOiAnICsgZWxlbWVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBlcnJvckNhbGxiYWNrKCdVbmtub3duIHRlbXBsYXRlIHZhbHVlOiAnICsgdGVtcGxhdGVDb25maWcpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVzb2x2ZVZpZXdNb2RlbChlcnJvckNhbGxiYWNrLCB2aWV3TW9kZWxDb25maWcsIGNhbGxiYWNrKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygdmlld01vZGVsQ29uZmlnID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAvLyBDb25zdHJ1Y3RvciAtIGNvbnZlcnQgdG8gc3RhbmRhcmQgZmFjdG9yeSBmdW5jdGlvbiBmb3JtYXRcbiAgICAgICAgICAgIC8vIEJ5IGRlc2lnbiwgdGhpcyBkb2VzICpub3QqIHN1cHBseSBjb21wb25lbnRJbmZvIHRvIHRoZSBjb25zdHJ1Y3RvciwgYXMgdGhlIGludGVudCBpcyB0aGF0XG4gICAgICAgICAgICAvLyBjb21wb25lbnRJbmZvIGNvbnRhaW5zIG5vbi12aWV3bW9kZWwgZGF0YSAoZS5nLiwgdGhlIGNvbXBvbmVudCdzIGVsZW1lbnQpIHRoYXQgc2hvdWxkIG9ubHlcbiAgICAgICAgICAgIC8vIGJlIHVzZWQgaW4gZmFjdG9yeSBmdW5jdGlvbnMsIG5vdCB2aWV3bW9kZWwgY29uc3RydWN0b3JzLlxuICAgICAgICAgICAgY2FsbGJhY2soZnVuY3Rpb24gKHBhcmFtcyAvKiwgY29tcG9uZW50SW5mbyAqLykge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgdmlld01vZGVsQ29uZmlnKHBhcmFtcyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2Ygdmlld01vZGVsQ29uZmlnW2NyZWF0ZVZpZXdNb2RlbEtleV0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIC8vIEFscmVhZHkgYSBmYWN0b3J5IGZ1bmN0aW9uIC0gdXNlIGl0IGFzLWlzXG4gICAgICAgICAgICBjYWxsYmFjayh2aWV3TW9kZWxDb25maWdbY3JlYXRlVmlld01vZGVsS2V5XSk7XG4gICAgICAgIH0gZWxzZSBpZiAoJ2luc3RhbmNlJyBpbiB2aWV3TW9kZWxDb25maWcpIHtcbiAgICAgICAgICAgIC8vIEZpeGVkIG9iamVjdCBpbnN0YW5jZSAtIHByb21vdGUgdG8gY3JlYXRlVmlld01vZGVsIGZvcm1hdCBmb3IgQVBJIGNvbnNpc3RlbmN5XG4gICAgICAgICAgICB2YXIgZml4ZWRJbnN0YW5jZSA9IHZpZXdNb2RlbENvbmZpZ1snaW5zdGFuY2UnXTtcbiAgICAgICAgICAgIGNhbGxiYWNrKGZ1bmN0aW9uIChwYXJhbXMsIGNvbXBvbmVudEluZm8pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZml4ZWRJbnN0YW5jZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2UgaWYgKCd2aWV3TW9kZWwnIGluIHZpZXdNb2RlbENvbmZpZykge1xuICAgICAgICAgICAgLy8gUmVzb2x2ZWQgQU1EIG1vZHVsZSB3aG9zZSB2YWx1ZSBpcyBvZiB0aGUgZm9ybSB7IHZpZXdNb2RlbDogLi4uIH1cbiAgICAgICAgICAgIHJlc29sdmVWaWV3TW9kZWwoZXJyb3JDYWxsYmFjaywgdmlld01vZGVsQ29uZmlnWyd2aWV3TW9kZWwnXSwgY2FsbGJhY2spO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZXJyb3JDYWxsYmFjaygnVW5rbm93biB2aWV3TW9kZWwgdmFsdWU6ICcgKyB2aWV3TW9kZWxDb25maWcpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2xvbmVOb2Rlc0Zyb21UZW1wbGF0ZVNvdXJjZUVsZW1lbnQoZWxlbUluc3RhbmNlKSB7XG4gICAgICAgIHN3aXRjaCAoa28udXRpbHMudGFnTmFtZUxvd2VyKGVsZW1JbnN0YW5jZSkpIHtcbiAgICAgICAgICAgIGNhc2UgJ3NjcmlwdCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGtvLnV0aWxzLnBhcnNlSHRtbEZyYWdtZW50KGVsZW1JbnN0YW5jZS50ZXh0KTtcbiAgICAgICAgICAgIGNhc2UgJ3RleHRhcmVhJzpcbiAgICAgICAgICAgICAgICByZXR1cm4ga28udXRpbHMucGFyc2VIdG1sRnJhZ21lbnQoZWxlbUluc3RhbmNlLnZhbHVlKTtcbiAgICAgICAgICAgIGNhc2UgJ3RlbXBsYXRlJzpcbiAgICAgICAgICAgICAgICAvLyBGb3IgYnJvd3NlcnMgd2l0aCBwcm9wZXIgPHRlbXBsYXRlPiBlbGVtZW50IHN1cHBvcnQgKGkuZS4sIHdoZXJlIHRoZSAuY29udGVudCBwcm9wZXJ0eVxuICAgICAgICAgICAgICAgIC8vIGdpdmVzIGEgZG9jdW1lbnQgZnJhZ21lbnQpLCB1c2UgdGhhdCBkb2N1bWVudCBmcmFnbWVudC5cbiAgICAgICAgICAgICAgICBpZiAoaXNEb2N1bWVudEZyYWdtZW50KGVsZW1JbnN0YW5jZS5jb250ZW50KSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4ga28udXRpbHMuY2xvbmVOb2RlcyhlbGVtSW5zdGFuY2UuY29udGVudC5jaGlsZE5vZGVzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBSZWd1bGFyIGVsZW1lbnRzIHN1Y2ggYXMgPGRpdj4sIGFuZCA8dGVtcGxhdGU+IGVsZW1lbnRzIG9uIG9sZCBicm93c2VycyB0aGF0IGRvbid0IHJlYWxseVxuICAgICAgICAvLyB1bmRlcnN0YW5kIDx0ZW1wbGF0ZT4gYW5kIGp1c3QgdHJlYXQgaXQgYXMgYSByZWd1bGFyIGNvbnRhaW5lclxuICAgICAgICByZXR1cm4ga28udXRpbHMuY2xvbmVOb2RlcyhlbGVtSW5zdGFuY2UuY2hpbGROb2Rlcyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNEb21FbGVtZW50KG9iaikge1xuICAgICAgICBpZiAod2luZG93WydIVE1MRWxlbWVudCddKSB7XG4gICAgICAgICAgICByZXR1cm4gb2JqIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gb2JqICYmIG9iai50YWdOYW1lICYmIG9iai5ub2RlVHlwZSA9PT0gMTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzRG9jdW1lbnRGcmFnbWVudChvYmopIHtcbiAgICAgICAgaWYgKHdpbmRvd1snRG9jdW1lbnRGcmFnbWVudCddKSB7XG4gICAgICAgICAgICByZXR1cm4gb2JqIGluc3RhbmNlb2YgRG9jdW1lbnRGcmFnbWVudDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBvYmogJiYgb2JqLm5vZGVUeXBlID09PSAxMTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBvc3NpYmx5R2V0Q29uZmlnRnJvbUFtZChlcnJvckNhbGxiYWNrLCBjb25maWcsIGNhbGxiYWNrKSB7XG4gICAgICAgIGlmICh0eXBlb2YgY29uZmlnWydyZXF1aXJlJ10gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAvLyBUaGUgY29uZmlnIGlzIHRoZSB2YWx1ZSBvZiBhbiBBTUQgbW9kdWxlXG4gICAgICAgICAgICBpZiAoYW1kUmVxdWlyZSB8fCB3aW5kb3dbJ3JlcXVpcmUnXSkge1xuICAgICAgICAgICAgICAgIChhbWRSZXF1aXJlIHx8IHdpbmRvd1sncmVxdWlyZSddKShbY29uZmlnWydyZXF1aXJlJ11dLCBjYWxsYmFjayk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGVycm9yQ2FsbGJhY2soJ1VzZXMgcmVxdWlyZSwgYnV0IG5vIEFNRCBsb2FkZXIgaXMgcHJlc2VudCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FsbGJhY2soY29uZmlnKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1ha2VFcnJvckNhbGxiYWNrKGNvbXBvbmVudE5hbWUpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChtZXNzYWdlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvbXBvbmVudCBcXCcnICsgY29tcG9uZW50TmFtZSArICdcXCc6ICcgKyBtZXNzYWdlKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBrby5leHBvcnRTeW1ib2woJ2NvbXBvbmVudHMucmVnaXN0ZXInLCBrby5jb21wb25lbnRzLnJlZ2lzdGVyKTtcbiAgICBrby5leHBvcnRTeW1ib2woJ2NvbXBvbmVudHMuaXNSZWdpc3RlcmVkJywga28uY29tcG9uZW50cy5pc1JlZ2lzdGVyZWQpO1xuICAgIGtvLmV4cG9ydFN5bWJvbCgnY29tcG9uZW50cy51bnJlZ2lzdGVyJywga28uY29tcG9uZW50cy51bnJlZ2lzdGVyKTtcblxuICAgIC8vIEV4cG9zZSB0aGUgZGVmYXVsdCBsb2FkZXIgc28gdGhhdCBkZXZlbG9wZXJzIGNhbiBkaXJlY3RseSBhc2sgaXQgZm9yIGNvbmZpZ3VyYXRpb25cbiAgICAvLyBvciB0byByZXNvbHZlIGNvbmZpZ3VyYXRpb25cbiAgICBrby5leHBvcnRTeW1ib2woJ2NvbXBvbmVudHMuZGVmYXVsdExvYWRlcicsIGtvLmNvbXBvbmVudHMuZGVmYXVsdExvYWRlcik7XG5cbiAgICAvLyBCeSBkZWZhdWx0LCB0aGUgZGVmYXVsdCBsb2FkZXIgaXMgdGhlIG9ubHkgcmVnaXN0ZXJlZCBjb21wb25lbnQgbG9hZGVyXG4gICAga28uY29tcG9uZW50c1snbG9hZGVycyddLnB1c2goa28uY29tcG9uZW50cy5kZWZhdWx0TG9hZGVyKTtcblxuICAgIC8vIFByaXZhdGVseSBleHBvc2UgdGhlIHVuZGVybHlpbmcgY29uZmlnIHJlZ2lzdHJ5IGZvciB1c2UgaW4gb2xkLUlFIHNoaW1cbiAgICBrby5jb21wb25lbnRzLl9hbGxSZWdpc3RlcmVkQ29tcG9uZW50cyA9IGRlZmF1bHRDb25maWdSZWdpc3RyeTtcbn0pKCk7XG4oZnVuY3Rpb24gKHVuZGVmaW5lZCkge1xuICAgIC8vIE92ZXJyaWRhYmxlIEFQSSBmb3IgZGV0ZXJtaW5pbmcgd2hpY2ggY29tcG9uZW50IG5hbWUgYXBwbGllcyB0byBhIGdpdmVuIG5vZGUuIEJ5IG92ZXJyaWRpbmcgdGhpcyxcbiAgICAvLyB5b3UgY2FuIGZvciBleGFtcGxlIG1hcCBzcGVjaWZpYyB0YWdOYW1lcyB0byBjb21wb25lbnRzIHRoYXQgYXJlIG5vdCBwcmVyZWdpc3RlcmVkLlxuICAgIGtvLmNvbXBvbmVudHNbJ2dldENvbXBvbmVudE5hbWVGb3JOb2RlJ10gPSBmdW5jdGlvbihub2RlKSB7XG4gICAgICAgIHZhciB0YWdOYW1lTG93ZXIgPSBrby51dGlscy50YWdOYW1lTG93ZXIobm9kZSk7XG4gICAgICAgIGlmIChrby5jb21wb25lbnRzLmlzUmVnaXN0ZXJlZCh0YWdOYW1lTG93ZXIpKSB7XG4gICAgICAgICAgICAvLyBUcnkgdG8gZGV0ZXJtaW5lIHRoYXQgdGhpcyBub2RlIGNhbiBiZSBjb25zaWRlcmVkIGEgKmN1c3RvbSogZWxlbWVudDsgc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9rbm9ja291dC9rbm9ja291dC9pc3N1ZXMvMTYwM1xuICAgICAgICAgICAgaWYgKHRhZ05hbWVMb3dlci5pbmRleE9mKCctJykgIT0gLTEgfHwgKCcnICsgbm9kZSkgPT0gXCJbb2JqZWN0IEhUTUxVbmtub3duRWxlbWVudF1cIiB8fCAoa28udXRpbHMuaWVWZXJzaW9uIDw9IDggJiYgbm9kZS50YWdOYW1lID09PSB0YWdOYW1lTG93ZXIpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRhZ05hbWVMb3dlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBrby5jb21wb25lbnRzLmFkZEJpbmRpbmdzRm9yQ3VzdG9tRWxlbWVudCA9IGZ1bmN0aW9uKGFsbEJpbmRpbmdzLCBub2RlLCBiaW5kaW5nQ29udGV4dCwgdmFsdWVBY2Nlc3NvcnMpIHtcbiAgICAgICAgLy8gRGV0ZXJtaW5lIGlmIGl0J3MgcmVhbGx5IGEgY3VzdG9tIGVsZW1lbnQgbWF0Y2hpbmcgYSBjb21wb25lbnRcbiAgICAgICAgaWYgKG5vZGUubm9kZVR5cGUgPT09IDEpIHtcbiAgICAgICAgICAgIHZhciBjb21wb25lbnROYW1lID0ga28uY29tcG9uZW50c1snZ2V0Q29tcG9uZW50TmFtZUZvck5vZGUnXShub2RlKTtcbiAgICAgICAgICAgIGlmIChjb21wb25lbnROYW1lKSB7XG4gICAgICAgICAgICAgICAgLy8gSXQgZG9lcyByZXByZXNlbnQgYSBjb21wb25lbnQsIHNvIGFkZCBhIGNvbXBvbmVudCBiaW5kaW5nIGZvciBpdFxuICAgICAgICAgICAgICAgIGFsbEJpbmRpbmdzID0gYWxsQmluZGluZ3MgfHwge307XG5cbiAgICAgICAgICAgICAgICBpZiAoYWxsQmluZGluZ3NbJ2NvbXBvbmVudCddKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEF2b2lkIHNpbGVudGx5IG92ZXJ3cml0aW5nIHNvbWUgb3RoZXIgJ2NvbXBvbmVudCcgYmluZGluZyB0aGF0IG1heSBhbHJlYWR5IGJlIG9uIHRoZSBlbGVtZW50XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IHVzZSB0aGUgXCJjb21wb25lbnRcIiBiaW5kaW5nIG9uIGEgY3VzdG9tIGVsZW1lbnQgbWF0Y2hpbmcgYSBjb21wb25lbnQnKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgY29tcG9uZW50QmluZGluZ1ZhbHVlID0geyAnbmFtZSc6IGNvbXBvbmVudE5hbWUsICdwYXJhbXMnOiBnZXRDb21wb25lbnRQYXJhbXNGcm9tQ3VzdG9tRWxlbWVudChub2RlLCBiaW5kaW5nQ29udGV4dCkgfTtcblxuICAgICAgICAgICAgICAgIGFsbEJpbmRpbmdzWydjb21wb25lbnQnXSA9IHZhbHVlQWNjZXNzb3JzXG4gICAgICAgICAgICAgICAgICAgID8gZnVuY3Rpb24oKSB7IHJldHVybiBjb21wb25lbnRCaW5kaW5nVmFsdWU7IH1cbiAgICAgICAgICAgICAgICAgICAgOiBjb21wb25lbnRCaW5kaW5nVmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYWxsQmluZGluZ3M7XG4gICAgfVxuXG4gICAgdmFyIG5hdGl2ZUJpbmRpbmdQcm92aWRlckluc3RhbmNlID0gbmV3IGtvLmJpbmRpbmdQcm92aWRlcigpO1xuXG4gICAgZnVuY3Rpb24gZ2V0Q29tcG9uZW50UGFyYW1zRnJvbUN1c3RvbUVsZW1lbnQoZWxlbSwgYmluZGluZ0NvbnRleHQpIHtcbiAgICAgICAgdmFyIHBhcmFtc0F0dHJpYnV0ZSA9IGVsZW0uZ2V0QXR0cmlidXRlKCdwYXJhbXMnKTtcblxuICAgICAgICBpZiAocGFyYW1zQXR0cmlidXRlKSB7XG4gICAgICAgICAgICB2YXIgcGFyYW1zID0gbmF0aXZlQmluZGluZ1Byb3ZpZGVySW5zdGFuY2VbJ3BhcnNlQmluZGluZ3NTdHJpbmcnXShwYXJhbXNBdHRyaWJ1dGUsIGJpbmRpbmdDb250ZXh0LCBlbGVtLCB7ICd2YWx1ZUFjY2Vzc29ycyc6IHRydWUsICdiaW5kaW5nUGFyYW1zJzogdHJ1ZSB9KSxcbiAgICAgICAgICAgICAgICByYXdQYXJhbUNvbXB1dGVkVmFsdWVzID0ga28udXRpbHMub2JqZWN0TWFwKHBhcmFtcywgZnVuY3Rpb24ocGFyYW1WYWx1ZSwgcGFyYW1OYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBrby5jb21wdXRlZChwYXJhbVZhbHVlLCBudWxsLCB7IGRpc3Bvc2VXaGVuTm9kZUlzUmVtb3ZlZDogZWxlbSB9KTtcbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBrby51dGlscy5vYmplY3RNYXAocmF3UGFyYW1Db21wdXRlZFZhbHVlcywgZnVuY3Rpb24ocGFyYW1WYWx1ZUNvbXB1dGVkLCBwYXJhbU5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBhcmFtVmFsdWUgPSBwYXJhbVZhbHVlQ29tcHV0ZWQucGVlaygpO1xuICAgICAgICAgICAgICAgICAgICAvLyBEb2VzIHRoZSBldmFsdWF0aW9uIG9mIHRoZSBwYXJhbWV0ZXIgdmFsdWUgdW53cmFwIGFueSBvYnNlcnZhYmxlcz9cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFwYXJhbVZhbHVlQ29tcHV0ZWQuaXNBY3RpdmUoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gTm8gaXQgZG9lc24ndCwgc28gdGhlcmUncyBubyBuZWVkIGZvciBhbnkgY29tcHV0ZWQgd3JhcHBlci4gSnVzdCBwYXNzIHRocm91Z2ggdGhlIHN1cHBsaWVkIHZhbHVlIGRpcmVjdGx5LlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRXhhbXBsZTogXCJzb21lVmFsOiBmaXJzdE5hbWUsIGFnZTogMTIzXCIgKHdoZXRoZXIgb3Igbm90IGZpcnN0TmFtZSBpcyBhbiBvYnNlcnZhYmxlL2NvbXB1dGVkKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBhcmFtVmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBZZXMgaXQgZG9lcy4gU3VwcGx5IGEgY29tcHV0ZWQgcHJvcGVydHkgdGhhdCB1bndyYXBzIGJvdGggdGhlIG91dGVyIChiaW5kaW5nIGV4cHJlc3Npb24pXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBsZXZlbCBvZiBvYnNlcnZhYmlsaXR5LCBhbmQgYW55IGlubmVyIChyZXN1bHRpbmcgbW9kZWwgdmFsdWUpIGxldmVsIG9mIG9ic2VydmFiaWxpdHkuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGlzIG1lYW5zIHRoZSBjb21wb25lbnQgZG9lc24ndCBoYXZlIHRvIHdvcnJ5IGFib3V0IG11bHRpcGxlIHVud3JhcHBpbmcuIElmIHRoZSB2YWx1ZSBpcyBhXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB3cml0YWJsZSBvYnNlcnZhYmxlLCB0aGUgY29tcHV0ZWQgd2lsbCBhbHNvIGJlIHdyaXRhYmxlIGFuZCBwYXNzIHRoZSB2YWx1ZSBvbiB0byB0aGUgb2JzZXJ2YWJsZS5cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBrby5jb21wdXRlZCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3JlYWQnOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGtvLnV0aWxzLnVud3JhcE9ic2VydmFibGUocGFyYW1WYWx1ZUNvbXB1dGVkKCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3dyaXRlJzoga28uaXNXcml0ZWFibGVPYnNlcnZhYmxlKHBhcmFtVmFsdWUpICYmIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtVmFsdWVDb21wdXRlZCgpKHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpc3Bvc2VXaGVuTm9kZUlzUmVtb3ZlZDogZWxlbVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgLy8gR2l2ZSBhY2Nlc3MgdG8gdGhlIHJhdyBjb21wdXRlZHMsIGFzIGxvbmcgYXMgdGhhdCB3b3VsZG4ndCBvdmVyd3JpdGUgYW55IGN1c3RvbSBwYXJhbSBhbHNvIGNhbGxlZCAnJHJhdydcbiAgICAgICAgICAgIC8vIFRoaXMgaXMgaW4gY2FzZSB0aGUgZGV2ZWxvcGVyIHdhbnRzIHRvIHJlYWN0IHRvIG91dGVyIChiaW5kaW5nKSBvYnNlcnZhYmlsaXR5IHNlcGFyYXRlbHkgZnJvbSBpbm5lclxuICAgICAgICAgICAgLy8gKG1vZGVsIHZhbHVlKSBvYnNlcnZhYmlsaXR5LCBvciBpbiBjYXNlIHRoZSBtb2RlbCB2YWx1ZSBvYnNlcnZhYmxlIGhhcyBzdWJvYnNlcnZhYmxlcy5cbiAgICAgICAgICAgIGlmICghcmVzdWx0Lmhhc093blByb3BlcnR5KCckcmF3JykpIHtcbiAgICAgICAgICAgICAgICByZXN1bHRbJyRyYXcnXSA9IHJhd1BhcmFtQ29tcHV0ZWRWYWx1ZXM7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBGb3IgY29uc2lzdGVuY3ksIGFic2VuY2Ugb2YgYSBcInBhcmFtc1wiIGF0dHJpYnV0ZSBpcyB0cmVhdGVkIHRoZSBzYW1lIGFzIHRoZSBwcmVzZW5jZSBvZlxuICAgICAgICAgICAgLy8gYW55IGVtcHR5IG9uZS4gT3RoZXJ3aXNlIGNvbXBvbmVudCB2aWV3bW9kZWxzIG5lZWQgc3BlY2lhbCBjb2RlIHRvIGNoZWNrIHdoZXRoZXIgb3Igbm90XG4gICAgICAgICAgICAvLyAncGFyYW1zJyBvciAncGFyYW1zLiRyYXcnIGlzIG51bGwvdW5kZWZpbmVkIGJlZm9yZSByZWFkaW5nIHN1YnByb3BlcnRpZXMsIHdoaWNoIGlzIGFubm95aW5nLlxuICAgICAgICAgICAgcmV0dXJuIHsgJyRyYXcnOiB7fSB9O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvLyBDb21wYXRpYmlsaXR5IGNvZGUgZm9yIG9sZGVyIChwcmUtSFRNTDUpIElFIGJyb3dzZXJzXG5cbiAgICBpZiAoa28udXRpbHMuaWVWZXJzaW9uIDwgOSkge1xuICAgICAgICAvLyBXaGVuZXZlciB5b3UgcHJlcmVnaXN0ZXIgYSBjb21wb25lbnQsIGVuYWJsZSBpdCBhcyBhIGN1c3RvbSBlbGVtZW50IGluIHRoZSBjdXJyZW50IGRvY3VtZW50XG4gICAgICAgIGtvLmNvbXBvbmVudHNbJ3JlZ2lzdGVyJ10gPSAoZnVuY3Rpb24ob3JpZ2luYWxGdW5jdGlvbikge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKGNvbXBvbmVudE5hbWUpIHtcbiAgICAgICAgICAgICAgICBkb2N1bWVudC5jcmVhdGVFbGVtZW50KGNvbXBvbmVudE5hbWUpOyAvLyBBbGxvd3MgSUU8OSB0byBwYXJzZSBtYXJrdXAgY29udGFpbmluZyB0aGUgY3VzdG9tIGVsZW1lbnRcbiAgICAgICAgICAgICAgICByZXR1cm4gb3JpZ2luYWxGdW5jdGlvbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KShrby5jb21wb25lbnRzWydyZWdpc3RlciddKTtcblxuICAgICAgICAvLyBXaGVuZXZlciB5b3UgY3JlYXRlIGEgZG9jdW1lbnQgZnJhZ21lbnQsIGVuYWJsZSBhbGwgcHJlcmVnaXN0ZXJlZCBjb21wb25lbnQgbmFtZXMgYXMgY3VzdG9tIGVsZW1lbnRzXG4gICAgICAgIC8vIFRoaXMgaXMgbmVlZGVkIHRvIG1ha2UgaW5uZXJTaGl2L2pRdWVyeSBIVE1MIHBhcnNpbmcgY29ycmVjdGx5IGhhbmRsZSB0aGUgY3VzdG9tIGVsZW1lbnRzXG4gICAgICAgIGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQgPSAoZnVuY3Rpb24ob3JpZ2luYWxGdW5jdGlvbikge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHZhciBuZXdEb2NGcmFnID0gb3JpZ2luYWxGdW5jdGlvbigpLFxuICAgICAgICAgICAgICAgICAgICBhbGxDb21wb25lbnRzID0ga28uY29tcG9uZW50cy5fYWxsUmVnaXN0ZXJlZENvbXBvbmVudHM7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgY29tcG9uZW50TmFtZSBpbiBhbGxDb21wb25lbnRzKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChhbGxDb21wb25lbnRzLmhhc093blByb3BlcnR5KGNvbXBvbmVudE5hbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdEb2NGcmFnLmNyZWF0ZUVsZW1lbnQoY29tcG9uZW50TmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ld0RvY0ZyYWc7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9KShkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KTtcbiAgICB9XG59KSgpOyhmdW5jdGlvbih1bmRlZmluZWQpIHtcblxuICAgIHZhciBjb21wb25lbnRMb2FkaW5nT3BlcmF0aW9uVW5pcXVlSWQgPSAwO1xuXG4gICAga28uYmluZGluZ0hhbmRsZXJzWydjb21wb25lbnQnXSA9IHtcbiAgICAgICAgJ2luaXQnOiBmdW5jdGlvbihlbGVtZW50LCB2YWx1ZUFjY2Vzc29yLCBpZ25vcmVkMSwgaWdub3JlZDIsIGJpbmRpbmdDb250ZXh0KSB7XG4gICAgICAgICAgICB2YXIgY3VycmVudFZpZXdNb2RlbCxcbiAgICAgICAgICAgICAgICBjdXJyZW50TG9hZGluZ09wZXJhdGlvbklkLFxuICAgICAgICAgICAgICAgIGRpc3Bvc2VBc3NvY2lhdGVkQ29tcG9uZW50Vmlld01vZGVsID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgY3VycmVudFZpZXdNb2RlbERpc3Bvc2UgPSBjdXJyZW50Vmlld01vZGVsICYmIGN1cnJlbnRWaWV3TW9kZWxbJ2Rpc3Bvc2UnXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBjdXJyZW50Vmlld01vZGVsRGlzcG9zZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFZpZXdNb2RlbERpc3Bvc2UuY2FsbChjdXJyZW50Vmlld01vZGVsKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50Vmlld01vZGVsID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgLy8gQW55IGluLWZsaWdodCBsb2FkaW5nIG9wZXJhdGlvbiBpcyBubyBsb25nZXIgcmVsZXZhbnQsIHNvIG1ha2Ugc3VyZSB3ZSBpZ25vcmUgaXRzIGNvbXBsZXRpb25cbiAgICAgICAgICAgICAgICAgICAgY3VycmVudExvYWRpbmdPcGVyYXRpb25JZCA9IG51bGw7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBvcmlnaW5hbENoaWxkTm9kZXMgPSBrby51dGlscy5tYWtlQXJyYXkoa28udmlydHVhbEVsZW1lbnRzLmNoaWxkTm9kZXMoZWxlbWVudCkpO1xuXG4gICAgICAgICAgICBrby51dGlscy5kb21Ob2RlRGlzcG9zYWwuYWRkRGlzcG9zZUNhbGxiYWNrKGVsZW1lbnQsIGRpc3Bvc2VBc3NvY2lhdGVkQ29tcG9uZW50Vmlld01vZGVsKTtcblxuICAgICAgICAgICAga28uY29tcHV0ZWQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IGtvLnV0aWxzLnVud3JhcE9ic2VydmFibGUodmFsdWVBY2Nlc3NvcigpKSxcbiAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50TmFtZSwgY29tcG9uZW50UGFyYW1zO1xuXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50TmFtZSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudE5hbWUgPSBrby51dGlscy51bndyYXBPYnNlcnZhYmxlKHZhbHVlWyduYW1lJ10pO1xuICAgICAgICAgICAgICAgICAgICBjb21wb25lbnRQYXJhbXMgPSBrby51dGlscy51bndyYXBPYnNlcnZhYmxlKHZhbHVlWydwYXJhbXMnXSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKCFjb21wb25lbnROYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTm8gY29tcG9uZW50IG5hbWUgc3BlY2lmaWVkJyk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIGxvYWRpbmdPcGVyYXRpb25JZCA9IGN1cnJlbnRMb2FkaW5nT3BlcmF0aW9uSWQgPSArK2NvbXBvbmVudExvYWRpbmdPcGVyYXRpb25VbmlxdWVJZDtcbiAgICAgICAgICAgICAgICBrby5jb21wb25lbnRzLmdldChjb21wb25lbnROYW1lLCBmdW5jdGlvbihjb21wb25lbnREZWZpbml0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHRoaXMgaXMgbm90IHRoZSBjdXJyZW50IGxvYWQgb3BlcmF0aW9uIGZvciB0aGlzIGVsZW1lbnQsIGlnbm9yZSBpdC5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRMb2FkaW5nT3BlcmF0aW9uSWQgIT09IGxvYWRpbmdPcGVyYXRpb25JZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gQ2xlYW4gdXAgcHJldmlvdXMgc3RhdGVcbiAgICAgICAgICAgICAgICAgICAgZGlzcG9zZUFzc29jaWF0ZWRDb21wb25lbnRWaWV3TW9kZWwoKTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBJbnN0YW50aWF0ZSBhbmQgYmluZCBuZXcgY29tcG9uZW50LiBJbXBsaWNpdGx5IHRoaXMgY2xlYW5zIGFueSBvbGQgRE9NIG5vZGVzLlxuICAgICAgICAgICAgICAgICAgICBpZiAoIWNvbXBvbmVudERlZmluaXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBjb21wb25lbnQgXFwnJyArIGNvbXBvbmVudE5hbWUgKyAnXFwnJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2xvbmVUZW1wbGF0ZUludG9FbGVtZW50KGNvbXBvbmVudE5hbWUsIGNvbXBvbmVudERlZmluaXRpb24sIGVsZW1lbnQpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgY29tcG9uZW50Vmlld01vZGVsID0gY3JlYXRlVmlld01vZGVsKGNvbXBvbmVudERlZmluaXRpb24sIGVsZW1lbnQsIG9yaWdpbmFsQ2hpbGROb2RlcywgY29tcG9uZW50UGFyYW1zKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkQmluZGluZ0NvbnRleHQgPSBiaW5kaW5nQ29udGV4dFsnY3JlYXRlQ2hpbGRDb250ZXh0J10oY29tcG9uZW50Vmlld01vZGVsLCAvKiBkYXRhSXRlbUFsaWFzICovIHVuZGVmaW5lZCwgZnVuY3Rpb24oY3R4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3R4WyckY29tcG9uZW50J10gPSBjb21wb25lbnRWaWV3TW9kZWw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3R4WyckY29tcG9uZW50VGVtcGxhdGVOb2RlcyddID0gb3JpZ2luYWxDaGlsZE5vZGVzO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRWaWV3TW9kZWwgPSBjb21wb25lbnRWaWV3TW9kZWw7XG4gICAgICAgICAgICAgICAgICAgIGtvLmFwcGx5QmluZGluZ3NUb0Rlc2NlbmRhbnRzKGNoaWxkQmluZGluZ0NvbnRleHQsIGVsZW1lbnQpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSwgbnVsbCwgeyBkaXNwb3NlV2hlbk5vZGVJc1JlbW92ZWQ6IGVsZW1lbnQgfSk7XG5cbiAgICAgICAgICAgIHJldHVybiB7ICdjb250cm9sc0Rlc2NlbmRhbnRCaW5kaW5ncyc6IHRydWUgfTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBrby52aXJ0dWFsRWxlbWVudHMuYWxsb3dlZEJpbmRpbmdzWydjb21wb25lbnQnXSA9IHRydWU7XG5cbiAgICBmdW5jdGlvbiBjbG9uZVRlbXBsYXRlSW50b0VsZW1lbnQoY29tcG9uZW50TmFtZSwgY29tcG9uZW50RGVmaW5pdGlvbiwgZWxlbWVudCkge1xuICAgICAgICB2YXIgdGVtcGxhdGUgPSBjb21wb25lbnREZWZpbml0aW9uWyd0ZW1wbGF0ZSddO1xuICAgICAgICBpZiAoIXRlbXBsYXRlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvbXBvbmVudCBcXCcnICsgY29tcG9uZW50TmFtZSArICdcXCcgaGFzIG5vIHRlbXBsYXRlJyk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgY2xvbmVkTm9kZXNBcnJheSA9IGtvLnV0aWxzLmNsb25lTm9kZXModGVtcGxhdGUpO1xuICAgICAgICBrby52aXJ0dWFsRWxlbWVudHMuc2V0RG9tTm9kZUNoaWxkcmVuKGVsZW1lbnQsIGNsb25lZE5vZGVzQXJyYXkpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNyZWF0ZVZpZXdNb2RlbChjb21wb25lbnREZWZpbml0aW9uLCBlbGVtZW50LCBvcmlnaW5hbENoaWxkTm9kZXMsIGNvbXBvbmVudFBhcmFtcykge1xuICAgICAgICB2YXIgY29tcG9uZW50Vmlld01vZGVsRmFjdG9yeSA9IGNvbXBvbmVudERlZmluaXRpb25bJ2NyZWF0ZVZpZXdNb2RlbCddO1xuICAgICAgICByZXR1cm4gY29tcG9uZW50Vmlld01vZGVsRmFjdG9yeVxuICAgICAgICAgICAgPyBjb21wb25lbnRWaWV3TW9kZWxGYWN0b3J5LmNhbGwoY29tcG9uZW50RGVmaW5pdGlvbiwgY29tcG9uZW50UGFyYW1zLCB7ICdlbGVtZW50JzogZWxlbWVudCwgJ3RlbXBsYXRlTm9kZXMnOiBvcmlnaW5hbENoaWxkTm9kZXMgfSlcbiAgICAgICAgICAgIDogY29tcG9uZW50UGFyYW1zOyAvLyBUZW1wbGF0ZS1vbmx5IGNvbXBvbmVudFxuICAgIH1cblxufSkoKTtcbnZhciBhdHRySHRtbFRvSmF2YXNjcmlwdE1hcCA9IHsgJ2NsYXNzJzogJ2NsYXNzTmFtZScsICdmb3InOiAnaHRtbEZvcicgfTtcbmtvLmJpbmRpbmdIYW5kbGVyc1snYXR0ciddID0ge1xuICAgICd1cGRhdGUnOiBmdW5jdGlvbihlbGVtZW50LCB2YWx1ZUFjY2Vzc29yLCBhbGxCaW5kaW5ncykge1xuICAgICAgICB2YXIgdmFsdWUgPSBrby51dGlscy51bndyYXBPYnNlcnZhYmxlKHZhbHVlQWNjZXNzb3IoKSkgfHwge307XG4gICAgICAgIGtvLnV0aWxzLm9iamVjdEZvckVhY2godmFsdWUsIGZ1bmN0aW9uKGF0dHJOYW1lLCBhdHRyVmFsdWUpIHtcbiAgICAgICAgICAgIGF0dHJWYWx1ZSA9IGtvLnV0aWxzLnVud3JhcE9ic2VydmFibGUoYXR0clZhbHVlKTtcblxuICAgICAgICAgICAgLy8gVG8gY292ZXIgY2FzZXMgbGlrZSBcImF0dHI6IHsgY2hlY2tlZDpzb21lUHJvcCB9XCIsIHdlIHdhbnQgdG8gcmVtb3ZlIHRoZSBhdHRyaWJ1dGUgZW50aXJlbHlcbiAgICAgICAgICAgIC8vIHdoZW4gc29tZVByb3AgaXMgYSBcIm5vIHZhbHVlXCItbGlrZSB2YWx1ZSAoc3RyaWN0bHkgbnVsbCwgZmFsc2UsIG9yIHVuZGVmaW5lZClcbiAgICAgICAgICAgIC8vIChiZWNhdXNlIHRoZSBhYnNlbmNlIG9mIHRoZSBcImNoZWNrZWRcIiBhdHRyIGlzIGhvdyB0byBtYXJrIGFuIGVsZW1lbnQgYXMgbm90IGNoZWNrZWQsIGV0Yy4pXG4gICAgICAgICAgICB2YXIgdG9SZW1vdmUgPSAoYXR0clZhbHVlID09PSBmYWxzZSkgfHwgKGF0dHJWYWx1ZSA9PT0gbnVsbCkgfHwgKGF0dHJWYWx1ZSA9PT0gdW5kZWZpbmVkKTtcbiAgICAgICAgICAgIGlmICh0b1JlbW92ZSlcbiAgICAgICAgICAgICAgICBlbGVtZW50LnJlbW92ZUF0dHJpYnV0ZShhdHRyTmFtZSk7XG5cbiAgICAgICAgICAgIC8vIEluIElFIDw9IDcgYW5kIElFOCBRdWlya3MgTW9kZSwgeW91IGhhdmUgdG8gdXNlIHRoZSBKYXZhc2NyaXB0IHByb3BlcnR5IG5hbWUgaW5zdGVhZCBvZiB0aGVcbiAgICAgICAgICAgIC8vIEhUTUwgYXR0cmlidXRlIG5hbWUgZm9yIGNlcnRhaW4gYXR0cmlidXRlcy4gSUU4IFN0YW5kYXJkcyBNb2RlIHN1cHBvcnRzIHRoZSBjb3JyZWN0IGJlaGF2aW9yLFxuICAgICAgICAgICAgLy8gYnV0IGluc3RlYWQgb2YgZmlndXJpbmcgb3V0IHRoZSBtb2RlLCB3ZSdsbCBqdXN0IHNldCB0aGUgYXR0cmlidXRlIHRocm91Z2ggdGhlIEphdmFzY3JpcHRcbiAgICAgICAgICAgIC8vIHByb3BlcnR5IGZvciBJRSA8PSA4LlxuICAgICAgICAgICAgaWYgKGtvLnV0aWxzLmllVmVyc2lvbiA8PSA4ICYmIGF0dHJOYW1lIGluIGF0dHJIdG1sVG9KYXZhc2NyaXB0TWFwKSB7XG4gICAgICAgICAgICAgICAgYXR0ck5hbWUgPSBhdHRySHRtbFRvSmF2YXNjcmlwdE1hcFthdHRyTmFtZV07XG4gICAgICAgICAgICAgICAgaWYgKHRvUmVtb3ZlKVxuICAgICAgICAgICAgICAgICAgICBlbGVtZW50LnJlbW92ZUF0dHJpYnV0ZShhdHRyTmFtZSk7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICBlbGVtZW50W2F0dHJOYW1lXSA9IGF0dHJWYWx1ZTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIXRvUmVtb3ZlKSB7XG4gICAgICAgICAgICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoYXR0ck5hbWUsIGF0dHJWYWx1ZS50b1N0cmluZygpKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gVHJlYXQgXCJuYW1lXCIgc3BlY2lhbGx5IC0gYWx0aG91Z2ggeW91IGNhbiB0aGluayBvZiBpdCBhcyBhbiBhdHRyaWJ1dGUsIGl0IGFsc28gbmVlZHNcbiAgICAgICAgICAgIC8vIHNwZWNpYWwgaGFuZGxpbmcgb24gb2xkZXIgdmVyc2lvbnMgb2YgSUUgKGh0dHBzOi8vZ2l0aHViLmNvbS9TdGV2ZVNhbmRlcnNvbi9rbm9ja291dC9wdWxsLzMzMylcbiAgICAgICAgICAgIC8vIERlbGliZXJhdGVseSBiZWluZyBjYXNlLXNlbnNpdGl2ZSBoZXJlIGJlY2F1c2UgWEhUTUwgd291bGQgcmVnYXJkIFwiTmFtZVwiIGFzIGEgZGlmZmVyZW50IHRoaW5nXG4gICAgICAgICAgICAvLyBlbnRpcmVseSwgYW5kIHRoZXJlJ3Mgbm8gc3Ryb25nIHJlYXNvbiB0byBhbGxvdyBmb3Igc3VjaCBjYXNpbmcgaW4gSFRNTC5cbiAgICAgICAgICAgIGlmIChhdHRyTmFtZSA9PT0gXCJuYW1lXCIpIHtcbiAgICAgICAgICAgICAgICBrby51dGlscy5zZXRFbGVtZW50TmFtZShlbGVtZW50LCB0b1JlbW92ZSA/IFwiXCIgOiBhdHRyVmFsdWUudG9TdHJpbmcoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbn07XG4oZnVuY3Rpb24oKSB7XG5cbmtvLmJpbmRpbmdIYW5kbGVyc1snY2hlY2tlZCddID0ge1xuICAgICdhZnRlcic6IFsndmFsdWUnLCAnYXR0ciddLFxuICAgICdpbml0JzogZnVuY3Rpb24gKGVsZW1lbnQsIHZhbHVlQWNjZXNzb3IsIGFsbEJpbmRpbmdzKSB7XG4gICAgICAgIHZhciBjaGVja2VkVmFsdWUgPSBrby5wdXJlQ29tcHV0ZWQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAvLyBUcmVhdCBcInZhbHVlXCIgbGlrZSBcImNoZWNrZWRWYWx1ZVwiIHdoZW4gaXQgaXMgaW5jbHVkZWQgd2l0aCBcImNoZWNrZWRcIiBiaW5kaW5nXG4gICAgICAgICAgICBpZiAoYWxsQmluZGluZ3NbJ2hhcyddKCdjaGVja2VkVmFsdWUnKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBrby51dGlscy51bndyYXBPYnNlcnZhYmxlKGFsbEJpbmRpbmdzLmdldCgnY2hlY2tlZFZhbHVlJykpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChhbGxCaW5kaW5nc1snaGFzJ10oJ3ZhbHVlJykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ga28udXRpbHMudW53cmFwT2JzZXJ2YWJsZShhbGxCaW5kaW5ncy5nZXQoJ3ZhbHVlJykpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gZWxlbWVudC52YWx1ZTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgZnVuY3Rpb24gdXBkYXRlTW9kZWwoKSB7XG4gICAgICAgICAgICAvLyBUaGlzIHVwZGF0ZXMgdGhlIG1vZGVsIHZhbHVlIGZyb20gdGhlIHZpZXcgdmFsdWUuXG4gICAgICAgICAgICAvLyBJdCBydW5zIGluIHJlc3BvbnNlIHRvIERPTSBldmVudHMgKGNsaWNrKSBhbmQgY2hhbmdlcyBpbiBjaGVja2VkVmFsdWUuXG4gICAgICAgICAgICB2YXIgaXNDaGVja2VkID0gZWxlbWVudC5jaGVja2VkLFxuICAgICAgICAgICAgICAgIGVsZW1WYWx1ZSA9IHVzZUNoZWNrZWRWYWx1ZSA/IGNoZWNrZWRWYWx1ZSgpIDogaXNDaGVja2VkO1xuXG4gICAgICAgICAgICAvLyBXaGVuIHdlJ3JlIGZpcnN0IHNldHRpbmcgdXAgdGhpcyBjb21wdXRlZCwgZG9uJ3QgY2hhbmdlIGFueSBtb2RlbCBzdGF0ZS5cbiAgICAgICAgICAgIGlmIChrby5jb21wdXRlZENvbnRleHQuaXNJbml0aWFsKCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFdlIGNhbiBpZ25vcmUgdW5jaGVja2VkIHJhZGlvIGJ1dHRvbnMsIGJlY2F1c2Ugc29tZSBvdGhlciByYWRpb1xuICAgICAgICAgICAgLy8gYnV0dG9uIHdpbGwgYmUgZ2V0dGluZyBjaGVja2VkLCBhbmQgdGhhdCBvbmUgY2FuIHRha2UgY2FyZSBvZiB1cGRhdGluZyBzdGF0ZS5cbiAgICAgICAgICAgIGlmIChpc1JhZGlvICYmICFpc0NoZWNrZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBtb2RlbFZhbHVlID0ga28uZGVwZW5kZW5jeURldGVjdGlvbi5pZ25vcmUodmFsdWVBY2Nlc3Nvcik7XG4gICAgICAgICAgICBpZiAodmFsdWVJc0FycmF5KSB7XG4gICAgICAgICAgICAgICAgdmFyIHdyaXRhYmxlVmFsdWUgPSByYXdWYWx1ZUlzTm9uQXJyYXlPYnNlcnZhYmxlID8gbW9kZWxWYWx1ZS5wZWVrKCkgOiBtb2RlbFZhbHVlO1xuICAgICAgICAgICAgICAgIGlmIChvbGRFbGVtVmFsdWUgIT09IGVsZW1WYWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBXaGVuIHdlJ3JlIHJlc3BvbmRpbmcgdG8gdGhlIGNoZWNrZWRWYWx1ZSBjaGFuZ2luZywgYW5kIHRoZSBlbGVtZW50IGlzXG4gICAgICAgICAgICAgICAgICAgIC8vIGN1cnJlbnRseSBjaGVja2VkLCByZXBsYWNlIHRoZSBvbGQgZWxlbSB2YWx1ZSB3aXRoIHRoZSBuZXcgZWxlbSB2YWx1ZVxuICAgICAgICAgICAgICAgICAgICAvLyBpbiB0aGUgbW9kZWwgYXJyYXkuXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0NoZWNrZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGtvLnV0aWxzLmFkZE9yUmVtb3ZlSXRlbSh3cml0YWJsZVZhbHVlLCBlbGVtVmFsdWUsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAga28udXRpbHMuYWRkT3JSZW1vdmVJdGVtKHdyaXRhYmxlVmFsdWUsIG9sZEVsZW1WYWx1ZSwgZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgb2xkRWxlbVZhbHVlID0gZWxlbVZhbHVlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFdoZW4gd2UncmUgcmVzcG9uZGluZyB0byB0aGUgdXNlciBoYXZpbmcgY2hlY2tlZC91bmNoZWNrZWQgYSBjaGVja2JveCxcbiAgICAgICAgICAgICAgICAgICAgLy8gYWRkL3JlbW92ZSB0aGUgZWxlbWVudCB2YWx1ZSB0byB0aGUgbW9kZWwgYXJyYXkuXG4gICAgICAgICAgICAgICAgICAgIGtvLnV0aWxzLmFkZE9yUmVtb3ZlSXRlbSh3cml0YWJsZVZhbHVlLCBlbGVtVmFsdWUsIGlzQ2hlY2tlZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChyYXdWYWx1ZUlzTm9uQXJyYXlPYnNlcnZhYmxlICYmIGtvLmlzV3JpdGVhYmxlT2JzZXJ2YWJsZShtb2RlbFZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICBtb2RlbFZhbHVlKHdyaXRhYmxlVmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAga28uZXhwcmVzc2lvblJld3JpdGluZy53cml0ZVZhbHVlVG9Qcm9wZXJ0eShtb2RlbFZhbHVlLCBhbGxCaW5kaW5ncywgJ2NoZWNrZWQnLCBlbGVtVmFsdWUsIHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIGZ1bmN0aW9uIHVwZGF0ZVZpZXcoKSB7XG4gICAgICAgICAgICAvLyBUaGlzIHVwZGF0ZXMgdGhlIHZpZXcgdmFsdWUgZnJvbSB0aGUgbW9kZWwgdmFsdWUuXG4gICAgICAgICAgICAvLyBJdCBydW5zIGluIHJlc3BvbnNlIHRvIGNoYW5nZXMgaW4gdGhlIGJvdW5kIChjaGVja2VkKSB2YWx1ZS5cbiAgICAgICAgICAgIHZhciBtb2RlbFZhbHVlID0ga28udXRpbHMudW53cmFwT2JzZXJ2YWJsZSh2YWx1ZUFjY2Vzc29yKCkpO1xuXG4gICAgICAgICAgICBpZiAodmFsdWVJc0FycmF5KSB7XG4gICAgICAgICAgICAgICAgLy8gV2hlbiBhIGNoZWNrYm94IGlzIGJvdW5kIHRvIGFuIGFycmF5LCBiZWluZyBjaGVja2VkIHJlcHJlc2VudHMgaXRzIHZhbHVlIGJlaW5nIHByZXNlbnQgaW4gdGhhdCBhcnJheVxuICAgICAgICAgICAgICAgIGVsZW1lbnQuY2hlY2tlZCA9IGtvLnV0aWxzLmFycmF5SW5kZXhPZihtb2RlbFZhbHVlLCBjaGVja2VkVmFsdWUoKSkgPj0gMDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaXNDaGVja2JveCkge1xuICAgICAgICAgICAgICAgIC8vIFdoZW4gYSBjaGVja2JveCBpcyBib3VuZCB0byBhbnkgb3RoZXIgdmFsdWUgKG5vdCBhbiBhcnJheSksIGJlaW5nIGNoZWNrZWQgcmVwcmVzZW50cyB0aGUgdmFsdWUgYmVpbmcgdHJ1ZWlzaFxuICAgICAgICAgICAgICAgIGVsZW1lbnQuY2hlY2tlZCA9IG1vZGVsVmFsdWU7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIEZvciByYWRpbyBidXR0b25zLCBiZWluZyBjaGVja2VkIG1lYW5zIHRoYXQgdGhlIHJhZGlvIGJ1dHRvbidzIHZhbHVlIGNvcnJlc3BvbmRzIHRvIHRoZSBtb2RlbCB2YWx1ZVxuICAgICAgICAgICAgICAgIGVsZW1lbnQuY2hlY2tlZCA9IChjaGVja2VkVmFsdWUoKSA9PT0gbW9kZWxWYWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIGlzQ2hlY2tib3ggPSBlbGVtZW50LnR5cGUgPT0gXCJjaGVja2JveFwiLFxuICAgICAgICAgICAgaXNSYWRpbyA9IGVsZW1lbnQudHlwZSA9PSBcInJhZGlvXCI7XG5cbiAgICAgICAgLy8gT25seSBiaW5kIHRvIGNoZWNrIGJveGVzIGFuZCByYWRpbyBidXR0b25zXG4gICAgICAgIGlmICghaXNDaGVja2JveCAmJiAhaXNSYWRpbykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHJhd1ZhbHVlID0gdmFsdWVBY2Nlc3NvcigpLFxuICAgICAgICAgICAgdmFsdWVJc0FycmF5ID0gaXNDaGVja2JveCAmJiAoa28udXRpbHMudW53cmFwT2JzZXJ2YWJsZShyYXdWYWx1ZSkgaW5zdGFuY2VvZiBBcnJheSksXG4gICAgICAgICAgICByYXdWYWx1ZUlzTm9uQXJyYXlPYnNlcnZhYmxlID0gISh2YWx1ZUlzQXJyYXkgJiYgcmF3VmFsdWUucHVzaCAmJiByYXdWYWx1ZS5zcGxpY2UpLFxuICAgICAgICAgICAgb2xkRWxlbVZhbHVlID0gdmFsdWVJc0FycmF5ID8gY2hlY2tlZFZhbHVlKCkgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICB1c2VDaGVja2VkVmFsdWUgPSBpc1JhZGlvIHx8IHZhbHVlSXNBcnJheTtcblxuICAgICAgICAvLyBJRSA2IHdvbid0IGFsbG93IHJhZGlvIGJ1dHRvbnMgdG8gYmUgc2VsZWN0ZWQgdW5sZXNzIHRoZXkgaGF2ZSBhIG5hbWVcbiAgICAgICAgaWYgKGlzUmFkaW8gJiYgIWVsZW1lbnQubmFtZSlcbiAgICAgICAgICAgIGtvLmJpbmRpbmdIYW5kbGVyc1sndW5pcXVlTmFtZSddWydpbml0J10oZWxlbWVudCwgZnVuY3Rpb24oKSB7IHJldHVybiB0cnVlIH0pO1xuXG4gICAgICAgIC8vIFNldCB1cCB0d28gY29tcHV0ZWRzIHRvIHVwZGF0ZSB0aGUgYmluZGluZzpcblxuICAgICAgICAvLyBUaGUgZmlyc3QgcmVzcG9uZHMgdG8gY2hhbmdlcyBpbiB0aGUgY2hlY2tlZFZhbHVlIHZhbHVlIGFuZCB0byBlbGVtZW50IGNsaWNrc1xuICAgICAgICBrby5jb21wdXRlZCh1cGRhdGVNb2RlbCwgbnVsbCwgeyBkaXNwb3NlV2hlbk5vZGVJc1JlbW92ZWQ6IGVsZW1lbnQgfSk7XG4gICAgICAgIGtvLnV0aWxzLnJlZ2lzdGVyRXZlbnRIYW5kbGVyKGVsZW1lbnQsIFwiY2xpY2tcIiwgdXBkYXRlTW9kZWwpO1xuXG4gICAgICAgIC8vIFRoZSBzZWNvbmQgcmVzcG9uZHMgdG8gY2hhbmdlcyBpbiB0aGUgbW9kZWwgdmFsdWUgKHRoZSBvbmUgYXNzb2NpYXRlZCB3aXRoIHRoZSBjaGVja2VkIGJpbmRpbmcpXG4gICAgICAgIGtvLmNvbXB1dGVkKHVwZGF0ZVZpZXcsIG51bGwsIHsgZGlzcG9zZVdoZW5Ob2RlSXNSZW1vdmVkOiBlbGVtZW50IH0pO1xuXG4gICAgICAgIHJhd1ZhbHVlID0gdW5kZWZpbmVkO1xuICAgIH1cbn07XG5rby5leHByZXNzaW9uUmV3cml0aW5nLnR3b1dheUJpbmRpbmdzWydjaGVja2VkJ10gPSB0cnVlO1xuXG5rby5iaW5kaW5nSGFuZGxlcnNbJ2NoZWNrZWRWYWx1ZSddID0ge1xuICAgICd1cGRhdGUnOiBmdW5jdGlvbiAoZWxlbWVudCwgdmFsdWVBY2Nlc3Nvcikge1xuICAgICAgICBlbGVtZW50LnZhbHVlID0ga28udXRpbHMudW53cmFwT2JzZXJ2YWJsZSh2YWx1ZUFjY2Vzc29yKCkpO1xuICAgIH1cbn07XG5cbn0pKCk7dmFyIGNsYXNzZXNXcml0dGVuQnlCaW5kaW5nS2V5ID0gJ19fa29fX2Nzc1ZhbHVlJztcbmtvLmJpbmRpbmdIYW5kbGVyc1snY3NzJ10gPSB7XG4gICAgJ3VwZGF0ZSc6IGZ1bmN0aW9uIChlbGVtZW50LCB2YWx1ZUFjY2Vzc29yKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IGtvLnV0aWxzLnVud3JhcE9ic2VydmFibGUodmFsdWVBY2Nlc3NvcigpKTtcbiAgICAgICAgaWYgKHZhbHVlICE9PSBudWxsICYmIHR5cGVvZiB2YWx1ZSA9PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICBrby51dGlscy5vYmplY3RGb3JFYWNoKHZhbHVlLCBmdW5jdGlvbihjbGFzc05hbWUsIHNob3VsZEhhdmVDbGFzcykge1xuICAgICAgICAgICAgICAgIHNob3VsZEhhdmVDbGFzcyA9IGtvLnV0aWxzLnVud3JhcE9ic2VydmFibGUoc2hvdWxkSGF2ZUNsYXNzKTtcbiAgICAgICAgICAgICAgICBrby51dGlscy50b2dnbGVEb21Ob2RlQ3NzQ2xhc3MoZWxlbWVudCwgY2xhc3NOYW1lLCBzaG91bGRIYXZlQ2xhc3MpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YWx1ZSA9IGtvLnV0aWxzLnN0cmluZ1RyaW0oU3RyaW5nKHZhbHVlIHx8ICcnKSk7IC8vIE1ha2Ugc3VyZSB3ZSBkb24ndCB0cnkgdG8gc3RvcmUgb3Igc2V0IGEgbm9uLXN0cmluZyB2YWx1ZVxuICAgICAgICAgICAga28udXRpbHMudG9nZ2xlRG9tTm9kZUNzc0NsYXNzKGVsZW1lbnQsIGVsZW1lbnRbY2xhc3Nlc1dyaXR0ZW5CeUJpbmRpbmdLZXldLCBmYWxzZSk7XG4gICAgICAgICAgICBlbGVtZW50W2NsYXNzZXNXcml0dGVuQnlCaW5kaW5nS2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAga28udXRpbHMudG9nZ2xlRG9tTm9kZUNzc0NsYXNzKGVsZW1lbnQsIHZhbHVlLCB0cnVlKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5rby5iaW5kaW5nSGFuZGxlcnNbJ2VuYWJsZSddID0ge1xuICAgICd1cGRhdGUnOiBmdW5jdGlvbiAoZWxlbWVudCwgdmFsdWVBY2Nlc3Nvcikge1xuICAgICAgICB2YXIgdmFsdWUgPSBrby51dGlscy51bndyYXBPYnNlcnZhYmxlKHZhbHVlQWNjZXNzb3IoKSk7XG4gICAgICAgIGlmICh2YWx1ZSAmJiBlbGVtZW50LmRpc2FibGVkKVxuICAgICAgICAgICAgZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoXCJkaXNhYmxlZFwiKTtcbiAgICAgICAgZWxzZSBpZiAoKCF2YWx1ZSkgJiYgKCFlbGVtZW50LmRpc2FibGVkKSlcbiAgICAgICAgICAgIGVsZW1lbnQuZGlzYWJsZWQgPSB0cnVlO1xuICAgIH1cbn07XG5cbmtvLmJpbmRpbmdIYW5kbGVyc1snZGlzYWJsZSddID0ge1xuICAgICd1cGRhdGUnOiBmdW5jdGlvbiAoZWxlbWVudCwgdmFsdWVBY2Nlc3Nvcikge1xuICAgICAgICBrby5iaW5kaW5nSGFuZGxlcnNbJ2VuYWJsZSddWyd1cGRhdGUnXShlbGVtZW50LCBmdW5jdGlvbigpIHsgcmV0dXJuICFrby51dGlscy51bndyYXBPYnNlcnZhYmxlKHZhbHVlQWNjZXNzb3IoKSkgfSk7XG4gICAgfVxufTtcbi8vIEZvciBjZXJ0YWluIGNvbW1vbiBldmVudHMgKGN1cnJlbnRseSBqdXN0ICdjbGljaycpLCBhbGxvdyBhIHNpbXBsaWZpZWQgZGF0YS1iaW5kaW5nIHN5bnRheFxuLy8gZS5nLiBjbGljazpoYW5kbGVyIGluc3RlYWQgb2YgdGhlIHVzdWFsIGZ1bGwtbGVuZ3RoIGV2ZW50OntjbGljazpoYW5kbGVyfVxuZnVuY3Rpb24gbWFrZUV2ZW50SGFuZGxlclNob3J0Y3V0KGV2ZW50TmFtZSkge1xuICAgIGtvLmJpbmRpbmdIYW5kbGVyc1tldmVudE5hbWVdID0ge1xuICAgICAgICAnaW5pdCc6IGZ1bmN0aW9uKGVsZW1lbnQsIHZhbHVlQWNjZXNzb3IsIGFsbEJpbmRpbmdzLCB2aWV3TW9kZWwsIGJpbmRpbmdDb250ZXh0KSB7XG4gICAgICAgICAgICB2YXIgbmV3VmFsdWVBY2Nlc3NvciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgICAgICAgICAgICAgcmVzdWx0W2V2ZW50TmFtZV0gPSB2YWx1ZUFjY2Vzc29yKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4ga28uYmluZGluZ0hhbmRsZXJzWydldmVudCddWydpbml0J10uY2FsbCh0aGlzLCBlbGVtZW50LCBuZXdWYWx1ZUFjY2Vzc29yLCBhbGxCaW5kaW5ncywgdmlld01vZGVsLCBiaW5kaW5nQ29udGV4dCk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmtvLmJpbmRpbmdIYW5kbGVyc1snZXZlbnQnXSA9IHtcbiAgICAnaW5pdCcgOiBmdW5jdGlvbiAoZWxlbWVudCwgdmFsdWVBY2Nlc3NvciwgYWxsQmluZGluZ3MsIHZpZXdNb2RlbCwgYmluZGluZ0NvbnRleHQpIHtcbiAgICAgICAgdmFyIGV2ZW50c1RvSGFuZGxlID0gdmFsdWVBY2Nlc3NvcigpIHx8IHt9O1xuICAgICAgICBrby51dGlscy5vYmplY3RGb3JFYWNoKGV2ZW50c1RvSGFuZGxlLCBmdW5jdGlvbihldmVudE5hbWUpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZXZlbnROYW1lID09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICBrby51dGlscy5yZWdpc3RlckV2ZW50SGFuZGxlcihlbGVtZW50LCBldmVudE5hbWUsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgaGFuZGxlclJldHVyblZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB2YXIgaGFuZGxlckZ1bmN0aW9uID0gdmFsdWVBY2Nlc3NvcigpW2V2ZW50TmFtZV07XG4gICAgICAgICAgICAgICAgICAgIGlmICghaGFuZGxlckZ1bmN0aW9uKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuXG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUYWtlIGFsbCB0aGUgZXZlbnQgYXJncywgYW5kIHByZWZpeCB3aXRoIHRoZSB2aWV3bW9kZWxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhcmdzRm9ySGFuZGxlciA9IGtvLnV0aWxzLm1ha2VBcnJheShhcmd1bWVudHMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmlld01vZGVsID0gYmluZGluZ0NvbnRleHRbJyRkYXRhJ107XG4gICAgICAgICAgICAgICAgICAgICAgICBhcmdzRm9ySGFuZGxlci51bnNoaWZ0KHZpZXdNb2RlbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBoYW5kbGVyUmV0dXJuVmFsdWUgPSBoYW5kbGVyRnVuY3Rpb24uYXBwbHkodmlld01vZGVsLCBhcmdzRm9ySGFuZGxlcik7XG4gICAgICAgICAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaGFuZGxlclJldHVyblZhbHVlICE9PSB0cnVlKSB7IC8vIE5vcm1hbGx5IHdlIHdhbnQgdG8gcHJldmVudCBkZWZhdWx0IGFjdGlvbi4gRGV2ZWxvcGVyIGNhbiBvdmVycmlkZSB0aGlzIGJlIGV4cGxpY2l0bHkgcmV0dXJuaW5nIHRydWUuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGV2ZW50LnByZXZlbnREZWZhdWx0KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnQucmV0dXJuVmFsdWUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHZhciBidWJibGUgPSBhbGxCaW5kaW5ncy5nZXQoZXZlbnROYW1lICsgJ0J1YmJsZScpICE9PSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFidWJibGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50LmNhbmNlbEJ1YmJsZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXZlbnQuc3RvcFByb3BhZ2F0aW9uKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbn07XG4vLyBcImZvcmVhY2g6IHNvbWVFeHByZXNzaW9uXCIgaXMgZXF1aXZhbGVudCB0byBcInRlbXBsYXRlOiB7IGZvcmVhY2g6IHNvbWVFeHByZXNzaW9uIH1cIlxuLy8gXCJmb3JlYWNoOiB7IGRhdGE6IHNvbWVFeHByZXNzaW9uLCBhZnRlckFkZDogbXlmbiB9XCIgaXMgZXF1aXZhbGVudCB0byBcInRlbXBsYXRlOiB7IGZvcmVhY2g6IHNvbWVFeHByZXNzaW9uLCBhZnRlckFkZDogbXlmbiB9XCJcbmtvLmJpbmRpbmdIYW5kbGVyc1snZm9yZWFjaCddID0ge1xuICAgIG1ha2VUZW1wbGF0ZVZhbHVlQWNjZXNzb3I6IGZ1bmN0aW9uKHZhbHVlQWNjZXNzb3IpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIG1vZGVsVmFsdWUgPSB2YWx1ZUFjY2Vzc29yKCksXG4gICAgICAgICAgICAgICAgdW53cmFwcGVkVmFsdWUgPSBrby51dGlscy5wZWVrT2JzZXJ2YWJsZShtb2RlbFZhbHVlKTsgICAgLy8gVW53cmFwIHdpdGhvdXQgc2V0dGluZyBhIGRlcGVuZGVuY3kgaGVyZVxuXG4gICAgICAgICAgICAvLyBJZiB1bndyYXBwZWRWYWx1ZSBpcyB0aGUgYXJyYXksIHBhc3MgaW4gdGhlIHdyYXBwZWQgdmFsdWUgb24gaXRzIG93blxuICAgICAgICAgICAgLy8gVGhlIHZhbHVlIHdpbGwgYmUgdW53cmFwcGVkIGFuZCB0cmFja2VkIHdpdGhpbiB0aGUgdGVtcGxhdGUgYmluZGluZ1xuICAgICAgICAgICAgLy8gKFNlZSBodHRwczovL2dpdGh1Yi5jb20vU3RldmVTYW5kZXJzb24va25vY2tvdXQvaXNzdWVzLzUyMylcbiAgICAgICAgICAgIGlmICgoIXVud3JhcHBlZFZhbHVlKSB8fCB0eXBlb2YgdW53cmFwcGVkVmFsdWUubGVuZ3RoID09IFwibnVtYmVyXCIpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgJ2ZvcmVhY2gnOiBtb2RlbFZhbHVlLCAndGVtcGxhdGVFbmdpbmUnOiBrby5uYXRpdmVUZW1wbGF0ZUVuZ2luZS5pbnN0YW5jZSB9O1xuXG4gICAgICAgICAgICAvLyBJZiB1bndyYXBwZWRWYWx1ZS5kYXRhIGlzIHRoZSBhcnJheSwgcHJlc2VydmUgYWxsIHJlbGV2YW50IG9wdGlvbnMgYW5kIHVud3JhcCBhZ2FpbiB2YWx1ZSBzbyB3ZSBnZXQgdXBkYXRlc1xuICAgICAgICAgICAga28udXRpbHMudW53cmFwT2JzZXJ2YWJsZShtb2RlbFZhbHVlKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgJ2ZvcmVhY2gnOiB1bndyYXBwZWRWYWx1ZVsnZGF0YSddLFxuICAgICAgICAgICAgICAgICdhcyc6IHVud3JhcHBlZFZhbHVlWydhcyddLFxuICAgICAgICAgICAgICAgICdpbmNsdWRlRGVzdHJveWVkJzogdW53cmFwcGVkVmFsdWVbJ2luY2x1ZGVEZXN0cm95ZWQnXSxcbiAgICAgICAgICAgICAgICAnYWZ0ZXJBZGQnOiB1bndyYXBwZWRWYWx1ZVsnYWZ0ZXJBZGQnXSxcbiAgICAgICAgICAgICAgICAnYmVmb3JlUmVtb3ZlJzogdW53cmFwcGVkVmFsdWVbJ2JlZm9yZVJlbW92ZSddLFxuICAgICAgICAgICAgICAgICdhZnRlclJlbmRlcic6IHVud3JhcHBlZFZhbHVlWydhZnRlclJlbmRlciddLFxuICAgICAgICAgICAgICAgICdiZWZvcmVNb3ZlJzogdW53cmFwcGVkVmFsdWVbJ2JlZm9yZU1vdmUnXSxcbiAgICAgICAgICAgICAgICAnYWZ0ZXJNb3ZlJzogdW53cmFwcGVkVmFsdWVbJ2FmdGVyTW92ZSddLFxuICAgICAgICAgICAgICAgICd0ZW1wbGF0ZUVuZ2luZSc6IGtvLm5hdGl2ZVRlbXBsYXRlRW5naW5lLmluc3RhbmNlXG4gICAgICAgICAgICB9O1xuICAgICAgICB9O1xuICAgIH0sXG4gICAgJ2luaXQnOiBmdW5jdGlvbihlbGVtZW50LCB2YWx1ZUFjY2Vzc29yLCBhbGxCaW5kaW5ncywgdmlld01vZGVsLCBiaW5kaW5nQ29udGV4dCkge1xuICAgICAgICByZXR1cm4ga28uYmluZGluZ0hhbmRsZXJzWyd0ZW1wbGF0ZSddWydpbml0J10oZWxlbWVudCwga28uYmluZGluZ0hhbmRsZXJzWydmb3JlYWNoJ10ubWFrZVRlbXBsYXRlVmFsdWVBY2Nlc3Nvcih2YWx1ZUFjY2Vzc29yKSk7XG4gICAgfSxcbiAgICAndXBkYXRlJzogZnVuY3Rpb24oZWxlbWVudCwgdmFsdWVBY2Nlc3NvciwgYWxsQmluZGluZ3MsIHZpZXdNb2RlbCwgYmluZGluZ0NvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIGtvLmJpbmRpbmdIYW5kbGVyc1sndGVtcGxhdGUnXVsndXBkYXRlJ10oZWxlbWVudCwga28uYmluZGluZ0hhbmRsZXJzWydmb3JlYWNoJ10ubWFrZVRlbXBsYXRlVmFsdWVBY2Nlc3Nvcih2YWx1ZUFjY2Vzc29yKSwgYWxsQmluZGluZ3MsIHZpZXdNb2RlbCwgYmluZGluZ0NvbnRleHQpO1xuICAgIH1cbn07XG5rby5leHByZXNzaW9uUmV3cml0aW5nLmJpbmRpbmdSZXdyaXRlVmFsaWRhdG9yc1snZm9yZWFjaCddID0gZmFsc2U7IC8vIENhbid0IHJld3JpdGUgY29udHJvbCBmbG93IGJpbmRpbmdzXG5rby52aXJ0dWFsRWxlbWVudHMuYWxsb3dlZEJpbmRpbmdzWydmb3JlYWNoJ10gPSB0cnVlO1xudmFyIGhhc2ZvY3VzVXBkYXRpbmdQcm9wZXJ0eSA9ICdfX2tvX2hhc2ZvY3VzVXBkYXRpbmcnO1xudmFyIGhhc2ZvY3VzTGFzdFZhbHVlID0gJ19fa29faGFzZm9jdXNMYXN0VmFsdWUnO1xua28uYmluZGluZ0hhbmRsZXJzWydoYXNmb2N1cyddID0ge1xuICAgICdpbml0JzogZnVuY3Rpb24oZWxlbWVudCwgdmFsdWVBY2Nlc3NvciwgYWxsQmluZGluZ3MpIHtcbiAgICAgICAgdmFyIGhhbmRsZUVsZW1lbnRGb2N1c0NoYW5nZSA9IGZ1bmN0aW9uKGlzRm9jdXNlZCkge1xuICAgICAgICAgICAgLy8gV2hlcmUgcG9zc2libGUsIGlnbm9yZSB3aGljaCBldmVudCB3YXMgcmFpc2VkIGFuZCBkZXRlcm1pbmUgZm9jdXMgc3RhdGUgdXNpbmcgYWN0aXZlRWxlbWVudCxcbiAgICAgICAgICAgIC8vIGFzIHRoaXMgYXZvaWRzIHBoYW50b20gZm9jdXMvYmx1ciBldmVudHMgcmFpc2VkIHdoZW4gY2hhbmdpbmcgdGFicyBpbiBtb2Rlcm4gYnJvd3NlcnMuXG4gICAgICAgICAgICAvLyBIb3dldmVyLCBub3QgYWxsIEtPLXRhcmdldGVkIGJyb3dzZXJzIChGaXJlZm94IDIpIHN1cHBvcnQgYWN0aXZlRWxlbWVudC4gRm9yIHRob3NlIGJyb3dzZXJzLFxuICAgICAgICAgICAgLy8gcHJldmVudCBhIGxvc3Mgb2YgZm9jdXMgd2hlbiBjaGFuZ2luZyB0YWJzL3dpbmRvd3MgYnkgc2V0dGluZyBhIGZsYWcgdGhhdCBwcmV2ZW50cyBoYXNmb2N1c1xuICAgICAgICAgICAgLy8gZnJvbSBjYWxsaW5nICdibHVyKCknIG9uIHRoZSBlbGVtZW50IHdoZW4gaXQgbG9zZXMgZm9jdXMuXG4gICAgICAgICAgICAvLyBEaXNjdXNzaW9uIGF0IGh0dHBzOi8vZ2l0aHViLmNvbS9TdGV2ZVNhbmRlcnNvbi9rbm9ja291dC9wdWxsLzM1MlxuICAgICAgICAgICAgZWxlbWVudFtoYXNmb2N1c1VwZGF0aW5nUHJvcGVydHldID0gdHJ1ZTtcbiAgICAgICAgICAgIHZhciBvd25lckRvYyA9IGVsZW1lbnQub3duZXJEb2N1bWVudDtcbiAgICAgICAgICAgIGlmIChcImFjdGl2ZUVsZW1lbnRcIiBpbiBvd25lckRvYykge1xuICAgICAgICAgICAgICAgIHZhciBhY3RpdmU7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgYWN0aXZlID0gb3duZXJEb2MuYWN0aXZlRWxlbWVudDtcbiAgICAgICAgICAgICAgICB9IGNhdGNoKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSUU5IHRocm93cyBpZiB5b3UgYWNjZXNzIGFjdGl2ZUVsZW1lbnQgZHVyaW5nIHBhZ2UgbG9hZCAoc2VlIGlzc3VlICM3MDMpXG4gICAgICAgICAgICAgICAgICAgIGFjdGl2ZSA9IG93bmVyRG9jLmJvZHk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlzRm9jdXNlZCA9IChhY3RpdmUgPT09IGVsZW1lbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIG1vZGVsVmFsdWUgPSB2YWx1ZUFjY2Vzc29yKCk7XG4gICAgICAgICAgICBrby5leHByZXNzaW9uUmV3cml0aW5nLndyaXRlVmFsdWVUb1Byb3BlcnR5KG1vZGVsVmFsdWUsIGFsbEJpbmRpbmdzLCAnaGFzZm9jdXMnLCBpc0ZvY3VzZWQsIHRydWUpO1xuXG4gICAgICAgICAgICAvL2NhY2hlIHRoZSBsYXRlc3QgdmFsdWUsIHNvIHdlIGNhbiBhdm9pZCB1bm5lY2Vzc2FyaWx5IGNhbGxpbmcgZm9jdXMvYmx1ciBpbiB0aGUgdXBkYXRlIGZ1bmN0aW9uXG4gICAgICAgICAgICBlbGVtZW50W2hhc2ZvY3VzTGFzdFZhbHVlXSA9IGlzRm9jdXNlZDtcbiAgICAgICAgICAgIGVsZW1lbnRbaGFzZm9jdXNVcGRhdGluZ1Byb3BlcnR5XSA9IGZhbHNlO1xuICAgICAgICB9O1xuICAgICAgICB2YXIgaGFuZGxlRWxlbWVudEZvY3VzSW4gPSBoYW5kbGVFbGVtZW50Rm9jdXNDaGFuZ2UuYmluZChudWxsLCB0cnVlKTtcbiAgICAgICAgdmFyIGhhbmRsZUVsZW1lbnRGb2N1c091dCA9IGhhbmRsZUVsZW1lbnRGb2N1c0NoYW5nZS5iaW5kKG51bGwsIGZhbHNlKTtcblxuICAgICAgICBrby51dGlscy5yZWdpc3RlckV2ZW50SGFuZGxlcihlbGVtZW50LCBcImZvY3VzXCIsIGhhbmRsZUVsZW1lbnRGb2N1c0luKTtcbiAgICAgICAga28udXRpbHMucmVnaXN0ZXJFdmVudEhhbmRsZXIoZWxlbWVudCwgXCJmb2N1c2luXCIsIGhhbmRsZUVsZW1lbnRGb2N1c0luKTsgLy8gRm9yIElFXG4gICAgICAgIGtvLnV0aWxzLnJlZ2lzdGVyRXZlbnRIYW5kbGVyKGVsZW1lbnQsIFwiYmx1clwiLCAgaGFuZGxlRWxlbWVudEZvY3VzT3V0KTtcbiAgICAgICAga28udXRpbHMucmVnaXN0ZXJFdmVudEhhbmRsZXIoZWxlbWVudCwgXCJmb2N1c291dFwiLCAgaGFuZGxlRWxlbWVudEZvY3VzT3V0KTsgLy8gRm9yIElFXG4gICAgfSxcbiAgICAndXBkYXRlJzogZnVuY3Rpb24oZWxlbWVudCwgdmFsdWVBY2Nlc3Nvcikge1xuICAgICAgICB2YXIgdmFsdWUgPSAhIWtvLnV0aWxzLnVud3JhcE9ic2VydmFibGUodmFsdWVBY2Nlc3NvcigpKTtcblxuICAgICAgICBpZiAoIWVsZW1lbnRbaGFzZm9jdXNVcGRhdGluZ1Byb3BlcnR5XSAmJiBlbGVtZW50W2hhc2ZvY3VzTGFzdFZhbHVlXSAhPT0gdmFsdWUpIHtcbiAgICAgICAgICAgIHZhbHVlID8gZWxlbWVudC5mb2N1cygpIDogZWxlbWVudC5ibHVyKCk7XG5cbiAgICAgICAgICAgIC8vIEluIElFLCB0aGUgYmx1ciBtZXRob2QgZG9lc24ndCBhbHdheXMgY2F1c2UgdGhlIGVsZW1lbnQgdG8gbG9zZSBmb2N1cyAoZm9yIGV4YW1wbGUsIGlmIHRoZSB3aW5kb3cgaXMgbm90IGluIGZvY3VzKS5cbiAgICAgICAgICAgIC8vIFNldHRpbmcgZm9jdXMgdG8gdGhlIGJvZHkgZWxlbWVudCBkb2VzIHNlZW0gdG8gYmUgcmVsaWFibGUgaW4gSUUsIGJ1dCBzaG91bGQgb25seSBiZSB1c2VkIGlmIHdlIGtub3cgdGhhdCB0aGUgY3VycmVudFxuICAgICAgICAgICAgLy8gZWxlbWVudCB3YXMgZm9jdXNlZCBhbHJlYWR5LlxuICAgICAgICAgICAgaWYgKCF2YWx1ZSAmJiBlbGVtZW50W2hhc2ZvY3VzTGFzdFZhbHVlXSkge1xuICAgICAgICAgICAgICAgIGVsZW1lbnQub3duZXJEb2N1bWVudC5ib2R5LmZvY3VzKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEZvciBJRSwgd2hpY2ggZG9lc24ndCByZWxpYWJseSBmaXJlIFwiZm9jdXNcIiBvciBcImJsdXJcIiBldmVudHMgc3luY2hyb25vdXNseVxuICAgICAgICAgICAga28uZGVwZW5kZW5jeURldGVjdGlvbi5pZ25vcmUoa28udXRpbHMudHJpZ2dlckV2ZW50LCBudWxsLCBbZWxlbWVudCwgdmFsdWUgPyBcImZvY3VzaW5cIiA6IFwiZm9jdXNvdXRcIl0pO1xuICAgICAgICB9XG4gICAgfVxufTtcbmtvLmV4cHJlc3Npb25SZXdyaXRpbmcudHdvV2F5QmluZGluZ3NbJ2hhc2ZvY3VzJ10gPSB0cnVlO1xuXG5rby5iaW5kaW5nSGFuZGxlcnNbJ2hhc0ZvY3VzJ10gPSBrby5iaW5kaW5nSGFuZGxlcnNbJ2hhc2ZvY3VzJ107IC8vIE1ha2UgXCJoYXNGb2N1c1wiIGFuIGFsaWFzXG5rby5leHByZXNzaW9uUmV3cml0aW5nLnR3b1dheUJpbmRpbmdzWydoYXNGb2N1cyddID0gdHJ1ZTtcbmtvLmJpbmRpbmdIYW5kbGVyc1snaHRtbCddID0ge1xuICAgICdpbml0JzogZnVuY3Rpb24oKSB7XG4gICAgICAgIC8vIFByZXZlbnQgYmluZGluZyBvbiB0aGUgZHluYW1pY2FsbHktaW5qZWN0ZWQgSFRNTCAoYXMgZGV2ZWxvcGVycyBhcmUgdW5saWtlbHkgdG8gZXhwZWN0IHRoYXQsIGFuZCBpdCBoYXMgc2VjdXJpdHkgaW1wbGljYXRpb25zKVxuICAgICAgICByZXR1cm4geyAnY29udHJvbHNEZXNjZW5kYW50QmluZGluZ3MnOiB0cnVlIH07XG4gICAgfSxcbiAgICAndXBkYXRlJzogZnVuY3Rpb24gKGVsZW1lbnQsIHZhbHVlQWNjZXNzb3IpIHtcbiAgICAgICAgLy8gc2V0SHRtbCB3aWxsIHVud3JhcCB0aGUgdmFsdWUgaWYgbmVlZGVkXG4gICAgICAgIGtvLnV0aWxzLnNldEh0bWwoZWxlbWVudCwgdmFsdWVBY2Nlc3NvcigpKTtcbiAgICB9XG59O1xuLy8gTWFrZXMgYSBiaW5kaW5nIGxpa2Ugd2l0aCBvciBpZlxuZnVuY3Rpb24gbWFrZVdpdGhJZkJpbmRpbmcoYmluZGluZ0tleSwgaXNXaXRoLCBpc05vdCwgbWFrZUNvbnRleHRDYWxsYmFjaykge1xuICAgIGtvLmJpbmRpbmdIYW5kbGVyc1tiaW5kaW5nS2V5XSA9IHtcbiAgICAgICAgJ2luaXQnOiBmdW5jdGlvbihlbGVtZW50LCB2YWx1ZUFjY2Vzc29yLCBhbGxCaW5kaW5ncywgdmlld01vZGVsLCBiaW5kaW5nQ29udGV4dCkge1xuICAgICAgICAgICAgdmFyIGRpZERpc3BsYXlPbkxhc3RVcGRhdGUsXG4gICAgICAgICAgICAgICAgc2F2ZWROb2RlcztcbiAgICAgICAgICAgIGtvLmNvbXB1dGVkKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHZhciByYXdWYWx1ZSA9IHZhbHVlQWNjZXNzb3IoKSxcbiAgICAgICAgICAgICAgICAgICAgZGF0YVZhbHVlID0ga28udXRpbHMudW53cmFwT2JzZXJ2YWJsZShyYXdWYWx1ZSksXG4gICAgICAgICAgICAgICAgICAgIHNob3VsZERpc3BsYXkgPSAhaXNOb3QgIT09ICFkYXRhVmFsdWUsIC8vIGVxdWl2YWxlbnQgdG8gaXNOb3QgPyAhZGF0YVZhbHVlIDogISFkYXRhVmFsdWVcbiAgICAgICAgICAgICAgICAgICAgaXNGaXJzdFJlbmRlciA9ICFzYXZlZE5vZGVzLFxuICAgICAgICAgICAgICAgICAgICBuZWVkc1JlZnJlc2ggPSBpc0ZpcnN0UmVuZGVyIHx8IGlzV2l0aCB8fCAoc2hvdWxkRGlzcGxheSAhPT0gZGlkRGlzcGxheU9uTGFzdFVwZGF0ZSk7XG5cbiAgICAgICAgICAgICAgICBpZiAobmVlZHNSZWZyZXNoKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFNhdmUgYSBjb3B5IG9mIHRoZSBpbm5lciBub2RlcyBvbiB0aGUgaW5pdGlhbCB1cGRhdGUsIGJ1dCBvbmx5IGlmIHdlIGhhdmUgZGVwZW5kZW5jaWVzLlxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNGaXJzdFJlbmRlciAmJiBrby5jb21wdXRlZENvbnRleHQuZ2V0RGVwZW5kZW5jaWVzQ291bnQoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2F2ZWROb2RlcyA9IGtvLnV0aWxzLmNsb25lTm9kZXMoa28udmlydHVhbEVsZW1lbnRzLmNoaWxkTm9kZXMoZWxlbWVudCksIHRydWUgLyogc2hvdWxkQ2xlYW5Ob2RlcyAqLyk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAoc2hvdWxkRGlzcGxheSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFpc0ZpcnN0UmVuZGVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAga28udmlydHVhbEVsZW1lbnRzLnNldERvbU5vZGVDaGlsZHJlbihlbGVtZW50LCBrby51dGlscy5jbG9uZU5vZGVzKHNhdmVkTm9kZXMpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGtvLmFwcGx5QmluZGluZ3NUb0Rlc2NlbmRhbnRzKG1ha2VDb250ZXh0Q2FsbGJhY2sgPyBtYWtlQ29udGV4dENhbGxiYWNrKGJpbmRpbmdDb250ZXh0LCByYXdWYWx1ZSkgOiBiaW5kaW5nQ29udGV4dCwgZWxlbWVudCk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBrby52aXJ0dWFsRWxlbWVudHMuZW1wdHlOb2RlKGVsZW1lbnQpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgZGlkRGlzcGxheU9uTGFzdFVwZGF0ZSA9IHNob3VsZERpc3BsYXk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgbnVsbCwgeyBkaXNwb3NlV2hlbk5vZGVJc1JlbW92ZWQ6IGVsZW1lbnQgfSk7XG4gICAgICAgICAgICByZXR1cm4geyAnY29udHJvbHNEZXNjZW5kYW50QmluZGluZ3MnOiB0cnVlIH07XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGtvLmV4cHJlc3Npb25SZXdyaXRpbmcuYmluZGluZ1Jld3JpdGVWYWxpZGF0b3JzW2JpbmRpbmdLZXldID0gZmFsc2U7IC8vIENhbid0IHJld3JpdGUgY29udHJvbCBmbG93IGJpbmRpbmdzXG4gICAga28udmlydHVhbEVsZW1lbnRzLmFsbG93ZWRCaW5kaW5nc1tiaW5kaW5nS2V5XSA9IHRydWU7XG59XG5cbi8vIENvbnN0cnVjdCB0aGUgYWN0dWFsIGJpbmRpbmcgaGFuZGxlcnNcbm1ha2VXaXRoSWZCaW5kaW5nKCdpZicpO1xubWFrZVdpdGhJZkJpbmRpbmcoJ2lmbm90JywgZmFsc2UgLyogaXNXaXRoICovLCB0cnVlIC8qIGlzTm90ICovKTtcbm1ha2VXaXRoSWZCaW5kaW5nKCd3aXRoJywgdHJ1ZSAvKiBpc1dpdGggKi8sIGZhbHNlIC8qIGlzTm90ICovLFxuICAgIGZ1bmN0aW9uKGJpbmRpbmdDb250ZXh0LCBkYXRhVmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGJpbmRpbmdDb250ZXh0LmNyZWF0ZVN0YXRpY0NoaWxkQ29udGV4dChkYXRhVmFsdWUpO1xuICAgIH1cbik7XG52YXIgY2FwdGlvblBsYWNlaG9sZGVyID0ge307XG5rby5iaW5kaW5nSGFuZGxlcnNbJ29wdGlvbnMnXSA9IHtcbiAgICAnaW5pdCc6IGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgICAgICAgaWYgKGtvLnV0aWxzLnRhZ05hbWVMb3dlcihlbGVtZW50KSAhPT0gXCJzZWxlY3RcIilcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIm9wdGlvbnMgYmluZGluZyBhcHBsaWVzIG9ubHkgdG8gU0VMRUNUIGVsZW1lbnRzXCIpO1xuXG4gICAgICAgIC8vIFJlbW92ZSBhbGwgZXhpc3RpbmcgPG9wdGlvbj5zLlxuICAgICAgICB3aGlsZSAoZWxlbWVudC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBlbGVtZW50LnJlbW92ZSgwKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEVuc3VyZXMgdGhhdCB0aGUgYmluZGluZyBwcm9jZXNzb3IgZG9lc24ndCB0cnkgdG8gYmluZCB0aGUgb3B0aW9uc1xuICAgICAgICByZXR1cm4geyAnY29udHJvbHNEZXNjZW5kYW50QmluZGluZ3MnOiB0cnVlIH07XG4gICAgfSxcbiAgICAndXBkYXRlJzogZnVuY3Rpb24gKGVsZW1lbnQsIHZhbHVlQWNjZXNzb3IsIGFsbEJpbmRpbmdzKSB7XG4gICAgICAgIGZ1bmN0aW9uIHNlbGVjdGVkT3B0aW9ucygpIHtcbiAgICAgICAgICAgIHJldHVybiBrby51dGlscy5hcnJheUZpbHRlcihlbGVtZW50Lm9wdGlvbnMsIGZ1bmN0aW9uIChub2RlKSB7IHJldHVybiBub2RlLnNlbGVjdGVkOyB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBzZWxlY3RXYXNQcmV2aW91c2x5RW1wdHkgPSBlbGVtZW50Lmxlbmd0aCA9PSAwLFxuICAgICAgICAgICAgbXVsdGlwbGUgPSBlbGVtZW50Lm11bHRpcGxlLFxuICAgICAgICAgICAgcHJldmlvdXNTY3JvbGxUb3AgPSAoIXNlbGVjdFdhc1ByZXZpb3VzbHlFbXB0eSAmJiBtdWx0aXBsZSkgPyBlbGVtZW50LnNjcm9sbFRvcCA6IG51bGwsXG4gICAgICAgICAgICB1bndyYXBwZWRBcnJheSA9IGtvLnV0aWxzLnVud3JhcE9ic2VydmFibGUodmFsdWVBY2Nlc3NvcigpKSxcbiAgICAgICAgICAgIHZhbHVlQWxsb3dVbnNldCA9IGFsbEJpbmRpbmdzLmdldCgndmFsdWVBbGxvd1Vuc2V0JykgJiYgYWxsQmluZGluZ3NbJ2hhcyddKCd2YWx1ZScpLFxuICAgICAgICAgICAgaW5jbHVkZURlc3Ryb3llZCA9IGFsbEJpbmRpbmdzLmdldCgnb3B0aW9uc0luY2x1ZGVEZXN0cm95ZWQnKSxcbiAgICAgICAgICAgIGFycmF5VG9Eb21Ob2RlQ2hpbGRyZW5PcHRpb25zID0ge30sXG4gICAgICAgICAgICBjYXB0aW9uVmFsdWUsXG4gICAgICAgICAgICBmaWx0ZXJlZEFycmF5LFxuICAgICAgICAgICAgcHJldmlvdXNTZWxlY3RlZFZhbHVlcyA9IFtdO1xuXG4gICAgICAgIGlmICghdmFsdWVBbGxvd1Vuc2V0KSB7XG4gICAgICAgICAgICBpZiAobXVsdGlwbGUpIHtcbiAgICAgICAgICAgICAgICBwcmV2aW91c1NlbGVjdGVkVmFsdWVzID0ga28udXRpbHMuYXJyYXlNYXAoc2VsZWN0ZWRPcHRpb25zKCksIGtvLnNlbGVjdEV4dGVuc2lvbnMucmVhZFZhbHVlKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZWxlbWVudC5zZWxlY3RlZEluZGV4ID49IDApIHtcbiAgICAgICAgICAgICAgICBwcmV2aW91c1NlbGVjdGVkVmFsdWVzLnB1c2goa28uc2VsZWN0RXh0ZW5zaW9ucy5yZWFkVmFsdWUoZWxlbWVudC5vcHRpb25zW2VsZW1lbnQuc2VsZWN0ZWRJbmRleF0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh1bndyYXBwZWRBcnJheSkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB1bndyYXBwZWRBcnJheS5sZW5ndGggPT0gXCJ1bmRlZmluZWRcIikgLy8gQ29lcmNlIHNpbmdsZSB2YWx1ZSBpbnRvIGFycmF5XG4gICAgICAgICAgICAgICAgdW53cmFwcGVkQXJyYXkgPSBbdW53cmFwcGVkQXJyYXldO1xuXG4gICAgICAgICAgICAvLyBGaWx0ZXIgb3V0IGFueSBlbnRyaWVzIG1hcmtlZCBhcyBkZXN0cm95ZWRcbiAgICAgICAgICAgIGZpbHRlcmVkQXJyYXkgPSBrby51dGlscy5hcnJheUZpbHRlcih1bndyYXBwZWRBcnJheSwgZnVuY3Rpb24oaXRlbSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpbmNsdWRlRGVzdHJveWVkIHx8IGl0ZW0gPT09IHVuZGVmaW5lZCB8fCBpdGVtID09PSBudWxsIHx8ICFrby51dGlscy51bndyYXBPYnNlcnZhYmxlKGl0ZW1bJ19kZXN0cm95J10pO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIC8vIElmIGNhcHRpb24gaXMgaW5jbHVkZWQsIGFkZCBpdCB0byB0aGUgYXJyYXlcbiAgICAgICAgICAgIGlmIChhbGxCaW5kaW5nc1snaGFzJ10oJ29wdGlvbnNDYXB0aW9uJykpIHtcbiAgICAgICAgICAgICAgICBjYXB0aW9uVmFsdWUgPSBrby51dGlscy51bndyYXBPYnNlcnZhYmxlKGFsbEJpbmRpbmdzLmdldCgnb3B0aW9uc0NhcHRpb24nKSk7XG4gICAgICAgICAgICAgICAgLy8gSWYgY2FwdGlvbiB2YWx1ZSBpcyBudWxsIG9yIHVuZGVmaW5lZCwgZG9uJ3Qgc2hvdyBhIGNhcHRpb25cbiAgICAgICAgICAgICAgICBpZiAoY2FwdGlvblZhbHVlICE9PSBudWxsICYmIGNhcHRpb25WYWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGZpbHRlcmVkQXJyYXkudW5zaGlmdChjYXB0aW9uUGxhY2Vob2xkZXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIElmIGEgZmFsc3kgdmFsdWUgaXMgcHJvdmlkZWQgKGUuZy4gbnVsbCksIHdlJ2xsIHNpbXBseSBlbXB0eSB0aGUgc2VsZWN0IGVsZW1lbnRcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGFwcGx5VG9PYmplY3Qob2JqZWN0LCBwcmVkaWNhdGUsIGRlZmF1bHRWYWx1ZSkge1xuICAgICAgICAgICAgdmFyIHByZWRpY2F0ZVR5cGUgPSB0eXBlb2YgcHJlZGljYXRlO1xuICAgICAgICAgICAgaWYgKHByZWRpY2F0ZVR5cGUgPT0gXCJmdW5jdGlvblwiKSAgICAvLyBHaXZlbiBhIGZ1bmN0aW9uOyBydW4gaXQgYWdhaW5zdCB0aGUgZGF0YSB2YWx1ZVxuICAgICAgICAgICAgICAgIHJldHVybiBwcmVkaWNhdGUob2JqZWN0KTtcbiAgICAgICAgICAgIGVsc2UgaWYgKHByZWRpY2F0ZVR5cGUgPT0gXCJzdHJpbmdcIikgLy8gR2l2ZW4gYSBzdHJpbmc7IHRyZWF0IGl0IGFzIGEgcHJvcGVydHkgbmFtZSBvbiB0aGUgZGF0YSB2YWx1ZVxuICAgICAgICAgICAgICAgIHJldHVybiBvYmplY3RbcHJlZGljYXRlXTtcbiAgICAgICAgICAgIGVsc2UgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEdpdmVuIG5vIG9wdGlvbnNUZXh0IGFyZzsgdXNlIHRoZSBkYXRhIHZhbHVlIGl0c2VsZlxuICAgICAgICAgICAgICAgIHJldHVybiBkZWZhdWx0VmFsdWU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUaGUgZm9sbG93aW5nIGZ1bmN0aW9ucyBjYW4gcnVuIGF0IHR3byBkaWZmZXJlbnQgdGltZXM6XG4gICAgICAgIC8vIFRoZSBmaXJzdCBpcyB3aGVuIHRoZSB3aG9sZSBhcnJheSBpcyBiZWluZyB1cGRhdGVkIGRpcmVjdGx5IGZyb20gdGhpcyBiaW5kaW5nIGhhbmRsZXIuXG4gICAgICAgIC8vIFRoZSBzZWNvbmQgaXMgd2hlbiBhbiBvYnNlcnZhYmxlIHZhbHVlIGZvciBhIHNwZWNpZmljIGFycmF5IGVudHJ5IGlzIHVwZGF0ZWQuXG4gICAgICAgIC8vIG9sZE9wdGlvbnMgd2lsbCBiZSBlbXB0eSBpbiB0aGUgZmlyc3QgY2FzZSwgYnV0IHdpbGwgYmUgZmlsbGVkIHdpdGggdGhlIHByZXZpb3VzbHkgZ2VuZXJhdGVkIG9wdGlvbiBpbiB0aGUgc2Vjb25kLlxuICAgICAgICB2YXIgaXRlbVVwZGF0ZSA9IGZhbHNlO1xuICAgICAgICBmdW5jdGlvbiBvcHRpb25Gb3JBcnJheUl0ZW0oYXJyYXlFbnRyeSwgaW5kZXgsIG9sZE9wdGlvbnMpIHtcbiAgICAgICAgICAgIGlmIChvbGRPcHRpb25zLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHByZXZpb3VzU2VsZWN0ZWRWYWx1ZXMgPSAhdmFsdWVBbGxvd1Vuc2V0ICYmIG9sZE9wdGlvbnNbMF0uc2VsZWN0ZWQgPyBbIGtvLnNlbGVjdEV4dGVuc2lvbnMucmVhZFZhbHVlKG9sZE9wdGlvbnNbMF0pIF0gOiBbXTtcbiAgICAgICAgICAgICAgICBpdGVtVXBkYXRlID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBvcHRpb24gPSBlbGVtZW50Lm93bmVyRG9jdW1lbnQuY3JlYXRlRWxlbWVudChcIm9wdGlvblwiKTtcbiAgICAgICAgICAgIGlmIChhcnJheUVudHJ5ID09PSBjYXB0aW9uUGxhY2Vob2xkZXIpIHtcbiAgICAgICAgICAgICAgICBrby51dGlscy5zZXRUZXh0Q29udGVudChvcHRpb24sIGFsbEJpbmRpbmdzLmdldCgnb3B0aW9uc0NhcHRpb24nKSk7XG4gICAgICAgICAgICAgICAga28uc2VsZWN0RXh0ZW5zaW9ucy53cml0ZVZhbHVlKG9wdGlvbiwgdW5kZWZpbmVkKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gQXBwbHkgYSB2YWx1ZSB0byB0aGUgb3B0aW9uIGVsZW1lbnRcbiAgICAgICAgICAgICAgICB2YXIgb3B0aW9uVmFsdWUgPSBhcHBseVRvT2JqZWN0KGFycmF5RW50cnksIGFsbEJpbmRpbmdzLmdldCgnb3B0aW9uc1ZhbHVlJyksIGFycmF5RW50cnkpO1xuICAgICAgICAgICAgICAgIGtvLnNlbGVjdEV4dGVuc2lvbnMud3JpdGVWYWx1ZShvcHRpb24sIGtvLnV0aWxzLnVud3JhcE9ic2VydmFibGUob3B0aW9uVmFsdWUpKTtcblxuICAgICAgICAgICAgICAgIC8vIEFwcGx5IHNvbWUgdGV4dCB0byB0aGUgb3B0aW9uIGVsZW1lbnRcbiAgICAgICAgICAgICAgICB2YXIgb3B0aW9uVGV4dCA9IGFwcGx5VG9PYmplY3QoYXJyYXlFbnRyeSwgYWxsQmluZGluZ3MuZ2V0KCdvcHRpb25zVGV4dCcpLCBvcHRpb25WYWx1ZSk7XG4gICAgICAgICAgICAgICAga28udXRpbHMuc2V0VGV4dENvbnRlbnQob3B0aW9uLCBvcHRpb25UZXh0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBbb3B0aW9uXTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEJ5IHVzaW5nIGEgYmVmb3JlUmVtb3ZlIGNhbGxiYWNrLCB3ZSBkZWxheSB0aGUgcmVtb3ZhbCB1bnRpbCBhZnRlciBuZXcgaXRlbXMgYXJlIGFkZGVkLiBUaGlzIGZpeGVzIGEgc2VsZWN0aW9uXG4gICAgICAgIC8vIHByb2JsZW0gaW4gSUU8PTggYW5kIEZpcmVmb3guIFNlZSBodHRwczovL2dpdGh1Yi5jb20va25vY2tvdXQva25vY2tvdXQvaXNzdWVzLzEyMDhcbiAgICAgICAgYXJyYXlUb0RvbU5vZGVDaGlsZHJlbk9wdGlvbnNbJ2JlZm9yZVJlbW92ZSddID1cbiAgICAgICAgICAgIGZ1bmN0aW9uIChvcHRpb24pIHtcbiAgICAgICAgICAgICAgICBlbGVtZW50LnJlbW92ZUNoaWxkKG9wdGlvbik7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgIGZ1bmN0aW9uIHNldFNlbGVjdGlvbkNhbGxiYWNrKGFycmF5RW50cnksIG5ld09wdGlvbnMpIHtcbiAgICAgICAgICAgIGlmIChpdGVtVXBkYXRlICYmIHZhbHVlQWxsb3dVbnNldCkge1xuICAgICAgICAgICAgICAgIC8vIFRoZSBtb2RlbCB2YWx1ZSBpcyBhdXRob3JpdGF0aXZlLCBzbyBtYWtlIHN1cmUgaXRzIHZhbHVlIGlzIHRoZSBvbmUgc2VsZWN0ZWRcbiAgICAgICAgICAgICAgICAvLyBUaGVyZSBpcyBubyBuZWVkIHRvIHVzZSBkZXBlbmRlbmN5RGV0ZWN0aW9uLmlnbm9yZSBzaW5jZSBzZXREb21Ob2RlQ2hpbGRyZW5Gcm9tQXJyYXlNYXBwaW5nIGRvZXMgc28gYWxyZWFkeS5cbiAgICAgICAgICAgICAgICBrby5zZWxlY3RFeHRlbnNpb25zLndyaXRlVmFsdWUoZWxlbWVudCwga28udXRpbHMudW53cmFwT2JzZXJ2YWJsZShhbGxCaW5kaW5ncy5nZXQoJ3ZhbHVlJykpLCB0cnVlIC8qIGFsbG93VW5zZXQgKi8pO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChwcmV2aW91c1NlbGVjdGVkVmFsdWVzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIC8vIElFNiBkb2Vzbid0IGxpa2UgdXMgdG8gYXNzaWduIHNlbGVjdGlvbiB0byBPUFRJT04gbm9kZXMgYmVmb3JlIHRoZXkncmUgYWRkZWQgdG8gdGhlIGRvY3VtZW50LlxuICAgICAgICAgICAgICAgIC8vIFRoYXQncyB3aHkgd2UgZmlyc3QgYWRkZWQgdGhlbSB3aXRob3V0IHNlbGVjdGlvbi4gTm93IGl0J3MgdGltZSB0byBzZXQgdGhlIHNlbGVjdGlvbi5cbiAgICAgICAgICAgICAgICB2YXIgaXNTZWxlY3RlZCA9IGtvLnV0aWxzLmFycmF5SW5kZXhPZihwcmV2aW91c1NlbGVjdGVkVmFsdWVzLCBrby5zZWxlY3RFeHRlbnNpb25zLnJlYWRWYWx1ZShuZXdPcHRpb25zWzBdKSkgPj0gMDtcbiAgICAgICAgICAgICAgICBrby51dGlscy5zZXRPcHRpb25Ob2RlU2VsZWN0aW9uU3RhdGUobmV3T3B0aW9uc1swXSwgaXNTZWxlY3RlZCk7XG5cbiAgICAgICAgICAgICAgICAvLyBJZiB0aGlzIG9wdGlvbiB3YXMgY2hhbmdlZCBmcm9tIGJlaW5nIHNlbGVjdGVkIGR1cmluZyBhIHNpbmdsZS1pdGVtIHVwZGF0ZSwgbm90aWZ5IHRoZSBjaGFuZ2VcbiAgICAgICAgICAgICAgICBpZiAoaXRlbVVwZGF0ZSAmJiAhaXNTZWxlY3RlZCkge1xuICAgICAgICAgICAgICAgICAgICBrby5kZXBlbmRlbmN5RGV0ZWN0aW9uLmlnbm9yZShrby51dGlscy50cmlnZ2VyRXZlbnQsIG51bGwsIFtlbGVtZW50LCBcImNoYW5nZVwiXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGNhbGxiYWNrID0gc2V0U2VsZWN0aW9uQ2FsbGJhY2s7XG4gICAgICAgIGlmIChhbGxCaW5kaW5nc1snaGFzJ10oJ29wdGlvbnNBZnRlclJlbmRlcicpICYmIHR5cGVvZiBhbGxCaW5kaW5ncy5nZXQoJ29wdGlvbnNBZnRlclJlbmRlcicpID09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgY2FsbGJhY2sgPSBmdW5jdGlvbihhcnJheUVudHJ5LCBuZXdPcHRpb25zKSB7XG4gICAgICAgICAgICAgICAgc2V0U2VsZWN0aW9uQ2FsbGJhY2soYXJyYXlFbnRyeSwgbmV3T3B0aW9ucyk7XG4gICAgICAgICAgICAgICAga28uZGVwZW5kZW5jeURldGVjdGlvbi5pZ25vcmUoYWxsQmluZGluZ3MuZ2V0KCdvcHRpb25zQWZ0ZXJSZW5kZXInKSwgbnVsbCwgW25ld09wdGlvbnNbMF0sIGFycmF5RW50cnkgIT09IGNhcHRpb25QbGFjZWhvbGRlciA/IGFycmF5RW50cnkgOiB1bmRlZmluZWRdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGtvLnV0aWxzLnNldERvbU5vZGVDaGlsZHJlbkZyb21BcnJheU1hcHBpbmcoZWxlbWVudCwgZmlsdGVyZWRBcnJheSwgb3B0aW9uRm9yQXJyYXlJdGVtLCBhcnJheVRvRG9tTm9kZUNoaWxkcmVuT3B0aW9ucywgY2FsbGJhY2spO1xuXG4gICAgICAgIGtvLmRlcGVuZGVuY3lEZXRlY3Rpb24uaWdub3JlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZUFsbG93VW5zZXQpIHtcbiAgICAgICAgICAgICAgICAvLyBUaGUgbW9kZWwgdmFsdWUgaXMgYXV0aG9yaXRhdGl2ZSwgc28gbWFrZSBzdXJlIGl0cyB2YWx1ZSBpcyB0aGUgb25lIHNlbGVjdGVkXG4gICAgICAgICAgICAgICAga28uc2VsZWN0RXh0ZW5zaW9ucy53cml0ZVZhbHVlKGVsZW1lbnQsIGtvLnV0aWxzLnVud3JhcE9ic2VydmFibGUoYWxsQmluZGluZ3MuZ2V0KCd2YWx1ZScpKSwgdHJ1ZSAvKiBhbGxvd1Vuc2V0ICovKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gRGV0ZXJtaW5lIGlmIHRoZSBzZWxlY3Rpb24gaGFzIGNoYW5nZWQgYXMgYSByZXN1bHQgb2YgdXBkYXRpbmcgdGhlIG9wdGlvbnMgbGlzdFxuICAgICAgICAgICAgICAgIHZhciBzZWxlY3Rpb25DaGFuZ2VkO1xuICAgICAgICAgICAgICAgIGlmIChtdWx0aXBsZSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBGb3IgYSBtdWx0aXBsZS1zZWxlY3QgYm94LCBjb21wYXJlIHRoZSBuZXcgc2VsZWN0aW9uIGNvdW50IHRvIHRoZSBwcmV2aW91cyBvbmVcbiAgICAgICAgICAgICAgICAgICAgLy8gQnV0IGlmIG5vdGhpbmcgd2FzIHNlbGVjdGVkIGJlZm9yZSwgdGhlIHNlbGVjdGlvbiBjYW4ndCBoYXZlIGNoYW5nZWRcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0aW9uQ2hhbmdlZCA9IHByZXZpb3VzU2VsZWN0ZWRWYWx1ZXMubGVuZ3RoICYmIHNlbGVjdGVkT3B0aW9ucygpLmxlbmd0aCA8IHByZXZpb3VzU2VsZWN0ZWRWYWx1ZXMubGVuZ3RoO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEZvciBhIHNpbmdsZS1zZWxlY3QgYm94LCBjb21wYXJlIHRoZSBjdXJyZW50IHZhbHVlIHRvIHRoZSBwcmV2aW91cyB2YWx1ZVxuICAgICAgICAgICAgICAgICAgICAvLyBCdXQgaWYgbm90aGluZyB3YXMgc2VsZWN0ZWQgYmVmb3JlIG9yIG5vdGhpbmcgaXMgc2VsZWN0ZWQgbm93LCBqdXN0IGxvb2sgZm9yIGEgY2hhbmdlIGluIHNlbGVjdGlvblxuICAgICAgICAgICAgICAgICAgICBzZWxlY3Rpb25DaGFuZ2VkID0gKHByZXZpb3VzU2VsZWN0ZWRWYWx1ZXMubGVuZ3RoICYmIGVsZW1lbnQuc2VsZWN0ZWRJbmRleCA+PSAwKVxuICAgICAgICAgICAgICAgICAgICAgICAgPyAoa28uc2VsZWN0RXh0ZW5zaW9ucy5yZWFkVmFsdWUoZWxlbWVudC5vcHRpb25zW2VsZW1lbnQuc2VsZWN0ZWRJbmRleF0pICE9PSBwcmV2aW91c1NlbGVjdGVkVmFsdWVzWzBdKVxuICAgICAgICAgICAgICAgICAgICAgICAgOiAocHJldmlvdXNTZWxlY3RlZFZhbHVlcy5sZW5ndGggfHwgZWxlbWVudC5zZWxlY3RlZEluZGV4ID49IDApO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIEVuc3VyZSBjb25zaXN0ZW5jeSBiZXR3ZWVuIG1vZGVsIHZhbHVlIGFuZCBzZWxlY3RlZCBvcHRpb24uXG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlIGRyb3Bkb3duIHdhcyBjaGFuZ2VkIHNvIHRoYXQgc2VsZWN0aW9uIGlzIG5vIGxvbmdlciB0aGUgc2FtZSxcbiAgICAgICAgICAgICAgICAvLyBub3RpZnkgdGhlIHZhbHVlIG9yIHNlbGVjdGVkT3B0aW9ucyBiaW5kaW5nLlxuICAgICAgICAgICAgICAgIGlmIChzZWxlY3Rpb25DaGFuZ2VkKSB7XG4gICAgICAgICAgICAgICAgICAgIGtvLnV0aWxzLnRyaWdnZXJFdmVudChlbGVtZW50LCBcImNoYW5nZVwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIFdvcmthcm91bmQgZm9yIElFIGJ1Z1xuICAgICAgICBrby51dGlscy5lbnN1cmVTZWxlY3RFbGVtZW50SXNSZW5kZXJlZENvcnJlY3RseShlbGVtZW50KTtcblxuICAgICAgICBpZiAocHJldmlvdXNTY3JvbGxUb3AgJiYgTWF0aC5hYnMocHJldmlvdXNTY3JvbGxUb3AgLSBlbGVtZW50LnNjcm9sbFRvcCkgPiAyMClcbiAgICAgICAgICAgIGVsZW1lbnQuc2Nyb2xsVG9wID0gcHJldmlvdXNTY3JvbGxUb3A7XG4gICAgfVxufTtcbmtvLmJpbmRpbmdIYW5kbGVyc1snb3B0aW9ucyddLm9wdGlvblZhbHVlRG9tRGF0YUtleSA9IGtvLnV0aWxzLmRvbURhdGEubmV4dEtleSgpO1xua28uYmluZGluZ0hhbmRsZXJzWydzZWxlY3RlZE9wdGlvbnMnXSA9IHtcbiAgICAnYWZ0ZXInOiBbJ29wdGlvbnMnLCAnZm9yZWFjaCddLFxuICAgICdpbml0JzogZnVuY3Rpb24gKGVsZW1lbnQsIHZhbHVlQWNjZXNzb3IsIGFsbEJpbmRpbmdzKSB7XG4gICAgICAgIGtvLnV0aWxzLnJlZ2lzdGVyRXZlbnRIYW5kbGVyKGVsZW1lbnQsIFwiY2hhbmdlXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IHZhbHVlQWNjZXNzb3IoKSwgdmFsdWVUb1dyaXRlID0gW107XG4gICAgICAgICAgICBrby51dGlscy5hcnJheUZvckVhY2goZWxlbWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZShcIm9wdGlvblwiKSwgZnVuY3Rpb24obm9kZSkge1xuICAgICAgICAgICAgICAgIGlmIChub2RlLnNlbGVjdGVkKVxuICAgICAgICAgICAgICAgICAgICB2YWx1ZVRvV3JpdGUucHVzaChrby5zZWxlY3RFeHRlbnNpb25zLnJlYWRWYWx1ZShub2RlKSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGtvLmV4cHJlc3Npb25SZXdyaXRpbmcud3JpdGVWYWx1ZVRvUHJvcGVydHkodmFsdWUsIGFsbEJpbmRpbmdzLCAnc2VsZWN0ZWRPcHRpb25zJywgdmFsdWVUb1dyaXRlKTtcbiAgICAgICAgfSk7XG4gICAgfSxcbiAgICAndXBkYXRlJzogZnVuY3Rpb24gKGVsZW1lbnQsIHZhbHVlQWNjZXNzb3IpIHtcbiAgICAgICAgaWYgKGtvLnV0aWxzLnRhZ05hbWVMb3dlcihlbGVtZW50KSAhPSBcInNlbGVjdFwiKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwidmFsdWVzIGJpbmRpbmcgYXBwbGllcyBvbmx5IHRvIFNFTEVDVCBlbGVtZW50c1wiKTtcblxuICAgICAgICB2YXIgbmV3VmFsdWUgPSBrby51dGlscy51bndyYXBPYnNlcnZhYmxlKHZhbHVlQWNjZXNzb3IoKSksXG4gICAgICAgICAgICBwcmV2aW91c1Njcm9sbFRvcCA9IGVsZW1lbnQuc2Nyb2xsVG9wO1xuXG4gICAgICAgIGlmIChuZXdWYWx1ZSAmJiB0eXBlb2YgbmV3VmFsdWUubGVuZ3RoID09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgIGtvLnV0aWxzLmFycmF5Rm9yRWFjaChlbGVtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKFwib3B0aW9uXCIpLCBmdW5jdGlvbihub2RlKSB7XG4gICAgICAgICAgICAgICAgdmFyIGlzU2VsZWN0ZWQgPSBrby51dGlscy5hcnJheUluZGV4T2YobmV3VmFsdWUsIGtvLnNlbGVjdEV4dGVuc2lvbnMucmVhZFZhbHVlKG5vZGUpKSA+PSAwO1xuICAgICAgICAgICAgICAgIGlmIChub2RlLnNlbGVjdGVkICE9IGlzU2VsZWN0ZWQpIHsgICAgICAvLyBUaGlzIGNoZWNrIHByZXZlbnRzIGZsYXNoaW5nIG9mIHRoZSBzZWxlY3QgZWxlbWVudCBpbiBJRVxuICAgICAgICAgICAgICAgICAgICBrby51dGlscy5zZXRPcHRpb25Ob2RlU2VsZWN0aW9uU3RhdGUobm9kZSwgaXNTZWxlY3RlZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBlbGVtZW50LnNjcm9sbFRvcCA9IHByZXZpb3VzU2Nyb2xsVG9wO1xuICAgIH1cbn07XG5rby5leHByZXNzaW9uUmV3cml0aW5nLnR3b1dheUJpbmRpbmdzWydzZWxlY3RlZE9wdGlvbnMnXSA9IHRydWU7XG5rby5iaW5kaW5nSGFuZGxlcnNbJ3N0eWxlJ10gPSB7XG4gICAgJ3VwZGF0ZSc6IGZ1bmN0aW9uIChlbGVtZW50LCB2YWx1ZUFjY2Vzc29yKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IGtvLnV0aWxzLnVud3JhcE9ic2VydmFibGUodmFsdWVBY2Nlc3NvcigpIHx8IHt9KTtcbiAgICAgICAga28udXRpbHMub2JqZWN0Rm9yRWFjaCh2YWx1ZSwgZnVuY3Rpb24oc3R5bGVOYW1lLCBzdHlsZVZhbHVlKSB7XG4gICAgICAgICAgICBzdHlsZVZhbHVlID0ga28udXRpbHMudW53cmFwT2JzZXJ2YWJsZShzdHlsZVZhbHVlKTtcblxuICAgICAgICAgICAgaWYgKHN0eWxlVmFsdWUgPT09IG51bGwgfHwgc3R5bGVWYWx1ZSA9PT0gdW5kZWZpbmVkIHx8IHN0eWxlVmFsdWUgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgLy8gRW1wdHkgc3RyaW5nIHJlbW92ZXMgdGhlIHZhbHVlLCB3aGVyZWFzIG51bGwvdW5kZWZpbmVkIGhhdmUgbm8gZWZmZWN0XG4gICAgICAgICAgICAgICAgc3R5bGVWYWx1ZSA9IFwiXCI7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGVsZW1lbnQuc3R5bGVbc3R5bGVOYW1lXSA9IHN0eWxlVmFsdWU7XG4gICAgICAgIH0pO1xuICAgIH1cbn07XG5rby5iaW5kaW5nSGFuZGxlcnNbJ3N1Ym1pdCddID0ge1xuICAgICdpbml0JzogZnVuY3Rpb24gKGVsZW1lbnQsIHZhbHVlQWNjZXNzb3IsIGFsbEJpbmRpbmdzLCB2aWV3TW9kZWwsIGJpbmRpbmdDb250ZXh0KSB7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWVBY2Nlc3NvcigpICE9IFwiZnVuY3Rpb25cIilcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoZSB2YWx1ZSBmb3IgYSBzdWJtaXQgYmluZGluZyBtdXN0IGJlIGEgZnVuY3Rpb25cIik7XG4gICAgICAgIGtvLnV0aWxzLnJlZ2lzdGVyRXZlbnRIYW5kbGVyKGVsZW1lbnQsIFwic3VibWl0XCIsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgdmFyIGhhbmRsZXJSZXR1cm5WYWx1ZTtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IHZhbHVlQWNjZXNzb3IoKTtcbiAgICAgICAgICAgIHRyeSB7IGhhbmRsZXJSZXR1cm5WYWx1ZSA9IHZhbHVlLmNhbGwoYmluZGluZ0NvbnRleHRbJyRkYXRhJ10sIGVsZW1lbnQpOyB9XG4gICAgICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICBpZiAoaGFuZGxlclJldHVyblZhbHVlICE9PSB0cnVlKSB7IC8vIE5vcm1hbGx5IHdlIHdhbnQgdG8gcHJldmVudCBkZWZhdWx0IGFjdGlvbi4gRGV2ZWxvcGVyIGNhbiBvdmVycmlkZSB0aGlzIGJlIGV4cGxpY2l0bHkgcmV0dXJuaW5nIHRydWUuXG4gICAgICAgICAgICAgICAgICAgIGlmIChldmVudC5wcmV2ZW50RGVmYXVsdClcbiAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50LnJldHVyblZhbHVlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG59O1xua28uYmluZGluZ0hhbmRsZXJzWyd0ZXh0J10gPSB7XG4gICAgJ2luaXQnOiBmdW5jdGlvbigpIHtcbiAgICAgICAgLy8gUHJldmVudCBiaW5kaW5nIG9uIHRoZSBkeW5hbWljYWxseS1pbmplY3RlZCB0ZXh0IG5vZGUgKGFzIGRldmVsb3BlcnMgYXJlIHVubGlrZWx5IHRvIGV4cGVjdCB0aGF0LCBhbmQgaXQgaGFzIHNlY3VyaXR5IGltcGxpY2F0aW9ucykuXG4gICAgICAgIC8vIEl0IHNob3VsZCBhbHNvIG1ha2UgdGhpbmdzIGZhc3RlciwgYXMgd2Ugbm8gbG9uZ2VyIGhhdmUgdG8gY29uc2lkZXIgd2hldGhlciB0aGUgdGV4dCBub2RlIG1pZ2h0IGJlIGJpbmRhYmxlLlxuICAgICAgICByZXR1cm4geyAnY29udHJvbHNEZXNjZW5kYW50QmluZGluZ3MnOiB0cnVlIH07XG4gICAgfSxcbiAgICAndXBkYXRlJzogZnVuY3Rpb24gKGVsZW1lbnQsIHZhbHVlQWNjZXNzb3IpIHtcbiAgICAgICAga28udXRpbHMuc2V0VGV4dENvbnRlbnQoZWxlbWVudCwgdmFsdWVBY2Nlc3NvcigpKTtcbiAgICB9XG59O1xua28udmlydHVhbEVsZW1lbnRzLmFsbG93ZWRCaW5kaW5nc1sndGV4dCddID0gdHJ1ZTtcbihmdW5jdGlvbiAoKSB7XG5cbmlmICh3aW5kb3cgJiYgd2luZG93Lm5hdmlnYXRvcikge1xuICAgIHZhciBwYXJzZVZlcnNpb24gPSBmdW5jdGlvbiAobWF0Y2hlcykge1xuICAgICAgICBpZiAobWF0Y2hlcykge1xuICAgICAgICAgICAgcmV0dXJuIHBhcnNlRmxvYXQobWF0Y2hlc1sxXSk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLy8gRGV0ZWN0IHZhcmlvdXMgYnJvd3NlciB2ZXJzaW9ucyBiZWNhdXNlIHNvbWUgb2xkIHZlcnNpb25zIGRvbid0IGZ1bGx5IHN1cHBvcnQgdGhlICdpbnB1dCcgZXZlbnRcbiAgICB2YXIgb3BlcmFWZXJzaW9uID0gd2luZG93Lm9wZXJhICYmIHdpbmRvdy5vcGVyYS52ZXJzaW9uICYmIHBhcnNlSW50KHdpbmRvdy5vcGVyYS52ZXJzaW9uKCkpLFxuICAgICAgICB1c2VyQWdlbnQgPSB3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudCxcbiAgICAgICAgc2FmYXJpVmVyc2lvbiA9IHBhcnNlVmVyc2lvbih1c2VyQWdlbnQubWF0Y2goL14oPzooPyFjaHJvbWUpLikqdmVyc2lvblxcLyhbXiBdKikgc2FmYXJpL2kpKSxcbiAgICAgICAgZmlyZWZveFZlcnNpb24gPSBwYXJzZVZlcnNpb24odXNlckFnZW50Lm1hdGNoKC9GaXJlZm94XFwvKFteIF0qKS8pKTtcbn1cblxuLy8gSUUgOCBhbmQgOSBoYXZlIGJ1Z3MgdGhhdCBwcmV2ZW50IHRoZSBub3JtYWwgZXZlbnRzIGZyb20gZmlyaW5nIHdoZW4gdGhlIHZhbHVlIGNoYW5nZXMuXG4vLyBCdXQgaXQgZG9lcyBmaXJlIHRoZSAnc2VsZWN0aW9uY2hhbmdlJyBldmVudCBvbiBtYW55IG9mIHRob3NlLCBwcmVzdW1hYmx5IGJlY2F1c2UgdGhlXG4vLyBjdXJzb3IgaXMgbW92aW5nIGFuZCB0aGF0IGNvdW50cyBhcyB0aGUgc2VsZWN0aW9uIGNoYW5naW5nLiBUaGUgJ3NlbGVjdGlvbmNoYW5nZScgZXZlbnQgaXNcbi8vIGZpcmVkIGF0IHRoZSBkb2N1bWVudCBsZXZlbCBvbmx5IGFuZCBkb2Vzbid0IGRpcmVjdGx5IGluZGljYXRlIHdoaWNoIGVsZW1lbnQgY2hhbmdlZC4gV2Vcbi8vIHNldCB1cCBqdXN0IG9uZSBldmVudCBoYW5kbGVyIGZvciB0aGUgZG9jdW1lbnQgYW5kIHVzZSAnYWN0aXZlRWxlbWVudCcgdG8gZGV0ZXJtaW5lIHdoaWNoXG4vLyBlbGVtZW50IHdhcyBjaGFuZ2VkLlxuaWYgKGtvLnV0aWxzLmllVmVyc2lvbiA8IDEwKSB7XG4gICAgdmFyIHNlbGVjdGlvbkNoYW5nZVJlZ2lzdGVyZWROYW1lID0ga28udXRpbHMuZG9tRGF0YS5uZXh0S2V5KCksXG4gICAgICAgIHNlbGVjdGlvbkNoYW5nZUhhbmRsZXJOYW1lID0ga28udXRpbHMuZG9tRGF0YS5uZXh0S2V5KCk7XG4gICAgdmFyIHNlbGVjdGlvbkNoYW5nZUhhbmRsZXIgPSBmdW5jdGlvbihldmVudCkge1xuICAgICAgICB2YXIgdGFyZ2V0ID0gdGhpcy5hY3RpdmVFbGVtZW50LFxuICAgICAgICAgICAgaGFuZGxlciA9IHRhcmdldCAmJiBrby51dGlscy5kb21EYXRhLmdldCh0YXJnZXQsIHNlbGVjdGlvbkNoYW5nZUhhbmRsZXJOYW1lKTtcbiAgICAgICAgaWYgKGhhbmRsZXIpIHtcbiAgICAgICAgICAgIGhhbmRsZXIoZXZlbnQpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICB2YXIgcmVnaXN0ZXJGb3JTZWxlY3Rpb25DaGFuZ2VFdmVudCA9IGZ1bmN0aW9uIChlbGVtZW50LCBoYW5kbGVyKSB7XG4gICAgICAgIHZhciBvd25lckRvYyA9IGVsZW1lbnQub3duZXJEb2N1bWVudDtcbiAgICAgICAgaWYgKCFrby51dGlscy5kb21EYXRhLmdldChvd25lckRvYywgc2VsZWN0aW9uQ2hhbmdlUmVnaXN0ZXJlZE5hbWUpKSB7XG4gICAgICAgICAgICBrby51dGlscy5kb21EYXRhLnNldChvd25lckRvYywgc2VsZWN0aW9uQ2hhbmdlUmVnaXN0ZXJlZE5hbWUsIHRydWUpO1xuICAgICAgICAgICAga28udXRpbHMucmVnaXN0ZXJFdmVudEhhbmRsZXIob3duZXJEb2MsICdzZWxlY3Rpb25jaGFuZ2UnLCBzZWxlY3Rpb25DaGFuZ2VIYW5kbGVyKTtcbiAgICAgICAgfVxuICAgICAgICBrby51dGlscy5kb21EYXRhLnNldChlbGVtZW50LCBzZWxlY3Rpb25DaGFuZ2VIYW5kbGVyTmFtZSwgaGFuZGxlcik7XG4gICAgfTtcbn1cblxua28uYmluZGluZ0hhbmRsZXJzWyd0ZXh0SW5wdXQnXSA9IHtcbiAgICAnaW5pdCc6IGZ1bmN0aW9uIChlbGVtZW50LCB2YWx1ZUFjY2Vzc29yLCBhbGxCaW5kaW5ncykge1xuXG4gICAgICAgIHZhciBwcmV2aW91c0VsZW1lbnRWYWx1ZSA9IGVsZW1lbnQudmFsdWUsXG4gICAgICAgICAgICB0aW1lb3V0SGFuZGxlLFxuICAgICAgICAgICAgZWxlbWVudFZhbHVlQmVmb3JlRXZlbnQ7XG5cbiAgICAgICAgdmFyIHVwZGF0ZU1vZGVsID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dEhhbmRsZSk7XG4gICAgICAgICAgICBlbGVtZW50VmFsdWVCZWZvcmVFdmVudCA9IHRpbWVvdXRIYW5kbGUgPSB1bmRlZmluZWQ7XG5cbiAgICAgICAgICAgIHZhciBlbGVtZW50VmFsdWUgPSBlbGVtZW50LnZhbHVlO1xuICAgICAgICAgICAgaWYgKHByZXZpb3VzRWxlbWVudFZhbHVlICE9PSBlbGVtZW50VmFsdWUpIHtcbiAgICAgICAgICAgICAgICAvLyBQcm92aWRlIGEgd2F5IGZvciB0ZXN0cyB0byBrbm93IGV4YWN0bHkgd2hpY2ggZXZlbnQgd2FzIHByb2Nlc3NlZFxuICAgICAgICAgICAgICAgIGlmIChERUJVRyAmJiBldmVudCkgZWxlbWVudFsnX2tvX3RleHRJbnB1dFByb2Nlc3NlZEV2ZW50J10gPSBldmVudC50eXBlO1xuICAgICAgICAgICAgICAgIHByZXZpb3VzRWxlbWVudFZhbHVlID0gZWxlbWVudFZhbHVlO1xuICAgICAgICAgICAgICAgIGtvLmV4cHJlc3Npb25SZXdyaXRpbmcud3JpdGVWYWx1ZVRvUHJvcGVydHkodmFsdWVBY2Nlc3NvcigpLCBhbGxCaW5kaW5ncywgJ3RleHRJbnB1dCcsIGVsZW1lbnRWYWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIGRlZmVyVXBkYXRlTW9kZWwgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgIGlmICghdGltZW91dEhhbmRsZSkge1xuICAgICAgICAgICAgICAgIC8vIFRoZSBlbGVtZW50VmFsdWVCZWZvcmVFdmVudCB2YXJpYWJsZSBpcyBzZXQgKm9ubHkqIGR1cmluZyB0aGUgYnJpZWYgZ2FwIGJldHdlZW4gYW5cbiAgICAgICAgICAgICAgICAvLyBldmVudCBmaXJpbmcgYW5kIHRoZSB1cGRhdGVNb2RlbCBmdW5jdGlvbiBydW5uaW5nLiBUaGlzIGFsbG93cyB1cyB0byBpZ25vcmUgbW9kZWxcbiAgICAgICAgICAgICAgICAvLyB1cGRhdGVzIHRoYXQgYXJlIGZyb20gdGhlIHByZXZpb3VzIHN0YXRlIG9mIHRoZSBlbGVtZW50LCB1c3VhbGx5IGR1ZSB0byB0ZWNobmlxdWVzXG4gICAgICAgICAgICAgICAgLy8gc3VjaCBhcyByYXRlTGltaXQuIFN1Y2ggdXBkYXRlcywgaWYgbm90IGlnbm9yZWQsIGNhbiBjYXVzZSBrZXlzdHJva2VzIHRvIGJlIGxvc3QuXG4gICAgICAgICAgICAgICAgZWxlbWVudFZhbHVlQmVmb3JlRXZlbnQgPSBlbGVtZW50LnZhbHVlO1xuICAgICAgICAgICAgICAgIHZhciBoYW5kbGVyID0gREVCVUcgPyB1cGRhdGVNb2RlbC5iaW5kKGVsZW1lbnQsIHt0eXBlOiBldmVudC50eXBlfSkgOiB1cGRhdGVNb2RlbDtcbiAgICAgICAgICAgICAgICB0aW1lb3V0SGFuZGxlID0ga28udXRpbHMuc2V0VGltZW91dChoYW5kbGVyLCA0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICAvLyBJRTkgd2lsbCBtZXNzIHVwIHRoZSBET00gaWYgeW91IGhhbmRsZSBldmVudHMgc3luY2hyb25vdXNseSB3aGljaCByZXN1bHRzIGluIERPTSBjaGFuZ2VzIChzdWNoIGFzIG90aGVyIGJpbmRpbmdzKTtcbiAgICAgICAgLy8gc28gd2UnbGwgbWFrZSBzdXJlIGFsbCB1cGRhdGVzIGFyZSBhc3luY2hyb25vdXNcbiAgICAgICAgdmFyIGllVXBkYXRlTW9kZWwgPSBrby51dGlscy5pZVZlcnNpb24gPT0gOSA/IGRlZmVyVXBkYXRlTW9kZWwgOiB1cGRhdGVNb2RlbDtcblxuICAgICAgICB2YXIgdXBkYXRlVmlldyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBtb2RlbFZhbHVlID0ga28udXRpbHMudW53cmFwT2JzZXJ2YWJsZSh2YWx1ZUFjY2Vzc29yKCkpO1xuXG4gICAgICAgICAgICBpZiAobW9kZWxWYWx1ZSA9PT0gbnVsbCB8fCBtb2RlbFZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBtb2RlbFZhbHVlID0gJyc7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChlbGVtZW50VmFsdWVCZWZvcmVFdmVudCAhPT0gdW5kZWZpbmVkICYmIG1vZGVsVmFsdWUgPT09IGVsZW1lbnRWYWx1ZUJlZm9yZUV2ZW50KSB7XG4gICAgICAgICAgICAgICAga28udXRpbHMuc2V0VGltZW91dCh1cGRhdGVWaWV3LCA0KTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFVwZGF0ZSB0aGUgZWxlbWVudCBvbmx5IGlmIHRoZSBlbGVtZW50IGFuZCBtb2RlbCBhcmUgZGlmZmVyZW50LiBPbiBzb21lIGJyb3dzZXJzLCB1cGRhdGluZyB0aGUgdmFsdWVcbiAgICAgICAgICAgIC8vIHdpbGwgbW92ZSB0aGUgY3Vyc29yIHRvIHRoZSBlbmQgb2YgdGhlIGlucHV0LCB3aGljaCB3b3VsZCBiZSBiYWQgd2hpbGUgdGhlIHVzZXIgaXMgdHlwaW5nLlxuICAgICAgICAgICAgaWYgKGVsZW1lbnQudmFsdWUgIT09IG1vZGVsVmFsdWUpIHtcbiAgICAgICAgICAgICAgICBwcmV2aW91c0VsZW1lbnRWYWx1ZSA9IG1vZGVsVmFsdWU7ICAvLyBNYWtlIHN1cmUgd2UgaWdub3JlIGV2ZW50cyAocHJvcGVydHljaGFuZ2UpIHRoYXQgcmVzdWx0IGZyb20gdXBkYXRpbmcgdGhlIHZhbHVlXG4gICAgICAgICAgICAgICAgZWxlbWVudC52YWx1ZSA9IG1vZGVsVmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIG9uRXZlbnQgPSBmdW5jdGlvbiAoZXZlbnQsIGhhbmRsZXIpIHtcbiAgICAgICAgICAgIGtvLnV0aWxzLnJlZ2lzdGVyRXZlbnRIYW5kbGVyKGVsZW1lbnQsIGV2ZW50LCBoYW5kbGVyKTtcbiAgICAgICAgfTtcblxuICAgICAgICBpZiAoREVCVUcgJiYga28uYmluZGluZ0hhbmRsZXJzWyd0ZXh0SW5wdXQnXVsnX2ZvcmNlVXBkYXRlT24nXSkge1xuICAgICAgICAgICAgLy8gUHJvdmlkZSBhIHdheSBmb3IgdGVzdHMgdG8gc3BlY2lmeSBleGFjdGx5IHdoaWNoIGV2ZW50cyBhcmUgYm91bmRcbiAgICAgICAgICAgIGtvLnV0aWxzLmFycmF5Rm9yRWFjaChrby5iaW5kaW5nSGFuZGxlcnNbJ3RleHRJbnB1dCddWydfZm9yY2VVcGRhdGVPbiddLCBmdW5jdGlvbihldmVudE5hbWUpIHtcbiAgICAgICAgICAgICAgICBpZiAoZXZlbnROYW1lLnNsaWNlKDAsNSkgPT0gJ2FmdGVyJykge1xuICAgICAgICAgICAgICAgICAgICBvbkV2ZW50KGV2ZW50TmFtZS5zbGljZSg1KSwgZGVmZXJVcGRhdGVNb2RlbCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgb25FdmVudChldmVudE5hbWUsIHVwZGF0ZU1vZGVsKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChrby51dGlscy5pZVZlcnNpb24gPCAxMCkge1xuICAgICAgICAgICAgICAgIC8vIEludGVybmV0IEV4cGxvcmVyIDw9IDggZG9lc24ndCBzdXBwb3J0IHRoZSAnaW5wdXQnIGV2ZW50LCBidXQgZG9lcyBpbmNsdWRlICdwcm9wZXJ0eWNoYW5nZScgdGhhdCBmaXJlcyB3aGVuZXZlclxuICAgICAgICAgICAgICAgIC8vIGFueSBwcm9wZXJ0eSBvZiBhbiBlbGVtZW50IGNoYW5nZXMuIFVubGlrZSAnaW5wdXQnLCBpdCBhbHNvIGZpcmVzIGlmIGEgcHJvcGVydHkgaXMgY2hhbmdlZCBmcm9tIEphdmFTY3JpcHQgY29kZSxcbiAgICAgICAgICAgICAgICAvLyBidXQgdGhhdCdzIGFuIGFjY2VwdGFibGUgY29tcHJvbWlzZSBmb3IgdGhpcyBiaW5kaW5nLiBJRSA5IGRvZXMgc3VwcG9ydCAnaW5wdXQnLCBidXQgc2luY2UgaXQgZG9lc24ndCBmaXJlIGl0XG4gICAgICAgICAgICAgICAgLy8gd2hlbiB1c2luZyBhdXRvY29tcGxldGUsIHdlJ2xsIHVzZSAncHJvcGVydHljaGFuZ2UnIGZvciBpdCBhbHNvLlxuICAgICAgICAgICAgICAgIG9uRXZlbnQoJ3Byb3BlcnR5Y2hhbmdlJywgZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGV2ZW50LnByb3BlcnR5TmFtZSA9PT0gJ3ZhbHVlJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWVVcGRhdGVNb2RlbChldmVudCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIGlmIChrby51dGlscy5pZVZlcnNpb24gPT0gOCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBJRSA4IGhhcyBhIGJ1ZyB3aGVyZSBpdCBmYWlscyB0byBmaXJlICdwcm9wZXJ0eWNoYW5nZScgb24gdGhlIGZpcnN0IHVwZGF0ZSBmb2xsb3dpbmcgYSB2YWx1ZSBjaGFuZ2UgZnJvbVxuICAgICAgICAgICAgICAgICAgICAvLyBKYXZhU2NyaXB0IGNvZGUuIEl0IGFsc28gZG9lc24ndCBmaXJlIGlmIHlvdSBjbGVhciB0aGUgZW50aXJlIHZhbHVlLiBUbyBmaXggdGhpcywgd2UgYmluZCB0byB0aGUgZm9sbG93aW5nXG4gICAgICAgICAgICAgICAgICAgIC8vIGV2ZW50cyB0b28uXG4gICAgICAgICAgICAgICAgICAgIG9uRXZlbnQoJ2tleXVwJywgdXBkYXRlTW9kZWwpOyAgICAgIC8vIEEgc2luZ2xlIGtleXN0b2tlXG4gICAgICAgICAgICAgICAgICAgIG9uRXZlbnQoJ2tleWRvd24nLCB1cGRhdGVNb2RlbCk7ICAgIC8vIFRoZSBmaXJzdCBjaGFyYWN0ZXIgd2hlbiBhIGtleSBpcyBoZWxkIGRvd25cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGtvLnV0aWxzLmllVmVyc2lvbiA+PSA4KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEludGVybmV0IEV4cGxvcmVyIDkgZG9lc24ndCBmaXJlIHRoZSAnaW5wdXQnIGV2ZW50IHdoZW4gZGVsZXRpbmcgdGV4dCwgaW5jbHVkaW5nIHVzaW5nXG4gICAgICAgICAgICAgICAgICAgIC8vIHRoZSBiYWNrc3BhY2UsIGRlbGV0ZSwgb3IgY3RybC14IGtleXMsIGNsaWNraW5nIHRoZSAneCcgdG8gY2xlYXIgdGhlIGlucHV0LCBkcmFnZ2luZyB0ZXh0XG4gICAgICAgICAgICAgICAgICAgIC8vIG91dCBvZiB0aGUgZmllbGQsIGFuZCBjdXR0aW5nIG9yIGRlbGV0aW5nIHRleHQgdXNpbmcgdGhlIGNvbnRleHQgbWVudS4gJ3NlbGVjdGlvbmNoYW5nZSdcbiAgICAgICAgICAgICAgICAgICAgLy8gY2FuIGRldGVjdCBhbGwgb2YgdGhvc2UgZXhjZXB0IGRyYWdnaW5nIHRleHQgb3V0IG9mIHRoZSBmaWVsZCwgZm9yIHdoaWNoIHdlIHVzZSAnZHJhZ2VuZCcuXG4gICAgICAgICAgICAgICAgICAgIC8vIFRoZXNlIGFyZSBhbHNvIG5lZWRlZCBpbiBJRTggYmVjYXVzZSBvZiB0aGUgYnVnIGRlc2NyaWJlZCBhYm92ZS5cbiAgICAgICAgICAgICAgICAgICAgcmVnaXN0ZXJGb3JTZWxlY3Rpb25DaGFuZ2VFdmVudChlbGVtZW50LCBpZVVwZGF0ZU1vZGVsKTsgIC8vICdzZWxlY3Rpb25jaGFuZ2UnIGNvdmVycyBjdXQsIHBhc3RlLCBkcm9wLCBkZWxldGUsIGV0Yy5cbiAgICAgICAgICAgICAgICAgICAgb25FdmVudCgnZHJhZ2VuZCcsIGRlZmVyVXBkYXRlTW9kZWwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gQWxsIG90aGVyIHN1cHBvcnRlZCBicm93c2VycyBzdXBwb3J0IHRoZSAnaW5wdXQnIGV2ZW50LCB3aGljaCBmaXJlcyB3aGVuZXZlciB0aGUgY29udGVudCBvZiB0aGUgZWxlbWVudCBpcyBjaGFuZ2VkXG4gICAgICAgICAgICAgICAgLy8gdGhyb3VnaCB0aGUgdXNlciBpbnRlcmZhY2UuXG4gICAgICAgICAgICAgICAgb25FdmVudCgnaW5wdXQnLCB1cGRhdGVNb2RlbCk7XG5cbiAgICAgICAgICAgICAgICBpZiAoc2FmYXJpVmVyc2lvbiA8IDUgJiYga28udXRpbHMudGFnTmFtZUxvd2VyKGVsZW1lbnQpID09PSBcInRleHRhcmVhXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gU2FmYXJpIDw1IGRvZXNuJ3QgZmlyZSB0aGUgJ2lucHV0JyBldmVudCBmb3IgPHRleHRhcmVhPiBlbGVtZW50cyAoaXQgZG9lcyBmaXJlICd0ZXh0SW5wdXQnXG4gICAgICAgICAgICAgICAgICAgIC8vIGJ1dCBvbmx5IHdoZW4gdHlwaW5nKS4gU28gd2UnbGwganVzdCBjYXRjaCBhcyBtdWNoIGFzIHdlIGNhbiB3aXRoIGtleWRvd24sIGN1dCwgYW5kIHBhc3RlLlxuICAgICAgICAgICAgICAgICAgICBvbkV2ZW50KCdrZXlkb3duJywgZGVmZXJVcGRhdGVNb2RlbCk7XG4gICAgICAgICAgICAgICAgICAgIG9uRXZlbnQoJ3Bhc3RlJywgZGVmZXJVcGRhdGVNb2RlbCk7XG4gICAgICAgICAgICAgICAgICAgIG9uRXZlbnQoJ2N1dCcsIGRlZmVyVXBkYXRlTW9kZWwpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAob3BlcmFWZXJzaW9uIDwgMTEpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gT3BlcmEgMTAgZG9lc24ndCBhbHdheXMgZmlyZSB0aGUgJ2lucHV0JyBldmVudCBmb3IgY3V0LCBwYXN0ZSwgdW5kbyAmIGRyb3Agb3BlcmF0aW9ucy5cbiAgICAgICAgICAgICAgICAgICAgLy8gV2UgY2FuIHRyeSB0byBjYXRjaCBzb21lIG9mIHRob3NlIHVzaW5nICdrZXlkb3duJy5cbiAgICAgICAgICAgICAgICAgICAgb25FdmVudCgna2V5ZG93bicsIGRlZmVyVXBkYXRlTW9kZWwpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZmlyZWZveFZlcnNpb24gPCA0LjApIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gRmlyZWZveCA8PSAzLjYgZG9lc24ndCBmaXJlIHRoZSAnaW5wdXQnIGV2ZW50IHdoZW4gdGV4dCBpcyBmaWxsZWQgaW4gdGhyb3VnaCBhdXRvY29tcGxldGVcbiAgICAgICAgICAgICAgICAgICAgb25FdmVudCgnRE9NQXV0b0NvbXBsZXRlJywgdXBkYXRlTW9kZWwpO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIEZpcmVmb3ggPD0zLjUgZG9lc24ndCBmaXJlIHRoZSAnaW5wdXQnIGV2ZW50IHdoZW4gdGV4dCBpcyBkcm9wcGVkIGludG8gdGhlIGlucHV0LlxuICAgICAgICAgICAgICAgICAgICBvbkV2ZW50KCdkcmFnZHJvcCcsIHVwZGF0ZU1vZGVsKTsgICAgICAgLy8gPDMuNVxuICAgICAgICAgICAgICAgICAgICBvbkV2ZW50KCdkcm9wJywgdXBkYXRlTW9kZWwpOyAgICAgICAgICAgLy8gMy41XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gQmluZCB0byB0aGUgY2hhbmdlIGV2ZW50IHNvIHRoYXQgd2UgY2FuIGNhdGNoIHByb2dyYW1tYXRpYyB1cGRhdGVzIG9mIHRoZSB2YWx1ZSB0aGF0IGZpcmUgdGhpcyBldmVudC5cbiAgICAgICAgb25FdmVudCgnY2hhbmdlJywgdXBkYXRlTW9kZWwpO1xuXG4gICAgICAgIGtvLmNvbXB1dGVkKHVwZGF0ZVZpZXcsIG51bGwsIHsgZGlzcG9zZVdoZW5Ob2RlSXNSZW1vdmVkOiBlbGVtZW50IH0pO1xuICAgIH1cbn07XG5rby5leHByZXNzaW9uUmV3cml0aW5nLnR3b1dheUJpbmRpbmdzWyd0ZXh0SW5wdXQnXSA9IHRydWU7XG5cbi8vIHRleHRpbnB1dCBpcyBhbiBhbGlhcyBmb3IgdGV4dElucHV0XG5rby5iaW5kaW5nSGFuZGxlcnNbJ3RleHRpbnB1dCddID0ge1xuICAgIC8vIHByZXByb2Nlc3MgaXMgdGhlIG9ubHkgd2F5IHRvIHNldCB1cCBhIGZ1bGwgYWxpYXNcbiAgICAncHJlcHJvY2Vzcyc6IGZ1bmN0aW9uICh2YWx1ZSwgbmFtZSwgYWRkQmluZGluZykge1xuICAgICAgICBhZGRCaW5kaW5nKCd0ZXh0SW5wdXQnLCB2YWx1ZSk7XG4gICAgfVxufTtcblxufSkoKTtrby5iaW5kaW5nSGFuZGxlcnNbJ3VuaXF1ZU5hbWUnXSA9IHtcbiAgICAnaW5pdCc6IGZ1bmN0aW9uIChlbGVtZW50LCB2YWx1ZUFjY2Vzc29yKSB7XG4gICAgICAgIGlmICh2YWx1ZUFjY2Vzc29yKCkpIHtcbiAgICAgICAgICAgIHZhciBuYW1lID0gXCJrb191bmlxdWVfXCIgKyAoKytrby5iaW5kaW5nSGFuZGxlcnNbJ3VuaXF1ZU5hbWUnXS5jdXJyZW50SW5kZXgpO1xuICAgICAgICAgICAga28udXRpbHMuc2V0RWxlbWVudE5hbWUoZWxlbWVudCwgbmFtZSk7XG4gICAgICAgIH1cbiAgICB9XG59O1xua28uYmluZGluZ0hhbmRsZXJzWyd1bmlxdWVOYW1lJ10uY3VycmVudEluZGV4ID0gMDtcbmtvLmJpbmRpbmdIYW5kbGVyc1sndmFsdWUnXSA9IHtcbiAgICAnYWZ0ZXInOiBbJ29wdGlvbnMnLCAnZm9yZWFjaCddLFxuICAgICdpbml0JzogZnVuY3Rpb24gKGVsZW1lbnQsIHZhbHVlQWNjZXNzb3IsIGFsbEJpbmRpbmdzKSB7XG4gICAgICAgIC8vIElmIHRoZSB2YWx1ZSBiaW5kaW5nIGlzIHBsYWNlZCBvbiBhIHJhZGlvL2NoZWNrYm94LCB0aGVuIGp1c3QgcGFzcyB0aHJvdWdoIHRvIGNoZWNrZWRWYWx1ZSBhbmQgcXVpdFxuICAgICAgICBpZiAoZWxlbWVudC50YWdOYW1lLnRvTG93ZXJDYXNlKCkgPT0gXCJpbnB1dFwiICYmIChlbGVtZW50LnR5cGUgPT0gXCJjaGVja2JveFwiIHx8IGVsZW1lbnQudHlwZSA9PSBcInJhZGlvXCIpKSB7XG4gICAgICAgICAgICBrby5hcHBseUJpbmRpbmdBY2Nlc3NvcnNUb05vZGUoZWxlbWVudCwgeyAnY2hlY2tlZFZhbHVlJzogdmFsdWVBY2Nlc3NvciB9KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEFsd2F5cyBjYXRjaCBcImNoYW5nZVwiIGV2ZW50OyBwb3NzaWJseSBvdGhlciBldmVudHMgdG9vIGlmIGFza2VkXG4gICAgICAgIHZhciBldmVudHNUb0NhdGNoID0gW1wiY2hhbmdlXCJdO1xuICAgICAgICB2YXIgcmVxdWVzdGVkRXZlbnRzVG9DYXRjaCA9IGFsbEJpbmRpbmdzLmdldChcInZhbHVlVXBkYXRlXCIpO1xuICAgICAgICB2YXIgcHJvcGVydHlDaGFuZ2VkRmlyZWQgPSBmYWxzZTtcbiAgICAgICAgdmFyIGVsZW1lbnRWYWx1ZUJlZm9yZUV2ZW50ID0gbnVsbDtcblxuICAgICAgICBpZiAocmVxdWVzdGVkRXZlbnRzVG9DYXRjaCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiByZXF1ZXN0ZWRFdmVudHNUb0NhdGNoID09IFwic3RyaW5nXCIpIC8vIEFsbG93IGJvdGggaW5kaXZpZHVhbCBldmVudCBuYW1lcywgYW5kIGFycmF5cyBvZiBldmVudCBuYW1lc1xuICAgICAgICAgICAgICAgIHJlcXVlc3RlZEV2ZW50c1RvQ2F0Y2ggPSBbcmVxdWVzdGVkRXZlbnRzVG9DYXRjaF07XG4gICAgICAgICAgICBrby51dGlscy5hcnJheVB1c2hBbGwoZXZlbnRzVG9DYXRjaCwgcmVxdWVzdGVkRXZlbnRzVG9DYXRjaCk7XG4gICAgICAgICAgICBldmVudHNUb0NhdGNoID0ga28udXRpbHMuYXJyYXlHZXREaXN0aW5jdFZhbHVlcyhldmVudHNUb0NhdGNoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB2YWx1ZVVwZGF0ZUhhbmRsZXIgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGVsZW1lbnRWYWx1ZUJlZm9yZUV2ZW50ID0gbnVsbDtcbiAgICAgICAgICAgIHByb3BlcnR5Q2hhbmdlZEZpcmVkID0gZmFsc2U7XG4gICAgICAgICAgICB2YXIgbW9kZWxWYWx1ZSA9IHZhbHVlQWNjZXNzb3IoKTtcbiAgICAgICAgICAgIHZhciBlbGVtZW50VmFsdWUgPSBrby5zZWxlY3RFeHRlbnNpb25zLnJlYWRWYWx1ZShlbGVtZW50KTtcbiAgICAgICAgICAgIGtvLmV4cHJlc3Npb25SZXdyaXRpbmcud3JpdGVWYWx1ZVRvUHJvcGVydHkobW9kZWxWYWx1ZSwgYWxsQmluZGluZ3MsICd2YWx1ZScsIGVsZW1lbnRWYWx1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBXb3JrYXJvdW5kIGZvciBodHRwczovL2dpdGh1Yi5jb20vU3RldmVTYW5kZXJzb24va25vY2tvdXQvaXNzdWVzLzEyMlxuICAgICAgICAvLyBJRSBkb2Vzbid0IGZpcmUgXCJjaGFuZ2VcIiBldmVudHMgb24gdGV4dGJveGVzIGlmIHRoZSB1c2VyIHNlbGVjdHMgYSB2YWx1ZSBmcm9tIGl0cyBhdXRvY29tcGxldGUgbGlzdFxuICAgICAgICB2YXIgaWVBdXRvQ29tcGxldGVIYWNrTmVlZGVkID0ga28udXRpbHMuaWVWZXJzaW9uICYmIGVsZW1lbnQudGFnTmFtZS50b0xvd2VyQ2FzZSgpID09IFwiaW5wdXRcIiAmJiBlbGVtZW50LnR5cGUgPT0gXCJ0ZXh0XCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICYmIGVsZW1lbnQuYXV0b2NvbXBsZXRlICE9IFwib2ZmXCIgJiYgKCFlbGVtZW50LmZvcm0gfHwgZWxlbWVudC5mb3JtLmF1dG9jb21wbGV0ZSAhPSBcIm9mZlwiKTtcbiAgICAgICAgaWYgKGllQXV0b0NvbXBsZXRlSGFja05lZWRlZCAmJiBrby51dGlscy5hcnJheUluZGV4T2YoZXZlbnRzVG9DYXRjaCwgXCJwcm9wZXJ0eWNoYW5nZVwiKSA9PSAtMSkge1xuICAgICAgICAgICAga28udXRpbHMucmVnaXN0ZXJFdmVudEhhbmRsZXIoZWxlbWVudCwgXCJwcm9wZXJ0eWNoYW5nZVwiLCBmdW5jdGlvbiAoKSB7IHByb3BlcnR5Q2hhbmdlZEZpcmVkID0gdHJ1ZSB9KTtcbiAgICAgICAgICAgIGtvLnV0aWxzLnJlZ2lzdGVyRXZlbnRIYW5kbGVyKGVsZW1lbnQsIFwiZm9jdXNcIiwgZnVuY3Rpb24gKCkgeyBwcm9wZXJ0eUNoYW5nZWRGaXJlZCA9IGZhbHNlIH0pO1xuICAgICAgICAgICAga28udXRpbHMucmVnaXN0ZXJFdmVudEhhbmRsZXIoZWxlbWVudCwgXCJibHVyXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGlmIChwcm9wZXJ0eUNoYW5nZWRGaXJlZCkge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZVVwZGF0ZUhhbmRsZXIoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGtvLnV0aWxzLmFycmF5Rm9yRWFjaChldmVudHNUb0NhdGNoLCBmdW5jdGlvbihldmVudE5hbWUpIHtcbiAgICAgICAgICAgIC8vIFRoZSBzeW50YXggXCJhZnRlcjxldmVudG5hbWU+XCIgbWVhbnMgXCJydW4gdGhlIGhhbmRsZXIgYXN5bmNocm9ub3VzbHkgYWZ0ZXIgdGhlIGV2ZW50XCJcbiAgICAgICAgICAgIC8vIFRoaXMgaXMgdXNlZnVsLCBmb3IgZXhhbXBsZSwgdG8gY2F0Y2ggXCJrZXlkb3duXCIgZXZlbnRzIGFmdGVyIHRoZSBicm93c2VyIGhhcyB1cGRhdGVkIHRoZSBjb250cm9sXG4gICAgICAgICAgICAvLyAob3RoZXJ3aXNlLCBrby5zZWxlY3RFeHRlbnNpb25zLnJlYWRWYWx1ZSh0aGlzKSB3aWxsIHJlY2VpdmUgdGhlIGNvbnRyb2wncyB2YWx1ZSAqYmVmb3JlKiB0aGUga2V5IGV2ZW50KVxuICAgICAgICAgICAgdmFyIGhhbmRsZXIgPSB2YWx1ZVVwZGF0ZUhhbmRsZXI7XG4gICAgICAgICAgICBpZiAoa28udXRpbHMuc3RyaW5nU3RhcnRzV2l0aChldmVudE5hbWUsIFwiYWZ0ZXJcIikpIHtcbiAgICAgICAgICAgICAgICBoYW5kbGVyID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRoZSBlbGVtZW50VmFsdWVCZWZvcmVFdmVudCB2YXJpYWJsZSBpcyBub24tbnVsbCAqb25seSogZHVyaW5nIHRoZSBicmllZiBnYXAgYmV0d2VlblxuICAgICAgICAgICAgICAgICAgICAvLyBhIGtleVggZXZlbnQgZmlyaW5nIGFuZCB0aGUgdmFsdWVVcGRhdGVIYW5kbGVyIHJ1bm5pbmcsIHdoaWNoIGlzIHNjaGVkdWxlZCB0byBoYXBwZW5cbiAgICAgICAgICAgICAgICAgICAgLy8gYXQgdGhlIGVhcmxpZXN0IGFzeW5jaHJvbm91cyBvcHBvcnR1bml0eS4gV2Ugc3RvcmUgdGhpcyB0ZW1wb3JhcnkgaW5mb3JtYXRpb24gc28gdGhhdFxuICAgICAgICAgICAgICAgICAgICAvLyBpZiwgYmV0d2VlbiBrZXlYIGFuZCB2YWx1ZVVwZGF0ZUhhbmRsZXIsIHRoZSB1bmRlcmx5aW5nIG1vZGVsIHZhbHVlIGNoYW5nZXMgc2VwYXJhdGVseSxcbiAgICAgICAgICAgICAgICAgICAgLy8gd2UgY2FuIG92ZXJ3cml0ZSB0aGF0IG1vZGVsIHZhbHVlIGNoYW5nZSB3aXRoIHRoZSB2YWx1ZSB0aGUgdXNlciBqdXN0IHR5cGVkLiBPdGhlcndpc2UsXG4gICAgICAgICAgICAgICAgICAgIC8vIHRlY2huaXF1ZXMgbGlrZSByYXRlTGltaXQgY2FuIHRyaWdnZXIgbW9kZWwgY2hhbmdlcyBhdCBjcml0aWNhbCBtb21lbnRzIHRoYXQgd2lsbFxuICAgICAgICAgICAgICAgICAgICAvLyBvdmVycmlkZSB0aGUgdXNlcidzIGlucHV0cywgY2F1c2luZyBrZXlzdHJva2VzIHRvIGJlIGxvc3QuXG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnRWYWx1ZUJlZm9yZUV2ZW50ID0ga28uc2VsZWN0RXh0ZW5zaW9ucy5yZWFkVmFsdWUoZWxlbWVudCk7XG4gICAgICAgICAgICAgICAgICAgIGtvLnV0aWxzLnNldFRpbWVvdXQodmFsdWVVcGRhdGVIYW5kbGVyLCAwKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGV2ZW50TmFtZSA9IGV2ZW50TmFtZS5zdWJzdHJpbmcoXCJhZnRlclwiLmxlbmd0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBrby51dGlscy5yZWdpc3RlckV2ZW50SGFuZGxlcihlbGVtZW50LCBldmVudE5hbWUsIGhhbmRsZXIpO1xuICAgICAgICB9KTtcblxuICAgICAgICB2YXIgdXBkYXRlRnJvbU1vZGVsID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIG5ld1ZhbHVlID0ga28udXRpbHMudW53cmFwT2JzZXJ2YWJsZSh2YWx1ZUFjY2Vzc29yKCkpO1xuICAgICAgICAgICAgdmFyIGVsZW1lbnRWYWx1ZSA9IGtvLnNlbGVjdEV4dGVuc2lvbnMucmVhZFZhbHVlKGVsZW1lbnQpO1xuXG4gICAgICAgICAgICBpZiAoZWxlbWVudFZhbHVlQmVmb3JlRXZlbnQgIT09IG51bGwgJiYgbmV3VmFsdWUgPT09IGVsZW1lbnRWYWx1ZUJlZm9yZUV2ZW50KSB7XG4gICAgICAgICAgICAgICAga28udXRpbHMuc2V0VGltZW91dCh1cGRhdGVGcm9tTW9kZWwsIDApO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHZhbHVlSGFzQ2hhbmdlZCA9IChuZXdWYWx1ZSAhPT0gZWxlbWVudFZhbHVlKTtcblxuICAgICAgICAgICAgaWYgKHZhbHVlSGFzQ2hhbmdlZCkge1xuICAgICAgICAgICAgICAgIGlmIChrby51dGlscy50YWdOYW1lTG93ZXIoZWxlbWVudCkgPT09IFwic2VsZWN0XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGFsbG93VW5zZXQgPSBhbGxCaW5kaW5ncy5nZXQoJ3ZhbHVlQWxsb3dVbnNldCcpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgYXBwbHlWYWx1ZUFjdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGtvLnNlbGVjdEV4dGVuc2lvbnMud3JpdGVWYWx1ZShlbGVtZW50LCBuZXdWYWx1ZSwgYWxsb3dVbnNldCk7XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIGFwcGx5VmFsdWVBY3Rpb24oKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoIWFsbG93VW5zZXQgJiYgbmV3VmFsdWUgIT09IGtvLnNlbGVjdEV4dGVuc2lvbnMucmVhZFZhbHVlKGVsZW1lbnQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiB5b3UgdHJ5IHRvIHNldCBhIG1vZGVsIHZhbHVlIHRoYXQgY2FuJ3QgYmUgcmVwcmVzZW50ZWQgaW4gYW4gYWxyZWFkeS1wb3B1bGF0ZWQgZHJvcGRvd24sIHJlamVjdCB0aGF0IGNoYW5nZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGJlY2F1c2UgeW91J3JlIG5vdCBhbGxvd2VkIHRvIGhhdmUgYSBtb2RlbCB2YWx1ZSB0aGF0IGRpc2FncmVlcyB3aXRoIGEgdmlzaWJsZSBVSSBzZWxlY3Rpb24uXG4gICAgICAgICAgICAgICAgICAgICAgICBrby5kZXBlbmRlbmN5RGV0ZWN0aW9uLmlnbm9yZShrby51dGlscy50cmlnZ2VyRXZlbnQsIG51bGwsIFtlbGVtZW50LCBcImNoYW5nZVwiXSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBXb3JrYXJvdW5kIGZvciBJRTYgYnVnOiBJdCB3b24ndCByZWxpYWJseSBhcHBseSB2YWx1ZXMgdG8gU0VMRUNUIG5vZGVzIGR1cmluZyB0aGUgc2FtZSBleGVjdXRpb24gdGhyZWFkXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyByaWdodCBhZnRlciB5b3UndmUgY2hhbmdlZCB0aGUgc2V0IG9mIE9QVElPTiBub2RlcyBvbiBpdC4gU28gZm9yIHRoYXQgbm9kZSB0eXBlLCB3ZSdsbCBzY2hlZHVsZSBhIHNlY29uZCB0aHJlYWRcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRvIGFwcGx5IHRoZSB2YWx1ZSBhcyB3ZWxsLlxuICAgICAgICAgICAgICAgICAgICAgICAga28udXRpbHMuc2V0VGltZW91dChhcHBseVZhbHVlQWN0aW9uLCAwKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGtvLnNlbGVjdEV4dGVuc2lvbnMud3JpdGVWYWx1ZShlbGVtZW50LCBuZXdWYWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIGtvLmNvbXB1dGVkKHVwZGF0ZUZyb21Nb2RlbCwgbnVsbCwgeyBkaXNwb3NlV2hlbk5vZGVJc1JlbW92ZWQ6IGVsZW1lbnQgfSk7XG4gICAgfSxcbiAgICAndXBkYXRlJzogZnVuY3Rpb24oKSB7fSAvLyBLZWVwIGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eSB3aXRoIGNvZGUgdGhhdCBtYXkgaGF2ZSB3cmFwcGVkIHZhbHVlIGJpbmRpbmdcbn07XG5rby5leHByZXNzaW9uUmV3cml0aW5nLnR3b1dheUJpbmRpbmdzWyd2YWx1ZSddID0gdHJ1ZTtcbmtvLmJpbmRpbmdIYW5kbGVyc1sndmlzaWJsZSddID0ge1xuICAgICd1cGRhdGUnOiBmdW5jdGlvbiAoZWxlbWVudCwgdmFsdWVBY2Nlc3Nvcikge1xuICAgICAgICB2YXIgdmFsdWUgPSBrby51dGlscy51bndyYXBPYnNlcnZhYmxlKHZhbHVlQWNjZXNzb3IoKSk7XG4gICAgICAgIHZhciBpc0N1cnJlbnRseVZpc2libGUgPSAhKGVsZW1lbnQuc3R5bGUuZGlzcGxheSA9PSBcIm5vbmVcIik7XG4gICAgICAgIGlmICh2YWx1ZSAmJiAhaXNDdXJyZW50bHlWaXNpYmxlKVxuICAgICAgICAgICAgZWxlbWVudC5zdHlsZS5kaXNwbGF5ID0gXCJcIjtcbiAgICAgICAgZWxzZSBpZiAoKCF2YWx1ZSkgJiYgaXNDdXJyZW50bHlWaXNpYmxlKVxuICAgICAgICAgICAgZWxlbWVudC5zdHlsZS5kaXNwbGF5ID0gXCJub25lXCI7XG4gICAgfVxufTtcbi8vICdjbGljaycgaXMganVzdCBhIHNob3J0aGFuZCBmb3IgdGhlIHVzdWFsIGZ1bGwtbGVuZ3RoIGV2ZW50OntjbGljazpoYW5kbGVyfVxubWFrZUV2ZW50SGFuZGxlclNob3J0Y3V0KCdjbGljaycpO1xuLy8gSWYgeW91IHdhbnQgdG8gbWFrZSBhIGN1c3RvbSB0ZW1wbGF0ZSBlbmdpbmUsXG4vL1xuLy8gWzFdIEluaGVyaXQgZnJvbSB0aGlzIGNsYXNzIChsaWtlIGtvLm5hdGl2ZVRlbXBsYXRlRW5naW5lIGRvZXMpXG4vLyBbMl0gT3ZlcnJpZGUgJ3JlbmRlclRlbXBsYXRlU291cmNlJywgc3VwcGx5aW5nIGEgZnVuY3Rpb24gd2l0aCB0aGlzIHNpZ25hdHVyZTpcbi8vXG4vLyAgICAgICAgZnVuY3Rpb24gKHRlbXBsYXRlU291cmNlLCBiaW5kaW5nQ29udGV4dCwgb3B0aW9ucykge1xuLy8gICAgICAgICAgICAvLyAtIHRlbXBsYXRlU291cmNlLnRleHQoKSBpcyB0aGUgdGV4dCBvZiB0aGUgdGVtcGxhdGUgeW91IHNob3VsZCByZW5kZXJcbi8vICAgICAgICAgICAgLy8gLSBiaW5kaW5nQ29udGV4dC4kZGF0YSBpcyB0aGUgZGF0YSB5b3Ugc2hvdWxkIHBhc3MgaW50byB0aGUgdGVtcGxhdGVcbi8vICAgICAgICAgICAgLy8gICAtIHlvdSBtaWdodCBhbHNvIHdhbnQgdG8gbWFrZSBiaW5kaW5nQ29udGV4dC4kcGFyZW50LCBiaW5kaW5nQ29udGV4dC4kcGFyZW50cyxcbi8vICAgICAgICAgICAgLy8gICAgIGFuZCBiaW5kaW5nQ29udGV4dC4kcm9vdCBhdmFpbGFibGUgaW4gdGhlIHRlbXBsYXRlIHRvb1xuLy8gICAgICAgICAgICAvLyAtIG9wdGlvbnMgZ2l2ZXMgeW91IGFjY2VzcyB0byBhbnkgb3RoZXIgcHJvcGVydGllcyBzZXQgb24gXCJkYXRhLWJpbmQ6IHsgdGVtcGxhdGU6IG9wdGlvbnMgfVwiXG4vLyAgICAgICAgICAgIC8vIC0gdGVtcGxhdGVEb2N1bWVudCBpcyB0aGUgZG9jdW1lbnQgb2JqZWN0IG9mIHRoZSB0ZW1wbGF0ZVxuLy8gICAgICAgICAgICAvL1xuLy8gICAgICAgICAgICAvLyBSZXR1cm4gdmFsdWU6IGFuIGFycmF5IG9mIERPTSBub2Rlc1xuLy8gICAgICAgIH1cbi8vXG4vLyBbM10gT3ZlcnJpZGUgJ2NyZWF0ZUphdmFTY3JpcHRFdmFsdWF0b3JCbG9jaycsIHN1cHBseWluZyBhIGZ1bmN0aW9uIHdpdGggdGhpcyBzaWduYXR1cmU6XG4vL1xuLy8gICAgICAgIGZ1bmN0aW9uIChzY3JpcHQpIHtcbi8vICAgICAgICAgICAgLy8gUmV0dXJuIHZhbHVlOiBXaGF0ZXZlciBzeW50YXggbWVhbnMgXCJFdmFsdWF0ZSB0aGUgSmF2YVNjcmlwdCBzdGF0ZW1lbnQgJ3NjcmlwdCcgYW5kIG91dHB1dCB0aGUgcmVzdWx0XCJcbi8vICAgICAgICAgICAgLy8gICAgICAgICAgICAgICBGb3IgZXhhbXBsZSwgdGhlIGpxdWVyeS50bXBsIHRlbXBsYXRlIGVuZ2luZSBjb252ZXJ0cyAnc29tZVNjcmlwdCcgdG8gJyR7IHNvbWVTY3JpcHQgfSdcbi8vICAgICAgICB9XG4vL1xuLy8gICAgIFRoaXMgaXMgb25seSBuZWNlc3NhcnkgaWYgeW91IHdhbnQgdG8gYWxsb3cgZGF0YS1iaW5kIGF0dHJpYnV0ZXMgdG8gcmVmZXJlbmNlIGFyYml0cmFyeSB0ZW1wbGF0ZSB2YXJpYWJsZXMuXG4vLyAgICAgSWYgeW91IGRvbid0IHdhbnQgdG8gYWxsb3cgdGhhdCwgeW91IGNhbiBzZXQgdGhlIHByb3BlcnR5ICdhbGxvd1RlbXBsYXRlUmV3cml0aW5nJyB0byBmYWxzZSAobGlrZSBrby5uYXRpdmVUZW1wbGF0ZUVuZ2luZSBkb2VzKVxuLy8gICAgIGFuZCB0aGVuIHlvdSBkb24ndCBuZWVkIHRvIG92ZXJyaWRlICdjcmVhdGVKYXZhU2NyaXB0RXZhbHVhdG9yQmxvY2snLlxuXG5rby50ZW1wbGF0ZUVuZ2luZSA9IGZ1bmN0aW9uICgpIHsgfTtcblxua28udGVtcGxhdGVFbmdpbmUucHJvdG90eXBlWydyZW5kZXJUZW1wbGF0ZVNvdXJjZSddID0gZnVuY3Rpb24gKHRlbXBsYXRlU291cmNlLCBiaW5kaW5nQ29udGV4dCwgb3B0aW9ucywgdGVtcGxhdGVEb2N1bWVudCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIk92ZXJyaWRlIHJlbmRlclRlbXBsYXRlU291cmNlXCIpO1xufTtcblxua28udGVtcGxhdGVFbmdpbmUucHJvdG90eXBlWydjcmVhdGVKYXZhU2NyaXB0RXZhbHVhdG9yQmxvY2snXSA9IGZ1bmN0aW9uIChzY3JpcHQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJPdmVycmlkZSBjcmVhdGVKYXZhU2NyaXB0RXZhbHVhdG9yQmxvY2tcIik7XG59O1xuXG5rby50ZW1wbGF0ZUVuZ2luZS5wcm90b3R5cGVbJ21ha2VUZW1wbGF0ZVNvdXJjZSddID0gZnVuY3Rpb24odGVtcGxhdGUsIHRlbXBsYXRlRG9jdW1lbnQpIHtcbiAgICAvLyBOYW1lZCB0ZW1wbGF0ZVxuICAgIGlmICh0eXBlb2YgdGVtcGxhdGUgPT0gXCJzdHJpbmdcIikge1xuICAgICAgICB0ZW1wbGF0ZURvY3VtZW50ID0gdGVtcGxhdGVEb2N1bWVudCB8fCBkb2N1bWVudDtcbiAgICAgICAgdmFyIGVsZW0gPSB0ZW1wbGF0ZURvY3VtZW50LmdldEVsZW1lbnRCeUlkKHRlbXBsYXRlKTtcbiAgICAgICAgaWYgKCFlbGVtKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgdGVtcGxhdGUgd2l0aCBJRCBcIiArIHRlbXBsYXRlKTtcbiAgICAgICAgcmV0dXJuIG5ldyBrby50ZW1wbGF0ZVNvdXJjZXMuZG9tRWxlbWVudChlbGVtKTtcbiAgICB9IGVsc2UgaWYgKCh0ZW1wbGF0ZS5ub2RlVHlwZSA9PSAxKSB8fCAodGVtcGxhdGUubm9kZVR5cGUgPT0gOCkpIHtcbiAgICAgICAgLy8gQW5vbnltb3VzIHRlbXBsYXRlXG4gICAgICAgIHJldHVybiBuZXcga28udGVtcGxhdGVTb3VyY2VzLmFub255bW91c1RlbXBsYXRlKHRlbXBsYXRlKTtcbiAgICB9IGVsc2VcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biB0ZW1wbGF0ZSB0eXBlOiBcIiArIHRlbXBsYXRlKTtcbn07XG5cbmtvLnRlbXBsYXRlRW5naW5lLnByb3RvdHlwZVsncmVuZGVyVGVtcGxhdGUnXSA9IGZ1bmN0aW9uICh0ZW1wbGF0ZSwgYmluZGluZ0NvbnRleHQsIG9wdGlvbnMsIHRlbXBsYXRlRG9jdW1lbnQpIHtcbiAgICB2YXIgdGVtcGxhdGVTb3VyY2UgPSB0aGlzWydtYWtlVGVtcGxhdGVTb3VyY2UnXSh0ZW1wbGF0ZSwgdGVtcGxhdGVEb2N1bWVudCk7XG4gICAgcmV0dXJuIHRoaXNbJ3JlbmRlclRlbXBsYXRlU291cmNlJ10odGVtcGxhdGVTb3VyY2UsIGJpbmRpbmdDb250ZXh0LCBvcHRpb25zLCB0ZW1wbGF0ZURvY3VtZW50KTtcbn07XG5cbmtvLnRlbXBsYXRlRW5naW5lLnByb3RvdHlwZVsnaXNUZW1wbGF0ZVJld3JpdHRlbiddID0gZnVuY3Rpb24gKHRlbXBsYXRlLCB0ZW1wbGF0ZURvY3VtZW50KSB7XG4gICAgLy8gU2tpcCByZXdyaXRpbmcgaWYgcmVxdWVzdGVkXG4gICAgaWYgKHRoaXNbJ2FsbG93VGVtcGxhdGVSZXdyaXRpbmcnXSA9PT0gZmFsc2UpXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIHJldHVybiB0aGlzWydtYWtlVGVtcGxhdGVTb3VyY2UnXSh0ZW1wbGF0ZSwgdGVtcGxhdGVEb2N1bWVudClbJ2RhdGEnXShcImlzUmV3cml0dGVuXCIpO1xufTtcblxua28udGVtcGxhdGVFbmdpbmUucHJvdG90eXBlWydyZXdyaXRlVGVtcGxhdGUnXSA9IGZ1bmN0aW9uICh0ZW1wbGF0ZSwgcmV3cml0ZXJDYWxsYmFjaywgdGVtcGxhdGVEb2N1bWVudCkge1xuICAgIHZhciB0ZW1wbGF0ZVNvdXJjZSA9IHRoaXNbJ21ha2VUZW1wbGF0ZVNvdXJjZSddKHRlbXBsYXRlLCB0ZW1wbGF0ZURvY3VtZW50KTtcbiAgICB2YXIgcmV3cml0dGVuID0gcmV3cml0ZXJDYWxsYmFjayh0ZW1wbGF0ZVNvdXJjZVsndGV4dCddKCkpO1xuICAgIHRlbXBsYXRlU291cmNlWyd0ZXh0J10ocmV3cml0dGVuKTtcbiAgICB0ZW1wbGF0ZVNvdXJjZVsnZGF0YSddKFwiaXNSZXdyaXR0ZW5cIiwgdHJ1ZSk7XG59O1xuXG5rby5leHBvcnRTeW1ib2woJ3RlbXBsYXRlRW5naW5lJywga28udGVtcGxhdGVFbmdpbmUpO1xuXG5rby50ZW1wbGF0ZVJld3JpdGluZyA9IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG1lbW9pemVEYXRhQmluZGluZ0F0dHJpYnV0ZVN5bnRheFJlZ2V4ID0gLyg8KFthLXpdK1xcZCopKD86XFxzKyg/IWRhdGEtYmluZFxccyo9XFxzKilbYS16MC05XFwtXSsoPzo9KD86XFxcIlteXFxcIl0qXFxcInxcXCdbXlxcJ10qXFwnfFtePl0qKSk/KSpcXHMrKWRhdGEtYmluZFxccyo9XFxzKihbXCInXSkoW1xcc1xcU10qPylcXDMvZ2k7XG4gICAgdmFyIG1lbW9pemVWaXJ0dWFsQ29udGFpbmVyQmluZGluZ1N5bnRheFJlZ2V4ID0gLzwhLS1cXHMqa29cXGJcXHMqKFtcXHNcXFNdKj8pXFxzKi0tPi9nO1xuXG4gICAgZnVuY3Rpb24gdmFsaWRhdGVEYXRhQmluZFZhbHVlc0ZvclJld3JpdGluZyhrZXlWYWx1ZUFycmF5KSB7XG4gICAgICAgIHZhciBhbGxWYWxpZGF0b3JzID0ga28uZXhwcmVzc2lvblJld3JpdGluZy5iaW5kaW5nUmV3cml0ZVZhbGlkYXRvcnM7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5VmFsdWVBcnJheS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGtleSA9IGtleVZhbHVlQXJyYXlbaV1bJ2tleSddO1xuICAgICAgICAgICAgaWYgKGFsbFZhbGlkYXRvcnMuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgICAgICAgIHZhciB2YWxpZGF0b3IgPSBhbGxWYWxpZGF0b3JzW2tleV07XG5cbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHZhbGlkYXRvciA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBwb3NzaWJsZUVycm9yTWVzc2FnZSA9IHZhbGlkYXRvcihrZXlWYWx1ZUFycmF5W2ldWyd2YWx1ZSddKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBvc3NpYmxlRXJyb3JNZXNzYWdlKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKHBvc3NpYmxlRXJyb3JNZXNzYWdlKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCF2YWxpZGF0b3IpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhpcyB0ZW1wbGF0ZSBlbmdpbmUgZG9lcyBub3Qgc3VwcG9ydCB0aGUgJ1wiICsga2V5ICsgXCInIGJpbmRpbmcgd2l0aGluIGl0cyB0ZW1wbGF0ZXNcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY29uc3RydWN0TWVtb2l6ZWRUYWdSZXBsYWNlbWVudChkYXRhQmluZEF0dHJpYnV0ZVZhbHVlLCB0YWdUb1JldGFpbiwgbm9kZU5hbWUsIHRlbXBsYXRlRW5naW5lKSB7XG4gICAgICAgIHZhciBkYXRhQmluZEtleVZhbHVlQXJyYXkgPSBrby5leHByZXNzaW9uUmV3cml0aW5nLnBhcnNlT2JqZWN0TGl0ZXJhbChkYXRhQmluZEF0dHJpYnV0ZVZhbHVlKTtcbiAgICAgICAgdmFsaWRhdGVEYXRhQmluZFZhbHVlc0ZvclJld3JpdGluZyhkYXRhQmluZEtleVZhbHVlQXJyYXkpO1xuICAgICAgICB2YXIgcmV3cml0dGVuRGF0YUJpbmRBdHRyaWJ1dGVWYWx1ZSA9IGtvLmV4cHJlc3Npb25SZXdyaXRpbmcucHJlUHJvY2Vzc0JpbmRpbmdzKGRhdGFCaW5kS2V5VmFsdWVBcnJheSwgeyd2YWx1ZUFjY2Vzc29ycyc6dHJ1ZX0pO1xuXG4gICAgICAgIC8vIEZvciBubyBvYnZpb3VzIHJlYXNvbiwgT3BlcmEgZmFpbHMgdG8gZXZhbHVhdGUgcmV3cml0dGVuRGF0YUJpbmRBdHRyaWJ1dGVWYWx1ZSB1bmxlc3MgaXQncyB3cmFwcGVkIGluIGFuIGFkZGl0aW9uYWxcbiAgICAgICAgLy8gYW5vbnltb3VzIGZ1bmN0aW9uLCBldmVuIHRob3VnaCBPcGVyYSdzIGJ1aWx0LWluIGRlYnVnZ2VyIGNhbiBldmFsdWF0ZSBpdCBhbnl3YXkuIE5vIG90aGVyIGJyb3dzZXIgcmVxdWlyZXMgdGhpc1xuICAgICAgICAvLyBleHRyYSBpbmRpcmVjdGlvbi5cbiAgICAgICAgdmFyIGFwcGx5QmluZGluZ3NUb05leHRTaWJsaW5nU2NyaXB0ID1cbiAgICAgICAgICAgIFwia28uX190cl9hbWJ0bnMoZnVuY3Rpb24oJGNvbnRleHQsJGVsZW1lbnQpe3JldHVybihmdW5jdGlvbigpe3JldHVybnsgXCIgKyByZXdyaXR0ZW5EYXRhQmluZEF0dHJpYnV0ZVZhbHVlICsgXCIgfSB9KSgpfSwnXCIgKyBub2RlTmFtZS50b0xvd2VyQ2FzZSgpICsgXCInKVwiO1xuICAgICAgICByZXR1cm4gdGVtcGxhdGVFbmdpbmVbJ2NyZWF0ZUphdmFTY3JpcHRFdmFsdWF0b3JCbG9jayddKGFwcGx5QmluZGluZ3NUb05leHRTaWJsaW5nU2NyaXB0KSArIHRhZ1RvUmV0YWluO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICAgIGVuc3VyZVRlbXBsYXRlSXNSZXdyaXR0ZW46IGZ1bmN0aW9uICh0ZW1wbGF0ZSwgdGVtcGxhdGVFbmdpbmUsIHRlbXBsYXRlRG9jdW1lbnQpIHtcbiAgICAgICAgICAgIGlmICghdGVtcGxhdGVFbmdpbmVbJ2lzVGVtcGxhdGVSZXdyaXR0ZW4nXSh0ZW1wbGF0ZSwgdGVtcGxhdGVEb2N1bWVudCkpXG4gICAgICAgICAgICAgICAgdGVtcGxhdGVFbmdpbmVbJ3Jld3JpdGVUZW1wbGF0ZSddKHRlbXBsYXRlLCBmdW5jdGlvbiAoaHRtbFN0cmluZykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4ga28udGVtcGxhdGVSZXdyaXRpbmcubWVtb2l6ZUJpbmRpbmdBdHRyaWJ1dGVTeW50YXgoaHRtbFN0cmluZywgdGVtcGxhdGVFbmdpbmUpO1xuICAgICAgICAgICAgICAgIH0sIHRlbXBsYXRlRG9jdW1lbnQpO1xuICAgICAgICB9LFxuXG4gICAgICAgIG1lbW9pemVCaW5kaW5nQXR0cmlidXRlU3ludGF4OiBmdW5jdGlvbiAoaHRtbFN0cmluZywgdGVtcGxhdGVFbmdpbmUpIHtcbiAgICAgICAgICAgIHJldHVybiBodG1sU3RyaW5nLnJlcGxhY2UobWVtb2l6ZURhdGFCaW5kaW5nQXR0cmlidXRlU3ludGF4UmVnZXgsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29uc3RydWN0TWVtb2l6ZWRUYWdSZXBsYWNlbWVudCgvKiBkYXRhQmluZEF0dHJpYnV0ZVZhbHVlOiAqLyBhcmd1bWVudHNbNF0sIC8qIHRhZ1RvUmV0YWluOiAqLyBhcmd1bWVudHNbMV0sIC8qIG5vZGVOYW1lOiAqLyBhcmd1bWVudHNbMl0sIHRlbXBsYXRlRW5naW5lKTtcbiAgICAgICAgICAgIH0pLnJlcGxhY2UobWVtb2l6ZVZpcnR1YWxDb250YWluZXJCaW5kaW5nU3ludGF4UmVnZXgsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjb25zdHJ1Y3RNZW1vaXplZFRhZ1JlcGxhY2VtZW50KC8qIGRhdGFCaW5kQXR0cmlidXRlVmFsdWU6ICovIGFyZ3VtZW50c1sxXSwgLyogdGFnVG9SZXRhaW46ICovIFwiPCEtLSBrbyAtLT5cIiwgLyogbm9kZU5hbWU6ICovIFwiI2NvbW1lbnRcIiwgdGVtcGxhdGVFbmdpbmUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgYXBwbHlNZW1vaXplZEJpbmRpbmdzVG9OZXh0U2libGluZzogZnVuY3Rpb24gKGJpbmRpbmdzLCBub2RlTmFtZSkge1xuICAgICAgICAgICAgcmV0dXJuIGtvLm1lbW9pemF0aW9uLm1lbW9pemUoZnVuY3Rpb24gKGRvbU5vZGUsIGJpbmRpbmdDb250ZXh0KSB7XG4gICAgICAgICAgICAgICAgdmFyIG5vZGVUb0JpbmQgPSBkb21Ob2RlLm5leHRTaWJsaW5nO1xuICAgICAgICAgICAgICAgIGlmIChub2RlVG9CaW5kICYmIG5vZGVUb0JpbmQubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gbm9kZU5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAga28uYXBwbHlCaW5kaW5nQWNjZXNzb3JzVG9Ob2RlKG5vZGVUb0JpbmQsIGJpbmRpbmdzLCBiaW5kaW5nQ29udGV4dCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG59KSgpO1xuXG5cbi8vIEV4cG9ydGVkIG9ubHkgYmVjYXVzZSBpdCBoYXMgdG8gYmUgcmVmZXJlbmNlZCBieSBzdHJpbmcgbG9va3VwIGZyb20gd2l0aGluIHJld3JpdHRlbiB0ZW1wbGF0ZVxua28uZXhwb3J0U3ltYm9sKCdfX3RyX2FtYnRucycsIGtvLnRlbXBsYXRlUmV3cml0aW5nLmFwcGx5TWVtb2l6ZWRCaW5kaW5nc1RvTmV4dFNpYmxpbmcpO1xuKGZ1bmN0aW9uKCkge1xuICAgIC8vIEEgdGVtcGxhdGUgc291cmNlIHJlcHJlc2VudHMgYSByZWFkL3dyaXRlIHdheSBvZiBhY2Nlc3NpbmcgYSB0ZW1wbGF0ZS4gVGhpcyBpcyB0byBlbGltaW5hdGUgdGhlIG5lZWQgZm9yIHRlbXBsYXRlIGxvYWRpbmcvc2F2aW5nXG4gICAgLy8gbG9naWMgdG8gYmUgZHVwbGljYXRlZCBpbiBldmVyeSB0ZW1wbGF0ZSBlbmdpbmUgKGFuZCBtZWFucyB0aGV5IGNhbiBhbGwgd29yayB3aXRoIGFub255bW91cyB0ZW1wbGF0ZXMsIGV0Yy4pXG4gICAgLy9cbiAgICAvLyBUd28gYXJlIHByb3ZpZGVkIGJ5IGRlZmF1bHQ6XG4gICAgLy8gIDEuIGtvLnRlbXBsYXRlU291cmNlcy5kb21FbGVtZW50ICAgICAgIC0gcmVhZHMvd3JpdGVzIHRoZSB0ZXh0IGNvbnRlbnQgb2YgYW4gYXJiaXRyYXJ5IERPTSBlbGVtZW50XG4gICAgLy8gIDIuIGtvLnRlbXBsYXRlU291cmNlcy5hbm9ueW1vdXNFbGVtZW50IC0gdXNlcyBrby51dGlscy5kb21EYXRhIHRvIHJlYWQvd3JpdGUgdGV4dCAqYXNzb2NpYXRlZCogd2l0aCB0aGUgRE9NIGVsZW1lbnQsIGJ1dFxuICAgIC8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpdGhvdXQgcmVhZGluZy93cml0aW5nIHRoZSBhY3R1YWwgZWxlbWVudCB0ZXh0IGNvbnRlbnQsIHNpbmNlIGl0IHdpbGwgYmUgb3ZlcndyaXR0ZW5cbiAgICAvLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aXRoIHRoZSByZW5kZXJlZCB0ZW1wbGF0ZSBvdXRwdXQuXG4gICAgLy8gWW91IGNhbiBpbXBsZW1lbnQgeW91ciBvd24gdGVtcGxhdGUgc291cmNlIGlmIHlvdSB3YW50IHRvIGZldGNoL3N0b3JlIHRlbXBsYXRlcyBzb21ld2hlcmUgb3RoZXIgdGhhbiBpbiBET00gZWxlbWVudHMuXG4gICAgLy8gVGVtcGxhdGUgc291cmNlcyBuZWVkIHRvIGhhdmUgdGhlIGZvbGxvd2luZyBmdW5jdGlvbnM6XG4gICAgLy8gICB0ZXh0KCkgXHRcdFx0LSByZXR1cm5zIHRoZSB0ZW1wbGF0ZSB0ZXh0IGZyb20geW91ciBzdG9yYWdlIGxvY2F0aW9uXG4gICAgLy8gICB0ZXh0KHZhbHVlKVx0XHQtIHdyaXRlcyB0aGUgc3VwcGxpZWQgdGVtcGxhdGUgdGV4dCB0byB5b3VyIHN0b3JhZ2UgbG9jYXRpb25cbiAgICAvLyAgIGRhdGEoa2V5KVx0XHRcdC0gcmVhZHMgdmFsdWVzIHN0b3JlZCB1c2luZyBkYXRhKGtleSwgdmFsdWUpIC0gc2VlIGJlbG93XG4gICAgLy8gICBkYXRhKGtleSwgdmFsdWUpXHQtIGFzc29jaWF0ZXMgXCJ2YWx1ZVwiIHdpdGggdGhpcyB0ZW1wbGF0ZSBhbmQgdGhlIGtleSBcImtleVwiLiBJcyB1c2VkIHRvIHN0b3JlIGluZm9ybWF0aW9uIGxpa2UgXCJpc1Jld3JpdHRlblwiLlxuICAgIC8vXG4gICAgLy8gT3B0aW9uYWxseSwgdGVtcGxhdGUgc291cmNlcyBjYW4gYWxzbyBoYXZlIHRoZSBmb2xsb3dpbmcgZnVuY3Rpb25zOlxuICAgIC8vICAgbm9kZXMoKSAgICAgICAgICAgIC0gcmV0dXJucyBhIERPTSBlbGVtZW50IGNvbnRhaW5pbmcgdGhlIG5vZGVzIG9mIHRoaXMgdGVtcGxhdGUsIHdoZXJlIGF2YWlsYWJsZVxuICAgIC8vICAgbm9kZXModmFsdWUpICAgICAgIC0gd3JpdGVzIHRoZSBnaXZlbiBET00gZWxlbWVudCB0byB5b3VyIHN0b3JhZ2UgbG9jYXRpb25cbiAgICAvLyBJZiBhIERPTSBlbGVtZW50IGlzIGF2YWlsYWJsZSBmb3IgYSBnaXZlbiB0ZW1wbGF0ZSBzb3VyY2UsIHRlbXBsYXRlIGVuZ2luZXMgYXJlIGVuY291cmFnZWQgdG8gdXNlIGl0IGluIHByZWZlcmVuY2Ugb3ZlciB0ZXh0KClcbiAgICAvLyBmb3IgaW1wcm92ZWQgc3BlZWQuIEhvd2V2ZXIsIGFsbCB0ZW1wbGF0ZVNvdXJjZXMgbXVzdCBzdXBwbHkgdGV4dCgpIGV2ZW4gaWYgdGhleSBkb24ndCBzdXBwbHkgbm9kZXMoKS5cbiAgICAvL1xuICAgIC8vIE9uY2UgeW91J3ZlIGltcGxlbWVudGVkIGEgdGVtcGxhdGVTb3VyY2UsIG1ha2UgeW91ciB0ZW1wbGF0ZSBlbmdpbmUgdXNlIGl0IGJ5IHN1YmNsYXNzaW5nIHdoYXRldmVyIHRlbXBsYXRlIGVuZ2luZSB5b3Ugd2VyZVxuICAgIC8vIHVzaW5nIGFuZCBvdmVycmlkaW5nIFwibWFrZVRlbXBsYXRlU291cmNlXCIgdG8gcmV0dXJuIGFuIGluc3RhbmNlIG9mIHlvdXIgY3VzdG9tIHRlbXBsYXRlIHNvdXJjZS5cblxuICAgIGtvLnRlbXBsYXRlU291cmNlcyA9IHt9O1xuXG4gICAgLy8gLS0tLSBrby50ZW1wbGF0ZVNvdXJjZXMuZG9tRWxlbWVudCAtLS0tLVxuXG4gICAgLy8gdGVtcGxhdGUgdHlwZXNcbiAgICB2YXIgdGVtcGxhdGVTY3JpcHQgPSAxLFxuICAgICAgICB0ZW1wbGF0ZVRleHRBcmVhID0gMixcbiAgICAgICAgdGVtcGxhdGVUZW1wbGF0ZSA9IDMsXG4gICAgICAgIHRlbXBsYXRlRWxlbWVudCA9IDQ7XG5cbiAgICBrby50ZW1wbGF0ZVNvdXJjZXMuZG9tRWxlbWVudCA9IGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgICAgICAgdGhpcy5kb21FbGVtZW50ID0gZWxlbWVudDtcblxuICAgICAgICBpZiAoZWxlbWVudCkge1xuICAgICAgICAgICAgdmFyIHRhZ05hbWVMb3dlciA9IGtvLnV0aWxzLnRhZ05hbWVMb3dlcihlbGVtZW50KTtcbiAgICAgICAgICAgIHRoaXMudGVtcGxhdGVUeXBlID1cbiAgICAgICAgICAgICAgICB0YWdOYW1lTG93ZXIgPT09IFwic2NyaXB0XCIgPyB0ZW1wbGF0ZVNjcmlwdCA6XG4gICAgICAgICAgICAgICAgdGFnTmFtZUxvd2VyID09PSBcInRleHRhcmVhXCIgPyB0ZW1wbGF0ZVRleHRBcmVhIDpcbiAgICAgICAgICAgICAgICAgICAgLy8gRm9yIGJyb3dzZXJzIHdpdGggcHJvcGVyIDx0ZW1wbGF0ZT4gZWxlbWVudCBzdXBwb3J0LCB3aGVyZSB0aGUgLmNvbnRlbnQgcHJvcGVydHkgZ2l2ZXMgYSBkb2N1bWVudCBmcmFnbWVudFxuICAgICAgICAgICAgICAgIHRhZ05hbWVMb3dlciA9PSBcInRlbXBsYXRlXCIgJiYgZWxlbWVudC5jb250ZW50ICYmIGVsZW1lbnQuY29udGVudC5ub2RlVHlwZSA9PT0gMTEgPyB0ZW1wbGF0ZVRlbXBsYXRlIDpcbiAgICAgICAgICAgICAgICB0ZW1wbGF0ZUVsZW1lbnQ7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBrby50ZW1wbGF0ZVNvdXJjZXMuZG9tRWxlbWVudC5wcm90b3R5cGVbJ3RleHQnXSA9IGZ1bmN0aW9uKC8qIHZhbHVlVG9Xcml0ZSAqLykge1xuICAgICAgICB2YXIgZWxlbUNvbnRlbnRzUHJvcGVydHkgPSB0aGlzLnRlbXBsYXRlVHlwZSA9PT0gdGVtcGxhdGVTY3JpcHQgPyBcInRleHRcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiB0aGlzLnRlbXBsYXRlVHlwZSA9PT0gdGVtcGxhdGVUZXh0QXJlYSA/IFwidmFsdWVcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBcImlubmVySFRNTFwiO1xuXG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09IDApIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRvbUVsZW1lbnRbZWxlbUNvbnRlbnRzUHJvcGVydHldO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIHZhbHVlVG9Xcml0ZSA9IGFyZ3VtZW50c1swXTtcbiAgICAgICAgICAgIGlmIChlbGVtQ29udGVudHNQcm9wZXJ0eSA9PT0gXCJpbm5lckhUTUxcIilcbiAgICAgICAgICAgICAgICBrby51dGlscy5zZXRIdG1sKHRoaXMuZG9tRWxlbWVudCwgdmFsdWVUb1dyaXRlKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICB0aGlzLmRvbUVsZW1lbnRbZWxlbUNvbnRlbnRzUHJvcGVydHldID0gdmFsdWVUb1dyaXRlO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHZhciBkYXRhRG9tRGF0YVByZWZpeCA9IGtvLnV0aWxzLmRvbURhdGEubmV4dEtleSgpICsgXCJfXCI7XG4gICAga28udGVtcGxhdGVTb3VyY2VzLmRvbUVsZW1lbnQucHJvdG90eXBlWydkYXRhJ10gPSBmdW5jdGlvbihrZXkgLyosIHZhbHVlVG9Xcml0ZSAqLykge1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgcmV0dXJuIGtvLnV0aWxzLmRvbURhdGEuZ2V0KHRoaXMuZG9tRWxlbWVudCwgZGF0YURvbURhdGFQcmVmaXggKyBrZXkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAga28udXRpbHMuZG9tRGF0YS5zZXQodGhpcy5kb21FbGVtZW50LCBkYXRhRG9tRGF0YVByZWZpeCArIGtleSwgYXJndW1lbnRzWzFdKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgdGVtcGxhdGVzRG9tRGF0YUtleSA9IGtvLnV0aWxzLmRvbURhdGEubmV4dEtleSgpO1xuICAgIGZ1bmN0aW9uIGdldFRlbXBsYXRlRG9tRGF0YShlbGVtZW50KSB7XG4gICAgICAgIHJldHVybiBrby51dGlscy5kb21EYXRhLmdldChlbGVtZW50LCB0ZW1wbGF0ZXNEb21EYXRhS2V5KSB8fCB7fTtcbiAgICB9XG4gICAgZnVuY3Rpb24gc2V0VGVtcGxhdGVEb21EYXRhKGVsZW1lbnQsIGRhdGEpIHtcbiAgICAgICAga28udXRpbHMuZG9tRGF0YS5zZXQoZWxlbWVudCwgdGVtcGxhdGVzRG9tRGF0YUtleSwgZGF0YSk7XG4gICAgfVxuXG4gICAga28udGVtcGxhdGVTb3VyY2VzLmRvbUVsZW1lbnQucHJvdG90eXBlWydub2RlcyddID0gZnVuY3Rpb24oLyogdmFsdWVUb1dyaXRlICovKSB7XG4gICAgICAgIHZhciBlbGVtZW50ID0gdGhpcy5kb21FbGVtZW50O1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgICAgICB2YXIgdGVtcGxhdGVEYXRhID0gZ2V0VGVtcGxhdGVEb21EYXRhKGVsZW1lbnQpLFxuICAgICAgICAgICAgICAgIGNvbnRhaW5lckRhdGEgPSB0ZW1wbGF0ZURhdGEuY29udGFpbmVyRGF0YTtcbiAgICAgICAgICAgIHJldHVybiBjb250YWluZXJEYXRhIHx8IChcbiAgICAgICAgICAgICAgICB0aGlzLnRlbXBsYXRlVHlwZSA9PT0gdGVtcGxhdGVUZW1wbGF0ZSA/IGVsZW1lbnQuY29udGVudCA6XG4gICAgICAgICAgICAgICAgdGhpcy50ZW1wbGF0ZVR5cGUgPT09IHRlbXBsYXRlRWxlbWVudCA/IGVsZW1lbnQgOlxuICAgICAgICAgICAgICAgIHVuZGVmaW5lZCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgdmFsdWVUb1dyaXRlID0gYXJndW1lbnRzWzBdO1xuICAgICAgICAgICAgc2V0VGVtcGxhdGVEb21EYXRhKGVsZW1lbnQsIHtjb250YWluZXJEYXRhOiB2YWx1ZVRvV3JpdGV9KTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvLyAtLS0tIGtvLnRlbXBsYXRlU291cmNlcy5hbm9ueW1vdXNUZW1wbGF0ZSAtLS0tLVxuICAgIC8vIEFub255bW91cyB0ZW1wbGF0ZXMgYXJlIG5vcm1hbGx5IHNhdmVkL3JldHJpZXZlZCBhcyBET00gbm9kZXMgdGhyb3VnaCBcIm5vZGVzXCIuXG4gICAgLy8gRm9yIGNvbXBhdGliaWxpdHksIHlvdSBjYW4gYWxzbyByZWFkIFwidGV4dFwiOyBpdCB3aWxsIGJlIHNlcmlhbGl6ZWQgZnJvbSB0aGUgbm9kZXMgb24gZGVtYW5kLlxuICAgIC8vIFdyaXRpbmcgdG8gXCJ0ZXh0XCIgaXMgc3RpbGwgc3VwcG9ydGVkLCBidXQgdGhlbiB0aGUgdGVtcGxhdGUgZGF0YSB3aWxsIG5vdCBiZSBhdmFpbGFibGUgYXMgRE9NIG5vZGVzLlxuXG4gICAga28udGVtcGxhdGVTb3VyY2VzLmFub255bW91c1RlbXBsYXRlID0gZnVuY3Rpb24oZWxlbWVudCkge1xuICAgICAgICB0aGlzLmRvbUVsZW1lbnQgPSBlbGVtZW50O1xuICAgIH1cbiAgICBrby50ZW1wbGF0ZVNvdXJjZXMuYW5vbnltb3VzVGVtcGxhdGUucHJvdG90eXBlID0gbmV3IGtvLnRlbXBsYXRlU291cmNlcy5kb21FbGVtZW50KCk7XG4gICAga28udGVtcGxhdGVTb3VyY2VzLmFub255bW91c1RlbXBsYXRlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IGtvLnRlbXBsYXRlU291cmNlcy5hbm9ueW1vdXNUZW1wbGF0ZTtcbiAgICBrby50ZW1wbGF0ZVNvdXJjZXMuYW5vbnltb3VzVGVtcGxhdGUucHJvdG90eXBlWyd0ZXh0J10gPSBmdW5jdGlvbigvKiB2YWx1ZVRvV3JpdGUgKi8pIHtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT0gMCkge1xuICAgICAgICAgICAgdmFyIHRlbXBsYXRlRGF0YSA9IGdldFRlbXBsYXRlRG9tRGF0YSh0aGlzLmRvbUVsZW1lbnQpO1xuICAgICAgICAgICAgaWYgKHRlbXBsYXRlRGF0YS50ZXh0RGF0YSA9PT0gdW5kZWZpbmVkICYmIHRlbXBsYXRlRGF0YS5jb250YWluZXJEYXRhKVxuICAgICAgICAgICAgICAgIHRlbXBsYXRlRGF0YS50ZXh0RGF0YSA9IHRlbXBsYXRlRGF0YS5jb250YWluZXJEYXRhLmlubmVySFRNTDtcbiAgICAgICAgICAgIHJldHVybiB0ZW1wbGF0ZURhdGEudGV4dERhdGE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgdmFsdWVUb1dyaXRlID0gYXJndW1lbnRzWzBdO1xuICAgICAgICAgICAgc2V0VGVtcGxhdGVEb21EYXRhKHRoaXMuZG9tRWxlbWVudCwge3RleHREYXRhOiB2YWx1ZVRvV3JpdGV9KTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBrby5leHBvcnRTeW1ib2woJ3RlbXBsYXRlU291cmNlcycsIGtvLnRlbXBsYXRlU291cmNlcyk7XG4gICAga28uZXhwb3J0U3ltYm9sKCd0ZW1wbGF0ZVNvdXJjZXMuZG9tRWxlbWVudCcsIGtvLnRlbXBsYXRlU291cmNlcy5kb21FbGVtZW50KTtcbiAgICBrby5leHBvcnRTeW1ib2woJ3RlbXBsYXRlU291cmNlcy5hbm9ueW1vdXNUZW1wbGF0ZScsIGtvLnRlbXBsYXRlU291cmNlcy5hbm9ueW1vdXNUZW1wbGF0ZSk7XG59KSgpO1xuKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgX3RlbXBsYXRlRW5naW5lO1xuICAgIGtvLnNldFRlbXBsYXRlRW5naW5lID0gZnVuY3Rpb24gKHRlbXBsYXRlRW5naW5lKSB7XG4gICAgICAgIGlmICgodGVtcGxhdGVFbmdpbmUgIT0gdW5kZWZpbmVkKSAmJiAhKHRlbXBsYXRlRW5naW5lIGluc3RhbmNlb2Yga28udGVtcGxhdGVFbmdpbmUpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwidGVtcGxhdGVFbmdpbmUgbXVzdCBpbmhlcml0IGZyb20ga28udGVtcGxhdGVFbmdpbmVcIik7XG4gICAgICAgIF90ZW1wbGF0ZUVuZ2luZSA9IHRlbXBsYXRlRW5naW5lO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGludm9rZUZvckVhY2hOb2RlSW5Db250aW51b3VzUmFuZ2UoZmlyc3ROb2RlLCBsYXN0Tm9kZSwgYWN0aW9uKSB7XG4gICAgICAgIHZhciBub2RlLCBuZXh0SW5RdWV1ZSA9IGZpcnN0Tm9kZSwgZmlyc3RPdXRPZlJhbmdlTm9kZSA9IGtvLnZpcnR1YWxFbGVtZW50cy5uZXh0U2libGluZyhsYXN0Tm9kZSk7XG4gICAgICAgIHdoaWxlIChuZXh0SW5RdWV1ZSAmJiAoKG5vZGUgPSBuZXh0SW5RdWV1ZSkgIT09IGZpcnN0T3V0T2ZSYW5nZU5vZGUpKSB7XG4gICAgICAgICAgICBuZXh0SW5RdWV1ZSA9IGtvLnZpcnR1YWxFbGVtZW50cy5uZXh0U2libGluZyhub2RlKTtcbiAgICAgICAgICAgIGFjdGlvbihub2RlLCBuZXh0SW5RdWV1ZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhY3RpdmF0ZUJpbmRpbmdzT25Db250aW51b3VzTm9kZUFycmF5KGNvbnRpbnVvdXNOb2RlQXJyYXksIGJpbmRpbmdDb250ZXh0KSB7XG4gICAgICAgIC8vIFRvIGJlIHVzZWQgb24gYW55IG5vZGVzIHRoYXQgaGF2ZSBiZWVuIHJlbmRlcmVkIGJ5IGEgdGVtcGxhdGUgYW5kIGhhdmUgYmVlbiBpbnNlcnRlZCBpbnRvIHNvbWUgcGFyZW50IGVsZW1lbnRcbiAgICAgICAgLy8gV2Fsa3MgdGhyb3VnaCBjb250aW51b3VzTm9kZUFycmF5ICh3aGljaCAqbXVzdCogYmUgY29udGludW91cywgaS5lLiwgYW4gdW5pbnRlcnJ1cHRlZCBzZXF1ZW5jZSBvZiBzaWJsaW5nIG5vZGVzLCBiZWNhdXNlXG4gICAgICAgIC8vIHRoZSBhbGdvcml0aG0gZm9yIHdhbGtpbmcgdGhlbSByZWxpZXMgb24gdGhpcyksIGFuZCBmb3IgZWFjaCB0b3AtbGV2ZWwgaXRlbSBpbiB0aGUgdmlydHVhbC1lbGVtZW50IHNlbnNlLFxuICAgICAgICAvLyAoMSkgRG9lcyBhIHJlZ3VsYXIgXCJhcHBseUJpbmRpbmdzXCIgdG8gYXNzb2NpYXRlIGJpbmRpbmdDb250ZXh0IHdpdGggdGhpcyBub2RlIGFuZCB0byBhY3RpdmF0ZSBhbnkgbm9uLW1lbW9pemVkIGJpbmRpbmdzXG4gICAgICAgIC8vICgyKSBVbm1lbW9pemVzIGFueSBtZW1vcyBpbiB0aGUgRE9NIHN1YnRyZWUgKGUuZy4sIHRvIGFjdGl2YXRlIGJpbmRpbmdzIHRoYXQgaGFkIGJlZW4gbWVtb2l6ZWQgZHVyaW5nIHRlbXBsYXRlIHJld3JpdGluZylcblxuICAgICAgICBpZiAoY29udGludW91c05vZGVBcnJheS5sZW5ndGgpIHtcbiAgICAgICAgICAgIHZhciBmaXJzdE5vZGUgPSBjb250aW51b3VzTm9kZUFycmF5WzBdLFxuICAgICAgICAgICAgICAgIGxhc3ROb2RlID0gY29udGludW91c05vZGVBcnJheVtjb250aW51b3VzTm9kZUFycmF5Lmxlbmd0aCAtIDFdLFxuICAgICAgICAgICAgICAgIHBhcmVudE5vZGUgPSBmaXJzdE5vZGUucGFyZW50Tm9kZSxcbiAgICAgICAgICAgICAgICBwcm92aWRlciA9IGtvLmJpbmRpbmdQcm92aWRlclsnaW5zdGFuY2UnXSxcbiAgICAgICAgICAgICAgICBwcmVwcm9jZXNzTm9kZSA9IHByb3ZpZGVyWydwcmVwcm9jZXNzTm9kZSddO1xuXG4gICAgICAgICAgICBpZiAocHJlcHJvY2Vzc05vZGUpIHtcbiAgICAgICAgICAgICAgICBpbnZva2VGb3JFYWNoTm9kZUluQ29udGludW91c1JhbmdlKGZpcnN0Tm9kZSwgbGFzdE5vZGUsIGZ1bmN0aW9uKG5vZGUsIG5leHROb2RlSW5SYW5nZSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbm9kZVByZXZpb3VzU2libGluZyA9IG5vZGUucHJldmlvdXNTaWJsaW5nO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbmV3Tm9kZXMgPSBwcmVwcm9jZXNzTm9kZS5jYWxsKHByb3ZpZGVyLCBub2RlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5ld05vZGVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobm9kZSA9PT0gZmlyc3ROb2RlKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpcnN0Tm9kZSA9IG5ld05vZGVzWzBdIHx8IG5leHROb2RlSW5SYW5nZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChub2RlID09PSBsYXN0Tm9kZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYXN0Tm9kZSA9IG5ld05vZGVzW25ld05vZGVzLmxlbmd0aCAtIDFdIHx8IG5vZGVQcmV2aW91c1NpYmxpbmc7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIC8vIEJlY2F1c2UgcHJlcHJvY2Vzc05vZGUgY2FuIGNoYW5nZSB0aGUgbm9kZXMsIGluY2x1ZGluZyB0aGUgZmlyc3QgYW5kIGxhc3Qgbm9kZXMsIHVwZGF0ZSBjb250aW51b3VzTm9kZUFycmF5IHRvIG1hdGNoLlxuICAgICAgICAgICAgICAgIC8vIFdlIG5lZWQgdGhlIGZ1bGwgc2V0LCBpbmNsdWRpbmcgaW5uZXIgbm9kZXMsIGJlY2F1c2UgdGhlIHVubWVtb2l6ZSBzdGVwIG1pZ2h0IHJlbW92ZSB0aGUgZmlyc3Qgbm9kZSAoYW5kIHNvIHRoZSByZWFsXG4gICAgICAgICAgICAgICAgLy8gZmlyc3Qgbm9kZSBuZWVkcyB0byBiZSBpbiB0aGUgYXJyYXkpLlxuICAgICAgICAgICAgICAgIGNvbnRpbnVvdXNOb2RlQXJyYXkubGVuZ3RoID0gMDtcbiAgICAgICAgICAgICAgICBpZiAoIWZpcnN0Tm9kZSkgeyAvLyBwcmVwcm9jZXNzTm9kZSBtaWdodCBoYXZlIHJlbW92ZWQgYWxsIHRoZSBub2RlcywgaW4gd2hpY2ggY2FzZSB0aGVyZSdzIG5vdGhpbmcgbGVmdCB0byBkb1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChmaXJzdE5vZGUgPT09IGxhc3ROb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVvdXNOb2RlQXJyYXkucHVzaChmaXJzdE5vZGUpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVvdXNOb2RlQXJyYXkucHVzaChmaXJzdE5vZGUsIGxhc3ROb2RlKTtcbiAgICAgICAgICAgICAgICAgICAga28udXRpbHMuZml4VXBDb250aW51b3VzTm9kZUFycmF5KGNvbnRpbnVvdXNOb2RlQXJyYXksIHBhcmVudE5vZGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gTmVlZCB0byBhcHBseUJpbmRpbmdzICpiZWZvcmUqIHVubWVtb3ppYXRpb24sIGJlY2F1c2UgdW5tZW1vaXphdGlvbiBtaWdodCBpbnRyb2R1Y2UgZXh0cmEgbm9kZXMgKHRoYXQgd2UgZG9uJ3Qgd2FudCB0byByZS1iaW5kKVxuICAgICAgICAgICAgLy8gd2hlcmVhcyBhIHJlZ3VsYXIgYXBwbHlCaW5kaW5ncyB3b24ndCBpbnRyb2R1Y2UgbmV3IG1lbW9pemVkIG5vZGVzXG4gICAgICAgICAgICBpbnZva2VGb3JFYWNoTm9kZUluQ29udGludW91c1JhbmdlKGZpcnN0Tm9kZSwgbGFzdE5vZGUsIGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgICAgICAgICAgICBpZiAobm9kZS5ub2RlVHlwZSA9PT0gMSB8fCBub2RlLm5vZGVUeXBlID09PSA4KVxuICAgICAgICAgICAgICAgICAgICBrby5hcHBseUJpbmRpbmdzKGJpbmRpbmdDb250ZXh0LCBub2RlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaW52b2tlRm9yRWFjaE5vZGVJbkNvbnRpbnVvdXNSYW5nZShmaXJzdE5vZGUsIGxhc3ROb2RlLCBmdW5jdGlvbihub2RlKSB7XG4gICAgICAgICAgICAgICAgaWYgKG5vZGUubm9kZVR5cGUgPT09IDEgfHwgbm9kZS5ub2RlVHlwZSA9PT0gOClcbiAgICAgICAgICAgICAgICAgICAga28ubWVtb2l6YXRpb24udW5tZW1vaXplRG9tTm9kZUFuZERlc2NlbmRhbnRzKG5vZGUsIFtiaW5kaW5nQ29udGV4dF0pO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSBhbnkgY2hhbmdlcyBkb25lIGJ5IGFwcGx5QmluZGluZ3Mgb3IgdW5tZW1vaXplIGFyZSByZWZsZWN0ZWQgaW4gdGhlIGFycmF5XG4gICAgICAgICAgICBrby51dGlscy5maXhVcENvbnRpbnVvdXNOb2RlQXJyYXkoY29udGludW91c05vZGVBcnJheSwgcGFyZW50Tm9kZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRGaXJzdE5vZGVGcm9tUG9zc2libGVBcnJheShub2RlT3JOb2RlQXJyYXkpIHtcbiAgICAgICAgcmV0dXJuIG5vZGVPck5vZGVBcnJheS5ub2RlVHlwZSA/IG5vZGVPck5vZGVBcnJheVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogbm9kZU9yTm9kZUFycmF5Lmxlbmd0aCA+IDAgPyBub2RlT3JOb2RlQXJyYXlbMF1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IG51bGw7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZXhlY3V0ZVRlbXBsYXRlKHRhcmdldE5vZGVPck5vZGVBcnJheSwgcmVuZGVyTW9kZSwgdGVtcGxhdGUsIGJpbmRpbmdDb250ZXh0LCBvcHRpb25zKSB7XG4gICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgICAgICB2YXIgZmlyc3RUYXJnZXROb2RlID0gdGFyZ2V0Tm9kZU9yTm9kZUFycmF5ICYmIGdldEZpcnN0Tm9kZUZyb21Qb3NzaWJsZUFycmF5KHRhcmdldE5vZGVPck5vZGVBcnJheSk7XG4gICAgICAgIHZhciB0ZW1wbGF0ZURvY3VtZW50ID0gKGZpcnN0VGFyZ2V0Tm9kZSB8fCB0ZW1wbGF0ZSB8fCB7fSkub3duZXJEb2N1bWVudDtcbiAgICAgICAgdmFyIHRlbXBsYXRlRW5naW5lVG9Vc2UgPSAob3B0aW9uc1sndGVtcGxhdGVFbmdpbmUnXSB8fCBfdGVtcGxhdGVFbmdpbmUpO1xuICAgICAgICBrby50ZW1wbGF0ZVJld3JpdGluZy5lbnN1cmVUZW1wbGF0ZUlzUmV3cml0dGVuKHRlbXBsYXRlLCB0ZW1wbGF0ZUVuZ2luZVRvVXNlLCB0ZW1wbGF0ZURvY3VtZW50KTtcbiAgICAgICAgdmFyIHJlbmRlcmVkTm9kZXNBcnJheSA9IHRlbXBsYXRlRW5naW5lVG9Vc2VbJ3JlbmRlclRlbXBsYXRlJ10odGVtcGxhdGUsIGJpbmRpbmdDb250ZXh0LCBvcHRpb25zLCB0ZW1wbGF0ZURvY3VtZW50KTtcblxuICAgICAgICAvLyBMb29zZWx5IGNoZWNrIHJlc3VsdCBpcyBhbiBhcnJheSBvZiBET00gbm9kZXNcbiAgICAgICAgaWYgKCh0eXBlb2YgcmVuZGVyZWROb2Rlc0FycmF5Lmxlbmd0aCAhPSBcIm51bWJlclwiKSB8fCAocmVuZGVyZWROb2Rlc0FycmF5Lmxlbmd0aCA+IDAgJiYgdHlwZW9mIHJlbmRlcmVkTm9kZXNBcnJheVswXS5ub2RlVHlwZSAhPSBcIm51bWJlclwiKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRlbXBsYXRlIGVuZ2luZSBtdXN0IHJldHVybiBhbiBhcnJheSBvZiBET00gbm9kZXNcIik7XG5cbiAgICAgICAgdmFyIGhhdmVBZGRlZE5vZGVzVG9QYXJlbnQgPSBmYWxzZTtcbiAgICAgICAgc3dpdGNoIChyZW5kZXJNb2RlKSB7XG4gICAgICAgICAgICBjYXNlIFwicmVwbGFjZUNoaWxkcmVuXCI6XG4gICAgICAgICAgICAgICAga28udmlydHVhbEVsZW1lbnRzLnNldERvbU5vZGVDaGlsZHJlbih0YXJnZXROb2RlT3JOb2RlQXJyYXksIHJlbmRlcmVkTm9kZXNBcnJheSk7XG4gICAgICAgICAgICAgICAgaGF2ZUFkZGVkTm9kZXNUb1BhcmVudCA9IHRydWU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwicmVwbGFjZU5vZGVcIjpcbiAgICAgICAgICAgICAgICBrby51dGlscy5yZXBsYWNlRG9tTm9kZXModGFyZ2V0Tm9kZU9yTm9kZUFycmF5LCByZW5kZXJlZE5vZGVzQXJyYXkpO1xuICAgICAgICAgICAgICAgIGhhdmVBZGRlZE5vZGVzVG9QYXJlbnQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcImlnbm9yZVRhcmdldE5vZGVcIjogYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gcmVuZGVyTW9kZTogXCIgKyByZW5kZXJNb2RlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChoYXZlQWRkZWROb2Rlc1RvUGFyZW50KSB7XG4gICAgICAgICAgICBhY3RpdmF0ZUJpbmRpbmdzT25Db250aW51b3VzTm9kZUFycmF5KHJlbmRlcmVkTm9kZXNBcnJheSwgYmluZGluZ0NvbnRleHQpO1xuICAgICAgICAgICAgaWYgKG9wdGlvbnNbJ2FmdGVyUmVuZGVyJ10pXG4gICAgICAgICAgICAgICAga28uZGVwZW5kZW5jeURldGVjdGlvbi5pZ25vcmUob3B0aW9uc1snYWZ0ZXJSZW5kZXInXSwgbnVsbCwgW3JlbmRlcmVkTm9kZXNBcnJheSwgYmluZGluZ0NvbnRleHRbJyRkYXRhJ11dKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZW5kZXJlZE5vZGVzQXJyYXk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVzb2x2ZVRlbXBsYXRlTmFtZSh0ZW1wbGF0ZSwgZGF0YSwgY29udGV4dCkge1xuICAgICAgICAvLyBUaGUgdGVtcGxhdGUgY2FuIGJlIHNwZWNpZmllZCBhczpcbiAgICAgICAgaWYgKGtvLmlzT2JzZXJ2YWJsZSh0ZW1wbGF0ZSkpIHtcbiAgICAgICAgICAgIC8vIDEuIEFuIG9ic2VydmFibGUsIHdpdGggc3RyaW5nIHZhbHVlXG4gICAgICAgICAgICByZXR1cm4gdGVtcGxhdGUoKTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdGVtcGxhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIC8vIDIuIEEgZnVuY3Rpb24gb2YgKGRhdGEsIGNvbnRleHQpIHJldHVybmluZyBhIHN0cmluZ1xuICAgICAgICAgICAgcmV0dXJuIHRlbXBsYXRlKGRhdGEsIGNvbnRleHQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gMy4gQSBzdHJpbmdcbiAgICAgICAgICAgIHJldHVybiB0ZW1wbGF0ZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGtvLnJlbmRlclRlbXBsYXRlID0gZnVuY3Rpb24gKHRlbXBsYXRlLCBkYXRhT3JCaW5kaW5nQ29udGV4dCwgb3B0aW9ucywgdGFyZ2V0Tm9kZU9yTm9kZUFycmF5LCByZW5kZXJNb2RlKSB7XG4gICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgICAgICBpZiAoKG9wdGlvbnNbJ3RlbXBsYXRlRW5naW5lJ10gfHwgX3RlbXBsYXRlRW5naW5lKSA9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTZXQgYSB0ZW1wbGF0ZSBlbmdpbmUgYmVmb3JlIGNhbGxpbmcgcmVuZGVyVGVtcGxhdGVcIik7XG4gICAgICAgIHJlbmRlck1vZGUgPSByZW5kZXJNb2RlIHx8IFwicmVwbGFjZUNoaWxkcmVuXCI7XG5cbiAgICAgICAgaWYgKHRhcmdldE5vZGVPck5vZGVBcnJheSkge1xuICAgICAgICAgICAgdmFyIGZpcnN0VGFyZ2V0Tm9kZSA9IGdldEZpcnN0Tm9kZUZyb21Qb3NzaWJsZUFycmF5KHRhcmdldE5vZGVPck5vZGVBcnJheSk7XG5cbiAgICAgICAgICAgIHZhciB3aGVuVG9EaXNwb3NlID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gKCFmaXJzdFRhcmdldE5vZGUpIHx8ICFrby51dGlscy5kb21Ob2RlSXNBdHRhY2hlZFRvRG9jdW1lbnQoZmlyc3RUYXJnZXROb2RlKTsgfTsgLy8gUGFzc2l2ZSBkaXNwb3NhbCAob24gbmV4dCBldmFsdWF0aW9uKVxuICAgICAgICAgICAgdmFyIGFjdGl2ZWx5RGlzcG9zZVdoZW5Ob2RlSXNSZW1vdmVkID0gKGZpcnN0VGFyZ2V0Tm9kZSAmJiByZW5kZXJNb2RlID09IFwicmVwbGFjZU5vZGVcIikgPyBmaXJzdFRhcmdldE5vZGUucGFyZW50Tm9kZSA6IGZpcnN0VGFyZ2V0Tm9kZTtcblxuICAgICAgICAgICAgcmV0dXJuIGtvLmRlcGVuZGVudE9ic2VydmFibGUoIC8vIFNvIHRoZSBET00gaXMgYXV0b21hdGljYWxseSB1cGRhdGVkIHdoZW4gYW55IGRlcGVuZGVuY3kgY2hhbmdlc1xuICAgICAgICAgICAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gRW5zdXJlIHdlJ3ZlIGdvdCBhIHByb3BlciBiaW5kaW5nIGNvbnRleHQgdG8gd29yayB3aXRoXG4gICAgICAgICAgICAgICAgICAgIHZhciBiaW5kaW5nQ29udGV4dCA9IChkYXRhT3JCaW5kaW5nQ29udGV4dCAmJiAoZGF0YU9yQmluZGluZ0NvbnRleHQgaW5zdGFuY2VvZiBrby5iaW5kaW5nQ29udGV4dCkpXG4gICAgICAgICAgICAgICAgICAgICAgICA/IGRhdGFPckJpbmRpbmdDb250ZXh0XG4gICAgICAgICAgICAgICAgICAgICAgICA6IG5ldyBrby5iaW5kaW5nQ29udGV4dChkYXRhT3JCaW5kaW5nQ29udGV4dCwgbnVsbCwgbnVsbCwgbnVsbCwgeyBcImV4cG9ydERlcGVuZGVuY2llc1wiOiB0cnVlIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgIHZhciB0ZW1wbGF0ZU5hbWUgPSByZXNvbHZlVGVtcGxhdGVOYW1lKHRlbXBsYXRlLCBiaW5kaW5nQ29udGV4dFsnJGRhdGEnXSwgYmluZGluZ0NvbnRleHQpLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVuZGVyZWROb2Rlc0FycmF5ID0gZXhlY3V0ZVRlbXBsYXRlKHRhcmdldE5vZGVPck5vZGVBcnJheSwgcmVuZGVyTW9kZSwgdGVtcGxhdGVOYW1lLCBiaW5kaW5nQ29udGV4dCwgb3B0aW9ucyk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlbmRlck1vZGUgPT0gXCJyZXBsYWNlTm9kZVwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXROb2RlT3JOb2RlQXJyYXkgPSByZW5kZXJlZE5vZGVzQXJyYXk7XG4gICAgICAgICAgICAgICAgICAgICAgICBmaXJzdFRhcmdldE5vZGUgPSBnZXRGaXJzdE5vZGVGcm9tUG9zc2libGVBcnJheSh0YXJnZXROb2RlT3JOb2RlQXJyYXkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgICAgIHsgZGlzcG9zZVdoZW46IHdoZW5Ub0Rpc3Bvc2UsIGRpc3Bvc2VXaGVuTm9kZUlzUmVtb3ZlZDogYWN0aXZlbHlEaXNwb3NlV2hlbk5vZGVJc1JlbW92ZWQgfVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIFdlIGRvbid0IHlldCBoYXZlIGEgRE9NIG5vZGUgdG8gZXZhbHVhdGUsIHNvIHVzZSBhIG1lbW8gYW5kIHJlbmRlciB0aGUgdGVtcGxhdGUgbGF0ZXIgd2hlbiB0aGVyZSBpcyBhIERPTSBub2RlXG4gICAgICAgICAgICByZXR1cm4ga28ubWVtb2l6YXRpb24ubWVtb2l6ZShmdW5jdGlvbiAoZG9tTm9kZSkge1xuICAgICAgICAgICAgICAgIGtvLnJlbmRlclRlbXBsYXRlKHRlbXBsYXRlLCBkYXRhT3JCaW5kaW5nQ29udGV4dCwgb3B0aW9ucywgZG9tTm9kZSwgXCJyZXBsYWNlTm9kZVwiKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIGtvLnJlbmRlclRlbXBsYXRlRm9yRWFjaCA9IGZ1bmN0aW9uICh0ZW1wbGF0ZSwgYXJyYXlPck9ic2VydmFibGVBcnJheSwgb3B0aW9ucywgdGFyZ2V0Tm9kZSwgcGFyZW50QmluZGluZ0NvbnRleHQpIHtcbiAgICAgICAgLy8gU2luY2Ugc2V0RG9tTm9kZUNoaWxkcmVuRnJvbUFycmF5TWFwcGluZyBhbHdheXMgY2FsbHMgZXhlY3V0ZVRlbXBsYXRlRm9yQXJyYXlJdGVtIGFuZCB0aGVuXG4gICAgICAgIC8vIGFjdGl2YXRlQmluZGluZ3NDYWxsYmFjayBmb3IgYWRkZWQgaXRlbXMsIHdlIGNhbiBzdG9yZSB0aGUgYmluZGluZyBjb250ZXh0IGluIHRoZSBmb3JtZXIgdG8gdXNlIGluIHRoZSBsYXR0ZXIuXG4gICAgICAgIHZhciBhcnJheUl0ZW1Db250ZXh0O1xuXG4gICAgICAgIC8vIFRoaXMgd2lsbCBiZSBjYWxsZWQgYnkgc2V0RG9tTm9kZUNoaWxkcmVuRnJvbUFycmF5TWFwcGluZyB0byBnZXQgdGhlIG5vZGVzIHRvIGFkZCB0byB0YXJnZXROb2RlXG4gICAgICAgIHZhciBleGVjdXRlVGVtcGxhdGVGb3JBcnJheUl0ZW0gPSBmdW5jdGlvbiAoYXJyYXlWYWx1ZSwgaW5kZXgpIHtcbiAgICAgICAgICAgIC8vIFN1cHBvcnQgc2VsZWN0aW5nIHRlbXBsYXRlIGFzIGEgZnVuY3Rpb24gb2YgdGhlIGRhdGEgYmVpbmcgcmVuZGVyZWRcbiAgICAgICAgICAgIGFycmF5SXRlbUNvbnRleHQgPSBwYXJlbnRCaW5kaW5nQ29udGV4dFsnY3JlYXRlQ2hpbGRDb250ZXh0J10oYXJyYXlWYWx1ZSwgb3B0aW9uc1snYXMnXSwgZnVuY3Rpb24oY29udGV4dCkge1xuICAgICAgICAgICAgICAgIGNvbnRleHRbJyRpbmRleCddID0gaW5kZXg7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgdmFyIHRlbXBsYXRlTmFtZSA9IHJlc29sdmVUZW1wbGF0ZU5hbWUodGVtcGxhdGUsIGFycmF5VmFsdWUsIGFycmF5SXRlbUNvbnRleHQpO1xuICAgICAgICAgICAgcmV0dXJuIGV4ZWN1dGVUZW1wbGF0ZShudWxsLCBcImlnbm9yZVRhcmdldE5vZGVcIiwgdGVtcGxhdGVOYW1lLCBhcnJheUl0ZW1Db250ZXh0LCBvcHRpb25zKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRoaXMgd2lsbCBiZSBjYWxsZWQgd2hlbmV2ZXIgc2V0RG9tTm9kZUNoaWxkcmVuRnJvbUFycmF5TWFwcGluZyBoYXMgYWRkZWQgbm9kZXMgdG8gdGFyZ2V0Tm9kZVxuICAgICAgICB2YXIgYWN0aXZhdGVCaW5kaW5nc0NhbGxiYWNrID0gZnVuY3Rpb24oYXJyYXlWYWx1ZSwgYWRkZWROb2Rlc0FycmF5LCBpbmRleCkge1xuICAgICAgICAgICAgYWN0aXZhdGVCaW5kaW5nc09uQ29udGludW91c05vZGVBcnJheShhZGRlZE5vZGVzQXJyYXksIGFycmF5SXRlbUNvbnRleHQpO1xuICAgICAgICAgICAgaWYgKG9wdGlvbnNbJ2FmdGVyUmVuZGVyJ10pXG4gICAgICAgICAgICAgICAgb3B0aW9uc1snYWZ0ZXJSZW5kZXInXShhZGRlZE5vZGVzQXJyYXksIGFycmF5VmFsdWUpO1xuXG4gICAgICAgICAgICAvLyByZWxlYXNlIHRoZSBcImNhY2hlXCIgdmFyaWFibGUsIHNvIHRoYXQgaXQgY2FuIGJlIGNvbGxlY3RlZCBieVxuICAgICAgICAgICAgLy8gdGhlIEdDIHdoZW4gaXRzIHZhbHVlIGlzbid0IHVzZWQgZnJvbSB3aXRoaW4gdGhlIGJpbmRpbmdzIGFueW1vcmUuXG4gICAgICAgICAgICBhcnJheUl0ZW1Db250ZXh0ID0gbnVsbDtcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4ga28uZGVwZW5kZW50T2JzZXJ2YWJsZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgdW53cmFwcGVkQXJyYXkgPSBrby51dGlscy51bndyYXBPYnNlcnZhYmxlKGFycmF5T3JPYnNlcnZhYmxlQXJyYXkpIHx8IFtdO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB1bndyYXBwZWRBcnJheS5sZW5ndGggPT0gXCJ1bmRlZmluZWRcIikgLy8gQ29lcmNlIHNpbmdsZSB2YWx1ZSBpbnRvIGFycmF5XG4gICAgICAgICAgICAgICAgdW53cmFwcGVkQXJyYXkgPSBbdW53cmFwcGVkQXJyYXldO1xuXG4gICAgICAgICAgICAvLyBGaWx0ZXIgb3V0IGFueSBlbnRyaWVzIG1hcmtlZCBhcyBkZXN0cm95ZWRcbiAgICAgICAgICAgIHZhciBmaWx0ZXJlZEFycmF5ID0ga28udXRpbHMuYXJyYXlGaWx0ZXIodW53cmFwcGVkQXJyYXksIGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gb3B0aW9uc1snaW5jbHVkZURlc3Ryb3llZCddIHx8IGl0ZW0gPT09IHVuZGVmaW5lZCB8fCBpdGVtID09PSBudWxsIHx8ICFrby51dGlscy51bndyYXBPYnNlcnZhYmxlKGl0ZW1bJ19kZXN0cm95J10pO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIC8vIENhbGwgc2V0RG9tTm9kZUNoaWxkcmVuRnJvbUFycmF5TWFwcGluZywgaWdub3JpbmcgYW55IG9ic2VydmFibGVzIHVud3JhcHBlZCB3aXRoaW4gKG1vc3QgbGlrZWx5IGZyb20gYSBjYWxsYmFjayBmdW5jdGlvbikuXG4gICAgICAgICAgICAvLyBJZiB0aGUgYXJyYXkgaXRlbXMgYXJlIG9ic2VydmFibGVzLCB0aG91Z2gsIHRoZXkgd2lsbCBiZSB1bndyYXBwZWQgaW4gZXhlY3V0ZVRlbXBsYXRlRm9yQXJyYXlJdGVtIGFuZCBtYW5hZ2VkIHdpdGhpbiBzZXREb21Ob2RlQ2hpbGRyZW5Gcm9tQXJyYXlNYXBwaW5nLlxuICAgICAgICAgICAga28uZGVwZW5kZW5jeURldGVjdGlvbi5pZ25vcmUoa28udXRpbHMuc2V0RG9tTm9kZUNoaWxkcmVuRnJvbUFycmF5TWFwcGluZywgbnVsbCwgW3RhcmdldE5vZGUsIGZpbHRlcmVkQXJyYXksIGV4ZWN1dGVUZW1wbGF0ZUZvckFycmF5SXRlbSwgb3B0aW9ucywgYWN0aXZhdGVCaW5kaW5nc0NhbGxiYWNrXSk7XG5cbiAgICAgICAgfSwgbnVsbCwgeyBkaXNwb3NlV2hlbk5vZGVJc1JlbW92ZWQ6IHRhcmdldE5vZGUgfSk7XG4gICAgfTtcblxuICAgIHZhciB0ZW1wbGF0ZUNvbXB1dGVkRG9tRGF0YUtleSA9IGtvLnV0aWxzLmRvbURhdGEubmV4dEtleSgpO1xuICAgIGZ1bmN0aW9uIGRpc3Bvc2VPbGRDb21wdXRlZEFuZFN0b3JlTmV3T25lKGVsZW1lbnQsIG5ld0NvbXB1dGVkKSB7XG4gICAgICAgIHZhciBvbGRDb21wdXRlZCA9IGtvLnV0aWxzLmRvbURhdGEuZ2V0KGVsZW1lbnQsIHRlbXBsYXRlQ29tcHV0ZWREb21EYXRhS2V5KTtcbiAgICAgICAgaWYgKG9sZENvbXB1dGVkICYmICh0eXBlb2Yob2xkQ29tcHV0ZWQuZGlzcG9zZSkgPT0gJ2Z1bmN0aW9uJykpXG4gICAgICAgICAgICBvbGRDb21wdXRlZC5kaXNwb3NlKCk7XG4gICAgICAgIGtvLnV0aWxzLmRvbURhdGEuc2V0KGVsZW1lbnQsIHRlbXBsYXRlQ29tcHV0ZWREb21EYXRhS2V5LCAobmV3Q29tcHV0ZWQgJiYgbmV3Q29tcHV0ZWQuaXNBY3RpdmUoKSkgPyBuZXdDb21wdXRlZCA6IHVuZGVmaW5lZCk7XG4gICAgfVxuXG4gICAga28uYmluZGluZ0hhbmRsZXJzWyd0ZW1wbGF0ZSddID0ge1xuICAgICAgICAnaW5pdCc6IGZ1bmN0aW9uKGVsZW1lbnQsIHZhbHVlQWNjZXNzb3IpIHtcbiAgICAgICAgICAgIC8vIFN1cHBvcnQgYW5vbnltb3VzIHRlbXBsYXRlc1xuICAgICAgICAgICAgdmFyIGJpbmRpbmdWYWx1ZSA9IGtvLnV0aWxzLnVud3JhcE9ic2VydmFibGUodmFsdWVBY2Nlc3NvcigpKTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgYmluZGluZ1ZhbHVlID09IFwic3RyaW5nXCIgfHwgYmluZGluZ1ZhbHVlWyduYW1lJ10pIHtcbiAgICAgICAgICAgICAgICAvLyBJdCdzIGEgbmFtZWQgdGVtcGxhdGUgLSBjbGVhciB0aGUgZWxlbWVudFxuICAgICAgICAgICAgICAgIGtvLnZpcnR1YWxFbGVtZW50cy5lbXB0eU5vZGUoZWxlbWVudCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCdub2RlcycgaW4gYmluZGluZ1ZhbHVlKSB7XG4gICAgICAgICAgICAgICAgLy8gV2UndmUgYmVlbiBnaXZlbiBhbiBhcnJheSBvZiBET00gbm9kZXMuIFNhdmUgdGhlbSBhcyB0aGUgdGVtcGxhdGUgc291cmNlLlxuICAgICAgICAgICAgICAgIC8vIFRoZXJlIGlzIG5vIGtub3duIHVzZSBjYXNlIGZvciB0aGUgbm9kZSBhcnJheSBiZWluZyBhbiBvYnNlcnZhYmxlIGFycmF5IChpZiB0aGUgb3V0cHV0XG4gICAgICAgICAgICAgICAgLy8gdmFyaWVzLCBwdXQgdGhhdCBiZWhhdmlvciAqaW50byogeW91ciB0ZW1wbGF0ZSAtIHRoYXQncyB3aGF0IHRlbXBsYXRlcyBhcmUgZm9yKSwgYW5kXG4gICAgICAgICAgICAgICAgLy8gdGhlIGltcGxlbWVudGF0aW9uIHdvdWxkIGJlIGEgbWVzcywgc28gYXNzZXJ0IHRoYXQgaXQncyBub3Qgb2JzZXJ2YWJsZS5cbiAgICAgICAgICAgICAgICB2YXIgbm9kZXMgPSBiaW5kaW5nVmFsdWVbJ25vZGVzJ10gfHwgW107XG4gICAgICAgICAgICAgICAgaWYgKGtvLmlzT2JzZXJ2YWJsZShub2RlcykpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgXCJub2Rlc1wiIG9wdGlvbiBtdXN0IGJlIGEgcGxhaW4sIG5vbi1vYnNlcnZhYmxlIGFycmF5LicpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgY29udGFpbmVyID0ga28udXRpbHMubW92ZUNsZWFuZWROb2Rlc1RvQ29udGFpbmVyRWxlbWVudChub2Rlcyk7IC8vIFRoaXMgYWxzbyByZW1vdmVzIHRoZSBub2RlcyBmcm9tIHRoZWlyIGN1cnJlbnQgcGFyZW50XG4gICAgICAgICAgICAgICAgbmV3IGtvLnRlbXBsYXRlU291cmNlcy5hbm9ueW1vdXNUZW1wbGF0ZShlbGVtZW50KVsnbm9kZXMnXShjb250YWluZXIpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBJdCdzIGFuIGFub255bW91cyB0ZW1wbGF0ZSAtIHN0b3JlIHRoZSBlbGVtZW50IGNvbnRlbnRzLCB0aGVuIGNsZWFyIHRoZSBlbGVtZW50XG4gICAgICAgICAgICAgICAgdmFyIHRlbXBsYXRlTm9kZXMgPSBrby52aXJ0dWFsRWxlbWVudHMuY2hpbGROb2RlcyhlbGVtZW50KSxcbiAgICAgICAgICAgICAgICAgICAgY29udGFpbmVyID0ga28udXRpbHMubW92ZUNsZWFuZWROb2Rlc1RvQ29udGFpbmVyRWxlbWVudCh0ZW1wbGF0ZU5vZGVzKTsgLy8gVGhpcyBhbHNvIHJlbW92ZXMgdGhlIG5vZGVzIGZyb20gdGhlaXIgY3VycmVudCBwYXJlbnRcbiAgICAgICAgICAgICAgICBuZXcga28udGVtcGxhdGVTb3VyY2VzLmFub255bW91c1RlbXBsYXRlKGVsZW1lbnQpWydub2RlcyddKGNvbnRhaW5lcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4geyAnY29udHJvbHNEZXNjZW5kYW50QmluZGluZ3MnOiB0cnVlIH07XG4gICAgICAgIH0sXG4gICAgICAgICd1cGRhdGUnOiBmdW5jdGlvbiAoZWxlbWVudCwgdmFsdWVBY2Nlc3NvciwgYWxsQmluZGluZ3MsIHZpZXdNb2RlbCwgYmluZGluZ0NvbnRleHQpIHtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IHZhbHVlQWNjZXNzb3IoKSxcbiAgICAgICAgICAgICAgICBvcHRpb25zID0ga28udXRpbHMudW53cmFwT2JzZXJ2YWJsZSh2YWx1ZSksXG4gICAgICAgICAgICAgICAgc2hvdWxkRGlzcGxheSA9IHRydWUsXG4gICAgICAgICAgICAgICAgdGVtcGxhdGVDb21wdXRlZCA9IG51bGwsXG4gICAgICAgICAgICAgICAgdGVtcGxhdGVOYW1lO1xuXG4gICAgICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgIHRlbXBsYXRlTmFtZSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGVtcGxhdGVOYW1lID0gb3B0aW9uc1snbmFtZSddO1xuXG4gICAgICAgICAgICAgICAgLy8gU3VwcG9ydCBcImlmXCIvXCJpZm5vdFwiIGNvbmRpdGlvbnNcbiAgICAgICAgICAgICAgICBpZiAoJ2lmJyBpbiBvcHRpb25zKVxuICAgICAgICAgICAgICAgICAgICBzaG91bGREaXNwbGF5ID0ga28udXRpbHMudW53cmFwT2JzZXJ2YWJsZShvcHRpb25zWydpZiddKTtcbiAgICAgICAgICAgICAgICBpZiAoc2hvdWxkRGlzcGxheSAmJiAnaWZub3QnIGluIG9wdGlvbnMpXG4gICAgICAgICAgICAgICAgICAgIHNob3VsZERpc3BsYXkgPSAha28udXRpbHMudW53cmFwT2JzZXJ2YWJsZShvcHRpb25zWydpZm5vdCddKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCdmb3JlYWNoJyBpbiBvcHRpb25zKSB7XG4gICAgICAgICAgICAgICAgLy8gUmVuZGVyIG9uY2UgZm9yIGVhY2ggZGF0YSBwb2ludCAodHJlYXRpbmcgZGF0YSBzZXQgYXMgZW1wdHkgaWYgc2hvdWxkRGlzcGxheT09ZmFsc2UpXG4gICAgICAgICAgICAgICAgdmFyIGRhdGFBcnJheSA9IChzaG91bGREaXNwbGF5ICYmIG9wdGlvbnNbJ2ZvcmVhY2gnXSkgfHwgW107XG4gICAgICAgICAgICAgICAgdGVtcGxhdGVDb21wdXRlZCA9IGtvLnJlbmRlclRlbXBsYXRlRm9yRWFjaCh0ZW1wbGF0ZU5hbWUgfHwgZWxlbWVudCwgZGF0YUFycmF5LCBvcHRpb25zLCBlbGVtZW50LCBiaW5kaW5nQ29udGV4dCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCFzaG91bGREaXNwbGF5KSB7XG4gICAgICAgICAgICAgICAga28udmlydHVhbEVsZW1lbnRzLmVtcHR5Tm9kZShlbGVtZW50KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gUmVuZGVyIG9uY2UgZm9yIHRoaXMgc2luZ2xlIGRhdGEgcG9pbnQgKG9yIHVzZSB0aGUgdmlld01vZGVsIGlmIG5vIGRhdGEgd2FzIHByb3ZpZGVkKVxuICAgICAgICAgICAgICAgIHZhciBpbm5lckJpbmRpbmdDb250ZXh0ID0gKCdkYXRhJyBpbiBvcHRpb25zKSA/XG4gICAgICAgICAgICAgICAgICAgIGJpbmRpbmdDb250ZXh0LmNyZWF0ZVN0YXRpY0NoaWxkQ29udGV4dChvcHRpb25zWydkYXRhJ10sIG9wdGlvbnNbJ2FzJ10pIDogIC8vIEdpdmVuIGFuIGV4cGxpdGl0ICdkYXRhJyB2YWx1ZSwgd2UgY3JlYXRlIGEgY2hpbGQgYmluZGluZyBjb250ZXh0IGZvciBpdFxuICAgICAgICAgICAgICAgICAgICBiaW5kaW5nQ29udGV4dDsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEdpdmVuIG5vIGV4cGxpY2l0ICdkYXRhJyB2YWx1ZSwgd2UgcmV0YWluIHRoZSBzYW1lIGJpbmRpbmcgY29udGV4dFxuICAgICAgICAgICAgICAgIHRlbXBsYXRlQ29tcHV0ZWQgPSBrby5yZW5kZXJUZW1wbGF0ZSh0ZW1wbGF0ZU5hbWUgfHwgZWxlbWVudCwgaW5uZXJCaW5kaW5nQ29udGV4dCwgb3B0aW9ucywgZWxlbWVudCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEl0IG9ubHkgbWFrZXMgc2Vuc2UgdG8gaGF2ZSBhIHNpbmdsZSB0ZW1wbGF0ZSBjb21wdXRlZCBwZXIgZWxlbWVudCAob3RoZXJ3aXNlIHdoaWNoIG9uZSBzaG91bGQgaGF2ZSBpdHMgb3V0cHV0IGRpc3BsYXllZD8pXG4gICAgICAgICAgICBkaXNwb3NlT2xkQ29tcHV0ZWRBbmRTdG9yZU5ld09uZShlbGVtZW50LCB0ZW1wbGF0ZUNvbXB1dGVkKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvLyBBbm9ueW1vdXMgdGVtcGxhdGVzIGNhbid0IGJlIHJld3JpdHRlbi4gR2l2ZSBhIG5pY2UgZXJyb3IgbWVzc2FnZSBpZiB5b3UgdHJ5IHRvIGRvIGl0LlxuICAgIGtvLmV4cHJlc3Npb25SZXdyaXRpbmcuYmluZGluZ1Jld3JpdGVWYWxpZGF0b3JzWyd0ZW1wbGF0ZSddID0gZnVuY3Rpb24oYmluZGluZ1ZhbHVlKSB7XG4gICAgICAgIHZhciBwYXJzZWRCaW5kaW5nVmFsdWUgPSBrby5leHByZXNzaW9uUmV3cml0aW5nLnBhcnNlT2JqZWN0TGl0ZXJhbChiaW5kaW5nVmFsdWUpO1xuXG4gICAgICAgIGlmICgocGFyc2VkQmluZGluZ1ZhbHVlLmxlbmd0aCA9PSAxKSAmJiBwYXJzZWRCaW5kaW5nVmFsdWVbMF1bJ3Vua25vd24nXSlcbiAgICAgICAgICAgIHJldHVybiBudWxsOyAvLyBJdCBsb29rcyBsaWtlIGEgc3RyaW5nIGxpdGVyYWwsIG5vdCBhbiBvYmplY3QgbGl0ZXJhbCwgc28gdHJlYXQgaXQgYXMgYSBuYW1lZCB0ZW1wbGF0ZSAod2hpY2ggaXMgYWxsb3dlZCBmb3IgcmV3cml0aW5nKVxuXG4gICAgICAgIGlmIChrby5leHByZXNzaW9uUmV3cml0aW5nLmtleVZhbHVlQXJyYXlDb250YWluc0tleShwYXJzZWRCaW5kaW5nVmFsdWUsIFwibmFtZVwiKSlcbiAgICAgICAgICAgIHJldHVybiBudWxsOyAvLyBOYW1lZCB0ZW1wbGF0ZXMgY2FuIGJlIHJld3JpdHRlbiwgc28gcmV0dXJuIFwibm8gZXJyb3JcIlxuICAgICAgICByZXR1cm4gXCJUaGlzIHRlbXBsYXRlIGVuZ2luZSBkb2VzIG5vdCBzdXBwb3J0IGFub255bW91cyB0ZW1wbGF0ZXMgbmVzdGVkIHdpdGhpbiBpdHMgdGVtcGxhdGVzXCI7XG4gICAgfTtcblxuICAgIGtvLnZpcnR1YWxFbGVtZW50cy5hbGxvd2VkQmluZGluZ3NbJ3RlbXBsYXRlJ10gPSB0cnVlO1xufSkoKTtcblxua28uZXhwb3J0U3ltYm9sKCdzZXRUZW1wbGF0ZUVuZ2luZScsIGtvLnNldFRlbXBsYXRlRW5naW5lKTtcbmtvLmV4cG9ydFN5bWJvbCgncmVuZGVyVGVtcGxhdGUnLCBrby5yZW5kZXJUZW1wbGF0ZSk7XG4vLyBHbyB0aHJvdWdoIHRoZSBpdGVtcyB0aGF0IGhhdmUgYmVlbiBhZGRlZCBhbmQgZGVsZXRlZCBhbmQgdHJ5IHRvIGZpbmQgbWF0Y2hlcyBiZXR3ZWVuIHRoZW0uXG5rby51dGlscy5maW5kTW92ZXNJbkFycmF5Q29tcGFyaXNvbiA9IGZ1bmN0aW9uIChsZWZ0LCByaWdodCwgbGltaXRGYWlsZWRDb21wYXJlcykge1xuICAgIGlmIChsZWZ0Lmxlbmd0aCAmJiByaWdodC5sZW5ndGgpIHtcbiAgICAgICAgdmFyIGZhaWxlZENvbXBhcmVzLCBsLCByLCBsZWZ0SXRlbSwgcmlnaHRJdGVtO1xuICAgICAgICBmb3IgKGZhaWxlZENvbXBhcmVzID0gbCA9IDA7ICghbGltaXRGYWlsZWRDb21wYXJlcyB8fCBmYWlsZWRDb21wYXJlcyA8IGxpbWl0RmFpbGVkQ29tcGFyZXMpICYmIChsZWZ0SXRlbSA9IGxlZnRbbF0pOyArK2wpIHtcbiAgICAgICAgICAgIGZvciAociA9IDA7IHJpZ2h0SXRlbSA9IHJpZ2h0W3JdOyArK3IpIHtcbiAgICAgICAgICAgICAgICBpZiAobGVmdEl0ZW1bJ3ZhbHVlJ10gPT09IHJpZ2h0SXRlbVsndmFsdWUnXSkge1xuICAgICAgICAgICAgICAgICAgICBsZWZ0SXRlbVsnbW92ZWQnXSA9IHJpZ2h0SXRlbVsnaW5kZXgnXTtcbiAgICAgICAgICAgICAgICAgICAgcmlnaHRJdGVtWydtb3ZlZCddID0gbGVmdEl0ZW1bJ2luZGV4J107XG4gICAgICAgICAgICAgICAgICAgIHJpZ2h0LnNwbGljZShyLCAxKTsgICAgICAgICAvLyBUaGlzIGl0ZW0gaXMgbWFya2VkIGFzIG1vdmVkOyBzbyByZW1vdmUgaXQgZnJvbSByaWdodCBsaXN0XG4gICAgICAgICAgICAgICAgICAgIGZhaWxlZENvbXBhcmVzID0gciA9IDA7ICAgICAvLyBSZXNldCBmYWlsZWQgY29tcGFyZXMgY291bnQgYmVjYXVzZSB3ZSdyZSBjaGVja2luZyBmb3IgY29uc2VjdXRpdmUgZmFpbHVyZXNcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmFpbGVkQ29tcGFyZXMgKz0gcjtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbmtvLnV0aWxzLmNvbXBhcmVBcnJheXMgPSAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBzdGF0dXNOb3RJbk9sZCA9ICdhZGRlZCcsIHN0YXR1c05vdEluTmV3ID0gJ2RlbGV0ZWQnO1xuXG4gICAgLy8gU2ltcGxlIGNhbGN1bGF0aW9uIGJhc2VkIG9uIExldmVuc2h0ZWluIGRpc3RhbmNlLlxuICAgIGZ1bmN0aW9uIGNvbXBhcmVBcnJheXMob2xkQXJyYXksIG5ld0FycmF5LCBvcHRpb25zKSB7XG4gICAgICAgIC8vIEZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LCBpZiB0aGUgdGhpcmQgYXJnIGlzIGFjdHVhbGx5IGEgYm9vbCwgaW50ZXJwcmV0XG4gICAgICAgIC8vIGl0IGFzIHRoZSBvbGQgcGFyYW1ldGVyICdkb250TGltaXRNb3ZlcycuIE5ld2VyIGNvZGUgc2hvdWxkIHVzZSB7IGRvbnRMaW1pdE1vdmVzOiB0cnVlIH0uXG4gICAgICAgIG9wdGlvbnMgPSAodHlwZW9mIG9wdGlvbnMgPT09ICdib29sZWFuJykgPyB7ICdkb250TGltaXRNb3Zlcyc6IG9wdGlvbnMgfSA6IChvcHRpb25zIHx8IHt9KTtcbiAgICAgICAgb2xkQXJyYXkgPSBvbGRBcnJheSB8fCBbXTtcbiAgICAgICAgbmV3QXJyYXkgPSBuZXdBcnJheSB8fCBbXTtcblxuICAgICAgICBpZiAob2xkQXJyYXkubGVuZ3RoIDwgbmV3QXJyYXkubGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuIGNvbXBhcmVTbWFsbEFycmF5VG9CaWdBcnJheShvbGRBcnJheSwgbmV3QXJyYXksIHN0YXR1c05vdEluT2xkLCBzdGF0dXNOb3RJbk5ldywgb3B0aW9ucyk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHJldHVybiBjb21wYXJlU21hbGxBcnJheVRvQmlnQXJyYXkobmV3QXJyYXksIG9sZEFycmF5LCBzdGF0dXNOb3RJbk5ldywgc3RhdHVzTm90SW5PbGQsIG9wdGlvbnMpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNvbXBhcmVTbWFsbEFycmF5VG9CaWdBcnJheShzbWxBcnJheSwgYmlnQXJyYXksIHN0YXR1c05vdEluU21sLCBzdGF0dXNOb3RJbkJpZywgb3B0aW9ucykge1xuICAgICAgICB2YXIgbXlNaW4gPSBNYXRoLm1pbixcbiAgICAgICAgICAgIG15TWF4ID0gTWF0aC5tYXgsXG4gICAgICAgICAgICBlZGl0RGlzdGFuY2VNYXRyaXggPSBbXSxcbiAgICAgICAgICAgIHNtbEluZGV4LCBzbWxJbmRleE1heCA9IHNtbEFycmF5Lmxlbmd0aCxcbiAgICAgICAgICAgIGJpZ0luZGV4LCBiaWdJbmRleE1heCA9IGJpZ0FycmF5Lmxlbmd0aCxcbiAgICAgICAgICAgIGNvbXBhcmVSYW5nZSA9IChiaWdJbmRleE1heCAtIHNtbEluZGV4TWF4KSB8fCAxLFxuICAgICAgICAgICAgbWF4RGlzdGFuY2UgPSBzbWxJbmRleE1heCArIGJpZ0luZGV4TWF4ICsgMSxcbiAgICAgICAgICAgIHRoaXNSb3csIGxhc3RSb3csXG4gICAgICAgICAgICBiaWdJbmRleE1heEZvclJvdywgYmlnSW5kZXhNaW5Gb3JSb3c7XG5cbiAgICAgICAgZm9yIChzbWxJbmRleCA9IDA7IHNtbEluZGV4IDw9IHNtbEluZGV4TWF4OyBzbWxJbmRleCsrKSB7XG4gICAgICAgICAgICBsYXN0Um93ID0gdGhpc1JvdztcbiAgICAgICAgICAgIGVkaXREaXN0YW5jZU1hdHJpeC5wdXNoKHRoaXNSb3cgPSBbXSk7XG4gICAgICAgICAgICBiaWdJbmRleE1heEZvclJvdyA9IG15TWluKGJpZ0luZGV4TWF4LCBzbWxJbmRleCArIGNvbXBhcmVSYW5nZSk7XG4gICAgICAgICAgICBiaWdJbmRleE1pbkZvclJvdyA9IG15TWF4KDAsIHNtbEluZGV4IC0gMSk7XG4gICAgICAgICAgICBmb3IgKGJpZ0luZGV4ID0gYmlnSW5kZXhNaW5Gb3JSb3c7IGJpZ0luZGV4IDw9IGJpZ0luZGV4TWF4Rm9yUm93OyBiaWdJbmRleCsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFiaWdJbmRleClcbiAgICAgICAgICAgICAgICAgICAgdGhpc1Jvd1tiaWdJbmRleF0gPSBzbWxJbmRleCArIDE7XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoIXNtbEluZGV4KSAgLy8gVG9wIHJvdyAtIHRyYW5zZm9ybSBlbXB0eSBhcnJheSBpbnRvIG5ldyBhcnJheSB2aWEgYWRkaXRpb25zXG4gICAgICAgICAgICAgICAgICAgIHRoaXNSb3dbYmlnSW5kZXhdID0gYmlnSW5kZXggKyAxO1xuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHNtbEFycmF5W3NtbEluZGV4IC0gMV0gPT09IGJpZ0FycmF5W2JpZ0luZGV4IC0gMV0pXG4gICAgICAgICAgICAgICAgICAgIHRoaXNSb3dbYmlnSW5kZXhdID0gbGFzdFJvd1tiaWdJbmRleCAtIDFdOyAgICAgICAgICAgICAgICAgIC8vIGNvcHkgdmFsdWUgKG5vIGVkaXQpXG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBub3J0aERpc3RhbmNlID0gbGFzdFJvd1tiaWdJbmRleF0gfHwgbWF4RGlzdGFuY2U7ICAgICAgIC8vIG5vdCBpbiBiaWcgKGRlbGV0aW9uKVxuICAgICAgICAgICAgICAgICAgICB2YXIgd2VzdERpc3RhbmNlID0gdGhpc1Jvd1tiaWdJbmRleCAtIDFdIHx8IG1heERpc3RhbmNlOyAgICAvLyBub3QgaW4gc21hbGwgKGFkZGl0aW9uKVxuICAgICAgICAgICAgICAgICAgICB0aGlzUm93W2JpZ0luZGV4XSA9IG15TWluKG5vcnRoRGlzdGFuY2UsIHdlc3REaXN0YW5jZSkgKyAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBlZGl0U2NyaXB0ID0gW10sIG1lTWludXNPbmUsIG5vdEluU21sID0gW10sIG5vdEluQmlnID0gW107XG4gICAgICAgIGZvciAoc21sSW5kZXggPSBzbWxJbmRleE1heCwgYmlnSW5kZXggPSBiaWdJbmRleE1heDsgc21sSW5kZXggfHwgYmlnSW5kZXg7KSB7XG4gICAgICAgICAgICBtZU1pbnVzT25lID0gZWRpdERpc3RhbmNlTWF0cml4W3NtbEluZGV4XVtiaWdJbmRleF0gLSAxO1xuICAgICAgICAgICAgaWYgKGJpZ0luZGV4ICYmIG1lTWludXNPbmUgPT09IGVkaXREaXN0YW5jZU1hdHJpeFtzbWxJbmRleF1bYmlnSW5kZXgtMV0pIHtcbiAgICAgICAgICAgICAgICBub3RJblNtbC5wdXNoKGVkaXRTY3JpcHRbZWRpdFNjcmlwdC5sZW5ndGhdID0geyAgICAgLy8gYWRkZWRcbiAgICAgICAgICAgICAgICAgICAgJ3N0YXR1cyc6IHN0YXR1c05vdEluU21sLFxuICAgICAgICAgICAgICAgICAgICAndmFsdWUnOiBiaWdBcnJheVstLWJpZ0luZGV4XSxcbiAgICAgICAgICAgICAgICAgICAgJ2luZGV4JzogYmlnSW5kZXggfSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHNtbEluZGV4ICYmIG1lTWludXNPbmUgPT09IGVkaXREaXN0YW5jZU1hdHJpeFtzbWxJbmRleCAtIDFdW2JpZ0luZGV4XSkge1xuICAgICAgICAgICAgICAgIG5vdEluQmlnLnB1c2goZWRpdFNjcmlwdFtlZGl0U2NyaXB0Lmxlbmd0aF0gPSB7ICAgICAvLyBkZWxldGVkXG4gICAgICAgICAgICAgICAgICAgICdzdGF0dXMnOiBzdGF0dXNOb3RJbkJpZyxcbiAgICAgICAgICAgICAgICAgICAgJ3ZhbHVlJzogc21sQXJyYXlbLS1zbWxJbmRleF0sXG4gICAgICAgICAgICAgICAgICAgICdpbmRleCc6IHNtbEluZGV4IH0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAtLWJpZ0luZGV4O1xuICAgICAgICAgICAgICAgIC0tc21sSW5kZXg7XG4gICAgICAgICAgICAgICAgaWYgKCFvcHRpb25zWydzcGFyc2UnXSkge1xuICAgICAgICAgICAgICAgICAgICBlZGl0U2NyaXB0LnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgJ3N0YXR1cyc6IFwicmV0YWluZWRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICd2YWx1ZSc6IGJpZ0FycmF5W2JpZ0luZGV4XSB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBTZXQgYSBsaW1pdCBvbiB0aGUgbnVtYmVyIG9mIGNvbnNlY3V0aXZlIG5vbi1tYXRjaGluZyBjb21wYXJpc29uczsgaGF2aW5nIGl0IGEgbXVsdGlwbGUgb2ZcbiAgICAgICAgLy8gc21sSW5kZXhNYXgga2VlcHMgdGhlIHRpbWUgY29tcGxleGl0eSBvZiB0aGlzIGFsZ29yaXRobSBsaW5lYXIuXG4gICAgICAgIGtvLnV0aWxzLmZpbmRNb3Zlc0luQXJyYXlDb21wYXJpc29uKG5vdEluQmlnLCBub3RJblNtbCwgIW9wdGlvbnNbJ2RvbnRMaW1pdE1vdmVzJ10gJiYgc21sSW5kZXhNYXggKiAxMCk7XG5cbiAgICAgICAgcmV0dXJuIGVkaXRTY3JpcHQucmV2ZXJzZSgpO1xuICAgIH1cblxuICAgIHJldHVybiBjb21wYXJlQXJyYXlzO1xufSkoKTtcblxua28uZXhwb3J0U3ltYm9sKCd1dGlscy5jb21wYXJlQXJyYXlzJywga28udXRpbHMuY29tcGFyZUFycmF5cyk7XG4oZnVuY3Rpb24gKCkge1xuICAgIC8vIE9iamVjdGl2ZTpcbiAgICAvLyAqIEdpdmVuIGFuIGlucHV0IGFycmF5LCBhIGNvbnRhaW5lciBET00gbm9kZSwgYW5kIGEgZnVuY3Rpb24gZnJvbSBhcnJheSBlbGVtZW50cyB0byBhcnJheXMgb2YgRE9NIG5vZGVzLFxuICAgIC8vICAgbWFwIHRoZSBhcnJheSBlbGVtZW50cyB0byBhcnJheXMgb2YgRE9NIG5vZGVzLCBjb25jYXRlbmF0ZSB0b2dldGhlciBhbGwgdGhlc2UgYXJyYXlzLCBhbmQgdXNlIHRoZW0gdG8gcG9wdWxhdGUgdGhlIGNvbnRhaW5lciBET00gbm9kZVxuICAgIC8vICogTmV4dCB0aW1lIHdlJ3JlIGdpdmVuIHRoZSBzYW1lIGNvbWJpbmF0aW9uIG9mIHRoaW5ncyAod2l0aCB0aGUgYXJyYXkgcG9zc2libHkgaGF2aW5nIG11dGF0ZWQpLCB1cGRhdGUgdGhlIGNvbnRhaW5lciBET00gbm9kZVxuICAgIC8vICAgc28gdGhhdCBpdHMgY2hpbGRyZW4gaXMgYWdhaW4gdGhlIGNvbmNhdGVuYXRpb24gb2YgdGhlIG1hcHBpbmdzIG9mIHRoZSBhcnJheSBlbGVtZW50cywgYnV0IGRvbid0IHJlLW1hcCBhbnkgYXJyYXkgZWxlbWVudHMgdGhhdCB3ZVxuICAgIC8vICAgcHJldmlvdXNseSBtYXBwZWQgLSByZXRhaW4gdGhvc2Ugbm9kZXMsIGFuZCBqdXN0IGluc2VydC9kZWxldGUgb3RoZXIgb25lc1xuXG4gICAgLy8gXCJjYWxsYmFja0FmdGVyQWRkaW5nTm9kZXNcIiB3aWxsIGJlIGludm9rZWQgYWZ0ZXIgYW55IFwibWFwcGluZ1wiLWdlbmVyYXRlZCBub2RlcyBhcmUgaW5zZXJ0ZWQgaW50byB0aGUgY29udGFpbmVyIG5vZGVcbiAgICAvLyBZb3UgY2FuIHVzZSB0aGlzLCBmb3IgZXhhbXBsZSwgdG8gYWN0aXZhdGUgYmluZGluZ3Mgb24gdGhvc2Ugbm9kZXMuXG5cbiAgICBmdW5jdGlvbiBtYXBOb2RlQW5kUmVmcmVzaFdoZW5DaGFuZ2VkKGNvbnRhaW5lck5vZGUsIG1hcHBpbmcsIHZhbHVlVG9NYXAsIGNhbGxiYWNrQWZ0ZXJBZGRpbmdOb2RlcywgaW5kZXgpIHtcbiAgICAgICAgLy8gTWFwIHRoaXMgYXJyYXkgdmFsdWUgaW5zaWRlIGEgZGVwZW5kZW50T2JzZXJ2YWJsZSBzbyB3ZSByZS1tYXAgd2hlbiBhbnkgZGVwZW5kZW5jeSBjaGFuZ2VzXG4gICAgICAgIHZhciBtYXBwZWROb2RlcyA9IFtdO1xuICAgICAgICB2YXIgZGVwZW5kZW50T2JzZXJ2YWJsZSA9IGtvLmRlcGVuZGVudE9ic2VydmFibGUoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgbmV3TWFwcGVkTm9kZXMgPSBtYXBwaW5nKHZhbHVlVG9NYXAsIGluZGV4LCBrby51dGlscy5maXhVcENvbnRpbnVvdXNOb2RlQXJyYXkobWFwcGVkTm9kZXMsIGNvbnRhaW5lck5vZGUpKSB8fCBbXTtcblxuICAgICAgICAgICAgLy8gT24gc3Vic2VxdWVudCBldmFsdWF0aW9ucywganVzdCByZXBsYWNlIHRoZSBwcmV2aW91c2x5LWluc2VydGVkIERPTSBub2Rlc1xuICAgICAgICAgICAgaWYgKG1hcHBlZE5vZGVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBrby51dGlscy5yZXBsYWNlRG9tTm9kZXMobWFwcGVkTm9kZXMsIG5ld01hcHBlZE5vZGVzKTtcbiAgICAgICAgICAgICAgICBpZiAoY2FsbGJhY2tBZnRlckFkZGluZ05vZGVzKVxuICAgICAgICAgICAgICAgICAgICBrby5kZXBlbmRlbmN5RGV0ZWN0aW9uLmlnbm9yZShjYWxsYmFja0FmdGVyQWRkaW5nTm9kZXMsIG51bGwsIFt2YWx1ZVRvTWFwLCBuZXdNYXBwZWROb2RlcywgaW5kZXhdKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gUmVwbGFjZSB0aGUgY29udGVudHMgb2YgdGhlIG1hcHBlZE5vZGVzIGFycmF5LCB0aGVyZWJ5IHVwZGF0aW5nIHRoZSByZWNvcmRcbiAgICAgICAgICAgIC8vIG9mIHdoaWNoIG5vZGVzIHdvdWxkIGJlIGRlbGV0ZWQgaWYgdmFsdWVUb01hcCB3YXMgaXRzZWxmIGxhdGVyIHJlbW92ZWRcbiAgICAgICAgICAgIG1hcHBlZE5vZGVzLmxlbmd0aCA9IDA7XG4gICAgICAgICAgICBrby51dGlscy5hcnJheVB1c2hBbGwobWFwcGVkTm9kZXMsIG5ld01hcHBlZE5vZGVzKTtcbiAgICAgICAgfSwgbnVsbCwgeyBkaXNwb3NlV2hlbk5vZGVJc1JlbW92ZWQ6IGNvbnRhaW5lck5vZGUsIGRpc3Bvc2VXaGVuOiBmdW5jdGlvbigpIHsgcmV0dXJuICFrby51dGlscy5hbnlEb21Ob2RlSXNBdHRhY2hlZFRvRG9jdW1lbnQobWFwcGVkTm9kZXMpOyB9IH0pO1xuICAgICAgICByZXR1cm4geyBtYXBwZWROb2RlcyA6IG1hcHBlZE5vZGVzLCBkZXBlbmRlbnRPYnNlcnZhYmxlIDogKGRlcGVuZGVudE9ic2VydmFibGUuaXNBY3RpdmUoKSA/IGRlcGVuZGVudE9ic2VydmFibGUgOiB1bmRlZmluZWQpIH07XG4gICAgfVxuXG4gICAgdmFyIGxhc3RNYXBwaW5nUmVzdWx0RG9tRGF0YUtleSA9IGtvLnV0aWxzLmRvbURhdGEubmV4dEtleSgpLFxuICAgICAgICBkZWxldGVkSXRlbUR1bW15VmFsdWUgPSBrby51dGlscy5kb21EYXRhLm5leHRLZXkoKTtcblxuICAgIGtvLnV0aWxzLnNldERvbU5vZGVDaGlsZHJlbkZyb21BcnJheU1hcHBpbmcgPSBmdW5jdGlvbiAoZG9tTm9kZSwgYXJyYXksIG1hcHBpbmcsIG9wdGlvbnMsIGNhbGxiYWNrQWZ0ZXJBZGRpbmdOb2Rlcykge1xuICAgICAgICAvLyBDb21wYXJlIHRoZSBwcm92aWRlZCBhcnJheSBhZ2FpbnN0IHRoZSBwcmV2aW91cyBvbmVcbiAgICAgICAgYXJyYXkgPSBhcnJheSB8fCBbXTtcbiAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgICAgIHZhciBpc0ZpcnN0RXhlY3V0aW9uID0ga28udXRpbHMuZG9tRGF0YS5nZXQoZG9tTm9kZSwgbGFzdE1hcHBpbmdSZXN1bHREb21EYXRhS2V5KSA9PT0gdW5kZWZpbmVkO1xuICAgICAgICB2YXIgbGFzdE1hcHBpbmdSZXN1bHQgPSBrby51dGlscy5kb21EYXRhLmdldChkb21Ob2RlLCBsYXN0TWFwcGluZ1Jlc3VsdERvbURhdGFLZXkpIHx8IFtdO1xuICAgICAgICB2YXIgbGFzdEFycmF5ID0ga28udXRpbHMuYXJyYXlNYXAobGFzdE1hcHBpbmdSZXN1bHQsIGZ1bmN0aW9uICh4KSB7IHJldHVybiB4LmFycmF5RW50cnk7IH0pO1xuICAgICAgICB2YXIgZWRpdFNjcmlwdCA9IGtvLnV0aWxzLmNvbXBhcmVBcnJheXMobGFzdEFycmF5LCBhcnJheSwgb3B0aW9uc1snZG9udExpbWl0TW92ZXMnXSk7XG5cbiAgICAgICAgLy8gQnVpbGQgdGhlIG5ldyBtYXBwaW5nIHJlc3VsdFxuICAgICAgICB2YXIgbmV3TWFwcGluZ1Jlc3VsdCA9IFtdO1xuICAgICAgICB2YXIgbGFzdE1hcHBpbmdSZXN1bHRJbmRleCA9IDA7XG4gICAgICAgIHZhciBuZXdNYXBwaW5nUmVzdWx0SW5kZXggPSAwO1xuXG4gICAgICAgIHZhciBub2Rlc1RvRGVsZXRlID0gW107XG4gICAgICAgIHZhciBpdGVtc1RvUHJvY2VzcyA9IFtdO1xuICAgICAgICB2YXIgaXRlbXNGb3JCZWZvcmVSZW1vdmVDYWxsYmFja3MgPSBbXTtcbiAgICAgICAgdmFyIGl0ZW1zRm9yTW92ZUNhbGxiYWNrcyA9IFtdO1xuICAgICAgICB2YXIgaXRlbXNGb3JBZnRlckFkZENhbGxiYWNrcyA9IFtdO1xuICAgICAgICB2YXIgbWFwRGF0YTtcblxuICAgICAgICBmdW5jdGlvbiBpdGVtTW92ZWRPclJldGFpbmVkKGVkaXRTY3JpcHRJbmRleCwgb2xkUG9zaXRpb24pIHtcbiAgICAgICAgICAgIG1hcERhdGEgPSBsYXN0TWFwcGluZ1Jlc3VsdFtvbGRQb3NpdGlvbl07XG4gICAgICAgICAgICBpZiAobmV3TWFwcGluZ1Jlc3VsdEluZGV4ICE9PSBvbGRQb3NpdGlvbilcbiAgICAgICAgICAgICAgICBpdGVtc0Zvck1vdmVDYWxsYmFja3NbZWRpdFNjcmlwdEluZGV4XSA9IG1hcERhdGE7XG4gICAgICAgICAgICAvLyBTaW5jZSB1cGRhdGluZyB0aGUgaW5kZXggbWlnaHQgY2hhbmdlIHRoZSBub2RlcywgZG8gc28gYmVmb3JlIGNhbGxpbmcgZml4VXBDb250aW51b3VzTm9kZUFycmF5XG4gICAgICAgICAgICBtYXBEYXRhLmluZGV4T2JzZXJ2YWJsZShuZXdNYXBwaW5nUmVzdWx0SW5kZXgrKyk7XG4gICAgICAgICAgICBrby51dGlscy5maXhVcENvbnRpbnVvdXNOb2RlQXJyYXkobWFwRGF0YS5tYXBwZWROb2RlcywgZG9tTm9kZSk7XG4gICAgICAgICAgICBuZXdNYXBwaW5nUmVzdWx0LnB1c2gobWFwRGF0YSk7XG4gICAgICAgICAgICBpdGVtc1RvUHJvY2Vzcy5wdXNoKG1hcERhdGEpO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gY2FsbENhbGxiYWNrKGNhbGxiYWNrLCBpdGVtcykge1xuICAgICAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIG4gPSBpdGVtcy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGl0ZW1zW2ldKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBrby51dGlscy5hcnJheUZvckVhY2goaXRlbXNbaV0ubWFwcGVkTm9kZXMsIGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhub2RlLCBpLCBpdGVtc1tpXS5hcnJheUVudHJ5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGVkaXRTY3JpcHRJdGVtLCBtb3ZlZEluZGV4OyBlZGl0U2NyaXB0SXRlbSA9IGVkaXRTY3JpcHRbaV07IGkrKykge1xuICAgICAgICAgICAgbW92ZWRJbmRleCA9IGVkaXRTY3JpcHRJdGVtWydtb3ZlZCddO1xuICAgICAgICAgICAgc3dpdGNoIChlZGl0U2NyaXB0SXRlbVsnc3RhdHVzJ10pIHtcbiAgICAgICAgICAgICAgICBjYXNlIFwiZGVsZXRlZFwiOlxuICAgICAgICAgICAgICAgICAgICBpZiAobW92ZWRJbmRleCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXBEYXRhID0gbGFzdE1hcHBpbmdSZXN1bHRbbGFzdE1hcHBpbmdSZXN1bHRJbmRleF07XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFN0b3AgdHJhY2tpbmcgY2hhbmdlcyB0byB0aGUgbWFwcGluZyBmb3IgdGhlc2Ugbm9kZXNcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtYXBEYXRhLmRlcGVuZGVudE9ic2VydmFibGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXBEYXRhLmRlcGVuZGVudE9ic2VydmFibGUuZGlzcG9zZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hcERhdGEuZGVwZW5kZW50T2JzZXJ2YWJsZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gUXVldWUgdGhlc2Ugbm9kZXMgZm9yIGxhdGVyIHJlbW92YWxcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChrby51dGlscy5maXhVcENvbnRpbnVvdXNOb2RlQXJyYXkobWFwRGF0YS5tYXBwZWROb2RlcywgZG9tTm9kZSkubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbnNbJ2JlZm9yZVJlbW92ZSddKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld01hcHBpbmdSZXN1bHQucHVzaChtYXBEYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXRlbXNUb1Byb2Nlc3MucHVzaChtYXBEYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1hcERhdGEuYXJyYXlFbnRyeSA9PT0gZGVsZXRlZEl0ZW1EdW1teVZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXBEYXRhID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW1zRm9yQmVmb3JlUmVtb3ZlQ2FsbGJhY2tzW2ldID0gbWFwRGF0YTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobWFwRGF0YSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2Rlc1RvRGVsZXRlLnB1c2guYXBwbHkobm9kZXNUb0RlbGV0ZSwgbWFwRGF0YS5tYXBwZWROb2Rlcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGxhc3RNYXBwaW5nUmVzdWx0SW5kZXgrKztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICBjYXNlIFwicmV0YWluZWRcIjpcbiAgICAgICAgICAgICAgICAgICAgaXRlbU1vdmVkT3JSZXRhaW5lZChpLCBsYXN0TWFwcGluZ1Jlc3VsdEluZGV4KyspO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgIGNhc2UgXCJhZGRlZFwiOlxuICAgICAgICAgICAgICAgICAgICBpZiAobW92ZWRJbmRleCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpdGVtTW92ZWRPclJldGFpbmVkKGksIG1vdmVkSW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWFwRGF0YSA9IHsgYXJyYXlFbnRyeTogZWRpdFNjcmlwdEl0ZW1bJ3ZhbHVlJ10sIGluZGV4T2JzZXJ2YWJsZToga28ub2JzZXJ2YWJsZShuZXdNYXBwaW5nUmVzdWx0SW5kZXgrKykgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld01hcHBpbmdSZXN1bHQucHVzaChtYXBEYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW1zVG9Qcm9jZXNzLnB1c2gobWFwRGF0YSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWlzRmlyc3RFeGVjdXRpb24pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaXRlbXNGb3JBZnRlckFkZENhbGxiYWNrc1tpXSA9IG1hcERhdGE7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBTdG9yZSBhIGNvcHkgb2YgdGhlIGFycmF5IGl0ZW1zIHdlIGp1c3QgY29uc2lkZXJlZCBzbyB3ZSBjYW4gZGlmZmVyZW5jZSBpdCBuZXh0IHRpbWVcbiAgICAgICAga28udXRpbHMuZG9tRGF0YS5zZXQoZG9tTm9kZSwgbGFzdE1hcHBpbmdSZXN1bHREb21EYXRhS2V5LCBuZXdNYXBwaW5nUmVzdWx0KTtcblxuICAgICAgICAvLyBDYWxsIGJlZm9yZU1vdmUgZmlyc3QgYmVmb3JlIGFueSBjaGFuZ2VzIGhhdmUgYmVlbiBtYWRlIHRvIHRoZSBET01cbiAgICAgICAgY2FsbENhbGxiYWNrKG9wdGlvbnNbJ2JlZm9yZU1vdmUnXSwgaXRlbXNGb3JNb3ZlQ2FsbGJhY2tzKTtcblxuICAgICAgICAvLyBOZXh0IHJlbW92ZSBub2RlcyBmb3IgZGVsZXRlZCBpdGVtcyAob3IganVzdCBjbGVhbiBpZiB0aGVyZSdzIGEgYmVmb3JlUmVtb3ZlIGNhbGxiYWNrKVxuICAgICAgICBrby51dGlscy5hcnJheUZvckVhY2gobm9kZXNUb0RlbGV0ZSwgb3B0aW9uc1snYmVmb3JlUmVtb3ZlJ10gPyBrby5jbGVhbk5vZGUgOiBrby5yZW1vdmVOb2RlKTtcblxuICAgICAgICAvLyBOZXh0IGFkZC9yZW9yZGVyIHRoZSByZW1haW5pbmcgaXRlbXMgKHdpbGwgaW5jbHVkZSBkZWxldGVkIGl0ZW1zIGlmIHRoZXJlJ3MgYSBiZWZvcmVSZW1vdmUgY2FsbGJhY2spXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBuZXh0Tm9kZSA9IGtvLnZpcnR1YWxFbGVtZW50cy5maXJzdENoaWxkKGRvbU5vZGUpLCBsYXN0Tm9kZSwgbm9kZTsgbWFwRGF0YSA9IGl0ZW1zVG9Qcm9jZXNzW2ldOyBpKyspIHtcbiAgICAgICAgICAgIC8vIEdldCBub2RlcyBmb3IgbmV3bHkgYWRkZWQgaXRlbXNcbiAgICAgICAgICAgIGlmICghbWFwRGF0YS5tYXBwZWROb2RlcylcbiAgICAgICAgICAgICAgICBrby51dGlscy5leHRlbmQobWFwRGF0YSwgbWFwTm9kZUFuZFJlZnJlc2hXaGVuQ2hhbmdlZChkb21Ob2RlLCBtYXBwaW5nLCBtYXBEYXRhLmFycmF5RW50cnksIGNhbGxiYWNrQWZ0ZXJBZGRpbmdOb2RlcywgbWFwRGF0YS5pbmRleE9ic2VydmFibGUpKTtcblxuICAgICAgICAgICAgLy8gUHV0IG5vZGVzIGluIHRoZSByaWdodCBwbGFjZSBpZiB0aGV5IGFyZW4ndCB0aGVyZSBhbHJlYWR5XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgbm9kZSA9IG1hcERhdGEubWFwcGVkTm9kZXNbal07IG5leHROb2RlID0gbm9kZS5uZXh0U2libGluZywgbGFzdE5vZGUgPSBub2RlLCBqKyspIHtcbiAgICAgICAgICAgICAgICBpZiAobm9kZSAhPT0gbmV4dE5vZGUpXG4gICAgICAgICAgICAgICAgICAgIGtvLnZpcnR1YWxFbGVtZW50cy5pbnNlcnRBZnRlcihkb21Ob2RlLCBub2RlLCBsYXN0Tm9kZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFJ1biB0aGUgY2FsbGJhY2tzIGZvciBuZXdseSBhZGRlZCBub2RlcyAoZm9yIGV4YW1wbGUsIHRvIGFwcGx5IGJpbmRpbmdzLCBldGMuKVxuICAgICAgICAgICAgaWYgKCFtYXBEYXRhLmluaXRpYWxpemVkICYmIGNhbGxiYWNrQWZ0ZXJBZGRpbmdOb2Rlcykge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrQWZ0ZXJBZGRpbmdOb2RlcyhtYXBEYXRhLmFycmF5RW50cnksIG1hcERhdGEubWFwcGVkTm9kZXMsIG1hcERhdGEuaW5kZXhPYnNlcnZhYmxlKTtcbiAgICAgICAgICAgICAgICBtYXBEYXRhLmluaXRpYWxpemVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIElmIHRoZXJlJ3MgYSBiZWZvcmVSZW1vdmUgY2FsbGJhY2ssIGNhbGwgaXQgYWZ0ZXIgcmVvcmRlcmluZy5cbiAgICAgICAgLy8gTm90ZSB0aGF0IHdlIGFzc3VtZSB0aGF0IHRoZSBiZWZvcmVSZW1vdmUgY2FsbGJhY2sgd2lsbCB1c3VhbGx5IGJlIHVzZWQgdG8gcmVtb3ZlIHRoZSBub2RlcyB1c2luZ1xuICAgICAgICAvLyBzb21lIHNvcnQgb2YgYW5pbWF0aW9uLCB3aGljaCBpcyB3aHkgd2UgZmlyc3QgcmVvcmRlciB0aGUgbm9kZXMgdGhhdCB3aWxsIGJlIHJlbW92ZWQuIElmIHRoZVxuICAgICAgICAvLyBjYWxsYmFjayBpbnN0ZWFkIHJlbW92ZXMgdGhlIG5vZGVzIHJpZ2h0IGF3YXksIGl0IHdvdWxkIGJlIG1vcmUgZWZmaWNpZW50IHRvIHNraXAgcmVvcmRlcmluZyB0aGVtLlxuICAgICAgICAvLyBQZXJoYXBzIHdlJ2xsIG1ha2UgdGhhdCBjaGFuZ2UgaW4gdGhlIGZ1dHVyZSBpZiB0aGlzIHNjZW5hcmlvIGJlY29tZXMgbW9yZSBjb21tb24uXG4gICAgICAgIGNhbGxDYWxsYmFjayhvcHRpb25zWydiZWZvcmVSZW1vdmUnXSwgaXRlbXNGb3JCZWZvcmVSZW1vdmVDYWxsYmFja3MpO1xuXG4gICAgICAgIC8vIFJlcGxhY2UgdGhlIHN0b3JlZCB2YWx1ZXMgb2YgZGVsZXRlZCBpdGVtcyB3aXRoIGEgZHVtbXkgdmFsdWUuIFRoaXMgcHJvdmlkZXMgdHdvIGJlbmVmaXRzOiBpdCBtYXJrcyB0aGlzIGl0ZW1cbiAgICAgICAgLy8gYXMgYWxyZWFkeSBcInJlbW92ZWRcIiBzbyB3ZSB3b24ndCBjYWxsIGJlZm9yZVJlbW92ZSBmb3IgaXQgYWdhaW4sIGFuZCBpdCBlbnN1cmVzIHRoYXQgdGhlIGl0ZW0gd29uJ3QgbWF0Y2ggdXBcbiAgICAgICAgLy8gd2l0aCBhbiBhY3R1YWwgaXRlbSBpbiB0aGUgYXJyYXkgYW5kIGFwcGVhciBhcyBcInJldGFpbmVkXCIgb3IgXCJtb3ZlZFwiLlxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgaXRlbXNGb3JCZWZvcmVSZW1vdmVDYWxsYmFja3MubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIGlmIChpdGVtc0ZvckJlZm9yZVJlbW92ZUNhbGxiYWNrc1tpXSkge1xuICAgICAgICAgICAgICAgIGl0ZW1zRm9yQmVmb3JlUmVtb3ZlQ2FsbGJhY2tzW2ldLmFycmF5RW50cnkgPSBkZWxldGVkSXRlbUR1bW15VmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBGaW5hbGx5IGNhbGwgYWZ0ZXJNb3ZlIGFuZCBhZnRlckFkZCBjYWxsYmFja3NcbiAgICAgICAgY2FsbENhbGxiYWNrKG9wdGlvbnNbJ2FmdGVyTW92ZSddLCBpdGVtc0Zvck1vdmVDYWxsYmFja3MpO1xuICAgICAgICBjYWxsQ2FsbGJhY2sob3B0aW9uc1snYWZ0ZXJBZGQnXSwgaXRlbXNGb3JBZnRlckFkZENhbGxiYWNrcyk7XG4gICAgfVxufSkoKTtcblxua28uZXhwb3J0U3ltYm9sKCd1dGlscy5zZXREb21Ob2RlQ2hpbGRyZW5Gcm9tQXJyYXlNYXBwaW5nJywga28udXRpbHMuc2V0RG9tTm9kZUNoaWxkcmVuRnJvbUFycmF5TWFwcGluZyk7XG5rby5uYXRpdmVUZW1wbGF0ZUVuZ2luZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzWydhbGxvd1RlbXBsYXRlUmV3cml0aW5nJ10gPSBmYWxzZTtcbn1cblxua28ubmF0aXZlVGVtcGxhdGVFbmdpbmUucHJvdG90eXBlID0gbmV3IGtvLnRlbXBsYXRlRW5naW5lKCk7XG5rby5uYXRpdmVUZW1wbGF0ZUVuZ2luZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBrby5uYXRpdmVUZW1wbGF0ZUVuZ2luZTtcbmtvLm5hdGl2ZVRlbXBsYXRlRW5naW5lLnByb3RvdHlwZVsncmVuZGVyVGVtcGxhdGVTb3VyY2UnXSA9IGZ1bmN0aW9uICh0ZW1wbGF0ZVNvdXJjZSwgYmluZGluZ0NvbnRleHQsIG9wdGlvbnMsIHRlbXBsYXRlRG9jdW1lbnQpIHtcbiAgICB2YXIgdXNlTm9kZXNJZkF2YWlsYWJsZSA9ICEoa28udXRpbHMuaWVWZXJzaW9uIDwgOSksIC8vIElFPDkgY2xvbmVOb2RlIGRvZXNuJ3Qgd29yayBwcm9wZXJseVxuICAgICAgICB0ZW1wbGF0ZU5vZGVzRnVuYyA9IHVzZU5vZGVzSWZBdmFpbGFibGUgPyB0ZW1wbGF0ZVNvdXJjZVsnbm9kZXMnXSA6IG51bGwsXG4gICAgICAgIHRlbXBsYXRlTm9kZXMgPSB0ZW1wbGF0ZU5vZGVzRnVuYyA/IHRlbXBsYXRlU291cmNlWydub2RlcyddKCkgOiBudWxsO1xuXG4gICAgaWYgKHRlbXBsYXRlTm9kZXMpIHtcbiAgICAgICAgcmV0dXJuIGtvLnV0aWxzLm1ha2VBcnJheSh0ZW1wbGF0ZU5vZGVzLmNsb25lTm9kZSh0cnVlKS5jaGlsZE5vZGVzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgdGVtcGxhdGVUZXh0ID0gdGVtcGxhdGVTb3VyY2VbJ3RleHQnXSgpO1xuICAgICAgICByZXR1cm4ga28udXRpbHMucGFyc2VIdG1sRnJhZ21lbnQodGVtcGxhdGVUZXh0LCB0ZW1wbGF0ZURvY3VtZW50KTtcbiAgICB9XG59O1xuXG5rby5uYXRpdmVUZW1wbGF0ZUVuZ2luZS5pbnN0YW5jZSA9IG5ldyBrby5uYXRpdmVUZW1wbGF0ZUVuZ2luZSgpO1xua28uc2V0VGVtcGxhdGVFbmdpbmUoa28ubmF0aXZlVGVtcGxhdGVFbmdpbmUuaW5zdGFuY2UpO1xuXG5rby5leHBvcnRTeW1ib2woJ25hdGl2ZVRlbXBsYXRlRW5naW5lJywga28ubmF0aXZlVGVtcGxhdGVFbmdpbmUpO1xuKGZ1bmN0aW9uKCkge1xuICAgIGtvLmpxdWVyeVRtcGxUZW1wbGF0ZUVuZ2luZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gRGV0ZWN0IHdoaWNoIHZlcnNpb24gb2YganF1ZXJ5LXRtcGwgeW91J3JlIHVzaW5nLiBVbmZvcnR1bmF0ZWx5IGpxdWVyeS10bXBsXG4gICAgICAgIC8vIGRvZXNuJ3QgZXhwb3NlIGEgdmVyc2lvbiBudW1iZXIsIHNvIHdlIGhhdmUgdG8gaW5mZXIgaXQuXG4gICAgICAgIC8vIE5vdGUgdGhhdCBhcyBvZiBLbm9ja291dCAxLjMsIHdlIG9ubHkgc3VwcG9ydCBqUXVlcnkudG1wbCAxLjAuMHByZSBhbmQgbGF0ZXIsXG4gICAgICAgIC8vIHdoaWNoIEtPIGludGVybmFsbHkgcmVmZXJzIHRvIGFzIHZlcnNpb24gXCIyXCIsIHNvIG9sZGVyIHZlcnNpb25zIGFyZSBubyBsb25nZXIgZGV0ZWN0ZWQuXG4gICAgICAgIHZhciBqUXVlcnlUbXBsVmVyc2lvbiA9IHRoaXMualF1ZXJ5VG1wbFZlcnNpb24gPSAoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpZiAoIWpRdWVyeUluc3RhbmNlIHx8ICEoalF1ZXJ5SW5zdGFuY2VbJ3RtcGwnXSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICAvLyBTaW5jZSBpdCBleHBvc2VzIG5vIG9mZmljaWFsIHZlcnNpb24gbnVtYmVyLCB3ZSB1c2Ugb3VyIG93biBudW1iZXJpbmcgc3lzdGVtLiBUbyBiZSB1cGRhdGVkIGFzIGpxdWVyeS10bXBsIGV2b2x2ZXMuXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGlmIChqUXVlcnlJbnN0YW5jZVsndG1wbCddWyd0YWcnXVsndG1wbCddWydvcGVuJ10udG9TdHJpbmcoKS5pbmRleE9mKCdfXycpID49IDApIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gU2luY2UgMS4wLjBwcmUsIGN1c3RvbSB0YWdzIHNob3VsZCBhcHBlbmQgbWFya3VwIHRvIGFuIGFycmF5IGNhbGxlZCBcIl9fXCJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDI7IC8vIEZpbmFsIHZlcnNpb24gb2YganF1ZXJ5LnRtcGxcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGNhdGNoKGV4KSB7IC8qIEFwcGFyZW50bHkgbm90IHRoZSB2ZXJzaW9uIHdlIHdlcmUgbG9va2luZyBmb3IgKi8gfVxuXG4gICAgICAgICAgICByZXR1cm4gMTsgLy8gQW55IG9sZGVyIHZlcnNpb24gdGhhdCB3ZSBkb24ndCBzdXBwb3J0XG4gICAgICAgIH0pKCk7XG5cbiAgICAgICAgZnVuY3Rpb24gZW5zdXJlSGFzUmVmZXJlbmNlZEpRdWVyeVRlbXBsYXRlcygpIHtcbiAgICAgICAgICAgIGlmIChqUXVlcnlUbXBsVmVyc2lvbiA8IDIpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiWW91ciB2ZXJzaW9uIG9mIGpRdWVyeS50bXBsIGlzIHRvbyBvbGQuIFBsZWFzZSB1cGdyYWRlIHRvIGpRdWVyeS50bXBsIDEuMC4wcHJlIG9yIGxhdGVyLlwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGV4ZWN1dGVUZW1wbGF0ZShjb21waWxlZFRlbXBsYXRlLCBkYXRhLCBqUXVlcnlUZW1wbGF0ZU9wdGlvbnMpIHtcbiAgICAgICAgICAgIHJldHVybiBqUXVlcnlJbnN0YW5jZVsndG1wbCddKGNvbXBpbGVkVGVtcGxhdGUsIGRhdGEsIGpRdWVyeVRlbXBsYXRlT3B0aW9ucyk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzWydyZW5kZXJUZW1wbGF0ZVNvdXJjZSddID0gZnVuY3Rpb24odGVtcGxhdGVTb3VyY2UsIGJpbmRpbmdDb250ZXh0LCBvcHRpb25zLCB0ZW1wbGF0ZURvY3VtZW50KSB7XG4gICAgICAgICAgICB0ZW1wbGF0ZURvY3VtZW50ID0gdGVtcGxhdGVEb2N1bWVudCB8fCBkb2N1bWVudDtcbiAgICAgICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgICAgICAgICAgZW5zdXJlSGFzUmVmZXJlbmNlZEpRdWVyeVRlbXBsYXRlcygpO1xuXG4gICAgICAgICAgICAvLyBFbnN1cmUgd2UgaGF2ZSBzdG9yZWQgYSBwcmVjb21waWxlZCB2ZXJzaW9uIG9mIHRoaXMgdGVtcGxhdGUgKGRvbid0IHdhbnQgdG8gcmVwYXJzZSBvbiBldmVyeSByZW5kZXIpXG4gICAgICAgICAgICB2YXIgcHJlY29tcGlsZWQgPSB0ZW1wbGF0ZVNvdXJjZVsnZGF0YSddKCdwcmVjb21waWxlZCcpO1xuICAgICAgICAgICAgaWYgKCFwcmVjb21waWxlZCkge1xuICAgICAgICAgICAgICAgIHZhciB0ZW1wbGF0ZVRleHQgPSB0ZW1wbGF0ZVNvdXJjZVsndGV4dCddKCkgfHwgXCJcIjtcbiAgICAgICAgICAgICAgICAvLyBXcmFwIGluIFwid2l0aCgkd2hhdGV2ZXIua29CaW5kaW5nQ29udGV4dCkgeyAuLi4gfVwiXG4gICAgICAgICAgICAgICAgdGVtcGxhdGVUZXh0ID0gXCJ7e2tvX3dpdGggJGl0ZW0ua29CaW5kaW5nQ29udGV4dH19XCIgKyB0ZW1wbGF0ZVRleHQgKyBcInt7L2tvX3dpdGh9fVwiO1xuXG4gICAgICAgICAgICAgICAgcHJlY29tcGlsZWQgPSBqUXVlcnlJbnN0YW5jZVsndGVtcGxhdGUnXShudWxsLCB0ZW1wbGF0ZVRleHQpO1xuICAgICAgICAgICAgICAgIHRlbXBsYXRlU291cmNlWydkYXRhJ10oJ3ByZWNvbXBpbGVkJywgcHJlY29tcGlsZWQpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgZGF0YSA9IFtiaW5kaW5nQ29udGV4dFsnJGRhdGEnXV07IC8vIFByZXdyYXAgdGhlIGRhdGEgaW4gYW4gYXJyYXkgdG8gc3RvcCBqcXVlcnkudG1wbCBmcm9tIHRyeWluZyB0byB1bndyYXAgYW55IGFycmF5c1xuICAgICAgICAgICAgdmFyIGpRdWVyeVRlbXBsYXRlT3B0aW9ucyA9IGpRdWVyeUluc3RhbmNlWydleHRlbmQnXSh7ICdrb0JpbmRpbmdDb250ZXh0JzogYmluZGluZ0NvbnRleHQgfSwgb3B0aW9uc1sndGVtcGxhdGVPcHRpb25zJ10pO1xuXG4gICAgICAgICAgICB2YXIgcmVzdWx0Tm9kZXMgPSBleGVjdXRlVGVtcGxhdGUocHJlY29tcGlsZWQsIGRhdGEsIGpRdWVyeVRlbXBsYXRlT3B0aW9ucyk7XG4gICAgICAgICAgICByZXN1bHROb2Rlc1snYXBwZW5kVG8nXSh0ZW1wbGF0ZURvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIikpOyAvLyBVc2luZyBcImFwcGVuZFRvXCIgZm9yY2VzIGpRdWVyeS9qUXVlcnkudG1wbCB0byBwZXJmb3JtIG5lY2Vzc2FyeSBjbGVhbnVwIHdvcmtcblxuICAgICAgICAgICAgalF1ZXJ5SW5zdGFuY2VbJ2ZyYWdtZW50cyddID0ge307IC8vIENsZWFyIGpRdWVyeSdzIGZyYWdtZW50IGNhY2hlIHRvIGF2b2lkIGEgbWVtb3J5IGxlYWsgYWZ0ZXIgYSBsYXJnZSBudW1iZXIgb2YgdGVtcGxhdGUgcmVuZGVyc1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdE5vZGVzO1xuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXNbJ2NyZWF0ZUphdmFTY3JpcHRFdmFsdWF0b3JCbG9jayddID0gZnVuY3Rpb24oc2NyaXB0KSB7XG4gICAgICAgICAgICByZXR1cm4gXCJ7e2tvX2NvZGUgKChmdW5jdGlvbigpIHsgcmV0dXJuIFwiICsgc2NyaXB0ICsgXCIgfSkoKSkgfX1cIjtcbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzWydhZGRUZW1wbGF0ZSddID0gZnVuY3Rpb24odGVtcGxhdGVOYW1lLCB0ZW1wbGF0ZU1hcmt1cCkge1xuICAgICAgICAgICAgZG9jdW1lbnQud3JpdGUoXCI8c2NyaXB0IHR5cGU9J3RleHQvaHRtbCcgaWQ9J1wiICsgdGVtcGxhdGVOYW1lICsgXCInPlwiICsgdGVtcGxhdGVNYXJrdXAgKyBcIjxcIiArIFwiL3NjcmlwdD5cIik7XG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKGpRdWVyeVRtcGxWZXJzaW9uID4gMCkge1xuICAgICAgICAgICAgalF1ZXJ5SW5zdGFuY2VbJ3RtcGwnXVsndGFnJ11bJ2tvX2NvZGUnXSA9IHtcbiAgICAgICAgICAgICAgICBvcGVuOiBcIl9fLnB1c2goJDEgfHwgJycpO1wiXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgalF1ZXJ5SW5zdGFuY2VbJ3RtcGwnXVsndGFnJ11bJ2tvX3dpdGgnXSA9IHtcbiAgICAgICAgICAgICAgICBvcGVuOiBcIndpdGgoJDEpIHtcIixcbiAgICAgICAgICAgICAgICBjbG9zZTogXCJ9IFwiXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIGtvLmpxdWVyeVRtcGxUZW1wbGF0ZUVuZ2luZS5wcm90b3R5cGUgPSBuZXcga28udGVtcGxhdGVFbmdpbmUoKTtcbiAgICBrby5qcXVlcnlUbXBsVGVtcGxhdGVFbmdpbmUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0ga28uanF1ZXJ5VG1wbFRlbXBsYXRlRW5naW5lO1xuXG4gICAgLy8gVXNlIHRoaXMgb25lIGJ5IGRlZmF1bHQgKm9ubHkgaWYganF1ZXJ5LnRtcGwgaXMgcmVmZXJlbmNlZCpcbiAgICB2YXIganF1ZXJ5VG1wbFRlbXBsYXRlRW5naW5lSW5zdGFuY2UgPSBuZXcga28uanF1ZXJ5VG1wbFRlbXBsYXRlRW5naW5lKCk7XG4gICAgaWYgKGpxdWVyeVRtcGxUZW1wbGF0ZUVuZ2luZUluc3RhbmNlLmpRdWVyeVRtcGxWZXJzaW9uID4gMClcbiAgICAgICAga28uc2V0VGVtcGxhdGVFbmdpbmUoanF1ZXJ5VG1wbFRlbXBsYXRlRW5naW5lSW5zdGFuY2UpO1xuXG4gICAga28uZXhwb3J0U3ltYm9sKCdqcXVlcnlUbXBsVGVtcGxhdGVFbmdpbmUnLCBrby5qcXVlcnlUbXBsVGVtcGxhdGVFbmdpbmUpO1xufSkoKTtcbn0pKTtcbn0oKSk7XG59KSgpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2tub2Nrb3V0L2J1aWxkL291dHB1dC9rbm9ja291dC1sYXRlc3QuZGVidWcuanNcbi8vIG1vZHVsZSBpZCA9IDk0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oKSB7IHRocm93IG5ldyBFcnJvcihcImRlZmluZSBjYW5ub3QgYmUgdXNlZCBpbmRpcmVjdFwiKTsgfTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vICh3ZWJwYWNrKS9idWlsZGluL2FtZC1kZWZpbmUuanNcbi8vIG1vZHVsZSBpZCA9IDk1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qZ2xvYmFscyBqUXVlcnksIGRlZmluZSwgbW9kdWxlLCBleHBvcnRzLCByZXF1aXJlLCB3aW5kb3csIGRvY3VtZW50LCBwb3N0TWVzc2FnZSAqL1xuKGZ1bmN0aW9uIChmYWN0b3J5KSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXHRpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XG5cdFx0ZGVmaW5lKFsnanF1ZXJ5J10sIGZhY3RvcnkpO1xuXHR9XG5cdGVsc2UgaWYodHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgJiYgbW9kdWxlLmV4cG9ydHMpIHtcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkocmVxdWlyZSgnanF1ZXJ5JykpO1xuXHR9XG5cdGVsc2Uge1xuXHRcdGZhY3RvcnkoalF1ZXJ5KTtcblx0fVxufShmdW5jdGlvbiAoJCwgdW5kZWZpbmVkKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuLyohXG4gKiBqc1RyZWUgMy4zLjNcbiAqIGh0dHA6Ly9qc3RyZWUuY29tL1xuICpcbiAqIENvcHlyaWdodCAoYykgMjAxNCBJdmFuIEJvemhhbm92IChodHRwOi8vdmFrYXRhLmNvbSlcbiAqXG4gKiBMaWNlbnNlZCBzYW1lIGFzIGpxdWVyeSAtIHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgTUlUIExpY2Vuc2VcbiAqICAgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHBcbiAqL1xuLyohXG4gKiBpZiB1c2luZyBqc2xpbnQgcGxlYXNlIGFsbG93IGZvciB0aGUgalF1ZXJ5IGdsb2JhbCBhbmQgdXNlIGZvbGxvd2luZyBvcHRpb25zOlxuICoganNsaW50OiBsb29wZnVuYzogdHJ1ZSwgYnJvd3NlcjogdHJ1ZSwgYXNzOiB0cnVlLCBiaXR3aXNlOiB0cnVlLCBjb250aW51ZTogdHJ1ZSwgbm9tZW46IHRydWUsIHBsdXNwbHVzOiB0cnVlLCByZWdleHA6IHRydWUsIHVucGFyYW06IHRydWUsIHRvZG86IHRydWUsIHdoaXRlOiB0cnVlXG4gKi9cbi8qanNoaW50IC1XMDgzICovXG5cblx0Ly8gcHJldmVudCBhbm90aGVyIGxvYWQ/IG1heWJlIHRoZXJlIGlzIGEgYmV0dGVyIHdheT9cblx0aWYoJC5qc3RyZWUpIHtcblx0XHRyZXR1cm47XG5cdH1cblxuXHQvKipcblx0ICogIyMjIGpzVHJlZSBjb3JlIGZ1bmN0aW9uYWxpdHlcblx0ICovXG5cblx0Ly8gaW50ZXJuYWwgdmFyaWFibGVzXG5cdHZhciBpbnN0YW5jZV9jb3VudGVyID0gMCxcblx0XHRjY3Bfbm9kZSA9IGZhbHNlLFxuXHRcdGNjcF9tb2RlID0gZmFsc2UsXG5cdFx0Y2NwX2luc3QgPSBmYWxzZSxcblx0XHR0aGVtZXNfbG9hZGVkID0gW10sXG5cdFx0c3JjID0gJCgnc2NyaXB0Omxhc3QnKS5hdHRyKCdzcmMnKSxcblx0XHRkb2N1bWVudCA9IHdpbmRvdy5kb2N1bWVudDsgLy8gbG9jYWwgdmFyaWFibGUgaXMgYWx3YXlzIGZhc3RlciB0byBhY2Nlc3MgdGhlbiBhIGdsb2JhbFxuXG5cdC8qKlxuXHQgKiBob2xkcyBhbGwganN0cmVlIHJlbGF0ZWQgZnVuY3Rpb25zIGFuZCB2YXJpYWJsZXMsIGluY2x1ZGluZyB0aGUgYWN0dWFsIGNsYXNzIGFuZCBtZXRob2RzIHRvIGNyZWF0ZSwgYWNjZXNzIGFuZCBtYW5pcHVsYXRlIGluc3RhbmNlcy5cblx0ICogQG5hbWUgJC5qc3RyZWVcblx0ICovXG5cdCQuanN0cmVlID0ge1xuXHRcdC8qKlxuXHRcdCAqIHNwZWNpZmllcyB0aGUganN0cmVlIHZlcnNpb24gaW4gdXNlXG5cdFx0ICogQG5hbWUgJC5qc3RyZWUudmVyc2lvblxuXHRcdCAqL1xuXHRcdHZlcnNpb24gOiAnMy4zLjMnLFxuXHRcdC8qKlxuXHRcdCAqIGhvbGRzIGFsbCB0aGUgZGVmYXVsdCBvcHRpb25zIHVzZWQgd2hlbiBjcmVhdGluZyBuZXcgaW5zdGFuY2VzXG5cdFx0ICogQG5hbWUgJC5qc3RyZWUuZGVmYXVsdHNcblx0XHQgKi9cblx0XHRkZWZhdWx0cyA6IHtcblx0XHRcdC8qKlxuXHRcdFx0ICogY29uZmlndXJlIHdoaWNoIHBsdWdpbnMgd2lsbCBiZSBhY3RpdmUgb24gYW4gaW5zdGFuY2UuIFNob3VsZCBiZSBhbiBhcnJheSBvZiBzdHJpbmdzLCB3aGVyZSBlYWNoIGVsZW1lbnQgaXMgYSBwbHVnaW4gbmFtZS4gVGhlIGRlZmF1bHQgaXMgYFtdYFxuXHRcdFx0ICogQG5hbWUgJC5qc3RyZWUuZGVmYXVsdHMucGx1Z2luc1xuXHRcdFx0ICovXG5cdFx0XHRwbHVnaW5zIDogW11cblx0XHR9LFxuXHRcdC8qKlxuXHRcdCAqIHN0b3JlcyBhbGwgbG9hZGVkIGpzdHJlZSBwbHVnaW5zICh1c2VkIGludGVybmFsbHkpXG5cdFx0ICogQG5hbWUgJC5qc3RyZWUucGx1Z2luc1xuXHRcdCAqL1xuXHRcdHBsdWdpbnMgOiB7fSxcblx0XHRwYXRoIDogc3JjICYmIHNyYy5pbmRleE9mKCcvJykgIT09IC0xID8gc3JjLnJlcGxhY2UoL1xcL1teXFwvXSskLywnJykgOiAnJyxcblx0XHRpZHJlZ2V4IDogL1tcXFxcOiYhXnwoKVxcW1xcXTw+QConK34jXCI7Liw9XFwtIFxcLyR7fSU/YF0vZyxcblx0XHRyb290IDogJyMnXG5cdH07XG5cdFxuXHQvKipcblx0ICogY3JlYXRlcyBhIGpzdHJlZSBpbnN0YW5jZVxuXHQgKiBAbmFtZSAkLmpzdHJlZS5jcmVhdGUoZWwgWywgb3B0aW9uc10pXG5cdCAqIEBwYXJhbSB7RE9NRWxlbWVudHxqUXVlcnl8U3RyaW5nfSBlbCB0aGUgZWxlbWVudCB0byBjcmVhdGUgdGhlIGluc3RhbmNlIG9uLCBjYW4gYmUgalF1ZXJ5IGV4dGVuZGVkIG9yIGEgc2VsZWN0b3Jcblx0ICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgb3B0aW9ucyBmb3IgdGhpcyBpbnN0YW5jZSAoZXh0ZW5kcyBgJC5qc3RyZWUuZGVmYXVsdHNgKVxuXHQgKiBAcmV0dXJuIHtqc1RyZWV9IHRoZSBuZXcgaW5zdGFuY2Vcblx0ICovXG5cdCQuanN0cmVlLmNyZWF0ZSA9IGZ1bmN0aW9uIChlbCwgb3B0aW9ucykge1xuXHRcdHZhciB0bXAgPSBuZXcgJC5qc3RyZWUuY29yZSgrK2luc3RhbmNlX2NvdW50ZXIpLFxuXHRcdFx0b3B0ID0gb3B0aW9ucztcblx0XHRvcHRpb25zID0gJC5leHRlbmQodHJ1ZSwge30sICQuanN0cmVlLmRlZmF1bHRzLCBvcHRpb25zKTtcblx0XHRpZihvcHQgJiYgb3B0LnBsdWdpbnMpIHtcblx0XHRcdG9wdGlvbnMucGx1Z2lucyA9IG9wdC5wbHVnaW5zO1xuXHRcdH1cblx0XHQkLmVhY2gob3B0aW9ucy5wbHVnaW5zLCBmdW5jdGlvbiAoaSwgaykge1xuXHRcdFx0aWYoaSAhPT0gJ2NvcmUnKSB7XG5cdFx0XHRcdHRtcCA9IHRtcC5wbHVnaW4oaywgb3B0aW9uc1trXSk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdFx0JChlbCkuZGF0YSgnanN0cmVlJywgdG1wKTtcblx0XHR0bXAuaW5pdChlbCwgb3B0aW9ucyk7XG5cdFx0cmV0dXJuIHRtcDtcblx0fTtcblx0LyoqXG5cdCAqIHJlbW92ZSBhbGwgdHJhY2VzIG9mIGpzdHJlZSBmcm9tIHRoZSBET00gYW5kIGRlc3Ryb3kgYWxsIGluc3RhbmNlc1xuXHQgKiBAbmFtZSAkLmpzdHJlZS5kZXN0cm95KClcblx0ICovXG5cdCQuanN0cmVlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG5cdFx0JCgnLmpzdHJlZTpqc3RyZWUnKS5qc3RyZWUoJ2Rlc3Ryb3knKTtcblx0XHQkKGRvY3VtZW50KS5vZmYoJy5qc3RyZWUnKTtcblx0fTtcblx0LyoqXG5cdCAqIHRoZSBqc3RyZWUgY2xhc3MgY29uc3RydWN0b3IsIHVzZWQgb25seSBpbnRlcm5hbGx5XG5cdCAqIEBwcml2YXRlXG5cdCAqIEBuYW1lICQuanN0cmVlLmNvcmUoaWQpXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBpZCB0aGlzIGluc3RhbmNlJ3MgaW5kZXhcblx0ICovXG5cdCQuanN0cmVlLmNvcmUgPSBmdW5jdGlvbiAoaWQpIHtcblx0XHR0aGlzLl9pZCA9IGlkO1xuXHRcdHRoaXMuX2NudCA9IDA7XG5cdFx0dGhpcy5fd3JrID0gbnVsbDtcblx0XHR0aGlzLl9kYXRhID0ge1xuXHRcdFx0Y29yZSA6IHtcblx0XHRcdFx0dGhlbWVzIDoge1xuXHRcdFx0XHRcdG5hbWUgOiBmYWxzZSxcblx0XHRcdFx0XHRkb3RzIDogZmFsc2UsXG5cdFx0XHRcdFx0aWNvbnMgOiBmYWxzZSxcblx0XHRcdFx0XHRlbGxpcHNpcyA6IGZhbHNlXG5cdFx0XHRcdH0sXG5cdFx0XHRcdHNlbGVjdGVkIDogW10sXG5cdFx0XHRcdGxhc3RfZXJyb3IgOiB7fSxcblx0XHRcdFx0d29ya2luZyA6IGZhbHNlLFxuXHRcdFx0XHR3b3JrZXJfcXVldWUgOiBbXSxcblx0XHRcdFx0Zm9jdXNlZCA6IG51bGxcblx0XHRcdH1cblx0XHR9O1xuXHR9O1xuXHQvKipcblx0ICogZ2V0IGEgcmVmZXJlbmNlIHRvIGFuIGV4aXN0aW5nIGluc3RhbmNlXG5cdCAqXG5cdCAqIF9fRXhhbXBsZXNfX1xuXHQgKlxuXHQgKlx0Ly8gcHJvdmlkZWQgYSBjb250YWluZXIgd2l0aCBhbiBJRCBvZiBcInRyZWVcIiwgYW5kIGEgbmVzdGVkIG5vZGUgd2l0aCBhbiBJRCBvZiBcImJyYW5jaFwiXG5cdCAqXHQvLyBhbGwgb2YgdGhlcmUgd2lsbCByZXR1cm4gdGhlIHNhbWUgaW5zdGFuY2Vcblx0ICpcdCQuanN0cmVlLnJlZmVyZW5jZSgndHJlZScpO1xuXHQgKlx0JC5qc3RyZWUucmVmZXJlbmNlKCcjdHJlZScpO1xuXHQgKlx0JC5qc3RyZWUucmVmZXJlbmNlKCQoJyN0cmVlJykpO1xuXHQgKlx0JC5qc3RyZWUucmVmZXJlbmNlKGRvY3VtZW50LmdldEVsZW1lbnRCeUlEKCd0cmVlJykpO1xuXHQgKlx0JC5qc3RyZWUucmVmZXJlbmNlKCdicmFuY2gnKTtcblx0ICpcdCQuanN0cmVlLnJlZmVyZW5jZSgnI2JyYW5jaCcpO1xuXHQgKlx0JC5qc3RyZWUucmVmZXJlbmNlKCQoJyNicmFuY2gnKSk7XG5cdCAqXHQkLmpzdHJlZS5yZWZlcmVuY2UoZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SUQoJ2JyYW5jaCcpKTtcblx0ICpcblx0ICogQG5hbWUgJC5qc3RyZWUucmVmZXJlbmNlKG5lZWRsZSlcblx0ICogQHBhcmFtIHtET01FbGVtZW50fGpRdWVyeXxTdHJpbmd9IG5lZWRsZVxuXHQgKiBAcmV0dXJuIHtqc1RyZWV8bnVsbH0gdGhlIGluc3RhbmNlIG9yIGBudWxsYCBpZiBub3QgZm91bmRcblx0ICovXG5cdCQuanN0cmVlLnJlZmVyZW5jZSA9IGZ1bmN0aW9uIChuZWVkbGUpIHtcblx0XHR2YXIgdG1wID0gbnVsbCxcblx0XHRcdG9iaiA9IG51bGw7XG5cdFx0aWYobmVlZGxlICYmIG5lZWRsZS5pZCAmJiAoIW5lZWRsZS50YWdOYW1lIHx8ICFuZWVkbGUubm9kZVR5cGUpKSB7IG5lZWRsZSA9IG5lZWRsZS5pZDsgfVxuXG5cdFx0aWYoIW9iaiB8fCAhb2JqLmxlbmd0aCkge1xuXHRcdFx0dHJ5IHsgb2JqID0gJChuZWVkbGUpOyB9IGNhdGNoIChpZ25vcmUpIHsgfVxuXHRcdH1cblx0XHRpZighb2JqIHx8ICFvYmoubGVuZ3RoKSB7XG5cdFx0XHR0cnkgeyBvYmogPSAkKCcjJyArIG5lZWRsZS5yZXBsYWNlKCQuanN0cmVlLmlkcmVnZXgsJ1xcXFwkJicpKTsgfSBjYXRjaCAoaWdub3JlKSB7IH1cblx0XHR9XG5cdFx0aWYob2JqICYmIG9iai5sZW5ndGggJiYgKG9iaiA9IG9iai5jbG9zZXN0KCcuanN0cmVlJykpLmxlbmd0aCAmJiAob2JqID0gb2JqLmRhdGEoJ2pzdHJlZScpKSkge1xuXHRcdFx0dG1wID0gb2JqO1xuXHRcdH1cblx0XHRlbHNlIHtcblx0XHRcdCQoJy5qc3RyZWUnKS5lYWNoKGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0dmFyIGluc3QgPSAkKHRoaXMpLmRhdGEoJ2pzdHJlZScpO1xuXHRcdFx0XHRpZihpbnN0ICYmIGluc3QuX21vZGVsLmRhdGFbbmVlZGxlXSkge1xuXHRcdFx0XHRcdHRtcCA9IGluc3Q7XG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHR9XG5cdFx0cmV0dXJuIHRtcDtcblx0fTtcblx0LyoqXG5cdCAqIENyZWF0ZSBhbiBpbnN0YW5jZSwgZ2V0IGFuIGluc3RhbmNlIG9yIGludm9rZSBhIGNvbW1hbmQgb24gYSBpbnN0YW5jZS5cblx0ICpcblx0ICogSWYgdGhlcmUgaXMgbm8gaW5zdGFuY2UgYXNzb2NpYXRlZCB3aXRoIHRoZSBjdXJyZW50IG5vZGUgYSBuZXcgb25lIGlzIGNyZWF0ZWQgYW5kIGBhcmdgIGlzIHVzZWQgdG8gZXh0ZW5kIGAkLmpzdHJlZS5kZWZhdWx0c2AgZm9yIHRoaXMgbmV3IGluc3RhbmNlLiBUaGVyZSB3b3VsZCBiZSBubyByZXR1cm4gdmFsdWUgKGNoYWluaW5nIGlzIG5vdCBicm9rZW4pLlxuXHQgKlxuXHQgKiBJZiB0aGVyZSBpcyBhbiBleGlzdGluZyBpbnN0YW5jZSBhbmQgYGFyZ2AgaXMgYSBzdHJpbmcgdGhlIGNvbW1hbmQgc3BlY2lmaWVkIGJ5IGBhcmdgIGlzIGV4ZWN1dGVkIG9uIHRoZSBpbnN0YW5jZSwgd2l0aCBhbnkgYWRkaXRpb25hbCBhcmd1bWVudHMgcGFzc2VkIHRvIHRoZSBmdW5jdGlvbi4gSWYgdGhlIGZ1bmN0aW9uIHJldHVybnMgYSB2YWx1ZSBpdCB3aWxsIGJlIHJldHVybmVkIChjaGFpbmluZyBjb3VsZCBicmVhayBkZXBlbmRpbmcgb24gZnVuY3Rpb24pLlxuXHQgKlxuXHQgKiBJZiB0aGVyZSBpcyBhbiBleGlzdGluZyBpbnN0YW5jZSBhbmQgYGFyZ2AgaXMgbm90IGEgc3RyaW5nIHRoZSBpbnN0YW5jZSBpdHNlbGYgaXMgcmV0dXJuZWQgKHNpbWlsYXIgdG8gYCQuanN0cmVlLnJlZmVyZW5jZWApLlxuXHQgKlxuXHQgKiBJbiBhbnkgb3RoZXIgY2FzZSAtIG5vdGhpbmcgaXMgcmV0dXJuZWQgYW5kIGNoYWluaW5nIGlzIG5vdCBicm9rZW4uXG5cdCAqXG5cdCAqIF9fRXhhbXBsZXNfX1xuXHQgKlxuXHQgKlx0JCgnI3RyZWUxJykuanN0cmVlKCk7IC8vIGNyZWF0ZXMgYW4gaW5zdGFuY2Vcblx0ICpcdCQoJyN0cmVlMicpLmpzdHJlZSh7IHBsdWdpbnMgOiBbXSB9KTsgLy8gY3JlYXRlIGFuIGluc3RhbmNlIHdpdGggc29tZSBvcHRpb25zXG5cdCAqXHQkKCcjdHJlZTEnKS5qc3RyZWUoJ29wZW5fbm9kZScsICcjYnJhbmNoXzEnKTsgLy8gY2FsbCBhIG1ldGhvZCBvbiBhbiBleGlzdGluZyBpbnN0YW5jZSwgcGFzc2luZyBhZGRpdGlvbmFsIGFyZ3VtZW50c1xuXHQgKlx0JCgnI3RyZWUyJykuanN0cmVlKCk7IC8vIGdldCBhbiBleGlzdGluZyBpbnN0YW5jZSAob3IgY3JlYXRlIGFuIGluc3RhbmNlKVxuXHQgKlx0JCgnI3RyZWUyJykuanN0cmVlKHRydWUpOyAvLyBnZXQgYW4gZXhpc3RpbmcgaW5zdGFuY2UgKHdpbGwgbm90IGNyZWF0ZSBuZXcgaW5zdGFuY2UpXG5cdCAqXHQkKCcjYnJhbmNoXzEnKS5qc3RyZWUoKS5zZWxlY3Rfbm9kZSgnI2JyYW5jaF8xJyk7IC8vIGdldCBhbiBpbnN0YW5jZSAodXNpbmcgYSBuZXN0ZWQgZWxlbWVudCBhbmQgY2FsbCBhIG1ldGhvZClcblx0ICpcblx0ICogQG5hbWUgJCgpLmpzdHJlZShbYXJnXSlcblx0ICogQHBhcmFtIHtTdHJpbmd8T2JqZWN0fSBhcmdcblx0ICogQHJldHVybiB7TWl4ZWR9XG5cdCAqL1xuXHQkLmZuLmpzdHJlZSA9IGZ1bmN0aW9uIChhcmcpIHtcblx0XHQvLyBjaGVjayBmb3Igc3RyaW5nIGFyZ3VtZW50XG5cdFx0dmFyIGlzX21ldGhvZFx0PSAodHlwZW9mIGFyZyA9PT0gJ3N0cmluZycpLFxuXHRcdFx0YXJnc1x0XHQ9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSksXG5cdFx0XHRyZXN1bHRcdFx0PSBudWxsO1xuXHRcdGlmKGFyZyA9PT0gdHJ1ZSAmJiAhdGhpcy5sZW5ndGgpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdFx0dGhpcy5lYWNoKGZ1bmN0aW9uICgpIHtcblx0XHRcdC8vIGdldCB0aGUgaW5zdGFuY2UgKGlmIHRoZXJlIGlzIG9uZSkgYW5kIG1ldGhvZCAoaWYgaXQgZXhpc3RzKVxuXHRcdFx0dmFyIGluc3RhbmNlID0gJC5qc3RyZWUucmVmZXJlbmNlKHRoaXMpLFxuXHRcdFx0XHRtZXRob2QgPSBpc19tZXRob2QgJiYgaW5zdGFuY2UgPyBpbnN0YW5jZVthcmddIDogbnVsbDtcblx0XHRcdC8vIGlmIGNhbGxpbmcgYSBtZXRob2QsIGFuZCBtZXRob2QgaXMgYXZhaWxhYmxlIC0gZXhlY3V0ZSBvbiB0aGUgaW5zdGFuY2Vcblx0XHRcdHJlc3VsdCA9IGlzX21ldGhvZCAmJiBtZXRob2QgP1xuXHRcdFx0XHRtZXRob2QuYXBwbHkoaW5zdGFuY2UsIGFyZ3MpIDpcblx0XHRcdFx0bnVsbDtcblx0XHRcdC8vIGlmIHRoZXJlIGlzIG5vIGluc3RhbmNlIGFuZCBubyBtZXRob2QgaXMgYmVpbmcgY2FsbGVkIC0gY3JlYXRlIG9uZVxuXHRcdFx0aWYoIWluc3RhbmNlICYmICFpc19tZXRob2QgJiYgKGFyZyA9PT0gdW5kZWZpbmVkIHx8ICQuaXNQbGFpbk9iamVjdChhcmcpKSkge1xuXHRcdFx0XHQkLmpzdHJlZS5jcmVhdGUodGhpcywgYXJnKTtcblx0XHRcdH1cblx0XHRcdC8vIGlmIHRoZXJlIGlzIGFuIGluc3RhbmNlIGFuZCBubyBtZXRob2QgaXMgY2FsbGVkIC0gcmV0dXJuIHRoZSBpbnN0YW5jZVxuXHRcdFx0aWYoIChpbnN0YW5jZSAmJiAhaXNfbWV0aG9kKSB8fCBhcmcgPT09IHRydWUgKSB7XG5cdFx0XHRcdHJlc3VsdCA9IGluc3RhbmNlIHx8IGZhbHNlO1xuXHRcdFx0fVxuXHRcdFx0Ly8gaWYgdGhlcmUgd2FzIGEgbWV0aG9kIGNhbGwgd2hpY2ggcmV0dXJuZWQgYSByZXN1bHQgLSBicmVhayBhbmQgcmV0dXJuIHRoZSB2YWx1ZVxuXHRcdFx0aWYocmVzdWx0ICE9PSBudWxsICYmIHJlc3VsdCAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblx0XHR9KTtcblx0XHQvLyBpZiB0aGVyZSB3YXMgYSBtZXRob2QgY2FsbCB3aXRoIGEgdmFsaWQgcmV0dXJuIHZhbHVlIC0gcmV0dXJuIHRoYXQsIG90aGVyd2lzZSBjb250aW51ZSB0aGUgY2hhaW5cblx0XHRyZXR1cm4gcmVzdWx0ICE9PSBudWxsICYmIHJlc3VsdCAhPT0gdW5kZWZpbmVkID9cblx0XHRcdHJlc3VsdCA6IHRoaXM7XG5cdH07XG5cdC8qKlxuXHQgKiB1c2VkIHRvIGZpbmQgZWxlbWVudHMgY29udGFpbmluZyBhbiBpbnN0YW5jZVxuXHQgKlxuXHQgKiBfX0V4YW1wbGVzX19cblx0ICpcblx0ICpcdCQoJ2Rpdjpqc3RyZWUnKS5lYWNoKGZ1bmN0aW9uICgpIHtcblx0ICpcdFx0JCh0aGlzKS5qc3RyZWUoJ2Rlc3Ryb3knKTtcblx0ICpcdH0pO1xuXHQgKlxuXHQgKiBAbmFtZSAkKCc6anN0cmVlJylcblx0ICogQHJldHVybiB7alF1ZXJ5fVxuXHQgKi9cblx0JC5leHByLnBzZXVkb3MuanN0cmVlID0gJC5leHByLmNyZWF0ZVBzZXVkbyhmdW5jdGlvbihzZWFyY2gpIHtcblx0XHRyZXR1cm4gZnVuY3Rpb24oYSkge1xuXHRcdFx0cmV0dXJuICQoYSkuaGFzQ2xhc3MoJ2pzdHJlZScpICYmXG5cdFx0XHRcdCQoYSkuZGF0YSgnanN0cmVlJykgIT09IHVuZGVmaW5lZDtcblx0XHR9O1xuXHR9KTtcblxuXHQvKipcblx0ICogc3RvcmVzIGFsbCBkZWZhdWx0cyBmb3IgdGhlIGNvcmVcblx0ICogQG5hbWUgJC5qc3RyZWUuZGVmYXVsdHMuY29yZVxuXHQgKi9cblx0JC5qc3RyZWUuZGVmYXVsdHMuY29yZSA9IHtcblx0XHQvKipcblx0XHQgKiBkYXRhIGNvbmZpZ3VyYXRpb25cblx0XHQgKlxuXHRcdCAqIElmIGxlZnQgYXMgYGZhbHNlYCB0aGUgSFRNTCBpbnNpZGUgdGhlIGpzdHJlZSBjb250YWluZXIgZWxlbWVudCBpcyB1c2VkIHRvIHBvcHVsYXRlIHRoZSB0cmVlICh0aGF0IHNob3VsZCBiZSBhbiB1bm9yZGVyZWQgbGlzdCB3aXRoIGxpc3QgaXRlbXMpLlxuXHRcdCAqXG5cdFx0ICogWW91IGNhbiBhbHNvIHBhc3MgaW4gYSBIVE1MIHN0cmluZyBvciBhIEpTT04gYXJyYXkgaGVyZS5cblx0XHQgKlxuXHRcdCAqIEl0IGlzIHBvc3NpYmxlIHRvIHBhc3MgaW4gYSBzdGFuZGFyZCBqUXVlcnktbGlrZSBBSkFYIGNvbmZpZyBhbmQganN0cmVlIHdpbGwgYXV0b21hdGljYWxseSBkZXRlcm1pbmUgaWYgdGhlIHJlc3BvbnNlIGlzIEpTT04gb3IgSFRNTCBhbmQgdXNlIHRoYXQgdG8gcG9wdWxhdGUgdGhlIHRyZWUuXG5cdFx0ICogSW4gYWRkaXRpb24gdG8gdGhlIHN0YW5kYXJkIGpRdWVyeSBhamF4IG9wdGlvbnMgaGVyZSB5b3UgY2FuIHN1cHB5IGZ1bmN0aW9ucyBmb3IgYGRhdGFgIGFuZCBgdXJsYCwgdGhlIGZ1bmN0aW9ucyB3aWxsIGJlIHJ1biBpbiB0aGUgY3VycmVudCBpbnN0YW5jZSdzIHNjb3BlIGFuZCBhIHBhcmFtIHdpbGwgYmUgcGFzc2VkIGluZGljYXRpbmcgd2hpY2ggbm9kZSBpcyBiZWluZyBsb2FkZWQsIHRoZSByZXR1cm4gdmFsdWUgb2YgdGhvc2UgZnVuY3Rpb25zIHdpbGwgYmUgdXNlZC5cblx0XHQgKlxuXHRcdCAqIFRoZSBsYXN0IG9wdGlvbiBpcyB0byBzcGVjaWZ5IGEgZnVuY3Rpb24sIHRoYXQgZnVuY3Rpb24gd2lsbCByZWNlaXZlIHRoZSBub2RlIGJlaW5nIGxvYWRlZCBhcyBhcmd1bWVudCBhbmQgYSBzZWNvbmQgcGFyYW0gd2hpY2ggaXMgYSBmdW5jdGlvbiB3aGljaCBzaG91bGQgYmUgY2FsbGVkIHdpdGggdGhlIHJlc3VsdC5cblx0XHQgKlxuXHRcdCAqIF9fRXhhbXBsZXNfX1xuXHRcdCAqXG5cdFx0ICpcdC8vIEFKQVhcblx0XHQgKlx0JCgnI3RyZWUnKS5qc3RyZWUoe1xuXHRcdCAqXHRcdCdjb3JlJyA6IHtcblx0XHQgKlx0XHRcdCdkYXRhJyA6IHtcblx0XHQgKlx0XHRcdFx0J3VybCcgOiAnL2dldC9jaGlsZHJlbi8nLFxuXHRcdCAqXHRcdFx0XHQnZGF0YScgOiBmdW5jdGlvbiAobm9kZSkge1xuXHRcdCAqXHRcdFx0XHRcdHJldHVybiB7ICdpZCcgOiBub2RlLmlkIH07XG5cdFx0ICpcdFx0XHRcdH1cblx0XHQgKlx0XHRcdH1cblx0XHQgKlx0XHR9KTtcblx0XHQgKlxuXHRcdCAqXHQvLyBkaXJlY3QgZGF0YVxuXHRcdCAqXHQkKCcjdHJlZScpLmpzdHJlZSh7XG5cdFx0ICpcdFx0J2NvcmUnIDoge1xuXHRcdCAqXHRcdFx0J2RhdGEnIDogW1xuXHRcdCAqXHRcdFx0XHQnU2ltcGxlIHJvb3Qgbm9kZScsXG5cdFx0ICpcdFx0XHRcdHtcblx0XHQgKlx0XHRcdFx0XHQnaWQnIDogJ25vZGVfMicsXG5cdFx0ICpcdFx0XHRcdFx0J3RleHQnIDogJ1Jvb3Qgbm9kZSB3aXRoIG9wdGlvbnMnLFxuXHRcdCAqXHRcdFx0XHRcdCdzdGF0ZScgOiB7ICdvcGVuZWQnIDogdHJ1ZSwgJ3NlbGVjdGVkJyA6IHRydWUgfSxcblx0XHQgKlx0XHRcdFx0XHQnY2hpbGRyZW4nIDogWyB7ICd0ZXh0JyA6ICdDaGlsZCAxJyB9LCAnQ2hpbGQgMiddXG5cdFx0ICpcdFx0XHRcdH1cblx0XHQgKlx0XHRcdF1cblx0XHQgKlx0XHR9XG5cdFx0ICpcdH0pO1xuXHRcdCAqXG5cdFx0ICpcdC8vIGZ1bmN0aW9uXG5cdFx0ICpcdCQoJyN0cmVlJykuanN0cmVlKHtcblx0XHQgKlx0XHQnY29yZScgOiB7XG5cdFx0ICpcdFx0XHQnZGF0YScgOiBmdW5jdGlvbiAob2JqLCBjYWxsYmFjaykge1xuXHRcdCAqXHRcdFx0XHRjYWxsYmFjay5jYWxsKHRoaXMsIFsnUm9vdCAxJywgJ1Jvb3QgMiddKTtcblx0XHQgKlx0XHRcdH1cblx0XHQgKlx0XHR9KTtcblx0XHQgKlxuXHRcdCAqIEBuYW1lICQuanN0cmVlLmRlZmF1bHRzLmNvcmUuZGF0YVxuXHRcdCAqL1xuXHRcdGRhdGFcdFx0XHQ6IGZhbHNlLFxuXHRcdC8qKlxuXHRcdCAqIGNvbmZpZ3VyZSB0aGUgdmFyaW91cyBzdHJpbmdzIHVzZWQgdGhyb3VnaG91dCB0aGUgdHJlZVxuXHRcdCAqXG5cdFx0ICogWW91IGNhbiB1c2UgYW4gb2JqZWN0IHdoZXJlIHRoZSBrZXkgaXMgdGhlIHN0cmluZyB5b3UgbmVlZCB0byByZXBsYWNlIGFuZCB0aGUgdmFsdWUgaXMgeW91ciByZXBsYWNlbWVudC5cblx0XHQgKiBBbm90aGVyIG9wdGlvbiBpcyB0byBzcGVjaWZ5IGEgZnVuY3Rpb24gd2hpY2ggd2lsbCBiZSBjYWxsZWQgd2l0aCBhbiBhcmd1bWVudCBvZiB0aGUgbmVlZGVkIHN0cmluZyBhbmQgc2hvdWxkIHJldHVybiB0aGUgcmVwbGFjZW1lbnQuXG5cdFx0ICogSWYgbGVmdCBhcyBgZmFsc2VgIG5vIHJlcGxhY2VtZW50IGlzIG1hZGUuXG5cdFx0ICpcblx0XHQgKiBfX0V4YW1wbGVzX19cblx0XHQgKlxuXHRcdCAqXHQkKCcjdHJlZScpLmpzdHJlZSh7XG5cdFx0ICpcdFx0J2NvcmUnIDoge1xuXHRcdCAqXHRcdFx0J3N0cmluZ3MnIDoge1xuXHRcdCAqXHRcdFx0XHQnTG9hZGluZyAuLi4nIDogJ1BsZWFzZSB3YWl0IC4uLidcblx0XHQgKlx0XHRcdH1cblx0XHQgKlx0XHR9XG5cdFx0ICpcdH0pO1xuXHRcdCAqXG5cdFx0ICogQG5hbWUgJC5qc3RyZWUuZGVmYXVsdHMuY29yZS5zdHJpbmdzXG5cdFx0ICovXG5cdFx0c3RyaW5nc1x0XHRcdDogZmFsc2UsXG5cdFx0LyoqXG5cdFx0ICogZGV0ZXJtaW5lcyB3aGF0IGhhcHBlbnMgd2hlbiBhIHVzZXIgdHJpZXMgdG8gbW9kaWZ5IHRoZSBzdHJ1Y3R1cmUgb2YgdGhlIHRyZWVcblx0XHQgKiBJZiBsZWZ0IGFzIGBmYWxzZWAgYWxsIG9wZXJhdGlvbnMgbGlrZSBjcmVhdGUsIHJlbmFtZSwgZGVsZXRlLCBtb3ZlIG9yIGNvcHkgYXJlIHByZXZlbnRlZC5cblx0XHQgKiBZb3UgY2FuIHNldCB0aGlzIHRvIGB0cnVlYCB0byBhbGxvdyBhbGwgaW50ZXJhY3Rpb25zIG9yIHVzZSBhIGZ1bmN0aW9uIHRvIGhhdmUgYmV0dGVyIGNvbnRyb2wuXG5cdFx0ICpcblx0XHQgKiBfX0V4YW1wbGVzX19cblx0XHQgKlxuXHRcdCAqXHQkKCcjdHJlZScpLmpzdHJlZSh7XG5cdFx0ICpcdFx0J2NvcmUnIDoge1xuXHRcdCAqXHRcdFx0J2NoZWNrX2NhbGxiYWNrJyA6IGZ1bmN0aW9uIChvcGVyYXRpb24sIG5vZGUsIG5vZGVfcGFyZW50LCBub2RlX3Bvc2l0aW9uLCBtb3JlKSB7XG5cdFx0ICpcdFx0XHRcdC8vIG9wZXJhdGlvbiBjYW4gYmUgJ2NyZWF0ZV9ub2RlJywgJ3JlbmFtZV9ub2RlJywgJ2RlbGV0ZV9ub2RlJywgJ21vdmVfbm9kZScgb3IgJ2NvcHlfbm9kZSdcblx0XHQgKlx0XHRcdFx0Ly8gaW4gY2FzZSBvZiAncmVuYW1lX25vZGUnIG5vZGVfcG9zaXRpb24gaXMgZmlsbGVkIHdpdGggdGhlIG5ldyBub2RlIG5hbWVcblx0XHQgKlx0XHRcdFx0cmV0dXJuIG9wZXJhdGlvbiA9PT0gJ3JlbmFtZV9ub2RlJyA/IHRydWUgOiBmYWxzZTtcblx0XHQgKlx0XHRcdH1cblx0XHQgKlx0XHR9XG5cdFx0ICpcdH0pO1xuXHRcdCAqXG5cdFx0ICogQG5hbWUgJC5qc3RyZWUuZGVmYXVsdHMuY29yZS5jaGVja19jYWxsYmFja1xuXHRcdCAqL1xuXHRcdGNoZWNrX2NhbGxiYWNrXHQ6IGZhbHNlLFxuXHRcdC8qKlxuXHRcdCAqIGEgY2FsbGJhY2sgY2FsbGVkIHdpdGggYSBzaW5nbGUgb2JqZWN0IHBhcmFtZXRlciBpbiB0aGUgaW5zdGFuY2UncyBzY29wZSB3aGVuIHNvbWV0aGluZyBnb2VzIHdyb25nIChvcGVyYXRpb24gcHJldmVudGVkLCBhamF4IGZhaWxlZCwgZXRjKVxuXHRcdCAqIEBuYW1lICQuanN0cmVlLmRlZmF1bHRzLmNvcmUuZXJyb3Jcblx0XHQgKi9cblx0XHRlcnJvclx0XHRcdDogJC5ub29wLFxuXHRcdC8qKlxuXHRcdCAqIHRoZSBvcGVuIC8gY2xvc2UgYW5pbWF0aW9uIGR1cmF0aW9uIGluIG1pbGxpc2Vjb25kcyAtIHNldCB0aGlzIHRvIGBmYWxzZWAgdG8gZGlzYWJsZSB0aGUgYW5pbWF0aW9uIChkZWZhdWx0IGlzIGAyMDBgKVxuXHRcdCAqIEBuYW1lICQuanN0cmVlLmRlZmF1bHRzLmNvcmUuYW5pbWF0aW9uXG5cdFx0ICovXG5cdFx0YW5pbWF0aW9uXHRcdDogMjAwLFxuXHRcdC8qKlxuXHRcdCAqIGEgYm9vbGVhbiBpbmRpY2F0aW5nIGlmIG11bHRpcGxlIG5vZGVzIGNhbiBiZSBzZWxlY3RlZFxuXHRcdCAqIEBuYW1lICQuanN0cmVlLmRlZmF1bHRzLmNvcmUubXVsdGlwbGVcblx0XHQgKi9cblx0XHRtdWx0aXBsZVx0XHQ6IHRydWUsXG5cdFx0LyoqXG5cdFx0ICogdGhlbWUgY29uZmlndXJhdGlvbiBvYmplY3Rcblx0XHQgKiBAbmFtZSAkLmpzdHJlZS5kZWZhdWx0cy5jb3JlLnRoZW1lc1xuXHRcdCAqL1xuXHRcdHRoZW1lc1x0XHRcdDoge1xuXHRcdFx0LyoqXG5cdFx0XHQgKiB0aGUgbmFtZSBvZiB0aGUgdGhlbWUgdG8gdXNlIChpZiBsZWZ0IGFzIGBmYWxzZWAgdGhlIGRlZmF1bHQgdGhlbWUgaXMgdXNlZClcblx0XHRcdCAqIEBuYW1lICQuanN0cmVlLmRlZmF1bHRzLmNvcmUudGhlbWVzLm5hbWVcblx0XHRcdCAqL1xuXHRcdFx0bmFtZVx0XHRcdDogZmFsc2UsXG5cdFx0XHQvKipcblx0XHRcdCAqIHRoZSBVUkwgb2YgdGhlIHRoZW1lJ3MgQ1NTIGZpbGUsIGxlYXZlIHRoaXMgYXMgYGZhbHNlYCBpZiB5b3UgaGF2ZSBtYW51YWxseSBpbmNsdWRlZCB0aGUgdGhlbWUgQ1NTIChyZWNvbW1lbmRlZCkuIFlvdSBjYW4gc2V0IHRoaXMgdG8gYHRydWVgIHRvbyB3aGljaCB3aWxsIHRyeSB0byBhdXRvbG9hZCB0aGUgdGhlbWUuXG5cdFx0XHQgKiBAbmFtZSAkLmpzdHJlZS5kZWZhdWx0cy5jb3JlLnRoZW1lcy51cmxcblx0XHRcdCAqL1xuXHRcdFx0dXJsXHRcdFx0XHQ6IGZhbHNlLFxuXHRcdFx0LyoqXG5cdFx0XHQgKiB0aGUgbG9jYXRpb24gb2YgYWxsIGpzdHJlZSB0aGVtZXMgLSBvbmx5IHVzZWQgaWYgYHVybGAgaXMgc2V0IHRvIGB0cnVlYFxuXHRcdFx0ICogQG5hbWUgJC5qc3RyZWUuZGVmYXVsdHMuY29yZS50aGVtZXMuZGlyXG5cdFx0XHQgKi9cblx0XHRcdGRpclx0XHRcdFx0OiBmYWxzZSxcblx0XHRcdC8qKlxuXHRcdFx0ICogYSBib29sZWFuIGluZGljYXRpbmcgaWYgY29ubmVjdGluZyBkb3RzIGFyZSBzaG93blxuXHRcdFx0ICogQG5hbWUgJC5qc3RyZWUuZGVmYXVsdHMuY29yZS50aGVtZXMuZG90c1xuXHRcdFx0ICovXG5cdFx0XHRkb3RzXHRcdFx0OiB0cnVlLFxuXHRcdFx0LyoqXG5cdFx0XHQgKiBhIGJvb2xlYW4gaW5kaWNhdGluZyBpZiBub2RlIGljb25zIGFyZSBzaG93blxuXHRcdFx0ICogQG5hbWUgJC5qc3RyZWUuZGVmYXVsdHMuY29yZS50aGVtZXMuaWNvbnNcblx0XHRcdCAqL1xuXHRcdFx0aWNvbnNcdFx0XHQ6IHRydWUsXG5cdFx0XHQvKipcblx0XHRcdCAqIGEgYm9vbGVhbiBpbmRpY2F0aW5nIGlmIG5vZGUgZWxsaXBzaXMgc2hvdWxkIGJlIHNob3duIC0gdGhpcyBvbmx5IHdvcmtzIHdpdGggYSBmaXhlZCB3aXRoIG9uIHRoZSBjb250YWluZXJcblx0XHRcdCAqIEBuYW1lICQuanN0cmVlLmRlZmF1bHRzLmNvcmUudGhlbWVzLmVsbGlwc2lzXG5cdFx0XHQgKi9cblx0XHRcdGVsbGlwc2lzXHRcdDogZmFsc2UsXG5cdFx0XHQvKipcblx0XHRcdCAqIGEgYm9vbGVhbiBpbmRpY2F0aW5nIGlmIHRoZSB0cmVlIGJhY2tncm91bmQgaXMgc3RyaXBlZFxuXHRcdFx0ICogQG5hbWUgJC5qc3RyZWUuZGVmYXVsdHMuY29yZS50aGVtZXMuc3RyaXBlc1xuXHRcdFx0ICovXG5cdFx0XHRzdHJpcGVzXHRcdFx0OiBmYWxzZSxcblx0XHRcdC8qKlxuXHRcdFx0ICogYSBzdHJpbmcgKG9yIGJvb2xlYW4gYGZhbHNlYCkgc3BlY2lmeWluZyB0aGUgdGhlbWUgdmFyaWFudCB0byB1c2UgKGlmIHRoZSB0aGVtZSBzdXBwb3J0cyB2YXJpYW50cylcblx0XHRcdCAqIEBuYW1lICQuanN0cmVlLmRlZmF1bHRzLmNvcmUudGhlbWVzLnZhcmlhbnRcblx0XHRcdCAqL1xuXHRcdFx0dmFyaWFudFx0XHRcdDogZmFsc2UsXG5cdFx0XHQvKipcblx0XHRcdCAqIGEgYm9vbGVhbiBzcGVjaWZ5aW5nIGlmIGEgcmVwb25zaXZlIHZlcnNpb24gb2YgdGhlIHRoZW1lIHNob3VsZCBraWNrIGluIG9uIHNtYWxsZXIgc2NyZWVucyAoaWYgdGhlIHRoZW1lIHN1cHBvcnRzIGl0KS4gRGVmYXVsdHMgdG8gYGZhbHNlYC5cblx0XHRcdCAqIEBuYW1lICQuanN0cmVlLmRlZmF1bHRzLmNvcmUudGhlbWVzLnJlc3BvbnNpdmVcblx0XHRcdCAqL1xuXHRcdFx0cmVzcG9uc2l2ZVx0XHQ6IGZhbHNlXG5cdFx0fSxcblx0XHQvKipcblx0XHQgKiBpZiBsZWZ0IGFzIGB0cnVlYCBhbGwgcGFyZW50cyBvZiBhbGwgc2VsZWN0ZWQgbm9kZXMgd2lsbCBiZSBvcGVuZWQgb25jZSB0aGUgdHJlZSBsb2FkcyAoc28gdGhhdCBhbGwgc2VsZWN0ZWQgbm9kZXMgYXJlIHZpc2libGUgdG8gdGhlIHVzZXIpXG5cdFx0ICogQG5hbWUgJC5qc3RyZWUuZGVmYXVsdHMuY29yZS5leHBhbmRfc2VsZWN0ZWRfb25sb2FkXG5cdFx0ICovXG5cdFx0ZXhwYW5kX3NlbGVjdGVkX29ubG9hZCA6IHRydWUsXG5cdFx0LyoqXG5cdFx0ICogaWYgbGVmdCBhcyBgdHJ1ZWAgd2ViIHdvcmtlcnMgd2lsbCBiZSB1c2VkIHRvIHBhcnNlIGluY29taW5nIEpTT04gZGF0YSB3aGVyZSBwb3NzaWJsZSwgc28gdGhhdCB0aGUgVUkgd2lsbCBub3QgYmUgYmxvY2tlZCBieSBsYXJnZSByZXF1ZXN0cy4gV29ya2VycyBhcmUgaG93ZXZlciBhYm91dCAzMCUgc2xvd2VyLiBEZWZhdWx0cyB0byBgdHJ1ZWBcblx0XHQgKiBAbmFtZSAkLmpzdHJlZS5kZWZhdWx0cy5jb3JlLndvcmtlclxuXHRcdCAqL1xuXHRcdHdvcmtlciA6IHRydWUsXG5cdFx0LyoqXG5cdFx0ICogRm9yY2Ugbm9kZSB0ZXh0IHRvIHBsYWluIHRleHQgKGFuZCBlc2NhcGUgSFRNTCkuIERlZmF1bHRzIHRvIGBmYWxzZWBcblx0XHQgKiBAbmFtZSAkLmpzdHJlZS5kZWZhdWx0cy5jb3JlLmZvcmNlX3RleHRcblx0XHQgKi9cblx0XHRmb3JjZV90ZXh0IDogZmFsc2UsXG5cdFx0LyoqXG5cdFx0ICogU2hvdWxkIHRoZSBub2RlIHNob3VsZCBiZSB0b2dnbGVkIGlmIHRoZSB0ZXh0IGlzIGRvdWJsZSBjbGlja2VkIC4gRGVmYXVsdHMgdG8gYHRydWVgXG5cdFx0ICogQG5hbWUgJC5qc3RyZWUuZGVmYXVsdHMuY29yZS5kYmxjbGlja190b2dnbGVcblx0XHQgKi9cblx0XHRkYmxjbGlja190b2dnbGUgOiB0cnVlXG5cdH07XG5cdCQuanN0cmVlLmNvcmUucHJvdG90eXBlID0ge1xuXHRcdC8qKlxuXHRcdCAqIHVzZWQgdG8gZGVjb3JhdGUgYW4gaW5zdGFuY2Ugd2l0aCBhIHBsdWdpbi4gVXNlZCBpbnRlcm5hbGx5LlxuXHRcdCAqIEBwcml2YXRlXG5cdFx0ICogQG5hbWUgcGx1Z2luKGRlY28gWywgb3B0c10pXG5cdFx0ICogQHBhcmFtICB7U3RyaW5nfSBkZWNvIHRoZSBwbHVnaW4gdG8gZGVjb3JhdGUgd2l0aFxuXHRcdCAqIEBwYXJhbSAge09iamVjdH0gb3B0cyBvcHRpb25zIGZvciB0aGUgcGx1Z2luXG5cdFx0ICogQHJldHVybiB7anNUcmVlfVxuXHRcdCAqL1xuXHRcdHBsdWdpbiA6IGZ1bmN0aW9uIChkZWNvLCBvcHRzKSB7XG5cdFx0XHR2YXIgQ2hpbGQgPSAkLmpzdHJlZS5wbHVnaW5zW2RlY29dO1xuXHRcdFx0aWYoQ2hpbGQpIHtcblx0XHRcdFx0dGhpcy5fZGF0YVtkZWNvXSA9IHt9O1xuXHRcdFx0XHRDaGlsZC5wcm90b3R5cGUgPSB0aGlzO1xuXHRcdFx0XHRyZXR1cm4gbmV3IENoaWxkKG9wdHMsIHRoaXMpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fSxcblx0XHQvKipcblx0XHQgKiBpbml0aWFsaXplIHRoZSBpbnN0YW5jZS4gVXNlZCBpbnRlcm5hbGx5LlxuXHRcdCAqIEBwcml2YXRlXG5cdFx0ICogQG5hbWUgaW5pdChlbCwgb3B0b25zKVxuXHRcdCAqIEBwYXJhbSB7RE9NRWxlbWVudHxqUXVlcnl8U3RyaW5nfSBlbCB0aGUgZWxlbWVudCB3ZSBhcmUgdHJhbnNmb3JtaW5nXG5cdFx0ICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgb3B0aW9ucyBmb3IgdGhpcyBpbnN0YW5jZVxuXHRcdCAqIEB0cmlnZ2VyIGluaXQuanN0cmVlLCBsb2FkaW5nLmpzdHJlZSwgbG9hZGVkLmpzdHJlZSwgcmVhZHkuanN0cmVlLCBjaGFuZ2VkLmpzdHJlZVxuXHRcdCAqL1xuXHRcdGluaXQgOiBmdW5jdGlvbiAoZWwsIG9wdGlvbnMpIHtcblx0XHRcdHRoaXMuX21vZGVsID0ge1xuXHRcdFx0XHRkYXRhIDoge30sXG5cdFx0XHRcdGNoYW5nZWQgOiBbXSxcblx0XHRcdFx0Zm9yY2VfZnVsbF9yZWRyYXcgOiBmYWxzZSxcblx0XHRcdFx0cmVkcmF3X3RpbWVvdXQgOiBmYWxzZSxcblx0XHRcdFx0ZGVmYXVsdF9zdGF0ZSA6IHtcblx0XHRcdFx0XHRsb2FkZWQgOiB0cnVlLFxuXHRcdFx0XHRcdG9wZW5lZCA6IGZhbHNlLFxuXHRcdFx0XHRcdHNlbGVjdGVkIDogZmFsc2UsXG5cdFx0XHRcdFx0ZGlzYWJsZWQgOiBmYWxzZVxuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXHRcdFx0dGhpcy5fbW9kZWwuZGF0YVskLmpzdHJlZS5yb290XSA9IHtcblx0XHRcdFx0aWQgOiAkLmpzdHJlZS5yb290LFxuXHRcdFx0XHRwYXJlbnQgOiBudWxsLFxuXHRcdFx0XHRwYXJlbnRzIDogW10sXG5cdFx0XHRcdGNoaWxkcmVuIDogW10sXG5cdFx0XHRcdGNoaWxkcmVuX2QgOiBbXSxcblx0XHRcdFx0c3RhdGUgOiB7IGxvYWRlZCA6IGZhbHNlIH1cblx0XHRcdH07XG5cblx0XHRcdHRoaXMuZWxlbWVudCA9ICQoZWwpLmFkZENsYXNzKCdqc3RyZWUganN0cmVlLScgKyB0aGlzLl9pZCk7XG5cdFx0XHR0aGlzLnNldHRpbmdzID0gb3B0aW9ucztcblxuXHRcdFx0dGhpcy5fZGF0YS5jb3JlLnJlYWR5ID0gZmFsc2U7XG5cdFx0XHR0aGlzLl9kYXRhLmNvcmUubG9hZGVkID0gZmFsc2U7XG5cdFx0XHR0aGlzLl9kYXRhLmNvcmUucnRsID0gKHRoaXMuZWxlbWVudC5jc3MoXCJkaXJlY3Rpb25cIikgPT09IFwicnRsXCIpO1xuXHRcdFx0dGhpcy5lbGVtZW50W3RoaXMuX2RhdGEuY29yZS5ydGwgPyAnYWRkQ2xhc3MnIDogJ3JlbW92ZUNsYXNzJ10oXCJqc3RyZWUtcnRsXCIpO1xuXHRcdFx0dGhpcy5lbGVtZW50LmF0dHIoJ3JvbGUnLCd0cmVlJyk7XG5cdFx0XHRpZih0aGlzLnNldHRpbmdzLmNvcmUubXVsdGlwbGUpIHtcblx0XHRcdFx0dGhpcy5lbGVtZW50LmF0dHIoJ2FyaWEtbXVsdGlzZWxlY3RhYmxlJywgdHJ1ZSk7XG5cdFx0XHR9XG5cdFx0XHRpZighdGhpcy5lbGVtZW50LmF0dHIoJ3RhYmluZGV4JykpIHtcblx0XHRcdFx0dGhpcy5lbGVtZW50LmF0dHIoJ3RhYmluZGV4JywnMCcpO1xuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLmJpbmQoKTtcblx0XHRcdC8qKlxuXHRcdFx0ICogdHJpZ2dlcmVkIGFmdGVyIGFsbCBldmVudHMgYXJlIGJvdW5kXG5cdFx0XHQgKiBAZXZlbnRcblx0XHRcdCAqIEBuYW1lIGluaXQuanN0cmVlXG5cdFx0XHQgKi9cblx0XHRcdHRoaXMudHJpZ2dlcihcImluaXRcIik7XG5cblx0XHRcdHRoaXMuX2RhdGEuY29yZS5vcmlnaW5hbF9jb250YWluZXJfaHRtbCA9IHRoaXMuZWxlbWVudC5maW5kKFwiID4gdWwgPiBsaVwiKS5jbG9uZSh0cnVlKTtcblx0XHRcdHRoaXMuX2RhdGEuY29yZS5vcmlnaW5hbF9jb250YWluZXJfaHRtbFxuXHRcdFx0XHQuZmluZChcImxpXCIpLmFkZEJhY2soKVxuXHRcdFx0XHQuY29udGVudHMoKS5maWx0ZXIoZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXMubm9kZVR5cGUgPT09IDMgJiYgKCF0aGlzLm5vZGVWYWx1ZSB8fCAvXlxccyskLy50ZXN0KHRoaXMubm9kZVZhbHVlKSk7XG5cdFx0XHRcdH0pXG5cdFx0XHRcdC5yZW1vdmUoKTtcblx0XHRcdHRoaXMuZWxlbWVudC5odG1sKFwiPFwiK1widWwgY2xhc3M9J2pzdHJlZS1jb250YWluZXItdWwganN0cmVlLWNoaWxkcmVuJyByb2xlPSdncm91cCc+PFwiK1wibGkgaWQ9J2pcIit0aGlzLl9pZCtcIl9sb2FkaW5nJyBjbGFzcz0nanN0cmVlLWluaXRpYWwtbm9kZSBqc3RyZWUtbG9hZGluZyBqc3RyZWUtbGVhZiBqc3RyZWUtbGFzdCcgcm9sZT0ndHJlZS1pdGVtJz48aSBjbGFzcz0nanN0cmVlLWljb24ganN0cmVlLW9jbCc+PC9pPjxcIitcImEgY2xhc3M9J2pzdHJlZS1hbmNob3InIGhyZWY9JyMnPjxpIGNsYXNzPSdqc3RyZWUtaWNvbiBqc3RyZWUtdGhlbWVpY29uLWhpZGRlbic+PC9pPlwiICsgdGhpcy5nZXRfc3RyaW5nKFwiTG9hZGluZyAuLi5cIikgKyBcIjwvYT48L2xpPjwvdWw+XCIpO1xuXHRcdFx0dGhpcy5lbGVtZW50LmF0dHIoJ2FyaWEtYWN0aXZlZGVzY2VuZGFudCcsJ2onICsgdGhpcy5faWQgKyAnX2xvYWRpbmcnKTtcblx0XHRcdHRoaXMuX2RhdGEuY29yZS5saV9oZWlnaHQgPSB0aGlzLmdldF9jb250YWluZXJfdWwoKS5jaGlsZHJlbihcImxpXCIpLmZpcnN0KCkuaGVpZ2h0KCkgfHwgMjQ7XG5cdFx0XHR0aGlzLl9kYXRhLmNvcmUubm9kZSA9IHRoaXMuX2NyZWF0ZV9wcm90b3R5cGVfbm9kZSgpO1xuXHRcdFx0LyoqXG5cdFx0XHQgKiB0cmlnZ2VyZWQgYWZ0ZXIgdGhlIGxvYWRpbmcgdGV4dCBpcyBzaG93biBhbmQgYmVmb3JlIGxvYWRpbmcgc3RhcnRzXG5cdFx0XHQgKiBAZXZlbnRcblx0XHRcdCAqIEBuYW1lIGxvYWRpbmcuanN0cmVlXG5cdFx0XHQgKi9cblx0XHRcdHRoaXMudHJpZ2dlcihcImxvYWRpbmdcIik7XG5cdFx0XHR0aGlzLmxvYWRfbm9kZSgkLmpzdHJlZS5yb290KTtcblx0XHR9LFxuXHRcdC8qKlxuXHRcdCAqIGRlc3Ryb3kgYW4gaW5zdGFuY2Vcblx0XHQgKiBAbmFtZSBkZXN0cm95KClcblx0XHQgKiBAcGFyYW0gIHtCb29sZWFufSBrZWVwX2h0bWwgaWYgbm90IHNldCB0byBgdHJ1ZWAgdGhlIGNvbnRhaW5lciB3aWxsIGJlIGVtcHRpZWQsIG90aGVyd2lzZSB0aGUgY3VycmVudCBET00gZWxlbWVudHMgd2lsbCBiZSBrZXB0IGludGFjdFxuXHRcdCAqL1xuXHRcdGRlc3Ryb3kgOiBmdW5jdGlvbiAoa2VlcF9odG1sKSB7XG5cdFx0XHRpZih0aGlzLl93cmspIHtcblx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHR3aW5kb3cuVVJMLnJldm9rZU9iamVjdFVSTCh0aGlzLl93cmspO1xuXHRcdFx0XHRcdHRoaXMuX3dyayA9IG51bGw7XG5cdFx0XHRcdH1cblx0XHRcdFx0Y2F0Y2ggKGlnbm9yZSkgeyB9XG5cdFx0XHR9XG5cdFx0XHRpZigha2VlcF9odG1sKSB7IHRoaXMuZWxlbWVudC5lbXB0eSgpOyB9XG5cdFx0XHR0aGlzLnRlYXJkb3duKCk7XG5cdFx0fSxcblx0XHQvKipcblx0XHQgKiBDcmVhdGUgcHJvdG90eXBlIG5vZGVcblx0XHQgKi9cblx0XHRfY3JlYXRlX3Byb3RvdHlwZV9ub2RlIDogZnVuY3Rpb24gKCkge1xuXHRcdFx0dmFyIF9ub2RlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnTEknKSwgX3RlbXAxLCBfdGVtcDI7XG5cdFx0XHRfbm9kZS5zZXRBdHRyaWJ1dGUoJ3JvbGUnLCAndHJlZWl0ZW0nKTtcblx0XHRcdF90ZW1wMSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ0knKTtcblx0XHRcdF90ZW1wMS5jbGFzc05hbWUgPSAnanN0cmVlLWljb24ganN0cmVlLW9jbCc7XG5cdFx0XHRfdGVtcDEuc2V0QXR0cmlidXRlKCdyb2xlJywgJ3ByZXNlbnRhdGlvbicpO1xuXHRcdFx0X25vZGUuYXBwZW5kQ2hpbGQoX3RlbXAxKTtcblx0XHRcdF90ZW1wMSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ0EnKTtcblx0XHRcdF90ZW1wMS5jbGFzc05hbWUgPSAnanN0cmVlLWFuY2hvcic7XG5cdFx0XHRfdGVtcDEuc2V0QXR0cmlidXRlKCdocmVmJywnIycpO1xuXHRcdFx0X3RlbXAxLnNldEF0dHJpYnV0ZSgndGFiaW5kZXgnLCctMScpO1xuXHRcdFx0X3RlbXAyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnSScpO1xuXHRcdFx0X3RlbXAyLmNsYXNzTmFtZSA9ICdqc3RyZWUtaWNvbiBqc3RyZWUtdGhlbWVpY29uJztcblx0XHRcdF90ZW1wMi5zZXRBdHRyaWJ1dGUoJ3JvbGUnLCAncHJlc2VudGF0aW9uJyk7XG5cdFx0XHRfdGVtcDEuYXBwZW5kQ2hpbGQoX3RlbXAyKTtcblx0XHRcdF9ub2RlLmFwcGVuZENoaWxkKF90ZW1wMSk7XG5cdFx0XHRfdGVtcDEgPSBfdGVtcDIgPSBudWxsO1xuXG5cdFx0XHRyZXR1cm4gX25vZGU7XG5cdFx0fSxcblx0XHQvKipcblx0XHQgKiBwYXJ0IG9mIHRoZSBkZXN0cm95aW5nIG9mIGFuIGluc3RhbmNlLiBVc2VkIGludGVybmFsbHkuXG5cdFx0ICogQHByaXZhdGVcblx0XHQgKiBAbmFtZSB0ZWFyZG93bigpXG5cdFx0ICovXG5cdFx0dGVhcmRvd24gOiBmdW5jdGlvbiAoKSB7XG5cdFx0XHR0aGlzLnVuYmluZCgpO1xuXHRcdFx0dGhpcy5lbGVtZW50XG5cdFx0XHRcdC5yZW1vdmVDbGFzcygnanN0cmVlJylcblx0XHRcdFx0LnJlbW92ZURhdGEoJ2pzdHJlZScpXG5cdFx0XHRcdC5maW5kKFwiW2NsYXNzXj0nanN0cmVlJ11cIilcblx0XHRcdFx0XHQuYWRkQmFjaygpXG5cdFx0XHRcdFx0LmF0dHIoXCJjbGFzc1wiLCBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLmNsYXNzTmFtZS5yZXBsYWNlKC9qc3RyZWVbXiBdKnwkL2lnLCcnKTsgfSk7XG5cdFx0XHR0aGlzLmVsZW1lbnQgPSBudWxsO1xuXHRcdH0sXG5cdFx0LyoqXG5cdFx0ICogYmluZCBhbGwgZXZlbnRzLiBVc2VkIGludGVybmFsbHkuXG5cdFx0ICogQHByaXZhdGVcblx0XHQgKiBAbmFtZSBiaW5kKClcblx0XHQgKi9cblx0XHRiaW5kIDogZnVuY3Rpb24gKCkge1xuXHRcdFx0dmFyIHdvcmQgPSAnJyxcblx0XHRcdFx0dG91dCA9IG51bGwsXG5cdFx0XHRcdHdhc19jbGljayA9IDA7XG5cdFx0XHR0aGlzLmVsZW1lbnRcblx0XHRcdFx0Lm9uKFwiZGJsY2xpY2suanN0cmVlXCIsIGZ1bmN0aW9uIChlKSB7XG5cdFx0XHRcdFx0XHRpZihlLnRhcmdldC50YWdOYW1lICYmIGUudGFyZ2V0LnRhZ05hbWUudG9Mb3dlckNhc2UoKSA9PT0gXCJpbnB1dFwiKSB7IHJldHVybiB0cnVlOyB9XG5cdFx0XHRcdFx0XHRpZihkb2N1bWVudC5zZWxlY3Rpb24gJiYgZG9jdW1lbnQuc2VsZWN0aW9uLmVtcHR5KSB7XG5cdFx0XHRcdFx0XHRcdGRvY3VtZW50LnNlbGVjdGlvbi5lbXB0eSgpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0XHRcdGlmKHdpbmRvdy5nZXRTZWxlY3Rpb24pIHtcblx0XHRcdFx0XHRcdFx0XHR2YXIgc2VsID0gd2luZG93LmdldFNlbGVjdGlvbigpO1xuXHRcdFx0XHRcdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRzZWwucmVtb3ZlQWxsUmFuZ2VzKCk7XG5cdFx0XHRcdFx0XHRcdFx0XHRzZWwuY29sbGFwc2UoKTtcblx0XHRcdFx0XHRcdFx0XHR9IGNhdGNoIChpZ25vcmUpIHsgfVxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSlcblx0XHRcdFx0Lm9uKFwibW91c2Vkb3duLmpzdHJlZVwiLCAkLnByb3h5KGZ1bmN0aW9uIChlKSB7XG5cdFx0XHRcdFx0XHRpZihlLnRhcmdldCA9PT0gdGhpcy5lbGVtZW50WzBdKSB7XG5cdFx0XHRcdFx0XHRcdGUucHJldmVudERlZmF1bHQoKTsgLy8gcHJldmVudCBsb3NpbmcgZm9jdXMgd2hlbiBjbGlja2luZyBzY3JvbGwgYXJyb3dzIChGRiwgQ2hyb21lKVxuXHRcdFx0XHRcdFx0XHR3YXNfY2xpY2sgPSArKG5ldyBEYXRlKCkpOyAvLyBpZSBkb2VzIG5vdCBhbGxvdyB0byBwcmV2ZW50IGxvc2luZyBmb2N1c1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0sIHRoaXMpKVxuXHRcdFx0XHQub24oXCJtb3VzZWRvd24uanN0cmVlXCIsIFwiLmpzdHJlZS1vY2xcIiwgZnVuY3Rpb24gKGUpIHtcblx0XHRcdFx0XHRcdGUucHJldmVudERlZmF1bHQoKTsgLy8gcHJldmVudCBhbnkgbm9kZSBpbnNpZGUgZnJvbSBsb3NpbmcgZm9jdXMgd2hlbiBjbGlja2luZyB0aGUgb3Blbi9jbG9zZSBpY29uXG5cdFx0XHRcdFx0fSlcblx0XHRcdFx0Lm9uKFwiY2xpY2suanN0cmVlXCIsIFwiLmpzdHJlZS1vY2xcIiwgJC5wcm94eShmdW5jdGlvbiAoZSkge1xuXHRcdFx0XHRcdFx0dGhpcy50b2dnbGVfbm9kZShlLnRhcmdldCk7XG5cdFx0XHRcdFx0fSwgdGhpcykpXG5cdFx0XHRcdC5vbihcImRibGNsaWNrLmpzdHJlZVwiLCBcIi5qc3RyZWUtYW5jaG9yXCIsICQucHJveHkoZnVuY3Rpb24gKGUpIHtcblx0XHRcdFx0XHRcdGlmKGUudGFyZ2V0LnRhZ05hbWUgJiYgZS50YXJnZXQudGFnTmFtZS50b0xvd2VyQ2FzZSgpID09PSBcImlucHV0XCIpIHsgcmV0dXJuIHRydWU7IH1cblx0XHRcdFx0XHRcdGlmKHRoaXMuc2V0dGluZ3MuY29yZS5kYmxjbGlja190b2dnbGUpIHtcblx0XHRcdFx0XHRcdFx0dGhpcy50b2dnbGVfbm9kZShlLnRhcmdldCk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSwgdGhpcykpXG5cdFx0XHRcdC5vbihcImNsaWNrLmpzdHJlZVwiLCBcIi5qc3RyZWUtYW5jaG9yXCIsICQucHJveHkoZnVuY3Rpb24gKGUpIHtcblx0XHRcdFx0XHRcdGUucHJldmVudERlZmF1bHQoKTtcblx0XHRcdFx0XHRcdGlmKGUuY3VycmVudFRhcmdldCAhPT0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudCkgeyAkKGUuY3VycmVudFRhcmdldCkuZm9jdXMoKTsgfVxuXHRcdFx0XHRcdFx0dGhpcy5hY3RpdmF0ZV9ub2RlKGUuY3VycmVudFRhcmdldCwgZSk7XG5cdFx0XHRcdFx0fSwgdGhpcykpXG5cdFx0XHRcdC5vbigna2V5ZG93bi5qc3RyZWUnLCAnLmpzdHJlZS1hbmNob3InLCAkLnByb3h5KGZ1bmN0aW9uIChlKSB7XG5cdFx0XHRcdFx0XHRpZihlLnRhcmdldC50YWdOYW1lICYmIGUudGFyZ2V0LnRhZ05hbWUudG9Mb3dlckNhc2UoKSA9PT0gXCJpbnB1dFwiKSB7IHJldHVybiB0cnVlOyB9XG5cdFx0XHRcdFx0XHRpZihlLndoaWNoICE9PSAzMiAmJiBlLndoaWNoICE9PSAxMyAmJiAoZS5zaGlmdEtleSB8fCBlLmN0cmxLZXkgfHwgZS5hbHRLZXkgfHwgZS5tZXRhS2V5KSkgeyByZXR1cm4gdHJ1ZTsgfVxuXHRcdFx0XHRcdFx0dmFyIG8gPSBudWxsO1xuXHRcdFx0XHRcdFx0aWYodGhpcy5fZGF0YS5jb3JlLnJ0bCkge1xuXHRcdFx0XHRcdFx0XHRpZihlLndoaWNoID09PSAzNykgeyBlLndoaWNoID0gMzk7IH1cblx0XHRcdFx0XHRcdFx0ZWxzZSBpZihlLndoaWNoID09PSAzOSkgeyBlLndoaWNoID0gMzc7IH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdHN3aXRjaChlLndoaWNoKSB7XG5cdFx0XHRcdFx0XHRcdGNhc2UgMzI6IC8vIGFyaWEgZGVmaW5lcyBzcGFjZSBvbmx5IHdpdGggQ3RybFxuXHRcdFx0XHRcdFx0XHRcdGlmKGUuY3RybEtleSkge1xuXHRcdFx0XHRcdFx0XHRcdFx0ZS50eXBlID0gXCJjbGlja1wiO1xuXHRcdFx0XHRcdFx0XHRcdFx0JChlLmN1cnJlbnRUYXJnZXQpLnRyaWdnZXIoZSk7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0XHRjYXNlIDEzOiAvLyBlbnRlclxuXHRcdFx0XHRcdFx0XHRcdGUudHlwZSA9IFwiY2xpY2tcIjtcblx0XHRcdFx0XHRcdFx0XHQkKGUuY3VycmVudFRhcmdldCkudHJpZ2dlcihlKTtcblx0XHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdFx0Y2FzZSAzNzogLy8gbGVmdFxuXHRcdFx0XHRcdFx0XHRcdGUucHJldmVudERlZmF1bHQoKTtcblx0XHRcdFx0XHRcdFx0XHRpZih0aGlzLmlzX29wZW4oZS5jdXJyZW50VGFyZ2V0KSkge1xuXHRcdFx0XHRcdFx0XHRcdFx0dGhpcy5jbG9zZV9ub2RlKGUuY3VycmVudFRhcmdldCk7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdFx0byA9IHRoaXMuZ2V0X3BhcmVudChlLmN1cnJlbnRUYXJnZXQpO1xuXHRcdFx0XHRcdFx0XHRcdFx0aWYobyAmJiBvLmlkICE9PSAkLmpzdHJlZS5yb290KSB7IHRoaXMuZ2V0X25vZGUobywgdHJ1ZSkuY2hpbGRyZW4oJy5qc3RyZWUtYW5jaG9yJykuZm9jdXMoKTsgfVxuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdFx0Y2FzZSAzODogLy8gdXBcblx0XHRcdFx0XHRcdFx0XHRlLnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHRcdFx0XHRcdFx0byA9IHRoaXMuZ2V0X3ByZXZfZG9tKGUuY3VycmVudFRhcmdldCk7XG5cdFx0XHRcdFx0XHRcdFx0aWYobyAmJiBvLmxlbmd0aCkgeyBvLmNoaWxkcmVuKCcuanN0cmVlLWFuY2hvcicpLmZvY3VzKCk7IH1cblx0XHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdFx0Y2FzZSAzOTogLy8gcmlnaHRcblx0XHRcdFx0XHRcdFx0XHRlLnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHRcdFx0XHRcdFx0aWYodGhpcy5pc19jbG9zZWQoZS5jdXJyZW50VGFyZ2V0KSkge1xuXHRcdFx0XHRcdFx0XHRcdFx0dGhpcy5vcGVuX25vZGUoZS5jdXJyZW50VGFyZ2V0LCBmdW5jdGlvbiAobykgeyB0aGlzLmdldF9ub2RlKG8sIHRydWUpLmNoaWxkcmVuKCcuanN0cmVlLWFuY2hvcicpLmZvY3VzKCk7IH0pO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRlbHNlIGlmICh0aGlzLmlzX29wZW4oZS5jdXJyZW50VGFyZ2V0KSkge1xuXHRcdFx0XHRcdFx0XHRcdFx0byA9IHRoaXMuZ2V0X25vZGUoZS5jdXJyZW50VGFyZ2V0LCB0cnVlKS5jaGlsZHJlbignLmpzdHJlZS1jaGlsZHJlbicpWzBdO1xuXHRcdFx0XHRcdFx0XHRcdFx0aWYobykgeyAkKHRoaXMuX2ZpcnN0Q2hpbGQobykpLmNoaWxkcmVuKCcuanN0cmVlLWFuY2hvcicpLmZvY3VzKCk7IH1cblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRcdGNhc2UgNDA6IC8vIGRvd25cblx0XHRcdFx0XHRcdFx0XHRlLnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHRcdFx0XHRcdFx0byA9IHRoaXMuZ2V0X25leHRfZG9tKGUuY3VycmVudFRhcmdldCk7XG5cdFx0XHRcdFx0XHRcdFx0aWYobyAmJiBvLmxlbmd0aCkgeyBvLmNoaWxkcmVuKCcuanN0cmVlLWFuY2hvcicpLmZvY3VzKCk7IH1cblx0XHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdFx0Y2FzZSAxMDY6IC8vIGFyaWEgZGVmaW5lcyAqIG9uIG51bXBhZCBhcyBvcGVuX2FsbCAtIG5vdCB2ZXJ5IGNvbW1vblxuXHRcdFx0XHRcdFx0XHRcdHRoaXMub3Blbl9hbGwoKTtcblx0XHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdFx0Y2FzZSAzNjogLy8gaG9tZVxuXHRcdFx0XHRcdFx0XHRcdGUucHJldmVudERlZmF1bHQoKTtcblx0XHRcdFx0XHRcdFx0XHRvID0gdGhpcy5fZmlyc3RDaGlsZCh0aGlzLmdldF9jb250YWluZXJfdWwoKVswXSk7XG5cdFx0XHRcdFx0XHRcdFx0aWYobykgeyAkKG8pLmNoaWxkcmVuKCcuanN0cmVlLWFuY2hvcicpLmZpbHRlcignOnZpc2libGUnKS5mb2N1cygpOyB9XG5cdFx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRcdGNhc2UgMzU6IC8vIGVuZFxuXHRcdFx0XHRcdFx0XHRcdGUucHJldmVudERlZmF1bHQoKTtcblx0XHRcdFx0XHRcdFx0XHR0aGlzLmVsZW1lbnQuZmluZCgnLmpzdHJlZS1hbmNob3InKS5maWx0ZXIoJzp2aXNpYmxlJykubGFzdCgpLmZvY3VzKCk7XG5cdFx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRcdGNhc2UgMTEzOiAvLyBmMiAtIHNhZmUgdG8gaW5jbHVkZSAtIGlmIGNoZWNrX2NhbGxiYWNrIGlzIGZhbHNlIGl0IHdpbGwgZmFpbFxuXHRcdFx0XHRcdFx0XHRcdGUucHJldmVudERlZmF1bHQoKTtcblx0XHRcdFx0XHRcdFx0XHR0aGlzLmVkaXQoZS5jdXJyZW50VGFyZ2V0KTtcblx0XHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdFx0LyohXG5cdFx0XHRcdFx0XHRcdC8vIGRlbGV0ZVxuXHRcdFx0XHRcdFx0XHRjYXNlIDQ2OlxuXHRcdFx0XHRcdFx0XHRcdGUucHJldmVudERlZmF1bHQoKTtcblx0XHRcdFx0XHRcdFx0XHRvID0gdGhpcy5nZXRfbm9kZShlLmN1cnJlbnRUYXJnZXQpO1xuXHRcdFx0XHRcdFx0XHRcdGlmKG8gJiYgby5pZCAmJiBvLmlkICE9PSAkLmpzdHJlZS5yb290KSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRvID0gdGhpcy5pc19zZWxlY3RlZChvKSA/IHRoaXMuZ2V0X3NlbGVjdGVkKCkgOiBvO1xuXHRcdFx0XHRcdFx0XHRcdFx0dGhpcy5kZWxldGVfbm9kZShvKTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRcdFx0Ki9cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9LCB0aGlzKSlcblx0XHRcdFx0Lm9uKFwibG9hZF9ub2RlLmpzdHJlZVwiLCAkLnByb3h5KGZ1bmN0aW9uIChlLCBkYXRhKSB7XG5cdFx0XHRcdFx0XHRpZihkYXRhLnN0YXR1cykge1xuXHRcdFx0XHRcdFx0XHRpZihkYXRhLm5vZGUuaWQgPT09ICQuanN0cmVlLnJvb3QgJiYgIXRoaXMuX2RhdGEuY29yZS5sb2FkZWQpIHtcblx0XHRcdFx0XHRcdFx0XHR0aGlzLl9kYXRhLmNvcmUubG9hZGVkID0gdHJ1ZTtcblx0XHRcdFx0XHRcdFx0XHRpZih0aGlzLl9maXJzdENoaWxkKHRoaXMuZ2V0X2NvbnRhaW5lcl91bCgpWzBdKSkge1xuXHRcdFx0XHRcdFx0XHRcdFx0dGhpcy5lbGVtZW50LmF0dHIoJ2FyaWEtYWN0aXZlZGVzY2VuZGFudCcsdGhpcy5fZmlyc3RDaGlsZCh0aGlzLmdldF9jb250YWluZXJfdWwoKVswXSkuaWQpO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHQvKipcblx0XHRcdFx0XHRcdFx0XHQgKiB0cmlnZ2VyZWQgYWZ0ZXIgdGhlIHJvb3Qgbm9kZSBpcyBsb2FkZWQgZm9yIHRoZSBmaXJzdCB0aW1lXG5cdFx0XHRcdFx0XHRcdFx0ICogQGV2ZW50XG5cdFx0XHRcdFx0XHRcdFx0ICogQG5hbWUgbG9hZGVkLmpzdHJlZVxuXHRcdFx0XHRcdFx0XHRcdCAqL1xuXHRcdFx0XHRcdFx0XHRcdHRoaXMudHJpZ2dlcihcImxvYWRlZFwiKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRpZighdGhpcy5fZGF0YS5jb3JlLnJlYWR5KSB7XG5cdFx0XHRcdFx0XHRcdFx0c2V0VGltZW91dCgkLnByb3h5KGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0XHRcdFx0aWYodGhpcy5lbGVtZW50ICYmICF0aGlzLmdldF9jb250YWluZXJfdWwoKS5maW5kKCcuanN0cmVlLWxvYWRpbmcnKS5sZW5ndGgpIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dGhpcy5fZGF0YS5jb3JlLnJlYWR5ID0gdHJ1ZTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWYodGhpcy5fZGF0YS5jb3JlLnNlbGVjdGVkLmxlbmd0aCkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGlmKHRoaXMuc2V0dGluZ3MuY29yZS5leHBhbmRfc2VsZWN0ZWRfb25sb2FkKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR2YXIgdG1wID0gW10sIGksIGo7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRmb3IoaSA9IDAsIGogPSB0aGlzLl9kYXRhLmNvcmUuc2VsZWN0ZWQubGVuZ3RoOyBpIDwgajsgaSsrKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHRtcCA9IHRtcC5jb25jYXQodGhpcy5fbW9kZWwuZGF0YVt0aGlzLl9kYXRhLmNvcmUuc2VsZWN0ZWRbaV1dLnBhcmVudHMpO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0dG1wID0gJC52YWthdGEuYXJyYXlfdW5pcXVlKHRtcCk7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRmb3IoaSA9IDAsIGogPSB0bXAubGVuZ3RoOyBpIDwgajsgaSsrKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHRoaXMub3Blbl9ub2RlKHRtcFtpXSwgZmFsc2UsIDApO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR0aGlzLnRyaWdnZXIoJ2NoYW5nZWQnLCB7ICdhY3Rpb24nIDogJ3JlYWR5JywgJ3NlbGVjdGVkJyA6IHRoaXMuX2RhdGEuY29yZS5zZWxlY3RlZCB9KTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0XHQvKipcblx0XHRcdFx0XHRcdFx0XHRcdFx0ICogdHJpZ2dlcmVkIGFmdGVyIGFsbCBub2RlcyBhcmUgZmluaXNoZWQgbG9hZGluZ1xuXHRcdFx0XHRcdFx0XHRcdFx0XHQgKiBAZXZlbnRcblx0XHRcdFx0XHRcdFx0XHRcdFx0ICogQG5hbWUgcmVhZHkuanN0cmVlXG5cdFx0XHRcdFx0XHRcdFx0XHRcdCAqL1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0aGlzLnRyaWdnZXIoXCJyZWFkeVwiKTtcblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9LCB0aGlzKSwgMCk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9LCB0aGlzKSlcblx0XHRcdFx0Ly8gcXVpY2sgc2VhcmNoaW5nIHdoZW4gdGhlIHRyZWUgaXMgZm9jdXNlZFxuXHRcdFx0XHQub24oJ2tleXByZXNzLmpzdHJlZScsICQucHJveHkoZnVuY3Rpb24gKGUpIHtcblx0XHRcdFx0XHRcdGlmKGUudGFyZ2V0LnRhZ05hbWUgJiYgZS50YXJnZXQudGFnTmFtZS50b0xvd2VyQ2FzZSgpID09PSBcImlucHV0XCIpIHsgcmV0dXJuIHRydWU7IH1cblx0XHRcdFx0XHRcdGlmKHRvdXQpIHsgY2xlYXJUaW1lb3V0KHRvdXQpOyB9XG5cdFx0XHRcdFx0XHR0b3V0ID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdFx0XHRcdHdvcmQgPSAnJztcblx0XHRcdFx0XHRcdH0sIDUwMCk7XG5cblx0XHRcdFx0XHRcdHZhciBjaHIgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGUud2hpY2gpLnRvTG93ZXJDYXNlKCksXG5cdFx0XHRcdFx0XHRcdGNvbCA9IHRoaXMuZWxlbWVudC5maW5kKCcuanN0cmVlLWFuY2hvcicpLmZpbHRlcignOnZpc2libGUnKSxcblx0XHRcdFx0XHRcdFx0aW5kID0gY29sLmluZGV4KGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQpIHx8IDAsXG5cdFx0XHRcdFx0XHRcdGVuZCA9IGZhbHNlO1xuXHRcdFx0XHRcdFx0d29yZCArPSBjaHI7XG5cblx0XHRcdFx0XHRcdC8vIG1hdGNoIGZvciB3aG9sZSB3b3JkIGZyb20gY3VycmVudCBub2RlIGRvd24gKGluY2x1ZGluZyB0aGUgY3VycmVudCBub2RlKVxuXHRcdFx0XHRcdFx0aWYod29yZC5sZW5ndGggPiAxKSB7XG5cdFx0XHRcdFx0XHRcdGNvbC5zbGljZShpbmQpLmVhY2goJC5wcm94eShmdW5jdGlvbiAoaSwgdikge1xuXHRcdFx0XHRcdFx0XHRcdGlmKCQodikudGV4dCgpLnRvTG93ZXJDYXNlKCkuaW5kZXhPZih3b3JkKSA9PT0gMCkge1xuXHRcdFx0XHRcdFx0XHRcdFx0JCh2KS5mb2N1cygpO1xuXHRcdFx0XHRcdFx0XHRcdFx0ZW5kID0gdHJ1ZTtcblx0XHRcdFx0XHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0sIHRoaXMpKTtcblx0XHRcdFx0XHRcdFx0aWYoZW5kKSB7IHJldHVybjsgfVxuXG5cdFx0XHRcdFx0XHRcdC8vIG1hdGNoIGZvciB3aG9sZSB3b3JkIGZyb20gdGhlIGJlZ2lubmluZyBvZiB0aGUgdHJlZVxuXHRcdFx0XHRcdFx0XHRjb2wuc2xpY2UoMCwgaW5kKS5lYWNoKCQucHJveHkoZnVuY3Rpb24gKGksIHYpIHtcblx0XHRcdFx0XHRcdFx0XHRpZigkKHYpLnRleHQoKS50b0xvd2VyQ2FzZSgpLmluZGV4T2Yod29yZCkgPT09IDApIHtcblx0XHRcdFx0XHRcdFx0XHRcdCQodikuZm9jdXMoKTtcblx0XHRcdFx0XHRcdFx0XHRcdGVuZCA9IHRydWU7XG5cdFx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9LCB0aGlzKSk7XG5cdFx0XHRcdFx0XHRcdGlmKGVuZCkgeyByZXR1cm47IH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdC8vIGxpc3Qgbm9kZXMgdGhhdCBzdGFydCB3aXRoIHRoYXQgbGV0dGVyIChvbmx5IGlmIHdvcmQgY29uc2lzdHMgb2YgYSBzaW5nbGUgY2hhcilcblx0XHRcdFx0XHRcdGlmKG5ldyBSZWdFeHAoJ14nICsgY2hyLnJlcGxhY2UoL1stXFwvXFxcXF4kKis/LigpfFtcXF17fV0vZywgJ1xcXFwkJicpICsgJyskJykudGVzdCh3b3JkKSkge1xuXHRcdFx0XHRcdFx0XHQvLyBzZWFyY2ggZm9yIHRoZSBuZXh0IG5vZGUgc3RhcnRpbmcgd2l0aCB0aGF0IGxldHRlclxuXHRcdFx0XHRcdFx0XHRjb2wuc2xpY2UoaW5kICsgMSkuZWFjaCgkLnByb3h5KGZ1bmN0aW9uIChpLCB2KSB7XG5cdFx0XHRcdFx0XHRcdFx0aWYoJCh2KS50ZXh0KCkudG9Mb3dlckNhc2UoKS5jaGFyQXQoMCkgPT09IGNocikge1xuXHRcdFx0XHRcdFx0XHRcdFx0JCh2KS5mb2N1cygpO1xuXHRcdFx0XHRcdFx0XHRcdFx0ZW5kID0gdHJ1ZTtcblx0XHRcdFx0XHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0sIHRoaXMpKTtcblx0XHRcdFx0XHRcdFx0aWYoZW5kKSB7IHJldHVybjsgfVxuXG5cdFx0XHRcdFx0XHRcdC8vIHNlYXJjaCBmcm9tIHRoZSBiZWdpbm5pbmdcblx0XHRcdFx0XHRcdFx0Y29sLnNsaWNlKDAsIGluZCArIDEpLmVhY2goJC5wcm94eShmdW5jdGlvbiAoaSwgdikge1xuXHRcdFx0XHRcdFx0XHRcdGlmKCQodikudGV4dCgpLnRvTG93ZXJDYXNlKCkuY2hhckF0KDApID09PSBjaHIpIHtcblx0XHRcdFx0XHRcdFx0XHRcdCQodikuZm9jdXMoKTtcblx0XHRcdFx0XHRcdFx0XHRcdGVuZCA9IHRydWU7XG5cdFx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9LCB0aGlzKSk7XG5cdFx0XHRcdFx0XHRcdGlmKGVuZCkgeyByZXR1cm47IH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9LCB0aGlzKSlcblx0XHRcdFx0Ly8gVEhFTUUgUkVMQVRFRFxuXHRcdFx0XHQub24oXCJpbml0LmpzdHJlZVwiLCAkLnByb3h5KGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0XHRcdHZhciBzID0gdGhpcy5zZXR0aW5ncy5jb3JlLnRoZW1lcztcblx0XHRcdFx0XHRcdHRoaXMuX2RhdGEuY29yZS50aGVtZXMuZG90c1x0XHRcdD0gcy5kb3RzO1xuXHRcdFx0XHRcdFx0dGhpcy5fZGF0YS5jb3JlLnRoZW1lcy5zdHJpcGVzXHRcdD0gcy5zdHJpcGVzO1xuXHRcdFx0XHRcdFx0dGhpcy5fZGF0YS5jb3JlLnRoZW1lcy5pY29uc1x0XHQ9IHMuaWNvbnM7XG5cdFx0XHRcdFx0XHR0aGlzLl9kYXRhLmNvcmUudGhlbWVzLmVsbGlwc2lzXHRcdD0gcy5lbGxpcHNpcztcblx0XHRcdFx0XHRcdHRoaXMuc2V0X3RoZW1lKHMubmFtZSB8fCBcImRlZmF1bHRcIiwgcy51cmwpO1xuXHRcdFx0XHRcdFx0dGhpcy5zZXRfdGhlbWVfdmFyaWFudChzLnZhcmlhbnQpO1xuXHRcdFx0XHRcdH0sIHRoaXMpKVxuXHRcdFx0XHQub24oXCJsb2FkaW5nLmpzdHJlZVwiLCAkLnByb3h5KGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0XHRcdHRoaXNbIHRoaXMuX2RhdGEuY29yZS50aGVtZXMuZG90cyA/IFwic2hvd19kb3RzXCIgOiBcImhpZGVfZG90c1wiIF0oKTtcblx0XHRcdFx0XHRcdHRoaXNbIHRoaXMuX2RhdGEuY29yZS50aGVtZXMuaWNvbnMgPyBcInNob3dfaWNvbnNcIiA6IFwiaGlkZV9pY29uc1wiIF0oKTtcblx0XHRcdFx0XHRcdHRoaXNbIHRoaXMuX2RhdGEuY29yZS50aGVtZXMuc3RyaXBlcyA/IFwic2hvd19zdHJpcGVzXCIgOiBcImhpZGVfc3RyaXBlc1wiIF0oKTtcblx0XHRcdFx0XHRcdHRoaXNbIHRoaXMuX2RhdGEuY29yZS50aGVtZXMuZWxsaXBzaXMgPyBcInNob3dfZWxsaXBzaXNcIiA6IFwiaGlkZV9lbGxpcHNpc1wiIF0oKTtcblx0XHRcdFx0XHR9LCB0aGlzKSlcblx0XHRcdFx0Lm9uKCdibHVyLmpzdHJlZScsICcuanN0cmVlLWFuY2hvcicsICQucHJveHkoZnVuY3Rpb24gKGUpIHtcblx0XHRcdFx0XHRcdHRoaXMuX2RhdGEuY29yZS5mb2N1c2VkID0gbnVsbDtcblx0XHRcdFx0XHRcdCQoZS5jdXJyZW50VGFyZ2V0KS5maWx0ZXIoJy5qc3RyZWUtaG92ZXJlZCcpLm1vdXNlbGVhdmUoKTtcblx0XHRcdFx0XHRcdHRoaXMuZWxlbWVudC5hdHRyKCd0YWJpbmRleCcsICcwJyk7XG5cdFx0XHRcdFx0fSwgdGhpcykpXG5cdFx0XHRcdC5vbignZm9jdXMuanN0cmVlJywgJy5qc3RyZWUtYW5jaG9yJywgJC5wcm94eShmdW5jdGlvbiAoZSkge1xuXHRcdFx0XHRcdFx0dmFyIHRtcCA9IHRoaXMuZ2V0X25vZGUoZS5jdXJyZW50VGFyZ2V0KTtcblx0XHRcdFx0XHRcdGlmKHRtcCAmJiB0bXAuaWQpIHtcblx0XHRcdFx0XHRcdFx0dGhpcy5fZGF0YS5jb3JlLmZvY3VzZWQgPSB0bXAuaWQ7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR0aGlzLmVsZW1lbnQuZmluZCgnLmpzdHJlZS1ob3ZlcmVkJykubm90KGUuY3VycmVudFRhcmdldCkubW91c2VsZWF2ZSgpO1xuXHRcdFx0XHRcdFx0JChlLmN1cnJlbnRUYXJnZXQpLm1vdXNlZW50ZXIoKTtcblx0XHRcdFx0XHRcdHRoaXMuZWxlbWVudC5hdHRyKCd0YWJpbmRleCcsICctMScpO1xuXHRcdFx0XHRcdH0sIHRoaXMpKVxuXHRcdFx0XHQub24oJ2ZvY3VzLmpzdHJlZScsICQucHJveHkoZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdFx0aWYoKyhuZXcgRGF0ZSgpKSAtIHdhc19jbGljayA+IDUwMCAmJiAhdGhpcy5fZGF0YS5jb3JlLmZvY3VzZWQpIHtcblx0XHRcdFx0XHRcdFx0d2FzX2NsaWNrID0gMDtcblx0XHRcdFx0XHRcdFx0dmFyIGFjdCA9IHRoaXMuZ2V0X25vZGUodGhpcy5lbGVtZW50LmF0dHIoJ2FyaWEtYWN0aXZlZGVzY2VuZGFudCcpLCB0cnVlKTtcblx0XHRcdFx0XHRcdFx0aWYoYWN0KSB7XG5cdFx0XHRcdFx0XHRcdFx0YWN0LmZpbmQoJz4gLmpzdHJlZS1hbmNob3InKS5mb2N1cygpO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSwgdGhpcykpXG5cdFx0XHRcdC5vbignbW91c2VlbnRlci5qc3RyZWUnLCAnLmpzdHJlZS1hbmNob3InLCAkLnByb3h5KGZ1bmN0aW9uIChlKSB7XG5cdFx0XHRcdFx0XHR0aGlzLmhvdmVyX25vZGUoZS5jdXJyZW50VGFyZ2V0KTtcblx0XHRcdFx0XHR9LCB0aGlzKSlcblx0XHRcdFx0Lm9uKCdtb3VzZWxlYXZlLmpzdHJlZScsICcuanN0cmVlLWFuY2hvcicsICQucHJveHkoZnVuY3Rpb24gKGUpIHtcblx0XHRcdFx0XHRcdHRoaXMuZGVob3Zlcl9ub2RlKGUuY3VycmVudFRhcmdldCk7XG5cdFx0XHRcdFx0fSwgdGhpcykpO1xuXHRcdH0sXG5cdFx0LyoqXG5cdFx0ICogcGFydCBvZiB0aGUgZGVzdHJveWluZyBvZiBhbiBpbnN0YW5jZS4gVXNlZCBpbnRlcm5hbGx5LlxuXHRcdCAqIEBwcml2YXRlXG5cdFx0ICogQG5hbWUgdW5iaW5kKClcblx0XHQgKi9cblx0XHR1bmJpbmQgOiBmdW5jdGlvbiAoKSB7XG5cdFx0XHR0aGlzLmVsZW1lbnQub2ZmKCcuanN0cmVlJyk7XG5cdFx0XHQkKGRvY3VtZW50KS5vZmYoJy5qc3RyZWUtJyArIHRoaXMuX2lkKTtcblx0XHR9LFxuXHRcdC8qKlxuXHRcdCAqIHRyaWdnZXIgYW4gZXZlbnQuIFVzZWQgaW50ZXJuYWxseS5cblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqIEBuYW1lIHRyaWdnZXIoZXYgWywgZGF0YV0pXG5cdFx0ICogQHBhcmFtICB7U3RyaW5nfSBldiB0aGUgbmFtZSBvZiB0aGUgZXZlbnQgdG8gdHJpZ2dlclxuXHRcdCAqIEBwYXJhbSAge09iamVjdH0gZGF0YSBhZGRpdGlvbmFsIGRhdGEgdG8gcGFzcyB3aXRoIHRoZSBldmVudFxuXHRcdCAqL1xuXHRcdHRyaWdnZXIgOiBmdW5jdGlvbiAoZXYsIGRhdGEpIHtcblx0XHRcdGlmKCFkYXRhKSB7XG5cdFx0XHRcdGRhdGEgPSB7fTtcblx0XHRcdH1cblx0XHRcdGRhdGEuaW5zdGFuY2UgPSB0aGlzO1xuXHRcdFx0dGhpcy5lbGVtZW50LnRyaWdnZXJIYW5kbGVyKGV2LnJlcGxhY2UoJy5qc3RyZWUnLCcnKSArICcuanN0cmVlJywgZGF0YSk7XG5cdFx0fSxcblx0XHQvKipcblx0XHQgKiByZXR1cm5zIHRoZSBqUXVlcnkgZXh0ZW5kZWQgaW5zdGFuY2UgY29udGFpbmVyXG5cdFx0ICogQG5hbWUgZ2V0X2NvbnRhaW5lcigpXG5cdFx0ICogQHJldHVybiB7alF1ZXJ5fVxuXHRcdCAqL1xuXHRcdGdldF9jb250YWluZXIgOiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5lbGVtZW50O1xuXHRcdH0sXG5cdFx0LyoqXG5cdFx0ICogcmV0dXJucyB0aGUgalF1ZXJ5IGV4dGVuZGVkIG1haW4gVUwgbm9kZSBpbnNpZGUgdGhlIGluc3RhbmNlIGNvbnRhaW5lci4gVXNlZCBpbnRlcm5hbGx5LlxuXHRcdCAqIEBwcml2YXRlXG5cdFx0ICogQG5hbWUgZ2V0X2NvbnRhaW5lcl91bCgpXG5cdFx0ICogQHJldHVybiB7alF1ZXJ5fVxuXHRcdCAqL1xuXHRcdGdldF9jb250YWluZXJfdWwgOiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5lbGVtZW50LmNoaWxkcmVuKFwiLmpzdHJlZS1jaGlsZHJlblwiKS5maXJzdCgpO1xuXHRcdH0sXG5cdFx0LyoqXG5cdFx0ICogZ2V0cyBzdHJpbmcgcmVwbGFjZW1lbnRzIChsb2NhbGl6YXRpb24pLiBVc2VkIGludGVybmFsbHkuXG5cdFx0ICogQHByaXZhdGVcblx0XHQgKiBAbmFtZSBnZXRfc3RyaW5nKGtleSlcblx0XHQgKiBAcGFyYW0gIHtTdHJpbmd9IGtleVxuXHRcdCAqIEByZXR1cm4ge1N0cmluZ31cblx0XHQgKi9cblx0XHRnZXRfc3RyaW5nIDogZnVuY3Rpb24gKGtleSkge1xuXHRcdFx0dmFyIGEgPSB0aGlzLnNldHRpbmdzLmNvcmUuc3RyaW5ncztcblx0XHRcdGlmKCQuaXNGdW5jdGlvbihhKSkgeyByZXR1cm4gYS5jYWxsKHRoaXMsIGtleSk7IH1cblx0XHRcdGlmKGEgJiYgYVtrZXldKSB7IHJldHVybiBhW2tleV07IH1cblx0XHRcdHJldHVybiBrZXk7XG5cdFx0fSxcblx0XHQvKipcblx0XHQgKiBnZXRzIHRoZSBmaXJzdCBjaGlsZCBvZiBhIERPTSBub2RlLiBVc2VkIGludGVybmFsbHkuXG5cdFx0ICogQHByaXZhdGVcblx0XHQgKiBAbmFtZSBfZmlyc3RDaGlsZChkb20pXG5cdFx0ICogQHBhcmFtICB7RE9NRWxlbWVudH0gZG9tXG5cdFx0ICogQHJldHVybiB7RE9NRWxlbWVudH1cblx0XHQgKi9cblx0XHRfZmlyc3RDaGlsZCA6IGZ1bmN0aW9uIChkb20pIHtcblx0XHRcdGRvbSA9IGRvbSA/IGRvbS5maXJzdENoaWxkIDogbnVsbDtcblx0XHRcdHdoaWxlKGRvbSAhPT0gbnVsbCAmJiBkb20ubm9kZVR5cGUgIT09IDEpIHtcblx0XHRcdFx0ZG9tID0gZG9tLm5leHRTaWJsaW5nO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGRvbTtcblx0XHR9LFxuXHRcdC8qKlxuXHRcdCAqIGdldHMgdGhlIG5leHQgc2libGluZyBvZiBhIERPTSBub2RlLiBVc2VkIGludGVybmFsbHkuXG5cdFx0ICogQHByaXZhdGVcblx0XHQgKiBAbmFtZSBfbmV4dFNpYmxpbmcoZG9tKVxuXHRcdCAqIEBwYXJhbSAge0RPTUVsZW1lbnR9IGRvbVxuXHRcdCAqIEByZXR1cm4ge0RPTUVsZW1lbnR9XG5cdFx0ICovXG5cdFx0X25leHRTaWJsaW5nIDogZnVuY3Rpb24gKGRvbSkge1xuXHRcdFx0ZG9tID0gZG9tID8gZG9tLm5leHRTaWJsaW5nIDogbnVsbDtcblx0XHRcdHdoaWxlKGRvbSAhPT0gbnVsbCAmJiBkb20ubm9kZVR5cGUgIT09IDEpIHtcblx0XHRcdFx0ZG9tID0gZG9tLm5leHRTaWJsaW5nO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGRvbTtcblx0XHR9LFxuXHRcdC8qKlxuXHRcdCAqIGdldHMgdGhlIHByZXZpb3VzIHNpYmxpbmcgb2YgYSBET00gbm9kZS4gVXNlZCBpbnRlcm5hbGx5LlxuXHRcdCAqIEBwcml2YXRlXG5cdFx0ICogQG5hbWUgX3ByZXZpb3VzU2libGluZyhkb20pXG5cdFx0ICogQHBhcmFtICB7RE9NRWxlbWVudH0gZG9tXG5cdFx0ICogQHJldHVybiB7RE9NRWxlbWVudH1cblx0XHQgKi9cblx0XHRfcHJldmlvdXNTaWJsaW5nIDogZnVuY3Rpb24gKGRvbSkge1xuXHRcdFx0ZG9tID0gZG9tID8gZG9tLnByZXZpb3VzU2libGluZyA6IG51bGw7XG5cdFx0XHR3aGlsZShkb20gIT09IG51bGwgJiYgZG9tLm5vZGVUeXBlICE9PSAxKSB7XG5cdFx0XHRcdGRvbSA9IGRvbS5wcmV2aW91c1NpYmxpbmc7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gZG9tO1xuXHRcdH0sXG5cdFx0LyoqXG5cdFx0ICogZ2V0IHRoZSBKU09OIHJlcHJlc2VudGF0aW9uIG9mIGEgbm9kZSAob3IgdGhlIGFjdHVhbCBqUXVlcnkgZXh0ZW5kZWQgRE9NIG5vZGUpIGJ5IHVzaW5nIGFueSBpbnB1dCAoY2hpbGQgRE9NIGVsZW1lbnQsIElEIHN0cmluZywgc2VsZWN0b3IsIGV0Yylcblx0XHQgKiBAbmFtZSBnZXRfbm9kZShvYmogWywgYXNfZG9tXSlcblx0XHQgKiBAcGFyYW0gIHttaXhlZH0gb2JqXG5cdFx0ICogQHBhcmFtICB7Qm9vbGVhbn0gYXNfZG9tXG5cdFx0ICogQHJldHVybiB7T2JqZWN0fGpRdWVyeX1cblx0XHQgKi9cblx0XHRnZXRfbm9kZSA6IGZ1bmN0aW9uIChvYmosIGFzX2RvbSkge1xuXHRcdFx0aWYob2JqICYmIG9iai5pZCkge1xuXHRcdFx0XHRvYmogPSBvYmouaWQ7XG5cdFx0XHR9XG5cdFx0XHR2YXIgZG9tO1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0aWYodGhpcy5fbW9kZWwuZGF0YVtvYmpdKSB7XG5cdFx0XHRcdFx0b2JqID0gdGhpcy5fbW9kZWwuZGF0YVtvYmpdO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2UgaWYodHlwZW9mIG9iaiA9PT0gXCJzdHJpbmdcIiAmJiB0aGlzLl9tb2RlbC5kYXRhW29iai5yZXBsYWNlKC9eIy8sICcnKV0pIHtcblx0XHRcdFx0XHRvYmogPSB0aGlzLl9tb2RlbC5kYXRhW29iai5yZXBsYWNlKC9eIy8sICcnKV07XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSBpZih0eXBlb2Ygb2JqID09PSBcInN0cmluZ1wiICYmIChkb20gPSAkKCcjJyArIG9iai5yZXBsYWNlKCQuanN0cmVlLmlkcmVnZXgsJ1xcXFwkJicpLCB0aGlzLmVsZW1lbnQpKS5sZW5ndGggJiYgdGhpcy5fbW9kZWwuZGF0YVtkb20uY2xvc2VzdCgnLmpzdHJlZS1ub2RlJykuYXR0cignaWQnKV0pIHtcblx0XHRcdFx0XHRvYmogPSB0aGlzLl9tb2RlbC5kYXRhW2RvbS5jbG9zZXN0KCcuanN0cmVlLW5vZGUnKS5hdHRyKCdpZCcpXTtcblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIGlmKChkb20gPSAkKG9iaiwgdGhpcy5lbGVtZW50KSkubGVuZ3RoICYmIHRoaXMuX21vZGVsLmRhdGFbZG9tLmNsb3Nlc3QoJy5qc3RyZWUtbm9kZScpLmF0dHIoJ2lkJyldKSB7XG5cdFx0XHRcdFx0b2JqID0gdGhpcy5fbW9kZWwuZGF0YVtkb20uY2xvc2VzdCgnLmpzdHJlZS1ub2RlJykuYXR0cignaWQnKV07XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSBpZigoZG9tID0gJChvYmosIHRoaXMuZWxlbWVudCkpLmxlbmd0aCAmJiBkb20uaGFzQ2xhc3MoJ2pzdHJlZScpKSB7XG5cdFx0XHRcdFx0b2JqID0gdGhpcy5fbW9kZWwuZGF0YVskLmpzdHJlZS5yb290XTtcblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZihhc19kb20pIHtcblx0XHRcdFx0XHRvYmogPSBvYmouaWQgPT09ICQuanN0cmVlLnJvb3QgPyB0aGlzLmVsZW1lbnQgOiAkKCcjJyArIG9iai5pZC5yZXBsYWNlKCQuanN0cmVlLmlkcmVnZXgsJ1xcXFwkJicpLCB0aGlzLmVsZW1lbnQpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBvYmo7XG5cdFx0XHR9IGNhdGNoIChleCkgeyByZXR1cm4gZmFsc2U7IH1cblx0XHR9LFxuXHRcdC8qKlxuXHRcdCAqIGdldCB0aGUgcGF0aCB0byBhIG5vZGUsIGVpdGhlciBjb25zaXN0aW5nIG9mIG5vZGUgdGV4dHMsIG9yIG9mIG5vZGUgSURzLCBvcHRpb25hbGx5IGdsdWVkIHRvZ2V0aGVyIChvdGhlcndpc2UgYW4gYXJyYXkpXG5cdFx0ICogQG5hbWUgZ2V0X3BhdGgob2JqIFssIGdsdWUsIGlkc10pXG5cdFx0ICogQHBhcmFtICB7bWl4ZWR9IG9iaiB0aGUgbm9kZVxuXHRcdCAqIEBwYXJhbSAge1N0cmluZ30gZ2x1ZSBpZiB5b3Ugd2FudCB0aGUgcGF0aCBhcyBhIHN0cmluZyAtIHBhc3MgdGhlIGdsdWUgaGVyZSAoZm9yIGV4YW1wbGUgJy8nKSwgaWYgYSBmYWxzeSB2YWx1ZSBpcyBzdXBwbGllZCBoZXJlLCBhbiBhcnJheSBpcyByZXR1cm5lZFxuXHRcdCAqIEBwYXJhbSAge0Jvb2xlYW59IGlkcyBpZiBzZXQgdG8gdHJ1ZSBidWlsZCB0aGUgcGF0aCB1c2luZyBJRCwgb3RoZXJ3aXNlIG5vZGUgdGV4dCBpcyB1c2VkXG5cdFx0ICogQHJldHVybiB7bWl4ZWR9XG5cdFx0ICovXG5cdFx0Z2V0X3BhdGggOiBmdW5jdGlvbiAob2JqLCBnbHVlLCBpZHMpIHtcblx0XHRcdG9iaiA9IG9iai5wYXJlbnRzID8gb2JqIDogdGhpcy5nZXRfbm9kZShvYmopO1xuXHRcdFx0aWYoIW9iaiB8fCBvYmouaWQgPT09ICQuanN0cmVlLnJvb3QgfHwgIW9iai5wYXJlbnRzKSB7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblx0XHRcdHZhciBpLCBqLCBwID0gW107XG5cdFx0XHRwLnB1c2goaWRzID8gb2JqLmlkIDogb2JqLnRleHQpO1xuXHRcdFx0Zm9yKGkgPSAwLCBqID0gb2JqLnBhcmVudHMubGVuZ3RoOyBpIDwgajsgaSsrKSB7XG5cdFx0XHRcdHAucHVzaChpZHMgPyBvYmoucGFyZW50c1tpXSA6IHRoaXMuZ2V0X3RleHQob2JqLnBhcmVudHNbaV0pKTtcblx0XHRcdH1cblx0XHRcdHAgPSBwLnJldmVyc2UoKS5zbGljZSgxKTtcblx0XHRcdHJldHVybiBnbHVlID8gcC5qb2luKGdsdWUpIDogcDtcblx0XHR9LFxuXHRcdC8qKlxuXHRcdCAqIGdldCB0aGUgbmV4dCB2aXNpYmxlIG5vZGUgdGhhdCBpcyBiZWxvdyB0aGUgYG9iamAgbm9kZS4gSWYgYHN0cmljdGAgaXMgc2V0IHRvIGB0cnVlYCBvbmx5IHNpYmxpbmcgbm9kZXMgYXJlIHJldHVybmVkLlxuXHRcdCAqIEBuYW1lIGdldF9uZXh0X2RvbShvYmogWywgc3RyaWN0XSlcblx0XHQgKiBAcGFyYW0gIHttaXhlZH0gb2JqXG5cdFx0ICogQHBhcmFtICB7Qm9vbGVhbn0gc3RyaWN0XG5cdFx0ICogQHJldHVybiB7alF1ZXJ5fVxuXHRcdCAqL1xuXHRcdGdldF9uZXh0X2RvbSA6IGZ1bmN0aW9uIChvYmosIHN0cmljdCkge1xuXHRcdFx0dmFyIHRtcDtcblx0XHRcdG9iaiA9IHRoaXMuZ2V0X25vZGUob2JqLCB0cnVlKTtcblx0XHRcdGlmKG9ialswXSA9PT0gdGhpcy5lbGVtZW50WzBdKSB7XG5cdFx0XHRcdHRtcCA9IHRoaXMuX2ZpcnN0Q2hpbGQodGhpcy5nZXRfY29udGFpbmVyX3VsKClbMF0pO1xuXHRcdFx0XHR3aGlsZSAodG1wICYmIHRtcC5vZmZzZXRIZWlnaHQgPT09IDApIHtcblx0XHRcdFx0XHR0bXAgPSB0aGlzLl9uZXh0U2libGluZyh0bXApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB0bXAgPyAkKHRtcCkgOiBmYWxzZTtcblx0XHRcdH1cblx0XHRcdGlmKCFvYmogfHwgIW9iai5sZW5ndGgpIHtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXHRcdFx0aWYoc3RyaWN0KSB7XG5cdFx0XHRcdHRtcCA9IG9ialswXTtcblx0XHRcdFx0ZG8ge1xuXHRcdFx0XHRcdHRtcCA9IHRoaXMuX25leHRTaWJsaW5nKHRtcCk7XG5cdFx0XHRcdH0gd2hpbGUgKHRtcCAmJiB0bXAub2Zmc2V0SGVpZ2h0ID09PSAwKTtcblx0XHRcdFx0cmV0dXJuIHRtcCA/ICQodG1wKSA6IGZhbHNlO1xuXHRcdFx0fVxuXHRcdFx0aWYob2JqLmhhc0NsYXNzKFwianN0cmVlLW9wZW5cIikpIHtcblx0XHRcdFx0dG1wID0gdGhpcy5fZmlyc3RDaGlsZChvYmouY2hpbGRyZW4oJy5qc3RyZWUtY2hpbGRyZW4nKVswXSk7XG5cdFx0XHRcdHdoaWxlICh0bXAgJiYgdG1wLm9mZnNldEhlaWdodCA9PT0gMCkge1xuXHRcdFx0XHRcdHRtcCA9IHRoaXMuX25leHRTaWJsaW5nKHRtcCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYodG1wICE9PSBudWxsKSB7XG5cdFx0XHRcdFx0cmV0dXJuICQodG1wKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0dG1wID0gb2JqWzBdO1xuXHRcdFx0ZG8ge1xuXHRcdFx0XHR0bXAgPSB0aGlzLl9uZXh0U2libGluZyh0bXApO1xuXHRcdFx0fSB3aGlsZSAodG1wICYmIHRtcC5vZmZzZXRIZWlnaHQgPT09IDApO1xuXHRcdFx0aWYodG1wICE9PSBudWxsKSB7XG5cdFx0XHRcdHJldHVybiAkKHRtcCk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gb2JqLnBhcmVudHNVbnRpbChcIi5qc3RyZWVcIixcIi5qc3RyZWUtbm9kZVwiKS5uZXh0QWxsKFwiLmpzdHJlZS1ub2RlOnZpc2libGVcIikuZmlyc3QoKTtcblx0XHR9LFxuXHRcdC8qKlxuXHRcdCAqIGdldCB0aGUgcHJldmlvdXMgdmlzaWJsZSBub2RlIHRoYXQgaXMgYWJvdmUgdGhlIGBvYmpgIG5vZGUuIElmIGBzdHJpY3RgIGlzIHNldCB0byBgdHJ1ZWAgb25seSBzaWJsaW5nIG5vZGVzIGFyZSByZXR1cm5lZC5cblx0XHQgKiBAbmFtZSBnZXRfcHJldl9kb20ob2JqIFssIHN0cmljdF0pXG5cdFx0ICogQHBhcmFtICB7bWl4ZWR9IG9ialxuXHRcdCAqIEBwYXJhbSAge0Jvb2xlYW59IHN0cmljdFxuXHRcdCAqIEByZXR1cm4ge2pRdWVyeX1cblx0XHQgKi9cblx0XHRnZXRfcHJldl9kb20gOiBmdW5jdGlvbiAob2JqLCBzdHJpY3QpIHtcblx0XHRcdHZhciB0bXA7XG5cdFx0XHRvYmogPSB0aGlzLmdldF9ub2RlKG9iaiwgdHJ1ZSk7XG5cdFx0XHRpZihvYmpbMF0gPT09IHRoaXMuZWxlbWVudFswXSkge1xuXHRcdFx0XHR0bXAgPSB0aGlzLmdldF9jb250YWluZXJfdWwoKVswXS5sYXN0Q2hpbGQ7XG5cdFx0XHRcdHdoaWxlICh0bXAgJiYgdG1wLm9mZnNldEhlaWdodCA9PT0gMCkge1xuXHRcdFx0XHRcdHRtcCA9IHRoaXMuX3ByZXZpb3VzU2libGluZyh0bXApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB0bXAgPyAkKHRtcCkgOiBmYWxzZTtcblx0XHRcdH1cblx0XHRcdGlmKCFvYmogfHwgIW9iai5sZW5ndGgpIHtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXHRcdFx0aWYoc3RyaWN0KSB7XG5cdFx0XHRcdHRtcCA9IG9ialswXTtcblx0XHRcdFx0ZG8ge1xuXHRcdFx0XHRcdHRtcCA9IHRoaXMuX3ByZXZpb3VzU2libGluZyh0bXApO1xuXHRcdFx0XHR9IHdoaWxlICh0bXAgJiYgdG1wLm9mZnNldEhlaWdodCA9PT0gMCk7XG5cdFx0XHRcdHJldHVybiB0bXAgPyAkKHRtcCkgOiBmYWxzZTtcblx0XHRcdH1cblx0XHRcdHRtcCA9IG9ialswXTtcblx0XHRcdGRvIHtcblx0XHRcdFx0dG1wID0gdGhpcy5fcHJldmlvdXNTaWJsaW5nKHRtcCk7XG5cdFx0XHR9IHdoaWxlICh0bXAgJiYgdG1wLm9mZnNldEhlaWdodCA9PT0gMCk7XG5cdFx0XHRpZih0bXAgIT09IG51bGwpIHtcblx0XHRcdFx0b2JqID0gJCh0bXApO1xuXHRcdFx0XHR3aGlsZShvYmouaGFzQ2xhc3MoXCJqc3RyZWUtb3BlblwiKSkge1xuXHRcdFx0XHRcdG9iaiA9IG9iai5jaGlsZHJlbihcIi5qc3RyZWUtY2hpbGRyZW5cIikuZmlyc3QoKS5jaGlsZHJlbihcIi5qc3RyZWUtbm9kZTp2aXNpYmxlOmxhc3RcIik7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIG9iajtcblx0XHRcdH1cblx0XHRcdHRtcCA9IG9ialswXS5wYXJlbnROb2RlLnBhcmVudE5vZGU7XG5cdFx0XHRyZXR1cm4gdG1wICYmIHRtcC5jbGFzc05hbWUgJiYgdG1wLmNsYXNzTmFtZS5pbmRleE9mKCdqc3RyZWUtbm9kZScpICE9PSAtMSA/ICQodG1wKSA6IGZhbHNlO1xuXHRcdH0sXG5cdFx0LyoqXG5cdFx0ICogZ2V0IHRoZSBwYXJlbnQgSUQgb2YgYSBub2RlXG5cdFx0ICogQG5hbWUgZ2V0X3BhcmVudChvYmopXG5cdFx0ICogQHBhcmFtICB7bWl4ZWR9IG9ialxuXHRcdCAqIEByZXR1cm4ge1N0cmluZ31cblx0XHQgKi9cblx0XHRnZXRfcGFyZW50IDogZnVuY3Rpb24gKG9iaikge1xuXHRcdFx0b2JqID0gdGhpcy5nZXRfbm9kZShvYmopO1xuXHRcdFx0aWYoIW9iaiB8fCBvYmouaWQgPT09ICQuanN0cmVlLnJvb3QpIHtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG9iai5wYXJlbnQ7XG5cdFx0fSxcblx0XHQvKipcblx0XHQgKiBnZXQgYSBqUXVlcnkgY29sbGVjdGlvbiBvZiBhbGwgdGhlIGNoaWxkcmVuIG9mIGEgbm9kZSAobm9kZSBtdXN0IGJlIHJlbmRlcmVkKVxuXHRcdCAqIEBuYW1lIGdldF9jaGlsZHJlbl9kb20ob2JqKVxuXHRcdCAqIEBwYXJhbSAge21peGVkfSBvYmpcblx0XHQgKiBAcmV0dXJuIHtqUXVlcnl9XG5cdFx0ICovXG5cdFx0Z2V0X2NoaWxkcmVuX2RvbSA6IGZ1bmN0aW9uIChvYmopIHtcblx0XHRcdG9iaiA9IHRoaXMuZ2V0X25vZGUob2JqLCB0cnVlKTtcblx0XHRcdGlmKG9ialswXSA9PT0gdGhpcy5lbGVtZW50WzBdKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLmdldF9jb250YWluZXJfdWwoKS5jaGlsZHJlbihcIi5qc3RyZWUtbm9kZVwiKTtcblx0XHRcdH1cblx0XHRcdGlmKCFvYmogfHwgIW9iai5sZW5ndGgpIHtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG9iai5jaGlsZHJlbihcIi5qc3RyZWUtY2hpbGRyZW5cIikuY2hpbGRyZW4oXCIuanN0cmVlLW5vZGVcIik7XG5cdFx0fSxcblx0XHQvKipcblx0XHQgKiBjaGVja3MgaWYgYSBub2RlIGhhcyBjaGlsZHJlblxuXHRcdCAqIEBuYW1lIGlzX3BhcmVudChvYmopXG5cdFx0ICogQHBhcmFtICB7bWl4ZWR9IG9ialxuXHRcdCAqIEByZXR1cm4ge0Jvb2xlYW59XG5cdFx0ICovXG5cdFx0aXNfcGFyZW50IDogZnVuY3Rpb24gKG9iaikge1xuXHRcdFx0b2JqID0gdGhpcy5nZXRfbm9kZShvYmopO1xuXHRcdFx0cmV0dXJuIG9iaiAmJiAob2JqLnN0YXRlLmxvYWRlZCA9PT0gZmFsc2UgfHwgb2JqLmNoaWxkcmVuLmxlbmd0aCA+IDApO1xuXHRcdH0sXG5cdFx0LyoqXG5cdFx0ICogY2hlY2tzIGlmIGEgbm9kZSBpcyBsb2FkZWQgKGl0cyBjaGlsZHJlbiBhcmUgYXZhaWxhYmxlKVxuXHRcdCAqIEBuYW1lIGlzX2xvYWRlZChvYmopXG5cdFx0ICogQHBhcmFtICB7bWl4ZWR9IG9ialxuXHRcdCAqIEByZXR1cm4ge0Jvb2xlYW59XG5cdFx0ICovXG5cdFx0aXNfbG9hZGVkIDogZnVuY3Rpb24gKG9iaikge1xuXHRcdFx0b2JqID0gdGhpcy5nZXRfbm9kZShvYmopO1xuXHRcdFx0cmV0dXJuIG9iaiAmJiBvYmouc3RhdGUubG9hZGVkO1xuXHRcdH0sXG5cdFx0LyoqXG5cdFx0ICogY2hlY2sgaWYgYSBub2RlIGlzIGN1cnJlbnRseSBsb2FkaW5nIChmZXRjaGluZyBjaGlsZHJlbilcblx0XHQgKiBAbmFtZSBpc19sb2FkaW5nKG9iailcblx0XHQgKiBAcGFyYW0gIHttaXhlZH0gb2JqXG5cdFx0ICogQHJldHVybiB7Qm9vbGVhbn1cblx0XHQgKi9cblx0XHRpc19sb2FkaW5nIDogZnVuY3Rpb24gKG9iaikge1xuXHRcdFx0b2JqID0gdGhpcy5nZXRfbm9kZShvYmopO1xuXHRcdFx0cmV0dXJuIG9iaiAmJiBvYmouc3RhdGUgJiYgb2JqLnN0YXRlLmxvYWRpbmc7XG5cdFx0fSxcblx0XHQvKipcblx0XHQgKiBjaGVjayBpZiBhIG5vZGUgaXMgb3BlbmVkXG5cdFx0ICogQG5hbWUgaXNfb3BlbihvYmopXG5cdFx0ICogQHBhcmFtICB7bWl4ZWR9IG9ialxuXHRcdCAqIEByZXR1cm4ge0Jvb2xlYW59XG5cdFx0ICovXG5cdFx0aXNfb3BlbiA6IGZ1bmN0aW9uIChvYmopIHtcblx0XHRcdG9iaiA9IHRoaXMuZ2V0X25vZGUob2JqKTtcblx0XHRcdHJldHVybiBvYmogJiYgb2JqLnN0YXRlLm9wZW5lZDtcblx0XHR9LFxuXHRcdC8qKlxuXHRcdCAqIGNoZWNrIGlmIGEgbm9kZSBpcyBpbiBhIGNsb3NlZCBzdGF0ZVxuXHRcdCAqIEBuYW1lIGlzX2Nsb3NlZChvYmopXG5cdFx0ICogQHBhcmFtICB7bWl4ZWR9IG9ialxuXHRcdCAqIEByZXR1cm4ge0Jvb2xlYW59XG5cdFx0ICovXG5cdFx0aXNfY2xvc2VkIDogZnVuY3Rpb24gKG9iaikge1xuXHRcdFx0b2JqID0gdGhpcy5nZXRfbm9kZShvYmopO1xuXHRcdFx0cmV0dXJuIG9iaiAmJiB0aGlzLmlzX3BhcmVudChvYmopICYmICFvYmouc3RhdGUub3BlbmVkO1xuXHRcdH0sXG5cdFx0LyoqXG5cdFx0ICogY2hlY2sgaWYgYSBub2RlIGhhcyBubyBjaGlsZHJlblxuXHRcdCAqIEBuYW1lIGlzX2xlYWYob2JqKVxuXHRcdCAqIEBwYXJhbSAge21peGVkfSBvYmpcblx0XHQgKiBAcmV0dXJuIHtCb29sZWFufVxuXHRcdCAqL1xuXHRcdGlzX2xlYWYgOiBmdW5jdGlvbiAob2JqKSB7XG5cdFx0XHRyZXR1cm4gIXRoaXMuaXNfcGFyZW50KG9iaik7XG5cdFx0fSxcblx0XHQvKipcblx0XHQgKiBsb2FkcyBhIG5vZGUgKGZldGNoZXMgaXRzIGNoaWxkcmVuIHVzaW5nIHRoZSBgY29yZS5kYXRhYCBzZXR0aW5nKS4gTXVsdGlwbGUgbm9kZXMgY2FuIGJlIHBhc3NlZCB0byBieSB1c2luZyBhbiBhcnJheS5cblx0XHQgKiBAbmFtZSBsb2FkX25vZGUob2JqIFssIGNhbGxiYWNrXSlcblx0XHQgKiBAcGFyYW0gIHttaXhlZH0gb2JqXG5cdFx0ICogQHBhcmFtICB7ZnVuY3Rpb259IGNhbGxiYWNrIGEgZnVuY3Rpb24gdG8gYmUgZXhlY3V0ZWQgb25jZSBsb2FkaW5nIGlzIGNvbXBsZXRlLCB0aGUgZnVuY3Rpb24gaXMgZXhlY3V0ZWQgaW4gdGhlIGluc3RhbmNlJ3Mgc2NvcGUgYW5kIHJlY2VpdmVzIHR3byBhcmd1bWVudHMgLSB0aGUgbm9kZSBhbmQgYSBib29sZWFuIHN0YXR1c1xuXHRcdCAqIEByZXR1cm4ge0Jvb2xlYW59XG5cdFx0ICogQHRyaWdnZXIgbG9hZF9ub2RlLmpzdHJlZVxuXHRcdCAqL1xuXHRcdGxvYWRfbm9kZSA6IGZ1bmN0aW9uIChvYmosIGNhbGxiYWNrKSB7XG5cdFx0XHR2YXIgaywgbCwgaSwgaiwgYztcblx0XHRcdGlmKCQuaXNBcnJheShvYmopKSB7XG5cdFx0XHRcdHRoaXMuX2xvYWRfbm9kZXMob2JqLnNsaWNlKCksIGNhbGxiYWNrKTtcblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9XG5cdFx0XHRvYmogPSB0aGlzLmdldF9ub2RlKG9iaik7XG5cdFx0XHRpZighb2JqKSB7XG5cdFx0XHRcdGlmKGNhbGxiYWNrKSB7IGNhbGxiYWNrLmNhbGwodGhpcywgb2JqLCBmYWxzZSk7IH1cblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXHRcdFx0Ly8gaWYob2JqLnN0YXRlLmxvYWRpbmcpIHsgfSAvLyB0aGUgbm9kZSBpcyBhbHJlYWR5IGxvYWRpbmcgLSBqdXN0IHdhaXQgZm9yIGl0IHRvIGxvYWQgYW5kIGludm9rZSBjYWxsYmFjaz8gYnV0IGlmIGNhbGxlZCBpbXBsaWNpdGx5IGl0IHNob3VsZCBiZSBsb2FkZWQgYWdhaW4/XG5cdFx0XHRpZihvYmouc3RhdGUubG9hZGVkKSB7XG5cdFx0XHRcdG9iai5zdGF0ZS5sb2FkZWQgPSBmYWxzZTtcblx0XHRcdFx0Zm9yKGkgPSAwLCBqID0gb2JqLnBhcmVudHMubGVuZ3RoOyBpIDwgajsgaSsrKSB7XG5cdFx0XHRcdFx0dGhpcy5fbW9kZWwuZGF0YVtvYmoucGFyZW50c1tpXV0uY2hpbGRyZW5fZCA9ICQudmFrYXRhLmFycmF5X2ZpbHRlcih0aGlzLl9tb2RlbC5kYXRhW29iai5wYXJlbnRzW2ldXS5jaGlsZHJlbl9kLCBmdW5jdGlvbiAodikge1xuXHRcdFx0XHRcdFx0cmV0dXJuICQuaW5BcnJheSh2LCBvYmouY2hpbGRyZW5fZCkgPT09IC0xO1xuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGZvcihrID0gMCwgbCA9IG9iai5jaGlsZHJlbl9kLmxlbmd0aDsgayA8IGw7IGsrKykge1xuXHRcdFx0XHRcdGlmKHRoaXMuX21vZGVsLmRhdGFbb2JqLmNoaWxkcmVuX2Rba11dLnN0YXRlLnNlbGVjdGVkKSB7XG5cdFx0XHRcdFx0XHRjID0gdHJ1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZGVsZXRlIHRoaXMuX21vZGVsLmRhdGFbb2JqLmNoaWxkcmVuX2Rba11dO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChjKSB7XG5cdFx0XHRcdFx0dGhpcy5fZGF0YS5jb3JlLnNlbGVjdGVkID0gJC52YWthdGEuYXJyYXlfZmlsdGVyKHRoaXMuX2RhdGEuY29yZS5zZWxlY3RlZCwgZnVuY3Rpb24gKHYpIHtcblx0XHRcdFx0XHRcdHJldHVybiAkLmluQXJyYXkodiwgb2JqLmNoaWxkcmVuX2QpID09PSAtMTtcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0fVxuXHRcdFx0XHRvYmouY2hpbGRyZW4gPSBbXTtcblx0XHRcdFx0b2JqLmNoaWxkcmVuX2QgPSBbXTtcblx0XHRcdFx0aWYoYykge1xuXHRcdFx0XHRcdHRoaXMudHJpZ2dlcignY2hhbmdlZCcsIHsgJ2FjdGlvbicgOiAnbG9hZF9ub2RlJywgJ25vZGUnIDogb2JqLCAnc2VsZWN0ZWQnIDogdGhpcy5fZGF0YS5jb3JlLnNlbGVjdGVkIH0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRvYmouc3RhdGUuZmFpbGVkID0gZmFsc2U7XG5cdFx0XHRvYmouc3RhdGUubG9hZGluZyA9IHRydWU7XG5cdFx0XHR0aGlzLmdldF9ub2RlKG9iaiwgdHJ1ZSkuYWRkQ2xhc3MoXCJqc3RyZWUtbG9hZGluZ1wiKS5hdHRyKCdhcmlhLWJ1c3knLHRydWUpO1xuXHRcdFx0dGhpcy5fbG9hZF9ub2RlKG9iaiwgJC5wcm94eShmdW5jdGlvbiAoc3RhdHVzKSB7XG5cdFx0XHRcdG9iaiA9IHRoaXMuX21vZGVsLmRhdGFbb2JqLmlkXTtcblx0XHRcdFx0b2JqLnN0YXRlLmxvYWRpbmcgPSBmYWxzZTtcblx0XHRcdFx0b2JqLnN0YXRlLmxvYWRlZCA9IHN0YXR1cztcblx0XHRcdFx0b2JqLnN0YXRlLmZhaWxlZCA9ICFvYmouc3RhdGUubG9hZGVkO1xuXHRcdFx0XHR2YXIgZG9tID0gdGhpcy5nZXRfbm9kZShvYmosIHRydWUpLCBpID0gMCwgaiA9IDAsIG0gPSB0aGlzLl9tb2RlbC5kYXRhLCBoYXNfY2hpbGRyZW4gPSBmYWxzZTtcblx0XHRcdFx0Zm9yKGkgPSAwLCBqID0gb2JqLmNoaWxkcmVuLmxlbmd0aDsgaSA8IGo7IGkrKykge1xuXHRcdFx0XHRcdGlmKG1bb2JqLmNoaWxkcmVuW2ldXSAmJiAhbVtvYmouY2hpbGRyZW5baV1dLnN0YXRlLmhpZGRlbikge1xuXHRcdFx0XHRcdFx0aGFzX2NoaWxkcmVuID0gdHJ1ZTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRpZihvYmouc3RhdGUubG9hZGVkICYmIGRvbSAmJiBkb20ubGVuZ3RoKSB7XG5cdFx0XHRcdFx0ZG9tLnJlbW92ZUNsYXNzKCdqc3RyZWUtY2xvc2VkIGpzdHJlZS1vcGVuIGpzdHJlZS1sZWFmJyk7XG5cdFx0XHRcdFx0aWYgKCFoYXNfY2hpbGRyZW4pIHtcblx0XHRcdFx0XHRcdGRvbS5hZGRDbGFzcygnanN0cmVlLWxlYWYnKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0XHRpZiAob2JqLmlkICE9PSAnIycpIHtcblx0XHRcdFx0XHRcdFx0ZG9tLmFkZENsYXNzKG9iai5zdGF0ZS5vcGVuZWQgPyAnanN0cmVlLW9wZW4nIDogJ2pzdHJlZS1jbG9zZWQnKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0ZG9tLnJlbW92ZUNsYXNzKFwianN0cmVlLWxvYWRpbmdcIikuYXR0cignYXJpYS1idXN5JyxmYWxzZSk7XG5cdFx0XHRcdC8qKlxuXHRcdFx0XHQgKiB0cmlnZ2VyZWQgYWZ0ZXIgYSBub2RlIGlzIGxvYWRlZFxuXHRcdFx0XHQgKiBAZXZlbnRcblx0XHRcdFx0ICogQG5hbWUgbG9hZF9ub2RlLmpzdHJlZVxuXHRcdFx0XHQgKiBAcGFyYW0ge09iamVjdH0gbm9kZSB0aGUgbm9kZSB0aGF0IHdhcyBsb2FkaW5nXG5cdFx0XHRcdCAqIEBwYXJhbSB7Qm9vbGVhbn0gc3RhdHVzIHdhcyB0aGUgbm9kZSBsb2FkZWQgc3VjY2Vzc2Z1bGx5XG5cdFx0XHRcdCAqL1xuXHRcdFx0XHR0aGlzLnRyaWdnZXIoJ2xvYWRfbm9kZScsIHsgXCJub2RlXCIgOiBvYmosIFwic3RhdHVzXCIgOiBzdGF0dXMgfSk7XG5cdFx0XHRcdGlmKGNhbGxiYWNrKSB7XG5cdFx0XHRcdFx0Y2FsbGJhY2suY2FsbCh0aGlzLCBvYmosIHN0YXR1cyk7XG5cdFx0XHRcdH1cblx0XHRcdH0sIHRoaXMpKTtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH0sXG5cdFx0LyoqXG5cdFx0ICogbG9hZCBhbiBhcnJheSBvZiBub2RlcyAod2lsbCBhbHNvIGxvYWQgdW5hdmFpbGFibGUgbm9kZXMgYXMgc29vbiBhcyB0aGUgYXBwZWFyIGluIHRoZSBzdHJ1Y3R1cmUpLiBVc2VkIGludGVybmFsbHkuXG5cdFx0ICogQHByaXZhdGVcblx0XHQgKiBAbmFtZSBfbG9hZF9ub2Rlcyhub2RlcyBbLCBjYWxsYmFja10pXG5cdFx0ICogQHBhcmFtICB7YXJyYXl9IG5vZGVzXG5cdFx0ICogQHBhcmFtICB7ZnVuY3Rpb259IGNhbGxiYWNrIGEgZnVuY3Rpb24gdG8gYmUgZXhlY3V0ZWQgb25jZSBsb2FkaW5nIGlzIGNvbXBsZXRlLCB0aGUgZnVuY3Rpb24gaXMgZXhlY3V0ZWQgaW4gdGhlIGluc3RhbmNlJ3Mgc2NvcGUgYW5kIHJlY2VpdmVzIG9uZSBhcmd1bWVudCAtIHRoZSBhcnJheSBwYXNzZWQgdG8gX2xvYWRfbm9kZXNcblx0XHQgKi9cblx0XHRfbG9hZF9ub2RlcyA6IGZ1bmN0aW9uIChub2RlcywgY2FsbGJhY2ssIGlzX2NhbGxiYWNrLCBmb3JjZV9yZWxvYWQpIHtcblx0XHRcdHZhciByID0gdHJ1ZSxcblx0XHRcdFx0YyA9IGZ1bmN0aW9uICgpIHsgdGhpcy5fbG9hZF9ub2Rlcyhub2RlcywgY2FsbGJhY2ssIHRydWUpOyB9LFxuXHRcdFx0XHRtID0gdGhpcy5fbW9kZWwuZGF0YSwgaSwgaiwgdG1wID0gW107XG5cdFx0XHRmb3IoaSA9IDAsIGogPSBub2Rlcy5sZW5ndGg7IGkgPCBqOyBpKyspIHtcblx0XHRcdFx0aWYobVtub2Rlc1tpXV0gJiYgKCAoIW1bbm9kZXNbaV1dLnN0YXRlLmxvYWRlZCAmJiAhbVtub2Rlc1tpXV0uc3RhdGUuZmFpbGVkKSB8fCAoIWlzX2NhbGxiYWNrICYmIGZvcmNlX3JlbG9hZCkgKSkge1xuXHRcdFx0XHRcdGlmKCF0aGlzLmlzX2xvYWRpbmcobm9kZXNbaV0pKSB7XG5cdFx0XHRcdFx0XHR0aGlzLmxvYWRfbm9kZShub2Rlc1tpXSwgYyk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHIgPSBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0aWYocikge1xuXHRcdFx0XHRmb3IoaSA9IDAsIGogPSBub2Rlcy5sZW5ndGg7IGkgPCBqOyBpKyspIHtcblx0XHRcdFx0XHRpZihtW25vZGVzW2ldXSAmJiBtW25vZGVzW2ldXS5zdGF0ZS5sb2FkZWQpIHtcblx0XHRcdFx0XHRcdHRtcC5wdXNoKG5vZGVzW2ldKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYoY2FsbGJhY2sgJiYgIWNhbGxiYWNrLmRvbmUpIHtcblx0XHRcdFx0XHRjYWxsYmFjay5jYWxsKHRoaXMsIHRtcCk7XG5cdFx0XHRcdFx0Y2FsbGJhY2suZG9uZSA9IHRydWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9LFxuXHRcdC8qKlxuXHRcdCAqIGxvYWRzIGFsbCB1bmxvYWRlZCBub2Rlc1xuXHRcdCAqIEBuYW1lIGxvYWRfYWxsKFtvYmosIGNhbGxiYWNrXSlcblx0XHQgKiBAcGFyYW0ge21peGVkfSBvYmogdGhlIG5vZGUgdG8gbG9hZCByZWN1cnNpdmVseSwgb21pdCB0byBsb2FkIGFsbCBub2RlcyBpbiB0aGUgdHJlZVxuXHRcdCAqIEBwYXJhbSB7ZnVuY3Rpb259IGNhbGxiYWNrIGEgZnVuY3Rpb24gdG8gYmUgZXhlY3V0ZWQgb25jZSBsb2FkaW5nIGFsbCB0aGUgbm9kZXMgaXMgY29tcGxldGUsXG5cdFx0ICogQHRyaWdnZXIgbG9hZF9hbGwuanN0cmVlXG5cdFx0ICovXG5cdFx0bG9hZF9hbGwgOiBmdW5jdGlvbiAob2JqLCBjYWxsYmFjaykge1xuXHRcdFx0aWYoIW9iaikgeyBvYmogPSAkLmpzdHJlZS5yb290OyB9XG5cdFx0XHRvYmogPSB0aGlzLmdldF9ub2RlKG9iaik7XG5cdFx0XHRpZighb2JqKSB7IHJldHVybiBmYWxzZTsgfVxuXHRcdFx0dmFyIHRvX2xvYWQgPSBbXSxcblx0XHRcdFx0bSA9IHRoaXMuX21vZGVsLmRhdGEsXG5cdFx0XHRcdGMgPSBtW29iai5pZF0uY2hpbGRyZW5fZCxcblx0XHRcdFx0aSwgajtcblx0XHRcdGlmKG9iai5zdGF0ZSAmJiAhb2JqLnN0YXRlLmxvYWRlZCkge1xuXHRcdFx0XHR0b19sb2FkLnB1c2gob2JqLmlkKTtcblx0XHRcdH1cblx0XHRcdGZvcihpID0gMCwgaiA9IGMubGVuZ3RoOyBpIDwgajsgaSsrKSB7XG5cdFx0XHRcdGlmKG1bY1tpXV0gJiYgbVtjW2ldXS5zdGF0ZSAmJiAhbVtjW2ldXS5zdGF0ZS5sb2FkZWQpIHtcblx0XHRcdFx0XHR0b19sb2FkLnB1c2goY1tpXSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGlmKHRvX2xvYWQubGVuZ3RoKSB7XG5cdFx0XHRcdHRoaXMuX2xvYWRfbm9kZXModG9fbG9hZCwgZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdHRoaXMubG9hZF9hbGwob2JqLCBjYWxsYmFjayk7XG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSB7XG5cdFx0XHRcdC8qKlxuXHRcdFx0XHQgKiB0cmlnZ2VyZWQgYWZ0ZXIgYSBsb2FkX2FsbCBjYWxsIGNvbXBsZXRlc1xuXHRcdFx0XHQgKiBAZXZlbnRcblx0XHRcdFx0ICogQG5hbWUgbG9hZF9hbGwuanN0cmVlXG5cdFx0XHRcdCAqIEBwYXJhbSB7T2JqZWN0fSBub2RlIHRoZSByZWN1cnNpdmVseSBsb2FkZWQgbm9kZVxuXHRcdFx0XHQgKi9cblx0XHRcdFx0aWYoY2FsbGJhY2spIHsgY2FsbGJhY2suY2FsbCh0aGlzLCBvYmopOyB9XG5cdFx0XHRcdHRoaXMudHJpZ2dlcignbG9hZF9hbGwnLCB7IFwibm9kZVwiIDogb2JqIH0pO1xuXHRcdFx0fVxuXHRcdH0sXG5cdFx0LyoqXG5cdFx0ICogaGFuZGxlcyB0aGUgYWN0dWFsIGxvYWRpbmcgb2YgYSBub2RlLiBVc2VkIG9ubHkgaW50ZXJuYWxseS5cblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqIEBuYW1lIF9sb2FkX25vZGUob2JqIFssIGNhbGxiYWNrXSlcblx0XHQgKiBAcGFyYW0gIHttaXhlZH0gb2JqXG5cdFx0ICogQHBhcmFtICB7ZnVuY3Rpb259IGNhbGxiYWNrIGEgZnVuY3Rpb24gdG8gYmUgZXhlY3V0ZWQgb25jZSBsb2FkaW5nIGlzIGNvbXBsZXRlLCB0aGUgZnVuY3Rpb24gaXMgZXhlY3V0ZWQgaW4gdGhlIGluc3RhbmNlJ3Mgc2NvcGUgYW5kIHJlY2VpdmVzIG9uZSBhcmd1bWVudCAtIGEgYm9vbGVhbiBzdGF0dXNcblx0XHQgKiBAcmV0dXJuIHtCb29sZWFufVxuXHRcdCAqL1xuXHRcdF9sb2FkX25vZGUgOiBmdW5jdGlvbiAob2JqLCBjYWxsYmFjaykge1xuXHRcdFx0dmFyIHMgPSB0aGlzLnNldHRpbmdzLmNvcmUuZGF0YSwgdDtcblx0XHRcdHZhciBub3RUZXh0T3JDb21tZW50Tm9kZSA9IGZ1bmN0aW9uIG5vdFRleHRPckNvbW1lbnROb2RlICgpIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMubm9kZVR5cGUgIT09IDMgJiYgdGhpcy5ub2RlVHlwZSAhPT0gODtcblx0XHRcdH07XG5cdFx0XHQvLyB1c2Ugb3JpZ2luYWwgSFRNTFxuXHRcdFx0aWYoIXMpIHtcblx0XHRcdFx0aWYob2JqLmlkID09PSAkLmpzdHJlZS5yb290KSB7XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXMuX2FwcGVuZF9odG1sX2RhdGEob2JqLCB0aGlzLl9kYXRhLmNvcmUub3JpZ2luYWxfY29udGFpbmVyX2h0bWwuY2xvbmUodHJ1ZSksIGZ1bmN0aW9uIChzdGF0dXMpIHtcblx0XHRcdFx0XHRcdGNhbGxiYWNrLmNhbGwodGhpcywgc3RhdHVzKTtcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRyZXR1cm4gY2FsbGJhY2suY2FsbCh0aGlzLCBmYWxzZSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0Ly8gcmV0dXJuIGNhbGxiYWNrLmNhbGwodGhpcywgb2JqLmlkID09PSAkLmpzdHJlZS5yb290ID8gdGhpcy5fYXBwZW5kX2h0bWxfZGF0YShvYmosIHRoaXMuX2RhdGEuY29yZS5vcmlnaW5hbF9jb250YWluZXJfaHRtbC5jbG9uZSh0cnVlKSkgOiBmYWxzZSk7XG5cdFx0XHR9XG5cdFx0XHRpZigkLmlzRnVuY3Rpb24ocykpIHtcblx0XHRcdFx0cmV0dXJuIHMuY2FsbCh0aGlzLCBvYmosICQucHJveHkoZnVuY3Rpb24gKGQpIHtcblx0XHRcdFx0XHRpZihkID09PSBmYWxzZSkge1xuXHRcdFx0XHRcdFx0Y2FsbGJhY2suY2FsbCh0aGlzLCBmYWxzZSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdFx0dGhpc1t0eXBlb2YgZCA9PT0gJ3N0cmluZycgPyAnX2FwcGVuZF9odG1sX2RhdGEnIDogJ19hcHBlbmRfanNvbl9kYXRhJ10ob2JqLCB0eXBlb2YgZCA9PT0gJ3N0cmluZycgPyAkKCQucGFyc2VIVE1MKGQpKS5maWx0ZXIobm90VGV4dE9yQ29tbWVudE5vZGUpIDogZCwgZnVuY3Rpb24gKHN0YXR1cykge1xuXHRcdFx0XHRcdFx0XHRjYWxsYmFjay5jYWxsKHRoaXMsIHN0YXR1cyk7XG5cdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0Ly8gcmV0dXJuIGQgPT09IGZhbHNlID8gY2FsbGJhY2suY2FsbCh0aGlzLCBmYWxzZSkgOiBjYWxsYmFjay5jYWxsKHRoaXMsIHRoaXNbdHlwZW9mIGQgPT09ICdzdHJpbmcnID8gJ19hcHBlbmRfaHRtbF9kYXRhJyA6ICdfYXBwZW5kX2pzb25fZGF0YSddKG9iaiwgdHlwZW9mIGQgPT09ICdzdHJpbmcnID8gJChkKSA6IGQpKTtcblx0XHRcdFx0fSwgdGhpcykpO1xuXHRcdFx0fVxuXHRcdFx0aWYodHlwZW9mIHMgPT09ICdvYmplY3QnKSB7XG5cdFx0XHRcdGlmKHMudXJsKSB7XG5cdFx0XHRcdFx0cyA9ICQuZXh0ZW5kKHRydWUsIHt9LCBzKTtcblx0XHRcdFx0XHRpZigkLmlzRnVuY3Rpb24ocy51cmwpKSB7XG5cdFx0XHRcdFx0XHRzLnVybCA9IHMudXJsLmNhbGwodGhpcywgb2JqKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYoJC5pc0Z1bmN0aW9uKHMuZGF0YSkpIHtcblx0XHRcdFx0XHRcdHMuZGF0YSA9IHMuZGF0YS5jYWxsKHRoaXMsIG9iaik7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiAkLmFqYXgocylcblx0XHRcdFx0XHRcdC5kb25lKCQucHJveHkoZnVuY3Rpb24gKGQsdCx4KSB7XG5cdFx0XHRcdFx0XHRcdFx0dmFyIHR5cGUgPSB4LmdldFJlc3BvbnNlSGVhZGVyKCdDb250ZW50LVR5cGUnKTtcblx0XHRcdFx0XHRcdFx0XHRpZigodHlwZSAmJiB0eXBlLmluZGV4T2YoJ2pzb24nKSAhPT0gLTEpIHx8IHR5cGVvZiBkID09PSBcIm9iamVjdFwiKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gdGhpcy5fYXBwZW5kX2pzb25fZGF0YShvYmosIGQsIGZ1bmN0aW9uIChzdGF0dXMpIHsgY2FsbGJhY2suY2FsbCh0aGlzLCBzdGF0dXMpOyB9KTtcblx0XHRcdFx0XHRcdFx0XHRcdC8vcmV0dXJuIGNhbGxiYWNrLmNhbGwodGhpcywgdGhpcy5fYXBwZW5kX2pzb25fZGF0YShvYmosIGQpKTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0aWYoKHR5cGUgJiYgdHlwZS5pbmRleE9mKCdodG1sJykgIT09IC0xKSB8fCB0eXBlb2YgZCA9PT0gXCJzdHJpbmdcIikge1xuXHRcdFx0XHRcdFx0XHRcdFx0cmV0dXJuIHRoaXMuX2FwcGVuZF9odG1sX2RhdGEob2JqLCAkKCQucGFyc2VIVE1MKGQpKS5maWx0ZXIobm90VGV4dE9yQ29tbWVudE5vZGUpLCBmdW5jdGlvbiAoc3RhdHVzKSB7IGNhbGxiYWNrLmNhbGwodGhpcywgc3RhdHVzKTsgfSk7XG5cdFx0XHRcdFx0XHRcdFx0XHQvLyByZXR1cm4gY2FsbGJhY2suY2FsbCh0aGlzLCB0aGlzLl9hcHBlbmRfaHRtbF9kYXRhKG9iaiwgJChkKSkpO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR0aGlzLl9kYXRhLmNvcmUubGFzdF9lcnJvciA9IHsgJ2Vycm9yJyA6ICdhamF4JywgJ3BsdWdpbicgOiAnY29yZScsICdpZCcgOiAnY29yZV8wNCcsICdyZWFzb24nIDogJ0NvdWxkIG5vdCBsb2FkIG5vZGUnLCAnZGF0YScgOiBKU09OLnN0cmluZ2lmeSh7ICdpZCcgOiBvYmouaWQsICd4aHInIDogeCB9KSB9O1xuXHRcdFx0XHRcdFx0XHRcdHRoaXMuc2V0dGluZ3MuY29yZS5lcnJvci5jYWxsKHRoaXMsIHRoaXMuX2RhdGEuY29yZS5sYXN0X2Vycm9yKTtcblx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gY2FsbGJhY2suY2FsbCh0aGlzLCBmYWxzZSk7XG5cdFx0XHRcdFx0XHRcdH0sIHRoaXMpKVxuXHRcdFx0XHRcdFx0LmZhaWwoJC5wcm94eShmdW5jdGlvbiAoZikge1xuXHRcdFx0XHRcdFx0XHRcdGNhbGxiYWNrLmNhbGwodGhpcywgZmFsc2UpO1xuXHRcdFx0XHRcdFx0XHRcdHRoaXMuX2RhdGEuY29yZS5sYXN0X2Vycm9yID0geyAnZXJyb3InIDogJ2FqYXgnLCAncGx1Z2luJyA6ICdjb3JlJywgJ2lkJyA6ICdjb3JlXzA0JywgJ3JlYXNvbicgOiAnQ291bGQgbm90IGxvYWQgbm9kZScsICdkYXRhJyA6IEpTT04uc3RyaW5naWZ5KHsgJ2lkJyA6IG9iai5pZCwgJ3hocicgOiBmIH0pIH07XG5cdFx0XHRcdFx0XHRcdFx0dGhpcy5zZXR0aW5ncy5jb3JlLmVycm9yLmNhbGwodGhpcywgdGhpcy5fZGF0YS5jb3JlLmxhc3RfZXJyb3IpO1xuXHRcdFx0XHRcdFx0XHR9LCB0aGlzKSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0dCA9ICgkLmlzQXJyYXkocykgfHwgJC5pc1BsYWluT2JqZWN0KHMpKSA/IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkocykpIDogcztcblx0XHRcdFx0aWYob2JqLmlkID09PSAkLmpzdHJlZS5yb290KSB7XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXMuX2FwcGVuZF9qc29uX2RhdGEob2JqLCB0LCBmdW5jdGlvbiAoc3RhdHVzKSB7XG5cdFx0XHRcdFx0XHRjYWxsYmFjay5jYWxsKHRoaXMsIHN0YXR1cyk7XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0dGhpcy5fZGF0YS5jb3JlLmxhc3RfZXJyb3IgPSB7ICdlcnJvcicgOiAnbm9kYXRhJywgJ3BsdWdpbicgOiAnY29yZScsICdpZCcgOiAnY29yZV8wNScsICdyZWFzb24nIDogJ0NvdWxkIG5vdCBsb2FkIG5vZGUnLCAnZGF0YScgOiBKU09OLnN0cmluZ2lmeSh7ICdpZCcgOiBvYmouaWQgfSkgfTtcblx0XHRcdFx0XHR0aGlzLnNldHRpbmdzLmNvcmUuZXJyb3IuY2FsbCh0aGlzLCB0aGlzLl9kYXRhLmNvcmUubGFzdF9lcnJvcik7XG5cdFx0XHRcdFx0cmV0dXJuIGNhbGxiYWNrLmNhbGwodGhpcywgZmFsc2UpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdC8vcmV0dXJuIGNhbGxiYWNrLmNhbGwodGhpcywgKG9iai5pZCA9PT0gJC5qc3RyZWUucm9vdCA/IHRoaXMuX2FwcGVuZF9qc29uX2RhdGEob2JqLCB0KSA6IGZhbHNlKSApO1xuXHRcdFx0fVxuXHRcdFx0aWYodHlwZW9mIHMgPT09ICdzdHJpbmcnKSB7XG5cdFx0XHRcdGlmKG9iai5pZCA9PT0gJC5qc3RyZWUucm9vdCkge1xuXHRcdFx0XHRcdHJldHVybiB0aGlzLl9hcHBlbmRfaHRtbF9kYXRhKG9iaiwgJCgkLnBhcnNlSFRNTChzKSkuZmlsdGVyKG5vdFRleHRPckNvbW1lbnROb2RlKSwgZnVuY3Rpb24gKHN0YXR1cykge1xuXHRcdFx0XHRcdFx0Y2FsbGJhY2suY2FsbCh0aGlzLCBzdGF0dXMpO1xuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdHRoaXMuX2RhdGEuY29yZS5sYXN0X2Vycm9yID0geyAnZXJyb3InIDogJ25vZGF0YScsICdwbHVnaW4nIDogJ2NvcmUnLCAnaWQnIDogJ2NvcmVfMDYnLCAncmVhc29uJyA6ICdDb3VsZCBub3QgbG9hZCBub2RlJywgJ2RhdGEnIDogSlNPTi5zdHJpbmdpZnkoeyAnaWQnIDogb2JqLmlkIH0pIH07XG5cdFx0XHRcdFx0dGhpcy5zZXR0aW5ncy5jb3JlLmVycm9yLmNhbGwodGhpcywgdGhpcy5fZGF0YS5jb3JlLmxhc3RfZXJyb3IpO1xuXHRcdFx0XHRcdHJldHVybiBjYWxsYmFjay5jYWxsKHRoaXMsIGZhbHNlKTtcblx0XHRcdFx0fVxuXHRcdFx0XHQvL3JldHVybiBjYWxsYmFjay5jYWxsKHRoaXMsIChvYmouaWQgPT09ICQuanN0cmVlLnJvb3QgPyB0aGlzLl9hcHBlbmRfaHRtbF9kYXRhKG9iaiwgJChzKSkgOiBmYWxzZSkgKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBjYWxsYmFjay5jYWxsKHRoaXMsIGZhbHNlKTtcblx0XHR9LFxuXHRcdC8qKlxuXHRcdCAqIGFkZHMgYSBub2RlIHRvIHRoZSBsaXN0IG9mIG5vZGVzIHRvIHJlZHJhdy4gVXNlZCBvbmx5IGludGVybmFsbHkuXG5cdFx0ICogQHByaXZhdGVcblx0XHQgKiBAbmFtZSBfbm9kZV9jaGFuZ2VkKG9iaiBbLCBjYWxsYmFja10pXG5cdFx0ICogQHBhcmFtICB7bWl4ZWR9IG9ialxuXHRcdCAqL1xuXHRcdF9ub2RlX2NoYW5nZWQgOiBmdW5jdGlvbiAob2JqKSB7XG5cdFx0XHRvYmogPSB0aGlzLmdldF9ub2RlKG9iaik7XG5cdFx0XHRpZihvYmopIHtcblx0XHRcdFx0dGhpcy5fbW9kZWwuY2hhbmdlZC5wdXNoKG9iai5pZCk7XG5cdFx0XHR9XG5cdFx0fSxcblx0XHQvKipcblx0XHQgKiBhcHBlbmRzIEhUTUwgY29udGVudCB0byB0aGUgdHJlZS4gVXNlZCBpbnRlcm5hbGx5LlxuXHRcdCAqIEBwcml2YXRlXG5cdFx0ICogQG5hbWUgX2FwcGVuZF9odG1sX2RhdGEob2JqLCBkYXRhKVxuXHRcdCAqIEBwYXJhbSAge21peGVkfSBvYmogdGhlIG5vZGUgdG8gYXBwZW5kIHRvXG5cdFx0ICogQHBhcmFtICB7U3RyaW5nfSBkYXRhIHRoZSBIVE1MIHN0cmluZyB0byBwYXJzZSBhbmQgYXBwZW5kXG5cdFx0ICogQHRyaWdnZXIgbW9kZWwuanN0cmVlLCBjaGFuZ2VkLmpzdHJlZVxuXHRcdCAqL1xuXHRcdF9hcHBlbmRfaHRtbF9kYXRhIDogZnVuY3Rpb24gKGRvbSwgZGF0YSwgY2IpIHtcblx0XHRcdGRvbSA9IHRoaXMuZ2V0X25vZGUoZG9tKTtcblx0XHRcdGRvbS5jaGlsZHJlbiA9IFtdO1xuXHRcdFx0ZG9tLmNoaWxkcmVuX2QgPSBbXTtcblx0XHRcdHZhciBkYXQgPSBkYXRhLmlzKCd1bCcpID8gZGF0YS5jaGlsZHJlbigpIDogZGF0YSxcblx0XHRcdFx0cGFyID0gZG9tLmlkLFxuXHRcdFx0XHRjaGQgPSBbXSxcblx0XHRcdFx0ZHBjID0gW10sXG5cdFx0XHRcdG0gPSB0aGlzLl9tb2RlbC5kYXRhLFxuXHRcdFx0XHRwID0gbVtwYXJdLFxuXHRcdFx0XHRzID0gdGhpcy5fZGF0YS5jb3JlLnNlbGVjdGVkLmxlbmd0aCxcblx0XHRcdFx0dG1wLCBpLCBqO1xuXHRcdFx0ZGF0LmVhY2goJC5wcm94eShmdW5jdGlvbiAoaSwgdikge1xuXHRcdFx0XHR0bXAgPSB0aGlzLl9wYXJzZV9tb2RlbF9mcm9tX2h0bWwoJCh2KSwgcGFyLCBwLnBhcmVudHMuY29uY2F0KCkpO1xuXHRcdFx0XHRpZih0bXApIHtcblx0XHRcdFx0XHRjaGQucHVzaCh0bXApO1xuXHRcdFx0XHRcdGRwYy5wdXNoKHRtcCk7XG5cdFx0XHRcdFx0aWYobVt0bXBdLmNoaWxkcmVuX2QubGVuZ3RoKSB7XG5cdFx0XHRcdFx0XHRkcGMgPSBkcGMuY29uY2F0KG1bdG1wXS5jaGlsZHJlbl9kKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0sIHRoaXMpKTtcblx0XHRcdHAuY2hpbGRyZW4gPSBjaGQ7XG5cdFx0XHRwLmNoaWxkcmVuX2QgPSBkcGM7XG5cdFx0XHRmb3IoaSA9IDAsIGogPSBwLnBhcmVudHMubGVuZ3RoOyBpIDwgajsgaSsrKSB7XG5cdFx0XHRcdG1bcC5wYXJlbnRzW2ldXS5jaGlsZHJlbl9kID0gbVtwLnBhcmVudHNbaV1dLmNoaWxkcmVuX2QuY29uY2F0KGRwYyk7XG5cdFx0XHR9XG5cdFx0XHQvKipcblx0XHRcdCAqIHRyaWdnZXJlZCB3aGVuIG5ldyBkYXRhIGlzIGluc2VydGVkIHRvIHRoZSB0cmVlIG1vZGVsXG5cdFx0XHQgKiBAZXZlbnRcblx0XHRcdCAqIEBuYW1lIG1vZGVsLmpzdHJlZVxuXHRcdFx0ICogQHBhcmFtIHtBcnJheX0gbm9kZXMgYW4gYXJyYXkgb2Ygbm9kZSBJRHNcblx0XHRcdCAqIEBwYXJhbSB7U3RyaW5nfSBwYXJlbnQgdGhlIHBhcmVudCBJRCBvZiB0aGUgbm9kZXNcblx0XHRcdCAqL1xuXHRcdFx0dGhpcy50cmlnZ2VyKCdtb2RlbCcsIHsgXCJub2Rlc1wiIDogZHBjLCAncGFyZW50JyA6IHBhciB9KTtcblx0XHRcdGlmKHBhciAhPT0gJC5qc3RyZWUucm9vdCkge1xuXHRcdFx0XHR0aGlzLl9ub2RlX2NoYW5nZWQocGFyKTtcblx0XHRcdFx0dGhpcy5yZWRyYXcoKTtcblx0XHRcdH1cblx0XHRcdGVsc2Uge1xuXHRcdFx0XHR0aGlzLmdldF9jb250YWluZXJfdWwoKS5jaGlsZHJlbignLmpzdHJlZS1pbml0aWFsLW5vZGUnKS5yZW1vdmUoKTtcblx0XHRcdFx0dGhpcy5yZWRyYXcodHJ1ZSk7XG5cdFx0XHR9XG5cdFx0XHRpZih0aGlzLl9kYXRhLmNvcmUuc2VsZWN0ZWQubGVuZ3RoICE9PSBzKSB7XG5cdFx0XHRcdHRoaXMudHJpZ2dlcignY2hhbmdlZCcsIHsgJ2FjdGlvbicgOiAnbW9kZWwnLCAnc2VsZWN0ZWQnIDogdGhpcy5fZGF0YS5jb3JlLnNlbGVjdGVkIH0pO1xuXHRcdFx0fVxuXHRcdFx0Y2IuY2FsbCh0aGlzLCB0cnVlKTtcblx0XHR9LFxuXHRcdC8qKlxuXHRcdCAqIGFwcGVuZHMgSlNPTiBjb250ZW50IHRvIHRoZSB0cmVlLiBVc2VkIGludGVybmFsbHkuXG5cdFx0ICogQHByaXZhdGVcblx0XHQgKiBAbmFtZSBfYXBwZW5kX2pzb25fZGF0YShvYmosIGRhdGEpXG5cdFx0ICogQHBhcmFtICB7bWl4ZWR9IG9iaiB0aGUgbm9kZSB0byBhcHBlbmQgdG9cblx0XHQgKiBAcGFyYW0gIHtTdHJpbmd9IGRhdGEgdGhlIEpTT04gb2JqZWN0IHRvIHBhcnNlIGFuZCBhcHBlbmRcblx0XHQgKiBAcGFyYW0gIHtCb29sZWFufSBmb3JjZV9wcm9jZXNzaW5nIGludGVybmFsIHBhcmFtIC0gZG8gbm90IHNldFxuXHRcdCAqIEB0cmlnZ2VyIG1vZGVsLmpzdHJlZSwgY2hhbmdlZC5qc3RyZWVcblx0XHQgKi9cblx0XHRfYXBwZW5kX2pzb25fZGF0YSA6IGZ1bmN0aW9uIChkb20sIGRhdGEsIGNiLCBmb3JjZV9wcm9jZXNzaW5nKSB7XG5cdFx0XHRpZih0aGlzLmVsZW1lbnQgPT09IG51bGwpIHsgcmV0dXJuOyB9XG5cdFx0XHRkb20gPSB0aGlzLmdldF9ub2RlKGRvbSk7XG5cdFx0XHRkb20uY2hpbGRyZW4gPSBbXTtcblx0XHRcdGRvbS5jaGlsZHJlbl9kID0gW107XG5cdFx0XHQvLyAqJSRAISEhXG5cdFx0XHRpZihkYXRhLmQpIHtcblx0XHRcdFx0ZGF0YSA9IGRhdGEuZDtcblx0XHRcdFx0aWYodHlwZW9mIGRhdGEgPT09IFwic3RyaW5nXCIpIHtcblx0XHRcdFx0XHRkYXRhID0gSlNPTi5wYXJzZShkYXRhKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0aWYoISQuaXNBcnJheShkYXRhKSkgeyBkYXRhID0gW2RhdGFdOyB9XG5cdFx0XHR2YXIgdyA9IG51bGwsXG5cdFx0XHRcdGFyZ3MgPSB7XG5cdFx0XHRcdFx0J2RmJ1x0OiB0aGlzLl9tb2RlbC5kZWZhdWx0X3N0YXRlLFxuXHRcdFx0XHRcdCdkYXQnXHQ6IGRhdGEsXG5cdFx0XHRcdFx0J3BhcidcdDogZG9tLmlkLFxuXHRcdFx0XHRcdCdtJ1x0XHQ6IHRoaXMuX21vZGVsLmRhdGEsXG5cdFx0XHRcdFx0J3RfaWQnXHQ6IHRoaXMuX2lkLFxuXHRcdFx0XHRcdCd0X2NudCdcdDogdGhpcy5fY250LFxuXHRcdFx0XHRcdCdzZWwnXHQ6IHRoaXMuX2RhdGEuY29yZS5zZWxlY3RlZFxuXHRcdFx0XHR9LFxuXHRcdFx0XHRmdW5jID0gZnVuY3Rpb24gKGRhdGEsIHVuZGVmaW5lZCkge1xuXHRcdFx0XHRcdGlmKGRhdGEuZGF0YSkgeyBkYXRhID0gZGF0YS5kYXRhOyB9XG5cdFx0XHRcdFx0dmFyIGRhdCA9IGRhdGEuZGF0LFxuXHRcdFx0XHRcdFx0cGFyID0gZGF0YS5wYXIsXG5cdFx0XHRcdFx0XHRjaGQgPSBbXSxcblx0XHRcdFx0XHRcdGRwYyA9IFtdLFxuXHRcdFx0XHRcdFx0YWRkID0gW10sXG5cdFx0XHRcdFx0XHRkZiA9IGRhdGEuZGYsXG5cdFx0XHRcdFx0XHR0X2lkID0gZGF0YS50X2lkLFxuXHRcdFx0XHRcdFx0dF9jbnQgPSBkYXRhLnRfY250LFxuXHRcdFx0XHRcdFx0bSA9IGRhdGEubSxcblx0XHRcdFx0XHRcdHAgPSBtW3Bhcl0sXG5cdFx0XHRcdFx0XHRzZWwgPSBkYXRhLnNlbCxcblx0XHRcdFx0XHRcdHRtcCwgaSwgaiwgcnNsdCxcblx0XHRcdFx0XHRcdHBhcnNlX2ZsYXQgPSBmdW5jdGlvbiAoZCwgcCwgcHMpIHtcblx0XHRcdFx0XHRcdFx0aWYoIXBzKSB7IHBzID0gW107IH1cblx0XHRcdFx0XHRcdFx0ZWxzZSB7IHBzID0gcHMuY29uY2F0KCk7IH1cblx0XHRcdFx0XHRcdFx0aWYocCkgeyBwcy51bnNoaWZ0KHApOyB9XG5cdFx0XHRcdFx0XHRcdHZhciB0aWQgPSBkLmlkLnRvU3RyaW5nKCksXG5cdFx0XHRcdFx0XHRcdFx0aSwgaiwgYywgZSxcblx0XHRcdFx0XHRcdFx0XHR0bXAgPSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRpZFx0XHRcdDogdGlkLFxuXHRcdFx0XHRcdFx0XHRcdFx0dGV4dFx0XHQ6IGQudGV4dCB8fCAnJyxcblx0XHRcdFx0XHRcdFx0XHRcdGljb25cdFx0OiBkLmljb24gIT09IHVuZGVmaW5lZCA/IGQuaWNvbiA6IHRydWUsXG5cdFx0XHRcdFx0XHRcdFx0XHRwYXJlbnRcdFx0OiBwLFxuXHRcdFx0XHRcdFx0XHRcdFx0cGFyZW50c1x0XHQ6IHBzLFxuXHRcdFx0XHRcdFx0XHRcdFx0Y2hpbGRyZW5cdDogZC5jaGlsZHJlbiB8fCBbXSxcblx0XHRcdFx0XHRcdFx0XHRcdGNoaWxkcmVuX2RcdDogZC5jaGlsZHJlbl9kIHx8IFtdLFxuXHRcdFx0XHRcdFx0XHRcdFx0ZGF0YVx0XHQ6IGQuZGF0YSxcblx0XHRcdFx0XHRcdFx0XHRcdHN0YXRlXHRcdDogeyB9LFxuXHRcdFx0XHRcdFx0XHRcdFx0bGlfYXR0clx0XHQ6IHsgaWQgOiBmYWxzZSB9LFxuXHRcdFx0XHRcdFx0XHRcdFx0YV9hdHRyXHRcdDogeyBocmVmIDogJyMnIH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRvcmlnaW5hbFx0OiBmYWxzZVxuXHRcdFx0XHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0XHRcdGZvcihpIGluIGRmKSB7XG5cdFx0XHRcdFx0XHRcdFx0aWYoZGYuaGFzT3duUHJvcGVydHkoaSkpIHtcblx0XHRcdFx0XHRcdFx0XHRcdHRtcC5zdGF0ZVtpXSA9IGRmW2ldO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRpZihkICYmIGQuZGF0YSAmJiBkLmRhdGEuanN0cmVlICYmIGQuZGF0YS5qc3RyZWUuaWNvbikge1xuXHRcdFx0XHRcdFx0XHRcdHRtcC5pY29uID0gZC5kYXRhLmpzdHJlZS5pY29uO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdGlmKHRtcC5pY29uID09PSB1bmRlZmluZWQgfHwgdG1wLmljb24gPT09IG51bGwgfHwgdG1wLmljb24gPT09IFwiXCIpIHtcblx0XHRcdFx0XHRcdFx0XHR0bXAuaWNvbiA9IHRydWU7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0aWYoZCAmJiBkLmRhdGEpIHtcblx0XHRcdFx0XHRcdFx0XHR0bXAuZGF0YSA9IGQuZGF0YTtcblx0XHRcdFx0XHRcdFx0XHRpZihkLmRhdGEuanN0cmVlKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRmb3IoaSBpbiBkLmRhdGEuanN0cmVlKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlmKGQuZGF0YS5qc3RyZWUuaGFzT3duUHJvcGVydHkoaSkpIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR0bXAuc3RhdGVbaV0gPSBkLmRhdGEuanN0cmVlW2ldO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdGlmKGQgJiYgdHlwZW9mIGQuc3RhdGUgPT09ICdvYmplY3QnKSB7XG5cdFx0XHRcdFx0XHRcdFx0Zm9yIChpIGluIGQuc3RhdGUpIHtcblx0XHRcdFx0XHRcdFx0XHRcdGlmKGQuc3RhdGUuaGFzT3duUHJvcGVydHkoaSkpIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dG1wLnN0YXRlW2ldID0gZC5zdGF0ZVtpXTtcblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0aWYoZCAmJiB0eXBlb2YgZC5saV9hdHRyID09PSAnb2JqZWN0Jykge1xuXHRcdFx0XHRcdFx0XHRcdGZvciAoaSBpbiBkLmxpX2F0dHIpIHtcblx0XHRcdFx0XHRcdFx0XHRcdGlmKGQubGlfYXR0ci5oYXNPd25Qcm9wZXJ0eShpKSkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0bXAubGlfYXR0cltpXSA9IGQubGlfYXR0cltpXTtcblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0aWYoIXRtcC5saV9hdHRyLmlkKSB7XG5cdFx0XHRcdFx0XHRcdFx0dG1wLmxpX2F0dHIuaWQgPSB0aWQ7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0aWYoZCAmJiB0eXBlb2YgZC5hX2F0dHIgPT09ICdvYmplY3QnKSB7XG5cdFx0XHRcdFx0XHRcdFx0Zm9yIChpIGluIGQuYV9hdHRyKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRpZihkLmFfYXR0ci5oYXNPd25Qcm9wZXJ0eShpKSkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0bXAuYV9hdHRyW2ldID0gZC5hX2F0dHJbaV07XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdGlmKGQgJiYgZC5jaGlsZHJlbiAmJiBkLmNoaWxkcmVuID09PSB0cnVlKSB7XG5cdFx0XHRcdFx0XHRcdFx0dG1wLnN0YXRlLmxvYWRlZCA9IGZhbHNlO1xuXHRcdFx0XHRcdFx0XHRcdHRtcC5jaGlsZHJlbiA9IFtdO1xuXHRcdFx0XHRcdFx0XHRcdHRtcC5jaGlsZHJlbl9kID0gW107XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0bVt0bXAuaWRdID0gdG1wO1xuXHRcdFx0XHRcdFx0XHRmb3IoaSA9IDAsIGogPSB0bXAuY2hpbGRyZW4ubGVuZ3RoOyBpIDwgajsgaSsrKSB7XG5cdFx0XHRcdFx0XHRcdFx0YyA9IHBhcnNlX2ZsYXQobVt0bXAuY2hpbGRyZW5baV1dLCB0bXAuaWQsIHBzKTtcblx0XHRcdFx0XHRcdFx0XHRlID0gbVtjXTtcblx0XHRcdFx0XHRcdFx0XHR0bXAuY2hpbGRyZW5fZC5wdXNoKGMpO1xuXHRcdFx0XHRcdFx0XHRcdGlmKGUuY2hpbGRyZW5fZC5sZW5ndGgpIHtcblx0XHRcdFx0XHRcdFx0XHRcdHRtcC5jaGlsZHJlbl9kID0gdG1wLmNoaWxkcmVuX2QuY29uY2F0KGUuY2hpbGRyZW5fZCk7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdGRlbGV0ZSBkLmRhdGE7XG5cdFx0XHRcdFx0XHRcdGRlbGV0ZSBkLmNoaWxkcmVuO1xuXHRcdFx0XHRcdFx0XHRtW3RtcC5pZF0ub3JpZ2luYWwgPSBkO1xuXHRcdFx0XHRcdFx0XHRpZih0bXAuc3RhdGUuc2VsZWN0ZWQpIHtcblx0XHRcdFx0XHRcdFx0XHRhZGQucHVzaCh0bXAuaWQpO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdHJldHVybiB0bXAuaWQ7XG5cdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0cGFyc2VfbmVzdCA9IGZ1bmN0aW9uIChkLCBwLCBwcykge1xuXHRcdFx0XHRcdFx0XHRpZighcHMpIHsgcHMgPSBbXTsgfVxuXHRcdFx0XHRcdFx0XHRlbHNlIHsgcHMgPSBwcy5jb25jYXQoKTsgfVxuXHRcdFx0XHRcdFx0XHRpZihwKSB7IHBzLnVuc2hpZnQocCk7IH1cblx0XHRcdFx0XHRcdFx0dmFyIHRpZCA9IGZhbHNlLCBpLCBqLCBjLCBlLCB0bXA7XG5cdFx0XHRcdFx0XHRcdGRvIHtcblx0XHRcdFx0XHRcdFx0XHR0aWQgPSAnaicgKyB0X2lkICsgJ18nICsgKCsrdF9jbnQpO1xuXHRcdFx0XHRcdFx0XHR9IHdoaWxlKG1bdGlkXSk7XG5cblx0XHRcdFx0XHRcdFx0dG1wID0ge1xuXHRcdFx0XHRcdFx0XHRcdGlkXHRcdFx0OiBmYWxzZSxcblx0XHRcdFx0XHRcdFx0XHR0ZXh0XHRcdDogdHlwZW9mIGQgPT09ICdzdHJpbmcnID8gZCA6ICcnLFxuXHRcdFx0XHRcdFx0XHRcdGljb25cdFx0OiB0eXBlb2YgZCA9PT0gJ29iamVjdCcgJiYgZC5pY29uICE9PSB1bmRlZmluZWQgPyBkLmljb24gOiB0cnVlLFxuXHRcdFx0XHRcdFx0XHRcdHBhcmVudFx0XHQ6IHAsXG5cdFx0XHRcdFx0XHRcdFx0cGFyZW50c1x0XHQ6IHBzLFxuXHRcdFx0XHRcdFx0XHRcdGNoaWxkcmVuXHQ6IFtdLFxuXHRcdFx0XHRcdFx0XHRcdGNoaWxkcmVuX2RcdDogW10sXG5cdFx0XHRcdFx0XHRcdFx0ZGF0YVx0XHQ6IG51bGwsXG5cdFx0XHRcdFx0XHRcdFx0c3RhdGVcdFx0OiB7IH0sXG5cdFx0XHRcdFx0XHRcdFx0bGlfYXR0clx0XHQ6IHsgaWQgOiBmYWxzZSB9LFxuXHRcdFx0XHRcdFx0XHRcdGFfYXR0clx0XHQ6IHsgaHJlZiA6ICcjJyB9LFxuXHRcdFx0XHRcdFx0XHRcdG9yaWdpbmFsXHQ6IGZhbHNlXG5cdFx0XHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0XHRcdGZvcihpIGluIGRmKSB7XG5cdFx0XHRcdFx0XHRcdFx0aWYoZGYuaGFzT3duUHJvcGVydHkoaSkpIHtcblx0XHRcdFx0XHRcdFx0XHRcdHRtcC5zdGF0ZVtpXSA9IGRmW2ldO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRpZihkICYmIGQuaWQpIHsgdG1wLmlkID0gZC5pZC50b1N0cmluZygpOyB9XG5cdFx0XHRcdFx0XHRcdGlmKGQgJiYgZC50ZXh0KSB7IHRtcC50ZXh0ID0gZC50ZXh0OyB9XG5cdFx0XHRcdFx0XHRcdGlmKGQgJiYgZC5kYXRhICYmIGQuZGF0YS5qc3RyZWUgJiYgZC5kYXRhLmpzdHJlZS5pY29uKSB7XG5cdFx0XHRcdFx0XHRcdFx0dG1wLmljb24gPSBkLmRhdGEuanN0cmVlLmljb247XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0aWYodG1wLmljb24gPT09IHVuZGVmaW5lZCB8fCB0bXAuaWNvbiA9PT0gbnVsbCB8fCB0bXAuaWNvbiA9PT0gXCJcIikge1xuXHRcdFx0XHRcdFx0XHRcdHRtcC5pY29uID0gdHJ1ZTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRpZihkICYmIGQuZGF0YSkge1xuXHRcdFx0XHRcdFx0XHRcdHRtcC5kYXRhID0gZC5kYXRhO1xuXHRcdFx0XHRcdFx0XHRcdGlmKGQuZGF0YS5qc3RyZWUpIHtcblx0XHRcdFx0XHRcdFx0XHRcdGZvcihpIGluIGQuZGF0YS5qc3RyZWUpIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWYoZC5kYXRhLmpzdHJlZS5oYXNPd25Qcm9wZXJ0eShpKSkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHRtcC5zdGF0ZVtpXSA9IGQuZGF0YS5qc3RyZWVbaV07XG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0aWYoZCAmJiB0eXBlb2YgZC5zdGF0ZSA9PT0gJ29iamVjdCcpIHtcblx0XHRcdFx0XHRcdFx0XHRmb3IgKGkgaW4gZC5zdGF0ZSkge1xuXHRcdFx0XHRcdFx0XHRcdFx0aWYoZC5zdGF0ZS5oYXNPd25Qcm9wZXJ0eShpKSkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0bXAuc3RhdGVbaV0gPSBkLnN0YXRlW2ldO1xuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRpZihkICYmIHR5cGVvZiBkLmxpX2F0dHIgPT09ICdvYmplY3QnKSB7XG5cdFx0XHRcdFx0XHRcdFx0Zm9yIChpIGluIGQubGlfYXR0cikge1xuXHRcdFx0XHRcdFx0XHRcdFx0aWYoZC5saV9hdHRyLmhhc093blByb3BlcnR5KGkpKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHRtcC5saV9hdHRyW2ldID0gZC5saV9hdHRyW2ldO1xuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRpZih0bXAubGlfYXR0ci5pZCAmJiAhdG1wLmlkKSB7XG5cdFx0XHRcdFx0XHRcdFx0dG1wLmlkID0gdG1wLmxpX2F0dHIuaWQudG9TdHJpbmcoKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRpZighdG1wLmlkKSB7XG5cdFx0XHRcdFx0XHRcdFx0dG1wLmlkID0gdGlkO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdGlmKCF0bXAubGlfYXR0ci5pZCkge1xuXHRcdFx0XHRcdFx0XHRcdHRtcC5saV9hdHRyLmlkID0gdG1wLmlkO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdGlmKGQgJiYgdHlwZW9mIGQuYV9hdHRyID09PSAnb2JqZWN0Jykge1xuXHRcdFx0XHRcdFx0XHRcdGZvciAoaSBpbiBkLmFfYXR0cikge1xuXHRcdFx0XHRcdFx0XHRcdFx0aWYoZC5hX2F0dHIuaGFzT3duUHJvcGVydHkoaSkpIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dG1wLmFfYXR0cltpXSA9IGQuYV9hdHRyW2ldO1xuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRpZihkICYmIGQuY2hpbGRyZW4gJiYgZC5jaGlsZHJlbi5sZW5ndGgpIHtcblx0XHRcdFx0XHRcdFx0XHRmb3IoaSA9IDAsIGogPSBkLmNoaWxkcmVuLmxlbmd0aDsgaSA8IGo7IGkrKykge1xuXHRcdFx0XHRcdFx0XHRcdFx0YyA9IHBhcnNlX25lc3QoZC5jaGlsZHJlbltpXSwgdG1wLmlkLCBwcyk7XG5cdFx0XHRcdFx0XHRcdFx0XHRlID0gbVtjXTtcblx0XHRcdFx0XHRcdFx0XHRcdHRtcC5jaGlsZHJlbi5wdXNoKGMpO1xuXHRcdFx0XHRcdFx0XHRcdFx0aWYoZS5jaGlsZHJlbl9kLmxlbmd0aCkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0bXAuY2hpbGRyZW5fZCA9IHRtcC5jaGlsZHJlbl9kLmNvbmNhdChlLmNoaWxkcmVuX2QpO1xuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR0bXAuY2hpbGRyZW5fZCA9IHRtcC5jaGlsZHJlbl9kLmNvbmNhdCh0bXAuY2hpbGRyZW4pO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdGlmKGQgJiYgZC5jaGlsZHJlbiAmJiBkLmNoaWxkcmVuID09PSB0cnVlKSB7XG5cdFx0XHRcdFx0XHRcdFx0dG1wLnN0YXRlLmxvYWRlZCA9IGZhbHNlO1xuXHRcdFx0XHRcdFx0XHRcdHRtcC5jaGlsZHJlbiA9IFtdO1xuXHRcdFx0XHRcdFx0XHRcdHRtcC5jaGlsZHJlbl9kID0gW107XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0ZGVsZXRlIGQuZGF0YTtcblx0XHRcdFx0XHRcdFx0ZGVsZXRlIGQuY2hpbGRyZW47XG5cdFx0XHRcdFx0XHRcdHRtcC5vcmlnaW5hbCA9IGQ7XG5cdFx0XHRcdFx0XHRcdG1bdG1wLmlkXSA9IHRtcDtcblx0XHRcdFx0XHRcdFx0aWYodG1wLnN0YXRlLnNlbGVjdGVkKSB7XG5cdFx0XHRcdFx0XHRcdFx0YWRkLnB1c2godG1wLmlkKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRyZXR1cm4gdG1wLmlkO1xuXHRcdFx0XHRcdFx0fTtcblxuXHRcdFx0XHRcdGlmKGRhdC5sZW5ndGggJiYgZGF0WzBdLmlkICE9PSB1bmRlZmluZWQgJiYgZGF0WzBdLnBhcmVudCAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdFx0XHQvLyBGbGF0IEpTT04gc3VwcG9ydCAoZm9yIGVhc3kgaW1wb3J0IGZyb20gREIpOlxuXHRcdFx0XHRcdFx0Ly8gMSkgY29udmVydCB0byBvYmplY3QgKGZvcmVhY2gpXG5cdFx0XHRcdFx0XHRmb3IoaSA9IDAsIGogPSBkYXQubGVuZ3RoOyBpIDwgajsgaSsrKSB7XG5cdFx0XHRcdFx0XHRcdGlmKCFkYXRbaV0uY2hpbGRyZW4pIHtcblx0XHRcdFx0XHRcdFx0XHRkYXRbaV0uY2hpbGRyZW4gPSBbXTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRtW2RhdFtpXS5pZC50b1N0cmluZygpXSA9IGRhdFtpXTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdC8vIDIpIHBvcHVsYXRlIGNoaWxkcmVuIChmb3JlYWNoKVxuXHRcdFx0XHRcdFx0Zm9yKGkgPSAwLCBqID0gZGF0Lmxlbmd0aDsgaSA8IGo7IGkrKykge1xuXHRcdFx0XHRcdFx0XHRtW2RhdFtpXS5wYXJlbnQudG9TdHJpbmcoKV0uY2hpbGRyZW4ucHVzaChkYXRbaV0uaWQudG9TdHJpbmcoKSk7XG5cdFx0XHRcdFx0XHRcdC8vIHBvcHVsYXRlIHBhcmVudC5jaGlsZHJlbl9kXG5cdFx0XHRcdFx0XHRcdHAuY2hpbGRyZW5fZC5wdXNoKGRhdFtpXS5pZC50b1N0cmluZygpKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdC8vIDMpIG5vcm1hbGl6ZSAmJiBwb3B1bGF0ZSBwYXJlbnRzIGFuZCBjaGlsZHJlbl9kIHdpdGggcmVjdXJzaW9uXG5cdFx0XHRcdFx0XHRmb3IoaSA9IDAsIGogPSBwLmNoaWxkcmVuLmxlbmd0aDsgaSA8IGo7IGkrKykge1xuXHRcdFx0XHRcdFx0XHR0bXAgPSBwYXJzZV9mbGF0KG1bcC5jaGlsZHJlbltpXV0sIHBhciwgcC5wYXJlbnRzLmNvbmNhdCgpKTtcblx0XHRcdFx0XHRcdFx0ZHBjLnB1c2godG1wKTtcblx0XHRcdFx0XHRcdFx0aWYobVt0bXBdLmNoaWxkcmVuX2QubGVuZ3RoKSB7XG5cdFx0XHRcdFx0XHRcdFx0ZHBjID0gZHBjLmNvbmNhdChtW3RtcF0uY2hpbGRyZW5fZCk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGZvcihpID0gMCwgaiA9IHAucGFyZW50cy5sZW5ndGg7IGkgPCBqOyBpKyspIHtcblx0XHRcdFx0XHRcdFx0bVtwLnBhcmVudHNbaV1dLmNoaWxkcmVuX2QgPSBtW3AucGFyZW50c1tpXV0uY2hpbGRyZW5fZC5jb25jYXQoZHBjKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdC8vID8pIHRocmVlX3N0YXRlIHNlbGVjdGlvbiAtIHAuc3RhdGUuc2VsZWN0ZWQgJiYgdCAtIChpZiB0aHJlZV9zdGF0ZSBmb3JlYWNoKGRhdCA9PiBjaCkgLT4gZm9yZWFjaChwYXJlbnRzKSBpZihwYXJlbnQuc2VsZWN0ZWQpIGNoaWxkLnNlbGVjdGVkID0gdHJ1ZTtcblx0XHRcdFx0XHRcdHJzbHQgPSB7XG5cdFx0XHRcdFx0XHRcdCdjbnQnIDogdF9jbnQsXG5cdFx0XHRcdFx0XHRcdCdtb2QnIDogbSxcblx0XHRcdFx0XHRcdFx0J3NlbCcgOiBzZWwsXG5cdFx0XHRcdFx0XHRcdCdwYXInIDogcGFyLFxuXHRcdFx0XHRcdFx0XHQnZHBjJyA6IGRwYyxcblx0XHRcdFx0XHRcdFx0J2FkZCcgOiBhZGRcblx0XHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdFx0Zm9yKGkgPSAwLCBqID0gZGF0Lmxlbmd0aDsgaSA8IGo7IGkrKykge1xuXHRcdFx0XHRcdFx0XHR0bXAgPSBwYXJzZV9uZXN0KGRhdFtpXSwgcGFyLCBwLnBhcmVudHMuY29uY2F0KCkpO1xuXHRcdFx0XHRcdFx0XHRpZih0bXApIHtcblx0XHRcdFx0XHRcdFx0XHRjaGQucHVzaCh0bXApO1xuXHRcdFx0XHRcdFx0XHRcdGRwYy5wdXNoKHRtcCk7XG5cdFx0XHRcdFx0XHRcdFx0aWYobVt0bXBdLmNoaWxkcmVuX2QubGVuZ3RoKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRkcGMgPSBkcGMuY29uY2F0KG1bdG1wXS5jaGlsZHJlbl9kKTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdHAuY2hpbGRyZW4gPSBjaGQ7XG5cdFx0XHRcdFx0XHRwLmNoaWxkcmVuX2QgPSBkcGM7XG5cdFx0XHRcdFx0XHRmb3IoaSA9IDAsIGogPSBwLnBhcmVudHMubGVuZ3RoOyBpIDwgajsgaSsrKSB7XG5cdFx0XHRcdFx0XHRcdG1bcC5wYXJlbnRzW2ldXS5jaGlsZHJlbl9kID0gbVtwLnBhcmVudHNbaV1dLmNoaWxkcmVuX2QuY29uY2F0KGRwYyk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRyc2x0ID0ge1xuXHRcdFx0XHRcdFx0XHQnY250JyA6IHRfY250LFxuXHRcdFx0XHRcdFx0XHQnbW9kJyA6IG0sXG5cdFx0XHRcdFx0XHRcdCdzZWwnIDogc2VsLFxuXHRcdFx0XHRcdFx0XHQncGFyJyA6IHBhcixcblx0XHRcdFx0XHRcdFx0J2RwYycgOiBkcGMsXG5cdFx0XHRcdFx0XHRcdCdhZGQnIDogYWRkXG5cdFx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZih0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJyB8fCB0eXBlb2Ygd2luZG93LmRvY3VtZW50ID09PSAndW5kZWZpbmVkJykge1xuXHRcdFx0XHRcdFx0cG9zdE1lc3NhZ2UocnNsdCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdFx0cmV0dXJuIHJzbHQ7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9LFxuXHRcdFx0XHRyc2x0ID0gZnVuY3Rpb24gKHJzbHQsIHdvcmtlcikge1xuXHRcdFx0XHRcdGlmKHRoaXMuZWxlbWVudCA9PT0gbnVsbCkgeyByZXR1cm47IH1cblx0XHRcdFx0XHR0aGlzLl9jbnQgPSByc2x0LmNudDtcblx0XHRcdFx0XHR2YXIgaSwgbSA9IHRoaXMuX21vZGVsLmRhdGE7XG5cdFx0XHRcdFx0Zm9yIChpIGluIG0pIHtcblx0XHRcdFx0XHRcdGlmIChtLmhhc093blByb3BlcnR5KGkpICYmIG1baV0uc3RhdGUgJiYgbVtpXS5zdGF0ZS5sb2FkaW5nICYmIHJzbHQubW9kW2ldKSB7XG5cdFx0XHRcdFx0XHRcdHJzbHQubW9kW2ldLnN0YXRlLmxvYWRpbmcgPSB0cnVlO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHR0aGlzLl9tb2RlbC5kYXRhID0gcnNsdC5tb2Q7IC8vIGJyZWFrcyB0aGUgcmVmZXJlbmNlIGluIGxvYWRfbm9kZSAtIGNhcmVmdWxcblxuXHRcdFx0XHRcdGlmKHdvcmtlcikge1xuXHRcdFx0XHRcdFx0dmFyIGosIGEgPSByc2x0LmFkZCwgciA9IHJzbHQuc2VsLCBzID0gdGhpcy5fZGF0YS5jb3JlLnNlbGVjdGVkLnNsaWNlKCk7XG5cdFx0XHRcdFx0XHRtID0gdGhpcy5fbW9kZWwuZGF0YTtcblx0XHRcdFx0XHRcdC8vIGlmIHNlbGVjdGlvbiB3YXMgY2hhbmdlZCB3aGlsZSBjYWxjdWxhdGluZyBpbiB3b3JrZXJcblx0XHRcdFx0XHRcdGlmKHIubGVuZ3RoICE9PSBzLmxlbmd0aCB8fCAkLnZha2F0YS5hcnJheV91bmlxdWUoci5jb25jYXQocykpLmxlbmd0aCAhPT0gci5sZW5ndGgpIHtcblx0XHRcdFx0XHRcdFx0Ly8gZGVzZWxlY3Qgbm9kZXMgdGhhdCBhcmUgbm8gbG9uZ2VyIHNlbGVjdGVkXG5cdFx0XHRcdFx0XHRcdGZvcihpID0gMCwgaiA9IHIubGVuZ3RoOyBpIDwgajsgaSsrKSB7XG5cdFx0XHRcdFx0XHRcdFx0aWYoJC5pbkFycmF5KHJbaV0sIGEpID09PSAtMSAmJiAkLmluQXJyYXkocltpXSwgcykgPT09IC0xKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRtW3JbaV1dLnN0YXRlLnNlbGVjdGVkID0gZmFsc2U7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdC8vIHNlbGVjdCBub2RlcyB0aGF0IHdlcmUgc2VsZWN0ZWQgaW4gdGhlIG1lYW4gdGltZVxuXHRcdFx0XHRcdFx0XHRmb3IoaSA9IDAsIGogPSBzLmxlbmd0aDsgaSA8IGo7IGkrKykge1xuXHRcdFx0XHRcdFx0XHRcdGlmKCQuaW5BcnJheShzW2ldLCByKSA9PT0gLTEpIHtcblx0XHRcdFx0XHRcdFx0XHRcdG1bc1tpXV0uc3RhdGUuc2VsZWN0ZWQgPSB0cnVlO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZihyc2x0LmFkZC5sZW5ndGgpIHtcblx0XHRcdFx0XHRcdHRoaXMuX2RhdGEuY29yZS5zZWxlY3RlZCA9IHRoaXMuX2RhdGEuY29yZS5zZWxlY3RlZC5jb25jYXQocnNsdC5hZGQpO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHRoaXMudHJpZ2dlcignbW9kZWwnLCB7IFwibm9kZXNcIiA6IHJzbHQuZHBjLCAncGFyZW50JyA6IHJzbHQucGFyIH0pO1xuXG5cdFx0XHRcdFx0aWYocnNsdC5wYXIgIT09ICQuanN0cmVlLnJvb3QpIHtcblx0XHRcdFx0XHRcdHRoaXMuX25vZGVfY2hhbmdlZChyc2x0LnBhcik7XG5cdFx0XHRcdFx0XHR0aGlzLnJlZHJhdygpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRcdC8vIHRoaXMuZ2V0X2NvbnRhaW5lcl91bCgpLmNoaWxkcmVuKCcuanN0cmVlLWluaXRpYWwtbm9kZScpLnJlbW92ZSgpO1xuXHRcdFx0XHRcdFx0dGhpcy5yZWRyYXcodHJ1ZSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmKHJzbHQuYWRkLmxlbmd0aCkge1xuXHRcdFx0XHRcdFx0dGhpcy50cmlnZ2VyKCdjaGFuZ2VkJywgeyAnYWN0aW9uJyA6ICdtb2RlbCcsICdzZWxlY3RlZCcgOiB0aGlzLl9kYXRhLmNvcmUuc2VsZWN0ZWQgfSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGNiLmNhbGwodGhpcywgdHJ1ZSk7XG5cdFx0XHRcdH07XG5cdFx0XHRpZih0aGlzLnNldHRpbmdzLmNvcmUud29ya2VyICYmIHdpbmRvdy5CbG9iICYmIHdpbmRvdy5VUkwgJiYgd2luZG93Lldvcmtlcikge1xuXHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdGlmKHRoaXMuX3dyayA9PT0gbnVsbCkge1xuXHRcdFx0XHRcdFx0dGhpcy5fd3JrID0gd2luZG93LlVSTC5jcmVhdGVPYmplY3RVUkwoXG5cdFx0XHRcdFx0XHRcdG5ldyB3aW5kb3cuQmxvYihcblx0XHRcdFx0XHRcdFx0XHRbJ3NlbGYub25tZXNzYWdlID0gJyArIGZ1bmMudG9TdHJpbmcoKV0sXG5cdFx0XHRcdFx0XHRcdFx0e3R5cGU6XCJ0ZXh0L2phdmFzY3JpcHRcIn1cblx0XHRcdFx0XHRcdFx0KVxuXHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYoIXRoaXMuX2RhdGEuY29yZS53b3JraW5nIHx8IGZvcmNlX3Byb2Nlc3NpbmcpIHtcblx0XHRcdFx0XHRcdHRoaXMuX2RhdGEuY29yZS53b3JraW5nID0gdHJ1ZTtcblx0XHRcdFx0XHRcdHcgPSBuZXcgd2luZG93Lldvcmtlcih0aGlzLl93cmspO1xuXHRcdFx0XHRcdFx0dy5vbm1lc3NhZ2UgPSAkLnByb3h5KGZ1bmN0aW9uIChlKSB7XG5cdFx0XHRcdFx0XHRcdHJzbHQuY2FsbCh0aGlzLCBlLmRhdGEsIHRydWUpO1xuXHRcdFx0XHRcdFx0XHR0cnkgeyB3LnRlcm1pbmF0ZSgpOyB3ID0gbnVsbDsgfSBjYXRjaChpZ25vcmUpIHsgfVxuXHRcdFx0XHRcdFx0XHRpZih0aGlzLl9kYXRhLmNvcmUud29ya2VyX3F1ZXVlLmxlbmd0aCkge1xuXHRcdFx0XHRcdFx0XHRcdHRoaXMuX2FwcGVuZF9qc29uX2RhdGEuYXBwbHkodGhpcywgdGhpcy5fZGF0YS5jb3JlLndvcmtlcl9xdWV1ZS5zaGlmdCgpKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHR0aGlzLl9kYXRhLmNvcmUud29ya2luZyA9IGZhbHNlO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9LCB0aGlzKTtcblx0XHRcdFx0XHRcdGlmKCFhcmdzLnBhcikge1xuXHRcdFx0XHRcdFx0XHRpZih0aGlzLl9kYXRhLmNvcmUud29ya2VyX3F1ZXVlLmxlbmd0aCkge1xuXHRcdFx0XHRcdFx0XHRcdHRoaXMuX2FwcGVuZF9qc29uX2RhdGEuYXBwbHkodGhpcywgdGhpcy5fZGF0YS5jb3JlLndvcmtlcl9xdWV1ZS5zaGlmdCgpKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHR0aGlzLl9kYXRhLmNvcmUud29ya2luZyA9IGZhbHNlO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRcdFx0dy5wb3N0TWVzc2FnZShhcmdzKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0XHR0aGlzLl9kYXRhLmNvcmUud29ya2VyX3F1ZXVlLnB1c2goW2RvbSwgZGF0YSwgY2IsIHRydWVdKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0Y2F0Y2goZSkge1xuXHRcdFx0XHRcdHJzbHQuY2FsbCh0aGlzLCBmdW5jKGFyZ3MpLCBmYWxzZSk7XG5cdFx0XHRcdFx0aWYodGhpcy5fZGF0YS5jb3JlLndvcmtlcl9xdWV1ZS5sZW5ndGgpIHtcblx0XHRcdFx0XHRcdHRoaXMuX2FwcGVuZF9qc29uX2RhdGEuYXBwbHkodGhpcywgdGhpcy5fZGF0YS5jb3JlLndvcmtlcl9xdWV1ZS5zaGlmdCgpKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0XHR0aGlzLl9kYXRhLmNvcmUud29ya2luZyA9IGZhbHNlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0ZWxzZSB7XG5cdFx0XHRcdHJzbHQuY2FsbCh0aGlzLCBmdW5jKGFyZ3MpLCBmYWxzZSk7XG5cdFx0XHR9XG5cdFx0fSxcblx0XHQvKipcblx0XHQgKiBwYXJzZXMgYSBub2RlIGZyb20gYSBqUXVlcnkgb2JqZWN0IGFuZCBhcHBlbmRzIHRoZW0gdG8gdGhlIGluIG1lbW9yeSB0cmVlIG1vZGVsLiBVc2VkIGludGVybmFsbHkuXG5cdFx0ICogQHByaXZhdGVcblx0XHQgKiBAbmFtZSBfcGFyc2VfbW9kZWxfZnJvbV9odG1sKGQgWywgcCwgcHNdKVxuXHRcdCAqIEBwYXJhbSAge2pRdWVyeX0gZCB0aGUgalF1ZXJ5IG9iamVjdCB0byBwYXJzZVxuXHRcdCAqIEBwYXJhbSAge1N0cmluZ30gcCB0aGUgcGFyZW50IElEXG5cdFx0ICogQHBhcmFtICB7QXJyYXl9IHBzIGxpc3Qgb2YgYWxsIHBhcmVudHNcblx0XHQgKiBAcmV0dXJuIHtTdHJpbmd9IHRoZSBJRCBvZiB0aGUgb2JqZWN0IGFkZGVkIHRvIHRoZSBtb2RlbFxuXHRcdCAqL1xuXHRcdF9wYXJzZV9tb2RlbF9mcm9tX2h0bWwgOiBmdW5jdGlvbiAoZCwgcCwgcHMpIHtcblx0XHRcdGlmKCFwcykgeyBwcyA9IFtdOyB9XG5cdFx0XHRlbHNlIHsgcHMgPSBbXS5jb25jYXQocHMpOyB9XG5cdFx0XHRpZihwKSB7IHBzLnVuc2hpZnQocCk7IH1cblx0XHRcdHZhciBjLCBlLCBtID0gdGhpcy5fbW9kZWwuZGF0YSxcblx0XHRcdFx0ZGF0YSA9IHtcblx0XHRcdFx0XHRpZFx0XHRcdDogZmFsc2UsXG5cdFx0XHRcdFx0dGV4dFx0XHQ6IGZhbHNlLFxuXHRcdFx0XHRcdGljb25cdFx0OiB0cnVlLFxuXHRcdFx0XHRcdHBhcmVudFx0XHQ6IHAsXG5cdFx0XHRcdFx0cGFyZW50c1x0XHQ6IHBzLFxuXHRcdFx0XHRcdGNoaWxkcmVuXHQ6IFtdLFxuXHRcdFx0XHRcdGNoaWxkcmVuX2RcdDogW10sXG5cdFx0XHRcdFx0ZGF0YVx0XHQ6IG51bGwsXG5cdFx0XHRcdFx0c3RhdGVcdFx0OiB7IH0sXG5cdFx0XHRcdFx0bGlfYXR0clx0XHQ6IHsgaWQgOiBmYWxzZSB9LFxuXHRcdFx0XHRcdGFfYXR0clx0XHQ6IHsgaHJlZiA6ICcjJyB9LFxuXHRcdFx0XHRcdG9yaWdpbmFsXHQ6IGZhbHNlXG5cdFx0XHRcdH0sIGksIHRtcCwgdGlkO1xuXHRcdFx0Zm9yKGkgaW4gdGhpcy5fbW9kZWwuZGVmYXVsdF9zdGF0ZSkge1xuXHRcdFx0XHRpZih0aGlzLl9tb2RlbC5kZWZhdWx0X3N0YXRlLmhhc093blByb3BlcnR5KGkpKSB7XG5cdFx0XHRcdFx0ZGF0YS5zdGF0ZVtpXSA9IHRoaXMuX21vZGVsLmRlZmF1bHRfc3RhdGVbaV07XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHRtcCA9ICQudmFrYXRhLmF0dHJpYnV0ZXMoZCwgdHJ1ZSk7XG5cdFx0XHQkLmVhY2godG1wLCBmdW5jdGlvbiAoaSwgdikge1xuXHRcdFx0XHR2ID0gJC50cmltKHYpO1xuXHRcdFx0XHRpZighdi5sZW5ndGgpIHsgcmV0dXJuIHRydWU7IH1cblx0XHRcdFx0ZGF0YS5saV9hdHRyW2ldID0gdjtcblx0XHRcdFx0aWYoaSA9PT0gJ2lkJykge1xuXHRcdFx0XHRcdGRhdGEuaWQgPSB2LnRvU3RyaW5nKCk7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdFx0dG1wID0gZC5jaGlsZHJlbignYScpLmZpcnN0KCk7XG5cdFx0XHRpZih0bXAubGVuZ3RoKSB7XG5cdFx0XHRcdHRtcCA9ICQudmFrYXRhLmF0dHJpYnV0ZXModG1wLCB0cnVlKTtcblx0XHRcdFx0JC5lYWNoKHRtcCwgZnVuY3Rpb24gKGksIHYpIHtcblx0XHRcdFx0XHR2ID0gJC50cmltKHYpO1xuXHRcdFx0XHRcdGlmKHYubGVuZ3RoKSB7XG5cdFx0XHRcdFx0XHRkYXRhLmFfYXR0cltpXSA9IHY7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KTtcblx0XHRcdH1cblx0XHRcdHRtcCA9IGQuY2hpbGRyZW4oXCJhXCIpLmZpcnN0KCkubGVuZ3RoID8gZC5jaGlsZHJlbihcImFcIikuZmlyc3QoKS5jbG9uZSgpIDogZC5jbG9uZSgpO1xuXHRcdFx0dG1wLmNoaWxkcmVuKFwiaW5zLCBpLCB1bFwiKS5yZW1vdmUoKTtcblx0XHRcdHRtcCA9IHRtcC5odG1sKCk7XG5cdFx0XHR0bXAgPSAkKCc8ZGl2IC8+JykuaHRtbCh0bXApO1xuXHRcdFx0ZGF0YS50ZXh0ID0gdGhpcy5zZXR0aW5ncy5jb3JlLmZvcmNlX3RleHQgPyB0bXAudGV4dCgpIDogdG1wLmh0bWwoKTtcblx0XHRcdHRtcCA9IGQuZGF0YSgpO1xuXHRcdFx0ZGF0YS5kYXRhID0gdG1wID8gJC5leHRlbmQodHJ1ZSwge30sIHRtcCkgOiBudWxsO1xuXHRcdFx0ZGF0YS5zdGF0ZS5vcGVuZWQgPSBkLmhhc0NsYXNzKCdqc3RyZWUtb3BlbicpO1xuXHRcdFx0ZGF0YS5zdGF0ZS5zZWxlY3RlZCA9IGQuY2hpbGRyZW4oJ2EnKS5oYXNDbGFzcygnanN0cmVlLWNsaWNrZWQnKTtcblx0XHRcdGRhdGEuc3RhdGUuZGlzYWJsZWQgPSBkLmNoaWxkcmVuKCdhJykuaGFzQ2xhc3MoJ2pzdHJlZS1kaXNhYmxlZCcpO1xuXHRcdFx0aWYoZGF0YS5kYXRhICYmIGRhdGEuZGF0YS5qc3RyZWUpIHtcblx0XHRcdFx0Zm9yKGkgaW4gZGF0YS5kYXRhLmpzdHJlZSkge1xuXHRcdFx0XHRcdGlmKGRhdGEuZGF0YS5qc3RyZWUuaGFzT3duUHJvcGVydHkoaSkpIHtcblx0XHRcdFx0XHRcdGRhdGEuc3RhdGVbaV0gPSBkYXRhLmRhdGEuanN0cmVlW2ldO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0dG1wID0gZC5jaGlsZHJlbihcImFcIikuY2hpbGRyZW4oXCIuanN0cmVlLXRoZW1laWNvblwiKTtcblx0XHRcdGlmKHRtcC5sZW5ndGgpIHtcblx0XHRcdFx0ZGF0YS5pY29uID0gdG1wLmhhc0NsYXNzKCdqc3RyZWUtdGhlbWVpY29uLWhpZGRlbicpID8gZmFsc2UgOiB0bXAuYXR0cigncmVsJyk7XG5cdFx0XHR9XG5cdFx0XHRpZihkYXRhLnN0YXRlLmljb24gIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRkYXRhLmljb24gPSBkYXRhLnN0YXRlLmljb247XG5cdFx0XHR9XG5cdFx0XHRpZihkYXRhLmljb24gPT09IHVuZGVmaW5lZCB8fCBkYXRhLmljb24gPT09IG51bGwgfHwgZGF0YS5pY29uID09PSBcIlwiKSB7XG5cdFx0XHRcdGRhdGEuaWNvbiA9IHRydWU7XG5cdFx0XHR9XG5cdFx0XHR0bXAgPSBkLmNoaWxkcmVuKFwidWxcIikuY2hpbGRyZW4oXCJsaVwiKTtcblx0XHRcdGRvIHtcblx0XHRcdFx0dGlkID0gJ2onICsgdGhpcy5faWQgKyAnXycgKyAoKyt0aGlzLl9jbnQpO1xuXHRcdFx0fSB3aGlsZShtW3RpZF0pO1xuXHRcdFx0ZGF0YS5pZCA9IGRhdGEubGlfYXR0ci5pZCA/IGRhdGEubGlfYXR0ci5pZC50b1N0cmluZygpIDogdGlkO1xuXHRcdFx0aWYodG1wLmxlbmd0aCkge1xuXHRcdFx0XHR0bXAuZWFjaCgkLnByb3h5KGZ1bmN0aW9uIChpLCB2KSB7XG5cdFx0XHRcdFx0YyA9IHRoaXMuX3BhcnNlX21vZGVsX2Zyb21faHRtbCgkKHYpLCBkYXRhLmlkLCBwcyk7XG5cdFx0XHRcdFx0ZSA9IHRoaXMuX21vZGVsLmRhdGFbY107XG5cdFx0XHRcdFx0ZGF0YS5jaGlsZHJlbi5wdXNoKGMpO1xuXHRcdFx0XHRcdGlmKGUuY2hpbGRyZW5fZC5sZW5ndGgpIHtcblx0XHRcdFx0XHRcdGRhdGEuY2hpbGRyZW5fZCA9IGRhdGEuY2hpbGRyZW5fZC5jb25jYXQoZS5jaGlsZHJlbl9kKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0sIHRoaXMpKTtcblx0XHRcdFx0ZGF0YS5jaGlsZHJlbl9kID0gZGF0YS5jaGlsZHJlbl9kLmNvbmNhdChkYXRhLmNoaWxkcmVuKTtcblx0XHRcdH1cblx0XHRcdGVsc2Uge1xuXHRcdFx0XHRpZihkLmhhc0NsYXNzKCdqc3RyZWUtY2xvc2VkJykpIHtcblx0XHRcdFx0XHRkYXRhLnN0YXRlLmxvYWRlZCA9IGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRpZihkYXRhLmxpX2F0dHJbJ2NsYXNzJ10pIHtcblx0XHRcdFx0ZGF0YS5saV9hdHRyWydjbGFzcyddID0gZGF0YS5saV9hdHRyWydjbGFzcyddLnJlcGxhY2UoJ2pzdHJlZS1jbG9zZWQnLCcnKS5yZXBsYWNlKCdqc3RyZWUtb3BlbicsJycpO1xuXHRcdFx0fVxuXHRcdFx0aWYoZGF0YS5hX2F0dHJbJ2NsYXNzJ10pIHtcblx0XHRcdFx0ZGF0YS5hX2F0dHJbJ2NsYXNzJ10gPSBkYXRhLmFfYXR0clsnY2xhc3MnXS5yZXBsYWNlKCdqc3RyZWUtY2xpY2tlZCcsJycpLnJlcGxhY2UoJ2pzdHJlZS1kaXNhYmxlZCcsJycpO1xuXHRcdFx0fVxuXHRcdFx0bVtkYXRhLmlkXSA9IGRhdGE7XG5cdFx0XHRpZihkYXRhLnN0YXRlLnNlbGVjdGVkKSB7XG5cdFx0XHRcdHRoaXMuX2RhdGEuY29yZS5zZWxlY3RlZC5wdXNoKGRhdGEuaWQpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGRhdGEuaWQ7XG5cdFx0fSxcblx0XHQvKipcblx0XHQgKiBwYXJzZXMgYSBub2RlIGZyb20gYSBKU09OIG9iamVjdCAodXNlZCB3aGVuIGRlYWxpbmcgd2l0aCBmbGF0IGRhdGEsIHdoaWNoIGhhcyBubyBuZXN0aW5nIG9mIGNoaWxkcmVuLCBidXQgaGFzIGlkIGFuZCBwYXJlbnQgcHJvcGVydGllcykgYW5kIGFwcGVuZHMgaXQgdG8gdGhlIGluIG1lbW9yeSB0cmVlIG1vZGVsLiBVc2VkIGludGVybmFsbHkuXG5cdFx0ICogQHByaXZhdGVcblx0XHQgKiBAbmFtZSBfcGFyc2VfbW9kZWxfZnJvbV9mbGF0X2pzb24oZCBbLCBwLCBwc10pXG5cdFx0ICogQHBhcmFtICB7T2JqZWN0fSBkIHRoZSBKU09OIG9iamVjdCB0byBwYXJzZVxuXHRcdCAqIEBwYXJhbSAge1N0cmluZ30gcCB0aGUgcGFyZW50IElEXG5cdFx0ICogQHBhcmFtICB7QXJyYXl9IHBzIGxpc3Qgb2YgYWxsIHBhcmVudHNcblx0XHQgKiBAcmV0dXJuIHtTdHJpbmd9IHRoZSBJRCBvZiB0aGUgb2JqZWN0IGFkZGVkIHRvIHRoZSBtb2RlbFxuXHRcdCAqL1xuXHRcdF9wYXJzZV9tb2RlbF9mcm9tX2ZsYXRfanNvbiA6IGZ1bmN0aW9uIChkLCBwLCBwcykge1xuXHRcdFx0aWYoIXBzKSB7IHBzID0gW107IH1cblx0XHRcdGVsc2UgeyBwcyA9IHBzLmNvbmNhdCgpOyB9XG5cdFx0XHRpZihwKSB7IHBzLnVuc2hpZnQocCk7IH1cblx0XHRcdHZhciB0aWQgPSBkLmlkLnRvU3RyaW5nKCksXG5cdFx0XHRcdG0gPSB0aGlzLl9tb2RlbC5kYXRhLFxuXHRcdFx0XHRkZiA9IHRoaXMuX21vZGVsLmRlZmF1bHRfc3RhdGUsXG5cdFx0XHRcdGksIGosIGMsIGUsXG5cdFx0XHRcdHRtcCA9IHtcblx0XHRcdFx0XHRpZFx0XHRcdDogdGlkLFxuXHRcdFx0XHRcdHRleHRcdFx0OiBkLnRleHQgfHwgJycsXG5cdFx0XHRcdFx0aWNvblx0XHQ6IGQuaWNvbiAhPT0gdW5kZWZpbmVkID8gZC5pY29uIDogdHJ1ZSxcblx0XHRcdFx0XHRwYXJlbnRcdFx0OiBwLFxuXHRcdFx0XHRcdHBhcmVudHNcdFx0OiBwcyxcblx0XHRcdFx0XHRjaGlsZHJlblx0OiBkLmNoaWxkcmVuIHx8IFtdLFxuXHRcdFx0XHRcdGNoaWxkcmVuX2RcdDogZC5jaGlsZHJlbl9kIHx8IFtdLFxuXHRcdFx0XHRcdGRhdGFcdFx0OiBkLmRhdGEsXG5cdFx0XHRcdFx0c3RhdGVcdFx0OiB7IH0sXG5cdFx0XHRcdFx0bGlfYXR0clx0XHQ6IHsgaWQgOiBmYWxzZSB9LFxuXHRcdFx0XHRcdGFfYXR0clx0XHQ6IHsgaHJlZiA6ICcjJyB9LFxuXHRcdFx0XHRcdG9yaWdpbmFsXHQ6IGZhbHNlXG5cdFx0XHRcdH07XG5cdFx0XHRmb3IoaSBpbiBkZikge1xuXHRcdFx0XHRpZihkZi5oYXNPd25Qcm9wZXJ0eShpKSkge1xuXHRcdFx0XHRcdHRtcC5zdGF0ZVtpXSA9IGRmW2ldO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRpZihkICYmIGQuZGF0YSAmJiBkLmRhdGEuanN0cmVlICYmIGQuZGF0YS5qc3RyZWUuaWNvbikge1xuXHRcdFx0XHR0bXAuaWNvbiA9IGQuZGF0YS5qc3RyZWUuaWNvbjtcblx0XHRcdH1cblx0XHRcdGlmKHRtcC5pY29uID09PSB1bmRlZmluZWQgfHwgdG1wLmljb24gPT09IG51bGwgfHwgdG1wLmljb24gPT09IFwiXCIpIHtcblx0XHRcdFx0dG1wLmljb24gPSB0cnVlO1xuXHRcdFx0fVxuXHRcdFx0aWYoZCAmJiBkLmRhdGEpIHtcblx0XHRcdFx0dG1wLmRhdGEgPSBkLmRhdGE7XG5cdFx0XHRcdGlmKGQuZGF0YS5qc3RyZWUpIHtcblx0XHRcdFx0XHRmb3IoaSBpbiBkLmRhdGEuanN0cmVlKSB7XG5cdFx0XHRcdFx0XHRpZihkLmRhdGEuanN0cmVlLmhhc093blByb3BlcnR5KGkpKSB7XG5cdFx0XHRcdFx0XHRcdHRtcC5zdGF0ZVtpXSA9IGQuZGF0YS5qc3RyZWVbaV07XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRpZihkICYmIHR5cGVvZiBkLnN0YXRlID09PSAnb2JqZWN0Jykge1xuXHRcdFx0XHRmb3IgKGkgaW4gZC5zdGF0ZSkge1xuXHRcdFx0XHRcdGlmKGQuc3RhdGUuaGFzT3duUHJvcGVydHkoaSkpIHtcblx0XHRcdFx0XHRcdHRtcC5zdGF0ZVtpXSA9IGQuc3RhdGVbaV07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRpZihkICYmIHR5cGVvZiBkLmxpX2F0dHIgPT09ICdvYmplY3QnKSB7XG5cdFx0XHRcdGZvciAoaSBpbiBkLmxpX2F0dHIpIHtcblx0XHRcdFx0XHRpZihkLmxpX2F0dHIuaGFzT3duUHJvcGVydHkoaSkpIHtcblx0XHRcdFx0XHRcdHRtcC5saV9hdHRyW2ldID0gZC5saV9hdHRyW2ldO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0aWYoIXRtcC5saV9hdHRyLmlkKSB7XG5cdFx0XHRcdHRtcC5saV9hdHRyLmlkID0gdGlkO1xuXHRcdFx0fVxuXHRcdFx0aWYoZCAmJiB0eXBlb2YgZC5hX2F0dHIgPT09ICdvYmplY3QnKSB7XG5cdFx0XHRcdGZvciAoaSBpbiBkLmFfYXR0cikge1xuXHRcdFx0XHRcdGlmKGQuYV9hdHRyLmhhc093blByb3BlcnR5KGkpKSB7XG5cdFx0XHRcdFx0XHR0bXAuYV9hdHRyW2ldID0gZC5hX2F0dHJbaV07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRpZihkICYmIGQuY2hpbGRyZW4gJiYgZC5jaGlsZHJlbiA9PT0gdHJ1ZSkge1xuXHRcdFx0XHR0bXAuc3RhdGUubG9hZGVkID0gZmFsc2U7XG5cdFx0XHRcdHRtcC5jaGlsZHJlbiA9IFtdO1xuXHRcdFx0XHR0bXAuY2hpbGRyZW5fZCA9IFtdO1xuXHRcdFx0fVxuXHRcdFx0bVt0bXAuaWRdID0gdG1wO1xuXHRcdFx0Zm9yKGkgPSAwLCBqID0gdG1wLmNoaWxkcmVuLmxlbmd0aDsgaSA8IGo7IGkrKykge1xuXHRcdFx0XHRjID0gdGhpcy5fcGFyc2VfbW9kZWxfZnJvbV9mbGF0X2pzb24obVt0bXAuY2hpbGRyZW5baV1dLCB0bXAuaWQsIHBzKTtcblx0XHRcdFx0ZSA9IG1bY107XG5cdFx0XHRcdHRtcC5jaGlsZHJlbl9kLnB1c2goYyk7XG5cdFx0XHRcdGlmKGUuY2hpbGRyZW5fZC5sZW5ndGgpIHtcblx0XHRcdFx0XHR0bXAuY2hpbGRyZW5fZCA9IHRtcC5jaGlsZHJlbl9kLmNvbmNhdChlLmNoaWxkcmVuX2QpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRkZWxldGUgZC5kYXRhO1xuXHRcdFx0ZGVsZXRlIGQuY2hpbGRyZW47XG5cdFx0XHRtW3RtcC5pZF0ub3JpZ2luYWwgPSBkO1xuXHRcdFx0aWYodG1wLnN0YXRlLnNlbGVjdGVkKSB7XG5cdFx0XHRcdHRoaXMuX2RhdGEuY29yZS5zZWxlY3RlZC5wdXNoKHRtcC5pZCk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdG1wLmlkO1xuXHRcdH0sXG5cdFx0LyoqXG5cdFx0ICogcGFyc2VzIGEgbm9kZSBmcm9tIGEgSlNPTiBvYmplY3QgYW5kIGFwcGVuZHMgaXQgdG8gdGhlIGluIG1lbW9yeSB0cmVlIG1vZGVsLiBVc2VkIGludGVybmFsbHkuXG5cdFx0ICogQHByaXZhdGVcblx0XHQgKiBAbmFtZSBfcGFyc2VfbW9kZWxfZnJvbV9qc29uKGQgWywgcCwgcHNdKVxuXHRcdCAqIEBwYXJhbSAge09iamVjdH0gZCB0aGUgSlNPTiBvYmplY3QgdG8gcGFyc2Vcblx0XHQgKiBAcGFyYW0gIHtTdHJpbmd9IHAgdGhlIHBhcmVudCBJRFxuXHRcdCAqIEBwYXJhbSAge0FycmF5fSBwcyBsaXN0IG9mIGFsbCBwYXJlbnRzXG5cdFx0ICogQHJldHVybiB7U3RyaW5nfSB0aGUgSUQgb2YgdGhlIG9iamVjdCBhZGRlZCB0byB0aGUgbW9kZWxcblx0XHQgKi9cblx0XHRfcGFyc2VfbW9kZWxfZnJvbV9qc29uIDogZnVuY3Rpb24gKGQsIHAsIHBzKSB7XG5cdFx0XHRpZighcHMpIHsgcHMgPSBbXTsgfVxuXHRcdFx0ZWxzZSB7IHBzID0gcHMuY29uY2F0KCk7IH1cblx0XHRcdGlmKHApIHsgcHMudW5zaGlmdChwKTsgfVxuXHRcdFx0dmFyIHRpZCA9IGZhbHNlLCBpLCBqLCBjLCBlLCBtID0gdGhpcy5fbW9kZWwuZGF0YSwgZGYgPSB0aGlzLl9tb2RlbC5kZWZhdWx0X3N0YXRlLCB0bXA7XG5cdFx0XHRkbyB7XG5cdFx0XHRcdHRpZCA9ICdqJyArIHRoaXMuX2lkICsgJ18nICsgKCsrdGhpcy5fY250KTtcblx0XHRcdH0gd2hpbGUobVt0aWRdKTtcblxuXHRcdFx0dG1wID0ge1xuXHRcdFx0XHRpZFx0XHRcdDogZmFsc2UsXG5cdFx0XHRcdHRleHRcdFx0OiB0eXBlb2YgZCA9PT0gJ3N0cmluZycgPyBkIDogJycsXG5cdFx0XHRcdGljb25cdFx0OiB0eXBlb2YgZCA9PT0gJ29iamVjdCcgJiYgZC5pY29uICE9PSB1bmRlZmluZWQgPyBkLmljb24gOiB0cnVlLFxuXHRcdFx0XHRwYXJlbnRcdFx0OiBwLFxuXHRcdFx0XHRwYXJlbnRzXHRcdDogcHMsXG5cdFx0XHRcdGNoaWxkcmVuXHQ6IFtdLFxuXHRcdFx0XHRjaGlsZHJlbl9kXHQ6IFtdLFxuXHRcdFx0XHRkYXRhXHRcdDogbnVsbCxcblx0XHRcdFx0c3RhdGVcdFx0OiB7IH0sXG5cdFx0XHRcdGxpX2F0dHJcdFx0OiB7IGlkIDogZmFsc2UgfSxcblx0XHRcdFx0YV9hdHRyXHRcdDogeyBocmVmIDogJyMnIH0sXG5cdFx0XHRcdG9yaWdpbmFsXHQ6IGZhbHNlXG5cdFx0XHR9O1xuXHRcdFx0Zm9yKGkgaW4gZGYpIHtcblx0XHRcdFx0aWYoZGYuaGFzT3duUHJvcGVydHkoaSkpIHtcblx0XHRcdFx0XHR0bXAuc3RhdGVbaV0gPSBkZltpXTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0aWYoZCAmJiBkLmlkKSB7IHRtcC5pZCA9IGQuaWQudG9TdHJpbmcoKTsgfVxuXHRcdFx0aWYoZCAmJiBkLnRleHQpIHsgdG1wLnRleHQgPSBkLnRleHQ7IH1cblx0XHRcdGlmKGQgJiYgZC5kYXRhICYmIGQuZGF0YS5qc3RyZWUgJiYgZC5kYXRhLmpzdHJlZS5pY29uKSB7XG5cdFx0XHRcdHRtcC5pY29uID0gZC5kYXRhLmpzdHJlZS5pY29uO1xuXHRcdFx0fVxuXHRcdFx0aWYodG1wLmljb24gPT09IHVuZGVmaW5lZCB8fCB0bXAuaWNvbiA9PT0gbnVsbCB8fCB0bXAuaWNvbiA9PT0gXCJcIikge1xuXHRcdFx0XHR0bXAuaWNvbiA9IHRydWU7XG5cdFx0XHR9XG5cdFx0XHRpZihkICYmIGQuZGF0YSkge1xuXHRcdFx0XHR0bXAuZGF0YSA9IGQuZGF0YTtcblx0XHRcdFx0aWYoZC5kYXRhLmpzdHJlZSkge1xuXHRcdFx0XHRcdGZvcihpIGluIGQuZGF0YS5qc3RyZWUpIHtcblx0XHRcdFx0XHRcdGlmKGQuZGF0YS5qc3RyZWUuaGFzT3duUHJvcGVydHkoaSkpIHtcblx0XHRcdFx0XHRcdFx0dG1wLnN0YXRlW2ldID0gZC5kYXRhLmpzdHJlZVtpXTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGlmKGQgJiYgdHlwZW9mIGQuc3RhdGUgPT09ICdvYmplY3QnKSB7XG5cdFx0XHRcdGZvciAoaSBpbiBkLnN0YXRlKSB7XG5cdFx0XHRcdFx0aWYoZC5zdGF0ZS5oYXNPd25Qcm9wZXJ0eShpKSkge1xuXHRcdFx0XHRcdFx0dG1wLnN0YXRlW2ldID0gZC5zdGF0ZVtpXTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGlmKGQgJiYgdHlwZW9mIGQubGlfYXR0ciA9PT0gJ29iamVjdCcpIHtcblx0XHRcdFx0Zm9yIChpIGluIGQubGlfYXR0cikge1xuXHRcdFx0XHRcdGlmKGQubGlfYXR0ci5oYXNPd25Qcm9wZXJ0eShpKSkge1xuXHRcdFx0XHRcdFx0dG1wLmxpX2F0dHJbaV0gPSBkLmxpX2F0dHJbaV07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRpZih0bXAubGlfYXR0ci5pZCAmJiAhdG1wLmlkKSB7XG5cdFx0XHRcdHRtcC5pZCA9IHRtcC5saV9hdHRyLmlkLnRvU3RyaW5nKCk7XG5cdFx0XHR9XG5cdFx0XHRpZighdG1wLmlkKSB7XG5cdFx0XHRcdHRtcC5pZCA9IHRpZDtcblx0XHRcdH1cblx0XHRcdGlmKCF0bXAubGlfYXR0ci5pZCkge1xuXHRcdFx0XHR0bXAubGlfYXR0ci5pZCA9IHRtcC5pZDtcblx0XHRcdH1cblx0XHRcdGlmKGQgJiYgdHlwZW9mIGQuYV9hdHRyID09PSAnb2JqZWN0Jykge1xuXHRcdFx0XHRmb3IgKGkgaW4gZC5hX2F0dHIpIHtcblx0XHRcdFx0XHRpZihkLmFfYXR0ci5oYXNPd25Qcm9wZXJ0eShpKSkge1xuXHRcdFx0XHRcdFx0dG1wLmFfYXR0cltpXSA9IGQuYV9hdHRyW2ldO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0aWYoZCAmJiBkLmNoaWxkcmVuICYmIGQuY2hpbGRyZW4ubGVuZ3RoKSB7XG5cdFx0XHRcdGZvcihpID0gMCwgaiA9IGQuY2hpbGRyZW4ubGVuZ3RoOyBpIDwgajsgaSsrKSB7XG5cdFx0XHRcdFx0YyA9IHRoaXMuX3BhcnNlX21vZGVsX2Zyb21fanNvbihkLmNoaWxkcmVuW2ldLCB0bXAuaWQsIHBzKTtcblx0XHRcdFx0XHRlID0gbVtjXTtcblx0XHRcdFx0XHR0bXAuY2hpbGRyZW4ucHVzaChjKTtcblx0XHRcdFx0XHRpZihlLmNoaWxkcmVuX2QubGVuZ3RoKSB7XG5cdFx0XHRcdFx0XHR0bXAuY2hpbGRyZW5fZCA9IHRtcC5jaGlsZHJlbl9kLmNvbmNhdChlLmNoaWxkcmVuX2QpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHR0bXAuY2hpbGRyZW5fZCA9IHRtcC5jaGlsZHJlbl9kLmNvbmNhdCh0bXAuY2hpbGRyZW4pO1xuXHRcdFx0fVxuXHRcdFx0aWYoZCAmJiBkLmNoaWxkcmVuICYmIGQuY2hpbGRyZW4gPT09IHRydWUpIHtcblx0XHRcdFx0dG1wLnN0YXRlLmxvYWRlZCA9IGZhbHNlO1xuXHRcdFx0XHR0bXAuY2hpbGRyZW4gPSBbXTtcblx0XHRcdFx0dG1wLmNoaWxkcmVuX2QgPSBbXTtcblx0XHRcdH1cblx0XHRcdGRlbGV0ZSBkLmRhdGE7XG5cdFx0XHRkZWxldGUgZC5jaGlsZHJlbjtcblx0XHRcdHRtcC5vcmlnaW5hbCA9IGQ7XG5cdFx0XHRtW3RtcC5pZF0gPSB0bXA7XG5cdFx0XHRpZih0bXAuc3RhdGUuc2VsZWN0ZWQpIHtcblx0XHRcdFx0dGhpcy5fZGF0YS5jb3JlLnNlbGVjdGVkLnB1c2godG1wLmlkKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiB0bXAuaWQ7XG5cdFx0fSxcblx0XHQvKipcblx0XHQgKiByZWRyYXdzIGFsbCBub2RlcyB0aGF0IG5lZWQgdG8gYmUgcmVkcmF3bi4gVXNlZCBpbnRlcm5hbGx5LlxuXHRcdCAqIEBwcml2YXRlXG5cdFx0ICogQG5hbWUgX3JlZHJhdygpXG5cdFx0ICogQHRyaWdnZXIgcmVkcmF3LmpzdHJlZVxuXHRcdCAqL1xuXHRcdF9yZWRyYXcgOiBmdW5jdGlvbiAoKSB7XG5cdFx0XHR2YXIgbm9kZXMgPSB0aGlzLl9tb2RlbC5mb3JjZV9mdWxsX3JlZHJhdyA/IHRoaXMuX21vZGVsLmRhdGFbJC5qc3RyZWUucm9vdF0uY2hpbGRyZW4uY29uY2F0KFtdKSA6IHRoaXMuX21vZGVsLmNoYW5nZWQuY29uY2F0KFtdKSxcblx0XHRcdFx0ZiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ1VMJyksIHRtcCwgaSwgaiwgZmUgPSB0aGlzLl9kYXRhLmNvcmUuZm9jdXNlZDtcblx0XHRcdGZvcihpID0gMCwgaiA9IG5vZGVzLmxlbmd0aDsgaSA8IGo7IGkrKykge1xuXHRcdFx0XHR0bXAgPSB0aGlzLnJlZHJhd19ub2RlKG5vZGVzW2ldLCB0cnVlLCB0aGlzLl9tb2RlbC5mb3JjZV9mdWxsX3JlZHJhdyk7XG5cdFx0XHRcdGlmKHRtcCAmJiB0aGlzLl9tb2RlbC5mb3JjZV9mdWxsX3JlZHJhdykge1xuXHRcdFx0XHRcdGYuYXBwZW5kQ2hpbGQodG1wKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0aWYodGhpcy5fbW9kZWwuZm9yY2VfZnVsbF9yZWRyYXcpIHtcblx0XHRcdFx0Zi5jbGFzc05hbWUgPSB0aGlzLmdldF9jb250YWluZXJfdWwoKVswXS5jbGFzc05hbWU7XG5cdFx0XHRcdGYuc2V0QXR0cmlidXRlKCdyb2xlJywnZ3JvdXAnKTtcblx0XHRcdFx0dGhpcy5lbGVtZW50LmVtcHR5KCkuYXBwZW5kKGYpO1xuXHRcdFx0XHQvL3RoaXMuZ2V0X2NvbnRhaW5lcl91bCgpWzBdLmFwcGVuZENoaWxkKGYpO1xuXHRcdFx0fVxuXHRcdFx0aWYoZmUgIT09IG51bGwpIHtcblx0XHRcdFx0dG1wID0gdGhpcy5nZXRfbm9kZShmZSwgdHJ1ZSk7XG5cdFx0XHRcdGlmKHRtcCAmJiB0bXAubGVuZ3RoICYmIHRtcC5jaGlsZHJlbignLmpzdHJlZS1hbmNob3InKVswXSAhPT0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudCkge1xuXHRcdFx0XHRcdHRtcC5jaGlsZHJlbignLmpzdHJlZS1hbmNob3InKS5mb2N1cygpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdHRoaXMuX2RhdGEuY29yZS5mb2N1c2VkID0gbnVsbDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0dGhpcy5fbW9kZWwuZm9yY2VfZnVsbF9yZWRyYXcgPSBmYWxzZTtcblx0XHRcdHRoaXMuX21vZGVsLmNoYW5nZWQgPSBbXTtcblx0XHRcdC8qKlxuXHRcdFx0ICogdHJpZ2dlcmVkIGFmdGVyIG5vZGVzIGFyZSByZWRyYXduXG5cdFx0XHQgKiBAZXZlbnRcblx0XHRcdCAqIEBuYW1lIHJlZHJhdy5qc3RyZWVcblx0XHRcdCAqIEBwYXJhbSB7YXJyYXl9IG5vZGVzIHRoZSByZWRyYXduIG5vZGVzXG5cdFx0XHQgKi9cblx0XHRcdHRoaXMudHJpZ2dlcigncmVkcmF3JywgeyBcIm5vZGVzXCIgOiBub2RlcyB9KTtcblx0XHR9LFxuXHRcdC8qKlxuXHRcdCAqIHJlZHJhd3MgYWxsIG5vZGVzIHRoYXQgbmVlZCB0byBiZSByZWRyYXduIG9yIG9wdGlvbmFsbHkgLSB0aGUgd2hvbGUgdHJlZVxuXHRcdCAqIEBuYW1lIHJlZHJhdyhbZnVsbF0pXG5cdFx0ICogQHBhcmFtIHtCb29sZWFufSBmdWxsIGlmIHNldCB0byBgdHJ1ZWAgYWxsIG5vZGVzIGFyZSByZWRyYXduLlxuXHRcdCAqL1xuXHRcdHJlZHJhdyA6IGZ1bmN0aW9uIChmdWxsKSB7XG5cdFx0XHRpZihmdWxsKSB7XG5cdFx0XHRcdHRoaXMuX21vZGVsLmZvcmNlX2Z1bGxfcmVkcmF3ID0gdHJ1ZTtcblx0XHRcdH1cblx0XHRcdC8vaWYodGhpcy5fbW9kZWwucmVkcmF3X3RpbWVvdXQpIHtcblx0XHRcdC8vXHRjbGVhclRpbWVvdXQodGhpcy5fbW9kZWwucmVkcmF3X3RpbWVvdXQpO1xuXHRcdFx0Ly99XG5cdFx0XHQvL3RoaXMuX21vZGVsLnJlZHJhd190aW1lb3V0ID0gc2V0VGltZW91dCgkLnByb3h5KHRoaXMuX3JlZHJhdywgdGhpcyksMCk7XG5cdFx0XHR0aGlzLl9yZWRyYXcoKTtcblx0XHR9LFxuXHRcdC8qKlxuXHRcdCAqIHJlZHJhd3MgYSBzaW5nbGUgbm9kZSdzIGNoaWxkcmVuLiBVc2VkIGludGVybmFsbHkuXG5cdFx0ICogQHByaXZhdGVcblx0XHQgKiBAbmFtZSBkcmF3X2NoaWxkcmVuKG5vZGUpXG5cdFx0ICogQHBhcmFtIHttaXhlZH0gbm9kZSB0aGUgbm9kZSB3aG9zZSBjaGlsZHJlbiB3aWxsIGJlIHJlZHJhd25cblx0XHQgKi9cblx0XHRkcmF3X2NoaWxkcmVuIDogZnVuY3Rpb24gKG5vZGUpIHtcblx0XHRcdHZhciBvYmogPSB0aGlzLmdldF9ub2RlKG5vZGUpLFxuXHRcdFx0XHRpID0gZmFsc2UsXG5cdFx0XHRcdGogPSBmYWxzZSxcblx0XHRcdFx0ayA9IGZhbHNlLFxuXHRcdFx0XHRkID0gZG9jdW1lbnQ7XG5cdFx0XHRpZighb2JqKSB7IHJldHVybiBmYWxzZTsgfVxuXHRcdFx0aWYob2JqLmlkID09PSAkLmpzdHJlZS5yb290KSB7IHJldHVybiB0aGlzLnJlZHJhdyh0cnVlKTsgfVxuXHRcdFx0bm9kZSA9IHRoaXMuZ2V0X25vZGUobm9kZSwgdHJ1ZSk7XG5cdFx0XHRpZighbm9kZSB8fCAhbm9kZS5sZW5ndGgpIHsgcmV0dXJuIGZhbHNlOyB9IC8vIFRPRE86IHF1aWNrIHRvZ2dsZVxuXG5cdFx0XHRub2RlLmNoaWxkcmVuKCcuanN0cmVlLWNoaWxkcmVuJykucmVtb3ZlKCk7XG5cdFx0XHRub2RlID0gbm9kZVswXTtcblx0XHRcdGlmKG9iai5jaGlsZHJlbi5sZW5ndGggJiYgb2JqLnN0YXRlLmxvYWRlZCkge1xuXHRcdFx0XHRrID0gZC5jcmVhdGVFbGVtZW50KCdVTCcpO1xuXHRcdFx0XHRrLnNldEF0dHJpYnV0ZSgncm9sZScsICdncm91cCcpO1xuXHRcdFx0XHRrLmNsYXNzTmFtZSA9ICdqc3RyZWUtY2hpbGRyZW4nO1xuXHRcdFx0XHRmb3IoaSA9IDAsIGogPSBvYmouY2hpbGRyZW4ubGVuZ3RoOyBpIDwgajsgaSsrKSB7XG5cdFx0XHRcdFx0ay5hcHBlbmRDaGlsZCh0aGlzLnJlZHJhd19ub2RlKG9iai5jaGlsZHJlbltpXSwgdHJ1ZSwgdHJ1ZSkpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdG5vZGUuYXBwZW5kQ2hpbGQoayk7XG5cdFx0XHR9XG5cdFx0fSxcblx0XHQvKipcblx0XHQgKiByZWRyYXdzIGEgc2luZ2xlIG5vZGUuIFVzZWQgaW50ZXJuYWxseS5cblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqIEBuYW1lIHJlZHJhd19ub2RlKG5vZGUsIGRlZXAsIGlzX2NhbGxiYWNrLCBmb3JjZV9yZW5kZXIpXG5cdFx0ICogQHBhcmFtIHttaXhlZH0gbm9kZSB0aGUgbm9kZSB0byByZWRyYXdcblx0XHQgKiBAcGFyYW0ge0Jvb2xlYW59IGRlZXAgc2hvdWxkIGNoaWxkIG5vZGVzIGJlIHJlZHJhd24gdG9vXG5cdFx0ICogQHBhcmFtIHtCb29sZWFufSBpc19jYWxsYmFjayBpcyB0aGlzIGEgcmVjdXJzaW9uIGNhbGxcblx0XHQgKiBAcGFyYW0ge0Jvb2xlYW59IGZvcmNlX3JlbmRlciBzaG91bGQgY2hpbGRyZW4gb2YgY2xvc2VkIHBhcmVudHMgYmUgZHJhd24gYW55d2F5XG5cdFx0ICovXG5cdFx0cmVkcmF3X25vZGUgOiBmdW5jdGlvbiAobm9kZSwgZGVlcCwgaXNfY2FsbGJhY2ssIGZvcmNlX3JlbmRlcikge1xuXHRcdFx0dmFyIG9iaiA9IHRoaXMuZ2V0X25vZGUobm9kZSksXG5cdFx0XHRcdHBhciA9IGZhbHNlLFxuXHRcdFx0XHRpbmQgPSBmYWxzZSxcblx0XHRcdFx0b2xkID0gZmFsc2UsXG5cdFx0XHRcdGkgPSBmYWxzZSxcblx0XHRcdFx0aiA9IGZhbHNlLFxuXHRcdFx0XHRrID0gZmFsc2UsXG5cdFx0XHRcdGMgPSAnJyxcblx0XHRcdFx0ZCA9IGRvY3VtZW50LFxuXHRcdFx0XHRtID0gdGhpcy5fbW9kZWwuZGF0YSxcblx0XHRcdFx0ZiA9IGZhbHNlLFxuXHRcdFx0XHRzID0gZmFsc2UsXG5cdFx0XHRcdHRtcCA9IG51bGwsXG5cdFx0XHRcdHQgPSAwLFxuXHRcdFx0XHRsID0gMCxcblx0XHRcdFx0aGFzX2NoaWxkcmVuID0gZmFsc2UsXG5cdFx0XHRcdGxhc3Rfc2libGluZyA9IGZhbHNlO1xuXHRcdFx0aWYoIW9iaikgeyByZXR1cm4gZmFsc2U7IH1cblx0XHRcdGlmKG9iai5pZCA9PT0gJC5qc3RyZWUucm9vdCkgeyAgcmV0dXJuIHRoaXMucmVkcmF3KHRydWUpOyB9XG5cdFx0XHRkZWVwID0gZGVlcCB8fCBvYmouY2hpbGRyZW4ubGVuZ3RoID09PSAwO1xuXHRcdFx0bm9kZSA9ICFkb2N1bWVudC5xdWVyeVNlbGVjdG9yID8gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQob2JqLmlkKSA6IHRoaXMuZWxlbWVudFswXS5xdWVyeVNlbGVjdG9yKCcjJyArIChcIjAxMjM0NTY3ODlcIi5pbmRleE9mKG9iai5pZFswXSkgIT09IC0xID8gJ1xcXFwzJyArIG9iai5pZFswXSArICcgJyArIG9iai5pZC5zdWJzdHIoMSkucmVwbGFjZSgkLmpzdHJlZS5pZHJlZ2V4LCdcXFxcJCYnKSA6IG9iai5pZC5yZXBsYWNlKCQuanN0cmVlLmlkcmVnZXgsJ1xcXFwkJicpKSApOyAvLywgdGhpcy5lbGVtZW50KTtcblx0XHRcdGlmKCFub2RlKSB7XG5cdFx0XHRcdGRlZXAgPSB0cnVlO1xuXHRcdFx0XHQvL25vZGUgPSBkLmNyZWF0ZUVsZW1lbnQoJ0xJJyk7XG5cdFx0XHRcdGlmKCFpc19jYWxsYmFjaykge1xuXHRcdFx0XHRcdHBhciA9IG9iai5wYXJlbnQgIT09ICQuanN0cmVlLnJvb3QgPyAkKCcjJyArIG9iai5wYXJlbnQucmVwbGFjZSgkLmpzdHJlZS5pZHJlZ2V4LCdcXFxcJCYnKSwgdGhpcy5lbGVtZW50KVswXSA6IG51bGw7XG5cdFx0XHRcdFx0aWYocGFyICE9PSBudWxsICYmICghcGFyIHx8ICFtW29iai5wYXJlbnRdLnN0YXRlLm9wZW5lZCkpIHtcblx0XHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aW5kID0gJC5pbkFycmF5KG9iai5pZCwgcGFyID09PSBudWxsID8gbVskLmpzdHJlZS5yb290XS5jaGlsZHJlbiA6IG1bb2JqLnBhcmVudF0uY2hpbGRyZW4pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRlbHNlIHtcblx0XHRcdFx0bm9kZSA9ICQobm9kZSk7XG5cdFx0XHRcdGlmKCFpc19jYWxsYmFjaykge1xuXHRcdFx0XHRcdHBhciA9IG5vZGUucGFyZW50KCkucGFyZW50KClbMF07XG5cdFx0XHRcdFx0aWYocGFyID09PSB0aGlzLmVsZW1lbnRbMF0pIHtcblx0XHRcdFx0XHRcdHBhciA9IG51bGw7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGluZCA9IG5vZGUuaW5kZXgoKTtcblx0XHRcdFx0fVxuXHRcdFx0XHQvLyBtW29iai5pZF0uZGF0YSA9IG5vZGUuZGF0YSgpOyAvLyB1c2Ugb25seSBub2RlJ3MgZGF0YSwgbm8gbmVlZCB0byB0b3VjaCBqcXVlcnkgc3RvcmFnZVxuXHRcdFx0XHRpZighZGVlcCAmJiBvYmouY2hpbGRyZW4ubGVuZ3RoICYmICFub2RlLmNoaWxkcmVuKCcuanN0cmVlLWNoaWxkcmVuJykubGVuZ3RoKSB7XG5cdFx0XHRcdFx0ZGVlcCA9IHRydWU7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYoIWRlZXApIHtcblx0XHRcdFx0XHRvbGQgPSBub2RlLmNoaWxkcmVuKCcuanN0cmVlLWNoaWxkcmVuJylbMF07XG5cdFx0XHRcdH1cblx0XHRcdFx0ZiA9IG5vZGUuY2hpbGRyZW4oJy5qc3RyZWUtYW5jaG9yJylbMF0gPT09IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQ7XG5cdFx0XHRcdG5vZGUucmVtb3ZlKCk7XG5cdFx0XHRcdC8vbm9kZSA9IGQuY3JlYXRlRWxlbWVudCgnTEknKTtcblx0XHRcdFx0Ly9ub2RlID0gbm9kZVswXTtcblx0XHRcdH1cblx0XHRcdG5vZGUgPSB0aGlzLl9kYXRhLmNvcmUubm9kZS5jbG9uZU5vZGUodHJ1ZSk7XG5cdFx0XHQvLyBub2RlIGlzIERPTSwgZGVlcCBpcyBib29sZWFuXG5cblx0XHRcdGMgPSAnanN0cmVlLW5vZGUgJztcblx0XHRcdGZvcihpIGluIG9iai5saV9hdHRyKSB7XG5cdFx0XHRcdGlmKG9iai5saV9hdHRyLmhhc093blByb3BlcnR5KGkpKSB7XG5cdFx0XHRcdFx0aWYoaSA9PT0gJ2lkJykgeyBjb250aW51ZTsgfVxuXHRcdFx0XHRcdGlmKGkgIT09ICdjbGFzcycpIHtcblx0XHRcdFx0XHRcdG5vZGUuc2V0QXR0cmlidXRlKGksIG9iai5saV9hdHRyW2ldKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0XHRjICs9IG9iai5saV9hdHRyW2ldO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0aWYoIW9iai5hX2F0dHIuaWQpIHtcblx0XHRcdFx0b2JqLmFfYXR0ci5pZCA9IG9iai5pZCArICdfYW5jaG9yJztcblx0XHRcdH1cblx0XHRcdG5vZGUuc2V0QXR0cmlidXRlKCdhcmlhLXNlbGVjdGVkJywgISFvYmouc3RhdGUuc2VsZWN0ZWQpO1xuXHRcdFx0bm9kZS5zZXRBdHRyaWJ1dGUoJ2FyaWEtbGV2ZWwnLCBvYmoucGFyZW50cy5sZW5ndGgpO1xuXHRcdFx0bm9kZS5zZXRBdHRyaWJ1dGUoJ2FyaWEtbGFiZWxsZWRieScsIG9iai5hX2F0dHIuaWQpO1xuXHRcdFx0aWYob2JqLnN0YXRlLmRpc2FibGVkKSB7XG5cdFx0XHRcdG5vZGUuc2V0QXR0cmlidXRlKCdhcmlhLWRpc2FibGVkJywgdHJ1ZSk7XG5cdFx0XHR9XG5cblx0XHRcdGZvcihpID0gMCwgaiA9IG9iai5jaGlsZHJlbi5sZW5ndGg7IGkgPCBqOyBpKyspIHtcblx0XHRcdFx0aWYoIW1bb2JqLmNoaWxkcmVuW2ldXS5zdGF0ZS5oaWRkZW4pIHtcblx0XHRcdFx0XHRoYXNfY2hpbGRyZW4gPSB0cnVlO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRpZihvYmoucGFyZW50ICE9PSBudWxsICYmIG1bb2JqLnBhcmVudF0gJiYgIW9iai5zdGF0ZS5oaWRkZW4pIHtcblx0XHRcdFx0aSA9ICQuaW5BcnJheShvYmouaWQsIG1bb2JqLnBhcmVudF0uY2hpbGRyZW4pO1xuXHRcdFx0XHRsYXN0X3NpYmxpbmcgPSBvYmouaWQ7XG5cdFx0XHRcdGlmKGkgIT09IC0xKSB7XG5cdFx0XHRcdFx0aSsrO1xuXHRcdFx0XHRcdGZvcihqID0gbVtvYmoucGFyZW50XS5jaGlsZHJlbi5sZW5ndGg7IGkgPCBqOyBpKyspIHtcblx0XHRcdFx0XHRcdGlmKCFtW21bb2JqLnBhcmVudF0uY2hpbGRyZW5baV1dLnN0YXRlLmhpZGRlbikge1xuXHRcdFx0XHRcdFx0XHRsYXN0X3NpYmxpbmcgPSBtW29iai5wYXJlbnRdLmNoaWxkcmVuW2ldO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0aWYobGFzdF9zaWJsaW5nICE9PSBvYmouaWQpIHtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGlmKG9iai5zdGF0ZS5oaWRkZW4pIHtcblx0XHRcdFx0YyArPSAnIGpzdHJlZS1oaWRkZW4nO1xuXHRcdFx0fVxuXHRcdFx0aWYob2JqLnN0YXRlLmxvYWRlZCAmJiAhaGFzX2NoaWxkcmVuKSB7XG5cdFx0XHRcdGMgKz0gJyBqc3RyZWUtbGVhZic7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIHtcblx0XHRcdFx0YyArPSBvYmouc3RhdGUub3BlbmVkICYmIG9iai5zdGF0ZS5sb2FkZWQgPyAnIGpzdHJlZS1vcGVuJyA6ICcganN0cmVlLWNsb3NlZCc7XG5cdFx0XHRcdG5vZGUuc2V0QXR0cmlidXRlKCdhcmlhLWV4cGFuZGVkJywgKG9iai5zdGF0ZS5vcGVuZWQgJiYgb2JqLnN0YXRlLmxvYWRlZCkgKTtcblx0XHRcdH1cblx0XHRcdGlmKGxhc3Rfc2libGluZyA9PT0gb2JqLmlkKSB7XG5cdFx0XHRcdGMgKz0gJyBqc3RyZWUtbGFzdCc7XG5cdFx0XHR9XG5cdFx0XHRub2RlLmlkID0gb2JqLmlkO1xuXHRcdFx0bm9kZS5jbGFzc05hbWUgPSBjO1xuXHRcdFx0YyA9ICggb2JqLnN0YXRlLnNlbGVjdGVkID8gJyBqc3RyZWUtY2xpY2tlZCcgOiAnJykgKyAoIG9iai5zdGF0ZS5kaXNhYmxlZCA/ICcganN0cmVlLWRpc2FibGVkJyA6ICcnKTtcblx0XHRcdGZvcihqIGluIG9iai5hX2F0dHIpIHtcblx0XHRcdFx0aWYob2JqLmFfYXR0ci5oYXNPd25Qcm9wZXJ0eShqKSkge1xuXHRcdFx0XHRcdGlmKGogPT09ICdocmVmJyAmJiBvYmouYV9hdHRyW2pdID09PSAnIycpIHsgY29udGludWU7IH1cblx0XHRcdFx0XHRpZihqICE9PSAnY2xhc3MnKSB7XG5cdFx0XHRcdFx0XHRub2RlLmNoaWxkTm9kZXNbMV0uc2V0QXR0cmlidXRlKGosIG9iai5hX2F0dHJbal0pO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRcdGMgKz0gJyAnICsgb2JqLmFfYXR0cltqXTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGlmKGMubGVuZ3RoKSB7XG5cdFx0XHRcdG5vZGUuY2hpbGROb2Rlc1sxXS5jbGFzc05hbWUgPSAnanN0cmVlLWFuY2hvciAnICsgYztcblx0XHRcdH1cblx0XHRcdGlmKChvYmouaWNvbiAmJiBvYmouaWNvbiAhPT0gdHJ1ZSkgfHwgb2JqLmljb24gPT09IGZhbHNlKSB7XG5cdFx0XHRcdGlmKG9iai5pY29uID09PSBmYWxzZSkge1xuXHRcdFx0XHRcdG5vZGUuY2hpbGROb2Rlc1sxXS5jaGlsZE5vZGVzWzBdLmNsYXNzTmFtZSArPSAnIGpzdHJlZS10aGVtZWljb24taGlkZGVuJztcblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIGlmKG9iai5pY29uLmluZGV4T2YoJy8nKSA9PT0gLTEgJiYgb2JqLmljb24uaW5kZXhPZignLicpID09PSAtMSkge1xuXHRcdFx0XHRcdG5vZGUuY2hpbGROb2Rlc1sxXS5jaGlsZE5vZGVzWzBdLmNsYXNzTmFtZSArPSAnICcgKyBvYmouaWNvbiArICcganN0cmVlLXRoZW1laWNvbi1jdXN0b20nO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdG5vZGUuY2hpbGROb2Rlc1sxXS5jaGlsZE5vZGVzWzBdLnN0eWxlLmJhY2tncm91bmRJbWFnZSA9ICd1cmwoXCInK29iai5pY29uKydcIiknO1xuXHRcdFx0XHRcdG5vZGUuY2hpbGROb2Rlc1sxXS5jaGlsZE5vZGVzWzBdLnN0eWxlLmJhY2tncm91bmRQb3NpdGlvbiA9ICdjZW50ZXIgY2VudGVyJztcblx0XHRcdFx0XHRub2RlLmNoaWxkTm9kZXNbMV0uY2hpbGROb2Rlc1swXS5zdHlsZS5iYWNrZ3JvdW5kU2l6ZSA9ICdhdXRvJztcblx0XHRcdFx0XHRub2RlLmNoaWxkTm9kZXNbMV0uY2hpbGROb2Rlc1swXS5jbGFzc05hbWUgKz0gJyBqc3RyZWUtdGhlbWVpY29uLWN1c3RvbSc7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0aWYodGhpcy5zZXR0aW5ncy5jb3JlLmZvcmNlX3RleHQpIHtcblx0XHRcdFx0bm9kZS5jaGlsZE5vZGVzWzFdLmFwcGVuZENoaWxkKGQuY3JlYXRlVGV4dE5vZGUob2JqLnRleHQpKTtcblx0XHRcdH1cblx0XHRcdGVsc2Uge1xuXHRcdFx0XHRub2RlLmNoaWxkTm9kZXNbMV0uaW5uZXJIVE1MICs9IG9iai50ZXh0O1xuXHRcdFx0fVxuXG5cblx0XHRcdGlmKGRlZXAgJiYgb2JqLmNoaWxkcmVuLmxlbmd0aCAmJiAob2JqLnN0YXRlLm9wZW5lZCB8fCBmb3JjZV9yZW5kZXIpICYmIG9iai5zdGF0ZS5sb2FkZWQpIHtcblx0XHRcdFx0ayA9IGQuY3JlYXRlRWxlbWVudCgnVUwnKTtcblx0XHRcdFx0ay5zZXRBdHRyaWJ1dGUoJ3JvbGUnLCAnZ3JvdXAnKTtcblx0XHRcdFx0ay5jbGFzc05hbWUgPSAnanN0cmVlLWNoaWxkcmVuJztcblx0XHRcdFx0Zm9yKGkgPSAwLCBqID0gb2JqLmNoaWxkcmVuLmxlbmd0aDsgaSA8IGo7IGkrKykge1xuXHRcdFx0XHRcdGsuYXBwZW5kQ2hpbGQodGhpcy5yZWRyYXdfbm9kZShvYmouY2hpbGRyZW5baV0sIGRlZXAsIHRydWUpKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRub2RlLmFwcGVuZENoaWxkKGspO1xuXHRcdFx0fVxuXHRcdFx0aWYob2xkKSB7XG5cdFx0XHRcdG5vZGUuYXBwZW5kQ2hpbGQob2xkKTtcblx0XHRcdH1cblx0XHRcdGlmKCFpc19jYWxsYmFjaykge1xuXHRcdFx0XHQvLyBhcHBlbmQgYmFjayB1c2luZyBwYXIgLyBpbmRcblx0XHRcdFx0aWYoIXBhcikge1xuXHRcdFx0XHRcdHBhciA9IHRoaXMuZWxlbWVudFswXTtcblx0XHRcdFx0fVxuXHRcdFx0XHRmb3IoaSA9IDAsIGogPSBwYXIuY2hpbGROb2Rlcy5sZW5ndGg7IGkgPCBqOyBpKyspIHtcblx0XHRcdFx0XHRpZihwYXIuY2hpbGROb2Rlc1tpXSAmJiBwYXIuY2hpbGROb2Rlc1tpXS5jbGFzc05hbWUgJiYgcGFyLmNoaWxkTm9kZXNbaV0uY2xhc3NOYW1lLmluZGV4T2YoJ2pzdHJlZS1jaGlsZHJlbicpICE9PSAtMSkge1xuXHRcdFx0XHRcdFx0dG1wID0gcGFyLmNoaWxkTm9kZXNbaV07XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYoIXRtcCkge1xuXHRcdFx0XHRcdHRtcCA9IGQuY3JlYXRlRWxlbWVudCgnVUwnKTtcblx0XHRcdFx0XHR0bXAuc2V0QXR0cmlidXRlKCdyb2xlJywgJ2dyb3VwJyk7XG5cdFx0XHRcdFx0dG1wLmNsYXNzTmFtZSA9ICdqc3RyZWUtY2hpbGRyZW4nO1xuXHRcdFx0XHRcdHBhci5hcHBlbmRDaGlsZCh0bXApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHBhciA9IHRtcDtcblxuXHRcdFx0XHRpZihpbmQgPCBwYXIuY2hpbGROb2Rlcy5sZW5ndGgpIHtcblx0XHRcdFx0XHRwYXIuaW5zZXJ0QmVmb3JlKG5vZGUsIHBhci5jaGlsZE5vZGVzW2luZF0pO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdHBhci5hcHBlbmRDaGlsZChub2RlKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZihmKSB7XG5cdFx0XHRcdFx0dCA9IHRoaXMuZWxlbWVudFswXS5zY3JvbGxUb3A7XG5cdFx0XHRcdFx0bCA9IHRoaXMuZWxlbWVudFswXS5zY3JvbGxMZWZ0O1xuXHRcdFx0XHRcdG5vZGUuY2hpbGROb2Rlc1sxXS5mb2N1cygpO1xuXHRcdFx0XHRcdHRoaXMuZWxlbWVudFswXS5zY3JvbGxUb3AgPSB0O1xuXHRcdFx0XHRcdHRoaXMuZWxlbWVudFswXS5zY3JvbGxMZWZ0ID0gbDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0aWYob2JqLnN0YXRlLm9wZW5lZCAmJiAhb2JqLnN0YXRlLmxvYWRlZCkge1xuXHRcdFx0XHRvYmouc3RhdGUub3BlbmVkID0gZmFsc2U7XG5cdFx0XHRcdHNldFRpbWVvdXQoJC5wcm94eShmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdFx0dGhpcy5vcGVuX25vZGUob2JqLmlkLCBmYWxzZSwgMCk7XG5cdFx0XHRcdH0sIHRoaXMpLCAwKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBub2RlO1xuXHRcdH0sXG5cdFx0LyoqXG5cdFx0ICogb3BlbnMgYSBub2RlLCByZXZhbGluZyBpdHMgY2hpbGRyZW4uIElmIHRoZSBub2RlIGlzIG5vdCBsb2FkZWQgaXQgd2lsbCBiZSBsb2FkZWQgYW5kIG9wZW5lZCBvbmNlIHJlYWR5LlxuXHRcdCAqIEBuYW1lIG9wZW5fbm9kZShvYmogWywgY2FsbGJhY2ssIGFuaW1hdGlvbl0pXG5cdFx0ICogQHBhcmFtIHttaXhlZH0gb2JqIHRoZSBub2RlIHRvIG9wZW5cblx0XHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBhIGZ1bmN0aW9uIHRvIGV4ZWN1dGUgb25jZSB0aGUgbm9kZSBpcyBvcGVuZWRcblx0XHQgKiBAcGFyYW0ge051bWJlcn0gYW5pbWF0aW9uIHRoZSBhbmltYXRpb24gZHVyYXRpb24gaW4gbWlsbGlzZWNvbmRzIHdoZW4gb3BlbmluZyB0aGUgbm9kZSAob3ZlcnJpZGVzIHRoZSBgY29yZS5hbmltYXRpb25gIHNldHRpbmcpLiBVc2UgYGZhbHNlYCBmb3Igbm8gYW5pbWF0aW9uLlxuXHRcdCAqIEB0cmlnZ2VyIG9wZW5fbm9kZS5qc3RyZWUsIGFmdGVyX29wZW4uanN0cmVlLCBiZWZvcmVfb3Blbi5qc3RyZWVcblx0XHQgKi9cblx0XHRvcGVuX25vZGUgOiBmdW5jdGlvbiAob2JqLCBjYWxsYmFjaywgYW5pbWF0aW9uKSB7XG5cdFx0XHR2YXIgdDEsIHQyLCBkLCB0O1xuXHRcdFx0aWYoJC5pc0FycmF5KG9iaikpIHtcblx0XHRcdFx0b2JqID0gb2JqLnNsaWNlKCk7XG5cdFx0XHRcdGZvcih0MSA9IDAsIHQyID0gb2JqLmxlbmd0aDsgdDEgPCB0MjsgdDErKykge1xuXHRcdFx0XHRcdHRoaXMub3Blbl9ub2RlKG9ialt0MV0sIGNhbGxiYWNrLCBhbmltYXRpb24pO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fVxuXHRcdFx0b2JqID0gdGhpcy5nZXRfbm9kZShvYmopO1xuXHRcdFx0aWYoIW9iaiB8fCBvYmouaWQgPT09ICQuanN0cmVlLnJvb3QpIHtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXHRcdFx0YW5pbWF0aW9uID0gYW5pbWF0aW9uID09PSB1bmRlZmluZWQgPyB0aGlzLnNldHRpbmdzLmNvcmUuYW5pbWF0aW9uIDogYW5pbWF0aW9uO1xuXHRcdFx0aWYoIXRoaXMuaXNfY2xvc2VkKG9iaikpIHtcblx0XHRcdFx0aWYoY2FsbGJhY2spIHtcblx0XHRcdFx0XHRjYWxsYmFjay5jYWxsKHRoaXMsIG9iaiwgZmFsc2UpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblx0XHRcdGlmKCF0aGlzLmlzX2xvYWRlZChvYmopKSB7XG5cdFx0XHRcdGlmKHRoaXMuaXNfbG9hZGluZyhvYmopKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHNldFRpbWVvdXQoJC5wcm94eShmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdFx0XHR0aGlzLm9wZW5fbm9kZShvYmosIGNhbGxiYWNrLCBhbmltYXRpb24pO1xuXHRcdFx0XHRcdH0sIHRoaXMpLCA1MDApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRoaXMubG9hZF9ub2RlKG9iaiwgZnVuY3Rpb24gKG8sIG9rKSB7XG5cdFx0XHRcdFx0cmV0dXJuIG9rID8gdGhpcy5vcGVuX25vZGUobywgY2FsbGJhY2ssIGFuaW1hdGlvbikgOiAoY2FsbGJhY2sgPyBjYWxsYmFjay5jYWxsKHRoaXMsIG8sIGZhbHNlKSA6IGZhbHNlKTtcblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIHtcblx0XHRcdFx0ZCA9IHRoaXMuZ2V0X25vZGUob2JqLCB0cnVlKTtcblx0XHRcdFx0dCA9IHRoaXM7XG5cdFx0XHRcdGlmKGQubGVuZ3RoKSB7XG5cdFx0XHRcdFx0aWYoYW5pbWF0aW9uICYmIGQuY2hpbGRyZW4oXCIuanN0cmVlLWNoaWxkcmVuXCIpLmxlbmd0aCkge1xuXHRcdFx0XHRcdFx0ZC5jaGlsZHJlbihcIi5qc3RyZWUtY2hpbGRyZW5cIikuc3RvcCh0cnVlLCB0cnVlKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYob2JqLmNoaWxkcmVuLmxlbmd0aCAmJiAhdGhpcy5fZmlyc3RDaGlsZChkLmNoaWxkcmVuKCcuanN0cmVlLWNoaWxkcmVuJylbMF0pKSB7XG5cdFx0XHRcdFx0XHR0aGlzLmRyYXdfY2hpbGRyZW4ob2JqKTtcblx0XHRcdFx0XHRcdC8vZCA9IHRoaXMuZ2V0X25vZGUob2JqLCB0cnVlKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYoIWFuaW1hdGlvbikge1xuXHRcdFx0XHRcdFx0dGhpcy50cmlnZ2VyKCdiZWZvcmVfb3BlbicsIHsgXCJub2RlXCIgOiBvYmogfSk7XG5cdFx0XHRcdFx0XHRkWzBdLmNsYXNzTmFtZSA9IGRbMF0uY2xhc3NOYW1lLnJlcGxhY2UoJ2pzdHJlZS1jbG9zZWQnLCAnanN0cmVlLW9wZW4nKTtcblx0XHRcdFx0XHRcdGRbMF0uc2V0QXR0cmlidXRlKFwiYXJpYS1leHBhbmRlZFwiLCB0cnVlKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0XHR0aGlzLnRyaWdnZXIoJ2JlZm9yZV9vcGVuJywgeyBcIm5vZGVcIiA6IG9iaiB9KTtcblx0XHRcdFx0XHRcdGRcblx0XHRcdFx0XHRcdFx0LmNoaWxkcmVuKFwiLmpzdHJlZS1jaGlsZHJlblwiKS5jc3MoXCJkaXNwbGF5XCIsXCJub25lXCIpLmVuZCgpXG5cdFx0XHRcdFx0XHRcdC5yZW1vdmVDbGFzcyhcImpzdHJlZS1jbG9zZWRcIikuYWRkQ2xhc3MoXCJqc3RyZWUtb3BlblwiKS5hdHRyKFwiYXJpYS1leHBhbmRlZFwiLCB0cnVlKVxuXHRcdFx0XHRcdFx0XHQuY2hpbGRyZW4oXCIuanN0cmVlLWNoaWxkcmVuXCIpLnN0b3AodHJ1ZSwgdHJ1ZSlcblx0XHRcdFx0XHRcdFx0XHQuc2xpZGVEb3duKGFuaW1hdGlvbiwgZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdFx0XHRcdFx0dGhpcy5zdHlsZS5kaXNwbGF5ID0gXCJcIjtcblx0XHRcdFx0XHRcdFx0XHRcdGlmICh0LmVsZW1lbnQpIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dC50cmlnZ2VyKFwiYWZ0ZXJfb3BlblwiLCB7IFwibm9kZVwiIDogb2JqIH0pO1xuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRvYmouc3RhdGUub3BlbmVkID0gdHJ1ZTtcblx0XHRcdFx0aWYoY2FsbGJhY2spIHtcblx0XHRcdFx0XHRjYWxsYmFjay5jYWxsKHRoaXMsIG9iaiwgdHJ1ZSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYoIWQubGVuZ3RoKSB7XG5cdFx0XHRcdFx0LyoqXG5cdFx0XHRcdFx0ICogdHJpZ2dlcmVkIHdoZW4gYSBub2RlIGlzIGFib3V0IHRvIGJlIG9wZW5lZCAoaWYgdGhlIG5vZGUgaXMgc3VwcG9zZWQgdG8gYmUgaW4gdGhlIERPTSwgaXQgd2lsbCBiZSwgYnV0IGl0IHdvbid0IGJlIHZpc2libGUgeWV0KVxuXHRcdFx0XHRcdCAqIEBldmVudFxuXHRcdFx0XHRcdCAqIEBuYW1lIGJlZm9yZV9vcGVuLmpzdHJlZVxuXHRcdFx0XHRcdCAqIEBwYXJhbSB7T2JqZWN0fSBub2RlIHRoZSBvcGVuZWQgbm9kZVxuXHRcdFx0XHRcdCAqL1xuXHRcdFx0XHRcdHRoaXMudHJpZ2dlcignYmVmb3JlX29wZW4nLCB7IFwibm9kZVwiIDogb2JqIH0pO1xuXHRcdFx0XHR9XG5cdFx0XHRcdC8qKlxuXHRcdFx0XHQgKiB0cmlnZ2VyZWQgd2hlbiBhIG5vZGUgaXMgb3BlbmVkIChpZiB0aGVyZSBpcyBhbiBhbmltYXRpb24gaXQgd2lsbCBub3QgYmUgY29tcGxldGVkIHlldClcblx0XHRcdFx0ICogQGV2ZW50XG5cdFx0XHRcdCAqIEBuYW1lIG9wZW5fbm9kZS5qc3RyZWVcblx0XHRcdFx0ICogQHBhcmFtIHtPYmplY3R9IG5vZGUgdGhlIG9wZW5lZCBub2RlXG5cdFx0XHRcdCAqL1xuXHRcdFx0XHR0aGlzLnRyaWdnZXIoJ29wZW5fbm9kZScsIHsgXCJub2RlXCIgOiBvYmogfSk7XG5cdFx0XHRcdGlmKCFhbmltYXRpb24gfHwgIWQubGVuZ3RoKSB7XG5cdFx0XHRcdFx0LyoqXG5cdFx0XHRcdFx0ICogdHJpZ2dlcmVkIHdoZW4gYSBub2RlIGlzIG9wZW5lZCBhbmQgdGhlIGFuaW1hdGlvbiBpcyBjb21wbGV0ZVxuXHRcdFx0XHRcdCAqIEBldmVudFxuXHRcdFx0XHRcdCAqIEBuYW1lIGFmdGVyX29wZW4uanN0cmVlXG5cdFx0XHRcdFx0ICogQHBhcmFtIHtPYmplY3R9IG5vZGUgdGhlIG9wZW5lZCBub2RlXG5cdFx0XHRcdFx0ICovXG5cdFx0XHRcdFx0dGhpcy50cmlnZ2VyKFwiYWZ0ZXJfb3BlblwiLCB7IFwibm9kZVwiIDogb2JqIH0pO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fVxuXHRcdH0sXG5cdFx0LyoqXG5cdFx0ICogb3BlbnMgZXZlcnkgcGFyZW50IG9mIGEgbm9kZSAobm9kZSBzaG91bGQgYmUgbG9hZGVkKVxuXHRcdCAqIEBuYW1lIF9vcGVuX3RvKG9iailcblx0XHQgKiBAcGFyYW0ge21peGVkfSBvYmogdGhlIG5vZGUgdG8gcmV2ZWFsXG5cdFx0ICogQHByaXZhdGVcblx0XHQgKi9cblx0XHRfb3Blbl90byA6IGZ1bmN0aW9uIChvYmopIHtcblx0XHRcdG9iaiA9IHRoaXMuZ2V0X25vZGUob2JqKTtcblx0XHRcdGlmKCFvYmogfHwgb2JqLmlkID09PSAkLmpzdHJlZS5yb290KSB7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblx0XHRcdHZhciBpLCBqLCBwID0gb2JqLnBhcmVudHM7XG5cdFx0XHRmb3IoaSA9IDAsIGogPSBwLmxlbmd0aDsgaSA8IGo7IGkrPTEpIHtcblx0XHRcdFx0aWYoaSAhPT0gJC5qc3RyZWUucm9vdCkge1xuXHRcdFx0XHRcdHRoaXMub3Blbl9ub2RlKHBbaV0sIGZhbHNlLCAwKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuICQoJyMnICsgb2JqLmlkLnJlcGxhY2UoJC5qc3RyZWUuaWRyZWdleCwnXFxcXCQmJyksIHRoaXMuZWxlbWVudCk7XG5cdFx0fSxcblx0XHQvKipcblx0XHQgKiBjbG9zZXMgYSBub2RlLCBoaWRpbmcgaXRzIGNoaWxkcmVuXG5cdFx0ICogQG5hbWUgY2xvc2Vfbm9kZShvYmogWywgYW5pbWF0aW9uXSlcblx0XHQgKiBAcGFyYW0ge21peGVkfSBvYmogdGhlIG5vZGUgdG8gY2xvc2Vcblx0XHQgKiBAcGFyYW0ge051bWJlcn0gYW5pbWF0aW9uIHRoZSBhbmltYXRpb24gZHVyYXRpb24gaW4gbWlsbGlzZWNvbmRzIHdoZW4gY2xvc2luZyB0aGUgbm9kZSAob3ZlcnJpZGVzIHRoZSBgY29yZS5hbmltYXRpb25gIHNldHRpbmcpLiBVc2UgYGZhbHNlYCBmb3Igbm8gYW5pbWF0aW9uLlxuXHRcdCAqIEB0cmlnZ2VyIGNsb3NlX25vZGUuanN0cmVlLCBhZnRlcl9jbG9zZS5qc3RyZWVcblx0XHQgKi9cblx0XHRjbG9zZV9ub2RlIDogZnVuY3Rpb24gKG9iaiwgYW5pbWF0aW9uKSB7XG5cdFx0XHR2YXIgdDEsIHQyLCB0LCBkO1xuXHRcdFx0aWYoJC5pc0FycmF5KG9iaikpIHtcblx0XHRcdFx0b2JqID0gb2JqLnNsaWNlKCk7XG5cdFx0XHRcdGZvcih0MSA9IDAsIHQyID0gb2JqLmxlbmd0aDsgdDEgPCB0MjsgdDErKykge1xuXHRcdFx0XHRcdHRoaXMuY2xvc2Vfbm9kZShvYmpbdDFdLCBhbmltYXRpb24pO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fVxuXHRcdFx0b2JqID0gdGhpcy5nZXRfbm9kZShvYmopO1xuXHRcdFx0aWYoIW9iaiB8fCBvYmouaWQgPT09ICQuanN0cmVlLnJvb3QpIHtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXHRcdFx0aWYodGhpcy5pc19jbG9zZWQob2JqKSkge1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cdFx0XHRhbmltYXRpb24gPSBhbmltYXRpb24gPT09IHVuZGVmaW5lZCA/IHRoaXMuc2V0dGluZ3MuY29yZS5hbmltYXRpb24gOiBhbmltYXRpb247XG5cdFx0XHR0ID0gdGhpcztcblx0XHRcdGQgPSB0aGlzLmdldF9ub2RlKG9iaiwgdHJ1ZSk7XG5cblx0XHRcdG9iai5zdGF0ZS5vcGVuZWQgPSBmYWxzZTtcblx0XHRcdC8qKlxuXHRcdFx0ICogdHJpZ2dlcmVkIHdoZW4gYSBub2RlIGlzIGNsb3NlZCAoaWYgdGhlcmUgaXMgYW4gYW5pbWF0aW9uIGl0IHdpbGwgbm90IGJlIGNvbXBsZXRlIHlldClcblx0XHRcdCAqIEBldmVudFxuXHRcdFx0ICogQG5hbWUgY2xvc2Vfbm9kZS5qc3RyZWVcblx0XHRcdCAqIEBwYXJhbSB7T2JqZWN0fSBub2RlIHRoZSBjbG9zZWQgbm9kZVxuXHRcdFx0ICovXG5cdFx0XHR0aGlzLnRyaWdnZXIoJ2Nsb3NlX25vZGUnLHsgXCJub2RlXCIgOiBvYmogfSk7XG5cdFx0XHRpZighZC5sZW5ndGgpIHtcblx0XHRcdFx0LyoqXG5cdFx0XHRcdCAqIHRyaWdnZXJlZCB3aGVuIGEgbm9kZSBpcyBjbG9zZWQgYW5kIHRoZSBhbmltYXRpb24gaXMgY29tcGxldGVcblx0XHRcdFx0ICogQGV2ZW50XG5cdFx0XHRcdCAqIEBuYW1lIGFmdGVyX2Nsb3NlLmpzdHJlZVxuXHRcdFx0XHQgKiBAcGFyYW0ge09iamVjdH0gbm9kZSB0aGUgY2xvc2VkIG5vZGVcblx0XHRcdFx0ICovXG5cdFx0XHRcdHRoaXMudHJpZ2dlcihcImFmdGVyX2Nsb3NlXCIsIHsgXCJub2RlXCIgOiBvYmogfSk7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIHtcblx0XHRcdFx0aWYoIWFuaW1hdGlvbikge1xuXHRcdFx0XHRcdGRbMF0uY2xhc3NOYW1lID0gZFswXS5jbGFzc05hbWUucmVwbGFjZSgnanN0cmVlLW9wZW4nLCAnanN0cmVlLWNsb3NlZCcpO1xuXHRcdFx0XHRcdGQuYXR0cihcImFyaWEtZXhwYW5kZWRcIiwgZmFsc2UpLmNoaWxkcmVuKCcuanN0cmVlLWNoaWxkcmVuJykucmVtb3ZlKCk7XG5cdFx0XHRcdFx0dGhpcy50cmlnZ2VyKFwiYWZ0ZXJfY2xvc2VcIiwgeyBcIm5vZGVcIiA6IG9iaiB9KTtcblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRkXG5cdFx0XHRcdFx0XHQuY2hpbGRyZW4oXCIuanN0cmVlLWNoaWxkcmVuXCIpLmF0dHIoXCJzdHlsZVwiLFwiZGlzcGxheTpibG9jayAhaW1wb3J0YW50XCIpLmVuZCgpXG5cdFx0XHRcdFx0XHQucmVtb3ZlQ2xhc3MoXCJqc3RyZWUtb3BlblwiKS5hZGRDbGFzcyhcImpzdHJlZS1jbG9zZWRcIikuYXR0cihcImFyaWEtZXhwYW5kZWRcIiwgZmFsc2UpXG5cdFx0XHRcdFx0XHQuY2hpbGRyZW4oXCIuanN0cmVlLWNoaWxkcmVuXCIpLnN0b3AodHJ1ZSwgdHJ1ZSkuc2xpZGVVcChhbmltYXRpb24sIGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0XHRcdFx0dGhpcy5zdHlsZS5kaXNwbGF5ID0gXCJcIjtcblx0XHRcdFx0XHRcdFx0ZC5jaGlsZHJlbignLmpzdHJlZS1jaGlsZHJlbicpLnJlbW92ZSgpO1xuXHRcdFx0XHRcdFx0XHRpZiAodC5lbGVtZW50KSB7XG5cdFx0XHRcdFx0XHRcdFx0dC50cmlnZ2VyKFwiYWZ0ZXJfY2xvc2VcIiwgeyBcIm5vZGVcIiA6IG9iaiB9KTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9LFxuXHRcdC8qKlxuXHRcdCAqIHRvZ2dsZXMgYSBub2RlIC0gY2xvc2luZyBpdCBpZiBpdCBpcyBvcGVuLCBvcGVuaW5nIGl0IGlmIGl0IGlzIGNsb3NlZFxuXHRcdCAqIEBuYW1lIHRvZ2dsZV9ub2RlKG9iailcblx0XHQgKiBAcGFyYW0ge21peGVkfSBvYmogdGhlIG5vZGUgdG8gdG9nZ2xlXG5cdFx0ICovXG5cdFx0dG9nZ2xlX25vZGUgOiBmdW5jdGlvbiAob2JqKSB7XG5cdFx0XHR2YXIgdDEsIHQyO1xuXHRcdFx0aWYoJC5pc0FycmF5KG9iaikpIHtcblx0XHRcdFx0b2JqID0gb2JqLnNsaWNlKCk7XG5cdFx0XHRcdGZvcih0MSA9IDAsIHQyID0gb2JqLmxlbmd0aDsgdDEgPCB0MjsgdDErKykge1xuXHRcdFx0XHRcdHRoaXMudG9nZ2xlX25vZGUob2JqW3QxXSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9XG5cdFx0XHRpZih0aGlzLmlzX2Nsb3NlZChvYmopKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLm9wZW5fbm9kZShvYmopO1xuXHRcdFx0fVxuXHRcdFx0aWYodGhpcy5pc19vcGVuKG9iaikpIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuY2xvc2Vfbm9kZShvYmopO1xuXHRcdFx0fVxuXHRcdH0sXG5cdFx0LyoqXG5cdFx0ICogb3BlbnMgYWxsIG5vZGVzIHdpdGhpbiBhIG5vZGUgKG9yIHRoZSB0cmVlKSwgcmV2YWxpbmcgdGhlaXIgY2hpbGRyZW4uIElmIHRoZSBub2RlIGlzIG5vdCBsb2FkZWQgaXQgd2lsbCBiZSBsb2FkZWQgYW5kIG9wZW5lZCBvbmNlIHJlYWR5LlxuXHRcdCAqIEBuYW1lIG9wZW5fYWxsKFtvYmosIGFuaW1hdGlvbiwgb3JpZ2luYWxfb2JqXSlcblx0XHQgKiBAcGFyYW0ge21peGVkfSBvYmogdGhlIG5vZGUgdG8gb3BlbiByZWN1cnNpdmVseSwgb21pdCB0byBvcGVuIGFsbCBub2RlcyBpbiB0aGUgdHJlZVxuXHRcdCAqIEBwYXJhbSB7TnVtYmVyfSBhbmltYXRpb24gdGhlIGFuaW1hdGlvbiBkdXJhdGlvbiBpbiBtaWxsaXNlY29uZHMgd2hlbiBvcGVuaW5nIHRoZSBub2RlcywgdGhlIGRlZmF1bHQgaXMgbm8gYW5pbWF0aW9uXG5cdFx0ICogQHBhcmFtIHtqUXVlcnl9IHJlZmVyZW5jZSB0byB0aGUgbm9kZSB0aGF0IHN0YXJ0ZWQgdGhlIHByb2Nlc3MgKGludGVybmFsIHVzZSlcblx0XHQgKiBAdHJpZ2dlciBvcGVuX2FsbC5qc3RyZWVcblx0XHQgKi9cblx0XHRvcGVuX2FsbCA6IGZ1bmN0aW9uIChvYmosIGFuaW1hdGlvbiwgb3JpZ2luYWxfb2JqKSB7XG5cdFx0XHRpZighb2JqKSB7IG9iaiA9ICQuanN0cmVlLnJvb3Q7IH1cblx0XHRcdG9iaiA9IHRoaXMuZ2V0X25vZGUob2JqKTtcblx0XHRcdGlmKCFvYmopIHsgcmV0dXJuIGZhbHNlOyB9XG5cdFx0XHR2YXIgZG9tID0gb2JqLmlkID09PSAkLmpzdHJlZS5yb290ID8gdGhpcy5nZXRfY29udGFpbmVyX3VsKCkgOiB0aGlzLmdldF9ub2RlKG9iaiwgdHJ1ZSksIGksIGosIF90aGlzO1xuXHRcdFx0aWYoIWRvbS5sZW5ndGgpIHtcblx0XHRcdFx0Zm9yKGkgPSAwLCBqID0gb2JqLmNoaWxkcmVuX2QubGVuZ3RoOyBpIDwgajsgaSsrKSB7XG5cdFx0XHRcdFx0aWYodGhpcy5pc19jbG9zZWQodGhpcy5fbW9kZWwuZGF0YVtvYmouY2hpbGRyZW5fZFtpXV0pKSB7XG5cdFx0XHRcdFx0XHR0aGlzLl9tb2RlbC5kYXRhW29iai5jaGlsZHJlbl9kW2ldXS5zdGF0ZS5vcGVuZWQgPSB0cnVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdGhpcy50cmlnZ2VyKCdvcGVuX2FsbCcsIHsgXCJub2RlXCIgOiBvYmogfSk7XG5cdFx0XHR9XG5cdFx0XHRvcmlnaW5hbF9vYmogPSBvcmlnaW5hbF9vYmogfHwgZG9tO1xuXHRcdFx0X3RoaXMgPSB0aGlzO1xuXHRcdFx0ZG9tID0gdGhpcy5pc19jbG9zZWQob2JqKSA/IGRvbS5maW5kKCcuanN0cmVlLWNsb3NlZCcpLmFkZEJhY2soKSA6IGRvbS5maW5kKCcuanN0cmVlLWNsb3NlZCcpO1xuXHRcdFx0ZG9tLmVhY2goZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRfdGhpcy5vcGVuX25vZGUoXG5cdFx0XHRcdFx0dGhpcyxcblx0XHRcdFx0XHRmdW5jdGlvbihub2RlLCBzdGF0dXMpIHsgaWYoc3RhdHVzICYmIHRoaXMuaXNfcGFyZW50KG5vZGUpKSB7IHRoaXMub3Blbl9hbGwobm9kZSwgYW5pbWF0aW9uLCBvcmlnaW5hbF9vYmopOyB9IH0sXG5cdFx0XHRcdFx0YW5pbWF0aW9uIHx8IDBcblx0XHRcdFx0KTtcblx0XHRcdH0pO1xuXHRcdFx0aWYob3JpZ2luYWxfb2JqLmZpbmQoJy5qc3RyZWUtY2xvc2VkJykubGVuZ3RoID09PSAwKSB7XG5cdFx0XHRcdC8qKlxuXHRcdFx0XHQgKiB0cmlnZ2VyZWQgd2hlbiBhbiBgb3Blbl9hbGxgIGNhbGwgY29tcGxldGVzXG5cdFx0XHRcdCAqIEBldmVudFxuXHRcdFx0XHQgKiBAbmFtZSBvcGVuX2FsbC5qc3RyZWVcblx0XHRcdFx0ICogQHBhcmFtIHtPYmplY3R9IG5vZGUgdGhlIG9wZW5lZCBub2RlXG5cdFx0XHRcdCAqL1xuXHRcdFx0XHR0aGlzLnRyaWdnZXIoJ29wZW5fYWxsJywgeyBcIm5vZGVcIiA6IHRoaXMuZ2V0X25vZGUob3JpZ2luYWxfb2JqKSB9KTtcblx0XHRcdH1cblx0XHR9LFxuXHRcdC8qKlxuXHRcdCAqIGNsb3NlcyBhbGwgbm9kZXMgd2l0aGluIGEgbm9kZSAob3IgdGhlIHRyZWUpLCByZXZhbGluZyB0aGVpciBjaGlsZHJlblxuXHRcdCAqIEBuYW1lIGNsb3NlX2FsbChbb2JqLCBhbmltYXRpb25dKVxuXHRcdCAqIEBwYXJhbSB7bWl4ZWR9IG9iaiB0aGUgbm9kZSB0byBjbG9zZSByZWN1cnNpdmVseSwgb21pdCB0byBjbG9zZSBhbGwgbm9kZXMgaW4gdGhlIHRyZWVcblx0XHQgKiBAcGFyYW0ge051bWJlcn0gYW5pbWF0aW9uIHRoZSBhbmltYXRpb24gZHVyYXRpb24gaW4gbWlsbGlzZWNvbmRzIHdoZW4gY2xvc2luZyB0aGUgbm9kZXMsIHRoZSBkZWZhdWx0IGlzIG5vIGFuaW1hdGlvblxuXHRcdCAqIEB0cmlnZ2VyIGNsb3NlX2FsbC5qc3RyZWVcblx0XHQgKi9cblx0XHRjbG9zZV9hbGwgOiBmdW5jdGlvbiAob2JqLCBhbmltYXRpb24pIHtcblx0XHRcdGlmKCFvYmopIHsgb2JqID0gJC5qc3RyZWUucm9vdDsgfVxuXHRcdFx0b2JqID0gdGhpcy5nZXRfbm9kZShvYmopO1xuXHRcdFx0aWYoIW9iaikgeyByZXR1cm4gZmFsc2U7IH1cblx0XHRcdHZhciBkb20gPSBvYmouaWQgPT09ICQuanN0cmVlLnJvb3QgPyB0aGlzLmdldF9jb250YWluZXJfdWwoKSA6IHRoaXMuZ2V0X25vZGUob2JqLCB0cnVlKSxcblx0XHRcdFx0X3RoaXMgPSB0aGlzLCBpLCBqO1xuXHRcdFx0aWYoZG9tLmxlbmd0aCkge1xuXHRcdFx0XHRkb20gPSB0aGlzLmlzX29wZW4ob2JqKSA/IGRvbS5maW5kKCcuanN0cmVlLW9wZW4nKS5hZGRCYWNrKCkgOiBkb20uZmluZCgnLmpzdHJlZS1vcGVuJyk7XG5cdFx0XHRcdCQoZG9tLmdldCgpLnJldmVyc2UoKSkuZWFjaChmdW5jdGlvbiAoKSB7IF90aGlzLmNsb3NlX25vZGUodGhpcywgYW5pbWF0aW9uIHx8IDApOyB9KTtcblx0XHRcdH1cblx0XHRcdGZvcihpID0gMCwgaiA9IG9iai5jaGlsZHJlbl9kLmxlbmd0aDsgaSA8IGo7IGkrKykge1xuXHRcdFx0XHR0aGlzLl9tb2RlbC5kYXRhW29iai5jaGlsZHJlbl9kW2ldXS5zdGF0ZS5vcGVuZWQgPSBmYWxzZTtcblx0XHRcdH1cblx0XHRcdC8qKlxuXHRcdFx0ICogdHJpZ2dlcmVkIHdoZW4gYW4gYGNsb3NlX2FsbGAgY2FsbCBjb21wbGV0ZXNcblx0XHRcdCAqIEBldmVudFxuXHRcdFx0ICogQG5hbWUgY2xvc2VfYWxsLmpzdHJlZVxuXHRcdFx0ICogQHBhcmFtIHtPYmplY3R9IG5vZGUgdGhlIGNsb3NlZCBub2RlXG5cdFx0XHQgKi9cblx0XHRcdHRoaXMudHJpZ2dlcignY2xvc2VfYWxsJywgeyBcIm5vZGVcIiA6IG9iaiB9KTtcblx0XHR9LFxuXHRcdC8qKlxuXHRcdCAqIGNoZWNrcyBpZiBhIG5vZGUgaXMgZGlzYWJsZWQgKG5vdCBzZWxlY3RhYmxlKVxuXHRcdCAqIEBuYW1lIGlzX2Rpc2FibGVkKG9iailcblx0XHQgKiBAcGFyYW0gIHttaXhlZH0gb2JqXG5cdFx0ICogQHJldHVybiB7Qm9vbGVhbn1cblx0XHQgKi9cblx0XHRpc19kaXNhYmxlZCA6IGZ1bmN0aW9uIChvYmopIHtcblx0XHRcdG9iaiA9IHRoaXMuZ2V0X25vZGUob2JqKTtcblx0XHRcdHJldHVybiBvYmogJiYgb2JqLnN0YXRlICYmIG9iai5zdGF0ZS5kaXNhYmxlZDtcblx0XHR9LFxuXHRcdC8qKlxuXHRcdCAqIGVuYWJsZXMgYSBub2RlIC0gc28gdGhhdCBpdCBjYW4gYmUgc2VsZWN0ZWRcblx0XHQgKiBAbmFtZSBlbmFibGVfbm9kZShvYmopXG5cdFx0ICogQHBhcmFtIHttaXhlZH0gb2JqIHRoZSBub2RlIHRvIGVuYWJsZVxuXHRcdCAqIEB0cmlnZ2VyIGVuYWJsZV9ub2RlLmpzdHJlZVxuXHRcdCAqL1xuXHRcdGVuYWJsZV9ub2RlIDogZnVuY3Rpb24gKG9iaikge1xuXHRcdFx0dmFyIHQxLCB0Mjtcblx0XHRcdGlmKCQuaXNBcnJheShvYmopKSB7XG5cdFx0XHRcdG9iaiA9IG9iai5zbGljZSgpO1xuXHRcdFx0XHRmb3IodDEgPSAwLCB0MiA9IG9iai5sZW5ndGg7IHQxIDwgdDI7IHQxKyspIHtcblx0XHRcdFx0XHR0aGlzLmVuYWJsZV9ub2RlKG9ialt0MV0pO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fVxuXHRcdFx0b2JqID0gdGhpcy5nZXRfbm9kZShvYmopO1xuXHRcdFx0aWYoIW9iaiB8fCBvYmouaWQgPT09ICQuanN0cmVlLnJvb3QpIHtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXHRcdFx0b2JqLnN0YXRlLmRpc2FibGVkID0gZmFsc2U7XG5cdFx0XHR0aGlzLmdldF9ub2RlKG9iaix0cnVlKS5jaGlsZHJlbignLmpzdHJlZS1hbmNob3InKS5yZW1vdmVDbGFzcygnanN0cmVlLWRpc2FibGVkJykuYXR0cignYXJpYS1kaXNhYmxlZCcsIGZhbHNlKTtcblx0XHRcdC8qKlxuXHRcdFx0ICogdHJpZ2dlcmVkIHdoZW4gYW4gbm9kZSBpcyBlbmFibGVkXG5cdFx0XHQgKiBAZXZlbnRcblx0XHRcdCAqIEBuYW1lIGVuYWJsZV9ub2RlLmpzdHJlZVxuXHRcdFx0ICogQHBhcmFtIHtPYmplY3R9IG5vZGUgdGhlIGVuYWJsZWQgbm9kZVxuXHRcdFx0ICovXG5cdFx0XHR0aGlzLnRyaWdnZXIoJ2VuYWJsZV9ub2RlJywgeyAnbm9kZScgOiBvYmogfSk7XG5cdFx0fSxcblx0XHQvKipcblx0XHQgKiBkaXNhYmxlcyBhIG5vZGUgLSBzbyB0aGF0IGl0IGNhbiBub3QgYmUgc2VsZWN0ZWRcblx0XHQgKiBAbmFtZSBkaXNhYmxlX25vZGUob2JqKVxuXHRcdCAqIEBwYXJhbSB7bWl4ZWR9IG9iaiB0aGUgbm9kZSB0byBkaXNhYmxlXG5cdFx0ICogQHRyaWdnZXIgZGlzYWJsZV9ub2RlLmpzdHJlZVxuXHRcdCAqL1xuXHRcdGRpc2FibGVfbm9kZSA6IGZ1bmN0aW9uIChvYmopIHtcblx0XHRcdHZhciB0MSwgdDI7XG5cdFx0XHRpZigkLmlzQXJyYXkob2JqKSkge1xuXHRcdFx0XHRvYmogPSBvYmouc2xpY2UoKTtcblx0XHRcdFx0Zm9yKHQxID0gMCwgdDIgPSBvYmoubGVuZ3RoOyB0MSA8IHQyOyB0MSsrKSB7XG5cdFx0XHRcdFx0dGhpcy5kaXNhYmxlX25vZGUob2JqW3QxXSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9XG5cdFx0XHRvYmogPSB0aGlzLmdldF9ub2RlKG9iaik7XG5cdFx0XHRpZighb2JqIHx8IG9iai5pZCA9PT0gJC5qc3RyZWUucm9vdCkge1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cdFx0XHRvYmouc3RhdGUuZGlzYWJsZWQgPSB0cnVlO1xuXHRcdFx0dGhpcy5nZXRfbm9kZShvYmosdHJ1ZSkuY2hpbGRyZW4oJy5qc3RyZWUtYW5jaG9yJykuYWRkQ2xhc3MoJ2pzdHJlZS1kaXNhYmxlZCcpLmF0dHIoJ2FyaWEtZGlzYWJsZWQnLCB0cnVlKTtcblx0XHRcdC8qKlxuXHRcdFx0ICogdHJpZ2dlcmVkIHdoZW4gYW4gbm9kZSBpcyBkaXNhYmxlZFxuXHRcdFx0ICogQGV2ZW50XG5cdFx0XHQgKiBAbmFtZSBkaXNhYmxlX25vZGUuanN0cmVlXG5cdFx0XHQgKiBAcGFyYW0ge09iamVjdH0gbm9kZSB0aGUgZGlzYWJsZWQgbm9kZVxuXHRcdFx0ICovXG5cdFx0XHR0aGlzLnRyaWdnZXIoJ2Rpc2FibGVfbm9kZScsIHsgJ25vZGUnIDogb2JqIH0pO1xuXHRcdH0sXG5cdFx0LyoqXG5cdFx0ICogZGV0ZXJtaW5lcyBpZiBhIG5vZGUgaXMgaGlkZGVuXG5cdFx0ICogQG5hbWUgaXNfaGlkZGVuKG9iailcblx0XHQgKiBAcGFyYW0ge21peGVkfSBvYmogdGhlIG5vZGVcblx0XHQgKi9cblx0XHRpc19oaWRkZW4gOiBmdW5jdGlvbiAob2JqKSB7XG5cdFx0XHRvYmogPSB0aGlzLmdldF9ub2RlKG9iaik7XG5cdFx0XHRyZXR1cm4gb2JqLnN0YXRlLmhpZGRlbiA9PT0gdHJ1ZTtcblx0XHR9LFxuXHRcdC8qKlxuXHRcdCAqIGhpZGVzIGEgbm9kZSAtIGl0IGlzIHN0aWxsIGluIHRoZSBzdHJ1Y3R1cmUgYnV0IHdpbGwgbm90IGJlIHZpc2libGVcblx0XHQgKiBAbmFtZSBoaWRlX25vZGUob2JqKVxuXHRcdCAqIEBwYXJhbSB7bWl4ZWR9IG9iaiB0aGUgbm9kZSB0byBoaWRlXG5cdFx0ICogQHBhcmFtIHtCb29sZWFufSBza2lwX3JlZHJhdyBpbnRlcm5hbCBwYXJhbWV0ZXIgY29udHJvbGxpbmcgaWYgcmVkcmF3IGlzIGNhbGxlZFxuXHRcdCAqIEB0cmlnZ2VyIGhpZGVfbm9kZS5qc3RyZWVcblx0XHQgKi9cblx0XHRoaWRlX25vZGUgOiBmdW5jdGlvbiAob2JqLCBza2lwX3JlZHJhdykge1xuXHRcdFx0dmFyIHQxLCB0Mjtcblx0XHRcdGlmKCQuaXNBcnJheShvYmopKSB7XG5cdFx0XHRcdG9iaiA9IG9iai5zbGljZSgpO1xuXHRcdFx0XHRmb3IodDEgPSAwLCB0MiA9IG9iai5sZW5ndGg7IHQxIDwgdDI7IHQxKyspIHtcblx0XHRcdFx0XHR0aGlzLmhpZGVfbm9kZShvYmpbdDFdLCB0cnVlKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoIXNraXBfcmVkcmF3KSB7XG5cdFx0XHRcdFx0dGhpcy5yZWRyYXcoKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblx0XHRcdG9iaiA9IHRoaXMuZ2V0X25vZGUob2JqKTtcblx0XHRcdGlmKCFvYmogfHwgb2JqLmlkID09PSAkLmpzdHJlZS5yb290KSB7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblx0XHRcdGlmKCFvYmouc3RhdGUuaGlkZGVuKSB7XG5cdFx0XHRcdG9iai5zdGF0ZS5oaWRkZW4gPSB0cnVlO1xuXHRcdFx0XHR0aGlzLl9ub2RlX2NoYW5nZWQob2JqLnBhcmVudCk7XG5cdFx0XHRcdGlmKCFza2lwX3JlZHJhdykge1xuXHRcdFx0XHRcdHRoaXMucmVkcmF3KCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0LyoqXG5cdFx0XHRcdCAqIHRyaWdnZXJlZCB3aGVuIGFuIG5vZGUgaXMgaGlkZGVuXG5cdFx0XHRcdCAqIEBldmVudFxuXHRcdFx0XHQgKiBAbmFtZSBoaWRlX25vZGUuanN0cmVlXG5cdFx0XHRcdCAqIEBwYXJhbSB7T2JqZWN0fSBub2RlIHRoZSBoaWRkZW4gbm9kZVxuXHRcdFx0XHQgKi9cblx0XHRcdFx0dGhpcy50cmlnZ2VyKCdoaWRlX25vZGUnLCB7ICdub2RlJyA6IG9iaiB9KTtcblx0XHRcdH1cblx0XHR9LFxuXHRcdC8qKlxuXHRcdCAqIHNob3dzIGEgbm9kZVxuXHRcdCAqIEBuYW1lIHNob3dfbm9kZShvYmopXG5cdFx0ICogQHBhcmFtIHttaXhlZH0gb2JqIHRoZSBub2RlIHRvIHNob3dcblx0XHQgKiBAcGFyYW0ge0Jvb2xlYW59IHNraXBfcmVkcmF3IGludGVybmFsIHBhcmFtZXRlciBjb250cm9sbGluZyBpZiByZWRyYXcgaXMgY2FsbGVkXG5cdFx0ICogQHRyaWdnZXIgc2hvd19ub2RlLmpzdHJlZVxuXHRcdCAqL1xuXHRcdHNob3dfbm9kZSA6IGZ1bmN0aW9uIChvYmosIHNraXBfcmVkcmF3KSB7XG5cdFx0XHR2YXIgdDEsIHQyO1xuXHRcdFx0aWYoJC5pc0FycmF5KG9iaikpIHtcblx0XHRcdFx0b2JqID0gb2JqLnNsaWNlKCk7XG5cdFx0XHRcdGZvcih0MSA9IDAsIHQyID0gb2JqLmxlbmd0aDsgdDEgPCB0MjsgdDErKykge1xuXHRcdFx0XHRcdHRoaXMuc2hvd19ub2RlKG9ialt0MV0sIHRydWUpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICghc2tpcF9yZWRyYXcpIHtcblx0XHRcdFx0XHR0aGlzLnJlZHJhdygpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fVxuXHRcdFx0b2JqID0gdGhpcy5nZXRfbm9kZShvYmopO1xuXHRcdFx0aWYoIW9iaiB8fCBvYmouaWQgPT09ICQuanN0cmVlLnJvb3QpIHtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXHRcdFx0aWYob2JqLnN0YXRlLmhpZGRlbikge1xuXHRcdFx0XHRvYmouc3RhdGUuaGlkZGVuID0gZmFsc2U7XG5cdFx0XHRcdHRoaXMuX25vZGVfY2hhbmdlZChvYmoucGFyZW50KTtcblx0XHRcdFx0aWYoIXNraXBfcmVkcmF3KSB7XG5cdFx0XHRcdFx0dGhpcy5yZWRyYXcoKTtcblx0XHRcdFx0fVxuXHRcdFx0XHQvKipcblx0XHRcdFx0ICogdHJpZ2dlcmVkIHdoZW4gYW4gbm9kZSBpcyBzaG93blxuXHRcdFx0XHQgKiBAZXZlbnRcblx0XHRcdFx0ICogQG5hbWUgc2hvd19ub2RlLmpzdHJlZVxuXHRcdFx0XHQgKiBAcGFyYW0ge09iamVjdH0gbm9kZSB0aGUgc2hvd24gbm9kZVxuXHRcdFx0XHQgKi9cblx0XHRcdFx0dGhpcy50cmlnZ2VyKCdzaG93X25vZGUnLCB7ICdub2RlJyA6IG9iaiB9KTtcblx0XHRcdH1cblx0XHR9LFxuXHRcdC8qKlxuXHRcdCAqIGhpZGVzIGFsbCBub2Rlc1xuXHRcdCAqIEBuYW1lIGhpZGVfYWxsKClcblx0XHQgKiBAdHJpZ2dlciBoaWRlX2FsbC5qc3RyZWVcblx0XHQgKi9cblx0XHRoaWRlX2FsbCA6IGZ1bmN0aW9uIChza2lwX3JlZHJhdykge1xuXHRcdFx0dmFyIGksIG0gPSB0aGlzLl9tb2RlbC5kYXRhLCBpZHMgPSBbXTtcblx0XHRcdGZvcihpIGluIG0pIHtcblx0XHRcdFx0aWYobS5oYXNPd25Qcm9wZXJ0eShpKSAmJiBpICE9PSAkLmpzdHJlZS5yb290ICYmICFtW2ldLnN0YXRlLmhpZGRlbikge1xuXHRcdFx0XHRcdG1baV0uc3RhdGUuaGlkZGVuID0gdHJ1ZTtcblx0XHRcdFx0XHRpZHMucHVzaChpKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0dGhpcy5fbW9kZWwuZm9yY2VfZnVsbF9yZWRyYXcgPSB0cnVlO1xuXHRcdFx0aWYoIXNraXBfcmVkcmF3KSB7XG5cdFx0XHRcdHRoaXMucmVkcmF3KCk7XG5cdFx0XHR9XG5cdFx0XHQvKipcblx0XHRcdCAqIHRyaWdnZXJlZCB3aGVuIGFsbCBub2RlcyBhcmUgaGlkZGVuXG5cdFx0XHQgKiBAZXZlbnRcblx0XHRcdCAqIEBuYW1lIGhpZGVfYWxsLmpzdHJlZVxuXHRcdFx0ICogQHBhcmFtIHtBcnJheX0gbm9kZXMgdGhlIElEcyBvZiBhbGwgaGlkZGVuIG5vZGVzXG5cdFx0XHQgKi9cblx0XHRcdHRoaXMudHJpZ2dlcignaGlkZV9hbGwnLCB7ICdub2RlcycgOiBpZHMgfSk7XG5cdFx0XHRyZXR1cm4gaWRzO1xuXHRcdH0sXG5cdFx0LyoqXG5cdFx0ICogc2hvd3MgYWxsIG5vZGVzXG5cdFx0ICogQG5hbWUgc2hvd19hbGwoKVxuXHRcdCAqIEB0cmlnZ2VyIHNob3dfYWxsLmpzdHJlZVxuXHRcdCAqL1xuXHRcdHNob3dfYWxsIDogZnVuY3Rpb24gKHNraXBfcmVkcmF3KSB7XG5cdFx0XHR2YXIgaSwgbSA9IHRoaXMuX21vZGVsLmRhdGEsIGlkcyA9IFtdO1xuXHRcdFx0Zm9yKGkgaW4gbSkge1xuXHRcdFx0XHRpZihtLmhhc093blByb3BlcnR5KGkpICYmIGkgIT09ICQuanN0cmVlLnJvb3QgJiYgbVtpXS5zdGF0ZS5oaWRkZW4pIHtcblx0XHRcdFx0XHRtW2ldLnN0YXRlLmhpZGRlbiA9IGZhbHNlO1xuXHRcdFx0XHRcdGlkcy5wdXNoKGkpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHR0aGlzLl9tb2RlbC5mb3JjZV9mdWxsX3JlZHJhdyA9IHRydWU7XG5cdFx0XHRpZighc2tpcF9yZWRyYXcpIHtcblx0XHRcdFx0dGhpcy5yZWRyYXcoKTtcblx0XHRcdH1cblx0XHRcdC8qKlxuXHRcdFx0ICogdHJpZ2dlcmVkIHdoZW4gYWxsIG5vZGVzIGFyZSBzaG93blxuXHRcdFx0ICogQGV2ZW50XG5cdFx0XHQgKiBAbmFtZSBzaG93X2FsbC5qc3RyZWVcblx0XHRcdCAqIEBwYXJhbSB7QXJyYXl9IG5vZGVzIHRoZSBJRHMgb2YgYWxsIHNob3duIG5vZGVzXG5cdFx0XHQgKi9cblx0XHRcdHRoaXMudHJpZ2dlcignc2hvd19hbGwnLCB7ICdub2RlcycgOiBpZHMgfSk7XG5cdFx0XHRyZXR1cm4gaWRzO1xuXHRcdH0sXG5cdFx0LyoqXG5cdFx0ICogY2FsbGVkIHdoZW4gYSBub2RlIGlzIHNlbGVjdGVkIGJ5IHRoZSB1c2VyLiBVc2VkIGludGVybmFsbHkuXG5cdFx0ICogQHByaXZhdGVcblx0XHQgKiBAbmFtZSBhY3RpdmF0ZV9ub2RlKG9iaiwgZSlcblx0XHQgKiBAcGFyYW0ge21peGVkfSBvYmogdGhlIG5vZGVcblx0XHQgKiBAcGFyYW0ge09iamVjdH0gZSB0aGUgcmVsYXRlZCBldmVudFxuXHRcdCAqIEB0cmlnZ2VyIGFjdGl2YXRlX25vZGUuanN0cmVlLCBjaGFuZ2VkLmpzdHJlZVxuXHRcdCAqL1xuXHRcdGFjdGl2YXRlX25vZGUgOiBmdW5jdGlvbiAob2JqLCBlKSB7XG5cdFx0XHRpZih0aGlzLmlzX2Rpc2FibGVkKG9iaikpIHtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXHRcdFx0aWYoIWUgfHwgdHlwZW9mIGUgIT09ICdvYmplY3QnKSB7XG5cdFx0XHRcdGUgPSB7fTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gZW5zdXJlIGxhc3RfY2xpY2tlZCBpcyBzdGlsbCBpbiB0aGUgRE9NLCBtYWtlIGl0IGZyZXNoIChtYXliZSBpdCB3YXMgbW92ZWQ/KSBhbmQgbWFrZSBzdXJlIGl0IGlzIHN0aWxsIHNlbGVjdGVkLCBpZiBub3QgLSBtYWtlIGxhc3RfY2xpY2tlZCB0aGUgbGFzdCBzZWxlY3RlZCBub2RlXG5cdFx0XHR0aGlzLl9kYXRhLmNvcmUubGFzdF9jbGlja2VkID0gdGhpcy5fZGF0YS5jb3JlLmxhc3RfY2xpY2tlZCAmJiB0aGlzLl9kYXRhLmNvcmUubGFzdF9jbGlja2VkLmlkICE9PSB1bmRlZmluZWQgPyB0aGlzLmdldF9ub2RlKHRoaXMuX2RhdGEuY29yZS5sYXN0X2NsaWNrZWQuaWQpIDogbnVsbDtcblx0XHRcdGlmKHRoaXMuX2RhdGEuY29yZS5sYXN0X2NsaWNrZWQgJiYgIXRoaXMuX2RhdGEuY29yZS5sYXN0X2NsaWNrZWQuc3RhdGUuc2VsZWN0ZWQpIHsgdGhpcy5fZGF0YS5jb3JlLmxhc3RfY2xpY2tlZCA9IG51bGw7IH1cblx0XHRcdGlmKCF0aGlzLl9kYXRhLmNvcmUubGFzdF9jbGlja2VkICYmIHRoaXMuX2RhdGEuY29yZS5zZWxlY3RlZC5sZW5ndGgpIHsgdGhpcy5fZGF0YS5jb3JlLmxhc3RfY2xpY2tlZCA9IHRoaXMuZ2V0X25vZGUodGhpcy5fZGF0YS5jb3JlLnNlbGVjdGVkW3RoaXMuX2RhdGEuY29yZS5zZWxlY3RlZC5sZW5ndGggLSAxXSk7IH1cblxuXHRcdFx0aWYoIXRoaXMuc2V0dGluZ3MuY29yZS5tdWx0aXBsZSB8fCAoIWUubWV0YUtleSAmJiAhZS5jdHJsS2V5ICYmICFlLnNoaWZ0S2V5KSB8fCAoZS5zaGlmdEtleSAmJiAoIXRoaXMuX2RhdGEuY29yZS5sYXN0X2NsaWNrZWQgfHwgIXRoaXMuZ2V0X3BhcmVudChvYmopIHx8IHRoaXMuZ2V0X3BhcmVudChvYmopICE9PSB0aGlzLl9kYXRhLmNvcmUubGFzdF9jbGlja2VkLnBhcmVudCApICkpIHtcblx0XHRcdFx0aWYoIXRoaXMuc2V0dGluZ3MuY29yZS5tdWx0aXBsZSAmJiAoZS5tZXRhS2V5IHx8IGUuY3RybEtleSB8fCBlLnNoaWZ0S2V5KSAmJiB0aGlzLmlzX3NlbGVjdGVkKG9iaikpIHtcblx0XHRcdFx0XHR0aGlzLmRlc2VsZWN0X25vZGUob2JqLCBmYWxzZSwgZSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0dGhpcy5kZXNlbGVjdF9hbGwodHJ1ZSk7XG5cdFx0XHRcdFx0dGhpcy5zZWxlY3Rfbm9kZShvYmosIGZhbHNlLCBmYWxzZSwgZSk7XG5cdFx0XHRcdFx0dGhpcy5fZGF0YS5jb3JlLmxhc3RfY2xpY2tlZCA9IHRoaXMuZ2V0X25vZGUob2JqKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0ZWxzZSB7XG5cdFx0XHRcdGlmKGUuc2hpZnRLZXkpIHtcblx0XHRcdFx0XHR2YXIgbyA9IHRoaXMuZ2V0X25vZGUob2JqKS5pZCxcblx0XHRcdFx0XHRcdGwgPSB0aGlzLl9kYXRhLmNvcmUubGFzdF9jbGlja2VkLmlkLFxuXHRcdFx0XHRcdFx0cCA9IHRoaXMuZ2V0X25vZGUodGhpcy5fZGF0YS5jb3JlLmxhc3RfY2xpY2tlZC5wYXJlbnQpLmNoaWxkcmVuLFxuXHRcdFx0XHRcdFx0YyA9IGZhbHNlLFxuXHRcdFx0XHRcdFx0aSwgajtcblx0XHRcdFx0XHRmb3IoaSA9IDAsIGogPSBwLmxlbmd0aDsgaSA8IGo7IGkgKz0gMSkge1xuXHRcdFx0XHRcdFx0Ly8gc2VwYXJhdGUgSUZzIHdvcmsgd2hlbSBvIGFuZCBsIGFyZSB0aGUgc2FtZVxuXHRcdFx0XHRcdFx0aWYocFtpXSA9PT0gbykge1xuXHRcdFx0XHRcdFx0XHRjID0gIWM7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRpZihwW2ldID09PSBsKSB7XG5cdFx0XHRcdFx0XHRcdGMgPSAhYztcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGlmKCF0aGlzLmlzX2Rpc2FibGVkKHBbaV0pICYmIChjIHx8IHBbaV0gPT09IG8gfHwgcFtpXSA9PT0gbCkpIHtcblx0XHRcdFx0XHRcdFx0aWYgKCF0aGlzLmlzX2hpZGRlbihwW2ldKSkge1xuXHRcdFx0XHRcdFx0XHRcdHRoaXMuc2VsZWN0X25vZGUocFtpXSwgdHJ1ZSwgZmFsc2UsIGUpO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRcdFx0dGhpcy5kZXNlbGVjdF9ub2RlKHBbaV0sIHRydWUsIGUpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHR0aGlzLnRyaWdnZXIoJ2NoYW5nZWQnLCB7ICdhY3Rpb24nIDogJ3NlbGVjdF9ub2RlJywgJ25vZGUnIDogdGhpcy5nZXRfbm9kZShvYmopLCAnc2VsZWN0ZWQnIDogdGhpcy5fZGF0YS5jb3JlLnNlbGVjdGVkLCAnZXZlbnQnIDogZSB9KTtcblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRpZighdGhpcy5pc19zZWxlY3RlZChvYmopKSB7XG5cdFx0XHRcdFx0XHR0aGlzLnNlbGVjdF9ub2RlKG9iaiwgZmFsc2UsIGZhbHNlLCBlKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0XHR0aGlzLmRlc2VsZWN0X25vZGUob2JqLCBmYWxzZSwgZSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHQvKipcblx0XHRcdCAqIHRyaWdnZXJlZCB3aGVuIGFuIG5vZGUgaXMgY2xpY2tlZCBvciBpbnRlcmNhdGVkIHdpdGggYnkgdGhlIHVzZXJcblx0XHRcdCAqIEBldmVudFxuXHRcdFx0ICogQG5hbWUgYWN0aXZhdGVfbm9kZS5qc3RyZWVcblx0XHRcdCAqIEBwYXJhbSB7T2JqZWN0fSBub2RlXG5cdFx0XHQgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgdGhlIG9vcmlnaW5hbCBldmVudCAoaWYgYW55KSB3aGljaCB0cmlnZ2VyZWQgdGhlIGNhbGwgKG1heSBiZSBhbiBlbXB0eSBvYmplY3QpXG5cdFx0XHQgKi9cblx0XHRcdHRoaXMudHJpZ2dlcignYWN0aXZhdGVfbm9kZScsIHsgJ25vZGUnIDogdGhpcy5nZXRfbm9kZShvYmopLCAnZXZlbnQnIDogZSB9KTtcblx0XHR9LFxuXHRcdC8qKlxuXHRcdCAqIGFwcGxpZXMgdGhlIGhvdmVyIHN0YXRlIG9uIGEgbm9kZSwgY2FsbGVkIHdoZW4gYSBub2RlIGlzIGhvdmVyZWQgYnkgdGhlIHVzZXIuIFVzZWQgaW50ZXJuYWxseS5cblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqIEBuYW1lIGhvdmVyX25vZGUob2JqKVxuXHRcdCAqIEBwYXJhbSB7bWl4ZWR9IG9ialxuXHRcdCAqIEB0cmlnZ2VyIGhvdmVyX25vZGUuanN0cmVlXG5cdFx0ICovXG5cdFx0aG92ZXJfbm9kZSA6IGZ1bmN0aW9uIChvYmopIHtcblx0XHRcdG9iaiA9IHRoaXMuZ2V0X25vZGUob2JqLCB0cnVlKTtcblx0XHRcdGlmKCFvYmogfHwgIW9iai5sZW5ndGggfHwgb2JqLmNoaWxkcmVuKCcuanN0cmVlLWhvdmVyZWQnKS5sZW5ndGgpIHtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXHRcdFx0dmFyIG8gPSB0aGlzLmVsZW1lbnQuZmluZCgnLmpzdHJlZS1ob3ZlcmVkJyksIHQgPSB0aGlzLmVsZW1lbnQ7XG5cdFx0XHRpZihvICYmIG8ubGVuZ3RoKSB7IHRoaXMuZGVob3Zlcl9ub2RlKG8pOyB9XG5cblx0XHRcdG9iai5jaGlsZHJlbignLmpzdHJlZS1hbmNob3InKS5hZGRDbGFzcygnanN0cmVlLWhvdmVyZWQnKTtcblx0XHRcdC8qKlxuXHRcdFx0ICogdHJpZ2dlcmVkIHdoZW4gYW4gbm9kZSBpcyBob3ZlcmVkXG5cdFx0XHQgKiBAZXZlbnRcblx0XHRcdCAqIEBuYW1lIGhvdmVyX25vZGUuanN0cmVlXG5cdFx0XHQgKiBAcGFyYW0ge09iamVjdH0gbm9kZVxuXHRcdFx0ICovXG5cdFx0XHR0aGlzLnRyaWdnZXIoJ2hvdmVyX25vZGUnLCB7ICdub2RlJyA6IHRoaXMuZ2V0X25vZGUob2JqKSB9KTtcblx0XHRcdHNldFRpbWVvdXQoZnVuY3Rpb24gKCkgeyB0LmF0dHIoJ2FyaWEtYWN0aXZlZGVzY2VuZGFudCcsIG9ialswXS5pZCk7IH0sIDApO1xuXHRcdH0sXG5cdFx0LyoqXG5cdFx0ICogcmVtb3ZlcyB0aGUgaG92ZXIgc3RhdGUgZnJvbSBhIG5vZGVjYWxsZWQgd2hlbiBhIG5vZGUgaXMgbm8gbG9uZ2VyIGhvdmVyZWQgYnkgdGhlIHVzZXIuIFVzZWQgaW50ZXJuYWxseS5cblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqIEBuYW1lIGRlaG92ZXJfbm9kZShvYmopXG5cdFx0ICogQHBhcmFtIHttaXhlZH0gb2JqXG5cdFx0ICogQHRyaWdnZXIgZGVob3Zlcl9ub2RlLmpzdHJlZVxuXHRcdCAqL1xuXHRcdGRlaG92ZXJfbm9kZSA6IGZ1bmN0aW9uIChvYmopIHtcblx0XHRcdG9iaiA9IHRoaXMuZ2V0X25vZGUob2JqLCB0cnVlKTtcblx0XHRcdGlmKCFvYmogfHwgIW9iai5sZW5ndGggfHwgIW9iai5jaGlsZHJlbignLmpzdHJlZS1ob3ZlcmVkJykubGVuZ3RoKSB7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblx0XHRcdG9iai5jaGlsZHJlbignLmpzdHJlZS1hbmNob3InKS5yZW1vdmVDbGFzcygnanN0cmVlLWhvdmVyZWQnKTtcblx0XHRcdC8qKlxuXHRcdFx0ICogdHJpZ2dlcmVkIHdoZW4gYW4gbm9kZSBpcyBubyBsb25nZXIgaG92ZXJlZFxuXHRcdFx0ICogQGV2ZW50XG5cdFx0XHQgKiBAbmFtZSBkZWhvdmVyX25vZGUuanN0cmVlXG5cdFx0XHQgKiBAcGFyYW0ge09iamVjdH0gbm9kZVxuXHRcdFx0ICovXG5cdFx0XHR0aGlzLnRyaWdnZXIoJ2RlaG92ZXJfbm9kZScsIHsgJ25vZGUnIDogdGhpcy5nZXRfbm9kZShvYmopIH0pO1xuXHRcdH0sXG5cdFx0LyoqXG5cdFx0ICogc2VsZWN0IGEgbm9kZVxuXHRcdCAqIEBuYW1lIHNlbGVjdF9ub2RlKG9iaiBbLCBzdXByZXNzX2V2ZW50LCBwcmV2ZW50X29wZW5dKVxuXHRcdCAqIEBwYXJhbSB7bWl4ZWR9IG9iaiBhbiBhcnJheSBjYW4gYmUgdXNlZCB0byBzZWxlY3QgbXVsdGlwbGUgbm9kZXNcblx0XHQgKiBAcGFyYW0ge0Jvb2xlYW59IHN1cHJlc3NfZXZlbnQgaWYgc2V0IHRvIGB0cnVlYCB0aGUgYGNoYW5nZWQuanN0cmVlYCBldmVudCB3b24ndCBiZSB0cmlnZ2VyZWRcblx0XHQgKiBAcGFyYW0ge0Jvb2xlYW59IHByZXZlbnRfb3BlbiBpZiBzZXQgdG8gYHRydWVgIHBhcmVudHMgb2YgdGhlIHNlbGVjdGVkIG5vZGUgd29uJ3QgYmUgb3BlbmVkXG5cdFx0ICogQHRyaWdnZXIgc2VsZWN0X25vZGUuanN0cmVlLCBjaGFuZ2VkLmpzdHJlZVxuXHRcdCAqL1xuXHRcdHNlbGVjdF9ub2RlIDogZnVuY3Rpb24gKG9iaiwgc3VwcmVzc19ldmVudCwgcHJldmVudF9vcGVuLCBlKSB7XG5cdFx0XHR2YXIgZG9tLCB0MSwgdDIsIHRoO1xuXHRcdFx0aWYoJC5pc0FycmF5KG9iaikpIHtcblx0XHRcdFx0b2JqID0gb2JqLnNsaWNlKCk7XG5cdFx0XHRcdGZvcih0MSA9IDAsIHQyID0gb2JqLmxlbmd0aDsgdDEgPCB0MjsgdDErKykge1xuXHRcdFx0XHRcdHRoaXMuc2VsZWN0X25vZGUob2JqW3QxXSwgc3VwcmVzc19ldmVudCwgcHJldmVudF9vcGVuLCBlKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblx0XHRcdG9iaiA9IHRoaXMuZ2V0X25vZGUob2JqKTtcblx0XHRcdGlmKCFvYmogfHwgb2JqLmlkID09PSAkLmpzdHJlZS5yb290KSB7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblx0XHRcdGRvbSA9IHRoaXMuZ2V0X25vZGUob2JqLCB0cnVlKTtcblx0XHRcdGlmKCFvYmouc3RhdGUuc2VsZWN0ZWQpIHtcblx0XHRcdFx0b2JqLnN0YXRlLnNlbGVjdGVkID0gdHJ1ZTtcblx0XHRcdFx0dGhpcy5fZGF0YS5jb3JlLnNlbGVjdGVkLnB1c2gob2JqLmlkKTtcblx0XHRcdFx0aWYoIXByZXZlbnRfb3Blbikge1xuXHRcdFx0XHRcdGRvbSA9IHRoaXMuX29wZW5fdG8ob2JqKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZihkb20gJiYgZG9tLmxlbmd0aCkge1xuXHRcdFx0XHRcdGRvbS5hdHRyKCdhcmlhLXNlbGVjdGVkJywgdHJ1ZSkuY2hpbGRyZW4oJy5qc3RyZWUtYW5jaG9yJykuYWRkQ2xhc3MoJ2pzdHJlZS1jbGlja2VkJyk7XG5cdFx0XHRcdH1cblx0XHRcdFx0LyoqXG5cdFx0XHRcdCAqIHRyaWdnZXJlZCB3aGVuIGFuIG5vZGUgaXMgc2VsZWN0ZWRcblx0XHRcdFx0ICogQGV2ZW50XG5cdFx0XHRcdCAqIEBuYW1lIHNlbGVjdF9ub2RlLmpzdHJlZVxuXHRcdFx0XHQgKiBAcGFyYW0ge09iamVjdH0gbm9kZVxuXHRcdFx0XHQgKiBAcGFyYW0ge0FycmF5fSBzZWxlY3RlZCB0aGUgY3VycmVudCBzZWxlY3Rpb25cblx0XHRcdFx0ICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IHRoZSBldmVudCAoaWYgYW55KSB0aGF0IHRyaWdnZXJlZCB0aGlzIHNlbGVjdF9ub2RlXG5cdFx0XHRcdCAqL1xuXHRcdFx0XHR0aGlzLnRyaWdnZXIoJ3NlbGVjdF9ub2RlJywgeyAnbm9kZScgOiBvYmosICdzZWxlY3RlZCcgOiB0aGlzLl9kYXRhLmNvcmUuc2VsZWN0ZWQsICdldmVudCcgOiBlIH0pO1xuXHRcdFx0XHRpZighc3VwcmVzc19ldmVudCkge1xuXHRcdFx0XHRcdC8qKlxuXHRcdFx0XHRcdCAqIHRyaWdnZXJlZCB3aGVuIHNlbGVjdGlvbiBjaGFuZ2VzXG5cdFx0XHRcdFx0ICogQGV2ZW50XG5cdFx0XHRcdFx0ICogQG5hbWUgY2hhbmdlZC5qc3RyZWVcblx0XHRcdFx0XHQgKiBAcGFyYW0ge09iamVjdH0gbm9kZVxuXHRcdFx0XHRcdCAqIEBwYXJhbSB7T2JqZWN0fSBhY3Rpb24gdGhlIGFjdGlvbiB0aGF0IGNhdXNlZCB0aGUgc2VsZWN0aW9uIHRvIGNoYW5nZVxuXHRcdFx0XHRcdCAqIEBwYXJhbSB7QXJyYXl9IHNlbGVjdGVkIHRoZSBjdXJyZW50IHNlbGVjdGlvblxuXHRcdFx0XHRcdCAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCB0aGUgZXZlbnQgKGlmIGFueSkgdGhhdCB0cmlnZ2VyZWQgdGhpcyBjaGFuZ2VkIGV2ZW50XG5cdFx0XHRcdFx0ICovXG5cdFx0XHRcdFx0dGhpcy50cmlnZ2VyKCdjaGFuZ2VkJywgeyAnYWN0aW9uJyA6ICdzZWxlY3Rfbm9kZScsICdub2RlJyA6IG9iaiwgJ3NlbGVjdGVkJyA6IHRoaXMuX2RhdGEuY29yZS5zZWxlY3RlZCwgJ2V2ZW50JyA6IGUgfSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9LFxuXHRcdC8qKlxuXHRcdCAqIGRlc2VsZWN0IGEgbm9kZVxuXHRcdCAqIEBuYW1lIGRlc2VsZWN0X25vZGUob2JqIFssIHN1cHJlc3NfZXZlbnRdKVxuXHRcdCAqIEBwYXJhbSB7bWl4ZWR9IG9iaiBhbiBhcnJheSBjYW4gYmUgdXNlZCB0byBkZXNlbGVjdCBtdWx0aXBsZSBub2Rlc1xuXHRcdCAqIEBwYXJhbSB7Qm9vbGVhbn0gc3VwcmVzc19ldmVudCBpZiBzZXQgdG8gYHRydWVgIHRoZSBgY2hhbmdlZC5qc3RyZWVgIGV2ZW50IHdvbid0IGJlIHRyaWdnZXJlZFxuXHRcdCAqIEB0cmlnZ2VyIGRlc2VsZWN0X25vZGUuanN0cmVlLCBjaGFuZ2VkLmpzdHJlZVxuXHRcdCAqL1xuXHRcdGRlc2VsZWN0X25vZGUgOiBmdW5jdGlvbiAob2JqLCBzdXByZXNzX2V2ZW50LCBlKSB7XG5cdFx0XHR2YXIgdDEsIHQyLCBkb207XG5cdFx0XHRpZigkLmlzQXJyYXkob2JqKSkge1xuXHRcdFx0XHRvYmogPSBvYmouc2xpY2UoKTtcblx0XHRcdFx0Zm9yKHQxID0gMCwgdDIgPSBvYmoubGVuZ3RoOyB0MSA8IHQyOyB0MSsrKSB7XG5cdFx0XHRcdFx0dGhpcy5kZXNlbGVjdF9ub2RlKG9ialt0MV0sIHN1cHJlc3NfZXZlbnQsIGUpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fVxuXHRcdFx0b2JqID0gdGhpcy5nZXRfbm9kZShvYmopO1xuXHRcdFx0aWYoIW9iaiB8fCBvYmouaWQgPT09ICQuanN0cmVlLnJvb3QpIHtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXHRcdFx0ZG9tID0gdGhpcy5nZXRfbm9kZShvYmosIHRydWUpO1xuXHRcdFx0aWYob2JqLnN0YXRlLnNlbGVjdGVkKSB7XG5cdFx0XHRcdG9iai5zdGF0ZS5zZWxlY3RlZCA9IGZhbHNlO1xuXHRcdFx0XHR0aGlzLl9kYXRhLmNvcmUuc2VsZWN0ZWQgPSAkLnZha2F0YS5hcnJheV9yZW1vdmVfaXRlbSh0aGlzLl9kYXRhLmNvcmUuc2VsZWN0ZWQsIG9iai5pZCk7XG5cdFx0XHRcdGlmKGRvbS5sZW5ndGgpIHtcblx0XHRcdFx0XHRkb20uYXR0cignYXJpYS1zZWxlY3RlZCcsIGZhbHNlKS5jaGlsZHJlbignLmpzdHJlZS1hbmNob3InKS5yZW1vdmVDbGFzcygnanN0cmVlLWNsaWNrZWQnKTtcblx0XHRcdFx0fVxuXHRcdFx0XHQvKipcblx0XHRcdFx0ICogdHJpZ2dlcmVkIHdoZW4gYW4gbm9kZSBpcyBkZXNlbGVjdGVkXG5cdFx0XHRcdCAqIEBldmVudFxuXHRcdFx0XHQgKiBAbmFtZSBkZXNlbGVjdF9ub2RlLmpzdHJlZVxuXHRcdFx0XHQgKiBAcGFyYW0ge09iamVjdH0gbm9kZVxuXHRcdFx0XHQgKiBAcGFyYW0ge0FycmF5fSBzZWxlY3RlZCB0aGUgY3VycmVudCBzZWxlY3Rpb25cblx0XHRcdFx0ICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IHRoZSBldmVudCAoaWYgYW55KSB0aGF0IHRyaWdnZXJlZCB0aGlzIGRlc2VsZWN0X25vZGVcblx0XHRcdFx0ICovXG5cdFx0XHRcdHRoaXMudHJpZ2dlcignZGVzZWxlY3Rfbm9kZScsIHsgJ25vZGUnIDogb2JqLCAnc2VsZWN0ZWQnIDogdGhpcy5fZGF0YS5jb3JlLnNlbGVjdGVkLCAnZXZlbnQnIDogZSB9KTtcblx0XHRcdFx0aWYoIXN1cHJlc3NfZXZlbnQpIHtcblx0XHRcdFx0XHR0aGlzLnRyaWdnZXIoJ2NoYW5nZWQnLCB7ICdhY3Rpb24nIDogJ2Rlc2VsZWN0X25vZGUnLCAnbm9kZScgOiBvYmosICdzZWxlY3RlZCcgOiB0aGlzLl9kYXRhLmNvcmUuc2VsZWN0ZWQsICdldmVudCcgOiBlIH0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSxcblx0XHQvKipcblx0XHQgKiBzZWxlY3QgYWxsIG5vZGVzIGluIHRoZSB0cmVlXG5cdFx0ICogQG5hbWUgc2VsZWN0X2FsbChbc3VwcmVzc19ldmVudF0pXG5cdFx0ICogQHBhcmFtIHtCb29sZWFufSBzdXByZXNzX2V2ZW50IGlmIHNldCB0byBgdHJ1ZWAgdGhlIGBjaGFuZ2VkLmpzdHJlZWAgZXZlbnQgd29uJ3QgYmUgdHJpZ2dlcmVkXG5cdFx0ICogQHRyaWdnZXIgc2VsZWN0X2FsbC5qc3RyZWUsIGNoYW5nZWQuanN0cmVlXG5cdFx0ICovXG5cdFx0c2VsZWN0X2FsbCA6IGZ1bmN0aW9uIChzdXByZXNzX2V2ZW50KSB7XG5cdFx0XHR2YXIgdG1wID0gdGhpcy5fZGF0YS5jb3JlLnNlbGVjdGVkLmNvbmNhdChbXSksIGksIGo7XG5cdFx0XHR0aGlzLl9kYXRhLmNvcmUuc2VsZWN0ZWQgPSB0aGlzLl9tb2RlbC5kYXRhWyQuanN0cmVlLnJvb3RdLmNoaWxkcmVuX2QuY29uY2F0KCk7XG5cdFx0XHRmb3IoaSA9IDAsIGogPSB0aGlzLl9kYXRhLmNvcmUuc2VsZWN0ZWQubGVuZ3RoOyBpIDwgajsgaSsrKSB7XG5cdFx0XHRcdGlmKHRoaXMuX21vZGVsLmRhdGFbdGhpcy5fZGF0YS5jb3JlLnNlbGVjdGVkW2ldXSkge1xuXHRcdFx0XHRcdHRoaXMuX21vZGVsLmRhdGFbdGhpcy5fZGF0YS5jb3JlLnNlbGVjdGVkW2ldXS5zdGF0ZS5zZWxlY3RlZCA9IHRydWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHRoaXMucmVkcmF3KHRydWUpO1xuXHRcdFx0LyoqXG5cdFx0XHQgKiB0cmlnZ2VyZWQgd2hlbiBhbGwgbm9kZXMgYXJlIHNlbGVjdGVkXG5cdFx0XHQgKiBAZXZlbnRcblx0XHRcdCAqIEBuYW1lIHNlbGVjdF9hbGwuanN0cmVlXG5cdFx0XHQgKiBAcGFyYW0ge0FycmF5fSBzZWxlY3RlZCB0aGUgY3VycmVudCBzZWxlY3Rpb25cblx0XHRcdCAqL1xuXHRcdFx0dGhpcy50cmlnZ2VyKCdzZWxlY3RfYWxsJywgeyAnc2VsZWN0ZWQnIDogdGhpcy5fZGF0YS5jb3JlLnNlbGVjdGVkIH0pO1xuXHRcdFx0aWYoIXN1cHJlc3NfZXZlbnQpIHtcblx0XHRcdFx0dGhpcy50cmlnZ2VyKCdjaGFuZ2VkJywgeyAnYWN0aW9uJyA6ICdzZWxlY3RfYWxsJywgJ3NlbGVjdGVkJyA6IHRoaXMuX2RhdGEuY29yZS5zZWxlY3RlZCwgJ29sZF9zZWxlY3Rpb24nIDogdG1wIH0pO1xuXHRcdFx0fVxuXHRcdH0sXG5cdFx0LyoqXG5cdFx0ICogZGVzZWxlY3QgYWxsIHNlbGVjdGVkIG5vZGVzXG5cdFx0ICogQG5hbWUgZGVzZWxlY3RfYWxsKFtzdXByZXNzX2V2ZW50XSlcblx0XHQgKiBAcGFyYW0ge0Jvb2xlYW59IHN1cHJlc3NfZXZlbnQgaWYgc2V0IHRvIGB0cnVlYCB0aGUgYGNoYW5nZWQuanN0cmVlYCBldmVudCB3b24ndCBiZSB0cmlnZ2VyZWRcblx0XHQgKiBAdHJpZ2dlciBkZXNlbGVjdF9hbGwuanN0cmVlLCBjaGFuZ2VkLmpzdHJlZVxuXHRcdCAqL1xuXHRcdGRlc2VsZWN0X2FsbCA6IGZ1bmN0aW9uIChzdXByZXNzX2V2ZW50KSB7XG5cdFx0XHR2YXIgdG1wID0gdGhpcy5fZGF0YS5jb3JlLnNlbGVjdGVkLmNvbmNhdChbXSksIGksIGo7XG5cdFx0XHRmb3IoaSA9IDAsIGogPSB0aGlzLl9kYXRhLmNvcmUuc2VsZWN0ZWQubGVuZ3RoOyBpIDwgajsgaSsrKSB7XG5cdFx0XHRcdGlmKHRoaXMuX21vZGVsLmRhdGFbdGhpcy5fZGF0YS5jb3JlLnNlbGVjdGVkW2ldXSkge1xuXHRcdFx0XHRcdHRoaXMuX21vZGVsLmRhdGFbdGhpcy5fZGF0YS5jb3JlLnNlbGVjdGVkW2ldXS5zdGF0ZS5zZWxlY3RlZCA9IGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHR0aGlzLl9kYXRhLmNvcmUuc2VsZWN0ZWQgPSBbXTtcblx0XHRcdHRoaXMuZWxlbWVudC5maW5kKCcuanN0cmVlLWNsaWNrZWQnKS5yZW1vdmVDbGFzcygnanN0cmVlLWNsaWNrZWQnKS5wYXJlbnQoKS5hdHRyKCdhcmlhLXNlbGVjdGVkJywgZmFsc2UpO1xuXHRcdFx0LyoqXG5cdFx0XHQgKiB0cmlnZ2VyZWQgd2hlbiBhbGwgbm9kZXMgYXJlIGRlc2VsZWN0ZWRcblx0XHRcdCAqIEBldmVudFxuXHRcdFx0ICogQG5hbWUgZGVzZWxlY3RfYWxsLmpzdHJlZVxuXHRcdFx0ICogQHBhcmFtIHtPYmplY3R9IG5vZGUgdGhlIHByZXZpb3VzIHNlbGVjdGlvblxuXHRcdFx0ICogQHBhcmFtIHtBcnJheX0gc2VsZWN0ZWQgdGhlIGN1cnJlbnQgc2VsZWN0aW9uXG5cdFx0XHQgKi9cblx0XHRcdHRoaXMudHJpZ2dlcignZGVzZWxlY3RfYWxsJywgeyAnc2VsZWN0ZWQnIDogdGhpcy5fZGF0YS5jb3JlLnNlbGVjdGVkLCAnbm9kZScgOiB0bXAgfSk7XG5cdFx0XHRpZighc3VwcmVzc19ldmVudCkge1xuXHRcdFx0XHR0aGlzLnRyaWdnZXIoJ2NoYW5nZWQnLCB7ICdhY3Rpb24nIDogJ2Rlc2VsZWN0X2FsbCcsICdzZWxlY3RlZCcgOiB0aGlzLl9kYXRhLmNvcmUuc2VsZWN0ZWQsICdvbGRfc2VsZWN0aW9uJyA6IHRtcCB9KTtcblx0XHRcdH1cblx0XHR9LFxuXHRcdC8qKlxuXHRcdCAqIGNoZWNrcyBpZiBhIG5vZGUgaXMgc2VsZWN0ZWRcblx0XHQgKiBAbmFtZSBpc19zZWxlY3RlZChvYmopXG5cdFx0ICogQHBhcmFtICB7bWl4ZWR9ICBvYmpcblx0XHQgKiBAcmV0dXJuIHtCb29sZWFufVxuXHRcdCAqL1xuXHRcdGlzX3NlbGVjdGVkIDogZnVuY3Rpb24gKG9iaikge1xuXHRcdFx0b2JqID0gdGhpcy5nZXRfbm9kZShvYmopO1xuXHRcdFx0aWYoIW9iaiB8fCBvYmouaWQgPT09ICQuanN0cmVlLnJvb3QpIHtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG9iai5zdGF0ZS5zZWxlY3RlZDtcblx0XHR9LFxuXHRcdC8qKlxuXHRcdCAqIGdldCBhbiBhcnJheSBvZiBhbGwgc2VsZWN0ZWQgbm9kZXNcblx0XHQgKiBAbmFtZSBnZXRfc2VsZWN0ZWQoW2Z1bGxdKVxuXHRcdCAqIEBwYXJhbSAge21peGVkfSAgZnVsbCBpZiBzZXQgdG8gYHRydWVgIHRoZSByZXR1cm5lZCBhcnJheSB3aWxsIGNvbnNpc3Qgb2YgdGhlIGZ1bGwgbm9kZSBvYmplY3RzLCBvdGhlcndpc2UgLSBvbmx5IElEcyB3aWxsIGJlIHJldHVybmVkXG5cdFx0ICogQHJldHVybiB7QXJyYXl9XG5cdFx0ICovXG5cdFx0Z2V0X3NlbGVjdGVkIDogZnVuY3Rpb24gKGZ1bGwpIHtcblx0XHRcdHJldHVybiBmdWxsID8gJC5tYXAodGhpcy5fZGF0YS5jb3JlLnNlbGVjdGVkLCAkLnByb3h5KGZ1bmN0aW9uIChpKSB7IHJldHVybiB0aGlzLmdldF9ub2RlKGkpOyB9LCB0aGlzKSkgOiB0aGlzLl9kYXRhLmNvcmUuc2VsZWN0ZWQuc2xpY2UoKTtcblx0XHR9LFxuXHRcdC8qKlxuXHRcdCAqIGdldCBhbiBhcnJheSBvZiBhbGwgdG9wIGxldmVsIHNlbGVjdGVkIG5vZGVzIChpZ25vcmluZyBjaGlsZHJlbiBvZiBzZWxlY3RlZCBub2Rlcylcblx0XHQgKiBAbmFtZSBnZXRfdG9wX3NlbGVjdGVkKFtmdWxsXSlcblx0XHQgKiBAcGFyYW0gIHttaXhlZH0gIGZ1bGwgaWYgc2V0IHRvIGB0cnVlYCB0aGUgcmV0dXJuZWQgYXJyYXkgd2lsbCBjb25zaXN0IG9mIHRoZSBmdWxsIG5vZGUgb2JqZWN0cywgb3RoZXJ3aXNlIC0gb25seSBJRHMgd2lsbCBiZSByZXR1cm5lZFxuXHRcdCAqIEByZXR1cm4ge0FycmF5fVxuXHRcdCAqL1xuXHRcdGdldF90b3Bfc2VsZWN0ZWQgOiBmdW5jdGlvbiAoZnVsbCkge1xuXHRcdFx0dmFyIHRtcCA9IHRoaXMuZ2V0X3NlbGVjdGVkKHRydWUpLFxuXHRcdFx0XHRvYmogPSB7fSwgaSwgaiwgaywgbDtcblx0XHRcdGZvcihpID0gMCwgaiA9IHRtcC5sZW5ndGg7IGkgPCBqOyBpKyspIHtcblx0XHRcdFx0b2JqW3RtcFtpXS5pZF0gPSB0bXBbaV07XG5cdFx0XHR9XG5cdFx0XHRmb3IoaSA9IDAsIGogPSB0bXAubGVuZ3RoOyBpIDwgajsgaSsrKSB7XG5cdFx0XHRcdGZvcihrID0gMCwgbCA9IHRtcFtpXS5jaGlsZHJlbl9kLmxlbmd0aDsgayA8IGw7IGsrKykge1xuXHRcdFx0XHRcdGlmKG9ialt0bXBbaV0uY2hpbGRyZW5fZFtrXV0pIHtcblx0XHRcdFx0XHRcdGRlbGV0ZSBvYmpbdG1wW2ldLmNoaWxkcmVuX2Rba11dO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0dG1wID0gW107XG5cdFx0XHRmb3IoaSBpbiBvYmopIHtcblx0XHRcdFx0aWYob2JqLmhhc093blByb3BlcnR5KGkpKSB7XG5cdFx0XHRcdFx0dG1wLnB1c2goaSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiBmdWxsID8gJC5tYXAodG1wLCAkLnByb3h5KGZ1bmN0aW9uIChpKSB7IHJldHVybiB0aGlzLmdldF9ub2RlKGkpOyB9LCB0aGlzKSkgOiB0bXA7XG5cdFx0fSxcblx0XHQvKipcblx0XHQgKiBnZXQgYW4gYXJyYXkgb2YgYWxsIGJvdHRvbSBsZXZlbCBzZWxlY3RlZCBub2RlcyAoaWdub3Jpbmcgc2VsZWN0ZWQgcGFyZW50cylcblx0XHQgKiBAbmFtZSBnZXRfYm90dG9tX3NlbGVjdGVkKFtmdWxsXSlcblx0XHQgKiBAcGFyYW0gIHttaXhlZH0gIGZ1bGwgaWYgc2V0IHRvIGB0cnVlYCB0aGUgcmV0dXJuZWQgYXJyYXkgd2lsbCBjb25zaXN0IG9mIHRoZSBmdWxsIG5vZGUgb2JqZWN0cywgb3RoZXJ3aXNlIC0gb25seSBJRHMgd2lsbCBiZSByZXR1cm5lZFxuXHRcdCAqIEByZXR1cm4ge0FycmF5fVxuXHRcdCAqL1xuXHRcdGdldF9ib3R0b21fc2VsZWN0ZWQgOiBmdW5jdGlvbiAoZnVsbCkge1xuXHRcdFx0dmFyIHRtcCA9IHRoaXMuZ2V0X3NlbGVjdGVkKHRydWUpLFxuXHRcdFx0XHRvYmogPSBbXSwgaSwgajtcblx0XHRcdGZvcihpID0gMCwgaiA9IHRtcC5sZW5ndGg7IGkgPCBqOyBpKyspIHtcblx0XHRcdFx0aWYoIXRtcFtpXS5jaGlsZHJlbi5sZW5ndGgpIHtcblx0XHRcdFx0XHRvYmoucHVzaCh0bXBbaV0uaWQpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gZnVsbCA/ICQubWFwKG9iaiwgJC5wcm94eShmdW5jdGlvbiAoaSkgeyByZXR1cm4gdGhpcy5nZXRfbm9kZShpKTsgfSwgdGhpcykpIDogb2JqO1xuXHRcdH0sXG5cdFx0LyoqXG5cdFx0ICogZ2V0cyB0aGUgY3VycmVudCBzdGF0ZSBvZiB0aGUgdHJlZSBzbyB0aGF0IGl0IGNhbiBiZSByZXN0b3JlZCBsYXRlciB3aXRoIGBzZXRfc3RhdGUoc3RhdGUpYC4gVXNlZCBpbnRlcm5hbGx5LlxuXHRcdCAqIEBuYW1lIGdldF9zdGF0ZSgpXG5cdFx0ICogQHByaXZhdGVcblx0XHQgKiBAcmV0dXJuIHtPYmplY3R9XG5cdFx0ICovXG5cdFx0Z2V0X3N0YXRlIDogZnVuY3Rpb24gKCkge1xuXHRcdFx0dmFyIHN0YXRlXHQ9IHtcblx0XHRcdFx0J2NvcmUnIDoge1xuXHRcdFx0XHRcdCdvcGVuJyA6IFtdLFxuXHRcdFx0XHRcdCdzY3JvbGwnIDoge1xuXHRcdFx0XHRcdFx0J2xlZnQnIDogdGhpcy5lbGVtZW50LnNjcm9sbExlZnQoKSxcblx0XHRcdFx0XHRcdCd0b3AnIDogdGhpcy5lbGVtZW50LnNjcm9sbFRvcCgpXG5cdFx0XHRcdFx0fSxcblx0XHRcdFx0XHQvKiFcblx0XHRcdFx0XHQndGhlbWVzJyA6IHtcblx0XHRcdFx0XHRcdCduYW1lJyA6IHRoaXMuZ2V0X3RoZW1lKCksXG5cdFx0XHRcdFx0XHQnaWNvbnMnIDogdGhpcy5fZGF0YS5jb3JlLnRoZW1lcy5pY29ucyxcblx0XHRcdFx0XHRcdCdkb3RzJyA6IHRoaXMuX2RhdGEuY29yZS50aGVtZXMuZG90c1xuXHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0Ki9cblx0XHRcdFx0XHQnc2VsZWN0ZWQnIDogW11cblx0XHRcdFx0fVxuXHRcdFx0fSwgaTtcblx0XHRcdGZvcihpIGluIHRoaXMuX21vZGVsLmRhdGEpIHtcblx0XHRcdFx0aWYodGhpcy5fbW9kZWwuZGF0YS5oYXNPd25Qcm9wZXJ0eShpKSkge1xuXHRcdFx0XHRcdGlmKGkgIT09ICQuanN0cmVlLnJvb3QpIHtcblx0XHRcdFx0XHRcdGlmKHRoaXMuX21vZGVsLmRhdGFbaV0uc3RhdGUub3BlbmVkKSB7XG5cdFx0XHRcdFx0XHRcdHN0YXRlLmNvcmUub3Blbi5wdXNoKGkpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0aWYodGhpcy5fbW9kZWwuZGF0YVtpXS5zdGF0ZS5zZWxlY3RlZCkge1xuXHRcdFx0XHRcdFx0XHRzdGF0ZS5jb3JlLnNlbGVjdGVkLnB1c2goaSk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gc3RhdGU7XG5cdFx0fSxcblx0XHQvKipcblx0XHQgKiBzZXRzIHRoZSBzdGF0ZSBvZiB0aGUgdHJlZS4gVXNlZCBpbnRlcm5hbGx5LlxuXHRcdCAqIEBuYW1lIHNldF9zdGF0ZShzdGF0ZSBbLCBjYWxsYmFja10pXG5cdFx0ICogQHByaXZhdGVcblx0XHQgKiBAcGFyYW0ge09iamVjdH0gc3RhdGUgdGhlIHN0YXRlIHRvIHJlc3RvcmUuIEtlZXAgaW4gbWluZCB0aGlzIG9iamVjdCBpcyBwYXNzZWQgYnkgcmVmZXJlbmNlIGFuZCBqc3RyZWUgd2lsbCBtb2RpZnkgaXQuXG5cdFx0ICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgYW4gb3B0aW9uYWwgZnVuY3Rpb24gdG8gZXhlY3V0ZSBvbmNlIHRoZSBzdGF0ZSBpcyByZXN0b3JlZC5cblx0XHQgKiBAdHJpZ2dlciBzZXRfc3RhdGUuanN0cmVlXG5cdFx0ICovXG5cdFx0c2V0X3N0YXRlIDogZnVuY3Rpb24gKHN0YXRlLCBjYWxsYmFjaykge1xuXHRcdFx0aWYoc3RhdGUpIHtcblx0XHRcdFx0aWYoc3RhdGUuY29yZSkge1xuXHRcdFx0XHRcdHZhciByZXMsIG4sIHQsIF90aGlzLCBpO1xuXHRcdFx0XHRcdGlmKHN0YXRlLmNvcmUub3Blbikge1xuXHRcdFx0XHRcdFx0aWYoISQuaXNBcnJheShzdGF0ZS5jb3JlLm9wZW4pIHx8ICFzdGF0ZS5jb3JlLm9wZW4ubGVuZ3RoKSB7XG5cdFx0XHRcdFx0XHRcdGRlbGV0ZSBzdGF0ZS5jb3JlLm9wZW47XG5cdFx0XHRcdFx0XHRcdHRoaXMuc2V0X3N0YXRlKHN0YXRlLCBjYWxsYmFjayk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRcdFx0dGhpcy5fbG9hZF9ub2RlcyhzdGF0ZS5jb3JlLm9wZW4sIGZ1bmN0aW9uIChub2Rlcykge1xuXHRcdFx0XHRcdFx0XHRcdHRoaXMub3Blbl9ub2RlKG5vZGVzLCBmYWxzZSwgMCk7XG5cdFx0XHRcdFx0XHRcdFx0ZGVsZXRlIHN0YXRlLmNvcmUub3Blbjtcblx0XHRcdFx0XHRcdFx0XHR0aGlzLnNldF9zdGF0ZShzdGF0ZSwgY2FsbGJhY2spO1xuXHRcdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYoc3RhdGUuY29yZS5zY3JvbGwpIHtcblx0XHRcdFx0XHRcdGlmKHN0YXRlLmNvcmUuc2Nyb2xsICYmIHN0YXRlLmNvcmUuc2Nyb2xsLmxlZnQgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRcdFx0XHR0aGlzLmVsZW1lbnQuc2Nyb2xsTGVmdChzdGF0ZS5jb3JlLnNjcm9sbC5sZWZ0KTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGlmKHN0YXRlLmNvcmUuc2Nyb2xsICYmIHN0YXRlLmNvcmUuc2Nyb2xsLnRvcCAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdFx0XHRcdHRoaXMuZWxlbWVudC5zY3JvbGxUb3Aoc3RhdGUuY29yZS5zY3JvbGwudG9wKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGRlbGV0ZSBzdGF0ZS5jb3JlLnNjcm9sbDtcblx0XHRcdFx0XHRcdHRoaXMuc2V0X3N0YXRlKHN0YXRlLCBjYWxsYmFjayk7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmKHN0YXRlLmNvcmUuc2VsZWN0ZWQpIHtcblx0XHRcdFx0XHRcdF90aGlzID0gdGhpcztcblx0XHRcdFx0XHRcdHRoaXMuZGVzZWxlY3RfYWxsKCk7XG5cdFx0XHRcdFx0XHQkLmVhY2goc3RhdGUuY29yZS5zZWxlY3RlZCwgZnVuY3Rpb24gKGksIHYpIHtcblx0XHRcdFx0XHRcdFx0X3RoaXMuc2VsZWN0X25vZGUodiwgZmFsc2UsIHRydWUpO1xuXHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0XHRkZWxldGUgc3RhdGUuY29yZS5zZWxlY3RlZDtcblx0XHRcdFx0XHRcdHRoaXMuc2V0X3N0YXRlKHN0YXRlLCBjYWxsYmFjayk7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGZvcihpIGluIHN0YXRlKSB7XG5cdFx0XHRcdFx0XHRpZihzdGF0ZS5oYXNPd25Qcm9wZXJ0eShpKSAmJiBpICE9PSBcImNvcmVcIiAmJiAkLmluQXJyYXkoaSwgdGhpcy5zZXR0aW5ncy5wbHVnaW5zKSA9PT0gLTEpIHtcblx0XHRcdFx0XHRcdFx0ZGVsZXRlIHN0YXRlW2ldO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZigkLmlzRW1wdHlPYmplY3Qoc3RhdGUuY29yZSkpIHtcblx0XHRcdFx0XHRcdGRlbGV0ZSBzdGF0ZS5jb3JlO1xuXHRcdFx0XHRcdFx0dGhpcy5zZXRfc3RhdGUoc3RhdGUsIGNhbGxiYWNrKTtcblx0XHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYoJC5pc0VtcHR5T2JqZWN0KHN0YXRlKSkge1xuXHRcdFx0XHRcdHN0YXRlID0gbnVsbDtcblx0XHRcdFx0XHRpZihjYWxsYmFjaykgeyBjYWxsYmFjay5jYWxsKHRoaXMpOyB9XG5cdFx0XHRcdFx0LyoqXG5cdFx0XHRcdFx0ICogdHJpZ2dlcmVkIHdoZW4gYSBgc2V0X3N0YXRlYCBjYWxsIGNvbXBsZXRlc1xuXHRcdFx0XHRcdCAqIEBldmVudFxuXHRcdFx0XHRcdCAqIEBuYW1lIHNldF9zdGF0ZS5qc3RyZWVcblx0XHRcdFx0XHQgKi9cblx0XHRcdFx0XHR0aGlzLnRyaWdnZXIoJ3NldF9zdGF0ZScpO1xuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9LFxuXHRcdC8qKlxuXHRcdCAqIHJlZnJlc2hlcyB0aGUgdHJlZSAtIGFsbCBub2RlcyBhcmUgcmVsb2FkZWQgd2l0aCBjYWxscyB0byBgbG9hZF9ub2RlYC5cblx0XHQgKiBAbmFtZSByZWZyZXNoKClcblx0XHQgKiBAcGFyYW0ge0Jvb2xlYW59IHNraXBfbG9hZGluZyBhbiBvcHRpb24gdG8gc2tpcCBzaG93aW5nIHRoZSBsb2FkaW5nIGluZGljYXRvclxuXHRcdCAqIEBwYXJhbSB7TWl4ZWR9IGZvcmdldF9zdGF0ZSBpZiBzZXQgdG8gYHRydWVgIHN0YXRlIHdpbGwgbm90IGJlIHJlYXBwbGllZCwgaWYgc2V0IHRvIGEgZnVuY3Rpb24gKHJlY2VpdmluZyB0aGUgY3VycmVudCBzdGF0ZSBhcyBhcmd1bWVudCkgdGhlIHJlc3VsdCBvZiB0aGF0IGZ1bmN0aW9uIHdpbGwgYmUgdXNlZCBhcyBzdGF0ZVxuXHRcdCAqIEB0cmlnZ2VyIHJlZnJlc2guanN0cmVlXG5cdFx0ICovXG5cdFx0cmVmcmVzaCA6IGZ1bmN0aW9uIChza2lwX2xvYWRpbmcsIGZvcmdldF9zdGF0ZSkge1xuXHRcdFx0dGhpcy5fZGF0YS5jb3JlLnN0YXRlID0gZm9yZ2V0X3N0YXRlID09PSB0cnVlID8ge30gOiB0aGlzLmdldF9zdGF0ZSgpO1xuXHRcdFx0aWYoZm9yZ2V0X3N0YXRlICYmICQuaXNGdW5jdGlvbihmb3JnZXRfc3RhdGUpKSB7IHRoaXMuX2RhdGEuY29yZS5zdGF0ZSA9IGZvcmdldF9zdGF0ZS5jYWxsKHRoaXMsIHRoaXMuX2RhdGEuY29yZS5zdGF0ZSk7IH1cblx0XHRcdHRoaXMuX2NudCA9IDA7XG5cdFx0XHR0aGlzLl9tb2RlbC5kYXRhID0ge307XG5cdFx0XHR0aGlzLl9tb2RlbC5kYXRhWyQuanN0cmVlLnJvb3RdID0ge1xuXHRcdFx0XHRpZCA6ICQuanN0cmVlLnJvb3QsXG5cdFx0XHRcdHBhcmVudCA6IG51bGwsXG5cdFx0XHRcdHBhcmVudHMgOiBbXSxcblx0XHRcdFx0Y2hpbGRyZW4gOiBbXSxcblx0XHRcdFx0Y2hpbGRyZW5fZCA6IFtdLFxuXHRcdFx0XHRzdGF0ZSA6IHsgbG9hZGVkIDogZmFsc2UgfVxuXHRcdFx0fTtcblx0XHRcdHRoaXMuX2RhdGEuY29yZS5zZWxlY3RlZCA9IFtdO1xuXHRcdFx0dGhpcy5fZGF0YS5jb3JlLmxhc3RfY2xpY2tlZCA9IG51bGw7XG5cdFx0XHR0aGlzLl9kYXRhLmNvcmUuZm9jdXNlZCA9IG51bGw7XG5cblx0XHRcdHZhciBjID0gdGhpcy5nZXRfY29udGFpbmVyX3VsKClbMF0uY2xhc3NOYW1lO1xuXHRcdFx0aWYoIXNraXBfbG9hZGluZykge1xuXHRcdFx0XHR0aGlzLmVsZW1lbnQuaHRtbChcIjxcIitcInVsIGNsYXNzPSdcIitjK1wiJyByb2xlPSdncm91cCc+PFwiK1wibGkgY2xhc3M9J2pzdHJlZS1pbml0aWFsLW5vZGUganN0cmVlLWxvYWRpbmcganN0cmVlLWxlYWYganN0cmVlLWxhc3QnIHJvbGU9J3RyZWVpdGVtJyBpZD0nalwiK3RoaXMuX2lkK1wiX2xvYWRpbmcnPjxpIGNsYXNzPSdqc3RyZWUtaWNvbiBqc3RyZWUtb2NsJz48L2k+PFwiK1wiYSBjbGFzcz0nanN0cmVlLWFuY2hvcicgaHJlZj0nIyc+PGkgY2xhc3M9J2pzdHJlZS1pY29uIGpzdHJlZS10aGVtZWljb24taGlkZGVuJz48L2k+XCIgKyB0aGlzLmdldF9zdHJpbmcoXCJMb2FkaW5nIC4uLlwiKSArIFwiPC9hPjwvbGk+PC91bD5cIik7XG5cdFx0XHRcdHRoaXMuZWxlbWVudC5hdHRyKCdhcmlhLWFjdGl2ZWRlc2NlbmRhbnQnLCdqJyt0aGlzLl9pZCsnX2xvYWRpbmcnKTtcblx0XHRcdH1cblx0XHRcdHRoaXMubG9hZF9ub2RlKCQuanN0cmVlLnJvb3QsIGZ1bmN0aW9uIChvLCBzKSB7XG5cdFx0XHRcdGlmKHMpIHtcblx0XHRcdFx0XHR0aGlzLmdldF9jb250YWluZXJfdWwoKVswXS5jbGFzc05hbWUgPSBjO1xuXHRcdFx0XHRcdGlmKHRoaXMuX2ZpcnN0Q2hpbGQodGhpcy5nZXRfY29udGFpbmVyX3VsKClbMF0pKSB7XG5cdFx0XHRcdFx0XHR0aGlzLmVsZW1lbnQuYXR0cignYXJpYS1hY3RpdmVkZXNjZW5kYW50Jyx0aGlzLl9maXJzdENoaWxkKHRoaXMuZ2V0X2NvbnRhaW5lcl91bCgpWzBdKS5pZCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHRoaXMuc2V0X3N0YXRlKCQuZXh0ZW5kKHRydWUsIHt9LCB0aGlzLl9kYXRhLmNvcmUuc3RhdGUpLCBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdFx0XHQvKipcblx0XHRcdFx0XHRcdCAqIHRyaWdnZXJlZCB3aGVuIGEgYHJlZnJlc2hgIGNhbGwgY29tcGxldGVzXG5cdFx0XHRcdFx0XHQgKiBAZXZlbnRcblx0XHRcdFx0XHRcdCAqIEBuYW1lIHJlZnJlc2guanN0cmVlXG5cdFx0XHRcdFx0XHQgKi9cblx0XHRcdFx0XHRcdHRoaXMudHJpZ2dlcigncmVmcmVzaCcpO1xuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRoaXMuX2RhdGEuY29yZS5zdGF0ZSA9IG51bGw7XG5cdFx0XHR9KTtcblx0XHR9LFxuXHRcdC8qKlxuXHRcdCAqIHJlZnJlc2hlcyBhIG5vZGUgaW4gdGhlIHRyZWUgKHJlbG9hZCBpdHMgY2hpbGRyZW4pIGFsbCBvcGVuZWQgbm9kZXMgaW5zaWRlIHRoYXQgbm9kZSBhcmUgcmVsb2FkZWQgd2l0aCBjYWxscyB0byBgbG9hZF9ub2RlYC5cblx0XHQgKiBAbmFtZSByZWZyZXNoX25vZGUob2JqKVxuXHRcdCAqIEBwYXJhbSAge21peGVkfSBvYmogdGhlIG5vZGVcblx0XHQgKiBAdHJpZ2dlciByZWZyZXNoX25vZGUuanN0cmVlXG5cdFx0ICovXG5cdFx0cmVmcmVzaF9ub2RlIDogZnVuY3Rpb24gKG9iaikge1xuXHRcdFx0b2JqID0gdGhpcy5nZXRfbm9kZShvYmopO1xuXHRcdFx0aWYoIW9iaiB8fCBvYmouaWQgPT09ICQuanN0cmVlLnJvb3QpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdFx0XHR2YXIgb3BlbmVkID0gW10sIHRvX2xvYWQgPSBbXSwgcyA9IHRoaXMuX2RhdGEuY29yZS5zZWxlY3RlZC5jb25jYXQoW10pO1xuXHRcdFx0dG9fbG9hZC5wdXNoKG9iai5pZCk7XG5cdFx0XHRpZihvYmouc3RhdGUub3BlbmVkID09PSB0cnVlKSB7IG9wZW5lZC5wdXNoKG9iai5pZCk7IH1cblx0XHRcdHRoaXMuZ2V0X25vZGUob2JqLCB0cnVlKS5maW5kKCcuanN0cmVlLW9wZW4nKS5lYWNoKGZ1bmN0aW9uKCkgeyB0b19sb2FkLnB1c2godGhpcy5pZCk7IG9wZW5lZC5wdXNoKHRoaXMuaWQpOyB9KTtcblx0XHRcdHRoaXMuX2xvYWRfbm9kZXModG9fbG9hZCwgJC5wcm94eShmdW5jdGlvbiAobm9kZXMpIHtcblx0XHRcdFx0dGhpcy5vcGVuX25vZGUob3BlbmVkLCBmYWxzZSwgMCk7XG5cdFx0XHRcdHRoaXMuc2VsZWN0X25vZGUocyk7XG5cdFx0XHRcdC8qKlxuXHRcdFx0XHQgKiB0cmlnZ2VyZWQgd2hlbiBhIG5vZGUgaXMgcmVmcmVzaGVkXG5cdFx0XHRcdCAqIEBldmVudFxuXHRcdFx0XHQgKiBAbmFtZSByZWZyZXNoX25vZGUuanN0cmVlXG5cdFx0XHRcdCAqIEBwYXJhbSB7T2JqZWN0fSBub2RlIC0gdGhlIHJlZnJlc2hlZCBub2RlXG5cdFx0XHRcdCAqIEBwYXJhbSB7QXJyYXl9IG5vZGVzIC0gYW4gYXJyYXkgb2YgdGhlIElEcyBvZiB0aGUgbm9kZXMgdGhhdCB3ZXJlIHJlbG9hZGVkXG5cdFx0XHRcdCAqL1xuXHRcdFx0XHR0aGlzLnRyaWdnZXIoJ3JlZnJlc2hfbm9kZScsIHsgJ25vZGUnIDogb2JqLCAnbm9kZXMnIDogbm9kZXMgfSk7XG5cdFx0XHR9LCB0aGlzKSwgZmFsc2UsIHRydWUpO1xuXHRcdH0sXG5cdFx0LyoqXG5cdFx0ICogc2V0IChjaGFuZ2UpIHRoZSBJRCBvZiBhIG5vZGVcblx0XHQgKiBAbmFtZSBzZXRfaWQob2JqLCBpZClcblx0XHQgKiBAcGFyYW0gIHttaXhlZH0gb2JqIHRoZSBub2RlXG5cdFx0ICogQHBhcmFtICB7U3RyaW5nfSBpZCB0aGUgbmV3IElEXG5cdFx0ICogQHJldHVybiB7Qm9vbGVhbn1cblx0XHQgKiBAdHJpZ2dlciBzZXRfaWQuanN0cmVlXG5cdFx0ICovXG5cdFx0c2V0X2lkIDogZnVuY3Rpb24gKG9iaiwgaWQpIHtcblx0XHRcdG9iaiA9IHRoaXMuZ2V0X25vZGUob2JqKTtcblx0XHRcdGlmKCFvYmogfHwgb2JqLmlkID09PSAkLmpzdHJlZS5yb290KSB7IHJldHVybiBmYWxzZTsgfVxuXHRcdFx0dmFyIGksIGosIG0gPSB0aGlzLl9tb2RlbC5kYXRhLCBvbGQgPSBvYmouaWQ7XG5cdFx0XHRpZCA9IGlkLnRvU3RyaW5nKCk7XG5cdFx0XHQvLyB1cGRhdGUgcGFyZW50cyAocmVwbGFjZSBjdXJyZW50IElEIHdpdGggbmV3IG9uZSBpbiBjaGlsZHJlbiBhbmQgY2hpbGRyZW5fZClcblx0XHRcdG1bb2JqLnBhcmVudF0uY2hpbGRyZW5bJC5pbkFycmF5KG9iai5pZCwgbVtvYmoucGFyZW50XS5jaGlsZHJlbildID0gaWQ7XG5cdFx0XHRmb3IoaSA9IDAsIGogPSBvYmoucGFyZW50cy5sZW5ndGg7IGkgPCBqOyBpKyspIHtcblx0XHRcdFx0bVtvYmoucGFyZW50c1tpXV0uY2hpbGRyZW5fZFskLmluQXJyYXkob2JqLmlkLCBtW29iai5wYXJlbnRzW2ldXS5jaGlsZHJlbl9kKV0gPSBpZDtcblx0XHRcdH1cblx0XHRcdC8vIHVwZGF0ZSBjaGlsZHJlbiAocmVwbGFjZSBjdXJyZW50IElEIHdpdGggbmV3IG9uZSBpbiBwYXJlbnQgYW5kIHBhcmVudHMpXG5cdFx0XHRmb3IoaSA9IDAsIGogPSBvYmouY2hpbGRyZW4ubGVuZ3RoOyBpIDwgajsgaSsrKSB7XG5cdFx0XHRcdG1bb2JqLmNoaWxkcmVuW2ldXS5wYXJlbnQgPSBpZDtcblx0XHRcdH1cblx0XHRcdGZvcihpID0gMCwgaiA9IG9iai5jaGlsZHJlbl9kLmxlbmd0aDsgaSA8IGo7IGkrKykge1xuXHRcdFx0XHRtW29iai5jaGlsZHJlbl9kW2ldXS5wYXJlbnRzWyQuaW5BcnJheShvYmouaWQsIG1bb2JqLmNoaWxkcmVuX2RbaV1dLnBhcmVudHMpXSA9IGlkO1xuXHRcdFx0fVxuXHRcdFx0aSA9ICQuaW5BcnJheShvYmouaWQsIHRoaXMuX2RhdGEuY29yZS5zZWxlY3RlZCk7XG5cdFx0XHRpZihpICE9PSAtMSkgeyB0aGlzLl9kYXRhLmNvcmUuc2VsZWN0ZWRbaV0gPSBpZDsgfVxuXHRcdFx0Ly8gdXBkYXRlIG1vZGVsIGFuZCBvYmogaXRzZWxmIChvYmouaWQsIHRoaXMuX21vZGVsLmRhdGFbS0VZXSlcblx0XHRcdGkgPSB0aGlzLmdldF9ub2RlKG9iai5pZCwgdHJ1ZSk7XG5cdFx0XHRpZihpKSB7XG5cdFx0XHRcdGkuYXR0cignaWQnLCBpZCk7IC8vLmNoaWxkcmVuKCcuanN0cmVlLWFuY2hvcicpLmF0dHIoJ2lkJywgaWQgKyAnX2FuY2hvcicpLmVuZCgpLmF0dHIoJ2FyaWEtbGFiZWxsZWRieScsIGlkICsgJ19hbmNob3InKTtcblx0XHRcdFx0aWYodGhpcy5lbGVtZW50LmF0dHIoJ2FyaWEtYWN0aXZlZGVzY2VuZGFudCcpID09PSBvYmouaWQpIHtcblx0XHRcdFx0XHR0aGlzLmVsZW1lbnQuYXR0cignYXJpYS1hY3RpdmVkZXNjZW5kYW50JywgaWQpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRkZWxldGUgbVtvYmouaWRdO1xuXHRcdFx0b2JqLmlkID0gaWQ7XG5cdFx0XHRvYmoubGlfYXR0ci5pZCA9IGlkO1xuXHRcdFx0bVtpZF0gPSBvYmo7XG5cdFx0XHQvKipcblx0XHRcdCAqIHRyaWdnZXJlZCB3aGVuIGEgbm9kZSBpZCB2YWx1ZSBpcyBjaGFuZ2VkXG5cdFx0XHQgKiBAZXZlbnRcblx0XHRcdCAqIEBuYW1lIHNldF9pZC5qc3RyZWVcblx0XHRcdCAqIEBwYXJhbSB7T2JqZWN0fSBub2RlXG5cdFx0XHQgKiBAcGFyYW0ge1N0cmluZ30gb2xkIHRoZSBvbGQgaWRcblx0XHRcdCAqL1xuXHRcdFx0dGhpcy50cmlnZ2VyKCdzZXRfaWQnLHsgXCJub2RlXCIgOiBvYmosIFwibmV3XCIgOiBvYmouaWQsIFwib2xkXCIgOiBvbGQgfSk7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9LFxuXHRcdC8qKlxuXHRcdCAqIGdldCB0aGUgdGV4dCB2YWx1ZSBvZiBhIG5vZGVcblx0XHQgKiBAbmFtZSBnZXRfdGV4dChvYmopXG5cdFx0ICogQHBhcmFtICB7bWl4ZWR9IG9iaiB0aGUgbm9kZVxuXHRcdCAqIEByZXR1cm4ge1N0cmluZ31cblx0XHQgKi9cblx0XHRnZXRfdGV4dCA6IGZ1bmN0aW9uIChvYmopIHtcblx0XHRcdG9iaiA9IHRoaXMuZ2V0X25vZGUob2JqKTtcblx0XHRcdHJldHVybiAoIW9iaiB8fCBvYmouaWQgPT09ICQuanN0cmVlLnJvb3QpID8gZmFsc2UgOiBvYmoudGV4dDtcblx0XHR9LFxuXHRcdC8qKlxuXHRcdCAqIHNldCB0aGUgdGV4dCB2YWx1ZSBvZiBhIG5vZGUuIFVzZWQgaW50ZXJuYWxseSwgcGxlYXNlIHVzZSBgcmVuYW1lX25vZGUob2JqLCB2YWwpYC5cblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqIEBuYW1lIHNldF90ZXh0KG9iaiwgdmFsKVxuXHRcdCAqIEBwYXJhbSAge21peGVkfSBvYmogdGhlIG5vZGUsIHlvdSBjYW4gcGFzcyBhbiBhcnJheSB0byBzZXQgdGhlIHRleHQgb24gbXVsdGlwbGUgbm9kZXNcblx0XHQgKiBAcGFyYW0gIHtTdHJpbmd9IHZhbCB0aGUgbmV3IHRleHQgdmFsdWVcblx0XHQgKiBAcmV0dXJuIHtCb29sZWFufVxuXHRcdCAqIEB0cmlnZ2VyIHNldF90ZXh0LmpzdHJlZVxuXHRcdCAqL1xuXHRcdHNldF90ZXh0IDogZnVuY3Rpb24gKG9iaiwgdmFsKSB7XG5cdFx0XHR2YXIgdDEsIHQyO1xuXHRcdFx0aWYoJC5pc0FycmF5KG9iaikpIHtcblx0XHRcdFx0b2JqID0gb2JqLnNsaWNlKCk7XG5cdFx0XHRcdGZvcih0MSA9IDAsIHQyID0gb2JqLmxlbmd0aDsgdDEgPCB0MjsgdDErKykge1xuXHRcdFx0XHRcdHRoaXMuc2V0X3RleHQob2JqW3QxXSwgdmFsKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblx0XHRcdG9iaiA9IHRoaXMuZ2V0X25vZGUob2JqKTtcblx0XHRcdGlmKCFvYmogfHwgb2JqLmlkID09PSAkLmpzdHJlZS5yb290KSB7IHJldHVybiBmYWxzZTsgfVxuXHRcdFx0b2JqLnRleHQgPSB2YWw7XG5cdFx0XHRpZih0aGlzLmdldF9ub2RlKG9iaiwgdHJ1ZSkubGVuZ3RoKSB7XG5cdFx0XHRcdHRoaXMucmVkcmF3X25vZGUob2JqLmlkKTtcblx0XHRcdH1cblx0XHRcdC8qKlxuXHRcdFx0ICogdHJpZ2dlcmVkIHdoZW4gYSBub2RlIHRleHQgdmFsdWUgaXMgY2hhbmdlZFxuXHRcdFx0ICogQGV2ZW50XG5cdFx0XHQgKiBAbmFtZSBzZXRfdGV4dC5qc3RyZWVcblx0XHRcdCAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcblx0XHRcdCAqIEBwYXJhbSB7U3RyaW5nfSB0ZXh0IHRoZSBuZXcgdmFsdWVcblx0XHRcdCAqL1xuXHRcdFx0dGhpcy50cmlnZ2VyKCdzZXRfdGV4dCcseyBcIm9ialwiIDogb2JqLCBcInRleHRcIiA6IHZhbCB9KTtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH0sXG5cdFx0LyoqXG5cdFx0ICogZ2V0cyBhIEpTT04gcmVwcmVzZW50YXRpb24gb2YgYSBub2RlIChvciB0aGUgd2hvbGUgdHJlZSlcblx0XHQgKiBAbmFtZSBnZXRfanNvbihbb2JqLCBvcHRpb25zXSlcblx0XHQgKiBAcGFyYW0gIHttaXhlZH0gb2JqXG5cdFx0ICogQHBhcmFtICB7T2JqZWN0fSBvcHRpb25zXG5cdFx0ICogQHBhcmFtICB7Qm9vbGVhbn0gb3B0aW9ucy5ub19zdGF0ZSBkbyBub3QgcmV0dXJuIHN0YXRlIGluZm9ybWF0aW9uXG5cdFx0ICogQHBhcmFtICB7Qm9vbGVhbn0gb3B0aW9ucy5ub19pZCBkbyBub3QgcmV0dXJuIElEXG5cdFx0ICogQHBhcmFtICB7Qm9vbGVhbn0gb3B0aW9ucy5ub19jaGlsZHJlbiBkbyBub3QgaW5jbHVkZSBjaGlsZHJlblxuXHRcdCAqIEBwYXJhbSAge0Jvb2xlYW59IG9wdGlvbnMubm9fZGF0YSBkbyBub3QgaW5jbHVkZSBub2RlIGRhdGFcblx0XHQgKiBAcGFyYW0gIHtCb29sZWFufSBvcHRpb25zLm5vX2xpX2F0dHIgZG8gbm90IGluY2x1ZGUgTEkgYXR0cmlidXRlc1xuXHRcdCAqIEBwYXJhbSAge0Jvb2xlYW59IG9wdGlvbnMubm9fYV9hdHRyIGRvIG5vdCBpbmNsdWRlIEEgYXR0cmlidXRlc1xuXHRcdCAqIEBwYXJhbSAge0Jvb2xlYW59IG9wdGlvbnMuZmxhdCByZXR1cm4gZmxhdCBKU09OIGluc3RlYWQgb2YgbmVzdGVkXG5cdFx0ICogQHJldHVybiB7T2JqZWN0fVxuXHRcdCAqL1xuXHRcdGdldF9qc29uIDogZnVuY3Rpb24gKG9iaiwgb3B0aW9ucywgZmxhdCkge1xuXHRcdFx0b2JqID0gdGhpcy5nZXRfbm9kZShvYmogfHwgJC5qc3RyZWUucm9vdCk7XG5cdFx0XHRpZighb2JqKSB7IHJldHVybiBmYWxzZTsgfVxuXHRcdFx0aWYob3B0aW9ucyAmJiBvcHRpb25zLmZsYXQgJiYgIWZsYXQpIHsgZmxhdCA9IFtdOyB9XG5cdFx0XHR2YXIgdG1wID0ge1xuXHRcdFx0XHQnaWQnIDogb2JqLmlkLFxuXHRcdFx0XHQndGV4dCcgOiBvYmoudGV4dCxcblx0XHRcdFx0J2ljb24nIDogdGhpcy5nZXRfaWNvbihvYmopLFxuXHRcdFx0XHQnbGlfYXR0cicgOiAkLmV4dGVuZCh0cnVlLCB7fSwgb2JqLmxpX2F0dHIpLFxuXHRcdFx0XHQnYV9hdHRyJyA6ICQuZXh0ZW5kKHRydWUsIHt9LCBvYmouYV9hdHRyKSxcblx0XHRcdFx0J3N0YXRlJyA6IHt9LFxuXHRcdFx0XHQnZGF0YScgOiBvcHRpb25zICYmIG9wdGlvbnMubm9fZGF0YSA/IGZhbHNlIDogJC5leHRlbmQodHJ1ZSwge30sIG9iai5kYXRhKVxuXHRcdFx0XHQvLyggdGhpcy5nZXRfbm9kZShvYmosIHRydWUpLmxlbmd0aCA/IHRoaXMuZ2V0X25vZGUob2JqLCB0cnVlKS5kYXRhKCkgOiBvYmouZGF0YSApLFxuXHRcdFx0fSwgaSwgajtcblx0XHRcdGlmKG9wdGlvbnMgJiYgb3B0aW9ucy5mbGF0KSB7XG5cdFx0XHRcdHRtcC5wYXJlbnQgPSBvYmoucGFyZW50O1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSB7XG5cdFx0XHRcdHRtcC5jaGlsZHJlbiA9IFtdO1xuXHRcdFx0fVxuXHRcdFx0aWYoIW9wdGlvbnMgfHwgIW9wdGlvbnMubm9fc3RhdGUpIHtcblx0XHRcdFx0Zm9yKGkgaW4gb2JqLnN0YXRlKSB7XG5cdFx0XHRcdFx0aWYob2JqLnN0YXRlLmhhc093blByb3BlcnR5KGkpKSB7XG5cdFx0XHRcdFx0XHR0bXAuc3RhdGVbaV0gPSBvYmouc3RhdGVbaV07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRkZWxldGUgdG1wLnN0YXRlO1xuXHRcdFx0fVxuXHRcdFx0aWYob3B0aW9ucyAmJiBvcHRpb25zLm5vX2xpX2F0dHIpIHtcblx0XHRcdFx0ZGVsZXRlIHRtcC5saV9hdHRyO1xuXHRcdFx0fVxuXHRcdFx0aWYob3B0aW9ucyAmJiBvcHRpb25zLm5vX2FfYXR0cikge1xuXHRcdFx0XHRkZWxldGUgdG1wLmFfYXR0cjtcblx0XHRcdH1cblx0XHRcdGlmKG9wdGlvbnMgJiYgb3B0aW9ucy5ub19pZCkge1xuXHRcdFx0XHRkZWxldGUgdG1wLmlkO1xuXHRcdFx0XHRpZih0bXAubGlfYXR0ciAmJiB0bXAubGlfYXR0ci5pZCkge1xuXHRcdFx0XHRcdGRlbGV0ZSB0bXAubGlfYXR0ci5pZDtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZih0bXAuYV9hdHRyICYmIHRtcC5hX2F0dHIuaWQpIHtcblx0XHRcdFx0XHRkZWxldGUgdG1wLmFfYXR0ci5pZDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0aWYob3B0aW9ucyAmJiBvcHRpb25zLmZsYXQgJiYgb2JqLmlkICE9PSAkLmpzdHJlZS5yb290KSB7XG5cdFx0XHRcdGZsYXQucHVzaCh0bXApO1xuXHRcdFx0fVxuXHRcdFx0aWYoIW9wdGlvbnMgfHwgIW9wdGlvbnMubm9fY2hpbGRyZW4pIHtcblx0XHRcdFx0Zm9yKGkgPSAwLCBqID0gb2JqLmNoaWxkcmVuLmxlbmd0aDsgaSA8IGo7IGkrKykge1xuXHRcdFx0XHRcdGlmKG9wdGlvbnMgJiYgb3B0aW9ucy5mbGF0KSB7XG5cdFx0XHRcdFx0XHR0aGlzLmdldF9qc29uKG9iai5jaGlsZHJlbltpXSwgb3B0aW9ucywgZmxhdCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdFx0dG1wLmNoaWxkcmVuLnB1c2godGhpcy5nZXRfanNvbihvYmouY2hpbGRyZW5baV0sIG9wdGlvbnMpKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiBvcHRpb25zICYmIG9wdGlvbnMuZmxhdCA/IGZsYXQgOiAob2JqLmlkID09PSAkLmpzdHJlZS5yb290ID8gdG1wLmNoaWxkcmVuIDogdG1wKTtcblx0XHR9LFxuXHRcdC8qKlxuXHRcdCAqIGNyZWF0ZSBhIG5ldyBub2RlIChkbyBub3QgY29uZnVzZSB3aXRoIGxvYWRfbm9kZSlcblx0XHQgKiBAbmFtZSBjcmVhdGVfbm9kZShbcGFyLCBub2RlLCBwb3MsIGNhbGxiYWNrLCBpc19sb2FkZWRdKVxuXHRcdCAqIEBwYXJhbSAge21peGVkfSAgIHBhciAgICAgICB0aGUgcGFyZW50IG5vZGUgKHRvIGNyZWF0ZSBhIHJvb3Qgbm9kZSB1c2UgZWl0aGVyIFwiI1wiIChzdHJpbmcpIG9yIGBudWxsYClcblx0XHQgKiBAcGFyYW0gIHttaXhlZH0gICBub2RlICAgICAgdGhlIGRhdGEgZm9yIHRoZSBuZXcgbm9kZSAoYSB2YWxpZCBKU09OIG9iamVjdCwgb3IgYSBzaW1wbGUgc3RyaW5nIHdpdGggdGhlIG5hbWUpXG5cdFx0ICogQHBhcmFtICB7bWl4ZWR9ICAgcG9zICAgICAgIHRoZSBpbmRleCBhdCB3aGljaCB0byBpbnNlcnQgdGhlIG5vZGUsIFwiZmlyc3RcIiBhbmQgXCJsYXN0XCIgYXJlIGFsc28gc3VwcG9ydGVkLCBkZWZhdWx0IGlzIFwibGFzdFwiXG5cdFx0ICogQHBhcmFtICB7RnVuY3Rpb259IGNhbGxiYWNrIGEgZnVuY3Rpb24gdG8gYmUgY2FsbGVkIG9uY2UgdGhlIG5vZGUgaXMgY3JlYXRlZFxuXHRcdCAqIEBwYXJhbSAge0Jvb2xlYW59IGlzX2xvYWRlZCBpbnRlcm5hbCBhcmd1bWVudCBpbmRpY2F0aW5nIGlmIHRoZSBwYXJlbnQgbm9kZSB3YXMgc3VjY2VzZnVsbHkgbG9hZGVkXG5cdFx0ICogQHJldHVybiB7U3RyaW5nfSAgICAgICAgICAgIHRoZSBJRCBvZiB0aGUgbmV3bHkgY3JlYXRlIG5vZGVcblx0XHQgKiBAdHJpZ2dlciBtb2RlbC5qc3RyZWUsIGNyZWF0ZV9ub2RlLmpzdHJlZVxuXHRcdCAqL1xuXHRcdGNyZWF0ZV9ub2RlIDogZnVuY3Rpb24gKHBhciwgbm9kZSwgcG9zLCBjYWxsYmFjaywgaXNfbG9hZGVkKSB7XG5cdFx0XHRpZihwYXIgPT09IG51bGwpIHsgcGFyID0gJC5qc3RyZWUucm9vdDsgfVxuXHRcdFx0cGFyID0gdGhpcy5nZXRfbm9kZShwYXIpO1xuXHRcdFx0aWYoIXBhcikgeyByZXR1cm4gZmFsc2U7IH1cblx0XHRcdHBvcyA9IHBvcyA9PT0gdW5kZWZpbmVkID8gXCJsYXN0XCIgOiBwb3M7XG5cdFx0XHRpZighcG9zLnRvU3RyaW5nKCkubWF0Y2goL14oYmVmb3JlfGFmdGVyKSQvKSAmJiAhaXNfbG9hZGVkICYmICF0aGlzLmlzX2xvYWRlZChwYXIpKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLmxvYWRfbm9kZShwYXIsIGZ1bmN0aW9uICgpIHsgdGhpcy5jcmVhdGVfbm9kZShwYXIsIG5vZGUsIHBvcywgY2FsbGJhY2ssIHRydWUpOyB9KTtcblx0XHRcdH1cblx0XHRcdGlmKCFub2RlKSB7IG5vZGUgPSB7IFwidGV4dFwiIDogdGhpcy5nZXRfc3RyaW5nKCdOZXcgbm9kZScpIH07IH1cblx0XHRcdGlmKHR5cGVvZiBub2RlID09PSBcInN0cmluZ1wiKSB7IG5vZGUgPSB7IFwidGV4dFwiIDogbm9kZSB9OyB9XG5cdFx0XHRpZihub2RlLnRleHQgPT09IHVuZGVmaW5lZCkgeyBub2RlLnRleHQgPSB0aGlzLmdldF9zdHJpbmcoJ05ldyBub2RlJyk7IH1cblx0XHRcdHZhciB0bXAsIGRwYywgaSwgajtcblxuXHRcdFx0aWYocGFyLmlkID09PSAkLmpzdHJlZS5yb290KSB7XG5cdFx0XHRcdGlmKHBvcyA9PT0gXCJiZWZvcmVcIikgeyBwb3MgPSBcImZpcnN0XCI7IH1cblx0XHRcdFx0aWYocG9zID09PSBcImFmdGVyXCIpIHsgcG9zID0gXCJsYXN0XCI7IH1cblx0XHRcdH1cblx0XHRcdHN3aXRjaChwb3MpIHtcblx0XHRcdFx0Y2FzZSBcImJlZm9yZVwiOlxuXHRcdFx0XHRcdHRtcCA9IHRoaXMuZ2V0X25vZGUocGFyLnBhcmVudCk7XG5cdFx0XHRcdFx0cG9zID0gJC5pbkFycmF5KHBhci5pZCwgdG1wLmNoaWxkcmVuKTtcblx0XHRcdFx0XHRwYXIgPSB0bXA7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGNhc2UgXCJhZnRlclwiIDpcblx0XHRcdFx0XHR0bXAgPSB0aGlzLmdldF9ub2RlKHBhci5wYXJlbnQpO1xuXHRcdFx0XHRcdHBvcyA9ICQuaW5BcnJheShwYXIuaWQsIHRtcC5jaGlsZHJlbikgKyAxO1xuXHRcdFx0XHRcdHBhciA9IHRtcDtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0Y2FzZSBcImluc2lkZVwiOlxuXHRcdFx0XHRjYXNlIFwiZmlyc3RcIjpcblx0XHRcdFx0XHRwb3MgPSAwO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRjYXNlIFwibGFzdFwiOlxuXHRcdFx0XHRcdHBvcyA9IHBhci5jaGlsZHJlbi5sZW5ndGg7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdFx0aWYoIXBvcykgeyBwb3MgPSAwOyB9XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0XHRpZihwb3MgPiBwYXIuY2hpbGRyZW4ubGVuZ3RoKSB7IHBvcyA9IHBhci5jaGlsZHJlbi5sZW5ndGg7IH1cblx0XHRcdGlmKCFub2RlLmlkKSB7IG5vZGUuaWQgPSB0cnVlOyB9XG5cdFx0XHRpZighdGhpcy5jaGVjayhcImNyZWF0ZV9ub2RlXCIsIG5vZGUsIHBhciwgcG9zKSkge1xuXHRcdFx0XHR0aGlzLnNldHRpbmdzLmNvcmUuZXJyb3IuY2FsbCh0aGlzLCB0aGlzLl9kYXRhLmNvcmUubGFzdF9lcnJvcik7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblx0XHRcdGlmKG5vZGUuaWQgPT09IHRydWUpIHsgZGVsZXRlIG5vZGUuaWQ7IH1cblx0XHRcdG5vZGUgPSB0aGlzLl9wYXJzZV9tb2RlbF9mcm9tX2pzb24obm9kZSwgcGFyLmlkLCBwYXIucGFyZW50cy5jb25jYXQoKSk7XG5cdFx0XHRpZighbm9kZSkgeyByZXR1cm4gZmFsc2U7IH1cblx0XHRcdHRtcCA9IHRoaXMuZ2V0X25vZGUobm9kZSk7XG5cdFx0XHRkcGMgPSBbXTtcblx0XHRcdGRwYy5wdXNoKG5vZGUpO1xuXHRcdFx0ZHBjID0gZHBjLmNvbmNhdCh0bXAuY2hpbGRyZW5fZCk7XG5cdFx0XHR0aGlzLnRyaWdnZXIoJ21vZGVsJywgeyBcIm5vZGVzXCIgOiBkcGMsIFwicGFyZW50XCIgOiBwYXIuaWQgfSk7XG5cblx0XHRcdHBhci5jaGlsZHJlbl9kID0gcGFyLmNoaWxkcmVuX2QuY29uY2F0KGRwYyk7XG5cdFx0XHRmb3IoaSA9IDAsIGogPSBwYXIucGFyZW50cy5sZW5ndGg7IGkgPCBqOyBpKyspIHtcblx0XHRcdFx0dGhpcy5fbW9kZWwuZGF0YVtwYXIucGFyZW50c1tpXV0uY2hpbGRyZW5fZCA9IHRoaXMuX21vZGVsLmRhdGFbcGFyLnBhcmVudHNbaV1dLmNoaWxkcmVuX2QuY29uY2F0KGRwYyk7XG5cdFx0XHR9XG5cdFx0XHRub2RlID0gdG1wO1xuXHRcdFx0dG1wID0gW107XG5cdFx0XHRmb3IoaSA9IDAsIGogPSBwYXIuY2hpbGRyZW4ubGVuZ3RoOyBpIDwgajsgaSsrKSB7XG5cdFx0XHRcdHRtcFtpID49IHBvcyA/IGkrMSA6IGldID0gcGFyLmNoaWxkcmVuW2ldO1xuXHRcdFx0fVxuXHRcdFx0dG1wW3Bvc10gPSBub2RlLmlkO1xuXHRcdFx0cGFyLmNoaWxkcmVuID0gdG1wO1xuXG5cdFx0XHR0aGlzLnJlZHJhd19ub2RlKHBhciwgdHJ1ZSk7XG5cdFx0XHRpZihjYWxsYmFjaykgeyBjYWxsYmFjay5jYWxsKHRoaXMsIHRoaXMuZ2V0X25vZGUobm9kZSkpOyB9XG5cdFx0XHQvKipcblx0XHRcdCAqIHRyaWdnZXJlZCB3aGVuIGEgbm9kZSBpcyBjcmVhdGVkXG5cdFx0XHQgKiBAZXZlbnRcblx0XHRcdCAqIEBuYW1lIGNyZWF0ZV9ub2RlLmpzdHJlZVxuXHRcdFx0ICogQHBhcmFtIHtPYmplY3R9IG5vZGVcblx0XHRcdCAqIEBwYXJhbSB7U3RyaW5nfSBwYXJlbnQgdGhlIHBhcmVudCdzIElEXG5cdFx0XHQgKiBAcGFyYW0ge051bWJlcn0gcG9zaXRpb24gdGhlIHBvc2l0aW9uIG9mIHRoZSBuZXcgbm9kZSBhbW9uZyB0aGUgcGFyZW50J3MgY2hpbGRyZW5cblx0XHRcdCAqL1xuXHRcdFx0dGhpcy50cmlnZ2VyKCdjcmVhdGVfbm9kZScsIHsgXCJub2RlXCIgOiB0aGlzLmdldF9ub2RlKG5vZGUpLCBcInBhcmVudFwiIDogcGFyLmlkLCBcInBvc2l0aW9uXCIgOiBwb3MgfSk7XG5cdFx0XHRyZXR1cm4gbm9kZS5pZDtcblx0XHR9LFxuXHRcdC8qKlxuXHRcdCAqIHNldCB0aGUgdGV4dCB2YWx1ZSBvZiBhIG5vZGVcblx0XHQgKiBAbmFtZSByZW5hbWVfbm9kZShvYmosIHZhbClcblx0XHQgKiBAcGFyYW0gIHttaXhlZH0gb2JqIHRoZSBub2RlLCB5b3UgY2FuIHBhc3MgYW4gYXJyYXkgdG8gcmVuYW1lIG11bHRpcGxlIG5vZGVzIHRvIHRoZSBzYW1lIG5hbWVcblx0XHQgKiBAcGFyYW0gIHtTdHJpbmd9IHZhbCB0aGUgbmV3IHRleHQgdmFsdWVcblx0XHQgKiBAcmV0dXJuIHtCb29sZWFufVxuXHRcdCAqIEB0cmlnZ2VyIHJlbmFtZV9ub2RlLmpzdHJlZVxuXHRcdCAqL1xuXHRcdHJlbmFtZV9ub2RlIDogZnVuY3Rpb24gKG9iaiwgdmFsKSB7XG5cdFx0XHR2YXIgdDEsIHQyLCBvbGQ7XG5cdFx0XHRpZigkLmlzQXJyYXkob2JqKSkge1xuXHRcdFx0XHRvYmogPSBvYmouc2xpY2UoKTtcblx0XHRcdFx0Zm9yKHQxID0gMCwgdDIgPSBvYmoubGVuZ3RoOyB0MSA8IHQyOyB0MSsrKSB7XG5cdFx0XHRcdFx0dGhpcy5yZW5hbWVfbm9kZShvYmpbdDFdLCB2YWwpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fVxuXHRcdFx0b2JqID0gdGhpcy5nZXRfbm9kZShvYmopO1xuXHRcdFx0aWYoIW9iaiB8fCBvYmouaWQgPT09ICQuanN0cmVlLnJvb3QpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdFx0XHRvbGQgPSBvYmoudGV4dDtcblx0XHRcdGlmKCF0aGlzLmNoZWNrKFwicmVuYW1lX25vZGVcIiwgb2JqLCB0aGlzLmdldF9wYXJlbnQob2JqKSwgdmFsKSkge1xuXHRcdFx0XHR0aGlzLnNldHRpbmdzLmNvcmUuZXJyb3IuY2FsbCh0aGlzLCB0aGlzLl9kYXRhLmNvcmUubGFzdF9lcnJvcik7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblx0XHRcdHRoaXMuc2V0X3RleHQob2JqLCB2YWwpOyAvLyAuYXBwbHkodGhpcywgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKSlcblx0XHRcdC8qKlxuXHRcdFx0ICogdHJpZ2dlcmVkIHdoZW4gYSBub2RlIGlzIHJlbmFtZWRcblx0XHRcdCAqIEBldmVudFxuXHRcdFx0ICogQG5hbWUgcmVuYW1lX25vZGUuanN0cmVlXG5cdFx0XHQgKiBAcGFyYW0ge09iamVjdH0gbm9kZVxuXHRcdFx0ICogQHBhcmFtIHtTdHJpbmd9IHRleHQgdGhlIG5ldyB2YWx1ZVxuXHRcdFx0ICogQHBhcmFtIHtTdHJpbmd9IG9sZCB0aGUgb2xkIHZhbHVlXG5cdFx0XHQgKi9cblx0XHRcdHRoaXMudHJpZ2dlcigncmVuYW1lX25vZGUnLCB7IFwibm9kZVwiIDogb2JqLCBcInRleHRcIiA6IHZhbCwgXCJvbGRcIiA6IG9sZCB9KTtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH0sXG5cdFx0LyoqXG5cdFx0ICogcmVtb3ZlIGEgbm9kZVxuXHRcdCAqIEBuYW1lIGRlbGV0ZV9ub2RlKG9iailcblx0XHQgKiBAcGFyYW0gIHttaXhlZH0gb2JqIHRoZSBub2RlLCB5b3UgY2FuIHBhc3MgYW4gYXJyYXkgdG8gZGVsZXRlIG11bHRpcGxlIG5vZGVzXG5cdFx0ICogQHJldHVybiB7Qm9vbGVhbn1cblx0XHQgKiBAdHJpZ2dlciBkZWxldGVfbm9kZS5qc3RyZWUsIGNoYW5nZWQuanN0cmVlXG5cdFx0ICovXG5cdFx0ZGVsZXRlX25vZGUgOiBmdW5jdGlvbiAob2JqKSB7XG5cdFx0XHR2YXIgdDEsIHQyLCBwYXIsIHBvcywgdG1wLCBpLCBqLCBrLCBsLCBjLCB0b3AsIGxmdDtcblx0XHRcdGlmKCQuaXNBcnJheShvYmopKSB7XG5cdFx0XHRcdG9iaiA9IG9iai5zbGljZSgpO1xuXHRcdFx0XHRmb3IodDEgPSAwLCB0MiA9IG9iai5sZW5ndGg7IHQxIDwgdDI7IHQxKyspIHtcblx0XHRcdFx0XHR0aGlzLmRlbGV0ZV9ub2RlKG9ialt0MV0pO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fVxuXHRcdFx0b2JqID0gdGhpcy5nZXRfbm9kZShvYmopO1xuXHRcdFx0aWYoIW9iaiB8fCBvYmouaWQgPT09ICQuanN0cmVlLnJvb3QpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdFx0XHRwYXIgPSB0aGlzLmdldF9ub2RlKG9iai5wYXJlbnQpO1xuXHRcdFx0cG9zID0gJC5pbkFycmF5KG9iai5pZCwgcGFyLmNoaWxkcmVuKTtcblx0XHRcdGMgPSBmYWxzZTtcblx0XHRcdGlmKCF0aGlzLmNoZWNrKFwiZGVsZXRlX25vZGVcIiwgb2JqLCBwYXIsIHBvcykpIHtcblx0XHRcdFx0dGhpcy5zZXR0aW5ncy5jb3JlLmVycm9yLmNhbGwodGhpcywgdGhpcy5fZGF0YS5jb3JlLmxhc3RfZXJyb3IpO1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cdFx0XHRpZihwb3MgIT09IC0xKSB7XG5cdFx0XHRcdHBhci5jaGlsZHJlbiA9ICQudmFrYXRhLmFycmF5X3JlbW92ZShwYXIuY2hpbGRyZW4sIHBvcyk7XG5cdFx0XHR9XG5cdFx0XHR0bXAgPSBvYmouY2hpbGRyZW5fZC5jb25jYXQoW10pO1xuXHRcdFx0dG1wLnB1c2gob2JqLmlkKTtcblx0XHRcdGZvcihpID0gMCwgaiA9IG9iai5wYXJlbnRzLmxlbmd0aDsgaSA8IGo7IGkrKykge1xuXHRcdFx0XHR0aGlzLl9tb2RlbC5kYXRhW29iai5wYXJlbnRzW2ldXS5jaGlsZHJlbl9kID0gJC52YWthdGEuYXJyYXlfZmlsdGVyKHRoaXMuX21vZGVsLmRhdGFbb2JqLnBhcmVudHNbaV1dLmNoaWxkcmVuX2QsIGZ1bmN0aW9uICh2KSB7XG5cdFx0XHRcdFx0cmV0dXJuICQuaW5BcnJheSh2LCB0bXApID09PSAtMTtcblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cdFx0XHRmb3IoayA9IDAsIGwgPSB0bXAubGVuZ3RoOyBrIDwgbDsgaysrKSB7XG5cdFx0XHRcdGlmKHRoaXMuX21vZGVsLmRhdGFbdG1wW2tdXS5zdGF0ZS5zZWxlY3RlZCkge1xuXHRcdFx0XHRcdGMgPSB0cnVlO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRpZiAoYykge1xuXHRcdFx0XHR0aGlzLl9kYXRhLmNvcmUuc2VsZWN0ZWQgPSAkLnZha2F0YS5hcnJheV9maWx0ZXIodGhpcy5fZGF0YS5jb3JlLnNlbGVjdGVkLCBmdW5jdGlvbiAodikge1xuXHRcdFx0XHRcdHJldHVybiAkLmluQXJyYXkodiwgdG1wKSA9PT0gLTE7XG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXHRcdFx0LyoqXG5cdFx0XHQgKiB0cmlnZ2VyZWQgd2hlbiBhIG5vZGUgaXMgZGVsZXRlZFxuXHRcdFx0ICogQGV2ZW50XG5cdFx0XHQgKiBAbmFtZSBkZWxldGVfbm9kZS5qc3RyZWVcblx0XHRcdCAqIEBwYXJhbSB7T2JqZWN0fSBub2RlXG5cdFx0XHQgKiBAcGFyYW0ge1N0cmluZ30gcGFyZW50IHRoZSBwYXJlbnQncyBJRFxuXHRcdFx0ICovXG5cdFx0XHR0aGlzLnRyaWdnZXIoJ2RlbGV0ZV9ub2RlJywgeyBcIm5vZGVcIiA6IG9iaiwgXCJwYXJlbnRcIiA6IHBhci5pZCB9KTtcblx0XHRcdGlmKGMpIHtcblx0XHRcdFx0dGhpcy50cmlnZ2VyKCdjaGFuZ2VkJywgeyAnYWN0aW9uJyA6ICdkZWxldGVfbm9kZScsICdub2RlJyA6IG9iaiwgJ3NlbGVjdGVkJyA6IHRoaXMuX2RhdGEuY29yZS5zZWxlY3RlZCwgJ3BhcmVudCcgOiBwYXIuaWQgfSk7XG5cdFx0XHR9XG5cdFx0XHRmb3IoayA9IDAsIGwgPSB0bXAubGVuZ3RoOyBrIDwgbDsgaysrKSB7XG5cdFx0XHRcdGRlbGV0ZSB0aGlzLl9tb2RlbC5kYXRhW3RtcFtrXV07XG5cdFx0XHR9XG5cdFx0XHRpZigkLmluQXJyYXkodGhpcy5fZGF0YS5jb3JlLmZvY3VzZWQsIHRtcCkgIT09IC0xKSB7XG5cdFx0XHRcdHRoaXMuX2RhdGEuY29yZS5mb2N1c2VkID0gbnVsbDtcblx0XHRcdFx0dG9wID0gdGhpcy5lbGVtZW50WzBdLnNjcm9sbFRvcDtcblx0XHRcdFx0bGZ0ID0gdGhpcy5lbGVtZW50WzBdLnNjcm9sbExlZnQ7XG5cdFx0XHRcdGlmKHBhci5pZCA9PT0gJC5qc3RyZWUucm9vdCkge1xuXHRcdFx0XHRcdGlmICh0aGlzLl9tb2RlbC5kYXRhWyQuanN0cmVlLnJvb3RdLmNoaWxkcmVuWzBdKSB7XG5cdFx0XHRcdFx0XHR0aGlzLmdldF9ub2RlKHRoaXMuX21vZGVsLmRhdGFbJC5qc3RyZWUucm9vdF0uY2hpbGRyZW5bMF0sIHRydWUpLmNoaWxkcmVuKCcuanN0cmVlLWFuY2hvcicpLmZvY3VzKCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdHRoaXMuZ2V0X25vZGUocGFyLCB0cnVlKS5jaGlsZHJlbignLmpzdHJlZS1hbmNob3InKS5mb2N1cygpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRoaXMuZWxlbWVudFswXS5zY3JvbGxUb3AgID0gdG9wO1xuXHRcdFx0XHR0aGlzLmVsZW1lbnRbMF0uc2Nyb2xsTGVmdCA9IGxmdDtcblx0XHRcdH1cblx0XHRcdHRoaXMucmVkcmF3X25vZGUocGFyLCB0cnVlKTtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH0sXG5cdFx0LyoqXG5cdFx0ICogY2hlY2sgaWYgYW4gb3BlcmF0aW9uIGlzIHByZW1pdHRlZCBvbiB0aGUgdHJlZS4gVXNlZCBpbnRlcm5hbGx5LlxuXHRcdCAqIEBwcml2YXRlXG5cdFx0ICogQG5hbWUgY2hlY2soY2hrLCBvYmosIHBhciwgcG9zKVxuXHRcdCAqIEBwYXJhbSAge1N0cmluZ30gY2hrIHRoZSBvcGVyYXRpb24gdG8gY2hlY2ssIGNhbiBiZSBcImNyZWF0ZV9ub2RlXCIsIFwicmVuYW1lX25vZGVcIiwgXCJkZWxldGVfbm9kZVwiLCBcImNvcHlfbm9kZVwiIG9yIFwibW92ZV9ub2RlXCJcblx0XHQgKiBAcGFyYW0gIHttaXhlZH0gb2JqIHRoZSBub2RlXG5cdFx0ICogQHBhcmFtICB7bWl4ZWR9IHBhciB0aGUgcGFyZW50XG5cdFx0ICogQHBhcmFtICB7bWl4ZWR9IHBvcyB0aGUgcG9zaXRpb24gdG8gaW5zZXJ0IGF0LCBvciBpZiBcInJlbmFtZV9ub2RlXCIgLSB0aGUgbmV3IG5hbWVcblx0XHQgKiBAcGFyYW0gIHttaXhlZH0gbW9yZSBzb21lIHZhcmlvdXMgYWRkaXRpb25hbCBpbmZvcm1hdGlvbiwgZm9yIGV4YW1wbGUgaWYgYSBcIm1vdmVfbm9kZVwiIG9wZXJhdGlvbnMgaXMgdHJpZ2dlcmVkIGJ5IERORCB0aGlzIHdpbGwgYmUgdGhlIGhvdmVyZWQgbm9kZVxuXHRcdCAqIEByZXR1cm4ge0Jvb2xlYW59XG5cdFx0ICovXG5cdFx0Y2hlY2sgOiBmdW5jdGlvbiAoY2hrLCBvYmosIHBhciwgcG9zLCBtb3JlKSB7XG5cdFx0XHRvYmogPSBvYmogJiYgb2JqLmlkID8gb2JqIDogdGhpcy5nZXRfbm9kZShvYmopO1xuXHRcdFx0cGFyID0gcGFyICYmIHBhci5pZCA/IHBhciA6IHRoaXMuZ2V0X25vZGUocGFyKTtcblx0XHRcdHZhciB0bXAgPSBjaGsubWF0Y2goL15tb3ZlX25vZGV8Y29weV9ub2RlfGNyZWF0ZV9ub2RlJC9pKSA/IHBhciA6IG9iaixcblx0XHRcdFx0Y2hjID0gdGhpcy5zZXR0aW5ncy5jb3JlLmNoZWNrX2NhbGxiYWNrO1xuXHRcdFx0aWYoY2hrID09PSBcIm1vdmVfbm9kZVwiIHx8IGNoayA9PT0gXCJjb3B5X25vZGVcIikge1xuXHRcdFx0XHRpZigoIW1vcmUgfHwgIW1vcmUuaXNfbXVsdGkpICYmIChvYmouaWQgPT09IHBhci5pZCB8fCAoY2hrID09PSBcIm1vdmVfbm9kZVwiICYmICQuaW5BcnJheShvYmouaWQsIHBhci5jaGlsZHJlbikgPT09IHBvcykgfHwgJC5pbkFycmF5KHBhci5pZCwgb2JqLmNoaWxkcmVuX2QpICE9PSAtMSkpIHtcblx0XHRcdFx0XHR0aGlzLl9kYXRhLmNvcmUubGFzdF9lcnJvciA9IHsgJ2Vycm9yJyA6ICdjaGVjaycsICdwbHVnaW4nIDogJ2NvcmUnLCAnaWQnIDogJ2NvcmVfMDEnLCAncmVhc29uJyA6ICdNb3ZpbmcgcGFyZW50IGluc2lkZSBjaGlsZCcsICdkYXRhJyA6IEpTT04uc3RyaW5naWZ5KHsgJ2NoaycgOiBjaGssICdwb3MnIDogcG9zLCAnb2JqJyA6IG9iaiAmJiBvYmouaWQgPyBvYmouaWQgOiBmYWxzZSwgJ3BhcicgOiBwYXIgJiYgcGFyLmlkID8gcGFyLmlkIDogZmFsc2UgfSkgfTtcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGlmKHRtcCAmJiB0bXAuZGF0YSkgeyB0bXAgPSB0bXAuZGF0YTsgfVxuXHRcdFx0aWYodG1wICYmIHRtcC5mdW5jdGlvbnMgJiYgKHRtcC5mdW5jdGlvbnNbY2hrXSA9PT0gZmFsc2UgfHwgdG1wLmZ1bmN0aW9uc1tjaGtdID09PSB0cnVlKSkge1xuXHRcdFx0XHRpZih0bXAuZnVuY3Rpb25zW2Noa10gPT09IGZhbHNlKSB7XG5cdFx0XHRcdFx0dGhpcy5fZGF0YS5jb3JlLmxhc3RfZXJyb3IgPSB7ICdlcnJvcicgOiAnY2hlY2snLCAncGx1Z2luJyA6ICdjb3JlJywgJ2lkJyA6ICdjb3JlXzAyJywgJ3JlYXNvbicgOiAnTm9kZSBkYXRhIHByZXZlbnRzIGZ1bmN0aW9uOiAnICsgY2hrLCAnZGF0YScgOiBKU09OLnN0cmluZ2lmeSh7ICdjaGsnIDogY2hrLCAncG9zJyA6IHBvcywgJ29iaicgOiBvYmogJiYgb2JqLmlkID8gb2JqLmlkIDogZmFsc2UsICdwYXInIDogcGFyICYmIHBhci5pZCA/IHBhci5pZCA6IGZhbHNlIH0pIH07XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHRtcC5mdW5jdGlvbnNbY2hrXTtcblx0XHRcdH1cblx0XHRcdGlmKGNoYyA9PT0gZmFsc2UgfHwgKCQuaXNGdW5jdGlvbihjaGMpICYmIGNoYy5jYWxsKHRoaXMsIGNoaywgb2JqLCBwYXIsIHBvcywgbW9yZSkgPT09IGZhbHNlKSB8fCAoY2hjICYmIGNoY1tjaGtdID09PSBmYWxzZSkpIHtcblx0XHRcdFx0dGhpcy5fZGF0YS5jb3JlLmxhc3RfZXJyb3IgPSB7ICdlcnJvcicgOiAnY2hlY2snLCAncGx1Z2luJyA6ICdjb3JlJywgJ2lkJyA6ICdjb3JlXzAzJywgJ3JlYXNvbicgOiAnVXNlciBjb25maWcgZm9yIGNvcmUuY2hlY2tfY2FsbGJhY2sgcHJldmVudHMgZnVuY3Rpb246ICcgKyBjaGssICdkYXRhJyA6IEpTT04uc3RyaW5naWZ5KHsgJ2NoaycgOiBjaGssICdwb3MnIDogcG9zLCAnb2JqJyA6IG9iaiAmJiBvYmouaWQgPyBvYmouaWQgOiBmYWxzZSwgJ3BhcicgOiBwYXIgJiYgcGFyLmlkID8gcGFyLmlkIDogZmFsc2UgfSkgfTtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fSxcblx0XHQvKipcblx0XHQgKiBnZXQgdGhlIGxhc3QgZXJyb3Jcblx0XHQgKiBAbmFtZSBsYXN0X2Vycm9yKClcblx0XHQgKiBAcmV0dXJuIHtPYmplY3R9XG5cdFx0ICovXG5cdFx0bGFzdF9lcnJvciA6IGZ1bmN0aW9uICgpIHtcblx0XHRcdHJldHVybiB0aGlzLl9kYXRhLmNvcmUubGFzdF9lcnJvcjtcblx0XHR9LFxuXHRcdC8qKlxuXHRcdCAqIG1vdmUgYSBub2RlIHRvIGEgbmV3IHBhcmVudFxuXHRcdCAqIEBuYW1lIG1vdmVfbm9kZShvYmosIHBhciBbLCBwb3MsIGNhbGxiYWNrLCBpc19sb2FkZWRdKVxuXHRcdCAqIEBwYXJhbSAge21peGVkfSBvYmogdGhlIG5vZGUgdG8gbW92ZSwgcGFzcyBhbiBhcnJheSB0byBtb3ZlIG11bHRpcGxlIG5vZGVzXG5cdFx0ICogQHBhcmFtICB7bWl4ZWR9IHBhciB0aGUgbmV3IHBhcmVudFxuXHRcdCAqIEBwYXJhbSAge21peGVkfSBwb3MgdGhlIHBvc2l0aW9uIHRvIGluc2VydCBhdCAoYmVzaWRlcyBpbnRlZ2VyIHZhbHVlcywgXCJmaXJzdFwiIGFuZCBcImxhc3RcIiBhcmUgc3VwcG9ydGVkLCBhcyB3ZWxsIGFzIFwiYmVmb3JlXCIgYW5kIFwiYWZ0ZXJcIiksIGRlZmF1bHRzIHRvIGludGVnZXIgYDBgXG5cdFx0ICogQHBhcmFtICB7ZnVuY3Rpb259IGNhbGxiYWNrIGEgZnVuY3Rpb24gdG8gY2FsbCBvbmNlIHRoZSBtb3ZlIGlzIGNvbXBsZXRlZCwgcmVjZWl2ZXMgMyBhcmd1bWVudHMgLSB0aGUgbm9kZSwgdGhlIG5ldyBwYXJlbnQgYW5kIHRoZSBwb3NpdGlvblxuXHRcdCAqIEBwYXJhbSAge0Jvb2xlYW59IGlzX2xvYWRlZCBpbnRlcm5hbCBwYXJhbWV0ZXIgaW5kaWNhdGluZyBpZiB0aGUgcGFyZW50IG5vZGUgaGFzIGJlZW4gbG9hZGVkXG5cdFx0ICogQHBhcmFtICB7Qm9vbGVhbn0gc2tpcF9yZWRyYXcgaW50ZXJuYWwgcGFyYW1ldGVyIGluZGljYXRpbmcgaWYgdGhlIHRyZWUgc2hvdWxkIGJlIHJlZHJhd25cblx0XHQgKiBAcGFyYW0gIHtCb29sZWFufSBpbnN0YW5jZSBpbnRlcm5hbCBwYXJhbWV0ZXIgaW5kaWNhdGluZyBpZiB0aGUgbm9kZSBjb21lcyBmcm9tIGFub3RoZXIgaW5zdGFuY2Vcblx0XHQgKiBAdHJpZ2dlciBtb3ZlX25vZGUuanN0cmVlXG5cdFx0ICovXG5cdFx0bW92ZV9ub2RlIDogZnVuY3Rpb24gKG9iaiwgcGFyLCBwb3MsIGNhbGxiYWNrLCBpc19sb2FkZWQsIHNraXBfcmVkcmF3LCBvcmlnaW4pIHtcblx0XHRcdHZhciB0MSwgdDIsIG9sZF9wYXIsIG9sZF9wb3MsIG5ld19wYXIsIG9sZF9pbnMsIGlzX211bHRpLCBkcGMsIHRtcCwgaSwgaiwgaywgbCwgcDtcblxuXHRcdFx0cGFyID0gdGhpcy5nZXRfbm9kZShwYXIpO1xuXHRcdFx0cG9zID0gcG9zID09PSB1bmRlZmluZWQgPyAwIDogcG9zO1xuXHRcdFx0aWYoIXBhcikgeyByZXR1cm4gZmFsc2U7IH1cblx0XHRcdGlmKCFwb3MudG9TdHJpbmcoKS5tYXRjaCgvXihiZWZvcmV8YWZ0ZXIpJC8pICYmICFpc19sb2FkZWQgJiYgIXRoaXMuaXNfbG9hZGVkKHBhcikpIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMubG9hZF9ub2RlKHBhciwgZnVuY3Rpb24gKCkgeyB0aGlzLm1vdmVfbm9kZShvYmosIHBhciwgcG9zLCBjYWxsYmFjaywgdHJ1ZSwgZmFsc2UsIG9yaWdpbik7IH0pO1xuXHRcdFx0fVxuXG5cdFx0XHRpZigkLmlzQXJyYXkob2JqKSkge1xuXHRcdFx0XHRpZihvYmoubGVuZ3RoID09PSAxKSB7XG5cdFx0XHRcdFx0b2JqID0gb2JqWzBdO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdC8vb2JqID0gb2JqLnNsaWNlKCk7XG5cdFx0XHRcdFx0Zm9yKHQxID0gMCwgdDIgPSBvYmoubGVuZ3RoOyB0MSA8IHQyOyB0MSsrKSB7XG5cdFx0XHRcdFx0XHRpZigodG1wID0gdGhpcy5tb3ZlX25vZGUob2JqW3QxXSwgcGFyLCBwb3MsIGNhbGxiYWNrLCBpc19sb2FkZWQsIGZhbHNlLCBvcmlnaW4pKSkge1xuXHRcdFx0XHRcdFx0XHRwYXIgPSB0bXA7XG5cdFx0XHRcdFx0XHRcdHBvcyA9IFwiYWZ0ZXJcIjtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0dGhpcy5yZWRyYXcoKTtcblx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0b2JqID0gb2JqICYmIG9iai5pZCA/IG9iaiA6IHRoaXMuZ2V0X25vZGUob2JqKTtcblxuXHRcdFx0aWYoIW9iaiB8fCBvYmouaWQgPT09ICQuanN0cmVlLnJvb3QpIHsgcmV0dXJuIGZhbHNlOyB9XG5cblx0XHRcdG9sZF9wYXIgPSAob2JqLnBhcmVudCB8fCAkLmpzdHJlZS5yb290KS50b1N0cmluZygpO1xuXHRcdFx0bmV3X3BhciA9ICghcG9zLnRvU3RyaW5nKCkubWF0Y2goL14oYmVmb3JlfGFmdGVyKSQvKSB8fCBwYXIuaWQgPT09ICQuanN0cmVlLnJvb3QpID8gcGFyIDogdGhpcy5nZXRfbm9kZShwYXIucGFyZW50KTtcblx0XHRcdG9sZF9pbnMgPSBvcmlnaW4gPyBvcmlnaW4gOiAodGhpcy5fbW9kZWwuZGF0YVtvYmouaWRdID8gdGhpcyA6ICQuanN0cmVlLnJlZmVyZW5jZShvYmouaWQpKTtcblx0XHRcdGlzX211bHRpID0gIW9sZF9pbnMgfHwgIW9sZF9pbnMuX2lkIHx8ICh0aGlzLl9pZCAhPT0gb2xkX2lucy5faWQpO1xuXHRcdFx0b2xkX3BvcyA9IG9sZF9pbnMgJiYgb2xkX2lucy5faWQgJiYgb2xkX3BhciAmJiBvbGRfaW5zLl9tb2RlbC5kYXRhW29sZF9wYXJdICYmIG9sZF9pbnMuX21vZGVsLmRhdGFbb2xkX3Bhcl0uY2hpbGRyZW4gPyAkLmluQXJyYXkob2JqLmlkLCBvbGRfaW5zLl9tb2RlbC5kYXRhW29sZF9wYXJdLmNoaWxkcmVuKSA6IC0xO1xuXHRcdFx0aWYob2xkX2lucyAmJiBvbGRfaW5zLl9pZCkge1xuXHRcdFx0XHRvYmogPSBvbGRfaW5zLl9tb2RlbC5kYXRhW29iai5pZF07XG5cdFx0XHR9XG5cblx0XHRcdGlmKGlzX211bHRpKSB7XG5cdFx0XHRcdGlmKCh0bXAgPSB0aGlzLmNvcHlfbm9kZShvYmosIHBhciwgcG9zLCBjYWxsYmFjaywgaXNfbG9hZGVkLCBmYWxzZSwgb3JpZ2luKSkpIHtcblx0XHRcdFx0XHRpZihvbGRfaW5zKSB7IG9sZF9pbnMuZGVsZXRlX25vZGUob2JqKTsgfVxuXHRcdFx0XHRcdHJldHVybiB0bXA7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXHRcdFx0Ly92YXIgbSA9IHRoaXMuX21vZGVsLmRhdGE7XG5cdFx0XHRpZihwYXIuaWQgPT09ICQuanN0cmVlLnJvb3QpIHtcblx0XHRcdFx0aWYocG9zID09PSBcImJlZm9yZVwiKSB7IHBvcyA9IFwiZmlyc3RcIjsgfVxuXHRcdFx0XHRpZihwb3MgPT09IFwiYWZ0ZXJcIikgeyBwb3MgPSBcImxhc3RcIjsgfVxuXHRcdFx0fVxuXHRcdFx0c3dpdGNoKHBvcykge1xuXHRcdFx0XHRjYXNlIFwiYmVmb3JlXCI6XG5cdFx0XHRcdFx0cG9zID0gJC5pbkFycmF5KHBhci5pZCwgbmV3X3Bhci5jaGlsZHJlbik7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGNhc2UgXCJhZnRlclwiIDpcblx0XHRcdFx0XHRwb3MgPSAkLmluQXJyYXkocGFyLmlkLCBuZXdfcGFyLmNoaWxkcmVuKSArIDE7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGNhc2UgXCJpbnNpZGVcIjpcblx0XHRcdFx0Y2FzZSBcImZpcnN0XCI6XG5cdFx0XHRcdFx0cG9zID0gMDtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0Y2FzZSBcImxhc3RcIjpcblx0XHRcdFx0XHRwb3MgPSBuZXdfcGFyLmNoaWxkcmVuLmxlbmd0aDtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0XHRpZighcG9zKSB7IHBvcyA9IDA7IH1cblx0XHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHRcdGlmKHBvcyA+IG5ld19wYXIuY2hpbGRyZW4ubGVuZ3RoKSB7IHBvcyA9IG5ld19wYXIuY2hpbGRyZW4ubGVuZ3RoOyB9XG5cdFx0XHRpZighdGhpcy5jaGVjayhcIm1vdmVfbm9kZVwiLCBvYmosIG5ld19wYXIsIHBvcywgeyAnY29yZScgOiB0cnVlLCAnb3JpZ2luJyA6IG9yaWdpbiwgJ2lzX211bHRpJyA6IChvbGRfaW5zICYmIG9sZF9pbnMuX2lkICYmIG9sZF9pbnMuX2lkICE9PSB0aGlzLl9pZCksICdpc19mb3JlaWduJyA6ICghb2xkX2lucyB8fCAhb2xkX2lucy5faWQpIH0pKSB7XG5cdFx0XHRcdHRoaXMuc2V0dGluZ3MuY29yZS5lcnJvci5jYWxsKHRoaXMsIHRoaXMuX2RhdGEuY29yZS5sYXN0X2Vycm9yKTtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXHRcdFx0aWYob2JqLnBhcmVudCA9PT0gbmV3X3Bhci5pZCkge1xuXHRcdFx0XHRkcGMgPSBuZXdfcGFyLmNoaWxkcmVuLmNvbmNhdCgpO1xuXHRcdFx0XHR0bXAgPSAkLmluQXJyYXkob2JqLmlkLCBkcGMpO1xuXHRcdFx0XHRpZih0bXAgIT09IC0xKSB7XG5cdFx0XHRcdFx0ZHBjID0gJC52YWthdGEuYXJyYXlfcmVtb3ZlKGRwYywgdG1wKTtcblx0XHRcdFx0XHRpZihwb3MgPiB0bXApIHsgcG9zLS07IH1cblx0XHRcdFx0fVxuXHRcdFx0XHR0bXAgPSBbXTtcblx0XHRcdFx0Zm9yKGkgPSAwLCBqID0gZHBjLmxlbmd0aDsgaSA8IGo7IGkrKykge1xuXHRcdFx0XHRcdHRtcFtpID49IHBvcyA/IGkrMSA6IGldID0gZHBjW2ldO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRtcFtwb3NdID0gb2JqLmlkO1xuXHRcdFx0XHRuZXdfcGFyLmNoaWxkcmVuID0gdG1wO1xuXHRcdFx0XHR0aGlzLl9ub2RlX2NoYW5nZWQobmV3X3Bhci5pZCk7XG5cdFx0XHRcdHRoaXMucmVkcmF3KG5ld19wYXIuaWQgPT09ICQuanN0cmVlLnJvb3QpO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSB7XG5cdFx0XHRcdC8vIGNsZWFuIG9sZCBwYXJlbnQgYW5kIHVwXG5cdFx0XHRcdHRtcCA9IG9iai5jaGlsZHJlbl9kLmNvbmNhdCgpO1xuXHRcdFx0XHR0bXAucHVzaChvYmouaWQpO1xuXHRcdFx0XHRmb3IoaSA9IDAsIGogPSBvYmoucGFyZW50cy5sZW5ndGg7IGkgPCBqOyBpKyspIHtcblx0XHRcdFx0XHRkcGMgPSBbXTtcblx0XHRcdFx0XHRwID0gb2xkX2lucy5fbW9kZWwuZGF0YVtvYmoucGFyZW50c1tpXV0uY2hpbGRyZW5fZDtcblx0XHRcdFx0XHRmb3IoayA9IDAsIGwgPSBwLmxlbmd0aDsgayA8IGw7IGsrKykge1xuXHRcdFx0XHRcdFx0aWYoJC5pbkFycmF5KHBba10sIHRtcCkgPT09IC0xKSB7XG5cdFx0XHRcdFx0XHRcdGRwYy5wdXNoKHBba10pO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRvbGRfaW5zLl9tb2RlbC5kYXRhW29iai5wYXJlbnRzW2ldXS5jaGlsZHJlbl9kID0gZHBjO1xuXHRcdFx0XHR9XG5cdFx0XHRcdG9sZF9pbnMuX21vZGVsLmRhdGFbb2xkX3Bhcl0uY2hpbGRyZW4gPSAkLnZha2F0YS5hcnJheV9yZW1vdmVfaXRlbShvbGRfaW5zLl9tb2RlbC5kYXRhW29sZF9wYXJdLmNoaWxkcmVuLCBvYmouaWQpO1xuXG5cdFx0XHRcdC8vIGluc2VydCBpbnRvIG5ldyBwYXJlbnQgYW5kIHVwXG5cdFx0XHRcdGZvcihpID0gMCwgaiA9IG5ld19wYXIucGFyZW50cy5sZW5ndGg7IGkgPCBqOyBpKyspIHtcblx0XHRcdFx0XHR0aGlzLl9tb2RlbC5kYXRhW25ld19wYXIucGFyZW50c1tpXV0uY2hpbGRyZW5fZCA9IHRoaXMuX21vZGVsLmRhdGFbbmV3X3Bhci5wYXJlbnRzW2ldXS5jaGlsZHJlbl9kLmNvbmNhdCh0bXApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGRwYyA9IFtdO1xuXHRcdFx0XHRmb3IoaSA9IDAsIGogPSBuZXdfcGFyLmNoaWxkcmVuLmxlbmd0aDsgaSA8IGo7IGkrKykge1xuXHRcdFx0XHRcdGRwY1tpID49IHBvcyA/IGkrMSA6IGldID0gbmV3X3Bhci5jaGlsZHJlbltpXTtcblx0XHRcdFx0fVxuXHRcdFx0XHRkcGNbcG9zXSA9IG9iai5pZDtcblx0XHRcdFx0bmV3X3Bhci5jaGlsZHJlbiA9IGRwYztcblx0XHRcdFx0bmV3X3Bhci5jaGlsZHJlbl9kLnB1c2gob2JqLmlkKTtcblx0XHRcdFx0bmV3X3Bhci5jaGlsZHJlbl9kID0gbmV3X3Bhci5jaGlsZHJlbl9kLmNvbmNhdChvYmouY2hpbGRyZW5fZCk7XG5cblx0XHRcdFx0Ly8gdXBkYXRlIG9iamVjdFxuXHRcdFx0XHRvYmoucGFyZW50ID0gbmV3X3Bhci5pZDtcblx0XHRcdFx0dG1wID0gbmV3X3Bhci5wYXJlbnRzLmNvbmNhdCgpO1xuXHRcdFx0XHR0bXAudW5zaGlmdChuZXdfcGFyLmlkKTtcblx0XHRcdFx0cCA9IG9iai5wYXJlbnRzLmxlbmd0aDtcblx0XHRcdFx0b2JqLnBhcmVudHMgPSB0bXA7XG5cblx0XHRcdFx0Ly8gdXBkYXRlIG9iamVjdCBjaGlsZHJlblxuXHRcdFx0XHR0bXAgPSB0bXAuY29uY2F0KCk7XG5cdFx0XHRcdGZvcihpID0gMCwgaiA9IG9iai5jaGlsZHJlbl9kLmxlbmd0aDsgaSA8IGo7IGkrKykge1xuXHRcdFx0XHRcdHRoaXMuX21vZGVsLmRhdGFbb2JqLmNoaWxkcmVuX2RbaV1dLnBhcmVudHMgPSB0aGlzLl9tb2RlbC5kYXRhW29iai5jaGlsZHJlbl9kW2ldXS5wYXJlbnRzLnNsaWNlKDAscCotMSk7XG5cdFx0XHRcdFx0QXJyYXkucHJvdG90eXBlLnB1c2guYXBwbHkodGhpcy5fbW9kZWwuZGF0YVtvYmouY2hpbGRyZW5fZFtpXV0ucGFyZW50cywgdG1wKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmKG9sZF9wYXIgPT09ICQuanN0cmVlLnJvb3QgfHwgbmV3X3Bhci5pZCA9PT0gJC5qc3RyZWUucm9vdCkge1xuXHRcdFx0XHRcdHRoaXMuX21vZGVsLmZvcmNlX2Z1bGxfcmVkcmF3ID0gdHJ1ZTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZighdGhpcy5fbW9kZWwuZm9yY2VfZnVsbF9yZWRyYXcpIHtcblx0XHRcdFx0XHR0aGlzLl9ub2RlX2NoYW5nZWQob2xkX3Bhcik7XG5cdFx0XHRcdFx0dGhpcy5fbm9kZV9jaGFuZ2VkKG5ld19wYXIuaWQpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmKCFza2lwX3JlZHJhdykge1xuXHRcdFx0XHRcdHRoaXMucmVkcmF3KCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGlmKGNhbGxiYWNrKSB7IGNhbGxiYWNrLmNhbGwodGhpcywgb2JqLCBuZXdfcGFyLCBwb3MpOyB9XG5cdFx0XHQvKipcblx0XHRcdCAqIHRyaWdnZXJlZCB3aGVuIGEgbm9kZSBpcyBtb3ZlZFxuXHRcdFx0ICogQGV2ZW50XG5cdFx0XHQgKiBAbmFtZSBtb3ZlX25vZGUuanN0cmVlXG5cdFx0XHQgKiBAcGFyYW0ge09iamVjdH0gbm9kZVxuXHRcdFx0ICogQHBhcmFtIHtTdHJpbmd9IHBhcmVudCB0aGUgcGFyZW50J3MgSURcblx0XHRcdCAqIEBwYXJhbSB7TnVtYmVyfSBwb3NpdGlvbiB0aGUgcG9zaXRpb24gb2YgdGhlIG5vZGUgYW1vbmcgdGhlIHBhcmVudCdzIGNoaWxkcmVuXG5cdFx0XHQgKiBAcGFyYW0ge1N0cmluZ30gb2xkX3BhcmVudCB0aGUgb2xkIHBhcmVudCBvZiB0aGUgbm9kZVxuXHRcdFx0ICogQHBhcmFtIHtOdW1iZXJ9IG9sZF9wb3NpdGlvbiB0aGUgb2xkIHBvc2l0aW9uIG9mIHRoZSBub2RlXG5cdFx0XHQgKiBAcGFyYW0ge0Jvb2xlYW59IGlzX211bHRpIGRvIHRoZSBub2RlIGFuZCBuZXcgcGFyZW50IGJlbG9uZyB0byBkaWZmZXJlbnQgaW5zdGFuY2VzXG5cdFx0XHQgKiBAcGFyYW0ge2pzVHJlZX0gb2xkX2luc3RhbmNlIHRoZSBpbnN0YW5jZSB0aGUgbm9kZSBjYW1lIGZyb21cblx0XHRcdCAqIEBwYXJhbSB7anNUcmVlfSBuZXdfaW5zdGFuY2UgdGhlIGluc3RhbmNlIG9mIHRoZSBuZXcgcGFyZW50XG5cdFx0XHQgKi9cblx0XHRcdHRoaXMudHJpZ2dlcignbW92ZV9ub2RlJywgeyBcIm5vZGVcIiA6IG9iaiwgXCJwYXJlbnRcIiA6IG5ld19wYXIuaWQsIFwicG9zaXRpb25cIiA6IHBvcywgXCJvbGRfcGFyZW50XCIgOiBvbGRfcGFyLCBcIm9sZF9wb3NpdGlvblwiIDogb2xkX3BvcywgJ2lzX211bHRpJyA6IChvbGRfaW5zICYmIG9sZF9pbnMuX2lkICYmIG9sZF9pbnMuX2lkICE9PSB0aGlzLl9pZCksICdpc19mb3JlaWduJyA6ICghb2xkX2lucyB8fCAhb2xkX2lucy5faWQpLCAnb2xkX2luc3RhbmNlJyA6IG9sZF9pbnMsICduZXdfaW5zdGFuY2UnIDogdGhpcyB9KTtcblx0XHRcdHJldHVybiBvYmouaWQ7XG5cdFx0fSxcblx0XHQvKipcblx0XHQgKiBjb3B5IGEgbm9kZSB0byBhIG5ldyBwYXJlbnRcblx0XHQgKiBAbmFtZSBjb3B5X25vZGUob2JqLCBwYXIgWywgcG9zLCBjYWxsYmFjaywgaXNfbG9hZGVkXSlcblx0XHQgKiBAcGFyYW0gIHttaXhlZH0gb2JqIHRoZSBub2RlIHRvIGNvcHksIHBhc3MgYW4gYXJyYXkgdG8gY29weSBtdWx0aXBsZSBub2Rlc1xuXHRcdCAqIEBwYXJhbSAge21peGVkfSBwYXIgdGhlIG5ldyBwYXJlbnRcblx0XHQgKiBAcGFyYW0gIHttaXhlZH0gcG9zIHRoZSBwb3NpdGlvbiB0byBpbnNlcnQgYXQgKGJlc2lkZXMgaW50ZWdlciB2YWx1ZXMsIFwiZmlyc3RcIiBhbmQgXCJsYXN0XCIgYXJlIHN1cHBvcnRlZCwgYXMgd2VsbCBhcyBcImJlZm9yZVwiIGFuZCBcImFmdGVyXCIpLCBkZWZhdWx0cyB0byBpbnRlZ2VyIGAwYFxuXHRcdCAqIEBwYXJhbSAge2Z1bmN0aW9ufSBjYWxsYmFjayBhIGZ1bmN0aW9uIHRvIGNhbGwgb25jZSB0aGUgbW92ZSBpcyBjb21wbGV0ZWQsIHJlY2VpdmVzIDMgYXJndW1lbnRzIC0gdGhlIG5vZGUsIHRoZSBuZXcgcGFyZW50IGFuZCB0aGUgcG9zaXRpb25cblx0XHQgKiBAcGFyYW0gIHtCb29sZWFufSBpc19sb2FkZWQgaW50ZXJuYWwgcGFyYW1ldGVyIGluZGljYXRpbmcgaWYgdGhlIHBhcmVudCBub2RlIGhhcyBiZWVuIGxvYWRlZFxuXHRcdCAqIEBwYXJhbSAge0Jvb2xlYW59IHNraXBfcmVkcmF3IGludGVybmFsIHBhcmFtZXRlciBpbmRpY2F0aW5nIGlmIHRoZSB0cmVlIHNob3VsZCBiZSByZWRyYXduXG5cdFx0ICogQHBhcmFtICB7Qm9vbGVhbn0gaW5zdGFuY2UgaW50ZXJuYWwgcGFyYW1ldGVyIGluZGljYXRpbmcgaWYgdGhlIG5vZGUgY29tZXMgZnJvbSBhbm90aGVyIGluc3RhbmNlXG5cdFx0ICogQHRyaWdnZXIgbW9kZWwuanN0cmVlIGNvcHlfbm9kZS5qc3RyZWVcblx0XHQgKi9cblx0XHRjb3B5X25vZGUgOiBmdW5jdGlvbiAob2JqLCBwYXIsIHBvcywgY2FsbGJhY2ssIGlzX2xvYWRlZCwgc2tpcF9yZWRyYXcsIG9yaWdpbikge1xuXHRcdFx0dmFyIHQxLCB0MiwgZHBjLCB0bXAsIGksIGosIG5vZGUsIG9sZF9wYXIsIG5ld19wYXIsIG9sZF9pbnMsIGlzX211bHRpO1xuXG5cdFx0XHRwYXIgPSB0aGlzLmdldF9ub2RlKHBhcik7XG5cdFx0XHRwb3MgPSBwb3MgPT09IHVuZGVmaW5lZCA/IDAgOiBwb3M7XG5cdFx0XHRpZighcGFyKSB7IHJldHVybiBmYWxzZTsgfVxuXHRcdFx0aWYoIXBvcy50b1N0cmluZygpLm1hdGNoKC9eKGJlZm9yZXxhZnRlcikkLykgJiYgIWlzX2xvYWRlZCAmJiAhdGhpcy5pc19sb2FkZWQocGFyKSkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5sb2FkX25vZGUocGFyLCBmdW5jdGlvbiAoKSB7IHRoaXMuY29weV9ub2RlKG9iaiwgcGFyLCBwb3MsIGNhbGxiYWNrLCB0cnVlLCBmYWxzZSwgb3JpZ2luKTsgfSk7XG5cdFx0XHR9XG5cblx0XHRcdGlmKCQuaXNBcnJheShvYmopKSB7XG5cdFx0XHRcdGlmKG9iai5sZW5ndGggPT09IDEpIHtcblx0XHRcdFx0XHRvYmogPSBvYmpbMF07XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0Ly9vYmogPSBvYmouc2xpY2UoKTtcblx0XHRcdFx0XHRmb3IodDEgPSAwLCB0MiA9IG9iai5sZW5ndGg7IHQxIDwgdDI7IHQxKyspIHtcblx0XHRcdFx0XHRcdGlmKCh0bXAgPSB0aGlzLmNvcHlfbm9kZShvYmpbdDFdLCBwYXIsIHBvcywgY2FsbGJhY2ssIGlzX2xvYWRlZCwgdHJ1ZSwgb3JpZ2luKSkpIHtcblx0XHRcdFx0XHRcdFx0cGFyID0gdG1wO1xuXHRcdFx0XHRcdFx0XHRwb3MgPSBcImFmdGVyXCI7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHRoaXMucmVkcmF3KCk7XG5cdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdG9iaiA9IG9iaiAmJiBvYmouaWQgPyBvYmogOiB0aGlzLmdldF9ub2RlKG9iaik7XG5cdFx0XHRpZighb2JqIHx8IG9iai5pZCA9PT0gJC5qc3RyZWUucm9vdCkgeyByZXR1cm4gZmFsc2U7IH1cblxuXHRcdFx0b2xkX3BhciA9IChvYmoucGFyZW50IHx8ICQuanN0cmVlLnJvb3QpLnRvU3RyaW5nKCk7XG5cdFx0XHRuZXdfcGFyID0gKCFwb3MudG9TdHJpbmcoKS5tYXRjaCgvXihiZWZvcmV8YWZ0ZXIpJC8pIHx8IHBhci5pZCA9PT0gJC5qc3RyZWUucm9vdCkgPyBwYXIgOiB0aGlzLmdldF9ub2RlKHBhci5wYXJlbnQpO1xuXHRcdFx0b2xkX2lucyA9IG9yaWdpbiA/IG9yaWdpbiA6ICh0aGlzLl9tb2RlbC5kYXRhW29iai5pZF0gPyB0aGlzIDogJC5qc3RyZWUucmVmZXJlbmNlKG9iai5pZCkpO1xuXHRcdFx0aXNfbXVsdGkgPSAhb2xkX2lucyB8fCAhb2xkX2lucy5faWQgfHwgKHRoaXMuX2lkICE9PSBvbGRfaW5zLl9pZCk7XG5cblx0XHRcdGlmKG9sZF9pbnMgJiYgb2xkX2lucy5faWQpIHtcblx0XHRcdFx0b2JqID0gb2xkX2lucy5fbW9kZWwuZGF0YVtvYmouaWRdO1xuXHRcdFx0fVxuXG5cdFx0XHRpZihwYXIuaWQgPT09ICQuanN0cmVlLnJvb3QpIHtcblx0XHRcdFx0aWYocG9zID09PSBcImJlZm9yZVwiKSB7IHBvcyA9IFwiZmlyc3RcIjsgfVxuXHRcdFx0XHRpZihwb3MgPT09IFwiYWZ0ZXJcIikgeyBwb3MgPSBcImxhc3RcIjsgfVxuXHRcdFx0fVxuXHRcdFx0c3dpdGNoKHBvcykge1xuXHRcdFx0XHRjYXNlIFwiYmVmb3JlXCI6XG5cdFx0XHRcdFx0cG9zID0gJC5pbkFycmF5KHBhci5pZCwgbmV3X3Bhci5jaGlsZHJlbik7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGNhc2UgXCJhZnRlclwiIDpcblx0XHRcdFx0XHRwb3MgPSAkLmluQXJyYXkocGFyLmlkLCBuZXdfcGFyLmNoaWxkcmVuKSArIDE7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGNhc2UgXCJpbnNpZGVcIjpcblx0XHRcdFx0Y2FzZSBcImZpcnN0XCI6XG5cdFx0XHRcdFx0cG9zID0gMDtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0Y2FzZSBcImxhc3RcIjpcblx0XHRcdFx0XHRwb3MgPSBuZXdfcGFyLmNoaWxkcmVuLmxlbmd0aDtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0XHRpZighcG9zKSB7IHBvcyA9IDA7IH1cblx0XHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHRcdGlmKHBvcyA+IG5ld19wYXIuY2hpbGRyZW4ubGVuZ3RoKSB7IHBvcyA9IG5ld19wYXIuY2hpbGRyZW4ubGVuZ3RoOyB9XG5cdFx0XHRpZighdGhpcy5jaGVjayhcImNvcHlfbm9kZVwiLCBvYmosIG5ld19wYXIsIHBvcywgeyAnY29yZScgOiB0cnVlLCAnb3JpZ2luJyA6IG9yaWdpbiwgJ2lzX211bHRpJyA6IChvbGRfaW5zICYmIG9sZF9pbnMuX2lkICYmIG9sZF9pbnMuX2lkICE9PSB0aGlzLl9pZCksICdpc19mb3JlaWduJyA6ICghb2xkX2lucyB8fCAhb2xkX2lucy5faWQpIH0pKSB7XG5cdFx0XHRcdHRoaXMuc2V0dGluZ3MuY29yZS5lcnJvci5jYWxsKHRoaXMsIHRoaXMuX2RhdGEuY29yZS5sYXN0X2Vycm9yKTtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXHRcdFx0bm9kZSA9IG9sZF9pbnMgPyBvbGRfaW5zLmdldF9qc29uKG9iaiwgeyBub19pZCA6IHRydWUsIG5vX2RhdGEgOiB0cnVlLCBub19zdGF0ZSA6IHRydWUgfSkgOiBvYmo7XG5cdFx0XHRpZighbm9kZSkgeyByZXR1cm4gZmFsc2U7IH1cblx0XHRcdGlmKG5vZGUuaWQgPT09IHRydWUpIHsgZGVsZXRlIG5vZGUuaWQ7IH1cblx0XHRcdG5vZGUgPSB0aGlzLl9wYXJzZV9tb2RlbF9mcm9tX2pzb24obm9kZSwgbmV3X3Bhci5pZCwgbmV3X3Bhci5wYXJlbnRzLmNvbmNhdCgpKTtcblx0XHRcdGlmKCFub2RlKSB7IHJldHVybiBmYWxzZTsgfVxuXHRcdFx0dG1wID0gdGhpcy5nZXRfbm9kZShub2RlKTtcblx0XHRcdGlmKG9iaiAmJiBvYmouc3RhdGUgJiYgb2JqLnN0YXRlLmxvYWRlZCA9PT0gZmFsc2UpIHsgdG1wLnN0YXRlLmxvYWRlZCA9IGZhbHNlOyB9XG5cdFx0XHRkcGMgPSBbXTtcblx0XHRcdGRwYy5wdXNoKG5vZGUpO1xuXHRcdFx0ZHBjID0gZHBjLmNvbmNhdCh0bXAuY2hpbGRyZW5fZCk7XG5cdFx0XHR0aGlzLnRyaWdnZXIoJ21vZGVsJywgeyBcIm5vZGVzXCIgOiBkcGMsIFwicGFyZW50XCIgOiBuZXdfcGFyLmlkIH0pO1xuXG5cdFx0XHQvLyBpbnNlcnQgaW50byBuZXcgcGFyZW50IGFuZCB1cFxuXHRcdFx0Zm9yKGkgPSAwLCBqID0gbmV3X3Bhci5wYXJlbnRzLmxlbmd0aDsgaSA8IGo7IGkrKykge1xuXHRcdFx0XHR0aGlzLl9tb2RlbC5kYXRhW25ld19wYXIucGFyZW50c1tpXV0uY2hpbGRyZW5fZCA9IHRoaXMuX21vZGVsLmRhdGFbbmV3X3Bhci5wYXJlbnRzW2ldXS5jaGlsZHJlbl9kLmNvbmNhdChkcGMpO1xuXHRcdFx0fVxuXHRcdFx0ZHBjID0gW107XG5cdFx0XHRmb3IoaSA9IDAsIGogPSBuZXdfcGFyLmNoaWxkcmVuLmxlbmd0aDsgaSA8IGo7IGkrKykge1xuXHRcdFx0XHRkcGNbaSA+PSBwb3MgPyBpKzEgOiBpXSA9IG5ld19wYXIuY2hpbGRyZW5baV07XG5cdFx0XHR9XG5cdFx0XHRkcGNbcG9zXSA9IHRtcC5pZDtcblx0XHRcdG5ld19wYXIuY2hpbGRyZW4gPSBkcGM7XG5cdFx0XHRuZXdfcGFyLmNoaWxkcmVuX2QucHVzaCh0bXAuaWQpO1xuXHRcdFx0bmV3X3Bhci5jaGlsZHJlbl9kID0gbmV3X3Bhci5jaGlsZHJlbl9kLmNvbmNhdCh0bXAuY2hpbGRyZW5fZCk7XG5cblx0XHRcdGlmKG5ld19wYXIuaWQgPT09ICQuanN0cmVlLnJvb3QpIHtcblx0XHRcdFx0dGhpcy5fbW9kZWwuZm9yY2VfZnVsbF9yZWRyYXcgPSB0cnVlO1xuXHRcdFx0fVxuXHRcdFx0aWYoIXRoaXMuX21vZGVsLmZvcmNlX2Z1bGxfcmVkcmF3KSB7XG5cdFx0XHRcdHRoaXMuX25vZGVfY2hhbmdlZChuZXdfcGFyLmlkKTtcblx0XHRcdH1cblx0XHRcdGlmKCFza2lwX3JlZHJhdykge1xuXHRcdFx0XHR0aGlzLnJlZHJhdyhuZXdfcGFyLmlkID09PSAkLmpzdHJlZS5yb290KTtcblx0XHRcdH1cblx0XHRcdGlmKGNhbGxiYWNrKSB7IGNhbGxiYWNrLmNhbGwodGhpcywgdG1wLCBuZXdfcGFyLCBwb3MpOyB9XG5cdFx0XHQvKipcblx0XHRcdCAqIHRyaWdnZXJlZCB3aGVuIGEgbm9kZSBpcyBjb3BpZWRcblx0XHRcdCAqIEBldmVudFxuXHRcdFx0ICogQG5hbWUgY29weV9ub2RlLmpzdHJlZVxuXHRcdFx0ICogQHBhcmFtIHtPYmplY3R9IG5vZGUgdGhlIGNvcGllZCBub2RlXG5cdFx0XHQgKiBAcGFyYW0ge09iamVjdH0gb3JpZ2luYWwgdGhlIG9yaWdpbmFsIG5vZGVcblx0XHRcdCAqIEBwYXJhbSB7U3RyaW5nfSBwYXJlbnQgdGhlIHBhcmVudCdzIElEXG5cdFx0XHQgKiBAcGFyYW0ge051bWJlcn0gcG9zaXRpb24gdGhlIHBvc2l0aW9uIG9mIHRoZSBub2RlIGFtb25nIHRoZSBwYXJlbnQncyBjaGlsZHJlblxuXHRcdFx0ICogQHBhcmFtIHtTdHJpbmd9IG9sZF9wYXJlbnQgdGhlIG9sZCBwYXJlbnQgb2YgdGhlIG5vZGVcblx0XHRcdCAqIEBwYXJhbSB7TnVtYmVyfSBvbGRfcG9zaXRpb24gdGhlIHBvc2l0aW9uIG9mIHRoZSBvcmlnaW5hbCBub2RlXG5cdFx0XHQgKiBAcGFyYW0ge0Jvb2xlYW59IGlzX211bHRpIGRvIHRoZSBub2RlIGFuZCBuZXcgcGFyZW50IGJlbG9uZyB0byBkaWZmZXJlbnQgaW5zdGFuY2VzXG5cdFx0XHQgKiBAcGFyYW0ge2pzVHJlZX0gb2xkX2luc3RhbmNlIHRoZSBpbnN0YW5jZSB0aGUgbm9kZSBjYW1lIGZyb21cblx0XHRcdCAqIEBwYXJhbSB7anNUcmVlfSBuZXdfaW5zdGFuY2UgdGhlIGluc3RhbmNlIG9mIHRoZSBuZXcgcGFyZW50XG5cdFx0XHQgKi9cblx0XHRcdHRoaXMudHJpZ2dlcignY29weV9ub2RlJywgeyBcIm5vZGVcIiA6IHRtcCwgXCJvcmlnaW5hbFwiIDogb2JqLCBcInBhcmVudFwiIDogbmV3X3Bhci5pZCwgXCJwb3NpdGlvblwiIDogcG9zLCBcIm9sZF9wYXJlbnRcIiA6IG9sZF9wYXIsIFwib2xkX3Bvc2l0aW9uXCIgOiBvbGRfaW5zICYmIG9sZF9pbnMuX2lkICYmIG9sZF9wYXIgJiYgb2xkX2lucy5fbW9kZWwuZGF0YVtvbGRfcGFyXSAmJiBvbGRfaW5zLl9tb2RlbC5kYXRhW29sZF9wYXJdLmNoaWxkcmVuID8gJC5pbkFycmF5KG9iai5pZCwgb2xkX2lucy5fbW9kZWwuZGF0YVtvbGRfcGFyXS5jaGlsZHJlbikgOiAtMSwnaXNfbXVsdGknIDogKG9sZF9pbnMgJiYgb2xkX2lucy5faWQgJiYgb2xkX2lucy5faWQgIT09IHRoaXMuX2lkKSwgJ2lzX2ZvcmVpZ24nIDogKCFvbGRfaW5zIHx8ICFvbGRfaW5zLl9pZCksICdvbGRfaW5zdGFuY2UnIDogb2xkX2lucywgJ25ld19pbnN0YW5jZScgOiB0aGlzIH0pO1xuXHRcdFx0cmV0dXJuIHRtcC5pZDtcblx0XHR9LFxuXHRcdC8qKlxuXHRcdCAqIGN1dCBhIG5vZGUgKGEgbGF0ZXIgY2FsbCB0byBgcGFzdGUob2JqKWAgd291bGQgbW92ZSB0aGUgbm9kZSlcblx0XHQgKiBAbmFtZSBjdXQob2JqKVxuXHRcdCAqIEBwYXJhbSAge21peGVkfSBvYmogbXVsdGlwbGUgb2JqZWN0cyBjYW4gYmUgcGFzc2VkIHVzaW5nIGFuIGFycmF5XG5cdFx0ICogQHRyaWdnZXIgY3V0LmpzdHJlZVxuXHRcdCAqL1xuXHRcdGN1dCA6IGZ1bmN0aW9uIChvYmopIHtcblx0XHRcdGlmKCFvYmopIHsgb2JqID0gdGhpcy5fZGF0YS5jb3JlLnNlbGVjdGVkLmNvbmNhdCgpOyB9XG5cdFx0XHRpZighJC5pc0FycmF5KG9iaikpIHsgb2JqID0gW29ial07IH1cblx0XHRcdGlmKCFvYmoubGVuZ3RoKSB7IHJldHVybiBmYWxzZTsgfVxuXHRcdFx0dmFyIHRtcCA9IFtdLCBvLCB0MSwgdDI7XG5cdFx0XHRmb3IodDEgPSAwLCB0MiA9IG9iai5sZW5ndGg7IHQxIDwgdDI7IHQxKyspIHtcblx0XHRcdFx0byA9IHRoaXMuZ2V0X25vZGUob2JqW3QxXSk7XG5cdFx0XHRcdGlmKG8gJiYgby5pZCAmJiBvLmlkICE9PSAkLmpzdHJlZS5yb290KSB7IHRtcC5wdXNoKG8pOyB9XG5cdFx0XHR9XG5cdFx0XHRpZighdG1wLmxlbmd0aCkgeyByZXR1cm4gZmFsc2U7IH1cblx0XHRcdGNjcF9ub2RlID0gdG1wO1xuXHRcdFx0Y2NwX2luc3QgPSB0aGlzO1xuXHRcdFx0Y2NwX21vZGUgPSAnbW92ZV9ub2RlJztcblx0XHRcdC8qKlxuXHRcdFx0ICogdHJpZ2dlcmVkIHdoZW4gbm9kZXMgYXJlIGFkZGVkIHRvIHRoZSBidWZmZXIgZm9yIG1vdmluZ1xuXHRcdFx0ICogQGV2ZW50XG5cdFx0XHQgKiBAbmFtZSBjdXQuanN0cmVlXG5cdFx0XHQgKiBAcGFyYW0ge0FycmF5fSBub2RlXG5cdFx0XHQgKi9cblx0XHRcdHRoaXMudHJpZ2dlcignY3V0JywgeyBcIm5vZGVcIiA6IG9iaiB9KTtcblx0XHR9LFxuXHRcdC8qKlxuXHRcdCAqIGNvcHkgYSBub2RlIChhIGxhdGVyIGNhbGwgdG8gYHBhc3RlKG9iailgIHdvdWxkIGNvcHkgdGhlIG5vZGUpXG5cdFx0ICogQG5hbWUgY29weShvYmopXG5cdFx0ICogQHBhcmFtICB7bWl4ZWR9IG9iaiBtdWx0aXBsZSBvYmplY3RzIGNhbiBiZSBwYXNzZWQgdXNpbmcgYW4gYXJyYXlcblx0XHQgKiBAdHJpZ2dlciBjb3B5LmpzdHJlZVxuXHRcdCAqL1xuXHRcdGNvcHkgOiBmdW5jdGlvbiAob2JqKSB7XG5cdFx0XHRpZighb2JqKSB7IG9iaiA9IHRoaXMuX2RhdGEuY29yZS5zZWxlY3RlZC5jb25jYXQoKTsgfVxuXHRcdFx0aWYoISQuaXNBcnJheShvYmopKSB7IG9iaiA9IFtvYmpdOyB9XG5cdFx0XHRpZighb2JqLmxlbmd0aCkgeyByZXR1cm4gZmFsc2U7IH1cblx0XHRcdHZhciB0bXAgPSBbXSwgbywgdDEsIHQyO1xuXHRcdFx0Zm9yKHQxID0gMCwgdDIgPSBvYmoubGVuZ3RoOyB0MSA8IHQyOyB0MSsrKSB7XG5cdFx0XHRcdG8gPSB0aGlzLmdldF9ub2RlKG9ialt0MV0pO1xuXHRcdFx0XHRpZihvICYmIG8uaWQgJiYgby5pZCAhPT0gJC5qc3RyZWUucm9vdCkgeyB0bXAucHVzaChvKTsgfVxuXHRcdFx0fVxuXHRcdFx0aWYoIXRtcC5sZW5ndGgpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdFx0XHRjY3Bfbm9kZSA9IHRtcDtcblx0XHRcdGNjcF9pbnN0ID0gdGhpcztcblx0XHRcdGNjcF9tb2RlID0gJ2NvcHlfbm9kZSc7XG5cdFx0XHQvKipcblx0XHRcdCAqIHRyaWdnZXJlZCB3aGVuIG5vZGVzIGFyZSBhZGRlZCB0byB0aGUgYnVmZmVyIGZvciBjb3B5aW5nXG5cdFx0XHQgKiBAZXZlbnRcblx0XHRcdCAqIEBuYW1lIGNvcHkuanN0cmVlXG5cdFx0XHQgKiBAcGFyYW0ge0FycmF5fSBub2RlXG5cdFx0XHQgKi9cblx0XHRcdHRoaXMudHJpZ2dlcignY29weScsIHsgXCJub2RlXCIgOiBvYmogfSk7XG5cdFx0fSxcblx0XHQvKipcblx0XHQgKiBnZXQgdGhlIGN1cnJlbnQgYnVmZmVyIChhbnkgbm9kZXMgdGhhdCBhcmUgd2FpdGluZyBmb3IgYSBwYXN0ZSBvcGVyYXRpb24pXG5cdFx0ICogQG5hbWUgZ2V0X2J1ZmZlcigpXG5cdFx0ICogQHJldHVybiB7T2JqZWN0fSBhbiBvYmplY3QgY29uc2lzdGluZyBvZiBgbW9kZWAgKFwiY29weV9ub2RlXCIgb3IgXCJtb3ZlX25vZGVcIiksIGBub2RlYCAoYW4gYXJyYXkgb2Ygb2JqZWN0cykgYW5kIGBpbnN0YCAodGhlIGluc3RhbmNlKVxuXHRcdCAqL1xuXHRcdGdldF9idWZmZXIgOiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRyZXR1cm4geyAnbW9kZScgOiBjY3BfbW9kZSwgJ25vZGUnIDogY2NwX25vZGUsICdpbnN0JyA6IGNjcF9pbnN0IH07XG5cdFx0fSxcblx0XHQvKipcblx0XHQgKiBjaGVjayBpZiB0aGVyZSBpcyBzb21ldGhpbmcgaW4gdGhlIGJ1ZmZlciB0byBwYXN0ZVxuXHRcdCAqIEBuYW1lIGNhbl9wYXN0ZSgpXG5cdFx0ICogQHJldHVybiB7Qm9vbGVhbn1cblx0XHQgKi9cblx0XHRjYW5fcGFzdGUgOiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRyZXR1cm4gY2NwX21vZGUgIT09IGZhbHNlICYmIGNjcF9ub2RlICE9PSBmYWxzZTsgLy8gJiYgY2NwX2luc3QuX21vZGVsLmRhdGFbY2NwX25vZGVdO1xuXHRcdH0sXG5cdFx0LyoqXG5cdFx0ICogY29weSBvciBtb3ZlIHRoZSBwcmV2aW91c2x5IGN1dCBvciBjb3BpZWQgbm9kZXMgdG8gYSBuZXcgcGFyZW50XG5cdFx0ICogQG5hbWUgcGFzdGUob2JqIFssIHBvc10pXG5cdFx0ICogQHBhcmFtICB7bWl4ZWR9IG9iaiB0aGUgbmV3IHBhcmVudFxuXHRcdCAqIEBwYXJhbSAge21peGVkfSBwb3MgdGhlIHBvc2l0aW9uIHRvIGluc2VydCBhdCAoYmVzaWRlcyBpbnRlZ2VyLCBcImZpcnN0XCIgYW5kIFwibGFzdFwiIGFyZSBzdXBwb3J0ZWQpLCBkZWZhdWx0cyB0byBpbnRlZ2VyIGAwYFxuXHRcdCAqIEB0cmlnZ2VyIHBhc3RlLmpzdHJlZVxuXHRcdCAqL1xuXHRcdHBhc3RlIDogZnVuY3Rpb24gKG9iaiwgcG9zKSB7XG5cdFx0XHRvYmogPSB0aGlzLmdldF9ub2RlKG9iaik7XG5cdFx0XHRpZighb2JqIHx8ICFjY3BfbW9kZSB8fCAhY2NwX21vZGUubWF0Y2goL14oY29weV9ub2RlfG1vdmVfbm9kZSkkLykgfHwgIWNjcF9ub2RlKSB7IHJldHVybiBmYWxzZTsgfVxuXHRcdFx0aWYodGhpc1tjY3BfbW9kZV0oY2NwX25vZGUsIG9iaiwgcG9zLCBmYWxzZSwgZmFsc2UsIGZhbHNlLCBjY3BfaW5zdCkpIHtcblx0XHRcdFx0LyoqXG5cdFx0XHRcdCAqIHRyaWdnZXJlZCB3aGVuIHBhc3RlIGlzIGludm9rZWRcblx0XHRcdFx0ICogQGV2ZW50XG5cdFx0XHRcdCAqIEBuYW1lIHBhc3RlLmpzdHJlZVxuXHRcdFx0XHQgKiBAcGFyYW0ge1N0cmluZ30gcGFyZW50IHRoZSBJRCBvZiB0aGUgcmVjZWl2aW5nIG5vZGVcblx0XHRcdFx0ICogQHBhcmFtIHtBcnJheX0gbm9kZSB0aGUgbm9kZXMgaW4gdGhlIGJ1ZmZlclxuXHRcdFx0XHQgKiBAcGFyYW0ge1N0cmluZ30gbW9kZSB0aGUgcGVyZm9ybWVkIG9wZXJhdGlvbiAtIFwiY29weV9ub2RlXCIgb3IgXCJtb3ZlX25vZGVcIlxuXHRcdFx0XHQgKi9cblx0XHRcdFx0dGhpcy50cmlnZ2VyKCdwYXN0ZScsIHsgXCJwYXJlbnRcIiA6IG9iai5pZCwgXCJub2RlXCIgOiBjY3Bfbm9kZSwgXCJtb2RlXCIgOiBjY3BfbW9kZSB9KTtcblx0XHRcdH1cblx0XHRcdGNjcF9ub2RlID0gZmFsc2U7XG5cdFx0XHRjY3BfbW9kZSA9IGZhbHNlO1xuXHRcdFx0Y2NwX2luc3QgPSBmYWxzZTtcblx0XHR9LFxuXHRcdC8qKlxuXHRcdCAqIGNsZWFyIHRoZSBidWZmZXIgb2YgcHJldmlvdXNseSBjb3BpZWQgb3IgY3V0IG5vZGVzXG5cdFx0ICogQG5hbWUgY2xlYXJfYnVmZmVyKClcblx0XHQgKiBAdHJpZ2dlciBjbGVhcl9idWZmZXIuanN0cmVlXG5cdFx0ICovXG5cdFx0Y2xlYXJfYnVmZmVyIDogZnVuY3Rpb24gKCkge1xuXHRcdFx0Y2NwX25vZGUgPSBmYWxzZTtcblx0XHRcdGNjcF9tb2RlID0gZmFsc2U7XG5cdFx0XHRjY3BfaW5zdCA9IGZhbHNlO1xuXHRcdFx0LyoqXG5cdFx0XHQgKiB0cmlnZ2VyZWQgd2hlbiB0aGUgY29weSAvIGN1dCBidWZmZXIgaXMgY2xlYXJlZFxuXHRcdFx0ICogQGV2ZW50XG5cdFx0XHQgKiBAbmFtZSBjbGVhcl9idWZmZXIuanN0cmVlXG5cdFx0XHQgKi9cblx0XHRcdHRoaXMudHJpZ2dlcignY2xlYXJfYnVmZmVyJyk7XG5cdFx0fSxcblx0XHQvKipcblx0XHQgKiBwdXQgYSBub2RlIGluIGVkaXQgbW9kZSAoaW5wdXQgZmllbGQgdG8gcmVuYW1lIHRoZSBub2RlKVxuXHRcdCAqIEBuYW1lIGVkaXQob2JqIFssIGRlZmF1bHRfdGV4dCwgY2FsbGJhY2tdKVxuXHRcdCAqIEBwYXJhbSAge21peGVkfSBvYmpcblx0XHQgKiBAcGFyYW0gIHtTdHJpbmd9IGRlZmF1bHRfdGV4dCB0aGUgdGV4dCB0byBwb3B1bGF0ZSB0aGUgaW5wdXQgd2l0aCAoaWYgb21pdHRlZCBvciBzZXQgdG8gYSBub24tc3RyaW5nIHZhbHVlIHRoZSBub2RlJ3MgdGV4dCB2YWx1ZSBpcyB1c2VkKVxuXHRcdCAqIEBwYXJhbSAge0Z1bmN0aW9ufSBjYWxsYmFjayBhIGZ1bmN0aW9uIHRvIGJlIGNhbGxlZCBvbmNlIHRoZSB0ZXh0IGJveCBpcyBibHVycmVkLCBpdCBpcyBjYWxsZWQgaW4gdGhlIGluc3RhbmNlJ3Mgc2NvcGUgYW5kIHJlY2VpdmVzIHRoZSBub2RlLCBhIHN0YXR1cyBwYXJhbWV0ZXIgKHRydWUgaWYgdGhlIHJlbmFtZSBpcyBzdWNjZXNzZnVsLCBmYWxzZSBvdGhlcndpc2UpIGFuZCBhIGJvb2xlYW4gaW5kaWNhdGluZyBpZiB0aGUgdXNlciBjYW5jZWxsZWQgdGhlIGVkaXQuIFlvdSBjYW4gYWNjZXNzIHRoZSBub2RlJ3MgdGl0bGUgdXNpbmcgLnRleHRcblx0XHQgKi9cblx0XHRlZGl0IDogZnVuY3Rpb24gKG9iaiwgZGVmYXVsdF90ZXh0LCBjYWxsYmFjaykge1xuXHRcdFx0dmFyIHJ0bCwgdywgYSwgcywgdCwgaDEsIGgyLCBmbiwgdG1wLCBjYW5jZWwgPSBmYWxzZTtcblx0XHRcdG9iaiA9IHRoaXMuZ2V0X25vZGUob2JqKTtcblx0XHRcdGlmKCFvYmopIHsgcmV0dXJuIGZhbHNlOyB9XG5cdFx0XHRpZih0aGlzLnNldHRpbmdzLmNvcmUuY2hlY2tfY2FsbGJhY2sgPT09IGZhbHNlKSB7XG5cdFx0XHRcdHRoaXMuX2RhdGEuY29yZS5sYXN0X2Vycm9yID0geyAnZXJyb3InIDogJ2NoZWNrJywgJ3BsdWdpbicgOiAnY29yZScsICdpZCcgOiAnY29yZV8wNycsICdyZWFzb24nIDogJ0NvdWxkIG5vdCBlZGl0IG5vZGUgYmVjYXVzZSBvZiBjaGVja19jYWxsYmFjaycgfTtcblx0XHRcdFx0dGhpcy5zZXR0aW5ncy5jb3JlLmVycm9yLmNhbGwodGhpcywgdGhpcy5fZGF0YS5jb3JlLmxhc3RfZXJyb3IpO1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cdFx0XHR0bXAgPSBvYmo7XG5cdFx0XHRkZWZhdWx0X3RleHQgPSB0eXBlb2YgZGVmYXVsdF90ZXh0ID09PSAnc3RyaW5nJyA/IGRlZmF1bHRfdGV4dCA6IG9iai50ZXh0O1xuXHRcdFx0dGhpcy5zZXRfdGV4dChvYmosIFwiXCIpO1xuXHRcdFx0b2JqID0gdGhpcy5fb3Blbl90byhvYmopO1xuXHRcdFx0dG1wLnRleHQgPSBkZWZhdWx0X3RleHQ7XG5cblx0XHRcdHJ0bCA9IHRoaXMuX2RhdGEuY29yZS5ydGw7XG5cdFx0XHR3ICA9IHRoaXMuZWxlbWVudC53aWR0aCgpO1xuXHRcdFx0dGhpcy5fZGF0YS5jb3JlLmZvY3VzZWQgPSB0bXAuaWQ7XG5cdFx0XHRhICA9IG9iai5jaGlsZHJlbignLmpzdHJlZS1hbmNob3InKS5mb2N1cygpO1xuXHRcdFx0cyAgPSAkKCc8c3Bhbj4nKTtcblx0XHRcdC8qIVxuXHRcdFx0b2kgPSBvYmouY2hpbGRyZW4oXCJpOnZpc2libGVcIiksXG5cdFx0XHRhaSA9IGEuY2hpbGRyZW4oXCJpOnZpc2libGVcIiksXG5cdFx0XHR3MSA9IG9pLndpZHRoKCkgKiBvaS5sZW5ndGgsXG5cdFx0XHR3MiA9IGFpLndpZHRoKCkgKiBhaS5sZW5ndGgsXG5cdFx0XHQqL1xuXHRcdFx0dCAgPSBkZWZhdWx0X3RleHQ7XG5cdFx0XHRoMSA9ICQoXCI8XCIrXCJkaXYgLz5cIiwgeyBjc3MgOiB7IFwicG9zaXRpb25cIiA6IFwiYWJzb2x1dGVcIiwgXCJ0b3BcIiA6IFwiLTIwMHB4XCIsIFwibGVmdFwiIDogKHJ0bCA/IFwiMHB4XCIgOiBcIi0xMDAwcHhcIiksIFwidmlzaWJpbGl0eVwiIDogXCJoaWRkZW5cIiB9IH0pLmFwcGVuZFRvKFwiYm9keVwiKTtcblx0XHRcdGgyID0gJChcIjxcIitcImlucHV0IC8+XCIsIHtcblx0XHRcdFx0XHRcdFwidmFsdWVcIiA6IHQsXG5cdFx0XHRcdFx0XHRcImNsYXNzXCIgOiBcImpzdHJlZS1yZW5hbWUtaW5wdXRcIixcblx0XHRcdFx0XHRcdC8vIFwic2l6ZVwiIDogdC5sZW5ndGgsXG5cdFx0XHRcdFx0XHRcImNzc1wiIDoge1xuXHRcdFx0XHRcdFx0XHRcInBhZGRpbmdcIiA6IFwiMFwiLFxuXHRcdFx0XHRcdFx0XHRcImJvcmRlclwiIDogXCIxcHggc29saWQgc2lsdmVyXCIsXG5cdFx0XHRcdFx0XHRcdFwiYm94LXNpemluZ1wiIDogXCJib3JkZXItYm94XCIsXG5cdFx0XHRcdFx0XHRcdFwiZGlzcGxheVwiIDogXCJpbmxpbmUtYmxvY2tcIixcblx0XHRcdFx0XHRcdFx0XCJoZWlnaHRcIiA6ICh0aGlzLl9kYXRhLmNvcmUubGlfaGVpZ2h0KSArIFwicHhcIixcblx0XHRcdFx0XHRcdFx0XCJsaW5lSGVpZ2h0XCIgOiAodGhpcy5fZGF0YS5jb3JlLmxpX2hlaWdodCkgKyBcInB4XCIsXG5cdFx0XHRcdFx0XHRcdFwid2lkdGhcIiA6IFwiMTUwcHhcIiAvLyB3aWxsIGJlIHNldCBhIGJpdCBmdXJ0aGVyIGRvd25cblx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcImJsdXJcIiA6ICQucHJveHkoZnVuY3Rpb24gKGUpIHtcblx0XHRcdFx0XHRcdFx0ZS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcblx0XHRcdFx0XHRcdFx0ZS5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0XHRcdFx0XHR2YXIgaSA9IHMuY2hpbGRyZW4oXCIuanN0cmVlLXJlbmFtZS1pbnB1dFwiKSxcblx0XHRcdFx0XHRcdFx0XHR2ID0gaS52YWwoKSxcblx0XHRcdFx0XHRcdFx0XHRmID0gdGhpcy5zZXR0aW5ncy5jb3JlLmZvcmNlX3RleHQsXG5cdFx0XHRcdFx0XHRcdFx0bnY7XG5cdFx0XHRcdFx0XHRcdGlmKHYgPT09IFwiXCIpIHsgdiA9IHQ7IH1cblx0XHRcdFx0XHRcdFx0aDEucmVtb3ZlKCk7XG5cdFx0XHRcdFx0XHRcdHMucmVwbGFjZVdpdGgoYSk7XG5cdFx0XHRcdFx0XHRcdHMucmVtb3ZlKCk7XG5cdFx0XHRcdFx0XHRcdHQgPSBmID8gdCA6ICQoJzxkaXY+PC9kaXY+JykuYXBwZW5kKCQucGFyc2VIVE1MKHQpKS5odG1sKCk7XG5cdFx0XHRcdFx0XHRcdHRoaXMuc2V0X3RleHQob2JqLCB0KTtcblx0XHRcdFx0XHRcdFx0bnYgPSAhIXRoaXMucmVuYW1lX25vZGUob2JqLCBmID8gJCgnPGRpdj48L2Rpdj4nKS50ZXh0KHYpLnRleHQoKSA6ICQoJzxkaXY+PC9kaXY+JykuYXBwZW5kKCQucGFyc2VIVE1MKHYpKS5odG1sKCkpO1xuXHRcdFx0XHRcdFx0XHRpZighbnYpIHtcblx0XHRcdFx0XHRcdFx0XHR0aGlzLnNldF90ZXh0KG9iaiwgdCk7IC8vIG1vdmUgdGhpcyB1cD8gYW5kIGZpeCAjNDgzXG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0dGhpcy5fZGF0YS5jb3JlLmZvY3VzZWQgPSB0bXAuaWQ7XG5cdFx0XHRcdFx0XHRcdHNldFRpbWVvdXQoJC5wcm94eShmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdFx0XHRcdFx0dmFyIG5vZGUgPSB0aGlzLmdldF9ub2RlKHRtcC5pZCwgdHJ1ZSk7XG5cdFx0XHRcdFx0XHRcdFx0aWYobm9kZS5sZW5ndGgpIHtcblx0XHRcdFx0XHRcdFx0XHRcdHRoaXMuX2RhdGEuY29yZS5mb2N1c2VkID0gdG1wLmlkO1xuXHRcdFx0XHRcdFx0XHRcdFx0bm9kZS5jaGlsZHJlbignLmpzdHJlZS1hbmNob3InKS5mb2N1cygpO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fSwgdGhpcyksIDApO1xuXHRcdFx0XHRcdFx0XHRpZihjYWxsYmFjaykge1xuXHRcdFx0XHRcdFx0XHRcdGNhbGxiYWNrLmNhbGwodGhpcywgdG1wLCBudiwgY2FuY2VsKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRoMiA9IG51bGw7XG5cdFx0XHRcdFx0XHR9LCB0aGlzKSxcblx0XHRcdFx0XHRcdFwia2V5ZG93blwiIDogZnVuY3Rpb24gKGUpIHtcblx0XHRcdFx0XHRcdFx0dmFyIGtleSA9IGUud2hpY2g7XG5cdFx0XHRcdFx0XHRcdGlmKGtleSA9PT0gMjcpIHtcblx0XHRcdFx0XHRcdFx0XHRjYW5jZWwgPSB0cnVlO1xuXHRcdFx0XHRcdFx0XHRcdHRoaXMudmFsdWUgPSB0O1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdGlmKGtleSA9PT0gMjcgfHwga2V5ID09PSAxMyB8fCBrZXkgPT09IDM3IHx8IGtleSA9PT0gMzggfHwga2V5ID09PSAzOSB8fCBrZXkgPT09IDQwIHx8IGtleSA9PT0gMzIpIHtcblx0XHRcdFx0XHRcdFx0XHRlLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdGlmKGtleSA9PT0gMjcgfHwga2V5ID09PSAxMykge1xuXHRcdFx0XHRcdFx0XHRcdGUucHJldmVudERlZmF1bHQoKTtcblx0XHRcdFx0XHRcdFx0XHR0aGlzLmJsdXIoKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFwiY2xpY2tcIiA6IGZ1bmN0aW9uIChlKSB7IGUuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7IH0sXG5cdFx0XHRcdFx0XHRcIm1vdXNlZG93blwiIDogZnVuY3Rpb24gKGUpIHsgZS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTsgfSxcblx0XHRcdFx0XHRcdFwia2V5dXBcIiA6IGZ1bmN0aW9uIChlKSB7XG5cdFx0XHRcdFx0XHRcdGgyLndpZHRoKE1hdGgubWluKGgxLnRleHQoXCJwV1wiICsgdGhpcy52YWx1ZSkud2lkdGgoKSx3KSk7XG5cdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XCJrZXlwcmVzc1wiIDogZnVuY3Rpb24oZSkge1xuXHRcdFx0XHRcdFx0XHRpZihlLndoaWNoID09PSAxMykgeyByZXR1cm4gZmFsc2U7IH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0Zm4gPSB7XG5cdFx0XHRcdFx0XHRmb250RmFtaWx5XHRcdDogYS5jc3MoJ2ZvbnRGYW1pbHknKVx0XHR8fCAnJyxcblx0XHRcdFx0XHRcdGZvbnRTaXplXHRcdDogYS5jc3MoJ2ZvbnRTaXplJylcdFx0XHR8fCAnJyxcblx0XHRcdFx0XHRcdGZvbnRXZWlnaHRcdFx0OiBhLmNzcygnZm9udFdlaWdodCcpXHRcdHx8ICcnLFxuXHRcdFx0XHRcdFx0Zm9udFN0eWxlXHRcdDogYS5jc3MoJ2ZvbnRTdHlsZScpXHRcdHx8ICcnLFxuXHRcdFx0XHRcdFx0Zm9udFN0cmV0Y2hcdFx0OiBhLmNzcygnZm9udFN0cmV0Y2gnKVx0XHR8fCAnJyxcblx0XHRcdFx0XHRcdGZvbnRWYXJpYW50XHRcdDogYS5jc3MoJ2ZvbnRWYXJpYW50JylcdFx0fHwgJycsXG5cdFx0XHRcdFx0XHRsZXR0ZXJTcGFjaW5nXHQ6IGEuY3NzKCdsZXR0ZXJTcGFjaW5nJylcdHx8ICcnLFxuXHRcdFx0XHRcdFx0d29yZFNwYWNpbmdcdFx0OiBhLmNzcygnd29yZFNwYWNpbmcnKVx0XHR8fCAnJ1xuXHRcdFx0XHR9O1xuXHRcdFx0cy5hdHRyKCdjbGFzcycsIGEuYXR0cignY2xhc3MnKSkuYXBwZW5kKGEuY29udGVudHMoKS5jbG9uZSgpKS5hcHBlbmQoaDIpO1xuXHRcdFx0YS5yZXBsYWNlV2l0aChzKTtcblx0XHRcdGgxLmNzcyhmbik7XG5cdFx0XHRoMi5jc3MoZm4pLndpZHRoKE1hdGgubWluKGgxLnRleHQoXCJwV1wiICsgaDJbMF0udmFsdWUpLndpZHRoKCksdykpWzBdLnNlbGVjdCgpO1xuXHRcdFx0JChkb2N1bWVudCkub25lKCdtb3VzZWRvd24uanN0cmVlIHRvdWNoc3RhcnQuanN0cmVlIGRuZF9zdGFydC52YWthdGEnLCBmdW5jdGlvbiAoZSkge1xuXHRcdFx0XHRpZiAoaDIgJiYgZS50YXJnZXQgIT09IGgyKSB7XG5cdFx0XHRcdFx0JChoMikuYmx1cigpO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHR9LFxuXG5cblx0XHQvKipcblx0XHQgKiBjaGFuZ2VzIHRoZSB0aGVtZVxuXHRcdCAqIEBuYW1lIHNldF90aGVtZSh0aGVtZV9uYW1lIFssIHRoZW1lX3VybF0pXG5cdFx0ICogQHBhcmFtIHtTdHJpbmd9IHRoZW1lX25hbWUgdGhlIG5hbWUgb2YgdGhlIG5ldyB0aGVtZSB0byBhcHBseVxuXHRcdCAqIEBwYXJhbSB7bWl4ZWR9IHRoZW1lX3VybCAgdGhlIGxvY2F0aW9uIG9mIHRoZSBDU1MgZmlsZSBmb3IgdGhpcyB0aGVtZS4gT21pdCBvciBzZXQgdG8gYGZhbHNlYCBpZiB5b3UgbWFudWFsbHkgaW5jbHVkZWQgdGhlIGZpbGUuIFNldCB0byBgdHJ1ZWAgdG8gYXV0b2xvYWQgZnJvbSB0aGUgYGNvcmUudGhlbWVzLmRpcmAgZGlyZWN0b3J5LlxuXHRcdCAqIEB0cmlnZ2VyIHNldF90aGVtZS5qc3RyZWVcblx0XHQgKi9cblx0XHRzZXRfdGhlbWUgOiBmdW5jdGlvbiAodGhlbWVfbmFtZSwgdGhlbWVfdXJsKSB7XG5cdFx0XHRpZighdGhlbWVfbmFtZSkgeyByZXR1cm4gZmFsc2U7IH1cblx0XHRcdGlmKHRoZW1lX3VybCA9PT0gdHJ1ZSkge1xuXHRcdFx0XHR2YXIgZGlyID0gdGhpcy5zZXR0aW5ncy5jb3JlLnRoZW1lcy5kaXI7XG5cdFx0XHRcdGlmKCFkaXIpIHsgZGlyID0gJC5qc3RyZWUucGF0aCArICcvdGhlbWVzJzsgfVxuXHRcdFx0XHR0aGVtZV91cmwgPSBkaXIgKyAnLycgKyB0aGVtZV9uYW1lICsgJy9zdHlsZS5jc3MnO1xuXHRcdFx0fVxuXHRcdFx0aWYodGhlbWVfdXJsICYmICQuaW5BcnJheSh0aGVtZV91cmwsIHRoZW1lc19sb2FkZWQpID09PSAtMSkge1xuXHRcdFx0XHQkKCdoZWFkJykuYXBwZW5kKCc8JysnbGluayByZWw9XCJzdHlsZXNoZWV0XCIgaHJlZj1cIicgKyB0aGVtZV91cmwgKyAnXCIgdHlwZT1cInRleHQvY3NzXCIgLz4nKTtcblx0XHRcdFx0dGhlbWVzX2xvYWRlZC5wdXNoKHRoZW1lX3VybCk7XG5cdFx0XHR9XG5cdFx0XHRpZih0aGlzLl9kYXRhLmNvcmUudGhlbWVzLm5hbWUpIHtcblx0XHRcdFx0dGhpcy5lbGVtZW50LnJlbW92ZUNsYXNzKCdqc3RyZWUtJyArIHRoaXMuX2RhdGEuY29yZS50aGVtZXMubmFtZSk7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLl9kYXRhLmNvcmUudGhlbWVzLm5hbWUgPSB0aGVtZV9uYW1lO1xuXHRcdFx0dGhpcy5lbGVtZW50LmFkZENsYXNzKCdqc3RyZWUtJyArIHRoZW1lX25hbWUpO1xuXHRcdFx0dGhpcy5lbGVtZW50W3RoaXMuc2V0dGluZ3MuY29yZS50aGVtZXMucmVzcG9uc2l2ZSA/ICdhZGRDbGFzcycgOiAncmVtb3ZlQ2xhc3MnIF0oJ2pzdHJlZS0nICsgdGhlbWVfbmFtZSArICctcmVzcG9uc2l2ZScpO1xuXHRcdFx0LyoqXG5cdFx0XHQgKiB0cmlnZ2VyZWQgd2hlbiBhIHRoZW1lIGlzIHNldFxuXHRcdFx0ICogQGV2ZW50XG5cdFx0XHQgKiBAbmFtZSBzZXRfdGhlbWUuanN0cmVlXG5cdFx0XHQgKiBAcGFyYW0ge1N0cmluZ30gdGhlbWUgdGhlIG5ldyB0aGVtZVxuXHRcdFx0ICovXG5cdFx0XHR0aGlzLnRyaWdnZXIoJ3NldF90aGVtZScsIHsgJ3RoZW1lJyA6IHRoZW1lX25hbWUgfSk7XG5cdFx0fSxcblx0XHQvKipcblx0XHQgKiBnZXRzIHRoZSBuYW1lIG9mIHRoZSBjdXJyZW50bHkgYXBwbGllZCB0aGVtZSBuYW1lXG5cdFx0ICogQG5hbWUgZ2V0X3RoZW1lKClcblx0XHQgKiBAcmV0dXJuIHtTdHJpbmd9XG5cdFx0ICovXG5cdFx0Z2V0X3RoZW1lIDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fZGF0YS5jb3JlLnRoZW1lcy5uYW1lOyB9LFxuXHRcdC8qKlxuXHRcdCAqIGNoYW5nZXMgdGhlIHRoZW1lIHZhcmlhbnQgKGlmIHRoZSB0aGVtZSBoYXMgdmFyaWFudHMpXG5cdFx0ICogQG5hbWUgc2V0X3RoZW1lX3ZhcmlhbnQodmFyaWFudF9uYW1lKVxuXHRcdCAqIEBwYXJhbSB7U3RyaW5nfEJvb2xlYW59IHZhcmlhbnRfbmFtZSB0aGUgdmFyaWFudCB0byBhcHBseSAoaWYgYGZhbHNlYCBpcyB1c2VkIHRoZSBjdXJyZW50IHZhcmlhbnQgaXMgcmVtb3ZlZClcblx0XHQgKi9cblx0XHRzZXRfdGhlbWVfdmFyaWFudCA6IGZ1bmN0aW9uICh2YXJpYW50X25hbWUpIHtcblx0XHRcdGlmKHRoaXMuX2RhdGEuY29yZS50aGVtZXMudmFyaWFudCkge1xuXHRcdFx0XHR0aGlzLmVsZW1lbnQucmVtb3ZlQ2xhc3MoJ2pzdHJlZS0nICsgdGhpcy5fZGF0YS5jb3JlLnRoZW1lcy5uYW1lICsgJy0nICsgdGhpcy5fZGF0YS5jb3JlLnRoZW1lcy52YXJpYW50KTtcblx0XHRcdH1cblx0XHRcdHRoaXMuX2RhdGEuY29yZS50aGVtZXMudmFyaWFudCA9IHZhcmlhbnRfbmFtZTtcblx0XHRcdGlmKHZhcmlhbnRfbmFtZSkge1xuXHRcdFx0XHR0aGlzLmVsZW1lbnQuYWRkQ2xhc3MoJ2pzdHJlZS0nICsgdGhpcy5fZGF0YS5jb3JlLnRoZW1lcy5uYW1lICsgJy0nICsgdGhpcy5fZGF0YS5jb3JlLnRoZW1lcy52YXJpYW50KTtcblx0XHRcdH1cblx0XHR9LFxuXHRcdC8qKlxuXHRcdCAqIGdldHMgdGhlIG5hbWUgb2YgdGhlIGN1cnJlbnRseSBhcHBsaWVkIHRoZW1lIHZhcmlhbnRcblx0XHQgKiBAbmFtZSBnZXRfdGhlbWUoKVxuXHRcdCAqIEByZXR1cm4ge1N0cmluZ31cblx0XHQgKi9cblx0XHRnZXRfdGhlbWVfdmFyaWFudCA6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2RhdGEuY29yZS50aGVtZXMudmFyaWFudDsgfSxcblx0XHQvKipcblx0XHQgKiBzaG93cyBhIHN0cmlwZWQgYmFja2dyb3VuZCBvbiB0aGUgY29udGFpbmVyIChpZiB0aGUgdGhlbWUgc3VwcG9ydHMgaXQpXG5cdFx0ICogQG5hbWUgc2hvd19zdHJpcGVzKClcblx0XHQgKi9cblx0XHRzaG93X3N0cmlwZXMgOiBmdW5jdGlvbiAoKSB7XG5cdFx0XHR0aGlzLl9kYXRhLmNvcmUudGhlbWVzLnN0cmlwZXMgPSB0cnVlO1xuXHRcdFx0dGhpcy5nZXRfY29udGFpbmVyX3VsKCkuYWRkQ2xhc3MoXCJqc3RyZWUtc3RyaXBlZFwiKTtcblx0XHRcdC8qKlxuXHRcdFx0ICogdHJpZ2dlcmVkIHdoZW4gc3RyaXBlcyBhcmUgc2hvd25cblx0XHRcdCAqIEBldmVudFxuXHRcdFx0ICogQG5hbWUgc2hvd19zdHJpcGVzLmpzdHJlZVxuXHRcdFx0ICovXG5cdFx0XHR0aGlzLnRyaWdnZXIoJ3Nob3dfc3RyaXBlcycpO1xuXHRcdH0sXG5cdFx0LyoqXG5cdFx0ICogaGlkZXMgdGhlIHN0cmlwZWQgYmFja2dyb3VuZCBvbiB0aGUgY29udGFpbmVyXG5cdFx0ICogQG5hbWUgaGlkZV9zdHJpcGVzKClcblx0XHQgKi9cblx0XHRoaWRlX3N0cmlwZXMgOiBmdW5jdGlvbiAoKSB7XG5cdFx0XHR0aGlzLl9kYXRhLmNvcmUudGhlbWVzLnN0cmlwZXMgPSBmYWxzZTtcblx0XHRcdHRoaXMuZ2V0X2NvbnRhaW5lcl91bCgpLnJlbW92ZUNsYXNzKFwianN0cmVlLXN0cmlwZWRcIik7XG5cdFx0XHQvKipcblx0XHRcdCAqIHRyaWdnZXJlZCB3aGVuIHN0cmlwZXMgYXJlIGhpZGRlblxuXHRcdFx0ICogQGV2ZW50XG5cdFx0XHQgKiBAbmFtZSBoaWRlX3N0cmlwZXMuanN0cmVlXG5cdFx0XHQgKi9cblx0XHRcdHRoaXMudHJpZ2dlcignaGlkZV9zdHJpcGVzJyk7XG5cdFx0fSxcblx0XHQvKipcblx0XHQgKiB0b2dnbGVzIHRoZSBzdHJpcGVkIGJhY2tncm91bmQgb24gdGhlIGNvbnRhaW5lclxuXHRcdCAqIEBuYW1lIHRvZ2dsZV9zdHJpcGVzKClcblx0XHQgKi9cblx0XHR0b2dnbGVfc3RyaXBlcyA6IGZ1bmN0aW9uICgpIHsgaWYodGhpcy5fZGF0YS5jb3JlLnRoZW1lcy5zdHJpcGVzKSB7IHRoaXMuaGlkZV9zdHJpcGVzKCk7IH0gZWxzZSB7IHRoaXMuc2hvd19zdHJpcGVzKCk7IH0gfSxcblx0XHQvKipcblx0XHQgKiBzaG93cyB0aGUgY29ubmVjdGluZyBkb3RzIChpZiB0aGUgdGhlbWUgc3VwcG9ydHMgaXQpXG5cdFx0ICogQG5hbWUgc2hvd19kb3RzKClcblx0XHQgKi9cblx0XHRzaG93X2RvdHMgOiBmdW5jdGlvbiAoKSB7XG5cdFx0XHR0aGlzLl9kYXRhLmNvcmUudGhlbWVzLmRvdHMgPSB0cnVlO1xuXHRcdFx0dGhpcy5nZXRfY29udGFpbmVyX3VsKCkucmVtb3ZlQ2xhc3MoXCJqc3RyZWUtbm8tZG90c1wiKTtcblx0XHRcdC8qKlxuXHRcdFx0ICogdHJpZ2dlcmVkIHdoZW4gZG90cyBhcmUgc2hvd25cblx0XHRcdCAqIEBldmVudFxuXHRcdFx0ICogQG5hbWUgc2hvd19kb3RzLmpzdHJlZVxuXHRcdFx0ICovXG5cdFx0XHR0aGlzLnRyaWdnZXIoJ3Nob3dfZG90cycpO1xuXHRcdH0sXG5cdFx0LyoqXG5cdFx0ICogaGlkZXMgdGhlIGNvbm5lY3RpbmcgZG90c1xuXHRcdCAqIEBuYW1lIGhpZGVfZG90cygpXG5cdFx0ICovXG5cdFx0aGlkZV9kb3RzIDogZnVuY3Rpb24gKCkge1xuXHRcdFx0dGhpcy5fZGF0YS5jb3JlLnRoZW1lcy5kb3RzID0gZmFsc2U7XG5cdFx0XHR0aGlzLmdldF9jb250YWluZXJfdWwoKS5hZGRDbGFzcyhcImpzdHJlZS1uby1kb3RzXCIpO1xuXHRcdFx0LyoqXG5cdFx0XHQgKiB0cmlnZ2VyZWQgd2hlbiBkb3RzIGFyZSBoaWRkZW5cblx0XHRcdCAqIEBldmVudFxuXHRcdFx0ICogQG5hbWUgaGlkZV9kb3RzLmpzdHJlZVxuXHRcdFx0ICovXG5cdFx0XHR0aGlzLnRyaWdnZXIoJ2hpZGVfZG90cycpO1xuXHRcdH0sXG5cdFx0LyoqXG5cdFx0ICogdG9nZ2xlcyB0aGUgY29ubmVjdGluZyBkb3RzXG5cdFx0ICogQG5hbWUgdG9nZ2xlX2RvdHMoKVxuXHRcdCAqL1xuXHRcdHRvZ2dsZV9kb3RzIDogZnVuY3Rpb24gKCkgeyBpZih0aGlzLl9kYXRhLmNvcmUudGhlbWVzLmRvdHMpIHsgdGhpcy5oaWRlX2RvdHMoKTsgfSBlbHNlIHsgdGhpcy5zaG93X2RvdHMoKTsgfSB9LFxuXHRcdC8qKlxuXHRcdCAqIHNob3cgdGhlIG5vZGUgaWNvbnNcblx0XHQgKiBAbmFtZSBzaG93X2ljb25zKClcblx0XHQgKi9cblx0XHRzaG93X2ljb25zIDogZnVuY3Rpb24gKCkge1xuXHRcdFx0dGhpcy5fZGF0YS5jb3JlLnRoZW1lcy5pY29ucyA9IHRydWU7XG5cdFx0XHR0aGlzLmdldF9jb250YWluZXJfdWwoKS5yZW1vdmVDbGFzcyhcImpzdHJlZS1uby1pY29uc1wiKTtcblx0XHRcdC8qKlxuXHRcdFx0ICogdHJpZ2dlcmVkIHdoZW4gaWNvbnMgYXJlIHNob3duXG5cdFx0XHQgKiBAZXZlbnRcblx0XHRcdCAqIEBuYW1lIHNob3dfaWNvbnMuanN0cmVlXG5cdFx0XHQgKi9cblx0XHRcdHRoaXMudHJpZ2dlcignc2hvd19pY29ucycpO1xuXHRcdH0sXG5cdFx0LyoqXG5cdFx0ICogaGlkZSB0aGUgbm9kZSBpY29uc1xuXHRcdCAqIEBuYW1lIGhpZGVfaWNvbnMoKVxuXHRcdCAqL1xuXHRcdGhpZGVfaWNvbnMgOiBmdW5jdGlvbiAoKSB7XG5cdFx0XHR0aGlzLl9kYXRhLmNvcmUudGhlbWVzLmljb25zID0gZmFsc2U7XG5cdFx0XHR0aGlzLmdldF9jb250YWluZXJfdWwoKS5hZGRDbGFzcyhcImpzdHJlZS1uby1pY29uc1wiKTtcblx0XHRcdC8qKlxuXHRcdFx0ICogdHJpZ2dlcmVkIHdoZW4gaWNvbnMgYXJlIGhpZGRlblxuXHRcdFx0ICogQGV2ZW50XG5cdFx0XHQgKiBAbmFtZSBoaWRlX2ljb25zLmpzdHJlZVxuXHRcdFx0ICovXG5cdFx0XHR0aGlzLnRyaWdnZXIoJ2hpZGVfaWNvbnMnKTtcblx0XHR9LFxuXHRcdC8qKlxuXHRcdCAqIHRvZ2dsZSB0aGUgbm9kZSBpY29uc1xuXHRcdCAqIEBuYW1lIHRvZ2dsZV9pY29ucygpXG5cdFx0ICovXG5cdFx0dG9nZ2xlX2ljb25zIDogZnVuY3Rpb24gKCkgeyBpZih0aGlzLl9kYXRhLmNvcmUudGhlbWVzLmljb25zKSB7IHRoaXMuaGlkZV9pY29ucygpOyB9IGVsc2UgeyB0aGlzLnNob3dfaWNvbnMoKTsgfSB9LFxuXHRcdC8qKlxuXHRcdCAqIHNob3cgdGhlIG5vZGUgZWxsaXBzaXNcblx0XHQgKiBAbmFtZSBzaG93X2ljb25zKClcblx0XHQgKi9cblx0XHRzaG93X2VsbGlwc2lzIDogZnVuY3Rpb24gKCkge1xuXHRcdFx0dGhpcy5fZGF0YS5jb3JlLnRoZW1lcy5lbGxpcHNpcyA9IHRydWU7XG5cdFx0XHR0aGlzLmdldF9jb250YWluZXJfdWwoKS5hZGRDbGFzcyhcImpzdHJlZS1lbGxpcHNpc1wiKTtcblx0XHRcdC8qKlxuXHRcdFx0ICogdHJpZ2dlcmVkIHdoZW4gZWxsaXNpcyBpcyBzaG93blxuXHRcdFx0ICogQGV2ZW50XG5cdFx0XHQgKiBAbmFtZSBzaG93X2VsbGlwc2lzLmpzdHJlZVxuXHRcdFx0ICovXG5cdFx0XHR0aGlzLnRyaWdnZXIoJ3Nob3dfZWxsaXBzaXMnKTtcblx0XHR9LFxuXHRcdC8qKlxuXHRcdCAqIGhpZGUgdGhlIG5vZGUgZWxsaXBzaXNcblx0XHQgKiBAbmFtZSBoaWRlX2VsbGlwc2lzKClcblx0XHQgKi9cblx0XHRoaWRlX2VsbGlwc2lzIDogZnVuY3Rpb24gKCkge1xuXHRcdFx0dGhpcy5fZGF0YS5jb3JlLnRoZW1lcy5lbGxpcHNpcyA9IGZhbHNlO1xuXHRcdFx0dGhpcy5nZXRfY29udGFpbmVyX3VsKCkucmVtb3ZlQ2xhc3MoXCJqc3RyZWUtZWxsaXBzaXNcIik7XG5cdFx0XHQvKipcblx0XHRcdCAqIHRyaWdnZXJlZCB3aGVuIGVsbGlzaXMgaXMgaGlkZGVuXG5cdFx0XHQgKiBAZXZlbnRcblx0XHRcdCAqIEBuYW1lIGhpZGVfZWxsaXBzaXMuanN0cmVlXG5cdFx0XHQgKi9cblx0XHRcdHRoaXMudHJpZ2dlcignaGlkZV9lbGxpcHNpcycpO1xuXHRcdH0sXG5cdFx0LyoqXG5cdFx0ICogdG9nZ2xlIHRoZSBub2RlIGVsbGlwc2lzXG5cdFx0ICogQG5hbWUgdG9nZ2xlX2ljb25zKClcblx0XHQgKi9cblx0XHR0b2dnbGVfZWxsaXBzaXMgOiBmdW5jdGlvbiAoKSB7IGlmKHRoaXMuX2RhdGEuY29yZS50aGVtZXMuZWxsaXBzaXMpIHsgdGhpcy5oaWRlX2VsbGlwc2lzKCk7IH0gZWxzZSB7IHRoaXMuc2hvd19lbGxpcHNpcygpOyB9IH0sXG5cdFx0LyoqXG5cdFx0ICogc2V0IHRoZSBub2RlIGljb24gZm9yIGEgbm9kZVxuXHRcdCAqIEBuYW1lIHNldF9pY29uKG9iaiwgaWNvbilcblx0XHQgKiBAcGFyYW0ge21peGVkfSBvYmpcblx0XHQgKiBAcGFyYW0ge1N0cmluZ30gaWNvbiB0aGUgbmV3IGljb24gLSBjYW4gYmUgYSBwYXRoIHRvIGFuIGljb24gb3IgYSBjbGFzc05hbWUsIGlmIHVzaW5nIGFuIGltYWdlIHRoYXQgaXMgaW4gdGhlIGN1cnJlbnQgZGlyZWN0b3J5IHVzZSBhIGAuL2AgcHJlZml4LCBvdGhlcndpc2UgaXQgd2lsbCBiZSBkZXRlY3RlZCBhcyBhIGNsYXNzXG5cdFx0ICovXG5cdFx0c2V0X2ljb24gOiBmdW5jdGlvbiAob2JqLCBpY29uKSB7XG5cdFx0XHR2YXIgdDEsIHQyLCBkb20sIG9sZDtcblx0XHRcdGlmKCQuaXNBcnJheShvYmopKSB7XG5cdFx0XHRcdG9iaiA9IG9iai5zbGljZSgpO1xuXHRcdFx0XHRmb3IodDEgPSAwLCB0MiA9IG9iai5sZW5ndGg7IHQxIDwgdDI7IHQxKyspIHtcblx0XHRcdFx0XHR0aGlzLnNldF9pY29uKG9ialt0MV0sIGljb24pO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fVxuXHRcdFx0b2JqID0gdGhpcy5nZXRfbm9kZShvYmopO1xuXHRcdFx0aWYoIW9iaiB8fCBvYmouaWQgPT09ICQuanN0cmVlLnJvb3QpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdFx0XHRvbGQgPSBvYmouaWNvbjtcblx0XHRcdG9iai5pY29uID0gaWNvbiA9PT0gdHJ1ZSB8fCBpY29uID09PSBudWxsIHx8IGljb24gPT09IHVuZGVmaW5lZCB8fCBpY29uID09PSAnJyA/IHRydWUgOiBpY29uO1xuXHRcdFx0ZG9tID0gdGhpcy5nZXRfbm9kZShvYmosIHRydWUpLmNoaWxkcmVuKFwiLmpzdHJlZS1hbmNob3JcIikuY2hpbGRyZW4oXCIuanN0cmVlLXRoZW1laWNvblwiKTtcblx0XHRcdGlmKGljb24gPT09IGZhbHNlKSB7XG5cdFx0XHRcdHRoaXMuaGlkZV9pY29uKG9iaik7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIGlmKGljb24gPT09IHRydWUgfHwgaWNvbiA9PT0gbnVsbCB8fCBpY29uID09PSB1bmRlZmluZWQgfHwgaWNvbiA9PT0gJycpIHtcblx0XHRcdFx0ZG9tLnJlbW92ZUNsYXNzKCdqc3RyZWUtdGhlbWVpY29uLWN1c3RvbSAnICsgb2xkKS5jc3MoXCJiYWNrZ3JvdW5kXCIsXCJcIikucmVtb3ZlQXR0cihcInJlbFwiKTtcblx0XHRcdFx0aWYob2xkID09PSBmYWxzZSkgeyB0aGlzLnNob3dfaWNvbihvYmopOyB9XG5cdFx0XHR9XG5cdFx0XHRlbHNlIGlmKGljb24uaW5kZXhPZihcIi9cIikgPT09IC0xICYmIGljb24uaW5kZXhPZihcIi5cIikgPT09IC0xKSB7XG5cdFx0XHRcdGRvbS5yZW1vdmVDbGFzcyhvbGQpLmNzcyhcImJhY2tncm91bmRcIixcIlwiKTtcblx0XHRcdFx0ZG9tLmFkZENsYXNzKGljb24gKyAnIGpzdHJlZS10aGVtZWljb24tY3VzdG9tJykuYXR0cihcInJlbFwiLGljb24pO1xuXHRcdFx0XHRpZihvbGQgPT09IGZhbHNlKSB7IHRoaXMuc2hvd19pY29uKG9iaik7IH1cblx0XHRcdH1cblx0XHRcdGVsc2Uge1xuXHRcdFx0XHRkb20ucmVtb3ZlQ2xhc3Mob2xkKS5jc3MoXCJiYWNrZ3JvdW5kXCIsXCJcIik7XG5cdFx0XHRcdGRvbS5hZGRDbGFzcygnanN0cmVlLXRoZW1laWNvbi1jdXN0b20nKS5jc3MoXCJiYWNrZ3JvdW5kXCIsIFwidXJsKCdcIiArIGljb24gKyBcIicpIGNlbnRlciBjZW50ZXIgbm8tcmVwZWF0XCIpLmF0dHIoXCJyZWxcIixpY29uKTtcblx0XHRcdFx0aWYob2xkID09PSBmYWxzZSkgeyB0aGlzLnNob3dfaWNvbihvYmopOyB9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9LFxuXHRcdC8qKlxuXHRcdCAqIGdldCB0aGUgbm9kZSBpY29uIGZvciBhIG5vZGVcblx0XHQgKiBAbmFtZSBnZXRfaWNvbihvYmopXG5cdFx0ICogQHBhcmFtIHttaXhlZH0gb2JqXG5cdFx0ICogQHJldHVybiB7U3RyaW5nfVxuXHRcdCAqL1xuXHRcdGdldF9pY29uIDogZnVuY3Rpb24gKG9iaikge1xuXHRcdFx0b2JqID0gdGhpcy5nZXRfbm9kZShvYmopO1xuXHRcdFx0cmV0dXJuICghb2JqIHx8IG9iai5pZCA9PT0gJC5qc3RyZWUucm9vdCkgPyBmYWxzZSA6IG9iai5pY29uO1xuXHRcdH0sXG5cdFx0LyoqXG5cdFx0ICogaGlkZSB0aGUgaWNvbiBvbiBhbiBpbmRpdmlkdWFsIG5vZGVcblx0XHQgKiBAbmFtZSBoaWRlX2ljb24ob2JqKVxuXHRcdCAqIEBwYXJhbSB7bWl4ZWR9IG9ialxuXHRcdCAqL1xuXHRcdGhpZGVfaWNvbiA6IGZ1bmN0aW9uIChvYmopIHtcblx0XHRcdHZhciB0MSwgdDI7XG5cdFx0XHRpZigkLmlzQXJyYXkob2JqKSkge1xuXHRcdFx0XHRvYmogPSBvYmouc2xpY2UoKTtcblx0XHRcdFx0Zm9yKHQxID0gMCwgdDIgPSBvYmoubGVuZ3RoOyB0MSA8IHQyOyB0MSsrKSB7XG5cdFx0XHRcdFx0dGhpcy5oaWRlX2ljb24ob2JqW3QxXSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9XG5cdFx0XHRvYmogPSB0aGlzLmdldF9ub2RlKG9iaik7XG5cdFx0XHRpZighb2JqIHx8IG9iaiA9PT0gJC5qc3RyZWUucm9vdCkgeyByZXR1cm4gZmFsc2U7IH1cblx0XHRcdG9iai5pY29uID0gZmFsc2U7XG5cdFx0XHR0aGlzLmdldF9ub2RlKG9iaiwgdHJ1ZSkuY2hpbGRyZW4oXCIuanN0cmVlLWFuY2hvclwiKS5jaGlsZHJlbihcIi5qc3RyZWUtdGhlbWVpY29uXCIpLmFkZENsYXNzKCdqc3RyZWUtdGhlbWVpY29uLWhpZGRlbicpO1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fSxcblx0XHQvKipcblx0XHQgKiBzaG93IHRoZSBpY29uIG9uIGFuIGluZGl2aWR1YWwgbm9kZVxuXHRcdCAqIEBuYW1lIHNob3dfaWNvbihvYmopXG5cdFx0ICogQHBhcmFtIHttaXhlZH0gb2JqXG5cdFx0ICovXG5cdFx0c2hvd19pY29uIDogZnVuY3Rpb24gKG9iaikge1xuXHRcdFx0dmFyIHQxLCB0MiwgZG9tO1xuXHRcdFx0aWYoJC5pc0FycmF5KG9iaikpIHtcblx0XHRcdFx0b2JqID0gb2JqLnNsaWNlKCk7XG5cdFx0XHRcdGZvcih0MSA9IDAsIHQyID0gb2JqLmxlbmd0aDsgdDEgPCB0MjsgdDErKykge1xuXHRcdFx0XHRcdHRoaXMuc2hvd19pY29uKG9ialt0MV0pO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fVxuXHRcdFx0b2JqID0gdGhpcy5nZXRfbm9kZShvYmopO1xuXHRcdFx0aWYoIW9iaiB8fCBvYmogPT09ICQuanN0cmVlLnJvb3QpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdFx0XHRkb20gPSB0aGlzLmdldF9ub2RlKG9iaiwgdHJ1ZSk7XG5cdFx0XHRvYmouaWNvbiA9IGRvbS5sZW5ndGggPyBkb20uY2hpbGRyZW4oXCIuanN0cmVlLWFuY2hvclwiKS5jaGlsZHJlbihcIi5qc3RyZWUtdGhlbWVpY29uXCIpLmF0dHIoJ3JlbCcpIDogdHJ1ZTtcblx0XHRcdGlmKCFvYmouaWNvbikgeyBvYmouaWNvbiA9IHRydWU7IH1cblx0XHRcdGRvbS5jaGlsZHJlbihcIi5qc3RyZWUtYW5jaG9yXCIpLmNoaWxkcmVuKFwiLmpzdHJlZS10aGVtZWljb25cIikucmVtb3ZlQ2xhc3MoJ2pzdHJlZS10aGVtZWljb24taGlkZGVuJyk7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cdH07XG5cblx0Ly8gaGVscGVyc1xuXHQkLnZha2F0YSA9IHt9O1xuXHQvLyBjb2xsZWN0IGF0dHJpYnV0ZXNcblx0JC52YWthdGEuYXR0cmlidXRlcyA9IGZ1bmN0aW9uKG5vZGUsIHdpdGhfdmFsdWVzKSB7XG5cdFx0bm9kZSA9ICQobm9kZSlbMF07XG5cdFx0dmFyIGF0dHIgPSB3aXRoX3ZhbHVlcyA/IHt9IDogW107XG5cdFx0aWYobm9kZSAmJiBub2RlLmF0dHJpYnV0ZXMpIHtcblx0XHRcdCQuZWFjaChub2RlLmF0dHJpYnV0ZXMsIGZ1bmN0aW9uIChpLCB2KSB7XG5cdFx0XHRcdGlmKCQuaW5BcnJheSh2Lm5hbWUudG9Mb3dlckNhc2UoKSxbJ3N0eWxlJywnY29udGVudGVkaXRhYmxlJywnaGFzZm9jdXMnLCd0YWJpbmRleCddKSAhPT0gLTEpIHsgcmV0dXJuOyB9XG5cdFx0XHRcdGlmKHYudmFsdWUgIT09IG51bGwgJiYgJC50cmltKHYudmFsdWUpICE9PSAnJykge1xuXHRcdFx0XHRcdGlmKHdpdGhfdmFsdWVzKSB7IGF0dHJbdi5uYW1lXSA9IHYudmFsdWU7IH1cblx0XHRcdFx0XHRlbHNlIHsgYXR0ci5wdXNoKHYubmFtZSk7IH1cblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0fVxuXHRcdHJldHVybiBhdHRyO1xuXHR9O1xuXHQkLnZha2F0YS5hcnJheV91bmlxdWUgPSBmdW5jdGlvbihhcnJheSkge1xuXHRcdHZhciBhID0gW10sIGksIGosIGwsIG8gPSB7fTtcblx0XHRmb3IoaSA9IDAsIGwgPSBhcnJheS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdGlmKG9bYXJyYXlbaV1dID09PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0YS5wdXNoKGFycmF5W2ldKTtcblx0XHRcdFx0b1thcnJheVtpXV0gPSB0cnVlO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gYTtcblx0fTtcblx0Ly8gcmVtb3ZlIGl0ZW0gZnJvbSBhcnJheVxuXHQkLnZha2F0YS5hcnJheV9yZW1vdmUgPSBmdW5jdGlvbihhcnJheSwgZnJvbSkge1xuXHRcdGFycmF5LnNwbGljZShmcm9tLCAxKTtcblx0XHRyZXR1cm4gYXJyYXk7XG5cdFx0Ly92YXIgcmVzdCA9IGFycmF5LnNsaWNlKCh0byB8fCBmcm9tKSArIDEgfHwgYXJyYXkubGVuZ3RoKTtcblx0XHQvL2FycmF5Lmxlbmd0aCA9IGZyb20gPCAwID8gYXJyYXkubGVuZ3RoICsgZnJvbSA6IGZyb207XG5cdFx0Ly9hcnJheS5wdXNoLmFwcGx5KGFycmF5LCByZXN0KTtcblx0XHQvL3JldHVybiBhcnJheTtcblx0fTtcblx0Ly8gcmVtb3ZlIGl0ZW0gZnJvbSBhcnJheVxuXHQkLnZha2F0YS5hcnJheV9yZW1vdmVfaXRlbSA9IGZ1bmN0aW9uKGFycmF5LCBpdGVtKSB7XG5cdFx0dmFyIHRtcCA9ICQuaW5BcnJheShpdGVtLCBhcnJheSk7XG5cdFx0cmV0dXJuIHRtcCAhPT0gLTEgPyAkLnZha2F0YS5hcnJheV9yZW1vdmUoYXJyYXksIHRtcCkgOiBhcnJheTtcblx0fTtcblx0JC52YWthdGEuYXJyYXlfZmlsdGVyID0gZnVuY3Rpb24oYyxhLGIsZCxlKSB7XG5cdFx0aWYgKGMuZmlsdGVyKSB7XG5cdFx0XHRyZXR1cm4gYy5maWx0ZXIoYSwgYik7XG5cdFx0fVxuXHRcdGQ9W107XG5cdFx0Zm9yIChlIGluIGMpIHtcblx0XHRcdGlmICh+fmUrJyc9PT1lKycnICYmIGU+PTAgJiYgYS5jYWxsKGIsY1tlXSwrZSxjKSkge1xuXHRcdFx0XHRkLnB1c2goY1tlXSk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBkO1xuXHR9O1xuXG5cbi8qKlxuICogIyMjIENoYW5nZWQgcGx1Z2luXG4gKlxuICogVGhpcyBwbHVnaW4gYWRkcyBtb3JlIGluZm9ybWF0aW9uIHRvIHRoZSBgY2hhbmdlZC5qc3RyZWVgIGV2ZW50LiBUaGUgbmV3IGRhdGEgaXMgY29udGFpbmVkIGluIHRoZSBgY2hhbmdlZGAgZXZlbnQgZGF0YSBwcm9wZXJ0eSwgYW5kIGNvbnRhaW5zIGEgbGlzdHMgb2YgYHNlbGVjdGVkYCBhbmQgYGRlc2VsZWN0ZWRgIG5vZGVzLlxuICovXG5cblx0JC5qc3RyZWUucGx1Z2lucy5jaGFuZ2VkID0gZnVuY3Rpb24gKG9wdGlvbnMsIHBhcmVudCkge1xuXHRcdHZhciBsYXN0ID0gW107XG5cdFx0dGhpcy50cmlnZ2VyID0gZnVuY3Rpb24gKGV2LCBkYXRhKSB7XG5cdFx0XHR2YXIgaSwgajtcblx0XHRcdGlmKCFkYXRhKSB7XG5cdFx0XHRcdGRhdGEgPSB7fTtcblx0XHRcdH1cblx0XHRcdGlmKGV2LnJlcGxhY2UoJy5qc3RyZWUnLCcnKSA9PT0gJ2NoYW5nZWQnKSB7XG5cdFx0XHRcdGRhdGEuY2hhbmdlZCA9IHsgc2VsZWN0ZWQgOiBbXSwgZGVzZWxlY3RlZCA6IFtdIH07XG5cdFx0XHRcdHZhciB0bXAgPSB7fTtcblx0XHRcdFx0Zm9yKGkgPSAwLCBqID0gbGFzdC5sZW5ndGg7IGkgPCBqOyBpKyspIHtcblx0XHRcdFx0XHR0bXBbbGFzdFtpXV0gPSAxO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGZvcihpID0gMCwgaiA9IGRhdGEuc2VsZWN0ZWQubGVuZ3RoOyBpIDwgajsgaSsrKSB7XG5cdFx0XHRcdFx0aWYoIXRtcFtkYXRhLnNlbGVjdGVkW2ldXSkge1xuXHRcdFx0XHRcdFx0ZGF0YS5jaGFuZ2VkLnNlbGVjdGVkLnB1c2goZGF0YS5zZWxlY3RlZFtpXSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdFx0dG1wW2RhdGEuc2VsZWN0ZWRbaV1dID0gMjtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0Zm9yKGkgPSAwLCBqID0gbGFzdC5sZW5ndGg7IGkgPCBqOyBpKyspIHtcblx0XHRcdFx0XHRpZih0bXBbbGFzdFtpXV0gPT09IDEpIHtcblx0XHRcdFx0XHRcdGRhdGEuY2hhbmdlZC5kZXNlbGVjdGVkLnB1c2gobGFzdFtpXSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdGxhc3QgPSBkYXRhLnNlbGVjdGVkLnNsaWNlKCk7XG5cdFx0XHR9XG5cdFx0XHQvKipcblx0XHRcdCAqIHRyaWdnZXJlZCB3aGVuIHNlbGVjdGlvbiBjaGFuZ2VzICh0aGUgXCJjaGFuZ2VkXCIgcGx1Z2luIGVuaGFuY2VzIHRoZSBvcmlnaW5hbCBldmVudCB3aXRoIG1vcmUgZGF0YSlcblx0XHRcdCAqIEBldmVudFxuXHRcdFx0ICogQG5hbWUgY2hhbmdlZC5qc3RyZWVcblx0XHRcdCAqIEBwYXJhbSB7T2JqZWN0fSBub2RlXG5cdFx0XHQgKiBAcGFyYW0ge09iamVjdH0gYWN0aW9uIHRoZSBhY3Rpb24gdGhhdCBjYXVzZWQgdGhlIHNlbGVjdGlvbiB0byBjaGFuZ2Vcblx0XHRcdCAqIEBwYXJhbSB7QXJyYXl9IHNlbGVjdGVkIHRoZSBjdXJyZW50IHNlbGVjdGlvblxuXHRcdFx0ICogQHBhcmFtIHtPYmplY3R9IGNoYW5nZWQgYW4gb2JqZWN0IGNvbnRhaW5pbmcgdHdvIHByb3BlcnRpZXMgYHNlbGVjdGVkYCBhbmQgYGRlc2VsZWN0ZWRgIC0gYm90aCBhcnJheXMgb2Ygbm9kZSBJRHMsIHdoaWNoIHdlcmUgc2VsZWN0ZWQgb3IgZGVzZWxlY3RlZCBzaW5jZSB0aGUgbGFzdCBjaGFuZ2VkIGV2ZW50XG5cdFx0XHQgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgdGhlIGV2ZW50IChpZiBhbnkpIHRoYXQgdHJpZ2dlcmVkIHRoaXMgY2hhbmdlZCBldmVudFxuXHRcdFx0ICogQHBsdWdpbiBjaGFuZ2VkXG5cdFx0XHQgKi9cblx0XHRcdHBhcmVudC50cmlnZ2VyLmNhbGwodGhpcywgZXYsIGRhdGEpO1xuXHRcdH07XG5cdFx0dGhpcy5yZWZyZXNoID0gZnVuY3Rpb24gKHNraXBfbG9hZGluZywgZm9yZ2V0X3N0YXRlKSB7XG5cdFx0XHRsYXN0ID0gW107XG5cdFx0XHRyZXR1cm4gcGFyZW50LnJlZnJlc2guYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0XHR9O1xuXHR9O1xuXG4vKipcbiAqICMjIyBDaGVja2JveCBwbHVnaW5cbiAqXG4gKiBUaGlzIHBsdWdpbiByZW5kZXJzIGNoZWNrYm94IGljb25zIGluIGZyb250IG9mIGVhY2ggbm9kZSwgbWFraW5nIG11bHRpcGxlIHNlbGVjdGlvbiBtdWNoIGVhc2llci5cbiAqIEl0IGFsc28gc3VwcG9ydHMgdHJpLXN0YXRlIGJlaGF2aW9yLCBtZWFuaW5nIHRoYXQgaWYgYSBub2RlIGhhcyBhIGZldyBvZiBpdHMgY2hpbGRyZW4gY2hlY2tlZCBpdCB3aWxsIGJlIHJlbmRlcmVkIGFzIHVuZGV0ZXJtaW5lZCwgYW5kIHN0YXRlIHdpbGwgYmUgcHJvcGFnYXRlZCB1cC5cbiAqL1xuXG5cdHZhciBfaSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ0knKTtcblx0X2kuY2xhc3NOYW1lID0gJ2pzdHJlZS1pY29uIGpzdHJlZS1jaGVja2JveCc7XG5cdF9pLnNldEF0dHJpYnV0ZSgncm9sZScsICdwcmVzZW50YXRpb24nKTtcblx0LyoqXG5cdCAqIHN0b3JlcyBhbGwgZGVmYXVsdHMgZm9yIHRoZSBjaGVja2JveCBwbHVnaW5cblx0ICogQG5hbWUgJC5qc3RyZWUuZGVmYXVsdHMuY2hlY2tib3hcblx0ICogQHBsdWdpbiBjaGVja2JveFxuXHQgKi9cblx0JC5qc3RyZWUuZGVmYXVsdHMuY2hlY2tib3ggPSB7XG5cdFx0LyoqXG5cdFx0ICogYSBib29sZWFuIGluZGljYXRpbmcgaWYgY2hlY2tib3hlcyBzaG91bGQgYmUgdmlzaWJsZSAoY2FuIGJlIGNoYW5nZWQgYXQgYSBsYXRlciB0aW1lIHVzaW5nIGBzaG93X2NoZWNrYm94ZXMoKWAgYW5kIGBoaWRlX2NoZWNrYm94ZXNgKS4gRGVmYXVsdHMgdG8gYHRydWVgLlxuXHRcdCAqIEBuYW1lICQuanN0cmVlLmRlZmF1bHRzLmNoZWNrYm94LnZpc2libGVcblx0XHQgKiBAcGx1Z2luIGNoZWNrYm94XG5cdFx0ICovXG5cdFx0dmlzaWJsZVx0XHRcdFx0OiB0cnVlLFxuXHRcdC8qKlxuXHRcdCAqIGEgYm9vbGVhbiBpbmRpY2F0aW5nIGlmIGNoZWNrYm94ZXMgc2hvdWxkIGNhc2NhZGUgZG93biBhbmQgaGF2ZSBhbiB1bmRldGVybWluZWQgc3RhdGUuIERlZmF1bHRzIHRvIGB0cnVlYC5cblx0XHQgKiBAbmFtZSAkLmpzdHJlZS5kZWZhdWx0cy5jaGVja2JveC50aHJlZV9zdGF0ZVxuXHRcdCAqIEBwbHVnaW4gY2hlY2tib3hcblx0XHQgKi9cblx0XHR0aHJlZV9zdGF0ZVx0XHRcdDogdHJ1ZSxcblx0XHQvKipcblx0XHQgKiBhIGJvb2xlYW4gaW5kaWNhdGluZyBpZiBjbGlja2luZyBhbnl3aGVyZSBvbiB0aGUgbm9kZSBzaG91bGQgYWN0IGFzIGNsaWNraW5nIG9uIHRoZSBjaGVja2JveC4gRGVmYXVsdHMgdG8gYHRydWVgLlxuXHRcdCAqIEBuYW1lICQuanN0cmVlLmRlZmF1bHRzLmNoZWNrYm94Lndob2xlX25vZGVcblx0XHQgKiBAcGx1Z2luIGNoZWNrYm94XG5cdFx0ICovXG5cdFx0d2hvbGVfbm9kZVx0XHRcdDogdHJ1ZSxcblx0XHQvKipcblx0XHQgKiBhIGJvb2xlYW4gaW5kaWNhdGluZyBpZiB0aGUgc2VsZWN0ZWQgc3R5bGUgb2YgYSBub2RlIHNob3VsZCBiZSBrZXB0LCBvciByZW1vdmVkLiBEZWZhdWx0cyB0byBgdHJ1ZWAuXG5cdFx0ICogQG5hbWUgJC5qc3RyZWUuZGVmYXVsdHMuY2hlY2tib3gua2VlcF9zZWxlY3RlZF9zdHlsZVxuXHRcdCAqIEBwbHVnaW4gY2hlY2tib3hcblx0XHQgKi9cblx0XHRrZWVwX3NlbGVjdGVkX3N0eWxlXHQ6IHRydWUsXG5cdFx0LyoqXG5cdFx0ICogVGhpcyBzZXR0aW5nIGNvbnRyb2xzIGhvdyBjYXNjYWRpbmcgYW5kIHVuZGV0ZXJtaW5lZCBub2RlcyBhcmUgYXBwbGllZC5cblx0XHQgKiBJZiAndXAnIGlzIGluIHRoZSBzdHJpbmcgLSBjYXNjYWRpbmcgdXAgaXMgZW5hYmxlZCwgaWYgJ2Rvd24nIGlzIGluIHRoZSBzdHJpbmcgLSBjYXNjYWRpbmcgZG93biBpcyBlbmFibGVkLCBpZiAndW5kZXRlcm1pbmVkJyBpcyBpbiB0aGUgc3RyaW5nIC0gdW5kZXRlcm1pbmVkIG5vZGVzIHdpbGwgYmUgdXNlZC5cblx0XHQgKiBJZiBgdGhyZWVfc3RhdGVgIGlzIHNldCB0byBgdHJ1ZWAgdGhpcyBzZXR0aW5nIGlzIGF1dG9tYXRpY2FsbHkgc2V0IHRvICd1cCtkb3duK3VuZGV0ZXJtaW5lZCcuIERlZmF1bHRzIHRvICcnLlxuXHRcdCAqIEBuYW1lICQuanN0cmVlLmRlZmF1bHRzLmNoZWNrYm94LmNhc2NhZGVcblx0XHQgKiBAcGx1Z2luIGNoZWNrYm94XG5cdFx0ICovXG5cdFx0Y2FzY2FkZVx0XHRcdFx0OiAnJyxcblx0XHQvKipcblx0XHQgKiBUaGlzIHNldHRpbmcgY29udHJvbHMgaWYgY2hlY2tib3ggYXJlIGJvdW5kIHRvIHRoZSBnZW5lcmFsIHRyZWUgc2VsZWN0aW9uIG9yIHRvIGFuIGludGVybmFsIGFycmF5IG1haW50YWluZWQgYnkgdGhlIGNoZWNrYm94IHBsdWdpbi4gRGVmYXVsdHMgdG8gYHRydWVgLCBvbmx5IHNldCB0byBgZmFsc2VgIGlmIHlvdSBrbm93IGV4YWN0bHkgd2hhdCB5b3UgYXJlIGRvaW5nLlxuXHRcdCAqIEBuYW1lICQuanN0cmVlLmRlZmF1bHRzLmNoZWNrYm94LnRpZV9zZWxlY3Rpb25cblx0XHQgKiBAcGx1Z2luIGNoZWNrYm94XG5cdFx0ICovXG5cdFx0dGllX3NlbGVjdGlvblx0XHQ6IHRydWVcblx0fTtcblx0JC5qc3RyZWUucGx1Z2lucy5jaGVja2JveCA9IGZ1bmN0aW9uIChvcHRpb25zLCBwYXJlbnQpIHtcblx0XHR0aGlzLmJpbmQgPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHRwYXJlbnQuYmluZC5jYWxsKHRoaXMpO1xuXHRcdFx0dGhpcy5fZGF0YS5jaGVja2JveC51dG8gPSBmYWxzZTtcblx0XHRcdHRoaXMuX2RhdGEuY2hlY2tib3guc2VsZWN0ZWQgPSBbXTtcblx0XHRcdGlmKHRoaXMuc2V0dGluZ3MuY2hlY2tib3gudGhyZWVfc3RhdGUpIHtcblx0XHRcdFx0dGhpcy5zZXR0aW5ncy5jaGVja2JveC5jYXNjYWRlID0gJ3VwK2Rvd24rdW5kZXRlcm1pbmVkJztcblx0XHRcdH1cblx0XHRcdHRoaXMuZWxlbWVudFxuXHRcdFx0XHQub24oXCJpbml0LmpzdHJlZVwiLCAkLnByb3h5KGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0XHRcdHRoaXMuX2RhdGEuY2hlY2tib3gudmlzaWJsZSA9IHRoaXMuc2V0dGluZ3MuY2hlY2tib3gudmlzaWJsZTtcblx0XHRcdFx0XHRcdGlmKCF0aGlzLnNldHRpbmdzLmNoZWNrYm94LmtlZXBfc2VsZWN0ZWRfc3R5bGUpIHtcblx0XHRcdFx0XHRcdFx0dGhpcy5lbGVtZW50LmFkZENsYXNzKCdqc3RyZWUtY2hlY2tib3gtbm8tY2xpY2tlZCcpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0aWYodGhpcy5zZXR0aW5ncy5jaGVja2JveC50aWVfc2VsZWN0aW9uKSB7XG5cdFx0XHRcdFx0XHRcdHRoaXMuZWxlbWVudC5hZGRDbGFzcygnanN0cmVlLWNoZWNrYm94LXNlbGVjdGlvbicpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0sIHRoaXMpKVxuXHRcdFx0XHQub24oXCJsb2FkaW5nLmpzdHJlZVwiLCAkLnByb3h5KGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0XHRcdHRoaXNbIHRoaXMuX2RhdGEuY2hlY2tib3gudmlzaWJsZSA/ICdzaG93X2NoZWNrYm94ZXMnIDogJ2hpZGVfY2hlY2tib3hlcycgXSgpO1xuXHRcdFx0XHRcdH0sIHRoaXMpKTtcblx0XHRcdGlmKHRoaXMuc2V0dGluZ3MuY2hlY2tib3guY2FzY2FkZS5pbmRleE9mKCd1bmRldGVybWluZWQnKSAhPT0gLTEpIHtcblx0XHRcdFx0dGhpcy5lbGVtZW50XG5cdFx0XHRcdFx0Lm9uKCdjaGFuZ2VkLmpzdHJlZSB1bmNoZWNrX25vZGUuanN0cmVlIGNoZWNrX25vZGUuanN0cmVlIHVuY2hlY2tfYWxsLmpzdHJlZSBjaGVja19hbGwuanN0cmVlIG1vdmVfbm9kZS5qc3RyZWUgY29weV9ub2RlLmpzdHJlZSByZWRyYXcuanN0cmVlIG9wZW5fbm9kZS5qc3RyZWUnLCAkLnByb3h5KGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0XHRcdFx0Ly8gb25seSBpZiB1bmRldGVybWluZWQgaXMgaW4gc2V0dGluZ1xuXHRcdFx0XHRcdFx0XHRpZih0aGlzLl9kYXRhLmNoZWNrYm94LnV0bykgeyBjbGVhclRpbWVvdXQodGhpcy5fZGF0YS5jaGVja2JveC51dG8pOyB9XG5cdFx0XHRcdFx0XHRcdHRoaXMuX2RhdGEuY2hlY2tib3gudXRvID0gc2V0VGltZW91dCgkLnByb3h5KHRoaXMuX3VuZGV0ZXJtaW5lZCwgdGhpcyksIDUwKTtcblx0XHRcdFx0XHRcdH0sIHRoaXMpKTtcblx0XHRcdH1cblx0XHRcdGlmKCF0aGlzLnNldHRpbmdzLmNoZWNrYm94LnRpZV9zZWxlY3Rpb24pIHtcblx0XHRcdFx0dGhpcy5lbGVtZW50XG5cdFx0XHRcdFx0Lm9uKCdtb2RlbC5qc3RyZWUnLCAkLnByb3h5KGZ1bmN0aW9uIChlLCBkYXRhKSB7XG5cdFx0XHRcdFx0XHR2YXIgbSA9IHRoaXMuX21vZGVsLmRhdGEsXG5cdFx0XHRcdFx0XHRcdHAgPSBtW2RhdGEucGFyZW50XSxcblx0XHRcdFx0XHRcdFx0ZHBjID0gZGF0YS5ub2Rlcyxcblx0XHRcdFx0XHRcdFx0aSwgajtcblx0XHRcdFx0XHRcdGZvcihpID0gMCwgaiA9IGRwYy5sZW5ndGg7IGkgPCBqOyBpKyspIHtcblx0XHRcdFx0XHRcdFx0bVtkcGNbaV1dLnN0YXRlLmNoZWNrZWQgPSBtW2RwY1tpXV0uc3RhdGUuY2hlY2tlZCB8fCAobVtkcGNbaV1dLm9yaWdpbmFsICYmIG1bZHBjW2ldXS5vcmlnaW5hbC5zdGF0ZSAmJiBtW2RwY1tpXV0ub3JpZ2luYWwuc3RhdGUuY2hlY2tlZCk7XG5cdFx0XHRcdFx0XHRcdGlmKG1bZHBjW2ldXS5zdGF0ZS5jaGVja2VkKSB7XG5cdFx0XHRcdFx0XHRcdFx0dGhpcy5fZGF0YS5jaGVja2JveC5zZWxlY3RlZC5wdXNoKGRwY1tpXSk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9LCB0aGlzKSk7XG5cdFx0XHR9XG5cdFx0XHRpZih0aGlzLnNldHRpbmdzLmNoZWNrYm94LmNhc2NhZGUuaW5kZXhPZigndXAnKSAhPT0gLTEgfHwgdGhpcy5zZXR0aW5ncy5jaGVja2JveC5jYXNjYWRlLmluZGV4T2YoJ2Rvd24nKSAhPT0gLTEpIHtcblx0XHRcdFx0dGhpcy5lbGVtZW50XG5cdFx0XHRcdFx0Lm9uKCdtb2RlbC5qc3RyZWUnLCAkLnByb3h5KGZ1bmN0aW9uIChlLCBkYXRhKSB7XG5cdFx0XHRcdFx0XHRcdHZhciBtID0gdGhpcy5fbW9kZWwuZGF0YSxcblx0XHRcdFx0XHRcdFx0XHRwID0gbVtkYXRhLnBhcmVudF0sXG5cdFx0XHRcdFx0XHRcdFx0ZHBjID0gZGF0YS5ub2Rlcyxcblx0XHRcdFx0XHRcdFx0XHRjaGQgPSBbXSxcblx0XHRcdFx0XHRcdFx0XHRjLCBpLCBqLCBrLCBsLCB0bXAsIHMgPSB0aGlzLnNldHRpbmdzLmNoZWNrYm94LmNhc2NhZGUsIHQgPSB0aGlzLnNldHRpbmdzLmNoZWNrYm94LnRpZV9zZWxlY3Rpb247XG5cblx0XHRcdFx0XHRcdFx0aWYocy5pbmRleE9mKCdkb3duJykgIT09IC0xKSB7XG5cdFx0XHRcdFx0XHRcdFx0Ly8gYXBwbHkgZG93blxuXHRcdFx0XHRcdFx0XHRcdGlmKHAuc3RhdGVbIHQgPyAnc2VsZWN0ZWQnIDogJ2NoZWNrZWQnIF0pIHtcblx0XHRcdFx0XHRcdFx0XHRcdGZvcihpID0gMCwgaiA9IGRwYy5sZW5ndGg7IGkgPCBqOyBpKyspIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0bVtkcGNbaV1dLnN0YXRlWyB0ID8gJ3NlbGVjdGVkJyA6ICdjaGVja2VkJyBdID0gdHJ1ZTtcblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdHRoaXMuX2RhdGFbIHQgPyAnY29yZScgOiAnY2hlY2tib3gnIF0uc2VsZWN0ZWQgPSB0aGlzLl9kYXRhWyB0ID8gJ2NvcmUnIDogJ2NoZWNrYm94JyBdLnNlbGVjdGVkLmNvbmNhdChkcGMpO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRcdGZvcihpID0gMCwgaiA9IGRwYy5sZW5ndGg7IGkgPCBqOyBpKyspIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWYobVtkcGNbaV1dLnN0YXRlWyB0ID8gJ3NlbGVjdGVkJyA6ICdjaGVja2VkJyBdKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0Zm9yKGsgPSAwLCBsID0gbVtkcGNbaV1dLmNoaWxkcmVuX2QubGVuZ3RoOyBrIDwgbDsgaysrKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRtW21bZHBjW2ldXS5jaGlsZHJlbl9kW2tdXS5zdGF0ZVsgdCA/ICdzZWxlY3RlZCcgOiAnY2hlY2tlZCcgXSA9IHRydWU7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHRoaXMuX2RhdGFbIHQgPyAnY29yZScgOiAnY2hlY2tib3gnIF0uc2VsZWN0ZWQgPSB0aGlzLl9kYXRhWyB0ID8gJ2NvcmUnIDogJ2NoZWNrYm94JyBdLnNlbGVjdGVkLmNvbmNhdChtW2RwY1tpXV0uY2hpbGRyZW5fZCk7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRpZihzLmluZGV4T2YoJ3VwJykgIT09IC0xKSB7XG5cdFx0XHRcdFx0XHRcdFx0Ly8gYXBwbHkgdXBcblx0XHRcdFx0XHRcdFx0XHRmb3IoaSA9IDAsIGogPSBwLmNoaWxkcmVuX2QubGVuZ3RoOyBpIDwgajsgaSsrKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRpZighbVtwLmNoaWxkcmVuX2RbaV1dLmNoaWxkcmVuLmxlbmd0aCkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRjaGQucHVzaChtW3AuY2hpbGRyZW5fZFtpXV0ucGFyZW50KTtcblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0Y2hkID0gJC52YWthdGEuYXJyYXlfdW5pcXVlKGNoZCk7XG5cdFx0XHRcdFx0XHRcdFx0Zm9yKGsgPSAwLCBsID0gY2hkLmxlbmd0aDsgayA8IGw7IGsrKykge1xuXHRcdFx0XHRcdFx0XHRcdFx0cCA9IG1bY2hkW2tdXTtcblx0XHRcdFx0XHRcdFx0XHRcdHdoaWxlKHAgJiYgcC5pZCAhPT0gJC5qc3RyZWUucm9vdCkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRjID0gMDtcblx0XHRcdFx0XHRcdFx0XHRcdFx0Zm9yKGkgPSAwLCBqID0gcC5jaGlsZHJlbi5sZW5ndGg7IGkgPCBqOyBpKyspIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRjICs9IG1bcC5jaGlsZHJlbltpXV0uc3RhdGVbIHQgPyAnc2VsZWN0ZWQnIDogJ2NoZWNrZWQnIF07XG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0aWYoYyA9PT0gaikge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHAuc3RhdGVbIHQgPyAnc2VsZWN0ZWQnIDogJ2NoZWNrZWQnIF0gPSB0cnVlO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHRoaXMuX2RhdGFbIHQgPyAnY29yZScgOiAnY2hlY2tib3gnIF0uc2VsZWN0ZWQucHVzaChwLmlkKTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR0bXAgPSB0aGlzLmdldF9ub2RlKHAsIHRydWUpO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGlmKHRtcCAmJiB0bXAubGVuZ3RoKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR0bXAuYXR0cignYXJpYS1zZWxlY3RlZCcsIHRydWUpLmNoaWxkcmVuKCcuanN0cmVlLWFuY2hvcicpLmFkZENsYXNzKCB0ID8gJ2pzdHJlZS1jbGlja2VkJyA6ICdqc3RyZWUtY2hlY2tlZCcpO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRwID0gdGhpcy5nZXRfbm9kZShwLnBhcmVudCk7XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0dGhpcy5fZGF0YVsgdCA/ICdjb3JlJyA6ICdjaGVja2JveCcgXS5zZWxlY3RlZCA9ICQudmFrYXRhLmFycmF5X3VuaXF1ZSh0aGlzLl9kYXRhWyB0ID8gJ2NvcmUnIDogJ2NoZWNrYm94JyBdLnNlbGVjdGVkKTtcblx0XHRcdFx0XHRcdH0sIHRoaXMpKVxuXHRcdFx0XHRcdC5vbih0aGlzLnNldHRpbmdzLmNoZWNrYm94LnRpZV9zZWxlY3Rpb24gPyAnc2VsZWN0X25vZGUuanN0cmVlJyA6ICdjaGVja19ub2RlLmpzdHJlZScsICQucHJveHkoZnVuY3Rpb24gKGUsIGRhdGEpIHtcblx0XHRcdFx0XHRcdFx0dmFyIG9iaiA9IGRhdGEubm9kZSxcblx0XHRcdFx0XHRcdFx0XHRtID0gdGhpcy5fbW9kZWwuZGF0YSxcblx0XHRcdFx0XHRcdFx0XHRwYXIgPSB0aGlzLmdldF9ub2RlKG9iai5wYXJlbnQpLFxuXHRcdFx0XHRcdFx0XHRcdGRvbSA9IHRoaXMuZ2V0X25vZGUob2JqLCB0cnVlKSxcblx0XHRcdFx0XHRcdFx0XHRpLCBqLCBjLCB0bXAsIHMgPSB0aGlzLnNldHRpbmdzLmNoZWNrYm94LmNhc2NhZGUsIHQgPSB0aGlzLnNldHRpbmdzLmNoZWNrYm94LnRpZV9zZWxlY3Rpb24sXG5cdFx0XHRcdFx0XHRcdFx0c2VsID0ge30sIGN1ciA9IHRoaXMuX2RhdGFbIHQgPyAnY29yZScgOiAnY2hlY2tib3gnIF0uc2VsZWN0ZWQ7XG5cblx0XHRcdFx0XHRcdFx0Zm9yIChpID0gMCwgaiA9IGN1ci5sZW5ndGg7IGkgPCBqOyBpKyspIHtcblx0XHRcdFx0XHRcdFx0XHRzZWxbY3VyW2ldXSA9IHRydWU7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0Ly8gYXBwbHkgZG93blxuXHRcdFx0XHRcdFx0XHRpZihzLmluZGV4T2YoJ2Rvd24nKSAhPT0gLTEpIHtcblx0XHRcdFx0XHRcdFx0XHQvL3RoaXMuX2RhdGFbIHQgPyAnY29yZScgOiAnY2hlY2tib3gnIF0uc2VsZWN0ZWQgPSAkLnZha2F0YS5hcnJheV91bmlxdWUodGhpcy5fZGF0YVsgdCA/ICdjb3JlJyA6ICdjaGVja2JveCcgXS5zZWxlY3RlZC5jb25jYXQob2JqLmNoaWxkcmVuX2QpKTtcblx0XHRcdFx0XHRcdFx0XHRmb3IoaSA9IDAsIGogPSBvYmouY2hpbGRyZW5fZC5sZW5ndGg7IGkgPCBqOyBpKyspIHtcblx0XHRcdFx0XHRcdFx0XHRcdHNlbFtvYmouY2hpbGRyZW5fZFtpXV0gPSB0cnVlO1xuXHRcdFx0XHRcdFx0XHRcdFx0dG1wID0gbVtvYmouY2hpbGRyZW5fZFtpXV07XG5cdFx0XHRcdFx0XHRcdFx0XHR0bXAuc3RhdGVbIHQgPyAnc2VsZWN0ZWQnIDogJ2NoZWNrZWQnIF0gPSB0cnVlO1xuXHRcdFx0XHRcdFx0XHRcdFx0aWYodG1wICYmIHRtcC5vcmlnaW5hbCAmJiB0bXAub3JpZ2luYWwuc3RhdGUgJiYgdG1wLm9yaWdpbmFsLnN0YXRlLnVuZGV0ZXJtaW5lZCkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0bXAub3JpZ2luYWwuc3RhdGUudW5kZXRlcm1pbmVkID0gZmFsc2U7XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0Ly8gYXBwbHkgdXBcblx0XHRcdFx0XHRcdFx0aWYocy5pbmRleE9mKCd1cCcpICE9PSAtMSkge1xuXHRcdFx0XHRcdFx0XHRcdHdoaWxlKHBhciAmJiBwYXIuaWQgIT09ICQuanN0cmVlLnJvb3QpIHtcblx0XHRcdFx0XHRcdFx0XHRcdGMgPSAwO1xuXHRcdFx0XHRcdFx0XHRcdFx0Zm9yKGkgPSAwLCBqID0gcGFyLmNoaWxkcmVuLmxlbmd0aDsgaSA8IGo7IGkrKykge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRjICs9IG1bcGFyLmNoaWxkcmVuW2ldXS5zdGF0ZVsgdCA/ICdzZWxlY3RlZCcgOiAnY2hlY2tlZCcgXTtcblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdGlmKGMgPT09IGopIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0cGFyLnN0YXRlWyB0ID8gJ3NlbGVjdGVkJyA6ICdjaGVja2VkJyBdID0gdHJ1ZTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0c2VsW3Bhci5pZF0gPSB0cnVlO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHQvL3RoaXMuX2RhdGFbIHQgPyAnY29yZScgOiAnY2hlY2tib3gnIF0uc2VsZWN0ZWQucHVzaChwYXIuaWQpO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0bXAgPSB0aGlzLmdldF9ub2RlKHBhciwgdHJ1ZSk7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlmKHRtcCAmJiB0bXAubGVuZ3RoKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0dG1wLmF0dHIoJ2FyaWEtc2VsZWN0ZWQnLCB0cnVlKS5jaGlsZHJlbignLmpzdHJlZS1hbmNob3InKS5hZGRDbGFzcyh0ID8gJ2pzdHJlZS1jbGlja2VkJyA6ICdqc3RyZWUtY2hlY2tlZCcpO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHRwYXIgPSB0aGlzLmdldF9ub2RlKHBhci5wYXJlbnQpO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdGN1ciA9IFtdO1xuXHRcdFx0XHRcdFx0XHRmb3IgKGkgaW4gc2VsKSB7XG5cdFx0XHRcdFx0XHRcdFx0aWYgKHNlbC5oYXNPd25Qcm9wZXJ0eShpKSkge1xuXHRcdFx0XHRcdFx0XHRcdFx0Y3VyLnB1c2goaSk7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdHRoaXMuX2RhdGFbIHQgPyAnY29yZScgOiAnY2hlY2tib3gnIF0uc2VsZWN0ZWQgPSBjdXI7XG5cblx0XHRcdFx0XHRcdFx0Ly8gYXBwbHkgZG93biAocHJvY2VzcyAuY2hpbGRyZW4gc2VwYXJhdGVseT8pXG5cdFx0XHRcdFx0XHRcdGlmKHMuaW5kZXhPZignZG93bicpICE9PSAtMSAmJiBkb20ubGVuZ3RoKSB7XG5cdFx0XHRcdFx0XHRcdFx0ZG9tLmZpbmQoJy5qc3RyZWUtYW5jaG9yJykuYWRkQ2xhc3ModCA/ICdqc3RyZWUtY2xpY2tlZCcgOiAnanN0cmVlLWNoZWNrZWQnKS5wYXJlbnQoKS5hdHRyKCdhcmlhLXNlbGVjdGVkJywgdHJ1ZSk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH0sIHRoaXMpKVxuXHRcdFx0XHRcdC5vbih0aGlzLnNldHRpbmdzLmNoZWNrYm94LnRpZV9zZWxlY3Rpb24gPyAnZGVzZWxlY3RfYWxsLmpzdHJlZScgOiAndW5jaGVja19hbGwuanN0cmVlJywgJC5wcm94eShmdW5jdGlvbiAoZSwgZGF0YSkge1xuXHRcdFx0XHRcdFx0XHR2YXIgb2JqID0gdGhpcy5nZXRfbm9kZSgkLmpzdHJlZS5yb290KSxcblx0XHRcdFx0XHRcdFx0XHRtID0gdGhpcy5fbW9kZWwuZGF0YSxcblx0XHRcdFx0XHRcdFx0XHRpLCBqLCB0bXA7XG5cdFx0XHRcdFx0XHRcdGZvcihpID0gMCwgaiA9IG9iai5jaGlsZHJlbl9kLmxlbmd0aDsgaSA8IGo7IGkrKykge1xuXHRcdFx0XHRcdFx0XHRcdHRtcCA9IG1bb2JqLmNoaWxkcmVuX2RbaV1dO1xuXHRcdFx0XHRcdFx0XHRcdGlmKHRtcCAmJiB0bXAub3JpZ2luYWwgJiYgdG1wLm9yaWdpbmFsLnN0YXRlICYmIHRtcC5vcmlnaW5hbC5zdGF0ZS51bmRldGVybWluZWQpIHtcblx0XHRcdFx0XHRcdFx0XHRcdHRtcC5vcmlnaW5hbC5zdGF0ZS51bmRldGVybWluZWQgPSBmYWxzZTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH0sIHRoaXMpKVxuXHRcdFx0XHRcdC5vbih0aGlzLnNldHRpbmdzLmNoZWNrYm94LnRpZV9zZWxlY3Rpb24gPyAnZGVzZWxlY3Rfbm9kZS5qc3RyZWUnIDogJ3VuY2hlY2tfbm9kZS5qc3RyZWUnLCAkLnByb3h5KGZ1bmN0aW9uIChlLCBkYXRhKSB7XG5cdFx0XHRcdFx0XHRcdHZhciBvYmogPSBkYXRhLm5vZGUsXG5cdFx0XHRcdFx0XHRcdFx0ZG9tID0gdGhpcy5nZXRfbm9kZShvYmosIHRydWUpLFxuXHRcdFx0XHRcdFx0XHRcdGksIGosIHRtcCwgcyA9IHRoaXMuc2V0dGluZ3MuY2hlY2tib3guY2FzY2FkZSwgdCA9IHRoaXMuc2V0dGluZ3MuY2hlY2tib3gudGllX3NlbGVjdGlvbixcblx0XHRcdFx0XHRcdFx0XHRjdXIgPSB0aGlzLl9kYXRhWyB0ID8gJ2NvcmUnIDogJ2NoZWNrYm94JyBdLnNlbGVjdGVkLCBzZWwgPSB7fTtcblx0XHRcdFx0XHRcdFx0aWYob2JqICYmIG9iai5vcmlnaW5hbCAmJiBvYmoub3JpZ2luYWwuc3RhdGUgJiYgb2JqLm9yaWdpbmFsLnN0YXRlLnVuZGV0ZXJtaW5lZCkge1xuXHRcdFx0XHRcdFx0XHRcdG9iai5vcmlnaW5hbC5zdGF0ZS51bmRldGVybWluZWQgPSBmYWxzZTtcblx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdC8vIGFwcGx5IGRvd25cblx0XHRcdFx0XHRcdFx0aWYocy5pbmRleE9mKCdkb3duJykgIT09IC0xKSB7XG5cdFx0XHRcdFx0XHRcdFx0Zm9yKGkgPSAwLCBqID0gb2JqLmNoaWxkcmVuX2QubGVuZ3RoOyBpIDwgajsgaSsrKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHR0bXAgPSB0aGlzLl9tb2RlbC5kYXRhW29iai5jaGlsZHJlbl9kW2ldXTtcblx0XHRcdFx0XHRcdFx0XHRcdHRtcC5zdGF0ZVsgdCA/ICdzZWxlY3RlZCcgOiAnY2hlY2tlZCcgXSA9IGZhbHNlO1xuXHRcdFx0XHRcdFx0XHRcdFx0aWYodG1wICYmIHRtcC5vcmlnaW5hbCAmJiB0bXAub3JpZ2luYWwuc3RhdGUgJiYgdG1wLm9yaWdpbmFsLnN0YXRlLnVuZGV0ZXJtaW5lZCkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0bXAub3JpZ2luYWwuc3RhdGUudW5kZXRlcm1pbmVkID0gZmFsc2U7XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0Ly8gYXBwbHkgdXBcblx0XHRcdFx0XHRcdFx0aWYocy5pbmRleE9mKCd1cCcpICE9PSAtMSkge1xuXHRcdFx0XHRcdFx0XHRcdGZvcihpID0gMCwgaiA9IG9iai5wYXJlbnRzLmxlbmd0aDsgaSA8IGo7IGkrKykge1xuXHRcdFx0XHRcdFx0XHRcdFx0dG1wID0gdGhpcy5fbW9kZWwuZGF0YVtvYmoucGFyZW50c1tpXV07XG5cdFx0XHRcdFx0XHRcdFx0XHR0bXAuc3RhdGVbIHQgPyAnc2VsZWN0ZWQnIDogJ2NoZWNrZWQnIF0gPSBmYWxzZTtcblx0XHRcdFx0XHRcdFx0XHRcdGlmKHRtcCAmJiB0bXAub3JpZ2luYWwgJiYgdG1wLm9yaWdpbmFsLnN0YXRlICYmIHRtcC5vcmlnaW5hbC5zdGF0ZS51bmRldGVybWluZWQpIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dG1wLm9yaWdpbmFsLnN0YXRlLnVuZGV0ZXJtaW5lZCA9IGZhbHNlO1xuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0dG1wID0gdGhpcy5nZXRfbm9kZShvYmoucGFyZW50c1tpXSwgdHJ1ZSk7XG5cdFx0XHRcdFx0XHRcdFx0XHRpZih0bXAgJiYgdG1wLmxlbmd0aCkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0bXAuYXR0cignYXJpYS1zZWxlY3RlZCcsIGZhbHNlKS5jaGlsZHJlbignLmpzdHJlZS1hbmNob3InKS5yZW1vdmVDbGFzcyh0ID8gJ2pzdHJlZS1jbGlja2VkJyA6ICdqc3RyZWUtY2hlY2tlZCcpO1xuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRzZWwgPSB7fTtcblx0XHRcdFx0XHRcdFx0Zm9yKGkgPSAwLCBqID0gY3VyLmxlbmd0aDsgaSA8IGo7IGkrKykge1xuXHRcdFx0XHRcdFx0XHRcdC8vIGFwcGx5IGRvd24gKyBhcHBseSB1cFxuXHRcdFx0XHRcdFx0XHRcdGlmKFxuXHRcdFx0XHRcdFx0XHRcdFx0KHMuaW5kZXhPZignZG93bicpID09PSAtMSB8fCAkLmluQXJyYXkoY3VyW2ldLCBvYmouY2hpbGRyZW5fZCkgPT09IC0xKSAmJlxuXHRcdFx0XHRcdFx0XHRcdFx0KHMuaW5kZXhPZigndXAnKSA9PT0gLTEgfHwgJC5pbkFycmF5KGN1cltpXSwgb2JqLnBhcmVudHMpID09PSAtMSlcblx0XHRcdFx0XHRcdFx0XHQpIHtcblx0XHRcdFx0XHRcdFx0XHRcdHNlbFtjdXJbaV1dID0gdHJ1ZTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0Y3VyID0gW107XG5cdFx0XHRcdFx0XHRcdGZvciAoaSBpbiBzZWwpIHtcblx0XHRcdFx0XHRcdFx0XHRpZiAoc2VsLmhhc093blByb3BlcnR5KGkpKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRjdXIucHVzaChpKTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0dGhpcy5fZGF0YVsgdCA/ICdjb3JlJyA6ICdjaGVja2JveCcgXS5zZWxlY3RlZCA9IGN1cjtcblx0XHRcdFx0XHRcdFx0XG5cdFx0XHRcdFx0XHRcdC8vIGFwcGx5IGRvd24gKHByb2Nlc3MgLmNoaWxkcmVuIHNlcGFyYXRlbHk/KVxuXHRcdFx0XHRcdFx0XHRpZihzLmluZGV4T2YoJ2Rvd24nKSAhPT0gLTEgJiYgZG9tLmxlbmd0aCkge1xuXHRcdFx0XHRcdFx0XHRcdGRvbS5maW5kKCcuanN0cmVlLWFuY2hvcicpLnJlbW92ZUNsYXNzKHQgPyAnanN0cmVlLWNsaWNrZWQnIDogJ2pzdHJlZS1jaGVja2VkJykucGFyZW50KCkuYXR0cignYXJpYS1zZWxlY3RlZCcsIGZhbHNlKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fSwgdGhpcykpO1xuXHRcdFx0fVxuXHRcdFx0aWYodGhpcy5zZXR0aW5ncy5jaGVja2JveC5jYXNjYWRlLmluZGV4T2YoJ3VwJykgIT09IC0xKSB7XG5cdFx0XHRcdHRoaXMuZWxlbWVudFxuXHRcdFx0XHRcdC5vbignZGVsZXRlX25vZGUuanN0cmVlJywgJC5wcm94eShmdW5jdGlvbiAoZSwgZGF0YSkge1xuXHRcdFx0XHRcdFx0XHQvLyBhcHBseSB1cCAod2hvbGUgaGFuZGxlcilcblx0XHRcdFx0XHRcdFx0dmFyIHAgPSB0aGlzLmdldF9ub2RlKGRhdGEucGFyZW50KSxcblx0XHRcdFx0XHRcdFx0XHRtID0gdGhpcy5fbW9kZWwuZGF0YSxcblx0XHRcdFx0XHRcdFx0XHRpLCBqLCBjLCB0bXAsIHQgPSB0aGlzLnNldHRpbmdzLmNoZWNrYm94LnRpZV9zZWxlY3Rpb247XG5cdFx0XHRcdFx0XHRcdHdoaWxlKHAgJiYgcC5pZCAhPT0gJC5qc3RyZWUucm9vdCAmJiAhcC5zdGF0ZVsgdCA/ICdzZWxlY3RlZCcgOiAnY2hlY2tlZCcgXSkge1xuXHRcdFx0XHRcdFx0XHRcdGMgPSAwO1xuXHRcdFx0XHRcdFx0XHRcdGZvcihpID0gMCwgaiA9IHAuY2hpbGRyZW4ubGVuZ3RoOyBpIDwgajsgaSsrKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRjICs9IG1bcC5jaGlsZHJlbltpXV0uc3RhdGVbIHQgPyAnc2VsZWN0ZWQnIDogJ2NoZWNrZWQnIF07XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdGlmKGogPiAwICYmIGMgPT09IGopIHtcblx0XHRcdFx0XHRcdFx0XHRcdHAuc3RhdGVbIHQgPyAnc2VsZWN0ZWQnIDogJ2NoZWNrZWQnIF0gPSB0cnVlO1xuXHRcdFx0XHRcdFx0XHRcdFx0dGhpcy5fZGF0YVsgdCA/ICdjb3JlJyA6ICdjaGVja2JveCcgXS5zZWxlY3RlZC5wdXNoKHAuaWQpO1xuXHRcdFx0XHRcdFx0XHRcdFx0dG1wID0gdGhpcy5nZXRfbm9kZShwLCB0cnVlKTtcblx0XHRcdFx0XHRcdFx0XHRcdGlmKHRtcCAmJiB0bXAubGVuZ3RoKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHRtcC5hdHRyKCdhcmlhLXNlbGVjdGVkJywgdHJ1ZSkuY2hpbGRyZW4oJy5qc3RyZWUtYW5jaG9yJykuYWRkQ2xhc3ModCA/ICdqc3RyZWUtY2xpY2tlZCcgOiAnanN0cmVlLWNoZWNrZWQnKTtcblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0cCA9IHRoaXMuZ2V0X25vZGUocC5wYXJlbnQpO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9LCB0aGlzKSlcblx0XHRcdFx0XHQub24oJ21vdmVfbm9kZS5qc3RyZWUnLCAkLnByb3h5KGZ1bmN0aW9uIChlLCBkYXRhKSB7XG5cdFx0XHRcdFx0XHRcdC8vIGFwcGx5IHVwICh3aG9sZSBoYW5kbGVyKVxuXHRcdFx0XHRcdFx0XHR2YXIgaXNfbXVsdGkgPSBkYXRhLmlzX211bHRpLFxuXHRcdFx0XHRcdFx0XHRcdG9sZF9wYXIgPSBkYXRhLm9sZF9wYXJlbnQsXG5cdFx0XHRcdFx0XHRcdFx0bmV3X3BhciA9IHRoaXMuZ2V0X25vZGUoZGF0YS5wYXJlbnQpLFxuXHRcdFx0XHRcdFx0XHRcdG0gPSB0aGlzLl9tb2RlbC5kYXRhLFxuXHRcdFx0XHRcdFx0XHRcdHAsIGMsIGksIGosIHRtcCwgdCA9IHRoaXMuc2V0dGluZ3MuY2hlY2tib3gudGllX3NlbGVjdGlvbjtcblx0XHRcdFx0XHRcdFx0aWYoIWlzX211bHRpKSB7XG5cdFx0XHRcdFx0XHRcdFx0cCA9IHRoaXMuZ2V0X25vZGUob2xkX3Bhcik7XG5cdFx0XHRcdFx0XHRcdFx0d2hpbGUocCAmJiBwLmlkICE9PSAkLmpzdHJlZS5yb290ICYmICFwLnN0YXRlWyB0ID8gJ3NlbGVjdGVkJyA6ICdjaGVja2VkJyBdKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRjID0gMDtcblx0XHRcdFx0XHRcdFx0XHRcdGZvcihpID0gMCwgaiA9IHAuY2hpbGRyZW4ubGVuZ3RoOyBpIDwgajsgaSsrKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGMgKz0gbVtwLmNoaWxkcmVuW2ldXS5zdGF0ZVsgdCA/ICdzZWxlY3RlZCcgOiAnY2hlY2tlZCcgXTtcblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdGlmKGogPiAwICYmIGMgPT09IGopIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0cC5zdGF0ZVsgdCA/ICdzZWxlY3RlZCcgOiAnY2hlY2tlZCcgXSA9IHRydWU7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHRoaXMuX2RhdGFbIHQgPyAnY29yZScgOiAnY2hlY2tib3gnIF0uc2VsZWN0ZWQucHVzaChwLmlkKTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dG1wID0gdGhpcy5nZXRfbm9kZShwLCB0cnVlKTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWYodG1wICYmIHRtcC5sZW5ndGgpIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR0bXAuYXR0cignYXJpYS1zZWxlY3RlZCcsIHRydWUpLmNoaWxkcmVuKCcuanN0cmVlLWFuY2hvcicpLmFkZENsYXNzKHQgPyAnanN0cmVlLWNsaWNrZWQnIDogJ2pzdHJlZS1jaGVja2VkJyk7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdHAgPSB0aGlzLmdldF9ub2RlKHAucGFyZW50KTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0cCA9IG5ld19wYXI7XG5cdFx0XHRcdFx0XHRcdHdoaWxlKHAgJiYgcC5pZCAhPT0gJC5qc3RyZWUucm9vdCkge1xuXHRcdFx0XHRcdFx0XHRcdGMgPSAwO1xuXHRcdFx0XHRcdFx0XHRcdGZvcihpID0gMCwgaiA9IHAuY2hpbGRyZW4ubGVuZ3RoOyBpIDwgajsgaSsrKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRjICs9IG1bcC5jaGlsZHJlbltpXV0uc3RhdGVbIHQgPyAnc2VsZWN0ZWQnIDogJ2NoZWNrZWQnIF07XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdGlmKGMgPT09IGopIHtcblx0XHRcdFx0XHRcdFx0XHRcdGlmKCFwLnN0YXRlWyB0ID8gJ3NlbGVjdGVkJyA6ICdjaGVja2VkJyBdKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHAuc3RhdGVbIHQgPyAnc2VsZWN0ZWQnIDogJ2NoZWNrZWQnIF0gPSB0cnVlO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0aGlzLl9kYXRhWyB0ID8gJ2NvcmUnIDogJ2NoZWNrYm94JyBdLnNlbGVjdGVkLnB1c2gocC5pZCk7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHRtcCA9IHRoaXMuZ2V0X25vZGUocCwgdHJ1ZSk7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlmKHRtcCAmJiB0bXAubGVuZ3RoKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0dG1wLmF0dHIoJ2FyaWEtc2VsZWN0ZWQnLCB0cnVlKS5jaGlsZHJlbignLmpzdHJlZS1hbmNob3InKS5hZGRDbGFzcyh0ID8gJ2pzdHJlZS1jbGlja2VkJyA6ICdqc3RyZWUtY2hlY2tlZCcpO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdFx0aWYocC5zdGF0ZVsgdCA/ICdzZWxlY3RlZCcgOiAnY2hlY2tlZCcgXSkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRwLnN0YXRlWyB0ID8gJ3NlbGVjdGVkJyA6ICdjaGVja2VkJyBdID0gZmFsc2U7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHRoaXMuX2RhdGFbIHQgPyAnY29yZScgOiAnY2hlY2tib3gnIF0uc2VsZWN0ZWQgPSAkLnZha2F0YS5hcnJheV9yZW1vdmVfaXRlbSh0aGlzLl9kYXRhWyB0ID8gJ2NvcmUnIDogJ2NoZWNrYm94JyBdLnNlbGVjdGVkLCBwLmlkKTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dG1wID0gdGhpcy5nZXRfbm9kZShwLCB0cnVlKTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWYodG1wICYmIHRtcC5sZW5ndGgpIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR0bXAuYXR0cignYXJpYS1zZWxlY3RlZCcsIGZhbHNlKS5jaGlsZHJlbignLmpzdHJlZS1hbmNob3InKS5yZW1vdmVDbGFzcyh0ID8gJ2pzdHJlZS1jbGlja2VkJyA6ICdqc3RyZWUtY2hlY2tlZCcpO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdHAgPSB0aGlzLmdldF9ub2RlKHAucGFyZW50KTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fSwgdGhpcykpO1xuXHRcdFx0fVxuXHRcdH07XG5cdFx0LyoqXG5cdFx0ICogc2V0IHRoZSB1bmRldGVybWluZWQgc3RhdGUgd2hlcmUgYW5kIGlmIG5lY2Vzc2FyeS4gVXNlZCBpbnRlcm5hbGx5LlxuXHRcdCAqIEBwcml2YXRlXG5cdFx0ICogQG5hbWUgX3VuZGV0ZXJtaW5lZCgpXG5cdFx0ICogQHBsdWdpbiBjaGVja2JveFxuXHRcdCAqL1xuXHRcdHRoaXMuX3VuZGV0ZXJtaW5lZCA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdGlmKHRoaXMuZWxlbWVudCA9PT0gbnVsbCkgeyByZXR1cm47IH1cblx0XHRcdHZhciBpLCBqLCBrLCBsLCBvID0ge30sIG0gPSB0aGlzLl9tb2RlbC5kYXRhLCB0ID0gdGhpcy5zZXR0aW5ncy5jaGVja2JveC50aWVfc2VsZWN0aW9uLCBzID0gdGhpcy5fZGF0YVsgdCA/ICdjb3JlJyA6ICdjaGVja2JveCcgXS5zZWxlY3RlZCwgcCA9IFtdLCB0dCA9IHRoaXM7XG5cdFx0XHRmb3IoaSA9IDAsIGogPSBzLmxlbmd0aDsgaSA8IGo7IGkrKykge1xuXHRcdFx0XHRpZihtW3NbaV1dICYmIG1bc1tpXV0ucGFyZW50cykge1xuXHRcdFx0XHRcdGZvcihrID0gMCwgbCA9IG1bc1tpXV0ucGFyZW50cy5sZW5ndGg7IGsgPCBsOyBrKyspIHtcblx0XHRcdFx0XHRcdGlmKG9bbVtzW2ldXS5wYXJlbnRzW2tdXSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0aWYobVtzW2ldXS5wYXJlbnRzW2tdICE9PSAkLmpzdHJlZS5yb290KSB7XG5cdFx0XHRcdFx0XHRcdG9bbVtzW2ldXS5wYXJlbnRzW2tdXSA9IHRydWU7XG5cdFx0XHRcdFx0XHRcdHAucHVzaChtW3NbaV1dLnBhcmVudHNba10pO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0Ly8gYXR0ZW1wdCBmb3Igc2VydmVyIHNpZGUgdW5kZXRlcm1pbmVkIHN0YXRlXG5cdFx0XHR0aGlzLmVsZW1lbnQuZmluZCgnLmpzdHJlZS1jbG9zZWQnKS5ub3QoJzpoYXMoLmpzdHJlZS1jaGlsZHJlbiknKVxuXHRcdFx0XHQuZWFjaChmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdFx0dmFyIHRtcCA9IHR0LmdldF9ub2RlKHRoaXMpLCB0bXAyO1xuXHRcdFx0XHRcdGlmKCF0bXAuc3RhdGUubG9hZGVkKSB7XG5cdFx0XHRcdFx0XHRpZih0bXAub3JpZ2luYWwgJiYgdG1wLm9yaWdpbmFsLnN0YXRlICYmIHRtcC5vcmlnaW5hbC5zdGF0ZS51bmRldGVybWluZWQgJiYgdG1wLm9yaWdpbmFsLnN0YXRlLnVuZGV0ZXJtaW5lZCA9PT0gdHJ1ZSkge1xuXHRcdFx0XHRcdFx0XHRpZihvW3RtcC5pZF0gPT09IHVuZGVmaW5lZCAmJiB0bXAuaWQgIT09ICQuanN0cmVlLnJvb3QpIHtcblx0XHRcdFx0XHRcdFx0XHRvW3RtcC5pZF0gPSB0cnVlO1xuXHRcdFx0XHRcdFx0XHRcdHAucHVzaCh0bXAuaWQpO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdGZvcihrID0gMCwgbCA9IHRtcC5wYXJlbnRzLmxlbmd0aDsgayA8IGw7IGsrKykge1xuXHRcdFx0XHRcdFx0XHRcdGlmKG9bdG1wLnBhcmVudHNba11dID09PSB1bmRlZmluZWQgJiYgdG1wLnBhcmVudHNba10gIT09ICQuanN0cmVlLnJvb3QpIHtcblx0XHRcdFx0XHRcdFx0XHRcdG9bdG1wLnBhcmVudHNba11dID0gdHJ1ZTtcblx0XHRcdFx0XHRcdFx0XHRcdHAucHVzaCh0bXAucGFyZW50c1trXSk7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdFx0Zm9yKGkgPSAwLCBqID0gdG1wLmNoaWxkcmVuX2QubGVuZ3RoOyBpIDwgajsgaSsrKSB7XG5cdFx0XHRcdFx0XHRcdHRtcDIgPSBtW3RtcC5jaGlsZHJlbl9kW2ldXTtcblx0XHRcdFx0XHRcdFx0aWYoIXRtcDIuc3RhdGUubG9hZGVkICYmIHRtcDIub3JpZ2luYWwgJiYgdG1wMi5vcmlnaW5hbC5zdGF0ZSAmJiB0bXAyLm9yaWdpbmFsLnN0YXRlLnVuZGV0ZXJtaW5lZCAmJiB0bXAyLm9yaWdpbmFsLnN0YXRlLnVuZGV0ZXJtaW5lZCA9PT0gdHJ1ZSkge1xuXHRcdFx0XHRcdFx0XHRcdGlmKG9bdG1wMi5pZF0gPT09IHVuZGVmaW5lZCAmJiB0bXAyLmlkICE9PSAkLmpzdHJlZS5yb290KSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRvW3RtcDIuaWRdID0gdHJ1ZTtcblx0XHRcdFx0XHRcdFx0XHRcdHAucHVzaCh0bXAyLmlkKTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0Zm9yKGsgPSAwLCBsID0gdG1wMi5wYXJlbnRzLmxlbmd0aDsgayA8IGw7IGsrKykge1xuXHRcdFx0XHRcdFx0XHRcdFx0aWYob1t0bXAyLnBhcmVudHNba11dID09PSB1bmRlZmluZWQgJiYgdG1wMi5wYXJlbnRzW2tdICE9PSAkLmpzdHJlZS5yb290KSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdG9bdG1wMi5wYXJlbnRzW2tdXSA9IHRydWU7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHAucHVzaCh0bXAyLnBhcmVudHNba10pO1xuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSk7XG5cblx0XHRcdHRoaXMuZWxlbWVudC5maW5kKCcuanN0cmVlLXVuZGV0ZXJtaW5lZCcpLnJlbW92ZUNsYXNzKCdqc3RyZWUtdW5kZXRlcm1pbmVkJyk7XG5cdFx0XHRmb3IoaSA9IDAsIGogPSBwLmxlbmd0aDsgaSA8IGo7IGkrKykge1xuXHRcdFx0XHRpZighbVtwW2ldXS5zdGF0ZVsgdCA/ICdzZWxlY3RlZCcgOiAnY2hlY2tlZCcgXSkge1xuXHRcdFx0XHRcdHMgPSB0aGlzLmdldF9ub2RlKHBbaV0sIHRydWUpO1xuXHRcdFx0XHRcdGlmKHMgJiYgcy5sZW5ndGgpIHtcblx0XHRcdFx0XHRcdHMuY2hpbGRyZW4oJy5qc3RyZWUtYW5jaG9yJykuY2hpbGRyZW4oJy5qc3RyZWUtY2hlY2tib3gnKS5hZGRDbGFzcygnanN0cmVlLXVuZGV0ZXJtaW5lZCcpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH07XG5cdFx0dGhpcy5yZWRyYXdfbm9kZSA9IGZ1bmN0aW9uKG9iaiwgZGVlcCwgaXNfY2FsbGJhY2ssIGZvcmNlX3JlbmRlcikge1xuXHRcdFx0b2JqID0gcGFyZW50LnJlZHJhd19ub2RlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdFx0XHRpZihvYmopIHtcblx0XHRcdFx0dmFyIGksIGosIHRtcCA9IG51bGwsIGljb24gPSBudWxsO1xuXHRcdFx0XHRmb3IoaSA9IDAsIGogPSBvYmouY2hpbGROb2Rlcy5sZW5ndGg7IGkgPCBqOyBpKyspIHtcblx0XHRcdFx0XHRpZihvYmouY2hpbGROb2Rlc1tpXSAmJiBvYmouY2hpbGROb2Rlc1tpXS5jbGFzc05hbWUgJiYgb2JqLmNoaWxkTm9kZXNbaV0uY2xhc3NOYW1lLmluZGV4T2YoXCJqc3RyZWUtYW5jaG9yXCIpICE9PSAtMSkge1xuXHRcdFx0XHRcdFx0dG1wID0gb2JqLmNoaWxkTm9kZXNbaV07XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYodG1wKSB7XG5cdFx0XHRcdFx0aWYoIXRoaXMuc2V0dGluZ3MuY2hlY2tib3gudGllX3NlbGVjdGlvbiAmJiB0aGlzLl9tb2RlbC5kYXRhW29iai5pZF0uc3RhdGUuY2hlY2tlZCkgeyB0bXAuY2xhc3NOYW1lICs9ICcganN0cmVlLWNoZWNrZWQnOyB9XG5cdFx0XHRcdFx0aWNvbiA9IF9pLmNsb25lTm9kZShmYWxzZSk7XG5cdFx0XHRcdFx0aWYodGhpcy5fbW9kZWwuZGF0YVtvYmouaWRdLnN0YXRlLmNoZWNrYm94X2Rpc2FibGVkKSB7IGljb24uY2xhc3NOYW1lICs9ICcganN0cmVlLWNoZWNrYm94LWRpc2FibGVkJzsgfVxuXHRcdFx0XHRcdHRtcC5pbnNlcnRCZWZvcmUoaWNvbiwgdG1wLmNoaWxkTm9kZXNbMF0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRpZighaXNfY2FsbGJhY2sgJiYgdGhpcy5zZXR0aW5ncy5jaGVja2JveC5jYXNjYWRlLmluZGV4T2YoJ3VuZGV0ZXJtaW5lZCcpICE9PSAtMSkge1xuXHRcdFx0XHRpZih0aGlzLl9kYXRhLmNoZWNrYm94LnV0bykgeyBjbGVhclRpbWVvdXQodGhpcy5fZGF0YS5jaGVja2JveC51dG8pOyB9XG5cdFx0XHRcdHRoaXMuX2RhdGEuY2hlY2tib3gudXRvID0gc2V0VGltZW91dCgkLnByb3h5KHRoaXMuX3VuZGV0ZXJtaW5lZCwgdGhpcyksIDUwKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBvYmo7XG5cdFx0fTtcblx0XHQvKipcblx0XHQgKiBzaG93IHRoZSBub2RlIGNoZWNrYm94IGljb25zXG5cdFx0ICogQG5hbWUgc2hvd19jaGVja2JveGVzKClcblx0XHQgKiBAcGx1Z2luIGNoZWNrYm94XG5cdFx0ICovXG5cdFx0dGhpcy5zaG93X2NoZWNrYm94ZXMgPSBmdW5jdGlvbiAoKSB7IHRoaXMuX2RhdGEuY29yZS50aGVtZXMuY2hlY2tib3hlcyA9IHRydWU7IHRoaXMuZ2V0X2NvbnRhaW5lcl91bCgpLnJlbW92ZUNsYXNzKFwianN0cmVlLW5vLWNoZWNrYm94ZXNcIik7IH07XG5cdFx0LyoqXG5cdFx0ICogaGlkZSB0aGUgbm9kZSBjaGVja2JveCBpY29uc1xuXHRcdCAqIEBuYW1lIGhpZGVfY2hlY2tib3hlcygpXG5cdFx0ICogQHBsdWdpbiBjaGVja2JveFxuXHRcdCAqL1xuXHRcdHRoaXMuaGlkZV9jaGVja2JveGVzID0gZnVuY3Rpb24gKCkgeyB0aGlzLl9kYXRhLmNvcmUudGhlbWVzLmNoZWNrYm94ZXMgPSBmYWxzZTsgdGhpcy5nZXRfY29udGFpbmVyX3VsKCkuYWRkQ2xhc3MoXCJqc3RyZWUtbm8tY2hlY2tib3hlc1wiKTsgfTtcblx0XHQvKipcblx0XHQgKiB0b2dnbGUgdGhlIG5vZGUgaWNvbnNcblx0XHQgKiBAbmFtZSB0b2dnbGVfY2hlY2tib3hlcygpXG5cdFx0ICogQHBsdWdpbiBjaGVja2JveFxuXHRcdCAqL1xuXHRcdHRoaXMudG9nZ2xlX2NoZWNrYm94ZXMgPSBmdW5jdGlvbiAoKSB7IGlmKHRoaXMuX2RhdGEuY29yZS50aGVtZXMuY2hlY2tib3hlcykgeyB0aGlzLmhpZGVfY2hlY2tib3hlcygpOyB9IGVsc2UgeyB0aGlzLnNob3dfY2hlY2tib3hlcygpOyB9IH07XG5cdFx0LyoqXG5cdFx0ICogY2hlY2tzIGlmIGEgbm9kZSBpcyBpbiBhbiB1bmRldGVybWluZWQgc3RhdGVcblx0XHQgKiBAbmFtZSBpc191bmRldGVybWluZWQob2JqKVxuXHRcdCAqIEBwYXJhbSAge21peGVkfSBvYmpcblx0XHQgKiBAcmV0dXJuIHtCb29sZWFufVxuXHRcdCAqL1xuXHRcdHRoaXMuaXNfdW5kZXRlcm1pbmVkID0gZnVuY3Rpb24gKG9iaikge1xuXHRcdFx0b2JqID0gdGhpcy5nZXRfbm9kZShvYmopO1xuXHRcdFx0dmFyIHMgPSB0aGlzLnNldHRpbmdzLmNoZWNrYm94LmNhc2NhZGUsIGksIGosIHQgPSB0aGlzLnNldHRpbmdzLmNoZWNrYm94LnRpZV9zZWxlY3Rpb24sIGQgPSB0aGlzLl9kYXRhWyB0ID8gJ2NvcmUnIDogJ2NoZWNrYm94JyBdLnNlbGVjdGVkLCBtID0gdGhpcy5fbW9kZWwuZGF0YTtcblx0XHRcdGlmKCFvYmogfHwgb2JqLnN0YXRlWyB0ID8gJ3NlbGVjdGVkJyA6ICdjaGVja2VkJyBdID09PSB0cnVlIHx8IHMuaW5kZXhPZigndW5kZXRlcm1pbmVkJykgPT09IC0xIHx8IChzLmluZGV4T2YoJ2Rvd24nKSA9PT0gLTEgJiYgcy5pbmRleE9mKCd1cCcpID09PSAtMSkpIHtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXHRcdFx0aWYoIW9iai5zdGF0ZS5sb2FkZWQgJiYgb2JqLm9yaWdpbmFsLnN0YXRlLnVuZGV0ZXJtaW5lZCA9PT0gdHJ1ZSkge1xuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblx0XHRcdGZvcihpID0gMCwgaiA9IG9iai5jaGlsZHJlbl9kLmxlbmd0aDsgaSA8IGo7IGkrKykge1xuXHRcdFx0XHRpZigkLmluQXJyYXkob2JqLmNoaWxkcmVuX2RbaV0sIGQpICE9PSAtMSB8fCAoIW1bb2JqLmNoaWxkcmVuX2RbaV1dLnN0YXRlLmxvYWRlZCAmJiBtW29iai5jaGlsZHJlbl9kW2ldXS5vcmlnaW5hbC5zdGF0ZS51bmRldGVybWluZWQpKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9O1xuXHRcdC8qKlxuXHRcdCAqIGRpc2FibGUgYSBub2RlJ3MgY2hlY2tib3hcblx0XHQgKiBAbmFtZSBkaXNhYmxlX2NoZWNrYm94KG9iailcblx0XHQgKiBAcGFyYW0ge21peGVkfSBvYmogYW4gYXJyYXkgY2FuIGJlIHVzZWQgdG9vXG5cdFx0ICogQHRyaWdnZXIgZGlzYWJsZV9jaGVja2JveC5qc3RyZWVcblx0XHQgKiBAcGx1Z2luIGNoZWNrYm94XG5cdFx0ICovXG5cdFx0dGhpcy5kaXNhYmxlX2NoZWNrYm94ID0gZnVuY3Rpb24gKG9iaikge1xuXHRcdFx0dmFyIHQxLCB0MiwgZG9tO1xuXHRcdFx0aWYoJC5pc0FycmF5KG9iaikpIHtcblx0XHRcdFx0b2JqID0gb2JqLnNsaWNlKCk7XG5cdFx0XHRcdGZvcih0MSA9IDAsIHQyID0gb2JqLmxlbmd0aDsgdDEgPCB0MjsgdDErKykge1xuXHRcdFx0XHRcdHRoaXMuZGlzYWJsZV9jaGVja2JveChvYmpbdDFdKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblx0XHRcdG9iaiA9IHRoaXMuZ2V0X25vZGUob2JqKTtcblx0XHRcdGlmKCFvYmogfHwgb2JqLmlkID09PSAkLmpzdHJlZS5yb290KSB7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblx0XHRcdGRvbSA9IHRoaXMuZ2V0X25vZGUob2JqLCB0cnVlKTtcblx0XHRcdGlmKCFvYmouc3RhdGUuY2hlY2tib3hfZGlzYWJsZWQpIHtcblx0XHRcdFx0b2JqLnN0YXRlLmNoZWNrYm94X2Rpc2FibGVkID0gdHJ1ZTtcblx0XHRcdFx0aWYoZG9tICYmIGRvbS5sZW5ndGgpIHtcblx0XHRcdFx0XHRkb20uY2hpbGRyZW4oJy5qc3RyZWUtYW5jaG9yJykuY2hpbGRyZW4oJy5qc3RyZWUtY2hlY2tib3gnKS5hZGRDbGFzcygnanN0cmVlLWNoZWNrYm94LWRpc2FibGVkJyk7XG5cdFx0XHRcdH1cblx0XHRcdFx0LyoqXG5cdFx0XHRcdCAqIHRyaWdnZXJlZCB3aGVuIGFuIG5vZGUncyBjaGVja2JveCBpcyBkaXNhYmxlZFxuXHRcdFx0XHQgKiBAZXZlbnRcblx0XHRcdFx0ICogQG5hbWUgZGlzYWJsZV9jaGVja2JveC5qc3RyZWVcblx0XHRcdFx0ICogQHBhcmFtIHtPYmplY3R9IG5vZGVcblx0XHRcdFx0ICogQHBsdWdpbiBjaGVja2JveFxuXHRcdFx0XHQgKi9cblx0XHRcdFx0dGhpcy50cmlnZ2VyKCdkaXNhYmxlX2NoZWNrYm94JywgeyAnbm9kZScgOiBvYmogfSk7XG5cdFx0XHR9XG5cdFx0fTtcblx0XHQvKipcblx0XHQgKiBlbmFibGUgYSBub2RlJ3MgY2hlY2tib3hcblx0XHQgKiBAbmFtZSBkaXNhYmxlX2NoZWNrYm94KG9iailcblx0XHQgKiBAcGFyYW0ge21peGVkfSBvYmogYW4gYXJyYXkgY2FuIGJlIHVzZWQgdG9vXG5cdFx0ICogQHRyaWdnZXIgZW5hYmxlX2NoZWNrYm94LmpzdHJlZVxuXHRcdCAqIEBwbHVnaW4gY2hlY2tib3hcblx0XHQgKi9cblx0XHR0aGlzLmVuYWJsZV9jaGVja2JveCA9IGZ1bmN0aW9uIChvYmopIHtcblx0XHRcdHZhciB0MSwgdDIsIGRvbTtcblx0XHRcdGlmKCQuaXNBcnJheShvYmopKSB7XG5cdFx0XHRcdG9iaiA9IG9iai5zbGljZSgpO1xuXHRcdFx0XHRmb3IodDEgPSAwLCB0MiA9IG9iai5sZW5ndGg7IHQxIDwgdDI7IHQxKyspIHtcblx0XHRcdFx0XHR0aGlzLmVuYWJsZV9jaGVja2JveChvYmpbdDFdKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblx0XHRcdG9iaiA9IHRoaXMuZ2V0X25vZGUob2JqKTtcblx0XHRcdGlmKCFvYmogfHwgb2JqLmlkID09PSAkLmpzdHJlZS5yb290KSB7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblx0XHRcdGRvbSA9IHRoaXMuZ2V0X25vZGUob2JqLCB0cnVlKTtcblx0XHRcdGlmKG9iai5zdGF0ZS5jaGVja2JveF9kaXNhYmxlZCkge1xuXHRcdFx0XHRvYmouc3RhdGUuY2hlY2tib3hfZGlzYWJsZWQgPSBmYWxzZTtcblx0XHRcdFx0aWYoZG9tICYmIGRvbS5sZW5ndGgpIHtcblx0XHRcdFx0XHRkb20uY2hpbGRyZW4oJy5qc3RyZWUtYW5jaG9yJykuY2hpbGRyZW4oJy5qc3RyZWUtY2hlY2tib3gnKS5yZW1vdmVDbGFzcygnanN0cmVlLWNoZWNrYm94LWRpc2FibGVkJyk7XG5cdFx0XHRcdH1cblx0XHRcdFx0LyoqXG5cdFx0XHRcdCAqIHRyaWdnZXJlZCB3aGVuIGFuIG5vZGUncyBjaGVja2JveCBpcyBlbmFibGVkXG5cdFx0XHRcdCAqIEBldmVudFxuXHRcdFx0XHQgKiBAbmFtZSBlbmFibGVfY2hlY2tib3guanN0cmVlXG5cdFx0XHRcdCAqIEBwYXJhbSB7T2JqZWN0fSBub2RlXG5cdFx0XHRcdCAqIEBwbHVnaW4gY2hlY2tib3hcblx0XHRcdFx0ICovXG5cdFx0XHRcdHRoaXMudHJpZ2dlcignZW5hYmxlX2NoZWNrYm94JywgeyAnbm9kZScgOiBvYmogfSk7XG5cdFx0XHR9XG5cdFx0fTtcblxuXHRcdHRoaXMuYWN0aXZhdGVfbm9kZSA9IGZ1bmN0aW9uIChvYmosIGUpIHtcblx0XHRcdGlmKCQoZS50YXJnZXQpLmhhc0NsYXNzKCdqc3RyZWUtY2hlY2tib3gtZGlzYWJsZWQnKSkge1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cdFx0XHRpZih0aGlzLnNldHRpbmdzLmNoZWNrYm94LnRpZV9zZWxlY3Rpb24gJiYgKHRoaXMuc2V0dGluZ3MuY2hlY2tib3gud2hvbGVfbm9kZSB8fCAkKGUudGFyZ2V0KS5oYXNDbGFzcygnanN0cmVlLWNoZWNrYm94JykpKSB7XG5cdFx0XHRcdGUuY3RybEtleSA9IHRydWU7XG5cdFx0XHR9XG5cdFx0XHRpZih0aGlzLnNldHRpbmdzLmNoZWNrYm94LnRpZV9zZWxlY3Rpb24gfHwgKCF0aGlzLnNldHRpbmdzLmNoZWNrYm94Lndob2xlX25vZGUgJiYgISQoZS50YXJnZXQpLmhhc0NsYXNzKCdqc3RyZWUtY2hlY2tib3gnKSkpIHtcblx0XHRcdFx0cmV0dXJuIHBhcmVudC5hY3RpdmF0ZV9ub2RlLmNhbGwodGhpcywgb2JqLCBlKTtcblx0XHRcdH1cblx0XHRcdGlmKHRoaXMuaXNfZGlzYWJsZWQob2JqKSkge1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cdFx0XHRpZih0aGlzLmlzX2NoZWNrZWQob2JqKSkge1xuXHRcdFx0XHR0aGlzLnVuY2hlY2tfbm9kZShvYmosIGUpO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSB7XG5cdFx0XHRcdHRoaXMuY2hlY2tfbm9kZShvYmosIGUpO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy50cmlnZ2VyKCdhY3RpdmF0ZV9ub2RlJywgeyAnbm9kZScgOiB0aGlzLmdldF9ub2RlKG9iaikgfSk7XG5cdFx0fTtcblxuXHRcdC8qKlxuXHRcdCAqIGNoZWNrIGEgbm9kZSAob25seSBpZiB0aWVfc2VsZWN0aW9uIGluIGNoZWNrYm94IHNldHRpbmdzIGlzIGZhbHNlLCBvdGhlcndpc2Ugc2VsZWN0X25vZGUgd2lsbCBiZSBjYWxsZWQgaW50ZXJuYWxseSlcblx0XHQgKiBAbmFtZSBjaGVja19ub2RlKG9iailcblx0XHQgKiBAcGFyYW0ge21peGVkfSBvYmogYW4gYXJyYXkgY2FuIGJlIHVzZWQgdG8gY2hlY2sgbXVsdGlwbGUgbm9kZXNcblx0XHQgKiBAdHJpZ2dlciBjaGVja19ub2RlLmpzdHJlZVxuXHRcdCAqIEBwbHVnaW4gY2hlY2tib3hcblx0XHQgKi9cblx0XHR0aGlzLmNoZWNrX25vZGUgPSBmdW5jdGlvbiAob2JqLCBlKSB7XG5cdFx0XHRpZih0aGlzLnNldHRpbmdzLmNoZWNrYm94LnRpZV9zZWxlY3Rpb24pIHsgcmV0dXJuIHRoaXMuc2VsZWN0X25vZGUob2JqLCBmYWxzZSwgdHJ1ZSwgZSk7IH1cblx0XHRcdHZhciBkb20sIHQxLCB0MiwgdGg7XG5cdFx0XHRpZigkLmlzQXJyYXkob2JqKSkge1xuXHRcdFx0XHRvYmogPSBvYmouc2xpY2UoKTtcblx0XHRcdFx0Zm9yKHQxID0gMCwgdDIgPSBvYmoubGVuZ3RoOyB0MSA8IHQyOyB0MSsrKSB7XG5cdFx0XHRcdFx0dGhpcy5jaGVja19ub2RlKG9ialt0MV0sIGUpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fVxuXHRcdFx0b2JqID0gdGhpcy5nZXRfbm9kZShvYmopO1xuXHRcdFx0aWYoIW9iaiB8fCBvYmouaWQgPT09ICQuanN0cmVlLnJvb3QpIHtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXHRcdFx0ZG9tID0gdGhpcy5nZXRfbm9kZShvYmosIHRydWUpO1xuXHRcdFx0aWYoIW9iai5zdGF0ZS5jaGVja2VkKSB7XG5cdFx0XHRcdG9iai5zdGF0ZS5jaGVja2VkID0gdHJ1ZTtcblx0XHRcdFx0dGhpcy5fZGF0YS5jaGVja2JveC5zZWxlY3RlZC5wdXNoKG9iai5pZCk7XG5cdFx0XHRcdGlmKGRvbSAmJiBkb20ubGVuZ3RoKSB7XG5cdFx0XHRcdFx0ZG9tLmNoaWxkcmVuKCcuanN0cmVlLWFuY2hvcicpLmFkZENsYXNzKCdqc3RyZWUtY2hlY2tlZCcpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdC8qKlxuXHRcdFx0XHQgKiB0cmlnZ2VyZWQgd2hlbiBhbiBub2RlIGlzIGNoZWNrZWQgKG9ubHkgaWYgdGllX3NlbGVjdGlvbiBpbiBjaGVja2JveCBzZXR0aW5ncyBpcyBmYWxzZSlcblx0XHRcdFx0ICogQGV2ZW50XG5cdFx0XHRcdCAqIEBuYW1lIGNoZWNrX25vZGUuanN0cmVlXG5cdFx0XHRcdCAqIEBwYXJhbSB7T2JqZWN0fSBub2RlXG5cdFx0XHRcdCAqIEBwYXJhbSB7QXJyYXl9IHNlbGVjdGVkIHRoZSBjdXJyZW50IHNlbGVjdGlvblxuXHRcdFx0XHQgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgdGhlIGV2ZW50IChpZiBhbnkpIHRoYXQgdHJpZ2dlcmVkIHRoaXMgY2hlY2tfbm9kZVxuXHRcdFx0XHQgKiBAcGx1Z2luIGNoZWNrYm94XG5cdFx0XHRcdCAqL1xuXHRcdFx0XHR0aGlzLnRyaWdnZXIoJ2NoZWNrX25vZGUnLCB7ICdub2RlJyA6IG9iaiwgJ3NlbGVjdGVkJyA6IHRoaXMuX2RhdGEuY2hlY2tib3guc2VsZWN0ZWQsICdldmVudCcgOiBlIH0pO1xuXHRcdFx0fVxuXHRcdH07XG5cdFx0LyoqXG5cdFx0ICogdW5jaGVjayBhIG5vZGUgKG9ubHkgaWYgdGllX3NlbGVjdGlvbiBpbiBjaGVja2JveCBzZXR0aW5ncyBpcyBmYWxzZSwgb3RoZXJ3aXNlIGRlc2VsZWN0X25vZGUgd2lsbCBiZSBjYWxsZWQgaW50ZXJuYWxseSlcblx0XHQgKiBAbmFtZSB1bmNoZWNrX25vZGUob2JqKVxuXHRcdCAqIEBwYXJhbSB7bWl4ZWR9IG9iaiBhbiBhcnJheSBjYW4gYmUgdXNlZCB0byB1bmNoZWNrIG11bHRpcGxlIG5vZGVzXG5cdFx0ICogQHRyaWdnZXIgdW5jaGVja19ub2RlLmpzdHJlZVxuXHRcdCAqIEBwbHVnaW4gY2hlY2tib3hcblx0XHQgKi9cblx0XHR0aGlzLnVuY2hlY2tfbm9kZSA9IGZ1bmN0aW9uIChvYmosIGUpIHtcblx0XHRcdGlmKHRoaXMuc2V0dGluZ3MuY2hlY2tib3gudGllX3NlbGVjdGlvbikgeyByZXR1cm4gdGhpcy5kZXNlbGVjdF9ub2RlKG9iaiwgZmFsc2UsIGUpOyB9XG5cdFx0XHR2YXIgdDEsIHQyLCBkb207XG5cdFx0XHRpZigkLmlzQXJyYXkob2JqKSkge1xuXHRcdFx0XHRvYmogPSBvYmouc2xpY2UoKTtcblx0XHRcdFx0Zm9yKHQxID0gMCwgdDIgPSBvYmoubGVuZ3RoOyB0MSA8IHQyOyB0MSsrKSB7XG5cdFx0XHRcdFx0dGhpcy51bmNoZWNrX25vZGUob2JqW3QxXSwgZSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9XG5cdFx0XHRvYmogPSB0aGlzLmdldF9ub2RlKG9iaik7XG5cdFx0XHRpZighb2JqIHx8IG9iai5pZCA9PT0gJC5qc3RyZWUucm9vdCkge1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cdFx0XHRkb20gPSB0aGlzLmdldF9ub2RlKG9iaiwgdHJ1ZSk7XG5cdFx0XHRpZihvYmouc3RhdGUuY2hlY2tlZCkge1xuXHRcdFx0XHRvYmouc3RhdGUuY2hlY2tlZCA9IGZhbHNlO1xuXHRcdFx0XHR0aGlzLl9kYXRhLmNoZWNrYm94LnNlbGVjdGVkID0gJC52YWthdGEuYXJyYXlfcmVtb3ZlX2l0ZW0odGhpcy5fZGF0YS5jaGVja2JveC5zZWxlY3RlZCwgb2JqLmlkKTtcblx0XHRcdFx0aWYoZG9tLmxlbmd0aCkge1xuXHRcdFx0XHRcdGRvbS5jaGlsZHJlbignLmpzdHJlZS1hbmNob3InKS5yZW1vdmVDbGFzcygnanN0cmVlLWNoZWNrZWQnKTtcblx0XHRcdFx0fVxuXHRcdFx0XHQvKipcblx0XHRcdFx0ICogdHJpZ2dlcmVkIHdoZW4gYW4gbm9kZSBpcyB1bmNoZWNrZWQgKG9ubHkgaWYgdGllX3NlbGVjdGlvbiBpbiBjaGVja2JveCBzZXR0aW5ncyBpcyBmYWxzZSlcblx0XHRcdFx0ICogQGV2ZW50XG5cdFx0XHRcdCAqIEBuYW1lIHVuY2hlY2tfbm9kZS5qc3RyZWVcblx0XHRcdFx0ICogQHBhcmFtIHtPYmplY3R9IG5vZGVcblx0XHRcdFx0ICogQHBhcmFtIHtBcnJheX0gc2VsZWN0ZWQgdGhlIGN1cnJlbnQgc2VsZWN0aW9uXG5cdFx0XHRcdCAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCB0aGUgZXZlbnQgKGlmIGFueSkgdGhhdCB0cmlnZ2VyZWQgdGhpcyB1bmNoZWNrX25vZGVcblx0XHRcdFx0ICogQHBsdWdpbiBjaGVja2JveFxuXHRcdFx0XHQgKi9cblx0XHRcdFx0dGhpcy50cmlnZ2VyKCd1bmNoZWNrX25vZGUnLCB7ICdub2RlJyA6IG9iaiwgJ3NlbGVjdGVkJyA6IHRoaXMuX2RhdGEuY2hlY2tib3guc2VsZWN0ZWQsICdldmVudCcgOiBlIH0pO1xuXHRcdFx0fVxuXHRcdH07XG5cdFx0LyoqXG5cdFx0ICogY2hlY2tzIGFsbCBub2RlcyBpbiB0aGUgdHJlZSAob25seSBpZiB0aWVfc2VsZWN0aW9uIGluIGNoZWNrYm94IHNldHRpbmdzIGlzIGZhbHNlLCBvdGhlcndpc2Ugc2VsZWN0X2FsbCB3aWxsIGJlIGNhbGxlZCBpbnRlcm5hbGx5KVxuXHRcdCAqIEBuYW1lIGNoZWNrX2FsbCgpXG5cdFx0ICogQHRyaWdnZXIgY2hlY2tfYWxsLmpzdHJlZSwgY2hhbmdlZC5qc3RyZWVcblx0XHQgKiBAcGx1Z2luIGNoZWNrYm94XG5cdFx0ICovXG5cdFx0dGhpcy5jaGVja19hbGwgPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHRpZih0aGlzLnNldHRpbmdzLmNoZWNrYm94LnRpZV9zZWxlY3Rpb24pIHsgcmV0dXJuIHRoaXMuc2VsZWN0X2FsbCgpOyB9XG5cdFx0XHR2YXIgdG1wID0gdGhpcy5fZGF0YS5jaGVja2JveC5zZWxlY3RlZC5jb25jYXQoW10pLCBpLCBqO1xuXHRcdFx0dGhpcy5fZGF0YS5jaGVja2JveC5zZWxlY3RlZCA9IHRoaXMuX21vZGVsLmRhdGFbJC5qc3RyZWUucm9vdF0uY2hpbGRyZW5fZC5jb25jYXQoKTtcblx0XHRcdGZvcihpID0gMCwgaiA9IHRoaXMuX2RhdGEuY2hlY2tib3guc2VsZWN0ZWQubGVuZ3RoOyBpIDwgajsgaSsrKSB7XG5cdFx0XHRcdGlmKHRoaXMuX21vZGVsLmRhdGFbdGhpcy5fZGF0YS5jaGVja2JveC5zZWxlY3RlZFtpXV0pIHtcblx0XHRcdFx0XHR0aGlzLl9tb2RlbC5kYXRhW3RoaXMuX2RhdGEuY2hlY2tib3guc2VsZWN0ZWRbaV1dLnN0YXRlLmNoZWNrZWQgPSB0cnVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHR0aGlzLnJlZHJhdyh0cnVlKTtcblx0XHRcdC8qKlxuXHRcdFx0ICogdHJpZ2dlcmVkIHdoZW4gYWxsIG5vZGVzIGFyZSBjaGVja2VkIChvbmx5IGlmIHRpZV9zZWxlY3Rpb24gaW4gY2hlY2tib3ggc2V0dGluZ3MgaXMgZmFsc2UpXG5cdFx0XHQgKiBAZXZlbnRcblx0XHRcdCAqIEBuYW1lIGNoZWNrX2FsbC5qc3RyZWVcblx0XHRcdCAqIEBwYXJhbSB7QXJyYXl9IHNlbGVjdGVkIHRoZSBjdXJyZW50IHNlbGVjdGlvblxuXHRcdFx0ICogQHBsdWdpbiBjaGVja2JveFxuXHRcdFx0ICovXG5cdFx0XHR0aGlzLnRyaWdnZXIoJ2NoZWNrX2FsbCcsIHsgJ3NlbGVjdGVkJyA6IHRoaXMuX2RhdGEuY2hlY2tib3guc2VsZWN0ZWQgfSk7XG5cdFx0fTtcblx0XHQvKipcblx0XHQgKiB1bmNoZWNrIGFsbCBjaGVja2VkIG5vZGVzIChvbmx5IGlmIHRpZV9zZWxlY3Rpb24gaW4gY2hlY2tib3ggc2V0dGluZ3MgaXMgZmFsc2UsIG90aGVyd2lzZSBkZXNlbGVjdF9hbGwgd2lsbCBiZSBjYWxsZWQgaW50ZXJuYWxseSlcblx0XHQgKiBAbmFtZSB1bmNoZWNrX2FsbCgpXG5cdFx0ICogQHRyaWdnZXIgdW5jaGVja19hbGwuanN0cmVlXG5cdFx0ICogQHBsdWdpbiBjaGVja2JveFxuXHRcdCAqL1xuXHRcdHRoaXMudW5jaGVja19hbGwgPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHRpZih0aGlzLnNldHRpbmdzLmNoZWNrYm94LnRpZV9zZWxlY3Rpb24pIHsgcmV0dXJuIHRoaXMuZGVzZWxlY3RfYWxsKCk7IH1cblx0XHRcdHZhciB0bXAgPSB0aGlzLl9kYXRhLmNoZWNrYm94LnNlbGVjdGVkLmNvbmNhdChbXSksIGksIGo7XG5cdFx0XHRmb3IoaSA9IDAsIGogPSB0aGlzLl9kYXRhLmNoZWNrYm94LnNlbGVjdGVkLmxlbmd0aDsgaSA8IGo7IGkrKykge1xuXHRcdFx0XHRpZih0aGlzLl9tb2RlbC5kYXRhW3RoaXMuX2RhdGEuY2hlY2tib3guc2VsZWN0ZWRbaV1dKSB7XG5cdFx0XHRcdFx0dGhpcy5fbW9kZWwuZGF0YVt0aGlzLl9kYXRhLmNoZWNrYm94LnNlbGVjdGVkW2ldXS5zdGF0ZS5jaGVja2VkID0gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHRoaXMuX2RhdGEuY2hlY2tib3guc2VsZWN0ZWQgPSBbXTtcblx0XHRcdHRoaXMuZWxlbWVudC5maW5kKCcuanN0cmVlLWNoZWNrZWQnKS5yZW1vdmVDbGFzcygnanN0cmVlLWNoZWNrZWQnKTtcblx0XHRcdC8qKlxuXHRcdFx0ICogdHJpZ2dlcmVkIHdoZW4gYWxsIG5vZGVzIGFyZSB1bmNoZWNrZWQgKG9ubHkgaWYgdGllX3NlbGVjdGlvbiBpbiBjaGVja2JveCBzZXR0aW5ncyBpcyBmYWxzZSlcblx0XHRcdCAqIEBldmVudFxuXHRcdFx0ICogQG5hbWUgdW5jaGVja19hbGwuanN0cmVlXG5cdFx0XHQgKiBAcGFyYW0ge09iamVjdH0gbm9kZSB0aGUgcHJldmlvdXMgc2VsZWN0aW9uXG5cdFx0XHQgKiBAcGFyYW0ge0FycmF5fSBzZWxlY3RlZCB0aGUgY3VycmVudCBzZWxlY3Rpb25cblx0XHRcdCAqIEBwbHVnaW4gY2hlY2tib3hcblx0XHRcdCAqL1xuXHRcdFx0dGhpcy50cmlnZ2VyKCd1bmNoZWNrX2FsbCcsIHsgJ3NlbGVjdGVkJyA6IHRoaXMuX2RhdGEuY2hlY2tib3guc2VsZWN0ZWQsICdub2RlJyA6IHRtcCB9KTtcblx0XHR9O1xuXHRcdC8qKlxuXHRcdCAqIGNoZWNrcyBpZiBhIG5vZGUgaXMgY2hlY2tlZCAoaWYgdGllX3NlbGVjdGlvbiBpcyBvbiBpbiB0aGUgc2V0dGluZ3MgdGhpcyBmdW5jdGlvbiB3aWxsIHJldHVybiB0aGUgc2FtZSBhcyBpc19zZWxlY3RlZClcblx0XHQgKiBAbmFtZSBpc19jaGVja2VkKG9iailcblx0XHQgKiBAcGFyYW0gIHttaXhlZH0gIG9ialxuXHRcdCAqIEByZXR1cm4ge0Jvb2xlYW59XG5cdFx0ICogQHBsdWdpbiBjaGVja2JveFxuXHRcdCAqL1xuXHRcdHRoaXMuaXNfY2hlY2tlZCA9IGZ1bmN0aW9uIChvYmopIHtcblx0XHRcdGlmKHRoaXMuc2V0dGluZ3MuY2hlY2tib3gudGllX3NlbGVjdGlvbikgeyByZXR1cm4gdGhpcy5pc19zZWxlY3RlZChvYmopOyB9XG5cdFx0XHRvYmogPSB0aGlzLmdldF9ub2RlKG9iaik7XG5cdFx0XHRpZighb2JqIHx8IG9iai5pZCA9PT0gJC5qc3RyZWUucm9vdCkgeyByZXR1cm4gZmFsc2U7IH1cblx0XHRcdHJldHVybiBvYmouc3RhdGUuY2hlY2tlZDtcblx0XHR9O1xuXHRcdC8qKlxuXHRcdCAqIGdldCBhbiBhcnJheSBvZiBhbGwgY2hlY2tlZCBub2RlcyAoaWYgdGllX3NlbGVjdGlvbiBpcyBvbiBpbiB0aGUgc2V0dGluZ3MgdGhpcyBmdW5jdGlvbiB3aWxsIHJldHVybiB0aGUgc2FtZSBhcyBnZXRfc2VsZWN0ZWQpXG5cdFx0ICogQG5hbWUgZ2V0X2NoZWNrZWQoW2Z1bGxdKVxuXHRcdCAqIEBwYXJhbSAge21peGVkfSAgZnVsbCBpZiBzZXQgdG8gYHRydWVgIHRoZSByZXR1cm5lZCBhcnJheSB3aWxsIGNvbnNpc3Qgb2YgdGhlIGZ1bGwgbm9kZSBvYmplY3RzLCBvdGhlcndpc2UgLSBvbmx5IElEcyB3aWxsIGJlIHJldHVybmVkXG5cdFx0ICogQHJldHVybiB7QXJyYXl9XG5cdFx0ICogQHBsdWdpbiBjaGVja2JveFxuXHRcdCAqL1xuXHRcdHRoaXMuZ2V0X2NoZWNrZWQgPSBmdW5jdGlvbiAoZnVsbCkge1xuXHRcdFx0aWYodGhpcy5zZXR0aW5ncy5jaGVja2JveC50aWVfc2VsZWN0aW9uKSB7IHJldHVybiB0aGlzLmdldF9zZWxlY3RlZChmdWxsKTsgfVxuXHRcdFx0cmV0dXJuIGZ1bGwgPyAkLm1hcCh0aGlzLl9kYXRhLmNoZWNrYm94LnNlbGVjdGVkLCAkLnByb3h5KGZ1bmN0aW9uIChpKSB7IHJldHVybiB0aGlzLmdldF9ub2RlKGkpOyB9LCB0aGlzKSkgOiB0aGlzLl9kYXRhLmNoZWNrYm94LnNlbGVjdGVkO1xuXHRcdH07XG5cdFx0LyoqXG5cdFx0ICogZ2V0IGFuIGFycmF5IG9mIGFsbCB0b3AgbGV2ZWwgY2hlY2tlZCBub2RlcyAoaWdub3JpbmcgY2hpbGRyZW4gb2YgY2hlY2tlZCBub2RlcykgKGlmIHRpZV9zZWxlY3Rpb24gaXMgb24gaW4gdGhlIHNldHRpbmdzIHRoaXMgZnVuY3Rpb24gd2lsbCByZXR1cm4gdGhlIHNhbWUgYXMgZ2V0X3RvcF9zZWxlY3RlZClcblx0XHQgKiBAbmFtZSBnZXRfdG9wX2NoZWNrZWQoW2Z1bGxdKVxuXHRcdCAqIEBwYXJhbSAge21peGVkfSAgZnVsbCBpZiBzZXQgdG8gYHRydWVgIHRoZSByZXR1cm5lZCBhcnJheSB3aWxsIGNvbnNpc3Qgb2YgdGhlIGZ1bGwgbm9kZSBvYmplY3RzLCBvdGhlcndpc2UgLSBvbmx5IElEcyB3aWxsIGJlIHJldHVybmVkXG5cdFx0ICogQHJldHVybiB7QXJyYXl9XG5cdFx0ICogQHBsdWdpbiBjaGVja2JveFxuXHRcdCAqL1xuXHRcdHRoaXMuZ2V0X3RvcF9jaGVja2VkID0gZnVuY3Rpb24gKGZ1bGwpIHtcblx0XHRcdGlmKHRoaXMuc2V0dGluZ3MuY2hlY2tib3gudGllX3NlbGVjdGlvbikgeyByZXR1cm4gdGhpcy5nZXRfdG9wX3NlbGVjdGVkKGZ1bGwpOyB9XG5cdFx0XHR2YXIgdG1wID0gdGhpcy5nZXRfY2hlY2tlZCh0cnVlKSxcblx0XHRcdFx0b2JqID0ge30sIGksIGosIGssIGw7XG5cdFx0XHRmb3IoaSA9IDAsIGogPSB0bXAubGVuZ3RoOyBpIDwgajsgaSsrKSB7XG5cdFx0XHRcdG9ialt0bXBbaV0uaWRdID0gdG1wW2ldO1xuXHRcdFx0fVxuXHRcdFx0Zm9yKGkgPSAwLCBqID0gdG1wLmxlbmd0aDsgaSA8IGo7IGkrKykge1xuXHRcdFx0XHRmb3IoayA9IDAsIGwgPSB0bXBbaV0uY2hpbGRyZW5fZC5sZW5ndGg7IGsgPCBsOyBrKyspIHtcblx0XHRcdFx0XHRpZihvYmpbdG1wW2ldLmNoaWxkcmVuX2Rba11dKSB7XG5cdFx0XHRcdFx0XHRkZWxldGUgb2JqW3RtcFtpXS5jaGlsZHJlbl9kW2tdXTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHRtcCA9IFtdO1xuXHRcdFx0Zm9yKGkgaW4gb2JqKSB7XG5cdFx0XHRcdGlmKG9iai5oYXNPd25Qcm9wZXJ0eShpKSkge1xuXHRcdFx0XHRcdHRtcC5wdXNoKGkpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gZnVsbCA/ICQubWFwKHRtcCwgJC5wcm94eShmdW5jdGlvbiAoaSkgeyByZXR1cm4gdGhpcy5nZXRfbm9kZShpKTsgfSwgdGhpcykpIDogdG1wO1xuXHRcdH07XG5cdFx0LyoqXG5cdFx0ICogZ2V0IGFuIGFycmF5IG9mIGFsbCBib3R0b20gbGV2ZWwgY2hlY2tlZCBub2RlcyAoaWdub3Jpbmcgc2VsZWN0ZWQgcGFyZW50cykgKGlmIHRpZV9zZWxlY3Rpb24gaXMgb24gaW4gdGhlIHNldHRpbmdzIHRoaXMgZnVuY3Rpb24gd2lsbCByZXR1cm4gdGhlIHNhbWUgYXMgZ2V0X2JvdHRvbV9zZWxlY3RlZClcblx0XHQgKiBAbmFtZSBnZXRfYm90dG9tX2NoZWNrZWQoW2Z1bGxdKVxuXHRcdCAqIEBwYXJhbSAge21peGVkfSAgZnVsbCBpZiBzZXQgdG8gYHRydWVgIHRoZSByZXR1cm5lZCBhcnJheSB3aWxsIGNvbnNpc3Qgb2YgdGhlIGZ1bGwgbm9kZSBvYmplY3RzLCBvdGhlcndpc2UgLSBvbmx5IElEcyB3aWxsIGJlIHJldHVybmVkXG5cdFx0ICogQHJldHVybiB7QXJyYXl9XG5cdFx0ICogQHBsdWdpbiBjaGVja2JveFxuXHRcdCAqL1xuXHRcdHRoaXMuZ2V0X2JvdHRvbV9jaGVja2VkID0gZnVuY3Rpb24gKGZ1bGwpIHtcblx0XHRcdGlmKHRoaXMuc2V0dGluZ3MuY2hlY2tib3gudGllX3NlbGVjdGlvbikgeyByZXR1cm4gdGhpcy5nZXRfYm90dG9tX3NlbGVjdGVkKGZ1bGwpOyB9XG5cdFx0XHR2YXIgdG1wID0gdGhpcy5nZXRfY2hlY2tlZCh0cnVlKSxcblx0XHRcdFx0b2JqID0gW10sIGksIGo7XG5cdFx0XHRmb3IoaSA9IDAsIGogPSB0bXAubGVuZ3RoOyBpIDwgajsgaSsrKSB7XG5cdFx0XHRcdGlmKCF0bXBbaV0uY2hpbGRyZW4ubGVuZ3RoKSB7XG5cdFx0XHRcdFx0b2JqLnB1c2godG1wW2ldLmlkKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGZ1bGwgPyAkLm1hcChvYmosICQucHJveHkoZnVuY3Rpb24gKGkpIHsgcmV0dXJuIHRoaXMuZ2V0X25vZGUoaSk7IH0sIHRoaXMpKSA6IG9iajtcblx0XHR9O1xuXHRcdHRoaXMubG9hZF9ub2RlID0gZnVuY3Rpb24gKG9iaiwgY2FsbGJhY2spIHtcblx0XHRcdHZhciBrLCBsLCBpLCBqLCBjLCB0bXA7XG5cdFx0XHRpZighJC5pc0FycmF5KG9iaikgJiYgIXRoaXMuc2V0dGluZ3MuY2hlY2tib3gudGllX3NlbGVjdGlvbikge1xuXHRcdFx0XHR0bXAgPSB0aGlzLmdldF9ub2RlKG9iaik7XG5cdFx0XHRcdGlmKHRtcCAmJiB0bXAuc3RhdGUubG9hZGVkKSB7XG5cdFx0XHRcdFx0Zm9yKGsgPSAwLCBsID0gdG1wLmNoaWxkcmVuX2QubGVuZ3RoOyBrIDwgbDsgaysrKSB7XG5cdFx0XHRcdFx0XHRpZih0aGlzLl9tb2RlbC5kYXRhW3RtcC5jaGlsZHJlbl9kW2tdXS5zdGF0ZS5jaGVja2VkKSB7XG5cdFx0XHRcdFx0XHRcdGMgPSB0cnVlO1xuXHRcdFx0XHRcdFx0XHR0aGlzLl9kYXRhLmNoZWNrYm94LnNlbGVjdGVkID0gJC52YWthdGEuYXJyYXlfcmVtb3ZlX2l0ZW0odGhpcy5fZGF0YS5jaGVja2JveC5zZWxlY3RlZCwgdG1wLmNoaWxkcmVuX2Rba10pO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHBhcmVudC5sb2FkX25vZGUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0XHR9O1xuXHRcdHRoaXMuZ2V0X3N0YXRlID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0dmFyIHN0YXRlID0gcGFyZW50LmdldF9zdGF0ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHRcdFx0aWYodGhpcy5zZXR0aW5ncy5jaGVja2JveC50aWVfc2VsZWN0aW9uKSB7IHJldHVybiBzdGF0ZTsgfVxuXHRcdFx0c3RhdGUuY2hlY2tib3ggPSB0aGlzLl9kYXRhLmNoZWNrYm94LnNlbGVjdGVkLnNsaWNlKCk7XG5cdFx0XHRyZXR1cm4gc3RhdGU7XG5cdFx0fTtcblx0XHR0aGlzLnNldF9zdGF0ZSA9IGZ1bmN0aW9uIChzdGF0ZSwgY2FsbGJhY2spIHtcblx0XHRcdHZhciByZXMgPSBwYXJlbnQuc2V0X3N0YXRlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdFx0XHRpZihyZXMgJiYgc3RhdGUuY2hlY2tib3gpIHtcblx0XHRcdFx0aWYoIXRoaXMuc2V0dGluZ3MuY2hlY2tib3gudGllX3NlbGVjdGlvbikge1xuXHRcdFx0XHRcdHRoaXMudW5jaGVja19hbGwoKTtcblx0XHRcdFx0XHR2YXIgX3RoaXMgPSB0aGlzO1xuXHRcdFx0XHRcdCQuZWFjaChzdGF0ZS5jaGVja2JveCwgZnVuY3Rpb24gKGksIHYpIHtcblx0XHRcdFx0XHRcdF90aGlzLmNoZWNrX25vZGUodik7XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZGVsZXRlIHN0YXRlLmNoZWNrYm94O1xuXHRcdFx0XHR0aGlzLnNldF9zdGF0ZShzdGF0ZSwgY2FsbGJhY2spO1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcmVzO1xuXHRcdH07XG5cdFx0dGhpcy5yZWZyZXNoID0gZnVuY3Rpb24gKHNraXBfbG9hZGluZywgZm9yZ2V0X3N0YXRlKSB7XG5cdFx0XHRpZighdGhpcy5zZXR0aW5ncy5jaGVja2JveC50aWVfc2VsZWN0aW9uKSB7XG5cdFx0XHRcdHRoaXMuX2RhdGEuY2hlY2tib3guc2VsZWN0ZWQgPSBbXTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBwYXJlbnQucmVmcmVzaC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHRcdH07XG5cdH07XG5cblx0Ly8gaW5jbHVkZSB0aGUgY2hlY2tib3ggcGx1Z2luIGJ5IGRlZmF1bHRcblx0Ly8gJC5qc3RyZWUuZGVmYXVsdHMucGx1Z2lucy5wdXNoKFwiY2hlY2tib3hcIik7XG5cbi8qKlxuICogIyMjIENvbmRpdGlvbmFsc2VsZWN0IHBsdWdpblxuICpcbiAqIFRoaXMgcGx1Z2luIGFsbG93cyBkZWZpbmluZyBhIGNhbGxiYWNrIHRvIGFsbG93IG9yIGRlbnkgbm9kZSBzZWxlY3Rpb24gYnkgdXNlciBpbnB1dCAoYWN0aXZhdGUgbm9kZSBtZXRob2QpLlxuICovXG5cblx0LyoqXG5cdCAqIGEgY2FsbGJhY2sgKGZ1bmN0aW9uKSB3aGljaCBpcyBpbnZva2VkIGluIHRoZSBpbnN0YW5jZSdzIHNjb3BlIGFuZCByZWNlaXZlcyB0d28gYXJndW1lbnRzIC0gdGhlIG5vZGUgYW5kIHRoZSBldmVudCB0aGF0IHRyaWdnZXJlZCB0aGUgYGFjdGl2YXRlX25vZGVgIGNhbGwuIFJldHVybmluZyBmYWxzZSBwcmV2ZW50cyB3b3JraW5nIHdpdGggdGhlIG5vZGUsIHJldHVybmluZyB0cnVlIGFsbG93cyBpbnZva2luZyBhY3RpdmF0ZV9ub2RlLiBEZWZhdWx0cyB0byByZXR1cm5pbmcgYHRydWVgLlxuXHQgKiBAbmFtZSAkLmpzdHJlZS5kZWZhdWx0cy5jaGVja2JveC52aXNpYmxlXG5cdCAqIEBwbHVnaW4gY2hlY2tib3hcblx0ICovXG5cdCQuanN0cmVlLmRlZmF1bHRzLmNvbmRpdGlvbmFsc2VsZWN0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdHJ1ZTsgfTtcblx0JC5qc3RyZWUucGx1Z2lucy5jb25kaXRpb25hbHNlbGVjdCA9IGZ1bmN0aW9uIChvcHRpb25zLCBwYXJlbnQpIHtcblx0XHQvLyBvd24gZnVuY3Rpb25cblx0XHR0aGlzLmFjdGl2YXRlX25vZGUgPSBmdW5jdGlvbiAob2JqLCBlKSB7XG5cdFx0XHRpZih0aGlzLnNldHRpbmdzLmNvbmRpdGlvbmFsc2VsZWN0LmNhbGwodGhpcywgdGhpcy5nZXRfbm9kZShvYmopLCBlKSkge1xuXHRcdFx0XHRwYXJlbnQuYWN0aXZhdGVfbm9kZS5jYWxsKHRoaXMsIG9iaiwgZSk7XG5cdFx0XHR9XG5cdFx0fTtcblx0fTtcblxuXG4vKipcbiAqICMjIyBDb250ZXh0bWVudSBwbHVnaW5cbiAqXG4gKiBTaG93cyBhIGNvbnRleHQgbWVudSB3aGVuIGEgbm9kZSBpcyByaWdodC1jbGlja2VkLlxuICovXG5cblx0LyoqXG5cdCAqIHN0b3JlcyBhbGwgZGVmYXVsdHMgZm9yIHRoZSBjb250ZXh0bWVudSBwbHVnaW5cblx0ICogQG5hbWUgJC5qc3RyZWUuZGVmYXVsdHMuY29udGV4dG1lbnVcblx0ICogQHBsdWdpbiBjb250ZXh0bWVudVxuXHQgKi9cblx0JC5qc3RyZWUuZGVmYXVsdHMuY29udGV4dG1lbnUgPSB7XG5cdFx0LyoqXG5cdFx0ICogYSBib29sZWFuIGluZGljYXRpbmcgaWYgdGhlIG5vZGUgc2hvdWxkIGJlIHNlbGVjdGVkIHdoZW4gdGhlIGNvbnRleHQgbWVudSBpcyBpbnZva2VkIG9uIGl0LiBEZWZhdWx0cyB0byBgdHJ1ZWAuXG5cdFx0ICogQG5hbWUgJC5qc3RyZWUuZGVmYXVsdHMuY29udGV4dG1lbnUuc2VsZWN0X25vZGVcblx0XHQgKiBAcGx1Z2luIGNvbnRleHRtZW51XG5cdFx0ICovXG5cdFx0c2VsZWN0X25vZGUgOiB0cnVlLFxuXHRcdC8qKlxuXHRcdCAqIGEgYm9vbGVhbiBpbmRpY2F0aW5nIGlmIHRoZSBtZW51IHNob3VsZCBiZSBzaG93biBhbGlnbmVkIHdpdGggdGhlIG5vZGUuIERlZmF1bHRzIHRvIGB0cnVlYCwgb3RoZXJ3aXNlIHRoZSBtb3VzZSBjb29yZGluYXRlcyBhcmUgdXNlZC5cblx0XHQgKiBAbmFtZSAkLmpzdHJlZS5kZWZhdWx0cy5jb250ZXh0bWVudS5zaG93X2F0X25vZGVcblx0XHQgKiBAcGx1Z2luIGNvbnRleHRtZW51XG5cdFx0ICovXG5cdFx0c2hvd19hdF9ub2RlIDogdHJ1ZSxcblx0XHQvKipcblx0XHQgKiBhbiBvYmplY3Qgb2YgYWN0aW9ucywgb3IgYSBmdW5jdGlvbiB0aGF0IGFjY2VwdHMgYSBub2RlIGFuZCBhIGNhbGxiYWNrIGZ1bmN0aW9uIGFuZCBjYWxscyB0aGUgY2FsbGJhY2sgZnVuY3Rpb24gd2l0aCBhbiBvYmplY3Qgb2YgYWN0aW9ucyBhdmFpbGFibGUgZm9yIHRoYXQgbm9kZSAoeW91IGNhbiBhbHNvIHJldHVybiB0aGUgaXRlbXMgdG9vKS5cblx0XHQgKlxuXHRcdCAqIEVhY2ggYWN0aW9uIGNvbnNpc3RzIG9mIGEga2V5IChhIHVuaXF1ZSBuYW1lKSBhbmQgYSB2YWx1ZSB3aGljaCBpcyBhbiBvYmplY3Qgd2l0aCB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXMgKG9ubHkgbGFiZWwgYW5kIGFjdGlvbiBhcmUgcmVxdWlyZWQpLiBPbmNlIGEgbWVudSBpdGVtIGlzIGFjdGl2YXRlZCB0aGUgYGFjdGlvbmAgZnVuY3Rpb24gd2lsbCBiZSBpbnZva2VkIHdpdGggYW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIGZvbGxvd2luZyBrZXlzOiBpdGVtIC0gdGhlIGNvbnRleHRtZW51IGl0ZW0gZGVmaW5pdGlvbiBhcyBzZWVuIGJlbG93LCByZWZlcmVuY2UgLSB0aGUgRE9NIG5vZGUgdGhhdCB3YXMgdXNlZCAodGhlIHRyZWUgbm9kZSksIGVsZW1lbnQgLSB0aGUgY29udGV4dG1lbnUgRE9NIGVsZW1lbnQsIHBvc2l0aW9uIC0gYW4gb2JqZWN0IHdpdGggeC95IHByb3BlcnRpZXMgaW5kaWNhdGluZyB0aGUgcG9zaXRpb24gb2YgdGhlIG1lbnUuXG5cdFx0ICpcblx0XHQgKiAqIGBzZXBhcmF0b3JfYmVmb3JlYCAtIGEgYm9vbGVhbiBpbmRpY2F0aW5nIGlmIHRoZXJlIHNob3VsZCBiZSBhIHNlcGFyYXRvciBiZWZvcmUgdGhpcyBpdGVtXG5cdFx0ICogKiBgc2VwYXJhdG9yX2FmdGVyYCAtIGEgYm9vbGVhbiBpbmRpY2F0aW5nIGlmIHRoZXJlIHNob3VsZCBiZSBhIHNlcGFyYXRvciBhZnRlciB0aGlzIGl0ZW1cblx0XHQgKiAqIGBfZGlzYWJsZWRgIC0gYSBib29sZWFuIGluZGljYXRpbmcgaWYgdGhpcyBhY3Rpb24gc2hvdWxkIGJlIGRpc2FibGVkXG5cdFx0ICogKiBgbGFiZWxgIC0gYSBzdHJpbmcgLSB0aGUgbmFtZSBvZiB0aGUgYWN0aW9uIChjb3VsZCBiZSBhIGZ1bmN0aW9uIHJldHVybmluZyBhIHN0cmluZylcblx0XHQgKiAqIGB0aXRsZWAgLSBhIHN0cmluZyAtIGFuIG9wdGlvbmFsIHRvb2x0aXAgZm9yIHRoZSBpdGVtXG5cdFx0ICogKiBgYWN0aW9uYCAtIGEgZnVuY3Rpb24gdG8gYmUgZXhlY3V0ZWQgaWYgdGhpcyBpdGVtIGlzIGNob3NlbiwgdGhlIGZ1bmN0aW9uIHdpbGwgcmVjZWl2ZSBcblx0XHQgKiAqIGBpY29uYCAtIGEgc3RyaW5nLCBjYW4gYmUgYSBwYXRoIHRvIGFuIGljb24gb3IgYSBjbGFzc05hbWUsIGlmIHVzaW5nIGFuIGltYWdlIHRoYXQgaXMgaW4gdGhlIGN1cnJlbnQgZGlyZWN0b3J5IHVzZSBhIGAuL2AgcHJlZml4LCBvdGhlcndpc2UgaXQgd2lsbCBiZSBkZXRlY3RlZCBhcyBhIGNsYXNzXG5cdFx0ICogKiBgc2hvcnRjdXRgIC0ga2V5Q29kZSB3aGljaCB3aWxsIHRyaWdnZXIgdGhlIGFjdGlvbiBpZiB0aGUgbWVudSBpcyBvcGVuIChmb3IgZXhhbXBsZSBgMTEzYCBmb3IgcmVuYW1lLCB3aGljaCBlcXVhbHMgRjIpXG5cdFx0ICogKiBgc2hvcnRjdXRfbGFiZWxgIC0gc2hvcnRjdXQgbGFiZWwgKGxpa2UgZm9yIGV4YW1wbGUgYEYyYCBmb3IgcmVuYW1lKVxuXHRcdCAqICogYHN1Ym1lbnVgIC0gYW4gb2JqZWN0IHdpdGggdGhlIHNhbWUgc3RydWN0dXJlIGFzICQuanN0cmVlLmRlZmF1bHRzLmNvbnRleHRtZW51Lml0ZW1zIHdoaWNoIGNhbiBiZSB1c2VkIHRvIGNyZWF0ZSBhIHN1Ym1lbnUgLSBlYWNoIGtleSB3aWxsIGJlIHJlbmRlcmVkIGFzIGEgc2VwYXJhdGUgb3B0aW9uIGluIGEgc3VibWVudSB0aGF0IHdpbGwgYXBwZWFyIG9uY2UgdGhlIGN1cnJlbnQgaXRlbSBpcyBob3ZlcmVkXG5cdFx0ICpcblx0XHQgKiBAbmFtZSAkLmpzdHJlZS5kZWZhdWx0cy5jb250ZXh0bWVudS5pdGVtc1xuXHRcdCAqIEBwbHVnaW4gY29udGV4dG1lbnVcblx0XHQgKi9cblx0XHRpdGVtcyA6IGZ1bmN0aW9uIChvLCBjYikgeyAvLyBDb3VsZCBiZSBhbiBvYmplY3QgZGlyZWN0bHlcblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdFwiY3JlYXRlXCIgOiB7XG5cdFx0XHRcdFx0XCJzZXBhcmF0b3JfYmVmb3JlXCJcdDogZmFsc2UsXG5cdFx0XHRcdFx0XCJzZXBhcmF0b3JfYWZ0ZXJcIlx0OiB0cnVlLFxuXHRcdFx0XHRcdFwiX2Rpc2FibGVkXCJcdFx0XHQ6IGZhbHNlLCAvLyh0aGlzLmNoZWNrKFwiY3JlYXRlX25vZGVcIiwgZGF0YS5yZWZlcmVuY2UsIHt9LCBcImxhc3RcIikpLFxuXHRcdFx0XHRcdFwibGFiZWxcIlx0XHRcdFx0OiBcIkNyZWF0ZVwiLFxuXHRcdFx0XHRcdFwiYWN0aW9uXCJcdFx0XHQ6IGZ1bmN0aW9uIChkYXRhKSB7XG5cdFx0XHRcdFx0XHR2YXIgaW5zdCA9ICQuanN0cmVlLnJlZmVyZW5jZShkYXRhLnJlZmVyZW5jZSksXG5cdFx0XHRcdFx0XHRcdG9iaiA9IGluc3QuZ2V0X25vZGUoZGF0YS5yZWZlcmVuY2UpO1xuXHRcdFx0XHRcdFx0aW5zdC5jcmVhdGVfbm9kZShvYmosIHt9LCBcImxhc3RcIiwgZnVuY3Rpb24gKG5ld19ub2RlKSB7XG5cdFx0XHRcdFx0XHRcdHNldFRpbWVvdXQoZnVuY3Rpb24gKCkgeyBpbnN0LmVkaXQobmV3X25vZGUpOyB9LDApO1xuXHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9LFxuXHRcdFx0XHRcInJlbmFtZVwiIDoge1xuXHRcdFx0XHRcdFwic2VwYXJhdG9yX2JlZm9yZVwiXHQ6IGZhbHNlLFxuXHRcdFx0XHRcdFwic2VwYXJhdG9yX2FmdGVyXCJcdDogZmFsc2UsXG5cdFx0XHRcdFx0XCJfZGlzYWJsZWRcIlx0XHRcdDogZmFsc2UsIC8vKHRoaXMuY2hlY2soXCJyZW5hbWVfbm9kZVwiLCBkYXRhLnJlZmVyZW5jZSwgdGhpcy5nZXRfcGFyZW50KGRhdGEucmVmZXJlbmNlKSwgXCJcIikpLFxuXHRcdFx0XHRcdFwibGFiZWxcIlx0XHRcdFx0OiBcIlJlbmFtZVwiLFxuXHRcdFx0XHRcdC8qIVxuXHRcdFx0XHRcdFwic2hvcnRjdXRcIlx0XHRcdDogMTEzLFxuXHRcdFx0XHRcdFwic2hvcnRjdXRfbGFiZWxcIlx0OiAnRjInLFxuXHRcdFx0XHRcdFwiaWNvblwiXHRcdFx0XHQ6IFwiZ2x5cGhpY29uIGdseXBoaWNvbi1sZWFmXCIsXG5cdFx0XHRcdFx0Ki9cblx0XHRcdFx0XHRcImFjdGlvblwiXHRcdFx0OiBmdW5jdGlvbiAoZGF0YSkge1xuXHRcdFx0XHRcdFx0dmFyIGluc3QgPSAkLmpzdHJlZS5yZWZlcmVuY2UoZGF0YS5yZWZlcmVuY2UpLFxuXHRcdFx0XHRcdFx0XHRvYmogPSBpbnN0LmdldF9ub2RlKGRhdGEucmVmZXJlbmNlKTtcblx0XHRcdFx0XHRcdGluc3QuZWRpdChvYmopO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSxcblx0XHRcdFx0XCJyZW1vdmVcIiA6IHtcblx0XHRcdFx0XHRcInNlcGFyYXRvcl9iZWZvcmVcIlx0OiBmYWxzZSxcblx0XHRcdFx0XHRcImljb25cIlx0XHRcdFx0OiBmYWxzZSxcblx0XHRcdFx0XHRcInNlcGFyYXRvcl9hZnRlclwiXHQ6IGZhbHNlLFxuXHRcdFx0XHRcdFwiX2Rpc2FibGVkXCJcdFx0XHQ6IGZhbHNlLCAvLyh0aGlzLmNoZWNrKFwiZGVsZXRlX25vZGVcIiwgZGF0YS5yZWZlcmVuY2UsIHRoaXMuZ2V0X3BhcmVudChkYXRhLnJlZmVyZW5jZSksIFwiXCIpKSxcblx0XHRcdFx0XHRcImxhYmVsXCJcdFx0XHRcdDogXCJEZWxldGVcIixcblx0XHRcdFx0XHRcImFjdGlvblwiXHRcdFx0OiBmdW5jdGlvbiAoZGF0YSkge1xuXHRcdFx0XHRcdFx0dmFyIGluc3QgPSAkLmpzdHJlZS5yZWZlcmVuY2UoZGF0YS5yZWZlcmVuY2UpLFxuXHRcdFx0XHRcdFx0XHRvYmogPSBpbnN0LmdldF9ub2RlKGRhdGEucmVmZXJlbmNlKTtcblx0XHRcdFx0XHRcdGlmKGluc3QuaXNfc2VsZWN0ZWQob2JqKSkge1xuXHRcdFx0XHRcdFx0XHRpbnN0LmRlbGV0ZV9ub2RlKGluc3QuZ2V0X3NlbGVjdGVkKCkpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0XHRcdGluc3QuZGVsZXRlX25vZGUob2JqKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0sXG5cdFx0XHRcdFwiY2NwXCIgOiB7XG5cdFx0XHRcdFx0XCJzZXBhcmF0b3JfYmVmb3JlXCJcdDogdHJ1ZSxcblx0XHRcdFx0XHRcImljb25cIlx0XHRcdFx0OiBmYWxzZSxcblx0XHRcdFx0XHRcInNlcGFyYXRvcl9hZnRlclwiXHQ6IGZhbHNlLFxuXHRcdFx0XHRcdFwibGFiZWxcIlx0XHRcdFx0OiBcIkVkaXRcIixcblx0XHRcdFx0XHRcImFjdGlvblwiXHRcdFx0OiBmYWxzZSxcblx0XHRcdFx0XHRcInN1Ym1lbnVcIiA6IHtcblx0XHRcdFx0XHRcdFwiY3V0XCIgOiB7XG5cdFx0XHRcdFx0XHRcdFwic2VwYXJhdG9yX2JlZm9yZVwiXHQ6IGZhbHNlLFxuXHRcdFx0XHRcdFx0XHRcInNlcGFyYXRvcl9hZnRlclwiXHQ6IGZhbHNlLFxuXHRcdFx0XHRcdFx0XHRcImxhYmVsXCJcdFx0XHRcdDogXCJDdXRcIixcblx0XHRcdFx0XHRcdFx0XCJhY3Rpb25cIlx0XHRcdDogZnVuY3Rpb24gKGRhdGEpIHtcblx0XHRcdFx0XHRcdFx0XHR2YXIgaW5zdCA9ICQuanN0cmVlLnJlZmVyZW5jZShkYXRhLnJlZmVyZW5jZSksXG5cdFx0XHRcdFx0XHRcdFx0XHRvYmogPSBpbnN0LmdldF9ub2RlKGRhdGEucmVmZXJlbmNlKTtcblx0XHRcdFx0XHRcdFx0XHRpZihpbnN0LmlzX3NlbGVjdGVkKG9iaikpIHtcblx0XHRcdFx0XHRcdFx0XHRcdGluc3QuY3V0KGluc3QuZ2V0X3RvcF9zZWxlY3RlZCgpKTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRpbnN0LmN1dChvYmopO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFwiY29weVwiIDoge1xuXHRcdFx0XHRcdFx0XHRcInNlcGFyYXRvcl9iZWZvcmVcIlx0OiBmYWxzZSxcblx0XHRcdFx0XHRcdFx0XCJpY29uXCJcdFx0XHRcdDogZmFsc2UsXG5cdFx0XHRcdFx0XHRcdFwic2VwYXJhdG9yX2FmdGVyXCJcdDogZmFsc2UsXG5cdFx0XHRcdFx0XHRcdFwibGFiZWxcIlx0XHRcdFx0OiBcIkNvcHlcIixcblx0XHRcdFx0XHRcdFx0XCJhY3Rpb25cIlx0XHRcdDogZnVuY3Rpb24gKGRhdGEpIHtcblx0XHRcdFx0XHRcdFx0XHR2YXIgaW5zdCA9ICQuanN0cmVlLnJlZmVyZW5jZShkYXRhLnJlZmVyZW5jZSksXG5cdFx0XHRcdFx0XHRcdFx0XHRvYmogPSBpbnN0LmdldF9ub2RlKGRhdGEucmVmZXJlbmNlKTtcblx0XHRcdFx0XHRcdFx0XHRpZihpbnN0LmlzX3NlbGVjdGVkKG9iaikpIHtcblx0XHRcdFx0XHRcdFx0XHRcdGluc3QuY29weShpbnN0LmdldF90b3Bfc2VsZWN0ZWQoKSk7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdFx0aW5zdC5jb3B5KG9iaik7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XCJwYXN0ZVwiIDoge1xuXHRcdFx0XHRcdFx0XHRcInNlcGFyYXRvcl9iZWZvcmVcIlx0OiBmYWxzZSxcblx0XHRcdFx0XHRcdFx0XCJpY29uXCJcdFx0XHRcdDogZmFsc2UsXG5cdFx0XHRcdFx0XHRcdFwiX2Rpc2FibGVkXCJcdFx0XHQ6IGZ1bmN0aW9uIChkYXRhKSB7XG5cdFx0XHRcdFx0XHRcdFx0cmV0dXJuICEkLmpzdHJlZS5yZWZlcmVuY2UoZGF0YS5yZWZlcmVuY2UpLmNhbl9wYXN0ZSgpO1xuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcInNlcGFyYXRvcl9hZnRlclwiXHQ6IGZhbHNlLFxuXHRcdFx0XHRcdFx0XHRcImxhYmVsXCJcdFx0XHRcdDogXCJQYXN0ZVwiLFxuXHRcdFx0XHRcdFx0XHRcImFjdGlvblwiXHRcdFx0OiBmdW5jdGlvbiAoZGF0YSkge1xuXHRcdFx0XHRcdFx0XHRcdHZhciBpbnN0ID0gJC5qc3RyZWUucmVmZXJlbmNlKGRhdGEucmVmZXJlbmNlKSxcblx0XHRcdFx0XHRcdFx0XHRcdG9iaiA9IGluc3QuZ2V0X25vZGUoZGF0YS5yZWZlcmVuY2UpO1xuXHRcdFx0XHRcdFx0XHRcdGluc3QucGFzdGUob2JqKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fTtcblx0XHR9XG5cdH07XG5cblx0JC5qc3RyZWUucGx1Z2lucy5jb250ZXh0bWVudSA9IGZ1bmN0aW9uIChvcHRpb25zLCBwYXJlbnQpIHtcblx0XHR0aGlzLmJpbmQgPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHRwYXJlbnQuYmluZC5jYWxsKHRoaXMpO1xuXG5cdFx0XHR2YXIgbGFzdF90cyA9IDAsIGN0byA9IG51bGwsIGV4LCBleTtcblx0XHRcdHRoaXMuZWxlbWVudFxuXHRcdFx0XHQub24oXCJjb250ZXh0bWVudS5qc3RyZWVcIiwgXCIuanN0cmVlLWFuY2hvclwiLCAkLnByb3h5KGZ1bmN0aW9uIChlLCBkYXRhKSB7XG5cdFx0XHRcdFx0XHRpZiAoZS50YXJnZXQudGFnTmFtZS50b0xvd2VyQ2FzZSgpID09PSAnaW5wdXQnKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGUucHJldmVudERlZmF1bHQoKTtcblx0XHRcdFx0XHRcdGxhc3RfdHMgPSBlLmN0cmxLZXkgPyArbmV3IERhdGUoKSA6IDA7XG5cdFx0XHRcdFx0XHRpZihkYXRhIHx8IGN0bykge1xuXHRcdFx0XHRcdFx0XHRsYXN0X3RzID0gKCtuZXcgRGF0ZSgpKSArIDEwMDAwO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0aWYoY3RvKSB7XG5cdFx0XHRcdFx0XHRcdGNsZWFyVGltZW91dChjdG8pO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0aWYoIXRoaXMuaXNfbG9hZGluZyhlLmN1cnJlbnRUYXJnZXQpKSB7XG5cdFx0XHRcdFx0XHRcdHRoaXMuc2hvd19jb250ZXh0bWVudShlLmN1cnJlbnRUYXJnZXQsIGUucGFnZVgsIGUucGFnZVksIGUpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0sIHRoaXMpKVxuXHRcdFx0XHQub24oXCJjbGljay5qc3RyZWVcIiwgXCIuanN0cmVlLWFuY2hvclwiLCAkLnByb3h5KGZ1bmN0aW9uIChlKSB7XG5cdFx0XHRcdFx0XHRpZih0aGlzLl9kYXRhLmNvbnRleHRtZW51LnZpc2libGUgJiYgKCFsYXN0X3RzIHx8ICgrbmV3IERhdGUoKSkgLSBsYXN0X3RzID4gMjUwKSkgeyAvLyB3b3JrIGFyb3VuZCBzYWZhcmkgJiBtYWNPUyBjdHJsK2NsaWNrXG5cdFx0XHRcdFx0XHRcdCQudmFrYXRhLmNvbnRleHQuaGlkZSgpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0bGFzdF90cyA9IDA7XG5cdFx0XHRcdFx0fSwgdGhpcykpXG5cdFx0XHRcdC5vbihcInRvdWNoc3RhcnQuanN0cmVlXCIsIFwiLmpzdHJlZS1hbmNob3JcIiwgZnVuY3Rpb24gKGUpIHtcblx0XHRcdFx0XHRcdGlmKCFlLm9yaWdpbmFsRXZlbnQgfHwgIWUub3JpZ2luYWxFdmVudC5jaGFuZ2VkVG91Y2hlcyB8fCAhZS5vcmlnaW5hbEV2ZW50LmNoYW5nZWRUb3VjaGVzWzBdKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGV4ID0gZS5vcmlnaW5hbEV2ZW50LmNoYW5nZWRUb3VjaGVzWzBdLmNsaWVudFg7XG5cdFx0XHRcdFx0XHRleSA9IGUub3JpZ2luYWxFdmVudC5jaGFuZ2VkVG91Y2hlc1swXS5jbGllbnRZO1xuXHRcdFx0XHRcdFx0Y3RvID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdFx0XHRcdCQoZS5jdXJyZW50VGFyZ2V0KS50cmlnZ2VyKCdjb250ZXh0bWVudScsIHRydWUpO1xuXHRcdFx0XHRcdFx0fSwgNzUwKTtcblx0XHRcdFx0XHR9KVxuXHRcdFx0XHQub24oJ3RvdWNobW92ZS52YWthdGEuanN0cmVlJywgZnVuY3Rpb24gKGUpIHtcblx0XHRcdFx0XHRcdGlmKGN0byAmJiBlLm9yaWdpbmFsRXZlbnQgJiYgZS5vcmlnaW5hbEV2ZW50LmNoYW5nZWRUb3VjaGVzICYmIGUub3JpZ2luYWxFdmVudC5jaGFuZ2VkVG91Y2hlc1swXSAmJiAoTWF0aC5hYnMoZXggLSBlLm9yaWdpbmFsRXZlbnQuY2hhbmdlZFRvdWNoZXNbMF0uY2xpZW50WCkgPiA1MCB8fCBNYXRoLmFicyhleSAtIGUub3JpZ2luYWxFdmVudC5jaGFuZ2VkVG91Y2hlc1swXS5jbGllbnRZKSA+IDUwKSkge1xuXHRcdFx0XHRcdFx0XHRjbGVhclRpbWVvdXQoY3RvKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9KVxuXHRcdFx0XHQub24oJ3RvdWNoZW5kLnZha2F0YS5qc3RyZWUnLCBmdW5jdGlvbiAoZSkge1xuXHRcdFx0XHRcdFx0aWYoY3RvKSB7XG5cdFx0XHRcdFx0XHRcdGNsZWFyVGltZW91dChjdG8pO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0pO1xuXG5cdFx0XHQvKiFcblx0XHRcdGlmKCEoJ29uY29udGV4dG1lbnUnIGluIGRvY3VtZW50LmJvZHkpICYmICgnb250b3VjaHN0YXJ0JyBpbiBkb2N1bWVudC5ib2R5KSkge1xuXHRcdFx0XHR2YXIgZWwgPSBudWxsLCB0bSA9IG51bGw7XG5cdFx0XHRcdHRoaXMuZWxlbWVudFxuXHRcdFx0XHRcdC5vbihcInRvdWNoc3RhcnRcIiwgXCIuanN0cmVlLWFuY2hvclwiLCBmdW5jdGlvbiAoZSkge1xuXHRcdFx0XHRcdFx0ZWwgPSBlLmN1cnJlbnRUYXJnZXQ7XG5cdFx0XHRcdFx0XHR0bSA9ICtuZXcgRGF0ZSgpO1xuXHRcdFx0XHRcdFx0JChkb2N1bWVudCkub25lKFwidG91Y2hlbmRcIiwgZnVuY3Rpb24gKGUpIHtcblx0XHRcdFx0XHRcdFx0ZS50YXJnZXQgPSBkb2N1bWVudC5lbGVtZW50RnJvbVBvaW50KGUub3JpZ2luYWxFdmVudC50YXJnZXRUb3VjaGVzWzBdLnBhZ2VYIC0gd2luZG93LnBhZ2VYT2Zmc2V0LCBlLm9yaWdpbmFsRXZlbnQudGFyZ2V0VG91Y2hlc1swXS5wYWdlWSAtIHdpbmRvdy5wYWdlWU9mZnNldCk7XG5cdFx0XHRcdFx0XHRcdGUuY3VycmVudFRhcmdldCA9IGUudGFyZ2V0O1xuXHRcdFx0XHRcdFx0XHR0bSA9ICgoKyhuZXcgRGF0ZSgpKSkgLSB0bSk7XG5cdFx0XHRcdFx0XHRcdGlmKGUudGFyZ2V0ID09PSBlbCAmJiB0bSA+IDYwMCAmJiB0bSA8IDEwMDApIHtcblx0XHRcdFx0XHRcdFx0XHRlLnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHRcdFx0XHRcdFx0JChlbCkudHJpZ2dlcignY29udGV4dG1lbnUnLCBlKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRlbCA9IG51bGw7XG5cdFx0XHRcdFx0XHRcdHRtID0gbnVsbDtcblx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdH0pO1xuXHRcdFx0fVxuXHRcdFx0Ki9cblx0XHRcdCQoZG9jdW1lbnQpLm9uKFwiY29udGV4dF9oaWRlLnZha2F0YS5qc3RyZWVcIiwgJC5wcm94eShmdW5jdGlvbiAoZSwgZGF0YSkge1xuXHRcdFx0XHR0aGlzLl9kYXRhLmNvbnRleHRtZW51LnZpc2libGUgPSBmYWxzZTtcblx0XHRcdFx0JChkYXRhLnJlZmVyZW5jZSkucmVtb3ZlQ2xhc3MoJ2pzdHJlZS1jb250ZXh0Jyk7XG5cdFx0XHR9LCB0aGlzKSk7XG5cdFx0fTtcblx0XHR0aGlzLnRlYXJkb3duID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0aWYodGhpcy5fZGF0YS5jb250ZXh0bWVudS52aXNpYmxlKSB7XG5cdFx0XHRcdCQudmFrYXRhLmNvbnRleHQuaGlkZSgpO1xuXHRcdFx0fVxuXHRcdFx0cGFyZW50LnRlYXJkb3duLmNhbGwodGhpcyk7XG5cdFx0fTtcblxuXHRcdC8qKlxuXHRcdCAqIHByZXBhcmUgYW5kIHNob3cgdGhlIGNvbnRleHQgbWVudSBmb3IgYSBub2RlXG5cdFx0ICogQG5hbWUgc2hvd19jb250ZXh0bWVudShvYmogWywgeCwgeV0pXG5cdFx0ICogQHBhcmFtIHttaXhlZH0gb2JqIHRoZSBub2RlXG5cdFx0ICogQHBhcmFtIHtOdW1iZXJ9IHggdGhlIHgtY29vcmRpbmF0ZSByZWxhdGl2ZSB0byB0aGUgZG9jdW1lbnQgdG8gc2hvdyB0aGUgbWVudSBhdFxuXHRcdCAqIEBwYXJhbSB7TnVtYmVyfSB5IHRoZSB5LWNvb3JkaW5hdGUgcmVsYXRpdmUgdG8gdGhlIGRvY3VtZW50IHRvIHNob3cgdGhlIG1lbnUgYXRcblx0XHQgKiBAcGFyYW0ge09iamVjdH0gZSB0aGUgZXZlbnQgaWYgYXZhaWxhYmxlIHRoYXQgdHJpZ2dlcmVkIHRoZSBjb250ZXh0bWVudVxuXHRcdCAqIEBwbHVnaW4gY29udGV4dG1lbnVcblx0XHQgKiBAdHJpZ2dlciBzaG93X2NvbnRleHRtZW51LmpzdHJlZVxuXHRcdCAqL1xuXHRcdHRoaXMuc2hvd19jb250ZXh0bWVudSA9IGZ1bmN0aW9uIChvYmosIHgsIHksIGUpIHtcblx0XHRcdG9iaiA9IHRoaXMuZ2V0X25vZGUob2JqKTtcblx0XHRcdGlmKCFvYmogfHwgb2JqLmlkID09PSAkLmpzdHJlZS5yb290KSB7IHJldHVybiBmYWxzZTsgfVxuXHRcdFx0dmFyIHMgPSB0aGlzLnNldHRpbmdzLmNvbnRleHRtZW51LFxuXHRcdFx0XHRkID0gdGhpcy5nZXRfbm9kZShvYmosIHRydWUpLFxuXHRcdFx0XHRhID0gZC5jaGlsZHJlbihcIi5qc3RyZWUtYW5jaG9yXCIpLFxuXHRcdFx0XHRvID0gZmFsc2UsXG5cdFx0XHRcdGkgPSBmYWxzZTtcblx0XHRcdGlmKHMuc2hvd19hdF9ub2RlIHx8IHggPT09IHVuZGVmaW5lZCB8fCB5ID09PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0byA9IGEub2Zmc2V0KCk7XG5cdFx0XHRcdHggPSBvLmxlZnQ7XG5cdFx0XHRcdHkgPSBvLnRvcCArIHRoaXMuX2RhdGEuY29yZS5saV9oZWlnaHQ7XG5cdFx0XHR9XG5cdFx0XHRpZih0aGlzLnNldHRpbmdzLmNvbnRleHRtZW51LnNlbGVjdF9ub2RlICYmICF0aGlzLmlzX3NlbGVjdGVkKG9iaikpIHtcblx0XHRcdFx0dGhpcy5hY3RpdmF0ZV9ub2RlKG9iaiwgZSk7XG5cdFx0XHR9XG5cblx0XHRcdGkgPSBzLml0ZW1zO1xuXHRcdFx0aWYoJC5pc0Z1bmN0aW9uKGkpKSB7XG5cdFx0XHRcdGkgPSBpLmNhbGwodGhpcywgb2JqLCAkLnByb3h5KGZ1bmN0aW9uIChpKSB7XG5cdFx0XHRcdFx0dGhpcy5fc2hvd19jb250ZXh0bWVudShvYmosIHgsIHksIGkpO1xuXHRcdFx0XHR9LCB0aGlzKSk7XG5cdFx0XHR9XG5cdFx0XHRpZigkLmlzUGxhaW5PYmplY3QoaSkpIHtcblx0XHRcdFx0dGhpcy5fc2hvd19jb250ZXh0bWVudShvYmosIHgsIHksIGkpO1xuXHRcdFx0fVxuXHRcdH07XG5cdFx0LyoqXG5cdFx0ICogc2hvdyB0aGUgcHJlcGFyZWQgY29udGV4dCBtZW51IGZvciBhIG5vZGVcblx0XHQgKiBAbmFtZSBfc2hvd19jb250ZXh0bWVudShvYmosIHgsIHksIGkpXG5cdFx0ICogQHBhcmFtIHttaXhlZH0gb2JqIHRoZSBub2RlXG5cdFx0ICogQHBhcmFtIHtOdW1iZXJ9IHggdGhlIHgtY29vcmRpbmF0ZSByZWxhdGl2ZSB0byB0aGUgZG9jdW1lbnQgdG8gc2hvdyB0aGUgbWVudSBhdFxuXHRcdCAqIEBwYXJhbSB7TnVtYmVyfSB5IHRoZSB5LWNvb3JkaW5hdGUgcmVsYXRpdmUgdG8gdGhlIGRvY3VtZW50IHRvIHNob3cgdGhlIG1lbnUgYXRcblx0XHQgKiBAcGFyYW0ge051bWJlcn0gaSB0aGUgb2JqZWN0IG9mIGl0ZW1zIHRvIHNob3dcblx0XHQgKiBAcGx1Z2luIGNvbnRleHRtZW51XG5cdFx0ICogQHRyaWdnZXIgc2hvd19jb250ZXh0bWVudS5qc3RyZWVcblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqL1xuXHRcdHRoaXMuX3Nob3dfY29udGV4dG1lbnUgPSBmdW5jdGlvbiAob2JqLCB4LCB5LCBpKSB7XG5cdFx0XHR2YXIgZCA9IHRoaXMuZ2V0X25vZGUob2JqLCB0cnVlKSxcblx0XHRcdFx0YSA9IGQuY2hpbGRyZW4oXCIuanN0cmVlLWFuY2hvclwiKTtcblx0XHRcdCQoZG9jdW1lbnQpLm9uZShcImNvbnRleHRfc2hvdy52YWthdGEuanN0cmVlXCIsICQucHJveHkoZnVuY3Rpb24gKGUsIGRhdGEpIHtcblx0XHRcdFx0dmFyIGNscyA9ICdqc3RyZWUtY29udGV4dG1lbnUganN0cmVlLScgKyB0aGlzLmdldF90aGVtZSgpICsgJy1jb250ZXh0bWVudSc7XG5cdFx0XHRcdCQoZGF0YS5lbGVtZW50KS5hZGRDbGFzcyhjbHMpO1xuXHRcdFx0XHRhLmFkZENsYXNzKCdqc3RyZWUtY29udGV4dCcpO1xuXHRcdFx0fSwgdGhpcykpO1xuXHRcdFx0dGhpcy5fZGF0YS5jb250ZXh0bWVudS52aXNpYmxlID0gdHJ1ZTtcblx0XHRcdCQudmFrYXRhLmNvbnRleHQuc2hvdyhhLCB7ICd4JyA6IHgsICd5JyA6IHkgfSwgaSk7XG5cdFx0XHQvKipcblx0XHRcdCAqIHRyaWdnZXJlZCB3aGVuIHRoZSBjb250ZXh0bWVudSBpcyBzaG93biBmb3IgYSBub2RlXG5cdFx0XHQgKiBAZXZlbnRcblx0XHRcdCAqIEBuYW1lIHNob3dfY29udGV4dG1lbnUuanN0cmVlXG5cdFx0XHQgKiBAcGFyYW0ge09iamVjdH0gbm9kZSB0aGUgbm9kZVxuXHRcdFx0ICogQHBhcmFtIHtOdW1iZXJ9IHggdGhlIHgtY29vcmRpbmF0ZSBvZiB0aGUgbWVudSByZWxhdGl2ZSB0byB0aGUgZG9jdW1lbnRcblx0XHRcdCAqIEBwYXJhbSB7TnVtYmVyfSB5IHRoZSB5LWNvb3JkaW5hdGUgb2YgdGhlIG1lbnUgcmVsYXRpdmUgdG8gdGhlIGRvY3VtZW50XG5cdFx0XHQgKiBAcGx1Z2luIGNvbnRleHRtZW51XG5cdFx0XHQgKi9cblx0XHRcdHRoaXMudHJpZ2dlcignc2hvd19jb250ZXh0bWVudScsIHsgXCJub2RlXCIgOiBvYmosIFwieFwiIDogeCwgXCJ5XCIgOiB5IH0pO1xuXHRcdH07XG5cdH07XG5cblx0Ly8gY29udGV4dG1lbnUgaGVscGVyXG5cdChmdW5jdGlvbiAoJCkge1xuXHRcdHZhciByaWdodF90b19sZWZ0ID0gZmFsc2UsXG5cdFx0XHR2YWthdGFfY29udGV4dCA9IHtcblx0XHRcdFx0ZWxlbWVudFx0XHQ6IGZhbHNlLFxuXHRcdFx0XHRyZWZlcmVuY2VcdDogZmFsc2UsXG5cdFx0XHRcdHBvc2l0aW9uX3hcdDogMCxcblx0XHRcdFx0cG9zaXRpb25feVx0OiAwLFxuXHRcdFx0XHRpdGVtc1x0XHQ6IFtdLFxuXHRcdFx0XHRodG1sXHRcdDogXCJcIixcblx0XHRcdFx0aXNfdmlzaWJsZVx0OiBmYWxzZVxuXHRcdFx0fTtcblxuXHRcdCQudmFrYXRhLmNvbnRleHQgPSB7XG5cdFx0XHRzZXR0aW5ncyA6IHtcblx0XHRcdFx0aGlkZV9vbm1vdXNlbGVhdmVcdDogMCxcblx0XHRcdFx0aWNvbnNcdFx0XHRcdDogdHJ1ZVxuXHRcdFx0fSxcblx0XHRcdF90cmlnZ2VyIDogZnVuY3Rpb24gKGV2ZW50X25hbWUpIHtcblx0XHRcdFx0JChkb2N1bWVudCkudHJpZ2dlckhhbmRsZXIoXCJjb250ZXh0X1wiICsgZXZlbnRfbmFtZSArIFwiLnZha2F0YVwiLCB7XG5cdFx0XHRcdFx0XCJyZWZlcmVuY2VcIlx0OiB2YWthdGFfY29udGV4dC5yZWZlcmVuY2UsXG5cdFx0XHRcdFx0XCJlbGVtZW50XCJcdDogdmFrYXRhX2NvbnRleHQuZWxlbWVudCxcblx0XHRcdFx0XHRcInBvc2l0aW9uXCJcdDoge1xuXHRcdFx0XHRcdFx0XCJ4XCIgOiB2YWthdGFfY29udGV4dC5wb3NpdGlvbl94LFxuXHRcdFx0XHRcdFx0XCJ5XCIgOiB2YWthdGFfY29udGV4dC5wb3NpdGlvbl95XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KTtcblx0XHRcdH0sXG5cdFx0XHRfZXhlY3V0ZSA6IGZ1bmN0aW9uIChpKSB7XG5cdFx0XHRcdGkgPSB2YWthdGFfY29udGV4dC5pdGVtc1tpXTtcblx0XHRcdFx0cmV0dXJuIGkgJiYgKCFpLl9kaXNhYmxlZCB8fCAoJC5pc0Z1bmN0aW9uKGkuX2Rpc2FibGVkKSAmJiAhaS5fZGlzYWJsZWQoeyBcIml0ZW1cIiA6IGksIFwicmVmZXJlbmNlXCIgOiB2YWthdGFfY29udGV4dC5yZWZlcmVuY2UsIFwiZWxlbWVudFwiIDogdmFrYXRhX2NvbnRleHQuZWxlbWVudCB9KSkpICYmIGkuYWN0aW9uID8gaS5hY3Rpb24uY2FsbChudWxsLCB7XG5cdFx0XHRcdFx0XHRcdFwiaXRlbVwiXHRcdDogaSxcblx0XHRcdFx0XHRcdFx0XCJyZWZlcmVuY2VcIlx0OiB2YWthdGFfY29udGV4dC5yZWZlcmVuY2UsXG5cdFx0XHRcdFx0XHRcdFwiZWxlbWVudFwiXHQ6IHZha2F0YV9jb250ZXh0LmVsZW1lbnQsXG5cdFx0XHRcdFx0XHRcdFwicG9zaXRpb25cIlx0OiB7XG5cdFx0XHRcdFx0XHRcdFx0XCJ4XCIgOiB2YWthdGFfY29udGV4dC5wb3NpdGlvbl94LFxuXHRcdFx0XHRcdFx0XHRcdFwieVwiIDogdmFrYXRhX2NvbnRleHQucG9zaXRpb25feVxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9KSA6IGZhbHNlO1xuXHRcdFx0fSxcblx0XHRcdF9wYXJzZSA6IGZ1bmN0aW9uIChvLCBpc19jYWxsYmFjaykge1xuXHRcdFx0XHRpZighbykgeyByZXR1cm4gZmFsc2U7IH1cblx0XHRcdFx0aWYoIWlzX2NhbGxiYWNrKSB7XG5cdFx0XHRcdFx0dmFrYXRhX2NvbnRleHQuaHRtbFx0XHQ9IFwiXCI7XG5cdFx0XHRcdFx0dmFrYXRhX2NvbnRleHQuaXRlbXNcdD0gW107XG5cdFx0XHRcdH1cblx0XHRcdFx0dmFyIHN0ciA9IFwiXCIsXG5cdFx0XHRcdFx0c2VwID0gZmFsc2UsXG5cdFx0XHRcdFx0dG1wO1xuXG5cdFx0XHRcdGlmKGlzX2NhbGxiYWNrKSB7IHN0ciArPSBcIjxcIitcInVsPlwiOyB9XG5cdFx0XHRcdCQuZWFjaChvLCBmdW5jdGlvbiAoaSwgdmFsKSB7XG5cdFx0XHRcdFx0aWYoIXZhbCkgeyByZXR1cm4gdHJ1ZTsgfVxuXHRcdFx0XHRcdHZha2F0YV9jb250ZXh0Lml0ZW1zLnB1c2godmFsKTtcblx0XHRcdFx0XHRpZighc2VwICYmIHZhbC5zZXBhcmF0b3JfYmVmb3JlKSB7XG5cdFx0XHRcdFx0XHRzdHIgKz0gXCI8XCIrXCJsaSBjbGFzcz0ndmFrYXRhLWNvbnRleHQtc2VwYXJhdG9yJz48XCIrXCJhIGhyZWY9JyMnIFwiICsgKCQudmFrYXRhLmNvbnRleHQuc2V0dGluZ3MuaWNvbnMgPyAnJyA6ICdzdHlsZT1cIm1hcmdpbi1sZWZ0OjBweDtcIicpICsgXCI+JiMxNjA7PFwiK1wiL2E+PFwiK1wiL2xpPlwiO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRzZXAgPSBmYWxzZTtcblx0XHRcdFx0XHRzdHIgKz0gXCI8XCIrXCJsaSBjbGFzcz0nXCIgKyAodmFsLl9jbGFzcyB8fCBcIlwiKSArICh2YWwuX2Rpc2FibGVkID09PSB0cnVlIHx8ICgkLmlzRnVuY3Rpb24odmFsLl9kaXNhYmxlZCkgJiYgdmFsLl9kaXNhYmxlZCh7IFwiaXRlbVwiIDogdmFsLCBcInJlZmVyZW5jZVwiIDogdmFrYXRhX2NvbnRleHQucmVmZXJlbmNlLCBcImVsZW1lbnRcIiA6IHZha2F0YV9jb250ZXh0LmVsZW1lbnQgfSkpID8gXCIgdmFrYXRhLWNvbnRleHRtZW51LWRpc2FibGVkIFwiIDogXCJcIikgKyBcIicgXCIrKHZhbC5zaG9ydGN1dD9cIiBkYXRhLXNob3J0Y3V0PSdcIit2YWwuc2hvcnRjdXQrXCInIFwiOicnKStcIj5cIjtcblx0XHRcdFx0XHRzdHIgKz0gXCI8XCIrXCJhIGhyZWY9JyMnIHJlbD0nXCIgKyAodmFrYXRhX2NvbnRleHQuaXRlbXMubGVuZ3RoIC0gMSkgKyBcIicgXCIgKyAodmFsLnRpdGxlID8gXCJ0aXRsZT0nXCIgKyB2YWwudGl0bGUgKyBcIidcIiA6IFwiXCIpICsgXCI+XCI7XG5cdFx0XHRcdFx0aWYoJC52YWthdGEuY29udGV4dC5zZXR0aW5ncy5pY29ucykge1xuXHRcdFx0XHRcdFx0c3RyICs9IFwiPFwiK1wiaSBcIjtcblx0XHRcdFx0XHRcdGlmKHZhbC5pY29uKSB7XG5cdFx0XHRcdFx0XHRcdGlmKHZhbC5pY29uLmluZGV4T2YoXCIvXCIpICE9PSAtMSB8fCB2YWwuaWNvbi5pbmRleE9mKFwiLlwiKSAhPT0gLTEpIHsgc3RyICs9IFwiIHN0eWxlPSdiYWNrZ3JvdW5kOnVybChcXFwiXCIgKyB2YWwuaWNvbiArIFwiXFxcIikgY2VudGVyIGNlbnRlciBuby1yZXBlYXQnIFwiOyB9XG5cdFx0XHRcdFx0XHRcdGVsc2UgeyBzdHIgKz0gXCIgY2xhc3M9J1wiICsgdmFsLmljb24gKyBcIicgXCI7IH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdHN0ciArPSBcIj48XCIrXCIvaT48XCIrXCJzcGFuIGNsYXNzPSd2YWthdGEtY29udGV4dG1lbnUtc2VwJz4mIzE2MDs8XCIrXCIvc3Bhbj5cIjtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0c3RyICs9ICgkLmlzRnVuY3Rpb24odmFsLmxhYmVsKSA/IHZhbC5sYWJlbCh7IFwiaXRlbVwiIDogaSwgXCJyZWZlcmVuY2VcIiA6IHZha2F0YV9jb250ZXh0LnJlZmVyZW5jZSwgXCJlbGVtZW50XCIgOiB2YWthdGFfY29udGV4dC5lbGVtZW50IH0pIDogdmFsLmxhYmVsKSArICh2YWwuc2hvcnRjdXQ/JyA8c3BhbiBjbGFzcz1cInZha2F0YS1jb250ZXh0bWVudS1zaG9ydGN1dCB2YWthdGEtY29udGV4dG1lbnUtc2hvcnRjdXQtJyt2YWwuc2hvcnRjdXQrJ1wiPicrICh2YWwuc2hvcnRjdXRfbGFiZWwgfHwgJycpICsnPC9zcGFuPic6JycpICsgXCI8XCIrXCIvYT5cIjtcblx0XHRcdFx0XHRpZih2YWwuc3VibWVudSkge1xuXHRcdFx0XHRcdFx0dG1wID0gJC52YWthdGEuY29udGV4dC5fcGFyc2UodmFsLnN1Ym1lbnUsIHRydWUpO1xuXHRcdFx0XHRcdFx0aWYodG1wKSB7IHN0ciArPSB0bXA7IH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0c3RyICs9IFwiPFwiK1wiL2xpPlwiO1xuXHRcdFx0XHRcdGlmKHZhbC5zZXBhcmF0b3JfYWZ0ZXIpIHtcblx0XHRcdFx0XHRcdHN0ciArPSBcIjxcIitcImxpIGNsYXNzPSd2YWthdGEtY29udGV4dC1zZXBhcmF0b3InPjxcIitcImEgaHJlZj0nIycgXCIgKyAoJC52YWthdGEuY29udGV4dC5zZXR0aW5ncy5pY29ucyA/ICcnIDogJ3N0eWxlPVwibWFyZ2luLWxlZnQ6MHB4O1wiJykgKyBcIj4mIzE2MDs8XCIrXCIvYT48XCIrXCIvbGk+XCI7XG5cdFx0XHRcdFx0XHRzZXAgPSB0cnVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSk7XG5cdFx0XHRcdHN0ciAgPSBzdHIucmVwbGFjZSgvPGxpIGNsYXNzXFw9J3Zha2F0YS1jb250ZXh0LXNlcGFyYXRvcidcXD48XFwvbGlcXD4kLyxcIlwiKTtcblx0XHRcdFx0aWYoaXNfY2FsbGJhY2spIHsgc3RyICs9IFwiPC91bD5cIjsgfVxuXHRcdFx0XHQvKipcblx0XHRcdFx0ICogdHJpZ2dlcmVkIG9uIHRoZSBkb2N1bWVudCB3aGVuIHRoZSBjb250ZXh0bWVudSBpcyBwYXJzZWQgKEhUTUwgaXMgYnVpbHQpXG5cdFx0XHRcdCAqIEBldmVudFxuXHRcdFx0XHQgKiBAcGx1Z2luIGNvbnRleHRtZW51XG5cdFx0XHRcdCAqIEBuYW1lIGNvbnRleHRfcGFyc2UudmFrYXRhXG5cdFx0XHRcdCAqIEBwYXJhbSB7alF1ZXJ5fSByZWZlcmVuY2UgdGhlIGVsZW1lbnQgdGhhdCB3YXMgcmlnaHQgY2xpY2tlZFxuXHRcdFx0XHQgKiBAcGFyYW0ge2pRdWVyeX0gZWxlbWVudCB0aGUgRE9NIGVsZW1lbnQgb2YgdGhlIG1lbnUgaXRzZWxmXG5cdFx0XHRcdCAqIEBwYXJhbSB7T2JqZWN0fSBwb3NpdGlvbiB0aGUgeCAmIHkgY29vcmRpbmF0ZXMgb2YgdGhlIG1lbnVcblx0XHRcdFx0ICovXG5cdFx0XHRcdGlmKCFpc19jYWxsYmFjaykgeyB2YWthdGFfY29udGV4dC5odG1sID0gc3RyOyAkLnZha2F0YS5jb250ZXh0Ll90cmlnZ2VyKFwicGFyc2VcIik7IH1cblx0XHRcdFx0cmV0dXJuIHN0ci5sZW5ndGggPiAxMCA/IHN0ciA6IGZhbHNlO1xuXHRcdFx0fSxcblx0XHRcdF9zaG93X3N1Ym1lbnUgOiBmdW5jdGlvbiAobykge1xuXHRcdFx0XHRvID0gJChvKTtcblx0XHRcdFx0aWYoIW8ubGVuZ3RoIHx8ICFvLmNoaWxkcmVuKFwidWxcIikubGVuZ3RoKSB7IHJldHVybjsgfVxuXHRcdFx0XHR2YXIgZSA9IG8uY2hpbGRyZW4oXCJ1bFwiKSxcblx0XHRcdFx0XHR4bCA9IG8ub2Zmc2V0KCkubGVmdCxcblx0XHRcdFx0XHR4ID0geGwgKyBvLm91dGVyV2lkdGgoKSxcblx0XHRcdFx0XHR5ID0gby5vZmZzZXQoKS50b3AsXG5cdFx0XHRcdFx0dyA9IGUud2lkdGgoKSxcblx0XHRcdFx0XHRoID0gZS5oZWlnaHQoKSxcblx0XHRcdFx0XHRkdyA9ICQod2luZG93KS53aWR0aCgpICsgJCh3aW5kb3cpLnNjcm9sbExlZnQoKSxcblx0XHRcdFx0XHRkaCA9ICQod2luZG93KS5oZWlnaHQoKSArICQod2luZG93KS5zY3JvbGxUb3AoKTtcblx0XHRcdFx0Ly8g0LzQvtC20LUg0LTQsCDRgdC1INGB0L/QtdGB0YLQuCDQtSDQtdC00L3QsCDQv9GA0L7QstC10YDQutCwIC0g0LTQsNC70Lgg0L3Rj9C80LAg0L3Rj9C60L7QuSDQvtGCINC60LvQsNGB0L7QstC10YLQtSDQstC10YfQtSDQvdCw0LPQvtGA0LVcblx0XHRcdFx0aWYocmlnaHRfdG9fbGVmdCkge1xuXHRcdFx0XHRcdG9beCAtICh3ICsgMTAgKyBvLm91dGVyV2lkdGgoKSkgPCAwID8gXCJhZGRDbGFzc1wiIDogXCJyZW1vdmVDbGFzc1wiXShcInZha2F0YS1jb250ZXh0LWxlZnRcIik7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0b1t4ICsgdyA+IGR3ICAmJiB4bCA+IGR3IC0geCA/IFwiYWRkQ2xhc3NcIiA6IFwicmVtb3ZlQ2xhc3NcIl0oXCJ2YWthdGEtY29udGV4dC1yaWdodFwiKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZih5ICsgaCArIDEwID4gZGgpIHtcblx0XHRcdFx0XHRlLmNzcyhcImJvdHRvbVwiLFwiLTFweFwiKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vaWYgZG9lcyBub3QgZml0IC0gc3RpY2sgaXQgdG8gdGhlIHNpZGVcblx0XHRcdFx0aWYgKG8uaGFzQ2xhc3MoJ3Zha2F0YS1jb250ZXh0LXJpZ2h0JykpIHtcblx0XHRcdFx0XHRpZiAoeGwgPCB3KSB7XG5cdFx0XHRcdFx0XHRlLmNzcyhcIm1hcmdpbi1yaWdodFwiLCB4bCAtIHcpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRpZiAoZHcgLSB4IDwgdykge1xuXHRcdFx0XHRcdFx0ZS5jc3MoXCJtYXJnaW4tbGVmdFwiLCBkdyAtIHggLSB3KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRlLnNob3coKTtcblx0XHRcdH0sXG5cdFx0XHRzaG93IDogZnVuY3Rpb24gKHJlZmVyZW5jZSwgcG9zaXRpb24sIGRhdGEpIHtcblx0XHRcdFx0dmFyIG8sIGUsIHgsIHksIHcsIGgsIGR3LCBkaCwgY29uZCA9IHRydWU7XG5cdFx0XHRcdGlmKHZha2F0YV9jb250ZXh0LmVsZW1lbnQgJiYgdmFrYXRhX2NvbnRleHQuZWxlbWVudC5sZW5ndGgpIHtcblx0XHRcdFx0XHR2YWthdGFfY29udGV4dC5lbGVtZW50LndpZHRoKCcnKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRzd2l0Y2goY29uZCkge1xuXHRcdFx0XHRcdGNhc2UgKCFwb3NpdGlvbiAmJiAhcmVmZXJlbmNlKTpcblx0XHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0XHRjYXNlICghIXBvc2l0aW9uICYmICEhcmVmZXJlbmNlKTpcblx0XHRcdFx0XHRcdHZha2F0YV9jb250ZXh0LnJlZmVyZW5jZVx0PSByZWZlcmVuY2U7XG5cdFx0XHRcdFx0XHR2YWthdGFfY29udGV4dC5wb3NpdGlvbl94XHQ9IHBvc2l0aW9uLng7XG5cdFx0XHRcdFx0XHR2YWthdGFfY29udGV4dC5wb3NpdGlvbl95XHQ9IHBvc2l0aW9uLnk7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRjYXNlICghcG9zaXRpb24gJiYgISFyZWZlcmVuY2UpOlxuXHRcdFx0XHRcdFx0dmFrYXRhX2NvbnRleHQucmVmZXJlbmNlXHQ9IHJlZmVyZW5jZTtcblx0XHRcdFx0XHRcdG8gPSByZWZlcmVuY2Uub2Zmc2V0KCk7XG5cdFx0XHRcdFx0XHR2YWthdGFfY29udGV4dC5wb3NpdGlvbl94XHQ9IG8ubGVmdCArIHJlZmVyZW5jZS5vdXRlckhlaWdodCgpO1xuXHRcdFx0XHRcdFx0dmFrYXRhX2NvbnRleHQucG9zaXRpb25feVx0PSBvLnRvcDtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdGNhc2UgKCEhcG9zaXRpb24gJiYgIXJlZmVyZW5jZSk6XG5cdFx0XHRcdFx0XHR2YWthdGFfY29udGV4dC5wb3NpdGlvbl94XHQ9IHBvc2l0aW9uLng7XG5cdFx0XHRcdFx0XHR2YWthdGFfY29udGV4dC5wb3NpdGlvbl95XHQ9IHBvc2l0aW9uLnk7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0XHRpZighIXJlZmVyZW5jZSAmJiAhZGF0YSAmJiAkKHJlZmVyZW5jZSkuZGF0YSgndmFrYXRhX2NvbnRleHRtZW51JykpIHtcblx0XHRcdFx0XHRkYXRhID0gJChyZWZlcmVuY2UpLmRhdGEoJ3Zha2F0YV9jb250ZXh0bWVudScpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmKCQudmFrYXRhLmNvbnRleHQuX3BhcnNlKGRhdGEpKSB7XG5cdFx0XHRcdFx0dmFrYXRhX2NvbnRleHQuZWxlbWVudC5odG1sKHZha2F0YV9jb250ZXh0Lmh0bWwpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmKHZha2F0YV9jb250ZXh0Lml0ZW1zLmxlbmd0aCkge1xuXHRcdFx0XHRcdHZha2F0YV9jb250ZXh0LmVsZW1lbnQuYXBwZW5kVG8oXCJib2R5XCIpO1xuXHRcdFx0XHRcdGUgPSB2YWthdGFfY29udGV4dC5lbGVtZW50O1xuXHRcdFx0XHRcdHggPSB2YWthdGFfY29udGV4dC5wb3NpdGlvbl94O1xuXHRcdFx0XHRcdHkgPSB2YWthdGFfY29udGV4dC5wb3NpdGlvbl95O1xuXHRcdFx0XHRcdHcgPSBlLndpZHRoKCk7XG5cdFx0XHRcdFx0aCA9IGUuaGVpZ2h0KCk7XG5cdFx0XHRcdFx0ZHcgPSAkKHdpbmRvdykud2lkdGgoKSArICQod2luZG93KS5zY3JvbGxMZWZ0KCk7XG5cdFx0XHRcdFx0ZGggPSAkKHdpbmRvdykuaGVpZ2h0KCkgKyAkKHdpbmRvdykuc2Nyb2xsVG9wKCk7XG5cdFx0XHRcdFx0aWYocmlnaHRfdG9fbGVmdCkge1xuXHRcdFx0XHRcdFx0eCAtPSAoZS5vdXRlcldpZHRoKCkgLSAkKHJlZmVyZW5jZSkub3V0ZXJXaWR0aCgpKTtcblx0XHRcdFx0XHRcdGlmKHggPCAkKHdpbmRvdykuc2Nyb2xsTGVmdCgpICsgMjApIHtcblx0XHRcdFx0XHRcdFx0eCA9ICQod2luZG93KS5zY3JvbGxMZWZ0KCkgKyAyMDtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYoeCArIHcgKyAyMCA+IGR3KSB7XG5cdFx0XHRcdFx0XHR4ID0gZHcgLSAodyArIDIwKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYoeSArIGggKyAyMCA+IGRoKSB7XG5cdFx0XHRcdFx0XHR5ID0gZGggLSAoaCArIDIwKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR2YWthdGFfY29udGV4dC5lbGVtZW50XG5cdFx0XHRcdFx0XHQuY3NzKHsgXCJsZWZ0XCIgOiB4LCBcInRvcFwiIDogeSB9KVxuXHRcdFx0XHRcdFx0LnNob3coKVxuXHRcdFx0XHRcdFx0LmZpbmQoJ2EnKS5maXJzdCgpLmZvY3VzKCkucGFyZW50KCkuYWRkQ2xhc3MoXCJ2YWthdGEtY29udGV4dC1ob3ZlclwiKTtcblx0XHRcdFx0XHR2YWthdGFfY29udGV4dC5pc192aXNpYmxlID0gdHJ1ZTtcblx0XHRcdFx0XHQvKipcblx0XHRcdFx0XHQgKiB0cmlnZ2VyZWQgb24gdGhlIGRvY3VtZW50IHdoZW4gdGhlIGNvbnRleHRtZW51IGlzIHNob3duXG5cdFx0XHRcdFx0ICogQGV2ZW50XG5cdFx0XHRcdFx0ICogQHBsdWdpbiBjb250ZXh0bWVudVxuXHRcdFx0XHRcdCAqIEBuYW1lIGNvbnRleHRfc2hvdy52YWthdGFcblx0XHRcdFx0XHQgKiBAcGFyYW0ge2pRdWVyeX0gcmVmZXJlbmNlIHRoZSBlbGVtZW50IHRoYXQgd2FzIHJpZ2h0IGNsaWNrZWRcblx0XHRcdFx0XHQgKiBAcGFyYW0ge2pRdWVyeX0gZWxlbWVudCB0aGUgRE9NIGVsZW1lbnQgb2YgdGhlIG1lbnUgaXRzZWxmXG5cdFx0XHRcdFx0ICogQHBhcmFtIHtPYmplY3R9IHBvc2l0aW9uIHRoZSB4ICYgeSBjb29yZGluYXRlcyBvZiB0aGUgbWVudVxuXHRcdFx0XHRcdCAqL1xuXHRcdFx0XHRcdCQudmFrYXRhLmNvbnRleHQuX3RyaWdnZXIoXCJzaG93XCIpO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0aGlkZSA6IGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0aWYodmFrYXRhX2NvbnRleHQuaXNfdmlzaWJsZSkge1xuXHRcdFx0XHRcdHZha2F0YV9jb250ZXh0LmVsZW1lbnQuaGlkZSgpLmZpbmQoXCJ1bFwiKS5oaWRlKCkuZW5kKCkuZmluZCgnOmZvY3VzJykuYmx1cigpLmVuZCgpLmRldGFjaCgpO1xuXHRcdFx0XHRcdHZha2F0YV9jb250ZXh0LmlzX3Zpc2libGUgPSBmYWxzZTtcblx0XHRcdFx0XHQvKipcblx0XHRcdFx0XHQgKiB0cmlnZ2VyZWQgb24gdGhlIGRvY3VtZW50IHdoZW4gdGhlIGNvbnRleHRtZW51IGlzIGhpZGRlblxuXHRcdFx0XHRcdCAqIEBldmVudFxuXHRcdFx0XHRcdCAqIEBwbHVnaW4gY29udGV4dG1lbnVcblx0XHRcdFx0XHQgKiBAbmFtZSBjb250ZXh0X2hpZGUudmFrYXRhXG5cdFx0XHRcdFx0ICogQHBhcmFtIHtqUXVlcnl9IHJlZmVyZW5jZSB0aGUgZWxlbWVudCB0aGF0IHdhcyByaWdodCBjbGlja2VkXG5cdFx0XHRcdFx0ICogQHBhcmFtIHtqUXVlcnl9IGVsZW1lbnQgdGhlIERPTSBlbGVtZW50IG9mIHRoZSBtZW51IGl0c2VsZlxuXHRcdFx0XHRcdCAqIEBwYXJhbSB7T2JqZWN0fSBwb3NpdGlvbiB0aGUgeCAmIHkgY29vcmRpbmF0ZXMgb2YgdGhlIG1lbnVcblx0XHRcdFx0XHQgKi9cblx0XHRcdFx0XHQkLnZha2F0YS5jb250ZXh0Ll90cmlnZ2VyKFwiaGlkZVwiKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH07XG5cdFx0JChmdW5jdGlvbiAoKSB7XG5cdFx0XHRyaWdodF90b19sZWZ0ID0gJChcImJvZHlcIikuY3NzKFwiZGlyZWN0aW9uXCIpID09PSBcInJ0bFwiO1xuXHRcdFx0dmFyIHRvID0gZmFsc2U7XG5cblx0XHRcdHZha2F0YV9jb250ZXh0LmVsZW1lbnQgPSAkKFwiPHVsIGNsYXNzPSd2YWthdGEtY29udGV4dCc+PC91bD5cIik7XG5cdFx0XHR2YWthdGFfY29udGV4dC5lbGVtZW50XG5cdFx0XHRcdC5vbihcIm1vdXNlZW50ZXJcIiwgXCJsaVwiLCBmdW5jdGlvbiAoZSkge1xuXHRcdFx0XHRcdGUuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG5cblx0XHRcdFx0XHRpZigkLmNvbnRhaW5zKHRoaXMsIGUucmVsYXRlZFRhcmdldCkpIHtcblx0XHRcdFx0XHRcdC8vINC/0YDQtdC80LDRhdC90LDRgtC+INC30LDRgNCw0LTQuCBkZWxlZ2F0ZSBtb3VzZWxlYXZlINC/0L4t0LTQvtC70YNcblx0XHRcdFx0XHRcdC8vICQodGhpcykuZmluZChcIi52YWthdGEtY29udGV4dC1ob3ZlclwiKS5yZW1vdmVDbGFzcyhcInZha2F0YS1jb250ZXh0LWhvdmVyXCIpO1xuXHRcdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGlmKHRvKSB7IGNsZWFyVGltZW91dCh0byk7IH1cblx0XHRcdFx0XHR2YWthdGFfY29udGV4dC5lbGVtZW50LmZpbmQoXCIudmFrYXRhLWNvbnRleHQtaG92ZXJcIikucmVtb3ZlQ2xhc3MoXCJ2YWthdGEtY29udGV4dC1ob3ZlclwiKS5lbmQoKTtcblxuXHRcdFx0XHRcdCQodGhpcylcblx0XHRcdFx0XHRcdC5zaWJsaW5ncygpLmZpbmQoXCJ1bFwiKS5oaWRlKCkuZW5kKCkuZW5kKClcblx0XHRcdFx0XHRcdC5wYXJlbnRzVW50aWwoXCIudmFrYXRhLWNvbnRleHRcIiwgXCJsaVwiKS5hZGRCYWNrKCkuYWRkQ2xhc3MoXCJ2YWthdGEtY29udGV4dC1ob3ZlclwiKTtcblx0XHRcdFx0XHQkLnZha2F0YS5jb250ZXh0Ll9zaG93X3N1Ym1lbnUodGhpcyk7XG5cdFx0XHRcdH0pXG5cdFx0XHRcdC8vINGC0LXRgdGC0L7QstC+IC0g0LTQsNC70Lgg0L3QtSDQvdCw0YLQvtCy0LDRgNCy0LA/XG5cdFx0XHRcdC5vbihcIm1vdXNlbGVhdmVcIiwgXCJsaVwiLCBmdW5jdGlvbiAoZSkge1xuXHRcdFx0XHRcdGlmKCQuY29udGFpbnModGhpcywgZS5yZWxhdGVkVGFyZ2V0KSkgeyByZXR1cm47IH1cblx0XHRcdFx0XHQkKHRoaXMpLmZpbmQoXCIudmFrYXRhLWNvbnRleHQtaG92ZXJcIikuYWRkQmFjaygpLnJlbW92ZUNsYXNzKFwidmFrYXRhLWNvbnRleHQtaG92ZXJcIik7XG5cdFx0XHRcdH0pXG5cdFx0XHRcdC5vbihcIm1vdXNlbGVhdmVcIiwgZnVuY3Rpb24gKGUpIHtcblx0XHRcdFx0XHQkKHRoaXMpLmZpbmQoXCIudmFrYXRhLWNvbnRleHQtaG92ZXJcIikucmVtb3ZlQ2xhc3MoXCJ2YWthdGEtY29udGV4dC1ob3ZlclwiKTtcblx0XHRcdFx0XHRpZigkLnZha2F0YS5jb250ZXh0LnNldHRpbmdzLmhpZGVfb25tb3VzZWxlYXZlKSB7XG5cdFx0XHRcdFx0XHR0byA9IHNldFRpbWVvdXQoXG5cdFx0XHRcdFx0XHRcdChmdW5jdGlvbiAodCkge1xuXHRcdFx0XHRcdFx0XHRcdHJldHVybiBmdW5jdGlvbiAoKSB7ICQudmFrYXRhLmNvbnRleHQuaGlkZSgpOyB9O1xuXHRcdFx0XHRcdFx0XHR9KHRoaXMpKSwgJC52YWthdGEuY29udGV4dC5zZXR0aW5ncy5oaWRlX29ubW91c2VsZWF2ZSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KVxuXHRcdFx0XHQub24oXCJjbGlja1wiLCBcImFcIiwgZnVuY3Rpb24gKGUpIHtcblx0XHRcdFx0XHRlLnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHRcdC8vfSlcblx0XHRcdFx0Ly8ub24oXCJtb3VzZXVwXCIsIFwiYVwiLCBmdW5jdGlvbiAoZSkge1xuXHRcdFx0XHRcdGlmKCEkKHRoaXMpLmJsdXIoKS5wYXJlbnQoKS5oYXNDbGFzcyhcInZha2F0YS1jb250ZXh0LWRpc2FibGVkXCIpICYmICQudmFrYXRhLmNvbnRleHQuX2V4ZWN1dGUoJCh0aGlzKS5hdHRyKFwicmVsXCIpKSAhPT0gZmFsc2UpIHtcblx0XHRcdFx0XHRcdCQudmFrYXRhLmNvbnRleHQuaGlkZSgpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSlcblx0XHRcdFx0Lm9uKCdrZXlkb3duJywgJ2EnLCBmdW5jdGlvbiAoZSkge1xuXHRcdFx0XHRcdFx0dmFyIG8gPSBudWxsO1xuXHRcdFx0XHRcdFx0c3dpdGNoKGUud2hpY2gpIHtcblx0XHRcdFx0XHRcdFx0Y2FzZSAxMzpcblx0XHRcdFx0XHRcdFx0Y2FzZSAzMjpcblx0XHRcdFx0XHRcdFx0XHRlLnR5cGUgPSBcImNsaWNrXCI7XG5cdFx0XHRcdFx0XHRcdFx0ZS5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0XHRcdFx0XHRcdCQoZS5jdXJyZW50VGFyZ2V0KS50cmlnZ2VyKGUpO1xuXHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0XHRjYXNlIDM3OlxuXHRcdFx0XHRcdFx0XHRcdGlmKHZha2F0YV9jb250ZXh0LmlzX3Zpc2libGUpIHtcblx0XHRcdFx0XHRcdFx0XHRcdHZha2F0YV9jb250ZXh0LmVsZW1lbnQuZmluZChcIi52YWthdGEtY29udGV4dC1ob3ZlclwiKS5sYXN0KCkuY2xvc2VzdChcImxpXCIpLmZpcnN0KCkuZmluZChcInVsXCIpLmhpZGUoKS5maW5kKFwiLnZha2F0YS1jb250ZXh0LWhvdmVyXCIpLnJlbW92ZUNsYXNzKFwidmFrYXRhLWNvbnRleHQtaG92ZXJcIikuZW5kKCkuZW5kKCkuY2hpbGRyZW4oJ2EnKS5mb2N1cygpO1xuXHRcdFx0XHRcdFx0XHRcdFx0ZS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcblx0XHRcdFx0XHRcdFx0XHRcdGUucHJldmVudERlZmF1bHQoKTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRcdGNhc2UgMzg6XG5cdFx0XHRcdFx0XHRcdFx0aWYodmFrYXRhX2NvbnRleHQuaXNfdmlzaWJsZSkge1xuXHRcdFx0XHRcdFx0XHRcdFx0byA9IHZha2F0YV9jb250ZXh0LmVsZW1lbnQuZmluZChcInVsOnZpc2libGVcIikuYWRkQmFjaygpLmxhc3QoKS5jaGlsZHJlbihcIi52YWthdGEtY29udGV4dC1ob3ZlclwiKS5yZW1vdmVDbGFzcyhcInZha2F0YS1jb250ZXh0LWhvdmVyXCIpLnByZXZBbGwoXCJsaTpub3QoLnZha2F0YS1jb250ZXh0LXNlcGFyYXRvcilcIikuZmlyc3QoKTtcblx0XHRcdFx0XHRcdFx0XHRcdGlmKCFvLmxlbmd0aCkgeyBvID0gdmFrYXRhX2NvbnRleHQuZWxlbWVudC5maW5kKFwidWw6dmlzaWJsZVwiKS5hZGRCYWNrKCkubGFzdCgpLmNoaWxkcmVuKFwibGk6bm90KC52YWthdGEtY29udGV4dC1zZXBhcmF0b3IpXCIpLmxhc3QoKTsgfVxuXHRcdFx0XHRcdFx0XHRcdFx0by5hZGRDbGFzcyhcInZha2F0YS1jb250ZXh0LWhvdmVyXCIpLmNoaWxkcmVuKCdhJykuZm9jdXMoKTtcblx0XHRcdFx0XHRcdFx0XHRcdGUuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG5cdFx0XHRcdFx0XHRcdFx0XHRlLnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0XHRjYXNlIDM5OlxuXHRcdFx0XHRcdFx0XHRcdGlmKHZha2F0YV9jb250ZXh0LmlzX3Zpc2libGUpIHtcblx0XHRcdFx0XHRcdFx0XHRcdHZha2F0YV9jb250ZXh0LmVsZW1lbnQuZmluZChcIi52YWthdGEtY29udGV4dC1ob3ZlclwiKS5sYXN0KCkuY2hpbGRyZW4oXCJ1bFwiKS5zaG93KCkuY2hpbGRyZW4oXCJsaTpub3QoLnZha2F0YS1jb250ZXh0LXNlcGFyYXRvcilcIikucmVtb3ZlQ2xhc3MoXCJ2YWthdGEtY29udGV4dC1ob3ZlclwiKS5maXJzdCgpLmFkZENsYXNzKFwidmFrYXRhLWNvbnRleHQtaG92ZXJcIikuY2hpbGRyZW4oJ2EnKS5mb2N1cygpO1xuXHRcdFx0XHRcdFx0XHRcdFx0ZS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcblx0XHRcdFx0XHRcdFx0XHRcdGUucHJldmVudERlZmF1bHQoKTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRcdGNhc2UgNDA6XG5cdFx0XHRcdFx0XHRcdFx0aWYodmFrYXRhX2NvbnRleHQuaXNfdmlzaWJsZSkge1xuXHRcdFx0XHRcdFx0XHRcdFx0byA9IHZha2F0YV9jb250ZXh0LmVsZW1lbnQuZmluZChcInVsOnZpc2libGVcIikuYWRkQmFjaygpLmxhc3QoKS5jaGlsZHJlbihcIi52YWthdGEtY29udGV4dC1ob3ZlclwiKS5yZW1vdmVDbGFzcyhcInZha2F0YS1jb250ZXh0LWhvdmVyXCIpLm5leHRBbGwoXCJsaTpub3QoLnZha2F0YS1jb250ZXh0LXNlcGFyYXRvcilcIikuZmlyc3QoKTtcblx0XHRcdFx0XHRcdFx0XHRcdGlmKCFvLmxlbmd0aCkgeyBvID0gdmFrYXRhX2NvbnRleHQuZWxlbWVudC5maW5kKFwidWw6dmlzaWJsZVwiKS5hZGRCYWNrKCkubGFzdCgpLmNoaWxkcmVuKFwibGk6bm90KC52YWthdGEtY29udGV4dC1zZXBhcmF0b3IpXCIpLmZpcnN0KCk7IH1cblx0XHRcdFx0XHRcdFx0XHRcdG8uYWRkQ2xhc3MoXCJ2YWthdGEtY29udGV4dC1ob3ZlclwiKS5jaGlsZHJlbignYScpLmZvY3VzKCk7XG5cdFx0XHRcdFx0XHRcdFx0XHRlLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xuXHRcdFx0XHRcdFx0XHRcdFx0ZS5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdFx0Y2FzZSAyNzpcblx0XHRcdFx0XHRcdFx0XHQkLnZha2F0YS5jb250ZXh0LmhpZGUoKTtcblx0XHRcdFx0XHRcdFx0XHRlLnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdFx0XHRcdFx0Ly9jb25zb2xlLmxvZyhlLndoaWNoKTtcblx0XHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9KVxuXHRcdFx0XHQub24oJ2tleWRvd24nLCBmdW5jdGlvbiAoZSkge1xuXHRcdFx0XHRcdGUucHJldmVudERlZmF1bHQoKTtcblx0XHRcdFx0XHR2YXIgYSA9IHZha2F0YV9jb250ZXh0LmVsZW1lbnQuZmluZCgnLnZha2F0YS1jb250ZXh0bWVudS1zaG9ydGN1dC0nICsgZS53aGljaCkucGFyZW50KCk7XG5cdFx0XHRcdFx0aWYoYS5wYXJlbnQoKS5ub3QoJy52YWthdGEtY29udGV4dC1kaXNhYmxlZCcpKSB7XG5cdFx0XHRcdFx0XHRhLmNsaWNrKCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KTtcblxuXHRcdFx0JChkb2N1bWVudClcblx0XHRcdFx0Lm9uKFwibW91c2Vkb3duLnZha2F0YS5qc3RyZWVcIiwgZnVuY3Rpb24gKGUpIHtcblx0XHRcdFx0XHRpZih2YWthdGFfY29udGV4dC5pc192aXNpYmxlICYmICEkLmNvbnRhaW5zKHZha2F0YV9jb250ZXh0LmVsZW1lbnRbMF0sIGUudGFyZ2V0KSkge1xuXHRcdFx0XHRcdFx0JC52YWthdGEuY29udGV4dC5oaWRlKCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KVxuXHRcdFx0XHQub24oXCJjb250ZXh0X3Nob3cudmFrYXRhLmpzdHJlZVwiLCBmdW5jdGlvbiAoZSwgZGF0YSkge1xuXHRcdFx0XHRcdHZha2F0YV9jb250ZXh0LmVsZW1lbnQuZmluZChcImxpOmhhcyh1bClcIikuY2hpbGRyZW4oXCJhXCIpLmFkZENsYXNzKFwidmFrYXRhLWNvbnRleHQtcGFyZW50XCIpO1xuXHRcdFx0XHRcdGlmKHJpZ2h0X3RvX2xlZnQpIHtcblx0XHRcdFx0XHRcdHZha2F0YV9jb250ZXh0LmVsZW1lbnQuYWRkQ2xhc3MoXCJ2YWthdGEtY29udGV4dC1ydGxcIikuY3NzKFwiZGlyZWN0aW9uXCIsIFwicnRsXCIpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHQvLyBhbHNvIGFwcGx5IGEgUlRMIGNsYXNzP1xuXHRcdFx0XHRcdHZha2F0YV9jb250ZXh0LmVsZW1lbnQuZmluZChcInVsXCIpLmhpZGUoKS5lbmQoKTtcblx0XHRcdFx0fSk7XG5cdFx0fSk7XG5cdH0oJCkpO1xuXHQvLyAkLmpzdHJlZS5kZWZhdWx0cy5wbHVnaW5zLnB1c2goXCJjb250ZXh0bWVudVwiKTtcblxuXG4vKipcbiAqICMjIyBEcmFnJ24nZHJvcCBwbHVnaW5cbiAqXG4gKiBFbmFibGVzIGRyYWdnaW5nIGFuZCBkcm9wcGluZyBvZiBub2RlcyBpbiB0aGUgdHJlZSwgcmVzdWx0aW5nIGluIGEgbW92ZSBvciBjb3B5IG9wZXJhdGlvbnMuXG4gKi9cblxuXHQvKipcblx0ICogc3RvcmVzIGFsbCBkZWZhdWx0cyBmb3IgdGhlIGRyYWcnbidkcm9wIHBsdWdpblxuXHQgKiBAbmFtZSAkLmpzdHJlZS5kZWZhdWx0cy5kbmRcblx0ICogQHBsdWdpbiBkbmRcblx0ICovXG5cdCQuanN0cmVlLmRlZmF1bHRzLmRuZCA9IHtcblx0XHQvKipcblx0XHQgKiBhIGJvb2xlYW4gaW5kaWNhdGluZyBpZiBhIGNvcHkgc2hvdWxkIGJlIHBvc3NpYmxlIHdoaWxlIGRyYWdnaW5nIChieSBwcmVzc2ludCB0aGUgbWV0YSBrZXkgb3IgQ3RybCkuIERlZmF1bHRzIHRvIGB0cnVlYC5cblx0XHQgKiBAbmFtZSAkLmpzdHJlZS5kZWZhdWx0cy5kbmQuY29weVxuXHRcdCAqIEBwbHVnaW4gZG5kXG5cdFx0ICovXG5cdFx0Y29weSA6IHRydWUsXG5cdFx0LyoqXG5cdFx0ICogYSBudW1iZXIgaW5kaWNhdGluZyBob3cgbG9uZyBhIG5vZGUgc2hvdWxkIHJlbWFpbiBob3ZlcmVkIHdoaWxlIGRyYWdnaW5nIHRvIGJlIG9wZW5lZC4gRGVmYXVsdHMgdG8gYDUwMGAuXG5cdFx0ICogQG5hbWUgJC5qc3RyZWUuZGVmYXVsdHMuZG5kLm9wZW5fdGltZW91dFxuXHRcdCAqIEBwbHVnaW4gZG5kXG5cdFx0ICovXG5cdFx0b3Blbl90aW1lb3V0IDogNTAwLFxuXHRcdC8qKlxuXHRcdCAqIGEgZnVuY3Rpb24gaW52b2tlZCBlYWNoIHRpbWUgYSBub2RlIGlzIGFib3V0IHRvIGJlIGRyYWdnZWQsIGludm9rZWQgaW4gdGhlIHRyZWUncyBzY29wZSBhbmQgcmVjZWl2ZXMgdGhlIG5vZGVzIGFib3V0IHRvIGJlIGRyYWdnZWQgYXMgYW4gYXJndW1lbnQgKGFycmF5KSBhbmQgdGhlIGV2ZW50IHRoYXQgc3RhcnRlZCB0aGUgZHJhZyAtIHJldHVybiBgZmFsc2VgIHRvIHByZXZlbnQgZHJhZ2dpbmdcblx0XHQgKiBAbmFtZSAkLmpzdHJlZS5kZWZhdWx0cy5kbmQuaXNfZHJhZ2dhYmxlXG5cdFx0ICogQHBsdWdpbiBkbmRcblx0XHQgKi9cblx0XHRpc19kcmFnZ2FibGUgOiB0cnVlLFxuXHRcdC8qKlxuXHRcdCAqIGEgYm9vbGVhbiBpbmRpY2F0aW5nIGlmIGNoZWNrcyBzaG91bGQgY29uc3RhbnRseSBiZSBtYWRlIHdoaWxlIHRoZSB1c2VyIGlzIGRyYWdnaW5nIHRoZSBub2RlIChhcyBvcHBvc2VkIHRvIGNoZWNraW5nIG9ubHkgb24gZHJvcCksIGRlZmF1bHQgaXMgYHRydWVgXG5cdFx0ICogQG5hbWUgJC5qc3RyZWUuZGVmYXVsdHMuZG5kLmNoZWNrX3doaWxlX2RyYWdnaW5nXG5cdFx0ICogQHBsdWdpbiBkbmRcblx0XHQgKi9cblx0XHRjaGVja193aGlsZV9kcmFnZ2luZyA6IHRydWUsXG5cdFx0LyoqXG5cdFx0ICogYSBib29sZWFuIGluZGljYXRpbmcgaWYgbm9kZXMgZnJvbSB0aGlzIHRyZWUgc2hvdWxkIG9ubHkgYmUgY29waWVkIHdpdGggZG5kIChhcyBvcHBvc2VkIHRvIG1vdmVkKSwgZGVmYXVsdCBpcyBgZmFsc2VgXG5cdFx0ICogQG5hbWUgJC5qc3RyZWUuZGVmYXVsdHMuZG5kLmFsd2F5c19jb3B5XG5cdFx0ICogQHBsdWdpbiBkbmRcblx0XHQgKi9cblx0XHRhbHdheXNfY29weSA6IGZhbHNlLFxuXHRcdC8qKlxuXHRcdCAqIHdoZW4gZHJvcHBpbmcgYSBub2RlIFwiaW5zaWRlXCIsIHRoaXMgc2V0dGluZyBpbmRpY2F0ZXMgdGhlIHBvc2l0aW9uIHRoZSBub2RlIHNob3VsZCBnbyB0byAtIGl0IGNhbiBiZSBhbiBpbnRlZ2VyIG9yIGEgc3RyaW5nOiBcImZpcnN0XCIgKHNhbWUgYXMgMCkgb3IgXCJsYXN0XCIsIGRlZmF1bHQgaXMgYDBgXG5cdFx0ICogQG5hbWUgJC5qc3RyZWUuZGVmYXVsdHMuZG5kLmluc2lkZV9wb3Ncblx0XHQgKiBAcGx1Z2luIGRuZFxuXHRcdCAqL1xuXHRcdGluc2lkZV9wb3MgOiAwLFxuXHRcdC8qKlxuXHRcdCAqIHdoZW4gc3RhcnRpbmcgdGhlIGRyYWcgb24gYSBub2RlIHRoYXQgaXMgc2VsZWN0ZWQgdGhpcyBzZXR0aW5nIGNvbnRyb2xzIGlmIGFsbCBzZWxlY3RlZCBub2RlcyBhcmUgZHJhZ2dlZCBvciBvbmx5IHRoZSBzaW5nbGUgbm9kZSwgZGVmYXVsdCBpcyBgdHJ1ZWAsIHdoaWNoIG1lYW5zIGFsbCBzZWxlY3RlZCBub2RlcyBhcmUgZHJhZ2dlZCB3aGVuIHRoZSBkcmFnIGlzIHN0YXJ0ZWQgb24gYSBzZWxlY3RlZCBub2RlXG5cdFx0ICogQG5hbWUgJC5qc3RyZWUuZGVmYXVsdHMuZG5kLmRyYWdfc2VsZWN0aW9uXG5cdFx0ICogQHBsdWdpbiBkbmRcblx0XHQgKi9cblx0XHRkcmFnX3NlbGVjdGlvbiA6IHRydWUsXG5cdFx0LyoqXG5cdFx0ICogY29udHJvbHMgd2hldGhlciBkbmQgd29ya3Mgb24gdG91Y2ggZGV2aWNlcy4gSWYgbGVmdCBhcyBib29sZWFuIHRydWUgZG5kIHdpbGwgd29yayB0aGUgc2FtZSBhcyBpbiBkZXNrdG9wIGJyb3dzZXJzLCB3aGljaCBpbiBzb21lIGNhc2VzIG1heSBpbXBhaXIgc2Nyb2xsaW5nLiBJZiBzZXQgdG8gYm9vbGVhbiBmYWxzZSBkbmQgd2lsbCBub3Qgd29yayBvbiB0b3VjaCBkZXZpY2VzLiBUaGVyZSBpcyBhIHNwZWNpYWwgdGhpcmQgb3B0aW9uIC0gc3RyaW5nIFwic2VsZWN0ZWRcIiB3aGljaCBtZWFucyBvbmx5IHNlbGVjdGVkIG5vZGVzIGNhbiBiZSBkcmFnZ2VkIG9uIHRvdWNoIGRldmljZXMuXG5cdFx0ICogQG5hbWUgJC5qc3RyZWUuZGVmYXVsdHMuZG5kLnRvdWNoXG5cdFx0ICogQHBsdWdpbiBkbmRcblx0XHQgKi9cblx0XHR0b3VjaCA6IHRydWUsXG5cdFx0LyoqXG5cdFx0ICogY29udHJvbHMgd2hldGhlciBpdGVtcyBjYW4gYmUgZHJvcHBlZCBhbnl3aGVyZSBvbiB0aGUgbm9kZSwgbm90IGp1c3Qgb24gdGhlIGFuY2hvciwgYnkgZGVmYXVsdCBvbmx5IHRoZSBub2RlIGFuY2hvciBpcyBhIHZhbGlkIGRyb3AgdGFyZ2V0LiBXb3JrcyBiZXN0IHdpdGggdGhlIHdob2xlcm93IHBsdWdpbi4gSWYgZW5hYmxlZCBvbiBtb2JpbGUgZGVwZW5kaW5nIG9uIHRoZSBpbnRlcmZhY2UgaXQgbWlnaHQgYmUgaGFyZCBmb3IgdGhlIHVzZXIgdG8gY2FuY2VsIHRoZSBkcm9wLCBzaW5jZSB0aGUgd2hvbGUgdHJlZSBjb250YWluZXIgd2lsbCBiZSBhIHZhbGlkIGRyb3AgdGFyZ2V0LlxuXHRcdCAqIEBuYW1lICQuanN0cmVlLmRlZmF1bHRzLmRuZC5sYXJnZV9kcm9wX3RhcmdldFxuXHRcdCAqIEBwbHVnaW4gZG5kXG5cdFx0ICovXG5cdFx0bGFyZ2VfZHJvcF90YXJnZXQgOiBmYWxzZSxcblx0XHQvKipcblx0XHQgKiBjb250cm9scyB3aGV0aGVyIGEgZHJhZyBjYW4gYmUgaW5pdGlhdGVkIGZyb20gYW55IHBhcnQgb2YgdGhlIG5vZGUgYW5kIG5vdCBqdXN0IHRoZSB0ZXh0L2ljb24gcGFydCwgd29ya3MgYmVzdCB3aXRoIHRoZSB3aG9sZXJvdyBwbHVnaW4uIEtlZXAgaW4gbWluZCBpdCBjYW4gY2F1c2UgcHJvYmxlbXMgd2l0aCB0cmVlIHNjcm9sbGluZyBvbiBtb2JpbGUgZGVwZW5kaW5nIG9uIHRoZSBpbnRlcmZhY2UgLSBpbiB0aGF0IGNhc2Ugc2V0IHRoZSB0b3VjaCBvcHRpb24gdG8gXCJzZWxlY3RlZFwiLlxuXHRcdCAqIEBuYW1lICQuanN0cmVlLmRlZmF1bHRzLmRuZC5sYXJnZV9kcmFnX3RhcmdldFxuXHRcdCAqIEBwbHVnaW4gZG5kXG5cdFx0ICovXG5cdFx0bGFyZ2VfZHJhZ190YXJnZXQgOiBmYWxzZSxcblx0XHQvKipcblx0XHQgKiBjb250cm9scyB3aGV0aGVyIHVzZSBIVE1MNSBkbmQgYXBpIGluc3RlYWQgb2YgY2xhc3NpY2FsLiBUaGF0IHdpbGwgYWxsb3cgYmV0dGVyIGludGVncmF0aW9uIG9mIGRuZCBldmVudHMgd2l0aCBvdGhlciBIVE1MNSBjb250cm9scy5cblx0XHQgKiBAcmVmZXJlbmNlIGh0dHA6Ly9jYW5pdXNlLmNvbS8jZmVhdD1kcmFnbmRyb3Bcblx0XHQgKiBAbmFtZSAkLmpzdHJlZS5kZWZhdWx0cy5kbmQudXNlX2h0bWw1XG5cdFx0ICogQHBsdWdpbiBkbmRcblx0XHQgKi9cblx0XHR1c2VfaHRtbDU6IGZhbHNlXG5cdH07XG5cdHZhciBkcmcsIGVsbTtcblx0Ly8gVE9ETzogbm93IGNoZWNrIHdvcmtzIGJ5IGNoZWNraW5nIGZvciBlYWNoIG5vZGUgaW5kaXZpZHVhbGx5LCBob3cgYWJvdXQgbWF4X2NoaWxkcmVuLCB1bmlxdWUsIGV0Yz9cblx0JC5qc3RyZWUucGx1Z2lucy5kbmQgPSBmdW5jdGlvbiAob3B0aW9ucywgcGFyZW50KSB7XG5cdFx0dGhpcy5pbml0ID0gZnVuY3Rpb24gKGVsLCBvcHRpb25zKSB7XG5cdFx0XHRwYXJlbnQuaW5pdC5jYWxsKHRoaXMsIGVsLCBvcHRpb25zKTtcblx0XHRcdHRoaXMuc2V0dGluZ3MuZG5kLnVzZV9odG1sNSA9IHRoaXMuc2V0dGluZ3MuZG5kLnVzZV9odG1sNSAmJiAoJ2RyYWdnYWJsZScgaW4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3BhbicpKTtcblx0XHR9O1xuXHRcdHRoaXMuYmluZCA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdHBhcmVudC5iaW5kLmNhbGwodGhpcyk7XG5cblx0XHRcdHRoaXMuZWxlbWVudFxuXHRcdFx0XHQub24odGhpcy5zZXR0aW5ncy5kbmQudXNlX2h0bWw1ID8gJ2RyYWdzdGFydC5qc3RyZWUnIDogJ21vdXNlZG93bi5qc3RyZWUgdG91Y2hzdGFydC5qc3RyZWUnLCB0aGlzLnNldHRpbmdzLmRuZC5sYXJnZV9kcmFnX3RhcmdldCA/ICcuanN0cmVlLW5vZGUnIDogJy5qc3RyZWUtYW5jaG9yJywgJC5wcm94eShmdW5jdGlvbiAoZSkge1xuXHRcdFx0XHRcdFx0aWYodGhpcy5zZXR0aW5ncy5kbmQubGFyZ2VfZHJhZ190YXJnZXQgJiYgJChlLnRhcmdldCkuY2xvc2VzdCgnLmpzdHJlZS1ub2RlJylbMF0gIT09IGUuY3VycmVudFRhcmdldCkge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGlmKGUudHlwZSA9PT0gXCJ0b3VjaHN0YXJ0XCIgJiYgKCF0aGlzLnNldHRpbmdzLmRuZC50b3VjaCB8fCAodGhpcy5zZXR0aW5ncy5kbmQudG91Y2ggPT09ICdzZWxlY3RlZCcgJiYgISQoZS5jdXJyZW50VGFyZ2V0KS5jbG9zZXN0KCcuanN0cmVlLW5vZGUnKS5jaGlsZHJlbignLmpzdHJlZS1hbmNob3InKS5oYXNDbGFzcygnanN0cmVlLWNsaWNrZWQnKSkpKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0dmFyIG9iaiA9IHRoaXMuZ2V0X25vZGUoZS50YXJnZXQpLFxuXHRcdFx0XHRcdFx0XHRtbHQgPSB0aGlzLmlzX3NlbGVjdGVkKG9iaikgJiYgdGhpcy5zZXR0aW5ncy5kbmQuZHJhZ19zZWxlY3Rpb24gPyB0aGlzLmdldF90b3Bfc2VsZWN0ZWQoKS5sZW5ndGggOiAxLFxuXHRcdFx0XHRcdFx0XHR0eHQgPSAobWx0ID4gMSA/IG1sdCArICcgJyArIHRoaXMuZ2V0X3N0cmluZygnbm9kZXMnKSA6IHRoaXMuZ2V0X3RleHQoZS5jdXJyZW50VGFyZ2V0KSk7XG5cdFx0XHRcdFx0XHRpZih0aGlzLnNldHRpbmdzLmNvcmUuZm9yY2VfdGV4dCkge1xuXHRcdFx0XHRcdFx0XHR0eHQgPSAkLnZha2F0YS5odG1sLmVzY2FwZSh0eHQpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0aWYob2JqICYmIG9iai5pZCAmJiBvYmouaWQgIT09ICQuanN0cmVlLnJvb3QgJiYgKGUud2hpY2ggPT09IDEgfHwgZS50eXBlID09PSBcInRvdWNoc3RhcnRcIiB8fCBlLnR5cGUgPT09IFwiZHJhZ3N0YXJ0XCIpICYmXG5cdFx0XHRcdFx0XHRcdCh0aGlzLnNldHRpbmdzLmRuZC5pc19kcmFnZ2FibGUgPT09IHRydWUgfHwgKCQuaXNGdW5jdGlvbih0aGlzLnNldHRpbmdzLmRuZC5pc19kcmFnZ2FibGUpICYmIHRoaXMuc2V0dGluZ3MuZG5kLmlzX2RyYWdnYWJsZS5jYWxsKHRoaXMsIChtbHQgPiAxID8gdGhpcy5nZXRfdG9wX3NlbGVjdGVkKHRydWUpIDogW29ial0pLCBlKSkpXG5cdFx0XHRcdFx0XHQpIHtcblx0XHRcdFx0XHRcdFx0ZHJnID0geyAnanN0cmVlJyA6IHRydWUsICdvcmlnaW4nIDogdGhpcywgJ29iaicgOiB0aGlzLmdldF9ub2RlKG9iaix0cnVlKSwgJ25vZGVzJyA6IG1sdCA+IDEgPyB0aGlzLmdldF90b3Bfc2VsZWN0ZWQoKSA6IFtvYmouaWRdIH07XG5cdFx0XHRcdFx0XHRcdGVsbSA9IGUuY3VycmVudFRhcmdldDtcblx0XHRcdFx0XHRcdFx0aWYgKHRoaXMuc2V0dGluZ3MuZG5kLnVzZV9odG1sNSkge1xuXHRcdFx0XHRcdFx0XHRcdCQudmFrYXRhLmRuZC5fdHJpZ2dlcignc3RhcnQnLCBlLCB7ICdoZWxwZXInOiAkKCksICdlbGVtZW50JzogZWxtLCAnZGF0YSc6IGRyZyB9KTtcblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHR0aGlzLmVsZW1lbnQudHJpZ2dlcignbW91c2Vkb3duLmpzdHJlZScpO1xuXHRcdFx0XHRcdFx0XHRcdHJldHVybiAkLnZha2F0YS5kbmQuc3RhcnQoZSwgZHJnLCAnPGRpdiBpZD1cImpzdHJlZS1kbmRcIiBjbGFzcz1cImpzdHJlZS0nICsgdGhpcy5nZXRfdGhlbWUoKSArICcganN0cmVlLScgKyB0aGlzLmdldF90aGVtZSgpICsgJy0nICsgdGhpcy5nZXRfdGhlbWVfdmFyaWFudCgpICsgJyAnICsgKCB0aGlzLnNldHRpbmdzLmNvcmUudGhlbWVzLnJlc3BvbnNpdmUgPyAnIGpzdHJlZS1kbmQtcmVzcG9uc2l2ZScgOiAnJyApICsgJ1wiPjxpIGNsYXNzPVwianN0cmVlLWljb24ganN0cmVlLWVyXCI+PC9pPicgKyB0eHQgKyAnPGlucyBjbGFzcz1cImpzdHJlZS1jb3B5XCIgc3R5bGU9XCJkaXNwbGF5Om5vbmU7XCI+KzwvaW5zPjwvZGl2PicpO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSwgdGhpcykpO1xuXHRcdFx0aWYgKHRoaXMuc2V0dGluZ3MuZG5kLnVzZV9odG1sNSkge1xuXHRcdFx0XHR0aGlzLmVsZW1lbnRcblx0XHRcdFx0XHQub24oJ2RyYWdvdmVyLmpzdHJlZScsIGZ1bmN0aW9uIChlKSB7XG5cdFx0XHRcdFx0XHRcdGUucHJldmVudERlZmF1bHQoKTtcblx0XHRcdFx0XHRcdFx0JC52YWthdGEuZG5kLl90cmlnZ2VyKCdtb3ZlJywgZSwgeyAnaGVscGVyJzogJCgpLCAnZWxlbWVudCc6IGVsbSwgJ2RhdGEnOiBkcmcgfSk7XG5cdFx0XHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0XHRcdH0pXG5cdFx0XHRcdFx0Ly8ub24oJ2RyYWdlbnRlci5qc3RyZWUnLCB0aGlzLnNldHRpbmdzLmRuZC5sYXJnZV9kcm9wX3RhcmdldCA/ICcuanN0cmVlLW5vZGUnIDogJy5qc3RyZWUtYW5jaG9yJywgJC5wcm94eShmdW5jdGlvbiAoZSkge1xuXHRcdFx0XHRcdC8vXHRcdGUucHJldmVudERlZmF1bHQoKTtcblx0XHRcdFx0XHQvL1x0XHQkLnZha2F0YS5kbmQuX3RyaWdnZXIoJ21vdmUnLCBlLCB7ICdoZWxwZXInOiAkKCksICdlbGVtZW50JzogZWxtLCAnZGF0YSc6IGRyZyB9KTtcblx0XHRcdFx0XHQvL1x0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdFx0Ly9cdH0sIHRoaXMpKVxuXHRcdFx0XHRcdC5vbignZHJvcC5qc3RyZWUnLCAkLnByb3h5KGZ1bmN0aW9uIChlKSB7XG5cdFx0XHRcdFx0XHRcdGUucHJldmVudERlZmF1bHQoKTtcblx0XHRcdFx0XHRcdFx0JC52YWthdGEuZG5kLl90cmlnZ2VyKCdzdG9wJywgZSwgeyAnaGVscGVyJzogJCgpLCAnZWxlbWVudCc6IGVsbSwgJ2RhdGEnOiBkcmcgfSk7XG5cdFx0XHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0XHRcdH0sIHRoaXMpKTtcblx0XHRcdH1cblx0XHR9O1xuXHRcdHRoaXMucmVkcmF3X25vZGUgPSBmdW5jdGlvbihvYmosIGRlZXAsIGNhbGxiYWNrLCBmb3JjZV9yZW5kZXIpIHtcblx0XHRcdG9iaiA9IHBhcmVudC5yZWRyYXdfbm9kZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHRcdFx0aWYgKG9iaiAmJiB0aGlzLnNldHRpbmdzLmRuZC51c2VfaHRtbDUpIHtcblx0XHRcdFx0aWYgKHRoaXMuc2V0dGluZ3MuZG5kLmxhcmdlX2RyYWdfdGFyZ2V0KSB7XG5cdFx0XHRcdFx0b2JqLnNldEF0dHJpYnV0ZSgnZHJhZ2dhYmxlJywgdHJ1ZSk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dmFyIGksIGosIHRtcCA9IG51bGw7XG5cdFx0XHRcdFx0Zm9yKGkgPSAwLCBqID0gb2JqLmNoaWxkTm9kZXMubGVuZ3RoOyBpIDwgajsgaSsrKSB7XG5cdFx0XHRcdFx0XHRpZihvYmouY2hpbGROb2Rlc1tpXSAmJiBvYmouY2hpbGROb2Rlc1tpXS5jbGFzc05hbWUgJiYgb2JqLmNoaWxkTm9kZXNbaV0uY2xhc3NOYW1lLmluZGV4T2YoXCJqc3RyZWUtYW5jaG9yXCIpICE9PSAtMSkge1xuXHRcdFx0XHRcdFx0XHR0bXAgPSBvYmouY2hpbGROb2Rlc1tpXTtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmKHRtcCkge1xuXHRcdFx0XHRcdFx0dG1wLnNldEF0dHJpYnV0ZSgnZHJhZ2dhYmxlJywgdHJ1ZSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gb2JqO1xuXHRcdH07XG5cdH07XG5cblx0JChmdW5jdGlvbigpIHtcblx0XHQvLyBiaW5kIG9ubHkgb25jZSBmb3IgYWxsIGluc3RhbmNlc1xuXHRcdHZhciBsYXN0bXYgPSBmYWxzZSxcblx0XHRcdGxhc3RlciA9IGZhbHNlLFxuXHRcdFx0bGFzdGV2ID0gZmFsc2UsXG5cdFx0XHRvcGVudG8gPSBmYWxzZSxcblx0XHRcdG1hcmtlciA9ICQoJzxkaXYgaWQ9XCJqc3RyZWUtbWFya2VyXCI+JiMxNjA7PC9kaXY+JykuaGlkZSgpOyAvLy5hcHBlbmRUbygnYm9keScpO1xuXG5cdFx0JChkb2N1bWVudClcblx0XHRcdC5vbignZG5kX3N0YXJ0LnZha2F0YS5qc3RyZWUnLCBmdW5jdGlvbiAoZSwgZGF0YSkge1xuXHRcdFx0XHRsYXN0bXYgPSBmYWxzZTtcblx0XHRcdFx0bGFzdGV2ID0gZmFsc2U7XG5cdFx0XHRcdGlmKCFkYXRhIHx8ICFkYXRhLmRhdGEgfHwgIWRhdGEuZGF0YS5qc3RyZWUpIHsgcmV0dXJuOyB9XG5cdFx0XHRcdG1hcmtlci5hcHBlbmRUbygnYm9keScpOyAvLy5zaG93KCk7XG5cdFx0XHR9KVxuXHRcdFx0Lm9uKCdkbmRfbW92ZS52YWthdGEuanN0cmVlJywgZnVuY3Rpb24gKGUsIGRhdGEpIHtcblx0XHRcdFx0aWYob3BlbnRvKSB7XG5cdFx0XHRcdFx0aWYgKCFkYXRhLmV2ZW50IHx8IGRhdGEuZXZlbnQudHlwZSAhPT0gJ2RyYWdvdmVyJyB8fCBkYXRhLmV2ZW50LnRhcmdldCAhPT0gbGFzdGV2LnRhcmdldCkge1xuXHRcdFx0XHRcdFx0Y2xlYXJUaW1lb3V0KG9wZW50byk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdGlmKCFkYXRhIHx8ICFkYXRhLmRhdGEgfHwgIWRhdGEuZGF0YS5qc3RyZWUpIHsgcmV0dXJuOyB9XG5cblx0XHRcdFx0Ly8gaWYgd2UgYXJlIGhvdmVyaW5nIHRoZSBtYXJrZXIgaW1hZ2UgZG8gbm90aGluZyAoY2FuIGhhcHBlbiBvbiBcImluc2lkZVwiIGRyYWdzKVxuXHRcdFx0XHRpZihkYXRhLmV2ZW50LnRhcmdldC5pZCAmJiBkYXRhLmV2ZW50LnRhcmdldC5pZCA9PT0gJ2pzdHJlZS1tYXJrZXInKSB7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGxhc3RldiA9IGRhdGEuZXZlbnQ7XG5cblx0XHRcdFx0dmFyIGlucyA9ICQuanN0cmVlLnJlZmVyZW5jZShkYXRhLmV2ZW50LnRhcmdldCksXG5cdFx0XHRcdFx0cmVmID0gZmFsc2UsXG5cdFx0XHRcdFx0b2ZmID0gZmFsc2UsXG5cdFx0XHRcdFx0cmVsID0gZmFsc2UsXG5cdFx0XHRcdFx0dG1wLCBsLCB0LCBoLCBwLCBpLCBvLCBvaywgdDEsIHQyLCBvcCwgcHMsIHByLCBpcCwgdG0sIGlzX2NvcHksIHBuO1xuXHRcdFx0XHQvLyBpZiB3ZSBhcmUgb3ZlciBhbiBpbnN0YW5jZVxuXHRcdFx0XHRpZihpbnMgJiYgaW5zLl9kYXRhICYmIGlucy5fZGF0YS5kbmQpIHtcblx0XHRcdFx0XHRtYXJrZXIuYXR0cignY2xhc3MnLCAnanN0cmVlLScgKyBpbnMuZ2V0X3RoZW1lKCkgKyAoIGlucy5zZXR0aW5ncy5jb3JlLnRoZW1lcy5yZXNwb25zaXZlID8gJyBqc3RyZWUtZG5kLXJlc3BvbnNpdmUnIDogJycgKSk7XG5cdFx0XHRcdFx0aXNfY29weSA9IGRhdGEuZGF0YS5vcmlnaW4gJiYgKGRhdGEuZGF0YS5vcmlnaW4uc2V0dGluZ3MuZG5kLmFsd2F5c19jb3B5IHx8IChkYXRhLmRhdGEub3JpZ2luLnNldHRpbmdzLmRuZC5jb3B5ICYmIChkYXRhLmV2ZW50Lm1ldGFLZXkgfHwgZGF0YS5ldmVudC5jdHJsS2V5KSkpO1xuXHRcdFx0XHRcdGRhdGEuaGVscGVyXG5cdFx0XHRcdFx0XHQuY2hpbGRyZW4oKS5hdHRyKCdjbGFzcycsICdqc3RyZWUtJyArIGlucy5nZXRfdGhlbWUoKSArICcganN0cmVlLScgKyBpbnMuZ2V0X3RoZW1lKCkgKyAnLScgKyBpbnMuZ2V0X3RoZW1lX3ZhcmlhbnQoKSArICcgJyArICggaW5zLnNldHRpbmdzLmNvcmUudGhlbWVzLnJlc3BvbnNpdmUgPyAnIGpzdHJlZS1kbmQtcmVzcG9uc2l2ZScgOiAnJyApKVxuXHRcdFx0XHRcdFx0LmZpbmQoJy5qc3RyZWUtY29weScpLmZpcnN0KClbIGlzX2NvcHkgPyAnc2hvdycgOiAnaGlkZScgXSgpO1xuXG5cdFx0XHRcdFx0Ly8gaWYgYXJlIGhvdmVyaW5nIHRoZSBjb250YWluZXIgaXRzZWxmIGFkZCBhIG5ldyByb290IG5vZGVcblx0XHRcdFx0XHQvL2NvbnNvbGUubG9nKGRhdGEuZXZlbnQpO1xuXHRcdFx0XHRcdGlmKCAoZGF0YS5ldmVudC50YXJnZXQgPT09IGlucy5lbGVtZW50WzBdIHx8IGRhdGEuZXZlbnQudGFyZ2V0ID09PSBpbnMuZ2V0X2NvbnRhaW5lcl91bCgpWzBdKSAmJiBpbnMuZ2V0X2NvbnRhaW5lcl91bCgpLmNoaWxkcmVuKCkubGVuZ3RoID09PSAwKSB7XG5cdFx0XHRcdFx0XHRvayA9IHRydWU7XG5cdFx0XHRcdFx0XHRmb3IodDEgPSAwLCB0MiA9IGRhdGEuZGF0YS5ub2Rlcy5sZW5ndGg7IHQxIDwgdDI7IHQxKyspIHtcblx0XHRcdFx0XHRcdFx0b2sgPSBvayAmJiBpbnMuY2hlY2soIChkYXRhLmRhdGEub3JpZ2luICYmIChkYXRhLmRhdGEub3JpZ2luLnNldHRpbmdzLmRuZC5hbHdheXNfY29weSB8fCAoZGF0YS5kYXRhLm9yaWdpbi5zZXR0aW5ncy5kbmQuY29weSAmJiAoZGF0YS5ldmVudC5tZXRhS2V5IHx8IGRhdGEuZXZlbnQuY3RybEtleSkpICkgPyBcImNvcHlfbm9kZVwiIDogXCJtb3ZlX25vZGVcIiksIChkYXRhLmRhdGEub3JpZ2luICYmIGRhdGEuZGF0YS5vcmlnaW4gIT09IGlucyA/IGRhdGEuZGF0YS5vcmlnaW4uZ2V0X25vZGUoZGF0YS5kYXRhLm5vZGVzW3QxXSkgOiBkYXRhLmRhdGEubm9kZXNbdDFdKSwgJC5qc3RyZWUucm9vdCwgJ2xhc3QnLCB7ICdkbmQnIDogdHJ1ZSwgJ3JlZicgOiBpbnMuZ2V0X25vZGUoJC5qc3RyZWUucm9vdCksICdwb3MnIDogJ2knLCAnb3JpZ2luJyA6IGRhdGEuZGF0YS5vcmlnaW4sICdpc19tdWx0aScgOiAoZGF0YS5kYXRhLm9yaWdpbiAmJiBkYXRhLmRhdGEub3JpZ2luICE9PSBpbnMpLCAnaXNfZm9yZWlnbicgOiAoIWRhdGEuZGF0YS5vcmlnaW4pIH0pO1xuXHRcdFx0XHRcdFx0XHRpZighb2spIHsgYnJlYWs7IH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGlmKG9rKSB7XG5cdFx0XHRcdFx0XHRcdGxhc3RtdiA9IHsgJ2lucycgOiBpbnMsICdwYXInIDogJC5qc3RyZWUucm9vdCwgJ3BvcycgOiAnbGFzdCcgfTtcblx0XHRcdFx0XHRcdFx0bWFya2VyLmhpZGUoKTtcblx0XHRcdFx0XHRcdFx0ZGF0YS5oZWxwZXIuZmluZCgnLmpzdHJlZS1pY29uJykuZmlyc3QoKS5yZW1vdmVDbGFzcygnanN0cmVlLWVyJykuYWRkQ2xhc3MoJ2pzdHJlZS1vaycpO1xuXHRcdFx0XHRcdFx0XHRpZiAoZGF0YS5ldmVudC5vcmlnaW5hbEV2ZW50ICYmIGRhdGEuZXZlbnQub3JpZ2luYWxFdmVudC5kYXRhVHJhbnNmZXIpIHtcblx0XHRcdFx0XHRcdFx0XHRkYXRhLmV2ZW50Lm9yaWdpbmFsRXZlbnQuZGF0YVRyYW5zZmVyLmRyb3BFZmZlY3QgPSBpc19jb3B5ID8gJ2NvcHknIDogJ21vdmUnO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0XHQvLyBpZiB3ZSBhcmUgaG92ZXJpbmcgYSB0cmVlIG5vZGVcblx0XHRcdFx0XHRcdHJlZiA9IGlucy5zZXR0aW5ncy5kbmQubGFyZ2VfZHJvcF90YXJnZXQgPyAkKGRhdGEuZXZlbnQudGFyZ2V0KS5jbG9zZXN0KCcuanN0cmVlLW5vZGUnKS5jaGlsZHJlbignLmpzdHJlZS1hbmNob3InKSA6ICQoZGF0YS5ldmVudC50YXJnZXQpLmNsb3Nlc3QoJy5qc3RyZWUtYW5jaG9yJyk7XG5cdFx0XHRcdFx0XHRpZihyZWYgJiYgcmVmLmxlbmd0aCAmJiByZWYucGFyZW50KCkuaXMoJy5qc3RyZWUtY2xvc2VkLCAuanN0cmVlLW9wZW4sIC5qc3RyZWUtbGVhZicpKSB7XG5cdFx0XHRcdFx0XHRcdG9mZiA9IHJlZi5vZmZzZXQoKTtcblx0XHRcdFx0XHRcdFx0cmVsID0gKGRhdGEuZXZlbnQucGFnZVkgIT09IHVuZGVmaW5lZCA/IGRhdGEuZXZlbnQucGFnZVkgOiBkYXRhLmV2ZW50Lm9yaWdpbmFsRXZlbnQucGFnZVkpIC0gb2ZmLnRvcDtcblx0XHRcdFx0XHRcdFx0aCA9IHJlZi5vdXRlckhlaWdodCgpO1xuXHRcdFx0XHRcdFx0XHRpZihyZWwgPCBoIC8gMykge1xuXHRcdFx0XHRcdFx0XHRcdG8gPSBbJ2InLCAnaScsICdhJ107XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0ZWxzZSBpZihyZWwgPiBoIC0gaCAvIDMpIHtcblx0XHRcdFx0XHRcdFx0XHRvID0gWydhJywgJ2knLCAnYiddO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdG8gPSByZWwgPiBoIC8gMiA/IFsnaScsICdhJywgJ2InXSA6IFsnaScsICdiJywgJ2EnXTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHQkLmVhY2gobywgZnVuY3Rpb24gKGosIHYpIHtcblx0XHRcdFx0XHRcdFx0XHRzd2l0Y2godikge1xuXHRcdFx0XHRcdFx0XHRcdFx0Y2FzZSAnYic6XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGwgPSBvZmYubGVmdCAtIDY7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHQgPSBvZmYudG9wO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRwID0gaW5zLmdldF9wYXJlbnQocmVmKTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0aSA9IHJlZi5wYXJlbnQoKS5pbmRleCgpO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdFx0XHRcdGNhc2UgJ2knOlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpcCA9IGlucy5zZXR0aW5ncy5kbmQuaW5zaWRlX3Bvcztcblx0XHRcdFx0XHRcdFx0XHRcdFx0dG0gPSBpbnMuZ2V0X25vZGUocmVmLnBhcmVudCgpKTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0bCA9IG9mZi5sZWZ0IC0gMjtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dCA9IG9mZi50b3AgKyBoIC8gMiArIDE7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHAgPSB0bS5pZDtcblx0XHRcdFx0XHRcdFx0XHRcdFx0aSA9IGlwID09PSAnZmlyc3QnID8gMCA6IChpcCA9PT0gJ2xhc3QnID8gdG0uY2hpbGRyZW4ubGVuZ3RoIDogTWF0aC5taW4oaXAsIHRtLmNoaWxkcmVuLmxlbmd0aCkpO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdFx0XHRcdGNhc2UgJ2EnOlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRsID0gb2ZmLmxlZnQgLSA2O1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0ID0gb2ZmLnRvcCArIGg7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHAgPSBpbnMuZ2V0X3BhcmVudChyZWYpO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRpID0gcmVmLnBhcmVudCgpLmluZGV4KCkgKyAxO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0b2sgPSB0cnVlO1xuXHRcdFx0XHRcdFx0XHRcdGZvcih0MSA9IDAsIHQyID0gZGF0YS5kYXRhLm5vZGVzLmxlbmd0aDsgdDEgPCB0MjsgdDErKykge1xuXHRcdFx0XHRcdFx0XHRcdFx0b3AgPSBkYXRhLmRhdGEub3JpZ2luICYmIChkYXRhLmRhdGEub3JpZ2luLnNldHRpbmdzLmRuZC5hbHdheXNfY29weSB8fCAoZGF0YS5kYXRhLm9yaWdpbi5zZXR0aW5ncy5kbmQuY29weSAmJiAoZGF0YS5ldmVudC5tZXRhS2V5IHx8IGRhdGEuZXZlbnQuY3RybEtleSkpKSA/IFwiY29weV9ub2RlXCIgOiBcIm1vdmVfbm9kZVwiO1xuXHRcdFx0XHRcdFx0XHRcdFx0cHMgPSBpO1xuXHRcdFx0XHRcdFx0XHRcdFx0aWYob3AgPT09IFwibW92ZV9ub2RlXCIgJiYgdiA9PT0gJ2EnICYmIChkYXRhLmRhdGEub3JpZ2luICYmIGRhdGEuZGF0YS5vcmlnaW4gPT09IGlucykgJiYgcCA9PT0gaW5zLmdldF9wYXJlbnQoZGF0YS5kYXRhLm5vZGVzW3QxXSkpIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0cHIgPSBpbnMuZ2V0X25vZGUocCk7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlmKHBzID4gJC5pbkFycmF5KGRhdGEuZGF0YS5ub2Rlc1t0MV0sIHByLmNoaWxkcmVuKSkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHBzIC09IDE7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdG9rID0gb2sgJiYgKCAoaW5zICYmIGlucy5zZXR0aW5ncyAmJiBpbnMuc2V0dGluZ3MuZG5kICYmIGlucy5zZXR0aW5ncy5kbmQuY2hlY2tfd2hpbGVfZHJhZ2dpbmcgPT09IGZhbHNlKSB8fCBpbnMuY2hlY2sob3AsIChkYXRhLmRhdGEub3JpZ2luICYmIGRhdGEuZGF0YS5vcmlnaW4gIT09IGlucyA/IGRhdGEuZGF0YS5vcmlnaW4uZ2V0X25vZGUoZGF0YS5kYXRhLm5vZGVzW3QxXSkgOiBkYXRhLmRhdGEubm9kZXNbdDFdKSwgcCwgcHMsIHsgJ2RuZCcgOiB0cnVlLCAncmVmJyA6IGlucy5nZXRfbm9kZShyZWYucGFyZW50KCkpLCAncG9zJyA6IHYsICdvcmlnaW4nIDogZGF0YS5kYXRhLm9yaWdpbiwgJ2lzX211bHRpJyA6IChkYXRhLmRhdGEub3JpZ2luICYmIGRhdGEuZGF0YS5vcmlnaW4gIT09IGlucyksICdpc19mb3JlaWduJyA6ICghZGF0YS5kYXRhLm9yaWdpbikgfSkgKTtcblx0XHRcdFx0XHRcdFx0XHRcdGlmKCFvaykge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZihpbnMgJiYgaW5zLmxhc3RfZXJyb3IpIHsgbGFzdGVyID0gaW5zLmxhc3RfZXJyb3IoKTsgfVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0aWYodiA9PT0gJ2knICYmIHJlZi5wYXJlbnQoKS5pcygnLmpzdHJlZS1jbG9zZWQnKSAmJiBpbnMuc2V0dGluZ3MuZG5kLm9wZW5fdGltZW91dCkge1xuXHRcdFx0XHRcdFx0XHRcdFx0b3BlbnRvID0gc2V0VGltZW91dCgoZnVuY3Rpb24gKHgsIHopIHsgcmV0dXJuIGZ1bmN0aW9uICgpIHsgeC5vcGVuX25vZGUoeik7IH07IH0oaW5zLCByZWYpKSwgaW5zLnNldHRpbmdzLmRuZC5vcGVuX3RpbWVvdXQpO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRpZihvaykge1xuXHRcdFx0XHRcdFx0XHRcdFx0cG4gPSBpbnMuZ2V0X25vZGUocCwgdHJ1ZSk7XG5cdFx0XHRcdFx0XHRcdFx0XHRpZiAoIXBuLmhhc0NsYXNzKCcuanN0cmVlLWRuZC1wYXJlbnQnKSkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHQkKCcuanN0cmVlLWRuZC1wYXJlbnQnKS5yZW1vdmVDbGFzcygnanN0cmVlLWRuZC1wYXJlbnQnKTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0cG4uYWRkQ2xhc3MoJ2pzdHJlZS1kbmQtcGFyZW50Jyk7XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHRsYXN0bXYgPSB7ICdpbnMnIDogaW5zLCAncGFyJyA6IHAsICdwb3MnIDogdiA9PT0gJ2knICYmIGlwID09PSAnbGFzdCcgJiYgaSA9PT0gMCAmJiAhaW5zLmlzX2xvYWRlZCh0bSkgPyAnbGFzdCcgOiBpIH07XG5cdFx0XHRcdFx0XHRcdFx0XHRtYXJrZXIuY3NzKHsgJ2xlZnQnIDogbCArICdweCcsICd0b3AnIDogdCArICdweCcgfSkuc2hvdygpO1xuXHRcdFx0XHRcdFx0XHRcdFx0ZGF0YS5oZWxwZXIuZmluZCgnLmpzdHJlZS1pY29uJykuZmlyc3QoKS5yZW1vdmVDbGFzcygnanN0cmVlLWVyJykuYWRkQ2xhc3MoJ2pzdHJlZS1vaycpO1xuXHRcdFx0XHRcdFx0XHRcdFx0aWYgKGRhdGEuZXZlbnQub3JpZ2luYWxFdmVudCAmJiBkYXRhLmV2ZW50Lm9yaWdpbmFsRXZlbnQuZGF0YVRyYW5zZmVyKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGRhdGEuZXZlbnQub3JpZ2luYWxFdmVudC5kYXRhVHJhbnNmZXIuZHJvcEVmZmVjdCA9IGlzX2NvcHkgPyAnY29weScgOiAnbW92ZSc7XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHRsYXN0ZXIgPSB7fTtcblx0XHRcdFx0XHRcdFx0XHRcdG8gPSB0cnVlO1xuXHRcdFx0XHRcdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0XHRcdGlmKG8gPT09IHRydWUpIHsgcmV0dXJuOyB9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdCQoJy5qc3RyZWUtZG5kLXBhcmVudCcpLnJlbW92ZUNsYXNzKCdqc3RyZWUtZG5kLXBhcmVudCcpO1xuXHRcdFx0XHRsYXN0bXYgPSBmYWxzZTtcblx0XHRcdFx0ZGF0YS5oZWxwZXIuZmluZCgnLmpzdHJlZS1pY29uJykucmVtb3ZlQ2xhc3MoJ2pzdHJlZS1vaycpLmFkZENsYXNzKCdqc3RyZWUtZXInKTtcblx0XHRcdFx0aWYgKGRhdGEuZXZlbnQub3JpZ2luYWxFdmVudCAmJiBkYXRhLmV2ZW50Lm9yaWdpbmFsRXZlbnQuZGF0YVRyYW5zZmVyKSB7XG5cdFx0XHRcdFx0ZGF0YS5ldmVudC5vcmlnaW5hbEV2ZW50LmRhdGFUcmFuc2Zlci5kcm9wRWZmZWN0ID0gJ25vbmUnO1xuXHRcdFx0XHR9XG5cdFx0XHRcdG1hcmtlci5oaWRlKCk7XG5cdFx0XHR9KVxuXHRcdFx0Lm9uKCdkbmRfc2Nyb2xsLnZha2F0YS5qc3RyZWUnLCBmdW5jdGlvbiAoZSwgZGF0YSkge1xuXHRcdFx0XHRpZighZGF0YSB8fCAhZGF0YS5kYXRhIHx8ICFkYXRhLmRhdGEuanN0cmVlKSB7IHJldHVybjsgfVxuXHRcdFx0XHRtYXJrZXIuaGlkZSgpO1xuXHRcdFx0XHRsYXN0bXYgPSBmYWxzZTtcblx0XHRcdFx0bGFzdGV2ID0gZmFsc2U7XG5cdFx0XHRcdGRhdGEuaGVscGVyLmZpbmQoJy5qc3RyZWUtaWNvbicpLmZpcnN0KCkucmVtb3ZlQ2xhc3MoJ2pzdHJlZS1vaycpLmFkZENsYXNzKCdqc3RyZWUtZXInKTtcblx0XHRcdH0pXG5cdFx0XHQub24oJ2RuZF9zdG9wLnZha2F0YS5qc3RyZWUnLCBmdW5jdGlvbiAoZSwgZGF0YSkge1xuXHRcdFx0XHQkKCcuanN0cmVlLWRuZC1wYXJlbnQnKS5yZW1vdmVDbGFzcygnanN0cmVlLWRuZC1wYXJlbnQnKTtcblx0XHRcdFx0aWYob3BlbnRvKSB7IGNsZWFyVGltZW91dChvcGVudG8pOyB9XG5cdFx0XHRcdGlmKCFkYXRhIHx8ICFkYXRhLmRhdGEgfHwgIWRhdGEuZGF0YS5qc3RyZWUpIHsgcmV0dXJuOyB9XG5cdFx0XHRcdG1hcmtlci5oaWRlKCkuZGV0YWNoKCk7XG5cdFx0XHRcdHZhciBpLCBqLCBub2RlcyA9IFtdO1xuXHRcdFx0XHRpZihsYXN0bXYpIHtcblx0XHRcdFx0XHRmb3IoaSA9IDAsIGogPSBkYXRhLmRhdGEubm9kZXMubGVuZ3RoOyBpIDwgajsgaSsrKSB7XG5cdFx0XHRcdFx0XHRub2Rlc1tpXSA9IGRhdGEuZGF0YS5vcmlnaW4gPyBkYXRhLmRhdGEub3JpZ2luLmdldF9ub2RlKGRhdGEuZGF0YS5ub2Rlc1tpXSkgOiBkYXRhLmRhdGEubm9kZXNbaV07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGxhc3Rtdi5pbnNbIGRhdGEuZGF0YS5vcmlnaW4gJiYgKGRhdGEuZGF0YS5vcmlnaW4uc2V0dGluZ3MuZG5kLmFsd2F5c19jb3B5IHx8IChkYXRhLmRhdGEub3JpZ2luLnNldHRpbmdzLmRuZC5jb3B5ICYmIChkYXRhLmV2ZW50Lm1ldGFLZXkgfHwgZGF0YS5ldmVudC5jdHJsS2V5KSkpID8gJ2NvcHlfbm9kZScgOiAnbW92ZV9ub2RlJyBdKG5vZGVzLCBsYXN0bXYucGFyLCBsYXN0bXYucG9zLCBmYWxzZSwgZmFsc2UsIGZhbHNlLCBkYXRhLmRhdGEub3JpZ2luKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRpID0gJChkYXRhLmV2ZW50LnRhcmdldCkuY2xvc2VzdCgnLmpzdHJlZScpO1xuXHRcdFx0XHRcdGlmKGkubGVuZ3RoICYmIGxhc3RlciAmJiBsYXN0ZXIuZXJyb3IgJiYgbGFzdGVyLmVycm9yID09PSAnY2hlY2snKSB7XG5cdFx0XHRcdFx0XHRpID0gaS5qc3RyZWUodHJ1ZSk7XG5cdFx0XHRcdFx0XHRpZihpKSB7XG5cdFx0XHRcdFx0XHRcdGkuc2V0dGluZ3MuY29yZS5lcnJvci5jYWxsKHRoaXMsIGxhc3Rlcik7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdGxhc3RldiA9IGZhbHNlO1xuXHRcdFx0XHRsYXN0bXYgPSBmYWxzZTtcblx0XHRcdH0pXG5cdFx0XHQub24oJ2tleXVwLmpzdHJlZSBrZXlkb3duLmpzdHJlZScsIGZ1bmN0aW9uIChlLCBkYXRhKSB7XG5cdFx0XHRcdGRhdGEgPSAkLnZha2F0YS5kbmQuX2dldCgpO1xuXHRcdFx0XHRpZihkYXRhICYmIGRhdGEuZGF0YSAmJiBkYXRhLmRhdGEuanN0cmVlKSB7XG5cdFx0XHRcdFx0aWYgKGUudHlwZSA9PT0gXCJrZXl1cFwiICYmIGUud2hpY2ggPT09IDI3KSB7XG5cdFx0XHRcdFx0XHRpZiAob3BlbnRvKSB7IGNsZWFyVGltZW91dChvcGVudG8pOyB9XG5cdFx0XHRcdFx0XHRsYXN0bXYgPSBmYWxzZTtcblx0XHRcdFx0XHRcdGxhc3RlciA9IGZhbHNlO1xuXHRcdFx0XHRcdFx0bGFzdGV2ID0gZmFsc2U7XG5cdFx0XHRcdFx0XHRvcGVudG8gPSBmYWxzZTtcblx0XHRcdFx0XHRcdG1hcmtlci5oaWRlKCkuZGV0YWNoKCk7XG5cdFx0XHRcdFx0XHQkLnZha2F0YS5kbmQuX2NsZWFuKCk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdGRhdGEuaGVscGVyLmZpbmQoJy5qc3RyZWUtY29weScpLmZpcnN0KClbIGRhdGEuZGF0YS5vcmlnaW4gJiYgKGRhdGEuZGF0YS5vcmlnaW4uc2V0dGluZ3MuZG5kLmFsd2F5c19jb3B5IHx8IChkYXRhLmRhdGEub3JpZ2luLnNldHRpbmdzLmRuZC5jb3B5ICYmIChlLm1ldGFLZXkgfHwgZS5jdHJsS2V5KSkpID8gJ3Nob3cnIDogJ2hpZGUnIF0oKTtcblx0XHRcdFx0XHRcdGlmKGxhc3Rldikge1xuXHRcdFx0XHRcdFx0XHRsYXN0ZXYubWV0YUtleSA9IGUubWV0YUtleTtcblx0XHRcdFx0XHRcdFx0bGFzdGV2LmN0cmxLZXkgPSBlLmN0cmxLZXk7XG5cdFx0XHRcdFx0XHRcdCQudmFrYXRhLmRuZC5fdHJpZ2dlcignbW92ZScsIGxhc3Rldik7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0fSk7XG5cblx0Ly8gaGVscGVyc1xuXHQoZnVuY3Rpb24gKCQpIHtcblx0XHQkLnZha2F0YS5odG1sID0ge1xuXHRcdFx0ZGl2IDogJCgnPGRpdiAvPicpLFxuXHRcdFx0ZXNjYXBlIDogZnVuY3Rpb24gKHN0cikge1xuXHRcdFx0XHRyZXR1cm4gJC52YWthdGEuaHRtbC5kaXYudGV4dChzdHIpLmh0bWwoKTtcblx0XHRcdH0sXG5cdFx0XHRzdHJpcCA6IGZ1bmN0aW9uIChzdHIpIHtcblx0XHRcdFx0cmV0dXJuICQudmFrYXRhLmh0bWwuZGl2LmVtcHR5KCkuYXBwZW5kKCQucGFyc2VIVE1MKHN0cikpLnRleHQoKTtcblx0XHRcdH1cblx0XHR9O1xuXHRcdC8vIHByaXZhdGUgdmFyaWFibGVcblx0XHR2YXIgdmFrYXRhX2RuZCA9IHtcblx0XHRcdGVsZW1lbnRcdDogZmFsc2UsXG5cdFx0XHR0YXJnZXRcdDogZmFsc2UsXG5cdFx0XHRpc19kb3duXHQ6IGZhbHNlLFxuXHRcdFx0aXNfZHJhZ1x0OiBmYWxzZSxcblx0XHRcdGhlbHBlclx0OiBmYWxzZSxcblx0XHRcdGhlbHBlcl93OiAwLFxuXHRcdFx0ZGF0YVx0OiBmYWxzZSxcblx0XHRcdGluaXRfeFx0OiAwLFxuXHRcdFx0aW5pdF95XHQ6IDAsXG5cdFx0XHRzY3JvbGxfbDogMCxcblx0XHRcdHNjcm9sbF90OiAwLFxuXHRcdFx0c2Nyb2xsX2U6IGZhbHNlLFxuXHRcdFx0c2Nyb2xsX2k6IGZhbHNlLFxuXHRcdFx0aXNfdG91Y2g6IGZhbHNlXG5cdFx0fTtcblx0XHQkLnZha2F0YS5kbmQgPSB7XG5cdFx0XHRzZXR0aW5ncyA6IHtcblx0XHRcdFx0c2Nyb2xsX3NwZWVkXHRcdDogMTAsXG5cdFx0XHRcdHNjcm9sbF9wcm94aW1pdHlcdDogMjAsXG5cdFx0XHRcdGhlbHBlcl9sZWZ0XHRcdFx0OiA1LFxuXHRcdFx0XHRoZWxwZXJfdG9wXHRcdFx0OiAxMCxcblx0XHRcdFx0dGhyZXNob2xkXHRcdFx0OiA1LFxuXHRcdFx0XHR0aHJlc2hvbGRfdG91Y2hcdFx0OiA1MFxuXHRcdFx0fSxcblx0XHRcdF90cmlnZ2VyIDogZnVuY3Rpb24gKGV2ZW50X25hbWUsIGUsIGRhdGEpIHtcblx0XHRcdFx0aWYgKGRhdGEgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRcdGRhdGEgPSAkLnZha2F0YS5kbmQuX2dldCgpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGRhdGEuZXZlbnQgPSBlO1xuXHRcdFx0XHQkKGRvY3VtZW50KS50cmlnZ2VySGFuZGxlcihcImRuZF9cIiArIGV2ZW50X25hbWUgKyBcIi52YWthdGFcIiwgZGF0YSk7XG5cdFx0XHR9LFxuXHRcdFx0X2dldCA6IGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0XHRcImRhdGFcIlx0XHQ6IHZha2F0YV9kbmQuZGF0YSxcblx0XHRcdFx0XHRcImVsZW1lbnRcIlx0OiB2YWthdGFfZG5kLmVsZW1lbnQsXG5cdFx0XHRcdFx0XCJoZWxwZXJcIlx0OiB2YWthdGFfZG5kLmhlbHBlclxuXHRcdFx0XHR9O1xuXHRcdFx0fSxcblx0XHRcdF9jbGVhbiA6IGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0aWYodmFrYXRhX2RuZC5oZWxwZXIpIHsgdmFrYXRhX2RuZC5oZWxwZXIucmVtb3ZlKCk7IH1cblx0XHRcdFx0aWYodmFrYXRhX2RuZC5zY3JvbGxfaSkgeyBjbGVhckludGVydmFsKHZha2F0YV9kbmQuc2Nyb2xsX2kpOyB2YWthdGFfZG5kLnNjcm9sbF9pID0gZmFsc2U7IH1cblx0XHRcdFx0dmFrYXRhX2RuZCA9IHtcblx0XHRcdFx0XHRlbGVtZW50XHQ6IGZhbHNlLFxuXHRcdFx0XHRcdHRhcmdldFx0OiBmYWxzZSxcblx0XHRcdFx0XHRpc19kb3duXHQ6IGZhbHNlLFxuXHRcdFx0XHRcdGlzX2RyYWdcdDogZmFsc2UsXG5cdFx0XHRcdFx0aGVscGVyXHQ6IGZhbHNlLFxuXHRcdFx0XHRcdGhlbHBlcl93OiAwLFxuXHRcdFx0XHRcdGRhdGFcdDogZmFsc2UsXG5cdFx0XHRcdFx0aW5pdF94XHQ6IDAsXG5cdFx0XHRcdFx0aW5pdF95XHQ6IDAsXG5cdFx0XHRcdFx0c2Nyb2xsX2w6IDAsXG5cdFx0XHRcdFx0c2Nyb2xsX3Q6IDAsXG5cdFx0XHRcdFx0c2Nyb2xsX2U6IGZhbHNlLFxuXHRcdFx0XHRcdHNjcm9sbF9pOiBmYWxzZSxcblx0XHRcdFx0XHRpc190b3VjaDogZmFsc2Vcblx0XHRcdFx0fTtcblx0XHRcdFx0JChkb2N1bWVudCkub2ZmKFwibW91c2Vtb3ZlLnZha2F0YS5qc3RyZWUgdG91Y2htb3ZlLnZha2F0YS5qc3RyZWVcIiwgJC52YWthdGEuZG5kLmRyYWcpO1xuXHRcdFx0XHQkKGRvY3VtZW50KS5vZmYoXCJtb3VzZXVwLnZha2F0YS5qc3RyZWUgdG91Y2hlbmQudmFrYXRhLmpzdHJlZVwiLCAkLnZha2F0YS5kbmQuc3RvcCk7XG5cdFx0XHR9LFxuXHRcdFx0X3Njcm9sbCA6IGZ1bmN0aW9uIChpbml0X29ubHkpIHtcblx0XHRcdFx0aWYoIXZha2F0YV9kbmQuc2Nyb2xsX2UgfHwgKCF2YWthdGFfZG5kLnNjcm9sbF9sICYmICF2YWthdGFfZG5kLnNjcm9sbF90KSkge1xuXHRcdFx0XHRcdGlmKHZha2F0YV9kbmQuc2Nyb2xsX2kpIHsgY2xlYXJJbnRlcnZhbCh2YWthdGFfZG5kLnNjcm9sbF9pKTsgdmFrYXRhX2RuZC5zY3JvbGxfaSA9IGZhbHNlOyB9XG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmKCF2YWthdGFfZG5kLnNjcm9sbF9pKSB7XG5cdFx0XHRcdFx0dmFrYXRhX2RuZC5zY3JvbGxfaSA9IHNldEludGVydmFsKCQudmFrYXRhLmRuZC5fc2Nyb2xsLCAxMDApO1xuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZihpbml0X29ubHkgPT09IHRydWUpIHsgcmV0dXJuIGZhbHNlOyB9XG5cblx0XHRcdFx0dmFyIGkgPSB2YWthdGFfZG5kLnNjcm9sbF9lLnNjcm9sbFRvcCgpLFxuXHRcdFx0XHRcdGogPSB2YWthdGFfZG5kLnNjcm9sbF9lLnNjcm9sbExlZnQoKTtcblx0XHRcdFx0dmFrYXRhX2RuZC5zY3JvbGxfZS5zY3JvbGxUb3AoaSArIHZha2F0YV9kbmQuc2Nyb2xsX3QgKiAkLnZha2F0YS5kbmQuc2V0dGluZ3Muc2Nyb2xsX3NwZWVkKTtcblx0XHRcdFx0dmFrYXRhX2RuZC5zY3JvbGxfZS5zY3JvbGxMZWZ0KGogKyB2YWthdGFfZG5kLnNjcm9sbF9sICogJC52YWthdGEuZG5kLnNldHRpbmdzLnNjcm9sbF9zcGVlZCk7XG5cdFx0XHRcdGlmKGkgIT09IHZha2F0YV9kbmQuc2Nyb2xsX2Uuc2Nyb2xsVG9wKCkgfHwgaiAhPT0gdmFrYXRhX2RuZC5zY3JvbGxfZS5zY3JvbGxMZWZ0KCkpIHtcblx0XHRcdFx0XHQvKipcblx0XHRcdFx0XHQgKiB0cmlnZ2VyZWQgb24gdGhlIGRvY3VtZW50IHdoZW4gYSBkcmFnIGNhdXNlcyBhbiBlbGVtZW50IHRvIHNjcm9sbFxuXHRcdFx0XHRcdCAqIEBldmVudFxuXHRcdFx0XHRcdCAqIEBwbHVnaW4gZG5kXG5cdFx0XHRcdFx0ICogQG5hbWUgZG5kX3Njcm9sbC52YWthdGFcblx0XHRcdFx0XHQgKiBAcGFyYW0ge01peGVkfSBkYXRhIGFueSBkYXRhIHN1cHBsaWVkIHdpdGggdGhlIGNhbGwgdG8gJC52YWthdGEuZG5kLnN0YXJ0XG5cdFx0XHRcdFx0ICogQHBhcmFtIHtET019IGVsZW1lbnQgdGhlIERPTSBlbGVtZW50IGJlaW5nIGRyYWdnZWRcblx0XHRcdFx0XHQgKiBAcGFyYW0ge2pRdWVyeX0gaGVscGVyIHRoZSBoZWxwZXIgc2hvd24gbmV4dCB0byB0aGUgbW91c2Vcblx0XHRcdFx0XHQgKiBAcGFyYW0ge2pRdWVyeX0gZXZlbnQgdGhlIGVsZW1lbnQgdGhhdCBpcyBzY3JvbGxpbmdcblx0XHRcdFx0XHQgKi9cblx0XHRcdFx0XHQkLnZha2F0YS5kbmQuX3RyaWdnZXIoXCJzY3JvbGxcIiwgdmFrYXRhX2RuZC5zY3JvbGxfZSk7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHRzdGFydCA6IGZ1bmN0aW9uIChlLCBkYXRhLCBodG1sKSB7XG5cdFx0XHRcdGlmKGUudHlwZSA9PT0gXCJ0b3VjaHN0YXJ0XCIgJiYgZS5vcmlnaW5hbEV2ZW50ICYmIGUub3JpZ2luYWxFdmVudC5jaGFuZ2VkVG91Y2hlcyAmJiBlLm9yaWdpbmFsRXZlbnQuY2hhbmdlZFRvdWNoZXNbMF0pIHtcblx0XHRcdFx0XHRlLnBhZ2VYID0gZS5vcmlnaW5hbEV2ZW50LmNoYW5nZWRUb3VjaGVzWzBdLnBhZ2VYO1xuXHRcdFx0XHRcdGUucGFnZVkgPSBlLm9yaWdpbmFsRXZlbnQuY2hhbmdlZFRvdWNoZXNbMF0ucGFnZVk7XG5cdFx0XHRcdFx0ZS50YXJnZXQgPSBkb2N1bWVudC5lbGVtZW50RnJvbVBvaW50KGUub3JpZ2luYWxFdmVudC5jaGFuZ2VkVG91Y2hlc1swXS5wYWdlWCAtIHdpbmRvdy5wYWdlWE9mZnNldCwgZS5vcmlnaW5hbEV2ZW50LmNoYW5nZWRUb3VjaGVzWzBdLnBhZ2VZIC0gd2luZG93LnBhZ2VZT2Zmc2V0KTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZih2YWthdGFfZG5kLmlzX2RyYWcpIHsgJC52YWthdGEuZG5kLnN0b3Aoe30pOyB9XG5cdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0ZS5jdXJyZW50VGFyZ2V0LnVuc2VsZWN0YWJsZSA9IFwib25cIjtcblx0XHRcdFx0XHRlLmN1cnJlbnRUYXJnZXQub25zZWxlY3RzdGFydCA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gZmFsc2U7IH07XG5cdFx0XHRcdFx0aWYoZS5jdXJyZW50VGFyZ2V0LnN0eWxlKSB7XG5cdFx0XHRcdFx0XHRlLmN1cnJlbnRUYXJnZXQuc3R5bGUudG91Y2hBY3Rpb24gPSBcIm5vbmVcIjtcblx0XHRcdFx0XHRcdGUuY3VycmVudFRhcmdldC5zdHlsZS5tc1RvdWNoQWN0aW9uID0gXCJub25lXCI7XG5cdFx0XHRcdFx0XHRlLmN1cnJlbnRUYXJnZXQuc3R5bGUuTW96VXNlclNlbGVjdCA9IFwibm9uZVwiO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBjYXRjaChpZ25vcmUpIHsgfVxuXHRcdFx0XHR2YWthdGFfZG5kLmluaXRfeFx0PSBlLnBhZ2VYO1xuXHRcdFx0XHR2YWthdGFfZG5kLmluaXRfeVx0PSBlLnBhZ2VZO1xuXHRcdFx0XHR2YWthdGFfZG5kLmRhdGFcdFx0PSBkYXRhO1xuXHRcdFx0XHR2YWthdGFfZG5kLmlzX2Rvd25cdD0gdHJ1ZTtcblx0XHRcdFx0dmFrYXRhX2RuZC5lbGVtZW50XHQ9IGUuY3VycmVudFRhcmdldDtcblx0XHRcdFx0dmFrYXRhX2RuZC50YXJnZXRcdD0gZS50YXJnZXQ7XG5cdFx0XHRcdHZha2F0YV9kbmQuaXNfdG91Y2hcdD0gZS50eXBlID09PSBcInRvdWNoc3RhcnRcIjtcblx0XHRcdFx0aWYoaHRtbCAhPT0gZmFsc2UpIHtcblx0XHRcdFx0XHR2YWthdGFfZG5kLmhlbHBlciA9ICQoXCI8ZGl2IGlkPSd2YWthdGEtZG5kJz48L2Rpdj5cIikuaHRtbChodG1sKS5jc3Moe1xuXHRcdFx0XHRcdFx0XCJkaXNwbGF5XCJcdFx0OiBcImJsb2NrXCIsXG5cdFx0XHRcdFx0XHRcIm1hcmdpblwiXHRcdDogXCIwXCIsXG5cdFx0XHRcdFx0XHRcInBhZGRpbmdcIlx0XHQ6IFwiMFwiLFxuXHRcdFx0XHRcdFx0XCJwb3NpdGlvblwiXHRcdDogXCJhYnNvbHV0ZVwiLFxuXHRcdFx0XHRcdFx0XCJ0b3BcIlx0XHRcdDogXCItMjAwMHB4XCIsXG5cdFx0XHRcdFx0XHRcImxpbmVIZWlnaHRcIlx0OiBcIjE2cHhcIixcblx0XHRcdFx0XHRcdFwiekluZGV4XCJcdFx0OiBcIjEwMDAwXCJcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0fVxuXHRcdFx0XHQkKGRvY3VtZW50KS5vbihcIm1vdXNlbW92ZS52YWthdGEuanN0cmVlIHRvdWNobW92ZS52YWthdGEuanN0cmVlXCIsICQudmFrYXRhLmRuZC5kcmFnKTtcblx0XHRcdFx0JChkb2N1bWVudCkub24oXCJtb3VzZXVwLnZha2F0YS5qc3RyZWUgdG91Y2hlbmQudmFrYXRhLmpzdHJlZVwiLCAkLnZha2F0YS5kbmQuc3RvcCk7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH0sXG5cdFx0XHRkcmFnIDogZnVuY3Rpb24gKGUpIHtcblx0XHRcdFx0aWYoZS50eXBlID09PSBcInRvdWNobW92ZVwiICYmIGUub3JpZ2luYWxFdmVudCAmJiBlLm9yaWdpbmFsRXZlbnQuY2hhbmdlZFRvdWNoZXMgJiYgZS5vcmlnaW5hbEV2ZW50LmNoYW5nZWRUb3VjaGVzWzBdKSB7XG5cdFx0XHRcdFx0ZS5wYWdlWCA9IGUub3JpZ2luYWxFdmVudC5jaGFuZ2VkVG91Y2hlc1swXS5wYWdlWDtcblx0XHRcdFx0XHRlLnBhZ2VZID0gZS5vcmlnaW5hbEV2ZW50LmNoYW5nZWRUb3VjaGVzWzBdLnBhZ2VZO1xuXHRcdFx0XHRcdGUudGFyZ2V0ID0gZG9jdW1lbnQuZWxlbWVudEZyb21Qb2ludChlLm9yaWdpbmFsRXZlbnQuY2hhbmdlZFRvdWNoZXNbMF0ucGFnZVggLSB3aW5kb3cucGFnZVhPZmZzZXQsIGUub3JpZ2luYWxFdmVudC5jaGFuZ2VkVG91Y2hlc1swXS5wYWdlWSAtIHdpbmRvdy5wYWdlWU9mZnNldCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYoIXZha2F0YV9kbmQuaXNfZG93bikgeyByZXR1cm47IH1cblx0XHRcdFx0aWYoIXZha2F0YV9kbmQuaXNfZHJhZykge1xuXHRcdFx0XHRcdGlmKFxuXHRcdFx0XHRcdFx0TWF0aC5hYnMoZS5wYWdlWCAtIHZha2F0YV9kbmQuaW5pdF94KSA+ICh2YWthdGFfZG5kLmlzX3RvdWNoID8gJC52YWthdGEuZG5kLnNldHRpbmdzLnRocmVzaG9sZF90b3VjaCA6ICQudmFrYXRhLmRuZC5zZXR0aW5ncy50aHJlc2hvbGQpIHx8XG5cdFx0XHRcdFx0XHRNYXRoLmFicyhlLnBhZ2VZIC0gdmFrYXRhX2RuZC5pbml0X3kpID4gKHZha2F0YV9kbmQuaXNfdG91Y2ggPyAkLnZha2F0YS5kbmQuc2V0dGluZ3MudGhyZXNob2xkX3RvdWNoIDogJC52YWthdGEuZG5kLnNldHRpbmdzLnRocmVzaG9sZClcblx0XHRcdFx0XHQpIHtcblx0XHRcdFx0XHRcdGlmKHZha2F0YV9kbmQuaGVscGVyKSB7XG5cdFx0XHRcdFx0XHRcdHZha2F0YV9kbmQuaGVscGVyLmFwcGVuZFRvKFwiYm9keVwiKTtcblx0XHRcdFx0XHRcdFx0dmFrYXRhX2RuZC5oZWxwZXJfdyA9IHZha2F0YV9kbmQuaGVscGVyLm91dGVyV2lkdGgoKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdHZha2F0YV9kbmQuaXNfZHJhZyA9IHRydWU7XG5cdFx0XHRcdFx0XHQkKHZha2F0YV9kbmQudGFyZ2V0KS5vbmUoJ2NsaWNrLnZha2F0YScsIGZhbHNlKTtcblx0XHRcdFx0XHRcdC8qKlxuXHRcdFx0XHRcdFx0ICogdHJpZ2dlcmVkIG9uIHRoZSBkb2N1bWVudCB3aGVuIGEgZHJhZyBzdGFydHNcblx0XHRcdFx0XHRcdCAqIEBldmVudFxuXHRcdFx0XHRcdFx0ICogQHBsdWdpbiBkbmRcblx0XHRcdFx0XHRcdCAqIEBuYW1lIGRuZF9zdGFydC52YWthdGFcblx0XHRcdFx0XHRcdCAqIEBwYXJhbSB7TWl4ZWR9IGRhdGEgYW55IGRhdGEgc3VwcGxpZWQgd2l0aCB0aGUgY2FsbCB0byAkLnZha2F0YS5kbmQuc3RhcnRcblx0XHRcdFx0XHRcdCAqIEBwYXJhbSB7RE9NfSBlbGVtZW50IHRoZSBET00gZWxlbWVudCBiZWluZyBkcmFnZ2VkXG5cdFx0XHRcdFx0XHQgKiBAcGFyYW0ge2pRdWVyeX0gaGVscGVyIHRoZSBoZWxwZXIgc2hvd24gbmV4dCB0byB0aGUgbW91c2Vcblx0XHRcdFx0XHRcdCAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCB0aGUgZXZlbnQgdGhhdCBjYXVzZWQgdGhlIHN0YXJ0IChwcm9iYWJseSBtb3VzZW1vdmUpXG5cdFx0XHRcdFx0XHQgKi9cblx0XHRcdFx0XHRcdCQudmFrYXRhLmRuZC5fdHJpZ2dlcihcInN0YXJ0XCIsIGUpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRlbHNlIHsgcmV0dXJuOyB9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHR2YXIgZCAgPSBmYWxzZSwgdyAgPSBmYWxzZSxcblx0XHRcdFx0XHRkaCA9IGZhbHNlLCB3aCA9IGZhbHNlLFxuXHRcdFx0XHRcdGR3ID0gZmFsc2UsIHd3ID0gZmFsc2UsXG5cdFx0XHRcdFx0ZHQgPSBmYWxzZSwgZGwgPSBmYWxzZSxcblx0XHRcdFx0XHRodCA9IGZhbHNlLCBobCA9IGZhbHNlO1xuXG5cdFx0XHRcdHZha2F0YV9kbmQuc2Nyb2xsX3QgPSAwO1xuXHRcdFx0XHR2YWthdGFfZG5kLnNjcm9sbF9sID0gMDtcblx0XHRcdFx0dmFrYXRhX2RuZC5zY3JvbGxfZSA9IGZhbHNlO1xuXHRcdFx0XHQkKCQoZS50YXJnZXQpLnBhcmVudHNVbnRpbChcImJvZHlcIikuYWRkQmFjaygpLmdldCgpLnJldmVyc2UoKSlcblx0XHRcdFx0XHQuZmlsdGVyKGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0XHRcdHJldHVyblx0KC9eYXV0b3xzY3JvbGwkLykudGVzdCgkKHRoaXMpLmNzcyhcIm92ZXJmbG93XCIpKSAmJlxuXHRcdFx0XHRcdFx0XHRcdCh0aGlzLnNjcm9sbEhlaWdodCA+IHRoaXMub2Zmc2V0SGVpZ2h0IHx8IHRoaXMuc2Nyb2xsV2lkdGggPiB0aGlzLm9mZnNldFdpZHRoKTtcblx0XHRcdFx0XHR9KVxuXHRcdFx0XHRcdC5lYWNoKGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0XHRcdHZhciB0ID0gJCh0aGlzKSwgbyA9IHQub2Zmc2V0KCk7XG5cdFx0XHRcdFx0XHRpZih0aGlzLnNjcm9sbEhlaWdodCA+IHRoaXMub2Zmc2V0SGVpZ2h0KSB7XG5cdFx0XHRcdFx0XHRcdGlmKG8udG9wICsgdC5oZWlnaHQoKSAtIGUucGFnZVkgPCAkLnZha2F0YS5kbmQuc2V0dGluZ3Muc2Nyb2xsX3Byb3hpbWl0eSlcdHsgdmFrYXRhX2RuZC5zY3JvbGxfdCA9IDE7IH1cblx0XHRcdFx0XHRcdFx0aWYoZS5wYWdlWSAtIG8udG9wIDwgJC52YWthdGEuZG5kLnNldHRpbmdzLnNjcm9sbF9wcm94aW1pdHkpXHRcdFx0XHR7IHZha2F0YV9kbmQuc2Nyb2xsX3QgPSAtMTsgfVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0aWYodGhpcy5zY3JvbGxXaWR0aCA+IHRoaXMub2Zmc2V0V2lkdGgpIHtcblx0XHRcdFx0XHRcdFx0aWYoby5sZWZ0ICsgdC53aWR0aCgpIC0gZS5wYWdlWCA8ICQudmFrYXRhLmRuZC5zZXR0aW5ncy5zY3JvbGxfcHJveGltaXR5KVx0eyB2YWthdGFfZG5kLnNjcm9sbF9sID0gMTsgfVxuXHRcdFx0XHRcdFx0XHRpZihlLnBhZ2VYIC0gby5sZWZ0IDwgJC52YWthdGEuZG5kLnNldHRpbmdzLnNjcm9sbF9wcm94aW1pdHkpXHRcdFx0XHR7IHZha2F0YV9kbmQuc2Nyb2xsX2wgPSAtMTsgfVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0aWYodmFrYXRhX2RuZC5zY3JvbGxfdCB8fCB2YWthdGFfZG5kLnNjcm9sbF9sKSB7XG5cdFx0XHRcdFx0XHRcdHZha2F0YV9kbmQuc2Nyb2xsX2UgPSAkKHRoaXMpO1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSk7XG5cblx0XHRcdFx0aWYoIXZha2F0YV9kbmQuc2Nyb2xsX2UpIHtcblx0XHRcdFx0XHRkICA9ICQoZG9jdW1lbnQpOyB3ID0gJCh3aW5kb3cpO1xuXHRcdFx0XHRcdGRoID0gZC5oZWlnaHQoKTsgd2ggPSB3LmhlaWdodCgpO1xuXHRcdFx0XHRcdGR3ID0gZC53aWR0aCgpOyB3dyA9IHcud2lkdGgoKTtcblx0XHRcdFx0XHRkdCA9IGQuc2Nyb2xsVG9wKCk7IGRsID0gZC5zY3JvbGxMZWZ0KCk7XG5cdFx0XHRcdFx0aWYoZGggPiB3aCAmJiBlLnBhZ2VZIC0gZHQgPCAkLnZha2F0YS5kbmQuc2V0dGluZ3Muc2Nyb2xsX3Byb3hpbWl0eSlcdFx0eyB2YWthdGFfZG5kLnNjcm9sbF90ID0gLTE7ICB9XG5cdFx0XHRcdFx0aWYoZGggPiB3aCAmJiB3aCAtIChlLnBhZ2VZIC0gZHQpIDwgJC52YWthdGEuZG5kLnNldHRpbmdzLnNjcm9sbF9wcm94aW1pdHkpXHR7IHZha2F0YV9kbmQuc2Nyb2xsX3QgPSAxOyB9XG5cdFx0XHRcdFx0aWYoZHcgPiB3dyAmJiBlLnBhZ2VYIC0gZGwgPCAkLnZha2F0YS5kbmQuc2V0dGluZ3Muc2Nyb2xsX3Byb3hpbWl0eSlcdFx0eyB2YWthdGFfZG5kLnNjcm9sbF9sID0gLTE7IH1cblx0XHRcdFx0XHRpZihkdyA+IHd3ICYmIHd3IC0gKGUucGFnZVggLSBkbCkgPCAkLnZha2F0YS5kbmQuc2V0dGluZ3Muc2Nyb2xsX3Byb3hpbWl0eSlcdHsgdmFrYXRhX2RuZC5zY3JvbGxfbCA9IDE7IH1cblx0XHRcdFx0XHRpZih2YWthdGFfZG5kLnNjcm9sbF90IHx8IHZha2F0YV9kbmQuc2Nyb2xsX2wpIHtcblx0XHRcdFx0XHRcdHZha2F0YV9kbmQuc2Nyb2xsX2UgPSBkO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRpZih2YWthdGFfZG5kLnNjcm9sbF9lKSB7ICQudmFrYXRhLmRuZC5fc2Nyb2xsKHRydWUpOyB9XG5cblx0XHRcdFx0aWYodmFrYXRhX2RuZC5oZWxwZXIpIHtcblx0XHRcdFx0XHRodCA9IHBhcnNlSW50KGUucGFnZVkgKyAkLnZha2F0YS5kbmQuc2V0dGluZ3MuaGVscGVyX3RvcCwgMTApO1xuXHRcdFx0XHRcdGhsID0gcGFyc2VJbnQoZS5wYWdlWCArICQudmFrYXRhLmRuZC5zZXR0aW5ncy5oZWxwZXJfbGVmdCwgMTApO1xuXHRcdFx0XHRcdGlmKGRoICYmIGh0ICsgMjUgPiBkaCkgeyBodCA9IGRoIC0gNTA7IH1cblx0XHRcdFx0XHRpZihkdyAmJiBobCArIHZha2F0YV9kbmQuaGVscGVyX3cgPiBkdykgeyBobCA9IGR3IC0gKHZha2F0YV9kbmQuaGVscGVyX3cgKyAyKTsgfVxuXHRcdFx0XHRcdHZha2F0YV9kbmQuaGVscGVyLmNzcyh7XG5cdFx0XHRcdFx0XHRsZWZ0XHQ6IGhsICsgXCJweFwiLFxuXHRcdFx0XHRcdFx0dG9wXHRcdDogaHQgKyBcInB4XCJcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0fVxuXHRcdFx0XHQvKipcblx0XHRcdFx0ICogdHJpZ2dlcmVkIG9uIHRoZSBkb2N1bWVudCB3aGVuIGEgZHJhZyBpcyBpbiBwcm9ncmVzc1xuXHRcdFx0XHQgKiBAZXZlbnRcblx0XHRcdFx0ICogQHBsdWdpbiBkbmRcblx0XHRcdFx0ICogQG5hbWUgZG5kX21vdmUudmFrYXRhXG5cdFx0XHRcdCAqIEBwYXJhbSB7TWl4ZWR9IGRhdGEgYW55IGRhdGEgc3VwcGxpZWQgd2l0aCB0aGUgY2FsbCB0byAkLnZha2F0YS5kbmQuc3RhcnRcblx0XHRcdFx0ICogQHBhcmFtIHtET019IGVsZW1lbnQgdGhlIERPTSBlbGVtZW50IGJlaW5nIGRyYWdnZWRcblx0XHRcdFx0ICogQHBhcmFtIHtqUXVlcnl9IGhlbHBlciB0aGUgaGVscGVyIHNob3duIG5leHQgdG8gdGhlIG1vdXNlXG5cdFx0XHRcdCAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCB0aGUgZXZlbnQgdGhhdCBjYXVzZWQgdGhpcyB0byB0cmlnZ2VyIChtb3N0IGxpa2VseSBtb3VzZW1vdmUpXG5cdFx0XHRcdCAqL1xuXHRcdFx0XHQkLnZha2F0YS5kbmQuX3RyaWdnZXIoXCJtb3ZlXCIsIGUpO1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9LFxuXHRcdFx0c3RvcCA6IGZ1bmN0aW9uIChlKSB7XG5cdFx0XHRcdGlmKGUudHlwZSA9PT0gXCJ0b3VjaGVuZFwiICYmIGUub3JpZ2luYWxFdmVudCAmJiBlLm9yaWdpbmFsRXZlbnQuY2hhbmdlZFRvdWNoZXMgJiYgZS5vcmlnaW5hbEV2ZW50LmNoYW5nZWRUb3VjaGVzWzBdKSB7XG5cdFx0XHRcdFx0ZS5wYWdlWCA9IGUub3JpZ2luYWxFdmVudC5jaGFuZ2VkVG91Y2hlc1swXS5wYWdlWDtcblx0XHRcdFx0XHRlLnBhZ2VZID0gZS5vcmlnaW5hbEV2ZW50LmNoYW5nZWRUb3VjaGVzWzBdLnBhZ2VZO1xuXHRcdFx0XHRcdGUudGFyZ2V0ID0gZG9jdW1lbnQuZWxlbWVudEZyb21Qb2ludChlLm9yaWdpbmFsRXZlbnQuY2hhbmdlZFRvdWNoZXNbMF0ucGFnZVggLSB3aW5kb3cucGFnZVhPZmZzZXQsIGUub3JpZ2luYWxFdmVudC5jaGFuZ2VkVG91Y2hlc1swXS5wYWdlWSAtIHdpbmRvdy5wYWdlWU9mZnNldCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYodmFrYXRhX2RuZC5pc19kcmFnKSB7XG5cdFx0XHRcdFx0LyoqXG5cdFx0XHRcdFx0ICogdHJpZ2dlcmVkIG9uIHRoZSBkb2N1bWVudCB3aGVuIGEgZHJhZyBzdG9wcyAodGhlIGRyYWdnZWQgZWxlbWVudCBpcyBkcm9wcGVkKVxuXHRcdFx0XHRcdCAqIEBldmVudFxuXHRcdFx0XHRcdCAqIEBwbHVnaW4gZG5kXG5cdFx0XHRcdFx0ICogQG5hbWUgZG5kX3N0b3AudmFrYXRhXG5cdFx0XHRcdFx0ICogQHBhcmFtIHtNaXhlZH0gZGF0YSBhbnkgZGF0YSBzdXBwbGllZCB3aXRoIHRoZSBjYWxsIHRvICQudmFrYXRhLmRuZC5zdGFydFxuXHRcdFx0XHRcdCAqIEBwYXJhbSB7RE9NfSBlbGVtZW50IHRoZSBET00gZWxlbWVudCBiZWluZyBkcmFnZ2VkXG5cdFx0XHRcdFx0ICogQHBhcmFtIHtqUXVlcnl9IGhlbHBlciB0aGUgaGVscGVyIHNob3duIG5leHQgdG8gdGhlIG1vdXNlXG5cdFx0XHRcdFx0ICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IHRoZSBldmVudCB0aGF0IGNhdXNlZCB0aGUgc3RvcFxuXHRcdFx0XHRcdCAqL1xuXHRcdFx0XHRcdGlmIChlLnRhcmdldCAhPT0gdmFrYXRhX2RuZC50YXJnZXQpIHtcblx0XHRcdFx0XHRcdCQodmFrYXRhX2RuZC50YXJnZXQpLm9mZignY2xpY2sudmFrYXRhJyk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdCQudmFrYXRhLmRuZC5fdHJpZ2dlcihcInN0b3BcIiwgZSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0aWYoZS50eXBlID09PSBcInRvdWNoZW5kXCIgJiYgZS50YXJnZXQgPT09IHZha2F0YV9kbmQudGFyZ2V0KSB7XG5cdFx0XHRcdFx0XHR2YXIgdG8gPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHsgJChlLnRhcmdldCkuY2xpY2soKTsgfSwgMTAwKTtcblx0XHRcdFx0XHRcdCQoZS50YXJnZXQpLm9uZSgnY2xpY2snLCBmdW5jdGlvbigpIHsgaWYodG8pIHsgY2xlYXJUaW1lb3V0KHRvKTsgfSB9KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0JC52YWthdGEuZG5kLl9jbGVhbigpO1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cdFx0fTtcblx0fSgkKSk7XG5cblx0Ly8gaW5jbHVkZSB0aGUgZG5kIHBsdWdpbiBieSBkZWZhdWx0XG5cdC8vICQuanN0cmVlLmRlZmF1bHRzLnBsdWdpbnMucHVzaChcImRuZFwiKTtcblxuXG4vKipcbiAqICMjIyBNYXNzbG9hZCBwbHVnaW5cbiAqXG4gKiBBZGRzIG1hc3Nsb2FkIGZ1bmN0aW9uYWxpdHkgdG8ganNUcmVlLCBzbyB0aGF0IG11bHRpcGxlIG5vZGVzIGNhbiBiZSBsb2FkZWQgaW4gYSBzaW5nbGUgcmVxdWVzdCAob25seSB1c2VmdWwgd2l0aCBsYXp5IGxvYWRpbmcpLlxuICovXG5cblx0LyoqXG5cdCAqIG1hc3Nsb2FkIGNvbmZpZ3VyYXRpb25cblx0ICpcblx0ICogSXQgaXMgcG9zc2libGUgdG8gc2V0IHRoaXMgdG8gYSBzdGFuZGFyZCBqUXVlcnktbGlrZSBBSkFYIGNvbmZpZy5cblx0ICogSW4gYWRkaXRpb24gdG8gdGhlIHN0YW5kYXJkIGpRdWVyeSBhamF4IG9wdGlvbnMgaGVyZSB5b3UgY2FuIHN1cHBseSBmdW5jdGlvbnMgZm9yIGBkYXRhYCBhbmQgYHVybGAsIHRoZSBmdW5jdGlvbnMgd2lsbCBiZSBydW4gaW4gdGhlIGN1cnJlbnQgaW5zdGFuY2UncyBzY29wZSBhbmQgYSBwYXJhbSB3aWxsIGJlIHBhc3NlZCBpbmRpY2F0aW5nIHdoaWNoIG5vZGUgSURzIG5lZWQgdG8gYmUgbG9hZGVkLCB0aGUgcmV0dXJuIHZhbHVlIG9mIHRob3NlIGZ1bmN0aW9ucyB3aWxsIGJlIHVzZWQuXG5cdCAqXG5cdCAqIFlvdSBjYW4gYWxzbyBzZXQgdGhpcyB0byBhIGZ1bmN0aW9uLCB0aGF0IGZ1bmN0aW9uIHdpbGwgcmVjZWl2ZSB0aGUgbm9kZSBJRHMgYmVpbmcgbG9hZGVkIGFzIGFyZ3VtZW50IGFuZCBhIHNlY29uZCBwYXJhbSB3aGljaCBpcyBhIGZ1bmN0aW9uIChjYWxsYmFjaykgd2hpY2ggc2hvdWxkIGJlIGNhbGxlZCB3aXRoIHRoZSByZXN1bHQuXG5cdCAqXG5cdCAqIEJvdGggdGhlIEFKQVggYW5kIHRoZSBmdW5jdGlvbiBhcHByb2FjaCByZWx5IG9uIHRoZSBzYW1lIHJldHVybiB2YWx1ZSAtIGFuIG9iamVjdCB3aGVyZSB0aGUga2V5cyBhcmUgdGhlIG5vZGUgSURzLCBhbmQgdGhlIHZhbHVlIGlzIHRoZSBjaGlsZHJlbiBvZiB0aGF0IG5vZGUgYXMgYW4gYXJyYXkuXG5cdCAqXG5cdCAqXHR7XG5cdCAqXHRcdFwiaWQxXCIgOiBbeyBcInRleHRcIiA6IFwiQ2hpbGQgb2YgSUQxXCIsIFwiaWRcIiA6IFwiYzFcIiB9LCB7IFwidGV4dFwiIDogXCJBbm90aGVyIGNoaWxkIG9mIElEMVwiLCBcImlkXCIgOiBcImMyXCIgfV0sXG5cdCAqXHRcdFwiaWQyXCIgOiBbeyBcInRleHRcIiA6IFwiQ2hpbGQgb2YgSUQyXCIsIFwiaWRcIiA6IFwiYzNcIiB9XVxuXHQgKlx0fVxuXHQgKiBcblx0ICogQG5hbWUgJC5qc3RyZWUuZGVmYXVsdHMubWFzc2xvYWRcblx0ICogQHBsdWdpbiBtYXNzbG9hZFxuXHQgKi9cblx0JC5qc3RyZWUuZGVmYXVsdHMubWFzc2xvYWQgPSBudWxsO1xuXHQkLmpzdHJlZS5wbHVnaW5zLm1hc3Nsb2FkID0gZnVuY3Rpb24gKG9wdGlvbnMsIHBhcmVudCkge1xuXHRcdHRoaXMuaW5pdCA9IGZ1bmN0aW9uIChlbCwgb3B0aW9ucykge1xuXHRcdFx0dGhpcy5fZGF0YS5tYXNzbG9hZCA9IHt9O1xuXHRcdFx0cGFyZW50LmluaXQuY2FsbCh0aGlzLCBlbCwgb3B0aW9ucyk7XG5cdFx0fTtcblx0XHR0aGlzLl9sb2FkX25vZGVzID0gZnVuY3Rpb24gKG5vZGVzLCBjYWxsYmFjaywgaXNfY2FsbGJhY2ssIGZvcmNlX3JlbG9hZCkge1xuXHRcdFx0dmFyIHMgPSB0aGlzLnNldHRpbmdzLm1hc3Nsb2FkLFxuXHRcdFx0XHRub2Rlc1N0cmluZyA9IEpTT04uc3RyaW5naWZ5KG5vZGVzKSxcblx0XHRcdFx0dG9Mb2FkID0gW10sXG5cdFx0XHRcdG0gPSB0aGlzLl9tb2RlbC5kYXRhLFxuXHRcdFx0XHRpLCBqLCBkb207XG5cdFx0XHRpZiAoIWlzX2NhbGxiYWNrKSB7XG5cdFx0XHRcdGZvcihpID0gMCwgaiA9IG5vZGVzLmxlbmd0aDsgaSA8IGo7IGkrKykge1xuXHRcdFx0XHRcdGlmKCFtW25vZGVzW2ldXSB8fCAoICghbVtub2Rlc1tpXV0uc3RhdGUubG9hZGVkICYmICFtW25vZGVzW2ldXS5zdGF0ZS5mYWlsZWQpIHx8IGZvcmNlX3JlbG9hZCkgKSB7XG5cdFx0XHRcdFx0XHR0b0xvYWQucHVzaChub2Rlc1tpXSk7XG5cdFx0XHRcdFx0XHRkb20gPSB0aGlzLmdldF9ub2RlKG5vZGVzW2ldLCB0cnVlKTtcblx0XHRcdFx0XHRcdGlmIChkb20gJiYgZG9tLmxlbmd0aCkge1xuXHRcdFx0XHRcdFx0XHRkb20uYWRkQ2xhc3MoXCJqc3RyZWUtbG9hZGluZ1wiKS5hdHRyKCdhcmlhLWJ1c3knLHRydWUpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHR0aGlzLl9kYXRhLm1hc3Nsb2FkID0ge307XG5cdFx0XHRcdGlmICh0b0xvYWQubGVuZ3RoKSB7XG5cdFx0XHRcdFx0aWYoJC5pc0Z1bmN0aW9uKHMpKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gcy5jYWxsKHRoaXMsIHRvTG9hZCwgJC5wcm94eShmdW5jdGlvbiAoZGF0YSkge1xuXHRcdFx0XHRcdFx0XHR2YXIgaSwgajtcblx0XHRcdFx0XHRcdFx0aWYoZGF0YSkge1xuXHRcdFx0XHRcdFx0XHRcdGZvcihpIGluIGRhdGEpIHtcblx0XHRcdFx0XHRcdFx0XHRcdGlmKGRhdGEuaGFzT3duUHJvcGVydHkoaSkpIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dGhpcy5fZGF0YS5tYXNzbG9hZFtpXSA9IGRhdGFbaV07XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdGZvcihpID0gMCwgaiA9IG5vZGVzLmxlbmd0aDsgaSA8IGo7IGkrKykge1xuXHRcdFx0XHRcdFx0XHRcdGRvbSA9IHRoaXMuZ2V0X25vZGUobm9kZXNbaV0sIHRydWUpO1xuXHRcdFx0XHRcdFx0XHRcdGlmIChkb20gJiYgZG9tLmxlbmd0aCkge1xuXHRcdFx0XHRcdFx0XHRcdFx0ZG9tLnJlbW92ZUNsYXNzKFwianN0cmVlLWxvYWRpbmdcIikuYXR0cignYXJpYS1idXN5JyxmYWxzZSk7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdHBhcmVudC5fbG9hZF9ub2Rlcy5jYWxsKHRoaXMsIG5vZGVzLCBjYWxsYmFjaywgaXNfY2FsbGJhY2ssIGZvcmNlX3JlbG9hZCk7XG5cdFx0XHRcdFx0XHR9LCB0aGlzKSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmKHR5cGVvZiBzID09PSAnb2JqZWN0JyAmJiBzICYmIHMudXJsKSB7XG5cdFx0XHRcdFx0XHRzID0gJC5leHRlbmQodHJ1ZSwge30sIHMpO1xuXHRcdFx0XHRcdFx0aWYoJC5pc0Z1bmN0aW9uKHMudXJsKSkge1xuXHRcdFx0XHRcdFx0XHRzLnVybCA9IHMudXJsLmNhbGwodGhpcywgdG9Mb2FkKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGlmKCQuaXNGdW5jdGlvbihzLmRhdGEpKSB7XG5cdFx0XHRcdFx0XHRcdHMuZGF0YSA9IHMuZGF0YS5jYWxsKHRoaXMsIHRvTG9hZCk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRyZXR1cm4gJC5hamF4KHMpXG5cdFx0XHRcdFx0XHRcdC5kb25lKCQucHJveHkoZnVuY3Rpb24gKGRhdGEsdCx4KSB7XG5cdFx0XHRcdFx0XHRcdFx0XHR2YXIgaSwgajtcblx0XHRcdFx0XHRcdFx0XHRcdGlmKGRhdGEpIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0Zm9yKGkgaW4gZGF0YSkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGlmKGRhdGEuaGFzT3duUHJvcGVydHkoaSkpIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHRoaXMuX2RhdGEubWFzc2xvYWRbaV0gPSBkYXRhW2ldO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0Zm9yKGkgPSAwLCBqID0gbm9kZXMubGVuZ3RoOyBpIDwgajsgaSsrKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGRvbSA9IHRoaXMuZ2V0X25vZGUobm9kZXNbaV0sIHRydWUpO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZiAoZG9tICYmIGRvbS5sZW5ndGgpIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRkb20ucmVtb3ZlQ2xhc3MoXCJqc3RyZWUtbG9hZGluZ1wiKS5hdHRyKCdhcmlhLWJ1c3knLGZhbHNlKTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0cGFyZW50Ll9sb2FkX25vZGVzLmNhbGwodGhpcywgbm9kZXMsIGNhbGxiYWNrLCBpc19jYWxsYmFjaywgZm9yY2VfcmVsb2FkKTtcblx0XHRcdFx0XHRcdFx0XHR9LCB0aGlzKSlcblx0XHRcdFx0XHRcdFx0LmZhaWwoJC5wcm94eShmdW5jdGlvbiAoZikge1xuXHRcdFx0XHRcdFx0XHRcdFx0cGFyZW50Ll9sb2FkX25vZGVzLmNhbGwodGhpcywgbm9kZXMsIGNhbGxiYWNrLCBpc19jYWxsYmFjaywgZm9yY2VfcmVsb2FkKTtcblx0XHRcdFx0XHRcdFx0XHR9LCB0aGlzKSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcGFyZW50Ll9sb2FkX25vZGVzLmNhbGwodGhpcywgbm9kZXMsIGNhbGxiYWNrLCBpc19jYWxsYmFjaywgZm9yY2VfcmVsb2FkKTtcblx0XHR9O1xuXHRcdHRoaXMuX2xvYWRfbm9kZSA9IGZ1bmN0aW9uIChvYmosIGNhbGxiYWNrKSB7XG5cdFx0XHR2YXIgZGF0YSA9IHRoaXMuX2RhdGEubWFzc2xvYWRbb2JqLmlkXSxcblx0XHRcdFx0cnNsdCA9IG51bGwsIGRvbTtcblx0XHRcdGlmKGRhdGEpIHtcblx0XHRcdFx0cnNsdCA9IHRoaXNbdHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnID8gJ19hcHBlbmRfaHRtbF9kYXRhJyA6ICdfYXBwZW5kX2pzb25fZGF0YSddKFxuXHRcdFx0XHRcdG9iaixcblx0XHRcdFx0XHR0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZycgPyAkKCQucGFyc2VIVE1MKGRhdGEpKS5maWx0ZXIoZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5ub2RlVHlwZSAhPT0gMzsgfSkgOiBkYXRhLFxuXHRcdFx0XHRcdGZ1bmN0aW9uIChzdGF0dXMpIHsgY2FsbGJhY2suY2FsbCh0aGlzLCBzdGF0dXMpOyB9XG5cdFx0XHRcdCk7XG5cdFx0XHRcdGRvbSA9IHRoaXMuZ2V0X25vZGUob2JqLmlkLCB0cnVlKTtcblx0XHRcdFx0aWYgKGRvbSAmJiBkb20ubGVuZ3RoKSB7XG5cdFx0XHRcdFx0ZG9tLnJlbW92ZUNsYXNzKFwianN0cmVlLWxvYWRpbmdcIikuYXR0cignYXJpYS1idXN5JyxmYWxzZSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZGVsZXRlIHRoaXMuX2RhdGEubWFzc2xvYWRbb2JqLmlkXTtcblx0XHRcdFx0cmV0dXJuIHJzbHQ7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcGFyZW50Ll9sb2FkX25vZGUuY2FsbCh0aGlzLCBvYmosIGNhbGxiYWNrKTtcblx0XHR9O1xuXHR9O1xuXG4vKipcbiAqICMjIyBTZWFyY2ggcGx1Z2luXG4gKlxuICogQWRkcyBzZWFyY2ggZnVuY3Rpb25hbGl0eSB0byBqc1RyZWUuXG4gKi9cblxuXHQvKipcblx0ICogc3RvcmVzIGFsbCBkZWZhdWx0cyBmb3IgdGhlIHNlYXJjaCBwbHVnaW5cblx0ICogQG5hbWUgJC5qc3RyZWUuZGVmYXVsdHMuc2VhcmNoXG5cdCAqIEBwbHVnaW4gc2VhcmNoXG5cdCAqL1xuXHQkLmpzdHJlZS5kZWZhdWx0cy5zZWFyY2ggPSB7XG5cdFx0LyoqXG5cdFx0ICogYSBqUXVlcnktbGlrZSBBSkFYIGNvbmZpZywgd2hpY2gganN0cmVlIHVzZXMgaWYgYSBzZXJ2ZXIgc2hvdWxkIGJlIHF1ZXJpZWQgZm9yIHJlc3VsdHMuXG5cdFx0ICpcblx0XHQgKiBBIGBzdHJgICh3aGljaCBpcyB0aGUgc2VhcmNoIHN0cmluZykgcGFyYW1ldGVyIHdpbGwgYmUgYWRkZWQgd2l0aCB0aGUgcmVxdWVzdCwgYW4gb3B0aW9uYWwgYGluc2lkZWAgcGFyYW1ldGVyIHdpbGwgYmUgYWRkZWQgaWYgdGhlIHNlYXJjaCBpcyBsaW1pdGVkIHRvIGEgbm9kZSBpZC4gVGhlIGV4cGVjdGVkIHJlc3VsdCBpcyBhIEpTT04gYXJyYXkgd2l0aCBub2RlcyB0aGF0IG5lZWQgdG8gYmUgb3BlbmVkIHNvIHRoYXQgbWF0Y2hpbmcgbm9kZXMgd2lsbCBiZSByZXZlYWxlZC5cblx0XHQgKiBMZWF2ZSB0aGlzIHNldHRpbmcgYXMgYGZhbHNlYCB0byBub3QgcXVlcnkgdGhlIHNlcnZlci4gWW91IGNhbiBhbHNvIHNldCB0aGlzIHRvIGEgZnVuY3Rpb24sIHdoaWNoIHdpbGwgYmUgaW52b2tlZCBpbiB0aGUgaW5zdGFuY2UncyBzY29wZSBhbmQgcmVjZWl2ZSAzIHBhcmFtZXRlcnMgLSB0aGUgc2VhcmNoIHN0cmluZywgdGhlIGNhbGxiYWNrIHRvIGNhbGwgd2l0aCB0aGUgYXJyYXkgb2Ygbm9kZXMgdG8gbG9hZCwgYW5kIHRoZSBvcHRpb25hbCBub2RlIElEIHRvIGxpbWl0IHRoZSBzZWFyY2ggdG9cblx0XHQgKiBAbmFtZSAkLmpzdHJlZS5kZWZhdWx0cy5zZWFyY2guYWpheFxuXHRcdCAqIEBwbHVnaW4gc2VhcmNoXG5cdFx0ICovXG5cdFx0YWpheCA6IGZhbHNlLFxuXHRcdC8qKlxuXHRcdCAqIEluZGljYXRlcyBpZiB0aGUgc2VhcmNoIHNob3VsZCBiZSBmdXp6eSBvciBub3QgKHNob3VsZCBgY2huZDNgIG1hdGNoIGBjaGlsZCBub2RlIDNgKS4gRGVmYXVsdCBpcyBgZmFsc2VgLlxuXHRcdCAqIEBuYW1lICQuanN0cmVlLmRlZmF1bHRzLnNlYXJjaC5mdXp6eVxuXHRcdCAqIEBwbHVnaW4gc2VhcmNoXG5cdFx0ICovXG5cdFx0ZnV6enkgOiBmYWxzZSxcblx0XHQvKipcblx0XHQgKiBJbmRpY2F0ZXMgaWYgdGhlIHNlYXJjaCBzaG91bGQgYmUgY2FzZSBzZW5zaXRpdmUuIERlZmF1bHQgaXMgYGZhbHNlYC5cblx0XHQgKiBAbmFtZSAkLmpzdHJlZS5kZWZhdWx0cy5zZWFyY2guY2FzZV9zZW5zaXRpdmVcblx0XHQgKiBAcGx1Z2luIHNlYXJjaFxuXHRcdCAqL1xuXHRcdGNhc2Vfc2Vuc2l0aXZlIDogZmFsc2UsXG5cdFx0LyoqXG5cdFx0ICogSW5kaWNhdGVzIGlmIHRoZSB0cmVlIHNob3VsZCBiZSBmaWx0ZXJlZCAoYnkgZGVmYXVsdCkgdG8gc2hvdyBvbmx5IG1hdGNoaW5nIG5vZGVzIChrZWVwIGluIG1pbmQgdGhpcyBjYW4gYmUgYSBoZWF2eSBvbiBsYXJnZSB0cmVlcyBpbiBvbGQgYnJvd3NlcnMpLlxuXHRcdCAqIFRoaXMgc2V0dGluZyBjYW4gYmUgY2hhbmdlZCBhdCBydW50aW1lIHdoZW4gY2FsbGluZyB0aGUgc2VhcmNoIG1ldGhvZC4gRGVmYXVsdCBpcyBgZmFsc2VgLlxuXHRcdCAqIEBuYW1lICQuanN0cmVlLmRlZmF1bHRzLnNlYXJjaC5zaG93X29ubHlfbWF0Y2hlc1xuXHRcdCAqIEBwbHVnaW4gc2VhcmNoXG5cdFx0ICovXG5cdFx0c2hvd19vbmx5X21hdGNoZXMgOiBmYWxzZSxcblx0XHQvKipcblx0XHQgKiBJbmRpY2F0ZXMgaWYgdGhlIGNoaWxkcmVuIG9mIG1hdGNoZWQgZWxlbWVudCBhcmUgc2hvd24gKHdoZW4gc2hvd19vbmx5X21hdGNoZXMgaXMgdHJ1ZSlcblx0XHQgKiBUaGlzIHNldHRpbmcgY2FuIGJlIGNoYW5nZWQgYXQgcnVudGltZSB3aGVuIGNhbGxpbmcgdGhlIHNlYXJjaCBtZXRob2QuIERlZmF1bHQgaXMgYGZhbHNlYC5cblx0XHQgKiBAbmFtZSAkLmpzdHJlZS5kZWZhdWx0cy5zZWFyY2guc2hvd19vbmx5X21hdGNoZXNfY2hpbGRyZW5cblx0XHQgKiBAcGx1Z2luIHNlYXJjaFxuXHRcdCAqL1xuXHRcdHNob3dfb25seV9tYXRjaGVzX2NoaWxkcmVuIDogZmFsc2UsXG5cdFx0LyoqXG5cdFx0ICogSW5kaWNhdGVzIGlmIGFsbCBub2RlcyBvcGVuZWQgdG8gcmV2ZWFsIHRoZSBzZWFyY2ggcmVzdWx0LCBzaG91bGQgYmUgY2xvc2VkIHdoZW4gdGhlIHNlYXJjaCBpcyBjbGVhcmVkIG9yIGEgbmV3IHNlYXJjaCBpcyBwZXJmb3JtZWQuIERlZmF1bHQgaXMgYHRydWVgLlxuXHRcdCAqIEBuYW1lICQuanN0cmVlLmRlZmF1bHRzLnNlYXJjaC5jbG9zZV9vcGVuZWRfb25jbGVhclxuXHRcdCAqIEBwbHVnaW4gc2VhcmNoXG5cdFx0ICovXG5cdFx0Y2xvc2Vfb3BlbmVkX29uY2xlYXIgOiB0cnVlLFxuXHRcdC8qKlxuXHRcdCAqIEluZGljYXRlcyBpZiBvbmx5IGxlYWYgbm9kZXMgc2hvdWxkIGJlIGluY2x1ZGVkIGluIHNlYXJjaCByZXN1bHRzLiBEZWZhdWx0IGlzIGBmYWxzZWAuXG5cdFx0ICogQG5hbWUgJC5qc3RyZWUuZGVmYXVsdHMuc2VhcmNoLnNlYXJjaF9sZWF2ZXNfb25seVxuXHRcdCAqIEBwbHVnaW4gc2VhcmNoXG5cdFx0ICovXG5cdFx0c2VhcmNoX2xlYXZlc19vbmx5IDogZmFsc2UsXG5cdFx0LyoqXG5cdFx0ICogSWYgc2V0IHRvIGEgZnVuY3Rpb24gaXQgd2lsIGJlIGNhbGxlZCBpbiB0aGUgaW5zdGFuY2UncyBzY29wZSB3aXRoIHR3byBhcmd1bWVudHMgLSBzZWFyY2ggc3RyaW5nIGFuZCBub2RlICh3aGVyZSBub2RlIHdpbGwgYmUgZXZlcnkgbm9kZSBpbiB0aGUgc3RydWN0dXJlLCBzbyB1c2Ugd2l0aCBjYXV0aW9uKS5cblx0XHQgKiBJZiB0aGUgZnVuY3Rpb24gcmV0dXJucyBhIHRydXRoeSB2YWx1ZSB0aGUgbm9kZSB3aWxsIGJlIGNvbnNpZGVyZWQgYSBtYXRjaCAoaXQgbWlnaHQgbm90IGJlIGRpc3BsYXllZCBpZiBzZWFyY2hfb25seV9sZWF2ZXMgaXMgc2V0IHRvIHRydWUgYW5kIHRoZSBub2RlIGlzIG5vdCBhIGxlYWYpLiBEZWZhdWx0IGlzIGBmYWxzZWAuXG5cdFx0ICogQG5hbWUgJC5qc3RyZWUuZGVmYXVsdHMuc2VhcmNoLnNlYXJjaF9jYWxsYmFja1xuXHRcdCAqIEBwbHVnaW4gc2VhcmNoXG5cdFx0ICovXG5cdFx0c2VhcmNoX2NhbGxiYWNrIDogZmFsc2Vcblx0fTtcblxuXHQkLmpzdHJlZS5wbHVnaW5zLnNlYXJjaCA9IGZ1bmN0aW9uIChvcHRpb25zLCBwYXJlbnQpIHtcblx0XHR0aGlzLmJpbmQgPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHRwYXJlbnQuYmluZC5jYWxsKHRoaXMpO1xuXG5cdFx0XHR0aGlzLl9kYXRhLnNlYXJjaC5zdHIgPSBcIlwiO1xuXHRcdFx0dGhpcy5fZGF0YS5zZWFyY2guZG9tID0gJCgpO1xuXHRcdFx0dGhpcy5fZGF0YS5zZWFyY2gucmVzID0gW107XG5cdFx0XHR0aGlzLl9kYXRhLnNlYXJjaC5vcG4gPSBbXTtcblx0XHRcdHRoaXMuX2RhdGEuc2VhcmNoLnNvbSA9IGZhbHNlO1xuXHRcdFx0dGhpcy5fZGF0YS5zZWFyY2guc21jID0gZmFsc2U7XG5cdFx0XHR0aGlzLl9kYXRhLnNlYXJjaC5oZG4gPSBbXTtcblxuXHRcdFx0dGhpcy5lbGVtZW50XG5cdFx0XHRcdC5vbihcInNlYXJjaC5qc3RyZWVcIiwgJC5wcm94eShmdW5jdGlvbiAoZSwgZGF0YSkge1xuXHRcdFx0XHRcdFx0aWYodGhpcy5fZGF0YS5zZWFyY2guc29tICYmIGRhdGEucmVzLmxlbmd0aCkge1xuXHRcdFx0XHRcdFx0XHR2YXIgbSA9IHRoaXMuX21vZGVsLmRhdGEsIGksIGosIHAgPSBbXSwgaywgbDtcblx0XHRcdFx0XHRcdFx0Zm9yKGkgPSAwLCBqID0gZGF0YS5yZXMubGVuZ3RoOyBpIDwgajsgaSsrKSB7XG5cdFx0XHRcdFx0XHRcdFx0aWYobVtkYXRhLnJlc1tpXV0gJiYgIW1bZGF0YS5yZXNbaV1dLnN0YXRlLmhpZGRlbikge1xuXHRcdFx0XHRcdFx0XHRcdFx0cC5wdXNoKGRhdGEucmVzW2ldKTtcblx0XHRcdFx0XHRcdFx0XHRcdHAgPSBwLmNvbmNhdChtW2RhdGEucmVzW2ldXS5wYXJlbnRzKTtcblx0XHRcdFx0XHRcdFx0XHRcdGlmKHRoaXMuX2RhdGEuc2VhcmNoLnNtYykge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRmb3IgKGsgPSAwLCBsID0gbVtkYXRhLnJlc1tpXV0uY2hpbGRyZW5fZC5sZW5ndGg7IGsgPCBsOyBrKyspIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRpZiAobVttW2RhdGEucmVzW2ldXS5jaGlsZHJlbl9kW2tdXSAmJiAhbVttW2RhdGEucmVzW2ldXS5jaGlsZHJlbl9kW2tdXS5zdGF0ZS5oaWRkZW4pIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHAucHVzaChtW2RhdGEucmVzW2ldXS5jaGlsZHJlbl9kW2tdKTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0cCA9ICQudmFrYXRhLmFycmF5X3JlbW92ZV9pdGVtKCQudmFrYXRhLmFycmF5X3VuaXF1ZShwKSwgJC5qc3RyZWUucm9vdCk7XG5cdFx0XHRcdFx0XHRcdHRoaXMuX2RhdGEuc2VhcmNoLmhkbiA9IHRoaXMuaGlkZV9hbGwodHJ1ZSk7XG5cdFx0XHRcdFx0XHRcdHRoaXMuc2hvd19ub2RlKHAsIHRydWUpO1xuXHRcdFx0XHRcdFx0XHR0aGlzLnJlZHJhdyh0cnVlKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9LCB0aGlzKSlcblx0XHRcdFx0Lm9uKFwiY2xlYXJfc2VhcmNoLmpzdHJlZVwiLCAkLnByb3h5KGZ1bmN0aW9uIChlLCBkYXRhKSB7XG5cdFx0XHRcdFx0XHRpZih0aGlzLl9kYXRhLnNlYXJjaC5zb20gJiYgZGF0YS5yZXMubGVuZ3RoKSB7XG5cdFx0XHRcdFx0XHRcdHRoaXMuc2hvd19ub2RlKHRoaXMuX2RhdGEuc2VhcmNoLmhkbiwgdHJ1ZSk7XG5cdFx0XHRcdFx0XHRcdHRoaXMucmVkcmF3KHRydWUpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0sIHRoaXMpKTtcblx0XHR9O1xuXHRcdC8qKlxuXHRcdCAqIHVzZWQgdG8gc2VhcmNoIHRoZSB0cmVlIG5vZGVzIGZvciBhIGdpdmVuIHN0cmluZ1xuXHRcdCAqIEBuYW1lIHNlYXJjaChzdHIgWywgc2tpcF9hc3luY10pXG5cdFx0ICogQHBhcmFtIHtTdHJpbmd9IHN0ciB0aGUgc2VhcmNoIHN0cmluZ1xuXHRcdCAqIEBwYXJhbSB7Qm9vbGVhbn0gc2tpcF9hc3luYyBpZiBzZXQgdG8gdHJ1ZSBzZXJ2ZXIgd2lsbCBub3QgYmUgcXVlcmllZCBldmVuIGlmIGNvbmZpZ3VyZWRcblx0XHQgKiBAcGFyYW0ge0Jvb2xlYW59IHNob3dfb25seV9tYXRjaGVzIGlmIHNldCB0byB0cnVlIG9ubHkgbWF0Y2hpbmcgbm9kZXMgd2lsbCBiZSBzaG93biAoa2VlcCBpbiBtaW5kIHRoaXMgY2FuIGJlIHZlcnkgc2xvdyBvbiBsYXJnZSB0cmVlcyBvciBvbGQgYnJvd3NlcnMpXG5cdFx0ICogQHBhcmFtIHttaXhlZH0gaW5zaWRlIGFuIG9wdGlvbmFsIG5vZGUgdG8gd2hvc2UgY2hpbGRyZW4gdG8gbGltaXQgdGhlIHNlYXJjaFxuXHRcdCAqIEBwYXJhbSB7Qm9vbGVhbn0gYXBwZW5kIGlmIHNldCB0byB0cnVlIHRoZSByZXN1bHRzIG9mIHRoaXMgc2VhcmNoIGFyZSBhcHBlbmRlZCB0byB0aGUgcHJldmlvdXMgc2VhcmNoXG5cdFx0ICogQHBsdWdpbiBzZWFyY2hcblx0XHQgKiBAdHJpZ2dlciBzZWFyY2guanN0cmVlXG5cdFx0ICovXG5cdFx0dGhpcy5zZWFyY2ggPSBmdW5jdGlvbiAoc3RyLCBza2lwX2FzeW5jLCBzaG93X29ubHlfbWF0Y2hlcywgaW5zaWRlLCBhcHBlbmQsIHNob3dfb25seV9tYXRjaGVzX2NoaWxkcmVuKSB7XG5cdFx0XHRpZihzdHIgPT09IGZhbHNlIHx8ICQudHJpbShzdHIudG9TdHJpbmcoKSkgPT09IFwiXCIpIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuY2xlYXJfc2VhcmNoKCk7XG5cdFx0XHR9XG5cdFx0XHRpbnNpZGUgPSB0aGlzLmdldF9ub2RlKGluc2lkZSk7XG5cdFx0XHRpbnNpZGUgPSBpbnNpZGUgJiYgaW5zaWRlLmlkID8gaW5zaWRlLmlkIDogbnVsbDtcblx0XHRcdHN0ciA9IHN0ci50b1N0cmluZygpO1xuXHRcdFx0dmFyIHMgPSB0aGlzLnNldHRpbmdzLnNlYXJjaCxcblx0XHRcdFx0YSA9IHMuYWpheCA/IHMuYWpheCA6IGZhbHNlLFxuXHRcdFx0XHRtID0gdGhpcy5fbW9kZWwuZGF0YSxcblx0XHRcdFx0ZiA9IG51bGwsXG5cdFx0XHRcdHIgPSBbXSxcblx0XHRcdFx0cCA9IFtdLCBpLCBqO1xuXHRcdFx0aWYodGhpcy5fZGF0YS5zZWFyY2gucmVzLmxlbmd0aCAmJiAhYXBwZW5kKSB7XG5cdFx0XHRcdHRoaXMuY2xlYXJfc2VhcmNoKCk7XG5cdFx0XHR9XG5cdFx0XHRpZihzaG93X29ubHlfbWF0Y2hlcyA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdHNob3dfb25seV9tYXRjaGVzID0gcy5zaG93X29ubHlfbWF0Y2hlcztcblx0XHRcdH1cblx0XHRcdGlmKHNob3dfb25seV9tYXRjaGVzX2NoaWxkcmVuID09PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0c2hvd19vbmx5X21hdGNoZXNfY2hpbGRyZW4gPSBzLnNob3dfb25seV9tYXRjaGVzX2NoaWxkcmVuO1xuXHRcdFx0fVxuXHRcdFx0aWYoIXNraXBfYXN5bmMgJiYgYSAhPT0gZmFsc2UpIHtcblx0XHRcdFx0aWYoJC5pc0Z1bmN0aW9uKGEpKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGEuY2FsbCh0aGlzLCBzdHIsICQucHJveHkoZnVuY3Rpb24gKGQpIHtcblx0XHRcdFx0XHRcdFx0aWYoZCAmJiBkLmQpIHsgZCA9IGQuZDsgfVxuXHRcdFx0XHRcdFx0XHR0aGlzLl9sb2FkX25vZGVzKCEkLmlzQXJyYXkoZCkgPyBbXSA6ICQudmFrYXRhLmFycmF5X3VuaXF1ZShkKSwgZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdFx0XHRcdHRoaXMuc2VhcmNoKHN0ciwgdHJ1ZSwgc2hvd19vbmx5X21hdGNoZXMsIGluc2lkZSwgYXBwZW5kLCBzaG93X29ubHlfbWF0Y2hlc19jaGlsZHJlbik7XG5cdFx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdFx0fSwgdGhpcyksIGluc2lkZSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0YSA9ICQuZXh0ZW5kKHt9LCBhKTtcblx0XHRcdFx0XHRpZighYS5kYXRhKSB7IGEuZGF0YSA9IHt9OyB9XG5cdFx0XHRcdFx0YS5kYXRhLnN0ciA9IHN0cjtcblx0XHRcdFx0XHRpZihpbnNpZGUpIHtcblx0XHRcdFx0XHRcdGEuZGF0YS5pbnNpZGUgPSBpbnNpZGU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmICh0aGlzLl9kYXRhLnNlYXJjaC5sYXN0UmVxdWVzdCkge1xuXHRcdFx0XHRcdFx0dGhpcy5fZGF0YS5zZWFyY2gubGFzdFJlcXVlc3QuYWJvcnQoKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0dGhpcy5fZGF0YS5zZWFyY2gubGFzdFJlcXVlc3QgPSAkLmFqYXgoYSlcblx0XHRcdFx0XHRcdC5mYWlsKCQucHJveHkoZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdFx0XHR0aGlzLl9kYXRhLmNvcmUubGFzdF9lcnJvciA9IHsgJ2Vycm9yJyA6ICdhamF4JywgJ3BsdWdpbicgOiAnc2VhcmNoJywgJ2lkJyA6ICdzZWFyY2hfMDEnLCAncmVhc29uJyA6ICdDb3VsZCBub3QgbG9hZCBzZWFyY2ggcGFyZW50cycsICdkYXRhJyA6IEpTT04uc3RyaW5naWZ5KGEpIH07XG5cdFx0XHRcdFx0XHRcdHRoaXMuc2V0dGluZ3MuY29yZS5lcnJvci5jYWxsKHRoaXMsIHRoaXMuX2RhdGEuY29yZS5sYXN0X2Vycm9yKTtcblx0XHRcdFx0XHRcdH0sIHRoaXMpKVxuXHRcdFx0XHRcdFx0LmRvbmUoJC5wcm94eShmdW5jdGlvbiAoZCkge1xuXHRcdFx0XHRcdFx0XHRpZihkICYmIGQuZCkgeyBkID0gZC5kOyB9XG5cdFx0XHRcdFx0XHRcdHRoaXMuX2xvYWRfbm9kZXMoISQuaXNBcnJheShkKSA/IFtdIDogJC52YWthdGEuYXJyYXlfdW5pcXVlKGQpLCBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdFx0XHRcdFx0dGhpcy5zZWFyY2goc3RyLCB0cnVlLCBzaG93X29ubHlfbWF0Y2hlcywgaW5zaWRlLCBhcHBlbmQsIHNob3dfb25seV9tYXRjaGVzX2NoaWxkcmVuKTtcblx0XHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0XHR9LCB0aGlzKSk7XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXMuX2RhdGEuc2VhcmNoLmxhc3RSZXF1ZXN0O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRpZighYXBwZW5kKSB7XG5cdFx0XHRcdHRoaXMuX2RhdGEuc2VhcmNoLnN0ciA9IHN0cjtcblx0XHRcdFx0dGhpcy5fZGF0YS5zZWFyY2guZG9tID0gJCgpO1xuXHRcdFx0XHR0aGlzLl9kYXRhLnNlYXJjaC5yZXMgPSBbXTtcblx0XHRcdFx0dGhpcy5fZGF0YS5zZWFyY2gub3BuID0gW107XG5cdFx0XHRcdHRoaXMuX2RhdGEuc2VhcmNoLnNvbSA9IHNob3dfb25seV9tYXRjaGVzO1xuXHRcdFx0XHR0aGlzLl9kYXRhLnNlYXJjaC5zbWMgPSBzaG93X29ubHlfbWF0Y2hlc19jaGlsZHJlbjtcblx0XHRcdH1cblxuXHRcdFx0ZiA9IG5ldyAkLnZha2F0YS5zZWFyY2goc3RyLCB0cnVlLCB7IGNhc2VTZW5zaXRpdmUgOiBzLmNhc2Vfc2Vuc2l0aXZlLCBmdXp6eSA6IHMuZnV6enkgfSk7XG5cdFx0XHQkLmVhY2gobVtpbnNpZGUgPyBpbnNpZGUgOiAkLmpzdHJlZS5yb290XS5jaGlsZHJlbl9kLCBmdW5jdGlvbiAoaWksIGkpIHtcblx0XHRcdFx0dmFyIHYgPSBtW2ldO1xuXHRcdFx0XHRpZih2LnRleHQgJiYgIXYuc3RhdGUuaGlkZGVuICYmICghcy5zZWFyY2hfbGVhdmVzX29ubHkgfHwgKHYuc3RhdGUubG9hZGVkICYmIHYuY2hpbGRyZW4ubGVuZ3RoID09PSAwKSkgJiYgKCAocy5zZWFyY2hfY2FsbGJhY2sgJiYgcy5zZWFyY2hfY2FsbGJhY2suY2FsbCh0aGlzLCBzdHIsIHYpKSB8fCAoIXMuc2VhcmNoX2NhbGxiYWNrICYmIGYuc2VhcmNoKHYudGV4dCkuaXNNYXRjaCkgKSApIHtcblx0XHRcdFx0XHRyLnB1c2goaSk7XG5cdFx0XHRcdFx0cCA9IHAuY29uY2F0KHYucGFyZW50cyk7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdFx0aWYoci5sZW5ndGgpIHtcblx0XHRcdFx0cCA9ICQudmFrYXRhLmFycmF5X3VuaXF1ZShwKTtcblx0XHRcdFx0Zm9yKGkgPSAwLCBqID0gcC5sZW5ndGg7IGkgPCBqOyBpKyspIHtcblx0XHRcdFx0XHRpZihwW2ldICE9PSAkLmpzdHJlZS5yb290ICYmIG1bcFtpXV0gJiYgdGhpcy5vcGVuX25vZGUocFtpXSwgbnVsbCwgMCkgPT09IHRydWUpIHtcblx0XHRcdFx0XHRcdHRoaXMuX2RhdGEuc2VhcmNoLm9wbi5wdXNoKHBbaV0pO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRpZighYXBwZW5kKSB7XG5cdFx0XHRcdFx0dGhpcy5fZGF0YS5zZWFyY2guZG9tID0gJCh0aGlzLmVsZW1lbnRbMF0ucXVlcnlTZWxlY3RvckFsbCgnIycgKyAkLm1hcChyLCBmdW5jdGlvbiAodikgeyByZXR1cm4gXCIwMTIzNDU2Nzg5XCIuaW5kZXhPZih2WzBdKSAhPT0gLTEgPyAnXFxcXDMnICsgdlswXSArICcgJyArIHYuc3Vic3RyKDEpLnJlcGxhY2UoJC5qc3RyZWUuaWRyZWdleCwnXFxcXCQmJykgOiB2LnJlcGxhY2UoJC5qc3RyZWUuaWRyZWdleCwnXFxcXCQmJyk7IH0pLmpvaW4oJywgIycpKSk7XG5cdFx0XHRcdFx0dGhpcy5fZGF0YS5zZWFyY2gucmVzID0gcjtcblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHR0aGlzLl9kYXRhLnNlYXJjaC5kb20gPSB0aGlzLl9kYXRhLnNlYXJjaC5kb20uYWRkKCQodGhpcy5lbGVtZW50WzBdLnF1ZXJ5U2VsZWN0b3JBbGwoJyMnICsgJC5tYXAociwgZnVuY3Rpb24gKHYpIHsgcmV0dXJuIFwiMDEyMzQ1Njc4OVwiLmluZGV4T2YodlswXSkgIT09IC0xID8gJ1xcXFwzJyArIHZbMF0gKyAnICcgKyB2LnN1YnN0cigxKS5yZXBsYWNlKCQuanN0cmVlLmlkcmVnZXgsJ1xcXFwkJicpIDogdi5yZXBsYWNlKCQuanN0cmVlLmlkcmVnZXgsJ1xcXFwkJicpOyB9KS5qb2luKCcsICMnKSkpKTtcblx0XHRcdFx0XHR0aGlzLl9kYXRhLnNlYXJjaC5yZXMgPSAkLnZha2F0YS5hcnJheV91bmlxdWUodGhpcy5fZGF0YS5zZWFyY2gucmVzLmNvbmNhdChyKSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0dGhpcy5fZGF0YS5zZWFyY2guZG9tLmNoaWxkcmVuKFwiLmpzdHJlZS1hbmNob3JcIikuYWRkQ2xhc3MoJ2pzdHJlZS1zZWFyY2gnKTtcblx0XHRcdH1cblx0XHRcdC8qKlxuXHRcdFx0ICogdHJpZ2dlcmVkIGFmdGVyIHNlYXJjaCBpcyBjb21wbGV0ZVxuXHRcdFx0ICogQGV2ZW50XG5cdFx0XHQgKiBAbmFtZSBzZWFyY2guanN0cmVlXG5cdFx0XHQgKiBAcGFyYW0ge2pRdWVyeX0gbm9kZXMgYSBqUXVlcnkgY29sbGVjdGlvbiBvZiBtYXRjaGluZyBub2Rlc1xuXHRcdFx0ICogQHBhcmFtIHtTdHJpbmd9IHN0ciB0aGUgc2VhcmNoIHN0cmluZ1xuXHRcdFx0ICogQHBhcmFtIHtBcnJheX0gcmVzIGEgY29sbGVjdGlvbiBvZiBvYmplY3RzIHJlcHJlc2VpbmcgdGhlIG1hdGNoaW5nIG5vZGVzXG5cdFx0XHQgKiBAcGx1Z2luIHNlYXJjaFxuXHRcdFx0ICovXG5cdFx0XHR0aGlzLnRyaWdnZXIoJ3NlYXJjaCcsIHsgbm9kZXMgOiB0aGlzLl9kYXRhLnNlYXJjaC5kb20sIHN0ciA6IHN0ciwgcmVzIDogdGhpcy5fZGF0YS5zZWFyY2gucmVzLCBzaG93X29ubHlfbWF0Y2hlcyA6IHNob3dfb25seV9tYXRjaGVzIH0pO1xuXHRcdH07XG5cdFx0LyoqXG5cdFx0ICogdXNlZCB0byBjbGVhciB0aGUgbGFzdCBzZWFyY2ggKHJlbW92ZXMgY2xhc3NlcyBhbmQgc2hvd3MgYWxsIG5vZGVzIGlmIGZpbHRlcmluZyBpcyBvbilcblx0XHQgKiBAbmFtZSBjbGVhcl9zZWFyY2goKVxuXHRcdCAqIEBwbHVnaW4gc2VhcmNoXG5cdFx0ICogQHRyaWdnZXIgY2xlYXJfc2VhcmNoLmpzdHJlZVxuXHRcdCAqL1xuXHRcdHRoaXMuY2xlYXJfc2VhcmNoID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0aWYodGhpcy5zZXR0aW5ncy5zZWFyY2guY2xvc2Vfb3BlbmVkX29uY2xlYXIpIHtcblx0XHRcdFx0dGhpcy5jbG9zZV9ub2RlKHRoaXMuX2RhdGEuc2VhcmNoLm9wbiwgMCk7XG5cdFx0XHR9XG5cdFx0XHQvKipcblx0XHRcdCAqIHRyaWdnZXJlZCBhZnRlciBzZWFyY2ggaXMgY29tcGxldGVcblx0XHRcdCAqIEBldmVudFxuXHRcdFx0ICogQG5hbWUgY2xlYXJfc2VhcmNoLmpzdHJlZVxuXHRcdFx0ICogQHBhcmFtIHtqUXVlcnl9IG5vZGVzIGEgalF1ZXJ5IGNvbGxlY3Rpb24gb2YgbWF0Y2hpbmcgbm9kZXMgKHRoZSByZXN1bHQgZnJvbSB0aGUgbGFzdCBzZWFyY2gpXG5cdFx0XHQgKiBAcGFyYW0ge1N0cmluZ30gc3RyIHRoZSBzZWFyY2ggc3RyaW5nICh0aGUgbGFzdCBzZWFyY2ggc3RyaW5nKVxuXHRcdFx0ICogQHBhcmFtIHtBcnJheX0gcmVzIGEgY29sbGVjdGlvbiBvZiBvYmplY3RzIHJlcHJlc2VpbmcgdGhlIG1hdGNoaW5nIG5vZGVzICh0aGUgcmVzdWx0IGZyb20gdGhlIGxhc3Qgc2VhcmNoKVxuXHRcdFx0ICogQHBsdWdpbiBzZWFyY2hcblx0XHRcdCAqL1xuXHRcdFx0dGhpcy50cmlnZ2VyKCdjbGVhcl9zZWFyY2gnLCB7ICdub2RlcycgOiB0aGlzLl9kYXRhLnNlYXJjaC5kb20sIHN0ciA6IHRoaXMuX2RhdGEuc2VhcmNoLnN0ciwgcmVzIDogdGhpcy5fZGF0YS5zZWFyY2gucmVzIH0pO1xuXHRcdFx0aWYodGhpcy5fZGF0YS5zZWFyY2gucmVzLmxlbmd0aCkge1xuXHRcdFx0XHR0aGlzLl9kYXRhLnNlYXJjaC5kb20gPSAkKHRoaXMuZWxlbWVudFswXS5xdWVyeVNlbGVjdG9yQWxsKCcjJyArICQubWFwKHRoaXMuX2RhdGEuc2VhcmNoLnJlcywgZnVuY3Rpb24gKHYpIHtcblx0XHRcdFx0XHRyZXR1cm4gXCIwMTIzNDU2Nzg5XCIuaW5kZXhPZih2WzBdKSAhPT0gLTEgPyAnXFxcXDMnICsgdlswXSArICcgJyArIHYuc3Vic3RyKDEpLnJlcGxhY2UoJC5qc3RyZWUuaWRyZWdleCwnXFxcXCQmJykgOiB2LnJlcGxhY2UoJC5qc3RyZWUuaWRyZWdleCwnXFxcXCQmJyk7XG5cdFx0XHRcdH0pLmpvaW4oJywgIycpKSk7XG5cdFx0XHRcdHRoaXMuX2RhdGEuc2VhcmNoLmRvbS5jaGlsZHJlbihcIi5qc3RyZWUtYW5jaG9yXCIpLnJlbW92ZUNsYXNzKFwianN0cmVlLXNlYXJjaFwiKTtcblx0XHRcdH1cblx0XHRcdHRoaXMuX2RhdGEuc2VhcmNoLnN0ciA9IFwiXCI7XG5cdFx0XHR0aGlzLl9kYXRhLnNlYXJjaC5yZXMgPSBbXTtcblx0XHRcdHRoaXMuX2RhdGEuc2VhcmNoLm9wbiA9IFtdO1xuXHRcdFx0dGhpcy5fZGF0YS5zZWFyY2guZG9tID0gJCgpO1xuXHRcdH07XG5cblx0XHR0aGlzLnJlZHJhd19ub2RlID0gZnVuY3Rpb24ob2JqLCBkZWVwLCBjYWxsYmFjaywgZm9yY2VfcmVuZGVyKSB7XG5cdFx0XHRvYmogPSBwYXJlbnQucmVkcmF3X25vZGUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0XHRcdGlmKG9iaikge1xuXHRcdFx0XHRpZigkLmluQXJyYXkob2JqLmlkLCB0aGlzLl9kYXRhLnNlYXJjaC5yZXMpICE9PSAtMSkge1xuXHRcdFx0XHRcdHZhciBpLCBqLCB0bXAgPSBudWxsO1xuXHRcdFx0XHRcdGZvcihpID0gMCwgaiA9IG9iai5jaGlsZE5vZGVzLmxlbmd0aDsgaSA8IGo7IGkrKykge1xuXHRcdFx0XHRcdFx0aWYob2JqLmNoaWxkTm9kZXNbaV0gJiYgb2JqLmNoaWxkTm9kZXNbaV0uY2xhc3NOYW1lICYmIG9iai5jaGlsZE5vZGVzW2ldLmNsYXNzTmFtZS5pbmRleE9mKFwianN0cmVlLWFuY2hvclwiKSAhPT0gLTEpIHtcblx0XHRcdFx0XHRcdFx0dG1wID0gb2JqLmNoaWxkTm9kZXNbaV07XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZih0bXApIHtcblx0XHRcdFx0XHRcdHRtcC5jbGFzc05hbWUgKz0gJyBqc3RyZWUtc2VhcmNoJztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiBvYmo7XG5cdFx0fTtcblx0fTtcblxuXHQvLyBoZWxwZXJzXG5cdChmdW5jdGlvbiAoJCkge1xuXHRcdC8vIGZyb20gaHR0cDovL2tpcm8ubWUvcHJvamVjdHMvZnVzZS5odG1sXG5cdFx0JC52YWthdGEuc2VhcmNoID0gZnVuY3Rpb24ocGF0dGVybiwgdHh0LCBvcHRpb25zKSB7XG5cdFx0XHRvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblx0XHRcdG9wdGlvbnMgPSAkLmV4dGVuZCh7fSwgJC52YWthdGEuc2VhcmNoLmRlZmF1bHRzLCBvcHRpb25zKTtcblx0XHRcdGlmKG9wdGlvbnMuZnV6enkgIT09IGZhbHNlKSB7XG5cdFx0XHRcdG9wdGlvbnMuZnV6enkgPSB0cnVlO1xuXHRcdFx0fVxuXHRcdFx0cGF0dGVybiA9IG9wdGlvbnMuY2FzZVNlbnNpdGl2ZSA/IHBhdHRlcm4gOiBwYXR0ZXJuLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHR2YXIgTUFUQ0hfTE9DQVRJT05cdD0gb3B0aW9ucy5sb2NhdGlvbixcblx0XHRcdFx0TUFUQ0hfRElTVEFOQ0VcdD0gb3B0aW9ucy5kaXN0YW5jZSxcblx0XHRcdFx0TUFUQ0hfVEhSRVNIT0xEXHQ9IG9wdGlvbnMudGhyZXNob2xkLFxuXHRcdFx0XHRwYXR0ZXJuTGVuID0gcGF0dGVybi5sZW5ndGgsXG5cdFx0XHRcdG1hdGNobWFzaywgcGF0dGVybl9hbHBoYWJldCwgbWF0Y2hfYml0YXBTY29yZSwgc2VhcmNoO1xuXHRcdFx0aWYocGF0dGVybkxlbiA+IDMyKSB7XG5cdFx0XHRcdG9wdGlvbnMuZnV6enkgPSBmYWxzZTtcblx0XHRcdH1cblx0XHRcdGlmKG9wdGlvbnMuZnV6enkpIHtcblx0XHRcdFx0bWF0Y2htYXNrID0gMSA8PCAocGF0dGVybkxlbiAtIDEpO1xuXHRcdFx0XHRwYXR0ZXJuX2FscGhhYmV0ID0gKGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0XHR2YXIgbWFzayA9IHt9LFxuXHRcdFx0XHRcdFx0aSA9IDA7XG5cdFx0XHRcdFx0Zm9yIChpID0gMDsgaSA8IHBhdHRlcm5MZW47IGkrKykge1xuXHRcdFx0XHRcdFx0bWFza1twYXR0ZXJuLmNoYXJBdChpKV0gPSAwO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRmb3IgKGkgPSAwOyBpIDwgcGF0dGVybkxlbjsgaSsrKSB7XG5cdFx0XHRcdFx0XHRtYXNrW3BhdHRlcm4uY2hhckF0KGkpXSB8PSAxIDw8IChwYXR0ZXJuTGVuIC0gaSAtIDEpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gbWFzaztcblx0XHRcdFx0fSgpKTtcblx0XHRcdFx0bWF0Y2hfYml0YXBTY29yZSA9IGZ1bmN0aW9uIChlLCB4KSB7XG5cdFx0XHRcdFx0dmFyIGFjY3VyYWN5ID0gZSAvIHBhdHRlcm5MZW4sXG5cdFx0XHRcdFx0XHRwcm94aW1pdHkgPSBNYXRoLmFicyhNQVRDSF9MT0NBVElPTiAtIHgpO1xuXHRcdFx0XHRcdGlmKCFNQVRDSF9ESVNUQU5DRSkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIHByb3hpbWl0eSA/IDEuMCA6IGFjY3VyYWN5O1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gYWNjdXJhY3kgKyAocHJveGltaXR5IC8gTUFUQ0hfRElTVEFOQ0UpO1xuXHRcdFx0XHR9O1xuXHRcdFx0fVxuXHRcdFx0c2VhcmNoID0gZnVuY3Rpb24gKHRleHQpIHtcblx0XHRcdFx0dGV4dCA9IG9wdGlvbnMuY2FzZVNlbnNpdGl2ZSA/IHRleHQgOiB0ZXh0LnRvTG93ZXJDYXNlKCk7XG5cdFx0XHRcdGlmKHBhdHRlcm4gPT09IHRleHQgfHwgdGV4dC5pbmRleE9mKHBhdHRlcm4pICE9PSAtMSkge1xuXHRcdFx0XHRcdHJldHVybiB7XG5cdFx0XHRcdFx0XHRpc01hdGNoOiB0cnVlLFxuXHRcdFx0XHRcdFx0c2NvcmU6IDBcblx0XHRcdFx0XHR9O1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmKCFvcHRpb25zLmZ1enp5KSB7XG5cdFx0XHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0XHRcdGlzTWF0Y2g6IGZhbHNlLFxuXHRcdFx0XHRcdFx0c2NvcmU6IDFcblx0XHRcdFx0XHR9O1xuXHRcdFx0XHR9XG5cdFx0XHRcdHZhciBpLCBqLFxuXHRcdFx0XHRcdHRleHRMZW4gPSB0ZXh0Lmxlbmd0aCxcblx0XHRcdFx0XHRzY29yZVRocmVzaG9sZCA9IE1BVENIX1RIUkVTSE9MRCxcblx0XHRcdFx0XHRiZXN0TG9jID0gdGV4dC5pbmRleE9mKHBhdHRlcm4sIE1BVENIX0xPQ0FUSU9OKSxcblx0XHRcdFx0XHRiaW5NaW4sIGJpbk1pZCxcblx0XHRcdFx0XHRiaW5NYXggPSBwYXR0ZXJuTGVuICsgdGV4dExlbixcblx0XHRcdFx0XHRsYXN0UmQsIHN0YXJ0LCBmaW5pc2gsIHJkLCBjaGFyTWF0Y2gsXG5cdFx0XHRcdFx0c2NvcmUgPSAxLFxuXHRcdFx0XHRcdGxvY2F0aW9ucyA9IFtdO1xuXHRcdFx0XHRpZiAoYmVzdExvYyAhPT0gLTEpIHtcblx0XHRcdFx0XHRzY29yZVRocmVzaG9sZCA9IE1hdGgubWluKG1hdGNoX2JpdGFwU2NvcmUoMCwgYmVzdExvYyksIHNjb3JlVGhyZXNob2xkKTtcblx0XHRcdFx0XHRiZXN0TG9jID0gdGV4dC5sYXN0SW5kZXhPZihwYXR0ZXJuLCBNQVRDSF9MT0NBVElPTiArIHBhdHRlcm5MZW4pO1xuXHRcdFx0XHRcdGlmIChiZXN0TG9jICE9PSAtMSkge1xuXHRcdFx0XHRcdFx0c2NvcmVUaHJlc2hvbGQgPSBNYXRoLm1pbihtYXRjaF9iaXRhcFNjb3JlKDAsIGJlc3RMb2MpLCBzY29yZVRocmVzaG9sZCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdGJlc3RMb2MgPSAtMTtcblx0XHRcdFx0Zm9yIChpID0gMDsgaSA8IHBhdHRlcm5MZW47IGkrKykge1xuXHRcdFx0XHRcdGJpbk1pbiA9IDA7XG5cdFx0XHRcdFx0YmluTWlkID0gYmluTWF4O1xuXHRcdFx0XHRcdHdoaWxlIChiaW5NaW4gPCBiaW5NaWQpIHtcblx0XHRcdFx0XHRcdGlmIChtYXRjaF9iaXRhcFNjb3JlKGksIE1BVENIX0xPQ0FUSU9OICsgYmluTWlkKSA8PSBzY29yZVRocmVzaG9sZCkge1xuXHRcdFx0XHRcdFx0XHRiaW5NaW4gPSBiaW5NaWQ7XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRiaW5NYXggPSBiaW5NaWQ7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRiaW5NaWQgPSBNYXRoLmZsb29yKChiaW5NYXggLSBiaW5NaW4pIC8gMiArIGJpbk1pbik7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGJpbk1heCA9IGJpbk1pZDtcblx0XHRcdFx0XHRzdGFydCA9IE1hdGgubWF4KDEsIE1BVENIX0xPQ0FUSU9OIC0gYmluTWlkICsgMSk7XG5cdFx0XHRcdFx0ZmluaXNoID0gTWF0aC5taW4oTUFUQ0hfTE9DQVRJT04gKyBiaW5NaWQsIHRleHRMZW4pICsgcGF0dGVybkxlbjtcblx0XHRcdFx0XHRyZCA9IG5ldyBBcnJheShmaW5pc2ggKyAyKTtcblx0XHRcdFx0XHRyZFtmaW5pc2ggKyAxXSA9ICgxIDw8IGkpIC0gMTtcblx0XHRcdFx0XHRmb3IgKGogPSBmaW5pc2g7IGogPj0gc3RhcnQ7IGotLSkge1xuXHRcdFx0XHRcdFx0Y2hhck1hdGNoID0gcGF0dGVybl9hbHBoYWJldFt0ZXh0LmNoYXJBdChqIC0gMSldO1xuXHRcdFx0XHRcdFx0aWYgKGkgPT09IDApIHtcblx0XHRcdFx0XHRcdFx0cmRbal0gPSAoKHJkW2ogKyAxXSA8PCAxKSB8IDEpICYgY2hhck1hdGNoO1xuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0cmRbal0gPSAoKHJkW2ogKyAxXSA8PCAxKSB8IDEpICYgY2hhck1hdGNoIHwgKCgobGFzdFJkW2ogKyAxXSB8IGxhc3RSZFtqXSkgPDwgMSkgfCAxKSB8IGxhc3RSZFtqICsgMV07XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRpZiAocmRbal0gJiBtYXRjaG1hc2spIHtcblx0XHRcdFx0XHRcdFx0c2NvcmUgPSBtYXRjaF9iaXRhcFNjb3JlKGksIGogLSAxKTtcblx0XHRcdFx0XHRcdFx0aWYgKHNjb3JlIDw9IHNjb3JlVGhyZXNob2xkKSB7XG5cdFx0XHRcdFx0XHRcdFx0c2NvcmVUaHJlc2hvbGQgPSBzY29yZTtcblx0XHRcdFx0XHRcdFx0XHRiZXN0TG9jID0gaiAtIDE7XG5cdFx0XHRcdFx0XHRcdFx0bG9jYXRpb25zLnB1c2goYmVzdExvYyk7XG5cdFx0XHRcdFx0XHRcdFx0aWYgKGJlc3RMb2MgPiBNQVRDSF9MT0NBVElPTikge1xuXHRcdFx0XHRcdFx0XHRcdFx0c3RhcnQgPSBNYXRoLm1heCgxLCAyICogTUFUQ0hfTE9DQVRJT04gLSBiZXN0TG9jKTtcblx0XHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmIChtYXRjaF9iaXRhcFNjb3JlKGkgKyAxLCBNQVRDSF9MT0NBVElPTikgPiBzY29yZVRocmVzaG9sZCkge1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGxhc3RSZCA9IHJkO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB7XG5cdFx0XHRcdFx0aXNNYXRjaDogYmVzdExvYyA+PSAwLFxuXHRcdFx0XHRcdHNjb3JlOiBzY29yZVxuXHRcdFx0XHR9O1xuXHRcdFx0fTtcblx0XHRcdHJldHVybiB0eHQgPT09IHRydWUgPyB7ICdzZWFyY2gnIDogc2VhcmNoIH0gOiBzZWFyY2godHh0KTtcblx0XHR9O1xuXHRcdCQudmFrYXRhLnNlYXJjaC5kZWZhdWx0cyA9IHtcblx0XHRcdGxvY2F0aW9uIDogMCxcblx0XHRcdGRpc3RhbmNlIDogMTAwLFxuXHRcdFx0dGhyZXNob2xkIDogMC42LFxuXHRcdFx0ZnV6enkgOiBmYWxzZSxcblx0XHRcdGNhc2VTZW5zaXRpdmUgOiBmYWxzZVxuXHRcdH07XG5cdH0oJCkpO1xuXG5cdC8vIGluY2x1ZGUgdGhlIHNlYXJjaCBwbHVnaW4gYnkgZGVmYXVsdFxuXHQvLyAkLmpzdHJlZS5kZWZhdWx0cy5wbHVnaW5zLnB1c2goXCJzZWFyY2hcIik7XG5cblxuLyoqXG4gKiAjIyMgU29ydCBwbHVnaW5cbiAqXG4gKiBBdXRvbWF0aWNhbGx5IHNvcnRzIGFsbCBzaWJsaW5ncyBpbiB0aGUgdHJlZSBhY2NvcmRpbmcgdG8gYSBzb3J0aW5nIGZ1bmN0aW9uLlxuICovXG5cblx0LyoqXG5cdCAqIHRoZSBzZXR0aW5ncyBmdW5jdGlvbiB1c2VkIHRvIHNvcnQgdGhlIG5vZGVzLlxuXHQgKiBJdCBpcyBleGVjdXRlZCBpbiB0aGUgdHJlZSdzIGNvbnRleHQsIGFjY2VwdHMgdHdvIG5vZGVzIGFzIGFyZ3VtZW50cyBhbmQgc2hvdWxkIHJldHVybiBgMWAgb3IgYC0xYC5cblx0ICogQG5hbWUgJC5qc3RyZWUuZGVmYXVsdHMuc29ydFxuXHQgKiBAcGx1Z2luIHNvcnRcblx0ICovXG5cdCQuanN0cmVlLmRlZmF1bHRzLnNvcnQgPSBmdW5jdGlvbiAoYSwgYikge1xuXHRcdC8vcmV0dXJuIHRoaXMuZ2V0X3R5cGUoYSkgPT09IHRoaXMuZ2V0X3R5cGUoYikgPyAodGhpcy5nZXRfdGV4dChhKSA+IHRoaXMuZ2V0X3RleHQoYikgPyAxIDogLTEpIDogdGhpcy5nZXRfdHlwZShhKSA+PSB0aGlzLmdldF90eXBlKGIpO1xuXHRcdHJldHVybiB0aGlzLmdldF90ZXh0KGEpID4gdGhpcy5nZXRfdGV4dChiKSA/IDEgOiAtMTtcblx0fTtcblx0JC5qc3RyZWUucGx1Z2lucy5zb3J0ID0gZnVuY3Rpb24gKG9wdGlvbnMsIHBhcmVudCkge1xuXHRcdHRoaXMuYmluZCA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdHBhcmVudC5iaW5kLmNhbGwodGhpcyk7XG5cdFx0XHR0aGlzLmVsZW1lbnRcblx0XHRcdFx0Lm9uKFwibW9kZWwuanN0cmVlXCIsICQucHJveHkoZnVuY3Rpb24gKGUsIGRhdGEpIHtcblx0XHRcdFx0XHRcdHRoaXMuc29ydChkYXRhLnBhcmVudCwgdHJ1ZSk7XG5cdFx0XHRcdFx0fSwgdGhpcykpXG5cdFx0XHRcdC5vbihcInJlbmFtZV9ub2RlLmpzdHJlZSBjcmVhdGVfbm9kZS5qc3RyZWVcIiwgJC5wcm94eShmdW5jdGlvbiAoZSwgZGF0YSkge1xuXHRcdFx0XHRcdFx0dGhpcy5zb3J0KGRhdGEucGFyZW50IHx8IGRhdGEubm9kZS5wYXJlbnQsIGZhbHNlKTtcblx0XHRcdFx0XHRcdHRoaXMucmVkcmF3X25vZGUoZGF0YS5wYXJlbnQgfHwgZGF0YS5ub2RlLnBhcmVudCwgdHJ1ZSk7XG5cdFx0XHRcdFx0fSwgdGhpcykpXG5cdFx0XHRcdC5vbihcIm1vdmVfbm9kZS5qc3RyZWUgY29weV9ub2RlLmpzdHJlZVwiLCAkLnByb3h5KGZ1bmN0aW9uIChlLCBkYXRhKSB7XG5cdFx0XHRcdFx0XHR0aGlzLnNvcnQoZGF0YS5wYXJlbnQsIGZhbHNlKTtcblx0XHRcdFx0XHRcdHRoaXMucmVkcmF3X25vZGUoZGF0YS5wYXJlbnQsIHRydWUpO1xuXHRcdFx0XHRcdH0sIHRoaXMpKTtcblx0XHR9O1xuXHRcdC8qKlxuXHRcdCAqIHVzZWQgdG8gc29ydCBhIG5vZGUncyBjaGlsZHJlblxuXHRcdCAqIEBwcml2YXRlXG5cdFx0ICogQG5hbWUgc29ydChvYmogWywgZGVlcF0pXG5cdFx0ICogQHBhcmFtICB7bWl4ZWR9IG9iaiB0aGUgbm9kZVxuXHRcdCAqIEBwYXJhbSB7Qm9vbGVhbn0gZGVlcCBpZiBzZXQgdG8gYHRydWVgIG5vZGVzIGFyZSBzb3J0ZWQgcmVjdXJzaXZlbHkuXG5cdFx0ICogQHBsdWdpbiBzb3J0XG5cdFx0ICogQHRyaWdnZXIgc2VhcmNoLmpzdHJlZVxuXHRcdCAqL1xuXHRcdHRoaXMuc29ydCA9IGZ1bmN0aW9uIChvYmosIGRlZXApIHtcblx0XHRcdHZhciBpLCBqO1xuXHRcdFx0b2JqID0gdGhpcy5nZXRfbm9kZShvYmopO1xuXHRcdFx0aWYob2JqICYmIG9iai5jaGlsZHJlbiAmJiBvYmouY2hpbGRyZW4ubGVuZ3RoKSB7XG5cdFx0XHRcdG9iai5jaGlsZHJlbi5zb3J0KCQucHJveHkodGhpcy5zZXR0aW5ncy5zb3J0LCB0aGlzKSk7XG5cdFx0XHRcdGlmKGRlZXApIHtcblx0XHRcdFx0XHRmb3IoaSA9IDAsIGogPSBvYmouY2hpbGRyZW5fZC5sZW5ndGg7IGkgPCBqOyBpKyspIHtcblx0XHRcdFx0XHRcdHRoaXMuc29ydChvYmouY2hpbGRyZW5fZFtpXSwgZmFsc2UpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH07XG5cdH07XG5cblx0Ly8gaW5jbHVkZSB0aGUgc29ydCBwbHVnaW4gYnkgZGVmYXVsdFxuXHQvLyAkLmpzdHJlZS5kZWZhdWx0cy5wbHVnaW5zLnB1c2goXCJzb3J0XCIpO1xuXG4vKipcbiAqICMjIyBTdGF0ZSBwbHVnaW5cbiAqXG4gKiBTYXZlcyB0aGUgc3RhdGUgb2YgdGhlIHRyZWUgKHNlbGVjdGVkIG5vZGVzLCBvcGVuZWQgbm9kZXMpIG9uIHRoZSB1c2VyJ3MgY29tcHV0ZXIgdXNpbmcgYXZhaWxhYmxlIG9wdGlvbnMgKGxvY2FsU3RvcmFnZSwgY29va2llcywgZXRjKVxuICovXG5cblx0dmFyIHRvID0gZmFsc2U7XG5cdC8qKlxuXHQgKiBzdG9yZXMgYWxsIGRlZmF1bHRzIGZvciB0aGUgc3RhdGUgcGx1Z2luXG5cdCAqIEBuYW1lICQuanN0cmVlLmRlZmF1bHRzLnN0YXRlXG5cdCAqIEBwbHVnaW4gc3RhdGVcblx0ICovXG5cdCQuanN0cmVlLmRlZmF1bHRzLnN0YXRlID0ge1xuXHRcdC8qKlxuXHRcdCAqIEEgc3RyaW5nIGZvciB0aGUga2V5IHRvIHVzZSB3aGVuIHNhdmluZyB0aGUgY3VycmVudCB0cmVlIChjaGFuZ2UgaWYgdXNpbmcgbXVsdGlwbGUgdHJlZXMgaW4geW91ciBwcm9qZWN0KS4gRGVmYXVsdHMgdG8gYGpzdHJlZWAuXG5cdFx0ICogQG5hbWUgJC5qc3RyZWUuZGVmYXVsdHMuc3RhdGUua2V5XG5cdFx0ICogQHBsdWdpbiBzdGF0ZVxuXHRcdCAqL1xuXHRcdGtleVx0XHQ6ICdqc3RyZWUnLFxuXHRcdC8qKlxuXHRcdCAqIEEgc3BhY2Ugc2VwYXJhdGVkIGxpc3Qgb2YgZXZlbnRzIHRoYXQgdHJpZ2dlciBhIHN0YXRlIHNhdmUuIERlZmF1bHRzIHRvIGBjaGFuZ2VkLmpzdHJlZSBvcGVuX25vZGUuanN0cmVlIGNsb3NlX25vZGUuanN0cmVlYC5cblx0XHQgKiBAbmFtZSAkLmpzdHJlZS5kZWZhdWx0cy5zdGF0ZS5ldmVudHNcblx0XHQgKiBAcGx1Z2luIHN0YXRlXG5cdFx0ICovXG5cdFx0ZXZlbnRzXHQ6ICdjaGFuZ2VkLmpzdHJlZSBvcGVuX25vZGUuanN0cmVlIGNsb3NlX25vZGUuanN0cmVlIGNoZWNrX25vZGUuanN0cmVlIHVuY2hlY2tfbm9kZS5qc3RyZWUnLFxuXHRcdC8qKlxuXHRcdCAqIFRpbWUgaW4gbWlsbGlzZWNvbmRzIGFmdGVyIHdoaWNoIHRoZSBzdGF0ZSB3aWxsIGV4cGlyZS4gRGVmYXVsdHMgdG8gJ2ZhbHNlJyBtZWFuaW5nIC0gbm8gZXhwaXJlLlxuXHRcdCAqIEBuYW1lICQuanN0cmVlLmRlZmF1bHRzLnN0YXRlLnR0bFxuXHRcdCAqIEBwbHVnaW4gc3RhdGVcblx0XHQgKi9cblx0XHR0dGxcdFx0OiBmYWxzZSxcblx0XHQvKipcblx0XHQgKiBBIGZ1bmN0aW9uIHRoYXQgd2lsbCBiZSBleGVjdXRlZCBwcmlvciB0byByZXN0b3Jpbmcgc3RhdGUgd2l0aCBvbmUgYXJndW1lbnQgLSB0aGUgc3RhdGUgb2JqZWN0LiBDYW4gYmUgdXNlZCB0byBjbGVhciB1bndhbnRlZCBwYXJ0cyBvZiB0aGUgc3RhdGUuXG5cdFx0ICogQG5hbWUgJC5qc3RyZWUuZGVmYXVsdHMuc3RhdGUuZmlsdGVyXG5cdFx0ICogQHBsdWdpbiBzdGF0ZVxuXHRcdCAqL1xuXHRcdGZpbHRlclx0OiBmYWxzZVxuXHR9O1xuXHQkLmpzdHJlZS5wbHVnaW5zLnN0YXRlID0gZnVuY3Rpb24gKG9wdGlvbnMsIHBhcmVudCkge1xuXHRcdHRoaXMuYmluZCA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdHBhcmVudC5iaW5kLmNhbGwodGhpcyk7XG5cdFx0XHR2YXIgYmluZCA9ICQucHJveHkoZnVuY3Rpb24gKCkge1xuXHRcdFx0XHR0aGlzLmVsZW1lbnQub24odGhpcy5zZXR0aW5ncy5zdGF0ZS5ldmVudHMsICQucHJveHkoZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdGlmKHRvKSB7IGNsZWFyVGltZW91dCh0byk7IH1cblx0XHRcdFx0XHR0byA9IHNldFRpbWVvdXQoJC5wcm94eShmdW5jdGlvbiAoKSB7IHRoaXMuc2F2ZV9zdGF0ZSgpOyB9LCB0aGlzKSwgMTAwKTtcblx0XHRcdFx0fSwgdGhpcykpO1xuXHRcdFx0XHQvKipcblx0XHRcdFx0ICogdHJpZ2dlcmVkIHdoZW4gdGhlIHN0YXRlIHBsdWdpbiBpcyBmaW5pc2hlZCByZXN0b3JpbmcgdGhlIHN0YXRlIChhbmQgaW1tZWRpYXRlbHkgYWZ0ZXIgcmVhZHkgaWYgdGhlcmUgaXMgbm8gc3RhdGUgdG8gcmVzdG9yZSkuXG5cdFx0XHRcdCAqIEBldmVudFxuXHRcdFx0XHQgKiBAbmFtZSBzdGF0ZV9yZWFkeS5qc3RyZWVcblx0XHRcdFx0ICogQHBsdWdpbiBzdGF0ZVxuXHRcdFx0XHQgKi9cblx0XHRcdFx0dGhpcy50cmlnZ2VyKCdzdGF0ZV9yZWFkeScpO1xuXHRcdFx0fSwgdGhpcyk7XG5cdFx0XHR0aGlzLmVsZW1lbnRcblx0XHRcdFx0Lm9uKFwicmVhZHkuanN0cmVlXCIsICQucHJveHkoZnVuY3Rpb24gKGUsIGRhdGEpIHtcblx0XHRcdFx0XHRcdHRoaXMuZWxlbWVudC5vbmUoXCJyZXN0b3JlX3N0YXRlLmpzdHJlZVwiLCBiaW5kKTtcblx0XHRcdFx0XHRcdGlmKCF0aGlzLnJlc3RvcmVfc3RhdGUoKSkgeyBiaW5kKCk7IH1cblx0XHRcdFx0XHR9LCB0aGlzKSk7XG5cdFx0fTtcblx0XHQvKipcblx0XHQgKiBzYXZlIHRoZSBzdGF0ZVxuXHRcdCAqIEBuYW1lIHNhdmVfc3RhdGUoKVxuXHRcdCAqIEBwbHVnaW4gc3RhdGVcblx0XHQgKi9cblx0XHR0aGlzLnNhdmVfc3RhdGUgPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHR2YXIgc3QgPSB7ICdzdGF0ZScgOiB0aGlzLmdldF9zdGF0ZSgpLCAndHRsJyA6IHRoaXMuc2V0dGluZ3Muc3RhdGUudHRsLCAnc2VjJyA6ICsobmV3IERhdGUoKSkgfTtcblx0XHRcdCQudmFrYXRhLnN0b3JhZ2Uuc2V0KHRoaXMuc2V0dGluZ3Muc3RhdGUua2V5LCBKU09OLnN0cmluZ2lmeShzdCkpO1xuXHRcdH07XG5cdFx0LyoqXG5cdFx0ICogcmVzdG9yZSB0aGUgc3RhdGUgZnJvbSB0aGUgdXNlcidzIGNvbXB1dGVyXG5cdFx0ICogQG5hbWUgcmVzdG9yZV9zdGF0ZSgpXG5cdFx0ICogQHBsdWdpbiBzdGF0ZVxuXHRcdCAqL1xuXHRcdHRoaXMucmVzdG9yZV9zdGF0ZSA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdHZhciBrID0gJC52YWthdGEuc3RvcmFnZS5nZXQodGhpcy5zZXR0aW5ncy5zdGF0ZS5rZXkpO1xuXHRcdFx0aWYoISFrKSB7IHRyeSB7IGsgPSBKU09OLnBhcnNlKGspOyB9IGNhdGNoKGV4KSB7IHJldHVybiBmYWxzZTsgfSB9XG5cdFx0XHRpZighIWsgJiYgay50dGwgJiYgay5zZWMgJiYgKyhuZXcgRGF0ZSgpKSAtIGsuc2VjID4gay50dGwpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdFx0XHRpZighIWsgJiYgay5zdGF0ZSkgeyBrID0gay5zdGF0ZTsgfVxuXHRcdFx0aWYoISFrICYmICQuaXNGdW5jdGlvbih0aGlzLnNldHRpbmdzLnN0YXRlLmZpbHRlcikpIHsgayA9IHRoaXMuc2V0dGluZ3Muc3RhdGUuZmlsdGVyLmNhbGwodGhpcywgayk7IH1cblx0XHRcdGlmKCEhaykge1xuXHRcdFx0XHR0aGlzLmVsZW1lbnQub25lKFwic2V0X3N0YXRlLmpzdHJlZVwiLCBmdW5jdGlvbiAoZSwgZGF0YSkgeyBkYXRhLmluc3RhbmNlLnRyaWdnZXIoJ3Jlc3RvcmVfc3RhdGUnLCB7ICdzdGF0ZScgOiAkLmV4dGVuZCh0cnVlLCB7fSwgaykgfSk7IH0pO1xuXHRcdFx0XHR0aGlzLnNldF9zdGF0ZShrKTtcblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fTtcblx0XHQvKipcblx0XHQgKiBjbGVhciB0aGUgc3RhdGUgb24gdGhlIHVzZXIncyBjb21wdXRlclxuXHRcdCAqIEBuYW1lIGNsZWFyX3N0YXRlKClcblx0XHQgKiBAcGx1Z2luIHN0YXRlXG5cdFx0ICovXG5cdFx0dGhpcy5jbGVhcl9zdGF0ZSA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdHJldHVybiAkLnZha2F0YS5zdG9yYWdlLmRlbCh0aGlzLnNldHRpbmdzLnN0YXRlLmtleSk7XG5cdFx0fTtcblx0fTtcblxuXHQoZnVuY3Rpb24gKCQsIHVuZGVmaW5lZCkge1xuXHRcdCQudmFrYXRhLnN0b3JhZ2UgPSB7XG5cdFx0XHQvLyBzaW1wbHkgc3BlY2lmeWluZyB0aGUgZnVuY3Rpb25zIGluIEZGIHRocm93cyBhbiBlcnJvclxuXHRcdFx0c2V0IDogZnVuY3Rpb24gKGtleSwgdmFsKSB7IHJldHVybiB3aW5kb3cubG9jYWxTdG9yYWdlLnNldEl0ZW0oa2V5LCB2YWwpOyB9LFxuXHRcdFx0Z2V0IDogZnVuY3Rpb24gKGtleSkgeyByZXR1cm4gd2luZG93LmxvY2FsU3RvcmFnZS5nZXRJdGVtKGtleSk7IH0sXG5cdFx0XHRkZWwgOiBmdW5jdGlvbiAoa2V5KSB7IHJldHVybiB3aW5kb3cubG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0oa2V5KTsgfVxuXHRcdH07XG5cdH0oJCkpO1xuXG5cdC8vIGluY2x1ZGUgdGhlIHN0YXRlIHBsdWdpbiBieSBkZWZhdWx0XG5cdC8vICQuanN0cmVlLmRlZmF1bHRzLnBsdWdpbnMucHVzaChcInN0YXRlXCIpO1xuXG4vKipcbiAqICMjIyBUeXBlcyBwbHVnaW5cbiAqXG4gKiBNYWtlcyBpdCBwb3NzaWJsZSB0byBhZGQgcHJlZGVmaW5lZCB0eXBlcyBmb3IgZ3JvdXBzIG9mIG5vZGVzLCB3aGljaCBtYWtlIGl0IHBvc3NpYmxlIHRvIGVhc2lseSBjb250cm9sIG5lc3RpbmcgcnVsZXMgYW5kIGljb24gZm9yIGVhY2ggZ3JvdXAuXG4gKi9cblxuXHQvKipcblx0ICogQW4gb2JqZWN0IHN0b3JpbmcgYWxsIHR5cGVzIGFzIGtleSB2YWx1ZSBwYWlycywgd2hlcmUgdGhlIGtleSBpcyB0aGUgdHlwZSBuYW1lIGFuZCB0aGUgdmFsdWUgaXMgYW4gb2JqZWN0IHRoYXQgY291bGQgY29udGFpbiBmb2xsb3dpbmcga2V5cyAoYWxsIG9wdGlvbmFsKS5cblx0ICpcblx0ICogKiBgbWF4X2NoaWxkcmVuYCB0aGUgbWF4aW11bSBudW1iZXIgb2YgaW1tZWRpYXRlIGNoaWxkcmVuIHRoaXMgbm9kZSB0eXBlIGNhbiBoYXZlLiBEbyBub3Qgc3BlY2lmeSBvciBzZXQgdG8gYC0xYCBmb3IgdW5saW1pdGVkLlxuXHQgKiAqIGBtYXhfZGVwdGhgIHRoZSBtYXhpbXVtIG51bWJlciBvZiBuZXN0aW5nIHRoaXMgbm9kZSB0eXBlIGNhbiBoYXZlLiBBIHZhbHVlIG9mIGAxYCB3b3VsZCBtZWFuIHRoYXQgdGhlIG5vZGUgY2FuIGhhdmUgY2hpbGRyZW4sIGJ1dCBubyBncmFuZGNoaWxkcmVuLiBEbyBub3Qgc3BlY2lmeSBvciBzZXQgdG8gYC0xYCBmb3IgdW5saW1pdGVkLlxuXHQgKiAqIGB2YWxpZF9jaGlsZHJlbmAgYW4gYXJyYXkgb2Ygbm9kZSB0eXBlIHN0cmluZ3MsIHRoYXQgbm9kZXMgb2YgdGhpcyB0eXBlIGNhbiBoYXZlIGFzIGNoaWxkcmVuLiBEbyBub3Qgc3BlY2lmeSBvciBzZXQgdG8gYC0xYCBmb3Igbm8gbGltaXRzLlxuXHQgKiAqIGBpY29uYCBhIHN0cmluZyAtIGNhbiBiZSBhIHBhdGggdG8gYW4gaWNvbiBvciBhIGNsYXNzTmFtZSwgaWYgdXNpbmcgYW4gaW1hZ2UgdGhhdCBpcyBpbiB0aGUgY3VycmVudCBkaXJlY3RvcnkgdXNlIGEgYC4vYCBwcmVmaXgsIG90aGVyd2lzZSBpdCB3aWxsIGJlIGRldGVjdGVkIGFzIGEgY2xhc3MuIE9taXQgdG8gdXNlIHRoZSBkZWZhdWx0IGljb24gZnJvbSB5b3VyIHRoZW1lLlxuXHQgKiAqIGBsaV9hdHRyYCBhbiBvYmplY3Qgb2YgdmFsdWVzIHdoaWNoIHdpbGwgYmUgdXNlZCB0byBhZGQgSFRNTCBhdHRyaWJ1dGVzIG9uIHRoZSByZXN1bHRpbmcgTEkgRE9NIG5vZGUgKG1lcmdlZCB3aXRoIHRoZSBub2RlJ3Mgb3duIGRhdGEpXG5cdCAqICogYGFfYXR0cmAgYW4gb2JqZWN0IG9mIHZhbHVlcyB3aGljaCB3aWxsIGJlIHVzZWQgdG8gYWRkIEhUTUwgYXR0cmlidXRlcyBvbiB0aGUgcmVzdWx0aW5nIEEgRE9NIG5vZGUgKG1lcmdlZCB3aXRoIHRoZSBub2RlJ3Mgb3duIGRhdGEpXG5cdCAqXG5cdCAqIFRoZXJlIGFyZSB0d28gcHJlZGVmaW5lZCB0eXBlczpcblx0ICpcblx0ICogKiBgI2AgcmVwcmVzZW50cyB0aGUgcm9vdCBvZiB0aGUgdHJlZSwgZm9yIGV4YW1wbGUgYG1heF9jaGlsZHJlbmAgd291bGQgY29udHJvbCB0aGUgbWF4aW11bSBudW1iZXIgb2Ygcm9vdCBub2Rlcy5cblx0ICogKiBgZGVmYXVsdGAgcmVwcmVzZW50cyB0aGUgZGVmYXVsdCBub2RlIC0gYW55IHNldHRpbmdzIGhlcmUgd2lsbCBiZSBhcHBsaWVkIHRvIGFsbCBub2RlcyB0aGF0IGRvIG5vdCBoYXZlIGEgdHlwZSBzcGVjaWZpZWQuXG5cdCAqXG5cdCAqIEBuYW1lICQuanN0cmVlLmRlZmF1bHRzLnR5cGVzXG5cdCAqIEBwbHVnaW4gdHlwZXNcblx0ICovXG5cdCQuanN0cmVlLmRlZmF1bHRzLnR5cGVzID0ge1xuXHRcdCdkZWZhdWx0JyA6IHt9XG5cdH07XG5cdCQuanN0cmVlLmRlZmF1bHRzLnR5cGVzWyQuanN0cmVlLnJvb3RdID0ge307XG5cblx0JC5qc3RyZWUucGx1Z2lucy50eXBlcyA9IGZ1bmN0aW9uIChvcHRpb25zLCBwYXJlbnQpIHtcblx0XHR0aGlzLmluaXQgPSBmdW5jdGlvbiAoZWwsIG9wdGlvbnMpIHtcblx0XHRcdHZhciBpLCBqO1xuXHRcdFx0aWYob3B0aW9ucyAmJiBvcHRpb25zLnR5cGVzICYmIG9wdGlvbnMudHlwZXNbJ2RlZmF1bHQnXSkge1xuXHRcdFx0XHRmb3IoaSBpbiBvcHRpb25zLnR5cGVzKSB7XG5cdFx0XHRcdFx0aWYoaSAhPT0gXCJkZWZhdWx0XCIgJiYgaSAhPT0gJC5qc3RyZWUucm9vdCAmJiBvcHRpb25zLnR5cGVzLmhhc093blByb3BlcnR5KGkpKSB7XG5cdFx0XHRcdFx0XHRmb3IoaiBpbiBvcHRpb25zLnR5cGVzWydkZWZhdWx0J10pIHtcblx0XHRcdFx0XHRcdFx0aWYob3B0aW9ucy50eXBlc1snZGVmYXVsdCddLmhhc093blByb3BlcnR5KGopICYmIG9wdGlvbnMudHlwZXNbaV1bal0gPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRcdFx0XHRcdG9wdGlvbnMudHlwZXNbaV1bal0gPSBvcHRpb25zLnR5cGVzWydkZWZhdWx0J11bal07XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHBhcmVudC5pbml0LmNhbGwodGhpcywgZWwsIG9wdGlvbnMpO1xuXHRcdFx0dGhpcy5fbW9kZWwuZGF0YVskLmpzdHJlZS5yb290XS50eXBlID0gJC5qc3RyZWUucm9vdDtcblx0XHR9O1xuXHRcdHRoaXMucmVmcmVzaCA9IGZ1bmN0aW9uIChza2lwX2xvYWRpbmcsIGZvcmdldF9zdGF0ZSkge1xuXHRcdFx0cGFyZW50LnJlZnJlc2guY2FsbCh0aGlzLCBza2lwX2xvYWRpbmcsIGZvcmdldF9zdGF0ZSk7XG5cdFx0XHR0aGlzLl9tb2RlbC5kYXRhWyQuanN0cmVlLnJvb3RdLnR5cGUgPSAkLmpzdHJlZS5yb290O1xuXHRcdH07XG5cdFx0dGhpcy5iaW5kID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0dGhpcy5lbGVtZW50XG5cdFx0XHRcdC5vbignbW9kZWwuanN0cmVlJywgJC5wcm94eShmdW5jdGlvbiAoZSwgZGF0YSkge1xuXHRcdFx0XHRcdFx0dmFyIG0gPSB0aGlzLl9tb2RlbC5kYXRhLFxuXHRcdFx0XHRcdFx0XHRkcGMgPSBkYXRhLm5vZGVzLFxuXHRcdFx0XHRcdFx0XHR0ID0gdGhpcy5zZXR0aW5ncy50eXBlcyxcblx0XHRcdFx0XHRcdFx0aSwgaiwgYyA9ICdkZWZhdWx0Jywgaztcblx0XHRcdFx0XHRcdGZvcihpID0gMCwgaiA9IGRwYy5sZW5ndGg7IGkgPCBqOyBpKyspIHtcblx0XHRcdFx0XHRcdFx0YyA9ICdkZWZhdWx0Jztcblx0XHRcdFx0XHRcdFx0aWYobVtkcGNbaV1dLm9yaWdpbmFsICYmIG1bZHBjW2ldXS5vcmlnaW5hbC50eXBlICYmIHRbbVtkcGNbaV1dLm9yaWdpbmFsLnR5cGVdKSB7XG5cdFx0XHRcdFx0XHRcdFx0YyA9IG1bZHBjW2ldXS5vcmlnaW5hbC50eXBlO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdGlmKG1bZHBjW2ldXS5kYXRhICYmIG1bZHBjW2ldXS5kYXRhLmpzdHJlZSAmJiBtW2RwY1tpXV0uZGF0YS5qc3RyZWUudHlwZSAmJiB0W21bZHBjW2ldXS5kYXRhLmpzdHJlZS50eXBlXSkge1xuXHRcdFx0XHRcdFx0XHRcdGMgPSBtW2RwY1tpXV0uZGF0YS5qc3RyZWUudHlwZTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRtW2RwY1tpXV0udHlwZSA9IGM7XG5cdFx0XHRcdFx0XHRcdGlmKG1bZHBjW2ldXS5pY29uID09PSB0cnVlICYmIHRbY10uaWNvbiAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdFx0XHRcdFx0bVtkcGNbaV1dLmljb24gPSB0W2NdLmljb247XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0aWYodFtjXS5saV9hdHRyICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIHRbY10ubGlfYXR0ciA9PT0gJ29iamVjdCcpIHtcblx0XHRcdFx0XHRcdFx0XHRmb3IgKGsgaW4gdFtjXS5saV9hdHRyKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRpZiAodFtjXS5saV9hdHRyLmhhc093blByb3BlcnR5KGspKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlmIChrID09PSAnaWQnKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0ZWxzZSBpZiAobVtkcGNbaV1dLmxpX2F0dHJba10gPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdG1bZHBjW2ldXS5saV9hdHRyW2tdID0gdFtjXS5saV9hdHRyW2tdO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGVsc2UgaWYgKGsgPT09ICdjbGFzcycpIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRtW2RwY1tpXV0ubGlfYXR0clsnY2xhc3MnXSA9IHRbY10ubGlfYXR0clsnY2xhc3MnXSArICcgJyArIG1bZHBjW2ldXS5saV9hdHRyWydjbGFzcyddO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdGlmKHRbY10uYV9hdHRyICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIHRbY10uYV9hdHRyID09PSAnb2JqZWN0Jykge1xuXHRcdFx0XHRcdFx0XHRcdGZvciAoayBpbiB0W2NdLmFfYXR0cikge1xuXHRcdFx0XHRcdFx0XHRcdFx0aWYgKHRbY10uYV9hdHRyLmhhc093blByb3BlcnR5KGspKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlmIChrID09PSAnaWQnKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0ZWxzZSBpZiAobVtkcGNbaV1dLmFfYXR0cltrXSA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0bVtkcGNbaV1dLmFfYXR0cltrXSA9IHRbY10uYV9hdHRyW2tdO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGVsc2UgaWYgKGsgPT09ICdocmVmJyAmJiBtW2RwY1tpXV0uYV9hdHRyW2tdID09PSAnIycpIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRtW2RwY1tpXV0uYV9hdHRyWydocmVmJ10gPSB0W2NdLmFfYXR0clsnaHJlZiddO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGVsc2UgaWYgKGsgPT09ICdjbGFzcycpIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRtW2RwY1tpXV0uYV9hdHRyWydjbGFzcyddID0gdFtjXS5hX2F0dHJbJ2NsYXNzJ10gKyAnICcgKyBtW2RwY1tpXV0uYV9hdHRyWydjbGFzcyddO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRtWyQuanN0cmVlLnJvb3RdLnR5cGUgPSAkLmpzdHJlZS5yb290O1xuXHRcdFx0XHRcdH0sIHRoaXMpKTtcblx0XHRcdHBhcmVudC5iaW5kLmNhbGwodGhpcyk7XG5cdFx0fTtcblx0XHR0aGlzLmdldF9qc29uID0gZnVuY3Rpb24gKG9iaiwgb3B0aW9ucywgZmxhdCkge1xuXHRcdFx0dmFyIGksIGosXG5cdFx0XHRcdG0gPSB0aGlzLl9tb2RlbC5kYXRhLFxuXHRcdFx0XHRvcHQgPSBvcHRpb25zID8gJC5leHRlbmQodHJ1ZSwge30sIG9wdGlvbnMsIHtub19pZDpmYWxzZX0pIDoge30sXG5cdFx0XHRcdHRtcCA9IHBhcmVudC5nZXRfanNvbi5jYWxsKHRoaXMsIG9iaiwgb3B0LCBmbGF0KTtcblx0XHRcdGlmKHRtcCA9PT0gZmFsc2UpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdFx0XHRpZigkLmlzQXJyYXkodG1wKSkge1xuXHRcdFx0XHRmb3IoaSA9IDAsIGogPSB0bXAubGVuZ3RoOyBpIDwgajsgaSsrKSB7XG5cdFx0XHRcdFx0dG1wW2ldLnR5cGUgPSB0bXBbaV0uaWQgJiYgbVt0bXBbaV0uaWRdICYmIG1bdG1wW2ldLmlkXS50eXBlID8gbVt0bXBbaV0uaWRdLnR5cGUgOiBcImRlZmF1bHRcIjtcblx0XHRcdFx0XHRpZihvcHRpb25zICYmIG9wdGlvbnMubm9faWQpIHtcblx0XHRcdFx0XHRcdGRlbGV0ZSB0bXBbaV0uaWQ7XG5cdFx0XHRcdFx0XHRpZih0bXBbaV0ubGlfYXR0ciAmJiB0bXBbaV0ubGlfYXR0ci5pZCkge1xuXHRcdFx0XHRcdFx0XHRkZWxldGUgdG1wW2ldLmxpX2F0dHIuaWQ7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRpZih0bXBbaV0uYV9hdHRyICYmIHRtcFtpXS5hX2F0dHIuaWQpIHtcblx0XHRcdFx0XHRcdFx0ZGVsZXRlIHRtcFtpXS5hX2F0dHIuaWQ7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRlbHNlIHtcblx0XHRcdFx0dG1wLnR5cGUgPSB0bXAuaWQgJiYgbVt0bXAuaWRdICYmIG1bdG1wLmlkXS50eXBlID8gbVt0bXAuaWRdLnR5cGUgOiBcImRlZmF1bHRcIjtcblx0XHRcdFx0aWYob3B0aW9ucyAmJiBvcHRpb25zLm5vX2lkKSB7XG5cdFx0XHRcdFx0dG1wID0gdGhpcy5fZGVsZXRlX2lkcyh0bXApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdG1wO1xuXHRcdH07XG5cdFx0dGhpcy5fZGVsZXRlX2lkcyA9IGZ1bmN0aW9uICh0bXApIHtcblx0XHRcdGlmKCQuaXNBcnJheSh0bXApKSB7XG5cdFx0XHRcdGZvcih2YXIgaSA9IDAsIGogPSB0bXAubGVuZ3RoOyBpIDwgajsgaSsrKSB7XG5cdFx0XHRcdFx0dG1wW2ldID0gdGhpcy5fZGVsZXRlX2lkcyh0bXBbaV0pO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB0bXA7XG5cdFx0XHR9XG5cdFx0XHRkZWxldGUgdG1wLmlkO1xuXHRcdFx0aWYodG1wLmxpX2F0dHIgJiYgdG1wLmxpX2F0dHIuaWQpIHtcblx0XHRcdFx0ZGVsZXRlIHRtcC5saV9hdHRyLmlkO1xuXHRcdFx0fVxuXHRcdFx0aWYodG1wLmFfYXR0ciAmJiB0bXAuYV9hdHRyLmlkKSB7XG5cdFx0XHRcdGRlbGV0ZSB0bXAuYV9hdHRyLmlkO1xuXHRcdFx0fVxuXHRcdFx0aWYodG1wLmNoaWxkcmVuICYmICQuaXNBcnJheSh0bXAuY2hpbGRyZW4pKSB7XG5cdFx0XHRcdHRtcC5jaGlsZHJlbiA9IHRoaXMuX2RlbGV0ZV9pZHModG1wLmNoaWxkcmVuKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiB0bXA7XG5cdFx0fTtcblx0XHR0aGlzLmNoZWNrID0gZnVuY3Rpb24gKGNoaywgb2JqLCBwYXIsIHBvcywgbW9yZSkge1xuXHRcdFx0aWYocGFyZW50LmNoZWNrLmNhbGwodGhpcywgY2hrLCBvYmosIHBhciwgcG9zLCBtb3JlKSA9PT0gZmFsc2UpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdFx0XHRvYmogPSBvYmogJiYgb2JqLmlkID8gb2JqIDogdGhpcy5nZXRfbm9kZShvYmopO1xuXHRcdFx0cGFyID0gcGFyICYmIHBhci5pZCA/IHBhciA6IHRoaXMuZ2V0X25vZGUocGFyKTtcblx0XHRcdHZhciBtID0gb2JqICYmIG9iai5pZCA/IChtb3JlICYmIG1vcmUub3JpZ2luID8gbW9yZS5vcmlnaW4gOiAkLmpzdHJlZS5yZWZlcmVuY2Uob2JqLmlkKSkgOiBudWxsLCB0bXAsIGQsIGksIGo7XG5cdFx0XHRtID0gbSAmJiBtLl9tb2RlbCAmJiBtLl9tb2RlbC5kYXRhID8gbS5fbW9kZWwuZGF0YSA6IG51bGw7XG5cdFx0XHRzd2l0Y2goY2hrKSB7XG5cdFx0XHRcdGNhc2UgXCJjcmVhdGVfbm9kZVwiOlxuXHRcdFx0XHRjYXNlIFwibW92ZV9ub2RlXCI6XG5cdFx0XHRcdGNhc2UgXCJjb3B5X25vZGVcIjpcblx0XHRcdFx0XHRpZihjaGsgIT09ICdtb3ZlX25vZGUnIHx8ICQuaW5BcnJheShvYmouaWQsIHBhci5jaGlsZHJlbikgPT09IC0xKSB7XG5cdFx0XHRcdFx0XHR0bXAgPSB0aGlzLmdldF9ydWxlcyhwYXIpO1xuXHRcdFx0XHRcdFx0aWYodG1wLm1heF9jaGlsZHJlbiAhPT0gdW5kZWZpbmVkICYmIHRtcC5tYXhfY2hpbGRyZW4gIT09IC0xICYmIHRtcC5tYXhfY2hpbGRyZW4gPT09IHBhci5jaGlsZHJlbi5sZW5ndGgpIHtcblx0XHRcdFx0XHRcdFx0dGhpcy5fZGF0YS5jb3JlLmxhc3RfZXJyb3IgPSB7ICdlcnJvcicgOiAnY2hlY2snLCAncGx1Z2luJyA6ICd0eXBlcycsICdpZCcgOiAndHlwZXNfMDEnLCAncmVhc29uJyA6ICdtYXhfY2hpbGRyZW4gcHJldmVudHMgZnVuY3Rpb246ICcgKyBjaGssICdkYXRhJyA6IEpTT04uc3RyaW5naWZ5KHsgJ2NoaycgOiBjaGssICdwb3MnIDogcG9zLCAnb2JqJyA6IG9iaiAmJiBvYmouaWQgPyBvYmouaWQgOiBmYWxzZSwgJ3BhcicgOiBwYXIgJiYgcGFyLmlkID8gcGFyLmlkIDogZmFsc2UgfSkgfTtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0aWYodG1wLnZhbGlkX2NoaWxkcmVuICE9PSB1bmRlZmluZWQgJiYgdG1wLnZhbGlkX2NoaWxkcmVuICE9PSAtMSAmJiAkLmluQXJyYXkoKG9iai50eXBlIHx8ICdkZWZhdWx0JyksIHRtcC52YWxpZF9jaGlsZHJlbikgPT09IC0xKSB7XG5cdFx0XHRcdFx0XHRcdHRoaXMuX2RhdGEuY29yZS5sYXN0X2Vycm9yID0geyAnZXJyb3InIDogJ2NoZWNrJywgJ3BsdWdpbicgOiAndHlwZXMnLCAnaWQnIDogJ3R5cGVzXzAyJywgJ3JlYXNvbicgOiAndmFsaWRfY2hpbGRyZW4gcHJldmVudHMgZnVuY3Rpb246ICcgKyBjaGssICdkYXRhJyA6IEpTT04uc3RyaW5naWZ5KHsgJ2NoaycgOiBjaGssICdwb3MnIDogcG9zLCAnb2JqJyA6IG9iaiAmJiBvYmouaWQgPyBvYmouaWQgOiBmYWxzZSwgJ3BhcicgOiBwYXIgJiYgcGFyLmlkID8gcGFyLmlkIDogZmFsc2UgfSkgfTtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0aWYobSAmJiBvYmouY2hpbGRyZW5fZCAmJiBvYmoucGFyZW50cykge1xuXHRcdFx0XHRcdFx0XHRkID0gMDtcblx0XHRcdFx0XHRcdFx0Zm9yKGkgPSAwLCBqID0gb2JqLmNoaWxkcmVuX2QubGVuZ3RoOyBpIDwgajsgaSsrKSB7XG5cdFx0XHRcdFx0XHRcdFx0ZCA9IE1hdGgubWF4KGQsIG1bb2JqLmNoaWxkcmVuX2RbaV1dLnBhcmVudHMubGVuZ3RoKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRkID0gZCAtIG9iai5wYXJlbnRzLmxlbmd0aCArIDE7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRpZihkIDw9IDAgfHwgZCA9PT0gdW5kZWZpbmVkKSB7IGQgPSAxOyB9XG5cdFx0XHRcdFx0XHRkbyB7XG5cdFx0XHRcdFx0XHRcdGlmKHRtcC5tYXhfZGVwdGggIT09IHVuZGVmaW5lZCAmJiB0bXAubWF4X2RlcHRoICE9PSAtMSAmJiB0bXAubWF4X2RlcHRoIDwgZCkge1xuXHRcdFx0XHRcdFx0XHRcdHRoaXMuX2RhdGEuY29yZS5sYXN0X2Vycm9yID0geyAnZXJyb3InIDogJ2NoZWNrJywgJ3BsdWdpbicgOiAndHlwZXMnLCAnaWQnIDogJ3R5cGVzXzAzJywgJ3JlYXNvbicgOiAnbWF4X2RlcHRoIHByZXZlbnRzIGZ1bmN0aW9uOiAnICsgY2hrLCAnZGF0YScgOiBKU09OLnN0cmluZ2lmeSh7ICdjaGsnIDogY2hrLCAncG9zJyA6IHBvcywgJ29iaicgOiBvYmogJiYgb2JqLmlkID8gb2JqLmlkIDogZmFsc2UsICdwYXInIDogcGFyICYmIHBhci5pZCA/IHBhci5pZCA6IGZhbHNlIH0pIH07XG5cdFx0XHRcdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdHBhciA9IHRoaXMuZ2V0X25vZGUocGFyLnBhcmVudCk7XG5cdFx0XHRcdFx0XHRcdHRtcCA9IHRoaXMuZ2V0X3J1bGVzKHBhcik7XG5cdFx0XHRcdFx0XHRcdGQrKztcblx0XHRcdFx0XHRcdH0gd2hpbGUocGFyKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9O1xuXHRcdC8qKlxuXHRcdCAqIHVzZWQgdG8gcmV0cmlldmUgdGhlIHR5cGUgc2V0dGluZ3Mgb2JqZWN0IGZvciBhIG5vZGVcblx0XHQgKiBAbmFtZSBnZXRfcnVsZXMob2JqKVxuXHRcdCAqIEBwYXJhbSB7bWl4ZWR9IG9iaiB0aGUgbm9kZSB0byBmaW5kIHRoZSBydWxlcyBmb3Jcblx0XHQgKiBAcmV0dXJuIHtPYmplY3R9XG5cdFx0ICogQHBsdWdpbiB0eXBlc1xuXHRcdCAqL1xuXHRcdHRoaXMuZ2V0X3J1bGVzID0gZnVuY3Rpb24gKG9iaikge1xuXHRcdFx0b2JqID0gdGhpcy5nZXRfbm9kZShvYmopO1xuXHRcdFx0aWYoIW9iaikgeyByZXR1cm4gZmFsc2U7IH1cblx0XHRcdHZhciB0bXAgPSB0aGlzLmdldF90eXBlKG9iaiwgdHJ1ZSk7XG5cdFx0XHRpZih0bXAubWF4X2RlcHRoID09PSB1bmRlZmluZWQpIHsgdG1wLm1heF9kZXB0aCA9IC0xOyB9XG5cdFx0XHRpZih0bXAubWF4X2NoaWxkcmVuID09PSB1bmRlZmluZWQpIHsgdG1wLm1heF9jaGlsZHJlbiA9IC0xOyB9XG5cdFx0XHRpZih0bXAudmFsaWRfY2hpbGRyZW4gPT09IHVuZGVmaW5lZCkgeyB0bXAudmFsaWRfY2hpbGRyZW4gPSAtMTsgfVxuXHRcdFx0cmV0dXJuIHRtcDtcblx0XHR9O1xuXHRcdC8qKlxuXHRcdCAqIHVzZWQgdG8gcmV0cmlldmUgdGhlIHR5cGUgc3RyaW5nIG9yIHNldHRpbmdzIG9iamVjdCBmb3IgYSBub2RlXG5cdFx0ICogQG5hbWUgZ2V0X3R5cGUob2JqIFssIHJ1bGVzXSlcblx0XHQgKiBAcGFyYW0ge21peGVkfSBvYmogdGhlIG5vZGUgdG8gZmluZCB0aGUgcnVsZXMgZm9yXG5cdFx0ICogQHBhcmFtIHtCb29sZWFufSBydWxlcyBpZiBzZXQgdG8gYHRydWVgIGluc3RlYWQgb2YgYSBzdHJpbmcgdGhlIHNldHRpbmdzIG9iamVjdCB3aWxsIGJlIHJldHVybmVkXG5cdFx0ICogQHJldHVybiB7U3RyaW5nfE9iamVjdH1cblx0XHQgKiBAcGx1Z2luIHR5cGVzXG5cdFx0ICovXG5cdFx0dGhpcy5nZXRfdHlwZSA9IGZ1bmN0aW9uIChvYmosIHJ1bGVzKSB7XG5cdFx0XHRvYmogPSB0aGlzLmdldF9ub2RlKG9iaik7XG5cdFx0XHRyZXR1cm4gKCFvYmopID8gZmFsc2UgOiAoIHJ1bGVzID8gJC5leHRlbmQoeyAndHlwZScgOiBvYmoudHlwZSB9LCB0aGlzLnNldHRpbmdzLnR5cGVzW29iai50eXBlXSkgOiBvYmoudHlwZSk7XG5cdFx0fTtcblx0XHQvKipcblx0XHQgKiB1c2VkIHRvIGNoYW5nZSBhIG5vZGUncyB0eXBlXG5cdFx0ICogQG5hbWUgc2V0X3R5cGUob2JqLCB0eXBlKVxuXHRcdCAqIEBwYXJhbSB7bWl4ZWR9IG9iaiB0aGUgbm9kZSB0byBjaGFuZ2Vcblx0XHQgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSB0aGUgbmV3IHR5cGVcblx0XHQgKiBAcGx1Z2luIHR5cGVzXG5cdFx0ICovXG5cdFx0dGhpcy5zZXRfdHlwZSA9IGZ1bmN0aW9uIChvYmosIHR5cGUpIHtcblx0XHRcdHZhciBtID0gdGhpcy5fbW9kZWwuZGF0YSwgdCwgdDEsIHQyLCBvbGRfdHlwZSwgb2xkX2ljb24sIGssIGQsIGE7XG5cdFx0XHRpZigkLmlzQXJyYXkob2JqKSkge1xuXHRcdFx0XHRvYmogPSBvYmouc2xpY2UoKTtcblx0XHRcdFx0Zm9yKHQxID0gMCwgdDIgPSBvYmoubGVuZ3RoOyB0MSA8IHQyOyB0MSsrKSB7XG5cdFx0XHRcdFx0dGhpcy5zZXRfdHlwZShvYmpbdDFdLCB0eXBlKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblx0XHRcdHQgPSB0aGlzLnNldHRpbmdzLnR5cGVzO1xuXHRcdFx0b2JqID0gdGhpcy5nZXRfbm9kZShvYmopO1xuXHRcdFx0aWYoIXRbdHlwZV0gfHwgIW9iaikgeyByZXR1cm4gZmFsc2U7IH1cblx0XHRcdGQgPSB0aGlzLmdldF9ub2RlKG9iaiwgdHJ1ZSk7XG5cdFx0XHRpZiAoZCAmJiBkLmxlbmd0aCkge1xuXHRcdFx0XHRhID0gZC5jaGlsZHJlbignLmpzdHJlZS1hbmNob3InKTtcblx0XHRcdH1cblx0XHRcdG9sZF90eXBlID0gb2JqLnR5cGU7XG5cdFx0XHRvbGRfaWNvbiA9IHRoaXMuZ2V0X2ljb24ob2JqKTtcblx0XHRcdG9iai50eXBlID0gdHlwZTtcblx0XHRcdGlmKG9sZF9pY29uID09PSB0cnVlIHx8ICF0W29sZF90eXBlXSB8fCAodFtvbGRfdHlwZV0uaWNvbiAhPT0gdW5kZWZpbmVkICYmIG9sZF9pY29uID09PSB0W29sZF90eXBlXS5pY29uKSkge1xuXHRcdFx0XHR0aGlzLnNldF9pY29uKG9iaiwgdFt0eXBlXS5pY29uICE9PSB1bmRlZmluZWQgPyB0W3R5cGVdLmljb24gOiB0cnVlKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gcmVtb3ZlIG9sZCB0eXBlIHByb3BzXG5cdFx0XHRpZih0W29sZF90eXBlXSAmJiB0W29sZF90eXBlXS5saV9hdHRyICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIHRbb2xkX3R5cGVdLmxpX2F0dHIgPT09ICdvYmplY3QnKSB7XG5cdFx0XHRcdGZvciAoayBpbiB0W29sZF90eXBlXS5saV9hdHRyKSB7XG5cdFx0XHRcdFx0aWYgKHRbb2xkX3R5cGVdLmxpX2F0dHIuaGFzT3duUHJvcGVydHkoaykpIHtcblx0XHRcdFx0XHRcdGlmIChrID09PSAnaWQnKSB7XG5cdFx0XHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0ZWxzZSBpZiAoayA9PT0gJ2NsYXNzJykge1xuXHRcdFx0XHRcdFx0XHRtW29iai5pZF0ubGlfYXR0clsnY2xhc3MnXSA9IChtW29iai5pZF0ubGlfYXR0clsnY2xhc3MnXSB8fCAnJykucmVwbGFjZSh0W29sZF90eXBlXS5saV9hdHRyW2tdLCAnJyk7XG5cdFx0XHRcdFx0XHRcdGlmIChkKSB7IGQucmVtb3ZlQ2xhc3ModFtvbGRfdHlwZV0ubGlfYXR0cltrXSk7IH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGVsc2UgaWYgKG1bb2JqLmlkXS5saV9hdHRyW2tdID09PSB0W29sZF90eXBlXS5saV9hdHRyW2tdKSB7XG5cdFx0XHRcdFx0XHRcdG1bb2JqLmlkXS5saV9hdHRyW2tdID0gbnVsbDtcblx0XHRcdFx0XHRcdFx0aWYgKGQpIHsgZC5yZW1vdmVBdHRyKGspOyB9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRpZih0W29sZF90eXBlXSAmJiB0W29sZF90eXBlXS5hX2F0dHIgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2YgdFtvbGRfdHlwZV0uYV9hdHRyID09PSAnb2JqZWN0Jykge1xuXHRcdFx0XHRmb3IgKGsgaW4gdFtvbGRfdHlwZV0uYV9hdHRyKSB7XG5cdFx0XHRcdFx0aWYgKHRbb2xkX3R5cGVdLmFfYXR0ci5oYXNPd25Qcm9wZXJ0eShrKSkge1xuXHRcdFx0XHRcdFx0aWYgKGsgPT09ICdpZCcpIHtcblx0XHRcdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRlbHNlIGlmIChrID09PSAnY2xhc3MnKSB7XG5cdFx0XHRcdFx0XHRcdG1bb2JqLmlkXS5hX2F0dHJbJ2NsYXNzJ10gPSAobVtvYmouaWRdLmFfYXR0clsnY2xhc3MnXSB8fCAnJykucmVwbGFjZSh0W29sZF90eXBlXS5hX2F0dHJba10sICcnKTtcblx0XHRcdFx0XHRcdFx0aWYgKGEpIHsgYS5yZW1vdmVDbGFzcyh0W29sZF90eXBlXS5hX2F0dHJba10pOyB9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRlbHNlIGlmIChtW29iai5pZF0uYV9hdHRyW2tdID09PSB0W29sZF90eXBlXS5hX2F0dHJba10pIHtcblx0XHRcdFx0XHRcdFx0aWYgKGsgPT09ICdocmVmJykge1xuXHRcdFx0XHRcdFx0XHRcdG1bb2JqLmlkXS5hX2F0dHJba10gPSAnIyc7XG5cdFx0XHRcdFx0XHRcdFx0aWYgKGEpIHsgYS5hdHRyKCdocmVmJywgJyMnKTsgfVxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdGRlbGV0ZSBtW29iai5pZF0uYV9hdHRyW2tdO1xuXHRcdFx0XHRcdFx0XHRcdGlmIChhKSB7IGEucmVtb3ZlQXR0cihrKTsgfVxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIGFkZCBuZXcgcHJvcHNcblx0XHRcdGlmKHRbdHlwZV0ubGlfYXR0ciAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiB0W3R5cGVdLmxpX2F0dHIgPT09ICdvYmplY3QnKSB7XG5cdFx0XHRcdGZvciAoayBpbiB0W3R5cGVdLmxpX2F0dHIpIHtcblx0XHRcdFx0XHRpZiAodFt0eXBlXS5saV9hdHRyLmhhc093blByb3BlcnR5KGspKSB7XG5cdFx0XHRcdFx0XHRpZiAoayA9PT0gJ2lkJykge1xuXHRcdFx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGVsc2UgaWYgKG1bb2JqLmlkXS5saV9hdHRyW2tdID09PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHRcdFx0bVtvYmouaWRdLmxpX2F0dHJba10gPSB0W3R5cGVdLmxpX2F0dHJba107XG5cdFx0XHRcdFx0XHRcdGlmIChkKSB7XG5cdFx0XHRcdFx0XHRcdFx0aWYgKGsgPT09ICdjbGFzcycpIHtcblx0XHRcdFx0XHRcdFx0XHRcdGQuYWRkQ2xhc3ModFt0eXBlXS5saV9hdHRyW2tdKTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRkLmF0dHIoaywgdFt0eXBlXS5saV9hdHRyW2tdKTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGVsc2UgaWYgKGsgPT09ICdjbGFzcycpIHtcblx0XHRcdFx0XHRcdFx0bVtvYmouaWRdLmxpX2F0dHJbJ2NsYXNzJ10gPSB0W3R5cGVdLmxpX2F0dHJba10gKyAnICcgKyBtW29iai5pZF0ubGlfYXR0clsnY2xhc3MnXTtcblx0XHRcdFx0XHRcdFx0aWYgKGQpIHsgZC5hZGRDbGFzcyh0W3R5cGVdLmxpX2F0dHJba10pOyB9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRpZih0W3R5cGVdLmFfYXR0ciAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiB0W3R5cGVdLmFfYXR0ciA9PT0gJ29iamVjdCcpIHtcblx0XHRcdFx0Zm9yIChrIGluIHRbdHlwZV0uYV9hdHRyKSB7XG5cdFx0XHRcdFx0aWYgKHRbdHlwZV0uYV9hdHRyLmhhc093blByb3BlcnR5KGspKSB7XG5cdFx0XHRcdFx0XHRpZiAoayA9PT0gJ2lkJykge1xuXHRcdFx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGVsc2UgaWYgKG1bb2JqLmlkXS5hX2F0dHJba10gPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRcdFx0XHRtW29iai5pZF0uYV9hdHRyW2tdID0gdFt0eXBlXS5hX2F0dHJba107XG5cdFx0XHRcdFx0XHRcdGlmIChhKSB7XG5cdFx0XHRcdFx0XHRcdFx0aWYgKGsgPT09ICdjbGFzcycpIHtcblx0XHRcdFx0XHRcdFx0XHRcdGEuYWRkQ2xhc3ModFt0eXBlXS5hX2F0dHJba10pO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRcdGEuYXR0cihrLCB0W3R5cGVdLmFfYXR0cltrXSk7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRlbHNlIGlmIChrID09PSAnaHJlZicgJiYgbVtvYmouaWRdLmFfYXR0cltrXSA9PT0gJyMnKSB7XG5cdFx0XHRcdFx0XHRcdG1bb2JqLmlkXS5hX2F0dHJbJ2hyZWYnXSA9IHRbdHlwZV0uYV9hdHRyWydocmVmJ107XG5cdFx0XHRcdFx0XHRcdGlmIChhKSB7IGEuYXR0cignaHJlZicsIHRbdHlwZV0uYV9hdHRyWydocmVmJ10pOyB9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRlbHNlIGlmIChrID09PSAnY2xhc3MnKSB7XG5cdFx0XHRcdFx0XHRcdG1bb2JqLmlkXS5hX2F0dHJbJ2NsYXNzJ10gPSB0W3R5cGVdLmFfYXR0clsnY2xhc3MnXSArICcgJyArIG1bb2JqLmlkXS5hX2F0dHJbJ2NsYXNzJ107XG5cdFx0XHRcdFx0XHRcdGlmIChhKSB7IGEuYWRkQ2xhc3ModFt0eXBlXS5hX2F0dHJba10pOyB9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH07XG5cdH07XG5cdC8vIGluY2x1ZGUgdGhlIHR5cGVzIHBsdWdpbiBieSBkZWZhdWx0XG5cdC8vICQuanN0cmVlLmRlZmF1bHRzLnBsdWdpbnMucHVzaChcInR5cGVzXCIpO1xuXG5cbi8qKlxuICogIyMjIFVuaXF1ZSBwbHVnaW5cbiAqXG4gKiBFbmZvcmNlcyB0aGF0IG5vIG5vZGVzIHdpdGggdGhlIHNhbWUgbmFtZSBjYW4gY29leGlzdCBhcyBzaWJsaW5ncy5cbiAqL1xuXG5cdC8qKlxuXHQgKiBzdG9yZXMgYWxsIGRlZmF1bHRzIGZvciB0aGUgdW5pcXVlIHBsdWdpblxuXHQgKiBAbmFtZSAkLmpzdHJlZS5kZWZhdWx0cy51bmlxdWVcblx0ICogQHBsdWdpbiB1bmlxdWVcblx0ICovXG5cdCQuanN0cmVlLmRlZmF1bHRzLnVuaXF1ZSA9IHtcblx0XHQvKipcblx0XHQgKiBJbmRpY2F0ZXMgaWYgdGhlIGNvbXBhcmlzb24gc2hvdWxkIGJlIGNhc2Ugc2Vuc2l0aXZlLiBEZWZhdWx0IGlzIGBmYWxzZWAuXG5cdFx0ICogQG5hbWUgJC5qc3RyZWUuZGVmYXVsdHMudW5pcXVlLmNhc2Vfc2Vuc2l0aXZlXG5cdFx0ICogQHBsdWdpbiB1bmlxdWVcblx0XHQgKi9cblx0XHRjYXNlX3NlbnNpdGl2ZSA6IGZhbHNlLFxuXHRcdC8qKlxuXHRcdCAqIEEgY2FsbGJhY2sgZXhlY3V0ZWQgaW4gdGhlIGluc3RhbmNlJ3Mgc2NvcGUgd2hlbiBhIG5ldyBub2RlIGlzIGNyZWF0ZWQgYW5kIHRoZSBuYW1lIGlzIGFscmVhZHkgdGFrZW4sIHRoZSB0d28gYXJndW1lbnRzIGFyZSB0aGUgY29uZmxpY3RpbmcgbmFtZSBhbmQgdGhlIGNvdW50ZXIuIFRoZSBkZWZhdWx0IHdpbGwgcHJvZHVjZSByZXN1bHRzIGxpa2UgYE5ldyBub2RlICgyKWAuXG5cdFx0ICogQG5hbWUgJC5qc3RyZWUuZGVmYXVsdHMudW5pcXVlLmR1cGxpY2F0ZVxuXHRcdCAqIEBwbHVnaW4gdW5pcXVlXG5cdFx0ICovXG5cdFx0ZHVwbGljYXRlIDogZnVuY3Rpb24gKG5hbWUsIGNvdW50ZXIpIHtcblx0XHRcdHJldHVybiBuYW1lICsgJyAoJyArIGNvdW50ZXIgKyAnKSc7XG5cdFx0fVxuXHR9O1xuXG5cdCQuanN0cmVlLnBsdWdpbnMudW5pcXVlID0gZnVuY3Rpb24gKG9wdGlvbnMsIHBhcmVudCkge1xuXHRcdHRoaXMuY2hlY2sgPSBmdW5jdGlvbiAoY2hrLCBvYmosIHBhciwgcG9zLCBtb3JlKSB7XG5cdFx0XHRpZihwYXJlbnQuY2hlY2suY2FsbCh0aGlzLCBjaGssIG9iaiwgcGFyLCBwb3MsIG1vcmUpID09PSBmYWxzZSkgeyByZXR1cm4gZmFsc2U7IH1cblx0XHRcdG9iaiA9IG9iaiAmJiBvYmouaWQgPyBvYmogOiB0aGlzLmdldF9ub2RlKG9iaik7XG5cdFx0XHRwYXIgPSBwYXIgJiYgcGFyLmlkID8gcGFyIDogdGhpcy5nZXRfbm9kZShwYXIpO1xuXHRcdFx0aWYoIXBhciB8fCAhcGFyLmNoaWxkcmVuKSB7IHJldHVybiB0cnVlOyB9XG5cdFx0XHR2YXIgbiA9IGNoayA9PT0gXCJyZW5hbWVfbm9kZVwiID8gcG9zIDogb2JqLnRleHQsXG5cdFx0XHRcdGMgPSBbXSxcblx0XHRcdFx0cyA9IHRoaXMuc2V0dGluZ3MudW5pcXVlLmNhc2Vfc2Vuc2l0aXZlLFxuXHRcdFx0XHRtID0gdGhpcy5fbW9kZWwuZGF0YSwgaSwgajtcblx0XHRcdGZvcihpID0gMCwgaiA9IHBhci5jaGlsZHJlbi5sZW5ndGg7IGkgPCBqOyBpKyspIHtcblx0XHRcdFx0Yy5wdXNoKHMgPyBtW3Bhci5jaGlsZHJlbltpXV0udGV4dCA6IG1bcGFyLmNoaWxkcmVuW2ldXS50ZXh0LnRvTG93ZXJDYXNlKCkpO1xuXHRcdFx0fVxuXHRcdFx0aWYoIXMpIHsgbiA9IG4udG9Mb3dlckNhc2UoKTsgfVxuXHRcdFx0c3dpdGNoKGNoaykge1xuXHRcdFx0XHRjYXNlIFwiZGVsZXRlX25vZGVcIjpcblx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0Y2FzZSBcInJlbmFtZV9ub2RlXCI6XG5cdFx0XHRcdFx0aSA9ICgkLmluQXJyYXkobiwgYykgPT09IC0xIHx8IChvYmoudGV4dCAmJiBvYmoudGV4dFsgcyA/ICd0b1N0cmluZycgOiAndG9Mb3dlckNhc2UnXSgpID09PSBuKSk7XG5cdFx0XHRcdFx0aWYoIWkpIHtcblx0XHRcdFx0XHRcdHRoaXMuX2RhdGEuY29yZS5sYXN0X2Vycm9yID0geyAnZXJyb3InIDogJ2NoZWNrJywgJ3BsdWdpbicgOiAndW5pcXVlJywgJ2lkJyA6ICd1bmlxdWVfMDEnLCAncmVhc29uJyA6ICdDaGlsZCB3aXRoIG5hbWUgJyArIG4gKyAnIGFscmVhZHkgZXhpc3RzLiBQcmV2ZW50aW5nOiAnICsgY2hrLCAnZGF0YScgOiBKU09OLnN0cmluZ2lmeSh7ICdjaGsnIDogY2hrLCAncG9zJyA6IHBvcywgJ29iaicgOiBvYmogJiYgb2JqLmlkID8gb2JqLmlkIDogZmFsc2UsICdwYXInIDogcGFyICYmIHBhci5pZCA/IHBhci5pZCA6IGZhbHNlIH0pIH07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiBpO1xuXHRcdFx0XHRjYXNlIFwiY3JlYXRlX25vZGVcIjpcblx0XHRcdFx0XHRpID0gKCQuaW5BcnJheShuLCBjKSA9PT0gLTEpO1xuXHRcdFx0XHRcdGlmKCFpKSB7XG5cdFx0XHRcdFx0XHR0aGlzLl9kYXRhLmNvcmUubGFzdF9lcnJvciA9IHsgJ2Vycm9yJyA6ICdjaGVjaycsICdwbHVnaW4nIDogJ3VuaXF1ZScsICdpZCcgOiAndW5pcXVlXzA0JywgJ3JlYXNvbicgOiAnQ2hpbGQgd2l0aCBuYW1lICcgKyBuICsgJyBhbHJlYWR5IGV4aXN0cy4gUHJldmVudGluZzogJyArIGNoaywgJ2RhdGEnIDogSlNPTi5zdHJpbmdpZnkoeyAnY2hrJyA6IGNoaywgJ3BvcycgOiBwb3MsICdvYmonIDogb2JqICYmIG9iai5pZCA/IG9iai5pZCA6IGZhbHNlLCAncGFyJyA6IHBhciAmJiBwYXIuaWQgPyBwYXIuaWQgOiBmYWxzZSB9KSB9O1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gaTtcblx0XHRcdFx0Y2FzZSBcImNvcHlfbm9kZVwiOlxuXHRcdFx0XHRcdGkgPSAoJC5pbkFycmF5KG4sIGMpID09PSAtMSk7XG5cdFx0XHRcdFx0aWYoIWkpIHtcblx0XHRcdFx0XHRcdHRoaXMuX2RhdGEuY29yZS5sYXN0X2Vycm9yID0geyAnZXJyb3InIDogJ2NoZWNrJywgJ3BsdWdpbicgOiAndW5pcXVlJywgJ2lkJyA6ICd1bmlxdWVfMDInLCAncmVhc29uJyA6ICdDaGlsZCB3aXRoIG5hbWUgJyArIG4gKyAnIGFscmVhZHkgZXhpc3RzLiBQcmV2ZW50aW5nOiAnICsgY2hrLCAnZGF0YScgOiBKU09OLnN0cmluZ2lmeSh7ICdjaGsnIDogY2hrLCAncG9zJyA6IHBvcywgJ29iaicgOiBvYmogJiYgb2JqLmlkID8gb2JqLmlkIDogZmFsc2UsICdwYXInIDogcGFyICYmIHBhci5pZCA/IHBhci5pZCA6IGZhbHNlIH0pIH07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiBpO1xuXHRcdFx0XHRjYXNlIFwibW92ZV9ub2RlXCI6XG5cdFx0XHRcdFx0aSA9ICggKG9iai5wYXJlbnQgPT09IHBhci5pZCAmJiAoIW1vcmUgfHwgIW1vcmUuaXNfbXVsdGkpKSB8fCAkLmluQXJyYXkobiwgYykgPT09IC0xKTtcblx0XHRcdFx0XHRpZighaSkge1xuXHRcdFx0XHRcdFx0dGhpcy5fZGF0YS5jb3JlLmxhc3RfZXJyb3IgPSB7ICdlcnJvcicgOiAnY2hlY2snLCAncGx1Z2luJyA6ICd1bmlxdWUnLCAnaWQnIDogJ3VuaXF1ZV8wMycsICdyZWFzb24nIDogJ0NoaWxkIHdpdGggbmFtZSAnICsgbiArICcgYWxyZWFkeSBleGlzdHMuIFByZXZlbnRpbmc6ICcgKyBjaGssICdkYXRhJyA6IEpTT04uc3RyaW5naWZ5KHsgJ2NoaycgOiBjaGssICdwb3MnIDogcG9zLCAnb2JqJyA6IG9iaiAmJiBvYmouaWQgPyBvYmouaWQgOiBmYWxzZSwgJ3BhcicgOiBwYXIgJiYgcGFyLmlkID8gcGFyLmlkIDogZmFsc2UgfSkgfTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIGk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9O1xuXHRcdHRoaXMuY3JlYXRlX25vZGUgPSBmdW5jdGlvbiAocGFyLCBub2RlLCBwb3MsIGNhbGxiYWNrLCBpc19sb2FkZWQpIHtcblx0XHRcdGlmKCFub2RlIHx8IG5vZGUudGV4dCA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdGlmKHBhciA9PT0gbnVsbCkge1xuXHRcdFx0XHRcdHBhciA9ICQuanN0cmVlLnJvb3Q7XG5cdFx0XHRcdH1cblx0XHRcdFx0cGFyID0gdGhpcy5nZXRfbm9kZShwYXIpO1xuXHRcdFx0XHRpZighcGFyKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHBhcmVudC5jcmVhdGVfbm9kZS5jYWxsKHRoaXMsIHBhciwgbm9kZSwgcG9zLCBjYWxsYmFjaywgaXNfbG9hZGVkKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRwb3MgPSBwb3MgPT09IHVuZGVmaW5lZCA/IFwibGFzdFwiIDogcG9zO1xuXHRcdFx0XHRpZighcG9zLnRvU3RyaW5nKCkubWF0Y2goL14oYmVmb3JlfGFmdGVyKSQvKSAmJiAhaXNfbG9hZGVkICYmICF0aGlzLmlzX2xvYWRlZChwYXIpKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHBhcmVudC5jcmVhdGVfbm9kZS5jYWxsKHRoaXMsIHBhciwgbm9kZSwgcG9zLCBjYWxsYmFjaywgaXNfbG9hZGVkKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZighbm9kZSkgeyBub2RlID0ge307IH1cblx0XHRcdFx0dmFyIHRtcCwgbiwgZHBjLCBpLCBqLCBtID0gdGhpcy5fbW9kZWwuZGF0YSwgcyA9IHRoaXMuc2V0dGluZ3MudW5pcXVlLmNhc2Vfc2Vuc2l0aXZlLCBjYiA9IHRoaXMuc2V0dGluZ3MudW5pcXVlLmR1cGxpY2F0ZTtcblx0XHRcdFx0biA9IHRtcCA9IHRoaXMuZ2V0X3N0cmluZygnTmV3IG5vZGUnKTtcblx0XHRcdFx0ZHBjID0gW107XG5cdFx0XHRcdGZvcihpID0gMCwgaiA9IHBhci5jaGlsZHJlbi5sZW5ndGg7IGkgPCBqOyBpKyspIHtcblx0XHRcdFx0XHRkcGMucHVzaChzID8gbVtwYXIuY2hpbGRyZW5baV1dLnRleHQgOiBtW3Bhci5jaGlsZHJlbltpXV0udGV4dC50b0xvd2VyQ2FzZSgpKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpID0gMTtcblx0XHRcdFx0d2hpbGUoJC5pbkFycmF5KHMgPyBuIDogbi50b0xvd2VyQ2FzZSgpLCBkcGMpICE9PSAtMSkge1xuXHRcdFx0XHRcdG4gPSBjYi5jYWxsKHRoaXMsIHRtcCwgKCsraSkpLnRvU3RyaW5nKCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0bm9kZS50ZXh0ID0gbjtcblx0XHRcdH1cblx0XHRcdHJldHVybiBwYXJlbnQuY3JlYXRlX25vZGUuY2FsbCh0aGlzLCBwYXIsIG5vZGUsIHBvcywgY2FsbGJhY2ssIGlzX2xvYWRlZCk7XG5cdFx0fTtcblx0fTtcblxuXHQvLyBpbmNsdWRlIHRoZSB1bmlxdWUgcGx1Z2luIGJ5IGRlZmF1bHRcblx0Ly8gJC5qc3RyZWUuZGVmYXVsdHMucGx1Z2lucy5wdXNoKFwidW5pcXVlXCIpO1xuXG5cbi8qKlxuICogIyMjIFdob2xlcm93IHBsdWdpblxuICpcbiAqIE1ha2VzIGVhY2ggbm9kZSBhcHBlYXIgYmxvY2sgbGV2ZWwuIE1ha2luZyBzZWxlY3Rpb24gZWFzaWVyLiBNYXkgY2F1c2Ugc2xvdyBkb3duIGZvciBsYXJnZSB0cmVlcyBpbiBvbGQgYnJvd3NlcnMuXG4gKi9cblxuXHR2YXIgZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnRElWJyk7XG5cdGRpdi5zZXRBdHRyaWJ1dGUoJ3Vuc2VsZWN0YWJsZScsJ29uJyk7XG5cdGRpdi5zZXRBdHRyaWJ1dGUoJ3JvbGUnLCdwcmVzZW50YXRpb24nKTtcblx0ZGl2LmNsYXNzTmFtZSA9ICdqc3RyZWUtd2hvbGVyb3cnO1xuXHRkaXYuaW5uZXJIVE1MID0gJyYjMTYwOyc7XG5cdCQuanN0cmVlLnBsdWdpbnMud2hvbGVyb3cgPSBmdW5jdGlvbiAob3B0aW9ucywgcGFyZW50KSB7XG5cdFx0dGhpcy5iaW5kID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0cGFyZW50LmJpbmQuY2FsbCh0aGlzKTtcblxuXHRcdFx0dGhpcy5lbGVtZW50XG5cdFx0XHRcdC5vbigncmVhZHkuanN0cmVlIHNldF9zdGF0ZS5qc3RyZWUnLCAkLnByb3h5KGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0XHRcdHRoaXMuaGlkZV9kb3RzKCk7XG5cdFx0XHRcdFx0fSwgdGhpcykpXG5cdFx0XHRcdC5vbihcImluaXQuanN0cmVlIGxvYWRpbmcuanN0cmVlIHJlYWR5LmpzdHJlZVwiLCAkLnByb3h5KGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0XHRcdC8vZGl2LnN0eWxlLmhlaWdodCA9IHRoaXMuX2RhdGEuY29yZS5saV9oZWlnaHQgKyAncHgnO1xuXHRcdFx0XHRcdFx0dGhpcy5nZXRfY29udGFpbmVyX3VsKCkuYWRkQ2xhc3MoJ2pzdHJlZS13aG9sZXJvdy11bCcpO1xuXHRcdFx0XHRcdH0sIHRoaXMpKVxuXHRcdFx0XHQub24oXCJkZXNlbGVjdF9hbGwuanN0cmVlXCIsICQucHJveHkoZnVuY3Rpb24gKGUsIGRhdGEpIHtcblx0XHRcdFx0XHRcdHRoaXMuZWxlbWVudC5maW5kKCcuanN0cmVlLXdob2xlcm93LWNsaWNrZWQnKS5yZW1vdmVDbGFzcygnanN0cmVlLXdob2xlcm93LWNsaWNrZWQnKTtcblx0XHRcdFx0XHR9LCB0aGlzKSlcblx0XHRcdFx0Lm9uKFwiY2hhbmdlZC5qc3RyZWVcIiwgJC5wcm94eShmdW5jdGlvbiAoZSwgZGF0YSkge1xuXHRcdFx0XHRcdFx0dGhpcy5lbGVtZW50LmZpbmQoJy5qc3RyZWUtd2hvbGVyb3ctY2xpY2tlZCcpLnJlbW92ZUNsYXNzKCdqc3RyZWUtd2hvbGVyb3ctY2xpY2tlZCcpO1xuXHRcdFx0XHRcdFx0dmFyIHRtcCA9IGZhbHNlLCBpLCBqO1xuXHRcdFx0XHRcdFx0Zm9yKGkgPSAwLCBqID0gZGF0YS5zZWxlY3RlZC5sZW5ndGg7IGkgPCBqOyBpKyspIHtcblx0XHRcdFx0XHRcdFx0dG1wID0gdGhpcy5nZXRfbm9kZShkYXRhLnNlbGVjdGVkW2ldLCB0cnVlKTtcblx0XHRcdFx0XHRcdFx0aWYodG1wICYmIHRtcC5sZW5ndGgpIHtcblx0XHRcdFx0XHRcdFx0XHR0bXAuY2hpbGRyZW4oJy5qc3RyZWUtd2hvbGVyb3cnKS5hZGRDbGFzcygnanN0cmVlLXdob2xlcm93LWNsaWNrZWQnKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0sIHRoaXMpKVxuXHRcdFx0XHQub24oXCJvcGVuX25vZGUuanN0cmVlXCIsICQucHJveHkoZnVuY3Rpb24gKGUsIGRhdGEpIHtcblx0XHRcdFx0XHRcdHRoaXMuZ2V0X25vZGUoZGF0YS5ub2RlLCB0cnVlKS5maW5kKCcuanN0cmVlLWNsaWNrZWQnKS5wYXJlbnQoKS5jaGlsZHJlbignLmpzdHJlZS13aG9sZXJvdycpLmFkZENsYXNzKCdqc3RyZWUtd2hvbGVyb3ctY2xpY2tlZCcpO1xuXHRcdFx0XHRcdH0sIHRoaXMpKVxuXHRcdFx0XHQub24oXCJob3Zlcl9ub2RlLmpzdHJlZSBkZWhvdmVyX25vZGUuanN0cmVlXCIsICQucHJveHkoZnVuY3Rpb24gKGUsIGRhdGEpIHtcblx0XHRcdFx0XHRcdGlmKGUudHlwZSA9PT0gXCJob3Zlcl9ub2RlXCIgJiYgdGhpcy5pc19kaXNhYmxlZChkYXRhLm5vZGUpKSB7IHJldHVybjsgfVxuXHRcdFx0XHRcdFx0dGhpcy5nZXRfbm9kZShkYXRhLm5vZGUsIHRydWUpLmNoaWxkcmVuKCcuanN0cmVlLXdob2xlcm93JylbZS50eXBlID09PSBcImhvdmVyX25vZGVcIj9cImFkZENsYXNzXCI6XCJyZW1vdmVDbGFzc1wiXSgnanN0cmVlLXdob2xlcm93LWhvdmVyZWQnKTtcblx0XHRcdFx0XHR9LCB0aGlzKSlcblx0XHRcdFx0Lm9uKFwiY29udGV4dG1lbnUuanN0cmVlXCIsIFwiLmpzdHJlZS13aG9sZXJvd1wiLCAkLnByb3h5KGZ1bmN0aW9uIChlKSB7XG5cdFx0XHRcdFx0XHRpZiAodGhpcy5fZGF0YS5jb250ZXh0bWVudSkge1xuXHRcdFx0XHRcdFx0XHRlLnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHRcdFx0XHRcdHZhciB0bXAgPSAkLkV2ZW50KCdjb250ZXh0bWVudScsIHsgbWV0YUtleSA6IGUubWV0YUtleSwgY3RybEtleSA6IGUuY3RybEtleSwgYWx0S2V5IDogZS5hbHRLZXksIHNoaWZ0S2V5IDogZS5zaGlmdEtleSwgcGFnZVggOiBlLnBhZ2VYLCBwYWdlWSA6IGUucGFnZVkgfSk7XG5cdFx0XHRcdFx0XHRcdCQoZS5jdXJyZW50VGFyZ2V0KS5jbG9zZXN0KFwiLmpzdHJlZS1ub2RlXCIpLmNoaWxkcmVuKFwiLmpzdHJlZS1hbmNob3JcIikuZmlyc3QoKS50cmlnZ2VyKHRtcCk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSwgdGhpcykpXG5cdFx0XHRcdC8qIVxuXHRcdFx0XHQub24oXCJtb3VzZWRvd24uanN0cmVlIHRvdWNoc3RhcnQuanN0cmVlXCIsIFwiLmpzdHJlZS13aG9sZXJvd1wiLCBmdW5jdGlvbiAoZSkge1xuXHRcdFx0XHRcdFx0aWYoZS50YXJnZXQgPT09IGUuY3VycmVudFRhcmdldCkge1xuXHRcdFx0XHRcdFx0XHR2YXIgYSA9ICQoZS5jdXJyZW50VGFyZ2V0KS5jbG9zZXN0KFwiLmpzdHJlZS1ub2RlXCIpLmNoaWxkcmVuKFwiLmpzdHJlZS1hbmNob3JcIik7XG5cdFx0XHRcdFx0XHRcdGUudGFyZ2V0ID0gYVswXTtcblx0XHRcdFx0XHRcdFx0YS50cmlnZ2VyKGUpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0pXG5cdFx0XHRcdCovXG5cdFx0XHRcdC5vbihcImNsaWNrLmpzdHJlZVwiLCBcIi5qc3RyZWUtd2hvbGVyb3dcIiwgZnVuY3Rpb24gKGUpIHtcblx0XHRcdFx0XHRcdGUuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG5cdFx0XHRcdFx0XHR2YXIgdG1wID0gJC5FdmVudCgnY2xpY2snLCB7IG1ldGFLZXkgOiBlLm1ldGFLZXksIGN0cmxLZXkgOiBlLmN0cmxLZXksIGFsdEtleSA6IGUuYWx0S2V5LCBzaGlmdEtleSA6IGUuc2hpZnRLZXkgfSk7XG5cdFx0XHRcdFx0XHQkKGUuY3VycmVudFRhcmdldCkuY2xvc2VzdChcIi5qc3RyZWUtbm9kZVwiKS5jaGlsZHJlbihcIi5qc3RyZWUtYW5jaG9yXCIpLmZpcnN0KCkudHJpZ2dlcih0bXApLmZvY3VzKCk7XG5cdFx0XHRcdFx0fSlcblx0XHRcdFx0Lm9uKFwiZGJsY2xpY2suanN0cmVlXCIsIFwiLmpzdHJlZS13aG9sZXJvd1wiLCBmdW5jdGlvbiAoZSkge1xuXHRcdFx0XHRcdFx0ZS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcblx0XHRcdFx0XHRcdHZhciB0bXAgPSAkLkV2ZW50KCdkYmxjbGljaycsIHsgbWV0YUtleSA6IGUubWV0YUtleSwgY3RybEtleSA6IGUuY3RybEtleSwgYWx0S2V5IDogZS5hbHRLZXksIHNoaWZ0S2V5IDogZS5zaGlmdEtleSB9KTtcblx0XHRcdFx0XHRcdCQoZS5jdXJyZW50VGFyZ2V0KS5jbG9zZXN0KFwiLmpzdHJlZS1ub2RlXCIpLmNoaWxkcmVuKFwiLmpzdHJlZS1hbmNob3JcIikuZmlyc3QoKS50cmlnZ2VyKHRtcCkuZm9jdXMoKTtcblx0XHRcdFx0XHR9KVxuXHRcdFx0XHQub24oXCJjbGljay5qc3RyZWVcIiwgXCIuanN0cmVlLWxlYWYgPiAuanN0cmVlLW9jbFwiLCAkLnByb3h5KGZ1bmN0aW9uIChlKSB7XG5cdFx0XHRcdFx0XHRlLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xuXHRcdFx0XHRcdFx0dmFyIHRtcCA9ICQuRXZlbnQoJ2NsaWNrJywgeyBtZXRhS2V5IDogZS5tZXRhS2V5LCBjdHJsS2V5IDogZS5jdHJsS2V5LCBhbHRLZXkgOiBlLmFsdEtleSwgc2hpZnRLZXkgOiBlLnNoaWZ0S2V5IH0pO1xuXHRcdFx0XHRcdFx0JChlLmN1cnJlbnRUYXJnZXQpLmNsb3Nlc3QoXCIuanN0cmVlLW5vZGVcIikuY2hpbGRyZW4oXCIuanN0cmVlLWFuY2hvclwiKS5maXJzdCgpLnRyaWdnZXIodG1wKS5mb2N1cygpO1xuXHRcdFx0XHRcdH0sIHRoaXMpKVxuXHRcdFx0XHQub24oXCJtb3VzZW92ZXIuanN0cmVlXCIsIFwiLmpzdHJlZS13aG9sZXJvdywgLmpzdHJlZS1pY29uXCIsICQucHJveHkoZnVuY3Rpb24gKGUpIHtcblx0XHRcdFx0XHRcdGUuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG5cdFx0XHRcdFx0XHRpZighdGhpcy5pc19kaXNhYmxlZChlLmN1cnJlbnRUYXJnZXQpKSB7XG5cdFx0XHRcdFx0XHRcdHRoaXMuaG92ZXJfbm9kZShlLmN1cnJlbnRUYXJnZXQpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHRcdH0sIHRoaXMpKVxuXHRcdFx0XHQub24oXCJtb3VzZWxlYXZlLmpzdHJlZVwiLCBcIi5qc3RyZWUtbm9kZVwiLCAkLnByb3h5KGZ1bmN0aW9uIChlKSB7XG5cdFx0XHRcdFx0XHR0aGlzLmRlaG92ZXJfbm9kZShlLmN1cnJlbnRUYXJnZXQpO1xuXHRcdFx0XHRcdH0sIHRoaXMpKTtcblx0XHR9O1xuXHRcdHRoaXMudGVhcmRvd24gPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHRpZih0aGlzLnNldHRpbmdzLndob2xlcm93KSB7XG5cdFx0XHRcdHRoaXMuZWxlbWVudC5maW5kKFwiLmpzdHJlZS13aG9sZXJvd1wiKS5yZW1vdmUoKTtcblx0XHRcdH1cblx0XHRcdHBhcmVudC50ZWFyZG93bi5jYWxsKHRoaXMpO1xuXHRcdH07XG5cdFx0dGhpcy5yZWRyYXdfbm9kZSA9IGZ1bmN0aW9uKG9iaiwgZGVlcCwgY2FsbGJhY2ssIGZvcmNlX3JlbmRlcikge1xuXHRcdFx0b2JqID0gcGFyZW50LnJlZHJhd19ub2RlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdFx0XHRpZihvYmopIHtcblx0XHRcdFx0dmFyIHRtcCA9IGRpdi5jbG9uZU5vZGUodHJ1ZSk7XG5cdFx0XHRcdC8vdG1wLnN0eWxlLmhlaWdodCA9IHRoaXMuX2RhdGEuY29yZS5saV9oZWlnaHQgKyAncHgnO1xuXHRcdFx0XHRpZigkLmluQXJyYXkob2JqLmlkLCB0aGlzLl9kYXRhLmNvcmUuc2VsZWN0ZWQpICE9PSAtMSkgeyB0bXAuY2xhc3NOYW1lICs9ICcganN0cmVlLXdob2xlcm93LWNsaWNrZWQnOyB9XG5cdFx0XHRcdGlmKHRoaXMuX2RhdGEuY29yZS5mb2N1c2VkICYmIHRoaXMuX2RhdGEuY29yZS5mb2N1c2VkID09PSBvYmouaWQpIHsgdG1wLmNsYXNzTmFtZSArPSAnIGpzdHJlZS13aG9sZXJvdy1ob3ZlcmVkJzsgfVxuXHRcdFx0XHRvYmouaW5zZXJ0QmVmb3JlKHRtcCwgb2JqLmNoaWxkTm9kZXNbMF0pO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG9iajtcblx0XHR9O1xuXHR9O1xuXHQvLyBpbmNsdWRlIHRoZSB3aG9sZXJvdyBwbHVnaW4gYnkgZGVmYXVsdFxuXHQvLyAkLmpzdHJlZS5kZWZhdWx0cy5wbHVnaW5zLnB1c2goXCJ3aG9sZXJvd1wiKTtcblx0aWYoZG9jdW1lbnQucmVnaXN0ZXJFbGVtZW50ICYmIE9iamVjdCAmJiBPYmplY3QuY3JlYXRlKSB7XG5cdFx0dmFyIHByb3RvID0gT2JqZWN0LmNyZWF0ZShIVE1MRWxlbWVudC5wcm90b3R5cGUpO1xuXHRcdHByb3RvLmNyZWF0ZWRDYWxsYmFjayA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdHZhciBjID0geyBjb3JlIDoge30sIHBsdWdpbnMgOiBbXSB9LCBpO1xuXHRcdFx0Zm9yKGkgaW4gJC5qc3RyZWUucGx1Z2lucykge1xuXHRcdFx0XHRpZigkLmpzdHJlZS5wbHVnaW5zLmhhc093blByb3BlcnR5KGkpICYmIHRoaXMuYXR0cmlidXRlc1tpXSkge1xuXHRcdFx0XHRcdGMucGx1Z2lucy5wdXNoKGkpO1xuXHRcdFx0XHRcdGlmKHRoaXMuZ2V0QXR0cmlidXRlKGkpICYmIEpTT04ucGFyc2UodGhpcy5nZXRBdHRyaWJ1dGUoaSkpKSB7XG5cdFx0XHRcdFx0XHRjW2ldID0gSlNPTi5wYXJzZSh0aGlzLmdldEF0dHJpYnV0ZShpKSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRmb3IoaSBpbiAkLmpzdHJlZS5kZWZhdWx0cy5jb3JlKSB7XG5cdFx0XHRcdGlmKCQuanN0cmVlLmRlZmF1bHRzLmNvcmUuaGFzT3duUHJvcGVydHkoaSkgJiYgdGhpcy5hdHRyaWJ1dGVzW2ldKSB7XG5cdFx0XHRcdFx0Yy5jb3JlW2ldID0gSlNPTi5wYXJzZSh0aGlzLmdldEF0dHJpYnV0ZShpKSkgfHwgdGhpcy5nZXRBdHRyaWJ1dGUoaSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdCQodGhpcykuanN0cmVlKGMpO1xuXHRcdH07XG5cdFx0Ly8gcHJvdG8uYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrID0gZnVuY3Rpb24gKG5hbWUsIHByZXZpb3VzLCB2YWx1ZSkgeyB9O1xuXHRcdHRyeSB7XG5cdFx0XHRkb2N1bWVudC5yZWdpc3RlckVsZW1lbnQoXCJ2YWthdGEtanN0cmVlXCIsIHsgcHJvdG90eXBlOiBwcm90byB9KTtcblx0XHR9IGNhdGNoKGlnbm9yZSkgeyB9XG5cdH1cblxufSkpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9qc3RyZWUvZGlzdC9qc3RyZWUuanNcbi8vIG1vZHVsZSBpZCA9IDk2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogcmVxdWlyZWQgdG8gaW5jbHVkZTogbGF6eS1zZWxlY3Rvci1tb2RhbC5odG1sXG4gKlxuICogYXZhaWxpYWJsZSBvcHRpb24gOlxuICoge1xuICogICAgc2VsZWN0b3I6ICdhdHRyYWN0aW9ucycgLCAndmVudWVzJywgJycsXG4gKiAgICBoaWRlTXVsdGlTZWxlY3RvcjogdHJ1ZSwgZmFsc2VcbiAqIH1cbiAqICQoJy5qc19sYXp5LXNlbGVjdG9yJykubGF6eVNlbGVjdG9yKCk7XG4gKiAkKCcuanNfbGF6eS1zZWxlY3Rvci1hdHRyYWN0aW9ucycpLmxhenlTZWxlY3Rvcigne3NlbGVjdG9yOiAnYXR0cmFjdGlvbnMnfSk7XG4gKiAkKCcuanNfbGF6eS1zZWxlY3Rvci12ZW51ZXMnKS5sYXp5U2VsZWN0b3Ioe3NlbGVjdG9yOid2ZW51ZXMnLCBoaWRlTXVsdGlTZWxlY3Rvcjp0cnVlfSk7XG4gKi9cblxuKGZ1bmN0aW9uICgkKSB7XG4gIHZhciBjb25maWcgPSBbJ2V2ZW50cycsICd2ZW51ZXMnLCAnYXR0cmFjdGlvbnMnXSxcbiAgICB0YWdzSWRzID17fSwgaW5pdGlhbFZhbD17fTtcblxuICBjb25maWcuZm9yRWFjaChmdW5jdGlvbiAoZWwpIHtcbiAgICB0YWdzSWRzW2VsXSA9IFtdO1xuICAgIGluaXRpYWxWYWxbZWxdID0gW107XG4gIH0pO1xuXG4gICQuZm4ubGF6eVNlbGVjdG9yID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICB2YXIgZGVmYXVsdHMgPSB7fSxcbiAgICAgICAgc2V0dGluZ3MgPSAkLmV4dGVuZCh7fSwgJC5mbi5sYXp5U2VsZWN0b3IuZGVmYXVsdHMsIG9wdGlvbnMpLFxuICAgICAgICAkaWNvbkJ1dHRvbiA9ICQoJzxhIGNsYXNzPVwiaWNvblwiIGlkPVwiZ2V0LWV2ZW50LWJ5LUlkLScgKyBvcHRpb25zLnNlbGVjdG9yICsgJ1wiIGRhdGEtdG9nZ2xlPVwibW9kYWxcIiBkYXRhLXRhcmdldD1cIiNqc19scy1tb2RhbFwiIC8+Jyk7XG5cbiAgICB2YXIgc3RhdGVDb25mID0ge1xuICAgICAgcGFnZUluY3JlbWVudDogMCxcbiAgICAgIGxvYWRpbmdGbGFnOiBmYWxzZSxcbiAgICAgIHNldFNpbmdsZVZhbDogZmFsc2VcbiAgICB9O1xuXG4gICAgdmFyICRpbnB1dCA9ICQodGhpcyksXG5cdFx0XHQkbW9kYWwgPSAkKCcjanNfbHMtbW9kYWwnKSxcbiAgICAgICRmb3JtID0gJCgnI2pzX2xhenktc2VsX2Zvcm0nLCAkbW9kYWwpLFxuICAgICAgJHVsID0gJCgnI2pzX2xhenktc2VsX2xpc3QnKSxcbiAgICAgICRsaUZvb3RlciA9ICQoJyNsb2FkLW1vcmUtYm94JyksXG4gICAgICAkaHIgPSAkKCcjanNfbHMtdG9wLWhyJyksXG4gICAgICAkYnRuR0VUID0gJG1vZGFsLmZpbmQoJyNqc19scy1tb2RhbF9idG4nKSxcbiAgICAgIGJ0bkNsb3NlTWFwID0gJCgnLmJ1dHRvbi1jbG9zZS1tYXAnLCAkbW9kYWwpLFxuICAgICAgY3NzVmFsaWRhdGlvbkNsYXNzID0gJ2dldC1ldmVudElkX2Zvcm0tdmFsaWRhdGlvbicsXG4gICAgICBtb2RhbENvbnRlbnQgPSAkKCcubW9kYWwtY29udGVudCcsICRtb2RhbCksXG4gICAgICAkbXNTZWxlY3Rpb24gPSAkKCcubXMtc2VsZWN0aW9uJyksXG4gICAgICAkbXNMaXN0ID0gJCgnLm1zLWxpc3QnLCRtc1NlbGVjdGlvbiksXG4gICAgICAkbXNCdG5Vc2UgPSAkKCcjanNfbXMtdXNlLWJ0bicsJG1zU2VsZWN0aW9uKVxuICAgICAgO1xuXG4gICAgdmFyIGtleXdvcmQgPSAkZm9ybS5maW5kKCcja2V5d29yZCcpLFxuICAgICAgZGVmYXVsdEFwaUtleSA9IGFwaUtleVNlcnZpY2UuZ2V0QXBpRXhwbG9yZUtleSgpLFxuICAgICAgYXBpa2V5ID0gYXBpS2V5U2VydmljZS5jaGVja0FwaUtleUNvb2tpZSgndGstYXBpLWtleScpIHx8ICQoJyN3LXRtLWFwaS1rZXknKS52YWwoKSB8fCBkZWZhdWx0QXBpS2V5LFxuICAgICAgc2VsZWN0b3IgPSBvcHRpb25zLnNlbGVjdG9yIHx8ICdldmVudHMnLFxuICAgICAgZXZlbnRVcmwgPSAnaHR0cHM6Ly9hcHAudGlja2V0bWFzdGVyLmNvbS9kaXNjb3ZlcnkvdjIvJyArIHNlbGVjdG9yICsgJy5qc29uJ1xuICAgICAgO1xuXG4gICAgZnVuY3Rpb24gZm9ybWF0RGF0ZShkYXRlKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gJyc7XG4gICAgICBpZiAoIWRhdGUuZGF5KSByZXR1cm4gcmVzdWx0OyAvLyBEYXkgaXMgcmVxdWlyZWRcblxuICAgICAgdmFyIE1PTlRIX05BTUVTID0gWydKYW4nLCAnRmViJywgJ01hcicsICdBcHInLCAnTWF5JywgJ0p1bicsICdKdWwnLCAnQXVnJywgJ1NlcCcsICdPY3QnLCAnTm92JywgJ0RlYyddLFxuICAgICAgICBEQVlfTkFNRVMgPSBbJ1N1bicsICdNb24nLCAnVHVlJywgJ1dlZCcsICdUaHUnLCAnRnJpJywgJ1NhdCddLFxuICAgICAgICBkYXlBcnJheSA9IGRhdGUuZGF5LnNwbGl0KCctJyksXG4gICAgICAgIGQgPSBwYXJzZUludChkYXlBcnJheVsyXSksXG4gICAgICAgIE0gPSBwYXJzZUludChkYXlBcnJheVsxXSk7XG5cbiAgICAgIHZhciBFID0gbmV3IERhdGUoZGF0ZS5kYXkpLmdldERheSgpO1xuXG4gICAgICAvL3ZhciBFMSA9IG5ldyBEYXRlKCtkYXRlLmRheS5zcGxpdCgnLScpWzBdLCgrZGF0ZS5kYXkuc3BsaXQoJy0nKVsxXSktMSwrZGF0ZS5kYXkuc3BsaXQoJy0nKVsyXSkuZ2V0RGF5KCk7XG4gICAgICAvL2lmKEUgIT09IEUxKSBjb25zb2xlLmxvZygnXFx0IGFsYXJtIGVxdWFsIC0gJyAsIEUgPT09IEUxKTtcblxuICAgICAgcmVzdWx0ID0gREFZX05BTUVTW0VdICsgJywgJyArIE1PTlRIX05BTUVTW00gLSAxXSArICcgJyArIGQgKyAnLCAnICsgZGF5QXJyYXlbMF07XG5cbiAgICAgIGlmICghZGF0ZS50aW1lKSByZXR1cm4gcmVzdWx0O1xuXG4gICAgICB2YXIgdGltZUFycmF5ID0gZGF0ZS50aW1lLnNwbGl0KCc6JyksXG4gICAgICAgIEggPSBwYXJzZUludCh0aW1lQXJyYXlbMF0pLFxuICAgICAgICBtID0gdGltZUFycmF5WzFdLFxuICAgICAgICBhID0gXCJBTVwiO1xuXG4gICAgICBpZiAoSCA+IDExKSBhID0gXCJQTVwiO1xuICAgICAgaWYgKEggPT09IDApIHtcbiAgICAgICAgSCA9IDEyO1xuICAgICAgfSBlbHNlIGlmIChIID4gMTIpIHtcbiAgICAgICAgSCA9IEggLSAxMjtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3VsdCArICcgJyArIGdldE5vcm1hbGl6ZWREYXRlVmFsdWUoSCkgKyAnOicgKyBtICsgJyAnICsgYTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXROb3JtYWxpemVkRGF0ZVZhbHVlKHZhbCkge1xuICAgICAgcmV0dXJuICh2YWwgPCAwIHx8IHZhbCA+IDkgPyBcIlwiIDogXCIwXCIpICsgdmFsXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2hvdyBvciBpbml0IG1hcCBsaXN0ZW5lclxuICAgICAqIEBwYXJhbSBlXG4gICAgICovXG4gICAgdmFyIG1hcFBvcFVwTGlzdGVuZXIgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgdmFyIGxhdCA9ICQoZS50YXJnZXQpLmF0dHIoJ2RhdGEtbGF0aXR1ZGUnKSAhPSBcInVuZGVmaW5lZFwiID8gcGFyc2VGbG9hdCgkKGUudGFyZ2V0KS5hdHRyKCdkYXRhLWxhdGl0dWRlJykpIDogbnVsbCxcbiAgICAgICAgbG5nID0gJChlLnRhcmdldCkuYXR0cignZGF0YS1sb25naXR1ZGUnKSAhPSBcInVuZGVmaW5lZFwiID8gcGFyc2VGbG9hdCgkKGUudGFyZ2V0KS5hdHRyKCdkYXRhLWxvbmdpdHVkZScpKSA6IG51bGwsXG4gICAgICAgIGFkZHJlc3MgPSBsYXQgJiYgbG5nID8gbnVsbCA6ICQoZS50YXJnZXQpLmF0dHIoJ2RhdGEtYWRkcmVzcycpO1xuXG4gICAgICBpZiAobGF0ICYmIGxuZyApIHtcbiAgICAgICAgaW5pdE1hcChsYXQsIGxuZyk7XG4gICAgICAgIGdvb2dsZS5tYXBzLmV2ZW50LnRyaWdnZXIobWFwLCBcInJlc2l6ZVwiKTsgLy8nc2Vjb25kIGluaXQnXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpbml0TWFwKDAsIDApOyAvL1wiZmlyc3QgaW5pdFwiXG4gICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEluaXQgbWFwIGdvb2dsZSBtYXBzXG4gICAgICogQHBhcmFtIGxhdCAtIGZsb2F0XG4gICAgICogQHBhcmFtIGxuZyAtIGZsb2F0XG4gICAgICogQHBhcmFtIGFkZHJlc3MgLSBub3QgdXNlZCBAZGVwcmVjYXRlZFxuICAgICAqL1xuICAgIHZhciBtYXAgPSBudWxsLCBtYXJrZXJzID0gW107XG5cbiAgICB2YXIgaW5pdE1hcCA9IGZ1bmN0aW9uIChsYXQsIGxuZykge1xuICAgIFx0dmFyIG1vZGFsID0gJG1vZGFsLFxuICAgICAgICBtYXBDZW50ZXIgPSBuZXcgZ29vZ2xlLm1hcHMuTGF0TG5nKGxhdCB8fCA1NSwgbG5nIHx8IDQzKTtcblxuICAgICAgaWYobWFwID09PSBudWxsKXtcbiAgICAgICAgLy8gaW5pdGlhbGl6ZSBtYXAgb2JqZWN0XG4gICAgICAgIG1hcCA9IG5ldyBnb29nbGUubWFwcy5NYXAoZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ21hcC1jYW52YXMnKSwge1xuICAgICAgICAgIGNlbnRlcjogbWFwQ2VudGVyLFxuICAgICAgICAgIHpvb206IDEwLFxuICAgICAgICAgIG1hcFR5cGVDb250cm9sOiBmYWxzZSxcbiAgICAgICAgICBzY2FsZUNvbnRyb2w6IGZhbHNlLFxuICAgICAgICAgIGZ1bGxzY3JlZW5Db250cm9sOiBmYWxzZSxcbiAgICAgICAgICBzdHJlZXRWaWV3Q29udHJvbDogZmFsc2UsXG4gICAgICAgICAgcm90YXRlQ29udHJvbDogZmFsc2VcbiAgICAgICAgfSk7XG4gICAgICB9ZWxzZSB7XG4gICAgICAgIGNsZWFyTWFya2VycygpO1xuXG4gICAgICAgIC8vc2V0IG5ldyBjZW50ZXJcbiAgICAgICAgbWFwLnBhblRvKG1hcENlbnRlcik7IC8vc21vb3RoIGNlbnRlci4gSWYgdGhlIGNoYW5nZSBpcyBsZXNzIHRoYW4gYm90aCB0aGUgd2lkdGggYW5kIGhlaWdodCBvZiB0aGUgbWFwLCB0aGUgdHJhbnNpdGlvbiB3aWxsIGJlIHNtb290aGx5IGFuaW1hdGVkLlxuICAgICAgICBtYXAuc2V0Q2VudGVyKG1hcENlbnRlcik7XG4gICAgICB9XG5cbiAgICAgIC8vIEFkZHMgYSBtYXJrZXIgYXQgdGhlIGNlbnRlciBvZiB0aGUgbWFwLlxuICAgICAgYWRkTWFya2VyKG1hcENlbnRlcik7XG5cbiAgICAgIC8vIHdoZW4gbWFwIHBvcHVwIGlzIHNob3duXG4gICAgICBtb2RhbC5vbihcInNob3duLmJzLm1vZGFsXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gUmVjZW50ZXIgdGhlIG1hcCBub3cgdGhhdCBpdCdzIGJlZW4gcmVkcmF3blxuICAgICAgICBnb29nbGUubWFwcy5ldmVudC50cmlnZ2VyKG1hcCwgXCJyZXNpemVcIik7XG4gICAgICAgIG1hcC5zZXRDZW50ZXIobWFwQ2VudGVyKTtcbiAgICAgIH0pO1xuICAgICAgbW9kYWwubW9kYWwoKTsgLy8gc2hvdyBtYXAgcG9wdXBcbiAgICB9O1xuXG4gICAgLy8gQWRkcyBhIG1hcmtlciB0byB0aGUgbWFwIGFuZCBwdXNoIHRvIHRoZSBhcnJheS5cbiAgICBmdW5jdGlvbiBhZGRNYXJrZXIobWFwQ2VudGVyKSB7XG4gICAgICB2YXIgbWFya2VyID0gbmV3IGdvb2dsZS5tYXBzLk1hcmtlcih7IC8vQ3JlYXRlIGEgbWFya2VyIGFuZCBzZXQgaXRzIHBvc2l0aW9uLlxuICAgICAgICBtYXA6IG1hcCxcbiAgICAgICAgcG9zaXRpb246IG1hcENlbnRlcixcbiAgICAgICAgaWNvbjogbmV3IGdvb2dsZS5tYXBzLk1hcmtlckltYWdlKCcuLi8uLi8uLi8uLi9hc3NldHMvY29udHJvbHMvcGluLWljLnN2ZycsXG4gICAgICAgICAgbnVsbCwgbnVsbCwgbnVsbCwgbmV3IGdvb2dsZS5tYXBzLlNpemUoMzQsIDUyKSlcbiAgICAgIH0pO1xuICAgICAgbWFya2Vycy5wdXNoKG1hcmtlcik7XG4gICAgfVxuXG4gICAgLy8gUmVtb3ZlcyB0aGUgbWFya2VycyBmcm9tIHRoZSBtYXAsIGJ1dCBrZWVwcyB0aGVtIGluIHRoZSBhcnJheS5cbiAgICBmdW5jdGlvbiBjbGVhck1hcmtlcnMoKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1hcmtlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbWFya2Vyc1tpXS5zZXRNYXAobnVsbCk7XG4gICAgICB9XG4gICAgICBtYXJrZXJzID0gW107XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2xvc2VNYXBMaXN0ZW5lcigpIHtcbiAgICAgIG1vZGFsQ29udGVudC5yZW1vdmVDbGFzcygnbmFycm93Jyk7XG4gICAgICBidG5DbG9zZU1hcC5oaWRlKCk7IC8vICdYJyAtYnV0dG9uXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdG9nZ2xlVGFncygpIHtcblx0XHRcdHZhciBpbmRUb1JlbW92ZSA9W10sIFxuICAgICAgICBpbnB1dFZhbEFycmF5ID0gJGlucHV0LnZhbCgpLnNwbGl0KFwiLFwiKTtcblxuICAgICAgJCgnbGknLCRtc0xpc3QpLmVhY2goZnVuY3Rpb24gKGkpIHtcbiAgICAgICAgdmFyIGxpc3RJdGVtID0gJCh0aGlzKSxcbiAgICAgICAgICAgIGlkID0gbGlzdEl0ZW0uZGF0YSgnc2VsZWN0b3ItJytzZWxlY3Rvcik7XG5cbiAgICAgICAgaWYobGlzdEl0ZW0uZGF0YSgnc2VsZWN0b3ItJytzZWxlY3Rvcikpe1xuXHRcdFx0XHRcdGxpc3RJdGVtLnNob3coKTtcbiAgICAgICAgICBpZiggalF1ZXJ5LmluQXJyYXkoIGlkLCBpbnB1dFZhbEFycmF5ICkgPT09IC0xKSB7XG5cdFx0XHRcdFx0XHRpbmRUb1JlbW92ZS5wdXNoKGlkKTtcbiAgICAgICAgICAgIGxpc3RJdGVtLnJlbW92ZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfWVsc2Uge1xuICAgICAgICAgIGxpc3RJdGVtLmhpZGUoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIC8vZmlsdGVyIGJ5IDogW2luZFRvUmVtb3ZlXVxuICAgICAgdGFnc0lkc1tzZWxlY3Rvcl0gPSB0YWdzSWRzW3NlbGVjdG9yXS5maWx0ZXIoIGZ1bmN0aW9uKCBlbCApIHtcbiAgICAgICAgcmV0dXJuICFpbmRUb1JlbW92ZS5pbmNsdWRlcyggZWwgKTtcbiAgICAgIH0pO1xuXG5cdFx0fVxuXG4gICAgZnVuY3Rpb24gdG9nZ2xlTXNTZWxlY3Rpb25Cb3goKSB7XG4gICAgICBpZigkKCdsaScsJG1zTGlzdCkubGVuZ3RoPDEpe1xuICAgICAgICAkbXNTZWxlY3Rpb24uaGlkZSgpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgICQoJ2xpJywkbXNMaXN0KS5lYWNoKGZ1bmN0aW9uIChpKSB7XG4gICAgICAgIHZhciBsaXN0SXRlbSA9ICQodGhpcyk7XG4gICAgICAgIGlmIChsaXN0SXRlbS5kYXRhKCdzZWxlY3Rvci0nICsgc2VsZWN0b3IpKSB7XG4gICAgICAgICAgJG1zU2VsZWN0aW9uLnNob3coKTtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSAkbXNTZWxlY3Rpb24uaGlkZSgpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogY2hhbmdlIDxMb2FkX01vcmU+IGJ1dHRvbiB0ZXh0IG9uIG9wZW4gbW9kYWxcbiAgICAgKiBzZXQgZGF0YS1zZWxlY3RvciBnb3IgXCJHRVRcIiBidXR0b25cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjaGFuZ2VNb2RhbFRleHRMaXN0ZW5lcigpIHtcbiAgICAgIGlmIChzZWxlY3RvciAhPT0gJ2V2ZW50cycpIHtcbiAgICAgICAgJCgnLm1vZGFsLXRpdGxlIHNwYW4nLCAkbW9kYWwpLnRleHQoc2VsZWN0b3IpO1xuICAgICAgICAkKCcjanNfbHMtbW9yZV9idG4nLCAkbW9kYWwpLnRleHQoJ1NIT1cgTU9SRSAnICsgc2VsZWN0b3IpO1xuICAgICAgfVxuICAgICAgaWYoc2VsZWN0b3IgPT09ICd2ZW51ZXMnKXtcblx0XHRcdFx0JCgnLndyYXBwZXItbGlzdC1ncm91cCcsICRtb2RhbCkuYWRkQ2xhc3MoJ2xvdy1oZWlnaHQnKTtcbiAgICAgICAgJG1zU2VsZWN0aW9uLmFkZENsYXNzKCdoaWRkZW4teHMnKTtcbiAgICAgIH1lbHNle1xuICAgICAgICAkKCcud3JhcHBlci1saXN0LWdyb3VwJywgJG1vZGFsKS5yZW1vdmVDbGFzcygnbG93LWhlaWdodCcpO1xuICAgICAgICAkbXNTZWxlY3Rpb24ucmVtb3ZlQ2xhc3MoJ2hpZGRlbi14cycpO1xuICAgICAgfVxuXG5cdFx0XHRpZihvcHRpb25zLmhpZGVNdWx0aVNlbGVjdG9yKSB7XG5cdFx0XHRcdCRtc1NlbGVjdGlvbi5oaWRlKCk7XG5cdFx0XHR9ZWxzZXtcblx0XHRcdFx0aWYoJCgnbGknLCRtc0xpc3QpLmxlbmd0aD4wKXtcblx0XHRcdFx0XHQkbXNTZWxlY3Rpb24uc2hvdygpOyAvLyBjb25zb2xlLmxvZygnc2hvdyAkbXNMaXN0JywkKCdsaScsJG1zTGlzdCkubGVuZ3RoKTtcblx0XHRcdFx0fVxuICAgICAgICB0b2dnbGVUYWdzKCk7XG4gICAgICAgIHRvZ2dsZU1zU2VsZWN0aW9uQm94KCk7XG5cdFx0XHR9XG5cbiAgICAgICRidG5HRVQuYXR0cignZGF0YS1zZWxlY3RvcicsIHNlbGVjdG9yKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBzaG93L2hpZGUgbG9hZGVyXG4gICAgICogQHBhcmFtIGFjdGlvbiAtIHN0cmluZyAoJ29uJyBvciAnb2ZmJylcbiAgICAgKi9cbiAgICB2YXIgbG9hZGluZyA9IGZ1bmN0aW9uIChhY3Rpb24pIHtcbiAgICAgIHZhciBzcGlubmVyID0gJCgnI3NwaW5uZXItbHMnLCAkbW9kYWwpO1xuICAgICAgLy8gYWRkIHRoZSBvdmVybGF5IHdpdGggbG9hZGluZyBpbWFnZSB0byB0aGUgcGFnZVxuICAgICAgaWYgKGFjdGlvbiA9PSBcIm9uXCIpIHtcbiAgICAgICAgc3Bpbm5lci5zaG93KCk7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChhY3Rpb24gPT0gXCJvZmZcIikge1xuICAgICAgICBzcGlubmVyLmhpZGUoKTtcbiAgICAgIH1cblxuICAgIH07XG5cbiAgICBmdW5jdGlvbiByZXNldEZvcm0oKSB7XG4gICAgICBzdGF0ZUNvbmYucGFnZUluY3JlbWVudCA9IDA7XG4gICAgICB2YXIgbGlzdEl0ZW1zID0gJHVsLmZpbmQoJ2xpJyk7XG4gICAgICBsaXN0SXRlbXMucmVtb3ZlKCk7XG4gICAgICAkaHIuaGlkZSgpO1xuICAgICAgJGxpRm9vdGVyLmhpZGUoKTtcblxuICAgICAgLy8gQ2xlYXIgaGlnaGxpZ2h0XG4gICAgICAkZm9ybS5yZW1vdmVDbGFzcyhjc3NWYWxpZGF0aW9uQ2xhc3MpO1xuXG4gICAgICAvLyBDbGVhciBMaXN0ZW5lciwgcHJldmVudCBtZW1vcnkgbGVha1xuICAgICAgJCggXCIjanNfbHMtbW9kYWxcIiApLm9mZiggXCJjbGlja1wiLCBcInVsIGxpIGJ1dHRvbi5qc19tcy1hZGQtbGlzdF9idG5cIiwgYWRkTXNCdXR0b25MaXN0ZW5lciApO1xuICAgICAgJCgnI2pzX29wZW4tbWFwX2J0bicpLm9mZiggXCJjbGlja1wiLCBtYXBMaXN0ZW5lciApO1xuXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSGFuZGxlciBmb3IgJ0dFVCcgYnV0dG9uXG4gICAgICogQHBhcmFtIHBhZ2VOdW1lcm8gLSBpbnQuIHVzZWQgZm9yIHBhZ2luYXRpb25cbiAgICAgKiBAcGFyYW0gZXZlbnRVcmwgLSB1cmwgb2YgcmVxdWVzdFxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSAtIGRvbmUvZmFpbFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHN1Ym1pdEZvcm0oLypvcHRpb25hbCovcGFnZU51bWVybykge1xuICAgICAgcGFnZU51bWVybyA9IHBhcnNlSW50KHBhZ2VOdW1lcm8pO1xuXG4gICAgICB2YXIgdXJsID0gKCBpc05hTihwYWdlTnVtZXJvKSApID8gZXZlbnRVcmwgKyAnP2FwaWtleT0nICsgYXBpa2V5ICsgJyZrZXl3b3JkPScgKyBrZXl3b3JkLnZhbCgpIDpcbiAgICAgICAgZXZlbnRVcmwgKyAnP2FwaWtleT0nICsgYXBpa2V5ICsgJyZrZXl3b3JkPScgKyBrZXl3b3JkLnZhbCgpICsgJyZwYWdlPScgKyBwYWdlTnVtZXJvO1xuXG4gICAgICAvL3N0b3AgbG9hZFxuICAgICAgaWYgKGlzTmFOKHBhZ2VOdW1lcm8pICYmIHBhZ2VOdW1lcm8gIT09IDAgJiYgc3RhdGVDb25mLmxvYWRpbmdGbGFnID09PSAnU1RPUF9MT0FEJykge1xuICAgICAgICByZW5kZXJSZXN1bHRzKG51bGwsICR1bCk7XG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuXG5cdFx0XHQvL3N0b3AgbG9hZFxuICAgICAgaWYgKHN0YXRlQ29uZi5sb2FkaW5nRmxhZyA9PT0gJ0ZJTkFMX1BBR0UnKSByZXR1cm4gZmFsc2U7XG5cbiAgICAgICQuYWpheCh7XG4gICAgICAgIGRhdGFUeXBlOiAnanNvbicsXG4gICAgICAgIGFzeW5jOiB0cnVlLFxuICAgICAgICB1cmw6IHVybCxcbiAgICAgICAgZGF0YTogJGZvcm0uc2VyaWFsaXplKClcbiAgICAgIH0pLmRvbmUoZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgICAgLy9sYXN0IHBhZ2UgcmVhY2hlZFxuICAgICAgICAgIGlmIChzdGF0ZUNvbmYucGFnZUluY3JlbWVudCA9PT0gcmVzdWx0LnBhZ2UudG90YWxQYWdlcyAmJiByZXN1bHQucGFnZS50b3RhbEVsZW1lbnRzID4gMCkge1xuICAgICAgICAgICAgc3RhdGVDb25mLmxvYWRpbmdGbGFnID0gJ1NUT1BfTE9BRCc7XG4gICAgICAgICAgICBsb2FkaW5nKCdvZmYnKTtcbiAgICAgICAgICAgIHJlbmRlclJlc3VsdHMocmVzdWx0LCAkdWwpOyAvL2FkZCBtZXNzYWdlIGF0IGJvdHRvbSBvZiBsaXN0XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmVuZGVyUmVzdWx0cyhyZXN1bHQsICR1bCk7XG4gICAgICAgICAgbG9hZGluZygnb2ZmJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc29sZS5sb2coJ25vIHJlc3VsdCBmb3VuZCcpO1xuICAgICAgICB9XG4gICAgICB9KS5mYWlsKGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdUaGVyZSB3YXMgYW4gZmFpbCBzdGF0dXMgLSAnICwgZS5zdGF0dXMpO1xuICAgICAgICBsb2FkaW5nKCdvZmYnKTtcbiAgICAgICAgcmVuZGVyUmVzdWx0cygnRkFJTCcsICR1bCk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBmaW5kIGltYWdlIHRoYXQgaGF2ZSB3aWR0aCBtb3JlIHRoZW4gMTIwcHhcbiAgICAgKiBAcGFyYW0gaW1hZ2VzIC0gYXJyYXlcbiAgICAgKiBAcmV0dXJucyB7aW1hZ2Ugd2l0aCBsb3dlc3QrMSB3aWR0aCB9XG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2V0SW1hZ2VGb3JFdmVudChpbWFnZXMpIHtcbiAgICAgIGltYWdlcy5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIGlmIChhLndpZHRoIDwgYi53aWR0aClcbiAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIGVsc2UgaWYgKGEud2lkdGggPiBiLndpZHRoKVxuICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBpbWFnZXNbMV0udXJsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIHJlbmRlciBmb3IgZXZlbnRzLWlkLXNlbGVjdG9yXG4gICAgICogQHBhcmFtIGl0ZW1zIC0gYXJyYXlcbiAgICAgKi9cbiAgICBmdW5jdGlvbiByZW5kZXJMaXN0RXZlbnRzKGl0ZW1zKSB7XG4gICAgICB2YXIgc3JjO1xuICAgICAgaXRlbXMubWFwKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgIHZhciBsaSA9ICQoJzxsaS8+JylcbiAgICAgICAgICAuYWRkQ2xhc3MoJ2xpc3QtZ3JvdXAtaXRlbSByb3cnKVxuICAgICAgICAgIC8vLmluc2VydEJlZm9yZSgkbGlGb290ZXIpO1xuICAgICAgICAgIC5hcHBlbmRUbygkdWwpO1xuXG4gICAgICAgIHZhciBsZWZ0Q29sID0gJCgnPGRpdiBjbGFzcz1cImNsZWFyLXBhZGRpbmdcIiAvPicpLmFwcGVuZFRvKGxpKTtcbiAgICAgICAgdmFyIHNwYW5JbWcgPSAkKCc8c3BhbiBjbGFzcz1cInRodW1ibmFpbFwiIC8+JylcbiAgICAgICAgICAuYXBwZW5kVG8obGVmdENvbCk7XG5cbiAgICAgICAgaWYgKGl0ZW0uaW1hZ2VzKSB7XG4gICAgICAgICAgc3JjID0gXCJzcmM9XCIgKyBnZXRJbWFnZUZvckV2ZW50KGl0ZW0uaW1hZ2VzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzcmMgPSAnc3R5bGU9XCJiYWNrZ3JvdW5kLWNvbG9yOiAjZjdmOWZhO3dpZHRoOiAxMjBweDsgYm9yZGVyOiBub25lO1wiJztcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBpbWcgPSAkKCc8aW1nICcgKyBzcmMgKyAnIC8+JylcbiAgICAgICAgICAuYWRkQ2xhc3MoJ2xpc3QtZ3JvdXAtaXRlbS1oZWFkaW5nJylcbiAgICAgICAgICAuYXBwZW5kVG8oc3BhbkltZyk7XG5cbiAgICAgICAgdmFyICR3cmFwQ29sID0gJCgnPGRpdiBjbGFzcz1cImV2ZW50LXRleHQtd3JhcHBlclwiLz4nKVxuICAgICAgICAgIC5hcHBlbmRUbyhsaSk7XG4gICAgICAgIGlmIChpdGVtLm5hbWUpIHtcbiAgICAgICAgICB2YXIgdGl0bGUgPSAkKCc8aDQvPicpXG4gICAgICAgICAgICAuYWRkQ2xhc3MoJ2xpc3QtZ3JvdXAtaXRlbS1oZWFkaW5nJylcbiAgICAgICAgICAgIC50ZXh0KGl0ZW0ubmFtZSlcbiAgICAgICAgICAgIC5hcHBlbmRUbygkd3JhcENvbCk7XG4gICAgICAgIH1cblxuICAgICAgICAvKmFkZCB0aW1lKi9cbiAgICAgICAgdmFyIGN1cnJlbnRFdmVudCA9IHt9O1xuICAgICAgICBjdXJyZW50RXZlbnQuZGF0ZSA9IHtcbiAgICAgICAgICBkYXk6IGl0ZW0uZGF0ZXMuc3RhcnQubG9jYWxEYXRlLFxuICAgICAgICAgIHRpbWU6IGl0ZW0uZGF0ZXMuc3RhcnQubG9jYWxUaW1lLFxuICAgICAgICAgIGRhdGVUaW1lOiBpdGVtLmRhdGVzLnN0YXJ0LmRhdGVUaW1lXG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIHRpbWUgPSBmb3JtYXREYXRlKGN1cnJlbnRFdmVudC5kYXRlKTtcbiAgICAgICAgdmFyIGV2ZW50VGltZSA9ICQoJzxoNCBjbGFzcz1cImV2ZW50LXRpbWUgZ3JheVwiLz4nKVxuICAgICAgICAgIC50ZXh0KHRpbWUpXG4gICAgICAgICAgLmFwcGVuZFRvKCR3cmFwQ29sKTtcbiAgICAgICAgLyphZGQgdGltZSBlbmQqL1xuXG4gICAgICAgIGlmIChpdGVtLl9lbWJlZGRlZCkge1xuXG4gICAgICAgICAgaWYgKGl0ZW0uX2VtYmVkZGVkLnZlbnVlcykge1xuICAgICAgICAgICAgdmFyIHZlbnVlID0gaXRlbS5fZW1iZWRkZWQudmVudWVzWzBdO1xuICAgICAgICAgICAgdmFyIGFkZHJlc3NOYW1lID0gJCgnPHNwYW4vPicpXG4gICAgICAgICAgICAgIC5hZGRDbGFzcygnYWRkcmVzcy1uYW1lJylcbiAgICAgICAgICAgICAgLnRleHQodmVudWUubmFtZSArICcuICcpXG4gICAgICAgICAgICAgIC5hcHBlbmRUbygkd3JhcENvbCk7XG5cbiAgICAgICAgICAgIGlmICgnYWRkcmVzcycgaW4gdmVudWUgJiYgJ2xpbmUxJyBpbiB2ZW51ZS5hZGRyZXNzKSB7XG4gICAgICAgICAgICAgIHZhciBhZGRyZXNzbGluZTEgPSAkKCc8c3Bhbi8+JylcbiAgICAgICAgICAgICAgICAuYWRkQ2xhc3MoJ2FkZHJlc3MtbGluZTEnKVxuICAgICAgICAgICAgICAgIC50ZXh0KHZlbnVlLmFkZHJlc3MubGluZTEpXG4gICAgICAgICAgICAgICAgLmFwcGVuZFRvKCR3cmFwQ29sKTtcbiAgICAgICAgICAgICAgaWYgKCdsaW5lMicgaW4gdmVudWUuYWRkcmVzcykge1xuICAgICAgICAgICAgICAgIHZhciBhZGRyZXNzbGluZTIgPSAkKCc8c3Bhbi8+JylcbiAgICAgICAgICAgICAgICAgIC5hZGRDbGFzcygnYWRkcmVzcy1saW5lMicpXG4gICAgICAgICAgICAgICAgICAudGV4dCh2ZW51ZS5hZGRyZXNzLmxpbmUyKVxuICAgICAgICAgICAgICAgICAgLmFwcGVuZFRvKGFkZHJlc3NsaW5lMSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnbm8gX2VtYmVkZGVkIGZvdW5kJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGl0ZW0uaWQpIHtcbiAgICAgICAgICAvL2FkZCBidXR0b24gPFNldCB0aGlzIElEPiBpZiAnbG9jYXRpb24nIGV4aXN0XG4gICAgICAgICAgdmFyIGJ1dHRvblNldElkID0gJChcIjxidXR0b24gZGF0YS1ldmVudD1cIiArIGl0ZW0uaWQgKyBcIi8+XCIpXG4gICAgICAgICAgICAuYWRkQ2xhc3MoJ2pzX2xhenktc2VsX2J0biBidG4gYnRuLXN1Ym1pdCcpXG4gICAgICAgICAgICAudGV4dCgnVXNlIHRoaXMgSUQnKVxuICAgICAgICAgICAgLmFwcGVuZFRvKGxpKVxuICAgICAgICAgICAgLndyYXAoJzxkaXYgY2xhc3MgPVwid3JhcHBlci1idG5zIHRleHQtcmlnaHRcIi8+Jyk7XG5cblx0XHRcdFx0XHRcdHZhciBhZGRUb0VsID0ge2xpOiBsaSwgYnV0dG9uU2V0SWRXcmFwcGVyOiBidXR0b25TZXRJZC5wYXJlbnQoKX07XG5cdFx0XHRcdFx0XHRhZGRNc0J1dHRvbiggYWRkVG9FbCAsIGl0ZW0uaWQpO1xuICAgICAgICB9XG5cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIHJlbmRlciBmb3IgdmVudWVzLWlkLXNlbGVjdG9yXG4gICAgICogQHBhcmFtIGl0ZW1zIC0gYXJyYXlcbiAgICAgKi9cbiAgICBmdW5jdGlvbiByZW5kZXJMaXN0VmVudWVzKGl0ZW1zKSB7XG4gICAgICBpdGVtcy5tYXAoZnVuY3Rpb24gKGl0ZW0pIHtcblxuICAgICAgICB2YXIgbGkgPSAkKCc8bGkvPicpXG4gICAgICAgICAgLmFkZENsYXNzKCdsaXN0LWdyb3VwLWl0ZW0gcm93JylcbiAgICAgICAgICAuYXBwZW5kVG8oJHVsKTtcblxuICAgICAgICBpZiAoaXRlbS5pbWFnZXMpIHtcbiAgICAgICAgICB2YXIgbGVmdENvbCA9ICQoJzxkaXYgY2xhc3M9XCJjbGVhci1wYWRkaW5nXCIgLz4nKS5hcHBlbmRUbyhsaSk7XG4gICAgICAgICAgdmFyIHNwYW5JbWcgPSAkKCc8c3BhbiBjbGFzcz1cInRodW1ibmFpbFwiIC8+JylcbiAgICAgICAgICAgIC5hcHBlbmRUbyhsZWZ0Q29sKTtcbiAgICAgICAgICB2YXIgaW1nID0gJCgnPGltZyBzcmM9JyArIGdldEltYWdlRm9yRXZlbnQoaXRlbS5pbWFnZXMpICsgJyAvPicpXG4gICAgICAgICAgICAuYWRkQ2xhc3MoJ2xpc3QtZ3JvdXAtaXRlbS1oZWFkaW5nJylcbiAgICAgICAgICAgIC5hcHBlbmRUbyhzcGFuSW1nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciAkd3JhcENvbCA9ICQoJzxkaXYgY2xhc3M9XCJldmVudC10ZXh0LXdyYXBwZXIgY2xlYXItbWFyZ2luLWxlZnRcIi8+JylcbiAgICAgICAgICAuYXBwZW5kVG8obGkpO1xuXG4gICAgICAgIGlmIChpdGVtLm5hbWUpIHtcbiAgICAgICAgICB2YXIgdGl0bGUgPSAkKCc8aDMvPicpXG4gICAgICAgICAgICAuYWRkQ2xhc3MoJ2xpc3QtZ3JvdXAtaXRlbS1oZWFkaW5nJylcbiAgICAgICAgICAgIC50ZXh0KGl0ZW0ubmFtZSlcbiAgICAgICAgICAgIC5hcHBlbmRUbygkd3JhcENvbCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXRlbS5kYXRlcykge1xuICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdpdGVtLmRhdGVzJyAsIGl0ZW0uZGF0ZXMpO1xuICAgICAgICAgIC8qYWRkIHRpbWUqL1xuICAgICAgICAgIHZhciBjdXJyZW50RXZlbnQgPSB7fTtcbiAgICAgICAgICBjdXJyZW50RXZlbnQuZGF0ZSA9IHtcbiAgICAgICAgICAgIGRheTogaXRlbS5kYXRlcy5zdGFydC5sb2NhbERhdGUsXG4gICAgICAgICAgICB0aW1lOiBpdGVtLmRhdGVzLnN0YXJ0LmxvY2FsVGltZSxcbiAgICAgICAgICAgIGRhdGVUaW1lOiBpdGVtLmRhdGVzLnN0YXJ0LmRhdGVUaW1lXG4gICAgICAgICAgfTtcblxuICAgICAgICAgIHZhciB0aW1lID0gZm9ybWF0RGF0ZShjdXJyZW50RXZlbnQuZGF0ZSk7XG4gICAgICAgICAgdmFyIGV2ZW50VGltZSA9ICQoJzxoNCBjbGFzcz1cImV2ZW50LXRpbWUgZ3JheVwiLz4nKVxuICAgICAgICAgICAgLnRleHQodGltZSlcbiAgICAgICAgICAgIC5hcHBlbmRUbygkd3JhcENvbCk7XG4gICAgICAgICAgLyphZGQgdGltZSBlbmQqL1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGl0ZW0pIHtcbiAgICAgICAgICB2YXIgdmVudWUgPSBpdGVtOyAvLyBpdGVtLl9lbWJlZGRlZC52ZW51ZXNbMF07XG4gICAgICAgICAgdmFyIGNvbnRyeVN0YXRlTmFtZSA9ICQoJzxoNC8+JylcbiAgICAgICAgICAgIC5hZGRDbGFzcygnY291bnRyeS1uYW1lIGdyYXknKVxuICAgICAgICAgICAgLnRleHQoKHZlbnVlLmNvdW50cnkgJiYgdmVudWUuY291bnRyeS5uYW1lKSA/IHZlbnVlLmNvdW50cnkubmFtZSA6ICcnKVxuICAgICAgICAgICAgLmFwcGVuZCgodmVudWUuc3RhdGUgJiYgdmVudWUuc3RhdGUubmFtZSkgPyAkKCc8c3BhbiBjbGFzcz1cImFkZC1kb3RcIj4nICt2ZW51ZS5zdGF0ZS5uYW1lKyAnPC8+Jyk6ICcnKVxuICAgICAgICAgICAgLmFwcGVuZFRvKCR3cmFwQ29sKTtcbiAgICAgICAgICB2YXIgY2l0eU5hbWUgPSAkKCc8c3Bhbi8+JylcbiAgICAgICAgICAgIC5hZGRDbGFzcygnYWRkcmVzcy1uYW1lJylcbiAgICAgICAgICAgIC50ZXh0KCh2ZW51ZS5jaXR5ICYmIHZlbnVlLmNpdHkubmFtZSkgPyB2ZW51ZS5jaXR5Lm5hbWUgKyAnLiAnIDogJycpXG4gICAgICAgICAgICAuYXBwZW5kVG8oJHdyYXBDb2wpO1xuXG4gICAgICAgICAgaWYgKCdhZGRyZXNzJyBpbiB2ZW51ZSAmJiAnbGluZTEnIGluIHZlbnVlLmFkZHJlc3MpIHtcbiAgICAgICAgICAgIHZhciBhZGRyZXNzbGluZTEgPSAkKCc8c3Bhbi8+JylcbiAgICAgICAgICAgICAgLmFkZENsYXNzKCdhZGRyZXNzLWxpbmUxJylcbiAgICAgICAgICAgICAgLnRleHQodmVudWUuYWRkcmVzcy5saW5lMSArICcuJylcbiAgICAgICAgICAgICAgLmFwcGVuZFRvKCR3cmFwQ29sKTtcbiAgICAgICAgICAgIGlmICgnbGluZTInIGluIHZlbnVlLmFkZHJlc3MpIHtcbiAgICAgICAgICAgICAgdmFyIGFkZHJlc3NsaW5lMiA9ICQoJzxzcGFuLz4nKVxuICAgICAgICAgICAgICAgIC5hZGRDbGFzcygnYWRkcmVzcy1saW5lMicpXG4gICAgICAgICAgICAgICAgLnRleHQodmVudWUuYWRkcmVzcy5saW5lMilcbiAgICAgICAgICAgICAgICAuYXBwZW5kVG8oYWRkcmVzc2xpbmUxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zb2xlLmxvZygnbm8gX2VtYmVkZGVkIGZvdW5kJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXRlbS5pZCkge1xuICAgICAgICAgIHZhciBidXR0b25TZXRJZCA9ICQoXCI8YnV0dG9uIGRhdGEtZXZlbnQ9XCIgKyBpdGVtLmlkICsgXCIvPlwiKVxuICAgICAgICAgICAgLmFkZENsYXNzKCdqc19sYXp5LXNlbF9idG4gYnRuIGJ0bi1zdWJtaXQnKVxuICAgICAgICAgICAgLnRleHQoJ1VzZSB0aGlzIElEJylcbiAgICAgICAgICAgIC5hcHBlbmRUbyhsaSlcbiAgICAgICAgICAgIC53cmFwKCc8ZGl2IGNsYXNzID1cIndyYXBwZXItYnRucyB0ZXh0LXJpZ2h0XCIvPicpO1xuICAgICAgICAgIGlmICh2ZW51ZS5sb2NhdGlvbiAmJiB2ZW51ZS5sb2NhdGlvbi5sYXRpdHVkZSAmJiB2ZW51ZS5sb2NhdGlvbi5sb25naXR1ZGUpIHtcbiAgICAgICAgICAgIC8vY29uc29sZS5sb2coJ3ZlbnVlLmxvY2F0aW9uIC0gJyAsIHZlbnVlLmxvY2F0aW9uKTtcbiAgICAgICAgICAgIHZhciBidXR0b25NYXAgPSAkKFwiPGJ1dHRvbiBkYXRhLWxhdGl0dWRlPVwiICsgdmVudWUubG9jYXRpb24ubGF0aXR1ZGUgKyBcIiBkYXRhLWxvbmdpdHVkZT1cIiArIHZlbnVlLmxvY2F0aW9uLmxvbmdpdHVkZSArIFwiLz5cIilcbiAgICAgICAgICAgICAgLmFkZENsYXNzKCdqc19vcGVuLW1hcF9idG4gYnRuIGJ0bi10cmFuc3BhcmVudCcpXG4gICAgICAgICAgICAgIC50ZXh0KCdTaG93IG9uIG1hcCcpXG4gICAgICAgICAgICAgIC5pbnNlcnRBZnRlcihidXR0b25TZXRJZClcbiAgICAgICAgICAgICAgLy8uYXBwZW5kVG8oYnV0dG9uU2V0SWQpXG4gICAgICAgICAgICAgIC53cmFwKCc8ZGl2IGNsYXNzID1cIndyYXBwZXItbG9jYXRpb25fYnRuIHB1bGwtcmlnaHRcIi8+Jyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBhZGRUb0VsID0ge2xpOiBsaSwgYnV0dG9uU2V0SWRXcmFwcGVyOiBidXR0b25TZXRJZC5wYXJlbnQoKX07XG4gICAgICAgICAgYWRkTXNCdXR0b24oIGFkZFRvRWwgLCBpdGVtLmlkKTtcbiAgICAgICAgfVxuXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiByZW5kZXIgZm9yIGF0dHJhY3Rpb25zLWlkLXNlbGVjdG9yXG4gICAgICogQHBhcmFtIGl0ZW1zIC0gYXJyYXlcbiAgICAgKi9cbiAgICBmdW5jdGlvbiByZW5kZXJMaXN0QXR0cmFjdGlvbnMoaXRlbXMpIHtcbiAgICAgIGl0ZW1zLm1hcChmdW5jdGlvbiAoaXRlbSkge1xuXG4gICAgICAgIHZhciBsaSA9ICQoJzxsaS8+JylcbiAgICAgICAgICAuYWRkQ2xhc3MoJ2xpc3QtZ3JvdXAtaXRlbSByb3cnKVxuICAgICAgICAgIC5hcHBlbmRUbygkdWwpO1xuXG4gICAgICAgIGlmIChpdGVtLmltYWdlcykge1xuICAgICAgICAgIHZhciBsZWZ0Q29sID0gJCgnPGRpdiBjbGFzcz1cImNsZWFyLXBhZGRpbmdcIiAvPicpLmFwcGVuZFRvKGxpKTtcbiAgICAgICAgICB2YXIgc3BhbkltZyA9ICQoJzxzcGFuIGNsYXNzPVwidGh1bWJuYWlsXCIgLz4nKVxuICAgICAgICAgICAgLmFwcGVuZFRvKGxlZnRDb2wpO1xuICAgICAgICAgIHZhciBpbWcgPSAkKCc8aW1nIHNyYz0nICsgZ2V0SW1hZ2VGb3JFdmVudChpdGVtLmltYWdlcykgKyAnIC8+JylcbiAgICAgICAgICAgIC5hZGRDbGFzcygnbGlzdC1ncm91cC1pdGVtLWhlYWRpbmcnKVxuICAgICAgICAgICAgLmFwcGVuZFRvKHNwYW5JbWcpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyICR3cmFwQ29sID0gJCgnPGRpdiBjbGFzcz1cImV2ZW50LXRleHQtd3JhcHBlciBjbGVhci1tYXJnaW4tbGVmdFwiLz4nKVxuICAgICAgICAgIC5hcHBlbmRUbyhsaSk7XG5cbiAgICAgICAgaWYgKGl0ZW0ubmFtZSkge1xuICAgICAgICAgIHZhciB0aXRsZSA9ICQoJzxoMy8+JylcbiAgICAgICAgICAgIC5hZGRDbGFzcygnbGlzdC1ncm91cC1pdGVtLWhlYWRpbmcnKVxuICAgICAgICAgICAgLnRleHQoaXRlbS5uYW1lKVxuICAgICAgICAgICAgLmFwcGVuZFRvKCR3cmFwQ29sKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qYWRkIHRpbWUqL1xuICAgICAgICBpZiAoaXRlbS5kYXRlcykge1xuICAgICAgICAgIHZhciBjdXJyZW50RXZlbnQgPSB7fTtcbiAgICAgICAgICBjdXJyZW50RXZlbnQuZGF0ZSA9IHtcbiAgICAgICAgICAgIGRheTogaXRlbS5kYXRlcy5zdGFydC5sb2NhbERhdGUsXG4gICAgICAgICAgICB0aW1lOiBpdGVtLmRhdGVzLnN0YXJ0LmxvY2FsVGltZSxcbiAgICAgICAgICAgIGRhdGVUaW1lOiBpdGVtLmRhdGVzLnN0YXJ0LmRhdGVUaW1lXG4gICAgICAgICAgfTtcblxuICAgICAgICAgIHZhciB0aW1lID0gZm9ybWF0RGF0ZShjdXJyZW50RXZlbnQuZGF0ZSk7XG4gICAgICAgICAgdmFyIGV2ZW50VGltZSA9ICQoJzxoNCBjbGFzcz1cImV2ZW50LXRpbWUgZ3JheVwiLz4nKVxuICAgICAgICAgICAgLnRleHQodGltZSlcbiAgICAgICAgICAgIC5hcHBlbmRUbygkd3JhcENvbCk7XG4gICAgICAgIH0vKmFkZCB0aW1lIGVuZCovXG5cbiAgICAgICAgaWYoaXRlbS5jbGFzc2lmaWNhdGlvbnMpe1xuICAgICAgICAgIGlmKGl0ZW0uY2xhc3NpZmljYXRpb25zLmxlbmd0aCA+IDEpIGNvbnNvbGUubG9nKGl0ZW0uY2xhc3NpZmljYXRpb25zLmxlbmd0aCk7XG5cbiAgICAgICAgICB2YXIgX2dlbnJlLCBfc3ViZ2VucmUsX3NlZ21lbnQ7XG4gICAgICAgICAgaWYoaXRlbS5jbGFzc2lmaWNhdGlvbnNbMF0pe1xuICAgICAgICAgICAgX3NlZ21lbnQgPSBpdGVtLmNsYXNzaWZpY2F0aW9uc1swXS5zZWdtZW50O1xuICAgICAgICAgICAgX2dlbnJlID0gaXRlbS5jbGFzc2lmaWNhdGlvbnNbMF0uZ2VucmU7XG4gICAgICAgICAgICBfc3ViZ2VucmUgPSBpdGVtLmNsYXNzaWZpY2F0aW9uc1swXS5zdWJHZW5yZTtcblxuICAgICAgICAgICAgdmFyIHNlZ21lbnRUZXh0ID0gJCgnPGg0Lz4nKVxuICAgICAgICAgICAgICAuYWRkQ2xhc3MoJ2NvdW50cnktbmFtZSBncmF5JylcbiAgICAgICAgICAgICAgLnRleHQoKCBfc2VnbWVudCAmJiBfc2VnbWVudC5uYW1lICYmIF9zZWdtZW50Lm5hbWUgIT09ICdVbmRlZmluZWQnKSA/IF9zZWdtZW50Lm5hbWUgOiAnJylcbiAgICAgICAgICAgICAgLmFwcGVuZFRvKCR3cmFwQ29sKTtcblxuICAgICAgICAgICAgdmFyIGdlbnJlID0gJCgnPHNwYW4vPicpXG4gICAgICAgICAgICAgIC5hZGRDbGFzcygnY2xhc3NpZmljYXRpb25zLW5hbWUnKVxuICAgICAgICAgICAgICAuYXBwZW5kKCggX2dlbnJlICYmIF9nZW5yZS5uYW1lICYmIF9nZW5yZS5uYW1lICE9PSAnVW5kZWZpbmVkJykgPyAkKCc8c3BhbiA+JyArX2dlbnJlLm5hbWUrICc8Lz4nKTogJycpXG4gICAgICAgICAgICAgIC5hcHBlbmQoKCBfc3ViZ2VucmUgJiYgX3N1YmdlbnJlLm5hbWUgJiYgX3N1YmdlbnJlLm5hbWUgIT09ICdVbmRlZmluZWQnKSA/ICQoJzxzcGFuIGNsYXNzPVwiYWRkLWRvdFwiPicgK19zdWJnZW5yZS5uYW1lKyAnPC8+Jyk6ICcnKVxuICAgICAgICAgICAgICAuYXBwZW5kVG8oJHdyYXBDb2wpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoaXRlbSkge1xuICAgICAgICAgIHZhciB2ZW51ZSA9IGl0ZW07IC8vIGl0ZW0uX2VtYmVkZGVkLnZlbnVlc1swXTtcbiAgICAgICAgICB2YXIgY29udHJ5U3RhdGVOYW1lID0gJCgnPGg0Lz4nKVxuICAgICAgICAgICAgLmFkZENsYXNzKCdjb3VudHJ5LW5hbWUgZ3JheScpXG4gICAgICAgICAgICAudGV4dCgodmVudWUuY291bnRyeSAmJiB2ZW51ZS5jb3VudHJ5Lm5hbWUpID8gdmVudWUuY291bnRyeS5uYW1lICsgJy4gJyA6ICcnKVxuICAgICAgICAgICAgLmFwcGVuZCgodmVudWUuc3RhdGUgJiYgdmVudWUuc3RhdGUubmFtZSkgPyB2ZW51ZS5zdGF0ZS5uYW1lICsgJy4gJyA6ICcnKVxuICAgICAgICAgICAgLmFwcGVuZFRvKCR3cmFwQ29sKTtcbiAgICAgICAgICB2YXIgY2l0eU5hbWUgPSAkKCc8c3Bhbi8+JylcbiAgICAgICAgICAgIC5hZGRDbGFzcygnYWRkcmVzcy1uYW1lJylcbiAgICAgICAgICAgIC50ZXh0KCh2ZW51ZS5jaXR5ICYmIHZlbnVlLmNpdHkubmFtZSkgPyB2ZW51ZS5jaXR5Lm5hbWUgKyAnLiAnIDogJycpXG4gICAgICAgICAgICAuYXBwZW5kVG8oJHdyYXBDb2wpO1xuXG4gICAgICAgICAgaWYgKCdhZGRyZXNzJyBpbiB2ZW51ZSAmJiAnbGluZTEnIGluIHZlbnVlLmFkZHJlc3MpIHtcbiAgICAgICAgICAgIHZhciBhZGRyZXNzbGluZTEgPSAkKCc8c3Bhbi8+JylcbiAgICAgICAgICAgICAgLmFkZENsYXNzKCdhZGRyZXNzLWxpbmUxJylcbiAgICAgICAgICAgICAgLnRleHQodmVudWUuYWRkcmVzcy5saW5lMSArICcuJylcbiAgICAgICAgICAgICAgLmFwcGVuZFRvKCR3cmFwQ29sKTtcbiAgICAgICAgICAgIGlmICgnbGluZTInIGluIHZlbnVlLmFkZHJlc3MpIHtcbiAgICAgICAgICAgICAgdmFyIGFkZHJlc3NsaW5lMiA9ICQoJzxzcGFuLz4nKVxuICAgICAgICAgICAgICAgIC5hZGRDbGFzcygnYWRkcmVzcy1saW5lMicpXG4gICAgICAgICAgICAgICAgLnRleHQodmVudWUuYWRkcmVzcy5saW5lMilcbiAgICAgICAgICAgICAgICAuYXBwZW5kVG8oYWRkcmVzc2xpbmUxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zb2xlLmxvZygnbm8gX2VtYmVkZGVkIGZvdW5kJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXRlbS5pZCkge1xuICAgICAgICAgIHZhciBidXR0b25TZXRJZCA9ICQoXCI8YnV0dG9uIGRhdGEtZXZlbnQ9XCIgKyBpdGVtLmlkICsgXCIvPlwiKVxuICAgICAgICAgICAgLmFkZENsYXNzKCdqc19sYXp5LXNlbF9idG4gYnRuIGJ0bi1zdWJtaXQnKVxuICAgICAgICAgICAgLnRleHQoJ1VzZSB0aGlzIElEJylcbiAgICAgICAgICAgIC5hcHBlbmRUbyhsaSlcbiAgICAgICAgICAgIC53cmFwKCc8ZGl2IGNsYXNzID1cIndyYXBwZXItYnRucyB0ZXh0LXJpZ2h0XCIvPicpO1xuICAgICAgICAgIGlmICh2ZW51ZS5sb2NhdGlvbiAmJiB2ZW51ZS5sb2NhdGlvbi5sYXRpdHVkZSAmJiB2ZW51ZS5sb2NhdGlvbi5sb25naXR1ZGUpIHtcbiAgICAgICAgICAgIC8vY29uc29sZS5sb2coJ3ZlbnVlLmxvY2F0aW9uIC0gJyAsIHZlbnVlLmxvY2F0aW9uKTtcbiAgICAgICAgICAgIHZhciBidXR0b25NYXAgPSAkKFwiPGJ1dHRvbiBzdHlsZT0nZmxvYXQ6IHJpZ2h0OycgZGF0YS1sYXRpdHVkZT1cIiArIHZlbnVlLmxvY2F0aW9uLmxhdGl0dWRlICsgXCIgZGF0YS1sb25naXR1ZGU9XCIgKyB2ZW51ZS5sb2NhdGlvbi5sb25naXR1ZGUgKyBcIi8+XCIpXG4gICAgICAgICAgICAgIC5hZGRDbGFzcygnanNfb3Blbi1tYXBfYnRuIGJ0biBidG4tdHJhbnNwYXJlbnQnKVxuICAgICAgICAgICAgICAudGV4dCgnU2hvdyBvbiBtYXAnKVxuICAgICAgICAgICAgICAuaW5zZXJ0QWZ0ZXIoYnV0dG9uU2V0SWQpXG4gICAgICAgICAgICAgIC8vLmFwcGVuZFRvKGJ1dHRvblNldElkKVxuICAgICAgICAgICAgICAud3JhcCgnPGRpdiBjbGFzcyA9XCJ3cmFwcGVyLWxvY2F0aW9uX2J0blwiLz4nKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIGFkZFRvRWwgPSB7bGk6IGxpLCBidXR0b25TZXRJZFdyYXBwZXI6IGJ1dHRvblNldElkLnBhcmVudCgpfTtcbiAgICAgICAgICBhZGRNc0J1dHRvbiggYWRkVG9FbCAsIGl0ZW0uaWQpO1xuICAgICAgICB9XG5cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGhhc1Njcm9sbEJhcihlbGVtZW50LCB3cmFwcGVyKSB7XG4gICAgICByZXR1cm4gZWxlbWVudC5nZXQoMCkuc2Nyb2xsSGVpZ2h0ID4gZWxlbWVudC5wYXJlbnQoKS5pbm5lckhlaWdodCgpO1xuICAgIH1cblxuICAgIHZhciByZW5kZXJSZXN1bHRzID0gZnVuY3Rpb24gKGRhdGEsIHVsRWxlbWVudCkge1xuICAgICAgdmFyIGl0ZW1zO1xuXG4gICAgICBmdW5jdGlvbiBzaG93TWVzc2FnZShlbGVtZW50LCBtZXNzYWdlLCAvKm9wdGlvbmFsKi9jbGVhckxpc3QpIHtcbiAgICAgICAgJGJ0bkdFVC5hdHRyKCdkaXNhYmxlZCcsIGZhbHNlKTtcblxuICAgICAgICBpZiAoY2xlYXJMaXN0KSAkKCdsaScsIGVsZW1lbnQpLnJlbW92ZSgpO1xuICAgICAgICBlbGVtZW50LmNzcyh7J292ZXJmbG93JzogJ2F1dG8nfSk7XG4gICAgICAgICQoJzxsaS8+JylcbiAgICAgICAgICAuYWRkQ2xhc3MoJ2xpc3QtZ3JvdXAtaXRlbSB0ZXh0LWNlbnRlcicpXG4gICAgICAgICAgLnRleHQobWVzc2FnZSlcbiAgICAgICAgICAuYXBwZW5kVG8odWxFbGVtZW50KTtcbiAgICAgIH1cblxuICAgICAgaWYgKHN0YXRlQ29uZi5sb2FkaW5nRmxhZyA9PT0gXCJGSU5BTF9QQUdFXCIpIHJldHVybiBmYWxzZTsgLy9leGl0IGlmIGhhcyByZWFjaGVkIGxhc3QgcGFnZVxuXG4gICAgICAvL3Nob3cgZmFpbCBtc2dcbiAgICAgIGlmIChkYXRhID09PSAnRkFJTCcpIHtcbiAgICAgICAgc2hvd01lc3NhZ2UoJHVsLCAnRmFpbHVyZSwgcG9zc2libGUga2V5IG5vdCBjb3JyZWN0LicsIHRydWUpO1xuICAgICAgICBtb2RhbENvbnRlbnQucmVtb3ZlQ2xhc3MoJ25hcnJvdycpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGlmIChzdGF0ZUNvbmYubG9hZGluZ0ZsYWcgPT09ICdTVE9QX0xPQUQnICYmIGRhdGEubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgIHN0YXRlQ29uZi5sb2FkaW5nRmxhZyA9IFwiRklOQUxfUEFHRVwiO1xuICAgICAgICBzaG93TWVzc2FnZSh1bEVsZW1lbnQsICdObyBtb3JlIHJlc3VsdHMuJywgZmFsc2UpO1xuICAgICAgICAkbGlGb290ZXIuaGlkZSgpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGlmIChkYXRhID09PSBudWxsIHx8ICFkYXRhLl9lbWJlZGRlZCkge1xuICAgICAgICBzaG93TWVzc2FnZSh1bEVsZW1lbnQsICdObyByZXN1bHRzIGZvdW5kLicsIHRydWUpO1xuICAgICAgICBtb2RhbENvbnRlbnQucmVtb3ZlQ2xhc3MoJ25hcnJvdycpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIC8vc3RhcnQgcmVuZGVyIGRhdGFcbiAgICAgIGlmIChzZWxlY3RvciA9PT0gJ2V2ZW50cycpIHtcbiAgICAgICAgaXRlbXMgPSAoZGF0YSAmJiBkYXRhLl9lbWJlZGRlZCAmJiBkYXRhLl9lbWJlZGRlZC5ldmVudHMpID8gZGF0YS5fZW1iZWRkZWQuZXZlbnRzIDogWycnXTtcbiAgICAgICAgcmVuZGVyTGlzdEV2ZW50cyhpdGVtcylcbiAgICAgIH0gZWxzZSBpZiAoc2VsZWN0b3IgPT09ICd2ZW51ZXMnKSB7XG4gICAgICAgIGl0ZW1zID0gKGRhdGEgJiYgZGF0YS5fZW1iZWRkZWQgJiYgZGF0YS5fZW1iZWRkZWQudmVudWVzKSA/IGRhdGEuX2VtYmVkZGVkLnZlbnVlcyA6IFsnJ107XG4gICAgICAgIHJlbmRlckxpc3RWZW51ZXMoaXRlbXMpO1xuICAgICAgfSBlbHNlIGlmIChzZWxlY3RvciA9PT0gJ2F0dHJhY3Rpb25zJykge1xuICAgICAgICBpdGVtcyA9IChkYXRhICYmIGRhdGEuX2VtYmVkZGVkICYmIGRhdGEuX2VtYmVkZGVkLmF0dHJhY3Rpb25zKSA/IGRhdGEuX2VtYmVkZGVkLmF0dHJhY3Rpb25zIDogWycnXTtcbiAgICAgICAgcmVuZGVyTGlzdEF0dHJhY3Rpb25zKGl0ZW1zKTtcbiAgICAgIH1cblxuICAgICAgLy9oaWRlIHNjcm9sbCBpZiByZWNpdmUgbGVzcyB0aGVuIDIgaXRlbXNcbiAgICAgIGlmIChoYXNTY3JvbGxCYXIoJHVsKSkge1xuICAgICAgICAkdWwucmVtb3ZlQ2xhc3MoJ25vLXNjcm9sbCcpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgJHVsLmFkZENsYXNzKCduby1zY3JvbGwnKTtcbiAgICAgIH1cblxuICAgICAgLy8gaGlkZS9zaG93IGhvcml6b250YWwgbGluZSBhbmQgYnV0dG9uIDxsb2FkIG1vcmU+XG4gICAgICBpZiAoZGF0YSAmJiBkYXRhLnBhZ2UgJiYgZGF0YS5wYWdlLnRvdGFsRWxlbWVudHMgPiAyMCkge1xuICAgICAgICAkaHIuc2hvdygpO1xuICAgICAgICAkbGlGb290ZXIuc2hvdygpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgJGhyLmhpZGUoKTtcbiAgICAgICAgJGxpRm9vdGVyLmhpZGUoKTtcbiAgICAgIH1cblxuICAgICAgLy8gaGlkZSBidXR0b24gPGxvYWQgbW9yZT4gaWYgbm90aGluZyBsZWZ0IHRvIGxvYWRcbiAgICAgIGlmIChzdGF0ZUNvbmYubG9hZGluZ0ZsYWcgPT09ICdTVE9QX0xPQUQnIHx8IChzdGF0ZUNvbmYucGFnZUluY3JlbWVudCArIDEpID09PSBkYXRhLnBhZ2UudG90YWxQYWdlcykge1xuICAgICAgICAkaHIuaGlkZSgpO1xuICAgICAgICAkbGlGb290ZXIuaGlkZSgpO1xuICAgICAgfVxuICAgICAgaWYgKGRhdGEucGFnZS50b3RhbEVsZW1lbnRzID4gMCB8fCBpdGVtcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICRoci5zaG93KCk7XG4gICAgICB9XG5cbiAgICAgIC8vPHNob3cgbWFwPiBidXR0b25cbiAgICAgICQoJy5qc19vcGVuLW1hcF9idG4nKS5vbignY2xpY2snLCBtYXBMaXN0ZW5lciApO1xuXG4gICAgICAkKCcuanNfbGF6eS1zZWxfYnRuJykub24oJ2NsaWNrJywgc2V0SWRMaXN0ZW5lcik7XG5cbiAgICAgICQoIFwiI2pzX2xzLW1vZGFsXCIgKS5vbiggXCJjbGlja1wiLCBcInVsIGxpIGJ1dHRvbi5qc19tcy1hZGQtbGlzdF9idG5cIiwgYWRkTXNCdXR0b25MaXN0ZW5lciApO1xuXG4gICAgICAvL3NldCBhdmFpbGlibGUgPEdldD4gYnV0dG9uIGFmdGVyIGxvYWQgaXMgZmluaXNoZWRcbiAgICAgICRidG5HRVQuYXR0cignZGlzYWJsZWQnLCBmYWxzZSk7XG5cbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gbWFwTGlzdGVuZXIoZSkge1xuICAgICAgdmFyIHNjcmVlbldpZHRoID0gTWF0aC5tYXgoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudFdpZHRoLCB3aW5kb3cuaW5uZXJXaWR0aCB8fCAwKTtcbiAgICAgIHZhciBpc01vYmlsZSA9IGZhbHNlOyAvL2luaXRpYXRlIGFzIGZhbHNlXG4gICAgICAvLyBkZXZpY2UgZGV0ZWN0aW9uXG4gICAgICBpZigvKGFuZHJvaWR8YmJcXGQrfG1lZWdvKS4rbW9iaWxlfGF2YW50Z298YmFkYVxcL3xibGFja2JlcnJ5fGJsYXplcnxjb21wYWx8ZWxhaW5lfGZlbm5lY3xoaXB0b3B8aWVtb2JpbGV8aXAoaG9uZXxvZCl8aXBhZHxpcmlzfGtpbmRsZXxBbmRyb2lkfFNpbGt8bGdlIHxtYWVtb3xtaWRwfG1tcHxuZXRmcm9udHxvcGVyYSBtKG9ifGluKWl8cGFsbSggb3MpP3xwaG9uZXxwKGl4aXxyZSlcXC98cGx1Y2tlcnxwb2NrZXR8cHNwfHNlcmllcyg0fDYpMHxzeW1iaWFufHRyZW98dXBcXC4oYnJvd3NlcnxsaW5rKXx2b2RhZm9uZXx3YXB8d2luZG93cyAoY2V8cGhvbmUpfHhkYXx4aWluby9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudClcbiAgICAgICAgfHwgLzEyMDd8NjMxMHw2NTkwfDNnc298NHRocHw1MFsxLTZdaXw3NzBzfDgwMnN8YSB3YXxhYmFjfGFjKGVyfG9vfHNcXC0pfGFpKGtvfHJuKXxhbChhdnxjYXxjbyl8YW1vaXxhbihleHxueXx5dyl8YXB0dXxhcihjaHxnbyl8YXModGV8dXMpfGF0dHd8YXUoZGl8XFwtbXxyIHxzICl8YXZhbnxiZShja3xsbHxucSl8YmkobGJ8cmQpfGJsKGFjfGF6KXxicihlfHYpd3xidW1ifGJ3XFwtKG58dSl8YzU1XFwvfGNhcGl8Y2N3YXxjZG1cXC18Y2VsbHxjaHRtfGNsZGN8Y21kXFwtfGNvKG1wfG5kKXxjcmF3fGRhKGl0fGxsfG5nKXxkYnRlfGRjXFwtc3xkZXZpfGRpY2F8ZG1vYnxkbyhjfHApb3xkcygxMnxcXC1kKXxlbCg0OXxhaSl8ZW0obDJ8dWwpfGVyKGljfGswKXxlc2w4fGV6KFs0LTddMHxvc3x3YXx6ZSl8ZmV0Y3xmbHkoXFwtfF8pfGcxIHV8ZzU2MHxnZW5lfGdmXFwtNXxnXFwtbW98Z28oXFwud3xvZCl8Z3IoYWR8dW4pfGhhaWV8aGNpdHxoZFxcLShtfHB8dCl8aGVpXFwtfGhpKHB0fHRhKXxocCggaXxpcCl8aHNcXC1jfGh0KGMoXFwtfCB8X3xhfGd8cHxzfHQpfHRwKXxodShhd3x0Yyl8aVxcLSgyMHxnb3xtYSl8aTIzMHxpYWMoIHxcXC18XFwvKXxpYnJvfGlkZWF8aWcwMXxpa29tfGltMWt8aW5ub3xpcGFxfGlyaXN8amEodHx2KWF8amJyb3xqZW11fGppZ3N8a2RkaXxrZWppfGtndCggfFxcLyl8a2xvbnxrcHQgfGt3Y1xcLXxreW8oY3xrKXxsZShub3x4aSl8bGcoIGd8XFwvKGt8bHx1KXw1MHw1NHxcXC1bYS13XSl8bGlid3xseW54fG0xXFwtd3xtM2dhfG01MFxcL3xtYSh0ZXx1aXx4byl8bWMoMDF8MjF8Y2EpfG1cXC1jcnxtZShyY3xyaSl8bWkobzh8b2F8dHMpfG1tZWZ8bW8oMDF8MDJ8Yml8ZGV8ZG98dChcXC18IHxvfHYpfHp6KXxtdCg1MHxwMXx2ICl8bXdicHxteXdhfG4xMFswLTJdfG4yMFsyLTNdfG4zMCgwfDIpfG41MCgwfDJ8NSl8bjcoMCgwfDEpfDEwKXxuZSgoY3xtKVxcLXxvbnx0Znx3Znx3Z3x3dCl8bm9rKDZ8aSl8bnpwaHxvMmltfG9wKHRpfHd2KXxvcmFufG93ZzF8cDgwMHxwYW4oYXxkfHQpfHBkeGd8cGcoMTN8XFwtKFsxLThdfGMpKXxwaGlsfHBpcmV8cGwoYXl8dWMpfHBuXFwtMnxwbyhja3xydHxzZSl8cHJveHxwc2lvfHB0XFwtZ3xxYVxcLWF8cWMoMDd8MTJ8MjF8MzJ8NjB8XFwtWzItN118aVxcLSl8cXRla3xyMzgwfHI2MDB8cmFrc3xyaW05fHJvKHZlfHpvKXxzNTVcXC98c2EoZ2V8bWF8bW18bXN8bnl8dmEpfHNjKDAxfGhcXC18b298cFxcLSl8c2RrXFwvfHNlKGMoXFwtfDB8MSl8NDd8bWN8bmR8cmkpfHNnaFxcLXxzaGFyfHNpZShcXC18bSl8c2tcXC0wfHNsKDQ1fGlkKXxzbShhbHxhcnxiM3xpdHx0NSl8c28oZnR8bnkpfHNwKDAxfGhcXC18dlxcLXx2ICl8c3koMDF8bWIpfHQyKDE4fDUwKXx0NigwMHwxMHwxOCl8dGEoZ3R8bGspfHRjbFxcLXx0ZGdcXC18dGVsKGl8bSl8dGltXFwtfHRcXC1tb3x0byhwbHxzaCl8dHMoNzB8bVxcLXxtM3xtNSl8dHhcXC05fHVwKFxcLmJ8ZzF8c2kpfHV0c3R8djQwMHx2NzUwfHZlcml8dmkocmd8dGUpfHZrKDQwfDVbMC0zXXxcXC12KXx2bTQwfHZvZGF8dnVsY3x2eCg1Mnw1M3w2MHw2MXw3MHw4MHw4MXw4M3w4NXw5OCl8dzNjKFxcLXwgKXx3ZWJjfHdoaXR8d2koZyB8bmN8bncpfHdtbGJ8d29udXx4NzAwfHlhc1xcLXx5b3VyfHpldG98enRlXFwtL2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50LnN1YnN0cigwLDQpKSkgaXNNb2JpbGUgPSB0cnVlO1xuXG4gICAgICBpZighaXNNb2JpbGUgfHwgc2NyZWVuV2lkdGggPj0gNzY4KSB7XG4gICAgICAgIG1hcFBvcFVwTGlzdGVuZXIoZSk7XG4gICAgICAgIG1vZGFsQ29udGVudC5hZGRDbGFzcygnbmFycm93Jyk7XG4gICAgICAgIGJ0bkNsb3NlTWFwLnNob3coKTtcbiAgICAgIH1lbHNlIGlmKGlzTW9iaWxlKXtcbiAgICAgICAgdmFyIGxhdCA9ICQoZS50YXJnZXQpLmF0dHIoJ2RhdGEtbGF0aXR1ZGUnKSAhPSBcInVuZGVmaW5lZFwiID8gcGFyc2VGbG9hdCgkKGUudGFyZ2V0KS5hdHRyKCdkYXRhLWxhdGl0dWRlJykpIDogbnVsbCxcbiAgICAgICAgICBsbmcgPSAkKGUudGFyZ2V0KS5hdHRyKCdkYXRhLWxvbmdpdHVkZScpICE9IFwidW5kZWZpbmVkXCIgPyBwYXJzZUZsb2F0KCQoZS50YXJnZXQpLmF0dHIoJ2RhdGEtbG9uZ2l0dWRlJykpIDogbnVsbDtcbiAgICAgICAgaWYgKGxhdCAmJiBsbmcgKSB7XG4gICAgICAgICAgbG9jYXRpb24uaHJlZj0nZ2VvOicrbG5nKycsJytsYXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbG9jYXRpb24uaHJlZj0nZ2VvOjAsMCc7XG4gICAgICAgIH1cblxuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFkZE1zQnV0dG9uKGVsLCBkYXRhKXtcblx0XHRcdGlmKG9wdGlvbnMuaGlkZU11bHRpU2VsZWN0b3IpIHJldHVybiBmYWxzZTtcblxuXHRcdFx0Ly9hZGQgYnV0dG9uIDxBREQgdG8gbGlzdD5cblx0XHRcdHZhciBidXR0b25BZGRJZFRvTGlzdCA9ICQoXCI8YnV0dG9uIGRhdGEtaWQ9XCIgKyBkYXRhICsgXCIvPlwiKVxuXHRcdFx0XHQuYWRkQ2xhc3MoJ2pzX21zLWFkZC1saXN0X2J0biBwdWxsLXJpZ2h0IGJ0biBidG4gYnRuLXRyYW5zcGFyZW50Jylcblx0XHRcdFx0LnRleHQoJ0FERCB0byBsaXN0Jylcblx0XHRcdFx0LmFwcGVuZFRvKGVsLmxpLmZpbmQoZWwuYnV0dG9uU2V0SWRXcmFwcGVyKSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2V0SWRMaXN0ZW5lcihlKXtcbiAgICAgIHZhciBzZWxlY3RlZElEID0gZS50YXJnZXQuZ2V0QXR0cmlidXRlKCdkYXRhLWV2ZW50Jyk7XG4gICAgICAkaW5wdXQudmFsKHNlbGVjdGVkSUQpXG4gICAgICAgIC5hdHRyKCd2YWx1ZScsIHNlbGVjdGVkSUQpXG4gICAgICAgIC50cmlnZ2VyKCdjaGFuZ2UnKTsgIC8vdXBkYXRlIHdpZGdldDpcbiAgICAgIHN0YXRlQ29uZi5zZXRTaW5nbGVWYWwgPSB0cnVlO1xuXG4gICAgICAvL2NsZWFyIHRhZ3MgYm94IG9mIGN1cnJlbnQgc2VsZWN0b3IgKHRoYXQgZXF1YWwgJ3NlbGVjdGVkSUQnIHZhbClcbiAgICAgIGNvbmZpZy5mb3JFYWNoKGZ1bmN0aW9uIChlbCkge1xuICAgICAgICB0YWdzSWRzW3NlbGVjdGVkSURdID0gW107XG4gICAgICB9KTtcbiAgICAgIC8vIENsb3NlIGRpYWxvZ1xuICAgICAgJG1vZGFsLm1vZGFsKCdoaWRlJyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2V0SWRzTGlzdGVuZXIoZSl7XG4gICAgICBpZiAoJGJ0bkdFVC5hdHRyKCdkYXRhLXNlbGVjdG9yJykgIT09ICRpY29uQnV0dG9uLmF0dHIoJ2RhdGEtc2VsZWN0b3InKSkgcmV0dXJuIGZhbHNlO1xuICAgICAgdmFyIHNlbGVjdGVkSUQgPSB0YWdzSWRzW3NlbGVjdG9yXTtcblxuXHRcdFx0Ly8gc2V0IGlzYWJsZT10cnVlIHRvIGFsbCBpdGVtcyBpbiB0YWdzLWxpc3Rcblx0XHRcdCQoJ2xpJywkbXNMaXN0KVxuXHRcdFx0XHQuZWFjaCggIGZ1bmN0aW9uKCkgeyAkKHRoaXMpLmF0dHIoJ2RhdGEtaXNhYmxlJyx0cnVlKX0gICk7XG5cbiAgICAgICRpbnB1dC52YWwoc2VsZWN0ZWRJRClcbiAgICAgIFx0LmF0dHIoJ3ZhbHVlJywgc2VsZWN0ZWRJRClcbiAgICAgIFx0LnRyaWdnZXIoJ2NoYW5nZScpOyAgLy91cGRhdGUgd2lkZ2V0OlxuXG4gICAgICAvLyBDbG9zZSBkaWFsb2dcbiAgICAgICRtb2RhbC5tb2RhbCgnaGlkZScpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNsZWFyQnlBcnJWYWwoc2VsZWN0ZWRJRCwgaW5kVG9SZW1vdmUpIHtcbiAgICAgIGZ1bmN0aW9uIG1hcEFueShhcnJheSkge1xuICAgICAgICBhcnJheS5tYXAoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgICBzZWxlY3RlZElELnNwbGljZShzZWxlY3RlZElELmluZGV4T2YoaXRlbSksIDEpO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgaWYoc2VsZWN0ZWRJRC5sZW5ndGggPj0gaW5kVG9SZW1vdmUubGVuZ3RoKSB7XG4gICAgICAgIG1hcEFueShpbmRUb1JlbW92ZSk7XG4gICAgICB9ZWxzZXtcbiAgICAgICAgbWFwQW55KHNlbGVjdGVkSUQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRlbElkTGlzdGVuZXIoZXZlbnQpe1xuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIHZhciBtZSA9ICQoIHRoaXMgKSxcbiAgICAgICAgdGFnSUQgPSBtZS5wYXJlbnRzKCdsaScpLmRhdGEoJ3NlbGVjdG9yLScrc2VsZWN0b3IpLFxuICAgICAgICBzZWxlY3RlZElEID0gdGFnc0lkc1tzZWxlY3Rvcl07XG4gICAgICB2YXIgaW5kVG9SZW1vdmUgPVtdO1xuXG4gICAgICBtZS5wYXJlbnRzKCdsaScpLnJlbW92ZSgpO1xuICAgICAgaW5kVG9SZW1vdmUucHVzaCh0YWdJRCk7XG4gICAgICBjbGVhckJ5QXJyVmFsKHNlbGVjdGVkSUQsIGluZFRvUmVtb3ZlKTtcblxuICAgICAgLy91cGRhdGUgaW5wdXQgdmFsdWVzXG4gICAgICAkaW5wdXQudmFsKHNlbGVjdGVkSUQpXG4gICAgICAgIC5hdHRyKCd2YWx1ZScsIHNlbGVjdGVkSUQpXG4gICAgICAgIC50cmlnZ2VyKCdjaGFuZ2UnKTsgIC8vdXBkYXRlIHdpZGdldDpcblxuICAgICAgdG9nZ2xlTXNTZWxlY3Rpb25Cb3goKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhZGRNc0J1dHRvbkxpc3RlbmVyKGV2ZW50KXtcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgIGZ1bmN0aW9uIGlzVW5pcXVlKGxpc3QpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IFtdLFxuICAgICAgICAgIHVuaXF1ZSA9IGZhbHNlO1xuXG4gICAgICAgICQuZWFjaChsaXN0LCBmdW5jdGlvbihpLCBlKSB7XG4gICAgICAgICAgaWYgKCQuaW5BcnJheShlLCByZXN1bHQpID09IC0xKXtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKGUpO1xuICAgICAgICAgICAgdW5pcXVlID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB1bmlxdWUgPSBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdW5pcXVlO1xuICAgICAgfVxuXG4gICAgICB2YXIgbWUgPSAkKCB0aGlzICksXG4gICAgICAgICAgdGl0bGUgPSBtZS5wYXJlbnRzKCdsaScpLmZpbmQoJy5saXN0LWdyb3VwLWl0ZW0taGVhZGluZycsJy5ldmVudC10ZXh0LXdyYXBwZXInKS50ZXh0KCksXG4gICAgICAgICAgdW5pcXVlVXBjb21pbmcsXG4gICAgICAgICAgY3VycmVudExpc3QgPSB0YWdzSWRzW3NlbGVjdG9yXTtcblxuICAgICAgY3VycmVudExpc3QucHVzaChtZS5kYXRhKCdpZCcpKTtcbiAgICAgIHVuaXF1ZVVwY29taW5nID0gaXNVbmlxdWUoY3VycmVudExpc3QpOyAvLyBHZXQgbGlzdCBvZiB1cGNvbWluZyB0YWdzXG5cbiAgICAgIGlmKCB1bmlxdWVVcGNvbWluZyApe1xuICAgICAgICB2YXIgaXRlbSA9ICQoJzxsaS8+JylcbiAgICAgICAgICAuYWRkQ2xhc3MoJ21zLWVsZW0tc2VsZWN0aW9uJylcbiAgICAgICAgICAudGV4dCh0aXRsZSlcbiAgICAgICAgICAuYXR0cignZGF0YS1zZWxlY3Rvci0nK3NlbGVjdG9yLCBtZS5kYXRhKCdpZCcpKVxuICAgICAgICAgIC5hdHRyKCdkYXRhLWlzYWJsZScsZmFsc2UpXG4gICAgICAgICAgLmFwcGVuZFRvKCRtc0xpc3QpO1xuICAgICAgICAkKCc8c3Bhbi8+JylcbiAgICAgICAgICAuYXBwZW5kVG8oaXRlbSlcbiAgICAgICAgICAub24oJ2NsaWNrJywgaXRlbSwgZGVsSWRMaXN0ZW5lcik7XG4gICAgICB9ZWxzZSB7XG4gICAgICAgIGN1cnJlbnRMaXN0LnNwbGljZShjdXJyZW50TGlzdC5sZW5ndGgtMSAsMSk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIG1lLmFkZENsYXNzKCdjaGVja2VkJyk7XG4gICAgICB0b2dnbGVNc1NlbGVjdGlvbkJveCgpO1xuICAgIH1cblxuICAgIC8vIEVWRU5UU1xuICAgICRidG5HRVQub24oJ2NsaWNrJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgIGlmICgkYnRuR0VULmF0dHIoJ2RhdGEtc2VsZWN0b3InKSAhPT0gJGljb25CdXR0b24uYXR0cignZGF0YS1zZWxlY3RvcicpKSByZXR1cm4gZmFsc2U7IC8vc3RvcCByZXF1ZXN0XG5cbiAgICAgIG1vZGFsQ29udGVudC5yZW1vdmVDbGFzcygnbmFycm93Jyk7XG4gICAgICB2YXIgZm9ybSA9ICRmb3JtLmdldCgwKTtcbiAgICAgIGlmICghJGJ0bkdFVC5pcygnOmRpc2FibGVkJykpIHtcbiAgICAgICAgaWYgKGZvcm0uY2hlY2tWYWxpZGl0eSgpKSB7XG4gICAgICAgICAgJGJ0bkdFVC5hdHRyKCdkaXNhYmxlZCcsIHRydWUpO1xuICAgICAgICAgIHN0YXRlQ29uZi5wYWdlSW5jcmVtZW50ID0gMDtcbiAgICAgICAgICBzdGF0ZUNvbmYubG9hZGluZ0ZsYWcgPSAnS0VFUF9MT0FEJztcbiAgICAgICAgICBsb2FkaW5nKCdvbicpOyAvL3Nob3cgbG9hZGluZy1zcGlubmVyXG4gICAgICAgICAgcmVzZXRGb3JtKCk7IC8vY2xlYXJcbiAgICAgICAgICBzdWJtaXRGb3JtKHN0YXRlQ29uZi5wYWdlSW5jcmVtZW50LCAgdHJ1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gSGlnaGxpZ2h0IGVycm9yc1xuICAgICAgICAgIGlmIChmb3JtLnJlcG9ydFZhbGlkaXR5KSBmb3JtLnJlcG9ydFZhbGlkaXR5KCk7XG4gICAgICAgICAgJGZvcm0uYWRkQ2xhc3MoY3NzVmFsaWRhdGlvbkNsYXNzKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuXG4gICAgJG1zQnRuVXNlLm9uKCdjbGljaycsIHNldElkc0xpc3RlbmVyKTtcblxuICAgIC8vQ2xvc2UgTWFwIGJ1dHRvblxuICAgIGJ0bkNsb3NlTWFwLm9uKCdjbGljaycsIGNsb3NlTWFwTGlzdGVuZXIpO1xuXG4gICAgJCgnI2pzX2xzLW1vcmVfYnRuJywgJGxpRm9vdGVyKS5vbignY2xpY2snLCBmdW5jdGlvbiAoZWxtKSB7XG4gICAgICBpZiAoJGJ0bkdFVC5hdHRyKCdkYXRhLXNlbGVjdG9yJykgIT09ICRpY29uQnV0dG9uLmF0dHIoJ2RhdGEtc2VsZWN0b3InKSkgcmV0dXJuIGZhbHNlO1xuICAgICAgLy8gZXZlbnRVcmwgPSAnaHR0cHM6Ly9hcHAudGlja2V0bWFzdGVyLmNvbS9kaXNjb3ZlcnkvdjIvJyArICRpY29uQnV0dG9uLmF0dHIoJ2RhdGEtc2VsZWN0b3InKSArICcuanNvbic7XG5cbiAgICAgIHN0YXRlQ29uZi5wYWdlSW5jcmVtZW50Kys7XG4gICAgICAkYnRuR0VULmF0dHIoJ2Rpc2FibGVkJywgdHJ1ZSk7XG4gICAgICBsb2FkaW5nKCdvbicpO1xuICAgICAgc3VibWl0Rm9ybShzdGF0ZUNvbmYucGFnZUluY3JlbWVudCk7XG5cbiAgICAgIC8vQ2xlYXIgTGlzdGVuZXIsIHByZXZlbnQgbWVtb3J5IGxlYWtcbiAgICAgICQoIFwiI2pzX2xzLW1vZGFsXCIgKS5vZmYoIFwiY2xpY2tcIiwgXCJ1bCBsaSBidXR0b24uanNfbXMtYWRkLWxpc3RfYnRuXCIsIGFkZE1zQnV0dG9uTGlzdGVuZXIgKTtcbiAgICB9KTtcblxuICAgIC8vbXVsdGlwbGUgc2VsZWN0b3IgZXZlbnRzXG5cbiAgICAkZm9ybS5vbihcImtleXVwXCIsIGZ1bmN0aW9uIChlKSB7XG4gICAgICB2YXIgaW5wdXQgPSAkKGUudGFyZ2V0KTtcbiAgICAgIGlmIChlLnRhcmdldC50YWdOYW1lID09PSBcIklOUFVUXCIpe1xuICAgICAgICBpZiAoZS5rZXlDb2RlID09IDEzKXtcbiAgICAgICAgICBpbnB1dC5ibHVyKCk7XG5cbiAgICAgICAgICBtb2RhbENvbnRlbnQucmVtb3ZlQ2xhc3MoJ25hcnJvdycpO1xuICAgICAgICAgIGlmICgkYnRuR0VULmF0dHIoJ2RhdGEtc2VsZWN0b3InKSAhPT0gJGljb25CdXR0b24uYXR0cignZGF0YS1zZWxlY3RvcicpKSByZXR1cm4gZmFsc2U7XG5cbiAgICAgICAgICBpZiAoJGZvcm0uZ2V0KDApLmNoZWNrVmFsaWRpdHkoKSkge1xuICAgICAgICAgICAgc3RhdGVDb25mLnBhZ2VJbmNyZW1lbnQgPSAwO1xuICAgICAgICAgICAgc3RhdGVDb25mLmxvYWRpbmdGbGFnID0gJ0tFRVBfTE9BRCc7XG4gICAgICAgICAgICBsb2FkaW5nKCdvbicpO1xuICAgICAgICAgICAgcmVzZXRGb3JtKCk7XG4gICAgICAgICAgICBzdWJtaXRGb3JtKHN0YXRlQ29uZi5wYWdlSW5jcmVtZW50KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9KTtcblxuICAgIC8vIE1vYmlsZSBkZXZpY2VzLiBGb3JjZSAnY2hhbmdlJyBieSAnR28nIHByZXNzXG4gICAgJGZvcm0ub24oXCJzdWJtaXRcIiwgZnVuY3Rpb24gKGUpIHtcbiAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICB9KTtcblxuICAgICRtb2RhbFxuICAgICAgLm9uKCdzaG93bi5icy5tb2RhbCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy9zYXZlIGRlZmF1bHQgdmFsdWUgdG8gdmFyaWFibGUgZm9yICdldmVudHMnIHNlbGVjdG9yIG9ubHlcbiAgICAgICAgaWYodHlwZW9mICRpbnB1dC52YWwoKSAhPT0gJ3VuZGVmaW5lZCcgJiYgJGljb25CdXR0b24uYXR0cignZGF0YS1zZWxlY3RvcicpID09PSAnZXZlbnRzJyApXG4gICAgICAgICAgaW5pdGlhbFZhbFsnZXZlbnRzJ10gPSAkaW5wdXQudmFsKCk7XG4gICAgICB9KVxuICAgICAgLm9uKCdoaWRkZW4uYnMubW9kYWwnLCBmdW5jdGlvbiAoZSkge1xuICAgICAgcmVzZXRGb3JtKCk7XG4gICAgICBjbG9zZU1hcExpc3RlbmVyKCk7XG5cblx0XHRcdHZhciBpbmRUb1JlbW92ZSA9W10sXG4gICAgICAgIHNlbGVjdG9yQnRuID0gJGJ0bkdFVC5hdHRyKCdkYXRhLXNlbGVjdG9yJyksXG4gICAgICAgIHRhZ3NBcnIgPSB0YWdzSWRzW3NlbGVjdG9yQnRuXTtcblxuICAgICAgJCggJ2xpJyAsICRtc0xpc3QgKS5lYWNoKCBmdW5jdGlvbihpKSB7XG5cdFx0XHRcdGlmICggJCh0aGlzKS5kYXRhKCdpc2FibGUnKSA9PT0gZmFsc2UgKXtcblx0XHRcdFx0XHRpbmRUb1JlbW92ZS5wdXNoKCAkKHRoaXMpLmRhdGEoJ3NlbGVjdG9yLScgKyBzZWxlY3RvckJ0bikgKTtcblx0XHRcdFx0XHQkKHRoaXMpLnJlbW92ZSgpO1xuXHRcdFx0XHR9XG4gICAgICB9KTtcblxuICAgICAgY2xlYXJCeUFyclZhbCh0YWdzQXJyLCBpbmRUb1JlbW92ZSk7XG5cbiAgICAgIC8vY2xlYXIgdGFncyBpZiBzZXQgU2luZ2xlIElEXG4gICAgICBpZihzZWxlY3RvciA9PT0gc2VsZWN0b3JCdG4gJiYgIXN0YXRlQ29uZi5zZXRTaW5nbGVWYWwpIHtcbiAgICAgICAgLy8kaW5wdXQudmFsKHRhZ3NBcnIpLmF0dHIoJ3ZhbHVlJywgdGFnc0FycikudHJpZ2dlcignY2hhbmdlJyk7ICAvL3VwZGF0ZSB3aWRnZXQ6XG4gICAgICAgIHN0YXRlQ29uZi5zZXRTaW5nbGVWYWwgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGtleXdvcmQudmFsKCcnKTsvL2NsZWFyIHNlYXJjaCBpbnB1dFxuICAgIH0pO1xuXG4gICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICBpbml0KCQodGhpcykpO1xuXG4gICAgICBmdW5jdGlvbiBpbml0KGlucHV0KSB7XG4gICAgICAgIGlucHV0LndyYXAoJzxkaXYgY2xhc3M9XCJsYXp5LXNlbGVjdG9yLXdyYXBwZXJcIj48L2Rpdj4nKTtcbiAgICAgICAgaW5wdXQuYWZ0ZXIoJGljb25CdXR0b24pO1xuICAgICAgICAkaWNvbkJ1dHRvbi5hdHRyKCdkYXRhLXNlbGVjdG9yJywgc2VsZWN0b3IpO1xuXG4gICAgICAgICQoJyNnZXQtZXZlbnQtYnktSWQtJyArIG9wdGlvbnMuc2VsZWN0b3IgKyAnJykub24oJ2NsaWNrJywgY2hhbmdlTW9kYWxUZXh0TGlzdGVuZXIpO1xuICAgICAgICB0YWdzSWRzW3NlbGVjdG9yXSA9IFtdO1xuICAgICAgfVxuICAgIH0pO1xuXG4gIH07XG5cbn0pKGpRdWVyeSk7XG5cbi8qKlxuICogYWRkIGxhenkgc2VsZWN0b3IgdG8gd2lkZ2V0c1xuICovXG4kKGRvY3VtZW50KS5vbigncmVhZHknLCBmdW5jdGlvbiAoKSB7XG4gICQoJy5qc19sYXp5LXNlbGVjdG9yJykubGF6eVNlbGVjdG9yKHtzZWxlY3RvcjonJywgaGlkZU11bHRpU2VsZWN0b3I6dHJ1ZX0pO1xuICAkKCcuanNfbGF6eS1zZWxlY3Rvci1hdHRyYWN0aW9ucycpLmxhenlTZWxlY3Rvcih7c2VsZWN0b3I6ICdhdHRyYWN0aW9ucyd9KTtcbiAgJCgnLmpzX2xhenktc2VsZWN0b3ItdmVudWVzJykubGF6eVNlbGVjdG9yKHtzZWxlY3RvcjondmVudWVzJ30pO1xufSk7XG5cblxuLyoqXG4gKiBhZGQgbGF6eSBzZWxlY3RvciB0byBhcGktZXhwbG9yZXIgdjEgKG1hZGUgYnkgVi5NZW5zaHV0aW4pXG4gKi9cbiQoZG9jdW1lbnQpLm9uKCBcImZpbmlzaEluaXRcIiwgZnVuY3Rpb24oIGV2ZW50LCBmbGFnICkge1xuICAkKCcjdmVudWVJZCcpLmxhenlTZWxlY3Rvcih7c2VsZWN0b3I6J3ZlbnVlcyd9KTtcbiAgJCgnI2F0dHJhY3Rpb25JZCcpLmxhenlTZWxlY3Rvcih7c2VsZWN0b3I6J2F0dHJhY3Rpb25zJ30pO1xufSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zY3JpcHRzL2NvbXBvbmVudHMvbGF6eS1zZWxlY3Rvci5qcyIsIi8qKlxyXG4gKiByZXF1aXJlZCB0byBpbmNsdWRlOiBjbGFzc2lmaWNhdGlvbi1zZWxlY3Rvci1tb2RhbC5odG1sXHJcbiAqXHJcbiAqIGF2YWlsaWFibGUgb3B0aW9uIDpcclxuICoge1xyXG4gKiAgICBzZWxlY3RvcjogJ2NsYXNzaWZpY2F0aW9ucydcclxuICogICAgdXNlOiAnbmFtZScsICdpZCdcclxuICogfVxyXG4gKiBcclxuICogJCgnLmpzX2xhenktc2VsZWN0b3ItYXR0cmFjdGlvbnMnKS5jbGFzc2lmaWNhdGlvblNlbGVjdG9yKHtzZWxlY3RvcjonY2xhc3NpZmljYXRpb25zJywgdXNlOiduYW1lJ30pO1xyXG4gKiAkKCcuanNfbGF6eS1zZWxlY3Rvci12ZW51ZXMnKS5jbGFzc2lmaWNhdGlvblNlbGVjdG9yKHtzZWxlY3RvcjonY2xhc3NpZmljYXRpb25zJywgdXNlOidpZCd9KTtcclxuICovXHJcblxyXG4oZnVuY3Rpb24gKCQpIHtcclxuXHJcbiAgJC5mbi5jbGFzc2lmaWNhdGlvblNlbGVjdG9yID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcclxuICAgIHZhciBkZWZhdWx0cyA9IHt9LFxyXG4gICAgICAgIHNldHRpbmdzID0gJC5leHRlbmQoe30sICQuZm4ubGF6eVNlbGVjdG9yLmRlZmF1bHRzLCBvcHRpb25zKSxcclxuICAgICAgICAkaWNvbkJ1dHRvbiA9ICQoJzxhIGNsYXNzPVwiaWNvblwiIGlkPVwiZ2V0LScrb3B0aW9ucy5zZWxlY3RvcisnLScrb3B0aW9ucy51c2UrJ1wiIGRhdGEtdG9nZ2xlPVwibW9kYWxcIiBkYXRhLXRhcmdldD1cIiNqc19scy1tb2RhbC1jbGFzc2lmaWNhdGlvblwiIC8+Jyk7XHJcblxyXG4gICAgdmFyICRpbnB1dCA9ICQodGhpcyksXHJcblx0XHRcdCRtb2RhbCA9ICQoJyNqc19scy1tb2RhbC1jbGFzc2lmaWNhdGlvbicpLFxyXG4gICAgICAkZm9ybSA9ICQoJyNqc19sYXp5LXNlbF9mb3JtJywgJG1vZGFsKSxcclxuICAgICAgJGJ0bkdFVCA9ICRtb2RhbC5maW5kKCcjanNfY2xhc3NpZmljYXRpb24tbW9kYWxfYnRuJyksXHJcbiAgICAgIGNzc1ZhbGlkYXRpb25DbGFzcyA9ICdnZXQtZXZlbnRJZF9mb3JtLXZhbGlkYXRpb24nLFxyXG4gICAgICBtb2RhbENvbnRlbnQgPSAkKCcubW9kYWwtY29udGVudCcsICRtb2RhbCksXHJcbiAgICAgICRqc3RyZWUgPSAkKCcjY2xhc3NpZmljYXRpb24tanN0cmVlJylcclxuICAgICAgO1xyXG4gICAgdmFyIGtleXdvcmQgPSAkZm9ybS5maW5kKCcja2V5d29yZCcpLFxyXG4gICAgICBhcGlrZXkgPSBhcGlLZXlTZXJ2aWNlLmNoZWNrQXBpS2V5Q29va2llKCd0ay1hcGkta2V5JykgfHwgJCgnI3ctdG0tYXBpLWtleScpLnZhbCgpIHx8IGFwaUtleVNlcnZpY2UuZ2V0QXBpRXhwbG9yZUtleSgpLFxyXG4gICAgICBzZWxlY3RvciA9IG9wdGlvbnMuc2VsZWN0b3IsXHJcbiAgICAgIHVzZSA9IG9wdGlvbnMudXNlLFxyXG4gICAgICBldmVudFVybCA9ICdodHRwczovL2FwcC50aWNrZXRtYXN0ZXIuY29tL2Rpc2NvdmVyeS92Mi8nICsgc2VsZWN0b3IgKyAnLmpzb24nO1xyXG5cclxuICAgIGZ1bmN0aW9uICBpbml0VHJlZShqc29uKSB7XHJcbiAgICAgIGpzb24gPSBzZXRDaGlsZHJlbihqc29uWydfZW1iZWRkZWQnXVsnY2xhc3NpZmljYXRpb25zJ10pO1xyXG5cclxuICAgICAgJGpzdHJlZS5qc3RyZWUoe1xyXG4gICAgICAgIFwiY29yZVwiIDoge1xyXG4gICAgICAgICAgJ2NoZWNrX2NhbGxiYWNrJzogdHJ1ZSxcclxuICAgICAgICAgICdkYXRhJyA6IGpzb25cclxuICAgICAgICB9ICxcclxuICAgICAgICBcInBsdWdpbnNcIiA6IFsgXCJzZWFyY2hcIiBdICxcclxuICAgICAgICBcInNlYXJjaFwiOiB7XHJcbiAgICAgICAgICBcInNob3dfb25seV9tYXRjaGVzXCIgOiB0cnVlLFxyXG4gICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgKiBJbmRpY2F0ZXMgaWYgYWxsIG5vZGVzIG9wZW5lZCB0byByZXZlYWwgdGhlIHNlYXJjaCByZXN1bHQsIHNob3VsZCBiZSBjbG9zZWQgd2hlbiB0aGUgc2VhcmNoIGlzIGNsZWFyZWQgb3IgYSBuZXcgc2VhcmNoIGlzIHBlcmZvcm1lZC4gRGVmYXVsdCBpcyBgdHJ1ZWAuXHJcbiAgICAgICAgICAgKiBAbmFtZSAkLmpzdHJlZS5kZWZhdWx0cy5zZWFyY2guY2xvc2Vfb3BlbmVkX29uY2xlYXJcclxuICAgICAgICAgICAqIEBwbHVnaW4gc2VhcmNoXHJcbiAgICAgICAgICAgKi9cclxuICAgICAgICAgIFwiY2FzZV9zZW5zaXRpdmVcIiA6IGZhbHNlXHJcbiAgICAgICAgfVxyXG4gICAgICB9KS5vbignc2VsZWN0X25vZGUuanN0cmVlJywgZnVuY3Rpb24gKGUsIGRhdGEpIHtcclxuICAgICAgICBkYXRhLmluc3RhbmNlLnRvZ2dsZV9ub2RlKGRhdGEubm9kZSk7IC8vc2V0IG9wZW4gb24gb25lIGNsaWNrXHJcbiAgICAgICAgdmFyIGksIGosIHIgPSBbXTtcclxuICAgICAgICBmb3IgKGkgPSAwLCBqID0gZGF0YS5zZWxlY3RlZC5sZW5ndGg7IGkgPCBqOyBpKyspIHtcclxuICAgICAgICAgIHIucHVzaChcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgIHRleHQ6IGRhdGEuaW5zdGFuY2UuZ2V0X25vZGUoZGF0YS5zZWxlY3RlZFtpXSkudGV4dCxcclxuICAgICAgICAgICAgICBpZDogZGF0YS5pbnN0YW5jZS5nZXRfbm9kZShkYXRhLnNlbGVjdGVkW2ldKS5pZFxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICApO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgJCgnYnV0dG9uJywkanN0cmVlKS5vZmYoJ2NsaWNrJywgc2V0SWRMaXN0ZW5lcikucmVtb3ZlKCk7XHJcblxyXG4gICAgICAgICQoJzxidXR0b24vPicpXHJcbiAgICAgICAgICAuYWRkQ2xhc3MoJ2J0biBidG4tc3VibWl0IGJ0bi1zbWFsbCcpXHJcbiAgICAgICAgICAudGV4dCgnVXNlJylcclxuICAgICAgICAgIC5hdHRyKCdkYXRhLWNsYXNzaWZpY2F0aW9uSWQnLCh1c2UgPT09ICduYW1lJykgPyByWzBdLnRleHQgOiByWzBdLmlkKVxyXG4gICAgICAgICAgLmluc2VydEFmdGVyKCQoJyMnK3JbMF0uaWQgKycgLmpzdHJlZS1jbGlja2VkJywgJGpzdHJlZSkpXHJcbiAgICAgICAgICAub24oJ2NsaWNrJywgc2V0SWRMaXN0ZW5lcik7XHJcbiAgICAgIH0pO1xyXG5cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiAgdXBkYXRlVHJlZShqc29uKSB7XHJcbiAgICAgIHZhciBuZXdKc29uID0gKGpzb25bJ19lbWJlZGRlZCddICYmIGpzb25bJ19lbWJlZGRlZCddWydjbGFzc2lmaWNhdGlvbnMnXSkgPyBzZXRDaGlsZHJlbihqc29uWydfZW1iZWRkZWQnXVsnY2xhc3NpZmljYXRpb25zJ10pIDogbnVsbDtcclxuICAgICAgJGpzdHJlZS5qc3RyZWUodHJ1ZSkuc2V0dGluZ3MuY29yZS5kYXRhID0gbmV3SnNvbjtcclxuICAgICAgJGpzdHJlZS5qc3RyZWUodHJ1ZSkucmVmcmVzaCgpO1xyXG5cclxuICAgICAgaWYobmV3SnNvbiAmJiBuZXdKc29uLmxlbmd0aCAmJiBuZXdKc29uWzBdLmNoaWxkcmVuLmxlbmd0aCA9PT0gMCl7XHJcbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgJCgnLmpzdHJlZS1pY29uJykuaGlkZSgpO1xyXG4gICAgICAgICAgfSwxMDAgKTtcclxuICAgICAgfTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gZGF0YSB7QXJyYXl9IC0gcmVjaXZlZCBjbGFzc2lmaWNhdGlvbnMgYXJyYXlcclxuICAgICAqIEByZXR1cm5zIHtBcnJheX1cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gc2V0Q2hpbGRyZW4oZGF0YSkge1xyXG4gICAgICB2YXIgbmV3QXJyT2JqID1bXTtcclxuICAgICAgZGF0YSA9IHJlbmFtZShkYXRhKTtcclxuXHJcbiAgICAgIC8vcmVuYW1lIHBhcmVudChnZW5yZXMpXHJcbiAgICAgIGRhdGEubWFwKGZ1bmN0aW9uKGl0ZW0pe1xyXG4gICAgICAgIG5ld0Fyck9iai5wdXNoKCB7XHJcbiAgICAgICAgICBjaGlsZHJlbjooaXRlbS5zZWdtZW50Ll9lbWJlZGRlZCAmJiBpdGVtLnNlZ21lbnQuX2VtYmVkZGVkLmdlbnJlcyk/IGl0ZW0uc2VnbWVudC5fZW1iZWRkZWQuZ2VucmVzIDpbXSxcclxuICAgICAgICAgIHRleHQgOiBpdGVtLnNlZ21lbnQudGV4dCB8fCAnJyxcclxuICAgICAgICAgIGlkIDogaXRlbS5zZWdtZW50LmlkXHJcbiAgICAgICAgfSApO1xyXG4gICAgICB9KTtcclxuICAgICAgLy9yZW5hbWUvY29weSBjaGlsZChzdWJnZW5yZXMpIGZpZWxkXHJcbiAgICAgIG5ld0Fyck9iai5tYXAoZnVuY3Rpb24oaXRlbSl7XHJcbiAgICAgICAgaXRlbS5jaGlsZHJlbi5tYXAoZnVuY3Rpb24oaXRlbSkge1xyXG4gICAgICAgICAgaWYoaXRlbS5fZW1iZWRkZWQgJiYgaXRlbS5fZW1iZWRkZWQuc3ViZ2VucmVzKXtcclxuICAgICAgICAgICAgaXRlbVsnY2hpbGRyZW4nXSA9IGl0ZW0uX2VtYmVkZGVkLnN1YmdlbnJlcyA7XHJcbiAgICAgICAgICAgIGRlbGV0ZSBpdGVtLl9lbWJlZGRlZDtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgfSk7XHJcblxyXG4gICAgICByZXR1cm4gbmV3QXJyT2JqO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVuYW1lIGZpZWxkc1xyXG4gICAgICogQHBhcmFtIGpzb25cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gcmVuYW1lKGpzb24pIHtcclxuICAgICAgdmFyIG9wdCA9e1xyXG4gICAgICAgIHJvb3Q6IHtmaWVsZE5hbWU6WydzZWdtZW50J10sIHZhbDondGV4dCcsIHRvOiduYW1lJyB9LFxyXG4gICAgICAgIHBhcmVudDoge2ZpZWxkTmFtZTpbJ2dlbnJlcyddLCdfZW1iZWRkZWQnOnRydWUgLCAgdmFsOid0ZXh0JywgdG86J25hbWUnIH0sXHJcbiAgICAgICAgY2hpbGQ6IHtmaWVsZE5hbWU6WydzdWJnZW5yZXMnXSwnX2VtYmVkZGVkJzp0cnVlLCAgIHZhbDondGV4dCcsIHRvOiduYW1lJ31cclxuICAgICAgfTtcclxuICAgICAgdmFyIGFyciA9IEpTT04uc3RyaW5naWZ5KGpzb24pOy8vY29udmVydCBhcnJheSB0byBzdHJpbmdcclxuICAgICAgYXJyID0gSlNPTi5wYXJzZShhcnIpO1xyXG5cclxuXHJcbiAgICAgIGZ1bmN0aW9uIHJlcGxhY2VBdG9CKGFycixvcHQpIHtcclxuICAgICAgICB2YXIgZ2VucmVzQXJyID0gW10sXHJcbiAgICAgICAgICAgIHN1YmdlbnJlc0FyciA9IFtdO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpPGFyci5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgYXJyW2ldW29wdC5yb290LmZpZWxkTmFtZV1bb3B0LnJvb3QudmFsXSA9IGFycltpXVtvcHQucm9vdC5maWVsZE5hbWVdW29wdC5yb290LnRvXTtcclxuICAgICAgICAgIGRlbGV0ZSBhcnJbaV1bb3B0LnJvb3QuZmllbGROYW1lXVtvcHQucm9vdC50b107XHJcblxyXG5cclxuICAgICAgICAgIGlmKCBhcnJbaV1bb3B0LnJvb3QuZmllbGROYW1lXVsnX2VtYmVkZGVkJ10gJiYgb3B0LnBhcmVudC5maWVsZE5hbWUgaW4gYXJyW2ldW29wdC5yb290LmZpZWxkTmFtZV1bJ19lbWJlZGRlZCddKSB7XHJcbiAgICAgICAgICAgIGdlbnJlc0FyciA9IGFycltpXVtvcHQucm9vdC5maWVsZE5hbWVdWydfZW1iZWRkZWQnXVtvcHQucGFyZW50LmZpZWxkTmFtZV07XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBpZiggMDxnZW5yZXNBcnIubGVuZ3RoICkge1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpaSA9IDA7IGlpIDwgZ2VucmVzQXJyLmxlbmd0aDsgaWkrKykge1xyXG4gICAgICAgICAgICAgIGdlbnJlc0FycltpaV1bb3B0LnBhcmVudC52YWxdID0gZ2VucmVzQXJyW2lpXVtvcHQucGFyZW50LnRvXTtcclxuICAgICAgICAgICAgICBkZWxldGUgZ2VucmVzQXJyW2lpXVtvcHQucGFyZW50LnRvXTtcclxuXHJcbiAgICAgICAgICAgICAgaWYoZ2VucmVzQXJyW2lpXVsnX2VtYmVkZGVkJ10gJiYgZ2VucmVzQXJyW2lpXVsnX2VtYmVkZGVkJ11bb3B0LmNoaWxkLmZpZWxkTmFtZV0pe1xyXG4gICAgICAgICAgICAgICAgc3ViZ2VucmVzQXJyID0gZ2VucmVzQXJyW2lpXVsnX2VtYmVkZGVkJ11bb3B0LmNoaWxkLmZpZWxkTmFtZV07XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIGlmKCAwPHN1YmdlbnJlc0Fyci5sZW5ndGggKSB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHN1YmdlbnJlc0Fyci5sZW5ndGg7IGorKykge1xyXG4gICAgICAgICAgICAgICAgICBzdWJnZW5yZXNBcnJbal1bb3B0LmNoaWxkLnZhbF0gPSBzdWJnZW5yZXNBcnJbal1bb3B0LmNoaWxkLnRvXTtcclxuICAgICAgICAgICAgICAgICAgaWYoaj4wKSBkZWxldGUgc3ViZ2VucmVzQXJyW2pdW29wdC5jaGlsZC50b107Ly9za2lwIHplcm8gaXRlbVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIHJlcGxhY2VBdG9CKGFycixvcHQpO1xyXG4gICAgICByZXR1cm4gYXJyO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogc2V0IGRhdGEtc2VsZWN0b3IgZm9yIFwiR0VUXCIgYnV0dG9uXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGNoYW5nZU1vZGFsVGV4dExpc3RlbmVyKCkge1xyXG4gICAgICAkYnRuR0VULmF0dHIoJ2RhdGEtc2VsZWN0b3InLCBzZWxlY3Rvcik7XHJcbiAgICAgIHN1Ym1pdEZvcm0odHJ1ZSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBzaG93L2hpZGUgbG9hZGVyXHJcbiAgICAgKiBAcGFyYW0gYWN0aW9uIC0gc3RyaW5nICgnb24nIG9yICdvZmYnKVxyXG4gICAgICovXHJcbiAgICB2YXIgbG9hZGluZyA9IGZ1bmN0aW9uIChhY3Rpb24pIHtcclxuICAgICAgdmFyIHNwaW5uZXIgPSAkKCcjc3Bpbm5lci1scycsICRtb2RhbCk7XHJcbiAgICAgIC8vIGFkZCB0aGUgb3ZlcmxheSB3aXRoIGxvYWRpbmcgaW1hZ2UgdG8gdGhlIHBhZ2VcclxuICAgICAgaWYgKGFjdGlvbiA9PSBcIm9uXCIpIHtcclxuICAgICAgICBzcGlubmVyLnNob3coKTtcclxuICAgICAgfVxyXG4gICAgICBlbHNlIGlmIChhY3Rpb24gPT0gXCJvZmZcIikge1xyXG4gICAgICAgIHNwaW5uZXIuaGlkZSgpO1xyXG4gICAgICB9XHJcblxyXG4gICAgfTtcclxuXHJcbiAgICBmdW5jdGlvbiByZXNldEZvcm0oKSB7XHJcbiAgICAgICRqc3RyZWVcclxuICAgICAgICAuanN0cmVlKFwiZGVzdHJveVwiKVxyXG4gICAgICAgIC5yZW1vdmVBdHRyKCdjbGFzcycpXHJcbiAgICAgICAgLnJlbW92ZUF0dHIoJ3JvbGUnKVxyXG4gICAgICAgIC5yZW1vdmVBdHRyKCdhcmlhLWFjdGl2ZWRlc2NlbmRhbnQnKVxyXG4gICAgICA7XHJcbiAgICAgIC8vIENsZWFyIGhpZ2hsaWdodFxyXG4gICAgICAkZm9ybS5yZW1vdmVDbGFzcyhjc3NWYWxpZGF0aW9uQ2xhc3MpO1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICAvKipcclxuICAgICAqIEhhbmRsZXIgZm9yICdHRVQnIGJ1dHRvblxyXG4gICAgICogQHBhcmFtIHBhZ2VOdW1lcm8gLSBpbnQuIHVzZWQgZm9yIHBhZ2luYXRpb25cclxuICAgICAqIEBwYXJhbSBldmVudFVybCAtIHVybCBvZiByZXF1ZXN0XHJcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gLSBkb25lL2ZhaWxcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gc3VibWl0Rm9ybShpc0luaXQpIHtcclxuICAgICAgdmFyIHVybCA9ICggaXNJbml0IClcclxuICAgICAgICA/IGV2ZW50VXJsICsgJz9hcGlrZXk9JyArIGFwaWtleVxyXG4gICAgICAgIDogZXZlbnRVcmwgKyAnP2FwaWtleT0nICsgYXBpa2V5ICsgJyZrZXl3b3JkPScgKyBrZXl3b3JkLnZhbCgpO1xyXG4gICAgICBcclxuICAgICAgJC5hamF4KHtcclxuICAgICAgICBkYXRhVHlwZTogJ2pzb24nLFxyXG4gICAgICAgIGFzeW5jOiB0cnVlLFxyXG4gICAgICAgIHVybDogdXJsLFxyXG4gICAgICAgIGRhdGE6ICRmb3JtLnNlcmlhbGl6ZSgpXHJcbiAgICAgIH0pLmRvbmUoZnVuY3Rpb24gKHJlc3VsdCkge1xyXG4gICAgICAgIGlmIChyZXN1bHQpIHtcclxuICAgICAgICAgIGlmIChyZXN1bHQucGFnZS50b3RhbEVsZW1lbnRzIDwgMSkge1xyXG4gICAgICAgICAgICBsb2FkaW5nKCdvZmYnKTtcclxuICAgICAgICAgICAgcmVuZGVyUmVzdWx0cyhudWxsLCAkanN0cmVlKTsgLy9hZGQgbWVzc2FnZSBhdCBib3R0b20gb2YgbGlzdFxyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgIChpc0luaXQpID8gaW5pdFRyZWUocmVzdWx0KSA6IHVwZGF0ZVRyZWUocmVzdWx0KTtcclxuICAgICAgICAgIGxvYWRpbmcoJ29mZicpO1xyXG4gICAgICAgICAgJGJ0bkdFVC5hdHRyKCdkaXNhYmxlZCcsIGZhbHNlKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgY29uc29sZS5sb2coJ25vIHJlc3VsdCBmb3VuZCcpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSkuZmFpbChmdW5jdGlvbiAoZSwgdGV4dFN0YXR1cywgZXJyb3JUaHJvd24pIHtcclxuICAgICAgICBjb25zb2xlLmxvZygnVGhlcmUgd2FzIGFuIGZhaWwgc3RhdHVzIC0gJyAsIGUuc3RhdHVzICwgZXJyb3JUaHJvd24pO1xyXG4gICAgICAgIGxvYWRpbmcoJ29mZicpO1xyXG4gICAgICAgIHJlbmRlclJlc3VsdHMoJ0ZBSUwnLCAkanN0cmVlICwgZSk7XHJcbiAgICAgICAgJGJ0bkdFVC5hdHRyKCdkaXNhYmxlZCcsIGZhbHNlKTtcclxuICAgICAgfSk7XHJcblxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGhhc1Njcm9sbEJhcihlbGVtZW50KSB7XHJcbiAgICAgIHJldHVybiBlbGVtZW50LmdldCgwKS5zY3JvbGxIZWlnaHQgPiBlbGVtZW50LnBhcmVudCgpLmlubmVySGVpZ2h0KCk7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIHJlbmRlclJlc3VsdHMgPSBmdW5jdGlvbiAoZGF0YSwgdWxFbGVtZW50LCBlcnJvck1zZykge1xyXG4gICAgICBmdW5jdGlvbiBzaG93TWVzc2FnZShlbGVtZW50LCBtZXNzYWdlLCAvKm9wdGlvbmFsKi9jbGVhckxpc3QpIHtcclxuICAgICAgICBpZiAoY2xlYXJMaXN0KSB7XHJcbiAgICAgICAgICAkKCdsaScsIGVsZW1lbnQpLnJlbW92ZSgpO1xyXG4gICAgICAgICAgJCgnLmVycm9yLWJveCcpLnJlbW92ZSgpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgJCgnPGRpdi8+JylcclxuICAgICAgICAgIC5hZGRDbGFzcyggJ2Vycm9yLWJveCB0ZXh0LWNlbnRlciAnKVxyXG4gICAgICAgICAgLmFkZENsYXNzKCAoZGF0YSA9PT0gJ0ZBSUwnKT8nIGVycm9yLWZhaWwgJzogJycpXHJcbiAgICAgICAgICAgIC5hcHBlbmQoJCgnPGgzLz4nKS50ZXh0KG1lc3NhZ2UubXNnKSlcclxuICAgICAgICAgICAgLmFwcGVuZCgkKCc8cC8+JykudGV4dChtZXNzYWdlLmV4cGxhbmF0aW9uKSlcclxuICAgICAgICAgIC5hcHBlbmRUbyh1bEVsZW1lbnQpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAkYnRuR0VULmF0dHIoJ2Rpc2FibGVkJywgZmFsc2UpO1xyXG5cclxuICAgICAgLy9zaG93IGZhaWwgbXNnXHJcbiAgICAgIGlmIChkYXRhID09PSAnRkFJTCcpIHtcclxuICAgICAgICB2YXIgbXNnRXJyID0gKGVycm9yTXNnLnJlc3BvbnNlSlNPTiAhPT0gbnVsbCApP2Vycm9yTXNnLnJlc3BvbnNlSlNPTi5lcnJvcnNbMF0uc3RhdHVzIDogJ3Vua25vd24nLFxyXG4gICAgICAgICAgc3RhdHVzVGV4dCA9IChlcnJvck1zZy5yZXNwb25zZUpTT04gIT09IG51bGwgKT9lcnJvck1zZy5yZXNwb25zZUpTT04uZXJyb3JzWzBdLnN0YXR1c1RleHQgIDogZXJyb3JNc2cuc3RhdHVzVGV4dCAgfHwgJycsXHJcbiAgICAgICAgICBleHBsYW5hdGlvbiA9IChlcnJvck1zZy5yZXNwb25zZUpTT04gIT09IG51bGwgKT9lcnJvck1zZy5yZXNwb25zZUpTT04uZXJyb3JzWzBdLmRldGFpbCA6ICd1bmtub3duJztcclxuXHJcbiAgICAgICAgc2hvd01lc3NhZ2UoJGpzdHJlZSwge1xyXG4gICAgICAgICAgbXNnOiAnRXJyb3IgJyArIG1zZ0VyciArICc6ICcgKyBzdGF0dXNUZXh0LFxyXG4gICAgICAgICAgZXhwbGFuYXRpb246IGV4cGxhbmF0aW9uXHJcbiAgICAgICAgfSwgdHJ1ZSk7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvL3Nob3cgTm8gcmVzdWx0cyBmb3VuZCBtc2dcclxuICAgICAgaWYgKGRhdGEgPT09IG51bGwgfHwgIWRhdGEuX2VtYmVkZGVkKSB7XHJcbiAgICAgICAgc2hvd01lc3NhZ2UodWxFbGVtZW50LCB7bXNnOiAnTm8gcmVzdWx0cyBmb3VuZC4nICwgZXhwbGFuYXRpb246ICdQbGVhc2UgdHJ5IHRvIGdldCBhbm90aGVyIGtleXdvcmQuJ30sIHRydWUpO1xyXG4gICAgICAgIG1vZGFsQ29udGVudC5yZW1vdmVDbGFzcygnbmFycm93Jyk7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIGZ1bmN0aW9uIHNldElkTGlzdGVuZXIoZSl7XHJcbiAgICAgIHZhciBzZWxlY3RlZElEID0gZS50YXJnZXQuZ2V0QXR0cmlidXRlKCdkYXRhLWNsYXNzaWZpY2F0aW9uSWQnKTtcclxuICAgICAgJGlucHV0LnZhbChzZWxlY3RlZElEKVxyXG4gICAgICAgICAgICAuYXR0cigndmFsdWUnLCBzZWxlY3RlZElEKVxyXG4gICAgICAgICAgICAudHJpZ2dlcignY2hhbmdlJyk7ICAvL3VwZGF0ZSB3aWRnZXQ6XHJcblxyXG4gICAgICAvLyBDbG9zZSBkaWFsb2dcclxuICAgICAgJG1vZGFsLm1vZGFsKCdoaWRlJyk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gRVZFTlRTXHJcbiAgICAkYnRuR0VULm9uKCdjbGljaycsIGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgIGUucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgaWYgKCRidG5HRVQuYXR0cignZGF0YS1zZWxlY3RvcicpICE9PSAkaWNvbkJ1dHRvbi5hdHRyKCdkYXRhLXNlbGVjdG9yJykpIHJldHVybiBmYWxzZTsgLy9zdG9wIHJlcXVlc3RcclxuXHJcbiAgICAgIHZhciBmb3JtID0gJGZvcm0uZ2V0KDApO1xyXG4gICAgICBpZiAoISRidG5HRVQuaXMoJzpkaXNhYmxlZCcpKSB7XHJcbiAgICAgICAgaWYgKGZvcm0uY2hlY2tWYWxpZGl0eSgpKSB7XHJcbiAgICAgICAgICAkYnRuR0VULmF0dHIoJ2Rpc2FibGVkJywgdHJ1ZSk7XHJcbiAgICAgICAgICBsb2FkaW5nKCdvbicpOyAvL3Nob3cgbG9hZGluZy1zcGlubmVyXHJcbiAgICAgICAgICBzdWJtaXRGb3JtKCk7XHJcbiAgICAgICAgICAvL3Jlc2V0Rm9ybSgpOyAvL2NsZWFyXHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIC8vIEhpZ2hsaWdodCBlcnJvcnNcclxuICAgICAgICAgIGlmIChmb3JtLnJlcG9ydFZhbGlkaXR5KSBmb3JtLnJlcG9ydFZhbGlkaXR5KCk7XHJcbiAgICAgICAgICAkZm9ybS5hZGRDbGFzcyhjc3NWYWxpZGF0aW9uQ2xhc3MpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgJGZvcm0ub24oXCJrZXl1cFwiLCBmdW5jdGlvbiAoZSkge1xyXG4gICAgICB2YXIgaW5wdXQgPSAkKGUudGFyZ2V0KTtcclxuICAgICAgaWYgKGUudGFyZ2V0LnRhZ05hbWUgPT09IFwiSU5QVVRcIil7XHJcbiAgICAgICAgaWYgKGUua2V5Q29kZSA9PSAxMyl7XHJcbiAgICAgICAgICBpbnB1dC5ibHVyKCk7XHJcblxyXG4gICAgICAgICAgbW9kYWxDb250ZW50LnJlbW92ZUNsYXNzKCduYXJyb3cnKTtcclxuICAgICAgICAgIGlmICgkYnRuR0VULmF0dHIoJ2RhdGEtc2VsZWN0b3InKSAhPT0gJGljb25CdXR0b24uYXR0cignZGF0YS1zZWxlY3RvcicpKSByZXR1cm4gZmFsc2U7XHJcblxyXG4gICAgICAgICAgaWYgKCRmb3JtLmdldCgwKS5jaGVja1ZhbGlkaXR5KCkpIHtcclxuICAgICAgICAgICAgbG9hZGluZygnb24nKTtcclxuICAgICAgICAgICAgc3VibWl0Rm9ybSgpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9KTtcclxuXHJcbiAgICAvLyBNb2JpbGUgZGV2aWNlcy4gRm9yY2UgJ2NoYW5nZScgYnkgJ0dvJyBwcmVzc1xyXG4gICAgJGZvcm0ub24oXCJzdWJtaXRcIiwgZnVuY3Rpb24gKGUpIHtcclxuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgJG1vZGFsLm9uKCdoaWRkZW4uYnMubW9kYWwnLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHJlc2V0Rm9ybSgpO1xyXG4gICAgICBrZXl3b3JkLnZhbCgnJyk7Ly9jbGVhciBzZWFyY2ggaW5wdXRcclxuICAgIH0pO1xyXG5cclxuICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKGkpIHtcclxuICAgICAgaW5pdCgkKHRoaXMpKTtcclxuXHJcbiAgICAgIGZ1bmN0aW9uIGluaXQoaW5wdXQpIHtcclxuICAgICAgICBpbnB1dC53cmFwKCc8ZGl2IGNsYXNzPVwibGF6eS1zZWxlY3Rvci13cmFwcGVyXCI+PC9kaXY+Jyk7XHJcbiAgICAgICAgaW5wdXQuYWZ0ZXIoJGljb25CdXR0b24pO1xyXG4gICAgICAgICRpY29uQnV0dG9uLmF0dHIoJ2RhdGEtc2VsZWN0b3InLCBzZWxlY3Rvcik7XHJcblxyXG4gICAgICAgICQoJyNnZXQtJytvcHRpb25zLnNlbGVjdG9yKyctJytvcHRpb25zLnVzZSkub24oJ2NsaWNrJywgY2hhbmdlTW9kYWxUZXh0TGlzdGVuZXIpO1xyXG5cclxuICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gIH07XHJcblxyXG59KShqUXVlcnkpO1xyXG5cclxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc2NyaXB0cy9jb21wb25lbnRzL2NsYXNzaWZpY2F0aW9uLXNlbGVjdG9yLmpzIiwibW9kdWxlLmV4cG9ydHMgPSB7IFwiZGVmYXVsdFwiOiByZXF1aXJlKFwiY29yZS1qcy9saWJyYXJ5L2ZuL2pzb24vc3RyaW5naWZ5XCIpLCBfX2VzTW9kdWxlOiB0cnVlIH07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9qc29uL3N0cmluZ2lmeS5qc1xuLy8gbW9kdWxlIGlkID0gOTlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGNvcmUgID0gcmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9fY29yZScpXG4gICwgJEpTT04gPSBjb3JlLkpTT04gfHwgKGNvcmUuSlNPTiA9IHtzdHJpbmdpZnk6IEpTT04uc3RyaW5naWZ5fSk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHN0cmluZ2lmeShpdCl7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgcmV0dXJuICRKU09OLnN0cmluZ2lmeS5hcHBseSgkSlNPTiwgYXJndW1lbnRzKTtcbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbGlicmFyeS9mbi9qc29uL3N0cmluZ2lmeS5qc1xuLy8gbW9kdWxlIGlkID0gMTAwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qIVxyXG4gKiBCb290c3RyYXAgdjMuMy42IChodHRwOi8vZ2V0Ym9vdHN0cmFwLmNvbSlcclxuICogQ29weXJpZ2h0IDIwMTEtMjAxNSBUd2l0dGVyLCBJbmMuXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxyXG4gKi9cclxuaWYoXCJ1bmRlZmluZWRcIj09dHlwZW9mIGpRdWVyeSl0aHJvdyBuZXcgRXJyb3IoXCJCb290c3RyYXAncyBKYXZhU2NyaXB0IHJlcXVpcmVzIGpRdWVyeVwiKTsrZnVuY3Rpb24oYSl7XCJ1c2Ugc3RyaWN0XCI7dmFyIGI9YS5mbi5qcXVlcnkuc3BsaXQoXCIgXCIpWzBdLnNwbGl0KFwiLlwiKTtpZihiWzBdPDImJmJbMV08OXx8MT09YlswXSYmOT09YlsxXSYmYlsyXTwxfHxiWzBdPjIpdGhyb3cgbmV3IEVycm9yKFwiQm9vdHN0cmFwJ3MgSmF2YVNjcmlwdCByZXF1aXJlcyBqUXVlcnkgdmVyc2lvbiAxLjkuMSBvciBoaWdoZXIsIGJ1dCBsb3dlciB0aGFuIHZlcnNpb24gM1wiKX0oalF1ZXJ5KSwrZnVuY3Rpb24oYSl7XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gYigpe3ZhciBhPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJib290c3RyYXBcIiksYj17V2Via2l0VHJhbnNpdGlvbjpcIndlYmtpdFRyYW5zaXRpb25FbmRcIixNb3pUcmFuc2l0aW9uOlwidHJhbnNpdGlvbmVuZFwiLE9UcmFuc2l0aW9uOlwib1RyYW5zaXRpb25FbmQgb3RyYW5zaXRpb25lbmRcIix0cmFuc2l0aW9uOlwidHJhbnNpdGlvbmVuZFwifTtmb3IodmFyIGMgaW4gYilpZih2b2lkIDAhPT1hLnN0eWxlW2NdKXJldHVybntlbmQ6YltjXX07cmV0dXJuITF9YS5mbi5lbXVsYXRlVHJhbnNpdGlvbkVuZD1mdW5jdGlvbihiKXt2YXIgYz0hMSxkPXRoaXM7YSh0aGlzKS5vbmUoXCJic1RyYW5zaXRpb25FbmRcIixmdW5jdGlvbigpe2M9ITB9KTt2YXIgZT1mdW5jdGlvbigpe2N8fGEoZCkudHJpZ2dlcihhLnN1cHBvcnQudHJhbnNpdGlvbi5lbmQpfTtyZXR1cm4gc2V0VGltZW91dChlLGIpLHRoaXN9LGEoZnVuY3Rpb24oKXthLnN1cHBvcnQudHJhbnNpdGlvbj1iKCksYS5zdXBwb3J0LnRyYW5zaXRpb24mJihhLmV2ZW50LnNwZWNpYWwuYnNUcmFuc2l0aW9uRW5kPXtiaW5kVHlwZTphLnN1cHBvcnQudHJhbnNpdGlvbi5lbmQsZGVsZWdhdGVUeXBlOmEuc3VwcG9ydC50cmFuc2l0aW9uLmVuZCxoYW5kbGU6ZnVuY3Rpb24oYil7cmV0dXJuIGEoYi50YXJnZXQpLmlzKHRoaXMpP2IuaGFuZGxlT2JqLmhhbmRsZXIuYXBwbHkodGhpcyxhcmd1bWVudHMpOnZvaWQgMH19KX0pfShqUXVlcnkpLCtmdW5jdGlvbihhKXtcInVzZSBzdHJpY3RcIjtmdW5jdGlvbiBiKGIpe3JldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKXt2YXIgYz1hKHRoaXMpLGU9Yy5kYXRhKFwiYnMuYWxlcnRcIik7ZXx8Yy5kYXRhKFwiYnMuYWxlcnRcIixlPW5ldyBkKHRoaXMpKSxcInN0cmluZ1wiPT10eXBlb2YgYiYmZVtiXS5jYWxsKGMpfSl9dmFyIGM9J1tkYXRhLWRpc21pc3M9XCJhbGVydFwiXScsZD1mdW5jdGlvbihiKXthKGIpLm9uKFwiY2xpY2tcIixjLHRoaXMuY2xvc2UpfTtkLlZFUlNJT049XCIzLjMuNlwiLGQuVFJBTlNJVElPTl9EVVJBVElPTj0xNTAsZC5wcm90b3R5cGUuY2xvc2U9ZnVuY3Rpb24oYil7ZnVuY3Rpb24gYygpe2cuZGV0YWNoKCkudHJpZ2dlcihcImNsb3NlZC5icy5hbGVydFwiKS5yZW1vdmUoKX12YXIgZT1hKHRoaXMpLGY9ZS5hdHRyKFwiZGF0YS10YXJnZXRcIik7Znx8KGY9ZS5hdHRyKFwiaHJlZlwiKSxmPWYmJmYucmVwbGFjZSgvLiooPz0jW15cXHNdKiQpLyxcIlwiKSk7dmFyIGc9YShmKTtiJiZiLnByZXZlbnREZWZhdWx0KCksZy5sZW5ndGh8fChnPWUuY2xvc2VzdChcIi5hbGVydFwiKSksZy50cmlnZ2VyKGI9YS5FdmVudChcImNsb3NlLmJzLmFsZXJ0XCIpKSxiLmlzRGVmYXVsdFByZXZlbnRlZCgpfHwoZy5yZW1vdmVDbGFzcyhcImluXCIpLGEuc3VwcG9ydC50cmFuc2l0aW9uJiZnLmhhc0NsYXNzKFwiZmFkZVwiKT9nLm9uZShcImJzVHJhbnNpdGlvbkVuZFwiLGMpLmVtdWxhdGVUcmFuc2l0aW9uRW5kKGQuVFJBTlNJVElPTl9EVVJBVElPTik6YygpKX07dmFyIGU9YS5mbi5hbGVydDthLmZuLmFsZXJ0PWIsYS5mbi5hbGVydC5Db25zdHJ1Y3Rvcj1kLGEuZm4uYWxlcnQubm9Db25mbGljdD1mdW5jdGlvbigpe3JldHVybiBhLmZuLmFsZXJ0PWUsdGhpc30sYShkb2N1bWVudCkub24oXCJjbGljay5icy5hbGVydC5kYXRhLWFwaVwiLGMsZC5wcm90b3R5cGUuY2xvc2UpfShqUXVlcnkpLCtmdW5jdGlvbihhKXtcInVzZSBzdHJpY3RcIjtmdW5jdGlvbiBiKGIpe3JldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKXt2YXIgZD1hKHRoaXMpLGU9ZC5kYXRhKFwiYnMuYnV0dG9uXCIpLGY9XCJvYmplY3RcIj09dHlwZW9mIGImJmI7ZXx8ZC5kYXRhKFwiYnMuYnV0dG9uXCIsZT1uZXcgYyh0aGlzLGYpKSxcInRvZ2dsZVwiPT1iP2UudG9nZ2xlKCk6YiYmZS5zZXRTdGF0ZShiKX0pfXZhciBjPWZ1bmN0aW9uKGIsZCl7dGhpcy4kZWxlbWVudD1hKGIpLHRoaXMub3B0aW9ucz1hLmV4dGVuZCh7fSxjLkRFRkFVTFRTLGQpLHRoaXMuaXNMb2FkaW5nPSExfTtjLlZFUlNJT049XCIzLjMuNlwiLGMuREVGQVVMVFM9e2xvYWRpbmdUZXh0OlwibG9hZGluZy4uLlwifSxjLnByb3RvdHlwZS5zZXRTdGF0ZT1mdW5jdGlvbihiKXt2YXIgYz1cImRpc2FibGVkXCIsZD10aGlzLiRlbGVtZW50LGU9ZC5pcyhcImlucHV0XCIpP1widmFsXCI6XCJodG1sXCIsZj1kLmRhdGEoKTtiKz1cIlRleHRcIixudWxsPT1mLnJlc2V0VGV4dCYmZC5kYXRhKFwicmVzZXRUZXh0XCIsZFtlXSgpKSxzZXRUaW1lb3V0KGEucHJveHkoZnVuY3Rpb24oKXtkW2VdKG51bGw9PWZbYl0/dGhpcy5vcHRpb25zW2JdOmZbYl0pLFwibG9hZGluZ1RleHRcIj09Yj8odGhpcy5pc0xvYWRpbmc9ITAsZC5hZGRDbGFzcyhjKS5hdHRyKGMsYykpOnRoaXMuaXNMb2FkaW5nJiYodGhpcy5pc0xvYWRpbmc9ITEsZC5yZW1vdmVDbGFzcyhjKS5yZW1vdmVBdHRyKGMpKX0sdGhpcyksMCl9LGMucHJvdG90eXBlLnRvZ2dsZT1mdW5jdGlvbigpe3ZhciBhPSEwLGI9dGhpcy4kZWxlbWVudC5jbG9zZXN0KCdbZGF0YS10b2dnbGU9XCJidXR0b25zXCJdJyk7aWYoYi5sZW5ndGgpe3ZhciBjPXRoaXMuJGVsZW1lbnQuZmluZChcImlucHV0XCIpO1wicmFkaW9cIj09Yy5wcm9wKFwidHlwZVwiKT8oYy5wcm9wKFwiY2hlY2tlZFwiKSYmKGE9ITEpLGIuZmluZChcIi5hY3RpdmVcIikucmVtb3ZlQ2xhc3MoXCJhY3RpdmVcIiksdGhpcy4kZWxlbWVudC5hZGRDbGFzcyhcImFjdGl2ZVwiKSk6XCJjaGVja2JveFwiPT1jLnByb3AoXCJ0eXBlXCIpJiYoYy5wcm9wKFwiY2hlY2tlZFwiKSE9PXRoaXMuJGVsZW1lbnQuaGFzQ2xhc3MoXCJhY3RpdmVcIikmJihhPSExKSx0aGlzLiRlbGVtZW50LnRvZ2dsZUNsYXNzKFwiYWN0aXZlXCIpKSxjLnByb3AoXCJjaGVja2VkXCIsdGhpcy4kZWxlbWVudC5oYXNDbGFzcyhcImFjdGl2ZVwiKSksYSYmYy50cmlnZ2VyKFwiY2hhbmdlXCIpfWVsc2UgdGhpcy4kZWxlbWVudC5hdHRyKFwiYXJpYS1wcmVzc2VkXCIsIXRoaXMuJGVsZW1lbnQuaGFzQ2xhc3MoXCJhY3RpdmVcIikpLHRoaXMuJGVsZW1lbnQudG9nZ2xlQ2xhc3MoXCJhY3RpdmVcIil9O3ZhciBkPWEuZm4uYnV0dG9uO2EuZm4uYnV0dG9uPWIsYS5mbi5idXR0b24uQ29uc3RydWN0b3I9YyxhLmZuLmJ1dHRvbi5ub0NvbmZsaWN0PWZ1bmN0aW9uKCl7cmV0dXJuIGEuZm4uYnV0dG9uPWQsdGhpc30sYShkb2N1bWVudCkub24oXCJjbGljay5icy5idXR0b24uZGF0YS1hcGlcIiwnW2RhdGEtdG9nZ2xlXj1cImJ1dHRvblwiXScsZnVuY3Rpb24oYyl7dmFyIGQ9YShjLnRhcmdldCk7ZC5oYXNDbGFzcyhcImJ0blwiKXx8KGQ9ZC5jbG9zZXN0KFwiLmJ0blwiKSksYi5jYWxsKGQsXCJ0b2dnbGVcIiksYShjLnRhcmdldCkuaXMoJ2lucHV0W3R5cGU9XCJyYWRpb1wiXScpfHxhKGMudGFyZ2V0KS5pcygnaW5wdXRbdHlwZT1cImNoZWNrYm94XCJdJyl8fGMucHJldmVudERlZmF1bHQoKX0pLm9uKFwiZm9jdXMuYnMuYnV0dG9uLmRhdGEtYXBpIGJsdXIuYnMuYnV0dG9uLmRhdGEtYXBpXCIsJ1tkYXRhLXRvZ2dsZV49XCJidXR0b25cIl0nLGZ1bmN0aW9uKGIpe2EoYi50YXJnZXQpLmNsb3Nlc3QoXCIuYnRuXCIpLnRvZ2dsZUNsYXNzKFwiZm9jdXNcIiwvXmZvY3VzKGluKT8kLy50ZXN0KGIudHlwZSkpfSl9KGpRdWVyeSksK2Z1bmN0aW9uKGEpe1widXNlIHN0cmljdFwiO2Z1bmN0aW9uIGIoYil7cmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpe3ZhciBkPWEodGhpcyksZT1kLmRhdGEoXCJicy5jYXJvdXNlbFwiKSxmPWEuZXh0ZW5kKHt9LGMuREVGQVVMVFMsZC5kYXRhKCksXCJvYmplY3RcIj09dHlwZW9mIGImJmIpLGc9XCJzdHJpbmdcIj09dHlwZW9mIGI/YjpmLnNsaWRlO2V8fGQuZGF0YShcImJzLmNhcm91c2VsXCIsZT1uZXcgYyh0aGlzLGYpKSxcIm51bWJlclwiPT10eXBlb2YgYj9lLnRvKGIpOmc/ZVtnXSgpOmYuaW50ZXJ2YWwmJmUucGF1c2UoKS5jeWNsZSgpfSl9dmFyIGM9ZnVuY3Rpb24oYixjKXt0aGlzLiRlbGVtZW50PWEoYiksdGhpcy4kaW5kaWNhdG9ycz10aGlzLiRlbGVtZW50LmZpbmQoXCIuY2Fyb3VzZWwtaW5kaWNhdG9yc1wiKSx0aGlzLm9wdGlvbnM9Yyx0aGlzLnBhdXNlZD1udWxsLHRoaXMuc2xpZGluZz1udWxsLHRoaXMuaW50ZXJ2YWw9bnVsbCx0aGlzLiRhY3RpdmU9bnVsbCx0aGlzLiRpdGVtcz1udWxsLHRoaXMub3B0aW9ucy5rZXlib2FyZCYmdGhpcy4kZWxlbWVudC5vbihcImtleWRvd24uYnMuY2Fyb3VzZWxcIixhLnByb3h5KHRoaXMua2V5ZG93bix0aGlzKSksXCJob3ZlclwiPT10aGlzLm9wdGlvbnMucGF1c2UmJiEoXCJvbnRvdWNoc3RhcnRcImluIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCkmJnRoaXMuJGVsZW1lbnQub24oXCJtb3VzZWVudGVyLmJzLmNhcm91c2VsXCIsYS5wcm94eSh0aGlzLnBhdXNlLHRoaXMpKS5vbihcIm1vdXNlbGVhdmUuYnMuY2Fyb3VzZWxcIixhLnByb3h5KHRoaXMuY3ljbGUsdGhpcykpfTtjLlZFUlNJT049XCIzLjMuNlwiLGMuVFJBTlNJVElPTl9EVVJBVElPTj02MDAsYy5ERUZBVUxUUz17aW50ZXJ2YWw6NWUzLHBhdXNlOlwiaG92ZXJcIix3cmFwOiEwLGtleWJvYXJkOiEwfSxjLnByb3RvdHlwZS5rZXlkb3duPWZ1bmN0aW9uKGEpe2lmKCEvaW5wdXR8dGV4dGFyZWEvaS50ZXN0KGEudGFyZ2V0LnRhZ05hbWUpKXtzd2l0Y2goYS53aGljaCl7Y2FzZSAzNzp0aGlzLnByZXYoKTticmVhaztjYXNlIDM5OnRoaXMubmV4dCgpO2JyZWFrO2RlZmF1bHQ6cmV0dXJufWEucHJldmVudERlZmF1bHQoKX19LGMucHJvdG90eXBlLmN5Y2xlPWZ1bmN0aW9uKGIpe3JldHVybiBifHwodGhpcy5wYXVzZWQ9ITEpLHRoaXMuaW50ZXJ2YWwmJmNsZWFySW50ZXJ2YWwodGhpcy5pbnRlcnZhbCksdGhpcy5vcHRpb25zLmludGVydmFsJiYhdGhpcy5wYXVzZWQmJih0aGlzLmludGVydmFsPXNldEludGVydmFsKGEucHJveHkodGhpcy5uZXh0LHRoaXMpLHRoaXMub3B0aW9ucy5pbnRlcnZhbCkpLHRoaXN9LGMucHJvdG90eXBlLmdldEl0ZW1JbmRleD1mdW5jdGlvbihhKXtyZXR1cm4gdGhpcy4kaXRlbXM9YS5wYXJlbnQoKS5jaGlsZHJlbihcIi5pdGVtXCIpLHRoaXMuJGl0ZW1zLmluZGV4KGF8fHRoaXMuJGFjdGl2ZSl9LGMucHJvdG90eXBlLmdldEl0ZW1Gb3JEaXJlY3Rpb249ZnVuY3Rpb24oYSxiKXt2YXIgYz10aGlzLmdldEl0ZW1JbmRleChiKSxkPVwicHJldlwiPT1hJiYwPT09Y3x8XCJuZXh0XCI9PWEmJmM9PXRoaXMuJGl0ZW1zLmxlbmd0aC0xO2lmKGQmJiF0aGlzLm9wdGlvbnMud3JhcClyZXR1cm4gYjt2YXIgZT1cInByZXZcIj09YT8tMToxLGY9KGMrZSkldGhpcy4kaXRlbXMubGVuZ3RoO3JldHVybiB0aGlzLiRpdGVtcy5lcShmKX0sYy5wcm90b3R5cGUudG89ZnVuY3Rpb24oYSl7dmFyIGI9dGhpcyxjPXRoaXMuZ2V0SXRlbUluZGV4KHRoaXMuJGFjdGl2ZT10aGlzLiRlbGVtZW50LmZpbmQoXCIuaXRlbS5hY3RpdmVcIikpO3JldHVybiBhPnRoaXMuJGl0ZW1zLmxlbmd0aC0xfHwwPmE/dm9pZCAwOnRoaXMuc2xpZGluZz90aGlzLiRlbGVtZW50Lm9uZShcInNsaWQuYnMuY2Fyb3VzZWxcIixmdW5jdGlvbigpe2IudG8oYSl9KTpjPT1hP3RoaXMucGF1c2UoKS5jeWNsZSgpOnRoaXMuc2xpZGUoYT5jP1wibmV4dFwiOlwicHJldlwiLHRoaXMuJGl0ZW1zLmVxKGEpKX0sYy5wcm90b3R5cGUucGF1c2U9ZnVuY3Rpb24oYil7cmV0dXJuIGJ8fCh0aGlzLnBhdXNlZD0hMCksdGhpcy4kZWxlbWVudC5maW5kKFwiLm5leHQsIC5wcmV2XCIpLmxlbmd0aCYmYS5zdXBwb3J0LnRyYW5zaXRpb24mJih0aGlzLiRlbGVtZW50LnRyaWdnZXIoYS5zdXBwb3J0LnRyYW5zaXRpb24uZW5kKSx0aGlzLmN5Y2xlKCEwKSksdGhpcy5pbnRlcnZhbD1jbGVhckludGVydmFsKHRoaXMuaW50ZXJ2YWwpLHRoaXN9LGMucHJvdG90eXBlLm5leHQ9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5zbGlkaW5nP3ZvaWQgMDp0aGlzLnNsaWRlKFwibmV4dFwiKX0sYy5wcm90b3R5cGUucHJldj1mdW5jdGlvbigpe3JldHVybiB0aGlzLnNsaWRpbmc/dm9pZCAwOnRoaXMuc2xpZGUoXCJwcmV2XCIpfSxjLnByb3RvdHlwZS5zbGlkZT1mdW5jdGlvbihiLGQpe3ZhciBlPXRoaXMuJGVsZW1lbnQuZmluZChcIi5pdGVtLmFjdGl2ZVwiKSxmPWR8fHRoaXMuZ2V0SXRlbUZvckRpcmVjdGlvbihiLGUpLGc9dGhpcy5pbnRlcnZhbCxoPVwibmV4dFwiPT1iP1wibGVmdFwiOlwicmlnaHRcIixpPXRoaXM7aWYoZi5oYXNDbGFzcyhcImFjdGl2ZVwiKSlyZXR1cm4gdGhpcy5zbGlkaW5nPSExO3ZhciBqPWZbMF0saz1hLkV2ZW50KFwic2xpZGUuYnMuY2Fyb3VzZWxcIix7cmVsYXRlZFRhcmdldDpqLGRpcmVjdGlvbjpofSk7aWYodGhpcy4kZWxlbWVudC50cmlnZ2VyKGspLCFrLmlzRGVmYXVsdFByZXZlbnRlZCgpKXtpZih0aGlzLnNsaWRpbmc9ITAsZyYmdGhpcy5wYXVzZSgpLHRoaXMuJGluZGljYXRvcnMubGVuZ3RoKXt0aGlzLiRpbmRpY2F0b3JzLmZpbmQoXCIuYWN0aXZlXCIpLnJlbW92ZUNsYXNzKFwiYWN0aXZlXCIpO3ZhciBsPWEodGhpcy4kaW5kaWNhdG9ycy5jaGlsZHJlbigpW3RoaXMuZ2V0SXRlbUluZGV4KGYpXSk7bCYmbC5hZGRDbGFzcyhcImFjdGl2ZVwiKX12YXIgbT1hLkV2ZW50KFwic2xpZC5icy5jYXJvdXNlbFwiLHtyZWxhdGVkVGFyZ2V0OmosZGlyZWN0aW9uOmh9KTtyZXR1cm4gYS5zdXBwb3J0LnRyYW5zaXRpb24mJnRoaXMuJGVsZW1lbnQuaGFzQ2xhc3MoXCJzbGlkZVwiKT8oZi5hZGRDbGFzcyhiKSxmWzBdLm9mZnNldFdpZHRoLGUuYWRkQ2xhc3MoaCksZi5hZGRDbGFzcyhoKSxlLm9uZShcImJzVHJhbnNpdGlvbkVuZFwiLGZ1bmN0aW9uKCl7Zi5yZW1vdmVDbGFzcyhbYixoXS5qb2luKFwiIFwiKSkuYWRkQ2xhc3MoXCJhY3RpdmVcIiksZS5yZW1vdmVDbGFzcyhbXCJhY3RpdmVcIixoXS5qb2luKFwiIFwiKSksaS5zbGlkaW5nPSExLHNldFRpbWVvdXQoZnVuY3Rpb24oKXtpLiRlbGVtZW50LnRyaWdnZXIobSl9LDApfSkuZW11bGF0ZVRyYW5zaXRpb25FbmQoYy5UUkFOU0lUSU9OX0RVUkFUSU9OKSk6KGUucmVtb3ZlQ2xhc3MoXCJhY3RpdmVcIiksZi5hZGRDbGFzcyhcImFjdGl2ZVwiKSx0aGlzLnNsaWRpbmc9ITEsdGhpcy4kZWxlbWVudC50cmlnZ2VyKG0pKSxnJiZ0aGlzLmN5Y2xlKCksdGhpc319O3ZhciBkPWEuZm4uY2Fyb3VzZWw7YS5mbi5jYXJvdXNlbD1iLGEuZm4uY2Fyb3VzZWwuQ29uc3RydWN0b3I9YyxhLmZuLmNhcm91c2VsLm5vQ29uZmxpY3Q9ZnVuY3Rpb24oKXtyZXR1cm4gYS5mbi5jYXJvdXNlbD1kLHRoaXN9O3ZhciBlPWZ1bmN0aW9uKGMpe3ZhciBkLGU9YSh0aGlzKSxmPWEoZS5hdHRyKFwiZGF0YS10YXJnZXRcIil8fChkPWUuYXR0cihcImhyZWZcIikpJiZkLnJlcGxhY2UoLy4qKD89I1teXFxzXSskKS8sXCJcIikpO2lmKGYuaGFzQ2xhc3MoXCJjYXJvdXNlbFwiKSl7dmFyIGc9YS5leHRlbmQoe30sZi5kYXRhKCksZS5kYXRhKCkpLGg9ZS5hdHRyKFwiZGF0YS1zbGlkZS10b1wiKTtoJiYoZy5pbnRlcnZhbD0hMSksYi5jYWxsKGYsZyksaCYmZi5kYXRhKFwiYnMuY2Fyb3VzZWxcIikudG8oaCksYy5wcmV2ZW50RGVmYXVsdCgpfX07YShkb2N1bWVudCkub24oXCJjbGljay5icy5jYXJvdXNlbC5kYXRhLWFwaVwiLFwiW2RhdGEtc2xpZGVdXCIsZSkub24oXCJjbGljay5icy5jYXJvdXNlbC5kYXRhLWFwaVwiLFwiW2RhdGEtc2xpZGUtdG9dXCIsZSksYSh3aW5kb3cpLm9uKFwibG9hZFwiLGZ1bmN0aW9uKCl7YSgnW2RhdGEtcmlkZT1cImNhcm91c2VsXCJdJykuZWFjaChmdW5jdGlvbigpe3ZhciBjPWEodGhpcyk7Yi5jYWxsKGMsYy5kYXRhKCkpfSl9KX0oalF1ZXJ5KSwrZnVuY3Rpb24oYSl7XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gYihiKXt2YXIgYyxkPWIuYXR0cihcImRhdGEtdGFyZ2V0XCIpfHwoYz1iLmF0dHIoXCJocmVmXCIpKSYmYy5yZXBsYWNlKC8uKig/PSNbXlxcc10rJCkvLFwiXCIpO3JldHVybiBhKGQpfWZ1bmN0aW9uIGMoYil7cmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpe3ZhciBjPWEodGhpcyksZT1jLmRhdGEoXCJicy5jb2xsYXBzZVwiKSxmPWEuZXh0ZW5kKHt9LGQuREVGQVVMVFMsYy5kYXRhKCksXCJvYmplY3RcIj09dHlwZW9mIGImJmIpOyFlJiZmLnRvZ2dsZSYmL3Nob3d8aGlkZS8udGVzdChiKSYmKGYudG9nZ2xlPSExKSxlfHxjLmRhdGEoXCJicy5jb2xsYXBzZVwiLGU9bmV3IGQodGhpcyxmKSksXCJzdHJpbmdcIj09dHlwZW9mIGImJmVbYl0oKX0pfXZhciBkPWZ1bmN0aW9uKGIsYyl7dGhpcy4kZWxlbWVudD1hKGIpLHRoaXMub3B0aW9ucz1hLmV4dGVuZCh7fSxkLkRFRkFVTFRTLGMpLHRoaXMuJHRyaWdnZXI9YSgnW2RhdGEtdG9nZ2xlPVwiY29sbGFwc2VcIl1baHJlZj1cIiMnK2IuaWQrJ1wiXSxbZGF0YS10b2dnbGU9XCJjb2xsYXBzZVwiXVtkYXRhLXRhcmdldD1cIiMnK2IuaWQrJ1wiXScpLHRoaXMudHJhbnNpdGlvbmluZz1udWxsLHRoaXMub3B0aW9ucy5wYXJlbnQ/dGhpcy4kcGFyZW50PXRoaXMuZ2V0UGFyZW50KCk6dGhpcy5hZGRBcmlhQW5kQ29sbGFwc2VkQ2xhc3ModGhpcy4kZWxlbWVudCx0aGlzLiR0cmlnZ2VyKSx0aGlzLm9wdGlvbnMudG9nZ2xlJiZ0aGlzLnRvZ2dsZSgpfTtkLlZFUlNJT049XCIzLjMuNlwiLGQuVFJBTlNJVElPTl9EVVJBVElPTj0zNTAsZC5ERUZBVUxUUz17dG9nZ2xlOiEwfSxkLnByb3RvdHlwZS5kaW1lbnNpb249ZnVuY3Rpb24oKXt2YXIgYT10aGlzLiRlbGVtZW50Lmhhc0NsYXNzKFwid2lkdGhcIik7cmV0dXJuIGE/XCJ3aWR0aFwiOlwiaGVpZ2h0XCJ9LGQucHJvdG90eXBlLnNob3c9ZnVuY3Rpb24oKXtpZighdGhpcy50cmFuc2l0aW9uaW5nJiYhdGhpcy4kZWxlbWVudC5oYXNDbGFzcyhcImluXCIpKXt2YXIgYixlPXRoaXMuJHBhcmVudCYmdGhpcy4kcGFyZW50LmNoaWxkcmVuKFwiLnBhbmVsXCIpLmNoaWxkcmVuKFwiLmluLCAuY29sbGFwc2luZ1wiKTtpZighKGUmJmUubGVuZ3RoJiYoYj1lLmRhdGEoXCJicy5jb2xsYXBzZVwiKSxiJiZiLnRyYW5zaXRpb25pbmcpKSl7dmFyIGY9YS5FdmVudChcInNob3cuYnMuY29sbGFwc2VcIik7aWYodGhpcy4kZWxlbWVudC50cmlnZ2VyKGYpLCFmLmlzRGVmYXVsdFByZXZlbnRlZCgpKXtlJiZlLmxlbmd0aCYmKGMuY2FsbChlLFwiaGlkZVwiKSxifHxlLmRhdGEoXCJicy5jb2xsYXBzZVwiLG51bGwpKTt2YXIgZz10aGlzLmRpbWVuc2lvbigpO3RoaXMuJGVsZW1lbnQucmVtb3ZlQ2xhc3MoXCJjb2xsYXBzZVwiKS5hZGRDbGFzcyhcImNvbGxhcHNpbmdcIilbZ10oMCkuYXR0cihcImFyaWEtZXhwYW5kZWRcIiwhMCksdGhpcy4kdHJpZ2dlci5yZW1vdmVDbGFzcyhcImNvbGxhcHNlZFwiKS5hdHRyKFwiYXJpYS1leHBhbmRlZFwiLCEwKSx0aGlzLnRyYW5zaXRpb25pbmc9MTt2YXIgaD1mdW5jdGlvbigpe3RoaXMuJGVsZW1lbnQucmVtb3ZlQ2xhc3MoXCJjb2xsYXBzaW5nXCIpLmFkZENsYXNzKFwiY29sbGFwc2UgaW5cIilbZ10oXCJcIiksdGhpcy50cmFuc2l0aW9uaW5nPTAsdGhpcy4kZWxlbWVudC50cmlnZ2VyKFwic2hvd24uYnMuY29sbGFwc2VcIil9O2lmKCFhLnN1cHBvcnQudHJhbnNpdGlvbilyZXR1cm4gaC5jYWxsKHRoaXMpO3ZhciBpPWEuY2FtZWxDYXNlKFtcInNjcm9sbFwiLGddLmpvaW4oXCItXCIpKTt0aGlzLiRlbGVtZW50Lm9uZShcImJzVHJhbnNpdGlvbkVuZFwiLGEucHJveHkoaCx0aGlzKSkuZW11bGF0ZVRyYW5zaXRpb25FbmQoZC5UUkFOU0lUSU9OX0RVUkFUSU9OKVtnXSh0aGlzLiRlbGVtZW50WzBdW2ldKX19fX0sZC5wcm90b3R5cGUuaGlkZT1mdW5jdGlvbigpe2lmKCF0aGlzLnRyYW5zaXRpb25pbmcmJnRoaXMuJGVsZW1lbnQuaGFzQ2xhc3MoXCJpblwiKSl7dmFyIGI9YS5FdmVudChcImhpZGUuYnMuY29sbGFwc2VcIik7aWYodGhpcy4kZWxlbWVudC50cmlnZ2VyKGIpLCFiLmlzRGVmYXVsdFByZXZlbnRlZCgpKXt2YXIgYz10aGlzLmRpbWVuc2lvbigpO3RoaXMuJGVsZW1lbnRbY10odGhpcy4kZWxlbWVudFtjXSgpKVswXS5vZmZzZXRIZWlnaHQsdGhpcy4kZWxlbWVudC5hZGRDbGFzcyhcImNvbGxhcHNpbmdcIikucmVtb3ZlQ2xhc3MoXCJjb2xsYXBzZSBpblwiKS5hdHRyKFwiYXJpYS1leHBhbmRlZFwiLCExKSx0aGlzLiR0cmlnZ2VyLmFkZENsYXNzKFwiY29sbGFwc2VkXCIpLmF0dHIoXCJhcmlhLWV4cGFuZGVkXCIsITEpLHRoaXMudHJhbnNpdGlvbmluZz0xO3ZhciBlPWZ1bmN0aW9uKCl7dGhpcy50cmFuc2l0aW9uaW5nPTAsdGhpcy4kZWxlbWVudC5yZW1vdmVDbGFzcyhcImNvbGxhcHNpbmdcIikuYWRkQ2xhc3MoXCJjb2xsYXBzZVwiKS50cmlnZ2VyKFwiaGlkZGVuLmJzLmNvbGxhcHNlXCIpfTtyZXR1cm4gYS5zdXBwb3J0LnRyYW5zaXRpb24/dm9pZCB0aGlzLiRlbGVtZW50W2NdKDApLm9uZShcImJzVHJhbnNpdGlvbkVuZFwiLGEucHJveHkoZSx0aGlzKSkuZW11bGF0ZVRyYW5zaXRpb25FbmQoZC5UUkFOU0lUSU9OX0RVUkFUSU9OKTplLmNhbGwodGhpcyl9fX0sZC5wcm90b3R5cGUudG9nZ2xlPWZ1bmN0aW9uKCl7dGhpc1t0aGlzLiRlbGVtZW50Lmhhc0NsYXNzKFwiaW5cIik/XCJoaWRlXCI6XCJzaG93XCJdKCl9LGQucHJvdG90eXBlLmdldFBhcmVudD1mdW5jdGlvbigpe3JldHVybiBhKHRoaXMub3B0aW9ucy5wYXJlbnQpLmZpbmQoJ1tkYXRhLXRvZ2dsZT1cImNvbGxhcHNlXCJdW2RhdGEtcGFyZW50PVwiJyt0aGlzLm9wdGlvbnMucGFyZW50KydcIl0nKS5lYWNoKGEucHJveHkoZnVuY3Rpb24oYyxkKXt2YXIgZT1hKGQpO3RoaXMuYWRkQXJpYUFuZENvbGxhcHNlZENsYXNzKGIoZSksZSl9LHRoaXMpKS5lbmQoKX0sZC5wcm90b3R5cGUuYWRkQXJpYUFuZENvbGxhcHNlZENsYXNzPWZ1bmN0aW9uKGEsYil7dmFyIGM9YS5oYXNDbGFzcyhcImluXCIpO2EuYXR0cihcImFyaWEtZXhwYW5kZWRcIixjKSxiLnRvZ2dsZUNsYXNzKFwiY29sbGFwc2VkXCIsIWMpLmF0dHIoXCJhcmlhLWV4cGFuZGVkXCIsYyl9O3ZhciBlPWEuZm4uY29sbGFwc2U7YS5mbi5jb2xsYXBzZT1jLGEuZm4uY29sbGFwc2UuQ29uc3RydWN0b3I9ZCxhLmZuLmNvbGxhcHNlLm5vQ29uZmxpY3Q9ZnVuY3Rpb24oKXtyZXR1cm4gYS5mbi5jb2xsYXBzZT1lLHRoaXN9LGEoZG9jdW1lbnQpLm9uKFwiY2xpY2suYnMuY29sbGFwc2UuZGF0YS1hcGlcIiwnW2RhdGEtdG9nZ2xlPVwiY29sbGFwc2VcIl0nLGZ1bmN0aW9uKGQpe3ZhciBlPWEodGhpcyk7ZS5hdHRyKFwiZGF0YS10YXJnZXRcIil8fGQucHJldmVudERlZmF1bHQoKTt2YXIgZj1iKGUpLGc9Zi5kYXRhKFwiYnMuY29sbGFwc2VcIiksaD1nP1widG9nZ2xlXCI6ZS5kYXRhKCk7Yy5jYWxsKGYsaCl9KX0oalF1ZXJ5KSwrZnVuY3Rpb24oYSl7XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gYihiKXt2YXIgYz1iLmF0dHIoXCJkYXRhLXRhcmdldFwiKTtjfHwoYz1iLmF0dHIoXCJocmVmXCIpLGM9YyYmLyNbQS1aYS16XS8udGVzdChjKSYmYy5yZXBsYWNlKC8uKig/PSNbXlxcc10qJCkvLFwiXCIpKTt2YXIgZD1jJiZhKGMpO3JldHVybiBkJiZkLmxlbmd0aD9kOmIucGFyZW50KCl9ZnVuY3Rpb24gYyhjKXtjJiYzPT09Yy53aGljaHx8KGEoZSkucmVtb3ZlKCksYShmKS5lYWNoKGZ1bmN0aW9uKCl7dmFyIGQ9YSh0aGlzKSxlPWIoZCksZj17cmVsYXRlZFRhcmdldDp0aGlzfTtlLmhhc0NsYXNzKFwib3BlblwiKSYmKGMmJlwiY2xpY2tcIj09Yy50eXBlJiYvaW5wdXR8dGV4dGFyZWEvaS50ZXN0KGMudGFyZ2V0LnRhZ05hbWUpJiZhLmNvbnRhaW5zKGVbMF0sYy50YXJnZXQpfHwoZS50cmlnZ2VyKGM9YS5FdmVudChcImhpZGUuYnMuZHJvcGRvd25cIixmKSksYy5pc0RlZmF1bHRQcmV2ZW50ZWQoKXx8KGQuYXR0cihcImFyaWEtZXhwYW5kZWRcIixcImZhbHNlXCIpLGUucmVtb3ZlQ2xhc3MoXCJvcGVuXCIpLnRyaWdnZXIoYS5FdmVudChcImhpZGRlbi5icy5kcm9wZG93blwiLGYpKSkpKX0pKX1mdW5jdGlvbiBkKGIpe3JldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKXt2YXIgYz1hKHRoaXMpLGQ9Yy5kYXRhKFwiYnMuZHJvcGRvd25cIik7ZHx8Yy5kYXRhKFwiYnMuZHJvcGRvd25cIixkPW5ldyBnKHRoaXMpKSxcInN0cmluZ1wiPT10eXBlb2YgYiYmZFtiXS5jYWxsKGMpfSl9dmFyIGU9XCIuZHJvcGRvd24tYmFja2Ryb3BcIixmPSdbZGF0YS10b2dnbGU9XCJkcm9wZG93blwiXScsZz1mdW5jdGlvbihiKXthKGIpLm9uKFwiY2xpY2suYnMuZHJvcGRvd25cIix0aGlzLnRvZ2dsZSl9O2cuVkVSU0lPTj1cIjMuMy42XCIsZy5wcm90b3R5cGUudG9nZ2xlPWZ1bmN0aW9uKGQpe3ZhciBlPWEodGhpcyk7aWYoIWUuaXMoXCIuZGlzYWJsZWQsIDpkaXNhYmxlZFwiKSl7dmFyIGY9YihlKSxnPWYuaGFzQ2xhc3MoXCJvcGVuXCIpO2lmKGMoKSwhZyl7XCJvbnRvdWNoc3RhcnRcImluIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCYmIWYuY2xvc2VzdChcIi5uYXZiYXItbmF2XCIpLmxlbmd0aCYmYShkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpKS5hZGRDbGFzcyhcImRyb3Bkb3duLWJhY2tkcm9wXCIpLmluc2VydEFmdGVyKGEodGhpcykpLm9uKFwiY2xpY2tcIixjKTt2YXIgaD17cmVsYXRlZFRhcmdldDp0aGlzfTtpZihmLnRyaWdnZXIoZD1hLkV2ZW50KFwic2hvdy5icy5kcm9wZG93blwiLGgpKSxkLmlzRGVmYXVsdFByZXZlbnRlZCgpKXJldHVybjtlLnRyaWdnZXIoXCJmb2N1c1wiKS5hdHRyKFwiYXJpYS1leHBhbmRlZFwiLFwidHJ1ZVwiKSxmLnRvZ2dsZUNsYXNzKFwib3BlblwiKS50cmlnZ2VyKGEuRXZlbnQoXCJzaG93bi5icy5kcm9wZG93blwiLGgpKX1yZXR1cm4hMX19LGcucHJvdG90eXBlLmtleWRvd249ZnVuY3Rpb24oYyl7aWYoLygzOHw0MHwyN3wzMikvLnRlc3QoYy53aGljaCkmJiEvaW5wdXR8dGV4dGFyZWEvaS50ZXN0KGMudGFyZ2V0LnRhZ05hbWUpKXt2YXIgZD1hKHRoaXMpO2lmKGMucHJldmVudERlZmF1bHQoKSxjLnN0b3BQcm9wYWdhdGlvbigpLCFkLmlzKFwiLmRpc2FibGVkLCA6ZGlzYWJsZWRcIikpe3ZhciBlPWIoZCksZz1lLmhhc0NsYXNzKFwib3BlblwiKTtpZighZyYmMjchPWMud2hpY2h8fGcmJjI3PT1jLndoaWNoKXJldHVybiAyNz09Yy53aGljaCYmZS5maW5kKGYpLnRyaWdnZXIoXCJmb2N1c1wiKSxkLnRyaWdnZXIoXCJjbGlja1wiKTt2YXIgaD1cIiBsaTpub3QoLmRpc2FibGVkKTp2aXNpYmxlIGFcIixpPWUuZmluZChcIi5kcm9wZG93bi1tZW51XCIraCk7aWYoaS5sZW5ndGgpe3ZhciBqPWkuaW5kZXgoYy50YXJnZXQpOzM4PT1jLndoaWNoJiZqPjAmJmotLSw0MD09Yy53aGljaCYmajxpLmxlbmd0aC0xJiZqKyssfmp8fChqPTApLGkuZXEoaikudHJpZ2dlcihcImZvY3VzXCIpfX19fTt2YXIgaD1hLmZuLmRyb3Bkb3duO2EuZm4uZHJvcGRvd249ZCxhLmZuLmRyb3Bkb3duLkNvbnN0cnVjdG9yPWcsYS5mbi5kcm9wZG93bi5ub0NvbmZsaWN0PWZ1bmN0aW9uKCl7cmV0dXJuIGEuZm4uZHJvcGRvd249aCx0aGlzfSxhKGRvY3VtZW50KS5vbihcImNsaWNrLmJzLmRyb3Bkb3duLmRhdGEtYXBpXCIsYykub24oXCJjbGljay5icy5kcm9wZG93bi5kYXRhLWFwaVwiLFwiLmRyb3Bkb3duIGZvcm1cIixmdW5jdGlvbihhKXthLnN0b3BQcm9wYWdhdGlvbigpfSkub24oXCJjbGljay5icy5kcm9wZG93bi5kYXRhLWFwaVwiLGYsZy5wcm90b3R5cGUudG9nZ2xlKS5vbihcImtleWRvd24uYnMuZHJvcGRvd24uZGF0YS1hcGlcIixmLGcucHJvdG90eXBlLmtleWRvd24pLm9uKFwia2V5ZG93bi5icy5kcm9wZG93bi5kYXRhLWFwaVwiLFwiLmRyb3Bkb3duLW1lbnVcIixnLnByb3RvdHlwZS5rZXlkb3duKX0oalF1ZXJ5KSwrZnVuY3Rpb24oYSl7XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gYihiLGQpe3JldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKXt2YXIgZT1hKHRoaXMpLGY9ZS5kYXRhKFwiYnMubW9kYWxcIiksZz1hLmV4dGVuZCh7fSxjLkRFRkFVTFRTLGUuZGF0YSgpLFwib2JqZWN0XCI9PXR5cGVvZiBiJiZiKTtmfHxlLmRhdGEoXCJicy5tb2RhbFwiLGY9bmV3IGModGhpcyxnKSksXCJzdHJpbmdcIj09dHlwZW9mIGI/ZltiXShkKTpnLnNob3cmJmYuc2hvdyhkKX0pfXZhciBjPWZ1bmN0aW9uKGIsYyl7dGhpcy5vcHRpb25zPWMsdGhpcy4kYm9keT1hKGRvY3VtZW50LmJvZHkpLHRoaXMuJGVsZW1lbnQ9YShiKSx0aGlzLiRkaWFsb2c9dGhpcy4kZWxlbWVudC5maW5kKFwiLm1vZGFsLWRpYWxvZ1wiKSx0aGlzLiRiYWNrZHJvcD1udWxsLHRoaXMuaXNTaG93bj1udWxsLHRoaXMub3JpZ2luYWxCb2R5UGFkPW51bGwsdGhpcy5zY3JvbGxiYXJXaWR0aD0wLHRoaXMuaWdub3JlQmFja2Ryb3BDbGljaz0hMSx0aGlzLm9wdGlvbnMucmVtb3RlJiZ0aGlzLiRlbGVtZW50LmZpbmQoXCIubW9kYWwtY29udGVudFwiKS5sb2FkKHRoaXMub3B0aW9ucy5yZW1vdGUsYS5wcm94eShmdW5jdGlvbigpe3RoaXMuJGVsZW1lbnQudHJpZ2dlcihcImxvYWRlZC5icy5tb2RhbFwiKX0sdGhpcykpfTtjLlZFUlNJT049XCIzLjMuNlwiLGMuVFJBTlNJVElPTl9EVVJBVElPTj0zMDAsYy5CQUNLRFJPUF9UUkFOU0lUSU9OX0RVUkFUSU9OPTE1MCxjLkRFRkFVTFRTPXtiYWNrZHJvcDohMCxrZXlib2FyZDohMCxzaG93OiEwfSxjLnByb3RvdHlwZS50b2dnbGU9ZnVuY3Rpb24oYSl7cmV0dXJuIHRoaXMuaXNTaG93bj90aGlzLmhpZGUoKTp0aGlzLnNob3coYSl9LGMucHJvdG90eXBlLnNob3c9ZnVuY3Rpb24oYil7dmFyIGQ9dGhpcyxlPWEuRXZlbnQoXCJzaG93LmJzLm1vZGFsXCIse3JlbGF0ZWRUYXJnZXQ6Yn0pO3RoaXMuJGVsZW1lbnQudHJpZ2dlcihlKSx0aGlzLmlzU2hvd258fGUuaXNEZWZhdWx0UHJldmVudGVkKCl8fCh0aGlzLmlzU2hvd249ITAsdGhpcy5jaGVja1Njcm9sbGJhcigpLHRoaXMuc2V0U2Nyb2xsYmFyKCksdGhpcy4kYm9keS5hZGRDbGFzcyhcIm1vZGFsLW9wZW5cIiksdGhpcy5lc2NhcGUoKSx0aGlzLnJlc2l6ZSgpLHRoaXMuJGVsZW1lbnQub24oXCJjbGljay5kaXNtaXNzLmJzLm1vZGFsXCIsJ1tkYXRhLWRpc21pc3M9XCJtb2RhbFwiXScsYS5wcm94eSh0aGlzLmhpZGUsdGhpcykpLHRoaXMuJGRpYWxvZy5vbihcIm1vdXNlZG93bi5kaXNtaXNzLmJzLm1vZGFsXCIsZnVuY3Rpb24oKXtkLiRlbGVtZW50Lm9uZShcIm1vdXNldXAuZGlzbWlzcy5icy5tb2RhbFwiLGZ1bmN0aW9uKGIpe2EoYi50YXJnZXQpLmlzKGQuJGVsZW1lbnQpJiYoZC5pZ25vcmVCYWNrZHJvcENsaWNrPSEwKX0pfSksdGhpcy5iYWNrZHJvcChmdW5jdGlvbigpe3ZhciBlPWEuc3VwcG9ydC50cmFuc2l0aW9uJiZkLiRlbGVtZW50Lmhhc0NsYXNzKFwiZmFkZVwiKTtkLiRlbGVtZW50LnBhcmVudCgpLmxlbmd0aHx8ZC4kZWxlbWVudC5hcHBlbmRUbyhkLiRib2R5KSxkLiRlbGVtZW50LnNob3coKS5zY3JvbGxUb3AoMCksZC5hZGp1c3REaWFsb2coKSxlJiZkLiRlbGVtZW50WzBdLm9mZnNldFdpZHRoLGQuJGVsZW1lbnQuYWRkQ2xhc3MoXCJpblwiKSxkLmVuZm9yY2VGb2N1cygpO3ZhciBmPWEuRXZlbnQoXCJzaG93bi5icy5tb2RhbFwiLHtyZWxhdGVkVGFyZ2V0OmJ9KTtlP2QuJGRpYWxvZy5vbmUoXCJic1RyYW5zaXRpb25FbmRcIixmdW5jdGlvbigpe2QuJGVsZW1lbnQudHJpZ2dlcihcImZvY3VzXCIpLnRyaWdnZXIoZil9KS5lbXVsYXRlVHJhbnNpdGlvbkVuZChjLlRSQU5TSVRJT05fRFVSQVRJT04pOmQuJGVsZW1lbnQudHJpZ2dlcihcImZvY3VzXCIpLnRyaWdnZXIoZil9KSl9LGMucHJvdG90eXBlLmhpZGU9ZnVuY3Rpb24oYil7YiYmYi5wcmV2ZW50RGVmYXVsdCgpLGI9YS5FdmVudChcImhpZGUuYnMubW9kYWxcIiksdGhpcy4kZWxlbWVudC50cmlnZ2VyKGIpLHRoaXMuaXNTaG93biYmIWIuaXNEZWZhdWx0UHJldmVudGVkKCkmJih0aGlzLmlzU2hvd249ITEsdGhpcy5lc2NhcGUoKSx0aGlzLnJlc2l6ZSgpLGEoZG9jdW1lbnQpLm9mZihcImZvY3VzaW4uYnMubW9kYWxcIiksdGhpcy4kZWxlbWVudC5yZW1vdmVDbGFzcyhcImluXCIpLm9mZihcImNsaWNrLmRpc21pc3MuYnMubW9kYWxcIikub2ZmKFwibW91c2V1cC5kaXNtaXNzLmJzLm1vZGFsXCIpLHRoaXMuJGRpYWxvZy5vZmYoXCJtb3VzZWRvd24uZGlzbWlzcy5icy5tb2RhbFwiKSxhLnN1cHBvcnQudHJhbnNpdGlvbiYmdGhpcy4kZWxlbWVudC5oYXNDbGFzcyhcImZhZGVcIik/dGhpcy4kZWxlbWVudC5vbmUoXCJic1RyYW5zaXRpb25FbmRcIixhLnByb3h5KHRoaXMuaGlkZU1vZGFsLHRoaXMpKS5lbXVsYXRlVHJhbnNpdGlvbkVuZChjLlRSQU5TSVRJT05fRFVSQVRJT04pOnRoaXMuaGlkZU1vZGFsKCkpfSxjLnByb3RvdHlwZS5lbmZvcmNlRm9jdXM9ZnVuY3Rpb24oKXthKGRvY3VtZW50KS5vZmYoXCJmb2N1c2luLmJzLm1vZGFsXCIpLm9uKFwiZm9jdXNpbi5icy5tb2RhbFwiLGEucHJveHkoZnVuY3Rpb24oYSl7dGhpcy4kZWxlbWVudFswXT09PWEudGFyZ2V0fHx0aGlzLiRlbGVtZW50LmhhcyhhLnRhcmdldCkubGVuZ3RofHx0aGlzLiRlbGVtZW50LnRyaWdnZXIoXCJmb2N1c1wiKX0sdGhpcykpfSxjLnByb3RvdHlwZS5lc2NhcGU9ZnVuY3Rpb24oKXt0aGlzLmlzU2hvd24mJnRoaXMub3B0aW9ucy5rZXlib2FyZD90aGlzLiRlbGVtZW50Lm9uKFwia2V5ZG93bi5kaXNtaXNzLmJzLm1vZGFsXCIsYS5wcm94eShmdW5jdGlvbihhKXsyNz09YS53aGljaCYmdGhpcy5oaWRlKCl9LHRoaXMpKTp0aGlzLmlzU2hvd258fHRoaXMuJGVsZW1lbnQub2ZmKFwia2V5ZG93bi5kaXNtaXNzLmJzLm1vZGFsXCIpfSxjLnByb3RvdHlwZS5yZXNpemU9ZnVuY3Rpb24oKXt0aGlzLmlzU2hvd24/YSh3aW5kb3cpLm9uKFwicmVzaXplLmJzLm1vZGFsXCIsYS5wcm94eSh0aGlzLmhhbmRsZVVwZGF0ZSx0aGlzKSk6YSh3aW5kb3cpLm9mZihcInJlc2l6ZS5icy5tb2RhbFwiKX0sYy5wcm90b3R5cGUuaGlkZU1vZGFsPWZ1bmN0aW9uKCl7dmFyIGE9dGhpczt0aGlzLiRlbGVtZW50LmhpZGUoKSx0aGlzLmJhY2tkcm9wKGZ1bmN0aW9uKCl7YS4kYm9keS5yZW1vdmVDbGFzcyhcIm1vZGFsLW9wZW5cIiksYS5yZXNldEFkanVzdG1lbnRzKCksYS5yZXNldFNjcm9sbGJhcigpLGEuJGVsZW1lbnQudHJpZ2dlcihcImhpZGRlbi5icy5tb2RhbFwiKX0pfSxjLnByb3RvdHlwZS5yZW1vdmVCYWNrZHJvcD1mdW5jdGlvbigpe3RoaXMuJGJhY2tkcm9wJiZ0aGlzLiRiYWNrZHJvcC5yZW1vdmUoKSx0aGlzLiRiYWNrZHJvcD1udWxsfSxjLnByb3RvdHlwZS5iYWNrZHJvcD1mdW5jdGlvbihiKXt2YXIgZD10aGlzLGU9dGhpcy4kZWxlbWVudC5oYXNDbGFzcyhcImZhZGVcIik/XCJmYWRlXCI6XCJcIjtpZih0aGlzLmlzU2hvd24mJnRoaXMub3B0aW9ucy5iYWNrZHJvcCl7dmFyIGY9YS5zdXBwb3J0LnRyYW5zaXRpb24mJmU7aWYodGhpcy4kYmFja2Ryb3A9YShkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpKS5hZGRDbGFzcyhcIm1vZGFsLWJhY2tkcm9wIFwiK2UpLmFwcGVuZFRvKHRoaXMuJGJvZHkpLHRoaXMuJGVsZW1lbnQub24oXCJjbGljay5kaXNtaXNzLmJzLm1vZGFsXCIsYS5wcm94eShmdW5jdGlvbihhKXtyZXR1cm4gdGhpcy5pZ25vcmVCYWNrZHJvcENsaWNrP3ZvaWQodGhpcy5pZ25vcmVCYWNrZHJvcENsaWNrPSExKTp2b2lkKGEudGFyZ2V0PT09YS5jdXJyZW50VGFyZ2V0JiYoXCJzdGF0aWNcIj09dGhpcy5vcHRpb25zLmJhY2tkcm9wP3RoaXMuJGVsZW1lbnRbMF0uZm9jdXMoKTp0aGlzLmhpZGUoKSkpfSx0aGlzKSksZiYmdGhpcy4kYmFja2Ryb3BbMF0ub2Zmc2V0V2lkdGgsdGhpcy4kYmFja2Ryb3AuYWRkQ2xhc3MoXCJpblwiKSwhYilyZXR1cm47Zj90aGlzLiRiYWNrZHJvcC5vbmUoXCJic1RyYW5zaXRpb25FbmRcIixiKS5lbXVsYXRlVHJhbnNpdGlvbkVuZChjLkJBQ0tEUk9QX1RSQU5TSVRJT05fRFVSQVRJT04pOmIoKX1lbHNlIGlmKCF0aGlzLmlzU2hvd24mJnRoaXMuJGJhY2tkcm9wKXt0aGlzLiRiYWNrZHJvcC5yZW1vdmVDbGFzcyhcImluXCIpO3ZhciBnPWZ1bmN0aW9uKCl7ZC5yZW1vdmVCYWNrZHJvcCgpLGImJmIoKX07YS5zdXBwb3J0LnRyYW5zaXRpb24mJnRoaXMuJGVsZW1lbnQuaGFzQ2xhc3MoXCJmYWRlXCIpP3RoaXMuJGJhY2tkcm9wLm9uZShcImJzVHJhbnNpdGlvbkVuZFwiLGcpLmVtdWxhdGVUcmFuc2l0aW9uRW5kKGMuQkFDS0RST1BfVFJBTlNJVElPTl9EVVJBVElPTik6ZygpfWVsc2UgYiYmYigpfSxjLnByb3RvdHlwZS5oYW5kbGVVcGRhdGU9ZnVuY3Rpb24oKXt0aGlzLmFkanVzdERpYWxvZygpfSxjLnByb3RvdHlwZS5hZGp1c3REaWFsb2c9ZnVuY3Rpb24oKXt2YXIgYT10aGlzLiRlbGVtZW50WzBdLnNjcm9sbEhlaWdodD5kb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50SGVpZ2h0O3RoaXMuJGVsZW1lbnQuY3NzKHtwYWRkaW5nTGVmdDohdGhpcy5ib2R5SXNPdmVyZmxvd2luZyYmYT90aGlzLnNjcm9sbGJhcldpZHRoOlwiXCIscGFkZGluZ1JpZ2h0OnRoaXMuYm9keUlzT3ZlcmZsb3dpbmcmJiFhP3RoaXMuc2Nyb2xsYmFyV2lkdGg6XCJcIn0pfSxjLnByb3RvdHlwZS5yZXNldEFkanVzdG1lbnRzPWZ1bmN0aW9uKCl7dGhpcy4kZWxlbWVudC5jc3Moe3BhZGRpbmdMZWZ0OlwiXCIscGFkZGluZ1JpZ2h0OlwiXCJ9KX0sYy5wcm90b3R5cGUuY2hlY2tTY3JvbGxiYXI9ZnVuY3Rpb24oKXt2YXIgYT13aW5kb3cuaW5uZXJXaWR0aDtpZighYSl7dmFyIGI9ZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO2E9Yi5yaWdodC1NYXRoLmFicyhiLmxlZnQpfXRoaXMuYm9keUlzT3ZlcmZsb3dpbmc9ZG9jdW1lbnQuYm9keS5jbGllbnRXaWR0aDxhLHRoaXMuc2Nyb2xsYmFyV2lkdGg9dGhpcy5tZWFzdXJlU2Nyb2xsYmFyKCl9LGMucHJvdG90eXBlLnNldFNjcm9sbGJhcj1mdW5jdGlvbigpe3ZhciBhPXBhcnNlSW50KHRoaXMuJGJvZHkuY3NzKFwicGFkZGluZy1yaWdodFwiKXx8MCwxMCk7dGhpcy5vcmlnaW5hbEJvZHlQYWQ9ZG9jdW1lbnQuYm9keS5zdHlsZS5wYWRkaW5nUmlnaHR8fFwiXCIsdGhpcy5ib2R5SXNPdmVyZmxvd2luZyYmdGhpcy4kYm9keS5jc3MoXCJwYWRkaW5nLXJpZ2h0XCIsYSt0aGlzLnNjcm9sbGJhcldpZHRoKX0sYy5wcm90b3R5cGUucmVzZXRTY3JvbGxiYXI9ZnVuY3Rpb24oKXt0aGlzLiRib2R5LmNzcyhcInBhZGRpbmctcmlnaHRcIix0aGlzLm9yaWdpbmFsQm9keVBhZCl9LGMucHJvdG90eXBlLm1lYXN1cmVTY3JvbGxiYXI9ZnVuY3Rpb24oKXt2YXIgYT1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO2EuY2xhc3NOYW1lPVwibW9kYWwtc2Nyb2xsYmFyLW1lYXN1cmVcIix0aGlzLiRib2R5LmFwcGVuZChhKTt2YXIgYj1hLm9mZnNldFdpZHRoLWEuY2xpZW50V2lkdGg7cmV0dXJuIHRoaXMuJGJvZHlbMF0ucmVtb3ZlQ2hpbGQoYSksYn07dmFyIGQ9YS5mbi5tb2RhbDthLmZuLm1vZGFsPWIsYS5mbi5tb2RhbC5Db25zdHJ1Y3Rvcj1jLGEuZm4ubW9kYWwubm9Db25mbGljdD1mdW5jdGlvbigpe3JldHVybiBhLmZuLm1vZGFsPWQsdGhpc30sYShkb2N1bWVudCkub24oXCJjbGljay5icy5tb2RhbC5kYXRhLWFwaVwiLCdbZGF0YS10b2dnbGU9XCJtb2RhbFwiXScsZnVuY3Rpb24oYyl7dmFyIGQ9YSh0aGlzKSxlPWQuYXR0cihcImhyZWZcIiksZj1hKGQuYXR0cihcImRhdGEtdGFyZ2V0XCIpfHxlJiZlLnJlcGxhY2UoLy4qKD89I1teXFxzXSskKS8sXCJcIikpLGc9Zi5kYXRhKFwiYnMubW9kYWxcIik/XCJ0b2dnbGVcIjphLmV4dGVuZCh7cmVtb3RlOiEvIy8udGVzdChlKSYmZX0sZi5kYXRhKCksZC5kYXRhKCkpO2QuaXMoXCJhXCIpJiZjLnByZXZlbnREZWZhdWx0KCksZi5vbmUoXCJzaG93LmJzLm1vZGFsXCIsZnVuY3Rpb24oYSl7YS5pc0RlZmF1bHRQcmV2ZW50ZWQoKXx8Zi5vbmUoXCJoaWRkZW4uYnMubW9kYWxcIixmdW5jdGlvbigpe2QuaXMoXCI6dmlzaWJsZVwiKSYmZC50cmlnZ2VyKFwiZm9jdXNcIil9KX0pLGIuY2FsbChmLGcsdGhpcyl9KX0oalF1ZXJ5KSwrZnVuY3Rpb24oYSl7XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gYihiKXtyZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCl7dmFyIGQ9YSh0aGlzKSxlPWQuZGF0YShcImJzLnRvb2x0aXBcIiksZj1cIm9iamVjdFwiPT10eXBlb2YgYiYmYjsoZXx8IS9kZXN0cm95fGhpZGUvLnRlc3QoYikpJiYoZXx8ZC5kYXRhKFwiYnMudG9vbHRpcFwiLGU9bmV3IGModGhpcyxmKSksXCJzdHJpbmdcIj09dHlwZW9mIGImJmVbYl0oKSl9KX12YXIgYz1mdW5jdGlvbihhLGIpe3RoaXMudHlwZT1udWxsLHRoaXMub3B0aW9ucz1udWxsLHRoaXMuZW5hYmxlZD1udWxsLHRoaXMudGltZW91dD1udWxsLHRoaXMuaG92ZXJTdGF0ZT1udWxsLHRoaXMuJGVsZW1lbnQ9bnVsbCx0aGlzLmluU3RhdGU9bnVsbCx0aGlzLmluaXQoXCJ0b29sdGlwXCIsYSxiKX07Yy5WRVJTSU9OPVwiMy4zLjZcIixjLlRSQU5TSVRJT05fRFVSQVRJT049MTUwLGMuREVGQVVMVFM9e2FuaW1hdGlvbjohMCxwbGFjZW1lbnQ6XCJ0b3BcIixzZWxlY3RvcjohMSx0ZW1wbGF0ZTonPGRpdiBjbGFzcz1cInRvb2x0aXBcIiByb2xlPVwidG9vbHRpcFwiPjxkaXYgY2xhc3M9XCJ0b29sdGlwLWFycm93XCI+PC9kaXY+PGRpdiBjbGFzcz1cInRvb2x0aXAtaW5uZXJcIj48L2Rpdj48L2Rpdj4nLHRyaWdnZXI6XCJob3ZlciBmb2N1c1wiLHRpdGxlOlwiXCIsZGVsYXk6MCxodG1sOiExLGNvbnRhaW5lcjohMSx2aWV3cG9ydDp7c2VsZWN0b3I6XCJib2R5XCIscGFkZGluZzowfX0sYy5wcm90b3R5cGUuaW5pdD1mdW5jdGlvbihiLGMsZCl7aWYodGhpcy5lbmFibGVkPSEwLHRoaXMudHlwZT1iLHRoaXMuJGVsZW1lbnQ9YShjKSx0aGlzLm9wdGlvbnM9dGhpcy5nZXRPcHRpb25zKGQpLHRoaXMuJHZpZXdwb3J0PXRoaXMub3B0aW9ucy52aWV3cG9ydCYmYShhLmlzRnVuY3Rpb24odGhpcy5vcHRpb25zLnZpZXdwb3J0KT90aGlzLm9wdGlvbnMudmlld3BvcnQuY2FsbCh0aGlzLHRoaXMuJGVsZW1lbnQpOnRoaXMub3B0aW9ucy52aWV3cG9ydC5zZWxlY3Rvcnx8dGhpcy5vcHRpb25zLnZpZXdwb3J0KSx0aGlzLmluU3RhdGU9e2NsaWNrOiExLGhvdmVyOiExLGZvY3VzOiExfSx0aGlzLiRlbGVtZW50WzBdaW5zdGFuY2VvZiBkb2N1bWVudC5jb25zdHJ1Y3RvciYmIXRoaXMub3B0aW9ucy5zZWxlY3Rvcil0aHJvdyBuZXcgRXJyb3IoXCJgc2VsZWN0b3JgIG9wdGlvbiBtdXN0IGJlIHNwZWNpZmllZCB3aGVuIGluaXRpYWxpemluZyBcIit0aGlzLnR5cGUrXCIgb24gdGhlIHdpbmRvdy5kb2N1bWVudCBvYmplY3QhXCIpO2Zvcih2YXIgZT10aGlzLm9wdGlvbnMudHJpZ2dlci5zcGxpdChcIiBcIiksZj1lLmxlbmd0aDtmLS07KXt2YXIgZz1lW2ZdO2lmKFwiY2xpY2tcIj09Zyl0aGlzLiRlbGVtZW50Lm9uKFwiY2xpY2suXCIrdGhpcy50eXBlLHRoaXMub3B0aW9ucy5zZWxlY3RvcixhLnByb3h5KHRoaXMudG9nZ2xlLHRoaXMpKTtlbHNlIGlmKFwibWFudWFsXCIhPWcpe3ZhciBoPVwiaG92ZXJcIj09Zz9cIm1vdXNlZW50ZXJcIjpcImZvY3VzaW5cIixpPVwiaG92ZXJcIj09Zz9cIm1vdXNlbGVhdmVcIjpcImZvY3Vzb3V0XCI7dGhpcy4kZWxlbWVudC5vbihoK1wiLlwiK3RoaXMudHlwZSx0aGlzLm9wdGlvbnMuc2VsZWN0b3IsYS5wcm94eSh0aGlzLmVudGVyLHRoaXMpKSx0aGlzLiRlbGVtZW50Lm9uKGkrXCIuXCIrdGhpcy50eXBlLHRoaXMub3B0aW9ucy5zZWxlY3RvcixhLnByb3h5KHRoaXMubGVhdmUsdGhpcykpfX10aGlzLm9wdGlvbnMuc2VsZWN0b3I/dGhpcy5fb3B0aW9ucz1hLmV4dGVuZCh7fSx0aGlzLm9wdGlvbnMse3RyaWdnZXI6XCJtYW51YWxcIixzZWxlY3RvcjpcIlwifSk6dGhpcy5maXhUaXRsZSgpfSxjLnByb3RvdHlwZS5nZXREZWZhdWx0cz1mdW5jdGlvbigpe3JldHVybiBjLkRFRkFVTFRTfSxjLnByb3RvdHlwZS5nZXRPcHRpb25zPWZ1bmN0aW9uKGIpe3JldHVybiBiPWEuZXh0ZW5kKHt9LHRoaXMuZ2V0RGVmYXVsdHMoKSx0aGlzLiRlbGVtZW50LmRhdGEoKSxiKSxiLmRlbGF5JiZcIm51bWJlclwiPT10eXBlb2YgYi5kZWxheSYmKGIuZGVsYXk9e3Nob3c6Yi5kZWxheSxoaWRlOmIuZGVsYXl9KSxifSxjLnByb3RvdHlwZS5nZXREZWxlZ2F0ZU9wdGlvbnM9ZnVuY3Rpb24oKXt2YXIgYj17fSxjPXRoaXMuZ2V0RGVmYXVsdHMoKTtyZXR1cm4gdGhpcy5fb3B0aW9ucyYmYS5lYWNoKHRoaXMuX29wdGlvbnMsZnVuY3Rpb24oYSxkKXtjW2FdIT1kJiYoYlthXT1kKX0pLGJ9LGMucHJvdG90eXBlLmVudGVyPWZ1bmN0aW9uKGIpe3ZhciBjPWIgaW5zdGFuY2VvZiB0aGlzLmNvbnN0cnVjdG9yP2I6YShiLmN1cnJlbnRUYXJnZXQpLmRhdGEoXCJicy5cIit0aGlzLnR5cGUpO3JldHVybiBjfHwoYz1uZXcgdGhpcy5jb25zdHJ1Y3RvcihiLmN1cnJlbnRUYXJnZXQsdGhpcy5nZXREZWxlZ2F0ZU9wdGlvbnMoKSksYShiLmN1cnJlbnRUYXJnZXQpLmRhdGEoXCJicy5cIit0aGlzLnR5cGUsYykpLGIgaW5zdGFuY2VvZiBhLkV2ZW50JiYoYy5pblN0YXRlW1wiZm9jdXNpblwiPT1iLnR5cGU/XCJmb2N1c1wiOlwiaG92ZXJcIl09ITApLGMudGlwKCkuaGFzQ2xhc3MoXCJpblwiKXx8XCJpblwiPT1jLmhvdmVyU3RhdGU/dm9pZChjLmhvdmVyU3RhdGU9XCJpblwiKTooY2xlYXJUaW1lb3V0KGMudGltZW91dCksYy5ob3ZlclN0YXRlPVwiaW5cIixjLm9wdGlvbnMuZGVsYXkmJmMub3B0aW9ucy5kZWxheS5zaG93P3ZvaWQoYy50aW1lb3V0PXNldFRpbWVvdXQoZnVuY3Rpb24oKXtcImluXCI9PWMuaG92ZXJTdGF0ZSYmYy5zaG93KCl9LGMub3B0aW9ucy5kZWxheS5zaG93KSk6Yy5zaG93KCkpfSxjLnByb3RvdHlwZS5pc0luU3RhdGVUcnVlPWZ1bmN0aW9uKCl7Zm9yKHZhciBhIGluIHRoaXMuaW5TdGF0ZSlpZih0aGlzLmluU3RhdGVbYV0pcmV0dXJuITA7cmV0dXJuITF9LGMucHJvdG90eXBlLmxlYXZlPWZ1bmN0aW9uKGIpe3ZhciBjPWIgaW5zdGFuY2VvZiB0aGlzLmNvbnN0cnVjdG9yP2I6YShiLmN1cnJlbnRUYXJnZXQpLmRhdGEoXCJicy5cIit0aGlzLnR5cGUpO3JldHVybiBjfHwoYz1uZXcgdGhpcy5jb25zdHJ1Y3RvcihiLmN1cnJlbnRUYXJnZXQsdGhpcy5nZXREZWxlZ2F0ZU9wdGlvbnMoKSksYShiLmN1cnJlbnRUYXJnZXQpLmRhdGEoXCJicy5cIit0aGlzLnR5cGUsYykpLGIgaW5zdGFuY2VvZiBhLkV2ZW50JiYoYy5pblN0YXRlW1wiZm9jdXNvdXRcIj09Yi50eXBlP1wiZm9jdXNcIjpcImhvdmVyXCJdPSExKSxjLmlzSW5TdGF0ZVRydWUoKT92b2lkIDA6KGNsZWFyVGltZW91dChjLnRpbWVvdXQpLGMuaG92ZXJTdGF0ZT1cIm91dFwiLGMub3B0aW9ucy5kZWxheSYmYy5vcHRpb25zLmRlbGF5LmhpZGU/dm9pZChjLnRpbWVvdXQ9c2V0VGltZW91dChmdW5jdGlvbigpe1wib3V0XCI9PWMuaG92ZXJTdGF0ZSYmYy5oaWRlKCl9LGMub3B0aW9ucy5kZWxheS5oaWRlKSk6Yy5oaWRlKCkpfSxjLnByb3RvdHlwZS5zaG93PWZ1bmN0aW9uKCl7dmFyIGI9YS5FdmVudChcInNob3cuYnMuXCIrdGhpcy50eXBlKTtpZih0aGlzLmhhc0NvbnRlbnQoKSYmdGhpcy5lbmFibGVkKXt0aGlzLiRlbGVtZW50LnRyaWdnZXIoYik7dmFyIGQ9YS5jb250YWlucyh0aGlzLiRlbGVtZW50WzBdLm93bmVyRG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LHRoaXMuJGVsZW1lbnRbMF0pO2lmKGIuaXNEZWZhdWx0UHJldmVudGVkKCl8fCFkKXJldHVybjt2YXIgZT10aGlzLGY9dGhpcy50aXAoKSxnPXRoaXMuZ2V0VUlEKHRoaXMudHlwZSk7dGhpcy5zZXRDb250ZW50KCksZi5hdHRyKFwiaWRcIixnKSx0aGlzLiRlbGVtZW50LmF0dHIoXCJhcmlhLWRlc2NyaWJlZGJ5XCIsZyksdGhpcy5vcHRpb25zLmFuaW1hdGlvbiYmZi5hZGRDbGFzcyhcImZhZGVcIik7dmFyIGg9XCJmdW5jdGlvblwiPT10eXBlb2YgdGhpcy5vcHRpb25zLnBsYWNlbWVudD90aGlzLm9wdGlvbnMucGxhY2VtZW50LmNhbGwodGhpcyxmWzBdLHRoaXMuJGVsZW1lbnRbMF0pOnRoaXMub3B0aW9ucy5wbGFjZW1lbnQsaT0vXFxzP2F1dG8/XFxzPy9pLGo9aS50ZXN0KGgpO2omJihoPWgucmVwbGFjZShpLFwiXCIpfHxcInRvcFwiKSxmLmRldGFjaCgpLmNzcyh7dG9wOjAsbGVmdDowLGRpc3BsYXk6XCJibG9ja1wifSkuYWRkQ2xhc3MoaCkuZGF0YShcImJzLlwiK3RoaXMudHlwZSx0aGlzKSx0aGlzLm9wdGlvbnMuY29udGFpbmVyP2YuYXBwZW5kVG8odGhpcy5vcHRpb25zLmNvbnRhaW5lcik6Zi5pbnNlcnRBZnRlcih0aGlzLiRlbGVtZW50KSx0aGlzLiRlbGVtZW50LnRyaWdnZXIoXCJpbnNlcnRlZC5icy5cIit0aGlzLnR5cGUpO3ZhciBrPXRoaXMuZ2V0UG9zaXRpb24oKSxsPWZbMF0ub2Zmc2V0V2lkdGgsbT1mWzBdLm9mZnNldEhlaWdodDtpZihqKXt2YXIgbj1oLG89dGhpcy5nZXRQb3NpdGlvbih0aGlzLiR2aWV3cG9ydCk7aD1cImJvdHRvbVwiPT1oJiZrLmJvdHRvbSttPm8uYm90dG9tP1widG9wXCI6XCJ0b3BcIj09aCYmay50b3AtbTxvLnRvcD9cImJvdHRvbVwiOlwicmlnaHRcIj09aCYmay5yaWdodCtsPm8ud2lkdGg/XCJsZWZ0XCI6XCJsZWZ0XCI9PWgmJmsubGVmdC1sPG8ubGVmdD9cInJpZ2h0XCI6aCxmLnJlbW92ZUNsYXNzKG4pLmFkZENsYXNzKGgpfXZhciBwPXRoaXMuZ2V0Q2FsY3VsYXRlZE9mZnNldChoLGssbCxtKTt0aGlzLmFwcGx5UGxhY2VtZW50KHAsaCk7dmFyIHE9ZnVuY3Rpb24oKXt2YXIgYT1lLmhvdmVyU3RhdGU7ZS4kZWxlbWVudC50cmlnZ2VyKFwic2hvd24uYnMuXCIrZS50eXBlKSxlLmhvdmVyU3RhdGU9bnVsbCxcIm91dFwiPT1hJiZlLmxlYXZlKGUpfTthLnN1cHBvcnQudHJhbnNpdGlvbiYmdGhpcy4kdGlwLmhhc0NsYXNzKFwiZmFkZVwiKT9mLm9uZShcImJzVHJhbnNpdGlvbkVuZFwiLHEpLmVtdWxhdGVUcmFuc2l0aW9uRW5kKGMuVFJBTlNJVElPTl9EVVJBVElPTik6cSgpfX0sYy5wcm90b3R5cGUuYXBwbHlQbGFjZW1lbnQ9ZnVuY3Rpb24oYixjKXt2YXIgZD10aGlzLnRpcCgpLGU9ZFswXS5vZmZzZXRXaWR0aCxmPWRbMF0ub2Zmc2V0SGVpZ2h0LGc9cGFyc2VJbnQoZC5jc3MoXCJtYXJnaW4tdG9wXCIpLDEwKSxoPXBhcnNlSW50KGQuY3NzKFwibWFyZ2luLWxlZnRcIiksMTApO2lzTmFOKGcpJiYoZz0wKSxpc05hTihoKSYmKGg9MCksYi50b3ArPWcsYi5sZWZ0Kz1oLGEub2Zmc2V0LnNldE9mZnNldChkWzBdLGEuZXh0ZW5kKHt1c2luZzpmdW5jdGlvbihhKXtkLmNzcyh7dG9wOk1hdGgucm91bmQoYS50b3ApLGxlZnQ6TWF0aC5yb3VuZChhLmxlZnQpfSl9fSxiKSwwKSxkLmFkZENsYXNzKFwiaW5cIik7dmFyIGk9ZFswXS5vZmZzZXRXaWR0aCxqPWRbMF0ub2Zmc2V0SGVpZ2h0O1widG9wXCI9PWMmJmohPWYmJihiLnRvcD1iLnRvcCtmLWopO3ZhciBrPXRoaXMuZ2V0Vmlld3BvcnRBZGp1c3RlZERlbHRhKGMsYixpLGopO2subGVmdD9iLmxlZnQrPWsubGVmdDpiLnRvcCs9ay50b3A7dmFyIGw9L3RvcHxib3R0b20vLnRlc3QoYyksbT1sPzIqay5sZWZ0LWUraToyKmsudG9wLWYraixuPWw/XCJvZmZzZXRXaWR0aFwiOlwib2Zmc2V0SGVpZ2h0XCI7ZC5vZmZzZXQoYiksdGhpcy5yZXBsYWNlQXJyb3cobSxkWzBdW25dLGwpfSxjLnByb3RvdHlwZS5yZXBsYWNlQXJyb3c9ZnVuY3Rpb24oYSxiLGMpe3RoaXMuYXJyb3coKS5jc3MoYz9cImxlZnRcIjpcInRvcFwiLDUwKigxLWEvYikrXCIlXCIpLmNzcyhjP1widG9wXCI6XCJsZWZ0XCIsXCJcIil9LGMucHJvdG90eXBlLnNldENvbnRlbnQ9ZnVuY3Rpb24oKXt2YXIgYT10aGlzLnRpcCgpLGI9dGhpcy5nZXRUaXRsZSgpO2EuZmluZChcIi50b29sdGlwLWlubmVyXCIpW3RoaXMub3B0aW9ucy5odG1sP1wiaHRtbFwiOlwidGV4dFwiXShiKSxhLnJlbW92ZUNsYXNzKFwiZmFkZSBpbiB0b3AgYm90dG9tIGxlZnQgcmlnaHRcIil9LGMucHJvdG90eXBlLmhpZGU9ZnVuY3Rpb24oYil7ZnVuY3Rpb24gZCgpe1wiaW5cIiE9ZS5ob3ZlclN0YXRlJiZmLmRldGFjaCgpLGUuJGVsZW1lbnQucmVtb3ZlQXR0cihcImFyaWEtZGVzY3JpYmVkYnlcIikudHJpZ2dlcihcImhpZGRlbi5icy5cIitlLnR5cGUpLGImJmIoKX12YXIgZT10aGlzLGY9YSh0aGlzLiR0aXApLGc9YS5FdmVudChcImhpZGUuYnMuXCIrdGhpcy50eXBlKTtyZXR1cm4gdGhpcy4kZWxlbWVudC50cmlnZ2VyKGcpLGcuaXNEZWZhdWx0UHJldmVudGVkKCk/dm9pZCAwOihmLnJlbW92ZUNsYXNzKFwiaW5cIiksYS5zdXBwb3J0LnRyYW5zaXRpb24mJmYuaGFzQ2xhc3MoXCJmYWRlXCIpP2Yub25lKFwiYnNUcmFuc2l0aW9uRW5kXCIsZCkuZW11bGF0ZVRyYW5zaXRpb25FbmQoYy5UUkFOU0lUSU9OX0RVUkFUSU9OKTpkKCksdGhpcy5ob3ZlclN0YXRlPW51bGwsdGhpcyl9LGMucHJvdG90eXBlLmZpeFRpdGxlPWZ1bmN0aW9uKCl7dmFyIGE9dGhpcy4kZWxlbWVudDsoYS5hdHRyKFwidGl0bGVcIil8fFwic3RyaW5nXCIhPXR5cGVvZiBhLmF0dHIoXCJkYXRhLW9yaWdpbmFsLXRpdGxlXCIpKSYmYS5hdHRyKFwiZGF0YS1vcmlnaW5hbC10aXRsZVwiLGEuYXR0cihcInRpdGxlXCIpfHxcIlwiKS5hdHRyKFwidGl0bGVcIixcIlwiKX0sYy5wcm90b3R5cGUuaGFzQ29udGVudD1mdW5jdGlvbigpe3JldHVybiB0aGlzLmdldFRpdGxlKCl9LGMucHJvdG90eXBlLmdldFBvc2l0aW9uPWZ1bmN0aW9uKGIpe2I9Ynx8dGhpcy4kZWxlbWVudDt2YXIgYz1iWzBdLGQ9XCJCT0RZXCI9PWMudGFnTmFtZSxlPWMuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7bnVsbD09ZS53aWR0aCYmKGU9YS5leHRlbmQoe30sZSx7d2lkdGg6ZS5yaWdodC1lLmxlZnQsaGVpZ2h0OmUuYm90dG9tLWUudG9wfSkpO3ZhciBmPWQ/e3RvcDowLGxlZnQ6MH06Yi5vZmZzZXQoKSxnPXtzY3JvbGw6ZD9kb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsVG9wfHxkb2N1bWVudC5ib2R5LnNjcm9sbFRvcDpiLnNjcm9sbFRvcCgpfSxoPWQ/e3dpZHRoOmEod2luZG93KS53aWR0aCgpLGhlaWdodDphKHdpbmRvdykuaGVpZ2h0KCl9Om51bGw7cmV0dXJuIGEuZXh0ZW5kKHt9LGUsZyxoLGYpfSxjLnByb3RvdHlwZS5nZXRDYWxjdWxhdGVkT2Zmc2V0PWZ1bmN0aW9uKGEsYixjLGQpe3JldHVyblwiYm90dG9tXCI9PWE/e3RvcDpiLnRvcCtiLmhlaWdodCxsZWZ0OmIubGVmdCtiLndpZHRoLzItYy8yfTpcInRvcFwiPT1hP3t0b3A6Yi50b3AtZCxsZWZ0OmIubGVmdCtiLndpZHRoLzItYy8yfTpcImxlZnRcIj09YT97dG9wOmIudG9wK2IuaGVpZ2h0LzItZC8yLGxlZnQ6Yi5sZWZ0LWN9Ont0b3A6Yi50b3ArYi5oZWlnaHQvMi1kLzIsbGVmdDpiLmxlZnQrYi53aWR0aH19LGMucHJvdG90eXBlLmdldFZpZXdwb3J0QWRqdXN0ZWREZWx0YT1mdW5jdGlvbihhLGIsYyxkKXt2YXIgZT17dG9wOjAsbGVmdDowfTtpZighdGhpcy4kdmlld3BvcnQpcmV0dXJuIGU7dmFyIGY9dGhpcy5vcHRpb25zLnZpZXdwb3J0JiZ0aGlzLm9wdGlvbnMudmlld3BvcnQucGFkZGluZ3x8MCxnPXRoaXMuZ2V0UG9zaXRpb24odGhpcy4kdmlld3BvcnQpO2lmKC9yaWdodHxsZWZ0Ly50ZXN0KGEpKXt2YXIgaD1iLnRvcC1mLWcuc2Nyb2xsLGk9Yi50b3ArZi1nLnNjcm9sbCtkO2g8Zy50b3A/ZS50b3A9Zy50b3AtaDppPmcudG9wK2cuaGVpZ2h0JiYoZS50b3A9Zy50b3ArZy5oZWlnaHQtaSl9ZWxzZXt2YXIgaj1iLmxlZnQtZixrPWIubGVmdCtmK2M7ajxnLmxlZnQ/ZS5sZWZ0PWcubGVmdC1qOms+Zy5yaWdodCYmKGUubGVmdD1nLmxlZnQrZy53aWR0aC1rKX1yZXR1cm4gZX0sYy5wcm90b3R5cGUuZ2V0VGl0bGU9ZnVuY3Rpb24oKXt2YXIgYSxiPXRoaXMuJGVsZW1lbnQsYz10aGlzLm9wdGlvbnM7cmV0dXJuIGE9Yi5hdHRyKFwiZGF0YS1vcmlnaW5hbC10aXRsZVwiKXx8KFwiZnVuY3Rpb25cIj09dHlwZW9mIGMudGl0bGU/Yy50aXRsZS5jYWxsKGJbMF0pOmMudGl0bGUpfSxjLnByb3RvdHlwZS5nZXRVSUQ9ZnVuY3Rpb24oYSl7ZG8gYSs9fn4oMWU2Kk1hdGgucmFuZG9tKCkpO3doaWxlKGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGEpKTtyZXR1cm4gYX0sYy5wcm90b3R5cGUudGlwPWZ1bmN0aW9uKCl7aWYoIXRoaXMuJHRpcCYmKHRoaXMuJHRpcD1hKHRoaXMub3B0aW9ucy50ZW1wbGF0ZSksMSE9dGhpcy4kdGlwLmxlbmd0aCkpdGhyb3cgbmV3IEVycm9yKHRoaXMudHlwZStcIiBgdGVtcGxhdGVgIG9wdGlvbiBtdXN0IGNvbnNpc3Qgb2YgZXhhY3RseSAxIHRvcC1sZXZlbCBlbGVtZW50IVwiKTtyZXR1cm4gdGhpcy4kdGlwfSxjLnByb3RvdHlwZS5hcnJvdz1mdW5jdGlvbigpe3JldHVybiB0aGlzLiRhcnJvdz10aGlzLiRhcnJvd3x8dGhpcy50aXAoKS5maW5kKFwiLnRvb2x0aXAtYXJyb3dcIil9LGMucHJvdG90eXBlLmVuYWJsZT1mdW5jdGlvbigpe3RoaXMuZW5hYmxlZD0hMH0sYy5wcm90b3R5cGUuZGlzYWJsZT1mdW5jdGlvbigpe3RoaXMuZW5hYmxlZD0hMX0sYy5wcm90b3R5cGUudG9nZ2xlRW5hYmxlZD1mdW5jdGlvbigpe3RoaXMuZW5hYmxlZD0hdGhpcy5lbmFibGVkfSxjLnByb3RvdHlwZS50b2dnbGU9ZnVuY3Rpb24oYil7dmFyIGM9dGhpcztiJiYoYz1hKGIuY3VycmVudFRhcmdldCkuZGF0YShcImJzLlwiK3RoaXMudHlwZSksY3x8KGM9bmV3IHRoaXMuY29uc3RydWN0b3IoYi5jdXJyZW50VGFyZ2V0LHRoaXMuZ2V0RGVsZWdhdGVPcHRpb25zKCkpLGEoYi5jdXJyZW50VGFyZ2V0KS5kYXRhKFwiYnMuXCIrdGhpcy50eXBlLGMpKSksYj8oYy5pblN0YXRlLmNsaWNrPSFjLmluU3RhdGUuY2xpY2ssYy5pc0luU3RhdGVUcnVlKCk/Yy5lbnRlcihjKTpjLmxlYXZlKGMpKTpjLnRpcCgpLmhhc0NsYXNzKFwiaW5cIik/Yy5sZWF2ZShjKTpjLmVudGVyKGMpfSxjLnByb3RvdHlwZS5kZXN0cm95PWZ1bmN0aW9uKCl7dmFyIGE9dGhpcztjbGVhclRpbWVvdXQodGhpcy50aW1lb3V0KSx0aGlzLmhpZGUoZnVuY3Rpb24oKXthLiRlbGVtZW50Lm9mZihcIi5cIithLnR5cGUpLnJlbW92ZURhdGEoXCJicy5cIithLnR5cGUpLGEuJHRpcCYmYS4kdGlwLmRldGFjaCgpLGEuJHRpcD1udWxsLGEuJGFycm93PW51bGwsYS4kdmlld3BvcnQ9bnVsbH0pfTt2YXIgZD1hLmZuLnRvb2x0aXA7YS5mbi50b29sdGlwPWIsYS5mbi50b29sdGlwLkNvbnN0cnVjdG9yPWMsYS5mbi50b29sdGlwLm5vQ29uZmxpY3Q9ZnVuY3Rpb24oKXtyZXR1cm4gYS5mbi50b29sdGlwPWQsdGhpc319KGpRdWVyeSksK2Z1bmN0aW9uKGEpe1widXNlIHN0cmljdFwiO2Z1bmN0aW9uIGIoYil7cmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpe3ZhciBkPWEodGhpcyksZT1kLmRhdGEoXCJicy5wb3BvdmVyXCIpLGY9XCJvYmplY3RcIj09dHlwZW9mIGImJmI7KGV8fCEvZGVzdHJveXxoaWRlLy50ZXN0KGIpKSYmKGV8fGQuZGF0YShcImJzLnBvcG92ZXJcIixlPW5ldyBjKHRoaXMsZikpLFwic3RyaW5nXCI9PXR5cGVvZiBiJiZlW2JdKCkpfSl9dmFyIGM9ZnVuY3Rpb24oYSxiKXt0aGlzLmluaXQoXCJwb3BvdmVyXCIsYSxiKX07aWYoIWEuZm4udG9vbHRpcCl0aHJvdyBuZXcgRXJyb3IoXCJQb3BvdmVyIHJlcXVpcmVzIHRvb2x0aXAuanNcIik7Yy5WRVJTSU9OPVwiMy4zLjZcIixjLkRFRkFVTFRTPWEuZXh0ZW5kKHt9LGEuZm4udG9vbHRpcC5Db25zdHJ1Y3Rvci5ERUZBVUxUUyx7cGxhY2VtZW50OlwicmlnaHRcIix0cmlnZ2VyOlwiY2xpY2tcIixjb250ZW50OlwiXCIsdGVtcGxhdGU6JzxkaXYgY2xhc3M9XCJwb3BvdmVyXCIgcm9sZT1cInRvb2x0aXBcIj48ZGl2IGNsYXNzPVwiYXJyb3dcIj48L2Rpdj48aDMgY2xhc3M9XCJwb3BvdmVyLXRpdGxlXCI+PC9oMz48ZGl2IGNsYXNzPVwicG9wb3Zlci1jb250ZW50XCI+PC9kaXY+PC9kaXY+J30pLGMucHJvdG90eXBlPWEuZXh0ZW5kKHt9LGEuZm4udG9vbHRpcC5Db25zdHJ1Y3Rvci5wcm90b3R5cGUpLGMucHJvdG90eXBlLmNvbnN0cnVjdG9yPWMsYy5wcm90b3R5cGUuZ2V0RGVmYXVsdHM9ZnVuY3Rpb24oKXtyZXR1cm4gYy5ERUZBVUxUU30sYy5wcm90b3R5cGUuc2V0Q29udGVudD1mdW5jdGlvbigpe3ZhciBhPXRoaXMudGlwKCksYj10aGlzLmdldFRpdGxlKCksYz10aGlzLmdldENvbnRlbnQoKTthLmZpbmQoXCIucG9wb3Zlci10aXRsZVwiKVt0aGlzLm9wdGlvbnMuaHRtbD9cImh0bWxcIjpcInRleHRcIl0oYiksYS5maW5kKFwiLnBvcG92ZXItY29udGVudFwiKS5jaGlsZHJlbigpLmRldGFjaCgpLmVuZCgpW3RoaXMub3B0aW9ucy5odG1sP1wic3RyaW5nXCI9PXR5cGVvZiBjP1wiaHRtbFwiOlwiYXBwZW5kXCI6XCJ0ZXh0XCJdKGMpLGEucmVtb3ZlQ2xhc3MoXCJmYWRlIHRvcCBib3R0b20gbGVmdCByaWdodCBpblwiKSxhLmZpbmQoXCIucG9wb3Zlci10aXRsZVwiKS5odG1sKCl8fGEuZmluZChcIi5wb3BvdmVyLXRpdGxlXCIpLmhpZGUoKX0sYy5wcm90b3R5cGUuaGFzQ29udGVudD1mdW5jdGlvbigpe3JldHVybiB0aGlzLmdldFRpdGxlKCl8fHRoaXMuZ2V0Q29udGVudCgpfSxjLnByb3RvdHlwZS5nZXRDb250ZW50PWZ1bmN0aW9uKCl7dmFyIGE9dGhpcy4kZWxlbWVudCxiPXRoaXMub3B0aW9ucztyZXR1cm4gYS5hdHRyKFwiZGF0YS1jb250ZW50XCIpfHwoXCJmdW5jdGlvblwiPT10eXBlb2YgYi5jb250ZW50P2IuY29udGVudC5jYWxsKGFbMF0pOmIuY29udGVudCl9LGMucHJvdG90eXBlLmFycm93PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuJGFycm93PXRoaXMuJGFycm93fHx0aGlzLnRpcCgpLmZpbmQoXCIuYXJyb3dcIil9O3ZhciBkPWEuZm4ucG9wb3ZlcjthLmZuLnBvcG92ZXI9YixhLmZuLnBvcG92ZXIuQ29uc3RydWN0b3I9YyxhLmZuLnBvcG92ZXIubm9Db25mbGljdD1mdW5jdGlvbigpe3JldHVybiBhLmZuLnBvcG92ZXI9ZCx0aGlzfX0oalF1ZXJ5KSwrZnVuY3Rpb24oYSl7XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gYihjLGQpe3RoaXMuJGJvZHk9YShkb2N1bWVudC5ib2R5KSx0aGlzLiRzY3JvbGxFbGVtZW50PWEoYShjKS5pcyhkb2N1bWVudC5ib2R5KT93aW5kb3c6YyksdGhpcy5vcHRpb25zPWEuZXh0ZW5kKHt9LGIuREVGQVVMVFMsZCksdGhpcy5zZWxlY3Rvcj0odGhpcy5vcHRpb25zLnRhcmdldHx8XCJcIikrXCIgLm5hdiBsaSA+IGFcIix0aGlzLm9mZnNldHM9W10sdGhpcy50YXJnZXRzPVtdLHRoaXMuYWN0aXZlVGFyZ2V0PW51bGwsdGhpcy5zY3JvbGxIZWlnaHQ9MCx0aGlzLiRzY3JvbGxFbGVtZW50Lm9uKFwic2Nyb2xsLmJzLnNjcm9sbHNweVwiLGEucHJveHkodGhpcy5wcm9jZXNzLHRoaXMpKSx0aGlzLnJlZnJlc2goKSx0aGlzLnByb2Nlc3MoKX1mdW5jdGlvbiBjKGMpe3JldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKXt2YXIgZD1hKHRoaXMpLGU9ZC5kYXRhKFwiYnMuc2Nyb2xsc3B5XCIpLGY9XCJvYmplY3RcIj09dHlwZW9mIGMmJmM7ZXx8ZC5kYXRhKFwiYnMuc2Nyb2xsc3B5XCIsZT1uZXcgYih0aGlzLGYpKSxcInN0cmluZ1wiPT10eXBlb2YgYyYmZVtjXSgpfSl9Yi5WRVJTSU9OPVwiMy4zLjZcIixiLkRFRkFVTFRTPXtvZmZzZXQ6MTB9LGIucHJvdG90eXBlLmdldFNjcm9sbEhlaWdodD1mdW5jdGlvbigpe3JldHVybiB0aGlzLiRzY3JvbGxFbGVtZW50WzBdLnNjcm9sbEhlaWdodHx8TWF0aC5tYXgodGhpcy4kYm9keVswXS5zY3JvbGxIZWlnaHQsZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbEhlaWdodCl9LGIucHJvdG90eXBlLnJlZnJlc2g9ZnVuY3Rpb24oKXt2YXIgYj10aGlzLGM9XCJvZmZzZXRcIixkPTA7dGhpcy5vZmZzZXRzPVtdLHRoaXMudGFyZ2V0cz1bXSx0aGlzLnNjcm9sbEhlaWdodD10aGlzLmdldFNjcm9sbEhlaWdodCgpLGEuaXNXaW5kb3codGhpcy4kc2Nyb2xsRWxlbWVudFswXSl8fChjPVwicG9zaXRpb25cIixkPXRoaXMuJHNjcm9sbEVsZW1lbnQuc2Nyb2xsVG9wKCkpLHRoaXMuJGJvZHkuZmluZCh0aGlzLnNlbGVjdG9yKS5tYXAoZnVuY3Rpb24oKXt2YXIgYj1hKHRoaXMpLGU9Yi5kYXRhKFwidGFyZ2V0XCIpfHxiLmF0dHIoXCJocmVmXCIpLGY9L14jLi8udGVzdChlKSYmYShlKTtyZXR1cm4gZiYmZi5sZW5ndGgmJmYuaXMoXCI6dmlzaWJsZVwiKSYmW1tmW2NdKCkudG9wK2QsZV1dfHxudWxsfSkuc29ydChmdW5jdGlvbihhLGIpe3JldHVybiBhWzBdLWJbMF19KS5lYWNoKGZ1bmN0aW9uKCl7Yi5vZmZzZXRzLnB1c2godGhpc1swXSksYi50YXJnZXRzLnB1c2godGhpc1sxXSl9KX0sYi5wcm90b3R5cGUucHJvY2Vzcz1mdW5jdGlvbigpe3ZhciBhLGI9dGhpcy4kc2Nyb2xsRWxlbWVudC5zY3JvbGxUb3AoKSt0aGlzLm9wdGlvbnMub2Zmc2V0LGM9dGhpcy5nZXRTY3JvbGxIZWlnaHQoKSxkPXRoaXMub3B0aW9ucy5vZmZzZXQrYy10aGlzLiRzY3JvbGxFbGVtZW50LmhlaWdodCgpLGU9dGhpcy5vZmZzZXRzLGY9dGhpcy50YXJnZXRzLGc9dGhpcy5hY3RpdmVUYXJnZXQ7aWYodGhpcy5zY3JvbGxIZWlnaHQhPWMmJnRoaXMucmVmcmVzaCgpLGI+PWQpcmV0dXJuIGchPShhPWZbZi5sZW5ndGgtMV0pJiZ0aGlzLmFjdGl2YXRlKGEpO2lmKGcmJmI8ZVswXSlyZXR1cm4gdGhpcy5hY3RpdmVUYXJnZXQ9bnVsbCx0aGlzLmNsZWFyKCk7Zm9yKGE9ZS5sZW5ndGg7YS0tOylnIT1mW2FdJiZiPj1lW2FdJiYodm9pZCAwPT09ZVthKzFdfHxiPGVbYSsxXSkmJnRoaXMuYWN0aXZhdGUoZlthXSl9LGIucHJvdG90eXBlLmFjdGl2YXRlPWZ1bmN0aW9uKGIpe3RoaXMuYWN0aXZlVGFyZ2V0PWIsdGhpcy5jbGVhcigpO3ZhciBjPXRoaXMuc2VsZWN0b3IrJ1tkYXRhLXRhcmdldD1cIicrYisnXCJdLCcrdGhpcy5zZWxlY3RvcisnW2hyZWY9XCInK2IrJ1wiXScsZD1hKGMpLnBhcmVudHMoXCJsaVwiKS5hZGRDbGFzcyhcImFjdGl2ZVwiKTtcclxuZC5wYXJlbnQoXCIuZHJvcGRvd24tbWVudVwiKS5sZW5ndGgmJihkPWQuY2xvc2VzdChcImxpLmRyb3Bkb3duXCIpLmFkZENsYXNzKFwiYWN0aXZlXCIpKSxkLnRyaWdnZXIoXCJhY3RpdmF0ZS5icy5zY3JvbGxzcHlcIil9LGIucHJvdG90eXBlLmNsZWFyPWZ1bmN0aW9uKCl7YSh0aGlzLnNlbGVjdG9yKS5wYXJlbnRzVW50aWwodGhpcy5vcHRpb25zLnRhcmdldCxcIi5hY3RpdmVcIikucmVtb3ZlQ2xhc3MoXCJhY3RpdmVcIil9O3ZhciBkPWEuZm4uc2Nyb2xsc3B5O2EuZm4uc2Nyb2xsc3B5PWMsYS5mbi5zY3JvbGxzcHkuQ29uc3RydWN0b3I9YixhLmZuLnNjcm9sbHNweS5ub0NvbmZsaWN0PWZ1bmN0aW9uKCl7cmV0dXJuIGEuZm4uc2Nyb2xsc3B5PWQsdGhpc30sYSh3aW5kb3cpLm9uKFwibG9hZC5icy5zY3JvbGxzcHkuZGF0YS1hcGlcIixmdW5jdGlvbigpe2EoJ1tkYXRhLXNweT1cInNjcm9sbFwiXScpLmVhY2goZnVuY3Rpb24oKXt2YXIgYj1hKHRoaXMpO2MuY2FsbChiLGIuZGF0YSgpKX0pfSl9KGpRdWVyeSksK2Z1bmN0aW9uKGEpe1widXNlIHN0cmljdFwiO2Z1bmN0aW9uIGIoYil7cmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpe3ZhciBkPWEodGhpcyksZT1kLmRhdGEoXCJicy50YWJcIik7ZXx8ZC5kYXRhKFwiYnMudGFiXCIsZT1uZXcgYyh0aGlzKSksXCJzdHJpbmdcIj09dHlwZW9mIGImJmVbYl0oKX0pfXZhciBjPWZ1bmN0aW9uKGIpe3RoaXMuZWxlbWVudD1hKGIpfTtjLlZFUlNJT049XCIzLjMuNlwiLGMuVFJBTlNJVElPTl9EVVJBVElPTj0xNTAsYy5wcm90b3R5cGUuc2hvdz1mdW5jdGlvbigpe3ZhciBiPXRoaXMuZWxlbWVudCxjPWIuY2xvc2VzdChcInVsOm5vdCguZHJvcGRvd24tbWVudSlcIiksZD1iLmRhdGEoXCJ0YXJnZXRcIik7aWYoZHx8KGQ9Yi5hdHRyKFwiaHJlZlwiKSxkPWQmJmQucmVwbGFjZSgvLiooPz0jW15cXHNdKiQpLyxcIlwiKSksIWIucGFyZW50KFwibGlcIikuaGFzQ2xhc3MoXCJhY3RpdmVcIikpe3ZhciBlPWMuZmluZChcIi5hY3RpdmU6bGFzdCBhXCIpLGY9YS5FdmVudChcImhpZGUuYnMudGFiXCIse3JlbGF0ZWRUYXJnZXQ6YlswXX0pLGc9YS5FdmVudChcInNob3cuYnMudGFiXCIse3JlbGF0ZWRUYXJnZXQ6ZVswXX0pO2lmKGUudHJpZ2dlcihmKSxiLnRyaWdnZXIoZyksIWcuaXNEZWZhdWx0UHJldmVudGVkKCkmJiFmLmlzRGVmYXVsdFByZXZlbnRlZCgpKXt2YXIgaD1hKGQpO3RoaXMuYWN0aXZhdGUoYi5jbG9zZXN0KFwibGlcIiksYyksdGhpcy5hY3RpdmF0ZShoLGgucGFyZW50KCksZnVuY3Rpb24oKXtlLnRyaWdnZXIoe3R5cGU6XCJoaWRkZW4uYnMudGFiXCIscmVsYXRlZFRhcmdldDpiWzBdfSksYi50cmlnZ2VyKHt0eXBlOlwic2hvd24uYnMudGFiXCIscmVsYXRlZFRhcmdldDplWzBdfSl9KX19fSxjLnByb3RvdHlwZS5hY3RpdmF0ZT1mdW5jdGlvbihiLGQsZSl7ZnVuY3Rpb24gZigpe2cucmVtb3ZlQ2xhc3MoXCJhY3RpdmVcIikuZmluZChcIj4gLmRyb3Bkb3duLW1lbnUgPiAuYWN0aXZlXCIpLnJlbW92ZUNsYXNzKFwiYWN0aXZlXCIpLmVuZCgpLmZpbmQoJ1tkYXRhLXRvZ2dsZT1cInRhYlwiXScpLmF0dHIoXCJhcmlhLWV4cGFuZGVkXCIsITEpLGIuYWRkQ2xhc3MoXCJhY3RpdmVcIikuZmluZCgnW2RhdGEtdG9nZ2xlPVwidGFiXCJdJykuYXR0cihcImFyaWEtZXhwYW5kZWRcIiwhMCksaD8oYlswXS5vZmZzZXRXaWR0aCxiLmFkZENsYXNzKFwiaW5cIikpOmIucmVtb3ZlQ2xhc3MoXCJmYWRlXCIpLGIucGFyZW50KFwiLmRyb3Bkb3duLW1lbnVcIikubGVuZ3RoJiZiLmNsb3Nlc3QoXCJsaS5kcm9wZG93blwiKS5hZGRDbGFzcyhcImFjdGl2ZVwiKS5lbmQoKS5maW5kKCdbZGF0YS10b2dnbGU9XCJ0YWJcIl0nKS5hdHRyKFwiYXJpYS1leHBhbmRlZFwiLCEwKSxlJiZlKCl9dmFyIGc9ZC5maW5kKFwiPiAuYWN0aXZlXCIpLGg9ZSYmYS5zdXBwb3J0LnRyYW5zaXRpb24mJihnLmxlbmd0aCYmZy5oYXNDbGFzcyhcImZhZGVcIil8fCEhZC5maW5kKFwiPiAuZmFkZVwiKS5sZW5ndGgpO2cubGVuZ3RoJiZoP2cub25lKFwiYnNUcmFuc2l0aW9uRW5kXCIsZikuZW11bGF0ZVRyYW5zaXRpb25FbmQoYy5UUkFOU0lUSU9OX0RVUkFUSU9OKTpmKCksZy5yZW1vdmVDbGFzcyhcImluXCIpfTt2YXIgZD1hLmZuLnRhYjthLmZuLnRhYj1iLGEuZm4udGFiLkNvbnN0cnVjdG9yPWMsYS5mbi50YWIubm9Db25mbGljdD1mdW5jdGlvbigpe3JldHVybiBhLmZuLnRhYj1kLHRoaXN9O3ZhciBlPWZ1bmN0aW9uKGMpe2MucHJldmVudERlZmF1bHQoKSxiLmNhbGwoYSh0aGlzKSxcInNob3dcIil9O2EoZG9jdW1lbnQpLm9uKFwiY2xpY2suYnMudGFiLmRhdGEtYXBpXCIsJ1tkYXRhLXRvZ2dsZT1cInRhYlwiXScsZSkub24oXCJjbGljay5icy50YWIuZGF0YS1hcGlcIiwnW2RhdGEtdG9nZ2xlPVwicGlsbFwiXScsZSl9KGpRdWVyeSksK2Z1bmN0aW9uKGEpe1widXNlIHN0cmljdFwiO2Z1bmN0aW9uIGIoYil7cmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpe3ZhciBkPWEodGhpcyksZT1kLmRhdGEoXCJicy5hZmZpeFwiKSxmPVwib2JqZWN0XCI9PXR5cGVvZiBiJiZiO2V8fGQuZGF0YShcImJzLmFmZml4XCIsZT1uZXcgYyh0aGlzLGYpKSxcInN0cmluZ1wiPT10eXBlb2YgYiYmZVtiXSgpfSl9dmFyIGM9ZnVuY3Rpb24oYixkKXt0aGlzLm9wdGlvbnM9YS5leHRlbmQoe30sYy5ERUZBVUxUUyxkKSx0aGlzLiR0YXJnZXQ9YSh0aGlzLm9wdGlvbnMudGFyZ2V0KS5vbihcInNjcm9sbC5icy5hZmZpeC5kYXRhLWFwaVwiLGEucHJveHkodGhpcy5jaGVja1Bvc2l0aW9uLHRoaXMpKS5vbihcImNsaWNrLmJzLmFmZml4LmRhdGEtYXBpXCIsYS5wcm94eSh0aGlzLmNoZWNrUG9zaXRpb25XaXRoRXZlbnRMb29wLHRoaXMpKSx0aGlzLiRlbGVtZW50PWEoYiksdGhpcy5hZmZpeGVkPW51bGwsdGhpcy51bnBpbj1udWxsLHRoaXMucGlubmVkT2Zmc2V0PW51bGwsdGhpcy5jaGVja1Bvc2l0aW9uKCl9O2MuVkVSU0lPTj1cIjMuMy42XCIsYy5SRVNFVD1cImFmZml4IGFmZml4LXRvcCBhZmZpeC1ib3R0b21cIixjLkRFRkFVTFRTPXtvZmZzZXQ6MCx0YXJnZXQ6d2luZG93fSxjLnByb3RvdHlwZS5nZXRTdGF0ZT1mdW5jdGlvbihhLGIsYyxkKXt2YXIgZT10aGlzLiR0YXJnZXQuc2Nyb2xsVG9wKCksZj10aGlzLiRlbGVtZW50Lm9mZnNldCgpLGc9dGhpcy4kdGFyZ2V0LmhlaWdodCgpO2lmKG51bGwhPWMmJlwidG9wXCI9PXRoaXMuYWZmaXhlZClyZXR1cm4gYz5lP1widG9wXCI6ITE7aWYoXCJib3R0b21cIj09dGhpcy5hZmZpeGVkKXJldHVybiBudWxsIT1jP2UrdGhpcy51bnBpbjw9Zi50b3A/ITE6XCJib3R0b21cIjphLWQ+PWUrZz8hMTpcImJvdHRvbVwiO3ZhciBoPW51bGw9PXRoaXMuYWZmaXhlZCxpPWg/ZTpmLnRvcCxqPWg/ZzpiO3JldHVybiBudWxsIT1jJiZjPj1lP1widG9wXCI6bnVsbCE9ZCYmaStqPj1hLWQ/XCJib3R0b21cIjohMX0sYy5wcm90b3R5cGUuZ2V0UGlubmVkT2Zmc2V0PWZ1bmN0aW9uKCl7aWYodGhpcy5waW5uZWRPZmZzZXQpcmV0dXJuIHRoaXMucGlubmVkT2Zmc2V0O3RoaXMuJGVsZW1lbnQucmVtb3ZlQ2xhc3MoYy5SRVNFVCkuYWRkQ2xhc3MoXCJhZmZpeFwiKTt2YXIgYT10aGlzLiR0YXJnZXQuc2Nyb2xsVG9wKCksYj10aGlzLiRlbGVtZW50Lm9mZnNldCgpO3JldHVybiB0aGlzLnBpbm5lZE9mZnNldD1iLnRvcC1hfSxjLnByb3RvdHlwZS5jaGVja1Bvc2l0aW9uV2l0aEV2ZW50TG9vcD1mdW5jdGlvbigpe3NldFRpbWVvdXQoYS5wcm94eSh0aGlzLmNoZWNrUG9zaXRpb24sdGhpcyksMSl9LGMucHJvdG90eXBlLmNoZWNrUG9zaXRpb249ZnVuY3Rpb24oKXtpZih0aGlzLiRlbGVtZW50LmlzKFwiOnZpc2libGVcIikpe3ZhciBiPXRoaXMuJGVsZW1lbnQuaGVpZ2h0KCksZD10aGlzLm9wdGlvbnMub2Zmc2V0LGU9ZC50b3AsZj1kLmJvdHRvbSxnPU1hdGgubWF4KGEoZG9jdW1lbnQpLmhlaWdodCgpLGEoZG9jdW1lbnQuYm9keSkuaGVpZ2h0KCkpO1wib2JqZWN0XCIhPXR5cGVvZiBkJiYoZj1lPWQpLFwiZnVuY3Rpb25cIj09dHlwZW9mIGUmJihlPWQudG9wKHRoaXMuJGVsZW1lbnQpKSxcImZ1bmN0aW9uXCI9PXR5cGVvZiBmJiYoZj1kLmJvdHRvbSh0aGlzLiRlbGVtZW50KSk7dmFyIGg9dGhpcy5nZXRTdGF0ZShnLGIsZSxmKTtpZih0aGlzLmFmZml4ZWQhPWgpe251bGwhPXRoaXMudW5waW4mJnRoaXMuJGVsZW1lbnQuY3NzKFwidG9wXCIsXCJcIik7dmFyIGk9XCJhZmZpeFwiKyhoP1wiLVwiK2g6XCJcIiksaj1hLkV2ZW50KGkrXCIuYnMuYWZmaXhcIik7aWYodGhpcy4kZWxlbWVudC50cmlnZ2VyKGopLGouaXNEZWZhdWx0UHJldmVudGVkKCkpcmV0dXJuO3RoaXMuYWZmaXhlZD1oLHRoaXMudW5waW49XCJib3R0b21cIj09aD90aGlzLmdldFBpbm5lZE9mZnNldCgpOm51bGwsdGhpcy4kZWxlbWVudC5yZW1vdmVDbGFzcyhjLlJFU0VUKS5hZGRDbGFzcyhpKS50cmlnZ2VyKGkucmVwbGFjZShcImFmZml4XCIsXCJhZmZpeGVkXCIpK1wiLmJzLmFmZml4XCIpfVwiYm90dG9tXCI9PWgmJnRoaXMuJGVsZW1lbnQub2Zmc2V0KHt0b3A6Zy1iLWZ9KX19O3ZhciBkPWEuZm4uYWZmaXg7YS5mbi5hZmZpeD1iLGEuZm4uYWZmaXguQ29uc3RydWN0b3I9YyxhLmZuLmFmZml4Lm5vQ29uZmxpY3Q9ZnVuY3Rpb24oKXtyZXR1cm4gYS5mbi5hZmZpeD1kLHRoaXN9LGEod2luZG93KS5vbihcImxvYWRcIixmdW5jdGlvbigpe2EoJ1tkYXRhLXNweT1cImFmZml4XCJdJykuZWFjaChmdW5jdGlvbigpe3ZhciBjPWEodGhpcyksZD1jLmRhdGEoKTtkLm9mZnNldD1kLm9mZnNldHx8e30sbnVsbCE9ZC5vZmZzZXRCb3R0b20mJihkLm9mZnNldC5ib3R0b209ZC5vZmZzZXRCb3R0b20pLG51bGwhPWQub2Zmc2V0VG9wJiYoZC5vZmZzZXQudG9wPWQub2Zmc2V0VG9wKSxiLmNhbGwoYyxkKX0pfSl9KGpRdWVyeSk7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc2NyaXB0cy92ZW5kb3JzL2Jvb3RzdHJhcC5taW4uanMiLCJyZXF1aXJlKCdrbm9ja291dC52YWxpZGF0aW9uJyk7XHJcblxyXG5rby52YWxpZGF0aW9uLnJ1bGVzLnBhdHRlcm4ubWVzc2FnZSA9ICdJbnZhbGlkLic7XHJcblxyXG5rby52YWxpZGF0aW9uLmluaXQoe1xyXG5cdHJlZ2lzdGVyRXh0ZW5kZXJzOiB0cnVlLFxyXG5cdG1lc3NhZ2VzT25Nb2RpZmllZDogdHJ1ZSxcclxuXHRkZWNvcmF0ZUlucHV0RWxlbWVudDogdHJ1ZSxcclxuXHRlcnJvck1lc3NhZ2VDbGFzczogJ2N1c3RvbS1pbnB1dF9fdmFsaWRhdGlvbi1tZXNzYWdlJyxcclxuXHRlcnJvckVsZW1lbnRDbGFzczogJ25vdC12YWxpZCcsXHJcblx0aW5zZXJ0TWVzc2FnZXM6IGZhbHNlLFxyXG5cdHBhcnNlSW5wdXRBdHRyaWJ1dGVzOiB0cnVlLFxyXG5cdG1lc3NhZ2VUZW1wbGF0ZTogbnVsbCxcclxuXHRncm91cGluZzoge1xyXG5cdFx0ZGVlcDogdHJ1ZSxcclxuXHRcdGxpdmU6IHRydWUsXHJcblx0XHRvYnNlcnZhYmxlOiB0cnVlXHJcblx0fVxyXG59LCB0cnVlKTtcclxuXHJcbmtvLnZhbGlkYXRpb24ucnVsZXNbJ251bGxhYmxlSW50J10gPSB7XHJcblx0dmFsaWRhdG9yOiBmdW5jdGlvbiAodmFsLCB2YWxpZGF0ZSkge1xyXG5cdFx0cmV0dXJuIHZhbCA9PT0gbnVsbCB8fCB2YWwgPT09IFwiXCIgfHwgKHZhbGlkYXRlICYmIC9eLT9cXGQqJC8udGVzdCh2YWwudG9TdHJpbmcoKSkpO1xyXG5cdH0sXHJcblx0bWVzc2FnZTogJ011c3QgYmUgZW1wdHkgb3IgYW4gaW50ZWdlciB2YWx1ZSdcclxufTtcclxuXHJcbmtvLnZhbGlkYXRpb24ucnVsZXNbJ251bGxhYmxlRGVjaW1hbCddID0ge1xyXG5cdHZhbGlkYXRvcjogZnVuY3Rpb24gKHZhbCwgdmFsaWRhdGUpIHtcclxuXHRcdHJldHVybiB2YWwgPT09IG51bGwgfHwgdmFsID09PSBcIlwiIHx8ICh2YWxpZGF0ZSAmJiAvXi0/XFxkKig/OlxcLlxcZCopPyQvLnRlc3QodmFsLnRvU3RyaW5nKCkpKTtcclxuXHR9LFxyXG5cdG1lc3NhZ2U6ICdNdXN0IGJlIGVtcHR5IG9yIGEgZGVjaW1hbCB2YWx1ZSdcclxufTtcclxuXHJcbmtvLnZhbGlkYXRpb24ucmVnaXN0ZXJFeHRlbmRlcnMoKTtcclxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc2NyaXB0cy9hcGktZXhwbG9yZXIvdjIvc3JjL21vZHVsZXMvdmFsaWRhdGlvbi5qcyIsIi8qPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblx0QXV0aG9yOlx0XHRcdEVyaWMgTS4gQmFybmFyZCAtIEBlcmljbWJhcm5hcmRcdFx0XHRcdFx0XHRcdFx0XG5cdExpY2Vuc2U6XHRcdE1JVCAoaHR0cDovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocClcdFx0XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XG5cdERlc2NyaXB0aW9uOlx0VmFsaWRhdGlvbiBMaWJyYXJ5IGZvciBLbm9ja291dEpTXHRcdFx0XHRcdFx0XHRcblx0VmVyc2lvbjpcdFx0Mi4wLjNcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XG49PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4qL1xuLypnbG9iYWxzIHJlcXVpcmU6IGZhbHNlLCBleHBvcnRzOiBmYWxzZSwgZGVmaW5lOiBmYWxzZSwga286IGZhbHNlICovXG5cbihmdW5jdGlvbiAoZmFjdG9yeSkge1xuXHQvLyBNb2R1bGUgc3lzdGVtcyBtYWdpYyBkYW5jZS5cblxuXHRpZiAodHlwZW9mIHJlcXVpcmUgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgZXhwb3J0cyA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgbW9kdWxlID09PSBcIm9iamVjdFwiKSB7XG5cdFx0Ly8gQ29tbW9uSlMgb3IgTm9kZTogaGFyZC1jb2RlZCBkZXBlbmRlbmN5IG9uIFwia25vY2tvdXRcIlxuXHRcdGZhY3RvcnkocmVxdWlyZShcImtub2Nrb3V0XCIpLCBleHBvcnRzKTtcblx0fSBlbHNlIGlmICh0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lW1wiYW1kXCJdKSB7XG5cdFx0Ly8gQU1EIGFub255bW91cyBtb2R1bGUgd2l0aCBoYXJkLWNvZGVkIGRlcGVuZGVuY3kgb24gXCJrbm9ja291dFwiXG5cdFx0ZGVmaW5lKFtcImtub2Nrb3V0XCIsIFwiZXhwb3J0c1wiXSwgZmFjdG9yeSk7XG5cdH0gZWxzZSB7XG5cdFx0Ly8gPHNjcmlwdD4gdGFnOiB1c2UgdGhlIGdsb2JhbCBga29gIG9iamVjdCwgYXR0YWNoaW5nIGEgYG1hcHBpbmdgIHByb3BlcnR5XG5cdFx0ZmFjdG9yeShrbywga28udmFsaWRhdGlvbiA9IHt9KTtcblx0fVxufShmdW5jdGlvbiAoIGtvLCBleHBvcnRzICkge1xuXG5cdGlmICh0eXBlb2YgKGtvKSA9PT0gJ3VuZGVmaW5lZCcpIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoJ0tub2Nrb3V0IGlzIHJlcXVpcmVkLCBwbGVhc2UgZW5zdXJlIGl0IGlzIGxvYWRlZCBiZWZvcmUgbG9hZGluZyB0aGlzIHZhbGlkYXRpb24gcGx1Zy1pbicpO1xuXHR9XG5cblx0Ly8gY3JlYXRlIG91ciBuYW1lc3BhY2Ugb2JqZWN0XG5cdGtvLnZhbGlkYXRpb24gPSBleHBvcnRzO1xuXG5cdHZhciBrdiA9IGtvLnZhbGlkYXRpb24sXG5cdFx0a29VdGlscyA9IGtvLnV0aWxzLFxuXHRcdHVud3JhcCA9IGtvVXRpbHMudW53cmFwT2JzZXJ2YWJsZSxcblx0XHRmb3JFYWNoID0ga29VdGlscy5hcnJheUZvckVhY2gsXG5cdFx0ZXh0ZW5kID0ga29VdGlscy5leHRlbmQ7XG47LypnbG9iYWwga286IGZhbHNlKi9cblxudmFyIGRlZmF1bHRzID0ge1xuXHRyZWdpc3RlckV4dGVuZGVyczogdHJ1ZSxcblx0bWVzc2FnZXNPbk1vZGlmaWVkOiB0cnVlLFxuXHRlcnJvcnNBc1RpdGxlOiB0cnVlLCAgICAgICAgICAgIC8vIGVuYWJsZXMvZGlzYWJsZXMgc2hvd2luZyBvZiBlcnJvcnMgYXMgdGl0bGUgYXR0cmlidXRlIG9mIHRoZSB0YXJnZXQgZWxlbWVudC5cblx0ZXJyb3JzQXNUaXRsZU9uTW9kaWZpZWQ6IGZhbHNlLCAvLyBzaG93cyB0aGUgZXJyb3Igd2hlbiBob3ZlcmluZyB0aGUgaW5wdXQgZmllbGQgKGRlY29yYXRlRWxlbWVudCBtdXN0IGJlIHRydWUpXG5cdG1lc3NhZ2VUZW1wbGF0ZTogbnVsbCxcblx0aW5zZXJ0TWVzc2FnZXM6IHRydWUsICAgICAgICAgICAvLyBhdXRvbWF0aWNhbGx5IGluc2VydHMgdmFsaWRhdGlvbiBtZXNzYWdlcyBhcyA8c3Bhbj48L3NwYW4+XG5cdHBhcnNlSW5wdXRBdHRyaWJ1dGVzOiBmYWxzZSwgICAgLy8gcGFyc2VzIHRoZSBIVE1MNSB2YWxpZGF0aW9uIGF0dHJpYnV0ZSBmcm9tIGEgZm9ybSBlbGVtZW50IGFuZCBhZGRzIHRoYXQgdG8gdGhlIG9iamVjdFxuXHR3cml0ZUlucHV0QXR0cmlidXRlczogZmFsc2UsICAgIC8vIGFkZHMgSFRNTDUgaW5wdXQgdmFsaWRhdGlvbiBhdHRyaWJ1dGVzIHRvIGZvcm0gZWxlbWVudHMgdGhhdCBrbyBvYnNlcnZhYmxlJ3MgYXJlIGJvdW5kIHRvXG5cdGRlY29yYXRlSW5wdXRFbGVtZW50OiBmYWxzZSwgICAgICAgICAvLyBmYWxzZSB0byBrZWVwIGJhY2t3YXJkIGNvbXBhdGliaWxpdHlcblx0ZGVjb3JhdGVFbGVtZW50T25Nb2RpZmllZDogdHJ1ZSwvLyB0cnVlIHRvIGtlZXAgYmFja3dhcmQgY29tcGF0aWJpbGl0eVxuXHRlcnJvckNsYXNzOiBudWxsLCAgICAgICAgICAgICAgIC8vIHNpbmdsZSBjbGFzcyBmb3IgZXJyb3IgbWVzc2FnZSBhbmQgZWxlbWVudFxuXHRlcnJvckVsZW1lbnRDbGFzczogJ3ZhbGlkYXRpb25FbGVtZW50JywgIC8vIGNsYXNzIHRvIGRlY29yYXRlIGVycm9yIGVsZW1lbnRcblx0ZXJyb3JNZXNzYWdlQ2xhc3M6ICd2YWxpZGF0aW9uTWVzc2FnZScsICAvLyBjbGFzcyB0byBkZWNvcmF0ZSBlcnJvciBtZXNzYWdlXG5cdGFsbG93SHRtbE1lc3NhZ2VzOiBmYWxzZSxcdFx0Ly8gYWxsb3dzIEhUTUwgaW4gdmFsaWRhdGlvbiBtZXNzYWdlc1xuXHRncm91cGluZzoge1xuXHRcdGRlZXA6IGZhbHNlLCAgICAgICAgLy9ieSBkZWZhdWx0IGdyb3VwaW5nIGlzIHNoYWxsb3dcblx0XHRvYnNlcnZhYmxlOiB0cnVlLCAgIC8vYW5kIHVzaW5nIG9ic2VydmFibGVzXG5cdFx0bGl2ZTogZmFsc2VcdFx0ICAgIC8vcmVhY3QgdG8gY2hhbmdlcyB0byBvYnNlcnZhYmxlQXJyYXlzIGlmIG9ic2VydmFibGUgPT09IHRydWVcblx0fSxcblx0dmFsaWRhdGU6IHtcblx0XHQvLyB0aHJvdHRsZTogMTBcblx0fVxufTtcblxuLy8gbWFrZSBhIGNvcHkgIHNvIHdlIGNhbiB1c2UgJ3Jlc2V0JyBsYXRlclxudmFyIGNvbmZpZ3VyYXRpb24gPSBleHRlbmQoe30sIGRlZmF1bHRzKTtcblxuY29uZmlndXJhdGlvbi5odG1sNUF0dHJpYnV0ZXMgPSBbJ3JlcXVpcmVkJywgJ3BhdHRlcm4nLCAnbWluJywgJ21heCcsICdzdGVwJ107XG5jb25maWd1cmF0aW9uLmh0bWw1SW5wdXRUeXBlcyA9IFsnZW1haWwnLCAnbnVtYmVyJywgJ2RhdGUnXTtcblxuY29uZmlndXJhdGlvbi5yZXNldCA9IGZ1bmN0aW9uICgpIHtcblx0ZXh0ZW5kKGNvbmZpZ3VyYXRpb24sIGRlZmF1bHRzKTtcbn07XG5cbmt2LmNvbmZpZ3VyYXRpb24gPSBjb25maWd1cmF0aW9uO1xuO2t2LnV0aWxzID0gKGZ1bmN0aW9uICgpIHtcblx0dmFyIHNlZWRJZCA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuXG5cdHZhciBkb21EYXRhID0ge307IC8vaGFzaCBvZiBkYXRhIG9iamVjdHMgdGhhdCB3ZSByZWZlcmVuY2UgZnJvbSBkb20gZWxlbWVudHNcblx0dmFyIGRvbURhdGFLZXkgPSAnX19rb192YWxpZGF0aW9uX18nO1xuXG5cdHJldHVybiB7XG5cdFx0aXNBcnJheTogZnVuY3Rpb24gKG8pIHtcblx0XHRcdHJldHVybiBvLmlzQXJyYXkgfHwgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pID09PSAnW29iamVjdCBBcnJheV0nO1xuXHRcdH0sXG5cdFx0aXNPYmplY3Q6IGZ1bmN0aW9uIChvKSB7XG5cdFx0XHRyZXR1cm4gbyAhPT0gbnVsbCAmJiB0eXBlb2YgbyA9PT0gJ29iamVjdCc7XG5cdFx0fSxcblx0XHRpc051bWJlcjogZnVuY3Rpb24obykge1xuXHRcdFx0cmV0dXJuICFpc05hTihvKTtcdFxuXHRcdH0sXG5cdFx0aXNPYnNlcnZhYmxlQXJyYXk6IGZ1bmN0aW9uKGluc3RhbmNlKSB7XG5cdFx0XHRyZXR1cm4gISFpbnN0YW5jZSAmJlxuXHRcdFx0XHRcdHR5cGVvZiBpbnN0YW5jZVtcInJlbW92ZVwiXSA9PT0gXCJmdW5jdGlvblwiICYmXG5cdFx0XHRcdFx0dHlwZW9mIGluc3RhbmNlW1wicmVtb3ZlQWxsXCJdID09PSBcImZ1bmN0aW9uXCIgJiZcblx0XHRcdFx0XHR0eXBlb2YgaW5zdGFuY2VbXCJkZXN0cm95XCJdID09PSBcImZ1bmN0aW9uXCIgJiZcblx0XHRcdFx0XHR0eXBlb2YgaW5zdGFuY2VbXCJkZXN0cm95QWxsXCJdID09PSBcImZ1bmN0aW9uXCIgJiZcblx0XHRcdFx0XHR0eXBlb2YgaW5zdGFuY2VbXCJpbmRleE9mXCJdID09PSBcImZ1bmN0aW9uXCIgJiZcblx0XHRcdFx0XHR0eXBlb2YgaW5zdGFuY2VbXCJyZXBsYWNlXCJdID09PSBcImZ1bmN0aW9uXCI7XG5cdFx0fSxcblx0XHR2YWx1ZXM6IGZ1bmN0aW9uIChvKSB7XG5cdFx0XHR2YXIgciA9IFtdO1xuXHRcdFx0Zm9yICh2YXIgaSBpbiBvKSB7XG5cdFx0XHRcdGlmIChvLmhhc093blByb3BlcnR5KGkpKSB7XG5cdFx0XHRcdFx0ci5wdXNoKG9baV0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcjtcblx0XHR9LFxuXHRcdGdldFZhbHVlOiBmdW5jdGlvbiAobykge1xuXHRcdFx0cmV0dXJuICh0eXBlb2YgbyA9PT0gJ2Z1bmN0aW9uJyA/IG8oKSA6IG8pO1xuXHRcdH0sXG5cdFx0aGFzQXR0cmlidXRlOiBmdW5jdGlvbiAobm9kZSwgYXR0cikge1xuXHRcdFx0cmV0dXJuIG5vZGUuZ2V0QXR0cmlidXRlKGF0dHIpICE9PSBudWxsO1xuXHRcdH0sXG5cdFx0Z2V0QXR0cmlidXRlOiBmdW5jdGlvbiAoZWxlbWVudCwgYXR0cikge1xuXHRcdFx0cmV0dXJuIGVsZW1lbnQuZ2V0QXR0cmlidXRlKGF0dHIpO1xuXHRcdH0sXG5cdFx0c2V0QXR0cmlidXRlOiBmdW5jdGlvbiAoZWxlbWVudCwgYXR0ciwgdmFsdWUpIHtcblx0XHRcdHJldHVybiBlbGVtZW50LnNldEF0dHJpYnV0ZShhdHRyLCB2YWx1ZSk7XG5cdFx0fSxcblx0XHRpc1ZhbGlkYXRhYmxlOiBmdW5jdGlvbiAobykge1xuXHRcdFx0cmV0dXJuICEhKG8gJiYgby5ydWxlcyAmJiBvLmlzVmFsaWQgJiYgby5pc01vZGlmaWVkKTtcblx0XHR9LFxuXHRcdGluc2VydEFmdGVyOiBmdW5jdGlvbiAobm9kZSwgbmV3Tm9kZSkge1xuXHRcdFx0bm9kZS5wYXJlbnROb2RlLmluc2VydEJlZm9yZShuZXdOb2RlLCBub2RlLm5leHRTaWJsaW5nKTtcblx0XHR9LFxuXHRcdG5ld0lkOiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRyZXR1cm4gc2VlZElkICs9IDE7XG5cdFx0fSxcblx0XHRnZXRDb25maWdPcHRpb25zOiBmdW5jdGlvbiAoZWxlbWVudCkge1xuXHRcdFx0dmFyIG9wdGlvbnMgPSBrdi51dGlscy5jb250ZXh0Rm9yKGVsZW1lbnQpO1xuXG5cdFx0XHRyZXR1cm4gb3B0aW9ucyB8fCBrdi5jb25maWd1cmF0aW9uO1xuXHRcdH0sXG5cdFx0c2V0RG9tRGF0YTogZnVuY3Rpb24gKG5vZGUsIGRhdGEpIHtcblx0XHRcdHZhciBrZXkgPSBub2RlW2RvbURhdGFLZXldO1xuXG5cdFx0XHRpZiAoIWtleSkge1xuXHRcdFx0XHRub2RlW2RvbURhdGFLZXldID0ga2V5ID0ga3YudXRpbHMubmV3SWQoKTtcblx0XHRcdH1cblxuXHRcdFx0ZG9tRGF0YVtrZXldID0gZGF0YTtcblx0XHR9LFxuXHRcdGdldERvbURhdGE6IGZ1bmN0aW9uIChub2RlKSB7XG5cdFx0XHR2YXIga2V5ID0gbm9kZVtkb21EYXRhS2V5XTtcblxuXHRcdFx0aWYgKCFrZXkpIHtcblx0XHRcdFx0cmV0dXJuIHVuZGVmaW5lZDtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGRvbURhdGFba2V5XTtcblx0XHR9LFxuXHRcdGNvbnRleHRGb3I6IGZ1bmN0aW9uIChub2RlKSB7XG5cdFx0XHRzd2l0Y2ggKG5vZGUubm9kZVR5cGUpIHtcblx0XHRcdFx0Y2FzZSAxOlxuXHRcdFx0XHRjYXNlIDg6XG5cdFx0XHRcdFx0dmFyIGNvbnRleHQgPSBrdi51dGlscy5nZXREb21EYXRhKG5vZGUpO1xuXHRcdFx0XHRcdGlmIChjb250ZXh0KSB7IHJldHVybiBjb250ZXh0OyB9XG5cdFx0XHRcdFx0aWYgKG5vZGUucGFyZW50Tm9kZSkgeyByZXR1cm4ga3YudXRpbHMuY29udGV4dEZvcihub2RlLnBhcmVudE5vZGUpOyB9XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdW5kZWZpbmVkO1xuXHRcdH0sXG5cdFx0aXNFbXB0eVZhbDogZnVuY3Rpb24gKHZhbCkge1xuXHRcdFx0aWYgKHZhbCA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fVxuXHRcdFx0aWYgKHZhbCA9PT0gbnVsbCkge1xuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblx0XHRcdGlmICh2YWwgPT09IFwiXCIpIHtcblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRnZXRPcmlnaW5hbEVsZW1lbnRUaXRsZTogZnVuY3Rpb24gKGVsZW1lbnQpIHtcblx0XHRcdHZhciBzYXZlZE9yaWdpbmFsVGl0bGUgPSBrdi51dGlscy5nZXRBdHRyaWJ1dGUoZWxlbWVudCwgJ2RhdGEtb3JpZy10aXRsZScpLFxuXHRcdFx0XHRjdXJyZW50VGl0bGUgPSBlbGVtZW50LnRpdGxlLFxuXHRcdFx0XHRoYXNTYXZlZE9yaWdpbmFsVGl0bGUgPSBrdi51dGlscy5oYXNBdHRyaWJ1dGUoZWxlbWVudCwgJ2RhdGEtb3JpZy10aXRsZScpO1xuXG5cdFx0XHRyZXR1cm4gaGFzU2F2ZWRPcmlnaW5hbFRpdGxlID9cblx0XHRcdFx0c2F2ZWRPcmlnaW5hbFRpdGxlIDogY3VycmVudFRpdGxlO1xuXHRcdH0sXG5cdFx0YXN5bmM6IGZ1bmN0aW9uIChleHByKSB7XG5cdFx0XHRpZiAod2luZG93LnNldEltbWVkaWF0ZSkgeyB3aW5kb3cuc2V0SW1tZWRpYXRlKGV4cHIpOyB9XG5cdFx0XHRlbHNlIHsgd2luZG93LnNldFRpbWVvdXQoZXhwciwgMCk7IH1cblx0XHR9LFxuXHRcdGZvckVhY2g6IGZ1bmN0aW9uIChvYmplY3QsIGNhbGxiYWNrKSB7XG5cdFx0XHRpZiAoa3YudXRpbHMuaXNBcnJheShvYmplY3QpKSB7XG5cdFx0XHRcdHJldHVybiBmb3JFYWNoKG9iamVjdCwgY2FsbGJhY2spO1xuXHRcdFx0fVxuXHRcdFx0Zm9yICh2YXIgcHJvcCBpbiBvYmplY3QpIHtcblx0XHRcdFx0aWYgKG9iamVjdC5oYXNPd25Qcm9wZXJ0eShwcm9wKSkge1xuXHRcdFx0XHRcdGNhbGxiYWNrKG9iamVjdFtwcm9wXSwgcHJvcCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH07XG59KCkpOzt2YXIgYXBpID0gKGZ1bmN0aW9uICgpIHtcblxuXHR2YXIgaXNJbml0aWFsaXplZCA9IDAsXG5cdFx0Y29uZmlndXJhdGlvbiA9IGt2LmNvbmZpZ3VyYXRpb24sXG5cdFx0dXRpbHMgPSBrdi51dGlscztcblxuXHRmdW5jdGlvbiBjbGVhblVwU3Vic2NyaXB0aW9ucyhjb250ZXh0KSB7XG5cdFx0Zm9yRWFjaChjb250ZXh0LnN1YnNjcmlwdGlvbnMsIGZ1bmN0aW9uIChzdWJzY3JpcHRpb24pIHtcblx0XHRcdHN1YnNjcmlwdGlvbi5kaXNwb3NlKCk7XG5cdFx0fSk7XG5cdFx0Y29udGV4dC5zdWJzY3JpcHRpb25zID0gW107XG5cdH1cblxuXHRmdW5jdGlvbiBkaXNwb3NlKGNvbnRleHQpIHtcblx0XHRpZiAoY29udGV4dC5vcHRpb25zLmRlZXApIHtcblx0XHRcdGZvckVhY2goY29udGV4dC5mbGFnZ2VkLCBmdW5jdGlvbiAob2JqKSB7XG5cdFx0XHRcdGRlbGV0ZSBvYmouX19rdl90cmF2ZXJzZWQ7XG5cdFx0XHR9KTtcblx0XHRcdGNvbnRleHQuZmxhZ2dlZC5sZW5ndGggPSAwO1xuXHRcdH1cblxuXHRcdGlmICghY29udGV4dC5vcHRpb25zLmxpdmUpIHtcblx0XHRcdGNsZWFuVXBTdWJzY3JpcHRpb25zKGNvbnRleHQpO1xuXHRcdH1cblx0fVxuXG5cdGZ1bmN0aW9uIHJ1blRyYXZlcnNhbChvYmosIGNvbnRleHQpIHtcblx0XHRjb250ZXh0LnZhbGlkYXRhYmxlcyA9IFtdO1xuXHRcdGNsZWFuVXBTdWJzY3JpcHRpb25zKGNvbnRleHQpO1xuXHRcdHRyYXZlcnNlR3JhcGgob2JqLCBjb250ZXh0KTtcblx0XHRkaXNwb3NlKGNvbnRleHQpO1xuXHR9XG5cblx0ZnVuY3Rpb24gdHJhdmVyc2VHcmFwaChvYmosIGNvbnRleHQsIGxldmVsKSB7XG5cdFx0dmFyIG9ialZhbHVlcyA9IFtdLFxuXHRcdFx0dmFsID0gb2JqLnBlZWsgPyBvYmoucGVlaygpIDogb2JqO1xuXG5cdFx0aWYgKG9iai5fX2t2X3RyYXZlcnNlZCA9PT0gdHJ1ZSkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGlmIChjb250ZXh0Lm9wdGlvbnMuZGVlcCkge1xuXHRcdFx0b2JqLl9fa3ZfdHJhdmVyc2VkID0gdHJ1ZTtcblx0XHRcdGNvbnRleHQuZmxhZ2dlZC5wdXNoKG9iaik7XG5cdFx0fVxuXG5cdFx0Ly9kZWZhdWx0IGxldmVsIHZhbHVlIGRlcGVuZHMgb24gZGVlcCBvcHRpb24uXG5cdFx0bGV2ZWwgPSAobGV2ZWwgIT09IHVuZGVmaW5lZCA/IGxldmVsIDogY29udGV4dC5vcHRpb25zLmRlZXAgPyAxIDogLTEpO1xuXG5cdFx0Ly8gaWYgb2JqZWN0IGlzIG9ic2VydmFibGUgdGhlbiBhZGQgaXQgdG8gdGhlIGxpc3Rcblx0XHRpZiAoa28uaXNPYnNlcnZhYmxlKG9iaikpIHtcblx0XHRcdC8vIGVuc3VyZSBpdCdzIHZhbGlkYXRhYmxlIGJ1dCBkb24ndCBleHRlbmQgdmFsaWRhdGVkT2JzZXJ2YWJsZSBiZWNhdXNlIGl0XG5cdFx0XHQvLyB3b3VsZCBvdmVyd3JpdGUgaXNWYWxpZCBwcm9wZXJ0eS5cblx0XHRcdGlmICghb2JqLmVycm9ycyAmJiAhdXRpbHMuaXNWYWxpZGF0YWJsZShvYmopKSB7XG5cdFx0XHRcdG9iai5leHRlbmQoeyB2YWxpZGF0YWJsZTogdHJ1ZSB9KTtcblx0XHRcdH1cblx0XHRcdGNvbnRleHQudmFsaWRhdGFibGVzLnB1c2gob2JqKTtcblxuXHRcdFx0aWYgKGNvbnRleHQub3B0aW9ucy5saXZlICYmIHV0aWxzLmlzT2JzZXJ2YWJsZUFycmF5KG9iaikpIHtcblx0XHRcdFx0Y29udGV4dC5zdWJzY3JpcHRpb25zLnB1c2gob2JqLnN1YnNjcmliZShmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdFx0Y29udGV4dC5ncmFwaE1vbml0b3IudmFsdWVIYXNNdXRhdGVkKCk7XG5cdFx0XHRcdH0pKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvL2dldCBsaXN0IG9mIHZhbHVlcyBlaXRoZXIgZnJvbSBhcnJheSBvciBvYmplY3QgYnV0IGlnbm9yZSBub24tb2JqZWN0c1xuXHRcdC8vIGFuZCBkZXN0cm95ZWQgb2JqZWN0c1xuXHRcdGlmICh2YWwgJiYgIXZhbC5fZGVzdHJveSkge1xuXHRcdFx0aWYgKHV0aWxzLmlzQXJyYXkodmFsKSkge1xuXHRcdFx0XHRvYmpWYWx1ZXMgPSB2YWw7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIGlmICh1dGlscy5pc09iamVjdCh2YWwpKSB7XG5cdFx0XHRcdG9ialZhbHVlcyA9IHV0aWxzLnZhbHVlcyh2YWwpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vcHJvY2VzcyByZWN1cnNpdmVseSBpZiBpdCBpcyBkZWVwIGdyb3VwaW5nXG5cdFx0aWYgKGxldmVsICE9PSAwKSB7XG5cdFx0XHR1dGlscy5mb3JFYWNoKG9ialZhbHVlcywgZnVuY3Rpb24gKG9ic2VydmFibGUpIHtcblx0XHRcdFx0Ly9idXQgbm90IGZhbHN5IHRoaW5ncyBhbmQgbm90IEhUTUwgRWxlbWVudHNcblx0XHRcdFx0aWYgKG9ic2VydmFibGUgJiYgIW9ic2VydmFibGUubm9kZVR5cGUgJiYgKCFrby5pc0NvbXB1dGVkKG9ic2VydmFibGUpIHx8IG9ic2VydmFibGUucnVsZXMpKSB7XG5cdFx0XHRcdFx0dHJhdmVyc2VHcmFwaChvYnNlcnZhYmxlLCBjb250ZXh0LCBsZXZlbCArIDEpO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHR9XG5cdH1cblxuXHRmdW5jdGlvbiBjb2xsZWN0RXJyb3JzKGFycmF5KSB7XG5cdFx0dmFyIGVycm9ycyA9IFtdO1xuXHRcdGZvckVhY2goYXJyYXksIGZ1bmN0aW9uIChvYnNlcnZhYmxlKSB7XG5cdFx0XHQvLyBEbyBub3QgY29sbGVjdCB2YWxpZGF0ZWRPYnNlcnZhYmxlIGVycm9yc1xuXHRcdFx0aWYgKHV0aWxzLmlzVmFsaWRhdGFibGUob2JzZXJ2YWJsZSkgJiYgIW9ic2VydmFibGUuaXNWYWxpZCgpKSB7XG5cdFx0XHRcdC8vIFVzZSBwZWVrIGJlY2F1c2Ugd2UgZG9uJ3Qgd2FudCBhIGRlcGVuZGVuY3kgZm9yICdlcnJvcicgcHJvcGVydHkgYmVjYXVzZSBpdFxuXHRcdFx0XHQvLyBjaGFuZ2VzIGJlZm9yZSAnaXNWYWxpZCcgZG9lcy4gKElzc3VlICM5OSlcblx0XHRcdFx0ZXJyb3JzLnB1c2gob2JzZXJ2YWJsZS5lcnJvci5wZWVrKCkpO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHRcdHJldHVybiBlcnJvcnM7XG5cdH1cblxuXHRyZXR1cm4ge1xuXHRcdC8vQ2FsbCB0aGlzIG9uIHN0YXJ0dXBcblx0XHQvL2FueSBjb25maWcgY2FuIGJlIG92ZXJyaWRkZW4gd2l0aCB0aGUgcGFzc2VkIGluIG9wdGlvbnNcblx0XHRpbml0OiBmdW5jdGlvbiAob3B0aW9ucywgZm9yY2UpIHtcblx0XHRcdC8vZG9uZSBydW4gdGhpcyBtdWx0aXBsZSB0aW1lcyBpZiB3ZSBkb24ndCByZWFsbHkgd2FudCB0b1xuXHRcdFx0aWYgKGlzSW5pdGlhbGl6ZWQgPiAwICYmICFmb3JjZSkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdC8vYmVjYXVzZSB3ZSB3aWxsIGJlIGFjY2Vzc2luZyBvcHRpb25zIHByb3BlcnRpZXMgaXQgaGFzIHRvIGJlIGFuIG9iamVjdCBhdCBsZWFzdFxuXHRcdFx0b3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cdFx0XHQvL2lmIHNwZWNpZmljIGVycm9yIGNsYXNzZXMgYXJlIG5vdCBwcm92aWRlZCB0aGVuIGFwcGx5IGdlbmVyaWMgZXJyb3JDbGFzc1xuXHRcdFx0Ly9pdCBoYXMgdG8gYmUgZG9uZSBvbiBvcHRpb24gc28gdGhhdCBvcHRpb25zLmVycm9yQ2xhc3MgY2FuIG92ZXJyaWRlIGRlZmF1bHRcblx0XHRcdC8vZXJyb3JFbGVtZW50Q2xhc3MgYW5kIGVycm9yTWVzc2FnZSBjbGFzcyBidXQgbm90IHRob3NlIHByb3ZpZGVkIGluIG9wdGlvbnNcblx0XHRcdG9wdGlvbnMuZXJyb3JFbGVtZW50Q2xhc3MgPSBvcHRpb25zLmVycm9yRWxlbWVudENsYXNzIHx8IG9wdGlvbnMuZXJyb3JDbGFzcyB8fCBjb25maWd1cmF0aW9uLmVycm9yRWxlbWVudENsYXNzO1xuXHRcdFx0b3B0aW9ucy5lcnJvck1lc3NhZ2VDbGFzcyA9IG9wdGlvbnMuZXJyb3JNZXNzYWdlQ2xhc3MgfHwgb3B0aW9ucy5lcnJvckNsYXNzIHx8IGNvbmZpZ3VyYXRpb24uZXJyb3JNZXNzYWdlQ2xhc3M7XG5cblx0XHRcdGV4dGVuZChjb25maWd1cmF0aW9uLCBvcHRpb25zKTtcblxuXHRcdFx0aWYgKGNvbmZpZ3VyYXRpb24ucmVnaXN0ZXJFeHRlbmRlcnMpIHtcblx0XHRcdFx0a3YucmVnaXN0ZXJFeHRlbmRlcnMoKTtcblx0XHRcdH1cblxuXHRcdFx0aXNJbml0aWFsaXplZCA9IDE7XG5cdFx0fSxcblxuXHRcdC8vIHJlc2V0cyB0aGUgY29uZmlnIGJhY2sgdG8gaXRzIG9yaWdpbmFsIHN0YXRlXG5cdFx0cmVzZXQ6IGt2LmNvbmZpZ3VyYXRpb24ucmVzZXQsXG5cblx0XHQvLyByZWN1cnNpdmVseSB3YWxrcyBhIHZpZXdNb2RlbCBhbmQgY3JlYXRlcyBhbiBvYmplY3QgdGhhdFxuXHRcdC8vIHByb3ZpZGVzIHZhbGlkYXRpb24gaW5mb3JtYXRpb24gZm9yIHRoZSBlbnRpcmUgdmlld01vZGVsXG5cdFx0Ly8gb2JqIC0+IHRoZSB2aWV3TW9kZWwgdG8gd2Fsa1xuXHRcdC8vIG9wdGlvbnMgLT4ge1xuXHRcdC8vXHQgIGRlZXA6IGZhbHNlLCAvLyBpZiB0cnVlLCB3aWxsIHdhbGsgcGFzdCB0aGUgZmlyc3QgbGV2ZWwgb2Ygdmlld01vZGVsIHByb3BlcnRpZXNcblx0XHQvL1x0ICBvYnNlcnZhYmxlOiBmYWxzZSAvLyBpZiB0cnVlLCByZXR1cm5zIGEgY29tcHV0ZWQgb2JzZXJ2YWJsZSBpbmRpY2F0aW5nIGlmIHRoZSB2aWV3TW9kZWwgaXMgdmFsaWRcblx0XHQvLyB9XG5cdFx0Z3JvdXA6IGZ1bmN0aW9uIGdyb3VwKG9iaiwgb3B0aW9ucykgeyAvLyBhcnJheSBvZiBvYnNlcnZhYmxlcyBvciB2aWV3TW9kZWxcblx0XHRcdG9wdGlvbnMgPSBleHRlbmQoZXh0ZW5kKHt9LCBjb25maWd1cmF0aW9uLmdyb3VwaW5nKSwgb3B0aW9ucyk7XG5cblx0XHRcdHZhciBjb250ZXh0ID0ge1xuXHRcdFx0XHRvcHRpb25zOiBvcHRpb25zLFxuXHRcdFx0XHRncmFwaE1vbml0b3I6IGtvLm9ic2VydmFibGUoKSxcblx0XHRcdFx0ZmxhZ2dlZDogW10sXG5cdFx0XHRcdHN1YnNjcmlwdGlvbnM6IFtdLFxuXHRcdFx0XHR2YWxpZGF0YWJsZXM6IFtdXG5cdFx0XHR9O1xuXG5cdFx0XHR2YXIgcmVzdWx0ID0gbnVsbDtcblxuXHRcdFx0Ly9pZiB1c2luZyBvYnNlcnZhYmxlcyB0aGVuIHRyYXZlcnNlIHN0cnVjdHVyZSBvbmNlIGFuZCBhZGQgb2JzZXJ2YWJsZXNcblx0XHRcdGlmIChvcHRpb25zLm9ic2VydmFibGUpIHtcblx0XHRcdFx0cmVzdWx0ID0ga28uY29tcHV0ZWQoZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdGNvbnRleHQuZ3JhcGhNb25pdG9yKCk7IC8vcmVnaXN0ZXIgZGVwZW5kZW5jeVxuXHRcdFx0XHRcdHJ1blRyYXZlcnNhbChvYmosIGNvbnRleHQpO1xuXHRcdFx0XHRcdHJldHVybiBjb2xsZWN0RXJyb3JzKGNvbnRleHQudmFsaWRhdGFibGVzKTtcblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIHsgLy9pZiBub3QgdXNpbmcgb2JzZXJ2YWJsZXMgdGhlbiBldmVyeSBjYWxsIHRvIGVycm9yKCkgc2hvdWxkIHRyYXZlcnNlIHRoZSBzdHJ1Y3R1cmVcblx0XHRcdFx0cmVzdWx0ID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdHJ1blRyYXZlcnNhbChvYmosIGNvbnRleHQpO1xuXHRcdFx0XHRcdHJldHVybiBjb2xsZWN0RXJyb3JzKGNvbnRleHQudmFsaWRhdGFibGVzKTtcblx0XHRcdFx0fTtcblx0XHRcdH1cblxuXHRcdFx0cmVzdWx0LnNob3dBbGxNZXNzYWdlcyA9IGZ1bmN0aW9uIChzaG93KSB7IC8vIHRoYW5rcyBAaGVsaW9zUG9ydGFsXG5cdFx0XHRcdGlmIChzaG93ID09PSB1bmRlZmluZWQpIHsvL2RlZmF1bHQgdG8gdHJ1ZVxuXHRcdFx0XHRcdHNob3cgPSB0cnVlO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmVzdWx0LmZvckVhY2goZnVuY3Rpb24gKG9ic2VydmFibGUpIHtcblx0XHRcdFx0XHRpZiAodXRpbHMuaXNWYWxpZGF0YWJsZShvYnNlcnZhYmxlKSkge1xuXHRcdFx0XHRcdFx0b2JzZXJ2YWJsZS5pc01vZGlmaWVkKHNob3cpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSk7XG5cdFx0XHR9O1xuXG5cdFx0XHRyZXN1bHQuaXNBbnlNZXNzYWdlU2hvd24gPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdHZhciBpbnZhbGlkQW5kTW9kaWZpZWRQcmVzZW50O1xuXG5cdFx0XHRcdGludmFsaWRBbmRNb2RpZmllZFByZXNlbnQgPSAhIXJlc3VsdC5maW5kKGZ1bmN0aW9uIChvYnNlcnZhYmxlKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHV0aWxzLmlzVmFsaWRhdGFibGUob2JzZXJ2YWJsZSkgJiYgIW9ic2VydmFibGUuaXNWYWxpZCgpICYmIG9ic2VydmFibGUuaXNNb2RpZmllZCgpO1xuXHRcdFx0XHR9KTtcblx0XHRcdFx0cmV0dXJuIGludmFsaWRBbmRNb2RpZmllZFByZXNlbnQ7XG5cdFx0XHR9O1xuXG5cdFx0XHRyZXN1bHQuZmlsdGVyID0gZnVuY3Rpb24ocHJlZGljYXRlKSB7XG5cdFx0XHRcdHByZWRpY2F0ZSA9IHByZWRpY2F0ZSB8fCBmdW5jdGlvbiAoKSB7IHJldHVybiB0cnVlOyB9O1xuXHRcdFx0XHQvLyBlbnN1cmUgd2UgaGF2ZSBsYXRlc3QgY2hhbmdlc1xuXHRcdFx0XHRyZXN1bHQoKTtcblxuXHRcdFx0XHRyZXR1cm4ga29VdGlscy5hcnJheUZpbHRlcihjb250ZXh0LnZhbGlkYXRhYmxlcywgcHJlZGljYXRlKTtcblx0XHRcdH07XG5cblx0XHRcdHJlc3VsdC5maW5kID0gZnVuY3Rpb24ocHJlZGljYXRlKSB7XG5cdFx0XHRcdHByZWRpY2F0ZSA9IHByZWRpY2F0ZSB8fCBmdW5jdGlvbiAoKSB7IHJldHVybiB0cnVlOyB9O1xuXHRcdFx0XHQvLyBlbnN1cmUgd2UgaGF2ZSBsYXRlc3QgY2hhbmdlc1xuXHRcdFx0XHRyZXN1bHQoKTtcblxuXHRcdFx0XHRyZXR1cm4ga29VdGlscy5hcnJheUZpcnN0KGNvbnRleHQudmFsaWRhdGFibGVzLCBwcmVkaWNhdGUpO1xuXHRcdFx0fTtcblxuXHRcdFx0cmVzdWx0LmZvckVhY2ggPSBmdW5jdGlvbihjYWxsYmFjaykge1xuXHRcdFx0XHRjYWxsYmFjayA9IGNhbGxiYWNrIHx8IGZ1bmN0aW9uICgpIHsgfTtcblx0XHRcdFx0Ly8gZW5zdXJlIHdlIGhhdmUgbGF0ZXN0IGNoYW5nZXNcblx0XHRcdFx0cmVzdWx0KCk7XG5cblx0XHRcdFx0Zm9yRWFjaChjb250ZXh0LnZhbGlkYXRhYmxlcywgY2FsbGJhY2spO1xuXHRcdFx0fTtcblxuXHRcdFx0cmVzdWx0Lm1hcCA9IGZ1bmN0aW9uKG1hcHBpbmcpIHtcblx0XHRcdFx0bWFwcGluZyA9IG1hcHBpbmcgfHwgZnVuY3Rpb24gKGl0ZW0pIHsgcmV0dXJuIGl0ZW07IH07XG5cdFx0XHRcdC8vIGVuc3VyZSB3ZSBoYXZlIGxhdGVzdCBjaGFuZ2VzXG5cdFx0XHRcdHJlc3VsdCgpO1xuXG5cdFx0XHRcdHJldHVybiBrb1V0aWxzLmFycmF5TWFwKGNvbnRleHQudmFsaWRhdGFibGVzLCBtYXBwaW5nKTtcblx0XHRcdH07XG5cblx0XHRcdC8qKlxuXHRcdFx0ICogQHByaXZhdGUgWW91IHNob3VsZCBub3QgcmVseSBvbiB0aGlzIG1ldGhvZCBiZWluZyBoZXJlLlxuXHRcdFx0ICogSXQncyBhIHByaXZhdGUgbWV0aG9kIGFuZCBpdCBtYXkgY2hhbmdlIGluIHRoZSBmdXR1cmUuXG5cdFx0XHQgKlxuXHRcdFx0ICogQGRlc2NyaXB0aW9uIFVwZGF0ZXMgdGhlIHZhbGlkYXRlZCBvYmplY3QgYW5kIGNvbGxlY3RzIGVycm9ycyBmcm9tIGl0LlxuXHRcdFx0ICovXG5cdFx0XHRyZXN1bHQuX3VwZGF0ZVN0YXRlID0gZnVuY3Rpb24obmV3VmFsdWUpIHtcblx0XHRcdFx0aWYgKCF1dGlscy5pc09iamVjdChuZXdWYWx1ZSkpIHtcblx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ0FuIG9iamVjdCBpcyByZXF1aXJlZC4nKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRvYmogPSBuZXdWYWx1ZTtcblx0XHRcdFx0aWYgKG9wdGlvbnMub2JzZXJ2YWJsZSkge1xuXHRcdFx0XHRcdGNvbnRleHQuZ3JhcGhNb25pdG9yLnZhbHVlSGFzTXV0YXRlZCgpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdHJ1blRyYXZlcnNhbChuZXdWYWx1ZSwgY29udGV4dCk7XG5cdFx0XHRcdFx0cmV0dXJuIGNvbGxlY3RFcnJvcnMoY29udGV4dC52YWxpZGF0YWJsZXMpO1xuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXHRcdFx0cmV0dXJuIHJlc3VsdDtcblx0XHR9LFxuXG5cdFx0Zm9ybWF0TWVzc2FnZTogZnVuY3Rpb24gKG1lc3NhZ2UsIHBhcmFtcywgb2JzZXJ2YWJsZSkge1xuXHRcdFx0aWYgKHV0aWxzLmlzT2JqZWN0KHBhcmFtcykgJiYgcGFyYW1zLnR5cGVBdHRyKSB7XG5cdFx0XHRcdHBhcmFtcyA9IHBhcmFtcy52YWx1ZTtcblx0XHRcdH1cblx0XHRcdGlmICh0eXBlb2YgbWVzc2FnZSA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0XHRyZXR1cm4gbWVzc2FnZShwYXJhbXMsIG9ic2VydmFibGUpO1xuXHRcdFx0fVxuXHRcdFx0dmFyIHJlcGxhY2VtZW50cyA9IHVud3JhcChwYXJhbXMpO1xuICAgICAgICAgICAgaWYgKHJlcGxhY2VtZW50cyA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmVwbGFjZW1lbnRzID0gW107XG4gICAgICAgICAgICB9XG5cdFx0XHRpZiAoIXV0aWxzLmlzQXJyYXkocmVwbGFjZW1lbnRzKSkge1xuXHRcdFx0XHRyZXBsYWNlbWVudHMgPSBbcmVwbGFjZW1lbnRzXTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBtZXNzYWdlLnJlcGxhY2UoL3soXFxkKyl9L2dpLCBmdW5jdGlvbihtYXRjaCwgaW5kZXgpIHtcblx0XHRcdFx0aWYgKHR5cGVvZiByZXBsYWNlbWVudHNbaW5kZXhdICE9PSAndW5kZWZpbmVkJykge1xuXHRcdFx0XHRcdHJldHVybiByZXBsYWNlbWVudHNbaW5kZXhdO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBtYXRjaDtcblx0XHRcdH0pO1xuXHRcdH0sXG5cblx0XHQvLyBhZGRSdWxlOlxuXHRcdC8vIFRoaXMgdGFrZXMgaW4gYSBrby5vYnNlcnZhYmxlIGFuZCBhIFJ1bGUgQ29udGV4dCAtIHdoaWNoIGlzIGp1c3QgYSBydWxlIG5hbWUgYW5kIHBhcmFtcyB0byBzdXBwbHkgdG8gdGhlIHZhbGlkYXRvclxuXHRcdC8vIGllOiBrdi5hZGRSdWxlKG15T2JzZXJ2YWJsZSwge1xuXHRcdC8vXHRcdCAgcnVsZTogJ3JlcXVpcmVkJyxcblx0XHQvL1x0XHQgIHBhcmFtczogdHJ1ZVxuXHRcdC8vXHQgIH0pO1xuXHRcdC8vXG5cdFx0YWRkUnVsZTogZnVuY3Rpb24gKG9ic2VydmFibGUsIHJ1bGUpIHtcblx0XHRcdG9ic2VydmFibGUuZXh0ZW5kKHsgdmFsaWRhdGFibGU6IHRydWUgfSk7XG5cblx0XHRcdHZhciBoYXNSdWxlID0gISFrb1V0aWxzLmFycmF5Rmlyc3Qob2JzZXJ2YWJsZS5ydWxlcygpLCBmdW5jdGlvbihpdGVtKSB7XG5cdFx0XHRcdHJldHVybiBpdGVtLnJ1bGUgJiYgaXRlbS5ydWxlID09PSBydWxlLnJ1bGU7XG5cdFx0XHR9KTtcblxuXHRcdFx0aWYgKCFoYXNSdWxlKSB7XG5cdFx0XHRcdC8vcHVzaCBhIFJ1bGUgQ29udGV4dCB0byB0aGUgb2JzZXJ2YWJsZXMgbG9jYWwgYXJyYXkgb2YgUnVsZSBDb250ZXh0c1xuXHRcdFx0XHRvYnNlcnZhYmxlLnJ1bGVzLnB1c2gocnVsZSk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gb2JzZXJ2YWJsZTtcblx0XHR9LFxuXG5cdFx0Ly8gYWRkQW5vbnltb3VzUnVsZTpcblx0XHQvLyBBbm9ueW1vdXMgUnVsZXMgZXNzZW50aWFsbHkgaGF2ZSBhbGwgdGhlIHByb3BlcnRpZXMgb2YgYSBSdWxlLCBidXQgYXJlIG9ubHkgc3BlY2lmaWMgZm9yIGEgY2VydGFpbiBwcm9wZXJ0eVxuXHRcdC8vIGFuZCBkZXZlbG9wZXJzIHR5cGljYWxseSBhcmUgd2FudGluZyB0byBhZGQgdGhlbSBvbiB0aGUgZmx5IG9yIG5vdCByZWdpc3RlciBhIHJ1bGUgd2l0aCB0aGUgJ2t2LnJ1bGVzJyBvYmplY3Rcblx0XHQvL1xuXHRcdC8vIEV4YW1wbGU6XG5cdFx0Ly8gdmFyIHRlc3QgPSBrby5vYnNlcnZhYmxlKCdzb21ldGhpbmcnKS5leHRlbmR7KFxuXHRcdC8vXHQgIHZhbGlkYXRpb246IHtcblx0XHQvL1x0XHQgIHZhbGlkYXRvcjogZnVuY3Rpb24odmFsLCBzb21lT3RoZXJWYWwpe1xuXHRcdC8vXHRcdFx0ICByZXR1cm4gdHJ1ZTtcblx0XHQvL1x0XHQgIH0sXG5cdFx0Ly9cdFx0ICBtZXNzYWdlOiBcIlNvbWV0aGluZyBtdXN0IGJlIHJlYWxseSB3cm9uZyEnLFxuXHRcdC8vXHRcdCAgcGFyYW1zOiB0cnVlXG5cdFx0Ly9cdCAgfVxuXHRcdC8vICApfTtcblx0XHRhZGRBbm9ueW1vdXNSdWxlOiBmdW5jdGlvbiAob2JzZXJ2YWJsZSwgcnVsZU9iaikge1xuXHRcdFx0aWYgKHJ1bGVPYmpbJ21lc3NhZ2UnXSA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdHJ1bGVPYmpbJ21lc3NhZ2UnXSA9ICdFcnJvcic7XG5cdFx0XHR9XG5cblx0XHRcdC8vbWFrZSBzdXJlIG9ubHlJZiBpcyBob25vdXJlZFxuXHRcdFx0aWYgKHJ1bGVPYmoub25seUlmKSB7XG5cdFx0XHRcdHJ1bGVPYmouY29uZGl0aW9uID0gcnVsZU9iai5vbmx5SWY7XG5cdFx0XHR9XG5cblx0XHRcdC8vYWRkIHRoZSBhbm9ueW1vdXMgcnVsZSB0byB0aGUgb2JzZXJ2YWJsZVxuXHRcdFx0a3YuYWRkUnVsZShvYnNlcnZhYmxlLCBydWxlT2JqKTtcblx0XHR9LFxuXG5cdFx0YWRkRXh0ZW5kZXI6IGZ1bmN0aW9uIChydWxlTmFtZSkge1xuXHRcdFx0a28uZXh0ZW5kZXJzW3J1bGVOYW1lXSA9IGZ1bmN0aW9uIChvYnNlcnZhYmxlLCBwYXJhbXMpIHtcblx0XHRcdFx0Ly9wYXJhbXMgY2FuIGNvbWUgaW4gYSBmZXcgZmxhdm9yc1xuXHRcdFx0XHQvLyAxLiBKdXN0IHRoZSBwYXJhbXMgdG8gYmUgcGFzc2VkIHRvIHRoZSB2YWxpZGF0b3Jcblx0XHRcdFx0Ly8gMi4gQW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIE1lc3NhZ2UgdG8gYmUgdXNlZCBhbmQgdGhlIFBhcmFtcyB0byBwYXNzIHRvIHRoZSB2YWxpZGF0b3Jcblx0XHRcdFx0Ly8gMy4gQSBjb25kaXRpb24gd2hlbiB0aGUgdmFsaWRhdGlvbiBydWxlIHRvIGJlIGFwcGxpZWRcblx0XHRcdFx0Ly9cblx0XHRcdFx0Ly8gRXhhbXBsZTpcblx0XHRcdFx0Ly8gdmFyIHRlc3QgPSBrby5vYnNlcnZhYmxlKDMpLmV4dGVuZCh7XG5cdFx0XHRcdC8vXHQgIG1heDoge1xuXHRcdFx0XHQvL1x0XHQgIG1lc3NhZ2U6ICdUaGlzIHNwZWNpYWwgZmllbGQgaGFzIGEgTWF4IG9mIHswfScsXG5cdFx0XHRcdC8vXHRcdCAgcGFyYW1zOiAyLFxuXHRcdFx0XHQvL1x0XHQgIG9ubHlJZjogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdC8vXHRcdFx0XHRcdCAgcmV0dXJuIHNwZWNpYWxGaWVsZC5Jc1Zpc2libGUoKTtcblx0XHRcdFx0Ly9cdFx0XHRcdCAgfVxuXHRcdFx0XHQvL1x0ICB9XG5cdFx0XHRcdC8vICApfTtcblx0XHRcdFx0Ly9cblx0XHRcdFx0aWYgKHBhcmFtcyAmJiAocGFyYW1zLm1lc3NhZ2UgfHwgcGFyYW1zLm9ubHlJZikpIHsgLy9pZiBpdCBoYXMgYSBtZXNzYWdlIG9yIGNvbmRpdGlvbiBvYmplY3QsIHRoZW4gaXRzIGFuIG9iamVjdCBsaXRlcmFsIHRvIHVzZVxuXHRcdFx0XHRcdHJldHVybiBrdi5hZGRSdWxlKG9ic2VydmFibGUsIHtcblx0XHRcdFx0XHRcdHJ1bGU6IHJ1bGVOYW1lLFxuXHRcdFx0XHRcdFx0bWVzc2FnZTogcGFyYW1zLm1lc3NhZ2UsXG5cdFx0XHRcdFx0XHRwYXJhbXM6IHV0aWxzLmlzRW1wdHlWYWwocGFyYW1zLnBhcmFtcykgPyB0cnVlIDogcGFyYW1zLnBhcmFtcyxcblx0XHRcdFx0XHRcdGNvbmRpdGlvbjogcGFyYW1zLm9ubHlJZlxuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHJldHVybiBrdi5hZGRSdWxlKG9ic2VydmFibGUsIHtcblx0XHRcdFx0XHRcdHJ1bGU6IHJ1bGVOYW1lLFxuXHRcdFx0XHRcdFx0cGFyYW1zOiBwYXJhbXNcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0fVxuXHRcdFx0fTtcblx0XHR9LFxuXG5cdFx0Ly8gbG9vcHMgdGhyb3VnaCBhbGwga3YucnVsZXMgYW5kIGFkZHMgdGhlbSBhcyBleHRlbmRlcnMgdG9cblx0XHQvLyBrby5leHRlbmRlcnNcblx0XHRyZWdpc3RlckV4dGVuZGVyczogZnVuY3Rpb24gKCkgeyAvLyByb290IGV4dGVuZGVycyBvcHRpb25hbCwgdXNlICd2YWxpZGF0aW9uJyBleHRlbmRlciBpZiB3b3VsZCBjYXVzZSBjb25mbGljdHNcblx0XHRcdGlmIChjb25maWd1cmF0aW9uLnJlZ2lzdGVyRXh0ZW5kZXJzKSB7XG5cdFx0XHRcdGZvciAodmFyIHJ1bGVOYW1lIGluIGt2LnJ1bGVzKSB7XG5cdFx0XHRcdFx0aWYgKGt2LnJ1bGVzLmhhc093blByb3BlcnR5KHJ1bGVOYW1lKSkge1xuXHRcdFx0XHRcdFx0aWYgKCFrby5leHRlbmRlcnNbcnVsZU5hbWVdKSB7XG5cdFx0XHRcdFx0XHRcdGt2LmFkZEV4dGVuZGVyKHJ1bGVOYW1lKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0Ly9jcmVhdGVzIGEgc3BhbiBuZXh0IHRvIHRoZSBAZWxlbWVudCB3aXRoIHRoZSBzcGVjaWZpZWQgZXJyb3IgY2xhc3Ncblx0XHRpbnNlcnRWYWxpZGF0aW9uTWVzc2FnZTogZnVuY3Rpb24gKGVsZW1lbnQpIHtcblx0XHRcdHZhciBzcGFuID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnU1BBTicpO1xuXHRcdFx0c3Bhbi5jbGFzc05hbWUgPSB1dGlscy5nZXRDb25maWdPcHRpb25zKGVsZW1lbnQpLmVycm9yTWVzc2FnZUNsYXNzO1xuXHRcdFx0dXRpbHMuaW5zZXJ0QWZ0ZXIoZWxlbWVudCwgc3Bhbik7XG5cdFx0XHRyZXR1cm4gc3Bhbjtcblx0XHR9LFxuXG5cdFx0Ly8gaWYgaHRtbC01IHZhbGlkYXRpb24gYXR0cmlidXRlcyBoYXZlIGJlZW4gc3BlY2lmaWVkLCB0aGlzIHBhcnNlc1xuXHRcdC8vIHRoZSBhdHRyaWJ1dGVzIG9uIEBlbGVtZW50XG5cdFx0cGFyc2VJbnB1dFZhbGlkYXRpb25BdHRyaWJ1dGVzOiBmdW5jdGlvbiAoZWxlbWVudCwgdmFsdWVBY2Nlc3Nvcikge1xuXHRcdFx0Zm9yRWFjaChrdi5jb25maWd1cmF0aW9uLmh0bWw1QXR0cmlidXRlcywgZnVuY3Rpb24gKGF0dHIpIHtcblx0XHRcdFx0aWYgKHV0aWxzLmhhc0F0dHJpYnV0ZShlbGVtZW50LCBhdHRyKSkge1xuXG5cdFx0XHRcdFx0dmFyIHBhcmFtcyA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKGF0dHIpIHx8IHRydWU7XG5cblx0XHRcdFx0XHRpZiAoYXR0ciA9PT0gJ21pbicgfHwgYXR0ciA9PT0gJ21heCcpXG5cdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0Ly8gSWYgd2UncmUgdmFsaWRhdGluZyBiYXNlZCBvbiB0aGUgbWluIGFuZCBtYXggYXR0cmlidXRlcywgd2UnbGxcblx0XHRcdFx0XHRcdC8vIG5lZWQgdG8ga25vdyB3aGF0IHRoZSAndHlwZScgYXR0cmlidXRlIGlzIHNldCB0b1xuXHRcdFx0XHRcdFx0dmFyIHR5cGVBdHRyID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ3R5cGUnKTtcblx0XHRcdFx0XHRcdGlmICh0eXBlb2YgdHlwZUF0dHIgPT09IFwidW5kZWZpbmVkXCIgfHwgIXR5cGVBdHRyKVxuXHRcdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0XHQvLyBGcm9tIGh0dHA6Ly93d3cudzMub3JnL1RSL2h0bWwtbWFya3VwL2lucHV0OlxuXHRcdFx0XHRcdFx0XHQvLyAgIEFuIGlucHV0IGVsZW1lbnQgd2l0aCBubyB0eXBlIGF0dHJpYnV0ZSBzcGVjaWZpZWQgcmVwcmVzZW50cyB0aGVcblx0XHRcdFx0XHRcdFx0Ly8gICBzYW1lIHRoaW5nIGFzIGFuIGlucHV0IGVsZW1lbnQgd2l0aCBpdHMgdHlwZSBhdHRyaWJ1dGUgc2V0IHRvIFwidGV4dFwiLlxuXHRcdFx0XHRcdFx0XHR0eXBlQXR0ciA9IFwidGV4dFwiO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0cGFyYW1zID0ge3R5cGVBdHRyOiB0eXBlQXR0ciwgdmFsdWU6IHBhcmFtc307XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0a3YuYWRkUnVsZSh2YWx1ZUFjY2Vzc29yKCksIHtcblx0XHRcdFx0XHRcdHJ1bGU6IGF0dHIsXG5cdFx0XHRcdFx0XHRwYXJhbXM6IHBhcmFtc1xuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblxuXHRcdFx0dmFyIGN1cnJlbnRUeXBlID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ3R5cGUnKTtcblx0XHRcdGZvckVhY2goa3YuY29uZmlndXJhdGlvbi5odG1sNUlucHV0VHlwZXMsIGZ1bmN0aW9uICh0eXBlKSB7XG5cdFx0XHRcdGlmICh0eXBlID09PSBjdXJyZW50VHlwZSkge1xuXHRcdFx0XHRcdGt2LmFkZFJ1bGUodmFsdWVBY2Nlc3NvcigpLCB7XG5cdFx0XHRcdFx0XHRydWxlOiAodHlwZSA9PT0gJ2RhdGUnKSA/ICdkYXRlSVNPJyA6IHR5cGUsXG5cdFx0XHRcdFx0XHRwYXJhbXM6IHRydWVcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0fSxcblxuXHRcdC8vIHdyaXRlcyBodG1sNSB2YWxpZGF0aW9uIGF0dHJpYnV0ZXMgb24gdGhlIGVsZW1lbnQgcGFzc2VkIGluXG5cdFx0d3JpdGVJbnB1dFZhbGlkYXRpb25BdHRyaWJ1dGVzOiBmdW5jdGlvbiAoZWxlbWVudCwgdmFsdWVBY2Nlc3Nvcikge1xuXHRcdFx0dmFyIG9ic2VydmFibGUgPSB2YWx1ZUFjY2Vzc29yKCk7XG5cblx0XHRcdGlmICghb2JzZXJ2YWJsZSB8fCAhb2JzZXJ2YWJsZS5ydWxlcykge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdHZhciBjb250ZXh0cyA9IG9ic2VydmFibGUucnVsZXMoKTsgLy8gb2JzZXJ2YWJsZSBhcnJheVxuXG5cdFx0XHQvLyBsb29wIHRocm91Z2ggdGhlIGF0dHJpYnV0ZXMgYW5kIGFkZCB0aGUgaW5mb3JtYXRpb24gbmVlZGVkXG5cdFx0XHRmb3JFYWNoKGt2LmNvbmZpZ3VyYXRpb24uaHRtbDVBdHRyaWJ1dGVzLCBmdW5jdGlvbiAoYXR0cikge1xuXHRcdFx0XHR2YXIgY3R4ID0ga29VdGlscy5hcnJheUZpcnN0KGNvbnRleHRzLCBmdW5jdGlvbiAoY3R4KSB7XG5cdFx0XHRcdFx0cmV0dXJuIGN0eC5ydWxlICYmIGN0eC5ydWxlLnRvTG93ZXJDYXNlKCkgPT09IGF0dHIudG9Mb3dlckNhc2UoKTtcblx0XHRcdFx0fSk7XG5cblx0XHRcdFx0aWYgKCFjdHgpIHtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyB3ZSBoYXZlIGEgcnVsZSBtYXRjaGluZyBhIHZhbGlkYXRpb24gYXR0cmlidXRlIGF0IHRoaXMgcG9pbnRcblx0XHRcdFx0Ly8gc28gbGV0cyBhZGQgaXQgdG8gdGhlIGVsZW1lbnQgYWxvbmcgd2l0aCB0aGUgcGFyYW1zXG5cdFx0XHRcdGtvLmNvbXB1dGVkKHtcblx0XHRcdFx0XHRyZWFkOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdHZhciBwYXJhbXMgPSBrby51bndyYXAoY3R4LnBhcmFtcyk7XG5cblx0XHRcdFx0XHRcdC8vIHdlIGhhdmUgdG8gZG8gc29tZSBzcGVjaWFsIHRoaW5ncyBmb3IgdGhlIHBhdHRlcm4gdmFsaWRhdGlvblxuXHRcdFx0XHRcdFx0aWYgKGN0eC5ydWxlID09PSBcInBhdHRlcm5cIiAmJiBwYXJhbXMgaW5zdGFuY2VvZiBSZWdFeHApIHtcblx0XHRcdFx0XHRcdFx0Ly8gd2UgbmVlZCB0aGUgcHVyZSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIFJlZ0V4cHIgd2l0aG91dCB0aGUgLy9naSBzdHVmZlxuXHRcdFx0XHRcdFx0XHRwYXJhbXMgPSBwYXJhbXMuc291cmNlO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRlbGVtZW50LnNldEF0dHJpYnV0ZShhdHRyLCBwYXJhbXMpO1xuXHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0ZGlzcG9zZVdoZW5Ob2RlSXNSZW1vdmVkOiBlbGVtZW50XG5cdFx0XHRcdH0pO1xuXHRcdFx0fSk7XG5cblx0XHRcdGNvbnRleHRzID0gbnVsbDtcblx0XHR9LFxuXG5cdFx0Ly90YWtlIGFuIGV4aXN0aW5nIGJpbmRpbmcgaGFuZGxlciBhbmQgbWFrZSBpdCBjYXVzZSBhdXRvbWF0aWMgdmFsaWRhdGlvbnNcblx0XHRtYWtlQmluZGluZ0hhbmRsZXJWYWxpZGF0YWJsZTogZnVuY3Rpb24gKGhhbmRsZXJOYW1lKSB7XG5cdFx0XHR2YXIgaW5pdCA9IGtvLmJpbmRpbmdIYW5kbGVyc1toYW5kbGVyTmFtZV0uaW5pdDtcblxuXHRcdFx0a28uYmluZGluZ0hhbmRsZXJzW2hhbmRsZXJOYW1lXS5pbml0ID0gZnVuY3Rpb24gKGVsZW1lbnQsIHZhbHVlQWNjZXNzb3IsIGFsbEJpbmRpbmdzQWNjZXNzb3IsIHZpZXdNb2RlbCwgYmluZGluZ0NvbnRleHQpIHtcblxuXHRcdFx0XHRpbml0KGVsZW1lbnQsIHZhbHVlQWNjZXNzb3IsIGFsbEJpbmRpbmdzQWNjZXNzb3IsIHZpZXdNb2RlbCwgYmluZGluZ0NvbnRleHQpO1xuXG5cdFx0XHRcdHJldHVybiBrby5iaW5kaW5nSGFuZGxlcnNbJ3ZhbGlkYXRpb25Db3JlJ10uaW5pdChlbGVtZW50LCB2YWx1ZUFjY2Vzc29yLCBhbGxCaW5kaW5nc0FjY2Vzc29yLCB2aWV3TW9kZWwsIGJpbmRpbmdDb250ZXh0KTtcblx0XHRcdH07XG5cdFx0fSxcblxuXHRcdC8vIHZpc2l0IGFuIG9iamVjdHMgcHJvcGVydGllcyBhbmQgYXBwbHkgdmFsaWRhdGlvbiBydWxlcyBmcm9tIGEgZGVmaW5pdGlvblxuXHRcdHNldFJ1bGVzOiBmdW5jdGlvbiAodGFyZ2V0LCBkZWZpbml0aW9uKSB7XG5cdFx0XHR2YXIgc2V0UnVsZXMgPSBmdW5jdGlvbiAodGFyZ2V0LCBkZWZpbml0aW9uKSB7XG5cdFx0XHRcdGlmICghdGFyZ2V0IHx8ICFkZWZpbml0aW9uKSB7IHJldHVybjsgfVxuXG5cdFx0XHRcdGZvciAodmFyIHByb3AgaW4gZGVmaW5pdGlvbikge1xuXHRcdFx0XHRcdGlmICghZGVmaW5pdGlvbi5oYXNPd25Qcm9wZXJ0eShwcm9wKSkgeyBjb250aW51ZTsgfVxuXHRcdFx0XHRcdHZhciBydWxlRGVmaW5pdGlvbnMgPSBkZWZpbml0aW9uW3Byb3BdO1xuXG5cdFx0XHRcdFx0Ly9jaGVjayB0aGUgdGFyZ2V0IHByb3BlcnR5IGV4aXN0cyBhbmQgaGFzIGEgdmFsdWVcblx0XHRcdFx0XHRpZiAoIXRhcmdldFtwcm9wXSkgeyBjb250aW51ZTsgfVxuXHRcdFx0XHRcdHZhciB0YXJnZXRWYWx1ZSA9IHRhcmdldFtwcm9wXSxcblx0XHRcdFx0XHRcdHVud3JhcHBlZFRhcmdldFZhbHVlID0gdW53cmFwKHRhcmdldFZhbHVlKSxcblx0XHRcdFx0XHRcdHJ1bGVzID0ge30sXG5cdFx0XHRcdFx0XHRub25SdWxlcyA9IHt9O1xuXG5cdFx0XHRcdFx0Zm9yICh2YXIgcnVsZSBpbiBydWxlRGVmaW5pdGlvbnMpIHtcblx0XHRcdFx0XHRcdGlmICghcnVsZURlZmluaXRpb25zLmhhc093blByb3BlcnR5KHJ1bGUpKSB7IGNvbnRpbnVlOyB9XG5cdFx0XHRcdFx0XHRpZiAoa3YucnVsZXNbcnVsZV0pIHtcblx0XHRcdFx0XHRcdFx0cnVsZXNbcnVsZV0gPSBydWxlRGVmaW5pdGlvbnNbcnVsZV07XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRub25SdWxlc1tydWxlXSA9IHJ1bGVEZWZpbml0aW9uc1tydWxlXTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvL2FwcGx5IHJ1bGVzXG5cdFx0XHRcdFx0aWYgKGtvLmlzT2JzZXJ2YWJsZSh0YXJnZXRWYWx1ZSkpIHtcblx0XHRcdFx0XHRcdHRhcmdldFZhbHVlLmV4dGVuZChydWxlcyk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly90aGVuIGFwcGx5IGNoaWxkIHJ1bGVzXG5cdFx0XHRcdFx0Ly9pZiBpdCdzIGFuIGFycmF5LCBhcHBseSBydWxlcyB0byBhbGwgY2hpbGRyZW5cblx0XHRcdFx0XHRpZiAodW53cmFwcGVkVGFyZ2V0VmFsdWUgJiYgdXRpbHMuaXNBcnJheSh1bndyYXBwZWRUYXJnZXRWYWx1ZSkpIHtcblx0XHRcdFx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgdW53cmFwcGVkVGFyZ2V0VmFsdWUubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHRcdFx0c2V0UnVsZXModW53cmFwcGVkVGFyZ2V0VmFsdWVbaV0sIG5vblJ1bGVzKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdC8vb3RoZXJ3aXNlLCBqdXN0IGFwcGx5IHRvIHRoaXMgcHJvcGVydHlcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0c2V0UnVsZXModW53cmFwcGVkVGFyZ2V0VmFsdWUsIG5vblJ1bGVzKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cdFx0XHRzZXRSdWxlcyh0YXJnZXQsIGRlZmluaXRpb24pO1xuXHRcdH1cblx0fTtcblxufSgpKTtcblxuLy8gZXhwb3NlIGFwaSBwdWJsaWNseVxuZXh0ZW5kKGtvLnZhbGlkYXRpb24sIGFwaSk7XG47Ly9WYWxpZGF0aW9uIFJ1bGVzOlxuLy8gWW91IGNhbiB2aWV3IGFuZCBvdmVycmlkZSBtZXNzYWdlcyBvciBydWxlcyB2aWE6XG4vLyBrdi5ydWxlc1tydWxlTmFtZV1cbi8vXG4vLyBUbyBpbXBsZW1lbnQgYSBjdXN0b20gUnVsZSwgc2ltcGx5IHVzZSB0aGlzIHRlbXBsYXRlOlxuLy8ga3YucnVsZXNbJzxjdXN0b20gcnVsZSBuYW1lPiddID0ge1xuLy8gICAgICB2YWxpZGF0b3I6IGZ1bmN0aW9uICh2YWwsIHBhcmFtKSB7XG4vLyAgICAgICAgICA8Y3VzdG9tIGxvZ2ljPlxuLy8gICAgICAgICAgcmV0dXJuIDx0cnVlIG9yIGZhbHNlPjtcbi8vICAgICAgfSxcbi8vICAgICAgbWVzc2FnZTogJzxjdXN0b20gdmFsaWRhdGlvbiBtZXNzYWdlPicgLy9vcHRpb25hbGx5IHlvdSBjYW4gYWxzbyB1c2UgYSAnezB9JyB0byBkZW5vdGUgYSBwbGFjZWhvbGRlciB0aGF0IHdpbGwgYmUgcmVwbGFjZWQgd2l0aCB5b3VyICdwYXJhbSdcbi8vIH07XG4vL1xuLy8gRXhhbXBsZTpcbi8vIGt2LnJ1bGVzWydtdXN0RXF1YWwnXSA9IHtcbi8vICAgICAgdmFsaWRhdG9yOiBmdW5jdGlvbiggdmFsLCBtdXN0RXF1YWxWYWwgKXtcbi8vICAgICAgICAgIHJldHVybiB2YWwgPT09IG11c3RFcXVhbFZhbDtcbi8vICAgICAgfSxcbi8vICAgICAgbWVzc2FnZTogJ1RoaXMgZmllbGQgbXVzdCBlcXVhbCB7MH0nXG4vLyB9O1xuLy9cbmt2LnJ1bGVzID0ge307XG5rdi5ydWxlc1sncmVxdWlyZWQnXSA9IHtcblx0dmFsaWRhdG9yOiBmdW5jdGlvbiAodmFsLCByZXF1aXJlZCkge1xuXHRcdHZhciB0ZXN0VmFsO1xuXG5cdFx0aWYgKHZhbCA9PT0gdW5kZWZpbmVkIHx8IHZhbCA9PT0gbnVsbCkge1xuXHRcdFx0cmV0dXJuICFyZXF1aXJlZDtcblx0XHR9XG5cblx0XHR0ZXN0VmFsID0gdmFsO1xuXHRcdGlmICh0eXBlb2YgKHZhbCkgPT09ICdzdHJpbmcnKSB7XG5cdFx0XHRpZiAoU3RyaW5nLnByb3RvdHlwZS50cmltKSB7XG5cdFx0XHRcdHRlc3RWYWwgPSB2YWwudHJpbSgpO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSB7XG5cdFx0XHRcdHRlc3RWYWwgPSB2YWwucmVwbGFjZSgvXlxccyt8XFxzKyQvZywgJycpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmICghcmVxdWlyZWQpIHsvLyBpZiB0aGV5IHBhc3NlZDogeyByZXF1aXJlZDogZmFsc2UgfSwgdGhlbiBkb24ndCByZXF1aXJlIHRoaXNcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblxuXHRcdHJldHVybiAoKHRlc3RWYWwgKyAnJykubGVuZ3RoID4gMCk7XG5cdH0sXG5cdG1lc3NhZ2U6ICdUaGlzIGZpZWxkIGlzIHJlcXVpcmVkLidcbn07XG5cbmZ1bmN0aW9uIG1pbk1heFZhbGlkYXRvckZhY3RvcnkodmFsaWRhdG9yTmFtZSkge1xuICAgIHZhciBpc01heFZhbGlkYXRpb24gPSB2YWxpZGF0b3JOYW1lID09PSBcIm1heFwiO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uICh2YWwsIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKGt2LnV0aWxzLmlzRW1wdHlWYWwodmFsKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgY29tcGFyaXNvblZhbHVlLCB0eXBlO1xuICAgICAgICBpZiAob3B0aW9ucy50eXBlQXR0ciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAvLyBUaGlzIHZhbGlkYXRvciBpcyBiZWluZyBjYWxsZWQgZnJvbSBqYXZhc2NyaXB0IHJhdGhlciB0aGFuXG4gICAgICAgICAgICAvLyBiZWluZyBib3VuZCBmcm9tIG1hcmt1cFxuICAgICAgICAgICAgdHlwZSA9IFwidGV4dFwiO1xuICAgICAgICAgICAgY29tcGFyaXNvblZhbHVlID0gb3B0aW9ucztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHR5cGUgPSBvcHRpb25zLnR5cGVBdHRyO1xuICAgICAgICAgICAgY29tcGFyaXNvblZhbHVlID0gb3B0aW9ucy52YWx1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEZyb20gaHR0cDovL3d3dy53My5vcmcvVFIvMjAxMi9XRC1odG1sNS0yMDEyMTAyNS9jb21tb24taW5wdXQtZWxlbWVudC1hdHRyaWJ1dGVzLmh0bWwjYXR0ci1pbnB1dC1taW4sXG4gICAgICAgIC8vIGlmIHRoZSB2YWx1ZSBpcyBwYXJzZWFibGUgdG8gYSBudW1iZXIsIHRoZW4gdGhlIG1pbmltdW0gc2hvdWxkIGJlIG51bWVyaWNcbiAgICAgICAgaWYgKCFpc05hTihjb21wYXJpc29uVmFsdWUpICYmICEoY29tcGFyaXNvblZhbHVlIGluc3RhbmNlb2YgRGF0ZSkpIHtcbiAgICAgICAgICAgIHR5cGUgPSBcIm51bWJlclwiO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHJlZ2V4LCB2YWxNYXRjaGVzLCBjb21wYXJpc29uVmFsdWVNYXRjaGVzO1xuICAgICAgICBzd2l0Y2ggKHR5cGUudG9Mb3dlckNhc2UoKSkge1xuICAgICAgICAgICAgY2FzZSBcIndlZWtcIjpcbiAgICAgICAgICAgICAgICByZWdleCA9IC9eKFxcZHs0fSktVyhcXGR7Mn0pJC87XG4gICAgICAgICAgICAgICAgdmFsTWF0Y2hlcyA9IHZhbC5tYXRjaChyZWdleCk7XG4gICAgICAgICAgICAgICAgaWYgKHZhbE1hdGNoZXMgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCB2YWx1ZSBmb3IgXCIgKyB2YWxpZGF0b3JOYW1lICsgXCIgYXR0cmlidXRlIGZvciB3ZWVrIGlucHV0LiAgU2hvdWxkIGxvb2sgbGlrZSBcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICBcIicyMDAwLVczMycgaHR0cDovL3d3dy53My5vcmcvVFIvaHRtbC1tYXJrdXAvaW5wdXQud2Vlay5odG1sI2lucHV0LndlZWsuYXR0cnMubWluXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb21wYXJpc29uVmFsdWVNYXRjaGVzID0gY29tcGFyaXNvblZhbHVlLm1hdGNoKHJlZ2V4KTtcbiAgICAgICAgICAgICAgICAvLyBJZiBubyByZWdleCBtYXRjaGVzIHdlcmUgZm91bmQsIHZhbGlkYXRpb24gZmFpbHNcbiAgICAgICAgICAgICAgICBpZiAoIWNvbXBhcmlzb25WYWx1ZU1hdGNoZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChpc01heFZhbGlkYXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICh2YWxNYXRjaGVzWzFdIDwgY29tcGFyaXNvblZhbHVlTWF0Y2hlc1sxXSkgfHwgLy8gb2xkZXIgeWVhclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gc2FtZSB5ZWFyLCBvbGRlciB3ZWVrXG4gICAgICAgICAgICAgICAgICAgICAgICAoKHZhbE1hdGNoZXNbMV0gPT09IGNvbXBhcmlzb25WYWx1ZU1hdGNoZXNbMV0pICYmICh2YWxNYXRjaGVzWzJdIDw9IGNvbXBhcmlzb25WYWx1ZU1hdGNoZXNbMl0pKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKHZhbE1hdGNoZXNbMV0gPiBjb21wYXJpc29uVmFsdWVNYXRjaGVzWzFdKSB8fCAvLyBuZXdlciB5ZWFyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBzYW1lIHllYXIsIG5ld2VyIHdlZWtcbiAgICAgICAgICAgICAgICAgICAgICAgICgodmFsTWF0Y2hlc1sxXSA9PT0gY29tcGFyaXNvblZhbHVlTWF0Y2hlc1sxXSkgJiYgKHZhbE1hdGNoZXNbMl0gPj0gY29tcGFyaXNvblZhbHVlTWF0Y2hlc1syXSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSBcIm1vbnRoXCI6XG4gICAgICAgICAgICAgICAgcmVnZXggPSAvXihcXGR7NH0pLShcXGR7Mn0pJC87XG4gICAgICAgICAgICAgICAgdmFsTWF0Y2hlcyA9IHZhbC5tYXRjaChyZWdleCk7XG4gICAgICAgICAgICAgICAgaWYgKHZhbE1hdGNoZXMgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCB2YWx1ZSBmb3IgXCIgKyB2YWxpZGF0b3JOYW1lICsgXCIgYXR0cmlidXRlIGZvciBtb250aCBpbnB1dC4gIFNob3VsZCBsb29rIGxpa2UgXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgXCInMjAwMC0wMycgaHR0cDovL3d3dy53My5vcmcvVFIvaHRtbC1tYXJrdXAvaW5wdXQubW9udGguaHRtbCNpbnB1dC5tb250aC5hdHRycy5taW5cIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbXBhcmlzb25WYWx1ZU1hdGNoZXMgPSBjb21wYXJpc29uVmFsdWUubWF0Y2gocmVnZXgpO1xuICAgICAgICAgICAgICAgIC8vIElmIG5vIHJlZ2V4IG1hdGNoZXMgd2VyZSBmb3VuZCwgdmFsaWRhdGlvbiBmYWlsc1xuICAgICAgICAgICAgICAgIGlmICghY29tcGFyaXNvblZhbHVlTWF0Y2hlcykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKGlzTWF4VmFsaWRhdGlvbikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKCh2YWxNYXRjaGVzWzFdIDwgY29tcGFyaXNvblZhbHVlTWF0Y2hlc1sxXSkgfHwgLy8gb2xkZXIgeWVhclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gc2FtZSB5ZWFyLCBvbGRlciBtb250aFxuICAgICAgICAgICAgICAgICAgICAgICAgKCh2YWxNYXRjaGVzWzFdID09PSBjb21wYXJpc29uVmFsdWVNYXRjaGVzWzFdKSAmJiAodmFsTWF0Y2hlc1syXSA8PSBjb21wYXJpc29uVmFsdWVNYXRjaGVzWzJdKSkpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAodmFsTWF0Y2hlc1sxXSA+IGNvbXBhcmlzb25WYWx1ZU1hdGNoZXNbMV0pIHx8IC8vIG5ld2VyIHllYXJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNhbWUgeWVhciwgbmV3ZXIgbW9udGhcbiAgICAgICAgICAgICAgICAgICAgICAgICgodmFsTWF0Y2hlc1sxXSA9PT0gY29tcGFyaXNvblZhbHVlTWF0Y2hlc1sxXSkgJiYgKHZhbE1hdGNoZXNbMl0gPj0gY29tcGFyaXNvblZhbHVlTWF0Y2hlc1syXSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSBcIm51bWJlclwiOlxuICAgICAgICAgICAgY2FzZSBcInJhbmdlXCI6XG4gICAgICAgICAgICAgICAgaWYgKGlzTWF4VmFsaWRhdGlvbikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKCFpc05hTih2YWwpICYmIHBhcnNlRmxvYXQodmFsKSA8PSBwYXJzZUZsb2F0KGNvbXBhcmlzb25WYWx1ZSkpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAoIWlzTmFOKHZhbCkgJiYgcGFyc2VGbG9hdCh2YWwpID49IHBhcnNlRmxvYXQoY29tcGFyaXNvblZhbHVlKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIGlmIChpc01heFZhbGlkYXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbCA8PSBjb21wYXJpc29uVmFsdWU7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbCA+PSBjb21wYXJpc29uVmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbn1cblxua3YucnVsZXNbJ21pbiddID0ge1xuXHR2YWxpZGF0b3I6IG1pbk1heFZhbGlkYXRvckZhY3RvcnkoXCJtaW5cIiksXG5cdG1lc3NhZ2U6ICdQbGVhc2UgZW50ZXIgYSB2YWx1ZSBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gezB9Lidcbn07XG5cbmt2LnJ1bGVzWydtYXgnXSA9IHtcblx0dmFsaWRhdG9yOiBtaW5NYXhWYWxpZGF0b3JGYWN0b3J5KFwibWF4XCIpLFxuXHRtZXNzYWdlOiAnUGxlYXNlIGVudGVyIGEgdmFsdWUgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIHswfS4nXG59O1xuXG5rdi5ydWxlc1snbWluTGVuZ3RoJ10gPSB7XG5cdHZhbGlkYXRvcjogZnVuY3Rpb24gKHZhbCwgbWluTGVuZ3RoKSB7XG5cdFx0aWYoa3YudXRpbHMuaXNFbXB0eVZhbCh2YWwpKSB7IHJldHVybiB0cnVlOyB9XG5cdFx0dmFyIG5vcm1hbGl6ZWRWYWwgPSBrdi51dGlscy5pc051bWJlcih2YWwpID8gKCcnICsgdmFsKSA6IHZhbDtcblx0XHRyZXR1cm4gbm9ybWFsaXplZFZhbC5sZW5ndGggPj0gbWluTGVuZ3RoO1xuXHR9LFxuXHRtZXNzYWdlOiAnUGxlYXNlIGVudGVyIGF0IGxlYXN0IHswfSBjaGFyYWN0ZXJzLidcbn07XG5cbmt2LnJ1bGVzWydtYXhMZW5ndGgnXSA9IHtcblx0dmFsaWRhdG9yOiBmdW5jdGlvbiAodmFsLCBtYXhMZW5ndGgpIHtcblx0XHRpZihrdi51dGlscy5pc0VtcHR5VmFsKHZhbCkpIHsgcmV0dXJuIHRydWU7IH1cblx0XHR2YXIgbm9ybWFsaXplZFZhbCA9IGt2LnV0aWxzLmlzTnVtYmVyKHZhbCkgPyAoJycgKyB2YWwpIDogdmFsO1xuXHRcdHJldHVybiBub3JtYWxpemVkVmFsLmxlbmd0aCA8PSBtYXhMZW5ndGg7XG5cdH0sXG5cdG1lc3NhZ2U6ICdQbGVhc2UgZW50ZXIgbm8gbW9yZSB0aGFuIHswfSBjaGFyYWN0ZXJzLidcbn07XG5cbmt2LnJ1bGVzWydwYXR0ZXJuJ10gPSB7XG5cdHZhbGlkYXRvcjogZnVuY3Rpb24gKHZhbCwgcmVnZXgpIHtcblx0XHRyZXR1cm4ga3YudXRpbHMuaXNFbXB0eVZhbCh2YWwpIHx8IHZhbC50b1N0cmluZygpLm1hdGNoKHJlZ2V4KSAhPT0gbnVsbDtcblx0fSxcblx0bWVzc2FnZTogJ1BsZWFzZSBjaGVjayB0aGlzIHZhbHVlLidcbn07XG5cbmt2LnJ1bGVzWydzdGVwJ10gPSB7XG5cdHZhbGlkYXRvcjogZnVuY3Rpb24gKHZhbCwgc3RlcCkge1xuXG5cdFx0Ly8gaW4gb3JkZXIgdG8gaGFuZGxlIHN0ZXBzIG9mIC4xICYgLjAxIGV0Yy4uIE1vZHVsdXMgd29uJ3Qgd29ya1xuXHRcdC8vIGlmIHRoZSB2YWx1ZSBpcyBhIGRlY2ltYWwsIHNvIHdlIGhhdmUgdG8gY29ycmVjdCBmb3IgdGhhdFxuXHRcdGlmIChrdi51dGlscy5pc0VtcHR5VmFsKHZhbCkgfHwgc3RlcCA9PT0gJ2FueScpIHsgcmV0dXJuIHRydWU7IH1cblx0XHR2YXIgZGlmID0gKHZhbCAqIDEwMCkgJSAoc3RlcCAqIDEwMCk7XG5cdFx0cmV0dXJuIE1hdGguYWJzKGRpZikgPCAwLjAwMDAxIHx8IE1hdGguYWJzKDEgLSBkaWYpIDwgMC4wMDAwMTtcblx0fSxcblx0bWVzc2FnZTogJ1RoZSB2YWx1ZSBtdXN0IGluY3JlbWVudCBieSB7MH0uJ1xufTtcblxua3YucnVsZXNbJ2VtYWlsJ10gPSB7XG5cdHZhbGlkYXRvcjogZnVuY3Rpb24gKHZhbCwgdmFsaWRhdGUpIHtcblx0XHRpZiAoIXZhbGlkYXRlKSB7IHJldHVybiB0cnVlOyB9XG5cblx0XHQvL0kgdGhpbmsgYW4gZW1wdHkgZW1haWwgYWRkcmVzcyBpcyBhbHNvIGEgdmFsaWQgZW50cnlcblx0XHQvL2lmIG9uZSB3YW50J3MgdG8gZW5mb3JjZSBlbnRyeSBpdCBzaG91bGQgYmUgZG9uZSB3aXRoICdyZXF1aXJlZDogdHJ1ZSdcblx0XHRyZXR1cm4ga3YudXRpbHMuaXNFbXB0eVZhbCh2YWwpIHx8IChcblx0XHRcdC8vIGpxdWVyeSB2YWxpZGF0ZSByZWdleCAtIHRoYW5rcyBTY290dCBHb256YWxlelxuXHRcdFx0dmFsaWRhdGUgJiYgL14oKChbYS16XXxcXGR8WyEjXFwkJSYnXFwqXFwrXFwtXFwvPVxcP1xcXl9ge1xcfH1+XXxbXFx1MDBBMC1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkVGXSkrKFxcLihbYS16XXxcXGR8WyEjXFwkJSYnXFwqXFwrXFwtXFwvPVxcP1xcXl9ge1xcfH1+XXxbXFx1MDBBMC1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkVGXSkrKSopfCgoXFx4MjIpKCgoKFxceDIwfFxceDA5KSooXFx4MGRcXHgwYSkpPyhcXHgyMHxcXHgwOSkrKT8oKFtcXHgwMS1cXHgwOFxceDBiXFx4MGNcXHgwZS1cXHgxZlxceDdmXXxcXHgyMXxbXFx4MjMtXFx4NWJdfFtcXHg1ZC1cXHg3ZV18W1xcdTAwQTAtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZFRl0pfChcXFxcKFtcXHgwMS1cXHgwOVxceDBiXFx4MGNcXHgwZC1cXHg3Zl18W1xcdTAwQTAtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZFRl0pKSkpKigoKFxceDIwfFxceDA5KSooXFx4MGRcXHgwYSkpPyhcXHgyMHxcXHgwOSkrKT8oXFx4MjIpKSlAKCgoW2Etel18XFxkfFtcXHUwMEEwLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRUZdKXwoKFthLXpdfFxcZHxbXFx1MDBBMC1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkVGXSkoW2Etel18XFxkfC18XFwufF98fnxbXFx1MDBBMC1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkVGXSkqKFthLXpdfFxcZHxbXFx1MDBBMC1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkVGXSkpKVxcLikrKChbYS16XXxbXFx1MDBBMC1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkVGXSl8KChbYS16XXxbXFx1MDBBMC1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkVGXSkoW2Etel18XFxkfC18XFwufF98fnxbXFx1MDBBMC1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkVGXSkqKFthLXpdfFtcXHUwMEEwLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRUZdKSkpJC9pLnRlc3QodmFsKVxuXHRcdCk7XG5cdH0sXG5cdG1lc3NhZ2U6ICdQbGVhc2UgZW50ZXIgYSBwcm9wZXIgZW1haWwgYWRkcmVzcy4nXG59O1xuXG5rdi5ydWxlc1snZGF0ZSddID0ge1xuXHR2YWxpZGF0b3I6IGZ1bmN0aW9uICh2YWx1ZSwgdmFsaWRhdGUpIHtcblx0XHRpZiAoIXZhbGlkYXRlKSB7IHJldHVybiB0cnVlOyB9XG5cdFx0cmV0dXJuIGt2LnV0aWxzLmlzRW1wdHlWYWwodmFsdWUpIHx8ICh2YWxpZGF0ZSAmJiAhL0ludmFsaWR8TmFOLy50ZXN0KG5ldyBEYXRlKHZhbHVlKSkpO1xuXHR9LFxuXHRtZXNzYWdlOiAnUGxlYXNlIGVudGVyIGEgcHJvcGVyIGRhdGUuJ1xufTtcblxua3YucnVsZXNbJ2RhdGVJU08nXSA9IHtcblx0dmFsaWRhdG9yOiBmdW5jdGlvbiAodmFsdWUsIHZhbGlkYXRlKSB7XG5cdFx0aWYgKCF2YWxpZGF0ZSkgeyByZXR1cm4gdHJ1ZTsgfVxuXHRcdHJldHVybiBrdi51dGlscy5pc0VtcHR5VmFsKHZhbHVlKSB8fCAodmFsaWRhdGUgJiYgL15cXGR7NH1bLS9dKD86MD9bMS05XXwxWzAxMl0pWy0vXSg/OjA/WzEtOV18WzEyXVswLTldfDNbMDFdKSQvLnRlc3QodmFsdWUpKTtcblx0fSxcblx0bWVzc2FnZTogJ1BsZWFzZSBlbnRlciBhIHByb3BlciBkYXRlLidcbn07XG5cbmt2LnJ1bGVzWydudW1iZXInXSA9IHtcblx0dmFsaWRhdG9yOiBmdW5jdGlvbiAodmFsdWUsIHZhbGlkYXRlKSB7XG5cdFx0aWYgKCF2YWxpZGF0ZSkgeyByZXR1cm4gdHJ1ZTsgfVxuXHRcdHJldHVybiBrdi51dGlscy5pc0VtcHR5VmFsKHZhbHVlKSB8fCAodmFsaWRhdGUgJiYgL14tPyg/OlxcZCt8XFxkezEsM30oPzosXFxkezN9KSspPyg/OlxcLlxcZCspPyQvLnRlc3QodmFsdWUpKTtcblx0fSxcblx0bWVzc2FnZTogJ1BsZWFzZSBlbnRlciBhIG51bWJlci4nXG59O1xuXG5rdi5ydWxlc1snZGlnaXQnXSA9IHtcblx0dmFsaWRhdG9yOiBmdW5jdGlvbiAodmFsdWUsIHZhbGlkYXRlKSB7XG5cdFx0aWYgKCF2YWxpZGF0ZSkgeyByZXR1cm4gdHJ1ZTsgfVxuXHRcdHJldHVybiBrdi51dGlscy5pc0VtcHR5VmFsKHZhbHVlKSB8fCAodmFsaWRhdGUgJiYgL15cXGQrJC8udGVzdCh2YWx1ZSkpO1xuXHR9LFxuXHRtZXNzYWdlOiAnUGxlYXNlIGVudGVyIGEgZGlnaXQuJ1xufTtcblxua3YucnVsZXNbJ3Bob25lVVMnXSA9IHtcblx0dmFsaWRhdG9yOiBmdW5jdGlvbiAocGhvbmVOdW1iZXIsIHZhbGlkYXRlKSB7XG5cdFx0aWYgKCF2YWxpZGF0ZSkgeyByZXR1cm4gdHJ1ZTsgfVxuXHRcdGlmIChrdi51dGlscy5pc0VtcHR5VmFsKHBob25lTnVtYmVyKSkgeyByZXR1cm4gdHJ1ZTsgfSAvLyBtYWtlcyBpdCBvcHRpb25hbCwgdXNlICdyZXF1aXJlZCcgcnVsZSBpZiBpdCBzaG91bGQgYmUgcmVxdWlyZWRcblx0XHRpZiAodHlwZW9mIChwaG9uZU51bWJlcikgIT09ICdzdHJpbmcnKSB7IHJldHVybiBmYWxzZTsgfVxuXHRcdHBob25lTnVtYmVyID0gcGhvbmVOdW1iZXIucmVwbGFjZSgvXFxzKy9nLCBcIlwiKTtcblx0XHRyZXR1cm4gdmFsaWRhdGUgJiYgcGhvbmVOdW1iZXIubGVuZ3RoID4gOSAmJiBwaG9uZU51bWJlci5tYXRjaCgvXigxLT8pPyhcXChbMi05XVxcZHsyfVxcKXxbMi05XVxcZHsyfSktP1syLTldXFxkezJ9LT9cXGR7NH0kLyk7XG5cdH0sXG5cdG1lc3NhZ2U6ICdQbGVhc2Ugc3BlY2lmeSBhIHZhbGlkIHBob25lIG51bWJlci4nXG59O1xuXG5rdi5ydWxlc1snZXF1YWwnXSA9IHtcblx0dmFsaWRhdG9yOiBmdW5jdGlvbiAodmFsLCBwYXJhbXMpIHtcblx0XHR2YXIgb3RoZXJWYWx1ZSA9IHBhcmFtcztcblx0XHRyZXR1cm4gdmFsID09PSBrdi51dGlscy5nZXRWYWx1ZShvdGhlclZhbHVlKTtcblx0fSxcblx0bWVzc2FnZTogJ1ZhbHVlcyBtdXN0IGVxdWFsLidcbn07XG5cbmt2LnJ1bGVzWydub3RFcXVhbCddID0ge1xuXHR2YWxpZGF0b3I6IGZ1bmN0aW9uICh2YWwsIHBhcmFtcykge1xuXHRcdHZhciBvdGhlclZhbHVlID0gcGFyYW1zO1xuXHRcdHJldHVybiB2YWwgIT09IGt2LnV0aWxzLmdldFZhbHVlKG90aGVyVmFsdWUpO1xuXHR9LFxuXHRtZXNzYWdlOiAnUGxlYXNlIGNob29zZSBhbm90aGVyIHZhbHVlLidcbn07XG5cbi8vdW5pcXVlIGluIGNvbGxlY3Rpb25cbi8vIG9wdGlvbnMgYXJlOlxuLy8gICAgY29sbGVjdGlvbjogYXJyYXkgb3IgZnVuY3Rpb24gcmV0dXJuaW5nIChvYnNlcnZhYmxlKSBhcnJheVxuLy8gICAgICAgICAgICAgIGluIHdoaWNoIHRoZSB2YWx1ZSBoYXMgdG8gYmUgdW5pcXVlXG4vLyAgICB2YWx1ZUFjY2Vzc29yOiBmdW5jdGlvbiB0aGF0IHJldHVybnMgdmFsdWUgZnJvbSBhbiBvYmplY3Qgc3RvcmVkIGluIGNvbGxlY3Rpb25cbi8vICAgICAgICAgICAgICBpZiBpdCBpcyBudWxsIHRoZSB2YWx1ZSBpcyBjb21wYXJlZCBkaXJlY3RseVxuLy8gICAgZXh0ZXJuYWw6IHNldCB0byB0cnVlIHdoZW4gb2JqZWN0IHlvdSBhcmUgdmFsaWRhdGluZyBpcyBhdXRvbWF0aWNhbGx5IHVwZGF0aW5nIGNvbGxlY3Rpb25cbmt2LnJ1bGVzWyd1bmlxdWUnXSA9IHtcblx0dmFsaWRhdG9yOiBmdW5jdGlvbiAodmFsLCBvcHRpb25zKSB7XG5cdFx0dmFyIGMgPSBrdi51dGlscy5nZXRWYWx1ZShvcHRpb25zLmNvbGxlY3Rpb24pLFxuXHRcdFx0ZXh0ZXJuYWwgPSBrdi51dGlscy5nZXRWYWx1ZShvcHRpb25zLmV4dGVybmFsVmFsdWUpLFxuXHRcdFx0Y291bnRlciA9IDA7XG5cblx0XHRpZiAoIXZhbCB8fCAhYykgeyByZXR1cm4gdHJ1ZTsgfVxuXG5cdFx0a29VdGlscy5hcnJheUZpbHRlcihjLCBmdW5jdGlvbiAoaXRlbSkge1xuXHRcdFx0aWYgKHZhbCA9PT0gKG9wdGlvbnMudmFsdWVBY2Nlc3NvciA/IG9wdGlvbnMudmFsdWVBY2Nlc3NvcihpdGVtKSA6IGl0ZW0pKSB7IGNvdW50ZXIrKzsgfVxuXHRcdH0pO1xuXHRcdC8vIGlmIHZhbHVlIGlzIGV4dGVybmFsIGV2ZW4gMSBzYW1lIHZhbHVlIGluIGNvbGxlY3Rpb24gbWVhbnMgdGhlIHZhbHVlIGlzIG5vdCB1bmlxdWVcblx0XHRyZXR1cm4gY291bnRlciA8ICghIWV4dGVybmFsID8gMSA6IDIpO1xuXHR9LFxuXHRtZXNzYWdlOiAnUGxlYXNlIG1ha2Ugc3VyZSB0aGUgdmFsdWUgaXMgdW5pcXVlLidcbn07XG5cblxuLy9ub3cgcmVnaXN0ZXIgYWxsIG9mIHRoZXNlIVxuKGZ1bmN0aW9uICgpIHtcblx0a3YucmVnaXN0ZXJFeHRlbmRlcnMoKTtcbn0oKSk7XG47Ly8gVGhlIGNvcmUgYmluZGluZyBoYW5kbGVyXG4vLyB0aGlzIGFsbG93cyB1cyB0byBzZXR1cCBhbnkgdmFsdWUgYmluZGluZyB0aGF0IGludGVybmFsbHkgYWx3YXlzXG4vLyBwZXJmb3JtcyB0aGUgc2FtZSBmdW5jdGlvbmFsaXR5XG5rby5iaW5kaW5nSGFuZGxlcnNbJ3ZhbGlkYXRpb25Db3JlJ10gPSAoZnVuY3Rpb24gKCkge1xuXG5cdHJldHVybiB7XG5cdFx0aW5pdDogZnVuY3Rpb24gKGVsZW1lbnQsIHZhbHVlQWNjZXNzb3IsIGFsbEJpbmRpbmdzQWNjZXNzb3IsIHZpZXdNb2RlbCwgYmluZGluZ0NvbnRleHQpIHtcblx0XHRcdHZhciBjb25maWcgPSBrdi51dGlscy5nZXRDb25maWdPcHRpb25zKGVsZW1lbnQpO1xuXHRcdFx0dmFyIG9ic2VydmFibGUgPSB2YWx1ZUFjY2Vzc29yKCk7XG5cblx0XHRcdC8vIHBhcnNlIGh0bWw1IGlucHV0IHZhbGlkYXRpb24gYXR0cmlidXRlcywgb3B0aW9uYWwgZmVhdHVyZVxuXHRcdFx0aWYgKGNvbmZpZy5wYXJzZUlucHV0QXR0cmlidXRlcykge1xuXHRcdFx0XHRrdi51dGlscy5hc3luYyhmdW5jdGlvbiAoKSB7IGt2LnBhcnNlSW5wdXRWYWxpZGF0aW9uQXR0cmlidXRlcyhlbGVtZW50LCB2YWx1ZUFjY2Vzc29yKTsgfSk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIGlmIHJlcXVlc3RlZCBpbnNlcnQgbWVzc2FnZSBlbGVtZW50IGFuZCBhcHBseSBiaW5kaW5nc1xuXHRcdFx0aWYgKGNvbmZpZy5pbnNlcnRNZXNzYWdlcyAmJiBrdi51dGlscy5pc1ZhbGlkYXRhYmxlKG9ic2VydmFibGUpKSB7XG5cblx0XHRcdFx0Ly8gaW5zZXJ0IHRoZSA8c3Bhbj48L3NwYW4+XG5cdFx0XHRcdHZhciB2YWxpZGF0aW9uTWVzc2FnZUVsZW1lbnQgPSBrdi5pbnNlcnRWYWxpZGF0aW9uTWVzc2FnZShlbGVtZW50KTtcblxuXHRcdFx0XHQvLyBpZiB3ZSdyZSB0b2xkIHRvIHVzZSBhIHRlbXBsYXRlLCBtYWtlIHN1cmUgdGhhdCBnZXRzIHJlbmRlcmVkXG5cdFx0XHRcdGlmIChjb25maWcubWVzc2FnZVRlbXBsYXRlKSB7XG5cdFx0XHRcdFx0a28ucmVuZGVyVGVtcGxhdGUoY29uZmlnLm1lc3NhZ2VUZW1wbGF0ZSwgeyBmaWVsZDogb2JzZXJ2YWJsZSB9LCBudWxsLCB2YWxpZGF0aW9uTWVzc2FnZUVsZW1lbnQsICdyZXBsYWNlTm9kZScpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGtvLmFwcGx5QmluZGluZ3NUb05vZGUodmFsaWRhdGlvbk1lc3NhZ2VFbGVtZW50LCB7IHZhbGlkYXRpb25NZXNzYWdlOiBvYnNlcnZhYmxlIH0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIHdyaXRlIHRoZSBodG1sNSBhdHRyaWJ1dGVzIGlmIGluZGljYXRlZCBieSB0aGUgY29uZmlnXG5cdFx0XHRpZiAoY29uZmlnLndyaXRlSW5wdXRBdHRyaWJ1dGVzICYmIGt2LnV0aWxzLmlzVmFsaWRhdGFibGUob2JzZXJ2YWJsZSkpIHtcblxuXHRcdFx0XHRrdi53cml0ZUlucHV0VmFsaWRhdGlvbkF0dHJpYnV0ZXMoZWxlbWVudCwgdmFsdWVBY2Nlc3Nvcik7XG5cdFx0XHR9XG5cblx0XHRcdC8vIGlmIHJlcXVlc3RlZCwgYWRkIGJpbmRpbmcgdG8gZGVjb3JhdGUgZWxlbWVudFxuXHRcdFx0aWYgKGNvbmZpZy5kZWNvcmF0ZUlucHV0RWxlbWVudCAmJiBrdi51dGlscy5pc1ZhbGlkYXRhYmxlKG9ic2VydmFibGUpKSB7XG5cdFx0XHRcdGtvLmFwcGx5QmluZGluZ3NUb05vZGUoZWxlbWVudCwgeyB2YWxpZGF0aW9uRWxlbWVudDogb2JzZXJ2YWJsZSB9KTtcblx0XHRcdH1cblx0XHR9XG5cdH07XG5cbn0oKSk7XG5cbi8vIG92ZXJyaWRlIGZvciBLTydzIGRlZmF1bHQgJ3ZhbHVlJywgJ2NoZWNrZWQnLCAndGV4dElucHV0JyBhbmQgc2VsZWN0ZWRPcHRpb25zIGJpbmRpbmdzXG5rdi5tYWtlQmluZGluZ0hhbmRsZXJWYWxpZGF0YWJsZShcInZhbHVlXCIpO1xua3YubWFrZUJpbmRpbmdIYW5kbGVyVmFsaWRhdGFibGUoXCJjaGVja2VkXCIpO1xuaWYgKGtvLmJpbmRpbmdIYW5kbGVycy50ZXh0SW5wdXQpIHtcblx0a3YubWFrZUJpbmRpbmdIYW5kbGVyVmFsaWRhdGFibGUoXCJ0ZXh0SW5wdXRcIik7XG59XG5rdi5tYWtlQmluZGluZ0hhbmRsZXJWYWxpZGF0YWJsZShcInNlbGVjdGVkT3B0aW9uc1wiKTtcblxuXG5rby5iaW5kaW5nSGFuZGxlcnNbJ3ZhbGlkYXRpb25NZXNzYWdlJ10gPSB7IC8vIGluZGl2aWR1YWwgZXJyb3IgbWVzc2FnZSwgaWYgbW9kaWZpZWQgb3IgcG9zdCBiaW5kaW5nXG5cdHVwZGF0ZTogZnVuY3Rpb24gKGVsZW1lbnQsIHZhbHVlQWNjZXNzb3IpIHtcblx0XHR2YXIgb2JzdiA9IHZhbHVlQWNjZXNzb3IoKSxcblx0XHRcdGNvbmZpZyA9IGt2LnV0aWxzLmdldENvbmZpZ09wdGlvbnMoZWxlbWVudCksXG5cdFx0XHR2YWwgPSB1bndyYXAob2JzdiksXG5cdFx0XHRtc2cgPSBudWxsLFxuXHRcdFx0aXNNb2RpZmllZCA9IGZhbHNlLFxuXHRcdFx0aXNWYWxpZCA9IGZhbHNlO1xuXG5cdFx0aWYgKG9ic3YgPT09IG51bGwgfHwgdHlwZW9mIG9ic3YgPT09ICd1bmRlZmluZWQnKSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBiaW5kIHZhbGlkYXRpb25NZXNzYWdlIHRvIHVuZGVmaW5lZCB2YWx1ZS4gZGF0YS1iaW5kIGV4cHJlc3Npb246ICcgK1xuXHRcdFx0XHRlbGVtZW50LmdldEF0dHJpYnV0ZSgnZGF0YS1iaW5kJykpO1xuXHRcdH1cblxuXHRcdGlzTW9kaWZpZWQgPSBvYnN2LmlzTW9kaWZpZWQgJiYgb2Jzdi5pc01vZGlmaWVkKCk7XG5cdFx0aXNWYWxpZCA9IG9ic3YuaXNWYWxpZCAmJiBvYnN2LmlzVmFsaWQoKTtcblxuXHRcdHZhciBlcnJvciA9IG51bGw7XG5cdFx0aWYgKCFjb25maWcubWVzc2FnZXNPbk1vZGlmaWVkIHx8IGlzTW9kaWZpZWQpIHtcblx0XHRcdGVycm9yID0gaXNWYWxpZCA/IG51bGwgOiBvYnN2LmVycm9yO1xuXHRcdH1cblxuXHRcdHZhciBpc1Zpc2libGUgPSAhY29uZmlnLm1lc3NhZ2VzT25Nb2RpZmllZCB8fCBpc01vZGlmaWVkID8gIWlzVmFsaWQgOiBmYWxzZTtcblx0XHR2YXIgaXNDdXJyZW50bHlWaXNpYmxlID0gZWxlbWVudC5zdHlsZS5kaXNwbGF5ICE9PSBcIm5vbmVcIjtcblxuXHRcdGlmIChjb25maWcuYWxsb3dIdG1sTWVzc2FnZXMpIHtcblx0XHRcdGtvVXRpbHMuc2V0SHRtbChlbGVtZW50LCBlcnJvcik7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGtvLmJpbmRpbmdIYW5kbGVycy50ZXh0LnVwZGF0ZShlbGVtZW50LCBmdW5jdGlvbiAoKSB7IHJldHVybiBlcnJvcjsgfSk7XG5cdFx0fVxuXG5cdFx0aWYgKGlzQ3VycmVudGx5VmlzaWJsZSAmJiAhaXNWaXNpYmxlKSB7XG5cdFx0XHRlbGVtZW50LnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG5cdFx0fSBlbHNlIGlmICghaXNDdXJyZW50bHlWaXNpYmxlICYmIGlzVmlzaWJsZSkge1xuXHRcdFx0ZWxlbWVudC5zdHlsZS5kaXNwbGF5ID0gJyc7XG5cdFx0fVxuXHR9XG59O1xuXG5rby5iaW5kaW5nSGFuZGxlcnNbJ3ZhbGlkYXRpb25FbGVtZW50J10gPSB7XG5cdHVwZGF0ZTogZnVuY3Rpb24gKGVsZW1lbnQsIHZhbHVlQWNjZXNzb3IsIGFsbEJpbmRpbmdzQWNjZXNzb3IpIHtcblx0XHR2YXIgb2JzdiA9IHZhbHVlQWNjZXNzb3IoKSxcblx0XHRcdGNvbmZpZyA9IGt2LnV0aWxzLmdldENvbmZpZ09wdGlvbnMoZWxlbWVudCksXG5cdFx0XHR2YWwgPSB1bndyYXAob2JzdiksXG5cdFx0XHRtc2cgPSBudWxsLFxuXHRcdFx0aXNNb2RpZmllZCA9IGZhbHNlLFxuXHRcdFx0aXNWYWxpZCA9IGZhbHNlO1xuXG5cdFx0aWYgKG9ic3YgPT09IG51bGwgfHwgdHlwZW9mIG9ic3YgPT09ICd1bmRlZmluZWQnKSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBiaW5kIHZhbGlkYXRpb25FbGVtZW50IHRvIHVuZGVmaW5lZCB2YWx1ZS4gZGF0YS1iaW5kIGV4cHJlc3Npb246ICcgK1xuXHRcdFx0XHRlbGVtZW50LmdldEF0dHJpYnV0ZSgnZGF0YS1iaW5kJykpO1xuXHRcdH1cblxuXHRcdGlzTW9kaWZpZWQgPSBvYnN2LmlzTW9kaWZpZWQgJiYgb2Jzdi5pc01vZGlmaWVkKCk7XG5cdFx0aXNWYWxpZCA9IG9ic3YuaXNWYWxpZCAmJiBvYnN2LmlzVmFsaWQoKTtcblxuXHRcdC8vIGNyZWF0ZSBhbiBldmFsdWF0b3IgZnVuY3Rpb24gdGhhdCB3aWxsIHJldHVybiBzb21ldGhpbmcgbGlrZTpcblx0XHQvLyBjc3M6IHsgdmFsaWRhdGlvbkVsZW1lbnQ6IHRydWUgfVxuXHRcdHZhciBjc3NTZXR0aW5nc0FjY2Vzc29yID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0dmFyIGNzcyA9IHt9O1xuXG5cdFx0XHR2YXIgc2hvdWxkU2hvdyA9ICgoIWNvbmZpZy5kZWNvcmF0ZUVsZW1lbnRPbk1vZGlmaWVkIHx8IGlzTW9kaWZpZWQpID8gIWlzVmFsaWQgOiBmYWxzZSk7XG5cblx0XHRcdC8vIGNzczogeyB2YWxpZGF0aW9uRWxlbWVudDogZmFsc2UgfVxuXHRcdFx0Y3NzW2NvbmZpZy5lcnJvckVsZW1lbnRDbGFzc10gPSBzaG91bGRTaG93O1xuXG5cdFx0XHRyZXR1cm4gY3NzO1xuXHRcdH07XG5cblx0XHQvL2FkZCBvciByZW1vdmUgY2xhc3Mgb24gdGhlIGVsZW1lbnQ7XG5cdFx0a28uYmluZGluZ0hhbmRsZXJzLmNzcy51cGRhdGUoZWxlbWVudCwgY3NzU2V0dGluZ3NBY2Nlc3NvciwgYWxsQmluZGluZ3NBY2Nlc3Nvcik7XG5cdFx0aWYgKCFjb25maWcuZXJyb3JzQXNUaXRsZSkgeyByZXR1cm47IH1cblxuXHRcdGtvLmJpbmRpbmdIYW5kbGVycy5hdHRyLnVwZGF0ZShlbGVtZW50LCBmdW5jdGlvbiAoKSB7XG5cdFx0XHR2YXJcblx0XHRcdFx0aGFzTW9kaWZpY2F0aW9uID0gIWNvbmZpZy5lcnJvcnNBc1RpdGxlT25Nb2RpZmllZCB8fCBpc01vZGlmaWVkLFxuXHRcdFx0XHR0aXRsZSA9IGt2LnV0aWxzLmdldE9yaWdpbmFsRWxlbWVudFRpdGxlKGVsZW1lbnQpO1xuXG5cdFx0XHRpZiAoaGFzTW9kaWZpY2F0aW9uICYmICFpc1ZhbGlkKSB7XG5cdFx0XHRcdHJldHVybiB7IHRpdGxlOiBvYnN2LmVycm9yLCAnZGF0YS1vcmlnLXRpdGxlJzogdGl0bGUgfTtcblx0XHRcdH0gZWxzZSBpZiAoIWhhc01vZGlmaWNhdGlvbiB8fCBpc1ZhbGlkKSB7XG5cdFx0XHRcdHJldHVybiB7IHRpdGxlOiB0aXRsZSwgJ2RhdGEtb3JpZy10aXRsZSc6IG51bGwgfTtcblx0XHRcdH1cblx0XHR9KTtcblx0fVxufTtcblxuLy8gVmFsaWRhdGlvbk9wdGlvbnM6XG4vLyBUaGlzIGJpbmRpbmcgaGFuZGxlciBhbGxvd3MgeW91IHRvIG92ZXJyaWRlIHRoZSBpbml0aWFsIGNvbmZpZyBieSBzZXR0aW5nIGFueSBvZiB0aGUgb3B0aW9ucyBmb3IgYSBzcGVjaWZpYyBlbGVtZW50IG9yIGNvbnRleHQgb2YgZWxlbWVudHNcbi8vXG4vLyBFeGFtcGxlOlxuLy8gPGRpdiBkYXRhLWJpbmQ9XCJ2YWxpZGF0aW9uT3B0aW9uczogeyBpbnNlcnRNZXNzYWdlczogdHJ1ZSwgbWVzc2FnZVRlbXBsYXRlOiAnY3VzdG9tVGVtcGxhdGUnLCBlcnJvck1lc3NhZ2VDbGFzczogJ215U3BlY2lhbENsYXNzJ31cIj5cbi8vICAgICAgPGlucHV0IHR5cGU9XCJ0ZXh0XCIgZGF0YS1iaW5kPVwidmFsdWU6IHNvbWVWYWx1ZVwiLz5cbi8vICAgICAgPGlucHV0IHR5cGU9XCJ0ZXh0XCIgZGF0YS1iaW5kPVwidmFsdWU6IHNvbWVWYWx1ZTJcIi8+XG4vLyA8L2Rpdj5cbmtvLmJpbmRpbmdIYW5kbGVyc1sndmFsaWRhdGlvbk9wdGlvbnMnXSA9IChmdW5jdGlvbiAoKSB7XG5cdHJldHVybiB7XG5cdFx0aW5pdDogZnVuY3Rpb24gKGVsZW1lbnQsIHZhbHVlQWNjZXNzb3IsIGFsbEJpbmRpbmdzQWNjZXNzb3IsIHZpZXdNb2RlbCwgYmluZGluZ0NvbnRleHQpIHtcblx0XHRcdHZhciBvcHRpb25zID0gdW53cmFwKHZhbHVlQWNjZXNzb3IoKSk7XG5cdFx0XHRpZiAob3B0aW9ucykge1xuXHRcdFx0XHR2YXIgbmV3Q29uZmlnID0gZXh0ZW5kKHt9LCBrdi5jb25maWd1cmF0aW9uKTtcblx0XHRcdFx0ZXh0ZW5kKG5ld0NvbmZpZywgb3B0aW9ucyk7XG5cblx0XHRcdFx0Ly9zdG9yZSB0aGUgdmFsaWRhdGlvbiBvcHRpb25zIG9uIHRoZSBub2RlIHNvIHdlIGNhbiByZXRyaWV2ZSBpdCBsYXRlclxuXHRcdFx0XHRrdi51dGlscy5zZXREb21EYXRhKGVsZW1lbnQsIG5ld0NvbmZpZyk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xufSgpKTtcbjsvLyBWYWxpZGF0aW9uIEV4dGVuZGVyOlxuLy8gVGhpcyBpcyBmb3IgY3JlYXRpbmcgY3VzdG9tIHZhbGlkYXRpb24gbG9naWMgb24gdGhlIGZseVxuLy8gRXhhbXBsZTpcbi8vIHZhciB0ZXN0ID0ga28ub2JzZXJ2YWJsZSgnc29tZXRoaW5nJykuZXh0ZW5keyhcbi8vICAgICAgdmFsaWRhdGlvbjoge1xuLy8gICAgICAgICAgdmFsaWRhdG9yOiBmdW5jdGlvbih2YWwsIHNvbWVPdGhlclZhbCl7XG4vLyAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4vLyAgICAgICAgICB9LFxuLy8gICAgICAgICAgbWVzc2FnZTogXCJTb21ldGhpbmcgbXVzdCBiZSByZWFsbHkgd3JvbmchJyxcbi8vICAgICAgICAgIHBhcmFtczogdHJ1ZVxuLy8gICAgICB9XG4vLyAgKX07XG5rby5leHRlbmRlcnNbJ3ZhbGlkYXRpb24nXSA9IGZ1bmN0aW9uIChvYnNlcnZhYmxlLCBydWxlcykgeyAvLyBhbGxvdyBzaW5nbGUgcnVsZSBvciBhcnJheVxuXHRmb3JFYWNoKGt2LnV0aWxzLmlzQXJyYXkocnVsZXMpID8gcnVsZXMgOiBbcnVsZXNdLCBmdW5jdGlvbiAocnVsZSkge1xuXHRcdC8vIHRoZSAncnVsZScgYmVpbmcgcGFzc2VkIGluIGhlcmUgaGFzIG5vIG5hbWUgdG8gaWRlbnRpZnkgYSBjb3JlIFJ1bGUsXG5cdFx0Ly8gc28gd2UgYWRkIGl0IGFzIGFuIGFub255bW91cyBydWxlXG5cdFx0Ly8gSWYgdGhlIGRldmVsb3BlciBpcyB3YW50aW5nIHRvIHVzZSBhIGNvcmUgUnVsZSwgYnV0IHVzZSBhIGRpZmZlcmVudCBtZXNzYWdlIHNlZSB0aGUgJ2FkZEV4dGVuZGVyJyBsb2dpYyBmb3IgZXhhbXBsZXNcblx0XHRrdi5hZGRBbm9ueW1vdXNSdWxlKG9ic2VydmFibGUsIHJ1bGUpO1xuXHR9KTtcblx0cmV0dXJuIG9ic2VydmFibGU7XG59O1xuXG4vL1RoaXMgaXMgdGhlIGV4dGVuZGVyIHRoYXQgbWFrZXMgYSBLbm9ja291dCBPYnNlcnZhYmxlIGFsc28gJ1ZhbGlkYXRhYmxlJ1xuLy9leGFtcGxlcyBpbmNsdWRlOlxuLy8gMS4gdmFyIHRlc3QgPSBrby5vYnNlcnZhYmxlKCdzb21ldGhpbmcnKS5leHRlbmQoe3ZhbGlkYXRhYmxlOiB0cnVlfSk7XG4vLyB0aGlzIHdpbGwgZW5zdXJlIHRoYXQgdGhlIE9ic2VydmFibGUgb2JqZWN0IGlzIHNldHVwIHByb3Blcmx5IHRvIHJlc3BvbmQgdG8gcnVsZXNcbi8vXG4vLyAyLiB0ZXN0LmV4dGVuZCh7dmFsaWRhdGFibGU6IGZhbHNlfSk7XG4vLyB0aGlzIHdpbGwgcmVtb3ZlIHRoZSB2YWxpZGF0aW9uIHByb3BlcnRpZXMgZnJvbSB0aGUgT2JzZXJ2YWJsZSBvYmplY3Qgc2hvdWxkIHlvdSBuZWVkIHRvIGRvIHRoYXQuXG5rby5leHRlbmRlcnNbJ3ZhbGlkYXRhYmxlJ10gPSBmdW5jdGlvbiAob2JzZXJ2YWJsZSwgb3B0aW9ucykge1xuXHRpZiAoIWt2LnV0aWxzLmlzT2JqZWN0KG9wdGlvbnMpKSB7XG5cdFx0b3B0aW9ucyA9IHsgZW5hYmxlOiBvcHRpb25zIH07XG5cdH1cblxuXHRpZiAoISgnZW5hYmxlJyBpbiBvcHRpb25zKSkge1xuXHRcdG9wdGlvbnMuZW5hYmxlID0gdHJ1ZTtcblx0fVxuXG5cdGlmIChvcHRpb25zLmVuYWJsZSAmJiAha3YudXRpbHMuaXNWYWxpZGF0YWJsZShvYnNlcnZhYmxlKSkge1xuXHRcdHZhciBjb25maWcgPSBrdi5jb25maWd1cmF0aW9uLnZhbGlkYXRlIHx8IHt9O1xuXHRcdHZhciB2YWxpZGF0aW9uT3B0aW9ucyA9IHtcblx0XHRcdHRocm90dGxlRXZhbHVhdGlvbiA6IG9wdGlvbnMudGhyb3R0bGUgfHwgY29uZmlnLnRocm90dGxlXG5cdFx0fTtcblxuXHRcdG9ic2VydmFibGUuZXJyb3IgPSBrby5vYnNlcnZhYmxlKG51bGwpOyAvLyBob2xkcyB0aGUgZXJyb3IgbWVzc2FnZSwgd2Ugb25seSBuZWVkIG9uZSBzaW5jZSB3ZSBzdG9wIHByb2Nlc3NpbmcgdmFsaWRhdG9ycyB3aGVuIG9uZSBpcyBpbnZhbGlkXG5cblx0XHQvLyBvYnNlcnZhYmxlLnJ1bGVzOlxuXHRcdC8vIE9ic2VydmFibGVBcnJheSBvZiBSdWxlIENvbnRleHRzLCB3aGVyZSBhIFJ1bGUgQ29udGV4dCBpcyBzaW1wbHkgdGhlIG5hbWUgb2YgYSBydWxlIGFuZCB0aGUgcGFyYW1zIHRvIHN1cHBseSB0byBpdFxuXHRcdC8vXG5cdFx0Ly8gUnVsZSBDb250ZXh0ID0geyBydWxlOiAnPHJ1bGUgbmFtZT4nLCBwYXJhbXM6ICc8cGFzc2VkIGluIHBhcmFtcz4nLCBtZXNzYWdlOiAnPE92ZXJyaWRlIG9mIGRlZmF1bHQgTWVzc2FnZT4nIH1cblx0XHRvYnNlcnZhYmxlLnJ1bGVzID0ga28ub2JzZXJ2YWJsZUFycmF5KCk7IC8vaG9sZHMgdGhlIHJ1bGUgQ29udGV4dHMgdG8gdXNlIGFzIHBhcnQgb2YgdmFsaWRhdGlvblxuXG5cdFx0Ly9pbiBjYXNlIGFzeW5jIHZhbGlkYXRpb24gaXMgb2NjdXJyaW5nXG5cdFx0b2JzZXJ2YWJsZS5pc1ZhbGlkYXRpbmcgPSBrby5vYnNlcnZhYmxlKGZhbHNlKTtcblxuXHRcdC8vdGhlIHRydWUgaG9sZGVyIG9mIHdoZXRoZXIgdGhlIG9ic2VydmFibGUgaXMgdmFsaWQgb3Igbm90XG5cdFx0b2JzZXJ2YWJsZS5fX3ZhbGlkX18gPSBrby5vYnNlcnZhYmxlKHRydWUpO1xuXG5cdFx0b2JzZXJ2YWJsZS5pc01vZGlmaWVkID0ga28ub2JzZXJ2YWJsZShmYWxzZSk7XG5cblx0XHQvLyBhIHNlbWktcHJvdGVjdGVkIG9ic2VydmFibGVcblx0XHRvYnNlcnZhYmxlLmlzVmFsaWQgPSBrby5jb21wdXRlZChvYnNlcnZhYmxlLl9fdmFsaWRfXyk7XG5cblx0XHQvL21hbnVhbGx5IHNldCBlcnJvciBzdGF0ZVxuXHRcdG9ic2VydmFibGUuc2V0RXJyb3IgPSBmdW5jdGlvbiAoZXJyb3IpIHtcblx0XHRcdHZhciBwcmV2aW91c0Vycm9yID0gb2JzZXJ2YWJsZS5lcnJvci5wZWVrKCk7XG5cdFx0XHR2YXIgcHJldmlvdXNJc1ZhbGlkID0gb2JzZXJ2YWJsZS5fX3ZhbGlkX18ucGVlaygpO1xuXG5cdFx0XHRvYnNlcnZhYmxlLmVycm9yKGVycm9yKTtcblx0XHRcdG9ic2VydmFibGUuX192YWxpZF9fKGZhbHNlKTtcblxuXHRcdFx0aWYgKHByZXZpb3VzRXJyb3IgIT09IGVycm9yICYmICFwcmV2aW91c0lzVmFsaWQpIHtcblx0XHRcdFx0Ly8gaWYgdGhlIG9ic2VydmFibGUgd2FzIG5vdCB2YWxpZCBiZWZvcmUgdGhlbiBpc1ZhbGlkIHdpbGwgbm90IG11dGF0ZSxcblx0XHRcdFx0Ly8gaGVuY2UgY2F1c2luZyBhbnkgZ3JvdXBpbmcgdG8gbm90IGRpc3BsYXkgdGhlIGxhdGVzdCBlcnJvci5cblx0XHRcdFx0b2JzZXJ2YWJsZS5pc1ZhbGlkLm5vdGlmeVN1YnNjcmliZXJzKCk7XG5cdFx0XHR9XG5cdFx0fTtcblxuXHRcdC8vbWFudWFsbHkgY2xlYXIgZXJyb3Igc3RhdGVcblx0XHRvYnNlcnZhYmxlLmNsZWFyRXJyb3IgPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHRvYnNlcnZhYmxlLmVycm9yKG51bGwpO1xuXHRcdFx0b2JzZXJ2YWJsZS5fX3ZhbGlkX18odHJ1ZSk7XG5cdFx0XHRyZXR1cm4gb2JzZXJ2YWJsZTtcblx0XHR9O1xuXG5cdFx0Ly9zdWJzY3JpYmUgdG8gY2hhbmdlcyBpbiB0aGUgb2JzZXJ2YWJsZVxuXHRcdHZhciBoX2NoYW5nZSA9IG9ic2VydmFibGUuc3Vic2NyaWJlKGZ1bmN0aW9uICgpIHtcblx0XHRcdG9ic2VydmFibGUuaXNNb2RpZmllZCh0cnVlKTtcblx0XHR9KTtcblxuXHRcdC8vIHdlIHVzZSBhIGNvbXB1dGVkIGhlcmUgdG8gZW5zdXJlIHRoYXQgYW55dGltZSBhIGRlcGVuZGVuY3kgY2hhbmdlcywgdGhlXG5cdFx0Ly8gdmFsaWRhdGlvbiBsb2dpYyBldmFsdWF0ZXNcblx0XHR2YXIgaF9vYnNWYWxpZGF0aW9uVHJpZ2dlciA9IGtvLmNvbXB1dGVkKGV4dGVuZCh7XG5cdFx0XHRyZWFkOiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdHZhciBvYnMgPSBvYnNlcnZhYmxlKCksXG5cdFx0XHRcdFx0cnVsZUNvbnRleHRzID0gb2JzZXJ2YWJsZS5ydWxlcygpO1xuXG5cdFx0XHRcdGt2LnZhbGlkYXRlT2JzZXJ2YWJsZShvYnNlcnZhYmxlKTtcblxuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblx0XHR9LCB2YWxpZGF0aW9uT3B0aW9ucykpO1xuXG5cdFx0ZXh0ZW5kKGhfb2JzVmFsaWRhdGlvblRyaWdnZXIsIHZhbGlkYXRpb25PcHRpb25zKTtcblxuXHRcdG9ic2VydmFibGUuX2Rpc3Bvc2VWYWxpZGF0aW9uID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0Ly9maXJzdCBkaXNwb3NlIG9mIHRoZSBzdWJzY3JpcHRpb25zXG5cdFx0XHRvYnNlcnZhYmxlLmlzVmFsaWQuZGlzcG9zZSgpO1xuXHRcdFx0b2JzZXJ2YWJsZS5ydWxlcy5yZW1vdmVBbGwoKTtcblx0XHRcdGhfY2hhbmdlLmRpc3Bvc2UoKTtcblx0XHRcdGhfb2JzVmFsaWRhdGlvblRyaWdnZXIuZGlzcG9zZSgpO1xuXG5cdFx0XHRkZWxldGUgb2JzZXJ2YWJsZVsncnVsZXMnXTtcblx0XHRcdGRlbGV0ZSBvYnNlcnZhYmxlWydlcnJvciddO1xuXHRcdFx0ZGVsZXRlIG9ic2VydmFibGVbJ2lzVmFsaWQnXTtcblx0XHRcdGRlbGV0ZSBvYnNlcnZhYmxlWydpc1ZhbGlkYXRpbmcnXTtcblx0XHRcdGRlbGV0ZSBvYnNlcnZhYmxlWydfX3ZhbGlkX18nXTtcblx0XHRcdGRlbGV0ZSBvYnNlcnZhYmxlWydpc01vZGlmaWVkJ107XG4gICAgICAgICAgICBkZWxldGUgb2JzZXJ2YWJsZVsnc2V0RXJyb3InXTtcbiAgICAgICAgICAgIGRlbGV0ZSBvYnNlcnZhYmxlWydjbGVhckVycm9yJ107XG4gICAgICAgICAgICBkZWxldGUgb2JzZXJ2YWJsZVsnX2Rpc3Bvc2VWYWxpZGF0aW9uJ107XG5cdFx0fTtcblx0fSBlbHNlIGlmIChvcHRpb25zLmVuYWJsZSA9PT0gZmFsc2UgJiYgb2JzZXJ2YWJsZS5fZGlzcG9zZVZhbGlkYXRpb24pIHtcblx0XHRvYnNlcnZhYmxlLl9kaXNwb3NlVmFsaWRhdGlvbigpO1xuXHR9XG5cdHJldHVybiBvYnNlcnZhYmxlO1xufTtcblxuZnVuY3Rpb24gdmFsaWRhdGVTeW5jKG9ic2VydmFibGUsIHJ1bGUsIGN0eCkge1xuXHQvL0V4ZWN1dGUgdGhlIHZhbGlkYXRvciBhbmQgc2VlIGlmIGl0cyB2YWxpZFxuXHRpZiAoIXJ1bGUudmFsaWRhdG9yKG9ic2VydmFibGUoKSwgKGN0eC5wYXJhbXMgPT09IHVuZGVmaW5lZCA/IHRydWUgOiB1bndyYXAoY3R4LnBhcmFtcykpKSkgeyAvLyBkZWZhdWx0IHBhcmFtIGlzIHRydWUsIGVnLiByZXF1aXJlZCA9IHRydWVcblxuXHRcdC8vbm90IHZhbGlkLCBzbyBmb3JtYXQgdGhlIGVycm9yIG1lc3NhZ2UgYW5kIHN0aWNrIGl0IGluIHRoZSAnZXJyb3InIHZhcmlhYmxlXG5cdFx0b2JzZXJ2YWJsZS5zZXRFcnJvcihrdi5mb3JtYXRNZXNzYWdlKFxuXHRcdFx0XHRcdGN0eC5tZXNzYWdlIHx8IHJ1bGUubWVzc2FnZSxcblx0XHRcdFx0XHR1bndyYXAoY3R4LnBhcmFtcyksXG5cdFx0XHRcdFx0b2JzZXJ2YWJsZSkpO1xuXHRcdHJldHVybiBmYWxzZTtcblx0fSBlbHNlIHtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fVxufVxuXG5mdW5jdGlvbiB2YWxpZGF0ZUFzeW5jKG9ic2VydmFibGUsIHJ1bGUsIGN0eCkge1xuXHRvYnNlcnZhYmxlLmlzVmFsaWRhdGluZyh0cnVlKTtcblxuXHR2YXIgY2FsbEJhY2sgPSBmdW5jdGlvbiAodmFsT2JqKSB7XG5cdFx0dmFyIGlzVmFsaWQgPSBmYWxzZSxcblx0XHRcdG1zZyA9ICcnO1xuXG5cdFx0aWYgKCFvYnNlcnZhYmxlLl9fdmFsaWRfXygpKSB7XG5cblx0XHRcdC8vIHNpbmNlIHdlJ3JlIHJldHVybmluZyBlYXJseSwgbWFrZSBzdXJlIHdlIHR1cm4gdGhpcyBvZmZcblx0XHRcdG9ic2VydmFibGUuaXNWYWxpZGF0aW5nKGZhbHNlKTtcblxuXHRcdFx0cmV0dXJuOyAvL2lmIGl0cyBhbHJlYWR5IE5PVCB2YWxpZCwgZG9uJ3QgYWRkIHRvIHRoYXRcblx0XHR9XG5cblx0XHQvL3dlIHdlcmUgaGFuZGVkIGJhY2sgYSBjb21wbGV4IG9iamVjdFxuXHRcdGlmICh2YWxPYmpbJ21lc3NhZ2UnXSkge1xuXHRcdFx0aXNWYWxpZCA9IHZhbE9iai5pc1ZhbGlkO1xuXHRcdFx0bXNnID0gdmFsT2JqLm1lc3NhZ2U7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGlzVmFsaWQgPSB2YWxPYmo7XG5cdFx0fVxuXG5cdFx0aWYgKCFpc1ZhbGlkKSB7XG5cdFx0XHQvL25vdCB2YWxpZCwgc28gZm9ybWF0IHRoZSBlcnJvciBtZXNzYWdlIGFuZCBzdGljayBpdCBpbiB0aGUgJ2Vycm9yJyB2YXJpYWJsZVxuXHRcdFx0b2JzZXJ2YWJsZS5lcnJvcihrdi5mb3JtYXRNZXNzYWdlKFxuXHRcdFx0XHRtc2cgfHwgY3R4Lm1lc3NhZ2UgfHwgcnVsZS5tZXNzYWdlLFxuXHRcdFx0XHR1bndyYXAoY3R4LnBhcmFtcyksXG5cdFx0XHRcdG9ic2VydmFibGUpKTtcblx0XHRcdG9ic2VydmFibGUuX192YWxpZF9fKGlzVmFsaWQpO1xuXHRcdH1cblxuXHRcdC8vIHRlbGwgaXQgdGhhdCB3ZSdyZSBkb25lXG5cdFx0b2JzZXJ2YWJsZS5pc1ZhbGlkYXRpbmcoZmFsc2UpO1xuXHR9O1xuXG5cdGt2LnV0aWxzLmFzeW5jKGZ1bmN0aW9uKCkge1xuXHQgICAgLy9maXJlIHRoZSB2YWxpZGF0b3IgYW5kIGhhbmQgaXQgdGhlIGNhbGxiYWNrXG4gICAgICAgIHJ1bGUudmFsaWRhdG9yKG9ic2VydmFibGUoKSwgY3R4LnBhcmFtcyA9PT0gdW5kZWZpbmVkID8gdHJ1ZSA6IHVud3JhcChjdHgucGFyYW1zKSwgY2FsbEJhY2spO1xuXHR9KTtcbn1cblxua3YudmFsaWRhdGVPYnNlcnZhYmxlID0gZnVuY3Rpb24gKG9ic2VydmFibGUpIHtcblx0dmFyIGkgPSAwLFxuXHRcdHJ1bGUsIC8vIHRoZSBydWxlIHZhbGlkYXRvciB0byBleGVjdXRlXG5cdFx0Y3R4LCAvLyB0aGUgY3VycmVudCBSdWxlIENvbnRleHQgZm9yIHRoZSBsb29wXG5cdFx0cnVsZUNvbnRleHRzID0gb2JzZXJ2YWJsZS5ydWxlcygpLCAvL2NhY2hlIGZvciBpdGVyYXRvclxuXHRcdGxlbiA9IHJ1bGVDb250ZXh0cy5sZW5ndGg7IC8vY2FjaGUgZm9yIGl0ZXJhdG9yXG5cblx0Zm9yICg7IGkgPCBsZW47IGkrKykge1xuXG5cdFx0Ly9nZXQgdGhlIFJ1bGUgQ29udGV4dCBpbmZvIHRvIGdpdmUgdG8gdGhlIGNvcmUgUnVsZVxuXHRcdGN0eCA9IHJ1bGVDb250ZXh0c1tpXTtcblxuXHRcdC8vIGNoZWNrcyBhbiAnb25seUlmJyBjb25kaXRpb25cblx0XHRpZiAoY3R4LmNvbmRpdGlvbiAmJiAhY3R4LmNvbmRpdGlvbigpKSB7XG5cdFx0XHRjb250aW51ZTtcblx0XHR9XG5cblx0XHQvL2dldCB0aGUgY29yZSBSdWxlIHRvIHVzZSBmb3IgdmFsaWRhdGlvblxuXHRcdHJ1bGUgPSBjdHgucnVsZSA/IGt2LnJ1bGVzW2N0eC5ydWxlXSA6IGN0eDtcblxuXHRcdGlmIChydWxlWydhc3luYyddIHx8IGN0eFsnYXN5bmMnXSkge1xuXHRcdFx0Ly9ydW4gYXN5bmMgdmFsaWRhdGlvblxuXHRcdFx0dmFsaWRhdGVBc3luYyhvYnNlcnZhYmxlLCBydWxlLCBjdHgpO1xuXG5cdFx0fSBlbHNlIHtcblx0XHRcdC8vcnVuIG5vcm1hbCBzeW5jIHZhbGlkYXRpb25cblx0XHRcdGlmICghdmFsaWRhdGVTeW5jKG9ic2VydmFibGUsIHJ1bGUsIGN0eCkpIHtcblx0XHRcdFx0cmV0dXJuIGZhbHNlOyAvL2JyZWFrIG91dCBvZiB0aGUgbG9vcFxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXHQvL2ZpbmFsbHkgaWYgd2UgZ290IHRoaXMgZmFyLCBtYWtlIHRoZSBvYnNlcnZhYmxlIHZhbGlkIGFnYWluIVxuXHRvYnNlcnZhYmxlLmNsZWFyRXJyb3IoKTtcblx0cmV0dXJuIHRydWU7XG59O1xuO1xudmFyIF9sb2NhbGVzID0ge307XG52YXIgX2N1cnJlbnRMb2NhbGU7XG5cbmt2LmRlZmluZUxvY2FsZSA9IGZ1bmN0aW9uKG5hbWUsIHZhbHVlcykge1xuXHRpZiAobmFtZSAmJiB2YWx1ZXMpIHtcblx0XHRfbG9jYWxlc1tuYW1lLnRvTG93ZXJDYXNlKCldID0gdmFsdWVzO1xuXHRcdHJldHVybiB2YWx1ZXM7XG5cdH1cblx0cmV0dXJuIG51bGw7XG59O1xuXG5rdi5sb2NhbGUgPSBmdW5jdGlvbihuYW1lKSB7XG5cdGlmIChuYW1lKSB7XG5cdFx0bmFtZSA9IG5hbWUudG9Mb3dlckNhc2UoKTtcblxuXHRcdGlmIChfbG9jYWxlcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuXHRcdFx0a3YubG9jYWxpemUoX2xvY2FsZXNbbmFtZV0pO1xuXHRcdFx0X2N1cnJlbnRMb2NhbGUgPSBuYW1lO1xuXHRcdH1cblx0XHRlbHNlIHtcblx0XHRcdHRocm93IG5ldyBFcnJvcignTG9jYWxpemF0aW9uICcgKyBuYW1lICsgJyBoYXMgbm90IGJlZW4gbG9hZGVkLicpO1xuXHRcdH1cblx0fVxuXHRyZXR1cm4gX2N1cnJlbnRMb2NhbGU7XG59O1xuXG4vL3F1aWNrIGZ1bmN0aW9uIHRvIG92ZXJyaWRlIHJ1bGUgbWVzc2FnZXNcbmt2LmxvY2FsaXplID0gZnVuY3Rpb24gKG1zZ1RyYW5zbGF0aW9ucykge1xuXHR2YXIgcnVsZXMgPSBrdi5ydWxlcztcblxuXHQvL2xvb3AgdGhlIHByb3BlcnRpZXMgaW4gdGhlIG9iamVjdCBhbmQgYXNzaWduIHRoZSBtc2cgdG8gdGhlIHJ1bGVcblx0Zm9yICh2YXIgcnVsZU5hbWUgaW4gbXNnVHJhbnNsYXRpb25zKSB7XG5cdFx0aWYgKHJ1bGVzLmhhc093blByb3BlcnR5KHJ1bGVOYW1lKSkge1xuXHRcdFx0cnVsZXNbcnVsZU5hbWVdLm1lc3NhZ2UgPSBtc2dUcmFuc2xhdGlvbnNbcnVsZU5hbWVdO1xuXHRcdH1cblx0fVxufTtcblxuLy8gUG9wdWxhdGUgZGVmYXVsdCBsb2NhbGUgKHRoaXMgd2lsbCBtYWtlIGVuLVVTLmpzIHNvbWV3aGF0IHJlZHVuZGFudClcbihmdW5jdGlvbigpIHtcblx0dmFyIGxvY2FsZURhdGEgPSB7fTtcblx0dmFyIHJ1bGVzID0ga3YucnVsZXM7XG5cblx0Zm9yICh2YXIgcnVsZU5hbWUgaW4gcnVsZXMpIHtcblx0XHRpZiAocnVsZXMuaGFzT3duUHJvcGVydHkocnVsZU5hbWUpKSB7XG5cdFx0XHRsb2NhbGVEYXRhW3J1bGVOYW1lXSA9IHJ1bGVzW3J1bGVOYW1lXS5tZXNzYWdlO1xuXHRcdH1cblx0fVxuXHRrdi5kZWZpbmVMb2NhbGUoJ2VuLXVzJywgbG9jYWxlRGF0YSk7XG59KSgpO1xuXG4vLyBObyBuZWVkIHRvIGludm9rZSBsb2NhbGUgYmVjYXVzZSB0aGUgbWVzc2FnZXMgYXJlIGFscmVhZHkgZGVmaW5lZCBhbG9uZyB3aXRoIHRoZSBydWxlcyBmb3IgZW4tVVNcbl9jdXJyZW50TG9jYWxlID0gJ2VuLXVzJztcbjsvKipcbiAqIFBvc3NpYmxlIGludm9jYXRpb25zOlxuICogXHRcdGFwcGx5QmluZGluZ3NXaXRoVmFsaWRhdGlvbih2aWV3TW9kZWwpXG4gKiBcdFx0YXBwbHlCaW5kaW5nc1dpdGhWYWxpZGF0aW9uKHZpZXdNb2RlbCwgb3B0aW9ucylcbiAqIFx0XHRhcHBseUJpbmRpbmdzV2l0aFZhbGlkYXRpb24odmlld01vZGVsLCByb290Tm9kZSlcbiAqXHRcdGFwcGx5QmluZGluZ3NXaXRoVmFsaWRhdGlvbih2aWV3TW9kZWwsIHJvb3ROb2RlLCBvcHRpb25zKVxuICovXG5rby5hcHBseUJpbmRpbmdzV2l0aFZhbGlkYXRpb24gPSBmdW5jdGlvbiAodmlld01vZGVsLCByb290Tm9kZSwgb3B0aW9ucykge1xuXHR2YXIgbm9kZSA9IGRvY3VtZW50LmJvZHksXG5cdFx0Y29uZmlnO1xuXG5cdGlmIChyb290Tm9kZSAmJiByb290Tm9kZS5ub2RlVHlwZSkge1xuXHRcdG5vZGUgPSByb290Tm9kZTtcblx0XHRjb25maWcgPSBvcHRpb25zO1xuXHR9XG5cdGVsc2Uge1xuXHRcdGNvbmZpZyA9IHJvb3ROb2RlO1xuXHR9XG5cblx0a3YuaW5pdCgpO1xuXG5cdGlmIChjb25maWcpIHtcblx0XHRjb25maWcgPSBleHRlbmQoZXh0ZW5kKHt9LCBrdi5jb25maWd1cmF0aW9uKSwgY29uZmlnKTtcblx0XHRrdi51dGlscy5zZXREb21EYXRhKG5vZGUsIGNvbmZpZyk7XG5cdH1cblxuXHRrby5hcHBseUJpbmRpbmdzKHZpZXdNb2RlbCwgbm9kZSk7XG59O1xuXG4vL292ZXJyaWRlIHRoZSBvcmlnaW5hbCBhcHBseUJpbmRpbmdzIHNvIHRoYXQgd2UgY2FuIGVuc3VyZSBhbGwgbmV3IHJ1bGVzIGFuZCB3aGF0IG5vdCBhcmUgY29ycmVjdGx5IHJlZ2lzdGVyZWRcbnZhciBvcmlnQXBwbHlCaW5kaW5ncyA9IGtvLmFwcGx5QmluZGluZ3M7XG5rby5hcHBseUJpbmRpbmdzID0gZnVuY3Rpb24gKHZpZXdNb2RlbCwgcm9vdE5vZGUpIHtcblxuXHRrdi5pbml0KCk7XG5cblx0b3JpZ0FwcGx5QmluZGluZ3Modmlld01vZGVsLCByb290Tm9kZSk7XG59O1xuXG5rby52YWxpZGF0ZWRPYnNlcnZhYmxlID0gZnVuY3Rpb24gKGluaXRpYWxWYWx1ZSwgb3B0aW9ucykge1xuXHRpZiAoIW9wdGlvbnMgJiYgIWt2LnV0aWxzLmlzT2JqZWN0KGluaXRpYWxWYWx1ZSkpIHtcblx0XHRyZXR1cm4ga28ub2JzZXJ2YWJsZShpbml0aWFsVmFsdWUpLmV4dGVuZCh7IHZhbGlkYXRhYmxlOiB0cnVlIH0pO1xuXHR9XG5cblx0dmFyIG9ic3YgPSBrby5vYnNlcnZhYmxlKGluaXRpYWxWYWx1ZSk7XG5cdG9ic3YuZXJyb3JzID0ga3YuZ3JvdXAoa3YudXRpbHMuaXNPYmplY3QoaW5pdGlhbFZhbHVlKSA/IGluaXRpYWxWYWx1ZSA6IHt9LCBvcHRpb25zKTtcblx0b2Jzdi5pc1ZhbGlkID0ga28ub2JzZXJ2YWJsZShvYnN2LmVycm9ycygpLmxlbmd0aCA9PT0gMCk7XG5cblx0aWYgKGtvLmlzT2JzZXJ2YWJsZShvYnN2LmVycm9ycykpIHtcblx0XHRvYnN2LmVycm9ycy5zdWJzY3JpYmUoZnVuY3Rpb24oZXJyb3JzKSB7XG5cdFx0XHRvYnN2LmlzVmFsaWQoZXJyb3JzLmxlbmd0aCA9PT0gMCk7XG5cdFx0fSk7XG5cdH1cblx0ZWxzZSB7XG5cdFx0a28uY29tcHV0ZWQob2Jzdi5lcnJvcnMpLnN1YnNjcmliZShmdW5jdGlvbiAoZXJyb3JzKSB7XG5cdFx0XHRvYnN2LmlzVmFsaWQoZXJyb3JzLmxlbmd0aCA9PT0gMCk7XG5cdFx0fSk7XG5cdH1cblxuXHRvYnN2LnN1YnNjcmliZShmdW5jdGlvbihuZXdWYWx1ZSkge1xuXHRcdGlmICgha3YudXRpbHMuaXNPYmplY3QobmV3VmFsdWUpKSB7XG5cdFx0XHQvKlxuXHRcdFx0ICogVGhlIHZhbGlkYXRpb24gZ3JvdXAgd29ya3Mgb24gb2JqZWN0cy5cblx0XHRcdCAqIFNpbmNlIHRoZSBuZXcgdmFsdWUgaXMgYSBwcmltaXRpdmUgKHNjYWxhciwgbnVsbCBvciB1bmRlZmluZWQpIHdlIG5lZWRcblx0XHRcdCAqIHRvIGNyZWF0ZSBhbiBlbXB0eSBvYmplY3QgdG8gcGFzcyBhbG9uZy5cblx0XHRcdCAqL1xuXHRcdFx0bmV3VmFsdWUgPSB7fTtcblx0XHR9XG5cdFx0Ly8gRm9yY2UgdGhlIGdyb3VwIHRvIHJlZnJlc2hcblx0XHRvYnN2LmVycm9ycy5fdXBkYXRlU3RhdGUobmV3VmFsdWUpO1xuXHRcdG9ic3YuaXNWYWxpZChvYnN2LmVycm9ycygpLmxlbmd0aCA9PT0gMCk7XG5cdH0pO1xuXG5cdHJldHVybiBvYnN2O1xufTtcbjt9KSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34va25vY2tvdXQudmFsaWRhdGlvbi9kaXN0L2tub2Nrb3V0LnZhbGlkYXRpb24uanNcbi8vIG1vZHVsZSBpZCA9IDEwM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKlxyXG4gXyBfICAgICAgXyAgICAgICBfXHJcbiBfX198IChfKSBfX198IHwgX18gIChfKV9fX1xyXG4gLyBfX3wgfCB8LyBfX3wgfC8gLyAgfCAvIF9ffFxyXG4gXFxfXyBcXCB8IHwgKF9ffCAgIDwgXyB8IFxcX18gXFxcclxuIHxfX18vX3xffFxcX19ffF98XFxfKF8pLyB8X19fL1xyXG4gfF9fL1xyXG5cclxuIFZlcnNpb246IDEuNS45XHJcbiBBdXRob3I6IEtlbiBXaGVlbGVyXHJcbiBXZWJzaXRlOiBodHRwOi8va2Vud2hlZWxlci5naXRodWIuaW9cclxuIERvY3M6IGh0dHA6Ly9rZW53aGVlbGVyLmdpdGh1Yi5pby9zbGlja1xyXG4gUmVwbzogaHR0cDovL2dpdGh1Yi5jb20va2Vud2hlZWxlci9zbGlja1xyXG4gSXNzdWVzOiBodHRwOi8vZ2l0aHViLmNvbS9rZW53aGVlbGVyL3NsaWNrL2lzc3Vlc1xyXG5cclxuICovXHJcbiFmdW5jdGlvbihhKXtcInVzZSBzdHJpY3RcIjtcImZ1bmN0aW9uXCI9PXR5cGVvZiBkZWZpbmUmJmRlZmluZS5hbWQ/ZGVmaW5lKFtcImpxdWVyeVwiXSxhKTpcInVuZGVmaW5lZFwiIT10eXBlb2YgZXhwb3J0cz9tb2R1bGUuZXhwb3J0cz1hKHJlcXVpcmUoXCJqcXVlcnlcIikpOmEoalF1ZXJ5KX0oZnVuY3Rpb24oYSl7XCJ1c2Ugc3RyaWN0XCI7dmFyIGI9d2luZG93LlNsaWNrfHx7fTtiPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gYyhjLGQpe3ZhciBmLGU9dGhpcztlLmRlZmF1bHRzPXthY2Nlc3NpYmlsaXR5OiEwLGFkYXB0aXZlSGVpZ2h0OiExLGFwcGVuZEFycm93czphKGMpLGFwcGVuZERvdHM6YShjKSxhcnJvd3M6ITAsYXNOYXZGb3I6bnVsbCxwcmV2QXJyb3c6JzxidXR0b24gdHlwZT1cImJ1dHRvblwiIGRhdGEtcm9sZT1cIm5vbmVcIiBjbGFzcz1cInNsaWNrLXByZXZcIiBhcmlhLWxhYmVsPVwiUHJldmlvdXNcIiB0YWJpbmRleD1cIjBcIiByb2xlPVwiYnV0dG9uXCI+UHJldmlvdXM8L2J1dHRvbj4nLG5leHRBcnJvdzonPGJ1dHRvbiB0eXBlPVwiYnV0dG9uXCIgZGF0YS1yb2xlPVwibm9uZVwiIGNsYXNzPVwic2xpY2stbmV4dFwiIGFyaWEtbGFiZWw9XCJOZXh0XCIgdGFiaW5kZXg9XCIwXCIgcm9sZT1cImJ1dHRvblwiPk5leHQ8L2J1dHRvbj4nLGF1dG9wbGF5OiExLGF1dG9wbGF5U3BlZWQ6M2UzLGNlbnRlck1vZGU6ITEsY2VudGVyUGFkZGluZzpcIjUwcHhcIixjc3NFYXNlOlwiZWFzZVwiLGN1c3RvbVBhZ2luZzpmdW5jdGlvbihhLGIpe3JldHVybic8YnV0dG9uIHR5cGU9XCJidXR0b25cIiBkYXRhLXJvbGU9XCJub25lXCIgcm9sZT1cImJ1dHRvblwiIGFyaWEtcmVxdWlyZWQ9XCJmYWxzZVwiIHRhYmluZGV4PVwiMFwiPicrKGIrMSkrXCI8L2J1dHRvbj5cIn0sZG90czohMSxkb3RzQ2xhc3M6XCJzbGljay1kb3RzXCIsZHJhZ2dhYmxlOiEwLGVhc2luZzpcImxpbmVhclwiLGVkZ2VGcmljdGlvbjouMzUsZmFkZTohMSxmb2N1c09uU2VsZWN0OiExLGluZmluaXRlOiEwLGluaXRpYWxTbGlkZTowLGxhenlMb2FkOlwib25kZW1hbmRcIixtb2JpbGVGaXJzdDohMSxwYXVzZU9uSG92ZXI6ITAscGF1c2VPbkRvdHNIb3ZlcjohMSxyZXNwb25kVG86XCJ3aW5kb3dcIixyZXNwb25zaXZlOm51bGwscm93czoxLHJ0bDohMSxzbGlkZTpcIlwiLHNsaWRlc1BlclJvdzoxLHNsaWRlc1RvU2hvdzoxLHNsaWRlc1RvU2Nyb2xsOjEsc3BlZWQ6NTAwLHN3aXBlOiEwLHN3aXBlVG9TbGlkZTohMSx0b3VjaE1vdmU6ITAsdG91Y2hUaHJlc2hvbGQ6NSx1c2VDU1M6ITAsdXNlVHJhbnNmb3JtOiExLHZhcmlhYmxlV2lkdGg6ITEsdmVydGljYWw6ITEsdmVydGljYWxTd2lwaW5nOiExLHdhaXRGb3JBbmltYXRlOiEwLHpJbmRleDoxZTN9LGUuaW5pdGlhbHM9e2FuaW1hdGluZzohMSxkcmFnZ2luZzohMSxhdXRvUGxheVRpbWVyOm51bGwsY3VycmVudERpcmVjdGlvbjowLGN1cnJlbnRMZWZ0Om51bGwsY3VycmVudFNsaWRlOjAsZGlyZWN0aW9uOjEsJGRvdHM6bnVsbCxsaXN0V2lkdGg6bnVsbCxsaXN0SGVpZ2h0Om51bGwsbG9hZEluZGV4OjAsJG5leHRBcnJvdzpudWxsLCRwcmV2QXJyb3c6bnVsbCxzbGlkZUNvdW50Om51bGwsc2xpZGVXaWR0aDpudWxsLCRzbGlkZVRyYWNrOm51bGwsJHNsaWRlczpudWxsLHNsaWRpbmc6ITEsc2xpZGVPZmZzZXQ6MCxzd2lwZUxlZnQ6bnVsbCwkbGlzdDpudWxsLHRvdWNoT2JqZWN0Ont9LHRyYW5zZm9ybXNFbmFibGVkOiExLHVuc2xpY2tlZDohMX0sYS5leHRlbmQoZSxlLmluaXRpYWxzKSxlLmFjdGl2ZUJyZWFrcG9pbnQ9bnVsbCxlLmFuaW1UeXBlPW51bGwsZS5hbmltUHJvcD1udWxsLGUuYnJlYWtwb2ludHM9W10sZS5icmVha3BvaW50U2V0dGluZ3M9W10sZS5jc3NUcmFuc2l0aW9ucz0hMSxlLmhpZGRlbj1cImhpZGRlblwiLGUucGF1c2VkPSExLGUucG9zaXRpb25Qcm9wPW51bGwsZS5yZXNwb25kVG89bnVsbCxlLnJvd0NvdW50PTEsZS5zaG91bGRDbGljaz0hMCxlLiRzbGlkZXI9YShjKSxlLiRzbGlkZXNDYWNoZT1udWxsLGUudHJhbnNmb3JtVHlwZT1udWxsLGUudHJhbnNpdGlvblR5cGU9bnVsbCxlLnZpc2liaWxpdHlDaGFuZ2U9XCJ2aXNpYmlsaXR5Y2hhbmdlXCIsZS53aW5kb3dXaWR0aD0wLGUud2luZG93VGltZXI9bnVsbCxmPWEoYykuZGF0YShcInNsaWNrXCIpfHx7fSxlLm9wdGlvbnM9YS5leHRlbmQoe30sZS5kZWZhdWx0cyxmLGQpLGUuY3VycmVudFNsaWRlPWUub3B0aW9ucy5pbml0aWFsU2xpZGUsZS5vcmlnaW5hbFNldHRpbmdzPWUub3B0aW9ucyxcInVuZGVmaW5lZFwiIT10eXBlb2YgZG9jdW1lbnQubW96SGlkZGVuPyhlLmhpZGRlbj1cIm1vekhpZGRlblwiLGUudmlzaWJpbGl0eUNoYW5nZT1cIm1venZpc2liaWxpdHljaGFuZ2VcIik6XCJ1bmRlZmluZWRcIiE9dHlwZW9mIGRvY3VtZW50LndlYmtpdEhpZGRlbiYmKGUuaGlkZGVuPVwid2Via2l0SGlkZGVuXCIsZS52aXNpYmlsaXR5Q2hhbmdlPVwid2Via2l0dmlzaWJpbGl0eWNoYW5nZVwiKSxlLmF1dG9QbGF5PWEucHJveHkoZS5hdXRvUGxheSxlKSxlLmF1dG9QbGF5Q2xlYXI9YS5wcm94eShlLmF1dG9QbGF5Q2xlYXIsZSksZS5jaGFuZ2VTbGlkZT1hLnByb3h5KGUuY2hhbmdlU2xpZGUsZSksZS5jbGlja0hhbmRsZXI9YS5wcm94eShlLmNsaWNrSGFuZGxlcixlKSxlLnNlbGVjdEhhbmRsZXI9YS5wcm94eShlLnNlbGVjdEhhbmRsZXIsZSksZS5zZXRQb3NpdGlvbj1hLnByb3h5KGUuc2V0UG9zaXRpb24sZSksZS5zd2lwZUhhbmRsZXI9YS5wcm94eShlLnN3aXBlSGFuZGxlcixlKSxlLmRyYWdIYW5kbGVyPWEucHJveHkoZS5kcmFnSGFuZGxlcixlKSxlLmtleUhhbmRsZXI9YS5wcm94eShlLmtleUhhbmRsZXIsZSksZS5hdXRvUGxheUl0ZXJhdG9yPWEucHJveHkoZS5hdXRvUGxheUl0ZXJhdG9yLGUpLGUuaW5zdGFuY2VVaWQ9YisrLGUuaHRtbEV4cHI9L14oPzpcXHMqKDxbXFx3XFxXXSs+KVtePl0qKSQvLGUucmVnaXN0ZXJCcmVha3BvaW50cygpLGUuaW5pdCghMCksZS5jaGVja1Jlc3BvbnNpdmUoITApfXZhciBiPTA7cmV0dXJuIGN9KCksYi5wcm90b3R5cGUuYWRkU2xpZGU9Yi5wcm90b3R5cGUuc2xpY2tBZGQ9ZnVuY3Rpb24oYixjLGQpe3ZhciBlPXRoaXM7aWYoXCJib29sZWFuXCI9PXR5cGVvZiBjKWQ9YyxjPW51bGw7ZWxzZSBpZigwPmN8fGM+PWUuc2xpZGVDb3VudClyZXR1cm4hMTtlLnVubG9hZCgpLFwibnVtYmVyXCI9PXR5cGVvZiBjPzA9PT1jJiYwPT09ZS4kc2xpZGVzLmxlbmd0aD9hKGIpLmFwcGVuZFRvKGUuJHNsaWRlVHJhY2spOmQ/YShiKS5pbnNlcnRCZWZvcmUoZS4kc2xpZGVzLmVxKGMpKTphKGIpLmluc2VydEFmdGVyKGUuJHNsaWRlcy5lcShjKSk6ZD09PSEwP2EoYikucHJlcGVuZFRvKGUuJHNsaWRlVHJhY2spOmEoYikuYXBwZW5kVG8oZS4kc2xpZGVUcmFjayksZS4kc2xpZGVzPWUuJHNsaWRlVHJhY2suY2hpbGRyZW4odGhpcy5vcHRpb25zLnNsaWRlKSxlLiRzbGlkZVRyYWNrLmNoaWxkcmVuKHRoaXMub3B0aW9ucy5zbGlkZSkuZGV0YWNoKCksZS4kc2xpZGVUcmFjay5hcHBlbmQoZS4kc2xpZGVzKSxlLiRzbGlkZXMuZWFjaChmdW5jdGlvbihiLGMpe2EoYykuYXR0cihcImRhdGEtc2xpY2staW5kZXhcIixiKX0pLGUuJHNsaWRlc0NhY2hlPWUuJHNsaWRlcyxlLnJlaW5pdCgpfSxiLnByb3RvdHlwZS5hbmltYXRlSGVpZ2h0PWZ1bmN0aW9uKCl7dmFyIGE9dGhpcztpZigxPT09YS5vcHRpb25zLnNsaWRlc1RvU2hvdyYmYS5vcHRpb25zLmFkYXB0aXZlSGVpZ2h0PT09ITAmJmEub3B0aW9ucy52ZXJ0aWNhbD09PSExKXt2YXIgYj1hLiRzbGlkZXMuZXEoYS5jdXJyZW50U2xpZGUpLm91dGVySGVpZ2h0KCEwKTthLiRsaXN0LmFuaW1hdGUoe2hlaWdodDpifSxhLm9wdGlvbnMuc3BlZWQpfX0sYi5wcm90b3R5cGUuYW5pbWF0ZVNsaWRlPWZ1bmN0aW9uKGIsYyl7dmFyIGQ9e30sZT10aGlzO2UuYW5pbWF0ZUhlaWdodCgpLGUub3B0aW9ucy5ydGw9PT0hMCYmZS5vcHRpb25zLnZlcnRpY2FsPT09ITEmJihiPS1iKSxlLnRyYW5zZm9ybXNFbmFibGVkPT09ITE/ZS5vcHRpb25zLnZlcnRpY2FsPT09ITE/ZS4kc2xpZGVUcmFjay5hbmltYXRlKHtsZWZ0OmJ9LGUub3B0aW9ucy5zcGVlZCxlLm9wdGlvbnMuZWFzaW5nLGMpOmUuJHNsaWRlVHJhY2suYW5pbWF0ZSh7dG9wOmJ9LGUub3B0aW9ucy5zcGVlZCxlLm9wdGlvbnMuZWFzaW5nLGMpOmUuY3NzVHJhbnNpdGlvbnM9PT0hMT8oZS5vcHRpb25zLnJ0bD09PSEwJiYoZS5jdXJyZW50TGVmdD0tZS5jdXJyZW50TGVmdCksYSh7YW5pbVN0YXJ0OmUuY3VycmVudExlZnR9KS5hbmltYXRlKHthbmltU3RhcnQ6Yn0se2R1cmF0aW9uOmUub3B0aW9ucy5zcGVlZCxlYXNpbmc6ZS5vcHRpb25zLmVhc2luZyxzdGVwOmZ1bmN0aW9uKGEpe2E9TWF0aC5jZWlsKGEpLGUub3B0aW9ucy52ZXJ0aWNhbD09PSExPyhkW2UuYW5pbVR5cGVdPVwidHJhbnNsYXRlKFwiK2ErXCJweCwgMHB4KVwiLGUuJHNsaWRlVHJhY2suY3NzKGQpKTooZFtlLmFuaW1UeXBlXT1cInRyYW5zbGF0ZSgwcHgsXCIrYStcInB4KVwiLGUuJHNsaWRlVHJhY2suY3NzKGQpKX0sY29tcGxldGU6ZnVuY3Rpb24oKXtjJiZjLmNhbGwoKX19KSk6KGUuYXBwbHlUcmFuc2l0aW9uKCksYj1NYXRoLmNlaWwoYiksZS5vcHRpb25zLnZlcnRpY2FsPT09ITE/ZFtlLmFuaW1UeXBlXT1cInRyYW5zbGF0ZTNkKFwiK2IrXCJweCwgMHB4LCAwcHgpXCI6ZFtlLmFuaW1UeXBlXT1cInRyYW5zbGF0ZTNkKDBweCxcIitiK1wicHgsIDBweClcIixlLiRzbGlkZVRyYWNrLmNzcyhkKSxjJiZzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7ZS5kaXNhYmxlVHJhbnNpdGlvbigpLGMuY2FsbCgpfSxlLm9wdGlvbnMuc3BlZWQpKX0sYi5wcm90b3R5cGUuYXNOYXZGb3I9ZnVuY3Rpb24oYil7dmFyIGM9dGhpcyxkPWMub3B0aW9ucy5hc05hdkZvcjtkJiZudWxsIT09ZCYmKGQ9YShkKS5ub3QoYy4kc2xpZGVyKSksbnVsbCE9PWQmJlwib2JqZWN0XCI9PXR5cGVvZiBkJiZkLmVhY2goZnVuY3Rpb24oKXt2YXIgYz1hKHRoaXMpLnNsaWNrKFwiZ2V0U2xpY2tcIik7Yy51bnNsaWNrZWR8fGMuc2xpZGVIYW5kbGVyKGIsITApfSl9LGIucHJvdG90eXBlLmFwcGx5VHJhbnNpdGlvbj1mdW5jdGlvbihhKXt2YXIgYj10aGlzLGM9e307Yi5vcHRpb25zLmZhZGU9PT0hMT9jW2IudHJhbnNpdGlvblR5cGVdPWIudHJhbnNmb3JtVHlwZStcIiBcIitiLm9wdGlvbnMuc3BlZWQrXCJtcyBcIitiLm9wdGlvbnMuY3NzRWFzZTpjW2IudHJhbnNpdGlvblR5cGVdPVwib3BhY2l0eSBcIitiLm9wdGlvbnMuc3BlZWQrXCJtcyBcIitiLm9wdGlvbnMuY3NzRWFzZSxiLm9wdGlvbnMuZmFkZT09PSExP2IuJHNsaWRlVHJhY2suY3NzKGMpOmIuJHNsaWRlcy5lcShhKS5jc3MoYyl9LGIucHJvdG90eXBlLmF1dG9QbGF5PWZ1bmN0aW9uKCl7dmFyIGE9dGhpczthLmF1dG9QbGF5VGltZXImJmNsZWFySW50ZXJ2YWwoYS5hdXRvUGxheVRpbWVyKSxhLnNsaWRlQ291bnQ+YS5vcHRpb25zLnNsaWRlc1RvU2hvdyYmYS5wYXVzZWQhPT0hMCYmKGEuYXV0b1BsYXlUaW1lcj1zZXRJbnRlcnZhbChhLmF1dG9QbGF5SXRlcmF0b3IsYS5vcHRpb25zLmF1dG9wbGF5U3BlZWQpKX0sYi5wcm90b3R5cGUuYXV0b1BsYXlDbGVhcj1mdW5jdGlvbigpe3ZhciBhPXRoaXM7YS5hdXRvUGxheVRpbWVyJiZjbGVhckludGVydmFsKGEuYXV0b1BsYXlUaW1lcil9LGIucHJvdG90eXBlLmF1dG9QbGF5SXRlcmF0b3I9ZnVuY3Rpb24oKXt2YXIgYT10aGlzO2Eub3B0aW9ucy5pbmZpbml0ZT09PSExPzE9PT1hLmRpcmVjdGlvbj8oYS5jdXJyZW50U2xpZGUrMT09PWEuc2xpZGVDb3VudC0xJiYoYS5kaXJlY3Rpb249MCksYS5zbGlkZUhhbmRsZXIoYS5jdXJyZW50U2xpZGUrYS5vcHRpb25zLnNsaWRlc1RvU2Nyb2xsKSk6KGEuY3VycmVudFNsaWRlLTE9PT0wJiYoYS5kaXJlY3Rpb249MSksYS5zbGlkZUhhbmRsZXIoYS5jdXJyZW50U2xpZGUtYS5vcHRpb25zLnNsaWRlc1RvU2Nyb2xsKSk6YS5zbGlkZUhhbmRsZXIoYS5jdXJyZW50U2xpZGUrYS5vcHRpb25zLnNsaWRlc1RvU2Nyb2xsKX0sYi5wcm90b3R5cGUuYnVpbGRBcnJvd3M9ZnVuY3Rpb24oKXt2YXIgYj10aGlzO2Iub3B0aW9ucy5hcnJvd3M9PT0hMCYmKGIuJHByZXZBcnJvdz1hKGIub3B0aW9ucy5wcmV2QXJyb3cpLmFkZENsYXNzKFwic2xpY2stYXJyb3dcIiksYi4kbmV4dEFycm93PWEoYi5vcHRpb25zLm5leHRBcnJvdykuYWRkQ2xhc3MoXCJzbGljay1hcnJvd1wiKSxiLnNsaWRlQ291bnQ+Yi5vcHRpb25zLnNsaWRlc1RvU2hvdz8oYi4kcHJldkFycm93LnJlbW92ZUNsYXNzKFwic2xpY2staGlkZGVuXCIpLnJlbW92ZUF0dHIoXCJhcmlhLWhpZGRlbiB0YWJpbmRleFwiKSxiLiRuZXh0QXJyb3cucmVtb3ZlQ2xhc3MoXCJzbGljay1oaWRkZW5cIikucmVtb3ZlQXR0cihcImFyaWEtaGlkZGVuIHRhYmluZGV4XCIpLGIuaHRtbEV4cHIudGVzdChiLm9wdGlvbnMucHJldkFycm93KSYmYi4kcHJldkFycm93LnByZXBlbmRUbyhiLm9wdGlvbnMuYXBwZW5kQXJyb3dzKSxiLmh0bWxFeHByLnRlc3QoYi5vcHRpb25zLm5leHRBcnJvdykmJmIuJG5leHRBcnJvdy5hcHBlbmRUbyhiLm9wdGlvbnMuYXBwZW5kQXJyb3dzKSxiLm9wdGlvbnMuaW5maW5pdGUhPT0hMCYmYi4kcHJldkFycm93LmFkZENsYXNzKFwic2xpY2stZGlzYWJsZWRcIikuYXR0cihcImFyaWEtZGlzYWJsZWRcIixcInRydWVcIikpOmIuJHByZXZBcnJvdy5hZGQoYi4kbmV4dEFycm93KS5hZGRDbGFzcyhcInNsaWNrLWhpZGRlblwiKS5hdHRyKHtcImFyaWEtZGlzYWJsZWRcIjpcInRydWVcIix0YWJpbmRleDpcIi0xXCJ9KSl9LGIucHJvdG90eXBlLmJ1aWxkRG90cz1mdW5jdGlvbigpe3ZhciBjLGQsYj10aGlzO2lmKGIub3B0aW9ucy5kb3RzPT09ITAmJmIuc2xpZGVDb3VudD5iLm9wdGlvbnMuc2xpZGVzVG9TaG93KXtmb3IoZD0nPHVsIGNsYXNzPVwiJytiLm9wdGlvbnMuZG90c0NsYXNzKydcIj4nLGM9MDtjPD1iLmdldERvdENvdW50KCk7Yys9MSlkKz1cIjxsaT5cIitiLm9wdGlvbnMuY3VzdG9tUGFnaW5nLmNhbGwodGhpcyxiLGMpK1wiPC9saT5cIjtkKz1cIjwvdWw+XCIsYi4kZG90cz1hKGQpLmFwcGVuZFRvKGIub3B0aW9ucy5hcHBlbmREb3RzKSxiLiRkb3RzLmZpbmQoXCJsaVwiKS5maXJzdCgpLmFkZENsYXNzKFwic2xpY2stYWN0aXZlXCIpLmF0dHIoXCJhcmlhLWhpZGRlblwiLFwiZmFsc2VcIil9fSxiLnByb3RvdHlwZS5idWlsZE91dD1mdW5jdGlvbigpe3ZhciBiPXRoaXM7Yi4kc2xpZGVzPWIuJHNsaWRlci5jaGlsZHJlbihiLm9wdGlvbnMuc2xpZGUrXCI6bm90KC5zbGljay1jbG9uZWQpXCIpLmFkZENsYXNzKFwic2xpY2stc2xpZGVcIiksYi5zbGlkZUNvdW50PWIuJHNsaWRlcy5sZW5ndGgsYi4kc2xpZGVzLmVhY2goZnVuY3Rpb24oYixjKXthKGMpLmF0dHIoXCJkYXRhLXNsaWNrLWluZGV4XCIsYikuZGF0YShcIm9yaWdpbmFsU3R5bGluZ1wiLGEoYykuYXR0cihcInN0eWxlXCIpfHxcIlwiKX0pLGIuJHNsaWRlci5hZGRDbGFzcyhcInNsaWNrLXNsaWRlclwiKSxiLiRzbGlkZVRyYWNrPTA9PT1iLnNsaWRlQ291bnQ/YSgnPGRpdiBjbGFzcz1cInNsaWNrLXRyYWNrXCIvPicpLmFwcGVuZFRvKGIuJHNsaWRlcik6Yi4kc2xpZGVzLndyYXBBbGwoJzxkaXYgY2xhc3M9XCJzbGljay10cmFja1wiLz4nKS5wYXJlbnQoKSxiLiRsaXN0PWIuJHNsaWRlVHJhY2sud3JhcCgnPGRpdiBhcmlhLWxpdmU9XCJwb2xpdGVcIiBjbGFzcz1cInNsaWNrLWxpc3RcIi8+JykucGFyZW50KCksYi4kc2xpZGVUcmFjay5jc3MoXCJvcGFjaXR5XCIsMCksKGIub3B0aW9ucy5jZW50ZXJNb2RlPT09ITB8fGIub3B0aW9ucy5zd2lwZVRvU2xpZGU9PT0hMCkmJihiLm9wdGlvbnMuc2xpZGVzVG9TY3JvbGw9MSksYShcImltZ1tkYXRhLWxhenldXCIsYi4kc2xpZGVyKS5ub3QoXCJbc3JjXVwiKS5hZGRDbGFzcyhcInNsaWNrLWxvYWRpbmdcIiksYi5zZXR1cEluZmluaXRlKCksYi5idWlsZEFycm93cygpLGIuYnVpbGREb3RzKCksYi51cGRhdGVEb3RzKCksYi5zZXRTbGlkZUNsYXNzZXMoXCJudW1iZXJcIj09dHlwZW9mIGIuY3VycmVudFNsaWRlP2IuY3VycmVudFNsaWRlOjApLGIub3B0aW9ucy5kcmFnZ2FibGU9PT0hMCYmYi4kbGlzdC5hZGRDbGFzcyhcImRyYWdnYWJsZVwiKX0sYi5wcm90b3R5cGUuYnVpbGRSb3dzPWZ1bmN0aW9uKCl7dmFyIGIsYyxkLGUsZixnLGgsYT10aGlzO2lmKGU9ZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpLGc9YS4kc2xpZGVyLmNoaWxkcmVuKCksYS5vcHRpb25zLnJvd3M+MSl7Zm9yKGg9YS5vcHRpb25zLnNsaWRlc1BlclJvdyphLm9wdGlvbnMucm93cyxmPU1hdGguY2VpbChnLmxlbmd0aC9oKSxiPTA7Zj5iO2IrKyl7dmFyIGk9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtmb3IoYz0wO2M8YS5vcHRpb25zLnJvd3M7YysrKXt2YXIgaj1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO2ZvcihkPTA7ZDxhLm9wdGlvbnMuc2xpZGVzUGVyUm93O2QrKyl7dmFyIGs9YipoKyhjKmEub3B0aW9ucy5zbGlkZXNQZXJSb3crZCk7Zy5nZXQoaykmJmouYXBwZW5kQ2hpbGQoZy5nZXQoaykpfWkuYXBwZW5kQ2hpbGQoail9ZS5hcHBlbmRDaGlsZChpKX1hLiRzbGlkZXIuaHRtbChlKSxhLiRzbGlkZXIuY2hpbGRyZW4oKS5jaGlsZHJlbigpLmNoaWxkcmVuKCkuY3NzKHt3aWR0aDoxMDAvYS5vcHRpb25zLnNsaWRlc1BlclJvdytcIiVcIixkaXNwbGF5OlwiaW5saW5lLWJsb2NrXCJ9KX19LGIucHJvdG90eXBlLmNoZWNrUmVzcG9uc2l2ZT1mdW5jdGlvbihiLGMpe3ZhciBlLGYsZyxkPXRoaXMsaD0hMSxpPWQuJHNsaWRlci53aWR0aCgpLGo9d2luZG93LmlubmVyV2lkdGh8fGEod2luZG93KS53aWR0aCgpO2lmKFwid2luZG93XCI9PT1kLnJlc3BvbmRUbz9nPWo6XCJzbGlkZXJcIj09PWQucmVzcG9uZFRvP2c9aTpcIm1pblwiPT09ZC5yZXNwb25kVG8mJihnPU1hdGgubWluKGosaSkpLGQub3B0aW9ucy5yZXNwb25zaXZlJiZkLm9wdGlvbnMucmVzcG9uc2l2ZS5sZW5ndGgmJm51bGwhPT1kLm9wdGlvbnMucmVzcG9uc2l2ZSl7Zj1udWxsO2ZvcihlIGluIGQuYnJlYWtwb2ludHMpZC5icmVha3BvaW50cy5oYXNPd25Qcm9wZXJ0eShlKSYmKGQub3JpZ2luYWxTZXR0aW5ncy5tb2JpbGVGaXJzdD09PSExP2c8ZC5icmVha3BvaW50c1tlXSYmKGY9ZC5icmVha3BvaW50c1tlXSk6Zz5kLmJyZWFrcG9pbnRzW2VdJiYoZj1kLmJyZWFrcG9pbnRzW2VdKSk7bnVsbCE9PWY/bnVsbCE9PWQuYWN0aXZlQnJlYWtwb2ludD8oZiE9PWQuYWN0aXZlQnJlYWtwb2ludHx8YykmJihkLmFjdGl2ZUJyZWFrcG9pbnQ9ZixcInVuc2xpY2tcIj09PWQuYnJlYWtwb2ludFNldHRpbmdzW2ZdP2QudW5zbGljayhmKTooZC5vcHRpb25zPWEuZXh0ZW5kKHt9LGQub3JpZ2luYWxTZXR0aW5ncyxkLmJyZWFrcG9pbnRTZXR0aW5nc1tmXSksYj09PSEwJiYoZC5jdXJyZW50U2xpZGU9ZC5vcHRpb25zLmluaXRpYWxTbGlkZSksZC5yZWZyZXNoKGIpKSxoPWYpOihkLmFjdGl2ZUJyZWFrcG9pbnQ9ZixcInVuc2xpY2tcIj09PWQuYnJlYWtwb2ludFNldHRpbmdzW2ZdP2QudW5zbGljayhmKTooZC5vcHRpb25zPWEuZXh0ZW5kKHt9LGQub3JpZ2luYWxTZXR0aW5ncyxkLmJyZWFrcG9pbnRTZXR0aW5nc1tmXSksYj09PSEwJiYoZC5jdXJyZW50U2xpZGU9ZC5vcHRpb25zLmluaXRpYWxTbGlkZSksZC5yZWZyZXNoKGIpKSxoPWYpOm51bGwhPT1kLmFjdGl2ZUJyZWFrcG9pbnQmJihkLmFjdGl2ZUJyZWFrcG9pbnQ9bnVsbCxkLm9wdGlvbnM9ZC5vcmlnaW5hbFNldHRpbmdzLGI9PT0hMCYmKGQuY3VycmVudFNsaWRlPWQub3B0aW9ucy5pbml0aWFsU2xpZGUpLGQucmVmcmVzaChiKSxoPWYpLGJ8fGg9PT0hMXx8ZC4kc2xpZGVyLnRyaWdnZXIoXCJicmVha3BvaW50XCIsW2QsaF0pfX0sYi5wcm90b3R5cGUuY2hhbmdlU2xpZGU9ZnVuY3Rpb24oYixjKXt2YXIgZixnLGgsZD10aGlzLGU9YShiLnRhcmdldCk7c3dpdGNoKGUuaXMoXCJhXCIpJiZiLnByZXZlbnREZWZhdWx0KCksZS5pcyhcImxpXCIpfHwoZT1lLmNsb3Nlc3QoXCJsaVwiKSksaD1kLnNsaWRlQ291bnQlZC5vcHRpb25zLnNsaWRlc1RvU2Nyb2xsIT09MCxmPWg/MDooZC5zbGlkZUNvdW50LWQuY3VycmVudFNsaWRlKSVkLm9wdGlvbnMuc2xpZGVzVG9TY3JvbGwsYi5kYXRhLm1lc3NhZ2Upe2Nhc2VcInByZXZpb3VzXCI6Zz0wPT09Zj9kLm9wdGlvbnMuc2xpZGVzVG9TY3JvbGw6ZC5vcHRpb25zLnNsaWRlc1RvU2hvdy1mLGQuc2xpZGVDb3VudD5kLm9wdGlvbnMuc2xpZGVzVG9TaG93JiZkLnNsaWRlSGFuZGxlcihkLmN1cnJlbnRTbGlkZS1nLCExLGMpO2JyZWFrO2Nhc2VcIm5leHRcIjpnPTA9PT1mP2Qub3B0aW9ucy5zbGlkZXNUb1Njcm9sbDpmLGQuc2xpZGVDb3VudD5kLm9wdGlvbnMuc2xpZGVzVG9TaG93JiZkLnNsaWRlSGFuZGxlcihkLmN1cnJlbnRTbGlkZStnLCExLGMpO2JyZWFrO2Nhc2VcImluZGV4XCI6dmFyIGk9MD09PWIuZGF0YS5pbmRleD8wOmIuZGF0YS5pbmRleHx8ZS5pbmRleCgpKmQub3B0aW9ucy5zbGlkZXNUb1Njcm9sbDtkLnNsaWRlSGFuZGxlcihkLmNoZWNrTmF2aWdhYmxlKGkpLCExLGMpLGUuY2hpbGRyZW4oKS50cmlnZ2VyKFwiZm9jdXNcIik7YnJlYWs7ZGVmYXVsdDpyZXR1cm59fSxiLnByb3RvdHlwZS5jaGVja05hdmlnYWJsZT1mdW5jdGlvbihhKXt2YXIgYyxkLGI9dGhpcztpZihjPWIuZ2V0TmF2aWdhYmxlSW5kZXhlcygpLGQ9MCxhPmNbYy5sZW5ndGgtMV0pYT1jW2MubGVuZ3RoLTFdO2Vsc2UgZm9yKHZhciBlIGluIGMpe2lmKGE8Y1tlXSl7YT1kO2JyZWFrfWQ9Y1tlXX1yZXR1cm4gYX0sYi5wcm90b3R5cGUuY2xlYW5VcEV2ZW50cz1mdW5jdGlvbigpe3ZhciBiPXRoaXM7Yi5vcHRpb25zLmRvdHMmJm51bGwhPT1iLiRkb3RzJiYoYShcImxpXCIsYi4kZG90cykub2ZmKFwiY2xpY2suc2xpY2tcIixiLmNoYW5nZVNsaWRlKSxiLm9wdGlvbnMucGF1c2VPbkRvdHNIb3Zlcj09PSEwJiZiLm9wdGlvbnMuYXV0b3BsYXk9PT0hMCYmYShcImxpXCIsYi4kZG90cykub2ZmKFwibW91c2VlbnRlci5zbGlja1wiLGEucHJveHkoYi5zZXRQYXVzZWQsYiwhMCkpLm9mZihcIm1vdXNlbGVhdmUuc2xpY2tcIixhLnByb3h5KGIuc2V0UGF1c2VkLGIsITEpKSksYi5vcHRpb25zLmFycm93cz09PSEwJiZiLnNsaWRlQ291bnQ+Yi5vcHRpb25zLnNsaWRlc1RvU2hvdyYmKGIuJHByZXZBcnJvdyYmYi4kcHJldkFycm93Lm9mZihcImNsaWNrLnNsaWNrXCIsYi5jaGFuZ2VTbGlkZSksYi4kbmV4dEFycm93JiZiLiRuZXh0QXJyb3cub2ZmKFwiY2xpY2suc2xpY2tcIixiLmNoYW5nZVNsaWRlKSksYi4kbGlzdC5vZmYoXCJ0b3VjaHN0YXJ0LnNsaWNrIG1vdXNlZG93bi5zbGlja1wiLGIuc3dpcGVIYW5kbGVyKSxiLiRsaXN0Lm9mZihcInRvdWNobW92ZS5zbGljayBtb3VzZW1vdmUuc2xpY2tcIixiLnN3aXBlSGFuZGxlciksYi4kbGlzdC5vZmYoXCJ0b3VjaGVuZC5zbGljayBtb3VzZXVwLnNsaWNrXCIsYi5zd2lwZUhhbmRsZXIpLGIuJGxpc3Qub2ZmKFwidG91Y2hjYW5jZWwuc2xpY2sgbW91c2VsZWF2ZS5zbGlja1wiLGIuc3dpcGVIYW5kbGVyKSxiLiRsaXN0Lm9mZihcImNsaWNrLnNsaWNrXCIsYi5jbGlja0hhbmRsZXIpLGEoZG9jdW1lbnQpLm9mZihiLnZpc2liaWxpdHlDaGFuZ2UsYi52aXNpYmlsaXR5KSxiLiRsaXN0Lm9mZihcIm1vdXNlZW50ZXIuc2xpY2tcIixhLnByb3h5KGIuc2V0UGF1c2VkLGIsITApKSxiLiRsaXN0Lm9mZihcIm1vdXNlbGVhdmUuc2xpY2tcIixhLnByb3h5KGIuc2V0UGF1c2VkLGIsITEpKSxiLm9wdGlvbnMuYWNjZXNzaWJpbGl0eT09PSEwJiZiLiRsaXN0Lm9mZihcImtleWRvd24uc2xpY2tcIixiLmtleUhhbmRsZXIpLGIub3B0aW9ucy5mb2N1c09uU2VsZWN0PT09ITAmJmEoYi4kc2xpZGVUcmFjaykuY2hpbGRyZW4oKS5vZmYoXCJjbGljay5zbGlja1wiLGIuc2VsZWN0SGFuZGxlciksYSh3aW5kb3cpLm9mZihcIm9yaWVudGF0aW9uY2hhbmdlLnNsaWNrLnNsaWNrLVwiK2IuaW5zdGFuY2VVaWQsYi5vcmllbnRhdGlvbkNoYW5nZSksYSh3aW5kb3cpLm9mZihcInJlc2l6ZS5zbGljay5zbGljay1cIitiLmluc3RhbmNlVWlkLGIucmVzaXplKSxhKFwiW2RyYWdnYWJsZSE9dHJ1ZV1cIixiLiRzbGlkZVRyYWNrKS5vZmYoXCJkcmFnc3RhcnRcIixiLnByZXZlbnREZWZhdWx0KSxhKHdpbmRvdykub2ZmKFwibG9hZC5zbGljay5zbGljay1cIitiLmluc3RhbmNlVWlkLGIuc2V0UG9zaXRpb24pLGEoZG9jdW1lbnQpLm9mZihcInJlYWR5LnNsaWNrLnNsaWNrLVwiK2IuaW5zdGFuY2VVaWQsYi5zZXRQb3NpdGlvbil9LGIucHJvdG90eXBlLmNsZWFuVXBSb3dzPWZ1bmN0aW9uKCl7dmFyIGIsYT10aGlzO2Eub3B0aW9ucy5yb3dzPjEmJihiPWEuJHNsaWRlcy5jaGlsZHJlbigpLmNoaWxkcmVuKCksYi5yZW1vdmVBdHRyKFwic3R5bGVcIiksYS4kc2xpZGVyLmh0bWwoYikpfSxiLnByb3RvdHlwZS5jbGlja0hhbmRsZXI9ZnVuY3Rpb24oYSl7dmFyIGI9dGhpcztiLnNob3VsZENsaWNrPT09ITEmJihhLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpLGEuc3RvcFByb3BhZ2F0aW9uKCksYS5wcmV2ZW50RGVmYXVsdCgpKX0sYi5wcm90b3R5cGUuZGVzdHJveT1mdW5jdGlvbihiKXt2YXIgYz10aGlzO2MuYXV0b1BsYXlDbGVhcigpLGMudG91Y2hPYmplY3Q9e30sYy5jbGVhblVwRXZlbnRzKCksYShcIi5zbGljay1jbG9uZWRcIixjLiRzbGlkZXIpLmRldGFjaCgpLGMuJGRvdHMmJmMuJGRvdHMucmVtb3ZlKCksYy4kcHJldkFycm93JiZjLiRwcmV2QXJyb3cubGVuZ3RoJiYoYy4kcHJldkFycm93LnJlbW92ZUNsYXNzKFwic2xpY2stZGlzYWJsZWQgc2xpY2stYXJyb3cgc2xpY2staGlkZGVuXCIpLnJlbW92ZUF0dHIoXCJhcmlhLWhpZGRlbiBhcmlhLWRpc2FibGVkIHRhYmluZGV4XCIpLmNzcyhcImRpc3BsYXlcIixcIlwiKSxjLmh0bWxFeHByLnRlc3QoYy5vcHRpb25zLnByZXZBcnJvdykmJmMuJHByZXZBcnJvdy5yZW1vdmUoKSksYy4kbmV4dEFycm93JiZjLiRuZXh0QXJyb3cubGVuZ3RoJiYoYy4kbmV4dEFycm93LnJlbW92ZUNsYXNzKFwic2xpY2stZGlzYWJsZWQgc2xpY2stYXJyb3cgc2xpY2staGlkZGVuXCIpLnJlbW92ZUF0dHIoXCJhcmlhLWhpZGRlbiBhcmlhLWRpc2FibGVkIHRhYmluZGV4XCIpLmNzcyhcImRpc3BsYXlcIixcIlwiKSxjLmh0bWxFeHByLnRlc3QoYy5vcHRpb25zLm5leHRBcnJvdykmJmMuJG5leHRBcnJvdy5yZW1vdmUoKSksYy4kc2xpZGVzJiYoYy4kc2xpZGVzLnJlbW92ZUNsYXNzKFwic2xpY2stc2xpZGUgc2xpY2stYWN0aXZlIHNsaWNrLWNlbnRlciBzbGljay12aXNpYmxlIHNsaWNrLWN1cnJlbnRcIikucmVtb3ZlQXR0cihcImFyaWEtaGlkZGVuXCIpLnJlbW92ZUF0dHIoXCJkYXRhLXNsaWNrLWluZGV4XCIpLmVhY2goZnVuY3Rpb24oKXthKHRoaXMpLmF0dHIoXCJzdHlsZVwiLGEodGhpcykuZGF0YShcIm9yaWdpbmFsU3R5bGluZ1wiKSl9KSxjLiRzbGlkZVRyYWNrLmNoaWxkcmVuKHRoaXMub3B0aW9ucy5zbGlkZSkuZGV0YWNoKCksYy4kc2xpZGVUcmFjay5kZXRhY2goKSxjLiRsaXN0LmRldGFjaCgpLGMuJHNsaWRlci5hcHBlbmQoYy4kc2xpZGVzKSksYy5jbGVhblVwUm93cygpLGMuJHNsaWRlci5yZW1vdmVDbGFzcyhcInNsaWNrLXNsaWRlclwiKSxjLiRzbGlkZXIucmVtb3ZlQ2xhc3MoXCJzbGljay1pbml0aWFsaXplZFwiKSxjLnVuc2xpY2tlZD0hMCxifHxjLiRzbGlkZXIudHJpZ2dlcihcImRlc3Ryb3lcIixbY10pfSxiLnByb3RvdHlwZS5kaXNhYmxlVHJhbnNpdGlvbj1mdW5jdGlvbihhKXt2YXIgYj10aGlzLGM9e307Y1tiLnRyYW5zaXRpb25UeXBlXT1cIlwiLGIub3B0aW9ucy5mYWRlPT09ITE/Yi4kc2xpZGVUcmFjay5jc3MoYyk6Yi4kc2xpZGVzLmVxKGEpLmNzcyhjKX0sYi5wcm90b3R5cGUuZmFkZVNsaWRlPWZ1bmN0aW9uKGEsYil7dmFyIGM9dGhpcztjLmNzc1RyYW5zaXRpb25zPT09ITE/KGMuJHNsaWRlcy5lcShhKS5jc3Moe3pJbmRleDpjLm9wdGlvbnMuekluZGV4fSksYy4kc2xpZGVzLmVxKGEpLmFuaW1hdGUoe29wYWNpdHk6MX0sYy5vcHRpb25zLnNwZWVkLGMub3B0aW9ucy5lYXNpbmcsYikpOihjLmFwcGx5VHJhbnNpdGlvbihhKSxjLiRzbGlkZXMuZXEoYSkuY3NzKHtvcGFjaXR5OjEsekluZGV4OmMub3B0aW9ucy56SW5kZXh9KSxiJiZzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7Yy5kaXNhYmxlVHJhbnNpdGlvbihhKSxiLmNhbGwoKX0sYy5vcHRpb25zLnNwZWVkKSl9LGIucHJvdG90eXBlLmZhZGVTbGlkZU91dD1mdW5jdGlvbihhKXt2YXIgYj10aGlzO2IuY3NzVHJhbnNpdGlvbnM9PT0hMT9iLiRzbGlkZXMuZXEoYSkuYW5pbWF0ZSh7b3BhY2l0eTowLHpJbmRleDpiLm9wdGlvbnMuekluZGV4LTJ9LGIub3B0aW9ucy5zcGVlZCxiLm9wdGlvbnMuZWFzaW5nKTooYi5hcHBseVRyYW5zaXRpb24oYSksYi4kc2xpZGVzLmVxKGEpLmNzcyh7b3BhY2l0eTowLHpJbmRleDpiLm9wdGlvbnMuekluZGV4LTJ9KSl9LGIucHJvdG90eXBlLmZpbHRlclNsaWRlcz1iLnByb3RvdHlwZS5zbGlja0ZpbHRlcj1mdW5jdGlvbihhKXt2YXIgYj10aGlzO251bGwhPT1hJiYoYi4kc2xpZGVzQ2FjaGU9Yi4kc2xpZGVzLGIudW5sb2FkKCksYi4kc2xpZGVUcmFjay5jaGlsZHJlbih0aGlzLm9wdGlvbnMuc2xpZGUpLmRldGFjaCgpLGIuJHNsaWRlc0NhY2hlLmZpbHRlcihhKS5hcHBlbmRUbyhiLiRzbGlkZVRyYWNrKSxiLnJlaW5pdCgpKX0sYi5wcm90b3R5cGUuZ2V0Q3VycmVudD1iLnByb3RvdHlwZS5zbGlja0N1cnJlbnRTbGlkZT1mdW5jdGlvbigpe3ZhciBhPXRoaXM7cmV0dXJuIGEuY3VycmVudFNsaWRlfSxiLnByb3RvdHlwZS5nZXREb3RDb3VudD1mdW5jdGlvbigpe3ZhciBhPXRoaXMsYj0wLGM9MCxkPTA7aWYoYS5vcHRpb25zLmluZmluaXRlPT09ITApZm9yKDtiPGEuc2xpZGVDb3VudDspKytkLGI9YythLm9wdGlvbnMuc2xpZGVzVG9TY3JvbGwsYys9YS5vcHRpb25zLnNsaWRlc1RvU2Nyb2xsPD1hLm9wdGlvbnMuc2xpZGVzVG9TaG93P2Eub3B0aW9ucy5zbGlkZXNUb1Njcm9sbDphLm9wdGlvbnMuc2xpZGVzVG9TaG93O2Vsc2UgaWYoYS5vcHRpb25zLmNlbnRlck1vZGU9PT0hMClkPWEuc2xpZGVDb3VudDtlbHNlIGZvcig7YjxhLnNsaWRlQ291bnQ7KSsrZCxiPWMrYS5vcHRpb25zLnNsaWRlc1RvU2Nyb2xsLGMrPWEub3B0aW9ucy5zbGlkZXNUb1Njcm9sbDw9YS5vcHRpb25zLnNsaWRlc1RvU2hvdz9hLm9wdGlvbnMuc2xpZGVzVG9TY3JvbGw6YS5vcHRpb25zLnNsaWRlc1RvU2hvdztyZXR1cm4gZC0xfSxiLnByb3RvdHlwZS5nZXRMZWZ0PWZ1bmN0aW9uKGEpe3ZhciBjLGQsZixiPXRoaXMsZT0wO3JldHVybiBiLnNsaWRlT2Zmc2V0PTAsZD1iLiRzbGlkZXMuZmlyc3QoKS5vdXRlckhlaWdodCghMCksYi5vcHRpb25zLmluZmluaXRlPT09ITA/KGIuc2xpZGVDb3VudD5iLm9wdGlvbnMuc2xpZGVzVG9TaG93JiYoYi5zbGlkZU9mZnNldD1iLnNsaWRlV2lkdGgqYi5vcHRpb25zLnNsaWRlc1RvU2hvdyotMSxlPWQqYi5vcHRpb25zLnNsaWRlc1RvU2hvdyotMSksYi5zbGlkZUNvdW50JWIub3B0aW9ucy5zbGlkZXNUb1Njcm9sbCE9PTAmJmErYi5vcHRpb25zLnNsaWRlc1RvU2Nyb2xsPmIuc2xpZGVDb3VudCYmYi5zbGlkZUNvdW50PmIub3B0aW9ucy5zbGlkZXNUb1Nob3cmJihhPmIuc2xpZGVDb3VudD8oYi5zbGlkZU9mZnNldD0oYi5vcHRpb25zLnNsaWRlc1RvU2hvdy0oYS1iLnNsaWRlQ291bnQpKSpiLnNsaWRlV2lkdGgqLTEsZT0oYi5vcHRpb25zLnNsaWRlc1RvU2hvdy0oYS1iLnNsaWRlQ291bnQpKSpkKi0xKTooYi5zbGlkZU9mZnNldD1iLnNsaWRlQ291bnQlYi5vcHRpb25zLnNsaWRlc1RvU2Nyb2xsKmIuc2xpZGVXaWR0aCotMSxlPWIuc2xpZGVDb3VudCViLm9wdGlvbnMuc2xpZGVzVG9TY3JvbGwqZCotMSkpKTphK2Iub3B0aW9ucy5zbGlkZXNUb1Nob3c+Yi5zbGlkZUNvdW50JiYoYi5zbGlkZU9mZnNldD0oYStiLm9wdGlvbnMuc2xpZGVzVG9TaG93LWIuc2xpZGVDb3VudCkqYi5zbGlkZVdpZHRoLGU9KGErYi5vcHRpb25zLnNsaWRlc1RvU2hvdy1iLnNsaWRlQ291bnQpKmQpLGIuc2xpZGVDb3VudDw9Yi5vcHRpb25zLnNsaWRlc1RvU2hvdyYmKGIuc2xpZGVPZmZzZXQ9MCxlPTApLGIub3B0aW9ucy5jZW50ZXJNb2RlPT09ITAmJmIub3B0aW9ucy5pbmZpbml0ZT09PSEwP2Iuc2xpZGVPZmZzZXQrPWIuc2xpZGVXaWR0aCpNYXRoLmZsb29yKGIub3B0aW9ucy5zbGlkZXNUb1Nob3cvMiktYi5zbGlkZVdpZHRoOmIub3B0aW9ucy5jZW50ZXJNb2RlPT09ITAmJihiLnNsaWRlT2Zmc2V0PTAsYi5zbGlkZU9mZnNldCs9Yi5zbGlkZVdpZHRoKk1hdGguZmxvb3IoYi5vcHRpb25zLnNsaWRlc1RvU2hvdy8yKSksYz1iLm9wdGlvbnMudmVydGljYWw9PT0hMT9hKmIuc2xpZGVXaWR0aCotMStiLnNsaWRlT2Zmc2V0OmEqZCotMStlLGIub3B0aW9ucy52YXJpYWJsZVdpZHRoPT09ITAmJihmPWIuc2xpZGVDb3VudDw9Yi5vcHRpb25zLnNsaWRlc1RvU2hvd3x8Yi5vcHRpb25zLmluZmluaXRlPT09ITE/Yi4kc2xpZGVUcmFjay5jaGlsZHJlbihcIi5zbGljay1zbGlkZVwiKS5lcShhKTpiLiRzbGlkZVRyYWNrLmNoaWxkcmVuKFwiLnNsaWNrLXNsaWRlXCIpLmVxKGErYi5vcHRpb25zLnNsaWRlc1RvU2hvdyksYz1iLm9wdGlvbnMucnRsPT09ITA/ZlswXT8tMSooYi4kc2xpZGVUcmFjay53aWR0aCgpLWZbMF0ub2Zmc2V0TGVmdC1mLndpZHRoKCkpOjA6ZlswXT8tMSpmWzBdLm9mZnNldExlZnQ6MCxiLm9wdGlvbnMuY2VudGVyTW9kZT09PSEwJiYoZj1iLnNsaWRlQ291bnQ8PWIub3B0aW9ucy5zbGlkZXNUb1Nob3d8fGIub3B0aW9ucy5pbmZpbml0ZT09PSExP2IuJHNsaWRlVHJhY2suY2hpbGRyZW4oXCIuc2xpY2stc2xpZGVcIikuZXEoYSk6Yi4kc2xpZGVUcmFjay5jaGlsZHJlbihcIi5zbGljay1zbGlkZVwiKS5lcShhK2Iub3B0aW9ucy5zbGlkZXNUb1Nob3crMSksYz1iLm9wdGlvbnMucnRsPT09ITA/ZlswXT8tMSooYi4kc2xpZGVUcmFjay53aWR0aCgpLWZbMF0ub2Zmc2V0TGVmdC1mLndpZHRoKCkpOjA6ZlswXT8tMSpmWzBdLm9mZnNldExlZnQ6MCxjKz0oYi4kbGlzdC53aWR0aCgpLWYub3V0ZXJXaWR0aCgpKS8yKSksY30sYi5wcm90b3R5cGUuZ2V0T3B0aW9uPWIucHJvdG90eXBlLnNsaWNrR2V0T3B0aW9uPWZ1bmN0aW9uKGEpe3ZhciBiPXRoaXM7cmV0dXJuIGIub3B0aW9uc1thXX0sYi5wcm90b3R5cGUuZ2V0TmF2aWdhYmxlSW5kZXhlcz1mdW5jdGlvbigpe3ZhciBlLGE9dGhpcyxiPTAsYz0wLGQ9W107Zm9yKGEub3B0aW9ucy5pbmZpbml0ZT09PSExP2U9YS5zbGlkZUNvdW50OihiPS0xKmEub3B0aW9ucy5zbGlkZXNUb1Njcm9sbCxjPS0xKmEub3B0aW9ucy5zbGlkZXNUb1Njcm9sbCxlPTIqYS5zbGlkZUNvdW50KTtlPmI7KWQucHVzaChiKSxiPWMrYS5vcHRpb25zLnNsaWRlc1RvU2Nyb2xsLGMrPWEub3B0aW9ucy5zbGlkZXNUb1Njcm9sbDw9YS5vcHRpb25zLnNsaWRlc1RvU2hvdz9hLm9wdGlvbnMuc2xpZGVzVG9TY3JvbGw6YS5vcHRpb25zLnNsaWRlc1RvU2hvdztyZXR1cm4gZH0sYi5wcm90b3R5cGUuZ2V0U2xpY2s9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpc30sYi5wcm90b3R5cGUuZ2V0U2xpZGVDb3VudD1mdW5jdGlvbigpe3ZhciBjLGQsZSxiPXRoaXM7cmV0dXJuIGU9Yi5vcHRpb25zLmNlbnRlck1vZGU9PT0hMD9iLnNsaWRlV2lkdGgqTWF0aC5mbG9vcihiLm9wdGlvbnMuc2xpZGVzVG9TaG93LzIpOjAsYi5vcHRpb25zLnN3aXBlVG9TbGlkZT09PSEwPyhiLiRzbGlkZVRyYWNrLmZpbmQoXCIuc2xpY2stc2xpZGVcIikuZWFjaChmdW5jdGlvbihjLGYpe3JldHVybiBmLm9mZnNldExlZnQtZSthKGYpLm91dGVyV2lkdGgoKS8yPi0xKmIuc3dpcGVMZWZ0PyhkPWYsITEpOnZvaWQgMH0pLGM9TWF0aC5hYnMoYShkKS5hdHRyKFwiZGF0YS1zbGljay1pbmRleFwiKS1iLmN1cnJlbnRTbGlkZSl8fDEpOmIub3B0aW9ucy5zbGlkZXNUb1Njcm9sbH0sYi5wcm90b3R5cGUuZ29Ubz1iLnByb3RvdHlwZS5zbGlja0dvVG89ZnVuY3Rpb24oYSxiKXt2YXIgYz10aGlzO2MuY2hhbmdlU2xpZGUoe2RhdGE6e21lc3NhZ2U6XCJpbmRleFwiLGluZGV4OnBhcnNlSW50KGEpfX0sYil9LGIucHJvdG90eXBlLmluaXQ9ZnVuY3Rpb24oYil7dmFyIGM9dGhpczthKGMuJHNsaWRlcikuaGFzQ2xhc3MoXCJzbGljay1pbml0aWFsaXplZFwiKXx8KGEoYy4kc2xpZGVyKS5hZGRDbGFzcyhcInNsaWNrLWluaXRpYWxpemVkXCIpLGMuYnVpbGRSb3dzKCksYy5idWlsZE91dCgpLGMuc2V0UHJvcHMoKSxjLnN0YXJ0TG9hZCgpLGMubG9hZFNsaWRlcigpLGMuaW5pdGlhbGl6ZUV2ZW50cygpLGMudXBkYXRlQXJyb3dzKCksYy51cGRhdGVEb3RzKCkpLGImJmMuJHNsaWRlci50cmlnZ2VyKFwiaW5pdFwiLFtjXSksYy5vcHRpb25zLmFjY2Vzc2liaWxpdHk9PT0hMCYmYy5pbml0QURBKCl9LGIucHJvdG90eXBlLmluaXRBcnJvd0V2ZW50cz1mdW5jdGlvbigpe3ZhciBhPXRoaXM7YS5vcHRpb25zLmFycm93cz09PSEwJiZhLnNsaWRlQ291bnQ+YS5vcHRpb25zLnNsaWRlc1RvU2hvdyYmKGEuJHByZXZBcnJvdy5vbihcImNsaWNrLnNsaWNrXCIse21lc3NhZ2U6XCJwcmV2aW91c1wifSxhLmNoYW5nZVNsaWRlKSxhLiRuZXh0QXJyb3cub24oXCJjbGljay5zbGlja1wiLHttZXNzYWdlOlwibmV4dFwifSxhLmNoYW5nZVNsaWRlKSl9LGIucHJvdG90eXBlLmluaXREb3RFdmVudHM9ZnVuY3Rpb24oKXt2YXIgYj10aGlzO2Iub3B0aW9ucy5kb3RzPT09ITAmJmIuc2xpZGVDb3VudD5iLm9wdGlvbnMuc2xpZGVzVG9TaG93JiZhKFwibGlcIixiLiRkb3RzKS5vbihcImNsaWNrLnNsaWNrXCIse21lc3NhZ2U6XCJpbmRleFwifSxiLmNoYW5nZVNsaWRlKSxiLm9wdGlvbnMuZG90cz09PSEwJiZiLm9wdGlvbnMucGF1c2VPbkRvdHNIb3Zlcj09PSEwJiZiLm9wdGlvbnMuYXV0b3BsYXk9PT0hMCYmYShcImxpXCIsYi4kZG90cykub24oXCJtb3VzZWVudGVyLnNsaWNrXCIsYS5wcm94eShiLnNldFBhdXNlZCxiLCEwKSkub24oXCJtb3VzZWxlYXZlLnNsaWNrXCIsYS5wcm94eShiLnNldFBhdXNlZCxiLCExKSl9LGIucHJvdG90eXBlLmluaXRpYWxpemVFdmVudHM9ZnVuY3Rpb24oKXt2YXIgYj10aGlzO2IuaW5pdEFycm93RXZlbnRzKCksYi5pbml0RG90RXZlbnRzKCksYi4kbGlzdC5vbihcInRvdWNoc3RhcnQuc2xpY2sgbW91c2Vkb3duLnNsaWNrXCIse2FjdGlvbjpcInN0YXJ0XCJ9LGIuc3dpcGVIYW5kbGVyKSxiLiRsaXN0Lm9uKFwidG91Y2htb3ZlLnNsaWNrIG1vdXNlbW92ZS5zbGlja1wiLHthY3Rpb246XCJtb3ZlXCJ9LGIuc3dpcGVIYW5kbGVyKSxiLiRsaXN0Lm9uKFwidG91Y2hlbmQuc2xpY2sgbW91c2V1cC5zbGlja1wiLHthY3Rpb246XCJlbmRcIn0sYi5zd2lwZUhhbmRsZXIpLGIuJGxpc3Qub24oXCJ0b3VjaGNhbmNlbC5zbGljayBtb3VzZWxlYXZlLnNsaWNrXCIse2FjdGlvbjpcImVuZFwifSxiLnN3aXBlSGFuZGxlciksYi4kbGlzdC5vbihcImNsaWNrLnNsaWNrXCIsYi5jbGlja0hhbmRsZXIpLGEoZG9jdW1lbnQpLm9uKGIudmlzaWJpbGl0eUNoYW5nZSxhLnByb3h5KGIudmlzaWJpbGl0eSxiKSksYi4kbGlzdC5vbihcIm1vdXNlZW50ZXIuc2xpY2tcIixhLnByb3h5KGIuc2V0UGF1c2VkLGIsITApKSxiLiRsaXN0Lm9uKFwibW91c2VsZWF2ZS5zbGlja1wiLGEucHJveHkoYi5zZXRQYXVzZWQsYiwhMSkpLGIub3B0aW9ucy5hY2Nlc3NpYmlsaXR5PT09ITAmJmIuJGxpc3Qub24oXCJrZXlkb3duLnNsaWNrXCIsYi5rZXlIYW5kbGVyKSxiLm9wdGlvbnMuZm9jdXNPblNlbGVjdD09PSEwJiZhKGIuJHNsaWRlVHJhY2spLmNoaWxkcmVuKCkub24oXCJjbGljay5zbGlja1wiLGIuc2VsZWN0SGFuZGxlciksYSh3aW5kb3cpLm9uKFwib3JpZW50YXRpb25jaGFuZ2Uuc2xpY2suc2xpY2stXCIrYi5pbnN0YW5jZVVpZCxhLnByb3h5KGIub3JpZW50YXRpb25DaGFuZ2UsYikpLGEod2luZG93KS5vbihcInJlc2l6ZS5zbGljay5zbGljay1cIitiLmluc3RhbmNlVWlkLGEucHJveHkoYi5yZXNpemUsYikpLGEoXCJbZHJhZ2dhYmxlIT10cnVlXVwiLGIuJHNsaWRlVHJhY2spLm9uKFwiZHJhZ3N0YXJ0XCIsYi5wcmV2ZW50RGVmYXVsdCksYSh3aW5kb3cpLm9uKFwibG9hZC5zbGljay5zbGljay1cIitiLmluc3RhbmNlVWlkLGIuc2V0UG9zaXRpb24pLGEoZG9jdW1lbnQpLm9uKFwicmVhZHkuc2xpY2suc2xpY2stXCIrYi5pbnN0YW5jZVVpZCxiLnNldFBvc2l0aW9uKX0sYi5wcm90b3R5cGUuaW5pdFVJPWZ1bmN0aW9uKCl7dmFyIGE9dGhpczthLm9wdGlvbnMuYXJyb3dzPT09ITAmJmEuc2xpZGVDb3VudD5hLm9wdGlvbnMuc2xpZGVzVG9TaG93JiYoYS4kcHJldkFycm93LnNob3coKSxhLiRuZXh0QXJyb3cuc2hvdygpKSxhLm9wdGlvbnMuZG90cz09PSEwJiZhLnNsaWRlQ291bnQ+YS5vcHRpb25zLnNsaWRlc1RvU2hvdyYmYS4kZG90cy5zaG93KCksYS5vcHRpb25zLmF1dG9wbGF5PT09ITAmJmEuYXV0b1BsYXkoKX0sYi5wcm90b3R5cGUua2V5SGFuZGxlcj1mdW5jdGlvbihhKXt2YXIgYj10aGlzO2EudGFyZ2V0LnRhZ05hbWUubWF0Y2goXCJURVhUQVJFQXxJTlBVVHxTRUxFQ1RcIil8fCgzNz09PWEua2V5Q29kZSYmYi5vcHRpb25zLmFjY2Vzc2liaWxpdHk9PT0hMD9iLmNoYW5nZVNsaWRlKHtkYXRhOnttZXNzYWdlOlwicHJldmlvdXNcIn19KTozOT09PWEua2V5Q29kZSYmYi5vcHRpb25zLmFjY2Vzc2liaWxpdHk9PT0hMCYmYi5jaGFuZ2VTbGlkZSh7ZGF0YTp7bWVzc2FnZTpcIm5leHRcIn19KSl9LGIucHJvdG90eXBlLmxhenlMb2FkPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gZyhiKXthKFwiaW1nW2RhdGEtbGF6eV1cIixiKS5lYWNoKGZ1bmN0aW9uKCl7dmFyIGI9YSh0aGlzKSxjPWEodGhpcykuYXR0cihcImRhdGEtbGF6eVwiKSxkPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpbWdcIik7ZC5vbmxvYWQ9ZnVuY3Rpb24oKXtiLmFuaW1hdGUoe29wYWNpdHk6MH0sMTAwLGZ1bmN0aW9uKCl7Yi5hdHRyKFwic3JjXCIsYykuYW5pbWF0ZSh7b3BhY2l0eToxfSwyMDAsZnVuY3Rpb24oKXtiLnJlbW92ZUF0dHIoXCJkYXRhLWxhenlcIikucmVtb3ZlQ2xhc3MoXCJzbGljay1sb2FkaW5nXCIpfSl9KX0sZC5zcmM9Y30pfXZhciBjLGQsZSxmLGI9dGhpcztiLm9wdGlvbnMuY2VudGVyTW9kZT09PSEwP2Iub3B0aW9ucy5pbmZpbml0ZT09PSEwPyhlPWIuY3VycmVudFNsaWRlKyhiLm9wdGlvbnMuc2xpZGVzVG9TaG93LzIrMSksZj1lK2Iub3B0aW9ucy5zbGlkZXNUb1Nob3crMik6KGU9TWF0aC5tYXgoMCxiLmN1cnJlbnRTbGlkZS0oYi5vcHRpb25zLnNsaWRlc1RvU2hvdy8yKzEpKSxmPTIrKGIub3B0aW9ucy5zbGlkZXNUb1Nob3cvMisxKStiLmN1cnJlbnRTbGlkZSk6KGU9Yi5vcHRpb25zLmluZmluaXRlP2Iub3B0aW9ucy5zbGlkZXNUb1Nob3crYi5jdXJyZW50U2xpZGU6Yi5jdXJyZW50U2xpZGUsZj1lK2Iub3B0aW9ucy5zbGlkZXNUb1Nob3csYi5vcHRpb25zLmZhZGU9PT0hMCYmKGU+MCYmZS0tLGY8PWIuc2xpZGVDb3VudCYmZisrKSksYz1iLiRzbGlkZXIuZmluZChcIi5zbGljay1zbGlkZVwiKS5zbGljZShlLGYpLGcoYyksYi5zbGlkZUNvdW50PD1iLm9wdGlvbnMuc2xpZGVzVG9TaG93PyhkPWIuJHNsaWRlci5maW5kKFwiLnNsaWNrLXNsaWRlXCIpLGcoZCkpOmIuY3VycmVudFNsaWRlPj1iLnNsaWRlQ291bnQtYi5vcHRpb25zLnNsaWRlc1RvU2hvdz8oZD1iLiRzbGlkZXIuZmluZChcIi5zbGljay1jbG9uZWRcIikuc2xpY2UoMCxiLm9wdGlvbnMuc2xpZGVzVG9TaG93KSxnKGQpKTowPT09Yi5jdXJyZW50U2xpZGUmJihkPWIuJHNsaWRlci5maW5kKFwiLnNsaWNrLWNsb25lZFwiKS5zbGljZSgtMSpiLm9wdGlvbnMuc2xpZGVzVG9TaG93KSxnKGQpKX0sYi5wcm90b3R5cGUubG9hZFNsaWRlcj1mdW5jdGlvbigpe3ZhciBhPXRoaXM7YS5zZXRQb3NpdGlvbigpLGEuJHNsaWRlVHJhY2suY3NzKHtvcGFjaXR5OjF9KSxhLiRzbGlkZXIucmVtb3ZlQ2xhc3MoXCJzbGljay1sb2FkaW5nXCIpLGEuaW5pdFVJKCksXCJwcm9ncmVzc2l2ZVwiPT09YS5vcHRpb25zLmxhenlMb2FkJiZhLnByb2dyZXNzaXZlTGF6eUxvYWQoKX0sYi5wcm90b3R5cGUubmV4dD1iLnByb3RvdHlwZS5zbGlja05leHQ9ZnVuY3Rpb24oKXt2YXIgYT10aGlzO2EuY2hhbmdlU2xpZGUoe2RhdGE6e21lc3NhZ2U6XCJuZXh0XCJ9fSl9LGIucHJvdG90eXBlLm9yaWVudGF0aW9uQ2hhbmdlPWZ1bmN0aW9uKCl7dmFyIGE9dGhpczthLmNoZWNrUmVzcG9uc2l2ZSgpLGEuc2V0UG9zaXRpb24oKX0sYi5wcm90b3R5cGUucGF1c2U9Yi5wcm90b3R5cGUuc2xpY2tQYXVzZT1mdW5jdGlvbigpe3ZhciBhPXRoaXM7YS5hdXRvUGxheUNsZWFyKCksYS5wYXVzZWQ9ITB9LGIucHJvdG90eXBlLnBsYXk9Yi5wcm90b3R5cGUuc2xpY2tQbGF5PWZ1bmN0aW9uKCl7dmFyIGE9dGhpczthLnBhdXNlZD0hMSxhLmF1dG9QbGF5KCl9LGIucHJvdG90eXBlLnBvc3RTbGlkZT1mdW5jdGlvbihhKXt2YXIgYj10aGlzO2IuJHNsaWRlci50cmlnZ2VyKFwiYWZ0ZXJDaGFuZ2VcIixbYixhXSksYi5hbmltYXRpbmc9ITEsYi5zZXRQb3NpdGlvbigpLGIuc3dpcGVMZWZ0PW51bGwsYi5vcHRpb25zLmF1dG9wbGF5PT09ITAmJmIucGF1c2VkPT09ITEmJmIuYXV0b1BsYXkoKSxiLm9wdGlvbnMuYWNjZXNzaWJpbGl0eT09PSEwJiZiLmluaXRBREEoKX0sYi5wcm90b3R5cGUucHJldj1iLnByb3RvdHlwZS5zbGlja1ByZXY9ZnVuY3Rpb24oKXt2YXIgYT10aGlzO2EuY2hhbmdlU2xpZGUoe2RhdGE6e21lc3NhZ2U6XCJwcmV2aW91c1wifX0pfSxiLnByb3RvdHlwZS5wcmV2ZW50RGVmYXVsdD1mdW5jdGlvbihhKXthLnByZXZlbnREZWZhdWx0KCl9LGIucHJvdG90eXBlLnByb2dyZXNzaXZlTGF6eUxvYWQ9ZnVuY3Rpb24oKXt2YXIgYyxkLGI9dGhpcztjPWEoXCJpbWdbZGF0YS1sYXp5XVwiLGIuJHNsaWRlcikubGVuZ3RoLGM+MCYmKGQ9YShcImltZ1tkYXRhLWxhenldXCIsYi4kc2xpZGVyKS5maXJzdCgpLGQuYXR0cihcInNyY1wiLG51bGwpLGQuYXR0cihcInNyY1wiLGQuYXR0cihcImRhdGEtbGF6eVwiKSkucmVtb3ZlQ2xhc3MoXCJzbGljay1sb2FkaW5nXCIpLmxvYWQoZnVuY3Rpb24oKXtkLnJlbW92ZUF0dHIoXCJkYXRhLWxhenlcIiksYi5wcm9ncmVzc2l2ZUxhenlMb2FkKCksYi5vcHRpb25zLmFkYXB0aXZlSGVpZ2h0PT09ITAmJmIuc2V0UG9zaXRpb24oKX0pLmVycm9yKGZ1bmN0aW9uKCl7ZC5yZW1vdmVBdHRyKFwiZGF0YS1sYXp5XCIpLGIucHJvZ3Jlc3NpdmVMYXp5TG9hZCgpfSkpfSxiLnByb3RvdHlwZS5yZWZyZXNoPWZ1bmN0aW9uKGIpe3ZhciBkLGUsYz10aGlzO2U9Yy5zbGlkZUNvdW50LWMub3B0aW9ucy5zbGlkZXNUb1Nob3csYy5vcHRpb25zLmluZmluaXRlfHwoYy5zbGlkZUNvdW50PD1jLm9wdGlvbnMuc2xpZGVzVG9TaG93P2MuY3VycmVudFNsaWRlPTA6Yy5jdXJyZW50U2xpZGU+ZSYmKGMuY3VycmVudFNsaWRlPWUpKSxkPWMuY3VycmVudFNsaWRlLGMuZGVzdHJveSghMCksYS5leHRlbmQoYyxjLmluaXRpYWxzLHtjdXJyZW50U2xpZGU6ZH0pLGMuaW5pdCgpLGJ8fGMuY2hhbmdlU2xpZGUoe2RhdGE6e21lc3NhZ2U6XCJpbmRleFwiLGluZGV4OmR9fSwhMSl9LGIucHJvdG90eXBlLnJlZ2lzdGVyQnJlYWtwb2ludHM9ZnVuY3Rpb24oKXt2YXIgYyxkLGUsYj10aGlzLGY9Yi5vcHRpb25zLnJlc3BvbnNpdmV8fG51bGw7aWYoXCJhcnJheVwiPT09YS50eXBlKGYpJiZmLmxlbmd0aCl7Yi5yZXNwb25kVG89Yi5vcHRpb25zLnJlc3BvbmRUb3x8XCJ3aW5kb3dcIjtmb3IoYyBpbiBmKWlmKGU9Yi5icmVha3BvaW50cy5sZW5ndGgtMSxkPWZbY10uYnJlYWtwb2ludCxmLmhhc093blByb3BlcnR5KGMpKXtmb3IoO2U+PTA7KWIuYnJlYWtwb2ludHNbZV0mJmIuYnJlYWtwb2ludHNbZV09PT1kJiZiLmJyZWFrcG9pbnRzLnNwbGljZShlLDEpLGUtLTtiLmJyZWFrcG9pbnRzLnB1c2goZCksYi5icmVha3BvaW50U2V0dGluZ3NbZF09ZltjXS5zZXR0aW5nc31iLmJyZWFrcG9pbnRzLnNvcnQoZnVuY3Rpb24oYSxjKXtyZXR1cm4gYi5vcHRpb25zLm1vYmlsZUZpcnN0P2EtYzpjLWF9KX19LGIucHJvdG90eXBlLnJlaW5pdD1mdW5jdGlvbigpe3ZhciBiPXRoaXM7Yi4kc2xpZGVzPWIuJHNsaWRlVHJhY2suY2hpbGRyZW4oYi5vcHRpb25zLnNsaWRlKS5hZGRDbGFzcyhcInNsaWNrLXNsaWRlXCIpLGIuc2xpZGVDb3VudD1iLiRzbGlkZXMubGVuZ3RoLGIuY3VycmVudFNsaWRlPj1iLnNsaWRlQ291bnQmJjAhPT1iLmN1cnJlbnRTbGlkZSYmKGIuY3VycmVudFNsaWRlPWIuY3VycmVudFNsaWRlLWIub3B0aW9ucy5zbGlkZXNUb1Njcm9sbCksYi5zbGlkZUNvdW50PD1iLm9wdGlvbnMuc2xpZGVzVG9TaG93JiYoYi5jdXJyZW50U2xpZGU9MCksYi5yZWdpc3RlckJyZWFrcG9pbnRzKCksYi5zZXRQcm9wcygpLGIuc2V0dXBJbmZpbml0ZSgpLGIuYnVpbGRBcnJvd3MoKSxiLnVwZGF0ZUFycm93cygpLGIuaW5pdEFycm93RXZlbnRzKCksYi5idWlsZERvdHMoKSxiLnVwZGF0ZURvdHMoKSxiLmluaXREb3RFdmVudHMoKSxiLmNoZWNrUmVzcG9uc2l2ZSghMSwhMCksYi5vcHRpb25zLmZvY3VzT25TZWxlY3Q9PT0hMCYmYShiLiRzbGlkZVRyYWNrKS5jaGlsZHJlbigpLm9uKFwiY2xpY2suc2xpY2tcIixiLnNlbGVjdEhhbmRsZXIpLGIuc2V0U2xpZGVDbGFzc2VzKDApLGIuc2V0UG9zaXRpb24oKSxiLiRzbGlkZXIudHJpZ2dlcihcInJlSW5pdFwiLFtiXSksYi5vcHRpb25zLmF1dG9wbGF5PT09ITAmJmIuZm9jdXNIYW5kbGVyKCl9LGIucHJvdG90eXBlLnJlc2l6ZT1mdW5jdGlvbigpe3ZhciBiPXRoaXM7YSh3aW5kb3cpLndpZHRoKCkhPT1iLndpbmRvd1dpZHRoJiYoY2xlYXJUaW1lb3V0KGIud2luZG93RGVsYXkpLGIud2luZG93RGVsYXk9d2luZG93LnNldFRpbWVvdXQoZnVuY3Rpb24oKXtiLndpbmRvd1dpZHRoPWEod2luZG93KS53aWR0aCgpLGIuY2hlY2tSZXNwb25zaXZlKCksYi51bnNsaWNrZWR8fGIuc2V0UG9zaXRpb24oKX0sNTApKX0sYi5wcm90b3R5cGUucmVtb3ZlU2xpZGU9Yi5wcm90b3R5cGUuc2xpY2tSZW1vdmU9ZnVuY3Rpb24oYSxiLGMpe3ZhciBkPXRoaXM7cmV0dXJuXCJib29sZWFuXCI9PXR5cGVvZiBhPyhiPWEsYT1iPT09ITA/MDpkLnNsaWRlQ291bnQtMSk6YT1iPT09ITA/LS1hOmEsZC5zbGlkZUNvdW50PDF8fDA+YXx8YT5kLnNsaWRlQ291bnQtMT8hMTooZC51bmxvYWQoKSxjPT09ITA/ZC4kc2xpZGVUcmFjay5jaGlsZHJlbigpLnJlbW92ZSgpOmQuJHNsaWRlVHJhY2suY2hpbGRyZW4odGhpcy5vcHRpb25zLnNsaWRlKS5lcShhKS5yZW1vdmUoKSxkLiRzbGlkZXM9ZC4kc2xpZGVUcmFjay5jaGlsZHJlbih0aGlzLm9wdGlvbnMuc2xpZGUpLGQuJHNsaWRlVHJhY2suY2hpbGRyZW4odGhpcy5vcHRpb25zLnNsaWRlKS5kZXRhY2goKSxkLiRzbGlkZVRyYWNrLmFwcGVuZChkLiRzbGlkZXMpLGQuJHNsaWRlc0NhY2hlPWQuJHNsaWRlcyx2b2lkIGQucmVpbml0KCkpfSxiLnByb3RvdHlwZS5zZXRDU1M9ZnVuY3Rpb24oYSl7dmFyIGQsZSxiPXRoaXMsYz17fTtiLm9wdGlvbnMucnRsPT09ITAmJihhPS1hKSxkPVwibGVmdFwiPT1iLnBvc2l0aW9uUHJvcD9NYXRoLmNlaWwoYSkrXCJweFwiOlwiMHB4XCIsZT1cInRvcFwiPT1iLnBvc2l0aW9uUHJvcD9NYXRoLmNlaWwoYSkrXCJweFwiOlwiMHB4XCIsY1tiLnBvc2l0aW9uUHJvcF09YSxiLnRyYW5zZm9ybXNFbmFibGVkPT09ITE/Yi4kc2xpZGVUcmFjay5jc3MoYyk6KGM9e30sYi5jc3NUcmFuc2l0aW9ucz09PSExPyhjW2IuYW5pbVR5cGVdPVwidHJhbnNsYXRlKFwiK2QrXCIsIFwiK2UrXCIpXCIsYi4kc2xpZGVUcmFjay5jc3MoYykpOihjW2IuYW5pbVR5cGVdPVwidHJhbnNsYXRlM2QoXCIrZCtcIiwgXCIrZStcIiwgMHB4KVwiLGIuJHNsaWRlVHJhY2suY3NzKGMpKSl9LGIucHJvdG90eXBlLnNldERpbWVuc2lvbnM9ZnVuY3Rpb24oKXt2YXIgYT10aGlzO2Eub3B0aW9ucy52ZXJ0aWNhbD09PSExP2Eub3B0aW9ucy5jZW50ZXJNb2RlPT09ITAmJmEuJGxpc3QuY3NzKHtwYWRkaW5nOlwiMHB4IFwiK2Eub3B0aW9ucy5jZW50ZXJQYWRkaW5nfSk6KGEuJGxpc3QuaGVpZ2h0KGEuJHNsaWRlcy5maXJzdCgpLm91dGVySGVpZ2h0KCEwKSphLm9wdGlvbnMuc2xpZGVzVG9TaG93KSxhLm9wdGlvbnMuY2VudGVyTW9kZT09PSEwJiZhLiRsaXN0LmNzcyh7cGFkZGluZzphLm9wdGlvbnMuY2VudGVyUGFkZGluZytcIiAwcHhcIn0pKSxhLmxpc3RXaWR0aD1hLiRsaXN0LndpZHRoKCksYS5saXN0SGVpZ2h0PWEuJGxpc3QuaGVpZ2h0KCksYS5vcHRpb25zLnZlcnRpY2FsPT09ITEmJmEub3B0aW9ucy52YXJpYWJsZVdpZHRoPT09ITE/KGEuc2xpZGVXaWR0aD1NYXRoLmNlaWwoYS5saXN0V2lkdGgvYS5vcHRpb25zLnNsaWRlc1RvU2hvdyksYS4kc2xpZGVUcmFjay53aWR0aChNYXRoLmNlaWwoYS5zbGlkZVdpZHRoKmEuJHNsaWRlVHJhY2suY2hpbGRyZW4oXCIuc2xpY2stc2xpZGVcIikubGVuZ3RoKSkpOmEub3B0aW9ucy52YXJpYWJsZVdpZHRoPT09ITA/YS4kc2xpZGVUcmFjay53aWR0aCg1ZTMqYS5zbGlkZUNvdW50KTooYS5zbGlkZVdpZHRoPU1hdGguY2VpbChhLmxpc3RXaWR0aCksYS4kc2xpZGVUcmFjay5oZWlnaHQoTWF0aC5jZWlsKGEuJHNsaWRlcy5maXJzdCgpLm91dGVySGVpZ2h0KCEwKSphLiRzbGlkZVRyYWNrLmNoaWxkcmVuKFwiLnNsaWNrLXNsaWRlXCIpLmxlbmd0aCkpKTt2YXIgYj1hLiRzbGlkZXMuZmlyc3QoKS5vdXRlcldpZHRoKCEwKS1hLiRzbGlkZXMuZmlyc3QoKS53aWR0aCgpO2Eub3B0aW9ucy52YXJpYWJsZVdpZHRoPT09ITEmJmEuJHNsaWRlVHJhY2suY2hpbGRyZW4oXCIuc2xpY2stc2xpZGVcIikud2lkdGgoYS5zbGlkZVdpZHRoLWIpfSxiLnByb3RvdHlwZS5zZXRGYWRlPWZ1bmN0aW9uKCl7dmFyIGMsYj10aGlzO2IuJHNsaWRlcy5lYWNoKGZ1bmN0aW9uKGQsZSl7Yz1iLnNsaWRlV2lkdGgqZCotMSxiLm9wdGlvbnMucnRsPT09ITA/YShlKS5jc3Moe3Bvc2l0aW9uOlwicmVsYXRpdmVcIixyaWdodDpjLHRvcDowLHpJbmRleDpiLm9wdGlvbnMuekluZGV4LTIsb3BhY2l0eTowfSk6YShlKS5jc3Moe3Bvc2l0aW9uOlwicmVsYXRpdmVcIixsZWZ0OmMsdG9wOjAsekluZGV4OmIub3B0aW9ucy56SW5kZXgtMixvcGFjaXR5OjB9KX0pLGIuJHNsaWRlcy5lcShiLmN1cnJlbnRTbGlkZSkuY3NzKHt6SW5kZXg6Yi5vcHRpb25zLnpJbmRleC0xLG9wYWNpdHk6MX0pfSxiLnByb3RvdHlwZS5zZXRIZWlnaHQ9ZnVuY3Rpb24oKXt2YXIgYT10aGlzO2lmKDE9PT1hLm9wdGlvbnMuc2xpZGVzVG9TaG93JiZhLm9wdGlvbnMuYWRhcHRpdmVIZWlnaHQ9PT0hMCYmYS5vcHRpb25zLnZlcnRpY2FsPT09ITEpe3ZhciBiPWEuJHNsaWRlcy5lcShhLmN1cnJlbnRTbGlkZSkub3V0ZXJIZWlnaHQoITApO2EuJGxpc3QuY3NzKFwiaGVpZ2h0XCIsYil9fSxiLnByb3RvdHlwZS5zZXRPcHRpb249Yi5wcm90b3R5cGUuc2xpY2tTZXRPcHRpb249ZnVuY3Rpb24oYixjLGQpe3ZhciBmLGcsZT10aGlzO2lmKFwicmVzcG9uc2l2ZVwiPT09YiYmXCJhcnJheVwiPT09YS50eXBlKGMpKWZvcihnIGluIGMpaWYoXCJhcnJheVwiIT09YS50eXBlKGUub3B0aW9ucy5yZXNwb25zaXZlKSllLm9wdGlvbnMucmVzcG9uc2l2ZT1bY1tnXV07ZWxzZXtmb3IoZj1lLm9wdGlvbnMucmVzcG9uc2l2ZS5sZW5ndGgtMTtmPj0wOyllLm9wdGlvbnMucmVzcG9uc2l2ZVtmXS5icmVha3BvaW50PT09Y1tnXS5icmVha3BvaW50JiZlLm9wdGlvbnMucmVzcG9uc2l2ZS5zcGxpY2UoZiwxKSxmLS07ZS5vcHRpb25zLnJlc3BvbnNpdmUucHVzaChjW2ddKX1lbHNlIGUub3B0aW9uc1tiXT1jO2Q9PT0hMCYmKGUudW5sb2FkKCksZS5yZWluaXQoKSl9LGIucHJvdG90eXBlLnNldFBvc2l0aW9uPWZ1bmN0aW9uKCl7dmFyIGE9dGhpczthLnNldERpbWVuc2lvbnMoKSxhLnNldEhlaWdodCgpLGEub3B0aW9ucy5mYWRlPT09ITE/YS5zZXRDU1MoYS5nZXRMZWZ0KGEuY3VycmVudFNsaWRlKSk6YS5zZXRGYWRlKCksYS4kc2xpZGVyLnRyaWdnZXIoXCJzZXRQb3NpdGlvblwiLFthXSl9LGIucHJvdG90eXBlLnNldFByb3BzPWZ1bmN0aW9uKCl7dmFyIGE9dGhpcyxiPWRvY3VtZW50LmJvZHkuc3R5bGU7YS5wb3NpdGlvblByb3A9YS5vcHRpb25zLnZlcnRpY2FsPT09ITA/XCJ0b3BcIjpcImxlZnRcIixcInRvcFwiPT09YS5wb3NpdGlvblByb3A/YS4kc2xpZGVyLmFkZENsYXNzKFwic2xpY2stdmVydGljYWxcIik6YS4kc2xpZGVyLnJlbW92ZUNsYXNzKFwic2xpY2stdmVydGljYWxcIiksKHZvaWQgMCE9PWIuV2Via2l0VHJhbnNpdGlvbnx8dm9pZCAwIT09Yi5Nb3pUcmFuc2l0aW9ufHx2b2lkIDAhPT1iLm1zVHJhbnNpdGlvbikmJmEub3B0aW9ucy51c2VDU1M9PT0hMCYmKGEuY3NzVHJhbnNpdGlvbnM9ITApLGEub3B0aW9ucy5mYWRlJiYoXCJudW1iZXJcIj09dHlwZW9mIGEub3B0aW9ucy56SW5kZXg/YS5vcHRpb25zLnpJbmRleDwzJiYoYS5vcHRpb25zLnpJbmRleD0zKTphLm9wdGlvbnMuekluZGV4PWEuZGVmYXVsdHMuekluZGV4KSx2b2lkIDAhPT1iLk9UcmFuc2Zvcm0mJihhLmFuaW1UeXBlPVwiT1RyYW5zZm9ybVwiLGEudHJhbnNmb3JtVHlwZT1cIi1vLXRyYW5zZm9ybVwiLGEudHJhbnNpdGlvblR5cGU9XCJPVHJhbnNpdGlvblwiLHZvaWQgMD09PWIucGVyc3BlY3RpdmVQcm9wZXJ0eSYmdm9pZCAwPT09Yi53ZWJraXRQZXJzcGVjdGl2ZSYmKGEuYW5pbVR5cGU9ITEpKSx2b2lkIDAhPT1iLk1velRyYW5zZm9ybSYmKGEuYW5pbVR5cGU9XCJNb3pUcmFuc2Zvcm1cIixhLnRyYW5zZm9ybVR5cGU9XCItbW96LXRyYW5zZm9ybVwiLGEudHJhbnNpdGlvblR5cGU9XCJNb3pUcmFuc2l0aW9uXCIsdm9pZCAwPT09Yi5wZXJzcGVjdGl2ZVByb3BlcnR5JiZ2b2lkIDA9PT1iLk1velBlcnNwZWN0aXZlJiYoYS5hbmltVHlwZT0hMSkpLHZvaWQgMCE9PWIud2Via2l0VHJhbnNmb3JtJiYoYS5hbmltVHlwZT1cIndlYmtpdFRyYW5zZm9ybVwiLGEudHJhbnNmb3JtVHlwZT1cIi13ZWJraXQtdHJhbnNmb3JtXCIsYS50cmFuc2l0aW9uVHlwZT1cIndlYmtpdFRyYW5zaXRpb25cIix2b2lkIDA9PT1iLnBlcnNwZWN0aXZlUHJvcGVydHkmJnZvaWQgMD09PWIud2Via2l0UGVyc3BlY3RpdmUmJihhLmFuaW1UeXBlPSExKSksdm9pZCAwIT09Yi5tc1RyYW5zZm9ybSYmKGEuYW5pbVR5cGU9XCJtc1RyYW5zZm9ybVwiLGEudHJhbnNmb3JtVHlwZT1cIi1tcy10cmFuc2Zvcm1cIixhLnRyYW5zaXRpb25UeXBlPVwibXNUcmFuc2l0aW9uXCIsdm9pZCAwPT09Yi5tc1RyYW5zZm9ybSYmKGEuYW5pbVR5cGU9ITEpKSx2b2lkIDAhPT1iLnRyYW5zZm9ybSYmYS5hbmltVHlwZSE9PSExJiYoYS5hbmltVHlwZT1cInRyYW5zZm9ybVwiLGEudHJhbnNmb3JtVHlwZT1cInRyYW5zZm9ybVwiLGEudHJhbnNpdGlvblR5cGU9XCJ0cmFuc2l0aW9uXCIpLGEudHJhbnNmb3Jtc0VuYWJsZWQ9YS5vcHRpb25zLnVzZVRyYW5zZm9ybSYmbnVsbCE9PWEuYW5pbVR5cGUmJmEuYW5pbVR5cGUhPT0hMX0sYi5wcm90b3R5cGUuc2V0U2xpZGVDbGFzc2VzPWZ1bmN0aW9uKGEpe3ZhciBjLGQsZSxmLGI9dGhpcztkPWIuJHNsaWRlci5maW5kKFwiLnNsaWNrLXNsaWRlXCIpLnJlbW92ZUNsYXNzKFwic2xpY2stYWN0aXZlIHNsaWNrLWNlbnRlciBzbGljay1jdXJyZW50XCIpLmF0dHIoXCJhcmlhLWhpZGRlblwiLFwidHJ1ZVwiKSxiLiRzbGlkZXMuZXEoYSkuYWRkQ2xhc3MoXCJzbGljay1jdXJyZW50XCIpLGIub3B0aW9ucy5jZW50ZXJNb2RlPT09ITA/KGM9TWF0aC5mbG9vcihiLm9wdGlvbnMuc2xpZGVzVG9TaG93LzIpLGIub3B0aW9ucy5pbmZpbml0ZT09PSEwJiYoYT49YyYmYTw9Yi5zbGlkZUNvdW50LTEtYz9iLiRzbGlkZXMuc2xpY2UoYS1jLGErYysxKS5hZGRDbGFzcyhcInNsaWNrLWFjdGl2ZVwiKS5hdHRyKFwiYXJpYS1oaWRkZW5cIixcImZhbHNlXCIpOihlPWIub3B0aW9ucy5zbGlkZXNUb1Nob3crYSxkLnNsaWNlKGUtYysxLGUrYysyKS5hZGRDbGFzcyhcInNsaWNrLWFjdGl2ZVwiKS5hdHRyKFwiYXJpYS1oaWRkZW5cIixcImZhbHNlXCIpKSwwPT09YT9kLmVxKGQubGVuZ3RoLTEtYi5vcHRpb25zLnNsaWRlc1RvU2hvdykuYWRkQ2xhc3MoXCJzbGljay1jZW50ZXJcIik6YT09PWIuc2xpZGVDb3VudC0xJiZkLmVxKGIub3B0aW9ucy5zbGlkZXNUb1Nob3cpLmFkZENsYXNzKFwic2xpY2stY2VudGVyXCIpKSxiLiRzbGlkZXMuZXEoYSkuYWRkQ2xhc3MoXCJzbGljay1jZW50ZXJcIikpOmE+PTAmJmE8PWIuc2xpZGVDb3VudC1iLm9wdGlvbnMuc2xpZGVzVG9TaG93P2IuJHNsaWRlcy5zbGljZShhLGErYi5vcHRpb25zLnNsaWRlc1RvU2hvdykuYWRkQ2xhc3MoXCJzbGljay1hY3RpdmVcIikuYXR0cihcImFyaWEtaGlkZGVuXCIsXCJmYWxzZVwiKTpkLmxlbmd0aDw9Yi5vcHRpb25zLnNsaWRlc1RvU2hvdz9kLmFkZENsYXNzKFwic2xpY2stYWN0aXZlXCIpLmF0dHIoXCJhcmlhLWhpZGRlblwiLFwiZmFsc2VcIik6KGY9Yi5zbGlkZUNvdW50JWIub3B0aW9ucy5zbGlkZXNUb1Nob3csZT1iLm9wdGlvbnMuaW5maW5pdGU9PT0hMD9iLm9wdGlvbnMuc2xpZGVzVG9TaG93K2E6YSxiLm9wdGlvbnMuc2xpZGVzVG9TaG93PT1iLm9wdGlvbnMuc2xpZGVzVG9TY3JvbGwmJmIuc2xpZGVDb3VudC1hPGIub3B0aW9ucy5zbGlkZXNUb1Nob3c/ZC5zbGljZShlLShiLm9wdGlvbnMuc2xpZGVzVG9TaG93LWYpLGUrZikuYWRkQ2xhc3MoXCJzbGljay1hY3RpdmVcIikuYXR0cihcImFyaWEtaGlkZGVuXCIsXCJmYWxzZVwiKTpkLnNsaWNlKGUsZStiLm9wdGlvbnMuc2xpZGVzVG9TaG93KS5hZGRDbGFzcyhcInNsaWNrLWFjdGl2ZVwiKS5hdHRyKFwiYXJpYS1oaWRkZW5cIixcImZhbHNlXCIpKSxcIm9uZGVtYW5kXCI9PT1iLm9wdGlvbnMubGF6eUxvYWQmJmIubGF6eUxvYWQoKX0sYi5wcm90b3R5cGUuc2V0dXBJbmZpbml0ZT1mdW5jdGlvbigpe3ZhciBjLGQsZSxiPXRoaXM7aWYoYi5vcHRpb25zLmZhZGU9PT0hMCYmKGIub3B0aW9ucy5jZW50ZXJNb2RlPSExKSxiLm9wdGlvbnMuaW5maW5pdGU9PT0hMCYmYi5vcHRpb25zLmZhZGU9PT0hMSYmKGQ9bnVsbCxiLnNsaWRlQ291bnQ+Yi5vcHRpb25zLnNsaWRlc1RvU2hvdykpe2ZvcihlPWIub3B0aW9ucy5jZW50ZXJNb2RlPT09ITA/Yi5vcHRpb25zLnNsaWRlc1RvU2hvdysxOmIub3B0aW9ucy5zbGlkZXNUb1Nob3csYz1iLnNsaWRlQ291bnQ7Yz5iLnNsaWRlQ291bnQtZTtjLT0xKWQ9Yy0xLGEoYi4kc2xpZGVzW2RdKS5jbG9uZSghMCkuYXR0cihcImlkXCIsXCJcIikuYXR0cihcImRhdGEtc2xpY2staW5kZXhcIixkLWIuc2xpZGVDb3VudCkucHJlcGVuZFRvKGIuJHNsaWRlVHJhY2spLmFkZENsYXNzKFwic2xpY2stY2xvbmVkXCIpO2ZvcihjPTA7ZT5jO2MrPTEpZD1jLGEoYi4kc2xpZGVzW2RdKS5jbG9uZSghMCkuYXR0cihcImlkXCIsXCJcIikuYXR0cihcImRhdGEtc2xpY2staW5kZXhcIixkK2Iuc2xpZGVDb3VudCkuYXBwZW5kVG8oYi4kc2xpZGVUcmFjaykuYWRkQ2xhc3MoXCJzbGljay1jbG9uZWRcIik7Yi4kc2xpZGVUcmFjay5maW5kKFwiLnNsaWNrLWNsb25lZFwiKS5maW5kKFwiW2lkXVwiKS5lYWNoKGZ1bmN0aW9uKCl7YSh0aGlzKS5hdHRyKFwiaWRcIixcIlwiKX0pfX0sYi5wcm90b3R5cGUuc2V0UGF1c2VkPWZ1bmN0aW9uKGEpe3ZhciBiPXRoaXM7Yi5vcHRpb25zLmF1dG9wbGF5PT09ITAmJmIub3B0aW9ucy5wYXVzZU9uSG92ZXI9PT0hMCYmKGIucGF1c2VkPWEsYT9iLmF1dG9QbGF5Q2xlYXIoKTpiLmF1dG9QbGF5KCkpfSxiLnByb3RvdHlwZS5zZWxlY3RIYW5kbGVyPWZ1bmN0aW9uKGIpe3ZhciBjPXRoaXMsZD1hKGIudGFyZ2V0KS5pcyhcIi5zbGljay1zbGlkZVwiKT9hKGIudGFyZ2V0KTphKGIudGFyZ2V0KS5wYXJlbnRzKFwiLnNsaWNrLXNsaWRlXCIpLGU9cGFyc2VJbnQoZC5hdHRyKFwiZGF0YS1zbGljay1pbmRleFwiKSk7cmV0dXJuIGV8fChlPTApLGMuc2xpZGVDb3VudDw9Yy5vcHRpb25zLnNsaWRlc1RvU2hvdz8oYy5zZXRTbGlkZUNsYXNzZXMoZSksdm9pZCBjLmFzTmF2Rm9yKGUpKTp2b2lkIGMuc2xpZGVIYW5kbGVyKGUpfSxiLnByb3RvdHlwZS5zbGlkZUhhbmRsZXI9ZnVuY3Rpb24oYSxiLGMpe3ZhciBkLGUsZixnLGg9bnVsbCxpPXRoaXM7cmV0dXJuIGI9Ynx8ITEsaS5hbmltYXRpbmc9PT0hMCYmaS5vcHRpb25zLndhaXRGb3JBbmltYXRlPT09ITB8fGkub3B0aW9ucy5mYWRlPT09ITAmJmkuY3VycmVudFNsaWRlPT09YXx8aS5zbGlkZUNvdW50PD1pLm9wdGlvbnMuc2xpZGVzVG9TaG93P3ZvaWQgMDooYj09PSExJiZpLmFzTmF2Rm9yKGEpLGQ9YSxoPWkuZ2V0TGVmdChkKSxnPWkuZ2V0TGVmdChpLmN1cnJlbnRTbGlkZSksaS5jdXJyZW50TGVmdD1udWxsPT09aS5zd2lwZUxlZnQ/ZzppLnN3aXBlTGVmdCxpLm9wdGlvbnMuaW5maW5pdGU9PT0hMSYmaS5vcHRpb25zLmNlbnRlck1vZGU9PT0hMSYmKDA+YXx8YT5pLmdldERvdENvdW50KCkqaS5vcHRpb25zLnNsaWRlc1RvU2Nyb2xsKT92b2lkKGkub3B0aW9ucy5mYWRlPT09ITEmJihkPWkuY3VycmVudFNsaWRlLGMhPT0hMD9pLmFuaW1hdGVTbGlkZShnLGZ1bmN0aW9uKCl7aS5wb3N0U2xpZGUoZCk7XHJcbn0pOmkucG9zdFNsaWRlKGQpKSk6aS5vcHRpb25zLmluZmluaXRlPT09ITEmJmkub3B0aW9ucy5jZW50ZXJNb2RlPT09ITAmJigwPmF8fGE+aS5zbGlkZUNvdW50LWkub3B0aW9ucy5zbGlkZXNUb1Njcm9sbCk/dm9pZChpLm9wdGlvbnMuZmFkZT09PSExJiYoZD1pLmN1cnJlbnRTbGlkZSxjIT09ITA/aS5hbmltYXRlU2xpZGUoZyxmdW5jdGlvbigpe2kucG9zdFNsaWRlKGQpfSk6aS5wb3N0U2xpZGUoZCkpKTooaS5vcHRpb25zLmF1dG9wbGF5PT09ITAmJmNsZWFySW50ZXJ2YWwoaS5hdXRvUGxheVRpbWVyKSxlPTA+ZD9pLnNsaWRlQ291bnQlaS5vcHRpb25zLnNsaWRlc1RvU2Nyb2xsIT09MD9pLnNsaWRlQ291bnQtaS5zbGlkZUNvdW50JWkub3B0aW9ucy5zbGlkZXNUb1Njcm9sbDppLnNsaWRlQ291bnQrZDpkPj1pLnNsaWRlQ291bnQ/aS5zbGlkZUNvdW50JWkub3B0aW9ucy5zbGlkZXNUb1Njcm9sbCE9PTA/MDpkLWkuc2xpZGVDb3VudDpkLGkuYW5pbWF0aW5nPSEwLGkuJHNsaWRlci50cmlnZ2VyKFwiYmVmb3JlQ2hhbmdlXCIsW2ksaS5jdXJyZW50U2xpZGUsZV0pLGY9aS5jdXJyZW50U2xpZGUsaS5jdXJyZW50U2xpZGU9ZSxpLnNldFNsaWRlQ2xhc3NlcyhpLmN1cnJlbnRTbGlkZSksaS51cGRhdGVEb3RzKCksaS51cGRhdGVBcnJvd3MoKSxpLm9wdGlvbnMuZmFkZT09PSEwPyhjIT09ITA/KGkuZmFkZVNsaWRlT3V0KGYpLGkuZmFkZVNsaWRlKGUsZnVuY3Rpb24oKXtpLnBvc3RTbGlkZShlKX0pKTppLnBvc3RTbGlkZShlKSx2b2lkIGkuYW5pbWF0ZUhlaWdodCgpKTp2b2lkKGMhPT0hMD9pLmFuaW1hdGVTbGlkZShoLGZ1bmN0aW9uKCl7aS5wb3N0U2xpZGUoZSl9KTppLnBvc3RTbGlkZShlKSkpKX0sYi5wcm90b3R5cGUuc3RhcnRMb2FkPWZ1bmN0aW9uKCl7dmFyIGE9dGhpczthLm9wdGlvbnMuYXJyb3dzPT09ITAmJmEuc2xpZGVDb3VudD5hLm9wdGlvbnMuc2xpZGVzVG9TaG93JiYoYS4kcHJldkFycm93LmhpZGUoKSxhLiRuZXh0QXJyb3cuaGlkZSgpKSxhLm9wdGlvbnMuZG90cz09PSEwJiZhLnNsaWRlQ291bnQ+YS5vcHRpb25zLnNsaWRlc1RvU2hvdyYmYS4kZG90cy5oaWRlKCksYS4kc2xpZGVyLmFkZENsYXNzKFwic2xpY2stbG9hZGluZ1wiKX0sYi5wcm90b3R5cGUuc3dpcGVEaXJlY3Rpb249ZnVuY3Rpb24oKXt2YXIgYSxiLGMsZCxlPXRoaXM7cmV0dXJuIGE9ZS50b3VjaE9iamVjdC5zdGFydFgtZS50b3VjaE9iamVjdC5jdXJYLGI9ZS50b3VjaE9iamVjdC5zdGFydFktZS50b3VjaE9iamVjdC5jdXJZLGM9TWF0aC5hdGFuMihiLGEpLGQ9TWF0aC5yb3VuZCgxODAqYy9NYXRoLlBJKSwwPmQmJihkPTM2MC1NYXRoLmFicyhkKSksNDU+PWQmJmQ+PTA/ZS5vcHRpb25zLnJ0bD09PSExP1wibGVmdFwiOlwicmlnaHRcIjozNjA+PWQmJmQ+PTMxNT9lLm9wdGlvbnMucnRsPT09ITE/XCJsZWZ0XCI6XCJyaWdodFwiOmQ+PTEzNSYmMjI1Pj1kP2Uub3B0aW9ucy5ydGw9PT0hMT9cInJpZ2h0XCI6XCJsZWZ0XCI6ZS5vcHRpb25zLnZlcnRpY2FsU3dpcGluZz09PSEwP2Q+PTM1JiYxMzU+PWQ/XCJsZWZ0XCI6XCJyaWdodFwiOlwidmVydGljYWxcIn0sYi5wcm90b3R5cGUuc3dpcGVFbmQ9ZnVuY3Rpb24oYSl7dmFyIGMsYj10aGlzO2lmKGIuZHJhZ2dpbmc9ITEsYi5zaG91bGRDbGljaz1iLnRvdWNoT2JqZWN0LnN3aXBlTGVuZ3RoPjEwPyExOiEwLHZvaWQgMD09PWIudG91Y2hPYmplY3QuY3VyWClyZXR1cm4hMTtpZihiLnRvdWNoT2JqZWN0LmVkZ2VIaXQ9PT0hMCYmYi4kc2xpZGVyLnRyaWdnZXIoXCJlZGdlXCIsW2IsYi5zd2lwZURpcmVjdGlvbigpXSksYi50b3VjaE9iamVjdC5zd2lwZUxlbmd0aD49Yi50b3VjaE9iamVjdC5taW5Td2lwZSlzd2l0Y2goYi5zd2lwZURpcmVjdGlvbigpKXtjYXNlXCJsZWZ0XCI6Yz1iLm9wdGlvbnMuc3dpcGVUb1NsaWRlP2IuY2hlY2tOYXZpZ2FibGUoYi5jdXJyZW50U2xpZGUrYi5nZXRTbGlkZUNvdW50KCkpOmIuY3VycmVudFNsaWRlK2IuZ2V0U2xpZGVDb3VudCgpLGIuc2xpZGVIYW5kbGVyKGMpLGIuY3VycmVudERpcmVjdGlvbj0wLGIudG91Y2hPYmplY3Q9e30sYi4kc2xpZGVyLnRyaWdnZXIoXCJzd2lwZVwiLFtiLFwibGVmdFwiXSk7YnJlYWs7Y2FzZVwicmlnaHRcIjpjPWIub3B0aW9ucy5zd2lwZVRvU2xpZGU/Yi5jaGVja05hdmlnYWJsZShiLmN1cnJlbnRTbGlkZS1iLmdldFNsaWRlQ291bnQoKSk6Yi5jdXJyZW50U2xpZGUtYi5nZXRTbGlkZUNvdW50KCksYi5zbGlkZUhhbmRsZXIoYyksYi5jdXJyZW50RGlyZWN0aW9uPTEsYi50b3VjaE9iamVjdD17fSxiLiRzbGlkZXIudHJpZ2dlcihcInN3aXBlXCIsW2IsXCJyaWdodFwiXSl9ZWxzZSBiLnRvdWNoT2JqZWN0LnN0YXJ0WCE9PWIudG91Y2hPYmplY3QuY3VyWCYmKGIuc2xpZGVIYW5kbGVyKGIuY3VycmVudFNsaWRlKSxiLnRvdWNoT2JqZWN0PXt9KX0sYi5wcm90b3R5cGUuc3dpcGVIYW5kbGVyPWZ1bmN0aW9uKGEpe3ZhciBiPXRoaXM7aWYoIShiLm9wdGlvbnMuc3dpcGU9PT0hMXx8XCJvbnRvdWNoZW5kXCJpbiBkb2N1bWVudCYmYi5vcHRpb25zLnN3aXBlPT09ITF8fGIub3B0aW9ucy5kcmFnZ2FibGU9PT0hMSYmLTEhPT1hLnR5cGUuaW5kZXhPZihcIm1vdXNlXCIpKSlzd2l0Y2goYi50b3VjaE9iamVjdC5maW5nZXJDb3VudD1hLm9yaWdpbmFsRXZlbnQmJnZvaWQgMCE9PWEub3JpZ2luYWxFdmVudC50b3VjaGVzP2Eub3JpZ2luYWxFdmVudC50b3VjaGVzLmxlbmd0aDoxLGIudG91Y2hPYmplY3QubWluU3dpcGU9Yi5saXN0V2lkdGgvYi5vcHRpb25zLnRvdWNoVGhyZXNob2xkLGIub3B0aW9ucy52ZXJ0aWNhbFN3aXBpbmc9PT0hMCYmKGIudG91Y2hPYmplY3QubWluU3dpcGU9Yi5saXN0SGVpZ2h0L2Iub3B0aW9ucy50b3VjaFRocmVzaG9sZCksYS5kYXRhLmFjdGlvbil7Y2FzZVwic3RhcnRcIjpiLnN3aXBlU3RhcnQoYSk7YnJlYWs7Y2FzZVwibW92ZVwiOmIuc3dpcGVNb3ZlKGEpO2JyZWFrO2Nhc2VcImVuZFwiOmIuc3dpcGVFbmQoYSl9fSxiLnByb3RvdHlwZS5zd2lwZU1vdmU9ZnVuY3Rpb24oYSl7dmFyIGQsZSxmLGcsaCxiPXRoaXM7cmV0dXJuIGg9dm9pZCAwIT09YS5vcmlnaW5hbEV2ZW50P2Eub3JpZ2luYWxFdmVudC50b3VjaGVzOm51bGwsIWIuZHJhZ2dpbmd8fGgmJjEhPT1oLmxlbmd0aD8hMTooZD1iLmdldExlZnQoYi5jdXJyZW50U2xpZGUpLGIudG91Y2hPYmplY3QuY3VyWD12b2lkIDAhPT1oP2hbMF0ucGFnZVg6YS5jbGllbnRYLGIudG91Y2hPYmplY3QuY3VyWT12b2lkIDAhPT1oP2hbMF0ucGFnZVk6YS5jbGllbnRZLGIudG91Y2hPYmplY3Quc3dpcGVMZW5ndGg9TWF0aC5yb3VuZChNYXRoLnNxcnQoTWF0aC5wb3coYi50b3VjaE9iamVjdC5jdXJYLWIudG91Y2hPYmplY3Quc3RhcnRYLDIpKSksYi5vcHRpb25zLnZlcnRpY2FsU3dpcGluZz09PSEwJiYoYi50b3VjaE9iamVjdC5zd2lwZUxlbmd0aD1NYXRoLnJvdW5kKE1hdGguc3FydChNYXRoLnBvdyhiLnRvdWNoT2JqZWN0LmN1clktYi50b3VjaE9iamVjdC5zdGFydFksMikpKSksZT1iLnN3aXBlRGlyZWN0aW9uKCksXCJ2ZXJ0aWNhbFwiIT09ZT8odm9pZCAwIT09YS5vcmlnaW5hbEV2ZW50JiZiLnRvdWNoT2JqZWN0LnN3aXBlTGVuZ3RoPjQmJmEucHJldmVudERlZmF1bHQoKSxnPShiLm9wdGlvbnMucnRsPT09ITE/MTotMSkqKGIudG91Y2hPYmplY3QuY3VyWD5iLnRvdWNoT2JqZWN0LnN0YXJ0WD8xOi0xKSxiLm9wdGlvbnMudmVydGljYWxTd2lwaW5nPT09ITAmJihnPWIudG91Y2hPYmplY3QuY3VyWT5iLnRvdWNoT2JqZWN0LnN0YXJ0WT8xOi0xKSxmPWIudG91Y2hPYmplY3Quc3dpcGVMZW5ndGgsYi50b3VjaE9iamVjdC5lZGdlSGl0PSExLGIub3B0aW9ucy5pbmZpbml0ZT09PSExJiYoMD09PWIuY3VycmVudFNsaWRlJiZcInJpZ2h0XCI9PT1lfHxiLmN1cnJlbnRTbGlkZT49Yi5nZXREb3RDb3VudCgpJiZcImxlZnRcIj09PWUpJiYoZj1iLnRvdWNoT2JqZWN0LnN3aXBlTGVuZ3RoKmIub3B0aW9ucy5lZGdlRnJpY3Rpb24sYi50b3VjaE9iamVjdC5lZGdlSGl0PSEwKSxiLm9wdGlvbnMudmVydGljYWw9PT0hMT9iLnN3aXBlTGVmdD1kK2YqZzpiLnN3aXBlTGVmdD1kK2YqKGIuJGxpc3QuaGVpZ2h0KCkvYi5saXN0V2lkdGgpKmcsYi5vcHRpb25zLnZlcnRpY2FsU3dpcGluZz09PSEwJiYoYi5zd2lwZUxlZnQ9ZCtmKmcpLGIub3B0aW9ucy5mYWRlPT09ITB8fGIub3B0aW9ucy50b3VjaE1vdmU9PT0hMT8hMTpiLmFuaW1hdGluZz09PSEwPyhiLnN3aXBlTGVmdD1udWxsLCExKTp2b2lkIGIuc2V0Q1NTKGIuc3dpcGVMZWZ0KSk6dm9pZCAwKX0sYi5wcm90b3R5cGUuc3dpcGVTdGFydD1mdW5jdGlvbihhKXt2YXIgYyxiPXRoaXM7cmV0dXJuIDEhPT1iLnRvdWNoT2JqZWN0LmZpbmdlckNvdW50fHxiLnNsaWRlQ291bnQ8PWIub3B0aW9ucy5zbGlkZXNUb1Nob3c/KGIudG91Y2hPYmplY3Q9e30sITEpOih2b2lkIDAhPT1hLm9yaWdpbmFsRXZlbnQmJnZvaWQgMCE9PWEub3JpZ2luYWxFdmVudC50b3VjaGVzJiYoYz1hLm9yaWdpbmFsRXZlbnQudG91Y2hlc1swXSksYi50b3VjaE9iamVjdC5zdGFydFg9Yi50b3VjaE9iamVjdC5jdXJYPXZvaWQgMCE9PWM/Yy5wYWdlWDphLmNsaWVudFgsYi50b3VjaE9iamVjdC5zdGFydFk9Yi50b3VjaE9iamVjdC5jdXJZPXZvaWQgMCE9PWM/Yy5wYWdlWTphLmNsaWVudFksdm9pZChiLmRyYWdnaW5nPSEwKSl9LGIucHJvdG90eXBlLnVuZmlsdGVyU2xpZGVzPWIucHJvdG90eXBlLnNsaWNrVW5maWx0ZXI9ZnVuY3Rpb24oKXt2YXIgYT10aGlzO251bGwhPT1hLiRzbGlkZXNDYWNoZSYmKGEudW5sb2FkKCksYS4kc2xpZGVUcmFjay5jaGlsZHJlbih0aGlzLm9wdGlvbnMuc2xpZGUpLmRldGFjaCgpLGEuJHNsaWRlc0NhY2hlLmFwcGVuZFRvKGEuJHNsaWRlVHJhY2spLGEucmVpbml0KCkpfSxiLnByb3RvdHlwZS51bmxvYWQ9ZnVuY3Rpb24oKXt2YXIgYj10aGlzO2EoXCIuc2xpY2stY2xvbmVkXCIsYi4kc2xpZGVyKS5yZW1vdmUoKSxiLiRkb3RzJiZiLiRkb3RzLnJlbW92ZSgpLGIuJHByZXZBcnJvdyYmYi5odG1sRXhwci50ZXN0KGIub3B0aW9ucy5wcmV2QXJyb3cpJiZiLiRwcmV2QXJyb3cucmVtb3ZlKCksYi4kbmV4dEFycm93JiZiLmh0bWxFeHByLnRlc3QoYi5vcHRpb25zLm5leHRBcnJvdykmJmIuJG5leHRBcnJvdy5yZW1vdmUoKSxiLiRzbGlkZXMucmVtb3ZlQ2xhc3MoXCJzbGljay1zbGlkZSBzbGljay1hY3RpdmUgc2xpY2stdmlzaWJsZSBzbGljay1jdXJyZW50XCIpLmF0dHIoXCJhcmlhLWhpZGRlblwiLFwidHJ1ZVwiKS5jc3MoXCJ3aWR0aFwiLFwiXCIpfSxiLnByb3RvdHlwZS51bnNsaWNrPWZ1bmN0aW9uKGEpe3ZhciBiPXRoaXM7Yi4kc2xpZGVyLnRyaWdnZXIoXCJ1bnNsaWNrXCIsW2IsYV0pLGIuZGVzdHJveSgpfSxiLnByb3RvdHlwZS51cGRhdGVBcnJvd3M9ZnVuY3Rpb24oKXt2YXIgYixhPXRoaXM7Yj1NYXRoLmZsb29yKGEub3B0aW9ucy5zbGlkZXNUb1Nob3cvMiksYS5vcHRpb25zLmFycm93cz09PSEwJiZhLnNsaWRlQ291bnQ+YS5vcHRpb25zLnNsaWRlc1RvU2hvdyYmIWEub3B0aW9ucy5pbmZpbml0ZSYmKGEuJHByZXZBcnJvdy5yZW1vdmVDbGFzcyhcInNsaWNrLWRpc2FibGVkXCIpLmF0dHIoXCJhcmlhLWRpc2FibGVkXCIsXCJmYWxzZVwiKSxhLiRuZXh0QXJyb3cucmVtb3ZlQ2xhc3MoXCJzbGljay1kaXNhYmxlZFwiKS5hdHRyKFwiYXJpYS1kaXNhYmxlZFwiLFwiZmFsc2VcIiksMD09PWEuY3VycmVudFNsaWRlPyhhLiRwcmV2QXJyb3cuYWRkQ2xhc3MoXCJzbGljay1kaXNhYmxlZFwiKS5hdHRyKFwiYXJpYS1kaXNhYmxlZFwiLFwidHJ1ZVwiKSxhLiRuZXh0QXJyb3cucmVtb3ZlQ2xhc3MoXCJzbGljay1kaXNhYmxlZFwiKS5hdHRyKFwiYXJpYS1kaXNhYmxlZFwiLFwiZmFsc2VcIikpOmEuY3VycmVudFNsaWRlPj1hLnNsaWRlQ291bnQtYS5vcHRpb25zLnNsaWRlc1RvU2hvdyYmYS5vcHRpb25zLmNlbnRlck1vZGU9PT0hMT8oYS4kbmV4dEFycm93LmFkZENsYXNzKFwic2xpY2stZGlzYWJsZWRcIikuYXR0cihcImFyaWEtZGlzYWJsZWRcIixcInRydWVcIiksYS4kcHJldkFycm93LnJlbW92ZUNsYXNzKFwic2xpY2stZGlzYWJsZWRcIikuYXR0cihcImFyaWEtZGlzYWJsZWRcIixcImZhbHNlXCIpKTphLmN1cnJlbnRTbGlkZT49YS5zbGlkZUNvdW50LTEmJmEub3B0aW9ucy5jZW50ZXJNb2RlPT09ITAmJihhLiRuZXh0QXJyb3cuYWRkQ2xhc3MoXCJzbGljay1kaXNhYmxlZFwiKS5hdHRyKFwiYXJpYS1kaXNhYmxlZFwiLFwidHJ1ZVwiKSxhLiRwcmV2QXJyb3cucmVtb3ZlQ2xhc3MoXCJzbGljay1kaXNhYmxlZFwiKS5hdHRyKFwiYXJpYS1kaXNhYmxlZFwiLFwiZmFsc2VcIikpKX0sYi5wcm90b3R5cGUudXBkYXRlRG90cz1mdW5jdGlvbigpe3ZhciBhPXRoaXM7bnVsbCE9PWEuJGRvdHMmJihhLiRkb3RzLmZpbmQoXCJsaVwiKS5yZW1vdmVDbGFzcyhcInNsaWNrLWFjdGl2ZVwiKS5hdHRyKFwiYXJpYS1oaWRkZW5cIixcInRydWVcIiksYS4kZG90cy5maW5kKFwibGlcIikuZXEoTWF0aC5mbG9vcihhLmN1cnJlbnRTbGlkZS9hLm9wdGlvbnMuc2xpZGVzVG9TY3JvbGwpKS5hZGRDbGFzcyhcInNsaWNrLWFjdGl2ZVwiKS5hdHRyKFwiYXJpYS1oaWRkZW5cIixcImZhbHNlXCIpKX0sYi5wcm90b3R5cGUudmlzaWJpbGl0eT1mdW5jdGlvbigpe3ZhciBhPXRoaXM7ZG9jdW1lbnRbYS5oaWRkZW5dPyhhLnBhdXNlZD0hMCxhLmF1dG9QbGF5Q2xlYXIoKSk6YS5vcHRpb25zLmF1dG9wbGF5PT09ITAmJihhLnBhdXNlZD0hMSxhLmF1dG9QbGF5KCkpfSxiLnByb3RvdHlwZS5pbml0QURBPWZ1bmN0aW9uKCl7dmFyIGI9dGhpcztiLiRzbGlkZXMuYWRkKGIuJHNsaWRlVHJhY2suZmluZChcIi5zbGljay1jbG9uZWRcIikpLmF0dHIoe1wiYXJpYS1oaWRkZW5cIjpcInRydWVcIix0YWJpbmRleDpcIi0xXCJ9KS5maW5kKFwiYSwgaW5wdXQsIGJ1dHRvbiwgc2VsZWN0XCIpLmF0dHIoe3RhYmluZGV4OlwiLTFcIn0pLGIuJHNsaWRlVHJhY2suYXR0cihcInJvbGVcIixcImxpc3Rib3hcIiksYi4kc2xpZGVzLm5vdChiLiRzbGlkZVRyYWNrLmZpbmQoXCIuc2xpY2stY2xvbmVkXCIpKS5lYWNoKGZ1bmN0aW9uKGMpe2EodGhpcykuYXR0cih7cm9sZTpcIm9wdGlvblwiLFwiYXJpYS1kZXNjcmliZWRieVwiOlwic2xpY2stc2xpZGVcIitiLmluc3RhbmNlVWlkK2N9KX0pLG51bGwhPT1iLiRkb3RzJiZiLiRkb3RzLmF0dHIoXCJyb2xlXCIsXCJ0YWJsaXN0XCIpLmZpbmQoXCJsaVwiKS5lYWNoKGZ1bmN0aW9uKGMpe2EodGhpcykuYXR0cih7cm9sZTpcInByZXNlbnRhdGlvblwiLFwiYXJpYS1zZWxlY3RlZFwiOlwiZmFsc2VcIixcImFyaWEtY29udHJvbHNcIjpcIm5hdmlnYXRpb25cIitiLmluc3RhbmNlVWlkK2MsaWQ6XCJzbGljay1zbGlkZVwiK2IuaW5zdGFuY2VVaWQrY30pfSkuZmlyc3QoKS5hdHRyKFwiYXJpYS1zZWxlY3RlZFwiLFwidHJ1ZVwiKS5lbmQoKS5maW5kKFwiYnV0dG9uXCIpLmF0dHIoXCJyb2xlXCIsXCJidXR0b25cIikuZW5kKCkuY2xvc2VzdChcImRpdlwiKS5hdHRyKFwicm9sZVwiLFwidG9vbGJhclwiKSxiLmFjdGl2YXRlQURBKCl9LGIucHJvdG90eXBlLmFjdGl2YXRlQURBPWZ1bmN0aW9uKCl7dmFyIGE9dGhpczthLiRzbGlkZVRyYWNrLmZpbmQoXCIuc2xpY2stYWN0aXZlXCIpLmF0dHIoe1wiYXJpYS1oaWRkZW5cIjpcImZhbHNlXCJ9KS5maW5kKFwiYSwgaW5wdXQsIGJ1dHRvbiwgc2VsZWN0XCIpLmF0dHIoe3RhYmluZGV4OlwiMFwifSl9LGIucHJvdG90eXBlLmZvY3VzSGFuZGxlcj1mdW5jdGlvbigpe3ZhciBiPXRoaXM7Yi4kc2xpZGVyLm9uKFwiZm9jdXMuc2xpY2sgYmx1ci5zbGlja1wiLFwiKlwiLGZ1bmN0aW9uKGMpe2Muc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7dmFyIGQ9YSh0aGlzKTtzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7Yi5pc1BsYXkmJihkLmlzKFwiOmZvY3VzXCIpPyhiLmF1dG9QbGF5Q2xlYXIoKSxiLnBhdXNlZD0hMCk6KGIucGF1c2VkPSExLGIuYXV0b1BsYXkoKSkpfSwwKX0pfSxhLmZuLnNsaWNrPWZ1bmN0aW9uKCl7dmFyIGYsZyxhPXRoaXMsYz1hcmd1bWVudHNbMF0sZD1BcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsMSksZT1hLmxlbmd0aDtmb3IoZj0wO2U+ZjtmKyspaWYoXCJvYmplY3RcIj09dHlwZW9mIGN8fFwidW5kZWZpbmVkXCI9PXR5cGVvZiBjP2FbZl0uc2xpY2s9bmV3IGIoYVtmXSxjKTpnPWFbZl0uc2xpY2tbY10uYXBwbHkoYVtmXS5zbGljayxkKSxcInVuZGVmaW5lZFwiIT10eXBlb2YgZylyZXR1cm4gZztyZXR1cm4gYX19KTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zY3JpcHRzL3ZlbmRvcnMvc2xpY2subWluLmpzIiwiKGZ1bmN0aW9uIGUodCxuLHIpe2Z1bmN0aW9uIHMobyx1KXtpZighbltvXSl7aWYoIXRbb10pe3ZhciBhPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7aWYoIXUmJmEpcmV0dXJuIGEobywhMCk7aWYoaSlyZXR1cm4gaShvLCEwKTt2YXIgZj1uZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK28rXCInXCIpO3Rocm93IGYuY29kZT1cIk1PRFVMRV9OT1RfRk9VTkRcIixmfXZhciBsPW5bb109e2V4cG9ydHM6e319O3Rbb11bMF0uY2FsbChsLmV4cG9ydHMsZnVuY3Rpb24oZSl7dmFyIG49dFtvXVsxXVtlXTtyZXR1cm4gcyhuP246ZSl9LGwsbC5leHBvcnRzLGUsdCxuLHIpfXJldHVybiBuW29dLmV4cG9ydHN9dmFyIGk9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtmb3IodmFyIG89MDtvPHIubGVuZ3RoO28rKylzKHJbb10pO3JldHVybiBzfSkoezE6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xyXG4oZnVuY3Rpb24gKGdsb2JhbCl7XHJcblxyXG52YXIgUmVzaXplU2Vuc29yID0gcmVxdWlyZSgnY3NzLWVsZW1lbnQtcXVlcmllcy9zcmMvUmVzaXplU2Vuc29yJylcclxudmFyIFJlc2l6ZVNlbnNvciA9IHJlcXVpcmUoJ2Nzcy1lbGVtZW50LXF1ZXJpZXMvc3JjL1Jlc2l6ZVNlbnNvcicpXHJcbnZhciBQcyA9IHJlcXVpcmUoJ3BlcmZlY3Qtc2Nyb2xsYmFyJylcclxudmFyIGtvID0gKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3dbJ2tvJ10gOiB0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsWydrbyddIDogbnVsbClcclxuXHJcbmZ1bmN0aW9uIGdldE9wdHMoYWNjKSB7XHJcbiAgICB2YXIgb3B0cyA9IGtvLnVud3JhcChhY2MoKSlcclxuICAgIGlmIChvcHRzLnggPT09IHVuZGVmaW5lZCkgb3B0cy54ID0gdHJ1ZVxyXG4gICAgaWYgKG9wdHMueSA9PT0gdW5kZWZpbmVkKSBvcHRzLnkgPSB0cnVlXHJcbiAgICByZXR1cm4gb3B0c1xyXG59XHJcblxyXG5mdW5jdGlvbiBwc09wdHMob3B0cykge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBzdXBwcmVzc1Njcm9sbFg6ICFvcHRzLngsXHJcbiAgICAgICAgc3VwcHJlc3NTY3JvbGxZOiAhb3B0cy55LFxyXG4gICAgfVxyXG59XHJcblxyXG52YXIgc2Nyb2xsQmluZGluZyA9IHtcclxuICAgIGluaXQ6IGZ1bmN0aW9uIChlbGVtZW50LCB2YWxBY2MsIGJpbmRpbmdzLCB2bSwgY3R4KSB7XHJcbiAgICAgICAgdmFyIG9wdHMgPSBnZXRPcHRzKHZhbEFjYylcclxuICAgICAgICBQcy5pbml0aWFsaXplKGVsZW1lbnQsIHBzT3B0cyhvcHRzKSlcclxuICAgICAgICB2YXIgc2Vuc29yID0gbmV3IFJlc2l6ZVNlbnNvcihlbGVtZW50LCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIFBzLnVwZGF0ZShlbGVtZW50KVxyXG4gICAgICAgIH0pXHJcbiAgICAgICAga28udXRpbHMuZG9tTm9kZURpc3Bvc2FsLmFkZERpc3Bvc2VDYWxsYmFjayhlbGVtZW50LCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHNlbnNvci5kZXRhY2goKVxyXG4gICAgICAgICAgICBQcy5kZXN0cm95KGVsZW1lbnQpXHJcbiAgICAgICAgfSlcclxuICAgIH0sXHJcbiAgICB1cGRhdGU6IGZ1bmN0aW9uIChlbGVtZW50LCB2YWxBY2MsIGJpbmRpbmdzLCB2bSwgY3R4KSB7XHJcbiAgICAgICAgdmFyIG9wdHMgPSBnZXRPcHRzKHZhbEFjYylcclxuICAgICAgICBpZiAoY3R4Ll9maXJzdFVwZGF0ZUNvbXBsZXRlKSB7XHJcbiAgICAgICAgICAgIFBzLmRlc3Ryb3koZWxlbWVudClcclxuICAgICAgICAgICAga28uYmluZGluZ0hhbmRsZXJzLnNjcm9sbC5pbml0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIE9iamVjdC5hc3NpZ24oZWxlbWVudC5zdHlsZSwge1xyXG4gICAgICAgICAgICBvdmVyZmxvd1g6IG9wdHMueCA/ICdzY3JvbGwnIDogJ2hpZGRlbicsXHJcbiAgICAgICAgICAgIG92ZXJmbG93WTogb3B0cy55ID8gJ3Njcm9sbCcgOiAnaGlkZGVuJyxcclxuICAgICAgICB9KVxyXG4gICAgICAgIGN0eC5fZmlyc3RVcGRhdGVDb21wbGV0ZSA9IHRydWVcclxuICAgIH0sXHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0ga28uYmluZGluZ0hhbmRsZXJzLnNjcm9sbCA9IHNjcm9sbEJpbmRpbmdcclxuXHJcbn0pLmNhbGwodGhpcyx0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9KVxyXG59LHtcImNzcy1lbGVtZW50LXF1ZXJpZXMvc3JjL1Jlc2l6ZVNlbnNvclwiOjIsXCJwZXJmZWN0LXNjcm9sbGJhclwiOjN9XSwyOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcclxuLyoqXHJcbiAqIENvcHlyaWdodCBNYXJjIEouIFNjaG1pZHQuIFNlZSB0aGUgTElDRU5TRSBmaWxlIGF0IHRoZSB0b3AtbGV2ZWxcclxuICogZGlyZWN0b3J5IG9mIHRoaXMgZGlzdHJpYnV0aW9uIGFuZCBhdFxyXG4gKiBodHRwczovL2dpdGh1Yi5jb20vbWFyY2ovY3NzLWVsZW1lbnQtcXVlcmllcy9ibG9iL21hc3Rlci9MSUNFTlNFLlxyXG4gKi9cclxuO1xyXG4oZnVuY3Rpb24oKSB7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDbGFzcyBmb3IgZGltZW5zaW9uIGNoYW5nZSBkZXRlY3Rpb24uXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtFbGVtZW50fEVsZW1lbnRbXXxFbGVtZW50c3xqUXVlcnl9IGVsZW1lbnRcclxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXHJcbiAgICAgKlxyXG4gICAgICogQGNvbnN0cnVjdG9yXHJcbiAgICAgKi9cclxuICAgIHZhciBSZXNpemVTZW5zb3IgPSBmdW5jdGlvbihlbGVtZW50LCBjYWxsYmFjaykge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQGNvbnN0cnVjdG9yXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZnVuY3Rpb24gRXZlbnRRdWV1ZSgpIHtcclxuICAgICAgICAgICAgdGhpcy5xID0gW107XHJcbiAgICAgICAgICAgIHRoaXMuYWRkID0gZnVuY3Rpb24oZXYpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMucS5wdXNoKGV2KTtcclxuICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgIHZhciBpLCBqO1xyXG4gICAgICAgICAgICB0aGlzLmNhbGwgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgIGZvciAoaSA9IDAsIGogPSB0aGlzLnEubGVuZ3RoOyBpIDwgajsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5xW2ldLmNhbGwoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnRcclxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gICAgICBwcm9wXHJcbiAgICAgICAgICogQHJldHVybnMge1N0cmluZ3xOdW1iZXJ9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZnVuY3Rpb24gZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50LCBwcm9wKSB7XHJcbiAgICAgICAgICAgIGlmIChlbGVtZW50LmN1cnJlbnRTdHlsZSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGVsZW1lbnQuY3VycmVudFN0eWxlW3Byb3BdO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWxlbWVudCwgbnVsbCkuZ2V0UHJvcGVydHlWYWx1ZShwcm9wKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBlbGVtZW50LnN0eWxlW3Byb3BdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnRcclxuICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSAgICByZXNpemVkXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZnVuY3Rpb24gYXR0YWNoUmVzaXplRXZlbnQoZWxlbWVudCwgcmVzaXplZCkge1xyXG4gICAgICAgICAgICBpZiAoIWVsZW1lbnQucmVzaXplZEF0dGFjaGVkKSB7XHJcbiAgICAgICAgICAgICAgICBlbGVtZW50LnJlc2l6ZWRBdHRhY2hlZCA9IG5ldyBFdmVudFF1ZXVlKCk7XHJcbiAgICAgICAgICAgICAgICBlbGVtZW50LnJlc2l6ZWRBdHRhY2hlZC5hZGQocmVzaXplZCk7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZWxlbWVudC5yZXNpemVkQXR0YWNoZWQpIHtcclxuICAgICAgICAgICAgICAgIGVsZW1lbnQucmVzaXplZEF0dGFjaGVkLmFkZChyZXNpemVkKTtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgZWxlbWVudC5yZXNpemVTZW5zb3IgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcclxuICAgICAgICAgICAgZWxlbWVudC5yZXNpemVTZW5zb3IuY2xhc3NOYW1lID0gJ3Jlc2l6ZS1zZW5zb3InO1xyXG4gICAgICAgICAgICB2YXIgc3R5bGUgPSAncG9zaXRpb246IGFic29sdXRlOyBsZWZ0OiAwOyB0b3A6IDA7IHJpZ2h0OiAwOyBib3R0b206IDA7IG92ZXJmbG93OiBoaWRkZW47IHotaW5kZXg6IC0xOyB2aXNpYmlsaXR5OiBoaWRkZW47JztcclxuICAgICAgICAgICAgdmFyIHN0eWxlQ2hpbGQgPSAncG9zaXRpb246IGFic29sdXRlOyBsZWZ0OiAwOyB0b3A6IDA7IHRyYW5zaXRpb246IDBzOyc7XHJcblxyXG4gICAgICAgICAgICBlbGVtZW50LnJlc2l6ZVNlbnNvci5zdHlsZS5jc3NUZXh0ID0gc3R5bGU7XHJcbiAgICAgICAgICAgIGVsZW1lbnQucmVzaXplU2Vuc29yLmlubmVySFRNTCA9XHJcbiAgICAgICAgICAgICAgICAnPGRpdiBjbGFzcz1cInJlc2l6ZS1zZW5zb3ItZXhwYW5kXCIgc3R5bGU9XCInICsgc3R5bGUgKyAnXCI+JyArXHJcbiAgICAgICAgICAgICAgICAgICAgJzxkaXYgc3R5bGU9XCInICsgc3R5bGVDaGlsZCArICdcIj48L2Rpdj4nICtcclxuICAgICAgICAgICAgICAgICc8L2Rpdj4nICtcclxuICAgICAgICAgICAgICAgICc8ZGl2IGNsYXNzPVwicmVzaXplLXNlbnNvci1zaHJpbmtcIiBzdHlsZT1cIicgKyBzdHlsZSArICdcIj4nICtcclxuICAgICAgICAgICAgICAgICAgICAnPGRpdiBzdHlsZT1cIicgKyBzdHlsZUNoaWxkICsgJyB3aWR0aDogMjAwJTsgaGVpZ2h0OiAyMDAlXCI+PC9kaXY+JyArXHJcbiAgICAgICAgICAgICAgICAnPC9kaXY+JztcclxuICAgICAgICAgICAgZWxlbWVudC5hcHBlbmRDaGlsZChlbGVtZW50LnJlc2l6ZVNlbnNvcik7XHJcblxyXG4gICAgICAgICAgICBpZiAoIXtmaXhlZDogMSwgYWJzb2x1dGU6IDF9W2dldENvbXB1dGVkU3R5bGUoZWxlbWVudCwgJ3Bvc2l0aW9uJyldKSB7XHJcbiAgICAgICAgICAgICAgICBlbGVtZW50LnN0eWxlLnBvc2l0aW9uID0gJ3JlbGF0aXZlJztcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdmFyIGV4cGFuZCA9IGVsZW1lbnQucmVzaXplU2Vuc29yLmNoaWxkTm9kZXNbMF07XHJcbiAgICAgICAgICAgIHZhciBleHBhbmRDaGlsZCA9IGV4cGFuZC5jaGlsZE5vZGVzWzBdO1xyXG4gICAgICAgICAgICB2YXIgc2hyaW5rID0gZWxlbWVudC5yZXNpemVTZW5zb3IuY2hpbGROb2Rlc1sxXTtcclxuICAgICAgICAgICAgdmFyIHNocmlua0NoaWxkID0gc2hyaW5rLmNoaWxkTm9kZXNbMF07XHJcblxyXG4gICAgICAgICAgICB2YXIgbGFzdFdpZHRoLCBsYXN0SGVpZ2h0O1xyXG5cclxuICAgICAgICAgICAgdmFyIHJlc2V0ID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICBleHBhbmRDaGlsZC5zdHlsZS53aWR0aCA9IGV4cGFuZC5vZmZzZXRXaWR0aCArIDEwICsgJ3B4JztcclxuICAgICAgICAgICAgICAgIGV4cGFuZENoaWxkLnN0eWxlLmhlaWdodCA9IGV4cGFuZC5vZmZzZXRIZWlnaHQgKyAxMCArICdweCc7XHJcbiAgICAgICAgICAgICAgICBleHBhbmQuc2Nyb2xsTGVmdCA9IGV4cGFuZC5zY3JvbGxXaWR0aDtcclxuICAgICAgICAgICAgICAgIGV4cGFuZC5zY3JvbGxUb3AgPSBleHBhbmQuc2Nyb2xsSGVpZ2h0O1xyXG4gICAgICAgICAgICAgICAgc2hyaW5rLnNjcm9sbExlZnQgPSBzaHJpbmsuc2Nyb2xsV2lkdGg7XHJcbiAgICAgICAgICAgICAgICBzaHJpbmsuc2Nyb2xsVG9wID0gc2hyaW5rLnNjcm9sbEhlaWdodDtcclxuICAgICAgICAgICAgICAgIGxhc3RXaWR0aCA9IGVsZW1lbnQub2Zmc2V0V2lkdGg7XHJcbiAgICAgICAgICAgICAgICBsYXN0SGVpZ2h0ID0gZWxlbWVudC5vZmZzZXRIZWlnaHQ7XHJcbiAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICByZXNldCgpO1xyXG5cclxuICAgICAgICAgICAgdmFyIGNoYW5nZWQgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgIGlmIChlbGVtZW50LnJlc2l6ZWRBdHRhY2hlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnQucmVzaXplZEF0dGFjaGVkLmNhbGwoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgIHZhciBhZGRFdmVudCA9IGZ1bmN0aW9uKGVsLCBuYW1lLCBjYikge1xyXG4gICAgICAgICAgICAgICAgaWYgKGVsLmF0dGFjaEV2ZW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZWwuYXR0YWNoRXZlbnQoJ29uJyArIG5hbWUsIGNiKTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcihuYW1lLCBjYik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICB2YXIgb25TY3JvbGwgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICBpZiAoZWxlbWVudC5vZmZzZXRXaWR0aCAhPSBsYXN0V2lkdGggfHwgZWxlbWVudC5vZmZzZXRIZWlnaHQgIT0gbGFzdEhlaWdodCkge1xyXG4gICAgICAgICAgICAgICAgICBjaGFuZ2VkKCk7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIHJlc2V0KCk7XHJcbiAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICBhZGRFdmVudChleHBhbmQsICdzY3JvbGwnLCBvblNjcm9sbCk7XHJcbiAgICAgICAgICAgIGFkZEV2ZW50KHNocmluaywgJ3Njcm9sbCcsIG9uU2Nyb2xsKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciBlbGVtZW50VHlwZSA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChlbGVtZW50KTtcclxuICAgICAgICB2YXIgaXNDb2xsZWN0aW9uVHlwZWQgPSAoJ1tvYmplY3QgQXJyYXldJyA9PT0gZWxlbWVudFR5cGVcclxuICAgICAgICAgICAgfHwgKCdbb2JqZWN0IE5vZGVMaXN0XScgPT09IGVsZW1lbnRUeXBlKVxyXG4gICAgICAgICAgICB8fCAoJ1tvYmplY3QgSFRNTENvbGxlY3Rpb25dJyA9PT0gZWxlbWVudFR5cGUpXHJcbiAgICAgICAgICAgIHx8ICgndW5kZWZpbmVkJyAhPT0gdHlwZW9mIGpRdWVyeSAmJiBlbGVtZW50IGluc3RhbmNlb2YgalF1ZXJ5KSAvL2pxdWVyeVxyXG4gICAgICAgICAgICB8fCAoJ3VuZGVmaW5lZCcgIT09IHR5cGVvZiBFbGVtZW50cyAmJiBlbGVtZW50IGluc3RhbmNlb2YgRWxlbWVudHMpIC8vbW9vdG9vbHNcclxuICAgICAgICApO1xyXG5cclxuICAgICAgICBpZiAoaXNDb2xsZWN0aW9uVHlwZWQpIHtcclxuICAgICAgICAgICAgdmFyIGkgPSAwLCBqID0gZWxlbWVudC5sZW5ndGg7XHJcbiAgICAgICAgICAgIGZvciAoOyBpIDwgajsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBhdHRhY2hSZXNpemVFdmVudChlbGVtZW50W2ldLCBjYWxsYmFjayk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBhdHRhY2hSZXNpemVFdmVudChlbGVtZW50LCBjYWxsYmFjayk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLmRldGFjaCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICBpZiAoaXNDb2xsZWN0aW9uVHlwZWQpIHtcclxuICAgICAgICAgICAgICAgIHZhciBpID0gMCwgaiA9IGVsZW1lbnQubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgZm9yICg7IGkgPCBqOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICBSZXNpemVTZW5zb3IuZGV0YWNoKGVsZW1lbnRbaV0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgUmVzaXplU2Vuc29yLmRldGFjaChlbGVtZW50KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICB9O1xyXG5cclxuICAgIFJlc2l6ZVNlbnNvci5kZXRhY2ggPSBmdW5jdGlvbihlbGVtZW50KSB7XHJcbiAgICAgICAgaWYgKGVsZW1lbnQucmVzaXplU2Vuc29yKSB7XHJcbiAgICAgICAgICAgIGVsZW1lbnQucmVtb3ZlQ2hpbGQoZWxlbWVudC5yZXNpemVTZW5zb3IpO1xyXG4gICAgICAgICAgICBkZWxldGUgZWxlbWVudC5yZXNpemVTZW5zb3I7XHJcbiAgICAgICAgICAgIGRlbGV0ZSBlbGVtZW50LnJlc2l6ZWRBdHRhY2hlZDtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIC8vIG1ha2UgYXZhaWxhYmxlIHRvIGNvbW1vbiBtb2R1bGUgbG9hZGVyXHJcbiAgICBpZiAodHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIG1vZHVsZS5leHBvcnRzICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgIG1vZHVsZS5leHBvcnRzID0gUmVzaXplU2Vuc29yO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgd2luZG93LlJlc2l6ZVNlbnNvciA9IFJlc2l6ZVNlbnNvcjtcclxuICAgIH1cclxuXHJcbn0pKCk7XHJcblxyXG59LHt9XSwzOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL3NyYy9qcy9tYWluJyk7XHJcblxyXG59LHtcIi4vc3JjL2pzL21haW5cIjo5fV0sNDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XHJcbid1c2Ugc3RyaWN0JztcclxuXHJcbmZ1bmN0aW9uIG9sZEFkZChlbGVtZW50LCBjbGFzc05hbWUpIHtcclxuICB2YXIgY2xhc3NlcyA9IGVsZW1lbnQuY2xhc3NOYW1lLnNwbGl0KCcgJyk7XHJcbiAgaWYgKGNsYXNzZXMuaW5kZXhPZihjbGFzc05hbWUpIDwgMCkge1xyXG4gICAgY2xhc3Nlcy5wdXNoKGNsYXNzTmFtZSk7XHJcbiAgfVxyXG4gIGVsZW1lbnQuY2xhc3NOYW1lID0gY2xhc3Nlcy5qb2luKCcgJyk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIG9sZFJlbW92ZShlbGVtZW50LCBjbGFzc05hbWUpIHtcclxuICB2YXIgY2xhc3NlcyA9IGVsZW1lbnQuY2xhc3NOYW1lLnNwbGl0KCcgJyk7XHJcbiAgdmFyIGlkeCA9IGNsYXNzZXMuaW5kZXhPZihjbGFzc05hbWUpO1xyXG4gIGlmIChpZHggPj0gMCkge1xyXG4gICAgY2xhc3Nlcy5zcGxpY2UoaWR4LCAxKTtcclxuICB9XHJcbiAgZWxlbWVudC5jbGFzc05hbWUgPSBjbGFzc2VzLmpvaW4oJyAnKTtcclxufVxyXG5cclxuZXhwb3J0cy5hZGQgPSBmdW5jdGlvbiAoZWxlbWVudCwgY2xhc3NOYW1lKSB7XHJcbiAgaWYgKGVsZW1lbnQuY2xhc3NMaXN0KSB7XHJcbiAgICBlbGVtZW50LmNsYXNzTGlzdC5hZGQoY2xhc3NOYW1lKTtcclxuICB9IGVsc2Uge1xyXG4gICAgb2xkQWRkKGVsZW1lbnQsIGNsYXNzTmFtZSk7XHJcbiAgfVxyXG59O1xyXG5cclxuZXhwb3J0cy5yZW1vdmUgPSBmdW5jdGlvbiAoZWxlbWVudCwgY2xhc3NOYW1lKSB7XHJcbiAgaWYgKGVsZW1lbnQuY2xhc3NMaXN0KSB7XHJcbiAgICBlbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoY2xhc3NOYW1lKTtcclxuICB9IGVsc2Uge1xyXG4gICAgb2xkUmVtb3ZlKGVsZW1lbnQsIGNsYXNzTmFtZSk7XHJcbiAgfVxyXG59O1xyXG5cclxuZXhwb3J0cy5saXN0ID0gZnVuY3Rpb24gKGVsZW1lbnQpIHtcclxuICBpZiAoZWxlbWVudC5jbGFzc0xpc3QpIHtcclxuICAgIHJldHVybiBBcnJheS5wcm90b3R5cGUuc2xpY2UuYXBwbHkoZWxlbWVudC5jbGFzc0xpc3QpO1xyXG4gIH0gZWxzZSB7XHJcbiAgICByZXR1cm4gZWxlbWVudC5jbGFzc05hbWUuc3BsaXQoJyAnKTtcclxuICB9XHJcbn07XHJcblxyXG59LHt9XSw1OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyIERPTSA9IHt9O1xyXG5cclxuRE9NLmUgPSBmdW5jdGlvbiAodGFnTmFtZSwgY2xhc3NOYW1lKSB7XHJcbiAgdmFyIGVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZ05hbWUpO1xyXG4gIGVsZW1lbnQuY2xhc3NOYW1lID0gY2xhc3NOYW1lO1xyXG4gIHJldHVybiBlbGVtZW50O1xyXG59O1xyXG5cclxuRE9NLmFwcGVuZFRvID0gZnVuY3Rpb24gKGNoaWxkLCBwYXJlbnQpIHtcclxuICBwYXJlbnQuYXBwZW5kQ2hpbGQoY2hpbGQpO1xyXG4gIHJldHVybiBjaGlsZDtcclxufTtcclxuXHJcbmZ1bmN0aW9uIGNzc0dldChlbGVtZW50LCBzdHlsZU5hbWUpIHtcclxuICByZXR1cm4gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWxlbWVudClbc3R5bGVOYW1lXTtcclxufVxyXG5cclxuZnVuY3Rpb24gY3NzU2V0KGVsZW1lbnQsIHN0eWxlTmFtZSwgc3R5bGVWYWx1ZSkge1xyXG4gIGlmICh0eXBlb2Ygc3R5bGVWYWx1ZSA9PT0gJ251bWJlcicpIHtcclxuICAgIHN0eWxlVmFsdWUgPSBzdHlsZVZhbHVlLnRvU3RyaW5nKCkgKyAncHgnO1xyXG4gIH1cclxuICBlbGVtZW50LnN0eWxlW3N0eWxlTmFtZV0gPSBzdHlsZVZhbHVlO1xyXG4gIHJldHVybiBlbGVtZW50O1xyXG59XHJcblxyXG5mdW5jdGlvbiBjc3NNdWx0aVNldChlbGVtZW50LCBvYmopIHtcclxuICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XHJcbiAgICB2YXIgdmFsID0gb2JqW2tleV07XHJcbiAgICBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcclxuICAgICAgdmFsID0gdmFsLnRvU3RyaW5nKCkgKyAncHgnO1xyXG4gICAgfVxyXG4gICAgZWxlbWVudC5zdHlsZVtrZXldID0gdmFsO1xyXG4gIH1cclxuICByZXR1cm4gZWxlbWVudDtcclxufVxyXG5cclxuRE9NLmNzcyA9IGZ1bmN0aW9uIChlbGVtZW50LCBzdHlsZU5hbWVPck9iamVjdCwgc3R5bGVWYWx1ZSkge1xyXG4gIGlmICh0eXBlb2Ygc3R5bGVOYW1lT3JPYmplY3QgPT09ICdvYmplY3QnKSB7XHJcbiAgICAvLyBtdWx0aXBsZSBzZXQgd2l0aCBvYmplY3RcclxuICAgIHJldHVybiBjc3NNdWx0aVNldChlbGVtZW50LCBzdHlsZU5hbWVPck9iamVjdCk7XHJcbiAgfSBlbHNlIHtcclxuICAgIGlmICh0eXBlb2Ygc3R5bGVWYWx1ZSA9PT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgcmV0dXJuIGNzc0dldChlbGVtZW50LCBzdHlsZU5hbWVPck9iamVjdCk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICByZXR1cm4gY3NzU2V0KGVsZW1lbnQsIHN0eWxlTmFtZU9yT2JqZWN0LCBzdHlsZVZhbHVlKTtcclxuICAgIH1cclxuICB9XHJcbn07XHJcblxyXG5ET00ubWF0Y2hlcyA9IGZ1bmN0aW9uIChlbGVtZW50LCBxdWVyeSkge1xyXG4gIGlmICh0eXBlb2YgZWxlbWVudC5tYXRjaGVzICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgcmV0dXJuIGVsZW1lbnQubWF0Y2hlcyhxdWVyeSk7XHJcbiAgfSBlbHNlIHtcclxuICAgIGlmICh0eXBlb2YgZWxlbWVudC5tYXRjaGVzU2VsZWN0b3IgIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgIHJldHVybiBlbGVtZW50Lm1hdGNoZXNTZWxlY3RvcihxdWVyeSk7XHJcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBlbGVtZW50LndlYmtpdE1hdGNoZXNTZWxlY3RvciAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgcmV0dXJuIGVsZW1lbnQud2Via2l0TWF0Y2hlc1NlbGVjdG9yKHF1ZXJ5KTtcclxuICAgIH0gZWxzZSBpZiAodHlwZW9mIGVsZW1lbnQubW96TWF0Y2hlc1NlbGVjdG9yICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICByZXR1cm4gZWxlbWVudC5tb3pNYXRjaGVzU2VsZWN0b3IocXVlcnkpO1xyXG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZWxlbWVudC5tc01hdGNoZXNTZWxlY3RvciAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgcmV0dXJuIGVsZW1lbnQubXNNYXRjaGVzU2VsZWN0b3IocXVlcnkpO1xyXG4gICAgfVxyXG4gIH1cclxufTtcclxuXHJcbkRPTS5yZW1vdmUgPSBmdW5jdGlvbiAoZWxlbWVudCkge1xyXG4gIGlmICh0eXBlb2YgZWxlbWVudC5yZW1vdmUgIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICBlbGVtZW50LnJlbW92ZSgpO1xyXG4gIH0gZWxzZSB7XHJcbiAgICBpZiAoZWxlbWVudC5wYXJlbnROb2RlKSB7XHJcbiAgICAgIGVsZW1lbnQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChlbGVtZW50KTtcclxuICAgIH1cclxuICB9XHJcbn07XHJcblxyXG5ET00ucXVlcnlDaGlsZHJlbiA9IGZ1bmN0aW9uIChlbGVtZW50LCBzZWxlY3Rvcikge1xyXG4gIHJldHVybiBBcnJheS5wcm90b3R5cGUuZmlsdGVyLmNhbGwoZWxlbWVudC5jaGlsZE5vZGVzLCBmdW5jdGlvbiAoY2hpbGQpIHtcclxuICAgIHJldHVybiBET00ubWF0Y2hlcyhjaGlsZCwgc2VsZWN0b3IpO1xyXG4gIH0pO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBET007XHJcblxyXG59LHt9XSw2OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyIEV2ZW50RWxlbWVudCA9IGZ1bmN0aW9uIChlbGVtZW50KSB7XHJcbiAgdGhpcy5lbGVtZW50ID0gZWxlbWVudDtcclxuICB0aGlzLmV2ZW50cyA9IHt9O1xyXG59O1xyXG5cclxuRXZlbnRFbGVtZW50LnByb3RvdHlwZS5iaW5kID0gZnVuY3Rpb24gKGV2ZW50TmFtZSwgaGFuZGxlcikge1xyXG4gIGlmICh0eXBlb2YgdGhpcy5ldmVudHNbZXZlbnROYW1lXSA9PT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgIHRoaXMuZXZlbnRzW2V2ZW50TmFtZV0gPSBbXTtcclxuICB9XHJcbiAgdGhpcy5ldmVudHNbZXZlbnROYW1lXS5wdXNoKGhhbmRsZXIpO1xyXG4gIHRoaXMuZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKGV2ZW50TmFtZSwgaGFuZGxlciwgZmFsc2UpO1xyXG59O1xyXG5cclxuRXZlbnRFbGVtZW50LnByb3RvdHlwZS51bmJpbmQgPSBmdW5jdGlvbiAoZXZlbnROYW1lLCBoYW5kbGVyKSB7XHJcbiAgdmFyIGlzSGFuZGxlclByb3ZpZGVkID0gKHR5cGVvZiBoYW5kbGVyICE9PSAndW5kZWZpbmVkJyk7XHJcbiAgdGhpcy5ldmVudHNbZXZlbnROYW1lXSA9IHRoaXMuZXZlbnRzW2V2ZW50TmFtZV0uZmlsdGVyKGZ1bmN0aW9uIChoZGxyKSB7XHJcbiAgICBpZiAoaXNIYW5kbGVyUHJvdmlkZWQgJiYgaGRsciAhPT0gaGFuZGxlcikge1xyXG4gICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuICAgIHRoaXMuZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50TmFtZSwgaGRsciwgZmFsc2UpO1xyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG4gIH0sIHRoaXMpO1xyXG59O1xyXG5cclxuRXZlbnRFbGVtZW50LnByb3RvdHlwZS51bmJpbmRBbGwgPSBmdW5jdGlvbiAoKSB7XHJcbiAgZm9yICh2YXIgbmFtZSBpbiB0aGlzLmV2ZW50cykge1xyXG4gICAgdGhpcy51bmJpbmQobmFtZSk7XHJcbiAgfVxyXG59O1xyXG5cclxudmFyIEV2ZW50TWFuYWdlciA9IGZ1bmN0aW9uICgpIHtcclxuICB0aGlzLmV2ZW50RWxlbWVudHMgPSBbXTtcclxufTtcclxuXHJcbkV2ZW50TWFuYWdlci5wcm90b3R5cGUuZXZlbnRFbGVtZW50ID0gZnVuY3Rpb24gKGVsZW1lbnQpIHtcclxuICB2YXIgZWUgPSB0aGlzLmV2ZW50RWxlbWVudHMuZmlsdGVyKGZ1bmN0aW9uIChldmVudEVsZW1lbnQpIHtcclxuICAgIHJldHVybiBldmVudEVsZW1lbnQuZWxlbWVudCA9PT0gZWxlbWVudDtcclxuICB9KVswXTtcclxuICBpZiAodHlwZW9mIGVlID09PSAndW5kZWZpbmVkJykge1xyXG4gICAgZWUgPSBuZXcgRXZlbnRFbGVtZW50KGVsZW1lbnQpO1xyXG4gICAgdGhpcy5ldmVudEVsZW1lbnRzLnB1c2goZWUpO1xyXG4gIH1cclxuICByZXR1cm4gZWU7XHJcbn07XHJcblxyXG5FdmVudE1hbmFnZXIucHJvdG90eXBlLmJpbmQgPSBmdW5jdGlvbiAoZWxlbWVudCwgZXZlbnROYW1lLCBoYW5kbGVyKSB7XHJcbiAgdGhpcy5ldmVudEVsZW1lbnQoZWxlbWVudCkuYmluZChldmVudE5hbWUsIGhhbmRsZXIpO1xyXG59O1xyXG5cclxuRXZlbnRNYW5hZ2VyLnByb3RvdHlwZS51bmJpbmQgPSBmdW5jdGlvbiAoZWxlbWVudCwgZXZlbnROYW1lLCBoYW5kbGVyKSB7XHJcbiAgdGhpcy5ldmVudEVsZW1lbnQoZWxlbWVudCkudW5iaW5kKGV2ZW50TmFtZSwgaGFuZGxlcik7XHJcbn07XHJcblxyXG5FdmVudE1hbmFnZXIucHJvdG90eXBlLnVuYmluZEFsbCA9IGZ1bmN0aW9uICgpIHtcclxuICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuZXZlbnRFbGVtZW50cy5sZW5ndGg7IGkrKykge1xyXG4gICAgdGhpcy5ldmVudEVsZW1lbnRzW2ldLnVuYmluZEFsbCgpO1xyXG4gIH1cclxufTtcclxuXHJcbkV2ZW50TWFuYWdlci5wcm90b3R5cGUub25jZSA9IGZ1bmN0aW9uIChlbGVtZW50LCBldmVudE5hbWUsIGhhbmRsZXIpIHtcclxuICB2YXIgZWUgPSB0aGlzLmV2ZW50RWxlbWVudChlbGVtZW50KTtcclxuICB2YXIgb25jZUhhbmRsZXIgPSBmdW5jdGlvbiAoZSkge1xyXG4gICAgZWUudW5iaW5kKGV2ZW50TmFtZSwgb25jZUhhbmRsZXIpO1xyXG4gICAgaGFuZGxlcihlKTtcclxuICB9O1xyXG4gIGVlLmJpbmQoZXZlbnROYW1lLCBvbmNlSGFuZGxlcik7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEV2ZW50TWFuYWdlcjtcclxuXHJcbn0se31dLDc6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xyXG4ndXNlIHN0cmljdCc7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IChmdW5jdGlvbiAoKSB7XHJcbiAgZnVuY3Rpb24gczQoKSB7XHJcbiAgICByZXR1cm4gTWF0aC5mbG9vcigoMSArIE1hdGgucmFuZG9tKCkpICogMHgxMDAwMClcclxuICAgICAgICAgICAgICAgLnRvU3RyaW5nKDE2KVxyXG4gICAgICAgICAgICAgICAuc3Vic3RyaW5nKDEpO1xyXG4gIH1cclxuICByZXR1cm4gZnVuY3Rpb24gKCkge1xyXG4gICAgcmV0dXJuIHM0KCkgKyBzNCgpICsgJy0nICsgczQoKSArICctJyArIHM0KCkgKyAnLScgK1xyXG4gICAgICAgICAgIHM0KCkgKyAnLScgKyBzNCgpICsgczQoKSArIHM0KCk7XHJcbiAgfTtcclxufSkoKTtcclxuXHJcbn0se31dLDg6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xyXG4ndXNlIHN0cmljdCc7XHJcblxyXG52YXIgY2xzID0gcmVxdWlyZSgnLi9jbGFzcycpO1xyXG52YXIgZG9tID0gcmVxdWlyZSgnLi9kb20nKTtcclxuXHJcbnZhciB0b0ludCA9IGV4cG9ydHMudG9JbnQgPSBmdW5jdGlvbiAoeCkge1xyXG4gIHJldHVybiBwYXJzZUludCh4LCAxMCkgfHwgMDtcclxufTtcclxuXHJcbnZhciBjbG9uZSA9IGV4cG9ydHMuY2xvbmUgPSBmdW5jdGlvbiAob2JqKSB7XHJcbiAgaWYgKG9iaiA9PT0gbnVsbCkge1xyXG4gICAgcmV0dXJuIG51bGw7XHJcbiAgfSBlbHNlIGlmIChvYmouY29uc3RydWN0b3IgPT09IEFycmF5KSB7XHJcbiAgICByZXR1cm4gb2JqLm1hcChjbG9uZSk7XHJcbiAgfSBlbHNlIGlmICh0eXBlb2Ygb2JqID09PSAnb2JqZWN0Jykge1xyXG4gICAgdmFyIHJlc3VsdCA9IHt9O1xyXG4gICAgZm9yICh2YXIga2V5IGluIG9iaikge1xyXG4gICAgICByZXN1bHRba2V5XSA9IGNsb25lKG9ialtrZXldKTtcclxuICAgIH1cclxuICAgIHJldHVybiByZXN1bHQ7XHJcbiAgfSBlbHNlIHtcclxuICAgIHJldHVybiBvYmo7XHJcbiAgfVxyXG59O1xyXG5cclxuZXhwb3J0cy5leHRlbmQgPSBmdW5jdGlvbiAob3JpZ2luYWwsIHNvdXJjZSkge1xyXG4gIHZhciByZXN1bHQgPSBjbG9uZShvcmlnaW5hbCk7XHJcbiAgZm9yICh2YXIga2V5IGluIHNvdXJjZSkge1xyXG4gICAgcmVzdWx0W2tleV0gPSBjbG9uZShzb3VyY2Vba2V5XSk7XHJcbiAgfVxyXG4gIHJldHVybiByZXN1bHQ7XHJcbn07XHJcblxyXG5leHBvcnRzLmlzRWRpdGFibGUgPSBmdW5jdGlvbiAoZWwpIHtcclxuICByZXR1cm4gZG9tLm1hdGNoZXMoZWwsIFwiaW5wdXQsW2NvbnRlbnRlZGl0YWJsZV1cIikgfHxcclxuICAgICAgICAgZG9tLm1hdGNoZXMoZWwsIFwic2VsZWN0LFtjb250ZW50ZWRpdGFibGVdXCIpIHx8XHJcbiAgICAgICAgIGRvbS5tYXRjaGVzKGVsLCBcInRleHRhcmVhLFtjb250ZW50ZWRpdGFibGVdXCIpIHx8XHJcbiAgICAgICAgIGRvbS5tYXRjaGVzKGVsLCBcImJ1dHRvbixbY29udGVudGVkaXRhYmxlXVwiKTtcclxufTtcclxuXHJcbmV4cG9ydHMucmVtb3ZlUHNDbGFzc2VzID0gZnVuY3Rpb24gKGVsZW1lbnQpIHtcclxuICB2YXIgY2xzTGlzdCA9IGNscy5saXN0KGVsZW1lbnQpO1xyXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgY2xzTGlzdC5sZW5ndGg7IGkrKykge1xyXG4gICAgdmFyIGNsYXNzTmFtZSA9IGNsc0xpc3RbaV07XHJcbiAgICBpZiAoY2xhc3NOYW1lLmluZGV4T2YoJ3BzLScpID09PSAwKSB7XHJcbiAgICAgIGNscy5yZW1vdmUoZWxlbWVudCwgY2xhc3NOYW1lKTtcclxuICAgIH1cclxuICB9XHJcbn07XHJcblxyXG5leHBvcnRzLm91dGVyV2lkdGggPSBmdW5jdGlvbiAoZWxlbWVudCkge1xyXG4gIHJldHVybiB0b0ludChkb20uY3NzKGVsZW1lbnQsICd3aWR0aCcpKSArXHJcbiAgICAgICAgIHRvSW50KGRvbS5jc3MoZWxlbWVudCwgJ3BhZGRpbmdMZWZ0JykpICtcclxuICAgICAgICAgdG9JbnQoZG9tLmNzcyhlbGVtZW50LCAncGFkZGluZ1JpZ2h0JykpICtcclxuICAgICAgICAgdG9JbnQoZG9tLmNzcyhlbGVtZW50LCAnYm9yZGVyTGVmdFdpZHRoJykpICtcclxuICAgICAgICAgdG9JbnQoZG9tLmNzcyhlbGVtZW50LCAnYm9yZGVyUmlnaHRXaWR0aCcpKTtcclxufTtcclxuXHJcbmV4cG9ydHMuc3RhcnRTY3JvbGxpbmcgPSBmdW5jdGlvbiAoZWxlbWVudCwgYXhpcykge1xyXG4gIGNscy5hZGQoZWxlbWVudCwgJ3BzLWluLXNjcm9sbGluZycpO1xyXG4gIGlmICh0eXBlb2YgYXhpcyAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgIGNscy5hZGQoZWxlbWVudCwgJ3BzLScgKyBheGlzKTtcclxuICB9IGVsc2Uge1xyXG4gICAgY2xzLmFkZChlbGVtZW50LCAncHMteCcpO1xyXG4gICAgY2xzLmFkZChlbGVtZW50LCAncHMteScpO1xyXG4gIH1cclxufTtcclxuXHJcbmV4cG9ydHMuc3RvcFNjcm9sbGluZyA9IGZ1bmN0aW9uIChlbGVtZW50LCBheGlzKSB7XHJcbiAgY2xzLnJlbW92ZShlbGVtZW50LCAncHMtaW4tc2Nyb2xsaW5nJyk7XHJcbiAgaWYgKHR5cGVvZiBheGlzICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgY2xzLnJlbW92ZShlbGVtZW50LCAncHMtJyArIGF4aXMpO1xyXG4gIH0gZWxzZSB7XHJcbiAgICBjbHMucmVtb3ZlKGVsZW1lbnQsICdwcy14Jyk7XHJcbiAgICBjbHMucmVtb3ZlKGVsZW1lbnQsICdwcy15Jyk7XHJcbiAgfVxyXG59O1xyXG5cclxuZXhwb3J0cy5lbnYgPSB7XHJcbiAgaXNXZWJLaXQ6ICdXZWJraXRBcHBlYXJhbmNlJyBpbiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGUsXHJcbiAgc3VwcG9ydHNUb3VjaDogKCgnb250b3VjaHN0YXJ0JyBpbiB3aW5kb3cpIHx8IHdpbmRvdy5Eb2N1bWVudFRvdWNoICYmIGRvY3VtZW50IGluc3RhbmNlb2Ygd2luZG93LkRvY3VtZW50VG91Y2gpLFxyXG4gIHN1cHBvcnRzSWVQb2ludGVyOiB3aW5kb3cubmF2aWdhdG9yLm1zTWF4VG91Y2hQb2ludHMgIT09IG51bGxcclxufTtcclxuXHJcbn0se1wiLi9jbGFzc1wiOjQsXCIuL2RvbVwiOjV9XSw5OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyIGRlc3Ryb3kgPSByZXF1aXJlKCcuL3BsdWdpbi9kZXN0cm95Jyk7XHJcbnZhciBpbml0aWFsaXplID0gcmVxdWlyZSgnLi9wbHVnaW4vaW5pdGlhbGl6ZScpO1xyXG52YXIgdXBkYXRlID0gcmVxdWlyZSgnLi9wbHVnaW4vdXBkYXRlJyk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IHtcclxuICBpbml0aWFsaXplOiBpbml0aWFsaXplLFxyXG4gIHVwZGF0ZTogdXBkYXRlLFxyXG4gIGRlc3Ryb3k6IGRlc3Ryb3lcclxufTtcclxuXHJcbn0se1wiLi9wbHVnaW4vZGVzdHJveVwiOjExLFwiLi9wbHVnaW4vaW5pdGlhbGl6ZVwiOjE5LFwiLi9wbHVnaW4vdXBkYXRlXCI6MjN9XSwxMDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XHJcbid1c2Ugc3RyaWN0JztcclxuXHJcbm1vZHVsZS5leHBvcnRzID0ge1xyXG4gIGhhbmRsZXJzOiBbJ2NsaWNrLXJhaWwnLCAnZHJhZy1zY3JvbGxiYXInLCAna2V5Ym9hcmQnLCAnd2hlZWwnLCAndG91Y2gnXSxcclxuICBtYXhTY3JvbGxiYXJMZW5ndGg6IG51bGwsXHJcbiAgbWluU2Nyb2xsYmFyTGVuZ3RoOiBudWxsLFxyXG4gIHNjcm9sbFhNYXJnaW5PZmZzZXQ6IDAsXHJcbiAgc2Nyb2xsWU1hcmdpbk9mZnNldDogMCxcclxuICBzdG9wUHJvcGFnYXRpb25PbkNsaWNrOiB0cnVlLFxyXG4gIHN1cHByZXNzU2Nyb2xsWDogZmFsc2UsXHJcbiAgc3VwcHJlc3NTY3JvbGxZOiBmYWxzZSxcclxuICBzd2lwZVByb3BhZ2F0aW9uOiB0cnVlLFxyXG4gIHVzZUJvdGhXaGVlbEF4ZXM6IGZhbHNlLFxyXG4gIHdoZWVsUHJvcGFnYXRpb246IGZhbHNlLFxyXG4gIHdoZWVsU3BlZWQ6IDEsXHJcbiAgdGhlbWU6ICdkZWZhdWx0J1xyXG59O1xyXG5cclxufSx7fV0sMTE6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xyXG4ndXNlIHN0cmljdCc7XHJcblxyXG52YXIgXyA9IHJlcXVpcmUoJy4uL2xpYi9oZWxwZXInKTtcclxudmFyIGRvbSA9IHJlcXVpcmUoJy4uL2xpYi9kb20nKTtcclxudmFyIGluc3RhbmNlcyA9IHJlcXVpcmUoJy4vaW5zdGFuY2VzJyk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChlbGVtZW50KSB7XHJcbiAgdmFyIGkgPSBpbnN0YW5jZXMuZ2V0KGVsZW1lbnQpO1xyXG5cclxuICBpZiAoIWkpIHtcclxuICAgIHJldHVybjtcclxuICB9XHJcblxyXG4gIGkuZXZlbnQudW5iaW5kQWxsKCk7XHJcbiAgZG9tLnJlbW92ZShpLnNjcm9sbGJhclgpO1xyXG4gIGRvbS5yZW1vdmUoaS5zY3JvbGxiYXJZKTtcclxuICBkb20ucmVtb3ZlKGkuc2Nyb2xsYmFyWFJhaWwpO1xyXG4gIGRvbS5yZW1vdmUoaS5zY3JvbGxiYXJZUmFpbCk7XHJcbiAgXy5yZW1vdmVQc0NsYXNzZXMoZWxlbWVudCk7XHJcblxyXG4gIGluc3RhbmNlcy5yZW1vdmUoZWxlbWVudCk7XHJcbn07XHJcblxyXG59LHtcIi4uL2xpYi9kb21cIjo1LFwiLi4vbGliL2hlbHBlclwiOjgsXCIuL2luc3RhbmNlc1wiOjIwfV0sMTI6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xyXG4ndXNlIHN0cmljdCc7XHJcblxyXG52YXIgXyA9IHJlcXVpcmUoJy4uLy4uL2xpYi9oZWxwZXInKTtcclxudmFyIGluc3RhbmNlcyA9IHJlcXVpcmUoJy4uL2luc3RhbmNlcycpO1xyXG52YXIgdXBkYXRlR2VvbWV0cnkgPSByZXF1aXJlKCcuLi91cGRhdGUtZ2VvbWV0cnknKTtcclxudmFyIHVwZGF0ZVNjcm9sbCA9IHJlcXVpcmUoJy4uL3VwZGF0ZS1zY3JvbGwnKTtcclxuXHJcbmZ1bmN0aW9uIGJpbmRDbGlja1JhaWxIYW5kbGVyKGVsZW1lbnQsIGkpIHtcclxuICBmdW5jdGlvbiBwYWdlT2Zmc2V0KGVsKSB7XHJcbiAgICByZXR1cm4gZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XHJcbiAgfVxyXG4gIHZhciBzdG9wUHJvcGFnYXRpb24gPSBmdW5jdGlvbiAoZSkgeyBlLnN0b3BQcm9wYWdhdGlvbigpOyB9O1xyXG5cclxuICBpZiAoaS5zZXR0aW5ncy5zdG9wUHJvcGFnYXRpb25PbkNsaWNrKSB7XHJcbiAgICBpLmV2ZW50LmJpbmQoaS5zY3JvbGxiYXJZLCAnY2xpY2snLCBzdG9wUHJvcGFnYXRpb24pO1xyXG4gIH1cclxuICBpLmV2ZW50LmJpbmQoaS5zY3JvbGxiYXJZUmFpbCwgJ2NsaWNrJywgZnVuY3Rpb24gKGUpIHtcclxuICAgIHZhciBoYWxmT2ZTY3JvbGxiYXJMZW5ndGggPSBfLnRvSW50KGkuc2Nyb2xsYmFyWUhlaWdodCAvIDIpO1xyXG4gICAgdmFyIHBvc2l0aW9uVG9wID0gaS5yYWlsWVJhdGlvICogKGUucGFnZVkgLSB3aW5kb3cucGFnZVlPZmZzZXQgLSBwYWdlT2Zmc2V0KGkuc2Nyb2xsYmFyWVJhaWwpLnRvcCAtIGhhbGZPZlNjcm9sbGJhckxlbmd0aCk7XHJcbiAgICB2YXIgbWF4UG9zaXRpb25Ub3AgPSBpLnJhaWxZUmF0aW8gKiAoaS5yYWlsWUhlaWdodCAtIGkuc2Nyb2xsYmFyWUhlaWdodCk7XHJcbiAgICB2YXIgcG9zaXRpb25SYXRpbyA9IHBvc2l0aW9uVG9wIC8gbWF4UG9zaXRpb25Ub3A7XHJcblxyXG4gICAgaWYgKHBvc2l0aW9uUmF0aW8gPCAwKSB7XHJcbiAgICAgIHBvc2l0aW9uUmF0aW8gPSAwO1xyXG4gICAgfSBlbHNlIGlmIChwb3NpdGlvblJhdGlvID4gMSkge1xyXG4gICAgICBwb3NpdGlvblJhdGlvID0gMTtcclxuICAgIH1cclxuXHJcbiAgICB1cGRhdGVTY3JvbGwoZWxlbWVudCwgJ3RvcCcsIChpLmNvbnRlbnRIZWlnaHQgLSBpLmNvbnRhaW5lckhlaWdodCkgKiBwb3NpdGlvblJhdGlvKTtcclxuICAgIHVwZGF0ZUdlb21ldHJ5KGVsZW1lbnQpO1xyXG5cclxuICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XHJcbiAgfSk7XHJcblxyXG4gIGlmIChpLnNldHRpbmdzLnN0b3BQcm9wYWdhdGlvbk9uQ2xpY2spIHtcclxuICAgIGkuZXZlbnQuYmluZChpLnNjcm9sbGJhclgsICdjbGljaycsIHN0b3BQcm9wYWdhdGlvbik7XHJcbiAgfVxyXG4gIGkuZXZlbnQuYmluZChpLnNjcm9sbGJhclhSYWlsLCAnY2xpY2snLCBmdW5jdGlvbiAoZSkge1xyXG4gICAgdmFyIGhhbGZPZlNjcm9sbGJhckxlbmd0aCA9IF8udG9JbnQoaS5zY3JvbGxiYXJYV2lkdGggLyAyKTtcclxuICAgIHZhciBwb3NpdGlvbkxlZnQgPSBpLnJhaWxYUmF0aW8gKiAoZS5wYWdlWCAtIHdpbmRvdy5wYWdlWE9mZnNldCAtIHBhZ2VPZmZzZXQoaS5zY3JvbGxiYXJYUmFpbCkubGVmdCAtIGhhbGZPZlNjcm9sbGJhckxlbmd0aCk7XHJcbiAgICB2YXIgbWF4UG9zaXRpb25MZWZ0ID0gaS5yYWlsWFJhdGlvICogKGkucmFpbFhXaWR0aCAtIGkuc2Nyb2xsYmFyWFdpZHRoKTtcclxuICAgIHZhciBwb3NpdGlvblJhdGlvID0gcG9zaXRpb25MZWZ0IC8gbWF4UG9zaXRpb25MZWZ0O1xyXG5cclxuICAgIGlmIChwb3NpdGlvblJhdGlvIDwgMCkge1xyXG4gICAgICBwb3NpdGlvblJhdGlvID0gMDtcclxuICAgIH0gZWxzZSBpZiAocG9zaXRpb25SYXRpbyA+IDEpIHtcclxuICAgICAgcG9zaXRpb25SYXRpbyA9IDE7XHJcbiAgICB9XHJcblxyXG4gICAgdXBkYXRlU2Nyb2xsKGVsZW1lbnQsICdsZWZ0JywgKChpLmNvbnRlbnRXaWR0aCAtIGkuY29udGFpbmVyV2lkdGgpICogcG9zaXRpb25SYXRpbykgLSBpLm5lZ2F0aXZlU2Nyb2xsQWRqdXN0bWVudCk7XHJcbiAgICB1cGRhdGVHZW9tZXRyeShlbGVtZW50KTtcclxuXHJcbiAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xyXG4gIH0pO1xyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChlbGVtZW50KSB7XHJcbiAgdmFyIGkgPSBpbnN0YW5jZXMuZ2V0KGVsZW1lbnQpO1xyXG4gIGJpbmRDbGlja1JhaWxIYW5kbGVyKGVsZW1lbnQsIGkpO1xyXG59O1xyXG5cclxufSx7XCIuLi8uLi9saWIvaGVscGVyXCI6OCxcIi4uL2luc3RhbmNlc1wiOjIwLFwiLi4vdXBkYXRlLWdlb21ldHJ5XCI6MjEsXCIuLi91cGRhdGUtc2Nyb2xsXCI6MjJ9XSwxMzpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XHJcbid1c2Ugc3RyaWN0JztcclxuXHJcbnZhciBfID0gcmVxdWlyZSgnLi4vLi4vbGliL2hlbHBlcicpO1xyXG52YXIgZG9tID0gcmVxdWlyZSgnLi4vLi4vbGliL2RvbScpO1xyXG52YXIgaW5zdGFuY2VzID0gcmVxdWlyZSgnLi4vaW5zdGFuY2VzJyk7XHJcbnZhciB1cGRhdGVHZW9tZXRyeSA9IHJlcXVpcmUoJy4uL3VwZGF0ZS1nZW9tZXRyeScpO1xyXG52YXIgdXBkYXRlU2Nyb2xsID0gcmVxdWlyZSgnLi4vdXBkYXRlLXNjcm9sbCcpO1xyXG5cclxuZnVuY3Rpb24gYmluZE1vdXNlU2Nyb2xsWEhhbmRsZXIoZWxlbWVudCwgaSkge1xyXG4gIHZhciBjdXJyZW50TGVmdCA9IG51bGw7XHJcbiAgdmFyIGN1cnJlbnRQYWdlWCA9IG51bGw7XHJcblxyXG4gIGZ1bmN0aW9uIHVwZGF0ZVNjcm9sbExlZnQoZGVsdGFYKSB7XHJcbiAgICB2YXIgbmV3TGVmdCA9IGN1cnJlbnRMZWZ0ICsgKGRlbHRhWCAqIGkucmFpbFhSYXRpbyk7XHJcbiAgICB2YXIgbWF4TGVmdCA9IE1hdGgubWF4KDAsIGkuc2Nyb2xsYmFyWFJhaWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkubGVmdCkgKyAoaS5yYWlsWFJhdGlvICogKGkucmFpbFhXaWR0aCAtIGkuc2Nyb2xsYmFyWFdpZHRoKSk7XHJcblxyXG4gICAgaWYgKG5ld0xlZnQgPCAwKSB7XHJcbiAgICAgIGkuc2Nyb2xsYmFyWExlZnQgPSAwO1xyXG4gICAgfSBlbHNlIGlmIChuZXdMZWZ0ID4gbWF4TGVmdCkge1xyXG4gICAgICBpLnNjcm9sbGJhclhMZWZ0ID0gbWF4TGVmdDtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGkuc2Nyb2xsYmFyWExlZnQgPSBuZXdMZWZ0O1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBzY3JvbGxMZWZ0ID0gXy50b0ludChpLnNjcm9sbGJhclhMZWZ0ICogKGkuY29udGVudFdpZHRoIC0gaS5jb250YWluZXJXaWR0aCkgLyAoaS5jb250YWluZXJXaWR0aCAtIChpLnJhaWxYUmF0aW8gKiBpLnNjcm9sbGJhclhXaWR0aCkpKSAtIGkubmVnYXRpdmVTY3JvbGxBZGp1c3RtZW50O1xyXG4gICAgdXBkYXRlU2Nyb2xsKGVsZW1lbnQsICdsZWZ0Jywgc2Nyb2xsTGVmdCk7XHJcbiAgfVxyXG5cclxuICB2YXIgbW91c2VNb3ZlSGFuZGxlciA9IGZ1bmN0aW9uIChlKSB7XHJcbiAgICB1cGRhdGVTY3JvbGxMZWZ0KGUucGFnZVggLSBjdXJyZW50UGFnZVgpO1xyXG4gICAgdXBkYXRlR2VvbWV0cnkoZWxlbWVudCk7XHJcbiAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xyXG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gIH07XHJcblxyXG4gIHZhciBtb3VzZVVwSGFuZGxlciA9IGZ1bmN0aW9uICgpIHtcclxuICAgIF8uc3RvcFNjcm9sbGluZyhlbGVtZW50LCAneCcpO1xyXG4gICAgaS5ldmVudC51bmJpbmQoaS5vd25lckRvY3VtZW50LCAnbW91c2Vtb3ZlJywgbW91c2VNb3ZlSGFuZGxlcik7XHJcbiAgfTtcclxuXHJcbiAgaS5ldmVudC5iaW5kKGkuc2Nyb2xsYmFyWCwgJ21vdXNlZG93bicsIGZ1bmN0aW9uIChlKSB7XHJcbiAgICBjdXJyZW50UGFnZVggPSBlLnBhZ2VYO1xyXG4gICAgY3VycmVudExlZnQgPSBfLnRvSW50KGRvbS5jc3MoaS5zY3JvbGxiYXJYLCAnbGVmdCcpKSAqIGkucmFpbFhSYXRpbztcclxuICAgIF8uc3RhcnRTY3JvbGxpbmcoZWxlbWVudCwgJ3gnKTtcclxuXHJcbiAgICBpLmV2ZW50LmJpbmQoaS5vd25lckRvY3VtZW50LCAnbW91c2Vtb3ZlJywgbW91c2VNb3ZlSGFuZGxlcik7XHJcbiAgICBpLmV2ZW50Lm9uY2UoaS5vd25lckRvY3VtZW50LCAnbW91c2V1cCcsIG1vdXNlVXBIYW5kbGVyKTtcclxuXHJcbiAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xyXG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gIH0pO1xyXG59XHJcblxyXG5mdW5jdGlvbiBiaW5kTW91c2VTY3JvbGxZSGFuZGxlcihlbGVtZW50LCBpKSB7XHJcbiAgdmFyIGN1cnJlbnRUb3AgPSBudWxsO1xyXG4gIHZhciBjdXJyZW50UGFnZVkgPSBudWxsO1xyXG5cclxuICBmdW5jdGlvbiB1cGRhdGVTY3JvbGxUb3AoZGVsdGFZKSB7XHJcbiAgICB2YXIgbmV3VG9wID0gY3VycmVudFRvcCArIChkZWx0YVkgKiBpLnJhaWxZUmF0aW8pO1xyXG4gICAgdmFyIG1heFRvcCA9IE1hdGgubWF4KDAsIGkuc2Nyb2xsYmFyWVJhaWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkudG9wKSArIChpLnJhaWxZUmF0aW8gKiAoaS5yYWlsWUhlaWdodCAtIGkuc2Nyb2xsYmFyWUhlaWdodCkpO1xyXG5cclxuICAgIGlmIChuZXdUb3AgPCAwKSB7XHJcbiAgICAgIGkuc2Nyb2xsYmFyWVRvcCA9IDA7XHJcbiAgICB9IGVsc2UgaWYgKG5ld1RvcCA+IG1heFRvcCkge1xyXG4gICAgICBpLnNjcm9sbGJhcllUb3AgPSBtYXhUb3A7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBpLnNjcm9sbGJhcllUb3AgPSBuZXdUb3A7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIHNjcm9sbFRvcCA9IF8udG9JbnQoaS5zY3JvbGxiYXJZVG9wICogKGkuY29udGVudEhlaWdodCAtIGkuY29udGFpbmVySGVpZ2h0KSAvIChpLmNvbnRhaW5lckhlaWdodCAtIChpLnJhaWxZUmF0aW8gKiBpLnNjcm9sbGJhcllIZWlnaHQpKSk7XHJcbiAgICB1cGRhdGVTY3JvbGwoZWxlbWVudCwgJ3RvcCcsIHNjcm9sbFRvcCk7XHJcbiAgfVxyXG5cclxuICB2YXIgbW91c2VNb3ZlSGFuZGxlciA9IGZ1bmN0aW9uIChlKSB7XHJcbiAgICB1cGRhdGVTY3JvbGxUb3AoZS5wYWdlWSAtIGN1cnJlbnRQYWdlWSk7XHJcbiAgICB1cGRhdGVHZW9tZXRyeShlbGVtZW50KTtcclxuICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XHJcbiAgICBlLnByZXZlbnREZWZhdWx0KCk7XHJcbiAgfTtcclxuXHJcbiAgdmFyIG1vdXNlVXBIYW5kbGVyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgXy5zdG9wU2Nyb2xsaW5nKGVsZW1lbnQsICd5Jyk7XHJcbiAgICBpLmV2ZW50LnVuYmluZChpLm93bmVyRG9jdW1lbnQsICdtb3VzZW1vdmUnLCBtb3VzZU1vdmVIYW5kbGVyKTtcclxuICB9O1xyXG5cclxuICBpLmV2ZW50LmJpbmQoaS5zY3JvbGxiYXJZLCAnbW91c2Vkb3duJywgZnVuY3Rpb24gKGUpIHtcclxuICAgIGN1cnJlbnRQYWdlWSA9IGUucGFnZVk7XHJcbiAgICBjdXJyZW50VG9wID0gXy50b0ludChkb20uY3NzKGkuc2Nyb2xsYmFyWSwgJ3RvcCcpKSAqIGkucmFpbFlSYXRpbztcclxuICAgIF8uc3RhcnRTY3JvbGxpbmcoZWxlbWVudCwgJ3knKTtcclxuXHJcbiAgICBpLmV2ZW50LmJpbmQoaS5vd25lckRvY3VtZW50LCAnbW91c2Vtb3ZlJywgbW91c2VNb3ZlSGFuZGxlcik7XHJcbiAgICBpLmV2ZW50Lm9uY2UoaS5vd25lckRvY3VtZW50LCAnbW91c2V1cCcsIG1vdXNlVXBIYW5kbGVyKTtcclxuXHJcbiAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xyXG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gIH0pO1xyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChlbGVtZW50KSB7XHJcbiAgdmFyIGkgPSBpbnN0YW5jZXMuZ2V0KGVsZW1lbnQpO1xyXG4gIGJpbmRNb3VzZVNjcm9sbFhIYW5kbGVyKGVsZW1lbnQsIGkpO1xyXG4gIGJpbmRNb3VzZVNjcm9sbFlIYW5kbGVyKGVsZW1lbnQsIGkpO1xyXG59O1xyXG5cclxufSx7XCIuLi8uLi9saWIvZG9tXCI6NSxcIi4uLy4uL2xpYi9oZWxwZXJcIjo4LFwiLi4vaW5zdGFuY2VzXCI6MjAsXCIuLi91cGRhdGUtZ2VvbWV0cnlcIjoyMSxcIi4uL3VwZGF0ZS1zY3JvbGxcIjoyMn1dLDE0OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyIF8gPSByZXF1aXJlKCcuLi8uLi9saWIvaGVscGVyJyk7XHJcbnZhciBkb20gPSByZXF1aXJlKCcuLi8uLi9saWIvZG9tJyk7XHJcbnZhciBpbnN0YW5jZXMgPSByZXF1aXJlKCcuLi9pbnN0YW5jZXMnKTtcclxudmFyIHVwZGF0ZUdlb21ldHJ5ID0gcmVxdWlyZSgnLi4vdXBkYXRlLWdlb21ldHJ5Jyk7XHJcbnZhciB1cGRhdGVTY3JvbGwgPSByZXF1aXJlKCcuLi91cGRhdGUtc2Nyb2xsJyk7XHJcblxyXG5mdW5jdGlvbiBiaW5kS2V5Ym9hcmRIYW5kbGVyKGVsZW1lbnQsIGkpIHtcclxuICB2YXIgaG92ZXJlZCA9IGZhbHNlO1xyXG4gIGkuZXZlbnQuYmluZChlbGVtZW50LCAnbW91c2VlbnRlcicsIGZ1bmN0aW9uICgpIHtcclxuICAgIGhvdmVyZWQgPSB0cnVlO1xyXG4gIH0pO1xyXG4gIGkuZXZlbnQuYmluZChlbGVtZW50LCAnbW91c2VsZWF2ZScsIGZ1bmN0aW9uICgpIHtcclxuICAgIGhvdmVyZWQgPSBmYWxzZTtcclxuICB9KTtcclxuXHJcbiAgdmFyIHNob3VsZFByZXZlbnQgPSBmYWxzZTtcclxuICBmdW5jdGlvbiBzaG91bGRQcmV2ZW50RGVmYXVsdChkZWx0YVgsIGRlbHRhWSkge1xyXG4gICAgdmFyIHNjcm9sbFRvcCA9IGVsZW1lbnQuc2Nyb2xsVG9wO1xyXG4gICAgaWYgKGRlbHRhWCA9PT0gMCkge1xyXG4gICAgICBpZiAoIWkuc2Nyb2xsYmFyWUFjdGl2ZSkge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgfVxyXG4gICAgICBpZiAoKHNjcm9sbFRvcCA9PT0gMCAmJiBkZWx0YVkgPiAwKSB8fCAoc2Nyb2xsVG9wID49IGkuY29udGVudEhlaWdodCAtIGkuY29udGFpbmVySGVpZ2h0ICYmIGRlbHRhWSA8IDApKSB7XHJcbiAgICAgICAgcmV0dXJuICFpLnNldHRpbmdzLndoZWVsUHJvcGFnYXRpb247XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICB2YXIgc2Nyb2xsTGVmdCA9IGVsZW1lbnQuc2Nyb2xsTGVmdDtcclxuICAgIGlmIChkZWx0YVkgPT09IDApIHtcclxuICAgICAgaWYgKCFpLnNjcm9sbGJhclhBY3RpdmUpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKChzY3JvbGxMZWZ0ID09PSAwICYmIGRlbHRhWCA8IDApIHx8IChzY3JvbGxMZWZ0ID49IGkuY29udGVudFdpZHRoIC0gaS5jb250YWluZXJXaWR0aCAmJiBkZWx0YVggPiAwKSkge1xyXG4gICAgICAgIHJldHVybiAhaS5zZXR0aW5ncy53aGVlbFByb3BhZ2F0aW9uO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdHJ1ZTtcclxuICB9XHJcblxyXG4gIGkuZXZlbnQuYmluZChpLm93bmVyRG9jdW1lbnQsICdrZXlkb3duJywgZnVuY3Rpb24gKGUpIHtcclxuICAgIGlmICgoZS5pc0RlZmF1bHRQcmV2ZW50ZWQgJiYgZS5pc0RlZmF1bHRQcmV2ZW50ZWQoKSkgfHwgZS5kZWZhdWx0UHJldmVudGVkKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgZm9jdXNlZCA9IGRvbS5tYXRjaGVzKGkuc2Nyb2xsYmFyWCwgJzpmb2N1cycpIHx8XHJcbiAgICAgICAgICAgICAgICAgIGRvbS5tYXRjaGVzKGkuc2Nyb2xsYmFyWSwgJzpmb2N1cycpO1xyXG5cclxuICAgIGlmICghaG92ZXJlZCAmJiAhZm9jdXNlZCkge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIGFjdGl2ZUVsZW1lbnQgPSBkb2N1bWVudC5hY3RpdmVFbGVtZW50ID8gZG9jdW1lbnQuYWN0aXZlRWxlbWVudCA6IGkub3duZXJEb2N1bWVudC5hY3RpdmVFbGVtZW50O1xyXG4gICAgaWYgKGFjdGl2ZUVsZW1lbnQpIHtcclxuICAgICAgaWYgKGFjdGl2ZUVsZW1lbnQudGFnTmFtZSA9PT0gJ0lGUkFNRScpIHtcclxuICAgICAgICBhY3RpdmVFbGVtZW50ID0gYWN0aXZlRWxlbWVudC5jb250ZW50RG9jdW1lbnQuYWN0aXZlRWxlbWVudDtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICAvLyBnbyBkZWVwZXIgaWYgZWxlbWVudCBpcyBhIHdlYmNvbXBvbmVudFxyXG4gICAgICAgIHdoaWxlIChhY3RpdmVFbGVtZW50LnNoYWRvd1Jvb3QpIHtcclxuICAgICAgICAgIGFjdGl2ZUVsZW1lbnQgPSBhY3RpdmVFbGVtZW50LnNoYWRvd1Jvb3QuYWN0aXZlRWxlbWVudDtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgaWYgKF8uaXNFZGl0YWJsZShhY3RpdmVFbGVtZW50KSkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHZhciBkZWx0YVggPSAwO1xyXG4gICAgdmFyIGRlbHRhWSA9IDA7XHJcblxyXG4gICAgc3dpdGNoIChlLndoaWNoKSB7XHJcbiAgICBjYXNlIDM3OiAvLyBsZWZ0XHJcbiAgICAgIGRlbHRhWCA9IC0zMDtcclxuICAgICAgYnJlYWs7XHJcbiAgICBjYXNlIDM4OiAvLyB1cFxyXG4gICAgICBkZWx0YVkgPSAzMDtcclxuICAgICAgYnJlYWs7XHJcbiAgICBjYXNlIDM5OiAvLyByaWdodFxyXG4gICAgICBkZWx0YVggPSAzMDtcclxuICAgICAgYnJlYWs7XHJcbiAgICBjYXNlIDQwOiAvLyBkb3duXHJcbiAgICAgIGRlbHRhWSA9IC0zMDtcclxuICAgICAgYnJlYWs7XHJcbiAgICBjYXNlIDMzOiAvLyBwYWdlIHVwXHJcbiAgICAgIGRlbHRhWSA9IDkwO1xyXG4gICAgICBicmVhaztcclxuICAgIGNhc2UgMzI6IC8vIHNwYWNlIGJhclxyXG4gICAgICBpZiAoZS5zaGlmdEtleSkge1xyXG4gICAgICAgIGRlbHRhWSA9IDkwO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGRlbHRhWSA9IC05MDtcclxuICAgICAgfVxyXG4gICAgICBicmVhaztcclxuICAgIGNhc2UgMzQ6IC8vIHBhZ2UgZG93blxyXG4gICAgICBkZWx0YVkgPSAtOTA7XHJcbiAgICAgIGJyZWFrO1xyXG4gICAgY2FzZSAzNTogLy8gZW5kXHJcbiAgICAgIGlmIChlLmN0cmxLZXkpIHtcclxuICAgICAgICBkZWx0YVkgPSAtaS5jb250ZW50SGVpZ2h0O1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGRlbHRhWSA9IC1pLmNvbnRhaW5lckhlaWdodDtcclxuICAgICAgfVxyXG4gICAgICBicmVhaztcclxuICAgIGNhc2UgMzY6IC8vIGhvbWVcclxuICAgICAgaWYgKGUuY3RybEtleSkge1xyXG4gICAgICAgIGRlbHRhWSA9IGVsZW1lbnQuc2Nyb2xsVG9wO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGRlbHRhWSA9IGkuY29udGFpbmVySGVpZ2h0O1xyXG4gICAgICB9XHJcbiAgICAgIGJyZWFrO1xyXG4gICAgZGVmYXVsdDpcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIHVwZGF0ZVNjcm9sbChlbGVtZW50LCAndG9wJywgZWxlbWVudC5zY3JvbGxUb3AgLSBkZWx0YVkpO1xyXG4gICAgdXBkYXRlU2Nyb2xsKGVsZW1lbnQsICdsZWZ0JywgZWxlbWVudC5zY3JvbGxMZWZ0ICsgZGVsdGFYKTtcclxuICAgIHVwZGF0ZUdlb21ldHJ5KGVsZW1lbnQpO1xyXG5cclxuICAgIHNob3VsZFByZXZlbnQgPSBzaG91bGRQcmV2ZW50RGVmYXVsdChkZWx0YVgsIGRlbHRhWSk7XHJcbiAgICBpZiAoc2hvdWxkUHJldmVudCkge1xyXG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICB9XHJcbiAgfSk7XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGVsZW1lbnQpIHtcclxuICB2YXIgaSA9IGluc3RhbmNlcy5nZXQoZWxlbWVudCk7XHJcbiAgYmluZEtleWJvYXJkSGFuZGxlcihlbGVtZW50LCBpKTtcclxufTtcclxuXHJcbn0se1wiLi4vLi4vbGliL2RvbVwiOjUsXCIuLi8uLi9saWIvaGVscGVyXCI6OCxcIi4uL2luc3RhbmNlc1wiOjIwLFwiLi4vdXBkYXRlLWdlb21ldHJ5XCI6MjEsXCIuLi91cGRhdGUtc2Nyb2xsXCI6MjJ9XSwxNTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XHJcbid1c2Ugc3RyaWN0JztcclxuXHJcbnZhciBpbnN0YW5jZXMgPSByZXF1aXJlKCcuLi9pbnN0YW5jZXMnKTtcclxudmFyIHVwZGF0ZUdlb21ldHJ5ID0gcmVxdWlyZSgnLi4vdXBkYXRlLWdlb21ldHJ5Jyk7XHJcbnZhciB1cGRhdGVTY3JvbGwgPSByZXF1aXJlKCcuLi91cGRhdGUtc2Nyb2xsJyk7XHJcblxyXG5mdW5jdGlvbiBiaW5kTW91c2VXaGVlbEhhbmRsZXIoZWxlbWVudCwgaSkge1xyXG4gIHZhciBzaG91bGRQcmV2ZW50ID0gZmFsc2U7XHJcblxyXG4gIGZ1bmN0aW9uIHNob3VsZFByZXZlbnREZWZhdWx0KGRlbHRhWCwgZGVsdGFZKSB7XHJcbiAgICB2YXIgc2Nyb2xsVG9wID0gZWxlbWVudC5zY3JvbGxUb3A7XHJcbiAgICBpZiAoZGVsdGFYID09PSAwKSB7XHJcbiAgICAgIGlmICghaS5zY3JvbGxiYXJZQWN0aXZlKSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICB9XHJcbiAgICAgIGlmICgoc2Nyb2xsVG9wID09PSAwICYmIGRlbHRhWSA+IDApIHx8IChzY3JvbGxUb3AgPj0gaS5jb250ZW50SGVpZ2h0IC0gaS5jb250YWluZXJIZWlnaHQgJiYgZGVsdGFZIDwgMCkpIHtcclxuICAgICAgICByZXR1cm4gIWkuc2V0dGluZ3Mud2hlZWxQcm9wYWdhdGlvbjtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHZhciBzY3JvbGxMZWZ0ID0gZWxlbWVudC5zY3JvbGxMZWZ0O1xyXG4gICAgaWYgKGRlbHRhWSA9PT0gMCkge1xyXG4gICAgICBpZiAoIWkuc2Nyb2xsYmFyWEFjdGl2ZSkge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgfVxyXG4gICAgICBpZiAoKHNjcm9sbExlZnQgPT09IDAgJiYgZGVsdGFYIDwgMCkgfHwgKHNjcm9sbExlZnQgPj0gaS5jb250ZW50V2lkdGggLSBpLmNvbnRhaW5lcldpZHRoICYmIGRlbHRhWCA+IDApKSB7XHJcbiAgICAgICAgcmV0dXJuICFpLnNldHRpbmdzLndoZWVsUHJvcGFnYXRpb247XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiB0cnVlO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gZ2V0RGVsdGFGcm9tRXZlbnQoZSkge1xyXG4gICAgdmFyIGRlbHRhWCA9IGUuZGVsdGFYO1xyXG4gICAgdmFyIGRlbHRhWSA9IC0xICogZS5kZWx0YVk7XHJcblxyXG4gICAgaWYgKHR5cGVvZiBkZWx0YVggPT09IFwidW5kZWZpbmVkXCIgfHwgdHlwZW9mIGRlbHRhWSA9PT0gXCJ1bmRlZmluZWRcIikge1xyXG4gICAgICAvLyBPUyBYIFNhZmFyaVxyXG4gICAgICBkZWx0YVggPSAtMSAqIGUud2hlZWxEZWx0YVggLyA2O1xyXG4gICAgICBkZWx0YVkgPSBlLndoZWVsRGVsdGFZIC8gNjtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoZS5kZWx0YU1vZGUgJiYgZS5kZWx0YU1vZGUgPT09IDEpIHtcclxuICAgICAgLy8gRmlyZWZveCBpbiBkZWx0YU1vZGUgMTogTGluZSBzY3JvbGxpbmdcclxuICAgICAgZGVsdGFYICo9IDEwO1xyXG4gICAgICBkZWx0YVkgKj0gMTA7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGRlbHRhWCAhPT0gZGVsdGFYICYmIGRlbHRhWSAhPT0gZGVsdGFZLyogTmFOIGNoZWNrcyAqLykge1xyXG4gICAgICAvLyBJRSBpbiBzb21lIG1vdXNlIGRyaXZlcnNcclxuICAgICAgZGVsdGFYID0gMDtcclxuICAgICAgZGVsdGFZID0gZS53aGVlbERlbHRhO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBbZGVsdGFYLCBkZWx0YVldO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gc2hvdWxkQmVDb25zdW1lZEJ5Q2hpbGQoZGVsdGFYLCBkZWx0YVkpIHtcclxuICAgIHZhciBjaGlsZCA9IGVsZW1lbnQucXVlcnlTZWxlY3RvcigndGV4dGFyZWE6aG92ZXIsIHNlbGVjdFttdWx0aXBsZV06aG92ZXIsIC5wcy1jaGlsZDpob3ZlcicpO1xyXG4gICAgaWYgKGNoaWxkKSB7XHJcbiAgICAgIGlmIChjaGlsZC50YWdOYW1lICE9PSAnVEVYVEFSRUEnICYmICF3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShjaGlsZCkub3ZlcmZsb3cubWF0Y2goLyhzY3JvbGx8YXV0bykvKSkge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgfVxyXG5cclxuICAgICAgdmFyIG1heFNjcm9sbFRvcCA9IGNoaWxkLnNjcm9sbEhlaWdodCAtIGNoaWxkLmNsaWVudEhlaWdodDtcclxuICAgICAgaWYgKG1heFNjcm9sbFRvcCA+IDApIHtcclxuICAgICAgICBpZiAoIShjaGlsZC5zY3JvbGxUb3AgPT09IDAgJiYgZGVsdGFZID4gMCkgJiYgIShjaGlsZC5zY3JvbGxUb3AgPT09IG1heFNjcm9sbFRvcCAmJiBkZWx0YVkgPCAwKSkge1xyXG4gICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIHZhciBtYXhTY3JvbGxMZWZ0ID0gY2hpbGQuc2Nyb2xsTGVmdCAtIGNoaWxkLmNsaWVudFdpZHRoO1xyXG4gICAgICBpZiAobWF4U2Nyb2xsTGVmdCA+IDApIHtcclxuICAgICAgICBpZiAoIShjaGlsZC5zY3JvbGxMZWZ0ID09PSAwICYmIGRlbHRhWCA8IDApICYmICEoY2hpbGQuc2Nyb2xsTGVmdCA9PT0gbWF4U2Nyb2xsTGVmdCAmJiBkZWx0YVggPiAwKSkge1xyXG4gICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBtb3VzZXdoZWVsSGFuZGxlcihlKSB7XHJcbiAgICB2YXIgZGVsdGEgPSBnZXREZWx0YUZyb21FdmVudChlKTtcclxuXHJcbiAgICB2YXIgZGVsdGFYID0gZGVsdGFbMF07XHJcbiAgICB2YXIgZGVsdGFZID0gZGVsdGFbMV07XHJcblxyXG4gICAgaWYgKHNob3VsZEJlQ29uc3VtZWRCeUNoaWxkKGRlbHRhWCwgZGVsdGFZKSkge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgc2hvdWxkUHJldmVudCA9IGZhbHNlO1xyXG4gICAgaWYgKCFpLnNldHRpbmdzLnVzZUJvdGhXaGVlbEF4ZXMpIHtcclxuICAgICAgLy8gZGVsdGFYIHdpbGwgb25seSBiZSB1c2VkIGZvciBob3Jpem9udGFsIHNjcm9sbGluZyBhbmQgZGVsdGFZIHdpbGxcclxuICAgICAgLy8gb25seSBiZSB1c2VkIGZvciB2ZXJ0aWNhbCBzY3JvbGxpbmcgLSB0aGlzIGlzIHRoZSBkZWZhdWx0XHJcbiAgICAgIHVwZGF0ZVNjcm9sbChlbGVtZW50LCAndG9wJywgZWxlbWVudC5zY3JvbGxUb3AgLSAoZGVsdGFZICogaS5zZXR0aW5ncy53aGVlbFNwZWVkKSk7XHJcbiAgICAgIHVwZGF0ZVNjcm9sbChlbGVtZW50LCAnbGVmdCcsIGVsZW1lbnQuc2Nyb2xsTGVmdCArIChkZWx0YVggKiBpLnNldHRpbmdzLndoZWVsU3BlZWQpKTtcclxuICAgIH0gZWxzZSBpZiAoaS5zY3JvbGxiYXJZQWN0aXZlICYmICFpLnNjcm9sbGJhclhBY3RpdmUpIHtcclxuICAgICAgLy8gb25seSB2ZXJ0aWNhbCBzY3JvbGxiYXIgaXMgYWN0aXZlIGFuZCB1c2VCb3RoV2hlZWxBeGVzIG9wdGlvbiBpc1xyXG4gICAgICAvLyBhY3RpdmUsIHNvIGxldCdzIHNjcm9sbCB2ZXJ0aWNhbCBiYXIgdXNpbmcgYm90aCBtb3VzZSB3aGVlbCBheGVzXHJcbiAgICAgIGlmIChkZWx0YVkpIHtcclxuICAgICAgICB1cGRhdGVTY3JvbGwoZWxlbWVudCwgJ3RvcCcsIGVsZW1lbnQuc2Nyb2xsVG9wIC0gKGRlbHRhWSAqIGkuc2V0dGluZ3Mud2hlZWxTcGVlZCkpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHVwZGF0ZVNjcm9sbChlbGVtZW50LCAndG9wJywgZWxlbWVudC5zY3JvbGxUb3AgKyAoZGVsdGFYICogaS5zZXR0aW5ncy53aGVlbFNwZWVkKSk7XHJcbiAgICAgIH1cclxuICAgICAgc2hvdWxkUHJldmVudCA9IHRydWU7XHJcbiAgICB9IGVsc2UgaWYgKGkuc2Nyb2xsYmFyWEFjdGl2ZSAmJiAhaS5zY3JvbGxiYXJZQWN0aXZlKSB7XHJcbiAgICAgIC8vIHVzZUJvdGhXaGVlbEF4ZXMgYW5kIG9ubHkgaG9yaXpvbnRhbCBiYXIgaXMgYWN0aXZlLCBzbyB1c2UgYm90aFxyXG4gICAgICAvLyB3aGVlbCBheGVzIGZvciBob3Jpem9udGFsIGJhclxyXG4gICAgICBpZiAoZGVsdGFYKSB7XHJcbiAgICAgICAgdXBkYXRlU2Nyb2xsKGVsZW1lbnQsICdsZWZ0JywgZWxlbWVudC5zY3JvbGxMZWZ0ICsgKGRlbHRhWCAqIGkuc2V0dGluZ3Mud2hlZWxTcGVlZCkpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHVwZGF0ZVNjcm9sbChlbGVtZW50LCAnbGVmdCcsIGVsZW1lbnQuc2Nyb2xsTGVmdCAtIChkZWx0YVkgKiBpLnNldHRpbmdzLndoZWVsU3BlZWQpKTtcclxuICAgICAgfVxyXG4gICAgICBzaG91bGRQcmV2ZW50ID0gdHJ1ZTtcclxuICAgIH1cclxuXHJcbiAgICB1cGRhdGVHZW9tZXRyeShlbGVtZW50KTtcclxuXHJcbiAgICBzaG91bGRQcmV2ZW50ID0gKHNob3VsZFByZXZlbnQgfHwgc2hvdWxkUHJldmVudERlZmF1bHQoZGVsdGFYLCBkZWx0YVkpKTtcclxuICAgIGlmIChzaG91bGRQcmV2ZW50KSB7XHJcbiAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XHJcbiAgICAgIGUucHJldmVudERlZmF1bHQoKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGlmICh0eXBlb2Ygd2luZG93Lm9ud2hlZWwgIT09IFwidW5kZWZpbmVkXCIpIHtcclxuICAgIGkuZXZlbnQuYmluZChlbGVtZW50LCAnd2hlZWwnLCBtb3VzZXdoZWVsSGFuZGxlcik7XHJcbiAgfSBlbHNlIGlmICh0eXBlb2Ygd2luZG93Lm9ubW91c2V3aGVlbCAhPT0gXCJ1bmRlZmluZWRcIikge1xyXG4gICAgaS5ldmVudC5iaW5kKGVsZW1lbnQsICdtb3VzZXdoZWVsJywgbW91c2V3aGVlbEhhbmRsZXIpO1xyXG4gIH1cclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZWxlbWVudCkge1xyXG4gIHZhciBpID0gaW5zdGFuY2VzLmdldChlbGVtZW50KTtcclxuICBiaW5kTW91c2VXaGVlbEhhbmRsZXIoZWxlbWVudCwgaSk7XHJcbn07XHJcblxyXG59LHtcIi4uL2luc3RhbmNlc1wiOjIwLFwiLi4vdXBkYXRlLWdlb21ldHJ5XCI6MjEsXCIuLi91cGRhdGUtc2Nyb2xsXCI6MjJ9XSwxNjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XHJcbid1c2Ugc3RyaWN0JztcclxuXHJcbnZhciBpbnN0YW5jZXMgPSByZXF1aXJlKCcuLi9pbnN0YW5jZXMnKTtcclxudmFyIHVwZGF0ZUdlb21ldHJ5ID0gcmVxdWlyZSgnLi4vdXBkYXRlLWdlb21ldHJ5Jyk7XHJcblxyXG5mdW5jdGlvbiBiaW5kTmF0aXZlU2Nyb2xsSGFuZGxlcihlbGVtZW50LCBpKSB7XHJcbiAgaS5ldmVudC5iaW5kKGVsZW1lbnQsICdzY3JvbGwnLCBmdW5jdGlvbiAoKSB7XHJcbiAgICB1cGRhdGVHZW9tZXRyeShlbGVtZW50KTtcclxuICB9KTtcclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZWxlbWVudCkge1xyXG4gIHZhciBpID0gaW5zdGFuY2VzLmdldChlbGVtZW50KTtcclxuICBiaW5kTmF0aXZlU2Nyb2xsSGFuZGxlcihlbGVtZW50LCBpKTtcclxufTtcclxuXHJcbn0se1wiLi4vaW5zdGFuY2VzXCI6MjAsXCIuLi91cGRhdGUtZ2VvbWV0cnlcIjoyMX1dLDE3OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyIF8gPSByZXF1aXJlKCcuLi8uLi9saWIvaGVscGVyJyk7XHJcbnZhciBpbnN0YW5jZXMgPSByZXF1aXJlKCcuLi9pbnN0YW5jZXMnKTtcclxudmFyIHVwZGF0ZUdlb21ldHJ5ID0gcmVxdWlyZSgnLi4vdXBkYXRlLWdlb21ldHJ5Jyk7XHJcbnZhciB1cGRhdGVTY3JvbGwgPSByZXF1aXJlKCcuLi91cGRhdGUtc2Nyb2xsJyk7XHJcblxyXG5mdW5jdGlvbiBiaW5kU2VsZWN0aW9uSGFuZGxlcihlbGVtZW50LCBpKSB7XHJcbiAgZnVuY3Rpb24gZ2V0UmFuZ2VOb2RlKCkge1xyXG4gICAgdmFyIHNlbGVjdGlvbiA9IHdpbmRvdy5nZXRTZWxlY3Rpb24gPyB3aW5kb3cuZ2V0U2VsZWN0aW9uKCkgOlxyXG4gICAgICAgICAgICAgICAgICAgIGRvY3VtZW50LmdldFNlbGVjdGlvbiA/IGRvY3VtZW50LmdldFNlbGVjdGlvbigpIDogJyc7XHJcbiAgICBpZiAoc2VsZWN0aW9uLnRvU3RyaW5nKCkubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgcmV0dXJuIHNlbGVjdGlvbi5nZXRSYW5nZUF0KDApLmNvbW1vbkFuY2VzdG9yQ29udGFpbmVyO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgdmFyIHNjcm9sbGluZ0xvb3AgPSBudWxsO1xyXG4gIHZhciBzY3JvbGxEaWZmID0ge3RvcDogMCwgbGVmdDogMH07XHJcbiAgZnVuY3Rpb24gc3RhcnRTY3JvbGxpbmcoKSB7XHJcbiAgICBpZiAoIXNjcm9sbGluZ0xvb3ApIHtcclxuICAgICAgc2Nyb2xsaW5nTG9vcCA9IHNldEludGVydmFsKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAoIWluc3RhbmNlcy5nZXQoZWxlbWVudCkpIHtcclxuICAgICAgICAgIGNsZWFySW50ZXJ2YWwoc2Nyb2xsaW5nTG9vcCk7XHJcbiAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB1cGRhdGVTY3JvbGwoZWxlbWVudCwgJ3RvcCcsIGVsZW1lbnQuc2Nyb2xsVG9wICsgc2Nyb2xsRGlmZi50b3ApO1xyXG4gICAgICAgIHVwZGF0ZVNjcm9sbChlbGVtZW50LCAnbGVmdCcsIGVsZW1lbnQuc2Nyb2xsTGVmdCArIHNjcm9sbERpZmYubGVmdCk7XHJcbiAgICAgICAgdXBkYXRlR2VvbWV0cnkoZWxlbWVudCk7XHJcbiAgICAgIH0sIDUwKTsgLy8gZXZlcnkgLjEgc2VjXHJcbiAgICB9XHJcbiAgfVxyXG4gIGZ1bmN0aW9uIHN0b3BTY3JvbGxpbmcoKSB7XHJcbiAgICBpZiAoc2Nyb2xsaW5nTG9vcCkge1xyXG4gICAgICBjbGVhckludGVydmFsKHNjcm9sbGluZ0xvb3ApO1xyXG4gICAgICBzY3JvbGxpbmdMb29wID0gbnVsbDtcclxuICAgIH1cclxuICAgIF8uc3RvcFNjcm9sbGluZyhlbGVtZW50KTtcclxuICB9XHJcblxyXG4gIHZhciBpc1NlbGVjdGVkID0gZmFsc2U7XHJcbiAgaS5ldmVudC5iaW5kKGkub3duZXJEb2N1bWVudCwgJ3NlbGVjdGlvbmNoYW5nZScsIGZ1bmN0aW9uICgpIHtcclxuICAgIGlmIChlbGVtZW50LmNvbnRhaW5zKGdldFJhbmdlTm9kZSgpKSkge1xyXG4gICAgICBpc1NlbGVjdGVkID0gdHJ1ZTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGlzU2VsZWN0ZWQgPSBmYWxzZTtcclxuICAgICAgc3RvcFNjcm9sbGluZygpO1xyXG4gICAgfVxyXG4gIH0pO1xyXG4gIGkuZXZlbnQuYmluZCh3aW5kb3csICdtb3VzZXVwJywgZnVuY3Rpb24gKCkge1xyXG4gICAgaWYgKGlzU2VsZWN0ZWQpIHtcclxuICAgICAgaXNTZWxlY3RlZCA9IGZhbHNlO1xyXG4gICAgICBzdG9wU2Nyb2xsaW5nKCk7XHJcbiAgICB9XHJcbiAgfSk7XHJcblxyXG4gIGkuZXZlbnQuYmluZCh3aW5kb3csICdtb3VzZW1vdmUnLCBmdW5jdGlvbiAoZSkge1xyXG4gICAgaWYgKGlzU2VsZWN0ZWQpIHtcclxuICAgICAgdmFyIG1vdXNlUG9zaXRpb24gPSB7eDogZS5wYWdlWCwgeTogZS5wYWdlWX07XHJcbiAgICAgIHZhciBjb250YWluZXJHZW9tZXRyeSA9IHtcclxuICAgICAgICBsZWZ0OiBlbGVtZW50Lm9mZnNldExlZnQsXHJcbiAgICAgICAgcmlnaHQ6IGVsZW1lbnQub2Zmc2V0TGVmdCArIGVsZW1lbnQub2Zmc2V0V2lkdGgsXHJcbiAgICAgICAgdG9wOiBlbGVtZW50Lm9mZnNldFRvcCxcclxuICAgICAgICBib3R0b206IGVsZW1lbnQub2Zmc2V0VG9wICsgZWxlbWVudC5vZmZzZXRIZWlnaHRcclxuICAgICAgfTtcclxuXHJcbiAgICAgIGlmIChtb3VzZVBvc2l0aW9uLnggPCBjb250YWluZXJHZW9tZXRyeS5sZWZ0ICsgMykge1xyXG4gICAgICAgIHNjcm9sbERpZmYubGVmdCA9IC01O1xyXG4gICAgICAgIF8uc3RhcnRTY3JvbGxpbmcoZWxlbWVudCwgJ3gnKTtcclxuICAgICAgfSBlbHNlIGlmIChtb3VzZVBvc2l0aW9uLnggPiBjb250YWluZXJHZW9tZXRyeS5yaWdodCAtIDMpIHtcclxuICAgICAgICBzY3JvbGxEaWZmLmxlZnQgPSA1O1xyXG4gICAgICAgIF8uc3RhcnRTY3JvbGxpbmcoZWxlbWVudCwgJ3gnKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBzY3JvbGxEaWZmLmxlZnQgPSAwO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAobW91c2VQb3NpdGlvbi55IDwgY29udGFpbmVyR2VvbWV0cnkudG9wICsgMykge1xyXG4gICAgICAgIGlmIChjb250YWluZXJHZW9tZXRyeS50b3AgKyAzIC0gbW91c2VQb3NpdGlvbi55IDwgNSkge1xyXG4gICAgICAgICAgc2Nyb2xsRGlmZi50b3AgPSAtNTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgc2Nyb2xsRGlmZi50b3AgPSAtMjA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIF8uc3RhcnRTY3JvbGxpbmcoZWxlbWVudCwgJ3knKTtcclxuICAgICAgfSBlbHNlIGlmIChtb3VzZVBvc2l0aW9uLnkgPiBjb250YWluZXJHZW9tZXRyeS5ib3R0b20gLSAzKSB7XHJcbiAgICAgICAgaWYgKG1vdXNlUG9zaXRpb24ueSAtIGNvbnRhaW5lckdlb21ldHJ5LmJvdHRvbSArIDMgPCA1KSB7XHJcbiAgICAgICAgICBzY3JvbGxEaWZmLnRvcCA9IDU7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHNjcm9sbERpZmYudG9wID0gMjA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIF8uc3RhcnRTY3JvbGxpbmcoZWxlbWVudCwgJ3knKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBzY3JvbGxEaWZmLnRvcCA9IDA7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChzY3JvbGxEaWZmLnRvcCA9PT0gMCAmJiBzY3JvbGxEaWZmLmxlZnQgPT09IDApIHtcclxuICAgICAgICBzdG9wU2Nyb2xsaW5nKCk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgc3RhcnRTY3JvbGxpbmcoKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH0pO1xyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChlbGVtZW50KSB7XHJcbiAgdmFyIGkgPSBpbnN0YW5jZXMuZ2V0KGVsZW1lbnQpO1xyXG4gIGJpbmRTZWxlY3Rpb25IYW5kbGVyKGVsZW1lbnQsIGkpO1xyXG59O1xyXG5cclxufSx7XCIuLi8uLi9saWIvaGVscGVyXCI6OCxcIi4uL2luc3RhbmNlc1wiOjIwLFwiLi4vdXBkYXRlLWdlb21ldHJ5XCI6MjEsXCIuLi91cGRhdGUtc2Nyb2xsXCI6MjJ9XSwxODpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XHJcbid1c2Ugc3RyaWN0JztcclxuXHJcbnZhciBfID0gcmVxdWlyZSgnLi4vLi4vbGliL2hlbHBlcicpO1xyXG52YXIgaW5zdGFuY2VzID0gcmVxdWlyZSgnLi4vaW5zdGFuY2VzJyk7XHJcbnZhciB1cGRhdGVHZW9tZXRyeSA9IHJlcXVpcmUoJy4uL3VwZGF0ZS1nZW9tZXRyeScpO1xyXG52YXIgdXBkYXRlU2Nyb2xsID0gcmVxdWlyZSgnLi4vdXBkYXRlLXNjcm9sbCcpO1xyXG5cclxuZnVuY3Rpb24gYmluZFRvdWNoSGFuZGxlcihlbGVtZW50LCBpLCBzdXBwb3J0c1RvdWNoLCBzdXBwb3J0c0llUG9pbnRlcikge1xyXG4gIGZ1bmN0aW9uIHNob3VsZFByZXZlbnREZWZhdWx0KGRlbHRhWCwgZGVsdGFZKSB7XHJcbiAgICB2YXIgc2Nyb2xsVG9wID0gZWxlbWVudC5zY3JvbGxUb3A7XHJcbiAgICB2YXIgc2Nyb2xsTGVmdCA9IGVsZW1lbnQuc2Nyb2xsTGVmdDtcclxuICAgIHZhciBtYWduaXR1ZGVYID0gTWF0aC5hYnMoZGVsdGFYKTtcclxuICAgIHZhciBtYWduaXR1ZGVZID0gTWF0aC5hYnMoZGVsdGFZKTtcclxuXHJcbiAgICBpZiAobWFnbml0dWRlWSA+IG1hZ25pdHVkZVgpIHtcclxuICAgICAgLy8gdXNlciBpcyBwZXJoYXBzIHRyeWluZyB0byBzd2lwZSB1cC9kb3duIHRoZSBwYWdlXHJcblxyXG4gICAgICBpZiAoKChkZWx0YVkgPCAwKSAmJiAoc2Nyb2xsVG9wID09PSBpLmNvbnRlbnRIZWlnaHQgLSBpLmNvbnRhaW5lckhlaWdodCkpIHx8XHJcbiAgICAgICAgICAoKGRlbHRhWSA+IDApICYmIChzY3JvbGxUb3AgPT09IDApKSkge1xyXG4gICAgICAgIHJldHVybiAhaS5zZXR0aW5ncy5zd2lwZVByb3BhZ2F0aW9uO1xyXG4gICAgICB9XHJcbiAgICB9IGVsc2UgaWYgKG1hZ25pdHVkZVggPiBtYWduaXR1ZGVZKSB7XHJcbiAgICAgIC8vIHVzZXIgaXMgcGVyaGFwcyB0cnlpbmcgdG8gc3dpcGUgbGVmdC9yaWdodCBhY3Jvc3MgdGhlIHBhZ2VcclxuXHJcbiAgICAgIGlmICgoKGRlbHRhWCA8IDApICYmIChzY3JvbGxMZWZ0ID09PSBpLmNvbnRlbnRXaWR0aCAtIGkuY29udGFpbmVyV2lkdGgpKSB8fFxyXG4gICAgICAgICAgKChkZWx0YVggPiAwKSAmJiAoc2Nyb2xsTGVmdCA9PT0gMCkpKSB7XHJcbiAgICAgICAgcmV0dXJuICFpLnNldHRpbmdzLnN3aXBlUHJvcGFnYXRpb247XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gdHJ1ZTtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGFwcGx5VG91Y2hNb3ZlKGRpZmZlcmVuY2VYLCBkaWZmZXJlbmNlWSkge1xyXG4gICAgdXBkYXRlU2Nyb2xsKGVsZW1lbnQsICd0b3AnLCBlbGVtZW50LnNjcm9sbFRvcCAtIGRpZmZlcmVuY2VZKTtcclxuICAgIHVwZGF0ZVNjcm9sbChlbGVtZW50LCAnbGVmdCcsIGVsZW1lbnQuc2Nyb2xsTGVmdCAtIGRpZmZlcmVuY2VYKTtcclxuXHJcbiAgICB1cGRhdGVHZW9tZXRyeShlbGVtZW50KTtcclxuICB9XHJcblxyXG4gIHZhciBzdGFydE9mZnNldCA9IHt9O1xyXG4gIHZhciBzdGFydFRpbWUgPSAwO1xyXG4gIHZhciBzcGVlZCA9IHt9O1xyXG4gIHZhciBlYXNpbmdMb29wID0gbnVsbDtcclxuICB2YXIgaW5HbG9iYWxUb3VjaCA9IGZhbHNlO1xyXG4gIHZhciBpbkxvY2FsVG91Y2ggPSBmYWxzZTtcclxuXHJcbiAgZnVuY3Rpb24gZ2xvYmFsVG91Y2hTdGFydCgpIHtcclxuICAgIGluR2xvYmFsVG91Y2ggPSB0cnVlO1xyXG4gIH1cclxuICBmdW5jdGlvbiBnbG9iYWxUb3VjaEVuZCgpIHtcclxuICAgIGluR2xvYmFsVG91Y2ggPSBmYWxzZTtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGdldFRvdWNoKGUpIHtcclxuICAgIGlmIChlLnRhcmdldFRvdWNoZXMpIHtcclxuICAgICAgcmV0dXJuIGUudGFyZ2V0VG91Y2hlc1swXTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIC8vIE1heWJlIElFIHBvaW50ZXJcclxuICAgICAgcmV0dXJuIGU7XHJcbiAgICB9XHJcbiAgfVxyXG4gIGZ1bmN0aW9uIHNob3VsZEhhbmRsZShlKSB7XHJcbiAgICBpZiAoZS50YXJnZXRUb3VjaGVzICYmIGUudGFyZ2V0VG91Y2hlcy5sZW5ndGggPT09IDEpIHtcclxuICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbiAgICBpZiAoZS5wb2ludGVyVHlwZSAmJiBlLnBvaW50ZXJUeXBlICE9PSAnbW91c2UnICYmIGUucG9pbnRlclR5cGUgIT09IGUuTVNQT0lOVEVSX1RZUEVfTU9VU0UpIHtcclxuICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbiAgfVxyXG4gIGZ1bmN0aW9uIHRvdWNoU3RhcnQoZSkge1xyXG4gICAgaWYgKHNob3VsZEhhbmRsZShlKSkge1xyXG4gICAgICBpbkxvY2FsVG91Y2ggPSB0cnVlO1xyXG5cclxuICAgICAgdmFyIHRvdWNoID0gZ2V0VG91Y2goZSk7XHJcblxyXG4gICAgICBzdGFydE9mZnNldC5wYWdlWCA9IHRvdWNoLnBhZ2VYO1xyXG4gICAgICBzdGFydE9mZnNldC5wYWdlWSA9IHRvdWNoLnBhZ2VZO1xyXG5cclxuICAgICAgc3RhcnRUaW1lID0gKG5ldyBEYXRlKCkpLmdldFRpbWUoKTtcclxuXHJcbiAgICAgIGlmIChlYXNpbmdMb29wICE9PSBudWxsKSB7XHJcbiAgICAgICAgY2xlYXJJbnRlcnZhbChlYXNpbmdMb29wKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcclxuICAgIH1cclxuICB9XHJcbiAgZnVuY3Rpb24gdG91Y2hNb3ZlKGUpIHtcclxuICAgIGlmICghaW5Mb2NhbFRvdWNoICYmIGkuc2V0dGluZ3Muc3dpcGVQcm9wYWdhdGlvbikge1xyXG4gICAgICB0b3VjaFN0YXJ0KGUpO1xyXG4gICAgfVxyXG4gICAgaWYgKCFpbkdsb2JhbFRvdWNoICYmIGluTG9jYWxUb3VjaCAmJiBzaG91bGRIYW5kbGUoZSkpIHtcclxuICAgICAgdmFyIHRvdWNoID0gZ2V0VG91Y2goZSk7XHJcblxyXG4gICAgICB2YXIgY3VycmVudE9mZnNldCA9IHtwYWdlWDogdG91Y2gucGFnZVgsIHBhZ2VZOiB0b3VjaC5wYWdlWX07XHJcblxyXG4gICAgICB2YXIgZGlmZmVyZW5jZVggPSBjdXJyZW50T2Zmc2V0LnBhZ2VYIC0gc3RhcnRPZmZzZXQucGFnZVg7XHJcbiAgICAgIHZhciBkaWZmZXJlbmNlWSA9IGN1cnJlbnRPZmZzZXQucGFnZVkgLSBzdGFydE9mZnNldC5wYWdlWTtcclxuXHJcbiAgICAgIGFwcGx5VG91Y2hNb3ZlKGRpZmZlcmVuY2VYLCBkaWZmZXJlbmNlWSk7XHJcbiAgICAgIHN0YXJ0T2Zmc2V0ID0gY3VycmVudE9mZnNldDtcclxuXHJcbiAgICAgIHZhciBjdXJyZW50VGltZSA9IChuZXcgRGF0ZSgpKS5nZXRUaW1lKCk7XHJcblxyXG4gICAgICB2YXIgdGltZUdhcCA9IGN1cnJlbnRUaW1lIC0gc3RhcnRUaW1lO1xyXG4gICAgICBpZiAodGltZUdhcCA+IDApIHtcclxuICAgICAgICBzcGVlZC54ID0gZGlmZmVyZW5jZVggLyB0aW1lR2FwO1xyXG4gICAgICAgIHNwZWVkLnkgPSBkaWZmZXJlbmNlWSAvIHRpbWVHYXA7XHJcbiAgICAgICAgc3RhcnRUaW1lID0gY3VycmVudFRpbWU7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChzaG91bGRQcmV2ZW50RGVmYXVsdChkaWZmZXJlbmNlWCwgZGlmZmVyZW5jZVkpKSB7XHJcbiAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcclxuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcbiAgZnVuY3Rpb24gdG91Y2hFbmQoKSB7XHJcbiAgICBpZiAoIWluR2xvYmFsVG91Y2ggJiYgaW5Mb2NhbFRvdWNoKSB7XHJcbiAgICAgIGluTG9jYWxUb3VjaCA9IGZhbHNlO1xyXG5cclxuICAgICAgY2xlYXJJbnRlcnZhbChlYXNpbmdMb29wKTtcclxuICAgICAgZWFzaW5nTG9vcCA9IHNldEludGVydmFsKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAoIWluc3RhbmNlcy5nZXQoZWxlbWVudCkpIHtcclxuICAgICAgICAgIGNsZWFySW50ZXJ2YWwoZWFzaW5nTG9vcCk7XHJcbiAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoTWF0aC5hYnMoc3BlZWQueCkgPCAwLjAxICYmIE1hdGguYWJzKHNwZWVkLnkpIDwgMC4wMSkge1xyXG4gICAgICAgICAgY2xlYXJJbnRlcnZhbChlYXNpbmdMb29wKTtcclxuICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGFwcGx5VG91Y2hNb3ZlKHNwZWVkLnggKiAzMCwgc3BlZWQueSAqIDMwKTtcclxuXHJcbiAgICAgICAgc3BlZWQueCAqPSAwLjg7XHJcbiAgICAgICAgc3BlZWQueSAqPSAwLjg7XHJcbiAgICAgIH0sIDEwKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGlmIChzdXBwb3J0c1RvdWNoKSB7XHJcbiAgICBpLmV2ZW50LmJpbmQod2luZG93LCAndG91Y2hzdGFydCcsIGdsb2JhbFRvdWNoU3RhcnQpO1xyXG4gICAgaS5ldmVudC5iaW5kKHdpbmRvdywgJ3RvdWNoZW5kJywgZ2xvYmFsVG91Y2hFbmQpO1xyXG4gICAgaS5ldmVudC5iaW5kKGVsZW1lbnQsICd0b3VjaHN0YXJ0JywgdG91Y2hTdGFydCk7XHJcbiAgICBpLmV2ZW50LmJpbmQoZWxlbWVudCwgJ3RvdWNobW92ZScsIHRvdWNoTW92ZSk7XHJcbiAgICBpLmV2ZW50LmJpbmQoZWxlbWVudCwgJ3RvdWNoZW5kJywgdG91Y2hFbmQpO1xyXG4gIH1cclxuXHJcbiAgaWYgKHN1cHBvcnRzSWVQb2ludGVyKSB7XHJcbiAgICBpZiAod2luZG93LlBvaW50ZXJFdmVudCkge1xyXG4gICAgICBpLmV2ZW50LmJpbmQod2luZG93LCAncG9pbnRlcmRvd24nLCBnbG9iYWxUb3VjaFN0YXJ0KTtcclxuICAgICAgaS5ldmVudC5iaW5kKHdpbmRvdywgJ3BvaW50ZXJ1cCcsIGdsb2JhbFRvdWNoRW5kKTtcclxuICAgICAgaS5ldmVudC5iaW5kKGVsZW1lbnQsICdwb2ludGVyZG93bicsIHRvdWNoU3RhcnQpO1xyXG4gICAgICBpLmV2ZW50LmJpbmQoZWxlbWVudCwgJ3BvaW50ZXJtb3ZlJywgdG91Y2hNb3ZlKTtcclxuICAgICAgaS5ldmVudC5iaW5kKGVsZW1lbnQsICdwb2ludGVydXAnLCB0b3VjaEVuZCk7XHJcbiAgICB9IGVsc2UgaWYgKHdpbmRvdy5NU1BvaW50ZXJFdmVudCkge1xyXG4gICAgICBpLmV2ZW50LmJpbmQod2luZG93LCAnTVNQb2ludGVyRG93bicsIGdsb2JhbFRvdWNoU3RhcnQpO1xyXG4gICAgICBpLmV2ZW50LmJpbmQod2luZG93LCAnTVNQb2ludGVyVXAnLCBnbG9iYWxUb3VjaEVuZCk7XHJcbiAgICAgIGkuZXZlbnQuYmluZChlbGVtZW50LCAnTVNQb2ludGVyRG93bicsIHRvdWNoU3RhcnQpO1xyXG4gICAgICBpLmV2ZW50LmJpbmQoZWxlbWVudCwgJ01TUG9pbnRlck1vdmUnLCB0b3VjaE1vdmUpO1xyXG4gICAgICBpLmV2ZW50LmJpbmQoZWxlbWVudCwgJ01TUG9pbnRlclVwJywgdG91Y2hFbmQpO1xyXG4gICAgfVxyXG4gIH1cclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZWxlbWVudCkge1xyXG4gIGlmICghXy5lbnYuc3VwcG9ydHNUb3VjaCAmJiAhXy5lbnYuc3VwcG9ydHNJZVBvaW50ZXIpIHtcclxuICAgIHJldHVybjtcclxuICB9XHJcblxyXG4gIHZhciBpID0gaW5zdGFuY2VzLmdldChlbGVtZW50KTtcclxuICBiaW5kVG91Y2hIYW5kbGVyKGVsZW1lbnQsIGksIF8uZW52LnN1cHBvcnRzVG91Y2gsIF8uZW52LnN1cHBvcnRzSWVQb2ludGVyKTtcclxufTtcclxuXHJcbn0se1wiLi4vLi4vbGliL2hlbHBlclwiOjgsXCIuLi9pbnN0YW5jZXNcIjoyMCxcIi4uL3VwZGF0ZS1nZW9tZXRyeVwiOjIxLFwiLi4vdXBkYXRlLXNjcm9sbFwiOjIyfV0sMTk6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xyXG4ndXNlIHN0cmljdCc7XHJcblxyXG52YXIgXyA9IHJlcXVpcmUoJy4uL2xpYi9oZWxwZXInKTtcclxudmFyIGNscyA9IHJlcXVpcmUoJy4uL2xpYi9jbGFzcycpO1xyXG52YXIgaW5zdGFuY2VzID0gcmVxdWlyZSgnLi9pbnN0YW5jZXMnKTtcclxudmFyIHVwZGF0ZUdlb21ldHJ5ID0gcmVxdWlyZSgnLi91cGRhdGUtZ2VvbWV0cnknKTtcclxuXHJcbi8vIEhhbmRsZXJzXHJcbnZhciBoYW5kbGVycyA9IHtcclxuICAnY2xpY2stcmFpbCc6IHJlcXVpcmUoJy4vaGFuZGxlci9jbGljay1yYWlsJyksXHJcbiAgJ2RyYWctc2Nyb2xsYmFyJzogcmVxdWlyZSgnLi9oYW5kbGVyL2RyYWctc2Nyb2xsYmFyJyksXHJcbiAgJ2tleWJvYXJkJzogcmVxdWlyZSgnLi9oYW5kbGVyL2tleWJvYXJkJyksXHJcbiAgJ3doZWVsJzogcmVxdWlyZSgnLi9oYW5kbGVyL21vdXNlLXdoZWVsJyksXHJcbiAgJ3RvdWNoJzogcmVxdWlyZSgnLi9oYW5kbGVyL3RvdWNoJyksXHJcbiAgJ3NlbGVjdGlvbic6IHJlcXVpcmUoJy4vaGFuZGxlci9zZWxlY3Rpb24nKVxyXG59O1xyXG52YXIgbmF0aXZlU2Nyb2xsSGFuZGxlciA9IHJlcXVpcmUoJy4vaGFuZGxlci9uYXRpdmUtc2Nyb2xsJyk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChlbGVtZW50LCB1c2VyU2V0dGluZ3MpIHtcclxuICB1c2VyU2V0dGluZ3MgPSB0eXBlb2YgdXNlclNldHRpbmdzID09PSAnb2JqZWN0JyA/IHVzZXJTZXR0aW5ncyA6IHt9O1xyXG5cclxuICBjbHMuYWRkKGVsZW1lbnQsICdwcy1jb250YWluZXInKTtcclxuXHJcbiAgLy8gQ3JlYXRlIGEgcGx1Z2luIGluc3RhbmNlLlxyXG4gIHZhciBpID0gaW5zdGFuY2VzLmFkZChlbGVtZW50KTtcclxuXHJcbiAgaS5zZXR0aW5ncyA9IF8uZXh0ZW5kKGkuc2V0dGluZ3MsIHVzZXJTZXR0aW5ncyk7XHJcbiAgY2xzLmFkZChlbGVtZW50LCAncHMtdGhlbWUtJyArIGkuc2V0dGluZ3MudGhlbWUpO1xyXG5cclxuICBpLnNldHRpbmdzLmhhbmRsZXJzLmZvckVhY2goZnVuY3Rpb24gKGhhbmRsZXJOYW1lKSB7XHJcbiAgICBoYW5kbGVyc1toYW5kbGVyTmFtZV0oZWxlbWVudCk7XHJcbiAgfSk7XHJcblxyXG4gIG5hdGl2ZVNjcm9sbEhhbmRsZXIoZWxlbWVudCk7XHJcblxyXG4gIHVwZGF0ZUdlb21ldHJ5KGVsZW1lbnQpO1xyXG59O1xyXG5cclxufSx7XCIuLi9saWIvY2xhc3NcIjo0LFwiLi4vbGliL2hlbHBlclwiOjgsXCIuL2hhbmRsZXIvY2xpY2stcmFpbFwiOjEyLFwiLi9oYW5kbGVyL2RyYWctc2Nyb2xsYmFyXCI6MTMsXCIuL2hhbmRsZXIva2V5Ym9hcmRcIjoxNCxcIi4vaGFuZGxlci9tb3VzZS13aGVlbFwiOjE1LFwiLi9oYW5kbGVyL25hdGl2ZS1zY3JvbGxcIjoxNixcIi4vaGFuZGxlci9zZWxlY3Rpb25cIjoxNyxcIi4vaGFuZGxlci90b3VjaFwiOjE4LFwiLi9pbnN0YW5jZXNcIjoyMCxcIi4vdXBkYXRlLWdlb21ldHJ5XCI6MjF9XSwyMDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XHJcbid1c2Ugc3RyaWN0JztcclxuXHJcbnZhciBfID0gcmVxdWlyZSgnLi4vbGliL2hlbHBlcicpO1xyXG52YXIgY2xzID0gcmVxdWlyZSgnLi4vbGliL2NsYXNzJyk7XHJcbnZhciBkZWZhdWx0U2V0dGluZ3MgPSByZXF1aXJlKCcuL2RlZmF1bHQtc2V0dGluZycpO1xyXG52YXIgZG9tID0gcmVxdWlyZSgnLi4vbGliL2RvbScpO1xyXG52YXIgRXZlbnRNYW5hZ2VyID0gcmVxdWlyZSgnLi4vbGliL2V2ZW50LW1hbmFnZXInKTtcclxudmFyIGd1aWQgPSByZXF1aXJlKCcuLi9saWIvZ3VpZCcpO1xyXG5cclxudmFyIGluc3RhbmNlcyA9IHt9O1xyXG5cclxuZnVuY3Rpb24gSW5zdGFuY2UoZWxlbWVudCkge1xyXG4gIHZhciBpID0gdGhpcztcclxuXHJcbiAgaS5zZXR0aW5ncyA9IF8uY2xvbmUoZGVmYXVsdFNldHRpbmdzKTtcclxuICBpLmNvbnRhaW5lcldpZHRoID0gbnVsbDtcclxuICBpLmNvbnRhaW5lckhlaWdodCA9IG51bGw7XHJcbiAgaS5jb250ZW50V2lkdGggPSBudWxsO1xyXG4gIGkuY29udGVudEhlaWdodCA9IG51bGw7XHJcblxyXG4gIGkuaXNSdGwgPSBkb20uY3NzKGVsZW1lbnQsICdkaXJlY3Rpb24nKSA9PT0gXCJydGxcIjtcclxuICBpLmlzTmVnYXRpdmVTY3JvbGwgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgdmFyIG9yaWdpbmFsU2Nyb2xsTGVmdCA9IGVsZW1lbnQuc2Nyb2xsTGVmdDtcclxuICAgIHZhciByZXN1bHQgPSBudWxsO1xyXG4gICAgZWxlbWVudC5zY3JvbGxMZWZ0ID0gLTE7XHJcbiAgICByZXN1bHQgPSBlbGVtZW50LnNjcm9sbExlZnQgPCAwO1xyXG4gICAgZWxlbWVudC5zY3JvbGxMZWZ0ID0gb3JpZ2luYWxTY3JvbGxMZWZ0O1xyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxuICB9KSgpO1xyXG4gIGkubmVnYXRpdmVTY3JvbGxBZGp1c3RtZW50ID0gaS5pc05lZ2F0aXZlU2Nyb2xsID8gZWxlbWVudC5zY3JvbGxXaWR0aCAtIGVsZW1lbnQuY2xpZW50V2lkdGggOiAwO1xyXG4gIGkuZXZlbnQgPSBuZXcgRXZlbnRNYW5hZ2VyKCk7XHJcbiAgaS5vd25lckRvY3VtZW50ID0gZWxlbWVudC5vd25lckRvY3VtZW50IHx8IGRvY3VtZW50O1xyXG5cclxuICBmdW5jdGlvbiBmb2N1cygpIHtcclxuICAgIGNscy5hZGQoZWxlbWVudCwgJ3BzLWZvY3VzJyk7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBibHVyKCkge1xyXG4gICAgY2xzLnJlbW92ZShlbGVtZW50LCAncHMtZm9jdXMnKTtcclxuICB9XHJcblxyXG4gIGkuc2Nyb2xsYmFyWFJhaWwgPSBkb20uYXBwZW5kVG8oZG9tLmUoJ2RpdicsICdwcy1zY3JvbGxiYXIteC1yYWlsJyksIGVsZW1lbnQpO1xyXG4gIGkuc2Nyb2xsYmFyWCA9IGRvbS5hcHBlbmRUbyhkb20uZSgnZGl2JywgJ3BzLXNjcm9sbGJhci14JyksIGkuc2Nyb2xsYmFyWFJhaWwpO1xyXG4gIGkuc2Nyb2xsYmFyWC5zZXRBdHRyaWJ1dGUoJ3RhYmluZGV4JywgMCk7XHJcbiAgaS5ldmVudC5iaW5kKGkuc2Nyb2xsYmFyWCwgJ2ZvY3VzJywgZm9jdXMpO1xyXG4gIGkuZXZlbnQuYmluZChpLnNjcm9sbGJhclgsICdibHVyJywgYmx1cik7XHJcbiAgaS5zY3JvbGxiYXJYQWN0aXZlID0gbnVsbDtcclxuICBpLnNjcm9sbGJhclhXaWR0aCA9IG51bGw7XHJcbiAgaS5zY3JvbGxiYXJYTGVmdCA9IG51bGw7XHJcbiAgaS5zY3JvbGxiYXJYQm90dG9tID0gXy50b0ludChkb20uY3NzKGkuc2Nyb2xsYmFyWFJhaWwsICdib3R0b20nKSk7XHJcbiAgaS5pc1Njcm9sbGJhclhVc2luZ0JvdHRvbSA9IGkuc2Nyb2xsYmFyWEJvdHRvbSA9PT0gaS5zY3JvbGxiYXJYQm90dG9tOyAvLyAhaXNOYU5cclxuICBpLnNjcm9sbGJhclhUb3AgPSBpLmlzU2Nyb2xsYmFyWFVzaW5nQm90dG9tID8gbnVsbCA6IF8udG9JbnQoZG9tLmNzcyhpLnNjcm9sbGJhclhSYWlsLCAndG9wJykpO1xyXG4gIGkucmFpbEJvcmRlclhXaWR0aCA9IF8udG9JbnQoZG9tLmNzcyhpLnNjcm9sbGJhclhSYWlsLCAnYm9yZGVyTGVmdFdpZHRoJykpICsgXy50b0ludChkb20uY3NzKGkuc2Nyb2xsYmFyWFJhaWwsICdib3JkZXJSaWdodFdpZHRoJykpO1xyXG4gIC8vIFNldCByYWlsIHRvIGRpc3BsYXk6YmxvY2sgdG8gY2FsY3VsYXRlIG1hcmdpbnNcclxuICBkb20uY3NzKGkuc2Nyb2xsYmFyWFJhaWwsICdkaXNwbGF5JywgJ2Jsb2NrJyk7XHJcbiAgaS5yYWlsWE1hcmdpbldpZHRoID0gXy50b0ludChkb20uY3NzKGkuc2Nyb2xsYmFyWFJhaWwsICdtYXJnaW5MZWZ0JykpICsgXy50b0ludChkb20uY3NzKGkuc2Nyb2xsYmFyWFJhaWwsICdtYXJnaW5SaWdodCcpKTtcclxuICBkb20uY3NzKGkuc2Nyb2xsYmFyWFJhaWwsICdkaXNwbGF5JywgJycpO1xyXG4gIGkucmFpbFhXaWR0aCA9IG51bGw7XHJcbiAgaS5yYWlsWFJhdGlvID0gbnVsbDtcclxuXHJcbiAgaS5zY3JvbGxiYXJZUmFpbCA9IGRvbS5hcHBlbmRUbyhkb20uZSgnZGl2JywgJ3BzLXNjcm9sbGJhci15LXJhaWwnKSwgZWxlbWVudCk7XHJcbiAgaS5zY3JvbGxiYXJZID0gZG9tLmFwcGVuZFRvKGRvbS5lKCdkaXYnLCAncHMtc2Nyb2xsYmFyLXknKSwgaS5zY3JvbGxiYXJZUmFpbCk7XHJcbiAgaS5zY3JvbGxiYXJZLnNldEF0dHJpYnV0ZSgndGFiaW5kZXgnLCAwKTtcclxuICBpLmV2ZW50LmJpbmQoaS5zY3JvbGxiYXJZLCAnZm9jdXMnLCBmb2N1cyk7XHJcbiAgaS5ldmVudC5iaW5kKGkuc2Nyb2xsYmFyWSwgJ2JsdXInLCBibHVyKTtcclxuICBpLnNjcm9sbGJhcllBY3RpdmUgPSBudWxsO1xyXG4gIGkuc2Nyb2xsYmFyWUhlaWdodCA9IG51bGw7XHJcbiAgaS5zY3JvbGxiYXJZVG9wID0gbnVsbDtcclxuICBpLnNjcm9sbGJhcllSaWdodCA9IF8udG9JbnQoZG9tLmNzcyhpLnNjcm9sbGJhcllSYWlsLCAncmlnaHQnKSk7XHJcbiAgaS5pc1Njcm9sbGJhcllVc2luZ1JpZ2h0ID0gaS5zY3JvbGxiYXJZUmlnaHQgPT09IGkuc2Nyb2xsYmFyWVJpZ2h0OyAvLyAhaXNOYU5cclxuICBpLnNjcm9sbGJhcllMZWZ0ID0gaS5pc1Njcm9sbGJhcllVc2luZ1JpZ2h0ID8gbnVsbCA6IF8udG9JbnQoZG9tLmNzcyhpLnNjcm9sbGJhcllSYWlsLCAnbGVmdCcpKTtcclxuICBpLnNjcm9sbGJhcllPdXRlcldpZHRoID0gaS5pc1J0bCA/IF8ub3V0ZXJXaWR0aChpLnNjcm9sbGJhclkpIDogbnVsbDtcclxuICBpLnJhaWxCb3JkZXJZV2lkdGggPSBfLnRvSW50KGRvbS5jc3MoaS5zY3JvbGxiYXJZUmFpbCwgJ2JvcmRlclRvcFdpZHRoJykpICsgXy50b0ludChkb20uY3NzKGkuc2Nyb2xsYmFyWVJhaWwsICdib3JkZXJCb3R0b21XaWR0aCcpKTtcclxuICBkb20uY3NzKGkuc2Nyb2xsYmFyWVJhaWwsICdkaXNwbGF5JywgJ2Jsb2NrJyk7XHJcbiAgaS5yYWlsWU1hcmdpbkhlaWdodCA9IF8udG9JbnQoZG9tLmNzcyhpLnNjcm9sbGJhcllSYWlsLCAnbWFyZ2luVG9wJykpICsgXy50b0ludChkb20uY3NzKGkuc2Nyb2xsYmFyWVJhaWwsICdtYXJnaW5Cb3R0b20nKSk7XHJcbiAgZG9tLmNzcyhpLnNjcm9sbGJhcllSYWlsLCAnZGlzcGxheScsICcnKTtcclxuICBpLnJhaWxZSGVpZ2h0ID0gbnVsbDtcclxuICBpLnJhaWxZUmF0aW8gPSBudWxsO1xyXG59XHJcblxyXG5mdW5jdGlvbiBnZXRJZChlbGVtZW50KSB7XHJcbiAgcmV0dXJuIGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdkYXRhLXBzLWlkJyk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHNldElkKGVsZW1lbnQsIGlkKSB7XHJcbiAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2RhdGEtcHMtaWQnLCBpZCk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHJlbW92ZUlkKGVsZW1lbnQpIHtcclxuICBlbGVtZW50LnJlbW92ZUF0dHJpYnV0ZSgnZGF0YS1wcy1pZCcpO1xyXG59XHJcblxyXG5leHBvcnRzLmFkZCA9IGZ1bmN0aW9uIChlbGVtZW50KSB7XHJcbiAgdmFyIG5ld0lkID0gZ3VpZCgpO1xyXG4gIHNldElkKGVsZW1lbnQsIG5ld0lkKTtcclxuICBpbnN0YW5jZXNbbmV3SWRdID0gbmV3IEluc3RhbmNlKGVsZW1lbnQpO1xyXG4gIHJldHVybiBpbnN0YW5jZXNbbmV3SWRdO1xyXG59O1xyXG5cclxuZXhwb3J0cy5yZW1vdmUgPSBmdW5jdGlvbiAoZWxlbWVudCkge1xyXG4gIGRlbGV0ZSBpbnN0YW5jZXNbZ2V0SWQoZWxlbWVudCldO1xyXG4gIHJlbW92ZUlkKGVsZW1lbnQpO1xyXG59O1xyXG5cclxuZXhwb3J0cy5nZXQgPSBmdW5jdGlvbiAoZWxlbWVudCkge1xyXG4gIHJldHVybiBpbnN0YW5jZXNbZ2V0SWQoZWxlbWVudCldO1xyXG59O1xyXG5cclxufSx7XCIuLi9saWIvY2xhc3NcIjo0LFwiLi4vbGliL2RvbVwiOjUsXCIuLi9saWIvZXZlbnQtbWFuYWdlclwiOjYsXCIuLi9saWIvZ3VpZFwiOjcsXCIuLi9saWIvaGVscGVyXCI6OCxcIi4vZGVmYXVsdC1zZXR0aW5nXCI6MTB9XSwyMTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XHJcbid1c2Ugc3RyaWN0JztcclxuXHJcbnZhciBfID0gcmVxdWlyZSgnLi4vbGliL2hlbHBlcicpO1xyXG52YXIgY2xzID0gcmVxdWlyZSgnLi4vbGliL2NsYXNzJyk7XHJcbnZhciBkb20gPSByZXF1aXJlKCcuLi9saWIvZG9tJyk7XHJcbnZhciBpbnN0YW5jZXMgPSByZXF1aXJlKCcuL2luc3RhbmNlcycpO1xyXG52YXIgdXBkYXRlU2Nyb2xsID0gcmVxdWlyZSgnLi91cGRhdGUtc2Nyb2xsJyk7XHJcblxyXG5mdW5jdGlvbiBnZXRUaHVtYlNpemUoaSwgdGh1bWJTaXplKSB7XHJcbiAgaWYgKGkuc2V0dGluZ3MubWluU2Nyb2xsYmFyTGVuZ3RoKSB7XHJcbiAgICB0aHVtYlNpemUgPSBNYXRoLm1heCh0aHVtYlNpemUsIGkuc2V0dGluZ3MubWluU2Nyb2xsYmFyTGVuZ3RoKTtcclxuICB9XHJcbiAgaWYgKGkuc2V0dGluZ3MubWF4U2Nyb2xsYmFyTGVuZ3RoKSB7XHJcbiAgICB0aHVtYlNpemUgPSBNYXRoLm1pbih0aHVtYlNpemUsIGkuc2V0dGluZ3MubWF4U2Nyb2xsYmFyTGVuZ3RoKTtcclxuICB9XHJcbiAgcmV0dXJuIHRodW1iU2l6ZTtcclxufVxyXG5cclxuZnVuY3Rpb24gdXBkYXRlQ3NzKGVsZW1lbnQsIGkpIHtcclxuICB2YXIgeFJhaWxPZmZzZXQgPSB7d2lkdGg6IGkucmFpbFhXaWR0aH07XHJcbiAgaWYgKGkuaXNSdGwpIHtcclxuICAgIHhSYWlsT2Zmc2V0LmxlZnQgPSBpLm5lZ2F0aXZlU2Nyb2xsQWRqdXN0bWVudCArIGVsZW1lbnQuc2Nyb2xsTGVmdCArIGkuY29udGFpbmVyV2lkdGggLSBpLmNvbnRlbnRXaWR0aDtcclxuICB9IGVsc2Uge1xyXG4gICAgeFJhaWxPZmZzZXQubGVmdCA9IGVsZW1lbnQuc2Nyb2xsTGVmdDtcclxuICB9XHJcbiAgaWYgKGkuaXNTY3JvbGxiYXJYVXNpbmdCb3R0b20pIHtcclxuICAgIHhSYWlsT2Zmc2V0LmJvdHRvbSA9IGkuc2Nyb2xsYmFyWEJvdHRvbSAtIGVsZW1lbnQuc2Nyb2xsVG9wO1xyXG4gIH0gZWxzZSB7XHJcbiAgICB4UmFpbE9mZnNldC50b3AgPSBpLnNjcm9sbGJhclhUb3AgKyBlbGVtZW50LnNjcm9sbFRvcDtcclxuICB9XHJcbiAgZG9tLmNzcyhpLnNjcm9sbGJhclhSYWlsLCB4UmFpbE9mZnNldCk7XHJcblxyXG4gIHZhciB5UmFpbE9mZnNldCA9IHt0b3A6IGVsZW1lbnQuc2Nyb2xsVG9wLCBoZWlnaHQ6IGkucmFpbFlIZWlnaHR9O1xyXG4gIGlmIChpLmlzU2Nyb2xsYmFyWVVzaW5nUmlnaHQpIHtcclxuICAgIGlmIChpLmlzUnRsKSB7XHJcbiAgICAgIHlSYWlsT2Zmc2V0LnJpZ2h0ID0gaS5jb250ZW50V2lkdGggLSAoaS5uZWdhdGl2ZVNjcm9sbEFkanVzdG1lbnQgKyBlbGVtZW50LnNjcm9sbExlZnQpIC0gaS5zY3JvbGxiYXJZUmlnaHQgLSBpLnNjcm9sbGJhcllPdXRlcldpZHRoO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgeVJhaWxPZmZzZXQucmlnaHQgPSBpLnNjcm9sbGJhcllSaWdodCAtIGVsZW1lbnQuc2Nyb2xsTGVmdDtcclxuICAgIH1cclxuICB9IGVsc2Uge1xyXG4gICAgaWYgKGkuaXNSdGwpIHtcclxuICAgICAgeVJhaWxPZmZzZXQubGVmdCA9IGkubmVnYXRpdmVTY3JvbGxBZGp1c3RtZW50ICsgZWxlbWVudC5zY3JvbGxMZWZ0ICsgaS5jb250YWluZXJXaWR0aCAqIDIgLSBpLmNvbnRlbnRXaWR0aCAtIGkuc2Nyb2xsYmFyWUxlZnQgLSBpLnNjcm9sbGJhcllPdXRlcldpZHRoO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgeVJhaWxPZmZzZXQubGVmdCA9IGkuc2Nyb2xsYmFyWUxlZnQgKyBlbGVtZW50LnNjcm9sbExlZnQ7XHJcbiAgICB9XHJcbiAgfVxyXG4gIGRvbS5jc3MoaS5zY3JvbGxiYXJZUmFpbCwgeVJhaWxPZmZzZXQpO1xyXG5cclxuICBkb20uY3NzKGkuc2Nyb2xsYmFyWCwge2xlZnQ6IGkuc2Nyb2xsYmFyWExlZnQsIHdpZHRoOiBpLnNjcm9sbGJhclhXaWR0aCAtIGkucmFpbEJvcmRlclhXaWR0aH0pO1xyXG4gIGRvbS5jc3MoaS5zY3JvbGxiYXJZLCB7dG9wOiBpLnNjcm9sbGJhcllUb3AsIGhlaWdodDogaS5zY3JvbGxiYXJZSGVpZ2h0IC0gaS5yYWlsQm9yZGVyWVdpZHRofSk7XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGVsZW1lbnQpIHtcclxuICB2YXIgaSA9IGluc3RhbmNlcy5nZXQoZWxlbWVudCk7XHJcblxyXG4gIGkuY29udGFpbmVyV2lkdGggPSBlbGVtZW50LmNsaWVudFdpZHRoO1xyXG4gIGkuY29udGFpbmVySGVpZ2h0ID0gZWxlbWVudC5jbGllbnRIZWlnaHQ7XHJcbiAgaS5jb250ZW50V2lkdGggPSBlbGVtZW50LnNjcm9sbFdpZHRoO1xyXG4gIGkuY29udGVudEhlaWdodCA9IGVsZW1lbnQuc2Nyb2xsSGVpZ2h0O1xyXG5cclxuICB2YXIgZXhpc3RpbmdSYWlscztcclxuICBpZiAoIWVsZW1lbnQuY29udGFpbnMoaS5zY3JvbGxiYXJYUmFpbCkpIHtcclxuICAgIGV4aXN0aW5nUmFpbHMgPSBkb20ucXVlcnlDaGlsZHJlbihlbGVtZW50LCAnLnBzLXNjcm9sbGJhci14LXJhaWwnKTtcclxuICAgIGlmIChleGlzdGluZ1JhaWxzLmxlbmd0aCA+IDApIHtcclxuICAgICAgZXhpc3RpbmdSYWlscy5mb3JFYWNoKGZ1bmN0aW9uIChyYWlsKSB7XHJcbiAgICAgICAgZG9tLnJlbW92ZShyYWlsKTtcclxuICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBkb20uYXBwZW5kVG8oaS5zY3JvbGxiYXJYUmFpbCwgZWxlbWVudCk7XHJcbiAgfVxyXG4gIGlmICghZWxlbWVudC5jb250YWlucyhpLnNjcm9sbGJhcllSYWlsKSkge1xyXG4gICAgZXhpc3RpbmdSYWlscyA9IGRvbS5xdWVyeUNoaWxkcmVuKGVsZW1lbnQsICcucHMtc2Nyb2xsYmFyLXktcmFpbCcpO1xyXG4gICAgaWYgKGV4aXN0aW5nUmFpbHMubGVuZ3RoID4gMCkge1xyXG4gICAgICBleGlzdGluZ1JhaWxzLmZvckVhY2goZnVuY3Rpb24gKHJhaWwpIHtcclxuICAgICAgICBkb20ucmVtb3ZlKHJhaWwpO1xyXG4gICAgICB9KTtcclxuICAgIH1cclxuICAgIGRvbS5hcHBlbmRUbyhpLnNjcm9sbGJhcllSYWlsLCBlbGVtZW50KTtcclxuICB9XHJcblxyXG4gIGlmICghaS5zZXR0aW5ncy5zdXBwcmVzc1Njcm9sbFggJiYgaS5jb250YWluZXJXaWR0aCArIGkuc2V0dGluZ3Muc2Nyb2xsWE1hcmdpbk9mZnNldCA8IGkuY29udGVudFdpZHRoKSB7XHJcbiAgICBpLnNjcm9sbGJhclhBY3RpdmUgPSB0cnVlO1xyXG4gICAgaS5yYWlsWFdpZHRoID0gaS5jb250YWluZXJXaWR0aCAtIGkucmFpbFhNYXJnaW5XaWR0aDtcclxuICAgIGkucmFpbFhSYXRpbyA9IGkuY29udGFpbmVyV2lkdGggLyBpLnJhaWxYV2lkdGg7XHJcbiAgICBpLnNjcm9sbGJhclhXaWR0aCA9IGdldFRodW1iU2l6ZShpLCBfLnRvSW50KGkucmFpbFhXaWR0aCAqIGkuY29udGFpbmVyV2lkdGggLyBpLmNvbnRlbnRXaWR0aCkpO1xyXG4gICAgaS5zY3JvbGxiYXJYTGVmdCA9IF8udG9JbnQoKGkubmVnYXRpdmVTY3JvbGxBZGp1c3RtZW50ICsgZWxlbWVudC5zY3JvbGxMZWZ0KSAqIChpLnJhaWxYV2lkdGggLSBpLnNjcm9sbGJhclhXaWR0aCkgLyAoaS5jb250ZW50V2lkdGggLSBpLmNvbnRhaW5lcldpZHRoKSk7XHJcbiAgfSBlbHNlIHtcclxuICAgIGkuc2Nyb2xsYmFyWEFjdGl2ZSA9IGZhbHNlO1xyXG4gIH1cclxuXHJcbiAgaWYgKCFpLnNldHRpbmdzLnN1cHByZXNzU2Nyb2xsWSAmJiBpLmNvbnRhaW5lckhlaWdodCArIGkuc2V0dGluZ3Muc2Nyb2xsWU1hcmdpbk9mZnNldCA8IGkuY29udGVudEhlaWdodCkge1xyXG4gICAgaS5zY3JvbGxiYXJZQWN0aXZlID0gdHJ1ZTtcclxuICAgIGkucmFpbFlIZWlnaHQgPSBpLmNvbnRhaW5lckhlaWdodCAtIGkucmFpbFlNYXJnaW5IZWlnaHQ7XHJcbiAgICBpLnJhaWxZUmF0aW8gPSBpLmNvbnRhaW5lckhlaWdodCAvIGkucmFpbFlIZWlnaHQ7XHJcbiAgICBpLnNjcm9sbGJhcllIZWlnaHQgPSBnZXRUaHVtYlNpemUoaSwgXy50b0ludChpLnJhaWxZSGVpZ2h0ICogaS5jb250YWluZXJIZWlnaHQgLyBpLmNvbnRlbnRIZWlnaHQpKTtcclxuICAgIGkuc2Nyb2xsYmFyWVRvcCA9IF8udG9JbnQoZWxlbWVudC5zY3JvbGxUb3AgKiAoaS5yYWlsWUhlaWdodCAtIGkuc2Nyb2xsYmFyWUhlaWdodCkgLyAoaS5jb250ZW50SGVpZ2h0IC0gaS5jb250YWluZXJIZWlnaHQpKTtcclxuICB9IGVsc2Uge1xyXG4gICAgaS5zY3JvbGxiYXJZQWN0aXZlID0gZmFsc2U7XHJcbiAgfVxyXG5cclxuICBpZiAoaS5zY3JvbGxiYXJYTGVmdCA+PSBpLnJhaWxYV2lkdGggLSBpLnNjcm9sbGJhclhXaWR0aCkge1xyXG4gICAgaS5zY3JvbGxiYXJYTGVmdCA9IGkucmFpbFhXaWR0aCAtIGkuc2Nyb2xsYmFyWFdpZHRoO1xyXG4gIH1cclxuICBpZiAoaS5zY3JvbGxiYXJZVG9wID49IGkucmFpbFlIZWlnaHQgLSBpLnNjcm9sbGJhcllIZWlnaHQpIHtcclxuICAgIGkuc2Nyb2xsYmFyWVRvcCA9IGkucmFpbFlIZWlnaHQgLSBpLnNjcm9sbGJhcllIZWlnaHQ7XHJcbiAgfVxyXG5cclxuICB1cGRhdGVDc3MoZWxlbWVudCwgaSk7XHJcblxyXG4gIGlmIChpLnNjcm9sbGJhclhBY3RpdmUpIHtcclxuICAgIGNscy5hZGQoZWxlbWVudCwgJ3BzLWFjdGl2ZS14Jyk7XHJcbiAgfSBlbHNlIHtcclxuICAgIGNscy5yZW1vdmUoZWxlbWVudCwgJ3BzLWFjdGl2ZS14Jyk7XHJcbiAgICBpLnNjcm9sbGJhclhXaWR0aCA9IDA7XHJcbiAgICBpLnNjcm9sbGJhclhMZWZ0ID0gMDtcclxuICAgIHVwZGF0ZVNjcm9sbChlbGVtZW50LCAnbGVmdCcsIDApO1xyXG4gIH1cclxuICBpZiAoaS5zY3JvbGxiYXJZQWN0aXZlKSB7XHJcbiAgICBjbHMuYWRkKGVsZW1lbnQsICdwcy1hY3RpdmUteScpO1xyXG4gIH0gZWxzZSB7XHJcbiAgICBjbHMucmVtb3ZlKGVsZW1lbnQsICdwcy1hY3RpdmUteScpO1xyXG4gICAgaS5zY3JvbGxiYXJZSGVpZ2h0ID0gMDtcclxuICAgIGkuc2Nyb2xsYmFyWVRvcCA9IDA7XHJcbiAgICB1cGRhdGVTY3JvbGwoZWxlbWVudCwgJ3RvcCcsIDApO1xyXG4gIH1cclxufTtcclxuXHJcbn0se1wiLi4vbGliL2NsYXNzXCI6NCxcIi4uL2xpYi9kb21cIjo1LFwiLi4vbGliL2hlbHBlclwiOjgsXCIuL2luc3RhbmNlc1wiOjIwLFwiLi91cGRhdGUtc2Nyb2xsXCI6MjJ9XSwyMjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XHJcbid1c2Ugc3RyaWN0JztcclxuXHJcbnZhciBpbnN0YW5jZXMgPSByZXF1aXJlKCcuL2luc3RhbmNlcycpO1xyXG5cclxudmFyIHVwRXZlbnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnRXZlbnQnKTtcclxudmFyIGRvd25FdmVudCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdFdmVudCcpO1xyXG52YXIgbGVmdEV2ZW50ID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoJ0V2ZW50Jyk7XHJcbnZhciByaWdodEV2ZW50ID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoJ0V2ZW50Jyk7XHJcbnZhciB5RXZlbnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnRXZlbnQnKTtcclxudmFyIHhFdmVudCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdFdmVudCcpO1xyXG52YXIgeFN0YXJ0RXZlbnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnRXZlbnQnKTtcclxudmFyIHhFbmRFdmVudCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdFdmVudCcpO1xyXG52YXIgeVN0YXJ0RXZlbnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnRXZlbnQnKTtcclxudmFyIHlFbmRFdmVudCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdFdmVudCcpO1xyXG52YXIgbGFzdFRvcDtcclxudmFyIGxhc3RMZWZ0O1xyXG5cclxudXBFdmVudC5pbml0RXZlbnQoJ3BzLXNjcm9sbC11cCcsIHRydWUsIHRydWUpO1xyXG5kb3duRXZlbnQuaW5pdEV2ZW50KCdwcy1zY3JvbGwtZG93bicsIHRydWUsIHRydWUpO1xyXG5sZWZ0RXZlbnQuaW5pdEV2ZW50KCdwcy1zY3JvbGwtbGVmdCcsIHRydWUsIHRydWUpO1xyXG5yaWdodEV2ZW50LmluaXRFdmVudCgncHMtc2Nyb2xsLXJpZ2h0JywgdHJ1ZSwgdHJ1ZSk7XHJcbnlFdmVudC5pbml0RXZlbnQoJ3BzLXNjcm9sbC15JywgdHJ1ZSwgdHJ1ZSk7XHJcbnhFdmVudC5pbml0RXZlbnQoJ3BzLXNjcm9sbC14JywgdHJ1ZSwgdHJ1ZSk7XHJcbnhTdGFydEV2ZW50LmluaXRFdmVudCgncHMteC1yZWFjaC1zdGFydCcsIHRydWUsIHRydWUpO1xyXG54RW5kRXZlbnQuaW5pdEV2ZW50KCdwcy14LXJlYWNoLWVuZCcsIHRydWUsIHRydWUpO1xyXG55U3RhcnRFdmVudC5pbml0RXZlbnQoJ3BzLXktcmVhY2gtc3RhcnQnLCB0cnVlLCB0cnVlKTtcclxueUVuZEV2ZW50LmluaXRFdmVudCgncHMteS1yZWFjaC1lbmQnLCB0cnVlLCB0cnVlKTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGVsZW1lbnQsIGF4aXMsIHZhbHVlKSB7XHJcbiAgaWYgKHR5cGVvZiBlbGVtZW50ID09PSAndW5kZWZpbmVkJykge1xyXG4gICAgdGhyb3cgJ1lvdSBtdXN0IHByb3ZpZGUgYW4gZWxlbWVudCB0byB0aGUgdXBkYXRlLXNjcm9sbCBmdW5jdGlvbic7XHJcbiAgfVxyXG5cclxuICBpZiAodHlwZW9mIGF4aXMgPT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICB0aHJvdyAnWW91IG11c3QgcHJvdmlkZSBhbiBheGlzIHRvIHRoZSB1cGRhdGUtc2Nyb2xsIGZ1bmN0aW9uJztcclxuICB9XHJcblxyXG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICB0aHJvdyAnWW91IG11c3QgcHJvdmlkZSBhIHZhbHVlIHRvIHRoZSB1cGRhdGUtc2Nyb2xsIGZ1bmN0aW9uJztcclxuICB9XHJcblxyXG4gIGlmIChheGlzID09PSAndG9wJyAmJiB2YWx1ZSA8PSAwKSB7XHJcbiAgICBlbGVtZW50LnNjcm9sbFRvcCA9IHZhbHVlID0gMDsgLy8gZG9uJ3QgYWxsb3cgbmVnYXRpdmUgc2Nyb2xsXHJcbiAgICBlbGVtZW50LmRpc3BhdGNoRXZlbnQoeVN0YXJ0RXZlbnQpO1xyXG4gIH1cclxuXHJcbiAgaWYgKGF4aXMgPT09ICdsZWZ0JyAmJiB2YWx1ZSA8PSAwKSB7XHJcbiAgICBlbGVtZW50LnNjcm9sbExlZnQgPSB2YWx1ZSA9IDA7IC8vIGRvbid0IGFsbG93IG5lZ2F0aXZlIHNjcm9sbFxyXG4gICAgZWxlbWVudC5kaXNwYXRjaEV2ZW50KHhTdGFydEV2ZW50KTtcclxuICB9XHJcblxyXG4gIHZhciBpID0gaW5zdGFuY2VzLmdldChlbGVtZW50KTtcclxuXHJcbiAgaWYgKGF4aXMgPT09ICd0b3AnICYmIHZhbHVlID49IGkuY29udGVudEhlaWdodCAtIGkuY29udGFpbmVySGVpZ2h0KSB7XHJcbiAgICAvLyBkb24ndCBhbGxvdyBzY3JvbGwgcGFzdCBjb250YWluZXJcclxuICAgIHZhbHVlID0gaS5jb250ZW50SGVpZ2h0IC0gaS5jb250YWluZXJIZWlnaHQ7XHJcbiAgICBpZiAodmFsdWUgLSBlbGVtZW50LnNjcm9sbFRvcCA8PSAxKSB7XHJcbiAgICAgIC8vIG1pdGlnYXRlcyByb3VuZGluZyBlcnJvcnMgb24gbm9uLXN1YnBpeGVsIHNjcm9sbCB2YWx1ZXNcclxuICAgICAgdmFsdWUgPSBlbGVtZW50LnNjcm9sbFRvcDtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGVsZW1lbnQuc2Nyb2xsVG9wID0gdmFsdWU7XHJcbiAgICB9XHJcbiAgICBlbGVtZW50LmRpc3BhdGNoRXZlbnQoeUVuZEV2ZW50KTtcclxuICB9XHJcblxyXG4gIGlmIChheGlzID09PSAnbGVmdCcgJiYgdmFsdWUgPj0gaS5jb250ZW50V2lkdGggLSBpLmNvbnRhaW5lcldpZHRoKSB7XHJcbiAgICAvLyBkb24ndCBhbGxvdyBzY3JvbGwgcGFzdCBjb250YWluZXJcclxuICAgIHZhbHVlID0gaS5jb250ZW50V2lkdGggLSBpLmNvbnRhaW5lcldpZHRoO1xyXG4gICAgaWYgKHZhbHVlIC0gZWxlbWVudC5zY3JvbGxMZWZ0IDw9IDEpIHtcclxuICAgICAgLy8gbWl0aWdhdGVzIHJvdW5kaW5nIGVycm9ycyBvbiBub24tc3VicGl4ZWwgc2Nyb2xsIHZhbHVlc1xyXG4gICAgICB2YWx1ZSA9IGVsZW1lbnQuc2Nyb2xsTGVmdDtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGVsZW1lbnQuc2Nyb2xsTGVmdCA9IHZhbHVlO1xyXG4gICAgfVxyXG4gICAgZWxlbWVudC5kaXNwYXRjaEV2ZW50KHhFbmRFdmVudCk7XHJcbiAgfVxyXG5cclxuICBpZiAoIWxhc3RUb3ApIHtcclxuICAgIGxhc3RUb3AgPSBlbGVtZW50LnNjcm9sbFRvcDtcclxuICB9XHJcblxyXG4gIGlmICghbGFzdExlZnQpIHtcclxuICAgIGxhc3RMZWZ0ID0gZWxlbWVudC5zY3JvbGxMZWZ0O1xyXG4gIH1cclxuXHJcbiAgaWYgKGF4aXMgPT09ICd0b3AnICYmIHZhbHVlIDwgbGFzdFRvcCkge1xyXG4gICAgZWxlbWVudC5kaXNwYXRjaEV2ZW50KHVwRXZlbnQpO1xyXG4gIH1cclxuXHJcbiAgaWYgKGF4aXMgPT09ICd0b3AnICYmIHZhbHVlID4gbGFzdFRvcCkge1xyXG4gICAgZWxlbWVudC5kaXNwYXRjaEV2ZW50KGRvd25FdmVudCk7XHJcbiAgfVxyXG5cclxuICBpZiAoYXhpcyA9PT0gJ2xlZnQnICYmIHZhbHVlIDwgbGFzdExlZnQpIHtcclxuICAgIGVsZW1lbnQuZGlzcGF0Y2hFdmVudChsZWZ0RXZlbnQpO1xyXG4gIH1cclxuXHJcbiAgaWYgKGF4aXMgPT09ICdsZWZ0JyAmJiB2YWx1ZSA+IGxhc3RMZWZ0KSB7XHJcbiAgICBlbGVtZW50LmRpc3BhdGNoRXZlbnQocmlnaHRFdmVudCk7XHJcbiAgfVxyXG5cclxuICBpZiAoYXhpcyA9PT0gJ3RvcCcpIHtcclxuICAgIGVsZW1lbnQuc2Nyb2xsVG9wID0gbGFzdFRvcCA9IHZhbHVlO1xyXG4gICAgZWxlbWVudC5kaXNwYXRjaEV2ZW50KHlFdmVudCk7XHJcbiAgfVxyXG5cclxuICBpZiAoYXhpcyA9PT0gJ2xlZnQnKSB7XHJcbiAgICBlbGVtZW50LnNjcm9sbExlZnQgPSBsYXN0TGVmdCA9IHZhbHVlO1xyXG4gICAgZWxlbWVudC5kaXNwYXRjaEV2ZW50KHhFdmVudCk7XHJcbiAgfVxyXG5cclxufTtcclxuXHJcbn0se1wiLi9pbnN0YW5jZXNcIjoyMH1dLDIzOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyIF8gPSByZXF1aXJlKCcuLi9saWIvaGVscGVyJyk7XHJcbnZhciBkb20gPSByZXF1aXJlKCcuLi9saWIvZG9tJyk7XHJcbnZhciBpbnN0YW5jZXMgPSByZXF1aXJlKCcuL2luc3RhbmNlcycpO1xyXG52YXIgdXBkYXRlR2VvbWV0cnkgPSByZXF1aXJlKCcuL3VwZGF0ZS1nZW9tZXRyeScpO1xyXG52YXIgdXBkYXRlU2Nyb2xsID0gcmVxdWlyZSgnLi91cGRhdGUtc2Nyb2xsJyk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChlbGVtZW50KSB7XHJcbiAgdmFyIGkgPSBpbnN0YW5jZXMuZ2V0KGVsZW1lbnQpO1xyXG5cclxuICBpZiAoIWkpIHtcclxuICAgIHJldHVybjtcclxuICB9XHJcblxyXG4gIC8vIFJlY2FsY3VhdGUgbmVnYXRpdmUgc2Nyb2xsTGVmdCBhZGp1c3RtZW50XHJcbiAgaS5uZWdhdGl2ZVNjcm9sbEFkanVzdG1lbnQgPSBpLmlzTmVnYXRpdmVTY3JvbGwgPyBlbGVtZW50LnNjcm9sbFdpZHRoIC0gZWxlbWVudC5jbGllbnRXaWR0aCA6IDA7XHJcblxyXG4gIC8vIFJlY2FsY3VsYXRlIHJhaWwgbWFyZ2luc1xyXG4gIGRvbS5jc3MoaS5zY3JvbGxiYXJYUmFpbCwgJ2Rpc3BsYXknLCAnYmxvY2snKTtcclxuICBkb20uY3NzKGkuc2Nyb2xsYmFyWVJhaWwsICdkaXNwbGF5JywgJ2Jsb2NrJyk7XHJcbiAgaS5yYWlsWE1hcmdpbldpZHRoID0gXy50b0ludChkb20uY3NzKGkuc2Nyb2xsYmFyWFJhaWwsICdtYXJnaW5MZWZ0JykpICsgXy50b0ludChkb20uY3NzKGkuc2Nyb2xsYmFyWFJhaWwsICdtYXJnaW5SaWdodCcpKTtcclxuICBpLnJhaWxZTWFyZ2luSGVpZ2h0ID0gXy50b0ludChkb20uY3NzKGkuc2Nyb2xsYmFyWVJhaWwsICdtYXJnaW5Ub3AnKSkgKyBfLnRvSW50KGRvbS5jc3MoaS5zY3JvbGxiYXJZUmFpbCwgJ21hcmdpbkJvdHRvbScpKTtcclxuXHJcbiAgLy8gSGlkZSBzY3JvbGxiYXJzIG5vdCB0byBhZmZlY3Qgc2Nyb2xsV2lkdGggYW5kIHNjcm9sbEhlaWdodFxyXG4gIGRvbS5jc3MoaS5zY3JvbGxiYXJYUmFpbCwgJ2Rpc3BsYXknLCAnbm9uZScpO1xyXG4gIGRvbS5jc3MoaS5zY3JvbGxiYXJZUmFpbCwgJ2Rpc3BsYXknLCAnbm9uZScpO1xyXG5cclxuICB1cGRhdGVHZW9tZXRyeShlbGVtZW50KTtcclxuXHJcbiAgLy8gVXBkYXRlIHRvcC9sZWZ0IHNjcm9sbCB0byB0cmlnZ2VyIGV2ZW50c1xyXG4gIHVwZGF0ZVNjcm9sbChlbGVtZW50LCAndG9wJywgZWxlbWVudC5zY3JvbGxUb3ApO1xyXG4gIHVwZGF0ZVNjcm9sbChlbGVtZW50LCAnbGVmdCcsIGVsZW1lbnQuc2Nyb2xsTGVmdCk7XHJcblxyXG4gIGRvbS5jc3MoaS5zY3JvbGxiYXJYUmFpbCwgJ2Rpc3BsYXknLCAnJyk7XHJcbiAgZG9tLmNzcyhpLnNjcm9sbGJhcllSYWlsLCAnZGlzcGxheScsICcnKTtcclxufTtcclxuXHJcbn0se1wiLi4vbGliL2RvbVwiOjUsXCIuLi9saWIvaGVscGVyXCI6OCxcIi4vaW5zdGFuY2VzXCI6MjAsXCIuL3VwZGF0ZS1nZW9tZXRyeVwiOjIxLFwiLi91cGRhdGUtc2Nyb2xsXCI6MjJ9XX0se30sWzFdKTtcclxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc2NyaXB0cy92ZW5kb3JzL2tub2Nrb3V0LXNjcm9sbGJhci5qcyIsIm1vZHVsZS5leHBvcnRzID0geyBcImRlZmF1bHRcIjogcmVxdWlyZShcImNvcmUtanMvbGlicmFyeS9mbi9vYmplY3QvYXNzaWduXCIpLCBfX2VzTW9kdWxlOiB0cnVlIH07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9vYmplY3QvYXNzaWduLmpzXG4vLyBtb2R1bGUgaWQgPSAxMDZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwicmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9lczYub2JqZWN0LmFzc2lnbicpO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLi8uLi9tb2R1bGVzL19jb3JlJykuT2JqZWN0LmFzc2lnbjtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9saWJyYXJ5L2ZuL29iamVjdC9hc3NpZ24uanNcbi8vIG1vZHVsZSBpZCA9IDEwN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyAxOS4xLjMuMSBPYmplY3QuYXNzaWduKHRhcmdldCwgc291cmNlKVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYsICdPYmplY3QnLCB7YXNzaWduOiByZXF1aXJlKCcuL19vYmplY3QtYXNzaWduJyl9KTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM2Lm9iamVjdC5hc3NpZ24uanNcbi8vIG1vZHVsZSBpZCA9IDEwOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG4vLyAxOS4xLjIuMSBPYmplY3QuYXNzaWduKHRhcmdldCwgc291cmNlLCAuLi4pXG52YXIgZ2V0S2V5cyAgPSByZXF1aXJlKCcuL19vYmplY3Qta2V5cycpXG4gICwgZ09QUyAgICAgPSByZXF1aXJlKCcuL19vYmplY3QtZ29wcycpXG4gICwgcElFICAgICAgPSByZXF1aXJlKCcuL19vYmplY3QtcGllJylcbiAgLCB0b09iamVjdCA9IHJlcXVpcmUoJy4vX3RvLW9iamVjdCcpXG4gICwgSU9iamVjdCAgPSByZXF1aXJlKCcuL19pb2JqZWN0JylcbiAgLCAkYXNzaWduICA9IE9iamVjdC5hc3NpZ247XG5cbi8vIHNob3VsZCB3b3JrIHdpdGggc3ltYm9scyBhbmQgc2hvdWxkIGhhdmUgZGV0ZXJtaW5pc3RpYyBwcm9wZXJ0eSBvcmRlciAoVjggYnVnKVxubW9kdWxlLmV4cG9ydHMgPSAhJGFzc2lnbiB8fCByZXF1aXJlKCcuL19mYWlscycpKGZ1bmN0aW9uKCl7XG4gIHZhciBBID0ge31cbiAgICAsIEIgPSB7fVxuICAgICwgUyA9IFN5bWJvbCgpXG4gICAgLCBLID0gJ2FiY2RlZmdoaWprbG1ub3BxcnN0JztcbiAgQVtTXSA9IDc7XG4gIEsuc3BsaXQoJycpLmZvckVhY2goZnVuY3Rpb24oayl7IEJba10gPSBrOyB9KTtcbiAgcmV0dXJuICRhc3NpZ24oe30sIEEpW1NdICE9IDcgfHwgT2JqZWN0LmtleXMoJGFzc2lnbih7fSwgQikpLmpvaW4oJycpICE9IEs7XG59KSA/IGZ1bmN0aW9uIGFzc2lnbih0YXJnZXQsIHNvdXJjZSl7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgdmFyIFQgICAgID0gdG9PYmplY3QodGFyZ2V0KVxuICAgICwgYUxlbiAgPSBhcmd1bWVudHMubGVuZ3RoXG4gICAgLCBpbmRleCA9IDFcbiAgICAsIGdldFN5bWJvbHMgPSBnT1BTLmZcbiAgICAsIGlzRW51bSAgICAgPSBwSUUuZjtcbiAgd2hpbGUoYUxlbiA+IGluZGV4KXtcbiAgICB2YXIgUyAgICAgID0gSU9iamVjdChhcmd1bWVudHNbaW5kZXgrK10pXG4gICAgICAsIGtleXMgICA9IGdldFN5bWJvbHMgPyBnZXRLZXlzKFMpLmNvbmNhdChnZXRTeW1ib2xzKFMpKSA6IGdldEtleXMoUylcbiAgICAgICwgbGVuZ3RoID0ga2V5cy5sZW5ndGhcbiAgICAgICwgaiAgICAgID0gMFxuICAgICAgLCBrZXk7XG4gICAgd2hpbGUobGVuZ3RoID4gailpZihpc0VudW0uY2FsbChTLCBrZXkgPSBrZXlzW2orK10pKVRba2V5XSA9IFNba2V5XTtcbiAgfSByZXR1cm4gVDtcbn0gOiAkYXNzaWduO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LWFzc2lnbi5qc1xuLy8gbW9kdWxlIGlkID0gMTA5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gZ2xvYmFsW1wiQ2xpcGJvYXJkXCJdID0gcmVxdWlyZShcIi0hRDpcXFxcdGlja2V0bWFzdGVyLWFwaS1zdGFnaW5nLmdpdGh1Yi5pb1xcXFxub2RlX21vZHVsZXNcXFxcYmFiZWwtbG9hZGVyXFxcXGluZGV4LmpzP3tcXFwicHJlc2V0c1xcXCI6W1xcXCJlczIwMTVcXFwiLFxcXCJzdGFnZS0wXFxcIl0sXFxcInBsdWdpbnNcXFwiOltcXFwidHJhbnNmb3JtLXJ1bnRpbWVcXFwiLFxcXCJ0cmFuc2Zvcm0tZGVjb3JhdG9ycy1sZWdhY3lcXFwiXSxcXFwiY2FjaGVEaXJlY3RvcnlcXFwiOnRydWV9IUQ6XFxcXHRpY2tldG1hc3Rlci1hcGktc3RhZ2luZy5naXRodWIuaW9cXFxcc2NyaXB0c1xcXFx2ZW5kb3JzXFxcXGNsaXBib2FyZC5qc1wiKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vZXhwb3NlLWxvYWRlcj9DbGlwYm9hcmQhLi9zY3JpcHRzL3ZlbmRvcnMvY2xpcGJvYXJkLmpzXG4vLyBtb2R1bGUgaWQgPSAxMTBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyohXHJcbiAqIGNsaXBib2FyZC5qcyB2MS41LjVcclxuICogaHR0cHM6Ly96ZW5vcm9jaGEuZ2l0aHViLmlvL2NsaXBib2FyZC5qc1xyXG4gKlxyXG4gKiBMaWNlbnNlZCBNSVQgwqkgWmVubyBSb2NoYVxyXG4gKi9cclxuIWZ1bmN0aW9uKHQpe2lmKFwib2JqZWN0XCI9PXR5cGVvZiBleHBvcnRzJiZcInVuZGVmaW5lZFwiIT10eXBlb2YgbW9kdWxlKW1vZHVsZS5leHBvcnRzPXQoKTtlbHNlIGlmKFwiZnVuY3Rpb25cIj09dHlwZW9mIGRlZmluZSYmZGVmaW5lLmFtZClkZWZpbmUoW10sdCk7ZWxzZXt2YXIgZTtlPVwidW5kZWZpbmVkXCIhPXR5cGVvZiB3aW5kb3c/d2luZG93OlwidW5kZWZpbmVkXCIhPXR5cGVvZiBnbG9iYWw/Z2xvYmFsOlwidW5kZWZpbmVkXCIhPXR5cGVvZiBzZWxmP3NlbGY6dGhpcyxlLkNsaXBib2FyZD10KCl9fShmdW5jdGlvbigpe3ZhciB0LGUsbjtyZXR1cm4gZnVuY3Rpb24gdChlLG4scil7ZnVuY3Rpb24gbyhhLGMpe2lmKCFuW2FdKXtpZighZVthXSl7dmFyIHM9XCJmdW5jdGlvblwiPT10eXBlb2YgcmVxdWlyZSYmcmVxdWlyZTtpZighYyYmcylyZXR1cm4gcyhhLCEwKTtpZihpKXJldHVybiBpKGEsITApO3ZhciB1PW5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIrYStcIidcIik7dGhyb3cgdS5jb2RlPVwiTU9EVUxFX05PVF9GT1VORFwiLHV9dmFyIGw9blthXT17ZXhwb3J0czp7fX07ZVthXVswXS5jYWxsKGwuZXhwb3J0cyxmdW5jdGlvbih0KXt2YXIgbj1lW2FdWzFdW3RdO3JldHVybiBvKG4/bjp0KX0sbCxsLmV4cG9ydHMsdCxlLG4scil9cmV0dXJuIG5bYV0uZXhwb3J0c31mb3IodmFyIGk9XCJmdW5jdGlvblwiPT10eXBlb2YgcmVxdWlyZSYmcmVxdWlyZSxhPTA7YTxyLmxlbmd0aDthKyspbyhyW2FdKTtyZXR1cm4gb30oezE6W2Z1bmN0aW9uKHQsZSxuKXt2YXIgcj10KFwibWF0Y2hlcy1zZWxlY3RvclwiKTtlLmV4cG9ydHM9ZnVuY3Rpb24odCxlLG4pe2Zvcih2YXIgbz1uP3Q6dC5wYXJlbnROb2RlO28mJm8hPT1kb2N1bWVudDspe2lmKHIobyxlKSlyZXR1cm4gbztvPW8ucGFyZW50Tm9kZX19fSx7XCJtYXRjaGVzLXNlbGVjdG9yXCI6Mn1dLDI6W2Z1bmN0aW9uKHQsZSxuKXtmdW5jdGlvbiByKHQsZSl7aWYoaSlyZXR1cm4gaS5jYWxsKHQsZSk7Zm9yKHZhciBuPXQucGFyZW50Tm9kZS5xdWVyeVNlbGVjdG9yQWxsKGUpLHI9MDtyPG4ubGVuZ3RoOysrcilpZihuW3JdPT10KXJldHVybiEwO3JldHVybiExfXZhciBvPUVsZW1lbnQucHJvdG90eXBlLGk9by5tYXRjaGVzU2VsZWN0b3J8fG8ud2Via2l0TWF0Y2hlc1NlbGVjdG9yfHxvLm1vek1hdGNoZXNTZWxlY3Rvcnx8by5tc01hdGNoZXNTZWxlY3Rvcnx8by5vTWF0Y2hlc1NlbGVjdG9yO2UuZXhwb3J0cz1yfSx7fV0sMzpbZnVuY3Rpb24odCxlLG4pe2Z1bmN0aW9uIHIodCxlLG4scil7dmFyIGk9by5hcHBseSh0aGlzLGFyZ3VtZW50cyk7cmV0dXJuIHQuYWRkRXZlbnRMaXN0ZW5lcihuLGkpLHtkZXN0cm95OmZ1bmN0aW9uKCl7dC5yZW1vdmVFdmVudExpc3RlbmVyKG4saSl9fX1mdW5jdGlvbiBvKHQsZSxuLHIpe3JldHVybiBmdW5jdGlvbihuKXtuLmRlbGVnYXRlVGFyZ2V0PWkobi50YXJnZXQsZSwhMCksbi5kZWxlZ2F0ZVRhcmdldCYmci5jYWxsKHQsbil9fXZhciBpPXQoXCJjbG9zZXN0XCIpO2UuZXhwb3J0cz1yfSx7Y2xvc2VzdDoxfV0sNDpbZnVuY3Rpb24odCxlLG4pe24ubm9kZT1mdW5jdGlvbih0KXtyZXR1cm4gdm9pZCAwIT09dCYmdCBpbnN0YW5jZW9mIEhUTUxFbGVtZW50JiYxPT09dC5ub2RlVHlwZX0sbi5ub2RlTGlzdD1mdW5jdGlvbih0KXt2YXIgZT1PYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodCk7cmV0dXJuIHZvaWQgMCE9PXQmJihcIltvYmplY3QgTm9kZUxpc3RdXCI9PT1lfHxcIltvYmplY3QgSFRNTENvbGxlY3Rpb25dXCI9PT1lKSYmXCJsZW5ndGhcImluIHQmJigwPT09dC5sZW5ndGh8fG4ubm9kZSh0WzBdKSl9LG4uc3RyaW5nPWZ1bmN0aW9uKHQpe3JldHVyblwic3RyaW5nXCI9PXR5cGVvZiB0fHx0IGluc3RhbmNlb2YgU3RyaW5nfSxuLmZ1bmN0aW9uPWZ1bmN0aW9uKHQpe3ZhciBlPU9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh0KTtyZXR1cm5cIltvYmplY3QgRnVuY3Rpb25dXCI9PT1lfX0se31dLDU6W2Z1bmN0aW9uKHQsZSxuKXtmdW5jdGlvbiByKHQsZSxuKXtpZighdCYmIWUmJiFuKXRocm93IG5ldyBFcnJvcihcIk1pc3NpbmcgcmVxdWlyZWQgYXJndW1lbnRzXCIpO2lmKCFjLnN0cmluZyhlKSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiU2Vjb25kIGFyZ3VtZW50IG11c3QgYmUgYSBTdHJpbmdcIik7aWYoIWMuZnVuY3Rpb24obikpdGhyb3cgbmV3IFR5cGVFcnJvcihcIlRoaXJkIGFyZ3VtZW50IG11c3QgYmUgYSBGdW5jdGlvblwiKTtpZihjLm5vZGUodCkpcmV0dXJuIG8odCxlLG4pO2lmKGMubm9kZUxpc3QodCkpcmV0dXJuIGkodCxlLG4pO2lmKGMuc3RyaW5nKHQpKXJldHVybiBhKHQsZSxuKTt0aHJvdyBuZXcgVHlwZUVycm9yKFwiRmlyc3QgYXJndW1lbnQgbXVzdCBiZSBhIFN0cmluZywgSFRNTEVsZW1lbnQsIEhUTUxDb2xsZWN0aW9uLCBvciBOb2RlTGlzdFwiKX1mdW5jdGlvbiBvKHQsZSxuKXtyZXR1cm4gdC5hZGRFdmVudExpc3RlbmVyKGUsbikse2Rlc3Ryb3k6ZnVuY3Rpb24oKXt0LnJlbW92ZUV2ZW50TGlzdGVuZXIoZSxuKX19fWZ1bmN0aW9uIGkodCxlLG4pe3JldHVybiBBcnJheS5wcm90b3R5cGUuZm9yRWFjaC5jYWxsKHQsZnVuY3Rpb24odCl7dC5hZGRFdmVudExpc3RlbmVyKGUsbil9KSx7ZGVzdHJveTpmdW5jdGlvbigpe0FycmF5LnByb3RvdHlwZS5mb3JFYWNoLmNhbGwodCxmdW5jdGlvbih0KXt0LnJlbW92ZUV2ZW50TGlzdGVuZXIoZSxuKX0pfX19ZnVuY3Rpb24gYSh0LGUsbil7cmV0dXJuIHMoZG9jdW1lbnQuYm9keSx0LGUsbil9dmFyIGM9dChcIi4vaXNcIikscz10KFwiZGVsZWdhdGVcIik7ZS5leHBvcnRzPXJ9LHtcIi4vaXNcIjo0LGRlbGVnYXRlOjN9XSw2OltmdW5jdGlvbih0LGUsbil7ZnVuY3Rpb24gcih0KXt2YXIgZTtpZihcIklOUFVUXCI9PT10Lm5vZGVOYW1lfHxcIlRFWFRBUkVBXCI9PT10Lm5vZGVOYW1lKXQuZm9jdXMoKSx0LnNldFNlbGVjdGlvblJhbmdlKDAsdC52YWx1ZS5sZW5ndGgpLGU9dC52YWx1ZTtlbHNle3QuaGFzQXR0cmlidXRlKFwiY29udGVudGVkaXRhYmxlXCIpJiZ0LmZvY3VzKCk7dmFyIG49d2luZG93LmdldFNlbGVjdGlvbigpLHI9ZG9jdW1lbnQuY3JlYXRlUmFuZ2UoKTtyLnNlbGVjdE5vZGVDb250ZW50cyh0KSxuLnJlbW92ZUFsbFJhbmdlcygpLG4uYWRkUmFuZ2UociksZT1uLnRvU3RyaW5nKCl9cmV0dXJuIGV9ZS5leHBvcnRzPXJ9LHt9XSw3OltmdW5jdGlvbih0LGUsbil7ZnVuY3Rpb24gcigpe31yLnByb3RvdHlwZT17b246ZnVuY3Rpb24odCxlLG4pe3ZhciByPXRoaXMuZXx8KHRoaXMuZT17fSk7cmV0dXJuKHJbdF18fChyW3RdPVtdKSkucHVzaCh7Zm46ZSxjdHg6bn0pLHRoaXN9LG9uY2U6ZnVuY3Rpb24odCxlLG4pe2Z1bmN0aW9uIHIoKXtvLm9mZih0LHIpLGUuYXBwbHkobixhcmd1bWVudHMpfXZhciBvPXRoaXM7cmV0dXJuIHIuXz1lLHRoaXMub24odCxyLG4pfSxlbWl0OmZ1bmN0aW9uKHQpe3ZhciBlPVtdLnNsaWNlLmNhbGwoYXJndW1lbnRzLDEpLG49KCh0aGlzLmV8fCh0aGlzLmU9e30pKVt0XXx8W10pLnNsaWNlKCkscj0wLG89bi5sZW5ndGg7Zm9yKHI7bz5yO3IrKyluW3JdLmZuLmFwcGx5KG5bcl0uY3R4LGUpO3JldHVybiB0aGlzfSxvZmY6ZnVuY3Rpb24odCxlKXt2YXIgbj10aGlzLmV8fCh0aGlzLmU9e30pLHI9blt0XSxvPVtdO2lmKHImJmUpZm9yKHZhciBpPTAsYT1yLmxlbmd0aDthPmk7aSsrKXJbaV0uZm4hPT1lJiZyW2ldLmZuLl8hPT1lJiZvLnB1c2gocltpXSk7cmV0dXJuIG8ubGVuZ3RoP25bdF09bzpkZWxldGUgblt0XSx0aGlzfX0sZS5leHBvcnRzPXJ9LHt9XSw4OltmdW5jdGlvbih0LGUsbil7XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gcih0KXtyZXR1cm4gdCYmdC5fX2VzTW9kdWxlP3Q6e1wiZGVmYXVsdFwiOnR9fWZ1bmN0aW9uIG8odCxlKXtpZighKHQgaW5zdGFuY2VvZiBlKSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpfW4uX19lc01vZHVsZT0hMDt2YXIgaT1mdW5jdGlvbigpe2Z1bmN0aW9uIHQodCxlKXtmb3IodmFyIG49MDtuPGUubGVuZ3RoO24rKyl7dmFyIHI9ZVtuXTtyLmVudW1lcmFibGU9ci5lbnVtZXJhYmxlfHwhMSxyLmNvbmZpZ3VyYWJsZT0hMCxcInZhbHVlXCJpbiByJiYoci53cml0YWJsZT0hMCksT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsci5rZXkscil9fXJldHVybiBmdW5jdGlvbihlLG4scil7cmV0dXJuIG4mJnQoZS5wcm90b3R5cGUsbiksciYmdChlLHIpLGV9fSgpLGE9dChcInNlbGVjdFwiKSxjPXIoYSkscz1mdW5jdGlvbigpe2Z1bmN0aW9uIHQoZSl7byh0aGlzLHQpLHRoaXMucmVzb2x2ZU9wdGlvbnMoZSksdGhpcy5pbml0U2VsZWN0aW9uKCl9cmV0dXJuIHQucHJvdG90eXBlLnJlc29sdmVPcHRpb25zPWZ1bmN0aW9uIHQoKXt2YXIgZT1hcmd1bWVudHMubGVuZ3RoPD0wfHx2b2lkIDA9PT1hcmd1bWVudHNbMF0/e306YXJndW1lbnRzWzBdO3RoaXMuYWN0aW9uPWUuYWN0aW9uLHRoaXMuZW1pdHRlcj1lLmVtaXR0ZXIsdGhpcy50YXJnZXQ9ZS50YXJnZXQsdGhpcy50ZXh0PWUudGV4dCx0aGlzLnRyaWdnZXI9ZS50cmlnZ2VyLHRoaXMuc2VsZWN0ZWRUZXh0PVwiXCJ9LHQucHJvdG90eXBlLmluaXRTZWxlY3Rpb249ZnVuY3Rpb24gdCgpe2lmKHRoaXMudGV4dCYmdGhpcy50YXJnZXQpdGhyb3cgbmV3IEVycm9yKCdNdWx0aXBsZSBhdHRyaWJ1dGVzIGRlY2xhcmVkLCB1c2UgZWl0aGVyIFwidGFyZ2V0XCIgb3IgXCJ0ZXh0XCInKTtpZih0aGlzLnRleHQpdGhpcy5zZWxlY3RGYWtlKCk7ZWxzZXtpZighdGhpcy50YXJnZXQpdGhyb3cgbmV3IEVycm9yKCdNaXNzaW5nIHJlcXVpcmVkIGF0dHJpYnV0ZXMsIHVzZSBlaXRoZXIgXCJ0YXJnZXRcIiBvciBcInRleHRcIicpO3RoaXMuc2VsZWN0VGFyZ2V0KCl9fSx0LnByb3RvdHlwZS5zZWxlY3RGYWtlPWZ1bmN0aW9uIHQoKXt2YXIgZT10aGlzO3RoaXMucmVtb3ZlRmFrZSgpLHRoaXMuZmFrZUhhbmRsZXI9ZG9jdW1lbnQuYm9keS5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIixmdW5jdGlvbigpe3JldHVybiBlLnJlbW92ZUZha2UoKX0pLHRoaXMuZmFrZUVsZW09ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInRleHRhcmVhXCIpLHRoaXMuZmFrZUVsZW0uc3R5bGUucG9zaXRpb249XCJhYnNvbHV0ZVwiLHRoaXMuZmFrZUVsZW0uc3R5bGUubGVmdD1cIi05OTk5cHhcIix0aGlzLmZha2VFbGVtLnN0eWxlLnRvcD0od2luZG93LnBhZ2VZT2Zmc2V0fHxkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsVG9wKStcInB4XCIsdGhpcy5mYWtlRWxlbS5zZXRBdHRyaWJ1dGUoXCJyZWFkb25seVwiLFwiXCIpLHRoaXMuZmFrZUVsZW0udmFsdWU9dGhpcy50ZXh0LGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQodGhpcy5mYWtlRWxlbSksdGhpcy5zZWxlY3RlZFRleHQ9Yy5kZWZhdWx0KHRoaXMuZmFrZUVsZW0pLHRoaXMuY29weVRleHQoKX0sdC5wcm90b3R5cGUucmVtb3ZlRmFrZT1mdW5jdGlvbiB0KCl7dGhpcy5mYWtlSGFuZGxlciYmKGRvY3VtZW50LmJvZHkucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIpLHRoaXMuZmFrZUhhbmRsZXI9bnVsbCksdGhpcy5mYWtlRWxlbSYmKGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQodGhpcy5mYWtlRWxlbSksdGhpcy5mYWtlRWxlbT1udWxsKX0sdC5wcm90b3R5cGUuc2VsZWN0VGFyZ2V0PWZ1bmN0aW9uIHQoKXt0aGlzLnNlbGVjdGVkVGV4dD1jLmRlZmF1bHQodGhpcy50YXJnZXQpLHRoaXMuY29weVRleHQoKX0sdC5wcm90b3R5cGUuY29weVRleHQ9ZnVuY3Rpb24gdCgpe3ZhciBlPXZvaWQgMDt0cnl7ZT1kb2N1bWVudC5leGVjQ29tbWFuZCh0aGlzLmFjdGlvbil9Y2F0Y2gobil7ZT0hMX10aGlzLmhhbmRsZVJlc3VsdChlKX0sdC5wcm90b3R5cGUuaGFuZGxlUmVzdWx0PWZ1bmN0aW9uIHQoZSl7ZT90aGlzLmVtaXR0ZXIuZW1pdChcInN1Y2Nlc3NcIix7YWN0aW9uOnRoaXMuYWN0aW9uLHRleHQ6dGhpcy5zZWxlY3RlZFRleHQsdHJpZ2dlcjp0aGlzLnRyaWdnZXIsY2xlYXJTZWxlY3Rpb246dGhpcy5jbGVhclNlbGVjdGlvbi5iaW5kKHRoaXMpfSk6dGhpcy5lbWl0dGVyLmVtaXQoXCJlcnJvclwiLHthY3Rpb246dGhpcy5hY3Rpb24sdHJpZ2dlcjp0aGlzLnRyaWdnZXIsY2xlYXJTZWxlY3Rpb246dGhpcy5jbGVhclNlbGVjdGlvbi5iaW5kKHRoaXMpfSl9LHQucHJvdG90eXBlLmNsZWFyU2VsZWN0aW9uPWZ1bmN0aW9uIHQoKXt0aGlzLnRhcmdldCYmdGhpcy50YXJnZXQuYmx1cigpLHdpbmRvdy5nZXRTZWxlY3Rpb24oKS5yZW1vdmVBbGxSYW5nZXMoKX0sdC5wcm90b3R5cGUuZGVzdHJveT1mdW5jdGlvbiB0KCl7dGhpcy5yZW1vdmVGYWtlKCl9LGkodCxbe2tleTpcImFjdGlvblwiLHNldDpmdW5jdGlvbiB0KCl7dmFyIGU9YXJndW1lbnRzLmxlbmd0aDw9MHx8dm9pZCAwPT09YXJndW1lbnRzWzBdP1wiY29weVwiOmFyZ3VtZW50c1swXTtpZih0aGlzLl9hY3Rpb249ZSxcImNvcHlcIiE9PXRoaXMuX2FjdGlvbiYmXCJjdXRcIiE9PXRoaXMuX2FjdGlvbil0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgXCJhY3Rpb25cIiB2YWx1ZSwgdXNlIGVpdGhlciBcImNvcHlcIiBvciBcImN1dFwiJyl9LGdldDpmdW5jdGlvbiB0KCl7cmV0dXJuIHRoaXMuX2FjdGlvbn19LHtrZXk6XCJ0YXJnZXRcIixzZXQ6ZnVuY3Rpb24gdChlKXtpZih2b2lkIDAhPT1lKXtpZighZXx8XCJvYmplY3RcIiE9dHlwZW9mIGV8fDEhPT1lLm5vZGVUeXBlKXRocm93IG5ldyBFcnJvcignSW52YWxpZCBcInRhcmdldFwiIHZhbHVlLCB1c2UgYSB2YWxpZCBFbGVtZW50Jyk7dGhpcy5fdGFyZ2V0PWV9fSxnZXQ6ZnVuY3Rpb24gdCgpe3JldHVybiB0aGlzLl90YXJnZXR9fV0pLHR9KCk7bi5kZWZhdWx0PXMsZS5leHBvcnRzPW4uZGVmYXVsdH0se3NlbGVjdDo2fV0sOTpbZnVuY3Rpb24odCxlLG4pe1widXNlIHN0cmljdFwiO2Z1bmN0aW9uIHIodCl7cmV0dXJuIHQmJnQuX19lc01vZHVsZT90OntcImRlZmF1bHRcIjp0fX1mdW5jdGlvbiBvKHQsZSl7aWYoISh0IGluc3RhbmNlb2YgZSkpdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKX1mdW5jdGlvbiBpKHQsZSl7aWYoXCJmdW5jdGlvblwiIT10eXBlb2YgZSYmbnVsbCE9PWUpdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIrdHlwZW9mIGUpO3QucHJvdG90eXBlPU9iamVjdC5jcmVhdGUoZSYmZS5wcm90b3R5cGUse2NvbnN0cnVjdG9yOnt2YWx1ZTp0LGVudW1lcmFibGU6ITEsd3JpdGFibGU6ITAsY29uZmlndXJhYmxlOiEwfX0pLGUmJihPYmplY3Quc2V0UHJvdG90eXBlT2Y/T2JqZWN0LnNldFByb3RvdHlwZU9mKHQsZSk6dC5fX3Byb3RvX189ZSl9ZnVuY3Rpb24gYSh0LGUpe3ZhciBuPVwiZGF0YS1jbGlwYm9hcmQtXCIrdDtpZihlLmhhc0F0dHJpYnV0ZShuKSlyZXR1cm4gZS5nZXRBdHRyaWJ1dGUobil9bi5fX2VzTW9kdWxlPSEwO3ZhciBjPXQoXCIuL2NsaXBib2FyZC1hY3Rpb25cIikscz1yKGMpLHU9dChcInRpbnktZW1pdHRlclwiKSxsPXIodSksZj10KFwiZ29vZC1saXN0ZW5lclwiKSxkPXIoZiksaD1mdW5jdGlvbih0KXtmdW5jdGlvbiBlKG4scil7byh0aGlzLGUpLHQuY2FsbCh0aGlzKSx0aGlzLnJlc29sdmVPcHRpb25zKHIpLHRoaXMubGlzdGVuQ2xpY2sobil9cmV0dXJuIGkoZSx0KSxlLnByb3RvdHlwZS5yZXNvbHZlT3B0aW9ucz1mdW5jdGlvbiB0KCl7dmFyIGU9YXJndW1lbnRzLmxlbmd0aDw9MHx8dm9pZCAwPT09YXJndW1lbnRzWzBdP3t9OmFyZ3VtZW50c1swXTt0aGlzLmFjdGlvbj1cImZ1bmN0aW9uXCI9PXR5cGVvZiBlLmFjdGlvbj9lLmFjdGlvbjp0aGlzLmRlZmF1bHRBY3Rpb24sdGhpcy50YXJnZXQ9XCJmdW5jdGlvblwiPT10eXBlb2YgZS50YXJnZXQ/ZS50YXJnZXQ6dGhpcy5kZWZhdWx0VGFyZ2V0LHRoaXMudGV4dD1cImZ1bmN0aW9uXCI9PXR5cGVvZiBlLnRleHQ/ZS50ZXh0OnRoaXMuZGVmYXVsdFRleHR9LGUucHJvdG90eXBlLmxpc3RlbkNsaWNrPWZ1bmN0aW9uIHQoZSl7dmFyIG49dGhpczt0aGlzLmxpc3RlbmVyPWQuZGVmYXVsdChlLFwiY2xpY2tcIixmdW5jdGlvbih0KXtyZXR1cm4gbi5vbkNsaWNrKHQpfSl9LGUucHJvdG90eXBlLm9uQ2xpY2s9ZnVuY3Rpb24gdChlKXt2YXIgbj1lLmRlbGVnYXRlVGFyZ2V0fHxlLmN1cnJlbnRUYXJnZXQ7dGhpcy5jbGlwYm9hcmRBY3Rpb24mJih0aGlzLmNsaXBib2FyZEFjdGlvbj1udWxsKSx0aGlzLmNsaXBib2FyZEFjdGlvbj1uZXcgcy5kZWZhdWx0KHthY3Rpb246dGhpcy5hY3Rpb24obiksdGFyZ2V0OnRoaXMudGFyZ2V0KG4pLHRleHQ6dGhpcy50ZXh0KG4pLHRyaWdnZXI6bixlbWl0dGVyOnRoaXN9KX0sZS5wcm90b3R5cGUuZGVmYXVsdEFjdGlvbj1mdW5jdGlvbiB0KGUpe3JldHVybiBhKFwiYWN0aW9uXCIsZSl9LGUucHJvdG90eXBlLmRlZmF1bHRUYXJnZXQ9ZnVuY3Rpb24gdChlKXt2YXIgbj1hKFwidGFyZ2V0XCIsZSk7cmV0dXJuIG4/ZG9jdW1lbnQucXVlcnlTZWxlY3RvcihuKTp2b2lkIDB9LGUucHJvdG90eXBlLmRlZmF1bHRUZXh0PWZ1bmN0aW9uIHQoZSl7cmV0dXJuIGEoXCJ0ZXh0XCIsZSl9LGUucHJvdG90eXBlLmRlc3Ryb3k9ZnVuY3Rpb24gdCgpe3RoaXMubGlzdGVuZXIuZGVzdHJveSgpLHRoaXMuY2xpcGJvYXJkQWN0aW9uJiYodGhpcy5jbGlwYm9hcmRBY3Rpb24uZGVzdHJveSgpLHRoaXMuY2xpcGJvYXJkQWN0aW9uPW51bGwpfSxlfShsLmRlZmF1bHQpO24uZGVmYXVsdD1oLGUuZXhwb3J0cz1uLmRlZmF1bHR9LHtcIi4vY2xpcGJvYXJkLWFjdGlvblwiOjgsXCJnb29kLWxpc3RlbmVyXCI6NSxcInRpbnktZW1pdHRlclwiOjd9XX0se30sWzldKSg5KX0pO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NjcmlwdHMvdmVuZG9ycy9jbGlwYm9hcmQuanMiLCJtb2R1bGUuZXhwb3J0cyA9IHsgXCJkZWZhdWx0XCI6IHJlcXVpcmUoXCJjb3JlLWpzL2xpYnJhcnkvZm4vb2JqZWN0L3NldC1wcm90b3R5cGUtb2ZcIiksIF9fZXNNb2R1bGU6IHRydWUgfTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vYmFiZWwtcnVudGltZS9jb3JlLWpzL29iamVjdC9zZXQtcHJvdG90eXBlLW9mLmpzXG4vLyBtb2R1bGUgaWQgPSAxMTJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwicmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9lczYub2JqZWN0LnNldC1wcm90b3R5cGUtb2YnKTtcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9fY29yZScpLk9iamVjdC5zZXRQcm90b3R5cGVPZjtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9saWJyYXJ5L2ZuL29iamVjdC9zZXQtcHJvdG90eXBlLW9mLmpzXG4vLyBtb2R1bGUgaWQgPSAxMTNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gMTkuMS4zLjE5IE9iamVjdC5zZXRQcm90b3R5cGVPZihPLCBwcm90bylcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG4kZXhwb3J0KCRleHBvcnQuUywgJ09iamVjdCcsIHtzZXRQcm90b3R5cGVPZjogcmVxdWlyZSgnLi9fc2V0LXByb3RvJykuc2V0fSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNi5vYmplY3Quc2V0LXByb3RvdHlwZS1vZi5qc1xuLy8gbW9kdWxlIGlkID0gMTE0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIFdvcmtzIHdpdGggX19wcm90b19fIG9ubHkuIE9sZCB2OCBjYW4ndCB3b3JrIHdpdGggbnVsbCBwcm90byBvYmplY3RzLlxuLyogZXNsaW50LWRpc2FibGUgbm8tcHJvdG8gKi9cbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpXG4gICwgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcbnZhciBjaGVjayA9IGZ1bmN0aW9uKE8sIHByb3RvKXtcbiAgYW5PYmplY3QoTyk7XG4gIGlmKCFpc09iamVjdChwcm90bykgJiYgcHJvdG8gIT09IG51bGwpdGhyb3cgVHlwZUVycm9yKHByb3RvICsgXCI6IGNhbid0IHNldCBhcyBwcm90b3R5cGUhXCIpO1xufTtcbm1vZHVsZS5leHBvcnRzID0ge1xuICBzZXQ6IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCAoJ19fcHJvdG9fXycgaW4ge30gPyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gICAgZnVuY3Rpb24odGVzdCwgYnVnZ3ksIHNldCl7XG4gICAgICB0cnkge1xuICAgICAgICBzZXQgPSByZXF1aXJlKCcuL19jdHgnKShGdW5jdGlvbi5jYWxsLCByZXF1aXJlKCcuL19vYmplY3QtZ29wZCcpLmYoT2JqZWN0LnByb3RvdHlwZSwgJ19fcHJvdG9fXycpLnNldCwgMik7XG4gICAgICAgIHNldCh0ZXN0LCBbXSk7XG4gICAgICAgIGJ1Z2d5ID0gISh0ZXN0IGluc3RhbmNlb2YgQXJyYXkpO1xuICAgICAgfSBjYXRjaChlKXsgYnVnZ3kgPSB0cnVlOyB9XG4gICAgICByZXR1cm4gZnVuY3Rpb24gc2V0UHJvdG90eXBlT2YoTywgcHJvdG8pe1xuICAgICAgICBjaGVjayhPLCBwcm90byk7XG4gICAgICAgIGlmKGJ1Z2d5KU8uX19wcm90b19fID0gcHJvdG87XG4gICAgICAgIGVsc2Ugc2V0KE8sIHByb3RvKTtcbiAgICAgICAgcmV0dXJuIE87XG4gICAgICB9O1xuICAgIH0oe30sIGZhbHNlKSA6IHVuZGVmaW5lZCksXG4gIGNoZWNrOiBjaGVja1xufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3NldC1wcm90by5qc1xuLy8gbW9kdWxlIGlkID0gMTE1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0geyBcImRlZmF1bHRcIjogcmVxdWlyZShcImNvcmUtanMvbGlicmFyeS9mbi9vYmplY3QvY3JlYXRlXCIpLCBfX2VzTW9kdWxlOiB0cnVlIH07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9vYmplY3QvY3JlYXRlLmpzXG4vLyBtb2R1bGUgaWQgPSAxMTZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwicmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9lczYub2JqZWN0LmNyZWF0ZScpO1xudmFyICRPYmplY3QgPSByZXF1aXJlKCcuLi8uLi9tb2R1bGVzL19jb3JlJykuT2JqZWN0O1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBjcmVhdGUoUCwgRCl7XG4gIHJldHVybiAkT2JqZWN0LmNyZWF0ZShQLCBEKTtcbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbGlicmFyeS9mbi9vYmplY3QvY3JlYXRlLmpzXG4vLyBtb2R1bGUgaWQgPSAxMTdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKVxyXG4vLyAxOS4xLjIuMiAvIDE1LjIuMy41IE9iamVjdC5jcmVhdGUoTyBbLCBQcm9wZXJ0aWVzXSlcclxuJGV4cG9ydCgkZXhwb3J0LlMsICdPYmplY3QnLCB7Y3JlYXRlOiByZXF1aXJlKCcuL19vYmplY3QtY3JlYXRlJyl9KTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM2Lm9iamVjdC5jcmVhdGUuanNcbi8vIG1vZHVsZSBpZCA9IDExOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKiFcclxuKiBDbGFtcC5qcyAwLjUuMVxyXG4qXHJcbiogQ29weXJpZ2h0IDIwMTEtMjAxMywgSm9zZXBoIFNjaG1pdHQgaHR0cDovL2pvZS5zaFxyXG4qIFJlbGVhc2VkIHVuZGVyIHRoZSBXVEZQTCBsaWNlbnNlXHJcbiogaHR0cDovL3NhbS56b3kub3JnL3d0ZnBsL1xyXG4qL1xyXG4oZnVuY3Rpb24oKXt3aW5kb3cuJGNsYW1wPWZ1bmN0aW9uKGMsZCl7ZnVuY3Rpb24gcyhhLGIpe24uZ2V0Q29tcHV0ZWRTdHlsZXx8KG4uZ2V0Q29tcHV0ZWRTdHlsZT1mdW5jdGlvbihhLGIpe3RoaXMuZWw9YTt0aGlzLmdldFByb3BlcnR5VmFsdWU9ZnVuY3Rpb24oYil7dmFyIGM9LyhcXC0oW2Etel0pezF9KS9nO1wiZmxvYXRcIj09YiYmKGI9XCJzdHlsZUZsb2F0XCIpO2MudGVzdChiKSYmKGI9Yi5yZXBsYWNlKGMsZnVuY3Rpb24oYSxiLGMpe3JldHVybiBjLnRvVXBwZXJDYXNlKCl9KSk7cmV0dXJuIGEuY3VycmVudFN0eWxlJiZhLmN1cnJlbnRTdHlsZVtiXT9hLmN1cnJlbnRTdHlsZVtiXTpudWxsfTtyZXR1cm4gdGhpc30pO3JldHVybiBuLmdldENvbXB1dGVkU3R5bGUoYSxudWxsKS5nZXRQcm9wZXJ0eVZhbHVlKGIpfWZ1bmN0aW9uIHQoYSl7YT1hfHxjLmNsaWVudEhlaWdodDt2YXIgYj11KGMpO3JldHVybiBNYXRoLm1heChNYXRoLmZsb29yKGEvYiksMCl9ZnVuY3Rpb24geChhKXtyZXR1cm4gdShjKSpcclxuYX1mdW5jdGlvbiB1KGEpe3ZhciBiPXMoYSxcImxpbmUtaGVpZ2h0XCIpO1wibm9ybWFsXCI9PWImJihiPTEuMipwYXJzZUludChzKGEsXCJmb250LXNpemVcIikpKTtyZXR1cm4gcGFyc2VJbnQoYil9ZnVuY3Rpb24gbChhKXtpZihhLmxhc3RDaGlsZC5jaGlsZHJlbiYmMDxhLmxhc3RDaGlsZC5jaGlsZHJlbi5sZW5ndGgpcmV0dXJuIGwoQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYS5jaGlsZHJlbikucG9wKCkpO2lmKGEubGFzdENoaWxkJiZhLmxhc3RDaGlsZC5ub2RlVmFsdWUmJlwiXCIhPWEubGFzdENoaWxkLm5vZGVWYWx1ZSYmYS5sYXN0Q2hpbGQubm9kZVZhbHVlIT1iLnRydW5jYXRpb25DaGFyKXJldHVybiBhLmxhc3RDaGlsZDthLmxhc3RDaGlsZC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGEubGFzdENoaWxkKTtyZXR1cm4gbChjKX1mdW5jdGlvbiBwKGEsZCl7aWYoZCl7dmFyIGU9YS5ub2RlVmFsdWUucmVwbGFjZShiLnRydW5jYXRpb25DaGFyLFwiXCIpO2Z8fChoPTA8ay5sZW5ndGg/XHJcbmsuc2hpZnQoKTpcIlwiLGY9ZS5zcGxpdChoKSk7MTxmLmxlbmd0aD8ocT1mLnBvcCgpLHIoYSxmLmpvaW4oaCkpKTpmPW51bGw7bSYmKGEubm9kZVZhbHVlPWEubm9kZVZhbHVlLnJlcGxhY2UoYi50cnVuY2F0aW9uQ2hhcixcIlwiKSxjLmlubmVySFRNTD1hLm5vZGVWYWx1ZStcIiBcIittLmlubmVySFRNTCtiLnRydW5jYXRpb25DaGFyKTtpZihmKXtpZihjLmNsaWVudEhlaWdodDw9ZClpZigwPD1rLmxlbmd0aCYmXCJcIiE9aClyKGEsZi5qb2luKGgpK2grcSksZj1udWxsO2Vsc2UgcmV0dXJuIGMuaW5uZXJIVE1MfWVsc2VcIlwiPT1oJiYocihhLFwiXCIpLGE9bChjKSxrPWIuc3BsaXRPbkNoYXJzLnNsaWNlKDApLGg9a1swXSxxPWY9bnVsbCk7aWYoYi5hbmltYXRlKXNldFRpbWVvdXQoZnVuY3Rpb24oKXtwKGEsZCl9LCEwPT09Yi5hbmltYXRlPzEwOmIuYW5pbWF0ZSk7ZWxzZSByZXR1cm4gcChhLGQpfX1mdW5jdGlvbiByKGEsYyl7YS5ub2RlVmFsdWU9YytiLnRydW5jYXRpb25DaGFyfWQ9ZHx8e307XHJcbnZhciBuPXdpbmRvdyxiPXtjbGFtcDpkLmNsYW1wfHwyLHVzZU5hdGl2ZUNsYW1wOlwidW5kZWZpbmVkXCIhPXR5cGVvZiBkLnVzZU5hdGl2ZUNsYW1wP2QudXNlTmF0aXZlQ2xhbXA6ITAsc3BsaXRPbkNoYXJzOmQuc3BsaXRPbkNoYXJzfHxbXCIuXCIsXCItXCIsXCJcXHUyMDEzXCIsXCJcXHUyMDE0XCIsXCIgXCJdLGFuaW1hdGU6ZC5hbmltYXRlfHwhMSx0cnVuY2F0aW9uQ2hhcjpkLnRydW5jYXRpb25DaGFyfHxcIlxcdTIwMjZcIix0cnVuY2F0aW9uSFRNTDpkLnRydW5jYXRpb25IVE1MfSxlPWMuc3R5bGUseT1jLmlubmVySFRNTCx6PVwidW5kZWZpbmVkXCIhPXR5cGVvZiBjLnN0eWxlLndlYmtpdExpbmVDbGFtcCxnPWIuY2xhbXAsdj1nLmluZGV4T2YmJigtMTxnLmluZGV4T2YoXCJweFwiKXx8LTE8Zy5pbmRleE9mKFwiZW1cIikpLG07Yi50cnVuY2F0aW9uSFRNTCYmKG09ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNwYW5cIiksbS5pbm5lckhUTUw9Yi50cnVuY2F0aW9uSFRNTCk7dmFyIGs9Yi5zcGxpdE9uQ2hhcnMuc2xpY2UoMCksXHJcbmg9a1swXSxmLHE7XCJhdXRvXCI9PWc/Zz10KCk6diYmKGc9dChwYXJzZUludChnKSkpO3ZhciB3O3omJmIudXNlTmF0aXZlQ2xhbXA/KGUub3ZlcmZsb3c9XCJoaWRkZW5cIixlLnRleHRPdmVyZmxvdz1cImVsbGlwc2lzXCIsZS53ZWJraXRCb3hPcmllbnQ9XCJ2ZXJ0aWNhbFwiLGUuZGlzcGxheT1cIi13ZWJraXQtYm94XCIsZS53ZWJraXRMaW5lQ2xhbXA9Zyx2JiYoZS5oZWlnaHQ9Yi5jbGFtcCtcInB4XCIpKTooZT14KGcpLGU8PWMuY2xpZW50SGVpZ2h0JiYodz1wKGwoYyksZSkpKTtyZXR1cm57b3JpZ2luYWw6eSxjbGFtcGVkOnd9fX0pKCk7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc2NyaXB0cy92ZW5kb3JzL2NsYW1wLm1pbi5qcyIsIi8vIGtub2Nrb3V0LXBvc3Rib3ggMC41LjIgfCAoYykgMjAxNSBSeWFuIE5pZW1leWVyIHwgIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2VcbjsoZnVuY3Rpb24oZmFjdG9yeSkge1xuICAgIC8vQ29tbW9uSlNcbiAgICBpZiAodHlwZW9mIHJlcXVpcmUgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgZXhwb3J0cyA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgbW9kdWxlID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIGZhY3RvcnkocmVxdWlyZShcImtub2Nrb3V0XCIpLCBleHBvcnRzKTtcbiAgICAvL0FNRFxuICAgIH0gZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQpIHtcbiAgICAgICAgZGVmaW5lKFtcImtub2Nrb3V0XCIsIFwiZXhwb3J0c1wiXSwgZmFjdG9yeSk7XG4gICAgLy9ub3JtYWwgc2NyaXB0IHRhZ1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGZhY3Rvcnkoa28sIGtvLnBvc3Rib3ggPSB7fSk7XG4gICAgfVxufShmdW5jdGlvbihrbywgZXhwb3J0cywgdW5kZWZpbmVkKSB7XG4gICAgdmFyIGRpc3Bvc2VUb3BpY1N1YnNjcmlwdGlvbiwgZXhpc3RpbmdTdWJzY3JpYmUsXG5cdFx0c3Vic2NyaXB0aW9ucyA9IHt9LFxuXHRcdHN1YklkID0gMTtcblxuXHRleHBvcnRzLnN1YnNjcmlwdGlvbnMgPSBzdWJzY3JpcHRpb25zO1xuXG4gICAgLy9jcmVhdGUgYSBnbG9iYWwgcG9zdGJveCB0aGF0IHN1cHBvcnRzIHN1YnNjcmliaW5nL3B1Ymxpc2hpbmdcbiAgICBrby5zdWJzY3JpYmFibGUuY2FsbChleHBvcnRzKTtcblxuICAgIC8va2VlcCBhIGNhY2hlIG9mIHRoZSBsYXRlc3QgdmFsdWUgYW5kIHN1YnNjcmliZXJzXG4gICAgZXhwb3J0cy50b3BpY0NhY2hlID0ge307XG5cbiAgICAvL2FsbG93IGN1c3RvbWl6YXRpb24gb2YgdGhlIGZ1bmN0aW9uIHVzZWQgdG8gc2VyaWFsaXplIHZhbHVlcyBmb3IgdGhlIHRvcGljIGNhY2hlXG4gICAgZXhwb3J0cy5zZXJpYWxpemVyID0ga28udG9KU09OO1xuXG4gICAgLy93cmFwIG5vdGlmeVN1YnNjcmliZXJzIHBhc3NpbmcgdG9waWMgZmlyc3QgYW5kIGNhY2hpbmcgbGF0ZXN0IHZhbHVlXG4gICAgZXhwb3J0cy5wdWJsaXNoID0gZnVuY3Rpb24odG9waWMsIHZhbHVlKSB7XG4gICAgICAgIGlmICh0b3BpYykge1xuICAgICAgICAgICAgLy9rZWVwIHRoZSB2YWx1ZSBhbmQgYSBzZXJpYWxpemVkIHZlcnNpb24gZm9yIGNvbXBhcmlzb25cbiAgICAgICAgICAgIGV4cG9ydHMudG9waWNDYWNoZVt0b3BpY10gPSB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICAgICAgICAgIHNlcmlhbGl6ZWQ6IGV4cG9ydHMuc2VyaWFsaXplcih2YWx1ZSlcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBleHBvcnRzLm5vdGlmeVN1YnNjcmliZXJzKHZhbHVlLCB0b3BpYyk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLy9wcm92aWRlIGEgc3Vic2NyaWJlIEFQSSBmb3IgdGhlIHBvc3Rib3ggdGhhdCB0YWtlcyBpbiB0aGUgdG9waWMgYXMgZmlyc3QgYXJnXG4gICAgZXhpc3RpbmdTdWJzY3JpYmUgPSBleHBvcnRzLnN1YnNjcmliZTtcbiAgICBleHBvcnRzLnN1YnNjcmliZSA9IGZ1bmN0aW9uKHRvcGljLCBhY3Rpb24sIHRhcmdldCwgaW5pdGlhbGl6ZVdpdGhMYXRlc3RWYWx1ZSkge1xuICAgICAgICB2YXIgc3Vic2NyaXB0aW9uLCBjdXJyZW50LCBleGlzdGluZ0Rpc3Bvc2U7XG5cbiAgICAgICAgaWYgKHRvcGljKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHRhcmdldCA9PT0gXCJib29sZWFuXCIpIHtcbiAgICAgICAgICAgICAgICBpbml0aWFsaXplV2l0aExhdGVzdFZhbHVlID0gdGFyZ2V0O1xuICAgICAgICAgICAgICAgIHRhcmdldCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgc3Vic2NyaXB0aW9uID0gZXhpc3RpbmdTdWJzY3JpYmUuY2FsbChleHBvcnRzLCBhY3Rpb24sIHRhcmdldCwgdG9waWMpO1xuXHRcdFx0c3Vic2NyaXB0aW9uLnN1YklkID0gKytzdWJJZDtcblx0XHRcdHN1YnNjcmlwdGlvbnNbIHN1YklkIF0gPSBzdWJzY3JpcHRpb247XG5cbiAgICAgICAgICAgIGlmIChpbml0aWFsaXplV2l0aExhdGVzdFZhbHVlKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudCA9IGV4cG9ydHMudG9waWNDYWNoZVt0b3BpY107XG5cbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGFjdGlvbi5jYWxsKHRhcmdldCwgY3VycmVudC52YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG5cdFx0XHRleGlzdGluZ0Rpc3Bvc2UgPSBzdWJzY3JpcHRpb24uZGlzcG9zZTtcblx0XHRcdHN1YnNjcmlwdGlvbi5kaXNwb3NlID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGRlbGV0ZSBzdWJzY3JpcHRpb25zW3N1YnNjcmlwdGlvbi5zdWJJZF07XG5cdFx0XHRcdGV4aXN0aW5nRGlzcG9zZS5jYWxsKHN1YnNjcmlwdGlvbik7XG5cdFx0XHR9O1xuXG4gICAgICAgICAgICByZXR1cm4gc3Vic2NyaXB0aW9uO1xuICAgICAgICB9XG4gICAgfTtcblxuXHQvL2NsZWFuIHVwIGFsbCBzdWJzY3JpcHRpb25zIGFuZCByZWZlcmVuY2VzXG5cdGV4cG9ydHMucmVzZXQgPSBmdW5jdGlvbigpIHtcblx0XHR2YXIgc3Vic2NyaXB0aW9uO1xuXG5cdFx0Zm9yICh2YXIgaWQgaW4gc3Vic2NyaXB0aW9ucykge1xuXHRcdFx0aWYgKHN1YnNjcmlwdGlvbnMuaGFzT3duUHJvcGVydHkoaWQpKSB7XG5cdFx0XHRcdHN1YnNjcmlwdGlvbiA9IHN1YnNjcmlwdGlvbnNbaWRdO1xuXG5cdFx0XHRcdGlmIChzdWJzY3JpcHRpb24gJiYgdHlwZW9mIHN1YnNjcmlwdGlvbi5kaXNwb3NlID09PSBcImZ1bmN0aW9uXCIpIHtcblx0XHRcdFx0XHRzdWJzY3JpcHRpb24uZGlzcG9zZSgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0ZXhwb3J0cy50b3BpY0NhY2hlID0ge307XG5cdH07XG5cbiAgICAvL2J5IGRlZmF1bHQgcHVibGlzaCB3aGVuIHRoZSBwcmV2aW91cyBjYWNoZWQgdmFsdWUgZG9lcyBub3QgZXF1YWwgdGhlIG5ldyB2YWx1ZVxuICAgIGV4cG9ydHMuZGVmYXVsdENvbXBhcmVyID0gZnVuY3Rpb24obmV3VmFsdWUsIGNhY2hlSXRlbSkge1xuICAgICAgICByZXR1cm4gY2FjaGVJdGVtICYmIGV4cG9ydHMuc2VyaWFsaXplcihuZXdWYWx1ZSkgPT09IGNhY2hlSXRlbS5zZXJpYWxpemVkO1xuICAgIH07XG5cbiAgICAvL2F1Z21lbnQgb2JzZXJ2YWJsZXMvY29tcHV0ZWRzIHdpdGggdGhlIGFiaWxpdHkgdG8gYXV0b21hdGljYWxseSBwdWJsaXNoIHVwZGF0ZXMgb24gYSB0b3BpY1xuICAgIGtvLnN1YnNjcmliYWJsZS5mbi5wdWJsaXNoT24gPSBmdW5jdGlvbih0b3BpYywgc2tpcEluaXRpYWxPckVxdWFsaXR5Q29tcGFyZXIsIGVxdWFsaXR5Q29tcGFyZXIpIHtcbiAgICAgICAgdmFyIHNraXBJbml0aWFsUHVibGlzaCwgc3Vic2NyaXB0aW9uLCBleGlzdGluZ0Rpc3Bvc2U7XG5cbiAgICAgICAgaWYgKHRvcGljKSB7XG4gICAgICAgICAgICAvL2FsbG93IHBhc3NpbmcgdGhlIGVxdWFsaXR5Q29tcGFyZXIgYXMgdGhlIHNlY29uZCBhcmd1bWVudFxuICAgICAgICAgICAgaWYgKHR5cGVvZiBza2lwSW5pdGlhbE9yRXF1YWxpdHlDb21wYXJlciA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgZXF1YWxpdHlDb21wYXJlciA9IHNraXBJbml0aWFsT3JFcXVhbGl0eUNvbXBhcmVyO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBza2lwSW5pdGlhbFB1Ymxpc2ggPSBza2lwSW5pdGlhbE9yRXF1YWxpdHlDb21wYXJlcjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZXF1YWxpdHlDb21wYXJlciA9IGVxdWFsaXR5Q29tcGFyZXIgfHwgZXhwb3J0cy5kZWZhdWx0Q29tcGFyZXI7XG5cbiAgICAgICAgICAgIC8vcmVtb3ZlIGFueSBleGlzdGluZyBzdWJzXG4gICAgICAgICAgICBkaXNwb3NlVG9waWNTdWJzY3JpcHRpb24uY2FsbCh0aGlzLCB0b3BpYywgXCJwdWJsaXNoT25cIik7XG5cbiAgICAgICAgICAgIC8va2VlcCBhIHJlZmVyZW5jZSB0byB0aGUgc3Vic2NyaXB0aW9uLCBzbyB3ZSBjYW4gc3RvcCBwdWJsaXNoaW5nXG4gICAgICAgICAgICBzdWJzY3JpcHRpb24gPSB0aGlzLnN1YnNjcmliZShmdW5jdGlvbihuZXdWYWx1ZSkge1xuXHRcdFx0XHRpZiAoIWVxdWFsaXR5Q29tcGFyZXIuY2FsbCh0aGlzLCBuZXdWYWx1ZSwgZXhwb3J0cy50b3BpY0NhY2hlW3RvcGljXSkpIHtcblx0XHRcdFx0XHRleHBvcnRzLnB1Ymxpc2godG9waWMsIG5ld1ZhbHVlKTtcblx0XHRcdFx0fVxuXHRcdFx0fSwgdGhpcyk7XG5cblx0XHRcdC8vdHJhY2sgdGhlIHN1YnNjcmlwdGlvbiBpbiBjYXNlIG9mIGEgcmVzZXRcblx0XHRcdHN1YnNjcmlwdGlvbi5pZCA9ICsrc3ViSWQ7XG5cdFx0XHRzdWJzY3JpcHRpb25zW3N1YklkXSA9IHN1YnNjcmlwdGlvbjtcblxuXHRcdFx0Ly9lbnN1cmUgdGhhdCB3ZSBjbGVhbnVwIHBvaW50ZXJzIHRvIHN1YnNjcmlwdGlvbiBvbiBkaXNwb3NlXG5cdFx0XHRleGlzdGluZ0Rpc3Bvc2UgPSBzdWJzY3JpcHRpb24uZGlzcG9zZTtcblx0XHRcdHN1YnNjcmlwdGlvbi5kaXNwb3NlID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGRlbGV0ZSB0aGlzLnBvc3Rib3hTdWJzW3RvcGljXS5wdWJsaXNoT247XG5cdFx0XHRcdGRlbGV0ZSBzdWJzY3JpcHRpb25zW3N1YnNjcmlwdGlvbi5pZF07XG5cblx0XHRcdFx0ZXhpc3RpbmdEaXNwb3NlLmNhbGwoc3Vic2NyaXB0aW9uKTtcblx0XHRcdH0uYmluZCh0aGlzKTtcblxuXHRcdFx0dGhpcy5wb3N0Ym94U3Vic1t0b3BpY10ucHVibGlzaE9uID0gc3Vic2NyaXB0aW9uO1xuXG4gICAgICAgICAgICAvL2RvIGFuIGluaXRpYWwgcHVibGlzaFxuICAgICAgICAgICAgaWYgKCFza2lwSW5pdGlhbFB1Ymxpc2gpIHtcbiAgICAgICAgICAgICAgICBleHBvcnRzLnB1Ymxpc2godG9waWMsIHRoaXMoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgLy9oYW5kbGUgZGlzcG9zaW5nIGEgc3Vic2NyaXB0aW9uIHVzZWQgdG8gcHVibGlzaCBvciBzdWJzY3JpYmUgdG8gYSB0b3BpY1xuICAgIGRpc3Bvc2VUb3BpY1N1YnNjcmlwdGlvbiA9IGZ1bmN0aW9uKHRvcGljLCB0eXBlKSB7XG4gICAgICAgIHZhciBzdWJzID0gdGhpcy5wb3N0Ym94U3VicyA9IHRoaXMucG9zdGJveFN1YnMgfHwge307XG4gICAgICAgIHN1YnNbdG9waWNdID0gc3Vic1t0b3BpY10gfHwge307XG5cbiAgICAgICAgaWYgKHN1YnNbdG9waWNdW3R5cGVdKSB7XG4gICAgICAgICAgICBzdWJzW3RvcGljXVt0eXBlXS5kaXNwb3NlKCk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLy9kaXNjb250aW51ZSBhdXRvbWF0aWNhbGx5IHB1Ymxpc2hpbmcgb24gYSB0b3BpY1xuICAgIGtvLnN1YnNjcmliYWJsZS5mbi5zdG9wUHVibGlzaGluZ09uID0gZnVuY3Rpb24odG9waWMpIHtcbiAgICAgICAgZGlzcG9zZVRvcGljU3Vic2NyaXB0aW9uLmNhbGwodGhpcywgdG9waWMsIFwicHVibGlzaE9uXCIpO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICAvL2F1Z21lbnQgb2JzZXJ2YWJsZXMvY29tcHV0ZWRzIHRvIGF1dG9tYXRpY2FsbHkgYmUgdXBkYXRlZCBieSBub3RpZmljYXRpb25zIG9uIGEgdG9waWNcbiAgICBrby5zdWJzY3JpYmFibGUuZm4uc3Vic2NyaWJlVG8gPSBmdW5jdGlvbih0b3BpYywgaW5pdGlhbGl6ZVdpdGhMYXRlc3RWYWx1ZU9yVHJhbnNmb3JtLCB0cmFuc2Zvcm0pIHtcbiAgICAgICAgdmFyIGluaXRpYWxpemVXaXRoTGF0ZXN0VmFsdWUsIGN1cnJlbnQsIGNhbGxiYWNrLCBzdWJzY3JpcHRpb24sIGV4aXN0aW5nRGlzcG9zZSxcbiAgICAgICAgICAgIHNlbGYgPSB0aGlzO1xuXG4gICAgICAgIC8vYWxsb3cgcGFzc2luZyB0aGUgZmlsdGVyIGFzIHRoZSBzZWNvbmQgYXJndW1lbnRcbiAgICAgICAgaWYgKHR5cGVvZiBpbml0aWFsaXplV2l0aExhdGVzdFZhbHVlT3JUcmFuc2Zvcm0gPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgdHJhbnNmb3JtID0gaW5pdGlhbGl6ZVdpdGhMYXRlc3RWYWx1ZU9yVHJhbnNmb3JtO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaW5pdGlhbGl6ZVdpdGhMYXRlc3RWYWx1ZSA9IGluaXRpYWxpemVXaXRoTGF0ZXN0VmFsdWVPclRyYW5zZm9ybTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0b3BpYyAmJiBrby5pc1dyaXRlYWJsZU9ic2VydmFibGUodGhpcykpIHtcbiAgICAgICAgICAgIC8vcmVtb3ZlIGFueSBleGlzdGluZyBzdWJzXG4gICAgICAgICAgICBkaXNwb3NlVG9waWNTdWJzY3JpcHRpb24uY2FsbCh0aGlzLCB0b3BpYywgXCJzdWJzY3JpYmVUb1wiKTtcblxuICAgICAgICAgICAgLy9pZiBzcGVjaWZpZWQsIGFwcGx5IGEgZmlsdGVyIGZ1bmN0aW9uIGluIHRoZSBzdWJzY3JpcHRpb25cbiAgICAgICAgICAgIGNhbGxiYWNrID0gZnVuY3Rpb24obmV3VmFsdWUpIHtcbiAgICAgICAgICAgICAgICBzZWxmKHRyYW5zZm9ybSA/IHRyYW5zZm9ybS5jYWxsKHNlbGYsIG5ld1ZhbHVlKSA6IG5ld1ZhbHVlKTtcbiAgICAgICAgICAgIH07XG5cblx0XHRcdC8vLy9rZWVwIGEgcmVmZXJlbmNlIHRvIHRoZSBzdWJzY3JpcHRpb24sIHNvIHdlIGNhbiB1bnN1YnNjcmliZSwgaWYgbmVjZXNzYXJ5XG5cdFx0XHRzdWJzY3JpcHRpb24gPSBleHBvcnRzLnN1YnNjcmliZSh0b3BpYywgY2FsbGJhY2spO1xuXHRcdFx0dGhpcy5wb3N0Ym94U3Vic1t0b3BpY10uc3Vic2NyaWJlVG8gPSBzdWJzY3JpcHRpb247XG5cblx0XHRcdC8vZW5zdXJlIHRoYXQgd2UgY2xlYW51cCBwb2ludGVycyB0byBzdWJzY3JpcHRpb24gb24gZGlzcG9zZVxuXHRcdFx0ZXhpc3RpbmdEaXNwb3NlID0gc3Vic2NyaXB0aW9uLmRpc3Bvc2U7XG5cdFx0XHRzdWJzY3JpcHRpb24uZGlzcG9zZSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRkZWxldGUgdGhpcy5wb3N0Ym94U3Vic1t0b3BpY10uc3Vic2NyaWJlVG87XG5cdFx0XHRcdGV4aXN0aW5nRGlzcG9zZS5jYWxsKHN1YnNjcmlwdGlvbik7XG5cdFx0XHR9LmJpbmQodGhpcyk7XG5cbiAgICAgICAgICAgIGlmIChpbml0aWFsaXplV2l0aExhdGVzdFZhbHVlKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudCA9IGV4cG9ydHMudG9waWNDYWNoZVt0b3BpY107XG5cbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKGN1cnJlbnQudmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICAvL2Rpc2NvbnRpbnVlIHJlY2VpdmluZyB1cGRhdGVzIG9uIGEgdG9waWNcbiAgICBrby5zdWJzY3JpYmFibGUuZm4udW5zdWJzY3JpYmVGcm9tID0gZnVuY3Rpb24odG9waWMpIHtcbiAgICAgICAgZGlzcG9zZVRvcGljU3Vic2NyaXB0aW9uLmNhbGwodGhpcywgdG9waWMsIFwic3Vic2NyaWJlVG9cIik7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIC8vIGJvdGggc3Vic2NyaWJlIGFuZCBwdWJsaXNoIG9uIHRoZSBzYW1lIHRvcGljXG4gICAgLy8gICAtYWxsb3dzIHRoZSBhYmlsaXR5IHRvIHN5bmMgYW4gb2JzZXJ2YWJsZS93cml0ZWFibGUgY29tcHV0ZWQvb2JzZXJ2YWJsZUFycmF5IGJldHdlZW4gdmlldyBtb2RlbHNcbiAgICAvLyAgIC1zdWJzY3JpYmVUbyBzaG91bGQgcmVhbGx5IG5vdCB1c2UgYSBmaWx0ZXIgZnVuY3Rpb24sIGFzIGl0IHdvdWxkIGxpa2VseSBjYXVzZSBpbmZpbml0ZSByZWN1cnNpb25cbiAgICBrby5zdWJzY3JpYmFibGUuZm4uc3luY1dpdGggPSBmdW5jdGlvbih0b3BpYywgaW5pdGlhbGl6ZVdpdGhMYXRlc3RWYWx1ZSwgc2tpcEluaXRpYWxPckVxdWFsaXR5Q29tcGFyZXIsIGVxdWFsaXR5Q29tcGFyZXIpIHtcbiAgICAgICAgdGhpcy5zdWJzY3JpYmVUbyh0b3BpYywgaW5pdGlhbGl6ZVdpdGhMYXRlc3RWYWx1ZSkucHVibGlzaE9uKHRvcGljLCBza2lwSW5pdGlhbE9yRXF1YWxpdHlDb21wYXJlciwgZXF1YWxpdHlDb21wYXJlcik7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIGtvLnBvc3Rib3ggPSBleHBvcnRzO1xufSkpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2tub2Nrb3V0LXBvc3Rib3gvYnVpbGQva25vY2tvdXQtcG9zdGJveC5qc1xuLy8gbW9kdWxlIGlkID0gMTIwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vSmF2YXNyaXB0IG5hbWU6IE15IERhdGUgVGltZSBQaWNrZXJcclxuLy9EYXRlIGNyZWF0ZWQ6IDE2LU5vdi0yMDAzIDIzOjE5XHJcbi8vQ3JlYXRvcjogVGVuZ1lvbmcgTmdcclxuLy9XZWJzaXRlOiBodHRwOi8vd3d3LnJhaW5mb3Jlc3RuZXQuY29tXHJcbi8vQ29weXJpZ2h0IChjKSAyMDAzIFRlbmdZb25nIE5nXHJcbi8vRmlsZU5hbWU6IERhdGVUaW1lUGlja2VyX2Nzcy5qc1xyXG4vL1ZlcnNpb246IDIuMi40XHJcbi8vIE5vdGU6IFBlcm1pc3Npb24gZ2l2ZW4gdG8gdXNlIGFuZCBtb2RpZnkgdGhpcyBzY3JpcHQgaW4gQU5ZIGtpbmQgb2YgYXBwbGljYXRpb25zIGlmXHJcbi8vICAgICAgIGhlYWRlciBsaW5lcyBhcmUgbGVmdCB1bmNoYW5nZWQuXHJcbi8vUGVybWlzc2lvbiBpcyBncmFudGVkIHRvIHJlZGlzdHJpYnV0ZSBhbmQgbW9kaWZ5IHRoaXMgamF2YXNjcmlwdCB1bmRlciBhIEZyZWVCU0QgTGljZW5zZS5cclxuLy9OZXcgQ3NzIHN0eWxlIHZlcnNpb24gYWRkZWQgYnkgWXZhbiBMYXZvaWUgKFF1w6liZWMsIENhbmFkYSkgMjktSmFuLTIwMDlcclxuLy9Gb3JtYXR0ZWQgZm9yIEpTTGludCBjb21wYXRpYmlsaXR5IGJ5IExhYnNtZWRpYS5jb20gKDMwLURlYy0yMDEwKVxyXG5cclxuXHJcbi8vR2xvYmFsIHZhcmlhYmxlc1xyXG5cclxud2luZG93LndpbkNhbCA9IHVuZGVmaW5lZDtcclxud2luZG93LmR0VG9kYXkgPSB1bmRlZmluZWQ7XHJcbndpbmRvdy5DYWwgPSB1bmRlZmluZWQ7XHJcbndpbmRvdy5leERhdGVUaW1lID0gdW5kZWZpbmVkOy8vRXhpc3RpbmcgRGF0ZSBhbmQgVGltZVxyXG53aW5kb3cuc2VsRGF0ZSA9IHVuZGVmaW5lZDsvL3NlbGVjdGVkIGRhdGUuIHZlcnNpb24gMS43XHJcbndpbmRvdy5jYWxTcGFuSUQgPSBcImNhbEJvcmRlclwiOyAvLyBzcGFuIElEXHJcbndpbmRvdy5kb21TdHlsZSA9IG51bGw7IC8vIHNwYW4gRE9NIG9iamVjdCB3aXRoIHN0eWxlXHJcbndpbmRvdy5jbkxlZnQgPSBcIjBcIjsvL2xlZnQgY29vcmRpbmF0ZSBvZiBjYWxlbmRhciBzcGFuXHJcbndpbmRvdy5jblRvcCA9IFwiMFwiOy8vdG9wIGNvb3JkaW5hdGUgb2YgY2FsZW5kYXIgc3BhblxyXG53aW5kb3cueHBvcyA9IDA7IC8vIG1vdXNlIHggcG9zaXRpb25cclxud2luZG93Lnlwb3MgPSAwOyAvLyBtb3VzZSB5IHBvc2l0aW9uXHJcbndpbmRvdy5jYWxIZWlnaHQgPSAwOyAvLyBjYWxlbmRhciBoZWlnaHRcclxud2luZG93LkNhbFdpZHRoID0gXCJhdXRvXCI7Ly8gY2FsZW5kYXIgd2lkdGhcclxud2luZG93LkNlbGxXaWR0aCA9IDM2Oy8vIHdpZHRoIG9mIGRheSBjZWxsLlxyXG53aW5kb3cuVGltZU1vZGUgPSAyNDsvLyBUaW1lTW9kZSB2YWx1ZS4gMTIgb3IgMjRcclxud2luZG93LlN0YXJ0WWVhciA9IHBhcnNlSW50KG5ldyBEYXRlKCkuZ2V0RnVsbFllYXIoKSk7IC8vRmlyc3QgWWVhciBpbiBkcm9wIGRvd24geWVhciBzZWxlY3Rpb25cclxud2luZG93LkVuZFllYXIgPSA1OyAvLyBUaGUgbGFzdCB5ZWFyIG9mIHBpY2thYmxlIGRhdGUuIGlmIGN1cnJlbnQgeWVhciBpcyAyMDExLCB0aGUgbGFzdCB5ZWFyIHRoYXQgc3RpbGwgcGlja2VyIHdpbGwgYmUgMjAxNiAoMjAxMSs1KVxyXG53aW5kb3cuQ2FsUG9zT2Zmc2V0WCA9IC0yMjc7IC8vWCBwb3NpdGlvbiBvZmZzZXQgcmVsYXRpdmUgdG8gY2FsZW5kYXIgaWNvbiwgY2FuIGJlIG5lZ2F0aXZlIHZhbHVlXHJcbndpbmRvdy5DYWxQb3NPZmZzZXRZID0gLTIzMDsgLy9ZIHBvc2l0aW9uIG9mZnNldCByZWxhdGl2ZSB0byBjYWxlbmRhciBpY29uLCBjYW4gYmUgbmVnYXRpdmUgdmFsdWVcclxud2luZG93LnNob3dNb250aEluSGVhZCA9IFwiZGlzcGxheTpub25lO1wiO1xyXG4vL0NvbmZpZ3VyYWJsZSBwYXJhbWV0ZXJzIHN0YXJ0XHJcbndpbmRvdy5TcGFuQm9yZGVyQ29sb3IgPSBcIiNjY2NjY2NcIjsvL3NwYW4gYm9yZGVyIGNvbG9yXHJcbndpbmRvdy5TcGFuQmdDb2xvciA9IFwiI0ZGRkZGRlwiOyAvL3NwYW4gYmFja2dyb3VuZCBjb2xvclxyXG53aW5kb3cuTW9udGhZZWFyQ29sb3IgPSBcIiNjYzAwMzNcIjsgLy9Gb250IENvbG9yIG9mIE1vbnRoIGFuZCBZZWFyIGluIENhbGVuZGFyIGhlYWRlci5cclxud2luZG93LldlZWtIZWFkQ29sb3IgPSBcIiNiN2M5ZDNcIjsgLy92YXIgV2Vla0hlYWRDb2xvcj1cIiMxODg2MUJcIjsvL0JhY2tncm91bmQgQ29sb3IgaW4gV2VlayBoZWFkZXIuXHJcbndpbmRvdy5XZWVrSGVhZEJhY2tncm91bmQgPSBcIiNmZmZmZmZcIjsgLy92YXIgV2Vla0hlYWRDb2xvcj1cIiMxODg2MUJcIjsvL0JhY2tncm91bmQgQ29sb3IgaW4gV2VlayBoZWFkZXIuXHJcbndpbmRvdy5TdW5kYXlDb2xvciA9IFwiXCI7IC8vdmFyIFN1bmRheUNvbG9yPVwiI0MwRjY0RlwiOy8vQmFja2dyb3VuZCBjb2xvciBvZiBTdW5kYXkuXHJcbndpbmRvdy5TYXR1cmRheUNvbG9yID0gXCJcIjsgLy9CYWNrZ3JvdW5kIGNvbG9yIG9mIFNhdHVyZGF5LlxyXG53aW5kb3cuV2Vla0RheUNvbG9yID0gXCJcIjsgLy9CYWNrZ3JvdW5kIGNvbG9yIG9mIHdlZWtkYXlzLlxyXG53aW5kb3cuRm9udENvbG9yID0gXCJibHVlXCI7IC8vY29sb3Igb2YgZm9udCBpbiBDYWxlbmRhciBkYXkgY2VsbC5cclxud2luZG93LlRvZGF5Q29sb3IgPSAnZm9udC1mYW1pbHk6XCJUTVNhbnMtQm9sZFwiLEhlbHZldGljYSxBcmlhbCxzYW5zLXNlcmlmO2JveC1zaGFkb3c6MCAwIDJweCByZ2JhKDAsMCwwLDEpOyc7XHJcbndpbmRvdy5TZWxEYXRlQ29sb3IgPSAnZm9udC1mYW1pbHk6XCJUTVNhbnMtQm9sZFwiLEhlbHZldGljYSxBcmlhbCxzYW5zLXNlcmlmO2NvbG9yOiNmZmY7YmFja2dyb3VuZDojMTc5Y2RiOyc7XHJcbndpbmRvdy5ZclNlbENvbG9yID0gXCIjY2MwMDMzXCI7IC8vY29sb3Igb2YgZm9udCBvZiBZZWFyIHNlbGVjdG9yLlxyXG53aW5kb3cuTXRoU2VsQ29sb3IgPSBcIiNjYzAwMzNcIjsgLy9jb2xvciBvZiBmb250IG9mIE1vbnRoIHNlbGVjdG9yIGlmIFwiTW9udGhTZWxlY3RvclwiIGlzIFwiYXJyb3dcIi5cclxud2luZG93LkhvdmVyQ29sb3IgPSBcIiNFMEZGMzhcIjsgLy9jb2xvciB3aGVuIG1vdXNlIG1vdmUgb3Zlci5cclxud2luZG93LkRpc2FibGVDb2xvciA9IFwiIzk5OTk2NlwiOyAvL2NvbG9yIG9mIGRpc2FibGVkIGNlbGwuXHJcbndpbmRvdy5DYWxCZ0NvbG9yID0gXCIjZmZmZmZmXCI7IC8vQmFja2dyb3VuZCBjb2xvciBvZiBDYWxlbmRhciB3aW5kb3cuXHJcbndpbmRvdy50b3BTZWxlY3RvckJnID0gXCIjZjFmNGY2XCI7XHJcblxyXG53aW5kb3cuV2Vla0NoYXIgPSAyOy8vbnVtYmVyIG9mIGNoYXJhY3RlciBmb3Igd2VlayBkYXkuIGlmIDIgdGhlbiBNbyxUdSxXZS4gaWYgMyB0aGVuIE1vbixUdWUsV2VkLlxyXG53aW5kb3cuRGF0ZVNlcGFyYXRvciA9IFwiLVwiOy8vRGF0ZSBTZXBhcmF0b3IsIHlvdSBjYW4gY2hhbmdlIGl0IHRvIFwiLVwiIGlmIHlvdSB3YW50LlxyXG53aW5kb3cuU2hvd0xvbmdNb250aCA9IHRydWU7Ly9TaG93IGxvbmcgbW9udGggbmFtZSBpbiBDYWxlbmRhciBoZWFkZXIuIGV4YW1wbGU6IFwiSmFudWFyeVwiLlxyXG53aW5kb3cuU2hvd01vbnRoWWVhciA9IHRydWU7Ly9TaG93IE1vbnRoIGFuZCBZZWFyIGluIENhbGVuZGFyIGhlYWRlci5cclxud2luZG93LlRoZW1lQmcgPSBcIlwiOy8vQmFja2dyb3VuZCBpbWFnZSBvZiBDYWxlbmRhciB3aW5kb3cuXHJcbndpbmRvdy5QcmVjZWRlWmVybyA9IHRydWU7Ly9QcmVjZWRpbmcgemVybyBbdHJ1ZXxmYWxzZV1cclxud2luZG93Lk1vbmRheUZpcnN0RGF5ID0gZmFsc2U7Ly90cnVlOlVzZSBNb25kYXkgYXMgZmlyc3QgZGF5OyBmYWxzZTpTdW5kYXkgYXMgZmlyc3QgZGF5LiBbdHJ1ZXxmYWxzZV0gIC8vYWRkZWQgaW4gdmVyc2lvbiAxLjdcclxud2luZG93LlVzZUltYWdlRmlsZXMgPSBmYWxzZTsvL1VzZSBpbWFnZSBmaWxlcyB3aXRoIFwiYXJyb3dzXCIgYW5kIFwiY2xvc2VcIiBidXR0b25cclxud2luZG93LmltYWdlRmlsZXNQYXRoID0gXCJpbWFnZXMyL1wiO1xyXG4vL0NvbmZpZ3VyYWJsZSBwYXJhbWV0ZXJzIGVuZFxyXG5cclxuLy91c2UgdGhlIE1vbnRoIGFuZCBXZWVrZGF5IGluIHlvdXIgcHJlZmVycmVkIGxhbmd1YWdlLlxyXG53aW5kb3cuTW9udGhOYW1lID0gW1wiSmFudWFyeVwiLCBcIkZlYnJ1YXJ5XCIsIFwiTWFyY2hcIiwgXCJBcHJpbFwiLCBcIk1heVwiLCBcIkp1bmVcIiwgXCJKdWx5XCIsIFwiQXVndXN0XCIsIFwiU2VwdGVtYmVyXCIsIFwiT2N0b2JlclwiLCBcIk5vdmVtYmVyXCIsIFwiRGVjZW1iZXJcIl07XHJcbndpbmRvdy5XZWVrRGF5TmFtZTEgPSBbXCJTXCIsIFwiTVwiLCBcIlRcIiwgXCJXXCIsIFwiVFwiLCBcIkZcIiwgXCJTXCJdO1xyXG53aW5kb3cuV2Vla0RheU5hbWUyID0gW1wiTW9uZGF5XCIsIFwiVHVlc2RheVwiLCBcIldlZG5lc2RheVwiLCBcIlRodXJzZGF5XCIsIFwiRnJpZGF5XCIsIFwiU2F0dXJkYXlcIiwgXCJTdW5kYXlcIl07XHJcblxyXG4vL2VuZCBDb25maWd1cmFibGUgcGFyYW1ldGVyc1xyXG5cclxuLy9lbmQgR2xvYmFsIHZhcmlhYmxlXHJcblxyXG4vLyBDYWxlbmRhciBwcm90b3R5cGVcclxuZnVuY3Rpb24gQ2FsZW5kYXIocERhdGUsIHBDdHJsKSB7XHJcblx0Ly9Qcm9wZXJ0aWVzXHJcblx0dGhpcy5EYXRlID0gcERhdGUuZ2V0RGF0ZSgpOy8vc2VsZWN0ZWQgZGF0ZVxyXG5cdHRoaXMuTW9udGggPSBwRGF0ZS5nZXRNb250aCgpOy8vc2VsZWN0ZWQgbW9udGggbnVtYmVyXHJcblx0dGhpcy5ZZWFyID0gcERhdGUuZ2V0RnVsbFllYXIoKTsvL3NlbGVjdGVkIHllYXIgaW4gNCBkaWdpdHNcclxuXHR0aGlzLkhvdXJzID0gcERhdGUuZ2V0SG91cnMoKTtcclxuXHJcblx0aWYgKHBEYXRlLmdldE1pbnV0ZXMoKSA8IDEwKSB7XHJcblx0XHR0aGlzLk1pbnV0ZXMgPSBcIjBcIiArIHBEYXRlLmdldE1pbnV0ZXMoKTtcclxuXHR9IGVsc2Uge1xyXG5cdFx0dGhpcy5NaW51dGVzID0gcERhdGUuZ2V0TWludXRlcygpO1xyXG5cdH1cclxuXHJcblx0aWYgKHBEYXRlLmdldFNlY29uZHMoKSA8IDEwKSB7XHJcblx0XHR0aGlzLlNlY29uZHMgPSBcIjBcIiArIHBEYXRlLmdldFNlY29uZHMoKTtcclxuXHR9IGVsc2Uge1xyXG5cdFx0dGhpcy5TZWNvbmRzID0gcERhdGUuZ2V0U2Vjb25kcygpO1xyXG5cdH1cclxuXHJcblx0dGhpcy5NeVdpbmRvdyA9IHdpbkNhbDtcclxuXHR0aGlzLkN0cmwgPSBwQ3RybDtcclxuXHR0aGlzLkZvcm1hdCA9IFwiZGRNTXl5eXlcIjtcclxuXHR0aGlzLlNlcGFyYXRvciA9IERhdGVTZXBhcmF0b3I7XHJcblx0dGhpcy5TaG93VGltZSA9IGZhbHNlO1xyXG5cdHRoaXMuU2Nyb2xsZXIgPSBcIkRST1BET1dOXCI7XHJcblxyXG5cdGlmIChwRGF0ZS5nZXRIb3VycygpIDwgMTIpIHtcclxuXHRcdHRoaXMuQU1vclBNID0gXCJBTVwiO1xyXG5cdH0gZWxzZSB7XHJcblx0XHR0aGlzLkFNb3JQTSA9IFwiUE1cIjtcclxuXHR9XHJcblxyXG5cdHRoaXMuU2hvd1NlY29uZHMgPSBmYWxzZTtcclxuXHR0aGlzLkVuYWJsZURhdGVNb2RlID0gXCJcIlxyXG59XHJcblxyXG5DYWxlbmRhci5wcm90b3R5cGUuR2V0TW9udGhJbmRleCA9IGZ1bmN0aW9uIChzaG9ydE1vbnRoTmFtZSkge1xyXG5cdGZvciAodmFyIGkgPSAwOyBpIDwgMTI7IGkgKz0gMSkge1xyXG5cdFx0aWYgKE1vbnRoTmFtZVtpXS5zdWJzdHJpbmcoMCwgMykudG9VcHBlckNhc2UoKSA9PT0gc2hvcnRNb250aE5hbWUudG9VcHBlckNhc2UoKSkge1xyXG5cdFx0XHRyZXR1cm4gaTtcclxuXHRcdH1cclxuXHR9XHJcbn07XHJcblxyXG5DYWxlbmRhci5wcm90b3R5cGUuSW5jWWVhciA9IGZ1bmN0aW9uICgpIHtcclxuXHRpZiAoQ2FsLlllYXIgPD0gZHRUb2RheS5nZXRGdWxsWWVhcigpK0VuZFllYXIpXHJcblx0XHRDYWwuWWVhciArPSAxO1xyXG59O1xyXG5cclxuQ2FsZW5kYXIucHJvdG90eXBlLkRlY1llYXIgPSBmdW5jdGlvbiAoKSB7XHJcblx0aWYgKENhbC5ZZWFyID4gU3RhcnRZZWFyKVxyXG5cdFx0Q2FsLlllYXIgLT0gMTtcclxufTtcclxuXHJcbkNhbGVuZGFyLnByb3RvdHlwZS5JbmNNb250aCA9IGZ1bmN0aW9uKCkge1xyXG5cdGlmIChDYWwuWWVhciA8PSBkdFRvZGF5LmdldEZ1bGxZZWFyKCkgKyBFbmRZZWFyKSB7XHJcblx0XHRDYWwuTW9udGggKz0gMTtcclxuXHRcdGlmIChDYWwuTW9udGggPj0gMTIpIHtcclxuXHRcdFx0Q2FsLk1vbnRoID0gMDtcclxuXHRcdFx0Q2FsLkluY1llYXIoKTtcclxuXHRcdH1cclxuXHR9XHJcbn07XHJcblxyXG5DYWxlbmRhci5wcm90b3R5cGUuRGVjTW9udGggPSBmdW5jdGlvbigpIHtcclxuXHRpZiAoQ2FsLlllYXIgPj0gU3RhcnRZZWFyKSB7XHJcblx0XHRDYWwuTW9udGggLT0gMTtcclxuXHRcdGlmIChDYWwuTW9udGggPCAwKSB7XHJcblx0XHRcdENhbC5Nb250aCA9IDExO1xyXG5cdFx0XHRDYWwuRGVjWWVhcigpO1xyXG5cdFx0fVxyXG5cdH1cclxufTtcclxuXHJcbkNhbGVuZGFyLnByb3RvdHlwZS5Td2l0Y2hNdGggPSBmdW5jdGlvbiAoaW50TXRoKSB7XHJcblx0Q2FsLk1vbnRoID0gcGFyc2VJbnQoaW50TXRoLCAxMCk7XHJcbn07XHJcblxyXG5DYWxlbmRhci5wcm90b3R5cGUuU3dpdGNoWWVhciA9IGZ1bmN0aW9uIChpbnRZZWFyKSB7XHJcblx0Q2FsLlllYXIgPSBwYXJzZUludChpbnRZZWFyLCAxMCk7XHJcbn07XHJcblxyXG5DYWxlbmRhci5wcm90b3R5cGUuU2V0SG91ciA9IGZ1bmN0aW9uKGludEhvdXIpIHtcclxuXHR2YXIgTWF4SG91cixcclxuXHRcdE1pbkhvdXIsXHJcblx0XHRIb3VyRXhwID0gbmV3IFJlZ0V4cChcIl5cXFxcZFxcXFxkXCIpLFxyXG5cdFx0U2luZ2xlRGlnaXQgPSBuZXcgUmVnRXhwKFwiXlxcXFxkezF9JFwiKTtcclxuXHJcblx0aWYgKFRpbWVNb2RlID09PSAyNCkge1xyXG5cdFx0TWF4SG91ciA9IDIzO1xyXG5cdFx0TWluSG91ciA9IDA7XHJcblx0fVxyXG5cdGVsc2UgaWYgKFRpbWVNb2RlID09PSAxMikge1xyXG5cdFx0TWF4SG91ciA9IDEyO1xyXG5cdFx0TWluSG91ciA9IDE7XHJcblx0fVxyXG5cdGVsc2Uge1xyXG5cdFx0YWxlcnQoXCJUaW1lTW9kZSBjYW4gb25seSBiZSAxMiBvciAyNFwiKTtcclxuXHR9XHJcblxyXG5cdGlmICgoSG91ckV4cC50ZXN0KGludEhvdXIpIHx8IFNpbmdsZURpZ2l0LnRlc3QoaW50SG91cikpICYmIChwYXJzZUludChpbnRIb3VyLCAxMCkgPiBNYXhIb3VyKSkge1xyXG5cdFx0aW50SG91ciA9IE1pbkhvdXI7XHJcblx0fVxyXG5cclxuXHRlbHNlIGlmICgoSG91ckV4cC50ZXN0KGludEhvdXIpIHx8IFNpbmdsZURpZ2l0LnRlc3QoaW50SG91cikpICYmIChwYXJzZUludChpbnRIb3VyLCAxMCkgPCBNaW5Ib3VyKSkge1xyXG5cdFx0aW50SG91ciA9IE1heEhvdXI7XHJcblx0fVxyXG5cclxuXHRpbnRIb3VyID0gcGFyc2VJbnQoaW50SG91ciwgMTApO1xyXG5cdGlmIChTaW5nbGVEaWdpdC50ZXN0KGludEhvdXIpKSB7XHJcblx0XHRpbnRIb3VyID0gXCIwXCIgKyBpbnRIb3VyO1xyXG5cdH1cclxuXHJcblx0aWYgKEhvdXJFeHAudGVzdChpbnRIb3VyKSAmJiAocGFyc2VJbnQoaW50SG91ciwgMTApIDw9IE1heEhvdXIpICYmIChwYXJzZUludChpbnRIb3VyLCAxMCkgPj0gTWluSG91cikpIHtcclxuXHRcdGlmICgoVGltZU1vZGUgPT09IDEyKSAmJiAoQ2FsLkFNb3JQTSA9PT0gXCJQTVwiKSkge1xyXG5cdFx0XHRpZiAocGFyc2VJbnQoaW50SG91ciwgMTApID09PSAxMikge1xyXG5cdFx0XHRcdENhbC5Ib3VycyA9IDEyO1xyXG5cdFx0XHR9XHJcblx0XHRcdGVsc2Uge1xyXG5cdFx0XHRcdENhbC5Ib3VycyA9IHBhcnNlSW50KGludEhvdXIsIDEwKSArIDEyO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0ZWxzZSBpZiAoKFRpbWVNb2RlID09PSAxMikgJiYgKENhbC5BTW9yUE0gPT09IFwiQU1cIikpIHtcclxuXHRcdFx0aWYgKGludEhvdXIgPT09IDEyKSB7XHJcblx0XHRcdFx0aW50SG91ciAtPSAxMjtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Q2FsLkhvdXJzID0gcGFyc2VJbnQoaW50SG91ciwgMTApO1xyXG5cdFx0fVxyXG5cclxuXHRcdGVsc2UgaWYgKFRpbWVNb2RlID09PSAyNCkge1xyXG5cdFx0XHRDYWwuSG91cnMgPSBwYXJzZUludChpbnRIb3VyLCAxMCk7XHJcblx0XHR9XHJcblx0fVxyXG5cclxufTtcclxuXHJcbkNhbGVuZGFyLnByb3RvdHlwZS5TZXRNaW51dGUgPSBmdW5jdGlvbiAoaW50TWluKSB7XHJcblx0dmFyIE1heE1pbiA9IDU5LFxyXG5cdFx0TWluTWluID0gMCxcclxuXHJcblx0XHRTaW5nbGVEaWdpdCA9IG5ldyBSZWdFeHAoXCJcXFxcZFwiKSxcclxuXHRcdFNpbmdsZURpZ2l0MiA9IG5ldyBSZWdFeHAoXCJeXFxcXGR7MX0kXCIpLFxyXG5cdFx0TWluRXhwID0gbmV3IFJlZ0V4cChcIl5cXFxcZHsyfSRcIiksXHJcblxyXG5cdFx0c3RyTWluID0gMDtcclxuXHJcblx0aWYgKChNaW5FeHAudGVzdChpbnRNaW4pIHx8IFNpbmdsZURpZ2l0LnRlc3QoaW50TWluKSkgJiYgKHBhcnNlSW50KGludE1pbiwgMTApID4gTWF4TWluKSlcclxuXHR7XHJcblx0XHRpbnRNaW4gPSBNaW5NaW47XHJcblx0fVxyXG5cclxuXHRlbHNlIGlmICgoTWluRXhwLnRlc3QoaW50TWluKSB8fCBTaW5nbGVEaWdpdC50ZXN0KGludE1pbikpICYmIChwYXJzZUludChpbnRNaW4sIDEwKSA8IE1pbk1pbikpXHJcblx0e1xyXG5cdFx0aW50TWluID0gTWF4TWluO1xyXG5cdH1cclxuXHJcblx0c3RyTWluID0gaW50TWluICsgXCJcIjtcclxuXHRpZiAoU2luZ2xlRGlnaXQyLnRlc3QoaW50TWluKSlcclxuXHR7XHJcblx0XHRzdHJNaW4gPSBcIjBcIiArIHN0ck1pbjtcclxuXHR9XHJcblxyXG5cdGlmICgoTWluRXhwLnRlc3QoaW50TWluKSB8fCBTaW5nbGVEaWdpdC50ZXN0KGludE1pbikpICYmIChwYXJzZUludChpbnRNaW4sIDEwKSA8PSA1OSkgJiYgKHBhcnNlSW50KGludE1pbiwgMTApID49IDApKVxyXG5cdHtcclxuXHRcdENhbC5NaW51dGVzID0gc3RyTWluO1xyXG5cdH1cclxufTtcclxuXHJcbkNhbGVuZGFyLnByb3RvdHlwZS5TZXRTZWNvbmQgPSBmdW5jdGlvbiAoaW50U2VjKSB7XHJcblx0dmFyIE1heFNlYyA9IDU5LFxyXG5cdFx0TWluU2VjID0gMCxcclxuXHJcblx0XHRTaW5nbGVEaWdpdCA9IG5ldyBSZWdFeHAoXCJcXFxcZFwiKSxcclxuXHRcdFNpbmdsZURpZ2l0MiA9IG5ldyBSZWdFeHAoXCJeXFxcXGR7MX0kXCIpLFxyXG5cdFx0U2VjRXhwID0gbmV3IFJlZ0V4cChcIl5cXFxcZHsyfSRcIiksXHJcblxyXG5cdFx0c3RyU2VjID0gMDtcclxuXHJcblx0aWYgKChTZWNFeHAudGVzdChpbnRTZWMpIHx8IFNpbmdsZURpZ2l0LnRlc3QoaW50U2VjKSkgJiYgKHBhcnNlSW50KGludFNlYywgMTApID4gTWF4U2VjKSlcclxuXHR7XHJcblx0XHRpbnRTZWMgPSBNaW5TZWM7XHJcblx0fVxyXG5cclxuXHRlbHNlIGlmICgoU2VjRXhwLnRlc3QoaW50U2VjKSB8fCBTaW5nbGVEaWdpdC50ZXN0KGludFNlYykpICYmIChwYXJzZUludChpbnRTZWMsIDEwKSA8IE1pblNlYykpXHJcblx0e1xyXG5cdFx0aW50U2VjID0gTWF4U2VjO1xyXG5cdH1cclxuXHJcblx0c3RyU2VjID0gaW50U2VjICsgXCJcIjtcclxuXHRpZiAoU2luZ2xlRGlnaXQyLnRlc3QoaW50U2VjKSlcclxuXHR7XHJcblx0XHRzdHJTZWMgPSBcIjBcIiArIHN0clNlYztcclxuXHR9XHJcblxyXG5cdGlmICgoU2VjRXhwLnRlc3QoaW50U2VjKSB8fCBTaW5nbGVEaWdpdC50ZXN0KGludFNlYykpICYmIChwYXJzZUludChpbnRTZWMsIDEwKSA8PSA1OSkgJiYgKHBhcnNlSW50KGludFNlYywgMTApID49IDApKVxyXG5cdHtcclxuXHRcdENhbC5TZWNvbmRzID0gc3RyU2VjO1xyXG5cdH1cclxuXHJcbn07XHJcblxyXG5DYWxlbmRhci5wcm90b3R5cGUuU2V0QW1QbSA9IGZ1bmN0aW9uIChwdmFsdWUpIHtcclxuXHR0aGlzLkFNb3JQTSA9IHB2YWx1ZTtcclxuXHRpZiAocHZhbHVlID09PSBcIlBNXCIpXHJcblx0e1xyXG5cdFx0dGhpcy5Ib3VycyA9IHBhcnNlSW50KHRoaXMuSG91cnMsIDEwKSArIDEyO1xyXG5cdFx0aWYgKHRoaXMuSG91cnMgPT09IDI0KVxyXG5cdFx0e1xyXG5cdFx0XHR0aGlzLkhvdXJzID0gMTI7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHRlbHNlIGlmIChwdmFsdWUgPT09IFwiQU1cIilcclxuXHR7XHJcblx0XHR0aGlzLkhvdXJzIC09IDEyO1xyXG5cdH1cclxufTtcclxuXHJcbkNhbGVuZGFyLnByb3RvdHlwZS5nZXRTaG93SG91ciA9IGZ1bmN0aW9uKCkge1xyXG5cdHZhciBmaW5hbEhvdXI7XHJcblxyXG5cdGlmIChUaW1lTW9kZSA9PT0gMTIpIHtcclxuXHRcdGlmIChwYXJzZUludCh0aGlzLkhvdXJzLCAxMCkgPT09IDApIHtcclxuXHRcdFx0dGhpcy5BTW9yUE0gPSBcIkFNXCI7XHJcblx0XHRcdGZpbmFsSG91ciA9IHBhcnNlSW50KHRoaXMuSG91cnMsIDEwKSArIDEyO1xyXG5cdFx0fVxyXG5cclxuXHRcdGVsc2UgaWYgKHBhcnNlSW50KHRoaXMuSG91cnMsIDEwKSA9PT0gMTIpIHtcclxuXHRcdFx0dGhpcy5BTW9yUE0gPSBcIlBNXCI7XHJcblx0XHRcdGZpbmFsSG91ciA9IDEyO1xyXG5cdFx0fVxyXG5cclxuXHRcdGVsc2UgaWYgKHRoaXMuSG91cnMgPiAxMikge1xyXG5cdFx0XHR0aGlzLkFNb3JQTSA9IFwiUE1cIjtcclxuXHRcdFx0aWYgKCh0aGlzLkhvdXJzIC0gMTIpIDwgMTApIHtcclxuXHRcdFx0XHRmaW5hbEhvdXIgPSBcIjBcIiArICgocGFyc2VJbnQodGhpcy5Ib3VycywgMTApKSAtIDEyKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRlbHNlIHtcclxuXHRcdFx0XHRmaW5hbEhvdXIgPSBwYXJzZUludCh0aGlzLkhvdXJzLCAxMCkgLSAxMjtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0ZWxzZSB7XHJcblx0XHRcdHRoaXMuQU1vclBNID0gXCJBTVwiO1xyXG5cdFx0XHRpZiAodGhpcy5Ib3VycyA8IDEwKSB7XHJcblx0XHRcdFx0ZmluYWxIb3VyID0gXCIwXCIgKyBwYXJzZUludCh0aGlzLkhvdXJzLCAxMCk7XHJcblx0XHRcdH1cclxuXHRcdFx0ZWxzZSB7XHJcblx0XHRcdFx0ZmluYWxIb3VyID0gdGhpcy5Ib3VycztcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0ZWxzZSBpZiAoVGltZU1vZGUgPT09IDI0KSB7XHJcblx0XHRpZiAodGhpcy5Ib3VycyA8IDEwKSB7XHJcblx0XHRcdGZpbmFsSG91ciA9IFwiMFwiICsgcGFyc2VJbnQodGhpcy5Ib3VycywgMTApO1xyXG5cdFx0fVxyXG5cdFx0ZWxzZSB7XHJcblx0XHRcdGZpbmFsSG91ciA9IHRoaXMuSG91cnM7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHRyZXR1cm4gZmluYWxIb3VyO1xyXG59O1xyXG5cclxuQ2FsZW5kYXIucHJvdG90eXBlLmdldFNob3dBTW9yUE0gPSBmdW5jdGlvbiAoKSB7XHJcblx0cmV0dXJuIHRoaXMuQU1vclBNO1xyXG59O1xyXG5cclxuQ2FsZW5kYXIucHJvdG90eXBlLkdldE1vbnRoTmFtZSA9IGZ1bmN0aW9uIChJc0xvbmcpIHtcclxuXHR2YXIgTW9udGggPSBNb250aE5hbWVbdGhpcy5Nb250aF07XHJcblx0aWYgKElzTG9uZylcclxuXHR7XHJcblx0XHRyZXR1cm4gTW9udGg7XHJcblx0fVxyXG5cdGVsc2VcclxuXHR7XHJcblx0XHRyZXR1cm4gTW9udGguc3Vic3RyKDAsIDMpO1xyXG5cdH1cclxufTtcclxuXHJcbkNhbGVuZGFyLnByb3RvdHlwZS5HZXRNb25EYXlzID0gZnVuY3Rpb24oKSB7IC8vR2V0IG51bWJlciBvZiBkYXlzIGluIGEgbW9udGhcclxuXHJcblx0dmFyIERheXNJbk1vbnRoID0gWzMxLCAyOCwgMzEsIDMwLCAzMSwgMzAsIDMxLCAzMSwgMzAsIDMxLCAzMCwgMzFdO1xyXG5cdGlmIChDYWwuSXNMZWFwWWVhcigpKSB7XHJcblx0XHREYXlzSW5Nb250aFsxXSA9IDI5O1xyXG5cdH1cclxuXHJcblx0cmV0dXJuIERheXNJbk1vbnRoW3RoaXMuTW9udGhdO1xyXG59O1xyXG5cclxuQ2FsZW5kYXIucHJvdG90eXBlLklzTGVhcFllYXIgPSBmdW5jdGlvbiAoKSB7XHJcblx0aWYgKCh0aGlzLlllYXIgJSA0KSA9PT0gMClcclxuXHR7XHJcblx0XHRpZiAoKHRoaXMuWWVhciAlIDEwMCA9PT0gMCkgJiYgKHRoaXMuWWVhciAlIDQwMCkgIT09IDApXHJcblx0XHR7XHJcblx0XHRcdHJldHVybiBmYWxzZTtcclxuXHRcdH1cclxuXHRcdGVsc2VcclxuXHRcdHtcclxuXHRcdFx0cmV0dXJuIHRydWU7XHJcblx0XHR9XHJcblx0fVxyXG5cdGVsc2VcclxuXHR7XHJcblx0XHRyZXR1cm4gZmFsc2U7XHJcblx0fVxyXG59O1xyXG5cclxuQ2FsZW5kYXIucHJvdG90eXBlLkZvcm1hdERhdGUgPSBmdW5jdGlvbiAocERhdGUpIHtcclxuXHR2YXIgTW9udGhEaWdpdCA9IHRoaXMuTW9udGggKyAxO1xyXG5cdGlmIChQcmVjZWRlWmVybyA9PT0gdHJ1ZSlcclxuXHR7XHJcblx0XHRpZiAoKHBEYXRlIDwgMTApICYmIFN0cmluZyhwRGF0ZSkubGVuZ3RoPT09MSkgLy9sZW5ndGggY2hlY2tpbmcgYWRkZWQgaW4gdmVyc2lvbiAyLjJcclxuXHRcdHtcclxuXHRcdFx0cERhdGUgPSBcIjBcIiArIHBEYXRlO1xyXG5cdFx0fVxyXG5cdFx0aWYgKE1vbnRoRGlnaXQgPCAxMClcclxuXHRcdHtcclxuXHRcdFx0TW9udGhEaWdpdCA9IFwiMFwiICsgTW9udGhEaWdpdDtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdHN3aXRjaCAodGhpcy5Gb3JtYXQudG9VcHBlckNhc2UoKSlcclxuXHR7XHJcblx0XHRjYXNlIFwiRERNTVlZWVlcIjpcclxuXHRcdFx0cmV0dXJuIChwRGF0ZSArIERhdGVTZXBhcmF0b3IgKyBNb250aERpZ2l0ICsgRGF0ZVNlcGFyYXRvciArIHRoaXMuWWVhcik7XHJcblx0XHRjYXNlIFwiRERNTU1ZWVlZXCI6XHJcblx0XHRcdHJldHVybiAocERhdGUgKyBEYXRlU2VwYXJhdG9yICsgdGhpcy5HZXRNb250aE5hbWUoZmFsc2UpICsgRGF0ZVNlcGFyYXRvciArIHRoaXMuWWVhcik7XHJcblx0XHRjYXNlIFwiTU1ERFlZWVlcIjpcclxuXHRcdFx0cmV0dXJuIChNb250aERpZ2l0ICsgRGF0ZVNlcGFyYXRvciArIHBEYXRlICsgRGF0ZVNlcGFyYXRvciArIHRoaXMuWWVhcik7XHJcblx0XHRjYXNlIFwiTU1NRERZWVlZXCI6XHJcblx0XHRcdHJldHVybiAodGhpcy5HZXRNb250aE5hbWUoZmFsc2UpICsgRGF0ZVNlcGFyYXRvciArIHBEYXRlICsgRGF0ZVNlcGFyYXRvciArIHRoaXMuWWVhcik7XHJcblx0XHRjYXNlIFwiWVlZWU1NRERcIjpcclxuXHRcdFx0cmV0dXJuICh0aGlzLlllYXIgKyBEYXRlU2VwYXJhdG9yICsgTW9udGhEaWdpdCArIERhdGVTZXBhcmF0b3IgKyBwRGF0ZSk7XHJcblx0XHRjYXNlIFwiWVlNTUREXCI6XHJcblx0XHRcdHJldHVybiAoU3RyaW5nKHRoaXMuWWVhcikuc3Vic3RyaW5nKDIsIDQpICsgRGF0ZVNlcGFyYXRvciArIE1vbnRoRGlnaXQgKyBEYXRlU2VwYXJhdG9yICsgcERhdGUpO1xyXG5cdFx0Y2FzZSBcIllZTU1NRERcIjpcclxuXHRcdFx0cmV0dXJuIChTdHJpbmcodGhpcy5ZZWFyKS5zdWJzdHJpbmcoMiwgNCkgKyBEYXRlU2VwYXJhdG9yICsgdGhpcy5HZXRNb250aE5hbWUoZmFsc2UpICsgRGF0ZVNlcGFyYXRvciArIHBEYXRlKTtcclxuXHRcdGNhc2UgXCJZWVlZTU1NRERcIjpcclxuXHRcdFx0cmV0dXJuICh0aGlzLlllYXIgKyBEYXRlU2VwYXJhdG9yICsgdGhpcy5HZXRNb250aE5hbWUoZmFsc2UpICsgRGF0ZVNlcGFyYXRvciArIHBEYXRlKTtcclxuXHRcdGRlZmF1bHQ6XHJcblx0XHRcdHJldHVybiAocERhdGUgKyBEYXRlU2VwYXJhdG9yICsgKHRoaXMuTW9udGggKyAxKSArIERhdGVTZXBhcmF0b3IgKyB0aGlzLlllYXIpO1xyXG5cdH1cclxufTtcclxuXHJcbi8vIGVuZCBDYWxlbmRhciBwcm90b3R5cGVcclxuXHJcbmZ1bmN0aW9uIEdlbkNlbGwocFZhbHVlLCBwSGlnaExpZ2h0LCBwQ29sb3IsIHBDbGlja2FibGUpIHsgLy9HZW5lcmF0ZSB0YWJsZSBjZWxsIHdpdGggdmFsdWVcclxuXHR2YXIgUFZhbHVlLFxyXG5cdFx0UENlbGxTdHIsXHJcblx0XHRQQ2xpY2thYmxlLFxyXG5cdFx0dlRpbWVTdHI7XHJcblxyXG5cdGlmICghcFZhbHVlKSB7XHJcblx0XHRQVmFsdWUgPSBcIlwiO1xyXG5cdH0gZWxzZSB7XHJcblx0XHRQVmFsdWUgPSBwVmFsdWU7XHJcblx0fVxyXG5cclxuXHRpZiAocENvbG9yID09PSB1bmRlZmluZWQpXHJcblx0XHRwQ29sb3IgPSBDYWxCZ0NvbG9yO1xyXG5cclxuXHRpZiAocENsaWNrYWJsZSAhPT0gdW5kZWZpbmVkKXtcclxuXHRcdFBDbGlja2FibGUgPSBwQ2xpY2thYmxlO1xyXG5cdH0gZWxzZSB7XHJcblx0XHRQQ2xpY2thYmxlID0gdHJ1ZTtcclxuXHR9XHJcblxyXG5cdGlmIChDYWwuU2hvd1RpbWUpIHtcclxuXHRcdHZUaW1lU3RyID0gJyAnICsgQ2FsLkhvdXJzICsgJzonICsgQ2FsLk1pbnV0ZXM7XHJcblx0XHRpZiAoQ2FsLlNob3dTZWNvbmRzKVxyXG5cdFx0e1xyXG5cdFx0XHR2VGltZVN0ciArPSAnOicgKyBDYWwuU2Vjb25kcztcclxuXHRcdH1cclxuXHRcdGlmIChUaW1lTW9kZSA9PT0gMTIpXHJcblx0XHR7XHJcblx0XHRcdHZUaW1lU3RyICs9ICcgJyArIENhbC5BTW9yUE07XHJcblx0XHR9XHJcblx0fSBlbHNlIHtcclxuXHRcdHZUaW1lU3RyID0gXCJcIjtcclxuXHR9XHJcblxyXG5cdGlmIChQVmFsdWUgIT09IFwiXCIpIHtcclxuXHRcdGlmIChQQ2xpY2thYmxlID09PSB0cnVlKSB7XHJcblx0XHRcdGlmIChDYWwuU2hvd1RpbWUgPT09IHRydWUpIHtcclxuXHRcdFx0XHRQQ2VsbFN0ciA9IFwiPHRkIGlkPSdjXCIgK1xyXG5cdFx0XHRcdFx0UFZhbHVlICtcclxuXHRcdFx0XHRcdFwiJyBjbGFzcz0nY2FsVEQnIHN0eWxlPSd0ZXh0LWFsaWduOmNlbnRlcjtjdXJzb3I6cG9pbnRlcjtcIiArXHJcblx0XHRcdFx0XHRwQ29sb3IgK1xyXG5cdFx0XHRcdFx0XCInIG9ubW91c2Vkb3duPSdzZWxlY3REYXRlKHRoaXMsXCIgK1xyXG5cdFx0XHRcdFx0UFZhbHVlICtcclxuXHRcdFx0XHRcdFwiKTsnPlwiICtcclxuXHRcdFx0XHRcdFBWYWx1ZSArXHJcblx0XHRcdFx0XHRcIjwvdGQ+XCI7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0UENlbGxTdHIgPVxyXG5cdFx0XHRcdFx0XCI8dGQgY2xhc3M9J2NhbFREJyBzdHlsZT0ndGV4dC1hbGlnbjpjZW50ZXI7Y3Vyc29yOnBvaW50ZXI7YmFja2dyb3VuZC1jb2xvcjpcIiArXHJcblx0XHRcdFx0XHRwQ29sb3IgK1xyXG5cdFx0XHRcdFx0XCInIG9ubW91c2VvdmVyPSdjaGFuZ2VCb3JkZXIodGhpcywgMCk7JyBvbm1vdXNlb3V0PVxcXCJjaGFuZ2VCb3JkZXIodGhpcywgMSwgJ1wiICtcclxuXHRcdFx0XHRcdHBDb2xvciArXHJcblx0XHRcdFx0XHRcIicpO1xcXCIgb25DbGljaz1cXFwiamF2YXNjcmlwdDpjYWxsYmFjaygnXCIgK1xyXG5cdFx0XHRcdFx0Q2FsLkN0cmwgK1xyXG5cdFx0XHRcdFx0XCInLCdcIiArXHJcblx0XHRcdFx0XHRDYWwuRm9ybWF0RGF0ZShQVmFsdWUpICtcclxuXHRcdFx0XHRcdFwiJyk7XFxcIj5cIiArXHJcblx0XHRcdFx0XHRQVmFsdWUgK1xyXG5cdFx0XHRcdFx0XCI8L3RkPlwiO1xyXG5cdFx0XHR9XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRQQ2VsbFN0ciA9XHJcblx0XHRcdFx0XCI8dGQgc3R5bGU9J3RleHQtYWxpZ246Y2VudGVyO2JhY2tncm91bmQtY29sb3I6XCIgK1xyXG5cdFx0XHRcdHBDb2xvciArXHJcblx0XHRcdFx0XCInIGNsYXNzPSdjYWxURCc+XCIgK1xyXG5cdFx0XHRcdFBWYWx1ZSArXHJcblx0XHRcdFx0XCI8L3RkPlwiO1xyXG5cdFx0fVxyXG5cdH0gZWxzZSB7XHJcblx0XHRQQ2VsbFN0ciA9XHJcblx0XHRcdFwiPHRkIHN0eWxlPSd0ZXh0LWFsaWduOmNlbnRlcjtiYWNrZ3JvdW5kLWNvbG9yOlwiICtcclxuXHRcdFx0cENvbG9yICtcclxuXHRcdFx0XCInIGNsYXNzPSdjYWxURCc+Jm5ic3A7PC90ZD5cIjtcclxuXHR9XHJcblxyXG5cdHJldHVybiBQQ2VsbFN0cjtcclxufVxyXG5cclxuZnVuY3Rpb24gUmVuZGVyQ3NzQ2FsKGJOZXdDYWwpIHtcclxuXHRpZiAodHlwZW9mIGJOZXdDYWwgPT09IFwidW5kZWZpbmVkXCIgfHwgYk5ld0NhbCAhPT0gdHJ1ZSlcclxuXHR7XHJcblx0XHRiTmV3Q2FsID0gZmFsc2U7XHJcblx0fVxyXG5cdHZhciB2Q2FsSGVhZGVyLFxyXG5cdFx0dkNhbERhdGEsXHJcblx0XHR2Q2FsVGltZSA9IFwiXCIsXHJcblx0XHR2Q2FsQ2xvc2luZyA9IFwiXCIsXHJcblx0XHR3aW5DYWxEYXRhID0gXCJcIixcclxuXHRcdENhbERhdGUsXHJcblxyXG5cdFx0aSxcclxuXHRcdGosXHJcblxyXG5cdFx0U2VsZWN0U3RyLFxyXG5cdFx0dkRheUNvdW50ID0gMCxcclxuXHRcdHZGaXJzdERheSxcclxuXHJcblx0XHRXZWVrRGF5TmFtZSA9IFtdLC8vQWRkZWQgdmVyc2lvbiAxLjdcclxuXHRcdHN0ckNlbGwsXHJcblxyXG5cdFx0c2hvd0hvdXIsXHJcblx0XHRTaG93QXJyb3dzID0gZmFsc2UsXHJcblx0XHRIb3VyQ2VsbFdpZHRoID0gXCIzNXB4XCIsIC8vY2VsbCB3aWR0aCB3aXRoIHNlY29uZHMuXHJcblxyXG5cdFx0U2VsZWN0QW0sXHJcblx0XHRTZWxlY3RQbSxcclxuXHJcblx0XHRmdW5jQ2FsYmFjayxcclxuXHJcblx0XHRoZWFkSUQsXHJcblx0XHRlLFxyXG5cdFx0Y3NzU3RyLFxyXG5cdFx0c3R5bGUsXHJcblx0XHRjc3NUZXh0LFxyXG5cdFx0c3BhbjtcclxuXHJcblx0Y2FsSGVpZ2h0ID0gMDsgLy8gcmVzZXQgdGhlIHdpbmRvdyBoZWlnaHQgb24gcmVmcmVzaFxyXG5cclxuXHQvLyBTZXQgdGhlIGRlZmF1bHQgY3Vyc29yIGZvciB0aGUgY2FsZW5kYXJcclxuXHJcblx0d2luQ2FsRGF0YSA9IFwiPHNwYW4gc3R5bGU9J2N1cnNvcjphdXRvOyc+XCI7XHJcblx0dkNhbEhlYWRlciA9IFwiPHRhYmxlIHN0eWxlPSdiYWNrZ3JvdW5kLWNvbG9yOlwiK0NhbEJnQ29sb3IrXCI7d2lkdGg6YXV0bztwYWRkaW5nOjA7Ym9yZGVyOm5vbmU7Jz48dGJvZHk+XCI7XHJcblxyXG5cdC8vVGFibGUgZm9yIE1vbnRoICYgWWVhciBTZWxlY3RvclxyXG5cclxuXHR2Q2FsSGVhZGVyICs9IFwiPHRyPjx0ZCBjb2xzcGFuPSc3Jz48dGFibGUgYm9yZGVyPScwJyB3aWR0aD0nMTAwJScgY2VsbHBhZGRpbmc9JzAnIGNlbGxzcGFjaW5nPScwJyBzdHlsZT0nYm9yZGVyOm5vbmU7cGFkZGluZzo1cHg7Jz48dHI+XCI7XHJcblx0Ly8qKioqKioqKioqKioqKioqKipNb250aCBhbmQgWWVhciBzZWxlY3RvciBpbiBkcm9wZG93biBsaXN0KioqKioqKioqKioqKioqKioqKioqKioqXHJcblxyXG5cdGlmIChDYWwuU2Nyb2xsZXIgPT09IFwiRFJPUERPV05cIilcclxuXHR7XHJcblx0XHR2Q2FsSGVhZGVyICs9IFwiPHRkIGFsaWduPSdsZWZ0JyBzdHlsZT0ncGFkZGluZzoxMHB4IDVweCAxMHB4IDEwcHg7bWFyZ2luOjA7YmFja2dyb3VuZDpcIit0b3BTZWxlY3RvckJnK1wiJz5cXG5cIjtcclxuXHRcdHZDYWxIZWFkZXIgKz0gXCI8c2VsZWN0IG5hbWU9J01vbnRoU2VsZWN0b3InIGlkPSdNb250aFNlbGVjdG9yU2VsZWN0JyBzdHlsZT0nbWFyZ2luLWJvdHRvbTo1cHg7IGRpc3BsYXk6IG5vbmU7JyBvbkNoYW5nZT0namF2YXNjcmlwdDpDYWwuU3dpdGNoTXRoKHRoaXMuc2VsZWN0ZWRJbmRleCk7UmVuZGVyQ3NzQ2FsKCk7Jz5cIjtcclxuXHRcdGZvciAoaSA9IDA7IGkgPCAxMjsgaSArPSAxKVxyXG5cdFx0e1xyXG5cdFx0XHRpZiAoaSA9PT0gQ2FsLk1vbnRoKVxyXG5cdFx0XHR7XHJcblx0XHRcdFx0U2VsZWN0U3RyID0gXCJTZWxlY3RlZFwiO1xyXG5cdFx0XHR9XHJcblx0XHRcdGVsc2VcclxuXHRcdFx0e1xyXG5cdFx0XHRcdFNlbGVjdFN0ciA9IFwiXCI7XHJcblx0XHRcdH1cclxuXHRcdFx0dkNhbEhlYWRlciArPSBcIjxvcHRpb24gXCIgKyBTZWxlY3RTdHIgKyBcIiB2YWx1ZT1cIiArIGkgKyBcIj5cIiArIE1vbnRoTmFtZVtpXSArIFwiPC9vcHRpb24+XCI7XHJcblx0XHR9XHJcblx0XHR2Q2FsSGVhZGVyICs9ICc8L3NlbGVjdD4nO1xyXG5cclxuXHRcdC8qIHVsIG1vbnRoIGZvciBjdXN0b20gc2VsZWN0ICovXHJcblx0XHR2Q2FsSGVhZGVyICs9ICc8c3BhbiBjbGFzcz1cIk1vbnRoU2VsZWN0b3JUaXRsZVwiPicgKyAgTW9udGhOYW1lW0NhbC5Nb250aF0gKyAnPC9zcGFuPic7XHJcblx0XHR2Q2FsSGVhZGVyICs9ICc8dWwgbmFtZT1cIk1vbnRoU2VsZWN0b3JcIiBjbGFzcz1cIk1vbnRoU2VsZWN0b3JcIiBvbkNoYW5nZT1cImphdmFzY3JpcHQ6Q2FsLlN3aXRjaE10aCh0aGlzLnNlbGVjdGVkSW5kZXgpO1JlbmRlckNzc0NhbCgpO1wiPic7XHJcblx0XHRmb3IgKGkgPSAwOyBpIDwgMTI7IGkgKz0gMSlcclxuXHRcdHtcclxuXHRcdFx0aWYgKGkgPT09IENhbC5Nb250aClcclxuXHRcdFx0e1xyXG5cdFx0XHRcdFNlbGVjdFN0ciA9IFwiU2VsZWN0ZWRcIjtcclxuXHRcdFx0fVxyXG5cdFx0XHRlbHNlXHJcblx0XHRcdHtcclxuXHRcdFx0XHRTZWxlY3RTdHIgPSBcIlwiO1xyXG5cdFx0XHR9XHJcblx0XHRcdHZDYWxIZWFkZXIgKz0gJzxsaT4nICsgTW9udGhOYW1lW2ldICsgJzwvbGk+JztcclxuXHRcdH1cclxuXHRcdHZDYWxIZWFkZXIgKz0gXCI8L3VsPlwiO1xyXG5cdFx0dkNhbEhlYWRlciArPSBcIjwvdGQ+XCI7XHJcblx0XHQvL1llYXIgc2VsZWN0b3JcclxuXHJcblx0XHR2Q2FsSGVhZGVyICs9IFwiPHRkIGFsaWduPSdyaWdodCcgc3R5bGU9J3BhZGRpbmc6MTBweCAxMHB4IDEwcHggNXB4O21hcmdpbjowO2JhY2tncm91bmQ6XCIrdG9wU2VsZWN0b3JCZytcIic+XCI7XHJcblx0XHR2Q2FsSGVhZGVyICs9IFwiPHNlbGVjdCBuYW1lPSdZZWFyU2VsZWN0b3InIHN0eWxlPSdkaXNwbGF5Om5vbmU7IG1hcmdpbi1ib3R0b206NXB4Oycgc2l6ZT0nMScgb25DaGFuZ2U9J2phdmFzY3JpcHQ6Q2FsLlN3aXRjaFllYXIodGhpcy52YWx1ZSk7UmVuZGVyQ3NzQ2FsKCk7Jz5cIjtcclxuXHRcdGZvciAoaSA9IFN0YXJ0WWVhcjsgaSA8PSAoZHRUb2RheS5nZXRGdWxsWWVhcigpICsgRW5kWWVhcik7IGkgKz0gMSlcclxuXHRcdHtcclxuXHRcdFx0aWYgKGkgPT09IENhbC5ZZWFyKVxyXG5cdFx0XHR7XHJcblx0XHRcdFx0U2VsZWN0U3RyID0gJ3NlbGVjdGVkPVwic2VsZWN0ZWRcIic7XHJcblx0XHRcdH1cclxuXHRcdFx0ZWxzZVxyXG5cdFx0XHR7XHJcblx0XHRcdFx0U2VsZWN0U3RyID0gJyc7XHJcblx0XHRcdH1cclxuXHRcdFx0dkNhbEhlYWRlciArPSBcIjxvcHRpb24gXCIgKyBTZWxlY3RTdHIgKyBcIiB2YWx1ZT1cIiArIGkgKyBcIj5cIiArIGkgKyBcIjwvb3B0aW9uPlxcblwiO1xyXG5cdFx0fVxyXG5cdFx0dkNhbEhlYWRlciArPSBcIjwvc2VsZWN0PlwiO1xyXG5cclxuXHRcdC8qIHVsIHllYXIgZm9yIGN1c3RvbSBzZWxlY3QgKi9cclxuXHRcdHZDYWxIZWFkZXIgKz0gJzxzcGFuIGNsYXNzPVwiTW9udGhTZWxlY3RvclRpdGxlIFllYXJcIj4nICsgQ2FsLlllYXIgKyAnPC9zcGFuPic7XHJcblx0XHR2Q2FsSGVhZGVyICs9ICc8dWwgbmFtZT1cIlllYXJTZWxlY3RvclwiIGNsYXNzPVwiTW9udGhTZWxlY3RvciBZZWFyXCIgb25DaGFuZ2U9XCJqYXZhc2NyaXB0OkNhbC5Td2l0Y2hNdGgodGhpcy5zZWxlY3RlZEluZGV4KTtSZW5kZXJDc3NDYWwoKTtcIj4nO1xyXG5cdFx0Zm9yIChpID0gU3RhcnRZZWFyOyBpIDw9IChkdFRvZGF5LmdldEZ1bGxZZWFyKCkgKyBFbmRZZWFyKTsgaSArPSAxKVxyXG5cdFx0e1xyXG5cdFx0XHRpZiAoaSA9PT0gQ2FsLlllYXIpXHJcblx0XHRcdHtcclxuXHRcdFx0XHRTZWxlY3RTdHIgPSAnc2VsZWN0ZWQ9XCJzZWxlY3RlZFwiJztcclxuXHRcdFx0fVxyXG5cdFx0XHRlbHNlXHJcblx0XHRcdHtcclxuXHRcdFx0XHRTZWxlY3RTdHIgPSAnJztcclxuXHRcdFx0fVxyXG5cdFx0XHR2Q2FsSGVhZGVyICs9ICc8bGk+JyArIGkgKyAnPC9saT4nO1xyXG5cdFx0fVxyXG5cdFx0dkNhbEhlYWRlciArPSBcIjwvdWw+XCI7XHJcblx0XHR2Q2FsSGVhZGVyICs9IFwiPC90ZD5cXG5cIjtcclxuXHRcdGNhbEhlaWdodCArPSAzMDtcclxuXHR9XHJcblxyXG5cdC8vKioqKioqKioqKioqKioqKioqRW5kIE1vbnRoIGFuZCBZZWFyIHNlbGVjdG9yIGluIGRyb3Bkb3duIGxpc3QqKioqKioqKioqKioqKioqKioqKipcclxuXHJcblx0Ly8qKioqKioqKioqKioqKioqKipNb250aCBhbmQgWWVhciBzZWxlY3RvciBpbiBhcnJvdyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG5cclxuXHRlbHNlIGlmIChDYWwuU2Nyb2xsZXIgPT09IFwiQVJST1dcIilcclxuXHR7XHJcblx0XHRpZiAoVXNlSW1hZ2VGaWxlcylcclxuXHRcdHtcclxuXHRcdFx0dkNhbEhlYWRlciArPSBcIjx0ZD48aW1nIG9ubW91c2Vkb3duPSdqYXZhc2NyaXB0OkNhbC5EZWNZZWFyKCk7UmVuZGVyQ3NzQ2FsKCk7JyBzcmM9J1wiK2ltYWdlRmlsZXNQYXRoK1wiY2FsX2Zhc3RyZXZlcnNlLmdpZicgd2lkdGg9JzEzcHgnIGhlaWdodD0nOScgb25tb3VzZW92ZXI9J2NoYW5nZUJvcmRlcih0aGlzLCAwKScgb25tb3VzZW91dD0nY2hhbmdlQm9yZGVyKHRoaXMsIDEpJyBzdHlsZT0nYm9yZGVyOjFweCBzb2xpZCB3aGl0ZSc+PC90ZD5cXG5cIjsvL1llYXIgc2Nyb2xsZXIgKGRlY3JlYXNlIDEgeWVhcilcclxuXHRcdFx0dkNhbEhlYWRlciArPSBcIjx0ZD48aW1nIG9ubW91c2Vkb3duPSdqYXZhc2NyaXB0OkNhbC5EZWNNb250aCgpO1JlbmRlckNzc0NhbCgpOycgc3JjPSdcIiArIGltYWdlRmlsZXNQYXRoICsgXCJjYWxfcmV2ZXJzZS5naWYnIHdpZHRoPScxM3B4JyBoZWlnaHQ9JzknIG9ubW91c2VvdmVyPSdjaGFuZ2VCb3JkZXIodGhpcywgMCknIG9ubW91c2VvdXQ9J2NoYW5nZUJvcmRlcih0aGlzLCAxKScgc3R5bGU9J2JvcmRlcjoxcHggc29saWQgd2hpdGUnPjwvdGQ+XFxuXCI7IC8vTW9udGggc2Nyb2xsZXIgKGRlY3JlYXNlIDEgbW9udGgpXHJcblx0XHRcdHZDYWxIZWFkZXIgKz0gXCI8dGQgd2lkdGg9JzcwJScgY2xhc3M9J2NhbFInIHN0eWxlPSdjb2xvcjpcIitZclNlbENvbG9yK1wiJz5cIisgQ2FsLkdldE1vbnRoTmFtZShTaG93TG9uZ01vbnRoKSArIFwiIFwiICsgQ2FsLlllYXIgKyBcIjwvdGQ+XCI7IC8vTW9udGggYW5kIFllYXJcclxuXHRcdFx0dkNhbEhlYWRlciArPSBcIjx0ZD48aW1nIG9ubW91c2Vkb3duPSdqYXZhc2NyaXB0OkNhbC5JbmNNb250aCgpO1JlbmRlckNzc0NhbCgpOycgc3JjPSdcIiArIGltYWdlRmlsZXNQYXRoICsgXCJjYWxfZm9yd2FyZC5naWYnIHdpZHRoPScxM3B4JyBoZWlnaHQ9JzknIG9ubW91c2VvdmVyPSdjaGFuZ2VCb3JkZXIodGhpcywgMCknIG9ubW91c2VvdXQ9J2NoYW5nZUJvcmRlcih0aGlzLCAxKScgc3R5bGU9J2JvcmRlcjoxcHggc29saWQgd2hpdGUnPjwvdGQ+XFxuXCI7IC8vTW9udGggc2Nyb2xsZXIgKGluY3JlYXNlIDEgbW9udGgpXHJcblx0XHRcdHZDYWxIZWFkZXIgKz0gXCI8dGQ+PGltZyBvbm1vdXNlZG93bj0namF2YXNjcmlwdDpDYWwuSW5jWWVhcigpO1JlbmRlckNzc0NhbCgpOycgc3JjPSdcIiArIGltYWdlRmlsZXNQYXRoICsgXCJjYWxfZmFzdGZvcndhcmQuZ2lmJyB3aWR0aD0nMTNweCcgaGVpZ2h0PSc5JyBvbm1vdXNlb3Zlcj0nY2hhbmdlQm9yZGVyKHRoaXMsIDApJyBvbm1vdXNlb3V0PSdjaGFuZ2VCb3JkZXIodGhpcywgMSknIHN0eWxlPSdib3JkZXI6MXB4IHNvbGlkIHdoaXRlJz48L3RkPlxcblwiOyAvL1llYXIgc2Nyb2xsZXIgKGluY3JlYXNlIDEgeWVhcilcclxuXHRcdFx0Y2FsSGVpZ2h0ICs9IDIyO1xyXG5cdFx0fVxyXG5cdFx0ZWxzZVxyXG5cdFx0e1xyXG5cdFx0XHR2Q2FsSGVhZGVyICs9IFwiPHRkPjxzcGFuIGlkPSdkZWNfeWVhcicgdGl0bGU9J3JldmVyc2UgeWVhcicgb25tb3VzZWRvd249J2phdmFzY3JpcHQ6Q2FsLkRlY1llYXIoKTtSZW5kZXJDc3NDYWwoKTsnIG9ubW91c2VvdmVyPSdjaGFuZ2VCb3JkZXIodGhpcywgMCknIG9ubW91c2VvdXQ9J2NoYW5nZUJvcmRlcih0aGlzLCAxKScgc3R5bGU9J2JvcmRlcjoxcHggc29saWQgd2hpdGU7IGNvbG9yOlwiICsgWXJTZWxDb2xvciArIFwiJz4tPC9zcGFuPjwvdGQ+XCI7Ly9ZZWFyIHNjcm9sbGVyIChkZWNyZWFzZSAxIHllYXIpXHJcblx0XHRcdHZDYWxIZWFkZXIgKz0gXCI8dGQ+PHNwYW4gaWQ9J2RlY19tb250aCcgdGl0bGU9J3JldmVyc2UgbW9udGgnIG9ubW91c2Vkb3duPSdqYXZhc2NyaXB0OkNhbC5EZWNNb250aCgpO1JlbmRlckNzc0NhbCgpOycgb25tb3VzZW92ZXI9J2NoYW5nZUJvcmRlcih0aGlzLCAwKScgb25tb3VzZW91dD0nY2hhbmdlQm9yZGVyKHRoaXMsIDEpJyBzdHlsZT0nYm9yZGVyOjFweCBzb2xpZCB3aGl0ZSc+Jmx0Ozwvc3Bhbj48L3RkPlxcblwiOy8vTW9udGggc2Nyb2xsZXIgKGRlY3JlYXNlIDEgbW9udGgpXHJcblx0XHRcdHZDYWxIZWFkZXIgKz0gXCI8dGQgd2lkdGg9JzcwJScgY2xhc3M9J2NhbFInIHN0eWxlPSdjb2xvcjpcIiArIFlyU2VsQ29sb3IgKyBcIic+XCIgKyBDYWwuR2V0TW9udGhOYW1lKFNob3dMb25nTW9udGgpICsgXCIgXCIgKyBDYWwuWWVhciArIFwiPC90ZD5cXG5cIjsgLy9Nb250aCBhbmQgWWVhclxyXG5cdFx0XHR2Q2FsSGVhZGVyICs9IFwiPHRkPjxzcGFuIGlkPSdpbmNfbW9udGgnIHRpdGxlPSdmb3J3YXJkIG1vbnRoJyBvbm1vdXNlZG93bj0namF2YXNjcmlwdDpDYWwuSW5jTW9udGgoKTtSZW5kZXJDc3NDYWwoKTsnIG9ubW91c2VvdmVyPSdjaGFuZ2VCb3JkZXIodGhpcywgMCknIG9ubW91c2VvdXQ9J2NoYW5nZUJvcmRlcih0aGlzLCAxKScgc3R5bGU9J2JvcmRlcjoxcHggc29saWQgd2hpdGUnPiZndDs8L3NwYW4+PC90ZD5cXG5cIjsvL01vbnRoIHNjcm9sbGVyIChpbmNyZWFzZSAxIG1vbnRoKVxyXG5cdFx0XHR2Q2FsSGVhZGVyICs9IFwiPHRkPjxzcGFuIGlkPSdpbmNfeWVhcicgdGl0bGU9J2ZvcndhcmQgeWVhcicgb25tb3VzZWRvd249J2phdmFzY3JpcHQ6Q2FsLkluY1llYXIoKTtSZW5kZXJDc3NDYWwoKTsnICBvbm1vdXNlb3Zlcj0nY2hhbmdlQm9yZGVyKHRoaXMsIDApJyBvbm1vdXNlb3V0PSdjaGFuZ2VCb3JkZXIodGhpcywgMSknIHN0eWxlPSdib3JkZXI6MXB4IHNvbGlkIHdoaXRlOyBjb2xvcjpcIiArIFlyU2VsQ29sb3IgKyBcIic+Kzwvc3Bhbj48L3RkPlxcblwiOy8vWWVhciBzY3JvbGxlciAoaW5jcmVhc2UgMSB5ZWFyKVxyXG5cdFx0XHRjYWxIZWlnaHQgKz0gMjI7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHR2Q2FsSGVhZGVyICs9IFwiPC90cj48L3RhYmxlPjwvdGQ+PC90cj5cIjtcclxuXHJcblx0Ly8qKioqKioqKioqKioqKioqKipFbmQgTW9udGggYW5kIFllYXIgc2VsZWN0b3IgaW4gYXJyb3cqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuXHJcblx0Ly9DYWxlbmRhciBoZWFkZXIgc2hvd3MgTW9udGggYW5kIFllYXJcclxuXHRpZiAoU2hvd01vbnRoWWVhciAmJiBDYWwuU2Nyb2xsZXIgPT09IFwiRFJPUERPV05cIilcclxuXHR7XHJcblx0XHR2Q2FsSGVhZGVyICs9IFwiPHRyPjx0ZCBjb2xzcGFuPSc3JyBjbGFzcz0nY2FsUicgc3R5bGU9J2NvbG9yOlwiICsgTW9udGhZZWFyQ29sb3IgKyBcIic+XCIgKyBDYWwuR2V0TW9udGhOYW1lKFNob3dMb25nTW9udGgpICsgXCIgXCIgKyBDYWwuWWVhciArIFwiPC90ZD48L3RyPlwiO1xyXG5cdFx0Y2FsSGVpZ2h0ICs9IDE5O1xyXG5cdH1cclxuXHJcblx0Ly9XZWVrIGRheSBoZWFkZXJcclxuXHJcblx0dkNhbEhlYWRlciArPSBcIjx0cj48dGQgY29sc3Bhbj1cXFwiN1xcXCI+PHRhYmxlIHN0eWxlPSdib3JkZXItc3BhY2luZzowO2JvcmRlci1jb2xsYXBzZTpjb2xsYXBzZTtib3gtc2l6aW5nOmJvcmRlci1ib3g7IG1hcmdpbjogNXB4IDVweCA1cHggNHB4Oyc+PHRyPlwiO1xyXG5cdGlmIChNb25kYXlGaXJzdERheSA9PT0gdHJ1ZSlcclxuXHR7XHJcblx0XHRXZWVrRGF5TmFtZSA9IFdlZWtEYXlOYW1lMjtcclxuXHR9XHJcblx0ZWxzZVxyXG5cdHtcclxuXHRcdFdlZWtEYXlOYW1lID0gV2Vla0RheU5hbWUxO1xyXG5cdH1cclxuXHRmb3IgKGkgPSAwOyBpIDwgNzsgaSArPSAxKVxyXG5cdHtcclxuXHRcdHZDYWxIZWFkZXIgKz0gXCI8dGQgc3R5bGU9J2JhY2tncm91bmQtY29sb3I6XCIrV2Vla0hlYWRCYWNrZ3JvdW5kK1wiO3dpZHRoOlwiK0NlbGxXaWR0aCtcInB4O2NvbG9yOlwiK1dlZWtIZWFkQ29sb3IrXCInIGNsYXNzPSdjYWxURCc+XCIgKyBXZWVrRGF5TmFtZVtpXS5zdWJzdHIoMCwgV2Vla0NoYXIpICsgXCI8L3RkPlwiO1xyXG5cdH1cclxuXHJcblx0Y2FsSGVpZ2h0ICs9IDE5O1xyXG5cdHZDYWxIZWFkZXIgKz0gXCI8L3RyPlwiO1xyXG5cdC8vQ2FsZW5kYXIgZGV0YWlsXHJcblx0Q2FsRGF0ZSA9IG5ldyBEYXRlKENhbC5ZZWFyLCBDYWwuTW9udGgpO1xyXG5cdENhbERhdGUuc2V0RGF0ZSgxKTtcclxuXHJcblx0dkZpcnN0RGF5ID0gQ2FsRGF0ZS5nZXREYXkoKTtcclxuXHJcblx0Ly9BZGRlZCB2ZXJzaW9uIDEuN1xyXG5cdGlmIChNb25kYXlGaXJzdERheSA9PT0gdHJ1ZSlcclxuXHR7XHJcblx0XHR2Rmlyc3REYXkgLT0gMTtcclxuXHRcdGlmICh2Rmlyc3REYXkgPT09IC0xKVxyXG5cdFx0e1xyXG5cdFx0XHR2Rmlyc3REYXkgPSA2O1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0Ly9BZGRlZCB2ZXJzaW9uIDEuN1xyXG5cdHZDYWxEYXRhID0gXCI8dHI+XCI7XHJcblx0Y2FsSGVpZ2h0ICs9IDE5O1xyXG5cdGZvciAoaSA9IDA7IGkgPCB2Rmlyc3REYXk7IGkgKz0gMSlcclxuXHR7XHJcblx0XHR2Q2FsRGF0YSA9IHZDYWxEYXRhICsgR2VuQ2VsbCgpO1xyXG5cdFx0dkRheUNvdW50ID0gdkRheUNvdW50ICsgMTtcclxuXHR9XHJcblxyXG5cdC8vQWRkZWQgdmVyc2lvbiAxLjdcclxuXHRmb3IgKGogPSAxOyBqIDw9IENhbC5HZXRNb25EYXlzKCk7IGogKz0gMSlcclxuXHR7XHJcblx0XHRpZiAoKHZEYXlDb3VudCAlIDcgPT09IDApICYmIChqID4gMSkpXHJcblx0XHR7XHJcblx0XHRcdHZDYWxEYXRhID0gdkNhbERhdGEgKyBcIjx0cj5cIjtcclxuXHRcdH1cclxuXHJcblx0XHR2RGF5Q291bnQgPSB2RGF5Q291bnQgKyAxO1xyXG5cdFx0Ly9hZGRlZCB2ZXJzaW9uIDIuMS4yXHJcblx0XHRpZiAoQ2FsLkVuYWJsZURhdGVNb2RlID09PSBcImZ1dHVyZVwiICYmICgoaiA8IGR0VG9kYXkuZ2V0RGF0ZSgpKSAmJiAoQ2FsLk1vbnRoID09PSBkdFRvZGF5LmdldE1vbnRoKCkpICYmIChDYWwuWWVhciA9PT0gZHRUb2RheS5nZXRGdWxsWWVhcigpKSB8fCAoQ2FsLk1vbnRoIDwgZHRUb2RheS5nZXRNb250aCgpKSAmJiAoQ2FsLlllYXIgPT09IGR0VG9kYXkuZ2V0RnVsbFllYXIoKSkgfHwgKENhbC5ZZWFyIDwgZHRUb2RheS5nZXRGdWxsWWVhcigpKSkpXHJcblx0XHR7XHJcblx0XHRcdHN0ckNlbGwgPSBHZW5DZWxsKGosIGZhbHNlLCBEaXNhYmxlQ29sb3IsIGZhbHNlKTsgLy9CZWZvcmUgdG9kYXkncyBkYXRlIGlzIG5vdCBjbGlja2FibGVcclxuXHRcdH1cclxuXHRcdGVsc2UgaWYgKENhbC5FbmFibGVEYXRlTW9kZSA9PT0gXCJwYXN0XCIgJiYgKChqID49IGR0VG9kYXkuZ2V0RGF0ZSgpKSAmJiAoQ2FsLk1vbnRoID09PSBkdFRvZGF5LmdldE1vbnRoKCkpICYmIChDYWwuWWVhciA9PT0gZHRUb2RheS5nZXRGdWxsWWVhcigpKSB8fCAoQ2FsLk1vbnRoID4gZHRUb2RheS5nZXRNb250aCgpKSAmJiAoQ2FsLlllYXIgPT09IGR0VG9kYXkuZ2V0RnVsbFllYXIoKSkgfHwgKENhbC5ZZWFyID4gZHRUb2RheS5nZXRGdWxsWWVhcigpKSkpIHtcclxuXHRcdFx0c3RyQ2VsbCA9IEdlbkNlbGwoaiwgZmFsc2UsIERpc2FibGVDb2xvciwgZmFsc2UpOyAvL0FmdGVyIHRvZGF5J3MgZGF0ZSBpcyBub3QgY2xpY2thYmxlXHJcblx0XHR9XHJcblx0XHQvL2lmIEVuZCBZZWFyICsgQ3VycmVudCBZZWFyID0gQ2FsLlllYXIuIERpc2FibGUuXHJcblx0XHRlbHNlIGlmIChDYWwuWWVhciA+IChkdFRvZGF5LmdldEZ1bGxZZWFyKCkrRW5kWWVhcikpXHJcblx0XHR7XHJcblx0XHRcdHN0ckNlbGwgPSBHZW5DZWxsKGosIGZhbHNlLCBEaXNhYmxlQ29sb3IsIGZhbHNlKTtcclxuXHRcdH1cclxuXHRcdGVsc2UgaWYgKChqID09PSBkdFRvZGF5LmdldERhdGUoKSkgJiYgKENhbC5Nb250aCA9PT0gZHRUb2RheS5nZXRNb250aCgpKSAmJiAoQ2FsLlllYXIgPT09IGR0VG9kYXkuZ2V0RnVsbFllYXIoKSkpXHJcblx0XHR7XHJcblx0XHRcdHN0ckNlbGwgPSBHZW5DZWxsKGosIHRydWUsIFRvZGF5Q29sb3IpOy8vSGlnaGxpZ2h0IHRvZGF5J3MgZGF0ZVxyXG5cdFx0fVxyXG5cdFx0ZWxzZVxyXG5cdFx0e1xyXG5cdFx0XHRpZiAoKGogPT09IHNlbERhdGUuZ2V0RGF0ZSgpKSAmJiAoQ2FsLk1vbnRoID09PSBzZWxEYXRlLmdldE1vbnRoKCkpICYmIChDYWwuWWVhciA9PT0gc2VsRGF0ZS5nZXRGdWxsWWVhcigpKSl7XHJcblx0XHRcdFx0Ly9tb2RpZmllZCB2ZXJzaW9uIDEuN1xyXG5cdFx0XHRcdHN0ckNlbGwgPSBHZW5DZWxsKGosIHRydWUsIFNlbERhdGVDb2xvcik7XHJcblx0XHRcdH1cclxuXHRcdFx0ZWxzZVxyXG5cdFx0XHR7XHJcblx0XHRcdFx0aWYgKE1vbmRheUZpcnN0RGF5ID09PSB0cnVlKVxyXG5cdFx0XHRcdHtcclxuXHRcdFx0XHRcdGlmICh2RGF5Q291bnQgJSA3ID09PSAwKVxyXG5cdFx0XHRcdFx0e1xyXG5cdFx0XHRcdFx0XHRzdHJDZWxsID0gR2VuQ2VsbChqLCBmYWxzZSwgU3VuZGF5Q29sb3IpO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0ZWxzZSBpZiAoKHZEYXlDb3VudCArIDEpICUgNyA9PT0gMClcclxuXHRcdFx0XHRcdHtcclxuXHRcdFx0XHRcdFx0c3RyQ2VsbCA9IEdlbkNlbGwoaiwgZmFsc2UsIFNhdHVyZGF5Q29sb3IpO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0ZWxzZVxyXG5cdFx0XHRcdFx0e1xyXG5cdFx0XHRcdFx0XHRzdHJDZWxsID0gR2VuQ2VsbChqLCBudWxsLCBXZWVrRGF5Q29sb3IpO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRlbHNlXHJcblx0XHRcdFx0e1xyXG5cdFx0XHRcdFx0aWYgKHZEYXlDb3VudCAlIDcgPT09IDApXHJcblx0XHRcdFx0XHR7XHJcblx0XHRcdFx0XHRcdHN0ckNlbGwgPSBHZW5DZWxsKGosIGZhbHNlLCBTYXR1cmRheUNvbG9yKTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdGVsc2UgaWYgKCh2RGF5Q291bnQgKyA2KSAlIDcgPT09IDApXHJcblx0XHRcdFx0XHR7XHJcblx0XHRcdFx0XHRcdHN0ckNlbGwgPSBHZW5DZWxsKGosIGZhbHNlLCBTdW5kYXlDb2xvcik7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRlbHNlXHJcblx0XHRcdFx0XHR7XHJcblx0XHRcdFx0XHRcdHN0ckNlbGwgPSBHZW5DZWxsKGosIG51bGwsIFdlZWtEYXlDb2xvcik7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0dkNhbERhdGEgPSB2Q2FsRGF0YSArIHN0ckNlbGw7XHJcblxyXG5cdFx0aWYgKCh2RGF5Q291bnQgJSA3ID09PSAwKSAmJiAoaiA8IENhbC5HZXRNb25EYXlzKCkpKVxyXG5cdFx0e1xyXG5cdFx0XHR2Q2FsRGF0YSA9IHZDYWxEYXRhICsgXCI8L3RyPlwiO1xyXG5cdFx0XHRjYWxIZWlnaHQgKz0gMTk7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHQvLyBmaW5pc2ggdGhlIHRhYmxlIHByb3BlclxyXG5cclxuXHRpZiAodkRheUNvdW50ICUgNyAhPT0gMClcclxuXHR7XHJcblx0XHR3aGlsZSAodkRheUNvdW50ICUgNyAhPT0gMClcclxuXHRcdHtcclxuXHRcdFx0dkNhbERhdGEgPSB2Q2FsRGF0YSArIEdlbkNlbGwoKTtcclxuXHRcdFx0dkRheUNvdW50ID0gdkRheUNvdW50ICsgMTtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdHZDYWxEYXRhID0gdkNhbERhdGEgKyBcIjwvdGFibGU+PC90ZD48L3RyPlwiO1xyXG5cclxuXHJcblx0Ly9UaW1lIHBpY2tlclxyXG5cdGlmIChDYWwuU2hvd1RpbWUgPT09IHRydWUpXHJcblx0e1xyXG5cdFx0c2hvd0hvdXIgPSBDYWwuZ2V0U2hvd0hvdXIoKTtcclxuXHJcblx0XHRpZiAoQ2FsLlNob3dTZWNvbmRzID09PSBmYWxzZSAmJiBUaW1lTW9kZSA9PT0gMjQpXHJcblx0XHR7XHJcblx0XHRcdFNob3dBcnJvd3MgPSB0cnVlO1xyXG5cdFx0XHRIb3VyQ2VsbFdpZHRoID0gXCIxMHB4XCI7XHJcblx0XHR9XHJcblxyXG5cdFx0dkNhbFRpbWUgPSBcIjx0cj48dGQgY29sc3Bhbj0nNycgc3R5bGU9XFxcInRleHQtYWxpZ246Y2VudGVyO1xcXCI+PHRhYmxlIGJvcmRlcj0nMCcgd2lkdGg9JzEwMCUnIGNlbGxwYWRkaW5nPScwJyBjZWxsc3BhY2luZz0nMCc+PHRib2R5Pjx0cj48dGQgaGVpZ2h0PSc1cHgnIHdpZHRoPSdcIiArIEhvdXJDZWxsV2lkdGggKyBcIic+Jm5ic3A7PC90ZD5cIjtcclxuXHJcblx0XHRpZiAoU2hvd0Fycm93cyAmJiBVc2VJbWFnZUZpbGVzKSAvL3RoaXMgaXMgd2hlcmUgdGhlIHVwIGFuZCBkb3duIGFycm93IGNvbnRyb2wgdGhlIGhvdXIuXHJcblx0XHR7XHJcblx0XHRcdHZDYWxUaW1lICs9IFwiPHRkIHN0eWxlPSd2ZXJ0aWNhbC1hbGlnbjptaWRkbGU7Jz48dGFibGUgY2VsbHNwYWNpbmc9JzAnIGNlbGxwYWRkaW5nPScwJyBzdHlsZT0nbGluZS1oZWlnaHQ6MHB0O3dpZHRoOjEwMCU7Jz48dHI+PHRkIHN0eWxlPSd0ZXh0LWFsaWduOmNlbnRlcjsnPjxpbWcgb25jbGljaz0nbmV4dFN0ZXAoXFxcIkhvdXJcXFwiLCBcXFwicGx1c1xcXCIpOycgb25tb3VzZWRvd249J3N0YXJ0U3BpbihcXFwiSG91clxcXCIsIFxcXCJwbHVzXFxcIik7JyBvbm1vdXNldXA9J3N0b3BTcGluKCk7JyBzcmM9J1wiICsgaW1hZ2VGaWxlc1BhdGggKyBcImNhbF9wbHVzLmdpZicgd2lkdGg9JzEzcHgnIGhlaWdodD0nOXB4JyBvbm1vdXNlb3Zlcj0nY2hhbmdlQm9yZGVyKHRoaXMsIDApJyBvbm1vdXNlb3V0PSdjaGFuZ2VCb3JkZXIodGhpcywgMSknIHN0eWxlPSdib3JkZXI6MXB4IHNvbGlkIHdoaXRlJz48L3RkPjwvdHI+PHRyPjx0ZCBzdHlsZT0ndGV4dC1hbGlnbjpjZW50ZXI7Jz48aW1nIG9uY2xpY2s9J25leHRTdGVwKFxcXCJIb3VyXFxcIiwgXFxcIm1pbnVzXFxcIik7JyBvbm1vdXNlZG93bj0nc3RhcnRTcGluKFxcXCJIb3VyXFxcIiwgXFxcIm1pbnVzXFxcIik7JyBvbm1vdXNldXA9J3N0b3BTcGluKCk7JyBzcmM9J1wiICsgaW1hZ2VGaWxlc1BhdGggKyBcImNhbF9taW51cy5naWYnIHdpZHRoPScxM3B4JyBoZWlnaHQ9JzlweCcgb25tb3VzZW92ZXI9J2NoYW5nZUJvcmRlcih0aGlzLCAwKScgb25tb3VzZW91dD0nY2hhbmdlQm9yZGVyKHRoaXMsIDEpJyBzdHlsZT0nYm9yZGVyOjFweCBzb2xpZCB3aGl0ZSc+PC90ZD48L3RyPjwvdGFibGU+PC90ZD5cXG5cIjtcclxuXHRcdH1cclxuXHJcblx0XHR2Q2FsVGltZSArPSBcIjx0ZCBzdHlsZT0nYm9yZGVyLXRvcDoxcHggc29saWQgI2I3YzlkMzsnPjxpbnB1dCB0eXBlPSd0ZXh0JyBuYW1lPSdob3VyJyBtYXhsZW5ndGg9MiBzaXplPTEgc3R5bGU9J3dpZHRoOmF1dG87cGFkZGluZzo1cHggMTBweDttYXJnaW46MTBweCBhdXRvO2Zsb2F0OnJpZ2h0OycgdmFsdWU9XCIgKyBzaG93SG91ciArIFwiIG9ua2V5dXA9XFxcImphdmFzY3JpcHQ6Q2FsLlNldEhvdXIodGhpcy52YWx1ZSlcXFwiPlwiO1xyXG5cdFx0dkNhbFRpbWUgKz0gXCI8L3RkPjx0ZCBzdHlsZT0nZm9udC13ZWlnaHQ6Ym9sZDt0ZXh0LWFsaWduOmNlbnRlcjtwYWRkaW5nOjAgM3B4O2JvcmRlci10b3A6MXB4IHNvbGlkICNiN2M5ZDM7Jz46PC90ZD48dGQgc3R5bGU9J2JvcmRlci10b3A6MXB4IHNvbGlkICNiN2M5ZDM7Jz5cIjtcclxuXHRcdHZDYWxUaW1lICs9IFwiPGlucHV0IHR5cGU9J3RleHQnIG5hbWU9J21pbnV0ZScgbWF4bGVuZ3RoPTIgc2l6ZT0xIHN0eWxlPSdib3JkZXItdG9wOjFweCBzb2xpZCAjYjdjOWQzOyB3aWR0aDphdXRvO3BhZGRpbmc6NXB4IDEwcHg7bWFyZ2luOjAgYXV0bztmbG9hdDpsZWZ0OycgdmFsdWU9XCIgKyBDYWwuTWludXRlcyArIFwiIG9ua2V5dXA9XFxcImphdmFzY3JpcHQ6Q2FsLlNldE1pbnV0ZSh0aGlzLnZhbHVlKVxcXCI+XCI7XHJcblxyXG5cdFx0aWYgKENhbC5TaG93U2Vjb25kcylcclxuXHRcdHtcclxuXHRcdFx0dkNhbFRpbWUgKz0gXCI8L3RkPjx0ZCBzdHlsZT0nZm9udC13ZWlnaHQ6Ym9sZDtib3JkZXItdG9wOjFweCBzb2xpZCAjYjdjOWQzOyc+OjwvdGQ+PHRkIHN0eWxlPSdib3JkZXItdG9wOjFweCBzb2xpZCAjYjdjOWQzOyc+XCI7XHJcblx0XHRcdHZDYWxUaW1lICs9IFwiPGlucHV0IHR5cGU9J3RleHQnIG5hbWU9J3NlY29uZCcgbWF4bGVuZ3RoPTIgc2l6ZT0xIHN0eWxlPSd3aWR0aDphdXRvO3BhZGRpbmc6NXB4IDEwcHg7bWFyZ2luOjAgYXV0bztmbG9hdDpsZWZ0OycgdmFsdWU9XCIgKyBDYWwuU2Vjb25kcyArIFwiIG9ua2V5dXA9XFxcImphdmFzY3JpcHQ6Q2FsLlNldFNlY29uZChwYXJzZUludCh0aGlzLnZhbHVlLDEwKSlcXFwiPlwiO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChUaW1lTW9kZSA9PT0gMTIpXHJcblx0XHR7XHJcblx0XHRcdFNlbGVjdEFtID0gKENhbC5BTW9yUE0gPT09IFwiQU1cIikgPyBcIlNlbGVjdGVkXCIgOiBcIlwiO1xyXG5cdFx0XHRTZWxlY3RQbSA9IChDYWwuQU1vclBNID09PSBcIlBNXCIpID8gXCJTZWxlY3RlZFwiIDogXCJcIjtcclxuXHJcblx0XHRcdHZDYWxUaW1lICs9IFwiPC90ZD48dGQ+XCI7XHJcblx0XHRcdHZDYWxUaW1lICs9IFwiPHNlbGVjdCBuYW1lPVxcXCJhbXBtXFxcIiBvbkNoYW5nZT1cXFwiamF2YXNjcmlwdDpDYWwuU2V0QW1QbSh0aGlzLm9wdGlvbnNbdGhpcy5zZWxlY3RlZEluZGV4XS52YWx1ZSk7XFxcIj5cXG5cIjtcclxuXHRcdFx0dkNhbFRpbWUgKz0gXCI8b3B0aW9uIFwiICsgU2VsZWN0QW0gKyBcIiB2YWx1ZT1cXFwiQU1cXFwiPkFNPC9vcHRpb24+XCI7XHJcblx0XHRcdHZDYWxUaW1lICs9IFwiPG9wdGlvbiBcIiArIFNlbGVjdFBtICsgXCIgdmFsdWU9XFxcIlBNXFxcIj5QTTxvcHRpb24+XCI7XHJcblx0XHRcdHZDYWxUaW1lICs9IFwiPC9zZWxlY3Q+XCI7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKFNob3dBcnJvd3MgJiYgVXNlSW1hZ2VGaWxlcykgLy90aGlzIGlzIHdoZXJlIHRoZSB1cCBhbmQgZG93biBhcnJvdyB0byBjaGFuZ2UgdGhlIFwiTWludXRlXCIuXHJcblx0XHR7XHJcblx0XHRcdHZDYWxUaW1lICs9IFwiPC90ZD5cXG48dGQgc3R5bGU9J3ZlcnRpY2FsLWFsaWduOm1pZGRsZTsnPjx0YWJsZSBjZWxsc3BhY2luZz0nMCcgY2VsbHBhZGRpbmc9JzAnIHN0eWxlPSdsaW5lLWhlaWdodDowcHQ7d2lkdGg6MTAwJSc+PHRyPjx0ZCBzdHlsZT0ndGV4dC1hbGlnbjpjZW50ZXI7Jz48aW1nIG9uY2xpY2s9J25leHRTdGVwKFxcXCJNaW51dGVcXFwiLCBcXFwicGx1c1xcXCIpOycgb25tb3VzZWRvd249J3N0YXJ0U3BpbihcXFwiTWludXRlXFxcIiwgXFxcInBsdXNcXFwiKTsnIG9ubW91c2V1cD0nc3RvcFNwaW4oKTsnIHNyYz0nXCIgKyBpbWFnZUZpbGVzUGF0aCArIFwiY2FsX3BsdXMuZ2lmJyB3aWR0aD0nMTNweCcgaGVpZ2h0PSc5cHgnIG9ubW91c2VvdmVyPSdjaGFuZ2VCb3JkZXIodGhpcywgMCknIG9ubW91c2VvdXQ9J2NoYW5nZUJvcmRlcih0aGlzLCAxKScgc3R5bGU9J2JvcmRlcjoxcHggc29saWQgd2hpdGUnPjwvdGQ+PC90cj48dHI+PHRkIHN0eWxlPSd0ZXh0LWFsaWduOmNlbnRlcjsnPjxpbWcgb25tb3VzZWRvd249J3N0YXJ0U3BpbihcXFwiTWludXRlXFxcIiwgXFxcIm1pbnVzXFxcIik7JyBvbm1vdXNldXA9J3N0b3BTcGluKCk7JyBvbmNsaWNrPSduZXh0U3RlcChcXFwiTWludXRlXFxcIixcXFwibWludXNcXFwiKTsnIHNyYz0nXCIgKyBpbWFnZUZpbGVzUGF0aCArIFwiY2FsX21pbnVzLmdpZicgd2lkdGg9JzEzcHgnIGhlaWdodD0nOXB4JyBvbm1vdXNlb3Zlcj0nY2hhbmdlQm9yZGVyKHRoaXMsIDApJyBvbm1vdXNlb3V0PSdjaGFuZ2VCb3JkZXIodGhpcywgMSknIHN0eWxlPSdib3JkZXI6MXB4IHNvbGlkIHdoaXRlJz48L3RkPjwvdHI+PC90YWJsZT5cIjtcclxuXHRcdH1cclxuXHJcblx0XHR2Q2FsVGltZSArPSBcIjwvdGQ+XFxuPHRkIGFsaWduPSdyaWdodCcgdmFsaWduPSdib3R0b20nIHdpZHRoPSdcIiArIEhvdXJDZWxsV2lkdGggKyBcInB4Jz48L3RkPjwvdHI+XCI7XHJcblx0XHR2Q2FsVGltZSArPSBcIjx0cj48dGQgaGVpZ2h0PSc1cHgnIHdpZHRoPSdcIiArIEhvdXJDZWxsV2lkdGggKyBcIic+Jm5ic3A7PC90ZD48dGQgY29sc3Bhbj0nMycgc3R5bGU9J3RleHQtYWxpZ246Y2VudGVyO2JvcmRlci10b3A6MXB4IHNvbGlkICNiN2M5ZDM7Jz48aW5wdXQgb25DbGljaz0namF2YXNjcmlwdDpjbG9zZXdpbihcXFwiXCIgKyBDYWwuQ3RybCArIFwiXFxcIik7JyAgdHlwZT1cXFwiYnV0dG9uXFxcIiB2YWx1ZT1cXFwiT0tcXFwiPiZuYnNwOzxpbnB1dCBvbkNsaWNrPSdqYXZhc2NyaXB0OndpbmNsb3NlKCknIHR5cGU9XFxcImJ1dHRvblxcXCIgdmFsdWU9XFxcIkNhbmNlbFxcXCI+PC90ZD48dGQgaGVpZ2h0PSc1cHgnIHdpZHRoPSdcIiArIEhvdXJDZWxsV2lkdGggKyBcIic+Jm5ic3A7PC90ZD48L3RyPlwiO1xyXG5cdH1cclxuXHRlbHNlIC8vaWYgbm90IHRvIHNob3cgdGltZS5cclxuXHR7XHJcblx0XHR2Q2FsVGltZSArPSBcIlxcbjx0cj5cXG48dGQgY29sc3Bhbj0nNycgc3R5bGU9XFxcInRleHQtYWxpZ246cmlnaHQ7XFxcIj5cIjtcclxuXHRcdC8vY2xvc2UgYnV0dG9uXHJcblx0XHRpZiAoVXNlSW1hZ2VGaWxlcykge1xyXG5cdFx0XHR2Q2FsQ2xvc2luZyArPSBcIjxpbWcgb25tb3VzZWRvd249J2phdmFzY3JpcHQ6Y2xvc2V3aW4oXFxcIlwiICsgQ2FsLkN0cmwgKyBcIlxcXCIpOyBzdG9wU3BpbigpOycgc3JjPSdcIitpbWFnZUZpbGVzUGF0aCtcImNhbF9jbG9zZS5naWYnIHdpZHRoPScxNnB4JyBoZWlnaHQ9JzE0cHgnIG9ubW91c2VvdmVyPSdjaGFuZ2VCb3JkZXIodGhpcywwKScgb25tb3VzZW91dD0nY2hhbmdlQm9yZGVyKHRoaXMsIDEpJyBzdHlsZT0nYm9yZGVyOjFweCBzb2xpZCB3aGl0ZSc+PC90ZD5cIjtcclxuXHRcdH1cclxuXHRcdGVsc2Uge1xyXG5cdFx0XHR2Q2FsQ2xvc2luZyArPSBcIjxzcGFuIGlkPSdjbG9zZV9jYWwnIHRpdGxlPSdjbG9zZSdvbm1vdXNlZG93bj0namF2YXNjcmlwdDpjbG9zZXdpbihcXFwiXCIgKyBDYWwuQ3RybCArIFwiXFxcIik7c3RvcFNwaW4oKTsnIG9ubW91c2VvdmVyPSdjaGFuZ2VCb3JkZXIodGhpcywgMCknb25tb3VzZW91dD0nY2hhbmdlQm9yZGVyKHRoaXMsIDEpJyBzdHlsZT0nYm9yZGVyOjFweCBzb2xpZCB3aGl0ZTsgZm9udC1mYW1pbHk6IEFyaWFsO2ZvbnQtc2l6ZTogMTBwdDsnPng8L3NwYW4+PC90ZD5cIjtcclxuXHRcdH1cclxuXHRcdHZDYWxDbG9zaW5nICs9IFwiPC90cj5cIjtcclxuXHR9XHJcblx0dkNhbENsb3NpbmcgKz0gXCI8L3Rib2R5PjwvdGFibGU+PC90ZD48L3RyPlwiO1xyXG5cdGNhbEhlaWdodCArPSAzMTtcclxuXHR2Q2FsQ2xvc2luZyArPSBcIjwvdGJvZHk+PC90YWJsZT5cXG48L3NwYW4+XCI7XHJcblxyXG5cdC8vZW5kIHRpbWUgcGlja2VyXHJcblx0ZnVuY0NhbGJhY2sgPSBcImZ1bmN0aW9uIGNhbGxiYWNrKGlkLCBkYXR1bSkge1wiO1xyXG5cdGZ1bmNDYWxiYWNrICs9IFwiIHZhciBDYWxJZCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGlkKTtpZiAoZGF0dW09PT0gJ3VuZGVmaW5lZCcpIHsgdmFyIGQgPSBuZXcgRGF0ZSgpOyBkYXR1bSA9IGQuZ2V0RGF0ZSgpICsgJy8nICsoZC5nZXRNb250aCgpKzEpICsgJy8nICsgZC5nZXRGdWxsWWVhcigpOyB9IHdpbmRvdy5jYWxEYXR1bT1kYXR1bTtDYWxJZC52YWx1ZT1kYXR1bTtcIjtcclxuXHRmdW5jQ2FsYmFjayArPSBcIiBpZihDYWwuU2hvd1RpbWUpe1wiO1xyXG5cdGZ1bmNDYWxiYWNrICs9IFwiIENhbElkLnZhbHVlKz0nVCcrQ2FsLmdldFNob3dIb3VyKCkrJzonK0NhbC5NaW51dGVzKyc6MDBaJztcIjtcclxuXHRmdW5jQ2FsYmFjayArPSBcIiBpZiAoQ2FsLlNob3dTZWNvbmRzKSAgQ2FsSWQudmFsdWUrPSc6JytDYWwuU2Vjb25kcztcIjtcclxuXHRmdW5jQ2FsYmFjayArPSBcIiBpZiAoVGltZU1vZGUgPT09IDEyKSAgQ2FsSWQudmFsdWUrPScnK0NhbC5nZXRTaG93QU1vclBNKCk7XCI7XHJcblx0ZnVuY0NhbGJhY2sgKz0gXCJ9aWYoQ2FsSWQub25jaGFuZ2UhPXVuZGVmaW5lZCkgQ2FsSWQub25jaGFuZ2UoKTtDYWxJZC5mb2N1cygpO3dpbkNhbC5zdHlsZS52aXNpYmlsaXR5PSdoaWRkZW4nOyAkKENhbElkKS50cmlnZ2VyKCdjaGFuZ2UnKX1cIjtcclxuXHJcblxyXG5cdC8vIGRldGVybWluZXMgaWYgdGhlcmUgaXMgZW5vdWdoIHNwYWNlIHRvIG9wZW4gdGhlIGNhbCBhYm92ZSB0aGUgcG9zaXRpb24gd2hlcmUgaXQgaXMgY2FsbGVkXHJcblx0aWYgKHlwb3MgPiBjYWxIZWlnaHQpXHJcblx0e1xyXG5cdFx0eXBvcyA9IHlwb3MgLSBjYWxIZWlnaHQ7XHJcblx0fVxyXG5cclxuXHRpZiAoIXdpbkNhbClcclxuXHR7XHJcblx0XHRoZWFkSUQgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZShcImhlYWRcIilbMF07XHJcblxyXG5cdFx0Ly8gYWRkIGphdmFzY3JpcHQgZnVuY3Rpb24gdG8gdGhlIHNwYW4gY2FsXHJcblx0XHRlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNjcmlwdFwiKTtcclxuXHRcdGUudHlwZSA9IFwidGV4dC9qYXZhc2NyaXB0XCI7XHJcblx0XHRlLmxhbmd1YWdlID0gXCJqYXZhc2NyaXB0XCI7XHJcblx0XHRlLnRleHQgPSBmdW5jQ2FsYmFjaztcclxuXHRcdGhlYWRJRC5hcHBlbmRDaGlsZChlKTtcclxuXHRcdC8vIGFkZCBzdHlsZXNoZWV0IHRvIHRoZSBzcGFuIGNhbFxyXG5cclxuXHRcdGNzc1N0ciA9IFwiLmNhbFREIHt0ZXh0LWFsaWduOiBjZW50ZXI7IGJvcmRlcjowOyB3aWR0aDozNnB4OyBoZWlnaHQ6MzZweDsgYm9yZGVyLXJhZGl1czo1MCV9XFxuXCI7XHJcblx0XHRjc3NTdHIgKz0gXCIjY2FsQm9yZGVyIHtmb250LXNpemU6IDE0cHg7IGJvcmRlci1yYWRpdXM6MHB4IDBweCA0cHggNHB4fVxcblwiO1xyXG5cdFx0Y3NzU3RyICs9IFwiLmNhbFIge3RleHQtYWxpZ246IGNlbnRlcjsgZm9udC13ZWlnaHQ6IGJvbGQ7XCIrc2hvd01vbnRoSW5IZWFkK1wifVxcblwiO1xyXG5cdFx0Y3NzU3RyICs9IFwiI2NhbEJvcmRlciB0YWJsZSwgI2NhbEJvcmRlciB0YWJsZSB0aCwgI2NhbEJvcmRlciB0YWJsZSB0ZCB7bWFyZ2luOjA7IHBhZGRpbmc6MDsgYm9yZGVyLXNwYWNpbmc6MDsgYm9yZGVyLWNvbGxhcHNlOmNvbGxhcHNlOyBib3JkZXI6MDsgYm94LXNpemluZzpib3JkZXItYm94OyAtd2Via2l0LXVzZXItc2VsZWN0OiBub25lOyAtbW96LXVzZXItc2VsZWN0OiBub25lOyAtbXMtdXNlci1zZWxlY3Q6IG5vbmU7IHVzZXItc2VsZWN0OiBub25lO31cXG5cIjtcclxuXHRcdGNzc1N0ciArPSBcIiNjYWxCb3JkZXIgaW5wdXQsICNjYWxCb3JkZXIgc2VsZWN0IHtoZWlnaHQ6YXV0bzt9XFxuXCI7XHJcblx0XHRjc3NTdHIgKz0gXCIjY2FsQm9yZGVyIHNlbGVjdCB7IC13ZWJraXQtYXBwZWFyYW5jZTogbWVudWxpc3Q7IC1tb3otYXBwZWFyYW5jZTogbWVudWxpc3Q7fVxcblwiO1xyXG5cdFx0Y3NzU3RyICs9IFwiI2NhbEJvcmRlciB0YWJsZSB0cjpudGgtY2hpbGQoZXZlbikge2JhY2tncm91bmQ6IG5vbmU7fVxcblwiO1xyXG5cdFx0Y3NzU3RyICs9ICcjY2FsQm9yZGVyIGlucHV0W3R5cGU9XCJidXR0b25cIl0sICNjYWxCb3JkZXJpbnB1dFt0eXBlPVwicmVzZXRcIl0sICNjYWxCb3JkZXIgaW5wdXRbdHlwZT1cInN1Ym1pdFwiXSB7bWFyZ2luLXRvcDogMTVweDsgZm9udC1mYW1pbHk6XCJUTVNhbnMtQm9sZFwiLEhlbHZldGljYSxBcmlhbCxzYW5zLXNlcmlmOyBmb250LXNpemU6MTJweDsgd2lkdGg6NDUlOyBib3JkZXI6MnB4IHNvbGlkICNiN2M5ZDM7IGJvcmRlci1yYWRpdXM6NHB4OyB0ZXh0LXRyYW5zZm9ybTp1cHBlcmNhc2U7IGNvbG9yOiNiN2M5ZDM7IHBhZGRpbmc6NHB4OyBtYXJnaW4tYm90dG9tOjEycHg7fVxcbic7XHJcblx0XHRjc3NTdHIgKz0gJyNjYWxCb3JkZXIgLk1vbnRoU2VsZWN0b3JUaXRsZSB7cG9zaXRpb246IHJlbGF0aXZlOyBmb250LWZhbWlseTogXCJUTVNhbnMtQm9sZFwiLCBBcmlhbCwgc2VyaWY7IGZvbnQtc2l6ZTogMTRweDsgY29sb3I6ICNiN2M5ZDM7IGRpc3BsYXk6IGJsb2NrOyBmbG9hdDogbGVmdDsgbWFyZ2luLWxlZnQ6IDVweDsgcGFkZGluZy1yaWdodDoyNHB4OyAtd2Via2l0LXRyYW5zaXRpb246IGNvbG9yIDAuM3MgZWFzZS1pbi1vdXQ7IC1vLXRyYW5zaXRpb246IGNvbG9yIDAuM3MgZWFzZS1pbi1vdXQ7IHRyYW5zaXRpb246IGNvbG9yIDAuM3MgZWFzZS1pbi1vdXQ7IC13ZWJraXQtdXNlci1zZWxlY3Q6IG5vbmU7IC1tb3otdXNlci1zZWxlY3Q6IG5vbmU7IC1tcy11c2VyLXNlbGVjdDogbm9uZTsgdXNlci1zZWxlY3Q6IG5vbmU7fVxcbic7XHJcblx0XHRjc3NTdHIgKz0gJyNjYWxCb3JkZXIgLk1vbnRoU2VsZWN0b3JUaXRsZTpob3ZlciB7Y29sb3I6ICMxODlkZGM7IGN1cnNvcjogcG9pbnRlcjt9XFxuJztcclxuXHRcdGNzc1N0ciArPSAnI2NhbEJvcmRlciAuTW9udGhTZWxlY3RvclRpdGxlOmhvdmVyOmJlZm9yZSB7b3BhY2l0eToxO31cXG4nO1xyXG5cdFx0Y3NzU3RyICs9ICcjY2FsQm9yZGVyIC5Nb250aFNlbGVjdG9yVGl0bGU6aG92ZXI6YWZ0ZXIge29wYWNpdHk6MDt9XFxuJztcclxuXHRcdGNzc1N0ciArPSAnI2NhbEJvcmRlciAuTW9udGhTZWxlY3RvclRpdGxlOmhvdmVyOmFmdGVyIHtjb2xvcjogIzE4OWRkYzsgY3Vyc29yOiBwb2ludGVyO31cXG4nO1xyXG5cdFx0Y3NzU3RyICs9ICcjY2FsQm9yZGVyIC5Nb250aFNlbGVjdG9yVGl0bGUuWWVhciB7ZmxvYXQ6IHJpZ2h0O31cXG4nO1xyXG5cdFx0Y3NzU3RyICs9ICcjY2FsQm9yZGVyIC5Nb250aFNlbGVjdG9yVGl0bGU6YmVmb3JlLCAjY2FsQm9yZGVyIC5Nb250aFNlbGVjdG9yVGl0bGU6YWZ0ZXIge2NvbnRlbnQ6IFwiXCI7IHBvc2l0aW9uOiBhYnNvbHV0ZTsgcmlnaHQ6IDA7IHRvcDogNTAlOyB3aWR0aDogMTVweDsgaGVpZ2h0OiAxMHB4OyBtYXJnaW4tdG9wOiAtNXB4OyBiYWNrZ3JvdW5kLXBvc2l0aW9uOiBjZW50ZXIgY2VudGVyOyBiYWNrZ3JvdW5kLXJlcGVhdDogbm8tcmVwZWF0OyAtd2Via2l0LXRyYW5zaXRpb246IG9wYWNpdHkgMC4ycyBlYXNlLWluLW91dDsgLW8tdHJhbnNpdGlvbjogb3BhY2l0eSAwLjJzIGVhc2UtaW4tb3V0OyB0cmFuc2l0aW9uOiBvcGFjaXR5IDAuMnMgZWFzZS1pbi1vdXQ7fVxcbic7XHJcblx0XHRjc3NTdHIgKz0gJyNjYWxCb3JkZXIgLk1vbnRoU2VsZWN0b3JUaXRsZTpiZWZvcmUge29wYWNpdHk6MDsgYmFja2dyb3VuZDogdXJsKFwiaHR0cDovL2RldmVsb3Blci50aWNrZXRtYXN0ZXIuY29tL2Fzc2V0cy93aWRnZXRzLzEuMC4wL2ltZy9zbWFsbC1zaGV2cm9uLWhvdmVyLnN2Z1wiKSBjZW50ZXIgY2VudGVyIG5vLXJlcGVhdDtcXG59JztcclxuXHRcdGNzc1N0ciArPSAnI2NhbEJvcmRlciAuTW9udGhTZWxlY3RvclRpdGxlOmFmdGVyIHtiYWNrZ3JvdW5kOiB1cmwoXCJodHRwOi8vZGV2ZWxvcGVyLnRpY2tldG1hc3Rlci5jb20vYXNzZXRzL3dpZGdldHMvMS4wLjAvaW1nL3NtYWxsLXNoZXZyb24uc3ZnXCIpIGNlbnRlciBjZW50ZXIgbm8tcmVwZWF0O31cXG4nO1xyXG5cdFx0Y3NzU3RyICs9ICcjY2FsQm9yZGVyIHVsLk1vbnRoU2VsZWN0b3Ige2Rpc3BsYXk6IG5vbmU7IGJhY2tncm91bmQ6I2I3YzlkMjsgbWFyZ2luLWJvdHRvbTo1cHg7IGZvbnQtZmFtaWx5OiBcIlRNU2Fucy1Cb2xkXCIsIEFyaWFsLCBzZXJpZjsgZm9udC1zaXplOiAxNHB4OyBwYWRkaW5nOiAxMHB4IDE1cHg7IG1hcmdpbjowOyB0b3A6MzVweDsgbGVmdDowOyBwb3NpdGlvbjogYWJzb2x1dGU7fVxcbic7XHJcblx0XHRjc3NTdHIgKz0gJyNjYWxCb3JkZXIgdWwuTW9udGhTZWxlY3Rvci5zaG93IHtkaXNwbGF5OiBibG9jazt9XFxuJztcclxuXHRcdGNzc1N0ciArPSAnI2NhbEJvcmRlciB1bC5Nb250aFNlbGVjdG9yLlllYXIge2xlZnQ6YXV0bzsgcmlnaHQ6MDsgcGFkZGluZzogMTBweCAzNHB4O31cXG4nO1xyXG5cdFx0Y3NzU3RyICs9ICcjY2FsQm9yZGVyIHVsLk1vbnRoU2VsZWN0b3IuWWVhci5zaG93IHtkaXNwbGF5OiBibG9jazt9XFxuJztcclxuXHRcdGNzc1N0ciArPSAnI2NhbEJvcmRlciB1bC5Nb250aFNlbGVjdG9yIGxpIHsgZm9udC1mYW1pbHk6IFwiVE1TYW5zLUJvbGRcIiwgQXJpYWwsIHNlcmlmOyBmb250LXNpemU6IDE0cHg7IG1hcmdpbjowOyBwYWRkaW5nOjA7IGxpbmUtaGVpZ2h0OjI3cHg7IGNvbG9yOiAjZmZmOyAtd2Via2l0LXVzZXItc2VsZWN0OiBub25lOyAtbW96LXVzZXItc2VsZWN0OiBub25lOyAtbXMtdXNlci1zZWxlY3Q6IG5vbmU7IHVzZXItc2VsZWN0OiBub25lO31cXG4nO1xyXG5cdFx0Y3NzU3RyICs9ICcjY2FsQm9yZGVyIHVsLk1vbnRoU2VsZWN0b3IgbGk6aG92ZXIge2NvbG9yOiAjMTg5ZGRjOyBjdXJzb3I6IHBvaW50ZXI7fVxcbic7XHJcblx0XHRjc3NTdHIgKz0gJyNjYWxPdmVybGF5IHt3aWR0aDogMTAwJTsgaGVpZ2h0OiAxMDAlOyBwb3NpdGlvbjogZml4ZWQ7IHRvcDogMDsgbGVmdDogMDsgZGlzcGxheTogbm9uZTt9XFxuJztcclxuXHRcdGNzc1N0ciArPSAnI2NhbE92ZXJsYXkuc2hvdyB7ZGlzcGxheTogYmxvY2s7fVxcbic7XHJcblxyXG5cdFx0c3R5bGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3R5bGVcIik7XHJcblx0XHRzdHlsZS50eXBlID0gXCJ0ZXh0L2Nzc1wiO1xyXG5cdFx0c3R5bGUucmVsID0gXCJzdHlsZXNoZWV0XCI7XHJcblx0XHRpZiAoc3R5bGUuc3R5bGVTaGVldClcclxuXHRcdHsgLy8gSUVcclxuXHRcdFx0c3R5bGUuc3R5bGVTaGVldC5jc3NUZXh0ID0gY3NzU3RyO1xyXG5cdFx0fVxyXG5cclxuXHRcdGVsc2VcclxuXHRcdHsgLy8gdzNjXHJcblx0XHRcdGNzc1RleHQgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShjc3NTdHIpO1xyXG5cdFx0XHRzdHlsZS5hcHBlbmRDaGlsZChjc3NUZXh0KTtcclxuXHRcdH1cclxuXHJcblx0XHRoZWFkSUQuYXBwZW5kQ2hpbGQoc3R5bGUpO1xyXG5cdFx0Ly8gY3JlYXRlIHRoZSBvdXRlciBmcmFtZSB0aGF0IGFsbG93cyB0aGUgY2FsLiB0byBiZSBtb3ZlZFxyXG5cdFx0c3BhbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpO1xyXG5cdFx0c3Bhbi5pZCA9IGNhbFNwYW5JRDtcclxuXHRcdHNwYW4uc3R5bGUucG9zaXRpb24gPSBcImFic29sdXRlXCI7XHJcblx0XHRzcGFuLnN0eWxlLmxlZnQgPSAoeHBvcyArIENhbFBvc09mZnNldFgpICsgJ3B4JztcclxuXHRcdHNwYW4uc3R5bGUudG9wID0gKHlwb3MgLSBDYWxQb3NPZmZzZXRZKSArICdweCc7XHJcblx0XHRzcGFuLnN0eWxlLndpZHRoID0gQ2FsV2lkdGggKyAncHgnO1xyXG5cdFx0c3Bhbi5zdHlsZS5ib3JkZXIgPSBcInNvbGlkIDFweCBcIiArIFNwYW5Cb3JkZXJDb2xvcjtcclxuXHRcdHNwYW4uc3R5bGUucGFkZGluZyA9IFwiMFwiO1xyXG5cdFx0c3Bhbi5zdHlsZS5jdXJzb3IgPSBcIm1vdmVcIjtcclxuXHRcdHNwYW4uc3R5bGUuYmFja2dyb3VuZENvbG9yID0gU3BhbkJnQ29sb3I7XHJcblx0XHRzcGFuLnN0eWxlLnpJbmRleCA9IDE7XHJcblx0XHR2YXIgb3ZlcmxheSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XHJcblx0XHRvdmVybGF5LmlkID0gXCJjYWxPdmVybGF5XCI7XHJcblx0XHRvdmVybGF5LmNsYXNzTGlzdC5hZGQoXCJzaG93XCIpO1xyXG5cdFx0ZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChzcGFuKTtcclxuXHRcdGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQob3ZlcmxheSk7XHJcblx0XHR3aW5DYWwgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChjYWxTcGFuSUQpO1xyXG5cdH1cclxuXHJcblx0ZWxzZVxyXG5cdHtcclxuXHRcdHdpbkNhbC5zdHlsZS52aXNpYmlsaXR5ID0gXCJ2aXNpYmxlXCI7XHJcblx0XHR3aW5DYWwuc3R5bGUuSGVpZ2h0ID0gY2FsSGVpZ2h0O1xyXG5cclxuXHRcdC8vIHNldCB0aGUgcG9zaXRpb24gZm9yIGEgbmV3IGNhbGVuZGFyIG9ubHlcclxuXHRcdGlmIChiTmV3Q2FsID09PSB0cnVlKVxyXG5cdFx0e1xyXG5cdFx0XHR3aW5DYWwuc3R5bGUubGVmdCA9ICh4cG9zICsgQ2FsUG9zT2Zmc2V0WCkgKyAncHgnO1xyXG5cdFx0XHR3aW5DYWwuc3R5bGUudG9wID0gKHlwb3MgLSBDYWxQb3NPZmZzZXRZKSArICdweCc7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHR3aW5DYWwuaW5uZXJIVE1MID0gd2luQ2FsRGF0YSArIHZDYWxIZWFkZXIgKyB2Q2FsRGF0YSArIHZDYWxUaW1lICsgdkNhbENsb3Npbmc7XHJcblx0cmV0dXJuIHRydWU7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIE5ld0Nzc0NhbChwQ3RybCwgcEZvcm1hdCwgcFNjcm9sbGVyLCBwU2hvd1RpbWUsIHBUaW1lTW9kZSwgcFNob3dTZWNvbmRzLCBwRW5hYmxlRGF0ZU1vZGUpIHtcclxuXHQvLyBnZXQgY3VycmVudCBkYXRlIGFuZCB0aW1lXHJcblxyXG5cdGR0VG9kYXkgPSBuZXcgRGF0ZSgpO1xyXG5cdENhbCA9IG5ldyBDYWxlbmRhcihkdFRvZGF5KTtcclxuXHJcblx0aWYgKHBTaG93VGltZSAhPT0gdW5kZWZpbmVkKSB7XHJcblx0XHRpZiAocFNob3dUaW1lKSB7XHJcblx0XHRcdENhbC5TaG93VGltZSA9IHRydWU7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRDYWwuU2hvd1RpbWUgPSBmYWxzZTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAocFRpbWVNb2RlKSB7XHJcblx0XHRcdHBUaW1lTW9kZSA9IHBhcnNlSW50KHBUaW1lTW9kZSwgMTApO1xyXG5cdFx0fVxyXG5cdFx0aWYgKHBUaW1lTW9kZSA9PT0gMTIgfHwgcFRpbWVNb2RlID09PSAyNCkge1xyXG5cdFx0XHRUaW1lTW9kZSA9IHBUaW1lTW9kZTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdFRpbWVNb2RlID0gMjQ7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKHBTaG93U2Vjb25kcyAhPT0gdW5kZWZpbmVkKSB7XHJcblx0XHRcdGlmIChwU2hvd1NlY29uZHMpIHtcclxuXHRcdFx0XHRDYWwuU2hvd1NlY29uZHMgPSB0cnVlO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdENhbC5TaG93U2Vjb25kcyA9IGZhbHNlO1xyXG5cdFx0XHR9XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRDYWwuU2hvd1NlY29uZHMgPSBmYWxzZTtcclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxuXHRpZiAocEN0cmwgIT09IHVuZGVmaW5lZCkge1xyXG5cdFx0Q2FsLkN0cmwgPSBwQ3RybDtcclxuXHR9XHJcblxyXG5cdGlmIChwRm9ybWF0IT09IHVuZGVmaW5lZCAmJiBwRm9ybWF0ICE9PVwiXCIpIHtcclxuXHRcdENhbC5Gb3JtYXQgPSBwRm9ybWF0LnRvVXBwZXJDYXNlKCk7XHJcblx0fSBlbHNlIHtcclxuXHRcdENhbC5Gb3JtYXQgPSBcIk1NRERZWVlZXCI7XHJcblx0fVxyXG5cclxuXHRpZiAocFNjcm9sbGVyIT09IHVuZGVmaW5lZCAmJiBwU2Nyb2xsZXIhPT1cIlwiKSB7XHJcblx0XHRpZiAocFNjcm9sbGVyLnRvVXBwZXJDYXNlKCkgPT09IFwiQVJST1dcIikge1xyXG5cdFx0XHRDYWwuU2Nyb2xsZXIgPSBcIkFSUk9XXCI7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRDYWwuU2Nyb2xsZXIgPSBcIkRST1BET1dOXCI7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHRpZiAocEVuYWJsZURhdGVNb2RlICE9PSB1bmRlZmluZWQgJiYgKHBFbmFibGVEYXRlTW9kZSA9PT0gXCJmdXR1cmVcIiB8fCBwRW5hYmxlRGF0ZU1vZGUgPT09IFwicGFzdFwiKSkge1xyXG5cdFx0Q2FsLkVuYWJsZURhdGVNb2RlPSBwRW5hYmxlRGF0ZU1vZGU7XHJcblx0fVxyXG5cclxuXHRleERhdGVUaW1lID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQocEN0cmwpLnZhbHVlOyAvL0V4aXN0aW5nIERhdGUgVGltZSB2YWx1ZSBpbiB0ZXh0Ym94LlxyXG5cclxuXHRpZiAoZXhEYXRlVGltZSkgeyAvL1BhcnNlIGV4aXN0aW5nIERhdGUgU3RyaW5nXHJcblx0XHR2YXIgU3AxID0gZXhEYXRlVGltZS5pbmRleE9mKERhdGVTZXBhcmF0b3IsIDApLC8vSW5kZXggb2YgRGF0ZSBTZXBhcmF0b3IgMVxyXG5cdFx0XHRTcDIgPSBleERhdGVUaW1lLmluZGV4T2YoRGF0ZVNlcGFyYXRvciwgcGFyc2VJbnQoU3AxLCAxMCkgKyAxKSwvL0luZGV4IG9mIERhdGUgU2VwYXJhdG9yIDJcclxuXHRcdFx0dFNwMSwvL0luZGV4IG9mIFRpbWUgU2VwYXJhdG9yIDFcclxuXHRcdFx0dFNwMiwvL0luZGV4IG9mIFRpbWUgU2VwYXJhdG9yIDJcclxuXHRcdFx0c3RyTW9udGgsXHJcblx0XHRcdHN0ckRhdGUsXHJcblx0XHRcdHN0clllYXIsXHJcblx0XHRcdGludE1vbnRoLFxyXG5cdFx0XHRZZWFyUGF0dGVybixcclxuXHRcdFx0c3RySG91cixcclxuXHRcdFx0c3RyTWludXRlLFxyXG5cdFx0XHRzdHJTZWNvbmQsXHJcblx0XHRcdHdpbkhlaWdodCxcclxuXHRcdFx0b2Zmc2V0ID0gcGFyc2VJbnQoQ2FsLkZvcm1hdC50b1VwcGVyQ2FzZSgpLmxhc3RJbmRleE9mKFwiTVwiKSwgMTApIC0gcGFyc2VJbnQoQ2FsLkZvcm1hdC50b1VwcGVyQ2FzZSgpLmluZGV4T2YoXCJNXCIpLCAxMCkgLSAxLFxyXG5cdFx0XHRzdHJBTVBNID0gXCJcIjtcclxuXHRcdC8vcGFyc2UgbW9udGhcclxuXHJcblx0XHRpZiAoQ2FsLkZvcm1hdC50b1VwcGVyQ2FzZSgpID09PSBcIkRETU1ZWVlZXCIgfHwgQ2FsLkZvcm1hdC50b1VwcGVyQ2FzZSgpID09PSBcIkRETU1NWVlZWVwiKSB7XHJcblx0XHRcdGlmIChEYXRlU2VwYXJhdG9yID09PSBcIlwiKVxyXG5cdFx0XHR7XHJcblx0XHRcdFx0c3RyTW9udGggPSBleERhdGVUaW1lLnN1YnN0cmluZygyLCA0ICsgb2Zmc2V0KTtcclxuXHRcdFx0XHRzdHJEYXRlID0gZXhEYXRlVGltZS5zdWJzdHJpbmcoMCwgMik7XHJcblx0XHRcdFx0c3RyWWVhciA9IGV4RGF0ZVRpbWUuc3Vic3RyaW5nKDQgKyBvZmZzZXQsIDggKyBvZmZzZXQpO1xyXG5cdFx0XHR9XHJcblx0XHRcdGVsc2VcclxuXHRcdFx0e1xyXG5cdFx0XHRcdGlmIChleERhdGVUaW1lLmluZGV4T2YoXCJEKlwiKSAhPT0gLTEpXHJcblx0XHRcdFx0eyAgIC8vRFRHXHJcblx0XHRcdFx0XHRzdHJNb250aCA9IGV4RGF0ZVRpbWUuc3Vic3RyaW5nKDgsIDExKTtcclxuXHRcdFx0XHRcdHN0ckRhdGUgID0gZXhEYXRlVGltZS5zdWJzdHJpbmcoMCwgMik7XHJcblx0XHRcdFx0XHRzdHJZZWFyICA9IFwiMjBcIiArIGV4RGF0ZVRpbWUuc3Vic3RyaW5nKDExLCAxMyk7ICAvL0hhY2ssIG51ciBmw7xyIEphaHJlc3phaGxlbiBhYiAyMDAwXHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGVsc2VcclxuXHRcdFx0XHR7XHJcblx0XHRcdFx0XHRzdHJNb250aCA9IGV4RGF0ZVRpbWUuc3Vic3RyaW5nKFNwMSArIDEsIFNwMik7XHJcblx0XHRcdFx0XHRzdHJEYXRlID0gZXhEYXRlVGltZS5zdWJzdHJpbmcoMCwgU3AxKTtcclxuXHRcdFx0XHRcdHN0clllYXIgPSBleERhdGVUaW1lLnN1YnN0cmluZyhTcDIgKyAxLCBTcDIgKyA1KTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRlbHNlIGlmIChDYWwuRm9ybWF0LnRvVXBwZXJDYXNlKCkgPT09IFwiTU1ERFlZWVlcIiB8fCBDYWwuRm9ybWF0LnRvVXBwZXJDYXNlKCkgPT09IFwiTU1NRERZWVlZXCIpIHtcclxuXHRcdFx0aWYgKERhdGVTZXBhcmF0b3IgPT09IFwiXCIpIHtcclxuXHRcdFx0XHRzdHJNb250aCA9IGV4RGF0ZVRpbWUuc3Vic3RyaW5nKDAsIDIgKyBvZmZzZXQpO1xyXG5cdFx0XHRcdHN0ckRhdGUgPSBleERhdGVUaW1lLnN1YnN0cmluZygyICsgb2Zmc2V0LCA0ICsgb2Zmc2V0KTtcclxuXHRcdFx0XHRzdHJZZWFyID0gZXhEYXRlVGltZS5zdWJzdHJpbmcoNCArIG9mZnNldCwgOCArIG9mZnNldCk7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0c3RyTW9udGggPSBleERhdGVUaW1lLnN1YnN0cmluZygwLCBTcDEpO1xyXG5cdFx0XHRcdHN0ckRhdGUgPSBleERhdGVUaW1lLnN1YnN0cmluZyhTcDEgKyAxLCBTcDIpO1xyXG5cdFx0XHRcdHN0clllYXIgPSBleERhdGVUaW1lLnN1YnN0cmluZyhTcDIgKyAxLCBTcDIgKyA1KTtcclxuXHRcdFx0fVxyXG5cdFx0fVx0ZWxzZSBpZiAoQ2FsLkZvcm1hdC50b1VwcGVyQ2FzZSgpID09PSBcIllZWVlNTUREXCIgfHwgQ2FsLkZvcm1hdC50b1VwcGVyQ2FzZSgpID09PSBcIllZWVlNTU1ERFwiKSB7XHJcblx0XHRcdGlmIChEYXRlU2VwYXJhdG9yID09PSBcIlwiKSB7XHJcblx0XHRcdFx0c3RyTW9udGggPSBleERhdGVUaW1lLnN1YnN0cmluZyg0LCA2ICsgb2Zmc2V0KTtcclxuXHRcdFx0XHRzdHJEYXRlID0gZXhEYXRlVGltZS5zdWJzdHJpbmcoNiArIG9mZnNldCwgOCArIG9mZnNldCk7XHJcblx0XHRcdFx0c3RyWWVhciA9IGV4RGF0ZVRpbWUuc3Vic3RyaW5nKDAsIDQpO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdHN0ck1vbnRoID0gZXhEYXRlVGltZS5zdWJzdHJpbmcoU3AxICsgMSwgU3AyKTtcclxuXHRcdFx0XHRzdHJEYXRlID0gZXhEYXRlVGltZS5zdWJzdHJpbmcoU3AyICsgMSwgU3AyICsgMyk7XHJcblx0XHRcdFx0c3RyWWVhciA9IGV4RGF0ZVRpbWUuc3Vic3RyaW5nKDAsIFNwMSk7XHJcblx0XHRcdH1cclxuXHRcdH0gZWxzZSBpZiAoQ2FsLkZvcm1hdC50b1VwcGVyQ2FzZSgpID09PSBcIllZTU1ERFwiIHx8IENhbC5Gb3JtYXQudG9VcHBlckNhc2UoKSA9PT0gXCJZWU1NTUREXCIpIHtcclxuXHRcdFx0aWYgKERhdGVTZXBhcmF0b3IgPT09IFwiXCIpXHJcblx0XHRcdHtcclxuXHRcdFx0XHRzdHJNb250aCA9IGV4RGF0ZVRpbWUuc3Vic3RyaW5nKDIsIDQgKyBvZmZzZXQpO1xyXG5cdFx0XHRcdHN0ckRhdGUgPSBleERhdGVUaW1lLnN1YnN0cmluZyg0ICsgb2Zmc2V0LCA2ICsgb2Zmc2V0KTtcclxuXHRcdFx0XHRzdHJZZWFyID0gZXhEYXRlVGltZS5zdWJzdHJpbmcoMCwgMik7XHJcblx0XHRcdH1cclxuXHRcdFx0ZWxzZVxyXG5cdFx0XHR7XHJcblx0XHRcdFx0c3RyTW9udGggPSBleERhdGVUaW1lLnN1YnN0cmluZyhTcDEgKyAxLCBTcDIpO1xyXG5cdFx0XHRcdHN0ckRhdGUgPSBleERhdGVUaW1lLnN1YnN0cmluZyhTcDIgKyAxLCBTcDIgKyAzKTtcclxuXHRcdFx0XHRzdHJZZWFyID0gZXhEYXRlVGltZS5zdWJzdHJpbmcoMCwgU3AxKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChpc05hTihzdHJNb250aCkpIHtcclxuXHRcdFx0aW50TW9udGggPSBDYWwuR2V0TW9udGhJbmRleChzdHJNb250aCk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRpbnRNb250aCA9IHBhcnNlSW50KHN0ck1vbnRoLCAxMCkgLSAxO1xyXG5cdFx0fVxyXG5cdFx0aWYgKChwYXJzZUludChpbnRNb250aCwgMTApID49IDApICYmIChwYXJzZUludChpbnRNb250aCwgMTApIDwgMTIpKVx0e1xyXG5cdFx0XHRDYWwuTW9udGggPSBpbnRNb250aDtcclxuXHRcdH1cclxuXHRcdC8vZW5kIHBhcnNlIG1vbnRoXHJcblxyXG5cdFx0Ly9wYXJzZSB5ZWFyXHJcblx0XHRZZWFyUGF0dGVybiA9IC9eXFxkezR9JC87XHJcblx0XHRpZiAoWWVhclBhdHRlcm4udGVzdChzdHJZZWFyKSkge1xyXG5cdFx0XHRpZiAoKHBhcnNlSW50KHN0clllYXIsIDEwKT49U3RhcnRZZWFyKSAmJiAocGFyc2VJbnQoc3RyWWVhciwgMTApPD0gKGR0VG9kYXkuZ2V0RnVsbFllYXIoKStFbmRZZWFyKSkpXHJcblx0XHRcdFx0Q2FsLlllYXIgPSBwYXJzZUludChzdHJZZWFyLCAxMCk7XHJcblx0XHR9XHJcblx0XHQvL2VuZCBwYXJzZSB5ZWFyXHJcblxyXG5cdFx0Ly9wYXJzZSBEYXRlXHJcblx0XHRpZiAoKHBhcnNlSW50KHN0ckRhdGUsIDEwKSA8PSBDYWwuR2V0TW9uRGF5cygpKSAmJiAocGFyc2VJbnQoc3RyRGF0ZSwgMTApID49IDEpKSB7XHJcblx0XHRcdENhbC5EYXRlID0gc3RyRGF0ZTtcclxuXHRcdH1cclxuXHRcdC8vZW5kIHBhcnNlIERhdGVcclxuXHJcblx0XHQvL3BhcnNlIHRpbWVcclxuXHJcblx0XHRpZiAoQ2FsLlNob3dUaW1lID09PSB0cnVlKSB7XHJcblx0XHRcdC8vcGFyc2UgQU0gb3IgUE1cclxuXHRcdFx0aWYgKFRpbWVNb2RlID09PSAxMikge1xyXG5cdFx0XHRcdHN0ckFNUE0gPSBleERhdGVUaW1lLnN1YnN0cmluZyhleERhdGVUaW1lLmxlbmd0aCAtIDIsIGV4RGF0ZVRpbWUubGVuZ3RoKTtcclxuXHRcdFx0XHRDYWwuQU1vclBNID0gc3RyQU1QTTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0dFNwMSA9IGV4RGF0ZVRpbWUuaW5kZXhPZihcIjpcIiwgMCk7XHJcblx0XHRcdHRTcDIgPSBleERhdGVUaW1lLmluZGV4T2YoXCI6XCIsIChwYXJzZUludCh0U3AxLCAxMCkgKyAxKSk7XHJcblxyXG5cdFx0XHRpZiAodFNwMSA+IDApIHtcclxuXHRcdFx0XHRzdHJIb3VyID0gZXhEYXRlVGltZS5zdWJzdHJpbmcodFNwMSwgdFNwMSAtIDIpO1xyXG5cdFx0XHRcdENhbC5TZXRIb3VyKHN0ckhvdXIpO1xyXG5cdFx0XHRcdHN0ck1pbnV0ZSA9IGV4RGF0ZVRpbWUuc3Vic3RyaW5nKHRTcDEgKyAxLCB0U3AxICsgMyk7XHJcblx0XHRcdFx0Q2FsLlNldE1pbnV0ZShzdHJNaW51dGUpO1xyXG5cdFx0XHRcdHN0clNlY29uZCA9IGV4RGF0ZVRpbWUuc3Vic3RyaW5nKHRTcDIgKyAxLCB0U3AyICsgMyk7XHJcblx0XHRcdFx0Q2FsLlNldFNlY29uZChzdHJTZWNvbmQpO1xyXG5cdFx0XHR9IGVsc2UgaWYgKGV4RGF0ZVRpbWUuaW5kZXhPZihcIkQqXCIpICE9PSAtMSkgeyAgIC8vRFRHXHJcblx0XHRcdFx0c3RySG91ciA9IGV4RGF0ZVRpbWUuc3Vic3RyaW5nKDIsIDQpO1xyXG5cdFx0XHRcdENhbC5TZXRIb3VyKHN0ckhvdXIpO1xyXG5cdFx0XHRcdHN0ck1pbnV0ZSA9IGV4RGF0ZVRpbWUuc3Vic3RyaW5nKDQsIDYpO1xyXG5cdFx0XHRcdENhbC5TZXRNaW51dGUoc3RyTWludXRlKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH1cclxuXHRzZWxEYXRlID0gbmV3IERhdGUoQ2FsLlllYXIsIENhbC5Nb250aCwgQ2FsLkRhdGUpOyAvL3ZlcnNpb24gMS43XHJcblx0UmVuZGVyQ3NzQ2FsKHRydWUpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBjbG9zZXdpbihpZCkge1xyXG5cdGlmIChDYWwuU2hvd1RpbWUgPT09IHRydWUpIHtcclxuXHRcdHZhciBNYXhZZWFyID0gZHRUb2RheS5nZXRGdWxsWWVhcigpICsgRW5kWWVhcjtcclxuXHRcdHZhciBiZWZvcmVUb2RheSA9XHJcblx0XHRcdChDYWwuRGF0ZSA8IGR0VG9kYXkuZ2V0RGF0ZSgpKSAmJlxyXG5cdFx0XHQoQ2FsLk1vbnRoID09PSBkdFRvZGF5LmdldE1vbnRoKCkpICYmXHJcblx0XHRcdChDYWwuWWVhciA9PT0gZHRUb2RheS5nZXRGdWxsWWVhcigpKVxyXG5cdFx0XHR8fFxyXG5cdFx0XHQoQ2FsLk1vbnRoIDwgZHRUb2RheS5nZXRNb250aCgpKSAmJlxyXG5cdFx0XHQoQ2FsLlllYXIgPT09IGR0VG9kYXkuZ2V0RnVsbFllYXIoKSlcclxuXHRcdFx0fHxcclxuXHRcdFx0KENhbC5ZZWFyIDwgZHRUb2RheS5nZXRGdWxsWWVhcigpKTtcclxuXHJcblx0XHRpZiAoKENhbC5ZZWFyIDw9IE1heFllYXIpICYmIChDYWwuWWVhciA+PSBTdGFydFllYXIpICYmIChDYWwuTW9udGggPT09IHNlbERhdGUuZ2V0TW9udGgoKSkgJiYgKENhbC5ZZWFyID09PSBzZWxEYXRlLmdldEZ1bGxZZWFyKCkpKSB7XHJcblx0XHRcdGlmIChDYWwuRW5hYmxlRGF0ZU1vZGUgPT09IFwiZnV0dXJlXCIpIHtcclxuXHRcdFx0XHRpZiAoYmVmb3JlVG9kYXkgPT09IGZhbHNlKSB7XHJcblx0XHRcdFx0XHRjYWxsYmFjayhpZCwgQ2FsLkZvcm1hdERhdGUoQ2FsLkRhdGUpKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdFx0ZWxzZVxyXG5cdFx0XHRcdGNhbGxiYWNrKGlkLCBDYWwuRm9ybWF0RGF0ZShDYWwuRGF0ZSkpO1xyXG5cdFx0fVxyXG5cdH1cclxuXHR2YXIgQ2FsSWQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChpZCk7XHJcblx0Q2FsSWQuZm9jdXMoKTtcclxuXHR3aW5DYWwuc3R5bGUudmlzaWJpbGl0eSA9ICdoaWRkZW4nO1xyXG5cdGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdjYWxPdmVybGF5JykuY2xhc3NMaXN0LnJlbW92ZSgnc2hvdycpO1xyXG5cdHZhciBhY3RpdmVJY29ucyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJy5kdC1pY28nKTtcclxuXHR2YXIgYWlDb3VudExlbmdodCA9IGFjdGl2ZUljb25zLmxlbmd0aDtcclxuXHRmb3IgKHZhciBhaUNvdW50ID0gMDsgYWlDb3VudCA8IGFpQ291bnRMZW5naHQ7ICsrYWlDb3VudCkge1xyXG5cdFx0YWN0aXZlSWNvbnNbYWlDb3VudF0uY2xhc3NMaXN0LnJlbW92ZSgnYWN0aXZlJyk7XHJcblx0fVxyXG59XHJcblxyXG5mdW5jdGlvbiB3aW5jbG9zZSgpIHtcclxuXHR3aW5DYWwuc3R5bGUudmlzaWJpbGl0eSA9ICdoaWRkZW4nO1xyXG5cdGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdjYWxPdmVybGF5JykuY2xhc3NMaXN0LnJlbW92ZSgnc2hvdycpO1xyXG5cdHZhciBhY3RpdmVJY29ucyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJy5kdC1pY28nKTtcclxuXHR2YXIgYWlDb3VudExlbmdodCA9IGFjdGl2ZUljb25zLmxlbmd0aDtcclxuXHRmb3IgKHZhciBhaUNvdW50ID0gMDsgYWlDb3VudCA8IGFpQ291bnRMZW5naHQ7ICsrYWlDb3VudCkge1xyXG5cdFx0YWN0aXZlSWNvbnNbYWlDb3VudF0uY2xhc3NMaXN0LnJlbW92ZSgnYWN0aXZlJyk7XHJcblx0fVxyXG59XHJcblxyXG5mdW5jdGlvbiBjaGFuZ2VCb3JkZXIoZWxlbWVudCwgY29sLCBvbGRCZ0NvbG9yKSB7XHJcblx0aWYgKGNvbCA9PT0gMClcclxuXHR7XHJcblx0XHRlbGVtZW50LnN0eWxlLmJhY2tncm91bmQgPSBIb3ZlckNvbG9yO1xyXG5cdFx0ZWxlbWVudC5zdHlsZS5ib3JkZXJDb2xvciA9IFwiYmxhY2tcIjtcclxuXHRcdGVsZW1lbnQuc3R5bGUuY3Vyc29yID0gXCJwb2ludGVyXCI7XHJcblx0fVxyXG5cclxuXHRlbHNlXHJcblx0e1xyXG5cdFx0aWYgKG9sZEJnQ29sb3IpXHJcblx0XHR7XHJcblx0XHRcdGVsZW1lbnQuc3R5bGUuYmFja2dyb3VuZCA9IG9sZEJnQ29sb3I7XHJcblx0XHR9XHJcblx0XHRlbHNlXHJcblx0XHR7XHJcblx0XHRcdGVsZW1lbnQuc3R5bGUuYmFja2dyb3VuZCA9IFwid2hpdGVcIjtcclxuXHRcdH1cclxuXHRcdGVsZW1lbnQuc3R5bGUuYm9yZGVyQ29sb3IgPSBcIndoaXRlXCI7XHJcblx0XHRlbGVtZW50LnN0eWxlLmN1cnNvciA9IFwiYXV0b1wiO1xyXG5cdH1cclxufVxyXG5cclxuZnVuY3Rpb24gc2VsZWN0RGF0ZShlbGVtZW50LCBkYXRlKSB7XHJcblx0Q2FsLkRhdGUgPSBkYXRlO1xyXG5cdHNlbERhdGUgPSBuZXcgRGF0ZShDYWwuWWVhciwgQ2FsLk1vbnRoLCBDYWwuRGF0ZSk7XHJcblx0ZWxlbWVudC5zdHlsZS5iYWNrZ3JvdW5kID0gU2VsRGF0ZUNvbG9yO1xyXG5cdFJlbmRlckNzc0NhbCgpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBmaW5kUG9zKG9iaikge1xyXG5cdHZhciBjdXJsZWZ0ID0gMCwgY3VydG9wID0gMDtcclxuXHRpZiAob2JqLm9mZnNldFBhcmVudCkge1xyXG5cdFx0ZG8ge1xyXG5cdFx0XHRjdXJsZWZ0ICs9IG9iai5vZmZzZXRMZWZ0O1xyXG5cdFx0XHRjdXJ0b3AgKz0gb2JqLm9mZnNldFRvcDtcclxuXHRcdH0gd2hpbGUgKG9iaiA9IG9iai5vZmZzZXRQYXJlbnQpO1xyXG5cdFx0cmV0dXJuIHsgeDogY3VybGVmdCwgeTogY3VydG9wIH07XHJcblx0fVxyXG5cdHJldHVybiB1bmRlZmluZWQ7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHBpY2tJdChldnQpIHtcclxuXHR2YXIgb2JqZWN0SUQsXHJcblx0XHRkb20sXHJcblx0XHRkZSxcclxuXHRcdGI7XHJcblx0Ly8gYWNjZXNzZXMgdGhlIGVsZW1lbnQgdGhhdCBnZW5lcmF0ZXMgdGhlIGV2ZW50IGFuZCByZXRyaWV2ZXMgaXRzIElEXHJcblx0aWYgKGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIpXHJcblx0eyAvLyB3M2NcclxuXHRcdG9iamVjdElEID0gZXZ0LnRhcmdldC5pZDtcclxuXHRcdC8qXHJcblx0XHQgaWYgKG9iamVjdElELmluZGV4T2YoY2FsU3BhbklEKSAhPT0gLTEpXHJcblx0XHQge1xyXG5cdFx0IGRvbSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKG9iamVjdElEKTtcclxuXHRcdCBjbkxlZnQgPSBldnQucGFnZVg7XHJcblx0XHQgY25Ub3AgPSBldnQucGFnZVk7XHJcblxyXG5cdFx0IGlmIChkb20ub2Zmc2V0TGVmdClcclxuXHRcdCB7XHJcblx0XHQgY25MZWZ0ID0gKGNuTGVmdCAtIGRvbS5vZmZzZXRMZWZ0KTtcclxuXHRcdCBjblRvcCA9IChjblRvcCAtIGRvbS5vZmZzZXRUb3ApO1xyXG5cdFx0IH1cclxuXHRcdCB9XHJcblx0XHQgKi9cclxuXHRcdC8vIGdldCBtb3VzZSBwb3NpdGlvbiBvbiBjbGlja1xyXG5cdFx0LypcclxuXHRcdCB4cG9zID0gKGV2dC5wYWdlWCk7XHJcblx0XHQgeXBvcyA9IChldnQucGFnZVkpO1xyXG5cdFx0ICovXHJcblx0XHRpZiAob2JqZWN0SUQgPT0gJycpIHtcclxuXHRcdFx0eHBvcyA9IGZpbmRQb3MoZXZ0LnRhcmdldCkueDtcclxuXHRcdFx0eXBvcyA9IGZpbmRQb3MoZXZ0LnRhcmdldCkueTtcclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxuXHRlbHNlXHJcblx0eyAvLyBJRVxyXG5cdFx0b2JqZWN0SUQgPSBldmVudC5zcmNFbGVtZW50LmlkO1xyXG5cdFx0Y25MZWZ0ID0gZXZlbnQub2Zmc2V0WDtcclxuXHRcdGNuVG9wID0gKGV2ZW50Lm9mZnNldFkpO1xyXG5cclxuXHRcdC8vIGdldCBtb3VzZSBwb3NpdGlvbiBvbiBjbGlja1xyXG5cdFx0ZGUgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XHJcblx0XHRiID0gZG9jdW1lbnQuYm9keTtcclxuXHJcblx0XHR4cG9zID0gZXZlbnQuY2xpZW50WCArIChkZS5zY3JvbGxMZWZ0IHx8IGIuc2Nyb2xsTGVmdCkgLSAoZGUuY2xpZW50TGVmdCB8fCAwKTtcclxuXHRcdHlwb3MgPSBldmVudC5jbGllbnRZICsgKGRlLnNjcm9sbFRvcCB8fCBiLnNjcm9sbFRvcCkgLSAoZGUuY2xpZW50VG9wIHx8IDApO1xyXG5cdH1cclxuXHJcblx0Ly8gdmVyaWZ5IGlmIHRoaXMgaXMgYSB2YWxpZCBlbGVtZW50IHRvIHBpY2tcclxuXHRpZiAob2JqZWN0SUQuaW5kZXhPZihjYWxTcGFuSUQpICE9PSAtMSlcclxuXHR7XHJcblx0XHRkb21TdHlsZSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKG9iamVjdElEKS5zdHlsZTtcclxuXHR9XHJcblxyXG5cdGlmIChkb21TdHlsZSlcclxuXHR7XHJcblx0XHRkb21TdHlsZS56SW5kZXggPSAxMDA7XHJcblx0XHRyZXR1cm4gZmFsc2U7XHJcblx0fVxyXG5cclxuXHRlbHNlXHJcblx0e1xyXG5cdFx0ZG9tU3R5bGUgPSBudWxsO1xyXG5cdFx0cmV0dXJuO1xyXG5cdH1cclxufVxyXG5cclxuZnVuY3Rpb24gZHJhZ0l0KGV2dCkge1xyXG5cdGlmIChkb21TdHlsZSlcclxuXHR7XHJcblx0XHRpZiAoZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcilcclxuXHRcdHsgLy9mb3IgSUVcclxuXHRcdFx0ZG9tU3R5bGUubGVmdCA9IChldmVudC5jbGllbnRYIC0gY25MZWZ0ICsgZG9jdW1lbnQuYm9keS5zY3JvbGxMZWZ0KSArICdweCc7XHJcblx0XHRcdGRvbVN0eWxlLnRvcCA9IChldmVudC5jbGllbnRZIC0gY25Ub3AgKyBkb2N1bWVudC5ib2R5LnNjcm9sbFRvcCkgKyAncHgnO1xyXG5cdFx0fVxyXG5cdFx0ZWxzZVxyXG5cdFx0eyAgLy9GaXJlZm94XHJcblx0XHRcdGRvbVN0eWxlLmxlZnQgPSAoZXZ0LmNsaWVudFggLSBjbkxlZnQgKyBkb2N1bWVudC5ib2R5LnNjcm9sbExlZnQpICsgJ3B4JztcclxuXHRcdFx0ZG9tU3R5bGUudG9wID0gKGV2dC5jbGllbnRZIC0gY25Ub3AgKyBkb2N1bWVudC5ib2R5LnNjcm9sbFRvcCkgKyAncHgnO1xyXG5cdFx0fVxyXG5cdH1cclxufVxyXG5cclxuLy8gcGVyZm9ybXMgYSBzaW5nbGUgaW5jcmVtZW50IG9yIGRlY3JlbWVudFxyXG5mdW5jdGlvbiBuZXh0U3RlcCh3aGF0U3Bpbm5lciwgZGlyZWN0aW9uKSB7XHJcblx0aWYgKHdoYXRTcGlubmVyID09PSBcIkhvdXJcIilcclxuXHR7XHJcblx0XHRpZiAoZGlyZWN0aW9uID09PSBcInBsdXNcIilcclxuXHRcdHtcclxuXHRcdFx0Q2FsLlNldEhvdXIoQ2FsLkhvdXJzICsgMSk7XHJcblx0XHRcdFJlbmRlckNzc0NhbCgpO1xyXG5cdFx0fVxyXG5cdFx0ZWxzZSBpZiAoZGlyZWN0aW9uID09PSBcIm1pbnVzXCIpXHJcblx0XHR7XHJcblx0XHRcdENhbC5TZXRIb3VyKENhbC5Ib3VycyAtIDEpO1xyXG5cdFx0XHRSZW5kZXJDc3NDYWwoKTtcclxuXHRcdH1cclxuXHR9XHJcblx0ZWxzZSBpZiAod2hhdFNwaW5uZXIgPT09IFwiTWludXRlXCIpXHJcblx0e1xyXG5cdFx0aWYgKGRpcmVjdGlvbiA9PT0gXCJwbHVzXCIpXHJcblx0XHR7XHJcblx0XHRcdENhbC5TZXRNaW51dGUocGFyc2VJbnQoQ2FsLk1pbnV0ZXMsIDEwKSArIDEpO1xyXG5cdFx0XHRSZW5kZXJDc3NDYWwoKTtcclxuXHRcdH1cclxuXHRcdGVsc2UgaWYgKGRpcmVjdGlvbiA9PT0gXCJtaW51c1wiKVxyXG5cdFx0e1xyXG5cdFx0XHRDYWwuU2V0TWludXRlKHBhcnNlSW50KENhbC5NaW51dGVzLCAxMCkgLSAxKTtcclxuXHRcdFx0UmVuZGVyQ3NzQ2FsKCk7XHJcblx0XHR9XHJcblx0fVxyXG5cclxufVxyXG5cclxuLy8gc3RhcnRzIHRoZSB0aW1lIHNwaW5uZXJcclxuZnVuY3Rpb24gc3RhcnRTcGluKHdoYXRTcGlubmVyLCBkaXJlY3Rpb24pIHtcclxuXHRkb2N1bWVudC50aGlzTG9vcCA9IHNldEludGVydmFsKGZ1bmN0aW9uICgpXHJcblx0e1xyXG5cdFx0bmV4dFN0ZXAod2hhdFNwaW5uZXIsIGRpcmVjdGlvbik7XHJcblx0fSwgMTI1KTsgLy8xMjUgbXNcclxufVxyXG5cclxuLy9zdG9wcyB0aGUgdGltZSBzcGlubmVyXHJcbmZ1bmN0aW9uIHN0b3BTcGluKCkge1xyXG5cdGNsZWFySW50ZXJ2YWwoZG9jdW1lbnQudGhpc0xvb3ApO1xyXG59XHJcblxyXG5mdW5jdGlvbiBkcm9wSXQoKSB7XHJcblx0c3RvcFNwaW4oKTtcclxuXHJcblx0aWYgKGRvbVN0eWxlKVxyXG5cdHtcclxuXHRcdGRvbVN0eWxlID0gbnVsbDtcclxuXHR9XHJcbn1cclxuXHJcbi8vIERlZmF1bHQgZXZlbnRzIGNvbmZpZ3VyYXRpb25cclxuXHJcbmRvY3VtZW50Lm9ubW91c2Vkb3duID0gcGlja0l0O1xyXG4vKlxyXG4gZG9jdW1lbnQub25tb3VzZW1vdmUgPSBkcmFnSXQ7XHJcbiBkb2N1bWVudC5vbm1vdXNldXAgPSBkcm9wSXQ7XHJcbiAqL1xyXG5cclxuZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBmdW5jdGlvbiAoZSkge1xyXG5cclxuXHRpZiAoZS50YXJnZXQuY2xhc3NMaXN0WzBdID09ICdkdC1pY28nKSB7XHJcblx0XHRpZiAoZS50YXJnZXQuY2xhc3NMaXN0WzFdICE9PSB1bmRlZmluZWQpIHtcclxuXHRcdFx0ZS50YXJnZXQuY2xhc3NMaXN0LnJlbW92ZSgnYWN0aXZlJyk7XHJcblx0XHRcdGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdjYWxCb3JkZXInKS5zdHlsZS52aXNpYmlsaXR5ID0gJ2hpZGRlbic7XHJcblx0XHRcdGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdjYWxPdmVybGF5JykuY2xhc3NMaXN0LnJlbW92ZSgnc2hvdycpO1xyXG5cdFx0fVxyXG5cdFx0ZWxzZSB7XHJcblx0XHRcdGUudGFyZ2V0LmNsYXNzTGlzdC5hZGQoJ2FjdGl2ZScpO1xyXG5cdFx0XHRkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnY2FsQm9yZGVyJykuc3R5bGUudmlzaWJpbGl0eSA9ICd2aXNpYmxlJztcclxuXHRcdFx0ZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2NhbE92ZXJsYXknKS5jbGFzc0xpc3QuYWRkKCdzaG93Jyk7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHRpZiAoZS50YXJnZXQuaWQgPT09ICdjYWxPdmVybGF5Jykge1xyXG5cdFx0ZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2NhbEJvcmRlcicpLnN0eWxlLnZpc2liaWxpdHkgPSAnaGlkZGVuJztcclxuXHRcdGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdjYWxPdmVybGF5JykuY2xhc3NMaXN0LnJlbW92ZSgnc2hvdycpO1xyXG5cdFx0dmFyIGFjdGl2ZUljb25zID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnLmR0LWljbycpO1xyXG5cdFx0dmFyIGFpQ291bnRMZW5naHQgPSBhY3RpdmVJY29ucy5sZW5ndGg7XHJcblx0XHRmb3IgKHZhciBhaUNvdW50ID0gMDsgYWlDb3VudCA8IGFpQ291bnRMZW5naHQ7ICsrYWlDb3VudCkge1xyXG5cdFx0XHRhY3RpdmVJY29uc1thaUNvdW50XS5jbGFzc0xpc3QucmVtb3ZlKCdhY3RpdmUnKTtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdGlmIChkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjY2FsQm9yZGVyIC5Nb250aFNlbGVjdG9yJykgIT09IG51bGwpIHtcclxuXHJcblx0XHR2YXIgdGFyZ2V0Q2xhc3MgPSBlLnRhcmdldC5jbGFzc0xpc3RbMF07XHJcblx0XHRpZiAoZS50YXJnZXQuY2xhc3NMaXN0WzFdICE9PSB1bmRlZmluZWQpIHRhcmdldENsYXNzID0gZS50YXJnZXQuY2xhc3NMaXN0WzFdO1xyXG5cdFx0aWYgKHRhcmdldENsYXNzID09PSB1bmRlZmluZWQpIHRhcmdldENsYXNzID0gZS50YXJnZXQucGFyZW50Tm9kZS5jbGFzc0xpc3RbMF07XHJcblxyXG5cdFx0aWYgKHRhcmdldENsYXNzID09ICdNb250aFNlbGVjdG9yVGl0bGUnKSB7XHJcblx0XHRcdGlmIChkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjY2FsQm9yZGVyIC5Nb250aFNlbGVjdG9yJykuY2xhc3NMaXN0LmNvbnRhaW5zKFwic2hvd1wiKSkge1xyXG5cdFx0XHRcdGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJyNjYWxCb3JkZXIgLk1vbnRoU2VsZWN0b3InKS5jbGFzc0xpc3QucmVtb3ZlKFwic2hvd1wiKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRlbHNlIHtcclxuXHRcdFx0XHRkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjY2FsQm9yZGVyIC5Nb250aFNlbGVjdG9yJykuY2xhc3NMaXN0LmFkZChcInNob3dcIik7XHJcblx0XHRcdFx0ZG9jdW1lbnQucXVlcnlTZWxlY3RvcignI2NhbEJvcmRlciAuTW9udGhTZWxlY3Rvci5ZZWFyJykuY2xhc3NMaXN0LnJlbW92ZShcInNob3dcIik7XHJcblx0XHRcdH1cclxuXHRcdH07XHJcblxyXG5cdFx0aWYgKHRhcmdldENsYXNzID09ICdNb250aFNlbGVjdG9yJykge1xyXG5cclxuXHRcdFx0dmFyIHNlbGVjdENsYXNzID0gZS50YXJnZXQucGFyZW50Tm9kZS5jbGFzc0xpc3RbMV07XHJcblxyXG5cdFx0XHRpZiAoZS50YXJnZXQudGFnTmFtZSA9PT0gJ0xJJyAmJiBzZWxlY3RDbGFzcyA9PT0gJ3Nob3cnKSB7XHJcblx0XHRcdFx0ZG9jdW1lbnQucXVlcnlTZWxlY3RvcignI2NhbEJvcmRlciAuTW9udGhTZWxlY3RvclRpdGxlJykuaW5uZXJIVE1MID0gZS50YXJnZXQuaW5uZXJIVE1MO1xyXG5cdFx0XHRcdENhbC5Td2l0Y2hNdGgoW10uaW5kZXhPZi5jYWxsKGUudGFyZ2V0LnBhcmVudE5vZGUuY2hpbGRyZW4sIChlID8gZS50YXJnZXQgOiBlLnNyY0VsZW1lbnQpKSk7XHJcblx0XHRcdFx0UmVuZGVyQ3NzQ2FsKCk7XHJcblx0XHRcdH1cclxuXHRcdFx0aWYgKGUudGFyZ2V0LnRhZ05hbWUgPT09ICdMSScgJiYgc2VsZWN0Q2xhc3MgPT09ICdZZWFyJykge1xyXG5cdFx0XHRcdGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJyNjYWxCb3JkZXIgLk1vbnRoU2VsZWN0b3JUaXRsZS5ZZWFyJykuaW5uZXJIVE1MID0gZS50YXJnZXQuaW5uZXJIVE1MO1xyXG5cdFx0XHRcdENhbC5Td2l0Y2hZZWFyKGUudGFyZ2V0LmlubmVySFRNTCk7XHJcblx0XHRcdFx0UmVuZGVyQ3NzQ2FsKCk7XHJcblx0XHRcdH1cclxuXHRcdH07XHJcblxyXG5cdFx0aWYgKHRhcmdldENsYXNzID09ICdZZWFyJykge1xyXG5cdFx0XHRpZiAoZG9jdW1lbnQucXVlcnlTZWxlY3RvcignI2NhbEJvcmRlciAuTW9udGhTZWxlY3Rvci5ZZWFyJykuY2xhc3NMaXN0LmNvbnRhaW5zKFwic2hvd1wiKSkge1xyXG5cdFx0XHRcdGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJyNjYWxCb3JkZXIgLk1vbnRoU2VsZWN0b3IuWWVhcicpLmNsYXNzTGlzdC5yZW1vdmUoXCJzaG93XCIpO1xyXG5cdFx0XHR9XHJcblx0XHRcdGVsc2Uge1xyXG5cdFx0XHRcdGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJyNjYWxCb3JkZXIgLk1vbnRoU2VsZWN0b3IuWWVhcicpLmNsYXNzTGlzdC5hZGQoXCJzaG93XCIpO1xyXG5cdFx0XHRcdGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJyNjYWxCb3JkZXIgLk1vbnRoU2VsZWN0b3InKS5jbGFzc0xpc3QucmVtb3ZlKFwic2hvd1wiKTtcclxuXHRcdFx0fVxyXG5cdFx0fTtcclxuXHJcblx0fVxyXG5cclxufSk7XHJcblxyXG50cnkge1xyXG5cdHdpbmRvdy5OZXdDc3NDYWwgPSBOZXdDc3NDYWw7XHJcblx0d2luZG93LkNhbGVuZGFyID0gQ2FsZW5kYXI7XHJcblx0d2luZG93LkdlbkNlbGwgPSBHZW5DZWxsO1xyXG5cdHdpbmRvdy5SZW5kZXJDc3NDYWwgPSBSZW5kZXJDc3NDYWw7XHJcblx0d2luZG93Lk5ld0Nzc0NhbCA9IE5ld0Nzc0NhbDtcclxuXHR3aW5kb3cuY2xvc2V3aW4gPSBjbG9zZXdpbjtcclxuXHR3aW5kb3cud2luY2xvc2UgPSB3aW5jbG9zZTtcclxuXHR3aW5kb3cuY2hhbmdlQm9yZGVyID0gY2hhbmdlQm9yZGVyO1xyXG5cdHdpbmRvdy5zZWxlY3REYXRlID0gc2VsZWN0RGF0ZTtcclxuXHR3aW5kb3cuZmluZFBvcyA9IGZpbmRQb3M7XHJcblx0d2luZG93LnBpY2tJdCA9IHBpY2tJdDtcclxuXHR3aW5kb3cuZHJhZ0l0ID0gZHJhZ0l0O1xyXG5cdHdpbmRvdy5uZXh0U3RlcCA9IG5leHRTdGVwO1xyXG5cdHdpbmRvdy5zdGFydFNwaW4gPSBzdGFydFNwaW47XHJcblx0d2luZG93LmRyb3BJdCA9IGRyb3BJdDtcclxufSBjYXRjaCAoZXJyKSB7XHJcblx0Y29uc29sZS5sb2coZXJyKTtcclxufVxyXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zY3JpcHRzL3ZlbmRvcnMvZGF0ZXRpbWVwaWNrZXIuanMiLCJyZXF1aXJlKCcuL2Jsb2NrRWxsaXBzaXMuYmluZGluZycpO1xyXG5yZXF1aXJlKCcuL2ZvcmVhY2hQcm9wLmJpbmRpbmcnKTtcclxucmVxdWlyZSgnLi9wb3BvdmVyLmJpbmRpbmcnKTtcclxucmVxdWlyZSgnLi9jb3B5Q2xpcGJvYXJkLmJpbmRpbmcnKTtcclxucmVxdWlyZSgnLi9sYXp5TG9hZGVyLmJpbmRpbmcnKTtcclxucmVxdWlyZSgnLi9jbGFzc2lmaWNhdGlvbnNNYXAuYmluZGluZycpO1xyXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zY3JpcHRzL2FwaS1leHBsb3Jlci92Mi9zcmMvY3VzdG9tQmluZGluZ3MvaW5kZXguanMiLCIvKipcclxuICogYmxvY2tFbGxpcHNpcyAtIENsYW1wcyAoaWUuIGN1dHMgb2ZmKSBhbiBIVE1MIGVsZW1lbnQncyBjb250ZW50IGJ5IGFkZGluZyBlbGxpcHNpcyB0byBpdCBpZiB0aGUgY29udGVudCBpbnNpZGUgaXMgdG9vIGxvbmcuXHJcbiAqXHJcbiAqIGV4YW1wbGU6IDx0YWcgZGF0YS1iaW5kPVwiYmxvY2tFbGxpcHNpczoge2NsYW1wOiAyfVwiPjwvdGFnPlxyXG4gKiBsaW5rIHRvIHNvdXJjZTogaHR0cHM6Ly9naXRodWIuY29tL2pvc2VwaHNjaG1pdHQvQ2xhbXAuanNcclxuICovXHJcbmtvLmJpbmRpbmdIYW5kbGVycy5ibG9ja0VsbGlwc2lzID0ge1xyXG5cdGluaXQ6IGZ1bmN0aW9uKGVsZW1lbnQsIHZhbHVlQWNjZXNzb3IsIGFsbEJpbmRpbmdzLCB2aWV3TW9kZWwsIGJpbmRpbmdDb250ZXh0KSB7XHJcblx0XHQkY2xhbXAoZWxlbWVudCwgdmFsdWVBY2Nlc3NvcigpKTtcclxuXHR9XHJcbn07XHJcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NjcmlwdHMvYXBpLWV4cGxvcmVyL3YyL3NyYy9jdXN0b21CaW5kaW5ncy9ibG9ja0VsbGlwc2lzLmJpbmRpbmcuanMiLCIgbW9kdWxlLmV4cG9ydHMgPSBrby5iaW5kaW5nSGFuZGxlcnMuZm9yZWFjaHByb3AgPSB7XHJcblxyXG5cdHRyYW5zZm9ybU9iamVjdDogZnVuY3Rpb24gKHBhcmFtcykge1xyXG5cdFx0dmFyIHByb3BlcnRpZXMgPSBbXTtcclxuXHRcdHZhciBvYmosIHNvcnRGbiA9IHBhcmFtcy5zb3J0Rm47XHJcblxyXG5cdFx0b2JqID0gc29ydEZuID8gcGFyYW1zLmRhdGE6IHBhcmFtcztcclxuXHRcdG9iaiA9IGtvLnV0aWxzLnVud3JhcE9ic2VydmFibGUob2JqKTtcclxuXHJcblx0XHRrby51dGlscy5vYmplY3RGb3JFYWNoKG9iaiwgZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcclxuXHRcdFx0cHJvcGVydGllcy5wdXNoKHtcclxuXHRcdFx0XHRrZXk6IGtleSxcclxuXHRcdFx0XHR2YWx1ZTogdmFsdWVcclxuXHRcdFx0fSk7XHJcblx0XHR9KTtcclxuXHJcblx0XHRpZiAoc29ydEZuKSB7XHJcblx0XHRcdHByb3BlcnRpZXMuc29ydChzb3J0Rm4pO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBwcm9wZXJ0aWVzO1xyXG5cdH0sXHJcblx0aW5pdDogZnVuY3Rpb24oZWxlbWVudCwgdmFsdWVBY2Nlc3NvciwgYWxsQmluZGluZ3NBY2Nlc3Nvciwgdmlld01vZGVsLCBiaW5kaW5nQ29udGV4dCkge1xyXG5cdFx0dmFyIHByb3BlcnRpZXMgPSBrby5wdXJlQ29tcHV0ZWQoZnVuY3Rpb24gKCkge1xyXG5cdFx0XHR2YXIgb2JqID0ga28udXRpbHMudW53cmFwT2JzZXJ2YWJsZSh2YWx1ZUFjY2Vzc29yKCkpO1xyXG5cdFx0XHRyZXR1cm4ga28uYmluZGluZ0hhbmRsZXJzLmZvcmVhY2hwcm9wLnRyYW5zZm9ybU9iamVjdChvYmopO1xyXG5cdFx0fSk7XHJcblx0XHRrby5hcHBseUJpbmRpbmdzVG9Ob2RlKGVsZW1lbnQsIHtcclxuXHRcdFx0Zm9yZWFjaDogcHJvcGVydGllc1xyXG5cdFx0fSwgYmluZGluZ0NvbnRleHQpO1xyXG5cdFx0cmV0dXJuIHtcclxuXHRcdFx0Y29udHJvbHNEZXNjZW5kYW50QmluZGluZ3M6IHRydWVcclxuXHRcdH07XHJcblx0fVxyXG59O1xyXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zY3JpcHRzL2FwaS1leHBsb3Jlci92Mi9zcmMvY3VzdG9tQmluZGluZ3MvZm9yZWFjaFByb3AuYmluZGluZy5qcyIsInZhciBjb21tb24gPSB7XHJcblx0Y29udGFpbmVyOiAnYm9keScsXHJcblx0dHJpZ2dlcjogJ2hvdmVyJyxcclxuXHRwbGFjZW1lbnQ6ICdib3R0b20nXHJcbn07XHJcblxyXG5rby5iaW5kaW5nSGFuZGxlcnMucG9wb3ZlciA9IHtcclxuXHR1cGRhdGU6IGZ1bmN0aW9uKGVsZW1lbnQsIHZhbHVlQWNjZXNzb3IpIHtcclxuXHRcdHZhciAkZWxlbWVudCA9ICQoZWxlbWVudCk7XHJcblx0XHR2YXIgcGFyYW1zID0gdmFsdWVBY2Nlc3NvcigpO1xyXG5cdFx0dmFyIGNvbmZpZyA9ICQuZXh0ZW5kKHt9LCBjb21tb24sIHBhcmFtcywge2RhdGE6IG51bGx9KTtcclxuXHJcblx0XHRpZiAocGFyYW1zLnR5cGUgPT09ICdwb3BvdmVyJyAmJiBwYXJhbXMuZGF0YSkge1xyXG5cdFx0XHR2YXIgZGF0YSA9IGtvLnVud3JhcChwYXJhbXMuZGF0YSk7XHJcblx0XHRcdGNvbmZpZy50aXRsZSA9IGBFcnJvciAke2RhdGFbMF19OiAke2RhdGFbMV19YDtcclxuXHRcdFx0Y29uZmlnLmNvbnRlbnQgPSBkYXRhWzJdO1xyXG5cdFx0XHQkZWxlbWVudC5wb3BvdmVyKGNvbmZpZyk7XHJcblx0XHRcdGlmIChjb25maWcudHJpZ2dlciA9PT0gJ2NsaWNrJykge1xyXG5cdFx0XHRcdHZhciB0aW1lcjtcclxuXHRcdFx0XHQkZWxlbWVudC5vbignc2hvd24uYnMucG9wb3ZlcicsIGZ1bmN0aW9uICgpIHtcclxuXHRcdFx0XHRcdHRpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XHJcblx0XHRcdFx0XHRcdCRlbGVtZW50LnRyaWdnZXIoJ2NsaWNrJyk7XHJcblx0XHRcdFx0XHR9LCAyMDAwKTtcclxuXHRcdFx0XHR9KTtcclxuXHRcdFx0XHQkZWxlbWVudC5vbignaGlkZS5icy5wb3BvdmVyJywgZnVuY3Rpb24gKCkge1xyXG5cdFx0XHRcdFx0Y2xlYXJJbnRlcnZhbCh0aW1lcik7XHJcblx0XHRcdFx0fSk7XHJcblx0XHRcdH1cclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdGNvbmZpZy5kZWxheSA9IHtcclxuXHRcdFx0XHRcInNob3dcIjogMTUwMCxcclxuXHRcdFx0XHRcImhpZGVcIjogMTAwXHJcblx0XHRcdH07XHJcblx0XHRcdGNvbmZpZy50aXRsZSA9IHBhcmFtcy50aXRsZSB8fCBjb25maWcudGl0bGU7XHJcblx0XHRcdCRlbGVtZW50LnRvb2x0aXAoY29uZmlnKTtcclxuXHRcdH1cclxuXHR9XHJcbn07XHJcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NjcmlwdHMvYXBpLWV4cGxvcmVyL3YyL3NyYy9jdXN0b21CaW5kaW5ncy9wb3BvdmVyLmJpbmRpbmcuanMiLCIvKipcclxuICogY29weVRvQ2xpcGJvYXJkIC0gQSBtb2Rlcm4gYXBwcm9hY2ggdG8gY29weSB0ZXh0IHRvIGNsaXBib2FyZFxyXG4gKlxyXG4gKiBleGFtcGxlOiA8dGFnIGRhdGEtYmluZD1cImNvcHlUb0NsaXBib2FyZDoge3RleHQ6ICdzb21lIHRleHQgdG8gY29weSd9XCI+PC90YWc+XHJcbiAqXHJcbiAqIG9wdGlvbnM6XHJcbiAqXHR0ZXh0OiAnc3RyaW5nJyAtIGNvcHl8Y3V0IHRleHRcclxuICpcdC0tIG9wdGlvbmFsIC0tXHJcbiAqIFx0dGFyZ2V0OiA8bm9kZXxlbGVtZW50PiAtIHRhcmdldCBlbGVtZW50XHJcbiAqIFx0YWN0aW9uOiA8c3RyaW5nPiAtIHR5cGUgb2YgYWN0aW9uICdjb3B5JyBvciAnY3V0JyhjdXQgb25seSBmb3IgdGV4dCBpbnB1dCBmaWVsZCBhbmQgdGV4dGFyZWEgZmllbGQpXHJcbiAqIFx0ZG9uZUNsYXNzOiA8c3RyaW5nPiAtIGNzcyBjbGFzcyBmb3Igc3VjY2Vzc2Z1bCBhY3Rpb24gKGRlZmF1bHQgaXMgZG9uZSlcclxuICogXHRlcnJvckNsYXNzOiA8c3RyaW5nPiAtIGNzcyBjbGFzcyBmb3IgZXJyb3IgYWN0aW9uIChkZWZhdWx0IGlzIGVycm9yKVxyXG4gKiBcdGFuaW1hdGlvblRpbWU6IDxudW1iZXI+IChkZWZhdWx0IGlzIDUwMClcclxuICpcclxuICogbGluayB0byBzb3VyY2U6IGh0dHBzOi8vY2xpcGJvYXJkanMuY29tXHJcbiAqL1xyXG5rby5iaW5kaW5nSGFuZGxlcnMuY29weVRvQ2xpcGJvYXJkID0ge1xyXG5cdGluaXQ6IGZ1bmN0aW9uKGVsZW1lbnQsIHZhbHVlQWNjZXNzb3IsIGFsbEJpbmRpbmdzLCB2aWV3TW9kZWwsIGJpbmRpbmdDb250ZXh0KSB7XHJcblx0XHRsZXQgJGVsZW1lbnQgPSAkKGVsZW1lbnQpO1xyXG5cdFx0bGV0IHBhcmFtcyA9IHZhbHVlQWNjZXNzb3IoKTtcclxuXHRcdGxldCBkb25lID0gcGFyYW1zLmRvbmVDbGFzcyB8fCAnZG9uZSc7XHJcblx0XHRsZXQgZXJyb3IgPSBwYXJhbXMuZXJyb3JDbGFzcyB8fCAnZXJyb3InO1xyXG5cdFx0bGV0IGFuaW1hdGlvblRpbWUgPSBwYXJhbXMuYW5pbWF0aW9uVGltZSB8fCA1MDA7XHJcblxyXG5cdFx0ZWxlbWVudC5jbGlwYm9hcmQgPSBuZXcgQ2xpcGJvYXJkKGVsZW1lbnQsIHtcclxuXHRcdFx0YWN0aW9uKHRyaWdnZXIpIHtcclxuXHRcdFx0XHRyZXR1cm4gIHBhcmFtcy5hY3Rpb24gfHwgJ2NvcHknO1xyXG5cdFx0XHR9LFxyXG5cdFx0XHR0YXJnZXQodHJpZ2dlcikge1xyXG5cdFx0XHRcdHJldHVybiBwYXJhbXMudGFyZ2V0O1xyXG5cdFx0XHR9LFxyXG5cdFx0XHR0ZXh0KHRyaWdnZXIpIHtcclxuXHRcdFx0XHRyZXR1cm4ga28udW53cmFwKHBhcmFtcy50ZXh0KTtcclxuXHRcdFx0fSxcclxuXHRcdH0pO1xyXG5cclxuXHRcdGVsZW1lbnQuY2xpcGJvYXJkXHJcblx0XHRcdC5vbignc3VjY2VzcycsIGUgPT4ge1xyXG5cdFx0XHRcdCRlbGVtZW50LmFkZENsYXNzKGRvbmUpO1xyXG5cdFx0XHRcdHNldFRpbWVvdXQoKCkgPT4gJGVsZW1lbnQucmVtb3ZlQ2xhc3MoZG9uZSksIGFuaW1hdGlvblRpbWUpO1xyXG5cdFx0XHRcdGUuY2xlYXJTZWxlY3Rpb24oKTtcclxuXHRcdFx0fSlcclxuXHRcdFx0Lm9uKCdlcnJvcicsIGUgPT4ge1xyXG5cdFx0XHRcdCRlbGVtZW50LmFkZENsYXNzKGVycm9yKTtcclxuXHRcdFx0XHRzZXRUaW1lb3V0KCgpID0+ICRlbGVtZW50LnJlbW92ZUNsYXNzKGVycm9yKSwgYW5pbWF0aW9uVGltZSk7XHJcblx0XHRcdFx0Y29uc29sZS5lcnJvcignY29weVRvQ2xpcGJvYXJkIGN1c3RvbSBiaW5kaW5nIC0gQWN0aW9uOicsIGUuYWN0aW9uKTtcclxuXHRcdFx0XHRjb25zb2xlLmVycm9yKCdjb3B5VG9DbGlwYm9hcmQgY3VzdG9tIGJpbmRpbmcgLSBUcmlnZ2VyOicsIGUudHJpZ2dlcik7XHJcblx0XHRcdH0pO1xyXG5cclxuXHRcdGtvLnV0aWxzLmRvbU5vZGVEaXNwb3NhbC5hZGREaXNwb3NlQ2FsbGJhY2soZWxlbWVudCwgKCkgPT4ge1xyXG5cdFx0XHRpZiAoJGVsZW1lbnQuY2xpcGJvYXJkICYmIHR5cGVvZiAkZWxlbWVudC5jbGlwYm9hcmQuZGVzdHJveSA9PT0gXCJmdW5jdGlvblwiKSB7XHJcblx0XHRcdFx0JGVsZW1lbnQuY2xpcGJvYXJkICYmICRlbGVtZW50LmNsaXBib2FyZC5kZXN0cm95KCk7XHJcblx0XHRcdFx0ZGVsZXRlICRlbGVtZW50LmNsaXBib2FyZDtcclxuXHRcdFx0fVxyXG5cdFx0fSk7XHJcblx0fVxyXG59O1xyXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zY3JpcHRzL2FwaS1leHBsb3Jlci92Mi9zcmMvY3VzdG9tQmluZGluZ3MvY29weUNsaXBib2FyZC5iaW5kaW5nLmpzIiwia28uYmluZGluZ0hhbmRsZXJzLmxhenlMb2FkZXIgPSB7XHJcblx0aW5pdDogZnVuY3Rpb24oZWxlbWVudCwgdmFsdWVBY2Nlc3Nvcikge1xyXG5cdFx0bGV0IHBhcmFtcyA9IHZhbHVlQWNjZXNzb3IoKTtcclxuXHRcdGxldCBuYW1lID0gcGFyYW1zLm5hbWUudG9Mb3dlckNhc2UoKTtcclxuXHRcdGxldCBkYXRlc0FyciA9IFtcclxuXHRcdFx0J3N0YXJ0RGF0ZVRpbWUnLFxyXG5cdFx0XHQnZW5kRGF0ZVRpbWUnLFxyXG5cdFx0XHQnb25zYWxlU3RhcnREYXRlVGltZScsXHJcblx0XHRcdCdvbnNhbGVFbmREYXRlVGltZSdcclxuXHRcdF07XHJcblx0XHRsZXQgZGF0ZUluZGV4ID0gZGF0ZXNBcnIuaW5kZXhPZihwYXJhbXMubmFtZSk7XHJcblxyXG5cdFx0bGV0IHNlbGVjdG9yID0gbmFtZSA9PT0gJ3ZlbnVlaWQnID8gJ3ZlbnVlcycgOiBuYW1lID09PSAnYXR0cmFjdGlvbmlkJyA/ICdhdHRyYWN0aW9ucyc6ICcnO1xyXG5cdFx0bGV0IHR5cGUgPSBuYW1lID09PSAnY2xhc3NpZmljYXRpb25pZCcgPyAnaWQnIDogbmFtZSA9PT0gJ2NsYXNzaWZpY2F0aW9ubmFtZScgPyAnbmFtZScgOiAnJztcclxuXHJcblx0XHRpZiAoZGF0ZUluZGV4ICE9PSAtMSkge1xyXG5cdFx0XHRsZXQgYnRuID0gJCgnPGJ1dHRvbiBjbGFzcz1cImN1c3RvbS1pbnB1dF9fYnV0dG9uXCI+Jm5ic3A7PC9idXR0b24+Jyk7XHJcblx0XHRcdGxldCBsYWJlbCA9IGRhdGVzQXJyW2RhdGVJbmRleF07XHJcblx0XHRcdGxldCBzZWxlY3RvciA9ICQoZWxlbWVudCk7XHJcblxyXG5cdFx0XHRzZWxlY3Rvci5hZnRlcihidG4pO1xyXG5cdFx0XHRidG4ub24oIFwiY2xpY2tcIiwgZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0TmV3Q3NzQ2FsKGxhYmVsLCAneXl5eU1NZGQnLCAnZHJvcGRvd24nLCB0cnVlLCAnMjQnKTtcclxuXHRcdFx0fSk7XHJcblxyXG5cdFx0XHRzZWxlY3Rvci5vbignb25jaGFuZ2UnLCBmdW5jdGlvbigpIHtcclxuXHRcdFx0XHRkZWJ1Z2dlcjtcclxuXHRcdFx0XHRwYXJhbXMudmFsKCQodGhpcykudmFsKCkpXHJcblx0XHRcdH0pXHJcblx0XHR9IGVsc2UgaWYgKHNlbGVjdG9yIHx8IHR5cGUpIHtcclxuXHRcdFx0c2VsZWN0b3IgPyAkKGVsZW1lbnQpLmxhenlTZWxlY3Rvcih7c2VsZWN0b3J9KSA6ICQoZWxlbWVudCkuY2xhc3NpZmljYXRpb25TZWxlY3Rvcih7c2VsZWN0b3I6J2NsYXNzaWZpY2F0aW9ucycsIHVzZTogdHlwZX0pO1xyXG5cclxuXHRcdFx0JChlbGVtZW50KS5vbignY2hhbmdlJywgZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0cGFyYW1zLnZhbCgkKHRoaXMpLnZhbCgpKVxyXG5cdFx0XHR9KVxyXG5cdFx0fVxyXG5cdH1cclxufTtcclxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc2NyaXB0cy9hcGktZXhwbG9yZXIvdjIvc3JjL2N1c3RvbUJpbmRpbmdzL2xhenlMb2FkZXIuYmluZGluZy5qcyIsImtvLmJpbmRpbmdIYW5kbGVycy5jbGFzc2lmaWNhdGlvbnNNYXAgPSB7XHJcblx0aW5pdDogZnVuY3Rpb24oZWxlbWVudCwgdmFsdWVBY2Nlc3NvciwgYWxsQmluZGluZ3MsIHZpZXdNb2RlbCwgYmluZGluZ0NvbnRleHQpIHtcclxuXHRcdGxldCBwYXJhbXMgPSB2YWx1ZUFjY2Vzc29yKCk7XHJcblx0XHRsZXQgX2FsbEJpbmRpbmdzID0gYWxsQmluZGluZ3MoKTtcclxuXHRcdGxldCBfYmluZGluZ0NvbnRleHQgPSBiaW5kaW5nQ29udGV4dDtcclxuXHJcblxyXG5cdH1cclxufTtcclxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc2NyaXB0cy9hcGktZXhwbG9yZXIvdjIvc3JjL2N1c3RvbUJpbmRpbmdzL2NsYXNzaWZpY2F0aW9uc01hcC5iaW5kaW5nLmpzIiwicmVxdWlyZSgnLi9jb21tb24nKTtcclxucmVxdWlyZSgnLi9maWx0ZXInKTtcclxucmVxdWlyZSgnLi9wb3B1cHMnKTtcclxucmVxdWlyZSgnLi9wYW5lbHMnKTtcclxucmVxdWlyZSgnLi9yZXF1ZXN0Jyk7XHJcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NjcmlwdHMvYXBpLWV4cGxvcmVyL3YyL3NyYy9jb21wb25lbnRzL2luZGV4LmpzIiwicmVxdWlyZSgnLi9jdXN0b21TZWxlY3QuY29tcG9uZW50Jyk7XHJcbnJlcXVpcmUoJy4vY3VzdG9tSW5wdXQuY29tcG9uZW50Jyk7XHJcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NjcmlwdHMvYXBpLWV4cGxvcmVyL3YyL3NyYy9jb21wb25lbnRzL2NvbW1vbi9pbmRleC5qcyIsIi8qKlxyXG4gKiBDdXN0b20gc2VsZWN0IGNvbXBvbmVudFxyXG4gKi9cclxuXHJcbmNsYXNzIEN1c3RvbVNlbGVjdCB7XHJcblx0Y29uc3RydWN0b3Ioe2RhdGEsIHNlbGVjdGVkLCBvcHRpb25zLCBmb2N1cywgb25zZWxlY3QsIGFuaW1hdGlvblNwZWVkID0gMjAwLCBpc1JlYWRPbmx5ID0gdHJ1ZX0pIHtcclxuXHRcdGNvbnN0IHJhd09wdGlvbnMgPSBrby51bndyYXAob3B0aW9ucyk7XHJcblx0XHRjb25zdCBERUZBVUxUX1NFTEVDVEVEID0gcmF3T3B0aW9uc1swXS5uYW1lO1xyXG5cdFx0dGhpcy5jdXJlbnRTZWxlY3REYXRhID0gZGF0YTtcclxuXHRcdHRoaXMub25Gb2N1cyA9IGZvY3VzO1xyXG5cdFx0dGhpcy5vbnNlbGVjdE1ldGhvZCA9IG9uc2VsZWN0O1xyXG5cdFx0dGhpcy5hbmltYXRpb25TcGVlZCA9IGFuaW1hdGlvblNwZWVkO1xyXG5cdFx0dGhpcy5vcHRpb25zID0gb3B0aW9ucztcclxuXHRcdHRoaXMudmFsdWUgPSBrby51bndyYXAoc2VsZWN0ZWQpIHx8IERFRkFVTFRfU0VMRUNURUQ7XHJcblx0XHR0aGlzLnNlbGVjdGVkT3B0aW9uID0ga28ub2JzZXJ2YWJsZSh0aGlzLm1hcEZvckNoZWNrZWQoe3Jhd09wdGlvbnMsIG5hbWU6IHRoaXMudmFsdWV9KSk7XHJcblx0XHR0aGlzLmlzRXhwYW5kZWRlZCA9IGtvLm9ic2VydmFibGUoZmFsc2UpO1xyXG5cdFx0dGhpcy5pc1JlYWRPbmx5ID0gaXNSZWFkT25seTtcclxuXHRcdHRoaXMuc2V0U3Vic2NyaWJ0aW9ucyh7c2VsZWN0ZWQsIERFRkFVTFRfU0VMRUNURUR9KTtcclxuXHJcblx0XHQvLyBEaXJ0eSB3YXRjaGVyXHJcblx0XHR0aGlzLmZpZWxkV2F0Y2hlcihkYXRhKTtcclxuXHR9XHJcblxyXG5cdGZpZWxkV2F0Y2hlcihkYXRhKSB7XHJcblx0XHRpZiAoZGF0YSkge1xyXG5cdFx0XHR0aGlzLmlzRGlydHkgPSBkYXRhLmlzRGlydHkgPSBrby5wdXJlQ29tcHV0ZWQoKCkgPT4ge1xyXG5cdFx0XHRcdHJldHVybiBkYXRhLnZhbHVlKCkgIT09IGRhdGEuZGVmYXVsdCAmJiBkYXRhLnZhbHVlKCkgIT09ICdub25lJztcclxuXHRcdFx0fSk7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHRzZXRTdWJzY3JpYnRpb25zKHtzZWxlY3RlZCwgREVGQVVMVF9TRUxFQ1RFRH0pIHtcclxuXHRcdC8vIGhhcyBwcmVzZWxlY3RlZCBvcHRpb25cclxuXHRcdGlmIChzZWxlY3RlZCkge1xyXG5cdFx0XHRzZWxlY3RlZC5zdWJzY3JpYmUodmFsdWUgPT4ge1xyXG5cdFx0XHRcdGxldCBzZWxlY3RlZE9wdGlvbiA9IHRoaXMubWFwRm9yQ2hlY2tlZCh7cmF3T3B0aW9uczoga28udW53cmFwKHRoaXMub3B0aW9ucyksIG5hbWU6IHZhbHVlIHx8IERFRkFVTFRfU0VMRUNURUR9KTtcclxuXHJcblx0XHRcdFx0cmV0dXJuIHRoaXMuc2VsZWN0ZWRPcHRpb24oc2VsZWN0ZWRPcHRpb24pO1xyXG5cdFx0XHR9KTtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBvbiBzZWxlY3QgbWFwIGZvciBjaGVja2VkXHJcblx0XHR0aGlzLnNlbGVjdGVkT3B0aW9uLnN1YnNjcmliZSh2YWx1ZSA9PiB7XHJcblx0XHRcdHRoaXMubWFwRm9yQ2hlY2tlZCh7cmF3T3B0aW9uczoga28udW53cmFwKHRoaXMub3B0aW9ucyksIG5hbWU6IHZhbHVlLm5hbWV9KTtcclxuXHRcdFx0dGhpcy5vbnNlbGVjdE1ldGhvZCh2YWx1ZSk7XHJcblx0XHR9KTtcclxuXHJcblx0XHQvLyBxdWFudGl0eSBvZiBvcHRpb25zIGNoZWNrXHJcblx0XHR0aGlzLmlzT25lT3B0aW9uID0ga28ucHVyZUNvbXB1dGVkKCgpID0+IGtvLnVud3JhcCh0aGlzLm9wdGlvbnMpLmxlbmd0aCA8IDIpO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogVXBkYXRlcyBjaGVja2VkIG9wdGlvblxyXG5cdCAqIEBwYXJhbSByYXdPcHRpb25zIHthcnJheX0gb3B0aW9uc1xyXG5cdCAqIEBwYXJhbSBuYW1lIHtzdHJpbmd9IG5hbWUgb2Ygc2VsZWN0ZWQgb3B0aW9uXHJcblx0ICogQHJldHVybnMge29iamVjdH0gc2VsZWN0ZWQgb3B0aW9uXHJcblx0ICovXHJcblx0bWFwRm9yQ2hlY2tlZCh7cmF3T3B0aW9ucywgbmFtZX0pIHtcclxuXHRcdGxldCBzZWxlY3RlZE9wdGlvbjtcclxuXHRcdGZvciAoY29uc3Qgb3B0aW9uIG9mIHJhd09wdGlvbnMpIHtcclxuXHRcdFx0b3B0aW9uLmNoZWNrZWQob3B0aW9uLm5hbWUgPT09IG5hbWUpO1xyXG5cdFx0XHRpZiAob3B0aW9uLm5hbWUgPT09IG5hbWUpIHtcclxuXHRcdFx0XHRzZWxlY3RlZE9wdGlvbiA9IG9wdGlvblxyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gc2VsZWN0ZWRPcHRpb247XHJcblx0fVxyXG5cclxuXHRzbGlkZVRvZ2dsZShpdGVtLCBldmVudCkge1xyXG5cdFx0dGhpcy5vbkZvY3VzICYmIHRoaXMub25Gb2N1cyh0aGlzLmN1cmVudFNlbGVjdERhdGEpO1xyXG5cdFx0dGhpcy5pc0V4cGFuZGVkZWQoIWtvLnVud3JhcCh0aGlzLmlzRXhwYW5kZWRlZCkpO1xyXG5cdFx0aWYgKGtvLnVud3JhcCh0aGlzLmlzT25lT3B0aW9uKSkge1xyXG5cdFx0XHRyZXR1cm4gZmFsc2VcclxuXHRcdH1cclxuXHRcdGxldCBlbCA9IHRoaXMuY29uc3RydWN0b3IuZmluZEVsZW1lbnQoZXZlbnQpO1xyXG5cdFx0ZWwud3JhcHBlci5zbGlkZVRvZ2dsZSh0aGlzLmFuaW1hdGlvblNwZWVkKTtcclxuXHRcdGVsLmxheWVyLnRvZ2dsZUNsYXNzKCdoaWRkZW4nKTtcclxuXHR9XHJcblxyXG5cdG9uU2VsZWN0KGl0ZW0sIGV2ZW50KSB7XHJcblx0XHRjb25zdCByYXdPcHRpb25zID0ga28udW53cmFwKHRoaXMub3B0aW9ucyk7XHJcblx0XHR0aGlzLm1hcEZvckNoZWNrZWQoe3Jhd09wdGlvbnMsIG5hbWU6IGl0ZW0ubmFtZX0pO1xyXG5cdFx0dGhpcy5zZWxlY3RlZE9wdGlvbihpdGVtKTtcclxuXHRcdHRoaXMuc2xpZGVUb2dnbGUoaXRlbSwgZXZlbnQpO1xyXG5cdH1cclxuXHJcblx0c3RhdGljIGZpbmRFbGVtZW50KGV2ZW50KSB7XHJcblx0XHRsZXQgcGFyZW50ID0gJChldmVudC5jdXJyZW50VGFyZ2V0KS5wYXJlbnRzKCcuanMtY3VzdG9tLXNlbGVjdCcpO1xyXG5cdFx0cmV0dXJuIHtcclxuXHRcdFx0d3JhcHBlcjogcGFyZW50LmZpbmQoJy5qcy1jdXN0b20tc2VsZWN0LXdyYXBwZXInKSxcclxuXHRcdFx0bGF5ZXI6IHBhcmVudC5maW5kKCcuanMtY3VzdG9tLXNlbGVjdC1sYXllcicpXHJcblx0XHR9XHJcblx0fVxyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGtvLmNvbXBvbmVudHMucmVnaXN0ZXIoJ2N1c3RvbS1zZWxlY3QnLCB7XHJcbiAgdmlld01vZGVsOiBDdXN0b21TZWxlY3QsXHJcbiAgdGVtcGxhdGU6IGBcclxuXHQ8ZGl2IGNsYXNzPVwiYXBpLWV4cC1jdXN0b20tc2VsZWN0IGpzLWN1c3RvbS1zZWxlY3RcIj5cclxuXHRcdDxkaXYgY2xhc3M9XCJhcGktZXhwLWN1c3RvbS1zZWxlY3Qtd3JhcHBlclwiPlxyXG5cdFx0XHQ8c2VsZWN0IGNsYXNzPVwiYXBpLWV4cC1jdXN0b20tc2VsZWN0X19maWVsZFwiIG5hbWU9XCJhcGktZXhwLW1ldGhvZFwiIGRhdGEtYmluZD1cIm9wdGlvbnM6IG9wdGlvbnMsIG9wdGlvbnNUZXh0OiAnbmFtZScsIHZhbHVlOiBzZWxlY3RlZE9wdGlvblwiPjwvc2VsZWN0PlxyXG5cdFx0XHRcdDxzcGFuIGNsYXNzPVwiYXBpLWV4cC1jdXN0b20tc2VsZWN0X19wbGFjZWhvbGRlclwiPlxyXG5cdFx0XHRcdDxpbnB1dCB0eXBlPVwidGV4dFwiIGRhdGEtYmluZD1cImNsaWNrOiBzbGlkZVRvZ2dsZSwgdmFsdWU6IHNlbGVjdGVkT3B0aW9uKCkubmFtZSwgYXR0cjoge2Rpc2FibGVkOiBpc09uZU9wdGlvbiwgcmVhZG9ubHk6IGlzUmVhZE9ubHl9XCI+XHJcblx0XHRcdFx0PGJ1dHRvbiBjbGFzcz1cImJ0biBidG4taWNvbiBzaGV2cm9uIHVwIGJsdWUgYXBpLWV4cC1jdXN0b20tc2VsZWN0X19jaGV2cm9uXCIgZGF0YS1iaW5kPVwiY3NzOiB7aGlkZGVuOiBpc09uZU9wdGlvbiwgZG93bjogaXNFeHBhbmRlZGVkfVwiIHR5cGU9XCJidXR0b25cIj48L2J1dHRvbj5cclxuXHRcdFx0PC9zcGFuPlxyXG5cdFx0XHQ8dWwgZGF0YS1iaW5kPVwiZm9yZWFjaDogb3B0aW9uc1wiIGNsYXNzPVwiYXBpLWV4cC1jdXN0b20tc2VsZWN0X19saXN0IGpzLWN1c3RvbS1zZWxlY3Qtd3JhcHBlclwiPlxyXG5cdFx0XHRcdDxsaSBkYXRhLWJpbmQ9XCJjc3M6IHsnYWN0aXZlJzogY2hlY2tlZH1cIiBjbGFzcz1cImFwaS1leHAtY3VzdG9tLXNlbGVjdF9faXRlbVwiPlxyXG5cdFx0XHRcdFx0PGJ1dHRvbiBjbGFzcz1cImFwaS1leHAtY3VzdG9tLXNlbGVjdF9faXRlbS1sYWJlbFwiXHJcblx0XHRcdFx0XHRcdFx0XHRcdGRhdGEtYmluZD1cImNsaWNrOiAkY29tcG9uZW50Lm9uU2VsZWN0LmJpbmQoJGNvbXBvbmVudCksXHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHRleHQ6IG5hbWUsXHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGNzczogeydhY3RpdmUnOiBjaGVja2VkfSxcclxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0YXR0cjogeydkYXRhLXZhbHVlJzogbmFtZX1cIj48L2J1dHRvbj5cclxuXHRcdFx0XHRcdDxhIGNsYXNzPVwiYXBpLWV4cC1jdXN0b20tc2VsZWN0X19pdGVtLWxpbmtcIiB0YXJnZXQ9XCJfYmxhbmtcIiBkYXRhLWJpbmQ9XCJhdHRyOiB7aHJlZjogbGlua30sIGNzczogeydoaWRkZW4nOiAhbGlua31cIj4mbmJzcDs8L2E+XHJcblx0XHRcdFx0PC9saT5cclxuXHRcdFx0PC91bD5cclxuXHRcdDwvZGl2PlxyXG5cdFx0PGRpdiBkYXRhLWJpbmQ9XCJjbGljazogc2xpZGVUb2dnbGVcIiBjbGFzcz1cImFwaS1leHAtY3VzdG9tLXNlbGVjdC1sYXllciBqcy1jdXN0b20tc2VsZWN0LWxheWVyIGhpZGRlblwiPjwvZGl2PlxyXG5cdDwvZGl2PlxyXG5gfSk7XHJcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NjcmlwdHMvYXBpLWV4cGxvcmVyL3YyL3NyYy9jb21wb25lbnRzL2NvbW1vbi9jdXN0b21TZWxlY3QuY29tcG9uZW50LmpzIiwiLyoqXHJcbiAqIEN1c3RvbSBzZWxlY3QgY29tcG9uZW50XHJcbiAqL1xyXG52YXIgc2VsZjtcclxuY2xhc3MgQ3VzdG9tSW5wdXQge1xyXG5cdGNvbnN0cnVjdG9yKHtvbkZvY3VzTWV0aG9kLCBkYXRhID0ge3ZhbHVlOiAnJywgaXNEaXJ0eTogZmFsc2UsIHJlcXVpcmVkOiBmYWxzZX0sICBjc3NDbGFzcyA9ICcnLCB2YWxpZGF0aW9uTW9kZWx9KSB7XHJcblx0XHRzZWxmID0gdGhpcztcclxuXHRcdHRoaXMuZGF0YSA9IGRhdGE7XHJcblx0XHR0aGlzLmZvY3VzTWV0aG9kID0gb25Gb2N1c01ldGhvZDtcclxuXHRcdHRoaXMucGxhY2Vob2xkZXIgPSBkYXRhLnBsYWNlaG9sZGVyIHx8IGRhdGEubmFtZTtcclxuXHRcdHRoaXMuaWQgPSBkYXRhLm5hbWU7XHJcblx0XHR0aGlzLmlzVmlyZ2luID0ga28ub2JzZXJ2YWJsZSh0cnVlKTtcclxuXHRcdC8vIGNzcyBjbGFzc2VzXHJcblx0XHR0aGlzLmNzc0NsYXNzID0gY3NzQ2xhc3M7XHJcblxyXG5cdFx0Ly8gRGlydHkgd2F0Y2hlclxyXG5cdFx0dGhpcy5maWVsZFdhdGNoZXIoZGF0YSk7XHJcblxyXG5cdFx0Ly8gVmFsaWRhdGlvblxyXG5cdFx0dGhpcy5pbml0VmFsaWRhdGlvbihkYXRhLCB2YWxpZGF0aW9uTW9kZWwpO1xyXG5cdH1cclxuXHJcblx0ZmllbGRXYXRjaGVyKGRhdGEpIHtcclxuXHRcdHRoaXMuaXNEaXJ0eSA9IGRhdGEuaXNEaXJ0eSA9IGtvLnB1cmVDb21wdXRlZCgoKSA9PiB7XHJcblx0XHRcdHJldHVybiAhIShkYXRhLnZhbHVlKCkudG9TdHJpbmcoKSkudHJpbSgpLmxlbmd0aDtcclxuXHRcdH0pO1xyXG5cdH1cclxuXHJcblx0aW5pdFZhbGlkYXRpb24oZGF0YSwgdmFsaWRhdGlvbk1vZGVsKSB7XHJcblx0XHRsZXQgb2JqID0ge3JlcXVpcmVkOiBkYXRhLnJlcXVpcmVkfTtcclxuXHJcblx0XHQvLyB2YWxpZGF0aW9uIGJ5IHR5cGVcclxuXHRcdHN3aXRjaCAoZGF0YS50eXBlKSB7XHJcblx0XHRcdGNhc2UgJ2ludGVnZXInOlxyXG5cdFx0XHRcdG9iai5udWxsYWJsZUludCA9IGRhdGEudmFsdWU7XHJcblx0XHRcdFx0YnJlYWs7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy52YWx1ZSA9IGRhdGEudmFsdWUuZXh0ZW5kKG9iaik7XHJcblx0XHRsZXQgbW9kZWwgPSBrby51bndyYXAodmFsaWRhdGlvbk1vZGVsKTtcclxuXHRcdG1vZGVsW2RhdGEubmFtZV0gPSB0aGlzLnZhbHVlO1xyXG5cdFx0dmFsaWRhdGlvbk1vZGVsKG1vZGVsKTtcclxuXHR9XHJcblxyXG5cdG9uRm9jdXNNZXRob2QoZGF0YSkge1xyXG5cdFx0dGhpcy5mb2N1c01ldGhvZCAmJiB0aGlzLmZvY3VzTWV0aG9kKGRhdGEpXHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBFbnRlciBrZXkgaGFuZGxlclxyXG5cdCAqIEBwYXJhbSBtb2RlbFxyXG5cdCAqIEBwYXJhbSBldmVudFxyXG5cdCAqL1xyXG5cdG9uS2V5RG93bihtb2RlbCwgZXZlbnQpIHtcclxuXHRcdHRoaXMuaXNWaXJnaW4oZmFsc2UpO1xyXG5cdFx0bGV0IGJ0biA9ICQoJyNhcGktZXhwLWdldC1idG4nKTtcclxuXHRcdGlmIChldmVudC5rZXlDb2RlID09PSAxMyAmJiBidG4uaXMoJzplbmFibGVkJykpIHtcclxuXHRcdFx0YnRuLnRyaWdnZXIoJ2NsaWNrJyk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRyZXR1cm4gdHJ1ZTtcclxuXHRcdH1cclxuXHR9XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0ga28uY29tcG9uZW50cy5yZWdpc3RlcignY3VzdG9tLWlucHV0Jywge1xyXG5cdHZpZXdNb2RlbDogQ3VzdG9tSW5wdXQsXHJcblx0dGVtcGxhdGU6IGBcclxuXHRcdDxkaXYgZGF0YS1iaW5kPVwiY3NzOiB7W2Nzc0NsYXNzXTogdHJ1ZSwgZGlydHk6IGlzRGlydHksIHZpcmdpbjogaXNWaXJnaW59XCIgY2xhc3M9XCJhcGktZXhwLWN1c3RvbS1pbnB1dFwiPlxyXG5cdFx0XHQ8ZGl2IGRhdGEtYmluZD1cInZhbGlkYXRpb25FbGVtZW50OiB2YWx1ZVwiPlxyXG5cdFx0XHRcdDxpbnB1dCBkYXRhLWJpbmQ9XCJ0ZXh0SW5wdXQ6IHZhbHVlLCBsYXp5TG9hZGVyOiB7bmFtZTogcGxhY2Vob2xkZXIsIHZhbDogdmFsdWV9LCBkYXRlVGltZVBpY2tlciwgZXZlbnQ6IHtmb2N1czogb25Gb2N1c01ldGhvZChkYXRhKSwga2V5ZG93bjogb25LZXlEb3duLmJpbmQoJGNvbXBvbmVudCl9LCBhdHRyOiB7aWQ6IGlkfVwiXHJcblx0XHRcdFx0XHRcdFx0XHR0eXBlPVwidGV4dFwiXHJcblx0XHRcdFx0XHRcdFx0XHRjbGFzcz1cImN1c3RvbS1pbnB1dF9fZmllbGQgZm9ybS1jb250cm9sXCI+XHJcblx0XHRcdFx0PHNwYW4gZGF0YS1iaW5kPVwidGV4dDogcGxhY2Vob2xkZXIsIGNzczoge3JlcXVpcmVkOiBkYXRhLnJlcXVpcmVkfVwiIGNsYXNzPVwiY3VzdG9tLWlucHV0X19wbGFjZWhvbGRlclwiPjwvc3Bhbj5cclxuXHRcdFx0PC9kaXY+XHJcblx0XHRcdDxwIGRhdGEtYmluZD1cInZhbGlkYXRpb25NZXNzYWdlOiB2YWx1ZVwiIGNsYXNzPVwiY3VzdG9tLWlucHV0X192YWxpZGF0aW9uLW1lc3NhZ2VcIj48L3A+XHJcblx0XHQ8L2Rpdj5cclxuYH0pO1xyXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zY3JpcHRzL2FwaS1leHBsb3Jlci92Mi9zcmMvY29tcG9uZW50cy9jb21tb24vY3VzdG9tSW5wdXQuY29tcG9uZW50LmpzIiwicmVxdWlyZSgnLi9hYm91dE1ldGhvZC5jb21wb25lbnQnKTtcclxucmVxdWlyZSgnLi9jYXRlZ29yeU1lbnUuY29tcG9uZW50Jyk7XHJcbnJlcXVpcmUoJy4vbWV0aG9kc0ZpbHRlci5jb21wb25lbnQnKTtcclxucmVxdWlyZSgnLi9yYWRpb0ZpbHRlci5jb21wb25lbnQnKTtcclxucmVxdWlyZSgnLi9wYXJhbXNGaWx0ZXIuY29tcG9uZW50Jyk7XHJcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NjcmlwdHMvYXBpLWV4cGxvcmVyL3YyL3NyYy9jb21wb25lbnRzL2ZpbHRlci9pbmRleC5qcyIsInZhciBzZWxmO1xyXG5cclxuZnVuY3Rpb24gQWJvdXRNZXRob2QocGFyYW1zKSB7XHJcblx0c2VsZiA9IHRoaXM7XHJcblx0dmFyIG1ldGhvZCA9IGtvLnVud3JhcChwYXJhbXMuc2VsZWN0ZWRNZXRob2REYXRhKTtcclxuXHR0aGlzLmRvY3VtZW50YXRpb25MaW5rID0ga28ub2JzZXJ2YWJsZShtZXRob2QubGluayk7XHJcblx0dGhpcy5uYW1lID0ga28ub2JzZXJ2YWJsZShtZXRob2QubmFtZSk7XHJcblx0dGhpcy5kZXNjcmlwdGlvbiA9IGtvLm9ic2VydmFibGUobWV0aG9kLmRlc2NyaXB0aW9uKTtcclxuXHJcblx0Ly8gb24gbW9kZWwgY2hhbmdlXHJcblx0cGFyYW1zLnNlbGVjdGVkTWV0aG9kRGF0YS5zdWJzY3JpYmUoZnVuY3Rpb24gKHZhbCkge1xyXG5cdFx0dGhpcy5kb2N1bWVudGF0aW9uTGluayh2YWwubGluayk7XHJcblx0XHR0aGlzLm5hbWUodmFsLm5hbWUpO1xyXG5cdFx0dGhpcy5kZXNjcmlwdGlvbih2YWwuZGVzY3JpcHRpb24pO1xyXG5cdH0sIHRoaXMpO1xyXG5cclxuXHQvLyBtZXRob2RzXHJcblx0dGhpcy50b2dnbGVQb3BVcCAgPSBrby5vYnNlcnZhYmxlKGZhbHNlKTtcclxufVxyXG5cclxuQWJvdXRNZXRob2QucHJvdG90eXBlLm9uQWJvdXRDbGljayA9IGZ1bmN0aW9uIChtb2RlbCkge1xyXG5cdHJldHVybiBtb2RlbC50b2dnbGVQb3BVcCghbW9kZWwudG9nZ2xlUG9wVXAoKSk7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGtvLmNvbXBvbmVudHMucmVnaXN0ZXIoJ2Fib3V0LW1ldGhvZCcsIHtcclxuXHR2aWV3TW9kZWw6IEFib3V0TWV0aG9kLFxyXG5cdHRlbXBsYXRlOmBcclxuXHRcdDxzZWN0aW9uIGRhdGEtYmluZD1cImNzczoge2FjdGl2ZTogdG9nZ2xlUG9wVXB9XCIgY2xhc3M9XCJhcGktZXhwLWFib3V0XCI+XHJcblx0XHRcdDxkaXYgY2xhc3M9XCJhcGktZXhwLWFib3V0LXdyYXBwZXJcIj5cclxuXHRcdFx0XHQ8YnV0dG9uIGRhdGEtYmluZD1cImNsaWNrOiBvbkFib3V0Q2xpY2tcIiBjbGFzcz1cImFwaS1leHAtYWJvdXRfX2J1dHRvbiBkZXZpY2VzLWJ1dHRvblwiPjwvYnV0dG9uPlxyXG5cdFx0XHRcdDxhIGRhdGEtYmluZD1cImF0dHI6IHtocmVmOiBkb2N1bWVudGF0aW9uTGlua31cIiBocmVmPVwiI1wiIGNsYXNzPVwiYXBpLWV4cC1hYm91dF9fYnV0dG9uXCIgdGFyZ2V0PVwiX2JsYW5rXCI+PC9hPlxyXG5cdFx0XHRcdDxhcnRpY2xlIGNsYXNzPVwiYXBpLWV4cC1hYm91dF9fY29udGVudFwiPlxyXG5cdFx0XHRcdFx0PGg1IGRhdGEtYmluZD1cInRleHQ6IG5hbWVcIiBjbGFzcz1cImFwaS1leHAtYWJvdXRfX3RpdGxlXCI+QWJvdXQgQVBJIGFuZCBNZXRob2Q6PC9oNT5cclxuXHRcdFx0XHRcdDxzZWN0aW9uIGNsYXNzPVwiYXBpLWV4cC1hYm91dF9fZGVzY3JpcHRpb25cIj5cclxuXHRcdFx0XHRcdFx0PHAgZGF0YS1iaW5kPVwidGV4dDogZGVzY3JpcHRpb25cIj48L3A+XHJcblx0XHRcdFx0XHRcdDxwPlxyXG5cdFx0XHRcdFx0XHRcdDxhIGRhdGEtYmluZD1cImF0dHI6IHtocmVmOiBkb2N1bWVudGF0aW9uTGlua31cIiB0YXJnZXQ9XCJfYmxhbmtcIiBocmVmPVwiI1wiIGNsYXNzPVwiYXBpLWV4cC1hYm91dF9fZGVzY3JpcHRpb24tbGlua1wiPlJlYWQgbW9kZTwvYT5cclxuXHRcdFx0XHRcdFx0PC9wPlxyXG5cdFx0XHRcdFx0PC9zZWN0aW9uPlxyXG5cdFx0XHRcdDwvYXJ0aWNsZT5cclxuXHRcdFx0XHQ8ZGl2IGRhdGEtYmluZD1cImNsaWNrOiBvbkFib3V0Q2xpY2tcIiBjbGFzcz1cImFwaS1leHAtYWJvdXQtbGF5ZXJcIj48L2Rpdj5cclxuXHRcdFx0PC9kaXY+XHJcblx0XHQ8L3NlY3Rpb24+XHJcbmB9KTtcclxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc2NyaXB0cy9hcGktZXhwbG9yZXIvdjIvc3JjL2NvbXBvbmVudHMvZmlsdGVyL2Fib3V0TWV0aG9kLmNvbXBvbmVudC5qcyIsInZhciBzZWxmO1xyXG5cclxuY2xhc3MgQ2F0ZWdvcnlNZW51IHtcclxuXHRjb25zdHJ1Y3Rvcih7ZGF0YSwgc2VsZWN0ZWRDYXRlZ29yeX0pIHtcclxuXHRcdHNlbGYgPSB0aGlzO1xyXG5cdFx0dGhpcy5zZWxlY3RlZENhdGVnb3J5ID0gc2VsZWN0ZWRDYXRlZ29yeTtcclxuXHRcdHZhciBpbml0Q2F0ZWdvcnkgPSBrby51bndyYXAodGhpcy5zZWxlY3RlZENhdGVnb3J5KTtcclxuXHRcdHRoaXMuY2F0ZWdvcmllcyA9IGtvLm9ic2VydmFibGVBcnJheShPYmplY3Qua2V5cyhkYXRhKS5tYXAoKGl0ZW0sIGluZGV4KSA9PiB7XHJcblx0XHRcdHZhciBjaGVja2VkID0gaW5pdENhdGVnb3J5ID8gaXRlbSA9PT0gaW5pdENhdGVnb3J5OiAhaW5kZXg7XHJcblx0XHRcdC8vIGluaXRpYWwgbG9hZFxyXG5cdFx0XHRjaGVja2VkICYmIHRoaXMuc2VsZWN0ZWRDYXRlZ29yeShpdGVtKTtcclxuXHRcdFx0cmV0dXJuIHtcclxuXHRcdFx0XHRjaGVja2VkOiBrby5vYnNlcnZhYmxlKGNoZWNrZWQpLFxyXG5cdFx0XHRcdG5hbWU6IGl0ZW0sXHJcblx0XHRcdFx0bGluazogZmFsc2VcclxuXHRcdFx0fVxyXG5cdFx0fSkpO1xyXG5cclxuXHRcdHRoaXMuc2VsZWN0ZWRDYXRlZ29yeS5zdWJzY3JpYmUoY2F0ZWdvcnlOYW1lID0+IHtcclxuXHRcdFx0Y2hlY2tBY3RpdmUodGhpcy5jYXRlZ29yaWVzLCBjYXRlZ29yeU5hbWUpO1xyXG5cdFx0fSlcclxuXHR9XHJcblxyXG5cdHNlbGVjdENhdGVnb3J5ID0gKGNhdGVnb3J5KSA9PiB7XHJcblx0XHR2YXIgY2F0ZWdvcnlOYW1lID0gY2F0ZWdvcnkubmFtZTtcclxuXHRcdHRoaXMuc2VsZWN0ZWRDYXRlZ29yeShjYXRlZ29yeU5hbWUpO1xyXG5cdFx0Y2hlY2tBY3RpdmUodGhpcy5jYXRlZ29yaWVzLCBjYXRlZ29yeU5hbWUpO1xyXG5cdH1cclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBrby5jb21wb25lbnRzLnJlZ2lzdGVyKCdjYXRlZ29yeS1tZW51Jywge1xyXG5cdHZpZXdNb2RlbDogQ2F0ZWdvcnlNZW51LFxyXG5cdHRlbXBsYXRlOmBcclxuXHRcdDxhc2lkZSBjbGFzcz1cImFwaS1leHAtc2lkZS1tZW51XCI+XHJcblx0XHRcdDx1bCBkYXRhLWJpbmQ9XCJmb3JlYWNoOiBjYXRlZ29yaWVzXCIgY2xhc3M9XCJhcGktZXhwLXNpZGUtbWVudV9fY29udGFpbmVyIG5hdiBuYXYtcGlsbHMgbmF2LXN0YWNrZWQgdmlzaWJsZS1sZy1ibG9ja1wiPlxyXG5cdFx0XHRcdDxsaSBkYXRhLWJpbmQ9XCJjc3M6IHthY3RpdmU6IGNoZWNrZWR9XCIgcm9sZT1cInByZXNlbnRhdGlvblwiIGNsYXNzPVwiYXBpLWV4cC1zaWRlLW1lbnVfX2l0ZW1cIj5cclxuXHRcdFx0XHRcdDxhIGRhdGEtYmluZD1cImNsaWNrOiAkcGFyZW50LnNlbGVjdENhdGVnb3J5LCB0ZXh0OiBuYW1lXCIgaHJlZj1cIiNcIiBjbGFzcz1cImFwaS1leHAtc2lkZS1tZW51X19saW5rXCI+PC9hPlxyXG5cdFx0XHRcdDwvbGk+XHJcblx0XHRcdDwvdWw+XHJcblx0XHRcdDwhLS1zZWxlY3QtLT5cclxuXHRcdFx0PGRpdiBjbGFzcz1cImFwaS1leHAtc2lkZS1tZW51X19zZWxlY3QgaGlkZGVuLWxnXCI+XHJcblx0XHRcdFx0PCEtLSBrbyB0ZW1wbGF0ZTogeyBub2RlczogJGNvbXBvbmVudFRlbXBsYXRlTm9kZXMsIGRhdGE6ICRjb21wb25lbnQgfSAtLT48IS0tIC9rbyAtLT5cclxuXHRcdFx0PC9kaXY+XHJcblx0XHQ8L2FzaWRlPlxyXG5gfSk7XHJcblxyXG5mdW5jdGlvbiBjaGVja0FjdGl2ZShrb0FyciwgYWN0aXZlRWxlbSkge1xyXG5cdGlmICgha29BcnIgJiYgIWFjdGl2ZUVsZW0pIHtyZXR1cm4gZmFsc2U7fVxyXG5cclxuXHRrb0Fycihrb0FycigpLm1hcChmdW5jdGlvbiAob2JqKSB7XHJcblx0XHRpZiAob2JqLm5hbWUgPT09IGFjdGl2ZUVsZW0pIHtcclxuXHRcdFx0b2JqLmNoZWNrZWQodHJ1ZSk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRvYmouY2hlY2tlZChmYWxzZSk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gb2JqO1xyXG5cdH0pKTtcclxufVxyXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zY3JpcHRzL2FwaS1leHBsb3Jlci92Mi9zcmMvY29tcG9uZW50cy9maWx0ZXIvY2F0ZWdvcnlNZW51LmNvbXBvbmVudC5qcyIsInZhciBzZWxmO1xyXG5cclxuY2xhc3MgTWV0aG9kc0ZpbHRlciB7XHJcblx0Y29uc3RydWN0b3Ioe3NlbGVjdGVkQ2F0ZWdvcnksIGRhdGEsIHNlbGVjdGVkTWV0aG9kVHlwZSwgc2VsZWN0ZWRNZXRob2R9KSB7XHJcblx0XHRzZWxmID0gdGhpcztcclxuXHRcdHRoaXMuc2VsZWN0ZWRDYXRlZ29yeSA9IHNlbGVjdGVkQ2F0ZWdvcnk7XHJcblx0XHR0aGlzLmRhdGEgPSBkYXRhO1xyXG5cdFx0dGhpcy5zZWxlY3RlZE1ldGhvZFR5cGUgPSBzZWxlY3RlZE1ldGhvZFR5cGU7XHJcblx0XHR0aGlzLnNlbGVjdGVkTWV0aG9kID0gc2VsZWN0ZWRNZXRob2Q7XHJcblx0XHR0aGlzLnNlbGVjdGVkTWV0aG9kTmFtZSA9IGtvLm9ic2VydmFibGUoJycpO1xyXG5cdFx0dGhpcy5tZXRob2RzVmlld01vZGVsID0ga28ub2JzZXJ2YWJsZUFycmF5KFtdKTtcclxuXHRcdHRoaXMuaW5pdCgpXHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBJbml0aWFsaXphdGlvbiBwaGFzZVxyXG5cdCAqL1xyXG5cdGluaXQgPSAoKSA9PiB7XHJcblx0XHR0aGlzLnVwZGF0ZU1ldGhvZHNNb2RlbChrby51bndyYXAodGhpcy5zZWxlY3RlZE1ldGhvZFR5cGUpKTtcclxuXHJcblx0XHQvL29uIGNoYW5nZVxyXG5cdFx0dGhpcy5zZWxlY3RlZE1ldGhvZFR5cGUuc3Vic2NyaWJlKHZhbCA9PiB0aGlzLnVwZGF0ZU1ldGhvZHNNb2RlbCh2YWwpKTtcclxuXHRcdHRoaXMuc2VsZWN0ZWRNZXRob2Quc3Vic2NyaWJlKHZhbCA9PiB7XHJcblx0XHRcdHRoaXMuc2VsZWN0ZWRNZXRob2ROYW1lKHRoaXMuZGF0YVtrby51bndyYXAodGhpcy5zZWxlY3RlZENhdGVnb3J5KV1bJ0FMTCddW3ZhbF0ubmFtZSlcclxuXHRcdH0pXHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBGaWx0ZXJzIHRyYW5zY2x1c2lvbiBkb20gbm9kZXNcclxuXHQgKiBAcGFyYW0gcGFyYW0ge2FycmF5fSAkY29tcG9uZW50VGVtcGxhdGVOb2Rlc1xyXG5cdCAqIEBwYXJhbSBpbmRleCB7bnVtYmVyfSBpbmRleCBvZiBlbGVtZW50XHJcblx0ICogQHJldHVybnMge2FycmF5fSBkb20gbm9kZXMgYXJyYXkgZm9yIGluc2VydGlvblxyXG5cdCAqL1xyXG5cdGZpbHRlclRyYW5zY2x1c2lvbihwYXJhbSwgaW5kZXgpIHtcclxuXHRcdHZhciB0ZXh0ID0gcGFyYW0uZmluZChmdW5jdGlvbiAoaXRlbSkge1xyXG5cdFx0XHRyZXR1cm4gaXRlbS5ub2RlTmFtZSA9PT0gJyN0ZXh0JztcclxuXHRcdH0pO1xyXG5cdFx0dmFyIGVsID0gcGFyYW0uZmlsdGVyKGZ1bmN0aW9uIChpdGVtKSB7XHJcblx0XHRcdHJldHVybiBpdGVtLm5vZGVOYW1lICE9PSAnI3RleHQnICYmIGl0ZW0ubm9kZU5hbWUgIT09ICcjY29tbWVudCc7XHJcblx0XHR9KVtpbmRleF07XHJcblx0XHRyZXR1cm4gW3RleHQsIGVsLCB0ZXh0XTtcclxuXHR9O1xyXG5cclxuXHQvKipcclxuXHQgKiBVcGRhdGVzIFZNIGZvciBtZXRob2RzIHNlbGVjdFxyXG5cdCAqIEBwYXJhbSBtZXRob2RUeXBlXHJcblx0ICovXHJcblx0dXBkYXRlTWV0aG9kc01vZGVsID0gKG1ldGhvZFR5cGUpID0+IHtcclxuXHRcdHZhciBvYmogPSB0aGlzLmRhdGFba28udW53cmFwKHRoaXMuc2VsZWN0ZWRDYXRlZ29yeSldW21ldGhvZFR5cGVdfHwge30sXHJcblx0XHRcdGFyciA9IFtdLFxyXG5cdFx0XHRzZWxlY3RlZE1ldGhvZCA9IGtvLnVud3JhcCh0aGlzLnNlbGVjdGVkTWV0aG9kKSxcclxuXHRcdFx0Y291bnQgPSAwO1xyXG5cclxuXHRcdGZvciAodmFyIGkgaW4gb2JqKSB7XHJcblx0XHRcdGlmICghb2JqLmhhc093blByb3BlcnR5KGkpKSB7IGNvbnRpbnVlOyB9XHJcblx0XHRcdHZhciBwcm9wZXJ0eSA9IG9ialtpXTtcclxuXHJcblx0XHRcdHZhciB2bU1ldGhvZCA9ICQuZXh0ZW5kKHt9LCB7XHJcblx0XHRcdFx0aWQ6IHByb3BlcnR5LmlkLFxyXG5cdFx0XHRcdG5hbWU6IHByb3BlcnR5Lm5hbWUsXHJcblx0XHRcdFx0bGluazogcHJvcGVydHkubGluayxcclxuXHRcdFx0XHRjaGVja2VkOiBrby5vYnNlcnZhYmxlKCBzZWxlY3RlZE1ldGhvZCA/IHNlbGVjdGVkTWV0aG9kID09PSBwcm9wZXJ0eS5pZCA6ICFjb3VudCApXHJcblx0XHRcdH0pO1xyXG5cclxuXHRcdFx0aWYgKHNlbGVjdGVkTWV0aG9kID09PSBwcm9wZXJ0eS5pZCkge1xyXG5cdFx0XHRcdHRoaXMuc2VsZWN0ZWRNZXRob2ROYW1lKHByb3BlcnR5Lm5hbWUpO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRhcnIucHVzaCh2bU1ldGhvZCk7XHJcblxyXG5cdFx0XHQvLyBzZXQgZ2xvYmFsIG9ic2VydmFibGVcclxuXHRcdFx0IXNlbGVjdGVkTWV0aG9kICYmICFjb3VudCAmJiB0aGlzLnNlbGVjdGVkTWV0aG9kKHByb3BlcnR5LmlkKTtcclxuXHJcblx0XHRcdGNvdW50Kys7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5tZXRob2RzVmlld01vZGVsKGFycik7XHJcblx0fTtcclxuXHJcblx0LyoqXHJcblx0ICogT24gc2VsZWN0IGhhbmRsZXIgZm9yIG1ldGhvZHMgc2VsZWN0XHJcblx0ICogQHBhcmFtIGl0ZW1cclxuXHQgKi9cclxuXHRvblNlbGVjdE1ldGhvZChpdGVtKSB7XHJcblx0XHRzZWxmLnNlbGVjdGVkTWV0aG9kKGl0ZW0uaWQpO1xyXG5cdH07XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0ga28uY29tcG9uZW50cy5yZWdpc3RlcignbWV0aG9kcy1maWx0ZXInLCB7XHJcblx0dmlld01vZGVsOiBNZXRob2RzRmlsdGVyLFxyXG5cdHRlbXBsYXRlOmBcclxuXHRcdDxzZWN0aW9uICBjbGFzcz1cImFwaS1leHAtbWFpbi1maWx0ZXJcIj5cclxuXHRcdFx0PHNlY3Rpb24gY2xhc3M9XCJhcGktZXhwLWZpbHRlclwiPlxyXG5cdFx0XHRcdDxzZWN0aW9uIGNsYXNzPVwiYXBpLWV4cC1tZXRob2RzIGNsZWFyZml4XCI+XHJcblx0XHRcdFx0XHQ8bGFiZWwgY2xhc3M9XCJhcGktZXhwLW1ldGhvZHNfX2xhYmVsXCI+TWV0aG9kczwvbGFiZWw+XHJcblx0XHJcblx0XHRcdFx0XHQ8IS0tcmFkaW9zLS0+XHJcblx0XHRcdFx0XHQ8IS0tIGtvIHRlbXBsYXRlOiB7IG5vZGVzOiBmaWx0ZXJUcmFuc2NsdXNpb24oJGNvbXBvbmVudFRlbXBsYXRlTm9kZXMsIDApLCBkYXRhOiAkY29tcG9uZW50IH0gLS0+PCEtLSAva28gLS0+XHJcblx0XHRcdFx0XHRcclxuXHRcdFx0XHRcdDwhLS1zZWxlY3QtLT5cclxuXHRcdFx0XHRcdDxkaXYgY2xhc3M9XCJhcGktZXhwLW1ldGhvZHNfX3NlbGVjdFwiPlxyXG5cdFx0XHRcdFx0XHQ8IS0tIGtvIHRlbXBsYXRlOiB7IG5vZGVzOiBmaWx0ZXJUcmFuc2NsdXNpb24oJGNvbXBvbmVudFRlbXBsYXRlTm9kZXMsIDEpLCBkYXRhOiAkY29tcG9uZW50IH0tLT48IS0tL2tvLS0+XHJcblx0XHRcdFx0XHQ8L2Rpdj5cclxuXHRcdFx0XHQ8L3NlY3Rpb24+XHJcblx0XHRcdDwvc2VjdGlvbj5cclxuXHRcdDwvc2VjdGlvbj5cclxuYH0pO1xyXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zY3JpcHRzL2FwaS1leHBsb3Jlci92Mi9zcmMvY29tcG9uZW50cy9maWx0ZXIvbWV0aG9kc0ZpbHRlci5jb21wb25lbnQuanMiLCJ2YXIgc2VsZjtcclxuXHJcbmZ1bmN0aW9uIFJhZGlvRmlsdGVyKHBhcmFtcykge1xyXG5cdHNlbGYgPSB0aGlzO1xyXG5cdHZhciBzZWxlY3RlZENhdGVnb3J5ID0ga28udW53cmFwKHBhcmFtcy5zZWxlY3RlZENhdGVnb3J5KTtcclxuXHR2YXIgZGF0YSA9IHBhcmFtcy5kYXRhO1xyXG5cdHRoaXMuc2VsZWN0ZWRNZXRob2RUeXBlID0gcGFyYW1zLnNlbGVjdGVkTWV0aG9kVHlwZTtcclxuXHR0aGlzLlJBRElPX0lEID0gJ2FwaS1leHAtJztcclxuXHJcblx0dGhpcy5yYWRpb3NNb2RlbCA9IGtvLm9ic2VydmFibGVBcnJheShbXSk7XHJcblx0dGhpcy51cGRhdGVSYWRpb3NNb2RlbChkYXRhW3NlbGVjdGVkQ2F0ZWdvcnldKTtcclxuXHJcblx0cGFyYW1zLnNlbGVjdGVkQ2F0ZWdvcnkuc3Vic2NyaWJlKGZ1bmN0aW9uICh2YWwpIHtcclxuXHRcdHRoaXMudXBkYXRlUmFkaW9zTW9kZWwoZGF0YVt2YWxdKTtcclxuXHR9LCB0aGlzKTtcclxufVxyXG5cclxuUmFkaW9GaWx0ZXIucHJvdG90eXBlLnVwZGF0ZVJhZGlvc01vZGVsID0gZnVuY3Rpb24gKHBhcmFtKSB7XHJcblx0dmFyIG9iaiA9IHBhcmFtIHx8IHt9LFxyXG5cdFx0YXJyID0gW107XHJcblxyXG5cdGZvciAodmFyIGkgaW4gb2JqKSB7XHJcblx0XHRpZiAoIW9iai5oYXNPd25Qcm9wZXJ0eShpKSkgeyBjb250aW51ZTsgfVxyXG5cdFx0dmFyIGl0ZW0gPSB7XHJcblx0XHRcdGNoZWNrZWQ6IGtvLm9ic2VydmFibGUoaSA9PT0gJ0FMTCcpLFxyXG5cdFx0XHRuYW1lOiBpXHJcblx0XHR9O1xyXG5cdFx0YXJyLnB1c2goaXRlbSk7XHJcblx0XHQvLyBpbml0aWFsIG5vdGlmeSBmb3IgYWxsIHN1YnNjcmliZXJzXHJcblx0XHRpID09PSAnQUxMJyAmJiB0aGlzLnNlbGVjdGVkTWV0aG9kVHlwZS5ub3RpZnlTdWJzY3JpYmVycyhpKTtcclxuXHR9XHJcblxyXG5cdGFyciA9IGFyci5zb3J0KGNvbXBhcmVNZXRob2RzKTtcclxuXHR0aGlzLnJhZGlvc01vZGVsKGFycik7XHJcblx0cmV0dXJuIGFycjtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBPbmNoYW5nZSBoYW5kbGVyIGZvciBSYWRpbyBidXR0b25zXHJcbiAqIEBwYXJhbSBpdGVtXHJcbiAqL1xyXG5SYWRpb0ZpbHRlci5wcm90b3R5cGUub25jaGFuZ2VSYWRpb3MgPSBmdW5jdGlvbiAoaXRlbSkge1xyXG5cdHZhciByYWRpb3NNb2RlbCA9IGtvLnVud3JhcChzZWxmLnJhZGlvc01vZGVsKS5tYXAoZnVuY3Rpb24gKG9iaikge1xyXG5cdFx0aWYgKG9iai5uYW1lID09PSBpdGVtLm5hbWUpIHtcclxuXHRcdFx0b2JqLmNoZWNrZWQodHJ1ZSk7XHJcblx0XHRcdHNlbGYuc2VsZWN0ZWRNZXRob2RUeXBlKG9iai5uYW1lKTtcclxuXHRcdFx0Y29uc29sZS5sb2coa28udW53cmFwKHNlbGYuc2VsZWN0ZWRNZXRob2RUeXBlKSk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRvYmouY2hlY2tlZChmYWxzZSk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gb2JqO1xyXG5cdH0pO1xyXG5cdHNlbGYucmFkaW9zTW9kZWwocmFkaW9zTW9kZWwpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFVuaXEgaWQgZm9yIHJhZGlvIGJ0blxyXG4gKiBAcGFyYW0gbmFtZVxyXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxyXG4gKi9cclxuUmFkaW9GaWx0ZXIucHJvdG90eXBlLmdldElucHV0SWQgPSBmdW5jdGlvbiAobmFtZSkge1xyXG5cdHJldHVybiBzZWxmLlJBRElPX0lEICsgbmFtZTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBTb3J0IGZ1bmN0aW9uIGZvciBtZXRob2RzIGFyYXlcclxuICogQHBhcmFtIGZcclxuICogQHBhcmFtIHNcclxuICogQHJldHVybnMge251bWJlcn1cclxuICovXHJcbmZ1bmN0aW9uIGNvbXBhcmVNZXRob2RzKGYscykge1xyXG5cdHZhciBhID0gZi5uYW1lLnRvVXBwZXJDYXNlKCk7XHJcblx0dmFyIGIgPSBzLm5hbWUudG9VcHBlckNhc2UoKTtcclxuXHJcblx0aWYgKGEgPT09IGIpIHtyZXR1cm4gMDt9XHJcblx0aWYgKGEgPT09ICdBTEwnIHx8XHJcblx0XHQoYSA9PT0gJ0dFVCcgJiYgKGIgPT09ICdQT1NUJyB8fCBiID09PSAnUFVUJyB8fCBiID09PSAnREVMRVRFJykpIHx8XHJcblx0XHQoYSA9PT0gJ1BPU1QnICYmIChiID09PSAnUFVUJyB8fCBiID09PSAnREVMRVRFJykpIHx8XHJcblx0XHQoYSA9PT0gJ1BVVCcgJiYgYiA9PT0gJ0RFTEVURScpKSB7XHJcblx0XHRyZXR1cm4gLTE7XHJcblx0fVxyXG5cdHJldHVybiAxO1xyXG59XHJcblxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBrby5jb21wb25lbnRzLnJlZ2lzdGVyKCdyYWRpby1maWx0ZXInLCB7XHJcblx0dmlld01vZGVsOiBSYWRpb0ZpbHRlcixcclxuXHR0ZW1wbGF0ZTpgXHJcblx0XHQ8IS0tcmFkaW9zLS0+XHJcblx0XHQ8c2VjdGlvbiBkYXRhLWJpbmQ9XCJmb3JlYWNoOiByYWRpb3NNb2RlbFwiIGNsYXNzPVwiYXBpLWV4cC1tZXRob2RzX19yYWRpby1idXR0b25zIHJhZGlvLWJ1dHRvbnMgY2xlYXJmaXhcIj5cclxuXHRcdFx0PGRpdiBkYXRhLWJpbmQ9XCJjc3M6IHthY3RpdmU6IGNoZWNrZWR9XCIgY2xhc3M9XCJhcGktZXhwLW1ldGhvZFwiPlxyXG5cdFx0XHRcdDxpbnB1dCBkYXRhLWJpbmQ9XCJhdHRyOiB7IGlkOiAkY29tcG9uZW50LmdldElucHV0SWQobmFtZSksIGNoZWNrZWQ6IGNoZWNrZWQgfSwgZXZlbnQ6IHtjaGFuZ2U6ICRjb21wb25lbnQub25jaGFuZ2VSYWRpb3N9XCJcclxuXHRcdFx0XHRcdFx0XHRcdGNsYXNzPVwiYXBpLWV4cC1jb250ZW50LW1ldGhvZF9fcmFkaW9cIlxyXG5cdFx0XHRcdFx0XHRcdFx0dHlwZT1cInJhZGlvXCJcclxuXHRcdFx0XHRcdFx0XHRcdG5hbWU9XCJhcGktZXhwLW1ldGhvZHNcIj5cclxuXHRcdFx0XHQ8bGFiZWwgZGF0YS1iaW5kPVwidGV4dDogbmFtZSwgYXR0cjoge2ZvcjogJGNvbXBvbmVudC5nZXRJbnB1dElkKG5hbWUpfVwiIGNsYXNzPVwicmFkaW8taW5saW5lIGFwaS1leHAtbWV0aG9kX19sYWJlbFwiPjwvbGFiZWw+XHJcblx0XHRcdDwvZGl2PlxyXG5cdFx0PC9zZWN0aW9uPlxyXG5gfSk7XHJcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NjcmlwdHMvYXBpLWV4cGxvcmVyL3YyL3NyYy9jb21wb25lbnRzL2ZpbHRlci9yYWRpb0ZpbHRlci5jb21wb25lbnQuanMiLCJjbGFzcyBQYXJhbXNGaWx0ZXIge1xuXHRjb25zdHJ1Y3Rvcih7c2VsZWN0ZWRNZXRob2QsIHNlbGVjdGVkUGFyYW1zLCBzZWxlY3RlZE1ldGhvZERhdGEsIGFuaW1hdGlvblNwZWVkID0gMjAwfSkge1xuXHRcdHRoaXMuYW5pbWF0aW9uU3BlZWQgPSBhbmltYXRpb25TcGVlZDtcblx0XHR0aGlzLnNlbGVjdGVkTWV0aG9kID0gc2VsZWN0ZWRNZXRob2Q7XG5cdFx0dGhpcy5zZWxlY3RlZFBhcmFtcyA9IHNlbGVjdGVkUGFyYW1zO1xuXHRcdHRoaXMuc2VsZWN0ZWRNZXRob2REYXRhID0gc2VsZWN0ZWRNZXRob2REYXRhO1xuXHRcdHRoaXMuaXNIaWRkZW4gPSBrby5vYnNlcnZhYmxlKHRydWUpO1xuXHRcdHRoaXMucGFyYW1JbkZvY3VzID0ga28ub2JzZXJ2YWJsZSh7fSk7XG5cdFx0dGhpcy5wYXJhbXNNb2RlbCA9IGtvLm9ic2VydmFibGVBcnJheShbXSk7XG5cdFx0dGhpcy5pc0RpcnR5ID0ga28uY29tcHV0ZWQodGhpcy5jaGVja0RpcnR5LCB0aGlzKTtcblx0XHR0aGlzLmluaXQoe3NlbGVjdGVkTWV0aG9kLCBzZWxlY3RlZFBhcmFtc30pO1xuXHR9XG5cblx0LyoqXG5cdCAqIEluaXRpYWxpemF0aW9uIHBoYXNlXG5cdCAqL1xuXHRpbml0KHtzZWxlY3RlZE1ldGhvZCwgc2VsZWN0ZWRQYXJhbXN9KSB7XG5cdFx0dGhpcy51cGRhdGVWaWV3TW9kZWwoKTtcblxuXHRcdHNlbGVjdGVkTWV0aG9kLnN1YnNjcmliZSh2YWwgPT4ge1xuXHRcdFx0dGhpcy51cGRhdGVWaWV3TW9kZWwodmFsKVxuXHRcdH0pO1xuXG5cdFx0c2VsZWN0ZWRQYXJhbXMuc3Vic2NyaWJlKHNlbGVjdGVkID0+IHtcblx0XHRcdGxldCBwYXJhbXNNb2RlbCA9IGtvLnVud3JhcCh0aGlzLnBhcmFtc01vZGVsKTtcblx0XHRcdHNlbGVjdGVkLm1hcChwYXJhbSA9PiB7XG5cdFx0XHRcdGxldCBtYXRjaGVkUGFyYW0gPSBwYXJhbXNNb2RlbC5maW5kKHZhbCA9PiBwYXJhbS5uYW1lID09PSB2YWwubmFtZSk7XG5cdFx0XHRcdG1hdGNoZWRQYXJhbS52YWx1ZShrby51bndyYXAocGFyYW0udmFsdWUpKTtcblx0XHRcdH0pO1xuXHRcdFx0dGhpcy5wYXJhbXNNb2RlbChwYXJhbXNNb2RlbCk7XG5cdFx0fSwgdGhpcywgJ3BhcmFtc1NldCcpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEluaXRpYWwgYnVpbGQgb2YgU2VsZWN0IE1vZGVsXG5cdCAqL1xuXHR1cGRhdGVWaWV3TW9kZWwgPSAoKSA9PiB7XG5cdFx0dmFyIG9iaiA9IGtvLnVud3JhcCh0aGlzLnNlbGVjdGVkTWV0aG9kRGF0YSkucGFyYW1ldGVycyB8fCB7fSxcblx0XHRcdGFyciA9IFtdO1xuXG5cdFx0Zm9yICh2YXIgaSBpbiBvYmopIHtcblx0XHRcdGlmICghb2JqLmhhc093blByb3BlcnR5KGkpKSB7Y29udGludWU7fVxuXHRcdFx0bGV0IHBhcmFtID0gb2JqW2ldO1xuXHRcdFx0dmFyIHNlbGVjdGVkUGFyYW07XG5cblx0XHRcdC8vIGNvcGllcyBhbGwgdmFsdWVzIGZyb20gbW9kZWwgdG8gdmlldy1tb2RlbFxuXHRcdFx0bGV0IHZtUGFyYW0gPSAkLmV4dGVuZCh0cnVlLCB7fSwgcGFyYW0pO1xuXG5cdFx0XHR2bVBhcmFtLnZhbHVlID0ga28ub2JzZXJ2YWJsZSh2bVBhcmFtLnZhbHVlIHx8IHZtUGFyYW0uc2VsZWN0ICYmIHBhcmFtLm9wdGlvbnNbMF0ubmFtZSB8fCAnJyk7XG5cblx0XHRcdC8vYWRkIG9ic2VydmFibGUgZm9yIHNlbGVjdGVkIG9wdGlvbnNcblx0XHRcdGlmICh2bVBhcmFtLnNlbGVjdCkge1xuXHRcdFx0XHR2bVBhcmFtLm9wdGlvbnMgPSBzZWxlY3RlZFBhcmFtID8gc2VsZWN0ZWRQYXJhbS5vcHRpb25zIDoga28ub2JzZXJ2YWJsZUFycmF5KFxuXHRcdFx0XHRcdHBhcmFtLm9wdGlvbnMubWFwKGl0ZW0gPT4gJC5leHRlbmQodHJ1ZSwge30sIGl0ZW0sIHtjaGVja2VkOiBrby5vYnNlcnZhYmxlKGl0ZW0uY2hlY2tlZCl9KSlcblx0XHRcdFx0KTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gYWRkIGNhbGVuZGFyIGJ0biBmb3IgY3VycmVudCBmaWVsZFxuXHRcdFx0dm1QYXJhbS5oYXNDYWxlbmRhciA9IGkuc2VhcmNoKC8oZGF0ZXx0aW1lKS9nbWkpICE9IC0xO1xuXG5cdFx0XHQvLyBhZGQgcG9wLXVwIGJ0biBmb3IgY3VycmVudCBmaWVsZFxuXHRcdFx0dm1QYXJhbS5oYXNQb3BVcCA9IGkuc2VhcmNoKC8oYXR0cmFjdGlvbklkfHZlbnVlSWQpL2dtaSkgIT0gLTE7XG5cblx0XHRcdGFyci5wdXNoKHZtUGFyYW0pO1xuXHRcdH1cblxuXHRcdC8vIHByZXBhcmUgb3V0cHV0IGZvciByZXF1ZXN0XG5cdFx0dGhpcy5wYXJhbXNNb2RlbChhcnIpO1xuXG5cdFx0Ly9zZXQgZm9jdXMgZm9yIGZpcnN0IGVsZW1cblx0XHR0aGlzLnBhcmFtSW5Gb2N1cyh0aGlzLnBhcmFtc01vZGVsKClbMF0pO1xuXHRcdHRoaXMucHJlcGFyZVVybFBhaXJzKGFyciwgdGhpcy5zZWxlY3RlZFBhcmFtcyk7XG5cdFx0cmV0dXJuIGFycjtcblx0fTtcblxuXHQvKipcblx0ICogRGlydHkgcGFyYW1zIGZvcm0gb2JzZXJ2YWJsZSBtZXRob2Rcblx0ICogQHJldHVybnMge2Jvb2xlYW59XG5cdCAqL1xuXHRjaGVja0RpcnR5KCkge1xuXHRcdHRoaXMucHJlcGFyZVVybFBhaXJzKGtvLnVud3JhcCh0aGlzLnBhcmFtc01vZGVsKSwgdGhpcy5zZWxlY3RlZFBhcmFtcyk7XG5cdFx0dmFyIGRpcnR5ID0ga28udW53cmFwKHRoaXMucGFyYW1zTW9kZWwpLmZpbHRlcihpdGVtID0+IHtcblx0XHRcdHJldHVybiBrby51bndyYXAoaXRlbS5pc0RpcnR5KSA9PT0gdHJ1ZTtcblx0XHR9KTtcblx0XHRyZXR1cm4gZGlydHkubGVuZ3RoID4gMDtcblx0fVxuXG5cdC8qKlxuXHQgKiBTbGlkZSB0b2dnbGUgZm9yIHBhcmFtcyBjb250YWluZXIgbWV0aG9kXG5cdCAqIEBwYXJhbSB2aWV3TW9kZWxcblx0ICogQHBhcmFtIGV2ZW50XG5cdCAqL1xuXHRzbGlkZVRvZ2dsZSh2aWV3TW9kZWwsIGV2ZW50KSB7XG5cdFx0JChldmVudC5jdXJyZW50VGFyZ2V0KVxuXHRcdFx0LnBhcmVudHMoJy5qcy1zbGlkZS1jb250cm9sJylcblx0XHRcdC5maW5kKCcuanMtc2xpZGUtd3JhcHBlcicpXG5cdFx0XHQuc2xpZGVUb2dnbGUodmlld01vZGVsLmFuaW1hdGlvblNwZWVkLCBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdHZpZXdNb2RlbC5pc0hpZGRlbighdmlld01vZGVsLmlzSGlkZGVuKCkpO1xuXHRcdFx0fSk7XG5cdH1cblxuXHQvKipcblx0ICogTWFjaGVzIGZvY3VzZWQgcGFyYW1cblx0ICogQHBhcmFtIGl0ZW1cblx0ICovXG5cdG9uRm9jdXMgPSAoaXRlbSkgPT4ge1xuXHRcdHRoaXMucGFyYW1JbkZvY3VzKGl0ZW0pO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBGaWx0ZXJzIHBhcmFtcyBieSBkZWZpbmVkIHZhbHVlXG5cdCAqIEBwYXJhbSBhcnJcblx0ICogQHBhcmFtIGtvT2JzXG5cdCAqIEByZXR1cm5zIHtib29sZWFufVxuXHQgKi9cblx0cHJlcGFyZVVybFBhaXJzKGFyciwga29PYnMpIHtcblx0XHRpZiAoIWFyciB8fCAha29PYnMpIHtyZXR1cm4gZmFsc2U7fVxuXG5cdFx0cmV0dXJuIGtvT2JzKGFyci5maWx0ZXIoZnVuY3Rpb24gKGl0ZW0pIHtcblx0XHRcdHJldHVybiAoaXRlbS52YWx1ZSgpICYmIGl0ZW0udmFsdWUoKSAhPT0gJ25vbmUnIHx8IGl0ZW0uZGVmYXVsdCk7XG5cdFx0fSkpO1xuXHR9XG5cblx0LyoqXG5cdCAqIE9uIHNlbGVjdCB2YWx1ZSBoYW5kbGVyIGZvciBwYXJhbXMgc2VsZWN0XG5cdCAqIEBwYXJhbSBwYXJhbSB7b2JqZWN0fSBwYXJhbWV0ZXIgdmlldy1tb2RlbFxuXHQgKiBAcGFyYW0gb3B0aW9uIHtvYmplY3R9IG9wdGlvbiB2aWV3LW1vZGVsXG5cdCAqL1xuXHRvblNlbGVjdFBhcmFtVmFsdWUocGFyYW0sIG9wdGlvbikge1xuXHRcdHBhcmFtLnZhbHVlKG9wdGlvbi5uYW1lKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBQYXJhbXMgY2xlYXIgYnV0dG9uIGhhbmRsZXJcblx0ICogQHBhcmFtIHZtIHtvYmplY3R9IHZpZXcgbW9kZWxcblx0ICogQHBhcmFtIGUge29iamVjdH0gZXZlbnRcblx0ICovXG5cdG9uUGFyYW1zQ2xlYXIgPSAodm0sIGUpID0+IHtcblx0XHR2YXIgYXJyID0ga28udW53cmFwKHRoaXMucGFyYW1zTW9kZWwpO1xuXG5cdFx0dGhpcy5wYXJhbXNNb2RlbChhcnIubWFwKHBhcmFtID0+IHtcblx0XHRcdHBhcmFtLnZhbHVlKHBhcmFtLnNlbGVjdCAmJiBwYXJhbS5kZWZhdWx0IHx8ICcnKTtcblxuXHRcdFx0aWYgKHBhcmFtLnNlbGVjdCkge1xuXHRcdFx0XHRwYXJhbS5vcHRpb25zKGtvLnVud3JhcChwYXJhbS5vcHRpb25zKS5tYXAoKG9wdGlvbiwgaW5kZXgpID0+IHtcblx0XHRcdFx0XHRvcHRpb24uY2hlY2tlZCghaW5kZXgpO1xuXHRcdFx0XHRcdHJldHVybiBvcHRpb247XG5cdFx0XHRcdH0pKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBwYXJhbTtcblx0XHR9KSk7XG5cblx0XHQvLyBwcmVwYXJlIG91dHB1dCBmb3IgcmVxdWVzdFxuXHRcdHRoaXMucGFyYW1JbkZvY3VzKHRoaXMucGFyYW1zTW9kZWwoKVswXSk7XG5cdFx0dGhpcy5wcmVwYXJlVXJsUGFpcnMoYXJyLCB0aGlzLnNlbGVjdGVkUGFyYW1zKTtcblx0fTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBrby5jb21wb25lbnRzLnJlZ2lzdGVyKCdwYXJhbXMtZmlsdGVyJywge1xuXHR2aWV3TW9kZWw6IFBhcmFtc0ZpbHRlcixcblx0dGVtcGxhdGU6YFxuXHRcdDxzZWN0aW9uIGRhdGEtYmluZD1cImNzczoge2Nsb3NlZDogaXNIaWRkZW4sIGRpcnR5OiBpc0RpcnR5fVwiIGNsYXNzPVwiYXBpLWV4cC1wYXJhbXMganMtc2xpZGUtY29udHJvbFwiPlxuXHRcdFxuXHRcdFx0PHNlY3Rpb24gY2xhc3M9XCJhcGktZXhwLXBhcmFtcy1oZWFkbGluZVwiPlxuXHRcdFx0XHQ8YnV0dG9uIGRhdGEtYmluZD1cImNsaWNrOiBzbGlkZVRvZ2dsZVwiIGNsYXNzPVwiYnRuIGJ0bi1pY29uIHRvZ2dsZS1idG5cIiB0eXBlPVwiYnV0dG9uXCI+UGFyYW1ldGVyczwvYnV0dG9uPlxuXHRcdFx0XHQ8c3BhbiBjbGFzcz1cImJ0biBidG4taWNvbiBzaGV2cm9uIHVwIGdyZXlcIiBkYXRhLWJpbmQ9XCJjc3M6IHtkb3duOiBpc0hpZGRlbn1cIj48L3NwYW4+XG5cdFx0XHRcdDxkaXYgY2xhc3M9XCJhcGktZXhwLXBhcmFtcy1oZWFkbGluZS1lZGl0XCI+XG5cdFx0XHRcdFx0PGJ1dHRvbiBjbGFzcz1cImJ0biBhcGktZXhwLXBhcmFtcy1oZWFkbGluZV9fYnRuIGFwaS1leHAtcGFyYW1zLWhlYWRsaW5lX19idG4tY29weVwiPiZuYnNwOzwvYnV0dG9uPlxuXHRcdFx0XHRcdDxidXR0b24gZGF0YS1iaW5kPVwiY2xpY2s6IG9uUGFyYW1zQ2xlYXJcIiBjbGFzcz1cImJ0biBhcGktZXhwLXBhcmFtcy1oZWFkbGluZV9fYnRuIGFwaS1leHAtcGFyYW1zLWhlYWRsaW5lX19idG4tY2xlYXJcIj4mbmJzcDs8L2J1dHRvbj5cblx0XHRcdFx0PC9kaXY+XG5cdFx0XHQ8L3NlY3Rpb24+XG5cdFx0XHRcblx0XHRcdDxkaXYgY2xhc3M9XCJhcGktZXhwLXBhcmFtcy13cmFwcGVyIGNsZWFyZml4IGpzLXNsaWRlLXdyYXBwZXJcIj5cblx0XHRcdFx0PCEtLWFib3V0LS0+XG5cdFx0XHRcdDxzZWN0aW9uIGNsYXNzPVwiYXBpLWV4cC1hYm91dCB2aXNpYmxlLWxnLWJsb2NrXCI+XG5cdFx0XHRcdFx0PGRpdiBjbGFzcz1cImFwaS1leHAtYWJvdXQtd3JhcHBlclwiPlxuXHRcdFx0XHRcdFx0PHNwYW4gY2xhc3M9XCJhcGktZXhwLWFib3V0X19idXR0b25cIj48L3NwYW4+XG5cdFx0XHRcdFx0XHQ8YXJ0aWNsZSBjbGFzcz1cImFwaS1leHAtYWJvdXRfX2NvbnRlbnRcIj5cblx0XHRcdFx0XHRcdFx0PGg1IGRhdGEtYmluZD1cInRleHQ6IHBhcmFtSW5Gb2N1cygpLm5hbWVcIiBjbGFzcz1cImFwaS1leHAtYWJvdXRfX3RpdGxlXCI+QWJvdXQgQVBJIGFuZCBNZXRob2Q6PC9oNT5cblx0XHRcdFx0XHRcdFx0PHNlY3Rpb24gY2xhc3M9XCJhcGktZXhwLWFib3V0X19kZXNjcmlwdGlvblwiPlxuXHRcdFx0XHRcdFx0XHRcdDxwIGRhdGEtYmluZD1cImh0bWw6IHBhcmFtSW5Gb2N1cygpLmRvY1wiPjwvcD5cblx0XHRcdFx0XHRcdFx0PC9zZWN0aW9uPlxuXHRcdFx0XHRcdFx0PC9hcnRpY2xlPlxuXHRcdFx0XHRcdDwvZGl2PlxuXHRcdFx0XHQ8L3NlY3Rpb24+XG5cdFx0XHRcdFxuXHRcdFx0XHQ8IS0tcGFyYW1zIGZpbHRlci0tPlxuXHRcdFx0XHQ8c2VjdGlvbiBjbGFzcz1cImFwaS1leHAtcGFyYW1zLWZpbHRlclwiPlxuXHRcdFx0XHRcdDxzZWN0aW9uIGRhdGEtYmluZD1cImZvcmVhY2g6IHBhcmFtc01vZGVsXCIgY2xhc3M9XCJhcGktZXhwLXBhcmFtcy1maWx0ZXItZmllbGRzXCI+XG5cdFx0XHRcdFx0XHQ8IS0tc2VsZWN0LS0+XG5cdFx0XHRcdFx0XHRcdDxkaXYgY2xhc3M9XCJhcGktZXhwLXBhcmFtcy1maWx0ZXJfX2ZpZWxkXCI+XG5cdFx0XHRcdFx0XHRcdFx0PCEtLSBrbyBpZjogc2VsZWN0IC0tPlxuXHRcdFx0XHRcdFx0XHRcdFx0PGN1c3RvbS1zZWxlY3QgcGFyYW1zPVwiXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGRhdGE6ICRkYXRhLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRvcHRpb25zOiBvcHRpb25zLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRvbnNlbGVjdDogJGNvbXBvbmVudC5vblNlbGVjdFBhcmFtVmFsdWUuYmluZCgkZGF0YSwgJGRhdGEpLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRmb2N1czogJGNvbXBvbmVudC5vbkZvY3VzLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRzZWxlY3RlZDogdmFsdWVcIj5cblx0XHRcdFx0XHRcdFx0XHRcdDwvY3VzdG9tLXNlbGVjdD5cblx0XHRcdFx0XHRcdFx0XHQ8IS0tIC9rbyAtLT5cblx0XHRcdFx0XHRcdFx0XHQ8IS0tIGtvIGlmbm90OiBzZWxlY3QgLS0+XG5cdFx0XHRcdFx0XHRcdFx0XHQ8Y3VzdG9tLWlucHV0IHBhcmFtcz1cIlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRvbkZvY3VzTWV0aG9kOiAkY29tcG9uZW50Lm9uRm9jdXMsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGRhdGE6ICRkYXRhLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRjc3NDbGFzczogaGFzQ2FsZW5kYXIgPyAnY2FsZW5kYXInOiBoYXNQb3BVcCA/ICdwb3B1cCc6ICcnLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHR2YWxpZGF0aW9uTW9kZWw6ICRyb290LnZhbGlkYXRpb25Nb2RlbFwiPlxuXHRcdFx0XHRcdFx0XHRcdFx0PC9jdXN0b20taW5wdXQ+XG5cdFx0XHRcdFx0XHRcdFx0PCEtLSAva28gLS0+XG5cdFx0XHRcdFx0XHRcdDwvZGl2PlxuXHRcdFx0XHRcdDwvc2VjdGlvbj5cblx0XHRcdFx0PC9zZWN0aW9uPjwhLS1wYXJhbXMgZmlsdGVyLS0+XG5cdFx0XHQ8L2Rpdj5cblx0XHQ8L3NlY3Rpb24+PCEtLXBhcmFtZXRlcnMtLT5cbmB9KTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NjcmlwdHMvYXBpLWV4cGxvcmVyL3YyL3NyYy9jb21wb25lbnRzL2ZpbHRlci9wYXJhbXNGaWx0ZXIuY29tcG9uZW50LmpzIiwicmVxdWlyZSgnLi9lcnJvci5jb21wb25lbnQnKTtcclxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc2NyaXB0cy9hcGktZXhwbG9yZXIvdjIvc3JjL2NvbXBvbmVudHMvcG9wdXBzL2luZGV4LmpzIiwiY2xhc3MgRXJyb3JQb3BVcCB7XHJcblx0Y29uc3RydWN0b3IoKSB7XHJcblx0XHR0aGlzLnN0YXR1cyA9IGtvLm9ic2VydmFibGUoJycpO1xyXG5cdFx0dGhpcy5zdGF0dXNUZXh0ID0ga28ub2JzZXJ2YWJsZSgnJyk7XHJcblx0XHR0aGlzLmRldGFpbHMgPSBrby5vYnNlcnZhYmxlKGBgKTtcclxuXHJcblx0XHRrby5wb3N0Ym94LnN1YnNjcmliZSgnUkVRVUVTVF9FUlJPUicsIGVycm9yT2JqID0+IHtcclxuXHRcdFx0dGhpcy5zdGF0dXMoT2JqZWN0LmdldFByb3AoZXJyb3JPYmosICcucmVzcG9uc2VKU09OLmVycm9yc1swXS5zdGF0dXMnKSB8fCBlcnJvck9iai5zdGF0dXMgfHwgJ3Vua25vd24nKTtcclxuXHRcdFx0dGhpcy5zdGF0dXNUZXh0KE9iamVjdC5nZXRQcm9wKGVycm9yT2JqLCAnLnJlc3BvbnNlSlNPTi5lcnJvcnNbMF0uc3RhdHVzVGV4dCcpIHx8IGVycm9yT2JqLnN0YXR1c1RleHQgfHwgJycpO1xyXG5cdFx0XHR0aGlzLmRldGFpbHMoT2JqZWN0LmdldFByb3AoZXJyb3JPYmosICcucmVzcG9uc2VKU09OLmVycm9yc1swXS5kZXRhaWwnKSB8fCAndW5rbm93bicpO1xyXG5cdFx0XHR0aGlzLnRvZ2dsZVBvcFVwKCk7XHJcblx0XHR9KVxyXG5cdH1cclxuXHR0b2dnbGVQb3BVcCgpIHtcclxuXHRcdCQoJyNlcnJvci1tb2RhbCcpLm1vZGFsKCdzaG93Jyk7XHJcblx0fVxyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGtvLmNvbXBvbmVudHMucmVnaXN0ZXIoJ2Vycm9yLXBvcC11cCcsIHtcclxuXHR2aWV3TW9kZWw6IEVycm9yUG9wVXAsXHJcblx0dGVtcGxhdGU6YFxyXG5cdFx0PHNlY3Rpb24gaWQ9XCJlcnJvci1tb2RhbFwiIGNsYXNzPVwibW9kYWwgZmFkZVwiIHRhYmluZGV4PVwiLTFcIiByb2xlPVwiZGlhbG9nXCI+XHJcblx0XHRcdDxkaXYgY2xhc3M9XCJtb2RhbC1kaWFsb2dcIiByb2xlPVwiZG9jdW1lbnRcIj5cclxuXHRcdFx0XHQ8ZGl2IGNsYXNzPVwibW9kYWwtY29udGVudCBlcnJvci1wb3AtdXBcIj5cclxuXHRcdFx0XHRcdDxkaXYgY2xhc3M9XCJtb2RhbC1oZWFkZXJcIj5cclxuXHRcdFx0XHRcdFx0PGgyIGNsYXNzPVwiZXJyb3ItdGl0bGVcIj5FcnJvciA8c3BhbiBkYXRhLWJpbmQ9XCJ0ZXh0OiBzdGF0dXNcIj48L3NwYW4+OiA8c3BhbiBkYXRhLWJpbmQ9XCJ0ZXh0OiBzdGF0dXNUZXh0XCI+PC9zcGFuPjwvaDI+XHJcblx0XHRcdFx0XHQ8L2Rpdj5cclxuXHRcdFx0XHRcdDxkaXYgY2xhc3M9XCJtb2RhbC1ib2R5XCI+XHJcblx0XHRcdFx0XHRcdDxwIGRhdGEtYmluZD1cInRleHQ6IGRldGFpbHNcIiBjbGFzcz1cImVycm9yLWRldGFpbHNcIj48L3A+XHJcblx0XHRcdFx0XHQ8L2Rpdj5cclxuXHRcdFx0XHRcdDxkaXYgY2xhc3M9XCJtb2RhbC1mb290ZXJcIj5cclxuXHRcdFx0XHRcdFx0PGJ1dHRvbiB0eXBlPVwiYnV0dG9uXCIgY2xhc3M9XCJidG4gYnRuLXByaW1hcnkgYnRuLWFjY2VwdFwiIGRhdGEtZGlzbWlzcz1cIm1vZGFsXCIgYXJpYS1sYWJlbD1cIkNsb3NlXCI+T2s8L2J1dHRvbj5cclxuXHRcdFx0XHRcdDwvZGl2PlxyXG5cdFx0XHRcdDwvZGl2PjwhLS0gLy5tb2RhbC1jb250ZW50IC0tPlxyXG5cdFx0XHQ8L2Rpdj48IS0tIC8ubW9kYWwtZGlhbG9nIC0tPlxyXG5cdFx0PC9zZWN0aW9uPjwhLS0gLy5tb2RhbCAtLT5cclxuYH0pO1xyXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zY3JpcHRzL2FwaS1leHBsb3Jlci92Mi9zcmMvY29tcG9uZW50cy9wb3B1cHMvZXJyb3IuY29tcG9uZW50LmpzIiwicmVxdWlyZSgnLi9wYW5lbEdyb3VwLmNvbXBvbmVudCcpO1xyXG5yZXF1aXJlKCcuL3BhbmVsLmNvbXBvbmVudCcpO1xyXG5yZXF1aXJlKCcuL3BhZ2luYXRpb24uY29tcG9uZW50Jyk7XHJcbnJlcXVpcmUoJy4vcGFuZWxIZWFkaW5nLmNvbXBvbmVudCcpO1xyXG5yZXF1aXJlKCcuL29iamVjdFBhbmVsQm9keS5jb21wb25lbnQnKTtcclxucmVxdWlyZSgnLi9hcnJheVBhbmVsQm9keS5jb21wb25lbnQnKTtcclxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc2NyaXB0cy9hcGktZXhwbG9yZXIvdjIvc3JjL2NvbXBvbmVudHMvcGFuZWxzL2luZGV4LmpzIiwidmFyIHNlbGY7XHJcblxyXG5jbGFzcyBDYXJkR3JvdXAge1xyXG5cdGNvbnN0cnVjdG9yKHBhcmFtcykge1xyXG5cdFx0c2VsZiA9IHRoaXM7XHJcblx0XHR0aGlzLmNvbmZpZyA9IHRoaXMuY29uc3RydWN0b3IuZ2V0Q29uZmlnKHBhcmFtcyk7XHJcblx0XHR0aGlzLmRhdGEgPSB0aGlzLnByZXBhcmVEYXRhKHtwYXJhbXMsIGNvbmZpZzogdGhpcy5jb25maWcuX0NPTkZJR30pO1xyXG5cdFx0dGhpcy5ncm91cEluZGV4ID0gcGFyYW1zLmdyb3VwSW5kZXggfHwgMDtcclxuXHRcdHRoaXMuc2VjdGlvbkluZGV4ID0ga28udW53cmFwKHBhcmFtcy5zZWN0aW9uSW5kZXgpO1xyXG5cdFx0dGhpcy5jb2xvckNsYXNzID0gcGFyYW1zLmNvbG9yQ2xhc3M7XHJcblx0XHR0aGlzLmdldE1vcmUgPSBwYXJhbXMuZ2V0TW9yZTtcclxuXHRcdHRoaXMucGFnZSA9IHRoaXMuY29uc3RydWN0b3IuZ2V0UGFnaW5nSW5mbyhwYXJhbXMsIHRoaXMuZGF0YS5wYWdlKTtcclxuXHRcdHRoaXMuY29sbGFwc2VJZCA9IHRoaXMuY29uc3RydWN0b3IuZ2V0Q29sbGFwc2VJZCgpO1xyXG5cdFx0dGhpcy5faGFzRXZlbnRzUGFuZWwgPSBmYWxzZTtcclxuXHR9XHJcblxyXG5cdHNvcnRCeUNvbmZpZyhhLCBiKSB7XHJcblx0XHRpZiAodGhpcy5jb25maWcgJiYgdGhpcy5jb25maWdbYS5rZXldICYmIHRoaXMuY29uZmlnW2Iua2V5XSAmJiB0aGlzLmNvbmZpZ1thLmtleV0uX0NPTkZJRyAmJiB0aGlzLmNvbmZpZ1tiLmtleV0uX0NPTkZJRykge1xyXG5cdFx0XHR2YXIgaTEgPSB0aGlzLmNvbmZpZ1thLmtleV0uX0NPTkZJRy5pbmRleDtcclxuXHRcdFx0dmFyIGkyID0gdGhpcy5jb25maWdbYi5rZXldLl9DT05GSUcuaW5kZXg7XHJcblx0XHRcdHJldHVybiBpMSAtIGkyO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIDA7XHJcblx0fVxyXG5cclxuXHRjaGVja0lmSGFzRXZlbnRzTGlzdChrZXkpIHtcclxuXHRcdHJldHVybiBzZWxmLl9oYXNFdmVudHNQYW5lbCA9IGtleSA9PT0gJ2V2ZW50cycgfHwgc2VsZi5faGFzRXZlbnRzUGFuZWw7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBDb25maWd1cmVzIGFuZCBwYXJhbXMgZm9yIGVhY2ggcGFuZWwgZ3JvdXBcclxuXHQgKi9cclxuXHRzdGF0aWMgZ2V0Q29uZmlnKHtkZWVwUHJvcCA9ICcnLCBjb25maWcsIGZpbHRlciwgbWV0aG9kSWR9KSB7XHJcblx0XHRzZWxmLmRlZXBQcm9wID0gZGVlcFByb3A7XHJcblx0XHQvLyBtYWluIGNvbmZpZ1xyXG5cdFx0aWYgKCFzZWxmLmRlZXBQcm9wICYmICFjb25maWcpIHtcclxuXHRcdFx0Ly8gcGFuZWxHcm91cCBpbmRleCAtIDBcclxuXHJcblx0XHRcdC8vIGdldCBmdWxsIGNvbmZpZztcclxuXHRcdFx0bGV0IHJhd0ZpbHRlciA9IGtvLnVud3JhcChmaWx0ZXIpO1xyXG5cclxuXHRcdFx0Ly8gZ2V0IGN1cnJlbnQgbWV0aG9kIGNvbmZpZ1xyXG5cdFx0XHRsZXQgbWV0aG9kQ29uZmlnID0gcmF3RmlsdGVyW21ldGhvZElkXSB8fCB7fTtcclxuXHJcblx0XHRcdC8vIG1ldGhvZCBjb25maWcgaW5oZXJpdHMgZ2xvYmFsIGNvbmZpZ1xyXG5cdFx0XHRtZXRob2RDb25maWcuX0NPTkZJRyAgPSAkLmV4dGVuZCh0cnVlLCB7fSwgcmF3RmlsdGVyLl9HTE9CQUxfQ09ORklHLCBtZXRob2RDb25maWcuX0NPTkZJRyk7XHJcblxyXG5cdFx0XHRyZXR1cm4gbWV0aG9kQ29uZmlnO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0Ly8gcGFuZWxHcm91cCBpbmRleCA+IDBcclxuXHRcdFx0cmV0dXJuIGNvbmZpZyB8fCB7fVxyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogRGF0YSBtYW5pcHVsYXRpb25zXHJcblx0ICovXHJcblx0cHJlcGFyZURhdGEoe3BhcmFtcyA9IHt9LCBjb25maWcgPSB0aGlzLmNvbmZpZy5fQ09ORklHfSkge1xyXG5cdFx0bGV0IGRhdGEgPSAkLmV4dGVuZCh0cnVlLCB7fSwgcGFyYW1zLmRhdGEpIHx8IHt9O1xyXG5cdFx0dGhpcy51bndyYXBwT2JqZWN0cyhkYXRhLCBjb25maWcpO1xyXG5cdFx0dGhpcy5yZW1vdmVEZXByZWNhdGVkKGRhdGEsIGNvbmZpZyk7XHJcblx0XHRyZXR1cm4gdGhpcy53cmFwcFByaW1pdGl2ZXMoe2RhdGEsIF9wcm9wVGl0bGU6IHBhcmFtcy5fcHJvcFRpdGxlfSk7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBHYXRoZXJzIGFsbCBzdGFuZCBhbG9uZSBwcm9wcyBpbiB0byBvbmUgb2JqZWN0XHJcblx0ICogQHBhcmFtIGRhdGEge29iamVjdH1cclxuXHQgKiBAcGFyYW0gX3Byb3BUaXRsZSB7c3RyaW5nfVxyXG5cdCAqIEByZXR1cm5zIHtvYmplY3R9IHJldmlzZWQgZGF0YVxyXG5cdCAqL1xyXG5cdHdyYXBwUHJpbWl0aXZlcyh7ZGF0YSwgX3Byb3BUaXRsZSA9ICdvYmplY3QnfSkge1xyXG5cdFx0bGV0IG5ld0RhdGEgPSB7fSwgdmFsO1xyXG5cclxuXHRcdC8vIGdhdGhlcmluZyBhbGwgcHJpbWl0aXZlIHByb3BzIGluIGFkZGl0aW9uYWwgcGFuZWxcclxuXHRcdGZvciAobGV0IGtleSBpbiBkYXRhKSB7XHJcblx0XHRcdGlmICghZGF0YS5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7Y29udGludWU7fVxyXG5cdFx0XHR2YWwgPSBkYXRhW2tleV07XHJcblxyXG5cdFx0XHRpZiAodHlwZW9mIHZhbCAhPT0gJ29iamVjdCcpIHtcclxuXHRcdFx0XHRuZXdEYXRhW19wcm9wVGl0bGVdID0gbmV3RGF0YVtfcHJvcFRpdGxlXSB8fCB7fTtcclxuXHRcdFx0XHRuZXdEYXRhW19wcm9wVGl0bGVdW2tleV0gPSB2YWw7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0bmV3RGF0YVtrZXldID0gdmFsO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gbmV3RGF0YVxyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogVW53cmFwcyBvYmplY3RzXHJcblx0ICovXHJcblx0cmVtb3ZlRGVwcmVjYXRlZChvYmosIGNvbmZpZyA9IHt9KSB7XHJcblx0XHR2YXIgZGVwcmVjYXRlZCA9IGNvbmZpZy5kZXByZWNhdGVkIHx8IFtdO1xyXG5cclxuXHRcdGRlcHJlY2F0ZWQubWFwKGl0ZW0gPT4ge1xyXG5cdFx0XHRpZiAob2JqW2l0ZW1dKSB7XHJcblx0XHRcdFx0ZGVsZXRlIG9ialtpdGVtXVxyXG5cdFx0XHR9XHJcblx0XHRcdHJldHVybiBpdGVtO1xyXG5cdFx0fSk7XHJcblxyXG5cdFx0cmV0dXJuIG9iajtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFJlbW92ZXMgZGVwcmVjYXRlZCBvYmplY3RzXHJcblx0ICovXHJcblx0dW53cmFwcE9iamVjdHMob2JqLCBjb25maWcgPSB7fSkge1xyXG5cdFx0dmFyIHVud3JhcHAgPSBjb25maWcudW53cmFwcCB8fCBbXTtcclxuXHJcblx0XHR1bndyYXBwLm1hcChpdGVtID0+IHtcclxuXHRcdFx0dmFyIHZhbCA9IG9ialtpdGVtXTtcclxuXHRcdFx0aWYgKHZhbCkge1xyXG5cdFx0XHRcdHZhciBhcnIgPSBPYmplY3Qua2V5cyh2YWwpO1xyXG5cdFx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdFx0XHR2YXIgcHJvcCA9IGFycltpXTtcclxuXHRcdFx0XHRcdG9ialtwcm9wXSA9IHZhbFtwcm9wXTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0ZGVsZXRlIG9ialtpdGVtXTtcclxuXHRcdFx0fVxyXG5cdFx0XHRyZXR1cm4gaXRlbTtcclxuXHRcdH0pO1xyXG5cclxuXHRcdHJldHVybiBvYmo7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBQcmVwYXJlcyBkYXRhIGZvciBwYWdpbmdcclxuXHQgKi9cclxuXHRzdGF0aWMgZ2V0UGFnaW5nSW5mbyhwYXJhbXMsIHBhZ2VPYmopIHtcclxuXHRcdGxldCBwYWdlUGFyYW0sIHNpemU7XHJcblxyXG5cdFx0aWYgKHBhZ2VPYmogJiYgKHBhcmFtcy5wYWdlUGFyYW0gfHwgcGFyYW1zLnBhcmFtcykpIHsgLy90ZW1wb3Jhcnkgc29sdXRpb24gdG9kbzogbmVlZCB0byBiZSByZXZpc2VkIGFuZCByZWZhY3RvcmVkXHJcblx0XHRcdHNpemUgPSBwYXJhbXMuY2FyZFNpemUgfHwgcGFnZU9iai5zaXplO1xyXG5cdFx0XHRwYWdlUGFyYW0gPSBwYXJhbXMucGFnZVBhcmFtIHx8IHBhcmFtcy5wYXJhbXMuZmluZChpdGVtID0+IGl0ZW0ubmFtZSA9PT0gJ3BhZ2UnKTtcclxuXHJcblx0XHRcdHJldHVybiB7XHJcblx0XHRcdFx0Y2F0ZWdvcnk6IHBhcmFtcy5jYXRlZ29yeSxcclxuXHRcdFx0XHRtZXRob2Q6IHBhcmFtcy5tZXRob2QsXHJcblx0XHRcdFx0bWV0aG9kSWQ6IHBhcmFtcy5tZXRob2RJZCxcclxuXHRcdFx0XHRwYXJhbXM6IHBhcmFtcy5wYXJhbXMsXHJcblx0XHRcdFx0cGFnZVBhcmFtOiBwYWdlUGFyYW0gJiYgcGFnZVBhcmFtLnZhbHVlLFxyXG5cdFx0XHRcdHNldFBhcmFtczogcGFyYW1zLnNldFBhcmFtcyxcclxuXHRcdFx0XHRzaXplOiBzaXplXHJcblx0XHRcdH07XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gbnVsbDtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFByb3ZpZGVzIGlkIHN0ciBmb3IgcGFuZWwgJ2NvbGxhcHNlIHRvZ2dsZScgbG9naWNcclxuXHQgKiBAcGFyYW0gc3RyXHJcblx0ICogQHJldHVybnMge3N0cmluZ31cclxuXHQgKi9cclxuXHRzdGF0aWMgZ2V0Q29sbGFwc2VJZCgpIHtcclxuXHRcdHJldHVybiBgY2FyZC1wYW5lbC1ib2R5LSR7c2VsZi5zZWN0aW9uSW5kZXh9JHtzZWxmLmdyb3VwSW5kZXh9YFxyXG5cdH1cclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBrby5jb21wb25lbnRzLnJlZ2lzdGVyKCdwYW5lbC1ncm91cCcsIHtcclxuXHR2aWV3TW9kZWw6IENhcmRHcm91cCxcclxuXHR0ZW1wbGF0ZTpgXHJcblx0XHQ8c2VjdGlvbiBkYXRhLWJpbmQ9XCJmb3JlYWNocHJvcDoge2RhdGE6IGRhdGEsIHNvcnRGbjogc29ydEJ5Q29uZmlnLmJpbmQoJGNvbXBvbmVudCl9XCIgY2xhc3M9XCJwYW5lbC1ncm91cFwiPlxyXG5cdFx0XHQ8IS0tcGFuZWwtLT5cclxuXHRcdFx0PHBhbmVsIGNsYXNzPVwicGFuZWwtaXRlbVwiIGRhdGEtYmluZD1cImNzczogeydoYXMtZXZlbnRzLWxpc3QnOiAkY29tcG9uZW50LmNoZWNrSWZIYXNFdmVudHNMaXN0KGtleSl9XCJcclxuXHRcdFx0XHRcdFx0XHRwYXJhbXM9XCIkZGF0YTogJGRhdGEsXHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQkaW5kZXg6ICRpbmRleCxcclxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHBhbmVsR3JvdXA6ICRjb21wb25lbnQsXHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRzb3J0QnlDb25maWc6ICRjb21wb25lbnQuc29ydEJ5Q29uZmlnXCI+XHJcblx0XHRcdDwvcGFuZWw+XHJcblx0XHQ8L3NlY3Rpb24+XHJcbmB9KTtcclxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc2NyaXB0cy9hcGktZXhwbG9yZXIvdjIvc3JjL2NvbXBvbmVudHMvcGFuZWxzL3BhbmVsR3JvdXAuY29tcG9uZW50LmpzIiwiY2xhc3MgUGFuZWwge1xyXG5cdGNvbnN0cnVjdG9yKHskZGF0YSA9IHt9LCBwYW5lbEdyb3VwID0ge30sICRpbmRleH0pIHtcclxuXHRcdHRoaXMuJGRhdGEgPSAkZGF0YTtcclxuXHRcdHRoaXMua2V5ID0gJGRhdGEua2V5O1xyXG5cdFx0dGhpcy4kaW5kZXggPSBrby51bndyYXAoJGluZGV4KTtcclxuXHRcdHRoaXMucGFuZWxHcm91cCA9IHBhbmVsR3JvdXA7XHJcblx0XHR0aGlzLnBhZ2UgPSBwYW5lbEdyb3VwLnBhZ2U7XHJcblx0XHR0aGlzLmNvbG9yQ2xhc3MgPSBwYW5lbEdyb3VwLmNvbG9yQ2xhc3MgfHwgJyc7XHJcblx0XHR0aGlzLmNvbmZpZyA9IHRoaXMuY29uc3RydWN0b3IucGFuZWxDb25maWcoe2NvbmZpZzogcGFuZWxHcm91cC5jb25maWcsIGtleTogdGhpcy5rZXl9KTtcclxuXHRcdHRoaXMuaXNFeHBhbmRlZCA9IHRoaXMuY29uc3RydWN0b3IuaXNFeHBhbmRlZCh0aGlzLmNvbmZpZyk7XHJcblx0XHR0aGlzLmNvbGxhcHNlSWQgPSBwYW5lbEdyb3VwLmNvbGxhcHNlSWQgKyB0aGlzLiRpbmRleDtcclxuXHRcdHRoaXMuaXNBY3RpdmUgPSBrby5vYnNlcnZhYmxlKHRoaXMuaXNFeHBhbmRlZCk7XHJcblx0XHR0aGlzLnN1YmplY3RJRCA9IGtvLm9ic2VydmFibGUoJycpO1xyXG5cdH1cclxuXHJcblx0c2V0QWN0aXZlKG1vZGVsLCBldmVudCkge1xyXG5cdFx0dGhpcy5pc0FjdGl2ZSghdGhpcy5pc0FjdGl2ZSgpKTtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIEdldHMgY29uZmlnIGZvciBlYWNoIHBhbmVsXHJcblx0ICogQHBhcmFtIGNvbmZpZ1xyXG5cdCAqIEBwYXJhbSBrZXlcclxuXHQgKiBAcmV0dXJucyB7Knx7fX1cclxuXHQgKi9cclxuXHRzdGF0aWMgcGFuZWxDb25maWcoe2NvbmZpZywga2V5fSkge1xyXG5cdFx0bGV0IHN1YkNvbmZpZyA9IGNvbmZpZ1trZXldIHx8IHt9O1xyXG5cclxuXHRcdHN1YkNvbmZpZy5fQ09ORklHID0gJC5leHRlbmQodHJ1ZSwge30sIGNvbmZpZy5fQ09ORklHLCBzdWJDb25maWcuX0NPTkZJRyk7XHJcblx0XHRyZXR1cm4gc3ViQ29uZmlnO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogQ2hlY2tzIGZvciAnZXhwYW5kZWQnIGNvbmZpZyBmb3IgZWFjaCBwYW5lbFxyXG5cdCAqIEBwYXJhbSBjb25maWdcclxuXHQgKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuXHQgKi9cclxuXHRzdGF0aWMgaXNFeHBhbmRlZChjb25maWcpIHtcclxuXHRcdHJldHVybiAhKE9iamVjdC5nZXRQcm9wKGNvbmZpZywgJy5fQ09ORklHLmNvbGxhcHNlZCcpIHx8IGZhbHNlKTtcclxuXHR9XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0ga28uY29tcG9uZW50cy5yZWdpc3RlcigncGFuZWwnLCB7XHJcblx0dmlld01vZGVsOiBQYW5lbCxcclxuXHR0ZW1wbGF0ZTpgXHJcblx0XHQ8c2VjdGlvbiBkYXRhLWJpbmQ9XCJjc3M6IHtbY29sb3JDbGFzc106IHRydWUsIGFjdGl2ZTogaXNBY3RpdmV9XCIgY2xhc3M9XCJwYW5lbCBwYW5lbC1wcmltYXJ5XCI+XHJcblx0XHRcdDwhLS1wYW5lbC1oZWFkaW5nLS0+XHJcblx0XHRcdDxwYW5lbC1oZWFkaW5nIHBhcmFtcz1cInBhbmVsR3JvdXA6IHBhbmVsR3JvdXAsIGNvbmZpZzogY29uZmlnLCBkYXRhOiAkZGF0YSwgaW5kZXg6ICRpbmRleCwgcGFnZTogcGFnZSwgc2V0QWN0aXZlOiBzZXRBY3RpdmUuYmluZCgkY29tcG9uZW50KSwgY29sbGFwc2VJZDogY29sbGFwc2VJZCwgY29sb3JDbGFzczogY29sb3JDbGFzcywgaXNFeHBhbmRlZDogaXNFeHBhbmRlZCwgc3ViamVjdElEOnN1YmplY3RJRFwiPjwvcGFuZWwtaGVhZGluZz5cclxuXHRcdFx0XHJcblx0XHRcdDwhLS1wYW5lbC1ib2R5LS0+XHJcblx0XHRcdDxzZWN0aW9uIGRhdGEtYmluZD1cImF0dHI6IHsnaWQnOiBjb2xsYXBzZUlkfSwgY3NzOiB7J2luJzogaXNFeHBhbmRlZH1cIiBjbGFzcz1cInBhbmVsLWNvbGxhcHNlIGNvbGxhcHNlXCI+XHRcdFx0XHRcclxuXHRcdFx0XHQ8IS0tIGtvIGlmOiAodHlwZW9mICRkYXRhLnZhbHVlID09PSAnb2JqZWN0JyAmJiAhJC5pc0FycmF5KCRkYXRhLnZhbHVlKSkgLS0+XHJcblx0XHRcdFx0XHQ8b2JqZWN0LXBhbmVsLWJvZHkgcGFyYW1zPVwiY29uZmlnOiBjb25maWcsIGRhdGE6ICRkYXRhLCBpbmRleDogJGluZGV4LCBwYW5lbEdyb3VwOiBwYW5lbEdyb3VwLCBwYWdlOiBwYWdlLCBjb2xsYXBzZUlkOiBjb2xsYXBzZUlkLCBzdWJqZWN0SUQ6IHN1YmplY3RJRFwiPjwvb2JqZWN0LXBhbmVsLWJvZHk+XHJcblx0XHRcdFx0PCEtLSAva28gLS0+XHJcblx0XHRcdFx0PCEtLSBrbyBpZjogKHR5cGVvZiAkZGF0YS52YWx1ZSA9PT0gJ29iamVjdCcgJiYgJC5pc0FycmF5KCRkYXRhLnZhbHVlKSkgLS0+XHJcblx0XHRcdFx0XHQ8YXJyYXktcGFuZWwtYm9keSBwYXJhbXM9XCJjb25maWc6IGNvbmZpZywgZGF0YTogJGRhdGEsIGluZGV4OiAkaW5kZXgsIHBhbmVsR3JvdXA6IHBhbmVsR3JvdXBcIj48L2FycmF5LXBhbmVsLWJvZHk+XHJcblx0XHRcdFx0PCEtLSAva28gLS0+XHJcblx0XHRcdDwvc2VjdGlvbj5cclxuXHRcdDwvc2VjdGlvbj5cclxuYH0pO1xyXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zY3JpcHRzL2FwaS1leHBsb3Jlci92Mi9zcmMvY29tcG9uZW50cy9wYW5lbHMvcGFuZWwuY29tcG9uZW50LmpzIiwiLyoqXG4gKiBQYWdpbmF0aW9uIGVsZW1lbnRcbiAqIEBwYXJhbSBwYXJhbXNcbiAqL1xuY2xhc3MgUGFnaW5hdGlvbiB7XG5cdGNvbnN0cnVjdG9yKHtwYWdlID0ge30sIHRvdGFsUGFnZXMsIG51bWJlcn0pIHtcblx0XHR0aGlzLnBhZ2UgPSBwYWdlO1xuXHRcdHRoaXMudG90YWxQYWdlcyA9ICt0b3RhbFBhZ2VzO1xuXHRcdHRoaXMubnVtYmVyID0gK251bWJlcjtcblx0XHR0aGlzLmZpcnN0ID0gISF0aGlzLm51bWJlcjtcblx0XHR0aGlzLmxhc3QgPSArbnVtYmVyIDwgK3RvdGFsUGFnZXMgLSAxO1xuXHRcdHRoaXMucmVxdWVzdEJ0biA9ICQoJyNhcGktZXhwLWdldC1idG4nKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBnZXQgbmV4dCBwYWdlXG5cdCAqL1xuXHRnZXRQcmV2UGFnZSgpIHtcblx0XHRsZXQgcGFnZSA9IHRoaXMucGFnZTtcblx0XHRjb25zdCB2YWwgPSBrby51bndyYXAocGFnZS5wYWdlUGFyYW0pO1xuXHRcdHBhZ2UucGFnZVBhcmFtKHZhbCA+IDAgPyB2YWwgLSAxIDogMCk7XG5cdFx0cGFnZS5zZXRQYXJhbXMoe1xuXHRcdFx0Y2F0ZWdvcnk6IHBhZ2UuY2F0ZWdvcnksXG5cdFx0XHRtZXRob2Q6IHBhZ2UubWV0aG9kLFxuXHRcdFx0bWV0aG9kSWQ6XHRwYWdlLm1ldGhvZElkLFxuXHRcdFx0cGFyYW1zOiBwYWdlLnBhcmFtc1xuXHRcdH0pO1xuXHRcdHRoaXMucmVxdWVzdEJ0bi50cmlnZ2VyKCdjbGljaycpO1xuXHR9XG5cblx0LyoqXG5cdCAqIGdldCBwcmV2IHBhZ2Vcblx0ICovXG5cdGdldE5leHRQYWdlKCkge1xuXHRcdGxldCBwYWdlID0gdGhpcy5wYWdlO1xuXHRcdGNvbnN0IHZhbCA9IGtvLnVud3JhcCh0aGlzLm51bWJlcik7XG5cdFx0cGFnZS5wYWdlUGFyYW0odmFsIDwgdGhpcy50b3RhbFBhZ2VzIC0gMSA/IHZhbCAgKyAxOiB2YWwpO1xuXHRcdHBhZ2Uuc2V0UGFyYW1zKHtcblx0XHRcdGNhdGVnb3J5OiBwYWdlLmNhdGVnb3J5LFxuXHRcdFx0bWV0aG9kOiBwYWdlLm1ldGhvZCxcblx0XHRcdG1ldGhvZElkOlx0cGFnZS5tZXRob2RJZCxcblx0XHRcdHBhcmFtczogcGFnZS5wYXJhbXNcblx0XHR9KTtcblx0XHR0aGlzLnJlcXVlc3RCdG4udHJpZ2dlcignY2xpY2snKTtcblx0fVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGtvLmNvbXBvbmVudHMucmVnaXN0ZXIoJ3BhZ2luYXRpb24nLCB7XG5cdHZpZXdNb2RlbDogUGFnaW5hdGlvbixcblx0dGVtcGxhdGU6XG5cdGA8c3BhbiBjbGFzcz1cIm5hdmlnYXRpb24td3JhcHBlclwiPlxuXHRcdDxidXR0b24gZGF0YS1iaW5kPVwiY2xpY2s6IGdldFByZXZQYWdlLCBlbmFibGU6IGZpcnN0XCIgdHlwZT1cImJ1dHRvblwiIGNsYXNzPVwibmF2aWdhdGlvbiBwcmV2XCI+PC9idXR0b24+XG5cdFx0PGJ1dHRvbiBkYXRhLWJpbmQ9XCJjbGljazogZ2V0TmV4dFBhZ2UsIGVuYWJsZTogbGFzdFwiIHR5cGU9XCJidXR0b25cIiBjbGFzcz1cIm5hdmlnYXRpb24gbmV4dFwiPjwvYnV0dG9uPlxuXHQ8L3NwYW4+YFxufSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zY3JpcHRzL2FwaS1leHBsb3Jlci92Mi9zcmMvY29tcG9uZW50cy9wYW5lbHMvcGFnaW5hdGlvbi5jb21wb25lbnQuanMiLCJpbXBvcnQge2NvbG9yc1NlcnZpY2V9IGZyb20gJy4uLy4uL3NlcnZpY2VzJztcclxuXHJcbmNsYXNzIFBhbmVsSGVhZGluZyB7XHJcblx0Y29uc3RydWN0b3Ioe2NvbmZpZyA9IHt9LCBkYXRhID0ge30sIHNldEFjdGl2ZSwgaXNFeHBhbmRlZCwgcGFnZSwgY29sbGFwc2VJZCwgY29sb3JDbGFzcywgcGFuZWxHcm91cCwgc3ViamVjdElEfSkge1xyXG5cdFx0dGhpcy5jb25maWcgPSBjb25maWcuX0NPTkZJRztcclxuXHRcdHRoaXMuc2V0QWN0aXZlID0gc2V0QWN0aXZlO1xyXG5cdFx0dGhpcy5pc0V4cGFuZGVkID0gaXNFeHBhbmRlZDtcclxuXHRcdHRoaXMuX3BhbmVsTmFtZSA9IGRhdGEua2V5O1xyXG5cdFx0dGhpcy50aXRsZSA9IHRoaXMuY29uZmlnICYmIHRoaXMuY29uZmlnLnRpdGxlIHx8IHRoaXMuX3BhbmVsTmFtZTtcclxuXHRcdHRoaXMuZGF0YSA9IGRhdGEudmFsdWU7XHJcblx0XHR0aGlzLmNvbGxhcHNlSWQgPSBjb2xsYXBzZUlkO1xyXG5cdFx0dGhpcy5wYWdlID0gcGFnZTtcclxuXHRcdHRoaXMucGFuZWxHcm91cCA9IHBhbmVsR3JvdXA7XHJcblx0XHR0aGlzLnN1YmplY3RJZCA9IHN1YmplY3RJRDtcclxuXHRcdHRoaXMuaW5pdCh7cGFnZSwgY29sb3JDbGFzc30pO1xyXG5cdH1cclxuXHJcblx0aW5pdCh7cGFnZSwgY29sb3JDbGFzc30pIHtcclxuXHRcdGlmIChwYWdlKSB7XHJcblx0XHRcdHRoaXMuY2FyZFNpemUgPSBwYWdlLnNpemU7XHJcblx0XHR9XHJcblx0XHRpZiAodGhpcy5jb25maWcucmVxdWVzdCkge1xyXG5cdFx0XHR0aGlzLmFub3RoZXJSZXF1ZXN0Q29sb3IgPSBjb2xvcnNTZXJ2aWNlLmdldFJhbmRvbUNvbG9yKGNvbG9yQ2xhc3MpO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0Zm9sbG93UmVxdWVzdCh2YWx1ZSkge1xyXG5cdFx0bGV0IHVybCA9IE9iamVjdC5nZXRQcm9wKHZhbHVlLCAnLmNvbmZpZy5yZXF1ZXN0Jyk7XHJcblx0XHRpZiAodXJsKSB7XHJcblx0XHRcdGxldCBtZXRob2QgPSB7fTtcclxuXHRcdFx0dXJsID0gdXJsLnNwbGl0KG5ldyBSZWdFeHAoJ2h0dHBzOi8vYXBwLnRpY2tldG1hc3Rlci5jb20vJykpWzFdO1xyXG5cdFx0XHRQYW5lbEhlYWRpbmcuZ2V0RGVlcFByb3AodXJsLCBiYXNlLCBtZXRob2QpO1xyXG5cdFx0XHRtZXRob2QgPSBtZXRob2Qub2JqZWN0O1xyXG5cclxuXHRcdFx0bWV0aG9kLnBhcmFtZXRlcnMgPSBPYmplY3Qua2V5cyhtZXRob2QucGFyYW1ldGVycykubWFwKGtleSA9PiB7XHJcblx0XHRcdFx0bGV0IHBhcmFtID0gbWV0aG9kLnBhcmFtZXRlcnNba2V5XTtcclxuXHRcdFx0XHRpZiAocGFyYW0ubmFtZSA9PT0gJ2lkJykge1xyXG5cdFx0XHRcdFx0cGFyYW0udmFsdWUgPSBrby51bndyYXAodGhpcy5zdWJqZWN0SWQpO1xyXG5cdFx0XHRcdH0gZWxzZSBpZiAocGFyYW0ubmFtZSA9PT0gJ2Zvcm1hdCcpIHtcclxuXHRcdFx0XHRcdHBhcmFtLnZhbHVlID0gJ2pzb24nXHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdHJldHVybiBwYXJhbTtcclxuXHRcdFx0fSk7XHJcblxyXG5cclxuXHRcdFx0dGhpcy5hbm90aGVyUmVxdWVzdCA9IGtvLm9ic2VydmFibGUoe3VybCwgbWV0aG9kLCBwYW5lbEdyb3VwOiB0aGlzLnBhbmVsR3JvdXAsIGNvbG9yOiB0aGlzLmFub3RoZXJSZXF1ZXN0Q29sb3J9KS5wdWJsaXNoT24oJ0FOT1RIRVJfUkVRVUVTVCcpO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0Z2V0IGhhc0Fub3RoZXJSZXF1ZXN0KCkge1xyXG5cdFx0cmV0dXJuICEhdGhpcy5jb25maWcucmVxdWVzdDtcclxuXHR9XHJcblxyXG5cdHN0YXRpYyBnZXREZWVwUHJvcCh2YWwsIG9iaiwgcmVzdWx0KSB7XHJcblx0XHRpZiAodHlwZW9mIG9iaiAhPT0gJ29iamVjdCcpIHJldHVybjtcclxuXHJcblx0XHRmb3IgKGxldCBwcm9wIGluIG9iaikge1xyXG5cdFx0XHRpZiAob2JqLmhhc093blByb3BlcnR5KHByb3ApICYmIHR5cGVvZiBvYmpbcHJvcF0gPT09ICdvYmplY3QnICYmICFyZXN1bHQubGVuZ3RoKSB7XHJcblx0XHRcdFx0aWYgKG9ialtwcm9wXS5wYXRoID09PSB2YWwpIHtcclxuXHRcdFx0XHRcdHJlc3VsdC5vYmplY3QgPSBvYmpbcHJvcF07XHJcblx0XHRcdFx0XHRicmVhaztcclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0UGFuZWxIZWFkaW5nLmdldERlZXBQcm9wKHZhbCwgb2JqW3Byb3BdLCByZXN1bHQpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH1cclxufVxyXG5cclxuXHJcbm1vZHVsZS5leHBvcnRzID0ga28uY29tcG9uZW50cy5yZWdpc3RlcigncGFuZWwtaGVhZGluZycsIHtcclxuXHR2aWV3TW9kZWw6ICBQYW5lbEhlYWRpbmcsXHJcblx0dGVtcGxhdGU6YFxyXG5cdFx0PHNlY3Rpb24gY2xhc3M9XCJwYW5lbC1oZWFkaW5nXCI+XHJcblx0XHRcdDxkaXYgY2xhc3M9XCJwYW5lbC10aXRsZVwiPlxyXG5cdFx0XHRcdFxyXG5cdFx0XHRcdDxhIGRhdGEtYmluZD1cImNsaWNrOiBzZXRBY3RpdmUsIGF0dHI6IHtocmVmOiAnIycgKyBjb2xsYXBzZUlkLCAnYXJpYS1jb250cm9scyc6IGNvbGxhcHNlSWQsICdhcmlhLWV4cGFuZGVkJzogaXNFeHBhbmRlZH1cIiBjbGFzcz1cImJ0biBidG4taWNvbiBidG4tdGl0bGVcIiB0eXBlPVwiYnV0dG9uXCIgZGF0YS10b2dnbGU9XCJjb2xsYXBzZVwiIGFyaWEtZXhwYW5kZWQ9XCJmYWxzZVwiPlxyXG5cdFx0XHRcdFx0PHNwYW4gY2xhc3M9XCJidG4gYnRuLWljb24gc2hldnJvbiB3aGl0ZS1zaGV2cm9uLXVwXCI+PC9zcGFuPlxyXG5cdFx0XHRcdFx0PHAgZGF0YS1iaW5kPVwidGV4dDogdGl0bGVcIiBjbGFzcz1cInRpdGxlXCI+UGFuZWwgdGl0bGU8L3A+XHJcblx0XHRcdFx0PC9hPlxyXG5cdFx0XHRcdFxyXG5cdFx0XHRcdDwhLS0ga28gaWY6IF9wYW5lbE5hbWUgPT09ICdldmVudHMnLS0+XHJcblx0XHRcdFx0XHQ8c3BhbiBkYXRhLWJpbmQ9XCJ0ZXh0OiBjYXJkU2l6ZVwiIGNsYXNzPVwiY291bnRlclwiPjwvc3Bhbj5cclxuXHRcdFx0XHQ8IS0tIC9rby0tPlxyXG5cdFx0XHRcdFxyXG5cdFx0XHRcdDwhLS0ga28gaWY6IF9wYW5lbE5hbWUgPT09ICdwYWdlJy0tPlxyXG5cdFx0XHRcdFx0PHBhZ2luYXRpb24gcGFyYW1zPVwibnVtYmVyOiBkYXRhLm51bWJlciwgdG90YWxQYWdlczogZGF0YS50b3RhbFBhZ2VzLCBwYWdlOiBwYWdlXCI+PC9wYWdpbmF0aW9uPlxyXG5cdFx0XHRcdDwhLS0gL2tvLS0+XHJcblx0XHRcdFx0XHJcblx0XHRcdFx0PCEtLSBrbyBpZjogaGFzQW5vdGhlclJlcXVlc3QgLS0+XHJcblx0XHRcdFx0PHNlY3Rpb24gY2xhc3M9XCJmb2xsb3ctcmVxdWVzdFwiPlxyXG5cdFx0XHRcdFx0PHNwYW4gZGF0YS1iaW5kPVwiY3NzOiBhbm90aGVyUmVxdWVzdENvbG9yXCIgY2xhc3M9XCJjb2xvci1pbmRpY2F0b3JcIj48L3NwYW4+XHJcblx0XHRcdFx0XHQ8YnV0dG9uIGRhdGEtYmluZD1cImNsaWNrOiBmb2xsb3dSZXF1ZXN0XCIgY2xhc3M9XCJidG4gYnRuLXJlcXVlc3RcIiB0eXBlPVwiYnV0dG9uXCI+YW5vdGhlciByZXF1ZXN0PC9idXR0b24+XHJcblx0XHRcdFx0PC9zZWN0aW9uPlxyXG5cdFx0XHRcdDwhLS0gL2tvLS0+XHJcblx0XHRcdDwvZGl2PlxyXG5cdFx0PC9zZWN0aW9uPlxyXG5gfSk7XHJcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NjcmlwdHMvYXBpLWV4cGxvcmVyL3YyL3NyYy9jb21wb25lbnRzL3BhbmVscy9wYW5lbEhlYWRpbmcuY29tcG9uZW50LmpzIiwiaW1wb3J0IGJhc2UgZnJvbSAnLi9iYXNlLnNlcnZpY2UnO1xyXG5pbXBvcnQgYXBpS2V5IGZyb20gJy4vYXBpS2V5LnNlcnZpY2UnO1xyXG5pbXBvcnQgY29uZmlnIGZyb20gJy4vY29uZmlnLnNlcnZpY2UnO1xyXG5pbXBvcnQganNvbkhMIGZyb20gJy4vanNvbi1oaWdobGlnaHQnO1xyXG5pbXBvcnQgY29sb3JzU2VydmljZSBmcm9tICcuL2NvbG9ycy5zZXJ2aWNlJztcclxuaW1wb3J0IHJlc3QgZnJvbSAnLi9yZXN0LnNlcnZpY2UnO1xyXG5cclxuZXhwb3J0IHtcclxuXHRiYXNlLFxyXG5cdGFwaUtleSxcclxuXHRyZXN0LFxyXG5cdGNvbmZpZyxcclxuXHRqc29uSEwsXHJcblx0Y29sb3JzU2VydmljZVxyXG59O1xyXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zY3JpcHRzL2FwaS1leHBsb3Jlci92Mi9zcmMvc2VydmljZXMvaW5kZXguanMiLCJ2YXIgYmFzZSA9IHt9O1xyXG52YXIgQ09ORklHX1VSTCA9ICcuLi8uLi9hcGlkZXNjcmlwdGlvbi54bWwnO1xyXG5cclxudmFyIHBhcnNlRGF0YSA9IGZ1bmN0aW9uICh4bWwpIHtcclxuXHR2YXIgZ2xvYmFsID0ge307XHJcblx0Ly9nZXQgYWxsIEFQSXNcclxuXHR2YXIgcmVzb3VyY2VzRWwgPSAkKHhtbCkuZmluZChcInJlc291cmNlc1wiKS5lcSgwKTtcclxuXHJcblx0Ly8gcmVzb3VyY2VcclxuXHQkKHhtbClcclxuXHRcdC5maW5kKFwicmVzb3VyY2VcIilcclxuXHRcdC5nZXQoKVxyXG5cdFx0Lm1hcChmdW5jdGlvbiAocmVzKSB7XHJcblx0XHRcdHZhciByZXNvdXJjZSA9ICQocmVzKTtcclxuXHRcdFx0Ly8gbWV0aG9kIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcblx0XHRcdHZhciBtZXRob2RFbGVtID0gcmVzb3VyY2UuZmluZChcIm1ldGhvZFwiKS5lcSgwKTtcclxuXHJcblx0XHRcdHZhciBtZXRob2QgPSB7XHJcblx0XHRcdFx0aWQgOiBtZXRob2RFbGVtLmF0dHIoXCJpZFwiKSwgLy8gbWV0aG9kIGlkXHJcblx0XHRcdFx0bmFtZSA6IG1ldGhvZEVsZW0uYXR0cihcImFwaWdlZTpkaXNwbGF5TmFtZVwiKSB8fCBtZXRob2RFbGVtLmF0dHIoXCJpZFwiKSwgLy8gbWV0aG9kIG5hbWVcclxuXHRcdFx0XHRtZXRob2QgOiBtZXRob2RFbGVtLmF0dHIoJ25hbWUnKSwgLy8gR0VUIG9yIFBPU1RcclxuXHRcdFx0XHRjYXRlZ29yeSA6IG1ldGhvZEVsZW0uZmluZCgnW3ByaW1hcnk9XCJ0cnVlXCJdJykudGV4dCgpLnRyaW0oKSwgLy8gQVBJIG5hbWVcclxuXHRcdFx0XHRwYXRoOiByZXNvdXJjZS5hdHRyKCdwYXRoJyksIC8vIG1ldGhvZCBVUkxcclxuXHRcdFx0XHRiYXNlIDogcmVzb3VyY2VzRWwuYXR0cignYmFzZScpLCAvLyBtZXRob2QgYmFzZSBsaW5rXHJcblx0XHRcdFx0bGluayA6IG1ldGhvZEVsZW0uZmluZCgnZG9jJykuZXEoMCkuYXR0cignYXBpZ2VlOnVybCcpLCAvLyBsaW5rIHRvIGRvY3VtZW50YXRpb25cclxuXHRcdFx0XHRkZXNjcmlwdGlvbiA6IG1ldGhvZEVsZW0uZmluZCgnZG9jJykuZXEoMCkudGV4dCgpLnRyaW0oKSwgLy9tZXRob2QgZGVzY3JpcHRpb25cclxuXHRcdFx0XHRwYXJhbWV0ZXJzOiB7fVxyXG5cdFx0XHR9O1xyXG5cclxuXHRcdFx0Ly8gcGFyYW1zIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcblx0XHRcdHJlc291cmNlXHJcblx0XHRcdFx0LmZpbmQoJ3BhcmFtJylcclxuXHRcdFx0XHQuZ2V0KClcclxuXHRcdFx0XHQubWFwKGZ1bmN0aW9uIChwYXIpIHtcclxuXHRcdFx0XHRcdHZhciBwYXJhbSA9ICQocGFyKTtcclxuXHRcdFx0XHRcdHZhciBvcHRpb25zID0gcGFyYW0uZmluZCgnb3B0aW9uJyk7XHJcblx0XHRcdFx0XHR2YXIgaXNTZWxlY3QgPSAhIW9wdGlvbnMubGVuZ3RoO1xyXG5cclxuXHRcdFx0XHRcdHZhciBwYXJhbWV0ZXIgPSB7XHJcblx0XHRcdFx0XHRcdG5hbWU6IHBhcmFtLmF0dHIoJ25hbWUnKSxcclxuXHRcdFx0XHRcdFx0ZG9jOiBwYXJhbS5maXJzdCgnZG9jJykudGV4dCgpLnRyaW0oKSxcclxuXHRcdFx0XHRcdFx0c3R5bGU6IHBhcmFtLmF0dHIoJ3N0eWxlJyksXHJcblx0XHRcdFx0XHRcdHJlcXVpcmVkOiBwYXJhbS5hdHRyKCdyZXF1aXJlZCcpID09PSAndHJ1ZScsXHJcblx0XHRcdFx0XHRcdGRlZmF1bHQ6IHBhcmFtLmF0dHIoJ2RlZmF1bHQnKSA9PT0gJ25vbmUnICYmIGlzU2VsZWN0ID8gJycgOiBwYXJhbS5hdHRyKCdkZWZhdWx0JyksXHJcblx0XHRcdFx0XHRcdHNlbGVjdDogaXNTZWxlY3QsXHJcblx0XHRcdFx0XHRcdHR5cGU6IHBhcmFtLmF0dHIoJ3R5cGUnKS5yZXBsYWNlKCd4c2Q6JywgJycpXHJcblx0XHRcdFx0XHR9O1xyXG5cclxuXHRcdFx0XHRcdGlmIChpc1NlbGVjdCkge1xyXG5cdFx0XHRcdFx0XHRwYXJhbWV0ZXIub3B0aW9ucyA9IG9wdGlvbnMuZ2V0KCkubWFwKGZ1bmN0aW9uIChvcHRpb24pIHtcclxuXHRcdFx0XHRcdFx0XHRyZXR1cm4ge1xyXG5cdFx0XHRcdFx0XHRcdFx0bmFtZTogJChvcHRpb24pLmF0dHIoJ3ZhbHVlJyksXHJcblx0XHRcdFx0XHRcdFx0XHRjaGVja2VkOiAkKG9wdGlvbikuYXR0cigndmFsdWUnKSA9PT0gcGFyYW1ldGVyLmRlZmF1bHQgfHwgJChvcHRpb24pLmF0dHIoJ3ZhbHVlJykgPT09ICdub25lJyxcclxuXHRcdFx0XHRcdFx0XHRcdGxpbms6IGZhbHNlXHJcblx0XHRcdFx0XHRcdFx0fTtcclxuXHRcdFx0XHRcdFx0fSk7XHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0bWV0aG9kLnBhcmFtZXRlcnNbcGFyYW1ldGVyLm5hbWVdID0gcGFyYW1ldGVyO1xyXG5cdFx0XHRcdH0pO1xyXG5cclxuXHRcdFx0LyoqXHJcblx0XHRcdCAqIEdsb2JhbCBvYmogY29tcG9zaXRpb25cclxuICAgICAgICovXHJcblx0XHRcdC8vIHNldCBjYXRlZ29yeSBvYmpcclxuXHRcdFx0Z2xvYmFsW21ldGhvZC5jYXRlZ29yeV0gPSBnbG9iYWxbbWV0aG9kLmNhdGVnb3J5XSB8fCB7fTtcclxuXHJcblx0XHRcdC8vIHNldCBtZXRob2RzIHR5cGUgb2JqXHJcblx0XHRcdGdsb2JhbFttZXRob2QuY2F0ZWdvcnldLkFMTCA9IGdsb2JhbFttZXRob2QuY2F0ZWdvcnldLkFMTCB8fCB7fTtcclxuXHRcdFx0Z2xvYmFsW21ldGhvZC5jYXRlZ29yeV1bbWV0aG9kLm1ldGhvZF0gPSBnbG9iYWxbbWV0aG9kLmNhdGVnb3J5XVttZXRob2QubWV0aG9kXSB8fCB7fTtcclxuXHJcblx0XHRcdC8vIHNldCBtZXRob2Qgb2JqXHJcblx0XHRcdGdsb2JhbFttZXRob2QuY2F0ZWdvcnldLkFMTFttZXRob2QuaWRdID0gbWV0aG9kO1xyXG5cdFx0XHRnbG9iYWxbbWV0aG9kLmNhdGVnb3J5XVttZXRob2QubWV0aG9kXVttZXRob2QuaWRdID0gbWV0aG9kO1xyXG5cdFx0fSk7XHJcblxyXG5cdHJldHVybiBnbG9iYWw7XHJcbn07XHJcblxyXG4vL2dldHMgZG9jdW1lbnQgZnJvbSBXQURMIGNvbmZpZ3VyYXRpb24gZmlsZVxyXG52YXIgcmVhZEZyb21XQURMID0gZnVuY3Rpb24gKCkge1xyXG4gICQuYWpheCh7XHJcbiAgICB1cmw6IENPTkZJR19VUkwsXHJcbiAgICBhc3luYyA6IGZhbHNlLFxyXG4gICAgZGF0YVR5cGU6IFwidGV4dFwiLFxyXG4gICAgc3VjY2VzcyA6IGZ1bmN0aW9uKHJlc3BvbnNlKXtcclxuICAgICAgdmFyIHhtbCA9ICQucGFyc2VYTUwocmVzcG9uc2UpO1xyXG5cdFx0XHRiYXNlID0gcGFyc2VEYXRhKHhtbCk7XHJcbiAgICB9LFxyXG5cclxuICAgIGVycm9yOiBmdW5jdGlvbihYTUxIdHRwUmVxdWVzdCwgdGV4dFN0YXR1cywgZXJyb3JUaHJvd24pe1xyXG4gICAgICBhbGVydCgnRGF0YSBDb3VsZCBOb3QgQmUgTG9hZGVkIC0gJysgdGV4dFN0YXR1cyk7XHJcbiAgICB9XHJcbiAgfSk7XHJcbn07XHJcbnJlYWRGcm9tV0FETCgpO1xyXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2U7XHJcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NjcmlwdHMvYXBpLWV4cGxvcmVyL3YyL3NyYy9zZXJ2aWNlcy9iYXNlLnNlcnZpY2UuanMiLCJ2YXIgYXBpS2V5ID0gYXBpS2V5U2VydmljZS5jaGVja0FwaUtleUNvb2tpZSgndGstYXBpLWtleScpIHx8IGFwaUtleVNlcnZpY2UuZ2V0QXBpRXhwbG9yZUtleSgpOyAvL0FQSSBLZXlcclxuXHJcbm1vZHVsZS5leHBvcnRzID0ge1xyXG5cdHBsYWNlaG9sZGVyOiAnQXBpIGtleScsXHJcbiAgbmFtZTogJ2FwaWtleScsXHJcbiAgc3R5bGU6ICdxdWVyeScsXHJcbiAgdmFsdWU6IGtvLm9ic2VydmFibGUoYXBpS2V5KSxcclxuXHR0eXBlOiAnc3RyaW5nJyxcclxuXHRyZXF1aXJlZDogdHJ1ZVxyXG59O1xyXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zY3JpcHRzL2FwaS1leHBsb3Jlci92Mi9zcmMvc2VydmljZXMvYXBpS2V5LnNlcnZpY2UuanMiLCJ2YXIgY29uZmlnID0ga28ub2JzZXJ2YWJsZSgpO1xyXG5cclxuJC5hamF4KHtcclxuXHR0eXBlOiAnR0VUJyxcclxuXHR1cmw6IFtcclxuXHRcdCdodHRwOi8vJyxcclxuXHRcdGRvY3VtZW50LmxvY2F0aW9uLmhvc3RuYW1lLFxyXG5cdFx0ZG9jdW1lbnQubG9jYXRpb24ucG9ydCAmJiAnOicgKyBkb2N1bWVudC5sb2NhdGlvbi5wb3J0LFxyXG5cdFx0Jy9zY3JpcHRzL2FwaS1leHBsb3Jlci92Mi9jb25maWcuanNvbidcclxuXHRdLmpvaW4oJycpLFxyXG5cdGFzeW5jOiB0cnVlLFxyXG5cdGRhdGFUeXBlOiBcImpzb25cIixcclxuXHRjb21wbGV0ZTogZnVuY3Rpb24ocmVzLCBtc2cpIHtcclxuXHRcdGlmIChtc2cgPT0gJ2Vycm9yJykge1xyXG5cdFx0XHRjb25zb2xlLmVycm9yKCdjYW5cXCd0IGxvYWQgY29uZmlnLmpzb24hJyk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRjb25maWcocmVzLnJlc3BvbnNlSlNPTik7XHJcblx0XHR9XHJcblx0fVxyXG59KTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gY29uZmlnO1xyXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zY3JpcHRzL2FwaS1leHBsb3Jlci92Mi9zcmMvc2VydmljZXMvY29uZmlnLnNlcnZpY2UuanMiLCJ2YXIgV29ya2VyID0gcmVxdWlyZSgnLi9oaWdobGlnaHRKc29uLndvcmtlci5qcycpOyAvLyBKc29uLWZvcm1hdHRlciB3b3JrZXJcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG9ic2VydmFibGUsIGNvZGUpIHtcclxuXHR2YXIgYW5pbVRpbWUgPSAxMDA7XHJcblx0dmFyIHdvcmtlciA9IG5ldyBXb3JrZXI7XHJcblxyXG5cdHdvcmtlci5vbm1lc3NhZ2UgPSBmdW5jdGlvbiAoZXZlbnQpIHtcclxuXHRcdG9ic2VydmFibGUoZXZlbnQuZGF0YSk7XHJcblxyXG5cdFx0JChkb2N1bWVudClcclxuXHRcdFx0Lm9uKCdjbGljayB0b3VjaCcsICcudG0tY29kZS1jb250YWluZXIgLmV4cGFuZGVkJywgZnVuY3Rpb24ganNvbkNvZGVDb250YWluZXJFeHBhbmRlZChlKSB7XHJcblx0XHRcdFx0ZS5wcmV2ZW50RGVmYXVsdCgpO1xyXG5cdFx0XHRcdGUuc3RvcFByb3BhZ2F0aW9uKCk7XHJcblx0XHRcdFx0dmFyICRzZWxmID0gJCh0aGlzKTtcclxuXHRcdFx0XHQkc2VsZlxyXG5cdFx0XHRcdFx0LnBhcmVudCgpXHJcblx0XHRcdFx0XHQuZmluZCgnPnVsJylcclxuXHRcdFx0XHRcdC5zbGlkZVVwKGFuaW1UaW1lLCBmdW5jdGlvbigpIHtcclxuXHRcdFx0XHRcdFx0JHNlbGYuYWRkQ2xhc3MoJ2NvbGxhcHNlZCcpO1xyXG5cdFx0XHRcdFx0fSk7XHJcblx0XHRcdH0pXHJcblx0XHRcdC5vbignY2xpY2sgdG91Y2gnLCAnLnRtLWNvZGUtY29udGFpbmVyIC5leHBhbmRlZC5jb2xsYXBzZWQnLCBmdW5jdGlvbiBqc29uQ29kZUNvbnRhaW5lckNvbGxhcHNlZChlKSB7XHJcblx0XHRcdFx0ZS5wcmV2ZW50RGVmYXVsdCgpO1xyXG5cdFx0XHRcdGUuc3RvcFByb3BhZ2F0aW9uKCk7XHJcblx0XHRcdFx0dmFyICRzZWxmID0gJCh0aGlzKTtcclxuXHRcdFx0XHQkc2VsZlxyXG5cdFx0XHRcdFx0LnJlbW92ZUNsYXNzKCdjb2xsYXBzZWQnKVxyXG5cdFx0XHRcdFx0LnBhcmVudCgpXHJcblx0XHRcdFx0XHQuZmluZCgnPnVsJylcclxuXHRcdFx0XHRcdC5zbGlkZURvd24oYW5pbVRpbWUsIGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRcdFx0XHQkc2VsZlxyXG5cdFx0XHRcdFx0XHRcdC5yZW1vdmVDbGFzcygnY29sbGFwc2VkJylcclxuXHRcdFx0XHRcdFx0XHQucmVtb3ZlQ2xhc3MoJ2hpZGRlbicpO1xyXG5cdFx0XHRcdFx0fSk7XHJcblx0XHRcdH0pXHJcblx0fTtcclxuXHR3b3JrZXIub25lcnJvciA9IGZ1bmN0aW9uIChldmVudCkge1xyXG5cdFx0Y29uc29sZS5lcnJvcihldmVudCk7XHJcblx0fTtcclxuXHJcblx0d29ya2VyLnBvc3RNZXNzYWdlKGNvZGUpO1xyXG59O1xyXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zY3JpcHRzL2FwaS1leHBsb3Jlci92Mi9zcmMvc2VydmljZXMvanNvbi1oaWdobGlnaHQvaW5kZXguanMiLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKCkge1xuXHRyZXR1cm4gcmVxdWlyZShcIiEhRDpcXFxcdGlja2V0bWFzdGVyLWFwaS1zdGFnaW5nLmdpdGh1Yi5pb1xcXFxub2RlX21vZHVsZXNcXFxcd29ya2VyLWxvYWRlclxcXFxjcmVhdGVJbmxpbmVXb3JrZXIuanNcIikoXCIvKioqKioqLyAoZnVuY3Rpb24obW9kdWxlcykgeyAvLyB3ZWJwYWNrQm9vdHN0cmFwXFxuLyoqKioqKi8gXFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxcbi8qKioqKiovIFxcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XFxuLyoqKioqKi9cXG4vKioqKioqLyBcXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxcbi8qKioqKiovIFxcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcXG4vKioqKioqL1xcbi8qKioqKiovIFxcdFxcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxcbi8qKioqKiovIFxcdFxcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKVxcbi8qKioqKiovIFxcdFxcdFxcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xcbi8qKioqKiovXFxuLyoqKioqKi8gXFx0XFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcXG4vKioqKioqLyBcXHRcXHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XFxuLyoqKioqKi8gXFx0XFx0XFx0ZXhwb3J0czoge30sXFxuLyoqKioqKi8gXFx0XFx0XFx0aWQ6IG1vZHVsZUlkLFxcbi8qKioqKiovIFxcdFxcdFxcdGxvYWRlZDogZmFsc2VcXG4vKioqKioqLyBcXHRcXHR9O1xcbi8qKioqKiovXFxuLyoqKioqKi8gXFx0XFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXFxuLyoqKioqKi8gXFx0XFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XFxuLyoqKioqKi9cXG4vKioqKioqLyBcXHRcXHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXFxuLyoqKioqKi8gXFx0XFx0bW9kdWxlLmxvYWRlZCA9IHRydWU7XFxuLyoqKioqKi9cXG4vKioqKioqLyBcXHRcXHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxcbi8qKioqKiovIFxcdFxcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcXG4vKioqKioqLyBcXHR9XFxuLyoqKioqKi9cXG4vKioqKioqL1xcbi8qKioqKiovIFxcdC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXFxuLyoqKioqKi8gXFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcXG4vKioqKioqL1xcbi8qKioqKiovIFxcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXFxuLyoqKioqKi8gXFx0X193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcXG4vKioqKioqL1xcbi8qKioqKiovIFxcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXFxuLyoqKioqKi8gXFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXFxcIlxcXCI7XFxuLyoqKioqKi9cXG4vKioqKioqLyBcXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcXG4vKioqKioqLyBcXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcXG4vKioqKioqLyB9KVxcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXFxuLyoqKioqKi8gKFtcXG4vKiAwICovXFxuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XFxuXFxuXFx0LyoqXFxyXFxuXFx0ICogQ29kZSBmb3JtYXQgd2ViLXdvcmtlclxcclxcblxcdCAqIEBwYXJhbSBldmVudFxcclxcblxcdCAqL1xcclxcblxcdC8vIHZhciBoaWdobGlnaHRKc29uKClcXHJcXG5cXHR2YXIgaGlnaGxpZ2h0SnNvbiA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XFxyXFxuXFx0XFxyXFxuXFx0b25tZXNzYWdlID0gZnVuY3Rpb24oZXZlbnQpIHtcXHJcXG5cXHQgIHZhciBjb2RlID0gZXZlbnQuZGF0YTtcXHJcXG5cXHQgIC8vIGltcG9ydFNjcmlwdHMoJ2pzb24tcGFyc2UuanMnKTtcXHJcXG5cXHQgIHZhciByZXN1bHQgPSBoaWdobGlnaHRKc29uKGNvZGUsIHtleHBhbmRlZDogdHJ1ZX0pO1xcclxcblxcdCAgLy8gdmFyIHJlc3VsdCA9SlNPTi5zdHJpbmdpZnkoY29kZSk7XFxyXFxuXFx0ICBwb3N0TWVzc2FnZShyZXN1bHQpO1xcclxcblxcdH07XFxyXFxuXFxuXFxuLyoqKi8gfSxcXG4vKiAxICovXFxuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XFxuXFxuXFx0J3VzZSBzdHJpY3QnO1xcblxcdFxcblxcdHZhciBfc3RyaW5naWZ5ID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcXG5cXHRcXG5cXHR2YXIgX3N0cmluZ2lmeTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9zdHJpbmdpZnkpO1xcblxcdFxcblxcdHZhciBfdHlwZW9mMiA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XFxuXFx0XFxuXFx0dmFyIF90eXBlb2YzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdHlwZW9mMik7XFxuXFx0XFxuXFx0ZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cXG5cXHRcXG5cXHR2YXIgcHJlZml4ID0gJ3RtLWNvZGUnO1xcblxcdFxcblxcdHZhciBnZXRFeHBhbmRlckNsYXNzZXMgPSBmdW5jdGlvbiBnZXRFeHBhbmRlckNsYXNzZXMoZXhwYW5kZWQpIHtcXG5cXHRcXHRpZiAoIWV4cGFuZGVkKSB7XFxuXFx0XFx0XFx0cmV0dXJuICdleHBhbmRlZCBjb2xsYXBzZWQgaGlkZGVuJztcXG5cXHRcXHR9XFxuXFx0XFx0cmV0dXJuICdleHBhbmRlZCc7XFxuXFx0fTtcXG5cXHRcXG5cXHR2YXIgZW5jb2RlID0gZnVuY3Rpb24gZW5jb2RlKHZhbHVlKSB7XFxuXFx0XFx0cmV0dXJuIFsnPHNwYW4+JywgdmFsdWUsICc8L3NwYW4+J10uam9pbignJyk7XFxuXFx0fTtcXG5cXHRcXG5cXHR2YXIgY3JlYXRlRWxlbWVudCA9IGZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnQoa2V5LCB2YWx1ZSwgdHlwZSwgZXhwYW5kZXJDbGFzc2VzKSB7XFxuXFx0XFx0dmFyIGtsYXNzID0gJ29iamVjdCcsXFxuXFx0XFx0ICAgIG9wZW4gPSAneycsXFxuXFx0XFx0ICAgIGNsb3NlID0gJ30nO1xcblxcdFxcblxcdFxcdGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xcblxcdFxcdFxcdGtsYXNzID0gJ2FycmF5JztcXG5cXHRcXHRcXHRvcGVuID0gJ1snO1xcblxcdFxcdFxcdGNsb3NlID0gJ10nO1xcblxcdFxcdH1cXG5cXHRcXG5cXHRcXHRpZiAodmFsdWUgPT09IG51bGwpIHtcXG5cXHRcXHRcXHRyZXR1cm4gWyc8bGk+JywgJzxzcGFuIGNsYXNzPVxcXCJrZXlcXFwiPlxcXCInLCBlbmNvZGUoa2V5KSwgJ1xcXCI6IDwvc3Bhbj4nLCAnPHNwYW4gY2xhc3M9XFxcIm51bGxcXFwiPlxcXCInLCBlbmNvZGUodmFsdWUpLCAnXFxcIjwvc3Bhbj4nLCAnPC9saT4nXS5qb2luKCcnKTtcXG5cXHRcXHR9XFxuXFx0XFxuXFx0XFx0aWYgKHR5cGUgPT0gJ29iamVjdCcpIHtcXG5cXHRcXHRcXHRyZXR1cm4gWyc8bGk+JywgJzxzcGFuIGNsYXNzPVxcXCInLCBleHBhbmRlckNsYXNzZXMsICdcXFwiPjwvc3Bhbj4nLCAnPHNwYW4gY2xhc3M9XFxcImtleVxcXCI+XFxcIicsIGVuY29kZShrZXkpLCAnXFxcIjogPC9zcGFuPiAnLCAnPHNwYW4gY2xhc3M9XFxcIm9wZW5cXFwiPicsIG9wZW4sICc8L3NwYW4+ICcsICc8dWwgY2xhc3M9XFxcIicsIGtsYXNzLCAnXFxcIj4nLCBqc29uMmh0bWwodmFsdWUsIGV4cGFuZGVyQ2xhc3NlcyksICc8L3VsPicsICc8c3BhbiBjbGFzcz1cXFwiY2xvc2VcXFwiPicsIGNsb3NlLCAnPC9zcGFuPicsICc8L2xpPiddLmpvaW4oJycpO1xcblxcdFxcdH1cXG5cXHRcXG5cXHRcXHRpZiAodHlwZSA9PSAnbnVtYmVyJyB8fCB0eXBlID09ICdib29sZWFuJykge1xcblxcdFxcdFxcdHJldHVybiBbJzxsaT4nLCAnPHNwYW4gY2xhc3M9XFxcImtleVxcXCI+XFxcIicsIGVuY29kZShrZXkpLCAnXFxcIjogPC9zcGFuPicsICc8c3BhbiBjbGFzcz1cXFwiJywgdHlwZSwgJ1xcXCI+JywgZW5jb2RlKHZhbHVlKSwgJzwvc3Bhbj4nLCAnPC9saT4nXS5qb2luKCcnKTtcXG5cXHRcXHR9XFxuXFx0XFx0cmV0dXJuIFsnPGxpPicsICc8c3BhbiBjbGFzcz1cXFwia2V5XFxcIj5cXFwiJywgZW5jb2RlKGtleSksICdcXFwiOiA8L3NwYW4+JywgJzxzcGFuIGNsYXNzPVxcXCInLCB0eXBlLCAnXFxcIj5cXFwiJywgZW5jb2RlKHZhbHVlKSwgJ1xcXCI8L3NwYW4+JywgJzwvbGk+J10uam9pbignJyk7XFxuXFx0fTtcXG5cXHRcXG5cXHR2YXIganNvbjJodG1sID0gZnVuY3Rpb24ganNvbjJodG1sKGpzb24sIGV4cGFuZGVyQ2xhc3Nlcykge1xcblxcdFxcdHZhciBodG1sID0gJyc7XFxuXFx0XFx0Zm9yICh2YXIga2V5IGluIGpzb24pIHtcXG5cXHRcXHRcXHRpZiAoIWpzb24uaGFzT3duUHJvcGVydHkoa2V5KSkge1xcblxcdFxcdFxcdFxcdGNvbnRpbnVlO1xcblxcdFxcdFxcdH1cXG5cXHRcXG5cXHRcXHRcXHRodG1sID0gW2h0bWwsIGNyZWF0ZUVsZW1lbnQoa2V5LCBqc29uW2tleV0sICgwLCBfdHlwZW9mMy5kZWZhdWx0KShqc29uW2tleV0pLCBleHBhbmRlckNsYXNzZXMpXS5qb2luKCcnKTtcXG5cXHRcXHR9XFxuXFx0XFx0cmV0dXJuIGh0bWw7XFxuXFx0fTtcXG5cXHRcXG5cXHR2YXIgZ2V0SnNvblZpZXdlciA9IGZ1bmN0aW9uIGdldEpzb25WaWV3ZXIoZGF0YSwgb3B0aW9ucykge1xcblxcdFxcdHRyeSB7XFxuXFx0XFx0XFx0cmV0dXJuIFsnPHVsIGNsYXNzPVxcXCInLCBwcmVmaXgsICctY29udGFpbmVyXFxcIj4nLCBqc29uMmh0bWwoW0pTT04ucGFyc2UoZGF0YSldLCBnZXRFeHBhbmRlckNsYXNzZXMob3B0aW9ucy5leHBhbmRlZCkpLCAnPC91bD4nXS5qb2luKCcnKTtcXG5cXHRcXHR9IGNhdGNoIChlKSB7XFxuXFx0XFx0XFx0cmV0dXJuIFsnPGRpdiBjbGFzcz1cXFwiJywgcHJlZml4LCAnLWVycm9yXFxcIiA+JywgZS50b1N0cmluZygpLCAnIDwvZGl2PiddLmpvaW4oJycpO1xcblxcdFxcdH1cXG5cXHR9O1xcblxcdFxcblxcdG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGRhdGEsIG9wdCkge1xcblxcdFxcdHZhciBqc29uID0gJyc7XFxuXFx0XFx0dmFyIG9wdGlvbnMgPSBvcHQgfHwgeyBleHBhbmRlZDogdHJ1ZSB9O1xcblxcdFxcdGlmICh0eXBlb2YgZGF0YSA9PSAnc3RyaW5nJykge1xcblxcdFxcdFxcdGpzb24gPSBkYXRhO1xcblxcdFxcdH0gZWxzZSBpZiAoKHR5cGVvZiBkYXRhID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogKDAsIF90eXBlb2YzLmRlZmF1bHQpKGRhdGEpKSA9PSAnb2JqZWN0Jykge1xcblxcdFxcdFxcdGpzb24gPSAoMCwgX3N0cmluZ2lmeTIuZGVmYXVsdCkoZGF0YSk7XFxuXFx0XFx0fVxcblxcdFxcdHJldHVybiBnZXRKc29uVmlld2VyKGpzb24sIG9wdGlvbnMpO1xcblxcdH07XFxuXFxuLyoqKi8gfSxcXG4vKiAyICovXFxuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XFxuXFxuXFx0bW9kdWxlLmV4cG9ydHMgPSB7IFxcXCJkZWZhdWx0XFxcIjogX193ZWJwYWNrX3JlcXVpcmVfXygzKSwgX19lc01vZHVsZTogdHJ1ZSB9O1xcblxcbi8qKiovIH0sXFxuLyogMyAqL1xcbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xcblxcblxcdHZhciBjb3JlICA9IF9fd2VicGFja19yZXF1aXJlX18oNClcXG5cXHQgICwgJEpTT04gPSBjb3JlLkpTT04gfHwgKGNvcmUuSlNPTiA9IHtzdHJpbmdpZnk6IEpTT04uc3RyaW5naWZ5fSk7XFxuXFx0bW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBzdHJpbmdpZnkoaXQpeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXFxuXFx0ICByZXR1cm4gJEpTT04uc3RyaW5naWZ5LmFwcGx5KCRKU09OLCBhcmd1bWVudHMpO1xcblxcdH07XFxuXFxuLyoqKi8gfSxcXG4vKiA0ICovXFxuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XFxuXFxuXFx0dmFyIGNvcmUgPSBtb2R1bGUuZXhwb3J0cyA9IHt2ZXJzaW9uOiAnMi40LjAnfTtcXG5cXHRpZih0eXBlb2YgX19lID09ICdudW1iZXInKV9fZSA9IGNvcmU7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWZcXG5cXG4vKioqLyB9LFxcbi8qIDUgKi9cXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcXG5cXG5cXHRcXFwidXNlIHN0cmljdFxcXCI7XFxuXFx0XFxuXFx0ZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcXG5cXHRcXG5cXHR2YXIgX2l0ZXJhdG9yID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2KTtcXG5cXHRcXG5cXHR2YXIgX2l0ZXJhdG9yMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2l0ZXJhdG9yKTtcXG5cXHRcXG5cXHR2YXIgX3N5bWJvbCA9IF9fd2VicGFja19yZXF1aXJlX18oNTYpO1xcblxcdFxcblxcdHZhciBfc3ltYm9sMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3N5bWJvbCk7XFxuXFx0XFxuXFx0dmFyIF90eXBlb2YgPSB0eXBlb2YgX3N5bWJvbDIuZGVmYXVsdCA9PT0gXFxcImZ1bmN0aW9uXFxcIiAmJiB0eXBlb2YgX2l0ZXJhdG9yMi5kZWZhdWx0ID09PSBcXFwic3ltYm9sXFxcIiA/IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH0gOiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIF9zeW1ib2wyLmRlZmF1bHQgPT09IFxcXCJmdW5jdGlvblxcXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBfc3ltYm9sMi5kZWZhdWx0ICYmIG9iaiAhPT0gX3N5bWJvbDIuZGVmYXVsdC5wcm90b3R5cGUgPyBcXFwic3ltYm9sXFxcIiA6IHR5cGVvZiBvYmo7IH07XFxuXFx0XFxuXFx0ZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cXG5cXHRcXG5cXHRleHBvcnRzLmRlZmF1bHQgPSB0eXBlb2YgX3N5bWJvbDIuZGVmYXVsdCA9PT0gXFxcImZ1bmN0aW9uXFxcIiAmJiBfdHlwZW9mKF9pdGVyYXRvcjIuZGVmYXVsdCkgPT09IFxcXCJzeW1ib2xcXFwiID8gZnVuY3Rpb24gKG9iaikge1xcblxcdCAgcmV0dXJuIHR5cGVvZiBvYmogPT09IFxcXCJ1bmRlZmluZWRcXFwiID8gXFxcInVuZGVmaW5lZFxcXCIgOiBfdHlwZW9mKG9iaik7XFxuXFx0fSA6IGZ1bmN0aW9uIChvYmopIHtcXG5cXHQgIHJldHVybiBvYmogJiYgdHlwZW9mIF9zeW1ib2wyLmRlZmF1bHQgPT09IFxcXCJmdW5jdGlvblxcXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBfc3ltYm9sMi5kZWZhdWx0ICYmIG9iaiAhPT0gX3N5bWJvbDIuZGVmYXVsdC5wcm90b3R5cGUgPyBcXFwic3ltYm9sXFxcIiA6IHR5cGVvZiBvYmogPT09IFxcXCJ1bmRlZmluZWRcXFwiID8gXFxcInVuZGVmaW5lZFxcXCIgOiBfdHlwZW9mKG9iaik7XFxuXFx0fTtcXG5cXG4vKioqLyB9LFxcbi8qIDYgKi9cXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcXG5cXG5cXHRtb2R1bGUuZXhwb3J0cyA9IHsgXFxcImRlZmF1bHRcXFwiOiBfX3dlYnBhY2tfcmVxdWlyZV9fKDcpLCBfX2VzTW9kdWxlOiB0cnVlIH07XFxuXFxuLyoqKi8gfSxcXG4vKiA3ICovXFxuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XFxuXFxuXFx0X193ZWJwYWNrX3JlcXVpcmVfXyg4KTtcXG5cXHRfX3dlYnBhY2tfcmVxdWlyZV9fKDUxKTtcXG5cXHRtb2R1bGUuZXhwb3J0cyA9IF9fd2VicGFja19yZXF1aXJlX18oNTUpLmYoJ2l0ZXJhdG9yJyk7XFxuXFxuLyoqKi8gfSxcXG4vKiA4ICovXFxuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XFxuXFxuXFx0J3VzZSBzdHJpY3QnO1xcblxcdHZhciAkYXQgID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5KSh0cnVlKTtcXG5cXHRcXG5cXHQvLyAyMS4xLjMuMjcgU3RyaW5nLnByb3RvdHlwZVtAQGl0ZXJhdG9yXSgpXFxuXFx0X193ZWJwYWNrX3JlcXVpcmVfXygxMikoU3RyaW5nLCAnU3RyaW5nJywgZnVuY3Rpb24oaXRlcmF0ZWQpe1xcblxcdCAgdGhpcy5fdCA9IFN0cmluZyhpdGVyYXRlZCk7IC8vIHRhcmdldFxcblxcdCAgdGhpcy5faSA9IDA7ICAgICAgICAgICAgICAgIC8vIG5leHQgaW5kZXhcXG5cXHQvLyAyMS4xLjUuMi4xICVTdHJpbmdJdGVyYXRvclByb3RvdHlwZSUubmV4dCgpXFxuXFx0fSwgZnVuY3Rpb24oKXtcXG5cXHQgIHZhciBPICAgICA9IHRoaXMuX3RcXG5cXHQgICAgLCBpbmRleCA9IHRoaXMuX2lcXG5cXHQgICAgLCBwb2ludDtcXG5cXHQgIGlmKGluZGV4ID49IE8ubGVuZ3RoKXJldHVybiB7dmFsdWU6IHVuZGVmaW5lZCwgZG9uZTogdHJ1ZX07XFxuXFx0ICBwb2ludCA9ICRhdChPLCBpbmRleCk7XFxuXFx0ICB0aGlzLl9pICs9IHBvaW50Lmxlbmd0aDtcXG5cXHQgIHJldHVybiB7dmFsdWU6IHBvaW50LCBkb25lOiBmYWxzZX07XFxuXFx0fSk7XFxuXFxuLyoqKi8gfSxcXG4vKiA5ICovXFxuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XFxuXFxuXFx0dmFyIHRvSW50ZWdlciA9IF9fd2VicGFja19yZXF1aXJlX18oMTApXFxuXFx0ICAsIGRlZmluZWQgICA9IF9fd2VicGFja19yZXF1aXJlX18oMTEpO1xcblxcdC8vIHRydWUgIC0+IFN0cmluZyNhdFxcblxcdC8vIGZhbHNlIC0+IFN0cmluZyNjb2RlUG9pbnRBdFxcblxcdG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oVE9fU1RSSU5HKXtcXG5cXHQgIHJldHVybiBmdW5jdGlvbih0aGF0LCBwb3Mpe1xcblxcdCAgICB2YXIgcyA9IFN0cmluZyhkZWZpbmVkKHRoYXQpKVxcblxcdCAgICAgICwgaSA9IHRvSW50ZWdlcihwb3MpXFxuXFx0ICAgICAgLCBsID0gcy5sZW5ndGhcXG5cXHQgICAgICAsIGEsIGI7XFxuXFx0ICAgIGlmKGkgPCAwIHx8IGkgPj0gbClyZXR1cm4gVE9fU1RSSU5HID8gJycgOiB1bmRlZmluZWQ7XFxuXFx0ICAgIGEgPSBzLmNoYXJDb2RlQXQoaSk7XFxuXFx0ICAgIHJldHVybiBhIDwgMHhkODAwIHx8IGEgPiAweGRiZmYgfHwgaSArIDEgPT09IGwgfHwgKGIgPSBzLmNoYXJDb2RlQXQoaSArIDEpKSA8IDB4ZGMwMCB8fCBiID4gMHhkZmZmXFxuXFx0ICAgICAgPyBUT19TVFJJTkcgPyBzLmNoYXJBdChpKSA6IGFcXG5cXHQgICAgICA6IFRPX1NUUklORyA/IHMuc2xpY2UoaSwgaSArIDIpIDogKGEgLSAweGQ4MDAgPDwgMTApICsgKGIgLSAweGRjMDApICsgMHgxMDAwMDtcXG5cXHQgIH07XFxuXFx0fTtcXG5cXG4vKioqLyB9LFxcbi8qIDEwICovXFxuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XFxuXFxuXFx0Ly8gNy4xLjQgVG9JbnRlZ2VyXFxuXFx0dmFyIGNlaWwgID0gTWF0aC5jZWlsXFxuXFx0ICAsIGZsb29yID0gTWF0aC5mbG9vcjtcXG5cXHRtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KXtcXG5cXHQgIHJldHVybiBpc05hTihpdCA9ICtpdCkgPyAwIDogKGl0ID4gMCA/IGZsb29yIDogY2VpbCkoaXQpO1xcblxcdH07XFxuXFxuLyoqKi8gfSxcXG4vKiAxMSAqL1xcbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xcblxcblxcdC8vIDcuMi4xIFJlcXVpcmVPYmplY3RDb2VyY2libGUoYXJndW1lbnQpXFxuXFx0bW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCl7XFxuXFx0ICBpZihpdCA9PSB1bmRlZmluZWQpdGhyb3cgVHlwZUVycm9yKFxcXCJDYW4ndCBjYWxsIG1ldGhvZCBvbiAgXFxcIiArIGl0KTtcXG5cXHQgIHJldHVybiBpdDtcXG5cXHR9O1xcblxcbi8qKiovIH0sXFxuLyogMTIgKi9cXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcXG5cXG5cXHQndXNlIHN0cmljdCc7XFxuXFx0dmFyIExJQlJBUlkgICAgICAgID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMylcXG5cXHQgICwgJGV4cG9ydCAgICAgICAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE0KVxcblxcdCAgLCByZWRlZmluZSAgICAgICA9IF9fd2VicGFja19yZXF1aXJlX18oMjgpXFxuXFx0ICAsIGhpZGUgICAgICAgICAgID0gX193ZWJwYWNrX3JlcXVpcmVfXygxOClcXG5cXHQgICwgaGFzICAgICAgICAgICAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI5KVxcblxcdCAgLCBJdGVyYXRvcnMgICAgICA9IF9fd2VicGFja19yZXF1aXJlX18oMzApXFxuXFx0ICAsICRpdGVyQ3JlYXRlICAgID0gX193ZWJwYWNrX3JlcXVpcmVfXygzMSlcXG5cXHQgICwgc2V0VG9TdHJpbmdUYWcgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQ3KVxcblxcdCAgLCBnZXRQcm90b3R5cGVPZiA9IF9fd2VicGFja19yZXF1aXJlX18oNDkpXFxuXFx0ICAsIElURVJBVE9SICAgICAgID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0OCkoJ2l0ZXJhdG9yJylcXG5cXHQgICwgQlVHR1kgICAgICAgICAgPSAhKFtdLmtleXMgJiYgJ25leHQnIGluIFtdLmtleXMoKSkgLy8gU2FmYXJpIGhhcyBidWdneSBpdGVyYXRvcnMgdy9vIGBuZXh0YFxcblxcdCAgLCBGRl9JVEVSQVRPUiAgICA9ICdAQGl0ZXJhdG9yJ1xcblxcdCAgLCBLRVlTICAgICAgICAgICA9ICdrZXlzJ1xcblxcdCAgLCBWQUxVRVMgICAgICAgICA9ICd2YWx1ZXMnO1xcblxcdFxcblxcdHZhciByZXR1cm5UaGlzID0gZnVuY3Rpb24oKXsgcmV0dXJuIHRoaXM7IH07XFxuXFx0XFxuXFx0bW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihCYXNlLCBOQU1FLCBDb25zdHJ1Y3RvciwgbmV4dCwgREVGQVVMVCwgSVNfU0VULCBGT1JDRUQpe1xcblxcdCAgJGl0ZXJDcmVhdGUoQ29uc3RydWN0b3IsIE5BTUUsIG5leHQpO1xcblxcdCAgdmFyIGdldE1ldGhvZCA9IGZ1bmN0aW9uKGtpbmQpe1xcblxcdCAgICBpZighQlVHR1kgJiYga2luZCBpbiBwcm90bylyZXR1cm4gcHJvdG9ba2luZF07XFxuXFx0ICAgIHN3aXRjaChraW5kKXtcXG5cXHQgICAgICBjYXNlIEtFWVM6IHJldHVybiBmdW5jdGlvbiBrZXlzKCl7IHJldHVybiBuZXcgQ29uc3RydWN0b3IodGhpcywga2luZCk7IH07XFxuXFx0ICAgICAgY2FzZSBWQUxVRVM6IHJldHVybiBmdW5jdGlvbiB2YWx1ZXMoKXsgcmV0dXJuIG5ldyBDb25zdHJ1Y3Rvcih0aGlzLCBraW5kKTsgfTtcXG5cXHQgICAgfSByZXR1cm4gZnVuY3Rpb24gZW50cmllcygpeyByZXR1cm4gbmV3IENvbnN0cnVjdG9yKHRoaXMsIGtpbmQpOyB9O1xcblxcdCAgfTtcXG5cXHQgIHZhciBUQUcgICAgICAgID0gTkFNRSArICcgSXRlcmF0b3InXFxuXFx0ICAgICwgREVGX1ZBTFVFUyA9IERFRkFVTFQgPT0gVkFMVUVTXFxuXFx0ICAgICwgVkFMVUVTX0JVRyA9IGZhbHNlXFxuXFx0ICAgICwgcHJvdG8gICAgICA9IEJhc2UucHJvdG90eXBlXFxuXFx0ICAgICwgJG5hdGl2ZSAgICA9IHByb3RvW0lURVJBVE9SXSB8fCBwcm90b1tGRl9JVEVSQVRPUl0gfHwgREVGQVVMVCAmJiBwcm90b1tERUZBVUxUXVxcblxcdCAgICAsICRkZWZhdWx0ICAgPSAkbmF0aXZlIHx8IGdldE1ldGhvZChERUZBVUxUKVxcblxcdCAgICAsICRlbnRyaWVzICAgPSBERUZBVUxUID8gIURFRl9WQUxVRVMgPyAkZGVmYXVsdCA6IGdldE1ldGhvZCgnZW50cmllcycpIDogdW5kZWZpbmVkXFxuXFx0ICAgICwgJGFueU5hdGl2ZSA9IE5BTUUgPT0gJ0FycmF5JyA/IHByb3RvLmVudHJpZXMgfHwgJG5hdGl2ZSA6ICRuYXRpdmVcXG5cXHQgICAgLCBtZXRob2RzLCBrZXksIEl0ZXJhdG9yUHJvdG90eXBlO1xcblxcdCAgLy8gRml4IG5hdGl2ZVxcblxcdCAgaWYoJGFueU5hdGl2ZSl7XFxuXFx0ICAgIEl0ZXJhdG9yUHJvdG90eXBlID0gZ2V0UHJvdG90eXBlT2YoJGFueU5hdGl2ZS5jYWxsKG5ldyBCYXNlKSk7XFxuXFx0ICAgIGlmKEl0ZXJhdG9yUHJvdG90eXBlICE9PSBPYmplY3QucHJvdG90eXBlKXtcXG5cXHQgICAgICAvLyBTZXQgQEB0b1N0cmluZ1RhZyB0byBuYXRpdmUgaXRlcmF0b3JzXFxuXFx0ICAgICAgc2V0VG9TdHJpbmdUYWcoSXRlcmF0b3JQcm90b3R5cGUsIFRBRywgdHJ1ZSk7XFxuXFx0ICAgICAgLy8gZml4IGZvciBzb21lIG9sZCBlbmdpbmVzXFxuXFx0ICAgICAgaWYoIUxJQlJBUlkgJiYgIWhhcyhJdGVyYXRvclByb3RvdHlwZSwgSVRFUkFUT1IpKWhpZGUoSXRlcmF0b3JQcm90b3R5cGUsIElURVJBVE9SLCByZXR1cm5UaGlzKTtcXG5cXHQgICAgfVxcblxcdCAgfVxcblxcdCAgLy8gZml4IEFycmF5I3t2YWx1ZXMsIEBAaXRlcmF0b3J9Lm5hbWUgaW4gVjggLyBGRlxcblxcdCAgaWYoREVGX1ZBTFVFUyAmJiAkbmF0aXZlICYmICRuYXRpdmUubmFtZSAhPT0gVkFMVUVTKXtcXG5cXHQgICAgVkFMVUVTX0JVRyA9IHRydWU7XFxuXFx0ICAgICRkZWZhdWx0ID0gZnVuY3Rpb24gdmFsdWVzKCl7IHJldHVybiAkbmF0aXZlLmNhbGwodGhpcyk7IH07XFxuXFx0ICB9XFxuXFx0ICAvLyBEZWZpbmUgaXRlcmF0b3JcXG5cXHQgIGlmKCghTElCUkFSWSB8fCBGT1JDRUQpICYmIChCVUdHWSB8fCBWQUxVRVNfQlVHIHx8ICFwcm90b1tJVEVSQVRPUl0pKXtcXG5cXHQgICAgaGlkZShwcm90bywgSVRFUkFUT1IsICRkZWZhdWx0KTtcXG5cXHQgIH1cXG5cXHQgIC8vIFBsdWcgZm9yIGxpYnJhcnlcXG5cXHQgIEl0ZXJhdG9yc1tOQU1FXSA9ICRkZWZhdWx0O1xcblxcdCAgSXRlcmF0b3JzW1RBR10gID0gcmV0dXJuVGhpcztcXG5cXHQgIGlmKERFRkFVTFQpe1xcblxcdCAgICBtZXRob2RzID0ge1xcblxcdCAgICAgIHZhbHVlczogIERFRl9WQUxVRVMgPyAkZGVmYXVsdCA6IGdldE1ldGhvZChWQUxVRVMpLFxcblxcdCAgICAgIGtleXM6ICAgIElTX1NFVCAgICAgPyAkZGVmYXVsdCA6IGdldE1ldGhvZChLRVlTKSxcXG5cXHQgICAgICBlbnRyaWVzOiAkZW50cmllc1xcblxcdCAgICB9O1xcblxcdCAgICBpZihGT1JDRUQpZm9yKGtleSBpbiBtZXRob2RzKXtcXG5cXHQgICAgICBpZighKGtleSBpbiBwcm90bykpcmVkZWZpbmUocHJvdG8sIGtleSwgbWV0aG9kc1trZXldKTtcXG5cXHQgICAgfSBlbHNlICRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogKEJVR0dZIHx8IFZBTFVFU19CVUcpLCBOQU1FLCBtZXRob2RzKTtcXG5cXHQgIH1cXG5cXHQgIHJldHVybiBtZXRob2RzO1xcblxcdH07XFxuXFxuLyoqKi8gfSxcXG4vKiAxMyAqL1xcbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xcblxcblxcdG1vZHVsZS5leHBvcnRzID0gdHJ1ZTtcXG5cXG4vKioqLyB9LFxcbi8qIDE0ICovXFxuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XFxuXFxuXFx0dmFyIGdsb2JhbCAgICA9IF9fd2VicGFja19yZXF1aXJlX18oMTUpXFxuXFx0ICAsIGNvcmUgICAgICA9IF9fd2VicGFja19yZXF1aXJlX18oNClcXG5cXHQgICwgY3R4ICAgICAgID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNilcXG5cXHQgICwgaGlkZSAgICAgID0gX193ZWJwYWNrX3JlcXVpcmVfXygxOClcXG5cXHQgICwgUFJPVE9UWVBFID0gJ3Byb3RvdHlwZSc7XFxuXFx0XFxuXFx0dmFyICRleHBvcnQgPSBmdW5jdGlvbih0eXBlLCBuYW1lLCBzb3VyY2Upe1xcblxcdCAgdmFyIElTX0ZPUkNFRCA9IHR5cGUgJiAkZXhwb3J0LkZcXG5cXHQgICAgLCBJU19HTE9CQUwgPSB0eXBlICYgJGV4cG9ydC5HXFxuXFx0ICAgICwgSVNfU1RBVElDID0gdHlwZSAmICRleHBvcnQuU1xcblxcdCAgICAsIElTX1BST1RPICA9IHR5cGUgJiAkZXhwb3J0LlBcXG5cXHQgICAgLCBJU19CSU5EICAgPSB0eXBlICYgJGV4cG9ydC5CXFxuXFx0ICAgICwgSVNfV1JBUCAgID0gdHlwZSAmICRleHBvcnQuV1xcblxcdCAgICAsIGV4cG9ydHMgICA9IElTX0dMT0JBTCA/IGNvcmUgOiBjb3JlW25hbWVdIHx8IChjb3JlW25hbWVdID0ge30pXFxuXFx0ICAgICwgZXhwUHJvdG8gID0gZXhwb3J0c1tQUk9UT1RZUEVdXFxuXFx0ICAgICwgdGFyZ2V0ICAgID0gSVNfR0xPQkFMID8gZ2xvYmFsIDogSVNfU1RBVElDID8gZ2xvYmFsW25hbWVdIDogKGdsb2JhbFtuYW1lXSB8fCB7fSlbUFJPVE9UWVBFXVxcblxcdCAgICAsIGtleSwgb3duLCBvdXQ7XFxuXFx0ICBpZihJU19HTE9CQUwpc291cmNlID0gbmFtZTtcXG5cXHQgIGZvcihrZXkgaW4gc291cmNlKXtcXG5cXHQgICAgLy8gY29udGFpbnMgaW4gbmF0aXZlXFxuXFx0ICAgIG93biA9ICFJU19GT1JDRUQgJiYgdGFyZ2V0ICYmIHRhcmdldFtrZXldICE9PSB1bmRlZmluZWQ7XFxuXFx0ICAgIGlmKG93biAmJiBrZXkgaW4gZXhwb3J0cyljb250aW51ZTtcXG5cXHQgICAgLy8gZXhwb3J0IG5hdGl2ZSBvciBwYXNzZWRcXG5cXHQgICAgb3V0ID0gb3duID8gdGFyZ2V0W2tleV0gOiBzb3VyY2Vba2V5XTtcXG5cXHQgICAgLy8gcHJldmVudCBnbG9iYWwgcG9sbHV0aW9uIGZvciBuYW1lc3BhY2VzXFxuXFx0ICAgIGV4cG9ydHNba2V5XSA9IElTX0dMT0JBTCAmJiB0eXBlb2YgdGFyZ2V0W2tleV0gIT0gJ2Z1bmN0aW9uJyA/IHNvdXJjZVtrZXldXFxuXFx0ICAgIC8vIGJpbmQgdGltZXJzIHRvIGdsb2JhbCBmb3IgY2FsbCBmcm9tIGV4cG9ydCBjb250ZXh0XFxuXFx0ICAgIDogSVNfQklORCAmJiBvd24gPyBjdHgob3V0LCBnbG9iYWwpXFxuXFx0ICAgIC8vIHdyYXAgZ2xvYmFsIGNvbnN0cnVjdG9ycyBmb3IgcHJldmVudCBjaGFuZ2UgdGhlbSBpbiBsaWJyYXJ5XFxuXFx0ICAgIDogSVNfV1JBUCAmJiB0YXJnZXRba2V5XSA9PSBvdXQgPyAoZnVuY3Rpb24oQyl7XFxuXFx0ICAgICAgdmFyIEYgPSBmdW5jdGlvbihhLCBiLCBjKXtcXG5cXHQgICAgICAgIGlmKHRoaXMgaW5zdGFuY2VvZiBDKXtcXG5cXHQgICAgICAgICAgc3dpdGNoKGFyZ3VtZW50cy5sZW5ndGgpe1xcblxcdCAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIG5ldyBDO1xcblxcdCAgICAgICAgICAgIGNhc2UgMTogcmV0dXJuIG5ldyBDKGEpO1xcblxcdCAgICAgICAgICAgIGNhc2UgMjogcmV0dXJuIG5ldyBDKGEsIGIpO1xcblxcdCAgICAgICAgICB9IHJldHVybiBuZXcgQyhhLCBiLCBjKTtcXG5cXHQgICAgICAgIH0gcmV0dXJuIEMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcXG5cXHQgICAgICB9O1xcblxcdCAgICAgIEZbUFJPVE9UWVBFXSA9IENbUFJPVE9UWVBFXTtcXG5cXHQgICAgICByZXR1cm4gRjtcXG5cXHQgICAgLy8gbWFrZSBzdGF0aWMgdmVyc2lvbnMgZm9yIHByb3RvdHlwZSBtZXRob2RzXFxuXFx0ICAgIH0pKG91dCkgOiBJU19QUk9UTyAmJiB0eXBlb2Ygb3V0ID09ICdmdW5jdGlvbicgPyBjdHgoRnVuY3Rpb24uY2FsbCwgb3V0KSA6IG91dDtcXG5cXHQgICAgLy8gZXhwb3J0IHByb3RvIG1ldGhvZHMgdG8gY29yZS4lQ09OU1RSVUNUT1IlLm1ldGhvZHMuJU5BTUUlXFxuXFx0ICAgIGlmKElTX1BST1RPKXtcXG5cXHQgICAgICAoZXhwb3J0cy52aXJ0dWFsIHx8IChleHBvcnRzLnZpcnR1YWwgPSB7fSkpW2tleV0gPSBvdXQ7XFxuXFx0ICAgICAgLy8gZXhwb3J0IHByb3RvIG1ldGhvZHMgdG8gY29yZS4lQ09OU1RSVUNUT1IlLnByb3RvdHlwZS4lTkFNRSVcXG5cXHQgICAgICBpZih0eXBlICYgJGV4cG9ydC5SICYmIGV4cFByb3RvICYmICFleHBQcm90b1trZXldKWhpZGUoZXhwUHJvdG8sIGtleSwgb3V0KTtcXG5cXHQgICAgfVxcblxcdCAgfVxcblxcdH07XFxuXFx0Ly8gdHlwZSBiaXRtYXBcXG5cXHQkZXhwb3J0LkYgPSAxOyAgIC8vIGZvcmNlZFxcblxcdCRleHBvcnQuRyA9IDI7ICAgLy8gZ2xvYmFsXFxuXFx0JGV4cG9ydC5TID0gNDsgICAvLyBzdGF0aWNcXG5cXHQkZXhwb3J0LlAgPSA4OyAgIC8vIHByb3RvXFxuXFx0JGV4cG9ydC5CID0gMTY7ICAvLyBiaW5kXFxuXFx0JGV4cG9ydC5XID0gMzI7ICAvLyB3cmFwXFxuXFx0JGV4cG9ydC5VID0gNjQ7ICAvLyBzYWZlXFxuXFx0JGV4cG9ydC5SID0gMTI4OyAvLyByZWFsIHByb3RvIG1ldGhvZCBmb3IgYGxpYnJhcnlgIFxcblxcdG1vZHVsZS5leHBvcnRzID0gJGV4cG9ydDtcXG5cXG4vKioqLyB9LFxcbi8qIDE1ICovXFxuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XFxuXFxuXFx0Ly8gaHR0cHM6Ly9naXRodWIuY29tL3psb2lyb2NrL2NvcmUtanMvaXNzdWVzLzg2I2lzc3VlY29tbWVudC0xMTU3NTkwMjhcXG5cXHR2YXIgZ2xvYmFsID0gbW9kdWxlLmV4cG9ydHMgPSB0eXBlb2Ygd2luZG93ICE9ICd1bmRlZmluZWQnICYmIHdpbmRvdy5NYXRoID09IE1hdGhcXG5cXHQgID8gd2luZG93IDogdHlwZW9mIHNlbGYgIT0gJ3VuZGVmaW5lZCcgJiYgc2VsZi5NYXRoID09IE1hdGggPyBzZWxmIDogRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKTtcXG5cXHRpZih0eXBlb2YgX19nID09ICdudW1iZXInKV9fZyA9IGdsb2JhbDsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZlxcblxcbi8qKiovIH0sXFxuLyogMTYgKi9cXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcXG5cXG5cXHQvLyBvcHRpb25hbCAvIHNpbXBsZSBjb250ZXh0IGJpbmRpbmdcXG5cXHR2YXIgYUZ1bmN0aW9uID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNyk7XFxuXFx0bW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihmbiwgdGhhdCwgbGVuZ3RoKXtcXG5cXHQgIGFGdW5jdGlvbihmbik7XFxuXFx0ICBpZih0aGF0ID09PSB1bmRlZmluZWQpcmV0dXJuIGZuO1xcblxcdCAgc3dpdGNoKGxlbmd0aCl7XFxuXFx0ICAgIGNhc2UgMTogcmV0dXJuIGZ1bmN0aW9uKGEpe1xcblxcdCAgICAgIHJldHVybiBmbi5jYWxsKHRoYXQsIGEpO1xcblxcdCAgICB9O1xcblxcdCAgICBjYXNlIDI6IHJldHVybiBmdW5jdGlvbihhLCBiKXtcXG5cXHQgICAgICByZXR1cm4gZm4uY2FsbCh0aGF0LCBhLCBiKTtcXG5cXHQgICAgfTtcXG5cXHQgICAgY2FzZSAzOiByZXR1cm4gZnVuY3Rpb24oYSwgYiwgYyl7XFxuXFx0ICAgICAgcmV0dXJuIGZuLmNhbGwodGhhdCwgYSwgYiwgYyk7XFxuXFx0ICAgIH07XFxuXFx0ICB9XFxuXFx0ICByZXR1cm4gZnVuY3Rpb24oLyogLi4uYXJncyAqLyl7XFxuXFx0ICAgIHJldHVybiBmbi5hcHBseSh0aGF0LCBhcmd1bWVudHMpO1xcblxcdCAgfTtcXG5cXHR9O1xcblxcbi8qKiovIH0sXFxuLyogMTcgKi9cXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcXG5cXG5cXHRtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KXtcXG5cXHQgIGlmKHR5cGVvZiBpdCAhPSAnZnVuY3Rpb24nKXRocm93IFR5cGVFcnJvcihpdCArICcgaXMgbm90IGEgZnVuY3Rpb24hJyk7XFxuXFx0ICByZXR1cm4gaXQ7XFxuXFx0fTtcXG5cXG4vKioqLyB9LFxcbi8qIDE4ICovXFxuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XFxuXFxuXFx0dmFyIGRQICAgICAgICAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE5KVxcblxcdCAgLCBjcmVhdGVEZXNjID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNyk7XFxuXFx0bW9kdWxlLmV4cG9ydHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIzKSA/IGZ1bmN0aW9uKG9iamVjdCwga2V5LCB2YWx1ZSl7XFxuXFx0ICByZXR1cm4gZFAuZihvYmplY3QsIGtleSwgY3JlYXRlRGVzYygxLCB2YWx1ZSkpO1xcblxcdH0gOiBmdW5jdGlvbihvYmplY3QsIGtleSwgdmFsdWUpe1xcblxcdCAgb2JqZWN0W2tleV0gPSB2YWx1ZTtcXG5cXHQgIHJldHVybiBvYmplY3Q7XFxuXFx0fTtcXG5cXG4vKioqLyB9LFxcbi8qIDE5ICovXFxuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XFxuXFxuXFx0dmFyIGFuT2JqZWN0ICAgICAgID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMClcXG5cXHQgICwgSUU4X0RPTV9ERUZJTkUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIyKVxcblxcdCAgLCB0b1ByaW1pdGl2ZSAgICA9IF9fd2VicGFja19yZXF1aXJlX18oMjYpXFxuXFx0ICAsIGRQICAgICAgICAgICAgID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xcblxcdFxcblxcdGV4cG9ydHMuZiA9IF9fd2VicGFja19yZXF1aXJlX18oMjMpID8gT2JqZWN0LmRlZmluZVByb3BlcnR5IDogZnVuY3Rpb24gZGVmaW5lUHJvcGVydHkoTywgUCwgQXR0cmlidXRlcyl7XFxuXFx0ICBhbk9iamVjdChPKTtcXG5cXHQgIFAgPSB0b1ByaW1pdGl2ZShQLCB0cnVlKTtcXG5cXHQgIGFuT2JqZWN0KEF0dHJpYnV0ZXMpO1xcblxcdCAgaWYoSUU4X0RPTV9ERUZJTkUpdHJ5IHtcXG5cXHQgICAgcmV0dXJuIGRQKE8sIFAsIEF0dHJpYnV0ZXMpO1xcblxcdCAgfSBjYXRjaChlKXsgLyogZW1wdHkgKi8gfVxcblxcdCAgaWYoJ2dldCcgaW4gQXR0cmlidXRlcyB8fCAnc2V0JyBpbiBBdHRyaWJ1dGVzKXRocm93IFR5cGVFcnJvcignQWNjZXNzb3JzIG5vdCBzdXBwb3J0ZWQhJyk7XFxuXFx0ICBpZigndmFsdWUnIGluIEF0dHJpYnV0ZXMpT1tQXSA9IEF0dHJpYnV0ZXMudmFsdWU7XFxuXFx0ICByZXR1cm4gTztcXG5cXHR9O1xcblxcbi8qKiovIH0sXFxuLyogMjAgKi9cXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcXG5cXG5cXHR2YXIgaXNPYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIxKTtcXG5cXHRtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KXtcXG5cXHQgIGlmKCFpc09iamVjdChpdCkpdGhyb3cgVHlwZUVycm9yKGl0ICsgJyBpcyBub3QgYW4gb2JqZWN0IScpO1xcblxcdCAgcmV0dXJuIGl0O1xcblxcdH07XFxuXFxuLyoqKi8gfSxcXG4vKiAyMSAqL1xcbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xcblxcblxcdG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQpe1xcblxcdCAgcmV0dXJuIHR5cGVvZiBpdCA9PT0gJ29iamVjdCcgPyBpdCAhPT0gbnVsbCA6IHR5cGVvZiBpdCA9PT0gJ2Z1bmN0aW9uJztcXG5cXHR9O1xcblxcbi8qKiovIH0sXFxuLyogMjIgKi9cXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcXG5cXG5cXHRtb2R1bGUuZXhwb3J0cyA9ICFfX3dlYnBhY2tfcmVxdWlyZV9fKDIzKSAmJiAhX193ZWJwYWNrX3JlcXVpcmVfXygyNCkoZnVuY3Rpb24oKXtcXHJcXG5cXHQgIHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkoX193ZWJwYWNrX3JlcXVpcmVfXygyNSkoJ2RpdicpLCAnYScsIHtnZXQ6IGZ1bmN0aW9uKCl7IHJldHVybiA3OyB9fSkuYSAhPSA3O1xcclxcblxcdH0pO1xcblxcbi8qKiovIH0sXFxuLyogMjMgKi9cXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcXG5cXG5cXHQvLyBUaGFuaydzIElFOCBmb3IgaGlzIGZ1bm55IGRlZmluZVByb3BlcnR5XFxuXFx0bW9kdWxlLmV4cG9ydHMgPSAhX193ZWJwYWNrX3JlcXVpcmVfXygyNCkoZnVuY3Rpb24oKXtcXG5cXHQgIHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkoe30sICdhJywge2dldDogZnVuY3Rpb24oKXsgcmV0dXJuIDc7IH19KS5hICE9IDc7XFxuXFx0fSk7XFxuXFxuLyoqKi8gfSxcXG4vKiAyNCAqL1xcbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xcblxcblxcdG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oZXhlYyl7XFxuXFx0ICB0cnkge1xcblxcdCAgICByZXR1cm4gISFleGVjKCk7XFxuXFx0ICB9IGNhdGNoKGUpe1xcblxcdCAgICByZXR1cm4gdHJ1ZTtcXG5cXHQgIH1cXG5cXHR9O1xcblxcbi8qKiovIH0sXFxuLyogMjUgKi9cXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcXG5cXG5cXHR2YXIgaXNPYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIxKVxcblxcdCAgLCBkb2N1bWVudCA9IF9fd2VicGFja19yZXF1aXJlX18oMTUpLmRvY3VtZW50XFxuXFx0ICAvLyBpbiBvbGQgSUUgdHlwZW9mIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQgaXMgJ29iamVjdCdcXG5cXHQgICwgaXMgPSBpc09iamVjdChkb2N1bWVudCkgJiYgaXNPYmplY3QoZG9jdW1lbnQuY3JlYXRlRWxlbWVudCk7XFxuXFx0bW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCl7XFxuXFx0ICByZXR1cm4gaXMgPyBkb2N1bWVudC5jcmVhdGVFbGVtZW50KGl0KSA6IHt9O1xcblxcdH07XFxuXFxuLyoqKi8gfSxcXG4vKiAyNiAqL1xcbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xcblxcblxcdC8vIDcuMS4xIFRvUHJpbWl0aXZlKGlucHV0IFssIFByZWZlcnJlZFR5cGVdKVxcblxcdHZhciBpc09iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oMjEpO1xcblxcdC8vIGluc3RlYWQgb2YgdGhlIEVTNiBzcGVjIHZlcnNpb24sIHdlIGRpZG4ndCBpbXBsZW1lbnQgQEB0b1ByaW1pdGl2ZSBjYXNlXFxuXFx0Ly8gYW5kIHRoZSBzZWNvbmQgYXJndW1lbnQgLSBmbGFnIC0gcHJlZmVycmVkIHR5cGUgaXMgYSBzdHJpbmdcXG5cXHRtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0LCBTKXtcXG5cXHQgIGlmKCFpc09iamVjdChpdCkpcmV0dXJuIGl0O1xcblxcdCAgdmFyIGZuLCB2YWw7XFxuXFx0ICBpZihTICYmIHR5cGVvZiAoZm4gPSBpdC50b1N0cmluZykgPT0gJ2Z1bmN0aW9uJyAmJiAhaXNPYmplY3QodmFsID0gZm4uY2FsbChpdCkpKXJldHVybiB2YWw7XFxuXFx0ICBpZih0eXBlb2YgKGZuID0gaXQudmFsdWVPZikgPT0gJ2Z1bmN0aW9uJyAmJiAhaXNPYmplY3QodmFsID0gZm4uY2FsbChpdCkpKXJldHVybiB2YWw7XFxuXFx0ICBpZighUyAmJiB0eXBlb2YgKGZuID0gaXQudG9TdHJpbmcpID09ICdmdW5jdGlvbicgJiYgIWlzT2JqZWN0KHZhbCA9IGZuLmNhbGwoaXQpKSlyZXR1cm4gdmFsO1xcblxcdCAgdGhyb3cgVHlwZUVycm9yKFxcXCJDYW4ndCBjb252ZXJ0IG9iamVjdCB0byBwcmltaXRpdmUgdmFsdWVcXFwiKTtcXG5cXHR9O1xcblxcbi8qKiovIH0sXFxuLyogMjcgKi9cXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcXG5cXG5cXHRtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGJpdG1hcCwgdmFsdWUpe1xcblxcdCAgcmV0dXJuIHtcXG5cXHQgICAgZW51bWVyYWJsZSAgOiAhKGJpdG1hcCAmIDEpLFxcblxcdCAgICBjb25maWd1cmFibGU6ICEoYml0bWFwICYgMiksXFxuXFx0ICAgIHdyaXRhYmxlICAgIDogIShiaXRtYXAgJiA0KSxcXG5cXHQgICAgdmFsdWUgICAgICAgOiB2YWx1ZVxcblxcdCAgfTtcXG5cXHR9O1xcblxcbi8qKiovIH0sXFxuLyogMjggKi9cXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcXG5cXG5cXHRtb2R1bGUuZXhwb3J0cyA9IF9fd2VicGFja19yZXF1aXJlX18oMTgpO1xcblxcbi8qKiovIH0sXFxuLyogMjkgKi9cXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcXG5cXG5cXHR2YXIgaGFzT3duUHJvcGVydHkgPSB7fS5oYXNPd25Qcm9wZXJ0eTtcXG5cXHRtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0LCBrZXkpe1xcblxcdCAgcmV0dXJuIGhhc093blByb3BlcnR5LmNhbGwoaXQsIGtleSk7XFxuXFx0fTtcXG5cXG4vKioqLyB9LFxcbi8qIDMwICovXFxuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XFxuXFxuXFx0bW9kdWxlLmV4cG9ydHMgPSB7fTtcXG5cXG4vKioqLyB9LFxcbi8qIDMxICovXFxuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XFxuXFxuXFx0J3VzZSBzdHJpY3QnO1xcblxcdHZhciBjcmVhdGUgICAgICAgICA9IF9fd2VicGFja19yZXF1aXJlX18oMzIpXFxuXFx0ICAsIGRlc2NyaXB0b3IgICAgID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNylcXG5cXHQgICwgc2V0VG9TdHJpbmdUYWcgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQ3KVxcblxcdCAgLCBJdGVyYXRvclByb3RvdHlwZSA9IHt9O1xcblxcdFxcblxcdC8vIDI1LjEuMi4xLjEgJUl0ZXJhdG9yUHJvdG90eXBlJVtAQGl0ZXJhdG9yXSgpXFxuXFx0X193ZWJwYWNrX3JlcXVpcmVfXygxOCkoSXRlcmF0b3JQcm90b3R5cGUsIF9fd2VicGFja19yZXF1aXJlX18oNDgpKCdpdGVyYXRvcicpLCBmdW5jdGlvbigpeyByZXR1cm4gdGhpczsgfSk7XFxuXFx0XFxuXFx0bW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihDb25zdHJ1Y3RvciwgTkFNRSwgbmV4dCl7XFxuXFx0ICBDb25zdHJ1Y3Rvci5wcm90b3R5cGUgPSBjcmVhdGUoSXRlcmF0b3JQcm90b3R5cGUsIHtuZXh0OiBkZXNjcmlwdG9yKDEsIG5leHQpfSk7XFxuXFx0ICBzZXRUb1N0cmluZ1RhZyhDb25zdHJ1Y3RvciwgTkFNRSArICcgSXRlcmF0b3InKTtcXG5cXHR9O1xcblxcbi8qKiovIH0sXFxuLyogMzIgKi9cXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcXG5cXG5cXHQvLyAxOS4xLjIuMiAvIDE1LjIuMy41IE9iamVjdC5jcmVhdGUoTyBbLCBQcm9wZXJ0aWVzXSlcXHJcXG5cXHR2YXIgYW5PYmplY3QgICAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIwKVxcclxcblxcdCAgLCBkUHMgICAgICAgICA9IF9fd2VicGFja19yZXF1aXJlX18oMzMpXFxyXFxuXFx0ICAsIGVudW1CdWdLZXlzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0NSlcXHJcXG5cXHQgICwgSUVfUFJPVE8gICAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQyKSgnSUVfUFJPVE8nKVxcclxcblxcdCAgLCBFbXB0eSAgICAgICA9IGZ1bmN0aW9uKCl7IC8qIGVtcHR5ICovIH1cXHJcXG5cXHQgICwgUFJPVE9UWVBFICAgPSAncHJvdG90eXBlJztcXHJcXG5cXHRcXHJcXG5cXHQvLyBDcmVhdGUgb2JqZWN0IHdpdGggZmFrZSBgbnVsbGAgcHJvdG90eXBlOiB1c2UgaWZyYW1lIE9iamVjdCB3aXRoIGNsZWFyZWQgcHJvdG90eXBlXFxyXFxuXFx0dmFyIGNyZWF0ZURpY3QgPSBmdW5jdGlvbigpe1xcclxcblxcdCAgLy8gVGhyYXNoLCB3YXN0ZSBhbmQgc29kb215OiBJRSBHQyBidWdcXHJcXG5cXHQgIHZhciBpZnJhbWUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI1KSgnaWZyYW1lJylcXHJcXG5cXHQgICAgLCBpICAgICAgPSBlbnVtQnVnS2V5cy5sZW5ndGhcXHJcXG5cXHQgICAgLCBndCAgICAgPSAnPidcXHJcXG5cXHQgICAgLCBpZnJhbWVEb2N1bWVudDtcXHJcXG5cXHQgIGlmcmFtZS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xcclxcblxcdCAgX193ZWJwYWNrX3JlcXVpcmVfXyg0NikuYXBwZW5kQ2hpbGQoaWZyYW1lKTtcXHJcXG5cXHQgIGlmcmFtZS5zcmMgPSAnamF2YXNjcmlwdDonOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXNjcmlwdC11cmxcXHJcXG5cXHQgIC8vIGNyZWF0ZURpY3QgPSBpZnJhbWUuY29udGVudFdpbmRvdy5PYmplY3Q7XFxyXFxuXFx0ICAvLyBodG1sLnJlbW92ZUNoaWxkKGlmcmFtZSk7XFxyXFxuXFx0ICBpZnJhbWVEb2N1bWVudCA9IGlmcmFtZS5jb250ZW50V2luZG93LmRvY3VtZW50O1xcclxcblxcdCAgaWZyYW1lRG9jdW1lbnQub3BlbigpO1xcclxcblxcdCAgaWZyYW1lRG9jdW1lbnQud3JpdGUoJzxzY3JpcHQ+ZG9jdW1lbnQuRj1PYmplY3Q8L3NjcmlwdCcgKyBndCk7XFxyXFxuXFx0ICBpZnJhbWVEb2N1bWVudC5jbG9zZSgpO1xcclxcblxcdCAgY3JlYXRlRGljdCA9IGlmcmFtZURvY3VtZW50LkY7XFxyXFxuXFx0ICB3aGlsZShpLS0pZGVsZXRlIGNyZWF0ZURpY3RbUFJPVE9UWVBFXVtlbnVtQnVnS2V5c1tpXV07XFxyXFxuXFx0ICByZXR1cm4gY3JlYXRlRGljdCgpO1xcclxcblxcdH07XFxyXFxuXFx0XFxyXFxuXFx0bW9kdWxlLmV4cG9ydHMgPSBPYmplY3QuY3JlYXRlIHx8IGZ1bmN0aW9uIGNyZWF0ZShPLCBQcm9wZXJ0aWVzKXtcXHJcXG5cXHQgIHZhciByZXN1bHQ7XFxyXFxuXFx0ICBpZihPICE9PSBudWxsKXtcXHJcXG5cXHQgICAgRW1wdHlbUFJPVE9UWVBFXSA9IGFuT2JqZWN0KE8pO1xcclxcblxcdCAgICByZXN1bHQgPSBuZXcgRW1wdHk7XFxyXFxuXFx0ICAgIEVtcHR5W1BST1RPVFlQRV0gPSBudWxsO1xcclxcblxcdCAgICAvLyBhZGQgXFxcIl9fcHJvdG9fX1xcXCIgZm9yIE9iamVjdC5nZXRQcm90b3R5cGVPZiBwb2x5ZmlsbFxcclxcblxcdCAgICByZXN1bHRbSUVfUFJPVE9dID0gTztcXHJcXG5cXHQgIH0gZWxzZSByZXN1bHQgPSBjcmVhdGVEaWN0KCk7XFxyXFxuXFx0ICByZXR1cm4gUHJvcGVydGllcyA9PT0gdW5kZWZpbmVkID8gcmVzdWx0IDogZFBzKHJlc3VsdCwgUHJvcGVydGllcyk7XFxyXFxuXFx0fTtcXG5cXG4vKioqLyB9LFxcbi8qIDMzICovXFxuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XFxuXFxuXFx0dmFyIGRQICAgICAgID0gX193ZWJwYWNrX3JlcXVpcmVfXygxOSlcXHJcXG5cXHQgICwgYW5PYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIwKVxcclxcblxcdCAgLCBnZXRLZXlzICA9IF9fd2VicGFja19yZXF1aXJlX18oMzQpO1xcclxcblxcdFxcclxcblxcdG1vZHVsZS5leHBvcnRzID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMykgPyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyA6IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXMoTywgUHJvcGVydGllcyl7XFxyXFxuXFx0ICBhbk9iamVjdChPKTtcXHJcXG5cXHQgIHZhciBrZXlzICAgPSBnZXRLZXlzKFByb3BlcnRpZXMpXFxyXFxuXFx0ICAgICwgbGVuZ3RoID0ga2V5cy5sZW5ndGhcXHJcXG5cXHQgICAgLCBpID0gMFxcclxcblxcdCAgICAsIFA7XFxyXFxuXFx0ICB3aGlsZShsZW5ndGggPiBpKWRQLmYoTywgUCA9IGtleXNbaSsrXSwgUHJvcGVydGllc1tQXSk7XFxyXFxuXFx0ICByZXR1cm4gTztcXHJcXG5cXHR9O1xcblxcbi8qKiovIH0sXFxuLyogMzQgKi9cXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcXG5cXG5cXHQvLyAxOS4xLjIuMTQgLyAxNS4yLjMuMTQgT2JqZWN0LmtleXMoTylcXHJcXG5cXHR2YXIgJGtleXMgICAgICAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM1KVxcclxcblxcdCAgLCBlbnVtQnVnS2V5cyA9IF9fd2VicGFja19yZXF1aXJlX18oNDUpO1xcclxcblxcdFxcclxcblxcdG1vZHVsZS5leHBvcnRzID0gT2JqZWN0LmtleXMgfHwgZnVuY3Rpb24ga2V5cyhPKXtcXHJcXG5cXHQgIHJldHVybiAka2V5cyhPLCBlbnVtQnVnS2V5cyk7XFxyXFxuXFx0fTtcXG5cXG4vKioqLyB9LFxcbi8qIDM1ICovXFxuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XFxuXFxuXFx0dmFyIGhhcyAgICAgICAgICA9IF9fd2VicGFja19yZXF1aXJlX18oMjkpXFxyXFxuXFx0ICAsIHRvSU9iamVjdCAgICA9IF9fd2VicGFja19yZXF1aXJlX18oMzYpXFxyXFxuXFx0ICAsIGFycmF5SW5kZXhPZiA9IF9fd2VicGFja19yZXF1aXJlX18oMzkpKGZhbHNlKVxcclxcblxcdCAgLCBJRV9QUk9UTyAgICAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQyKSgnSUVfUFJPVE8nKTtcXHJcXG5cXHRcXHJcXG5cXHRtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG9iamVjdCwgbmFtZXMpe1xcclxcblxcdCAgdmFyIE8gICAgICA9IHRvSU9iamVjdChvYmplY3QpXFxyXFxuXFx0ICAgICwgaSAgICAgID0gMFxcclxcblxcdCAgICAsIHJlc3VsdCA9IFtdXFxyXFxuXFx0ICAgICwga2V5O1xcclxcblxcdCAgZm9yKGtleSBpbiBPKWlmKGtleSAhPSBJRV9QUk9UTyloYXMoTywga2V5KSAmJiByZXN1bHQucHVzaChrZXkpO1xcclxcblxcdCAgLy8gRG9uJ3QgZW51bSBidWcgJiBoaWRkZW4ga2V5c1xcclxcblxcdCAgd2hpbGUobmFtZXMubGVuZ3RoID4gaSlpZihoYXMoTywga2V5ID0gbmFtZXNbaSsrXSkpe1xcclxcblxcdCAgICB+YXJyYXlJbmRleE9mKHJlc3VsdCwga2V5KSB8fCByZXN1bHQucHVzaChrZXkpO1xcclxcblxcdCAgfVxcclxcblxcdCAgcmV0dXJuIHJlc3VsdDtcXHJcXG5cXHR9O1xcblxcbi8qKiovIH0sXFxuLyogMzYgKi9cXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcXG5cXG5cXHQvLyB0byBpbmRleGVkIG9iamVjdCwgdG9PYmplY3Qgd2l0aCBmYWxsYmFjayBmb3Igbm9uLWFycmF5LWxpa2UgRVMzIHN0cmluZ3NcXG5cXHR2YXIgSU9iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oMzcpXFxuXFx0ICAsIGRlZmluZWQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDExKTtcXG5cXHRtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KXtcXG5cXHQgIHJldHVybiBJT2JqZWN0KGRlZmluZWQoaXQpKTtcXG5cXHR9O1xcblxcbi8qKiovIH0sXFxuLyogMzcgKi9cXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcXG5cXG5cXHQvLyBmYWxsYmFjayBmb3Igbm9uLWFycmF5LWxpa2UgRVMzIGFuZCBub24tZW51bWVyYWJsZSBvbGQgVjggc3RyaW5nc1xcblxcdHZhciBjb2YgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM4KTtcXG5cXHRtb2R1bGUuZXhwb3J0cyA9IE9iamVjdCgneicpLnByb3BlcnR5SXNFbnVtZXJhYmxlKDApID8gT2JqZWN0IDogZnVuY3Rpb24oaXQpe1xcblxcdCAgcmV0dXJuIGNvZihpdCkgPT0gJ1N0cmluZycgPyBpdC5zcGxpdCgnJykgOiBPYmplY3QoaXQpO1xcblxcdH07XFxuXFxuLyoqKi8gfSxcXG4vKiAzOCAqL1xcbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xcblxcblxcdHZhciB0b1N0cmluZyA9IHt9LnRvU3RyaW5nO1xcblxcdFxcblxcdG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQpe1xcblxcdCAgcmV0dXJuIHRvU3RyaW5nLmNhbGwoaXQpLnNsaWNlKDgsIC0xKTtcXG5cXHR9O1xcblxcbi8qKiovIH0sXFxuLyogMzkgKi9cXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcXG5cXG5cXHQvLyBmYWxzZSAtPiBBcnJheSNpbmRleE9mXFxuXFx0Ly8gdHJ1ZSAgLT4gQXJyYXkjaW5jbHVkZXNcXG5cXHR2YXIgdG9JT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygzNilcXG5cXHQgICwgdG9MZW5ndGggID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0MClcXG5cXHQgICwgdG9JbmRleCAgID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0MSk7XFxuXFx0bW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihJU19JTkNMVURFUyl7XFxuXFx0ICByZXR1cm4gZnVuY3Rpb24oJHRoaXMsIGVsLCBmcm9tSW5kZXgpe1xcblxcdCAgICB2YXIgTyAgICAgID0gdG9JT2JqZWN0KCR0aGlzKVxcblxcdCAgICAgICwgbGVuZ3RoID0gdG9MZW5ndGgoTy5sZW5ndGgpXFxuXFx0ICAgICAgLCBpbmRleCAgPSB0b0luZGV4KGZyb21JbmRleCwgbGVuZ3RoKVxcblxcdCAgICAgICwgdmFsdWU7XFxuXFx0ICAgIC8vIEFycmF5I2luY2x1ZGVzIHVzZXMgU2FtZVZhbHVlWmVybyBlcXVhbGl0eSBhbGdvcml0aG1cXG5cXHQgICAgaWYoSVNfSU5DTFVERVMgJiYgZWwgIT0gZWwpd2hpbGUobGVuZ3RoID4gaW5kZXgpe1xcblxcdCAgICAgIHZhbHVlID0gT1tpbmRleCsrXTtcXG5cXHQgICAgICBpZih2YWx1ZSAhPSB2YWx1ZSlyZXR1cm4gdHJ1ZTtcXG5cXHQgICAgLy8gQXJyYXkjdG9JbmRleCBpZ25vcmVzIGhvbGVzLCBBcnJheSNpbmNsdWRlcyAtIG5vdFxcblxcdCAgICB9IGVsc2UgZm9yKDtsZW5ndGggPiBpbmRleDsgaW5kZXgrKylpZihJU19JTkNMVURFUyB8fCBpbmRleCBpbiBPKXtcXG5cXHQgICAgICBpZihPW2luZGV4XSA9PT0gZWwpcmV0dXJuIElTX0lOQ0xVREVTIHx8IGluZGV4IHx8IDA7XFxuXFx0ICAgIH0gcmV0dXJuICFJU19JTkNMVURFUyAmJiAtMTtcXG5cXHQgIH07XFxuXFx0fTtcXG5cXG4vKioqLyB9LFxcbi8qIDQwICovXFxuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XFxuXFxuXFx0Ly8gNy4xLjE1IFRvTGVuZ3RoXFxuXFx0dmFyIHRvSW50ZWdlciA9IF9fd2VicGFja19yZXF1aXJlX18oMTApXFxuXFx0ICAsIG1pbiAgICAgICA9IE1hdGgubWluO1xcblxcdG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQpe1xcblxcdCAgcmV0dXJuIGl0ID4gMCA/IG1pbih0b0ludGVnZXIoaXQpLCAweDFmZmZmZmZmZmZmZmZmKSA6IDA7IC8vIHBvdygyLCA1MykgLSAxID09IDkwMDcxOTkyNTQ3NDA5OTFcXG5cXHR9O1xcblxcbi8qKiovIH0sXFxuLyogNDEgKi9cXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcXG5cXG5cXHR2YXIgdG9JbnRlZ2VyID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMClcXG5cXHQgICwgbWF4ICAgICAgID0gTWF0aC5tYXhcXG5cXHQgICwgbWluICAgICAgID0gTWF0aC5taW47XFxuXFx0bW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpbmRleCwgbGVuZ3RoKXtcXG5cXHQgIGluZGV4ID0gdG9JbnRlZ2VyKGluZGV4KTtcXG5cXHQgIHJldHVybiBpbmRleCA8IDAgPyBtYXgoaW5kZXggKyBsZW5ndGgsIDApIDogbWluKGluZGV4LCBsZW5ndGgpO1xcblxcdH07XFxuXFxuLyoqKi8gfSxcXG4vKiA0MiAqL1xcbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xcblxcblxcdHZhciBzaGFyZWQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQzKSgna2V5cycpXFxyXFxuXFx0ICAsIHVpZCAgICA9IF9fd2VicGFja19yZXF1aXJlX18oNDQpO1xcclxcblxcdG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oa2V5KXtcXHJcXG5cXHQgIHJldHVybiBzaGFyZWRba2V5XSB8fCAoc2hhcmVkW2tleV0gPSB1aWQoa2V5KSk7XFxyXFxuXFx0fTtcXG5cXG4vKioqLyB9LFxcbi8qIDQzICovXFxuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XFxuXFxuXFx0dmFyIGdsb2JhbCA9IF9fd2VicGFja19yZXF1aXJlX18oMTUpXFxuXFx0ICAsIFNIQVJFRCA9ICdfX2NvcmUtanNfc2hhcmVkX18nXFxuXFx0ICAsIHN0b3JlICA9IGdsb2JhbFtTSEFSRURdIHx8IChnbG9iYWxbU0hBUkVEXSA9IHt9KTtcXG5cXHRtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGtleSl7XFxuXFx0ICByZXR1cm4gc3RvcmVba2V5XSB8fCAoc3RvcmVba2V5XSA9IHt9KTtcXG5cXHR9O1xcblxcbi8qKiovIH0sXFxuLyogNDQgKi9cXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcXG5cXG5cXHR2YXIgaWQgPSAwXFxuXFx0ICAsIHB4ID0gTWF0aC5yYW5kb20oKTtcXG5cXHRtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGtleSl7XFxuXFx0ICByZXR1cm4gJ1N5bWJvbCgnLmNvbmNhdChrZXkgPT09IHVuZGVmaW5lZCA/ICcnIDoga2V5LCAnKV8nLCAoKytpZCArIHB4KS50b1N0cmluZygzNikpO1xcblxcdH07XFxuXFxuLyoqKi8gfSxcXG4vKiA0NSAqL1xcbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xcblxcblxcdC8vIElFIDgtIGRvbid0IGVudW0gYnVnIGtleXNcXHJcXG5cXHRtb2R1bGUuZXhwb3J0cyA9IChcXHJcXG5cXHQgICdjb25zdHJ1Y3RvcixoYXNPd25Qcm9wZXJ0eSxpc1Byb3RvdHlwZU9mLHByb3BlcnR5SXNFbnVtZXJhYmxlLHRvTG9jYWxlU3RyaW5nLHRvU3RyaW5nLHZhbHVlT2YnXFxyXFxuXFx0KS5zcGxpdCgnLCcpO1xcblxcbi8qKiovIH0sXFxuLyogNDYgKi9cXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcXG5cXG5cXHRtb2R1bGUuZXhwb3J0cyA9IF9fd2VicGFja19yZXF1aXJlX18oMTUpLmRvY3VtZW50ICYmIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcXG5cXG4vKioqLyB9LFxcbi8qIDQ3ICovXFxuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XFxuXFxuXFx0dmFyIGRlZiA9IF9fd2VicGFja19yZXF1aXJlX18oMTkpLmZcXG5cXHQgICwgaGFzID0gX193ZWJwYWNrX3JlcXVpcmVfXygyOSlcXG5cXHQgICwgVEFHID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0OCkoJ3RvU3RyaW5nVGFnJyk7XFxuXFx0XFxuXFx0bW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCwgdGFnLCBzdGF0KXtcXG5cXHQgIGlmKGl0ICYmICFoYXMoaXQgPSBzdGF0ID8gaXQgOiBpdC5wcm90b3R5cGUsIFRBRykpZGVmKGl0LCBUQUcsIHtjb25maWd1cmFibGU6IHRydWUsIHZhbHVlOiB0YWd9KTtcXG5cXHR9O1xcblxcbi8qKiovIH0sXFxuLyogNDggKi9cXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcXG5cXG5cXHR2YXIgc3RvcmUgICAgICA9IF9fd2VicGFja19yZXF1aXJlX18oNDMpKCd3a3MnKVxcblxcdCAgLCB1aWQgICAgICAgID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0NClcXG5cXHQgICwgU3ltYm9sICAgICA9IF9fd2VicGFja19yZXF1aXJlX18oMTUpLlN5bWJvbFxcblxcdCAgLCBVU0VfU1lNQk9MID0gdHlwZW9mIFN5bWJvbCA9PSAnZnVuY3Rpb24nO1xcblxcdFxcblxcdHZhciAkZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24obmFtZSl7XFxuXFx0ICByZXR1cm4gc3RvcmVbbmFtZV0gfHwgKHN0b3JlW25hbWVdID1cXG5cXHQgICAgVVNFX1NZTUJPTCAmJiBTeW1ib2xbbmFtZV0gfHwgKFVTRV9TWU1CT0wgPyBTeW1ib2wgOiB1aWQpKCdTeW1ib2wuJyArIG5hbWUpKTtcXG5cXHR9O1xcblxcdFxcblxcdCRleHBvcnRzLnN0b3JlID0gc3RvcmU7XFxuXFxuLyoqKi8gfSxcXG4vKiA0OSAqL1xcbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xcblxcblxcdC8vIDE5LjEuMi45IC8gMTUuMi4zLjIgT2JqZWN0LmdldFByb3RvdHlwZU9mKE8pXFxyXFxuXFx0dmFyIGhhcyAgICAgICAgID0gX193ZWJwYWNrX3JlcXVpcmVfXygyOSlcXHJcXG5cXHQgICwgdG9PYmplY3QgICAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUwKVxcclxcblxcdCAgLCBJRV9QUk9UTyAgICA9IF9fd2VicGFja19yZXF1aXJlX18oNDIpKCdJRV9QUk9UTycpXFxyXFxuXFx0ICAsIE9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcXHJcXG5cXHRcXHJcXG5cXHRtb2R1bGUuZXhwb3J0cyA9IE9iamVjdC5nZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbihPKXtcXHJcXG5cXHQgIE8gPSB0b09iamVjdChPKTtcXHJcXG5cXHQgIGlmKGhhcyhPLCBJRV9QUk9UTykpcmV0dXJuIE9bSUVfUFJPVE9dO1xcclxcblxcdCAgaWYodHlwZW9mIE8uY29uc3RydWN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiBPIGluc3RhbmNlb2YgTy5jb25zdHJ1Y3Rvcil7XFxyXFxuXFx0ICAgIHJldHVybiBPLmNvbnN0cnVjdG9yLnByb3RvdHlwZTtcXHJcXG5cXHQgIH0gcmV0dXJuIE8gaW5zdGFuY2VvZiBPYmplY3QgPyBPYmplY3RQcm90byA6IG51bGw7XFxyXFxuXFx0fTtcXG5cXG4vKioqLyB9LFxcbi8qIDUwICovXFxuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XFxuXFxuXFx0Ly8gNy4xLjEzIFRvT2JqZWN0KGFyZ3VtZW50KVxcblxcdHZhciBkZWZpbmVkID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMSk7XFxuXFx0bW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCl7XFxuXFx0ICByZXR1cm4gT2JqZWN0KGRlZmluZWQoaXQpKTtcXG5cXHR9O1xcblxcbi8qKiovIH0sXFxuLyogNTEgKi9cXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcXG5cXG5cXHRfX3dlYnBhY2tfcmVxdWlyZV9fKDUyKTtcXG5cXHR2YXIgZ2xvYmFsICAgICAgICA9IF9fd2VicGFja19yZXF1aXJlX18oMTUpXFxuXFx0ICAsIGhpZGUgICAgICAgICAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE4KVxcblxcdCAgLCBJdGVyYXRvcnMgICAgID0gX193ZWJwYWNrX3JlcXVpcmVfXygzMClcXG5cXHQgICwgVE9fU1RSSU5HX1RBRyA9IF9fd2VicGFja19yZXF1aXJlX18oNDgpKCd0b1N0cmluZ1RhZycpO1xcblxcdFxcblxcdGZvcih2YXIgY29sbGVjdGlvbnMgPSBbJ05vZGVMaXN0JywgJ0RPTVRva2VuTGlzdCcsICdNZWRpYUxpc3QnLCAnU3R5bGVTaGVldExpc3QnLCAnQ1NTUnVsZUxpc3QnXSwgaSA9IDA7IGkgPCA1OyBpKyspe1xcblxcdCAgdmFyIE5BTUUgICAgICAgPSBjb2xsZWN0aW9uc1tpXVxcblxcdCAgICAsIENvbGxlY3Rpb24gPSBnbG9iYWxbTkFNRV1cXG5cXHQgICAgLCBwcm90byAgICAgID0gQ29sbGVjdGlvbiAmJiBDb2xsZWN0aW9uLnByb3RvdHlwZTtcXG5cXHQgIGlmKHByb3RvICYmICFwcm90b1tUT19TVFJJTkdfVEFHXSloaWRlKHByb3RvLCBUT19TVFJJTkdfVEFHLCBOQU1FKTtcXG5cXHQgIEl0ZXJhdG9yc1tOQU1FXSA9IEl0ZXJhdG9ycy5BcnJheTtcXG5cXHR9XFxuXFxuLyoqKi8gfSxcXG4vKiA1MiAqL1xcbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xcblxcblxcdCd1c2Ugc3RyaWN0JztcXG5cXHR2YXIgYWRkVG9VbnNjb3BhYmxlcyA9IF9fd2VicGFja19yZXF1aXJlX18oNTMpXFxuXFx0ICAsIHN0ZXAgICAgICAgICAgICAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDU0KVxcblxcdCAgLCBJdGVyYXRvcnMgICAgICAgID0gX193ZWJwYWNrX3JlcXVpcmVfXygzMClcXG5cXHQgICwgdG9JT2JqZWN0ICAgICAgICA9IF9fd2VicGFja19yZXF1aXJlX18oMzYpO1xcblxcdFxcblxcdC8vIDIyLjEuMy40IEFycmF5LnByb3RvdHlwZS5lbnRyaWVzKClcXG5cXHQvLyAyMi4xLjMuMTMgQXJyYXkucHJvdG90eXBlLmtleXMoKVxcblxcdC8vIDIyLjEuMy4yOSBBcnJheS5wcm90b3R5cGUudmFsdWVzKClcXG5cXHQvLyAyMi4xLjMuMzAgQXJyYXkucHJvdG90eXBlW0BAaXRlcmF0b3JdKClcXG5cXHRtb2R1bGUuZXhwb3J0cyA9IF9fd2VicGFja19yZXF1aXJlX18oMTIpKEFycmF5LCAnQXJyYXknLCBmdW5jdGlvbihpdGVyYXRlZCwga2luZCl7XFxuXFx0ICB0aGlzLl90ID0gdG9JT2JqZWN0KGl0ZXJhdGVkKTsgLy8gdGFyZ2V0XFxuXFx0ICB0aGlzLl9pID0gMDsgICAgICAgICAgICAgICAgICAgLy8gbmV4dCBpbmRleFxcblxcdCAgdGhpcy5fayA9IGtpbmQ7ICAgICAgICAgICAgICAgIC8vIGtpbmRcXG5cXHQvLyAyMi4xLjUuMi4xICVBcnJheUl0ZXJhdG9yUHJvdG90eXBlJS5uZXh0KClcXG5cXHR9LCBmdW5jdGlvbigpe1xcblxcdCAgdmFyIE8gICAgID0gdGhpcy5fdFxcblxcdCAgICAsIGtpbmQgID0gdGhpcy5fa1xcblxcdCAgICAsIGluZGV4ID0gdGhpcy5faSsrO1xcblxcdCAgaWYoIU8gfHwgaW5kZXggPj0gTy5sZW5ndGgpe1xcblxcdCAgICB0aGlzLl90ID0gdW5kZWZpbmVkO1xcblxcdCAgICByZXR1cm4gc3RlcCgxKTtcXG5cXHQgIH1cXG5cXHQgIGlmKGtpbmQgPT0gJ2tleXMnICApcmV0dXJuIHN0ZXAoMCwgaW5kZXgpO1xcblxcdCAgaWYoa2luZCA9PSAndmFsdWVzJylyZXR1cm4gc3RlcCgwLCBPW2luZGV4XSk7XFxuXFx0ICByZXR1cm4gc3RlcCgwLCBbaW5kZXgsIE9baW5kZXhdXSk7XFxuXFx0fSwgJ3ZhbHVlcycpO1xcblxcdFxcblxcdC8vIGFyZ3VtZW50c0xpc3RbQEBpdGVyYXRvcl0gaXMgJUFycmF5UHJvdG9fdmFsdWVzJSAoOS40LjQuNiwgOS40LjQuNylcXG5cXHRJdGVyYXRvcnMuQXJndW1lbnRzID0gSXRlcmF0b3JzLkFycmF5O1xcblxcdFxcblxcdGFkZFRvVW5zY29wYWJsZXMoJ2tleXMnKTtcXG5cXHRhZGRUb1Vuc2NvcGFibGVzKCd2YWx1ZXMnKTtcXG5cXHRhZGRUb1Vuc2NvcGFibGVzKCdlbnRyaWVzJyk7XFxuXFxuLyoqKi8gfSxcXG4vKiA1MyAqL1xcbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xcblxcblxcdG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oKXsgLyogZW1wdHkgKi8gfTtcXG5cXG4vKioqLyB9LFxcbi8qIDU0ICovXFxuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XFxuXFxuXFx0bW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihkb25lLCB2YWx1ZSl7XFxuXFx0ICByZXR1cm4ge3ZhbHVlOiB2YWx1ZSwgZG9uZTogISFkb25lfTtcXG5cXHR9O1xcblxcbi8qKiovIH0sXFxuLyogNTUgKi9cXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcXG5cXG5cXHRleHBvcnRzLmYgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQ4KTtcXG5cXG4vKioqLyB9LFxcbi8qIDU2ICovXFxuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XFxuXFxuXFx0bW9kdWxlLmV4cG9ydHMgPSB7IFxcXCJkZWZhdWx0XFxcIjogX193ZWJwYWNrX3JlcXVpcmVfXyg1NyksIF9fZXNNb2R1bGU6IHRydWUgfTtcXG5cXG4vKioqLyB9LFxcbi8qIDU3ICovXFxuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XFxuXFxuXFx0X193ZWJwYWNrX3JlcXVpcmVfXyg1OCk7XFxuXFx0X193ZWJwYWNrX3JlcXVpcmVfXyg2OSk7XFxuXFx0X193ZWJwYWNrX3JlcXVpcmVfXyg3MCk7XFxuXFx0X193ZWJwYWNrX3JlcXVpcmVfXyg3MSk7XFxuXFx0bW9kdWxlLmV4cG9ydHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpLlN5bWJvbDtcXG5cXG4vKioqLyB9LFxcbi8qIDU4ICovXFxuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XFxuXFxuXFx0J3VzZSBzdHJpY3QnO1xcblxcdC8vIEVDTUFTY3JpcHQgNiBzeW1ib2xzIHNoaW1cXG5cXHR2YXIgZ2xvYmFsICAgICAgICAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE1KVxcblxcdCAgLCBoYXMgICAgICAgICAgICA9IF9fd2VicGFja19yZXF1aXJlX18oMjkpXFxuXFx0ICAsIERFU0NSSVBUT1JTICAgID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMylcXG5cXHQgICwgJGV4cG9ydCAgICAgICAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE0KVxcblxcdCAgLCByZWRlZmluZSAgICAgICA9IF9fd2VicGFja19yZXF1aXJlX18oMjgpXFxuXFx0ICAsIE1FVEEgICAgICAgICAgID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1OSkuS0VZXFxuXFx0ICAsICRmYWlscyAgICAgICAgID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNClcXG5cXHQgICwgc2hhcmVkICAgICAgICAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQzKVxcblxcdCAgLCBzZXRUb1N0cmluZ1RhZyA9IF9fd2VicGFja19yZXF1aXJlX18oNDcpXFxuXFx0ICAsIHVpZCAgICAgICAgICAgID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0NClcXG5cXHQgICwgd2tzICAgICAgICAgICAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQ4KVxcblxcdCAgLCB3a3NFeHQgICAgICAgICA9IF9fd2VicGFja19yZXF1aXJlX18oNTUpXFxuXFx0ICAsIHdrc0RlZmluZSAgICAgID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2MClcXG5cXHQgICwga2V5T2YgICAgICAgICAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYxKVxcblxcdCAgLCBlbnVtS2V5cyAgICAgICA9IF9fd2VicGFja19yZXF1aXJlX18oNjIpXFxuXFx0ICAsIGlzQXJyYXkgICAgICAgID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2NSlcXG5cXHQgICwgYW5PYmplY3QgICAgICAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIwKVxcblxcdCAgLCB0b0lPYmplY3QgICAgICA9IF9fd2VicGFja19yZXF1aXJlX18oMzYpXFxuXFx0ICAsIHRvUHJpbWl0aXZlICAgID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNilcXG5cXHQgICwgY3JlYXRlRGVzYyAgICAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI3KVxcblxcdCAgLCBfY3JlYXRlICAgICAgICA9IF9fd2VicGFja19yZXF1aXJlX18oMzIpXFxuXFx0ICAsIGdPUE5FeHQgICAgICAgID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2NilcXG5cXHQgICwgJEdPUEQgICAgICAgICAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDY4KVxcblxcdCAgLCAkRFAgICAgICAgICAgICA9IF9fd2VicGFja19yZXF1aXJlX18oMTkpXFxuXFx0ICAsICRrZXlzICAgICAgICAgID0gX193ZWJwYWNrX3JlcXVpcmVfXygzNClcXG5cXHQgICwgZ09QRCAgICAgICAgICAgPSAkR09QRC5mXFxuXFx0ICAsIGRQICAgICAgICAgICAgID0gJERQLmZcXG5cXHQgICwgZ09QTiAgICAgICAgICAgPSBnT1BORXh0LmZcXG5cXHQgICwgJFN5bWJvbCAgICAgICAgPSBnbG9iYWwuU3ltYm9sXFxuXFx0ICAsICRKU09OICAgICAgICAgID0gZ2xvYmFsLkpTT05cXG5cXHQgICwgX3N0cmluZ2lmeSAgICAgPSAkSlNPTiAmJiAkSlNPTi5zdHJpbmdpZnlcXG5cXHQgICwgUFJPVE9UWVBFICAgICAgPSAncHJvdG90eXBlJ1xcblxcdCAgLCBISURERU4gICAgICAgICA9IHdrcygnX2hpZGRlbicpXFxuXFx0ICAsIFRPX1BSSU1JVElWRSAgID0gd2tzKCd0b1ByaW1pdGl2ZScpXFxuXFx0ICAsIGlzRW51bSAgICAgICAgID0ge30ucHJvcGVydHlJc0VudW1lcmFibGVcXG5cXHQgICwgU3ltYm9sUmVnaXN0cnkgPSBzaGFyZWQoJ3N5bWJvbC1yZWdpc3RyeScpXFxuXFx0ICAsIEFsbFN5bWJvbHMgICAgID0gc2hhcmVkKCdzeW1ib2xzJylcXG5cXHQgICwgT1BTeW1ib2xzICAgICAgPSBzaGFyZWQoJ29wLXN5bWJvbHMnKVxcblxcdCAgLCBPYmplY3RQcm90byAgICA9IE9iamVjdFtQUk9UT1RZUEVdXFxuXFx0ICAsIFVTRV9OQVRJVkUgICAgID0gdHlwZW9mICRTeW1ib2wgPT0gJ2Z1bmN0aW9uJ1xcblxcdCAgLCBRT2JqZWN0ICAgICAgICA9IGdsb2JhbC5RT2JqZWN0O1xcblxcdC8vIERvbid0IHVzZSBzZXR0ZXJzIGluIFF0IFNjcmlwdCwgaHR0cHM6Ly9naXRodWIuY29tL3psb2lyb2NrL2NvcmUtanMvaXNzdWVzLzE3M1xcblxcdHZhciBzZXR0ZXIgPSAhUU9iamVjdCB8fCAhUU9iamVjdFtQUk9UT1RZUEVdIHx8ICFRT2JqZWN0W1BST1RPVFlQRV0uZmluZENoaWxkO1xcblxcdFxcblxcdC8vIGZhbGxiYWNrIGZvciBvbGQgQW5kcm9pZCwgaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTY4N1xcblxcdHZhciBzZXRTeW1ib2xEZXNjID0gREVTQ1JJUFRPUlMgJiYgJGZhaWxzKGZ1bmN0aW9uKCl7XFxuXFx0ICByZXR1cm4gX2NyZWF0ZShkUCh7fSwgJ2EnLCB7XFxuXFx0ICAgIGdldDogZnVuY3Rpb24oKXsgcmV0dXJuIGRQKHRoaXMsICdhJywge3ZhbHVlOiA3fSkuYTsgfVxcblxcdCAgfSkpLmEgIT0gNztcXG5cXHR9KSA/IGZ1bmN0aW9uKGl0LCBrZXksIEQpe1xcblxcdCAgdmFyIHByb3RvRGVzYyA9IGdPUEQoT2JqZWN0UHJvdG8sIGtleSk7XFxuXFx0ICBpZihwcm90b0Rlc2MpZGVsZXRlIE9iamVjdFByb3RvW2tleV07XFxuXFx0ICBkUChpdCwga2V5LCBEKTtcXG5cXHQgIGlmKHByb3RvRGVzYyAmJiBpdCAhPT0gT2JqZWN0UHJvdG8pZFAoT2JqZWN0UHJvdG8sIGtleSwgcHJvdG9EZXNjKTtcXG5cXHR9IDogZFA7XFxuXFx0XFxuXFx0dmFyIHdyYXAgPSBmdW5jdGlvbih0YWcpe1xcblxcdCAgdmFyIHN5bSA9IEFsbFN5bWJvbHNbdGFnXSA9IF9jcmVhdGUoJFN5bWJvbFtQUk9UT1RZUEVdKTtcXG5cXHQgIHN5bS5fayA9IHRhZztcXG5cXHQgIHJldHVybiBzeW07XFxuXFx0fTtcXG5cXHRcXG5cXHR2YXIgaXNTeW1ib2wgPSBVU0VfTkFUSVZFICYmIHR5cGVvZiAkU3ltYm9sLml0ZXJhdG9yID09ICdzeW1ib2wnID8gZnVuY3Rpb24oaXQpe1xcblxcdCAgcmV0dXJuIHR5cGVvZiBpdCA9PSAnc3ltYm9sJztcXG5cXHR9IDogZnVuY3Rpb24oaXQpe1xcblxcdCAgcmV0dXJuIGl0IGluc3RhbmNlb2YgJFN5bWJvbDtcXG5cXHR9O1xcblxcdFxcblxcdHZhciAkZGVmaW5lUHJvcGVydHkgPSBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0eShpdCwga2V5LCBEKXtcXG5cXHQgIGlmKGl0ID09PSBPYmplY3RQcm90bykkZGVmaW5lUHJvcGVydHkoT1BTeW1ib2xzLCBrZXksIEQpO1xcblxcdCAgYW5PYmplY3QoaXQpO1xcblxcdCAga2V5ID0gdG9QcmltaXRpdmUoa2V5LCB0cnVlKTtcXG5cXHQgIGFuT2JqZWN0KEQpO1xcblxcdCAgaWYoaGFzKEFsbFN5bWJvbHMsIGtleSkpe1xcblxcdCAgICBpZighRC5lbnVtZXJhYmxlKXtcXG5cXHQgICAgICBpZighaGFzKGl0LCBISURERU4pKWRQKGl0LCBISURERU4sIGNyZWF0ZURlc2MoMSwge30pKTtcXG5cXHQgICAgICBpdFtISURERU5dW2tleV0gPSB0cnVlO1xcblxcdCAgICB9IGVsc2Uge1xcblxcdCAgICAgIGlmKGhhcyhpdCwgSElEREVOKSAmJiBpdFtISURERU5dW2tleV0paXRbSElEREVOXVtrZXldID0gZmFsc2U7XFxuXFx0ICAgICAgRCA9IF9jcmVhdGUoRCwge2VudW1lcmFibGU6IGNyZWF0ZURlc2MoMCwgZmFsc2UpfSk7XFxuXFx0ICAgIH0gcmV0dXJuIHNldFN5bWJvbERlc2MoaXQsIGtleSwgRCk7XFxuXFx0ICB9IHJldHVybiBkUChpdCwga2V5LCBEKTtcXG5cXHR9O1xcblxcdHZhciAkZGVmaW5lUHJvcGVydGllcyA9IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXMoaXQsIFApe1xcblxcdCAgYW5PYmplY3QoaXQpO1xcblxcdCAgdmFyIGtleXMgPSBlbnVtS2V5cyhQID0gdG9JT2JqZWN0KFApKVxcblxcdCAgICAsIGkgICAgPSAwXFxuXFx0ICAgICwgbCA9IGtleXMubGVuZ3RoXFxuXFx0ICAgICwga2V5O1xcblxcdCAgd2hpbGUobCA+IGkpJGRlZmluZVByb3BlcnR5KGl0LCBrZXkgPSBrZXlzW2krK10sIFBba2V5XSk7XFxuXFx0ICByZXR1cm4gaXQ7XFxuXFx0fTtcXG5cXHR2YXIgJGNyZWF0ZSA9IGZ1bmN0aW9uIGNyZWF0ZShpdCwgUCl7XFxuXFx0ICByZXR1cm4gUCA9PT0gdW5kZWZpbmVkID8gX2NyZWF0ZShpdCkgOiAkZGVmaW5lUHJvcGVydGllcyhfY3JlYXRlKGl0KSwgUCk7XFxuXFx0fTtcXG5cXHR2YXIgJHByb3BlcnR5SXNFbnVtZXJhYmxlID0gZnVuY3Rpb24gcHJvcGVydHlJc0VudW1lcmFibGUoa2V5KXtcXG5cXHQgIHZhciBFID0gaXNFbnVtLmNhbGwodGhpcywga2V5ID0gdG9QcmltaXRpdmUoa2V5LCB0cnVlKSk7XFxuXFx0ICBpZih0aGlzID09PSBPYmplY3RQcm90byAmJiBoYXMoQWxsU3ltYm9scywga2V5KSAmJiAhaGFzKE9QU3ltYm9scywga2V5KSlyZXR1cm4gZmFsc2U7XFxuXFx0ICByZXR1cm4gRSB8fCAhaGFzKHRoaXMsIGtleSkgfHwgIWhhcyhBbGxTeW1ib2xzLCBrZXkpIHx8IGhhcyh0aGlzLCBISURERU4pICYmIHRoaXNbSElEREVOXVtrZXldID8gRSA6IHRydWU7XFxuXFx0fTtcXG5cXHR2YXIgJGdldE93blByb3BlcnR5RGVzY3JpcHRvciA9IGZ1bmN0aW9uIGdldE93blByb3BlcnR5RGVzY3JpcHRvcihpdCwga2V5KXtcXG5cXHQgIGl0ICA9IHRvSU9iamVjdChpdCk7XFxuXFx0ICBrZXkgPSB0b1ByaW1pdGl2ZShrZXksIHRydWUpO1xcblxcdCAgaWYoaXQgPT09IE9iamVjdFByb3RvICYmIGhhcyhBbGxTeW1ib2xzLCBrZXkpICYmICFoYXMoT1BTeW1ib2xzLCBrZXkpKXJldHVybjtcXG5cXHQgIHZhciBEID0gZ09QRChpdCwga2V5KTtcXG5cXHQgIGlmKEQgJiYgaGFzKEFsbFN5bWJvbHMsIGtleSkgJiYgIShoYXMoaXQsIEhJRERFTikgJiYgaXRbSElEREVOXVtrZXldKSlELmVudW1lcmFibGUgPSB0cnVlO1xcblxcdCAgcmV0dXJuIEQ7XFxuXFx0fTtcXG5cXHR2YXIgJGdldE93blByb3BlcnR5TmFtZXMgPSBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eU5hbWVzKGl0KXtcXG5cXHQgIHZhciBuYW1lcyAgPSBnT1BOKHRvSU9iamVjdChpdCkpXFxuXFx0ICAgICwgcmVzdWx0ID0gW11cXG5cXHQgICAgLCBpICAgICAgPSAwXFxuXFx0ICAgICwga2V5O1xcblxcdCAgd2hpbGUobmFtZXMubGVuZ3RoID4gaSl7XFxuXFx0ICAgIGlmKCFoYXMoQWxsU3ltYm9scywga2V5ID0gbmFtZXNbaSsrXSkgJiYga2V5ICE9IEhJRERFTiAmJiBrZXkgIT0gTUVUQSlyZXN1bHQucHVzaChrZXkpO1xcblxcdCAgfSByZXR1cm4gcmVzdWx0O1xcblxcdH07XFxuXFx0dmFyICRnZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPSBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eVN5bWJvbHMoaXQpe1xcblxcdCAgdmFyIElTX09QICA9IGl0ID09PSBPYmplY3RQcm90b1xcblxcdCAgICAsIG5hbWVzICA9IGdPUE4oSVNfT1AgPyBPUFN5bWJvbHMgOiB0b0lPYmplY3QoaXQpKVxcblxcdCAgICAsIHJlc3VsdCA9IFtdXFxuXFx0ICAgICwgaSAgICAgID0gMFxcblxcdCAgICAsIGtleTtcXG5cXHQgIHdoaWxlKG5hbWVzLmxlbmd0aCA+IGkpe1xcblxcdCAgICBpZihoYXMoQWxsU3ltYm9scywga2V5ID0gbmFtZXNbaSsrXSkgJiYgKElTX09QID8gaGFzKE9iamVjdFByb3RvLCBrZXkpIDogdHJ1ZSkpcmVzdWx0LnB1c2goQWxsU3ltYm9sc1trZXldKTtcXG5cXHQgIH0gcmV0dXJuIHJlc3VsdDtcXG5cXHR9O1xcblxcdFxcblxcdC8vIDE5LjQuMS4xIFN5bWJvbChbZGVzY3JpcHRpb25dKVxcblxcdGlmKCFVU0VfTkFUSVZFKXtcXG5cXHQgICRTeW1ib2wgPSBmdW5jdGlvbiBTeW1ib2woKXtcXG5cXHQgICAgaWYodGhpcyBpbnN0YW5jZW9mICRTeW1ib2wpdGhyb3cgVHlwZUVycm9yKCdTeW1ib2wgaXMgbm90IGEgY29uc3RydWN0b3IhJyk7XFxuXFx0ICAgIHZhciB0YWcgPSB1aWQoYXJndW1lbnRzLmxlbmd0aCA+IDAgPyBhcmd1bWVudHNbMF0gOiB1bmRlZmluZWQpO1xcblxcdCAgICB2YXIgJHNldCA9IGZ1bmN0aW9uKHZhbHVlKXtcXG5cXHQgICAgICBpZih0aGlzID09PSBPYmplY3RQcm90bykkc2V0LmNhbGwoT1BTeW1ib2xzLCB2YWx1ZSk7XFxuXFx0ICAgICAgaWYoaGFzKHRoaXMsIEhJRERFTikgJiYgaGFzKHRoaXNbSElEREVOXSwgdGFnKSl0aGlzW0hJRERFTl1bdGFnXSA9IGZhbHNlO1xcblxcdCAgICAgIHNldFN5bWJvbERlc2ModGhpcywgdGFnLCBjcmVhdGVEZXNjKDEsIHZhbHVlKSk7XFxuXFx0ICAgIH07XFxuXFx0ICAgIGlmKERFU0NSSVBUT1JTICYmIHNldHRlcilzZXRTeW1ib2xEZXNjKE9iamVjdFByb3RvLCB0YWcsIHtjb25maWd1cmFibGU6IHRydWUsIHNldDogJHNldH0pO1xcblxcdCAgICByZXR1cm4gd3JhcCh0YWcpO1xcblxcdCAgfTtcXG5cXHQgIHJlZGVmaW5lKCRTeW1ib2xbUFJPVE9UWVBFXSwgJ3RvU3RyaW5nJywgZnVuY3Rpb24gdG9TdHJpbmcoKXtcXG5cXHQgICAgcmV0dXJuIHRoaXMuX2s7XFxuXFx0ICB9KTtcXG5cXHRcXG5cXHQgICRHT1BELmYgPSAkZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xcblxcdCAgJERQLmYgICA9ICRkZWZpbmVQcm9wZXJ0eTtcXG5cXHQgIF9fd2VicGFja19yZXF1aXJlX18oNjcpLmYgPSBnT1BORXh0LmYgPSAkZ2V0T3duUHJvcGVydHlOYW1lcztcXG5cXHQgIF9fd2VicGFja19yZXF1aXJlX18oNjQpLmYgID0gJHByb3BlcnR5SXNFbnVtZXJhYmxlO1xcblxcdCAgX193ZWJwYWNrX3JlcXVpcmVfXyg2MykuZiA9ICRnZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XFxuXFx0XFxuXFx0ICBpZihERVNDUklQVE9SUyAmJiAhX193ZWJwYWNrX3JlcXVpcmVfXygxMykpe1xcblxcdCAgICByZWRlZmluZShPYmplY3RQcm90bywgJ3Byb3BlcnR5SXNFbnVtZXJhYmxlJywgJHByb3BlcnR5SXNFbnVtZXJhYmxlLCB0cnVlKTtcXG5cXHQgIH1cXG5cXHRcXG5cXHQgIHdrc0V4dC5mID0gZnVuY3Rpb24obmFtZSl7XFxuXFx0ICAgIHJldHVybiB3cmFwKHdrcyhuYW1lKSk7XFxuXFx0ICB9XFxuXFx0fVxcblxcdFxcblxcdCRleHBvcnQoJGV4cG9ydC5HICsgJGV4cG9ydC5XICsgJGV4cG9ydC5GICogIVVTRV9OQVRJVkUsIHtTeW1ib2w6ICRTeW1ib2x9KTtcXG5cXHRcXG5cXHRmb3IodmFyIHN5bWJvbHMgPSAoXFxuXFx0ICAvLyAxOS40LjIuMiwgMTkuNC4yLjMsIDE5LjQuMi40LCAxOS40LjIuNiwgMTkuNC4yLjgsIDE5LjQuMi45LCAxOS40LjIuMTAsIDE5LjQuMi4xMSwgMTkuNC4yLjEyLCAxOS40LjIuMTMsIDE5LjQuMi4xNFxcblxcdCAgJ2hhc0luc3RhbmNlLGlzQ29uY2F0U3ByZWFkYWJsZSxpdGVyYXRvcixtYXRjaCxyZXBsYWNlLHNlYXJjaCxzcGVjaWVzLHNwbGl0LHRvUHJpbWl0aXZlLHRvU3RyaW5nVGFnLHVuc2NvcGFibGVzJ1xcblxcdCkuc3BsaXQoJywnKSwgaSA9IDA7IHN5bWJvbHMubGVuZ3RoID4gaTsgKXdrcyhzeW1ib2xzW2krK10pO1xcblxcdFxcblxcdGZvcih2YXIgc3ltYm9scyA9ICRrZXlzKHdrcy5zdG9yZSksIGkgPSAwOyBzeW1ib2xzLmxlbmd0aCA+IGk7ICl3a3NEZWZpbmUoc3ltYm9sc1tpKytdKTtcXG5cXHRcXG5cXHQkZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqICFVU0VfTkFUSVZFLCAnU3ltYm9sJywge1xcblxcdCAgLy8gMTkuNC4yLjEgU3ltYm9sLmZvcihrZXkpXFxuXFx0ICAnZm9yJzogZnVuY3Rpb24oa2V5KXtcXG5cXHQgICAgcmV0dXJuIGhhcyhTeW1ib2xSZWdpc3RyeSwga2V5ICs9ICcnKVxcblxcdCAgICAgID8gU3ltYm9sUmVnaXN0cnlba2V5XVxcblxcdCAgICAgIDogU3ltYm9sUmVnaXN0cnlba2V5XSA9ICRTeW1ib2woa2V5KTtcXG5cXHQgIH0sXFxuXFx0ICAvLyAxOS40LjIuNSBTeW1ib2wua2V5Rm9yKHN5bSlcXG5cXHQgIGtleUZvcjogZnVuY3Rpb24ga2V5Rm9yKGtleSl7XFxuXFx0ICAgIGlmKGlzU3ltYm9sKGtleSkpcmV0dXJuIGtleU9mKFN5bWJvbFJlZ2lzdHJ5LCBrZXkpO1xcblxcdCAgICB0aHJvdyBUeXBlRXJyb3Ioa2V5ICsgJyBpcyBub3QgYSBzeW1ib2whJyk7XFxuXFx0ICB9LFxcblxcdCAgdXNlU2V0dGVyOiBmdW5jdGlvbigpeyBzZXR0ZXIgPSB0cnVlOyB9LFxcblxcdCAgdXNlU2ltcGxlOiBmdW5jdGlvbigpeyBzZXR0ZXIgPSBmYWxzZTsgfVxcblxcdH0pO1xcblxcdFxcblxcdCRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogIVVTRV9OQVRJVkUsICdPYmplY3QnLCB7XFxuXFx0ICAvLyAxOS4xLjIuMiBPYmplY3QuY3JlYXRlKE8gWywgUHJvcGVydGllc10pXFxuXFx0ICBjcmVhdGU6ICRjcmVhdGUsXFxuXFx0ICAvLyAxOS4xLjIuNCBPYmplY3QuZGVmaW5lUHJvcGVydHkoTywgUCwgQXR0cmlidXRlcylcXG5cXHQgIGRlZmluZVByb3BlcnR5OiAkZGVmaW5lUHJvcGVydHksXFxuXFx0ICAvLyAxOS4xLjIuMyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhPLCBQcm9wZXJ0aWVzKVxcblxcdCAgZGVmaW5lUHJvcGVydGllczogJGRlZmluZVByb3BlcnRpZXMsXFxuXFx0ICAvLyAxOS4xLjIuNiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKE8sIFApXFxuXFx0ICBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I6ICRnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IsXFxuXFx0ICAvLyAxOS4xLjIuNyBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhPKVxcblxcdCAgZ2V0T3duUHJvcGVydHlOYW1lczogJGdldE93blByb3BlcnR5TmFtZXMsXFxuXFx0ICAvLyAxOS4xLjIuOCBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKE8pXFxuXFx0ICBnZXRPd25Qcm9wZXJ0eVN5bWJvbHM6ICRnZXRPd25Qcm9wZXJ0eVN5bWJvbHNcXG5cXHR9KTtcXG5cXHRcXG5cXHQvLyAyNC4zLjIgSlNPTi5zdHJpbmdpZnkodmFsdWUgWywgcmVwbGFjZXIgWywgc3BhY2VdXSlcXG5cXHQkSlNPTiAmJiAkZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqICghVVNFX05BVElWRSB8fCAkZmFpbHMoZnVuY3Rpb24oKXtcXG5cXHQgIHZhciBTID0gJFN5bWJvbCgpO1xcblxcdCAgLy8gTVMgRWRnZSBjb252ZXJ0cyBzeW1ib2wgdmFsdWVzIHRvIEpTT04gYXMge31cXG5cXHQgIC8vIFdlYktpdCBjb252ZXJ0cyBzeW1ib2wgdmFsdWVzIHRvIEpTT04gYXMgbnVsbFxcblxcdCAgLy8gVjggdGhyb3dzIG9uIGJveGVkIHN5bWJvbHNcXG5cXHQgIHJldHVybiBfc3RyaW5naWZ5KFtTXSkgIT0gJ1tudWxsXScgfHwgX3N0cmluZ2lmeSh7YTogU30pICE9ICd7fScgfHwgX3N0cmluZ2lmeShPYmplY3QoUykpICE9ICd7fSc7XFxuXFx0fSkpLCAnSlNPTicsIHtcXG5cXHQgIHN0cmluZ2lmeTogZnVuY3Rpb24gc3RyaW5naWZ5KGl0KXtcXG5cXHQgICAgaWYoaXQgPT09IHVuZGVmaW5lZCB8fCBpc1N5bWJvbChpdCkpcmV0dXJuOyAvLyBJRTggcmV0dXJucyBzdHJpbmcgb24gdW5kZWZpbmVkXFxuXFx0ICAgIHZhciBhcmdzID0gW2l0XVxcblxcdCAgICAgICwgaSAgICA9IDFcXG5cXHQgICAgICAsIHJlcGxhY2VyLCAkcmVwbGFjZXI7XFxuXFx0ICAgIHdoaWxlKGFyZ3VtZW50cy5sZW5ndGggPiBpKWFyZ3MucHVzaChhcmd1bWVudHNbaSsrXSk7XFxuXFx0ICAgIHJlcGxhY2VyID0gYXJnc1sxXTtcXG5cXHQgICAgaWYodHlwZW9mIHJlcGxhY2VyID09ICdmdW5jdGlvbicpJHJlcGxhY2VyID0gcmVwbGFjZXI7XFxuXFx0ICAgIGlmKCRyZXBsYWNlciB8fCAhaXNBcnJheShyZXBsYWNlcikpcmVwbGFjZXIgPSBmdW5jdGlvbihrZXksIHZhbHVlKXtcXG5cXHQgICAgICBpZigkcmVwbGFjZXIpdmFsdWUgPSAkcmVwbGFjZXIuY2FsbCh0aGlzLCBrZXksIHZhbHVlKTtcXG5cXHQgICAgICBpZighaXNTeW1ib2wodmFsdWUpKXJldHVybiB2YWx1ZTtcXG5cXHQgICAgfTtcXG5cXHQgICAgYXJnc1sxXSA9IHJlcGxhY2VyO1xcblxcdCAgICByZXR1cm4gX3N0cmluZ2lmeS5hcHBseSgkSlNPTiwgYXJncyk7XFxuXFx0ICB9XFxuXFx0fSk7XFxuXFx0XFxuXFx0Ly8gMTkuNC4zLjQgU3ltYm9sLnByb3RvdHlwZVtAQHRvUHJpbWl0aXZlXShoaW50KVxcblxcdCRTeW1ib2xbUFJPVE9UWVBFXVtUT19QUklNSVRJVkVdIHx8IF9fd2VicGFja19yZXF1aXJlX18oMTgpKCRTeW1ib2xbUFJPVE9UWVBFXSwgVE9fUFJJTUlUSVZFLCAkU3ltYm9sW1BST1RPVFlQRV0udmFsdWVPZik7XFxuXFx0Ly8gMTkuNC4zLjUgU3ltYm9sLnByb3RvdHlwZVtAQHRvU3RyaW5nVGFnXVxcblxcdHNldFRvU3RyaW5nVGFnKCRTeW1ib2wsICdTeW1ib2wnKTtcXG5cXHQvLyAyMC4yLjEuOSBNYXRoW0BAdG9TdHJpbmdUYWddXFxuXFx0c2V0VG9TdHJpbmdUYWcoTWF0aCwgJ01hdGgnLCB0cnVlKTtcXG5cXHQvLyAyNC4zLjMgSlNPTltAQHRvU3RyaW5nVGFnXVxcblxcdHNldFRvU3RyaW5nVGFnKGdsb2JhbC5KU09OLCAnSlNPTicsIHRydWUpO1xcblxcbi8qKiovIH0sXFxuLyogNTkgKi9cXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcXG5cXG5cXHR2YXIgTUVUQSAgICAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQ0KSgnbWV0YScpXFxuXFx0ICAsIGlzT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMSlcXG5cXHQgICwgaGFzICAgICAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI5KVxcblxcdCAgLCBzZXREZXNjICA9IF9fd2VicGFja19yZXF1aXJlX18oMTkpLmZcXG5cXHQgICwgaWQgICAgICAgPSAwO1xcblxcdHZhciBpc0V4dGVuc2libGUgPSBPYmplY3QuaXNFeHRlbnNpYmxlIHx8IGZ1bmN0aW9uKCl7XFxuXFx0ICByZXR1cm4gdHJ1ZTtcXG5cXHR9O1xcblxcdHZhciBGUkVFWkUgPSAhX193ZWJwYWNrX3JlcXVpcmVfXygyNCkoZnVuY3Rpb24oKXtcXG5cXHQgIHJldHVybiBpc0V4dGVuc2libGUoT2JqZWN0LnByZXZlbnRFeHRlbnNpb25zKHt9KSk7XFxuXFx0fSk7XFxuXFx0dmFyIHNldE1ldGEgPSBmdW5jdGlvbihpdCl7XFxuXFx0ICBzZXREZXNjKGl0LCBNRVRBLCB7dmFsdWU6IHtcXG5cXHQgICAgaTogJ08nICsgKytpZCwgLy8gb2JqZWN0IElEXFxuXFx0ICAgIHc6IHt9ICAgICAgICAgIC8vIHdlYWsgY29sbGVjdGlvbnMgSURzXFxuXFx0ICB9fSk7XFxuXFx0fTtcXG5cXHR2YXIgZmFzdEtleSA9IGZ1bmN0aW9uKGl0LCBjcmVhdGUpe1xcblxcdCAgLy8gcmV0dXJuIHByaW1pdGl2ZSB3aXRoIHByZWZpeFxcblxcdCAgaWYoIWlzT2JqZWN0KGl0KSlyZXR1cm4gdHlwZW9mIGl0ID09ICdzeW1ib2wnID8gaXQgOiAodHlwZW9mIGl0ID09ICdzdHJpbmcnID8gJ1MnIDogJ1AnKSArIGl0O1xcblxcdCAgaWYoIWhhcyhpdCwgTUVUQSkpe1xcblxcdCAgICAvLyBjYW4ndCBzZXQgbWV0YWRhdGEgdG8gdW5jYXVnaHQgZnJvemVuIG9iamVjdFxcblxcdCAgICBpZighaXNFeHRlbnNpYmxlKGl0KSlyZXR1cm4gJ0YnO1xcblxcdCAgICAvLyBub3QgbmVjZXNzYXJ5IHRvIGFkZCBtZXRhZGF0YVxcblxcdCAgICBpZighY3JlYXRlKXJldHVybiAnRSc7XFxuXFx0ICAgIC8vIGFkZCBtaXNzaW5nIG1ldGFkYXRhXFxuXFx0ICAgIHNldE1ldGEoaXQpO1xcblxcdCAgLy8gcmV0dXJuIG9iamVjdCBJRFxcblxcdCAgfSByZXR1cm4gaXRbTUVUQV0uaTtcXG5cXHR9O1xcblxcdHZhciBnZXRXZWFrID0gZnVuY3Rpb24oaXQsIGNyZWF0ZSl7XFxuXFx0ICBpZighaGFzKGl0LCBNRVRBKSl7XFxuXFx0ICAgIC8vIGNhbid0IHNldCBtZXRhZGF0YSB0byB1bmNhdWdodCBmcm96ZW4gb2JqZWN0XFxuXFx0ICAgIGlmKCFpc0V4dGVuc2libGUoaXQpKXJldHVybiB0cnVlO1xcblxcdCAgICAvLyBub3QgbmVjZXNzYXJ5IHRvIGFkZCBtZXRhZGF0YVxcblxcdCAgICBpZighY3JlYXRlKXJldHVybiBmYWxzZTtcXG5cXHQgICAgLy8gYWRkIG1pc3NpbmcgbWV0YWRhdGFcXG5cXHQgICAgc2V0TWV0YShpdCk7XFxuXFx0ICAvLyByZXR1cm4gaGFzaCB3ZWFrIGNvbGxlY3Rpb25zIElEc1xcblxcdCAgfSByZXR1cm4gaXRbTUVUQV0udztcXG5cXHR9O1xcblxcdC8vIGFkZCBtZXRhZGF0YSBvbiBmcmVlemUtZmFtaWx5IG1ldGhvZHMgY2FsbGluZ1xcblxcdHZhciBvbkZyZWV6ZSA9IGZ1bmN0aW9uKGl0KXtcXG5cXHQgIGlmKEZSRUVaRSAmJiBtZXRhLk5FRUQgJiYgaXNFeHRlbnNpYmxlKGl0KSAmJiAhaGFzKGl0LCBNRVRBKSlzZXRNZXRhKGl0KTtcXG5cXHQgIHJldHVybiBpdDtcXG5cXHR9O1xcblxcdHZhciBtZXRhID0gbW9kdWxlLmV4cG9ydHMgPSB7XFxuXFx0ICBLRVk6ICAgICAgTUVUQSxcXG5cXHQgIE5FRUQ6ICAgICBmYWxzZSxcXG5cXHQgIGZhc3RLZXk6ICBmYXN0S2V5LFxcblxcdCAgZ2V0V2VhazogIGdldFdlYWssXFxuXFx0ICBvbkZyZWV6ZTogb25GcmVlemVcXG5cXHR9O1xcblxcbi8qKiovIH0sXFxuLyogNjAgKi9cXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcXG5cXG5cXHR2YXIgZ2xvYmFsICAgICAgICAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE1KVxcclxcblxcdCAgLCBjb3JlICAgICAgICAgICA9IF9fd2VicGFja19yZXF1aXJlX18oNClcXHJcXG5cXHQgICwgTElCUkFSWSAgICAgICAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEzKVxcclxcblxcdCAgLCB3a3NFeHQgICAgICAgICA9IF9fd2VicGFja19yZXF1aXJlX18oNTUpXFxyXFxuXFx0ICAsIGRlZmluZVByb3BlcnR5ID0gX193ZWJwYWNrX3JlcXVpcmVfXygxOSkuZjtcXHJcXG5cXHRtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG5hbWUpe1xcclxcblxcdCAgdmFyICRTeW1ib2wgPSBjb3JlLlN5bWJvbCB8fCAoY29yZS5TeW1ib2wgPSBMSUJSQVJZID8ge30gOiBnbG9iYWwuU3ltYm9sIHx8IHt9KTtcXHJcXG5cXHQgIGlmKG5hbWUuY2hhckF0KDApICE9ICdfJyAmJiAhKG5hbWUgaW4gJFN5bWJvbCkpZGVmaW5lUHJvcGVydHkoJFN5bWJvbCwgbmFtZSwge3ZhbHVlOiB3a3NFeHQuZihuYW1lKX0pO1xcclxcblxcdH07XFxuXFxuLyoqKi8gfSxcXG4vKiA2MSAqL1xcbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xcblxcblxcdHZhciBnZXRLZXlzICAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM0KVxcblxcdCAgLCB0b0lPYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM2KTtcXG5cXHRtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG9iamVjdCwgZWwpe1xcblxcdCAgdmFyIE8gICAgICA9IHRvSU9iamVjdChvYmplY3QpXFxuXFx0ICAgICwga2V5cyAgID0gZ2V0S2V5cyhPKVxcblxcdCAgICAsIGxlbmd0aCA9IGtleXMubGVuZ3RoXFxuXFx0ICAgICwgaW5kZXggID0gMFxcblxcdCAgICAsIGtleTtcXG5cXHQgIHdoaWxlKGxlbmd0aCA+IGluZGV4KWlmKE9ba2V5ID0ga2V5c1tpbmRleCsrXV0gPT09IGVsKXJldHVybiBrZXk7XFxuXFx0fTtcXG5cXG4vKioqLyB9LFxcbi8qIDYyICovXFxuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XFxuXFxuXFx0Ly8gYWxsIGVudW1lcmFibGUgb2JqZWN0IGtleXMsIGluY2x1ZGVzIHN5bWJvbHNcXG5cXHR2YXIgZ2V0S2V5cyA9IF9fd2VicGFja19yZXF1aXJlX18oMzQpXFxuXFx0ICAsIGdPUFMgICAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYzKVxcblxcdCAgLCBwSUUgICAgID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2NCk7XFxuXFx0bW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCl7XFxuXFx0ICB2YXIgcmVzdWx0ICAgICA9IGdldEtleXMoaXQpXFxuXFx0ICAgICwgZ2V0U3ltYm9scyA9IGdPUFMuZjtcXG5cXHQgIGlmKGdldFN5bWJvbHMpe1xcblxcdCAgICB2YXIgc3ltYm9scyA9IGdldFN5bWJvbHMoaXQpXFxuXFx0ICAgICAgLCBpc0VudW0gID0gcElFLmZcXG5cXHQgICAgICAsIGkgICAgICAgPSAwXFxuXFx0ICAgICAgLCBrZXk7XFxuXFx0ICAgIHdoaWxlKHN5bWJvbHMubGVuZ3RoID4gaSlpZihpc0VudW0uY2FsbChpdCwga2V5ID0gc3ltYm9sc1tpKytdKSlyZXN1bHQucHVzaChrZXkpO1xcblxcdCAgfSByZXR1cm4gcmVzdWx0O1xcblxcdH07XFxuXFxuLyoqKi8gfSxcXG4vKiA2MyAqL1xcbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xcblxcblxcdGV4cG9ydHMuZiA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XFxuXFxuLyoqKi8gfSxcXG4vKiA2NCAqL1xcbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xcblxcblxcdGV4cG9ydHMuZiA9IHt9LnByb3BlcnR5SXNFbnVtZXJhYmxlO1xcblxcbi8qKiovIH0sXFxuLyogNjUgKi9cXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcXG5cXG5cXHQvLyA3LjIuMiBJc0FycmF5KGFyZ3VtZW50KVxcblxcdHZhciBjb2YgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM4KTtcXG5cXHRtb2R1bGUuZXhwb3J0cyA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gaXNBcnJheShhcmcpe1xcblxcdCAgcmV0dXJuIGNvZihhcmcpID09ICdBcnJheSc7XFxuXFx0fTtcXG5cXG4vKioqLyB9LFxcbi8qIDY2ICovXFxuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XFxuXFxuXFx0Ly8gZmFsbGJhY2sgZm9yIElFMTEgYnVnZ3kgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMgd2l0aCBpZnJhbWUgYW5kIHdpbmRvd1xcblxcdHZhciB0b0lPYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM2KVxcblxcdCAgLCBnT1BOICAgICAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDY3KS5mXFxuXFx0ICAsIHRvU3RyaW5nICA9IHt9LnRvU3RyaW5nO1xcblxcdFxcblxcdHZhciB3aW5kb3dOYW1lcyA9IHR5cGVvZiB3aW5kb3cgPT0gJ29iamVjdCcgJiYgd2luZG93ICYmIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzXFxuXFx0ICA/IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHdpbmRvdykgOiBbXTtcXG5cXHRcXG5cXHR2YXIgZ2V0V2luZG93TmFtZXMgPSBmdW5jdGlvbihpdCl7XFxuXFx0ICB0cnkge1xcblxcdCAgICByZXR1cm4gZ09QTihpdCk7XFxuXFx0ICB9IGNhdGNoKGUpe1xcblxcdCAgICByZXR1cm4gd2luZG93TmFtZXMuc2xpY2UoKTtcXG5cXHQgIH1cXG5cXHR9O1xcblxcdFxcblxcdG1vZHVsZS5leHBvcnRzLmYgPSBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eU5hbWVzKGl0KXtcXG5cXHQgIHJldHVybiB3aW5kb3dOYW1lcyAmJiB0b1N0cmluZy5jYWxsKGl0KSA9PSAnW29iamVjdCBXaW5kb3ddJyA/IGdldFdpbmRvd05hbWVzKGl0KSA6IGdPUE4odG9JT2JqZWN0KGl0KSk7XFxuXFx0fTtcXG5cXG5cXG4vKioqLyB9LFxcbi8qIDY3ICovXFxuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XFxuXFxuXFx0Ly8gMTkuMS4yLjcgLyAxNS4yLjMuNCBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhPKVxcclxcblxcdHZhciAka2V5cyAgICAgID0gX193ZWJwYWNrX3JlcXVpcmVfXygzNSlcXHJcXG5cXHQgICwgaGlkZGVuS2V5cyA9IF9fd2VicGFja19yZXF1aXJlX18oNDUpLmNvbmNhdCgnbGVuZ3RoJywgJ3Byb3RvdHlwZScpO1xcclxcblxcdFxcclxcblxcdGV4cG9ydHMuZiA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzIHx8IGZ1bmN0aW9uIGdldE93blByb3BlcnR5TmFtZXMoTyl7XFxyXFxuXFx0ICByZXR1cm4gJGtleXMoTywgaGlkZGVuS2V5cyk7XFxyXFxuXFx0fTtcXG5cXG4vKioqLyB9LFxcbi8qIDY4ICovXFxuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XFxuXFxuXFx0dmFyIHBJRSAgICAgICAgICAgID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2NClcXHJcXG5cXHQgICwgY3JlYXRlRGVzYyAgICAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI3KVxcclxcblxcdCAgLCB0b0lPYmplY3QgICAgICA9IF9fd2VicGFja19yZXF1aXJlX18oMzYpXFxyXFxuXFx0ICAsIHRvUHJpbWl0aXZlICAgID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNilcXHJcXG5cXHQgICwgaGFzICAgICAgICAgICAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI5KVxcclxcblxcdCAgLCBJRThfRE9NX0RFRklORSA9IF9fd2VicGFja19yZXF1aXJlX18oMjIpXFxyXFxuXFx0ICAsIGdPUEQgICAgICAgICAgID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcXHJcXG5cXHRcXHJcXG5cXHRleHBvcnRzLmYgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIzKSA/IGdPUEQgOiBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoTywgUCl7XFxyXFxuXFx0ICBPID0gdG9JT2JqZWN0KE8pO1xcclxcblxcdCAgUCA9IHRvUHJpbWl0aXZlKFAsIHRydWUpO1xcclxcblxcdCAgaWYoSUU4X0RPTV9ERUZJTkUpdHJ5IHtcXHJcXG5cXHQgICAgcmV0dXJuIGdPUEQoTywgUCk7XFxyXFxuXFx0ICB9IGNhdGNoKGUpeyAvKiBlbXB0eSAqLyB9XFxyXFxuXFx0ICBpZihoYXMoTywgUCkpcmV0dXJuIGNyZWF0ZURlc2MoIXBJRS5mLmNhbGwoTywgUCksIE9bUF0pO1xcclxcblxcdH07XFxuXFxuLyoqKi8gfSxcXG4vKiA2OSAqL1xcbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xcblxcblxcblxcbi8qKiovIH0sXFxuLyogNzAgKi9cXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcXG5cXG5cXHRfX3dlYnBhY2tfcmVxdWlyZV9fKDYwKSgnYXN5bmNJdGVyYXRvcicpO1xcblxcbi8qKiovIH0sXFxuLyogNzEgKi9cXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcXG5cXG5cXHRfX3dlYnBhY2tfcmVxdWlyZV9fKDYwKSgnb2JzZXJ2YWJsZScpO1xcblxcbi8qKiovIH1cXG4vKioqKioqLyBdKTtcXG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247Y2hhcnNldD11dGYtODtiYXNlNjQsZXlKMlpYSnphVzl1SWpvekxDSnpiM1Z5WTJWeklqcGJJbmRsWW5CaFkyczZMeTh2ZDJWaWNHRmpheTlpYjI5MGMzUnlZWEFnT1dVM1pEa3hZak0zTURSak4yWTNNV016WVRJaUxDSjNaV0p3WVdOck9pOHZMeTR2YzJOeWFYQjBjeTloY0drdFpYaHdiRzl5WlhJdmRqSXZjM0pqTDNObGNuWnBZMlZ6TDJwemIyNHRhR2xuYUd4cFoyaDBMMmhwWjJoc2FXZG9kRXB6YjI0dWQyOXlhMlZ5TG1weklpd2lkMlZpY0dGamF6b3ZMeTh1TDNOamNtbHdkSE12WVhCcExXVjRjR3h2Y21WeUwzWXlMM055WXk5elpYSjJhV05sY3k5cWMyOXVMV2hwWjJoc2FXZG9kQzlxYzI5dUxYQmhjbk5sTG1weklpd2lkMlZpY0dGamF6b3ZMeTh1TDM0dlltRmlaV3d0Y25WdWRHbHRaUzlqYjNKbExXcHpMMnB6YjI0dmMzUnlhVzVuYVdaNUxtcHpJaXdpZDJWaWNHRmphem92THk4dUwzNHZZMjl5WlMxcWN5OXNhV0p5WVhKNUwyWnVMMnB6YjI0dmMzUnlhVzVuYVdaNUxtcHpJaXdpZDJWaWNHRmphem92THk4dUwzNHZZMjl5WlMxcWN5OXNhV0p5WVhKNUwyMXZaSFZzWlhNdlgyTnZjbVV1YW5NaUxDSjNaV0p3WVdOck9pOHZMeTR2Zmk5aVlXSmxiQzF5ZFc1MGFXMWxMMmhsYkhCbGNuTXZkSGx3Wlc5bUxtcHpJaXdpZDJWaWNHRmphem92THk4dUwzNHZZbUZpWld3dGNuVnVkR2x0WlM5amIzSmxMV3B6TDNONWJXSnZiQzlwZEdWeVlYUnZjaTVxY3lJc0luZGxZbkJoWTJzNkx5OHZMaTkrTDJOdmNtVXRhbk12YkdsaWNtRnllUzltYmk5emVXMWliMnd2YVhSbGNtRjBiM0l1YW5NaUxDSjNaV0p3WVdOck9pOHZMeTR2Zmk5amIzSmxMV3B6TDJ4cFluSmhjbmt2Ylc5a2RXeGxjeTlsY3pZdWMzUnlhVzVuTG1sMFpYSmhkRzl5TG1weklpd2lkMlZpY0dGamF6b3ZMeTh1TDM0dlkyOXlaUzFxY3k5c2FXSnlZWEo1TDIxdlpIVnNaWE12WDNOMGNtbHVaeTFoZEM1cWN5SXNJbmRsWW5CaFkyczZMeTh2TGk5K0wyTnZjbVV0YW5NdmJHbGljbUZ5ZVM5dGIyUjFiR1Z6TDE5MGJ5MXBiblJsWjJWeUxtcHpJaXdpZDJWaWNHRmphem92THk4dUwzNHZZMjl5WlMxcWN5OXNhV0p5WVhKNUwyMXZaSFZzWlhNdlgyUmxabWx1WldRdWFuTWlMQ0ozWldKd1lXTnJPaTh2THk0dmZpOWpiM0psTFdwekwyeHBZbkpoY25rdmJXOWtkV3hsY3k5ZmFYUmxjaTFrWldacGJtVXVhbk1pTENKM1pXSndZV05yT2k4dkx5NHZmaTlqYjNKbExXcHpMMnhwWW5KaGNua3ZiVzlrZFd4bGN5OWZiR2xpY21GeWVTNXFjeUlzSW5kbFluQmhZMnM2THk4dkxpOStMMk52Y21VdGFuTXZiR2xpY21GeWVTOXRiMlIxYkdWekwxOWxlSEJ2Y25RdWFuTWlMQ0ozWldKd1lXTnJPaTh2THk0dmZpOWpiM0psTFdwekwyeHBZbkpoY25rdmJXOWtkV3hsY3k5ZloyeHZZbUZzTG1weklpd2lkMlZpY0dGamF6b3ZMeTh1TDM0dlkyOXlaUzFxY3k5c2FXSnlZWEo1TDIxdlpIVnNaWE12WDJOMGVDNXFjeUlzSW5kbFluQmhZMnM2THk4dkxpOStMMk52Y21VdGFuTXZiR2xpY21GeWVTOXRiMlIxYkdWekwxOWhMV1oxYm1OMGFXOXVMbXB6SWl3aWQyVmljR0ZqYXpvdkx5OHVMMzR2WTI5eVpTMXFjeTlzYVdKeVlYSjVMMjF2WkhWc1pYTXZYMmhwWkdVdWFuTWlMQ0ozWldKd1lXTnJPaTh2THk0dmZpOWpiM0psTFdwekwyeHBZbkpoY25rdmJXOWtkV3hsY3k5ZmIySnFaV04wTFdSd0xtcHpJaXdpZDJWaWNHRmphem92THk4dUwzNHZZMjl5WlMxcWN5OXNhV0p5WVhKNUwyMXZaSFZzWlhNdlgyRnVMVzlpYW1WamRDNXFjeUlzSW5kbFluQmhZMnM2THk4dkxpOStMMk52Y21VdGFuTXZiR2xpY21GeWVTOXRiMlIxYkdWekwxOXBjeTF2WW1wbFkzUXVhbk1pTENKM1pXSndZV05yT2k4dkx5NHZmaTlqYjNKbExXcHpMMnhwWW5KaGNua3ZiVzlrZFd4bGN5OWZhV1U0TFdSdmJTMWtaV1pwYm1VdWFuTWlMQ0ozWldKd1lXTnJPaTh2THk0dmZpOWpiM0psTFdwekwyeHBZbkpoY25rdmJXOWtkV3hsY3k5ZlpHVnpZM0pwY0hSdmNuTXVhbk1pTENKM1pXSndZV05yT2k4dkx5NHZmaTlqYjNKbExXcHpMMnhwWW5KaGNua3ZiVzlrZFd4bGN5OWZabUZwYkhNdWFuTWlMQ0ozWldKd1lXTnJPaTh2THk0dmZpOWpiM0psTFdwekwyeHBZbkpoY25rdmJXOWtkV3hsY3k5ZlpHOXRMV055WldGMFpTNXFjeUlzSW5kbFluQmhZMnM2THk4dkxpOStMMk52Y21VdGFuTXZiR2xpY21GeWVTOXRiMlIxYkdWekwxOTBieTF3Y21sdGFYUnBkbVV1YW5NaUxDSjNaV0p3WVdOck9pOHZMeTR2Zmk5amIzSmxMV3B6TDJ4cFluSmhjbmt2Ylc5a2RXeGxjeTlmY0hKdmNHVnlkSGt0WkdWell5NXFjeUlzSW5kbFluQmhZMnM2THk4dkxpOStMMk52Y21VdGFuTXZiR2xpY21GeWVTOXRiMlIxYkdWekwxOXlaV1JsWm1sdVpTNXFjeUlzSW5kbFluQmhZMnM2THk4dkxpOStMMk52Y21VdGFuTXZiR2xpY21GeWVTOXRiMlIxYkdWekwxOW9ZWE11YW5NaUxDSjNaV0p3WVdOck9pOHZMeTR2Zmk5amIzSmxMV3B6TDJ4cFluSmhjbmt2Ylc5a2RXeGxjeTlmYVhSbGNtRjBiM0p6TG1weklpd2lkMlZpY0dGamF6b3ZMeTh1TDM0dlkyOXlaUzFxY3k5c2FXSnlZWEo1TDIxdlpIVnNaWE12WDJsMFpYSXRZM0psWVhSbExtcHpJaXdpZDJWaWNHRmphem92THk4dUwzNHZZMjl5WlMxcWN5OXNhV0p5WVhKNUwyMXZaSFZzWlhNdlgyOWlhbVZqZEMxamNtVmhkR1V1YW5NaUxDSjNaV0p3WVdOck9pOHZMeTR2Zmk5amIzSmxMV3B6TDJ4cFluSmhjbmt2Ylc5a2RXeGxjeTlmYjJKcVpXTjBMV1J3Y3k1cWN5SXNJbmRsWW5CaFkyczZMeTh2TGk5K0wyTnZjbVV0YW5NdmJHbGljbUZ5ZVM5dGIyUjFiR1Z6TDE5dlltcGxZM1F0YTJWNWN5NXFjeUlzSW5kbFluQmhZMnM2THk4dkxpOStMMk52Y21VdGFuTXZiR2xpY21GeWVTOXRiMlIxYkdWekwxOXZZbXBsWTNRdGEyVjVjeTFwYm5SbGNtNWhiQzVxY3lJc0luZGxZbkJoWTJzNkx5OHZMaTkrTDJOdmNtVXRhbk12YkdsaWNtRnllUzl0YjJSMWJHVnpMMTkwYnkxcGIySnFaV04wTG1weklpd2lkMlZpY0dGamF6b3ZMeTh1TDM0dlkyOXlaUzFxY3k5c2FXSnlZWEo1TDIxdlpIVnNaWE12WDJsdlltcGxZM1F1YW5NaUxDSjNaV0p3WVdOck9pOHZMeTR2Zmk5amIzSmxMV3B6TDJ4cFluSmhjbmt2Ylc5a2RXeGxjeTlmWTI5bUxtcHpJaXdpZDJWaWNHRmphem92THk4dUwzNHZZMjl5WlMxcWN5OXNhV0p5WVhKNUwyMXZaSFZzWlhNdlgyRnljbUY1TFdsdVkyeDFaR1Z6TG1weklpd2lkMlZpY0dGamF6b3ZMeTh1TDM0dlkyOXlaUzFxY3k5c2FXSnlZWEo1TDIxdlpIVnNaWE12WDNSdkxXeGxibWQwYUM1cWN5SXNJbmRsWW5CaFkyczZMeTh2TGk5K0wyTnZjbVV0YW5NdmJHbGljbUZ5ZVM5dGIyUjFiR1Z6TDE5MGJ5MXBibVJsZUM1cWN5SXNJbmRsWW5CaFkyczZMeTh2TGk5K0wyTnZjbVV0YW5NdmJHbGljbUZ5ZVM5dGIyUjFiR1Z6TDE5emFHRnlaV1F0YTJWNUxtcHpJaXdpZDJWaWNHRmphem92THk4dUwzNHZZMjl5WlMxcWN5OXNhV0p5WVhKNUwyMXZaSFZzWlhNdlgzTm9ZWEpsWkM1cWN5SXNJbmRsWW5CaFkyczZMeTh2TGk5K0wyTnZjbVV0YW5NdmJHbGljbUZ5ZVM5dGIyUjFiR1Z6TDE5MWFXUXVhbk1pTENKM1pXSndZV05yT2k4dkx5NHZmaTlqYjNKbExXcHpMMnhwWW5KaGNua3ZiVzlrZFd4bGN5OWZaVzUxYlMxaWRXY3RhMlY1Y3k1cWN5SXNJbmRsWW5CaFkyczZMeTh2TGk5K0wyTnZjbVV0YW5NdmJHbGljbUZ5ZVM5dGIyUjFiR1Z6TDE5b2RHMXNMbXB6SWl3aWQyVmljR0ZqYXpvdkx5OHVMMzR2WTI5eVpTMXFjeTlzYVdKeVlYSjVMMjF2WkhWc1pYTXZYM05sZEMxMGJ5MXpkSEpwYm1jdGRHRm5MbXB6SWl3aWQyVmljR0ZqYXpvdkx5OHVMMzR2WTI5eVpTMXFjeTlzYVdKeVlYSjVMMjF2WkhWc1pYTXZYM2RyY3k1cWN5SXNJbmRsWW5CaFkyczZMeTh2TGk5K0wyTnZjbVV0YW5NdmJHbGljbUZ5ZVM5dGIyUjFiR1Z6TDE5dlltcGxZM1F0WjNCdkxtcHpJaXdpZDJWaWNHRmphem92THk4dUwzNHZZMjl5WlMxcWN5OXNhV0p5WVhKNUwyMXZaSFZzWlhNdlgzUnZMVzlpYW1WamRDNXFjeUlzSW5kbFluQmhZMnM2THk4dkxpOStMMk52Y21VdGFuTXZiR2xpY21GeWVTOXRiMlIxYkdWekwzZGxZaTVrYjIwdWFYUmxjbUZpYkdVdWFuTWlMQ0ozWldKd1lXTnJPaTh2THk0dmZpOWpiM0psTFdwekwyeHBZbkpoY25rdmJXOWtkV3hsY3k5bGN6WXVZWEp5WVhrdWFYUmxjbUYwYjNJdWFuTWlMQ0ozWldKd1lXTnJPaTh2THk0dmZpOWpiM0psTFdwekwyeHBZbkpoY25rdmJXOWtkV3hsY3k5ZllXUmtMWFJ2TFhWdWMyTnZjR0ZpYkdWekxtcHpJaXdpZDJWaWNHRmphem92THk4dUwzNHZZMjl5WlMxcWN5OXNhV0p5WVhKNUwyMXZaSFZzWlhNdlgybDBaWEl0YzNSbGNDNXFjeUlzSW5kbFluQmhZMnM2THk4dkxpOStMMk52Y21VdGFuTXZiR2xpY21GeWVTOXRiMlIxYkdWekwxOTNhM010WlhoMExtcHpJaXdpZDJWaWNHRmphem92THk4dUwzNHZZbUZpWld3dGNuVnVkR2x0WlM5amIzSmxMV3B6TDNONWJXSnZiQzVxY3lJc0luZGxZbkJoWTJzNkx5OHZMaTkrTDJOdmNtVXRhbk12YkdsaWNtRnllUzltYmk5emVXMWliMnd2YVc1a1pYZ3Vhbk1pTENKM1pXSndZV05yT2k4dkx5NHZmaTlqYjNKbExXcHpMMnhwWW5KaGNua3ZiVzlrZFd4bGN5OWxjell1YzNsdFltOXNMbXB6SWl3aWQyVmljR0ZqYXpvdkx5OHVMMzR2WTI5eVpTMXFjeTlzYVdKeVlYSjVMMjF2WkhWc1pYTXZYMjFsZEdFdWFuTWlMQ0ozWldKd1lXTnJPaTh2THk0dmZpOWpiM0psTFdwekwyeHBZbkpoY25rdmJXOWtkV3hsY3k5ZmQydHpMV1JsWm1sdVpTNXFjeUlzSW5kbFluQmhZMnM2THk4dkxpOStMMk52Y21VdGFuTXZiR2xpY21GeWVTOXRiMlIxYkdWekwxOXJaWGx2Wmk1cWN5SXNJbmRsWW5CaFkyczZMeTh2TGk5K0wyTnZjbVV0YW5NdmJHbGljbUZ5ZVM5dGIyUjFiR1Z6TDE5bGJuVnRMV3RsZVhNdWFuTWlMQ0ozWldKd1lXTnJPaTh2THk0dmZpOWpiM0psTFdwekwyeHBZbkpoY25rdmJXOWtkV3hsY3k5ZmIySnFaV04wTFdkdmNITXVhbk1pTENKM1pXSndZV05yT2k4dkx5NHZmaTlqYjNKbExXcHpMMnhwWW5KaGNua3ZiVzlrZFd4bGN5OWZiMkpxWldOMExYQnBaUzVxY3lJc0luZGxZbkJoWTJzNkx5OHZMaTkrTDJOdmNtVXRhbk12YkdsaWNtRnllUzl0YjJSMWJHVnpMMTlwY3kxaGNuSmhlUzVxY3lJc0luZGxZbkJoWTJzNkx5OHZMaTkrTDJOdmNtVXRhbk12YkdsaWNtRnllUzl0YjJSMWJHVnpMMTl2WW1wbFkzUXRaMjl3YmkxbGVIUXVhbk1pTENKM1pXSndZV05yT2k4dkx5NHZmaTlqYjNKbExXcHpMMnhwWW5KaGNua3ZiVzlrZFd4bGN5OWZiMkpxWldOMExXZHZjRzR1YW5NaUxDSjNaV0p3WVdOck9pOHZMeTR2Zmk5amIzSmxMV3B6TDJ4cFluSmhjbmt2Ylc5a2RXeGxjeTlmYjJKcVpXTjBMV2R2Y0dRdWFuTWlMQ0ozWldKd1lXTnJPaTh2THk0dmZpOWpiM0psTFdwekwyeHBZbkpoY25rdmJXOWtkV3hsY3k5bGN6Y3VjM2x0WW05c0xtRnplVzVqTFdsMFpYSmhkRzl5TG1weklpd2lkMlZpY0dGamF6b3ZMeTh1TDM0dlkyOXlaUzFxY3k5c2FXSnlZWEo1TDIxdlpIVnNaWE12WlhNM0xuTjViV0p2YkM1dlluTmxjblpoWW14bExtcHpJbDBzSW01aGJXVnpJanBiSW5CeVpXWnBlQ0lzSW1kbGRFVjRjR0Z1WkdWeVEyeGhjM05sY3lJc0ltVjRjR0Z1WkdWa0lpd2laVzVqYjJSbElpd2lkbUZzZFdVaUxDSnFiMmx1SWl3aVkzSmxZWFJsUld4bGJXVnVkQ0lzSW10bGVTSXNJblI1Y0dVaUxDSmxlSEJoYm1SbGNrTnNZWE56WlhNaUxDSnJiR0Z6Y3lJc0ltOXdaVzRpTENKamJHOXpaU0lzSWtGeWNtRjVJaXdpYVhOQmNuSmhlU0lzSW1wemIyNHlhSFJ0YkNJc0ltcHpiMjRpTENKb2RHMXNJaXdpYUdGelQzZHVVSEp2Y0dWeWRIa2lMQ0puWlhSS2MyOXVWbWxsZDJWeUlpd2laR0YwWVNJc0ltOXdkR2x2Ym5NaUxDSktVMDlPSWl3aWNHRnljMlVpTENKbElpd2lkRzlUZEhKcGJtY2lMQ0p0YjJSMWJHVWlMQ0psZUhCdmNuUnpJaXdpYjNCMElsMHNJbTFoY0hCcGJtZHpJam9pTzBGQlFVRTdRVUZEUVRzN1FVRkZRVHRCUVVOQk96dEJRVVZCTzBGQlEwRTdRVUZEUVRzN1FVRkZRVHRCUVVOQk8wRkJRMEVzZFVKQlFXVTdRVUZEWmp0QlFVTkJPMEZCUTBFN08wRkJSVUU3UVVGRFFUczdRVUZGUVR0QlFVTkJPenRCUVVWQk8wRkJRMEU3UVVGRFFUczdPMEZCUjBFN1FVRkRRVHM3UVVGRlFUdEJRVU5CT3p0QlFVVkJPMEZCUTBFN08wRkJSVUU3UVVGRFFUczdPenM3T3p0QlEzUkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdPMEZCUlVFN1FVRkRRVHRCUVVOQk8wRkJRMEVzY1VOQlFXOURMR1ZCUVdVN1FVRkRia1E3UVVGRFFUdEJRVU5CT3pzN096czdPenM3T3pzN096czdPenM3TzBGRFlrRXNTMEZCU1VFc1UwRkJVeXhUUVVGaU96dEJRVVZCTEV0QlFVbERMSEZDUVVGeFFpeFRRVUZ5UWtFc2EwSkJRWEZDTEVOQlFWVkRMRkZCUVZZc1JVRkJiMEk3UVVGRE5VTXNUVUZCU1N4RFFVRkRRU3hSUVVGTUxFVkJRV1U3UVVGRFpDeFZRVUZQTERKQ1FVRlFPMEZCUTBFN1FVRkRSQ3hUUVVGUExGVkJRVkE3UVVGRFFTeEZRVXhFT3p0QlFVOUJMRXRCUVVsRExGTkJRVk1zVTBGQlZFRXNUVUZCVXl4RFFVRlZReXhMUVVGV0xFVkJRV2xDTzBGQlF6ZENMRk5CUVU4c1EwRkJReXhSUVVGRUxFVkJRVmRCTEV0QlFWZ3NSVUZCYTBJc1UwRkJiRUlzUlVGQk5rSkRMRWxCUVRkQ0xFTkJRV3RETEVWQlFXeERMRU5CUVZBN1FVRkRRU3hGUVVaRU96dEJRVWxCTEV0QlFVbERMR2RDUVVGblFpeFRRVUZvUWtFc1lVRkJaMElzUTBGQlZVTXNSMEZCVml4RlFVRmxTQ3hMUVVGbUxFVkJRWE5DU1N4SlFVRjBRaXhGUVVFMFFrTXNaVUZCTlVJc1JVRkJOa003UVVGRGFFVXNUVUZCU1VNc1VVRkJVU3hSUVVGYU8wRkJRVUVzVFVGRFEwTXNUMEZCVHl4SFFVUlNPMEZCUVVFc1RVRkZRME1zVVVGQlVTeEhRVVpVT3p0QlFVbEJMRTFCUVVsRExFMUJRVTFETEU5QlFVNHNRMEZCWTFZc1MwRkJaQ3hEUVVGS0xFVkJRVEJDTzBGQlEzcENUU3hYUVVGUkxFOUJRVkk3UVVGRFFVTXNWVUZCVHl4SFFVRlFPMEZCUTBGRExGZEJRVkVzUjBGQlVqdEJRVU5CT3p0QlFVVkVMRTFCUVVsU0xGVkJRVlVzU1VGQlpDeEZRVUZ2UWp0QlFVTnVRaXhWUVVGUExFTkJRMDRzVFVGRVRTeEZRVVZNTEhGQ1FVWkxMRVZCUld0Q1JDeFBRVUZQU1N4SFFVRlFMRU5CUm14Q0xFVkJSU3RDTEZsQlJpOUNMRVZCUjB3c2MwSkJTRXNzUlVGSGJVSktMRTlCUVU5RExFdEJRVkFzUTBGSWJrSXNSVUZIYTBNc1ZVRkliRU1zUlVGSlRpeFBRVXBOTEVWQlMweERMRWxCVEVzc1EwRkxRU3hGUVV4QkxFTkJRVkE3UVVGTlFUczdRVUZGUkN4TlFVRkpSeXhSUVVGUkxGRkJRVm9zUlVGQmMwSTdRVUZEY2tJc1ZVRkJUeXhEUVVOT0xFMUJSRTBzUlVGRlRDeGxRVVpMTEVWQlJWbERMR1ZCUmxvc1JVRkZOa0lzVjBGR04wSXNSVUZIVEN4eFFrRklTeXhGUVVkclFrNHNUMEZCVDBrc1IwRkJVQ3hEUVVoc1FpeEZRVWNyUWl4aFFVZ3ZRaXhGUVVsTUxIRkNRVXBMTEVWQlNXdENTU3hKUVVwc1FpeEZRVWwzUWl4VlFVcDRRaXhGUVV0TUxHRkJURXNzUlVGTFZVUXNTMEZNVml4RlFVdHBRaXhKUVV4cVFpeEZRVTFLU3l4VlFVRlZXQ3hMUVVGV0xFVkJRV2xDU3l4bFFVRnFRaXhEUVU1SkxFVkJUMHdzVDBGUVN5eEZRVkZNTEhOQ1FWSkxMRVZCVVcxQ1J5eExRVkp1UWl4RlFWRXdRaXhUUVZJeFFpeEZRVk5PTEU5QlZFMHNSVUZWVEZBc1NVRldTeXhEUVZWQkxFVkJWa0VzUTBGQlVEdEJRVmRCT3p0QlFVVkVMRTFCUVVsSExGRkJRVkVzVVVGQlVpeEpRVUZ2UWtFc1VVRkJVU3hUUVVGb1F5eEZRVUV5UXp0QlFVTXhReXhWUVVGUExFTkJRMDRzVFVGRVRTeEZRVVZNTEhGQ1FVWkxMRVZCUld0Q1RDeFBRVUZQU1N4SFFVRlFMRU5CUm14Q0xFVkJSU3RDTEZsQlJpOUNMRVZCUjB3c1pVRklTeXhGUVVkWlF5eEpRVWhhTEVWQlIydENMRWxCU0d4Q0xFVkJSM2RDVEN4UFFVRlBReXhMUVVGUUxFTkJTSGhDTEVWQlIzVkRMRk5CU0haRExFVkJTVTRzVDBGS1RTeEZRVXRNUXl4SlFVeExMRU5CUzBFc1JVRk1RU3hEUVVGUU8wRkJUVUU3UVVGRFJDeFRRVUZQTEVOQlEwNHNUVUZFVFN4RlFVVk1MSEZDUVVaTExFVkJSV3RDUml4UFFVRlBTU3hIUVVGUUxFTkJSbXhDTEVWQlJTdENMRmxCUmk5Q0xFVkJSMHdzWlVGSVN5eEZRVWRaUXl4SlFVaGFMRVZCUjJ0Q0xFdEJTR3hDTEVWQlIzbENUQ3hQUVVGUFF5eExRVUZRTEVOQlNIcENMRVZCUjNkRExGVkJTSGhETEVWQlNVNHNUMEZLVFN4RlFVdE1ReXhKUVV4TExFTkJTMEVzUlVGTVFTeERRVUZRTzBGQlRVRXNSVUZvUkVRN08wRkJhMFJCTEV0QlFVbFZMRmxCUVZrc1UwRkJXa0VzVTBGQldTeERRVUZWUXl4SlFVRldMRVZCUVdkQ1VDeGxRVUZvUWl4RlFVRnBRenRCUVVOb1JDeE5RVUZKVVN4UFFVRlBMRVZCUVZnN1FVRkRRU3hQUVVGTExFbEJRVWxXTEVkQlFWUXNTVUZCWjBKVExFbEJRV2hDTEVWQlFYTkNPMEZCUTNKQ0xFOUJRVWtzUTBGQlEwRXNTMEZCUzBVc1kwRkJUQ3hEUVVGdlFsZ3NSMEZCY0VJc1EwRkJUQ3hGUVVFclFqdEJRVU01UWp0QlFVTkJPenRCUVVWRVZTeFZRVUZQTEVOQlFVTkJMRWxCUVVRc1JVRkJUMWdzWTBGQlkwTXNSMEZCWkN4RlFVRnRRbE1zUzBGQlMxUXNSMEZCVEN4RFFVRnVRaXgzUWtGQmNVTlRMRXRCUVV0VUxFZEJRVXdzUTBGQmNrTXNSMEZCWjBSRkxHVkJRV2hFTEVOQlFWQXNSVUZCZVVWS0xFbEJRWHBGTEVOQlFUaEZMRVZCUVRsRkxFTkJRVkE3UVVGRFFUdEJRVU5FTEZOQlFVOVpMRWxCUVZBN1FVRkRRU3hGUVZaRU96dEJRVmxCTEV0QlFVbEZMR2RDUVVGblFpeFRRVUZvUWtFc1lVRkJaMElzUTBGQlZVTXNTVUZCVml4RlFVRm5Ra01zVDBGQmFFSXNSVUZCZVVJN1FVRkROVU1zVFVGQlNUdEJRVU5JTEZWQlFVOHNRMEZEVGl4aFFVUk5MRVZCUTFOeVFpeE5RVVJVTEVWQlEybENMR05CUkdwQ0xFVkJSVXhsTEZWQlFWVXNRMEZCUTA4c1MwRkJTME1zUzBGQlRDeERRVUZYU0N4SlFVRllMRU5CUVVRc1EwRkJWaXhGUVVFNFFtNUNMRzFDUVVGdFFtOUNMRkZCUVZGdVFpeFJRVUV6UWl4RFFVRTVRaXhEUVVaTExFVkJSMDRzVDBGSVRTeEZRVWxNUnl4SlFVcExMRU5CU1VFc1JVRktRU3hEUVVGUU8wRkJTMEVzUjBGT1JDeERRVTFGTEU5QlFVOXRRaXhEUVVGUUxFVkJRVlU3UVVGRFdDeFZRVUZQTEVOQlEwNHNZMEZFVFN4RlFVTlZlRUlzVFVGRVZpeEZRVU5yUWl4WFFVUnNRaXhGUVVNclFuZENMRVZCUVVWRExGRkJRVVlzUlVGRUwwSXNSVUZETmtNc1UwRkVOME1zUlVGRlRIQkNMRWxCUmtzc1EwRkZRU3hGUVVaQkxFTkJRVkE3UVVGSFFUdEJRVU5FTEVWQldrUTdPMEZCWTBGeFFpeFJRVUZQUXl4UFFVRlFMRWRCUVdsQ0xGVkJRVk5RTEVsQlFWUXNSVUZCWlZFc1IwRkJaaXhGUVVGdlFqdEJRVU53UXl4TlFVRkpXaXhQUVVGUExFVkJRVmc3UVVGRFFTeE5RVUZKU3l4VlFVRlZUeXhQUVVGUExFVkJRVU14UWl4VlFVRlZMRWxCUVZnc1JVRkJja0k3UVVGRFFTeE5RVUZKTEU5QlFVOXJRaXhKUVVGUUxFbEJRV1VzVVVGQmJrSXNSVUZCTmtJN1FVRkROVUpLTEZWQlFVOUpMRWxCUVZBN1FVRkRRU3hIUVVaRUxFMUJSVThzU1VGQlNTeFJRVUZQUVN4SlFVRlFMSFZFUVVGUFFTeEpRVUZRTEUxQlFXVXNVVUZCYmtJc1JVRkJOa0k3UVVGRGJrTktMRlZCUVU4c2VVSkJRV1ZKTEVsQlFXWXNRMEZCVUR0QlFVTkJPMEZCUTBRc1UwRkJUMFFzWTBGQlkwZ3NTVUZCWkN4RlFVRnZRa3NzVDBGQmNFSXNRMEZCVUR0QlFVTkJMRVZCVkVRc1F6czdPenM3TzBGRGVrWkJMRzFDUVVGclFpeDFSRHM3T3pzN08wRkRRV3hDTzBGQlEwRXNkME5CUVhWRExEQkNRVUV3UWp0QlFVTnFSU3g1UTBGQmQwTTdRVUZEZUVNN1FVRkRRU3hIT3pzN096czdRVU5LUVN3NFFrRkJOa0k3UVVGRE4wSXNjME5CUVhGRExHZERPenM3T3pzN1FVTkVja003TzBGQlJVRTdPMEZCUlVFN08wRkJSVUU3TzBGQlJVRTdPMEZCUlVFN08wRkJSVUVzYTBoQlFXbElMRzFDUVVGdFFpeEZRVUZGTEcxQ1FVRnRRaXcwU2tGQk5FbzdPMEZCUlhKVUxIVkRRVUZ6UXl4MVEwRkJkVU1zWjBKQlFXZENPenRCUVVVM1JqdEJRVU5CTzBGQlEwRXNSVUZCUXp0QlFVTkVPMEZCUTBFc1J6czdPenM3TzBGRGNFSkJMRzFDUVVGclFpeDFSRHM3T3pzN08wRkRRV3hDTzBGQlEwRTdRVUZEUVN4M1JEczdPenM3TzBGRFJrRTdRVUZEUVRzN1FVRkZRVHRCUVVOQk8wRkJRMEVzT0VKQlFUWkNPMEZCUXpkQ0xHVkJRV003UVVGRFpEdEJRVU5CTEVWQlFVTTdRVUZEUkR0QlFVTkJPMEZCUTBFN1FVRkRRU3huUTBGQkswSTdRVUZETDBJN1FVRkRRVHRCUVVOQkxGZEJRVlU3UVVGRFZpeEZRVUZETEVVN096czdPenRCUTJoQ1JEdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQkxFYzdPenM3T3p0QlEyaENRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRXNSenM3T3pzN08wRkRURUU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVN4SE96czdPenM3UVVOS1FUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN08wRkJSVUVzTmtKQlFUUkNMR0ZCUVdFN08wRkJSWHBETzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRU3g1UTBGQmQwTXNiME5CUVc5RE8wRkJRelZGTERaRFFVRTBReXh2UTBGQmIwTTdRVUZEYUVZc1RVRkJTeXd5UWtGQk1rSXNiME5CUVc5RE8wRkJRM0JGTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVN4cFFrRkJaMElzYlVKQlFXMUNPMEZCUTI1RE8wRkJRMEU3UVVGRFFTeHJRMEZCYVVNc01rSkJRVEpDTzBGQlF6VkVPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRXNUVUZCU3p0QlFVTk1PMEZCUTBFN1FVRkRRU3hIT3pzN096czdRVU55UlVFc2RVSTdPenM3T3p0QlEwRkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3TzBGQlJVRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFTeHZSVUZCYlVVN1FVRkRia1U3UVVGRFFTeHpSa0ZCY1VZN1FVRkRja1k3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTEZsQlFWYzdRVUZEV0N4VlFVRlRPMEZCUTFRN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFTeE5RVUZMTzBGQlEwdzdRVUZEUVR0QlFVTkJMR2RFUVVFclF6dEJRVU12UXp0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFTeGxRVUZqTzBGQlEyUXNaVUZCWXp0QlFVTmtMR1ZCUVdNN1FVRkRaQ3hsUVVGak8wRkJRMlFzWjBKQlFXVTdRVUZEWml4blFrRkJaVHRCUVVObUxHZENRVUZsTzBGQlEyWXNhVUpCUVdkQ08wRkJRMmhDTERCQ096czdPenM3UVVNMVJFRTdRVUZEUVR0QlFVTkJPMEZCUTBFc2QwTkJRWFZETEdkRE96czdPenM3UVVOSWRrTTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVN4SE96czdPenM3UVVOdVFrRTdRVUZEUVR0QlFVTkJPMEZCUTBFc1J6czdPenM3TzBGRFNFRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRU3hGUVVGRE8wRkJRMFE3UVVGRFFUdEJRVU5CTEVjN096czdPenRCUTFCQk8wRkJRMEU3UVVGRFFUdEJRVU5CT3p0QlFVVkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTEVsQlFVY3NWVUZCVlR0QlFVTmlPMEZCUTBFN1FVRkRRVHRCUVVOQkxFYzdPenM3T3p0QlEyWkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEVzUnpzN096czdPMEZEU2tFN1FVRkRRVHRCUVVOQkxFYzdPenM3T3p0QlEwWkJPMEZCUTBFc2MwVkJRWE5GTEdkQ1FVRm5RaXhWUVVGVkxFZEJRVWM3UVVGRGJrY3NSVUZCUXl4Rk96czdPenM3UVVOR1JEdEJRVU5CTzBGQlEwRXNhME5CUVdsRExGRkJRVkVzWjBKQlFXZENMRlZCUVZVc1IwRkJSenRCUVVOMFJTeEZRVUZETEVVN096czdPenRCUTBoRU8wRkJRMEU3UVVGRFFUdEJRVU5CTEVsQlFVYzdRVUZEU0R0QlFVTkJPMEZCUTBFc1J6czdPenM3TzBGRFRrRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEVzUnpzN096czdPMEZEVGtFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQkxFYzdPenM3T3p0QlExaEJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRXNSenM3T3pzN08wRkRVRUVzTUVNN096czdPenRCUTBGQkxIZENRVUYxUWp0QlFVTjJRanRCUVVOQk8wRkJRMEVzUnpzN096czdPMEZEU0VFc2NVSTdPenM3T3p0QlEwRkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3TzBGQlJVRTdRVUZEUVN3MFJrRkJaMFlzWVVGQllTeEZRVUZGT3p0QlFVVXZSanRCUVVOQkxITkVRVUZ4UkN3d1FrRkJNRUk3UVVGREwwVTdRVUZEUVN4SE96czdPenM3UVVOYVFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFc09FSkJRVFpDTzBGQlF6ZENPenRCUVVWQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQkxEaENRVUUyUWp0QlFVTTNRanRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHM3UVVGRlFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEVzU1VGQlJ6dEJRVU5JTzBGQlEwRXNSenM3T3pzN08wRkRka05CTzBGQlEwRTdRVUZEUVRzN1FVRkZRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFc1J6czdPenM3TzBGRFdrRTdRVUZEUVR0QlFVTkJPenRCUVVWQk8wRkJRMEU3UVVGRFFTeEhPenM3T3pzN1FVTk9RVHRCUVVOQk8wRkJRMEU3UVVGRFFUczdRVUZGUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFc1J6czdPenM3TzBGRGFFSkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFTeEhPenM3T3pzN1FVTk1RVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTEVjN096czdPenRCUTBwQkxHdENRVUZwUWpzN1FVRkZha0k3UVVGRFFUdEJRVU5CTEVjN096czdPenRCUTBwQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFc1RVRkJTeXhYUVVGWExHVkJRV1U3UVVGREwwSTdRVUZEUVN4TlFVRkxPMEZCUTB3N1FVRkRRU3hIT3pzN096czdRVU53UWtFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFTdzBSRUZCTWtRN1FVRkRNMFFzUnpzN096czdPMEZEVEVFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRXNSenM3T3pzN08wRkRUa0U3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVN4SE96czdPenM3UVVOS1FUdEJRVU5CTzBGQlEwRXNiMFJCUVcxRU8wRkJRMjVFTzBGQlEwRXNkME5CUVhWRE8wRkJRM1pETEVjN096czdPenRCUTB4Qk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRXNSenM3T3pzN08wRkRTa0U3UVVGRFFUdEJRVU5CTzBGQlEwRXNZenM3T3pzN08wRkRTRUVzSzBVN096czdPenRCUTBGQk8wRkJRMEU3UVVGRFFUczdRVUZGUVR0QlFVTkJMRzFGUVVGclJTd3JRa0ZCSzBJN1FVRkRha2NzUnpzN096czdPMEZEVGtFN1FVRkRRVHRCUVVOQk8wRkJRMEU3TzBGQlJVRTdRVUZEUVR0QlFVTkJPMEZCUTBFN08wRkJSVUVzZDBJN096czdPenRCUTFaQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdPMEZCUlVFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTEVsQlFVYzdRVUZEU0N4SE96czdPenM3UVVOYVFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJMRWM3T3pzN096dEJRMHBCTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN08wRkJSVUVzZVVkQlFYZEhMRTlCUVU4N1FVRkRMMGM3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJMRVU3T3pzN096dEJRMXBCTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN08wRkJSVUU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJMR2xEUVVGblF6dEJRVU5vUXl4bFFVRmpPMEZCUTJRc2EwSkJRV2xDTzBGQlEycENPMEZCUTBFc1JVRkJRenRCUVVORU8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEVzUlVGQlF6czdRVUZGUkR0QlFVTkJPenRCUVVWQk8wRkJRMEU3UVVGRFFTdzJRanM3T3pzN08wRkRha05CTERaQ1FVRTBRaXhsT3pzN096czdRVU5CTlVJN1FVRkRRU3hYUVVGVk8wRkJRMVlzUnpzN096czdPMEZEUmtFc2NVTTdPenM3T3p0QlEwRkJMRzFDUVVGclFpeDNSRHM3T3pzN08wRkRRV3hDTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFc1owUTdPenM3T3p0QlEwcEJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJMSGRDUVVGMVFqdEJRVU4yUWp0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CT3p0QlFVVkJPMEZCUTBFN1FVRkRRU3gxUWtGQmMwSTdRVUZEZEVJc2NVSkJRVzlDTEhWQ1FVRjFRaXhUUVVGVExFbEJRVWs3UVVGRGVFUXNTVUZCUnp0QlFVTklMRVZCUVVNN1FVRkRSRHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTEVWQlFVTTdPMEZCUlVRN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUczdRVUZGUVR0QlFVTkJPMEZCUTBFc1JVRkJRenRCUVVORU8wRkJRMEU3TzBGQlJVRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFTd3dSRUZCZVVRN1FVRkRla1E3UVVGRFFTeE5RVUZMTzBGQlEwdzdRVUZEUVN4MVFrRkJjMElzYVVOQlFXbERPMEZCUTNaRUxFMUJRVXM3UVVGRFRDeEpRVUZITzBGQlEwZzdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEVzU1VGQlJ6dEJRVU5JTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTEVsQlFVYzdRVUZEU0RzN1FVRkZRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQkxDdEVRVUU0UkN3NFFrRkJPRUk3UVVGRE5VWTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRU3hKUVVGSE96dEJRVVZJTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN08wRkJSVUU3UVVGRFFUdEJRVU5CT3p0QlFVVkJPMEZCUTBFN1FVRkRRVHRCUVVOQk96dEJRVVZCTERKRVFVRXdSQ3huUWtGQlowSTdPMEZCUlRGRk8wRkJRMEU3UVVGRFFUdEJRVU5CTEhGQ1FVRnZRaXh2UWtGQmIwSTdPMEZCUlhoRExESkRRVUV3UXl4dlFrRkJiMEk3TzBGQlJUbEVPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTEVsQlFVYzdRVUZEU0R0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQkxFbEJRVWM3UVVGRFNDeDVRa0ZCZDBJc1pVRkJaU3hGUVVGRk8wRkJRM3BETEhsQ1FVRjNRaXhuUWtGQlowSTdRVUZEZUVNc1JVRkJRenM3UVVGRlJEdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJMRVZCUVVNN08wRkJSVVE3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFc2NVUkJRVzlFTEV0QlFVc3NVVUZCVVN4cFEwRkJhVU03UVVGRGJFY3NSVUZCUXp0QlFVTkVPMEZCUTBFc1owUkJRU3RETzBGQlF5OURPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEVzUlVGQlF6czdRVUZGUkR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTERKRE96czdPenM3UVVNeFQwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRXNhMFJCUVdsRU8wRkJRMnBFTEVWQlFVTTdRVUZEUkR0QlFVTkJMSE5DUVVGeFFqdEJRVU55UWp0QlFVTkJMRlZCUVZNN1FVRkRWQ3hMUVVGSk8wRkJRMG83UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRXNTVUZCUnp0QlFVTklPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFc1NVRkJSenRCUVVOSU8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTEVjN096czdPenRCUTNCRVFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRU3d5UkVGQk1FUXNjMEpCUVhOQ08wRkJRMmhHTEdsR1FVRm5SaXh6UWtGQmMwSTdRVUZEZEVjc1J6czdPenM3TzBGRFVrRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRXNSenM3T3pzN08wRkRWRUU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVN4SlFVRkhPMEZCUTBnc1J6czdPenM3TzBGRFpFRXNNRU03T3pzN096dEJRMEZCTEdWQlFXTXNjMEk3T3pzN096dEJRMEZrTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFc1J6czdPenM3TzBGRFNrRTdRVUZEUVR0QlFVTkJPMEZCUTBFc2JVSkJRV3RDT3p0QlFVVnNRanRCUVVOQk96dEJRVVZCTzBGQlEwRTdRVUZEUVR0QlFVTkJMRWxCUVVjN1FVRkRTRHRCUVVOQk8wRkJRMEU3TzBGQlJVRTdRVUZEUVR0QlFVTkJPenM3T3pzN08wRkRiRUpCTzBGQlEwRTdRVUZEUVRzN1FVRkZRVHRCUVVOQk8wRkJRMEVzUnpzN096czdPMEZEVGtFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdPMEZCUlVFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTEVsQlFVY3NWVUZCVlR0QlFVTmlPMEZCUTBFc1J6czdPenM3T3pzN096czdPMEZEWmtFc01FTTdPenM3T3p0QlEwRkJMSFZESWl3aVptbHNaU0k2SW1ocFoyaHNhV2RvZEVwemIyNHVkMjl5YTJWeUxtcHpJaXdpYzI5MWNtTmxjME52Ym5SbGJuUWlPbHNpSUZ4MEx5OGdWR2hsSUcxdlpIVnNaU0JqWVdOb1pWeHVJRngwZG1GeUlHbHVjM1JoYkd4bFpFMXZaSFZzWlhNZ1BTQjdmVHRjYmx4dUlGeDBMeThnVkdobElISmxjWFZwY21VZ1puVnVZM1JwYjI1Y2JpQmNkR1oxYm1OMGFXOXVJRjlmZDJWaWNHRmphMTl5WlhGMWFYSmxYMThvYlc5a2RXeGxTV1FwSUh0Y2JseHVJRngwWEhRdkx5QkRhR1ZqYXlCcFppQnRiMlIxYkdVZ2FYTWdhVzRnWTJGamFHVmNiaUJjZEZ4MGFXWW9hVzV6ZEdGc2JHVmtUVzlrZFd4bGMxdHRiMlIxYkdWSlpGMHBYRzRnWEhSY2RGeDBjbVYwZFhKdUlHbHVjM1JoYkd4bFpFMXZaSFZzWlhOYmJXOWtkV3hsU1dSZExtVjRjRzl5ZEhNN1hHNWNiaUJjZEZ4MEx5OGdRM0psWVhSbElHRWdibVYzSUcxdlpIVnNaU0FvWVc1a0lIQjFkQ0JwZENCcGJuUnZJSFJvWlNCallXTm9aU2xjYmlCY2RGeDBkbUZ5SUcxdlpIVnNaU0E5SUdsdWMzUmhiR3hsWkUxdlpIVnNaWE5iYlc5a2RXeGxTV1JkSUQwZ2UxeHVJRngwWEhSY2RHVjRjRzl5ZEhNNklIdDlMRnh1SUZ4MFhIUmNkR2xrT2lCdGIyUjFiR1ZKWkN4Y2JpQmNkRngwWEhSc2IyRmtaV1E2SUdaaGJITmxYRzRnWEhSY2RIMDdYRzVjYmlCY2RGeDBMeThnUlhobFkzVjBaU0IwYUdVZ2JXOWtkV3hsSUdaMWJtTjBhVzl1WEc0Z1hIUmNkRzF2WkhWc1pYTmJiVzlrZFd4bFNXUmRMbU5oYkd3b2JXOWtkV3hsTG1WNGNHOXlkSE1zSUcxdlpIVnNaU3dnYlc5a2RXeGxMbVY0Y0c5eWRITXNJRjlmZDJWaWNHRmphMTl5WlhGMWFYSmxYMThwTzF4dVhHNGdYSFJjZEM4dklFWnNZV2NnZEdobElHMXZaSFZzWlNCaGN5QnNiMkZrWldSY2JpQmNkRngwYlc5a2RXeGxMbXh2WVdSbFpDQTlJSFJ5ZFdVN1hHNWNiaUJjZEZ4MEx5OGdVbVYwZFhKdUlIUm9aU0JsZUhCdmNuUnpJRzltSUhSb1pTQnRiMlIxYkdWY2JpQmNkRngwY21WMGRYSnVJRzF2WkhWc1pTNWxlSEJ2Y25Sek8xeHVJRngwZlZ4dVhHNWNiaUJjZEM4dklHVjRjRzl6WlNCMGFHVWdiVzlrZFd4bGN5QnZZbXBsWTNRZ0tGOWZkMlZpY0dGamExOXRiMlIxYkdWelgxOHBYRzRnWEhSZlgzZGxZbkJoWTJ0ZmNtVnhkV2x5WlY5ZkxtMGdQU0J0YjJSMWJHVnpPMXh1WEc0Z1hIUXZMeUJsZUhCdmMyVWdkR2hsSUcxdlpIVnNaU0JqWVdOb1pWeHVJRngwWDE5M1pXSndZV05yWDNKbGNYVnBjbVZmWHk1aklEMGdhVzV6ZEdGc2JHVmtUVzlrZFd4bGN6dGNibHh1SUZ4MEx5OGdYMTkzWldKd1lXTnJYM0IxWW14cFkxOXdZWFJvWDE5Y2JpQmNkRjlmZDJWaWNHRmphMTl5WlhGMWFYSmxYMTh1Y0NBOUlGd2lYQ0k3WEc1Y2JpQmNkQzh2SUV4dllXUWdaVzUwY25rZ2JXOWtkV3hsSUdGdVpDQnlaWFIxY200Z1pYaHdiM0owYzF4dUlGeDBjbVYwZFhKdUlGOWZkMlZpY0dGamExOXlaWEYxYVhKbFgxOG9NQ2s3WEc1Y2JseHVYRzR2THlCWFJVSlFRVU5MSUVaUFQxUkZVaUF2TDF4dUx5OGdkMlZpY0dGamF5OWliMjkwYzNSeVlYQWdPV1UzWkRreFlqTTNNRFJqTjJZM01XTXpZVElpTENJdktpcGNjbHh1SUNvZ1EyOWtaU0JtYjNKdFlYUWdkMlZpTFhkdmNtdGxjbHh5WEc0Z0tpQkFjR0Z5WVcwZ1pYWmxiblJjY2x4dUlDb3ZYSEpjYmk4dklIWmhjaUJvYVdkb2JHbG5hSFJLYzI5dUtDbGNjbHh1ZG1GeUlHaHBaMmhzYVdkb2RFcHpiMjRnUFNCeVpYRjFhWEpsS0NjdUwycHpiMjR0Y0dGeWMyVW5LVHRjY2x4dVhISmNibTl1YldWemMyRm5aU0E5SUdaMWJtTjBhVzl1S0dWMlpXNTBLU0I3WEhKY2JpQWdkbUZ5SUdOdlpHVWdQU0JsZG1WdWRDNWtZWFJoTzF4eVhHNGdJQzh2SUdsdGNHOXlkRk5qY21sd2RITW9KMnB6YjI0dGNHRnljMlV1YW5NbktUdGNjbHh1SUNCMllYSWdjbVZ6ZFd4MElEMGdhR2xuYUd4cFoyaDBTbk52YmloamIyUmxMQ0I3Wlhod1lXNWtaV1E2SUhSeWRXVjlLVHRjY2x4dUlDQXZMeUIyWVhJZ2NtVnpkV3gwSUQxS1UwOU9Mbk4wY21sdVoybG1lU2hqYjJSbEtUdGNjbHh1SUNCd2IzTjBUV1Z6YzJGblpTaHlaWE4xYkhRcE8xeHlYRzU5TzF4eVhHNWNibHh1WEc0dkx5OHZMeTh2THk4dkx5OHZMeTh2THk5Y2JpOHZJRmRGUWxCQlEwc2dSazlQVkVWU1hHNHZMeUF1TDNOamNtbHdkSE12WVhCcExXVjRjR3h2Y21WeUwzWXlMM055WXk5elpYSjJhV05sY3k5cWMyOXVMV2hwWjJoc2FXZG9kQzlvYVdkb2JHbG5hSFJLYzI5dUxuZHZjbXRsY2k1cWMxeHVMeThnYlc5a2RXeGxJR2xrSUQwZ01GeHVMeThnYlc5a2RXeGxJR05vZFc1cmN5QTlJREFpTENKMllYSWdjSEpsWm1sNElEMGdKM1J0TFdOdlpHVW5PMXh5WEc1Y2NseHVkbUZ5SUdkbGRFVjRjR0Z1WkdWeVEyeGhjM05sY3lBOUlHWjFibU4wYVc5dUlDaGxlSEJoYm1SbFpDa2dlMXh5WEc1Y2RHbG1JQ2doWlhod1lXNWtaV1FwSUh0Y2NseHVYSFJjZEhKbGRIVnliaUFuWlhod1lXNWtaV1FnWTI5c2JHRndjMlZrSUdocFpHUmxiaWM3WEhKY2JseDBmVnh5WEc1Y2RISmxkSFZ5YmlBblpYaHdZVzVrWldRbk8xeHlYRzU5TzF4eVhHNWNjbHh1ZG1GeUlHVnVZMjlrWlNBOUlHWjFibU4wYVc5dUlDaDJZV3gxWlNrZ2UxeHlYRzVjZEhKbGRIVnliaUJiSnp4emNHRnVQaWNzSUhaaGJIVmxMQ0FuUEM5emNHRnVQaWRkTG1wdmFXNG9KeWNwTzF4eVhHNTlPMXh5WEc1Y2NseHVkbUZ5SUdOeVpXRjBaVVZzWlcxbGJuUWdQU0JtZFc1amRHbHZiaUFvYTJWNUxDQjJZV3gxWlN3Z2RIbHdaU3dnWlhod1lXNWtaWEpEYkdGemMyVnpLU0I3WEhKY2JseDBkbUZ5SUd0c1lYTnpJRDBnSjI5aWFtVmpkQ2NzWEhKY2JseDBYSFJ2Y0dWdUlEMGdKM3NuTEZ4eVhHNWNkRngwWTJ4dmMyVWdQU0FuZlNjN1hISmNibHh5WEc1Y2RHbG1JQ2hCY25KaGVTNXBjMEZ5Y21GNUtIWmhiSFZsS1NrZ2UxeHlYRzVjZEZ4MGEyeGhjM01nUFNBbllYSnlZWGtuTzF4eVhHNWNkRngwYjNCbGJpQTlJQ2RiSnp0Y2NseHVYSFJjZEdOc2IzTmxJRDBnSjEwbk8xeHlYRzVjZEgxY2NseHVYSEpjYmx4MGFXWWdLSFpoYkhWbElEMDlQU0J1ZFd4c0tTQjdYSEpjYmx4MFhIUnlaWFIxY200Z1cxeHlYRzVjZEZ4MFhIUW5QR3hwUGljc1hISmNibHgwWEhSY2RGeDBKenh6Y0dGdUlHTnNZWE56UFZ3aWEyVjVYQ0krWENJbkxDQmxibU52WkdVb2EyVjVLU3dnSjF3aU9pQThMM053WVc0K0p5eGNjbHh1WEhSY2RGeDBYSFFuUEhOd1lXNGdZMnhoYzNNOVhDSnVkV3hzWENJK1hDSW5MQ0JsYm1OdlpHVW9kbUZzZFdVcExDQW5YQ0k4TDNOd1lXNCtKeXhjY2x4dVhIUmNkRngwSnp3dmJHaytKMXh5WEc1Y2RGeDBYUzVxYjJsdUtDY25LVHRjY2x4dVhIUjlYSEpjYmx4eVhHNWNkR2xtSUNoMGVYQmxJRDA5SUNkdlltcGxZM1FuS1NCN1hISmNibHgwWEhSeVpYUjFjbTRnVzF4eVhHNWNkRngwWEhRblBHeHBQaWNzWEhKY2JseDBYSFJjZEZ4MEp6eHpjR0Z1SUdOc1lYTnpQVndpSnl3Z1pYaHdZVzVrWlhKRGJHRnpjMlZ6TENBblhDSStQQzl6Y0dGdVBpY3NYSEpjYmx4MFhIUmNkRngwSnp4emNHRnVJR05zWVhOelBWd2lhMlY1WENJK1hDSW5MQ0JsYm1OdlpHVW9hMlY1S1N3Z0oxd2lPaUE4TDNOd1lXNCtJQ2NzWEhKY2JseDBYSFJjZEZ4MEp6eHpjR0Z1SUdOc1lYTnpQVndpYjNCbGJsd2lQaWNzSUc5d1pXNHNJQ2M4TDNOd1lXNCtJQ2NzWEhKY2JseDBYSFJjZEZ4MEp6eDFiQ0JqYkdGemN6MWNJaWNzSUd0c1lYTnpMQ0FuWENJK0p5eGNjbHh1WEhSY2RGeDBYSFJjZEdwemIyNHlhSFJ0YkNoMllXeDFaU3dnWlhod1lXNWtaWEpEYkdGemMyVnpLU3hjY2x4dVhIUmNkRngwWEhRblBDOTFiRDRuTEZ4eVhHNWNkRngwWEhSY2RDYzhjM0JoYmlCamJHRnpjejFjSW1Oc2IzTmxYQ0krSnl3Z1kyeHZjMlVzSUNjOEwzTndZVzQrSnl4Y2NseHVYSFJjZEZ4MEp6d3ZiR2srSjF4eVhHNWNkRngwWFM1cWIybHVLQ2NuS1R0Y2NseHVYSFI5WEhKY2JseHlYRzVjZEdsbUlDaDBlWEJsSUQwOUlDZHVkVzFpWlhJbklIeDhJSFI1Y0dVZ1BUMGdKMkp2YjJ4bFlXNG5LU0I3WEhKY2JseDBYSFJ5WlhSMWNtNGdXMXh5WEc1Y2RGeDBYSFFuUEd4cFBpY3NYSEpjYmx4MFhIUmNkRngwSnp4emNHRnVJR05zWVhOelBWd2lhMlY1WENJK1hDSW5MQ0JsYm1OdlpHVW9hMlY1S1N3Z0oxd2lPaUE4TDNOd1lXNCtKeXhjY2x4dVhIUmNkRngwWEhRblBITndZVzRnWTJ4aGMzTTlYQ0luTENCMGVYQmxMQ0FuWENJK0p5d2daVzVqYjJSbEtIWmhiSFZsS1N3Z0p6d3ZjM0JoYmo0bkxGeHlYRzVjZEZ4MFhIUW5QQzlzYVQ0blhISmNibHgwWEhSZExtcHZhVzRvSnljcE8xeHlYRzVjZEgxY2NseHVYSFJ5WlhSMWNtNGdXMXh5WEc1Y2RGeDBKenhzYVQ0bkxGeHlYRzVjZEZ4MFhIUW5QSE53WVc0Z1kyeGhjM005WENKclpYbGNJajVjSWljc0lHVnVZMjlrWlNoclpYa3BMQ0FuWENJNklEd3ZjM0JoYmo0bkxGeHlYRzVjZEZ4MFhIUW5QSE53WVc0Z1kyeGhjM005WENJbkxDQjBlWEJsTENBblhDSStYQ0luTENCbGJtTnZaR1VvZG1Gc2RXVXBMQ0FuWENJOEwzTndZVzQrSnl4Y2NseHVYSFJjZENjOEwyeHBQaWRjY2x4dVhIUmRMbXB2YVc0b0p5Y3BPMXh5WEc1OU8xeHlYRzVjY2x4dWRtRnlJR3B6YjI0eWFIUnRiQ0E5SUdaMWJtTjBhVzl1SUNocWMyOXVMQ0JsZUhCaGJtUmxja05zWVhOelpYTXBJSHRjY2x4dVhIUjJZWElnYUhSdGJDQTlJQ2NuTzF4eVhHNWNkR1p2Y2lBb2RtRnlJR3RsZVNCcGJpQnFjMjl1S1NCN1hISmNibHgwWEhScFppQW9JV3B6YjI0dWFHRnpUM2R1VUhKdmNHVnlkSGtvYTJWNUtTa2dlMXh5WEc1Y2RGeDBYSFJqYjI1MGFXNTFaVHRjY2x4dVhIUmNkSDFjY2x4dVhISmNibHgwWEhSb2RHMXNJRDBnVzJoMGJXd3NJR055WldGMFpVVnNaVzFsYm5Rb2EyVjVMQ0JxYzI5dVcydGxlVjBzSUhSNWNHVnZaaUJxYzI5dVcydGxlVjBzSUdWNGNHRnVaR1Z5UTJ4aGMzTmxjeWxkTG1wdmFXNG9KeWNwTzF4eVhHNWNkSDFjY2x4dVhIUnlaWFIxY200Z2FIUnRiRHRjY2x4dWZUdGNjbHh1WEhKY2JuWmhjaUJuWlhSS2MyOXVWbWxsZDJWeUlEMGdablZ1WTNScGIyNGdLR1JoZEdFc0lHOXdkR2x2Ym5NcElIdGNjbHh1WEhSMGNua2dlMXh5WEc1Y2RGeDBjbVYwZFhKdUlGdGNjbHh1WEhSY2RGeDBKengxYkNCamJHRnpjejFjSWljc0lIQnlaV1pwZUN3Z0p5MWpiMjUwWVdsdVpYSmNJajRuTEZ4eVhHNWNkRngwWEhSY2RHcHpiMjR5YUhSdGJDaGJTbE5QVGk1d1lYSnpaU2hrWVhSaEtWMHNJR2RsZEVWNGNHRnVaR1Z5UTJ4aGMzTmxjeWh2Y0hScGIyNXpMbVY0Y0dGdVpHVmtLU2tzWEhKY2JseDBYSFJjZENjOEwzVnNQaWRjY2x4dVhIUmNkRjB1YW05cGJpZ25KeWs3WEhKY2JseDBmU0JqWVhSamFDQW9aU2tnZTF4eVhHNWNkRngwY21WMGRYSnVJRnRjY2x4dVhIUmNkRngwSnp4a2FYWWdZMnhoYzNNOVhDSW5MQ0J3Y21WbWFYZ3NJQ2N0WlhKeWIzSmNJaUErSnl3Z1pTNTBiMU4wY21sdVp5Z3BMQ0FuSUR3dlpHbDJQaWRjY2x4dVhIUmNkRjB1YW05cGJpZ25KeWs3WEhKY2JseDBmVnh5WEc1OU8xeHlYRzVjY2x4dWJXOWtkV3hsTG1WNGNHOXlkSE1nUFNCbWRXNWpkR2x2Ymloa1lYUmhMQ0J2Y0hRcElIdGNjbHh1WEhSMllYSWdhbk52YmlBOUlDY25PMXh5WEc1Y2RIWmhjaUJ2Y0hScGIyNXpJRDBnYjNCMElIeDhJSHRsZUhCaGJtUmxaRG9nZEhKMVpYMDdYSEpjYmx4MGFXWWdLSFI1Y0dWdlppQmtZWFJoSUQwOUlDZHpkSEpwYm1jbktTQjdYSEpjYmx4MFhIUnFjMjl1SUQwZ1pHRjBZVHRjY2x4dVhIUjlJR1ZzYzJVZ2FXWWdLSFI1Y0dWdlppQmtZWFJoSUQwOUlDZHZZbXBsWTNRbktTQjdYSEpjYmx4MFhIUnFjMjl1SUQwZ1NsTlBUaTV6ZEhKcGJtZHBabmtvWkdGMFlTbGNjbHh1WEhSOVhISmNibHgwY21WMGRYSnVJR2RsZEVwemIyNVdhV1YzWlhJb2FuTnZiaXdnYjNCMGFXOXVjeWs3WEhKY2JuMDdYSEpjYmx4dVhHNWNiaTh2SUZkRlFsQkJRMHNnUms5UFZFVlNJQzh2WEc0dkx5QXVMM05qY21sd2RITXZZWEJwTFdWNGNHeHZjbVZ5TDNZeUwzTnlZeTl6WlhKMmFXTmxjeTlxYzI5dUxXaHBaMmhzYVdkb2RDOXFjMjl1TFhCaGNuTmxMbXB6SWl3aWJXOWtkV3hsTG1WNGNHOXlkSE1nUFNCN0lGd2laR1ZtWVhWc2RGd2lPaUJ5WlhGMWFYSmxLRndpWTI5eVpTMXFjeTlzYVdKeVlYSjVMMlp1TDJwemIyNHZjM1J5YVc1bmFXWjVYQ0lwTENCZlgyVnpUVzlrZFd4bE9pQjBjblZsSUgwN1hHNWNibHh1THk4dkx5OHZMeTh2THk4dkx5OHZMeTh2WEc0dkx5QlhSVUpRUVVOTElFWlBUMVJGVWx4dUx5OGdMaTkrTDJKaFltVnNMWEoxYm5ScGJXVXZZMjl5WlMxcWN5OXFjMjl1TDNOMGNtbHVaMmxtZVM1cWMxeHVMeThnYlc5a2RXeGxJR2xrSUQwZ01seHVMeThnYlc5a2RXeGxJR05vZFc1cmN5QTlJREFpTENKMllYSWdZMjl5WlNBZ1BTQnlaWEYxYVhKbEtDY3VMaTh1TGk5dGIyUjFiR1Z6TDE5amIzSmxKeWxjYmlBZ0xDQWtTbE5QVGlBOUlHTnZjbVV1U2xOUFRpQjhmQ0FvWTI5eVpTNUtVMDlPSUQwZ2UzTjBjbWx1WjJsbWVUb2dTbE5QVGk1emRISnBibWRwWm5sOUtUdGNibTF2WkhWc1pTNWxlSEJ2Y25SeklEMGdablZ1WTNScGIyNGdjM1J5YVc1bmFXWjVLR2wwS1hzZ0x5OGdaWE5zYVc1MExXUnBjMkZpYkdVdGJHbHVaU0J1YnkxMWJuVnpaV1F0ZG1GeWMxeHVJQ0J5WlhSMWNtNGdKRXBUVDA0dWMzUnlhVzVuYVdaNUxtRndjR3g1S0NSS1UwOU9MQ0JoY21kMWJXVnVkSE1wTzF4dWZUdGNibHh1WEc0dkx5OHZMeTh2THk4dkx5OHZMeTh2THk5Y2JpOHZJRmRGUWxCQlEwc2dSazlQVkVWU1hHNHZMeUF1TDM0dlkyOXlaUzFxY3k5c2FXSnlZWEo1TDJadUwycHpiMjR2YzNSeWFXNW5hV1o1TG1welhHNHZMeUJ0YjJSMWJHVWdhV1FnUFNBelhHNHZMeUJ0YjJSMWJHVWdZMmgxYm10eklEMGdNQ0lzSW5aaGNpQmpiM0psSUQwZ2JXOWtkV3hsTG1WNGNHOXlkSE1nUFNCN2RtVnljMmx2YmpvZ0p6SXVOQzR3SjMwN1hHNXBaaWgwZVhCbGIyWWdYMTlsSUQwOUlDZHVkVzFpWlhJbktWOWZaU0E5SUdOdmNtVTdJQzh2SUdWemJHbHVkQzFrYVhOaFlteGxMV3hwYm1VZ2JtOHRkVzVrWldaY2JseHVYRzR2THk4dkx5OHZMeTh2THk4dkx5OHZMeTljYmk4dklGZEZRbEJCUTBzZ1JrOVBWRVZTWEc0dkx5QXVMMzR2WTI5eVpTMXFjeTlzYVdKeVlYSjVMMjF2WkhWc1pYTXZYMk52Y21VdWFuTmNiaTh2SUcxdlpIVnNaU0JwWkNBOUlEUmNiaTh2SUcxdlpIVnNaU0JqYUhWdWEzTWdQU0F3SWl3aVhDSjFjMlVnYzNSeWFXTjBYQ0k3WEc1Y2JtVjRjRzl5ZEhNdVgxOWxjMDF2WkhWc1pTQTlJSFJ5ZFdVN1hHNWNiblpoY2lCZmFYUmxjbUYwYjNJZ1BTQnlaWEYxYVhKbEtGd2lMaTR2WTI5eVpTMXFjeTl6ZVcxaWIyd3ZhWFJsY21GMGIzSmNJaWs3WEc1Y2JuWmhjaUJmYVhSbGNtRjBiM0l5SUQwZ1gybHVkR1Z5YjNCU1pYRjFhWEpsUkdWbVlYVnNkQ2hmYVhSbGNtRjBiM0lwTzF4dVhHNTJZWElnWDNONWJXSnZiQ0E5SUhKbGNYVnBjbVVvWENJdUxpOWpiM0psTFdwekwzTjViV0p2YkZ3aUtUdGNibHh1ZG1GeUlGOXplVzFpYjJ3eUlEMGdYMmx1ZEdWeWIzQlNaWEYxYVhKbFJHVm1ZWFZzZENoZmMzbHRZbTlzS1R0Y2JseHVkbUZ5SUY5MGVYQmxiMllnUFNCMGVYQmxiMllnWDNONWJXSnZiREl1WkdWbVlYVnNkQ0E5UFQwZ1hDSm1kVzVqZEdsdmJsd2lJQ1ltSUhSNWNHVnZaaUJmYVhSbGNtRjBiM0l5TG1SbFptRjFiSFFnUFQwOUlGd2ljM2x0WW05c1hDSWdQeUJtZFc1amRHbHZiaUFvYjJKcUtTQjdJSEpsZEhWeWJpQjBlWEJsYjJZZ2IySnFPeUI5SURvZ1puVnVZM1JwYjI0Z0tHOWlhaWtnZXlCeVpYUjFjbTRnYjJKcUlDWW1JSFI1Y0dWdlppQmZjM2x0WW05c01pNWtaV1poZFd4MElEMDlQU0JjSW1aMWJtTjBhVzl1WENJZ0ppWWdiMkpxTG1OdmJuTjBjblZqZEc5eUlEMDlQU0JmYzNsdFltOXNNaTVrWldaaGRXeDBJQ1ltSUc5aWFpQWhQVDBnWDNONWJXSnZiREl1WkdWbVlYVnNkQzV3Y205MGIzUjVjR1VnUHlCY0luTjViV0p2YkZ3aUlEb2dkSGx3Wlc5bUlHOWlhanNnZlR0Y2JseHVablZ1WTNScGIyNGdYMmx1ZEdWeWIzQlNaWEYxYVhKbFJHVm1ZWFZzZENodlltb3BJSHNnY21WMGRYSnVJRzlpYWlBbUppQnZZbW91WDE5bGMwMXZaSFZzWlNBL0lHOWlhaUE2SUhzZ1pHVm1ZWFZzZERvZ2IySnFJSDA3SUgxY2JseHVaWGh3YjNKMGN5NWtaV1poZFd4MElEMGdkSGx3Wlc5bUlGOXplVzFpYjJ3eUxtUmxabUYxYkhRZ1BUMDlJRndpWm5WdVkzUnBiMjVjSWlBbUppQmZkSGx3Wlc5bUtGOXBkR1Z5WVhSdmNqSXVaR1ZtWVhWc2RDa2dQVDA5SUZ3aWMzbHRZbTlzWENJZ1B5Qm1kVzVqZEdsdmJpQW9iMkpxS1NCN1hHNGdJSEpsZEhWeWJpQjBlWEJsYjJZZ2IySnFJRDA5UFNCY0luVnVaR1ZtYVc1bFpGd2lJRDhnWENKMWJtUmxabWx1WldSY0lpQTZJRjkwZVhCbGIyWW9iMkpxS1R0Y2JuMGdPaUJtZFc1amRHbHZiaUFvYjJKcUtTQjdYRzRnSUhKbGRIVnliaUJ2WW1vZ0ppWWdkSGx3Wlc5bUlGOXplVzFpYjJ3eUxtUmxabUYxYkhRZ1BUMDlJRndpWm5WdVkzUnBiMjVjSWlBbUppQnZZbW91WTI5dWMzUnlkV04wYjNJZ1BUMDlJRjl6ZVcxaWIyd3lMbVJsWm1GMWJIUWdKaVlnYjJKcUlDRTlQU0JmYzNsdFltOXNNaTVrWldaaGRXeDBMbkJ5YjNSdmRIbHdaU0EvSUZ3aWMzbHRZbTlzWENJZ09pQjBlWEJsYjJZZ2IySnFJRDA5UFNCY0luVnVaR1ZtYVc1bFpGd2lJRDhnWENKMWJtUmxabWx1WldSY0lpQTZJRjkwZVhCbGIyWW9iMkpxS1R0Y2JuMDdYRzVjYmx4dUx5OHZMeTh2THk4dkx5OHZMeTh2THk4dlhHNHZMeUJYUlVKUVFVTkxJRVpQVDFSRlVseHVMeThnTGk5K0wySmhZbVZzTFhKMWJuUnBiV1V2YUdWc2NHVnljeTkwZVhCbGIyWXVhbk5jYmk4dklHMXZaSFZzWlNCcFpDQTlJRFZjYmk4dklHMXZaSFZzWlNCamFIVnVhM01nUFNBd0lpd2liVzlrZFd4bExtVjRjRzl5ZEhNZ1BTQjdJRndpWkdWbVlYVnNkRndpT2lCeVpYRjFhWEpsS0Z3aVkyOXlaUzFxY3k5c2FXSnlZWEo1TDJadUwzTjViV0p2YkM5cGRHVnlZWFJ2Y2x3aUtTd2dYMTlsYzAxdlpIVnNaVG9nZEhKMVpTQjlPMXh1WEc1Y2JpOHZMeTh2THk4dkx5OHZMeTh2THk4dkwxeHVMeThnVjBWQ1VFRkRTeUJHVDA5VVJWSmNiaTh2SUM0dmZpOWlZV0psYkMxeWRXNTBhVzFsTDJOdmNtVXRhbk12YzNsdFltOXNMMmwwWlhKaGRHOXlMbXB6WEc0dkx5QnRiMlIxYkdVZ2FXUWdQU0EyWEc0dkx5QnRiMlIxYkdVZ1kyaDFibXR6SUQwZ01DSXNJbkpsY1hWcGNtVW9KeTR1THk0dUwyMXZaSFZzWlhNdlpYTTJMbk4wY21sdVp5NXBkR1Z5WVhSdmNpY3BPMXh1Y21WeGRXbHlaU2duTGk0dkxpNHZiVzlrZFd4bGN5OTNaV0l1Wkc5dExtbDBaWEpoWW14bEp5azdYRzV0YjJSMWJHVXVaWGh3YjNKMGN5QTlJSEpsY1hWcGNtVW9KeTR1THk0dUwyMXZaSFZzWlhNdlgzZHJjeTFsZUhRbktTNW1LQ2RwZEdWeVlYUnZjaWNwTzF4dVhHNWNiaTh2THk4dkx5OHZMeTh2THk4dkx5OHZMMXh1THk4Z1YwVkNVRUZEU3lCR1QwOVVSVkpjYmk4dklDNHZmaTlqYjNKbExXcHpMMnhwWW5KaGNua3ZabTR2YzNsdFltOXNMMmwwWlhKaGRHOXlMbXB6WEc0dkx5QnRiMlIxYkdVZ2FXUWdQU0EzWEc0dkx5QnRiMlIxYkdVZ1kyaDFibXR6SUQwZ01DSXNJaWQxYzJVZ2MzUnlhV04wSnp0Y2JuWmhjaUFrWVhRZ0lEMGdjbVZ4ZFdseVpTZ25MaTlmYzNSeWFXNW5MV0YwSnlrb2RISjFaU2s3WEc1Y2JpOHZJREl4TGpFdU15NHlOeUJUZEhKcGJtY3VjSEp2ZEc5MGVYQmxXMEJBYVhSbGNtRjBiM0pkS0NsY2JuSmxjWFZwY21Vb0p5NHZYMmwwWlhJdFpHVm1hVzVsSnlrb1UzUnlhVzVuTENBblUzUnlhVzVuSnl3Z1puVnVZM1JwYjI0b2FYUmxjbUYwWldRcGUxeHVJQ0IwYUdsekxsOTBJRDBnVTNSeWFXNW5LR2wwWlhKaGRHVmtLVHNnTHk4Z2RHRnlaMlYwWEc0Z0lIUm9hWE11WDJrZ1BTQXdPeUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQXZMeUJ1WlhoMElHbHVaR1Y0WEc0dkx5QXlNUzR4TGpVdU1pNHhJQ1ZUZEhKcGJtZEpkR1Z5WVhSdmNsQnliM1J2ZEhsd1pTVXVibVY0ZENncFhHNTlMQ0JtZFc1amRHbHZiaWdwZTF4dUlDQjJZWElnVHlBZ0lDQWdQU0IwYUdsekxsOTBYRzRnSUNBZ0xDQnBibVJsZUNBOUlIUm9hWE11WDJsY2JpQWdJQ0FzSUhCdmFXNTBPMXh1SUNCcFppaHBibVJsZUNBK1BTQlBMbXhsYm1kMGFDbHlaWFIxY200Z2UzWmhiSFZsT2lCMWJtUmxabWx1WldRc0lHUnZibVU2SUhSeWRXVjlPMXh1SUNCd2IybHVkQ0E5SUNSaGRDaFBMQ0JwYm1SbGVDazdYRzRnSUhSb2FYTXVYMmtnS3owZ2NHOXBiblF1YkdWdVozUm9PMXh1SUNCeVpYUjFjbTRnZTNaaGJIVmxPaUJ3YjJsdWRDd2daRzl1WlRvZ1ptRnNjMlY5TzF4dWZTazdYRzVjYmx4dUx5OHZMeTh2THk4dkx5OHZMeTh2THk4dlhHNHZMeUJYUlVKUVFVTkxJRVpQVDFSRlVseHVMeThnTGk5K0wyTnZjbVV0YW5NdmJHbGljbUZ5ZVM5dGIyUjFiR1Z6TDJWek5pNXpkSEpwYm1jdWFYUmxjbUYwYjNJdWFuTmNiaTh2SUcxdlpIVnNaU0JwWkNBOUlEaGNiaTh2SUcxdlpIVnNaU0JqYUhWdWEzTWdQU0F3SWl3aWRtRnlJSFJ2U1c1MFpXZGxjaUE5SUhKbGNYVnBjbVVvSnk0dlgzUnZMV2x1ZEdWblpYSW5LVnh1SUNBc0lHUmxabWx1WldRZ0lDQTlJSEpsY1hWcGNtVW9KeTR2WDJSbFptbHVaV1FuS1R0Y2JpOHZJSFJ5ZFdVZ0lDMCtJRk4wY21sdVp5TmhkRnh1THk4Z1ptRnNjMlVnTFQ0Z1UzUnlhVzVuSTJOdlpHVlFiMmx1ZEVGMFhHNXRiMlIxYkdVdVpYaHdiM0owY3lBOUlHWjFibU4wYVc5dUtGUlBYMU5VVWtsT1J5bDdYRzRnSUhKbGRIVnliaUJtZFc1amRHbHZiaWgwYUdGMExDQndiM01wZTF4dUlDQWdJSFpoY2lCeklEMGdVM1J5YVc1bktHUmxabWx1WldRb2RHaGhkQ2twWEc0Z0lDQWdJQ0FzSUdrZ1BTQjBiMGx1ZEdWblpYSW9jRzl6S1Z4dUlDQWdJQ0FnTENCc0lEMGdjeTVzWlc1bmRHaGNiaUFnSUNBZ0lDd2dZU3dnWWp0Y2JpQWdJQ0JwWmlocElEd2dNQ0I4ZkNCcElENDlJR3dwY21WMGRYSnVJRlJQWDFOVVVrbE9SeUEvSUNjbklEb2dkVzVrWldacGJtVmtPMXh1SUNBZ0lHRWdQU0J6TG1Ob1lYSkRiMlJsUVhRb2FTazdYRzRnSUNBZ2NtVjBkWEp1SUdFZ1BDQXdlR1E0TURBZ2ZId2dZU0ErSURCNFpHSm1aaUI4ZkNCcElDc2dNU0E5UFQwZ2JDQjhmQ0FvWWlBOUlITXVZMmhoY2tOdlpHVkJkQ2hwSUNzZ01Ta3BJRHdnTUhoa1l6QXdJSHg4SUdJZ1BpQXdlR1JtWm1aY2JpQWdJQ0FnSUQ4Z1ZFOWZVMVJTU1U1SElEOGdjeTVqYUdGeVFYUW9hU2tnT2lCaFhHNGdJQ0FnSUNBNklGUlBYMU5VVWtsT1J5QS9JSE11YzJ4cFkyVW9hU3dnYVNBcklESXBJRG9nS0dFZ0xTQXdlR1E0TURBZ1BEd2dNVEFwSUNzZ0tHSWdMU0F3ZUdSak1EQXBJQ3NnTUhneE1EQXdNRHRjYmlBZ2ZUdGNibjA3WEc1Y2JseHVMeTh2THk4dkx5OHZMeTh2THk4dkx5OHZYRzR2THlCWFJVSlFRVU5MSUVaUFQxUkZVbHh1THk4Z0xpOStMMk52Y21VdGFuTXZiR2xpY21GeWVTOXRiMlIxYkdWekwxOXpkSEpwYm1jdFlYUXVhbk5jYmk4dklHMXZaSFZzWlNCcFpDQTlJRGxjYmk4dklHMXZaSFZzWlNCamFIVnVhM01nUFNBd0lpd2lMeThnTnk0eExqUWdWRzlKYm5SbFoyVnlYRzUyWVhJZ1kyVnBiQ0FnUFNCTllYUm9MbU5sYVd4Y2JpQWdMQ0JtYkc5dmNpQTlJRTFoZEdndVpteHZiM0k3WEc1dGIyUjFiR1V1Wlhod2IzSjBjeUE5SUdaMWJtTjBhVzl1S0dsMEtYdGNiaUFnY21WMGRYSnVJR2x6VG1GT0tHbDBJRDBnSzJsMEtTQS9JREFnT2lBb2FYUWdQaUF3SUQ4Z1pteHZiM0lnT2lCalpXbHNLU2hwZENrN1hHNTlPMXh1WEc1Y2JpOHZMeTh2THk4dkx5OHZMeTh2THk4dkwxeHVMeThnVjBWQ1VFRkRTeUJHVDA5VVJWSmNiaTh2SUM0dmZpOWpiM0psTFdwekwyeHBZbkpoY25rdmJXOWtkV3hsY3k5ZmRHOHRhVzUwWldkbGNpNXFjMXh1THk4Z2JXOWtkV3hsSUdsa0lEMGdNVEJjYmk4dklHMXZaSFZzWlNCamFIVnVhM01nUFNBd0lpd2lMeThnTnk0eUxqRWdVbVZ4ZFdseVpVOWlhbVZqZEVOdlpYSmphV0pzWlNoaGNtZDFiV1Z1ZENsY2JtMXZaSFZzWlM1bGVIQnZjblJ6SUQwZ1puVnVZM1JwYjI0b2FYUXBlMXh1SUNCcFppaHBkQ0E5UFNCMWJtUmxabWx1WldRcGRHaHliM2NnVkhsd1pVVnljbTl5S0Z3aVEyRnVKM1FnWTJGc2JDQnRaWFJvYjJRZ2IyNGdJRndpSUNzZ2FYUXBPMXh1SUNCeVpYUjFjbTRnYVhRN1hHNTlPMXh1WEc1Y2JpOHZMeTh2THk4dkx5OHZMeTh2THk4dkwxeHVMeThnVjBWQ1VFRkRTeUJHVDA5VVJWSmNiaTh2SUM0dmZpOWpiM0psTFdwekwyeHBZbkpoY25rdmJXOWtkV3hsY3k5ZlpHVm1hVzVsWkM1cWMxeHVMeThnYlc5a2RXeGxJR2xrSUQwZ01URmNiaTh2SUcxdlpIVnNaU0JqYUhWdWEzTWdQU0F3SWl3aUozVnpaU0J6ZEhKcFkzUW5PMXh1ZG1GeUlFeEpRbEpCVWxrZ0lDQWdJQ0FnSUQwZ2NtVnhkV2x5WlNnbkxpOWZiR2xpY21GeWVTY3BYRzRnSUN3Z0pHVjRjRzl5ZENBZ0lDQWdJQ0FnUFNCeVpYRjFhWEpsS0NjdUwxOWxlSEJ2Y25RbktWeHVJQ0FzSUhKbFpHVm1hVzVsSUNBZ0lDQWdJRDBnY21WeGRXbHlaU2duTGk5ZmNtVmtaV1pwYm1VbktWeHVJQ0FzSUdocFpHVWdJQ0FnSUNBZ0lDQWdJRDBnY21WeGRXbHlaU2duTGk5ZmFHbGtaU2NwWEc0Z0lDd2dhR0Z6SUNBZ0lDQWdJQ0FnSUNBZ1BTQnlaWEYxYVhKbEtDY3VMMTlvWVhNbktWeHVJQ0FzSUVsMFpYSmhkRzl5Y3lBZ0lDQWdJRDBnY21WeGRXbHlaU2duTGk5ZmFYUmxjbUYwYjNKekp5bGNiaUFnTENBa2FYUmxja055WldGMFpTQWdJQ0E5SUhKbGNYVnBjbVVvSnk0dlgybDBaWEl0WTNKbFlYUmxKeWxjYmlBZ0xDQnpaWFJVYjFOMGNtbHVaMVJoWnlBOUlISmxjWFZwY21Vb0p5NHZYM05sZEMxMGJ5MXpkSEpwYm1jdGRHRm5KeWxjYmlBZ0xDQm5aWFJRY205MGIzUjVjR1ZQWmlBOUlISmxjWFZwY21Vb0p5NHZYMjlpYW1WamRDMW5jRzhuS1Z4dUlDQXNJRWxVUlZKQlZFOVNJQ0FnSUNBZ0lEMGdjbVZ4ZFdseVpTZ25MaTlmZDJ0ekp5a29KMmwwWlhKaGRHOXlKeWxjYmlBZ0xDQkNWVWRIV1NBZ0lDQWdJQ0FnSUNBOUlDRW9XMTB1YTJWNWN5QW1KaUFuYm1WNGRDY2dhVzRnVzEwdWEyVjVjeWdwS1NBdkx5QlRZV1poY21rZ2FHRnpJR0oxWjJkNUlHbDBaWEpoZEc5eWN5QjNMMjhnWUc1bGVIUmdYRzRnSUN3Z1JrWmZTVlJGVWtGVVQxSWdJQ0FnUFNBblFFQnBkR1Z5WVhSdmNpZGNiaUFnTENCTFJWbFRJQ0FnSUNBZ0lDQWdJQ0E5SUNkclpYbHpKMXh1SUNBc0lGWkJURlZGVXlBZ0lDQWdJQ0FnSUQwZ0ozWmhiSFZsY3ljN1hHNWNiblpoY2lCeVpYUjFjbTVVYUdseklEMGdablZ1WTNScGIyNG9LWHNnY21WMGRYSnVJSFJvYVhNN0lIMDdYRzVjYm0xdlpIVnNaUzVsZUhCdmNuUnpJRDBnWm5WdVkzUnBiMjRvUW1GelpTd2dUa0ZOUlN3Z1EyOXVjM1J5ZFdOMGIzSXNJRzVsZUhRc0lFUkZSa0ZWVEZRc0lFbFRYMU5GVkN3Z1JrOVNRMFZFS1h0Y2JpQWdKR2wwWlhKRGNtVmhkR1VvUTI5dWMzUnlkV04wYjNJc0lFNUJUVVVzSUc1bGVIUXBPMXh1SUNCMllYSWdaMlYwVFdWMGFHOWtJRDBnWm5WdVkzUnBiMjRvYTJsdVpDbDdYRzRnSUNBZ2FXWW9JVUpWUjBkWklDWW1JR3RwYm1RZ2FXNGdjSEp2ZEc4cGNtVjBkWEp1SUhCeWIzUnZXMnRwYm1SZE8xeHVJQ0FnSUhOM2FYUmphQ2hyYVc1a0tYdGNiaUFnSUNBZ0lHTmhjMlVnUzBWWlV6b2djbVYwZFhKdUlHWjFibU4wYVc5dUlHdGxlWE1vS1hzZ2NtVjBkWEp1SUc1bGR5QkRiMjV6ZEhKMVkzUnZjaWgwYUdsekxDQnJhVzVrS1RzZ2ZUdGNiaUFnSUNBZ0lHTmhjMlVnVmtGTVZVVlRPaUJ5WlhSMWNtNGdablZ1WTNScGIyNGdkbUZzZFdWektDbDdJSEpsZEhWeWJpQnVaWGNnUTI5dWMzUnlkV04wYjNJb2RHaHBjeXdnYTJsdVpDazdJSDA3WEc0Z0lDQWdmU0J5WlhSMWNtNGdablZ1WTNScGIyNGdaVzUwY21sbGN5Z3BleUJ5WlhSMWNtNGdibVYzSUVOdmJuTjBjblZqZEc5eUtIUm9hWE1zSUd0cGJtUXBPeUI5TzF4dUlDQjlPMXh1SUNCMllYSWdWRUZISUNBZ0lDQWdJQ0E5SUU1QlRVVWdLeUFuSUVsMFpYSmhkRzl5SjF4dUlDQWdJQ3dnUkVWR1gxWkJURlZGVXlBOUlFUkZSa0ZWVEZRZ1BUMGdWa0ZNVlVWVFhHNGdJQ0FnTENCV1FVeFZSVk5mUWxWSElEMGdabUZzYzJWY2JpQWdJQ0FzSUhCeWIzUnZJQ0FnSUNBZ1BTQkNZWE5sTG5CeWIzUnZkSGx3WlZ4dUlDQWdJQ3dnSkc1aGRHbDJaU0FnSUNBOUlIQnliM1J2VzBsVVJWSkJWRTlTWFNCOGZDQndjbTkwYjF0R1JsOUpWRVZTUVZSUFVsMGdmSHdnUkVWR1FWVk1WQ0FtSmlCd2NtOTBiMXRFUlVaQlZVeFVYVnh1SUNBZ0lDd2dKR1JsWm1GMWJIUWdJQ0E5SUNSdVlYUnBkbVVnZkh3Z1oyVjBUV1YwYUc5a0tFUkZSa0ZWVEZRcFhHNGdJQ0FnTENBa1pXNTBjbWxsY3lBZ0lEMGdSRVZHUVZWTVZDQS9JQ0ZFUlVaZlZrRk1WVVZUSUQ4Z0pHUmxabUYxYkhRZ09pQm5aWFJOWlhSb2IyUW9KMlZ1ZEhKcFpYTW5LU0E2SUhWdVpHVm1hVzVsWkZ4dUlDQWdJQ3dnSkdGdWVVNWhkR2wyWlNBOUlFNUJUVVVnUFQwZ0owRnljbUY1SnlBL0lIQnliM1J2TG1WdWRISnBaWE1nZkh3Z0pHNWhkR2wyWlNBNklDUnVZWFJwZG1WY2JpQWdJQ0FzSUcxbGRHaHZaSE1zSUd0bGVTd2dTWFJsY21GMGIzSlFjbTkwYjNSNWNHVTdYRzRnSUM4dklFWnBlQ0J1WVhScGRtVmNiaUFnYVdZb0pHRnVlVTVoZEdsMlpTbDdYRzRnSUNBZ1NYUmxjbUYwYjNKUWNtOTBiM1I1Y0dVZ1BTQm5aWFJRY205MGIzUjVjR1ZQWmlna1lXNTVUbUYwYVhabExtTmhiR3dvYm1WM0lFSmhjMlVwS1R0Y2JpQWdJQ0JwWmloSmRHVnlZWFJ2Y2xCeWIzUnZkSGx3WlNBaFBUMGdUMkpxWldOMExuQnliM1J2ZEhsd1pTbDdYRzRnSUNBZ0lDQXZMeUJUWlhRZ1FFQjBiMU4wY21sdVoxUmhaeUIwYnlCdVlYUnBkbVVnYVhSbGNtRjBiM0p6WEc0Z0lDQWdJQ0J6WlhSVWIxTjBjbWx1WjFSaFp5aEpkR1Z5WVhSdmNsQnliM1J2ZEhsd1pTd2dWRUZITENCMGNuVmxLVHRjYmlBZ0lDQWdJQzh2SUdacGVDQm1iM0lnYzI5dFpTQnZiR1FnWlc1bmFXNWxjMXh1SUNBZ0lDQWdhV1lvSVV4SlFsSkJVbGtnSmlZZ0lXaGhjeWhKZEdWeVlYUnZjbEJ5YjNSdmRIbHdaU3dnU1ZSRlVrRlVUMUlwS1docFpHVW9TWFJsY21GMGIzSlFjbTkwYjNSNWNHVXNJRWxVUlZKQlZFOVNMQ0J5WlhSMWNtNVVhR2x6S1R0Y2JpQWdJQ0I5WEc0Z0lIMWNiaUFnTHk4Z1ptbDRJRUZ5Y21GNUkzdDJZV3gxWlhNc0lFQkFhWFJsY21GMGIzSjlMbTVoYldVZ2FXNGdWamdnTHlCR1JseHVJQ0JwWmloRVJVWmZWa0ZNVlVWVElDWW1JQ1J1WVhScGRtVWdKaVlnSkc1aGRHbDJaUzV1WVcxbElDRTlQU0JXUVV4VlJWTXBlMXh1SUNBZ0lGWkJURlZGVTE5Q1ZVY2dQU0IwY25WbE8xeHVJQ0FnSUNSa1pXWmhkV3gwSUQwZ1puVnVZM1JwYjI0Z2RtRnNkV1Z6S0NsN0lISmxkSFZ5YmlBa2JtRjBhWFpsTG1OaGJHd29kR2hwY3lrN0lIMDdYRzRnSUgxY2JpQWdMeThnUkdWbWFXNWxJR2wwWlhKaGRHOXlYRzRnSUdsbUtDZ2hURWxDVWtGU1dTQjhmQ0JHVDFKRFJVUXBJQ1ltSUNoQ1ZVZEhXU0I4ZkNCV1FVeFZSVk5mUWxWSElIeDhJQ0Z3Y205MGIxdEpWRVZTUVZSUFVsMHBLWHRjYmlBZ0lDQm9hV1JsS0hCeWIzUnZMQ0JKVkVWU1FWUlBVaXdnSkdSbFptRjFiSFFwTzF4dUlDQjlYRzRnSUM4dklGQnNkV2NnWm05eUlHeHBZbkpoY25sY2JpQWdTWFJsY21GMGIzSnpXMDVCVFVWZElEMGdKR1JsWm1GMWJIUTdYRzRnSUVsMFpYSmhkRzl5YzF0VVFVZGRJQ0E5SUhKbGRIVnlibFJvYVhNN1hHNGdJR2xtS0VSRlJrRlZURlFwZTF4dUlDQWdJRzFsZEdodlpITWdQU0I3WEc0Z0lDQWdJQ0IyWVd4MVpYTTZJQ0JFUlVaZlZrRk1WVVZUSUQ4Z0pHUmxabUYxYkhRZ09pQm5aWFJOWlhSb2IyUW9Wa0ZNVlVWVEtTeGNiaUFnSUNBZ0lHdGxlWE02SUNBZ0lFbFRYMU5GVkNBZ0lDQWdQeUFrWkdWbVlYVnNkQ0E2SUdkbGRFMWxkR2h2WkNoTFJWbFRLU3hjYmlBZ0lDQWdJR1Z1ZEhKcFpYTTZJQ1JsYm5SeWFXVnpYRzRnSUNBZ2ZUdGNiaUFnSUNCcFppaEdUMUpEUlVRcFptOXlLR3RsZVNCcGJpQnRaWFJvYjJSektYdGNiaUFnSUNBZ0lHbG1LQ0VvYTJWNUlHbHVJSEJ5YjNSdktTbHlaV1JsWm1sdVpTaHdjbTkwYnl3Z2EyVjVMQ0J0WlhSb2IyUnpXMnRsZVYwcE8xeHVJQ0FnSUgwZ1pXeHpaU0FrWlhod2IzSjBLQ1JsZUhCdmNuUXVVQ0FySUNSbGVIQnZjblF1UmlBcUlDaENWVWRIV1NCOGZDQldRVXhWUlZOZlFsVkhLU3dnVGtGTlJTd2diV1YwYUc5a2N5azdYRzRnSUgxY2JpQWdjbVYwZFhKdUlHMWxkR2h2WkhNN1hHNTlPMXh1WEc1Y2JpOHZMeTh2THk4dkx5OHZMeTh2THk4dkwxeHVMeThnVjBWQ1VFRkRTeUJHVDA5VVJWSmNiaTh2SUM0dmZpOWpiM0psTFdwekwyeHBZbkpoY25rdmJXOWtkV3hsY3k5ZmFYUmxjaTFrWldacGJtVXVhbk5jYmk4dklHMXZaSFZzWlNCcFpDQTlJREV5WEc0dkx5QnRiMlIxYkdVZ1kyaDFibXR6SUQwZ01DSXNJbTF2WkhWc1pTNWxlSEJ2Y25SeklEMGdkSEoxWlR0Y2JseHVYRzR2THk4dkx5OHZMeTh2THk4dkx5OHZMeTljYmk4dklGZEZRbEJCUTBzZ1JrOVBWRVZTWEc0dkx5QXVMMzR2WTI5eVpTMXFjeTlzYVdKeVlYSjVMMjF2WkhWc1pYTXZYMnhwWW5KaGNua3Vhbk5jYmk4dklHMXZaSFZzWlNCcFpDQTlJREV6WEc0dkx5QnRiMlIxYkdVZ1kyaDFibXR6SUQwZ01DSXNJblpoY2lCbmJHOWlZV3dnSUNBZ1BTQnlaWEYxYVhKbEtDY3VMMTluYkc5aVlXd25LVnh1SUNBc0lHTnZjbVVnSUNBZ0lDQTlJSEpsY1hWcGNtVW9KeTR2WDJOdmNtVW5LVnh1SUNBc0lHTjBlQ0FnSUNBZ0lDQTlJSEpsY1hWcGNtVW9KeTR2WDJOMGVDY3BYRzRnSUN3Z2FHbGtaU0FnSUNBZ0lEMGdjbVZ4ZFdseVpTZ25MaTlmYUdsa1pTY3BYRzRnSUN3Z1VGSlBWRTlVV1ZCRklEMGdKM0J5YjNSdmRIbHdaU2M3WEc1Y2JuWmhjaUFrWlhod2IzSjBJRDBnWm5WdVkzUnBiMjRvZEhsd1pTd2dibUZ0WlN3Z2MyOTFjbU5sS1h0Y2JpQWdkbUZ5SUVsVFgwWlBVa05GUkNBOUlIUjVjR1VnSmlBa1pYaHdiM0owTGtaY2JpQWdJQ0FzSUVsVFgwZE1UMEpCVENBOUlIUjVjR1VnSmlBa1pYaHdiM0owTGtkY2JpQWdJQ0FzSUVsVFgxTlVRVlJKUXlBOUlIUjVjR1VnSmlBa1pYaHdiM0owTGxOY2JpQWdJQ0FzSUVsVFgxQlNUMVJQSUNBOUlIUjVjR1VnSmlBa1pYaHdiM0owTGxCY2JpQWdJQ0FzSUVsVFgwSkpUa1FnSUNBOUlIUjVjR1VnSmlBa1pYaHdiM0owTGtKY2JpQWdJQ0FzSUVsVFgxZFNRVkFnSUNBOUlIUjVjR1VnSmlBa1pYaHdiM0owTGxkY2JpQWdJQ0FzSUdWNGNHOXlkSE1nSUNBOUlFbFRYMGRNVDBKQlRDQS9JR052Y21VZ09pQmpiM0psVzI1aGJXVmRJSHg4SUNoamIzSmxXMjVoYldWZElEMGdlMzBwWEc0Z0lDQWdMQ0JsZUhCUWNtOTBieUFnUFNCbGVIQnZjblJ6VzFCU1QxUlBWRmxRUlYxY2JpQWdJQ0FzSUhSaGNtZGxkQ0FnSUNBOUlFbFRYMGRNVDBKQlRDQS9JR2RzYjJKaGJDQTZJRWxUWDFOVVFWUkpReUEvSUdkc2IySmhiRnR1WVcxbFhTQTZJQ2huYkc5aVlXeGJibUZ0WlYwZ2ZId2dlMzBwVzFCU1QxUlBWRmxRUlYxY2JpQWdJQ0FzSUd0bGVTd2diM2R1TENCdmRYUTdYRzRnSUdsbUtFbFRYMGRNVDBKQlRDbHpiM1Z5WTJVZ1BTQnVZVzFsTzF4dUlDQm1iM0lvYTJWNUlHbHVJSE52ZFhKalpTbDdYRzRnSUNBZ0x5OGdZMjl1ZEdGcGJuTWdhVzRnYm1GMGFYWmxYRzRnSUNBZ2IzZHVJRDBnSVVsVFgwWlBVa05GUkNBbUppQjBZWEpuWlhRZ0ppWWdkR0Z5WjJWMFcydGxlVjBnSVQwOUlIVnVaR1ZtYVc1bFpEdGNiaUFnSUNCcFppaHZkMjRnSmlZZ2EyVjVJR2x1SUdWNGNHOXlkSE1wWTI5dWRHbHVkV1U3WEc0Z0lDQWdMeThnWlhod2IzSjBJRzVoZEdsMlpTQnZjaUJ3WVhOelpXUmNiaUFnSUNCdmRYUWdQU0J2ZDI0Z1B5QjBZWEpuWlhSYmEyVjVYU0E2SUhOdmRYSmpaVnRyWlhsZE8xeHVJQ0FnSUM4dklIQnlaWFpsYm5RZ1oyeHZZbUZzSUhCdmJHeDFkR2x2YmlCbWIzSWdibUZ0WlhOd1lXTmxjMXh1SUNBZ0lHVjRjRzl5ZEhOYmEyVjVYU0E5SUVsVFgwZE1UMEpCVENBbUppQjBlWEJsYjJZZ2RHRnlaMlYwVzJ0bGVWMGdJVDBnSjJaMWJtTjBhVzl1SnlBL0lITnZkWEpqWlZ0clpYbGRYRzRnSUNBZ0x5OGdZbWx1WkNCMGFXMWxjbk1nZEc4Z1oyeHZZbUZzSUdadmNpQmpZV3hzSUdaeWIyMGdaWGh3YjNKMElHTnZiblJsZUhSY2JpQWdJQ0E2SUVsVFgwSkpUa1FnSmlZZ2IzZHVJRDhnWTNSNEtHOTFkQ3dnWjJ4dlltRnNLVnh1SUNBZ0lDOHZJSGR5WVhBZ1oyeHZZbUZzSUdOdmJuTjBjblZqZEc5eWN5Qm1iM0lnY0hKbGRtVnVkQ0JqYUdGdVoyVWdkR2hsYlNCcGJpQnNhV0p5WVhKNVhHNGdJQ0FnT2lCSlUxOVhVa0ZRSUNZbUlIUmhjbWRsZEZ0clpYbGRJRDA5SUc5MWRDQS9JQ2htZFc1amRHbHZiaWhES1h0Y2JpQWdJQ0FnSUhaaGNpQkdJRDBnWm5WdVkzUnBiMjRvWVN3Z1lpd2dZeWw3WEc0Z0lDQWdJQ0FnSUdsbUtIUm9hWE1nYVc1emRHRnVZMlZ2WmlCREtYdGNiaUFnSUNBZ0lDQWdJQ0J6ZDJsMFkyZ29ZWEpuZFcxbGJuUnpMbXhsYm1kMGFDbDdYRzRnSUNBZ0lDQWdJQ0FnSUNCallYTmxJREE2SUhKbGRIVnliaUJ1WlhjZ1F6dGNiaUFnSUNBZ0lDQWdJQ0FnSUdOaGMyVWdNVG9nY21WMGRYSnVJRzVsZHlCREtHRXBPMXh1SUNBZ0lDQWdJQ0FnSUNBZ1kyRnpaU0F5T2lCeVpYUjFjbTRnYm1WM0lFTW9ZU3dnWWlrN1hHNGdJQ0FnSUNBZ0lDQWdmU0J5WlhSMWNtNGdibVYzSUVNb1lTd2dZaXdnWXlrN1hHNGdJQ0FnSUNBZ0lIMGdjbVYwZFhKdUlFTXVZWEJ3Ykhrb2RHaHBjeXdnWVhKbmRXMWxiblJ6S1R0Y2JpQWdJQ0FnSUgwN1hHNGdJQ0FnSUNCR1cxQlNUMVJQVkZsUVJWMGdQU0JEVzFCU1QxUlBWRmxRUlYwN1hHNGdJQ0FnSUNCeVpYUjFjbTRnUmp0Y2JpQWdJQ0F2THlCdFlXdGxJSE4wWVhScFl5QjJaWEp6YVc5dWN5Qm1iM0lnY0hKdmRHOTBlWEJsSUcxbGRHaHZaSE5jYmlBZ0lDQjlLU2h2ZFhRcElEb2dTVk5mVUZKUFZFOGdKaVlnZEhsd1pXOW1JRzkxZENBOVBTQW5ablZ1WTNScGIyNG5JRDhnWTNSNEtFWjFibU4wYVc5dUxtTmhiR3dzSUc5MWRDa2dPaUJ2ZFhRN1hHNGdJQ0FnTHk4Z1pYaHdiM0owSUhCeWIzUnZJRzFsZEdodlpITWdkRzhnWTI5eVpTNGxRMDlPVTFSU1ZVTlVUMUlsTG0xbGRHaHZaSE11SlU1QlRVVWxYRzRnSUNBZ2FXWW9TVk5mVUZKUFZFOHBlMXh1SUNBZ0lDQWdLR1Y0Y0c5eWRITXVkbWx5ZEhWaGJDQjhmQ0FvWlhod2IzSjBjeTUyYVhKMGRXRnNJRDBnZTMwcEtWdHJaWGxkSUQwZ2IzVjBPMXh1SUNBZ0lDQWdMeThnWlhod2IzSjBJSEJ5YjNSdklHMWxkR2h2WkhNZ2RHOGdZMjl5WlM0bFEwOU9VMVJTVlVOVVQxSWxMbkJ5YjNSdmRIbHdaUzRsVGtGTlJTVmNiaUFnSUNBZ0lHbG1LSFI1Y0dVZ0ppQWtaWGh3YjNKMExsSWdKaVlnWlhod1VISnZkRzhnSmlZZ0lXVjRjRkJ5YjNSdlcydGxlVjBwYUdsa1pTaGxlSEJRY205MGJ5d2dhMlY1TENCdmRYUXBPMXh1SUNBZ0lIMWNiaUFnZlZ4dWZUdGNiaTh2SUhSNWNHVWdZbWwwYldGd1hHNGtaWGh3YjNKMExrWWdQU0F4T3lBZ0lDOHZJR1p2Y21ObFpGeHVKR1Y0Y0c5eWRDNUhJRDBnTWpzZ0lDQXZMeUJuYkc5aVlXeGNiaVJsZUhCdmNuUXVVeUE5SURRN0lDQWdMeThnYzNSaGRHbGpYRzRrWlhod2IzSjBMbEFnUFNBNE95QWdJQzh2SUhCeWIzUnZYRzRrWlhod2IzSjBMa0lnUFNBeE5qc2dJQzh2SUdKcGJtUmNiaVJsZUhCdmNuUXVWeUE5SURNeU95QWdMeThnZDNKaGNGeHVKR1Y0Y0c5eWRDNVZJRDBnTmpRN0lDQXZMeUJ6WVdabFhHNGtaWGh3YjNKMExsSWdQU0F4TWpnN0lDOHZJSEpsWVd3Z2NISnZkRzhnYldWMGFHOWtJR1p2Y2lCZ2JHbGljbUZ5ZVdBZ1hHNXRiMlIxYkdVdVpYaHdiM0owY3lBOUlDUmxlSEJ2Y25RN1hHNWNibHh1THk4dkx5OHZMeTh2THk4dkx5OHZMeTh2WEc0dkx5QlhSVUpRUVVOTElFWlBUMVJGVWx4dUx5OGdMaTkrTDJOdmNtVXRhbk12YkdsaWNtRnllUzl0YjJSMWJHVnpMMTlsZUhCdmNuUXVhbk5jYmk4dklHMXZaSFZzWlNCcFpDQTlJREUwWEc0dkx5QnRiMlIxYkdVZ1kyaDFibXR6SUQwZ01DSXNJaTh2SUdoMGRIQnpPaTh2WjJsMGFIVmlMbU52YlM5NmJHOXBjbTlqYXk5amIzSmxMV3B6TDJsemMzVmxjeTg0TmlOcGMzTjFaV052YlcxbGJuUXRNVEUxTnpVNU1ESTRYRzUyWVhJZ1oyeHZZbUZzSUQwZ2JXOWtkV3hsTG1WNGNHOXlkSE1nUFNCMGVYQmxiMllnZDJsdVpHOTNJQ0U5SUNkMWJtUmxabWx1WldRbklDWW1JSGRwYm1SdmR5NU5ZWFJvSUQwOUlFMWhkR2hjYmlBZ1B5QjNhVzVrYjNjZ09pQjBlWEJsYjJZZ2MyVnNaaUFoUFNBbmRXNWtaV1pwYm1Wa0p5QW1KaUJ6Wld4bUxrMWhkR2dnUFQwZ1RXRjBhQ0EvSUhObGJHWWdPaUJHZFc1amRHbHZiaWduY21WMGRYSnVJSFJvYVhNbktTZ3BPMXh1YVdZb2RIbHdaVzltSUY5Zlp5QTlQU0FuYm5WdFltVnlKeWxmWDJjZ1BTQm5iRzlpWVd3N0lDOHZJR1Z6YkdsdWRDMWthWE5oWW14bExXeHBibVVnYm04dGRXNWtaV1pjYmx4dVhHNHZMeTh2THk4dkx5OHZMeTh2THk4dkx5OWNiaTh2SUZkRlFsQkJRMHNnUms5UFZFVlNYRzR2THlBdUwzNHZZMjl5WlMxcWN5OXNhV0p5WVhKNUwyMXZaSFZzWlhNdlgyZHNiMkpoYkM1cWMxeHVMeThnYlc5a2RXeGxJR2xrSUQwZ01UVmNiaTh2SUcxdlpIVnNaU0JqYUhWdWEzTWdQU0F3SWl3aUx5OGdiM0IwYVc5dVlXd2dMeUJ6YVcxd2JHVWdZMjl1ZEdWNGRDQmlhVzVrYVc1blhHNTJZWElnWVVaMWJtTjBhVzl1SUQwZ2NtVnhkV2x5WlNnbkxpOWZZUzFtZFc1amRHbHZiaWNwTzF4dWJXOWtkV3hsTG1WNGNHOXlkSE1nUFNCbWRXNWpkR2x2YmlobWJpd2dkR2hoZEN3Z2JHVnVaM1JvS1h0Y2JpQWdZVVoxYm1OMGFXOXVLR1p1S1R0Y2JpQWdhV1lvZEdoaGRDQTlQVDBnZFc1a1pXWnBibVZrS1hKbGRIVnliaUJtYmp0Y2JpQWdjM2RwZEdOb0tHeGxibWQwYUNsN1hHNGdJQ0FnWTJGelpTQXhPaUJ5WlhSMWNtNGdablZ1WTNScGIyNG9ZU2w3WEc0Z0lDQWdJQ0J5WlhSMWNtNGdabTR1WTJGc2JDaDBhR0YwTENCaEtUdGNiaUFnSUNCOU8xeHVJQ0FnSUdOaGMyVWdNam9nY21WMGRYSnVJR1oxYm1OMGFXOXVLR0VzSUdJcGUxeHVJQ0FnSUNBZ2NtVjBkWEp1SUdadUxtTmhiR3dvZEdoaGRDd2dZU3dnWWlrN1hHNGdJQ0FnZlR0Y2JpQWdJQ0JqWVhObElETTZJSEpsZEhWeWJpQm1kVzVqZEdsdmJpaGhMQ0JpTENCaktYdGNiaUFnSUNBZ0lISmxkSFZ5YmlCbWJpNWpZV3hzS0hSb1lYUXNJR0VzSUdJc0lHTXBPMXh1SUNBZ0lIMDdYRzRnSUgxY2JpQWdjbVYwZFhKdUlHWjFibU4wYVc5dUtDOHFJQzR1TG1GeVozTWdLaThwZTF4dUlDQWdJSEpsZEhWeWJpQm1iaTVoY0hCc2VTaDBhR0YwTENCaGNtZDFiV1Z1ZEhNcE8xeHVJQ0I5TzF4dWZUdGNibHh1WEc0dkx5OHZMeTh2THk4dkx5OHZMeTh2THk5Y2JpOHZJRmRGUWxCQlEwc2dSazlQVkVWU1hHNHZMeUF1TDM0dlkyOXlaUzFxY3k5c2FXSnlZWEo1TDIxdlpIVnNaWE12WDJOMGVDNXFjMXh1THk4Z2JXOWtkV3hsSUdsa0lEMGdNVFpjYmk4dklHMXZaSFZzWlNCamFIVnVhM01nUFNBd0lpd2liVzlrZFd4bExtVjRjRzl5ZEhNZ1BTQm1kVzVqZEdsdmJpaHBkQ2w3WEc0Z0lHbG1LSFI1Y0dWdlppQnBkQ0FoUFNBblpuVnVZM1JwYjI0bktYUm9jbTkzSUZSNWNHVkZjbkp2Y2locGRDQXJJQ2NnYVhNZ2JtOTBJR0VnWm5WdVkzUnBiMjRoSnlrN1hHNGdJSEpsZEhWeWJpQnBkRHRjYm4wN1hHNWNibHh1THk4dkx5OHZMeTh2THk4dkx5OHZMeTh2WEc0dkx5QlhSVUpRUVVOTElFWlBUMVJGVWx4dUx5OGdMaTkrTDJOdmNtVXRhbk12YkdsaWNtRnllUzl0YjJSMWJHVnpMMTloTFdaMWJtTjBhVzl1TG1welhHNHZMeUJ0YjJSMWJHVWdhV1FnUFNBeE4xeHVMeThnYlc5a2RXeGxJR05vZFc1cmN5QTlJREFpTENKMllYSWdaRkFnSUNBZ0lDQWdJQ0E5SUhKbGNYVnBjbVVvSnk0dlgyOWlhbVZqZEMxa2NDY3BYRzRnSUN3Z1kzSmxZWFJsUkdWell5QTlJSEpsY1hWcGNtVW9KeTR2WDNCeWIzQmxjblI1TFdSbGMyTW5LVHRjYm0xdlpIVnNaUzVsZUhCdmNuUnpJRDBnY21WeGRXbHlaU2duTGk5ZlpHVnpZM0pwY0hSdmNuTW5LU0EvSUdaMWJtTjBhVzl1S0c5aWFtVmpkQ3dnYTJWNUxDQjJZV3gxWlNsN1hHNGdJSEpsZEhWeWJpQmtVQzVtS0c5aWFtVmpkQ3dnYTJWNUxDQmpjbVZoZEdWRVpYTmpLREVzSUhaaGJIVmxLU2s3WEc1OUlEb2dablZ1WTNScGIyNG9iMkpxWldOMExDQnJaWGtzSUhaaGJIVmxLWHRjYmlBZ2IySnFaV04wVzJ0bGVWMGdQU0IyWVd4MVpUdGNiaUFnY21WMGRYSnVJRzlpYW1WamREdGNibjA3WEc1Y2JseHVMeTh2THk4dkx5OHZMeTh2THk4dkx5OHZYRzR2THlCWFJVSlFRVU5MSUVaUFQxUkZVbHh1THk4Z0xpOStMMk52Y21VdGFuTXZiR2xpY21GeWVTOXRiMlIxYkdWekwxOW9hV1JsTG1welhHNHZMeUJ0YjJSMWJHVWdhV1FnUFNBeE9GeHVMeThnYlc5a2RXeGxJR05vZFc1cmN5QTlJREFpTENKMllYSWdZVzVQWW1wbFkzUWdJQ0FnSUNBZ1BTQnlaWEYxYVhKbEtDY3VMMTloYmkxdlltcGxZM1FuS1Z4dUlDQXNJRWxGT0Y5RVQwMWZSRVZHU1U1RklEMGdjbVZ4ZFdseVpTZ25MaTlmYVdVNExXUnZiUzFrWldacGJtVW5LVnh1SUNBc0lIUnZVSEpwYldsMGFYWmxJQ0FnSUQwZ2NtVnhkV2x5WlNnbkxpOWZkRzh0Y0hKcGJXbDBhWFpsSnlsY2JpQWdMQ0JrVUNBZ0lDQWdJQ0FnSUNBZ0lDQTlJRTlpYW1WamRDNWtaV1pwYm1WUWNtOXdaWEowZVR0Y2JseHVaWGh3YjNKMGN5NW1JRDBnY21WeGRXbHlaU2duTGk5ZlpHVnpZM0pwY0hSdmNuTW5LU0EvSUU5aWFtVmpkQzVrWldacGJtVlFjbTl3WlhKMGVTQTZJR1oxYm1OMGFXOXVJR1JsWm1sdVpWQnliM0JsY25SNUtFOHNJRkFzSUVGMGRISnBZblYwWlhNcGUxeHVJQ0JoYms5aWFtVmpkQ2hQS1R0Y2JpQWdVQ0E5SUhSdlVISnBiV2wwYVhabEtGQXNJSFJ5ZFdVcE8xeHVJQ0JoYms5aWFtVmpkQ2hCZEhSeWFXSjFkR1Z6S1R0Y2JpQWdhV1lvU1VVNFgwUlBUVjlFUlVaSlRrVXBkSEo1SUh0Y2JpQWdJQ0J5WlhSMWNtNGdaRkFvVHl3Z1VDd2dRWFIwY21saWRYUmxjeWs3WEc0Z0lIMGdZMkYwWTJnb1pTbDdJQzhxSUdWdGNIUjVJQ292SUgxY2JpQWdhV1lvSjJkbGRDY2dhVzRnUVhSMGNtbGlkWFJsY3lCOGZDQW5jMlYwSnlCcGJpQkJkSFJ5YVdKMWRHVnpLWFJvY205M0lGUjVjR1ZGY25KdmNpZ25RV05qWlhOemIzSnpJRzV2ZENCemRYQndiM0owWldRaEp5azdYRzRnSUdsbUtDZDJZV3gxWlNjZ2FXNGdRWFIwY21saWRYUmxjeWxQVzFCZElEMGdRWFIwY21saWRYUmxjeTUyWVd4MVpUdGNiaUFnY21WMGRYSnVJRTg3WEc1OU8xeHVYRzVjYmk4dkx5OHZMeTh2THk4dkx5OHZMeTh2TDF4dUx5OGdWMFZDVUVGRFN5QkdUMDlVUlZKY2JpOHZJQzR2Zmk5amIzSmxMV3B6TDJ4cFluSmhjbmt2Ylc5a2RXeGxjeTlmYjJKcVpXTjBMV1J3TG1welhHNHZMeUJ0YjJSMWJHVWdhV1FnUFNBeE9WeHVMeThnYlc5a2RXeGxJR05vZFc1cmN5QTlJREFpTENKMllYSWdhWE5QWW1wbFkzUWdQU0J5WlhGMWFYSmxLQ2N1TDE5cGN5MXZZbXBsWTNRbktUdGNibTF2WkhWc1pTNWxlSEJ2Y25SeklEMGdablZ1WTNScGIyNG9hWFFwZTF4dUlDQnBaaWdoYVhOUFltcGxZM1FvYVhRcEtYUm9jbTkzSUZSNWNHVkZjbkp2Y2locGRDQXJJQ2NnYVhNZ2JtOTBJR0Z1SUc5aWFtVmpkQ0VuS1R0Y2JpQWdjbVYwZFhKdUlHbDBPMXh1ZlR0Y2JseHVYRzR2THk4dkx5OHZMeTh2THk4dkx5OHZMeTljYmk4dklGZEZRbEJCUTBzZ1JrOVBWRVZTWEc0dkx5QXVMMzR2WTI5eVpTMXFjeTlzYVdKeVlYSjVMMjF2WkhWc1pYTXZYMkZ1TFc5aWFtVmpkQzVxYzF4dUx5OGdiVzlrZFd4bElHbGtJRDBnTWpCY2JpOHZJRzF2WkhWc1pTQmphSFZ1YTNNZ1BTQXdJaXdpYlc5a2RXeGxMbVY0Y0c5eWRITWdQU0JtZFc1amRHbHZiaWhwZENsN1hHNGdJSEpsZEhWeWJpQjBlWEJsYjJZZ2FYUWdQVDA5SUNkdlltcGxZM1FuSUQ4Z2FYUWdJVDA5SUc1MWJHd2dPaUIwZVhCbGIyWWdhWFFnUFQwOUlDZG1kVzVqZEdsdmJpYzdYRzU5TzF4dVhHNWNiaTh2THk4dkx5OHZMeTh2THk4dkx5OHZMMXh1THk4Z1YwVkNVRUZEU3lCR1QwOVVSVkpjYmk4dklDNHZmaTlqYjNKbExXcHpMMnhwWW5KaGNua3ZiVzlrZFd4bGN5OWZhWE10YjJKcVpXTjBMbXB6WEc0dkx5QnRiMlIxYkdVZ2FXUWdQU0F5TVZ4dUx5OGdiVzlrZFd4bElHTm9kVzVyY3lBOUlEQWlMQ0p0YjJSMWJHVXVaWGh3YjNKMGN5QTlJQ0Z5WlhGMWFYSmxLQ2N1TDE5a1pYTmpjbWx3ZEc5eWN5Y3BJQ1ltSUNGeVpYRjFhWEpsS0NjdUwxOW1ZV2xzY3ljcEtHWjFibU4wYVc5dUtDbDdYSEpjYmlBZ2NtVjBkWEp1SUU5aWFtVmpkQzVrWldacGJtVlFjbTl3WlhKMGVTaHlaWEYxYVhKbEtDY3VMMTlrYjIwdFkzSmxZWFJsSnlrb0oyUnBkaWNwTENBbllTY3NJSHRuWlhRNklHWjFibU4wYVc5dUtDbDdJSEpsZEhWeWJpQTNPeUI5ZlNrdVlTQWhQU0EzTzF4eVhHNTlLVHRjYmx4dVhHNHZMeTh2THk4dkx5OHZMeTh2THk4dkx5OWNiaTh2SUZkRlFsQkJRMHNnUms5UFZFVlNYRzR2THlBdUwzNHZZMjl5WlMxcWN5OXNhV0p5WVhKNUwyMXZaSFZzWlhNdlgybGxPQzFrYjIwdFpHVm1hVzVsTG1welhHNHZMeUJ0YjJSMWJHVWdhV1FnUFNBeU1seHVMeThnYlc5a2RXeGxJR05vZFc1cmN5QTlJREFpTENJdkx5QlVhR0Z1YXlkeklFbEZPQ0JtYjNJZ2FHbHpJR1oxYm01NUlHUmxabWx1WlZCeWIzQmxjblI1WEc1dGIyUjFiR1V1Wlhod2IzSjBjeUE5SUNGeVpYRjFhWEpsS0NjdUwxOW1ZV2xzY3ljcEtHWjFibU4wYVc5dUtDbDdYRzRnSUhKbGRIVnliaUJQWW1wbFkzUXVaR1ZtYVc1bFVISnZjR1Z5ZEhrb2UzMHNJQ2RoSnl3Z2UyZGxkRG9nWm5WdVkzUnBiMjRvS1hzZ2NtVjBkWEp1SURjN0lIMTlLUzVoSUNFOUlEYzdYRzU5S1R0Y2JseHVYRzR2THk4dkx5OHZMeTh2THk4dkx5OHZMeTljYmk4dklGZEZRbEJCUTBzZ1JrOVBWRVZTWEc0dkx5QXVMMzR2WTI5eVpTMXFjeTlzYVdKeVlYSjVMMjF2WkhWc1pYTXZYMlJsYzJOeWFYQjBiM0p6TG1welhHNHZMeUJ0YjJSMWJHVWdhV1FnUFNBeU0xeHVMeThnYlc5a2RXeGxJR05vZFc1cmN5QTlJREFpTENKdGIyUjFiR1V1Wlhod2IzSjBjeUE5SUdaMWJtTjBhVzl1S0dWNFpXTXBlMXh1SUNCMGNua2dlMXh1SUNBZ0lISmxkSFZ5YmlBaElXVjRaV01vS1R0Y2JpQWdmU0JqWVhSamFDaGxLWHRjYmlBZ0lDQnlaWFIxY200Z2RISjFaVHRjYmlBZ2ZWeHVmVHRjYmx4dVhHNHZMeTh2THk4dkx5OHZMeTh2THk4dkx5OWNiaTh2SUZkRlFsQkJRMHNnUms5UFZFVlNYRzR2THlBdUwzNHZZMjl5WlMxcWN5OXNhV0p5WVhKNUwyMXZaSFZzWlhNdlgyWmhhV3h6TG1welhHNHZMeUJ0YjJSMWJHVWdhV1FnUFNBeU5GeHVMeThnYlc5a2RXeGxJR05vZFc1cmN5QTlJREFpTENKMllYSWdhWE5QWW1wbFkzUWdQU0J5WlhGMWFYSmxLQ2N1TDE5cGN5MXZZbXBsWTNRbktWeHVJQ0FzSUdSdlkzVnRaVzUwSUQwZ2NtVnhkV2x5WlNnbkxpOWZaMnh2WW1Gc0p5a3VaRzlqZFcxbGJuUmNiaUFnTHk4Z2FXNGdiMnhrSUVsRklIUjVjR1Z2WmlCa2IyTjFiV1Z1ZEM1amNtVmhkR1ZGYkdWdFpXNTBJR2x6SUNkdlltcGxZM1FuWEc0Z0lDd2dhWE1nUFNCcGMwOWlhbVZqZENoa2IyTjFiV1Z1ZENrZ0ppWWdhWE5QWW1wbFkzUW9aRzlqZFcxbGJuUXVZM0psWVhSbFJXeGxiV1Z1ZENrN1hHNXRiMlIxYkdVdVpYaHdiM0owY3lBOUlHWjFibU4wYVc5dUtHbDBLWHRjYmlBZ2NtVjBkWEp1SUdseklEOGdaRzlqZFcxbGJuUXVZM0psWVhSbFJXeGxiV1Z1ZENocGRDa2dPaUI3ZlR0Y2JuMDdYRzVjYmx4dUx5OHZMeTh2THk4dkx5OHZMeTh2THk4dlhHNHZMeUJYUlVKUVFVTkxJRVpQVDFSRlVseHVMeThnTGk5K0wyTnZjbVV0YW5NdmJHbGljbUZ5ZVM5dGIyUjFiR1Z6TDE5a2IyMHRZM0psWVhSbExtcHpYRzR2THlCdGIyUjFiR1VnYVdRZ1BTQXlOVnh1THk4Z2JXOWtkV3hsSUdOb2RXNXJjeUE5SURBaUxDSXZMeUEzTGpFdU1TQlViMUJ5YVcxcGRHbDJaU2hwYm5CMWRDQmJMQ0JRY21WbVpYSnlaV1JVZVhCbFhTbGNiblpoY2lCcGMwOWlhbVZqZENBOUlISmxjWFZwY21Vb0p5NHZYMmx6TFc5aWFtVmpkQ2NwTzF4dUx5OGdhVzV6ZEdWaFpDQnZaaUIwYUdVZ1JWTTJJSE53WldNZ2RtVnljMmx2Yml3Z2QyVWdaR2xrYmlkMElHbHRjR3hsYldWdWRDQkFRSFJ2VUhKcGJXbDBhWFpsSUdOaGMyVmNiaTh2SUdGdVpDQjBhR1VnYzJWamIyNWtJR0Z5WjNWdFpXNTBJQzBnWm14aFp5QXRJSEJ5WldabGNuSmxaQ0IwZVhCbElHbHpJR0VnYzNSeWFXNW5YRzV0YjJSMWJHVXVaWGh3YjNKMGN5QTlJR1oxYm1OMGFXOXVLR2wwTENCVEtYdGNiaUFnYVdZb0lXbHpUMkpxWldOMEtHbDBLU2x5WlhSMWNtNGdhWFE3WEc0Z0lIWmhjaUJtYml3Z2RtRnNPMXh1SUNCcFppaFRJQ1ltSUhSNWNHVnZaaUFvWm00Z1BTQnBkQzUwYjFOMGNtbHVaeWtnUFQwZ0oyWjFibU4wYVc5dUp5QW1KaUFoYVhOUFltcGxZM1FvZG1Gc0lEMGdabTR1WTJGc2JDaHBkQ2twS1hKbGRIVnliaUIyWVd3N1hHNGdJR2xtS0hSNWNHVnZaaUFvWm00Z1BTQnBkQzUyWVd4MVpVOW1LU0E5UFNBblpuVnVZM1JwYjI0bklDWW1JQ0ZwYzA5aWFtVmpkQ2gyWVd3Z1BTQm1iaTVqWVd4c0tHbDBLU2twY21WMGRYSnVJSFpoYkR0Y2JpQWdhV1lvSVZNZ0ppWWdkSGx3Wlc5bUlDaG1iaUE5SUdsMExuUnZVM1J5YVc1bktTQTlQU0FuWm5WdVkzUnBiMjRuSUNZbUlDRnBjMDlpYW1WamRDaDJZV3dnUFNCbWJpNWpZV3hzS0dsMEtTa3BjbVYwZFhKdUlIWmhiRHRjYmlBZ2RHaHliM2NnVkhsd1pVVnljbTl5S0Z3aVEyRnVKM1FnWTI5dWRtVnlkQ0J2WW1wbFkzUWdkRzhnY0hKcGJXbDBhWFpsSUhaaGJIVmxYQ0lwTzF4dWZUdGNibHh1WEc0dkx5OHZMeTh2THk4dkx5OHZMeTh2THk5Y2JpOHZJRmRGUWxCQlEwc2dSazlQVkVWU1hHNHZMeUF1TDM0dlkyOXlaUzFxY3k5c2FXSnlZWEo1TDIxdlpIVnNaWE12WDNSdkxYQnlhVzFwZEdsMlpTNXFjMXh1THk4Z2JXOWtkV3hsSUdsa0lEMGdNalpjYmk4dklHMXZaSFZzWlNCamFIVnVhM01nUFNBd0lpd2liVzlrZFd4bExtVjRjRzl5ZEhNZ1BTQm1kVzVqZEdsdmJpaGlhWFJ0WVhBc0lIWmhiSFZsS1h0Y2JpQWdjbVYwZFhKdUlIdGNiaUFnSUNCbGJuVnRaWEpoWW14bElDQTZJQ0VvWW1sMGJXRndJQ1lnTVNrc1hHNGdJQ0FnWTI5dVptbG5kWEpoWW14bE9pQWhLR0pwZEcxaGNDQW1JRElwTEZ4dUlDQWdJSGR5YVhSaFlteGxJQ0FnSURvZ0lTaGlhWFJ0WVhBZ0ppQTBLU3hjYmlBZ0lDQjJZV3gxWlNBZ0lDQWdJQ0E2SUhaaGJIVmxYRzRnSUgwN1hHNTlPMXh1WEc1Y2JpOHZMeTh2THk4dkx5OHZMeTh2THk4dkwxeHVMeThnVjBWQ1VFRkRTeUJHVDA5VVJWSmNiaTh2SUM0dmZpOWpiM0psTFdwekwyeHBZbkpoY25rdmJXOWtkV3hsY3k5ZmNISnZjR1Z5ZEhrdFpHVnpZeTVxYzF4dUx5OGdiVzlrZFd4bElHbGtJRDBnTWpkY2JpOHZJRzF2WkhWc1pTQmphSFZ1YTNNZ1BTQXdJaXdpYlc5a2RXeGxMbVY0Y0c5eWRITWdQU0J5WlhGMWFYSmxLQ2N1TDE5b2FXUmxKeWs3WEc1Y2JseHVMeTh2THk4dkx5OHZMeTh2THk4dkx5OHZYRzR2THlCWFJVSlFRVU5MSUVaUFQxUkZVbHh1THk4Z0xpOStMMk52Y21VdGFuTXZiR2xpY21GeWVTOXRiMlIxYkdWekwxOXlaV1JsWm1sdVpTNXFjMXh1THk4Z2JXOWtkV3hsSUdsa0lEMGdNamhjYmk4dklHMXZaSFZzWlNCamFIVnVhM01nUFNBd0lpd2lkbUZ5SUdoaGMwOTNibEJ5YjNCbGNuUjVJRDBnZTMwdWFHRnpUM2R1VUhKdmNHVnlkSGs3WEc1dGIyUjFiR1V1Wlhod2IzSjBjeUE5SUdaMWJtTjBhVzl1S0dsMExDQnJaWGtwZTF4dUlDQnlaWFIxY200Z2FHRnpUM2R1VUhKdmNHVnlkSGt1WTJGc2JDaHBkQ3dnYTJWNUtUdGNibjA3WEc1Y2JseHVMeTh2THk4dkx5OHZMeTh2THk4dkx5OHZYRzR2THlCWFJVSlFRVU5MSUVaUFQxUkZVbHh1THk4Z0xpOStMMk52Y21VdGFuTXZiR2xpY21GeWVTOXRiMlIxYkdWekwxOW9ZWE11YW5OY2JpOHZJRzF2WkhWc1pTQnBaQ0E5SURJNVhHNHZMeUJ0YjJSMWJHVWdZMmgxYm10eklEMGdNQ0lzSW0xdlpIVnNaUzVsZUhCdmNuUnpJRDBnZTMwN1hHNWNibHh1THk4dkx5OHZMeTh2THk4dkx5OHZMeTh2WEc0dkx5QlhSVUpRUVVOTElFWlBUMVJGVWx4dUx5OGdMaTkrTDJOdmNtVXRhbk12YkdsaWNtRnllUzl0YjJSMWJHVnpMMTlwZEdWeVlYUnZjbk11YW5OY2JpOHZJRzF2WkhWc1pTQnBaQ0E5SURNd1hHNHZMeUJ0YjJSMWJHVWdZMmgxYm10eklEMGdNQ0lzSWlkMWMyVWdjM1J5YVdOMEp6dGNiblpoY2lCamNtVmhkR1VnSUNBZ0lDQWdJQ0E5SUhKbGNYVnBjbVVvSnk0dlgyOWlhbVZqZEMxamNtVmhkR1VuS1Z4dUlDQXNJR1JsYzJOeWFYQjBiM0lnSUNBZ0lEMGdjbVZ4ZFdseVpTZ25MaTlmY0hKdmNHVnlkSGt0WkdWell5Y3BYRzRnSUN3Z2MyVjBWRzlUZEhKcGJtZFVZV2NnUFNCeVpYRjFhWEpsS0NjdUwxOXpaWFF0ZEc4dGMzUnlhVzVuTFhSaFp5Y3BYRzRnSUN3Z1NYUmxjbUYwYjNKUWNtOTBiM1I1Y0dVZ1BTQjdmVHRjYmx4dUx5OGdNalV1TVM0eUxqRXVNU0FsU1hSbGNtRjBiM0pRY205MGIzUjVjR1VsVzBCQWFYUmxjbUYwYjNKZEtDbGNibkpsY1hWcGNtVW9KeTR2WDJocFpHVW5LU2hKZEdWeVlYUnZjbEJ5YjNSdmRIbHdaU3dnY21WeGRXbHlaU2duTGk5ZmQydHpKeWtvSjJsMFpYSmhkRzl5Snlrc0lHWjFibU4wYVc5dUtDbDdJSEpsZEhWeWJpQjBhR2x6T3lCOUtUdGNibHh1Ylc5a2RXeGxMbVY0Y0c5eWRITWdQU0JtZFc1amRHbHZiaWhEYjI1emRISjFZM1J2Y2l3Z1RrRk5SU3dnYm1WNGRDbDdYRzRnSUVOdmJuTjBjblZqZEc5eUxuQnliM1J2ZEhsd1pTQTlJR055WldGMFpTaEpkR1Z5WVhSdmNsQnliM1J2ZEhsd1pTd2dlMjVsZUhRNklHUmxjMk55YVhCMGIzSW9NU3dnYm1WNGRDbDlLVHRjYmlBZ2MyVjBWRzlUZEhKcGJtZFVZV2NvUTI5dWMzUnlkV04wYjNJc0lFNUJUVVVnS3lBbklFbDBaWEpoZEc5eUp5azdYRzU5TzF4dVhHNWNiaTh2THk4dkx5OHZMeTh2THk4dkx5OHZMMXh1THk4Z1YwVkNVRUZEU3lCR1QwOVVSVkpjYmk4dklDNHZmaTlqYjNKbExXcHpMMnhwWW5KaGNua3ZiVzlrZFd4bGN5OWZhWFJsY2kxamNtVmhkR1V1YW5OY2JpOHZJRzF2WkhWc1pTQnBaQ0E5SURNeFhHNHZMeUJ0YjJSMWJHVWdZMmgxYm10eklEMGdNQ0lzSWk4dklERTVMakV1TWk0eUlDOGdNVFV1TWk0ekxqVWdUMkpxWldOMExtTnlaV0YwWlNoUElGc3NJRkJ5YjNCbGNuUnBaWE5kS1Z4eVhHNTJZWElnWVc1UFltcGxZM1FnSUNBZ1BTQnlaWEYxYVhKbEtDY3VMMTloYmkxdlltcGxZM1FuS1Z4eVhHNGdJQ3dnWkZCeklDQWdJQ0FnSUNBZ1BTQnlaWEYxYVhKbEtDY3VMMTl2WW1wbFkzUXRaSEJ6SnlsY2NseHVJQ0FzSUdWdWRXMUNkV2RMWlhseklEMGdjbVZ4ZFdseVpTZ25MaTlmWlc1MWJTMWlkV2N0YTJWNWN5Y3BYSEpjYmlBZ0xDQkpSVjlRVWs5VVR5QWdJQ0E5SUhKbGNYVnBjbVVvSnk0dlgzTm9ZWEpsWkMxclpYa25LU2duU1VWZlVGSlBWRThuS1Z4eVhHNGdJQ3dnUlcxd2RIa2dJQ0FnSUNBZ1BTQm1kVzVqZEdsdmJpZ3BleUF2S2lCbGJYQjBlU0FxTHlCOVhISmNiaUFnTENCUVVrOVVUMVJaVUVVZ0lDQTlJQ2R3Y205MGIzUjVjR1VuTzF4eVhHNWNjbHh1THk4Z1EzSmxZWFJsSUc5aWFtVmpkQ0IzYVhSb0lHWmhhMlVnWUc1MWJHeGdJSEJ5YjNSdmRIbHdaVG9nZFhObElHbG1jbUZ0WlNCUFltcGxZM1FnZDJsMGFDQmpiR1ZoY21Wa0lIQnliM1J2ZEhsd1pWeHlYRzUyWVhJZ1kzSmxZWFJsUkdsamRDQTlJR1oxYm1OMGFXOXVLQ2w3WEhKY2JpQWdMeThnVkdoeVlYTm9MQ0IzWVhOMFpTQmhibVFnYzI5a2IyMTVPaUJKUlNCSFF5QmlkV2RjY2x4dUlDQjJZWElnYVdaeVlXMWxJRDBnY21WeGRXbHlaU2duTGk5ZlpHOXRMV055WldGMFpTY3BLQ2RwWm5KaGJXVW5LVnh5WEc0Z0lDQWdMQ0JwSUNBZ0lDQWdQU0JsYm5WdFFuVm5TMlY1Y3k1c1pXNW5kR2hjY2x4dUlDQWdJQ3dnWjNRZ0lDQWdJRDBnSno0blhISmNiaUFnSUNBc0lHbG1jbUZ0WlVSdlkzVnRaVzUwTzF4eVhHNGdJR2xtY21GdFpTNXpkSGxzWlM1a2FYTndiR0Y1SUQwZ0oyNXZibVVuTzF4eVhHNGdJSEpsY1hWcGNtVW9KeTR2WDJoMGJXd25LUzVoY0hCbGJtUkRhR2xzWkNocFpuSmhiV1VwTzF4eVhHNGdJR2xtY21GdFpTNXpjbU1nUFNBbmFtRjJZWE5qY21sd2REb25PeUF2THlCbGMyeHBiblF0WkdsellXSnNaUzFzYVc1bElHNXZMWE5qY21sd2RDMTFjbXhjY2x4dUlDQXZMeUJqY21WaGRHVkVhV04wSUQwZ2FXWnlZVzFsTG1OdmJuUmxiblJYYVc1a2IzY3VUMkpxWldOME8xeHlYRzRnSUM4dklHaDBiV3d1Y21WdGIzWmxRMmhwYkdRb2FXWnlZVzFsS1R0Y2NseHVJQ0JwWm5KaGJXVkViMk4xYldWdWRDQTlJR2xtY21GdFpTNWpiMjUwWlc1MFYybHVaRzkzTG1SdlkzVnRaVzUwTzF4eVhHNGdJR2xtY21GdFpVUnZZM1Z0Wlc1MExtOXdaVzRvS1R0Y2NseHVJQ0JwWm5KaGJXVkViMk4xYldWdWRDNTNjbWwwWlNnblBITmpjbWx3ZEQ1a2IyTjFiV1Z1ZEM1R1BVOWlhbVZqZER3dmMyTnlhWEIwSnlBcklHZDBLVHRjY2x4dUlDQnBabkpoYldWRWIyTjFiV1Z1ZEM1amJHOXpaU2dwTzF4eVhHNGdJR055WldGMFpVUnBZM1FnUFNCcFpuSmhiV1ZFYjJOMWJXVnVkQzVHTzF4eVhHNGdJSGRvYVd4bEtHa3RMU2xrWld4bGRHVWdZM0psWVhSbFJHbGpkRnRRVWs5VVQxUlpVRVZkVzJWdWRXMUNkV2RMWlhselcybGRYVHRjY2x4dUlDQnlaWFIxY200Z1kzSmxZWFJsUkdsamRDZ3BPMXh5WEc1OU8xeHlYRzVjY2x4dWJXOWtkV3hsTG1WNGNHOXlkSE1nUFNCUFltcGxZM1F1WTNKbFlYUmxJSHg4SUdaMWJtTjBhVzl1SUdOeVpXRjBaU2hQTENCUWNtOXdaWEowYVdWektYdGNjbHh1SUNCMllYSWdjbVZ6ZFd4ME8xeHlYRzRnSUdsbUtFOGdJVDA5SUc1MWJHd3BlMXh5WEc0Z0lDQWdSVzF3ZEhsYlVGSlBWRTlVV1ZCRlhTQTlJR0Z1VDJKcVpXTjBLRThwTzF4eVhHNGdJQ0FnY21WemRXeDBJRDBnYm1WM0lFVnRjSFI1TzF4eVhHNGdJQ0FnUlcxd2RIbGJVRkpQVkU5VVdWQkZYU0E5SUc1MWJHdzdYSEpjYmlBZ0lDQXZMeUJoWkdRZ1hDSmZYM0J5YjNSdlgxOWNJaUJtYjNJZ1QySnFaV04wTG1kbGRGQnliM1J2ZEhsd1pVOW1JSEJ2YkhsbWFXeHNYSEpjYmlBZ0lDQnlaWE4xYkhSYlNVVmZVRkpQVkU5ZElEMGdUenRjY2x4dUlDQjlJR1ZzYzJVZ2NtVnpkV3gwSUQwZ1kzSmxZWFJsUkdsamRDZ3BPMXh5WEc0Z0lISmxkSFZ5YmlCUWNtOXdaWEowYVdWeklEMDlQU0IxYm1SbFptbHVaV1FnUHlCeVpYTjFiSFFnT2lCa1VITW9jbVZ6ZFd4MExDQlFjbTl3WlhKMGFXVnpLVHRjY2x4dWZUdGNibHh1WEc0dkx5OHZMeTh2THk4dkx5OHZMeTh2THk5Y2JpOHZJRmRGUWxCQlEwc2dSazlQVkVWU1hHNHZMeUF1TDM0dlkyOXlaUzFxY3k5c2FXSnlZWEo1TDIxdlpIVnNaWE12WDI5aWFtVmpkQzFqY21WaGRHVXVhbk5jYmk4dklHMXZaSFZzWlNCcFpDQTlJRE15WEc0dkx5QnRiMlIxYkdVZ1kyaDFibXR6SUQwZ01DSXNJblpoY2lCa1VDQWdJQ0FnSUNBOUlISmxjWFZwY21Vb0p5NHZYMjlpYW1WamRDMWtjQ2NwWEhKY2JpQWdMQ0JoYms5aWFtVmpkQ0E5SUhKbGNYVnBjbVVvSnk0dlgyRnVMVzlpYW1WamRDY3BYSEpjYmlBZ0xDQm5aWFJMWlhseklDQTlJSEpsY1hWcGNtVW9KeTR2WDI5aWFtVmpkQzFyWlhsekp5azdYSEpjYmx4eVhHNXRiMlIxYkdVdVpYaHdiM0owY3lBOUlISmxjWFZwY21Vb0p5NHZYMlJsYzJOeWFYQjBiM0p6SnlrZ1B5QlBZbXBsWTNRdVpHVm1hVzVsVUhKdmNHVnlkR2xsY3lBNklHWjFibU4wYVc5dUlHUmxabWx1WlZCeWIzQmxjblJwWlhNb1R5d2dVSEp2Y0dWeWRHbGxjeWw3WEhKY2JpQWdZVzVQWW1wbFkzUW9UeWs3WEhKY2JpQWdkbUZ5SUd0bGVYTWdJQ0E5SUdkbGRFdGxlWE1vVUhKdmNHVnlkR2xsY3lsY2NseHVJQ0FnSUN3Z2JHVnVaM1JvSUQwZ2EyVjVjeTVzWlc1bmRHaGNjbHh1SUNBZ0lDd2dhU0E5SURCY2NseHVJQ0FnSUN3Z1VEdGNjbHh1SUNCM2FHbHNaU2hzWlc1bmRHZ2dQaUJwS1dSUUxtWW9UeXdnVUNBOUlHdGxlWE5iYVNzclhTd2dVSEp2Y0dWeWRHbGxjMXRRWFNrN1hISmNiaUFnY21WMGRYSnVJRTg3WEhKY2JuMDdYRzVjYmx4dUx5OHZMeTh2THk4dkx5OHZMeTh2THk4dlhHNHZMeUJYUlVKUVFVTkxJRVpQVDFSRlVseHVMeThnTGk5K0wyTnZjbVV0YW5NdmJHbGljbUZ5ZVM5dGIyUjFiR1Z6TDE5dlltcGxZM1F0WkhCekxtcHpYRzR2THlCdGIyUjFiR1VnYVdRZ1BTQXpNMXh1THk4Z2JXOWtkV3hsSUdOb2RXNXJjeUE5SURBaUxDSXZMeUF4T1M0eExqSXVNVFFnTHlBeE5TNHlMak11TVRRZ1QySnFaV04wTG10bGVYTW9UeWxjY2x4dWRtRnlJQ1JyWlhseklDQWdJQ0FnSUQwZ2NtVnhkV2x5WlNnbkxpOWZiMkpxWldOMExXdGxlWE10YVc1MFpYSnVZV3duS1Z4eVhHNGdJQ3dnWlc1MWJVSjFaMHRsZVhNZ1BTQnlaWEYxYVhKbEtDY3VMMTlsYm5WdExXSjFaeTFyWlhsekp5azdYSEpjYmx4eVhHNXRiMlIxYkdVdVpYaHdiM0owY3lBOUlFOWlhbVZqZEM1clpYbHpJSHg4SUdaMWJtTjBhVzl1SUd0bGVYTW9UeWw3WEhKY2JpQWdjbVYwZFhKdUlDUnJaWGx6S0U4c0lHVnVkVzFDZFdkTFpYbHpLVHRjY2x4dWZUdGNibHh1WEc0dkx5OHZMeTh2THk4dkx5OHZMeTh2THk5Y2JpOHZJRmRGUWxCQlEwc2dSazlQVkVWU1hHNHZMeUF1TDM0dlkyOXlaUzFxY3k5c2FXSnlZWEo1TDIxdlpIVnNaWE12WDI5aWFtVmpkQzFyWlhsekxtcHpYRzR2THlCdGIyUjFiR1VnYVdRZ1BTQXpORnh1THk4Z2JXOWtkV3hsSUdOb2RXNXJjeUE5SURBaUxDSjJZWElnYUdGeklDQWdJQ0FnSUNBZ0lEMGdjbVZ4ZFdseVpTZ25MaTlmYUdGekp5bGNjbHh1SUNBc0lIUnZTVTlpYW1WamRDQWdJQ0E5SUhKbGNYVnBjbVVvSnk0dlgzUnZMV2x2WW1wbFkzUW5LVnh5WEc0Z0lDd2dZWEp5WVhsSmJtUmxlRTltSUQwZ2NtVnhkV2x5WlNnbkxpOWZZWEp5WVhrdGFXNWpiSFZrWlhNbktTaG1ZV3h6WlNsY2NseHVJQ0FzSUVsRlgxQlNUMVJQSUNBZ0lDQTlJSEpsY1hWcGNtVW9KeTR2WDNOb1lYSmxaQzFyWlhrbktTZ25TVVZmVUZKUFZFOG5LVHRjY2x4dVhISmNibTF2WkhWc1pTNWxlSEJ2Y25SeklEMGdablZ1WTNScGIyNG9iMkpxWldOMExDQnVZVzFsY3lsN1hISmNiaUFnZG1GeUlFOGdJQ0FnSUNBOUlIUnZTVTlpYW1WamRDaHZZbXBsWTNRcFhISmNiaUFnSUNBc0lHa2dJQ0FnSUNBOUlEQmNjbHh1SUNBZ0lDd2djbVZ6ZFd4MElEMGdXMTFjY2x4dUlDQWdJQ3dnYTJWNU8xeHlYRzRnSUdadmNpaHJaWGtnYVc0Z1R5bHBaaWhyWlhrZ0lUMGdTVVZmVUZKUFZFOHBhR0Z6S0U4c0lHdGxlU2tnSmlZZ2NtVnpkV3gwTG5CMWMyZ29hMlY1S1R0Y2NseHVJQ0F2THlCRWIyNG5kQ0JsYm5WdElHSjFaeUFtSUdocFpHUmxiaUJyWlhselhISmNiaUFnZDJocGJHVW9ibUZ0WlhNdWJHVnVaM1JvSUQ0Z2FTbHBaaWhvWVhNb1R5d2dhMlY1SUQwZ2JtRnRaWE5iYVNzclhTa3BlMXh5WEc0Z0lDQWdmbUZ5Y21GNVNXNWtaWGhQWmloeVpYTjFiSFFzSUd0bGVTa2dmSHdnY21WemRXeDBMbkIxYzJnb2EyVjVLVHRjY2x4dUlDQjlYSEpjYmlBZ2NtVjBkWEp1SUhKbGMzVnNkRHRjY2x4dWZUdGNibHh1WEc0dkx5OHZMeTh2THk4dkx5OHZMeTh2THk5Y2JpOHZJRmRGUWxCQlEwc2dSazlQVkVWU1hHNHZMeUF1TDM0dlkyOXlaUzFxY3k5c2FXSnlZWEo1TDIxdlpIVnNaWE12WDI5aWFtVmpkQzFyWlhsekxXbHVkR1Z5Ym1Gc0xtcHpYRzR2THlCdGIyUjFiR1VnYVdRZ1BTQXpOVnh1THk4Z2JXOWtkV3hsSUdOb2RXNXJjeUE5SURBaUxDSXZMeUIwYnlCcGJtUmxlR1ZrSUc5aWFtVmpkQ3dnZEc5UFltcGxZM1FnZDJsMGFDQm1ZV3hzWW1GamF5Qm1iM0lnYm05dUxXRnljbUY1TFd4cGEyVWdSVk16SUhOMGNtbHVaM05jYm5aaGNpQkpUMkpxWldOMElEMGdjbVZ4ZFdseVpTZ25MaTlmYVc5aWFtVmpkQ2NwWEc0Z0lDd2daR1ZtYVc1bFpDQTlJSEpsY1hWcGNtVW9KeTR2WDJSbFptbHVaV1FuS1R0Y2JtMXZaSFZzWlM1bGVIQnZjblJ6SUQwZ1puVnVZM1JwYjI0b2FYUXBlMXh1SUNCeVpYUjFjbTRnU1U5aWFtVmpkQ2hrWldacGJtVmtLR2wwS1NrN1hHNTlPMXh1WEc1Y2JpOHZMeTh2THk4dkx5OHZMeTh2THk4dkwxeHVMeThnVjBWQ1VFRkRTeUJHVDA5VVJWSmNiaTh2SUM0dmZpOWpiM0psTFdwekwyeHBZbkpoY25rdmJXOWtkV3hsY3k5ZmRHOHRhVzlpYW1WamRDNXFjMXh1THk4Z2JXOWtkV3hsSUdsa0lEMGdNelpjYmk4dklHMXZaSFZzWlNCamFIVnVhM01nUFNBd0lpd2lMeThnWm1Gc2JHSmhZMnNnWm05eUlHNXZiaTFoY25KaGVTMXNhV3RsSUVWVE15QmhibVFnYm05dUxXVnVkVzFsY21GaWJHVWdiMnhrSUZZNElITjBjbWx1WjNOY2JuWmhjaUJqYjJZZ1BTQnlaWEYxYVhKbEtDY3VMMTlqYjJZbktUdGNibTF2WkhWc1pTNWxlSEJ2Y25SeklEMGdUMkpxWldOMEtDZDZKeWt1Y0hKdmNHVnlkSGxKYzBWdWRXMWxjbUZpYkdVb01Da2dQeUJQWW1wbFkzUWdPaUJtZFc1amRHbHZiaWhwZENsN1hHNGdJSEpsZEhWeWJpQmpiMllvYVhRcElEMDlJQ2RUZEhKcGJtY25JRDhnYVhRdWMzQnNhWFFvSnljcElEb2dUMkpxWldOMEtHbDBLVHRjYm4wN1hHNWNibHh1THk4dkx5OHZMeTh2THk4dkx5OHZMeTh2WEc0dkx5QlhSVUpRUVVOTElFWlBUMVJGVWx4dUx5OGdMaTkrTDJOdmNtVXRhbk12YkdsaWNtRnllUzl0YjJSMWJHVnpMMTlwYjJKcVpXTjBMbXB6WEc0dkx5QnRiMlIxYkdVZ2FXUWdQU0F6TjF4dUx5OGdiVzlrZFd4bElHTm9kVzVyY3lBOUlEQWlMQ0oyWVhJZ2RHOVRkSEpwYm1jZ1BTQjdmUzUwYjFOMGNtbHVaenRjYmx4dWJXOWtkV3hsTG1WNGNHOXlkSE1nUFNCbWRXNWpkR2x2YmlocGRDbDdYRzRnSUhKbGRIVnliaUIwYjFOMGNtbHVaeTVqWVd4c0tHbDBLUzV6YkdsalpTZzRMQ0F0TVNrN1hHNTlPMXh1WEc1Y2JpOHZMeTh2THk4dkx5OHZMeTh2THk4dkwxeHVMeThnVjBWQ1VFRkRTeUJHVDA5VVJWSmNiaTh2SUM0dmZpOWpiM0psTFdwekwyeHBZbkpoY25rdmJXOWtkV3hsY3k5ZlkyOW1MbXB6WEc0dkx5QnRiMlIxYkdVZ2FXUWdQU0F6T0Z4dUx5OGdiVzlrZFd4bElHTm9kVzVyY3lBOUlEQWlMQ0l2THlCbVlXeHpaU0F0UGlCQmNuSmhlU05wYm1SbGVFOW1YRzR2THlCMGNuVmxJQ0F0UGlCQmNuSmhlU05wYm1Oc2RXUmxjMXh1ZG1GeUlIUnZTVTlpYW1WamRDQTlJSEpsY1hWcGNtVW9KeTR2WDNSdkxXbHZZbXBsWTNRbktWeHVJQ0FzSUhSdlRHVnVaM1JvSUNBOUlISmxjWFZwY21Vb0p5NHZYM1J2TFd4bGJtZDBhQ2NwWEc0Z0lDd2dkRzlKYm1SbGVDQWdJRDBnY21WeGRXbHlaU2duTGk5ZmRHOHRhVzVrWlhnbktUdGNibTF2WkhWc1pTNWxlSEJ2Y25SeklEMGdablZ1WTNScGIyNG9TVk5mU1U1RFRGVkVSVk1wZTF4dUlDQnlaWFIxY200Z1puVnVZM1JwYjI0b0pIUm9hWE1zSUdWc0xDQm1jbTl0U1c1a1pYZ3BlMXh1SUNBZ0lIWmhjaUJQSUNBZ0lDQWdQU0IwYjBsUFltcGxZM1FvSkhSb2FYTXBYRzRnSUNBZ0lDQXNJR3hsYm1kMGFDQTlJSFJ2VEdWdVozUm9LRTh1YkdWdVozUm9LVnh1SUNBZ0lDQWdMQ0JwYm1SbGVDQWdQU0IwYjBsdVpHVjRLR1p5YjIxSmJtUmxlQ3dnYkdWdVozUm9LVnh1SUNBZ0lDQWdMQ0IyWVd4MVpUdGNiaUFnSUNBdkx5QkJjbkpoZVNOcGJtTnNkV1JsY3lCMWMyVnpJRk5oYldWV1lXeDFaVnBsY204Z1pYRjFZV3hwZEhrZ1lXeG5iM0pwZEdodFhHNGdJQ0FnYVdZb1NWTmZTVTVEVEZWRVJWTWdKaVlnWld3Z0lUMGdaV3dwZDJocGJHVW9iR1Z1WjNSb0lENGdhVzVrWlhncGUxeHVJQ0FnSUNBZ2RtRnNkV1VnUFNCUFcybHVaR1Y0S3l0ZE8xeHVJQ0FnSUNBZ2FXWW9kbUZzZFdVZ0lUMGdkbUZzZFdVcGNtVjBkWEp1SUhSeWRXVTdYRzRnSUNBZ0x5OGdRWEp5WVhramRHOUpibVJsZUNCcFoyNXZjbVZ6SUdodmJHVnpMQ0JCY25KaGVTTnBibU5zZFdSbGN5QXRJRzV2ZEZ4dUlDQWdJSDBnWld4elpTQm1iM0lvTzJ4bGJtZDBhQ0ErSUdsdVpHVjRPeUJwYm1SbGVDc3JLV2xtS0VsVFgwbE9RMHhWUkVWVElIeDhJR2x1WkdWNElHbHVJRThwZTF4dUlDQWdJQ0FnYVdZb1QxdHBibVJsZUYwZ1BUMDlJR1ZzS1hKbGRIVnliaUJKVTE5SlRrTk1WVVJGVXlCOGZDQnBibVJsZUNCOGZDQXdPMXh1SUNBZ0lIMGdjbVYwZFhKdUlDRkpVMTlKVGtOTVZVUkZVeUFtSmlBdE1UdGNiaUFnZlR0Y2JuMDdYRzVjYmx4dUx5OHZMeTh2THk4dkx5OHZMeTh2THk4dlhHNHZMeUJYUlVKUVFVTkxJRVpQVDFSRlVseHVMeThnTGk5K0wyTnZjbVV0YW5NdmJHbGljbUZ5ZVM5dGIyUjFiR1Z6TDE5aGNuSmhlUzFwYm1Oc2RXUmxjeTVxYzF4dUx5OGdiVzlrZFd4bElHbGtJRDBnTXpsY2JpOHZJRzF2WkhWc1pTQmphSFZ1YTNNZ1BTQXdJaXdpTHk4Z055NHhMakUxSUZSdlRHVnVaM1JvWEc1MllYSWdkRzlKYm5SbFoyVnlJRDBnY21WeGRXbHlaU2duTGk5ZmRHOHRhVzUwWldkbGNpY3BYRzRnSUN3Z2JXbHVJQ0FnSUNBZ0lEMGdUV0YwYUM1dGFXNDdYRzV0YjJSMWJHVXVaWGh3YjNKMGN5QTlJR1oxYm1OMGFXOXVLR2wwS1h0Y2JpQWdjbVYwZFhKdUlHbDBJRDRnTUNBL0lHMXBiaWgwYjBsdWRHVm5aWElvYVhRcExDQXdlREZtWm1abVptWm1abVptWm1abUtTQTZJREE3SUM4dklIQnZkeWd5TENBMU15a2dMU0F4SUQwOUlEa3dNRGN4T1RreU5UUTNOREE1T1RGY2JuMDdYRzVjYmx4dUx5OHZMeTh2THk4dkx5OHZMeTh2THk4dlhHNHZMeUJYUlVKUVFVTkxJRVpQVDFSRlVseHVMeThnTGk5K0wyTnZjbVV0YW5NdmJHbGljbUZ5ZVM5dGIyUjFiR1Z6TDE5MGJ5MXNaVzVuZEdndWFuTmNiaTh2SUcxdlpIVnNaU0JwWkNBOUlEUXdYRzR2THlCdGIyUjFiR1VnWTJoMWJtdHpJRDBnTUNJc0luWmhjaUIwYjBsdWRHVm5aWElnUFNCeVpYRjFhWEpsS0NjdUwxOTBieTFwYm5SbFoyVnlKeWxjYmlBZ0xDQnRZWGdnSUNBZ0lDQWdQU0JOWVhSb0xtMWhlRnh1SUNBc0lHMXBiaUFnSUNBZ0lDQTlJRTFoZEdndWJXbHVPMXh1Ylc5a2RXeGxMbVY0Y0c5eWRITWdQU0JtZFc1amRHbHZiaWhwYm1SbGVDd2diR1Z1WjNSb0tYdGNiaUFnYVc1a1pYZ2dQU0IwYjBsdWRHVm5aWElvYVc1a1pYZ3BPMXh1SUNCeVpYUjFjbTRnYVc1a1pYZ2dQQ0F3SUQ4Z2JXRjRLR2x1WkdWNElDc2diR1Z1WjNSb0xDQXdLU0E2SUcxcGJpaHBibVJsZUN3Z2JHVnVaM1JvS1R0Y2JuMDdYRzVjYmx4dUx5OHZMeTh2THk4dkx5OHZMeTh2THk4dlhHNHZMeUJYUlVKUVFVTkxJRVpQVDFSRlVseHVMeThnTGk5K0wyTnZjbVV0YW5NdmJHbGljbUZ5ZVM5dGIyUjFiR1Z6TDE5MGJ5MXBibVJsZUM1cWMxeHVMeThnYlc5a2RXeGxJR2xrSUQwZ05ERmNiaTh2SUcxdlpIVnNaU0JqYUhWdWEzTWdQU0F3SWl3aWRtRnlJSE5vWVhKbFpDQTlJSEpsY1hWcGNtVW9KeTR2WDNOb1lYSmxaQ2NwS0NkclpYbHpKeWxjY2x4dUlDQXNJSFZwWkNBZ0lDQTlJSEpsY1hWcGNtVW9KeTR2WDNWcFpDY3BPMXh5WEc1dGIyUjFiR1V1Wlhod2IzSjBjeUE5SUdaMWJtTjBhVzl1S0d0bGVTbDdYSEpjYmlBZ2NtVjBkWEp1SUhOb1lYSmxaRnRyWlhsZElIeDhJQ2h6YUdGeVpXUmJhMlY1WFNBOUlIVnBaQ2hyWlhrcEtUdGNjbHh1ZlR0Y2JseHVYRzR2THk4dkx5OHZMeTh2THk4dkx5OHZMeTljYmk4dklGZEZRbEJCUTBzZ1JrOVBWRVZTWEc0dkx5QXVMMzR2WTI5eVpTMXFjeTlzYVdKeVlYSjVMMjF2WkhWc1pYTXZYM05vWVhKbFpDMXJaWGt1YW5OY2JpOHZJRzF2WkhWc1pTQnBaQ0E5SURReVhHNHZMeUJ0YjJSMWJHVWdZMmgxYm10eklEMGdNQ0lzSW5aaGNpQm5iRzlpWVd3Z1BTQnlaWEYxYVhKbEtDY3VMMTluYkc5aVlXd25LVnh1SUNBc0lGTklRVkpGUkNBOUlDZGZYMk52Y21VdGFuTmZjMmhoY21Wa1gxOG5YRzRnSUN3Z2MzUnZjbVVnSUQwZ1oyeHZZbUZzVzFOSVFWSkZSRjBnZkh3Z0tHZHNiMkpoYkZ0VFNFRlNSVVJkSUQwZ2UzMHBPMXh1Ylc5a2RXeGxMbVY0Y0c5eWRITWdQU0JtZFc1amRHbHZiaWhyWlhrcGUxeHVJQ0J5WlhSMWNtNGdjM1J2Y21WYmEyVjVYU0I4ZkNBb2MzUnZjbVZiYTJWNVhTQTlJSHQ5S1R0Y2JuMDdYRzVjYmx4dUx5OHZMeTh2THk4dkx5OHZMeTh2THk4dlhHNHZMeUJYUlVKUVFVTkxJRVpQVDFSRlVseHVMeThnTGk5K0wyTnZjbVV0YW5NdmJHbGljbUZ5ZVM5dGIyUjFiR1Z6TDE5emFHRnlaV1F1YW5OY2JpOHZJRzF2WkhWc1pTQnBaQ0E5SURRelhHNHZMeUJ0YjJSMWJHVWdZMmgxYm10eklEMGdNQ0lzSW5aaGNpQnBaQ0E5SURCY2JpQWdMQ0J3ZUNBOUlFMWhkR2d1Y21GdVpHOXRLQ2s3WEc1dGIyUjFiR1V1Wlhod2IzSjBjeUE5SUdaMWJtTjBhVzl1S0d0bGVTbDdYRzRnSUhKbGRIVnliaUFuVTNsdFltOXNLQ2N1WTI5dVkyRjBLR3RsZVNBOVBUMGdkVzVrWldacGJtVmtJRDhnSnljZ09pQnJaWGtzSUNjcFh5Y3NJQ2dySzJsa0lDc2djSGdwTG5SdlUzUnlhVzVuS0RNMktTazdYRzU5TzF4dVhHNWNiaTh2THk4dkx5OHZMeTh2THk4dkx5OHZMMXh1THk4Z1YwVkNVRUZEU3lCR1QwOVVSVkpjYmk4dklDNHZmaTlqYjNKbExXcHpMMnhwWW5KaGNua3ZiVzlrZFd4bGN5OWZkV2xrTG1welhHNHZMeUJ0YjJSMWJHVWdhV1FnUFNBME5GeHVMeThnYlc5a2RXeGxJR05vZFc1cmN5QTlJREFpTENJdkx5QkpSU0E0TFNCa2IyNG5kQ0JsYm5WdElHSjFaeUJyWlhselhISmNibTF2WkhWc1pTNWxlSEJ2Y25SeklEMGdLRnh5WEc0Z0lDZGpiMjV6ZEhKMVkzUnZjaXhvWVhOUGQyNVFjbTl3WlhKMGVTeHBjMUJ5YjNSdmRIbHdaVTltTEhCeWIzQmxjblI1U1hORmJuVnRaWEpoWW14bExIUnZURzlqWVd4bFUzUnlhVzVuTEhSdlUzUnlhVzVuTEhaaGJIVmxUMlluWEhKY2Jpa3VjM0JzYVhRb0p5d25LVHRjYmx4dVhHNHZMeTh2THk4dkx5OHZMeTh2THk4dkx5OWNiaTh2SUZkRlFsQkJRMHNnUms5UFZFVlNYRzR2THlBdUwzNHZZMjl5WlMxcWN5OXNhV0p5WVhKNUwyMXZaSFZzWlhNdlgyVnVkVzB0WW5WbkxXdGxlWE11YW5OY2JpOHZJRzF2WkhWc1pTQnBaQ0E5SURRMVhHNHZMeUJ0YjJSMWJHVWdZMmgxYm10eklEMGdNQ0lzSW0xdlpIVnNaUzVsZUhCdmNuUnpJRDBnY21WeGRXbHlaU2duTGk5ZloyeHZZbUZzSnlrdVpHOWpkVzFsYm5RZ0ppWWdaRzlqZFcxbGJuUXVaRzlqZFcxbGJuUkZiR1Z0Wlc1ME8xeHVYRzVjYmk4dkx5OHZMeTh2THk4dkx5OHZMeTh2TDF4dUx5OGdWMFZDVUVGRFN5QkdUMDlVUlZKY2JpOHZJQzR2Zmk5amIzSmxMV3B6TDJ4cFluSmhjbmt2Ylc5a2RXeGxjeTlmYUhSdGJDNXFjMXh1THk4Z2JXOWtkV3hsSUdsa0lEMGdORFpjYmk4dklHMXZaSFZzWlNCamFIVnVhM01nUFNBd0lpd2lkbUZ5SUdSbFppQTlJSEpsY1hWcGNtVW9KeTR2WDI5aWFtVmpkQzFrY0NjcExtWmNiaUFnTENCb1lYTWdQU0J5WlhGMWFYSmxLQ2N1TDE5b1lYTW5LVnh1SUNBc0lGUkJSeUE5SUhKbGNYVnBjbVVvSnk0dlgzZHJjeWNwS0NkMGIxTjBjbWx1WjFSaFp5Y3BPMXh1WEc1dGIyUjFiR1V1Wlhod2IzSjBjeUE5SUdaMWJtTjBhVzl1S0dsMExDQjBZV2NzSUhOMFlYUXBlMXh1SUNCcFppaHBkQ0FtSmlBaGFHRnpLR2wwSUQwZ2MzUmhkQ0EvSUdsMElEb2dhWFF1Y0hKdmRHOTBlWEJsTENCVVFVY3BLV1JsWmlocGRDd2dWRUZITENCN1kyOXVabWxuZFhKaFlteGxPaUIwY25WbExDQjJZV3gxWlRvZ2RHRm5mU2s3WEc1OU8xeHVYRzVjYmk4dkx5OHZMeTh2THk4dkx5OHZMeTh2TDF4dUx5OGdWMFZDVUVGRFN5QkdUMDlVUlZKY2JpOHZJQzR2Zmk5amIzSmxMV3B6TDJ4cFluSmhjbmt2Ylc5a2RXeGxjeTlmYzJWMExYUnZMWE4wY21sdVp5MTBZV2N1YW5OY2JpOHZJRzF2WkhWc1pTQnBaQ0E5SURRM1hHNHZMeUJ0YjJSMWJHVWdZMmgxYm10eklEMGdNQ0lzSW5aaGNpQnpkRzl5WlNBZ0lDQWdJRDBnY21WeGRXbHlaU2duTGk5ZmMyaGhjbVZrSnlrb0ozZHJjeWNwWEc0Z0lDd2dkV2xrSUNBZ0lDQWdJQ0E5SUhKbGNYVnBjbVVvSnk0dlgzVnBaQ2NwWEc0Z0lDd2dVM2x0WW05c0lDQWdJQ0E5SUhKbGNYVnBjbVVvSnk0dlgyZHNiMkpoYkNjcExsTjViV0p2YkZ4dUlDQXNJRlZUUlY5VFdVMUNUMHdnUFNCMGVYQmxiMllnVTNsdFltOXNJRDA5SUNkbWRXNWpkR2x2YmljN1hHNWNiblpoY2lBa1pYaHdiM0owY3lBOUlHMXZaSFZzWlM1bGVIQnZjblJ6SUQwZ1puVnVZM1JwYjI0b2JtRnRaU2w3WEc0Z0lISmxkSFZ5YmlCemRHOXlaVnR1WVcxbFhTQjhmQ0FvYzNSdmNtVmJibUZ0WlYwZ1BWeHVJQ0FnSUZWVFJWOVRXVTFDVDB3Z0ppWWdVM2x0WW05c1cyNWhiV1ZkSUh4OElDaFZVMFZmVTFsTlFrOU1JRDhnVTNsdFltOXNJRG9nZFdsa0tTZ25VM2x0WW05c0xpY2dLeUJ1WVcxbEtTazdYRzU5TzF4dVhHNGtaWGh3YjNKMGN5NXpkRzl5WlNBOUlITjBiM0psTzF4dVhHNWNiaTh2THk4dkx5OHZMeTh2THk4dkx5OHZMMXh1THk4Z1YwVkNVRUZEU3lCR1QwOVVSVkpjYmk4dklDNHZmaTlqYjNKbExXcHpMMnhwWW5KaGNua3ZiVzlrZFd4bGN5OWZkMnR6TG1welhHNHZMeUJ0YjJSMWJHVWdhV1FnUFNBME9GeHVMeThnYlc5a2RXeGxJR05vZFc1cmN5QTlJREFpTENJdkx5QXhPUzR4TGpJdU9TQXZJREUxTGpJdU15NHlJRTlpYW1WamRDNW5aWFJRY205MGIzUjVjR1ZQWmloUEtWeHlYRzUyWVhJZ2FHRnpJQ0FnSUNBZ0lDQWdQU0J5WlhGMWFYSmxLQ2N1TDE5b1lYTW5LVnh5WEc0Z0lDd2dkRzlQWW1wbFkzUWdJQ0FnUFNCeVpYRjFhWEpsS0NjdUwxOTBieTF2WW1wbFkzUW5LVnh5WEc0Z0lDd2dTVVZmVUZKUFZFOGdJQ0FnUFNCeVpYRjFhWEpsS0NjdUwxOXphR0Z5WldRdGEyVjVKeWtvSjBsRlgxQlNUMVJQSnlsY2NseHVJQ0FzSUU5aWFtVmpkRkJ5YjNSdklEMGdUMkpxWldOMExuQnliM1J2ZEhsd1pUdGNjbHh1WEhKY2JtMXZaSFZzWlM1bGVIQnZjblJ6SUQwZ1QySnFaV04wTG1kbGRGQnliM1J2ZEhsd1pVOW1JSHg4SUdaMWJtTjBhVzl1S0U4cGUxeHlYRzRnSUU4Z1BTQjBiMDlpYW1WamRDaFBLVHRjY2x4dUlDQnBaaWhvWVhNb1R5d2dTVVZmVUZKUFZFOHBLWEpsZEhWeWJpQlBXMGxGWDFCU1QxUlBYVHRjY2x4dUlDQnBaaWgwZVhCbGIyWWdUeTVqYjI1emRISjFZM1J2Y2lBOVBTQW5ablZ1WTNScGIyNG5JQ1ltSUU4Z2FXNXpkR0Z1WTJWdlppQlBMbU52Ym5OMGNuVmpkRzl5S1h0Y2NseHVJQ0FnSUhKbGRIVnliaUJQTG1OdmJuTjBjblZqZEc5eUxuQnliM1J2ZEhsd1pUdGNjbHh1SUNCOUlISmxkSFZ5YmlCUElHbHVjM1JoYm1ObGIyWWdUMkpxWldOMElEOGdUMkpxWldOMFVISnZkRzhnT2lCdWRXeHNPMXh5WEc1OU8xeHVYRzVjYmk4dkx5OHZMeTh2THk4dkx5OHZMeTh2TDF4dUx5OGdWMFZDVUVGRFN5QkdUMDlVUlZKY2JpOHZJQzR2Zmk5amIzSmxMV3B6TDJ4cFluSmhjbmt2Ylc5a2RXeGxjeTlmYjJKcVpXTjBMV2R3Ynk1cWMxeHVMeThnYlc5a2RXeGxJR2xrSUQwZ05EbGNiaTh2SUcxdlpIVnNaU0JqYUhWdWEzTWdQU0F3SWl3aUx5OGdOeTR4TGpFeklGUnZUMkpxWldOMEtHRnlaM1Z0Wlc1MEtWeHVkbUZ5SUdSbFptbHVaV1FnUFNCeVpYRjFhWEpsS0NjdUwxOWtaV1pwYm1Wa0p5azdYRzV0YjJSMWJHVXVaWGh3YjNKMGN5QTlJR1oxYm1OMGFXOXVLR2wwS1h0Y2JpQWdjbVYwZFhKdUlFOWlhbVZqZENoa1pXWnBibVZrS0dsMEtTazdYRzU5TzF4dVhHNWNiaTh2THk4dkx5OHZMeTh2THk4dkx5OHZMMXh1THk4Z1YwVkNVRUZEU3lCR1QwOVVSVkpjYmk4dklDNHZmaTlqYjNKbExXcHpMMnhwWW5KaGNua3ZiVzlrZFd4bGN5OWZkRzh0YjJKcVpXTjBMbXB6WEc0dkx5QnRiMlIxYkdVZ2FXUWdQU0ExTUZ4dUx5OGdiVzlrZFd4bElHTm9kVzVyY3lBOUlEQWlMQ0p5WlhGMWFYSmxLQ2N1TDJWek5pNWhjbkpoZVM1cGRHVnlZWFJ2Y2ljcE8xeHVkbUZ5SUdkc2IySmhiQ0FnSUNBZ0lDQWdQU0J5WlhGMWFYSmxLQ2N1TDE5bmJHOWlZV3duS1Z4dUlDQXNJR2hwWkdVZ0lDQWdJQ0FnSUNBZ1BTQnlaWEYxYVhKbEtDY3VMMTlvYVdSbEp5bGNiaUFnTENCSmRHVnlZWFJ2Y25NZ0lDQWdJRDBnY21WeGRXbHlaU2duTGk5ZmFYUmxjbUYwYjNKekp5bGNiaUFnTENCVVQxOVRWRkpKVGtkZlZFRkhJRDBnY21WeGRXbHlaU2duTGk5ZmQydHpKeWtvSjNSdlUzUnlhVzVuVkdGbkp5azdYRzVjYm1admNpaDJZWElnWTI5c2JHVmpkR2x2Ym5NZ1BTQmJKMDV2WkdWTWFYTjBKeXdnSjBSUFRWUnZhMlZ1VEdsemRDY3NJQ2ROWldScFlVeHBjM1FuTENBblUzUjViR1ZUYUdWbGRFeHBjM1FuTENBblExTlRVblZzWlV4cGMzUW5YU3dnYVNBOUlEQTdJR2tnUENBMU95QnBLeXNwZTF4dUlDQjJZWElnVGtGTlJTQWdJQ0FnSUNBOUlHTnZiR3hsWTNScGIyNXpXMmxkWEc0Z0lDQWdMQ0JEYjJ4c1pXTjBhVzl1SUQwZ1oyeHZZbUZzVzA1QlRVVmRYRzRnSUNBZ0xDQndjbTkwYnlBZ0lDQWdJRDBnUTI5c2JHVmpkR2x2YmlBbUppQkRiMnhzWldOMGFXOXVMbkJ5YjNSdmRIbHdaVHRjYmlBZ2FXWW9jSEp2ZEc4Z0ppWWdJWEJ5YjNSdlcxUlBYMU5VVWtsT1IxOVVRVWRkS1docFpHVW9jSEp2ZEc4c0lGUlBYMU5VVWtsT1IxOVVRVWNzSUU1QlRVVXBPMXh1SUNCSmRHVnlZWFJ2Y25OYlRrRk5SVjBnUFNCSmRHVnlZWFJ2Y25NdVFYSnlZWGs3WEc1OVhHNWNibHh1THk4dkx5OHZMeTh2THk4dkx5OHZMeTh2WEc0dkx5QlhSVUpRUVVOTElFWlBUMVJGVWx4dUx5OGdMaTkrTDJOdmNtVXRhbk12YkdsaWNtRnllUzl0YjJSMWJHVnpMM2RsWWk1a2IyMHVhWFJsY21GaWJHVXVhbk5jYmk4dklHMXZaSFZzWlNCcFpDQTlJRFV4WEc0dkx5QnRiMlIxYkdVZ1kyaDFibXR6SUQwZ01DSXNJaWQxYzJVZ2MzUnlhV04wSnp0Y2JuWmhjaUJoWkdSVWIxVnVjMk52Y0dGaWJHVnpJRDBnY21WeGRXbHlaU2duTGk5ZllXUmtMWFJ2TFhWdWMyTnZjR0ZpYkdWekp5bGNiaUFnTENCemRHVndJQ0FnSUNBZ0lDQWdJQ0FnSUQwZ2NtVnhkV2x5WlNnbkxpOWZhWFJsY2kxemRHVndKeWxjYmlBZ0xDQkpkR1Z5WVhSdmNuTWdJQ0FnSUNBZ0lEMGdjbVZ4ZFdseVpTZ25MaTlmYVhSbGNtRjBiM0p6SnlsY2JpQWdMQ0IwYjBsUFltcGxZM1FnSUNBZ0lDQWdJRDBnY21WeGRXbHlaU2duTGk5ZmRHOHRhVzlpYW1WamRDY3BPMXh1WEc0dkx5QXlNaTR4TGpNdU5DQkJjbkpoZVM1d2NtOTBiM1I1Y0dVdVpXNTBjbWxsY3lncFhHNHZMeUF5TWk0eExqTXVNVE1nUVhKeVlYa3VjSEp2ZEc5MGVYQmxMbXRsZVhNb0tWeHVMeThnTWpJdU1TNHpMakk1SUVGeWNtRjVMbkJ5YjNSdmRIbHdaUzUyWVd4MVpYTW9LVnh1THk4Z01qSXVNUzR6TGpNd0lFRnljbUY1TG5CeWIzUnZkSGx3WlZ0QVFHbDBaWEpoZEc5eVhTZ3BYRzV0YjJSMWJHVXVaWGh3YjNKMGN5QTlJSEpsY1hWcGNtVW9KeTR2WDJsMFpYSXRaR1ZtYVc1bEp5a29RWEp5WVhrc0lDZEJjbkpoZVNjc0lHWjFibU4wYVc5dUtHbDBaWEpoZEdWa0xDQnJhVzVrS1h0Y2JpQWdkR2hwY3k1ZmRDQTlJSFJ2U1U5aWFtVmpkQ2hwZEdWeVlYUmxaQ2s3SUM4dklIUmhjbWRsZEZ4dUlDQjBhR2x6TGw5cElEMGdNRHNnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnTHk4Z2JtVjRkQ0JwYm1SbGVGeHVJQ0IwYUdsekxsOXJJRDBnYTJsdVpEc2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0x5OGdhMmx1WkZ4dUx5OGdNakl1TVM0MUxqSXVNU0FsUVhKeVlYbEpkR1Z5WVhSdmNsQnliM1J2ZEhsd1pTVXVibVY0ZENncFhHNTlMQ0JtZFc1amRHbHZiaWdwZTF4dUlDQjJZWElnVHlBZ0lDQWdQU0IwYUdsekxsOTBYRzRnSUNBZ0xDQnJhVzVrSUNBOUlIUm9hWE11WDJ0Y2JpQWdJQ0FzSUdsdVpHVjRJRDBnZEdocGN5NWZhU3NyTzF4dUlDQnBaaWdoVHlCOGZDQnBibVJsZUNBK1BTQlBMbXhsYm1kMGFDbDdYRzRnSUNBZ2RHaHBjeTVmZENBOUlIVnVaR1ZtYVc1bFpEdGNiaUFnSUNCeVpYUjFjbTRnYzNSbGNDZ3hLVHRjYmlBZ2ZWeHVJQ0JwWmlocmFXNWtJRDA5SUNkclpYbHpKeUFnS1hKbGRIVnliaUJ6ZEdWd0tEQXNJR2x1WkdWNEtUdGNiaUFnYVdZb2EybHVaQ0E5UFNBbmRtRnNkV1Z6SnlseVpYUjFjbTRnYzNSbGNDZ3dMQ0JQVzJsdVpHVjRYU2s3WEc0Z0lISmxkSFZ5YmlCemRHVndLREFzSUZ0cGJtUmxlQ3dnVDF0cGJtUmxlRjFkS1R0Y2JuMHNJQ2QyWVd4MVpYTW5LVHRjYmx4dUx5OGdZWEpuZFcxbGJuUnpUR2x6ZEZ0QVFHbDBaWEpoZEc5eVhTQnBjeUFsUVhKeVlYbFFjbTkwYjE5MllXeDFaWE1sSUNnNUxqUXVOQzQyTENBNUxqUXVOQzQzS1Z4dVNYUmxjbUYwYjNKekxrRnlaM1Z0Wlc1MGN5QTlJRWwwWlhKaGRHOXljeTVCY25KaGVUdGNibHh1WVdSa1ZHOVZibk5qYjNCaFlteGxjeWduYTJWNWN5Y3BPMXh1WVdSa1ZHOVZibk5qYjNCaFlteGxjeWduZG1Gc2RXVnpKeWs3WEc1aFpHUlViMVZ1YzJOdmNHRmliR1Z6S0NkbGJuUnlhV1Z6SnlrN1hHNWNibHh1THk4dkx5OHZMeTh2THk4dkx5OHZMeTh2WEc0dkx5QlhSVUpRUVVOTElFWlBUMVJGVWx4dUx5OGdMaTkrTDJOdmNtVXRhbk12YkdsaWNtRnllUzl0YjJSMWJHVnpMMlZ6Tmk1aGNuSmhlUzVwZEdWeVlYUnZjaTVxYzF4dUx5OGdiVzlrZFd4bElHbGtJRDBnTlRKY2JpOHZJRzF2WkhWc1pTQmphSFZ1YTNNZ1BTQXdJaXdpYlc5a2RXeGxMbVY0Y0c5eWRITWdQU0JtZFc1amRHbHZiaWdwZXlBdktpQmxiWEIwZVNBcUx5QjlPMXh1WEc1Y2JpOHZMeTh2THk4dkx5OHZMeTh2THk4dkwxeHVMeThnVjBWQ1VFRkRTeUJHVDA5VVJWSmNiaTh2SUM0dmZpOWpiM0psTFdwekwyeHBZbkpoY25rdmJXOWtkV3hsY3k5ZllXUmtMWFJ2TFhWdWMyTnZjR0ZpYkdWekxtcHpYRzR2THlCdGIyUjFiR1VnYVdRZ1BTQTFNMXh1THk4Z2JXOWtkV3hsSUdOb2RXNXJjeUE5SURBaUxDSnRiMlIxYkdVdVpYaHdiM0owY3lBOUlHWjFibU4wYVc5dUtHUnZibVVzSUhaaGJIVmxLWHRjYmlBZ2NtVjBkWEp1SUh0MllXeDFaVG9nZG1Gc2RXVXNJR1J2Ym1VNklDRWhaRzl1WlgwN1hHNTlPMXh1WEc1Y2JpOHZMeTh2THk4dkx5OHZMeTh2THk4dkwxeHVMeThnVjBWQ1VFRkRTeUJHVDA5VVJWSmNiaTh2SUM0dmZpOWpiM0psTFdwekwyeHBZbkpoY25rdmJXOWtkV3hsY3k5ZmFYUmxjaTF6ZEdWd0xtcHpYRzR2THlCdGIyUjFiR1VnYVdRZ1BTQTFORnh1THk4Z2JXOWtkV3hsSUdOb2RXNXJjeUE5SURBaUxDSmxlSEJ2Y25SekxtWWdQU0J5WlhGMWFYSmxLQ2N1TDE5M2EzTW5LVHRjYmx4dVhHNHZMeTh2THk4dkx5OHZMeTh2THk4dkx5OWNiaTh2SUZkRlFsQkJRMHNnUms5UFZFVlNYRzR2THlBdUwzNHZZMjl5WlMxcWN5OXNhV0p5WVhKNUwyMXZaSFZzWlhNdlgzZHJjeTFsZUhRdWFuTmNiaTh2SUcxdlpIVnNaU0JwWkNBOUlEVTFYRzR2THlCdGIyUjFiR1VnWTJoMWJtdHpJRDBnTUNJc0ltMXZaSFZzWlM1bGVIQnZjblJ6SUQwZ2V5QmNJbVJsWm1GMWJIUmNJam9nY21WeGRXbHlaU2hjSW1OdmNtVXRhbk12YkdsaWNtRnllUzltYmk5emVXMWliMnhjSWlrc0lGOWZaWE5OYjJSMWJHVTZJSFJ5ZFdVZ2ZUdGNibHh1WEc0dkx5OHZMeTh2THk4dkx5OHZMeTh2THk5Y2JpOHZJRmRGUWxCQlEwc2dSazlQVkVWU1hHNHZMeUF1TDM0dlltRmlaV3d0Y25WdWRHbHRaUzlqYjNKbExXcHpMM041YldKdmJDNXFjMXh1THk4Z2JXOWtkV3hsSUdsa0lEMGdOVFpjYmk4dklHMXZaSFZzWlNCamFIVnVhM01nUFNBd0lpd2ljbVZ4ZFdseVpTZ25MaTR2TGk0dmJXOWtkV3hsY3k5bGN6WXVjM2x0WW05c0p5azdYRzV5WlhGMWFYSmxLQ2N1TGk4dUxpOXRiMlIxYkdWekwyVnpOaTV2WW1wbFkzUXVkRzh0YzNSeWFXNW5KeWs3WEc1eVpYRjFhWEpsS0NjdUxpOHVMaTl0YjJSMWJHVnpMMlZ6Tnk1emVXMWliMnd1WVhONWJtTXRhWFJsY21GMGIzSW5LVHRjYm5KbGNYVnBjbVVvSnk0dUx5NHVMMjF2WkhWc1pYTXZaWE0zTG5ONWJXSnZiQzV2WW5ObGNuWmhZbXhsSnlrN1hHNXRiMlIxYkdVdVpYaHdiM0owY3lBOUlISmxjWFZwY21Vb0p5NHVMeTR1TDIxdlpIVnNaWE12WDJOdmNtVW5LUzVUZVcxaWIydzdYRzVjYmx4dUx5OHZMeTh2THk4dkx5OHZMeTh2THk4dlhHNHZMeUJYUlVKUVFVTkxJRVpQVDFSRlVseHVMeThnTGk5K0wyTnZjbVV0YW5NdmJHbGljbUZ5ZVM5bWJpOXplVzFpYjJ3dmFXNWtaWGd1YW5OY2JpOHZJRzF2WkhWc1pTQnBaQ0E5SURVM1hHNHZMeUJ0YjJSMWJHVWdZMmgxYm10eklEMGdNQ0lzSWlkMWMyVWdjM1J5YVdOMEp6dGNiaTh2SUVWRFRVRlRZM0pwY0hRZ05pQnplVzFpYjJ4eklITm9hVzFjYm5aaGNpQm5iRzlpWVd3Z0lDQWdJQ0FnSUNBOUlISmxjWFZwY21Vb0p5NHZYMmRzYjJKaGJDY3BYRzRnSUN3Z2FHRnpJQ0FnSUNBZ0lDQWdJQ0FnUFNCeVpYRjFhWEpsS0NjdUwxOW9ZWE1uS1Z4dUlDQXNJRVJGVTBOU1NWQlVUMUpUSUNBZ0lEMGdjbVZ4ZFdseVpTZ25MaTlmWkdWelkzSnBjSFJ2Y25NbktWeHVJQ0FzSUNSbGVIQnZjblFnSUNBZ0lDQWdJRDBnY21WeGRXbHlaU2duTGk5ZlpYaHdiM0owSnlsY2JpQWdMQ0J5WldSbFptbHVaU0FnSUNBZ0lDQTlJSEpsY1hWcGNtVW9KeTR2WDNKbFpHVm1hVzVsSnlsY2JpQWdMQ0JOUlZSQklDQWdJQ0FnSUNBZ0lDQTlJSEpsY1hWcGNtVW9KeTR2WDIxbGRHRW5LUzVMUlZsY2JpQWdMQ0FrWm1GcGJITWdJQ0FnSUNBZ0lDQTlJSEpsY1hWcGNtVW9KeTR2WDJaaGFXeHpKeWxjYmlBZ0xDQnphR0Z5WldRZ0lDQWdJQ0FnSUNBOUlISmxjWFZwY21Vb0p5NHZYM05vWVhKbFpDY3BYRzRnSUN3Z2MyVjBWRzlUZEhKcGJtZFVZV2NnUFNCeVpYRjFhWEpsS0NjdUwxOXpaWFF0ZEc4dGMzUnlhVzVuTFhSaFp5Y3BYRzRnSUN3Z2RXbGtJQ0FnSUNBZ0lDQWdJQ0FnUFNCeVpYRjFhWEpsS0NjdUwxOTFhV1FuS1Z4dUlDQXNJSGRyY3lBZ0lDQWdJQ0FnSUNBZ0lEMGdjbVZ4ZFdseVpTZ25MaTlmZDJ0ekp5bGNiaUFnTENCM2EzTkZlSFFnSUNBZ0lDQWdJQ0E5SUhKbGNYVnBjbVVvSnk0dlgzZHJjeTFsZUhRbktWeHVJQ0FzSUhkcmMwUmxabWx1WlNBZ0lDQWdJRDBnY21WeGRXbHlaU2duTGk5ZmQydHpMV1JsWm1sdVpTY3BYRzRnSUN3Z2EyVjVUMllnSUNBZ0lDQWdJQ0FnUFNCeVpYRjFhWEpsS0NjdUwxOXJaWGx2WmljcFhHNGdJQ3dnWlc1MWJVdGxlWE1nSUNBZ0lDQWdQU0J5WlhGMWFYSmxLQ2N1TDE5bGJuVnRMV3RsZVhNbktWeHVJQ0FzSUdselFYSnlZWGtnSUNBZ0lDQWdJRDBnY21WeGRXbHlaU2duTGk5ZmFYTXRZWEp5WVhrbktWeHVJQ0FzSUdGdVQySnFaV04wSUNBZ0lDQWdJRDBnY21WeGRXbHlaU2duTGk5ZllXNHRiMkpxWldOMEp5bGNiaUFnTENCMGIwbFBZbXBsWTNRZ0lDQWdJQ0E5SUhKbGNYVnBjbVVvSnk0dlgzUnZMV2x2WW1wbFkzUW5LVnh1SUNBc0lIUnZVSEpwYldsMGFYWmxJQ0FnSUQwZ2NtVnhkV2x5WlNnbkxpOWZkRzh0Y0hKcGJXbDBhWFpsSnlsY2JpQWdMQ0JqY21WaGRHVkVaWE5qSUNBZ0lDQTlJSEpsY1hWcGNtVW9KeTR2WDNCeWIzQmxjblI1TFdSbGMyTW5LVnh1SUNBc0lGOWpjbVZoZEdVZ0lDQWdJQ0FnSUQwZ2NtVnhkV2x5WlNnbkxpOWZiMkpxWldOMExXTnlaV0YwWlNjcFhHNGdJQ3dnWjA5UVRrVjRkQ0FnSUNBZ0lDQWdQU0J5WlhGMWFYSmxLQ2N1TDE5dlltcGxZM1F0WjI5d2JpMWxlSFFuS1Z4dUlDQXNJQ1JIVDFCRUlDQWdJQ0FnSUNBZ0lEMGdjbVZ4ZFdseVpTZ25MaTlmYjJKcVpXTjBMV2R2Y0dRbktWeHVJQ0FzSUNSRVVDQWdJQ0FnSUNBZ0lDQWdJRDBnY21WeGRXbHlaU2duTGk5ZmIySnFaV04wTFdSd0p5bGNiaUFnTENBa2EyVjVjeUFnSUNBZ0lDQWdJQ0E5SUhKbGNYVnBjbVVvSnk0dlgyOWlhbVZqZEMxclpYbHpKeWxjYmlBZ0xDQm5UMUJFSUNBZ0lDQWdJQ0FnSUNBOUlDUkhUMUJFTG1aY2JpQWdMQ0JrVUNBZ0lDQWdJQ0FnSUNBZ0lDQTlJQ1JFVUM1bVhHNGdJQ3dnWjA5UVRpQWdJQ0FnSUNBZ0lDQWdQU0JuVDFCT1JYaDBMbVpjYmlBZ0xDQWtVM2x0WW05c0lDQWdJQ0FnSUNBOUlHZHNiMkpoYkM1VGVXMWliMnhjYmlBZ0xDQWtTbE5QVGlBZ0lDQWdJQ0FnSUNBOUlHZHNiMkpoYkM1S1UwOU9YRzRnSUN3Z1gzTjBjbWx1WjJsbWVTQWdJQ0FnUFNBa1NsTlBUaUFtSmlBa1NsTlBUaTV6ZEhKcGJtZHBabmxjYmlBZ0xDQlFVazlVVDFSWlVFVWdJQ0FnSUNBOUlDZHdjbTkwYjNSNWNHVW5YRzRnSUN3Z1NFbEVSRVZPSUNBZ0lDQWdJQ0FnUFNCM2EzTW9KMTlvYVdSa1pXNG5LVnh1SUNBc0lGUlBYMUJTU1UxSlZFbFdSU0FnSUQwZ2QydHpLQ2QwYjFCeWFXMXBkR2wyWlNjcFhHNGdJQ3dnYVhORmJuVnRJQ0FnSUNBZ0lDQWdQU0I3ZlM1d2NtOXdaWEowZVVselJXNTFiV1Z5WVdKc1pWeHVJQ0FzSUZONWJXSnZiRkpsWjJsemRISjVJRDBnYzJoaGNtVmtLQ2R6ZVcxaWIyd3RjbVZuYVhOMGNua25LVnh1SUNBc0lFRnNiRk41YldKdmJITWdJQ0FnSUQwZ2MyaGhjbVZrS0NkemVXMWliMnh6SnlsY2JpQWdMQ0JQVUZONWJXSnZiSE1nSUNBZ0lDQTlJSE5vWVhKbFpDZ25iM0F0YzNsdFltOXNjeWNwWEc0Z0lDd2dUMkpxWldOMFVISnZkRzhnSUNBZ1BTQlBZbXBsWTNSYlVGSlBWRTlVV1ZCRlhWeHVJQ0FzSUZWVFJWOU9RVlJKVmtVZ0lDQWdJRDBnZEhsd1pXOW1JQ1JUZVcxaWIyd2dQVDBnSjJaMWJtTjBhVzl1SjF4dUlDQXNJRkZQWW1wbFkzUWdJQ0FnSUNBZ0lEMGdaMnh2WW1Gc0xsRlBZbXBsWTNRN1hHNHZMeUJFYjI0bmRDQjFjMlVnYzJWMGRHVnljeUJwYmlCUmRDQlRZM0pwY0hRc0lHaDBkSEJ6T2k4dloybDBhSFZpTG1OdmJTOTZiRzlwY205amF5OWpiM0psTFdwekwybHpjM1ZsY3k4eE56TmNiblpoY2lCelpYUjBaWElnUFNBaFVVOWlhbVZqZENCOGZDQWhVVTlpYW1WamRGdFFVazlVVDFSWlVFVmRJSHg4SUNGUlQySnFaV04wVzFCU1QxUlBWRmxRUlYwdVptbHVaRU5vYVd4a08xeHVYRzR2THlCbVlXeHNZbUZqYXlCbWIzSWdiMnhrSUVGdVpISnZhV1FzSUdoMGRIQnpPaTh2WTI5a1pTNW5iMjluYkdVdVkyOXRMM0F2ZGpndmFYTnpkV1Z6TDJSbGRHRnBiRDlwWkQwMk9EZGNiblpoY2lCelpYUlRlVzFpYjJ4RVpYTmpJRDBnUkVWVFExSkpVRlJQVWxNZ0ppWWdKR1poYVd4ektHWjFibU4wYVc5dUtDbDdYRzRnSUhKbGRIVnliaUJmWTNKbFlYUmxLR1JRS0h0OUxDQW5ZU2NzSUh0Y2JpQWdJQ0JuWlhRNklHWjFibU4wYVc5dUtDbDdJSEpsZEhWeWJpQmtVQ2gwYUdsekxDQW5ZU2NzSUh0MllXeDFaVG9nTjMwcExtRTdJSDFjYmlBZ2ZTa3BMbUVnSVQwZ056dGNibjBwSUQ4Z1puVnVZM1JwYjI0b2FYUXNJR3RsZVN3Z1JDbDdYRzRnSUhaaGNpQndjbTkwYjBSbGMyTWdQU0JuVDFCRUtFOWlhbVZqZEZCeWIzUnZMQ0JyWlhrcE8xeHVJQ0JwWmlod2NtOTBiMFJsYzJNcFpHVnNaWFJsSUU5aWFtVmpkRkJ5YjNSdlcydGxlVjA3WEc0Z0lHUlFLR2wwTENCclpYa3NJRVFwTzF4dUlDQnBaaWh3Y205MGIwUmxjMk1nSmlZZ2FYUWdJVDA5SUU5aWFtVmpkRkJ5YjNSdktXUlFLRTlpYW1WamRGQnliM1J2TENCclpYa3NJSEJ5YjNSdlJHVnpZeWs3WEc1OUlEb2daRkE3WEc1Y2JuWmhjaUIzY21Gd0lEMGdablZ1WTNScGIyNG9kR0ZuS1h0Y2JpQWdkbUZ5SUhONWJTQTlJRUZzYkZONWJXSnZiSE5iZEdGblhTQTlJRjlqY21WaGRHVW9KRk41YldKdmJGdFFVazlVVDFSWlVFVmRLVHRjYmlBZ2MzbHRMbDlySUQwZ2RHRm5PMXh1SUNCeVpYUjFjbTRnYzNsdE8xeHVmVHRjYmx4dWRtRnlJR2x6VTNsdFltOXNJRDBnVlZORlgwNUJWRWxXUlNBbUppQjBlWEJsYjJZZ0pGTjViV0p2YkM1cGRHVnlZWFJ2Y2lBOVBTQW5jM2x0WW05c0p5QS9JR1oxYm1OMGFXOXVLR2wwS1h0Y2JpQWdjbVYwZFhKdUlIUjVjR1Z2WmlCcGRDQTlQU0FuYzNsdFltOXNKenRjYm4wZ09pQm1kVzVqZEdsdmJpaHBkQ2w3WEc0Z0lISmxkSFZ5YmlCcGRDQnBibk4wWVc1alpXOW1JQ1JUZVcxaWIydzdYRzU5TzF4dVhHNTJZWElnSkdSbFptbHVaVkJ5YjNCbGNuUjVJRDBnWm5WdVkzUnBiMjRnWkdWbWFXNWxVSEp2Y0dWeWRIa29hWFFzSUd0bGVTd2dSQ2w3WEc0Z0lHbG1LR2wwSUQwOVBTQlBZbXBsWTNSUWNtOTBieWtrWkdWbWFXNWxVSEp2Y0dWeWRIa29UMUJUZVcxaWIyeHpMQ0JyWlhrc0lFUXBPMXh1SUNCaGJrOWlhbVZqZENocGRDazdYRzRnSUd0bGVTQTlJSFJ2VUhKcGJXbDBhWFpsS0d0bGVTd2dkSEoxWlNrN1hHNGdJR0Z1VDJKcVpXTjBLRVFwTzF4dUlDQnBaaWhvWVhNb1FXeHNVM2x0WW05c2N5d2dhMlY1S1NsN1hHNGdJQ0FnYVdZb0lVUXVaVzUxYldWeVlXSnNaU2w3WEc0Z0lDQWdJQ0JwWmlnaGFHRnpLR2wwTENCSVNVUkVSVTRwS1dSUUtHbDBMQ0JJU1VSRVJVNHNJR055WldGMFpVUmxjMk1vTVN3Z2UzMHBLVHRjYmlBZ0lDQWdJR2wwVzBoSlJFUkZUbDFiYTJWNVhTQTlJSFJ5ZFdVN1hHNGdJQ0FnZlNCbGJITmxJSHRjYmlBZ0lDQWdJR2xtS0doaGN5aHBkQ3dnU0VsRVJFVk9LU0FtSmlCcGRGdElTVVJFUlU1ZFcydGxlVjBwYVhSYlNFbEVSRVZPWFZ0clpYbGRJRDBnWm1Gc2MyVTdYRzRnSUNBZ0lDQkVJRDBnWDJOeVpXRjBaU2hFTENCN1pXNTFiV1Z5WVdKc1pUb2dZM0psWVhSbFJHVnpZeWd3TENCbVlXeHpaU2w5S1R0Y2JpQWdJQ0I5SUhKbGRIVnliaUJ6WlhSVGVXMWliMnhFWlhOaktHbDBMQ0JyWlhrc0lFUXBPMXh1SUNCOUlISmxkSFZ5YmlCa1VDaHBkQ3dnYTJWNUxDQkVLVHRjYm4wN1hHNTJZWElnSkdSbFptbHVaVkJ5YjNCbGNuUnBaWE1nUFNCbWRXNWpkR2x2YmlCa1pXWnBibVZRY205d1pYSjBhV1Z6S0dsMExDQlFLWHRjYmlBZ1lXNVBZbXBsWTNRb2FYUXBPMXh1SUNCMllYSWdhMlY1Y3lBOUlHVnVkVzFMWlhsektGQWdQU0IwYjBsUFltcGxZM1FvVUNrcFhHNGdJQ0FnTENCcElDQWdJRDBnTUZ4dUlDQWdJQ3dnYkNBOUlHdGxlWE11YkdWdVozUm9YRzRnSUNBZ0xDQnJaWGs3WEc0Z0lIZG9hV3hsS0d3Z1BpQnBLU1JrWldacGJtVlFjbTl3WlhKMGVTaHBkQ3dnYTJWNUlEMGdhMlY1YzF0cEt5dGRMQ0JRVzJ0bGVWMHBPMXh1SUNCeVpYUjFjbTRnYVhRN1hHNTlPMXh1ZG1GeUlDUmpjbVZoZEdVZ1BTQm1kVzVqZEdsdmJpQmpjbVZoZEdVb2FYUXNJRkFwZTF4dUlDQnlaWFIxY200Z1VDQTlQVDBnZFc1a1pXWnBibVZrSUQ4Z1gyTnlaV0YwWlNocGRDa2dPaUFrWkdWbWFXNWxVSEp2Y0dWeWRHbGxjeWhmWTNKbFlYUmxLR2wwS1N3Z1VDazdYRzU5TzF4dWRtRnlJQ1J3Y205d1pYSjBlVWx6Ulc1MWJXVnlZV0pzWlNBOUlHWjFibU4wYVc5dUlIQnliM0JsY25SNVNYTkZiblZ0WlhKaFlteGxLR3RsZVNsN1hHNGdJSFpoY2lCRklEMGdhWE5GYm5WdExtTmhiR3dvZEdocGN5d2dhMlY1SUQwZ2RHOVFjbWx0YVhScGRtVW9hMlY1TENCMGNuVmxLU2s3WEc0Z0lHbG1LSFJvYVhNZ1BUMDlJRTlpYW1WamRGQnliM1J2SUNZbUlHaGhjeWhCYkd4VGVXMWliMnh6TENCclpYa3BJQ1ltSUNGb1lYTW9UMUJUZVcxaWIyeHpMQ0JyWlhrcEtYSmxkSFZ5YmlCbVlXeHpaVHRjYmlBZ2NtVjBkWEp1SUVVZ2ZId2dJV2hoY3loMGFHbHpMQ0JyWlhrcElIeDhJQ0ZvWVhNb1FXeHNVM2x0WW05c2N5d2dhMlY1S1NCOGZDQm9ZWE1vZEdocGN5d2dTRWxFUkVWT0tTQW1KaUIwYUdselcwaEpSRVJGVGwxYmEyVjVYU0EvSUVVZ09pQjBjblZsTzF4dWZUdGNiblpoY2lBa1oyVjBUM2R1VUhKdmNHVnlkSGxFWlhOamNtbHdkRzl5SUQwZ1puVnVZM1JwYjI0Z1oyVjBUM2R1VUhKdmNHVnlkSGxFWlhOamNtbHdkRzl5S0dsMExDQnJaWGtwZTF4dUlDQnBkQ0FnUFNCMGIwbFBZbXBsWTNRb2FYUXBPMXh1SUNCclpYa2dQU0IwYjFCeWFXMXBkR2wyWlNoclpYa3NJSFJ5ZFdVcE8xeHVJQ0JwWmlocGRDQTlQVDBnVDJKcVpXTjBVSEp2ZEc4Z0ppWWdhR0Z6S0VGc2JGTjViV0p2YkhNc0lHdGxlU2tnSmlZZ0lXaGhjeWhQVUZONWJXSnZiSE1zSUd0bGVTa3BjbVYwZFhKdU8xeHVJQ0IyWVhJZ1JDQTlJR2RQVUVRb2FYUXNJR3RsZVNrN1hHNGdJR2xtS0VRZ0ppWWdhR0Z6S0VGc2JGTjViV0p2YkhNc0lHdGxlU2tnSmlZZ0lTaG9ZWE1vYVhRc0lFaEpSRVJGVGlrZ0ppWWdhWFJiU0VsRVJFVk9YVnRyWlhsZEtTbEVMbVZ1ZFcxbGNtRmliR1VnUFNCMGNuVmxPMXh1SUNCeVpYUjFjbTRnUkR0Y2JuMDdYRzUyWVhJZ0pHZGxkRTkzYmxCeWIzQmxjblI1VG1GdFpYTWdQU0JtZFc1amRHbHZiaUJuWlhSUGQyNVFjbTl3WlhKMGVVNWhiV1Z6S0dsMEtYdGNiaUFnZG1GeUlHNWhiV1Z6SUNBOUlHZFBVRTRvZEc5SlQySnFaV04wS0dsMEtTbGNiaUFnSUNBc0lISmxjM1ZzZENBOUlGdGRYRzRnSUNBZ0xDQnBJQ0FnSUNBZ1BTQXdYRzRnSUNBZ0xDQnJaWGs3WEc0Z0lIZG9hV3hsS0c1aGJXVnpMbXhsYm1kMGFDQStJR2twZTF4dUlDQWdJR2xtS0NGb1lYTW9RV3hzVTNsdFltOXNjeXdnYTJWNUlEMGdibUZ0WlhOYmFTc3JYU2tnSmlZZ2EyVjVJQ0U5SUVoSlJFUkZUaUFtSmlCclpYa2dJVDBnVFVWVVFTbHlaWE4xYkhRdWNIVnphQ2hyWlhrcE8xeHVJQ0I5SUhKbGRIVnliaUJ5WlhOMWJIUTdYRzU5TzF4dWRtRnlJQ1JuWlhSUGQyNVFjbTl3WlhKMGVWTjViV0p2YkhNZ1BTQm1kVzVqZEdsdmJpQm5aWFJQZDI1UWNtOXdaWEowZVZONWJXSnZiSE1vYVhRcGUxeHVJQ0IyWVhJZ1NWTmZUMUFnSUQwZ2FYUWdQVDA5SUU5aWFtVmpkRkJ5YjNSdlhHNGdJQ0FnTENCdVlXMWxjeUFnUFNCblQxQk9LRWxUWDA5UUlEOGdUMUJUZVcxaWIyeHpJRG9nZEc5SlQySnFaV04wS0dsMEtTbGNiaUFnSUNBc0lISmxjM1ZzZENBOUlGdGRYRzRnSUNBZ0xDQnBJQ0FnSUNBZ1BTQXdYRzRnSUNBZ0xDQnJaWGs3WEc0Z0lIZG9hV3hsS0c1aGJXVnpMbXhsYm1kMGFDQStJR2twZTF4dUlDQWdJR2xtS0doaGN5aEJiR3hUZVcxaWIyeHpMQ0JyWlhrZ1BTQnVZVzFsYzF0cEt5dGRLU0FtSmlBb1NWTmZUMUFnUHlCb1lYTW9UMkpxWldOMFVISnZkRzhzSUd0bGVTa2dPaUIwY25WbEtTbHlaWE4xYkhRdWNIVnphQ2hCYkd4VGVXMWliMnh6VzJ0bGVWMHBPMXh1SUNCOUlISmxkSFZ5YmlCeVpYTjFiSFE3WEc1OU8xeHVYRzR2THlBeE9TNDBMakV1TVNCVGVXMWliMndvVzJSbGMyTnlhWEIwYVc5dVhTbGNibWxtS0NGVlUwVmZUa0ZVU1ZaRktYdGNiaUFnSkZONWJXSnZiQ0E5SUdaMWJtTjBhVzl1SUZONWJXSnZiQ2dwZTF4dUlDQWdJR2xtS0hSb2FYTWdhVzV6ZEdGdVkyVnZaaUFrVTNsdFltOXNLWFJvY205M0lGUjVjR1ZGY25KdmNpZ25VM2x0WW05c0lHbHpJRzV2ZENCaElHTnZibk4wY25WamRHOXlJU2NwTzF4dUlDQWdJSFpoY2lCMFlXY2dQU0IxYVdRb1lYSm5kVzFsYm5SekxteGxibWQwYUNBK0lEQWdQeUJoY21kMWJXVnVkSE5iTUYwZ09pQjFibVJsWm1sdVpXUXBPMXh1SUNBZ0lIWmhjaUFrYzJWMElEMGdablZ1WTNScGIyNG9kbUZzZFdVcGUxeHVJQ0FnSUNBZ2FXWW9kR2hwY3lBOVBUMGdUMkpxWldOMFVISnZkRzhwSkhObGRDNWpZV3hzS0U5UVUzbHRZbTlzY3l3Z2RtRnNkV1VwTzF4dUlDQWdJQ0FnYVdZb2FHRnpLSFJvYVhNc0lFaEpSRVJGVGlrZ0ppWWdhR0Z6S0hSb2FYTmJTRWxFUkVWT1hTd2dkR0ZuS1NsMGFHbHpXMGhKUkVSRlRsMWJkR0ZuWFNBOUlHWmhiSE5sTzF4dUlDQWdJQ0FnYzJWMFUzbHRZbTlzUkdWell5aDBhR2x6TENCMFlXY3NJR055WldGMFpVUmxjMk1vTVN3Z2RtRnNkV1VwS1R0Y2JpQWdJQ0I5TzF4dUlDQWdJR2xtS0VSRlUwTlNTVkJVVDFKVElDWW1JSE5sZEhSbGNpbHpaWFJUZVcxaWIyeEVaWE5qS0U5aWFtVmpkRkJ5YjNSdkxDQjBZV2NzSUh0amIyNW1hV2QxY21GaWJHVTZJSFJ5ZFdVc0lITmxkRG9nSkhObGRIMHBPMXh1SUNBZ0lISmxkSFZ5YmlCM2NtRndLSFJoWnlrN1hHNGdJSDA3WEc0Z0lISmxaR1ZtYVc1bEtDUlRlVzFpYjJ4YlVGSlBWRTlVV1ZCRlhTd2dKM1J2VTNSeWFXNW5KeXdnWm5WdVkzUnBiMjRnZEc5VGRISnBibWNvS1h0Y2JpQWdJQ0J5WlhSMWNtNGdkR2hwY3k1ZmF6dGNiaUFnZlNrN1hHNWNiaUFnSkVkUFVFUXVaaUE5SUNSblpYUlBkMjVRY205d1pYSjBlVVJsYzJOeWFYQjBiM0k3WEc0Z0lDUkVVQzVtSUNBZ1BTQWtaR1ZtYVc1bFVISnZjR1Z5ZEhrN1hHNGdJSEpsY1hWcGNtVW9KeTR2WDI5aWFtVmpkQzFuYjNCdUp5a3VaaUE5SUdkUFVFNUZlSFF1WmlBOUlDUm5aWFJQZDI1UWNtOXdaWEowZVU1aGJXVnpPMXh1SUNCeVpYRjFhWEpsS0NjdUwxOXZZbXBsWTNRdGNHbGxKeWt1WmlBZ1BTQWtjSEp2Y0dWeWRIbEpjMFZ1ZFcxbGNtRmliR1U3WEc0Z0lISmxjWFZwY21Vb0p5NHZYMjlpYW1WamRDMW5iM0J6SnlrdVppQTlJQ1JuWlhSUGQyNVFjbTl3WlhKMGVWTjViV0p2YkhNN1hHNWNiaUFnYVdZb1JFVlRRMUpKVUZSUFVsTWdKaVlnSVhKbGNYVnBjbVVvSnk0dlgyeHBZbkpoY25rbktTbDdYRzRnSUNBZ2NtVmtaV1pwYm1Vb1QySnFaV04wVUhKdmRHOHNJQ2R3Y205d1pYSjBlVWx6Ulc1MWJXVnlZV0pzWlNjc0lDUndjbTl3WlhKMGVVbHpSVzUxYldWeVlXSnNaU3dnZEhKMVpTazdYRzRnSUgxY2JseHVJQ0IzYTNORmVIUXVaaUE5SUdaMWJtTjBhVzl1S0c1aGJXVXBlMXh1SUNBZ0lISmxkSFZ5YmlCM2NtRndLSGRyY3lodVlXMWxLU2s3WEc0Z0lIMWNibjFjYmx4dUpHVjRjRzl5ZENna1pYaHdiM0owTGtjZ0t5QWtaWGh3YjNKMExsY2dLeUFrWlhod2IzSjBMa1lnS2lBaFZWTkZYMDVCVkVsV1JTd2dlMU41YldKdmJEb2dKRk41YldKdmJIMHBPMXh1WEc1bWIzSW9kbUZ5SUhONWJXSnZiSE1nUFNBb1hHNGdJQzh2SURFNUxqUXVNaTR5TENBeE9TNDBMakl1TXl3Z01Ua3VOQzR5TGpRc0lERTVMalF1TWk0MkxDQXhPUzQwTGpJdU9Dd2dNVGt1TkM0eUxqa3NJREU1TGpRdU1pNHhNQ3dnTVRrdU5DNHlMakV4TENBeE9TNDBMakl1TVRJc0lERTVMalF1TWk0eE15d2dNVGt1TkM0eUxqRTBYRzRnSUNkb1lYTkpibk4wWVc1alpTeHBjME52Ym1OaGRGTndjbVZoWkdGaWJHVXNhWFJsY21GMGIzSXNiV0YwWTJnc2NtVndiR0ZqWlN4elpXRnlZMmdzYzNCbFkybGxjeXh6Y0d4cGRDeDBiMUJ5YVcxcGRHbDJaU3gwYjFOMGNtbHVaMVJoWnl4MWJuTmpiM0JoWW14bGN5ZGNiaWt1YzNCc2FYUW9KeXduS1N3Z2FTQTlJREE3SUhONWJXSnZiSE11YkdWdVozUm9JRDRnYVRzZ0tYZHJjeWh6ZVcxaWIyeHpXMmtySzEwcE8xeHVYRzVtYjNJb2RtRnlJSE41YldKdmJITWdQU0FrYTJWNWN5aDNhM011YzNSdmNtVXBMQ0JwSUQwZ01Ec2djM2x0WW05c2N5NXNaVzVuZEdnZ1BpQnBPeUFwZDJ0elJHVm1hVzVsS0hONWJXSnZiSE5iYVNzclhTazdYRzVjYmlSbGVIQnZjblFvSkdWNGNHOXlkQzVUSUNzZ0pHVjRjRzl5ZEM1R0lDb2dJVlZUUlY5T1FWUkpWa1VzSUNkVGVXMWliMnduTENCN1hHNGdJQzh2SURFNUxqUXVNaTR4SUZONWJXSnZiQzVtYjNJb2EyVjVLVnh1SUNBblptOXlKem9nWm5WdVkzUnBiMjRvYTJWNUtYdGNiaUFnSUNCeVpYUjFjbTRnYUdGektGTjViV0p2YkZKbFoybHpkSEo1TENCclpYa2dLejBnSnljcFhHNGdJQ0FnSUNBL0lGTjViV0p2YkZKbFoybHpkSEo1VzJ0bGVWMWNiaUFnSUNBZ0lEb2dVM2x0WW05c1VtVm5hWE4wY25sYmEyVjVYU0E5SUNSVGVXMWliMndvYTJWNUtUdGNiaUFnZlN4Y2JpQWdMeThnTVRrdU5DNHlMalVnVTNsdFltOXNMbXRsZVVadmNpaHplVzBwWEc0Z0lHdGxlVVp2Y2pvZ1puVnVZM1JwYjI0Z2EyVjVSbTl5S0d0bGVTbDdYRzRnSUNBZ2FXWW9hWE5UZVcxaWIyd29hMlY1S1NseVpYUjFjbTRnYTJWNVQyWW9VM2x0WW05c1VtVm5hWE4wY25rc0lHdGxlU2s3WEc0Z0lDQWdkR2h5YjNjZ1ZIbHdaVVZ5Y205eUtHdGxlU0FySUNjZ2FYTWdibTkwSUdFZ2MzbHRZbTlzSVNjcE8xeHVJQ0I5TEZ4dUlDQjFjMlZUWlhSMFpYSTZJR1oxYm1OMGFXOXVLQ2w3SUhObGRIUmxjaUE5SUhSeWRXVTdJSDBzWEc0Z0lIVnpaVk5wYlhCc1pUb2dablZ1WTNScGIyNG9LWHNnYzJWMGRHVnlJRDBnWm1Gc2MyVTdJSDFjYm4wcE8xeHVYRzRrWlhod2IzSjBLQ1JsZUhCdmNuUXVVeUFySUNSbGVIQnZjblF1UmlBcUlDRlZVMFZmVGtGVVNWWkZMQ0FuVDJKcVpXTjBKeXdnZTF4dUlDQXZMeUF4T1M0eExqSXVNaUJQWW1wbFkzUXVZM0psWVhSbEtFOGdXeXdnVUhKdmNHVnlkR2xsYzEwcFhHNGdJR055WldGMFpUb2dKR055WldGMFpTeGNiaUFnTHk4Z01Ua3VNUzR5TGpRZ1QySnFaV04wTG1SbFptbHVaVkJ5YjNCbGNuUjVLRThzSUZBc0lFRjBkSEpwWW5WMFpYTXBYRzRnSUdSbFptbHVaVkJ5YjNCbGNuUjVPaUFrWkdWbWFXNWxVSEp2Y0dWeWRIa3NYRzRnSUM4dklERTVMakV1TWk0eklFOWlhbVZqZEM1a1pXWnBibVZRY205d1pYSjBhV1Z6S0U4c0lGQnliM0JsY25ScFpYTXBYRzRnSUdSbFptbHVaVkJ5YjNCbGNuUnBaWE02SUNSa1pXWnBibVZRY205d1pYSjBhV1Z6TEZ4dUlDQXZMeUF4T1M0eExqSXVOaUJQWW1wbFkzUXVaMlYwVDNkdVVISnZjR1Z5ZEhsRVpYTmpjbWx3ZEc5eUtFOHNJRkFwWEc0Z0lHZGxkRTkzYmxCeWIzQmxjblI1UkdWelkzSnBjSFJ2Y2pvZ0pHZGxkRTkzYmxCeWIzQmxjblI1UkdWelkzSnBjSFJ2Y2l4Y2JpQWdMeThnTVRrdU1TNHlMamNnVDJKcVpXTjBMbWRsZEU5M2JsQnliM0JsY25SNVRtRnRaWE1vVHlsY2JpQWdaMlYwVDNkdVVISnZjR1Z5ZEhsT1lXMWxjem9nSkdkbGRFOTNibEJ5YjNCbGNuUjVUbUZ0WlhNc1hHNGdJQzh2SURFNUxqRXVNaTQ0SUU5aWFtVmpkQzVuWlhSUGQyNVFjbTl3WlhKMGVWTjViV0p2YkhNb1R5bGNiaUFnWjJWMFQzZHVVSEp2Y0dWeWRIbFRlVzFpYjJ4ek9pQWtaMlYwVDNkdVVISnZjR1Z5ZEhsVGVXMWliMnh6WEc1OUtUdGNibHh1THk4Z01qUXVNeTR5SUVwVFQwNHVjM1J5YVc1bmFXWjVLSFpoYkhWbElGc3NJSEpsY0d4aFkyVnlJRnNzSUhOd1lXTmxYVjBwWEc0a1NsTlBUaUFtSmlBa1pYaHdiM0owS0NSbGVIQnZjblF1VXlBcklDUmxlSEJ2Y25RdVJpQXFJQ2doVlZORlgwNUJWRWxXUlNCOGZDQWtabUZwYkhNb1puVnVZM1JwYjI0b0tYdGNiaUFnZG1GeUlGTWdQU0FrVTNsdFltOXNLQ2s3WEc0Z0lDOHZJRTFUSUVWa1oyVWdZMjl1ZG1WeWRITWdjM2x0WW05c0lIWmhiSFZsY3lCMGJ5QktVMDlPSUdGeklIdDlYRzRnSUM4dklGZGxZa3RwZENCamIyNTJaWEowY3lCemVXMWliMndnZG1Gc2RXVnpJSFJ2SUVwVFQwNGdZWE1nYm5Wc2JGeHVJQ0F2THlCV09DQjBhSEp2ZDNNZ2IyNGdZbTk0WldRZ2MzbHRZbTlzYzF4dUlDQnlaWFIxY200Z1gzTjBjbWx1WjJsbWVTaGJVMTBwSUNFOUlDZGJiblZzYkYwbklIeDhJRjl6ZEhKcGJtZHBabmtvZTJFNklGTjlLU0FoUFNBbmUzMG5JSHg4SUY5emRISnBibWRwWm5rb1QySnFaV04wS0ZNcEtTQWhQU0FuZTMwbk8xeHVmU2twTENBblNsTlBUaWNzSUh0Y2JpQWdjM1J5YVc1bmFXWjVPaUJtZFc1amRHbHZiaUJ6ZEhKcGJtZHBabmtvYVhRcGUxeHVJQ0FnSUdsbUtHbDBJRDA5UFNCMWJtUmxabWx1WldRZ2ZId2dhWE5UZVcxaWIyd29hWFFwS1hKbGRIVnlianNnTHk4Z1NVVTRJSEpsZEhWeWJuTWdjM1J5YVc1bklHOXVJSFZ1WkdWbWFXNWxaRnh1SUNBZ0lIWmhjaUJoY21keklEMGdXMmwwWFZ4dUlDQWdJQ0FnTENCcElDQWdJRDBnTVZ4dUlDQWdJQ0FnTENCeVpYQnNZV05sY2l3Z0pISmxjR3hoWTJWeU8xeHVJQ0FnSUhkb2FXeGxLR0Z5WjNWdFpXNTBjeTVzWlc1bmRHZ2dQaUJwS1dGeVozTXVjSFZ6YUNoaGNtZDFiV1Z1ZEhOYmFTc3JYU2s3WEc0Z0lDQWdjbVZ3YkdGalpYSWdQU0JoY21keld6RmRPMXh1SUNBZ0lHbG1LSFI1Y0dWdlppQnlaWEJzWVdObGNpQTlQU0FuWm5WdVkzUnBiMjRuS1NSeVpYQnNZV05sY2lBOUlISmxjR3hoWTJWeU8xeHVJQ0FnSUdsbUtDUnlaWEJzWVdObGNpQjhmQ0FoYVhOQmNuSmhlU2h5WlhCc1lXTmxjaWtwY21Wd2JHRmpaWElnUFNCbWRXNWpkR2x2YmloclpYa3NJSFpoYkhWbEtYdGNiaUFnSUNBZ0lHbG1LQ1J5WlhCc1lXTmxjaWwyWVd4MVpTQTlJQ1J5WlhCc1lXTmxjaTVqWVd4c0tIUm9hWE1zSUd0bGVTd2dkbUZzZFdVcE8xeHVJQ0FnSUNBZ2FXWW9JV2x6VTNsdFltOXNLSFpoYkhWbEtTbHlaWFIxY200Z2RtRnNkV1U3WEc0Z0lDQWdmVHRjYmlBZ0lDQmhjbWR6V3pGZElEMGdjbVZ3YkdGalpYSTdYRzRnSUNBZ2NtVjBkWEp1SUY5emRISnBibWRwWm5rdVlYQndiSGtvSkVwVFQwNHNJR0Z5WjNNcE8xeHVJQ0I5WEc1OUtUdGNibHh1THk4Z01Ua3VOQzR6TGpRZ1UzbHRZbTlzTG5CeWIzUnZkSGx3WlZ0QVFIUnZVSEpwYldsMGFYWmxYU2hvYVc1MEtWeHVKRk41YldKdmJGdFFVazlVVDFSWlVFVmRXMVJQWDFCU1NVMUpWRWxXUlYwZ2ZId2djbVZ4ZFdseVpTZ25MaTlmYUdsa1pTY3BLQ1JUZVcxaWIyeGJVRkpQVkU5VVdWQkZYU3dnVkU5ZlVGSkpUVWxVU1ZaRkxDQWtVM2x0WW05c1cxQlNUMVJQVkZsUVJWMHVkbUZzZFdWUFppazdYRzR2THlBeE9TNDBMak11TlNCVGVXMWliMnd1Y0hKdmRHOTBlWEJsVzBCQWRHOVRkSEpwYm1kVVlXZGRYRzV6WlhSVWIxTjBjbWx1WjFSaFp5Z2tVM2x0WW05c0xDQW5VM2x0WW05c0p5azdYRzR2THlBeU1DNHlMakV1T1NCTllYUm9XMEJBZEc5VGRISnBibWRVWVdkZFhHNXpaWFJVYjFOMGNtbHVaMVJoWnloTllYUm9MQ0FuVFdGMGFDY3NJSFJ5ZFdVcE8xeHVMeThnTWpRdU15NHpJRXBUVDA1YlFFQjBiMU4wY21sdVoxUmhaMTFjYm5ObGRGUnZVM1J5YVc1blZHRm5LR2RzYjJKaGJDNUtVMDlPTENBblNsTlBUaWNzSUhSeWRXVXBPMXh1WEc1Y2JpOHZMeTh2THk4dkx5OHZMeTh2THk4dkwxeHVMeThnVjBWQ1VFRkRTeUJHVDA5VVJWSmNiaTh2SUM0dmZpOWpiM0psTFdwekwyeHBZbkpoY25rdmJXOWtkV3hsY3k5bGN6WXVjM2x0WW05c0xtcHpYRzR2THlCdGIyUjFiR1VnYVdRZ1BTQTFPRnh1THk4Z2JXOWtkV3hsSUdOb2RXNXJjeUE5SURBaUxDSjJZWElnVFVWVVFTQWdJQ0FnUFNCeVpYRjFhWEpsS0NjdUwxOTFhV1FuS1NnbmJXVjBZU2NwWEc0Z0lDd2dhWE5QWW1wbFkzUWdQU0J5WlhGMWFYSmxLQ2N1TDE5cGN5MXZZbXBsWTNRbktWeHVJQ0FzSUdoaGN5QWdJQ0FnSUQwZ2NtVnhkV2x5WlNnbkxpOWZhR0Z6SnlsY2JpQWdMQ0J6WlhSRVpYTmpJQ0E5SUhKbGNYVnBjbVVvSnk0dlgyOWlhbVZqZEMxa2NDY3BMbVpjYmlBZ0xDQnBaQ0FnSUNBZ0lDQTlJREE3WEc1MllYSWdhWE5GZUhSbGJuTnBZbXhsSUQwZ1QySnFaV04wTG1selJYaDBaVzV6YVdKc1pTQjhmQ0JtZFc1amRHbHZiaWdwZTF4dUlDQnlaWFIxY200Z2RISjFaVHRjYm4wN1hHNTJZWElnUmxKRlJWcEZJRDBnSVhKbGNYVnBjbVVvSnk0dlgyWmhhV3h6Snlrb1puVnVZM1JwYjI0b0tYdGNiaUFnY21WMGRYSnVJR2x6UlhoMFpXNXphV0pzWlNoUFltcGxZM1F1Y0hKbGRtVnVkRVY0ZEdWdWMybHZibk1vZTMwcEtUdGNibjBwTzF4dWRtRnlJSE5sZEUxbGRHRWdQU0JtZFc1amRHbHZiaWhwZENsN1hHNGdJSE5sZEVSbGMyTW9hWFFzSUUxRlZFRXNJSHQyWVd4MVpUb2dlMXh1SUNBZ0lHazZJQ2RQSnlBcklDc3JhV1FzSUM4dklHOWlhbVZqZENCSlJGeHVJQ0FnSUhjNklIdDlJQ0FnSUNBZ0lDQWdJQzh2SUhkbFlXc2dZMjlzYkdWamRHbHZibk1nU1VSelhHNGdJSDE5S1R0Y2JuMDdYRzUyWVhJZ1ptRnpkRXRsZVNBOUlHWjFibU4wYVc5dUtHbDBMQ0JqY21WaGRHVXBlMXh1SUNBdkx5QnlaWFIxY200Z2NISnBiV2wwYVhabElIZHBkR2dnY0hKbFptbDRYRzRnSUdsbUtDRnBjMDlpYW1WamRDaHBkQ2twY21WMGRYSnVJSFI1Y0dWdlppQnBkQ0E5UFNBbmMzbHRZbTlzSnlBL0lHbDBJRG9nS0hSNWNHVnZaaUJwZENBOVBTQW5jM1J5YVc1bkp5QS9JQ2RUSnlBNklDZFFKeWtnS3lCcGREdGNiaUFnYVdZb0lXaGhjeWhwZEN3Z1RVVlVRU2twZTF4dUlDQWdJQzh2SUdOaGJpZDBJSE5sZENCdFpYUmhaR0YwWVNCMGJ5QjFibU5oZFdkb2RDQm1jbTk2Wlc0Z2IySnFaV04wWEc0Z0lDQWdhV1lvSVdselJYaDBaVzV6YVdKc1pTaHBkQ2twY21WMGRYSnVJQ2RHSnp0Y2JpQWdJQ0F2THlCdWIzUWdibVZqWlhOellYSjVJSFJ2SUdGa1pDQnRaWFJoWkdGMFlWeHVJQ0FnSUdsbUtDRmpjbVZoZEdVcGNtVjBkWEp1SUNkRkp6dGNiaUFnSUNBdkx5QmhaR1FnYldsemMybHVaeUJ0WlhSaFpHRjBZVnh1SUNBZ0lITmxkRTFsZEdFb2FYUXBPMXh1SUNBdkx5QnlaWFIxY200Z2IySnFaV04wSUVsRVhHNGdJSDBnY21WMGRYSnVJR2wwVzAxRlZFRmRMbWs3WEc1OU8xeHVkbUZ5SUdkbGRGZGxZV3NnUFNCbWRXNWpkR2x2YmlocGRDd2dZM0psWVhSbEtYdGNiaUFnYVdZb0lXaGhjeWhwZEN3Z1RVVlVRU2twZTF4dUlDQWdJQzh2SUdOaGJpZDBJSE5sZENCdFpYUmhaR0YwWVNCMGJ5QjFibU5oZFdkb2RDQm1jbTk2Wlc0Z2IySnFaV04wWEc0Z0lDQWdhV1lvSVdselJYaDBaVzV6YVdKc1pTaHBkQ2twY21WMGRYSnVJSFJ5ZFdVN1hHNGdJQ0FnTHk4Z2JtOTBJRzVsWTJWemMyRnllU0IwYnlCaFpHUWdiV1YwWVdSaGRHRmNiaUFnSUNCcFppZ2hZM0psWVhSbEtYSmxkSFZ5YmlCbVlXeHpaVHRjYmlBZ0lDQXZMeUJoWkdRZ2JXbHpjMmx1WnlCdFpYUmhaR0YwWVZ4dUlDQWdJSE5sZEUxbGRHRW9hWFFwTzF4dUlDQXZMeUJ5WlhSMWNtNGdhR0Z6YUNCM1pXRnJJR052Ykd4bFkzUnBiMjV6SUVsRWMxeHVJQ0I5SUhKbGRIVnliaUJwZEZ0TlJWUkJYUzUzTzF4dWZUdGNiaTh2SUdGa1pDQnRaWFJoWkdGMFlTQnZiaUJtY21WbGVtVXRabUZ0YVd4NUlHMWxkR2h2WkhNZ1kyRnNiR2x1WjF4dWRtRnlJRzl1Um5KbFpYcGxJRDBnWm5WdVkzUnBiMjRvYVhRcGUxeHVJQ0JwWmloR1VrVkZXa1VnSmlZZ2JXVjBZUzVPUlVWRUlDWW1JR2x6UlhoMFpXNXphV0pzWlNocGRDa2dKaVlnSVdoaGN5aHBkQ3dnVFVWVVFTa3BjMlYwVFdWMFlTaHBkQ2s3WEc0Z0lISmxkSFZ5YmlCcGREdGNibjA3WEc1MllYSWdiV1YwWVNBOUlHMXZaSFZzWlM1bGVIQnZjblJ6SUQwZ2UxeHVJQ0JMUlZrNklDQWdJQ0FnVFVWVVFTeGNiaUFnVGtWRlJEb2dJQ0FnSUdaaGJITmxMRnh1SUNCbVlYTjBTMlY1T2lBZ1ptRnpkRXRsZVN4Y2JpQWdaMlYwVjJWaGF6b2dJR2RsZEZkbFlXc3NYRzRnSUc5dVJuSmxaWHBsT2lCdmJrWnlaV1Y2WlZ4dWZUdGNibHh1WEc0dkx5OHZMeTh2THk4dkx5OHZMeTh2THk5Y2JpOHZJRmRGUWxCQlEwc2dSazlQVkVWU1hHNHZMeUF1TDM0dlkyOXlaUzFxY3k5c2FXSnlZWEo1TDIxdlpIVnNaWE12WDIxbGRHRXVhbk5jYmk4dklHMXZaSFZzWlNCcFpDQTlJRFU1WEc0dkx5QnRiMlIxYkdVZ1kyaDFibXR6SUQwZ01DSXNJblpoY2lCbmJHOWlZV3dnSUNBZ0lDQWdJQ0E5SUhKbGNYVnBjbVVvSnk0dlgyZHNiMkpoYkNjcFhISmNiaUFnTENCamIzSmxJQ0FnSUNBZ0lDQWdJQ0E5SUhKbGNYVnBjbVVvSnk0dlgyTnZjbVVuS1Z4eVhHNGdJQ3dnVEVsQ1VrRlNXU0FnSUNBZ0lDQWdQU0J5WlhGMWFYSmxLQ2N1TDE5c2FXSnlZWEo1SnlsY2NseHVJQ0FzSUhkcmMwVjRkQ0FnSUNBZ0lDQWdJRDBnY21WeGRXbHlaU2duTGk5ZmQydHpMV1Y0ZENjcFhISmNiaUFnTENCa1pXWnBibVZRY205d1pYSjBlU0E5SUhKbGNYVnBjbVVvSnk0dlgyOWlhbVZqZEMxa2NDY3BMbVk3WEhKY2JtMXZaSFZzWlM1bGVIQnZjblJ6SUQwZ1puVnVZM1JwYjI0b2JtRnRaU2w3WEhKY2JpQWdkbUZ5SUNSVGVXMWliMndnUFNCamIzSmxMbE41YldKdmJDQjhmQ0FvWTI5eVpTNVRlVzFpYjJ3Z1BTQk1TVUpTUVZKWklEOGdlMzBnT2lCbmJHOWlZV3d1VTNsdFltOXNJSHg4SUh0OUtUdGNjbHh1SUNCcFppaHVZVzFsTG1Ob1lYSkJkQ2d3S1NBaFBTQW5YeWNnSmlZZ0lTaHVZVzFsSUdsdUlDUlRlVzFpYjJ3cEtXUmxabWx1WlZCeWIzQmxjblI1S0NSVGVXMWliMndzSUc1aGJXVXNJSHQyWVd4MVpUb2dkMnR6UlhoMExtWW9ibUZ0WlNsOUtUdGNjbHh1ZlR0Y2JseHVYRzR2THk4dkx5OHZMeTh2THk4dkx5OHZMeTljYmk4dklGZEZRbEJCUTBzZ1JrOVBWRVZTWEc0dkx5QXVMMzR2WTI5eVpTMXFjeTlzYVdKeVlYSjVMMjF2WkhWc1pYTXZYM2RyY3kxa1pXWnBibVV1YW5OY2JpOHZJRzF2WkhWc1pTQnBaQ0E5SURZd1hHNHZMeUJ0YjJSMWJHVWdZMmgxYm10eklEMGdNQ0lzSW5aaGNpQm5aWFJMWlhseklDQWdQU0J5WlhGMWFYSmxLQ2N1TDE5dlltcGxZM1F0YTJWNWN5Y3BYRzRnSUN3Z2RHOUpUMkpxWldOMElEMGdjbVZ4ZFdseVpTZ25MaTlmZEc4dGFXOWlhbVZqZENjcE8xeHViVzlrZFd4bExtVjRjRzl5ZEhNZ1BTQm1kVzVqZEdsdmJpaHZZbXBsWTNRc0lHVnNLWHRjYmlBZ2RtRnlJRThnSUNBZ0lDQTlJSFJ2U1U5aWFtVmpkQ2h2WW1wbFkzUXBYRzRnSUNBZ0xDQnJaWGx6SUNBZ1BTQm5aWFJMWlhsektFOHBYRzRnSUNBZ0xDQnNaVzVuZEdnZ1BTQnJaWGx6TG14bGJtZDBhRnh1SUNBZ0lDd2dhVzVrWlhnZ0lEMGdNRnh1SUNBZ0lDd2dhMlY1TzF4dUlDQjNhR2xzWlNoc1pXNW5kR2dnUGlCcGJtUmxlQ2xwWmloUFcydGxlU0E5SUd0bGVYTmJhVzVrWlhncksxMWRJRDA5UFNCbGJDbHlaWFIxY200Z2EyVjVPMXh1ZlR0Y2JseHVYRzR2THk4dkx5OHZMeTh2THk4dkx5OHZMeTljYmk4dklGZEZRbEJCUTBzZ1JrOVBWRVZTWEc0dkx5QXVMMzR2WTI5eVpTMXFjeTlzYVdKeVlYSjVMMjF2WkhWc1pYTXZYMnRsZVc5bUxtcHpYRzR2THlCdGIyUjFiR1VnYVdRZ1BTQTJNVnh1THk4Z2JXOWtkV3hsSUdOb2RXNXJjeUE5SURBaUxDSXZMeUJoYkd3Z1pXNTFiV1Z5WVdKc1pTQnZZbXBsWTNRZ2EyVjVjeXdnYVc1amJIVmtaWE1nYzNsdFltOXNjMXh1ZG1GeUlHZGxkRXRsZVhNZ1BTQnlaWEYxYVhKbEtDY3VMMTl2WW1wbFkzUXRhMlY1Y3ljcFhHNGdJQ3dnWjA5UVV5QWdJQ0E5SUhKbGNYVnBjbVVvSnk0dlgyOWlhbVZqZEMxbmIzQnpKeWxjYmlBZ0xDQndTVVVnSUNBZ0lEMGdjbVZ4ZFdseVpTZ25MaTlmYjJKcVpXTjBMWEJwWlNjcE8xeHViVzlrZFd4bExtVjRjRzl5ZEhNZ1BTQm1kVzVqZEdsdmJpaHBkQ2w3WEc0Z0lIWmhjaUJ5WlhOMWJIUWdJQ0FnSUQwZ1oyVjBTMlY1Y3locGRDbGNiaUFnSUNBc0lHZGxkRk41YldKdmJITWdQU0JuVDFCVExtWTdYRzRnSUdsbUtHZGxkRk41YldKdmJITXBlMXh1SUNBZ0lIWmhjaUJ6ZVcxaWIyeHpJRDBnWjJWMFUzbHRZbTlzY3locGRDbGNiaUFnSUNBZ0lDd2dhWE5GYm5WdElDQTlJSEJKUlM1bVhHNGdJQ0FnSUNBc0lHa2dJQ0FnSUNBZ1BTQXdYRzRnSUNBZ0lDQXNJR3RsZVR0Y2JpQWdJQ0IzYUdsc1pTaHplVzFpYjJ4ekxteGxibWQwYUNBK0lHa3BhV1lvYVhORmJuVnRMbU5oYkd3b2FYUXNJR3RsZVNBOUlITjViV0p2YkhOYmFTc3JYU2twY21WemRXeDBMbkIxYzJnb2EyVjVLVHRjYmlBZ2ZTQnlaWFIxY200Z2NtVnpkV3gwTzF4dWZUdGNibHh1WEc0dkx5OHZMeTh2THk4dkx5OHZMeTh2THk5Y2JpOHZJRmRGUWxCQlEwc2dSazlQVkVWU1hHNHZMeUF1TDM0dlkyOXlaUzFxY3k5c2FXSnlZWEo1TDIxdlpIVnNaWE12WDJWdWRXMHRhMlY1Y3k1cWMxeHVMeThnYlc5a2RXeGxJR2xrSUQwZ05qSmNiaTh2SUcxdlpIVnNaU0JqYUhWdWEzTWdQU0F3SWl3aVpYaHdiM0owY3k1bUlEMGdUMkpxWldOMExtZGxkRTkzYmxCeWIzQmxjblI1VTNsdFltOXNjenRjYmx4dVhHNHZMeTh2THk4dkx5OHZMeTh2THk4dkx5OWNiaTh2SUZkRlFsQkJRMHNnUms5UFZFVlNYRzR2THlBdUwzNHZZMjl5WlMxcWN5OXNhV0p5WVhKNUwyMXZaSFZzWlhNdlgyOWlhbVZqZEMxbmIzQnpMbXB6WEc0dkx5QnRiMlIxYkdVZ2FXUWdQU0EyTTF4dUx5OGdiVzlrZFd4bElHTm9kVzVyY3lBOUlEQWlMQ0psZUhCdmNuUnpMbVlnUFNCN2ZTNXdjbTl3WlhKMGVVbHpSVzUxYldWeVlXSnNaVHRjYmx4dVhHNHZMeTh2THk4dkx5OHZMeTh2THk4dkx5OWNiaTh2SUZkRlFsQkJRMHNnUms5UFZFVlNYRzR2THlBdUwzNHZZMjl5WlMxcWN5OXNhV0p5WVhKNUwyMXZaSFZzWlhNdlgyOWlhbVZqZEMxd2FXVXVhbk5jYmk4dklHMXZaSFZzWlNCcFpDQTlJRFkwWEc0dkx5QnRiMlIxYkdVZ1kyaDFibXR6SUQwZ01DSXNJaTh2SURjdU1pNHlJRWx6UVhKeVlYa29ZWEpuZFcxbGJuUXBYRzUyWVhJZ1kyOW1JRDBnY21WeGRXbHlaU2duTGk5ZlkyOW1KeWs3WEc1dGIyUjFiR1V1Wlhod2IzSjBjeUE5SUVGeWNtRjVMbWx6UVhKeVlYa2dmSHdnWm5WdVkzUnBiMjRnYVhOQmNuSmhlU2hoY21jcGUxeHVJQ0J5WlhSMWNtNGdZMjltS0dGeVp5a2dQVDBnSjBGeWNtRjVKenRjYm4wN1hHNWNibHh1THk4dkx5OHZMeTh2THk4dkx5OHZMeTh2WEc0dkx5QlhSVUpRUVVOTElFWlBUMVJGVWx4dUx5OGdMaTkrTDJOdmNtVXRhbk12YkdsaWNtRnllUzl0YjJSMWJHVnpMMTlwY3kxaGNuSmhlUzVxYzF4dUx5OGdiVzlrZFd4bElHbGtJRDBnTmpWY2JpOHZJRzF2WkhWc1pTQmphSFZ1YTNNZ1BTQXdJaXdpTHk4Z1ptRnNiR0poWTJzZ1ptOXlJRWxGTVRFZ1luVm5aM2tnVDJKcVpXTjBMbWRsZEU5M2JsQnliM0JsY25SNVRtRnRaWE1nZDJsMGFDQnBabkpoYldVZ1lXNWtJSGRwYm1SdmQxeHVkbUZ5SUhSdlNVOWlhbVZqZENBOUlISmxjWFZwY21Vb0p5NHZYM1J2TFdsdlltcGxZM1FuS1Z4dUlDQXNJR2RQVUU0Z0lDQWdJQ0E5SUhKbGNYVnBjbVVvSnk0dlgyOWlhbVZqZEMxbmIzQnVKeWt1Wmx4dUlDQXNJSFJ2VTNSeWFXNW5JQ0E5SUh0OUxuUnZVM1J5YVc1bk8xeHVYRzUyWVhJZ2QybHVaRzkzVG1GdFpYTWdQU0IwZVhCbGIyWWdkMmx1Wkc5M0lEMDlJQ2R2WW1wbFkzUW5JQ1ltSUhkcGJtUnZkeUFtSmlCUFltcGxZM1F1WjJWMFQzZHVVSEp2Y0dWeWRIbE9ZVzFsYzF4dUlDQS9JRTlpYW1WamRDNW5aWFJQZDI1UWNtOXdaWEowZVU1aGJXVnpLSGRwYm1SdmR5a2dPaUJiWFR0Y2JseHVkbUZ5SUdkbGRGZHBibVJ2ZDA1aGJXVnpJRDBnWm5WdVkzUnBiMjRvYVhRcGUxeHVJQ0IwY25rZ2UxeHVJQ0FnSUhKbGRIVnliaUJuVDFCT0tHbDBLVHRjYmlBZ2ZTQmpZWFJqYUNobEtYdGNiaUFnSUNCeVpYUjFjbTRnZDJsdVpHOTNUbUZ0WlhNdWMyeHBZMlVvS1R0Y2JpQWdmVnh1ZlR0Y2JseHViVzlrZFd4bExtVjRjRzl5ZEhNdVppQTlJR1oxYm1OMGFXOXVJR2RsZEU5M2JsQnliM0JsY25SNVRtRnRaWE1vYVhRcGUxeHVJQ0J5WlhSMWNtNGdkMmx1Wkc5M1RtRnRaWE1nSmlZZ2RHOVRkSEpwYm1jdVkyRnNiQ2hwZENrZ1BUMGdKMXR2WW1wbFkzUWdWMmx1Wkc5M1hTY2dQeUJuWlhSWGFXNWtiM2RPWVcxbGN5aHBkQ2tnT2lCblQxQk9LSFJ2U1U5aWFtVmpkQ2hwZENrcE8xeHVmVHRjYmx4dVhHNWNiaTh2THk4dkx5OHZMeTh2THk4dkx5OHZMMXh1THk4Z1YwVkNVRUZEU3lCR1QwOVVSVkpjYmk4dklDNHZmaTlqYjNKbExXcHpMMnhwWW5KaGNua3ZiVzlrZFd4bGN5OWZiMkpxWldOMExXZHZjRzR0WlhoMExtcHpYRzR2THlCdGIyUjFiR1VnYVdRZ1BTQTJObHh1THk4Z2JXOWtkV3hsSUdOb2RXNXJjeUE5SURBaUxDSXZMeUF4T1M0eExqSXVOeUF2SURFMUxqSXVNeTQwSUU5aWFtVmpkQzVuWlhSUGQyNVFjbTl3WlhKMGVVNWhiV1Z6S0U4cFhISmNiblpoY2lBa2EyVjVjeUFnSUNBZ0lEMGdjbVZ4ZFdseVpTZ25MaTlmYjJKcVpXTjBMV3RsZVhNdGFXNTBaWEp1WVd3bktWeHlYRzRnSUN3Z2FHbGtaR1Z1UzJWNWN5QTlJSEpsY1hWcGNtVW9KeTR2WDJWdWRXMHRZblZuTFd0bGVYTW5LUzVqYjI1allYUW9KMnhsYm1kMGFDY3NJQ2R3Y205MGIzUjVjR1VuS1R0Y2NseHVYSEpjYm1WNGNHOXlkSE11WmlBOUlFOWlhbVZqZEM1blpYUlBkMjVRY205d1pYSjBlVTVoYldWeklIeDhJR1oxYm1OMGFXOXVJR2RsZEU5M2JsQnliM0JsY25SNVRtRnRaWE1vVHlsN1hISmNiaUFnY21WMGRYSnVJQ1JyWlhsektFOHNJR2hwWkdSbGJrdGxlWE1wTzF4eVhHNTlPMXh1WEc1Y2JpOHZMeTh2THk4dkx5OHZMeTh2THk4dkwxeHVMeThnVjBWQ1VFRkRTeUJHVDA5VVJWSmNiaTh2SUM0dmZpOWpiM0psTFdwekwyeHBZbkpoY25rdmJXOWtkV3hsY3k5ZmIySnFaV04wTFdkdmNHNHVhbk5jYmk4dklHMXZaSFZzWlNCcFpDQTlJRFkzWEc0dkx5QnRiMlIxYkdVZ1kyaDFibXR6SUQwZ01DSXNJblpoY2lCd1NVVWdJQ0FnSUNBZ0lDQWdJQ0E5SUhKbGNYVnBjbVVvSnk0dlgyOWlhbVZqZEMxd2FXVW5LVnh5WEc0Z0lDd2dZM0psWVhSbFJHVnpZeUFnSUNBZ1BTQnlaWEYxYVhKbEtDY3VMMTl3Y205d1pYSjBlUzFrWlhOakp5bGNjbHh1SUNBc0lIUnZTVTlpYW1WamRDQWdJQ0FnSUQwZ2NtVnhkV2x5WlNnbkxpOWZkRzh0YVc5aWFtVmpkQ2NwWEhKY2JpQWdMQ0IwYjFCeWFXMXBkR2wyWlNBZ0lDQTlJSEpsY1hWcGNtVW9KeTR2WDNSdkxYQnlhVzFwZEdsMlpTY3BYSEpjYmlBZ0xDQm9ZWE1nSUNBZ0lDQWdJQ0FnSUNBOUlISmxjWFZwY21Vb0p5NHZYMmhoY3ljcFhISmNiaUFnTENCSlJUaGZSRTlOWDBSRlJrbE9SU0E5SUhKbGNYVnBjbVVvSnk0dlgybGxPQzFrYjIwdFpHVm1hVzVsSnlsY2NseHVJQ0FzSUdkUFVFUWdJQ0FnSUNBZ0lDQWdJRDBnVDJKcVpXTjBMbWRsZEU5M2JsQnliM0JsY25SNVJHVnpZM0pwY0hSdmNqdGNjbHh1WEhKY2JtVjRjRzl5ZEhNdVppQTlJSEpsY1hWcGNtVW9KeTR2WDJSbGMyTnlhWEIwYjNKekp5a2dQeUJuVDFCRUlEb2dablZ1WTNScGIyNGdaMlYwVDNkdVVISnZjR1Z5ZEhsRVpYTmpjbWx3ZEc5eUtFOHNJRkFwZTF4eVhHNGdJRThnUFNCMGIwbFBZbXBsWTNRb1R5azdYSEpjYmlBZ1VDQTlJSFJ2VUhKcGJXbDBhWFpsS0ZBc0lIUnlkV1VwTzF4eVhHNGdJR2xtS0VsRk9GOUVUMDFmUkVWR1NVNUZLWFJ5ZVNCN1hISmNiaUFnSUNCeVpYUjFjbTRnWjA5UVJDaFBMQ0JRS1R0Y2NseHVJQ0I5SUdOaGRHTm9LR1VwZXlBdktpQmxiWEIwZVNBcUx5QjlYSEpjYmlBZ2FXWW9hR0Z6S0U4c0lGQXBLWEpsZEhWeWJpQmpjbVZoZEdWRVpYTmpLQ0Z3U1VVdVppNWpZV3hzS0U4c0lGQXBMQ0JQVzFCZEtUdGNjbHh1ZlR0Y2JseHVYRzR2THk4dkx5OHZMeTh2THk4dkx5OHZMeTljYmk4dklGZEZRbEJCUTBzZ1JrOVBWRVZTWEc0dkx5QXVMMzR2WTI5eVpTMXFjeTlzYVdKeVlYSjVMMjF2WkhWc1pYTXZYMjlpYW1WamRDMW5iM0JrTG1welhHNHZMeUJ0YjJSMWJHVWdhV1FnUFNBMk9GeHVMeThnYlc5a2RXeGxJR05vZFc1cmN5QTlJREFpTENKeVpYRjFhWEpsS0NjdUwxOTNhM010WkdWbWFXNWxKeWtvSjJGemVXNWpTWFJsY21GMGIzSW5LVHRjYmx4dVhHNHZMeTh2THk4dkx5OHZMeTh2THk4dkx5OWNiaTh2SUZkRlFsQkJRMHNnUms5UFZFVlNYRzR2THlBdUwzNHZZMjl5WlMxcWN5OXNhV0p5WVhKNUwyMXZaSFZzWlhNdlpYTTNMbk41YldKdmJDNWhjM2x1WXkxcGRHVnlZWFJ2Y2k1cWMxeHVMeThnYlc5a2RXeGxJR2xrSUQwZ056QmNiaTh2SUcxdlpIVnNaU0JqYUhWdWEzTWdQU0F3SWl3aWNtVnhkV2x5WlNnbkxpOWZkMnR6TFdSbFptbHVaU2NwS0NkdlluTmxjblpoWW14bEp5azdYRzVjYmx4dUx5OHZMeTh2THk4dkx5OHZMeTh2THk4dlhHNHZMeUJYUlVKUVFVTkxJRVpQVDFSRlVseHVMeThnTGk5K0wyTnZjbVV0YW5NdmJHbGljbUZ5ZVM5dGIyUjFiR1Z6TDJWek55NXplVzFpYjJ3dWIySnpaWEoyWVdKc1pTNXFjMXh1THk4Z2JXOWtkV3hsSUdsa0lEMGdOekZjYmk4dklHMXZaSFZzWlNCamFIVnVhM01nUFNBd0lsMHNJbk52ZFhKalpWSnZiM1FpT2lJaWZRPT1cIiwgX193ZWJwYWNrX3B1YmxpY19wYXRoX18gKyBcImhpZ2hsaWdodEpzb24ud29ya2VyLmpzXCIpO1xufTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zY3JpcHRzL2FwaS1leHBsb3Jlci92Mi9zcmMvc2VydmljZXMvanNvbi1oaWdobGlnaHQvaGlnaGxpZ2h0SnNvbi53b3JrZXIuanMiLCIvLyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzEwMzQzOTEzL2hvdy10by1jcmVhdGUtYS13ZWItd29ya2VyLWZyb20tYS1zdHJpbmdcclxuXHJcbnZhciBVUkwgPSB3aW5kb3cuVVJMIHx8IHdpbmRvdy53ZWJraXRVUkw7XHJcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oY29udGVudCwgdXJsKSB7XHJcblx0dHJ5IHtcclxuXHRcdHRyeSB7XHJcblx0XHRcdHZhciBibG9iO1xyXG5cdFx0XHR0cnkgeyAvLyBCbG9iQnVpbGRlciA9IERlcHJlY2F0ZWQsIGJ1dCB3aWRlbHkgaW1wbGVtZW50ZWRcclxuXHRcdFx0XHR2YXIgQmxvYkJ1aWxkZXIgPSB3aW5kb3cuQmxvYkJ1aWxkZXIgfHwgd2luZG93LldlYktpdEJsb2JCdWlsZGVyIHx8IHdpbmRvdy5Nb3pCbG9iQnVpbGRlciB8fCB3aW5kb3cuTVNCbG9iQnVpbGRlcjtcclxuXHRcdFx0XHRibG9iID0gbmV3IEJsb2JCdWlsZGVyKCk7XHJcblx0XHRcdFx0YmxvYi5hcHBlbmQoY29udGVudCk7XHJcblx0XHRcdFx0YmxvYiA9IGJsb2IuZ2V0QmxvYigpO1xyXG5cdFx0XHR9IGNhdGNoKGUpIHsgLy8gVGhlIHByb3Bvc2VkIEFQSVxyXG5cdFx0XHRcdGJsb2IgPSBuZXcgQmxvYihbY29udGVudF0pO1xyXG5cdFx0XHR9XHJcblx0XHRcdHJldHVybiBuZXcgV29ya2VyKFVSTC5jcmVhdGVPYmplY3RVUkwoYmxvYikpO1xyXG5cdFx0fSBjYXRjaChlKSB7XHJcblx0XHRcdHJldHVybiBuZXcgV29ya2VyKCdkYXRhOmFwcGxpY2F0aW9uL2phdmFzY3JpcHQsJyArIGVuY29kZVVSSUNvbXBvbmVudChjb250ZW50KSk7XHJcblx0XHR9XHJcblx0fSBjYXRjaChlKSB7XHJcblx0XHRyZXR1cm4gbmV3IFdvcmtlcih1cmwpO1xyXG5cdH1cclxufVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi93b3JrZXItbG9hZGVyL2NyZWF0ZUlubGluZVdvcmtlci5qc1xuLy8gbW9kdWxlIGlkID0gMTUyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxyXG4gKiBDb2xvcnMgc2VydmljZSAoc2luZ2xldG9uKVxyXG4gKi9cclxuXHJcbnZhciBudW0gPSBTeW1ib2woJ05VTScpO1xyXG52YXIgcHJlZml4ID0gU3ltYm9sKCdQUkVGSVgnKTtcclxubGV0IGluc3RhbmNlID0gbnVsbDtcclxuXHJcbmNsYXNzIENvbG9yc1NlcnZpY2Uge1xyXG5cdGNvbnN0cnVjdG9yKE5VTSA9IDEyLCBQUkVGSVggPSAnY29sb3ItJykge1xyXG5cdFx0aWYgKCFpbnN0YW5jZSkge1xyXG5cdFx0XHRpbnN0YW5jZSA9IHRoaXM7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpc1tudW1dID0gTlVNO1xyXG5cdFx0dGhpc1twcmVmaXhdID0gUFJFRklYO1xyXG5cdFx0dGhpcy5jb2xvcnMgPSB0aGlzLmdldENvbG9ycygpO1xyXG5cclxuXHRcdHJldHVybiBpbnN0YW5jZTtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIEdldHMgcmFuZG9tIGNvbG9yIGNzcyBjbGFzc1xyXG5cdCAqIEBwYXJhbSBjb2xvciB7c3RyaW5nfSBleGlzdGluZyBjc3MgY2xhc3MgdG8gcHJldmVudCBtYWNoXHJcblx0ICogQHJldHVybnMge3N0cmluZ30gY3NzIGNsYXNzIG5hbWVcclxuXHQgKi9cclxuXHRnZXRSYW5kb21Db2xvcihjb2xvcikge1xyXG5cdFx0bGV0IHJhbmRvbU51bWJlcjtcclxuXHRcdGxldCBQUkVGSVggPSB0aGlzW3ByZWZpeF07XHJcblx0XHRkbyB7XHJcblx0XHRcdHJhbmRvbU51bWJlciA9IHRoaXMuY29uc3RydWN0b3IuZ2V0UmFuZG9tSW50KDEsIHRoaXMuY29sb3JzLmxlbmd0aCk7XHJcblx0XHR9IHdoaWxlIChQUkVGSVggKyByYW5kb21OdW1iZXIgPT09IGNvbG9yKTtcclxuXHJcblx0XHRyZXR1cm4gUFJFRklYICsgcmFuZG9tTnVtYmVyO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogQnVpbGRzIGFycmF5IG9mIGNvbG9ycyBjc3MgY2xhc3Nlc1xyXG5cdCAqIEByZXR1cm5zIHtBcnJheX0gYXJyYXkgb2Ygc3RyaW5nc1xyXG5cdCAqL1xyXG5cdGdldENvbG9ycygpIHtcclxuXHRcdGxldCBjb2xvcnMgPSBuZXcgQXJyYXkodGhpc1tudW1dKTtcclxuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgY29sb3JzLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdGNvbG9yc1tpXSA9IHRoaXNbcHJlZml4XSArIChpICsgMSk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gY29sb3JzO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogUmV0dXJucyBhIHJhbmRvbSBpbnRlZ2VyIGJldHdlZW4gbWluIChpbmNsdXNpdmUpIGFuZCBtYXggKGluY2x1c2l2ZSlcclxuXHQgKiBVc2luZyBNYXRoLnJvdW5kKCkgd2lsbCBnaXZlIHlvdSBhIG5vbi11bmlmb3JtIGRpc3RyaWJ1dGlvbiFcclxuXHQgKi9cclxuXHRzdGF0aWMgZ2V0UmFuZG9tSW50KG1pbiwgbWF4KSB7XHJcblx0XHRyZXR1cm4gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogKG1heCAtIG1pbiArIDEpKSArIG1pbjtcclxuXHR9XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gbmV3IENvbG9yc1NlcnZpY2UoKTtcclxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc2NyaXB0cy9hcGktZXhwbG9yZXIvdjIvc3JjL3NlcnZpY2VzL2NvbG9ycy5zZXJ2aWNlLmpzIiwiaW1wb3J0IGJhc2UgZnJvbSAnLi9iYXNlLnNlcnZpY2UnO1xyXG5pbXBvcnQgYXBpa2V5IGZyb20gJy4vYXBpS2V5LnNlcnZpY2UnO1xyXG5cclxuLyoqXHJcbiAqIFJlc3Qgc2VydmljZVxyXG4gKiBHZXRzIGRhdGEgZnJvbSBzZXJ2ZXJcclxuICovXHJcbmxldCBpbnN0YW5jZTtcclxuXHJcbmNsYXNzIFJlc3RTZXJ2aWNlIHtcclxuXHRjb25zdHJ1Y3RvcigpIHtcclxuXHRcdGlmICghaW5zdGFuY2UpIHtcclxuXHRcdFx0aW5zdGFuY2UgPSB0aGlzO1xyXG5cdFx0fVxyXG5cdFx0dGhpcy5iYXNlID0gYmFzZTtcclxuXHRcdHRoaXMuYXBpS2V5ID0gYXBpa2V5O1xyXG5cdFx0dGhpcy5zZWxlY3RlZENhdGVnb3J5ID0ga28ub2JzZXJ2YWJsZSgnJykuc3Vic2NyaWJlVG8oJ1NFTEVDVEVEX0NBVEVHT1JZJyk7XHJcblx0XHR0aGlzLnNlbGVjdGVkTWV0aG9kVHlwZSA9IGtvLm9ic2VydmFibGUoJycpLnN1YnNjcmliZVRvKCdTRUxFQ1RFRF9NRVRIT0RfVFlQRScpO1xyXG5cdFx0dGhpcy5zZWxlY3RlZE1ldGhvZCA9IGtvLm9ic2VydmFibGUoJycpLnN1YnNjcmliZVRvKCdTRUxFQ1RFRF9NRVRIT0QnKTtcclxuXHRcdHRoaXMuc2VsZWN0ZWRQYXJhbXMgPSBrby5vYnNlcnZhYmxlQXJyYXkoW10pLnN1YnNjcmliZVRvKCdTRUxFQ1RFRF9QQVJBTVMnKTtcclxuXHRcdHRoaXMucmVxdWVzdHMgPSBrby5vYnNlcnZhYmxlQXJyYXkoW10pLnN5bmNXaXRoKCdSRVFVRVNUU19BUlInKTtcclxuXHRcdHRoaXMuYW5vdGhlclJlc3BvbnNlID0ga28ub2JzZXJ2YWJsZSgpLnB1Ymxpc2hPbignQU5PVEhFUl9SRVNQT05TRScpO1xyXG5cdFx0dGhpcy5pbml0KCk7XHJcblx0XHRyZXR1cm4gaW5zdGFuY2U7XHJcblx0fVxyXG5cclxuXHRpbml0KCkge1xyXG5cdFx0a28ucG9zdGJveC5zdWJzY3JpYmUoJ1NFTEVDVEVEX01FVEhPRCcsIG5ld1ZhbHVlID0+IHtcclxuXHRcdFx0dGhpcy5zZWxlY3RlZE1ldGhvZERhdGEgPSB0aGlzLmdldE1ldGhvZERhdGEoKVxyXG5cdFx0fSk7XHJcblxyXG5cdFx0a28ucG9zdGJveC5zdWJzY3JpYmUoJ0FOT1RIRVJfUkVRVUVTVCcsICh7bWV0aG9kLCBwYW5lbEdyb3VwLCBjb2xvcn0pID0+IHtcclxuXHRcdFx0dGhpcy5hbm90aGVyUmVxdWVzdCA9IHRydWU7XHJcblx0XHRcdGxldCB1cmwgPSB0aGlzLnByZXBhcmVVcmwobWV0aG9kLmJhc2UsIG1ldGhvZC5wYXRoLCBtZXRob2QucGFyYW1ldGVycyk7XHJcblxyXG5cdFx0XHR0aGlzLmFqYXhTZXJ2aWNlKHt1cmwsIHR5cGU6IG1ldGhvZC5tZXRob2QsIGNhbGxiYWNrOiAocmVzLCBtc2cpID0+IHtcclxuXHRcdFx0XHRsZXQgY2F0ZWdvcnkgPSBtZXRob2QuY2F0ZWdvcnk7XHJcblx0XHRcdFx0bGV0IHR5cGUgPSBtZXRob2QubWV0aG9kO1xyXG5cdFx0XHRcdGxldCBtZXRob2RJZCA9IG1ldGhvZC5pZDtcclxuXHRcdFx0XHRsZXQgcGFyYW1zID0gbWV0aG9kLnBhcmFtZXRlcnM7XHJcblxyXG5cdFx0XHRcdGxldCByZXNPYmogPSB7XHJcblx0XHRcdFx0XHRjYXRlZ29yeSxcclxuXHRcdFx0XHRcdG1ldGhvZDogdHlwZSxcclxuXHRcdFx0XHRcdG1ldGhvZElkLFxyXG5cdFx0XHRcdFx0cGFyYW1zOiBwYXJhbXMubWFwKG9iaiA9PiAkLmV4dGVuZCh0cnVlLCB7fSwge1xyXG5cdFx0XHRcdFx0XHRuYW1lOiBvYmoubmFtZSxcclxuXHRcdFx0XHRcdFx0dmFsdWU6IGtvLm9ic2VydmFibGUoa28udW53cmFwKG9iai52YWx1ZSkpLFxyXG5cdFx0XHRcdFx0XHRvcHRpb25zOiBvYmoub3B0aW9uc1xyXG5cdFx0XHRcdFx0fSkpLFxyXG5cdFx0XHRcdFx0cmVxOiB0aGlzLnJlcSxcclxuXHRcdFx0XHRcdGluZGV4OiB0aGlzLnJlcXVlc3RzKCkubGVuZ3RoXHJcblx0XHRcdFx0fTtcclxuXHJcblx0XHRcdFx0aWYgKG1zZyA9PSAnZXJyb3InKSB7XHJcblx0XHRcdFx0XHQvLyBub3RpZnlpbmcgZXJyb3IgbW9kYWxcclxuXHRcdFx0XHRcdHRoaXMuZXJyb3IgPSBrby5vYnNlcnZhYmxlKHJlcykucHVibGlzaE9uKCdSRVFVRVNUX0VSUk9SJyk7XHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdHRoaXMuZXJyb3IgJiYgZGVsZXRlIHRoaXMuZXJyb3I7XHJcblx0XHRcdFx0XHRyZXNPYmoucmVzcG9uc2UgPSByZXMucmVzcG9uc2VKU09OO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0Ly8gZXhwb3J0aW5nIGRhdGEgdXNpbmcgb2JzZXJ2YWJsZVxyXG5cdFx0XHRcdHRoaXMuYW5vdGhlclJlc3BvbnNlKHtkYXRhOiByZXNPYmosIHBhbmVsR3JvdXAsIGNvbG9yfSlcclxuXHRcdFx0fX0pO1xyXG5cdFx0fSk7XHJcblx0fVxyXG5cclxuXHRzZW5kUmVxdWVzdCgpIHtcclxuXHRcdGxldCB0eXBlID0ga28udW53cmFwKHRoaXMuc2VsZWN0ZWRNZXRob2RUeXBlKTtcclxuXHRcdHRoaXMucmVxID0gdGhpcy5wcmVwYXJlVXJsKCk7XHJcblx0XHR0aGlzLmFqYXhTZXJ2aWNlKHt1cmw6IHRoaXMucmVxLCB0eXBlLCBjYWxsYmFjazogdGhpcy5jYWxsYmFja30pO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogRmlsdGVycyBhbmQgcHJlcGFyZXMgcGFyYW1zIHBhaXJzXHJcblx0ICogQHJldHVybnMge2Jvb2xlYW59XHJcblx0ICovXHJcblx0cHJlcGFyZVVybChfZG9tYWluLCBfcGF0aCwgX3NlbGVjdGVkUGFyYW1zKSB7XHJcblx0XHRsZXQgcmVwbGFjZW1lbnQsXHJcblx0XHRcdHVybCxcclxuXHRcdFx0cGFyYW1zLFxyXG5cdFx0XHRzZWxlY3RlZFBhcmFtcyA9IGtvLnVud3JhcChfc2VsZWN0ZWRQYXJhbXMgfHwgdGhpcy5zZWxlY3RlZFBhcmFtcyk7XHJcblxyXG5cdFx0bGV0IGRvbWFpbiA9IF9kb21haW4gfHwgdGhpcy5zZWxlY3RlZE1ldGhvZERhdGEuYmFzZTtcclxuXHRcdGxldCBwYXRoID0gX3BhdGggfHwgdGhpcy5zZWxlY3RlZE1ldGhvZERhdGEucGF0aDtcclxuXHJcblx0XHRwYXJhbXMgPSBzZWxlY3RlZFBhcmFtcy5maWx0ZXIoaXRlbSA9PiBpdGVtLnN0eWxlID09PSAncXVlcnknKTtcclxuXHJcblx0XHQvLyBhcnIgb2YgdGVtcGxhdGUgbWFya3NcclxuXHRcdHJlcGxhY2VtZW50ID0gcGF0aC5tYXRjaCgvKFtee10qPylcXHcoPz1cXH0pL2dtaSk7XHJcblxyXG5cdFx0Ly8gYXJyIG9mIHRlbXBsYXRlIHBhcmFtc1xyXG5cdFx0dmFyIHRlbXBsYXRlc0FyciA9IHNlbGVjdGVkUGFyYW1zLmZpbHRlcihpdGVtID0+IGl0ZW0uc3R5bGUgPT09ICd0ZW1wbGF0ZScpO1xyXG5cclxuXHRcdC8vIHJlcGxhY2VtZW50XHJcblx0XHRyZXBsYWNlbWVudC5mb3JFYWNoKHZhbCA9PiB7XHJcblx0XHRcdHZhciBwYXJhbSA9IHRlbXBsYXRlc0Fyci5maW5kKGl0ZW0gPT4gaXRlbS5uYW1lID09PSB2YWwpO1xyXG5cdFx0XHRwYXRoID0gcGF0aC5yZXBsYWNlKCd7JysgcGFyYW0ubmFtZSArICd9Jywga28udW53cmFwKHBhcmFtLnZhbHVlKSB8fCBwYXJhbS5kZWZhdWx0KTtcclxuXHRcdH0pO1xyXG5cclxuXHRcdC8vIGFkZHMgYXBpS2V5IHBhcmFtXHJcblx0XHRpZiAoIXBhcmFtc1swXSB8fCBwYXJhbXNbMF0ubmFtZSAhPT0gJ2FwaWtleScpIHtcclxuXHRcdFx0cGFyYW1zLnVuc2hpZnQodGhpcy5hcGlLZXkpO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIHByZXBhcmVzIHBhcmFtcyBwYXJ0IG9mIHVybFxyXG5cdFx0cGFyYW1zID0gcGFyYW1zLm1hcChpdGVtID0+IFtpdGVtLm5hbWUsIGtvLnVud3JhcChpdGVtLnZhbHVlKSB8fCBpdGVtLmRlZmF1bHRdLmpvaW4oJz0nKSkuam9pbignJicpO1xyXG5cclxuXHRcdHVybCA9IFtkb21haW4sICcvJywgcGF0aCwgJz8nLCBwYXJhbXNdLmpvaW4oJycpO1xyXG5cclxuXHRcdHJldHVybiBlbmNvZGVVUkkodXJsKTtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIEFqYXggU2VydmljZVxyXG5cdCAqL1xyXG5cdGFqYXhTZXJ2aWNlKHt1cmwsIHR5cGUgPSAnR0VUJywgYXN5bmMgPSB0cnVlLCBkYXRhVHlwZSA9ICdqc29uJywgY2FsbGJhY2t9KSB7XHJcblx0XHQkLmFqYXgoe1xyXG5cdFx0XHR0eXBlOiB0eXBlID09PSAnQUxMJyA/ICdHRVQnIDogdHlwZSxcclxuXHRcdFx0dXJsLFxyXG5cdFx0XHRhc3luYyxcclxuXHRcdFx0ZGF0YVR5cGUsXHJcblx0XHRcdGNvbXBsZXRlOiBjYWxsYmFja1xyXG5cdFx0fSk7XHJcblx0fVxyXG5cclxuXHRnZXRNZXRob2REYXRhKHBhcmFtcyA9IHt9KSB7XHJcblx0XHRsZXQgY2F0ZWdvcnkgPSBrby51bndyYXAocGFyYW1zLmFwaUNhdGVnb3J5IHx8IHRoaXMuc2VsZWN0ZWRDYXRlZ29yeSk7XHJcblx0XHRsZXQgbWV0aG9kVHlwZSA9IGtvLnVud3JhcChwYXJhbXMudHlwZSB8fCB0aGlzLnNlbGVjdGVkTWV0aG9kVHlwZSB8fCAnQUxMJyk7XHJcblx0XHRsZXQgbWV0aG9kID0ga28udW53cmFwKHBhcmFtcy5tZXRob2RJZCB8fCB0aGlzLnNlbGVjdGVkTWV0aG9kKTtcclxuXHRcdHJldHVybiB0aGlzLmJhc2VbY2F0ZWdvcnldICYmIHRoaXMuYmFzZVtjYXRlZ29yeV1bbWV0aG9kVHlwZV0gJiYgdGhpcy5iYXNlW2NhdGVnb3J5XVttZXRob2RUeXBlXVttZXRob2RdIHx8IHt9O1xyXG5cdH1cclxuXHJcblx0Y2FsbGJhY2sgPSAocmVzLCBtc2cpID0+IHtcclxuXHRcdGxldCBjYXRlZ29yeSA9IGtvLnVud3JhcCh0aGlzLnNlbGVjdGVkQ2F0ZWdvcnkpO1xyXG5cdFx0bGV0IHR5cGUgPSBrby51bndyYXAodGhpcy5zZWxlY3RlZE1ldGhvZFR5cGUpO1xyXG5cdFx0bGV0IG1ldGhvZElkID0ga28udW53cmFwKHRoaXMuc2VsZWN0ZWRNZXRob2QpO1xyXG5cdFx0bGV0IHBhcmFtcyA9IGtvLnVud3JhcCh0aGlzLnNlbGVjdGVkUGFyYW1zKTtcclxuXHJcblx0XHR2YXIgcmVzT2JqID0ge1xyXG5cdFx0XHRjYXRlZ29yeSxcclxuXHRcdFx0bWV0aG9kOiB0eXBlLFxyXG5cdFx0XHRtZXRob2RJZCxcclxuXHRcdFx0cGFyYW1zOiBwYXJhbXMubWFwKG9iaiA9PiAkLmV4dGVuZCh0cnVlLCB7fSwge1xyXG5cdFx0XHRcdG5hbWU6IG9iai5uYW1lLFxyXG5cdFx0XHRcdHZhbHVlOiBrby5vYnNlcnZhYmxlKGtvLnVud3JhcChvYmoudmFsdWUpKSxcclxuXHRcdFx0XHRvcHRpb25zOiBvYmoub3B0aW9uc1xyXG5cdFx0XHR9KSksXHJcblx0XHRcdHJlcTogdGhpcy5yZXEsXHJcblx0XHRcdGluZGV4OiB0aGlzLnJlcXVlc3RzKCkubGVuZ3RoXHJcblx0XHR9O1xyXG5cclxuXHRcdGlmIChtc2cgPT0gJ2Vycm9yJykge1xyXG5cdFx0XHQvLyBub3RpZnlpbmcgZXJyb3IgbW9kYWxcclxuXHRcdFx0dGhpcy5lcnJvciA9IGtvLm9ic2VydmFibGUocmVzKS5wdWJsaXNoT24oJ1JFUVVFU1RfRVJST1InKTtcclxuXHRcdFx0Ly8gZXJyb3IgcG9wb3ZlciBvZiByZXF1ZXN0XHJcblx0XHRcdHJlc09iai5lcnJvciA9IHJlcztcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHRoaXMuZXJyb3IgJiYgZGVsZXRlIHRoaXMuZXJyb3I7XHJcblx0XHRcdGdsb2JhbC5sYXN0UmVzcG9uc2UgPSByZXNPYmoucmVzcG9uc2UgPSByZXMucmVzcG9uc2VKU09OO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIGV4cG9ydGluZyBkYXRhIHVzaW5nIG9ic2VydmFibGVcclxuXHRcdHRoaXMucmVxdWVzdHMudW5zaGlmdChyZXNPYmopO1xyXG5cdH07XHJcblxyXG5cdHBhcnNlVXJsID0gKHVybCkgPT4ge1xyXG5cdFx0bGV0IGxvY2F0aW9uID0gdXJsID8gJz8nICsgdXJsLnNwbGl0KCc/JylbMV06IHdpbmRvdy5sb2NhdGlvbi5zZWFyY2g7XHJcblxyXG5cdFx0aWYgKGxvY2F0aW9uKSB7XHJcblx0XHRcdHZhciBxdWVyeXMgPSBsb2NhdGlvbi5yZXBsYWNlKC9eXFw/L2csICcnKS5zcGxpdCgnJicpO1xyXG5cdFx0XHR2YXIgb2JqID0ge1xyXG5cdFx0XHRcdGFwaUNhdGVnb3J5OiAnJyxcclxuXHRcdFx0XHRtZXRob2RJZDogJycsXHJcblx0XHRcdFx0cGFyYW1ldGVyczogW11cclxuXHRcdFx0fTtcclxuXHJcblx0XHRcdGxldCBnbG9iYWxRdWVyeU9iaiA9IHdpbmRvdy5sb2NhdGlvbi5xdWVyeSA9IHt9O1xyXG5cdFx0XHRxdWVyeXMubWFwKHF1ZXJ5ID0+IHtcclxuXHRcdFx0XHRsZXQgW2tleSwgdmFsXSA9IGRlY29kZVVSSShxdWVyeSkuc3BsaXQoJz0nKTtcclxuXHJcblx0XHRcdFx0aWYgKE9iamVjdC5rZXlzKG9iaikuaW5kZXhPZihrZXkpICE9PSAtMSkge1xyXG5cdFx0XHRcdFx0dHJ5IHtcclxuXHRcdFx0XHRcdFx0b2JqW2tleV0gPSBnbG9iYWxRdWVyeU9ialtrZXldID0gSlNPTi5wYXJzZSh2YWwpO1xyXG5cdFx0XHRcdFx0fSBjYXRjaCAoZXhjZXB0aW9uX3Zhcikge1xyXG5cdFx0XHRcdFx0XHRvYmpba2V5XSA9IGdsb2JhbFF1ZXJ5T2JqW2tleV0gPSB2YWw7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdHRyeSB7XHJcblx0XHRcdFx0XHRcdGdsb2JhbFF1ZXJ5T2JqW2tleV0gPSBKU09OLnBhcnNlKHZhbCk7XHJcblx0XHRcdFx0XHR9IGNhdGNoIChleGNlcHRpb25fdmFyKSB7XHJcblx0XHRcdFx0XHRcdGdsb2JhbFF1ZXJ5T2JqW2tleV0gPSB2YWw7XHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0b2JqLnBhcmFtZXRlcnMucHVzaCh7XHJcblx0XHRcdFx0XHRcdG5hbWU6IGtleSxcclxuXHRcdFx0XHRcdFx0dmFsdWU6IGdsb2JhbFF1ZXJ5T2JqW2tleV1cclxuXHRcdFx0XHRcdH0pXHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9KTtcclxuXHJcblx0XHRcdGxldCBtZXRob2REYXRhID0gdGhpcy5nZXRNZXRob2REYXRhKG9iaik7XHJcblx0XHRcdGxldCBwYXJhbWV0ZXJzID0gbWV0aG9kRGF0YS5wYXJhbWV0ZXJzO1xyXG5cclxuXHRcdFx0b2JqLnBhcmFtZXRlcnMgPSBvYmoucGFyYW1ldGVycy5tYXAob2JqID0+IHtcclxuXHRcdFx0XHRyZXR1cm4gJC5leHRlbmQodHJ1ZSwge30sIHBhcmFtZXRlcnNbb2JqLm5hbWVdLCBvYmopO1xyXG5cdFx0XHR9KTtcclxuXHRcdFx0cmV0dXJuIG9iajtcclxuXHRcdH1cclxuXHRcdHJldHVybiB7fTtcclxuXHR9O1xyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IG5ldyBSZXN0U2VydmljZSgpO1xyXG5cclxuXHJcblxyXG5cclxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc2NyaXB0cy9hcGktZXhwbG9yZXIvdjIvc3JjL3NlcnZpY2VzL3Jlc3Quc2VydmljZS5qcyIsInZhciBzZWxmO1xuXG5jbGFzcyBPYmplY3RQYW5lbEJvZHkge1xuXHRjb25zdHJ1Y3Rvcih7ZGF0YSA9IHt9LCBjb25maWcsIGluZGV4ID0gdGhpcy5jYXJkSW5kZXgsIHBhbmVsR3JvdXAgPSB7fSwgcGFnZSwgY29sbGFwc2VJZCwgc3ViamVjdElEfSkge1xuXHRcdHNlbGYgPSB0aGlzO1xuXHRcdHRoaXMuZGF0YSA9IHRoaXMuZGF0YSB8fCBrby5vYnNlcnZhYmxlKGRhdGEudmFsdWUpO1xuXHRcdHRoaXMuY29uZmlnID0gY29uZmlnO1xuXHRcdHRoaXMuX3BhbmVsTmFtZSA9IGRhdGEua2V5O1xuXHRcdHRoaXMuY2FyZEluZGV4ID0ga28udW53cmFwKGluZGV4KTtcblx0XHR0aGlzLnBhbmVsR3JvdXAgPSBwYW5lbEdyb3VwO1xuXHRcdHRoaXMuZ2V0TW9yZSA9IHBhbmVsR3JvdXAuZ2V0TW9yZTtcblx0XHR0aGlzLnBhZ2UgPSBwYWdlO1xuXHRcdHRoaXMuY29sbGFwc2VJZCA9IGNvbGxhcHNlSWQ7XG5cdFx0dGhpcy5fYWxsSW5zaWRlID0gISFPYmplY3QuZ2V0UHJvcChrby51bndyYXAoY29uZmlnKSwgJy5fQ09ORklHLmFsbEluc2lkZScpO1xuXHRcdHRoaXMuc29ydEJ5Q29uZmlnID0gcGFuZWxHcm91cC5zb3J0QnlDb25maWc7XG5cdFx0dGhpcy5zdWJqZWN0SUQgPSBzdWJqZWN0SUQ7XG5cdFx0dGhpcy5zZW5kSWQodGhpcy5kYXRhKTtcblx0fVxuXHRzZW5kSWQoZGF0YSkge1xuXHRcdGxldCBpZCA9IGtvLnVud3JhcChkYXRhKS5pZDtcblx0XHRpZihpZCkge1xuXHRcdFx0dGhpcy5zdWJqZWN0SUQoaWQpXG5cdFx0fVxuXHR9XG5cdG9uRW50ZXJLZXlEb3duID0gKG1vZGVsLCBldmVudCkgPT4ge1xuXHRcdGlmIChldmVudC5rZXlDb2RlID09PSAxMykge1xuXHRcdFx0bGV0IHBhZ2UgPSB0aGlzLnBhZ2U7XG5cdFx0XHR2YXIgdmFsdWUgPSArZXZlbnQuY3VycmVudFRhcmdldC52YWx1ZTtcblx0XHRcdHZhbHVlID0gTnVtYmVyLmlzTmFOKHZhbHVlKSA/IDAgOiB2YWx1ZTtcblx0XHRcdHZhciBwYWdlTnVtYmVyID0gfn52YWx1ZSA8IDAgPyAwIDogfn52YWx1ZTtcblx0XHRcdHBhZ2UucGFnZVBhcmFtKHBhZ2VOdW1iZXIgPCBrby51bndyYXAodGhpcy5kYXRhKS50b3RhbFBhZ2VzID8gcGFnZU51bWJlciA6IGtvLnVud3JhcCh0aGlzLmRhdGEpLnRvdGFsUGFnZXMgLSAxKTtcblx0XHRcdHBhZ2Uuc2V0UGFyYW1zKHtcblx0XHRcdFx0Y2F0ZWdvcnk6IHBhZ2UuY2F0ZWdvcnksXG5cdFx0XHRcdG1ldGhvZDogcGFnZS5tZXRob2QsXG5cdFx0XHRcdG1ldGhvZElkOiBwYWdlLm1ldGhvZElkLFxuXHRcdFx0XHRwYXJhbXM6IHBhZ2UucGFyYW1zXG5cdFx0XHR9KTtcblx0XHRcdCQoJyNhcGktZXhwLWdldC1idG4nKS50cmlnZ2VyKCdjbGljaycpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cdH07XG5cblx0Y2FuQmVDb3BpZWQoKSB7XG5cdFx0cmV0dXJuICEhT2JqZWN0LmdldFByb3Aoc2VsZi5jb25maWcsICcuX0NPTkZJRy5jb3B5QnRuLicgKyB0aGlzLmtleSkgJiYgdHlwZW9mIHRoaXMudmFsdWUgIT09ICdvYmplY3QnO1xuXHR9XG5cblx0c2V0QWN0aXZlKGtleSwgdmFsdWUsIG1vZGVsLCBlKXtcblx0XHQkKGUuY3VycmVudFRhcmdldClcblx0XHRcdC5wYXJlbnRzKCcuc2xpY2stc2xpZGUnKVxuXHRcdFx0LmZpbmQoJy5pdGVtLm9iamVjdCcpXG5cdFx0XHQucmVtb3ZlQ2xhc3MoJ2FjdGl2ZScpO1xuXHRcdCQoZS5jdXJyZW50VGFyZ2V0KVxuXHRcdFx0LnBhcmVudCgnLml0ZW0nKVxuXHRcdFx0LmFkZENsYXNzKCdhY3RpdmUnKTtcblx0XHR0aGlzLmdldE1vcmUuY2FsbChudWxsLCB7cGFuZWw6IHRoaXMsIGlkOiBrZXksIGRhdGE6IHZhbHVlfSk7XG5cdH1cbn1cblxuXG5cbm1vZHVsZS5leHBvcnRzID0ga28uY29tcG9uZW50cy5yZWdpc3Rlcignb2JqZWN0LXBhbmVsLWJvZHknLCB7XG5cdHZpZXdNb2RlbDogIE9iamVjdFBhbmVsQm9keSxcblx0dGVtcGxhdGU6YFxuXHRcdDxzZWN0aW9uIGRhdGEtYmluZD1cImNzczogeydhbGwtaW5zaWRlJzogJGNvbXBvbmVudC5fYWxsSW5zaWRlfVwiIGNsYXNzPVwicGFuZWwtYm9keSBvYmplY3QtcGFuZWwtYm9keVwiPlxuXHRcdFx0PCEtLSBrbyBpZjogJGNvbXBvbmVudC5fcGFuZWxOYW1lID09PSAnb2JqZWN0JyAmJiAhIU9iamVjdC5nZXRQcm9wKGtvLnVud3JhcChkYXRhKSwgJy5yYXRpbycpLS0+XG5cdFx0XHRcdDxpbWcgZGF0YS1iaW5kPVwiYXR0cjoge3NyYzoga28udXRpbHMudW53cmFwT2JzZXJ2YWJsZShkYXRhKS51cmwsIGFsdDogJ2ltYWdlLScgKyBrby51dGlscy51bndyYXBPYnNlcnZhYmxlKGRhdGEpLnJhdGlvfVwiIGFsdD1cImltZ1wiIGNsYXNzPVwiaW1nIGltZy10aHVtYm5haWxcIj5cblx0XHRcdDwhLS0gL2tvIC0tPlxuXHRcdFx0XG5cdFx0XHQ8dWwgZGF0YS1iaW5kPVwiZm9yZWFjaHByb3A6IHtkYXRhOiBkYXRhLCBzb3J0Rm46ICRjb21wb25lbnQuc29ydEJ5Q29uZmlnLmJpbmQoJGNvbXBvbmVudCl9XCIgY2xhc3M9XCJsaXN0IG9iamVjdC1saXN0XCI+XG5cdFx0XHRcdDxsaSBkYXRhLWJpbmQ9XCJjc3M6IHsnb2JqZWN0JzogdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JywgJ3ByaW1pdGl2ZSc6IHR5cGVvZiB2YWx1ZSAhPT0gJ29iamVjdCd9XCIgY2xhc3M9XCJjbGVhcmZpeCBwYWRpbmcgaXRlbVwiPlxuXHRcdFx0XHRcblx0XHRcdFx0XHQ8IS0tIGtvIGlmbm90OiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmICRjb21wb25lbnQuX2FsbEluc2lkZSAtLT5cblx0XHRcdFx0XHQ8c3BhbiBkYXRhLWJpbmQ9XCJ0ZXh0OiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnID8ga2V5OiBrZXkgKyAnOidcIiBjbGFzcz1cImtleVwiPjwvc3Bhbj5cblx0XHRcdFx0XHQ8IS0tIC9rbyAtLT5cblx0XHRcdFx0XHRcblx0XHRcdFx0XHQ8IS0tIGtvIGlmbm90OiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnIHx8ICRjb21wb25lbnQuX3BhbmVsTmFtZSA9PT0gJ3BhZ2UnICYmIGtleSA9PT0gJ251bWJlcicgLS0+XG5cdFx0XHRcdFx0XHQ8c3BhbiBkYXRhLWJpbmQ9XCJ0ZXh0OiB2YWx1ZVwiIGNsYXNzPVwidmFsdWVcIj48L3NwYW4+XG5cdFx0XHRcdFx0PCEtLSAva28gLS0+XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0PCEtLSBrbyBpZjogJGNvbXBvbmVudC5fcGFuZWxOYW1lID09PSAncGFnZScgJiYga2V5ID09PSAnbnVtYmVyJy0tPlxuXHRcdFx0XHRcdFx0PGRpdiBjbGFzcz1cImZvcm0taW5saW5lXCI+XG5cdFx0XHRcdFx0XHRcdDxpbnB1dCBpZD1cInBhZ2luYXRpb24taW5wdXRcIiBkYXRhLWJpbmQ9XCJldmVudDoge2tleWRvd246ICRjb21wb25lbnQub25FbnRlcktleURvd24uYmluZCgkY29tcG9uZW50KX0sIGF0dHI6IHtwbGFjZWhvbGRlcjogdmFsdWV9XCIgdHlwZT1cInRleHRcIiBwYXR0ZXJuPVwiWzAtOV0rXCIgY2xhc3M9XCJmb3JtLWNvbnRyb2xcIj5cblx0XHRcdFx0XHRcdDwvZGl2PlxuXHRcdFx0XHRcdDwhLS0gL2tvIC0tPlxuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdDwhLS0ga28gaWY6ICRjb21wb25lbnQuY2FuQmVDb3BpZWQuY2FsbCgkZGF0YSwgJyNwcm9wLXZhbHVlLScgKyBrZXkgKyAkaW5kZXgoKSkgLS0+XG5cdFx0XHRcdFx0XHQ8IS0tIGNvcHkgcHJvcGVydHkgYnRuIC0tPlxuXHRcdFx0XHRcdFx0PGJ1dHRvbiBkYXRhLWJpbmQ9XCJjb3B5VG9DbGlwYm9hcmQ6IHt0ZXh0OiB2YWx1ZS50b1N0cmluZygpfSwgYXR0cjoge2lkOiAncHJvcC12YWx1ZS0nICsga2V5ICsgJGluZGV4KCl9LCBwb3BvdmVyOiB7dHlwZTogJ3Rvb2x0aXAnLCB0aXRsZTogJ0NvcHkgdmFsdWUnfVwiIHR5cGU9XCJidXR0b25cIiBjbGFzcz1cImJ0biBidG4taWNvbiBidG4tY29weVwiPjwvYnV0dG9uPlxuXHRcdFx0XHRcdDwhLS0gL2tvIC0tPlxuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdDwhLS0ga28gaWY6IHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgJGNvbXBvbmVudC5fYWxsSW5zaWRlIC0tPlxuXHRcdFx0XHRcdFx0PHBhbmVsIHBhcmFtcz1cIiRkYXRhOiAkZGF0YSwgJGluZGV4OiAkaW5kZXgsIHBhbmVsR3JvdXA6ICRjb21wb25lbnRcIj48L3BhbmVsPlxuXHRcdFx0XHRcdDwhLS0gL2tvIC0tPlxuXHRcdFx0XHRcdDwhLS0ga28gaWY6IHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgISRjb21wb25lbnQuX2FsbEluc2lkZSAtLT5cblx0XHRcdFx0XHRcdDxidXR0b24gZGF0YS1iaW5kPVwiY2xpY2s6ICRjb21wb25lbnQuc2V0QWN0aXZlLmJpbmQoJGNvbXBvbmVudCwga2V5LCB2YWx1ZSlcIiB0eXBlPVwiYnV0dG9uXCIgY2xhc3M9XCJidG4gYnRuLWljb24gYmx1ZS1zaGV2cm9uLXJpZ2h0IHB1bGwtcmlnaHRcIj48L2J1dHRvbj5cblx0XHRcdFx0XHQ8IS0tIC9rbyAtLT5cblx0XHRcdFx0PC9saT5cblx0XHRcdDwvdWw+XG5cdFx0PC9zZWN0aW9uPlxuYH0pO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc2NyaXB0cy9hcGktZXhwbG9yZXIvdjIvc3JjL2NvbXBvbmVudHMvcGFuZWxzL29iamVjdFBhbmVsQm9keS5jb21wb25lbnQuanMiLCJtb2R1bGUuZXhwb3J0cyA9IHsgXCJkZWZhdWx0XCI6IHJlcXVpcmUoXCJjb3JlLWpzL2xpYnJhcnkvZm4vbnVtYmVyL2lzLW5hblwiKSwgX19lc01vZHVsZTogdHJ1ZSB9O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9iYWJlbC1ydW50aW1lL2NvcmUtanMvbnVtYmVyL2lzLW5hbi5qc1xuLy8gbW9kdWxlIGlkID0gMTU2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInJlcXVpcmUoJy4uLy4uL21vZHVsZXMvZXM2Lm51bWJlci5pcy1uYW4nKTtcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9fY29yZScpLk51bWJlci5pc05hTjtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9saWJyYXJ5L2ZuL251bWJlci9pcy1uYW4uanNcbi8vIG1vZHVsZSBpZCA9IDE1N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyAyMC4xLjIuNCBOdW1iZXIuaXNOYU4obnVtYmVyKVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdOdW1iZXInLCB7XG4gIGlzTmFOOiBmdW5jdGlvbiBpc05hTihudW1iZXIpe1xuICAgIHJldHVybiBudW1iZXIgIT0gbnVtYmVyO1xuICB9XG59KTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM2Lm51bWJlci5pcy1uYW4uanNcbi8vIG1vZHVsZSBpZCA9IDE1OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgc2VsZjtcblxuY2xhc3MgQXJyYXlQYW5lbEJvZHkge1xuXHRjb25zdHJ1Y3RvcihwYXJhbXMpIHtcblx0XHRzZWxmID0gdGhpcztcblx0XHR0aGlzLmRhdGEgPSBwYXJhbXMuZGF0YS52YWx1ZTtcblx0XHR0aGlzLmNvbmZpZyA9IHBhcmFtcy5jb25maWc7XG5cdFx0dGhpcy5fcGFuZWxOYW1lID0gcGFyYW1zLmRhdGEua2V5O1xuXHRcdHRoaXMuY2FyZEluZGV4ID0gdGhpcy5jYXJkSW5kZXggfHwga28udXRpbHMudW53cmFwT2JzZXJ2YWJsZShwYXJhbXMuaW5kZXgpO1xuXHRcdHRoaXMucGFuZWxHcm91cCA9IHBhcmFtcy5wYW5lbEdyb3VwO1xuXHRcdHRoaXMuZ2V0TW9yZSA9IHRoaXMucGFuZWxHcm91cC5nZXRNb3JlO1xuXHR9XG5cblx0Z2V0U3RhcnREYXRhKCRkYXRhKSB7XG5cdFx0cmV0dXJuIE9iamVjdC5nZXRQcm9wKCRkYXRhLCAnZGF0ZXMuc3RhcnQubG9jYWxEYXRlJykgfHwgJydcblx0fVxuXHRnZXRWZW51ZU5hbWUoJGRhdGEpIHtcblx0XHRyZXR1cm4gT2JqZWN0LmdldFByb3AoJGRhdGEsICdfZW1iZWRkZWQudmVudWVzWzBdLm5hbWUnKSB8fCAnJ1xuXHR9XG5cdHNldEFjdGl2ZSgkaW5kZXgsIG1vZGVsLCBlKSB7XG5cdFx0JChlLmN1cnJlbnRUYXJnZXQpXG5cdFx0XHQucGFyZW50cygnLnNsaWNrLXNsaWRlJylcblx0XHRcdC5maW5kKCcuaXRlbS5vYmplY3QnKVxuXHRcdFx0LnJlbW92ZUNsYXNzKCdhY3RpdmUnKTtcblx0XHQkKGUuY3VycmVudFRhcmdldClcblx0XHRcdC5wYXJlbnQoJy5pdGVtJylcblx0XHRcdC5hZGRDbGFzcygnYWN0aXZlJyk7XG5cdFx0dGhpcy5nZXRNb3JlLmNhbGwobnVsbCwge3BhbmVsOiB0aGlzLCBpZDogJGluZGV4LCBkYXRhOiBtb2RlbH0pO1xuXHR9XG59XG5cbm1vZHVsZS5leHBvcnRzID0ga28uY29tcG9uZW50cy5yZWdpc3RlcignYXJyYXktcGFuZWwtYm9keScsIHtcblx0dmlld01vZGVsOiBBcnJheVBhbmVsQm9keSxcblx0dGVtcGxhdGU6YFxuXHRcdDxzZWN0aW9uIGNsYXNzPVwicGFuZWwtYm9keSBhcnJheS1wYW5lbC1ib2R5XCI+XG5cdFx0XHQ8dWwgZGF0YS1iaW5kPVwiZm9yZWFjaDogZGF0YSwgY3NzOiB7J2V2ZW50cyc6ICRjb21wb25lbnQuX3BhbmVsTmFtZSA9PT0gJ2V2ZW50cyd9XCIgY2xhc3M9XCJsaXN0IGxpc3QtZ3JvdXBcIj5cblx0XHRcdFx0PGxpIGRhdGEtYmluZD1cImNzczogeydvYmplY3QnOiB0eXBlb2YgJGRhdGEgPT09ICdvYmplY3QnfVwiIGNsYXNzPVwibGlzdC1ncm91cC1pdGVtIGl0ZW1cIj5cblx0XHRcdFx0XG5cdFx0XHRcdFx0PCEtLSBrbyBpZjogJGNvbXBvbmVudC5fcGFuZWxOYW1lID09PSAnaW1hZ2VzJyAtLT5cblx0XHRcdFx0XHRcdDxpbWcgZGF0YS1iaW5kPVwiYXR0cjoge3NyYzogdXJsLCBhbHQ6ICdpbWFnZS0nICsgcmF0aW99XCIgYWx0PVwiaW1nXCIgY2xhc3M9XCJpbWdcIj5cblx0XHRcdFx0XHRcdDxkaXYgY2xhc3M9XCJpbWctaW5mb1wiPlxuXHRcdFx0XHRcdFx0XHQ8c3BhbiBjbGFzcz1cImltZy1yYXRpb1wiPlJhdGlvOiA8aSBkYXRhLWJpbmQ9XCJ0ZXh0OiByYXRpb1wiPjwvaT48L3NwYW4+XG5cdFx0XHRcdFx0XHRcdDxzcGFuIGNsYXNzPVwiaW1nLXNpemVcIj4oPGkgZGF0YS1iaW5kPVwidGV4dDogaGVpZ2h0XCI+PC9pPiB4IDxpIGRhdGEtYmluZD1cInRleHQ6IHdpZHRoXCI+PC9pPik8L3NwYW4+XG5cdFx0XHRcdFx0XHQ8L2Rpdj5cblx0XHRcdFx0XHQ8IS0tIC9rbyAtLT5cblx0XHRcdFx0XHRcblx0XHRcdFx0XHQ8IS0tIGtvIGlmbm90OiAkY29tcG9uZW50Ll9wYW5lbE5hbWUgPT09ICdpbWFnZXMnIC0tPlxuXHRcdFx0XHRcdFx0PGRpdiBjbGFzcz1cInZlcnRpY2FsLWFsaWduLWNlbnRlclwiPlxuXHRcdFx0XHRcdFx0XHQ8ZGl2IGNsYXNzPVwibmFtZS13cmFwcGVyXCI+XG5cdFx0XHRcdFx0XHRcdFx0PHNwYW4gZGF0YS1iaW5kPVwidGV4dDogbmFtZSB8fCAnIycgKyAkaW5kZXgoKSwgYmxvY2tFbGxpcHNpczoge2NsYW1wOiAyfVwiIGNsYXNzPVwibmFtZVwiPjwvc3Bhbj5cblx0XHRcdFx0XHRcdFx0PC9kaXY+XG5cdFx0XHRcdFx0XHQ8L2Rpdj5cblx0XHRcdFx0XHRcdFxuXHRcdFx0XHRcdFx0PCEtLSBrbyBpZjogJGNvbXBvbmVudC5fcGFuZWxOYW1lID09PSAnZXZlbnRzJyAtLT5cblx0XHRcdFx0XHRcdFx0PGRpdiBjbGFzcz1cImFkZGl0aW9uYWwtaW5mb1wiPlxuXHRcdFx0XHRcdFx0XHRcdDxwIGRhdGEtYmluZD1cInRleHQ6ICRjb21wb25lbnQuZ2V0U3RhcnREYXRhKCRkYXRhKVwiIGNsYXNzPVwiZGF0ZVwiPmV2ZW50IGRhdGU8L3A+XG5cdFx0XHRcdFx0XHRcdFx0PCEtLSBrbyBpZjogJGNvbXBvbmVudC5nZXRWZW51ZU5hbWUoJGRhdGEpLS0+XG5cdFx0XHRcdFx0XHRcdFx0XHQ8cCBkYXRhLWJpbmQ9XCJ0ZXh0OiAkY29tcG9uZW50LmdldFZlbnVlTmFtZSgkZGF0YSlcIiBjbGFzcz1cInZlbnVlIHRydW5jYXRlXCI+ZXZlbnQgdmVudWU8L3A+XG5cdFx0XHRcdFx0XHRcdFx0PCEtLS9rby0tPlxuXHRcdFx0XHRcdFx0XHQ8L2Rpdj5cblx0XHRcdFx0XHRcdDwhLS0gL2tvIC0tPlxuXHRcdFx0XHRcdFx0XG5cdFx0XHRcdFx0PCEtLSAva28gLS0+XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0PCEtLSBrbyBpZjogdHlwZW9mICRkYXRhID09PSAnb2JqZWN0JyAtLT5cblx0XHRcdFx0XHRcdDxidXR0b24gZGF0YS1iaW5kPVwiY2xpY2s6ICRjb21wb25lbnQuc2V0QWN0aXZlLmJpbmQoJGNvbXBvbmVudCwgJGluZGV4KCkpXCIgdHlwZT1cImJ1dHRvblwiIGNsYXNzPVwiYnRuIGJ0bi1pY29uIGJsdWUtc2hldnJvbi1yaWdodCBwdWxsLXJpZ2h0XCI+PC9idXR0b24+XG5cdFx0XHRcdFx0PCEtLSAva28gLS0+XG5cdFx0XHRcdFx0XG5cdFx0XHRcdDwvbGk+XG5cdFx0XHQ8L3VsPlxuXHRcdDwvc2VjdGlvbj5cbmB9KTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NjcmlwdHMvYXBpLWV4cGxvcmVyL3YyL3NyYy9jb21wb25lbnRzL3BhbmVscy9hcnJheVBhbmVsQm9keS5jb21wb25lbnQuanMiLCJyZXF1aXJlKCcuL3JlcXVlc3RMaXN0LmNvbXBvbmVudCcpO1xyXG5yZXF1aXJlKCcuL3JlcXVlc3QuY29tcG9uZW50Jyk7XHJcbnJlcXVpcmUoJy4vcmVzcG9uc2UuY29tcG9uZW50Jyk7XHJcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NjcmlwdHMvYXBpLWV4cGxvcmVyL3YyL3NyYy9jb21wb25lbnRzL3JlcXVlc3QvaW5kZXguanMiLCJpbXBvcnQge2NvbG9yc1NlcnZpY2V9IGZyb20gJy4uLy4uL3NlcnZpY2VzJztcclxudmFyIHNsaWRlciA9IHJlcXVpcmUoJy4uLy4uL21vZHVsZXMvc2xpZGVyJyk7XHJcblxyXG5jbGFzcyBSZXF1ZXN0TGlzdENvbXBvbmVudHtcclxuXHRjb25zdHJ1Y3Rvcih7c2VsZWN0ZWRQYXJhbXMsIHNoYXJlUGF0aCwgc2V0UGFyYW1zfSkge1xyXG5cdFx0dGhpcy51cmwgPSBzZWxlY3RlZFBhcmFtcztcclxuXHRcdHRoaXMuc2hhcmVQYXRoID0gc2hhcmVQYXRoO1xyXG5cdFx0dGhpcy5yZXF1ZXN0cyA9IGtvLm9ic2VydmFibGVBcnJheShbXSkuc3luY1dpdGgoJ1JFUVVFU1RTX0FSUicpO1xyXG5cdFx0dGhpcy5zZXRQYXJhbXMgPSBzZXRQYXJhbXM7XHJcblx0XHR0aGlzLmNvbG9ycyA9IGNvbG9yc1NlcnZpY2UuY29sb3JzO1xyXG5cdFx0dGhpcy52aWV3TW9kZWwgPSBrby5vYnNlcnZhYmxlQXJyYXkoW10pO1xyXG5cdFx0dGhpcy5jbGVhckJ0bklzVmlzaWJsZSA9IGtvLmNvbXB1dGVkKHRoaXMuX2lzVmlzaWJsZSwgdGhpcyk7XHJcblx0XHR0aGlzLnJlcXVlc3RzLnN1YnNjcmliZSh0aGlzLnVwZGF0ZU1vZGVsLCB0aGlzKTtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFVwZGF0ZSBWaWV3bW9kZWwgb2YgcmVxdWVzdCBsaXN0XHJcblx0ICogQHBhcmFtIGFyclxyXG5cdCAqL1xyXG5cdHVwZGF0ZU1vZGVsKGFycikge1xyXG5cdFx0dmFyIG5ld01vZGVsID0ga28udW53cmFwKHRoaXMucmVxdWVzdHMpXHJcblx0XHRcdC5tYXAob2JqID0+IHtcclxuXHRcdFx0XHR2YXIgbmV3T2JqID0ge1xyXG5cdFx0XHRcdFx0Y29sb3I6IHRoaXMuY29sb3JzW29iai5pbmRleCAlIHRoaXMuY29sb3JzLmxlbmd0aF0sXHJcblx0XHRcdFx0XHRhY3RpdmU6IGtvLm9ic2VydmFibGUoZmFsc2UpLFxyXG5cdFx0XHRcdFx0aXNBY3RpdmVNb3JlTWVudToga28ub2JzZXJ2YWJsZShmYWxzZSksXHJcblx0XHRcdFx0XHRjb3BpZWRGb3JTaGFyZToga28ub2JzZXJ2YWJsZShmYWxzZSksXHJcblx0XHRcdFx0XHRwYXJhbXNBcmVTZXRlZDoga28ub2JzZXJ2YWJsZShmYWxzZSksXHJcblx0XHRcdFx0XHRjb3BpZWRVcmw6IGtvLm9ic2VydmFibGUoZmFsc2UpLFxyXG5cdFx0XHRcdFx0cmVzSFRNTDoga28ub2JzZXJ2YWJsZSgnJylcclxuXHRcdFx0XHR9O1xyXG5cclxuXHRcdFx0XHQvLyBlcnJvciBwb3BvdmVyXHJcblx0XHRcdFx0aWYgKG9iai5lcnJvcikge1xyXG5cdFx0XHRcdFx0dmFyIGVycm9yT2JqID0gb2JqLmVycm9yO1xyXG5cdFx0XHRcdFx0bmV3T2JqLmVycm9yID0ga28ub2JzZXJ2YWJsZShbXHJcblx0XHRcdFx0XHRcdE9iamVjdC5nZXRQcm9wKGVycm9yT2JqLCAnLnJlc3BvbnNlSlNPTi5lcnJvcnNbMF0uc3RhdHVzJykgfHwgZXJyb3JPYmouc3RhdHVzICsgJycsXHJcblx0XHRcdFx0XHRcdE9iamVjdC5nZXRQcm9wKGVycm9yT2JqLCAnLnJlc3BvbnNlSlNPTi5lcnJvcnNbMF0uc3RhdHVzVGV4dCcpIHx8ICcnLFxyXG5cdFx0XHRcdFx0XHRPYmplY3QuZ2V0UHJvcChlcnJvck9iaiwgJy5yZXNwb25zZUpTT04uZXJyb3JzWzBdLmRldGFpbCcpIHx8ICd1bmtub3duJyxcclxuXHRcdFx0XHRcdFx0T2JqZWN0LmdldFByb3AoZXJyb3JPYmosICcucmVzcG9uc2VKU09OJykgfHwge31cclxuXHRcdFx0XHRcdF0pXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRyZXR1cm4gJC5leHRlbmQoe30sIG9iaiwgbmV3T2JqKTtcclxuXHRcdFx0fSk7XHJcblx0XHRzbGlkZXIucmVtb3ZlKHRoaXMudmlld01vZGVsKCkubGVuZ3RoKTtcclxuXHRcdHRoaXMudmlld01vZGVsKG5ld01vZGVsKTtcclxuXHRcdHNldFRpbWVvdXQoKCkgPT4ge1xyXG5cdFx0XHRzbGlkZXIuc2V0KHRoaXMudmlld01vZGVsKCkubGVuZ3RoKTtcclxuXHRcdFx0JCgnI3Nob3ctZGV0YWlscy0wJykudHJpZ2dlcignY2xpY2snKTtcclxuXHRcdH0sIDEwKTtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFZpc2liaWxpdHkgZmxhZyBmb3IgQ2xlYXIgYnRuXHJcblx0ICogQHJldHVybnMge2Jvb2xlYW59XHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRfaXNWaXNpYmxlKCkge1xyXG5cdFx0cmV0dXJuIGtvLnV0aWxzLnVud3JhcE9ic2VydmFibGUodGhpcy5yZXF1ZXN0cykubGVuZ3RoID4gMDtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIENsZWFyIHJlcXVlc3RzdHMgbGlzdCBoYW5kbGVyXHJcblx0ICogQHBhcmFtIHZtXHJcblx0ICogQHBhcmFtIGV2ZW50XHJcblx0ICovXHJcblx0b25DbGVhclJlcXVlc3RzKHZtLCBldmVudCkge1xyXG5cdFx0dGhpcy5yZXF1ZXN0cyhbXSk7XHJcblx0fVxyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGtvLmNvbXBvbmVudHMucmVnaXN0ZXIoJ3JlcXVlc3QtbGlzdCcsIHtcclxuXHR2aWV3TW9kZWw6IFJlcXVlc3RMaXN0Q29tcG9uZW50LFxyXG5cdHRlbXBsYXRlOmBcclxuXHQ8c2VjdGlvbiBjbGFzcz1cImNsZWFyZml4XCI+XHJcblx0XHQ8IS0ta28gaWY6IGNsZWFyQnRuSXNWaXNpYmxlLS0+XHJcblx0XHRcdDwhLS1oZWFkbGluZS0tPlxyXG5cdFx0XHQ8c2VjdGlvbiBjbGFzcz1cInJvdy1jb250YWluZXIgYXBpLWV4cC1yZXF1ZXN0LWxpc3QtaGVhZGxpbmVcIj5cclxuXHRcdFx0XHQ8aDQgY2xhc3M9XCJ0aXRsZVwiPlJlcXVlc3QgbGlzdDwvaDQ+XHJcblx0XHRcdFx0PGRpdiBjbGFzcz1cImhlYWRsaW5lLWVkaXRcIj5cclxuXHRcdFx0XHRcdDxidXR0b24gZGF0YS1iaW5kPVwiY2xpY2s6IG9uQ2xlYXJSZXF1ZXN0cywgcG9wb3Zlcjoge3R5cGU6ICd0b29sdGlwJywgdGl0bGU6ICdDbGVhciByZXF1ZXN0cyBoaXN0b3J5J31cIiBjbGFzcz1cImJ0biBidG4taWNvbiBidG4tY2xlYXJcIiB0eXBlPVwiYnV0dG9uXCI+PC9idXR0b24+XHJcblx0XHRcdFx0PC9kaXY+XHJcblx0XHRcdDwvc2VjdGlvbj5cclxuXHJcblx0XHRcdDwhLS1yZXF1ZXN0cy0tPlxyXG5cdFx0XHQ8c2VjdGlvbj5cclxuXHRcdFx0XHQ8dWwgZGF0YS1iaW5kPVwiZm9yZWFjaDogdmlld01vZGVsXCIgY2xhc3M9XCJwYW5lbC1ncm91cCBhcGktZXhwLXJlcXVlc3QtbGlzdFwiIGlkPVwicmVzcG9uc2VcIiByb2xlPVwidGFibGlzdFwiIGFyaWEtbXVsdGlzZWxlY3RhYmxlPVwidHJ1ZVwiPlxyXG5cdFx0XHRcdFx0PGxpIGRhdGEtYmluZD1cImNzczoge2FjdGl2ZTogYWN0aXZlfVwiIGNsYXNzPVwicGFuZWwgcGFuZWwtZGVmYXVsdCBhcGktZXhwLXJlcXVlc3QtbGlzdC1pdGVtIGNsZWFyZml4XCI+XHJcblx0XHRcdFx0XHRcdDxyZXF1ZXN0LWNvbXBvbmVudCBwYXJhbXM9XCJkYXRhOiAkZGF0YSwgaW5kZXg6ICRpbmRleCwgc2hhcmVQYXRoOiAkcm9vdC5zaGFyZVBhdGgsIHNldFBhcmFtczogJHJvb3Quc2V0UGFyYW1zXCI+PC9yZXF1ZXN0LWNvbXBvbmVudD5cclxuXHRcdFx0XHRcdFx0PHJlc3BvbnNlLWNvbXBvbmVudCBwYXJhbXM9XCJkYXRhOiAkZGF0YSwgaW5kZXg6ICRpbmRleCwgY29uZmlnOiAkcm9vdC5jb25maWcsIHNldFBhcmFtczogJGNvbXBvbmVudC5zZXRQYXJhbXNcIj48L3Jlc3BvbnNlLWNvbXBvbmVudD5cclxuXHRcdFx0XHRcdDwvbGk+XHJcblx0XHRcdFx0PC91bD5cclxuXHRcdFx0PC9zZWN0aW9uPlxyXG5cdFx0PCEtLSAva28gLS0+XHJcblx0PC9zZWN0aW9uPlxyXG5gfSk7XHJcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NjcmlwdHMvYXBpLWV4cGxvcmVyL3YyL3NyYy9jb21wb25lbnRzL3JlcXVlc3QvcmVxdWVzdExpc3QuY29tcG9uZW50LmpzIiwiY29uc3QgY29uZmlnID0ge1xyXG5cdGRvdHM6IGZhbHNlLFxyXG5cdGluZmluaXRlOiBmYWxzZSxcclxuXHRzcGVlZDogMzAwLFxyXG5cdHNsaWRlc1RvU2hvdzogMyxcclxuXHRzbGlkZXNUb1Njcm9sbDogMSxcclxuXHRhdXRvcGxheTogZmFsc2UsXHJcblx0Zm9jdXNPblNlbGVjdDogdHJ1ZSxcclxuXHRyZXNwb25zaXZlOiBbXHJcblx0XHR7XHJcblx0XHRcdGJyZWFrcG9pbnQ6IDEyMDAsXHJcblx0XHRcdHNldHRpbmdzOiB7XHJcblx0XHRcdFx0ZG90czogdHJ1ZSxcclxuXHRcdFx0XHRzbGlkZXNUb1Nob3c6IDIsXHJcblx0XHRcdFx0c2xpZGVzVG9TY3JvbGw6IDEsXHJcblx0XHRcdH1cclxuXHRcdH0sXHJcblx0XHR7XHJcblx0XHRcdGJyZWFrcG9pbnQ6IDgwMCxcclxuXHRcdFx0c2V0dGluZ3M6IHtcclxuXHRcdFx0XHRkb3RzOiB0cnVlLFxyXG5cdFx0XHRcdHNsaWRlc1RvU2hvdzogMSxcclxuXHRcdFx0XHRzbGlkZXNUb1Njcm9sbDogMVxyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XVxyXG59O1xyXG5cclxuZnVuY3Rpb24gc2xpY2sodGltZXMpIHtcclxuXHRcInVzZSBzdHJpY3RcIjtcclxuXHR2YXIgc2VsZWN0b3IgPSAnI3NsaWRlci0nO1xyXG5cclxuXHRmb3IgKGxldCBpID0gMDsgaSA8IHRpbWVzOyBpKyspIHtcclxuXHRcdGxldCBzbGlkZXIgPSAkKHNlbGVjdG9yICsgaSk7XHJcblx0XHRpZihzbGlkZXIubGVuZ3RoKSB7XHJcblx0XHRcdHNsaWRlci5zbGljayhjb25maWcpO1xyXG5cdFx0fVxyXG5cdH1cclxufVxyXG5cclxuZnVuY3Rpb24gdW5zbGljayh0aW1lcykge1xyXG5cdFwidXNlIHN0cmljdFwiO1xyXG5cclxuXHRmb3IgKGxldCBpID0gMDsgaSA8IHRpbWVzOyBpKyspIHtcclxuXHRcdGxldCBzbGlkZXIgPSAkKCcjc2xpZGVyLScgKyBpKTtcclxuXHRcdHNsaWRlci5sZW5ndGggJiYgc2xpZGVyLnNsaWNrKCd1bnNsaWNrJyk7XHJcblx0fVxyXG5cdGNvbnNvbGUuaW5mbygnY2xlYXJlZCcpO1xyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IHtcclxuXHRzZXQ6IHNsaWNrLFxyXG5cdHJlbW92ZTogdW5zbGlja1xyXG59O1xyXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zY3JpcHRzL2FwaS1leHBsb3Jlci92Mi9zcmMvbW9kdWxlcy9zbGlkZXIuanMiLCJpbXBvcnQge2pzb25ITH0gZnJvbSAnLi4vLi4vc2VydmljZXMnO1xyXG5cclxuY2xhc3MgUmVxdWVzdENvbXBvbmVudHtcclxuXHRjb25zdHJ1Y3Rvcih7ZGF0YSwgaW5kZXgsIHNoYXJlUGF0aCwgc2V0UGFyYW1zfSkge1xyXG5cdFx0Y29uc3QgJGluZGV4ID0ga28udW53cmFwKGluZGV4KTtcclxuXHRcdHRoaXMuZGF0YSA9IGRhdGE7XHJcblx0XHR0aGlzLnJlc3BvbnNlID0gZGF0YS5yZXNwb25zZTtcclxuXHRcdHRoaXMuaGFzUmVzcG9uc2UgPSAhIWRhdGEucmVzcG9uc2U7XHJcblx0XHR0aGlzLnJlcSA9IGRhdGEucmVxO1xyXG5cdFx0dGhpcy5qc29uSEwgPSBqc29uSEw7XHJcblx0XHR0aGlzLmNvbG9yID0gZGF0YS5jb2xvcjtcclxuXHRcdHRoaXMuYWN0aXZlID0gZGF0YS5hY3RpdmU7XHJcblx0XHR0aGlzLmlzQWN0aXZlTW9yZU1lbnUgPSBkYXRhLmlzQWN0aXZlTW9yZU1lbnU7XHJcblx0XHR0aGlzLmNvcGllZEZvclNoYXJlID0gZGF0YS5jb3BpZWRGb3JTaGFyZTtcclxuXHRcdHRoaXMucGFyYW1zQXJlU2V0ZWQgPSBkYXRhLnBhcmFtc0FyZVNldGVkO1xyXG5cdFx0dGhpcy5jb3BpZWRVcmwgPSBkYXRhLmNvcGllZFVybDtcclxuXHRcdHRoaXMucmVzSFRNTCA9IGRhdGEucmVzSFRNTDtcclxuXHRcdHRoaXMuc2hhcmVQYXRoID0gc2hhcmVQYXRoO1xyXG5cdFx0dGhpcy5yb290c2V0UGFyYW1zID0gc2V0UGFyYW1zO1xyXG5cdFx0dGhpcy5pZHMgPSB7XHJcblx0XHRcdHdyYXBwZXI6IGBoZWFkaW5nLSR7JGluZGV4fWAsXHJcblx0XHRcdGRldGFpbHM6IHtcclxuXHRcdFx0XHRpZDogYHNob3ctZGV0YWlscy0keyRpbmRleH1gLFxyXG5cdFx0XHRcdHRhcmdldDogYCNjb2xsYXBzZS0keyRpbmRleH1gLFxyXG5cdFx0XHRcdGNvbnRyb2xzOiBgY29sbGFwc2UtJHskaW5kZXh9YFxyXG5cdFx0XHR9XHJcblx0XHR9O1xyXG5cdH1cclxuXHJcblx0c2V0UGFyYW1zKCkge1xyXG5cdFx0dGhpcy5wYXJhbXNBcmVTZXRlZCh0cnVlKTtcclxuXHRcdHNldFRpbWVvdXQoKCkgPT4ge1xyXG5cdFx0XHR0aGlzLnBhcmFtc0FyZVNldGVkKGZhbHNlKTtcclxuXHRcdH0sIDIwMCk7XHJcblx0XHR0aGlzLnJvb3RzZXRQYXJhbXModGhpcy5kYXRhKTtcclxuXHR9XHJcblxyXG5cdGdldE1vcmVNZW51KCkge1xyXG5cdFx0dGhpcy5pc0FjdGl2ZU1vcmVNZW51KCFrby51bndyYXAodGhpcy5pc0FjdGl2ZU1vcmVNZW51KSk7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBEZXRhaWxzIHRvZ2dsZSBoYW5kbGVyXHJcblx0ICogQHBhcmFtIG1vZGVsXHJcblx0ICogQHBhcmFtIGV2ZW50XHJcblx0ICovXHJcblx0Z2V0RGV0YWlscyhtb2RlbCwgZXZlbnQpIHtcclxuXHRcdGlmICgha28udW53cmFwKHRoaXMucmVzSFRNTCkubGVuZ3RoKSB7XHJcblx0XHRcdHRoaXMuanNvbkhMKHRoaXMucmVzSFRNTCwgdGhpcy5yZXNwb25zZSk7XHJcblx0XHR9XHJcblxyXG5cdFx0bGV0IHNsaWRlciA9ICQoZXZlbnQuY3VycmVudFRhcmdldClcclxuXHRcdFx0LnBhcmVudHMoJy5wYW5lbCcpXHJcblx0XHRcdC5maW5kKCcuc2xpY2stc2xpZGVyJyk7XHJcblxyXG5cdFx0aWYgKCFzbGlkZXIuZmluZCgnLnNsaWNrLXRyYWNrJykud2lkdGgoKSkge1xyXG5cdFx0XHRzZXRUaW1lb3V0KCgpPT4ge1xyXG5cdFx0XHRcdHNsaWRlci5zbGljaygnc2V0UG9zaXRpb24nKTtcclxuXHRcdFx0fSwgMCk7XHJcblx0XHR9XHJcblx0XHR0aGlzLmFjdGl2ZSghdGhpcy5hY3RpdmUoKSk7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBHZXQgcmF3IHJlc3BvbnNlIGRhdGFcclxuXHQgKiBAcGFyYW0gbW9kZWwge29iamVjdH1cclxuXHQgKiBAcmV0dXJucyB7c3RyaW5nfVxyXG5cdCAqL1xyXG5cdGdldFJhd0RhdGEobW9kZWwgPSB7fSkge1xyXG5cdFx0dmFyIGNvbnRlbnQgPSBtb2RlbC5yZXNwb25zZSB8fCBrby51bndyYXAobW9kZWwuZGF0YS5lcnJvcilbM10gfHwge307XHJcblx0XHR2YXIgcmF3V2luZG93ID0gd2luZG93Lm9wZW4oXCJkYXRhOnRleHQvanNvbixcIiArIGVuY29kZVVSSShKU09OLnN0cmluZ2lmeShjb250ZW50LCBudWxsLCAyKSksICdfYmxhbmsnKTtcclxuXHRcdHJhd1dpbmRvdy5mb2N1cygpO1xyXG5cdH1cclxuXHJcblx0Z2V0IHNldFBhcmFtc1BvcG92ZXIoKSB7XHJcblx0XHRyZXR1cm4ge1xyXG5cdFx0XHR0eXBlOiAndG9vbHRpcCcsXHJcblx0XHRcdHRpdGxlOiAnUmVwZWF0IHNldHRpbmdzIG9mIHRoaXMgcmVxdWVzdCdcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdGdldCBzaGFyZVBhdGhQb3BvdmVyKCkge1xyXG5cdFx0cmV0dXJuIHtcclxuXHRcdFx0dHlwZTogJ3Rvb2x0aXAnLFxyXG5cdFx0XHR0aXRsZTogJ0NvcHkgcmVxdWVzdCBzaGFyZSBsaW5rJ1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0Z2V0IGNvcHlVcmxQb3BvdmVyKCkge1xyXG5cdFx0cmV0dXJuIHtcclxuXHRcdFx0dHlwZTogJ3Rvb2x0aXAnLFxyXG5cdFx0XHR0aXRsZTogJ0NvcHkgcmVxdWVzdCBVUkwnXHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHRnZXQgZ2V0UmF3RGF0YVBvcG92ZXIoKSB7XHJcblx0XHRyZXR1cm4ge1xyXG5cdFx0XHR0eXBlOiAndG9vbHRpcCcsXHJcblx0XHRcdHRpdGxlOiAnU2hvdyByYXcgcmVzcG9uc2UgZGF0YSdcclxuXHRcdH1cclxuXHR9XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0ga28uY29tcG9uZW50cy5yZWdpc3RlcigncmVxdWVzdC1jb21wb25lbnQnLCB7XHJcblx0dmlld01vZGVsOiBSZXF1ZXN0Q29tcG9uZW50LFxyXG5cdHRlbXBsYXRlOmBcclxuXHRcdDxzZWN0aW9uIGNsYXNzPVwicm93LWNvbnRhaW5lciByZXF1ZXN0XCIgZGF0YS1iaW5kPVwiYXR0cjoge2lkOiBpZHMud3JhcHBlcn1cIiByb2xlPVwidGFiXCI+XHJcblx0XHRcdDxkaXYgY2xhc3M9XCJlZGl0LWNvbnRyb2xzXCIgZGF0YS1iaW5kPVwiY3NzOiB7J3Zpc2libGUgd2hpdGUnOiBpc0FjdGl2ZU1vcmVNZW51fVwiPlxyXG5cdFx0XHRcdDxidXR0b24gZGF0YS1iaW5kPVwiY2xpY2s6IHNldFBhcmFtcywgY3NzOiB7ZG9uZTogcGFyYW1zQXJlU2V0ZWR9LCBwb3BvdmVyOiBzZXRQYXJhbXNQb3BvdmVyXCIgY2xhc3M9XCJidG4gYnRuLWljb24gYnRuLXByZXNldFwiIHR5cGU9XCJidXR0b25cIj48L2J1dHRvbj5cclxuXHRcdFx0XHQ8YnV0dG9uIGRhdGEtYmluZD1cImNvcHlUb0NsaXBib2FyZDoge3RleHQ6IHNoYXJlUGF0aH0sIHBvcG92ZXI6IHNoYXJlUGF0aFBvcG92ZXJcIiBjbGFzcz1cImJ0biBidG4taWNvbiBidG4tc2hhcmVcIiB0eXBlPVwiYnV0dG9uXCI+PC9idXR0b24+XHJcblx0XHRcdFx0PGJ1dHRvbiBkYXRhLWJpbmQ9XCJjb3B5VG9DbGlwYm9hcmQ6IHt0ZXh0OiByZXF9LCBwb3BvdmVyOiBjb3B5VXJsUG9wb3ZlclwiIGNsYXNzPVwiYnRuIGJ0bi1pY29uIGJ0bi1jb3B5XCIgdHlwZT1cImJ1dHRvblwiPjwvYnV0dG9uPlxyXG5cdFx0XHRcdDxidXR0b24gZGF0YS1iaW5kPVwiY2xpY2s6IGdldFJhd0RhdGEsIHBvcG92ZXI6IGdldFJhd0RhdGFQb3BvdmVyXCIgY2xhc3M9XCJidG4gYnRuLWljb24gYnRuLXJhd1wiIHR5cGU9XCJidXR0b25cIj48L2J1dHRvbj5cclxuXHRcdFx0PC9kaXY+XHJcblx0XHRcdDxidXR0b24gZGF0YS1iaW5kPVwiY2xpY2s6IGdldE1vcmVNZW51LCBjc3M6IHthY3RpdmU6IGlzQWN0aXZlTW9yZU1lbnV9XCIgY2xhc3M9XCJidG4gYnRuLWljb24gYnRuLW1vcmVcIj48L2J1dHRvbj5cclxuXHRcdFx0PGRpdiBjbGFzcz1cInBhbmVsLXRpdGxlXCI+XHJcblx0XHRcdFx0PCEtLSBrbyBpZjogaGFzUmVzcG9uc2UgLS0+XHJcblx0XHRcdFx0XHQ8YnV0dG9uIGRhdGEtYmluZD1cImNsaWNrOiBnZXREZXRhaWxzLCBhdHRyOiB7aWQ6IGlkcy5kZXRhaWxzLmlkLCAnZGF0YS10YXJnZXQnOiBpZHMuZGV0YWlscy50YXJnZXQsICdhcmlhLWNvbnRyb2xzJzogaWRzLmRldGFpbHMuY29udHJvbHN9XCIgdHlwZT1cImJ1dHRvblwiIGNsYXNzPVwiYnRuIGJ0bi1pY29uIHNoZXZyb24gdXAgYmx1ZSB2aWV3LWNvbnRyb2xcIiBkYXRhLXRvZ2dsZT1cImNvbGxhcHNlXCIgZGF0YS1wYXJlbnQ9XCIjcmVzcG9uc2VcIiBhcmlhLWV4cGFuZGVkPVwiZmFsc2VcIj48L2J1dHRvbj5cclxuXHRcdFx0XHQ8IS0tIC9rbyAtLT5cclxuXHRcdFx0XHQ8IS0tIGtvIGlmbm90OiBoYXNSZXNwb25zZSAtLT5cclxuXHRcdFx0XHRcdDxidXR0b24gZGF0YS1iaW5kPVwicG9wb3Zlcjoge3R5cGU6ICdwb3BvdmVyJywgdHJpZ2dlcjogJ2NsaWNrJywgZGF0YTogZGF0YS5lcnJvcn1cIiBjbGFzcz1cImJ0biBidG4taWNvbiBidG4tYWxlcnQgdmlldy1jb250cm9sXCI+PC9idXR0b24+XHJcblx0XHRcdFx0PCEtLSAva28gLS0+XHJcblx0XHRcdDwvZGl2PlxyXG5cdFx0XHQ8c3BhbiBkYXRhLWJpbmQ9XCJjc3M6IGNvbG9yXCIgY2xhc3M9XCJjb2xvci1pbmRpY2F0b3Igdmlldy1jb250cm9sXCI+PC9zcGFuPlxyXG5cdFx0XHQ8cCBkYXRhLWJpbmQ9XCJ0ZXh0OiByZXEsIGJsb2NrRWxsaXBzaXM6IHtjbGFtcDogMn1cIiBjbGFzcz1cIml0ZW1fdGV4dFwiPjwvcD5cclxuXHRcdDwvc2VjdGlvbj5cclxuYH0pO1xyXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zY3JpcHRzL2FwaS1leHBsb3Jlci92Mi9zcmMvY29tcG9uZW50cy9yZXF1ZXN0L3JlcXVlc3QuY29tcG9uZW50LmpzIiwiY2xhc3MgUmVzcG9uc2VDb21wb25lbnR7XHJcblx0Y29uc3RydWN0b3Ioe2RhdGEsIGluZGV4LCBjb25maWcsIHNldFBhcmFtcywgZ2V0UmFuZG9tQ29sb3J9KSB7XHJcblx0XHR0aGlzLmluZGV4ID0ga28udW53cmFwKGluZGV4KTtcclxuXHRcdHRoaXMuZGF0YSA9IGRhdGE7XHJcblx0XHR0aGlzLmhhc1Jlc3BvbnNlID0gISFkYXRhLnJlc3BvbnNlO1xyXG5cdFx0dGhpcy5yZXNIVE1MID0gZGF0YS5yZXNIVE1MO1xyXG5cdFx0dGhpcy5jb2xvciA9IGRhdGEuY29sb3I7XHJcblx0XHR0aGlzLmNvbmZpZyA9IGNvbmZpZztcclxuXHRcdHRoaXMuc2V0UGFyYW1zID0gc2V0UGFyYW1zO1xyXG5cdFx0dGhpcy5yZXNwb25zZSA9IGRhdGEucmVzcG9uc2U7XHJcblx0XHR0aGlzLnJlcSA9IGRhdGEucmVxO1xyXG5cclxuXHRcdHRoaXMuYnJlYWRjcnVic0FyciA9IFtdO1xyXG5cdFx0dGhpcy5icmVhZGNydW1icyA9IGtvLm9ic2VydmFibGUoJycpO1xyXG5cclxuXHRcdHRoaXMuYXR0cnMgPSB7XHJcblx0XHRcdHdyYXBwZXI6IHtcclxuXHRcdFx0XHRpZDogYGNvbGxhcHNlLSR7dGhpcy5pbmRleH1gLFxyXG5cdFx0XHRcdCdhcmlhLWxhYmVsbGVkYnknOiBgaGVhZGluZy0ke3RoaXMuaW5kZXh9YCxcclxuXHRcdFx0fSxcclxuXHRcdFx0dGFiczoge1xyXG5cdFx0XHRcdGpzb246IHtcclxuXHRcdFx0XHRcdGhyZWY6IGAjanNvbi0ke3RoaXMuaW5kZXh9YCxcclxuXHRcdFx0XHRcdCdhcmlhLWNvbnRyb2xzJzogYGpzb24tJHt0aGlzLmluZGV4fWBcclxuXHRcdFx0XHR9LFxyXG5cdFx0XHRcdGJsb2Nrczoge1xyXG5cdFx0XHRcdFx0aHJlZjogYCNzbGlkZXItJHt0aGlzLmluZGV4fWAsXHJcblx0XHRcdFx0XHQnYXJpYS1jb250cm9scyc6IGBibG9ja3MtJHt0aGlzLmluZGV4fWBcclxuXHRcdFx0XHR9XHJcblx0XHRcdH0sXHJcblx0XHRcdHZpZXc6IHtcclxuXHRcdFx0XHRqc29uOiB7XHJcblx0XHRcdFx0XHRpZDogYGpzb24tJHt0aGlzLmluZGV4fWBcclxuXHRcdFx0XHR9LFxyXG5cdFx0XHRcdGJsb2Nrczoge1xyXG5cdFx0XHRcdFx0aWQ6IGBzbGlkZXItJHt0aGlzLmluZGV4fWBcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdH07XHJcblxyXG5cdFx0a28ucG9zdGJveC5zdWJzY3JpYmUoJ0FOT1RIRVJfUkVTUE9OU0UnLCAoe2RhdGEsIHBhbmVsR3JvdXAsIGNvbG9yfSkgPT4ge1xyXG5cdFx0XHRsZXQgcmVzcG9uc2UgPSBwYW5lbEdyb3VwLnByZXBhcmVEYXRhKHtwYXJhbXM6IHtkYXRhOiBkYXRhLnJlc3BvbnNlfX0pO1xyXG5cdFx0XHR0aGlzLmdldE1vcmUoe1xyXG5cdFx0XHRcdGlkOiBwYW5lbEdyb3VwLmdyb3VwSW5kZXgsXHJcblx0XHRcdFx0ZGF0YTogcmVzcG9uc2UsXHJcblx0XHRcdFx0cEdyb3VwOiBwYW5lbEdyb3VwLFxyXG5cdFx0XHRcdGNvbG9yXHJcblx0XHRcdH0pO1xyXG5cdFx0fSk7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBnZXQgZGV0YWlsc1xyXG5cdCAqL1xyXG5cdGdldE1vcmUgPSAoe3BhbmVsID0ge30sIGlkLCBkYXRhLCBwR3JvdXAsIGNvbG9yfSkgPT4ge1xyXG5cdFx0bGV0IHBhbmVsR3JvdXAgPSBwR3JvdXAgfHwgcGFuZWwucGFuZWxHcm91cDtcclxuXHRcdGxldCBjdXJyZW50U2xpZGVyID0gJCgnI3NsaWRlci0nICsgcGFuZWxHcm91cC5zZWN0aW9uSW5kZXgpO1xyXG5cdFx0bGV0IGNvbXBvbmVudCA9ICQoJzxzZWN0aW9uIGRhdGEtYmluZD1cImNvbXBvbmVudDoge25hbWU6IFxcJ3BhbmVsLWdyb3VwXFwnLCBwYXJhbXM6IHBhcmFtc31cIj48L3NlY3Rpb24+Jyk7XHJcblx0XHRsZXQgY3Vyc2xpY2sgPSBjdXJyZW50U2xpZGVyLnNsaWNrKCdnZXRTbGljaycpO1xyXG5cclxuXHRcdC8vIGV4dGVuZGluZyBhZGRpdGlvbmFsIGRhdGEgKGNvcHkpXHJcblx0XHRsZXQgcGFyYW1zID0gJC5leHRlbmQoe30sIHBhbmVsR3JvdXAsIHtcclxuXHRcdFx0ZGF0YTogZGF0YSxcclxuXHRcdFx0Z3JvdXBJbmRleDogcGFuZWxHcm91cC5ncm91cEluZGV4ICsgMSxcclxuXHRcdFx0X3Byb3BUaXRsZTogdHlwZW9mIGlkID09PSAnc3RyaW5nJyAmJiBpZCB8fCAnb2JqZWN0JyxcclxuXHRcdFx0Y29uZmlnOiBwYW5lbC5jb25maWcsXHJcblx0XHRcdGNvbG9yQ2xhc3M6IGNvbG9yXHJcblx0XHR9KTtcclxuXHJcblx0XHQvLyBhcHBseSBjb21wb25lbnQgZGF0YSBiaW5kaW5nc1xyXG5cdFx0a28uYXBwbHlCaW5kaW5ncyh7XHJcblx0XHRcdHBhcmFtczogcGFyYW1zXHJcblx0XHR9LCBjb21wb25lbnRbMF0pO1xyXG5cclxuXHRcdC8vIGJ1aWxkIGJyZWFkY3J1YnNcclxuXHRcdHRoaXMuYnVpbGRCcmVhZGNydW1icyh7aW5kZXg6IHBhbmVsR3JvdXAuZ3JvdXBJbmRleCwgcGFyZW50OiBwYW5lbC5fcGFuZWxOYW1lLCBjdXJyZW50OiBpZH0pO1xyXG5cclxuXHRcdC8vIGFkZCBzbGlkZSB3aXRoIHNlbGVjdGVkIGRhdGFcclxuXHRcdGN1cnJlbnRTbGlkZXIuc2xpY2soJ3NsaWNrQWRkJywgY29tcG9uZW50KTtcclxuXHRcdC8vIHJlbW92ZSBvdXRzdGFuZGluZyBzbGlkZXNcclxuXHRcdGZvciAodmFyIGkgPSBjdXJzbGljay5zbGlkZUNvdW50IC0gMjsgaSA+IHBhbmVsR3JvdXAuZ3JvdXBJbmRleDsgaS0tKSB7XHJcblx0XHRcdGN1cnJlbnRTbGlkZXIuc2xpY2soJ3NsaWNrUmVtb3ZlJywgaSwgZmFsc2UpO1xyXG5cdFx0fVxyXG5cdFx0Ly8gbW92ZSB0byBuZXh0IHNsaWRlXHJcblx0XHRzZXRUaW1lb3V0KCgpID0+IHtcclxuXHRcdFx0Y3VycmVudFNsaWRlci5zbGljaygnc2xpY2tOZXh0Jyk7XHJcblx0XHR9LCAzMTApO1xyXG5cdH07XHJcblxyXG5cdGJ1aWxkQnJlYWRjcnVtYnMoe2luZGV4LCBwYXJlbnQsIGN1cnJlbnR9KSB7XHJcblx0XHRsZXQgc3RyID0gaW5kZXggPyAnLycgOiAnJztcclxuXHJcblx0XHRpZiAodHlwZW9mIGN1cnJlbnQgPT09ICdudW1iZXInKSB7XHJcblx0XHRcdHN0ciArPSBgJHtwYXJlbnR9WyR7Y3VycmVudH1dYFxyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0c3RyICs9IGAke3BhcmVudH0vJHtjdXJyZW50fWBcclxuXHRcdH1cclxuXHRcdHRoaXMuYnJlYWRjcnVic0FycltpbmRleF0gPSBzdHI7XHJcblx0XHR0aGlzLmJyZWFkY3J1YnNBcnIubGVuZ3RoID0gaW5kZXggKyAxO1xyXG5cclxuXHRcdHRoaXMuYnJlYWRjcnVtYnModGhpcy5icmVhZGNydWJzQXJyLmpvaW4oJycpKTtcclxuXHR9XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0ga28uY29tcG9uZW50cy5yZWdpc3RlcigncmVzcG9uc2UtY29tcG9uZW50Jywge1xyXG5cdHZpZXdNb2RlbDogUmVzcG9uc2VDb21wb25lbnQsXHJcblx0dGVtcGxhdGU6YFxyXG5cdFx0PCEtLSBrbyBpZjogaGFzUmVzcG9uc2UgLS0+XHJcblx0XHQ8c2VjdGlvbiBjbGFzcz1cInJlc3BvbnNlIGNvbGxhcHNlXCIgZGF0YS1iaW5kPVwiYXR0cjogYXR0cnMud3JhcHBlclwiIHJvbGU9XCJ0YWJwYW5lbFwiPlxyXG5cdFx0XHRcdDxkaXYgY2xhc3M9XCJyb3ctY29udGFpbmVyXCI+XHJcblx0XHRcdFx0XHJcblx0XHRcdFx0XHQ8IS0tIE5hdiB0YWJzIC0tPlxyXG5cdFx0XHRcdFx0PHVsIGNsYXNzPVwibmF2IG5hdi10YWJzIHRhYnMtY29udHJvbGxzXCIgcm9sZT1cInRhYmxpc3RcIj5cclxuXHRcdFx0XHRcdFx0PGxpIHJvbGU9XCJwcmVzZW50YXRpb25cIiBjbGFzcz1cInRhYlwiPlxyXG5cdFx0XHRcdFx0XHRcdDxhIGRhdGEtYmluZD1cImF0dHI6IGF0dHJzLnRhYnMuanNvblwiIGNsYXNzPVwidGFiLWJ0blwiIGhyZWY9XCIjanNvblwiIGFyaWEtY29udHJvbHM9XCJqc29uXCIgcm9sZT1cInRhYlwiIGRhdGEtdG9nZ2xlPVwidGFiXCI+SnNvbjwvYT5cclxuXHRcdFx0XHRcdFx0PC9saT5cclxuXHRcdFx0XHRcdFx0PGxpIHJvbGU9XCJwcmVzZW50YXRpb25cIiBjbGFzcz1cInRhYiBhY3RpdmVcIj5cclxuXHRcdFx0XHRcdFx0XHQ8YSBkYXRhLWJpbmQ9XCJhdHRyOiBhdHRycy50YWJzLmJsb2Nrc1wiIGNsYXNzPVwidGFiLWJ0blwiIGhyZWY9XCIjYmxvY2tzXCIgYXJpYS1jb250cm9scz1cImJsb2Nrc1wiIHJvbGU9XCJ0YWJcIiBkYXRhLXRvZ2dsZT1cInRhYlwiPkJsb2NrczwvYT5cclxuXHRcdFx0XHRcdFx0PC9saT5cclxuXHRcdFx0XHRcdDwvdWw+XHJcblx0XHRcdFx0XHRcclxuXHRcdFx0XHRcdDx1bCBjbGFzcz1cIm5hdiBuYXYtdGFicyBpbmZvXCI+XHJcblx0XHRcdFx0XHRcdDxsaSBjbGFzcz1cInRhYlwiPlxyXG5cdFx0XHRcdFx0XHRcdDxkaXYgY2xhc3M9XCJ0YWItbGFiZWxcIj5cclxuXHRcdFx0XHRcdFx0XHRcdDxzcGFuIGRhdGEtYmluZD1cInZpc2libGU6IGJyZWFkY3J1bWJzXCI+U3RydWN0dXJlOjwvc3Bhbj5cclxuXHRcdFx0XHRcdFx0XHQ8L2Rpdj5cclxuXHRcdFx0XHRcdFx0PC9saT5cclxuXHRcdFx0XHRcdFx0PGxpIGNsYXNzPVwidGFiXCI+XHJcblx0XHRcdFx0XHRcdFx0PHNwYW4gZGF0YS1iaW5kPVwidGV4dDogYnJlYWRjcnVtYnNcIiBjbGFzcz1cInRhYi1sYWJlbCBicmVhZGNydW1icyB0cnVuY2F0ZVwiPjwvc3Bhbj5cclxuXHRcdFx0XHRcdFx0PC9saT5cclxuXHRcdFx0XHRcdDwvdWw+XHJcblxyXG5cdFx0XHRcdFx0PCEtLSBUYWIgcGFuZXMgLS0+XHJcblx0XHRcdFx0XHQ8ZGl2IGNsYXNzPVwicm93XCI+XHJcblx0XHRcdFx0XHRcdDxkaXYgY2xhc3M9XCJ0YWItY29udGVudCBjb2wteHMtMTJcIj5cclxuXHRcdFx0XHRcdFx0XHQ8IS0tIGpzb24gLS0+XHJcblx0XHRcdFx0XHRcdFx0PGRpdiBkYXRhLWJpbmQ9XCJzY3JvbGw6IHt4OiBmYWxzZSwgeTogdHJ1ZX0sIGF0dHI6IGF0dHJzLnZpZXcuanNvblwiIHJvbGU9XCJ0YWJwYW5lbFwiIGNsYXNzPVwidGFiLXBhbmUgcHJldHktanNvblwiIGlkPVwianNvblwiPlxyXG5cdFx0XHRcdFx0XHRcdFx0PHAgZGF0YS1iaW5kPVwiaHRtbDogcmVzSFRNTFwiPjwvcD5cclxuXHRcdFx0XHRcdFx0XHQ8L2Rpdj5cclxuXHRcdFx0XHRcdFx0XHQ8IS0tIGJsb2NrcyAtLT5cclxuXHRcdFx0XHRcdFx0XHQ8ZGl2IGRhdGEtYmluZD1cImF0dHI6IGF0dHJzLnZpZXcuYmxvY2tzXCIgcm9sZT1cInRhYnBhbmVsXCIgY2xhc3M9XCJ0YWItcGFuZSBibG9ja3MgYWN0aXZlXCIgaWQ9XCJibG9ja3NcIj5cclxuXHRcdFx0XHRcdFx0XHRcdDxwYW5lbC1ncm91cCBwYXJhbXM9XCJcclxuXHRcdFx0XHRcdFx0XHRcdFx0Y2F0ZWdvcnk6IGRhdGEuY2F0ZWdvcnksXHJcblx0XHRcdFx0XHRcdFx0XHRcdG1ldGhvZDogZGF0YS5tZXRob2QsXHJcblx0XHRcdFx0XHRcdFx0XHRcdG1ldGhvZElkOiBkYXRhLm1ldGhvZElkLFxyXG5cdFx0XHRcdFx0XHRcdFx0XHRwYXJhbXM6IGRhdGEucGFyYW1zLFxyXG5cdFx0XHRcdFx0XHRcdFx0XHRkYXRhOiBkYXRhLnJlc3BvbnNlLFxyXG5cdFx0XHRcdFx0XHRcdFx0XHRjb2xvckNsYXNzOiBkYXRhLmNvbG9yLFxyXG5cdFx0XHRcdFx0XHRcdFx0XHRzZWN0aW9uSW5kZXg6IGluZGV4LFxyXG5cdFx0XHRcdFx0XHRcdFx0XHRmaWx0ZXI6IGNvbmZpZyxcclxuXHRcdFx0XHRcdFx0XHRcdFx0c2V0UGFyYW1zOiBzZXRQYXJhbXMsXHJcblx0XHRcdFx0XHRcdFx0XHRcdGdldE1vcmU6IGdldE1vcmVcclxuXHRcdFx0XHRcdFx0XHRcdFx0XCI+XHJcblx0XHRcdFx0XHRcdFx0XHQ8L3BhbmVsLWdyb3VwPlxyXG5cdFx0XHRcdFx0XHRcdDwvZGl2PlxyXG5cdFx0XHRcdFx0XHQ8L2Rpdj5cclxuXHRcdFx0XHRcdDwvZGl2PlxyXG5cdFx0XHRcdDwvZGl2PlxyXG5cdFx0PC9zZWN0aW9uPlxyXG5cdFx0PCEtLSAva28gLS0+XHRcclxuYH0pO1xyXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zY3JpcHRzL2FwaS1leHBsb3Jlci92Mi9zcmMvY29tcG9uZW50cy9yZXF1ZXN0L3Jlc3BvbnNlLmNvbXBvbmVudC5qcyJdLCJzb3VyY2VSb290IjoiIn0=